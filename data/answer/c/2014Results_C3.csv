21162503,496448,8,"<p>A very good article that I came about the <code>extern</code> keyword, along with the examples: <a href=""http://www.geeksforgeeks.org/understanding-extern-keyword-in-c/"" rel=""nofollow"">http://www.geeksforgeeks.org/understanding-extern-keyword-in-c/</a></p>

<p>Though I do not agree that using <code>extern</code> in function declarations is redundant. This is supposed to be a compiler setting. So I recommend using the <code>extern</code> in the function declarations when it is needed. </p>
",1
28150561,28150386,1,"<p>You can easily try to test how many bytes a string has. If I compile it on my machine with the following code:</p>

<pre><code>char s[] = ""AAA"";
char m[] = ""XÉú"";
printf(""s: %d\n"", sizeof(s));
printf(""m: %d\n"", sizeof(m));
</code></pre>

<p>I'll get as an result the output </p>

<pre><code>s: 4
m: 5
</code></pre>

<p>That means ""s"" isn't a multibyte string but ""m"" is. To make sure your compiler/system behaves the same way, I would just test it on your system.</p>
",1
28150667,28150386,3,"<p>So the <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf"" rel=""nofollow"">C99 draft standard</a> (<em>C11 looks the same</em>) defines multibyte character as follows:</p>

<blockquote>
  <p>sequence of one or more bytes representing a member of the extended character set of
  either the source or the execution environment</p>
</blockquote>

<p>So a <em>multibyte character</em> is part of the extended character set, so <code>s</code> is not made up of multi-byte characters. </p>

<p><em>multibyte characters</em> are further defined in section <code>5.2.1.2</code>:</p>

<blockquote>
  <p>The source character set may contain multibyte characters, used to
  represent members of the extended character set. The execution
  character set may also contain multibyte characters, which need not
  have the same encoding as for the source character set. For both
  character sets, the following shall hold:</p>
  
  <ul>
  <li><p>The basic character set shall be present and each character shall be encoded as a single byte.</p></li>
  <li><p>The presence, meaning, and representation of any additional members is locales pecific.</p></li>
  <li><p>A multibyte character set may have a state-dependent encoding, wherein each sequence of multibyte characters begins in an initial
  shift state and enters other locale-specific shift states when
  specific multibyte characters are encountered in the sequence. While
  in the initial shift state, all single-byte characters retain their
  usual interpretation and do not alter the shift state. The
  interpretation for subsequent bytes in the sequence is a function of
  the current shift state.</p></li>
  <li><p>A byte with all bits zero shall be interpreted as a null character
  independent of shift state. Such a byte shall not occur as part of any
  other multibyte character.</p></li>
  </ul>
</blockquote>
",0
27678537,867979,3,"<p>In this simple way</p>

<pre><code>char str [10] = ""IAmCute"";
printf (""%c"",str[4]);
</code></pre>
",0
24635989,24635500,1,"<p>A function type characterize by its return type as well as its number of parameters and type of its parameters. When you declare a function as    </p>

<pre><code>double bar(int a, int b);  
</code></pre>

<p>it means that <code>bar</code> is a function of <em>type</em> which accepts two parameters of type <code>int</code> and returns a <code>double</code> value. You can also understand a function type as  </p>

<pre><code>double (*fptr)(int, int);
</code></pre>

<p><code>fptr</code> is a pointer which can hold the address of function type taking two parameters of <code>int</code> type and returning <code>double</code>.    </p>

<p>When standard says that a function type cannot return a function type or an array type, it means  </p>

<p>A function can't return functions  </p>

<pre><code>int f(int ) (int );  //Wrong
</code></pre>

<p>A function can't return  arrays:  </p>

<pre><code>int f(int ) [];      //Wrong   
</code></pre>

<p>But, pointer to functions/arrays can be returned from a function. </p>
",0
24635537,24635500,6,"<p>It's right there in the text you quoted, ""and the number and types of its parameters"", so yes the parameters matter.</p>

<p>The type  of the example function would be <code>double (int, int)</code>, I'm not sure about the notation but something like that.</p>

<p>I.e. ""a function that takes two <code>int</code> arguments and returns a <code>double</code>"".</p>
",0
24636009,24635500,0,"<p>The bottom line is, a function is a normal identifier like any other; it's just what it denotes, namely a function, which differs from normal objects. Functions in C/C++ are not objects; they cannot be passed or changed. But function <strong>pointers</strong> can. In that functions and their pointers resemble arrays, to a degree. Another parallel is the pragmatic C approach which almost identifies arrays as well as functions with their location in memory; it's just that we have data here (arrays) and code there (functions).</p>

<p>The type of a function can be obtained like any other type (e.g. <code>int</code>, or <code>int*</code>) by omitting the identifier from a declaration. That gives you the <code>double (int, int)</code> the others correctly mentioned. Each sequence denoting a type has exactly one position where an identifier can be legally inserted (here after the double).</p>

<p>But back to the bottom line: A function name is just an identifier with a type. Let's say we have a function definition in one file and want to use it in another, as is common:</p>

<p>File 1: Normal function definition</p>

<pre><code>double external_function(int a, int b) 
{ 
    return a+b;
}
</code></pre>

<p>File 2: Declare an identifier for that function and use it. Then do something bogus.</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

// Declare a function type alias (not a pointer type!)
typedef double function_type(int, int);

// Use that to declare that identifier. Not different from 
// any other identifier.
extern function_type external_function;

// Also totally equivalent to the conventional notation;
// it's not harmful to declare the same global identifier
// multiple times.
extern double external_function(int, int);

// Define a function with a different signature, i.e.
// a different type. We'll use it in a joke in main().
double f_float_float(float f1, float f2) 
{ 
    return f1 + f2; 
}

int main()
{
    // Call the previously declared external function: -&gt; 3.
    cout &lt;&lt; external_function(1,2) &lt;&lt; endl;

    // Do something funny: Declare a pointer to such a function ...
    function_type *function_pointer;

    // ... and assign a function with the wrong type to it.
    // function_pointer = f_float_float; /* doesn't compile: need cast */
    function_pointer = reinterpret_cast&lt;double (*)(int, int)&gt;(f_float_float);

    // Now call it with certain values 
    // (cf. http://www.cprogramming.com/tutorial/floating_point/understanding_floating_point_representation.html)
    // and see what happens.
    cout &lt;&lt; function_pointer(0x3f800000, 0x40400000) &lt;&lt; endl;

    return 0;
}
</code></pre>
",0
24635679,24635500,3,"<blockquote>
  <p>A function type describes a function with speci?ed return type. A
  function type is characterized by its return type and the number and
  <strong><em>types</em> of its parameters</strong></p>
</blockquote>

<p>So, the parameters types are part of the function type. <code>double bar(int a, int b)</code> has the same type as <code>double foo(int c, int d)</code>, but not the same type as <code>double foo(int a, double b)</code>.</p>

<p>You could assign bar to a function pointer like:</p>

<pre><code>double (*func)(int, int) = bar;
</code></pre>
",5
22475833,22475705,1,"<p>There is no requirement in the C standard to ""destroy"" the data stored in a variable that goes out of scope.</p>

<p>It isn't safe to access <code>a</code> after it has gone out of scope.  The memory is free to use for other purposes. What happens if you access the memory is unspecified. It may return the value you put there, it may return some other (junk) value, it may cause a program crash or it may blow up the island of Manhattan. </p>

<p>The last option is very unlikely though, I haven't come across any C compiler that generates code that does that. </p>
",0
22475843,22475705,1,"<p><code>a</code> is a local variable. ""Local"" as in function-local. <code>a</code> doesn't exist any more once <code>test()</code> returns. Thus you return a pointer to an object that doesn't exist any more, and the compiler rightly complains.</p>

<p>You can either pass an array as parameter to <code>test()</code> and fill that array within <code>test()</code>, or you can actively allocate memory on the heap with <code>malloc()</code> within <code>test()</code> and return a pointer to that. Note that the caller then has to <code>free()</code> said memory again to prevent memory leaking.</p>
",3
22475848,22475705,3,"<p>The requirement is not for the memory to be ""destroyed"" (whatever it could mean - filling with zeros?) the standard says only that such code as yours triggers undefined behaviour - and undefined behaviour may mean anything, including the situation in which the memory for some time has the same content. But still it is undefined behaviour and your code is erroneous.</p>
",0
29245755,29245708,1,"<p>Try this:</p>

<pre><code>#define SIZEOF(TYPE) \
    ({ \
    TYPE _array_[2]; \
    (char*)(&amp;_array_[1]) - (char*)(&amp;_array_[0]); \
    })
</code></pre>

<p>...although it uses gcc specific support for statements inside expressions, so I would recommend using the standard <code>sizeof</code> operator instead.</p>

<p>How to actually use this:</p>

<pre><code>printf(""Size Of Integer = %d"", (int)SIZEOF(int));
</code></pre>

<p>i.e. it works as a pretty good replacement for <code>sizeof</code> on compilers that actually allow the dirty trick of statements inside expressions.</p>
",0
29245771,29245708,3,"<p>Macro expansion is a text replacement. Your code expands to:</p>

<pre><code>int x = int _array_[2]; size = (char*)(&amp;_array_[1]) - (char*)(&amp;_array_[0]);
</code></pre>

<p>The initial part <code>int x = int</code> is a syntax error.</p>

<p>You could make your code work without changing the macro by writing:</p>

<pre><code>SIZEOF(int);
printf(""Size Of Integer = %d"", size);
</code></pre>

<p>An improvement would be to pass the name of the variable as a parameter to the macro, instead of using global variables.</p>
",1
29462790,29462752,6,"<p>As per its <a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/chdir.html"">documentation</a></p>

<blockquote>
  <p>The chdir() function only affects the working directory of the <strong>current</strong> process.</p>
</blockquote>

<p>So you cannot change the directory of the parent process.</p>
",1
30143805,53161,0,"<p>A nifty solution I came up with is to binary search the bits.</p>

<pre><code>uint64_t highestBit(uint64_t a, uint64_t bit_min, uint64_t bit_max, uint16_t bit_shift){
    if(a == 0) return 0;
    if(bit_min &gt;= bit_max){
        if((a &amp; bit_min) != 0)
            return bit_min;
        return 0;
    }
    uint64_t bit_mid = bit_max &gt;&gt; bit_shift;
    bit_shift &gt;&gt;= 1;
    if((a &gt;= bit_mid) &amp;&amp; (a &lt; (bit_mid &lt;&lt; 1)))
        return bit_mid;
    else if(a &gt; bit_mid)
        return highestBit(a, bit_mid, bit_max, bit_shift);
    else
        return highestBit(a, bit_min, bit_mid, bit_shift);

}
</code></pre>

<p>Bit max is the highest power of 2, so for a 64 bit number it would be 2^63. Bit shift should be initialized to half the number of bits, so for 64 bits, it would be 32.</p>
",0
22428098,1759057,0,"<p>I'm using a trick which is working for me.</p>

<pre><code>struct hello{
    ....;
    ....;
    ....;
};

struct hello *t;

t=malloc(sizeof(struct hello));
free(t);
t=NULL;
</code></pre>

<p>Now u can easily check if <code>t</code> is initialized or not. And there is no memory leak at all.</p>
",0
23086456,23086370,6,"<p>Undefined behavior: you do not allocate space for the null terminator.  You should enable warnings in your compiler, which should catch this.</p>
",0
23086509,23086370,2,"<p>It would be an undefined behavior as your source array <code>s</code> has not enough space for terminating null ie, <code>\0</code>. Enable your compiler warnings.</p>

<p>You can change your array like</p>

<pre><code>char s[7]=""ABCDEF"";
</code></pre>

<p>From the C99 standard</p>

<blockquote>
  <p>An array of character type may be initialized by a character string
  literal, optionally enclosed in braces. Successive characters of the
  character string literal (including the terminating null character if
  there is room or if the array is of unknown size) initialize the
  elements of the array</p>
</blockquote>
",5
23086520,23086370,3,"<p>Your problem lies with the statement <code>char s[6]=""ABCDEF"";</code>. There's no space for a null terminator which is what all the standard library string functions (and your function <code>mystrlen</code>) require.</p>

<p>Use <code>char s[]=""ABCDEF"";</code> instead. In doing this, the null terminator is added for you automatically - that's how quoted literals work: think of the closing quotation as including an implicit <code>\0</code>. Also, C will calculate the size of the array for you so there's no need to specify that.</p>

<p>Formally the behaviour of your program is currently <em>undefined</em>. It's not just compiler-dependent but anything dependent.</p>
",2
24599796,1488569,3,"<p>No, you shouldn't use the above instead of <code>atoi</code>.</p>

<p>You should actually check the error information that <code>strtol</code> makes available:</p>

<pre><code>i = atoi(s);
</code></pre>

<p>should be replaced by</p>

<pre><code>char* stopped;
i = (int)strtol(s, &amp;stopped, 10);
if (*stopped) { /* handle error */ }
</code></pre>
",0
29456537,29456437,1,"<p>Since the other pointers point to constant values, the data is already put into memory by the compiler. You cannot change them or the data they point to (the data is literal and resides in read-only memory block). The tmp variable will point into a mutable part of memory so you need to allocate it as such. </p>

<p>Of course you could allocate the memory statically so that you wouldn't need malloc for that either, but dynamic allocations are, as the name says, dynamic so you can allocate whatever amount you need defined run time and nor compile time. Like in this case, the amount of memory is not known while compiling. </p>
",0
26444066,26444041,4,"<p>The compiler sees you declaring <code>g_argv</code> as an array of char pointers, but you don't specify how many.</p>
",0
26444204,26444041,3,"<pre><code>int main(int argc, char *argv[])
</code></pre>

<p>Despite what it looks like, argv is not an array; arrays aren't first class objects in C and cannot be passed to functions, only their addresses can. So because argv is a parameter, it's actually a pointer to a pointer. For this reason I think it's better to tell the truth and use</p>

<pre><code>int main(int argc, char** argv)
</code></pre>

<p>which is exactly equivalent to the above. This confusion in the language has led you to</p>

<pre><code>char* g_argv[];
</code></pre>

<p>You're saying this is an array of pointers, without saying how big the array is, but that's not what you want; you want a pointer to the first of several pointers:</p>

<pre><code>char** g_argv;
</code></pre>

<p>That fixes the problem you asked about, but I wonder about this declaration:</p>

<pre><code>u64 get_env(char *argv[]);
</code></pre>

<p>Why declare it as returning u64 when the name and usage clearly indicate that it returns a <code>char*</code>? Actually, you should not be declaring it here at all ... it should be declared in a header file that specifies the API that includes get_env. Hopefully that header file declares it as returning a <code>char*</code>, and then you can remove the cast from</p>

<pre><code>return (char*)get_env(g_argv);
</code></pre>
",1
26812019,810129,-2,"<p>Well this is true just in the case of the char if there is no \0 and the it is an integer array the the program will crash because there will be a address whose elements are not the part of the array or pointer, if the system has memory that was allocated using the malloc then the system will keep giving the memory</p>
",0
24614148,3784263,-2,"<p>The problem is arising as unsigned char is a 4 byte number not a 1 byte number as many think, so change it to</p>

<pre><code>union {
unsigned int integer;
char byte[4];
} temp32bitint;
</code></pre>

<p>and cast while printing, to prevent promoting to 'int' (which C does by default)</p>

<pre><code>printf(""%u, %u \n"", (unsigned char)Buffer[0], (unsigned char)Buffer[1]);
</code></pre>
",0
24116251,24116172,8,"<p><strong>REWRITTEN</strong>: I guess I mis-read the spec, as pointed out by @Lundin. A better answer seems to be that the names used in this part of the standard don't make a lot of sense.</p>

<p>Of course both postfix and prefix increment/decrement are both just as unary as the other. That's how they're used. The fact that they have different priorities mean that they are put in different groups, and the groups have historical names which are a bit off.</p>
",3
24116262,24116172,3,"<p>You are referring to the C standard, of which one draft of one version is <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf"" rel=""nofollow"">here</a>.</p>

<p>The reason why postfix inc/decrement are in a different section than prefix inc/decrement is that this part of the standard follows the grammar, and that in order to remove ambiguity, these operators are at different levels of the grammar:</p>

<pre>
unary-expression: 
  postfix-expression
  ++ unary-expression
  -- unary-expression
  ...


postfix-expression:
  primary-expression
  ...
  postfix-expression ++
  postfix-expression --
</pre>

<p>This allows an expression such as <code>++ E ++</code> (while such an expression would never be valid anyway) to be parsed unambiguously as <code>++(E++)</code>).</p>
",0
24116274,24116172,1,"<p>I guess that it is just a question of structure of the standard. The C11 standard has a special section for postfix operators, so they are not classified with the rest of infix and prefix operators. Mathematically, they are of course unary.</p>
",2
24116425,24116172,1,"<p>Firstly, Postfix operators are left-associative, and Unary operators are right-associative.</p>

<p>Secondly, Postfix operators have higher precedence than Unary operators.</p>
",0
24118257,24116172,2,"<p>@Pascal Cuoq answered why they are in different groups: it is because they have different precedence and for no other reason. It has little to do with whether they are actually unary or binary operators.</p>

<p>The reason why the C uses confused names for the operator groups is most likely this classic, yet incorrect table:</p>

<p><strong>K&amp;R 2nd edition page 48.</strong>
<img src=""https://i.stack.imgur.com/qXIfT.jpg"" alt=""enter image description here""></p>

<p>This table is to blame for a lot of evil in the world. K&amp;R originally listed ""everything unary"" as one operator group. But of course this is correct: it doesn't make sense for the postfix ++ -- to be grouped with the prefix operators. </p>

<p>As C was standardized, the committee likely realized that this table didn't make any sense, so they made additional groups. Out of the two top groups in the K&amp;R table, they made three. One group for primary expression (plain parenthesis <code>()</code> included there), one group for postfix ones and one group still called unary, likely because of historical reasons. A better name for the latter would no doubt have been prefix operators, but the C standard isn't exactly known to be rational.</p>
",2
28197109,28197006,4,"<p><code>%s</code> consumes everything <strong>until</strong> a whitespace character and discards <strong>leading</strong> whitespace characters not trailing ones. The <code>[</code> conversion specifier in the second <code>scanf</code> does not skip leading whitespace characters and therefore, fails to scan because of the newline character(which is a whitespace character) left over by the first <code>scanf</code>.</p>

<p>To fix the issue, either use</p>

<pre><code>int c;
while((c=getchar())!='\n' &amp;&amp; c!=EOF);
</code></pre>

<p>After the first <code>scanf</code> to clear the <code>stdin</code> or add a space before the format specifier(<code>%[</code>) in the second <code>scanf</code>.</p>
",0
28197117,28197006,4,"<blockquote>
  <p>So also %s doesn't discard a new line?</p>
</blockquote>

<p><code>%s</code> tells <code>scanf</code> to discard any <em>leading</em> whitespace, including newlines.  It will then read any non-whitespace characters, leaving any trailing whitespace in the input buffer.</p>

<p>So assuming your input stream looks like <code>""\n\ntest\n""</code>, <code>scanf(""%s"", buf)</code> will discard the two leading newlines, consume the string <code>""test""</code>, and leave the trailing newline in the input stream, so after the call the input stream looks like <code>""\n""</code>.  </p>

<p><strong>Edit</strong></p>

<p>Responding to xdevel2000's comment here.</p>

<p>Let's talk about how conversion specifiers work.  Here are some relevant paragraphs from the <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""nofollow"">online C 2011 standard</a>:</p>

<blockquote>
<strong>7.21.6.2 The fscanf function</strong><br>
...<br>
9 An input item is read from the stream, unless the specification includes an n specifier. An input item is defined as the longest sequence of input characters which does not exceed any specified field width and which is, or is a prefix of, a matching input sequence.<sup>285)</sup>
The first character, if any, after the input item remains unread. If the length of the input item is zero, the execution of the directive fails; this condition is a matching failure unless end-of-file, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.<br>
<br>
10 Except in the case of a <code>%</code> specifier, the input item (or, in the case of a <code>%n</code> directive, the
count of input characters) is converted to a type appropriate to the conversion specifier. If the input item is not a matching sequence, the execution of the directive fails: this condition is a matching failure. Unless assignment suppression was indicated by a <code>*</code>, the result of the conversion is placed in the object pointed to by the first argument following
the format argument that has not already received a conversion result. If this object does not have an appropriate type, or if the result of the conversion cannot be represented in the object, the behavior is undefined.<br>
<br>
12 The conversion specifiers and their meanings are:<br>
...<br>
<code>c</code> Matches a sequence of characters of exactly the number specified by the field width (1 if no field width is present in the directive).<sup>286)</sup><br>
...<br>
<code>s</code> Matches a sequence of non-white-space characters.<sup>286)</sup><br>
...<br>
<code>[</code> Matches a nonempty sequence of characters from a set of expected characters
(the <em>scanset</em>).<sup>286)</sup><br>
...
<hr>
<sup>
285) <code>fscanf</code> pushes back at most one input character onto the input stream. Therefore, some sequences that are acceptable to <code>strtod</code>, <code>strtol</code>, etc., are unacceptable to <code>fscanf</code>.<br><br>
286) No special provisions are made for multibyte characters in the matching rules used by the <code>c</code>, <code>s</code>, and <code>[</code>
conversion specifiers ¡ª the extent of the input field is determined on a byte-by-byte basis. The
resulting field is nevertheless a sequence of multibyte characters that begins in the initial shift state.
</sup>
</blockquote>

<p><code>%s</code> matches a sequence of <em>non-whitespace</em> characters.  Here's a basic algorithm describing how it works (not taking into account end of file or other exceptional conditions):</p>

<pre><code>c &lt;- next character from input stream
while c is whitespace
  c &lt;- next character from input stream
while c is not whitespace
  append c to target buffer
  c &lt;- next character from input stream
push c back onto input stream
append 0 terminator to target buffer
</code></pre>

<p>The first whitespace character after the non-whitespace characters (if any) is pushed back onto the input stream for the next input operation to read.  </p>

<p>By contrast, the algorithm for the <code>%c</code> specifier is dead simple (unless you're using a field width greater than 1, which I've never done and won't get into here):</p>

<pre><code>c &lt;- next character from input stream
write c to target
</code></pre>

<p>The algorithm for the <code>%[</code> conversion specifier is a little different:</p>

<pre><code>c &lt;- next character from input stream
while c is in the list of characters in the scan set
  append c to target buffer
  c &lt;- next character from input stream
append 0 to target buffer
push c back onto input stream
</code></pre>

<p>So, it's a mistake to describe any conversion specifier as ""retaining"" trailing whitespace (which would imply that the trailing whitespace is saved to the target buffer); that's not the case.  Trailing whitespace is left in the input stream for the next input operation to read.  </p>
",3
28197582,28197006,1,"<p>Your excerpt from the standard omits important context.  The preceding text specifies that skipping whitespace is the <em>first step</em> in processing a conversion specifier for a type other than <code>c</code>, <code>[</code>, or <code>n</code>.</p>

<p>The next step, other than for an <code>n</code> specifier, is to read an input item, which is defined as ""the longest sequence of input characters which does not exceed any specified field width and which is, or is a prefix of, a matching input sequence"" (quoted from C99, but equivalent applies to C2011).</p>

<p>An <code>s</code> item ""[m]atches a sequence of non-white-space characters"", so with the input you specify, the first <code>scanf()</code> reads everything up to, but not including, the newline.</p>

<p>The standard explicitly specifies</p>

<blockquote>
  <p>Trailing white space (including new-line characters) is left unread unless matched by a directive.</p>
</blockquote>

<p>so the newline definitely remains unscanned at this point.</p>

<p>The format given to the next <code>scanf()</code> starts with a <code>%[</code> conversion specifier, which, as you already observed, does <strong>not</strong> cause whitespace (leading or otherwise) to be skipped, though it can include whitespace in the item that is scanned.  Since the next character available from the input is a newline, however, and the given scan set for your <code>%[</code> does not include that character, zero characters are scanned for that item.  Going back to the standard (C99, again):</p>

<blockquote>
  <p>If the length of the input item is zero, the execution of the directive fails; this condition is a matching failure unless end-of-file, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.</p>
</blockquote>

<p>There are easier ways to read free-form input line by line, but you can do it with <code>scanf()</code> if you must.  For example:</p>

<pre><code>char buff[10 + 1] = {0};
printf(""Input: "");
/*
 * Ignore leading whitespace and scan a string of up to 10 non-whitespace
 * characters.  Zero-length inputs will produce a matching failure, leaving
 * the buffer unchanged (and initialized to an empty string).  End of
 * input will produce an input error, which is ignored.
 */
scanf(""%10s"", buff);

/* Scan and ignore anything else up to a newline.  There will
 * be an (ignorable) matching failure if the next available character is a
 * newline.  Any input error generated by this call is also ignored.
 */
scanf(""%*[^\n]"");

/*
 * Consume the next character, if any.  If there is one, it will be a
 * newline.  An input error will occur if we're already at the end of stdin;
 * a careful program would test for that (by comparing the return value to
 * EOF) but this one doesn't.
 */
scanf(""%*c"");

printf(""Input: "");

/* scan the second string; again, we're ignoring matching and input errors */
char buff_2[5 + 1] = {0};
scanf(""%5[abcde]"", buff_2);
</code></pre>

<p>If you're exclusively using <code>scanf()</code> for such a job then it is essential to read each line in three steps, as shown, because each one can produce a matching failure that would prevent any attempt to match subsequent items.</p>

<p>Note, too, how maximum field widths are matched to buffer sizes in that example, which your original code did not do correctly.</p>
",0
24138732,24138674,1,"<p>For </p>

<pre><code>int a = -10&amp;&amp;0;
</code></pre>

<p><code>-10</code> is treated as higher logic(1). However, result still be 0.</p>
",2
24138770,24138674,3,"<p>The operator <code>&amp;&amp;</code> and <code>||</code> has <em>short circuit behavior</em><sup><strong>1</strong></sup>. In  </p>

<pre><code>int a = -10 &amp;&amp; 0;  
</code></pre>

<p>since left operand is <code>-10</code>, which  is non-zero and hence <code>true</code>, therefore right operand, i.e <code>0</code> is checked. In   </p>

<pre><code>int res = c &gt; 10 &amp;&amp; b == 11;  
</code></pre>

<p>since left operand is evaluated to <code>false</code>, right operand is not evaluated.  </p>

<hr>

<p><sup><strong>1</strong> C11 6.5.13 (p4): <em>If the first operand compares equal to <code>0</code>, the second operand is not evaluated.</em> 
</sup></p>
",7
25538397,25538260,1,"<p>Unless you have a particular reason for wanting <code>data</code> to be 4-byte aligned (and if so, why is it a <code>uint8</code>?), the first one is mildly preferable because it'll save you a couple of bytes. For a variable-length structure like this, the value reported by <code>sizeof</code> is not really relevant, for exactly this reason. If you decide to allocate <code>sizeof(foo_t) + data_len</code> bytes for it then you'll be wasting a couple of bytes, but you'd waste them in padding in your second structure definition anyway.</p>
",4
25538426,25538260,1,"<p>If you want to pack your structs without sacrificing alignment then yes: the best option is to order elements in decreasing or increasing order. The array must be the last element, so here your best option is decreasing order (note that the size win is small, and it only matters if you have a large array of structs, but with a flexible array member you can't have an array of structs).</p>
",0
29195551,29195316,1,"<p><code>cowsdf</code> has no particular meaning. It's probably just a placeholder in the manuscript for a better title later.</p>

<p>There's also <code>titlesdf</code> earlier, which I would apply the same lack of meaning to.</p>

<p>By looking at the <a href=""http://cvs.savannah.gnu.org/viewvc/c-prog-book/learning_gnu_c.texinfo?root=c-prog-book&amp;view=markup"" rel=""nofollow"">source code</a> to the book, we can see that it is still <code>cowsdf</code> in the most recent version of the book as well. And we can see that the book was most recently edited 6 years ago. So it's unlikely that this will be fixed.</p>
",2
29196414,2637856,3,"<p>In C this is often done using a macro,<br>there are very simplistic examples, eg:<br><code>#define SWAP(type,a,b) {type _tmp=a;a=b;b=_tmp;}</code><br>... but I wouldn't recommend using them because they have some non-obvious flaws. </p>

<p>This is a macro written to avoid accidental errors.</p>

<pre><code>#define SWAP(type, a_, b_) \
do { \
    struct { type *a; type *b; type t; } SWAP; \
    SWAP.a  = &amp;(a_); \
    SWAP.b  = &amp;(b_); \
    SWAP.t  = *SWAP.a; \
    *SWAP.a = *SWAP.b; \
    *SWAP.b =  SWAP.t; \
} while (0)
</code></pre>

<ul>
<li>Each argument is instantiated only once,<br>so <code>SWAP(a[i++], b[j++])</code> doesn't give problem side effects.</li>
<li>temp variable name is also <code>SWAP</code>, so as not to cause bugs if a different name happens to collide with the hard-coded name chosen.</li>
<li>It doesn't call <code>memcpy</code> (which in fact ended up doing real function calls in my tests, even though a compiler may optimize them out).</li>
<li>Its type-checked<br>(comparing as pointers makes the compiler warn if they don't match).</li>
</ul>
",2
28219455,2425167,2,"<p>You must add a line with <code>#include &lt;stdlib.h&gt;</code> to include that header file
and <code>exit</code> must return a value so assign some integer in <code>exit(any_integer)</code>.</p>
",0
26205303,2425167,-6,"<p>Use process.h instead of stdlib and iostream... It will work 100%.</p>
",2
24365193,2425167,-3,"<p>Bad programming practice. Using a goto function is a complete no no in C programming.<br>
Also include header file stdlib.h by writing <code>#include &lt;iostream.h&gt;</code>for using <code>exit()</code> function. Also remember that exit() function takes an integer argument . Use <code>exit(0)</code> if the program completed successfully and <code>exit(-1)</code> or exit function with any non zero value as the argument if the program has error.</p>
",1
30147425,30147386,1,"<p>The problem is caused by the value of <code>i</code> not being reset to <code>0</code> at the start of the top level <code>while</code> loop.</p>

<p>Add the line</p>

<pre><code>  i = 0;
</code></pre>

<p>just before </p>

<pre><code>  printf(""miniShell&gt;&gt; "");                    
</code></pre>

<p>and all should be well.</p>
",0
24623435,2552544,0,"<p>Replace <code>extern int errno;</code> as <code>#include &lt;errno.h&gt;</code>.</p>

<p>Please see note in <a href=""http://man7.org/linux/man-pages/man3/errno.3.html"" rel=""nofollow"">this page</a>:</p>

<blockquote>
  <p>It was common in traditional C to declare errno manually (i.e.,
  extern int errno) instead of including .  Do not do this.
  It will not work with modern versions of the C library.  However, on
  (very) old UNIX systems, there may be no  and the
  declaration is needed.</p>
</blockquote>
",0
29912907,29912848,0,"<p><code>*ptr</code> is dereferencing of the pointer. </p>

<p><code>*a = *b;</code> means you are putting in the value contained at location <code>b</code> into the location where <code>a</code> points to. And this is what is required in the swap function.</p>

<p><code>a = b;</code> means you are assigning value of pointer b to pointer a. This is not what you need in swap logic. </p>
",0
29912953,29912848,0,"<p>On doing <code>a = b</code>, both <code>a</code> and <code>b</code> will point to location pointed by <code>b</code>, this will defeat the purpose of passing <code>a</code> and <code>b</code> as reference; as the <code>swap()</code> will not be reflected after the function returns.</p>
",0
29912994,29912848,2,"<p><code>a = b</code> means you are assigning address of <code>b</code> to <code>a</code> which not the right way.</p>

<p>for swapping two numbers means you need to get <code>value at that address</code> and that value you have to swap.<br>
so right way is to do <code>*a = *b;</code> i.e value at the address of <code>b</code> assigned to value at the address of <code>a</code>.</p>
",0
25678402,25678322,4,"<p>Whether or not the compiler diagnoses it, it's always an error to fall off the end of a function (i.e. reach the closing <code>}</code>) without returning a value if the function has a non-<code>void</code> return type.  It's <strong>Undefined Behavior</strong>.</p>

<p>Now, Undefined Behavior can manifest itself in many different ways.  It can result in your program crashing, receiving the wrong value, erasing your hard drive, sending a nasty email to your mother, or <em>appearing to work successfully with no other ill effects</em>.  All of these behaviors are permitted by the C language standard.  Just because the code may appear to work correctly, that doesn't mean it's actually correct and working.</p>

<p>If you crash when you invoke Undefined Behavior, you should consider yourself lucky, since those are usually easy to diagnose.  But if your program silently corrupts memory and then later crashes in an ""impossible"" situation, you're going to be in for one heck of a difficult debugging job.</p>

<p>Moral of the story: compile your code with a high warning level (e.g. use the <code>-Wall</code> compiler option; possibly also <code>-Wextra</code> and/or <code>-pedantic</code> if you can bear it; <code>-Werror</code> also strongly recommended).  Any compiler worth its salt will catch this kind of error, <em>but often times not at the default warning level</em>.</p>
",2
25678422,25678322,1,"<p>It was answered before: <a href=""https://stackoverflow.com/questions/4644860/function-returns-value-without-return-statement"">Function returns value without return statement</a> .</p>

<p>The gist of it: when doing d = get_stack(), the system looks into some place in memory where it expects to find the return value. Whatever trash is in that place in memory - counts as the return.</p>

<p>It may be that ""eax register"" or a slot in the call stack. You are just lucky that the return from malloc() got stuck in that spot. Add a few extra commands into get_stack() and the miracle will disappear.</p>
",0
28222649,28222336,1,"<p>It looks like you were trying to use a function pointer. To do that you would need to declare a function pointer to a function which return a <code>Tree*</code>, not a <code>Tree*</code> directly:</p>

<pre><code>if(choose==0) {
    Tree* (*CreateTree)(void);
    CreateTree = &amp;GetNewTreeInt;
}
</code></pre>

<p>However, your two functions are identical, since the line <code>*((int*)newTree-&gt;data);</code> has no side-effects. You could just create a function like this instead:</p>

<pre><code>Tree* GetNewTreeInt(void){
    Tree* newTree = (Tree*)malloc(sizeof(Tree));
    newTree-&gt;left = newTree-&gt;right = NULL;
    return newTree;
}
</code></pre>

<p>It's when you access <code>tree-&gt;data</code> that you need to cast the <code>void *</code> to a pointer of the type you know it contains. If you don't know what type of tree you have externally, you should add another field to your struct which signifies which type of data is stored. If you're only storing small data types like <code>int</code> and <code>char</code> I would recommend using a union instead of a void pointer, since a union will store the data inside the Tree in memory. Either way you'll still need something in your tree to indicate what type of data its storing.</p>

<pre><code>typedef struct Tree {

    // 0 means there is an int in tree-&gt;data.i,
    // 1 means there is a char in tree-&gt;data.c
    int type; 

    union {
        int i;
        char c;
    } data;

    struct Tree *left;
    struct Tree *right;

} Tree;
</code></pre>

<p>Then your two functions become:</p>

<pre><code>Tree* GetNewTreeInt(void){
    Tree* newTree = (Tree*)malloc(sizeof(Tree));
    newTree-&gt;type = 0;
    newTree-&gt;data.i = 0; // Set an initial value
    newTree-&gt;left = newTree-&gt;right = NULL;
    return newTree;
}

Tree* GetNewTreeChar(void){
    Tree* newTree = (Tree*)malloc(sizeof(Tree));
    newTree-&gt;type = 1;
    newTree-&gt;data.c = '\0'; // Set an initial value
    newTree-&gt;left = newTree-&gt;right = NULL;
    return newTree;
}
</code></pre>

<p>And you can use a function pointer just like this:</p>

<pre><code>if(choose==0) {
    Tree* (*CreateTree)(void);
    CreateTree = &amp;GetNewTreeInt;

    Tree* tree = CreateTree();
    tree-&gt;data.i = 7;
}
</code></pre>

<p>Each tree will have either a <code>data.i</code> or <code>data.c</code>, but not both, later when you're traversing your trees you can check their type to find out which:</p>

<pre><code>if ( tree-&gt;type == 0 ) {
    int data = tree-&gt;data.i;
} else if ( tree-&gt;type == 1 ) {
    char data = tree-&gt;data.c;
} 
</code></pre>

<p><strong>EDIT</strong></p>

<p>If you really want to use a <code>void *</code>, you can still add the <code>int type</code> to your struct, and when traversing you could do something like this:</p>

<pre><code>if ( tree-&gt;type == 0 ) {
    int data = *(int *)tree-&gt;data;
} else if ( tree-&gt;type == 1 ) {
    char data = *(char *)tree-&gt;data;
}
</code></pre>
",7
28222656,28222336,2,"<p>This:</p>

<pre><code>Tree* CreateTree();
</code></pre>

<p>..declares a function <code>CreateTree</code> that returns a <code>Tree*</code>, without fully defining the function (no function body, just a prototype).  Whereas this:</p>

<pre><code>Tree* CreateTree=GetNewTreeInt();
</code></pre>

<p>declares a variable of type <code>Tree*</code> named <code>CreateTree</code>, and calls the <code>GetNewTreeInt()</code> function assigning its return value to <code>CreateTree</code>.  This gives you your error since you've already declared a function with the same name.</p>

<p>If you want <code>CreateTree</code> to be a function pointer, and to point it at the <code>GetNewTreeInt</code> function, you need to declare it as (either globally or within <code>main</code>, not both):</p>

<pre><code>Tree *(*CreateTree)();
</code></pre>

<p>..and then point it at <code>GetNewTreeInt</code> like this:</p>

<pre><code>CreateTree = GetNewTreeInt;
</code></pre>

<p>..and then you can call the function through the pointer with just <code>CreateTree()</code> as with a normal function, eg.:</p>

<pre><code>root = CreateTree();
</code></pre>

<p>If you want a typedef of the function pointer type, you can do that as follows:</p>

<pre><code>typedef Tree *(*CreateTreeFuncType)();
</code></pre>

<p>...and declare <code>CreateTree</code> as:</p>

<pre><code>CreateTreeFuncType CreateTree;
</code></pre>

<p>instead of using the function pointer syntax mentioned earlier.</p>
",0
29200208,29200100,8,"<p><code>::</code> is not C but is the C++ <em>scope resolution operator</em> (C++11, 3.3.6p2).</p>

<p>See <a href=""http://en.wikipedia.org/wiki/Scope_resolution_operator"" rel=""noreferrer"">http://en.wikipedia.org/wiki/Scope_resolution_operator</a> for more information.</p>
",0
22448962,22448931,3,"<blockquote>
  <p>how does the function return value to the calling function?  </p>
</blockquote>

<p>Your intuition is right (partially). In some architecture the value is stored at stack and get popped when returning to the caller.  But keep in mind that a value is returned from a function, not the variable itself.</p>

<h3><a href=""https://rads.stackoverflow.com/amzn/click/com/013299044X"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">C: How to Program</a>: Ch-5: C Functions:</h3>

<blockquote>
  <p>When a program calls a function, the called function must know how to return to its
  caller, so the return address of the calling function is pushed onto the <strong>program execution stack</strong> (sometimes referred to as the function call stack).  </p>
  
  <p><strong>The program execution stack also contains the memory for the local variables used in
  each invocation of a function during a program¡¯s execution</strong>. This data, stored as a portion of the program execution stack, is known as the <strong>activation record</strong> or <strong>stack frame</strong> of the function call. When a function call is made, the activation record for that function call is pushed onto the program execution stack. When the function returns to its caller, the activation record for this function call is popped off the stack and <strong>those local variables are no longer known to the program</strong>.  </p>
</blockquote>

<hr>

<p><strong>EDIT:</strong> As others mentioned is comments that this is implementation specific I changed my mind.<br>
For x86 <a href=""http://en.wikipedia.org/wiki/X86_calling_conventions"" rel=""nofollow noreferrer"">wiki</a> says:    </p>

<blockquote>
  <p>Calling conventions describe the interface of called code:<br>
  1. The order in which atomic (scalar) parameters, or individual parts of a complex parameter, are allocated<br>
  2. <strong>How parameters are passed (pushed on the stack, placed in registers, or a mix of both)</strong><br>
  3. Which registers the callee must preserve for the caller<br>
  4. How the task of preparing the stack for, and restoring after, a function call is divided between the caller and the callee<br>
  <strong>There are often subtle differences in how various compilers implement these conventions</strong>. </p>
</blockquote>
",3
22449117,22448931,5,"<blockquote>
  <p>Does C destroy return variable before the closing brace?</p>
</blockquote>

<p>Yes ... sort of.</p>

<p>Local variables go out of scope at the end of a method, and after that, they cease to be accessible.</p>

<p>In C, that simply means that the storage for the variable itself becomes available for other uses.  But there is no active ""destruction"" of the variable.</p>

<p>In C++, the variable's destructor (if there is one) will be invoked when the variable goes out of scope.</p>

<p>At an implementation level, the storage space for local variables is <em>typically</em> managed using a stack.  But I don't think this is mandated by the respective language specifications.</p>

<hr>

<p>It is also important to note that we are talking about variables, not values.  In your example, the value of the variable is going to be returned to the caller (<em>vide</em> the <code>return</code> statement) and will continue to exist beyond the <code>}</code> ...</p>
",0
21316742,21316671,8,"<p>This is a piece of syntactic/semantic sugar that has, AFAIK, worked since the very earliest versions of C. It makes sense if you think of functions as pointers to code.</p>

<p>The only special rule needed to make function pointers work this way is that indirecting a function pointer gives the same pointer back (because you can't manipulate code in standard C anyway): when <code>f</code> is a function pointer, then <code>f == (*f) == (**f)</code>, etc.</p>

<p>(Aside: watch out with declaration such as <code>void (*f)()</code>. An empty argument list denotes an old-style, pre-C89 function declaration that matches on the return type only. Prefer <code>void (*f)(void)</code> for type safety.)</p>
",0
21317169,21316671,4,"<p>The C 2011 standard says in clause 6.3.2.1, paragraph 4:</p>

<blockquote>
  <p>Except when it is the operand of the <strong>sizeof operator</strong>, the <strong>_Alignof</strong> operator, or the unary <strong>&amp;</strong> operator, a function designator with type ¡®¡®function returning <em>type</em>¡¯¡¯ is converted to an expression that has type ¡®¡®pointer to function returning <em>type</em>¡¯¡¯.</p>
</blockquote>

<p>This means that, if <code>f</code> designates a function, then, in a call such as <code>f()</code>, <code>f</code> is automatically converted to <code>&amp;f</code>, resulting in <code>(&amp;f)()</code>. This is actually the ¡°proper¡± way to call a function, because the function-call expression requires a pointer to a function.</p>

<p>Now consider what happens in <code>*f</code>. The <code>f</code> is automatically converted to <code>&amp;f</code>, so we have <code>*&amp;f</code>. In this expression, the result of the <code>*</code> operator is a function, <code>f</code>; it just reverse the operation performed by <code>&amp;</code>. So <code>*&amp;f</code> is the same as <code>f</code>. We can repeat this indefinitely: <code>**f</code> is automatically converted to <code>**&amp;f</code>, which is <code>*f</code>, which is automatically converted to <code>*&amp;f</code>, which is <code>f</code>, which is automatically converted to <code>&amp;f</code>.</p>
",0
21316783,21316671,4,"<p>In C you can call your function like:  </p>

<pre><code>f();
(*f)();
(**f)();
(********f)();
(*****************************f)();  
</code></pre>

<p>all are valid. In C, dereferencing or taking the address of a function just evaluates to a pointer to that function, and dereferencing a function pointer just evaluates back to the function pointer. C is designed in such a way that both function name identifier as well as variable holding function's pointer mean the same: <strong>address to CODE memory</strong>. And it allows to jump to that memory by using call <code>()</code> syntax either on an identifier or variable.<br>
And the last but but least, standard says that:  </p>

<h3>C11: 6.3.2.1:</h3>

<blockquote>
  <p>4    A function designator is an expression that has function type. Except when it is the
  operand of the <code>sizeof</code> operator, the <code>_Alignof</code> operator,65) or the unary <code>&amp;</code> operator, a
  function designator with type ¡®¡®function returning type¡¯¡¯ is converted to an expression that has type ¡®¡®pointer to function returning type¡¯¡¯.</p>
</blockquote>
",2
21316789,21316671,4,"<p>A function call expression is always of the form ""function pointer"", ""round parenthesis"", ""arguments"", ""round parenthesis"". In order for you not to have to spell out <code>(&amp;printf)(""Hello World\n"")</code> every time<sup>1</sup>, there is a separate rule by which an expression which denotes a function decays to the respective function pointer.</p>

<p>Since a function pointer can be dereferenced to give an expression that denotes a function again, this will again decay, so you can keep dereferencing and there'll be a lot of decay:</p>

<pre><code>(&amp;f)();   // no decay (decay does not happen when the expression
          //           is the operand of &amp;)
f();      // one decay
(*f)();   // two decays
(**f)();  // three decays
</code></pre>

<p><br></p>

<p><sup>1) Early Perl has function syntax like that.</sup></p>
",1
24091430,24091254,2,"<p>Probably on your platform, <code>short</code> is 16-bit wide. Therefore no <code>short</code> can equal <code>0xf00f</code> and the condition <code>f00f.itm [0] != 0xf00f</code> is always true. The compiler optimized accordingly.</p>

<p>You may have meant <code>unsigned short</code> in the definition of <code>struct f00f</code>, but this is only one way to fix it, of course. You could also compare <code>f00f.itm [0]</code> to <code>(short)0xf00f</code>, but if you meant <code>f00f.itm[i]</code> to be compared to <code>0xf00f</code>, you definitely should have used <code>unsigned short</code> in the definition.</p>
",4
24091495,24091254,2,"<p><code>short val = 0xf00f;</code> assigns the value -4081 to val.</p>

<p>You get hit by integer promotion rules.</p>

<pre><code> f00f.itm [0] != 0xf00f
</code></pre>

<p>converts the short in <code>f00f.itm [0]</code> to an int, and that's -4081. 0xf00f as an int is 61455, and those two are not equal. Since the value is converted to an unsigned short when you print out the values (by using <code>%hx</code>), the issue isn't visible in the output.</p>

<p>Use unsigned values in your struct since you seem to treat the values as unsigned:</p>

<pre><code>struct {
           unsigned short   len;
           unsigned short   itm [4];
           char    nul;
    } f00f;
</code></pre>

<p>This sample program might make you understand what's going on a bit better:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(int argc,char *arga[])
{
    short x = 0xf00f;
    int y  =  0xf00f;

    printf(""x = 0x%hx y = 0x%x\n"", x, y);
    printf(""x = %d y = %d\n"", x, y);
    printf(""x==y: %d\n"", x == y);

    return 0;
}
</code></pre>
",1
32393916,32393866,5,"<p>The two strings are just concatenated by the <em>compiler</em>.</p>
",0
32393979,32393866,16,"<p>Yes it is legal syntax because of <strong>translation phase 6</strong> in ISO C99, #5.1.1.2 Translation phases:</p>

<blockquote>
  <ol start=""6"">
  <li>Adjacent string literal tokens are concatenated.</li>
  </ol>
</blockquote>
",1
32394807,32393866,1,"<p>As @Jens said, adjacent string literals are concatenated by the compiler.</p>

<p>One reason for this is so that you can do preprocessor things like this:</p>

<pre><code>#include &lt;stdio.h&gt;

#if defined(__linux__)
#define MY_OS ""linux""
#elif defined(_WIN32)
#define MY_OS ""windows""
#else
#define MY_OS ""probably something BSD-derived""
#endif

int main(void){
    printf(""my os is "" MY_OS ""\n"");
}
</code></pre>

<p>Which saves everybody a lot of time.</p>
",2
32394014,32393866,6,"<p>As mentioned adjacent strings are concatenated by the compiler. But if you want to see some difference you may add a <code>\0</code> null terminator in your strings.</p>

<p>On adding the <code>aaa\0</code> your o/p will be just <code>aaa</code> as printf will print till it finds the 1st <code>\0</code> null terminator.</p>

<pre><code>#include&lt;stdio.h&gt;

int main()
{

printf(""aaa\0"" ""bbb"");

}
</code></pre>

<p>Output </p>

<p><code>aaa</code></p>
",6
32394024,32393866,2,"<p>When the compiler see two consecutive string <em>literals</em>, it concatenate them (at parsing time in the compiler), like you observe. This won't work (compiler syntax error) for non literals.</p>

<p>The <a href=""https://en.wikipedia.org/wiki/Comma_operator"" rel=""nofollow"">comma operator</a> is unrelated to concatenation. It evaluates first the left operand, then the right one, and discards the result of the left, giving the right result. It is useful for side effects (like <code>progn</code> in Lisp, <code>;</code> in Ocaml, <code>begin</code> in Scheme). Of course, the comma is also used to separate arguments in calls.</p>
",0
30702332,30702288,2,"<p>This is a cast of -1 into the function pointer which is expected as the type of SIG_ERR. Using -1 directly does not work at situations where the compiler needs the correct type.</p>
",0
30702336,30702288,8,"<p>This is cast to a function-pointer:</p>

<pre><code>((type) value)
</code></pre>

<p>Where type is <code>void (*)(int)</code> which is pointer to function accepting one <code>int</code> argument and returning <code>void</code>, which is actually is a signature of a signal handler:</p>

<pre><code>typedef void (*sighandler_t)(int);
</code></pre>

<p>You may decode such types with <code>cdecl</code> tool or web-site: <a href=""http://cdecl.org/"" rel=""noreferrer"">http://cdecl.org/</a></p>
",7
31238197,2279379,6,"<p>To convert int to char use:</p>

<pre><code>int a=8;  
char c=a+'0';
printf(""%c"",c);       //prints 8  
</code></pre>

<p>To Convert char to int use:</p>

<pre><code>char c='5';
int a=c-'0';
printf(""%d"",a);        //prints 5
</code></pre>
",0
29167637,3050132,0,"<p>Personally, I prefer the minimalist style:</p>

<pre><code>((x == 'c' &amp;&amp; y == 'b') || (z == ',') || (z == ' '))

(  x == 'c'  &amp;&amp;  y == 'b'   ||   z == ','   ||   z == ' '  )
</code></pre>

<p>or </p>

<pre><code>(  x == 'c'  &amp;&amp;  y == 'b'  ?  z == ','  :  z == ' '  )
</code></pre>

<p>against</p>

<pre><code>( x == 'c' &amp;&amp; y == 'b' ? z == ',' : z == ' ')
</code></pre>
",1
26224286,8116703,2,"<p>As noted above:</p>

<blockquote>
  <p>You're missing a required #include for  (or one of several other headers that defines NULL); see the duplicated question. Probably on Windows some header you #include in turn #includes something that defines nULL. Oh, and according to the reference I just Googled, the second argument to xTaskCreate() is of type const portCHAR * const; why are you casting it to signed char*</p>
</blockquote>
",0
31164345,31163724,2,"<p>First of all, the standard rule of thumb for doing manual optimizations. Generally, manual code optimizations don't make much sense unless:</p>

<ul>
<li>You have benchmarked your code and found out that a certain part of it is a bottleneck.</li>
<li>You have a given hardware in mind.</li>
<li>You are an expert of the given hardware.</li>
</ul>

<p>That being said, a C programmer will always have to ensure that they aren't writing stupidly inefficient things that the compiler can't very well do much about. For example complex nested loop constructs, complex nested if-elses, complex function calls, recursion etc etc.</p>

<hr>

<p>In this specific case, the code looks good, there's not really much you can do to improve performance.</p>

<p>A switch-case like this one, based on an enum with adjacent numbers, are ideal for the optimizer. The compiler can optimize it into an array of function pointers, each function pointer corresponding to a <code>case</code>. Or alternatively into an array of direct jump addresses.</p>

<p>It is not really something the C programmer needs to concern themselves with, but they may need to consider that a switch where every integer case is an adjacent number likely gets better optimized than a switch with any random numbers.</p>

<p>In this case, the only optimization concern is probably branch prediction. But since you are using different function signatures, there's not really a way to avoid it. If you could rewrite the functions to use the same signatures, the function could be optimized ever so slightly. But we are talking nanoseconds here.</p>
",0
22505930,22505901,4,"<p>If you use the function, and it isn't implemented, you will get a link error.  Otherwise, no errors or warnings will occur.  </p>
",0
22505987,22505901,1,"<p>No, it is not an error to declare a function and not define it.</p>

<p>If you enable warnings, you may get a warning if you define a function with <code>static</code> linkage that does not get used in this translation unit.</p>
",0
21585233,4268589,50,"<p>While your code contains a number of rather serious and obvious errors (already covered in other answers), the warning you put into the title of your question is a completely superfluous meaningless warning. GCC compiler is notorious for issuing useless warnings. Many of those warnings seem to be derived from someone's incompetent and completely unsubstantiated belief that doing something is somehow ""wrong"", while in reality there's nothing wrong with it.</p>

<p>In your case the warning is triggered by </p>

<pre><code>extern int stack_counter = 0;
</code></pre>

<p>declaration. Apparently, the ""author"" of the warning believed that <code>extern</code> specifier should be reserved for non-defining declarations. In this case the presence of initializer <code>= 0</code> turns the declaration into a definition (and thus formally makes that <code>extern</code> optional). Nevertheless, there's no error in it and, in fact, <code>extern</code> might be quite welcome here to emphasize the fact that <code>stack_counter</code> is intended to be a global variable.</p>

<p>Again, whether you need a global variable here or not is a different question and, again, your code contains a massive number of other errors. But the warning you seem to focus your attention on is not really worth it. Just disable this warning in compiler settings (and, please, write a rude letter about it to GCC team).</p>
",15
28175272,28175234,2,"<p>You are mixing <code>char</code> and <code>int</code>. Are you sure that compiled without warnings?</p>
",0
21589518,21589449,10,"<p>It's the <a href=""http://c-faq.com/struct/structhack.html"">struct hack</a>. C99 added it officially in the form of ""flexible array member"".</p>

<blockquote>
  <p>As a special case, the last element of a structure with more than one
  named member may have an incomplete array type; this is called a
  flexible array member. In most situations, the flexible array member
  is ignored. In particular, the size of the structure is as if the
  flexible array member were omitted except that it may have more
  trailing padding than the omission would imply.</p>
</blockquote>

<p>The <code>sys/cdefs.h</code> I have says:</p>

<pre><code>#if __GNUC_PREREQ (2,97)
/* GCC 2.97 supports C99 flexible array members.  */
# define __flexarr      []
#else
# ifdef __GNUC__
#  define __flexarr     [0]
# else
....
</code></pre>

<p>If you are writing new code, the standard-mandated way to use it is with just a <code>[]</code>.</p>
",0
25545813,3461465,1,"<p>Just add the below code above the main()</p>

<pre><code>     void display(int);
     main() {
     // code
     }
</code></pre>
",0
32395560,32395458,1,"<p>From  the  C standard of <code>strftime</code>:</p>

<blockquote>
  <p>6 If a conversion specifier is not one of the above, the behavior is
  undefined.</p>
</blockquote>

<p>You can see the <a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html"" rel=""nofollow"">list of format specifiers</a> for strftime. So what you are getting is an <strong>undefined behavior</strong>.</p>

<p>See the <a href=""http://man7.org/linux/man-pages/man3/strftime.3.html"" rel=""nofollow"">manual</a> which says about %k</p>

<blockquote>
  <p><strong>%k</strong>     The hour (24-hour clock) as a decimal number (range 0 to 23);
          single digits are preceded by a blank.  (See also %H.)  (TZ)</p>
</blockquote>
",0
32395599,32395458,1,"<blockquote>
  <p><code>%k</code>-
    The hour as a decimal number, using a 24-hour clock like <code>%H</code>, but padded with blank (range  0 through 23). </p>
</blockquote>

<p>But this format is a GNU extension. <a href=""http://www.gnu.org/software/libc/manual/html_node/Formatting-Calendar-Time.html"" rel=""nofollow"">See here listed specifiers</a>.</p>

<p>And if the specifier not listed is used code will exbhit <em>undefined behaviour</em>.</p>
",0
32421921,3572688,2,"<pre><code>//a.h---

#include&lt;stdio.h&gt;
#include ""1.h""//cannot know its there without including it first.
#include ""2.h""
extern struct k;// don't really need to do this and is wrong. 
extern int c;

//a.c
int main()
{
  extern int a,b;//externs i believe should be in the h file?
  fun1();
  fun2();
  c=10;
  printf(""%d\n"",c);
  struct k *ptr = malloc(sizeof(struct k));//Define our pointer to the struct and make use of malloc.
  //now we can point to the struct, update it and even retrieve.
  ptr-&gt;id = 89;
  ptr-&gt;m = 43;
  printf(""\n%d\t%f"" ptr-&gt;id,ptr-&gt;m);
}


//1.h

#include&lt;stdio.h&gt;
typeof struct k
{
  int id;
  float m;
}j;

//1.c
int c;
void fun1()
{
  int a=0,b=5;
  printf(""tis is fun1"");
  printf(""\n%d%d\n"",a,b);
}


//2.h--

#include&lt;stdio.h&gt;
struct k
{
  int id;
  float m;
}j;

//2.c
void fun2()
{
  int a=10,b=4;
  printf(""this is fun2()"");
  printf(""\n%d%d\n"",a,b);
}
</code></pre>

<p>I have edited your code in places so it should see the struct and point to it. Each C file should know have an header h file. When the a.h belonging to your main includes files not only it can see them but should be able to access them. This means it should also know what K is J is alias of K if I remember correctly. </p>

<p>I should know update the struct and retrieve data from it via pointer. If this still doesn't work please post your compiling error and copy n paste the line its crying about.</p>
",0
24376634,6812242,0,"<p>I always do it that way, seems elegant and easy to me.<br>
You just define an array as usual, without fixed index.<br>
All you have to make sure is to add a single 0 at the end.<br>
Then you can make the shortest TEST case possible and iterate through it with for or while.  </p>

<p>Here is an example, it displays a list of options and the fitting help element (in that case the help array needs to be at least as long as the options one.</p>

<pre><code>const char *options[]={
    ""CAL_MAG_MIN"",
    ""CAL_MAG_MAX"",
    0
    };
const char *help[]={
    ""&lt;X,Y,Z&gt;"",
    ""&lt;X,Y,Z&gt;"",
    0
    };

int pos;
for (pos=0;options[pos];pos++)
{
    printf(""\t %s %s\n"",options[pos],help[pos]);
}
</code></pre>
",0
25696072,25696055,9,"<p>No for <code>TRUE</code> or <code>FALSE</code>. Yes for <code>true</code> and <code>false</code> in C99 or later if you include <code>&lt;stdbool.h&gt;</code>.</p>
",0
25696560,25696055,0,"<p>C99 and C11 define an integral type with Boolean semantics called <code>_Bool</code>, but no actual true/false keywords exist.</p>

<p>The <code>_Bool</code> type is only capable of storing the values 1 and 0. Any value that doesn't compare equal to 0 is converted to 1, and any value comparing equal to 0 is converted to 0.</p>

<p>By including <code>&lt;stdbool.h&gt;</code>, the <code>_Bool</code> type is allowed to be written as <code>bool</code> as with some other languages, and <code>true</code> and <code>false</code> C preprocessor macros are defined to be 1 and 0 respectively.</p>

<p>Before that, it was somewhat of a convenience for someone to define constants like</p>

<pre><code>#define TRUE 1
#define FALSE 0
typedef char BOOL; /* or #define BOOL char */
</code></pre>

<p>or sometimes</p>

<pre><code>typedef enum {False, True} BOOL;
</code></pre>

<p>Unlike C99, however, both have at least one flaw:</p>

<pre><code>BOOL bClicked = False;

++bClicked, ++bClicked;

if (bClicked == False)
    printf (""False\n"");
else if (bClicked == True)
    printf (""True\n"");
else
    printf (""Unknown: %d\n"", bClicked);
</code></pre>

<p>That will print ""Unknown: 2"" because the defined <code>BOOL</code> type isn't a true Boolean type.</p>

<p>The C99 version:</p>

<pre><code>_Bool bClicked = 0;

++bClicked, ++bClicked;

if (bClicked == 0)
  printf (""False\n"");
else if (bClicked == 1)
  printf (""True\n"");
else
  printf (""Unknown: %d\n"", bClicked);
</code></pre>

<p>That will print ""True"" because <code>_Bool</code> can only store 0 and 1, so incrementing 1 to get 2, which compares as not equal to 0, results in 1.</p>

<p>Of course, most people just use the language to their advantage rather than actually comparing against True/False constants:</p>

<pre><code>if (bClicked)
  {
    /* True if bClicked does not compare equal to 0 */
  }
else
  {
    /* False */
  }
</code></pre>

<p>Because of that behavior, there isn't any real need for a Boolean type or true/false constants; they exist purely for indication of intent.</p>

<p>I vaguely remember someone ranting that some Windows API functions return a value of type <code>BOOL</code>, but <code>TRUE</code> and <code>FALSE</code> weren't the only possible return values, so despite returning a value that should have been a simple comparison as in that last bit of code, more comparisons were needed to handle all possible cases. Had there been an actual Boolean type back then, most likely those functions, whatever they are/were would have returned a value of type <code>int</code> instead. A <code>BOOL</code> return type suggests only two values can be returned, but apparently that wasn't the case with those functions, perhaps because there was a third (error) return value.</p>
",0
22494501,4156585,-3,"<p>You can find the length of your C function by subtracting the addresses of functions.
Let me provide you an example</p>

<pre><code>int function1()
    {
    } 

int function2()
{
    int a,b;    //just defining some variable for increasing the memory size
    printf(""This function would take more memory than earlier function i.e function01 "");
}

int main()
{
    printf(""Printing the address of function01 %p\n"",function01);
    printf(""Printing the address of function02 %p\n"",function02);
    printf(""Printing the address of main %p\n"",main);
    return 0;
}
</code></pre>

<p>Hope you would get your answer after compiling it. After compiling you will able to see the 
difference in size of function01 and function2.</p>

<p>Note : Normally there is 16bytes diff between one function and other.</p>
",1
24592239,24592228,5,"<ol>
<li><p>A ""circular buffer"" is an array that's used in a particular way. It's not declared any differently from any other array.</p></li>
<li><p>It's updating the index of the array that's read from and keeping it within the bounds of the array.</p></li>
</ol>
",0
24592338,24592228,4,"<ol>
<li>Circular buffer is of course a plain array, but you reset the array indexers once it comes to the last element.</li>
<li>Use of modulus operator (%) ensures that array index is reset to 0 once it comes to the last element.</li>
</ol>
",1
32419390,32419329,3,"<p>The decision of using one method instead of another depends on what you intend to do.</p>

<p>Example</p>

<p>If you want to modify an array inside a function an maintain the modification in the original array, you should use your first example.</p>

<p>If you are creating your own data structure, you have to deal with all the operations. And if you want to create a new struct you should allocate memory inside the function and return the pointer. The second example.</p>

<p>If you want to ""return"" two values from a function, like a vector and the length of the vector, and you don't want to create a struct for this, you could return the pointer of the vector and pass an int pointer as an argument of the function. That way you could modify the value of the int inside the function and you use it outside too. </p>

<pre><code>char* return_vector_and_length(int* length);
</code></pre>
",0
32419392,32419329,3,"<p>The benefit is that you can reserve the return value of the function for error checking, status indicators, etc, and actually send back data using the output parameter. In fact, with this pattern, you can send back any amount of data along with the return value, which could be immensely useful. And, of course, with multiple calls to the function (for example, calling <code>scanf</code> in a loop to validate user input), you don't have to <code>malloc</code> every time.</p>

<p>One of the best examples of this pattern being used effectively is the function <code>strtol</code>, which converts a string to a <code>long</code>.</p>

<p>The function accepts a pointer to a character as one of its parameters. It's common to declare this <code>char</code> locally as <code>endptr</code> and pass in its address to the function. The function will return the converted number if it was able to, but if not, it'll return <code>0</code> to indicate failure <em>but also</em> set the character pointer passed in to the non-digit character it encountered that caused the failure.</p>

<p>You can then report that the conversion failed on that particular character.</p>

<p>This is better design than using global error indicators; consider multithreaded programs. It likely isn't reasonable to use global error indicators if you'll be calling functions that could fail in several threads.</p>

<p>You mention that a function should be responsible for its own memory. Well, <code>scanf</code> doesn't exist to <em>create</em> the memory to store the scanned value. It exists to scan a value from an input buffer. The responsibilities of that function are very clear and don't include allocating the space.</p>

<p>It's also not unreasonable to return a <code>malloc</code>'d pointer. The programmer should be prudent, though, and <code>free</code> the returned pointer when they're done using it.</p>
",6
32419409,32419329,0,"<p>Let¡¯s say that, for example, you wanted to store process settings in a specific place in memory.  With the first version, you can write this as, <code>process_settings(output_buffer + offset);</code>.  How would you have to do it in you only had the second version?  What would happen to performance if it were a really big array?  Or what if, let¡¯s say, you¡¯re writing a multithreaded application where having all the threads call <code>malloc()</code> all the time would make them fight over the heap and serialize the program, so you want to preallocate all your buffers?</p>

<p>Your intuition is correct in some cases, though: on modern OSes that can memory-map files, it does turn out to be more efficient to return a pointer to the file contents than the way the standard library was historically written, and this is how <code>glib</code> does it.  Sometimes allocating all your buffers on the heap helps avoid buffer overflows that smash the stack.</p>

<p>An important point is that, if you have the first version, you can trivially get the second one by calling <code>malloc</code> and then passing the buffer as the dest argument.  But, if you have only the second, you can¡¯t implement the first without copying the whole array.</p>
",0
24596228,24592696,0,"<p>The function is checking that the difference between last_seqno and curr_seqno are smaller than TQ_LOCAL_WINDOW_SIZE and that curr_seqno is not > than last_seqno.</p>

<p>It looks like validation but you changed something as the 2nd call doesn't match the protype of the apparently tail recursive call.  In K&amp;R C, you could sometimes get away with local variables used as paramters by mistake but this example you provide gets the types wrong.. so as posted this is NONSENSE!  *</p>

<ul>
<li>Seen explanation that this is a wrapper not meant to be a recursive call.</li>
</ul>
",2
26448108,26448085,5,"<p>On Linux, this is available from <code>/proc/meminfo</code>.  Example:</p>

<pre>
MemTotal:       16469432 kB
MemFree:          792136 kB
MemAvailable:   15201832 kB
Buffers:         5806244 kB
Cached:          8637760 kB
...
</pre>

<p>Just open this as an ordinary file, and parse the contents.</p>
",1
26448189,26448085,3,"<p>The cleanest way is to use procfs (see Dietrich's answer).</p>

<p>However, for more details about the hardware (RAM, CPU count, speed, model numbers, misc other devices) you can extract tons of info from dmesg:</p>

<pre><code>dmesg | grep Memory
</code></pre>

<p>You can use the C stdlib popen() to read from dmesg if you have privs, and parse all sorts of info. I have used this for a monitoring system like Spong to extract as much information as possible about the node. You can even monitor it live for feedback from hardware / device commands you issue (dmesg | tail -f).</p>

<p>Keep in mind dmesg isn't always available, depending on privs.</p>
",1
26449295,26448085,1,"<p>@abc This documentation can help you. <a href=""http://valgrind.org/docs/manual/ms-manual.html"" rel=""nofollow"">http://valgrind.org/docs/manual/ms-manual.html</a> </p>
",0
26450482,26448085,1,"<p>Only way to get physical RAM available is by using BIOS calls if you don't want the OS to do it for you.
All the information you need <a href=""http://wiki.osdev.org/index.php?title=How_Do_I_Determine_The_Amount_Of_RAM&amp;redirect=no"" rel=""nofollow"">http://wiki.osdev.org/index.php?title=How_Do_I_Determine_The_Amount_Of_RAM&amp;redirect=no</a></p>
",0
26450498,26448085,0,"<p>you can use <strong>top</strong> command will show cpu usage memory usage ,etc</p>
",0
21165281,21164939,1,"<p>The actual representation is like:</p>

<pre><code>000011 00011 00001
     b     c     a
</code></pre>

<p>When aligned as bytes:</p>

<pre><code>00001100 01100001
       |        |
       p+1      p 
</code></pre>

<p>On the address (p+1) is <code>0001100</code> which gives 12.</p>
",0
21165975,21164939,1,"<p>The C standard does not completely specify how bit-fields are packed into bytes. The details depend on each C implementation.</p>

<p>From C 2011 6.7.2.1:</p>

<blockquote>
  <p>11 An implementation may allocate any addressable storage unit large enough to hold a bit-field. If enough space remains, a bit-field that immediately follows another bit-field in a structure shall be packed into adjacent bits of the same unit. If insufficient space remains, whether a bit-field that does not fit is put into the next unit or overlaps adjacent units is implementation-defined. The order of allocation of bit-fields within a unit (high-order to low-order or low-order to high-order) is implementation-defined. The alignment of the addressable storage unit is unspecified.</p>
</blockquote>
",0
21166098,21164939,1,"<p>From the C11 standard (6.7.2.1):</p>

<blockquote>
  <p>The order of allocation of bit-?elds within a unit (high-order to low-order or low-order to high-order) is implementation-de?ned. The alignment of the addressable storage unit is unspeci?ed.</p>
</blockquote>

<p>I know for a fact that GCC and other compilers on unix-like systems order bit fields in the host byte order which can be evidenced from the definition of an IP header from an operating system source I had handy:</p>

<pre><code>struct ip {
#if _BYTE_ORDER == _LITTLE_ENDIAN
        u_int     ip_hl:4,              /* header length */
                  ip_v:4;               /* version */
#endif
#if _BYTE_ORDER == _BIG_ENDIAN
        u_int     ip_v:4,               /* version */
                  ip_hl:4;              /* header length */
#endif
</code></pre>

<p>Other compilers might do the same. Since you're most likely on a little endian machine, your bit field will be backwards from what you're expecting (in addition to the words being backwards already). Most likely it looks like this in memory (notice that the order of your fields in the struct in your question is ""a, c, b"", not ""a, b, c"", just to make this all more confusing):</p>

<pre><code>01100001 00001100
|        |
byte 0   byte 1
|  |     |     |
x  a     b     c
</code></pre>

<p>So, all three bit fields can be stuffed in an int. Padding is added automatically and it's at the start of all the bitfields, it is put at byte 2 and 3. Then the <code>b</code> starts at the lowest bit of byte 1. After it <code>c</code> starts in byte 1 two, but we can only fit two bits of it, the two highest bits of <code>c</code> are 0, then <code>c</code> continues in byte 0 (<code>x</code> in my picture above), and then after that you have <code>a</code>.</p>

<p>Notice that the picture is with the lowest address of both the bytes and the bits on the left side growing to the right (this is pretty much standard in literature, your picture had the bits in one direction and bytes in another which makes everything more confusing, especially adding your weird ordering of the fields ""a, c, b"").</p>

<p>I none of the above made any sense run this program and then read up on byte-ordering:</p>

<pre><code>#include &lt;stdio.h&gt;
int
main(int argc, char **argv)
{
        unsigned int i = 0x01020304;
        unsigned char *p;
        p = (unsigned char *)&amp;i;
        printf(""0x%x 0x%x 0x%x 0x%x\n"", (unsigned int)p[0], (unsigned int)p[1], (unsigned int)p[2], (unsigned int)p[3]);
        return 0;
}
</code></pre>

<p>Then when you understand what little-endian does to the ordering of bytes in an int, map your bit-field on top of that, but with the fields backwards. Then it might start making sense (I've been doing this for years and it's still confusing as hell).</p>

<p>Another example to show how the bit fields are backwards twice, once because of the compiler deciding to put them backwards on a little-endian machine, and then once again because the byte order of ints:</p>

<pre><code>#include &lt;stdio.h&gt;
int
main(int argc, char **argv)
{
        struct bf {
                unsigned a:4,b:4,c:4,d:4,e:4,f:4,g:4,h:4;
        } bf = { 1, 2, 3, 4, 5, 6, 7, 8 };
        unsigned int *i;
        unsigned char *p;
        p = (unsigned char *)&amp;bf;
        i = (unsigned int *)&amp;bf;
        printf(""0x%x 0x%x 0x%x 0x%x\n"", (unsigned int)p[0], (unsigned int)p[1], (unsigned int)p[2], (unsigned int)p[3]);
        printf(""0x%x\n"", *i);
        return 0;
}
</code></pre>
",0
23077027,23076754,2,"<pre><code>size_t size = (char*)(&amp;i+1)-(char*)(&amp;i);
</code></pre>

<p>here since <code>i</code> is integer pointer, &amp;i+1 will increment the pointer to the next address for a <code>int</code> type variable. So this increment will result in increment of address by the number of bytes required store a <code>int</code> data. but if you directly subtract the value it will give you number of int data in between pointers not the number of bytes. So to get the number of bytes you type cast the pointer to a data type whose size is a byte.<br>
You can even convert it to a integer and get the difference to get the size of <code>int</code> i.e. number of bytes. but it will result in warning so not a good practice.  </p>
",0
23076784,23076754,8,"<p>The casts to <code>(char*)</code> mean that the difference is computed in <code>char</code> <em>pointer arithmetic</em>. The resulting <code>size</code> will then be in units of <code>char</code> (i.e. bytes), which is the natural unit of a <code>sizeof</code>.</p>
",1
23076823,23076754,3,"<p>The size of <code>char</code> is guaranteed to be 1. If you convert the pointer from <code>int</code> to <code>char</code>, when you subtract the two pointers you get the different between them which will be in units of size of <code>char</code>, not size of <code>int</code>. It helps to figure the actual size of an <code>int</code>.</p>
",2
23081199,23076754,0,"<p>Both addition and subtraction have a different behavior with pointers according to the size of the data type to which they point.
For example, let's assume that in a given compiler for a specific machine, <code>char</code> takes 1 byte, <code>short</code> takes 2 bytes and <code>long</code> takes 4.
Suppose we define the following variables:</p>

<pre><code>char *pChar;
short *pShort;
long *pLong;
</code></pre>

<p>and that we know that they point to memory locations 1000, 2000 and 3000 respectively, so if we write:</p>

<pre><code>pChar++;  // As expected, pChar will contain the value 1001
pShort++; // pShort will contain the value 2002, because short type will take 2 bytes
pLong++;  // pLong will contain the value 3004
</code></pre>

<p>Back to code in the question, according to the pointer arithmetic, the variable size will contain the size of <code>i</code> (in this case <code>int</code>) regardless the cast to (char *) or (int *)</p>
",0
34188159,34188066,4,"<p>You haven't included <code>&lt;stdlib.h&gt;</code> to get <a href=""http://man7.org/linux/man-pages/man3/strtod.3.html"" rel=""nofollow""><code>strtof()</code></a>'s prototype. So the return type defaults to int. But implicit int rule has been removed from C since C99.</p>

<p>The usage is also wrong. It should be, at least:</p>

<pre><code>char *eptr;

x = strtof(a, &amp;eptr);
</code></pre>

<p>And inspect <code>eptr</code> for conversion failures.</p>

<p>Compile with warnings enabled. GCC warns with:</p>

<blockquote>
  <p>warning: implicit declaration of function ¡®strtof¡¯
  [-Wimplicit-function-declaration]</p>
</blockquote>
",2
29494811,29494757,2,"<pre><code>char *ptr = malloc(sizeof(char *));
ptr = ""AB"";
</code></pre>

<p>This is a memory leak, because you have lost the address returned by <code>malloc()</code> and won't be able to send that address to <code>free()</code>.</p>

<pre><code>char *addr = ""0x08123412"";
</code></pre>

<p>Although I'm having trouble understanding what you are trying to accomplish here, this is valid. No call to <code>malloc()</code> was needed. Note that this code declares a <code>char</code> pointer, and points it to the string ""0x08123412"".</p>

<p>To get back a previously used address, you'll need to save it somewhere. That is why you cannot be overwriting your pointer values. You need to hang on to them if you might need them later.</p>
",2
29498049,29494757,0,"<pre><code>char *ptr = malloc(sizeof(char *));
ptr = ""AB"";
char *addr = ""0x08123412"";
</code></pre>

<p>Now let's replace the last instruction with this:
<code>char *addr = 0x08123412;</code></p>

<p>It is probably what you meant, it makes more sense.
So here we go:
First, you wrote <code>malloc(sizeof (char *))</code>, you probably intended to write <code>malloc(sizeof (char))</code> because according to this code, you are allocating a pointer to char, not a char, hopefully malloc returns a pointer to void, which will be implicitely cast into the <code>char *ptr</code> you have declared.</p>

<p>Next instruction: <code>ptr = ""AB""</code>. What happens here is that the compiler will allocate ""AB"" as a string literal probably in the .rodata section. 'ptr' will hold the address at which ""AB"" was put.<br>
Until now, here is your memory layout: </p>

<pre><code>ptr lives at address X // &amp;ptr = X  
""AB"" lives at address Y // &amp;(""AB"") = Y  
ptr contains Y // ptr = Y 
</code></pre>

<p>Now the address returned by malloc, which you say is 0x08123412, let's call it Z, is the address of the memory location allocated by malloc(), which you lost when assigning ""AB"" to ptr. But supposing you kept it somewhere, you still cannot reach ""AB"" with it. The only way to reach the string ""AB"" is to know its address, and right now, the only thing that can help you with that is ptr, since it still holds that address. Overwrite it and ""AB"" is lost forever.</p>
",0
26447682,26447614,2,"<p>You have several different ways to resolve this warning:</p>

<p><strong>Option #1:</strong></p>

<pre><code>#define MEM_SIZE_WORDS MEM_SIZE_BYTES/sizeof(int)      // change this
#define MEM_SIZE_WORDS MEM_SIZE_BYTES/(int)sizeof(int) // to this
</code></pre>

<p><strong>Option #2:</strong></p>

<pre><code>#define MEM_SIZE_WORDS MEM_SIZE_BYTES/sizeof(int)        // change this
#define MEM_SIZE_WORDS (int)(MEM_SIZE_BYTES/sizeof(int)) // to this
</code></pre>

<p><strong>Option #3:</strong></p>

<pre><code>printf(""words are %d\n"", MEM_SIZE_WORDS);  // change this
printf(""words are %lu\n"", MEM_SIZE_WORDS); // to this
</code></pre>
",3
26447686,26447614,2,"<p>In this case, sizeof returns an long unsigned int. One way to get around the warning:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

#define SIZE_TYPE
#define MEM_SIZE_BYTES  4096
int intSize = sizeof(int);
#define MEM_SIZE_WORDS  MEM_SIZE_BYTES/intSize

int main() {

    printf(""bytes are %d\n"", MEM_SIZE_BYTES);
    printf(""words are %d\n"", MEM_SIZE_WORDS);

}
</code></pre>

<p>intSize is <strong>global</strong> variable. In some cases, it will not be considered as a best practice. Using a <strong>cast to int will be superior</strong> (see barak's comment and answer). </p>
",7
27126627,27125151,2,"<p>Here's your problem:</p>

<blockquote>
  <p>The Daylight Saving Time flag (tm_isdst) is greater than zero if Daylight Saving Time is in effect, zero if Daylight Saving Time is not in effect, and less than zero if the information is not available.</p>
</blockquote>

<p>By setting <code>t.tm_isdst = 0;</code> in your code, you are explicitly specifying that there is no daylight saving in effect. You should have provided a negative value.</p>

<p>Reference: <a href=""http://www.cplusplus.com/reference/ctime/tm/"" rel=""nofollow"">http://www.cplusplus.com/reference/ctime/tm/</a></p>

<hr>

<p>(Also, shouldn't the format string near the bottom be <code>""%d:%02d""</code>instead of <code>""%s:%s""</code>?)</p>

<h2>EDIT</h2>

<p>Sorry, I didn't notice you'd tried different values of <code>tm_isdst</code>. Perhaps it would help if you simplified your code a bit. This works perfectly on my system:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

int main() {
  struct tm   t, *gmtTimeStruct, *localTimeStruct;
  time_t      t_of_day;
  char        *gmtHumanTime, *localHumanTime;

  t.tm_year  = 2014 - 1900;
  t.tm_mon   = 3    - 1;
  t.tm_mday  = 30;
  t.tm_hour  = 2;
  t.tm_min   = 59;
  t.tm_sec   = 59;
  t.tm_isdst = -1;
  t_of_day = mktime(&amp;t);

  gmtTimeStruct = gmtime(&amp;t_of_day);
  asprintf(&amp;gmtHumanTime, ""%d:%d"", gmtTimeStruct-&gt;tm_hour, gmtTimeStruct-&gt;tm_min);
  printf(""GMT Human Time: %s\n"", gmtHumanTime);

  localTimeStruct = localtime(&amp;t_of_day);
  asprintf(&amp;localHumanTime, ""%d:%d"", localTimeStruct-&gt;tm_hour, localTimeStruct-&gt;tm_min);
  printf(""Local Human Time: %s\n"", localHumanTime);

  return 0;
}
</code></pre>

<p><strong>Output:</strong></p>

<pre><code>GMT Human Time: 1:59
Local Human Time: 2:59
</code></pre>

<p>Try compiling this on your system and see what you get. (Perhaps there is something wrong with your system's time zone setting?)</p>
",3
31231124,5403103,2,"<p><code>strtol()</code> is your friend here. The third parameter is the numerical base that you are converting.</p>

<p>Example:</p>

<pre><code>#include &lt;stdio.h&gt;      /* printf */
#include &lt;stdlib.h&gt;     /* strtol */

int main(int argc, char **argv)
{
    long int num  = 0;
    long int num2 =0;
    char * str. = ""f00d"";
    char * str2 = ""0xf00d"";

    num = strtol( str, 0, 16);  //converts hexadecimal string to long.
    num2 = strtol( str2, 0, 0); //conversion depends on the string passed in, 0x... Is hex, 0... Is octal and everything else is decimal.

    printf( ""%ld\n"", num);
    printf( ""%ld\n"", num);
}
</code></pre>
",1
23841970,23841402,2,"<p>According to the C standard (ISO 9899:1999 section 7.1.3), ""all external identifiers defined by the library are reserved in a hosted environment. This means, in effect, that no user-supplied external names may match library names."" </p>

<p>Your problem can be easily solved by adding a unique prefix to all your identifiers, e.g. ""<code>mylang_</code>"".</p>

<p>As an alternative, you can avoid the problem by using the LLVM or GCC <code>-ffreestanding</code> flag, which will compile your code for a non-hosted environment. (The C standard specifies that the restriction only applies to a hosted environment.)  In this case you can use all the names you want (apart from <code>main</code>, which is still your program's entry point), but you must make your own arrangements for your library.  This is how operating system kernels can legally define their own versions of the C library functions.</p>
",1
23841758,23841402,1,"<p>The reason is explained here and a relevant extract is given below. <a href=""http://www.gnu.org/software/libc/manual/html_node/Reserved-Names.html"" rel=""nofollow"">http://www.gnu.org/software/libc/manual/html_node/Reserved-Names.html</a>
I get an error in gcc as well.  </p>

<blockquote>
  <p>The names of all library types, macros, variables and functions that come from the ISO C standard are reserved unconditionally; your program may not redefine these names. All other library names are reserved if your program explicitly includes the header file that defines or declares them. There are several reasons for these restrictions:</p>
  
  <ol>
  <li>Other people reading your code could get very confused if you were using a function named exit to do something completely different from what the standard exit function does, for example. Preventing this situation helps to make your programs easier to understand and contributes to modularity and maintainability.</li>
  <li>It avoids the possibility of a user accidentally redefining a library function that is called by other library functions. If redefinition were allowed, those other functions would not work properly.</li>
  <li>It allows the compiler to do whatever special optimizations it pleases on calls to these functions, without the possibility that they may have been redefined by the user. Some library facilities, such as those for dealing with variadic arguments (see Variadic Functions) and non-local exits (see Non-Local Exits), actually require a considerable amount of cooperation on the part of the C compiler, and with respect to the implementation, it might be easier for the compiler to treat these as built-in parts of the language.</li>
  </ol>
</blockquote>

<p>The page also describes other restricted names. </p>
",0
28229747,4346598,2,"<p>To read all the words using scanf you can do it like this</p>

<p><strong>Example :</strong></p>

<pre><code>printf(""Enter name: "");

scanf(""%[^\n]s"",name);       //[^\n] is the trick
</code></pre>
",0
26446340,26446325,1,"<p>Whatever you pass is going to get copied... so you should pass something, that even when copied, lets you find the original <code>a</code>.</p>

<p>That something is a pointer, and its value is the address of <code>a</code>.</p>

<p>If you write your friend's address on a piece of paper, then no matter how many times that paper gets copied, the person holding it can still find the original house.</p>

<p>You write a pointer as <code>int* asdf</code>, and the address of <code>a</code> is written as <code>&amp;a</code>.  To find the object when you have a pointer, you need <code>*asdf</code>.</p>
",0
26446342,26446325,1,"<p>First get started with a Pointers chapter from good C book</p>

<pre><code>int test(int* asdf){   // Argument will be pointer to integer
  *asdf = *asdf + 1;   // de-reference and access asdf's content &amp; increment
  return 0;
}

test(&amp;a); // Pass address of a
</code></pre>
",1
26446350,26446325,0,"<p>C doesn't support passing a variable by reference so you can't do that.</p>

<p>However, if you did pass a pointer to a variable then you could get the variable incremented.</p>

<p>Look at:</p>

<p><a href=""https://stackoverflow.com/questions/2229498/passing-by-reference-in-c"">Passing by reference in C</a></p>
",0
22126089,22123467,3,"<p>Well, some people like <a href=""https://stackoverflow.com/questions/971312/why-avoid-increment-and-decrement-operators-in-javascript"">Douglas Crockford</a> are against using those operators because they can lead to unexpected behaviors by hiding the final result from the untrained eye.</p>

<p>But, since <a href=""https://github.com/coma/MomentPicker/blob/master/package.json"" rel=""nofollow noreferrer"">I'm using JSHint</a>, let's share an example here:</p>

<p><a href=""http://jsfiddle.net/coma/EB72c/"" rel=""nofollow noreferrer"">http://jsfiddle.net/coma/EB72c/</a></p>

<pre><code>var List = function(values) {

    this.index = 0;
    this.values = values;
};

List.prototype.next = function() {

    return this.values[++this.index];
};

List.prototype.prev = function() {

    return this.values[--this.index];
};

List.prototype.current = function() {

    return this.values[this.index];
};

List.prototype.prefix = function(prefixes) {

    var i;

    for (i = 0; i &lt; this.values.length; i++) {

        this.values[i] = prefixes[i] + this.values[i];
    }
};

var animals = new List(['dog', 'cat', 'parrot']);

console.log('current', animals.current());
console.log('next', animals.next());
console.log('next', animals.next());
console.log('current', animals.current());
console.log('prev', animals.prev());
console.log('prev', animals.prev());

animals.prefix(['Snoopy the ', 'Gartfield the ', 'A ']);

console.log('current', animals.current());
</code></pre>
",0
22126096,22123467,6,"<p>The short answer is: You never need them!</p>

<p>The long answer is that the instruction sets of early micro-computers had features like that. Upon reading of a memory cell, you could post-increment or pre-decrement that cell when reading it. Such machine level features inspired the predecessors of C, from whence it found its way even into more recent languages.</p>

<p>To understand this, one must remember that RAM was extremely scarce in those days. When you have 64k addressable RAM for your program, you'll find it worth it to write very compact code. The machine architectures of those days reflected this need by providing extremely powerful instructions. Hence you could express code like:</p>

<pre><code>s = s + a[j]
j = j + 1
</code></pre>

<p>with just one instruction, given that <code>s</code> and <code>j</code> were in a register.</p>

<p>Thus we have language features in C that allowed the compiler without much effort to generate efficient code line:</p>

<pre><code>register int s = 0;           // clr r5
s += a[j++];                  // mov j+, r6   move j to r6 and increment j after
                              // add r5,a[r6]
</code></pre>

<p>The same goes for the short-cut operations like <code>+=</code>, <code>-=</code>, <code>*=</code> etc.</p>

<p>They are </p>

<ol>
<li>A way to save typing</li>
<li>A help for a compiler that had to fit in small RAM, and couldn't afford much optimizations</li>
</ol>

<p>For example,</p>

<pre><code>a[i] *= 5
</code></pre>

<p>which is short for</p>

<pre><code>a[i] = a[i] * 5
</code></pre>

<p>in effect saves the compiler some form of common subexpression analysis.</p>

<p>And yet, all that language features, can always be replaced by equivalent, maybe a bit longer code that doesn't use them. Modern compilers should translate them to efficient code, just like the shorter forms.</p>

<p>So the bottom line and answer to your question: you don't need to look for cases where one <em>needs</em> to apply those operators. Such cases simply do not exits.</p>
",6
22130390,22123467,2,"<p>As others have said, you never ""need"" either flavor of the <code>++</code> and <code>--</code> operators. Then again, there are a lot of features of languages that you never ""need"" but that are useful in clearly expressing the intent of the code. You don't need an assignment that returns a value either, or unary negation since you can always write <code>(0-x)</code>... heck, if you push that to the limit you don't need C at all since you can always write in assembler, and you don't need assembler since you can always just set the bits to construct the instructions by hand...</p>

<p>(Cue Frank Hayes' song, <em>When I Was A Boy</em>. And get off my lawn, you kids!)</p>

<p>So the real answer here is to use the increment and decrement operators <em>where they make sense stylistically</em> -- where the value being manipulated is in some sense a counter and where it makes sense to advance the count ""in passing"". Loop control is one obvious place where people expect to see increment/decrement and where it reads more clearly than the alternatives. And there are many C idioms which have almost become meta-statements in the language as it is actually used -- the classic one-liner version of strcpy(), for example -- and which an experienced C programmer will recognize at a glance and be able to recreate at need; many of those do take advantage of increment/decrement as side effect.</p>

<p>Unfortunately, ""where it makes sense stylistically"" is not a simple rule to teach. As with any other aspect of coding style, it really needs to come from exposure to other folks' code and from an understanding of how ""native speakers"" of the programming language think about the code.</p>

<p>That isn't a very satisfying answer, I know. But I don't think a better one exists.</p>
",2
22130591,22123467,0,"<p>Usually, it just depends on what you need in your specific case. If you <strong><em>need</em></strong> the result of the operation, it's just a question of whether you need the value of the variable before or after incrementing / decrementing. So use the one which makes the code more clear to understand. </p>

<p>In some languages like C++ it is considered good practice to use the pre-increment / pre-decrement operators if you <strong><em>don't need</em></strong> the value, since the post operators need to store the previous value in a temporary during the operation, therefore they require more instructions (additional copy) and can cause performance issues for complex types. </p>

<p>I'm no C expert but I don't think it really matters which you use in C, since there are no increment / decrement operators for large structs. </p>
",0
27748846,3555108,4,"<p>Better to used <code>fgets()</code> than <code>scanf()</code> for reading a line of user input.</p>

<p>If code must use <code>scanf()</code> then</p>

<pre><code>char buf[100];

// Read up to 99 char and then 1 \n
int count = scanf(""%99[^\n]%*1[\n]"", buf);

if (count == EOF) {
  Handle_EndOfFile();  // or IO error
}

if (count == 0) {  // Input began with \n, so read and toss it
  scanf(""%*c"");
}
</code></pre>

<p>Now parse <code>buf</code> for individual words.</p>
",0
33581602,5224244,-2,"<p>it was simple,why because,in it you just want to print in the form of rows and columns and that should be in increasing order. in the first for loop,you are going to print rows and with included for loop you need to do it for columns.</p>
",0
21603967,21603907,3,"<p>You can't have declarations as part of an expression. You need to figure out another way of handling conditional compilation/declarations (perhaps using the preprocessor?).</p>

<hr>

<p>One possible way may be to have a common base structure, with the ""toggle"" as a flag in it, and use pointer to this base-structure type-casted to the correct structure. A soft of ""inhearitance"" in C, so to say. Something like</p>

<pre><code>enum Type
{
    TYPE_A,
    TYPE_B
};

struct Base
{
    int type;  /* One of the Type enumerations */
};

struct A
{
    struct Base base;
    int field_unique_to_a;
};

struct B
{
    struct Base base;
    double field_unique_to_b;
};

int main(void)
{
    int toggle = 1;
    struct Base *base_ptr;

    if (toggle == 1)
    {
        base_ptr = calloc(1, sizeof(A));  /* Use calloc to initialize the data */
        base_ptr-&gt;type = TYPE_A;
    }
    else
    {
        base_ptr = calloc(1, sizeof(B));  /* Use calloc to initialize the data */
        base_ptr-&gt;type = TYPE_B;
    }

    /* Now `base_ptr` points either to a `A` or a `B` structure */

    if (base_ptr-&gt;type == TYPE_A)
    {
        ((struct A *) base_ptr)-&gt;field_unique_to_a = 1;
    }
    else
    {
        ((struct B *) base_ptr)-&gt;field_unique_to_b = 12.34;
    }

    /* ... */
}
</code></pre>
",0
33584429,33583686,1,"<p>So here as I said you have the following problems:</p>

<ul>
<li><code>execv</code> needs as 2nd parameter a NULL-terminated array (so last value must be a NULL value)</li>
<li>this parameter also starts with the ""program name"" so the real 1st parameter (as you intend it) is <code>args[1]</code> and not <code>args[0]</code></li>
<li>you also should check for errors and check for returned values</li>
<li>beware that <code>%10s</code> means that <code>scanf</code> will read 10 characters max + add a leading <code>\0</code> after that, so it could be 11 characters! Use <code>%9s</code> or increase your allocation size</li>
</ul>

<p>Here is a sample code that perform mostly the same (using <code>/bin/echo</code> command rather than <code>./prinargs</code>):</p>

<pre><code>int main()
{
  char  * args[4];  // 1 for bin name, 2 for args, 1 for NULL
  args[0] = ""/bin/echo"";  // you may put what you want here, in fact
  args[1] = (char*)malloc(sizeof(char)*10);
  args[2] = (char*)malloc(sizeof(char)*10);
  args[3] = NULL;  // NULL-terminated

  scanf(""%9s"", args[1]); // read 9 (+1 for \0)
  scanf(""%9s"", args[2]);

  int pid = fork();

  if (pid == -1) {  // handle fork() error
    perror(""fork"");  // print out the reason
    exit(1); // and leave
  } else if (pid == 0) {
    // child
    execv(""/bin/echo"", args);
    perror(""execv""); // we are here only if execv failed
    exit(1);         // so print out error and exit
  }
  // here you should wait for your child to get returned value
  // see wait() and similar functions 
  return 0;
}
</code></pre>

<p>Most of the time it is better to wait for childrens (using <code>wait()</code> family) so that the father don't ends before the child(ren) and you can also get its return status (i.e. the return of the command you exec-ed or your <code>exit()</code> value if <code>execv()</code> failed.</p>
",2
28468999,13199693,1,"<p>I would like to point out that the original code is buggy:</p>

<pre><code>bool is_int(char const* s) {
    int n;
    int i;
    return sscanf(s, ""%d %n"", &amp;i, &amp;n) == 1 &amp;&amp; !s[n];
} 
</code></pre>

<p>I will explain why. And I will interpret the sscanf format string.</p>

<p>First, buggy:</p>

<p>Given input ""1"", which is the integer one, sscanf will store 1 into i. Then, since there is no white space after, sscanf will not touch n. And n is uninitialized. Because sscanf set i to 1, the value returned by sscanf will be 1, meaning 1 field scanned. Since sscanf returns 1, the part of the expression</p>

<pre><code>sscanf(s, ""%d %n"", &amp;i, &amp;n) == 1
</code></pre>

<p>will be true. Therefore the other part of the &amp;&amp; expression will execute. And s[n] will access some random place in memory because n is uninitialized.</p>

<p>Interpreting the format:</p>

<pre><code>""%d %n""
</code></pre>

<p>Attempts to scan a number which may be a decimal number or an integer or a scientific notation number. The number is an integer, it must be followed by at least one white space. White space would be a space, \n, \t, and certain other non-printable characters. Only if it is followed by white space will it set n to the number of characters scanned to that point, including the white space.</p>

<p>This code might be what is intended:</p>

<pre><code>    static bool is_int(char const* s) 
    {
        int i;
        int fld;
        return (fld = sscanf(s, ""%i"", &amp;i)) == 1;
    }

    int main(int argc, char * argv[])
    {
        bool ans = false;

        ans = is_int(""1"");
        ans = is_int(""m"");

        return 0;
    }
</code></pre>

<p>This code is based on, if s is an integer, then sscanf will scan it and fld will be exactly one. If s is not an integer, then fld will be zero or -1. Zero if something else is there, like a word; and -1 if nothing is there but an empty string.</p>
",2
29479849,29479679,6,"<p>C's type promotion system, combined with the fact that the type of the argument is <code>size_t</code>, an unsigned type, precludes there from being any way to detect the incorrect usage from inside the function. However you can detect it from outside via a macro:</p>

<pre><code>#define print(x) do { if ((x)&lt;0) { /* error */ } else print(x); } while(0)
</code></pre>

<p>or similar.</p>
",12
29491511,29479679,0,"<p>You're actually asking for a ""reasonable"" number check rather that negative number check (18446744073709551615 is indeed positive).</p>

<p>I could recommend comparing the size to some arbitrary limit such as 4 terabytes (4,398,046,511,104) (if it is indeed memory size).</p>

<p>If you indeed want to check for negative numbers, in gcc you can cast to <code>ssize_t</code> and then compare to 0.</p>
",0
24597740,24597603,0,"<p>An idiomatic way to have arrays containing data of variable length in C is to use a buffer with a maximum size which is known at compile time, is that what you wanted?</p>

<pre><code>#include &lt;stdio.h&gt;

#define MAX_SIZE 15
typedef struct {
    int arr[MAX_SIZE];
    size_t arr_len;
} rec_t;

void pa(rec_t rec){
    for(int z=0; z&lt;rec.arr_len; z++){
        printf(""array[%2d] is %d\n"", z, rec.arr[z]);
    }

}

int main(void){
        rec_t rec ={
            .arr = {9,8,7,6,5,4,3,2,1,0},
            .arr_len = 10
        };
        pa(rec);
}
</code></pre>
",1
22132138,22131857,0,"<p>I also had same assignment last year. Your need not to handle input and output from one process to another separately. Just initialize pipes between the series of processes and the flow of input and output would take place itself. You only need to give input to first command and take output from the last command.</p>

<p>Following is code snippet I used.</p>

<pre><code>#include &lt;fcntl.h&gt;
#include &lt;errno.h&gt;
#include &lt;dirent.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stddef.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pwd.h&gt;
#include &lt;grp.h&gt;
#include &lt;time.h&gt;
#include &lt;sys/wait.h&gt;

int exit_flag = 0;

#define ARG_SIZE 100



int main ()  
{

    int size = 1000,i,j;
    int pipe_count = 0;
    int fd[100][2],cid1,cid2,length,status;


    char string[][100] = {""ls"",""wc""};

    pipe_count = 1;

    if(pipe_count)
    {
        for(i = 0;i &lt; pipe_count;i++)
        {
            pipe(fd[i]);
        }

        for(i = 0;i &lt;= pipe_count;i++)
        {
            cid1 = fork();
            if(!cid1)
            {

                if(i!=0)
                {
                    dup2(fd[i-1][0],0);
                }


                if(i!=pipe_count)
                {
                    dup2(fd[i][1],1);
                }


                for(j = 0;j &lt; pipe_count;j++)
                {   
                        close(fd[j][0]);
                        close(fd[j][1]);
                }

                execlp(string[i], string[i], NULL);
                exit(0);
            }


        }
        for(i = 0;i &lt; pipe_count;i++)
        {
            close(fd[i][0]);
            close(fd[i][1]);
        }
        waitpid(cid1,&amp;status,0);


    }
    else
    {
        execlp(string[0], string[0], NULL);
    }


    return 0;
}
</code></pre>

<p>In above code <code>string[]</code> array contains all commands separated by <code>'|'</code> in sequence. <code>fd[][2]</code> is array of file descriptors. <code>fd[i][0]</code> is input of <code>i+1</code> command and <code>fd[i][1]</code> is output of <code>ith</code> command. So output of <code>i</code> goes to input of <code>i+1</code> using <code>fd[i]</code> pipe.    </p>

<p>I don't remember now how the dup2 and close commands were handled. May you may get them since you have done them recently. I there is any doubt then I would try my best to clarify.</p>
",10
28217717,28217658,7,"<p>From chapter 6.5.13, Paragraph 4, <code>C99</code> standard, regarding Logical AND operator [<code>&amp;&amp;</code>]</p>

<blockquote>
  <p>the &amp;&amp; operator guarantees left-to-right evaluation</p>
</blockquote>

<p>and</p>

<blockquote>
  <p>If the first operand compares equal to 0, the second operand is not evaluated.</p>
</blockquote>

<p>So, your second code is as efficient as your first one and also comes with better readability.</p>
",4
21303640,21303529,1,"<p>Your buff array should be at least nob bytes long for the write call to succeed...</p>
",0
21303698,21303529,2,"<p>According to man of <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/write.html"" rel=""nofollow"">write</a> <code>write() writes up to count bytes from the buffer pointed buf to the file referred to by the file descriptor fd</code> so you are overrunning the string buffer.</p>

<p>If you want to just fill the file with that string try <a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/fwrite.html"" rel=""nofollow"">fwrite</a>, you can specify the string length and the total number of times to write the buffer (nob/strlen(buff) ?).</p>
",3
21304968,21303529,2,"<pre><code> ssize_t write(int fd, const void *buf, size_t nbytes);
</code></pre>

<p><code>write()</code> system call will read <code>nbytes</code> bytes from <code>buf</code> and write to file referred by the file descriptor <code>fd</code>.</p>

<p>In your program <code>buf</code> is small compare to <code>nbytes</code> so <code>write()</code> trying to access invalid address location, so its giving Bad Address error.</p>

<p>Your <code>buf</code> is <strong>buff[30]</strong> change to <strong>buf[1000000]</strong> you can solve your problem.</p>

<p><em>Bad Address error means that the address location that you have given is invalid</em>.</p>

<p><a href=""http://en.wikipedia.org/wiki/Write_%28system_call%29"" rel=""nofollow"">Wikipedia giving good explanation with example program about write</a>.</p>
",0
28203152,8707857,5,"<p>For me this problem was caused by a missing ) at the end of an if statement in a function called by the function the error was reported as from.  Try scrolling up in the output to find the first error reported by the compiler.  Fixing that error may fix this error.  </p>
",0
29220647,29220388,5,"<p><code>""\n""</code> in <code>if (scanf("" %s %d %d\n""</code> prevents <code>scanf()</code> from returning until non-white-space is entered after the 2nd <code>int</code>.</p>

<p><code>""\n""</code>  does not simply scan in a <code>'\n'</code>,  It scans in all white-space until another non-white-space occurs.  This usually involves a 2nd line of text as user input is line buffered.</p>

<p>Drop the <code>'\n'</code> at the end of <code>"" %s %d %d\n""</code>.</p>

<p>Better yet, read using <code>fgets()</code> and drop using <code>scanf()</code>.  Use <code>sscanf()</code>, <code>strtok()</code>, <code>strtod()</code>, etc. instead.</p>
",0
22129336,22129274,2,"<p>Your program has at least two problems, the first is <code>%c</code> in <code>scanf()</code> is used for single <code>char</code>, not a string, you should use <code>%s</code> instead, or better, use <code>fgets()</code> for this job.</p>

<pre><code>fgets(fileName, sizeof(fileName), stdin);
</code></pre>

<p>The second is that you are using <code>==</code> to compare strings, <code>if(fileName == ""\\0"")</code> would NEVER be true. <code>strcmp()</code> is the function you are looking for:</p>

<pre><code>if (strcmp(fileName, ""\\0"") == 0)
</code></pre>
",1
25528714,25528380,1,"<p>Arrays (or strings) in many circunstances, are converted to the address of their first element.</p>

<p>In your code, inside the <code>printf()</code>, these addresses are being compared.</p>

<p>To compare the stuff pointed to by the addresses you need <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/strcmp.html"" rel=""nofollow""><code>strcmp()</code></a> (for real strings) or <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/memcmp.html"" rel=""nofollow""><code>memcmp()</code></a> (for binary data)</p>

<pre><code>char buffer[] = {'e','a','b','g','e','l','e','g','o','n','\000','p','k','n','m','l','\000','j', 'i', 'h'};

int equal1 = memcmp(buffer, ""eabgelegon\000pknml\000jih"", 20);
printf(""%d"", equal1);
int equal2 = memcmp(buffer, ""eabgelegon\000XXXXXXXXX"", 20);
printf(""%d"", equal2);

int equal3 = strcmp(buffer, ""eabgelegon\000pknml\000jih"");
printf(""%d"", equal3);
int equal4 = strcmp(buffer, ""eabgelegon\000XXXXXXXXX"");
printf(""%d"", equal4);
</code></pre>
",0
25530459,25528380,0,"<p>If you don't recognize it:</p>

<pre><code>char buffer[] = {'a', '\0'};
char p2[] = ""a"";
</code></pre>

<p><code>buffer</code> and <code>p2</code> are <strong>exactly</strong> the same. With <code>buffer</code> you declare a character array and assign the first character as <code>'a'</code> and then an explicit <strong>null-terminating character</strong> <code>'\0'</code> giving you a string <code>""a""</code>. With <code>p2</code> you assign the string literal <code>""a""</code> and the null-terminating character is <strong>automatically</strong> appended to the end. Either way -- you get the same thing, <code>buffer</code> and <code>p2</code> hold the string <code>""a""</code>.</p>
",3
25531685,25528380,1,"<p>None of OP's 3 <code>buffer</code> are best described as C strings.  Simply arrays of <code>char</code>.</p>

<pre><code>char buffer[] = {'a', '0'};  // No terminating \0
char buffer[] = {'a', '0'};  // No terminating \0
// No terminating \0 yet has embedded \0
char buffer[] = {'e','a','b','g','e','l','e','g','o','n','\000','p','k','n','m','l','\000','j', 'i', 'h'};
</code></pre>

<p>Since OP ""cannot use any other functions"" ...</p>

<p>Find range of valid indexable memory <code>buffer</code> and <code>p2</code>.  The valid indexable range of  <code>buffer</code> is <code>0</code> to <code>sizeof(buffer) - 1</code>.</p>

<p>The same for <code>p2</code> (the string literal) is complicated.  If <code>p2</code> was a typical C string, the range is <code>0</code> to <code>strlen(p2) + 1</code>.  But a string literal such as <code>""eabgelegon\000pknml\000jih""</code> has embedded <code>'\0'</code> in it (as well as a terminating <code>'\0'</code>), so its range cannot be determined at run time with <code>strlen()</code>, but only at compile time with <code>sizeof()</code>.</p>

<p>Let's assume the comparison should not include the string literal's terminating <code>'\0'</code>.</p>

<pre><code> char buffer[] = 'e','a','b','g','e','l','e','g','o','n','\000','p','k','n','m','l','\000','j', 'i', 'h'};
 char p2[] = ""eabgelegon\000pknml\000jih""; // matches
 //char p2[] = ""eabgelegon\000pknml\000ji ""; // fails
 //char p2[] = ""eabgelegon\000pk ml\000jih""; // fails

 size_t buffer_size = sizeof(buffer);
 size_t p2_size = sizeof(p2);
 // p2 should be 1 longer than buffer due to its terminating \0
 if (buffer_size + 1 != p2_size) return NOT_EQUAL; 

 size_t i;
 for (i=0; i&lt;buffer_size; i++) {
   if (buffer[i] != p2[i]) return NOT_EQUAL;
 }
 return EQUAL;
</code></pre>

<p>Note: <code>sizeof()</code> is not a function in C, but an operator.</p>
",0
29475363,29475329,2,"<p>You could use a recursive function.</p>
",3
27126509,27126387,3,"<p>When you use <code>va_arg()</code> ""function"" on the <code>va_list</code> obtained from <code>va_start()</code>, the <code>va_list</code> is modified, so when passed to another function it is NOT the same as you got at the beginning. You could treat <code>va_list</code> as an pointer, and using <code>va_arg()</code> is sth like increment operator (++). You call your function like this:</p>

<pre><code>log(""%s gestartet: PID = %d"", argv[0], getpid());
</code></pre>

<p>But vfprint most likely sees it like this:</p>

<pre><code>vfprintf(fd, ""%s gestartet: PID = %d"", /* argv[0], &lt;-- REMOVED */ getpid());
</code></pre>
",6
32420015,32419998,1,"<p>You shouldn't ever rely on the addresses provided by the allocator falling within a specific range. Even if you could show that on a particular Linux setup, <code>malloc</code> can only generate addresses between X and Y, there is no guarantee--it could change with any future update. The only guarantee from <code>malloc</code> is that successful allocations won't start at <code>NULL</code> (address 0 in code, for Linux and most other typical platforms).</p>
",6
32420019,32419998,0,"<p>Yes, for a 32 bit or 64 bit OS.  Whether there's anything usable there, or if you'll get an access violation trying to dereference the pointer, is up to the compiler and OS.</p>
",0
32420029,32419998,0,"<p>The OS can map pages of physical memory anywhere in the address space.  The addresses you see don¡¯t correspond to physical RAM chips at all.  The OS might, for example, have virtual memory or copy-on-write pages.</p>
",0
32420357,32419998,3,"<p>The standard says that </p>

<ol>
<li>For two elements of an array, the address of the element with the lower subscript will always compare less to the address of the object with the higher subscript. </li>
<li>Comparing any two elements that are not part of the same aggregate (array or struct) is <strong>undefined behavior</strong>.</li>
</ol>

<p>So if <code>buf + len</code> and <code>some_pointer</code> point to elments in the same array as <code>buf</code> (or one past the array), you don't have to worry about wrap arround. If one of them doesn't, you have <strong>undefined behavior</strong> anyway.</p>
",3
31230163,31230141,4,"<p>Make it <code>if (strcmp(""fahr"", argv[1]) == 0) </code> <br>
The placement of closing parenthesis is wrong, hence the error <br> Similarly, change the else if condition to <br> <code>(strcmp(""celsius"", argv[1]) == 0) </code> <br> Also, your variable <code>fahr</code> is float, where as you are assigning it to argv[2], which is of char* type, hence you getting an error. <br> So you need to convert char* to float or double. <code>atof</code> function will help you out here. Try this <br> <code> fahr=atof(argv[2]);</code><br> Make sure you include <code>stdlib</code> header file.</p>
",3
31230248,31230141,3,"<p>There are some various errors here.</p>

<pre><code>main.c:16:21: warning: incompatible integer to pointer conversion passing 'int'
      to parameter of type 'const char *' [-Wint-conversion]
        if (strcmp(""fahr"", argv[1] == 0)){
                           ^~~~~~~~~~~~
</code></pre>

<p>The parentheses are simply wrong. It should be <code>if (strcmp(""fahr"", argv[1]) == 0</code>).</p>

<pre><code>main.c:17:8: error: assigning to 'float' from incompatible type 'char *'
                fahr = argv[2];
                     ^ ~~~~~~~
</code></pre>

<p>You can't assign a string to a float, you have to use some function to convert it. E.g. <code>fahr = strtof(argv[2], 0)</code>. You need to include the header <code>&lt;stdlib.h&gt;</code> for <code>strtof</code>.</p>

<pre><code>main.c:19:4: warning: implicit declaration of function 'fahr_conversion' is
      invalid in C99 [-Wimplicit-function-declaration]
                        fahr_conversion(fahr);
                        ^
</code></pre>

<p>When <code>main</code> uses <code>fahr_conversion</code> before <code>fahr_conversion</code> appears in the source, the compiler doesn't yet know the type of <code>fahr_conversion</code>, so it assumes a standard type (which almost always is not what you want). This is solved by adding a function prototype <em>before</em> main:</p>

<pre><code>int fahr_conversion(float fahr);
</code></pre>

<p>Though, I wonder whether <code>int</code> really is the return type you want. If you aren't returning anything, the return type should be <code>void</code>.</p>
",2
31230257,31230141,2,"<p>First, you want to test if the first parameter was a ""fahr"" string. So you should do:<br>
compare strings:</p>

<pre><code>strcmp(""fahr"", argv[1])
</code></pre>

<p>test the comparision result</p>

<pre><code>strcmp(""fahr"", argv[1]) == 0
</code></pre>

<p>and perform action dependant on the test result</p>

<pre><code>if( strcmp(""fahr"", argv[1]) == 0) {.....}
</code></pre>

<p>Find out the difference to your code!</p>

<p>Second, you want to take a second parameter as a numeric value. Alas it is a character string! You will not get appropriate result by assigning the string to a <code>float</code> variable. You need some strig-to-float convertion function. On of possibilities is <code>atof()</code>:</p>

<pre><code>fahr = atof( argv[2] );
</code></pre>
",2
28185013,28184782,0,"<p>Please Try This...</p>

<pre><code>#include &lt;stdio.h&gt;
void print_byte(unsigned number, unsigned order)
{
    unsigned i = 0;

    i = (number &gt;&gt; (8*order)) &amp; 0x000000FF;

    printf(""Number:0x%08x, Byte:%02x, Order:%d\n"",number,i,order);

    return;
}

int main(void) {

    print_byte(0x1f2e3d4c,0);
    print_byte(0x1f2e3d4c,1);
    print_byte(0x1f2e3d4c,2);
    print_byte(0x1f2e3d4c,3);

    return 0;
}
</code></pre>
",1
28197264,28184782,0,"<p>If using C99 or later, use the length modifier <code>""hh""</code> after shifting.  This modifier will convert the integer to <code>unsigned/signed char</code> before printing.  Use 8 or <code>CHAR_BIT</code> depending on meaning of ""byte"".</p>

<pre><code>printf(""%hhX"", number &gt;&gt; (order * 8));
</code></pre>

<p>or</p>

<pre><code>#include &lt;limits.h&gt;
printf(""%hhX"", number &gt;&gt; (order * CHAR_BIT));
</code></pre>
",0
21307582,21307454,1,"<p>The <code>creat</code> function opens the file after creating it, so from your description, simply calling <code>creat()</code> is sufficient for your needs.</p>

<p>To answer your question, it gives you multiple file descriptors because you've performed multiple opens (creat is an open with creation). You can access the same file using both descriptors (and your current location within the file can differ for each descriptor).</p>
",0
21307741,21307454,1,"<p>Literally creat() function is equivalent to open(pathname, O_RWONLY | O_CREAT | O_TRUNCATE, mode) so your second open() is redundant. 
You should also keep in mind that the fd is just a handler of your current process. Different handler may point to the same file as we call it ""File Sharing"". 
Another suggestion is, try </p>

<pre><code>if (write(fd, buff, 100) != 100)
    /*Error handling codes*/
</code></pre>

<p>to make sure the write() works correctly. </p>
",0
25663614,25663567,6,"<p>Your shell is expanding <code>*</code> to a list of files in the current folder. Try quoting the <code>*</code> by enclosing it in double or single quotes.</p>

<p>You could have found out yourself by iterating over <code>argv</code> and printing all the parameters.</p>
",0
25663621,25663567,1,"<p>When you are running the binary, the input <code>argv[]</code> is considered as the number of the files present in that directory. </p>

<p>The <code>*</code> in a shell environment usually denotes all files present in that directory. Maybe using <code>"" ""</code> can be a good idea to consider the input <code>*</code> as you want it[string].</p>
",0
25663663,25663567,2,"<p>On a UNIX like operating system the system shell expands operators like ""*"" before executing the command. The * operator will list all files in the current directory and supply it as a list of parameters to your program. It is very likely that you have exactly 8 files in your working directory. Try to put the star in ""*"" if you really want to provide a * as input parameter to your program.</p>
",0
24636088,24634999,1,"<p>I assume that your compilation error is in the commented lines, and you've got this message from the compiler when they were not in a comment.</p>

<p>I can see that you've tried to instantiate an array of length 2, that each cell of it will contain the st struct that you've defined in the previous macro. For this purpose you can simply do:</p>

<pre><code>st str[2] = {ST_ALLOC,ST_ALLOC};
</code></pre>

<p>Now it compiles and the running output is:</p>

<pre><code>st.s1.a : 20 st.t1.d : 10
</code></pre>
",0
24636275,24634999,1,"<p>The curly-bracket notation is for initializing arrays and can't be used after the definition line.  This is really why the compilation error existed in the lines commented out.</p>

<p>As Mickey pointed out, the issue is a little confused by the misleading intialization. If you wanted to initialize both <code>st</code> in an array of two <code>st</code> you should use <code>{ST_ALLOC, ST_ALLOC}</code>.  If it were just one <code>st</code>, this would initialize all elements:</p>

<pre><code>st str = ST_ALLOC;
</code></pre>
",0
24636211,24634999,1,"<p>i get only some compiler warnings</p>

<pre><code>test2.c: In function ¡®main¡¯:
test2.c:25:2: warning: missing braces around initializer [-Wmissing-braces]
test2.c:25:2: warning: (near initialization for ¡®str[0].s1¡¯) [-Wmissing-braces]
</code></pre>

<p>you get the warnings because you only initialize 1 of the 2 structs you declared.</p>

<p>because you are only printing <code>str[1]</code>, I suppose you want to initialize <code>str[0]</code> to <code>0</code>, therefore you have to change the define to:</p>

<pre><code>#define ST_ALLOC {{{0,0},{0,0}},{{20,20},{10,10}}}
</code></pre>
",0
25469075,25469067,1,"<p>The answer is simple you dont have <code>long float</code> and <code>long long long int</code> in C. The language designers <a href=""http://en.wikipedia.org/wiki/C_data_types"" rel=""nofollow"">have not defined them</a> to be used in C.</p>

<p>Also to add that long is equivalent to long int just like short and short int.</p>

<p>On most of the 32-bit platforms:</p>

<ul>
<li>int is specified as 32 bits</li>
<li>long is specified as 32 bits as well</li>
<li>long long is specified as 64 bits</li>
</ul>

<p>On most of the 64-bit platforms:</p>

<ul>
<li>int is specified as 32 bits</li>
<li>long is specified as either 32 or 64 bits</li>
<li>long long is specified as 64 bits as well</li>
</ul>

<p>On a side note</p>

<p><strong>long long</strong> is not part of C89/CC90, nor part of C++98 or C++03, but does exist in C99 (and therefore in C11) and in C++11 (and therefore in C++14).</p>
",0
25469085,25469067,1,"<p><code>long float</code> is essentially (and used to be a synonym for) a <code>double</code>. Adding extra <code>long</code>s to an integer type has to stop somewhere, and 64 bits is the compromise chosen (since it's generally directly representable on most processors). </p>
",2
25469086,25469067,3,"<p>At one time, <code>long float</code> was a synonym for <code>double</code>, but the C standard ruled it illegal.  There's an outside chance that a compiler in non-conforming mode would accept <code>long float</code> still.</p>

<p>You can't use <code>long long long int</code> because there is as yet no precedent implementing it (128-bit integer?) and because it would be extremely clumsy.</p>

<h3>Archaeology</h3>

<p>The first edition of K&amp;R ""The C Programming Language"" published in 1978 has a version of ""C Reference Manual"" which does have <code>long</code> and explicitly mentions <code>long float</code> as one of the possible types.  However, the main text does not seem to mention <code>long float</code>.</p>

<p>Volume 2A of the UNIX? Programmer's Manual for 7th Edition Unix is available online at <a href=""http://www.cs.bell-labs.com/7thEdMan/"" rel=""nofollow"">Bell Labs</a>; it was published as a whole in January 1979.  It has a version of ""C Reference Manual"" which makes no reference to the keyword <code>long</code>, and therefore does not recognize <code>long float</code>. (Note that although most chapters of Volume 2A are available separately, this chapter is not, but it is included in the PDF and Postscript versions made available via a link on the main page.  <s>Given that the separate chapter is not available for copyright reasons, I cannot formally rule out the possibility that the chapter in the composite Volume 2A PDF is actually an earlier edition of ""C Reference Manual"".</s> <em>Update:</em> I found my bound, printed, published version of UNIX Programmer's Manual Volume 2 (published 1983, ISBN 0-03-061743-X) and indeed, that chapter is preceded by 'This manual is reprinted, with minor changes, from <em>The C Programming Language</em>, by Brian W. Kernighan and Dennis M. Ritchie, Prentice-Hall, Inc., 1978.'  It lists <code>long</code> as a keyword.  Therefore, the version available in the PDF is indeed from an older revision of the ""C Reference Manual"".  The older version is useful in that it substantiates my claim that <code>long</code> and hence <code>long float</code> were not always a part of the C language.)</p>

<p>The C language was in some flux in the period 1978-1979, therefore.  Structure assignment and passing and returning structures to functions was added a little later still, but well before the C89 standard.</p>
",4
25469089,25469067,4,"<p>Originally <code>long long int</code> was not in the language specification (<code>long int</code> was the largest signed integer type in C). Later <code>long long int</code> was introduced. Maybe one day we'll see <code>long long long int</code> in C language as well, but that day is yet to come.</p>

<p>As for <code>long float</code>... there is not much sense in it. The next larger floating-point type already has a name and it is called <code>double</code>. <code>long float</code> would be just like <code>long short</code> or <code>long char</code>.</p>
",2
22855414,7055397,0,"<p>One case in the switch statement is wrong. You are calculating day by using the following code</p>

<pre><code>day=dayextra%7
</code></pre>

<p>But if you mod a number by 7, the output should be less than 7. So, your cases should be 0,1,2....6</p>

<p>That implies that your following case is wrong</p>

<pre><code>case '7':printf(""\nfri"");
</code></pre>

<p>Re-arrange the code using following cases</p>

<pre><code>switch(day)
  {
   case '0':printf(""\nsun"");
       break; 
   case '1':printf(""\nmonday"");
       break;
   case '2':printf(""\ntuesday"");
       break;
   case '3':printf(""\nwed"");
       break;
   case '4':printf(""\nthu"");
       break;
   case '5':printf(""\nfri"");
    break;
   case '6':printf(""\nsat"");
       break; 
  }
</code></pre>

<p>Hope this will work for you.</p>
",0
27131021,27130904,3,"<p>use:</p>

<pre><code>for(int fadeValue = startingPoint ; fadeValue &gt;= 0;
    fadeValue = (fadeValue==1 || fadeValue==2) ? 0 : fadeValue-3)
</code></pre>

<p>This ensures that there is a last iteration with 0 after one with 1 or 2, without making the loop infinite.</p>
",1
27130304,27127568,0,"<p>Something like this perhaps?</p>

<pre><code>for i in object1.o object2.o object3.o; do echo $i; strings |grep ""thing to find""; done
</code></pre>
",0
33606993,33606876,4,"<p>In the realloc, you've failed to include the</p>

<pre><code>* sizeof(int)
</code></pre>

<p>part, so you are reallocating not enough memory.</p>
",1
33607057,33606876,1,"<p>You forgot to multiply with sizeof(int) in the realloc()</p>
",0
24108803,24108758,3,"<p>Until unless you press <code>EOF</code>, <code>(getchar() != EOF)</code> will return <code>true</code> which assigns <code>1</code> to <code>c</code>. That's why you are getting output always as <code>11</code>, first <code>1</code> for the character you entered and second <code>1</code> is for <code>\n</code> passed to the input buffer on pressing <kbd>Enter</kbd> key.   </p>

<p>Similarly in case of <code>putchar</code> it prints the character corresponding to the  returned value <code>1</code> which is non-printable (printable characters start from <code>32</code>) and you will get some weird output, one for input character and another for <code>\n</code>.   </p>

<p>Now change the parentheses in conditional expression to  </p>

<pre><code>while( (c=getchar()) != EOF ){...}   
</code></pre>

<p>Now it will work as it should but will give you two ASCII code in first case (one for <code>\n</code>).  </p>
",4
24108829,24108758,2,"<blockquote>
  <p>1) In the first case, why is the output printing more than 1 1's?</p>
</blockquote>

<p>Because you are looking for an <code>EOF</code>. In order to send your program <code>EOF</code> from the keyboard, press <kbd>Ctrl</kbd>+<kbd>Z</kbd></p>

<blockquote>
  <p>2) Why isn't the output of case 2 same as case 1?</p>
</blockquote>

<p>Because <code>%d</code> produces a decimal representation of the character code, while <code>putchar</code> produces the character itself. For example, if you print <code>'A'</code> using <code>printf</code>'s <code>%d</code> format, you would see <code>65</code> - ASCII code of the uppercase character <code>A</code>. On the other hand, if you print it using <code>putchar</code>, you would see character <code>A</code> itself.</p>

<p><a href=""http://ideone.com/9y0GFl"" rel=""nofollow"">Demo on ideone.</a></p>
",1
27551365,27551316,4,"<p>Add a function declaration before <code>main</code>:</p>

<pre><code>void congratulateStudent(char *student, char *course, int numDays);
</code></pre>

<p>UPDATE 1: You can alternatively move the <code>congratulateStudent</code> function before <code>main</code>.</p>

<p>UPDATE 2: The answer that you refer to in the link, focuses on that the user uses wrong argument types in the function than those he/she intends to use in: <code>char, char, int</code> and that <code>%s, %s, %d</code> used in <code>printf</code> work for <code>char*, char*, int</code> types, so this is something different.</p>
",7
27551398,27551316,0,"<p>Try this:</p>

<pre><code>#include &lt;stdio.h&gt;

void congratulateStudent(char *student, char *course, int numDays) {
   printf(""%s has done as much %s Programming as I could fit into %d days.\n"",
       student, course, numDays);
}

int main(int argc, const char * argv[])
{

congratulateStudent(""Kate"", ""Cocoa"", 5);

return 0;
}
</code></pre>
",0
27551437,27551316,3,"<p>It's because in your main function, the <code>congratulateStudent</code> function was not declared yet, and the compiler assumes it returns <code>int</code> by default, then you define it below to return <code>void</code>, hence the</p>

<pre><code>Conflicting types for 'congratulateStudent'
</code></pre>

<p>so either declare the function before <code>main</code> or move it's definition before <code>main</code>, both solutions work.</p>
",2
27551537,27551316,0,"<p>You should make sure your compiler's warning flags are set: <code>-Wall -Wextra</code>.  Those should have given you a warning that the compiler didn't understand the function <code>congratulateStudent</code> within <code>main</code>.  My compiler gave me the output</p>

<pre><code>line 6: warning: implicit declaration of function `congratulateStudent'
</code></pre>

<p>These sorts of warnings can help you figure out where your mistakes are.</p>

<p>And, to fix both the warning and the error, we can add a function prototype near the top of the code:</p>

<pre><code>#include &lt;stdio.h&gt;

void congratulateStudent(char *student, char *course, int numDays);

int main(int argc, const char * argv[])
{
...
</code></pre>
",0
26798717,8831323,-2,"<pre><code>main(int argc, char *argv[])
{
    char *input = ""Enter Any string"";
    printf(""your Entered String is: %s\n"", input);

    int length = 0;
    while (input[length] != '\0') {
          length++;
    }

    printf(""length is : %i\n"", length); 
}
</code></pre>
",1
24379120,24379084,5,"<p>Recall that <code>~</code> is the bitwise NOT operator, and that <code>0</code> is an integer, <code>sizeof(int)</code> bytes in size.</p>

<p>Since <code>0</code> is all bits set to zero, <code>(~0)</code> is all bits set to 1.</p>

<p>If (like most systems), your <code>sizeof(int)==4</code>, then <code>(~0) == 0xFFFFFFFF</code>.</p>

<p>Basically, this is <code>delay</code>ing for the maximum value possible (assuming <code>delay(unsigned int)</code>)</p>

<hr>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;limits.h&gt;

int main(void)
{
    printf(""sizeof(0)=%d sizeof(~0)=%d\n"", sizeof(0), sizeof(~0));
    printf(""0x%X\n"", (~0));
    printf(""%d\n"", (~0)==UINT_MAX);
    return 0;
}
</code></pre>

<p>Output:</p>

<pre class=""lang-none prettyprint-override""><code>$ ./a.out
sizeof(0)=4 sizeof(~0)=4
0xFFFFFFFF
1
</code></pre>
",6
24379151,24379084,0,"<p>By default, all integer constants are treated as <code>signed int</code>. However when you print it using <code>printf</code>, then the argument will be typecasted/promoted according to the format specifier.</p>

<p>In <code>delay(~(0));</code> I assume <code>delay()</code> will always expect a <code>unsigned int</code> argument hence <code>~0 == 0xffffffff</code> (since <code>int</code> is 4 bytes, hence <code>0xffffffff</code>) will be type promoted to <code>unsigned int</code>.</p>
",0
24379153,24379084,0,"<p><code>~0</code> is an int with all 1 bits (since the unary <code>~</code> is the bitwise not operator). On most machines, it is <code>-1</code> on <a href=""http://en.wikipedia.org/wiki/Two%27s_complement"" rel=""nofollow"">two's complement</a> machines like <a href=""http://en.wikipedia.org/wiki/X86"" rel=""nofollow"">x86</a></p>

<p>So <code>printf(""%d\n"", ~0);</code> outputs -1.</p>
",0
22112334,22112257,1,"<p>The algorithm builds a long value a byte at a time. If you change all you formats to hexadecimal you should be able to see the number being built up more clearly. </p>
",2
22112435,22112257,1,"<p>As said before it's very useful to see <code>tmp</code> value as Hex:</p>

<pre><code>k = 24
k=num &gt;&gt; k=0
k=k &amp; 0xFF=0
tmp = 0
k = 16
k=num &gt;&gt; k=213
k=k &amp; 0xFF=213 // d5
tmp = d500
k = 8
k=num &gt;&gt; k=54773
k=k &amp; 0xFF=245  // f5
tmp = f5d500
k = 0
k=num &gt;&gt; k=14022014
k=k &amp; 0xFF=126  // obviously 7e
tmp = 7ef5d500
t = 2130040064
</code></pre>

<p>Your code fills <code>tmp</code> as flipped <code>no</code> value:</p>

<pre><code>printf(""t = %x, no = %x\n"", t, no);
t = 7ef5d500,
no = d5f57e
</code></pre>
",1
32389374,32389074,1,"<p>This code has 3 problems:</p>

<pre><code>node = malloc(sizeof(node));
node = new_node;
</code></pre>

<p>Firstly you malloc the wrong number of bytes. Use the pattern <code>node = malloc(sizeof *node);</code> .</p>

<p>Secondly this leaks memory: you point <code>node</code> at a freshly allocated block of memory. Then you point <code>node</code> at the object <code>new_node</code> is pointing at. This leaves no pointers to the allocated block.  </p>

<p>Thirdly, <code>node</code> is a local variable to your function so this change is not seen by code outside your function. </p>

<p>I think you meant the entire function to be something like:</p>

<pre><code>void add(struct node** headRef, int value)
{
// Make the new node
    struct node* new_node = malloc(sizeof *new_node);
    new_node-&gt;value = value;
    new_node-&gt;next = NULL;

// If the list is empty then make the new node be the first node
    if ( *headRef == NULL ) 
        *headRef = new_node;

// Otherwise put this node on the end of the list
    else for ( struct node *ptr = *headRef; ; ptr = ptr-&gt;next )
    {
         if ( ptr-&gt;next == NULL )
         {
              ptr-&gt;next = new_node;
              break;
         }
    }
}
</code></pre>
",0
32394673,32389074,0,"<p>Pointer is just a mechanism to access memory. Different types of pointers has different access mechanisms. Integer pointer reads 4 bytes while character pointer reads only one when you deference it.</p>

<p>For storing something, You need to allocate memory. Once you allocate memory, you can access it using different pointers.
When you write : </p>

<pre><code>  new_node=(struct node*)malloc(sizeof(struct node))
</code></pre>

<p>it means that you are allocating some memory and accessing it using new_node pointer. </p>

<p>When you write:</p>

<pre><code>   node=new_node
</code></pre>

<p>it means that node will point to the same memory new_node is currently referring.You dont need to allocate memory to node since you are just accessing the already allocated memory using it.</p>

<pre><code>void add(struct node** headRef, int value) {
    struct node* node = *headRef;
    struct node* new_node = malloc(sizeof(struct node));//Always mention datatype rather than mentioning a particular value;

    new_node-&gt;value = value;
    new_node-&gt;next = NULL;

    if (node == NULL) {
      //node = malloc(sizeof(node)); //Not required as you are just accessing the pre-allocated memory;

      *headRef = new_node; //Change the actual pointer rather than the local one;
    } else {

      while (node-&gt;next != NULL) {
        node = node-&gt;next;
      }

      node-&gt;next = new_node;
    }
 }
</code></pre>
",0
32950288,8283596,0,"<p><a href=""http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1256.pdf"" rel=""nofollow"">C99 N1256 standard draft</a> 6.10.3.1/1 ""Argument substitution"":</p>

<blockquote>
  <p>After the arguments for the invocation of a function-like macro have been identified,
  argument substitution takes place. A parameter in the replacement list, unless preceded
  by a # or ## preprocessing token or followed by a ## preprocessing token (see below), is
  replaced by the corresponding argument after all macros contained therein have been
  expanded. Before being substituted, each argument¡¯s preprocessing tokens are
  completely macro replaced as if they formed the rest of the preprocessing file; no other
  preprocessing tokens are available.</p>
</blockquote>

<p>So <code>#</code> and <code>##</code> make arguments be treated differently.</p>
",0
25522279,25520888,1,"<p>No your function is working properly! it is executing <code>SIZE</code> times.</p>

<p>But the thing is you are using <code>system(cls);</code>. So it will clear the screen every time when it executes! so due to this you can't see the previous prints on the screen. so you will get only the last print on the screen. </p>

<p>Try this change-</p>

<pre><code>moveDown(int printx) {
    int moved = 0,r;
    for (m=0; m&lt;SIZE; m++) {
        moved = 0;
        for (i=0; i&lt;SIZE-1; i++) {
            for (j=0;j&lt;SIZE;j++) { 
                if (matrix[i+1][j] == ' ') {
                    matrix[i+1][j] = matrix[i][j];
                    matrix[i][j] = ' ';
                    moved = 1;
                }
            }
        }
        i=0;
        for (j=0;j&lt;SIZE;j++) { 
            r = rand_lim(5); // 0 to 5
            if (matrix[i][j] == ' ') {
                matrix[i][j] = arr[r];
            }
        }
        if(printx==1 &amp;&amp; moved==1) {
             //system(""cls"");   // remove or comment out this line  &lt;-- Note
             printScreen();
             // Remove vertical matches
             removeVerticals();
             // Remove horizontal matches
             removeHorizontals();
             waitForIt();
             moved = 0;
        }
    }
}
</code></pre>
",0
24655978,24655848,0,"<p>Don't use gzip, run <a href=""http://linux.die.net/man/1/zip"" rel=""nofollow"">the actual <code>zip</code> binary</a> instead.</p>

<p>Also, there's no need to run a shell, <code>zip</code> is perfectly capable of writing its own output.</p>
",0
26232371,26232022,3,"<p>You can use a binary mask, change:</p>

<pre><code>snprintf(buff, 255, ""%02x"", 0xFFFFFF);
</code></pre>

<p>to</p>

<pre><code>snprintf(buff, 255, ""%02x"", 0xFFFFFF &amp; 0x0000FF);
</code></pre>

<p>E.g.:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void) /* main() is not valid */
{
    char buff[255];
    snprintf(buff, 255, ""%02x"", 0x00BEEF &amp; 0x0000FF);
    printf(""%s\n"", buff);
    return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>ef
</code></pre>
",3
26232109,26232022,4,"<p>Your expectations are wrong.</p>

<p>From <a href=""http://linux.die.net/man/3/printf"" rel=""nofollow"">the manual page for the <code>*printf()</code> family</a>:</p>

<blockquote>
  <p>In no case does a nonexistent or small field width cause truncation of a field; if the result of a conversion is wider than the field width, the field is expanded to contain the conversion result. </p>
</blockquote>

<p>You can truncate strings using the precision (""<code>.N</code>"") modifier, but not using field width:</p>

<pre><code>printf(""%2s and %.2s"", ""foo"", ""foo"");
</code></pre>

<p>prints</p>

<pre><code>foo and fo
</code></pre>

<p>You can't use precision to truncate integers.</p>
",1
26239427,26232022,0,"<p>As <a href=""https://stackoverflow.com/a/26232109/1741125"">Unwind¡¯s answer</a> says, you can only pass a minimum, not a maximum field-width to <code>*printf</code> for integer conversions.</p>

<p>As long as you only convert an integer per call, you can use the size argument to <code>snprintf</code>:</p>

<pre><code>snprintf(buff, 3, ""%02x"", 0x9abcdef);
</code></pre>

<p>Output (with the otherwise unchanged code):</p>

<pre><code>9a
</code></pre>

<p>I changed the number being converted to illustrate the difference to masking, <code>0x9abcdef &amp; 0xff</code> is <code>0xef</code> and masking with <code>0xff000000</code> (the highest-order bytes of a 4-byte integer) yields <code>0x9</code>. I don't know of an easier way to get the two highest-order non-zero nibbles (0-padded on the left if they don¡¯t exist).</p>
",0
31812593,31812363,3,"<p><code>while</code> does not take parameters, but an expression. In your example, <code>while</code> is not taking 2 parameters, but an expression containing 2 subexpressions separated by the <code>,</code> operator. This operator executes both expressions but returns the value produced by the last expression.</p>

<p>In your sample, it is used as a trick to turn a loop into a one-liner, by doing the <code>read()</code> operation inside the <code>while</code> expression.</p>

<p>It's equivalent to this:</p>

<pre><code>do {
    retval = read(fd, buf, size);
} while (retval == -1 &amp;&amp; errno == EINTR);
</code></pre>
",0
22518733,22518671,4,"<p>Pointer arithmetic in C is scaled by the size of the type, which makes these two equivalent:</p>

<pre><code>valA = valA + valB;
valA = &amp;valA[valB];
</code></pre>

<p>If you want to force it to treat it as a byte offset, you'll need a cast to <code>char *</code> first:</p>

<pre><code>valA = (uint32 *)((char *)valA + valB);
</code></pre>
",1
22518760,22518671,0,"<p>Pointer arithmetic is a matter of size of data the pointer is pointing to.</p>

<p>uint32 is 4 bytes large, that's because the result is four times valB.</p>

<p>The question is, why do you want you pointer incremented just by 0x7a0. That doesn't make sense in this situation. It's only useful if you need to access bytes. If you need just that, you would use pointers pointing to a byte.</p>
",0
22518761,22518671,0,"<p>Adding an int to a pointer advances the pointer by that many instances of the datatype the pointer points to. That is, if your systems's <code>sizeof(uint)</code> is 4 bytes, the integer is multipled by 4 before being added to the pointer address.</p>

<p>Essentially, pointer math is isomorphic with array addressing. If <code>p</code> is a pointer and <code>i</code> is an integer, <code>p[i]</code> is the same as <code>*(p+i)</code> ... and in old C compilers, you could even write that as <code>i[p]</code> and get the same result.</p>
",0
22518859,22518671,0,"<p>A <code>uint32</code> takes 4 bytes of space. The next <code>uint32</code> after <code>&amp;valA</code> occurs at <code>&amp;((valA + 4U))</code>.  </p>
",0
22518876,22518671,0,"<p>C and C++ pointer arithmetic must increase the value of the pointer by the size of the type object.</p>

<p>Say you have:</p>

<pre><code>int a[2];
int* b = a;
</code></pre>

<p>At this point <code>b</code> points to the first element of <code>a</code>. Now, increment <code>b</code>.</p>

<pre><code>++b;
</code></pre>

<p>You would expect <code>b</code> to point to the second element of <code>a</code>. The addresses of the first element of <code>a</code> and the second element of <code>a</code> are different by size of <code>int</code>. Hence, if the <code>++b</code> must increment the value of <code>b</code> by the size of <code>int</code>, not just one byte.</p>
",0
22426359,22426329,3,"<p>A string literal, ""..."", when used to initialise a char pointer, has type const char *, i.e. it's read-only.</p>

<p>dest should therefore have type const char *, at which point your code won't compile.</p>

<p>If you turn all your compiler warnings on then you'll get a warning for the ""char * dest = ..."" line.</p>
",5
22426381,22426329,12,"<p>When you do:</p>

<pre><code>char *dest = ""hello world!"";
</code></pre>

<p><code>""hello world!""</code> is kept in the read-only parts of the memory and pointer named <code>dest</code> is pointed to it, making any writing operation on this memory illegal. So if you try to use it as  a destination in your <code>memcpy</code>; it's an access violation.</p>

<p>You should use:</p>

<pre><code>char dest[] = ""hello world!"";
</code></pre>
",0
22426451,22426329,1,"<p>char dest [] = ""hello world!"" and char* dest = ""hello world!"" is not the same thing. char dest[]=""hello world!"" is an array with 13 elements (the string is null-terminated). char* dest =""hello world!"" is a pointer to an constant, null terminated string (also 13 characters).</p>
",0
24580374,14496596,1,"<p>How to solve ""using fscanf"":</p>

<p>After the <code>int</code>, look for spaces (don't save), then look for <code>char</code> that are not <code>'\n'</code>.  </p>

<pre><code>int num;
char str[10];
#define ScanInt            ""%d""
#define ScanSpacesDontSave ""%*[ ]""
#define ScanUntilEOL       ""%9[^\n]""

int ret = fscanf(fp, ScanInt ScanSpacesDontSave ScanUntilEOL, &amp;num, str);
if (EOF == ret) break;
else if (1 == ret) HandleNum(num);
else if (2 == ret) HandleNumStr(num, str);
else HadleMissingNum();
</code></pre>

<p><code>ret</code> will be 2 if <em>something</em> was scanned into <code>str</code>, else <code>ret</code> will typically be 1.  The trick to the above is not to scan in a <code>'\n'</code> after the <code>int</code>.  Thus code can not use <code>""%s""</code> nor <code>"" ""</code> after the <code>""%d""</code> which both consume all (leading) white-space.  The <em>next</em> <code>fscanf()</code> call will consume the <code>'\n'</code> as part of leading white-space consumption via <code>""%d""</code>.</p>

<p>Minor note: reading the line with <code>fgets()</code> then parsing the buffer is usually a better approach, but coding goals may preclude that.</p>
",0
28455422,28455081,2,"<p>In your code,</p>

<pre><code> strcpy((*pointeur).codeactuel, CODE_NON_TROUVE);
</code></pre>

<p><code>codeactuel</code> is defined to have a size of <code>10</code>, but to copy <code>CODE_NON_TROUVE</code> you need to have a size of <code>11</code>.</p>

<p>Then, <code>printf(birthPlace);</code> is also wrong, it should be something like</p>

<pre><code> printf(""%s\n"", birthPlace);
</code></pre>

<p>Also, there is a logical problem in</p>

<pre><code>pointeur=undepartement();
</code></pre>

<p>if <code>malloc()</code> fails and <code>undepartement()</code> returns NULL, you'll be facing undefined behaviour by dereferencing <code>pointeur</code>. Please add a NULL check.</p>

<p>P.S - There maybe other issues. Please provide a <a href=""https://stackoverflow.com/help/mcve"">MCVE</a> and if possible kindly stick to english so that we can understand the code logic in a better way.</p>
",0
28456148,28455081,0,"<p>Inside <code>while</code> loop  you are comparing <code>.currentCode</code> with <code>.dep_name.</code> 
This was wrong. Change the code to this:</p>

<pre><code>// trouve=((strcmp(ptmp.currentCode,dep_name))==0) ;
trouve=((strcmp(ptmp.name,dep_name))==0) ;
</code></pre>

<p>And it works correct.</p>
",0
30693647,30693529,2,"<p>You forgot to reset <code>revNum</code> in each iteration. Fix the problem by adding </p>

<pre><code>revNum = 0;
</code></pre>

<p>just before </p>

<pre><code>num = (99-i)*(99-j);
</code></pre>
",0
30693672,30693529,0,"<p>Set the revNum to 0 after each iteration otherwise the next time the loop runs it will cause faulty results.</p>
",0
28166738,27729930,5,"<p>Whenever you allocate local variables in a C scope (such as a functions), they have no default initialization code (such as C++ constructors). And since they're not dynamically allocated (they're just uninitialized pointers), no additional (and potentially expensive) functions need to be invoked (e.g. <code>malloc</code>) in order to prepare/allocate them.</p>

<p>Due to the way the <a href=""https://www.youtube.com/watch?v=_8-ht2AKyH4"" rel=""noreferrer"" title=""A very helpful Youtube video"">stack</a> works, allocating a stack variable simply means decrementing the stack pointer (i.e. increasing the stack size, because on most architectures, it grows downwards) in order to make room for it. From the CPU's perspective, this means executing a simple SUB instruction: <code>SUB rsp, 4</code> (in case your variable is 4 bytes large--such as a regular 32-bit integer).</p>

<p>Moreover, when you declare multiple variables, your compiler is smart enough to actually group them together into one large <code>SUB rsp, XX</code> instruction, where <code>XX</code> is the total size of a scope's local variables. <strong>In theory. In practice, something a little different happens.</strong></p>

<p>In situations like these, I find <a href=""https://gcc.godbolt.org/"" rel=""noreferrer"">GCC explorer</a> to be an invaluable tool when it comes to finding out (with tremendous ease) what happens ""under the hood"" of the compiler.</p>

<p>So let's take a look at what happens when you actually write a function like this: <a href=""http://goo.gl/UeniAi"" rel=""noreferrer"">GCC explorer link</a>.</p>

<h2>C code</h2>

<pre><code>int function(int a, int b) {
  int x, y, z, t;

  if(a == 2) { return 15; }

  x = 1;
  y = 2;
  z = 3;
  t = 4;

  return x + y + z + t + a + b;
}
</code></pre>

<h2>Resulting assembly</h2>

<pre><code>function(int, int):
    push    rbp
    mov rbp, rsp
    mov DWORD PTR [rbp-20], edi
    mov DWORD PTR [rbp-24], esi
    cmp DWORD PTR [rbp-20], 2
    jne .L2
    mov eax, 15
    jmp .L3
.L2:
    -- snip --
.L3:
    pop rbp
    ret
</code></pre>

<p>As it turns out, GCC is even smarter than that. It doesn't even perform the SUB instruction at all to allocate the local variables. It just (internally) assumes that the space is ""occupied"", but doesn't add any instructions to update the stack pointer (e.g. <code>SUB rsp, XX</code>). This means that the stack pointer is not kept up to date but, since in this case no more <code>PUSH</code> instructions are performed (and no <code>rsp</code>-relative lookups) after the stack space is used, there's no issue.</p>

<p>Here's an example where no additional variables are declared: <a href=""http://goo.gl/3TV4hE"" rel=""noreferrer"">http://goo.gl/3TV4hE</a> </p>

<h2>C code</h2>

<pre><code>int function(int a, int b) {
  if(a == 2) { return 15; }
  return a + b;
}
</code></pre>

<h2>Resulting assembly</h2>

<pre><code>function(int, int):
    push    rbp
    mov rbp, rsp
    mov DWORD PTR [rbp-4], edi
    mov DWORD PTR [rbp-8], esi
    cmp DWORD PTR [rbp-4], 2
    jne .L2
    mov eax, 15
    jmp .L3
.L2:
    mov edx, DWORD PTR [rbp-4]
    mov eax, DWORD PTR [rbp-8]
    add eax, edx
.L3:
    pop rbp
    ret
</code></pre>

<p>If you take a look at the code before the premature return (<code>jmp .L3</code>, which jumps to the cleanup and return code), no additional instructions are invoked to ""prepare"" the stack variables. The only difference is that the function parameters a and b, which are stored in the <code>edi</code> and <code>esi</code> registers, are loaded onto the stack at a higher address than in the first example (<code>[rbp-4]</code> and <code>[rbp - 8]</code>). This is because no additional space has been ""allocated"" for the local variables like in the first example. So, as you can see, the only ""overhead"" for adding those local variables is a change in a subtraction term (i.e. not even adding an additional subtraction operation).</p>

<p>So, in your case, there is virtually no cost for simply declaring stack variables.</p>
",0
27542642,22293043,0,"<p>The problem you are asking is based of algorithm concept <a href=""http://en.wikipedia.org/wiki/Backtracking"" rel=""nofollow"">Backtracking</a></p>

<p>Here is the function</p>

<pre><code>void permute(char *a, int i, int n) 
{
   int j; 
   if (i == n)
     printf(""%s\n"", a);
   else
   {
        for (j = i; j &lt;= n; j++)
       {
          swap((a+i), (a+j));
          permute(a, i+1, n);
          swap((a+i), (a+j)); //backtrack
       }
   }
}
</code></pre>

<p>call this from <code>main()</code>   </p>

<pre><code>int main()
{
   char a[] = ""ABC"";  
   permute(a, 0, 2);     // first param is array,2nd is starting index and 3rd is ending index

   return 0;
}
</code></pre>

<p>Wolfram alpha is having mathematical concept behind these type of problem.Basically we try all the solutions one by one and then backtrack by reverting those changes to original one and then again try out different solution.To understand clearly check this.
<a href=""http://mathworld.wolfram.com/Permutation.html"" rel=""nofollow"">http://mathworld.wolfram.com/Permutation.html</a></p>
",3
27542465,22293043,1,"<p>If you <em>know</em> it's always going to be a length of three, you can use pre-generation to minimise complexity and/or code. Pre-generation is the act of moving complex calculations from run time to compile time or even before hand, and it can be very productive for complex calculations.</p>

<p>One example (though a little contrived) is to write a program to calculate all possible unsigned 64-bit factorials (there's only about ninety of them) then have that program generate the <em>source code</em> (lookup table and function) that can do the lookup to get them. The complexity of generating the table is done <em>once,</em> long before compilation of the program that will use it.</p>

<p>This means that a factorial operation <em>in the program that uses it,</em> changes from being a possibly time consuming series of multiplications to something more akin to one multiplication and an addition (the table lookup).</p>

<p>Applying that same method to permutations (though the generation of the lookup table was done in my head since it's not that complex) will give you code like:</p>

<pre><code>#include &lt;stdio.h&gt;

// The permutations.

static int perm3[] = { 0,1,2,  0,2,1,
                       1,0,2,  1,2,0,
                       2,0,1,  2,1,0 };

int main (void) {
    int i;
    char x[] = {'a', 'b', 'c'};

    // Permute using the table to get indexes.

    for (i = 0; i &lt; sizeof(perm3) / sizeof(perm3[0]); i += 3)
        printf (""%c %c %c\n"", x[perm3[i]], x[perm3[i+1]], x[perm3[i+2]]);

    return 0;
}
</code></pre>

<p>Now, some people may consider that ""cheating"" but I'll be honest here, some of the fastest programs you can write will cheat in this manner :-)</p>
",0
22134517,22134457,4,"<p>When you pass an array to a function, it gets rewritten as a pointer, where <code>sizeof</code> information is lost. If you did this in <code>main</code> instead, i.e:</p>

<pre><code>char a[10]={'b','c','d','e','f','f','f','f','f','f'};
int size = sizeof(a)/sizeof(a[0]);
printf(""Size is %d.\n"", size);
</code></pre>

<p>It prints <code>10</code> as expected. But once you pass it to <code>constChars</code>, it prints the size of a pointer.</p>
",3
22134537,22134457,0,"<p>Str is a pointer to a char. That is typically 4 to 8 bytes. You are not getting the size of the array, but the size of the variable. The only way to know the length of the array is to pass the size in with it, or you could deliminate the array with some sort of signal value (like \0) and do some iteration.</p>
",0
26438989,26438969,3,"<p>Programs are usually being changed. So it is better to use a general approach. For example the type of data member first can be changed or before data member last there can be added one more data member.
Take into accpunt that there is already a similar macro in C defined in <code>&lt;stddef.h&gt;</code> (or <code>&lt;cstddef&gt;</code> in C++)</p>

<pre><code>offsetof(type, member-designator)
</code></pre>
",5
29454690,29454641,3,"<pre><code>if (!fgets(userInput,sizeof(userInput),stdin))
</code></pre>

<p>is wrong on couple of accounts.</p>

<ol>
<li><code>userInput</code> does not point to any valid memory.</li>
<li><code>sizeof(userInput)</code> is the same as <code>sizeof(char*)</code>, which is not what you want.</li>
</ol>

<p>Change</p>

<pre><code>char *userInput;
</code></pre>

<p>to something like:</p>

<pre><code>char userInput[100];
</code></pre>

<p><strong>Next problem</strong></p>

<pre><code>if((input_file1 = open(userInput, O_RDONLY)) &lt; 0)
</code></pre>

<p>That's wrong. The return value of <code>open</code> is an <code>int</code>. Type of <code>input_file1</code> is <code>FILE*</code>. I am surprised you didn't get compiler errors/warnings.</p>

<p>Change</p>

<pre><code>FILE *input_file1;
</code></pre>

<p>to</p>

<pre><code>int input_file1;
</code></pre>

<p><strong>And the next problem</strong></p>

<p>It's probably caused by <code>fgets()</code> including the newline character in <code>userInput</code>. Add code to trim the newline.</p>

<pre><code>int len = strlen(userInput);
if ( userInput[len-1] == '\n' )
{
   userInput[len-1] = '\0';
}
</code></pre>
",7
27555445,27554822,1,"<p>Too much to comment but not a definitive answer. What is ""a simple PI controller""? And ""how long is a piece of string""? I don't see why you (effectively) code</p>

<pre><code>P = (current_error = 0 - input_value);
</code></pre>

<p>which simply negates the error of -¦Ð to ¦Ð. You then aggregate the error with</p>

<pre><code>I += previous_error;
</code></pre>

<p>but haven't stated the cumulative error bounds, and then calculate</p>

<pre><code>output = Kp*P + Ki*I;
</code></pre>

<p>which must be <code>-4000 &lt;= output &lt;= 4000</code>. So you are looking for values of <code>Kp</code> and <code>Ki</code> that keep you within bounds, or perhaps don't keep you within bounds except in <em>average</em> conditions.</p>

<p><strong>I suggest an empirical solution</strong>. Try a series of runs, filing the results, stepping the values of <code>Kp</code> and <code>Ki</code> by 5 steps each, first from extreme neg to pos values. Limit the output as you stated, counting the number of results that break the limit.</p>

<p>Next, halve the range of one of <code>Kp</code> and <code>Ki</code> and make a further informed choice as to which one to limit. And so on. ""Divide and conquer"".</p>

<p>As to your requirement ""how to limit the PI controller properly"", are you sure that 4000 is the limit and not 4096 or even 4095?</p>

<pre><code>if (output &lt; -4000) output = -4000;
if (output &gt;  4000) output =  4000;
</code></pre>
",4
27555567,27554822,0,"<p>To configure your <code>Kp</code> and <code>Ki</code> you really should analyze the frequency response of your system and design your PI to give the desired response.  To simply limit the output decide if you need to freeze the integrator, or just limit the immediate output.  I'd recommend freezing the integrator.</p>

<pre><code>I_tmp = previous_error + I;
output_tmp = Kp*P + Ki*I_tmp;
if( output_tmp &lt; -4000 )
{
  output = -4000;
}
else if( output_tmp &gt; 4000 )
{
  output = 4000;
}
else
{
  I = I_tmp;
  output = output_tmp;
}
</code></pre>

<p>That's not a super elegant, vetted algorithm, but it gives you an idea.</p>
",0
27555709,27554822,0,"<p>If I understand your question correctly you are asking about anti windup for your integrator.</p>

<p>There are more clever ways to to it, but a simple</p>

<pre><code>if ( abs (I) &lt; x)
{
    I += previous_error;
}
</code></pre>

<p>will prevent windup of the integrator.</p>

<p>Then you need to figure out x, Kp and Ki so that <code>abs(x*Ki) + abs(3.14*Kp) &lt; 4000</code></p>

<p>[edit] Off cause as macduff states, you first need to analyse your system and choose the korrect Ki and Kp, x is the only really free variable in the above equation.</p>
",0
27685431,27493325,1,"<p>Efficient? In time or memory?
How you are doing it is very efficient in time. Bad for memory.
But it's not <em>that</em> bad. </p>

<p>6kB is nothing. Unless your programming an ic or something :P. Anyhow, your program must be a lot bigger than 6kB so this ought to be negligable.</p>
",0
28215712,28215647,8,"<pre><code>int res = (n == 10)? ABD;
</code></pre>

<p>Now if <code>n = 10</code> then <code>res = 1</code> else <code>res= 0</code></p>

<p>It is used in the ternary operator <code>?:</code></p>

<p>So basically <code>ABD</code> is replaced by <code>1:0</code> because of the MACRO</p>

<pre><code>#define ABD 1:0
</code></pre>
",8
28215740,28215647,2,"<p>The <code>#define</code> preprocessing directives [AKA MACRO] can be considered as a <em>textual replacement</em>.</p>

<p>Quoting chapter 6.10 from <code>C99</code> standard, the semantics for <code>#define</code> is</p>

<pre><code># define identifier replacement-list new-line
</code></pre>

<p>compared to your code</p>

<pre><code>#define ABD 1:0
</code></pre>

<p><code>ABD</code> is the <em>identifier</em> [also called macro name], <code>1:0</code> is the <em>replacement list</em>. There is no <em>seperate</em> meaning of the <code>:</code>, other than being a part of the replacement list.</p>

<p>Related, chapter 6.10.3, paragraph 9,</p>

<blockquote>
  <p>A preprocessing directive of the form</p>
</blockquote>

<pre><code># define identifier replacement-list new-line
</code></pre>

<blockquote>
  <p>defines an object-like macro that causes each subsequent instance of the macro name to be replaced by the replacement list of preprocessing tokens that constitute the remainder of the directive.</p>
</blockquote>

<p>So, if you have a MACRO like <code>#define ABD 1:0</code> and <code>ABD</code> somewhere in your code, in preprocessing stage, all occurrences of <code>ABD</code> will get replaced by <code>1:0</code>.</p>
",0
28179104,28178673,0,"<p>This is usually done using the <code>vprintf()</code> function, as orlp explained. However, that alone leaves you with a format that cannot be typechecked: Usually, your compiler interpretes the format string literal in every <code>printf()</code> call that it sees to determine whether the corresponding arguments have the right types.</p>

<p>Some compilers allow you to add support for this kind of type checking, here is the <code>__attribute__(())</code> that is needed for <code>gcc</code>:</p>

<pre><code>//within header
void printfTimestamp(const char* format, ...)
    __attribute__((format(printf, 1, 2)));

//within implementation file
void printfTimestamp(const char* format, ...) {
    va_list args;
    va_start(args, format);
    int result = vfprintf(stderr, format, args);
    va_end(args);
    timestamp();
    return result;
}
</code></pre>

<p>The arguments to the attribute are the argument number with the format string (<code>1</code>) and the first variable argument position (<code>2</code>). As such, if you were to add an additional parameter to your function, you would declare it like this:</p>

<pre><code>void myPimpedPrintf(int foo, const char* format, ...)
    __attribute__((format(printf, 2, 3)));
</code></pre>
",0
28179450,28178673,0,"<p>For just adding a timestamp, I agree that <code>vprintf()</code> as proposed by orlp is the way to go.  However, I think there is a valid argument in favor of macros, and that's the use of other compiler built-in macros like <code>__LINE__</code>, <code>__FILE__</code>, and <code>__func__</code>, which I personally find very useful for logging.</p>

<p>I generally use something like this with <code>gcc</code> and anything else that does comma swallowing.</p>

<pre><code>#define log_debug(M, ...) do{ \
  struct timespec _ts; \
  double _ts_sec; \
  clock_gettime(CLOCK_MONOTONIC, &amp;_ts);\
  _ts_sec = _ts.tv_nsec * 1e-9 + _ts.tv_sec; \
  fprintf(stderr, ""%.3f [DEBUG] (%s:%d) "" M,  _ts_sec, \
      __func__, __LINE__, ##__VA_ARGS__); \
}while(0)

// usage:
log_debug(""x=%d\n"", x);
</code></pre>

<p>There are a couple ""tricks"" going on here you might not be familiar with.</p>

<p>The first of which is the <code>do{}while()</code> loop.  This is a fairly common and largely portable C idiom for writing multi-statement macros.  It lets you use the macro terminating it in a <code>;</code> and allows declaration of scoped variables.  However, is a statement, not an expression, so there's no ""return value"".  Usually doesn't matter for printf() like macros, but be aware, this can bite you in other uses when trying to make function-like macros.</p>

<p>The other ""trick"" is the use of comma swallowing with the '##' operator.  Read more here:  <a href=""https://gcc.gnu.org/onlinedocs/cpp/Variadic-Macros.html"" rel=""nofollow"">https://gcc.gnu.org/onlinedocs/cpp/Variadic-Macros.html</a></p>

<p>Also, this takes advantage of the fact that back-to-back string literals are concatenated in C to form a single string literal.  The downside is that this technique ONLY works with string literals, i.e. your format string cannot be in a variable. </p>
",0
28178811,28178673,4,"<p>You can use <a href=""http://en.cppreference.com/w/c/io/vfprintf""><strong><code>vprintf</code></strong></a>:</p>

<pre><code>int printf_timestamp(const char* fmt, ...) {
    va_list args;
    int result;

    va_start(args, fmt);
    result = vprintf(fmt, args);
    va_end(args);
    timestamp();

    return result;
}
</code></pre>
",1
30705456,8011700,6,"<p>This is a briefer variation of the accepted answer: the function below extracts the bits from-to inclusive by creating a bitmask. After applying an AND logic over the original number the result is shifted so the function returns just the extracted bits.
Skipped index/integrity checks for clarity.</p>

<pre><code>uint16_t extractInt(uint16_t orig16BitWord, unsigned from, unsigned to) 
{
  unsigned mask = ( (1&lt;&lt;(to-from+1))-1) &lt;&lt; from;
  return (orig16BitWord &amp; mask) &gt;&gt; from;
}
</code></pre>
",1
29455534,29455455,4,"<p>For the most part, they're not. Most C programmers simply use the <code>NULL</code> macro, with a cast to the required pointer type only in the rare cases where it's necessary.</p>

<p>By defining a type-specific null pointer macro like</p>

<pre><code>#define NULLUT  ((struct utmp *)NULL)
</code></pre>

<p>you get something that is only of that specific pointer type. Comparing a pointer of a different type, for example:</p>

<pre><code>char *ptr = some_value;
if (ptr == NULLUT) /* ERROR */
</code></pre>

<p>the compiler will flag an error. A null pointer constant, on the other hand, is comparison-compatible with any pointer type.</p>

<p>I suppose the author thought that would be a good idea.</p>

<p>I disagree.</p>

<p>The macro <code>NULL</code> is standard, and every C programmer recognizes it. It's perfectly safe to use in a comparison, assignment, initialization, or <code>return</code> statement for any pointer type. And most of the time, it's perfectly safe to use as an argument to a function with a pointer parameter. The only exceptions are when the function has no visible prototype (solution: always use prototypes) or when it's a variadic function like <code>printf</code> (solution: cast <code>NULL</code> to the appropriate pointer type). (Macros using the new <code>_Generic</code> feature are probably another case where a cast might be needed.)</p>

<p>Defining your own <code>NULLUT</code> macro serves no real purpose that I can see.</p>

<pre><code>while (( utbufp = utmp_next() ) != ((struct utmp *)NULL) )
   do_something()
</code></pre>

<p>This is from another source file from the book (the <code>who3.c</code> you cited in the question). Here, the author doesn't even define the <code>NULLUT</code> macro, choosing instead to write</p>

<pre><code>((struct utmp *)NULL)
</code></pre>

<p>This would be better written as:</p>

<pre><code>while (( utbufp = utmp_next() ) != NULL) )
   do_something()
</code></pre>
",9
27511179,27510764,1,"<p>If I understand your question correctly, it sounds like you're wondering why they are variables instead of being static constants (ie <code>static const int bufalign = ...</code>, etc) or just hard-coded unnamed magic numbers. Doing a quick search on the page, the only place they're assigned is in their declaration statements or while doing command line argument processing.</p>

<p>Since it is possible to specify command line arguments that change their values, I'm guessing that's ""why they are needed in the source code"".</p>

<p>--EDIT--</p>

<p>The line of code <code>buf +=(bufalign - ((int)buf % bufalign) + bufoffset) % bufalign;</code> is just pointer arithmetic to ensure that the memory address <code>buf</code> points to is aligned to a specific multiple. The memory address of <code>buf</code> is incremented so that it is equal to the next memory location that is a multiple of <code>bufalign</code> (so that <code>buf</code> starts at a memory address that is a multiple of 16k by default), with an additional offset of <code>bufoffset</code>.</p>

<p>You are correct in your assumption of how buf is used later. However, the pointer arithmetic with bufalign and bufoffset is unnecessary and should be removed. The source code is pretty old style C - my best guess is that this line of code in question was needed on whatever platform(s) this program was originally designed for.</p>

<p>I also don't see anything freeing the memory that was allocated for buf, which is a memory leak.</p>
",1
29456796,29456727,1,"<p>This code is probably bugged. The storage should be:</p>

<pre><code>static  struct utmp    utmpbuf[NRECS];
</code></pre>

<p>as you suggested. As to why the book wrote this, you'd have to ask them about it. I don't see any conceivable reason.</p>

<p>The problem comes about from attempting to alias the char array as <code>struct utmp</code>:</p>

<pre><code>recp = ( struct utmp *) &amp;utmpbuf[cur_rec * UTSIZE];
</code></pre>

<p>Firstly, the <code>char</code> array might not be correctly aligned for <code>struct utmp</code>. If it is not correctly aligned, this cast causes undefined behaviour.</p>

<p>Even if it is correctly aligned however, any attempt to use <code>*recp</code>, or do <code>recp-&gt;X</code> where <code>X</code> is not a character type, would cause undefined behaviour by violating the strict aliasing rule. This code doesn't do that, but presumably the calling code that uses this function will dereference the returned pointer at some stage. </p>
",0
26188365,26188085,3,"<p>Your code is correct.  You should <em>not</em> expect the output to show you a value of <code>1</code>.  You should expect it to show you a value of <code>16843009</code>, assuming a 4 byte <code>int</code>.</p>

<p>The reason is: you are filling <code>array1</code> with <em>bytes</em> of value <code>1</code>, not with <em>ints</em> of value <code>1</code>.  i.e. binary <code>00000001000000010000000100000001</code> (<code>0x01010101</code>) is being filled into all the <code>int</code> elements with your <code>memset</code> operation.</p>

<p>So regardless of the size of <code>int</code> on your machine (unless it's a single byte!) you should not expect to see the value <code>1</code>. </p>

<p>I hope this helps.</p>
",0
26188497,26188085,1,"<p>Multidimensional array in C is a flat block of memory with no internal structure. Memory layout of a multidimensional array is exactly the same as that of a 1-dimensional array of the same total size. The multidimensional interface is implemented through simple index recalculation. You can always <code>memcpy</code> the whole multidimensional array exactly as you do it in your code.</p>

<p>This, of course, only applies to built-in multidimensional arrays, explicitly declared as such (as in your code sample). If you implement a hand-made multidimensional array as an array of pointers to sub-arrays, that data structure will not be copyable in one shot with <code>memcpy</code>.</p>

<p>However, apparently you have some misconceptions about how <code>memset</code> works. Your <code>memset(&amp;array1,1,sizeof(array1));</code> will not fill the array with <code>1</code>s, meaning that your code is not supposed to print <code>1</code> regardless of which array you print. <code>memset</code> interprets target memory as an array of <code>char</code>s, not as an array of <code>int</code>s. </p>

<p><code>memset</code> can be used to set memory to zero. As for non-zero values, <code>memset</code> is generally unsuitable for initializing arrays of any type other than <code>char</code>.</p>
",0
26786879,26786839,0,"<p>In that case it's both: declaration + definition.</p>

<p>If you have in a separate file something like:</p>

<pre><code>extern int array[4][5][2];
</code></pre>

<p>Then that's only declaring it, since definition occurs in other ""external"" file.</p>
",0
26786989,26786839,2,"<p>According to the C Standard (6.7 Declarations)</p>

<blockquote>
  <p>5 A declaration specifies the interpretation and attributes of a set
  of identifiers. A <strong>definition</strong> of an identifier is a declaration for
  that identifier that:</p>
  
  <p>¡ª for an object, causes storage to be reserved for that object;</p>
</blockquote>

<p>As you noted yourself the memory for the array is reserved in data section then you have a declaration of an array that at the same time is a definition.</p>
",0
28452489,28452178,3,"<p>This:</p>

<pre><code>struct departement *undepartement()
{
    return (struct departement *) undepartement(sizeof(struct departement));
}
</code></pre>

<p>is very wrong, it tries to return the address of the function (!) converted to a pointer to a structure, but also does an infinite recursive call that will eat your stack and cause undefined behavior.</p>

<p>It should just be:</p>

<pre><code>struct departement * undepartement(void)
{
    struct departement *p = malloc(sizeof *p);
    return p;
}
</code></pre>

<p>Note that functions accepting no arguments in C should be declared as <code>(void)</code>. Also note that <code>malloc()</code> can fail, you need to check the return vaule of <code>undepartement()</code> before relying on it.</p>
",1
28452501,28452178,1,"<p>From <code>manpage</code>:</p>

<blockquote>
  <p>RETURN VALUE
         Upon successful completion fopen(), fdopen()  and  freopen()  return  a
         FILE pointer.  Otherwise, NULL is returned and errno is set to indicate
         the error.</p>
</blockquote>

<p>So you might want to <code>#include &lt;errno.h&gt;</code> and check <code>errno</code> when your <code>fopen</code> fails to have your answer. </p>

<p>My guess: maybe your file <code>Basedecommunes.txt</code> is not in the same directory of your running program.</p>
",1
27119402,27119352,3,"<p>There has to be some return type,</p>

<pre><code>void (*b) (int) = fubar;
</code></pre>

<p>or </p>

<pre><code>int (*b) (int) = fubar;
</code></pre>

<p>Then it <code>b</code> would be, pointer to function which return <code>void</code>/<code>int</code> and takes <code>int</code> as parameter. </p>
",0
27119449,27119352,2,"<p>there must be a return type to this as </p>

<p>int (*b) (int) = fubar;</p>

<p>so this explaines the b is the pointer to the function which take INT as parameter and it would return INT value</p>
",0
27119666,27119352,1,"<blockquote>
  <p>My guess is that b is a pointer to a function returning int. Is this
  correct?</p>
</blockquote>

<p>You are close to the correct answer. It is indeed a pointer to a function that has return type <code>void</code> and one parameter of type <code>int</code>.</p>

<p>As you can see from the code snippet</p>

<pre><code>static void fubar(int a)
{
  void (*b) (int) = fubar; // &lt;---
  static int c;
}
</code></pre>

<p>in the right side of the assignment there is identifier <code>fubar</code> that is already declared like
<code>void fubar(int a)</code>. SO inside the function there is simply an assignment of it to a pointer of the same type. </p>
",0
34203453,12318866,-2,"<p>this will run:
FILE *f=fopen(""...\\abc\\p.txt"",""r"");</p>
",1
23566158,23566114,8,"<p>Overwriting invokes undefined behavior.</p>

<p>In your case, you trash the heap's data structures, causing <code>free()</code> to do something which crashes. This is why it's called ""undefined behavior"", since you can't know when, how, or if there will be any observable ""proof"" that you did something wrong. Or it can come later when the program does something seemingly unrelated.</p>

<p>Also, <a href=""https://stackoverflow.com/a/605858/28169"">please don't cast the return value of <code>malloc()</code> in C</a>.</p>
",0
23566285,23566114,5,"<p>You are writing beyond the end of the block of memory that you allocated and the behaviour is undefined.</p>

<blockquote>
  <p>I am aware that I am overwrting the array but here observation is crash happens at when I free(tmp) now even though I am over writing ptr, but when I free(ptr) it should only free first 60 bytes.</p>
</blockquote>

<p>Heap allocated memory typically works by storing meta data about the block of memory alongside the block of memory. This is needed so that the heap manager knows how to free the block of memory. After all, when you pass a pointer to <code>free</code>, the heap manager does need some way to work out how to deallocate the memory.  </p>

<p>What is happening here is that you are corrupting that meta data and that is detected when the call to <code>free</code> is made. It looks very much like you are using the debug heap manager which in your runtime implements debugging code to detect such heap corruptions.</p>
",0
21161459,21161175,3,"<p>a simple loop should do the trick:</p>

<pre><code>/* iterate.c */
#include &lt;stdio.h&gt;

int 
main (void)
{
  printf(""start\n"");

  volatile unsigned long long i;
  for (i = 0; i &lt; 1000000000ULL; ++i);

  printf(""stop\n"");

  return 0;
}
</code></pre>

<p>this takes ~2.5 seconds on my system. feel free to increase the amount of iterations to match your timing expectations.</p>

<pre><code>$&gt; gcc -o iterate iterate.c
$&gt; time ./iterate
start
stop

real    0m2.763s
user    0m2.758s
sys     0m0.000s
</code></pre>

<p>short form:</p>

<pre><code>void
wait (void)
{
  volatile unsigned long long i;
  for (i = 0; i &lt; 1000000000ULL; ++i);
}
</code></pre>
",2
21161236,21161175,0,"<p>Just pause the thread/process? No need to do actual work.</p>

<p>In POSIX, call e.g. <code>usleep(5000000);</code> to pause for five seconds (see <a href=""http://linux.die.net/man/3/usleep"" rel=""nofollow""><code>usleep()</code></a> manual page).</p>
",5
32464278,32463719,4,"<p>In your example, there are no <strong>absolute</strong> guarantees of the adjacency/placement of the two string literals with respect to each other. GCC in this case happens to demonstrate such behavior, but it has no obligation to exhibit this behavior.</p>

<p>In this example, we see no padding, and we can even use undefined behavior to demonstrate adjacency of string literals. This works with GCC, but using alternate <code>libc</code>'s or different compilers, you could get other behavior, such as detecting duplicate string literals across translation units and reducing redundancy to save memory in the final application.</p>

<p>Also, while the pointers you declared are of type <code>char *</code>, the literals actually should be <code>const char*</code>, since they will be stored in <code>RODATA</code>, and writing to that memory will cause a segfault.</p>

<hr>

<p><strong>Code Listing</strong></p>

<hr>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

struct example_t {
char * a;
char * b;
char * c;
};


int main(void) {

    struct example_t test = {
        ""Chocolate"",
        ""Cookies"",
        ""And milk""
    };
    size_t len = strlen(test.a) + strlen(test.b) + strlen(test.c) + ((3-1) * sizeof(char));

    char* t= test.a;
    int i;
    for (i = 0; i&lt; len; i++) {
        printf(""%c"", t[i]);
    }

    return 0;
}
</code></pre>

<hr>

<p><strong>Sample output</strong></p>

<hr>

<pre><code>./a.out 
ChocolateCookiesAnd milk
</code></pre>

<hr>

<p><strong>Output of gcc -S</strong></p>

<hr>

<pre><code>    .file   ""test.c""
    .section    .rodata
.LC0:
    .string ""Chocolate""
.LC1:
    .string ""Cookies""
.LC2:
    .string ""And milk""
    .text
    .globl  main
    .type   main, @function
main:
.LFB0:
    .cfi_startproc
    pushq   %rbp
    .cfi_def_cfa_offset 16
    .cfi_offset 6, -16
    movq    %rsp, %rbp
    .cfi_def_cfa_register 6
    pushq   %rbx
    subq    $72, %rsp
    .cfi_offset 3, -24
    movq    $.LC0, -48(%rbp)
    movq    $.LC1, -40(%rbp)
    movq    $.LC2, -32(%rbp)
    movq    -48(%rbp), %rax
    movq    %rax, %rdi
    call    strlen
    movq    %rax, %rbx
    movq    -40(%rbp), %rax
    movq    %rax, %rdi
    call    strlen
    addq    %rax, %rbx
    movq    -32(%rbp), %rax
    movq    %rax, %rdi
    call    strlen
    addq    %rbx, %rax
    addq    $2, %rax
    movq    %rax, -64(%rbp)
    movq    -48(%rbp), %rax
    movq    %rax, -56(%rbp)
    movl    $0, -68(%rbp)
    jmp .L2
.L3:
    movl    -68(%rbp), %eax
    movslq  %eax, %rdx
    movq    -56(%rbp), %rax
    addq    %rdx, %rax
    movzbl  (%rax), %eax
    movsbl  %al, %eax
    movl    %eax, %edi
    call    putchar
    addl    $1, -68(%rbp)
.L2:
    movl    -68(%rbp), %eax
    cltq
    cmpq    -64(%rbp), %rax
    jb  .L3
    movl    $0, %eax
    addq    $72, %rsp
    popq    %rbx
    popq    %rbp
    .cfi_def_cfa 7, 8
    ret
    .cfi_endproc
.LFE0:
    .size   main, .-main
    .ident  ""GCC: (Ubuntu 4.8.4-2ubuntu1~14.04) 4.8.4""
    .section    .note.GNU-stack,"""",@progbits
</code></pre>
",0
32465363,32463719,1,"<p>No, there is no guarantee for adjacent placement.</p>

<p>One occasion where actual compilers will place them far apart is if the same string literal appears in different places (as read-only objects) and the <em>string combining</em> optimization is enabled.</p>

<p>Example:</p>

<pre><code> char *foo = ""foo"";
 char *baz = ""baz"";
 struct example_t bar = {
     ""foo"",
     ""bar""
 }
</code></pre>

<p>may well end up in memory as <code>""foo""</code> followed by <code>""baz""</code> followed by <code>""bar""</code>.</p>
",0
32465405,32463719,1,"<p>Here is an example demonstrating a real-world scenario where the strings are not adjacent.  GCC decides to reuse the string <code>""Chocolate""</code> from earlier.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

const char *a = ""Chocolate"";
const char *b = ""Spinach"";

struct test_t {
    const char *a;
    const char *b;
};

struct test_t test = {""Chocolate"", ""Cookies""};

int main(void)
{
    printf(""%p %p\n"", (const void *) a, (const void *) b);
    printf(""%p %p\n"", (const void *) test.a, (const void *) test.b);
    return EXIT_SUCCESS;
}
</code></pre>

<p>Output:</p>

<pre><code>0x400614 0x40061e
0x400614 0x400626
</code></pre>
",0
31855027,31852173,0,"<p>Val should be a structure who looks like this</p>

<pre><code>typedef struct s_val
{
  char *str;
  int id;
}               val;
</code></pre>

<p>if vl == NULL, it means that it points to nothing... so you can't access to nothing with it.
This is the reason why you segfault.</p>

<p>You have to allocate the memory you need with malloc (i suppose that you just learned pointer and malloc).</p>

<pre><code>int number_of_val_i_want;
vl = malloc(sizeof(val) * number_of_val_i_want);
</code></pre>

<p>After that, you must allocate all the str pointer, you can use strdup if you want, but i think that trainning to use malloc should be a great idea (recode strdup should be a good exercice to beginning ;)).</p>

<p>I let you think about the stop condition of the for loops.</p>

<p>I don't forget, you have to free vl after the imposed for loops !</p>
",0
29226536,29226327,0,"<pre><code>I think this is the process:

int function (int i)
{ 
return (i + 1);
}

typedef int (*fp)(int);  // Declare typedef

fp func = &amp;function; // Define function-pointer variable, and initialize

int value = func(3);     // Call function through pointer
</code></pre>
",1
29227121,29226327,0,"<p>Both versions are needlessly complex ways of writing:</p>

<pre><code>typedef int (*PSERVER_DISPATCH)(struct _SERVER_OBJECT *pSerObj,int val);
</code></pre>

<p>Why you would ever need the type <code>SERVER_DISPATCH</code> from your examples, I have no idea. Seems like a pointless type that is never actually used by the program.</p>
",7
29227202,29226327,0,"<p><strong>typedef</strong> are used to ease the reading of the code - especially for pointers to functions, or structure names.</p>

<pre><code>typedef int myinteger;
typedef char *mystring;
typedef void (*myfunction)();
</code></pre>

<p><strong>use them like</strong></p>

<pre><code>myinteger i;  
mystring s;
myfunction f;
</code></pre>
",0
29226963,29226327,4,"<pre><code>typedef int SERVER_DISPATCH(struct _SERVER_OBJECT *pSerObj,int val);
typedef SERVER_DISPATCH *PSERVER_DISPATCH;
</code></pre>

<p><code>SERVER_DISPATCH</code> is a function which returns int.</p>

<p><code>PSERVER_DISPATCH</code> is a pointer to <code>SERVER_DISPATCH</code>: so it is a pointer to a function which returns int.</p>

<pre><code>typedef int (*SERVER_DISPATCH)(struct _SERVER_OBJECT *pSerObj,int val);
typedef SERVER_DISPATCH PSERVER_DISPATCH;
</code></pre>

<p><code>SERVER_DISPATCH</code> is a pointer to a function which returns int.</p>

<p><code>PSERVER_DISPATCH</code> is a <code>SERVER_DISPATCH</code>: so it is a pointer to a function which returns int.</p>

<p>In both cases <code>PSERVER_DISPATCH</code> is the same. <code>SERVER_DISPATCH</code> is different.</p>
",0
31170983,31170836,1,"<p>Your if-statement is wrong.</p>

<p>You can express it much clearer, and more correctly as:</p>

<pre><code>if ('0' &lt;= line[c] &amp;&amp; line[c] &lt;= '9')
{
    printf(""the character is: %c\n"",line[c]);
}
</code></pre>

<hr>

<p>Your loop runs for 256 characters, even though the input of <code>""buttons""</code> only has 7 characters.  You're running off into memory that is not yours, and likely finding 9, 4, 4, there by random chance.</p>

<p>You want:</p>

<pre><code>for (int c=0; c &lt; 256; ++c)
{
    if (line[c] == '\0')    // If the end of the input is found, stop the loop.
    {
        break;
    }
    if ('0' &lt;= line[c] &amp;&amp; line[c] &lt;= '9')
    {
        printf(""the character is: %c\n"",line[c]);
    }
}
</code></pre>
",1
31171473,31170836,1,"<p>An extension of abelenky's post:</p>

<p>abelenky presents 2 (out of many) solutions to the problem. An important aspect of writing code is readability. abelenky's first solution maximizes readability.</p>

<pre><code>if (line[c] &gt;= '0' &amp;&amp; line[c] &lt;= '9')
{
    printf(""the character is: %c\n"",line[c]);
}
</code></pre>

<p>Everyone is aware that ASCII characters are mapped to integer values, but not everyone can readily recall the range of values associated with each types of character (numbers, letters, capital letters, etc.). </p>

<p>This is why C supports the single quotes: ' '</p>

<p>It is reasonable to assume that ASCII values for integers increment as do integers from 0-9, thus using '0' and '9' in your conditional statement improves readability. Adopting a more legible style of code <strong>will</strong> improve your and the life of anyone who views your code. </p>

<p>Happy coding!</p>
",3
31283681,31283444,0,"<p>Sadly, no. C is described abstractly in terms of <em>execution character set</em> and <em>implementation  character set</em>, both of which may vary. The characters it uses are not the complete set offered by ASCII. In fact the version of ascii current at the time of the first C compilers didn't even have <code>'@'</code> yet.</p>

<p>Searching for ""posix character set"" turned this up. <a href=""http://pubs.opengroup.org/onlinepubs/009696899/basedefs/xbd_chap06.html"" rel=""nofollow"">http://pubs.opengroup.org/onlinepubs/009696899/basedefs/xbd_chap06.html</a></p>
",0
22855775,22855499,3,"<p>You are returning a local array variable. This variable is destroyed when the function exits, making the address to it no longer safe or valid to access. In fact accessing it will give you what is called <em>undefined behavior</em>, which explains why it sometimes appears to ""work"".</p>

<p>This is a classic beginner's mistake in C. You must either have the caller pass in the desired destination array, or use <code>malloc()</code> to allocate ""persistent"" heap memory and return that:</p>

<pre><code>int* countingSort(int unsorted[], int arrayLen, int range) {
  int *sorted = malloc(arrayLen * sizeof *sorted );
  if (sorted== NULL)
    return NULL;
  /* rest of sorting */
  return sorted;
}
</code></pre>

<p>The <code>arrayLen * sizeof *sorted</code> expression computes the number of bytes required for the allocation. There's no need to use <code>calloc()</code> which clears the memory; you're going to overwrite each element so clearing it is just wasted effort.</p>
",1
21599837,9386651,0,"<p>It's an old question but thought I'd add a technique I use when testing programs on a Windows box.</p>

<p>Compile program into an exe. And then create a batch script to ""wrap"" the program along the lines of:</p>

<pre><code>@echo off
foo.exe
pause
exit
</code></pre>

<p>which will execute your program as it should be, without any dirty hacks, while allowing you to pause the window and see the output.</p>
",0
22459820,9064630,0,"<pre><code>arr_size=(sizeof(c)/sizeof(c[0]));
    //arr_size=30/1

for(i; i &lt; arr_size; i++)
    //for(i; i &lt; 30; i++)
</code></pre>

<p>Wouldn't state be a ""no"" if you enter a number less than 30digits...
If you enter a 30 digit number like this: <code>12234**************8877</code>, wouldn't ""7"" the last digit of the number make stats a yes?</p>

<p>use <code>if(isdigit())</code>
and <code>for(i; i &lt; strlen(c); i++)</code>
and a break whenever state becomes no..</p>
",0
30134003,9446707,0,"<p>You can change the signature of display method as follows:</p>

<pre><code>void display(int (*p)[numCols])
</code></pre>

<p>Here, <code>p</code> is a pointer to the row of a 2D array. The pointer only needs to know the number of columns in the array. </p>

<p>Actually speaking, pointer need to know the size of each row. This is very important for pointer arithmetic. So that when you increment the pointer, the pointer must point to next row.</p>

<p>Note here, <code>p</code> is not a normal integer pointer. It's a integer pointer to the memory size equal to <code>integer_size x columns</code>.</p>

<p>In main you don't need to change anything. <code>display(arr)</code> is just fine.</p>
",0
30153856,9446707,5,"<p>There are several, sometimes equivalent ways of doing this. By declaring an array (cf. <code>method_c()</code>), by using a pointer (cf. <code>method_b()</code>) or by using a pointer to an array of an array (cf. <code>method_a()</code>). <code>method_b()</code>, using a single pointer, is slightly more difficult to get right since it is not easy to use standard array indexing and hence, we use pointer arithmetic. <code>method_a()</code> and <code>method_c()</code> are basically equivalent since arrays decay non-recursively to pointers during compilation. Here is a little program illustrating all three methods. We first initialize a <code>2x4</code>-array <code>arr</code> in a simple for loop and print it. It will look like this:</p>

<pre><code>arr:
0 1 2 3
0 1 2 3
</code></pre>

<p>Afterwards we call all three methods. <code>method_a()</code> adds 1, <code>method_b()</code> adds 2 and <code>method_c()</code> adds 3 to all elements. After each call we print out the array <code>arr</code> again.  If a function worked correctly you will easily see it on the output. Size is arbitrary and can be regulated via the two macros <code>ROW</code> and <code>COL</code>. One last note, <code>method_c()</code> relies on variable-length array present since <code>C99</code>.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define ROW 2
#define COL 4

void method_a(int m, int n, int (*ptr_arr)[n]);
void method_b(int m, int n, int *ptr_arr);
void method_c(int m, int n, int arr[][n]);

int main(int argc, char *argv[]) {

    int arr[ROW][COL];

    int i;
    int j;
    for(i = 0; i &lt; ROW; i++) {
        for(j = 0; j &lt; COL; j++) {
            arr[i][j] = j;
        }
    }

    printf(""Original array:\n"");
    for (i = 0; i &lt; ROW; i++) {
        for(j = 0; j &lt; COL; j++) {
            printf(""%d\t"", arr[i][j]);
        }
        printf(""\n"");
    }

    printf(""\n\n"");

    method_a(ROW, COL, arr);

    printf(""method_a() array:\n"");
    for (i = 0; i &lt; ROW; i++) {
        for(j = 0; j &lt; COL; j++) {
            printf(""%d\t"", arr[i][j]);
        }
        printf(""\n"");
    }

    printf(""\n\n"");

    printf(""method_b() array:\n"");
    method_b(ROW, COL, (int *)arr);

    for (i = 0; i &lt; ROW; i++) {
        for(j = 0; j &lt; COL; j++) {
            printf(""%d\t"", arr[i][j]);
        }
        printf(""\n"");
    }

    printf(""\n\n"");

    method_c(ROW, COL, arr);

    printf(""method_c() array:\n"");
    for (i = 0; i &lt; ROW; i++) {
        for(j = 0; j &lt; COL; j++) {
            printf(""%d\t"", arr[i][j]);
        }
        printf(""\n"");
    }

    printf(""\n\n"");

    return EXIT_SUCCESS;
}

void method_a(int m, int n, int (*ptr_arr)[n])
{
    int i, j;
    for (i = 0; i &lt; m; i++)
    {
        for (j = 0; j &lt; n; j++)
        {
            ptr_arr[i][j] = j + 1;
        }
    }
}

void method_b(int m, int n, int *ptr_arr)
{
    int i, j;
    for (i = 0; i &lt; m; i++)
    {
        for (j = 0; j &lt; n; j++)
        {
            /* We need to use pointer arithmetic when indexing. */
            *((ptr_arr + i * n) + j) = j + 2;
        }
    }
    /* The whole function could have also been defined a bit different by taking
     * the i index out of the pointer arithmetic. n alone will then provide our
     * correct offset to the right. This may be a bit easier to understand. Our
     * for-loop would then look like this:
     * for (i = 0; i &lt; m; i++)
     * {
     *     for (j = 0; j &lt; n; j++)
     *     {
     *         *((ptr_arr + n) + j) = j + 2;
     *     }
     *     ptr_arr++;
     * }*/
}

void method_c(int m, int n, int arr[][n])
{
    int i, j;
    for (i = 0; i &lt; m; i++)
    {
        for (j = 0; j &lt; n; j++)
        {
            arr[i][j] = j + 3;
        }
    }
}
</code></pre>
",2
30173819,9450653,0,"<pre><code>while (exists == 0) 
{
    scanf(""%c"", &amp;letter);   // ok
    printf(""AFTER"");
    printf(""\n"");
    printf(""%c"", letter);
    printf(""\n"");
    if (letter == EOF) {
    //  printf(letter);
     printf(""HEADER NOT DETECTED""); }
    return 0;
}
</code></pre>

<p>So when using this the </p>

<pre><code>if (letter == E0F) 
</code></pre>

<p>section above is a bit too literal. Why not just use a <em>char</em> to store your desired answer and use the following to create </p>

<pre><code>if(strcmp(letter, *desired char here*) == 0){
</code></pre>

<p>just a guess considering the fact it may be client side if your scanf function is freezing only in debug but with the example above it is a bit more user friendly when reading the code and will not have any errors when dealing with other characters and integers later on in your program. Depending on what you want to accomplish with it.</p>
",0
28150653,28150543,1,"<p>The memory is allocated (and thus, not constant), so it is legal to cast <code>const</code> away:</p>

<pre><code>struct Foo * new_foo(void)
{
    struct Foo *n = malloc(sizeof *n);
    if (n) {
        struct Params *s = (void *)&amp;n-&gt;settings;
        s-&gt;a = SETTING_A;
        s-&gt;b = SETTING_B;
    }
    return n;
}
</code></pre>
",6
28196306,28150543,0,"<p>Here is one way to do it:</p>

<pre><code>struct Foo *new_foo(void)
{
    static struct Foo foo =
    {
        .settings =
        {
            .a = SETTING_A,
            .b = SETTING_B
        },
        .state = ...
    };

    struct Foo *n = malloc(sizeof *n);
    memcpy(n, &amp;foo, sizeof *n);

    return n;
}
</code></pre>

<hr>

<p>Here is another way to do it:</p>

<pre><code>struct Foo *new_foo(void)
{
    static struct Params settings =
    {
        .a = SETTING_A,
        .b = SETTING_B
    };

    struct Foo *n = malloc(sizeof *n);
    memcpy((struct Params*)&amp;n-&gt;settings, &amp;settings, sizeof settings);
    n-&gt;state = ...;

    return n;
}
</code></pre>
",0
31261318,31260839,1,"<p>You missed the line ""<em>If more than one order of brown, green, and clear bins yields the minimum number of movements then the alphabetically first string representing a minimal configuration should be printed.</em>"" Your posibleIndex [6] [3] initialization should be in the order  { {0, 2, 1}, {0, 1, 2}, {2,0,1}, {2,1,0}, {1, 0, 2}, {1, 2, 0} } because you have initialized bcgText[3] array as { 'B',  'G', 'C'} in order to maintain lexicographical ordering. One more thing, you should initialize sum variable declared in getSumOfBottles function with 0. Though you will get accepted even without initializing sum, it is a bad practice.</p>
",0
31150096,31150071,3,"<p>You never initialize <code>target</code> or <code>tobe_sorted</code> - they are ""full of junk"".</p>

<p>You never take the numbers off your command line <code>argv</code> and do anything with them.</p>

<p>You're going to need to convert the strings in <code>argv</code> into <code>ints</code>. Something like this:</p>

<pre><code>for(i = 1; i &lt; count; i++) {
    tobe_sorted[i-1] = atoi(argv[i]);
}
</code></pre>

<p>Before your <code>memcpy()</code></p>
",1
31150114,31150071,2,"<p>The main problem here is that you are not using <code>argv</code> at all.</p>

<p>You declare an array named <code>tobe_sorted</code>, you don't initialize its values (so it contains garbage).</p>

<p>Then you copy the data on the <code>target</code> array and you sort that garbage data. Then you print them.</p>

<p>You must parse <code>argv</code>, convert each argument to an <code>int</code> using something like <a href=""http://en.cppreference.com/w/cpp/string/byte/atoi"" rel=""nofollow""><code>atoi</code></a> and then sort these values.</p>
",0
31150129,31150071,2,"<p>You have several problems:</p>

<ol>
<li><code>int tobe_sorted[count];</code></li>
</ol>

<p>This is uninitialized.  It currently contains junk.  You're then copying that junk to your target array.</p>

<ol start=""2"">
<li><code>//copy unsorted ints to target
 memcpy(target, tobe_sorted, count * sizeof(int));</code></li>
</ol>

<p>As mentioned in 1, your <code>tobe_sorted</code> array doesn't contain your data.  You want to parse <code>*argv[]</code>, which is an array of arrays that contains the actual cmdline input.  <code>argc</code> just tells you how many elements exist in <code>*argv[]</code> array.
You need to parse the <code>argv</code> array, convert each element into an <code>int</code> and store the results in the <code>tobe_sorted</code> array.</p>
",0
31174754,31174743,7,"<p>Use <code>*buttons = 5;</code> instead of <code>buttons = 5;</code></p>

<blockquote>
  <p>when I print the value of buttons, it's shown as 0(the value it was initialized to)</p>
</blockquote>

<p>The value of <code>button</code> is not initialized but as you know, the <a href=""https://en.wikipedia.org/wiki/Global_variable"">global variables</a> by default initialized with <code>0</code> hence you get <code>0</code> when you print it.</p>

<p><code>buttons=5;</code> means the address of <code>buttons</code> pointer now holding address <code>5</code> whereas, <code>*buttons = 5;</code> means the content of <code>buttons</code> pointer is changed with value <code>5</code>. Remember, the content of whom <code>buttons</code> pointer points will be updated by <code>5</code> now.</p>
",0
27161150,27161132,1,"<p>I'm sure you got a compiler warning for this.  But it compiles because what you are doing is setting <code>c</code> to the address of the function <code>getchar</code> (of course you are only getting the lowest byte of the address).</p>
",1
27161234,27161132,0,"<p>Are you not just assigning to c the value of the address of the getchar function. Which is probably not what you want but not illegal.</p>

<pre><code>gcc -g -o test test.c
test.c: In function ¡®count_lines¡¯:
test.c:7:15: warning: assignment makes integer from pointer without a cast [enabled by   default]
     while ((c = getchar) != EOF)      // compiles as getchar instead of getchar()
</code></pre>
",1
27161241,27161132,2,"<p>This:</p>

<pre><code>c = getchar
</code></pre>

<p>attempts to assign the address of the function <code>getchar</code> to the <code>char</code> object <code>c</code>.</p>

<p>This is a <em>constraint violation</em>, meaning that any conforming C compiler must issue a diagnostic. That diagnostic may legally be a non-fatal warning, and a compiler is still allowed to produce a ""working"" executable -- though its behavior is not defined by the standard.</p>

<p>If a compiler doesn't reject it outright, it will most likely generate a conversion of the function pointer value to type <code>char</code>. The standard does not define the behavior of such a conversion (but it's likely to take the low-order 8 bits of the address. This is unlikely to match the value of <code>EOF</code>, resulting in an infinite loop.)</p>

<p>As I'm sure you know, the line</p>

<pre><code>while ((c = getchar) != EOF)
</code></pre>

<p>should be</p>

<pre><code>while ((c = getchar()) != EOF)
</code></pre>

<p>As you might not have noticed, the <code>getchar()</code> function returns a result of type <code>int</code>, not <code>char</code>, precisely so that the value <code>EOF</code> can be distinguished from any valid character value. You should declare <code>c</code> as an <code>int</code>, not as a <code>char</code>. See question 12.1 of the <a href=""http://www.c-faq.com/"" rel=""nofollow"">comp.lang.c FAQ</a>.</p>
",3
33036717,33036546,5,"<p><code>strtok</code> modifies the original string. And you pass it a string literal which you can't modify. You should declare and initialize <code>cmd</code> like this- </p>

<pre><code> char cmd[] = ""zwr ^A(\""A\"")""; //string: zwr ^A(""A"")
</code></pre>

<p>Also in function <code>int checkUserRole(char *cmd)</code> -</p>

<pre><code>char fileContent[1000000];   // maybe use a pointer instead and allocate memory on heap
</code></pre>
",2
26253853,26243564,0,"<p>I hope the below code does what you are trying to do. Which is simple and looks good too.</p>

<pre><code>#include&lt;stdio.h&gt;

void power (int, int);
int main()
{
   int a,b;
   scanf(""%d %d"",&amp;a, &amp;b);
   power(a,b);
   return 0;
}

void power(int a, int b)
{
   int c=1,sum=0;
   while(b&gt;0)
   {   
      c = c*a;
      b--;
   }   
   printf(""%d\n"",c);
   while(c!=0)
   {   
      sum = sum+(c%10);
      c =c/10;
   }   
   printf(""%d\n"",sum);

}
</code></pre>
",3
29224291,29224234,5,"<p>The <code>reverse</code> function leaves its argument pointing to zero. The argument doesn't need to be a pointer, and passing <code>n</code> by value instead solves the problem.</p>

<p>Here's fixed code, somewhat reformatted and with error-checking added.</p>

<pre><code>#include &lt;stdio.h&gt;

int reverse(int p) {
    int rev = 0;
    while (p != 0) {
        rev = rev * 10;
        rev = rev + p%10;
        p = p/10;
    }
    return rev;
}

int main(void) {
    int n, i;
    printf(""Please enter a number: "");
    if (scanf(""%d"", &amp;n) != 1) {
        printf(""failed to read number.\n"");
        return 1;
    }
    i = reverse(n);
    if (i == n) {
        printf(""%d is a palindrome: reversing it gives %d\n"", n, i);
    } else {
        printf(""%d isn't a palindrome: reversing it gives %d\n"", n, i);
    }
    return 0;
}
</code></pre>

<p>It's an important skill to be able to debug programs. Here's a good link for some beginner techniques: <a href=""http://ericlippert.com/2014/03/05/how-to-debug-small-programs/"" rel=""nofollow"">http://ericlippert.com/2014/03/05/how-to-debug-small-programs/</a></p>
",6
28206485,28204427,0,"<p>I ended doing this :</p>

<pre><code>    int i=0;
    int j=0;
    while(i != LETTER_COUNT)
    {
        char c = myBaseArray[j % myBaseArray_LENGTH];
        if(c == ' '){
            linkedListTwo = add(linkedListTwo,  c);
            j++;
        }
        else{
            linkedListTwo= add(linkedListTwo,  c);
            j++;
            i++;    
    }
}
</code></pre>
",0
23581068,23580845,4,"<p>There is no requirement for the compiler/linker toolchain to produce executables with identical checksums for equivalent programs. In fact, some compilers on certain platforms would produce different executables when <em>the same program</em> is rebuilt twice.</p>

<p>See, for example, <a href=""https://stackoverflow.com/questions/5794949/exe-checksum-different-after-each-recompile"">exe checksum different after each recompile</a></p>

<p>You'd have to profile to executable to see if there's any performance difference (in your example, there will almost certainly be none).</p>
",3
27118962,27118941,0,"<p>The variable is not declared as <code>long int</code> . The declaration should be <code>long int nEndIndex = -1;</code> </p>
",1
27119024,27118941,5,"<p>The type of the argument (after promotion, which doesn't apply in this case) <em>must</em> match the type expected for the format string; otherwise the behavior is undefined.</p>

<p>Passing an <code>int</code> to a function expecting a <code>long int</code> is usually permitted, and causes an implicit conversion. But for a variadic function like <code>printf</code>, the compiler doesn't know what type to convert the argument to.</p>

<p>The behavior is undefined, which means that quite literally anything can happen (including, if you're <em>unlucky</em>, the code appearing to work ""correctly""). In practice, let's assume that <code>int</code> is 32 bits and <code>long</code> is 64 bits (those sizes vary from system to system). <code>printf</code> might grab 64 bits of data from the stack, 32 bits from your argument and another 32 bits of garbage; it will then print that data <em>assuming</em> that it's a <code>long int</code> object (because that's what you told it via the format string).</p>

<p>Use <code>%d</code> for an <code>int</code> argument, <code>%ld</code> for a <code>long int</code> argument.</p>
",5
31233823,12231560,0,"<pre><code> static unsigned absolute(int x)
 {
          if (INT_MIN == x) {
                  /* Avoid tricky arithmetic overflow possibilities */
                  return ((unsigned) -(INT_MIN + 1)) + 1U;
          } else if (x &lt; 0) {
                  return -x;
          } else {
                  return x;
          }
 }
</code></pre>
",1
25473768,25473677,0,"<pre><code>#include &lt;stdio.h&gt;

#define last(a) a[sizeof(a)/sizeof(*a)-1]

int main(){
    int a[] = {10, 20, 30, 40, 50, 60, 70, 80, 90};
    char ca[] = { 'x', 'y', 'z' };
    printf(""%d\n"", last(a));
    printf(""%c\n"", last(ca));
    return 0;
}
</code></pre>
",12
27568842,27568645,1,"<p>Is a circular dependency header problem.</p>

<p>file strophe.h has to be include before common.h</p>

<p>That because of types in strophe.h has to be known by common.h</p>

<pre><code>#include ""strophe.h""
#include ""common.h""

void main()
{
    xmpp_ctx_t *ctx;

    xmpp_initialize();

    ctx = xmpp_ctx_new(NULL, log);
    /* create a connection */
    conn = xmpp_conn_new(ctx);
    xmpp_connect_client(conn, ""alt3.xmpp.l.google.com"", 5222, conn_handler,
            ctx);
    ctx-&gt;loop_status = 1; // error error: dereferencing pointer to incomplete type
    xmpp_run(ctx);
}
</code></pre>
",8
27677741,27677631,2,"<p>Yes you are right and wrong. You would get an empty NUL terminated string (<code>lim</code> is supposed to include the terminating NUL character). A valid C-string should be NUL terminated and even a zero length string contains at least one character. So, if your MAXLINE is 1, it's already full and can't hold any more characters.</p>

<pre><code>while (--lim &gt; 0 &amp;&amp; (c=getchar()) != EOF &amp;&amp; c!= '\n')
    s[i++] =c; 
if (c =='\n')
    s[i++] =c; 
s[i] = '\0' ;
</code></pre>

<p>The last statement <code>s[i] = '\0'</code> is assigning the NUL character, which in your case would be <code>s[0] = '\0';</code>. Also, the getline function is correctly returning the length of captured string (=0) in the next statement <code>return i;</code>. </p>
",2
32492742,32492688,3,"<pre><code>struct tm epoch_time;
time_t seconds = 1441852;
memcpy(&amp;epoch_time, localtime(&amp;seconds), sizeof (struct tm));
</code></pre>

<p>This assumes you want local time. If you want GMT, use <code>gmtime</code> instead of <code>localtime</code>. Note that this will crash on error.</p>
",4
25689717,25687011,2,"<p>You need to recognize the third comma and fill in .text when you find it, something along these lines:</p>

<pre><code>        case ',':
            if (currentElement == &amp;(currentRow.a)) {
                currentElement = &amp;(currentRow.b);
                break;
            }
            if (currentElement == &amp;(currentRow.b)) {
                currentElement = &amp;(currentRow.t);
                break;
            }
            {   int i = 0;
                int maxchars = sizeof(currentRow-&gt;text) - 1;

                while ((lastRead = readChar(input, buffer, &amp;pos, &amp;limit)) != '\n') {
                    if (i &lt; maxchars) currentRow-&gt;text[i++] = lastRead;
                }
                currentRow-&gt;text[i] = '\0';
            }
            /* fallthrough*/
</code></pre>
",1
25690023,25687011,1,"<p>This will probably do what you want, which is considerably different than how I would have done <em>any</em> of this, but its your code, and I'm looking for a minimal solution.</p>

<p>First, define a macro for your text field length</p>

<pre><code>#define TEXT_LEN    40
</code></pre>

<p>and use it in your structure:</p>

<pre><code>typedef struct Row {
    uint32_t a;
    uint32_t b;
    uint32_t t;
    char text[TEXT_LEN];
} Row;
</code></pre>

<p>Next, modify your <code>readAll</code> to do this:</p>

<pre><code>void readAll(char * fileName, Row * table)
{
    char* buffer = (char*) malloc(sizeof(char) * BUFFER_SIZE);
    int limit = 0;
    int pos = 0;

    FILE * input = fopen(fileName, ""rb"");

    int lastRead;
    Row currentRow;
    uint32_t * currentElement = &amp;(currentRow.a);
    size_t txt_len = 0;

    while (1)
    {
        switch(lastRead = readChar(input, buffer, &amp;pos, &amp;limit))
        {
            case END_OF_FILE:
                fclose(input);
                return;

            case ',':
                // move from a to b
                if (currentElement == &amp;(currentRow.a))
                    currentElement = &amp;(currentRow.b);

                // move from b to t
                else if (currentElement == &amp;(currentRow.b))
                    currentElement = &amp;(currentRow.t);

                // move from t to NULL, begin trailing text
                else
                    currentElement = NULL;
                break;

            case '\n':
                // terminate text string
                currentRow.text[txt_len] = 0;
                insert(table, currentRow);
                currentRow.a = 0;
                currentRow.b = 0;
                currentRow.t = 0;
                txt_len = 0;
                currentElement = &amp;(currentRow.a);
                break;

            default:
                // only if  there is a current element to parse as uint32_t
                if (currentElement)
                    *currentElement = *currentElement * 10 + (lastRead - '0');

                // else we're parsing trailing text
                else if (txt_len &lt; (TEXT_LEN-1))
                    currentRow.text[txt_len++] = lastRead;

                // else we consume the char. as we have no space for it anyway
                break;
        }
    }
}
</code></pre>

<p><strong>Notes:</strong></p>

<p>Worth mentioning, your code will skip the last entry in the file if it is not terminated by a newline. Addressing that is not entirely trivial, in particular because of the double-buffering being done. The double buffering is a waste, and frequently done to avoid the overhead of the mandated locking characteristics of <code>fgetc()</code> and <code>getc()</code>. If only a single thread is reading the file, you can avoid this and significantly boost your performance by doing the following:</p>

<ul>
<li>Open the file in read-only mode (you're doing this already)</li>
<li>Invoke <a href=""http://pubs.opengroup.org/onlinepubs/009696799/functions/flockfile.html"" rel=""nofollow""><code>flockfile(input)</code></a> to lock the file for your thread.</li>
<li>Consume the file with your loop using <a href=""http://pubs.opengroup.org/onlinepubs/009696799/functions/getc_unlocked.html"" rel=""nofollow""><code>getc_unlocked(input)</code></a></li>
<li>Upon reaching <code>EOF</code>, invoke <code>funlockfile(input)</code> and then <code>fclose(input);</code></li>
</ul>

<p>Doing the above will eliminate the need for <code>readChar</code> entirely, and reduce your code base significantly.</p>

<p>Best of luck.</p>
",2
25516133,25515347,2,"<pre><code>const int array_size = 32;
</code></pre>

<p>Does <strong>NOT</strong> make <code>array_size</code> a constant. It merely means that it cannot be used for assignment as an lvalue. (it's value can be changed otherwise). Therefore it is not allowed as a <code>constant literal</code> in:</p>

<pre><code>char my_array[array_size];
</code></pre>

<p>You can either:</p>

<pre><code>#DEFINE array_size  32
</code></pre>

<p>or</p>

<pre><code>enum { array_size = 32 };
</code></pre>
",1
23581517,23580682,0,"<p><code>user32.dll</code> does not export <code>NtUserMessageCall</code> for public use (it is internal only), so you cannot get its address by name using <code>GetProcAddress</code>. You'll have to find another technique, like downloading and parsing the symbol file (<code>.PDB</code>) for the version of the DLL you're working with.</p>
",1
27496699,27493037,1,"<p>To split a number into <code>char</code> code needs use the intended base and null character terminate to treat as a string.</p>

<pre><code>#include &lt;limits.h&gt;

void display_decl(unsigned int j) {
  char lst[sizeof j * CHAR_BIT + 1];
  unsigned base = 10;  // or 16 or any base 2 to 16
  char *p = &amp;lst[sizeof lst] - 1;
  *p = '\0';
  do {
    p--;
    *p = ""0123456789ABCDEF""[j%base];
    j /= base;
  } while (j &gt; 0);
  display_string(p);
}
</code></pre>
",0
25443506,25442313,1,"<p>The obvious solution to your problem is multithreading (backgrounding of the computation). It is a good idea to use Gtk+ functionality for that as well (as you show in your example solution).</p>

<p>However if your program is rather simple and you don't want to make it complicated (esp. with communication of results, cancellation etc.), you can also interrupt your scanning routine frequently to process Gtk+ events. See the documentation of events_pending():
<a href=""http://www.gtk.org/api/2.6/gtk/gtk-General.html#gtk-events-pending"" rel=""nofollow"">http://www.gtk.org/api/2.6/gtk/gtk-General.html#gtk-events-pending</a></p>

<p>Obviously, the overall performance of the multithreading solution is better especially as nowadays most computers come with several CPU cores.</p>
",0
30408690,30408662,7,"<p>It's so you can mask bits off and set bits.  At least that's the simple answer.  In C, &amp; is the bitwise AND operator and | is the bitwise OR operator (which are a little different than the logical &amp;&amp; and || used for boolean operations).  Take a look at the truth tables below.</p>

<pre><code>AND       OR
A B X     A B X
0 0 0     0 0 0
0 1 0     0 1 1
1 0 0     1 0 1
1 1 1     1 1 1
</code></pre>

<p>A and B are inputs and X is the output.  So when you do a 16-bit endian swap, you would use a macro like this:</p>

<pre><code>#define endianswap16(x)  (x &lt;&lt; 8) | (x &gt;&gt; 8)
</code></pre>

<p>This takes x, does a shift, then ORs the results together to get the endian swap.  Take the 32-bit endian swap which uses both &amp; and | in addition to bit shifting:</p>

<pre><code>#define endianswap32(x)  (x &lt;&lt; 24) | (x &amp; 0x0000FF00) &lt;&lt; 8) \
  | (x &amp; 0x00FF0000) &gt;&gt; 8) | (x &gt;&gt; 24)
</code></pre>

<p>Since 32 bits is 4 bytes, this swaps the two outer bytes with each other and then swaps the two inner bytes with each other.  Then it does logical ORs to put the 32-bit number back together.  The ANDs are used to mask off certian bit positions so when we perform the ORs to reconstruct the number, we don't change the value.</p>

<p>As to your question as to why we do it this way, it's because we have to reverse the order of the bytes.  Take 0x12345678 for instance.  When stored in memory on both a little and big endian machines, it would look like this:</p>

<pre><code>---&gt; Increasing Memory Address
78 56 34 12   Little Endian
12 34 56 78   Big Endian
</code></pre>

<p>Intel and their clones are little endian machines which actually has advantages over the big endian format.  Big endian machines are the IBN S/360 and descendants (Z-architecture), Sparc, Motorola 68000 series and PowerPC, MIPS, and others.</p>

<p>There are two big problems when dealing with platforms that differ in endiness:</p>

<ul>
<li>The first one is when exchanging binary data between big and little
endian platforms.</li>
<li>The second one is when software takes a multibyte value and splits it up into different byte values.</li>
</ul>

<p>An example of this is Intel machines communicating over the network.  The network addresses are in network byte order which is big endian, but Intel machines are little endian.  So IP addresses and such need to have their endians swapped for them to be interpreted correctly.</p>
",6
30408692,30408662,1,"<p>It's fairly straightforward bit masking and shifting. </p>

<p>the <code>(num &amp; 0x000000ff)</code> zeros out all but a single byte of the word.  The <code>&lt;&lt; 24u</code> shifts it by 24 bits, or 3 8-bit bytes, putting it at the other end of the word.  The next three lines swap the remaining 3 bytes in a similar manner. 
Then the <code>b1|b2|...</code> combines those bytes together to make the final word.</p>

<p>See <a href=""https://stackoverflow.com/q/47981/10396"">How do you set, clear, and toggle a single bit?</a> and <a href=""https://stackoverflow.com/q/141525/10396"">What are bitwise shift (bit-shift) operators and how do they work?</a>. The same operations that work on single bits work on groups of bits, in this case the 8 bits that make a byte.</p>
",1
30170314,30170109,3,"<p>*row is not null after the first insert.  So the next insert never happens.</p>

<pre><code>void insertEnd(ROW *row, int value){
    if(*row==NULL){
        printf(""Inserting %d\n"", value);
        *row = (ROW) (malloc(sizeof(Element)));
        if(*row==NULL){
            return;
        }else{
            (*row)-&gt;data = value;
            (**row).next = NULL;
        }
    }
}
</code></pre>

<p>Add a debug printf like this and it'll become obvious what's happening.</p>

<p>I think there are more fundamental problems though with the design!  </p>

<p>You might want to keep a pointer to the start of the list around otherwise it'll be mighty difficult to find it again.  And for a fast insert at the end you might want to keep a pointer to the end of the list as well. </p>

<p>I'm assuming that you are trying to figure this out for yourself, so I won't give you the answer :)</p>
",3
30170601,30170109,0,"<p>The problem is in the method insertEnd.</p>

<p>You should link the elements of the list not overide them :) like this :</p>

<pre><code>void insertEnd(ROW *row, int value){
    if(*row!=NULL){
        ROW *lastElement = (ROW) (malloc(sizeof(Element)));
        if(*lastElement==NULL){
            return;
        }else{
            (*lastElement)-&gt;data = value;
            (**lastElement).next = NULL;
            (**row).next = lastElement;
        }
    } else {
        *row = (ROW) (malloc(sizeof(Element)));
        if(*row==NULL){
            return;
        }else{
        (*row)-&gt;data = value;
        (**row).next = NULL;
    }
}
</code></pre>

<p>Like this you will link all your list elements.</p>
",0
32939120,32939045,3,"<pre><code>if (scanf(""%d \""%49[^\""]\"" %lf"", &amp;x, y, &amp;z) == 3)
    ¡­process valid data¡­
else
    ¡­report erroneous input¡­
</code></pre>

<p>The relevant part for you is <code>%49[^\""]</code>; it matches a string until <code>""</code> is encountered (or it runs out of space). Note that this will not include the <code>""</code> into the string.</p>
",0
32939149,32939045,4,"<p>OP's approach hopes to use <code>fgets()</code> to read a portion of a line, yet <code>fgets()</code> reads until an end-of-line <code>'\n'</code> is encountered.</p>

<p>Read the <em>entire</em> line with <code>fgets()</code> and <em>then</em> parse.</p>

<p>Using <code>""%n""</code> is an easy way to see if the entire string was parsed as expected.</p>

<pre><code>int code;
char description[50];
double value;
#define MAX_LINE_SIZE (20 + 2 + sizeof description + 2 + 20 + 2)
char line[MAX_LINE_SIZE];

printf(""Type in: "");
fflush(stdout);
fgets(line, sizeof line, stdin);

int n = 0;
sscanf(line, ""%d \""%49[^\""]\""%lf %n"", &amp;code,  description, &amp;value, &amp;n);
if (n == 0 || line[n] != '\0') {
  fputs(""Input formatted incorrectly\n"", stderr);
  return 1;
}

printf(""%d\n"", code);
printf(""\""%s\""\n"", description);
printf(""%2.2f"", value);
</code></pre>

<p><code>""%d \""%49[^\""]\""%lf %n""</code> details</p>

<p><code>""%d""</code> scan &amp; toss whitespace, scan and save integer<br>
<code>"" ""</code> scan and toss any whitespace<br>
<code>""\""""</code> scan and match a <code>'\""'</code><br>
<code>""%49[^\""]""</code> scan up to 49 char that are not <code>'\""'</code>, save in <code>description</code> and append <code>'\0'</code><br>
<code>""%lf""</code> scan &amp; toss whitespace, scan and save <code>double</code><br>
<code>""%n""</code> save current offset of scan into <code>n</code>.</p>
",1
22435009,22434876,2,"<p>It is a undefined behavior.</p>

<p><code>printf(""The value of --i-&gt; %d and that of --i -&gt; %d and that of i -&gt; %d"",--i,--i,i);</code></p>

<p><code>i</code> is modified more than once in the above statement.</p>

<p>The Standard in C++ says</p>

<p>Between the previous and next sequence point a scalar object shall have its stored value modified at most once by the evaluation of an expression.</p>

<p>and</p>

<p>The prior value shall be accessed only to determine the value to be stored.</p>

<p>It means, that between two sequence points a variable must not be modified more than once and, if an object is written to within a full expression, any and all accesses to it within the same expression must be directly involved in the computation of the value to be written.</p>
",2
22435070,22434876,-2,"<p>Pre- decrement takes precedence over post increment.
So what happens is value, at the address where i stored (say address x), gets decremented twice and becomes 8.</p>

<p>Now the first argument i++ gets ivaluated.
As this is post increment, value is used first (so 8 is printed) and then incremented .
hence, 
what has happened finally is value at address x is incremented by 1 and becomes 9.</p>

<p>Now, we have already done with pre-decrement.
So printf only remembers to print the value at address of i i.e. address x that we have assumed.</p>

<p>And finally because of forth argument i, one more 9 is printed.</p>
",0
30155826,30155573,3,"<p>Assuming you have an original size factor (the name <em>capacity</em> would be as-appropriate, if not more so), your original code lacks several things:</p>

<ul>
<li>Compares the size against a constant, rather than the current sp against the stack current size.</li>
<li>Does not <em>save</em> nor <em>test</em> the return result of <code>realloc</code></li>
<li>Does not actually double the allocation (you're missing the 2x in the realloc expression.</li>
<li>Declares an <code>int</code> return result, but no such return exists.</li>
<li>Has no way of communicating back to the caller the push result (success or not). That missing return result would be ideal for this, btw.</li>
</ul>

<p>Addressing <em>all</em> of these:</p>

<pre><code>int pushs(STACKS *s, int x)
{
    if (s-&gt;sp == s-&gt;size) 
    {
        void *pv = realloc(s-&gt;values, 2 * s-&gt;size * sizeof *(s-&gt;values));
        if (pv != NULL)
        {
            s-&gt;values = pv;
            s-&gt;size *= 2;
        }
        else
        {
            fprintf(stderr, ""Failed to resize stack\n"");
            return -1;
        }
    }

    s-&gt;values[s-&gt;sp++] = x;
    return 0;
}
</code></pre>

<p>Untested, but hopefully close enough.</p>

<p>Best of luck </p>
",9
30157928,30155573,-1,"<p>Although not directly an answer to the actual question, but more to the general problem, I post this as it does not fit into a comment.</p>

<p>If you expect excessive push/pop operations and memory usage, the following might be an alternative:</p>

<pre><code>typedef struct SubStack_s {
    struct SubStack_s *prev;
    int data[ENTRIES_PER_SEGMENT];
} SubStack;

typedef struct {
    SubStack *tos;    // init to NULL
    size_t sp;        // init to 0
} Stack;
</code></pre>

<p>The basic idea is to push elements onto each substack until full (as you already do). If the current one is full, you alloc a new one, chain them (<code>new-&gt;prev = old</code>) and continue with the new one (storing <code>new</code> to <code>Stack.tos</code>)</p>

<p>Pop works similar, free'ing each substack once it is not used anymore.</p>

<p>That concept is called ""fragmented stack"". It is much more efficient than the realloc-approach (it avoids copying) and does not fragment RAM as all block are of equal size. Oh, and it allows to have pointers into the stack, which the realloc-varaint does not, because the address of the stack can change.</p>
",10
25529433,25529309,0,"<p>Neither <code>d</code> nor <code>pEnd</code> appears to have been allocated.  Also, you've initialized <code>i</code> to <code>o</code>, which if it isn't a typo (for <code>0</code>?), is an undeclared variable (which would prevent your code form compiling).</p>
",1
25529505,25529309,2,"<p>You need to allocate space for <code>d</code>.</p>

<p>Try</p>

<pre><code>double d[3] = {0}; // double *d = NULL;
</code></pre>

<p>If you want to keep using <code>d</code> as a pointer, allocate space before assigning</p>

<pre><code>double *d = NULL;
d = malloc(3 * sizeof *d);
if (d != NULL) {
    // ... your code using d
    free(d);
} else {
    fprintf(stderr, ""Unable to allocate memory for `d`.\n"");
    exit(EXIT_FAILURE);
}
</code></pre>
",2
25529601,25529309,0,"<p>Note this-</p>

<pre><code>char * pEnd = = NULL; // you should not use '==' here
</code></pre>

<p>First fix this to-</p>

<pre><code>char * pEnd = NULL;
</code></pre>

<p>Then try to allocate memory for <code>d</code> and <code>pEnd</code> and try it.</p>
",0
23595280,23594849,0,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt; // to use tolower()


void display_menu(void);


void display_menu()
{
 char c;

  /* char c = 'y'; You don't need to set it equal to y. 
     The do-while loop will run at least one time regardless of you condition */

  printf(""This is Menu for Single Linkd List:\n"");

 do
 {
    printf(""Press 1 for Create Link List \n"");
    printf(""Press 2 for Insert Node\n"");
    printf(""Press 3 for Delete the entire list\n"");
    printf(""Press 4 for Delete the Node\n"");
    printf(""Press 5 for Reverse the List\n"");
    printf(""Press 6 for Display the List\n"");
    printf(""Press 7 for Display the Node\n"");
    printf(""Press 'y' or 'Y' for Display the Menu again \n"");

    scanf("" %c"",&amp;c);
    c = tolower(c); //simplifies you while condition.
 }while( c == 'y');

}



int main()
{
 display_menu();

 return 0;
}
</code></pre>
",0
23594931,23594849,1,"<p>You need to take into account new line characters etc.</p>

<p>So the <code>scanf</code> should just eat them</p>
",0
23594992,23594849,1,"<p>The conversion specifier <code>""%c""</code> does not ignore whitespace. So when you type ""Y"" both the ""Y"" and the """" get assigned to <code>c</code>.</p>

<p>You have several options:</p>

<ol>
<li>use <code>fgets()</code> for obtaining user input</li>
<li>ignore whitespace</li>
<li>use a 1-char string (<code>char onechar[2];</code>) and the conversion specifier <code>""%1s""</code> to have <code>scanf()</code> automatically ignore leading whitespace</li>
</ol>
",0
23595037,23594849,2,"<p>Instead of:</p>

<pre><code>scanf(""%c"",&amp;c);
</code></pre>

<p>Use:</p>

<pre><code>scanf("" %c"",&amp;c);
</code></pre>

<p>The leading space tells scanf() to skip residual whitespace characters (including '\n') before reading the next character.</p>
",1
31807572,12867810,0,"<pre><code>   private static void problem20()
    {
        string muliplent = ""100"";
        for (int i = 99; i &gt; 1; i--)
        {
            muliplent = getproduct(muliplent, i);
        }

        int sum = 0;
        char[] result=muliplent.ToCharArray();
        int count = muliplent.ToCharArray().Count();
        for (int j = 0; j &lt; count; j++)
        {
            sum = sum + (result[j] - '0');
        }
        Console.WriteLine(""sum is {0}"", sum);
        Console.ReadLine();

    }


    private static string getproduct(string multiplent, int multiplier)
    {
        StringBuilder str = new StringBuilder();
        int product = 0;
        int remainder = 0;
        int dividend = 0;
        char[] c = multiplent.ToCharArray();

        for (int i = c.Count() - 1; i &gt;= 0; i--)
        {
            product = (((c[i] - '0') * multiplier) + dividend);
            remainder = product % 10;
            dividend = product / 10;
            if (i != 0)
            {
                str.Insert(0, remainder);
            }
        }
        str.Insert(0, product);

        return str.ToString();
    }
</code></pre>
",0
24091230,24090687,0,"<p>When writing to a terminal, <code>stdout</code> is flushed after every line. This way you can always see the output right away. When writing to a file or, as in your case a pipe, this automatic flush is disabled. Usually in those cases performance is more important.</p>

<p>This causes problems when processes have to interact with each other. One program writes something. It's not sent instantly but stored in a buffer. Second program waits for that data. First program waits for more data from second program resulting in a deadlock.</p>

<p>To avoid this, you need to flush all the output before waiting for additional input. Simple <code>fflusuh(stdout)</code> before every <strong>read</strong> operation should be enough. This is actually what <code>$|=1</code> does in Perl. Nothing needs to be done with <code>stdin</code>.</p>

<p>If performance is critical and you need to operate only on single bytes. Read and write data in big chunks using unbuffered <a href=""http://linux.die.net/man/2/read"" rel=""nofollow"">read</a>/<a href=""http://linux.die.net/man/2/write"" rel=""nofollow"">write</a>. For example:</p>

<pre><code>#include &lt;unistd.h&gt;

int main() {
    char buf[1024];
    while(1) {
        int len = read(0,buf,sizeof(buf));
        for(int i=0;i&lt;len;i++) {
            if ( buf[i] == '-' ) {
                buf[i] = '_';
            }
        }
        write(1,buf,len);
    }
}
</code></pre>
",0
24090986,24090687,2,"<p>Question 1:  You would have to look at the code.  It could be line buffered, it could be using fflush at the end of each request (or block of requests), or it could be using write calls with a larger buffer.  In any case, it won't be doing per-character I/O which is what your program is doing.</p>

<p>Question 2:  I suspect the main issue is on output.  If you were to assemble the entire result in a buffer and write that out as one call, then you would be faster.  However, that just means you are doing the line buffering instead of having the library take care of it for you.  The key is that with no buffering, each output call results in a system call - that is very high overhead.  In theory, the same concept holds true on input but I'm not sure the implementation wouldn't notice the available characters and buffer them in any case.  Same workaround though - read a larger buffer and then take it apart yourself.</p>

<p>Personally, I'd avoid all the setvbuf stuff and just do an fflush at the end of each request.</p>
",4
26408222,26408150,0,"<p>In this case you are making a cast. </p>

<p>You are just saying for the compile. Hey, I'm sure that this is a type (A).</p>

<p>C++ style casts are checked by the compiler. C style casts aren't and can fail at runtime</p>
",0
26408232,26408150,2,"<p>It is not necessary in C but it helps silent compiler warnings for implicit casts in some cases.</p>

<p>In C++ however you need explicit casts to cast a void pointer into a pointer of a different type.</p>
",2
26408263,26408150,4,"<p>You've got it the other way around: the cast is absolutely necessary in C++, but it is not necessary in C.</p>

<p>This <a href=""http://ideone.com/kXnkIU"" rel=""nofollow"">will compile in C</a>, but <a href=""http://ideone.com/QnXZPs"" rel=""nofollow"">not in C++</a>:</p>

<pre><code>static void hexdump(const void* pv, int len) {
  const unsigned char* p = pv;
  ...
}
</code></pre>
",2
26408246,26408150,0,"<p>It's called a <strong>cast</strong>. It means that it converts b in the (A) type.</p>

<pre><code>char c = 'a'; // c is a char
int b = (int) c // you tell your compiler to interpret c as an int
</code></pre>
",0
26408255,26408150,4,"<p>No, conversion from <code>void*</code> to <code>char*</code> in C (it's a <a href=""https://stackoverflow.com/questions/1736833/void-pointers-difference-between-c-and-c"">common example</a> to explain where they're different!) is implicit so casting is unnecessary (then <em>wrong</em> because it may hide a problem if you wrongly change <code>char</code> to <code>int</code>).</p>

<p>Quoting ""<em>The C Programming Language</em>, 2nd edition"" by K&amp;R (<strong>¡ìA.6.8</strong>):</p>

<blockquote>
  <p>Any pointer to an object may be converted to type void* without loss of information. If the result is converted back to the original pointer type, the original pointer is recovered. Unlike the pointer-to-pointer conversions discussed in Par.A.6.6, which generally require an explicit cast, pointers may be assigned to and from pointers of type void*, and may be compared with them.</p>
</blockquote>

<p>Please note <em>""If the result is converted back to the original pointer type""</em> because is crucial: if instead of <code>char*</code> you had <code>int*</code> then it <em>may</em> be wrong because of memory alignment.</p>

<p>From C99 standard (<strong>¡ì6.3.2.3</strong>) about when conversion is possible:</p>

<blockquote>
  <p>A pointer to void may be converted to or from a pointer to any incomplete or object type. A pointer to any incomplete or object type may be converted to a pointer to void and back again; the result shall compare equal to the original pointer.</p>
</blockquote>

<p>Now let's see when can be implicit (thanks to mafso for very quick search), from C11 (n1570) <strong>¡ì6.5.4p3</strong>:</p>

<blockquote>
  <p>Conversions that involve pointers, other than where permitted by the constraints of 6.5.16.1, shall be specified by means of an explicit cast.</p>
</blockquote>

<p>Then <strong>¡ì6.5.16.1</strong>:</p>

<blockquote>
  <p>One of the following shall hold: [...] the left operand has atomic, qualified, or unqualified pointer type, and (considering the type the left operand would have after lvalue conversion) one operand is a pointer to an object type, and the other is a pointer to a qualified or unqualified version of void, and the type pointed to by the left has all the qualifiers of the type pointed to by the right</p>
</blockquote>
",0
26408408,26408150,1,"<p>In my practice, no casting at first, though there's compiler warnings, after testing pass, casting is added to eliminate warnings.</p>
",0
29246618,29246416,1,"<p>This is my suggestion to solve the problem</p>

<pre><code>#include&lt;stdio.h&gt;

#define LOW 0
#define HIGH 1
#define OPEN 2

#define MAXGPIO 5

int main()
{
    int gpio[MAXGPIO] = { LOW, LOW, OPEN, HIGH, OPEN };

    int mask = 0;

    for (int i = 0; i &lt; MAXGPIO; i++)
        mask = mask &lt;&lt; 2 | gpio[i];  

    printf(""Masked: %d\n"", mask);
    printf(""Unmasked:\n"");

    for (int i = 0; i &lt; MAXGPIO; i++)
        printf(""GPIO %d = %d\n"", i + 1, (mask &gt;&gt; (2*(MAXGPIO-1-i))) &amp; 0x03); 

    return 0;
}
</code></pre>

<p>A little explanation about the code.</p>

<p><strong>Masking</strong><br>
I am using 2 bits to save each GPIO value. The combinations are:</p>

<ul>
<li><code>00: LOW</code></li>
<li><code>01: HIGH</code></li>
<li><code>02: OPEN</code></li>
<li>03 is Invalid</li>
</ul>

<p>I am iterating the array gpio (where I have the acquired values) and creating a mask in the <code>mask</code> variable shifting left 2 bits and applying an <code>or</code> operation.</p>

<p><strong>Unmasking</strong><br>
To get the initial values I am just making the opposite operation shifting right 2 bits multiplied by the amount of GPIO - 1 and masking with 0x03 </p>

<p>I am applying a mask with <strong>0x03</strong> because those are the bit I am interested.</p>

<p>This is the result of the program</p>

<pre><code>$ cc -Wall test.c -o test;./test
Masked: 38
Unmasked:
GPIO 1 = 0
GPIO 2 = 0
GPIO 3 = 2
GPIO 4 = 1
GPIO 5 = 2
</code></pre>

<p>Hope this helps</p>
",2
29248580,29246416,1,"<p>You have 5 pins of 3 states each. You can approach representing this in a few ways.</p>

<p>First, imagine using this sort of framework:</p>

<pre><code>#define LOW (0)
#define HIGH (1)
#define OPEN (2)

uint16_t config = PIN_CONFIG(pin1, pin2, pin3, pin4, pin5);

if(config == PIN_CONFIG(LOW, HIGH, OPEN, LOW, LOW))
{
    // do something
}

switch(config) {
    case PIN_CONFIG(LOW, HIGH, OPEN, LOW, HIGH):
        // do something;
        break;
}

uint16_t config_max = PIN_CONFIG(OPEN, OPEN, OPEN, OPEN, OPEN);
uint32_t hardware_ids[config_max + 1] = {0};

// init your hardware ids
hardware_ids[PIN_CONFIG(LOW, HIGH, HIGH, LOW, LOW)] = 0xF315;
hardware_ids[PIN_CONFIG(LOW, LOW, HIGH, LOW, LOW)] = 0xF225;

// look up a HWID
uint32_t hwid = hardware_ids[config];
</code></pre>

<p>This code is just the sort of stuff you'd like to do with pin configurations. The only bit left to implement is <code>PIN_CONFIG</code></p>

<hr>

<h1>Approach 1</h1>

<p>The first approach is to keep using it as a bitfield, but instead of 1 bit per pin you use 2 bits to represent each pin state. I think this is the cleanest, even though you're ""wasting"" half a bit for each pin.</p>

<pre><code>#define PIN_CLAMP(x) ((x) &amp; 0x03)
#define PIN_CONFIG(p1, p2, p3, p4, p5)  \\
  (PIN_CLAMP(p1) &amp;                      \\
  (PIN_CLAMP(p2) &lt;&lt; 2) &amp;                \\
  (PIN_CLAMP(p3) &lt;&lt; 4) &amp;                \\
  (PIN_CLAMP(p4) &lt;&lt; 6) &amp;                \\
  (PIN_CLAMP(p5) &lt;&lt; 8))
</code></pre>

<p>This is kind of nice because it leaves room for a ""Don't care"" or ""Invalid"" value if you are going to do searches later.</p>

<hr>

<h1>Approach 2</h1>

<p>Alternatively, you can use arithmetic to do it, making sure you use the minimum amount of bits necessary. That is, ~1.5 bits to encode 3 values. As expected, this goes from 0 up to 242 for a total of 3^5=243 states.
Without knowing anything else about your situation I believe this is the smallest complete encoding of your pin states.
(Practically, you have to use 8 bits to encode 243 values, so it's higher 1.5 bits per pin)</p>

<pre><code>#define PIN_CLAMP(x) ((x) % 3) /* note this should really assert */
#define PIN_CONFIG(p1, p2, p3, p4, p5)  \\
  (PIN_CLAMP(p1) &amp;                      \\
  (PIN_CLAMP(p2) * 3) &amp;                 \\
  (PIN_CLAMP(p3) * 9) &amp;                 \\
  (PIN_CLAMP(p4) * 27) &amp;                \\
  (PIN_CLAMP(p5) * 81))
</code></pre>

<hr>

<h1>Approach 1.1</h1>

<p>If you don't like preprocessor stuff, you could use functions a bit like this:</p>

<pre><code>enum PinLevel (low = 0, high, open);

void set_pin(uint32_t * config, uint8_t pin_number, enum PinLevel value) {
    int shift = pin_number * 2; // 2 bits
    int mask = 0x03 &lt;&lt; shift; // 2 bits set to on, moved to the right spot
    *config &amp;= ~pinmask;
    *config |= (((int)value) &lt;&lt; shift) &amp; pinmask;
}

enum PinLevel get_pin(uint32_t config, uint8_t pin_number) {
    int shift = pin_number * 2; // 2 bits
    return (enum PinLevel)((config &gt;&gt; shift) &amp; 0x03);
}
</code></pre>

<p><em>This follows the first (2 bit per value) approach.</em></p>

<hr>

<h1>Approach 1.2</h1>

<p>YET ANOTHER WAY using C's cool bitfield syntax:</p>

<pre><code>struct pins {
    uint16_t pin1 : 2;
    uint16_t pin2 : 2;
    uint16_t pin3 : 2;
    uint16_t pin4 : 2;
    uint16_t pin5 : 2;
};

typedef union pinconfig_ {
    struct pins pins;
    uint16_t value;
} pinconfig;

pinconfig input;
input.value = 0; // don't forget to init the members unless static

input.pins.pin1 = HIGH;
input.pins.pin2 = LOW;

printf(""%d"", input.value);

input.value = 0x0003;
printd(""%d"", input.pins.pin1);
</code></pre>

<p>The union lets you view the bitfield as a number and vice versa.</p>

<p>(note: all code completely untested)</p>
",5
22499406,22499042,1,"<p>In your while loop you reallocate your buffer each time (which BTW is totally inefficient, but that's another story). But you continue to use the <code>ptr</code> pointer which points into the buffer that has been allocated by malloc just before the while loop. The realloc function <strong>may</strong> return the same address as the address of the previously allocated pointer, in which case your program seems to work. But if the returned address is <strong>different</strong>, <code>ptr</code> is no longer valid and your program won't work and it may even crash.</p>

<p>This should work (still as inefficient though) :</p>

<pre><code>while ((ch = fgetc(f)) != EOF) {
    if (ch == 10) {
        continue; //exclude new line character
    }

    arr[count++] = (ch - 48); //populating array
    arr = realloc(arr, (count + 1) * sizeof(int));
}
</code></pre>
",2
31292600,15708793,-1,"<p>Use This code</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;
#include&lt;stdlib.h&gt;
void main(){
char a[10];
clrscr();
gets(a);
int i,length=0;
for(i=0;a[i]!='\0';i++)
length+=1;
for(i=0;i&lt;length;i++){
a[i]=a[i]^32;
}
printf(""%s"",&amp;a);
getch();
}
</code></pre>
",0
25483237,25483166,2,"<p>Consider looking into <a href=""http://en.wikipedia.org/wiki/Mmap"" rel=""nofollow""><code>mmap</code></a> and <a href=""http://en.wikipedia.org/wiki/Memory-mapped_file"" rel=""nofollow"">memory-mapped storage</a>.</p>
",0
33590669,33590492,1,"<p>You can easily change the <code>update</code> function to</p>

<pre><code>struct entry *update(struct entry *insert, struct entry *before, struct entry *after)
{
    insert-&gt;next = after;
    if (before != NULL)
    {
        before-&gt;next = insert;
        return before;
    }
    return insert;
}
</code></pre>

<p>where <code>insert</code> is the entry to insert, <code>before</code> is the node before the one inserted, and <code>after</code> is the node after the one inserted. The function returns the new entry if it is being inserted as the first entry, and <code>before</code> otherwise.</p>

<p>To prepend to a list, use</p>

<pre><code>list_to_prepend_to = update(node_to_insert, NULL, list_to_prepend_to);
</code></pre>

<p>For example, in your code, you could use</p>

<pre><code>listPtr = update(&amp;insert, NULL, &amp;list);

while (listPtr)
{
    printf(""%d\n"", listPtr-&gt;value);
    listPtr = listPtr-&gt;next;
}
</code></pre>

<p>to prepend an entry to the list and print the list out. To insert in the middle of a list, you don't need the return value:</p>

<pre><code>update(&amp;insert, &amp;list, &amp;n1);
</code></pre>

<p>This will make <code>insert</code> the second entry in your list.</p>
",1
33591543,33590492,0,"<p>You are passing address of n2 to the update function. n2 is not the top of the list element. This will insert an element b/w n2 and end. 
To insert element after first element the top call-</p>

<p>update(&amp;insert, &amp;list);</p>

<p>To prepend a new element to the list-</p>

<p>struct entry new_element;</p>

<p>new_element.next = &list;</p>

<p>new_element.value = some_value;</p>
",0
21324487,21324470,1,"<p>In your <code>average</code> function, don't pass <code>*a</code> to <code>sum</code>, but just <code>a</code> since it's already a pointer.</p>
",0
21326374,21324470,0,"<p>Since a is an array, just passing a will give the base address of the array, so just pass a in the argument.</p>
",0
32946246,32946071,1,"<p>Problems:</p>

<ol>
<li><p>All these</p>

<pre><code>scanf(""%s"",&amp;gbl_name);
scanf(""%s"",&amp;username);  
scanf(""%s"",&amp;set);
scanf(""%s"",&amp;kill);
scanf(""%s"",&amp;zwrite);
</code></pre>

<p>should be</p>

<pre><code>scanf(""%s"", gbl_name);
scanf(""%s"", username);  
scanf("" %c"", &amp;set);
scanf("" %c"", &amp;kill);
scanf("" %c"", &amp;zwrite); /* The reason for using %c is explaned below */
</code></pre>

<p>because <code>%s</code> in the <code>scanf</code> expects a <code>char*</code>, not a <code>char(*)[20]</code> or a <code>char**</code>.</p></li>
<li><p>You have</p>

<pre><code>char *set,kill,zwrite;
</code></pre>

<p>which declares a <code>char*</code> <code>set</code> and two <code>char</code>s <code>kill</code> and <code>zwrite</code>. It should be something like</p>

<pre><code>char set, kill, zwrite;
</code></pre>

<p>because you want to input characters, not strings. That's why the last three <code>scanf</code>s in problem #1 use a <code>%c</code>.</p></li>
</ol>
",2
32953514,32946071,0,"<p>you are accessing an uninitialized arrays rights[] and user_list[]; 
use malloc to allocate memory for them, or define the boundaries. 
for examle:</p>

<pre><code>struct usr_rights{
    char *username;/*user name*/
    struct rights_on_cmd rights[3]; /* &lt;&lt; HERE */
};
struct rights_on_gbl{
    char *gbl_name;
    struct usr_rights user_list[3]; /* &lt;&lt; and HERE*/
};
</code></pre>
",4
32954361,32946071,0,"<p>you have buffer over flow in parts of your code, the behavior of you program yet is unpredictable.</p>

<p>check the boundaries of these</p>

<pre><code>user.rights[0] = set_cmd;
user.rights[1] = kill_cmd;
user.rights[2] = zwrite_cmd;
gbl.user_list[j] = user;
</code></pre>
",0
32990471,32990416,2,"<p><strong>1.</strong> In <code>struct Class</code> -  </p>

<pre><code>struct Student students[ ];
 /*                     ^ you haven't given any size .  */
</code></pre>

<p>You need to give number of elements as you use it as operand to <code>sizeof</code> . Example -</p>

<pre><code>struct Student students[5];    // give any desired size 
</code></pre>

<p><strong>2.</strong> Also in your function <code>int countStdInClass</code>-</p>

<pre><code>int sizeOfStd = sizeof(classA-&gt;students)/sizeof(classA-&gt;students[0])
 /*                                                                 ^ ; missing   */
</code></pre>
",6
32990791,32990416,0,"<p>The C standard explicitly states (6.7.2.1) that a flexible array member isn't counted when taking the <code>sizeof</code> the struct:</p>

<blockquote>
  <p>In particular, the size of the structure is as if the flexible array
  member were omitted except that it may have more trailing padding than
  the omission would imply.</p>
</blockquote>

<p>It only makes sense to use flexible array members if you allocate memory dynamically. And as for all other cases of dynamic memory, it doesn't make any sense to use the <code>sizeof</code> operator on the allocated segment.</p>

<p>When using the flexible array member <code>students</code>, you have to allocate memory as:</p>

<pre><code>struct Class* c = malloc( sizeof(*c) + n*sizeof(struct Student) );
</code></pre>

<p>Meaning you already know the size! It is <code>n*sizeof(struct Student)</code>.</p>
",0
27146270,27146203,2,"<p>because when you do</p>

<pre><code>w=SUM(b++);
</code></pre>

<p>the macro will be replaced by:</p>

<pre><code>w= b++ + b++;
</code></pre>

<p>now, if <code>b=5</code> then you do twice <code>b++</code> and get <code>b=7</code></p>

<h2>Edit</h2>

<p>after reading MSalters comment i did some searching and found out that as he said this code couse UB.</p>

<p><a href=""https://www.securecoding.cert.org/confluence/display/seccode/EXP30-C.+Do+not+depend+on+the+order+of+evaluation+for+side+effects"" rel=""nofollow"">as says here</a>:</p>

<blockquote>
  <p>If a side effect on a scalar object is unsequenced relative to either
  a different side effect on the same scalar object or a value
  computation using the value of the same scalar object, the behavior is
  undefined. If there are multiple allowable orderings of the
  subexpressions of an expression, the behavior is undefined if such an
  unsequenced side effect occurs in any of the orderings.</p>
</blockquote>
",7
33023986,12831486,-2,"<p>After you compile the program by using make ""your program name"" (like make mario in this case), then just use ./""your program name"" (this case ./mario). DO NOT add .c when running the program.</p>
",2
32436460,15192441,-1,"<p>Refer to the sample code to understand:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;

void myThread(void* ptr) {
    printf(""Hello in thread\n"");
    int i=0;    
    for(;i&lt;10;i++)
    {
        sleep(1);
        printf("". "");
        fflush(stdout);  //comment this, to see the difference in O/P
    }
    printf(""sleep over now\n"");
}

int main(void) {
    pthread_t tid;
    printf(""creating a new thread\n"");
    pthread_create(&amp;tid, NULL, (void*)myThread, 0);
    printf(""going to join with child thread..\n"");
    pthread_join(tid, NULL);
    printf(""joined..!!\n"");
    return 0;
}
</code></pre>

<p><a href=""http://cboard.cprogramming.com/c-programming/118404-printf-refresh-screen.html"" rel=""nofollow"">Reference Blog</a></p>
",0
32938696,32938665,2,"<p>In your code, <code>p1</code>, <code>p2</code> and <code>p3</code> are all <em>pointers to integers</em>, not integers.</p>

<p>To get what you want, you probably want:</p>

<pre><code>*p3 - *p2 - *p1;
</code></pre>

<p>where the <code>*</code> operator is the <a href=""https://en.wikipedia.org/wiki/Dereference_operator"" rel=""nofollow""><em>dereference operator</em></a>. It dereferences pointers, so in this case <code>*p3</code> etc are of type <code>int</code>. You can think of it as the inverse of the <code>&amp;</code> address-of operator.</p>
",0
32938714,32938665,3,"<p>You are doing address arithmetic. Given operator precedence, it is evaluating <code>p1-p2-p3</code> as <code>(p1-p2)-p3</code>. <code>p1-p2</code> yields not an address but an integer. Then you are attempting to subtract an address from an integer, which isn't valid. You could do <code>p1-(p2-p3)</code>, then it's taking <code>p2-p3</code>, yielding an integer, and subtracting that as an integer offset from an address (<code>p1</code>), which will compile. However, [Thanks to @EOF for this reference in his comment] such subtraction (of integer from a pointer) would only be valid if it points somewhere within the allocation for <code>p1</code>. It's subject to the C11 standard described specifically in section 6.5.6, excerpted below:</p>

<blockquote>
  <p>When an expression that has integer type is added to or subtracted
  from a pointer, the result has the type of the pointer operand. If the
  pointer operand points to an element of an array object, and the array
  is large enough, the result points to an element offset from the
  original element such that the difference of the subscripts of the
  resulting and original array elements equals the integer expression.
  In other words, if the expression P points to the i-th element of an
  array object, the expressions (P)+N (equivalently, N+(P)) and (P)-N
  (where N has the value n) point to, respectively, the i+n-th and
  i?n-th elements of the array object, provided they exist. Moreover, if
  the expression P points to the last element of an array object, the
  expression (P)+1 points one past the last element of the array object,
  and if the expression Q points one past the last element of an array
  object, the expression (Q)-1 points to the last element of the array
  object. If both the pointer operand and the result point to elements
  of the same array object, or one past the last element of the array
  object, the evaluation shall not produce an overflow; otherwise, the
  behavior is undefined. If the result points one past the last element
  of the array object, it shall not be used as the operand of a unary *
  operator that is evaluated.</p>
</blockquote>
",5
21046533,21046532,1,"<p>My C is a little rusty, however....</p>

<p>On the assumption that argv[] is going to be available for the duration of your script, you don't need to strdup strings if they are not going to be changed. After you allocate the memory (remembering to add more to argc if you want to add extra parameters), you should just be able to memcpy. Your new_argv will point to the same strings as your original argv, so you will need to strdup before you change it (or not, if you want to set it to some other string). </p>

<p>I think you need to have a close look at your loop, <code>for (m=0, tmp..</code> - for a start, I don't think m is used anywhere else; second, you are testing <code>*argv != 0</code>, but not changing *argv in the loop, so it will run forever or not at all, and third, at the start of this loop, all your new_argv are null pointers, so <code>*tmp = strdump(*tmp);</code> will try to duplicate a string at memory address 0, having nothing to do with argv?</p>
",1
22503832,22503755,0,"<p>Why don't you have an array of three <code>analyzer_t</code> in your <code>analyzers_t</code>, then you can iterate the array an call the same function for each.</p>
",3
22504071,22503755,0,"<p>Do the common stuff in function and pass only the differing information:</p>

<pre><code>void writeAnalyzer(analyzer_t * analyzer, char * name, char * dir) {
    if (analyzer-&gt;StartPosition &gt; 10)
        writeFile(name, analyzer-&gt;buff, &amp;analyzer-&gt;StartPosition, dir);
}
</code></pre>

<p>And don't use suffix <code>_t</code> with custom types. Those are reserved for standard C library.</p>
",3
31251520,31251421,9,"<pre><code>a++&gt;2
</code></pre>

<p>will return false, since 2 is not greater than 2 (remember, <code>a++</code> means the old value of <code>a</code> will be returned, not the incremented value). Also, <code>a</code>is now worth 3.</p>

<p>Since the <code>&amp;&amp;</code> operator is short-circuiting, the <code>--b&lt;3</code> part will not be evaluated, so <code>b</code> is still worth 3.</p>

<p>The variable <code>x</code> remains unchanged because the conditional was false.</p>

<p>So you do get ""3 3 1""</p>
",0
31251535,31251421,4,"<p><code>a++&gt;2</code> is false, and because of short-circuiting, <code>--b&lt;3</code> is never evaluated. <code>a++&gt;2</code> is false because <code>a</code> is initially <code>2</code>, and <code>2</code> is not greater than <code>2</code>. As a side effect, though, <code>a</code> has become <code>3</code>. Because the condition was false, <code>x</code> is unchanged. Thus the final values of <code>b</code> and <code>x</code> are the same as their initial values, while <code>a</code> has been incremented.</p>
",0
31251543,31251421,4,"<p>No. Your code explained:</p>

<pre><code>if(a++&gt;2) // a = 2, so 2 &gt; 2? No. 
// So the other condition WILL NOT be checked (--b&gt;3), because it's an &amp;&amp; condition.
</code></pre>

<p>But, <strong>a++</strong> increments the 'a', <strong>AFTER</strong> the expression. So now:</p>

<pre><code>a = 3
b = 3
</code></pre>

<p>The code doesn't enter into the if block. So 'x' will never be changed. Then:</p>

<pre><code>a = 3
b = 3
x = 1
</code></pre>

<p>If you did:</p>

<pre><code>if(++a&gt;2 ... 
</code></pre>

<p>The <strong>++a</strong> increments <strong>BEFORE</strong> the expression. So 'a' would be 3 and the if would check '3 > 2'.</p>
",1
31251638,31251421,3,"<p>The post-increment will be resolved first, then the comparation. That is because of the Operator Precedence Rules.</p>

<p>If you have two operator with different priority, the one with the greater priority will be invoked first, then the other one. If two operator have the same priority, they will be solved according to the corresponding associativity rule.</p>

<p>You can check operators priority and associativity rules in the next link:</p>

<p><a href=""http://en.cppreference.com/w/c/language/operator_precedence"" rel=""nofollow"">http://en.cppreference.com/w/c/language/operator_precedence</a></p>
",0
28195832,18933410,-1,"<p>When we run the C programme as</p>

<pre><code>#include&lt;stdio.h&gt;
void main() {
    printf(""hello"");
}
</code></pre>

<p>then the compiler creates only <code>.bak</code> file. We can also get the source file from the <code>.bak</code> file.</p>
",0
21582763,21582543,4,"<p><code>scanf(""%c"", ...)</code> will read any character from the input, including a newline character. So if you press <code>a&lt;enter&gt;b&lt;enter&gt;</code>, the first <code>scanf</code> will get <code>'a'</code>, the second will get a newline character, and the third will get <code>'b'</code>.</p>

<p>In your case, the second time <code>scanf</code> is called, it will immediately return with a newline, which will then cause the loop to execute a third time.</p>

<p>One way to fix this is to add a space before the <code>%c</code>: <code>scanf("" %c"", ...)</code>. This will cause <code>scanf</code> to skip all whitespace (including newlines) before reading the character.</p>
",8
21583012,21582543,1,"<p><code>scanf(""%c"");</code> reads the newline character from the <code>ENTER</code> key. When you type a char <code>a</code>, you type <code>a</code> followed by <code>ENTER</code> key too. Now there are two chars in the input buffer. Since the newline char is still in the input buffer, you get the string <code>type a character</code> two times. </p>

<p>Its suggested not to use scanf, and reasons are stated here <a href=""http://c-faq.com/stdio/scanfprobs.html"" rel=""nofollow"">Why does everyone say not to use scanf? What should I use instead?</a>. </p>

<p>Alternatively you can use, </p>

<pre><code>while((c = getchar()) != '\n' &amp;&amp; c != EOF)
</code></pre>

<p>to read the character &amp; getting rid of newline.  </p>
",1
31819745,31094516,0,"<p>There are only two situations in which the Standard allows a pointer value to point to something other than a valid object:</p>

<ol>
<li><p>A <code>null</code> pointer value doesn't point to anything.  Null pointers may be copied, and may be compared using the <code>==</code> or <code>!=</code> operators.  Use of the additive, subtractive, or relational operators on a null pointer; use of a dereferencing operator will yield Undefined Behavior except in some cases where it does neither requests an actual dereferencing operator nor pointer arithmetic [e.g. <code>sizeof *p</code> is legal even when <code>p</code> is null].</p></li>
<li><p>For any object, it is possible to have a pointer to that object, or a pointer ""one past"" that object; adding one to the former will yield the latter, and subtracting one from the latter will yield the former.  Use of the <code>==</code> or <code>!=</code> operators on a ""one-past"" pointer and a pointer to a different object may sometimes report them as equal, even in cases where accesses made using the pointer to the other object would be legitimate and accesses made with the ""one-past"" pointer would trigger Undefined Behavior.</p></li>
</ol>

<p>Your code attempts to generate a pointer which doesn't point to any valid object, and does not fit any of the described behavioral categories.  Note that it would be possible and legitimate to create a pointer to an ""array"" of N elements such that valid subscripts ranged from K-N to K-1, for any K ranging from 0 to N inclusive (given an array of N objects, it's possible to generate a pointer to any of the N objects, or a pointer ""one-past"" the last one, for a total of N+1 valid pointer values).  A pointer just before the first object would not be valid, however.</p>
",0
21173672,21173549,5,"<p>If <code>x</code> is a pointer to <code>char</code> (and points to an existing object), then the declaration <code>char *g = &amp;(*x++);</code> is allowed in standard C and has defined behavior.</p>

<p>The result of the <code>*</code> operator is an lvalue, per C 2011 6.5.3.2 4, so its address may be taken with <code>&amp;</code>.</p>

<p>In detail:</p>

<ul>
<li><code>x++</code> increments <code>x</code> and produces the original value of <code>x</code>. (Note: Incrementing a pointer requires that the pointer point to an object. It does not require that it be an array element or that there be another object after it; you are allowed to increment to point one past an object, as long as you do not then dereference a pointer to a non-existent object.)</li>
<li><code>*x++</code> dereferences the pointer (the original value of <code>x</code>). The result is an lvalue.</li>
<li><code>&amp;(*x++)</code> takes the address of the lvalue, which is the original value of <code>x</code>.</li>
<li>Then this value is used to initialize <code>g</code>.</li>
</ul>

<p>Additionally, C 2011 6.5.3.2 3 specifies that the combination of <code>&amp;</code> and <code>*</code> cancel, except that the result is not an lvalue and the usual constraints apply, so the <code>&amp;</code> and <code>*</code> operations are not actually evaluated. Thus, this statement is the same as <code>char *g = x++;</code>.</p>
",7
21173863,21173549,1,"<p>Just as a hint: Are you aware that you are shadowing the outer x variable?</p>

<p>What you are currently doing is:</p>

<pre><code>char *x = ""1234""; //declare c style string
while(*x != '\0'){ //for the conditional the ""outer"" x will be used for comparsion
    char tmp = *x++; //increment x to point to whatever comes sizint atoi (const char * str);eof(char) bytes afterwards; dereference what x previously pointed to (postfix ++) and save it in local char tmp
    char *x = &amp;tmp; //take adress of the local char and save its adress in a new local/inner char*
    int t = atoi(x); //call atoi on the inner x
</code></pre>

<p>Although this may work it may be confusing style to shadow variables like this. (Confusing for other developers especially)</p>

<p>Also take a look at the signature of atoi:</p>

<pre><code>int atoi (const char * str);
</code></pre>

<p>Here you can see that you can safely pass the pointer like this:</p>

<pre><code>int t = atoi(&amp;x);
++x; 
</code></pre>

<p>Or preferably:</p>

<pre><code>int t = atoi(&amp;x++);
</code></pre>
",1
33028549,15513465,0,"<p>Here is a simple implementation of <code>getchar()</code>:</p>

<pre><code>int mygetchar(void)
{
        static char buf[BUFSIZ];
        static char *bufp = buf;
        static int i = 0;

        if (i == 0)
        {
                i = read(0, buf, 1);
                bufp = buf;
        }
        if ( --i &gt;= 0 )
        {
                return  *bufp++;
        }

        return EOF;
}
</code></pre>
",0
23852082,23851098,9,"<p>The Exercise 32 code downloaded from the github repo is platform specific for a BSD  system (and perhaps OS X).  Specifically, there are a couple required symbols for a successful build that are present on a BSD sysem, but which are most likely not present on a (Linux) Ubuntu 12.04 system.  These include:</p>

<pre><code>mergesort
heapsort
</code></pre>

<p>Nevertheless, the library and unit tests can all be successfully compiled, with the exception of one unit test that (eventually) will require the above symbols.  Moving the single problematic test from the <code>tests</code> directory will allow the other tests to compile on a (Linux) SuSE SLES 11 system, if a slight change is made to a flaw in the makefile shown below. </p>

<p>After downloading the source mentioned in the question:</p>

<pre><code>.../liblcthw-master&gt; ll
total 28
drwxr-xr-x 2 mahonri users 4096 May 24 21:30 bin
drwxr-xr-x 2 mahonri users 4096 May 24 21:53 build
-rw-r--r-- 1 mahonri users 1548 May  8  2012 LICENSE
-rw-r--r-- 1 mahonri users 1139 May  8  2012 Makefile
-rw-r--r-- 1 mahonri users 1069 May  8  2012 README.md
drwxr-xr-x 3 mahonri users 4096 May 24 21:52 src
drwxr-xr-x 2 mahonri users 4096 May 24 21:53 tests
</code></pre>

<p>Flaws can be found in <code>Makefile</code>.  Here is the flawed portion of the <code>Makefile</code>, as downloaded:</p>

<pre><code># The Unit Tests
.PHONY: tests
tests: CFLAGS += $(TARGET)
tests: $(TESTS)
       sh ./tests/runtests.sh
</code></pre>

<p>One issue is that placing the value of $(TARGET) <code>build/liblcthw.a</code> in the end of CFLAGS doesn't work.  This is due to CFLAGS targeting the compiler, not the linker.  Hence, the resulting 'tests' targets are not linked with the library.</p>

<p>Another issue is that at least one of the 'test' applications requires a math library.</p>

<p>To fix these issues, the <code>Makefile</code> must be modified to something similar to the following:</p>

<pre><code># The Unit Tests
.PHONY: tests
tests: LDLIBS += -lm -L./build -llcthw
tests: $(TESTS)
       sh ./tests/runtests.sh
</code></pre>

<p>To build <code>liblcthw.a</code>, and build the 'test' applications, run <code>make</code> against the updated <code>Makefile</code> in this directory:</p>

<pre><code>.../liblcthw-master&gt; ll
total 28
drwxr-xr-x 2 mahonri users 4096 May 24 21:30 bin
drwxr-xr-x 2 mahonri users 4096 May 24 21:53 build
-rw-r--r-- 1 mahonri users 1548 May  8  2012 LICENSE
-rw-r--r-- 1 mahonri users 1139 May  8  2012 Makefile
-rw-r--r-- 1 mahonri users 1069 May  8  2012 README.md
drwxr-xr-x 3 mahonri users 4096 May 24 21:52 src
drwxr-xr-x 2 mahonri users 4096 May 24 21:53 tests
.../liblcthw-master&gt; make
cc -g -O2 -Wall -Wextra -Isrc -rdynamic -DNDEBUG  -fPIC   -c -o src/lcthw/bstree.o src/lcthw/bstree.c
cc -g -O2 -Wall -Wextra -Isrc -rdynamic -DNDEBUG  -fPIC   -c -o src/lcthw/bstrlib.o src/lcthw/bstrlib.c
cc -g -O2 -Wall -Wextra -Isrc -rdynamic -DNDEBUG  -fPIC   -c -o src/lcthw/darray_algos.o src/lcthw/darray_algos.c
src/lcthw/darray_algos.c: In function ¡®DArray_heapsort¡¯:
src/lcthw/darray_algos.c:12: warning: implicit declaration of function ¡®heapsort¡¯
src/lcthw/darray_algos.c: In function ¡®DArray_mergesort¡¯:
src/lcthw/darray_algos.c:17: warning: implicit declaration of function ¡®mergesort¡¯
cc -g -O2 -Wall -Wextra -Isrc -rdynamic -DNDEBUG  -fPIC   -c -o src/lcthw/darray.o src/lcthw/darray.c
cc -g -O2 -Wall -Wextra -Isrc -rdynamic -DNDEBUG  -fPIC   -c -o src/lcthw/hashmap_algos.o src/lcthw/hashmap_algos.c
cc -g -O2 -Wall -Wextra -Isrc -rdynamic -DNDEBUG  -fPIC   -c -o src/lcthw/hashmap.o src/lcthw/hashmap.c
cc -g -O2 -Wall -Wextra -Isrc -rdynamic -DNDEBUG  -fPIC   -c -o src/lcthw/list_algos.o src/lcthw/list_algos.c
cc -g -O2 -Wall -Wextra -Isrc -rdynamic -DNDEBUG  -fPIC   -c -o src/lcthw/list.o src/lcthw/list.c
cc -g -O2 -Wall -Wextra -Isrc -rdynamic -DNDEBUG  -fPIC   -c -o src/lcthw/radixmap.o src/lcthw/radixmap.c
cc -g -O2 -Wall -Wextra -Isrc -rdynamic -DNDEBUG  -fPIC   -c -o src/lcthw/ringbuffer.o src/lcthw/ringbuffer.c
cc -g -O2 -Wall -Wextra -Isrc -rdynamic -DNDEBUG  -fPIC   -c -o src/lcthw/sarray.o  src/lcthw/sarray.c
src/lcthw/sarray.c: In function ¡®SuffixArray_create¡¯:
src/lcthw/sarray.c:71: warning: implicit declaration of function ¡®qsort_r¡¯
cc -g -O2 -Wall -Wextra -Isrc -rdynamic -DNDEBUG  -fPIC   -c -o src/lcthw/stats.o src/lcthw/stats.c
cc -g -O2 -Wall -Wextra -Isrc -rdynamic -DNDEBUG  -fPIC   -c -o src/lcthw/tstree.o src/lcthw/tstree.c
ar rcs build/liblcthw.a src/lcthw/bstree.o src/lcthw/bstrlib.o src/lcthw/darray_algos.o src/lcthw/darray.o src/lcthw/hashmap_algos.o src/lcthw/hashmap.o src/lcthw/list_algos.o src/lcthw/list.o src/lcthw/radixmap.o src/lcthw/ringbuffer.o src/lcthw/sarray.o src/lcthw/stats.o src/lcthw/tstree.o
ranlib build/liblcthw.a
cc -g -O2 -Wall -Wextra -Isrc -rdynamic -DNDEBUG     tests/bstree_tests.c  -L./build -llcthw -o tests/bstree_tests
cc -g -O2 -Wall -Wextra -Isrc -rdynamic -DNDEBUG     tests/bstr_tests.c  -L./build -llcthw -o tests/bstr_tests
cc -g -O2 -Wall -Wextra -Isrc -rdynamic -DNDEBUG     tests/darray_algos_tests.c  -L./build -llcthw -o tests/darray_algos_tests
...
</code></pre>

<p>Then, the makefile continues on to run the test executables:</p>

<pre><code>sh ./tests/runtests.sh
Running unit tests:
----
RUNNING: ./tests/bstree_tests
ALL TESTS PASSED
Tests run: 5
tests/bstree_tests PASS
tests/bstr_tests PASS
----
RUNNING: ./tests/darray_tests
ALL TESTS PASSED
Tests run: 8
tests/darray_tests PASS
----
RUNNING: ./tests/hashmap_algos_tests
ALL TESTS PASSED
Tests run: 4
tests/hashmap_algos_tests PASS
----
RUNNING: ./tests/hashmap_tests
ALL TESTS PASSED
Tests run: 5
tests/hashmap_tests PASS
----
RUNNING: ./tests/list_algos_tests
ALL TESTS PASSED
Tests run: 2
tests/list_algos_tests PASS
----
RUNNING: ./tests/list_tests
ALL TESTS PASSED
Tests run: 6
tests/list_tests PASS
----
RUNNING: ./tests/queue_tests
ALL TESTS PASSED
Tests run: 3
tests/queue_tests PASS
----
RUNNING: ./tests/radixmap_tests
ALL TESTS PASSED
Tests run: 1
tests/radixmap_tests PASS
----
RUNNING: ./tests/ringbuffer_tests
ALL TESTS PASSED
Tests run: 3
tests/ringbuffer_tests PASS
----
RUNNING: ./tests/sarray_tests
./tests/runtests.sh: line 3:  1033 Segmentation fault      $VALGRIND ./$i 2&gt;&gt;  tests/tests.log
ERROR in test tests/sarray_tests: here's tests/tests.log
------
DEBUG tests/ringbuffer_tests.c:60: ----- RUNNING: ./tests/ringbuffer_tests
DEBUG tests/ringbuffer_tests.c:53: 
----- test_create
DEBUG tests/ringbuffer_tests.c:54: 
----- test_read_write
DEBUG tests/ringbuffer_tests.c:55: 
----- test_destroy
DEBUG tests/sarray_tests.c:46: ----- RUNNING: ./tests/sarray_tests
DEBUG tests/sarray_tests.c:39: 
----- test_create
make: *** [tests] Error 1
</code></pre>

<hr>

<p><b>NOTE:</b> The same flaw didn't seem to impact an OS X 8 build (which is a puzzlement to myself).  A separate flaw has to be fixed in the OS X 8 version of the build. Specifically, the following line in <code>list_algos.c</code>:</p>

<pre><code>...

inline List *List_merge(List *left, List *right, List_compare cmp)
{
   List *result = List_create();
...
</code></pre>

<p>The inline function requires a function prototype.  Change to the following:</p>

<pre><code>...

extern List *List_merge(List *left, List *right, List_compare cmp);
inline List *List_merge(List *left, List *right, List_compare cmp)
{
   List *result = List_create();
...
</code></pre>

<p>After this single modification, the OS X version was able to <code>make</code> successfully.</p>
",5
22447570,22447302,0,"<p>Do I understand correctly that your file looks like</p>

<pre><code>327            // number of lines
1 2 3          // line 1
33 44 55       // line 2 
</code></pre>

<p>... repeats until 327 lines have been printed, all with 3 elements? Note that the line breaks would be optional and could be any whitespace.</p>

<p>The canonical way to read a number from text in C is using scanf. scanf uses, like printf, a weird looking format string as the fist parameter. Each basic type has a letter associated with it, for integers it's d or, more intuitively, i. These letters are prefixed with a %. So to read an integer, you would write <code>scanf(""%d"", &amp;lines);</code> if lines is an int holding the number of lines. (Do rather not use x, for readability).</p>

<p>The way you allocate your array is correct (provided x holds the number of lines and 10 is the known line length). One style issue is that the 10 should be #defined as a macro so that you can use e.g. malloc(LINE_LEN*sizeof(int)). That helps later when that number should ever change and you have (in a real world program) scattered references to m over several source files.</p>

<p>If this is just a little program and the array isnt't inordinately large and does not need to live longer than the function call (which, in the case of main(), may be long enough in any case), the easiest would be to use a variable size array in C; provided you use a modestly modern compiler:</p>

<pre><code>#define LINE_LEN 10
int lineCount;
scanf(""%d"", &amp;lineCount);
int m[lineCount][LINE_LEN];
// fill from file
</code></pre>

<p>If you compile with gcc you'll probably need to specify ""-std=c99"" as a command line option for that.</p>
",4
22447690,22447302,0,"<p>First off fgetc() returns an integer, so casting it as an int will do nothing.  Second you're only reading in one integer at a time with fgetc() so you will have a 1 digit number in x.</p>

<p>Your array allocation looks correct, but you can also allocate the columns as an array of int * on the stack and then allocate the rows dynamically as m[i] = (int*)malloc(x*sizeof(int)); from i = 0->9</p>
",1
22447406,22447302,0,"<p>You can design a list and dynamically insert your rows.</p>
",0
22432853,22432715,1,"<p>I tried your program, when <code>n = 1</code>, the program would output <code>OK</code> and <code>ERROR</code>. The statement in <code>while</code> should be changed to:</p>

<pre><code>}while(n&gt;0);
</code></pre>

<p>And if the input <code>n</code> is above than 1, you should move the <code>scanf</code> statement into <code>while</code> loop:</p>

<pre><code>scanf(""%d"",&amp;n);
do{
fflush(stdin);
scanf(""%c%d"",&amp;c,&amp;number);
</code></pre>

<p>Hope that help. </p>

<p>One more thing, <code>debugger</code> is always your best friend, please spend more time to <code>debug</code>, it would give you the best answer most of the time. </p>
",3
29197265,29197127,0,"<p>Try using more simple functions:</p>

<pre><code>double              floattime (void)
{
    struct timeval  t;

    if (gettimeofday (&amp;t, (struct timezone *)NULL) == 0)
        return (double)t.tv_sec + t.tv_usec * 0.000001;
    return (0);
}

int main(int argc, char **argv) {
    double begin;
    begin = floattime();

    getchar ();
    printf(""Time: %.2f"", floattime () - begin);
    return 0;
 }
</code></pre>

<p>And don't forget to wait some time before calculating time execution. Else, it will always return 0.00s.</p>
",0
29197349,29197127,1,"<p>You could do something like this instead:</p>

<pre><code>#include &lt;time.h&gt;
#include &lt;stdio.h&gt;

int main() {
  clock_t begin, end;
  int i = 1e8;

  begin = clock();
  while(i--);
  end = clock();

  printf(""Time: %.2f\n"", (double) (end-begin)/CLOCKS_PER_SEC);
}
</code></pre>

<p>The <code>clock()</code> function counts processor clock cycles.  By dividing it by <code>CLOCKS_PER_SEC</code> you get seconds.  The code above counts the time it takes to iterate 1e8 down to 0.</p>
",0
24645287,24645208,0,"<p>When you write like this</p>

<pre><code>int total = 0, values = 0;
char *string = (char*) &amp;values;
</code></pre>

<p>You set the pointer string to point to the integer value <code>values</code> so if the user enters a value that is larger than <code>sizeof(values)</code> i.e. sizeof(int), the program will crash.</p>

<p>Instead use a dedicated buffer for the input string</p>

<p><code>char string[128] = {0};</code></p>

<p>scanf can be used for input but it is safer to use fgets() to minimize the risk of a buffer overrun:</p>

<p><code>fgets( string, sizeof(string), stdin );</code></p>

<p>if you need to hold the individual values entered declare an array of ints e.g.</p>

<p><code>int values[100];</code></p>

<p>when the user has enters something check the content of 'string' and see if it
contains compute - it may be enough checking the first char - e.g. <code>if ( string[0] == 'c' )</code> else convert the string to int and place it in the array of values:</p>

<p><code>values[i++] = atoi(string);</code></p>

<p>EDIT:</p>

<p>As McNabb pointed out fgets() adds a \n to the string so if you want to compare the whole string you must take that into account e.g.</p>

<pre><code>if ( !strncmp( ""compute"", string, strlen(""compute"") ) 
{...}
</code></pre>
",4
24645288,24645208,0,"<p>The most efficient method would be to read in a string (use <code>fgets()</code>), then try to decide what it is.  If it's an integer, you can use <code>atoi</code> or <code>strtol</code> to convert it.  If it's a float, you can use <code>strtod</code>.  Otherwise, you can parse the string however you want.</p>

<p>So you'll end up with something like this:</p>

<pre><code>char str[15];
long sum = 0, val;
char* ptr;
while (1)
{
    fgets(str, 15, stdin);
    if (0 == strcmp(str, ""compute""))
    {
        printf(""sum: %d\n"", sum);
        break;
    }
    val = strtol(str, &amp;ptr, 10);
    // error-check here.
   sum += val;
}
</code></pre>

<p>Another, simpler option, might be to read integers (using <code>scanf</code>, as in your code above) until end-of-file, then print the sum.  That approach has some limitations: you need to give your input through some channel that has a defined EOF, and you can't receive more input after the end of your list of integers.  Use a specific value (such as 0) as a sentinel, as Havenard suggested, does not have these drawbacks, but doesn't allow the sentinel value to appear in your list of numbers either.</p>
",0
24645330,24645208,0,"<p>To read a string you have to allocate some space for it. You cannot read it into an integer.</p>

<p>To support reading input that could be either an integer or a string, you have to read a string; and then you can try to convert the string to integer.</p>

<p>For example:</p>

<pre><code>char buffer[50];
scanf(""%49s"", buffer);

if ( 0 == strcmp(buffer, ""compute"") )
    return 0;    // they typed ""compute""

if ( 0 == sscanf(buffer, ""%d"", &amp;number) )
    break;       // they typed something that was not a number

total += number;
</code></pre>
",0
24645505,24645208,0,"<p>Not sure why are you trying to compare strings at this point.  If you just want to read whitespace separated integers until a non-integer value is entered, let scanf do the work for you:</p>

<pre><code>int menu(int choice){
  int total = 0;
  int value;
  switch(choice){
    case 1: printf(""Enter your values separated by a whitespace: "");
      while(scanf(""%d"",&amp;value) &gt; 0) {
        total += value;
      }
  }
  /* Here, use scanf to get the first non-integer value entered */
  return total;
}
</code></pre>
",0
29501131,29500959,3,"<p>There are two ways to analyze code for problems - static analysis and run-time analysis.  Static analysis reads the code - this is what compilers do really well.  Run-time analysis for code problems happens when the code is linked against another set of libraries that see what the code actually does  as it runs under surveillance.  Finding memory leaks is difficult for static analysis but not for a run-time analysis package.</p>

<p>Other run-time analyses are things like code coverage - does all parts of your code run?  gcov does this, like valgrind and electric fence look for memory problems like leaks.</p>

<p>So, no, there are no really good compiler safeguards for testing memory leaks.</p>
",0
29501947,29500959,0,"<p>There is <code>-fsanitize=leak</code> GCC flag.</p>

<p>It overrides <code>malloc</code>/<code>calloc</code>/<code>free</code> to make them count allocated and freed blocks of memory.<br>
If your program is compiled with this flag, it prints information about detected leaks to the terminal after execution.</p>

<p>You can read about it <a href=""https://gcc.gnu.org/onlinedocs/gcc/Debugging-Options.html"" rel=""nofollow"" title=""here"">here</a> and <a href=""https://code.google.com/p/address-sanitizer/wiki/LeakSanitizer"" rel=""nofollow"" title=""here"">here</a>.
<hr>
Also, I have never used it, so this answer is completely based on GCC manual.</p>
",4
22491657,22491578,2,"<p>It looks like a buffer overrun of <code>dmpfilename</code>. You allocated an array of length 32. You then format it with <code>""InstrumentList_FULL.csv_%.*s""</code>. That's 24 characters, plus 15 for the filename, plus a null terminator. That's more than 32. </p>

<p>Increase the size of the buffer.</p>

<p>Oh, and <code>dmpParams_t</code> is, er, rather large. Perhaps there's a stack overflow when you allocate one of those as a local.</p>

<p>Some other comments:</p>

<ol>
<li>You could usefully use <code>const</code> a bit more.</li>
<li>Declaring <code>size</code> as <code>size_t*</code> in the struct is a bit odd. You pass the address of the struct to <code>g_tree_foreach</code>. I'd declare <code>size</code> as <code>size_t</code> and let <code>g_tree_foreach</code> modify the value.</li>
<li>Likewise, it seems odd that you pass the address of <code>size</code> to <code>writeFile</code>. Again a const value seems to make more sense.</li>
</ol>
",0
22479053,22478403,0,"<p>The integer pointer variable p is already initialized. In the while loop this reference is checked to see whether the array holds the four numbers.</p>

<pre><code>  while ( p &lt; (&amp;a[0][0]+4) &amp;&amp; scanf(""%d"",p++) );
</code></pre>

<p>the actual code is</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;

int main()
{
   int a[2][2],*p;
   p = &amp;a[0][0];

   printf(""enter 4 numbers\n"");
   while ( p &lt; (&amp;a[0][0]+4) &amp;&amp; scanf(""%d"",p++) );
   printf(""the numbers are\n"");
   p=&amp;a[0][0];
   while( p &lt; (&amp;a[0][0]+4) &amp;&amp; printf(""%d"",*p++) );
   return 0;
}
</code></pre>
",0
22479171,22478403,1,"<ol>
<li><code>conio.h</code> was used in MS-DOS. Are you using MS-DOS? Probably not. Don't include this header.</li>
<li>Add a <code>{}</code> or <code>;</code> to the end of each <code>while</code> loop. This is proper syntax. Otherwise, you will get a parser error.</li>
<li>While this code will print the four values entered once you fix those issues, it is a convoluted way to teach you about loops. <code>printf</code> will return the number of characters printed. <code>scanf</code> on success, the function returns the number of items of the argument list successfully filled. This count can match the expected number of items or be less (even zero) due to a matching failure, a reading error, or the reach of the end-of-file.</li>
<li><code>&amp;a[0][0]+4</code> are memory addresses. Each time you run this program, you will get different memory addresses. </li>
<li><code>p=&amp;a[0][0]</code> will start <code>p</code> at the beginning to prepare it to print out the values in the next while loop.</li>
</ol>

<p>You can read more on <a href=""https://stackoverflow.com/questions/13554244/how-to-use-pointer-expressions-to-access-elements-of-a-two-dimensional-array-in"">pointer arithmetic of multi-dimensional arrays here</a>.</p>
",0
22107333,14176620,0,"<pre><code>int func(char a, char b, char c) /* DEMONSTRATION that char on stack is promoted to int !!!
                                    note: this promotion is NOT integer promotion of literals, but promotion during handling of the stack. don't confuse the two */
{
  const char *p = &amp;a;
  printf(""a=%d\n""
         ""b=%d\n""
         ""c=%d\n"", *p, p[-(int)sizeof(int)], p[-(int)sizeof(int) * 2]); // don't do this. might probably work on x86 with gcc (but again: don't do this)
}
</code></pre>

<p>The message is <code>va_arg(ap, char)</code> and <code>va_arg(ap, short)</code> is wrong.
Use <code>va_arg(ap, int)</code> instead: it will handle arguments of type int and ""smaller"" type (short, char).</p>

<p>See also <a href=""http://publications.gbdirect.co.uk/c_book/chapter9/stdarg.html"" rel=""nofollow"">http://publications.gbdirect.co.uk/c_book/chapter9/stdarg.html</a>
Quote: "" Take care here to avoid problems which could be caused by arithmetic conversions. Use of char or short as the second argument to va_arg is invariably an error: these types always promote up to one of signed int or unsigned int, and float converts to double.""</p>
",0
26432467,26432102,0,"<p>Firstly, your pow function doesn't know which instance to call. MuzzleVelocity should be double, float or long double. You can just put 
pow float((MuzzleVelocity), 2).</p>

<p>Secondly you don't give any value to range and you use it to calculate angle. I guess you made the mistake and wanted to get range in meters as input and not meters. If I am correct you should change  scanf(""%f"", &amp;meters); to  scanf(""%f"", &amp;range);</p>

<p>Hope that </p>
",0
26432189,26432102,4,"<p>The problem (though you never actually tell us what 'not working' means) is likely that you are assigning the user input to <code>meters</code>:</p>

<pre><code>printf(""Enter the range of Enemy Sub in Meters&gt;"");
scanf(""%f"", &amp;meters);
</code></pre>

<p>But then in your equations, you use the value of <code>range</code>, which has not been set to any value, and will thus have a completely random value in it:</p>

<pre><code>angle = (180/PI)* .5* asin(range / ((pow(MuzzleVelocity, 2))/G));
</code></pre>

<p>Replace <code>range</code> with <code>meters</code> in the equation, or vise-versa in the <code>scanf</code>.</p>
",2
21303426,21295313,2,"<p>In answer to some of the other comments (sorry, can't reply to each of them as I don't have enough rep yet):</p>

<p>In C and C++ the type of an expression doesn't depend on its context. In this case, the type of     <code>-214743648</code> is defined by the language rules,  the fact that you later assign it to a <code>long long</code> doesn't affect this.   </p>

<p>Actually this way of doing things makes the language much simpler than the alternative, it's one of the things that attracted me to C in the first place.</p>

<p>In David Heffernan's example,</p>

<pre><code>x = -2147483648;
std::cout &lt;&lt; x &lt;&lt; std::endl;     // gives 2147483648
x = -2147483649;
std::cout &lt;&lt; x &lt;&lt; std::endl;     // gives 2147483647
</code></pre>

<p>The important thing is that the <code>-</code> sign is NOT part of an integer literal. The expression <code>2147483648</code> is an integer constant whose type is determined according to a set of rules in the standard; and then the unary minus operator is applied to the value (which does not change its type).</p>

<p>Unfortunately, C90, C99, C++98 and C++11 all have different rules for the types of integer literals. Further, the rules are different for decimal constants than for hex or octal constants! You can look them up in the relevant standards documents.</p>

<p>If you have 32-bit ints, then <code>2147483648</code> is too large to be an <code>int</code>. In all dialects the next possible type for it is <code>long int</code>. If you also have 32-bit <code>long ints</code>, then in C99 or C++11 it has type <code>long long int</code>. In C90 or C++98 it has type <code>unsigned long int</code>. (Those languages do not have a <code>long long</code> type). </p>

<p>Back to David Heffernan's example. C++98 does not have <code>long long</code>, so either you're using a C++11 compiler, or using Microsoft extensions. Assuming the latter; who knows what they've decided to do for integer constants, but if they have retained the C++98 definition that <code>2147483648</code> has type <code>unsigned long int</code>, that would explain the results.</p>
",0
29204383,29204307,1,"<p>You could use the <a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/mkdir.html"" rel=""nofollow"">mkdir() UNIX function</a>:</p>

<pre><code>#include &lt;sys/stat.h&gt;
int mkdir(const char *path, mode_t mode);
</code></pre>

<p>But easier would be to use the <a href=""http://unixhelp.ed.ac.uk/CGI/man-cgi?system"" rel=""nofollow"">system() UNIX function</a>:</p>

<pre><code>#include &lt;stdlib.h&gt;
int system(const char *command);
</code></pre>

<p>Something like this might work for you:</p>

<pre><code>#include &lt;stdlib.h&gt;
int main(void) {
   system(""mkdir -p /usr/share/language/mSG"");
   system(""ln -s /usr/share/x.mo /usr/share/language/mSG"");
}
</code></pre>
",1
29204456,29204307,1,"<p>Use the <strong>popen</strong> or <strong>system</strong> api's to run the shell commands through the C code .</p>

<pre><code>FILE *pf;
char command[512];

sprintf(command, ""mkdir -p /usr/share/language/mSG"");

pf = popen(command,""r""); 

if(!pf){
  fprintf(stderr, ""popen failure \n"");
  return;
}
</code></pre>
",0
21313819,21313700,2,"<p>You can use a temporary array of pointers to your arguments, then you can access them through this array of pointers:</p>

<pre><code>void myFunc(int arg1,int arg2,int arg3,int arg4,int arg5,int arg6,n)
{
    int *array_of_args[] = {&amp;arg1, &amp;arg2, &amp;arg3, &amp;arg4, &amp;arg5, &amp;arg6};
    if (n &gt;= 1 &amp;&amp; n &lt;= 6)
        ++*array_of_args[n - 1];
}
</code></pre>

<p>This is not better than your original code, but if your code uses the array-access several times, this hack will make the code smaller.</p>
",2
21313835,21313700,6,"<p>Although as suggested in the comments passing a pointer to an array may be easier. If you really want to go with arguments then your best bet may be to use a variadric function:</p>

<pre><code>void myFunc(int n, ...)
{
    va_list ap;
    int arg;
    va_start(ap, n);
    while (--n)
        arg = va_arg(ap, int); /* Increments ap to the next argument. */
    va_end(ap);

    arg++;

}
</code></pre>
",0
21313869,21313700,4,"<p>I'd do it like this:</p>

<pre><code>void myFunc(int n, ...)
{
    va_list args;
    va_start(args, n);

    int temp;
    for(n; n; --n)
    {
        temp = va_arg(vl, int);
    }

    temp++;
    va_end(args);
}
</code></pre>

<p>A few things to note:</p>

<ul>
<li>This does no handling if n == 0, and will be wrong in that case.</li>
<li>Because C is <em>pass by value</em>, this will increment the variable locally, (as your original function), but the change will NOT take effect outside the function!</li>
</ul>
",0
21313946,21313700,1,"<p>Pass your arguments in as an array. Here I just used literals, but you could replace <code>1,2,3,4</code> with your own variables like <code>arg1, arg2</code>, and so on.</p>

<pre><code>int myNumbers[] = { 1, 2, 3, 4 };
myFunc(myNumbers, sizeof myNumbers / sizeof myNumbers[0]);
</code></pre>

<p>Then, your function needs to be prepared to accept the array. Also, rather than using six if's to check six arguments, we can write a for loop. However, that is entirely unrelated to the question and I understand you may be doing this for a class assignment.</p>

<pre><code>void myFunc(int *args, int numArgs)
{
    int i = 0;
    for(i; i &lt; numArgs; i++)
    {
        if(args[i] == i+1) ++args[i];
    }
}
</code></pre>
",6
31862525,31861781,-1,"<p>Your could try this:</p>

<pre><code>int factorial (int t) /*t = factorial*/
{ 
    int r; /*result*/
    if (t == 1) /*if t = 1 the recursion will end*/
    { 
        return 1; 
    } 
    r = t * factorial(t - 1) ; /*calling the function again with times - 1*/
return r;                      /*will make recursion until t = 1          */
}
</code></pre>

<p>Hope it works.</p>
",3
31862726,31861781,4,"<pre><code>int result;

void factorial(int n)
{
  (result = 1, n &lt;= 1) || (factorial(n - 1), result *= n);
}

int main()
{
   factorial(5);
   printf(""%d\n"", result);
}
</code></pre>

<p>Or, better</p>

<pre><code>void factorial(int *n)
{
  int f;
  (f = 1, *n &lt;= 1) || (f = (*n)--, factorial(n), f *= *n);
  *n = f;
}

int main()
{
   int n = 5;
   factorial(&amp;n);
   printf(""%d\n"", n);
}
</code></pre>

<p>Or, if <code>?:</code> is allowed the last one can be rewritten without that <code>||</code> trickery</p>

<pre><code>void factorial(int *n)
{
  int s;
  *n = *n &lt;= 1 ? 1 : (s = (*n)--, factorial(n), *n * s);
}
</code></pre>
",0
31862808,31861781,0,"<p>I think you are using C in a wrong way, because to use the global variable n is wrong practice. It would have to be a parameter of the function factorial.<br>
Once this issue is fixed, we can handle the problem you are asking for.  </p>

<p>I see unnecessary to restrict ourselves to ""not use"" if-else sentences.<br>
Anyway, it's easy to do it in C, since we have the ternary operator.<br>
For example, the following:  </p>

<pre><code>char c = (3&lt;4)? 'y': 'n';  
</code></pre>

<p>is equivalent to:  </p>

<pre><code>char c;
if (3&lt;4)
  c = 'y';
else
  c = 'n';
</code></pre>

<p>In the case of recursive factorial, we would have:  </p>

<pre><code> int factorial(int n) {
    return (n &lt;= 1)? 1: factorial(n-1);
 }
</code></pre>
",3
31864408,31861781,0,"<p>Using a recursive helper function:</p>

<pre><code>int helperfact(int *m, int *n){
    *n&gt;0 &amp;&amp; ( *m *= (*n)--, helperfact(m, n)); 
}

void fact(int n){
    int m = 1;
    helperfact(&amp;m,&amp;n);
    printf(""%d\n"",m);
}

int main(void){
   fact(10);
   fact(0);
   return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>3628800
1
</code></pre>
",0
31163957,31163900,8,"<p>Whatever you do, <strong>don't</strong> redraw if a returned value is 0: that will introduce statistical bias into the result.</p>

<p>The best thing to do here is to draw between -10 and 1 inclusive and add 1 to any non-negative output.</p>

<p>Finally, call <code>srand</code> <strong>once</strong> else you'll ruin the generator's statistical properties.</p>

<p>(Briefly - since this comment is more for the mathematics site - and restricting the argument to a linear congruential generator, what tends to happen if you omit generated values is that you increase the variance of the resulting distribution so it's no longer uniform. A previously drawn small number will be linearly related to the subsequent drawing as the generator's modulus will have no effect. This autocorrelation - necessary for the resulting distribution to be uniform - of adjacent drawings will be curtailed if drawings are discarded and <em>that</em> increases the sample variance.)</p>
",2
26117262,26117187,1,"<pre><code>scanf_s(""%s"", &amp;answer);
</code></pre>

<p>Should be:</p>

<pre><code>scanf_s(""%c"", &amp;answer); /* answer is a char (not a string) */
</code></pre>

<p>On the other hand:</p>

<blockquote>
  <p>Two different initializations with the same seed will generate the
  same succession of results in subsequent calls to rand.</p>
  
  <p>If seed is set to 1, the generator is reinitialized to its initial
  value and produces the same values as before any call to rand or
  srand.</p>
  
  <p>In order to generate random-like numbers, srand is usually initialized
  to some distinctive runtime value, like the value returned by function
  time (declared in header ). This is distinctive enough for most
  trivial randomization needs.</p>
</blockquote>

<p>Add <code>srand(time(NULL));</code> at the very begin.</p>
",0
26117301,26117187,0,"<p>Your <code>scanf_s</code> is ""scanning"" for a string (<code>%s</code>), not a <code>char</code> (<code>%c</code>).</p>

<p>Use <code>scanf_s(""%c"", &amp;answer)</code> ! :)</p>
",5
26117556,26117187,0,"<p>Instead of</p>

<pre><code>scanf_s(""%s"", &amp;answer);
</code></pre>

<p>Use:</p>

<pre><code>scanf_s("" %c"", &amp;answer);
</code></pre>

<p>As <code>answer</code> is not a string,but is a character.</p>

<p>You also need to change <code>else</code> to <code>else if(answer != 'G')</code> or to <code>else if(answer != good)</code>. <code>rand</code> will also generate the same value. In order to generate random values, you need</p>

<pre><code>srand(time(NULL));
</code></pre>

<p>At the start of <code>main</code>. This is the <a href=""http://www.cplusplus.com/reference/cstdlib/srand/"" rel=""nofollow"">pseudo-random number
generator</a></p>
",0
34088738,34088561,2,"<p>by putting <code>0x00</code> on the beginning of your string <code>b</code>, you essentially created a null-string, since it is terminated in the very first char. you see <code>0x00</code> or <code>'\0'</code> is a string terminator, indicating the end of a string for all c string functions. So <code>strstr()</code> reads only the first char, assumes the string ends there, and since there was nothing there before that, assumes the string is a null-string, and a null string is part of every single string there is.</p>
",5
34088777,34088561,5,"<p>From <code>strstr</code>:</p>

<blockquote>
<pre><code>char *strstr(const char *haystack, const char *needle);
</code></pre>
  
  <p>The <code>strstr()</code> function finds the first occurrence of the substring
  needle in the string haystack.</p>
</blockquote>

<p>Since strings are null-terminated in C and <code>0x00</code> denotes a null byte, <code>b</code> is effectively <code>""""</code>.<br>
Searching for an empty string <strong>always</strong> yields true, so your program will always find the substring.</p>

<p><code>strstr</code>is designed for strings. No string contains <code>0x00</code> as a character, so <code>strstr</code>will not work here. You'll need to write a custom search function like <code>binbin</code>, which seeks binary data in binary data. The function signature might be like this:</p>

<pre><code>unsigned char* binbin(const unsigned char* haystack, size_t haystack_len,
const unsigned char* needle, size_t needle_len);
</code></pre>

<p>A size is passed here because we cannot null-terminate the data.</p>
",0
29200871,27536219,1,"<p>As <a href=""https://stackoverflow.com/users/3439241/brad-s"">Brad. S</a> noted in his <a href=""https://stackoverflow.com/a/27539131/776208"">reply</a>, this is because GActionEntry has a private ""padding"" field, that is not initialized in your code. GCC warns you about that.</p>

<p>However, you can trick GCC by using <strong>designated initializers</strong>. Have a look at <a href=""http://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html"" rel=""nofollow noreferrer"">GCC Warning Options</a>.</p>

<blockquote>
  <p>-Wmissing-field-initializers</p>
  
  <p>This option does not warn about designated initializers, so the following modification does not trigger a warning:</p>

<pre><code>     struct s { int f, g, h; };
     struct s x = { .f = 3, .g = 4 };
</code></pre>
</blockquote>

<p>Designated initializers are useful if you want to initialize only a few fields of a structure. Un-initialized fields will be set to zero, according to the C99 standard.</p>

<blockquote>
  <p>(C99 section 6.7.8.19) ""If there are fewer initializers in a brace-enclosed list than there are elements or members of an aggregate, or fewer characters in a string literal used to initialize an array of known size than there are elements in the array, the remainder of the aggregate shall be initialized implicitly the same as objects that have static storage duration.""</p>
</blockquote>

<p>By using designated initializers, your code could look like that:</p>

<pre><code>static GActionEntry app_entries[] = {
    { .name = ""preferences"", .activate = preferences_activated },
    { .name = ""quit"",        .activate = quit_activated }
};
</code></pre>

<p>Such code won't raise warnings from GCC.</p>

<p>Of course, GCC can't distinguish between the fields you omit on purpose, and the fields you really forgot to initialize. By using this syntax, you'll get no more warnings, you're on your own.</p>

<p>Also, note that designated initializers don't exist in C prior to C99.</p>
",0
27539131,27536219,1,"<p>Looking at the header file /usr/include/glib-2.0/gio/gactionmap.h , we find that <code>GActionEntry</code> is defined as follows: </p>

<pre><code>struct _GActionEntry
{
    const gchar *name;
    void (*activate) (GSimpleAction *action, GVariant *parameter, gpointer user_data);
    const gchar *parameter_type;
    const gchar *state;
    void (* change_state) (GSimpleAction *action, GVariant *value, gpointer user_data);
    /*&lt; private &gt;*/
    gsize padding[3];
};

typedef struct _GActionEntry GActionEntry;
</code></pre>

<p>See that last member of the struct? You need to supply an initializer for it if you are going to have warnings enabled for 'missing initializer'. </p>

<p>Try something like this: </p>

<pre><code>static GActionEntry app_entries[] = {
    {""preferences"", preferences_activated, NULL, NULL, NULL, {0,0,0}},
    {""quit"", quit_activated, NULL, NULL, NULL, {0,0,0}}
};
</code></pre>
",0
22129077,22129059,3,"<p>You are assigning the result of your calculation to <code>i</code>, but print out <code>n</code>. </p>

<p>Moreover, as <code>n</code> had never been initilaised, the code (also) runs into undefined behaviour reading it to have it printed out.</p>

<hr>

<p>This line</p>

<pre><code>i=i++;
</code></pre>

<p>is useless.</p>

<hr>

<p>The value to assign the result of <code>strlgnth()</code> to should have the same type, that is <code>int</code>.</p>

<p>Or even better make <code>strlgnth()</code> and all <code>i</code>s to be <code>size_t</code>.</p>

<p><code>size_t</code> is guaranteed to be wide enough to hold any size the platform may use.</p>

<hr>

<p>Finally this line</p>

<pre><code>scanf(""%s"", s);
</code></pre>

<p>is dangerous as it allows the user to overlfow <code>s</code>. To avoid this tell <code>scanf()</code> the maximum number of charaters to scan in, that is the buffer's size - 1. The 1 character in spare is necessaory to hold the <code>0</code>-terminator:</p>

<pre><code>scanf(""%999s"", s);
</code></pre>

<hr>

<p>Perhaps you should clean-up the layout of your sources. This might help gaining the overview.</p>
",0
22129084,22129059,2,"<p>Delete this line:</p>

<pre><code>    i=i++;
</code></pre>

<p>It's (a) unnecessary and (b) it results in undefined bahviour.</p>

<p>Also, as others have noted, you are confusing <code>i</code> and <code>n</code> in <code>main()</code>.</p>
",0
22129100,22129059,2,"<p>Pay attention, his line: </p>

<pre><code> i=i++;
</code></pre>

<p>is wrong. The behavior is undefined. Try to remove it, as i is incremented in your for loop definition itself.</p>
",0
22129106,22129059,3,"<pre><code>int strlgnth(char *s)
{ 
  int i;    
  for(i=0;s[i]!='\0';i++)
     ;   
  return i;
}
</code></pre>

<p>and</p>

<pre><code>printf(""Length of string: %d"",i);
</code></pre>
",2
21566682,21566670,4,"<blockquote>
  <p>couldn't find what the behaviour of [using free() on non-heap objects in C] action actually is. </p>
</blockquote>

<p>It's undefined behavior.  That's it, you can't make any assumptions about what will occur.  <code>test</code> is a copy of the memory at <code>*ptr</code>.  Calling <code>free</code> on a pointer which was not returned by <code>malloc</code> (and friends) results in undefined behavior.</p>

<p>Either you misunderstood your professor, or your professor doesn't know what s/he is talking about. All you need do is to read the documentation:</p>

<blockquote>
  <p>The behavior is undefined if ptr does not match a pointer returned earlier by malloc(), calloc() or realloc(). Also, the behavior is undefined if the memory area referred to by ptr has already been deallocated, that is, free() or realloc() has already been called with ptr as the argument and no calls to malloc(), calloc() or realloc() resulted in a pointer equal to ptr afterwards.</p>
</blockquote>

<hr>

<blockquote>
  <p>It doesn't seem to cause any run-time errors so I guess it just does nothing? </p>
</blockquote>

<p>Welcome to C :).  You're used to languages which smack your hand right away when you do something terribly wrong.  C doesn't really care what you do. C gives you freedom, but that freedom works both ways (i.e., you're free to shoot your foot off as well).</p>
",7
21566863,21566670,4,"<p>I ran this test and got a core dump. Ubuntu Linux with gcc 4.6.3. I tried several other variations on the theme and core dumped all of them. </p>

<p>Here is the description of free from the Linux man page:</p>

<blockquote>
  <p>The free() function frees the memory space pointed to by ptr, which
  must have been returned by a previous call to malloc(), calloc() or
  realloc(). Otherwise, or if free(ptr) has already been called before,
  undefined behavior occurs. If ptr is NULL, no operation is performed.</p>
</blockquote>

<p>That word <em>undefined</em> is key. That means that it will not necessarily crash. Those are the worst kind of errors to debug - you are much better having a bug that crashes reliably every time. This may be safe for some configurations of compiler and libraries, but it is not for all of them. The method is best avoided.</p>
",0
33030868,33030780,8,"<p>Since <code>strlen()</code> returns a value of type <code>size_t</code>, which is unsigned, then you compute <code>x - 3</code> the computation is done on unsigned values, and with unsigned arithmetic, <code>0 - 3</code> is a large positive value, and is never less than zero. In fact, since the comparison is for an unsigned quantity less than 0, but unsigned quantities can never be negative, the compiler can optimize the entire <code>if</code> test and the following <code>return</code> completely away.</p>

<p>You can fix the problem by changing:</p>

<pre><code>if (x-strlen(str) &lt; 0){
</code></pre>

<p>to:</p>

<pre><code>if (x &lt; strlen(str)) {
</code></pre>

<p>Note that your loop is somewhat inefficient.  You have:</p>

<pre><code>for (int i = 0; i &lt; (strlen(str)); i++){
</code></pre>

<p>This recomputes <code>strlen(str)</code> on each iteration.  You could write:</p>

<pre><code>size_t len = strlen(str);

for (size_t i = 0; i &lt; len; i++) {
</code></pre>

<p>This guarantees that the length is only computed once, which is sufficient unless you're modifying the string somewhere in the function, or one of the functions it calls.</p>
",2
22476960,22476861,3,"<p>With <code>%.*s</code>, the argument corresponding to <code>*</code> means the number of characters to write. You gave argument <code>0</code> so it writes <code>0</code> characters.</p>

<p>To fix this, either change the <code>0</code> to a positive number, or if you want to write the remainder of the string you can just omit the <code>.*</code> and the <code>0,</code>.</p>
",0
21567880,21567827,1,"<pre><code>double sin(double x)
</code></pre>

<p>Is a function declared in the math.h header. It can be used anywhere you'd like - in main() or in any other function you write that is called within main(). However, the way you show it called in main will not do anything useful. The sin() function takes a double as an input and returns a double as an output, so you must store this result in order to do anything with it. For example:</p>

<pre><code>#include &lt;math.h&gt;
void main()
{
  double x, y;
  x = 3.14159;
  y = sin(x);
}
</code></pre>

<p>Now y contains the value of the sine of x, which in this case would be 0.</p>
",0
21567924,21567827,0,"<p>Well, you should begin by opening a <a href=""http://zanasi.chem.unisa.it/download/C.pdf"" rel=""nofollow"">C language book</a>, but here's the basic explanation:</p>

<p>test.c:</p>

<pre><code>#include &lt;math.h&gt;

int main()
{
  double x = sin(1);
}
</code></pre>

<p>there's a thing called ""preprocessor"" that parses your source code and generate a ""pure C"" source code that you can discover if you run:</p>

<pre><code>gcc -E test.c
</code></pre>

<p>the <code>#include</code> directive is a preprocessor keyword (hint: they all begin with a <code>#</code>), that includes the file name given from the include path into the source code, and thus the <em>declaration</em> of the function is available from within the <code>test.c</code> source code.</p>

<p>The <em>declaration</em> is the form you pasted:</p>

<pre><code>double sin(double x);
</code></pre>

<p>it only tells the compiler about the existence of the <code>sin()</code> function, it is not the <code>sin()</code> function itself.</p>

<p>But the <em>definition</em> of <code>sin()</code> is not in that source file. That's because there's another phase called ""linking"" that gets a compiled library's symbols and use them associated with symbols from the files. the <code>sin()</code> symbol is in one of such libraries.</p>

<p>That's for the basics, now it's time for you to read <a href=""http://zanasi.chem.unisa.it/download/C.pdf"" rel=""nofollow"">a book</a>, because there's a lot more to learn about C to understand all that.</p>
",0
22485600,22484538,0,"<p>Best way to fix it would actually be to declare a const in your loop if it is what returns <code>OCI_GetString</code>.</p>

<p>However it depends on what you want to do with this data. If you just want to display it you can directly use <code>OCI_GetString</code> in a <code>printf</code>.</p>

<p>An other solution: if you know a priori the size of the strings returned by <code>OCI_GetString</code> maybe you can try to use it in a <code>memcpy</code> or <code>strcpy</code> using the same buffer in every loop.</p>
",2
22485695,22484538,5,"<p>There is nothing wrong with using <code>const char *symbolP</code>, and it is no less efficient than using <code>char *symbolP</code>. Also, the <em>pointer</em> remains assignable:</p>

<ul>
<li><code>const char *</code> = a non-constant pointer to a constant <code>char</code></li>
<li><code>char * const</code> = a constant pointer to a non-constant <code>char</code></li>
<li><code>const char * const</code> = a constant pointer to a constant <code>char</code></li>
</ul>

<p>Now, if the code that you didn't show actually modifies the string being pointed to, then it is an error and you need to make a modifiable copy first. This is also a good reason to use the proper <code>const char *</code> pointer: you will get the correct error.</p>
",0
21321760,21319021,1,"<p>There are really only two possibilities here - either <code>pq-&gt;Array</code> is being modified to something other than the return value of a <code>malloc()</code> or <code>realloc()</code>, which invokes undefined behaviour when you pass it to <code>realloc()</code>, or the heap is getting corrupted somehow, in which case <em>pretty much anything can happen</em>.</p>

<p>Pointers are easy enough to debug - breakpoint every <code>malloc()</code>, <code>realloc()</code> and <code>free()</code> to make sure the value isn't changing in between. If it is, track down when, then where, then why.</p>

<p>Heap corruption on the other hand is generally a right pain to debug, since you usually only see the symptoms some time after it occurs, and the errors you get are often nonsense and only tell you <em>something went wrong</em>.</p>

<p>Now, there is a potential heap corruption waiting to happen in the code posted, but it doesn't seem to be the one causing this crash. Consider when <code>realloc()</code> runs out of memory here:</p>

<ol>
<li>insert function calls <code>pq_addMem()</code> for more space</li>
<li><code>pq_addMem()</code> doubles <code>pq-&gt;pq_max</code></li>
<li><code>realloc()</code> returns <code>NULL</code>, <code>pq-&gt;Array</code> remains the same size.</li>
<li><code>pq_addMem()</code> returns.</li>
<li>insert function sees <code>pq-&gt;pq_max</code> is now larger, proceeds to insert nodes off the end of the array overwriting internal heap data.</li>
<li>...</li>
<li>later call to memory management function tries to interpret corrupted heap, all hell breaks loose.</li>
</ol>

<p>Double-check all your pointer and array accesses, make sure everything really is the size you think it is, and look out for the sneaky stuff like inadvertently <code>malloc()</code>'ing 0 bytes then trying to actually <em>use</em> the pointer it happily returns.</p>
",1
21321164,21319021,1,"<p>My guess would be that something is writing outside the array and thus corrupting the heap. This is then causing the <code>ASSERT</code> in <code>dbgheap.c</code> to think it's not a valid heap pointer. Alternatively, something is overwriting <code>pq-&gt;Array</code> so it really is not a valid heap pointer.</p>

<p><code>valgrind</code> is a useful tool to use to debug this sort of thing.</p>
",1
29503954,29503646,0,"<p>I suggest to use a switch-like solution. <code>switch</code> doesn't support <code>char *</code>, so else-if is needed.</p>

<pre><code>int x;
char buff[MAX_LEN], buff1[MAX_LEN];

scanf(""%s"", buff);
if (!strcmp(buff, ""read"")) {
    scanf(""%s"", buff1);
    //...
} else if (!strcmp(buff, ""delete"")) {
    scanf(""%d"", &amp;x);
    //...
} else if (!strcmp(buff, ""quit"")) {
    //...
    exit(0);
} else {
    //Error handle
}
</code></pre>
",0
29503791,29503646,2,"<p>The result of the <code>scanf()</code> for each of the listed inputs will be ONLY the first word (up to but not including the space). Suggest using <code>fgets()</code> to get the whole command line input into a local buffer, then parsing the data fields from the local buffer, perhaps using <code>strtok()</code> or <code>strchr()</code> or ...</p>
",2
29503824,29503646,1,"<p>You can instead try something like this?</p>

<pre><code>int option;
printf(""\nPlease enter a command (1 for print, 2 for delete, 3 for write, 4 for quit): "");
</code></pre>

<p>And then read the user input number</p>

<pre><code>scanf(""%d"", &amp;option);
</code></pre>

<p>You can later use a switch statement on 'option' to process differently</p>
",1
25665094,18730510,0,"<pre><code>(TYPE*) POINTER
</code></pre>

<p>is a syntax which is interpreted as a type-cast of pointer.
For example, </p>

<pre><code>int m = 4;
char* p_char = (char*)&amp;m;
</code></pre>

<p>Thus, <code>p_char</code> is a pointer to char. If we dereference <code>p_char</code>, namely <code>*p_char</code>, the binary representation at the position where <code>p_char</code> points to will be transformed to a representation of <code>char</code>(character). The exact result of this value is undefined. I have no idea what exact value it will return, but it will return something like a weird character <code>?</code>. </p>

<p>For a deeper understanding of pointer, I want to emphasize that a pointer is merely one of the interfaces to access entity represented in C++ language and residing on computer memory. </p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

/*
 *  C++ interface to represent entity which resides on computer memory: 
 *      ---------                                             
 *  1) object;
 *  2) pointer;
 *  3) reference;
 *
 *  C++ interpretation of entity through interface: TYPE
 *      --------------                              ----          
 *
 *  What is the function of TYPE?
 *  1) tell compiler the size of an object of this TYPE needed; ( sizeof( int ) -&gt; 4 bytes )
 *  2) when the value of object at which it resides is dereferenced, 
 *     the binary represented value is transformed to some other 
 *     representation value according to the TYPE's interpretation rule; ( if int, interpret it as an int )
 *
 *
 *              +----------------+         
 *              |     0x02105207 |                    
 *              |     0x02105206 |                    
 *              |     0x02105205 |                    
 *       int  n |     0x02105204 |                    
 *              +----------------+                    
 *              |     0x02105203 |                    
 *              |     0x02105202 |                    
 *              |     0x02105201 |                    
 *  ----&gt;int  m |     0x02105200 |                    
 *  |           +----------------+                   
 *  |           |                |                    
 *  |           +----------------+                   
 *  |          ...              ...                    
 *  |           +----------------+                   
 *  ---- int* p |     0x00002298 |                    
 *              +----------------+                   
 *
 *  if the pointer in figure is declared as:
 *
 *       int* p = &amp;m;
 *  
 *  the face of 0x00002298 -&gt; 0x02105200 will not be changed until p is 
 *  assigned to other address value;
 *
 *  
 */

class consecutive_two_int
{
public:
    consecutive_two_int():m(4),n(123){}
    int m;
    int n;
};

int main()
{
    int * p;
    consecutive_two_int obj;
    p = &amp;(obj.m);

    for( int i = 0; i &lt; 8; ++i )
    {
        //  because pointer of char progresses every 1 byte;
        //  increment memory byte by byte through it;
        cout &lt;&lt; *(int*)( (char*)p + i ) &lt;&lt; ""\n"";
    }

    return 0;
}
</code></pre>

<p>The result, as an example, is:</p>

<pre><code>4 // the first defined int
2063597568 // undefined
8060928  // undefined
31488  // undefined
123 // the second defined int
268435456  // undefined
1175453696  // undefined
-465170432  // undefined
</code></pre>
",0
29222076,19395675,0,"<p>I don't have enough rep to comment.  This post helped me out a lot.  If anyone else comes across this the issue for why his second function won't print is that his return statement is before his printf statement.  If here were to flip them around:</p>

<pre><code>  printf(""in xtoi, processing %s\n"", hexstring);
  return dec;
</code></pre>

<p>Then the second function will print the line.</p>
",0
34247636,34247623,5,"<p>Because you're creating that as an automatic variable, it will go on the stack. The stack size is not very large. A general rule of thumb is for any objects larger than a few KBs, always dynamically allocate them on the heap using <code>malloc()</code> (or new for C++).</p>

<p>Your program is crashing because the size of the stack grew larger than it was allowed to. That's known as a stack overflow and is usually seen when you have unbounded recursion.</p>

<p>The size of the stack is implementation defined, so it's very possible that the default stack size on Linux is larger than on OS X.</p>
",9
34247701,34247623,1,"<p>I guess the reason it works on the other machine is because the compiler has optimization for unused variables.</p>
",4
24758756,24758693,6,"<p>Bitwise <code>&amp;</code> has lower <a href=""http://www.difranco.net/compsci/C_Operator_Precedence_Table.htm"" rel=""nofollow"">precedence</a> than <code>*</code>, <code>%</code>, <code>+</code>.  Operands will be grouped as</p>

<pre><code> double b = (5 % 3) &amp; (4 + 5 * 6);  
</code></pre>

<p><code>5%3</code> = 2 =  <code>0000 0000 0000 0000 0000 0000 0000 0010</code><br>
<code>34</code>  = <code>0000 0000 0000 0000 0000 0000 0010 0010</code><br>
Bit-wise ANDing both yield <code>0000 0000 0000 0000 0000 0000 0000 0010</code>  = 2 </p>
",2
24758791,24758693,3,"<p>To get your expected output of <code>30.000000</code> you have to specify the order of operations - you could use parens.  You need to tell the compiler that you want the <code>AND</code> to happen directly after the <code>5 % 3</code>.</p>

<pre><code>double b = (5 % 3 &amp; 4) + 5 * 6; // Specify precedence
</code></pre>

<p>Output: <code>30.000000</code></p>

<hr>

<p>Your original code executes in this precedence.</p>

<pre><code>double b = (5 % 3) &amp; (4 + (5 * 6)); // Added parens to show how it executes
</code></pre>

<p>Output: <code>2.000000</code></p>

<p>Basically, you were <code>AND</code>ing (5 % 3) with (4 + (5 * 6)).</p>
",2
24758861,24758693,0,"<p><code>&amp;</code> has lower precedence than you think. You can check them all <a href=""http://www.difranco.net/compsci/C_Operator_Precedence_Table.htm"" rel=""nofollow"">here</a>.</p>
",0
24758893,24758693,1,"<p>The problem is caused because of the bitwise-And (&amp;) operator. </p>

<p>It might seem unintuitive, but it has a <strong>lower precedence</strong> than multiplication, addition and modulus operations.</p>

<p>This was considered an ""<em>infelicity of C's precedence rules</em>"" by Dennis Ritchie but was nevertheless accepted into the language. </p>

<p>You can find Ritchie's exposition on this, among other matters here: <a href=""http://cm.bell-labs.com/who/dmr/chist.html"" rel=""nofollow"">http://cm.bell-labs.com/who/dmr/chist.html</a></p>
",0
34257489,21311397,3,"<p>I had the same problem, and I realized that changing the header </p>

<pre><code>#define _XOPEN_SOURCE
#include &lt;unistd.h&gt;
</code></pre>

<p>by</p>

<pre><code>#define _GNU_SOURCE
#include &lt;crypt.h&gt;
</code></pre>

<p>makes disapear the error in compilation time</p>
",0
21314271,21311397,1,"<p>The function signature of <a href=""http://www.gnu.org/software/libc/manual/html_node/crypt.html"" rel=""nofollow""><code>crypt</code></a> is:</p>

<pre><code>char * crypt (const char *key, const char *salt)
</code></pre>

<p>It seems that you forgot one parameter! So your line:</p>

<pre><code>string beta = crypt(alpha);
</code></pre>

<p>Should be something like that:</p>

<pre><code>string beta = crypt(alpha, salt);
</code></pre>
",0
25669538,25668946,1,"<p>You always read/write files at a certain position. To make these changes, you need to jump back, overwrite, and jump back.</p>

<pre><code> char  lineFileRecord[150];
 FILE* fp = fopen(""abc.txt"",""r+"");
 long  posWrite = 0;
 long  posRead;

 while (fgets(lineFileRecord , 150 , fp) != NULL)
 {
    char* sample;
    sample = strstr(lineFileRecord, ""overwritef""); 

    //overwritef and changemade both have same size

    if (sample != NULL)
    {
        // 1. Update your current lineFileRecord in memory.
        strncpy(sample, ""changemade"", 10);

        // 2. Remember where you were reading.
        posRead = ftell(fp);

        // 3. Jump back in the file to the beginning of your current lineFileRecord.
        //    This position was saved the previous time step 6 was executed.
        fseek(fp, posWrite, SEEK_SET);

        // 4. Now overwrite your file on disk! You were only changing the memory of
        //    of your program. And as you should know, memory and disk are
        //    different things. You need to overwrite the full lineFileRecord, 
        //    because ftell() does not give a clean byte position in text files.
        //    THANKS @chux!!!
        fwrite(lineFileRecord, 1, strlen(lineFileRecord), fp);

        // 5. Finally jump forward to where you are reading.
        fseek(fp, posRead, SEEK_SET);
    }

    // 6. Save the file position for the next overwrite.
    long posWrite = ftell(fp);
}
</code></pre>

<p>Remark: Stop using TABs in your code, it messes up indentation; always use spaces!</p>
",3
25670779,25668946,0,"<p>Reading a file is the same as copying the contents of the file into memory*. You are modifying the copy of the contents, not the original.</p>

<p>You should either copy the content of entire file into memory, change that content, and then overwrite the entire file, or use the function calls like <code>feek</code> and <code>fputs</code> to modify parts of the file. How to write to a text file is explained in this question: <a href=""https://stackoverflow.com/questions/11573974/write-to-txt-file"">Write to .txt file?</a></p>

<p>*Unless you are using something like memory mapped files. As a beginner, do <strong>not</strong> use memory mapped files, they are not trivial to use.</p>
",2
26227665,26227644,0,"<p><code>error:</code> is a label for <code>goto</code>. As you have no <code>goto</code> it will do nothing.</p>

<p>You should turn on all warnings in the compiler. Also do not use <code>goto</code> - other methods are better</p>
",0
26227666,26227644,2,"<p>That <code>error:</code> would get used by <code>goto error;</code>, but you have nothing like that in your examples.</p>

<p>Here's a snippet from Linux kernel (namespace.c):</p>

<pre><code>static struct vfsmount *fs_set_subtype(struct vfsmount *mnt, const char *fstype)
{
        int err;
        const char *subtype = strchr(fstype, '.');
        if (subtype) {
                subtype++;
                err = -EINVAL;
                if (!subtype[0])
                        goto err;
        } else
                subtype = """";

        mnt-&gt;mnt_sb-&gt;s_subtype = kstrdup(subtype, GFP_KERNEL);
        err = -ENOMEM;
        if (!mnt-&gt;mnt_sb-&gt;s_subtype)
                goto err;
        return mnt;

 err:
        mntput(mnt);
        return ERR_PTR(err);
}
</code></pre>

<p>Using <code>goto</code> is prone to errors, discouraged, and not for beginners.</p>
",1
21171701,21171060,0,"<p>you can do this in several macro combination:</p>

<pre><code>#define BEGIN_INT_FUNCTION(name) \
  int name() {\
  do something...

#define END_INT_FUNCTION \
  do something...
  return 0; \
}
</code></pre>

<p>now you code the function:</p>

<pre><code>BEGIN_INT_FUNCTION(name)  // or without argument
{
  function body...
}
END_INT_FUNCTION
</code></pre>

<p>and you call it like this:</p>

<pre><code>int x = name();
</code></pre>
",0
21171399,21171060,3,"<p>This is not something I'd recommend doing, but you can have the macro create one function containing the entry/exit code, and another containing the code given by the user:</p>

<pre><code>#include &lt;stdio.h&gt;

#define MAGIC_MACRO(f) \
    void f##_inner(void); \
    void f(void) { \
        printf(""entry\n""); \
        f##_inner(); \
        printf(""exit\n""); \
    } \
    void f##_inner()

MAGIC_MACRO(foo)
{
    printf(""foo\n"");
}

int main(void) {
    foo();
    return 0;
}
</code></pre>

<p>The invocation of <code>MAGIC_MACRO</code> will create <code>foo</code> and <code>foo_inner</code> functions, where <code>foo</code> calls <code>foo_inner</code>. <code>foo_inner</code> contains the user code, which allows putting it all after the macro invocation.</p>

<p><a href=""http://ideone.com/eqIzuZ"" rel=""nofollow"">Live example</a></p>
",0
21171510,21171060,0,"<blockquote>
  <p>In short, want to take the whole body of the function and place it in
  an ""outer"" function.</p>
</blockquote>

<p>the syntax for such a macro would have to take the whole body of the function as parameters, which isn't</p>

<pre><code>MAGIC_MACRO(foo)
{
...doSomeStuff...
}
</code></pre>

<p>but</p>

<pre><code>MAGIC_MACRO(foo,
{
...doSomeStuff...
})
</code></pre>

<p>or maybe</p>

<pre><code>MAGIC_MACRO(void foo(void),
{
...doSomeStuff...
})
</code></pre>

<p>the real problem with the approach is see is that there are special characters, #pragma's and other things which may be found in the bodies and they cannot be transported using a macro parameter.</p>
",0
34204567,15338417,1,"<p>For the record:</p>

<p>I also noticed wrong values returned by ifft from four1.c from numerical recipes. I only tested it with N=256 complex values as input, assembled in a way, that they should result in a real only time domain signal.</p>

<p>The resulting time domain vector has to be mirrored (end to start and vice versa ...) and shifted by one to correspond with the IFFTs of other implementations. (I tested numpy.fft.ifft, octave's ifft and a inverse discrete fourier transformation without any optimisation, simply based on the IDFT formula, which should be definitly correct).</p>

<p>There has to be a fundamental algorithm fault in the version provided by numerical recipies. In their books nothing related to this problem is described.</p>
",0
26228497,26228353,3,"<p>Depending on the CPU architecture it may be necessary for the structure members to be correctly aligned, eg the address of a 4 byte member should be divisible by 4. Some CPUs don't need such alignment, but many do. Some CPUs will crash if you attempt to do stuff with improperly aligned data, others will cope but access to improperly aligned data will be much slower. </p>

<p>Assembler programmers need to worry about this issue, but C programmers can generally leave the messy details to the compiler. But it means that structures can include ""invisible"" padding to ensure proper alignment. This padding doesn't waste much space, and you can minimise the wasted space by good layout of your structure members. Note that this padding also happens to variables created on the stack for your functions.</p>

<p>For further info, please see <a href=""http://en.wikipedia.org/wiki/Data_structure_alignment"" rel=""nofollow"">Data structure alignment</a>.</p>
",0
26228504,26228353,3,"<p>While members are not necessarily contiguous, they're not in arbitrary memory locations either. Take, for example, the following definition:</p>

<pre><code>struct MyStruct
{
    char foo;
    int  bar;
};
</code></pre>

<p>Assuming <code>sizeof(int) == 4</code>, then <code>foo</code> will be at offset 0 and <code>bar</code> at offset 4 (to be properly aligned). So the whole structure will be 8 bytes, even though it could fit in 5. However, these offsets will always be the same for every instance of this structure. So to answer your question about <code>malloc</code>, no, it will not waste space.</p>

<p>As far as separate variables, yes, they may be located at different locations in memory, but the whole point of structures is to group related variables. Therefore, all members of the same struct instance will be closely grouped together.</p>
",0
26227755,26227740,0,"<p>strncat is for concatenating (C-style) strings. <code>text</code> is a char[], so that works, but <code>c</code> is an int, which is definitely not a string, hence the error.</p>
",0
26227760,26227740,2,"<p>There is no implicit conversion between an integer and a string representing the value stored in the integer. You must manually convert it.</p>

<p>Function <code>itoa</code> can do it for you:</p>

<pre><code>int value = 1234;
char tempBuffer[MAX_DIGITS];
itoa(value, tempBuffer, 10);
</code></pre>
",0
26227766,26227740,2,"<p><code>strncat</code> cannot append a character to a string, because it appends strings to strings. You can make a one-character string from your <code>c</code> character, but using <code>strcat</code> is an overkill: you would be better off making a pointer, and appending by adding characters to it:</p>

<pre><code>char *p = &amp;text[strlen(text)]; // Start appending at the last position of text
while ((c = fgetc(fp)) != EOF &amp;&amp; c != '\n') {
    *p++ = c;
    if (p == &amp;text[1023]) break;
}
*p = '\0';
</code></pre>

<p>Pointer check in the loop has been added to deal with buffer overruns.</p>
",0
26227767,26227740,1,"<p><code>strcat()</code> concatenates two strings, and a C string is an array with a terminating <code>'\0'</code> character. So this is a mismatch.</p>

<p>However, <code>strncat()</code> concatenates two strings and let's you set the maximum number of characters to copy. So you could pass the address of the <code>c</code> and it will be treated like an array with only one element. So you could try something like this:</p>

<pre><code>strncat(text, (char*)&amp;c, 1);
</code></pre>

<p>Otherwise, you need a character buffer to hold this stuff.</p>
",6
26227819,26227740,0,"<p>try this
 <code>strncat(text, &amp;c,1)</code></p>
",0
29200534,15766492,0,"<blockquote>
  <p>PS: As a secondary question, is it impossible to print the number 0 to 9 horizontally, in 10 different lines, using nested for loop if we use the same count variable in each loop, as I have done here? (Ignore this secondary question if it's not relevant to main question)</p>
</blockquote>

<p>Of course you can, but you need a more complex format string for your printf.</p>

<pre><code>printf(""%d "",i);
</code></pre>

<p>The above statement works by printing I, immediately followed by a space, and leaving the carriage where the print stops.</p>

<p>The effect that I think you have in mind is something like the following.</p>

<pre><code>0
  1
    2
      3
        4
          5
            6
              7
                8
                  9
</code></pre>

<p>To make that happen, you need a couple of changes to your printf statement, as illustrated in the following complete program.</p>

<pre><code>// MarchingDigits.cpp : Defines the entry point for the console application.
//

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char* argv[])
{
    for ( int i = 0 ; i &lt; 10 ; i++ )
    {
        printf ( ""%*d\n"", ( i &gt; 0 ? i + 1 : i ) , i ) ;
    }   // for ( int i = 0 ; i &lt; 10 ; i++ )

return 0;
}       // int main
</code></pre>

<p>The output generated by this program is as follows.</p>

<pre><code>0
 1
  2
   3
    4
     5
      6
       7
        8
         9
</code></pre>

<p>There are three fundamental differences between your printf statement and the one that generated this output.</p>

<ul>
<li>Between the opening % and the closing d, I inserted an asterisk where the width goes.</li>
<li>I replaced the trailing space with a newline.</li>
<li>Between the format string and your integer argument i, I inserted another argument, in the form of a ternary expression, i > 0 ? i + 1 : i, which says, in effect, if I is greater than zero, set the width to i + 1, otherwise set the width to i. Although the else block sets the width to i, which happens to be zero, this works because printf guarantees never to truncate the output.</li>
</ul>
",0
23852805,23851025,1,"<p>You can write your own malloc/free using a fixed-size pool, for example:</p>

<pre><code>typedef struct test_struct T;
#define POOL_SIZE 100
static bool pool_use[POOL_SIZE] = { 0 };
static T pool[POOL_SIZE];

T *t_malloc(void)
{
    for (int ii = 0; ii &lt; POOL_SIZE; ++ii)
        if ( !pool_use[ii] )
        {
            pool_use[ii] = 1;
            return &amp;pool[ii];
        }

    return NULL;
}

void t_free(T *t)
{
    for (int ii = 0; ii &lt; POOL_SIZE; ++ii)
        if ( t == &amp;pool[ii] )
        {
             pool_use[ii] = 0;
             break;
        }
}
</code></pre>

<p>Note: This is just a basic example to illustrate the idea of a memory pool.  It could be optimized a lot. There's a lot of theory around about allocators and memory pools (it's the sort of thing you could write a thesis on if doing postgrad work for a comp sci degree). </p>

<p>If your application is going to depend on the speed and/or space-efficiency of this allocator then you could do a bit more research about what techniques are available.</p>
",2
27118741,27118700,0,"<p>You can't access local values from outside a function. Instead, try changing <code>randomNum</code> to <code>return result[2]</code> at the end and change teh <code>void</code> in the signature to be <code>int</code>.</p>

<p>Alternatively, you could make <code>result</code> be a variable inside the <code>thebest</code> function, then pass it to <code>randomNum</code> to be filled in, then you can use it from <code>thebest</code> as a regular array.</p>

<p>But returning the specific item you're interested in from the <code>randomNum</code> function is probably the easiest and cleanest solution.</p>

<p>Also, when you call <code>randomNum</code>, don't forget the parenthesis: <code>randomNum()</code> instead at the usage point.</p>
",3
27118796,27118700,0,"<p>You could do it like this:</p>

<pre><code>void randomNum(int *result)
{
    // same code except don't declare result[10]
}

void thebest()
{
    int result[11];

    randomNum(result);
    printf(""Fitness = %d \n"" , result[2]);
}
</code></pre>
",0
27118801,27118700,0,"<p>You are trying to access or change a member of randomNum.result[] that doesn't exist. The index of array, array_name[index] is from 0 to index - 1. Therefore, in the for loop to you need to change the it for i &lt; 11 to i &lt; 10 as it is the for loop below.</p>

<pre><code>for ( i=0; i&lt;10; i++)
{

            x[i]=  100+rand()%100;
            y[i]=   80+rand()% 90;
            result[i] = ( -2*(x[i]) ) + ( 5*(y[i]) );
            printf(""Fitness = %d \n"" , result[i]);

}
</code></pre>

<p>When trying to access the array it needs to be:</p>

<pre><code>void thebest()
{
   printf(""Fitness = %d \n"" , randomNum.result[9]);

}
</code></pre>
",3
27123094,27118700,0,"<p>C functions don't have class-like members, so you can't access <code>randomNum.result[2]</code> the way you do. There are a few other ways though:</p>

<p><strong>Caller-supplied buffer:</strong></p>

<p>The calling function can supply a buffer to be filled in by <code>randomNum()</code>. This is probably the simplest solution:</p>

<pre><code>void randomNum(int result[10])
{
  int i;
  /* int result[10]; // Converted into a function parameter. */

  ...
}

void thebest ()
{
  int r[10];

  randomNum (r);
  printf (""Fitness = %d \n"", r[9]);
}
</code></pre>

<p>This way, the <code>thebest()</code> function allocates storage for the array, and passes a <em>pointer</em> to <code>randomNum()</code>. It is not possible to pass an array directly to a function, so the array parameter in the definition of <code>randomNum()</code> is silently adjusted to a pointer to <code>int</code>, and the function call <code>randomNum (r)</code> will pass a pointer to the first element of <code>r</code>.</p>

<hr>

<p><strong>Returning a pointer to static storage:</strong></p>

<p>If you want to access the <code>result</code> variable inside <code>randomNum()</code>, you can return it from the function. Similarly to the example above, you cannot return an array directly from a function. You have to return a <em>pointer</em> to the array. However, a local variable ceases to exist when the function where it is defined returns. To get around this you can define the variable to have <em><code>static</code></em> storage. This means that the variable exists throughout the entire execution of the program. It <em>also</em> has the drawback that two calls to the function will operate on <em>the same</em> variable, thus overwriting the previous data.</p>

<pre><code>/* Define randomNum to return pointer of int */

int *randomNum(void)
{
   int i;
   static int result[10]; /* Changed to static */

   ...

   return result;
}

void thebest()
{
  printf(""Fitness = %d \n"" , randomNum()[2]);
}
</code></pre>

<hr>

<p><strong>Returning a pointer to allocated storage:</strong></p>

<p>To get around the drawback of using a local static buffer, you can use a dynamically allocated buffer. This returns a new buffer on every call. Note that the allocation may fail (returning <code>NULL</code>), and that the pointer must be <code>free()</code>'d afterwards.</p>

<pre><code>int *randomNum(void)
{
   int i;
   int *result; /* Changed to a pointer */

   result = malloc (10 * sizeof *result);
     /* Allocate 10 elements of whatever result points to */

   if (result) {

     ...

   }

   return result;
}

void thebest()
{
  int *r = randomNum();

  if (r) {
    printf(""Fitness = %d \n"" , r[2]);
  }

  free (r);
}
</code></pre>

<hr>

<p><strong>Returning an array inside a struct:</strong></p>

<p>Ok, I lied before: There <em>is</em> a way to pass and return an array to and from a function. You can wrap it inside a <code>struct</code>. This has the drawback that, on some implementations, passing of large structs can be much more complicated than passing a pointer.</p>

<pre><code>struct result_t {
  int result[10];
};

struct result_t randomNum(void)
{
  int i;
  struct result_t r;

  ...

    r.result[i] = ( -2*(x[i]) ) + ( 5*(y[i]) );

  ...

  return r;
}   

void thebest()
{
  struct result_t res;
  res = randomNum();
  printf(""Fitness = %d \n"" , res.result[2]);
}
</code></pre>

<p><strong>or:</strong> (if your compiler conforms to recent C standards)</p>

<pre><code>void thebest()
{
  printf(""Fitness = %d \n"" , randomNum().result[2]);
}
</code></pre>
",0
27134332,27118700,0,"<p>Thank you guys for the help </p>

<p>I figure it out:</p>

<p>I need to declare the result[] in the main and then pass it to both functions:</p>

<pre><code>  main(){
 int result[10];


 randomNum(result);
 thebest(result);


 }
</code></pre>

<p>pass result[] to the function()</p>

<pre><code>  void randomNum(int result[])
       {
        ...

        }


   void thebest(int result[])
     {

     ...  
      }
</code></pre>
",0
26784507,26784385,1,"<p>With 32 bit signed ints you can can only represent values up to <code>2^31 - 1</code>, hence <code>n</code> must be <code>&lt;= 30</code>. Use 64 bits ints (preferably unsigned) for larger values of <code>n</code>, e.g.</p>

<pre><code>int n = 60;
uint64_t s = 1ULL &lt;&lt; n;    // s = pow(2, n) = pow(2, 60)
</code></pre>
",0
26784539,26784385,0,"<p><code>s</code> is a <code>signed int</code> and you're uncomfortably close to overflowing it with <code>s = power (2, n)</code> when n is greater than 31.</p>
",0
26784563,26784385,4,"<p>You get a division by zero as your <code>int</code> type is overflowing. (<code>power(2, 32)</code> is probably being evaluated as 0 but you should view this as a coindicence since signed overflow is <em>undefined behaviour</em> in C).</p>

<p>In C you can use <code>uint64_t</code> which is a 64 bit unsigned integer type. That's been there since (and including) C99. Note that <code>unsigned</code> overflow is defined in C to be reduced modulo power of 2</p>

<p>This will give you good results up to <code>power(2, 63)</code>.</p>
",1
28179270,28179220,4,"<p><code>in</code> is too small as the string literal is <code>50</code> characters, meaning the <code>strcat()</code> afterwards are writing beyond the end of the buffer causing undefined behaviour, in this case causing corruption (in fact the string literal is <code>50 + 1</code> due to the implicit null terminator appended to string literals). To correct increase the size of the buffer and use <a href=""http://en.cppreference.com/w/c/io/fprintf"" rel=""nofollow""><code>snprintf()</code></a> to prevent buffer overrun and to perform the string construction in a single operation. For example:</p>

<pre><code>for (int i = 0; i &lt; 10; i++)
{
    char str[128];

    const int result =
        snprintf(str,
                 sizeof(str),
                 ""INSERT INTO `Test` (`Col1`, `Col2`) VALUES ('1', '%i')"",
                 i);

    if (-1 == result)
    {
        fprintf(stderr, ""Failed to create 'INSERT' statement\n."");
    }
    else if (result &gt;= sizeof(str))
    {
        fprintf(stderr, ""Failed to create 'INSERT' statement: truncated\n"");
    }
    else
    {
        printf(""[%s]\n"", str);
    }
}
</code></pre>
",1
28179313,28179220,3,"<p>You declare this:</p>

<pre><code>char in[50] = ""INSERT INTO `Test` (`Col1`, `Col2`) VALUES ('1', '"";
</code></pre>

<p>but</p>

<pre><code>sizeof ""INSERT INTO `Test` (`Col1`, `Col2`) VALUES ('1', '""
</code></pre>

<p>is 51 characters.</p>

<p>Which means that there is not enough room for the null terminator in your original <code>in</code> array, so <code>in</code> is not a string so can you cannot concatenate anything to it and as <code>hmdj</code> wrote even if it was a string there would be no room left to concatenate anything as it is full.</p>
",0
23102290,23100919,0,"<p>You are accessing out of bounds of the array in the function <code>getField</code> because the <code>while</code> loop never exits. This invokes undefined behaviour and most likely program crash due to segfault which is what is happening in your case. I suggest the following changes to your program.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

void getField(char *line, int field);

int main(int argc, char *argv[]) {
  if(argc &lt; 3) {
    fprintf(stderr, ""Too few arguments \""%s\"".\n"", argv[0]);
    return 1; // end the program
  }

  if(atoi(argv[1]) &lt; 1) {
    fprintf(stderr, ""First argument must be &gt;= 1 \""%s\"".\n"", argv[1]);
    return 1; // end the program
  }

  FILE *fp = fopen(argv[2], ""r"");
  if(fp == NULL) {
    fprintf(stderr, ""Cannot open file %s\n"", argv[0]);
    return 1; // end the program
  }

  char buf[80];
  while(fgets(buf, 80, fp) != NULL) {
    getField(buf, atoi(argv[1]));  // seg fault is happening here
  }

  return 0;
}

void getField(char *line, int field) {
  int len = strlen(line);
  char temp[len + 1];
  strcpy(temp, line);

  int count = 0;
  char ch = ',';
  char *p = temp;
  char *q = NULL;
  while(count &lt; field - 1) {
    q = strchr(p, ch);
    if(q == NULL) {
      printf(""error in the value of field\n"");
      return;
    }
    count++;
    p = q + 1;
  }
  q = strchr(p, ch);
  if(q != NULL)
    *q = '\0';
  else 
    temp[len-1] = '\0';

  printf(""%s\n"", p);
}
</code></pre>
",0
23101015,23100919,4,"<p>One obvious error is that you have an infinite loop here, and you will eventually access illegal memory.</p>

<pre><code>while(column) {
     //printf(""here"");
    if(line[idx] == ',') field--;
    idx++;
}
</code></pre>

<p>You are not modifying <code>column</code> at all, so your loop cannot possibly end. 
<code>column</code> will not update itself when you update <code>field</code>, so you will have to update it if you want it to update.</p>

<pre><code>while(column) {
     //printf(""here"");
    if(line[idx] == ',') field--;
    idx++;
    column = field - 1;
}
</code></pre>

<p><strong>Note on debugging segfaults using <code>printf</code>.</strong></p>

<p>The function <code>printf</code> prints to <code>stdout</code> and <code>stdout</code> likes to buffer output. This means that sometimes if you try to find a segfault by moving a print statement down your code until it fails to print, you will misunderstand where the segfault it happening. In particular, a <code>printf</code> line that appears before the line that actually contains the segfault may not print even if you might expect it to.</p>

<p>If you want to use this strategy (instead of <code>gdb</code>), you can force it to print by using <code>fflush(stdout);</code> immediately after your debugging <code>printf</code>.</p>
",3
23101062,23100919,0,"<p>In following line:</p>

<pre><code>printf(""%s"", line[j]);
</code></pre>

<p>you are using the <code>%s</code> format specifier but you are passing a <code>char</code> as argument.</p>

<p>You probably want this (<code>%c</code> format specifier fot printing a <code>char</code>):</p>

<pre><code>printf(""%c"", line[j]);
</code></pre>
",1
23101063,23100919,1,"<pre><code>while(column) {
        //printf(""here"");
        if(line[idx] == ',') column--;  // Changed field-- to column--
                idx++;
}
</code></pre>
",0
29448675,29448572,2,"<p>Perhaps it will be clearer if I put in stepping stones <code>v3</code> and <code>v4</code>. These are used to calculate an offset into the string of 3 indices. So the print output begins at <code>abc[3]</code>.</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main (int argc, char *argv[])
{
    char abc[14] = ""C Programming"";
    int v3 = abc[3];
    int v4 = abc[4];
    printf(""%d - %d = %d\n"", v3, v4, v3 - v4);
    printf(""%s\n"", abc + v3 - v4);
    return 0;
}
</code></pre>

<p>Program output:</p>

<pre><code>114 - 111 = 3
rogramming
</code></pre>
",0
29448693,29448572,2,"<p>This may caused by the following:
the value of <code>abc[3]</code> is 'r',the value of <code>abc[4]</code> is 'o'.so the value of</p>

<pre><code>abc[3]-abc[4]
</code></pre>

<p>is 'r'-'o',change the value into <code>int</code> is <code>3</code>.So when you use <code>printf(""%s\n"", abc+abc[3]-abc[4]);</code>,it means you print this string from abc[3].
the following code will show you something.</p>

<pre><code> int main()
  {
  char abc[14] = ""C Programming"";
  printf(""%d\n"",abc[3]-abc[4]);
  printf(""%s\n"", abc+abc[3]-abc[4]);

  }
</code></pre>
",0
29448717,29448572,2,"<p>In this expression <code>abc+abc[3]-abc[4]</code> there is used so-called the pointer arithmetic.</p>

<p>An array name in expressions is converted to pointer to the first element of the array,</p>

<p>Thus in the expression above abc points to the first character of the string that is to  <code>'C'</code> <code>abc + 1</code> points to space. <code>abc + 2</code> points to 'P'. <code>abc + 3</code> points to 'r' and so on.</p>

<p>expressions abc[3] and abc[4] are converted to type int and equal to internal codes of characters <code>'r'</code>  and <code>'o'</code> The difference of these codes is equal to 3,</p>

<p>Thus expression <code>abc+abc[3]-abc[4]</code> can be written like <code>abc + 3</code> and points to the forth element of the array that is to <code>'r'</code> So the string starting from 'r' is outputed by statement</p>

<pre><code>printf(""%s\n"", abc+abc[3]-abc[4]);
</code></pre>
",0
29449174,29448572,1,"<p>On virtually every platform (e.g. one using ASCII), the behaviour is undefined. So, none of the answers is correct.</p>

<pre><code>abc+abc[3]-abc[4]
</code></pre>

<p>This expression is equal to</p>

<pre><code>abc + 'r' - 'o'
</code></pre>

<p>the values of character constants are implementation-dependent; assuming an ASCII system, where <code>r</code> and <code>o</code> are 0x6f and 0x72, respectively, <code>abc + 0x6f</code> is out of the bounds of the array <code>abc</code>, leading to undefined behaviour. Note, that the later subtraction, appearing to bring the result back into bounds, doesn't change that; once reached, one cannot recover from undefined behaviour.</p>

<p>That said, the result is likely to be the same as <code>abc + ('r' - 'o')</code>, which, on an ASCII system, is <code>abc + (0x6f - 0x72)</code>, which in turn is <code>abc + 3</code> and thus <code>rogramming</code> is outputted, as reported in the question.</p>
",0
22119143,22118880,2,"<p>You cannot do that.</p>

<p>To achieve your goal, C preprocessor needs to understand all the C built-in data type and types defined by programmer, that is <strong>too much</strong> for it.</p>
",0
22118907,22118880,4,"<p>You cannot do what you want. <code>offsetof</code> is (like <code>sizeof</code>) computed after preprocessing, during the compilation proper.</p>

<p>Look at the preprocessed form of your source code. With GCC you could get it using <code>gcc -C -E CMain.c &gt; CMain.i</code> then use an editor (or a pager) to look inside <code>CMain.i</code> e.g. <code>less CMain.i</code></p>
",0
23569586,23568612,11,"<p>I notice that no one has actually answered the question you asked, which was</p>

<blockquote>
  <p>What is the reason for forward-declaring a type?</p>
</blockquote>

<p>The answer is: C was designed so that it could be compiled <em>by reading each file <strong>once</strong> going from top to bottom</em>.  Consider a language like C#:</p>

<pre><code>class C
{
  B b;
}
class B
{
  C c;
}
</code></pre>

<p>Notice that if the compiler is going from top to bottom, the compiler gets to a field of type <code>B</code> before it knows what <code>B</code> is. And in fact the C# compiler does <em>not</em> read the entire file <strong>once</strong> going from top to bottom. It makes <em>many</em> passes over each file, building up information as it goes.</p>

<p>Now suppose you wanted to write a C# compiler that could parse the program above <em>without</em> doing multiple passes. Somehow you'd have to tell the compiler <em>before it encountered field <code>b</code></em> that there was a type called <code>B</code>. But we can't just move <code>class B</code> to before <code>class C</code> because that would create the same problem again, this time with <code>C</code>!</p>

<p>In our imaginary one-pass version of C# you might say that you can get around the problem like this:</p>

<pre><code>class B; // Tell the compiler that B will be defined later.
class C
{
  B b;
}
class B
{
  C c;
}
</code></pre>

<p>And there you go. When the compiler gets to <code>B b</code> it knows that <code>B</code> is a class that will be defined later. <code>B</code> has been <em>forward-declared</em>. </p>

<p>Since C# has always used a multi-pass approach it does not need this trick. But the designers of C <em>did</em> want a single-pass approach, and so they require the redundancy of a forward declare.</p>

<p>This single-pass approach was designed to make compilation easier back in the day when machines had a few K of memory and ran at a few thousand cycles per second; C#'s approach of multiple scans building up complex data structures each time is expensive in comparison, and would be difficult on a machine with constrained speed and memory.</p>

<p>Now of course we have machines with trillions of bytes of memory (remember, <em>memory</em> is <em>disk space</em>; RAM is just a cache over disk!) that run billions of cycles per second, and yet still we are stuck with having to use techniques to make compiler writer's lives easier back in the 1970s.  That's how it goes when you use C.</p>
",0
23568686,23568612,1,"<p>This is not a forward declaration of a <code>point</code>, this is a <code>typedef</code> for it<sup> *</sup>. The <code>typedef</code> lets you write</p>

<pre><code>point p;
</code></pre>

<p>instead of</p>

<pre><code>struct point p;
</code></pre>

<p>The forward declaration effect is not used in your code. However, with the <code>typedef</code> in place you could start using <code>point</code> as a type name, rather than a <code>struct</code> tag, inside the declaration of the <code>point</code> structure.</p>

<p>A more common way of achieving the same effect is to combine the definition and the <code>typedef</code>, like this:</p>

<pre><code>typedef struct point {
   int    x;
   int    y;
} point;
</code></pre>

<p><sup> *</sup> The <code>typedef</code> happens to forward-declare the type, but that is a ""side effect"".</p>
",4
23568733,23568612,2,"<pre><code>typedef struct point point;
struct point {
   int    x;
   int    y;
   point *next; /* Could be used */
};
</code></pre>

<p>vs</p>

<pre><code>// typedef struct point point;
struct point {
   int    x;
   int    y;
   point *next; /* error: unknown type name ¡®point¡¯ */
};
</code></pre>
",0
23568836,23568612,2,"<p><a href=""http://en.wikipedia.org/wiki/Typedef"" rel=""nofollow""><h3>What is typedef?</h3></a></p>

<blockquote>
  <p>The
  purpose of typedef is to form complex types from more-basic machine
  types and assign simpler names to such combinations. They are most
  often used when a standard declaration is cumbersome, potentially
  confusing, or likely to vary from one implementation to another.</p>
</blockquote>

<p>So <code>typedef struct point point;</code> is not a forward declaration which you assume. It <em>names</em> <code>struct point</code> to be <code>point</code>, so that whenever you write <code>point</code> later, it will refer to <code>struct point</code>.</p>

<p>So now, you can declare a variable as <code>point p;</code> rather than <code>struct point p;</code>.</p>
",1
24109484,24109435,4,"<p>To solve the problem, just use <code>double</code>:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    double men,wmen,litm,litwo,illit,lit,tot=80000,illitwmen;
    men=(52.0/100.0)*80000.0;
    wmen=tot-men;
    lit=(48.0/100.0)*80000.0;
    litm=(35.0/100.0)*80000.0;
    litwo=lit-litm;
    illitwmen=wmen-litwo;
    printf(""Hence the total illiterate men of the town is %d\n"",men-litm);
    printf(""Hence the total illiterate women is %d\n"",illitwmen);
    return 0;
}
</code></pre>

<p>EDIT: I hate mobile answering</p>
",0
24109503,24109435,1,"<p>Use instead (if you want to stay with integers):</p>

<pre><code>men=(52*80000)/100;
wmen=tot-men;
lit=(48*80000)/100;
litm=(35*80000)/100;
</code></pre>

<p>Also, you may have to deal with rounding.</p>
",0
31144780,31144667,2,"<p>Here you write <em>out of bounds</em></p>

<pre><code>arr[j][1]=0;
</code></pre>

<p>This is because you write to the second element of an array with only one element.</p>

<p>The size of <code>arr[x]</code> (for any valid <code>x</code>) is just one.</p>

<p>Writing out of bounds leads to <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow""><em>undefined behavior</em></a>.</p>
",2
31144793,31144667,3,"<p><code>int arr[a][1];</code> There is only one column and not two.You should use</p>

<pre><code>  int arr[a][2];
</code></pre>
",0
31144870,31144667,2,"<p>Your arrays should be something like this :</p>

<pre><code>arr[row][col] where row denotes the number of rows and col the no of coloumns.
</code></pre>

<p>Therefore arr[a][1] is a array of a rows and 1 coloumn and therefore your code works wrong.</p>

<p>Your array should be a[a][2]. It means arr is a array with a rows and 2 coloumn.Similarly you have to change the other arr[][] 's throughout the code. </p>
",0
32986667,17362046,0,"<p>you need not to use <code>fread()</code> Even the <code>fgetc()</code> works well. Simple coding. SImple as reading a text file.</p>

<pre><code>#include &lt;stdio.h&gt;

int main(int argc, char** argv)
{
    FILE* f = fopen(""lak"", ""rb"");
    fseek(f,0,SEEK_END);
    long lsize=0,i=0;
    lsize = ftell(f);
    rewind(f);

    while(i&lt;lsize){
        int first = fgetc(f);
        i++;
        printf(""first byte = %x\n"", (unsigned)first); //you can do anything with 
                                                      //first now
    }

fclose(f);

return 0;
}
</code></pre>
",0
21034262,21034253,8,"<pre><code>*(char**)bar;
</code></pre>

<p>Cast <code>bar</code> to a pointer to pointer to <code>char</code> and dereference, which results in a pointer to <code>char</code> (i.e., a <code>char*</code>).</p>

<p>Remember that pointers are merely indirection.  When you dereference a pointer you ""drop a star"", i.e.:</p>

<pre><code>char ***p = ...;
p    -&gt; char***
*p   -&gt; char**
**p  -&gt; char*
***p -&gt; char
</code></pre>
",0
21034315,21034253,1,"<p>I don't know what type <code>bar</code> is without the cast, but here goes:</p>

<p><code>bar</code> is being cast into a pointer to a pointer to a <code>char</code>.</p>

<p>The <code>*</code> before the <code>(char **)</code> is ""dereferencing"" the value to its right. In this case, it is returning the <code>char *</code> pointer held in the location pointer to by <code>bar</code>.</p>

<p>The result of the ""dereferencing"" is a <code>char *</code> -- pointer to a character -- which is assigned to the <code>foo</code> variable of the same type.</p>
",0
21034375,21034253,3,"<p>Beginners and experts alike can benefit from getting the basics really solid.</p>

<ul>
<li>A ""<em>variable</em> of type t"" is a storage location which can be used to store or fetch a <em>value</em> of type t.</li>
<li>A ""<em>pointer</em> to t"" is a <em>value</em>.</li>
<li>Applying the dereferencing operator <code>*</code> to a ""pointer to t"" produces a ""variable of type t"".</li>
</ul>

<p>So what have we got?</p>

<pre><code>void *bar = whatever;
char *foo = *(char **)bar;
</code></pre>

<ul>
<li><code>bar</code> is a variable of type ""pointer to void"".</li>
<li><code>foo</code> is a variable of type ""pointer to char"".</li>
<li>casting <code>bar</code> to <code>char**</code> reads the variable <code>bar</code> and fetches a value of type ""pointer to void"". That value is then converted into a value of type ""pointer to pointer to char"".</li>
<li>Dereferencing that value produces a variable of type ""pointer to char"".</li>
<li>The value of that variable is then fetched, and the value is assigned to variable <code>foo</code>.</li>
</ul>

<p>Make sense?</p>
",1
30140860,30140859,2,"<p>Assuming you know there will be a newline, the solution is to consume one character, and then decide:</p>

<pre><code>10 - LF ... Unix style newline
13 - CR ... Windows style newline
</code></pre>

<p>If it's <code>13</code>, you have to consume one more character (10)</p>

<pre><code>const char x = fgetc(stdin); // Consume LF or CR
if (x == 13) fgetc(stdin); // consume LF
</code></pre>
",0
30141729,30140859,1,"<p>There are a few more <a href=""http://en.wikipedia.org/wiki/Newline#Representations"" rel=""nofollow"">newline conventions</a> than that. In particular, all four involving CR <code>\r</code> and LF <code>\n</code> -- <code>\n</code>, <code>\r</code>, <code>\r\n</code>, and <code>\n\r</code> -- are actually encoutered in the wild.</p>

<p>For reading text input, possibly interactively, and supporting all of those four newline encodings at the same time, I recommend using a helper function something like the following:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;locale.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;

size_t get_line(char **const lineptr, size_t *const sizeptr, char *const lastptr, FILE *const in)
{
    char  *line;
    size_t size, have;
    int    c;

    if (!lineptr || !sizeptr || !in) {
        errno = EINVAL; /* Invalid parameters! */
        return 0;
    }

    if (*lineptr) {
        line = *lineptr;
        size = *sizeptr;
    } else {
        line = NULL;
        size = 0;
    }

    have = 0;

    if (lastptr) {
        if (*lastptr == '\n') {
            c = getc(in);
            if (c != '\r' &amp;&amp; c != EOF)
                ungetc(c, in);
        } else
        if (*lastptr == '\r') {
            c = getc(in);
            if (c != '\n' &amp;&amp; c != EOF)
                ungetc(c, in);
        }
        *lastptr = '\0';
    }

    while (1) {

        if (have + 2 &gt;= size) {

            /* Reallocation policy; my personal quirk here.
             * You can replace this with e.g. have + 128,
             * or (have + 2)*3/2 or whatever you prefer. */ 
            size = (have | 127) + 129;

            line = realloc(line, size);
            if (!line) {
                errno = ENOMEM; /* Out of memory */
                return 0;
            }

            *lineptr = line;
            *sizeptr = size;
        }

        c = getc(in);
        if (c == EOF) {
            if (lastptr)
                *lastptr = '\0';
            break;
        } else
        if (c == '\n') {
            if (lastptr)
                *lastptr = c;
            else {
                c = getc(in);
                if (c != EOF &amp;&amp; c != '\r')
                    ungetc(c, in);
            }
            break;
        } else
        if (c == '\r') {
            if (lastptr)
                *lastptr = c;
            else {
                c = getc(in);
                if (c != EOF &amp;&amp; c != '\n')
                    ungetc(c, in);
            }
            break;
        }            

        if (iscntrl(c) &amp;&amp; !isspace(c))
            continue;

        line[have++] = c;
    }

    if (ferror(in)) {
        errno = EIO; /* I/O error */
        return 0;
    }

    line[have] = '\0';
    errno = 0; /* No errors, even if have were 0 */
    return have;
}

int main(void)
{
    char   *data = NULL;
    size_t  size = 0;
    size_t  len;
    char    last = '\0';

    setlocale(LC_ALL, """");

    while (1) {
        len = get_line(&amp;data, &amp;size, &amp;last, stdin);
        if (errno) {
            fprintf(stderr, ""Error reading standard input: %s.\n"", strerror(errno));
            return EXIT_FAILURE;
        }

        if (!len &amp;&amp; feof(stdin))
            break;

        printf(""Read %lu characters: '%s'\n"", (unsigned long)len, data);
    }

    free(data);
    data = NULL;
    size = 0;

    return EXIT_SUCCESS;
}
</code></pre>

<p>Except for the <code>errno</code> constants I used (<code>EINVAL</code>, <code>ENOMEM</code>, and <code>EIO</code>), the above code is C89, and should be portable.</p>

<p>The <code>get_line()</code> function dynamically reallocates the line buffer to be long enough when necessary. For interactive inputs, you must accept a newline at the first newline-ish character you encounter (as trying to read the second character would block, if the first character happens to be the only newline character). If specified, the one-character state at <code>lastptr</code> is used to detect and handle correctly any two-character newlines at the start of the next line read. If not specified, the function will attempt to consume the entire newline as part of the current line (which is okay for non-interactive inputs, especially files).</p>

<p>The newline is not stored or counted in the line length. For added ease of use, the function also skips non-whitespace control characters. Especially embedded nul characters (<code>\0</code>) often cause headaches, so having the function skip those altogether is often a robust approach.</p>

<p>As a final touch, the function always sets <code>errno</code> -- to zero if no error occurred, nonzero error code otherwise --, including <code>ferror()</code> cases, so detecting error conditions is trivial.</p>

<p>The above code snippet includes a <code>main()</code>, which reads and displays input lines, using the current locale for the meaning of ""non-whitespace control character"" (<code>!isspace(c) &amp;&amp; iscntrl(c)</code>).</p>

<p>Although this is definitely not the fastest mechanism to read input, it is not <em>that</em> slow, and it is a very robust one.</p>

<p>Questions?</p>
",0
25683669,25683554,0,"<p>If I understand what you want correctly and if the numbers will be non-negative.</p>

<p><strong>Solution:</strong></p>

<pre><code>    int solution (int X, int Y, int D)
    {
       int count = 0;

       while (X &lt; Y)
       {
          count++;
          X += D;
       }

        return count;
    }
</code></pre>

<p>The <code>count</code> really doesn't have to be global, since your method will return it.</p>
",0
25683692,25683554,1,"<p>You should not use <code>if .. else</code> to do it. Because it will executed only one time. When the execution of function finished it won't return anything, <code>if</code> does not have <code>return</code> statement!</p>

<p>You should use loop's to do-</p>

<pre><code>int count = 0;
int solution (int X, int Y, int D)
{
   while(X&lt;=Y) // executes till the condition fails
   {
      count++;
      X = X+D;
   }
}
</code></pre>

<p>In this case you are having <code>count</code> as a global variable. So no need to return it. but if you have it as a local one you should return it-</p>

<pre><code>int solution (int X, int Y, int D)
{
   int count = 0;
   while(X&lt;=Y) // executes till the condition fails
   {
      count++;
      X = X+D;
   }
   return count;
}
</code></pre>
",1
25683717,25683554,0,"<pre><code>int solution (int X, int Y, int D){
    int count;
    for(count = 0; X &lt;= Y; X += D)
        ++count;
    return count;
}
</code></pre>
",0
25683730,25683554,3,"<p>You should use division to solve this problem:</p>

<pre><code>if (X &gt; Y)
  return 0;

int count = (Y - X) / D + 1;   
return count;
</code></pre>
",0
26247347,26247296,1,"<p>""Scanf matches a sequence of non-white-space characters; the next pointer must be a pointer to character array that is long enough to hold the input sequence and the terminating null character ('\0'), which is added automatically. The input string stops at white space or at the maximum field width, whichever occurs first."" taken from Rafal Rawiki.</p>

<p>In other words, you don't get the whole sentence.</p>

<p>You can use fgets() to get the whole line</p>
",0
28475121,28474299,1,"<p>No, there's no a memory leak here.</p>

<p>The key thing is that you've declared and initialized an <strong>array</strong> of chars. You could have done that two ways, which are effectively the same:</p>

<p>First way:</p>

<pre><code>char str[] = {'h', 'e', 'l', 'l', 'o', '\0'};
</code></pre>

<p>Here compiler knows you want an array of chars, and it figures the array length and contents via by-element initialization. So, you have an array of 6 chars.</p>

<p>Second way:</p>

<pre><code>char str[] = ""hello"";
</code></pre>

<p>Here compiler once again knows you want an array of chars. Array of chars, this is a kind of special case, can be initialized with a string literal. It's length is 5 printed characters plus one for the string terminating <code>NUL</code>. So you have an array of 6 chars.</p>

<p>Changing any certain element of this array doesn't lead to a memory leak, since you can still access any array element with <code>str[i]</code>. You just have to make sure, you don't get out of array bounds with <code>i</code>.</p>

<p>Try to compare to this:</p>

<pre><code>int arr_int[] = {10, 20, 30, 40, 50};
arr_int[2] = 0; 
</code></pre>

<p>Is there a memory leak in this snippet? -- No, there isn't.</p>
",0
28474455,28474299,2,"<p>Your snippet has 2 memory areas to consider:</p>

<p>The area for the string literal <code>""hello""</code>, composed of 6 bytes (<code>'h'</code>, <code>'e'</code>, <code>'l'</code>, <code>'l'</code>, <code>'o'</code>, <code>'\0'</code>) and the area for the variable <code>str</code>, also composed of 6 bytes (copies of the string literal).</p>

<p><strong>Neither of these memory areas will ever move around, change size or be altered in any way whatsoever, so there is no chance for a memory leak.</strong></p>

<p>You can change the <em>contents</em> of the memory area reserved for <code>str</code>; you cannot change the <em>contents</em> of the memory area reserved for the string literal.<br>
Setting <code>str[2]</code> to <code>'\0'</code> is perfectly ok.</p>
",0
28475032,28474299,1,"<p>There are two possibilities: either <code>char str[] = ""hello"";</code> is inside a function, or it is outside of a function.</p>

<p>If it is inside a function, then the array will be allocated on the stack, so as soon as your function returns the stack will be reclaimed, so no harm done.</p>

<p>If it is outside of a function, then the array will be allocated in the static data segment.  When you truncate it by placing a zero in the middle of it, the memory is still there, and you can later replace the zero with 'l' and you will get ""Hello"" back.  No harm done, either.</p>

<p>The only scenario under which we speak of memory leaks is when we allocate memory dynamically, for example with malloc().  If you allocate memory with <code>p = malloc( 1 );</code> and then forget the pointer to it (say, with <code>p = NULL;</code> or with another <code>p = malloc( 1 );</code> without first doing <code>free( p );</code>) then you have introduced a tiny, tiny memory leak.</p>
",0
21045270,15868175,0,"<p><em>Since feature requests to <a href=""https://meta.stackexchange.com/questions/82099/answering-comment-answered-questions"">mark a comment as an answer</a> remain declined, I copy the above solution here.</em></p>

<ol>
<li>do something like printf(&quot;executing...\r&quot;); to erase just print something again (or a lot of spaces).</li>
<li>scanf doesn't &quot;eat&quot; symbol &quot;\n&quot;, so, first getchar just returns last &quot;\n&quot;.</li>
</ol>
<p>¨C  Eddy_Em</p>
",0
22108357,22108136,1,"<p>This works:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt; 
#define BUFFER_SIZE 256

// self-referential structure
struct stackNode
{   
  char* data;
  struct stackNode *pNext;
};

typedef struct stackNode StackNode;
typedef StackNode *StackNodePtr;

// function prototypes
void push(StackNodePtr* pTop, char* value);
//int pop( StackNodePtr *pTop );
//int isEmpty( StackNodePtr pTop );
void printStack( StackNodePtr pCurrent );


int main( void )
{
  char *pToken = NULL;
  int counter;
  char input[BUFFER_SIZE];
  StackNodePtr pStack = NULL;

  printf(""Please enter a line of text here :\n"");
  gets(input);

  pToken = strtok(input, "" "");

  while(pToken != NULL)
  {
    push(&amp;pStack, pToken);
    printf(""%p  '%s'\n"", pToken, pToken);
    pToken = strtok(NULL, "" "");
  }
  printf(""I am out of while loop"");
  printStack(pStack); 
  return 0;
}


// Insert a node at the stack top
void push( StackNodePtr* pTop, char* value )
{ 
  StackNodePtr pNew;

  pNew = (StackNode*)malloc( sizeof( StackNode ) );

  if ( pNew != NULL )
  {   
    pNew-&gt;data = value;
    pNew-&gt;pNext = *pTop; // insert at top of stack
    *pTop = pNew;
  }
  else
  {
    printf( ""%s not inserted. No memory available.\n"", value );
  }
} 

// output stack contents to the console
void printStack( StackNodePtr pCurrent )
{ 
  if ( pCurrent == NULL )
  {
    printf( ""The stack is empty.\n\n"" );
  }
  else
  { 
    printf( ""The stack is:\n"" );

    while ( pCurrent != NULL )
    { 

      printf( ""%s"", pCurrent-&gt;data );
      pCurrent = pCurrent-&gt;pNext; // move to next element
    }
    printf( ""NULL\n\n"" );
  } 
}
</code></pre>

<h3>Input:</h3>

<blockquote>
  <p>welcome to the den</p>
</blockquote>

<h3>Output:</h3>

<pre><code>0x7fff31d13fc0  'welcome'
0x7fff31d13fc8  'to'
0x7fff31d13fcb  'the'
0x7fff31d13fcf  'den'
I am out of while loopThe stack is:
denthetowelcomeNULL
</code></pre>

<p>I really only modified the code to compile on a reasonable machine. Just make sure you aren't printing character arrays as decimal types. I didn't fix any other issues, so no guarantees, just that THIS bit compiles and runs. I'm assuming you are going to add onto it later. Just make sure you are tracking your memory allocations.</p>
",4
22108450,22108136,0,"<p>I suspect the main problem is the mismatch between the prototype for push and it's definition.</p>

<pre><code>void push( StackNodePtr *pTop, char value );
</code></pre>

<p>Vs</p>

<pre><code>void push( StackNodePtr *pTop, char *value )
</code></pre>

<p>When I tried to compile the original it would not even compile, but maybe some broken would compile it and perhaps ignore the definition.</p>

<p><a href=""http://ideone.com/k1s064"" rel=""nofollow"">Here</a> is a working version with the only change being to assign the declaration with the definition. Note that there are a shedload of warnings - you should address these as well.</p>
",1
29239672,29239645,4,"<p>You can use an array, and convert the argument to <code>int</code> using <a href=""http://www.cplusplus.com/reference/cstdlib/atoi/"" rel=""nofollow""><code>atoi</code></a>:</p>

<pre><code>int main(int argc, char *argv[])
{
    if (argc &lt; 2)
    {
        printf(""Program needs an int argument!\n"");
        return 1;
    }

    int n = atoi(argv[1]);

    if (n &lt; 1 || n &gt; 10)
    {
        printf(""The argument must be in the range 1-10!\n"");
        return 2;
    }

    int test[n];
    // use test...
    return 0;
}
</code></pre>

<p>This creates an <code>int</code> array with <code>argv[1]</code> elements, <em>if</em> the program is executed with at least one argument, and the first argument is within the range [1, 10]. If the first argument is not in the range of an <code>int</code> i.e. [<code>INT_MIN</code>, <code>INT_MAX</code>], the program will cause undefined behavior.</p>

<p>Without VLA (variable-length array) support, you can use a dynamic array:</p>

<pre><code>int* test = malloc(n * sizeof(int));
</code></pre>

<p>Or you can simply make an array of size 10 and only use the first <code>n</code> elements of that array.</p>
",14
29240068,29239645,2,"<p>A straight forward dynamic allocation of the array is another acceptable way to approach the problem. For a small number of inputs in a known range, static allocation is fine, but when flexibility is needed, allocating dynamically, provides a way to grow the array as necessary and is generally safer from a portability standpoint that some of the other options. Here is a quick example:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define MAXELE 10

int main (int argc, char **argv) {

    /* test for required input */
    if (argc &lt; 2) {
        fprintf (stderr, ""error: insufficient input.  usage: %s int (no. of array elements)\n"", argv[0]);
        return 1;
    }

    /* convert input to numeric form */
    size_t nelements = atoi (argv[1]);
    size_t i = 0;

    /* test values for 1 - 10 */
    if ( nelements &lt; 1 || nelements &gt; MAXELE ) {
        fprintf (stderr, ""error: input not within 1 - %d.\n"", MAXELE);
        return 1;
    }

    /* allocate nelements int for array &amp; initialize to 0 */
    int *array = calloc (nelements , sizeof *array);

    /* test allocation succeeded, if not exit */
    if (!array) {
        fprintf (stderr, ""error: memory allocation failed.\n"");
        return 1;
    }

    /* fill array with some numbers */
    for (i = 0; i &lt; nelements; i++)
        array[i] = (i + 2) * i;

    /* print array */
    for (i = 0; i &lt; nelements; i++)
        printf ("" array[%2zu]  %d\n"", i, array[i]);

    /* free memory allocated to array */
    if (array) free (array);

    return 0;
}
</code></pre>

<p><strong>Use/Output</strong></p>

<pre><code>$ ./bin/nintarray 10
 array[ 0]  0
 array[ 1]  3
 array[ 2]  8
 array[ 3]  15
 array[ 4]  24
 array[ 5]  35
 array[ 6]  48
 array[ 7]  63
 array[ 8]  80
 array[ 9]  99
</code></pre>
",0
29239944,29239645,1,"<p>Just for the fun of taking questions verbatim: This solution actually allocates N variables on the stack in a recursion, not only an array with N items. You should not do this in a serious context:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

typedef struct vars {
    struct vars *previous;
    int value;
} vars_t;

int run_main(vars_t *variables)
{
    vars_t *var;
    for (var = variables; var; var = var-&gt;previous) {
        printf(""%p = %d\n"", (void *) var, var-&gt;value);
    }
    return 0;
}

int alloc_vars(int n, vars_t *previous)
{
    if (n == 0) {
        return run_main(previous);
    }

    vars_t current;
    current.previous = previous;
    current.value = n;
    return alloc_vars(n-1, &amp;current);
}

int main(int argc, char **argv)
{
    if (argc != 2) {
        return 1;
    }

    char *err_pos = NULL;
    long n = strtol(argv[1], &amp;err_pos, 10);
    if (err_pos == argv[1] || *err_pos || n &lt; 0) {
        return 2;
    }

    return alloc_vars(n, NULL);
}
</code></pre>
",1
23093184,23093100,0,"<pre><code>while ((getchar())!='\n');
</code></pre>

<p>The above line is used to flush anything on the line not read by <code>scanf</code>, for example non-digits and spaces, so the next input starts in a new line.</p>

<p>Also:</p>

<ul>
<li><code>scanf</code>-call should check the number of assigned matches (0 matches <em>is</em> possible.</li>
<li>the result of <code>malloc</code> should never be cast (that just hides bugs).</li>
<li>the result of <code>malloc</code> should be checked for <code>NULL</code>. (Warning: <strong>Undefined Behavior</strong>)</li>
<li><code>fgets</code> expects the buffer length and guarantees 0-termination. Passing one less means you get a shorter string.</li>
</ul>
",7
26116325,26116162,1,"<p>It's a <a href=""https://stackoverflow.com/questions/840501/how-do-function-pointers-in-c-work"">function pointer</a> that's being passed, that's likely been <a href=""http://www.cprogramming.com/tutorial/typedef.html"" rel=""nofollow noreferrer"">typedef</a>-ed. This means that the location of the <code>case_send_browser_event</code> is being passed, so that it can alter the behavior of the <code>casweare_register_cb_uievent</code> function. </p>

<p>This kind of passing is very helpful in algorithms where you'd want to maximize for different things on the fly, so changing the Boolean function used to do a compare from a minimize to a maximize would provide opposite behavior for a sort algorithm.</p>
",0
26116509,26116162,4,"<p><code>casware_register_cb_uievent (cas_send_browser_event_cb , NULL);</code></p>

<p>is passing a pointer to the function <code>casware_register_cb_uievent</code></p>

<p>To understand a little more consider the following code.</p>

<pre><code>#include&lt;stdio.h&gt;


void hello()
{
        printf(""hello world"");
}

void world(void (*fun)())
{
         fun();
}

main()
{
        world(hello);
}
</code></pre>

<p>Here the function <code>world</code> is similar to the function <code>casware_register_cb_uievent</code></p>

<p><code>void world(void (*fun)())</code> the function <code>world</code> accepts a pointer to a function which is pointed by  <code>fun</code></p>

<p>now when the function <code>hello</code> (similar to the function <code>cas_send_browser_event_cb</code>) is given as input it is similar to assining the pointer as </p>

<p><code>fun = hello</code></p>

<p>the function call</p>

<p><code>fun()</code> in <code>world</code> calls the function pointed by it, <code>hello</code> 
producing output as </p>

<p><code>hello world</code></p>

<p>when a function is declaread as</p>

<p><code>void (*fun)();</code>
a function pointer is created. </p>

<p>The function pointer can be assigned using name of another function to which it is to be pointed</p>

<p><code>fun = hello;</code></p>

<p>now on calling the pointer, <code>fun</code> the function being pointed, <code>hello</code> is intern called</p>
",0
26815746,26815623,2,"<pre><code>char *tmp = strdup(wholeProgramStr); /* makes a copy to be writeable */
char *pch;
char *pch2;

pch = strstr(tmp, ""/*""); /* pointer to first occurrence */
if (pch) { /* founded */
    pch += 2; /* skip ""/*"" */
    pch2 = strstr(pch, ""*/""); /* pointer to second occurrence */
    if (pch2) { /* founded */
        *pch2 = '\0'; /* cut */
        printf(""%s\n"", pch);
    }
}
</code></pre>

<p>As pointed out by @alk, there is no need to duplicate the string if you only need to print the result:</p>

<pre><code>char *pch;
char *pch2;

pch = strstr(wholeProgramStr, ""/*""); /* pointer to first occurrence */
if (pch) { /* founded */
    pch += 2; /* skip ""/*"" */
    pch2 = strstr(pch, ""*/""); /* pointer to second occurrence */
    if (pch2) { /* founded */
        printf(""%*s\n"", pch2 - pch, pch));
    }
}
</code></pre>

<p><strong>EDIT:</strong></p>

<blockquote>
  <p>How would I run this again until it reaches the end of the string? So
  it can find multiple comments?</p>
</blockquote>

<p>Loop until you don't find both delimiters:</p>

<pre><code>char *tmp = wholeProgramStr;
char *pch;

while (1) {
    pch = strstr(tmp, ""/*""); /* pointer to first occurrence */
    if (pch) { /* founded */
        pch += 2; // skip ""/*""
        tmp = strstr(pch, ""*/""); /* pointer to second occurrence */
        if (tmp) { /* founded */
            printf(""%*s\n"", tmp - pch, pch));
            tmp += 2; // skip ""*/""
        } else break;
    } else break;
}
</code></pre>
",6
26815759,26815623,3,"<p>Your idea to use <code>strstr</code> is good, but it doesn't give you a null-terminated string. It gives you a pointer to the beginning of the string and the string's length via pointer arithmetic. You can print a char array that is limited by its length by specifying a width with the <code>%s</code> format in <code>printf</code>:</p>

<pre><code>void str_print_between(const char *str, 
    const char *left, const char *right)
{
    const char *begin, *end;
    int len; 

    begin = strstr(str, left);
    if (begin == NULL) return;
    begin += strlen(left);

    end = strstr(begin, right);
    if (end == NULL) return;

    len = end - begin;
    printf(""'%.*s'\n"", len, begin);
}
</code></pre>

<p>Depending on what you want to do, you can return both start pointer and length (via pointers or as a <code>struct</code>) from your function. There are many <code>strn*</code> functions that act equivalent to their <code>str*</code> counterparts, but take an additional maximum length, so you could use those to process your string further.</p>

<p>Treating line comments works just the same as with block comments, just with other delimiters. (But this simple solution does not heed the context; it will detect comments in or across strings, for example.)</p>
",0
21016492,21016419,3,"<p>What you really want is to dereference:</p>

<pre><code>*res
</code></pre>
",0
21016496,21016419,6,"<p><code>res</code> is a pointer to a pointer, so you need to dereference it before you use it. You're right that <code>res[0]</code> isn't the right way to do that though in this context. Use <code>(*res)</code> instead.</p>
",6
21017035,21016419,2,"<p>Why do you need to pass a pointer pointer anyway? You could just as well change it to this:</p>

<pre><code>char *add_str(char *str1, char *str2)
{
    char *res = malloc((strlen(str1) + strlen(str2) + 1));
    if (res == NULL)
        return NULL;

    char *ret = res;

    while(*str1 != 0)
        *res++ = *str1++;

    while(*str2 != 0)
        *res++ = *str2++;

    *res = '\0';
    return ret;
}
</code></pre>

<p>It has the same effect and you don't have to deal wit that ugly construct.</p>
",2
21017327,21016419,2,"<p>This is not a direct answer to your question, but more of a general coding advice:</p>

<p>In order to properly manage all dynamic memory operations within your program, you should strive (try as much as you can) to have both operations <code>x=malloc(...)</code> and <code>free(x)</code> executed from the same function.</p>

<p>In most cases, if you design your code correctly, then you can achieve this.</p>

<p>In some cases, when the flow is asynchronous, it is impossible to do so. For example, one function allocates the buffer, and after some event occurs in the system, another function (AKA callback) releases the buffer.</p>

<p>In such cases, you should still try to have both operations within the same ""scope"" (class, file or module).</p>

<p>In your coding example, function <code>add_str</code> allocates the buffer but does not release it, which means some other function will eventually have to do it (or you will have memory leaks). Hence, if possible, then you should try to perform the <code>malloc</code> outside of this function.</p>
",7
21017557,21016419,0,"<p>I would use another pointer variable to hold the result string, which avoids dereferencing the result variable all the time. Apart from that, of course, you should avoid using the array subscript operator where a simple pointer dereference is what you do. I have also made a few other changes to your example code to make it more concise, feel free to ignore them.</p>

<pre><code>void add_str(char *str1, char *str2, char **res) {
    char* result = *res = malloc((strlen(str1) + strlen(str2) + 1) * sizeof(char));
    //Dereferencing a NULL pointer will safely crash your program on any sane system.
    //if (!result) return;
    int   j = 0;    //Since C99 you are allowed to mix code and variable declarations.
    for(int i = 0; str1[i]; i++) result[j++] = str1[i];
    for(int i = 0; str2[i]; i++) result[j++] = str2[i];
    result[j] = '\0';
}
</code></pre>

<p>If pointers are used to their full potential, your code can look like this:</p>

<pre><code>void add_str(char *str1, char *str2, char **res) {
    char* result = *res = malloc((strlen(str1) + strlen(str2) + 1) * sizeof(char));
    while(*str1) *result++ = *str1++;
    while(*str2) *result++ = *str2++;
    *result = '\0';
}
</code></pre>
",0
31273985,31273943,5,"<p>Fix your first <code>scanf</code> call (you need to pass a pointer):</p>

<p><code>scanf(""%d"", &amp;o);</code></p>

<p>Put a space between subsequent <code>scanf</code> calls:</p>

<p><code>scanf("" %d"", &amp;age);</code></p>

<p>This passes over the newline character entered on a previous iteration.</p>
",3
23822357,23822255,2,"<p>You're never telling <code>gcc</code> to compile <code>atomic_logger.c</code>, or link against it.</p>

<p>The simplest remedy would be </p>

<pre><code>$ gcc -o ex8/chainforkopenlog ex8/chainforkopenlog.c ex8/atomic_logger.c 
</code></pre>

<p>This tells <code>gcc</code> to <em>compile</em> all of the listed <code>.c</code> files and <em>link</em> them together for the final output binary - all in one invocation.</p>

<p>The alternative is to <em>compile only</em> each <code>.c</code> file independently to its corresponding <code>.o</code> file using the <code>-c</code> switch. Then <em>link</em> all of the <code>.o</code> files together for the output binary.</p>

<pre><code>$ gcc -c ex8/chainforkopenlog.c       # Produces chainforkopenlog.o
$ gcc -c ex8/atomic_logger.c          # Produces atomic_logger.o

$ gcc -o ex8/chainforkopenlog chainforkopenlog.o atomic_logger.o
</code></pre>

<p>Note that <code>#include ""atomic_logger.h""</code> doesn't have anything to do with the final link process - it doesn't automagically inform GCC to look at <code>atomic_logger.c</code>. It merely copy+pastes the contents of that header file at the location where it is included.</p>
",1
24078975,24078746,8,"<p>The function <code>sscanf_s</code> is a Microsoft invention, intended to be ""more secure"" than the standard <code>sscanf</code> function.</p>

<p>As such, if you are using <code>""%s""</code> or <code>""%c""</code>, it requires <strong>two</strong> parameters: One being the buffer to write the input to, and <em>an integer specifying the available size of the buffer</em>, so that a long input string does not result in a buffer overflow.</p>

<p>Unfortunately this is not quite that obvious to users of the function (like yourself), resulting in frequent mis-use of the function (which somewhat reduces the ""security"" implied).</p>

<p><a href=""http://msdn.microsoft.com/en-US/en-en/library/t6z7bya3.aspx"" rel=""noreferrer"">Link to the Microsoft docs</a>; refer to the section ""remarks"".</p>

<p>So what you have here is undefined behaviour, as <code>sscanf_s</code> attempts to read an integer from the stack where you haven't put one. You end up lucky that the memory read is apparently zero, so zero bytes are written to <code>numString</code>.</p>

<p>This should do nicely:</p>

<pre><code>size_t BUFSIZE = 50;
char numString[ BUFSIZE ];
sscanf_s( line.c_str(),
          ""&lt;float_array id=\""%*s[^\""]\"" count=\""%*d\""&gt;%[^&lt;]s"",
          numString, BUFSIZE );
</code></pre>

<hr>

<p>Note that <code>numString</code> better actually <em>be</em> a <code>char[]</code>. Your question was initially tagged as C++; if <code>numString</code> is actually a <code>std::string</code>, be advised that you cannot use the <code>scanf</code> family function with <code>std::string</code> parameters.</p>

<hr>

<p>(Sorry for the edits, got it wrong the first few times. That format string is something... ;-) )</p>
",10
24096984,24078746,1,"<pre><code>char numString[ 256 ];
sscanf_s( line.c_str(),
          ""&lt;float_array id=\""%*[^\""]\"" count=\""%*d\""&gt;%255[^&lt;]"",
          numString, 256);
</code></pre>
",2
23845524,23845321,1,"<p><a href=""https://stackoverflow.com/questions/18565663/while-c-getchar-eof-not-terminating"">Someone asked the same question here</a>
It should answer your question, good explanation by many people</p>

<p>summary of the source and my answer:<br>
EOF indicates ""end of file"".  Use CTRL-D (unix-style systems) or CTRL-Z (Windows), and the loop will terminate</p>
",0
23845556,23845321,0,"<p>Try this version:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
  long nc = 0;

  do
  {
    printf(""%ld chars read so far, hit any key or Ctrl-D/Ctrl-Z to end.\n"", nc);
    ++nc;
  } while (getchar() != EOF)

  printf(""total number of chars entered: %ld\n"", nc);  
}
</code></pre>
",0
23845364,23845321,3,"<p>It's because you're not inputting anything. EOF doesn't mean that there are no characters available; getchar() just waits for input. EOF means you have it CTRL+Z or CTRL+D.</p>
",0
22441128,22441070,5,"<pre><code>char *new_path;
strcat(new_path, path);
</code></pre>

<p>Is undefined behavior.</p>

<p>There is no memory for strcat to append to since new_path is uninitialized and unallocated. strcat appends to an undeterminated address, creating a segfault.</p>
",1
22441224,22441070,2,"<p>The prototype of the standard library function <code>strcat</code> is</p>

<pre><code>char *strcat(char *dest, const char *src);
</code></pre>

<p>Here, <code>dest</code> and <code>src</code> both are strings, they may not overlap and <code>dest</code> must be large enough for the string pointed by <code>src</code> to be appended to it.</p>

<p>In your code, in the statement</p>

<pre><code>strcat(new_path, path);
</code></pre>

<p><code>new_path</code> is a pointer to a character, not a string. It's not null terminated and not large enough for the string pointed to by <code>path</code> to be appended to it. <code>strcat</code> call attempts illegal memory access causing undefined behaviour and program crash due to segfault. You must allocate a buffer either dynamically or statically to concatenate strings to it.</p>

<pre><code>#define MAX_LEN 40+1  // max buffer length. +1 for terminating null byte 

char new_path[MAX_LEN] = {0};  // initialize to null bytes

strcat(new_path, path);
// more strcat calls
</code></pre>

<p><strong>Edit:</strong> As mentioned in the comment, the maximum buffer length is not known beforehand. In that case, memory should be dynamically allocated using <code>calloc</code> and <code>realloc</code>.</p>

<pre><code>int size = strlen(path) + 1;
char *temp = NULL; // for holding new_path in case realloc fails
char *new_path = calloc(size, sizeof path[0]);
if(new_path == NULL) {
    printf(""Not enough memory.\n"");
    // handle it
}

strcat(new_path, path);
temp = new_path;
new_path = realloc(new_path, size *= 2); // double the size of the buffer
if(new_path == NULL) {
    printf(""Not enough memory.\n"");
    // handle it
}

// check if new_path is large enough for concatenation
const char *catstr = ""somestring""; // string to be appended
if(size &lt;= strlen(new_path) + strlen(catstr)) {
    // allocate more memory
    temp = new_path;
    new_path = realloc(new_path, size *= 2); // double the buffer size
    if(new_path == NULL) {
        printf(""Not enough memory.\n"");
        // handle it
    }
}

strcat(new_path, catstr);

// and so on
</code></pre>

<p>This gets unwieldy with all the checks for <code>NULL</code> but there's no easy way out when you deal with dynamic memory allocation.</p>
",3
26426256,26426129,4,"<p>First change the call to:</p>

<pre><code>char date[] = ""3.10.2014"";
change_date(date);
</code></pre>

<p>This makes <code>date</code> into an array which you can actually modify, as opposed to a string literal which you cannot.</p>

<p>Then write <code>change_date()</code>, using e.g. <code>sscanf()</code> and <code>sprintf()</code>:</p>

<pre><code>void change_date(char *s)
{
  int y, m, d;

  if(sscanf(s, ""%d.%d.%d"", &amp;d, &amp;m, &amp;y) == 3)
  {
    sprintf(s, ""%d-%d-%d"", y, m, d);
  }
}
</code></pre>

<p>The above does <em>not</em> use <code>%04d</code> to format the year, in the hopes of being slighly less likely to break if the available buffer space is too small.</p>

<p>It would be better to also accept a <code>size_t s_max</code> argument and use <code>snprintf()</code>, and have a return value. I opted for brevity.</p>
",0
28190247,28190179,2,"<blockquote>
  <p>""I called my squareOfInteger function from my printf statement. Is this advisable though?""</p>
</blockquote>

<p>There is nothing wrong in calling the function from within a function. It depends on case, where you say need to retain the squared value (as not in your case where you just need to print the value) and perform other operations on it. like:</p>

<pre><code>int value = myFun(100);
int nextVal = myNextFun(value);
</code></pre>

<blockquote>
  <p>""The other thing nagging at me is whether or not I need to reiterate the type as being an int inside the parameter of my function before my variable number, or whether it is enough to declare the result as being of type int, and leaving out type in the parameter, which I have done below.""</p>
</blockquote>

<p>Yes you should use define the type of number (in your case as by default it would be integer type and would fail if you have it of other type) as a best practice as it will make code more clear and readable.</p>
",1
28190271,28190179,6,"<blockquote>
  <p>I called my squareOfInteger function from my printf statement. Is this
  advisable though? It worked but I'm worried this might be bad
  practice?</p>
</blockquote>

<p>Calling a function from <code>printf()</code> is not bad. But there might be scenarios leading to undefined behavior since the order of evaluation within <code>printf()</code> is not specified.For example:</p>

<pre><code>int func(int *p)
{
   *p =30;
}
int main()
{
   printf(""%d %d"",num,func(&amp;num));
   return 0;
}
</code></pre>

<p>Here you are calling <code>func()</code> as well as printing the value of <code>num</code> so you have UB.</p>

<blockquote>
  <p>whether it is enough to declare the result as being of type int, and
  leaving out type in the parameter</p>
</blockquote>

<p>If the type of the argument is not specified then it defaults to <code>int</code>.But it is always good to mention the type of the arguments.</p>
",2
34190854,34190776,5,"<p>On Borland C compiler, the size of int is 16-bits. So the statement</p>

<pre><code>h = (h&lt;&lt;8)+(h&lt;&lt;6);
</code></pre>

<p><a href=""https://en.wikipedia.org/wiki/Integer_overflow"">overflows a signed integer</a>. The individual shift operations are fine as the results are within the limit of what a 16-bit signed integer can hold. But the addition results in overflow. Signed integer overflow is <a href=""https://en.wikipedia.org/wiki/Undefined_behavior""><em>undefined behaviour</em></a> in C.</p>
",2
34190944,34190776,1,"<p>It seems In the environment where the program was run type <code>int</code> has width of 2 bytes and its maximum value is <code>+32767</code>. </p>

<p>So when a positive value exceedes this limit then the sign bit can be set and you get a negative value.</p>

<p>You can check the maximum poisitive value that can be stored in an object of type int the following way</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;limits.h&gt;

int main( void )
{
    printf( ""The maximum is %d\n"", INT_MAX );
}
</code></pre>

<p>Instead of the type int you could use type <code>unsigned int</code> or type <code>long</code> or <code>unsigned long</code></p>

<p>For example the maximum value for type <code>unsigned int</code> provided by your compiler can be equal to <code>65535</code>. It is enough to store the result of your expression.</p>
",0
22513793,22512877,2,"<p>There are four different issues to consider here:</p>

<p>1) The size of the argument of <code>malloc</code>. It is of type <code>size_t</code>, which is an unsigned integer type that is at least 16 bits and large enough to hold the size of any object or the index of any array. In practice it tends to be the platform's native word size, i.e., 32 bits for 32-bit platforms, and 64 bits for 64-bit platforms, so you are likely to need at least a 32-bit platform, but this almost certainly the case unless developing for embedded (or very retro) systems.</p>

<p>One should also remember that the argument may overflow and you can silently end up <em>successfully</em> allocating less memory than you thought you'd get (e.g., you may effectively call <code>malloc(65534)</code> when you thought you were calling <code>malloc(2 * 65535)</code>). But in this case it is very unlikely to be an issue for any platform capable of allocating this amount of memory.</p>

<p>2) Whether the <code>malloc</code> calls succeed. You are already checking for this, so simply running the code will answer this. You are allocating over 8 GB? of memory here, so it is likely that it will fail unless compiled for 64 bits (since the maximum addressable memory for 32 bits is 4 GB).</p>

<p>3) Whether you can actually use all the memory you've allocated. Some operating systems will overcommit memory and allow you to allocate much more memory than is actually available. You may run into trouble if you actually try to <em>use</em> all the memory you've allocated. This depends on the OS and the amount of memory actually available, possibly including swap.</p>

<p>4) Whether it is practical for the machine the program is run on to actually have that much data in memory. Even if the <code>malloc</code> calls succeed and the OS lets you use the memory allocated, it is still over 8 GB, which means that a typical machine should probably have at least 12 GB of RAM installed to accommodate this, the OS, and other programs. Otherwise it may swap like crazy, despite theoretically working.</p>

<p>You have revealed in comments that you are running a 64-bit machine with 4 GB of RAM installed, so if you compile for 64 bits the first two points are not an issue, but point 3 may be, and point 4 almost certainly will be. So, either install more RAM or figure out a different way to handle the data (e.g., if you are storing a graph as per the variable name, perhaps it is often sparse enough that you don't need to allocate for the worst case).</p>

<p>? ¡°over 8 GB¡± comes from <code>65535 * sizeof(short *) + 65535 * 65535 * sizeof(short)</code>, where <code>sizeof(short)</code> is very likely to be <code>2</code>, and <code>sizeof(short *)</code> (the pointer size) either 4 or 8. There is also some extra overhead for <code>malloc</code>'s bookkeeping, but still it rounds to ¡°over 8 GB¡±.</p>

<p>Some stylistic observations:</p>

<ul>
<li>It would be better style to use one of the types from <code>stdint.h</code> if you want specifically 16 bits, e.g., <code>uint16_t</code> or <code>uint_least16_t</code></li>
<li>You should not cast the return value of <code>malloc</code> in C (unlike in C++)</li>
<li>You can replace <code>sizeof(unsigned short int *)</code> with <code>sizeof(*graph)</code> and <code>sizeof(unsigned short int)</code> with <code>sizeof(**graph)</code> to avoid repetition (and allow you to change the type of <code>graph</code> without changing the <code>malloc</code> calls)</li>
<li>You don't need the <code>int</code> in <code>unsigned short int</code></li>
</ul>
",0
22513949,22512877,0,"<p>The maximum size of non-arrayed data is <code>SIZE_MAX</code>.  <code>SIZE_MAX</code> is <em>at least</em> 65535.</p>

<p><code>SIZE_MAX</code> is type <code>size_t</code> which is often the same type as <code>unsigned</code> but may be different.</p>

<p>The single largest allocation available using <code>malloc()</code> is <code>SIZE_MAX</code>.  </p>

<pre><code>void *malloc(size_t size);
</code></pre>

<p><code>sizeof(unsigned short int *) * 65535</code> may fail due to integer math overflow.</p>

<p>To allocate an array larger than <code>SIZE_MAX</code> (but each element is still &lt;= <code>SIZE_MAX</code>), use <code>calloc()</code>.</p>

<pre><code>void *calloc(size_t nmemb, size_t size);
unsigned short int **graph = calloc(65535u, sizeof *graph);
</code></pre>
",3
22512963,22512877,0,"<p>Max allowed size will be range of integer. So if you are using 16 bit OS max size is 65535, if you are using 32 bit OS size will be 4,294,967,295. </p>
",10
26442902,26442803,-1,"<p>You have two instances of</p>

<pre><code>printf(""|%s|\n"", input);
</code></pre>

<p>one before you read into input and one after; just remove the first one, which is accessing <code>input</code> before it is set, resulting in undefined behavior.</p>

<blockquote>
  <p>isn't that a new array at every loop?</p>
</blockquote>

<p>Only conceptually; in practice, in most implementations, it's the same memory (which is allocated on the stack). That's why you're seeing the results from the previous iteration. On the first iteration you're printing whatever junk happens to be on the stack (which is probably NULs). With an implementation that really allocated a new array on every iteration, you would be printing junk on every iteration ... or your program could crash; again, it's undefined behavior.</p>

<p>Also, you should check if fgets returns NULL -- which indicates EOF or error -- and terminate your loop if so, not just if you read an 'e'. The contents of <code>input</code> after fgets returns NULL is indeterminate.</p>
",1
26442972,26442803,1,"<blockquote>
  <p>However, it seems that there are leftovers at the current loop, from the previous loop. But I declare input inside the loop, so isn't that a new array at every loop?</p>
</blockquote>

<p>Each time you enter the scope in the loop, for each iteration, you have an array with undefined content.  That is how local arrays declared in functions work.  So your first pass through the loop could (theoretically) have <code>input</code> containing anything.  In your case it <em>happened</em> to be an effectively empty string...but that wasn't required.  Subsequent iterations <em>happened</em> to have the previous content...but again not required, it could contain anything.</p>

<p>Note that if an array is declared <em>globally</em> in C then the elements will be set to the default values:</p>

<p><a href=""https://stackoverflow.com/questions/2091499/why-global-and-static-variables-are-initialized-to-their-default-values"">Why are global and static variables initialized to their default values?</a></p>

<p>Though you are effectively <em>""getting a 'new' (uninitialized) array every loop""</em>, it's important to realize you are also <em>""losing the old array every loop""</em>.  While it is likely in this case that the array will be getting the same memory address on each iteration, that is not a guarantee.  You could not save the address of the array in a pointer declared outside the loop and be assured it would be the same on subsequent iterations.</p>
",0
27765220,27765157,1,"<p>The smallest part of memory you can easily access is a byte, so there would be no use making an address for every bit.</p>
",0
27765226,27765157,0,"<p>Memory is addressed in bytes rather than bits, you have to accept this as a matter of fact. Once you get a value of a certain byte in a memory you can work with its bits using logical (bitwise) functions or operators, such as &amp;, |, ^, ~ etc. See <a href=""http://www.cprogramming.com/tutorial/bitwise_operators.html"" rel=""nofollow"">http://www.cprogramming.com/tutorial/bitwise_operators.html</a></p>

<p>Moreover, the address is not stored in hexadecimal format, the hexadecimal format is only the format of the number printed to the output. If you used other formatter %d rather than %p in your printf call you will get decadic format. See <a href=""http://www.cplusplus.com/reference/cstdio/printf/"" rel=""nofollow"">http://www.cplusplus.com/reference/cstdio/printf/</a></p>
",3
27765240,27765157,2,"<p>The memory is organized in terms of bytes, and pointers point to a specific byte, not to a single bit. The reason is probably that early computers had 8-bit registers/... and usually whole bytes were processed at once. Since the computer was operating on whole bytes, addressing bytes instead of single bits made more sense. It also saves address space, allowing for more memory to be addressed with the same pointer size.</p>

<p>Also the memory addresses are not really stored in hexadecimal format, they are just formatted that way when printed out. Internally in memory they are binary numbers just like all the other numbers a computer works with.</p>
",2
25705319,25705296,2,"<p>change the names.</p>

<p>There are no ""namespaces"" in C. They were added to C++. In C everything at the global scope has to have a unique name.</p>

<p>So prefix your stuff</p>

<pre><code>A_Function1
A_Function2

B_Function1
B_Function2
</code></pre>

<p>etc.</p>

<p>If you only need 1 implementation (say one is for Mac and other for Windows) then of course only link one in or use <code>#if</code> to turn one off</p>

<pre><code>// a.h
#if USE_A
...
#endif  // USA_A

// a.c
#if USE_A
...
#endif  // USE_A
</code></pre>

<p>Same for B. Then when you compile you can use</p>

<pre><code>cc -DUSE_A=1
</code></pre>

<p>Otherwise if you need to switch implementations at runtime (say OpenGL vs DirectX backends) this is often done with function pointers.</p>

<p>You make yet another file with pointers to functions. You then fill in those pointers to functions with either functions from implementation A or B. All other files only reference the function pointers. </p>

<pre><code>// a.h
int A_SomeFunc(int arg1);

// a.c
#include ""a.h""
int A_SomeFunc(int arg1) {
  ...
}

// b.h
int B_SomeFunc(int arg1);

// b.c
#include ""b.h""
int B_SomeFunc(int arg1) {
  ...
}

// virtual.h
extern int (*SomeFunc)(int arg1); 

void Init(int implementation) // 0 = A, 1 = B

// virtual.c
#include ""a.h""
#include ""b.h""

int (*SomeFunc)(int arg1);

void Init(int implementation) {
  switch (implementation) {
    case 0: // use A
      SomeFunc = A_SomeFunc;
      break;
    case 1: // use B;
      SomeFunc = B_SomeFunc;
      break;
  }
}
</code></pre>

<p>Now somewhere at the start of your program you need to call <code>Init</code>. Then other files can include <code>virtual.h</code> and will use whatever implementation you selected in <code>Init</code>.</p>

<p>To take it to the next level, put <code>SomeFunc</code> in a struct.</p>

<pre><code>struct SomeAPI {
 int (*SomeFunc)(int arg1);
};
</code></pre>

<p>Now change Init to fill out SomeAPI</p>

<pre><code>void Init(struct SomeAPI* someAPI, int implementation) {
  switch (implementation) {
    case 0: // use A
      someAPI-&gt;SomeFunc = A_SomeFunc;
      break;
    case 1: // use B;
      someAPI-&gt;SomeFunc = B_SomeFunc;
      break;
  }
}
</code></pre>

<p>Now you've effectively made the virtual functions of C++ classes. Other modules would do something like</p>

<pre><code>struct SomeAPI api;
Init(&amp;api, 1);  // choose B
int result = api.SomeFunc(someIntArgument);
</code></pre>

<p>Or</p>

<pre><code>struct SomeAPI* pAPI = malloc(sizeof(SomeAPI));
Init(pAPI, 1); // choose B
int result = api-&gt;SomeFunc(someIntArgument);
</code></pre>
",1
31903655,31903554,2,"<p>How to use headers:</p>

<h3>a.h</h3>

<pre><code>int DoA();
int DoA2();
</code></pre>

<h3>a.c</h3>

<pre><code>#include &lt;b.h&gt;
int DoA()
{
   return 1 + DoB();
}
int DoA2()
{
   return 2;
}
</code></pre>

<h3>b.h</h3>

<pre><code>int DoB();
</code></pre>

<h3>b.c</h3>

<pre><code>#include &lt;a.h&gt;
int DoB()
{
   return 1 + DoA2();
}
</code></pre>

<p>And with safe guards, you'd do:</p>

<h3>a.h</h3>

<pre><code>#ifndef _INCL_A
#define _INCL_A

int DoA();
int DoA2();

#endif
</code></pre>
",1
33023465,33023343,1,"<p>well ... this is the right code ...</p>

<pre><code>#include &lt;stdio.h&gt;
struct test {
char *a;
char *b;
};

struct test test_main;
void modif_value(char *val) {
test_main.a = val;
}
int main () {
char c='1';
modif_value(&amp;c);
printf (""value after modif is %s \n"", test_main.a);
return 0;
}
</code></pre>

<ol>
<li>don't forget ... after struct definition you should use (;)</li>
<li>modif_value doesn't return anything so write VOID in the prototype</li>
<li>you should pass an address to modif_value function ! not the character ! </li>
</ol>
",2
25548610,25547707,2,"<p>Your code gives the answer 2091059712 right? The correct answer is an order of magnitude greater than that.</p>

<p>You're bumping into integer overflow.</p>

<p><code>a[i] * a[i+1] * ....</code></p>

<p>is getting calculated as an <code>int</code>, which is typically only 2-4 bytes wide.
You correctly store the result as a <code>long int</code> (8 bytes in your case), but by then it's too late.</p>

<p>The way around this is to calculate the product step by step.</p>

<p><code>long int product = 1;
for ( j = 0; j &lt; 13; j++ ) product *= a[i + j];
if ( s &lt; = product ) s = product;</code></p>

<p>This has the added advantage of being <em>much</em> easier to read.</p>
",4
25547972,25547707,1,"<p>This will be no exhaustive answer, but directives so you can rewrite your code, because no sane person will debug that.</p>

<ul>
<li><p>Store <code>a</code> in static memory. <s>This thing is 4 megabytes, and you're dangerously close to (if not past) busting your stack.</s> This can be done by making <code>a</code> a global (put it outside of <code>main</code>), or a static local (declare it as <code>static int a[]</code>). Declaring it <code>const</code> can be a good idea too. Also, give it a meaningful name. <strong>Edit:</strong> evidence has proven that I don't know how to count. Still, that array has no sense being a mutable automatic variable.</p></li>
<li><p>Loops will save you. Your whole <code>a[i]*a[i+1]*a[i+2]*a[i+3]*...*a[i+N]</code> is always the same term, with a counter from 0 to N. Hey, a counter, that's what a loop can do, right ?</p></li>
<li><p>Format your code properly. Indentation and alignment go a long way of making a code snippet readable.</p></li>
</ul>

<p><strong>Edit:</strong> I tried it, and your result should be <code>23514624000</code> (23,514,624,000).</p>
",4
34086869,34086305,0,"<p>Zero-copy means no data copying between user space and kernel space. In this program, we are copying data from the user space buffer to kernel space to transmit that data using socket.</p>

<p>When we need to transfer data out from a file using a socket, we can use sendfile system call, passing it the socket and file descriptor.</p>

<p>Please refer to the link <a href=""http://www.linuxjournal.com/article/6345?page=0,0"" rel=""nofollow"">http://www.linuxjournal.com/article/6345?page=0,0</a> which gives useful information on zero copy.</p>
",0
23841539,23841426,5,"<p>It is invalid and not needed in procedural language like <code>C</code>. (May be useful in languages which do lazy evaluation for ex: <code>Haskell</code>).</p>

<p>Imagine a use case of your example</p>

<pre><code>struct A { 
  struct B b;
};
struct B {
  struct A a;
};
Struct A a;
a.b.a.b.a.b.......[infinitely]
</code></pre>

<p>But yes sometimes you need to refer structures of type <code>A</code> and <code>B</code> into each other, in that case you can use pointers.</p>

<pre><code>struct child;
struct parent;

struct child { 
  ...
  struct parent *pParent;
};

struct parent {
  ...
  struct child *children[2];
};
</code></pre>

<p>Now the possible use case would be:</p>

<pre><code>struct child pikachu;
...
if(pikachu.pParent != NULL) {
  struct child *pPikachuSibling;
  pPikachuSibling = (pikachu.pParent.children[0] == &amp;pikachu) ?
                           pikachu.pParent.children[1] :
                           pikachu.pParent.children[0];
  if(pPikachuSibling != NULL) {
    do_something_with(pPikachuSibling);
  }
}
</code></pre>

<p>In <code>C</code> a field can not have <a href=""http://docs.oracle.com/cd/E19205-01/819-5265/bjals/index.html"" rel=""nofollow"">incomplete type</a><sup>[a]</sup>, but field are allowed to be pointers to incomplete type.</p>

<p>About Self referential struct, using pointers, you can achieve this requirement.</p>

<pre><code>assert( pikachu.pParent.children[0] == &amp;pikachu) ||
        pikachu.pParent.children[1] == &amp;pikachu) );
</code></pre>

<hr>

<p><sup>
[a] Quoting from <code>ISO/IEC 9899:TC2 Committee Draft ¡ª May 6, 2005 WG14/N1124</code>
</sup></p>

<blockquote>
  <p><sup>109) An incomplete type may only by used when the size of an object of that type is not needed. It is not
  needed, for example, when a typedef name is declared to be a specifier for a structure or union, or
  when a pointer to or a function returning a structure or union is being declared. (See incomplete types
  in 6.2.5.) The specification has to be complete before such a function is called or defined.</sup></p>
</blockquote>

<p><strong><sup>6.2.5 Types</sup></strong></p>

<blockquote>
  <p><sup>22 An array type of unknown size is an incomplete type. It is
  completed, for an identifier of that type, by specifying the size in a
  later declaration (with internal or external linkage). A structure or
  union type of unknown content (as described in 6.7.2.3) is an
  incomplete type. It is completed, for all declarations of that type,
  by declaring the same structure or union tag with its defining content
  later in the same scope.</sup></p>
</blockquote>
",1
31224064,31223895,3,"<p>The problem is that you place the result of the <code>byte_to_binary()</code> function in a <code>static</code> buffer.  The statement where <code>printf()</code> is called actually makes both calls to <code>byte_to_binary()</code> before transferring control to <code>printf()</code>.  So <code>printf()</code> just displays the same buffer twice.</p>

<p>You'll need to do something like have <code>byte_to_binary()</code> return a string that's allocated dynamically then free it later (in which case you can't easily use it in a call to <code>printf()</code> without a memory leak), or you'll need to change the interface so that the output buffer is passed into <code>byte_to_binary()</code>.  Just have <code>byte_to_binary()</code> return the pointer that is passed in and you can call it from <code>printf()</code> like you're doing now.</p>
",0
33521848,33521191,1,"<blockquote>
  <p>how come the output of line 27 is not the same?</p>
</blockquote>

<p>In ""line 27"" </p>

<ul>
<li><p><code>&amp;dd.a[0]</code> evaluates to the address of <code>dd.a</code>'s first element.</p></li>
<li><p><code>p-&gt;pc</code> <em>holds</em> the address of the string literal <code>""testasdfsadfasdfasdfas...""</code> as assigned in this line</p>

<pre><code>p-&gt;pc = ""testasdfsadfasdfasdfas..."";
</code></pre></li>
</ul>

<p>(You are aware one cannot assign arrays in C, aren't you?)</p>
",1
33522872,33521191,0,"<p>You are doing everything in the stack. So you aren't needing to malloc anything to the heap. You don't segfault because your program still has access to the memory you assigned your string to (accounting for the fact that you can't assign strings).</p>
",0
22516022,22515994,8,"<p>You wrote a dash <code>¨C</code> instead of a hyphen <code>-</code>. Spot the difference:</p>

<pre><code>... 3*2 ¨C 5;
... 3*2 - 5;
</code></pre>
",1
22516033,22515994,6,"<p>It seems that you have copied pasted the code from elsewhere. In expression  </p>

<pre><code>a=12 + 10/2 + 3*2 ¨C 5;  
                  ^ is not minus sign   
</code></pre>

<p>Change it to <code>-</code></p>
",0
22516055,22515994,3,"<p>In your expression that's not a minus sign, judging by eye it's an en-dash, which is not accepted by the compiler. Don't write code in Word or ""normal"" word processors, use plain text editors. </p>
",1
23832374,23831972,1,"<p>Make a <code>node</code> struct that represents a position in the matrix, with one of its elements being a <code>node*[8]</code> or <code>node**</code> to represent the available paths out of the node. Each node needs a <code>char value</code> to tell you what it is labelled by. They also need a <code>int traversed</code> which I'll talk about later.</p>

<p><a href=""http://simplestcodings.blogspot.ca/2013/09/graphs.html"" rel=""nofollow"">Here</a> is a discussion on graphs in C instead using an adjacency matrix (a bit more efficient).</p>

<p>The path that they generate will basically be a string of the <code>char value</code> that are traversed. Since you know that you can only have <code>n * m</code> total unique paths in this, you can just make a fixed size <code>char* path</code> that is no more than <code>n * m + 1</code> characters (the last one is for <code>\0</code>, of course).</p>

<p>Perform a <a href=""http://en.wikipedia.org/wiki/Depth-first_search"" rel=""nofollow"">Depth first search</a> on the graph you have constructed starting from each of the nodes, creating a list of all possible <code>char*</code> paths. Make sure that in the DFS you mark each node that you hit as <code>traversed = 1</code> so that you don't repeat any (and of course if you hit a <code>traversed == 1</code> node just stop that particular path). Very important that you reset all the nodes to <code>traversed = 0</code> after you're done with them. </p>
",1
22492464,22492435,3,"<blockquote>
  <p>When something is cast to void, then the value becomes NULL.</p>
</blockquote>

<p>Not true. Nothing happens to the pointed data.</p>

<blockquote>
  <p>Shouldn't a void pointer just be useless?</p>
</blockquote>

<p>A void pointer is the closest thing C has to a ""generic type"" and is very useful in that it allows things like somewhat generic functions, somewhat generic containers etc.</p>
",0
22492465,22492435,8,"<p>A void pointer is a pointer to anything.  It is a generic pointer that doesn't have a particular type.  It can also have the value <code>NULL</code> in which case it doesn't point to anything.
To use a void pointer, you have to keep track of what it actually points to and when you are going to use it, you must cast it to the appropriate type.</p>

<p>They can be dangerous, because if you cast it to the wrong type, it will result in undefined behavior at runtime.</p>
",0
22492477,22492435,2,"<p><code>void *</code> is a generic object pointer. Note that there is no generic function pointer.</p>

<p>You can convert any object pointer value to <code>void *</code> and back without loss of value.</p>
",0
22872410,22872380,2,"<p>Use modulo arithmetic</p>

<pre><code>i = (i+3) % 4
</code></pre>
",5
22872429,22872380,0,"<p>Should be pretty simple:</p>

<pre><code>i = (i+3)%4
</code></pre>
",3
22872543,22872380,4,"<p>The operation you want to perform is fairly simple: if <code>i</code> is 0, set it to 3, otherwise decrement it.</p>

<p>Your code should express that operation as clearly as possible. The code in your question does that reasonably well.</p>

<p>You could also use the <code>%</code> remainder operator, but it <em>might</em> impose too much overhead if the cycle length isn't a power of 2 (as it happens to be in this case).</p>

<p>I'd be tempted to write the code a bit more tersely:</p>

<pre><code>i = (i==0 ? 3 : i-1);
</code></pre>

<p>It's easy to get carried away and write code that looks like line noise (and code speed is <em>not</em> related to the number of characters in an expression), but in this case I think the conditional operator is clear enough.</p>
",1
22872549,22872380,3,"<p>Since you explicitly asked for bitwise operators, this:</p>

<pre><code>i=(i-1) &amp; 0x03;
</code></pre>

<p>should do the trick. Only works if the first number which you <em>don't</em> want to see is 2, 4, 8, 16, 32,...</p>
",2
22872668,22872380,0,"<p>Why not something like this with nary a division or conditional branch in sight (excluding the <code>while</code>):</p>

<pre><code>#include &lt;limits.h&gt;
...
unsigned int  cnt = UINT_MAX ;
unsigned char i   ;
while ( 1 )
{
  i = 0x00000003U &amp; (cnt--) ;
  do_something_useful(i) ;
}
</code></pre>

<p>pretty sure you'll get tight code that simply loads a register with <code>UINT_MAX</code> and loops around stuffing <code>i</code> with the appropriate value.</p>
",0
21181819,21181800,2,"<p>Try to do it exactly as you would do that on paper. For small divisors (as 2) this is an O(d) algorithm (where d is the number of digits) and it is impossible to find anything asymptotically better since you need to check each digit at least once.</p>
",0
26146693,26146548,5,"<p>So, <code>pos % 62</code> returns a number between <code>[0, 61]</code>. So when you do <code>(pos%62)-1</code>, you get a number between <code>[-1, 60]</code>. Which you likely don't want.</p>

<p>You should probably rewrite this line:</p>

<pre><code>string[i]=arry[(pos%62)-1];
</code></pre>

<p>as:</p>

<pre><code>string[i] = arry[pos % 62];
</code></pre>
",0
26146857,26146548,2,"<p>Here's a test harness.   I would add some bounds checking to the input otherwise you can overrun the array.</p>

<pre><code>    #include &lt;stdio.h&gt;
    #include &lt;stdlib.h&gt;

    void valueof(int pos,int len)
...

   int main (int argc, char **argv) {
     valueof(atoi(argv[1]), atoi(argv[2]));
   }
</code></pre>

<p>To compile gcc vo.c -o vo</p>

<pre><code>./vo 1 3
000
./vo 109 3
k10
</code></pre>
",0
29955485,29955409,4,"<p>This code</p>

<pre><code>#define ELEMENTS 1
....
double Angstroms[ELEMENTS];
double Energy[ELEMENTS];
</code></pre>

<p>Is making two arrays with one element each (so max index would be 0). When you try to access the element at index 1 of Angstroms, you're getting into undefined behavior. You just happen to have stumbled upon a situation in which it didn't segfault.</p>

<hr>

<p>Edit: see, for example <a href=""https://stackoverflow.com/questions/9137157/no-out-of-bounds-error"">this question.</a> It looks like you made a similar mistake defining n, which I believe should also be 2.</p>

<p>Furthermore, I don't think that you're going to get the output you said you want when the program runs correctly, I think you'd get</p>

<pre><code>1.00000000 2.00000000
1.00000000 6.00000000
</code></pre>

<p>You're setting ax[i][0] to 1 each time, and then printing it as the first number on each line, then printing Angstroms[i], which was the first number on the ith input line. At least if I'm understanding this code right:</p>

<pre><code>ax[i][0] = 1;
ax[i][1] = Angstroms[i];
fprintf (outfile, ""%.8f %.8f\n"", ax[i][0], ax[i][1]);
</code></pre>

<p>Don't be discouraged if it seems confusing!</p>
",1
29955622,29955409,1,"<p>This might help:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#define ELEMENTS 2

double Angstroms[ELEMENTS];
double Energy[ELEMENTS];

void file_input ();
void polynomial ();

int main () {
     file_input ();
     polynomial ();
   return 0;
 }

void file_input () {

     float a, b;
     int i;

     FILE * in_file = fopen(""H2.txt"", ""r"");
     for (i = 0; i &lt; ELEMENTS; i++) {
          fscanf(in_file, ""%f %f\n"", &amp;a, &amp;b);
          Angstroms[i] = a;
          Energy [i] = b;
     }
     fclose(in_file);
}

void polynomial () {

      int i;
      FILE * outfile = fopen(""PolyTest1.txt"", ""w"");
      if (outfile == NULL) {
         printf (""Error file does not exist"");
         exit (-1);
       }
      fprintf (outfile, ""%.8f %.8f\n"", 1.0, 1.0);
      for (i = 0; i &lt; ELEMENTS; i++) {
          fprintf (outfile, ""%.8f "", Angstroms[i]);
      }
      fclose(outfile);
}
</code></pre>
",0
32934393,32933934,0,"<p>Variable that you want is <strong>asciiValue</strong>. <strong>Here is your code:</strong> (I tested)</p>

<pre><code>#include&lt;stdio.h&gt;
#include &lt;string.h&gt;

int * getASCIIValue(char *array) {
    char c;
    int i, ascii;
    int result[100];


    for(i=0; array[i]; i++) {
        ascii = (int)array[i];
        result[i] = ascii;
    }

    return result;
}

void main()
{
    char cInputString[] = ""Hello World"";
    int asciiValue[100], i;


    int *arr = getASCIIValue(cInputString);

    for(i=0; i&lt;strlen(cInputString); i++) {
        asciiValue[i] = arr[i];
    }

    for(i=0; i&lt;strlen(cInputString); i++) {
        printf(""%d"", asciiValue[i]);
    }

    system(""pause"");
}
</code></pre>
",3
32934021,32933934,0,"<p>The ASCII value would be the value of each character in the string. Simply retrieve them by indexing the string.</p>

<pre><code>for ( unsigned int idx = 0; idx &lt; strlen(cInputString); idx++ ) {
    ASCIIValue = cInputString[idx];
}
</code></pre>
",2
32934038,32933934,2,"<pre><code>for ( size_t idx = 0; idx &lt; strlen(cInputString); idx++ ) {
    printf(""ascii of %c = %d \n"",cInputString[idx],cInputString[idx]);
}
</code></pre>
",1
22437212,22436975,0,"<p><code>EOF</code> is an integer value which indicate the end of input. It's a value such that for any character <code>ch</code>, <code>ch == EOF</code> is always false. Therefore, you should always compare a value of <code>int</code> type with <code>EOF</code>, not <code>char</code> type. It's working on your machine because the <code>char</code> type is implemented as <code>signed char</code> but on machines where <code>char</code> type is <code>unsigned char</code>, this won't.</p>

<p>Now coming to the warnings and errors </p>

<ol>
<li><p>The scope of a function is from the point of its definition or declaration till the end of the program. You are calling the functions like <code>isLetter</code> in <code>main</code> before they have been declared. </p></li>
<li><p><code>""\n""</code> is a string literal, not a character. So are <code>"" ""</code> and <code>""    ""</code>. The string literal here evaluates to a pointer to its first element and you are comparing this pointer with a character -  a different type. You should, instead, compare with <code>'\n'</code>, <code>' '</code>, <code>'\t'</code> respectively. </p></li>
</ol>
",0
22437004,22436975,2,"<p>Start with the first error/warning, fix it and then work your way down one by one always compiling after each change. Often, you will find, getting rid of an error/warning on a line also gets rid of others in subsequent lines.</p>

<p>Line 20:</p>

<pre><code>            if(c == ""\n"") linecount++;
</code></pre>

<p>gives the warning</p>

<pre><code>program2.c:20: warning: comparison between pointer and integer
</code></pre>

<p><code>c</code> is a char (internally converted to an integer before the comparison); <code>""\n""</code> is an array[2] of <code>char</code> (internally converted to <code>char *</code> before the comparison).<br>
That's why the compiler complains about comparing an integer and a pointer.</p>

<p>You need to compare <code>c</code> to a character (both will get internally converted to integers)</p>

<pre><code>            if(c == '\n') linecount++;
</code></pre>
",0
22437005,22436975,4,"<p>For</p>

<blockquote>
  <p>program2.c:20: warning: comparison between pointer and integer  </p>
</blockquote>

<p>Change  </p>

<pre><code> if(c == ""\n"")  
</code></pre>

<p>to  </p>

<pre><code> if(c == '\n')  
</code></pre>

<p>For  </p>

<blockquote>
  <p>program2.c:28: error: conflicting types for ¡®isLetter¡¯<br>
  program2.c:28: note: an argument type that has a default promotion can¡¯t match an empty   parameter name list declaration<br>
  program2.c:14: error: previous implicit declaration of ¡®isLetter¡¯ was here<br>
  program2.c:35: error: conflicting types for ¡®isWhitespace¡¯<br>
  program2.c:35: note: an argument type that has a default promotion can¡¯t match an empty   parameter name list declaration
  program2.c:15: error: previous implicit declaration of ¡®isWhitespace¡¯ was here    </p>
</blockquote>

<p>Define prototypes for your functions.  </p>

<pre><code>int isLetter(char c);
int isWhitespace(char c);  
</code></pre>

<p>For</p>

<blockquote>
  <p>program2.c: In function ¡®isWhitespace¡¯:<br>
  program2.c:36: warning: comparison between pointer and integer<br>
  program2.c:36: warning: comparison between pointer and integer<br>
  program2.c:36: warning: comparison between pointer and integer  </p>
</blockquote>

<p>Change  </p>

<pre><code>if(c == ""\n"" || c == "" "" || c == ""      "") return 1;
</code></pre>

<p>to  </p>

<pre><code>if(c == '\n' || c == ' ' || c == '\t') 
</code></pre>
",1
22437121,22436975,2,"<ul>
<li><p>Declare the following functions <strong>before</strong> calling them (i.e., above function <code>main</code>):</p>

<ul>
<li><code>int isLetter(char c);</code></li>
<li><code>int isWhitespace(char c);</code></li>
</ul></li>
</ul>

<hr>

<ul>
<li><p>In function <code>main</code>:</p>

<ul>
<li>Replace the variable-declaration  <code>char c</code>          with <code>int c</code></li>
<li>Replace the function-call         <code>isLetter(c)</code>     with <code>isLetter((char)c)</code></li>
<li>Replace the function-call         <code>isWhitespace(c)</code> with <code>isWhitespace((char)c)</code></li>
<li>Replace the variable-assignment   <code>previous = c</code>    with <code>previous = (char)c</code></li>
<li>Replace the conditional-statement <code>if (c == ""\n"")</code>  with <code>if ((char)c == '\n')</code></li>
</ul></li>
</ul>

<p>The reason for <code>int c</code>, is that function <code>getchar</code> returns <code>int</code> in order support the <code>EOF</code> indicator.</p>

<hr>

<ul>
<li><p>In function <code>isWhitespace</code>, change the conditional-statement to:</p>

<ul>
<li><code>if (c == ' ' || c == '\n' || c == '\r' || c == '\t')</code></li>
</ul></li>
</ul>
",0
23844996,23844962,8,"<p>In c the empty parameter list does not mean <strong>function that takes no arguments</strong>. It means function with <strong>unspecified number of arguments</strong></p>

<p>To declare a function that takes no arguments write : </p>

<pre><code>int func(void);
</code></pre>
",10
23845001,23844962,6,"<p>Because in C,</p>

<pre><code>int slogan();
</code></pre>

<p>declares a function without saying anything about its arguments. This is not a prototype declaration at all, it's an old-style <a href=""https://en.wikipedia.org/wiki/C_%28programming_language%29#K.26R_C"">K&amp;R</a> declaration. The prototype declaration for a function taking to arguments is</p>

<pre><code>int slogan(void);
</code></pre>

<p>The former form exists for backward compability with pre-1989 C, when you couldn't provide argument information in the prototype at all.</p>
",0
23845877,23844962,0,"<p><a href=""https://stackoverflow.com/questions/13950642/why-does-a-function-with-no-parameters-compared-to-the-actual-function-definiti"">Look at First answer here(and second)</a>
The first answer will give you an Accurate explanation of a functions declaration </p>

<p>Section 6.11.6 Function declarators(K&amp;R C)</p>

<blockquote>
  <p>The use of function declarators with empty parentheses (not
  prototype-format parameter type declarators) <strong>is an obsolescent
  feature.</strong></p>
</blockquote>
",0
22117261,22117219,3,"<p>31 in binary representation will be 11111 so ~31 = 5 zeros 00000 preceeded by 1's. so it is to make last 5 bits zero. i.e. to mask the last 5 bits.<br>
here ~ is NOT operator i.e. it gives 1's complement. and &amp; is AND operator.</p>
",0
22117263,22117219,0,"<blockquote>
  <p>&amp; ~31</p>
</blockquote>

<p>means <code>bitwise and</code> of the operand on the left of <code>&amp;</code> and a <code>bitwise not</code> of <code>31</code>.</p>

<p><a href=""http://en.wikipedia.org/wiki/Bitwise_operation"" rel=""nofollow"">http://en.wikipedia.org/wiki/Bitwise_operation</a></p>
",0
22117314,22117219,0,"<p>The number 31 in binary is <code>11111</code> and <code>~</code> in this case is the unare one's compliment operator. So assuming 4-byte <code>int</code>:</p>

<pre><code>~31 = 11111111 11111111 11111111 11100000
</code></pre>

<p>The <code>&amp;</code> is the bitwise AND operator. So you're taking the value of:</p>

<pre><code>((out_bi.biWidth * out_bi.biBitCount) + 31)
</code></pre>

<p>And performing a bitwise AND with the above value, which is essentially blanking the 5 low-order bits of the left-hand result.</p>
",0
22117330,22117219,4,"<p>The <code>&amp;</code> operator is a bitwise AND. The <code>~</code> operator is a bitwise NOT (i.e. inverts the bits). As 31 is binary <code>11111</code>, ~31 is binary <code>1111111....111100000</code> (i.e. a number which is all ones, but has five zeroes at the end). Anding a number with this thus clears the least significant five bits, which (if you think about it) rounds down to a multiple of 32.</p>

<p>What does the whole thing do? Note it adds 31 first. This has the effect that the whole thing rounds something UP to the next multiple of 32.</p>

<p>This might be used to calculate (for instance), how many bits are going to be used to store something if you can only use 32 bit quantities to store them, as there is going to be some wastage in the last 32 bit number.</p>
",0
22117578,22117219,2,"<p><code>&amp;</code> is the <a href=""http://msdn.microsoft.com/en-us/library/17zwb64t.aspx"" rel=""nofollow"">bitwise AND operator</a>. It <em>and's</em> every corresponding bit of two operands on its both sides. In an example, it does the following:</p>

<p><em>Let <code>char</code> be a type of 8 bits.</em></p>

<pre><code>unsigned char a = 5;
unsigned char b = 12;
</code></pre>

<p><em>Their bit representation would be as follows:</em></p>

<pre><code>a     --&gt; 0 0 0 0 0 1 0 1 // 5
b     --&gt; 0 0 0 0 1 1 0 0 // 12
</code></pre>

<p><em>And the bitwise AND of those would be:</em></p>

<pre><code>a &amp; b --&gt; 0 0 0 0 0 1 0 0 // 8
</code></pre>

<p>Now, the <code>~</code> is the <a href=""http://msdn.microsoft.com/en-us/library/s50et82s.aspx"" rel=""nofollow"">bitwise NOT operator</a>, and it negates every single bit of the operand it prefixes. In an example, it does the following:</p>

<p><em>With the same <code>a</code> from the previous example, the <code>~a</code> would be:</em></p>

<pre><code>~a    --&gt; 1 1 1 1 1 0 1 0 // 250
</code></pre>

<p>Now with all this knowledge, <code>x &amp; ~31</code> would be the bitwise AND of <code>x</code> and <code>~31</code>, where the bit representation of <code>~31</code> looks like this:</p>

<pre><code>~31   --&gt; 1111 1111   1111 1111   1111 1111   1110 0000 // -32 on my end
</code></pre>

<p>So the result would be whatever the <code>x</code> has on its bits, other than its last 5 bits.</p>
",0
21018218,21018065,1,"<p><code>buffer</code> is a local variable, wich is destroyed one time <code>fun</code> ends.</p>

<p>if <code>buffer</code> is <code>static</code>, is always in the program.</p>

<p>if you want that <code>fun</code> return an array, you can use dynamic memory.</p>

<pre><code>#include&lt;stdio.h&gt;
#include""string.h""

int main( ){

    char *s;    
    char *fun();

    s = fun();    
    printf (""%s"",s);

    // in c pure 
    //free(s);
    // in c++
    delete s;
}


char *fun(){         
    // in c pure
    //char * buffer = (char*) malloc(30*sizeof(char));        
    // in c++
    char *buffer = new char[30];

    strcpy ( buffer, ""RAM - Rarely Adequate Memory"" );        
    return ( buffer ) ;    
} 
</code></pre>
",2
21018223,21018065,1,"<p>First, pointer to local variable should not be returned. </p>

<p>Second, <code>auto</code> local variable will disappear as soon as the code block (function) exits. But <code>static</code> local variable will stay there till the whole program is ended. For the same reason, you can access that <code>static</code> local variable next time you get into that code block.</p>
",1
21018350,21018065,3,"<p>(automatic) local variables are destroyed as soon as you leave the block where they were declared. Keeping a reference to them is just as wrong as keeping a pointer to a deallocated memory block.</p>

<p>static (local) variables have the same lifespan as the program that declares them.</p>

<p>Implementation-wise, a static variable is allocated in the same space as the global variables.<br>
Semantically, it is still only visible inside the block where it was declared, but it retains its value outside its declaration scope.</p>

<p>Beware, though. Retaining a reference to a static variable might have unpleasant side effects.</p>

<p>For instance, each call to your function will reset the string to its initial value, so the callers should make their own copies of it if they don't want any other piece of the code to be able to mess with the value they got from your function.</p>
",0
21018118,21018065,1,"<p>Without <code>static</code>, the variable <code>buffer</code> passes out of scope as soon as the function <code>fun</code> terminates. The <code>main</code> routine is then left holding a pointer to a defunct variable, and dereferencing it causes <b>Undefined Behavior</b>.</p>
",0
21018125,21018065,2,"<p>You're returning a local variable, which is triggering undefined behaviour. <code>char buffer[30]</code> is a stack variable, so when the function exits, it goes out of scope, and is cleaned up.</p>

<p>Making it <code>static</code> means it is does not go out of scope when the function exits, and thus works correctly.</p>

<p>In C, one would usually fix this by passing in a buffer to write to:</p>

<pre><code>void fun(char *buffer, size_t len)
{
    // Write some stuff into buffer
}
</code></pre>

<p>In C++, use <code>std::string</code>. </p>
",2
21019084,21018065,0,"<p>The <code>buffer</code> without <code>static</code> is placed on the processor's <a href=""http://en.wikipedia.org/wiki/Stack_%28abstract_data_type%29"" rel=""nofollow"">stack</a>.  When <code>fun</code> ends, the stack memory that was used for this function is freed.</p>

<p>But this freeing does not actually change the contents of these used stack memory locations.  This means that the string you copied to <code>buffer</code> will initially still be there.</p>

<p>As the program progresses, this freed stack space (which was first used by your <code>buffer</code>), will get used for other stuff.  But it's hard to tell when this will happen, as it all depends on how the compiler planned to use stack space.</p>

<p>In theory, your program could have nicely printed out <code>RAM - Rarely Adequate Memory</code>; when this part of the stack were not overwritten.  So actually you are lucky, as you could have had a latent bug that could bite at a later stage (for example after you started adding code to <code>main()</code>, or changed compiler options for example.)</p>
",0
30177420,30177405,2,"<p><code>sprintf</code> will print to a string, not the screen.</p>

<p>It's exactly what you're looking for.</p>
",1
30177458,30177405,3,"<p>Not displaying it to screen doesn't invalidate functions like sprintf() since they literally ""print to string"".</p>

<pre><code>int X = 15;
char buffer[10];
memset(&amp;buffer, 0, sizeof(buffer)); // zero out the buffer    
sprintf(buffer, ""%d"", X);
// Expected result : ""15""
printf(""contents of buffer: %s\n"", buffer);
</code></pre>
",0
21178031,21177972,0,"<p>1 you should convert the content you want to send in Big-Endian</p>

<p>2 . it will not, the server recieve what the client send</p>
",0
21178685,21177972,2,"<p>Instead of <code>strlen(sendbuf)</code> in </p>

<pre><code>iResult = send(client_socket, sendbuf, (int32_t)strlen(sendbuf), 0);
</code></pre>

<p>calculate the size appropriately </p>

<pre><code>//         number of pixels + int size + 2 ints for p[0] and p[1]
int size = 160*120*sizeof(uint32_t) + 2 *sizeof(uint32_t);
iResult = send(client_socket, sendbuf, size, 0);
</code></pre>

<p>Also make sure <code>DEFAULT_BUFLEN</code> is equal to more than <code>size</code>. If you want you can define <code>DEFAULT_BUFLEN</code> as that.</p>
",0
24103401,24103380,2,"<p>No, tst is not ""popped"" again.  myfunc merely receives the address of where tst is located on the stack and updates the memory at that address.</p>

<p>Note that taking pointers to automatic (stack) variables and placing them in globals is generally a bad idea.  The pointers cease to be valid as soon as the function exits but the system will not detect that so memory corruption is likely.  Not a problem in this case but also not a good habit to get into.</p>
",1
24103422,24103380,0,"<p>Since ptr is global, when you make it point to some object inside a function, it globally points to the memory location of that object. </p>

<p>You are updating the contents of that memory location in <code>myfunc()</code>, and then accessing the same memory location in <code>main()</code>. So obviously the change you made in <code>myfunc()</code> is visible.</p>
",0
24112515,24103380,0,"<p>When a functions call is made, not all variables are pushed onto the stack. Only those which are arguments of the functions will be pushed onto the stack, i.e: ones in parentheses, like this: <code>myfunc(arg);</code>. In this case, <code>arg</code> will be pushed onto the stack for use in <code>myfunc</code>. The key is to remember that in C its just the values in variables that are pushed, not the variable itself.</p>

<p>You might be after something like this</p>

<pre><code>#include &lt;stdio.h&gt;
int *ptr;

int myfunc(int value);
int myfunc2(int *pValue);

main()
{
   int tst = 3;
   ptr = &amp;tst;
   printf(""tst = %d\n"", tst);
   myfunc(*ptr);
   printf(""tst = %d\n"", tst);
   myfunc2(ptr);
   printf(""tst = %d\n"", tst);
}

void myfunc(int value)
{
    //here you can do whatever you want with the value that was in the global ptr
    //but when you return to main it will not have changed.

    value = value + 10;       //has no effect on tst
}

void myfunc2(int *pValue)
{
    //here the argument is a pointer value. If you de-reference the pointer value
    //with an '*' you start accessing the contents at that address

    *pValue = *pValue + 10;    //does effect the global *ptr
}
</code></pre>
",0
24136498,24136312,1,"<p>No, C has only <code>stderr</code> and <code>stdout</code> and standard output streams. But you can set the buffering on <code>stderr</code> as you please with <code>setvbuf</code>.</p>
",0
24136929,24136312,2,"<p>Yes, using <code>setvbuf</code> and full buffering (<code>_IOFBF</code>):</p>

<blockquote>
  <p>Full buffering: On output, data is written once the buffer is full (or
  flushed). On Input, the buffer is filled when an input operation is
  requested and the buffer is empty.</p>
</blockquote>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    char buff[BUFSIZ];

    setvbuf(stderr, buff, _IOFBF, BUFSIZ);
    fprintf(stderr, ""Hello world\n"");
    getchar();
    fflush(stderr);
    return 0;
}
</code></pre>

<blockquote>
  <p>The value of BUFSIZ is chosen on each system so as to make stream I/O
  efficient. So it is a good idea to use BUFSIZ as the size for the
  buffer when you call setvbuf.</p>
</blockquote>
",0
25483448,25483031,5,"<p>You defined <code>_XOPEN_SOURCE=500</code>. According to the <a href=""http://pubs.opengroup.org/onlinepubs/007908799/xsh/gettimeofday.html"" rel=""noreferrer"">X/Open 5</a>, the second argument is of type <code>void*</code> and must be <code>NULL</code>:</p>

<blockquote>
<pre><code>int gettimeofday(struct timeval *tp, void *tzp);
</code></pre>
  
  <p>[..]</p>
  
  <p>If tzp is not a null pointer, the behaviour is unspecified. </p>
</blockquote>

<p>If you want the prototype specified in the linux manual, you need to</p>

<pre><code>#define __USE_BSD
</code></pre>

<p>However, if you pass anything other than <code>NULL</code>, it will return an error.</p>
",0
25483530,25483031,1,"<p>You can just get rid of the 'tzp' variable.</p>

<p>From the gettimeofday man page:</p>

<blockquote>
<pre><code>If either tv or tz is NULL, the corresponding structure is not set or returned.

The use of the timezone structure is obsolete; the tz argument should normally be specified as NULL.
</code></pre>
</blockquote>

<p>So your code should be something like:</p>

<pre><code>#include &lt;time.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/resource.h&gt;

double get_time()
{
    struct timeval t;
    gettimeofday(&amp;t, NULL);
    return t.tv_sec + t.tv_usec*1e-6;
}
</code></pre>
",0
25459071,25459043,5,"<p>If by <code>top n</code> you mean the <code>n</code>-th highest (or lowest) number in the array, you may want to look at the <a href=""http://en.wikipedia.org/wiki/Quickselect"" rel=""nofollow"">QuickSelect</a> algorithm. Unfortunately there is no C library function I am aware of that implements it but Wikipedia should give you a good starting point.</p>

<p>QuickSelect is O(n) on average, if O(nlogn) and some overhead is fine as well, you can do <code>qsort</code> and take the <code>n</code>'th element.</p>

<p><strong>Edit</strong> (In response to example) Getting all the indexes of the top-n in a single batch is straightforward with both approaches. QuickSelect sorts them all on one side of the final pivot.</p>
",4
25459391,25459043,2,"<p>So you want the top n numbers in a big array of N numbers. There is a straightforward algorithm which is O(N*n). If n is small (as it seems to be in your case) this is good enough.</p>

<pre><code>size_t top_elems(int *arr, size_t N, size_t *top, size_t n) {
  /*
     insert into top[0],...,top[n-1] the indices of n largest elements 
     of arr[0],...,arr[N-1]
  */
  size_t top_count = 0;
  size_t i;
  for (i=0;i&lt;N;++i) {
    // invariant: arr[top[0]] &gt;= arr[top[1]] &gt;= .... &gt;= arr[top[top_count-1]]
    // are the indices of the top_count larger values in arr[0],...,arr[i-1]
    // top_count = max(i,n);
    size_t k;
    for (k=top_count;k&gt;0 &amp;&amp; arr[i]&gt;arr[top[k-1]];k--);
    // i should be inserted in position k
    if (k&gt;=n) continue; // element arr[i] is not in the top n
    // shift elements from k to top_count
    size_t j=top_count;
    if (j&gt;n-1) { // top array is already full
      j=n-1;
    } else { // increase top array
      top_count++;
    }
    for (;j&gt;k;j--) {
      top[j]=top[j-1];
    }
    // insert i
    top[k] = i;
  }
  return top_count;
}
</code></pre>
",3
21323119,21322852,1,"<p>well, table lookup is the fastest method I think. The problem is base because it's not, well, ""bit-aligned"". if your base was 2^n, then you could use bitwise shifts and ANDs to get indices, and now you have to use division and deal with remainder</p>
",0
22109190,22109151,3,"<p>When you call a function the compiler hasn't seen a prototype for, it applies the <a href=""https://stackoverflow.com/questions/1255775/default-argument-promotions-in-c-function-calls"">default argument promotions</a> to all arguments. Chars and shorts are promoted to ints, and floats are promoted to doubles. This breaks when <code>print_numbers_below</code> actually wants a float.</p>

<p>If you haven't defined the function yet, always use a prototype.</p>
",5
22109216,22109151,6,"<p>A reasonable compiler would give you the following error:</p>

<pre><code>foo.c:12:5: warning: implicit declaration of function 'print_numbers_below' is invalid in C99 [-Wimplicit-function-declaration]
    print_numbers_below(x, y, z);
    ^
foo.c:16:5: error: conflicting types for 'print_numbers_below'
int print_numbers_below(double x, float y, int z)
    ^
foo.c:12:5: note: previous implicit declaration is here
    print_numbers_below(x, y, z);
    ^
</code></pre>
",1
26123277,26123094,1,"<p>You are permanently modifying n in your very first while loop with this statement: <code>n=n/10;</code> You need to set n back to number in between the loops with <code>n=number;</code></p>
",0
26123299,26123094,1,"<p>Here's a helpful hint:</p>

<ul>
<li>The binary representation of 171 is: <strong>0b10101011</strong></li>
<li>The binary representation of 213 is: <strong>0b11010101</strong></li>
</ul>

<p>Note that they have the same representation except that they are reversed.</p>

<p>That being said, because you count decimal places and everything else in your solution, it becomes pretty complicated. It doesn't need to be that complicated.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;

int toDecimal(int number, int base) {
    assert(base == 2);
    int result = 0;
    int offset = 1;

    while (number) {
        if (number % 10 == 1)
            result += offset;
        offset *= 2;
        number /= 10;
    }

    return result;
}

int main() {
    printf(""%d\n"", toDecimal(11010101, 2));
}
</code></pre>
",0
26123342,26123094,2,"<pre><code>for(i = 0; number != 0; i++){
    if(number % 10 == 1){
        dec += 1&lt;&lt;i;
    }
    number /= 10;
}
</code></pre>

<p>this should solve all problems discussed in the comments.</p>
",0
26123904,26123094,0,"<p>Instead of using two loop in the use only one loop like given below</p>

<p>and you can even eliminate the if statement.</p>

<pre><code>int toDecimal(int number,int base){
    if (base==2) {
        int n=number, dec=0, d=0, r;

        while(n!=0){
            r=n%10;
            dec+=r*1&lt;&lt;d++;
            n=n/10;
        }
        return dec;
    }
    return 0;
}
</code></pre>
",0
33035683,33035630,2,"<ol>
<li><p><code>#define</code> is text replacement. All occurrences of <code>PI</code> in your code will be replaced by <code>3.1415927</code> before compilation.</p></li>
<li><p><code>const</code> creates read-only variables. That means you can't assign to them, but you still can't use them as e.g. <code>case</code> labels, because they're not true constants.</p></li>
</ol>
",4
22124023,22123975,0,"<p>Instead of using <code>if</code> <code>else</code>, I would suggest using a <code>switch</code> statement </p>

<p>If you need to use only <code>if</code> <code>else</code>, then include another <code>else</code> statement mentioning.</p>

<pre><code>else
    exit(0); 
</code></pre>

<p>for your program to terminate in such a case.</p>
",2
22134249,22123975,1,"<p>Your loop never terminates because you never tell it to terminate. It continues to execute as long as <code>a != 0</code>. You initialize <code>a</code> to 1 and you never change it, so naturally you have an infinite loop.</p>

<p>You're also not checking whether <code>scanf</code> succeeded. If you enter some garbage value, it will leave <code>n</code> with its previous value and return a result indicating that it failed to read a new value, but your program doesn't distinguish between success and failure.</p>

<p><code>scanf</code> returns an <code>int</code> result indicating how many items it was able to read (or <code>EOF</code>, a negative value, if there was an error). You should at least compare the value to <code>1</code> to see whether it succeeded.</p>

<p>It appears that you intend to use <code>a</code> to determine whether the loop should continue executing. You should give it a more meaningful name, like <code>keep_going</code>. And you can make it a <code>bool</code> (if you have <code>#include &lt;stdbool.h&gt;</code>, if your compiler supports it), but using an <code>int</code> with <code>0</code> for false and <code>1</code> for true is also ok.</p>

<pre><code>int keep_going = 1;
while (keep_going) {
    /* ... */
    if (...) {
        keep_going = 0;
    }
}
</code></pre>

<p>Or you can write an infinite loop and use <code>break</code> to terminate it:</p>

<pre><code>while (1) {
    /* ... */
    if (...) {
        break;
    }
}
</code></pre>
",2
31811310,31811289,0,"<p>Yes, obviously. Your function <code>foo()</code> will not be able to modify the value <code>foobar</code> inside the function.</p>
",12
23852680,23852643,3,"<p>In the first case,</p>

<pre><code>#include&lt;stdio.h&gt;
int main()
{
   int i;
   for(i=0;i&lt;=5;i++)
   {
      int i=10; // This shadows the previous i
      printf(""%d\n"",i);
      i++;
   }
}
</code></pre>

<p>In the second case,</p>

<pre><code>#include&lt;stdio.h&gt;
int main()
{
   for(int i=0;i&lt;=5;i++)
   {
      int i=10; // This is a problem because the previous i
                // is in the same scope as this i.
      printf(""%d\n"",i);
      i++;
   }
}
</code></pre>
",0
23852720,23852643,0,"<p>In the first code block there are actually two scopes, and the <code>i</code> declared in each scope is a <em>different</em> variable.</p>

<p>Consider this equivalent code, with <em>different</em> variable names to avoid/show the confusion with the second declaration shadowing the first.</p>

<pre><code>// outer scope
int i;
for(i=0;i&lt;=5;i++)      // loops 5 times, only increments i here
{
  // inner scope
  int J=10;            // always assigns 10 to J before print
  printf(""%d\n"",J);
  J++;                 // no effect on i
}
</code></pre>

<p>As for the second case, a variable declared in the <code>for</code> loop <em>initialization</em> section is declared in the same scope as the <em>body</em> of the for loop:</p>

<pre><code>// Same as declaring i in the inner scope ..
for(int i=0;i&lt;=5;i++)
{
   // .. so this is a compiler error because i is
   // already declared this in scope.
   int i=10;
}
</code></pre>

<p>That is, the compile treats the second case about like..</p>

<pre><code>int i=0;
int i=10; // but this redeclaration is invalid
</code></pre>

<p>.. and KABOOM!</p>
",0
24106160,24106097,7,"<p>Yes. It's safe.</p>

<p>When you assign:</p>

<pre><code>*x = y;
</code></pre>

<p>The members of <code>y</code> are copied into the corresponding members of <code>*x</code>. It works as if you did a member to member copy yourself.</p>
",0
24106162,24106097,9,"<p>Assignment always copies.</p>

<p>If you did something like <code>*x = &amp;y</code> (assuming the types matched - if the parameter was declared as <code>st** x</code>, for example), you would be copying the address of <code>y</code>, but since <code>y</code> will go out of scope soon, that assignment would be unsafe, as you feared.</p>

<p>But since you're doing <code>*x = y</code> instead (where the parameter is declared <code>st* x</code>), you are copying the content of <code>y</code> to <code>*x</code>, so even after <code>y</code> goes out of scope, the data stored in <code>*x</code> should be valid.</p>
",4
24106934,24106097,1,"<p>C allow structure assignment. <strong>Two structures can be assigned if they are of compatible type</strong>. Two structures <strong>declared at the same time</strong> are compatible and structures <strong>declared using the same ""structure tag"" or the same type name</strong> are also compatible.   </p>

<p>In the example you provided, both <code>*x</code> and <code>y</code> are declared using the same structure type name <code>st</code>, both are compatible and hence the assignment <code>*x = y</code> is legal. Since <code>st x</code> in <code>main</code> creates a structure which is of complete type, passing its address to a function is legal. In your function the assignment <code>*x = y</code> simply copies the content of local variable <code>y</code> to <code>*x</code> and this change to <code>*x</code> is persist and reflected to <code>x</code> in <code>main</code>.  </p>
",0
24612965,24612909,6,"<p>The main scopes are: </p>

<ul>
<li>drivers</li>
<li>operating systems</li>
<li>systems where performance is critical</li>
<li>small embedded systems (thanks Joachim)</li>
</ul>
",4
24612991,24612909,4,"<p>C is still heavily used in situations where otherwise one would drop down to assembler, since it's one of the few structured languages to let users code that close to the hardware.</p>

<p>And a lot of what claims to be C++ code is C code with an OOP wrapper.</p>
",0
31174517,31174474,3,"<p>People write a lot of things that are invalid C. Lack of strictness by compilers is the principal reason they're able to get away with it. But in the case of the example you linked, it does not seem like the code is doing anything wrong. Rather than illegally defining identifiers in the reserved namespace, it's using implementation-defined identifiers provided by the implementation in the standard headers.</p>
",8
31174566,31174474,1,"<p><code>__cdecl</code> is a Microsoft specific function qualifier.  It is indeed part of the implementation.</p>
",0
31176457,31174474,0,"<p>As a famous science fiction writer once said, ""90% of everything is crap"", and sadly, that applies to computer programs (and computer programmers), too.</p>

<p>It's true that most identifiers starting with underscore are reserved, but it's also true that (a) this rule is very rarely enforced, and consequently (b) it's very widely ignored.  It bugs me, too.</p>

<p>In answer to your followup question, those programmers aren't even sure exactly what they're trying to convey.  A ""special"" identifier, a ""different"" identifier, a ""meta"" identifier.  They've seen the underscore used like that, so they think it must be a good idea to mimic it.</p>

<p>Please don't mimic them, but don't worry if you can't understand what they were trying to accomplish, because I usually don't, either.</p>
",0
26165159,26165122,3,"<p>Roughly, different operating systems read executables in different binary formats and these don't happen to be compatible. So, when you are building the game from source code, you're building for a given platform, using the formats of that platform. You are correct in guessing that the platform you're building <em>for</em> (also called the target platform) doesn't have to be the platform you're building <em>on</em> (this process is called cross-compiling).</p>

<p>Additionally, it's often the case that some source code isn't translatable to all platforms. For example, code that calls to a library file that's only available on Windows can't be compiled (or cross-compiled) for non-Windows systems. The way that every operating system creates user interfaces (such as windows, touch screen pages, etc) is different not only at the binary level, but often also at the source-code level.</p>

<p>The problem of the second paragraph can be partially mitigated by cross-platform libraries (like GTK, OpenGL, OpenCL, etc) that offer the same mechanisms regardless of the operating system you're targeting. They often achieve this by using conditional compilation and other ""tricks"" behind the scenes.</p>

<p>The problem of the first paragraph is more difficult, but workarounds have appeared as well, utilizing some other binary formats (Java archives, CLR assemblies, etc). These formats aren't special in any way. The trick is that they aren't meant to be directly read by any operating system - instead, they are fed to another mechanism (the JVM, the CLI, etc) which has already been built by someone multiple times for multiple platforms (including Windows and Linux) and that mechanism manages the execution of those programs, often from a common binary file without the need for you to target any one specific platform. They usually achieve this by automatically compiling the code for you just before it runs (a process known as Just-in-Time compilation).</p>
",1
23109118,23109032,8,"<p>It's because <code>a</code> has external linkage and the standard states (C11, 6.2.2/2):</p>
<blockquote>
<p>An identifier declared in different scopes or in the same scope more than once can be made to refer to the same object or function by a process called linkage. There are three kinds of linkage: external, internal, and none.</p>
<p>In the set of translation units and libraries that constitutes an entire program, <strong>each declaration of a particular identifier with external linkage denotes the same object</strong> or function. Within one translation unit, each declaration of an identifier with internal linkage denotes the same object or function. <strong>Each declaration of an identifier with no linkage denotes a unique entity.</strong></p>
</blockquote>
<p>So, because <code>a</code> has external linkage, both those declarations refer to the <em>same</em> underlying variable. Because <code>b</code> has no linkage, the declaration refer to <em>unique</em> variables and therefore conflict with each other.</p>
",3
23111511,23109032,0,"<p><code>int a; int a;</code> is a <em>tentative definition</em>. From 6.9.2p2:</p>

<blockquote>
  <p>A declaration of an identifier for an object that has file scope without an initializer, and
  without a storage-class specifier or with the storage-class specifier static, constitutes a
  <strong>tentative definition</strong>. If a translation unit contains one or more tentative definitions for an
  identifier, and the translation unit contains no external definition for that identifier, then
  the behavior is exactly as if the translation unit contains a file scope declaration of that
  identifier, with the composite type as of the end of the translation unit, with an initializer
  equal to 0.</p>
</blockquote>

<p>Tentative definitions are only permitted at file scope. </p>

<p>The reason that <code>int b; int b;</code> is illegal is because of 6.7p3:</p>

<blockquote>
  <p>If an identifier has no linkage, there shall be no more than one declaration of the identifier
  (in a declarator or type specifier) with the same scope and in the same name space</p>
</blockquote>

<p>Identifiers declared within a function and not <code>static</code> or <code>extern</code> have <em>no linkage</em>, this is describd in 6.2.2p6</p>

<blockquote>
  <p>The following identifiers have no linkage: an identifier declared to be anything other than
  an object or a function; an identifier declared to be a function parameter; a block scope
  identifier for an object declared without the storage-class specifier extern.</p>
</blockquote>
",0
23111570,23109032,1,"<p>Quoting the C99 standard &sect;6.9.2 &para;2</p>

<blockquote>
  <p>A declaration of an identifier for an object that has file scope
  without an initializer, and without a storage-class specifier or with
  the storage-class specifier static, constitutes a tentative
  definition. If a translation unit contains one or more <strong>tentative
  definitions</strong> for an identifier, and the translation unit contains no
  external definition for that identifier, then the behavior is exactly
  as if the translation unit contains a file scope declaration of that
  identifier, with the composite type as of the end of the translation
  unit, with an initializer equal to 0.</p>
</blockquote>

<p>Therefore, both the statements </p>

<pre><code>int a;
int a;
</code></pre>

<p>constitute tentative definitions. According to the above quoted part, the behaviour is as if
the two statements were replaced by</p>

<pre><code>int a = 0;
</code></pre>

<p>However, <code>b</code> defined inside <code>main</code> is an automatic variable, i.e., it has automatic storage allocation. There cannot be two definitions of an automatic variable.</p>
",0
24079973,24079912,1,"<p>After replacement it will look like  </p>

<pre><code>printf(""%d"", 2+34+5) );  // 2+34+5 = 41  
</code></pre>

<p><strike>It will never print <code>28</code>.</strike>   </p>

<p>The argument to <code>MUL</code> will not evaluate before the replacement.</p>
",0
24080065,24079912,1,"<p>When a macro is expanded, the two tokens on either side of each ¡®##¡¯ operator are combined into a single token. Expressions are not evaluated and passed to the macro.</p>

<p>In this case the expansion would be <code>2+3 ## 4+5 i.e 2 + 34 + 5 = 41</code>.</p>
",0
24080085,24079912,0,"<pre><code>MUL(2+3,4+5)
</code></pre>

<p>will expand to</p>

<pre><code> 2+3##4+5
</code></pre>

<p>which is</p>

<pre><code>2+34+5
</code></pre>

<p>It evaluates to 41.</p>

<p>To get 59, you need to call <code>MUL(5,9)</code>. For even <code>MUL((2+3),(4+5))</code>, preprocessing will be done first which will make it to</p>

<p><code>(2+3)(4+5)</code></p>

<p>and will result in compiler error.</p>

<p>MACROs are replaced before compilation phase.</p>
",0
27750055,27749998,1,"<ol>
<li><p>Find the largest power of 2 less than n. (by rounding down log2n) Call the number x.</p></li>
<li><p>The <code>k</code> you want to find is <code>n - 2^x.</code></p></li>
</ol>

<p><strong>OR</strong></p>

<p>You can write a loop that checks every power of two less than n.</p>

<p>The first method is faster. (constant time vs. O(n) time)</p>
",7
27750111,27749998,2,"<pre><code>int i = 0; j = 1, k, n = (your value);

if ( n &gt; 0 )
{
    while ( 2 * j &lt; n) 
    {
        j = 2 * j; 
        i++;
    }

    k = n - j;
}

// replace '&lt;' with '&lt;=' if k = 0 is desired where n is a pure power of 2
</code></pre>

<p>(nb: there is no exponentiation operator in Standard C)</p>
",1
26439696,26439668,1,"<p>The *a = *b, means that the content that is stored in the memory assinged to pointer b is going to be the content of pointer a.</p>
",0
26439712,26439668,1,"<p><code>a=b</code> : it assigns the value of b to a</p>

<p><code>*a=*b</code>: it assigns the content located in the address pointed by b to that pointed by a</p>

<p>A good use of what you ask can be illustrated in what follows:</p>

<pre><code>#include&lt;stdio.h&gt;

    void swapping(int *ptr_c, int *ptr_d) {
        int tmp;

        tmp = *ptr_c;
        *ptr_c = *ptr_d;
        *ptr_d = tmp;
        printf(""In function: %d %d\n"", *ptr_c , *ptr_d);
    }

    int main(void) {
        int a,b;

        a=5;
        b=10;
        printf(""input: %d %d\n"", a, b);
        swapping(&amp;a,&amp;b);
        printf(""output: %d %d\n"", a, b);
                return 0;
    }
</code></pre>
",2
26440081,26439668,0,"<pre><code>*a = *b;   
</code></pre>

<p>The above statement will simply do this: value(<code>a</code>) &lt;-- value(<code>b</code>) (i.e. pointer <code>a</code> will contain value 'd' ).</p>

<pre><code>printf(""%x\n"", a); 
</code></pre>

<p>This will print the pointer's address(<code>a</code>) in hexadecimal. However, always use the <code>""%p""</code> format identifier to print the addresses. <code>""%x""</code> is used to print the values in hexadecimal format.</p>

<pre><code>printf(""%x\n"", *a);
</code></pre>

<p>Since the value(<code>a</code>) is 'd' whose ASCII value is <code>100</code> (hundred in decimal).
Thus <code>""%x""</code> will print the hexadecimal value of <code>100</code> which is <code>64</code>. Therefore this statement will print <code>64</code>. </p>

<p>No the above statement will not print the pointer's address(<code>b</code>). </p>

<p>However, pointer's address(<code>b</code>) can be printed by following statement:</p>

<pre><code> printf(""%p"", b);
</code></pre>
",3
23091383,23091345,3,"<p>Change:</p>

<pre><code>main(int argc, int **argv){ 
</code></pre>

<p>to</p>

<pre><code>int main(int argc, char *argv[]){
</code></pre>

<p>Your former declaration is not an acceptable declaration for <code>main</code> and <code>atoi</code> requires a parameter of type <code>char *</code>.</p>
",1
23091425,23091345,0,"<p>argv is supposed to be a character array, you have to read the characters and then convert them into an int.</p>

<p>Also, what is:</p>

<pre><code>if(argc == 0)
</code></pre>

<p>If you have no arguments? That should never even be possible because the program name is in passed as an argument.</p>

<p>See:</p>

<p><a href=""https://stackoverflow.com/questions/3024197/what-does-int-argc-char-argv-mean"">What does int argc, char *argv[] mean?</a></p>

<p>You also didn't declare int blk in the correct scope, when you leave that if(argc == 0) statement, the variable blk will disappear. </p>
",4
33566131,33316727,0,"<p>Or perhaps you should just ""cast"" the operation like this</p>

<p>float f = (float)1 / n;
This will work!!!</p>
",0
27523760,27523635,3,"<pre><code>(*cars)[i].id   = i; //when i&gt;0 then It crash here...
</code></pre>

<p>This should work for you.</p>

<p>explanation:</p>

<p>you allocate <code>n</code> elements to the value of the pointer to the <code>cars</code> pointer.</p>

<p>but you try to derefference the value of the <code>i</code>th pointer to a <code>cars</code> element.</p>

<p>With my correction you derefference the firsts pointer's <code>i</code>th <code>cars</code> id. what is bad coded but should do what you want.</p>

<p>But what you probabbly want to do is asigning multiple pointers which at all point to a single car pointer instead ;)</p>

<p>than your crashing line could stay at it is.</p>
",0
31258647,31258511,7,"<p>The most likely explanation one can come up with from what you provided is that at the point of the call the function <code>create</code> is <em>undeclared</em>. A permissive C compiler assumed that unknown function <code>create</code> returned an <code>int</code> and generated code, which effectively truncated the pointer value or, more precisely, sign-extended the assumed <code>int</code> return value into the MSB of the recipient pointer (assuming a platform where pointers are wider than <code>int</code> in terms of their bit-width, e.g. 64-bit platform).</p>

<p>Most likely the compiler issued a warning about an undeclared function being called, but the warning was ignored by the user.</p>

<p>Make sure declaration (or, better, prototype) of <code>create</code> is visible at the point of the call. If you are compiling in C99 mode (or later), ask your compiler to strictly enforce C99 requirements. And don't ignore compiler diagnostic messages.</p>
",1
29194138,29194098,3,"<p><code>info_bottom();</code> you should  pass diameter as argument i.e. <code>info_bottom(diameter);</code></p>
",0
29194217,29194098,1,"<p>Adding to <a href=""https://stackoverflow.com/a/29194138/4516316"">@JerryGoyal</a> 's answer, In your main.c</p>

<pre><code>case 1:

    info_top();
    cir_user_input();
    info_bottom();          //  here
    break;
</code></pre>

<p>In the commented line, you need to give <code>info_bottom()</code> an argument when you call it. Something like <code>info_bottom( diameter );</code> where <code>diameter</code> is a variable of type double you must declare in your main.c</p>

<p>If you had your compiler Warnings turned on, it should have warned you about this.</p>

<p>You should also make the <code>diameter</code> in </p>

<pre><code>double getRadius(float diameter)
double getSurface(float diameter)
</code></pre>

<p>and</p>

<pre><code>double getOutline(float diameter)
</code></pre>

<p>of type double. In other words, the arguments should be <code>double diameter</code></p>
",0
26227506,26227457,0,"<p>One way to achieve what you want is to use <strong><em>getc</em></strong> and check for space , if space is found call <strong><em>ungetc</em></strong> and read the line using <strong><em>fgets</em></strong> else read the line and skip it</p>
",0
26227551,26227457,3,"<p>OP: it possible to specify it in the <code>fscanf</code>?<br>
A: Yes, but its ugly.  Use the best tool for the job.</p>

<p>Use <code>fgets()</code>, then scan with <code>sscanf()</code>.</p>

<pre><code>char buf[100];
char a;
unsigned b;
int c;
while (fgets(buf, sizeof buf, fp) != NULL) {
  // Thank-you @Chris Dodd
  if ((buf[0] == ' ') &amp;&amp; (sscanf(buf, "" %c%x,%d"", &amp;a,&amp;b,&amp;c) == 3)) {
    printf(""%c %x,%d\n"",a,b,c);
  }
}
</code></pre>
",1
23850227,23849744,1,"<p>The following will get the address of myFunc and step bytewise through memory starting from that address when you type a key: </p>

<pre><code>void myFunc();
int main()
{
   void* ptr = &amp;myFunc; // stuff like that
   while(getchar() != -1) {
     printf(""%d"", *((char*)ptr++));
   }
   return 0;
}
void myFunc()
{
   printf(""hi!"");
}
</code></pre>

<p>Here's the output I get:</p>

<pre><code>[gregor@localhost tmp]$ ./faddr

85
72
-119
-27
-65
-109
6
</code></pre>

<p>I wouldn't be able to tell if this is actually stepping through the machine code for the function ... Maybe you have a way to check this? E.g use something simpler like:</p>

<pre><code>int myFunc() 
{
   return 0;
}
</code></pre>
",2
23849755,23849744,1,"<p>I'd say you want </p>

<pre><code>char* myChar =(char*)&amp;myFunc; // stuff like that
</code></pre>

<p>You cannot convert an address to a <code>char</code>, but of course you can convert it to a pointer-to-char <code>char*</code>. </p>

<p>Also, define the function above main, or if not, declare its prototype <code>void myFunc();</code> above main. Otherwise <code>main()</code> does not ""see"" it and you get a compile time error.</p>
",14
31284185,31283454,0,"<p>Let's look at your logic:</p>

<pre><code>return (*(uint16_t*)value &lt;&lt; 8 | *(uint16_t*)value &gt;&gt; 8);
</code></pre>

<p><code>*(uint16_t*)value</code> is <code>0xADDE</code> since your system is little-endian.  (Subject to some caveats which I will mention below).</p>

<p><code>0xADDE &lt;&lt; 8</code> is <code>0xADDE00</code>, assuming you have 32-bit (or larger) <code>int</code>. Remember that left-shifting is equivalent to multiplying by a power of 2.</p>

<p><code>0xADDE &gt;&gt; 8</code> is <code>0xAD</code>.</p>

<p><code>0xADDE00 | 0xAD</code> is <code>0xADDEAD</code> which is what you observed.</p>

<p>If you expected to <code>0xDEAD</code> then you are going about it completely the wrong way. Instead the following code would work (and be endian-agnostic):</p>

<pre><code>return (value[0] &lt;&lt; 8) | value[1];
</code></pre>

<p>although my personal preference, since we are doing arithmetic, is to write it as <code>value[0] * 0x100u + value[1]</code>.</p>

<hr>

<p><code>*(uint16_t *)value</code> has other problems. Firstly it will cause undefined behaviour if your system has an alignment restriction on integers. Secondly, it violates the strict aliasing rule: objects of type <code>uint8_t</code> may not be read through an lvalue of type <code>uint16_t</code>, again causing undefined behaviour.  </p>

<p>If you are porting code that uses aliasing casts like this, I'd suggest disabling type-based aliasing optimization in your compiler until you fully understand the issues. In gcc the flag is <code>-fno-strict-aliasing</code>.</p>
",0
31283573,31283454,2,"<p>The integer promotions are done at the ""read side"", therefore while the expression is evaluated. This means that after reading an integer value that has a smaller size than <code>int</code> resp. <code>unsigned</code> it is immediately converted:</p>

<blockquote>
  <p>The following may be used in an expression wherever an int or unsigned int may be used:</p>
  
  <p>?¡ª An object or expression with an integer type whose integer conversion rank is less than or equal to the rank of int and unsigned int.</p>
  
  <p>¡ª A bit-field of type _Bool, int, signed int, or unsigned int.</p>
  
  <p>If an int can represent all values of the original type, the value is converted to an int; otherwise, it is converted to an unsigned int. These are called the integer promotions. 48)</p>
  
  <p>48) The integer promotions are applied only: as part of the usual arithmetic conversions, to certain argument expressions, to the operands of the unary +, -, and ~ operators, and to both operands of the shift operators, as specified by their respective subclauses.</p>
</blockquote>

<p>ISO/IEC 9899:TC3 6.3.1.1-2</p>

<p>Therefore</p>

<pre><code>*(uint16_t*)value
</code></pre>

<p>is immediately converted to <code>int</code> and then shifted.</p>
",0
31283639,31283454,2,"<p>On a little endian system you are reading a <code>unit16_t</code> memory location that contains value <code>0xADDE</code>. Before performing shifts, the value is promoted to <code>int</code> type, which is probably 32-bit wide on your platform, producing <code>0x0000ADDE</code>. Shifts produce <code>0x00ADDE00</code> and <code>0x000000AD</code> respectively. Bitwise OR produces <code>0x00ADDEAD</code>.</p>

<p>Everything is as expected.</p>

<p>C language does not perform any arithmetic operations within types smaller than <code>int</code> (or <code>unsigned int</code>). Any smaller type is always promoted to <code>int</code> (or <code>unsigned int</code>) before performing the operation. This is what happens with your shifts. Your shifts are <code>int</code> shifts. C does not have ""narrower"" shifts. C does not have ""narrower"" additions and multiplications. C does not have ""narrower"" <em>anything</em>.</p>

<p>If you want a ""narrower"" shift (or any other operation) you have to simulate it by meticulously manually truncating the intermediate results in order to force them into a smaller type</p>

<pre><code>(uint16_t) (*(uint16_t*) value &lt;&lt; 8) | (uint16_t) (*(uint16_t*) value &gt;&gt; 8);
</code></pre>

<p>They will constantly spring back to <code>int</code> and you have to constantly beat them back into <code>uint16_t</code>.</p>
",0
31283673,31283454,1,"<p>This is what the compiler does:</p>

<pre><code>uint32_t swap_16_p(uint8_t *value)
{
    uint16_t v1 = *(uint16_t*)value;  // -&gt; 0x0000ADDE
    int v2 = v1 &lt;&lt; 8;                 // -&gt; 0x00ADDE00
    int v3 = v1 &gt;&gt; 8;                 // -&gt; 0x000000AD
    uint32_t v4 = v2 | v3;            // -&gt; 0x00ADDEAD
    return v4;
}
</code></pre>

<p>So the result is well-justified.</p>

<p>Please note that <code>v2</code> and <code>v3</code> are results of <em>integral promotion</em>.</p>
",0
33031481,33031422,2,"<p>Your cast says ""treat 1000 as the address of a float"" and assign that address to ptr1. That is, you have a pointer, but you don't have any float to point it to. 1000 is just a value that could be used to initialise a float, but you have to actually store that value somewhere before you can point to it.</p>

<pre><code>float   f = 1000;
float*  ptr1 = &amp;f;
</code></pre>
",0
33031482,33031422,1,"<p>This type of casting is usually found in embedded applications, where you have absolute hard-coded addresses, such as memory-mapped I/O ports.</p>

<pre><code>float *ptr1=(float *)1000;
</code></pre>

<p>This defines a pointer to absolute address 1000 (decimal). Reading or writing to that address will attempt to read or write a float value.</p>
",0
33031484,33031422,2,"<p>That line of code won't set <code>*ptr</code> to <code>1000.0f</code>, it will make <code>ptr</code> <em>point to</em> the address <code>1000</code>.  What this means is architecture specific, as you are forcing a pointer to point to some exact place and how a processor interprets addresses is, again, architecture specific.</p>

<p>The casting tells the compiler that the value <code>1000</code> is a pointer to a <code>float</code>, i.e. an address.</p>

<p>If you want to have a pointer to <code>float</code>, and have it point to some other location that contain the value <code>1000.0f</code>, then you need to declare another variable and use the address-of operator <code>&amp;</code>:</p>

<pre><code>float flt1 = 1000.0f;
float *ptr1 = &amp;flt1;
</code></pre>

<p>Important note: The lifetime of the <code>flt1</code> variable in the above example must be the same (or longer) as the lifetime of the variable <code>ptr1</code>, or you will have a stray pointer which could lead to <em>undefined behavior</em>.  This means a pointer pointing to somewhere that has ceased to exist.</p>
",0
21782805,21782762,6,"<p>No. This is not a valid syntax. A valid syntax which could be a pointer to a <a href=""http://gcc.gnu.org/onlinedocs/gcc-3.2.2/gcc/Compound-Literals.html"" rel=""nofollow"">compound literal</a> is  </p>

<pre><code>int *arr = (int []){-1, -1};  // Valid only in C99 and latter
</code></pre>

<p>If you wanna return an array then return a pointer to it;  </p>

<pre><code>int *arr = malloc(sizeof(*arr)*2);
....
return arr;
</code></pre>
",12
21782864,21782762,0,"<p><code>arr</code> is pointer to <code>integer</code>. So you can not have multiple inits like this.</p>

<p>You can have below:</p>

<pre><code>int *arr = NULL;

arr = malloc(..)

...
...
arr[0] = some value..
arr[1] = some value..
</code></pre>
",0
21782872,21782762,2,"<p><code>Is there a better way of setting a pointer variable to an array without looping?</code> <br/></p>

<p>There is a option called pointer to an array. <br/>
<strong>sample:</strong></p>

<pre><code>int a[10];
int (*x)[10] = &amp;a;
</code></pre>
",0
21782988,21782762,4,"<p>You can set a pointer to an array created on the fly with a <em>compound literal</em>:</p>

<pre><code>int *p = (int []){2, 4};
</code></pre>

<p>However, the array lives only as long as the block it is in. You cannot return it from a function. To return an array (by pointer), you should allocate it dynamically, as with <code>malloc</code>.</p>
",7
21783290,21782762,0,"<p>Regarding   </p>

<pre><code>int *arr = {-1, -1};
</code></pre>

<p><em>Is that valid syntax?</em>  </p>

<p><em><strong>No, but this is:</em></strong>  </p>

<pre><code>int *arr = {0}; //initialize pointer to 0;

arr = malloc(100*sizof(int));// allocate memory (can also do this at creation of arr) 

arr[99]=1; //assign value to elements as needed  

free(arr);// free memory when done with arr  
</code></pre>

<p><em><strong>And - in this form (pointer)</em></strong>, <code>arr</code> <strong><em>is</em></strong> returnable by a function:  </p>

<pre><code>int * somefunc(int *arr)
{
    //manipulate arr[0] - arr[n]
    ....
    return arr;
}
</code></pre>
",0
34250396,34249886,0,"<p>Firstly, you need to initialise foo and baz for the code to actually compile. Then it is clear to the compiler what the difference between the two are.</p>
",0
34250508,34249886,2,"<p>Your structure declaration is incorrect: <code>char foo[];</code> can only appear as the last member, and it is missing a <code>;</code> at the end. Here is correct declaration:</p>

<pre><code>struct ss {
    char *foo;
    char bar[3];
    int bazSize;
    char baz[];
};
</code></pre>

<p>We have a pointer <code>foo</code> and a flexible array <code>baz</code> at the end.  When allocating such a structure from the heap, the actual space for the last member must be known and cannot be changed without reallocating the whose structure which may be complicated if the structure it referred to from various other places.  Flexible arrays save space but are not <em>flexible</em> at all.</p>

<p>Advantages of the flexible array:</p>

<ul>
<li>save space</li>
<li>save one indirection</li>
<li>allocate in one step</li>
<li><code>baz</code> is never <code>NULL</code></li>
</ul>

<p>Conversely, making <code>baz</code> a pointer requires separate allocation of the array it points to.  This disadvantage in size, code and speed comes with compensations.</p>

<p>Advantages of the pointer version:</p>

<ul>
<li><code>baz</code> can be <code>NULL</code> to specify no data.</li>
<li><code>baz</code> can be allocated on demand, when the actual size is known.</li>
<li><code>baz</code> can be reallocated easily.</li>
</ul>

<p>So which you should use depends on how you use these structures.  The syntax at point of use is the same, but the compiler has seen the actual declaration and will generate the appropriate code. </p>
",0
34258798,34249886,1,"<p>The problem is that <code>char *foo</code> and <code>char foo[]</code> are only the same thing in some contexts (like function parameter declaration) and not others (like structure field declarations).  </p>

<p>(I have not hacked C for a long while.)</p>
",0
25672658,25672488,1,"<p>Calling <a href=""http://msdn.microsoft.com/en-us/library/t32cf9tb.aspx"" rel=""nofollow"">_scprintf(...)</a> will tell you how big the string would be, without actually using a buffer.</p>

<p>Then you allocate a buffer of that size, and call snprintf.</p>
",2
25672903,25672488,2,"<p>If you have the option to allocate the destination-buffer yourself, you can check the length of the source string with <code>strlen()</code> in case it is null-terminatd and allocate a sufficiently large buffer for it and the terminating null-character. You could also use <code>asprintf</code> directly, if it is available.
If you do not have that option you will have to pass the size of the destination buffer as argument, because you cannot reliably determine its size from inside the function if you only have the pointer to it (unless the destination buffer is always delimited in a uniquely identifiable way).</p>
",4
25676093,25672488,0,"<p>You will not gain any benefit by simply changing out <code>sprintf</code> for <code>snprintf</code> if you are not able to call <code>snprintf</code> with the proper arguments. Your <code>foo</code> function needs to also take an extra parameter just like <code>snprintf</code> requires an extra parameter over <code>sprintf</code>. Since arrays decay to pointers when they are used as arguments to a function, any size information is lost.</p>

<p>This may be a pain in the arse if you call <code>foo</code> hundreds of times throughout your program, but if you want to make sure you avoid buffer overruns, you need to make sure that any functions that operate on arrays are fully aware of their size.</p>

<p>If you are using GCC or clang, you can put a deprecation warning on the <code>foo</code> function by changing its prototype to<sup>1</sup>:</p>

<pre><code>void __attribute__((deprecated)) foo(char *a, uchar *string);
</code></pre>

<p>Then, you can create a new function, e.g. <code>foo_n</code>, which has the extra parameter for the size. When you compile your code, GCC will emit a warning for each use of the function <code>foo</code>, so you know to replace them with <code>foo_n</code>.</p>

<p><sup>1. It's possible that the <code>__attribute__((deprecated))</code> part goes <em>after</em> the parameter list, but clang seems to accept it as it is shown above.</sup></p>
",0
28182020,28181903,1,"<p>It is not a problem with char* and char[] conversion, it is a problem with converting char* to int since argv[] is an array of an array of character.</p>

<p>Try this -- it uses pointer arithmetic and probably work:</p>

<pre><code>int SearchWord( char *word, char *text, unsigned int length ) {
  unsigned int i = 0, d = 0, x = 0;
  x = strlen( text );
  // Keep looping til we reach less than total length
  for (; i &lt;= ( x - length ); i++) {
    if (strncmp( text, word, length ) == 0) {
      d = i;
      break;
    }
    else {
      // Moving 1 character position
      text++;
    }
  }
  // Check if no match was found
  if (i == (x - length) {
    return -1;
  }
  for (i = 0; i &lt;= d; i++) {
    // Revert the text
    text--;
  }
  return d;
}
</code></pre>
",7
28182028,28181903,1,"<p>Assuming that <em>text</em> is composed of words separated by spaces, you can consider tokenizing <em>text</em>, and then iterating through the tokens to see if they match <em>word</em>. Try making use of strtok(), and there is a lot of documentation online for how to use the function. </p>

<p>I found a relevant question on how to use strtok here: <a href=""https://stackoverflow.com/questions/18927793/how-to-use-strtok"">how to use strtok</a>.</p>

<p>You can try to find the position this way: </p>

<pre><code>int search(char * word, char * text, unsigned int length) {
    char * token = strtok(text, "" "");
    int position = 0;

    while (token != NULL) {
        // if word matches the token, we found our word
        if (! strncmp(word, token, length)) {
            return position;
        } else {
            position += (strlen(token) + 1);
            // get the next token from the text
            token = strtok(NULL, "" "");
        }
    }
    // didn't find it
    return -1;
}
</code></pre>
",2
24114983,24114877,0,"<p>""xyz"" and ""a"" are string literals which is mostly available in <strong>string table</strong>.</p>

<p>""xyz"" is printed because it is recently assigned to that pointer.  </p>
",4
24114986,24114877,1,"<p><strong>1.In below code where does pointer 'c' is actually pointing to?In other words where does the string ""xyz"" get stored in memory(stack/heap etc.)?</strong></p>

<p>will place <code>xyz</code> the read-only parts of the memory and making <code>c</code> a pointer to that, a variable of type pointer-to-char, called <code>c</code> , which is initialized with the location of the first character in that unnamed, read-only array.you created automatic storage (often called the stack). Here you just point to memory in text section.</p>

<p><strong>2.What will happen to memory location allocated for""a""' as i am not using it anymore?</strong></p>

<p>As per your code you not allocated any memory just you assign string literals to that.If you allocate then need to free it.</p>

<p><strong>3.Code seems to work well if I un-comment the commented section.Whats happening with memory in that scenario?</strong></p>

<p>If you un comment the allocation statement to allocate memory then also it point to you literal string but you need to free that memory.</p>

<p>Now for case</p>

<pre><code>char *c[] = {""a"",""xyz""};
</code></pre>

<p>when you declare and initialize words, it'll be allocated on the stack as any other automatic array and its items will be assigned to pointers to the beginning of each string constant.Also to alter this string may illegal.</p>
",0
24115019,24114877,5,"<ol>
<li><p>The specific details are implementation dependent, but in most common implementations, literal strings like <code>""a""</code> and <code>""xyz""</code> are stored in the text section of the program, like the machine code that implements the program. Assigning <code>a = ""xyz"";</code> sets <code>a</code> to point to that location in memory.</p></li>
<li><p>The memory for <code>""a""</code> is unaffected. However, an optimizing compiler may notice that <code>c</code> was never used between that assignment and being reassigned, so it could simply ignore the first assignment, and never allocate any space for <code>""a""</code> at all.</p></li>
<li><p>The memory you allocated with <code>malloc()</code> stays allocated until the program ends. Allocating memory without freeing it is called a <em>memory leak</em>, and you should try to avoid it.</p></li>
</ol>
",1
24115913,24114877,0,"<ol>
<li>To a place in the heap/stack in the READ-ONLY part of the memory which the string is in. When assigning a <a href=""http://msdn.microsoft.com/en-us/library/8kc54dd5.aspx"" rel=""nofollow"">string literal</a> directly into a pointer, the program searches for that string in the memory, if it exists through the short search he's doing, it'll point to it, if it doesn't - it will create it. Either way it's read only so it'll be the same as a <code>const char*</code> so you can't change it (of course you can somehow manipulate it, maybe by another pointer or so).</li>
<li>Nothing, it'll stay unaffected.</li>
<li>What's happening is that malloc returns a pointer and you just ignore it, you go to another address containing a and it will not have the same influence as <code>strcpy(c, ""a"");</code> as you ignore the allocated memory and its pointer - you do not free it. Generally, nothing's happen if you don't free the memory (I mean, at the end of the program it is freed automatically by the OS) but it WILL take memory within the program so if i'd allocate, let's say <code>1000000</code> bytes (assuming it succeeded), allocating more heap memory would be a problem :P</li>
<li>about the other question... You can't alter them through that pointer, try and it will throw an interrupt in the middle of the program and it'll probably stop responding.</li>
</ol>
",0
33006686,33006576,3,"<p>No you don't need to copy and paste, suppose you have this</p>

<p><strong>program-one.c</strong><br>
<em>First program</em>.</p>

<pre><code>#include ""common.h"" /* This should be implemented */

int main(void)
{
    do_program_one_stuff();
    common_function();
    return 0;
}
</code></pre>

<p><strong>program-two.c</strong><br>
<em>Second program</em>.</p>

<pre><code>#include ""common.h"" /* This should be implemented */

int main(void)
{
    do_program_two_stuff();
    common_function();
    return 0;
}
</code></pre>

<p>You need a third <em>.c</em> file and a <em>.h</em> file, like this</p>

<p><strong>common.c</strong><br>
<em>Common Functions Implementation</em>.</p>

<pre><code>void common_function()
{
    /* Do it here */
}
</code></pre>

<p><strong>common.h</strong><br>
<em>Common Functions Header</em>.</p>

<pre><code>void common_function();
</code></pre>

<p>You now can compile a single binary for each program consisting of two files, the program specific <em>.c</em> file and <em>common.c</em>.</p>

<p>The right way to do it is to have a <em>Makefile</em> and generate object code first, and then link the object files togeather, thus compiling each file only once.</p>

<p><strong>Makefile</strong><br>
<em>This is a <a href=""https://www.gnu.org/software/make/"" rel=""nofollow"">GNU make</a> Makefile using <a href=""https://gcc.gnu.org/"" rel=""nofollow"">gcc</a> as the compiler.</em>
</p>

<pre class=""lang-none prettyprint-override""><code>CC      = gcc
CFLAGS  = -Wall -Wextra -Werror -g3 -O0 # enable debug symbols and warnings
LDFLAGS = # linker flags here ...
OBJ     = common.o program-one.o program-two.o

all:
    $(CC) $(LDFLAGS) common.o program-one.o -o program-one
    $(CC) $(LDFLAGS) common.o program-two.o -o program-two

%.o: %.c
    $(CC) $(CFLAGS) -c $&lt;

clean:
    @rm -fv *.o program-one program-two
</code></pre>

<p><strong>EDIT</strong>: <em>in response to your comment I would suggest the following</em>
</p>

<pre class=""lang-c prettyprint-override""><code>#define main ignore /* Or whatever name you want */
#include ""the-student-implementation.c""
#undef main

int main(void)
{
    /* This would be your `main()' */
    return 0;
}
</code></pre>
",6
33006754,33006576,2,"<p>The best solution is what iharob suggested, but if for some reason that isn't possible, you could surround the main() in the file containing the common function with #ifdef USE_MAIN, then only define the USE_MAIN identifier in the command to build that project.  When you build the other project that doesn't have USE_MAIN defined, the preprocessor will cause the second main() to be skipped, so the compiler won't be confused.</p>

<p>But unless this is really needed, I highly recommend splitting this into three files: main1.c, main2.c, and common.c/common.h</p>
",0
31253932,31253804,2,"<p>Did you modify this from a program which originally was supposed to have spaces and asterisks the other way around? You forgot to change the other space-printing loop to print asterisks¡­ =)</p>

<pre><code>    for(space=0;space&lt;rows-i;++space) // &lt;- name of variable misleading
       printf(""*""); // &lt;- ok
    for(j=i;j&lt;=2*i-1;++j)
      printf("" ""); // &lt;- ok
    for(j=0;j&lt;i-1;++j) // &lt;- this should print as many *'s as the first loop
      printf("" ""); // &lt;- ???
</code></pre>

<p><strong>edit</strong>: re. modified question, the loops themselves are also slightly wrong. You have all the pieces required to fix it, tweak the termination conditions of the loops and you'll get the answer.</p>

<p>As an additional observation, all of your <code>printf</code> calls are printing only one character each, so you could replace them with, e.g., <code>putchar</code>.</p>
",1
31254001,31253804,4,"<p>There are a couple things wrong here.</p>

<p>First let's address your third loop. The program should print stars, spaces, and then stars again, so that third loop shouldn't be printing spaces. Also, we're printing the same amount of stars on either side of the spaces, so the third loop will actually just be the <strong>same exact code</strong> as your first loop!</p>

<p>Secondly, here in the header of the second loop:</p>

<pre><code>for(j=i;j&lt;=2*i-1;++j)
</code></pre>

<p>You're missing parenthises. By the order of operations, this will evaluate as <code>(2*i)-1</code>, which isn't what you want.</p>

<p>There is also a tricky caveat here! You'll notice in the first row of your example output there's an <strong><em>odd number</em></strong> of stars, while every other line has an even number! In the first line only, we need to print exactly one less star! Which means we'll need this code in one of our star loops to ignore the first star of the first row:</p>

<pre><code>if(i !=0 || space != 0) printf(""*"");
</code></pre>

<p>Lastly, I've flipped your outer loop to iterate the other way, as it looked like that was what you wanted and it helped to solve some other problems:</p>

<pre><code>for(i=0;i&lt;rows;++i)
{
    for(space=0;space&lt;rows-i;++space)
       if(i!=0 || space != 0) printf(""*"");
    for(j=0;j&lt;2*(i-1)+1;++j)
      printf("" "");
    for(space=0;space&lt;rows-i;++space)
       printf(""*"");
    printf(""\n"");
}
</code></pre>
",2
24588414,24588350,0,"<p>The return character (pressed to validate your first input) is still present in the standard input buffer.</p>

<p>You can solve your issue by adding <code>getchar();</code> after your first <code>scant</code>, as it will consume the stray <code>\n</code> of the buffer, leaving it empty for your next input.</p>
",0
24588426,24588350,2,"<p>Here's what's going on.</p>

<pre><code>      printf(""Please enter number : "");
      scanf(""%d"",&amp;inputNum);
</code></pre>

<p>When this runs, you are prompted to enter a number, and then of course <em>you hit return</em> to flush the input buffer.  That leaves a <code>\n</code> (newline) character in there, which gets read by:</p>

<pre><code>     printf(""\nEnter (N/n) to STOP ADDING : "");
     scanf(""%c"",&amp;choice);
</code></pre>

<p>So the program goes <code>Choice is :</code> and leaves a blank line -- that's the <code>\n</code> that got put into <code>choice</code>.</p>

<p>One solution is to use;</p>

<pre><code>scanf(""%*c%c"", &amp;choice);
</code></pre>

<p>The <code>*</code> tells <code>scanf()</code> to discard the field, in this case, the newline remaining from the last input.</p>

<blockquote>
  <p>if I put Integer Input (inputNum) statement after choice asking choice input is working</p>
</blockquote>

<p>It's important to note that the issue with the newline won't affect <code>%d</code> scans, because these <em>skip leading whitespace</em>.  So if you ask for two integers in your program instead of an int and a char, it works without the need to manually skip the newline.  The same logic applies to most kinds of input, as per a statement from the ISO C 99 Draft Standard repeated in the <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/fscanf.html"" rel=""nofollow"">POSIX man page for fscanf</a>:</p>

<blockquote>
  <p>Input white-space characters (as specified by isspace) shall be
  skipped, unless the conversion specification includes a [, c, C, or n
  conversion specifier.</p>
</blockquote>

<p>That ""unless"" applies of course to <code>%c</code>.</p>
",3
24653593,24653551,2,"<p>You need to leave a space for a terminator in your string - here you define it to be char[16], then put 16 chars in locations 0..15, so there is no room for the null terminator that you then check for.</p>

<p>If you define as char[17] you should be OK</p>
",0
24653650,24653551,2,"<p>In C strings are null terminated.</p>

<p>Read more about it <a href=""http://en.wikipedia.org/wiki/Null-terminated_string"" rel=""nofollow"">here on wikipedia</a></p>

<p>So you need to leave a space at the end for the zero terminator.</p>

<pre><code>char str[17] = ""--g-6hA-Za-z56-9""; /* here the compiler is so kind to insert the null terminator for you */
</code></pre>

<p>or as Quentin suggested let the compiler figure it all out by itself</p>

<pre><code>char str[] = ""--g-6hA-Za-z56-9""; /* here the compiler is so kind to insert the null terminator for you and figure out the length */
</code></pre>
",1
24654417,24653551,0,"<p>As others have answered, you didn't leave room for the null terminator to be placed as the last element in str</p>

<p>What ends up happening as a result is you continue your for loop iteration past ""the end"" (or rather what you expected to be the end) of str since str[i] doesn't equal 0</p>

<p>The iteration will continue until you just happen to reach memory that will satisfy the condition of your for loop which was supposed to check for the end of str (signified by the null termination)</p>
",0
26243581,26243541,2,"<p>You can't have Node defined again inside the same structure. This will be infinite recursion.</p>

<p>you can have a Pointer to the same type.</p>

<pre><code>typedef struct Node{
    struct Node *next;
</code></pre>
",4
26243771,26243541,1,"<p>there are numerous errors in your code. <br>
here is a correct version <br></p>

<pre><code>typedef struct NodeTag
{
    struct NodeTag* next;
    int id;
} Node;

void append_node(Node* sent,int val)
{   
    Node* other_node = (Node*)malloc(sizeof(Node));
    other_node-&gt;id = val;
    other_node-&gt;next = 0;
    Node* n = sent;
    while (n-&gt;next != 0)
    {
        n = n-&gt;next;
    }
    n-&gt;next = other_node;
}
</code></pre>
",1
21325843,21325761,6,"<p>You cant because if you have example(), 'example' is a pointer to that function.</p>
",7
21325886,21325761,5,"<p>You can declare local variables with the same name as a global variable, but the local variable will <em>shadow</em> the global. As long as your local <code>a</code> is in scope, the symbol <code>a</code> refers to your local variable.</p>

<p>Some languages allow to refer to the global symbols via special syntax, such as <code>::a</code> or <code>.a</code>. C is not one of these languages.</p>

<p>(As a side note: You shouldn't give global functions names that are likely to interfere with locals. Names of locals are usually short and don't carry much information - it is not needed, bacause the context is clear. Global variables have to share one big namespace with other variables. It is recommended to provide a bit of context in your name in order to avoid name clashes and shadowing.)</p>
",4
32471882,32471749,2,"<p>One thing, you are initializing a string constant which are read only. You cannot change it the way you want.</p>

<p>For your requirements, you need a <code>char</code> array, and use <code>sprintf()</code></p>

<pre><code>char str[20];

sprintf(str, ""par-%2.1f.txt"", par);
</code></pre>
",0
32472001,32471749,3,"<p>This should work.</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
  FILE * fp; 
  double par;
  char filename[128];

  for(par=0.1; par&lt;1.001; par+=0.1)
  {   
    snprintf(filename, sizeof filename, ""par-%2.1f.txt"", par);
    // not 100% sure how the float will get parsed in.
    fp = fopen(filename, ""w"");//I want a changing filename here!!
    fprintf(fp, ""In this file, par is %lf"", par);
    fclose(fp);
  }   
  return 0;
}
</code></pre>
",1
28438003,28437895,2,"<p>you need to add <code>arr[0] = first</code> before calling GenProg</p>
",0
28438007,28437895,2,"<pre><code>first = input[0];
</code></pre>

<p>Pretty sure you have that backwards. Should be</p>

<pre><code>input[0] = first;
</code></pre>

<p>Also, there's no reason it should be in the loop body. It should go before the first for-loop.</p>
",0
27125025,27123921,2,"<pre><code>#include &lt;stdio.h&gt;

#define A 10
#define B 11
#define C 12
#define D 13
#define E 14
#define F 15

int main(void){
    int arr_hex[] = {6,1,6,2,6,5,6,A,7,A};
    int size = sizeof(arr_hex)/sizeof(*arr_hex);
    char arr_ascii[size/2];
    int i, j;
    for(j=i=0; j &lt; size/2; i+=2){
        printf(""%c"", arr_ascii[j++] = arr_hex[i]*16 + arr_hex[i+1]);
    }
    printf(""\n"");
    return 0;
}
</code></pre>
",0
27163166,27162507,3,"<p>You have lot of errors in your code, as @SSC suggested compile your code with all warnings. And use <code>gdb</code> or some other debugger to identify crash.</p>

<p>But to start with, in <code>main()</code> you have</p>

<pre><code>scanf( ""%s"", &amp;user );
...
scanf( ""%s"", &amp;pass );
</code></pre>

<p><code>user</code> and <code>pass</code> are <code>char</code> not <code>char *</code> nor <code>char</code> array. So when you read username it will overwrite memory. You need to use <code>char *</code> allocate memory appropriately or use <code>char</code> array.</p>

<p>Also there is </p>

<pre><code>scanf(""%d"", choice);
</code></pre>

<p>should be</p>

<pre><code>scanf(""%d"", &amp;choice);
//----------^
</code></pre>
",1
27176727,27162507,1,"<p>The problem with the code was mainly the poorly declared variables.
Especially the buffer variable which stores the file input. </p>

<p>The main error was however the somewhat ""dynamically assigned"" variable </p>

<blockquote>
  <p>""filename"" which was changed to ""fil"" and passed as an argument in the fileHandler function</p>
</blockquote>

<pre><code> /* Declaration of Global Variables */
char  message, chat ;
char user, pass, to, from;
int choice, response;
char filename[];
char buffer;
</code></pre>

<p>After fidgeting for a whole night and reading through myriads of manuals [which are not so well done for greenhorns ]( Yeah, I'm obviously a noob! ) </p>

<p>I tried many different things on the variables and came up with</p>

<pre><code>int choice, resp;
char user[], pass[], to[], message[], from[], chat[9999], buffer[9999];
</code></pre>

<blockquote>
  <p>Thanks Michel @ ueab for the support!!</p>
</blockquote>

<p>The functional yet graphically and functionally gruesome application can be found at: </p>

<blockquote>
  <p><a href=""https://github.com/ianmin2/chat"" rel=""nofollow"">https://github.com/ianmin2/chat</a></p>
</blockquote>
",0
29145137,29144595,1,"<p>The integral of from 0 to infinity of cos(x)/sqrt(x), or sin(x)/sqrt(x) is well known to be sqrt(pi/2).   So evaluating pi to any number of digits is easier problem.  Newton did it by integrating a quarter circle to get the area = pi/4. The integrals are evaluated by the methods of complex analysis. They are done in may text books on the subject, and on one of my final exams in graduate school.</p>
",5
29147735,29144595,1,"<p>For a non-periodic function that converges to zero you can (sort of) do a check of the function's value and compare to a minimum error value, but this doesn't work for a periodic function as you get an early exit before the integrand sum converges (as you've found out). For a non-periodic function you can simply check the change in the integrand sum on each iteration to a minimum error but that won't work here either.</p>

<p>Instead, you'll have to do like a few comments suggest to check for convergence relative to the period of the function, PI in this case (I found it works better than using 2*PI). To implement this do something like the following code (note I changed your sum to be the actual area instead of doing it at the end):</p>

<pre><code>sumFirstAndLast = (0.5*func(a) + 0.5*func(b)) * stripSize;
double z = a + stripSize;
double CHECK_RANGE = 3.14159265359;
double NextCheck = CHECK_RANGE;
double LastCheckSum = 0;
double MinError = 0.0001;

for (int i = 1; i &lt; 1000000000; i++) 
{
     sumFirstAndLast += func(z) * stripSize;

     if (z &gt;= NextCheck)
     {
          if (fabs(LastCheckSum - sumFirstAndLast ) &lt; MinError) break;
          NextCheck += CheckRange;
          LastCheckSum = sumFirstAndLast;
     }

     z += stripSize;
     count++;
}                                                 
</code></pre>

<p>This seems to work and give the result to the specified accuracy according to the value of <code>MinError</code>. There are probably other (better) ways to check for convergence when numerically integrating a periodic function. A quick Google search reveals <a href=""http://dip.sun.ac.za/~weideman/TW324/monthly021-036.pdf"" rel=""nofollow"">this paper</a> for example.</p>
",1
25448668,25448626,9,"<pre><code>i = (1 &amp;&amp; ((2 + 3) | 4)))
</code></pre>

<p>Boolean expression in C always evaluates to 0 or 1. Anything that's not 0 is considered true.</p>

<blockquote>
  <ul>
  <li>1 != 0  </li>
  <li>2 + 3 == 5  </li>
  <li>5 | 4 == 5 (| is the bitwise or operator)  </li>
  <li>5 != 0  </li>
  <li>1 &amp;&amp; 5 == 1  </li>
  </ul>
</blockquote>
",3
25448795,25448626,2,"<p>Based on the operator precedence, <code>+</code> has highest precedence so is evaluated first, then <code>|</code> (bitwise or), then <code>&amp;&amp;</code> (logical and):</p>

<pre><code>i = 1 &amp;&amp; ((2 + 3) | 4)
</code></pre>

<p>Evaluating this out:</p>

<pre><code>i = 1 &amp;&amp; (5 | 4)
</code></pre>

<p><code>|</code> is bitwise or, which returns a value which has a bit set in every location that either of its operands have a bit set. 5 is <code>101</code> in binary, 4 is <code>100</code>, so the bitwise or is <code>101</code>, or 5:</p>

<pre><code>i = 1 &amp;&amp; 5
</code></pre>

<p>Now <code>&amp;&amp;</code> is logical and, which returns 1 if both of the values are true values. Anything besides 0 is a true value, so it returns 1.</p>
",0
25451295,25448626,1,"<p>Look up the C Precedence Table when you are not sure.</p>

<p><a href=""http://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B#Operator_precedence"" rel=""nofollow"">Operators in C and C++</a></p>
",0
21036618,21036506,3,"<p>This is not at all how you access elements of a 2D array. There are several things wrong here. For one, you are looping over both <code>i</code> and <code>j</code> - but since you are taking <code>j</code> from <code>0</code> to <code>8</code>, you will run into trouble when you hit a value i>0. You could just do</p>

<pre><code>#include &lt;stdio.h&gt;

int main(){

  int n[3][3] = {2, 4, 3, 6, 8, 5, 3, 5, 1};

  int j=0;   
  int *ptr = &amp;n[0][0];

  for(j=0; j&lt;9; j++)
  {
     printf(""%d\t"",*(ptr+j)) ;
  }

  return 0; 
}
</code></pre>

<p>It is a bit simpler, but maintains the essence of your code - in that it is setting a pointer to the start of the array, and incrementing this pointer.  Some variations:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(){

  int n[3][3] = {2, 4, 3, 6, 8, 5, 3, 5, 1};

  int j=0;   
  int *ptr = &amp;n[0][0];

  for(j=0; j&lt;9; j++)
  {
     printf(""%d\t"",*(ptr++)) ;
  }

  return 0; 
}
</code></pre>

<p>or</p>

<pre><code>#include &lt;stdio.h&gt;

int main(){

  int n[3][3] = {2, 4, 3, 6, 8, 5, 3, 5, 1};

  int i, j;   
  int *ptr = &amp;n[0][0];

  for(i=0; i&lt;9; i+=3)
  {
    for(j=0; j&lt;3; j++)
    {
     printf(""%d\t"",*(ptr+i+j)) ;
    }
  }

  return 0; 
}
</code></pre>

<p>And of course the old stand-by:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(){

  int n[3][3] = {2, 4, 3, 6, 8, 5, 3, 5, 1};

  int i, j;   

  for(i=0; i&lt;3; i++)
  {
    for(j=0; j&lt;3; j++)
    {
     printf(""%d\t"",n[i][j]);
    }
  }

  return 0; 
}
</code></pre>

<p>See if these different methods make sense for you. Ask questions if they don't.</p>

<p><strong>EDIT</strong> a simple modification to your program shows better what the bug in your original code is:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(){
  int i, j;

  for(i=0; i&lt;3; i++)
    for(j=0; j&lt;9; j++)
    {
       printf(""i = %d; j = %d; i + j = %d\n"", i, j, i+j);
    }
   return 0;
}
</code></pre>

<p>Which prints out the values of <code>i</code> and <code>j</code> in the inner loop (where you were trying to print the array elements in turn). You get:</p>

<pre><code>i = 0; j = 0; i + j = 0
i = 0; j = 1; i + j = 1
i = 0; j = 2; i + j = 2
i = 0; j = 3; i + j = 3
i = 0; j = 4; i + j = 4
i = 0; j = 5; i + j = 5
i = 0; j = 6; i + j = 6
i = 0; j = 7; i + j = 7
i = 0; j = 8; i + j = 8
i = 1; j = 0; i + j = 1
i = 1; j = 1; i + j = 2
i = 1; j = 2; i + j = 3
i = 1; j = 3; i + j = 4
i = 1; j = 4; i + j = 5
i = 1; j = 5; i + j = 6
i = 1; j = 6; i + j = 7
i = 1; j = 7; i + j = 8
i = 1; j = 8; i + j = 9
i = 2; j = 0; i + j = 2
i = 2; j = 1; i + j = 3
i = 2; j = 2; i + j = 4
i = 2; j = 3; i + j = 5
i = 2; j = 4; i + j = 6
i = 2; j = 5; i + j = 7
i = 2; j = 6; i + j = 8
i = 2; j = 7; i + j = 9
i = 2; j = 8; i + j = 10
</code></pre>

<p>As you can see, you get far too many elements printed, and you ""fall off the edge"" because when <code>i + j</code> > 8 you are accessing memory beyond that which was assigned. Which leads to Undefined Behavior. But it's usually a Bad Thing.</p>
",1
22122963,18290680,0,"<p>The C language has the notion of <em>linkage</em>. Linkage is a property of <em>names</em> and describes the meaning of names across different translation units. The details are e.g. in C11 6.2.2..</p>

<p>Briefly, linkage can be either <em>external</em> or <em>internal</em> or <em>none</em>. Only the names that are identifiers of objects or functions can have linkage. For example, functions have external linkage unless they're declared as <code>static</code>, in which case they have internal linkage. Local variables that are not declared <code>extern</code> have no linkage, as per 6.2.2/6:</p>

<blockquote>
  <p>The following identifiers have no linkage: an identifier declared to be anything other than
  an object or a function; an identifier declared to be a function parameter; a block scope
  identifier for an object declared without the storage-class specifier <code>extern</code>.</p>
</blockquote>

<p>In terms of the implementation, names without linkage do not need symbolic placeholders in the generated machine code, since they can be referred to directly. Names with internal linkage may or may not need a symbol, but if they do it has to be unique and depends only on the translation unit that declares the name. Things with external linkage are the ones subject to proper linking and need to be findable by the linker across translation units.</p>
",0
23852858,23852737,1,"<p>I will give you the pseudo code:</p>

<pre><code>   1: input n numbers using scanf() 
   2:sort the array using any sort algorithm.
   3:once it is sorted you can easily count if( a[i]==a[i+1])
   4: print count and a[i]
</code></pre>

<p>Or</p>

<pre><code>  1:input n numbers using scanf() 
  2: for i=0 till n-1{
  3:      for j=i+1 till n{
  4:          if a[i] equal to a[j]
                    if(prev_read[j-1]==i)
                      ignore and break
                    prev_read[j-1]==i
  5:                count++
  6:          else
                    prev_read[j-1]=-1
  7:                count =1
           }
  8:      print a[i] and count
      }
</code></pre>

<p>I think this should solve your problem. I hope you are not looking into optimization now so this could be a solution. You will face some errors for sure.I did not test this. Hope this helps.</p>
",1
21157083,19502246,1,"<pre><code>       #include &lt;stdio.h&gt;
       #include&lt;sys/types.h&gt;
       #include&lt;sys/unistd.h&gt;
       #include &lt;math.h&gt;
       enum  //these are modes to open the file
       { 
           reading=0; 
           writing=1;
           readwrite=2;
       }
       int main()
       {
           unsigned long int a[10];
           int file_1,i=0,lim,pid,j,k=0,res;
           if((pid=fork())==0) //child process
           {
               file_1=open(""Program_name"",mode); //program name has to be the path
               if(file_1&lt;0)
               {
                   exit(1);
               }
               else
               {
                   while(1)
                   {
                       i=0;
                       j=9;
                       res=0;
                       while(i&lt;10)
                       {
                           lim=read(file_1,&amp;ch,sizeof(char));
                           if(lim&lt;=0)
                           {
                               exit(2);
                           }
                           dig=convert(&amp;ch);
                           res=res+dig*pow(10,j); //code to make a 10 digit number
                           j--;
                       }
                       a[k]=res;
                       k++;
                   }  
               }
               close(file_1);
           } //child process ends here
           else //parent process begins here
           {
               /*code that use the digits above */
           }
           return 0;
       }
       int converter(char *p) //this function coverts char to integer
       { 
           int num;
           *p=*p-'0';
           num=(int)*p;
           return num;
       }    
</code></pre>
",2
29460167,29460096,0,"<p>It is probably something to do with the <strong>return key</strong> you pressed to enter the input lying around in your input buffer. </p>

<p>To simply clear that character from the buffer you can read it and ignore it by adding <code>scanf(""%*c"");</code> immediately after you scan for a character from the <code>STDIN</code>. </p>

<p>So your new code would look something like this: </p>

<pre><code>printf(""Enter your choice:"");
scanf(""%c"",&amp;choice);
scanf(""%*c"");
</code></pre>
",1
25703199,25701020,0,"<pre><code>    fd=open(""/test.txt"",O_CREAT|O_RDWR|O_TRUNC,0777);
</code></pre>

<p>In this line specify path correctly.(i.e) It is current working directory means, keep (dot) <code>.</code> before <code>/</code> like<code>./test.txt</code></p>
",0
23070546,23070518,6,"<p>If <code>ut_slot_t</code> is a type then you have to put it in parentheses:</p>

<pre><code> ut_slot = malloc(tab_size * sizeof(ut_slot_t));
</code></pre>

<p><em>Edit:</em> The above is correct (I think!), but only one part of the problem. The other answer
solves it completely.</p>
",3
23070583,23070518,2,"<p>Change</p>

<pre><code>ut_slot = malloc(tab_size * sizeof ut_slot_t);
</code></pre>

<p>to </p>

<pre><code>ut_slot_t *ut_slot = malloc(tab_size * sizeof *ut_slot);
</code></pre>

<p>and remove <code>ut_slot</code> from the typedef:</p>

<pre><code>typedef struct _ut_slot {
...
...
} ut_slot_t;
</code></pre>
",1
32446195,32446079,1,"<p>strtok is the wrong function to use as it will split on <em>any</em> of the characters in the set of delimiters.</p>

<p>I'm not aware of any standard function to do what you want. You might have to  <a href=""https://stackoverflow.com/questions/14867213/does-strtok-work-with-strings-as-the-delimiter"">roll your own</a>.</p>
",4
32446381,32446079,1,"<p>In C ""splitting"" a string is really a matter of inserting a null terminator (0x00) in the string itself and let a new char* point to the next byte after it.</p>

<p>It's not so obvious how to do it and, more important, there are many ways to do it</p>
",0
33601747,33601548,1,"<p>The issue was that I had forgotten that I was using std::nth_element not std::sort in the c++ version.  That is why the code was slow.  I wrote a qselect and now the entire program is about the same speed.</p>

<pre><code>quantum_t quantum_qselect(quantum_t *v, size_t len, size_t k)
{
    size_t i, st;

    for(st = i = 0; i &lt; len - 1; i++)
    {
        if(v[i] &gt; v[len - 1])
            continue;
        swap(quantum_t, v[i], v[st]);
        st++;
    }

    swap(quantum_t, v[len - 1], v[st]);

    return k == st ? v[st] : st &gt; k ? quantum_qselect(v, st, k) : quantum_qselect(v + st, len - st, k - st);
}
</code></pre>
",1
28155492,28155371,4,"<p>Maybe this is not the most elegant solution, but you could use <a href=""http://www.tutorialspoint.com/c_standard_library/c_function_strtok.htm"" rel=""nofollow"">strtok()</a>. Assuming that all your words are separated by spaces, then it is just a matter of strtok'ing x number of times. I just threw this thing together real quick, but it should work OK, I hope.</p>

<pre><code>#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

int main( void ) {
    char str[] = ""This is a string\n"";
    char *token;
    int i;
    token = strtok( str, "" "");
    i = 1;
    while( token != NULL ) {
        if( 3 == i ) {
            fprintf( stdout, ""%s\n"", token );
            fflush( stdout );
        }
        token = strtok(NULL, "" "");
        i++;  // &lt;-- this was missing
    }
    return 0;
}
</code></pre>
",3
28156450,28155371,1,"<p>Use <code>""%n</code> to locate the ends of the sub-string being sought.</p>

<p>No modifications or copying of the source string are needed.</p>

<pre><code>void Print_Nth_word(const char *s, unsigned n) {
  if (n &gt; 0) {
    int left;
    int right;
    while (1) {
      left = right = 0;
      sscanf(s, "" %n%*s%n"", &amp;left, &amp;right);
      if (right &lt;= left) return;  // no sub-string (word) found
      if (--n == 0) break;
      s += right;
    }
    printf(""%.*s\n"", right - left, &amp;s[left]);
  }
}
</code></pre>

<p><code>"" %n%*s%n""</code> detail:<br>
<code>"" ""</code> Skip white space.<br>
<code>""%n""</code> Save offset of current scanning.<br>
<code>""*s""</code> Scan, but do not save non-whitespace.  (a word)</p>

<p><code>""%.*s"", right - left, &amp;s[left]</code> detail: Print <code>&amp;s[left]</code> up to  <code>right - left</code> characters.</p>
",0
22494868,22494845,5,"<p>You're getting that because whatever terminal program you're using isn't that compatible with some Unicode encodings.</p>

<p>For example, my Debian box compiles that fine and it actually prints out the smiley face, because <code>gnome-terminal</code> is a damn fine piece of software :-)</p>

<p>The fact that you're seeing three characters instead of one is a fairly good indication that it's outputting UTF-8. In fact, if I run that program on my Debian box and capture the binary output with <code>od -xcb</code>, I see:</p>

<pre><code>0000000    98e2    0abb
        342 230 273  \n
        342 230 273 012
0000004
</code></pre>

<p>showing that it <em>is</em> coming out in UTF-8, it's just that <code>gnome-terminal</code> is smart enough to  turn that back into the correct glyph.</p>

<p>Those bytes translate to binary as follows:</p>

<pre><code>e2          98          bb
1110 0010 : 1001 1000 : 1011 1011
</code></pre>

<p>And, using this excellent answer <a href=""https://stackoverflow.com/questions/6907297/can-utf-8-contain-zero-byte/6907327#6907327"">here</a>, stating that bit patterns starting with <code>10</code> are continuation bytes, we can decode it as follows:</p>

<pre><code>U+000800-U+00ffff  1110yyyy  yyyyyyyy xxxxxxxx
                   10yyyyxx
                   10xxxxxx

e2          98          bb
1110 0010 : 1001 1000 : 1011 1011
     yyyy     yy yyxx     xx xxxx
</code></pre>

<p>Hence the code point is <code>0010 0110 : 0011 1011</code> which equates to <code>263b</code> which, in a total lack of coincidence, is the <a href=""http://www.fileformat.info/info/unicode/char/263b/index.htm"" rel=""nofollow noreferrer"">black smiling face character</a>.</p>

<hr>

<p>In terms of fixing the problem of Windows not displaying Unicode correctly, as indicated by your comment:</p>

<blockquote>
  <p>I am on Windows Command Prompt. How should I make cmd.exe work with unicode?</p>
</blockquote>

<p>You may want to look at <a href=""https://stackoverflow.com/questions/379240/is-there-a-windows-command-shell-that-will-display-unicode-characters"">this question</a>, particularly the answer about using <code>chcp</code> to change the code page to 65001 (UTF-8). Note I haven't tested this, I provide it only as a pointer for you.</p>
",1
22495269,22494845,1,"<pre><code>#include &lt;fcntl.h&gt;

_setmode(_fileno(stdout), _O_U16TEXT);
wprintf(L""?\n"");
</code></pre>

<p>valter</p>
",0
22876009,22875984,2,"<p>Guessing here¡­
Your printout starts with the correct two digits: <code>78</code>.</p>

<p>But if you do not include a <code>\n</code> at the end of your formatting string, then the next thing you print will be concatenated. As will the next thing, and the next.</p>

<p>I suspect your problem will disappear when you change your print statement to</p>

<pre><code>printf(""%d\n"", num);
</code></pre>
",0
21023590,21023567,4,"<p>Because there is no condition to <code>break</code> out (terminate) the loop, i.e, this is an infinite loop.  </p>

<p>Try this instead:  </p>

<pre><code>while(1){
    if(scanf(""%f"", &amp;a) == 1)
    {
        b += a;
        counter++;
    }
    else break;
    }
}  
</code></pre>

<p>Now, pressing <kbd>Ctrl+Z</kbd> (as you mentioned in the question) will terminate the loop.</p>
",4
21023636,21023567,4,"<p>If you're in Linux and expect <kbd>Ctrl+Z</kbd> to finish the input, you're mistaken. It's <kbd>Ctrl+D</kbd>, but it's <kbd>Ctrl+Z</kbd> in Windows though.</p>

<p>(What <kbd>Ctrl+Z</kbd> does in Linux is generally (in Bash and other shells) to <em>suspend</em> the program, meaning it's temporarily stopped but still exists as a process.)</p>

<p>You should change your loop to something like:</p>

<pre><code>while(scanf(""%f"", &amp;a) == 1)
{
  b += a;
  ++counter;
}
</code></pre>

<p>and then try again with the EOF keyboard sequence (or just some non-numeric input).</p>
",0
21023647,21023567,0,"<p>instead of while(1), you need to test for eof().</p>

<p>Try <code>while(scant(""%f"", &amp;a) == 1)</code></p>

<p>see the man page for scant() and see what it says about return values, at the bottom.</p>
",0
21023662,21023567,0,"<p>Your control Z is affecting the entire program, since it is inside the loop when you hit cntrl-Z the final section never executes.</p>
",0
21024003,21023567,1,"<p>Rule of thumb:</p>

<p><strong>NEVER</strong> use an endless loop without making sure you have a <strong>hitable</strong> <code>break</code> statement.</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    float a;
    float b = 0;
    int counter = 0;
    while(1){
        if(scanf(""%f"", &amp;a) == 1)
        {
           b += a;
           counter++;
        }
        else break;
    }

    float average = b/counter;
    printf(""%f"", average);
    return 0;
}
</code></pre>
",0
21721975,21717361,0,"<p>Actually your compiler might implement some memory protection : like <a href=""http://en.wikipedia.org/wiki/Buffer_overflow_protection"" rel=""nofollow"">canaries</a> against buffer overflow/stack-smashing.</p>

<p>It inserts magic words before the return address and check its integrity before jumping at it.
You may have overwritten this marker.</p>
",0
26201820,26187037,5,"<p>This function takes delimiting, openblock and closeblock characters. Delimiting characters are ignored within the block and closing block characters must match the opening block characters.  The example splits on space and blocks are defined by quote and brackets, braces and &lt;>. Thanks to Jongware for comments!</p>

<pre><code>#include&lt;stdlib.h&gt;
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

char *strmbtok ( char *input, char *delimit, char *openblock, char *closeblock) {
    static char *token = NULL;
    char *lead = NULL;
    char *block = NULL;
    int iBlock = 0;
    int iBlockIndex = 0;

    if ( input != NULL) {
        token = input;
        lead = input;
    }
    else {
        lead = token;
        if ( *token == '\0') {
            lead = NULL;
        }
    }

    while ( *token != '\0') {
        if ( iBlock) {
            if ( closeblock[iBlockIndex] == *token) {
                iBlock = 0;
            }
            token++;
            continue;
        }
        if ( ( block = strchr ( openblock, *token)) != NULL) {
            iBlock = 1;
            iBlockIndex = block - openblock;
            token++;
            continue;
        }
        if ( strchr ( delimit, *token) != NULL) {
            *token = '\0';
            token++;
            break;
        }
        token++;
    }
    return lead;
}

int main (int argc , char *argv[]) {
    char *tok;
    char acOpen[]  = {""\""[&lt;{""};
    char acClose[] = {""\""]&gt;}""};
    char acStr[] = {""this contains blocks \""a [quoted block\"" and a [bracketed \""block] and &lt;other ]\"" blocks&gt;""};

    tok = strmbtok ( acStr, "" "", acOpen, acClose);
    printf ( ""%s\n"", tok);
    while ( ( tok = strmbtok ( NULL, "" "", acOpen, acClose)) != NULL) {
        printf ( ""%s\n"", tok);
    }

    return 0;
}
</code></pre>

<p>output<br>
this<br>
contains<br>
blocks<br>
""a [quoted block""<br>
and<br>
a<br>
[bracketed ""block]<br>
and<br>
  </p>
",1
28183532,28183508,7,"<p>Undefined behaviour is undefined. Anything could happen. In this case it looks like you're running past <code>argv</code> and into the third (less well known and certainly nonstandard) parameter of <code>main</code>, commonly called <code>envp</code>. <a href=""https://stackoverflow.com/questions/10321435/is-char-envp-as-a-third-argument-to-main-portable"">Relevant link</a>.</p>
",0
28183553,28183508,1,"<p>argv[2] is the third parameter of the command line like this code, argc is the number of parameters:</p>

<pre><code>int main(int argc, char const *argv[])
{
  int i = 0;
  for (; i &lt; argc; ++i)
  {
     printf(""%d -&gt; %s\n"", i, argv[i]); 
  }
  return 0;
}
</code></pre>

<p>See the process:</p>

<pre><code>F:\so&gt;tcc test.c

F:\so&gt;test.exe a b c
0 -&gt; test.exe
1 -&gt; a
2 -&gt; b
3 -&gt; c
</code></pre>

<p>test.exe is the first, a is the second, b is third, c is the fourth.
If you run test.exe whitout other parameters, it will say argv[2] means b here is not defined.</p>
",0
28184256,28183508,1,"<p>you'd better check ""argc"" firstly, then you can choose to use the valid ""argv""</p>
",0
23818447,23818288,0,"<p>You probably need dynamic memory allocation if you're unaware (at the time of writing the code) how much memory you will need. However, you could also allocate a static arbitrarily sized array instead.</p>

<p>If you're not sure how large <code>name</code> should be, you could:</p>

<p>a. Set a size limit and have the program respond accordingly when it is reached.</p>

<p>b. Dynamically allocate some memory and resize the allocation when it fills up.</p>

<p>I hope this helps.</p>
",0
23818458,23818288,2,"<p>Dynamic allocation would not make a difference; what you need to do is count how many characters you have read, and stop reading them when you run out of space.  In this case switch <code>11</code> for <code>sizeof name</code>.</p>

<p>If you want to stop when they press Enter, you have to check and see if the character you just read was <code>\n</code>, and stop if it is.  It would also be smart to stop if the input gets closed (which will be indicated by <code>scanf</code>'s return value being <code>0</code> or negative).</p>

<p>In C there is no builtin function to allocate as much memory as needed for what the person types; you would have to write a function to do that yourself, or use someone else's function. There is a POSIX function called <code>getline</code> which does something similar.</p>
",2
23821035,23818288,0,"<p>Modify your code as below.   </p>

<pre><code>#include &lt;stdio.h&gt;
main () {    
char name[10];    
int i=0;
for (i=0;i&lt;11;i++){
    scanf(""%c"",&amp;name[i]);
    if(name[i] == '\n')
    return 0;
    printf(""%c"",name[i]);
}    
</code></pre>
",3
25678429,25678377,1,"<p>You cannot redefine <code>int getline (char *, int);</code>. libc already contains a <code>getline</code> function. (see <code>man getline</code>) Did you compile with warning enabled? Try compiling with <code>-Wall -Wextra</code>. Rename <code>getline</code> to <code>getline2</code> or something else to avoid conflict with the previous declaration of <code>getline</code> in <code>stdio.h</code>. </p>

<p>As pointed out, since <code>getline</code> is not technically a <strong>reserved word</strong> it must be available for redefinition by a conforming ISO C implementation. <strong>However</strong>, as also pointed out, many of the ISO C implementations are <strong>non-conforming</strong> and will not allow this redefinition.</p>
",4
25679145,25678377,1,"<p>Variables are passed by value in C. The variable <code>p</code> inside <code>copy_lines</code> is a different variable to <code>p</code> in <code>readlines</code>. When the function is called, the former is created and initialized with the value of the latter. You could remove some confusing by using a different name for each of these variables.</p>

<p>To allow one function to modify a variable local to another function, you must pass a pointer to that variable. A pointer to a <code>char *</code> has type <code>char **</code>.</p>
",0
23108448,23106587,2,"<p>If you call you program like this <code>gpio-demo -g 255 -o 0</code>, than <code>argc</code> would be equal to <code>5</code> and <code>argv</code> will be a list of five pointers to sequences of characters where the first is <code>gpio-demo</code>, the second <code>-g</code>, the third <code>255</code>, ... </p>

<p>So if you really want to hardcode, you would have to write:</p>

<pre><code>argc = 5;
argv = (char**)malloc(sizeof(char*)*argc);
argv[0] = ""gpio-demo"";
argv[1] = ""-g"";
argv[2] = ""255"";
argv[3] = ""-o"";
argv[4] = ""0"";
</code></pre>

<p>However, I would not recommend this! Rather use a bash script with the desired command line.</p>
",8
33555949,33555762,1,"<p>You did not call the pow function correctly.</p>

<p>Change the pow function call to:</p>

<pre><code>y = pow(x, n); //call pow function
</code></pre>
",1
28221538,28221198,1,"<p>There is no straightforward way to accomplish this in the same way that C++ does. You can define a pointer to an opaque (i.e., incomplete) type, and use that to get data hiding. But to get private data members, you would need some kind of hack.</p>

<p>If you are satisfied with a hack, one way is to define a union type in the private implementation file to provide names to unnamed members implied in the public header file.</p>

<pre><code>/* header.h */
struct X {
    char private[SIZEOF_Y];
};

/* implementation.c */
struct Y {
    int private_a;
    float private_b;
};

union Z {
    struct X x;
    struct Y y;
};
</code></pre>

<p>This is a hack because type punning is being used across incompatible types <code>X</code> and <code>Y</code>. There is also no clean way to communicate the <code>SIZEOF_Y</code> value to the header file, although you may be able to automate its definition with a script that runs before compilation of the source files.</p>
",0
28221550,28221198,5,"<p>You need to create an opaque type for this, two structs which start with the same fields and then you can add private fields to one of them and never let the user access the one with the private fields.</p>

<p>Then provide accessor functions to modify/read the private fields in the struct.</p>

<p>An example is better than a thousand words</p>

<p><strong>struct.c</strong></p>

<pre><code>#include &lt;stdlib.h&gt;

struct Private
{
    int public;
    int private;
};

struct Public
{
    int public;
};

struct Public *new_public(int private, int public)
{
    struct Private *instance;
    instance = malloc(sizeof(*instance));
    if (instance == NULL)
        return NULL;
    instance-&gt;private = private;
    instance-&gt;public  = public;

    return (struct Public *)instance;
}

int public_get_private(struct Public *public)
{
    if (public == NULL)
        return -1; /* or some invalid value */
    return ((struct Private *)public)-&gt;private;
}

void public_set_private(Public *public, int value)
{
    if (public == NULL)
        return;
    ((struct Private *)public)-&gt;private = value;
}
</code></pre>

<p><strong>struct.h</strong></p>

<pre><code>#ifndef __STRUCT_H__
#define __STRUCT_H__

struct Public
{
    int public;
};

typedef struct Public Public;

Public *new_public(int private, int public);
int public_get_private(Public *instance);
void public_set_private(Public *instance, int value);
/* you can add more fields to the structures and more access functions */

#endif
</code></pre>

<p><strong>main.c</strong></p>

<pre><code>#include ""struct.h""

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main()
{
    Public *instance;

    instance = new_public(1, 2);
    if (instance == NULL)
        return -1;
    printf(""%d\n"", instance-&gt;public);
    printf(""%d\n"", public_get_private(instance));

    free(instance);

    return 0;
}
</code></pre>

<ol>
<li><code>new_public()</code> acts as a constructor.</li>
<li>You can get the value at <code>private</code> by means of the function <code>public_get_private()</code> which behaves as a member function.</li>
<li>You can't access the <code>private</code> member from the <code>Public</code> struct.</li>
</ol>

<p>Of course you can do stupid things like</p>

<pre><code>Public *public = malloc(sizeof(*public));
</code></pre>

<p>but thats what I find so sweet about c, you are free to do whatever you want, just don't do things wrong.</p>

<p>I also think this is nicer than <code>private</code> members, because both the definition and the implementation details are hidden from the library user.</p>
",0
22420969,22420888,1,"<p>Your question about when you reach the end of file, there is a function for it naming 'end of file' in short EOF heres a good example:</p>

<p><a href=""http://mathbits.com/MathBits/CompSci/Files/End.htm"" rel=""nofollow"">Eof example</a> </p>
",0
22420974,22420888,3,"<blockquote>
  <p>But if i was to run a unknown file i wouldn't know how many are in it.</p>
</blockquote>

<p>Replace</p>

<pre><code>int i = 0;
for ( i = 0; i &lt; 5; i++)
{
    fgets(buf, 40, pFile);
    x[i] = atoi(buf);

    fgets(buf, 40, pFile);
    y[i] = atof(buf);

    fgets(buf, 40, pFile);
    z[i] = buf[0];

    fgets(str, 40, pFile);
    str[strlen(str) - 1] = '\0';

    printf(""\n %s \n"", str);

    printf(""\n %i \n"", x[i]);
    printf(""\n %f \n"", y[i]);
    printf(""\n %c \n"", z[i]);
}
</code></pre>

<p>with</p>

<pre><code>int i = 0;
while (fgets(buf, 40, pFile))
{
    x[i] = atoi(buf);

    fgets(buf, 40, pFile);
    y[i] = atof(buf);

    fgets(buf, 40, pFile);
    z[i] = buf[0];

    fgets(str, 40, pFile);
    str[strlen(str) - 1] = '\0';

    printf(""\n %s \n"", str);

    printf(""\n %i \n"", x[i]);
    printf(""\n %f \n"", y[i]);
    printf(""\n %c \n"", z[i]);
    i++;
}
</code></pre>

<p>Avoid the use of magic numbers like <code>40</code>, use <code>sizeof(buf)</code></p>
",0
33016280,33016123,0,"<p>I don't know why you have hexa string there, but what it is doing is dividing the int num by 2 if it's even <code>n%2 = 0</code> so the element 0 of the string will be picked ('0') if it's odd <code>n%2 = 1</code> so it will pick element 1 of the array ('1'). In the loop the pointer <code>p</code> goes backwards in the retbuff to place each char ('0' or '1') in order</p>

<p>It's a really weird way of doing this</p>
",0
33016296,33016123,8,"<p>Using string is equivalent to using an array. In this specific case the following would be sufficient:</p>

<pre><code>*--p = ""01""[num % 2];
</code></pre>

<p>Since only the first 2 positions of the array is in use. I assume that the entire string ""01...ef"" is from a similar function that converted to hex.</p>
",1
33016341,33016123,4,"<p>Keep in mind that in  C a String is just a character array. So</p>

<pre><code>*--p = ""0123456789abcdef""[num % 2];
</code></pre>

<p>is the same as if you had </p>

<pre><code>char digits[] = ""0123456789abcdef"";
....
*--p = digits[num % 2];
</code></pre>

<p>and like others have alrady pointed out, <code>*--p</code> will be set to <code>'0'</code> or <code>'1'</code> depending on <code>num</code> being even or odd</p>
",0
33016397,33016123,3,"<p>In C, a constant string points to the memory location of its first element;</p>

<p>array name without square brackets also points to the address of the first element of the array. So elements in a constant string can be accessed in the same way as we do with array.</p>

<p>See the example below</p>

<pre><code>char arr[10] = ""Hello"";

printf(""%c %c"", arr[4], ""Hello""[4]);
</code></pre>

<p>It will print the charecter 'o' 2 times.
Hope you understood.</p>
",0
33017768,33016123,2,"<p>For the record, just in case someone stumbles over this question in the future, the function posted is horrible, don't use it. A proper way to implement this algorithm would be something like this:</p>

<pre><code>#include &lt;inttypes.h&gt;
#include &lt;stdio.h&gt;

char* uint32_to_binstr (uint32_t num, char buf[32+1]);

static size_t get_bin_digits (uint32_t i);

int main(void)
{
  char str[32+1];

  printf(""%u\t-&gt; %s\n"",     0, uint32_to_binstr(    0, str));
  printf(""%u\t-&gt; %s\n"",     2, uint32_to_binstr(    2, str));
  printf(""%u\t-&gt; %s\n"",    15, uint32_to_binstr(   15, str));
  printf(""%u\t-&gt; %s\n"",   255, uint32_to_binstr(  255, str));
  printf(""%u\t-&gt; %s\n"", 12345, uint32_to_binstr(12345, str));
}

char* uint32_to_binstr (uint32_t num, char buf[32+1])
{
  const uint32_t BASE = 2;

  // count the number of binary digits in advance, to get a left-aligned string:
  size_t digits = get_bin_digits(num); 
  size_t i;

  for(i=0; i&lt;digits; i++)
  {
    char ch = num % BASE + '0';
    buf[digits-i-1] = ch; // have to write string from right to left
    num /= BASE;
  }

  buf[i] = '\0';
  return buf;
}

static size_t get_bin_digits (uint32_t i)
{
  size_t digits = 0;

  if(i==0)
  {
    return 1;
  }

  for(; i&gt;0; i&gt;&gt;=1)
  {
    digits++;
  }

  return digits;
}
</code></pre>

<p>Output:</p>

<pre><code>0       -&gt; 0
2       -&gt; 10
15      -&gt; 1111
255     -&gt; 11111111
12345   -&gt; 11000000111001
</code></pre>
",4
21567013,21566960,1,"<p>The problem is on the line </p>

<pre><code>strcpy(dirs[counter], token);
</code></pre>

<p>At the beginning, you initialize all elements in <code>dirs</code> as <code>NULL</code>. Thus, here on the above line you copies <code>token</code> into <code>NULL</code>.</p>
",0
22454940,22454901,2,"<p><code>p-&gt;clg_data</code> is not a pointer. Use <code>.</code> to access its members</p>

<pre><code>    p-&gt;clg_data.college_id = 3;
</code></pre>
",2
31856903,31856372,1,"<p>This looks like a use case for the <code>stdarg</code> set of macros:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdarg.h&gt;

void bar(int n, ...) {
    va_list args;
    int arg1, arg2;
    char *arg3;

    va_start(args, n);
    arg1 = va_arg(args, int);
    arg2 = va_arg(args, int);
    arg3 = va_arg(args, char *);
    printf(""arg1=%d, arg2=%d, arg3=%s\n"", arg1, arg2, arg3);
    va_end(args);
}

int main()
{
    int a=1, b=2;
    char c[] = ""hello"";

    bar(3, a, b, c);
    return 0;
}
</code></pre>

<p>Output:</p>

<blockquote>
  <p>arg1=1, arg2=2, arg3=hello</p>
</blockquote>

<p>You first call <code>va_start</code> to begin processing of the additional arguments, passing it the last known argument.  Then use <code>va_args</code> to return each argument, passing it the expected type.  Finish processing by calling <code>va_end</code>.</p>

<p>For more info: <a href=""http://linux.die.net/man/3/stdarg"" rel=""nofollow"">http://linux.die.net/man/3/stdarg</a></p>
",4
31857278,31856372,2,"<p>A non-standard, but defined way would be to use <a href=""http://man7.org/linux/man-pages/man3/alloca.3.html"" rel=""nofollow""><code>alloca()</code></a> :</p>

<pre><code>void bar() {
    int *storage = alloca(size * sizeof storage);
    foo(storage);
}
</code></pre>

<p>A standard way, but that needs C99 support, would be a <a href=""http://en.cppreference.com/w/c/language/array#Variable-length_arrays"" rel=""nofollow"">VLA</a> :</p>

<pre><code>void bar() {
    int storage[size];
    foo(storage);
}
</code></pre>
",0
22120403,22120362,3,"<p>The compiler creates a different instance for every global static variable, even when you have several such variables with identical names.</p>

<p>In fact, the compiler (or possibly, the preprocessor) implicitly changes the name of every such variable, according to the name of the source file which declares it.</p>

<p>You can prove this to yourself by declaring a global static variable in a header file, and then include this header file in several different source files. Try to set it to a different value in each source file, and you'll see that this variable retains its different value in each source file.</p>

<p>If you want to have <strong>the same instance</strong> of a global variable accessible in several source files, then you should <strong>refrain</strong> from declaring it <code>static</code>:</p>

<ul>
<li>If you declare it in a header file, then use <code>extern</code> as prefix, and include the header file in every source file that makes use of this variable.</li>
<li>If you declare it in a source file, then you will have to declare it as <code>extern</code> in every <strong>other</strong> source file that makes use of this variable.</li>
</ul>

<p>The address of an external global variable is determined <strong>only during linkage</strong>. This is in contrast with the following cases, in which the address of the variable is determined <strong>during compilation</strong>:</p>

<ul>
<li>A local variable</li>
<li>A static local variable</li>
<li>A static global variable</li>
<li>A non-external global variable</li>
</ul>

<hr>

<p>I believe that the term <code>static linkage</code> refers to the linkage of compiled objects (or libraries) into the executable image <strong>during the build process</strong>, as opposed to <code>dynamic linkage</code> which refers to the linkage of compiled code (also known as DLL) into the executable image <strong>only during runtime</strong>.</p>

<hr>

<p><strong>UPDATE:</strong></p>

<p>After reading your clarification, I understand that the only issue is with a local variable and a global variable of the same name (the <code>static</code> attribute makes no difference with regards to this issue).</p>

<p>Inside a function, a local variable is always ""preferred by the compiler"" over a global variable with the same name. In other words, in function <code>f</code>, all operations on variable <code>b</code> are applied on the local variable and not on the global variable.</p>
",4
21304943,21304844,6,"<p>Cast the lower byte:</p>

<pre><code>uint16_t a[1] = {0x2321};
uint8_t b[1] = {(uint8_t)(a[0] &amp; 0xFF)};
</code></pre>
",5
21305118,21304844,2,"<p>Use a bitmask to get the least significant byte:</p>

<pre><code>uint8_t b[1];
b[0] = (a[0] &amp; 0xff);
</code></pre>
",0
21306617,21304844,1,"<p>Just </p>

<pre><code>b[0] = a[0];
</code></pre>

<p>or in a declaration inside a function (this is not legal at file scope):</p>

<pre><code>uint8_t b[1] = { a[0] };
</code></pre>

<p>There is a well-defined implicit conversion from unsigned intgral types to smaller unsigned integral types; the value is reduced modulo (1 + maximum value of the smaller type).</p>

<p>You don't need any casts or bitmask operations, although some compilers may give a specious (IMHO) warning about loss of precision if you don't write a cast to suppress this warning.</p>
",0
22468549,22468440,2,"<p>See <a href=""http://en.wikibooks.org/wiki/C_Programming/C_Reference/string.h/strcmp"" rel=""nofollow"">http://en.wikibooks.org/wiki/C_Programming/C_Reference/string.h/strcmp</a> and repetition structures to improve your program</p>

<p>You can't compare strings using (*a == *b), this is equivalent to (a[0] == b[0]), with this you are comparing the first letter of each string</p>

<p>Your scanf can't read a line, so when you write - go north, it just takes go, and the other scanf gets north</p>

<p>I will not give you the answer because I think it's more fun and productive if you find it</p>
",0
26139653,26139617,3,"<p>You must have been reading pretty quickly.</p>

<p>I'm rather sure the book explains that a statement can be either simple, in which case it's just a single statement terminated by <code>;</code>, or compound in which case it's a list of statements enclosed by <code>{</code> and <code>}</code>.</p>

<p>The body of the <code>for</code> loop is a statement, and can thus be either simple or compound.</p>

<p>Of course the wording above is recursive, which is intentionally. This is perfectly valid:</p>

<pre><code>for(fahr = 0; fahr &lt;= 300; fahr += 20)
{
  printf(""%d"", fahr);
  {
    printf("" %6.1f"", (5.0 / 9.0) * (fahr - 32));
    {
      printf(""\n"");
    }
  }
}
</code></pre>

<p>It's of course an utterly annoying and pointless way to write this very simple loop, but it illustrates that wherever there can be a statement, there can be a compound statement. This is sometimes handy if you want a ""more local"" variable, especially in pre-C99 versions of the language.</p>
",1
26139659,26139617,0,"<p>by default next statement to  <code>for(...)</code> loop other then comment will be considered as body of the loop. however it is good to put it. curly braces is must if you want it should be treated as body of any construct.</p>

<pre><code>for(...)
  {
    // body of the loop
    ...
  }
</code></pre>
",1
26139661,26139617,0,"<p>Curly braces are not need when one statement needs to be executed by a <code>for</code> loop. However,if multiple statements needs to be looped by the <code>for</code> , you need the curly braces.</p>

<p>In your case,the printf is considered as the body of the loop and it will be executed until the condition in the <code>for</code> becomes false. But it is a good practice to include the braces as it increases the legibility of the code as well as prevent mistakes which might happen in the future when editing the program.</p>

<p>This is the same for <code>while</code>,<code>if</code> etc</p>
",1
26139664,26139617,0,"<p>This is basic C syntax, that has been valid since the dawn of time (well, since the early 70s, but <a href=""https://en.wikipedia.org/wiki/Unix_time"" rel=""nofollow"">Unix</a> considers that the dawn of time). The body of a <code>for</code> loop is always a statement. A statement can either be simple, like the one you show, or a <em>block</em> of statements in curly braces. So you only need the braces if the body contains multiple statements. I'm pretty sure K&amp;R explain this somewhere.</p>

<p>This is true in C, C++, D, Java and Objective-C. Perl and Go are the exceptions.</p>

<p>I would add, though, that putting in the curly braces even though they're not necessary doesn't hurt, and I've adopted these ""useless"" braces as part of my coding style, to prevent mistakes like</p>

<pre><code>if (condition)
    do_one_thing();
    and_another_thing();
</code></pre>

<p>which can creep into code when editing it.</p>
",1
26139684,26139617,0,"<p>In C if the construct, control or selection body contains only a single statment, then it is not necessary to include it in braces</p>

<p>That is </p>

<pre><code>for (fahr = 0; fahr &lt;= 300; fahr = fahr + 20)
    printf(""%3d %6.1f\n"", fahr, (5.0/9.0)*(fahr-32));
</code></pre>

<p>is treated same as </p>

<pre><code>for (fahr = 0; fahr &lt;= 300; fahr = fahr + 20)
{
    printf(""%3d %6.1f\n"", fahr, (5.0/9.0)*(fahr-32));
}
</code></pre>
",0
30695732,30695658,2,"<p>Here the issue:</p>

<pre><code>if (*pnt_d2 &gt; largest) // 2 &gt; 1
    largest = *pnt_d2; // largest = 2
else if...
</code></pre>

<p>Because of <code>else if</code> code jumps there:</p>

<pre><code>*pnt_d1 = smallest; // not changed and equal to 2
*pnt_d2 = middle;   // not changed and equal to 3
*pnt_d3 = largest;  // updated by 'if' and equal to 2 
</code></pre>
",1
30695778,30695658,3,"<p>Basically if the following <code>if</code> succeeds, none of the other statements are executed because they are in <code>else if</code>. So you want to remove all <code>else</code> and just check <code>if(condition)</code> 6 times. So something like</p>

<pre><code>if (*pnt_d2 &gt; largest)
    largest = *pnt_d2;

if (*pnt_d3 &gt; largest)
    largest = *pnt_d3;

 ....
</code></pre>
",2
26196743,26195895,4,"<p>Why not simply:</p>

<pre><code>void createWindow(Control * c) {
    *c = {
        .type = ""window"",
        .surface = SDL_SetVideoMode(WIN_W, WIN_H, 24, SDL_SWSURFACE),
        .height = WIN_H,
        .width = WIN_W,
        .x = 0,
        .y = 0
    };
}
</code></pre>

<p>and then:</p>

<pre><code>Control c;
createWindow(&amp;c); 
</code></pre>

<p>This way you allocate the space for the object in the call location and pass its address to the function to initialize that address, this is effectively a by-hand implementation of RVO, the compiler will most likely be smart enough and figure out the pointer is to a stack object and directly initialize the data in-place without calling the function.</p>

<p>Referencing to memory on the stack to use an object whose function has already returned is a very bad idea. That data might remain there ""for a while"", but when the stack reaches that depth again, the data will be overwritten and next time you will either get and/or make garbage. You can also dynamically allocated memory and return a pointer to it, WHILE remembering to deal with that data in the calling location or relying on some other management scheme, but that would be overkill with a tiny overhead that can be avoided in your case.</p>

<p>A global would be a rather clumsy solution to your problem, and entirely pointless. If you decide to have more than 1 window, are you going to edit the source and recompile to add another global each time you need one? Doesn't seem like a good idea. </p>

<p>EDIT: I didn't test that code before posting it, assuming it would work but it doesn't seem that designated initializers work with dereferenced pointers. Casting the initializer to the type works as you noted in the comments, and the code generated by the compiler should be identical to initializing ""procedurally"", i.e. <code>c-&gt;type = ""window""</code> and so on which is what I would personally do.</p>
",4
26196610,26195895,1,"<p>Let's take a look at your CreateWindow function.</p>

<pre><code>Control* createWindow() {
    Control window = {
        .type = ""window"",
        .surface = SDL_SetVideoMode(WIN_W, WIN_H, 24, SDL_SWSURFACE),
        .height = WIN_H,
        .width = WIN_W,
        .x = 0,
        .y = 0
    };
    return &amp;window;
}
</code></pre>

<p>You are creating a new Control structure on the stack, and later returning the address. Since the structure is not on the heap, the data in the place is probably modified. You want save the Window on the heap.</p>

<p>Take a look at this answer: <a href=""https://stackoverflow.com/questions/1623024/creating-a-struct-on-the-heap"">Creating a struct on the heap?</a></p>
",0
26196633,26195895,2,"<p>You are returning a pointer to a local variable. You have to remember that (non-static) local variable goes out of scope and wont exist anymore when the function they are defined in returns.</p>

<p>Returning, and using, this pointer will lead to <a href=""http://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow""><em>undefined behavior</em></a>, which is what you're seeing.</p>

<p>My suggestion on how to fix the problem? Don't return a <em>pointer</em>, return a <em>copy</em>.</p>

<hr>

<p>If you desperately need want to return a pointer, which you don't really need to do in that function, you must allocate it of the heap using <a href=""http://en.cppreference.com/w/c/memory/malloc"" rel=""nofollow""><code>malloc</code></a>. Remember that you then have to <a href=""http://en.cppreference.com/w/c/memory/free"" rel=""nofollow""><code>free</code></a> it.</p>
",2
26161262,26161237,9,"<p>You're using the wrong syntax when casting (you're using one of C++'s many styles of casting, but for C there is only one way). Change:</p>

<pre><code>sqrt(float(n))
</code></pre>

<p>to</p>

<pre><code>sqrt((float)n)
</code></pre>

<p>Note however that <code>sqrt</code> takes a <code>double</code>, so strictly speaking this should be:</p>

<pre><code>sqrt((double)n)
</code></pre>

<p>Note also that the cast is not necessary, and you can just write:</p>

<pre><code>sqrt(n)
</code></pre>
",0
26161268,26161237,3,"<p>Change this</p>

<p><code>sqrt(float(n))</code></p>

<p>to this</p>

<p><code>sqrt((float)n)</code></p>

<p>You want to cast <code>n</code> to float.</p>

<p>You should use this function:</p>

<p><code>float sqrtf (float x);</code></p>

<p>which in C99 receives a float as an argument. Otherwise, it would be better to cast into double (if you use sqrt()).</p>

<p><a href=""http://www.cplusplus.com/reference/cmath/sqrt/"" rel=""nofollow"">sqrt-ref</a></p>

<p>What you have written:</p>

<p><code>float(n)</code></p>

<p>is like saying that float is a name of a function and you pass to it the parameter n.</p>

<p>Notice, that in your case, you don't need casting, since it's going to be performed automatically (to float if you use sqrtf() or to double if you use sqrt()).</p>

<hr>

<p>Other notes, irrelevant with your syntax error.</p>

<p>Why not start the loop from 3 and increase the counter by two? If you think about it, this will faster and will produce the same results. If you want to test yourself, check my example <a href=""http://gsamaras.wordpress.com/code/isprime-c/"" rel=""nofollow"">here</a>.</p>

<p>Also, what I had found pretty exciting when I was searching for primes, is the sieve of Eratosthene's (¦ª?¦Ò¦Ê¦É¦Í¦Ï ¦Ó¦Ï¦Ô ¦¥¦Ñ¦Á¦Ó¦Ï¦Ò¦È?¦Í¦Ç) . <a href=""http://gsamaras.wordpress.com/code/eratostheness-sieve-c/"" rel=""nofollow"">Here is</a> an example of it.</p>
",0
26161281,26161237,2,"<p>If you want to cast <code>n</code> to a <code>float</code>, use <code>(float)n</code>.</p>
",0
26164106,26161237,1,"<p>Just do:</p>

<pre><code>sqrt(n);
</code></pre>

<p>You'll be having the exam same result as the casting for your case.</p>
",0
24358962,24358849,0,"<p>I think the problem is in this condition ""c != '\n'"" which is breaking the for loop right after the first line, before it reaches any brackets. And hence the output. </p>
",4
24359007,24358849,4,"<p>There are several problems. 
Lets go through it step by step</p>

<p>1) Your array initialization loop:</p>

<pre><code>int brackets[limit]; 
char braces[limit]; 

for(i = 0; i &lt; 100; i++)
{
    braces[i] = 0; 
}
</code></pre>

<p>You declare the array having size of <code>limit</code> but only initialize 100 items. Change 100 to limit to fully initialize it depending on the parameter of the function.</p>

<p>2) The conditional statement of the main for loop:</p>

<pre><code>i &lt; limit - 1 &amp;&amp; (c = getc(cfile)) != EOF &amp;&amp; c != '\n'
</code></pre>

<p>Although the first substatement is correct I have two remarks:</p>

<p>Firstly <code>(c = getc(cfile)) != EOF</code> might be one reason why the loop is never accessed and still everything is <code>000000...</code>. Check if the file exists, the pointer is not NULL or other silent errors occured.</p>

<p>Secondly the <code>c != '\n'</code>. What if one of these characters occurs? In this case you won't continue with the next iteration but break out of the entire forloop. Remove it there and put it in the first line of the body like this:</p>

<pre><code>if(c == '\n') 
{
    i -= 1; // to really skip the character and maintain the index. 
    continue;
}
</code></pre>

<p>3) <code>s[i] = c;</code></p>

<p>Can you be certain, that the array is indeed sizeof <code>limit</code>?</p>

<p>4) Checking for curly braces</p>

<pre><code>if(s[i] == '{')
{
    braces[0] = s[i]; 
    //push(s[i], braces); 
    ++push_count; 
}
else if(s[i] == '}')
{
   pop(braces);
   ++pop_count; 
}
</code></pre>

<p>You assign to <code>braces[0]</code> always, why? </p>

<p>5) Uninitialized access</p>

<pre><code>if(c == '\n')
{  
    s[i] = c;
    i++; 
}
s[i] = '\0';
i = i -1;  //Suuld zalgasan 0 -g toonoos hasna
</code></pre>

<p>You're now using the function-global variable <code>i</code>, which is never initialized properly for this block. What you do is to use a variable that is used basically everywhere ( which is basically also no problem from the memory point of view. ), but you rely on legacy values. Is this done by purpose? If no, reinitialize <code>i</code> properly. I have to ask this since i can't read your comments in code.</p>

<p>What I'm quite unhappy about is that you entirely rely on one variable in all the loops and statements. Usually a loop-index should never be altered from inside. Maybe you can come up with a cleaner design of the function like an additional index variable you parallelly increase without altering <code>i</code>. The additional index will be used for array access where appropriate whereas <code>i</code> really remains just a counter.</p>
",0
24359425,24358849,0,"<p>For the task of counting whether there are balanced braces in the data, the code is excessively complex.  You could simply use:</p>

<pre><code>int l_brace = 0;
int r_brace = 0;
int c;
while ((c = getchar()) != EOF)
{
    if (c == '{')
        l_brace++;
    else if (c == '}')
        r_brace++;
}

if (l_brace != r_brace)
    printf(""Number of { = %d; number of } = %d\n"", l_brace, r_brace);
</code></pre>

<p>Of course, this can be confused by code such as:</p>

<pre><code>/* This is a comment with an { in it */
char string[] = ""{{{"";
char  c = '{';
</code></pre>

<p>There are no braces that mark control-of-flow statement grouping in that fragment, for all there are 5 left braces (<code>{</code>) in the source code.  Parsing C properly is hard work.</p>
",1
22437636,22437597,1,"<p>Ahh, MSDN functions... well, <a href=""http://msdn.microsoft.com/en-us/library/0we9x30h.aspx"" rel=""nofollow"">_itoa_s()</a> takes 4 arguments, and you only gave it three, hence the error saying it doesn't take 3 arguments.</p>

<pre><code>errno_t _itoa_s(
   int value,
   char *buffer,
   size_t sizeInCharacters,
   int radix 
);
</code></pre>

<p>""No instance of overload function"" is telling you that there isn't more than 1 <code>_itoa_s()</code> function that takes less arguments. Looks like you're missing the <code>radix</code> or <code>sizeInCharacters</code>:</p>

<blockquote>
  <p>[in] sizeInCharacters<br>
  Size of the buffer in single-byte characters or wide characters.<br>
  [in] radix<br>
  Base of value; which must be in the range 2¨C36.</p>
</blockquote>
",2
33588931,33588900,2,"<p>To accommodate exactly what you are trying to do, <code>realloc(NULL, size)</code> does the same thing as <code>malloc(size)</code>.  You can write your loop like this:</p>

<pre><code>int *h = 0;
size_t avail = 0;

for (size_t i = 0; more_data_available(); i++) {
    if ((i+1) * sizeof(int) &gt; avail) {
        avail = avail == 0 ? 8*sizeof(int) : avail*2;
        int *nh = realloc(h, avail);
        if (!nh) abort();
        h = nh;
   }
   h[i] = next_data_item();
}
</code></pre>

<p>But note the convoluted <code>?:</code> expression I had to use to enlarge <code>avail</code>.  That would be cleaner if I start the loop with some space already allocated; and then I can just use <code>malloc</code> normally:</p>

<pre><code>size_t avail = 8 * sizeof(int);
int *h = malloc(avail);
if (!h) abort();

for (size_t i = 0; more_data_available(); i++) {
    if ((i+1) * sizeof(int) &gt; avail) {
        avail *= 2;
        int *nh = realloc(h, avail);
        if (!nh) abort();
        h = nh;
    }
    h[i] = next_data_item();
}
</code></pre>
",3
23079728,23079443,4,"<p>I suspect that you are looking for <a href=""http://en.wikipedia.org/wiki/Exponentiation_by_squaring"" rel=""nofollow"">exponentiation by squaring</a> which goes like this:</p>

<pre><code>unsigned int intpow(unsigned int base, unsigned int exponent)
{
    unsigned int result = 1;
    while (exponent &gt; 0)
    {
        while ((exponent &amp; 1) == 0)
        {
            exponent /= 2;
            base *= base;
        }
        exponent--;
        result *= base;
    }
    return result;
}
</code></pre>
",1
23079759,23079443,1,"<p>To make the code work for other powers make these changes, multiply by to get the extra power.</p>

<pre><code>int main()
{
int i;
long int x=2;
int n=7;
int k=log(n)/log(2);
int y,z;
y=n-pow(2,k);
z=1;
for(i=0;i&lt;y;i++)
{
    z*=x;
}
for(i=1;i&lt;=k;i++)
{
 x=x*x;
 }
 x=x*z;
printf(""%d"",x);
printf(""\n%d"",k);
}
</code></pre>
",2
32388995,32388979,3,"<p>You have duplicate type specifiers in both your functions:</p>

<pre><code>unsigned uint16_t Reade2PW(unsigned uint16_t rde2pw) //Error here
^^duplicate types here      ^^ and here
</code></pre>

<p>Remove one. The <code>uint16_t</code> is already unsigned (so the <code>u</code> prefix). So just remove the <code>unsigned</code> from them:</p>

<pre><code>uint16_t Reade2PW(uint16_t rde2pw)
        {   
            uint16_t EEPVal;
          // ....
        }
</code></pre>
",0
21600779,21600719,5,"<p>You need to include your header file in <code>p750_eightqueens.c</code>, too.
Your <code>.c</code> files are compiled independently of each other, so your <code>p750_eightqueens.c</code> doesn't know about your defines and function declarations.</p>

<p>If you compile a C-program each compilation unit (<code>.c</code>-file) is compiled on it's own and needs all includes and declarations that are used in that file. After that you have object files (<code>.o</code>) which are then combined to a single executable by the linker. The linker searchs for the implementations of the used functions and puts it together so that different compilation units can call functions in others.</p>
",2
24078232,24078152,5,"<pre><code>char *s;
</code></pre>

<p><code>s</code> needs memory to be allocated either <em>statically</em> or <em>dynamically</em></p>

<pre><code>char s[100];
</code></pre>

<p>or</p>

<pre><code>char *s = NULL;
s = malloc(100);
if (s)
    /* do operations with s */
.
.
if (s)
    free(s);
</code></pre>
",1
24078257,24078152,0,"<p>I do not see any problem in assigning <code>dummy</code> variable but have issues in allocation of variable <code>s</code></p>

<pre><code>s = malloc (256);

...
...

if(s)
free(s)
</code></pre>
",0
26250735,26250633,2,"<p>If an integer is 4 bytes, there are 4 char's in it. Try to understand the output of this code: </p>

<pre><code>int main() {
    int a =330, i;
    char *p; 

    printf(""%08x\n"", a); 
    p=(char *)&amp;a;
    for (i = 0; i &lt; sizeof(int); i++) {
        printf(""%02x "", p[i]);
    }   
    printf(""\n"");
    for (i = 0; i &lt; sizeof(int); i++) {
        printf(""%02d "", p[i]);
    }   
    printf(""\n"");
    return 0;
}
</code></pre>

<p><em>prints:</em></p>

<pre><code>0000014a
4a 01 00 00 
74 01 00 00 
</code></pre>
",1
26250762,26250633,0,"<p>Here you are using a character pointer to point to a integer variable.
Since character is just a single byte you are getting 74 .
If you had used a integer pointer then you would have got 330.</p>

<pre><code>330 in binary is : 0000 0001 0100 1010
</code></pre>

<p>The value you are seeing here is </p>

<pre><code>74 : 0100 1010(1byte)
</code></pre>
",0
22119144,22118412,0,"<p>Try my code. Explanation is in the code:</p>

<pre><code>void event_remove_first (event_t ** list)
{
    event_t *aux = *list;

    if (*list == NULL)
    {
        printf (""List is already empty\n"");
        return;
    }

    // there is only one object which will be deleted
    if(*list-&gt;prox == NULL)
    {
        printf (""List got empty\n"");
        free (*list);
        *list = NULL;
        return;
    }

    *list = aux-&gt;prox;
    free (aux);
}
</code></pre>
",1
22508188,22508151,3,"<p><code>\%</code> is not a valid escape sequence. Your compiler should raise a warning like  </p>

<pre><code>[Warning] unknown escape sequence: '\%' [enabled by default]  
</code></pre>

<p>You need <code>%%</code> to print <code>%</code> otherwise it may or may not be printed.</p>
",2
22508409,22508151,3,"<p>There are two levels of processing here:</p>

<ol>
<li><p>The parsing of string literals. This is where the <code>\</code> becomes effective. <code>\n</code> is replaced by the newline character, and other escaping happens as well.</p></li>
<li><p>The <code>printf()</code> mechanism. This one only deals with the <code>%</code> as special character, and parses whatever comes after it in order to format one of its arguments.</p></li>
</ol>

<p>With <code>\%</code> you intermix these two, whatever happens on the <code>\</code> (if the <code>%</code> is suppressed or not), (2) won't notice the <code>\</code> as it is ""eaten up"" by (1).</p>
",0
23303252,23297037,1,"<p>simple line by line sample</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

char *esc_cnv(char *str){
    char *in, *out;
    out = in = str;
    while(*in){
        if(*in == '\\' &amp;&amp; in[1] == 'n'){
            *out++ = '\n';
            in += 2;
        } else 
            *out++ = *in++;
    }
    *out = '\0';
    return str;
}

int main(void){
    FILE *fin = stdin, *fout = stdout;
    char line[1024];
    char del_str[1024];
    char *p, *s;
    int len;
    int find=0;//this flag indicating whether or not there is a string that you specify 

    fin = fopen(""input.txt"", ""r"");
    fout = fopen(""output.txt"", ""w"");//temp file -&gt;(delete input file) -&gt; rename temp file.
    printf(""input delete string :"");
    scanf(""%1023[^\n]"", del_str);
    esc_cnv(del_str);//""\\n"" -&gt; ""\n""
    len = strlen(del_str);
    while(fgets(line, sizeof(line), fin)){
        s = line;
        while(p = strstr(s, del_str)){
            find = 1;//find it!
            *p = '\0';
            fprintf(fout, ""%s"", s);
            s += len;
        }
        fprintf(fout, ""%s"", s);
    }
    fclose(fout);
    fclose(fin);
    if(find==0)
        fprintf(stderr, ""%s is not in the file\n"", del_str); 
    return 0;
}
</code></pre>
",6
29224521,29224371,1,"<p>This replaces every <code>' '</code> with <code>'\t'</code>:</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    char text[1000];

    fputs(""enter some text: "", stdout);
    fflush(stdout);

    if (fgets(text, sizeof(text), stdin) != NULL)
    {
        int i = 0;
        while (text[i])
        {
            if (text[i] == ' ')
                text[i] = '\t';
            i++;
        }
    }
    printf(""%s"", text);

    return 0;
}
</code></pre>
",0
26422377,26422346,4,"<p>You need to declare <code>main</code> as <code>int main</code>:</p>

<pre><code>int main (int argc, char *argv[]) {
    // ...
    return 0;
}
</code></pre>
",4
26422415,26422346,3,"<p>After you've fixed the indentation and the glaring imbalance of braces, you'll get to the heart of the matter. Statements like</p>

<p><code>input1.dollars = input1.dollars + (input1.quarters/25) + (input1.dimes/10);</code></p>

<p>will be performed in <em>integer arithmetic</em> as the operands are all integral types. You'll get a lot of truncation of data. (24 quarters will evaluate to zero dollars the way you've written it).</p>

<p>To remedy, replace 25 with 25.0. etc. That forces the division to be carried out in floating point.</p>

<p>And fix your prototype for <code>main</code>: should be <code>int main()</code>. Formally the program behaviour is <em>undefined</em> if you use <code>void main()</code>.</p>
",5
26425369,26422346,0,"<p>This is not an answer (feel free to down-vote it as such)</p>

<p>You should do your addition first:</p>

<pre><code>total.dimes = input1.dimes + input2.dimes;
total.quarters = input1.quarters + input2.quarters;
total.dollars = input1.dollars + input2.dollars;
</code></pre>

<p>Then the propagate the summing up:</p>

<pre><code>// NOTE: Assumes the user enter the number of quarters, not the value in quarters!
total.dollars += total.quarters / 4;
// NOTE: Assumes the user enter the number of dimes, not the value in dimes!
total.dollars += total.dimes / 10;
</code></pre>

<p>Finish by adjusting the remainders:</p>

<pre><code>// NOTE: Assumes the user enter the number of quarters, not the value in quarters!
total.quarters = total.quarters % 4;
// NOTE: Assumes the user enter the number of dimes, not the value in dimes!
total.dimes = total.dimes % 10;
</code></pre>

<p>The % operator gives the remainder of the division.</p>
",0
22851665,22851335,0,"<p>Unless I am missing something the solution seems very simple to me.</p>

<p>One way to deal with cards that are not in the deck is to set the value for that card in <code>deck</code> to an out of range value.</p>

<p>The valid ranges for the values of items in <code>deck</code> are 0-51. As an example, define</p>

<pre><code>// You can use any number that is not in the range 0-51
const char INVALID_CARD = -1;
</code></pre>

<p>When you remove a card from <code>deck</code>, assign the value of that card in the deck to be <code>INVALID_CARD</code>. When checking for existing cards deck, make sure you ignore the items whose value is <code>INVALID_CARD</code>.</p>
",0
22852338,22851335,0,"<p>Rather then view the deck of cards as <code>char deck[SIZE]</code>, re-define the deck of cards as </p>

<pre><code>char deck[SIZE];
int deck_count;
</code></pre>

<p>Or as a structure:</p>

<pre><code>typedef struct {
  char deck[SIZE];
  int n;
} stock;
</code></pre>

<p>Then create functions to manipulate the stock:</p>

<pre><code>void stock_newdeck(stock *st);  // fresh deck of 52 cards: ordered
void stock_shuffle(stock *st);  // shuffle the n cards
int  stock_isempty(stock *st);  // any cards left?
char stock_draw(stock *st);     // draw the top card
</code></pre>
",0
26799134,26798900,1,"<p>It is more or less equivalent to this:</p>

<pre><code>long r = 0;
for(size_t i=0; i&lt;strlen(s); i++) // Traverse the string
{
    r = r&lt;&lt;1; // Shift the long representation
    if( s[i] != '0' )  // Is current char 0 or 1
    {
        r = r | 1; // It is 1: append it to long representation
    }
}
</code></pre>
",0
26799211,26798900,1,"<pre><code>for(;*s; r=(r&lt;&lt;1)|(*s++ - '0'));//explain this 
</code></pre>

<p>is: </p>

<pre><code>int r=0;
while(*s){
  int m=*s-'0';
  r=r*2 + m;    
  ++s;
}
</code></pre>

<p>As commented above It will parse(convert) your binary string to number</p>
",0
26799276,26798900,0,"<p>The structure of a for loop is the following:</p>

<ul>
<li>Before the first semi-colon you define and/or initialize any values related to the loop</li>
<li>between the two semi-colons lies the logic that is checked at the start of each loop, if it is true the    loop goes on</li>
<li>The code after the second semi-colon executes after the loop body is finished</li>
</ul>

<p>So in your <code>for</code> loop there is nothing before the first semi-colon, nothing needs to be initialized, that's normal.</p>

<p>The <code>*s</code> will be true (different than 0) for as long as the ASCII value stored there is different than <code>'0'</code>, that it the string termination character. So it's the same as saying <code>strlen(s)!=0</code></p>

<p><code>r=(r&lt;&lt;1)</code> performs a bitwise operation on <code>r</code>.</p>

<p><code>*s++ - '0'</code> subtracts the character <code>'0'</code> from the character pointed to by <code>s</code> and then increments the pointer to point to the next character</p>
",0
26801634,26798900,0,"<p>This for loop will run number of times, the characters inputed in fun() function parameters, e.g. here 9.</p>

<p>The value of r will be decided by the bitwise operation (r&lt;&lt;1),  subtraction (*s++ - '0') and the orring operation | of these two previous operations.</p>

<p>for first five iterations, value of the r will be 0, as leftshift operation on 0 will yeild 0 and ASCII value subtraction of the characters will also come as 0.</p>

<p>for 6th iteration, subtraction will bear value 1, and subsequently r will have 1.
for 7th iteration, leftshift operation (multiplication by 2) will have output 2, so r=2.
for 8th, leftshift operation will have output 4 and subtraction 1, so orring of (1 | 4) will have 5.</p>

<p>and for last iteration, leftshift operation will yeild o/p 10.
So finally You should get 10 as o/p.</p>
",0
27555581,27555432,1,"<p>You're reading integer values into the <code>blendingArray</code> pointer, repeatedly. Apart from failing if you try to input fractional parts, this leaves the pointer in a useless state (pointing to <code>0x00000006</code>, for example, if you'd entered ""6"" as the last element).</p>

<p>You want to be reading float values into the <em>elements</em> of the <code>blendingArray</code>:</p>

<pre><code>scanf(""%f"", &amp;blendingArray[a]);
</code></pre>
",0
27551301,27551256,3,"<p>You have to learn what the <a href=""https://gcc.gnu.org/onlinedocs/cpp/"" rel=""nofollow"">Preprocessor</a> is. As for your problem, the right solution is</p>

<pre><code>typedef char *string;
</code></pre>

<p>and if you want to use the preprocessor remove the semi colon and the <code>s</code> like this</p>

<pre><code>#define string char *
</code></pre>

<p>In the second case the preprocessor will replace each occurence of <code>string</code> with <code>char *</code>, and hence if you declare</p>

<pre><code>string x, y;
</code></pre>

<p>it will expand to</p>

<pre><code>char *x, y;
</code></pre>

<p>where <code>x</code> if a pointer to <code>char</code> and <code>y</code> is simply a <code>char</code>, this is misleading and should be avoided.</p>

<p>One more thing, when working in C it is never a good Idea to hide the fact that some variable is a pointer, so things like</p>

<pre><code>typedef SomeType *SomeTypeName;
</code></pre>

<p>where <code>SomeType</code> could be any type, are generally a bad idea, you can do something I've seen that clarifies this a little, you can append a <code>P</code> to <code>SomeType</code>, like this</p>

<pre><code>typedef SomeType *SomeTypeP;
</code></pre>

<p>but I personally prefer the <code>*</code> to any of these <code>typedef</code>s</p>
",4
27551473,27551256,-1,"<p>Don't. <code>string</code> is a C++ keyword. Not only it will cause problems if C++ becomes involved, but more importantly, it causes confusion and hides the fact that you are dealing with a pointer.</p>

<p>UPDATE: Right guys, it's not a keyword. But if like many people you put <code>using namespace std;</code> in your code, then <code>string</code> is a C++ class from the standard library.</p>

<p>What I wanted to say is that it is not a common practice to make an alias for <code>char *</code> and it might confuse other people looking at your code.</p>
",5
27551702,27551256,7,"<p>You <em>can't</em> make variables of type string in C, because ""string"" is not a type.</p>

<p>A ""string"" is, by definition, ""a contiguous sequence of characters terminated by and including the first null character"". It's not a data type, it's a data format.</p>

<p>An array of <code>char</code> may <em>contain</em> a string. A <code>char*</code> may <em>point to</em> a string. Neither of them <em>is</em> a string.</p>

<p>If you like, you can define</p>

<pre><code>typedef char *string; /* not recommended */
</code></pre>

<p>but that's misleading, since a variable of type <code>char*</code>, as I mentioned, isn't a string.</p>

<p>The best practice is simply to use <code>char*</code> directly. This makes it clear that your variable is a pointer. It's also consistent with the way the standard library is defined; for example, the <code>strlen</code> function is declared as:</p>

<pre><code>size_t strlen(const char *s);
</code></pre>

<p>It's also consistent with the way most experienced C programmers write code that deals with strings.</p>

<p>Because of the way C treats arrays (more or less as second-class citizens), arrays, including arrays that contain strings, are usually manipulated via pointers to their elements. We can use pointer arithmetic to traverse an array. Pretending that the pointer <em>is</em> the array, or that it <em>is</em> a string, is tempting, and might seem to make the code more understandable, but in the long run it just causes confusion.</p>

<p>A macro approach like</p>

<pre><code>#define string char*
</code></pre>

<p>is even worse than a <code>typedef</code>. Macros are expanded as sequences of tokens; the processor doesn't know about the syntax of C declarations. So given the above definition, this:</p>

<pre><code>string x, y;
</code></pre>

<p>expands to</p>

<pre><code>char* x, y;
</code></pre>

<p>which defines <code>x</code> as a <code>char*</code> and <code>y</code> as a <code>char</code>. If you need a name for a type, <code>typedef</code> is almost always better than <code>#define</code>.</p>
",6
21045972,21045928,1,"<p>This isn't valid C, even though the <code>int</code> is const and static.
I would recommend doing something like</p>

<pre><code>#define LOG_MAX 31
static int log_table[LOG_MAX];
</code></pre>
",3
21045993,21045928,3,"<p><code>const</code> does not mean constant in C but rather read-only. <code>LOG_MAX</code> is not a constant in your program.</p>

<p>Here are two ways to have a constant:</p>

<pre><code>#define LOG_MAX 31
</code></pre>

<p>or </p>

<pre><code>enum {
    LOG_MAX = 31
};
</code></pre>
",0
21046002,21045928,0,"<p>You should use the preprocessor :</p>

<pre><code>#define LOG_MAX 31
static int log_table[LOG_MAX];
</code></pre>
",0
21046075,21045928,4,"<p>In older C and C++ standards, the array bounds of an array had to be a constant literal evaluated at compile time. A <code>const</code> variable isn't necessary evaluated at compile time, it could be created in runtime as a local variable. Also, as pointed out in another answer, <code>const</code> should actually be regarded read-only rather than anything else.</p>

<p>In all C and C++ standards, <code>static</code> arrays must always have their size set using a constant literal. (Or to be picky, this applies to any variable with <em>static storage duration</em>)</p>

<p>In newer C standards (C99, C11) however, the code you posted is perfectly fine if you leave out the <code>static</code> keyword. It will then create a variable-length array (VLA), which may or may not be what you wanted to do.</p>

<p>I'm not sure about the latest C++11 standard, but as far as I know it does not support VLAs.</p>
",0
21046217,21045928,1,"<p>This fails since a <code>const int</code> variable is not considered a compile-time constant in C.</p>

<p>But since the array is going to be static, you can be sure that the ""full"" declaration is always available, i.e. it's never going to be referenced through a pointer. Thus, you can inline the size and use <code>sizeof</code> in all places where you wanted to use <code>LOG_MAX</code>:</p>

<pre><code>static int log_table[32];
</code></pre>

<p>and then elsewhere in the same function:</p>

<pre><code>const size_t log_max = sizeof log_table / sizeof *log_table;
</code></pre>

<p>This keeps the ""magic constant"" around, but only in one place and its purpose should be pretty clear given the way the <code>log_table</code> is used. This is all inside a single function, after all, it's not scary global data.</p>
",0
23115512,23115462,9,"<p>It's a generic term that normally refers to some particular syntax included in the language to perform some task (like a loop with the condition at the end). It has no relation at all with constructors.<sup>1</sup></p>

<hr>

<ol>
<li>Well, besides the fact that constructors are a particular language construct in many OO languages.  </li>
</ol>
",2
23115521,23115462,11,"<p>In this case you can replace the word <em>construct</em> with <em>syntax</em>.  </p>

<blockquote>
  <p>does the word 'construct' have an relation to an object 'constructor' in other languages?  </p>
</blockquote>

<p>No. These two terms are different.  There is nothing like constructor in C</p>
",1
23115614,23115462,6,"<blockquote>
  <p>does the word 'construct' have an relation to an object 'constructor' in other languages?</p>
</blockquote>

<p>The sentence uses the noun, not a verb, meaning of the word ""construct"":</p>

<blockquote>
  <p><em>construct (n)</em> - something (such as an idea or a theory) that is formed in people's minds.</p>
</blockquote>

<p>In this case, ""construct"" refers to an abstract way of describing something (namely, a loop) in terms of the syntax of that particular language. ""Language construct"" means ""a way to do [something] with that language"".</p>
",1
21306675,21306642,0,"<p><code>0x1111</code> is greater than the maximum value a character (of type <code>char</code> ... ie: <code>uint8_t</code>) can take... so possibly you need an array with two, like: <code>char b[2] = { 0x11, 0x11 };</code></p>
",0
21306713,21306642,1,"<p>First of all: <code>char b[1]</code> is not large enough to hold two bytes of a <code>uint16_t a[1]</code>.</p>

<p>If you want to allocate a copy then memcpy is a way:</p>

<pre><code>char b[sizeof(a)];
memcpy(b, a, sizeof(a));
</code></pre>

<p>If you want to alias it as a char type you could just cast the pointer:</p>

<pre><code>char * b = (char *)a;
</code></pre>
",1
23582692,23582451,1,"<pre><code>xy *p=NULL;
// ...
p = realloc(p, newsize);
</code></pre>

<p><code>realloc(NULL, size)</code> have same effect as <code>malloc</code>. You wanted first line to be <code>xy *p=*ptr;</code>, then actual reallocation would happen.</p>
",0
29191577,29191529,1,"<p>When you use <code>gcc</code>, the line</p>

<pre><code>void errExit(const char *format, ...) NORETURN;
</code></pre>

<p>is translated to </p>

<pre><code>void errExit(const char *format, ...) __attribute__ ((__noreturn__));
</code></pre>

<p>by the preprocessor. What does the <code>__noreturn__</code> attribute to do?</p>

<blockquote>
  <p>A few standard library functions, such as <code>abort</code> and <code>exit</code>, cannot return. GCC knows this automatically. Some programs define their own functions that never return. You can declare them noreturn to tell the compiler this fact.</p>
</blockquote>

<p>You read more about <code>__noreturn__</code> and other function attributes supported by <code>gcc</code> at <a href=""http://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Function-Attributes.html"" rel=""nofollow"">http://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Function-Attributes.html</a>.</p>

<p>When use a different compiler, the same line is translated to:</p>

<pre><code>void errExit(const char *format, ...);
</code></pre>
",0
23814339,20068781,4,"<p>Ok, I am not sure if I understood completely, but here it goes...</p>

<p>Q1: Why does it use symbols in the global offset table (GOT)?</p>

<p>GOT is used because by the way compiler, linker and loader works, it is impossible to tell where each object will end up in memory at runtime. The compiler proper step sees one module at a time, so it cannot tell from where each (external) function and global var will be referred. Instead, for each one it creates a symbol to be resolved at link time. For static functions/variables, it generates code that access those directly (it is platform dependent: in Linux/x86_64 is uses an offset from the program counter). For externals, it generates indirect access code through a runtime data structure: GOT.</p>

<p>At link time, you can tell which modules call what symbols, so it is the linker job to make sure that all symbols (either those in your program or in its external dependencies) are resolved, meaning they are defined elsewhere in the multiple modules that compose your program. For objects defined in your own code (or linked statically) it is possible to tell its location inside your binary (ELF/COFF/PE/etc), but you do not know where are they going to be in memory until load time. Linker also writes into the binary what are the required shared libraries and (optionally) their likely location at runtime.</p>

<p>When you run your program, <a href=""http://en.wikipedia.org/wiki/Dynamic_loading"" rel=""nofollow"">the loader</a>! will try to find all dependencies (shared libs), and then as part of process start up will build GOT structure. It will load your program code from binary's text section into memory and for each symbol it will create an entry in the GOT with the actual memory address where to find it. Then it will do the same for each shared library. It is also worth noting that some libraries may keep internal offset tables independent of GOT. This way you can have the same symbol defined multiple times. This is by example what happens with <a href=""http://en.wikipedia.org/wiki/Side-by-side_assembly"" rel=""nofollow"">Window SxS</a>! (Microsoft's answer to DLL hell problem).</p>

<p>From the point of view of your program, each access to external symbol requires 2 memory accesses (indirect). If the symbol represents a function, there is another structure PLT, that is a jump table with GOTO instructions to each place.</p>

<p>Q2: Is there anyway to avoid using global offset table? Any help out there?</p>

<p>Yes, the easiest way is to figure out what functions/globals you do not need access outside the module they are defined and declare those as static. In this way, compiler will know that it can generate direct access code to find them (offset from program counter is the way it is done in Linux/x86_64, but it is platform dependent). </p>

<p>I have read that in large projects there is a specialized build teams that identify tightly coupled sets of modules and integrate them in a single big C file in order to minimize the number of exposed symbols into the general product, but I have never seen it first hand.</p>

<p>There are also linker options that help you avoid exposing symbols, but for what I know they are just syntactic sugar. The GOT and PLT is still being used, just you make its contents opaque.</p>

<p>A great resource for this subject is Ulrich Drepper's <a href=""http://www.akkadia.org/drepper/dsohowto.pdf"" rel=""nofollow"">How to Write Shared Libraries</a>!</p>
",2
21037900,21037815,4,"<pre><code>printf('1.cake\n2.cake\n......');
</code></pre>

<p>this will be the solution in no <code>loops</code> are allowed and a single <code>printf</code> statement should do.</p>
",1
21038097,21037815,1,"<p>Does the stipulation ""only one printf statement"" only constrain number of printf, or does it mean that is the only statement you can use? Assuming the former:</p>

<pre><code>void print(int num)
{
    printf(""%d. Cake\n"", num);
    if (num == 15)
        return;
    else
        print(num+1);
}

int main()
{
    print(1);
}
</code></pre>
",0
22424484,22423811,4,"<p>In the header, declare:</p>

<pre><code>extern td_sys_call_handler syscall_redirect;
</code></pre>

<p>and in the implementation (<code>syscall.c</code>), just define the structure as a normal global variable ¡ª but <em>don't</em> make it <code>static</code>.  (A <code>static</code> variable has internal linkage, so it can't be referred to by other modules, but the whole point of this structure is for other modules to use it.)</p>
",1
30699946,30699912,-1,"<pre><code>struct foo **m = malloc(n * sizeof *m);
</code></pre>

<p>This code creates a variable <code>m</code>, which is a pointer of pointer to <code>struct foo</code>. So if you dereference it twice, you now just have a <code>struct foo</code>. Looks like you want a pointer to pointer to pointer of <code>struct foo</code>--in other words, <code>struct foo ***m</code>.</p>
",6
30699975,30699912,1,"<p>The best solution indeed is the second structure, although you can use a three star poitner <code>struct foo ***</code>, it's normally not a good solution, since you can always have <code>struct</code>s to give more <em>structure</em> to your data, and make your code less error prone.</p>
",0
21329589,21329485,8,"<p><code>&lt;conio.h&gt;</code> is non-standard and non-portable. Use a cross-platform library such as <a href=""https://www.gnu.org/software/ncurses/ncurses.html"" rel=""nofollow"">ncurses</a> if you need functionality not provided by the standard C libraries.</p>
",4
21182902,21182833,10,"<p>The actions of the program depend on how your implementation defines <code>char</code>: <a href=""http://web.archive.org/web/20050207010641/http://dev.unicals.com/papers/c99-draft.html#6.2.5"" rel=""nofollow noreferrer"">it may be a signed or an unsigned type</a>.</p>

<p>If it is unsigned, it outputs 10 numbers and terminates.</p>

<p>If it is signed, it will wrap at 127 and the next value is -128 - in most implementations. But according to the standard, it is undefined behaviour.</p>

<p>I don't see why it should eat up the complete stack - there is no recursion and no additional memory allocation, so that</p>

<blockquote>
  <p>told by a very experienced teacher that the following code will terminate when the <code>STACK memory</code> gets completely filled by the program</p>
</blockquote>

<p>means ""never"" - because it just doesn't fill up the stack. It cannot have been such an experienced programmer/teacher ¨C or the OP is not an experienced listener and has misunderstood something the teacher has told him.</p>
",10
21182986,21182833,0,"<p>Yeah it will lead to infinite loop since <code>i</code> has been declared as <code>char</code> which ranges from <strong>-128 to +127</strong> so it never reached 130</p>

<p>the time <code>i</code> reaches <strong>127</strong> it comes back to <strong>-128</strong> and never reaches <strong>130</strong></p>

<p><a href=""http://ideone.com/iVLoHe"" rel=""nofollow"">http://ideone.com/iVLoHe</a></p>
",0
21182994,21182833,3,"<p>the reason is simple as well as tricky :)</p>

<p><code>i</code> is not an <strong>int</strong>, but a <strong>char</strong>.
This means that its range goes from -128 to +127.</p>

<p>While the loop increses the index, it will overflow at +128, so that the value in memory will be -127 again. This means that <code>i</code> is again smaller than 130! The loop continues on and on...</p>

<p>Now continue cheating :P</p>
",5
21183007,21182833,0,"<p>char is 1byte long -2^8 to 2^8-1 (-128 to 127) if you try to add 1 to 127 it will be -128 an overflow occurs. 
printing the variable you will see the same .</p>

<p>change the declartion from 
         char i  to int i </p>

<p>it never fills the stack as you are not declaring new variables or calling functions to fill the stack. so it's an infinite loop only</p>
",0
21301748,21301691,3,"<p>you can open your file only with <code>fopen()</code> so remove the first open of file:</p>

<pre><code>int fd = open(""/home/pdave/hello2.c"", O_RDONLY);
</code></pre>

<p>And the file path in your <code>fopen()</code> function seems to be wrong:</p>

<pre><code>stream = fopen(""/home/pdave/hello2.c"",""r"");
</code></pre>
",3
21301833,21301691,1,"<p>Return value of <code>fopen</code> will be NULL when file path wrong.</p>

<p>Using NULL to <code>fgets</code> leads to <code>SO</code>.</p>

<p>Your file path looks like wrong, Usually there will not any path like <code>./home/path</code>.</p>

<p>compare the return value of <code>fopen</code> with <code>NULL</code>, after <code>fopen</code>. </p>

<p>Try with:</p>

<pre><code>stream = fopen(""/home/pdave/hello2.c"", ""r"");
if (stream == NULL) {
    printf(""Error opening file\n"");
    return -1;
}
</code></pre>

<p>Further <a href=""http://linux.die.net/man/3/fopen"" rel=""nofollow"">man fopen</a> and <a href=""http://linux.die.net/man/3/fgets"" rel=""nofollow"">man fgets</a></p>
",0
26228081,26228031,2,"<p>Your are using <code>fgetc</code>. It will do character reading. So you are facing cumbersome to meet your requirements. I request you to use <code>fscanf</code> and this is one of easy way too.</p>

<p><code>fscanf</code> will return EOF if it fails before matching any of the arguments</p>

<p>Example code</p>

<pre><code>int main ()
{
    FILE *fp = fopen (""/home/inputs.in"", ""r"");
    int d=0;

    while ( EOF != fscanf ( fp, ""%d "", &amp;d ))
    {
            printf (""%d "", d);
    }
    return 0;
}
</code></pre>
",1
26228101,26228031,3,"<p>here's how you can do it with <code>fgets</code></p>

<pre><code>char arr[PickYourSize];
char* ptr;
fgets(arr , sizeof arr , fp);
ptr = strtok(arr , "" "");
while(ptr)
{
       array[counter++] = strtol(ptr , NULL , 10);
       ++numberRead;
       ptr = strtok(NULL , "" "");
}
</code></pre>
",2
22882718,22882619,2,"<p>Even though the data is entered all in one line, you don't have to read it all at the same time:</p>

<pre><code>scanf(""%d"",&amp;length);
str = malloc(length+1);
scanf(""%s"",str);
</code></pre>

<p>Each time use use scanf, it just reads as much as it can, and leaves the rest in the input buffer.</p>
",4
22882787,22882619,1,"<p>simply sample. check omit.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(){
    int len;
    char *string;
    printf(""Enter an integer and string :"");
    scanf(""%d"", &amp;len);
    string = malloc(len+1);
    scanf(""%*[ \t\n]"");
    fgets(string, len+1, stdin);//scanf("" %[^\n]"", string);
    printf(""%s.\n"", string);
    free(string);
    return 0;
}
</code></pre>
",0
22882953,22882619,0,"<p>With POSIX 2008 or GNU <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/scanf.html"" rel=""nofollow""><code>scanf()</code></a> (but not on Mac OS X), you could do it all on one line with the <code>m</code> (memory allocation) modifier:</p>

<pre><code>char *str;
int   len;

if (scanf(""%d %ms"", &amp;len, &amp;str) != 2)
    ¡­Oops; something went wrong¡­
¡­use len and str¡­
free(str);
</code></pre>

<p>With this usage, the fact that the integer is the length of the string is immaterial; they're unrelated data items as far as <code>scanf()</code> is concerned.</p>
",0
31890366,31890304,1,"<p>Here's the problem: if the user types <code>A</code> and presses enter, then the first <code>scanf</code> fails because it sees the <code>A</code>, but the <code>A</code> remains in the input stream. So the second and third <code>scanf</code> will also see the <code>A</code> and fail immediately. </p>

<p>In general, if you need to enforce a line-oriented protocol, you should use <code>fgets</code> to read a line, and use <code>sscanf</code> and/or the <code>strto*</code> family of functions to do the conversions.</p>
",2
31890370,31890304,3,"<p>The problem is that if there is invalid input, the <code>scanf</code> function will <em>not</em> read the input, it will be left in the input buffer for the next input function, which in your case will fail with the same input.</p>

<p>I recommend you use e.g. <code>fgets</code> to read the whole line, and then use e.g. <code>sscanf</code> (or <a href=""http://en.cppreference.com/w/c/string/byte/strtol"" rel=""nofollow""><code>strtol</code></a>) to convert the string to a number.</p>
",3
31896367,31890304,0,"<p><code>scanf(""%d ...</code> <em>does</em> read the invalid character <code>'f'</code>, but seeing that it is not an expected part of a <code>int</code> (because of the <code>""%d""</code>), <em>ungets</em> the character, putting it back into <code>stdin</code> for subsequent reading/scanning.</p>

<p>So until something consumes the <code>'f'</code>, additional calls with <code>scanf(""%d%c"", ...</code> will not change the status of things.</p>

<p>Better to use <code>fgets()</code> (C standard) or <code>getline()</code> (common, but not standard) to read user input.</p>
",0
22468802,22468788,3,"<p>That's because you <em>didn't</em> declare start or stop. You have to declare variables before you can use them. They don't just show up out of thin air.</p>
",0
22469009,22468788,2,"<p>try this</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main(int argc, char* argv[])
{
    int start = atoi(argv[1]);
    int stop = atoi(argv[3]);
    for(start; start &lt; stop; start++)
    {
        printf(""hello"");
    }
}
</code></pre>
",1
22469097,22468788,2,"<p>The windows shell you're using is a basically DOS-ish thing. <code>./prog</code> doesn't work because the slash is not a directory separator. You have to use <code>.\prog</code>, or just <code>prog</code> because <code>.</code> is always implicitly in the <code>PATH</code>.</p>

<p>This is in addition to your lack of declaration of <code>start</code> and <code>stop</code> which is well covered by the other answers and comments.</p>
",0
22478498,22468788,1,"<p>Well, you are actually using <em>start</em> and <em>stop</em> variables without declaring them.</p>

<p>You are passing to the main two strings (<em>argv[1]</em> and <em>argv[2]</em>) that are supposed to be integers; as a consequence you need your <em>start</em> and <em>stop</em> variables to be integers as well.</p>

<p>Therefore you have two options (which are the same, just pick your favourite one):</p>

<pre><code>int start = atoi(argv[1]);
int stop = atoi(argv[2]);
</code></pre>

<p>or</p>

<pre><code>int start, stop;
start = atoi(argv[1]);
stop = atoi(argv[2]);
</code></pre>
",0
25476950,25476923,2,"<p>It sounds like you need to link lodepng.c with the example program, like this:</p>

<pre><code>$ gcc -o example_encode lodepng.c example_encode.c
</code></pre>
",2
21046939,21046897,4,"<p>Your code is not valid, you cannot use <code>strcpy()</code> when source and destination buffers overlap.</p>

<p>You must use <a href=""http://linux.die.net/man/3/memmove"" rel=""nofollow""><code>memmove()</code></a> for cases like those. Note that <code>memmove()</code> is not a string function so it doesn't use 0-termination, thus you need to pass the number of bytes to move.</p>

<p>Also, never use <code>gets()</code>, it's very dangerous (no protection against buffer overflow).</p>

<p>You should do something like:</p>

<pre><code>char a[128];

if(fgets(a, sizeof a, stdin))
{
    const size_t len = strlen(a);
    int n;

    printf(""enter index&gt; "");
    flush(stdout);
    if(scanf("" %d"", &amp;n) == 1 &amp;&amp; n &lt; len)
    {
        memmove(a + n, a + n + 1, len - n);
    }
}
</code></pre>

<p>The above uses 0-based indexing. If you want 1-based indexing, replace the inner-most <code>if</code>:</p>

<pre><code>if(scanf("" %d"", &amp;n) == 1 &amp;&amp; n &gt; 0 &amp;&amp; n &lt;= len)
{
    --n;
    memmove(a + n, a + n + 1, len - n));
}
</code></pre>
",5
30717153,30717094,13,"<p>The multiplication operator <code>*</code> applies the <em>usual arithmetic conversions</em> to its operands. These conversions convert the <code>unsigned</code> char operands to <code>int</code>. See <a href=""https://stackoverflow.com/a/30717197/827263"">pmg's answer</a> for the standard reference.</p>

<p>Apparently on your system type <code>int</code> is wide enough to hold the result value <code>65025</code>. On a system with 16-bit <code>int</code>, where <code>INT_MAX == 32767</code>, the multiplication would result in an overflow, causing undefined behavior (typically the high-order bits of the result would be discarded). Most modern systems have 32-bit <code>int</code>.</p>

<p>There is no multiplication operator for integer types narrower than <code>int</code> or <code>unsigned int</code>.</p>

<p>(Strictly speaking, it's possible that the operands could be converted to <code>unsigned int</code> rather than to <code>int</code>. That would happen only if <code>unsigned int</code> can represent the entire range of <code>unsigned char</code>, but <code>int</code> cannot -- and that cannot happen on a system with 8-bit <code>char</code>.)</p>
",0
30717197,30717094,6,"<p>The operands to <code>*</code> undergo the <a href=""http://port70.net/~nsz/c/c11/n1570.html#6.3.1.8"" rel=""nofollow"">""usual arithmetic conversions""</a> (C11 Standard p6.3.1.8).</p>

<p>Also see p6.5.5.2: <a href=""http://port70.net/~nsz/c/c11/n1570.html#6.5.5"" rel=""nofollow"">Multiplicative operators</a></p>

<blockquote>
  <p><strong>Semantics</strong><br>
  The usual arithmetic conversions are performed on the operands.</p>
</blockquote>
",1
25457252,25457213,0,"<p>The entries are being processed back to front.  I'm not 100% but I'd think that the order of processing of arguments to a printf() statement is not set so the result is not predictable (from compiler to compiler).</p>
",0
34247540,34247408,1,"<p>There is no need to use an array for the digits. You should get into the habit of splitting the code into small easy to understand functions too.</p>

<pre><code>#include &lt;stdio.h&gt;

// assume n &gt;= 0
int sum_of_digits (int n)
{
    int sum = 0;
    while (n &gt; 0) {
        sum += n % 10;
        n /= 10;
    }
    return sum;
}

// assume n &gt;= 0
int digital_root_sum (int n)
{
    // As long as n has more than one digit, we replace it
    // with the sum of its digits.
    while (n &gt;= 10) {
        n = sum_of_digits (n);
    }
    return n;
}

int main()
{
    int n;

    printf (""n   : "");
    scanf (""%d"", &amp;n);
    printf (""sum : %d\n"", digital_root_sum (n));
    return 0;
}
</code></pre>
",5
34248269,34247408,0,"<pre><code>#include &lt;stdio.h&gt;

int sumOfDigit(int n){
    if(10 &gt; n)
        return n;

    int r = n % 9;

    return r ? r : 9;
}

int main(void){
    int N, T[50];
    int i, sum = 0;

    printf(""D (max.50) : "");
    scanf(""%d"", &amp;N );
    for (i=0; i&lt;N; i++){
        printf(""E %d : "", i);
        scanf(""%1d"", &amp;T[i]);//scanf(""%d"", &amp;T[i]);
        sum += T[i];        //sum += sumOfDigit(T[i]);
    }
    printf(""T :\n"");
    for (i=0; i&lt;N; i++)
        printf(""%d"", T[i]);
    printf(""\n"");

    printf(""Sum : %d\n"", sumOfDigit(sum));

    return 0;
}
</code></pre>
",1
34253820,34247408,0,"<p>Thank you everyone for your warm response, that's very kind of you. I'll try your answers and I put you posted.
I apologize for my English and thank you again</p>
",0
22422175,22422128,1,"<p>If you wanted to initialize all ints to zero, you should write:</p>

<pre><code>int counter1=0, counter2=0, ...
</code></pre>

<p>Now only <code>nine</code> is init by 0, other variables contain rubbish - arbitrary values.</p>
",0
22422230,22422128,1,"<p>Initialize all variables:</p>

<pre><code>int counter1=0, counter2=0, ones=0, tens=0, zero=0, one=0..
</code></pre>

<p>BTW, for better performance,
replace <code>if</code> with <code>else if</code> except the first one in the block. Why do you want to check all <code>if</code> conditions when you already know only one is true?</p>

<p>FYI, when a condition is true in <code>Else if</code>, all other <code>if</code>s are skipped.</p>
",0
22422257,22422128,1,"<p>in main() you have to initialize all variable with zero like</p>

<pre><code>  int counter1=0,counter2=0 and so on
</code></pre>

<p>otherwise it take garbage value and perform operation with those values and then output will be like</p>

<pre><code>********
*****************
*****************
*****************
*****************
*****************
*****************
*******
*******
</code></pre>
",0
26451983,26451916,0,"<p>This program basically extracts each bit of the number and puts it in a vector. So every bit becomes a vector element. It has nothing to do with two's complement conversion (although the resulting bit-vector will be in two's complement, as the internal representation of numbers is in two's complement).</p>

<ol>
<li><p>The computer has no idea what hex means. Every value is stored in binary, because binary is the only thing computer understands. So, ,the ""integer"" and the hex values are converted to binary (the hex there is also an integer). On these binary representations that the computer uses, the binary operators are applied.</p></li>
<li><p>In order to understand what is happening with the result when num is negative, you need to understand that the result is basically the two's complement representation of num and you need to know how the two's complement representation works. <a href=""http://en.wikipedia.org/wiki/Two&#39;s_complement"" rel=""nofollow"">Wikipedia</a> is a good starting point. </p></li>
</ol>
",1
26452095,26451916,0,"<p>To answer your questions</p>

<p>1.Yes num is integer represented in <code>decimal</code> format  and mask is also integer represented in <code>hex</code> format.
Yes C compiler treats <code>num</code> and <code>mask</code> with their binary equivalents.</p>

<p>Say  </p>

<pre><code>num = 24; // binary value on 32 bit machine is 000000000000000000011000
mask = 0x01; // binary value on 32 bit machine is 000000000000000000000001 
</code></pre>

<p>Yes compiler now performs <code>&amp;</code> bitwise and the equivalent binary values.</p>

<p>Yes if output is nonzero, treated as true</p>

<ol start=""2"">
<li>If a number is negative, its represented in 2's complement form.</li>
</ol>

<p>Basically your code is just storing binary equivalent of number into <code>array</code>. You are not representing in twos complement.  </p>

<p>If MSB is 1 indicates number is negative. if a number is negative </p>

<pre><code>num = -24; // represent binary value of 24 
000000000000000000011000 -&gt; apply 1's complement + 1 to this binary value

 111111111111111111100111 -&gt; 1's complement
+000000000000000000000001 -&gt; add 1
 ------------------------
 111111111111111111101000 -&gt; -24 representation
 ------------------------
</code></pre>
",0
21044989,21043841,0,"<p>From the stack trace, you've clearly overwritten something on the heap. What and where is unclear, though it doesn't immediately appear to be in your logging code as that doesn't access the heap. (Although it's quite difficult given your one-size-fits-all indenting).</p>

<p>as an aside, this:</p>

<pre><code>char path[1024];
char logpath[1024];
getcwd(path,1024);
sprintf(logpath,""%s/TEST_LOGS/%s_%d_%d.log"",path,logfile_name,app_inst_id,getpid());
</code></pre>

<p>could be coded rather more safely as:</p>

<pre><code>char path[1024];
char logpath[1024];
getcwd(path, sizeof(path));
snprintf(logpath, sizeof(logpath), ""%s/TEST_LOGS/%s_%d_%d.log"", path, logfile_name, app_inst_id, getpid());
</code></pre>

<p>in case your path is a little on the big size, and you <em>really</em> should test the return codes of getcwd and snprintf</p>
",0
22432941,22432910,19,"<p><code>&lt;sys/socket.h&gt;</code> is for UNIX/Linux.</p>

<p>For windows, you use <code>&lt;Winsock2.h&gt;</code>. You'll also need to link against <code>Ws2_32.lib</code> and call <code>WSAStartup</code> to use WinSock.</p>

<p>See also:</p>

<ul>
<li><a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/ms740506.aspx"" rel=""noreferrer""><code>socket</code> function</a> (MSDN)</li>
<li><a href=""https://stackoverflow.com/questions/6769981/windows-socket-programming-in-c"">Windows Socket Programming in C</a> (Stack Overflow)</li>
</ul>
",0
30695256,30690084,2,"<p>You can use <code>sscanf</code> and the <code>%n</code> specifier to advance through a string. The <code>%n</code> specifier will tell you how many characters are processed by the scan. That can be added to <code>offset</code> to move through the string. It can also be used to detect when an integer should be split into two integers.<br>
The scanset <code>%79[^0-9\n]</code> will scan up to 79 characters that are not a digit or newline.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    char input[80] = {""24a10b9100""};
    char nondigit[80] = {0};
    int digit = 0;
    int thousands = 0;
    int offset = 0;
    int used = 0;
    int length = 0;
    length = strlen ( input);
    while ( offset &lt; length) {
        if ( ( sscanf(input + offset, ""%79[^0-9\n]%n"", nondigit, &amp;used)) == 1) {//scan for non digit string
            offset += used;//add characters used by scan to offset
            printf ( ""not number %s\n"", nondigit);
        }
        if ( ( sscanf(input + offset, ""%d%n"", &amp;digit, &amp;used)) == 1) {
            offset += used;
            if ( used &gt; 3) {//scanned more than three digits, split the integer
                thousands = digit / 1000;
                digit %= 1000;
                printf ( ""thousands %d\n"", thousands);
                printf ( ""number %d\n"", digit);
            }
            else {
                printf ( ""number %d\n"", digit);
            }
        }
    }
    return 0;
}
</code></pre>
",1
22439029,22437595,1,"<p><code>printf()</code>, when STDOUT is a terminal, does line-buffering. As you have not added a linefeed after ""Hello"", it remains in the userspace buffer and <code>printf()</code> does not actually <code>write()</code> ""Hello"" to STDOUT.</p>

<p>Then you call <code>select()</code> which waits for user input. That achieved, your program exits, but flushes the STDOUT buffer first.</p>

<p>Try again with <code>""Hello\n""</code>.</p>
",1
22437637,22437613,0,"<p>If you want to use a defined struct in C, you have to put the keyword <code>struct</code> before it (e.g. in <code>main</code>, you need to do it in more places):</p>

<pre><code>int main() {
    struct dvdstruct dvds;    // add ""struct"" here
    initDvds(dvds);           // no need to provide type in function call
    system(""PAUSE"");    
    return 0;
}
</code></pre>

<p>As a shorthand, you can do a <code>typedef</code> to define it as a new type:</p>

<pre><code>typedef struct dvdstruct {
  // definition
} dvdstruct;
</code></pre>

<p>and then you can use it as you did.</p>

<p>About the storage size: when declaring an array in C, you have to supply a length or have it inherent in its declaration. Either <code>int i[4]</code> or <code>int i[] = { 1,2,3,4 };</code>.</p>

<p>About the incompatible types: C is a typed language. <code>char</code> is not the same type as <code>char[50]</code>. <code>char</code> is a single byte, <code>char[50]</code> is actually a pointer to a <code>char</code>.</p>
",2
22437642,22437613,0,"<p>And indeed it doesn't have a field named 'numdvds'. It does have, however, a field named 'numdv'.</p>
",0
22437671,22437613,0,"<p>In C language use <code>struct</code> keyword when declare variable <code>struct dvdstruct dvds;</code></p>

<p>Also you may use <code>typedef</code> whed declaring structure itself</p>

<pre><code>typedef struct dvdstruct{
    struct dvdtype *dvd; 
    int numdv;
} dvdstruct_t; //define datatype
</code></pre>

<p>or</p>

<pre><code>typedef struct {
    struct dvdtype *dvd; 
    int numdv;
} dvdstruct; 
</code></pre>
",0
22438672,22437613,0,"<p>I have modified your code and pointed out all the errors. Pl. see if this helps. I have also added a function to 
print the dvds.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;


struct dvdtype{
    int dvdcode;
    char title[50];
    int customerID;
    int daysowned;
};

struct dvdstruct{
    struct dvdtype *dvd;
    int numdv;
};

/*Changed the function prototype, since the argument needs to be updated
inside the function and C supports only Call By value*/
void initDvds(struct dvdstruct *dvds);

/*Added this function*/
void printDvds(struct dvdstruct *dvds);

int main() {
    struct dvdstruct dvds;
    /*You need to populate the above structure inside the function,
    so you need to pass the address of the structure as the argument */
    initDvds(&amp;dvds);
    system(""PAUSE"");
    printDvds(&amp;dvds);
    return 0;
}


void initDvds(struct dvdstruct *dvds)
{
    int i;

    /*You have made error here
    dvd[]= (int *)malloc(5);*/

    /*I am assuming you want to simulate an array of
    type struct dvdtype inside the struct dvdstruct*/
    dvds-&gt;dvd = malloc(5 * sizeof(struct dvdtype));
    dvds-&gt;numdv = 0;
    for(i=0; i&lt;5; i++)
    {

        (dvds-&gt;dvd[i]).dvdcode = -1;
        /*This is wrong since title is a character array
        dvds-&gt;(dvd[i].title)= '0';*/
        memset((dvds-&gt;dvd[i]).title, '\0', 50);
        (dvds-&gt;dvd[i]).customerID = -1;
        (dvds-&gt;dvd[i]).daysowned = -1;
        /*Will this be inside the loop like this? this I feel 
        will be used to check how many dvds you have have  dvds.numdvds=0;*/
       dvds-&gt;numdv++;
   }

}

void printDvds(struct dvdstruct *dvds)
{

    int no_of_dvds;
    int i;
    no_of_dvds = dvds-&gt;numdv;
    for (i = 0; i &lt; no_of_dvds; i++)
    {

        printf(""Dvd Code = %d "",(dvds-&gt;dvd[i]).dvdcode);
        printf(""Dvd Title  = %s "",(dvds-&gt;dvd[i]).title);
        printf(""Customer Id   = %d "",(dvds-&gt;dvd[i]).customerID );
        printf(""Days Owned  = %d\n"",(dvds-&gt;dvd[i]).daysowned );
        printf(""#####################################\n"");


    }

}
</code></pre>
",0
21165642,21165437,0,"<p>I'd recommend looking into Clang. It has has an excellent C parser, and a library, cindex, for traversing though the AST. See <a href=""http://clang.llvm.org/get_started.html"" rel=""nofollow"">http://clang.llvm.org/get_started.html</a> for getting started and CINDEX.html"">http://clang.llvm.org/doxygen/group_CINDEX.html for the API documentation.</p>
",4
27561060,27561031,7,"<p>Yes, it's fine, the specific case you posted is good except that you don't check the return value, so you won't know if the string was truncated.</p>
",3
27561099,27561031,2,"<p>Yes you can use. But if the string is higher than the sizeof value then the string is truncated. or up to the given value is stored in that array.</p>
",0
27561124,27561031,4,"<p>You can use the <code>sizeof</code> operator in the <code>snprintf</code>, but if the length of the string is bigger than the size which you have specified, then the remaining characters in the string will be lost.</p>
",0
27561436,27561031,5,"<p>It is fine in example you posted.</p>

<p>However, it's not fine in any case where array decays in to pointer:</p>

<pre><code>void func(char s []) {
    snprintf(s,sizeof(s),""%s"",""somestring......""); // Not fine, s is actually pointer
}
int main(void) {
    char cstring[20];
    func(cstring); // Array decays to pointer
</code></pre>
",0
27563246,27561031,1,"<pre><code>#include &lt;stdio.h&gt;                                                                                                                            
int main()                                                                                                                                    
{                                                                                                                                             
        char str[16];                                                                                                                         
        int len;                                                                                                                              

        len = snprintf(str, sizeof( str ), ""%s %d %f"", ""hello world"", 1000, 10.5);                                                            
        printf(""%s\n"", str);                                                                                                                  

        if (len &gt;= 16)                                                                                                                        
        {                                                                                                                                     
                printf(""length truncated (from %d)\n"", len);                                                                                  
        }                                                                                                                                     
} 

output:
=======
 ./a.out
hello world 100
length truncated (from 26)

/* You can see from the output only 15 char + '\0' is displayed on the console ( stored in the str ) */


/* Now changing the size of the str from 16 to 46 */

#include &lt;stdio.h&gt;
int main()
{

        char str[46];
        int len;

        len = snprintf(str, sizeof( str ), ""%s %d %f"", ""hello world"", 1000, 10.5);
        printf(""%s\n"", str);

        if (len &gt;= 46)
        {
                printf(""length truncated (from %d)\n"", len);
        }
}

output:
==========
./a.out
hello world 1000 10.500000
</code></pre>
",0
22463391,22455090,1,"<p>You can flush <code>stdin</code> using <code>getchar</code> or <code>fgetc(stdin)</code>:</p>

<pre><code>static void flush_stdin(void)
{
    int c;

    while ((c = fgetc(stdin)) != '\n' &amp;&amp; c != EOF);
}

scanf(""%d"",&amp;a);
flush_stdin();
fgets(ch,SIZE,stdin);    //SIZE=100 and ch is a char array
</code></pre>
",0
26429632,26429579,6,"<p>Pass a pointer-to-const is the obvious answer</p>

<pre><code>void foo(const struct some_struct *p)
</code></pre>

<p>That will prevent you from modifying the immediate members of the struct inadvertently. That's what <code>const</code> is for.</p>

<p>In fact, your question sounds like a copy-paste from some quiz card, with <code>const</code> being the expected answer.</p>
",0
26429726,26429579,2,"<p>In general, when it comes to simple optimizations like what you've described, it is often preferable to use a <code>pointer-to-struct</code> rather than passing a <code>struct</code> itself, as passing a whole <code>struct</code> means more overhead from extra data being copied onto the call stack.</p>

<p>The example below is a fairly common approach:</p>

<pre><code>#include &lt;errno.h&gt;

typedef struct myStruct {
   int  i;
   char c;
} myStruct_t;


int myFunc(myStruct_t* pStruct) {
   if (!pStruct) {
      return EINVAL;
   }

   // Do some stuff

   return 0;
}
</code></pre>

<p>If you want to avoid modifying the data passed to the function, just make sure that the data is immutable by modifying the function prototype.</p>

<pre><code>int myFunc(const myStruct_t* pStruct)
</code></pre>

<p>You will also benefit from reading up on <a href=""https://stackoverflow.com/questions/13181546/const-correctness-for-structs-with-pointers"">""const correctness""</a>.</p>
",4
26430156,26429579,0,"<p>A very common idiom, particularly in unix/posix style system code is to have the caller allocate a struct, and pass a pointer to that struct through the function call.</p>

<p>This is a little different than what I think your asking about where you are passing data into a function with a struct (where as others have mention you may the function to treat the struct as const). In these cases, the struct is empty (or only partially full) before the function call. The caller will do something like allocate an empty struct and then passes a pointer to this struct. Probably different than your general question, but relevant to the discussion I think.</p>

<p>This accomplishes a couple handy things. It avoids copying a possibly large structure, also it lets the caller fill in some fields and the callee to fill out other (giving an effective shared space for communication). </p>

<p>The most important aspect to this idiom is that the caller has full control over the allocation of the struct. It can have it on the stack, heap, reuse the same one repeatedly, but where it comes from the caller is responsible for the handling the memory.</p>

<p>This is one of the problems with passing around struct pointers; you can easily lose track of who allocated the struct and whose responsibility it is to free it. This idiom gives you the advantage of not having to copy the struct around, while making it clear who has the job of free'ing the memory is. </p>
",3
30175629,30175023,0,"<p>gcc &lt; 5.1.0 default standard is <code>-std=gnu90</code>. Version 5.1.0, changed the default from <code>-std=gnu90</code> to <code>-std=gnu11</code>.</p>

<p>You should compile your code with <code>-std=gnu99</code> to have the identifier <code>CLOCK_MONOTONIC</code> available.</p>

<p><a href=""https://stackoverflow.com/questions/8881617/constants-not-loaded-by-compiler"">This answer</a> might provide more details.</p>
",0
27154400,27154120,0,"<pre><code>fwrite( &amp;hardware, sizeof( struct hardwareData), 1, hfPtr);
</code></pre>

<p>Where are you initializing your local file pointer <code>hfptr</code> hence the crash.
Inside</p>

<pre><code>void newRecord( FILE *fPtr )
</code></pre>

<p>You have a local variable <code>hfPtr</code> and that is not initialized. </p>

<p>The pointer is not pointing to anything, you need to do something like.</p>

<pre><code>FILE *hfPtr = fopen(""file"",""w"");
</code></pre>
",4
27154240,27154120,-1,"<p>cFptr will always be null. When you fail to open the file for the first time you dont update that pointer. You should either return the file handle from the textFile function or re-open the file in main</p>

<p>But mainly - learn to use xcode debugger and step through your program line by line </p>
",0
22490126,22489902,1,"<p>Call:</p>

<pre><code>int *A = load_from_file(&amp;count);
</code></pre>

<p>Function:</p>

<pre><code>int *load_from_file(int *n)
{
    FILE* fp;
    int temp,i;
    int *A = 0;

    fp=fopen(""data.txt"",""r"");
    if (fp==NULL){fprintf(stderr, ""error!!\n"");exit (1);}

    fscanf(fp,""%d"",&amp;temp);
    *n=temp;
    A = (int*) realloc(A,temp * sizeof(int));
    if (A == NULL) {fprintf(stderr, ""error realloc!!\n"");exit(1);}
    for(i=0;i&lt;temp;i++)
        fscanf(fp, ""%d"",&amp;A[i]);
    for(i=0;i&lt;temp;i++)
    {
        printf(""A[%d]=%d "",i,A[i]);
        printf(""\n"");
        printf(""&amp;A[%d]=%p \n\n"",i,&amp;A[i]);
    }
    fclose(fp);
    return A;
}
</code></pre>

<p>This is a totally minimal set of changes; the code needs a lot more work.  In particular, the <code>fscanf()</code> calls should be error checked.  There's a subtle but important change in the allocation test: <code>if (A == NULL)</code> rather than the original <code>if (*A == NULL)</code>.</p>

<hr>

<p>With somewhat more complete error checking:</p>

<pre><code>int *load_from_file(int *n)
{
    FILE *fp;
    int temp, i;
    int *A = 0;
    const char file[] = ""data.txt"";

    fp = fopen(file, ""r"");
    if (fp == NULL)
    {
        fprintf(stderr, ""Failed to open file %s for reading\n"", file);
        exit(1);
    }

    if (fscanf(fp, ""%d"", &amp;temp) != 1)
    {
        fprintf(stderr, ""Failed to read number of entries\n"");
        exit(1);
    }
    *n = temp;
    A = (int *) realloc(A, temp * sizeof(int));
    if (A == NULL)
    {
        fprintf(stderr, ""Failed to reallocate %zu bytes of memory\n"",
                temp * sizeof(int));
        exit(1);
    }
    for (i = 0; i &lt; temp; i++)
    {
        if (fscanf(fp, ""%d"", &amp;A[i]) != 1)
        {
            fprintf(stderr, ""Failed to read entry number %d\n"", i);
            exit(1);
        }
    }
    for (i = 0; i &lt; temp; i++)
        printf(""A[%d]=%d: &amp;A[%d]=%p\n"", i, A[i], i, &amp;A[i]);
    fclose(fp);
    return A;
}
</code></pre>

<p>I have a library of error reporting functions that I use which would reduce the error handling from 4 lines to 1 line per error.  I strongly recommend creating and using such a library for yourself.</p>
",2
22445288,22445110,0,"<p>You can do something like this:</p>

<pre><code>    #include&lt;stdio.h&gt;
    #include&lt;string.h&gt;


    int main()
    {
        char text[] = ""Hello"";

         int i=0;
         int size= strlen(text);

         for(i=0;i&lt;size;i++)
         {
              //something here  
         }

         return 0;

     }
</code></pre>
",1
22445418,22445110,-1,"<p>You should read about dynamic arrays in C.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

char* code(const char* message)
{
    int i = 0;
    char* coded;
    for (i = 0; i &lt; strlen(message); i++)
    {
        coded[i] = message[i] - 3;
    }
    return coded;
}

char* decode(const char* message)
{
    int i = 0;
    char* coded;
    for (i = 0; i &lt; strlen(message); i++)
    {
        coded[i] = message[i] + 3;
    }
    return coded;
}

int main()
{
    // This is dynamic allocated chars array
    char* message = ""Hello World!"";
    message = code(message);
    printf(""%s\n"", message);
    message = decode(message);
    printf(""%s\n"", message);
}
</code></pre>
",2
22445690,22445110,0,"<p>Assuming the string is mutable, you can update it in place:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

void update(char *s, int delta)
{
    while(*s)
        *s++ += delta;
}

int main(int argc, char **argv)
{
    char str[] = ""Hello"";
    update(str, 1);
    printf(""Encoded: \""%s\""\n"", str);
    update(str, -1);
    printf(""Decoded: \""%s\""\n"", str);
    return 0;
}
</code></pre>

<p>If the string is immutable, you will need to make a copy of it, and update the copy.</p>

<pre><code>int main(int argc, char **argv)
{
    const char str[] = ""Hello"";
    char *copy = strdup(str);
    update(copy, 1);
    printf(""Encoded: \""%s\""\n"", copy);
    update(copy, -1);
    printf(""Decoded: \""%s\""\n"", copy);
    free(copy);
    return 0;
}
</code></pre>
",0
22877336,22877287,1,"<p>You need <code>&amp;&amp;</code> instead of <code>||</code> in if conditions. </p>

<p>In your code for <code>inm = 3000</code> second if-case-condition pass because you use <code>||</code> condition that evaluates   52.... (<a href=""http://codepad.org/mkbVBEuE"" rel=""nofollow"">check what is happening, and what you need both</a>)</p>

<p>In your, code the third case is in else part of second <code>if</code>. You have nested <code>if</code>s, whereas you need sequential ifs, remove else. </p>

<pre><code>if(inm&lt;750){
    printf(""tax due :%f"",inm*1/100);
}
if(inm&gt;=750 &amp;&amp; inm&lt;=2250){
    printf(""tax due :%f"",inm=7.50+((inm-750)*2/100));
}
if(inm&gt;=2251 &amp;&amp; inm&lt;=3750){
    printf(""tax due :%f"",inm=37.50+((inm-2250)*3/100));
}
</code></pre>

<p><a href=""http://codepad.org/ASyItrGE"" rel=""nofollow"">codepad</a></p>

<p>Addtionally, <a href=""http://www.cs.arizona.edu/~mccann/indent_c.html"" rel=""nofollow"">indent</a> your code correctly.</p>
",0
22877540,22877287,1,"<p>I think @Grijesh Chauhan is correct.</p>

<p>And you may want to write code as below.</p>

<pre><code>#include &lt;stdio.h&gt;

int main( void ){

    float inm;

    printf( ""Enter the amount of taxable  income:"" );
    scanf( ""%f"", &amp;inm );

    if ( inm &lt; 750 ){
        printf( ""tax due :%f"", inm * 1 / 100 );
    }
    else if (inm &lt;= 2250 ){
        printf( ""tax due :%f"", inm = 7.50 + ( ( inm - 750 ) * 2 / 100 ) );
    }
    else if (inm &lt;= 3750 ){
        printf( ""tax due :%f"", inm = 37.50 + ( ( inm - 2250 ) * 3 / 100 ) );
    }

    return 0;
}
</code></pre>

<p>output:</p>

<pre><code>Enter the amount of taxable  income:3000
tax due :60.000000
</code></pre>
",0
22522955,22522692,2,"<p>It's an operator precedence issue.</p>

<pre><code>*numDeposit++;
</code></pre>

<p>The postfix ++ has a higher precedence than *. So it's evaluating to</p>

<pre><code>*(numDeposit++);
</code></pre>

<p>Which basically does nothing (it increments the pointer then references the value at that memory location).  You can do</p>

<pre><code>(*numDeposit)++;
</code></pre>

<p>Or </p>

<pre><code>*numDeposit += 1;
</code></pre>

<p>See <a href=""http://en.cppreference.com/w/cpp/language/operator_precedence"" rel=""nofollow"">http://en.cppreference.com/w/cpp/language/operator_precedence</a>.</p>
",0
25502770,25502611,0,"<p>To convert a float to its corresponding integer, you should not simply take the bits and re-interpret them as an integer.</p>

<p>Simply do:</p>

<pre><code>int i = (int)myFloat;
</code></pre>

<p>That will cause a conversion to happen from the internal format of <code>float</code> to an <code>int</code>. The fractional part of the <code>float</code> will be truncated, so it will round down toward 0.</p>

<h2>EDIT</h2>

<p>Since your values are the result of a sinus call, they will be in the [-1.0f, 1.0f] range. If you want to have values in the [-4096, 4096] range, simply do:</p>

<pre><code>int i = (int)(4096 * myFloat);
</code></pre>
",4
26149228,25515713,0,"<p>Turns out the issue was with my variable type caused by my compiler. <code>gapLength</code> and <code>scafLength</code> were originally declared as <code>int</code>.  Having run out of options, I switch them to <code>long</code> and the code performs perfectly.  Apparently my compiler has the short <code>int</code> limit of 32,768.</p>
",0
25515819,25515713,1,"<p>In the first version it looks like you only incrementing scafLength when <code>(in != '\n')</code> but in the second version you continually add the value of <code>gapLength - 1</code> whenever you enter the outer if-block and not just when you enter the inner <code>(in != '\n')</code> </p>

<p>Presumably the value of gapLength isn't reset and therefore the second version grows faster.</p>

<p>As your code is incomplete it's really hard to say, so consider this a guess.</p>
",1
24648255,24648203,4,"<p>It does exactly nothing. It gets preprocessed to an empty string. This may be a somewhat convenient way of disabling/enabling debug log messages. The code was probably written like this at some point:</p>

<pre><code>#define LOG_DBG(x) some_logging_function(x)
</code></pre>

<p>But then someone wanted to simply get rid of all the log messages in one shot.</p>
",0
24648260,24648203,1,"<p>It will do nothing. You're seeing the ""disabled"" form of the macro, which is used to make the logging calls go away on non-debug builds.</p>

<p>There should be another declaration of the macro somewhere, or the code is perhaps just ""left"" in the non-debugging state.</p>
",0
24648295,24648203,1,"<p>You've defined a macro that receives x as parameter but do nothing. Here's a concrete use of macro:</p>

<pre><code>#include &lt;stdio.h&gt;

#define LOG_DBG(x) ((x)+5)
int main(int argc, char *argv[])
{
  int x = LOG_DBG(3);
  printf(""%d\n"", x);
  return 0;
} 
</code></pre>

<p>Here, we did something in the macro and hence the number 8 will be printed.</p>

<p>Of course, if you want the logarithm of x, it would be another expression.</p>
",4
23856430,23856306,13,"<p>Well creating a .log file is just like creating any other file in C</p>

<pre><code>FILE *f;
f = fopen(""x.log"", ""a+""); // a+ (create + append) option will allow appending which is useful in a log file
if (f == NULL) { /* Something is wrong   */}
fprintf(f, ""I'm logging something ...\n"");
</code></pre>

<p>That is pretty much the whole magic. </p>
",2
29465128,29464603,2,"<p>First You open the document file using the <code>open</code> or <code>fopen</code> function.</p>

<p>eg: <code>fp=fopen (filename,""r"");</code></p>

<p>Then read line by line using <code>fgets</code>.</p>

<p>eg: <code>while(fgets(array,BUFSIZ,fp) != NULL)</code></p>

<p>After reading each line store the data in the structure using the <code>sscanf</code> function.</p>

<p>eg: <code>sscanf(array,"" %d  %s</code>"", &amp;var[i].id,var[i].name);`</p>

<p>The data in the file will be loaded in the structure.</p>
",3
29465360,29464603,0,"<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#define MAXLENGTH 200 
typedef struct node{
    char query[MAXLENGTH];
}DATA;

typedef struct stack{
    DATA data[MAXLENGTH];
    int top;
}Stack;

void write(FILE *file,Stack* st)
{   
    while(!feof(file)){  //Check EOF
        st-&gt;top++; 
        fgets(st-&gt;data[st-&gt;top].query,MAXLENGTH,file); //Scan data line by line and put into data structure
        //printf(""%s"",st-&gt;data[st-&gt;top].query); 
    }
}

void read(Stack* st)
{
    FILE *file;
    file = fopen(""h.txt"", ""r"");
    write(file,st);
}

int main(){
    int i;
    Stack st;
    st.top = -1;

    read(&amp;st);

    for(i = 0; i&lt;= st.top; i++){  //DISPLAY DATA
        printf(""%s\n"",st.data[i].query); 
    } 
    fflush(stdin);getchar();
    return 0;
}
</code></pre>
",0
29467231,29464603,0,"<p>Since you are trying to parse string that contains spaces, which are in turn separated from other fields by more spaces (e.g <code>name</code> and <code>address</code>), you <strong>cannot</strong> read the line and then parse the string with <code>sscanf</code>. It simply isn't possible. With <code>scanf/sscanf</code> the match of a string terminates on the first <code>whitespace</code> (unless a <code>width</code> specifier is given), rendering it useless for parsing strings of varying length containing whitespace. E.g.:</p>

<pre><code>Jane Smith    123 lala land    123-222-1231
</code></pre>

<p>Attempting to parse with <code>%s</code> reads <code>Jane</code> and no more. Unless you are guaranteed of a fixed width column, <code>sscanf</code> will not work in this case. </p>

<p>Compounding the problem, not only do the strings contain spaces, but the delimiters are composed of multiple-spaces. So unfortunately, this is a situation where you must use pointers to parse the string. How? Start with <strong>known</strong> information.</p>

<p>The only thing that makes this possible is presumption that <strong>the phone number contains no-whitespace</strong>. So using <code>strrchr</code> (or set a pointer at the end of the string and backup) you can simply find the space before the start of the phone number. Set an <code>end pointer (ep)</code> prior to this space, advance the original pointer by <code>1</code> and copy the phone number to the structure.</p>

<p>Starting at <code>ep</code>, work backwards until you find the first non-space character (end of the address field) and set a <code>null-terminating</code> character there.</p>

<p>The next known point is the beginning of the string. Start there and find the first <code>double-space</code>. (the presumption being that the name, address and phone fields are all separated <strong>by at least 2 spaces</strong>). You know the first of the double-space is the end of the name field, set a <code>null-terminating</code> character there. (you can read/copy name to the struct at this point by simply reading the start of the string)</p>

<p>Finally, work forward until you find the next non-space character. This is the start of the address. Copy the address to the struct and you are done. (repeat process for each line).</p>

<p>Sometimes where you have no sane delimiter, you have to fall-back to simply stepping through the string with a pointer and processing it piecemeal. This is one of those cases. Look over the following and let me know if you have questions:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define EMAX 128

typedef struct entry {
    char name[32];
    char address[32];
    char phone[16];
} entry;

size_t readtxtfile (char *fn, entry *array);
void prn_entries (entry *array);

int main (int argc, char **argv) {

    /* validate number of arguments */
    if (argc &lt; 2 ) {
        fprintf (stderr, ""error: insufficient input, usage: %s &lt;filename1&gt;\n"", argv[0]);
        return 1;
    }

    /* initialize all variables */
    size_t index = 0;
    entry contacts[EMAX] = {{{0}, {0}, {0}}};

    /* read file into an array of entries,
    number of entries, returned to index */
    index = readtxtfile (argv[1], contacts);

    /* simple print function */
    if (index &gt; 0)
    {
        printf (""\nNumber of entries in contacts : %zu\n\n"", index);
        prn_entries (contacts);
    }
    else
        fprintf (stderr, ""error: no entries read from file '%s'\n."", argv[1]);

    return 0;
}

size_t readtxtfile (char *fn, entry *array)
{
    if (!fn) return 0;              /* validate filename provided       */

    char *ln = NULL;                /* NULL forces getline to allocate  */
    size_t n = 0;                   /* max chars to read (0 - no limit) */
    ssize_t nchr = 0;               /* number of chars actually read    */
    size_t idx = 0;                 /* couner for number of entries     */
    FILE *fp = NULL;                /* file pointer to open file fn     */

    /* open / validate file */
    if (!(fp = fopen (fn, ""r""))) {
        fprintf (stderr, ""%s() error: file open failed '%s'."", __func__, fn);
        return 0;
    }

    /* read each line from file */
    while ((nchr = getline (&amp;ln, &amp;n, fp)) != -1)
    {
        /* strip newline or carriage rtn    */
        while (nchr &gt; 0 &amp;&amp; (ln[nchr-1] == '\n' || ln[nchr-1] == '\r'))
            ln[--nchr] = 0;

        /* create a copy of ln to preserve start address */
        char *lcpy = strdup (ln);
        if (!lcpy) {
            fprintf (stderr, ""%s() error: memory allocation failed.\n"", __func__);
            continue;
        }

        char *p = strrchr (lcpy, ' ');                  /* find last space in line      */
        char *ep = p - 1;                               /* set end pointer 1 before     */

        p++;                                            /* advance to next char         */
        strncpy (array[idx].phone, p, strlen (p));      /* copy p to phone              */

        while (ep &gt; lcpy &amp;&amp; *ep == ' ') ep--;           /* find first space after addr  */
        *(++ep) = 0;                                    /* null-terminat at that space  */

        p = lcpy;           /* start at beginning of string and find first double-space */
        while (*(p + 1) &amp;&amp; !(*(p + 1) == ' ' &amp;&amp; *p == ' ')) p++;

        *p = 0;                     /* null-terminate at first space    */

        while (*(++p) == ' ');      /* find first char in addr          */

        strncpy (array[idx].address, p, strlen (p));    /* copy p to address            */
        strncpy (array[idx].name, lcpy, strlen (lcpy)); /* copy lcpy to name            */

        free (lcpy);                /* free memory allocated by strdup  */
        lcpy = NULL;                /* reset pointer NULL               */

        idx++;                      /* increment entry index            */
        if (idx == EMAX)            /* check if EMAX reached &amp; return   */
        {
            fprintf (stderr, ""%s() warning: maximun number of entries read\n"", __func__);
            break;
        }
    }

    if (ln) free (ln);              /* free memory allocated by getline */
    if (fp) fclose (fp);            /* close open file descriptor       */

    return idx;
}

/* print an array of character pointers. */
void prn_entries (entry *array)
{
    register size_t n = 0;
    while (strlen (array[n].name) &gt; 0)
    {
        printf ("" (%2zu.)  %-32s %-32s %s\n"", n, array[n].name, array[n].address, array[n].phone);
        n++;
    }
}
</code></pre>

<p><strong>Output</strong></p>

<pre><code>$ ./bin/read_entries dat/nmaddph.txt

Number of entries in contacts : 3

 ( 0.)  Jane Smith                       123 lala land                    123-222-1231
 ( 1.)  Bob Fall                         123 blue jay st                  812-923-1111
 ( 2.)  Sally White                      1 rose ave.                      +1-231-2318
</code></pre>

<p><strong>Note:</strong> using <code>getline</code> or any time you have allocated space for a string dynamically, you need to make a copy before you alter that memory block with functions that do not preserve the original start of the string (like <code>strtok</code> or you manually iterating over the string with the string variable). <code>getline</code> allocates the memory for <code>ln</code> for you (if originally set NULL) and as a result <code>getline</code> is responsible for freeing it. If you alter the start address for the string, or leave parts of it unreachable, then when <code>getline</code> attempts to <code>realloc</code> or <code>free</code> that block of memory, a memory error will occur. Making a copy will save you a lot of headaches.</p>

<p>In the example above, a copy of the <code>ln</code> allocated by <code>getline</code> is made. Character pointers are assigned as needed <strong>to preserve the starting address</strong> of <code>lcpy</code>. If you would have iterated over the string advancing <code>lcpy</code> (e.g. <code>lcpy++;</code>), instead of using a second pointer, the original start address would be lost. When you (or the program on exit) attempts to free <code>lcpy</code> a whole host of errors (or segmentation faults) can occur.</p>
",0
26812619,26812562,6,"<p><code>k &amp; 1</code> does a bitwise AND operation of the <code>k</code> variable and the <code>1</code> literal.  The expression results in either <code>0</code> (if the LSB of <code>k</code> is <code>0</code>) or <code>1</code> (if the LSB of <code>k</code> is <code>1</code>).  As the expression is the condition for the <code>if</code> statement, it is implicitly cast to <code>bool</code>, for which <code>1</code> maps to <code>true</code> and <code>0</code> maps to <code>false</code>.</p>
",0
21714379,21714273,2,"<p>All of your trouble has to do with making a copy of the input struct and then updating the copy rather than the one you passed in. Change as follows:</p>

<pre><code>void insertCommand(struct commandStorage* addressOfcStore, char newCommand[])
{
    addressOfcStore-&gt;mostRecent++;
    if (addressOfcStore-&gt;mostRecent &gt;= MAX_COMMANDS)
    {
       addressOfcStore-&gt;mostRecent = 0;
    }

    strncpy(addressOfcStore-&gt;stringArray[addressOfcStore-&gt;mostRecent],
            newCommand, 
            MAX_STRING_LENGTH);

}
</code></pre>
",5
26813557,26813514,0,"<pre><code>#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt; 
// You need to include the relevant headers
//  - stdio.h  for printf, scanf etc
//  - stdlib.h for system

int main(void)
{
    char name[20];
    printf(&quot;Enter the file name: &quot;);
    scanf(&quot;%19s&quot;, name);
    // Scan a string (word). Since the array size is 20, scan a 
    // maximum of 19 characters (+1 for the \0 at the end)
    // so that we don't run into a buffer overflow situation

    FILE* info;
    // Not recommended to use capital letters at the start for variables
    info = fopen(name, &quot;r&quot;);
    if(info == NULL)
    {
        // Opening the file failed
        printf(&quot;Opening %s failed&quot;, name);
    }
    else
    {
        // Opening the file was successful

        // Read the file etc

        // Close the opened FILE object
        fclose(info);
    }

    system(&quot;pause&quot;);
}
</code></pre>
",5
21038373,21038120,0,"<p><a href=""http://ideone.com/pt1gEd"" rel=""nofollow"">check this</a>
      #</p>

<pre><code>  int main(void) 
  {
     // your code goes here
     unsigned int X = 0x08090a0b;

     printf(""%8x"", ((X &lt;&lt; 24) | (((X&gt;&gt;16)&lt;&lt;24)&gt;&gt;16) | (((X&lt;&lt;16)&gt;&gt;24)&lt;&lt;16) | (X&gt;&gt;24)));
     return 0;
  }
</code></pre>

<p>Your output is correct only. are you saying that 0 initially is not being displayed ?? </p>

<p>09 = 9
in your case x0b0a0908 = b0a0908</p>
",0
21038810,21038120,2,"<p>It is cleaner and easier to follow if you combine shifting with masking: below I show both the complete expression, and its components separately. Note that you don't need the leading zeros in the mask - I put it there for clarity / alignment. And you don't need masks for the first and last term, as all the ""unwanted"" bits shift out of the expression.</p>

<pre><code>#define REV(X) ((X &lt;&lt; 24) | (( X &amp; 0xff00 ) &lt;&lt; 8) | (( X &gt;&gt; 8) &amp; 0xff00 ) | ( X &gt;&gt; 24 ))
</code></pre>

<p>One byte at a time:</p>

<pre><code>#define R1(X) ((X &amp; 0x000000ff ) &lt;&lt; 24 )
#define R2(X) ((X &amp; 0x0000ff00 ) &lt;&lt;  8 )
#define R3(X) ((X &amp; 0x00ff0000 ) &gt;&gt;  8 )
#define R4(X) ((X &amp; 0xff000000 ) &gt;&gt; 24 )
</code></pre>

<p>To print out the number correctly, use</p>

<pre><code>printf(""%08x"", REV(x));
</code></pre>

<p>This will make sure that leading zeros are printed. You have to make sure that your input is a 32 bit unsigned integer for this to work correctly.</p>
",1
24572357,24572324,2,"<p>The data itself is not ""hexadecimal"", it's just a single character (byte, typically) of bits from the file.</p>

<p>You can choose to print it in hexadecimal, or any other format. You can do that regardless if you have the value in an array or not.</p>
",0
25547536,25546893,1,"<p>hey you are requesting for 256*256*256 = 16777216 byte of blocks. And this array is declare in main() method, which takes the memory on stack rather than heap. 
So try to declare this array outside the main() or use malloc() function to dynamically allocate the memory. It will work fine.</p>
",1
31148847,30825829,0,"<p>I am a moron and wasn't initializing the pointer. After doing that correctly it worked fine. Thanks for all your help.</p>
",0
26118949,26118872,3,"<p>The following does not raise <code>(x2 - x1)</code> to the second power; rather, it multiplies by four:</p>

<pre><code>double formula1 = (x2-x1) * 2 * 2; 
</code></pre>

<p>The same goes for the next line.</p>

<p>Once you've fixed those, things will improve (you will no longer be trying to compute the real square root of a negative number, which is what gives you the <a href=""http://en.wikipedia.org/wiki/NaN"" rel=""nofollow"">NaN</a>).</p>

<p>Edit: To compute the square use either <code>(x2-x1) * (x2-x1)</code> or <code>pow(x2-x1, 2.0)</code>.</p>
",2
26119252,26118872,1,"<p>you'll be calling your distance function as</p>

<pre><code>distance (x1=1, x2=0, y1=0, y2=0)
</code></pre>

<p>and then </p>

<pre><code>double formula1 = (x2-x1) * 2 * 2; 
</code></pre>

<p>will evaluate to -4</p>

<p>and then </p>

<pre><code> double formula = formula1 + formula2;
</code></pre>

<p>will evaluate to -4 </p>

<p>thus</p>

<pre><code>sqrt(formula);
</code></pre>

<p>as -nan</p>
",0
28511091,28511051,4,"<p>When you add and subtract pointers in C, it's done in <em>units</em> of the size of the type pointed to. So, for example, if</p>

<pre><code>int s[10];
</code></pre>

<p>if <code>s</code> points to an <code>int</code>, then <code>s+1</code> points to the next <code>int</code>, not the next byte. Likewise, if you subtract one pointer from another you get the distance between them in terms of the their type, not bytes.</p>

<p>So <code>offsetof</code> casts the pointers to <code>char *</code> so that it always returns offsets in terms of bytes.</p>
",0
33029569,33029536,2,"<p>You have <em>not</em> allocate memory to <code>char</code> pointer <code>cache</code> . <em>Allocate memory</em> to it before using it in <code>fgets</code> (<em>also remember to</em> <code>free</code> <em>it</em>).</p>

<p><em>Note-</em> variable <code>size</code> in method 3 remains uninitialized , so method 3 has no chance to work .</p>
",0
33029573,33029536,1,"<ol>
<li>You don't allocate memory for cache. Good idea to use ftell() result.</li>
<li>You use ""sizeof(cache)"". Please note, this is just size of pointer - 4 or 8 bytes.</li>
</ol>
",0
33029575,33029536,1,"<p><strong>Problem 1</strong></p>

<pre><code>fseek(list, 0, SEEK_END);
</code></pre>

<p>puts <code>list</code> at the end of the file. You need to rewind the file to be able read its contents.</p>

<p>Add</p>

<pre><code>rewind(list);
</code></pre>

<p>before you read the contents of the file.</p>

<p><strong>Problem 2</strong></p>

<p>You also need to allocate memory for <code>cache</code> before reading into it.</p>

<p><strong>Problem 3</strong></p>

<p><code>fgets</code> reads only one line of text. If you want to read the contents of the entire file, you need to use <code>fread</code>.</p>

<hr>

<p>Try:</p>

<pre><code>fseek(list, 0, SEEK_END);
long size = ftell(list);
if (size == 0)
{
   fprintf(stdout, ""list.txt is empty \n"");
}

// Rewind the file
rewind(list);

cache = malloc(size+1);
if ( cache == NULL }
{
   // Unable to allocate memory.
   exit(1);
}

int n = fread(cache, 1, size, list);
if ( n != size )
{
   // Was able to read only n characters,
   // not size characters.
   // Print a message.
}

cache[n] = '\0';
fprintf(stdout, ""cache is %s\n"", cache);
</code></pre>
",0
33820679,33820175,1,"<p>Write <code>a++,b--;</code></p>

<p>Two expressions separated by a comma are evaluated left to right.</p>
",2
22525964,22525684,0,"<p>You can use <code>kbhit</code> (or <code>_getch</code> and <code>_kbhit</code>) to peek and see if there are some keys pressed. And only if there are some, get it with <code>getch</code>. Also see <a href=""https://stackoverflow.com/questions/15603082/how-to-use-kbhit-and-getch-c-programming"">this</a> question and answer for an example.</p>
",2
22877371,22877279,5,"<p>your code is legal ISO C99 code. It's not C89 ANSI compliant: if you are stuck with compatibility rules, because of old compilers or company policies, you need to use <code>malloc()</code>.</p>

<p>More importantly, in C99, using your definition, the array is allocated on <em>stack</em>, that is usually a limited resource, while with <code>malloc()</code> it's allocated in the <em>heap</em>.</p>
",0
22877510,22877279,0,"<p>""...it is not correct way of writing as it surpasses the use of malloc function..."" - what is that supposed to mean? According to the rules of modern C language, the only problem with your code is the missing <code>int</code> in the declaration of <code>main</code>. I.e. it has nothing to do with any <code>malloc</code>.</p>

<p>It can be said that your code is self-contradictory in a sense that it uses a perfectly valid C99 feature - variable length array <code>int a[n]</code> - but at the same time relies on an obsolete feature of C89/90 - implied <code>int</code> in the declaration of <code>main</code>, which is no longer supported by C99.</p>

<p>You need to decide which version of C language you are trying to use - C89/90 or C99. Once you make that decision, we'll be able to discuss the correctness of your code. </p>
",1
22877609,22877279,1,"<p>Your array is a variable length array (VLA). This is an advanced feature of C, introduced in the C99 version of the standard. </p>

<p>The problem with VLAs is that they can easily overflow the stack. Unless you have a specific reason to use a VLA, use dynamic memory with <code>malloc</code> and avoid the risk of stack overflow. </p>

<p>Your main declaration is wrong. It should be</p>

<pre><code>int main(void)
</code></pre>
",0
29171927,29171820,2,"<p>It's because of your badly formed scanf storage location. You're scanning into an item that has zero bytes to store data... this causes undefined results which, in this case, are likely overwriting your value of <code>q</code> - apparently with a value you can still read. Try printing the value of <code>q</code> before and after your <code>scanf</code> to see what I mean.</p>

<p>Better yet, declare the length of <code>x</code> to be longer than the input (including line termination and NULL termination) will be!</p>
",0
28205142,28204979,2,"<p>Count the number of newline characters (usually <code>\n</code>) in the buffer.</p>
",0
28206377,28204979,1,"<p>Count the number of ""previous"" <code>char</code> that were <code>'\n'</code>.</p>

<p>If the buffer was <code>""abcdef""</code>, that would be 1 line.<br>
If the buffer was <code>""abcdef\n""</code>, that would also be 1 line.<br>
If the buffer was <code>""abcdef\ndef""</code>, that would be 2 lines.  </p>

<pre><code>unsigned long long linecount = 0;
int previous = '\n';
char buffer[N];
size_t len;
while ((len = fread(buffer, 1, sizeof buffer, stream)) &gt; 0) {
  for (size_t i=0; i&lt;len; i++) {
    if (previous == '\n') linecount++;
    previous = buffer[i];
  }
}
printf(""%llu\n"", linecount);
</code></pre>
",0
31898003,31897880,1,"<p>So it actually <strong>wasn't</strong> getting stuck in an infinite loop. C code is usually so fast that I assume it's broken if it doesn't complete immediately.</p>

<p>It did eventually return the correct answer after I let it run for about 10 seconds. Turns out that 2,147,483,647 increments takes quite a few cycles to complete.</p>

<p>I should also note that I compiled with <code>cc -O0</code> to disable optimizations, so this wasn't the problem.</p>

<p>A faster solution might look something like this:</p>

<pre><code>int i_max = 0;
int step_size = 256;

while ((i_max + step_size) &gt; i_max) {
    i_max += step_size;
}

while ((i_max + 1) &gt; i_max) {
    ++i_max;
}

printf(""int max: %d\n"", i_max);
</code></pre>

<p>However, as signed overflow is undefined behavior, probably it is a terrible idea to ever try to programmatically guess this in practice. Better to use <code>INT_MAX</code>.</p>
",4
31898039,31897880,7,"<p>Ok, I was about to write a comment but it got too long...</p>

<p>Are you allowed to use <code>sizeof</code>?</p>

<p>If true, then there is an easy way to find the max value for any type:</p>

<p>For example, I'll find the maximum value for an integer:</p>

<p>Definition: <code>INT_MAX = (1 &lt;&lt; 31) - 1</code> for 32-bit integer (2^31 - 1)</p>

<p>The previous definition overflows if we use integers to compute int max, so, it has to be adapted properly:</p>

<pre><code>INT_MAX = (1 &lt;&lt; 31) - 1
        = ((1 &lt;&lt; 30) * 2) - 1
        = ((1 &lt;&lt; 30) - 1) * 2 + 2) - 1
        = ((1 &lt;&lt; 30) - 1) * 2) + 1
</code></pre>

<p>And using <code>sizeof</code>:</p>

<pre><code>INT_MAX = ((1 &lt;&lt; (sizeof(int)*8 - 2) - 1) * 2) + 1
</code></pre>

<p>You can do the same for any signed/unsigned type by just reading the rules for each type.</p>
",4
31902428,31897880,0,"<p>Assuming a two's complement processor, use unsigned math:</p>

<pre><code>unsigned ... smax, smin;
    smax = ((unsigned ...)0 - (unsigned ...)1) / (unsigned ...) 2;
    smin = ~smax;
</code></pre>
",0
21586723,21586662,0,"<p>The source is maintained by sourceforge.net <a href=""http://traceroute.sourceforge.net/"" rel=""nofollow"">here</a></p>
",0
23587114,23586902,1,"<p>This doesn't spoon-feed you the code, but the questions may guide you.</p>

<p>Questions to which you must know the answers:</p>

<ol>
<li>Do you need to process just the words from a single line at a time, or do you need to keep all the words already read in memory?</li>
<li>If the same word appears several times, do you need to keep the separate appearances separate?</li>
<li>Are there any reasonable upper bounds on the length of a line, the length of a word, or the number of words in a line? If you're keeping all words, will all the information fit in memory?</li>
</ol>

<p>Assuming you're using POSIX <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/getline.html"" rel=""nofollow noreferrer""><code>getline()</code></a>, then you can use it to allocate the storage for the words.  You have to decide how to manage the storage for the array of pointers.  A fixed size allocation is simplest, but a dynamically allocated array isn't very hard.  If you are handling one line at a time, then life is easy.  If you're accumulating data across lines, then you'd have to ensure that <code>getline()</code> allocates new space for each line ¡ª not hard, but requires a modicum of care.  Either way, you need to be careful with releasing the space allocated by <code>getline()</code>.</p>

<p>You could use <code>strtok()</code>, though if <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/strtok_r.html"" rel=""nofollow noreferrer""><code>strtok_r()</code></a> or <a href=""https://msdn.microsoft.com/en-us/library/ftsafwz3.aspx"" rel=""nofollow noreferrer""><code>strtok_s()</code></a> is available, you should use one of those instead. (They're effectively interchangeable, though their behaviours on error are different.  Note that the <code>strtok_s()</code> defined in C11 Annex K is different from both the others.)</p>

<p>Another option is to use <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/strdup.html"" rel=""nofollow noreferrer""><code>strdup()</code></a> to copy words as they're parsed, maybe using <code>strchr()</code> to find the spaces that mark the ends of words.  You'd then use the same storage space repeatedly with <code>getline()</code> since you'd already have copies of the words.</p>
",0
23587137,23586902,0,"<p>So, you need to set an array of char pointers like this:</p>

<pre><code>char *srcStr = ""Now is the time for all good men"";
                ^   ^  ^   ^    ^   ^   ^    ^
                p0 p1  p2  p3   p4  p5  p6   p7
</code></pre>

<p>A common approach to doing this is to search the string for the spaces.</p>

<pre><code>char *srcStr = ""Now is the time for all good men"";
                   ^  ^   ^    ^   ^   ^    ^
</code></pre>

<p>Notice how each space is just one character off from where a pointer should be set.</p>

<p>Consider the following code:</p>

<pre><code>...
char *ptrArray[10];
int   ptrIndex = 0;
char *cp = srcStr;

// ptrArray[0] points to ""Now..."", and increment the ptrIndex.
ptrArray[ptrIndex++] = cp;    

// Find the next space character.    
while((cp=strchr(cp, ' '))
   // If another space is found, assign the next pointer in
   // 'ptrArray' to the address of 'cp' plus one.
   ptrArray[ptrIndex++] = ++cp;

...    
</code></pre>

<p>This code the raw answer to the question.  However, it may not produce the expected results.  Specifically, if you were to print the pointer values:</p>

<pre><code>printf(""p0[%s]\n"", ptrArray[0]); //Output: ""Now is the time for all good men""
printf(""p1[%s]\n"", ptrArray[1]); //Output: ""is the time for all good men""
printf(""p2[%s]\n"", ptrArray[2]); //Output: ""the time for all good men""
</code></pre>

<p>An so-on.<br>
If the intention is to limit the output (above) to only one word per pointer, instead of:</p>

<pre><code>while((cp=strchr(cp, ' '))
   ptrArray[ptrIndex++] = ++cp;
</code></pre>

<p>the code could do this:</p>

<pre><code>while((cp=strchr(cp, ' '))
   {
   *cp='\0';
   ptrArray[ptrIndex++] = ++cp;
   }
</code></pre>

<p>Which will exchange a '\0' in the srcStr where a space ' ' is found.  Something like this:</p>

<pre><code>char *srcStr = ""Now?is?the?time?for?all?good?men"";
                ^   ^  ^   ^    ^   ^   ^    ^
                p0 p1  p2  p3   p4  p5  p6   p7
</code></pre>

<p>Thus, placing a string termination character '\0' after each word, resulting in:</p>

<pre><code>printf(""p0[%s]\n"", ptrArray[0]); //Output: ""Now""
printf(""p1[%s]\n"", ptrArray[1]); //Output: ""is""
printf(""p2[%s]\n"", ptrArray[2]); //Output: ""the""
...
</code></pre>
",0
23586081,23585984,0,"<p>The empty square bracket <code>[]</code> syntax in declarations is for defining arrays with the size defined by the array initializer. In your code, however, you are simply pointing to some existing array, so you could do it with a pointer. Since your array is an array of pointers, you need a pointer to pointer, like this:</p>

<pre><code>char **currentList = currentHistory-&gt;commandslist;
</code></pre>

<p>The rest of your code remains the same.</p>

<p>Note that although this will work, it is entirely unnecessary to store a pointer to the array in a local variable. You can rewrite your code without the local, like this:</p>

<pre><code>for(int i=0; i&lt;myLength; i++)
{
    printf(""arg[%d] :%s\n"", i, currentHistory-&gt;commandslist[i]);
}
</code></pre>
",0
25673521,25671819,1,"<p>Pointers and arrays are two completely different animals; a pointer cannot be an array and an array cannot be a pointer.</p>

<p>The confusion comes from two concepts that aren't explained very well in most introductory C texts.</p>

<p>The first is that the array subscript operator <code>[]</code> can be applied to both pointer and array expressions.  The expression <code>a[i]</code> is defined as <code>*(a + i)</code>; you offset <code>i</code> <em>elements</em> from the address stored in <code>a</code> and dereference the result.  </p>

<p>So if you declare a pointer</p>

<pre><code>T *p;
</code></pre>

<p>and assign it to point to some memory, like so</p>

<pre><code>p = malloc( N * sizeof *p );
</code></pre>

<p>you'll get something like the following:</p>

<pre><code>        +---+
     p: |   | ---+
        +---+    |
         ...     |
        +---+    |
  p[0]: |   |&lt;---+
        +---+
  p[1]: |   |
        +---+
         ...
        +---+
p[N-1]: |   |
        +---+
</code></pre>

<p><code>p</code> stores the base address of the array, so <code>*(p + i)</code> gives you the value stored in the <code>i</code>'th <em>element</em> (not byte) following that address.</p>

<p>However, when you declare an array, such as </p>

<pre><code>T a[N];
</code></pre>

<p>what you get in memory is the following:</p>

<pre><code>        +---+
  a[0]: |   |
        +---+
  a[1]: |   |
        +---+
         ...
        +---+
a[N-1]: |   |
        +---+
</code></pre>

<p>Storage has only been set aside for the array elements themselves; there's no separate storage set aside for a variable named <code>a</code> to store the base address of the array.  So how can the <code>*(a+i)</code> mechanism possibly work?  </p>

<p>This brings us to the second concept: except when it is the operand of the <code>sizeof</code> or unary <code>&amp;</code> operators, or is a string literal being used to initialize another array ijn a declaration, an <em>expression</em> of type ""N-element array of <code>T</code>"" will be converted (""decay"") to an expression of type ""pointer to <code>T</code>"", and the value of the expression will be the address of the first element of the array.  </p>

<p>In other words, when the compiler sees the expression <code>a</code> in the code, it will replace that expression with a pointer to the first element of <code>a</code>, unless <code>a</code> is the operand of <code>sizeof</code> or unary <code>&amp;</code>.  So <code>a</code> evaluates to the address of the first element of the array, meaning <code>*(a + i)</code> will work as expected.  </p>

<p>Thus, the subscript operator works exactly the same way for both pointer and array expressions.  However, this does not mean that pointer <em>objects</em> are the same thing as array <em>objects</em>; they are not, and anyone who claims otherwise is confused.  </p>
",0
24571993,24571796,1,"<p>It is common for C functions to return 0 on success or error code in case of failure.</p>

<pre><code>#include &lt;stdio.h&gt;

int power(int base,int n, double *result);

int main() {
    int no1, no2;


    printf(""Enter two numbers:\n"");
    printf(""If you want to compute x^y enter x y\n"");

    scanf(""%i%i"", &amp;no1, &amp;no2);

    double result;
    int error = power(no1, no2, &amp;result);

    if(error == 0)
        printf(""The value of %i^%i is %f\n"", no1, no2, result);

    return 0;
}

int power(int base, int n, double *result) {

    *result = 1;

    if(n == 0 &amp;&amp; base == 0){
        printf(""Unable to compute 0^0\n"");
        return 1;

    } else if(n == 0 &amp;&amp; base != 0) {
        *result = 1;
         return 0;

    } else if(n&gt;0){
        for(; n&gt;0 ; n--) {
            *result = *result*base;
        }
        return 0;

    } else if(n &lt; 0){
        int temp = -n;

        power(base,temp, result);
        *result = (float) 1.0 / *result;
        return 0;
    }

    return 1;
}
</code></pre>
",0
24572216,24571796,3,"<p>@BartoszMarcinkowski gives you the correct answer, as an alternative (if you can't pass an extra variable) you can return <code>NAN</code> and check the result with <code>isnan()</code>.</p>

<blockquote>
  <p>In computing, NaN, standing for not a number, is a numeric data type
  value representing an undefined or unrepresentable value, especially
  in floating-point calculations.</p>
</blockquote>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

double power(int base,int n);

int main(void)
{
    double f;

    f = power(2, 2);
    if (isnan(f)) {
        printf(""Unable to compute power\n"");
    } else {
        printf(""%f\n"", f);
    }
    return 0;
}

double power(int base, int n) {

    double result = 1;

    if( n == 0 &amp;&amp; base == 0){
        return NAN;
    }
    ...
    return result;
}
</code></pre>
",0
24572242,24571796,0,"<blockquote>
  <p>Note : My answer is in reference to the user's post saying that he is
  a novice at learning C, so I have assumed that he might not have yet
  be comfortable dealing with pointers.</p>
</blockquote>

<p>You can have an error flag in your code that tells the main function that an error has occurred.
You can use a <strong>global</strong> integer, that is common to all functions of your program to inform of errors in code. </p>

<p>After calling the power function, you check whether the error FLAG is set, which means errors have occurred. So you print the error message instead of the result. </p>

<p>What value you should use for showing a error has occurred is arbitrary. In most cases, a non-zero (sometimes negative) value can indicate the specific error. For example:</p>

<p><code>FLAG = -1 might indicate invalid input</code></p>

<p><code>FLAG = -2 might indicate invalid operation</code></p>

<p>And so on. etc. Here I have chosen <code>FLAG = non-zero</code> value to mean error has occurred. </p>

<pre><code>   #include &lt;stdio.h&gt;
double power(int base,int n);
--&gt; char FLAG = 0;

int main() {
    int no1,no2;
    ---- your code ---
    double and = power(no1,no2);
    --&gt; if (char) {
        printf(""error : both values cannot be negative);
        char = 0;
    } else {
        printf(""The value of %i^%i is %f"", no1, no2, ans);
    }    
    return 0;
}

double power(int base, int n) {
    ---- your code ---
    if( n == 0 &amp;&amp; base == 0){
        printf(""Unable to compute 0^0\n"");
    --&gt; FLAG = -1; 
        return 0;
    }
    else if( n == 0 &amp;&amp; base != 0) {
        result = 1;
    }
    else ---- your code ---
}
</code></pre>
",0
22890152,22890114,4,"<p>When you do:</p>

<pre><code>#define green 2, red 3;
</code></pre>

<p>You are defining a macro <code>green</code> that expands to <code>2, red 3;</code>.</p>

<p>What you need to do is:</p>

<pre><code>#define green 2
#define red 3
</code></pre>

<p>But a better way is to avoid macros if you can:</p>

<pre><code>enum { green = 2, red = 3 };
</code></pre>
",0
22890173,22890114,1,"<p>There are various ways you can solve your problem.</p>

<p><strong>Solution 1: Use <code>#define</code> properly</strong></p>

<p>Replace</p>

<pre><code>#define green 2, red 3;
</code></pre>

<p>by</p>

<pre><code>#define green 2
#define red 3
</code></pre>

<p><strong>Solution 2: Use <code>const</code> variables</strong></p>

<p>Replace</p>

<pre><code>#define green 2, red 3;
</code></pre>

<p>by</p>

<pre><code>const int green = 2;
const int red = 3;
</code></pre>

<p><strong>Solution 3: Use an <code>enum</code></strong></p>

<p>Replace</p>

<pre><code>#define green 2, red 3;
</code></pre>

<p>by</p>

<pre><code>enum KNOWN_COLORS { green=2, red };
</code></pre>
",2
22890229,22890114,0,"<p>The <code>#define</code> directive you are will instruct the preprocessor to replace all symbols matching <code>green</code> with the string you have defined, in this case <code>2, red 3;</code></p>

<p>However, there are no <code>green</code> symbols in your file, so the <code>#define</code> will not do anything.</p>

<p>A <code>#define</code> directive will NOT have any effect on variables. You will have to manually check variables to see if they are equal to any constants you care about. Currently your program will not execute any differently than if the <code>#define</code> line were removed. If you want to define a mapping between a string and an integer, you will need to take a different approach.</p>

<p>Also, your color variables need to be defined as character arrays if they are going to hold more than a single character. By specifying <code>%s</code> in scanf, you are storing multiple characters in a single character, which will cause memory corruption.</p>

<p>Here is a corrected version of your program with the color mapping as a function instead.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define MAX_COLOR_STR_LEN 10

int valueFromColor(char const * const color) 
{
  if(strcmp(""green"", color)==0)
    return 2;
  if(strcmp(""red"", color)==0)
    return 3;
  return 0;
}

int main()
{
    char bands;
    char color1[MAX_COLOR_STR_LEN];
    char color2[MAX_COLOR_STR_LEN];
    int mult;


    printf(""Select how many bands the resistor has"");
    printf(""\n A. 4 bands"");
    printf(""\n B. 5 bands"");
    printf(""\n C. 6 bands"");
    scanf(""%c"", &amp;bands);

    switch (bands)

    case 'a':
    case 'A':
      printf(""\nEnter the colors"");
      scanf(""%s %s"", color1, color2);
      mult = valueFromColor(color1) * valueFromColor(color2);
      printf(""%d"", mult);

    getchar();
    return 0;
}
</code></pre>
",2
25678816,25678797,4,"<p>You are modifying <code>p</code> in <code>somefunc</code> but this won't modify <code>p</code> in <code>main</code>. You probably need to pass a pointer to <code>p</code> if you want to modify its value.</p>
",5
25678828,25678797,4,"<p><code>p</code> in <code>main()</code> is a null pointer.  It is passed by value to <code>somefunc()</code>, but that means that the value in the variable <code>p</code> in the function is a copy of the value in <code>p</code> in the main program, not a pointer to <code>p</code> itself.  You change what the copy of <code>p</code> in the function points at; fortunately, it doesn't change what's in the main program.</p>

<p>Then you try to print what's at the position pointed to by the null pointer; this is undefined behaviour and programs typically crash.</p>

<p>If you had managed to change <code>p</code> in the main program, it would be pointing to an automatic local variable in <code>somefunc()</code> that would be out of scope ¡ª which is more undefined behaviour.</p>

<p>This would work:</p>

<pre><code>#include &lt;stdio.h&gt;

int somefunc(char **p);

int main(void)
{
    char *p = 0;
    int x = somefunc(&amp;p);
    printf(""%c\n"", *p);
    return 0;
}

int somefunc(char **p)
{
    static char y = '4';
    *p = &amp;y;
    return 2;
}
</code></pre>

<p>There are many other, possibly better, ways to make this work too.</p>

<hr>

<blockquote>
  <p>I'm still confused on what <code>*p = &amp;y;</code> means. If <code>p</code> in <code>somefunc</code> is a pointer to the pointer <code>p</code>, let's say <code>p2</code> is a pointer to <code>p1</code>, then <code>*p2 = p1</code>, so <code>*p2</code> is <code>p1</code>, which stores <code>&amp;y</code>? Is that the correct way of thinking about this?</p>
</blockquote>

<p>Basically, yes.  First, let's rewrite the code to disambiguate the use of <code>p</code>:</p>

<pre><code>int main(void)
{
    char *p1 = 0;
    int x = somefunc(&amp;p1);
    printf(""%c\n"", *p1);
    return 0;
}

int somefunc(char **ppc)
{
    static char y = '4';
    *ppc = &amp;y;
    return 2;
}
</code></pre>

<p>The variable <code>ppc</code> is a pointer to pointer to <code>char</code> (hence the name <code>ppc</code> ¡ª not a name I'd normally use except for pedagogical purposes).  I'll also rename <code>p</code> in <code>main()</code> to <code>pq1</code>, and introduce <code>char *p2;</code> in <code>somefunc()</code> which is a pointer to <code>char</code>.</p>

<p>Revising your comment in terms of these variables:</p>

<blockquote>
  <p>I'm still confused on what <code>*ppc = &amp;y;</code> means. If <code>ppc</code> in <code>somefunc()</code> is a pointer to the pointer <code>p1</code> in <code>main()</code>, then let's say <code>ppc</code> is a pointer to <code>p1</code>, then <code>*ppc = p1</code>, so <code>*ppc</code> is <code>p1</code>, which stores <code>&amp;y</code>? Is that the correct way of thinking about this?</p>
</blockquote>

<p>And that strongly shows that you're thinking is correct.  One of the design guidelines for the C type nomemclature was that if you write:</p>

<pre><code>SomeType *stp;
</code></pre>

<p>then <code>*stp</code> represents a value of type <code>SomeType</code> ¡ª declaration mimics use.</p>

<p>Now, with <code>ppc</code>, the declaration is <code>char **ppc;</code> and the declaration mimics use rule means that <code>**ppc</code> is a value of type <code>char</code>.  Consequently, it means that <code>*ppc</code> is a value of type <code>char *</code>.  It means that when you write to <code>*ppc</code>, you are modifying the space that <code>ppc</code> points at, and it points at the address of <code>char *p1;</code> in <code>main()</code> in the sample code.</p>
",6
25679122,25678797,2,"<p>Complementing Jonathan's answer, for your question</p>

<blockquote>
  <p>What is the difference between char **p and char p for the function parameter? Why can I pass and modify an array without having to return it, but I have to with a pointer? They are both addresses.</p>
</blockquote>

<p>In <em>C</em>, there's no pass by reference, there's only pass by value i.e. any argument passed to a function is copied to its parameters, but can't be made to refer to the original. This is the reason functions like <code>swap</code> is implemented using pointers. Example</p>

<pre><code>void swap(int *x, int *y)
{
   int t = *x;
   *x = *y;
   *y = t;
}

int a = 0, b = 1;
swap(&amp;a, &amp;b);
</code></pre>

<p>Here <code>&amp;a</code> is a pointer whose value is copied onto <code>x</code>, thus it is pass by value (sometimes, incorrectly, called pass by reference). So I should be able to do the same when modifying pointers too, right?</p>

<p>Nope. Since a pointer is already pointing to something, making it point another thing needs another level of indirection. An analogy would be: you know somewhere a direction sign is pointing towards your home, by just knowing where it's pointing to (home), would you be able to change the direction it's pointing? No, you'd have to know where the sign is to go there and make it point in another direction.</p>

<p>Likewise, say if a variable lives at level 0 then to edit it, we go to a level further i.e. level 1 to modify it (from outside). This concept can be applied recursively; so to edit a variable at level 1, we've to go to level 2 to modify them from outside and so on. Pictorially</p>

<pre><code>         type:          int*         int         int*
variable name:          ptr           a          pptr
                      --------     -------     --------
        value:        | 1000 | --&gt; |  1  | &lt;-- | 1000 |
                      --------     -------     --------
      address:          2000        1000         2400
</code></pre>

<p>Notice that <code>pptr</code> can't change where <code>ptr</code> is pointing to since <code>pptr</code> too is pointing at what <code>ptr</code> is pointing at <code>a</code>. However</p>

<pre><code>      int**        int*         int
      pptr         ptr           a
    --------     --------     -------
    | 2000 | --&gt; | 1000 | --&gt; |  1  |
    --------     --------     -------
      2400         2000        1000
</code></pre>

<p>now <code>pptr</code> (<code>int**</code>) is in a position to modify where <code>ptr</code> (<code>int*</code>) is pointing to. If you'd to modify <code>pptr</code> then you to go another level higher <code>ppptr</code> (<code>int***</code>) and so on.</p>
",0
21781353,21780403,1,"<pre><code>FILE *file = fopen(name, ""w"");
char buff[BUFSIZ];
while(fgets(buff, sizeof(buff), stdin) &amp;&amp; strcmp(buff, ""exit\n"")){
    fprintf(file, ""%s"", buff);
}
fclose(file);
</code></pre>
",3
21780514,21780403,-1,"<p>You need a console input function like <a href=""http://www.cplusplus.com/reference/cstdio/scanf/"" rel=""nofollow"">scanf</a> to <strong>read from the standard input and then store the read input into an array</strong> or something similar:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(int argc, char* argv[])
{
  char text[100];   
  do {
    printf(""Enter text : \n"");                              
    scanf_s(""%s"", text, 100);
  } while(strcmp(text, ""exit""));

  return 0;
}
</code></pre>

<p>in your code</p>

<pre><code>strcmp(""/stdin"", ""exit"")
</code></pre>

<p>is basically asking </p>

<blockquote>
  <p>are '/stdin' and 'exit' the same characters?</p>
</blockquote>

<p>and the answer will always be the same: no. And the loop will always be entered and never left.</p>
",5
21789034,21788882,0,"<p>Try this:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main() {
    char *string = NULL;
    char *newstring = NULL;
    char c = '\0';
    unsigned int count = 0;

    while(c != 'Q'){
        c = getc(stdin);
        if(string == NULL){
            string = (char *) malloc(sizeof(char)); // remember to include stdlib.h
            string[0] = c;
        }
        else{
            newstring = (char *) realloc(string, sizeof(char)*count);
            string = newstring;
            string[count] = c;
        }
        count++;
    }

    string[count-1] = '\0';  // remove the Q character
    fprintf(stderr,""here you are: %s"",string);
    free(string); // remember this!
    return 0;
}
</code></pre>
",0
21789109,21788882,0,"<p>If you will know at the start of runtime how many keys you'll enter, you can have it ask first for the number of keys and then for the individual characters, as in the untested snippet below.  </p>

<p>Otherwise, you have to set some real-world maximum (e.g. 10000) that will never be reached, or, if that's not possible, set a per-array maximum and make provisions for rollover into a new array.  That last option really is the same (eventually bounded by memory) but gives you a larger maximum.</p>

<pre><code>char *mychars;
int numchars;

printf(""Please enter the total number of characters:\n"");
if (scanf(""%d"", &amp;numchars) == NULL) {
  printf(""couldn't read the input; exiting\n"");
  exit(EXIT_FAILURE);
}

if (numchars &lt;= 0) {
  printf(""this input must be positive; exiting\n"");
  exit(EXIT_FAILURE);
}

mychars = (char *) malloc (numchars * sizeof(char));

int current_pos = 0;
printf(""Enter a digit and hit return:\n"");

while (scanf(""%c"", &amp;mychars[current_pos]) != NULL &amp;&amp; current_pos &lt; numchars) {
  current_pos++;
  printf(""Enter a digit and hit return:\n"");
}
</code></pre>
",0
21789270,21788882,0,"<p>Repetitive calls to <code>realloc()</code> will meet the need.</p>

<p>Double <code>realloc()</code> size as needed to avoid O(n) calls.</p>

<pre><code>char *GetQLessString(void) {
  size_t size_alloc = 1;
  size_t size_used = size_alloc;
  char *a_string = malloc(size_alloc);
  if (a_string == NULL) {
    return NULL; // Out  of memory
    }

  char ch;
  while(scanf(""%c"", &amp;ch) == 1 &amp;&amp; (ch != 'Q')) {
    size_used++;
    if (size_used &gt; size_alloc) {
      if (size_alloc &gt; SIZE_MAX/2) {
        free(a_string);
        return NULL; // Too big - been typing a long time
      }
      size_alloc *= 2; 
      char *new_str = realloc(a_string, size_alloc);
      if (new_str == NULL) {
        free(a_string);
        return NULL; // Out  of memory
      }
      a_string = new_str;
    }
    a_string[size_used - 2] = ch;
  }

  a_string[size_used - 1] = '\0';
  return a_string;
}
</code></pre>

<p>Code could do a final <code>realloc(a_string, size_used)</code> to trim excess memory allocation.<br>
Calling routine needs to call <code>free()</code> when done with the buffer.<br>
The following would be cleaner.</p>

<pre><code>int ch;
while((ch = fgetc(stdin)) != EOF &amp;&amp; (ch != 'Q')) {
</code></pre>
",0
26223348,26223316,1,"<p>You want to use %u for unsigned int:</p>

<pre><code>printf(""%u\n"", x);
printf(""%u\n"", y);
</code></pre>
",1
29216469,29215955,0,"<p>The <code>waitpid()</code> function's third argument is a bitmask of options, one of which is (symbolically) <code>WNOHANG</code>.  If you include that among the options then <code>waitpid()</code> will not block, even if the specified child is still running.  You can then determine whether the child process has, in fact, terminated by testing the value returned via the second argument:</p>

<pre><code>if (WIFEXITED(i)) {
    /* ... handle normal exit ... */
else if (WIFSIGNALED(i)) {
    /* ... handle exit because of a signal ... */
}
</code></pre>

<p>You cannot get the child's exit status or clean it up until it has in fact exited, however, so it is only useful for the parent to do this if it has other work to perform while the child runs.  In that case, it will need to periodically perform a <code>waitpid()</code> until it finds that the child has terminated, or else it needs some other way for the child to tell it when it's done (signal, I/O, IPC).</p>
",0
21031182,21031082,0,"<p>You should use <code>strcmp</code> instead of comparing two array pointers.</p>

<p>In <code>searchCodop</code> instead of </p>

<pre><code>if(ptr-&gt;code == codop)
</code></pre>

<p>do</p>

<pre><code>if (!strcmp(ptr-&gt;code, codop))
</code></pre>
",3
21031258,21031082,0,"<p>You are calling pointer as pass by value, instead use call by reference. For this, use pointer to pointer. Like that:</p>

<p>In main change</p>

<pre><code>CodopsList(head);
</code></pre>

<p>with</p>

<pre><code>CodopsList(&amp;head);
</code></pre>

<p>And,</p>

<p>Change function</p>

<pre><code>void CodopsList(COD *head)
</code></pre>

<p>with</p>

<pre><code>void CodopsList(COD **head)
</code></pre>

<p>In function CodopsList use head as *head</p>
",0
33515556,33515528,4,"<blockquote>
  <p>In the C and C++ programming languages, the comma operator
  (represented by the token ,) is a binary operator that evaluates its
  first operand and discards the result, and then evaluates the second
  operand and returns this value (and type).</p>
</blockquote>

<p><a href=""https://en.wikipedia.org/wiki/Comma_operator"" rel=""nofollow"">https://en.wikipedia.org/wiki/Comma_operator</a></p>

<p>So, the result of the <code>(4, 5)</code> expression will be <code>5</code>.</p>
",3
33539254,33539054,5,"<p>C uses the minus character (ASCII 45) for the negative sign. Use the same character in the <code>printf</code> statement as you do for unary minus.</p>

<p>You are currently using the <em>en dash</em> which will not be outputted correctly in a console which only supports UTC-7 encoding.</p>

<p>By the way, is this a quiz?</p>
",2
27541731,20625693,3,"<p>You've almost certainly saved your file with one of the Unicode encodings such as <code>UTF-16</code>.</p>

<p>This assigns 16 bits to each character meaning that if you hes-dump your code, you'll see something like:</p>

<pre><code>0000 - 23 00 69 00 6e 00 63 00 - 6c 00 75 00 64 00 5 00 - #.i.n.c.l.u.d.e.
</code></pre>

<p>at the start.</p>

<p>A compiler that <em>doesn't</em> understand UTF-16 will then probably complain bitterly about finding null bytes amongst all the real characters, just as yours seems to have done.</p>

<p>To fix it, either save the file in a more conventional form (such as ASCII) or find a compiler that can handle it. The former is probably the easier path to take provided you don't actually <em>need</em> all those non-ASCII Unicode characters.</p>
",0
29176824,29176524,2,"<p>The line</p>

<pre><code>printf(""ASCII value of %c = %d"",c,c);
</code></pre>

<p>will show the value of <code>c</code> in two ways. Firstly as a character, secondly as a number.</p>

<p>Whether or not it is an ASCII value, depends on what <code>c</code> is, because the ASCII standard does not encompass <em>all</em> of the 256 values representable by <code>char</code> or even <code>unsigned char</code>. That depends on system settings such as code page, language, etc. Moreover, not all of the ASCII characters are even printable - but some terminal or console outputs will use a printable representation of the number rather than using it as a control - although <code>7</code> might ring your bell!</p>
",0
23070642,23070610,2,"<p>this is what you want... loop over all of them.</p>

<pre><code>for(i=0;i&lt;6;i++)
</code></pre>
",0
23070709,23070610,0,"<p>This is because the elements of the array are numbered from 0 to 5, not 1 to 6.</p>

<p>So since you defined the variables in this order:</p>

<pre><code>int     _min;
int     _max;     &lt;----
int     input[6];
</code></pre>

<p>...when you write to <code>input[6]</code>, you are actually writing to the memory just after <code>input[5]</code>, which is occupied by <code>_max</code>. I guess if you wrote to <code>input[7]</code>, you'd see the same thing happening to your <code>_min</code>.</p>

<p>(Note, however, that actual variable allocation is compiler and platform dependant. Where data ends up when it <strong>overflows the buffer</strong> is not so easy to tell).</p>
",0
23102575,23102484,1,"<p>You're not actually <em>calling</em> the functions, you are just <em>declaring</em> them e.g.:</p>

<pre><code>if (i==1) {
    Player* playGame(Player *computer, Player *human, Card *deck);
    int testmethod();
}
</code></pre>

<p>should be:</p>

<pre><code>if (i==1) {
    player = playGame(computer, human, deck);
    testmethod();
}
</code></pre>

<p>(obviously <code>player</code>, <code>computer</code>, <code>human</code>, <code>deck</code> will need to have been previously defined/initialised)</p>
",6
34179161,34179127,1,"<p>There should be a comma after <code>false</code>, not a semicolon.</p>

<p>And a comma after <code>true</code> is optional.</p>

<p>You don't even need to Google for it, just search this site. E.g. <a href=""https://stackoverflow.com/questions/1102542/how-to-define-an-enumerated-type-enum-in-c#1102556"">How to define an enumerated type (enum) in C?</a></p>
",1
34179163,34179127,3,"<p>Use comma after enum constant.</p>

<pre><code>enum a { 
    false,
    true
};
</code></pre>
",0
34179184,34179127,1,"<pre><code>typedef enum a { 
    false,
    true
} a;
</code></pre>

<p>is a succinct way of doing this. Note the comma after <code>false</code>, and the use of <code>typedef</code>.</p>

<p>I wouldn't recommend using <code>false</code> and <code>true</code> as enumerated names though; especially if you intend to port your code to C++.</p>
",0
24593754,24593717,4,"<p>This depends on the implementation of the program. <kbd>Ctrl</kbd>+<kbd>D</kbd> writes <code>EOF</code> to <code>stdin</code>, so it's up to the programmer to decide what to do with that input.</p>
",5
33559820,33559076,0,"<pre><code>&gt; Use queue.
&gt; 1. create the queue and call the method that will produce(submit) data to the queue.
&gt; 2. create a new thread that will read the data from the queue.
&gt; 3. use mutex or any else mechanism to protect the queue heads. Else you can go lock free queue implementation.
&gt; 
&gt; Let me know if you need any code.
</code></pre>
",0
33559320,33559076,1,"<p>( <strong>THIS ANSWER IS VALID AS LONG AS YOU ARE ON A UNIX/UNIX-LIKE PLATFORM!</strong> )</p>

<p>Although by definition the existence of threads <em>implies</em> shared memory, you can go the weirdo way and use pipes instead.</p>

<p>The function <code>pipe()</code> is declared in <code>&lt;unistd.h&gt;</code>. It takes a <code>int[2]</code> as parameter, and returns an error code <code>int</code> (<code>0</code> is success, failure otherwise). If successful, the function creates two new file descriptors, one for reading and other for writing. Whenever you write in the write-only file descriptor, that data arrives at the read-only file descriptor! That mechanism is known as a <em>pipe</em>. If you try to read in the read-only file descriptor, but the data is still not there, the <code>read()</code> function will simply block (unless instructed to do otherwise by means of <code>fcntl()</code>).</p>

<p>For any <code>int fd[2]</code>, <code>pipe(fd)</code> sets <code>fd[0]</code> to the read end and <code>fd[1]</code> to the write end.</p>

<p>Now, what you can do is call <code>pipe</code> before spawning the second thread, and pass <code>fd[0]</code> as an argument to it, so it can read the data! Let's see an example (note, <strong>no error checking</strong>!)...</p>

<pre><code>#include &lt;unistd.h&gt;

typedef struct {
    UINT32  ot_id;
    BOOLEAN result;
} RESULT;

void secondThread(int readDescriptor) {
    RESULT result;
    read(readDescriptor, &amp;result, sizeof(RESULT));

    // Do something with that...

    close(readDescriptor);
}

int main() {
    int fd[2];
    pipe(fd);

    spawnTheSecondHolyThread(secondThread, fd[0]);

    RESULT result;

    // Calculate the result...

    write(fd[1], &amp;result, sizeof(result));
    close(fd[1]);

   joinTheSecondThread();
    return 0;
}
</code></pre>
",2
22510175,22510131,3,"<p>You are using wrong specifier for <code>long</code> which invokes <strong>undefined behavior</strong>. Use <code>%ld</code> instead.</p>
",3
22510200,22510131,2,"<p>You should use <code>%ld</code> to <code>printf</code> a <code>long</code> value (<code>%d</code> is for <code>int</code> instead).</p>

<p>For <a href=""http://en.cppreference.com/w/c/io/fprintf"" rel=""nofollow""><code>printf()</code></a>:</p>

<blockquote>
  <p>arguments specifying data to print. <strong>If any argument is not the type expected by the corresponding conversion specifier, or if there are less arguments than required by format, the behavior is undefined</strong>. If there are more arguments than required by format, the extraneous arguments are evaluated and ignored</p>
</blockquote>
",1
22510217,22510131,0,"<p>Your debugger should be able to provide a backtrace so you can see what function is on top of the stack  ( ie currently running ) at time of the segfault.  In gdb, this would be the <code>bt</code> commnd.</p>
",1
22114518,22114433,5,"<p>You could simply do this:</p>

<pre><code>void main()
{
    char c;
    int a=10,b=20,sum;
    scanf(""%c"",&amp;c);
    sum=(c=='+')?(a+b):((c=='-')?(a-b):((c=='*')?(a*b):0));
    printf(""%d"",sum);
}
</code></pre>

<p>Don't be confused with the line <code>sum=(c=='+')?(a+b):((c=='-')?(a-b):((c=='*')?(a*b):0));</code>. It actually does this:</p>

<pre><code>if(c=='+')
    sum=a+b;
else
{
    if(c=='-')
        sum=a-b;
    else
    {
        if(c=='*')
            sum=a*b;
        else
            sum=0;
    }
}
</code></pre>

<p>The operator (?:) is called Conditional (ternary) operator. </p>

<p>Syntax:</p>

<pre><code>condition ? expr_if_condition_is_true : expr_if_condition_is_false
</code></pre>

<p>If the condition is true, expression1 will be returned. Else expression2 will be returned. As you can see, there are 3 nested conditional operators are used in that line.</p>

<p>Read more about conditional operator <a href=""http://msdn.microsoft.com/en-us/library/e4213hs1.aspx"" rel=""nofollow noreferrer"">here</a>.</p>
",2
22114628,22114433,1,"<p>I'm sorry, but you can't convert a <code>char</code> to an operator. If you want to take different actions depending on the input, you <strong>must</strong> branch.</p>

<p>You can make your switch more compact though, as noted by Matteo Italia and Jens Gustedt.</p>

<pre><code>scanf(""%c"",&amp;c);
switch(c) {
   case '+': sum = a + b; break;
   case '-': sum = a - b; break;
   case '*': sum = a * b; break;
   default: break; /* invalid op? */
}
</code></pre>
",2
22114661,22114433,4,"<p>I'm not saying it's a <em>good</em> way of doing things, but you could have something like:</p>

<pre><code>#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef int (*fn)(int, int);
int add(int a, int b) { return a + b; }
int subtract(int a, int b) { return a - b; }

int main(void) {
    int a = 10, b = 20, sum;
    char c;
    fn f[256] = {NULL};

    f['+'] = add;
    f['-'] = subtract;
    // etc

    scanf(""%c"", &amp;c);
    fn fn = f[(int)c];
    assert(fn != NULL);
    sum = fn(a, b);
    printf(""%d\n"", sum);

    return EXIT_SUCCESS;
}
</code></pre>

<p>Realistically, though, just go with a <code>switch</code> statement.</p>
",1
22114821,22114433,2,"<p>Impossible is usually too strong a word when it comes to C. And it is always too strong when it comes to functional programming.</p>

<pre><code>#include &lt;stdio.h&gt;

int (*ops[5])(int,int);
int mul(int f, int s)  { return f*s; }
int plus(int f, int s) { return f+s; }

int main(int argc, char** argv)
{
  ops[0] = &amp;mul;
  ops[1] = &amp;plus;

  printf(""%u + %u = %u\n"", 5, 10, ops['+' - 42](5, 10));
  return 0;
}
</code></pre>

<p>ops is an array of function pointers (each takes two ints and returns one, which is the type of the standard operations on ints). The ASCII code for the '*' is 42 (what a coincidence!), '+' is 43 and so on. ops[0] = &amp;mul initializes ops to contain the address of the function which multiplies two numbers. Then in the printf ops is indexed by the character code of the operator you want to apply minus the index of the first operator, ie the appropriate function is invoked and the required arguments are passed. Unfortunately, the interval for the four ASCII codes for the four basic artihmetic operators are not continuous (44 is not an operator), so you need 5 elements for the array. The technique is called a lookup table, and it could be made much nicer if I knew how to take the address of the built in + function instead of defining a wrapper for it.</p>
",0
22114453,22114433,0,"<p>That's not possible in C/C++ without some switch/if checks.</p>
",6
22121292,22114433,2,"<pre><code>char c;
int a=10, b=20, result=0;

scanf(""%c"", &amp;c);
c=='+' &amp;&amp; (result = a + b);
c=='-' &amp;&amp; (result = a - b);
c=='*' &amp;&amp; (result = a * b);
printf(""%d"", result);
</code></pre>
",0
22120225,22120165,2,"<p>It's not clear what you are asking here, but let's assume the question is</p>

<blockquote>
  <p>Why did I get the error <code>[Warning] passing arg 1 of 'swap' from incompatible pointer type</code></p>
</blockquote>

<p>The reason is because you are calling <code>swap</code> wrongly. You call it two ways:</p>

<pre><code>swap((&amp;board), (&amp;i), (&amp;i + 1));
</code></pre>

<p>and</p>

<pre><code>swap(&amp;board[], &amp;(i), &amp;(i - 1));
</code></pre>

<p>But <code>board</code> is declared as <code>char* board[]</code> in both cases, so all you need to do is:</p>

<pre><code>swap(board, ... (whatever) ...);
</code></pre>
",0
23117610,23117521,3,"<p>You said it yourself. You have two variables named <code>t</code> with different scope.</p>

<p>The <code>double t</code> you declared has the scope of the block that executes inside of the while loop. The conditional in the while loop uses the <code>t</code> that is declared in the scope surrounding the while loop (the <code>int t</code>) which is never modified (because the loop hides <code>t</code> and modifies the double t) and so it never reaches 0.</p>

<p>Here are some points about scope of variables in C:</p>

<ul>
<li>blocks inherit all global variables</li>
<li>variables declared inside a block are only valid inside the block</li>
<li>blocks can be nested</li>
<li>a nested block inherits the variables from the outer block,</li>
<li>variables may be declared in a nested block to hide variables in the outer block (such as in your case)</li>
</ul>

<p><strong>EDIT</strong></p>

<p>As @pmg suggested, here are a couple of extra points:</p>

<ul>
<li>a hidden variable cannot be accessed at all, except through use of pointers created when it was still visible</li>
<li>although strictly speaking, hiding variables is not an error, it's almost never a good thing and most compilers will issue warnings when a variable is hidden!</li>
</ul>
",1
23117623,23117521,1,"<blockquote>
  <p>Can anyone care to explain why is this happening?</p>
</blockquote>

<p>There are two variables in your program called t. One is an <code>int</code>, at the scope of main, and one is a <code>double</code>, in the scope of the while loop. Inside the while loop the double t is hiding the int t, and your scanf is setting the double t.</p>

<blockquote>
  <p>How does the while loop get terminated there?</p>
</blockquote>

<p>The program can't be terminated from inside the while loop as written.</p>
",0
23117643,23117521,0,"<p>When the statement <code>t--</code> is executed, it refers to the (<code>double t</code>) variable declared earlier in the same block, so your <code>int t</code> in the outer block scope, which is shadowed by the <code>double t</code>, never gets decremented.</p>
",2
23117672,23117521,1,"<pre><code>while(t&gt;0)//int t;
{
    {
        double t;
        scanf(""%lf"",&amp;t);
        printf(""%lf\n"",t);
    }
    t--;
}
</code></pre>
",0
24091095,24091036,5,"<p>A few notes:</p>

<p>The argument to <code>malloc()</code> is declared to be <code>size_t</code>, therefore the <code>size</code> parameter to <code>CountMalloc()</code> should also be <code>size_t</code>.</p>

<p>You don't check the result of <code>malloc()</code> to see if the allocation succeeded.  Consider doing this instead:</p>

<pre><code>void * CountMalloc(size_t size)
{
    void * allocation = malloc(size);
    if (allocation) {
        Totalmem += size;
    }
    return allocation;
}
</code></pre>

<p>However, note that the total amount of memory allocated is likely to be higher.  Most <code>malloc()</code> implementations allocate more memory than you request so that they can store some information about the allocation prior to the location in memory that it returns.</p>

<p>Otherwise, I see no serious problems that would prevent the code from having the effect you intended.</p>
",5
24092276,24091036,0,"<p>While your code will keep track of the total amount of memory request via <code>malloc()</code>, it isn't really keeping track of the total amount of memory used by the objects that are returned.  Most allocators won't return objects of arbitrary sizes, but rather have pools of fixed sized objects (4 bytes, 8 bytes, etc.) and return the smallest object that can meet the size requested.</p>

<p>Even if it would allow objects of arbitrary size, it would still often round up the size of the memory block returned, depending on if the hardware allowed for byte or word addressing, or to maximize object reusabilty.</p>

<p>Finally, like I stated in a comment to another answer, the object will often have a hidden header that stores the size of the object, so that a subsequent <code>free()</code> can know how large a block is being returned.</p>
",0
27119963,27119756,1,"<pre><code>// Create a char array to store a word
char word[100];
// Stop when fscanf returns 0
while(fscanf(f1, ""%s"", word)==1)
{
    // print the word
    printf(""%s "",word);
    // Increment count
    count ++;
}
// Print count
printf(""%d\n"", count );
</code></pre>

<p>Remember it assumes that no word is longer than 100 characters since <code>fscanf</code> does't check for buffer overflow</p>
",0
34259049,34259000,5,"<p><strong>AAAAAAAAAAAAAAAAAAAA</strong> has size 20. You are then using <code>strcpy</code> to copy it to an char array of size 16. Try increasing your password_buffer size.  </p>

<blockquote>
  <p>To avoid overflows, the size of the array pointed by destination
  shall be long enough to contain the same C string as source (including
  the terminating null character), and should not overlap in memory with
  source.</p>
</blockquote>

<p><a href=""http://www.cplusplus.com/reference/cstring/strcpy/"">http://www.cplusplus.com/reference/cstring/strcpy/</a></p>
",2
34259059,34259000,3,"<p>Because you are copying the input into a buffer that is too small (and for no reason). Your method could be implemented (without overflow) like</p>

<pre><code>int check_authentication(const char *password) {
    size_t len = strlen(password);

    return strncmp(password, ""brillig"", len) == 0 ||
           strncmp(password, ""outgrabe"", len) == 0;
}
</code></pre>

<blockquote>
  <p>I understand it overflows the buffet, but why would it cause access granted? (auth_flag >0)</p>
</blockquote>

<p>Because <code>auth_flag</code> is the next <code>int</code> in memory after <code>char password_buffer[16];</code>. With some compilers (and operating systems), if you overflow <code>password_buffer</code>, there is a high probability that you modify <code>auth_flag</code>.</p>
",4
34260045,34259000,1,"<p>The memory is stored in the stack in a consecutive manner, 
so there's a char[16] and an int that indicates whether the authentication passed successfully.</p>

<p>When you pass in a pointer to a buffer and copies it without boundary checking the local buffer, you risking overflowing your buffer and rewriting your stack variables.</p>

<p>When you input 'A' * 20, the first 16 'A' went into the buffer, and the remaining 4 'A's went into the int (usually sizeof(int) is 4 bytes).</p>

<p>So now, your int is not 0, it's:
auth = 0x41414141 
since the ASCII code of 'A' is 0x41.</p>

<p>There's a really great article related to this - 
<a href=""http://insecure.org/stf/smashstack.html"" rel=""nofollow"">http://insecure.org/stf/smashstack.html</a></p>

<p>It lays out the basics of stack overflows and gets a little more advanced later on.</p>
",0
22518215,22518059,0,"<p>Normally you don't want to include <code>.c</code> implementation files.  The normal thing to do is have two source files that you build into objects:</p>

<pre><code>cc -o file1.o file1.c
cc -o file2.o file2.c
</code></pre>

<p>And then link them into an executable at the end:</p>

<pre><code>cc -o example file1.o file2.o
</code></pre>

<p>To allow calling functions between the two <code>.c</code> files, you create a header (<code>.h</code>) file that has function declarations for everything you're interested in sharing.  For you, that might be something like <code>header.h</code>, containing:</p>

<pre><code>void calcTax(void);
float calcfed(void);
float calcssi(void);
</code></pre>

<p>Then, just <code>#include ""header.h""</code> from the implementation files where you need to know about those functions.</p>
",7
22518252,22518059,5,"<p>Normally, when you want a function in one compilation unit to call a function in another compilation unit, you should create a header file containing the function prototypes.  The header file can be included in both compilation units to make sure that both sides agree on the interface.</p>

<p>calctax.h</p>

<pre><code>#ifndef calctax_h_included
#define calctax_h_included

void calctaxes(void);
/* any other related prototypes we want to include in this header */

#endif
</code></pre>

<p>Note that <code>extern</code> is not required on functions, only global data.  Also, since the function takes no arguments, you should put <code>void</code> in the argument list, and you also need a semi-colon at the end of the prototype.</p>

<p>Next, we can include this header file in the .c file that implements the function:</p>

<p>calctax.c</p>

<pre><code>#include ""calctax.h""

void calctaxes(void)
{
    /* implementation */
}
</code></pre>

<p>Finally, we include the same header file in our main .c file that calls the function:</p>

<p>main.c</p>

<pre><code>#include ""calctax.h""

int main(int argc, char **argc)
{
    calctax();
    return 0;
}
</code></pre>

<p>You can compile and link these together with</p>

<pre><code>% gcc -o main main.c calctax.c
</code></pre>
",0
21019591,21019568,4,"<p>Change <code>const int n; to int n;</code><br>
<code>const int n;</code> should be initialized during definition time. You declared n as const int and you are trying to store data in to that taking from input.</p>
",0
21019597,21019568,7,"<p>You declared your variable length array <code>ave</code> at wrong place. Declare it after getting the input <code>n</code>. And declare <code>n</code> as <code>int</code> instead of <code>const int</code> (otherwise modifying a <code>const</code> qualified type objects invokes <strong>undefined behavior</strong>).  </p>

<pre><code>int n;
float max,min;
int i,x=0,z=0;
printf(""How many numbers do you want to enter?\n"");
scanf(""%d"",&amp;n);  
float ave[n];
</code></pre>
",1
21019633,21019568,2,"<p>The problem is that you declare</p>

<pre><code>float ave[n]
</code></pre>

<p>before you give <em>n</em> a value. So <em>n</em> == 0.</p>

<p>To fix it, give <code>ave[]</code> a bigger fixed size OR allocate memory to it after reading <em>n</em>.</p>
",1
21019651,21019568,3,"<p>You have two cases of undefined behavior. The first is that you try to modify a constant (<code>n</code> is a constant and should not be modified). The second is that when you declare the array you use the uninitialized <code>n</code> which will be zero, and therefore create a zero-length array which you then continue to write into.</p>
",1
21787854,21787792,5,"<pre><code>for(int i=0x00;i&lt;=0xA;++i){
   for(int j=0x00;j&lt;=0xA;++j){
       for(int k=0x00;k&lt;=0xA;++k){
          someFunction(i,j,k);
       }           
   }
}
</code></pre>
",2
21788356,21787792,2,"<p>A more generic solution would be something like</p>

<pre><code>someRecursiveFunction( int *arr, int curbyte, int min, int max)
{
 int n;
 if( curbyte == 0 ) someFunction( arr );
 else for( n = min; n &lt;= max; n++ ) {
  arr[curbyte-1] = n;
  someRecursiveFunction( arr, curbyte-1, min, max );
 }
}
</code></pre>

<p>and then in your main:</p>

<pre><code>someRecursiveFunction( array, 3, 0, 0xA );
</code></pre>
",0
22888402,22888331,1,"<p>This code reads a char from keyboard (<code>stdin</code>) using <code>scanf()</code>, stores it in byte-sized variable <code>c</code> of type <code>char</code>, and then prints its ASCII decimal value as an <code>int</code> to <code>stdout</code> :</p>

<pre><code>char c;    
scanf(""%c"", &amp;c);    
printf(""%d"", c);
</code></pre>
",7
22888425,22888331,0,"<p>If you want to output the ASCII value, simply <code>printf()</code> with the <code>%d</code> format string.</p>

<pre><code>char ch = 'a';
printf(""%d"", a); // should be 97
</code></pre>
",0
30141871,30141751,2,"<p>You can't cast a non-pointer function return value into a pointer at all. Think about it, where would this pointer point to?</p>

<p>You can, however, save the result to a variable and have a pointer to it.
For example,</p>

<pre><code> char tmp = (char) foo();
 char * ptr = &amp;tmp;
</code></pre>

<p>Edit:</p>

<p>As another answer said, if you want to use <code>strcasecmp</code> you would need a <code>char</code> array where the last byte is the null terminator.</p>
",3
30141882,30141751,2,"<p>To achieve what you want, use the following code: </p>

<pre><code>char array [2];
array [0] = (char) foo ();
array [1] = '\0';
...
... strcasecmp (array, ...);
</code></pre>

<p>This builds an array containing a string of a single character which you can then use. </p>
",0
21036520,21036509,4,"<p>The standard C library functions are provided in libraries along with your compiler and the rest of your toolchain.  For unix-like systems, that's usually in libraries called <code>libc</code> and <code>libm</code>.  <code>libc</code> is normally linked with your program by default.  <code>libm</code> sometimes is and sometimes isn't.</p>
",3
28192759,19537564,1,"<p>Of course you could compile graphics.h with <code>gcc</code> but you have to follow certain steps.</p>

<ol>
<li>Get the files <code>graphics.h</code> from <a href=""http://nikhilbhardwaj.in/resources/graphics/graphics.h"" rel=""nofollow"">graphics</a> and <code>libbgi.a</code> from <a href=""http://nikhilbhardwaj.in/resources/graphics/libbgi.a"" rel=""nofollow"">library</a>.</li>
<li>Copy the <code>graphics.h</code> file to the <code>include</code> directory of your gcc compiler.</li>
<li>Copy the <code>libbgi.a</code> file to the <code>lib</code> directory of your gcc compiler.</li>
<li><p>Afterwards execute the code:</p>

<p><code>C:\&gt;gcc your_filename.c -lbgi -lgdi32 -lcomdlg32 -luuid -loleaut32 -lole32</code></p>

<p>Also if you are executing a c++ program use <code>g++</code> instead of <code>gcc</code>.</p></li>
</ol>
",0
22421526,22421214,1,"<p><code>int *fd</code> is a dimension array's pointer, so you can not reference its item as tow dimension array like this:  <code>fd[i][0]</code>.</p>

<p>Again <code>fd[4][2]</code> is wrong for array access because of <code>[4][2]</code> is out of bound.</p>
",4
22435838,22435806,1,"<p>You need to include the <code>&lt;stdio.h&gt;</code> header, and also, main needs a return type (int) and a return value. Changing the program to this will make it compile (at least it did using GCC) and run:</p>

<pre><code>#include &lt;stdio.h&gt;
int main(int argc, char *argv[])
{

    int i;

    for(i=1;i++&lt;=5;printf(""%d"",i));

    return 0;
}
</code></pre>

<p>The quotes you used in the <code>¡°%d¡±</code> are illegal too, use normal quotes: <code>""%d""</code>.</p>

<p>Apart from that, doing the <code>printf</code> inside the loop head might be legal, but it's pretty bad style. Usually in a for-loop you would have have <em>initialization;condition;increment(or decrement or w/e)</em> in the head, and do side-effects in the body of the statement.</p>
",7
22435842,22435806,0,"<p>I would try writing the for loop as:</p>

<pre><code>for(i=1;i &lt; 6;i++) { printf(¡°%d¡±,i); }
</code></pre>
",1
31877906,31877772,6,"<p>In this expression:</p>

<pre><code>(getFreeSystemMemory()/1024*1024)/(getTotalSystemMemory()/1024*1024)
</code></pre>

<p>All subexpressions are of an integral type, so the result is also of an integral type.  The division operation is also integer division rather than floating point division because of that.  You are then trying to print that integral type as a float, which is <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"">undefined behavior</a>.</p>

<p>You need to cast at least part of the above expression to a floating point type so that the rest of the expression is done in floating point:</p>

<pre><code>((double)getFreeSystemMemory()/1024.0*1024.0)/((double)getTotalSystemMemory()/1024.0*1024.0)
</code></pre>

<p>That should print the result you expect.</p>
",0
31879292,31877772,0,"<p>If you are just trying to remove the negative sign, you could check if the output is negative and negate if so or use abs().</p>

<pre><code>float z = (float)(x/y);
if( z &lt; 0){
   z = -z;
}
</code></pre>

<p>Also, it is worth noting that your final statement is unnecessary:</p>

<p><code>getFreeSystemMemory()/1024*1024)/(getTotalSystemMemory()/1024*1024</code></p>

<p>Consider this</p>

<pre><code>x = getFreeSystemMemory();
y = 1024^2;
z = getTotalSystemMemory();

//then your statement becomes 
(x / y) / (z / y);
//which equals
(x / y) * (y / z);
//which equals
(x / z);
</code></pre>
",1
31894210,31877772,1,"<p>after applying the needed corrections to the code, so it cleanly compiles, this is the result:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;unistd.h&gt;




size_t getTotalSystemMemory(){
    long pages = sysconf(_SC_PHYS_PAGES);
    long page_size = sysconf(_SC_PAGE_SIZE);
    return pages * page_size;
}

size_t getFreeSystemMemory(){
    long pages = sysconf(_SC_AVPHYS_PAGES);
    long page_size = sysconf(_SC_PAGE_SIZE);
    return pages * page_size;
}



int main( void )
{


    printf(""Currently total memory: %zd\n"",getTotalSystemMemory());
    printf(""Currently avail memory: %zd\n"",getFreeSystemMemory());

    printf(""Percentage: %lu %%\n"",( ((getFreeSystemMemory()/1024)*1024)/((getTotalSystemMemory()/1024)*1024)));


}
</code></pre>

<p>running that code on my computer results in:</p>

<pre><code>Currently total memory: 7167004672
Currently avail memory: 3325980672
Percentage: 0 %
</code></pre>

<p>The 0 percent is because of the integer divide.</p>

<p>To achieve a more useful percentage, change the print statement to:</p>

<pre><code>printf(""Percentage: %f %%\n"",( ((getFreeSystemMemory()/1024.f)*1024.f)/( (getTotalSystemMemory()/1024.f)*1024.f)));
</code></pre>

<p>which results in:</p>

<pre><code>Currently total memory: 7167004672
Currently avail memory: 3278430208
Percentage: 0.457434 %
</code></pre>

<p>or this:</p>

<pre><code>printf(""Percentage: %f %%\n"",( (float)((getFreeSystemMemory()/1024)*1024)/ (float)( (getTotalSystemMemory()/1024)*1024)));
</code></pre>

<p>which results in:</p>

<pre><code>Currently total memory: 7167004672
Currently avail memory: 3263479808
Percentage: 0.455348 %
</code></pre>

<p>Yet another needed improvement to the code is to display a percentage and not a fraction, so multiply the result by 100.f</p>

<pre><code>printf(""Percentage: %f %%\n"",(( (float)((getFreeSystemMemory()/1024)*1024)/ (float)( (getTotalSystemMemory()/1024)*1024))) *100.f);
</code></pre>

<p>which results in: </p>

<pre><code>Currently total memory: 7167004672
Currently avail memory: 3279790080
Percentage: 45.762356 %
</code></pre>

<p>Note: the available memory keeps changing because of the OS and background processes coming and going.</p>
",0
31302994,31302862,5,"<p>As you've seen, when you read the file using <code>fread</code> it reads it byte for byte.  It doesn't get any of the syntactic processing that the compiler does on your source files.  It doesn't know that strings live inside of quotes.  It doesn't map escape sequences like <code>\x01</code> into single bytes.</p>

<p>You have several different possibilities for fixing this:</p>

<ol>
<li>Teach your program how to do that processing as it reads the file.  This would be a fair amount of work.</li>
<li>Put just the bytes you want into the file.</li>
<li>Pick a different encoding for your file.</li>
</ol>

<p>To say a little more about #2: If you don't want to change your file-reading code, what you can do is to create an (in this case) 9-byte file containing just the nine bytes you want.  Since your nine bytes are not text, it'll end up being a ""binary"" file, which you won't be able to straightforwardly edit with an ordinary text editor, etc.  (In fact, depending on the tools you have available to you, it might be challenging just to create this particular 9-byte file.)</p>

<p>So if you can't use #1 or #2, you might want to go with #3: pick a brand-new way to encode the data in the file, easier to parse than #1, but easier to prepare than #2.  My first thought would be to have the file be hexadecimal.  That is, the file would contain</p>

<pre><code>010203040506070809
</code></pre>

<p>or</p>

<pre><code>010203
040506
070809
</code></pre>

<p>Your file-reading code, instead of the single call to <code>fread</code>, would read two characters at a time and assemble them into bytes for your array.  (I'd sketch this out for you, but the compilation I was waiting for has finished, and I ought to get back to my job.)</p>
",1
31303964,31302862,1,"<p>This should read the hex values from the file and save them to <code>buffer</code>.<br>
<code>fgets()</code> reads each line from the file.<br>
<code>sscanf()</code> reads each hex value from the line.<br>
The format string for sscanf, <code>""\\x%x%n""</code>, scans the backslash, an <code>x</code>, the hex value and stores the number of characters processed by the scan. The number of characters processed is used to advance through the line. This is needed if some lines have a different number of hex values.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    char line[100] = {'\0'};
    unsigned char *buffer = NULL;
    unsigned char *temp = NULL;
    unsigned int hex = 0;
    int size = 0;
    int offset = 0;
    int used = 0;
    int bufferused = 0;
    int increment = 100;
    int each = 0;
    FILE *pf = NULL;

    if ( ( pf = fopen ( ""file.h"", ""r"")) != NULL) {
        while ( fgets ( line, sizeof ( line), pf)) {//get each line of the file
            offset = 1;//to skip leading quote
            //sscanf each hex value in the line
            while ( ( sscanf ( line + offset, ""\\x%x%n"", &amp;hex, &amp;used)) == 1) {
                offset += used;// to advance through the line
                if ( bufferused &gt;= size) {
                    temp = realloc ( buffer, size + increment);
                    if ( temp == NULL) {
                        //one way to handle the failure
                        printf ( ""realloc failed\n"");
                        free ( buffer);
                        exit (1);
                    }
                    buffer = temp;
                    size += increment;
                }
                buffer[bufferused] = hex;
                bufferused++;
            }
        }
        fclose ( pf);
    }
    for ( each = 0; each &lt; bufferused; each++) {
        printf ( ""%x\n"", buffer[each]);
    }
    free ( buffer);

    return 0;
}
</code></pre>
",4
24092905,24092883,1,"<p>Problem was that the #includes in my .c were in the wrong order so the graph.h couldn't use the list.h. </p>
",0
24093384,24092883,0,"<p>Include list.h in graph.h,and only include graph.h in graph.c</p>
",0
23825597,23825537,1,"<p>You are confusing the different functions.</p>

<p>The <code>atoi()</code> (ASCII to integer) converts a character string to <code>int</code>. But <code>isdigit()</code> checks a single character, not an <code>int</code>.</p>

<p>All you need is <code>isdigit((unsigned int) argv[1][0])</code> to check the first character of the string.</p>

<p>If you want to make sure there aren't <em>more</em> characters, verify that too:</p>

<pre><code>bool single_digit(const char *s)
{
  return s != NULL &amp;&amp; isdigit((unsigned int) *s) &amp;&amp; s[1] == '\0';
}
</code></pre>

<p>then call</p>

<pre><code>single_digit(argv[1]);
</code></pre>
",1
23825708,23825537,-1,"<p>You don't need <code>atoi</code>. Instead just cast it to an integer. </p>

<pre><code>if (isdigit((int)argv[1]))
{
   printf(""true"");
}
else
{
   print(""false"");
}
</code></pre>

<p>Also, run it like this: <code>./filename 3</code> (i.e. just one digit after the filename because the second one will be ignored).</p>

<p><strong>Best thing:</strong> Check <a href=""http://en.wikipedia.org/wiki/Man_page"" rel=""nofollow"">man page</a> for <code>isdigit</code> and other similar methods: <a href=""http://linux.die.net/man/3/isdigit"" rel=""nofollow"">http://linux.die.net/man/3/isdigit</a></p>
",0
21030829,21030780,3,"<p>The problem is that when you hit the <code>if</code> statement, you are now skipping the increment of <code>i</code>. So you never reach 100!</p>

<pre><code>#include&lt;stdio.h&gt;
main()
{
  int i=10;
  do {
    if(i==30||i==70)
      continue;        //!!!! This will skip the i increment

    printf(""\n %d"",i);
    i++;
  } while(i&lt;100);

  return 0;
}
</code></pre>

<p>I recommend a <code>for</code> loop:</p>

<pre><code>main()
{
  for (i = 10; i &lt; 100; i++) {
    if(i==30||i==70)
      continue;          // The for loop will do the i++ on the ""continue""

    printf(""\n %d"",i);
  } 

  return 0;
}
</code></pre>
",0
21030834,21030780,1,"<p>When <code>i</code> reaches 30 the continue statements moves back to the start of the loop. </p>

<p>And so the loop continues endlessly as <code>i</code> is not incremented from this point.</p>
",0
21030836,21030780,0,"<p>It loops forever because you <code>continue</code> but don't increment i.</p>

<pre><code>if(i==30||i==70) {
  i++;
  continue;   
}
</code></pre>

<p>or you could use a for loop like so,</p>

<pre><code>#include&lt;stdio.h&gt;
int main()
{ 
  int i=10;

  for (; i &lt; 100; i++)
  {
    if(i==30 || i==70) {
      continue;
    }
    printf(""\n %d"",i);
  }

  return 0;
}
</code></pre>
",0
21030841,21030780,1,"<p>Your code's doing exactly what it's written to do.  The <code>continue</code> skips the increment instruction, so the value hits 30 and gets stuck there.  Move the increment to the start of the loop body, or better yet, use a <code>for</code> instead of a <code>while</code>.</p>
",0
21030843,21030780,0,"<p>The reason is that <code>i</code> is never incremented after 30 inside the body of do..while. You'd need to increment it.</p>

<pre><code>if (i == 30 || i == 70){
    i++;
    continue;
}
</code></pre>
",0
21030870,21030780,2,"<p>mbratch correctly pointed out your problem, but you might want to consider a <code>for</code> loop for this sort of thing. It would have prevented this particular problem, since the increment is automatic.</p>

<p>I won't do the whole thing for you, since you're obviously trying to learn, but this ought to get you started:</p>

<pre><code>for (i=0; i&lt;100; i+= 1)
</code></pre>

<p>You'll have to change some of the numbers in that line, but hopefully you'll understand what they mean when you change them.</p>
",0
21030883,21030780,0,"<p>Don't use <code>continue</code>.  Instead print out the value as long as <code>!=</code> to <code>30</code> and <code>70</code>.  Also iterate by <code>10</code> instead of <code>1</code> to output multiples <code>10</code>.</p>

<pre><code>#include&lt;stdio.h&gt;
main()
{
    int i = 10;

    do
    {
        if (i != 30 &amp;&amp; i != 70)
            printf(""\n %d"", i);

        i += 10;

    }
    while (i &lt;= 100); // if you want to print 100

    return 0;
}
</code></pre>

<p>Output: </p>

<pre><code> 10
 20
 40
 50
 60
 80
 90
100
</code></pre>

<p>Use <code>while (i &lt;= 100);</code> if you need to also print <code>100</code>.</p>
",0
24594751,24594699,0,"<p>Never ever make a format string dynamic/accessible/changeable, even if it's trivial.</p>

<p>If (in this case) your text contains potential format markup (like <code>%s</code>), you'll cause errors. Also make sure the string is null terminated properly.</p>

<p>Instead use another alternative or add a dummy format string:</p>

<pre><code>fprintf(f, ""%s"", szBuffer);
</code></pre>

<p>This might actually be the reason for the crash, but without knowing the contents of the mail, we can't say for sure.</p>

<p>Also - as mentioned by Ed in the comments - you shouldn't use <code>malloc()</code> and <code>free()</code> in a C++ program. Use <code>new</code> and <code>delete</code> instead, since those will properly call constructors/destructors as necessary (doesn't really matter for an array of <code>char</code>, but it's still not really tidy).</p>
",0
24594787,24594699,0,"<p>you need to check the return value of malloc which can be NULL.</p>

<p>and also you should use fprintf like below</p>

<p>fprintf(f, ""%s"", szBuffer);</p>

<p>that's because szBuffer may have any format string (like %d, %s etc.) and here you use szBuffer as format string (second parameter).</p>
",0
22463325,22463269,11,"<h2>What's happening:</h2>

<ol>
<li><code>searcharray[i]</code> has type <code>char</code>.</li>
<li>In a varargs function, the <code>char</code> will be promoted to an <code>int</code>.</li>
</ol>

<h2>Your bug:</h2>

<ol>
<li><code>fscanf</code> expects the variables that it will place data into to be passed by pointer.</li>
<li><p>So you should be doing:</p>

<pre><code>fscanf(filePtr, ""%c"", &amp;searcharray[i]);
</code></pre></li>
</ol>
",4
23840126,23839971,0,"<p>Here's a fairly easy way to parse the file.  </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;

int main (void)
   {
   FILE *infile;
   char  lineBuf[255+1];
   double score, sum=0, average;
   int count=0;
   int fieldsParsed;

   infile = fopen(""scores.txt"", ""r"");

   /** Read a line from the file. **/
   while(fgets(lineBuf, sizeof(lineBuf), infile))
      {
      /** Is the first character of the line a digit? **/
      if(!isdigit(*lineBuf))
         continue;  /* It is not a digit.  Go get the next line. */

      /** Convert the number string (in lineBuf) to an integer (score). **/
      score=atof(lineBuf);
      printf(""fields[%d] %.2f\n "", fieldsParsed, score);
      sum += score;
      count++;
      }

   average = sum / count;

   printf(""\nSum of the scores is %f\n"", sum);
   printf(""Average score is %.2f\n"", average);
   fclose(infile);
//   getch(); Non-portable
   return(0);
   }
</code></pre>
",0
23840019,23839971,-1,"<p>Use fseek() to skip past the leading bytes to the numbers. </p>
",0
23840031,23839971,1,"<p>Problems I see:</p>

<pre><code>input_status = fscanf(infile, ""%lf"", &amp;score);
while (input_status != EOF) 
</code></pre>

<p>is not right. The returned value of <code>fscanf</code> will be <code>0</code> if the read was not successful and <code>1</code> if it was successful.</p>

<p>More importantly, you need to add code that skips everything upto the point where you expect to see the numbers.</p>

<pre><code>char line[100];
while ( fgets(line, 100, infile) != NULL )
{
  // If the line containing ""students scores :""
  // is found, break from the while loop.
  if (strstr(line, ""students scores :"") != NULL )
  {
    break;
  }
}
</code></pre>

<p>Then, change start of the lines that read the data into:</p>

<pre><code>input_status = fscanf(infile, ""%lf"", &amp;score);
while (input_status == 1 ) 
</code></pre>
",0
22449356,22449334,3,"<p><code>sum</code> is not initialized. It has <em>indeterminate</em> value.</p>
",0
22449358,22449334,2,"<p>You should initialise <code>sum</code> at the top of your program. It could be anything!</p>
",0
22449360,22449334,1,"<p>You have not initialized the variable <code>sum</code>. Its value is <strong>indeterminate</strong>.  </p>

<h3>6.7.9 Initialization:</h3>

<blockquote>
  <p>If an object that has automatic storage duration is not initialized explicitly, its value is
  indeterminate.  </p>
</blockquote>

<p>Initialize it to <code>0</code>  </p>

<pre><code>unsigned long sum = 0;
</code></pre>
",0
23813062,23812888,-1,"<p>May be this will spoil your learning process, but here is one solution anyway:</p>

<pre><code>#include&lt;stdio.h&gt;
int main()
{ 
    int a[9];
    int i;
    int cont_sum = 0;
    int prev;
    for(i=0;i&lt;9;i++)
        scanf(""%d"",&amp;a[i]);

    prev = a[0];
    cont_sum = prev;
    for(i=1;i&lt;9;i++)
    {
        if(a[i] != prev)
        {
            printf(""contiguous sub sequence sum: %d\n"", cont_sum);
            prev = a[i];
            cont_sum = prev;
        }
        else
        {
            prev = a[i];
            cont_sum += prev;
        }
    }
    printf(""contiguous sub sequence sum: %d\n"", cont_sum);
    getch();
}
</code></pre>
",0
23813706,23812888,1,"<p>First, regarding this:</p>

<pre><code>sum[9]={0};
</code></pre>

<p>Since the problem only asks you to print the sums of the various subsequences, it's not strictly necessary to store them, so I would just declare a single <code>int</code> that you can use for doing the summation. Incidentally, if you did need to store all of the sums, you would need a substantially larger array: one with a position for every distinct subsequence, rather than for every member of the original series.</p>

<p>On to the calculation. Here's where you're enumerating the members of a subsequence:</p>

<pre><code>for(k=i;k&lt;j+1;k++)
    printf(""+%d "",a[k]);
</code></pre>

<p>What you'll want to do is:</p>

<ol>
<li>Before the loop, initialize the summation variable to zero, since you're about to begin a new calculation.</li>
<li>Inside the loop, add each <code>a[k]</code> value to the sum.</li>
<li>After the loop, your summation variable will contain the correct value since you've just processed the whole subsequence, so you can simply print it.</li>
</ol>

<p>This should give you enough to complete the exercise, but if you have any further specific questions, just let me know.</p>
",0
23817381,23812888,0,"<pre><code>#include&lt;stdio.h&gt;
int main()
{
    int a[9]={0};
    int sum=0;
    int i,j;
    for(i=0;i&lt;9;i++)
        scanf(""%d"",&amp;a[i]);
    for(i=0;i&lt;9-1;i++)
    {
        sum=0;
        for(j=i;j&lt;9;j++)
        {
            sum=sum+a[j];
            printf(""sum: %d "",sum);
        }
      printf(""\n\n"");
   }
return 0;
}
</code></pre>

<p>OK first off all i didn't know what was contiguous sub sequence,so sorry if my answer is not so correct with the your problem,  i googled and found this <a href=""https://stackoverflow.com/questions/3988575/what-does-this-definition-of-contiguous-subsequences-mean"">What does this definition of contiguous subsequences mean?</a>   I made the program according to my  understanding of this link. so according to that your problem should find sum of every possible set (in contiguous incrementing order). I have implemented it.</p>
",0
23594521,23594496,0,"<p>Move these lines:</p>

<pre><code>printf(""Please enter the number of integers you want to input\n"");
scanf(""%d"", &amp;numInput);
integersArray = (int *) malloc(sizeof(int) * numInput);
</code></pre>

<p>to <code>main</code>, before you call <code>getInts</code>.</p>

<p>The reason why you need this is that <code>getInts</code> receives a copy of <code>integersArray</code> (i.e. a copy of the pointer), and an assignment within <code>getInts</code> modifies only the copy, and the <code>integersArray</code> in main remains intact.</p>
",1
23594664,23594496,0,"<p>First you need to understand what passing by value and what passing by reference is.</p>

<p>Observe in the example I have <a href=""http://gsamaras.wordpress.com/code/functions-in-c/"" rel=""nofollow noreferrer"">here</a>, how the arguments are passed in the function. The first one is passed by value and the second by reference.</p>

<p>The function holds its own variables, since it has an internal world, that all of its variables live inside. Once the function is terminated, so does its world.</p>

<p>The first argument is copied to the first argument and when the function terminates, the changes made inside the function are forgotten.</p>

<p>However, the second one is passed by reference. As a result the variable inside the function 'points' to the variable that lives in main. So, when the function terminates, all the changes will be remembered in the world of main too.</p>

<p>Now, in your case, you want to pass an array, to dynamically allocate it and fill it.
You need to pass the array by reference, so that the changes shall be remembered when the function terminates.</p>

<p>Here is how one could do it:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int getInts(int** integersArray, int numInput);

int main() {
    int * integersArray;
    int numInput;
    int i;

    numInput = getInts(&amp;integersArray, numInput);

    for (i = 0; i &lt; numInput; i++) {
        printf(""%d "",integersArray[i]);
    }

    return 0;
}

// do I really need to pass numInput, since I return it? No.
int getInts(int** integersArray, int numInput) {
    int i;

    printf(""Please enter the number of integers you want to input\n"");
    scanf(""%d"", &amp;numInput);

    *integersArray = malloc(sizeof(int) * numInput);

    for (i = 0; i &lt; numInput; i++) {
        printf(""please enter integer %d: "", i+1);
        scanf(""%d"", &amp;((*integersArray)[i]));
    }

    return numInput;
}
</code></pre>

<p>Here, when we malloc something, this means that the memory allocated will not be de-allocated when the function terminates. It will live <strong>forever</strong> and we ought to de-allocate when we no longer need it, e.g. at the end of main. If we do not do so, this will produce a <code>memory leak</code>, which is a common logical error.</p>

<p>So, the main should be modified in order to use <code>free()</code>.</p>

<pre><code>int main() {
    int * integersArray;
    int numInput;
    int i;

    numInput = getInts(&amp;integersArray, numInput);

    for (i = 0; i &lt; numInput; i++) {
        printf(""%d "",integersArray[i]);
    }

    free(integersArray);   // FREE
    return 0;
}
</code></pre>

<p>Below is a version, which doesn't return the <code>numInput</code>, but modifies a bit the second argument you have in <code>getInts()</code>.</p>

<pre><code>// changed the prototype
void getInts(int** integersArray, int* numInput);

int main() {
    int * integersArray;
    int numInput;
    int i;

    getInts(&amp;integersArray, &amp;numInput); // pass the numInput by reference!!

    for (i = 0; i &lt; numInput; i++) {
        printf(""%d "",integersArray[i]);
    }
    free(integersArray);
    return 0;
}


void getInts(int** integersArray, int* numInput) {
    int i;

    printf(""Please enter the number of integers you want to input\n"");
    scanf(""%d"", numInput);

    *integersArray = malloc(sizeof(int) * (*numInput));

    for (i = 0; i &lt; *numInput; i++) {
        printf(""please enter integer %d: "", i+1);
        scanf(""%d"", &amp;((*integersArray)[i]));
    }
}
</code></pre>

<p>Notice how <code>numInput</code> is treated inside the body of your function.
Also note that I wrote <code>scanf</code> as this</p>

<p><code>scanf(""%d"", numInput);</code></p>

<p>but what really happens is this:</p>

<p><code>scanf(""%d"", &amp;(*numInput));</code></p>

<p>However, operators <code>&amp;</code> and <code>*</code> cancel its other out, as you might already know.</p>

<p>[EDIT]</p>

<p>As <em>alk</em> stated, this provides an excellent chance to learn to use a <code>debugger</code>. There is plenty of info and good tutorials about that in the internet.</p>

<p>Another debugging technique would be using printing messages in the code and see where things don't go as you think they are (remember the good thing with the computers is that they do exactly what we tell them and the bad thing with the computers is that they do exactly what we tell them).</p>

<p>Here is an example of modifying your function for that purpose:</p>

<pre><code>int getInts(int * integersArray, int numInput) {
    int i;

    printf(""Please enter the number of integers you want to input\n"");
    scanf(""%d"", &amp;numInput);

    // first step would be to check that you get the numInput right
    printf(""numInput is %d\n"", numInput);


    integersArray = malloc(sizeof(int) * numInput);

    for (i = 0; i &lt; numInput; i++) {
        printf(""please enter integer %d: "", i+1);
        scanf(""%d"", &amp;(integersArray[i]));
    }

    // check if you read the numbers correctly
    for (i = 0; i &lt; numInput; i++) {
         printf(""%d "",integersArray[i]);
    }
    printf(""\ngetInts() terminating...\n"");

    return numInput;
}
</code></pre>

<p>and a possible output would be:</p>

<pre><code>Please enter the number of integers you want to input
1
numInput is 1
please enter integer 1: 2
2 
getInts() terminating...
441172865 
</code></pre>

<p>From the output we can see that input value was correctly received by our array, because we print the array inside the function.</p>

<p>However in the main, the array contains garbage..Hmm, what can be wrong? Well you already know from what I wrote before. Your mind should think, the function does it's job good inside her body, but the 'communication' with main has some problem. The problem was that the array wasn't passed by reference.</p>

<p>Also notice, that you should not cast what malloc returns. Google for more (one result of googling is <a href=""https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc"">here</a>).</p>
",0
22128018,22127985,1,"<pre><code>1 / n
</code></pre>

<p>is an expression with two integer operands. And so performs integer division. For <code>n</code> equal to <code>1</code>, this evaluates to <code>1</code>. For all values of <code>n</code> greater than <code>1</code> this integer division evaluates to <code>0</code>.</p>

<p>You want floating point division and so must make at least one of the operands a floating point value. For instance </p>

<pre><code>1.0 / n
</code></pre>

<p>You'll also need to declare <code>x1</code> to be a floating point value and use <code>%f</code>. It's no good trying to approximate <code>e</code> with an integer variable.</p>

<p>I guess that you will, at some point, need to implement a loop termination condition. And as it stands, your loop is rather pointless because none of the values used inside the loop ever change.</p>

<p>Here's a program that is perhaps moving in the right direction:</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;math.h&gt;

int main(void)
{
    for (int n = 1; n &lt;= 1000; n++)
    {
        double e = pow(1 + 1.0 / n, n);
        printf(""n=%d, approximation to e=%.16f\n"", n, e);
    }
    printf(""true value of e=%.16f\n"", exp(1.0));
    return 0;
}
</code></pre>

<p><strong>Output</strong></p>

<pre>
n=1, approximation to e=2.0000000000000000
n=2, approximation to e=2.2500000000000000
n=3, approximation to e=2.3703703703703698
n=4, approximation to e=2.4414062500000000
n=5, approximation to e=2.4883199999999994
n=6, approximation to e=2.5216263717421135
n=7, approximation to e=2.5464996970407121
n=8, approximation to e=2.5657845139503479
n=9, approximation to e=2.5811747917131984
n=10, approximation to e=2.5937424601000023
..........
n=991, approximation to e=2.7169116115768883
n=992, approximation to e=2.7169129915688766
n=993, approximation to e=2.7169143687840753
n=994, approximation to e=2.7169157432307069
n=995, approximation to e=2.7169171149169880
n=996, approximation to e=2.7169184838514693
n=997, approximation to e=2.7169198500421694
n=998, approximation to e=2.7169212134981109
n=999, approximation to e=2.7169225742266474
n=1000, approximation to e=2.7169239322355936
true value of e=2.7182818284590451
</pre>

<p>It's quite interesting to note that the rate of convergence is really poor. And the accuracy of the estimate can never be good because for large <code>n</code> you will suffer round off in <code>1.0 + 1.0 / n</code>. This is absolutely not a useful way to approximate <code>e</code>.</p>

<p>This version, using an <a href=""http://en.wikipedia.org/wiki/E_%28mathematical_constant%29"" rel=""nofollow"">infinite sum</a>, converges much more rapidly:</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;math.h&gt;

int main(void)
{
    double e = 0.0;
    double increment = 1.0;
    for (int n = 0; n &lt;= 20; n++)
    {
        e += increment;
        increment /= (n+1);
        printf(""n=%d, approximation to e=%.16f\n"", n, e);
    }
    printf(""true value of e=%.16f\n"", exp(1.0));
    return 0;
}
</code></pre>

<p><strong>Output</strong></p>

<pre>
n=0, approximation to e=1.0000000000000000
n=1, approximation to e=2.0000000000000000
n=2, approximation to e=2.5000000000000000
n=3, approximation to e=2.6666666666666665
n=4, approximation to e=2.7083333333333330
n=5, approximation to e=2.7166666666666663
n=6, approximation to e=2.7180555555555554
n=7, approximation to e=2.7182539682539684
n=8, approximation to e=2.7182787698412700
n=9, approximation to e=2.7182815255731922
n=10, approximation to e=2.7182818011463845
n=11, approximation to e=2.7182818261984929
n=12, approximation to e=2.7182818282861687
n=13, approximation to e=2.7182818284467594
n=14, approximation to e=2.7182818284582302
n=15, approximation to e=2.7182818284589949
n=16, approximation to e=2.7182818284590429
n=17, approximation to e=2.7182818284590455
n=18, approximation to e=2.7182818284590455
n=19, approximation to e=2.7182818284590455
n=20, approximation to e=2.7182818284590455
true value of e=2.7182818284590451
</pre>
",0
22853766,22853599,0,"<p>Problems I see:</p>

<ol>
<li><p><code>img</code> is not initialized at all. It is used before it is assigned to point to a valid <code>PPMImage</code>. That causes the line:</p>

<p><code>n=img->x * img->y;</code></p>

<p>to cause segmentation violation.</p></li>
<li><p><code>fgets</code> returns a <code>char*</code>. In the line</p>

<p><code>int a = fgets(buff, sizeof(buff), fp);</code></p>

<p>you are assigning a <code>char*</code> to an <code>int</code>.</p></li>
<li><p>You have</p>

<pre>
**int i,j,array[n];
ch = array[0];

<pre><code>for (i=1;i&lt;n;i++)
{
    if(ch&lt;array[i])
    ch = array[i];
}** 
</code></pre>

</pre>

<p>The <code>**</code>s at the start of the block and at the end of the block were unexpected. I am not sure what you were thinking.</p></li>
</ol>

<p>The last two problems are minor ones. If you fix the first problem, things might work.</p>

<p>Here's a reworked <code>PPMInage</code></p>

<pre><code>static PPMImage *readPPM(const char *filename)
{
   char buff[16];
   PPMImage *img;
   FILE *fp;
   int n;
   int maxRGB;
   int red;
   int green;
   int blue;
   int i;
   int sum;
   int minSum;

   //open PPM file for reading
   if((fp=fopen(filename,""rb""))==NULL){
       printf(""Can't open file: %s \n"",filename);
   }
   else{
       printf(""image name: %s \n"",filename);
   }

   //read image format
   if (!fgets(buff, sizeof(buff), fp)) {
       perror(filename);
       exit(1);
   }

   //check the image format
   if (buff[0] != 'P' || buff[1] != '3') {
       printf(""Invalid image format (must be 'P3')\n"");
       exit(1);
   }
   else{
       printf(""magic number  = P3 \n"");
   }

   // Allocate memory for the image.
   img = malloc(sizeof(PPMImage));

   // Read the X and Y dimensions of the image.
   fscanf(fp, ""%d %d"", &amp;(img-&gt;x), &amp;(img-&gt;y));

   // Allocate memory for the pixel data.
   n=img-&gt;x * img-&gt;y;
   img-&gt;data = malloc(n*sizeof(pixel_t));

   // Read the max RGB value and discard.
   // We don't need it.
   fscanf(fp, ""%d"", &amp;maxRGB);

   // Read the RGB values one by one.
   for ( i = 0; i &lt; n; ++i )
   {
      if ( fscanf(fp, ""%d %d %d"", &amp;red, &amp;green, &amp;blue) != 3 )
      {
         printf(""Incomplete RGB data\n"");
         return img;
      }

      img-&gt;data[i].red = (unsigned char)red;
      img-&gt;data[i].green = (unsigned char)green;
      img-&gt;data[i].blue = (unsigned char)blue;
   }

   // Get the minimum sum.
   minSum = img-&gt;data[0].red + img-&gt;data[0].green + img-&gt;data[0].blue;
   for ( i = 1; i &lt; n; ++i )
   {
      sum = img-&gt;data[i].red + img-&gt;data[i].green + img-&gt;data[i].blue;
      if ( minSum &gt; sum )
      {
         minSum = sum;
      }
   }

   printf(""Minimum RGB sum: %d\n"", minSum);

   return img;
}
</code></pre>
",7
22495626,22495532,1,"<p>I'm not following your logic in the line</p>

<pre><code>    A[x][y] = 1*x + y;
</code></pre>

<p>I seem to have gotten closer using <code>%</code>: </p>

<pre><code>        A[x][y] = (1+x + y) % 10;
</code></pre>

<p>This takes the remainder of the sum of <code>x</code> and <code>y</code> when divided by 10 - which, if we start with 1 rather than 0, begins to approach what you want.  It's not exactly correct, but it's a start.  </p>

<pre><code>=== Original matrix === 
  1    2    3    4    5    6    7    8    9    0  
  2    3    4    5    6    7    8    9    0    1  
  3    4    5    6    7    8    9    0    1    2  
  4    5    6    7    8    9    0    1    2    3  
  5    6    7    8    9    0    1    2    3    4  
  6    7    8    9    0    1    2    3    4    5  
  7    8    9    0    1    2    3    4    5    6  
  8    9    0    1    2    3    4    5    6    7 
</code></pre>

<p>Here's the code:</p>

<pre><code>#include &lt;stdio.h&gt;

#define ROWS 8
#define COLS 10

int main(int argc, char* argv[]) {
    int A[ROWS][COLS];
    int B[COLS][ROWS];
    int x,y;
    for (x=0; x&lt;ROWS; x++) {
        for (y=0; y&lt;COLS; y++) {
            A[x][y] = (1+x + y) % 10;
        }
    }
    printf(""=== Original matrix === \n"");
    for (x=0; x&lt;ROWS; x++) {
        for (y=0; y&lt;COLS; y++) {
            printf(""%3d  "", A[x][y]);
        }
        printf(""\n"");
  }
}
</code></pre>
",0
22495856,22495532,1,"<p>First, just fill the first row with whatever you want in it.  For example, for numbers counting up from zero:</p>

<pre><code>for (y = 0; y &lt; COLS; y++)
  A[0][y] = y;
</code></pre>

<p>Once you have the first row filled, this will fill the remaining rows as you described (each row right-rotated by one from the previous row):</p>

<pre><code>for (x = 1; x &lt; ROWS; x++)
  for (y = 0; y &lt; COLS; y++)
    A[x][(x + y) % COLS] = A[0][y];
</code></pre>

<p>The above starts filling from the second row (index of 1) onward, and always copies values from the first row.  However, the position in the current row it copies to is offset by the row number, so it starts one place later for each row.  The <code>%</code> operator is used to wrap the index back around to the start of the row when it gets to the end.</p>
",4
28179386,28179315,1,"<p>As per the <a href=""http://linux.die.net/man/3/fgets"" rel=""nofollow"">man page</a> of <code>fgets()</code>, the syntax is</p>

<pre><code>char *fgets(char *s, int size, FILE *stream);
</code></pre>

<p>so, a call to <code>fgets()</code> needs to have three arguments.</p>

<p>In your code, <code>while (fgets(str).....</code>, it has only one.</p>
",2
28450473,22878913,0,"<blockquote>
  <p>problem is that if i enter 13:15(13*60+15=795) then the program should
  display 12:47 pm departure time</p>
</blockquote>

<p>Since you want the departure time closest to the entered time, you must not compare <code>entertime</code> to the departure times, but to the times halfway between to successive departure times, e. g. instead of</p>

<pre><code>    if(entertime&lt;=dept1)
</code></pre>

<p>write</p>

<pre><code>    if (entertime &lt;= (dept1+dept2)/2)
</code></pre>

<p>and at last remove the</p>

<pre><code>    if(entertime&lt;=dept8)
</code></pre>

<p>to enable the user to get the latest flight when none of the earlier ones fits.</p>
",0
22852348,22852289,1,"<p>Use <code>%*d</code> to get output without leading zeros.</p>
",0
22522304,22522285,3,"<pre><code>do {
    /* ... */
} while (ans == Y || y);
</code></pre>

<p>You should change this into</p>

<pre><code>do {
    /* ... */
} while (ans == 'Y' || ans == 'y');
</code></pre>
",0
22522472,22522285,0,"<p>in this code row:</p>

<pre><code>char ans, y, Y, n, N;
</code></pre>

<p>must be this way:</p>

<pre><code>char ans;
</code></pre>

<p>you don't need create the another chars, because the variable ans will assume the values 'y', 'Y', 'n' and 'N'. Then, if <code>(ans == 'y' || 'Y' )</code> is boolean true, will be because the user  typed 'y' or 'Y'.</p>

<p>And, like the partner Timrau says:</p>

<p>this code:</p>

<pre><code>do{
    /* ... */
}while (ans == Y || y);
</code></pre>

<p>Must be:</p>

<pre><code>do{
    /* ... */
}while (ans == 'Y' || ans == 'y');
</code></pre>
",0
21298418,21298407,1,"<p>You have an error in this line. It should be</p>

<pre><code>printf(""The distance between the two points is %5.2f \n"", distance);
</code></pre>

<p>Notice that you had two double-quotes in there.</p>
",4
22132092,22132048,1,"<p>regarding the first <code>expected ; before'{' token</code> error, instead of</p>

<pre><code>main()
</code></pre>

<p>you should use the full signature</p>

<pre><code>int main(int argc, char **argv)
</code></pre>

<p>for the second error, you should first indent your code properly.</p>
",2
22132101,22132048,1,"<p>check the {} combinations properly. you have mostly written display() function difination inside create{} function. so add the {} pairs properly. add keep code well indented
add one closing '}' before display() function defination.<br>
and </p>

<pre><code> printf(""\nthe name of the student is%d"",temp-&gt;name);
</code></pre>

<p>it should be %s for strings.</p>
",2
22518483,22518315,0,"<p>You never check fp to be a valid file pointer after fopen() (!= NULL).</p>

<p>Not unlikely (actually, I'll bet on it) your program just doesn't find its data file.</p>
",2
23821986,23821929,3,"<p><code>""\0""</code> is equivalent to an empty string, so <code>strcat</code>ting it onto <code>ptr</code> won¡¯t do anything.</p>

<p>Instead, set element <code>4</code> to a null byte:</p>

<pre><code>ptr = realloc(ptr, 5);
ptr[4] = '\0';
</code></pre>

<p>If the string is longer than 4 characters, it¡¯ll be truncated, and if not, it will have no effect, since the terminator is before it.</p>

<p>Also, use <code>strncpy</code> instead of <code>strcpy</code> and <a href=""https://stackoverflow.com/questions/1621394/how-to-prevent-scanf-causing-a-buffer-overflow-in-c"">not plain <code>scanf(""%s"")</code></a> to avoid buffer overflows.</p>

<p>And take Cody Gray¡¯s comment below into account, but really, you should just allocate <code>sizeof str</code> instead.</p>
",4
23822022,23821929,0,"<p>@false's answer is absolutely correct, but he does not explain <em>why</em> the whole string is initially being printed. </p>

<p>The reason is because the call to <code>realloc</code> with a smaller size does not actually cause any initialization to happen, and in particular does not cause a write to the memory. Instead, it just tells the memory management system that the bytes after the 5th byte are now available for reuse.</p>

<p>If you do a whole bunch of <code>malloc</code> afterwards, you will probably eventually observe the end of the string being corrupted.</p>
",1
23822908,23821929,0,"<p>in C,STRING mean an null-terminated arrays of characters (memory block)
for example, string ""enter"" will occupied 6 bytes of memory(include null-terminated)</p>

<pre><code>char* ptr = ""test""; //will AUTO-allocated 5 bytes to stored string ""test\0""
</code></pre>

<p><code>malloc,realloc,free</code> are memory manager, NOT string manipulator, in your first malloc</p>

<pre><code>ptr=(char *)malloc(sizeof(char)*10);
</code></pre>

<p>system will preserved 10 bytes for your code-purpose,after realloc</p>

<pre><code>ptr=(char *)realloc(ptr,5);
</code></pre>

<p>the original data <strong>MAY</strong> still preserved when new size fitted int the pre-allocated location,but in this point, the last 5 bytes already return to system,strcat it could lead program crash,becase you are trying to access the memory <strong>NOT</strong> belong to your code,if just need shrink string or something else, use string function instead</p>
",0
22875958,22875923,0,"<p>Read the manual pages</p>

<p>you need %c not %s</p>
",0
22875966,22875923,5,"<p>With <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/scanf.html"" rel=""noreferrer""><code>scanf()</code></a>
, the <code>%s</code> format skips leading white space, then scans non-white space characters and stops at the next white space in the input line.</p>

<p>That means that only <code>Bangalore</code> is read, so only <code>Bangalore</code> is printed.</p>

<p>If you want a whole line of input, you should probably use <code>fgets()</code>.</p>

<p>You should also be getting warnings from your compiler about your printing code.  You probably want to use this without a loop:</p>

<pre><code>printf(""%s\n"", str);
</code></pre>

<p>or this within a loop:</p>

<pre><code>printf(""%c"", str[i]);
</code></pre>

<p>though this would be faster:</p>

<pre><code>putchar(str[i]);
</code></pre>

<p>and you would need to worry about adding a newline at the end (<code>putchar('\n');</code> after the loop).</p>
",2
22875976,22875923,1,"<p>Reading input from terminal would stop if it encountered a space or a new line. You could do 2 things to get what you need</p>

<ol>
<li>Use fgets, ex : <code>fgets(str, 100, stdin)</code></li>
<li>Tell scanf to read input while it's not a newline like this <code>scanf (""%[^\n]%*c"", str);</code></li>
</ol>

<p>and the second thing,if you are printing out character arrays, you must use %c</p>
",0
23062184,23061509,0,"<p>You can see what C++ Vector does: you can malloc a length of L at fist, every time you getch(), you should decide if you expand L to 2*L (or to L + 100 for saving spaces)</p>
",0
23062391,23061509,0,"<p>Perhaps something like this? </p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;ctype.h&gt;

int main() 
  {
  int mychar;

  mychar=fgetc(stdin);
  while(EOF != (mychar=fgetc(stdin)))
     putchar(toupper(mychar));

  return 0;
  }
</code></pre>
",0
34231469,34231427,3,"<p>printf is much slower because the format string is parsed at runtime. Of course, the average homework program or simple Project Euler solution is so small that wasting a few CPU cycles doesn't matter anyway. </p>
",2
34231481,34231427,3,"<p>I would go with <code>putchar</code> as the string in <code>printf</code> needs to be parsed. Should be slightly quicker - but probably not a lot in it. </p>
",0
34231484,34231427,5,"<p>It doesn't really matter. I never encountered a case were printing to the console ever matter to someone in terms functions choice or effiency.</p>
",5
34231500,34231427,6,"<p><code>printf</code> and <code>putchar</code> are both stdio functions, so they both write to the same <code>FILE</code> handle (rather than directly to the file descriptor).</p>

<p>However, <code>printf</code> is far heavier since the first argument is a format string that needs to be scanned for replacement expressions and escapes.</p>

<p>So, both <code>printf(""\n"")</code> and <code>putchar('\n')</code> will do the same thing, but the latter will be faster.</p>
",0
34231554,34231427,29,"<p>It will make no difference which one you chose if you're using a modern compiler<sup>[1]</sup>. Take for example the following C code.</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

void foo(void) {
    putchar('\n');
}

void bar(void) {
    printf(""\n"");
}
</code></pre>

<p>When compiled with <code>gcc -O1</code> (optimizations enabled), we get the following (identical) machine code in both <code>foo</code> and <code>bar</code>:</p>

<pre><code>movl    $10, %edi
popq    %rbp
jmp _putchar                ## TAILCALL
</code></pre>

<p>Both <code>foo</code> and <code>bar</code> end up calling <code>putchar('\n')</code>. In other words, modern C compilers are smart enough to optimize <code>printf</code> calls very efficiently. Just use whichever one you think is more clear and readable.</p>

<hr>

<ol>
<li>I do not consider MS's <code>cl</code> to be a modern compiler.</li>
</ol>
",15
34231944,34231427,11,"<blockquote>
  <p>Are there any best practices for using one over the other? </p>
</blockquote>

<p>Let style drives the decision.</p>

<p>Since efficiency of execution is the same or nearly identical, use the style that best conveys the larger code's function.  </p>

<p>If the function had lots of <code>printf()</code>, stay with <code>printf(""\n"")</code>.  </p>

<p>Likewise for <code>putchar('\n')</code> and <code>puts("""")</code></p>
",0
31186511,31186346,3,"<ul>
<li>In C, <em>zero</em> <code>0</code> is treated as <em>boolean</em> <code>false</code>.</li>
<li>Any other <em>non zero</em> value is <em>boolean</em> <code>true</code>. </li>
<li>By default <code>true</code> means <code>1</code>.</li>
</ul>

<p>So when you <code>return(!b-&gt;count)</code> which is equivalent to <code>b-&gt;count ! = 0</code> return either <code>true</code> or <code>false</code>. But as the <code>return</code> type is <code>int</code> then if <code>b-&gt;count</code> is equal to <code>0</code> then <code>isEmptyArray</code> will return <code>1</code>, <code>0</code> otherwise.</p>
",0
31186888,31186346,2,"<p>Its not that it will change the datatype from <code>int</code> to <code>!int</code>.</p>

<p><code>!</code> will work on the value of <code>b-&gt;count</code>. So if it is 0, <code>!b-&gt;count</code> will result in <code>1</code>, otherwise <code>0</code>.</p>
",0
31186403,31186346,9,"<p>There is no change of type happening here.</p>

<p>The not operator (<code>!</code>) simply computes another integer value, which is then returned.</p>

<p>In this case, it's being used to convert the count into a true/false value to answer the question whether the array is empty. If <code>b-&gt;count</code> is 0, <code>!0</code> is <code>1</code>, which means ""true"". If it's any other value, <code>!</code> will convert that to <code>0</code>, i.e. ""false"".</p>

<p>In my opinion code like this fails to be optimally clear; it should just be:</p>

<pre><code>return b-&gt;count != 0;
</code></pre>

<p>Which generates the exact same values for all values of <code>count</code>, but is way clearer.</p>
",0
31186406,31186346,3,"<p>the return value is playing the role of a boolean, if <code>count</code> is <code>0</code> return <code>1</code>, otherwise return <code>0</code></p>
",0
31186418,31186346,2,"<p>Its because of what you're returning.</p>

<p>isEmptyArray means </p>

<ul>
<li>a return of ""true"" says the array is empty </li>
<li>a return of ""false"" says
the array is not</li>
</ul>

<p>So if b -> count is NULL, then you'd want to return true for empty, so you inverse it</p>

<p>and if b -> count is not NULL you want to return false for not empty, so you inverse it</p>

<p>If you wanted to remove the !, then rename the function to isNotEmptyArray to follow the logic</p>
",0
22493270,22483641,0,"<p>Need to use the result of <code>open()</code>.  Without it, code does not know if the <code>\0</code> are from the <code>read()</code> call or the initialization <code>array[10] = {'\0',}</code></p>

<pre><code>ssize_t len = read(0,array,sizeof(array));
// Use `len` as then needed.
</code></pre>
",0
25657625,25657604,2,"<blockquote>
  <p>CXX0017: Error symbol ""node"" not found , in ""watch 1""</p>
</blockquote>

<p>sounds very much like it's a variable being watched in the <em>debugger</em> (and, in fact, it <em>is</em> <a href=""http://social.msdn.microsoft.com/Forums/vstudio/en-US/3c87a746-e2f6-44ee-a506-65fd412e5a69/debug-watch-error-cxx0017-symbol-not-found-beginner?forum=vsdebug"" rel=""nofollow"">such a beast</a>), which may or may not be a variable in your code.</p>

<p>Even if it <em>was</em> in your code, it may be at a different stack level to the one you're currently on.</p>

<p>It's likely that a watchpoint has been set on a variable called <code>node</code>. You just need to remove that watchpoint, the method used would be dictated by the debugger itself.</p>

<p>For example, In Visual Studio Debugger, I believe you can go to the watch window and right-click on an expression to delete it.</p>
",2
24113084,24102448,0,"<p>See 8 &amp; 9 first.</p>

<ol>
<li><p><code>MaxCurrencyTypes</code> is undeclared, let's assume</p>

<pre><code>#define MaxCurrencyTypes (5)
</code></pre></li>
<li><p><code>string</code> is undeclared, let's assume</p>

<pre><code>typedef char * string;
</code></pre></li>
<li><p><code>currencyDB</code> is a pointer type, recommend instead declaring as a structure type</p>

<pre><code>typedef struct {
  currencyT cur[MaxCurrencyTypes];
  int nCurrency;
} currencyDB;  // Drop *
</code></pre></li>
<li><p><code>static ReadOneLine()</code> should use explicit return type.</p>

<pre><code>static int ReadOneLine()
</code></pre></li>
<li><p><code>int nCurrency;</code> not used in <code>ReadDataBase()</code>.</p></li>
<li><p><code>New()</code> in <code>db = New(currencyDB)</code> is not declared nor defined.  Assume to allocate uninitialized memory for <code>*db</code>.</p></li>
<li><p><code>ExchangeFile</code> not declared.</p></li>
<li><p><code>if (nscan = EOF)</code> -> <code>if (nscan == EOF)</code></p></li>
<li><p><code>ReadOneLine()</code> needs to return a value.</p></li>
<li><p><code>main()</code> should explicitly state return type and parameters.</p>

<pre><code>int main(void)  
</code></pre></li>
</ol>
",0
24614022,24613953,6,"<p>You have a stray <code>&amp;</code> in there it seems - change:</p>

<pre><code>int* hfmmInfo = (int*) malloc(&amp;hfmmInfoSize*sizeof(int));
</code></pre>

<p>to:</p>

<pre><code>int* hfmmInfo = malloc(hfmmInfoSize*sizeof(int));
</code></pre>

<p>Note also the removal of the <a href=""https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc"">redundant (and potentially dangerous) cast</a> on the result of the call to <code>malloc</code>.</p>
",3
23826331,23826154,3,"<p>You're only incrementing <code>count</code> in the first function if you match on a newline <strong>followed by a null char</strong>.</p>

<p>This:</p>

<pre><code>ret2line_template[1]
</code></pre>

<p>in your conditional expression is looking at the second wchar_t in this:</p>

<pre><code>const wchar_t* ret2line_template = L""\n"";
</code></pre>

<p>which is the zero terminator. None of the pairs of wchar_t's in your string match this, so the result is zero. Just look for a <code>L'\n'</code>. If there are chars left after the last one, add one more ""line"" to your count (the last one that has no <code>L'\n'</code> trailing.</p>
",2
24109049,24108822,1,"<pre><code>char a[20]={""abd123vf""};
int l=0,m=0,j,cc=0;
char b[20];
l=strlen(a);

for(j=0;j&lt;l;j++)
{
 if(a[j]&gt; 47 &amp;&amp; a[j] &lt;58){
 cc+ = a[j] - '0';
}
 else{
  b[m]=a[j];
  m++;
 }
}
b[m]='\0';

printf(""%d\n\n"",cc);
printf(""%s"",b);
getch();
return 0;
</code></pre>

<p>Edit after the first comment:</p>

<p>Since you have not specifically mentioned a problem, I assume you are looking for a better way of writing this code.</p>

<p>Instead of looping through your string twice, you can do it in a single go.
Instead of checking for individual numbers or letters, you can check if the character is in the range : 48 - 57 [i.e., 0 to 9]</p>

<p>Instead of two if conditions, you can go for an else.
[Note that even the special characters in the original string will be part of your new string in this case]</p>

<p><code>a[j] - '0'</code> will give the actual number in the string. eg:
if the number is 5, a[j] will be 53;
'0' is 48; 53 - 48 = 5 and that's what you add to your sum</p>
",3
24109304,24108822,0,"<p>Your code is OK for the most part.</p>

<p>There is one error in computing <code>c</code>. Instead of</p>

<pre><code>    cc += c[j]; // The integer value of c[j] when it is `0` is 48, not 0
</code></pre>

<p>You need to use</p>

<pre><code>    cc += c[j] - '0';
</code></pre>

<p>Based on your expected output at the top of the question, your <code>printf</code> lines</p>

<pre><code>printf(""%d\n\n"",cc);
printf(""%s"",b);
</code></pre>

<p>need to be</p>

<pre><code>printf(""%s %d\n"",b,cc);
</code></pre>

<p><strong>Other</strong></p>

<p>You have an unnecessary call to <code>atoi</code>. Was that just for debugging?</p>
",0
24109488,24108822,0,"<p>I wouldn't do it this way, the algorithm is actually quite simple. Works for every string.</p>
<pre><code>char a[] = &quot;abcd123dc2&quot;;
char b[20];
char c[20];
int i, spotinnumbers = 0, spotincharacters = 0;
for(i = 0 ; i &lt; strlen(a) ; i++)
{
    if((a[i] &gt;= 'a' &amp;&amp; a[i] &lt;= 'z') || (a[i] &gt;= 'A' &amp;&amp; a[i] &lt;= 'Z'))
    {
        b[spotincharacters] = a[i];
        spotincharacters++;
    }
    else if(a[i] &gt;= '0' &amp;&amp; a[i] &lt;= '9')
    {
        c[spotinnumbers] = a[i];
        spotinnumbers++;
    }
}
b[spotincharacters] = '\0';
c[spotinnumbers] = '\0';
</code></pre>
<p>Some explanation of the code. Basically, it's not splitting, just having another two strings, one of the alphabet in the main string and one of the numbers in it. We use one loop to run on the string and decide whether the character is an alphabet letter or a number and assign it in the right place.</p>
<p>About the sum calculation... As we have the numbers in c:</p>
<pre><code>int total = 0;
for(i = 0 ; i &lt; strlen(c) ; i++)
{
   total += c[i]-'0';
}
</code></pre>
<p>explanation about this piece of code, in this code, as a string in C is simply an array of characters, in the string we have the characters resembling the numbers but the characters' value in numeric is something called ASCII value. You can look at the <a href=""http://www.asciitable.com/"" rel=""nofollow noreferrer"">ASCII Table</a> and find out that each character has a numeric value and there's an overall of 256 characters (2^8) which is why a character takes one byte (1 byte = 8 bits = 2^8 possibilities for different numbers). '0''s ASCII is 48 and that's how we basically turn a number from a character to its true numeric value. for 0 (<code>48-48</code> = 0) and for 1 (<code>49-48 = 1</code>) as all number characters in the ASCII table are in a series.</p>
<p>The actual problem in the code isn't just efficiency as there is no need to run in two loops and so, you enter the numeric values of the numbers into C ! which turns them to different characters.</p>
",0
24090207,22309894,1,"<p>The realloc way is probably the best way to go.  Here's an example (small allocation size chosen for demo purposes.)  No error checking performed.  At the end of the loop, direntArray has the goods, and count tells you how many there are.</p>

<pre><code>#define num_to_alloc 10

int main(int argc, const char * argv[])
{

    struct dirent *direntArray = NULL;

    DIR *myDir = opendir(""/tmp"");
    int count = 0;
    int max = 0;
    struct dirent *myEnt;

    while ((myEnt = readdir(myDir))){
        if ( count == max ){
            max += num_to_alloc;
            direntArray = realloc(direntArray, max * sizeof(struct dirent));
        }
        memcpy(&amp;direntArray[count], myEnt, sizeof(struct dirent));
        count++;
    }
    return 0; 
}
</code></pre>
",0
25535876,25535721,0,"<p>Your first malloc casts to a pointer of pointer's but that doesn't mean it is.  If you look at your 2nd malloc you're allocating the same thing. So when you dereference <code>matriz[i][z]</code> you're dereferencing a charater, not a pointer.  So I believe, it's been a while since I've done C, your first malloc needs to be <code>(char**)malloc(sizeof(char*)*largo)</code>.</p>
",1
25536386,25535721,1,"<pre><code>char **matriz;
int i,j;
matriz = (char **)malloc(sizeof(char)*largo);
</code></pre>

<p>Your <code>matriz</code> variable is a pointer to an array of pointers, each of which points to an array of <code>char</code>. You first need to allocate memory for the array of pointers, which requires <code>largo</code> times the size of the pointers, which is <code>sizeof (char *)</code>. You only allocate space for <code>largo</code> times the size of a <strong>single</strong> <code>char</code>.</p>

<p>The easiest way to get the allocation right is to use the following pattern:</p>

<pre><code>p = malloc (n * sizeof *p);
</code></pre>

<p>In other words, allocate <code>n</code> times the size of whatever <code>p</code> points to. This will automatically allocate the right amount regardless of the type of <code>p</code>, assuming you get the <code>n</code> right. If you're declaring the pointer in the same line, it looks a little different:</p>

<pre><code>T *p = malloc (n * sizeof *p);  /* For some type T */
</code></pre>

<p>In this case there is an asterisk before <code>p</code> on <strong>both</strong> sides. This difference is something you will have to be aware of, especially when you have more than one level of indirection.</p>

<p>Your first allocation, using this pattern, would look like this:</p>

<pre><code>matriz = malloc (largo * sizeof *matriz); 
</code></pre>

<p>and the second:</p>

<pre><code>matriz[i] = malloc (ancho * sizeof *matriz[i]);
</code></pre>

<p>Note, that you never have to cast a void pointer (the return value of <code>malloc()</code>), and that the argument to the <code>sizeof</code> operator only needs parenthesis when it's a type name. When you get rid of the parenthesis, and place the quantity (<code>ancho</code>) before the <code>sizeof</code> operator, the result is an expression that is very clean and easy to understand. That is, of course, my personal opinion.</p>
",1
21594070,21593969,2,"<p>Add a declaration of <code>wordToInt()</code> before <code>main()</code>, or put the body of <code>wordToInt()</code> before <code>main()</code>.  Either way, the compiler gets to know the prototype of <code>wordToInt()</code>, and only so can the arguments be passed and return value be returned correctly.</p>
",3
21594073,21593969,7,"<p>First -- pay attention to your compiler's warnings, they matter!</p>

<p>Answer -- since you didn't prototype <code>wordToInt()</code> before using it, the compiler warned you that it had not been prototyped and it assumed the function returned an int (which is smaller than a long long)... so you got an int value returned, rather than a long long. The value printed within the function is correct because the function knew the proper type.</p>
",0
21594076,21593969,0,"<p>char array when given a string of characters always adds a <code>NULL</code> character to the end of the string automatically so make the size to 6</p>

<pre><code>char c[6] = ""ABCDE"";
</code></pre>

<p>And the output is consistent when i ran the same code with and without changes.</p>

<p>For char size 6</p>

<pre><code>Function item is :6566676869
Main  The item is :6566676869
</code></pre>

<p>For char size 5</p>

<pre><code>Function item is :656667686803780408
Main  The item is :656667686803780408
</code></pre>

<p>EDIT: I added a prototype before function call.</p>
",0
21594182,21593969,0,"<p>I copied and ran your program and its working. I found the same result in both segments. I don't know why you're getting erroneous answer in the main function. Anyway, here's how i did it.</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;
#include&lt;string.h&gt;
#include&lt;math.h&gt;

long long unsigned wordToInt(char *c)
{

  long long unsigned int k,item=0;
  int i,len;
  int j,p=0;
  len = (int) strlen(c);

  for(i = len-1;i&gt;=0;i--)
  {
          if(c[i] == 'c')
                  j = 42;
          else if(c[i] == '*')
                  j = 99;
          else
                  j = (int) c[i];
          j = j%100;
          k = pow(100,p);
          p++;
          item = item + (j*k);
  }
  printf(""Function item is :%llu\n"",item);
  return item;
}

int main()
{
    long long unsigned item;
    char c[5] = ""ABCDE"";
    item = wordToInt(c);
    printf(""Main The item is :%llu\n"",item);
    getch();
    return 0;
}
</code></pre>

<p>Then i compiled it with MinGW: gcc -c yourFileName.c
And then for executable: gcc -o executable yourFileName.o</p>
",1
30193007,30192625,3,"<p>In both cases only one <code>num</code> and one <code>result</code> instance will be created.<br>
The only different is that on <strong>Code 2</strong> <code>num</code> and <code>result</code> won't be accessible after the loop and the memory used to hold them can be reused for other members.</p>
",1
30193326,30192625,3,"<p><strong>Important:</strong> Where you declare a local variable in your source code has very little impact on when the actual allocation and deallocation (for example push/pop on the stack) takes place. If at all, the variable might get optimized away entirely. </p>

<p>Where in your C code you allocate your local variable has most likely no impact on performance what-so-ever. Therefore, you should declare local variables where it gives the best possible readability.</p>

<p>In both cases, the compiler will deduce that <code>num</code> is completely superfluous and optimize it away. No memory will be allocated for it.</p>

<p>In code 2, the compiler will deduce that the local variable <code>result</code> isn't used anywhere in the program, and therefore it will most likely optimize away the whole of code 2 into nothing.</p>

<p>The machine code of code 1 will look something like this:</p>

<pre><code>  allocate room for i
  allocate room for result
  set i to 0
loop:
  multiply i by i
  store in result
  if i is less than 500, jump to loop
</code></pre>
",0
30193954,30192625,1,"<blockquote>
  <p>Can anyone tell me the effect that the below code has on memory?</p>
</blockquote>

<p>As others have mentioned, the answer to your question hugely depends on the compiler you are using.</p>

<p>[1] Assuming you intend to use <code>result</code> and <code>num</code> later in the loop for other computations as in:</p>

<pre><code>for(int i=0; i&lt;500; ++i){
    int num = i;
    long result = num * num;

    // more operations using num and result, e.g. function calls, IO, etc.
}
</code></pre>

<p>, a modern compiler (gcc, llvm, mvc, icc) would be smart enough to optimise the two codes you provided to the same thing, thus in both codes the same ""memory location"" would be updated on each iteration.</p>

<p>I put ""memory location"" in quotes, as the variables can be promoted to registers, which, while strictly speaking are still memory, are a lot faster to access and thus a preferable location for frequently used variables.</p>

<p>The only difference between your codes is the <em>scope</em> of your variables, but you probably already know that.</p>

<p>If, conversly to [1], you don't intend to use your variables later, the compiler would probably detect that and just skip the loop, not generating any machine code for it, as it is redundant.</p>
",0
23592722,23592698,2,"<p>You need to add a forward declaration of one of the functions, like this:</p>

<pre><code>static void print (char title[MAX_TITLE_LENGTH+1] , char author[MAX_AUTHOR_LENGTH+1] , int year , int printed , int np , struct Book *print_pointer);
void descend_right (char title[MAX_TITLE_LENGTH+1] , char author[MAX_AUTHOR_LENGTH+1] , int year , int printed , int np , struct Book *print_pointer);
void descend_left (char title[MAX_TITLE_LENGTH+1] , char author[MAX_AUTHOR_LENGTH+1] , int year , int printed , int np , struct Book *print_pointer);
</code></pre>

<p>This serves as a promise to the compiler to define these functions some time later in the code of your program. It tells the compiler the names of the functions, their return types, and the types of their parameters - everything that it needs to know to produce an invocation of the function.</p>

<p>Add these three lines before the first function to fix the problem.</p>
",0
21782417,21782352,-1,"<p>You will need to add another semicolon after the struct definition. </p>

<p>edit: Try this.</p>

<pre><code>struct myNumber {
    double real;
    double imaginary;
};

struct myNumber c1 = {0.0,1.0};
struct myNumber c2 = {1.0,0.0};
struct myNumber c3;
</code></pre>

<p>You want to name your struct. Also, when initializing a struct variable you want to use curly braces. You said this works:</p>

<pre><code>struct {
    double real;
    double imaginary;
} c1 = {0.0,1.0};
</code></pre>

<p>I'm guessing since the struct is acting as a datatype this compiles but you will not be able to access that datatype later.</p>
",3
21782553,21782352,2,"<p>You need braces in the <code>c2</code> initialization, not parenthesis:</p>

<pre><code>struct {double real;double imaginary;} c1={0.0,1.0},c2={1.0,0.0},c3;
                                                       ^       ^
</code></pre>
",2
29535495,29535255,0,"<p>You can use strftime to get only the minutes part :</p>

<pre><code>#include &lt;time.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main(void)
{
  char buffer[0x100];
  time_t curtime;

  // Don't forget to check the return value !
  curtime = time(NULL);
  if (curtime == -1)
  {
    perror(""time()"");
    return 1;
  }

  strftime(buffer,0x100,""%M"",localtime(&amp;curtime));
  printf(""minutes: %s\n"", buffer);

  return 0;
}
</code></pre>

<p>No need to use gettimeofday here, use it only if you want a precision better than seconds.</p>
",0
29535753,29535255,0,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

int main()
{
    time_t curtime;
    char buffer[30];
    struct tm* tm_info;

    time(&amp;curtime);
    tm_info = localtime(&amp;curtime);

    strftime(buffer, 30, ""%Y-%m-%d %H:%M:%S"", tm_info);
    puts(buffer);

    return 0;
}
</code></pre>

<p>%Y:- will print year<br>
%m:- will print Month<br>
%d:- will print day<br>
%H:- will print Hour<br>
%M:- will print Minute<br>
%S:- will print Second</p>
",0
28225483,28225416,2,"<p>Instead of</p>

<pre><code>age = atoi(buffer);
printf(""%d\n"",age);


if (age == NULL)
{
    printf(""Nothing entered\n"");
}
</code></pre>

<p>Use</p>

<pre><code>if ( sscanf(buffer, ""%d"", &amp;age) != 1 )
{
    printf(""Nothing entered\n"");
}
else
{
    printf(""%d entered\n"", age);
}
</code></pre>
",3
28225546,28225416,2,"<p><code>atoi</code> is the wrong function to use when you have untrusted/potentially erroneous input (i. e. almost always).</p>

<p>Use <a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/strtol.html"" rel=""nofollow""><code>strtol()</code> (man page)</a> instead, which allows for extensive error checking.</p>

<p>Also, <strong>do check</strong> the return value of <code>fgets()</code>.</p>

<pre><code>char buf[100];
if (fgets(buf, sizeof buf, stdin)) {
    char *end;
    errno = 0;
    long n = strtol(buf, &amp;end, 10);

    // check for errors
    if (n == 0 || n == LONG_MIN || n == LONG_MAX) {
        if (errno != 0) {
            printf(""Erroneous input entered\n"");
        } else {
            // process valid input
        }
    } else {
        // process valid input
    }
} else {
    printf(""nothing was entered\n"");
}
</code></pre>

<p>By the way, it doesn't make sense to compare an <code>int</code> with <code>NULL</code> (which is a pointer). If this doesn't trigger at least a compiler warning (better yet, a hard error), you need to boost your compiler warning level or change to a modern compiler.</p>
",0
28225651,28225416,0,"<p>explanation of the behavior</p>

<pre><code>atoi(""x"") 
</code></pre>

<p>will return 0. This is becuase atoi stops on the first non digit</p>

<pre><code>if (age == NULL)
</code></pre>

<p>is then true because NULL is defined as 0 (basically)</p>

<p>You should check buffer first and then do atoi</p>
",1
24095793,24095701,8,"<p>I assume you did search google, but you need some help understanding what you have found:</p>
<p>I am quoting interchangeably  <a href=""http://www.gnu.org/software/libc/manual/html_node/Controlling-Buffering.html"" rel=""nofollow noreferrer"">gnu documentation</a> and <a href=""http://en.cppreference.com/w/cpp/io/c/setvbuf"" rel=""nofollow noreferrer"">cppreference</a>:</p>
<pre><code> int setvbuf (FILE *stream, char *buf, int mode, size_t size)
</code></pre>
<blockquote>
<p>After opening a stream (but before any other operations have been
performed on it), you can explicitly specify what kind of buffering
you want it to have using the setvbuf function. The facilities listed
in this section are declared in the header file stdio.h.</p>
</blockquote>
<p>The arguments description:</p>
<blockquote>
<p>stream     -   the file stream to set the buffer to</p>
<p>buffer     -   pointer to a buffer for the stream to use</p>
<p>mode   -   buffering mode to use. It can
be one of the following values:</p>
<p>_IOFBF    full buffering</p>
<p>_IOLBF    line buffering</p>
<p>_IONBF    no buffering
size   -   size of the buffer</p>
</blockquote>
<p>If you switch for the <code>c</code> documentation in <a href=""http://en.cppreference.com/w/c/io/setvbuf"" rel=""nofollow noreferrer"">cppreference</a> you will find the following example:</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
 
int main(void)
{
    int file_size;
    char buffer[BUFSIZ];
    FILE * fp = fopen(&quot;test.txt&quot;,&quot;w+&quot;);
    if (setvbuf(fp,buffer,_IOFBF,BUFSIZ) != 0)
    {
       perror(&quot;setvbuf()&quot;);
       fprintf(stderr,&quot;setvbuf() failed in file %s at line # %d\n&quot;, __FILE__,__LINE__-3);
       exit(EXIT_FAILURE);
    }
 
    /* Exhibit the contents of buffer. */
    fputs (&quot;aaa&quot;,fp);
    printf(&quot;%s\n&quot;, buffer);
    fputs (&quot;bbb&quot;,fp);
    printf(&quot;%s\n&quot;, buffer);
    fputs (&quot;ccc&quot;,fp);
    printf(&quot;%s\n&quot;, buffer);
    file_size = ftell(fp);
    printf(&quot;file_size = %d\n&quot;, file_size);
    fflush (fp);              /* flush buffer */
    printf(&quot;%s\n&quot;, buffer);
    fputs (&quot;ddd&quot;,fp);
    printf(&quot;%s\n&quot;, buffer);
    fputs (&quot;eee&quot;,fp);
    printf(&quot;%s\n&quot;, buffer);
 
    rewind(fp);               /* flush buffer and rewind file */
    char buf[20];
    fgets(buf,sizeof buf,fp);
    printf(&quot;%s\n&quot;, buf);
 
    fclose(fp);
 
    return 0;
}
</code></pre>
<p>Output:</p>
<pre><code>aaa
aaabbb
aaabbbccc
file_size = 9
aaabbbccc
dddbbbccc
dddeeeccc
aaabbbcccdddeee
</code></pre>
<p>Pay attention for the following things:</p>
<ol>
<li>What happens when you <code>fflush</code> the <code>FILE *fp</code>.</li>
<li>What <code>buffer</code> contains after <code>fputs</code> string to <code>fp</code>.</li>
<li>What happens when you <code>rewind(fp)</code>, reread from the file all you have been written.</li>
</ol>
<p>Don't be afraid of documentation/ manual pages, if you get used to them and read them you will be a great developer, moreover now you are familiar with <a href=""http://en.cppreference.com/"" rel=""nofollow noreferrer"">http://en.cppreference.com/</a>, which is very good source to get start with new API functions, good luck.</p>
",5
21597794,21597756,0,"<p><code>s1</code> &amp; <code>s2</code> are not declared which you are trying to read into them. 
I feel they should be <code>num1</code> &amp; <code>num2</code> which you been declared as integers.  </p>

<p>After <code>printf</code> you just read a char value into <code>i</code> using scanf and main ends doing nothing. </p>
",0
21597820,21597756,2,"<p>There is no way you could compile that, since <code>s1</code> and <code>s2</code> are undefined variables.</p>

<p>Thus, any information about what happened when you ran it is moot, since there is no way you could run it.</p>

<p>You meant:</p>

<pre><code>if(scanf(""%d %d"", &amp;num1, &amp;num2) == 2)
{
  printf(""Operands are %d and %d, now type initial of desired operation:\n"");
  if(scanf(""%c"", &amp;i) == 1)
  {
  }
}
</code></pre>

<p>It's important to check that <code>scanf()</code> has succeeded before relying on the return value.</p>
",0
21597828,21597756,1,"<p>use <code>scanf("" %c"",&amp;i);</code>
there is new line character is present in buffer,so it is not asking for any input and storing it in i.</p>
",0
22884051,22883980,2,"<p><a href=""https://stackoverflow.com/questions/3267311/what-is-newline-character-n"">I would say it depends on the operating system.</a></p>

<p>Notice that when you hit enter you hit ""\r\n"" and not only ""\n"".</p>

<p>Try running your code with input from a file, I bet it would work.</p>

<p>Also, if you are interested about <code>\n</code> then have a look at this <a href=""https://stackoverflow.com/questions/3267311/what-is-newline-character-n"">question</a> too.</p>
",0
26190393,26190362,1,"<p>Everything you need is in the <code>string.h</code> library.</p>

<p>Please try coding <em>something</em> with that library. If you still cannot get it to work, please update your question with your code.</p>
",2
22508980,22508881,4,"<ol>
<li><p>The <code>total++</code> seems wrong; what is that for?</p></li>
<li><p>You never assign anything to <code>perc</code> or <code>exp</code>.</p></li>
<li><p>You print out <code>d2</code> twice, but never <code>d12</code>.</p></li>
</ol>

<p>You should probably turn on some warnings.  With <code>-Wall</code>, clang says:</p>

<pre><code>example.c:22:41: warning: unused variable 'count' [-Wunused-variable]
int k, roll_1, roll_2, num_roll, total, count = 0 ;
                                        ^
example.c:58:48: warning: variable 'perc' is uninitialized when used here
      [-Wuninitialized]
     printf(""2:\t %d\t %.3f \t\t %.3f \n"", d2, perc, exp);
                                               ^~~~
example.c:24:15: note: initialize the variable 'perc' to silence this warning
    float perc, exp;
              ^
               = 0.0
example.c:58:54: warning: variable 'exp' is uninitialized when used here
      [-Wuninitialized]
     printf(""2:\t %d\t %.3f \t\t %.3f \n"", d2, perc, exp);
                                                     ^~~
example.c:24:20: note: initialize the variable 'exp' to silence this warning
    float perc, exp;
                   ^
                    = 0.0
3 warnings generated.
</code></pre>

<p>Adding <code>-Weverything</code> yields one more warning:</p>

<pre><code>example.c:25:11: warning: implicit conversion loses integer precision: 'long' to
      'unsigned int' [-Wshorten-64-to-32]
    srand((long)time(NULL));
    ~~~~~ ^~~~~~~~~~~~~~~~
</code></pre>

<p>That one you may or may not care about.</p>
",3
26126468,26126394,1,"<pre><code>int somthing(int i)
{
  if(i == 0)
    return 0;
  else
    printf(""%d,"", i);
    somthing (--i);
}
</code></pre>

<p>Do this instead. See if this works</p>
",1
26126543,26126394,3,"<p><strong>I did post decrement on i variable one less value should go into loop every time and it should print values from 9 to 0</strong></p>

<p>what you are using <code>i--</code> is post increment. It would send the value of i to the <code>something()</code> function and then decrement the value of <code>i</code>. so, the <code>somthing()</code> function always gets the value <code>9</code>. thus it goes to an infinite recursive call.</p>

<p>what you need is preincrement <code>--i</code>. It will decrement the value of <code>i</code> and then send it to the function <code>somthing()</code></p>
",0
22887279,22887260,4,"<p>You need to call <code>fscanf</code> not <code>scanf</code>. Take the habit of reading the documentation of functions you are using, here on <a href=""http://man7.org/linux/man-pages/man3/scanf.3.html"" rel=""nofollow"">scanf(3)</a>. If you have the chance of coding on Linux, type </p>

<pre><code>man scanf
</code></pre>

<p>and compile with</p>

<pre><code>gcc -Wall -Wextra -Wpedantic -g yourfile.cc -o yourprog
</code></pre>

<p>then learn how to use the <a href=""https://sourceware.org/gdb/download/onlinedocs/"" rel=""nofollow"">GDB debugger</a> (<code>gdb</code>) and run</p>

<pre><code>gdb yourprog
</code></pre>

<p>BTW, giving precision in <code>scanf</code> format is useless. Using the result of <code>scanf</code> or <code>fscanf</code> is good practice</p>

<pre><code>   int nbread = fscanf(fptr, ""%d %f %f %f"", 
      &amp;item[i].frame, &amp;item[i].elec, &amp;item[i].vdw, &amp;item[i].total);
   if (nbread != 4) {
      fprintf(stderr, ""failed to read entry #%d (%s)\n"", 
              i, strerror(errno));
      exit(EXIT_FAILURE);
   }
</code></pre>

<p>BTW, you could remove most spaces in <code>scanf</code> formats. I usually keep them to 
have the format strings more readable.
You need </p>

<pre><code>   #include &lt;string.h&gt;
   #include &lt;errno.h&gt;
</code></pre>

<p>for <code>strerror</code> and <code>errno</code> so read <a href=""http://man7.org/linux/man-pages/man3/strerror.3.html"" rel=""nofollow"">strerror(3)</a> and <a href=""http://man7.org/linux/man-pages/man3/errno.3.html"" rel=""nofollow"">errno(3)</a></p>

<p>I also suggest to end <code>printf</code> format strings with <code>\n</code> (since <code>stdout</code> is buffered, see <a href=""http://man7.org/linux/man-pages/man3/stdout.3.html"" rel=""nofollow"">stdout(3)</a>!) or else use <a href=""http://man7.org/linux/man-pages/man3/fflush.3.html"" rel=""nofollow"">fflush(3)</a> at appropriate places.</p>
",0
22887321,22887260,1,"<p><code>scanf</code> and <code>fscanf</code> are different. <code>scanf</code>'s first argument is the format string; it outputs to <code>stdout</code> by default. The one you want is <code>fscanf</code>, which takes the output pointer as its first argument and the format string second. See <a href=""http://pubs.opengroup.org/onlinepubs/009604599/functions/fscanf.html"" rel=""nofollow"">this</a>.</p>
",0
22887387,22887260,1,"<p>Use <code>fscanf</code> instead of <code>scanf</code>, as others already said. Also add ampersands in front of arguments to scanning function.<br>
You might also remove TAB characters (""\t"") from the scanning format.</p>

<pre><code>fscanf(fptr, ""%d%.4f%.4f%4.f"", &amp;item[i].frame, &amp;item[i].elec, &amp;item[i].vdw, &amp;item[i].total);  
</code></pre>
",0
22890679,22890660,5,"<p>Use a <a href=""http://en.wikipedia.org/wiki/Random_seed"">random seed</a> that changes each time you run the program. One common approach is to use the current time.</p>

<pre><code>srand(time(NULL));
</code></pre>
",4
22890683,22890660,2,"<p>You need to <a href=""http://en.wikipedia.org/wiki/Random_seed"" rel=""nofollow noreferrer"">seed</a> your <a href=""http://en.wikipedia.org/wiki/Pseudorandom_number_generator"" rel=""nofollow noreferrer"">PRNG</a>. Read <a href=""http://man7.org/linux/man-pages/man3/rand.3.html"" rel=""nofollow noreferrer"">rand(3)</a> &amp; <a href=""http://man7.org/linux/man-pages/man3/random.3.html"" rel=""nofollow noreferrer"">random(3)</a> man pages.</p>

<p>As <a href=""https://stackoverflow.com/a/22890679/841108"">guest answered</a> you could use the current time (with <code>#include &lt;time.h&gt;</code>, see <a href=""http://man7.org/linux/man-pages/man2/time.2.html"" rel=""nofollow noreferrer"">time(2)</a>) as a seed.</p>

<pre><code>time_t now;
time(&amp;now);
srand((unsigned)now);
</code></pre>

<p>But on Linux you could also use the <code>/dev/urandom</code> device (at least for seeding) - see <a href=""http://man7.org/linux/man-pages/man4/random.4.html"" rel=""nofollow noreferrer"">random(4)</a> for more, or the current pid (see <a href=""http://man7.org/linux/man-pages/man2/getpid.2.html"" rel=""nofollow noreferrer"">getpid(2)</a> to get it using <code>#include &lt;sys/type.h&gt;</code> and <code>#include &lt;unistd.h&gt;</code>).</p>

<pre><code>{ unsigned s = (unsigned)getpid();
  FILE* f = fopen(""/dev/urandom"", ""r"");
  if (f) { fread (&amp;s, sizeof(s), 1, f); fclose(f); };
  srand(s);
}
</code></pre>

<p>If using <code>random</code>, replace <code>srand</code> with <code>srandom</code> ....</p>

<p>BTW, <code>random(3)</code> is supposed to be a better PRNG than <code>rand(3)</code></p>

<p>Also, you might read your random numbers directly from <code>/dev/urandom</code> (or even <code>/dev/random</code> which could block!); but it is generally not worth the effort. And <code>/dev/urandom</code> or <code>/dev/random</code> is available on Linux but probably not on many other systems.</p>
",0
29248016,29247980,4,"<p>Rule #1 with macros is to enclose all arguments in parentheses, to avoid exactly the problem that you're seeing.</p>

<pre><code>#define _valid_pagesize(_newsize) (!((_newsize) % 0x80000000)?1:      \
    (!((_newsize) % 0x40000000)?1:      \
    (!((_newsize) % 0x10000000)?1:      \
    (!((_newsize) % 0x4000000) ?1:0))))
</code></pre>

<p>When you pass <code>a+b</code> to the macro, it expands to </p>

<pre><code>a + b % 0x40000000
</code></pre>

<p>and since <code>%</code> has higher precedence than <code>+</code>, you don't get the result you expect. By enclosing the argument in parentheses, the macro expands to</p>

<pre><code>(a + b) % 0x40000000
</code></pre>

<p>which works as expected.</p>
",0
29248021,29247980,3,"<p>Macro parameters aren't evaluated prior to being passed to the macro, since macro expansion occurs prior to compilation. Instead, the actual expression is passed unchanged into the macro, and is substituted into all occurrences of the parameter name. Therefore, <code>_valid_pagesize(a+b)</code> expands to this:</p>

<pre><code>(!(a+b % 0x80000000)?1:      \
    (!(a+b % 0x40000000)?1:      \
    (!(a+b % 0x10000000)?1:      \
    (!(a+b % 0x4000000) ?1:0))))
</code></pre>

<p>Now, the reason it produces wrong answers is hopefully obvious. Follow user3386109's advice about enclosing the parameter in parentheses.</p>
",0
29248030,29247980,1,"<p>Put _newsize inside braces in the macro expansion </p>
",1
22121379,22121088,0,"<p>Part of the problem is </p>

<p><code>while ((aux-&gt;prox!=NULL)||(aux-&gt;prox-&gt;time&lt;=time))</code></p>

<p>I guess you meant </p>

<p><code>while ((aux-&gt;prox!=NULL)&amp;&amp;(aux-&gt;prox-&gt;time&lt;=time))</code></p>

<p>I did not look for other problem.</p>

<p>Bye,</p>

<p>Francis</p>
",3
22121433,22121088,0,"<p>I see a mistake here:</p>

<pre><code>else if (aux-&gt;prox == NULL)
{
    if (aux-&gt;time &lt;= time)
    {
        aux-&gt;prox = newelement;
        newelement-&gt;prox = NULL;
    }
    else
    {
        *list = newelement;
        newelement-&gt;prox = aux;
    }
}
</code></pre>

<p>It should be</p>

<pre><code>    else if (aux-&gt;prox == NULL)
    {
        if (aux-&gt;time &lt;= time)
        {
            aux-&gt;prox = newelement;
            newelement-&gt;prox = NULL;
        }
        else
        {
            newelement-&gt;prox = aux;
            *list = newelement;
        }
    }
</code></pre>

<p>Otherwise you overwrite what <code>*list</code> was pointing to before copying it.</p>
",0
22521069,22521003,1,"<p>The point is that your functions never <em>returns</em>.</p>

<p>Your loops never finish because when <code>isalpha() == 0</code> you <code>continue</code> and so the <code>i</code> is not incremented. Remember that continue jumps to the start of the loop.</p>

<p>You will be better with a <code>for</code> loop:</p>

<pre><code>for (i = 0; (cur= word[i]) != 0; ++i)
{
    if (...)
        continue;
}
</code></pre>

<p>Now, the <code>continue</code> will jump to the increment expression.</p>

<p>BTW, why the convoluted <code>*(word + i)</code> instead of <code>word[i]</code>? They are exactly the same!</p>

<p>PS: please, do not use <code>gets()</code>. It is deprecated. Use <code>fgets(stdin,...)</code> instead.</p>
",2
22462631,22462549,0,"<p>The tests increment. The loop executes and enters the text, <code>while(i++&gt;5);</code> evaluates false, but i becomes 2. <code>while(i++&gt;4);</code> evaluates false, but i becomes 3. <code>while(i++&gt;3);</code> evaluates false (because of post-incrementing), but i becomes 4.</p>
",0
22462637,22462549,1,"<p><strong>1st conditions</strong></p>

<pre><code>while(i++&gt;5);
</code></pre>

<p>here i =1, it fails but increments it to 2.</p>

<p><strong>2nd condition</strong>  </p>

<pre><code>while(i++&gt;4);
</code></pre>

<p>again fails but increments i to 3</p>

<p><strong>3rd conditions</strong></p>

<pre><code>while(i++&gt;3);
</code></pre>

<p>again fails but increments i to 4</p>

<p>So, you end up with a 4</p>
",0
23087536,23087380,3,"<p>If there will always be only three words in the input, then yes can most definitely use <a href=""http://en.cppreference.com/w/c/io/fscanf"" rel=""nofollow""><code>scanf</code></a>, because it actually does simple pattern matching:</p>

<pre><code>if (scanf(""%[^ ,] , %[^ ,] , %[^ \n]"", string1, string2, string3) == 3)
{
    /* Read three words */
}
</code></pre>

<p>If you can have a variable number of words, then read about <a href=""http://en.cppreference.com/w/c/string/byte/strtok"" rel=""nofollow""><code>strtok</code></a>.</p>
",11
22891069,22891055,1,"<p>Just don't put space in the <code>printf</code> call:</p>

<pre><code> z = (10*x+y)*a;
 printf(""%d = %d%d * %d"", z, x, y, a);
</code></pre>

<p><strong>EDIT:</strong></p>

<p>To handle the general case, where <code>y</code> has more than one digit use this:</p>

<pre><code>no_of_digs = ceil(log(y)/log(10));
z = (pow(10, no_of_digs)*x+y)*a;
printf(""%d = %d%d * %d"", z, x, y, a);
</code></pre>
",3
22891751,22891055,0,"<pre><code>#include&lt;stdio.h&gt;

int main() {
    char x[16], y[16], xy_s[32];
    int xy, a, z;
    scanf(""%15s %15s %d"", x, y, &amp;a);
    sprintf(xy_s, ""%s%s"", x, y);
    sscanf(xy_s, ""%d"", &amp;xy);
    z = xy * a;
    printf(""%d\n"", z);
    return 0;
}
</code></pre>
",0
21786300,21786223,0,"<pre><code>int i,j;
for (i=1; i&lt;5; i++){
    for (j=1; j&lt;=i; j++){ // it will print i spaces whenever i increases. 
        printf("" "");
    }
}
</code></pre>
",0
21786309,21786223,0,"<pre><code>int i, j;

for(i = 0; i &lt; 10; i++){
  for(j = 0; j &lt; i; j++) printf("" "");
  printf(""\n"");
}
</code></pre>
",0
24358417,24358375,4,"<p>With the caveat that this method is <em>utterly unportable</em> as T.C. mentions, and the additional caveat that it almost certainly will not work if optimizations are turned on, you can read the return address from the stack by reading off the end of a buffer, as in the example below. </p>

<pre><code>int main()
{
    f1();
    return 0;
}
void f1()
{
    f2();
}
void f2() {
    char buf[4];
    printf(""%p\n"", *(void**)(buf + 8));
}
</code></pre>

<p>Note that the number <code>8</code> above will vary based on operating system, architecture, and compiler padding, so you will most likely have to try a variety of different numbers to make it work.
The choice of <code>8</code> for the example assumes padding up to a 4-byte boundary, and 4-byte pointers on a 32-bit system.</p>

<p>You also have to make sure optimizations are <strong>turned off</strong>.</p>

<p>The reason why this works at all is because the structure of the stack immediately after a function call looks kind of like this.</p>

<pre><code>|Return Address|
|Saved Frame Pointer|
|Local Variables|
</code></pre>

<p>Observe that the return address is at a higher address than the Local Variables. That is the reason that reading past the end of a buffer will allow you to potentially read the return address.</p>

<p>The reason why this breaks with optimizations is that compiler might decide to inline one or both functions, or realize one of them is doing nothing at all and optimize the function call away entirely, which blows aside the assumptions about the stack.</p>
",15
25535276,25535050,1,"<pre><code>#include &lt;stdio.h&gt;

#define MAX_STRING_COUNT 1000
#define MAX_STRING_LENGTH 100

int main()
{
    int n;
    char str[MAX_STRING_COUNT][MAX_STRING_LENGTH];
    int ret = scanf(""%d\n"",&amp;n);
    if (ret != 1 || n &lt; 0 || n &gt; MAX_STRING_COUNT) {
        puts(""Wrong number of strings!\n"");
        return 1;
    }

    for(int i = 0; i &lt; n; i++) {
        ret = fgets(str[i], MAX_STRING_LENGTH, stdin);
        if (ret == NULL) {
            puts(""Error reading string\n"");
            return 1;
        }
    }
    return 0;
}
</code></pre>

<p><strong>Never read unbound strings</strong>. That may cause an overflow, that is security flow in your program.</p>
",8
25535294,25535050,0,"<p>You've tagged this with C++ so I assume you can use C++ for this solution.</p>

<p>If so, you can use <code>std::cin</code> and <code>std::string</code>:</p>

<pre><code>int main() {
   int n;
   std::string s;

   cout &lt;&lt; ""How many strings do you want to enter?"" &lt;&lt; std::endl;

   // Get the user input and store it in n
   cin &gt;&gt; n;

   // Ask for a string n times
   for (int x = 0; x &lt; n; x++) {
      cout &lt;&lt; ""Enter a string:"" &lt;&lt; std::endl;

      // Get the user input string and put it in s
      cin &gt;&gt; s;

      // Do something with the string here
   }
   return 0;
}
</code></pre>

<p>You'll want to do error checking and I haven't included the headers you need, but this is the core of the procedure.</p>
",0
25537409,25535050,0,"<pre><code>#include&lt;stdio.h&gt;

int main(){
    int n;
    scanf(""%d"", &amp;n);
    char str[n][1000];

    for(int i=0;i&lt;n;i++){
        scanf(""%999s"", str[i]);
    }
    for(int i=0;i&lt;n;i++){
        printf(""%s\n"", str[i]);
    }

    return 0;
}
</code></pre>
",0
29507203,29506987,2,"<p><sup><em>Transferring a comment into an answer.</em></sup></p>

<p>Yes, you can add an <code>if</code> statement somewhere, but the <code>push()</code> function is the best place to do that. It's best because it is the one place where you know that more capacity is needed if you are at the current limit. Unless you have an 'increase capacity' function, only the <code>push()</code> function can ever need to grow the stack, so that's the only place where it is relevant to test whether you need to add more memory to the stack.</p>

<p>Note that you currently have a fixed upper-bound on the stack size.  You'll need to make that into a variable.  Remember to think carefully about the initialization conditions.</p>
",0
23586348,23586316,0,"<p>a char is really just an 8 bit number, so a single char alone is no different than an int, except that it can only store smaller numbers. In your printf statement you have </p>

<pre><code>%s
</code></pre>

<p>but a single char is not considered a string, just a number, so you should use </p>

<pre><code>%c or %d
</code></pre>

<p>for you printf statement. If you had an array of chars, then you would use %s</p>
",1
23586397,23586316,0,"<p>Try this instead:  </p>

<blockquote>
  <p>printf(""%c \n"", b);  </p>
</blockquote>

<p>The compiler is casting the char to int on the fly, so the error msg makes sense (at least to someone used to interpreting C compiler messages).</p>
",1
23586407,23586316,5,"<p>The compiler is certainly correct to warn about the call. <code>printf</code> with a <code>""%s""</code> specifier requires an argument of type <code>char*</code> (which must point to a string), and the argument you pass is not of that type.</p>

<p>As for why the warning message refers to <code>int</code> rather than <code>char</code>, it's because <code>printf</code> is a <em>variadic</em> function. The first parameter, the format string, is declared to be of type <code>const char*</code>, but the following arguments are specified only as <code>, ...</code>. In this special case, arguments of integer types narrower than <code>int</code> are <em>promoted</em> to <code>int</code> or to <code>unsigned int</code>. So even though the expression <code>b</code> is of type <code>char</code>, the actual argument that's passed to <code>printf</code> is of type <code>int</code>; specifically, it's the result of converting the value of <code>b</code> from <code>char</code> to <code>int</code>.</p>
",0
23586544,23586316,1,"<p>The warning is accurate, though the reasons are modestly obscure.</p>

<p>The declaration of <code>printf()</code> is:</p>

<pre><code>int printf(const char *restrict format, ...);
</code></pre>

<p>The <code>const</code> and <code>restrict</code> keywords aren't important for this discussion.  What is important is the ellipsis, <code>...</code>.  When arguments are passed to a function with a variable argument list (a <em>variadic</em> function), they undergo 'default argument conversions'.  Integer types shorter than <code>int</code> (<code>short</code> and <code>char</code> in their various forms) are promoted to <code>int</code>, and <code>float</code> values are promoted to <code>double</code>.  Thus, the value of <code>b</code> is converted to <code>int</code> by the rules for calling a variadic functions.</p>

<p>The <code>""%s""</code> format expects to be given a pointer to a null-terminated character string.  The variable <code>b</code> is a single <code>char</code>, not a string.  Consequently, the compiler is correctly warning you that you will not get good results from running the program.</p>

<p>In this context, using a format such as <code>%c</code> (to print a character) or <code>%d</code> (to print a decimal integer) is probably best:</p>

<pre><code>printf(""%c\n"", b);
</code></pre>

<hr>

<p>As a general rule, at this stage in your C programming career, you should assume the compiler is right and that you're wrong.  Remember, the C compiler knows a lot more about C than you do.  This isn't to say that there are never bugs in compilers.  However, the chances of you finding one are slim.  Until you know enough about C (maybe in five to ten years time), then you should assume the compiler is right, you're wrong, and work out (a) what the compiler means and (b) how to fix it.</p>

<p>It was not always thus.  Thirty years ago, bad compilers existed because the best were not all that much better.  It was possible to find bugs in those compilers.  There has, however, been a serious winnowing and few incompetent compilers are left on the market.  One area where you can sometimes find compilers with surprising limitations (occasionally tantamount to bugs) is in specialized embedded systems for obscure chips.  However, in mainstream o/s for desktops and servers (and tablets and smart phones), you're unlikely to come across a seriously defective compiler.</p>

<hr>

<h3>ISO/IEC 9899:2011 ¡ì6.5.2.2 Function calls</h3>

<blockquote>
  <p>?6 If the expression that denotes the called function has a type that does not include a
  prototype, the integer promotions are performed on each argument, and arguments that
  have type <code>float</code> are promoted to <code>double</code>. These are called the <em>default argument
  promotions</em>. If the number of arguments does not equal the number of parameters, the
  behavior is undefined. If the function is defined with a type that includes a prototype, and
  either the prototype ends with an ellipsis (<code>, ...</code>) or the types of the arguments after
  promotion are not compatible with the types of the parameters, the behavior is undefined.
  If the function is defined with a type that does not include a prototype, and the types of
  the arguments after promotion are not compatible with those of the parameters after
  promotion, the behavior is undefined, except for the following cases:</p>
  
  <ul>
  <li><p>one promoted type is a signed integer type, the other promoted type is the
  corresponding unsigned integer type, and the value is representable in both types;</p></li>
  <li><p>both types are pointers to qualified or unqualified versions of a character type or
  <code>void</code>.</p></li>
  </ul>
</blockquote>

<p>The 'integer promotions' are defined in ¡ì6.3.1.8 Usual arithmetic conversions.  They're more complex than I want to go through here.</p>
",0
32985899,32985809,0,"<p>You can try like this:</p>

<pre><code>su username -c 'ls /long/dir/user/yourfilename'
</code></pre>

<p>or</p>

<pre><code>su username -s /bin/sh -c 'ls /long/dir/user/yourfilename'
</code></pre>
",0
32986078,32985809,0,"<pre><code>#include&lt;stdio.h&gt;
#include&lt;sys/stat.h&gt;
#include&lt;stdlib.h&gt;
int main(int argc, char *argv[])
{
int i=0;
struct stat buf;
char ptr[]=""test.txt"";
printf(""%s: "",ptr);
if (stat(ptr, &amp;buf) &lt; 0)
{
perror(""stat error\n"");
return;
}
if(buf.st_mode &amp; S_IROTH)
{
 printf(""The Others have a read permission for file %s\n"",ptr);
}
 exit(0);
}
</code></pre>

<p>In this above example gives others have a read permission or not for the file test.txt in current directory.</p>

<p>Using the following macros to check permissions for user and others and group.</p>

<p>S_IRWXU  - Read, write and execute permissions for owner</p>

<p>S_IRUSR  - Owner has read permission</p>

<p>S_IWUSR  - Owner has write permission</p>

<p>S_IXUSR  - Owner has execute permission</p>

<p>S_IRWXG  - Read, write and execute permissions for group</p>

<p>S_IRGRP  - Group has read permission</p>

<p>S_IWGRP  - Group has write permission</p>

<p>S_IXGRP  - Group has execute permission</p>

<p>S_IRWXO  - Read, write and execute permissions for others</p>

<p>S_IROTH  - Others have read permission</p>

<p>S_IWOTH  - Others have write permission</p>

<p>S_IXOTH  - Others have execute permission</p>

<p>Using the above macros to modify the code based on what you want in the if condition in the example(if(buf.st_mode &amp; S_IROTH)).</p>
",0
32986252,32985809,1,"<p>You should use <em>stat</em> function, or <em>fstat</em> if you want to use file descriptor instead of path. </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;  
#include &lt;sys/stat.h&gt;
int main()
{
    char *f = ""test.ts"";

    struct stat *buff = malloc(sizeof(struct stat));
    if (stat(f,buff) &lt; 0)
    return 1;

    printf(""Information for %s\n"",f);

    printf(""File Permissions: \t"");
    printf( (S_ISDIR(buff-&gt;st_mode)) ? ""d"" : ""-"");
    printf( (buff-&gt;st_mode &amp; S_IRUSR) ? ""r"" : ""-"");
    printf( (buff-&gt;st_mode &amp; S_IWUSR) ? ""w"" : ""-"");
    printf( (buff-&gt;st_mode &amp; S_IXUSR) ? ""x"" : ""-"");
    printf( (buff-&gt;st_mode &amp; S_IRGRP) ? ""r"" : ""-"");
    printf( (buff-&gt;st_mode &amp; S_IWGRP) ? ""w"" : ""-"");
    printf( (buff-&gt;st_mode &amp; S_IXGRP) ? ""x"" : ""-"");
    printf( (buff-&gt;st_mode &amp; S_IROTH) ? ""r"" : ""-"");
    printf( (buff-&gt;st_mode &amp; S_IWOTH) ? ""w"" : ""-"");
    printf( (buff-&gt;st_mode &amp; S_IXOTH) ? ""x\n"" : ""-\n"");

    return 0;
}
</code></pre>
",0
22135432,22135210,0,"<p>So, the best way to see what is going on in your code or where u get garbage, after all scanf print the value
ex:</p>

<pre><code>double a;
scanf(""%f"",&amp;a);
printf(""a=%f"",a); //OR
printf(""a=%3.3f"",a);
</code></pre>

<p>and you can easy see if the problem is in your scanf or somewhere else..</p>
",2
22132855,22132249,0,"<p>Is this question about C? I saw the q tag but I'm not sure, as you talk about compiler...</p>
<p>Anyway, in C it is done with <code>*</code>:</p>
<blockquote>
<p><code>*</code>   The width is not specified in the format string, but as an additional integer value argument preceding the argument that has to be formatted.</p>
<p><code>.*</code>  The precision is not specified in the format string, but as an additional integer value argument preceding the argument that has to be formatted.</p>
</blockquote>
<pre><code>printf (&quot;Width trick: %*d \n&quot;, 5, 10);
Width trick:    10
</code></pre>
<p><a href=""http://www.cplusplus.com/reference/cstdio/printf/"" rel=""nofollow noreferrer"">http://www.cplusplus.com/reference/cstdio/printf/</a></p>
",0
27541841,23294438,1,"<p>Since from your image you appear to be using DosBox and (ugh!) Turbo C, that means you're running under DOS of some description.</p>

<p>So it will almost certainly still have the 8.3 limit on file names, meaning that <code>newheader.h</code> will be too long.</p>

<p>Try shortening it to something that will fit within the confines of your environment, such as <code>newhdr.h</code> (both for the file and the <code>#include</code>).</p>
",1
22123341,22123320,4,"<p>You SHOULD NOT (although yes, sometimes it CAN return the expected result!) return local variable pointer from a function as it is allocated on stack!</p>

<p>Here's an excellent explanation as to why: <a href=""https://stackoverflow.com/questions/6441218/can-a-local-variables-memory-be-accessed-outside-its-scope"">Can a local variable&#39;s memory be accessed outside its scope?</a></p>

<p>To make your code work,replace</p>

<pre><code>char cadena_nueva[largo_texto+1]; 
</code></pre>

<p>with</p>

<pre><code>char* cadena_nueva = (char*)malloc(sizeof(char)*(largo_texto+1));
</code></pre>

<p>Don't forget to <code>free()</code> it when you are done using it</p>

<hr>

<p>It would really help you if you'd read about heap &amp; stack memory storage:</p>

<p><a href=""https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap"">What and where are the stack and heap?</a>
<a href=""http://gribblelab.org/CBootcamp/7_Memory_Stack_vs_Heap.html"" rel=""nofollow noreferrer"">http://gribblelab.org/CBootcamp/7_Memory_Stack_vs_Heap.html</a>
<a href=""http://www-ee.eng.hawaii.edu/~tep/EE160/Book/chap14/subsection2.1.1.8.html"" rel=""nofollow noreferrer"">http://www-ee.eng.hawaii.edu/~tep/EE160/Book/chap14/subsection2.1.1.8.html</a></p>
",6
22117985,22117055,0,"<p>As other have suggested <code>""%d-%d-%d""</code>.  </p>

<p>To add error checking, should code need to insure no trailing garbage and all was there:</p>

<pre><code>char date[80];
fgets(data, sizeof date, stdin);

int d,m,y;
in n;
int cnt = sscanf(date, ""%d-%d-%d%n"", &amp;d, &amp;m, &amp;y, &amp;n);

if (cnt == 3 &amp;&amp; date[n] == '\n') Good();
else Bad();
</code></pre>
",0
22117073,22117055,0,"<p>Yes, with the <code>%d-%d-%d</code> format.</p>

<p>If reading from STDIN, use <code>scanf</code>, from a file use <code>fscanf</code> and from a string use <code>sscanf</code></p>
",1
22117079,22117055,12,"<pre><code>char date[]=""20-02-2015"";
int d,m,y;
sscanf(date,""%d-%d-%d"",&amp;d,&amp;m,&amp;y);
</code></pre>
",2
22117125,22117055,0,"<p>you can divide the string using strtok(date,""-"") then can use atoi() to get the date, month and year as numbers. check this <a href=""https://stackoverflow.com/questions/22116327/to-get-integer-from-string/22116364?noredirect=1#comment33551696_22116364"">link</a> it can help you </p>
",2
22117143,22117055,2,"<p>Assuming that your string is given as <code>char* str</code> or as <code>char str[]</code>, you can try this:</p>

<pre><code>int day,mon,year;
sscanf(str,""%d-%d-%d"",&amp;day,&amp;mon,&amp;year);
</code></pre>

<p>Or you can try this, for a slightly better performance (by avoiding the call to <code>sscanf</code>):</p>

<pre><code>int year = 1000*(str[6]-'0')+100*(str[7]-'0')+10*(str[8]-'0')+(str[9]-'0');
</code></pre>
",0
22117145,22117055,1,"<p>You can use the <a href=""http://en.cppreference.com/w/c/string/byte/strtok"" rel=""nofollow"">strtok()</a> function to split a string (and specify the delimiter to use)</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main() 
{  

 char *date = malloc(10);
 char *day = NULL;
 char *month = NULL;
 char *year = NULL;

 strcpy(date, ""01-03-2014"");

 day = strtok(date, ""-"");
 printf(""%s\n"",day);

 month = strtok(NULL, ""-"");
 printf(""%s\n"",month);

 year = strtok(NULL, ""-"");
 printf(""%s\n"",year);


free(date);
    return 0;
}
</code></pre>

<p>the output :</p>

<pre><code> 01
 03
 2014
</code></pre>
",0
22882118,22882043,0,"<p>The problem is that you are writing the result of the concatenation on top of one of the input strings. At the moment the first loop (over string1) does nothing; it is just copying string1 on top of itself character by character. I think you might be getting confused between the newline character '\n' and the string termination character '\0' as well.</p>

<p>The reason you are getting segfaults is that in the second loop you start writing onto the memory that follows the first input string. Only 81 characters of memory are reserved for it, but you might write more than that for the concatenation.</p>

<p>I think the answer would be to create a new string to contain the result of your function. You need to find out how long it needs to be by looping over the input strings first, counting their length. Then when you copy the two strings into the result you will only use the space that you have reserved for it in memory. Also you won't change the input as part of the function, which is another problem with the current method.</p>
",2
22882792,22882043,0,"<p>A string is an array of characters containing a terminating null character <code>'\0'</code>, not a newline character <code>'\n'</code>. Therefore, in <code>strcat406</code> function, you should check the value for the null byte and not the newline character. Note that <code>str2</code> must be large enough for <code>string2</code> to be appended to it else it will cause buffer overflow invoking undefined behaviour. Also note that the lengths of both the strings <code>string1</code> and <code>string2</code> should each be less than <code>81</code> and the sum of their lengths should be less than <code>81 + 81 == 162</code>. </p>

<pre><code>#include &lt;stdio.h&gt;

char *strcat406(char string1[], char string2[]) {
    int i = 0, j = 0;
    // increment i till the terminating null byte is reached
    while(string1[i++]) ; // the null statement

    i--;  // reset i to the index of the null byte

    // copy the characters from string2 to string1 till and 
    // including the terminating null byte of string2
    while((string1[i++] = string2[j++])) ; // the null statement

    return string1;
}

int main(void) { 
    char str1[81], str2[81]; 
    char again = 'y';

    while(again == 'y') { 
        printf(""Enter a string\n""); 
        scanf(""%s"", str1); 
        printf(""Enter another string\n""); 
        scanf(""%s"", str2); 
        printf(""The concatention is %s\n"", strcat406(str1, str2)); 
        printf(""Second test:  The concatenation is %s\n"", str1);
        printf(""The second string is still %s\n"", str2); 
        printf(""Again? (y/n)\n"");

        // note the leading space in the format string of scanf.
        // this reads and discards the newline left in the buffer in 
        // the previous scanf call
        scanf("" %c"", &amp;again);  
    }
    return 0;
}
</code></pre>
",1
22882096,22882043,2,"<p>The problem is that your <code>while</code> loops are looking for a newline character to terminate, but <code>scanf(""%s"", ...)</code> won't include the ending newline in the scanned string. You should look for <code>'\0'</code> to terminate those loops.</p>

<p>By the way... the title of this question reflects a misunderstanding. You said you're getting a segfault, but ""have no infinite loops"". Segfaults are not normally caused by infinite loops. They are commonly caused by dereferencing a null pointer, or a pointer which is ""bad"" in some other way. Note that array indexing is a form of pointer dereference, so using a ""bad"" array index is just the same thing.</p>
",0
23111469,23111144,1,"<p>You can't.</p>

<p>The function just receives a pointer (an address to a location in memory).</p>

<p>You have two options: pass the lenght of the array as an extra argument to the function (as other suggested)...</p>

<p>...or establish a convention (if possibile) where a certain value on the array represent the last element (so you can get the length by counting elements until the end-of-array item).</p>

<p>That's what happens with C strings. A C string is an array of <code>char</code>s where a character with value of <code>0</code> indicates the end of the string.</p>
",0
23111249,23111144,6,"<p>Arrays decay to pointers when used as arguments to a function:</p>

<pre><code>int function(int a[]);
</code></pre>

<p>and</p>

<pre><code>int function(int *a);
</code></pre>

<p>are the same.</p>

<p>This means that you cannot know how many elements are in an array that is passed to your function unless you have a separate parameter that indicates the length of the array.</p>
",0
23111270,23111144,4,"<p>You can find out how many elements there are in <code>arr</code> in <code>main()</code> by <code>sizeof(arr)/sizeof(arr[0])</code>. </p>

<p>However, you cannot use this method in that <code>function()</code>. Because in this case <code>a</code> is a pointer to <code>int</code>, you need to pass the length of <code>a</code> as an extra argument to <code>function()</code>, like this:</p>

<pre><code>int function(int a[], int len) {
</code></pre>
",0
23113697,23111144,-2,"<pre><code>#include&lt;stdio.h&gt;

int ArraySize (int *); 

main ()


{

   int array[] = {1,2,3}; 
   printf(""The size of the array is%d \n"", ArraySize(array)); 

}

int ArraySize (int *a)

{    

   for (int i=0; a[i]!='\0'; i++);
   return i;
} 
</code></pre>
",5
24571092,24570729,2,"<p>Assuming you're using Windows:
If you hit asd^Z\n , the CTRL-Z does not end the input, so it's not an EOF condition, it's simply the ascii code 26 (the ""subsitute"" character.)</p>

<p>In a windows console, a line needs to start with CTRL-Z to result in an EOF condition.</p>

<p>(Keep in mind that EOF is not a character, it's a just condition that means there's no more input available. The operating system takes care of transforming the CTRL+Z keystroke to do whatever it needs to end the standard input of your program - but it does that only if CTRL-Z is at the beginning of a line)</p>
",0
24583470,24583453,0,"<pre><code>float r = 250.0/1024;

printf(""%f\n"", r * adc);
</code></pre>
",1
24583503,24583453,0,"<p>Assuming only <code>int</code> math (and adc >= 0): </p>

<pre><code>int numerator = 250;
int denominator = 1024;
int product = (adc * numerator + denominator/2)/denominator;
</code></pre>

<p><code>denominator/2</code> is for rounding.</p>
",0
27518832,27518809,0,"<p>Array is not initialized and you are doing this</p>

<pre><code>bigNum=largest(array);
</code></pre>

<p>You should be finding the largest when you have elements in your array.</p>

<p>There are many other bugs in this code:</p>

<ol>
<li>The largest function is not proper and it is returning void </li>
<li>You can't have array[][] as your parameter and it should be array[][4].</li>
</ol>

<p>OMG when I went through the code I found that there is bug in almost each and every line.</p>

<pre><code>#include &lt;stdio.h&gt;

int largest(int array[][4]);
int main()
{   int x,y;
   int array[4][4];
    int row = 4;
    int col = 4;
    int bigNum;

    printf(""Please enter a value: "");

for(x=0;x&lt;row;x++)
{
    for(y=0;y&lt;(col);y++)
    {
        scanf(""%d"",&amp;array[x][y]);

        }
    }
bigNum=largest(array);
   printf(""The largest number in the array is : %d"",bigNum);
}
int largest(int array[][4])
{  
    int max=0;
    int x,y;
    max = array[0][0];
    for(x=0;x&lt;4;x++)
{
    for(y=0;y&lt;4;y++)
    {
        if (array[x][y]&gt;max)
        {
            max = array[x][y];
        }
    }

}
return max;
}
</code></pre>
",0
27518865,27518809,1,"<p>There are a few problems to address here, the first is you can't have <code>int array[][]</code> as a parameter, you need to provide all but the first dimension, <code>int array[][4]</code> would suffice in this limited case.</p>

<p>However, since <code>row</code> and <code>col</code> are local variables in <code>main</code> they aren't visible to your <code>largest</code> functions body, so they'll need to be passed,  make the signature</p>

<pre><code>void largest(int row, int col, int array[row][col]);
</code></pre>

<p>Since this is a void function, it can't return any value.  It will modify the array it's given  in place though, so the changes will be visible.</p>

<p>If you're looking for the straight-up log error, the function to find the largest is pretty crazy.  A saner implementation would be to just track the largest element you've seen so far:</p>

<pre><code>int largest(int row, in col, int array[row][col]) {
    int big = array[0][0]; // assume the first element is the largest
    for (int i = 0; i &lt; row, ++i) {
        for (int j = 0; j &lt; col; ++j) {
            if (array[i][j] &gt; big) big = array[i][j];
        }
    }
    return big;
}
</code></pre>

<p>you could then call the function from main as</p>

<pre><code>int bigNum = largest(row, column, array);
</code></pre>
",3
27518876,27518809,0,"<p>You need to get the values in the array from the user first. So you main should be:</p>

<pre><code>int main()
{   int x,y,trash;
   int array[4][4];
    int row = 4;
    int col = 4;
    int bigNum,greater;
    printf(""Please enter a value: "")

for(x=0;x&lt;row;x++)
{
    for(y=0;y&lt;(col);y++)
    {
        scanf(""%d"",&amp;array[x][y]);
        scanf(""%d"",&amp;trash);
    }
}

    bigNum=largest(array);
    printf(""The largest number in the array is : "",bigNum);

   return 0;          //Because it is ""int"" main and not ""void"" main
}
</code></pre>
",4
27519173,27518809,0,"<p><em>Errors in your code</em></p>

<ol>
<li>You cannot pass two dimensional arrays like you are doing.</li>
<li>Your logic  to find the largest is not proper, you are comparing at any movement two adjacent elements and if the first is small you are actually making them equal</li>
<li>Variable scoping errors, <code>row</code>, <code>col</code>, <code>x</code> and <code>y</code> are bound to main method and you cannot access them in other method. look at <code>Global Variables</code> to access them anywhere you want within the program file. </li>
<li><p>Unnecessary <code>scanf for trash</code> and printf in <code>largest method</code>.</p>

<pre><code>#include&lt;stdio.h&gt;
int row = 4;
int col = 4;
int largestElement(int array[][4],int row);
int main()
{   
 int x,y;

 int array[row][col];
 int bigNum,greater;
 printf(""Please enter a value: "");

 for(x=0;x&lt; row;x++)
 {
     for(y=0;y&lt; col;y++)
     {
         scanf(""%d"",&amp;array[x][y]);
     }
 }

 bigNum = largestElement(array, sizeof(array) / sizeof(array[0]));
 printf(""The largest number in the array is : "",bigNum);
}

int largestElement(int array[][4],int row)
{   
   int x,y;
   int big =0;
   for(x=0;x&lt;row;x++)
   {
     for(y=0;y&lt;(col-1);y++)
     if (big &lt; array[x][y]) big = array[x][y];
   }
  return big;
}
</code></pre></li>
</ol>
",0
27519216,27518809,1,"<p>You have declared the function largest as void and trying to store the return value of the function, it is not possible, so change it as int data type.
Then the row and the col variable value is not passed to the largest function.
either you should declare it globally or pass it as a argument to the largest function.
And you are trying to get the value for trash, I don't know what is the need for that. you can remove it.
And do the following changes in the largest function:</p>

<pre><code>#include &lt;stdio.h&gt;
int largest(int [4][4]);
int row = 4;
int col = 4;
int main()
{   int x,y,trash;
    int array[4][4];
    int bigNum,greater;
    printf(""Please enter a value: "");

    for(x=0;x&lt;row;x++)
    {
            for(y=0;y&lt;col;y++)
            {
                    scanf(""%d"",&amp;array[x][y]);
                    //scanf(""%d"",&amp;trash);
            }
    }

    bigNum=largest(array);
    printf(""The largest number in the array is : %d\n"",bigNum);
    return 0;
    }
    int largest(int array[4][4])

    {
    int x=0,y=0,big=array[0][0];
    for(x=0;x&lt;row;x++)
    {
            for(y=0;y&lt;col;y++)
            {
                    if (array[x][y]&gt;big)
                    {
                            big = array[x][y];

                    }
            }
            printf(""\n"");

    }
    return big;
    }
</code></pre>

<p>Try this code!!!!!</p>
",0
27519299,27518809,0,"<p>You try this code for finding the biggest elements in the Two dimensional array.</p>

<pre><code> #include &lt;stdio.h&gt;
 int  largest(int [][4],int ,int);
 int main() {
    int x,y,trash;
    int array[4][4];
    int row = 4;
    int col = 4;
    int bigNum,greater;
    printf(""Please enter a value: "");

    for(x=0;x&lt;row;x++) {
            for(y=0;y&lt;col;y++) {
                    scanf(""%d"",&amp;array[x][y]);
             }
     }
    bigNum=largest(array,row,col);
    printf(""The largest number in the array is:%d "",bigNum);
    return 0;
  }
 int largest(int array[][4], int row, int col) 
 {
    int x,y,big=array[0][0];
    for(x=0; x&lt;row; x++) {
            for(y=0; y&lt;col-1; y++) {
                    if(big&lt;array[x][y])
                            big=array[x][y];
            }
     }
    return big;
  }
</code></pre>
",0
26147523,26147498,1,"<blockquote>
  <p>Why does one example give an error in while the other does not?  </p>
</blockquote>

<p>This is because both of the code snippet invokes undefined behavior. You should note that, dereferencing an uninitialized pointer invokes UB.  </p>

<p><strong>NOTE:</strong> There is no <code>then</code> keyword in C.</p>
",1
26149020,26147498,2,"<p>The code samples are obviously invalid C. As others have already pointed out, C has no <code>then</code> keyword. That was probably just an error by your instructor, not intended to illustrate anything in particular. I'll show similar examples that illustrate the point.</p>

<p>This code is correct:</p>

<pre><code>char *p;
/* code that assigns a value to p omitted */
if (p &amp;&amp; *p)
    foo(); 
</code></pre>

<p>Any scalar value can be used as a condition; if it's equal to zero it's treated as false, otherwise as true. (In the original sample, <code>p</code> was uninitialized, causing undefined behavior if its value is used, but I'll assume any initialization code was simply omitted.)</p>

<p>The above can be written more explicitly as:</p>

<pre><code>char *p;
/* code that assigns a value to p omitted */
if (p != NULL &amp;&amp; *p != '\0')
    foo(); 
</code></pre>

<p>Evaluating <code>*p</code> would be invalid (causing undefined behavior) if <code>p</code> were a null pointer. By testing whether <code>p</code> is null before trying to dereference it, the above code avoids any such error, since <code>&amp;&amp;</code> has short-circuit behavior. The <code>if</code> statement could also be written as:</p>

<pre><code>if (p != NULL) {
    if (*p != '\0') {
        foo();
    }
}    
</code></pre>

<p>The code calls the function <code>foo</code> if <code>p</code> is a non-null pointer that points to a non-null character. (These are two different meanings of the word ""null"".) If <code>p</code> is meant to be a pointer to a string, then <code>p != '\0'</code> means that the string it points to is not empty.</p>

<p>Now to the second example:</p>

<pre><code>char *p;
/* code that assigns a value to p omitted */
if (*p &amp;&amp; p)
    foo();
</code></pre>

<p>or, more explicitly:</p>

<pre><code>char *p;
/* code that assigns a value to p omitted */
if (*p != '\0' &amp;&amp; p != NULL)
    foo();
</code></pre>

<p>This causes undefined behavior (possibly a program crash) if <code>p</code> is a null pointer. The check <code>p != NULL</code> is performed too late, after the program has already crashed.</p>
",0
22511674,22511612,3,"<p>Stack overflow is causing sigsegv. There's no need of a while loop. A single printf will cause stack overflow.<br>
Local variables are created on the stack. The variable foo is using huge space on the stack. Stack is also used to store return addresses in function calls. So both of them together will cause a stack overflow. foo uses up almost all the space in the stack. Calling printf overflows the stack<br>
You should allocate on the heap using malloc.</p>
",10
22511711,22511612,8,"<pre><code>long size = 10000000;
struct foo *bar[size];
</code></pre>

<p>will create a very big array, which may cause stack overflow, and therefore your program receive the SIGSEV.</p>

<p>You should create this array dynamically:</p>

<pre><code>struct foo *bar = malloc(size * sizeof(struct foo *));
</code></pre>

<hr>

<p>Why does the program work normally if these is not any function call in <code>main()</code>?</p>

<p>The definition of <code>foo</code> will cause <code>main()</code> to have a large stack frame at runtime. If you does not call any function in <code>main()</code>, this large stack frame will not be actually allocated or accessed (the entrance code of <code>main()</code> only make sure that amounts of memory be reserved by manipulating some registers and memory cells); but if you call a function in <code>main()</code>, the calling itself will try to access some addresses in that <code>main()</code> stack frame, because of stack overflow, those addresses may not be valid, this will cause SIGSEV be sent.</p>

<p>If you disassemble and compare the working and not-working versions of this program, this would be obvious. You could also find it out by stepping through the instructions of not-working <code>main()</code> one by one.</p>

<hr>

<p>Without function call in <code>main()</code>:</p>

<pre><code>0x00001ff0 &lt;main+0&gt;:    push   %ebp
0x00001ff1 &lt;main+1&gt;:    mov    %esp,%eax
0x00001ff3 &lt;main+3&gt;:    mov    %esp,%ebp
0x00001ff5 &lt;main+5&gt;:    sub    $0x2625a10,%esp
0x00001ffb &lt;main+11&gt;:   mov    %eax,%esp
0x00001ffd &lt;main+13&gt;:   leave  
0x00001ffe &lt;main+14&gt;:   ret  
</code></pre>

<p>Call <code>exit()</code> in <code>main()</code>:</p>

<pre><code>0x00001fe0 &lt;main+0&gt;:    push   %ebp
0x00001fe1 &lt;main+1&gt;:    mov    %esp,%ebp
0x00001fe3 &lt;main+3&gt;:    sub    $0x2625a28,%esp
0x00001fe9 &lt;main+9&gt;:    movl   $0x0,(%esp)    &lt;==== This causes segfault.
0x00001ff0 &lt;main+16&gt;:   call   0x3000 &lt;dyld_stub_exit&gt;
</code></pre>
",4
22511892,22511612,1,"<p>Stack size is the problem here, as others have pointed out. Check out <a href=""https://stackoverflow.com/questions/1825964/c-c-maximum-stack-size-of-program"">C/C++ maximum stack size of program</a> for more details.</p>
",0
24619321,24618942,2,"<p>If an <code>a</code> is given that is greater than all elements in <code>arr</code>, the first <code>for()</code> loop in <code>main()</code> overruns the array, yielding undefined behavior. The fact that the global variable <code>arr</code> will be zero initialized helps to trigger this condition: start with any <code>a</code> other than zero, and you immediately have undefined behavior.</p>
",1
28220857,28220773,5,"<p>If the user inserts Ctrl-D (on Linux/OS X) or Ctrl-Z (on Windows), you get an EOF from stdin. Also, the standard input may be redirected from a file - in that case, at the end you get a ""real"" EOF.</p>

<p>In both these cases, without that check that loop would go on forever, waiting for a newline that will never come (insert melancholic music here).</p>
",3
28220907,28220773,4,"<p>Your code does not ""flush"" <code>stdin</code>. All it does is searching for the nearest <code>'\n'</code>, or the end of the input, whichever comes first.</p>

<p>You can get an <code>EOF</code> in several situations:</p>

<ul>
<li>End-user presses a combination that closes <code>stdin</code>, meaning that the next attempt to read would return <code>EOF</code>, or</li>
<li>You hit the actual end-of-file, when the input is redirected through OS-specific means to access a file instead of using console, e.g. <code>a.out &lt;data.txt</code></li>
<li>There is a read error in the middle of accessing the input stream of your program.</li>
</ul>

<p>The reasons why you may do it could be different, but most often it's clearing out the leftovers from some previous invalid input.</p>
",3
28221149,28220773,1,"<p>The statement you present reads the remainder of the current line from <code>stdin</code> and discards it, whether the line ends with a newline character (<code>'\n'</code>) or at the end of the stream (<code>EOF</code>).  As dasblinkenlight observes, that is not what is conventionally called a ""flush"".</p>

<p><code>getchar()</code> returns <code>EOF</code> at the end of the stream or on error, and <code>EOF != '\n'</code>, so without the the <code>EOF</code> check, that statement would loop infinitely if it reaches the end of the stream.</p>

<p>It is by no means certain that the last line of the input will be newline-terminated.  In fact, you could argue that the last line of a stream is the one terminated by the end of the stream, so the last line is <em>never</em> newline-terminated, though it may contain zero characters.</p>
",4
24633204,24632913,0,"<p>The second time you input <code>time_diff</code>, it will overwrite the first one, and then the second one will be used twice.</p>

<p>If you move the call to <code>Time_change</code> to the first loop, it will use the correct value of <code>time_diff</code> each time.</p>
",0
28470217,27759456,0,"<p>You could probably use sizeof() and pointers to do it, since every char in memory is linear</p>

<p><strong>Eg:</strong>
`</p>

<pre><code>//Remove duplicate char in string 'in'
char* rem_dup(char* in){

    int i=0, j=0, pos=0;
    for(;i&lt;strlen(in);i++){
    int charat = *(in+i);
    for(j=i+1;j&lt;strlen(in);j++){
        if(charat == *(in+j)){
        *(in+i) = *(in+j) = -1;
        }
    }

    if(*(in+i) &gt; 0){        
        *(in+pos) = *(in+i);
        pos++;
    }

    }

    *(in+pos) = 0;
    return in;
}

int main(){
    int i=0;
    char str[][100] = {""remove duplicates"", """", ""aabb"", ""ab"", ""a"", ""abba""};
    for(;i&lt;sizeof(str)/sizeof(char);i+=sizeof(str[0])/sizeof(char)){
    printf(""IN :%s\n"",(char*)str+i);
    printf(""OUT:%s\n"", rem_dup((char*)str+i));
    }
    return 0;
}
</code></pre>

<p>`</p>
",0
22515698,22515622,2,"<p>Change   </p>

<pre><code>scanf("" %d "",&amp;a);  
</code></pre>

<p>to  </p>

<pre><code>scanf(""%d"",&amp;a);  
</code></pre>

<p>otherwise <code>scanf</code> will wait until you pass a non-whitespace character.</p>
",0
22515719,22515622,4,"<p>When there is a blank in the format string, <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/scanf.html"" rel=""nofollow""><code>scanf()</code></a> consumes zero or more white space characters until it comes across a non-white-space character.  Newlines are white space.</p>

<p>Therefore, especially for interactive input, trailing white space in a format string is a bad idea!  In your code, remove the trailing space.  (Note that you could type anything, not just another number, after the first number and the code will report on the first number you enter; the extra data is available to another read operation, even though your program does not actually read it.)</p>

<p>Most conversion specifications ignore leading white space too.  The exceptions are <code>%c</code>, <code>%n</code> and <code>%[...]</code> (the last being the scanset conversion specification).</p>
",0
22515779,22515622,1,"<p>From <a href=""http://www.cplusplus.com/reference/cstdio/scanf/"" rel=""nofollow"">here</a>:</p>

<blockquote>
  <p>The function will read and ignore any whitespace
  characters encountered before the next non-whitespace character
  (whitespace characters include spaces, newline and tab characters --
  see isspace). A single whitespace in the format string validates any
  quantity of whitespace characters extracted from the stream (including
  none).</p>
</blockquote>

<p>So change </p>

<pre><code>scanf("" %d "",&amp;a); 
</code></pre>

<p>to</p>

<pre><code>scanf(""%d"",&amp;a);  
</code></pre>
",0
24616620,24616355,2,"<p>Does the segmentation fault happen at the same place?
It could be that the OS ignores the <code>W</code> flag, but I don't think that's the case here. Assuming the OS honours the flag, the following is relevant.</p>

<p>You are overwriting the first instruction of the <code>add</code> function with <code>0</code>, which in x86 assembly is (assuming 4 bytes <code>int</code> here)</p>

<pre><code>00000000  0000              add [bx+si],al
00000002  0000              add [bx+si],al
</code></pre>

<p>This most likely ends up accessing invalid memory, at <code>bx+si</code>.</p>
",0
24617423,24616355,2,"<p>The system is ignoring the <code>W</code> flag here:</p>

<pre><code>$ gcc -Wall file.c 
$ readelf -S a.out | grep .text
  [14] .text             PROGBITS        08048330 000330 0001cc 00  AX  0   0 16
$ objcopy a.out --set-section-flags .text=alloc,code,data a.out 
$ readelf -S a.out | grep .text
  [14] .text             PROGBITS        08048330 000330 0001cc 00 WAX  0   0 16
$ gdb -q a.out 
Reading symbols from a.out...(no debugging symbols found)...done.
(gdb) r
Starting program: a.out 

Program received signal SIGSEGV, Segmentation fault.
0x0804842f in main ()
(gdb) x/i 0x0804842f
0x804842f &lt;main+45&gt;:    movl   $0x0,(%eax)
(gdb) 
</code></pre>

<p>You still  cannot write to <code>p</code>. You can change the memory page protection at runtime using <a href=""http://linux.die.net/man/2/mprotect"" rel=""nofollow""><code>mprotect</code></a>:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdint.h&gt;
#include &lt;sys/mman.h&gt;

int add(int a, int b)
{
        printf(""reached inside the function"");
        return a+b;
}

int main()
{
        int x=10;
        int y = 20;
        int * p;
        int z;
        int (*fp) (int , int);
        long pagesize;

        fp = add;
        p = (int *)fp;

        pagesize = sysconf(_SC_PAGESIZE);
        if(mprotect((void *)((uintptr_t)p &amp; ~((uintptr_t)pagesize - 1)), pagesize, PROT_READ | PROT_WRITE | PROT_EXEC) == -1)
          perror(""Error mprotect()"");

        *(p+0) = 0;
        z = add(x,y);
        return 0;
}
</code></pre>

<p>this will leave you with the bad instruction to fix:</p>

<pre><code>$ gcc -Wall file.c 
$ ./a.out 
Segmentation fault
$ gdb -q a.out 
Reading symbols from a.out...(no debugging symbols found)...done.
(gdb) r
Starting program: a.out 

Program received signal SIGSEGV, Segmentation fault.
0x08048484 in add ()
(gdb) x/i 0x08048484
0x8048484 &lt;add&gt;:    add    %al,(%eax)
(gdb) 
</code></pre>
",2
24096385,24096362,2,"<p>Your function does not remove the file because you are passing <code>FILE*</code> instead of <code>char*</code> to the <a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/remove.html"" rel=""nofollow""><code>remove</code></a> function:</p>

<pre><code>FILE *stock = fopen(""stock.dat"",""rb"");
...
fclose(stock);
remove(stock); // &lt;&lt;== HERE: you are supposed to pass a name, not FILE*
</code></pre>

<p>To fix the problem, change the <code>remove</code> line as followsL</p>

<pre><code>remove(""stock.dat"");
</code></pre>
",0
23079616,23079573,0,"<p>change it like this:</p>

<pre><code>scanf("" %li"", &amp;fs);

while(fs &lt;= 0)
{
    printf(""\nThe samplefrequency must be above 0 Hz. Please enter again: "");
    scanf("" %li"", &amp;fs);
}
</code></pre>

<p>When you input a wrong number the loop will continue to prompt for a new number until it is correct.</p>
",0
23079730,23079573,4,"<p>The only way to make user input from the console completely idiot-proof is this:</p>

<ul>
<li><a href=""http://c-faq.com/stdio/scanfprobs.html"" rel=""nofollow"">Do not use scanf</a>.</li>
<li>Read the input as a string, using <code>fgets</code>. Do not read it as an integer. </li>
<li>Parse this string and see if it contains a valid number.</li>
<li>Convert the string to an integer by using strtol().</li>
</ul>
",0
23080439,23079573,0,"<p>Here's a sample that demonstrates how to use <code>fgets</code> with <code>sscanf</code> to solve the user input problem. </p>

<p>The function <code>getInputFromUser</code> displays <code>prompt1</code>, and then uses <code>fgets</code> to read a line of input from the user. (If <code>fgets</code> returns <code>NULL</code>, that indicates end-of-file from the user, and the program aborts.)</p>

<p>The function then uses <code>sscanf</code> to convert the input to a number. <code>sscanf</code> returns the number of successful conversions, so in this example a return value of <code>1</code> indicates that <code>sscanf</code> succeeded. (Additional range checking can be performed after the <code>sscanf</code> to make sure the number is acceptable.) If the <code>sscanf</code> fails, then the second prompt (<code>prompt2</code>) is displayed and the function tries again. </p>

<p>If and when the user gets around to entering a valid number, the function will return that value. </p>

<pre><code>long getInputFromUser(char *prompt1, char *prompt2)
{
    long result = 0;
    char line[100];  

    printf(""%s"", prompt1);       
    for (;;)
    {
        if (fgets(line, sizeof(line), stdin) == NULL) 
        {
            // user hit the EOF key
            printf( ""\nterminated by user...\n"" );
            exit(1);
        }

        if (sscanf( line, ""%ld"", &amp;result) == 1 &amp;&amp; result &gt; 0)
            break;

        printf(""%s"", prompt2);
    }

    return result;
}
</code></pre>

<p>Call the function with the initial prompt, and the re-prompt for the user</p>

<pre><code>long fs = getInputFromUser(""Enter the samplefrequency(in Hz) and press 'ENTER': "",
                           ""The samplefrequency must be above 0 Hz. Please enter again: "");
</code></pre>
",0
22515799,22515750,0,"<p>The main issue throughout is that you don't specify the type of each function parameter. You need to tell the compiler that integer1 is an <code>int</code>, for example. Also, see haccks' answer. </p>
",0
22515826,22515750,0,"<p>Two return statements one after the other are useless. The second return statement is unreachable. And you missed semicolons at the end of both the lines. May be this is the function you wanted:</p>

<pre><code>int squared(int integer1,int integer2,int total)
{
   total = integer2+integer2;
   return total*total;
}
</code></pre>

<p>This calculates the sum of the two values and returns the square of the sum.</p>
",0
22515950,22515750,0,"<p>in addition to the function definition you need to change even the function call,  </p>

<pre><code>printf(""Square of entered numbers = %d\n"",squared(total));
</code></pre>

<p>to  </p>

<pre><code>printf(""Square of entered numbers = %d\n"",squared(integer1,integer2,total));
</code></pre>

<p>so that function call gets the value to add. read some basic c programs to know the format and syntax.</p>
",0
22516060,22515750,0,"<p>While you don't really need to specify the type <code>int</code> for the arguments that the function <code>squared</code> takes, because <code>int</code> is assumed whenever type is not specified, it is never bad to just put them down, as in:</p>

<pre><code>int squared(int integer1, int integer2, int total);
// instead of
// int squared(integer1, integer2, total);
// both at the prototype and the definition of the function
</code></pre>

<p>Then again, you may just leave that out.</p>

<p>There are real problems in your function <code>squared</code>'s definition. You aren't using semicolons <code>;</code>, and you have written a return for the first statement, where I think you don't really want to return anything yet. You probably just wanted:</p>

<pre><code>int squared(int integer1, int integer2, int total)
{
    total = integer1 + integer2;
    return total *= total;
}
</code></pre>

<p>One another important thing is, you are giving 2 less arguments to the <code>squared</code> function call from your <code>main</code> function. <code>squared</code> awaits for 3, you give it just 1. You probably wanted to call it as following:</p>

<pre><code>...
    printf(""Square of entered numbers = %d\n"", squared(integer1, integer2, total));
...
</code></pre>

<p>Lastly, you shouldn't be using variables that you haven't given a value to. <code>integer1</code> <em>hopefully</em> will have a value assigned, <code>integer2</code> also, <em>hopefully</em>. But <code>total</code> won't be assigned a value by the time you call the <code>squared</code> from <code>main</code>. You can just initialize it with a <code>0</code> or something, like this:</p>

<pre><code>...
    int integer1, integer2, total = 0;
...
</code></pre>

<p>Actually, you don't even need to have a <code>total</code> inside <code>main</code>, your <code>squared</code> function doesn't need a 3rd argument that holds <code>total</code>, as soon as you just declare an <code>int total</code> inside <code>squared</code>. But I won't get to that...</p>
",0
24088671,24088626,3,"<p>This line:</p>

<pre><code>cat_names=malloc(data_cat_num*50);
</code></pre>

<p>doesn't allocate 50 bytes per name; it allocates <code>data_cat_num*50</code> names. You need to do this:</p>

<pre><code>cat_names = malloc(data_cat_num * sizeof(char *));
int i;
for(i = 0; i &lt; data_cat_num; i++)
    cat_names[i] = malloc(50);
</code></pre>

<p>The first line allocates <code>data_cat_num</code> names (i.e., <code>char *</code> variables), and later (in the for loop), 50 bytes for each name.</p>

<p><strong>EDIT</strong> Also, when you free this memory, you need to do it this way:</p>

<pre><code>for(i = 0; i &lt; data_cat_num; i++)
    free(cat_names[i]);
free(cat_names);
</code></pre>
",2
24088680,24088626,-1,"<pre><code>char **cat_names;
</code></pre>

<p>This says <code>cat_names</code> will be a pointer to a pointer.</p>

<pre><code>cat_names=malloc(data_cat_num*50);/*Currently defaulting to 50 bytes per name*/
</code></pre>

<p>This makes <code>cat_names</code> a pointer, but a pointer to garbage because the memory returned by <code>malloc</code> isn't initialized.</p>

<pre><code>cat_names[current_cat][col_index]='\n';
</code></pre>

<p>Oops, you used the <code>cat_names</code> contents as a pointer, but it points to garbage.</p>
",2
24088712,24088626,0,"<p>This line doesn't do what you think:</p>

<pre><code>cat_names=malloc(data_cat_num*50);/*Currently defaulting to 50 bytes per name*/
</code></pre>

<p>cat_names contains pointers to the strings, not the strings themselves. So, here you're allocating enough space to store the pointers to 50 cat names, but not the names themselves.</p>

<p>What you'll need to do is each time you add a name, malloc that as well. So...</p>

<pre><code>cat_names[current_cat] = malloc(maxNameLength*sizeof(char));
</code></pre>
",0
23113825,23113778,2,"<p>Without a base case you are creating code with undefined behaviour. Your compiler will issue a warning saying that your function that returns <code>int</code> does not have a return statement. This does not mean that the function that called it won't look for a returned value which may or may not contain garbage.</p>
",2
23113939,23113778,0,"<p>You're going to run into problems here: <code>add</code> will only return a value if <code>n != 0</code>, so if <code>n &lt;= 0</code>, you won't have a value returned, so when <code>add</code> calls itself with <code>n-1</code> passed in, you'll eventually reach your base case that doesn't exist, and bad things will happen.</p>
",0
23113959,23113778,0,"<pre><code>if(n==0){return 0;}
</code></pre>

<p>is the base case. The base case exists to get the recursion to stop. Without a base case you will just infinitely recurse until you possibly hit some kind of error. In your case it will start adding negative numbers.</p>
",1
23114191,23113778,0,"<p>From the C standards:</p>

<blockquote>
  <p>Flowing off the end of a function is equivalent to a return with no
  value; this results in undefined behavior in a value-returning
  function.</p>
</blockquote>

<p>Your compiler may warn you:</p>

<blockquote>
  <p>not all control paths return a value</p>
</blockquote>

<p>It's the same situation with <a href=""https://stackoverflow.com/questions/23015797/confused-about-the-function-return-value/23017449#23017449"">this one</a>.
This is calling convention and architecture dependent. The return value is the result of last expression evaluation, stored in the eax register. So when <code>n==0</code>, you function <code>add()</code> returns 0, but it's a result of undefined behavior. </p>
",0
23581567,23581470,0,"<pre><code>#include &lt;stdlib.h&gt;

double ** aloc_dynamic( size_t n, size_t m )
{
    double **p = ( double ** )malloc( n * sizeof( double * ) );

    for ( size_t i = 0; i &lt; n; i++ )
    {
        p[i] = ( double * )malloc( m * sizeof( double ) );
    }

    return p;
}

int main(void)
{
    size_t n = 5;
    size_t m = 10;

    double **p = aloc_dynamic( n, m );

    // before exiting the function free the allocated memory
}
</code></pre>
",0
23581603,23581470,0,"<p>... and with the corresponding free function</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

double** alloc_2d(int y_extent, int x_extent)
{
    int y, x;
    double ** array = (double**)malloc(y_extent * sizeof(double*));
    for (y = 0 ; y &lt; y_extent ; ++y) {
        array[y] = (double*)malloc(sizeof(double) * x_extent);
        for(x = 0 ; x &lt; x_extent ; ++x) {
            array[y][x] = 0.0;
        }
    }

    return array;
}

void free_2d(double** array, int y_extent)
{
    int y;
    for(y = 0 ; y &lt; y_extent ; ++y) {
        free(array[y]);
    }
    free(array);
}


int main(void)
{
    double **H = alloc_2d(50,100);

    H[10][10] = 0.0; // for example

    free_2d(H, 50);

    return 0;
}
</code></pre>
",0
23581915,23581470,0,"<p>You can do it like this:</p>

<pre><code>// We return the pointer
int **get(int N, int M) /* Allocate the array */
{
    /* Check if allocation succeeded. (check for NULL pointer) */
    int i, **table;
    table = malloc(N*sizeof(int *));
    for(i = 0 ; i &lt; N ; i++)
        table[i] = malloc( M*sizeof(int) );
    return table;
}

// We don't return the pointer
void getNoReturn(int*** table, int N, int M) {
    /* Check if allocation succeeded. (check for NULL pointer) */
    int i;
    *table = malloc(N*sizeof(int *));
    for(i = 0 ; i &lt; N ; i++)
        *table[i] = malloc( M*sizeof(int) );
}

void fill(int** p, int N, int M) {
    int i, j;
    for(i = 0 ; i &lt; N ; i++)
        for(j = 0 ; j &lt; M ; j++)
            p[i][j] = j;
}

void print(int** p, int N, int M) {
    int i, j;
    for(i = 0 ; i &lt; N ; i++)
        for(j = 0 ; j &lt; M ; j++)
            printf(""array[%d][%d] = %d\n"", i, j, p[i][j]);
}

void free2Darray(int** p, int N) {
    int i;
    for(i = 0 ; i &lt; N ; i++)
        free(p[i]);
    free(p);
}

int main(void)
{
    int **p;
    //getNoReturn(&amp;p, 2, 5);
    p = get(2, 5);
    fill(p ,2, 5);
    print(p, 2, 5);
    free2Darray(p ,2);
    return 0;
}
</code></pre>

<p>Remember a 2D array is a 1D array of pointers, where every pointer, is set to another 1D array of the actual data.
Image:</p>

<p><img src=""https://i.stack.imgur.com/WCY75.png"" alt=""enter image description here""></p>

<p>I suggest you to read the explanation <a href=""http://gsamaras.wordpress.com/code/2d-dynamic-array-c/"" rel=""nofollow noreferrer"">here</a>.</p>
",0
26206771,26206647,0,"<p>Probably you should get also a warning about 'unknown' function. That means that there is a problem with function <code>newList</code> and compiler assumes the unknown function returns int, and continues on.. </p>

<p>Possible reason: the function is named newList but you use</p>

<pre><code>ListP r = newlist();
             ^
</code></pre>

<p>You should double check if proper <strong>headers</strong> are included and names are correct, and that <strong>the function is declared before</strong> it's used. Search case sensitive (grep is by default case sensitive so something like</p>

<pre><code>grep -r ""newlist"" .  // verify
grep -r ""newList"" .  // again...
</code></pre>

<p>will work) in your project root dir for ""newlist"" &amp; for ""newList"". You shouldn't also</p>

<pre><code>#include ""List.c""
</code></pre>

<p>but only</p>

<pre><code>#include ""List.h""
</code></pre>

<p>Then correct also comparison <code>p-&gt;head == NULL;</code> to assignment <code>p-&gt;head = NULL;</code></p>
",4
22508967,22508629,1,"<p>strstr() returns a char* pointer to the first occurence of substring. You need to subtract the starting address of the array to get the position as an index</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main()
{
    char s1[20],s2[20];
    char *x;
    gets(s1);
    gets(s2);
    x=strstr(s1,s2);
    if(strstr(s1,s2)==NULL)
    printf(""-1"");
    else
    printf(""%d"",x-s1);
    return 0;
}
</code></pre>

<p>Also, I'd advise you to refrain from using gets since it's a bad habit. Use fgets instead.</p>
",0
22508780,22508629,3,"<p>The <code>x</code> needs to be a pointer:</p>

<pre><code>char *x;
</code></pre>

<p>Then:</p>

<pre><code>x=strstr(s1,s2);
</code></pre>

<p>points to the location within <code>s1</code> of <code>s2</code>, or NULL. If you need the index, you can write:</p>

<pre><code>int indx = x ? x - s1 : -1;
// ...
printf(""%d\n"", indx);
</code></pre>

<p>And by the way, as standard advice, you should use <code>fgets()</code> rather than <code>gets()</code>.</p>
",6
22508828,22508629,0,"<p>your code almost works.
strstr returns the address which should be stored in a pointer.But you are storing in an character variable. So change the <code>char x</code> to <code>char *x</code>.</p>
",0
22508835,22508629,0,"<p>from this post </p>

<p>Use pointer subtraction.</p>

<pre><code>char *str = ""sdfadabcGGGGGGGGG"";
char *result = strstr(str, ""abc"");
int position = result - str;
int substringLength = strlen(str) - position;
</code></pre>

<p><a href=""https://stackoverflow.com/questions/7500892/get-index-of-substring"">Get index of substring</a></p>
",0
22427290,22427264,4,"<p>Your problem is that you think that <code>sizeof</code> on a pointer give the size of what it points to. Hint: It gives you the size of <em>the pointer</em> (which is typically 4 bytes on a 32-bit machine and 8 bytes on a 64-bit machine).</p>

<p>Either use <code>strlen</code> to get the length of strings, or use arrays instead of pointers.</p>

<p>Besides, even if you use pointers, you have to remember that they point to <em>constant</em> strings, so the correct definition would be e.g.</p>

<pre><code>const char *tt = ""22"";
</code></pre>
",0
22427349,22427264,0,"<p>For debugging you should have modified your code like this:</p>

<pre><code>void testdigi(){
    char* tt=""22"";
    char* tt2= ""222222222"";
    for(int i=0;i&lt;sizeof(tt)/sizeof(char);i++)
        if (!isdigit(tt[i])) printf(""22 not digital\n"");
        else printf(""22 is digital\n"");
    for(int i=0;i&lt;sizeof(tt2)/sizeof(char);i++)
        if (!isdigit(tt2[i])) printf(""222222222 not digital\n"");
        else printf(""222222222 is digital\n"");
}
</code></pre>

<p>And you might have been enlighted of what is wrong beforehand.</p>
",0
25699623,25699395,3,"<p>Your dereference logic for AddStreet is wrong. You're dereferencing <code>length</code> from a pointer to pointer base. You want to dereference from the pointer it points to to get the actual street object.</p>

<p>When <code>streets</code> is <code>STREET**</code>, then this:</p>

<pre><code>streets[length]-&gt;start[0]
</code></pre>

<p>says ""get me the pointer in the array of pointers starting at <code>streets</code> at offset <code>length</code>, then dereference that pointer"". But your array isn't an array of pointers. In fact, there is only <em>one</em> pointer (and you happen to pass it by address). </p>

<p>This will do what you want:</p>

<pre><code>STREET* AddStreet(STREET **streets, int length, int bx, int by, int ex, int ey)
{
    if(ValidStreet(bx, by, ex, ey))
    {
        (*streets)[length].start[0] = bx;
        (*streets)[length].start[1] = by;
        (*streets)[length].end[0] = ex;
        (*streets)[length].end[1] = ey;
    }
    else
    {
        (*streets)[length].start[0] = ex;
        (*streets)[length].start[1] = ey;
        (*streets)[length].end[0] = bx;
        (*streets)[length].end[1] = by;
    }

    return *streets;
}
</code></pre>

<hr>

<p>Frankly, you shouldn't be passing the pointer to pointer in the first place.</p>

<pre><code>void AddStreet(STREET* street, int bx, int by, int ex, int ey)
{
    if(ValidStreet(bx, by, ex, ey))
    {
        street-&gt;start[0] = bx;
        street-&gt;start[1] = by;
        street-&gt;end[0] = ex;
        street-&gt;end[1] = ey;
    }
    else
    {
        street-&gt;start[0] = ex;
        street-&gt;start[1] = ey;
        street-&gt;end[0] = bx;
        street-&gt;end[1] = by;
    }
}
</code></pre>

<p>invoked as this:</p>

<pre><code>    fscanf(pf, ""%d %d %d %d"", &amp;a,&amp;b,&amp;c,&amp;d);
    AddStreet(*pstreets + (slength-1), a,b,c,d);
</code></pre>

<p>would work and is considerably less prone to error.</p>
",4
27547748,27547605,0,"<p>I'm afraid there are no standard types in C that will allow you to store such a big value with 20148 bits... You can try to read the string from console (not converting into int), and then parse the string into ""010101...."" on your own. <br></p>

<p>The approach would be like that:<br>
You should go for ""dividing"" the string by 2 in each step (for each division by 2 you need to divide all digits of the string by 2, and handle special cases like 11 / 2 => 5), and for each step if the value cannot be divided by 2, then you then you can put ""1"" as another binary digit, otherwise you put ""0"". This way you gather the digits '0', '1', '0', '1', etc. one by one. Then finally you need to reverse the order of digits. A similar approach implemented in C# you can find here: <a href=""https://stackoverflow.com/questions/2954962/decimal-to-binary-conversion-in-c"">Decimal to binary conversion in c #</a></p>
",0
27550587,27547605,1,"<p>Since you told that you just need some pointers and not the actual answer, here goes:</p>

<blockquote>
  <p>I am not able to understand how to convert an String into large Int</p>
</blockquote>

<p>That's because you can't. If you want to convert a number that huge to a numerical type, in the first place you need such a type that can hold numbers that big. The language doesn't provide you anything more than <code>long long</code> which is usually 128-bits long (i.e. if you can use C99, or just <code>long</code> which is usually lesser than a <code>long long</code>). Since your tutor told you not to use any external library, it's a clear sign that s/he wants you to code the solution using what's available only in the language and perhaps additionally the standard library.</p>

<blockquote>
  <p>Is the library function log capable of finding this</p>
</blockquote>

<p>No, you can't use <code>stoi</code> or <code>log</code> since all of these expect arguments of some arithmetic type, while none of those built-in types are that big to hold numbers this huge. So you've to work completely with strings (i.e. either static or dynamic char buffers).</p>

<p>I understand that you want to use <code>log</code> to deduce the number of digits the binary output would need; but there's another option, which is to not know the number of digits before hand and allocate them dynamically with some upper bound so that you needn't re-allocate them further.</p>

<p>Lets take an example.</p>

<ol>
<li>Allocate 3 <code>char</code> buffers <code>in</code>, <code>out</code> (length of input) and <code>bin</code> (length of input * 4).</li>
<li>Copy input to <code>in</code></li>
<li>While <code>in</code> is not <code>""0""</code> or <code>""1""</code> do else goto <em>12</em></li>
<li>For each element <code>ch</code> in <code>in</code> do else goto <em>10</em></li>
<li>Convert <code>ch</code> to integer <code>i</code></li>
<li>If <code>is_odd</code> = <code>1</code> then <code>i += 10</code></li>
<li><code>quot = i / 2</code></li>
<li>Append <code>quot</code> to <code>out</code></li>
<li><code>is_odd = quot % 2</code>; goto <em>4</em></li>
<li>If <code>is_odd</code> = <code>1</code> append <code>'1'</code> else <code>'0'</code> to <code>bin</code></li>
<li>Copy <code>out</code> to <code>in</code>, reset <code>out</code> and goto <em>3</em></li>
<li>Append <code>in</code> to <code>bin</code></li>
<li>Print <code>bin</code> in reverse</li>
</ol>

<p>When you integer divide a number by 2, the quotient would always be less than or equal to the number of digits of the dividend. So you could allocate <code>in</code> and <code>out</code> with the same size as the input and use it for all iterations. For the <code>bin</code> buffer, the knowledge that each decimal digit wouldn't take more than 4 bits (9 takes a nibble, 1001) would help. So if the input is 10 digits, then 10*4 = 40 bytes would be the upper limit needed for <code>bin</code> buffer and 10 bytes would be needed for the <code>in</code> and <code>out</code> buffers.</p>

<p>This is a vague write-up of an algorithm, I hope it conveys the idea. I feel writing code is more easier than writing algorithms properly.</p>
",0
27551066,27547605,0,"<p>Regarding the update:</p>

<p>Grinding it through WolframAlpha gives:</p>

<blockquote>
  <p>log(222121212213212313133123413131313131311313154515441315413451315641314563154134156313461316413415635154613415645156451434)</p>
</blockquote>

<p>is roughly</p>

<blockquote>
  <p>274.8056791141317511022806994521207149274321589939103691837589..</p>
</blockquote>

<p>Test:</p>

<p>Putting it into exp gives:</p>

<blockquote>
  <p>2.2212121221321231313312341313131313131131315451544131541.. ¡Á 10^119</p>
</blockquote>

<p>This raises the question about the precision you need.</p>

<p>Note: I assumed you mean the natural logarithm (base e).</p>
",1
23561998,23537890,0,"<p>I  just solved the problem by using one function which basically is collects all memory allocated to local static pointers like above and then other functions free them during the end as it is registered using atexit function.</p>

<pre><code>struct node
{
node *next;
void *content;
};

node* head = NULL, tail =NULL;


void addToList(void* ptr)
{
    struct node* p = (struct node*)malloc(sizeof(struct node));
    p-&gt;next = NULL; 
    p-&gt;conent = ptr;
    tail-&gt;next = p;
    tail = p;
    return;
}

void freeList()
{
    struct node* p = NULL, p1 = NULL;
    for(p = head; p != NULL; p = p-&gt;next)
    {
        free(p1);
        free(p-&gt;content);
        p1 = p;  
    }
    head = tail = NULL;
    return;
    }

/*

*/

void func
{
//static int array[EOL]; //-&gt; that how it was earlier
static int *array = (int*)malloc(sizeof(int)*EOL); //Will this allocated memory only once
addToList(array);                                  //or on every invokation.
free(array);//will it  free the memory more than once?
}
</code></pre>

<p>As you can see it above code a linked list is created in separate .c file and using .map method head,tail and node will not be exposed to outside world only addToList and freeList will be visible. In every places just after doing a malloc I am calling addToList and then freeList will free up the memory.</p>

<p>Thanks</p>
",0
22430886,22430809,0,"<p>This check: str1[i]>='\0' is a signed comparison.  Once you access uninitialized data past the boundary of str1 you will eventually access a byte with a value > 127, which is negative when used in a signed comparison and therefore less than zero ('\0'), so the loop terminates.  It's also possible that the program could encounter an access violation and crash before it encounters a negative byte - it just depends on what's in memory, but your program will be trashing memory that lies after str2, if it doesn't crash.</p>

<p>This code is unsafe and an example of how buffer overflows happen.  The correct check for terminating the loop is ""str1[I] != '\0'"".</p>
",2
27544989,27544939,1,"<p>This line is in the opposite order</p>

<pre><code>int test = (bytes[3] &lt;&lt; 24) | (bytes[2] &lt;&lt; 16) | (bytes[1] &lt;&lt; 8) | (bytes[0]);
</code></pre>

<p>so</p>

<pre><code>int test = (bytes[0] &lt;&lt; 24) | (bytes[1] &lt;&lt; 16) | (bytes[2] &lt;&lt; 8) | (bytes[3]);
</code></pre>

<p>should work.</p>
",1
28524255,28524134,-1,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;

int main() {
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */
    int N, M, i, a, b, k, total = 0;
    fscanf(stdin, ""%d %d"", &amp;N, &amp;M);
    fprintf(stdout, ""N: %d, M: %d\n"", N, M);

    for(i=0 ; i&lt;M ; i++){
        fflush(stdin);
        fscanf(stdin, ""%d %d %d"", &amp;a, &amp;b, &amp;k);
        fflush(stdout);
        fprintf(stdout, ""A: %d, B: %d, K: %d\n"", a, b, k);
        total += (((b-a)+1)*k);
        fprintf(stdout, ""total: %d\n"", total);
    }
    total = total/N;
    fprintf(stdout, ""%d\n"", total);
    return 0;
}
</code></pre>
",1
28524303,28524134,1,"<pre><code>fscanf(stdin, ""%d, %d, %d"", &amp;a, &amp;b, &amp;k);
</code></pre>

<p>Has the format string</p>

<pre><code>""%d, %d, %d""
</code></pre>

<p>Which means that <code>fscanf</code> expects you to type a number and then <strong>a comma</strong> and then the space discards any number of whitespace characters including none(which is redundant as <code>%d</code> already skips them) and then expects a number,a comma, any number of whitespace characters including none and then a number.</p>

<p>You type in three numbers seperated by a space. The <code>fscanf</code> reads the first number and fails to scan a comma. The rest of the calls to <code>fscanf</code> expects a number first, but found a comma in the <code>stdin</code>, thus failing.</p>

<p>To fix it, change</p>

<pre><code>fscanf(stdin, ""%d, %d, %d"", &amp;a, &amp;b, &amp;k);
</code></pre>

<p>To</p>

<pre><code>fscanf(stdin, ""%d %d %d"", &amp;a, &amp;b, &amp;k);
</code></pre>

<p>Or</p>

<pre><code>fscanf(stdin, ""%d%d%d"", &amp;a, &amp;b, &amp;k);
</code></pre>
",0
23848086,23847553,0,"<p>Move the included files from the EnzoLib.c to EnzoLib.h and only keep the #include ""EnzoLib.h""</p>

<p>The contents of the EnzoLib.h should be something like</p>

<pre><code>#ifndef ENZOLIB_H
#define ENZOLIB_H

#include &lt;winsock2.h&gt;
#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;

typedef struct {
    SOCKET sock;
    char nombre[64];
    char activo;
    struct sockaddr_in from;
} Socket;

#endif
//end of EnzoLib.h
</code></pre>

<p>Contents of EnzoLib.c should be online</p>

<pre><code>#include ""EnzoLib.h""

//Freely use the Socket structure
Socket mySocket;

//end of EnzoLib.c
</code></pre>
",0
23847648,23847553,1,"<p>When compiling <code>main.c</code>, the header <code>lib2.h</code>, which contains the definition of <code>MyTypedef</code>, is never included. Therefore, when compiling <code>main.c</code>, the compiler has <em>no idea</em> what that type is.</p>

<p>That is, after the preprocessor runs, the compiler sees two ""translation units"" (the standard calls a c file and all the headers it includes collectively a translation unit):</p>

<p><code>main.c</code> becomes:</p>

<pre><code>//main.c

#ifndef GUARD_LIB1
#define GUARD_LIB1

MyTypedef variable123;

#endif

int main(){

}
</code></pre>

<p>and <code>lib1.c</code> becomes:</p>

<pre><code>#ifndef GUARD_LIB2
#define GUARD_LIB2

typedef struct int MyTypedef;

#endif
#ifndef GUARD_LIB1
#define GUARD_LIB1

MyTypedef variable123;

#endif
</code></pre>

<p>In <code>lib1.c</code> the compiler knows what <code>MyTypedef</code> is, but in <code>main.c</code> it does not.</p>

<p>If you want to use a type in a header, then the header should include its dependencies. Have <code>lib1.h</code> include <code>lib2.h</code>, so that anyone who uses <code>lib1.h</code> can tell what <code>MyTypedef</code> is.</p>
",0
25472889,25472601,1,"<p>There are many things in this book that are outdated, as one would expect. However, you seem to misunderstand what this is about. </p>

<p>It is absolutely required, even more so than years ago, that when a function is called, the compiler needs to know a function prototype when the function is called. </p>

<p>For functions that are part of the Standard C library, the appropriate header file must be included. For functions that are not part of the Standard C library, like the ""atoif"" that you declared, a declaration within a function is an awfully bad practice and it would be much better to declare it in a header file and include it, put it is just as perfectly legal as it was back then. </p>
",1
25472974,25472601,1,"<p>But ... as a now scaly dynosaur, I can remember that in old K&amp;R days, we already used header to declare functions ! So for this part K&amp;R is still valid because including a header is no more no less than declaring a bunch of function prototypes.</p>

<p>The main difference between old K&amp;R C and modern C, is that in modern C we declare the return type <strong>and all parameters</strong>, whereas in K&amp;R only return type was declared (and we had to control ourselves with no compiler help that all parameters had correct type ... if not SIGSEGV !)</p>
",0
22483700,22483633,5,"<p>Add a space:</p>

<pre><code>while(scanf("" %19[^\n]"",str)==1){
             ^
</code></pre>

<p>The space (unintuitively) consumes <em>any</em> white-space, including the <code>\n</code>, which otherwise you are not handling.</p>

<p>Of course, it is generally better to use e.g. <code>fgets()</code> and <code>sscanf()</code> rather than <code>scanf()</code> to parse input.</p>

<p>This changes the logic of you code slightly, but maybe better captures your intent. Any attempt to only skip only <code>\n</code> rather than all white-space, as in:</p>

<pre><code>while(scanf(""%19[^\n]\n"",str)==1){
</code></pre>

<p>will fail, because here the second <code>\n</code> is exactly the same as a space <code></code>.</p>
",4
22483993,22483633,0,"<p>Find the modified code </p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    char str[20];
    while(gets(str)!=NULL)
    {
      printf(""%s"",str);
    }
    return 0;
}
</code></pre>
",2
22509811,22508468,0,"<p>You probably want this:</p>

<pre><code>u64 text[2] ;

FILE *input = fopen(""myfile.data"", ""r"") ;

if (input == NULL)
{
  printf (""Unable to open file\n"") ;
  return 1 ;
}

while (!feof(input))
{
  int charsread ;
  charsread = fread(text, 16, 1, input) ;  // read at most 16 bytes into the text array  

  // process your text array here
  // charsread contains the number of characters actually read
  //     this can be less than 16 if the total file length is not a 
  //     multiple of 16. You mus deal with that.

} 

fclose(input) ;
</code></pre>
",6
22518250,22518161,2,"<p><code>fscanf</code> returns the number of successful conversions made - check that and see if the call is working the way you expect (hint: it's not).</p>

<p>Turning on some warnings would be a good first step.  The <code>%f</code> format you're using in the <code>fscanf()</code> call doesn't match the <code>double *</code> argument you're assing.  Use <code>%lf</code>.  From <a href=""http://clang.llvm.org"" rel=""nofollow"">clang</a>:</p>

<pre><code>example.c:29:36: warning: format specifies type 'float *' but the argument has
      type 'double *' [-Wformat]
while ((fscanf(fp, ""%c %f"", &amp;code, &amp;amount)) != EOF){
                       ~~          ^~~~~~~
                       %lf
</code></pre>
",1
23811903,23811828,2,"<p>In your code <code>ch</code> is not a <code>char</code>, it is <code>char[20]</code> - an array of 20 characters. You cannot assign a result of <code>fgetc</code> to it, because <code>fgetc</code> returns an <code>int</code> (which contains either a single <code>char</code>, or an <code>EOF</code> mark).</p>

<p>Change the declaration of <code>ch</code> to <code>int ch</code> to fix this problem. You can also drop the call to <code>feof</code> because it happens at the wrong time anyway (you call it after read operations, not before read operations).</p>

<pre><code>for (;;) {
    int ch = fgetc(file);
    if (ch == EOF) break;
    if (ch == '\n') lines++;
}
</code></pre>
",0
23826638,23811828,0,"<pre><code>void trinti1()
{
    int b,lines=0;
    int ch;

    FILE* file = fopen (""Kordinates.txt"", ""r"");

    while(EOF!=(ch=fgetc(file)))
    {
        if(ch == '\n')
        {
            ++lines;
        }
    }

    fclose(file);
}
</code></pre>
",0
23583531,23583480,1,"<p>^D will send an EOF on stdin.</p>

<p>From the manpage:</p>

<pre><code>   On success, getline() and getdelim() return the number of characters read, including the delimiter character, but not includ©\
   ing the terminating null byte.  This value can be used to handle embedded null bytes in the line read.

   Both functions return -1 on failure to read a line (including end-of-file condition).
</code></pre>
",2
23610213,23610182,5,"<p>In short and simple, the compiler translates anything in the form <code>x[y]</code> to <code>*(x + y)</code>. So <code>2[a]</code> translates to <code>*(2 + a)</code> which is the same as <code>*(a + 2)</code> from <code>a[2]</code>.</p>
",2
23811007,23810775,0,"<p>Use clock() instead of time(). You should be able to just change time(NULL) to clock(). clock_t can replace time_t as well.</p>
",2
25540412,25540386,5,"<p>No, it is not valid. The prototype expected by the caller doesn't match the prototype of the function being called, so undefined behavior may result. The specific result will depend on such factors as the compiler and the calling convention (the called function may merely end up seeing garbage in <code>arg</code>, or the thread stack may get corrupted resulting in a crash).</p>
",3
25540670,25540386,3,"<p>Andrew Medico is right when he says that it is invalid, but in actual practice, it is certainly going to work on the vast majority of current ABIs, and work reliably.</p>

<p>Most ABIs used today let the caller do all the stack maintenance and/or pass arguments in registers, so if you give a function more arguments than it asks for, noone is going to notice. You're just going to have some unused stack space, or write a value to a register that is never used.</p>

<p>In actual fact, you can often do the reverse as well; that is, to give a function fewer arguments than it asks for. It's going to receive undefined values for those arguments, but if it doesn't use them you'll be alright. In fact, the standard POSIX C function <code>open()</code> depends on this behavior, which goes to show how uncommon it is for C ABIs to choke on these things, both now and historically.</p>

<p>If possible, you should of course avoid relying on this kind of behavior working, but especially if you don't care about being overly portable I don't <em>really</em> see a reason to balk at it. You <em>should</em>, however, be very well aware of what you're doing, and you shouldn't use these kinds of tricks if you don't feel that you are well-versed in the reasons for why they may or may not work.</p>

<p>One occasion where this would not work is if you're writing functions in a Pascal/BASIC-like ABI (like <code>stdcall</code> on Windows), where the caller sets up the stack but the callee cleans it up. In this case, the caller would have pushed two arguments but the callee only pop off one, so the stack pointer would not match its pre-call value after returning, which would cause all kinds of weirdness, including but not limited to the caller function not using the proper return address when it in turn returns. Crashes would be guaranteed. This is quite an unusual thing to do in C, however.</p>
",0
26407837,26407794,1,"<p>because of the stored <kbd>enter</kbd> key press [considered as character input]. use one <code>getch();</code> before the third <code>scanf()</code>.</p>

<p>alternatively, use <code>(scanf("" %c"",&amp;c);)</code> [mind the space before <code>%c</code>] which will get rid of any number of whitespace [buffered] character present before actual input.</p>
",0
29198023,29197978,1,"<p>No, this is a local variable and is stored in the stack for that method, outside that method the stack does not exist and can not be read</p>
",1
29198065,29197978,1,"<p>If you want to just use the value of <code>i</code>, you can use:</p>

<pre><code>void bar(int i);

void foo() {
    int i = 3;
    bar(i);
}

void bar(int i) {
    //print i in foo()
}
</code></pre>

<p>If you want to be able modify the value of <code>i</code>, use:</p>

<pre><code>void bar(int* ip);

void foo() {
    int i = 3;
    bar(&amp;i);
}

void bar(int* ip) {
   *ip = 20;
}
</code></pre>
",1
29198068,29197978,0,"<p>Simply pass <code>i</code> from <code>foo</code> to <code>bar</code> as parameter:</p>

<pre><code>bar(i);

void bar(int i)
</code></pre>
",0
29198088,29197978,1,"<p>C uses static scoping. You can check this here: <a href=""https://msujaws.wordpress.com/2011/05/03/static-vs-dynamic-scoping/"" rel=""nofollow"">https://msujaws.wordpress.com/2011/05/03/static-vs-dynamic-scoping/</a> :)</p>
",0
29200396,29197978,0,"<p>You can, but you have to pass it to <code>foo</code> as an argument. The reason for this is that when a C function is called it creates any local variables defined inside it on the stack, which is essentially just a form of dynamic memory allocation. When the function returns, it frees the memory used by those variable. Now you might think there should be some way for <code>bar</code> to know about <code>i</code> since it is still present on the stack when <code>bar</code> is called inside <code>foo</code>. But the problem is that C does not make any assumptions about who might be calling the <code>bar</code> function. You could just as easily call <code>bar</code> from a third function that has no <code>i</code> defined within it. For this reason there is no mechanism for accessing stack variables from a nested function without passing them explicitly.</p>

<p>Interestingly, having the ability to do this built into the language is one of the key features that allows for the implementation of closures. So if you have ever struggled to understand what made these so special, this is basically it. Probably not as spectacular as the hype might have lead you to believe.</p>
",0
23058894,23049452,0,"<p>Try this:</p>

<pre><code>#include ""stdio.h""
#include ""math.h""

void metersToFeetAndInches(float meters, float *feetsPtr, float *inchesPtr)
{
    *inchesPtr = modff(meters * 3.28084, feetsPtr) * 12;
}


int main()
{
    float meters;
    float feet;
    float inches;

    printf(""How many meters are you trying to convert?\n"");
    fscanf(stdin, ""%f%*[^\n]"", &amp;meters);

    metersToFeetAndInches(meters, &amp;feet, &amp;inches);
    printf(""%.3f meters is equal to %1.0f feet and %.3f inches.\n"",
           meters, feet, inches);
    return 0;
}
</code></pre>

<p>Some remarks:</p>

<ul>
<li>It is better to use the same unit throughout for calculations (here float).</li>
<li>You forgot to convert fractional feet to inches.</li>
</ul>
",0
24077126,24076781,0,"<p>You can use this, but please note that you will not be able to utilize a <code>union1</code> array:</p>

<pre><code>typedef struct
{
    short a;
    short b;
    short c;
    short d;
}
str1;

typedef union
{
    str1  my_str;
    short my_array[0];
}
union1;

union1* allocate_union1(int additional_size)
{
    return (union1*)malloc(sizeof(union1)+additional_size);
}
</code></pre>

<p>If you get a compiler warning for the <code>[0]</code>, then you may replace it with a <code>[1]</code>.</p>
",0
24076878,24076781,1,"<p>What I'd do is make <code>my_array</code> a pointer, like this:</p>

<pre><code> typedef union
 {
     struct
     {
         short int a;
         short int b;
         short int c;
         short int d;
     } str1;
     short int *my_array;
 } union1; 
</code></pre>

<p>That way you could do:</p>

<pre><code>union1 foo;
foo.my_array = malloc(bar * sizeof(short int));
</code></pre>

<p>I've removed the inner <code>typedef</code> you used because it served no purpose and caused compiler errors. I assume you meant to use an anonymous <code>struct</code>?</p>
",10
21029925,21029809,0,"<p><code>scanf</code> removes whitespace automatically from <em>before</em> the datum it's trying to get. An exception to this is the character formats (primarily <code>%c</code>), which don't remove whitespace. However, <code>scanf</code> leaves whitespace <em>after</em> the datum. Therefore, you'll need a way to get rid of that. Use</p>

<pre><code>getc(stdin);
</code></pre>

<p>you can then continue on your merry way. <a href=""http://www.cplusplus.com/reference/cstdio/getc/"" rel=""nofollow"">This page</a> has more documentation on <code>getc</code>.</p>
",2
21030135,21029809,1,"<p><code>scanf(""%s"",c)</code> left the <kbd>Enter</kbd> or <code>\n</code> in <code>stdin</code>.  When <code>gets()</code> executed it consumed that and returned an empty string.  <code>gets()</code> reads in all data up to the <code>\n</code> and trims it off before returning.</p>

<p>The format specifiers like <code>%d %s</code>, etc. (all except <code>%n %c %[</code>) and the whitespace format directives like <code>"" ""</code> direct <code>scanf()</code> to skip leading whitespace.  <code>scanf()</code> itself does not skip leading whitespace.</p>

<p>Suggest using <code>fgets()</code> and avoid using <code>gets()</code>.</p>

<pre><code>char buf[100];
printf(""enter a word\n"");
fgets(buf, sizeof buf, stdin);
sscanf(buf, ""%29s"", c);  // 29 because c is size 30
printf(""%s\n"",c);

printf(""enter a sentence\n"");
fgets(d, sizeof d, stdin);
printf(""%s"",d);
</code></pre>
",1
21029869,21029809,1,"<p><strong><code>gets</code> doesn't skip the white-space characters before starting to read the string while <code>scanf</code> does</strong>.<br>
After your first input, there is <code>\n</code> character in the buffer left behind by first <code>scanf</code> call. This <code>\n</code> is read by <code>gets</code> but <code>scanf</code> skips this white-space character.<br>
this can be solved by using a <code>getchar</code> statement after the <code>scanf</code> call.  </p>

<pre><code>printf(""enter a word\n"");
scanf(""%s"",c);
getchar();  
</code></pre>

<p>Do not use <code>gets</code> neither <code>scanf</code> (they do not check array bound), instead use <code>fgets</code>.  </p>

<pre><code>printf(""enter a word\n"");
fgets(c, 30, stdin);
printf(""%s"",c);
printf(""enter a sentence\n"");
fgets(d, 30, stdin);
printf(""%s"",d);
</code></pre>
",5
21029872,21029809,1,"<p>Scanf leaves behind ""\n""(without quotes) and then gets() function reads only it.</p>
",0
24124260,24124021,0,"<p>Something like...</p>

<pre><code>char str[50];
char tmp[50];
str[0] = '=';
str[1] = 0;
while (mnumber&gt;0)
{
     int n = mnumber % 10;
     mnumber /= 10;
     if (mnumber&gt;0)
        sprintf (tmp,""%s%d*"", str, n );
     else
        sprintf (tmp,""%s%d"", str, n );
     strcpy ( str, tmp);
}
printf (""%s\n"",str);
</code></pre>
",1
24124070,24124021,1,"<p>To solve the problem using your approach, you have to remove the most significant part of the number, once you have processed it. For example:</p>

<pre><code>num5 = mnumber/10000;
mnumber -= num5*10000;
num4  = mnumber/1000;
mnumber -= num4*1000;
num3 = mnumber/100;
mnumber -= num3*100;
num2 = mnumber/10;
mnumber -= num2*10;
num1 = mnumber;
</code></pre>

<p>However, I think it would be cleaner to convert to a string and then print out each character of that string, alternating with an asterisk, as @clcto demonstrates.</p>
",2
24124117,24124021,0,"<p>You can use the modulus <code>%</code> operator to make your life easier.</p>

<pre><code>num5 = (mnumber/10000);
num4 = (mnumber/1000) % 10;
num3 = (mnumber/100) % 10;
num2 = (mnumber/10) % 10;
num1 = (mnumber/1) % 10;
</code></pre>
",0
24124154,24124021,1,"<p>You can convert the number to a string (or possibly read in the input as a string and do validation on it), and then print it one character at a time:</p>

<pre><code> char input_str[15];
 sprintf( input_str, ""%d"", mnumber );

 int len = strlen( input_str );
 if( len &gt; 0 )
     printf( ""%c"", input_str[0] );

 for( int i = 1; i &lt; len; ++i )
     printf( ""*%c"", input_str[i] );
</code></pre>
",1
26207291,26207174,2,"<p>The loop runs more than once, and each time the loop runs, the value of b will be less than the previous iteration because (a % b) is an integer in the range [0, b), which is exclusive of b. </p>

<p>On the first iteration:
a = 481, b = 910</p>

<p>For the second iteration:
b = a % b => 481
a = 910</p>

<p>For the third iteration 
a = 481
b = (910 % 481) = 429</p>

<p>tmp will never be 0 because if b is 0, then the loop stops and 0 will not be assigned to tmp. </p>
",0
26207342,26207174,2,"<p>Note first that the variables <code>a</code> and <code>b</code> are passed to <code>gcd()</code> by value.  That means that the local variables (parameters) <code>a</code> and <code>b</code> in the function <code>gcd()</code> are unrelated to the variables <code>a</code> and <code>b</code> in <code>main()</code> except by coincidence of naming.</p>

<p>Within the function, before the loop, the values are:</p>

<pre><code>a = 481    b = 910
</code></pre>

<p>Since <code>b</code> is not zero, the loop is executed:</p>

<pre><code>a = 481    b = 910
tmp := 910
b := 481 % 910 := 481
a := 910
</code></pre>

<p>and then the loop checks again, and <code>b</code> is still not zero:</p>

<pre><code>a = 910    b = 481
tmp := 481
b := 910 % 481 := 429
a := 481
</code></pre>

<p>and the loop repeats again because <code>b</code> is still not zero:</p>

<pre><code>a = 481    b = 429
tmp := 429
b := 481 % 429 := 52
a := 429
</code></pre>

<p>and again:</p>

<pre><code>a = 429    b = 52
tmp := 52
b := 429 % 52 := 13
a := 52
</code></pre>

<p>and a final time through the body of the loop:</p>

<pre><code>a = 52     b = 13
tmp := 13
b := 52 % 13 := 0
a := 13
</code></pre>

<p>and now <code>b</code> is zero, so the loop terminates, and the value in <code>a</code>, which is <code>13</code>, is returned.</p>

<p>Note that the values of <code>a</code> and <code>b</code> in <code>main()</code> are unchanged.  You could demonstrate this with:</p>

<pre><code>printf(""GCD(%d, %d) = %d\n"", a, b, result);
</code></pre>

<p>which is a better output in that it identifies the input values as well as the result.</p>
",0
26207474,26207174,2,"<p>If you work through each iteration yourself, you'll find that it does indeed terminate:</p>

<p>Iteration 1:<br>
a == 481<br>
b == 910</p>

<p>Iteration 2:<br>
a == 910<br>
b == 481</p>

<p>Iteration 3:<br>
a == 481<br>
b == 429</p>

<p>Iteration 4:<br>
a == 429<br>
b == 52</p>

<p>Iteration 5:<br>
a == 52<br>
b == 13</p>

<p>Iteration 6:<br>
a == 13<br>
b == 0  &lt;-- TERMINATES</p>

<p>Feel free to ask if it doesn't make sense just yet.</p>
",0
23814291,23814272,4,"<p>You want to replace this line:</p>

<pre><code>minmax(t, double* min, double* max);
</code></pre>

<p>with:</p>

<pre><code>minmax(t, &amp;min, &amp;max);
</code></pre>

<p>Using <code>&amp;</code> means you're passing the address of the variable, which is what the function <code>minmax</code> is expecting (since it uses pointers, it's expecting the address).</p>

<p>PS: normally, you have to pass the size of the array along with the array when you pass it to a function. You've hardcoded the size of the array into the function, which works great in this case. In the future, try to remember to pass the array along with it's size; it's good C coding practice.</p>

<p><strong>EDIT after OP comment</strong></p>

<p>Here is the function, with comments to indicate changes to make in the function:</p>

<pre><code>void minmax(double tomb[], double* mini , double* maxi) {
    int i;
    *mini=tomb[0]; // change here; original: mini=&amp;tomb[0];
    *maxi=tomb[0]; // change here; original: maxi=&amp;tomb[0];
    for(i=1; i&lt;10; i++){
        if(tomb[i]&gt;*maxi){
            *maxi=tomb[i]; // change here; original: maxi=&amp;tomb[i];
        }
        if(tomb[i]&lt;*mini){
            *mini=tomb[i]; // change here; original: mini=&amp;tomb[i];
        }
    }
}
</code></pre>
",2
24124386,24124358,5,"<pre><code>**arkadas = (int **)malloc( t*sizeof( int* ));
</code></pre>

<p>should be</p>

<pre><code>arkadas = malloc( t*sizeof( int* ));
</code></pre>

<p><code>**arkadas</code> dereferences an uninitialised pointer, resulting in you trying to write to an unpredictable address.  You don't own the memory at this address so it isn't safe to try and write to it.</p>

<p>The second form assigns the address of an array of pointers to the local variable <code>arkadas</code>; this is what need to do.</p>

<p>Later in your program</p>

<pre><code>if(komsu[i][j]==1){
    komsuSayisi++;
    arkadas[i][x]=j;
    x++;
}
arkadas[i] = (int *) realloc(arkadas[i], x);
</code></pre>

<p>code inside the <code>if</code> condition attempts to write to <code>arkadas[i]</code> before you allocate it.  This also invokes undefined behaviour and will likely crash.  You can avoid the crash by removing the line <code>arkadas[i][x]=j;</code> and swapping your <code>realloc</code> call for <code>malloc</code> (you need the address of a previous allocation before you can call <code>realloc</code>)</p>

<pre><code>if(komsu[i][j]==1){
    komsuSayisi++;
    x++;
}
arkadas[i] = malloc(x*sizeof(int));
</code></pre>
",4
24124653,24124358,1,"<p>I see</p>

<pre><code> komsuSayisi++;
</code></pre>

<p>You didn't paste the whole code but probably thats what is crashing your program... I don't see any initializing previous to that increment.... </p>

<p>this plus the deferentiation posted on the other answer</p>
",0
25463771,25463692,3,"<p>Since you said you're given the array size as a <strong>variable</strong> <code>n</code>, feel free to use it as a loop counter:</p>

<pre><code>while (n &gt; 0) {
    --n;
    temp = 0; // the sum
    for (i = a[n] - 1; i &gt; 0; --i) {
        if (a[n] % i == 0) {
            temp += i;
        }
    }
    a[n] = temp;
}
</code></pre>
",0
25450021,25449655,0,"<p>see realloc's definition:</p>

<pre><code>void *realloc(void *ptr, size_t size);
</code></pre>

<p>in your case, you don't provide any <code>ptr</code> argument in your call to realloc. For me, this doesn't even compile:</p>

<blockquote>
  <p>error: too few arguments to function ¡®realloc¡¯</p>
</blockquote>

<p>Realloc returns a pointer to the newly allocated memory. You should pass in the old pointer to realloc and make it return to the new one, like:</p>

<pre><code>char* new_finished_line = NULL;
new_finished_line = realloc(finished_line, sizeof(char)*finish_length);
/* if realloc was successful, it already freed finished_line pointer
 * and it returned to new_finished_line */
if (new_finished_line != NULL) {
    finished_line = new_finished_line;
}
/* if new_finished_line is NULL, then finished line is still allocated */
else {
    free(finished_line);
    printf(""realloc error\n"");
    exit(1);
}
</code></pre>

<p>However, after some syntax fixes, your version on my machine did not made that memory leaks. Maybe think of redesigning your algorithm? You can try with the code below, where file is read char by char and if newline character was read, then space is written to buffer. There are many different ways of achieving that.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

char* read_my_file(char* name) {
    char* store;
    char* new_store = NULL;
    int SIZE = 10;
    int x;
    int i = 0;
    store = malloc(SIZE);
    FILE* fp = fopen(name, ""r"");
    while (( x = fgetc(fp) ) != EOF) {
        if (x == '\n') {
            store[i] = ' ';
        }
        else {
            store[i] = x;
        }
        if (i &gt; SIZE - 2) {
            SIZE *= 2;
            new_store = realloc(store, SIZE);
            if (new_store != NULL) {
                store = new_store;
            }
            else {
                fprintf(stderr, ""realloc error"");
                free(store);
                exit(1);
            }
        }
        i++;
    }
    store[i] = '\0';
    fclose(fp);
    return store;
}

int main(void)
{
    char* container = read_my_file(""YOUR_FILE_TO_READ.txt"");
    printf(""%s\n"",container);
    free(container);
    return 0;
}
</code></pre>

<p>My algorithm might not be the greatest one, I just want to show that there are many ways of doing that.</p>
",2
26230749,26230526,0,"<p><code>fgets</code> reads too much. After first <code>realloc</code> <code>line_pos</code> is 9999 and <code>max_line_len</code> is 20000, which means you end up reading to indexes 9999 .. 29999, when the last valid index of <code>line</code> is only 19999.</p>
",7
31821183,31821159,1,"<p><code>sleep</code> is a non-standard function:</p>

<ul>
<li>On UNIX use <code>&lt;unistd.h&gt;</code></li>
<li>On MS-Windows use <code>&lt;windows.h&gt;</code></li>
</ul>

<p>There is no way work around this besides writing your own code:</p>

<pre><code>void sleep (int seconds)
{
    Sleep (seconds * 1000);  // Converting to milliseconds
}
</code></pre>
",3
31821197,31821159,2,"<blockquote>
  <p>How can I get my first code compiled successfully?</p>
</blockquote>

<p>You can't (at least exactly with this code as you stated). The point is that <code>&lt;stdio.h&gt;</code> header does not provide declaration for <code>sleep()</code> and C standard requires, that every function needs to be declared before its call. It's as simple as that.</p>

<p>The second thing is that <code>sleep()</code> function, that you want is likely from <a href=""https://en.wikipedia.org/wiki/POSIX"" rel=""nofollow"">POSIX</a> (specifically from <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/unistd.h.html"" rel=""nofollow""><code>&lt;unistd.h&gt;</code></a> header). However, Visual Studio 2013 is <em>not</em> POSIX-compliant. Thus, the solution is to use <code>Sleep()</code>, that is declared in <code>&lt;Windows.h&gt;</code> header or possibly some other alternative.</p>
",0
31821200,31821159,2,"<p><a href=""http://linux.die.net/man/3/sleep"" rel=""nofollow noreferrer"">Sleep</a> is not a C standard function.</p>

<p>If you are on a UNIX system, then include <code>&lt;unistd.h&gt;</code>. However, if you are on a windows system, it should be in <code>&lt;windows.h&gt;</code> (which is why your second version of the code compiles successfully.</p>

<p>If you want to use in both systems, try something like this (from <a href=""https://stackoverflow.com/questions/6649936/c-compiling-on-windows-and-linux-ifdef-switch"">here</a>):</p>

<pre><code>#ifdef __linux__ 
    //linux include code goes here
#elif _WIN32
    // windows include code goes here
#else

#endif
</code></pre>
",0
31821202,31821159,1,"<p>The sleep function is not declared in <code>&lt;stdio.h&gt;</code>. If you're on unix, use <code>sleep()</code> from unistd.h, or for windows, <code>Sleep()</code> from Winbase.h (windows.h). If you want to see how <code>Sleep()</code> works, you can see <a href=""https://stackoverflow.com/questions/1719071/how-is-sleep-implemented-at-os-level"">how is sleep implemented at OS level?</a>.</p>

<p>If you want to do it without having to change <code>sleep()</code> to <code>Sleep()</code>, you could use a macro:</p>

<p><code>#define sleep(s) Sleep((s) * 1000)</code></p>

<p>Macros are bad, so you may not want to do this in production code, but the advantage of the macro is that it will be guaranteed to be inlined, which will result in faster code.</p>
",0
27540796,27540759,2,"<p>You are storing every string in the same place, overwriting the previous string each time.  Don't do that.  <code>str</code> is a buffer, and all of the pointers in the array <code>arr</code> are pointing at it.  </p>
",0
27540805,27540759,0,"<p>Because you keep on using the same <code>char[] str</code> for all strings.</p>

<p>Instead, you probably want to allocate a new memory block for each string. Don't forget to free them again after use.</p>

<p>You can check that in the loop</p>

<pre><code>while(i&lt;in)
{
  printf(""%p\t%s\n"",arr[i],arr[i]);
  i++;
}
</code></pre>

<p>and you see that not only the string is the same, but its address as well.</p>
",0
27540835,27540759,1,"<p>Because you are assigning the memory address to the array of pointer. So the address of the 
array will not be changed. Every array of pointer is pointing to the same address. </p>

<p>When the new value is get then it will place that value in array at same address position. </p>

<p>So the all values are remaining same. So avoid this you can make the str to pointer. And allocate the memory to that pointer dynamically.</p>

<p><code>char *str;</code>Make the allocation in while loop
<code>str=malloc(MAX);</code></p>

<pre><code>while(i&lt;in)
{ str=malloc(100);//change
    scanf(""%s"",str);
    arr[i]=str;
  //  printf(""%s\n"",arr[i]);
    i++;
}
</code></pre>

<p>100 is an example. you can use your needed value.</p>
",0
27540853,27540759,2,"<p>Your problem is <code>arr[i]=str;</code> statement. </p>

<p><code>str</code> is a statically allocated array, and <strong>all</strong> the <code>arr[i]</code> are storing the base address of it. </p>

<p>As the value of <code>str</code> get overwritten in every call to <code>scanf()</code>,  in your case, only the last value stored in <code>str</code> will be printed by accessing <strong>any</strong>  <code>arr[i]</code>.</p>

<p>What you need to do</p>

<ol>
<li>Allocate memory <a href=""http://linux.die.net/man/3/malloc"" rel=""nofollow"">dynamically</a> to <code>arr[100]</code>.</li>
<li>use <a href=""http://linux.die.net/man/3/strcpy"" rel=""nofollow""><code>strcpy()</code></a> to copy the user input from <code>str</code> to <code>arr[i]</code></li>
</ol>

<p>Note: Don't forget to <a href=""http://linux.die.net/man/3/free"" rel=""nofollow""><code>free()</code></a> the allocated memory at last.</p>
",0
27540856,27540759,1,"<p>Try something like this in your loop.</p>

<pre><code>while(i&lt;in)
{
    scanf(""%s"",str);
    arr[i]=malloc(sizeof(char) * strlen(str));
    strcpy(arr[i],str);
  //  printf(""%s\n"",arr[i]);
    i++;

}
</code></pre>
",0
27540872,27540759,0,"<p>You need to allocate memory for each string <code>arr[i]</code> and then use <code>strcpy</code> for copy string.</p>

<p>Add some code like below in your loop.</p>

<pre><code>arr[i]=malloc(strlen(str)+1);
strcpy(arr[i],str);
</code></pre>

<p>Also never forgot to free memory for above allocation at the end of program.</p>
",0
27541826,27540759,0,"<p>In addition to the other responses, there are a few alternative ways to approach reading string input that you can use to simplify the what you need to keep track of in the program. As others suggested, instead of declaring <code>arr</code> as <code>char *arr[100]</code>, go ahead and declare it as a <code>pointer-to-pointer-to-char</code>. </p>

<pre><code>char **arr = NULL;
</code></pre>

<p>This allows you to allocate an array of character pointers. You can choose to allocate with <code>malloc</code> or you can choose to allocate and initialize all pointers to <code>zero/NULL</code> simply by using <code>calloc</code> instead. </p>

<pre><code>arr = calloc (100, sizeof *arr);
</code></pre>

<p>By using <code>calloc</code>, this allows later iteration over only those pointers that contain strings. This further eliminates having to ask for the number of strings to enter (or keep track of how many were entered).</p>

<p>After you have allocated your pointers, you need to allocate space to hold each string. While there is nothing wrong with another call to <code>malloc</code> (or <code>calloc</code>) and then a call to <code>strcpy</code> (or <code>strncpy</code>), you can do both at once with the function <code>strdup</code> provided in <code>string.h</code>. The only thing to be aware of with <code>strdup</code> is that it is allocating memory for you. Therefore, you are responsible for freeing that memory when no longer needed. </p>

<p>Putting the pieces together, as well as the information from the comment regarding your <code>scanf</code> string, you can implement your string collection as follows. <strong>Note</strong> You simply enter as many strings as you like (up to the 100 pointers initially allocated), then press <code>[enter]</code> on a blank line when you are done:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main ()
{
    int i = 0;                              /* always initialize your variables */
    char **arr = NULL;
    char str[14] = { 0 };

    arr = calloc (100, sizeof *arr);        /* create 100 pointers to char*     */

    printf (""\nEnter strings ( [enter] alone when done )\n\n"");

    while (printf ("" input: "") &amp;&amp; scanf (""%[^\n]%*c"", str) &gt;= 1)
        arr[i++] = strdup (str);            /* strdup allocates and copies  */

    printf (""\nThe strings entered were:\n\n"");
    i = 0;                                  /* print the array              */
    while (arr[i]) {
        printf ("" arr[%2d]: %s\n"", i, arr[i]);
        i++;
    }

    i = 0;                                  /* free memory allocated        */
    while (arr[i])
        free (arr[i++]);
    if (arr)
        free (arr);

    return 0;
}
</code></pre>

<p><strong>output:</strong></p>

<pre><code>$ ./bin/str_array

Enter strings ( [enter] alone when done )

 input: string 1
 input: string 2
 input: string 3
 input:

The strings entered were:

 arr[ 0]: string 1
 arr[ 1]: string 2
 arr[ 2]: string 3
</code></pre>

<p>There are many, many ways to approach this problem. Compare all the answers and add the different approaches to your collection. There are always places where one will have benefits over the other, and vice-versa. Note, in the above code you should check whether any allocation with <code>calloc</code>, <code>malloc</code>, or <code>strdup</code> succeeds and handle the error if it fails. You should also check when you get to the 99th sting entered and reallocate the number of pointers as needed. Those checks are omitted for clarity. </p>

<p><strong>valgrind memory useage summary</strong></p>

<p>Get in the habit of always verifying your memory usage with <code>valgrind</code>. It will point out any place where you have allocated memory that you have failed to free. While the memory in a short bit of code like this will be freed on <code>exit</code>, in longer code, failing to keep track of the memory you allocate can lead to significant amounts of memory in use by your program after it is no longer needed (memory leaks). A quick check with <code>valgrind</code> will disclose any problems or confirm all is well:</p>

<pre><code>==28677== HEAP SUMMARY:
==28677==     in use at exit: 0 bytes in 0 blocks
==28677==   total heap usage: 4 allocs, 4 frees, 827 bytes allocated
==28677==
==28677== All heap blocks were freed -- no leaks are possible
==28677==
==28677== For counts of detected and suppressed errors, rerun with: -v
==28677== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 2 from 2)
</code></pre>

<p>Let me know if you have any questions.</p>
",0
25546595,25546520,1,"<p><code>void function ((char **) &amp;p)</code> if my memory is not cheating me is not valid C syntax. The closest you can get to the validity is to remove the inner <code>(</code> and <code>)</code> and compile as C++ an then it would be a reference to a pointer of a char pointer.</p>

<p>The first one is just a ""plain"" char pointer.</p>
",1
25546597,25546520,-1,"<p>Your idea is good: the operators <code>*</code> and <code>&amp;</code> cancel each other when assigning values, but not in  declarations, just like <code>*</code> and <code>/</code>, but the header:</p>

<pre><code>void function ((char **) &amp;p);
</code></pre>

<p>can't be compiled by a C compiler.</p>
",1
27685355,27663052,0,"<p>This looks like homework.</p>

<p>I'll give some pointers.</p>

<p>Once you have the input chars converted to an actual <code>int</code> or <code>long</code> (or <code>long long</code> in your case), do NOT muck around with digits - especially in base 10. If you're going to do anything like that then you may as well leave it in <code>char</code> array form. This bit is not needed:</p>

<pre><code>while (digits1 != 0)
{
    digits1 = x/10;
    cnt++;
}
</code></pre>

<p>You have uninitialised values. Don't assume that everything is automatically initialised to zero. Sometimes you get lucky... but often you won't.</p>

<p>This looks good:</p>

<pre><code>for(int j = 1; j &lt;= cnt; j++)
{
    rem = x % N[j]; //not quite right N is ASCII
    if (rem == 0)
    {
        digits2++;    
    }
}  
</code></pre>
",0
23596830,23596628,1,"<p>The addition is buggy. So, print (if it is not buggy) can not make anything about it.</p>

<p>The problem lies here:</p>

<pre><code>static void book_details(char title[MAX_TITLE_LENGTH + 1],
                         char author[MAX_AUTHOR_LENGTH + 1], int year, int bn) {
  char line[301];

  fprintf(stderr, ""Enter Year:\n"");
  read_line(stdin, line, 4);
  // I changed %i to %d, which is the one you should use for integers
  sscanf(line, ""%d"", &amp;year);
  fprintf(stderr, ""Entered Year: %d\n"", year);

  // and here yes, year has the value that you expect, but because it is passed by value, when the function is terminated, all the changes made to year will be lost
}

static void menu_add_book(char title[MAX_TITLE_LENGTH + 1],
                      char author[MAX_AUTHOR_LENGTH + 1], int year, int bn) {
  // you call book_details here, and you pass year by value!!!!!
  book_details(title, author, year, bn);
  place_book(title, author, year, bn);
}
</code></pre>

<p>In case you want a refresh for passing variables by value and by reference, I have a small example <a href=""http://gsamaras.wordpress.com/code/functions-in-c/"" rel=""nofollow"">here</a>.</p>

<p>Following the comment of the OP and my example in the link, you could something like this in the case that you want to call two functions from main and preserve the changes:</p>

<pre><code>void bla(int* argumentTwo)
{
  *argumentTwo = 32000;
}


/* Definition of function foo. */
void foo(int argumentOne, int* argumentTwo)
{
    argumentOne = 1500;
    bla(argumentTwo);
}
</code></pre>
",6
32397962,32395670,2,"<p>As others(@BLUEPIXY and @BillDoomProg) have already pointed in the comments, your problem is the space in your <code>scanf</code> format string. Also check <a href=""https://stackoverflow.com/questions/6582322/what-does-space-in-scanf-mean"">this answer</a>.</p>

<p>Change both your <code>scanf</code> format string from:</p>

<pre><code>scanf(""%d "",&amp;m);
...
scanf(""%d "",&amp;num);
</code></pre>

<p>To:</p>

<pre><code>scanf(""%d"", &amp;m);
...
scanf(""%d"", &amp;num);
</code></pre>

<p>Just remove the space and it will work fine.</p>

<h1>scanf()</h1>

<h3>From the manual</h3>

<blockquote>
  <p>The format string consists of a sequence of directives(...)</p>
  
  <p>A directive is one of the following:</p>
  
  <p>A sequence of white-space characters (space, tab, newline, etc.; see
  isspace(3)). This directive matches any amount of white space, including 
  none, in the input. </p>
</blockquote>

<p>Also note that <code>stdin</code> is buffered, so the results are a little different from what you would expect:</p>

<pre><code>man stdin
</code></pre>

<blockquote>
  <h2>Notes</h2>
  
  <p>The stream <em>stderr</em> is unbuffered. The stream <em>stdout</em> is line-buffered when 
  it points to a terminal. Partial lines will not appear until fflush(3) or 
  exit(3) is called, or a newline is printed. This can produce unexpected 
  results, especially with debugging output. The buffering mode of the 
  standard streams (or any other stream) can be changed using the setbuf(3) 
  or setvbuf(3) call. Note that in case <strong>stdin is associated with a terminal, 
  there may also be input buffering in the terminal driver, entirely 
  unrelated to stdio buffering</strong>. (Indeed, normally terminal input is line 
  buffered in the kernel.) This kernel input handling can be modified using 
  calls like tcsetattr(3); see also stty(1), and termios(3).</p>
</blockquote>

<h1>So, lets examine your program step by step.</h1>

<p><em>Your program starts running and you enter the number 2. This is what the input buffer looks like:</em></p>

<pre><code>2\n
</code></pre>

<p><code>scanf(""%d "", &amp;m)</code> assigns 2 to the <code>m</code> variable and starts trying to match a space. It gets a <code>NL</code> and <code>EOL</code>. Control is still with this <code>scanf</code> because it just matched a newline (considered a white-space) and is waiting to match more, but instead it got the <code>End-Of-Line</code>, so it is still waiting when you type:</p>

<pre><code>1\n
</code></pre>

<p>Then reads <strong>stdin</strong> again and realizes that the next character in the input stream is not a space and returns (it's format string condition was done). At this point, you <strong>enter the loop</strong> and your next <code>scanf(""%d "",&amp;num)</code> is called and it wants to read an integer, <em>which it does</em>: it reads 1 and stores that in the <code>num</code> variable.  Then again it starts matching white-spaces and gets the new-line and it repeats the above pattern. Then when you enter:</p>

<pre><code>2\n
</code></pre>

<p>That second <code>scanf</code> gets a character different than a white-space
and returns, so your loop scope keeps executing printing the current <code>sum</code>.
The loop break condition is not met, so it starts again. It calls the
<code>scanf</code> and it effectively reads an integer into the variable, then the
pattern repeats itself...</p>

<pre><code>3\n
</code></pre>

<p>It was waiting for a white-space but it got a character instead. So your
<code>scanf</code> returns <strong>and now the loop break condition is met</strong>. This is where you exit your loop, prints the whole <code>sum</code> and get that <em>weired felling that it
""added"" 3 numbers but the sum is adding only the first 2</em> (as you intended
in the first place).</p>

<p>You can check that 3 hanging in <strong>stdin</strong> with a simple addition to your code:</p>

<pre><code>#include &lt;stdio.h&gt; 

int main()
{

    int m, i, sum, num;
    char c;

    i = 0;
    sum = 0;
    scanf(""%d "", &amp;m);

    while (i &lt; m) {
        scanf(""%d "", &amp;num);

        sum = sum + num;

        i = i + 1;
        printf(""Value of sum= %d\n"", sum);
    }

    while((c = getchar()) != '\n') 
        printf(""Still in buffer: %c"", c);

    return 0;
}
</code></pre>

<p>That will output (with the above input, of couse):</p>

<pre><code>$ ./sum1
2
1
2
Value of sum= 1
3
Value of sum= 3
Still in buffer: 3
</code></pre>
",4
32397631,32395670,1,"<p>This is because you have a space after your <code>%d</code> in the <code>scanf</code> lines. </p>

<p><strong>Change</strong> </p>

<pre><code>scanf(""%d "",&amp;num);
</code></pre>

<p><strong>To</strong></p>

<pre><code>scanf(""%d"",&amp;num);   
</code></pre>

<p><code>Scanf</code> usually ignores whitespaces, so you don't want spaces in your format strings.</p>
",0
32397699,32395670,0,"<p>It's causes of <code>extra space in scanf()</code>. Change <code>scanf(""%d "",&amp;num) to scanf(""%d"",&amp;num)</code></p>

<p>From <a href=""http://beej.us/guide/bgc/output/html/multipage/scanf.html"" rel=""nofollow"">Scanf(), fscanf()</a>, You can follow this.</p>

<blockquote>
  <p>The scanf() family of functions reads data from the console or from a
  FILE stream, parses it, and stores the results away in variables you
  provide in the argument list.</p>
  
  <p>The format string is very similar to that in printf() in that you can
  tell it to read a ""%d"", for instance for an int. But it also has
  additional capabilities, most notably that it can eat up other
  characters in the input that you specify in the format string.</p>
</blockquote>

<p>You should write:</p>

<pre><code>int main()
{
    int m,i,sum,num;

    i=0;
    sum=0;
    scanf(""%d"",&amp;m);
    while(i&lt;m){
        scanf(""%d"",&amp;num);

        sum=sum + num;

        i=i+1;
        printf(""Value of sum= %d\n"",sum);
        //continue;
    }
    printf(""Sum= %d "",sum);
}
</code></pre>
",0
32397749,32395670,0,"<p>A refactored code will look like this</p>

<pre><code>#include &lt;stdio.h&gt;

int main() {
    int m, num, sum = 0;
    scanf(""%d"", &amp;m);    // Let scanf automatically skip whitespace
    while (m--) {
        scanf(""%d"", &amp;num);
        sum += num;
    }
    printf(""Sum= %d\n"", sum);
    return 0;
}
</code></pre>
",0
26246578,26246538,2,"<p>This declaration doesn't make sense:</p>

<pre><code>void Welcome(char *PointeurNameHuman[50])
</code></pre>

<p>Do you perhaps mean the following?</p>

<pre><code>void Welcome(char *PointeurNameHuman)
</code></pre>

<p>Also, this line is wrong:</p>

<pre><code>void *PointeurWelcome = &amp;Welcome(PointeurNameHuman);
</code></pre>

<p>You probably mean this as well:</p>

<pre><code>void (*PointeurWelcome)() = &amp;Welcome;
</code></pre>

<p>Likewise this line is strange:</p>

<pre><code>char NameHuman[50] = ""HUMAN"";
</code></pre>

<p>Typically, you don't declare the array size when you initialize it with constant data. Instead, you could write this:</p>

<pre><code>char NameHuman[] = ""HUMAN"";
</code></pre>

<p>The advantage to this is that you won't include all of the extra trailing zero bytes in your constant.</p>

<p>Also, the place inside <code>Menu</code> when you invoke <code>PointeurWelcome</code>, it is undeclared at that point in the code. That variable doesn't exist in that scope.</p>

<p>Also, inside <code>Menu</code>, typically people use local variables for reading data from <code>scanf</code>. For example, like this:</p>

<pre><code>int Choix;
scanf(""%d"", &amp;Choix);
</code></pre>

<p>Instead of what you have.</p>

<p>I strongly suggest you enable compiler warnings, as you will probably discover several other mistakes that you have made.</p>
",1
26246750,26246538,0,"<p>N.B: Enable warnings on your compiler. <code>-Wall -pedantic</code> are good flags for GCC and clang. Consult your compiler's documentation for specifics.</p>

<p><code>char *PointeurNameHuman[50]</code>, <code>char NameHuman[50]</code>, and <code>char *PointeurNameHuman</code> are different declarations. See this example in the standard:</p>

<p>¡ì 6.7.6.2</p>

<blockquote>
  <p>7 EXAMPLE 1</p>

<pre><code>float fa[11], *afp[17];
</code></pre>
  
  <p>declares an array of float numbers and an array of pointers to float
  numbers.</p>
</blockquote>

<p>Refer to <a href=""http://cdecl.org/"" rel=""nofollow"">cdecl</a> if you ever have trouble with declarations.</p>

<p><code>char *PointeurNameHuman = &amp;NameHuman;</code> does not do what you think.</p>

<pre><code>main.cpp:4:31: warning: initialization from incompatible pointer type
     char *PointeurNameHuman = &amp;NameHuman;
</code></pre>

<p>You probably meant to do <code>char *PointeurNameHuman = NameHuman;</code> instead, although this is unnecessary because <a href=""https://stackoverflow.com/questions/1461432/what-is-array-decaying"">arrays decay to pointers</a>.</p>

<pre><code>void Welcome(char* PointeurNameHuman)
{
    printf(""\n\nWelcome %s \nPlease enter your name: "", PointeurNameHuman);
}

int main(int argc, char *argv[])
{
    char NameHuman[] = ""HUMAN"";
    Welcome(NameHuman);
    return 0;
}
</code></pre>

<p>Secondly, to address your original error, you have the incorrect syntax for a function pointer. <code>void *</code> declares a void pointer, not a function pointer. In your edit, you changed it to <code>void (*PointerWelcome)() = &amp;Welcome(variable)</code> which is still incorrect. You're now trying to take the address of a void expression. Use <code>void (*)()</code> instead:</p>

<pre><code>void (*PointerWelcome)() = &amp;Welcome;
PointerWelcome(variable);
</code></pre>

<hr />

<p>For some reason, you declare a local function prototype in your main function. You already have a definition for <code>Welcome</code>, remove:</p>

<pre><code>void Welcome(PointeurNameHuman);
</code></pre>

<p>If <code>PointeurNameHuman</code> had a type, it would conflict with your previous declaration of <code>Welcome</code>.</p>

<p>You declare your <code>Menu</code> function void, yet you return 0 in three different places. Either change <code>Menu</code>'s signature to <code>int Menu(...)</code> or change your return expressions to <code>return;</code>.</p>

<p>And finally, you're still not declaring a function pointer correctly.</p>

<pre><code>void Menu( /* ... */ void (*PointeurWelcome)())
</code></pre>
",1
24354493,24354331,0,"<p>Try this <a href=""http://ideone.com/SJFQ0X"" rel=""nofollow"">code</a> :</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void){
int array[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
int counter=0, c, position;
while ((c = getchar()) != EOF){
    if(c == ' ' || c == '\n' || c == '\t'){
        array[counter]++;
        counter = 0;
    } else {
        if(counter&lt;9) {
            counter ++;
        }
    }
}
if(counter!=0) {
    array[counter]++;
}
for (position = 0; position &lt; 10; ++position){
    printf(""%d "", array[position]);
}
    return 0;
}
</code></pre>

<p>The problem with your code was that whenever a character was appearing, you were incrementing an array position. What is needed is to wait till the word is finished and as soon as we encounter "" "", we increment the word length position in the array.</p>
",0
24354357,24354331,0,"<p>You have to initialize counter like this:</p>

<pre><code>counter = 0;
</code></pre>

<p>before using it.</p>
",0
29956001,29955685,2,"<p>Your <code>_setCapacityDynArr</code> function is written in a rather nonsensical fashion. All functions in this ""API"" receive a pointer <code>v</code> (or, sometimes, <code>b</code>) to an existing <code>struct DynArr</code> object, which they work with. They can manipulate the fields of <code>*v</code> object. They can allocate/deallocate/reallocate the actual array <code>v-&gt;data</code>. But they never allocate/deallocate the <code>*v</code> object itself. Object <code>*v</code> is passed from the outside and managed by the outside code.</p>

<p>But your <code>_setCapacityDynArr</code> function attempts to do something completely and drastically different. It begins with </p>

<pre><code>temp = v;
v = malloc(sizeof(struct DynArr));
...
free(temp);
</code></pre>

<p>That is already incorrect. This is completely unacceptable. You are not allowed to allocate/deallocate <code>*v</code> object itself.</p>

<p>In any case, changing the value of <code>v</code> inside the function make no sense simply because <code>v</code> is passed to <code>_setCapacityDynArr</code> by value. The outside code will not see these changes anyway. </p>

<p>This latter detail is what makes your code to output allegedly ""changing"" value of <code>v-&gt;size</code> - you are simply outputing two completely different <code>v-&gt;size</code> values and one of them actually belongs to deallocated memory. In line 77 you are printing <code>v-&gt;size</code> value stored in ""dead"" memory already deallocated by <code>free(temp)</code> call inside <code>_setCapacityDynArr</code>.</p>

<p>Don't try to acclocate/deallocate <code>*v</code> object inside your <code>_setCapacityDynArr</code>. Where did you get that idea? Just reallocate <code>v-&gt;data</code> and change  the other firelds accordingly. But don't attempt to change the value of <code>v</code> itself.</p>
",0
23611793,23611553,0,"<p>You should use a debugger or a <code>printf</code> in the loop body to see what the value of qx is becoming and fix your logic.  Since you never told us what you're trying to compute, this is about the only possible answer.</p>

<p>One thing it could be is floating point precision. If <code>qx</code> is a <code>float</code>, it has at most 9 digits of precision.  So if it's initial random value is more than 10^11 or so, the <code>2*xmax</code> term disappears into round-off error, and <code>qx</code> will oscillate between +10^11 and -10^11 forever.</p>
",2
24084908,24084863,3,"<p>Escape the inner quotes</p>

<pre><code>system(""echo \""$(cat test.txt)\"""");
</code></pre>
",0
26227517,26227476,4,"<p>In ASCII, the digit <em>characters</em> <code>'0'</code> through <code>'9'</code> occupy code points 48 through 57 (i hex, <code>0x30</code> through <code>0x39</code>) so, to turn a digit character into a value, you just subtract 48.</p>

<hr>

<blockquote>
  <p>As an aside, you should <em>really</em> subtract <code>'0'</code> since the standard doesn't guarantee ASCII, though it <em>does</em> guarantee that the digit characters are contiguous and ordered. C under z/OS, for example, uses EBCDIC which places the digits at code points <code>0xf0</code> through <code>0xf9</code>.</p>
</blockquote>

<hr>

<p>The loop itself is a simple shift-and-add type, to create a number from multiple digit characters. Say you have the string <code>""123""</code>, and <code>number</code> is initially zero.</p>

<p>You multiply <code>number</code> (zero) by ten to get zero then add digit character <code>'1'</code> (49) and subtract 48. This gives you one.</p>

<p>You then multiply <code>number</code> (one) by ten to get ten and add digit character <code>'2'</code> (50), again subtracting 48. This gives you twelve.</p>

<p>Finally, you multiply <code>number</code> (twelve) by ten to get a hundred and twenty then add digit character <code>'3'</code> (51) and subtract 48. This gives you a hundred and twenty three.</p>

<p>There are better ways to do this in the C standard library, <code>atoi</code> or the more robust <code>strtol</code>-type functions, all found in <code>stdlib.h</code>. The latter allow you to better detect if there was ""rubbish"" at the end of the number, for assistance with validation (<code>atoi</code> cannot tell the difference between <code>123</code> and <code>123xyzzy</code>).</p>

<hr>

<p>And, as yet <em>another</em> aside, you should avoid <code>gets()</code> like the plague. It, like the ""naked"" <code>scanf(""%s"")</code>, is not suitable for user input, and opens your code to buffer overflow problems. In fact, unlike <code>scanf()</code>, there is <em>no</em> safe way to use <code>gets()</code>, which is undoubtedly why it has been removed from C11, the latest standard. A more robust user input function can be found <a href=""https://stackoverflow.com/questions/4023895/how-to-read-string-entered-by-user-in-c/4023921#4023921"">here</a>.</p>

<p>There's also a large class of addresses for which that code will fail miserably, such as:</p>

<pre><code>3/28 Tivoli Rd
57a Smith Street
Flat 2, 12 Xyzzy Lane
</code></pre>
",0
26227523,26227476,4,"<p>C requires the digits <code>0</code> through <code>9</code> to be stored contiguously, in that order, in the execution character set. <code>48</code> is the ASCII value of <code>'0'</code>, so, for instance:</p>

<pre><code>'3' - 48 == 3
</code></pre>

<p>for any digit. </p>

<p>ASCII is not required for C, so better is:</p>

<pre><code>'3' - '0' 
</code></pre>

<p>because while <code>48</code> is right for ASCII, <code>'0'</code> is by definition right for any character set.</p>

<p>If <code>address</code> contains <code>""456 ""</code>, then:</p>

<ul>
<li>when <code>i == 0</code> and <code>number == 0</code>, <code>number * 10 + (address[0] - 48)</code> equals <code>0 * 10 + 4</code>, or <code>4</code>.</li>
<li>when <code>i == 1</code>, <code>number * 10 + (address[1] - 48)</code> is <code>4 * 10 + 5</code>, or <code>45</code>.</li>
<li>when <code>i == 2</code>, <code>number * 10 + (address[2] - 48)</code> is <code>45 * 10 + 6</code>, or <code>456</code></li>
</ul>

<p>and you're done. </p>

<p>Never use <code>gets()</code>, it's dangerous, and isn't even part of C anymore. </p>
",0
24381634,24381117,2,"<p>This function is checking that the frequencies of characters are the same in the first half and second half of the string.</p>

<p>Take <code>h1[s[i]]++;</code></p>

<p><code>s[i]</code> is character <code>i</code> of string <code>s</code>. <code>h1[]</code> is the number of characters seen in the first half. <code>h1[s[i]]</code> is the number for the given character. The <code>++</code> increments the count for that character.</p>

<p><code>h2[s[i+mid]]++;</code> Is the same for the second half of the string. The <code>+mid</code> means we are looking at the second half of the string.</p>

<p>Then it checks the frequencies match for all characters.</p>
",0
24381289,24381117,1,"<p><code>h1[s[i]]++</code> uses the contents of s[i] to index into the h1 array, and then increments the value in that location of the h1 array.</p>

<p>Similarly, <code>h2[s[i+mid]]++</code> Uses the contents of s[i+mid] to index into the h2 array, and then increments the value in that location of the h2 array.</p>
",2
24390043,24389511,1,"<p>It looks like you have a C file meant for ROOT. You can't compile it on its own with GCC. I'm unfamiliar with ROOT, but try this.</p>

<pre><code>root plot_na22.C
</code></pre>
",1
24389617,24389511,1,"<p>You can't start a C source file with <code>{</code> and compile it directly. It's just a syntax error. So fundamentally, you need to find out how/where this was meant to be used and use it in that way. <a href=""https://stackoverflow.com/users/694576/alk"">alk</a>'s suggestion seemed like a useful approach:</p>

<pre>grep ""include.*plot_na22.C"" * -ir</pre>

<p>Perhaps the original author was using this in an <code>#include</code> in a different file (which isn't a good idea, but does happen), but that's speculation. It certainly is highly suspicious that it happily starts using symbols (like <code>gStyle</code>) it hasn't defined or <code>extern</code>d.</p>
",3
22883425,22883357,1,"<p>Are you trying to convert a double to a string, or a string to a double? It looks like the latter, and I don¡¯t think you should be using the <code>%</code> operator in that case at all. Starting at <code>0.1</code>, multiply each digit¡¯s value by what¡¯s appropriate for its place.</p>

<p>It¡¯s easier to explain in C, though:</p>

<pre><code>char c;
double result = 0.0;

/* The part before the decimal place */
while ((c = *s++) &amp;&amp; c != '.') {
    result = result * 10.0 + (c - '0');
}

/* The part after the decimal place */
if (c == '.') {
    double m = 0.1;
    s++;

    while ((c = *s++)) {
        result += m * (c - '0');
        m *= 0.1;
    }
}
</code></pre>
",1
22883532,22883357,0,"<p>The modulo operator is not defined for floating points. If you are trying to use <code>num%1</code> to extract the decimal part of <code>num</code>, you should instead try something like this:</p>

<pre><code>double num_dec = num - floor(num);
</code></pre>
",0
27540915,27540864,1,"<p>After multiplication you are storing all values to the same location,i.e, <code>*ptr</code>. Change   </p>

<pre><code>*aPtr = *(aPtr+i) * mul;  
</code></pre>

<p>to  </p>

<pre><code>*(aPtr+i) = *(aPtr+i) * mul;
</code></pre>
",0
27540935,27540864,1,"<p>Modify </p>

<pre><code>*aPtr = *(aPtr+i) * mul;  
</code></pre>

<p>to  </p>

<pre><code>*(aPtr+i) = *(aPtr+i) * mul;
</code></pre>

<p>Also note in C there is no pass-by-reference. Arguments are copied by value. You might <em>simulate</em> it but its not an <em>emulation</em>.</p>
",0
27540953,27540864,0,"<p>You have to increment the array position. Make your code like this. While calling you have to pass the array address.    <code>multiply(array, m);</code></p>

<pre><code>for(i=0; i&lt;SIZE; i++,aPtr++)
*aPtr = *aPtr * mul; 
</code></pre>

<p>Or else.</p>

<pre><code>for(i=0; i&lt;SIZE; i++)
*(aPtr+i) = *(aPtr+i) * mul;   
</code></pre>

<p>Because *aPtr is pointing to the first position of the array. After the first multiplication  we have to move to second position. So the incrementation needs. Sorry for the first answer.</p>
",1
27540993,27540864,0,"<p>You have to multiply the values in the each position and store it in the same position again.<br>
In your code the last value which was multiplied will only be stored, because <code>*aPtr</code> will be pointing to the first position.<br>
Try this code...</p>

<pre><code>#include &lt;stdio.h&gt;
#define SIZE 5

void multiply(int *aPtr, int);

int main(){
    int array[SIZE];
    int i=0;
    int m;

    printf(""Enter 5 integers: "");
    for(i=0; i&lt;SIZE; i++){
            scanf(""%d"", &amp;array[i]);
    }

    printf(""Please enter the multiplier: "");
    scanf(""%d"", &amp;m);

    multiply(&amp;array[0], m);

    for(i=0; i&lt;SIZE; i++){
            printf(""%d  "", array[i]);
    }

    return 0;
}

void multiply(int *aPtr, int mul){
   int i = 0;
    for(i=0; i&lt;SIZE; i++)
            *(aPtr + i) = *(aPtr+i) * mul;

}         
</code></pre>
",0
27517134,27516773,5,"<p>I don't know where you found this code, but it certainly doesn't do what you think it does.</p>

<p>What you think it does is check some kind of multiplication.  Probably because it prints ""n = y * z"" at the end.  But what it actually does is it takes the digits of <code>n</code>, and remove the digits of <code>y</code> and <code>z</code>.  If all digits were removed, it prints that message.  So for example:</p>

<pre><code>1111 = 11 * 11    true
1234 = 12 * 34    true
1500 = 10 * 50    true
1500 = 30 * 50    false
1458 = 18 * 81    false
1458 = 14 * 58    true
1458 = 45 * 18    true
</code></pre>
",2
27516844,27516773,1,"<p>At the top of your code you can see that</p>

<pre><code>#define NEG ~0x0LL
</code></pre>

<p>Therefore <code>NEG</code> is the bit-wise inverse of <code>0x0LL</code>, which stands for (long long)0. Therefore, <code>NEG</code> is a long long with all bits set to one.</p>

<p>To understand your problem:</p>

<p>First, fix undefined behavior, allocate your <code>buf</code> (you need <code>stdlib.h</code>)</p>

<pre><code>int8_t * buf;
buf = malloc(sizeof(* buf) * 8);
</code></pre>

<p>Then attach a debugger to <code>buf</code> with the expression <code>(uint64_t *)buf</code> and its view property as vector of uint8 (or equivalent from your debugger). This way you can actually see what's done with your variable and why it fails on those specific values.</p>

<p><img src=""https://i.stack.imgur.com/OdlEH.png"" alt=""Sample debugger image""></p>

<p>Something to keep in mind: setting <code>buf[i]</code> is equivalent to setting the corresponding bits to <code>0xff</code> due to the data type.</p>

<p>Your code simply doesn't do what you <em>think</em> it does.</p>
",1
27517249,27516773,0,"<p>As said Nit, you are defining NEG as 64bits set to 1.
then what you do:</p>

<pre><code>*((uint64_t*) buf) = NEG
</code></pre>

<p>so you are storing 64bits set to one in a 64bits of data pointed to by buf.</p>

<p>then, when you do the checking:</p>

<pre><code>if( *((uint64_t*) buf) == NEG )
</code></pre>

<p>you compare 64bits pointed to by buf to 64 bits set to one.</p>

<p>what you seem to want to do is comparing only 8bits:</p>

<pre><code>if( *((uint8_t*) buf) == (uint8_t)NEG )
</code></pre>

<p>I'm just reacting to:</p>

<pre><code>, if the if only compares the first position
</code></pre>

<p>because the the if compares 64bits of data as asked by casting :)</p>
",0
24106170,24106139,12,"<p>When you scan a number, you need to pass the address of the variable where you want to store the result:</p>

<pre><code>fscanf(fp,""%d"",&amp;i);
</code></pre>

<p>where you have</p>

<pre><code>fscanf(fp,""%d"",i);
               ^  missing the &amp; sign!
</code></pre>

<p>Your compiler really ought to have warned you - do you enable warnings when you compile?</p>

<p>What is happening here is that the <code>fscanf</code> function writes to the location given (in your case, it writes to whatever location is <em>pointed to</em> by the <em>value</em> of <code>i</code>, instead of writing to the <em>location of <code>i</code></em>) . This can corrupt your memory in all kinds of nasty ways - resulting, in your case, in the program ""running"" for considerable time before crashing.</p>

<p>As @Brandin pointed out, there is a further problem with your code (although it's less likely to be the source of your problem). When you attempt to open a file, you should ALWAYS check that you succeeded.  You do this with something like this:</p>

<pre><code>#include &lt;assert.h&gt;
// at the top of the program


// attempt to open the file:
fp = fopen(""keimeno.txt"",""r"");
// and check whether you succeeded:
assert(fp != NULL); // this says ""check fp is not NULL. Otherwise, quit.""
</code></pre>

<p>Alternatively, you can make things a bit prettier with:</p>

<pre><code>const char *fileName = ""keimeno.txt"";
const char *mode = ""r"";
if((fp=fopen(fileName, mode))==NULL) {
  printf(""cannot open file %s\n"", fileName);
  return -1;
}
</code></pre>

<p>It is almost always a good idea to put ""hard wired values"" near the start of your program, rather than embedding them in a function call.</p>
",6
23583488,23583473,2,"<p>By calling <code>fopen(""name"",""r"")</code>, you are attempting to open a file called ""name"" for reading.</p>

<hr>

<p>Assuming that you have <code>FILE* ptr</code> declared somewhere up there...</p>

<p><strong>Change this:</strong></p>

<pre><code>ptr = fopen(""name"",""r"");
</code></pre>

<p><strong>To this:</strong></p>

<pre><code>ptr = fopen(name,""r"");
</code></pre>
",2
23583506,23583473,0,"<p>Just simply pass name instead:</p>

<pre><code>if ((ptr = fopen(name, ""r"")) == NULL)
{
    fprintf(stderr, ""We have a problem!\n"");
    return -1;
}
</code></pre>

<p>Also, do some error checking to ensure it is really open.</p>
",0
23583520,23583473,0,"<p>For file I/O, you need a <code>FILE</code> object, hence the code would be:</p>

<pre><code>FILE* ptr;
ptr = fopen( name, ""r"" );
</code></pre>

<p>and also check the return value, that will be <code>NULL</code> in case of failure.</p>

<p>Check out <a href=""http://en.cppreference.com/w/c/io/fopen"" rel=""nofollow"">this link</a> for more details.</p>
",0
23583523,23583473,0,"<pre><code>char name[20];  //Missed the semi colon
printf(""Ender the name of text file you want to open ex: word.txt"");
scanf(""%s"", name);
ptr = fopen(name, ""r""); // Remove the string literal. 
</code></pre>

<p>Using ""name"" means you are looking for a file named ""name"" in your directory to open.
If you use name instead (no quotes) then you are looking for the string literal that is stored in the variable named name.</p>
",3
25709514,25623810,1,"<p>It depends where you have the kernel from and what your target device will be. Usually you need the right toolchain for your kernel and an approprietary linux environment anyway. Compared to this it's not much to just type the command to compile it in the terminal. If you need further information, xda is always a good source of information, but you have to know more on which phone you are using.
If you have everything together, it is very easy to just quickly set up a custom script which would allow you to compile, pack and flash your kernel in one command. Just add the commands in correct order.</p>
",0
26437946,26437880,2,"<pre><code>scanf(""%s"",name);
</code></pre>

<p>Will scan user input until it encounters a space,i.e, when you type <code>hi bye</code> , only <code>hi</code> will be stored in <code>name</code>.On the other hand,</p>

<pre><code>scanf (""%[^\n]%*c"", name);
</code></pre>

<p>Will scan until it encounters a <code>\n</code> or an enter key. The <code>%*c</code> tells <code>scanf</code> to scan a character and discard it. In your case,<code>%*c</code> discards the <code>\n</code> character which is present in the <code>stdin</code> as you pressed it after entering the string.</p>
",2
25658971,25658951,1,"<p>You could pass a pointer and de-reference it in the function:</p>

<pre><code>int num5(int* pnum)
{
    *pnum = 5;   // you may want to check that pnum is not NULL
    return 0;    // presumably you don't always return 0 in real code
}
</code></pre>

<p>Then</p>

<pre><code>int number = 42;
printf(""%d"", number); // prints 42
int ret = num5(&amp;number);
printf(""%d"", number); // prints 5
</code></pre>
",8
25659003,25658951,2,"<p>You are using Pass by value method. What ever the changes takes places in the function it won't affect in the main program. Those changes are limited with in the function.</p>

<p>You need use the following method to do this!</p>

<pre><code>int num5(int *number)
{
    *number = 5;
    return 0;
}

int main()
{
    int number;
    number = num5(&amp;number); // pass the address of the number instead value
    printf(""%d"", number);
}
</code></pre>

<p>When you Pass the address of the variable to the function, whatever the changes you are doing in the function, that is retained by that variable. So you will get the latest assigned value!</p>
",0
25662625,25658951,0,"<p>As others mentioned, call by reference [a.k.a. call by address] will do the job for you. To be on safer side, don't forget to add a <code>NULL</code> pointer check to your incoming pointer. Also, as per usual convention, <code>main()</code> should return 0 in case of successful completion of execution.</p>
<h3>Modified Code:</h3>
<pre><code>int num5(int *number)
{
   if (number)                       //NULL check for incoming pointer
   {
       *number = 5;
   }
    return 0;
}

int main()
{
    int number;
    number = num5(&amp;number); // pass the address of the number instead value
    printf(&quot;%d&quot;, number);

    return 0;               //for convention
}
</code></pre>
",0
26798132,26797845,2,"<p>I assume that you are calculating the sum of the digits that make up a number.</p>

<p>The problem is that you fail to initialize <code>a</code>. If it happens to get the initial value of <code>0</code>, the code in the while loop will never execute.</p>

<p>Also, the condition is wrong, you shoud test on <code>n</code> instead. Consider what will happen if you enter <code>101</code>. Your current code will stop then it reaches the <code>0</code> and will output a sum of <code>1</code> instead of <code>2</code>.</p>

<p>So, if we fix the issues:</p>

<pre><code>int main() {
    int n,s=0;
    int a;
    printf(""Input a integer number: "");
    scanf(""%d"",&amp;n);

    while (n!=0) {
        a=n%10;
        s=s+a;
        n=n/10;
    }
    printf(""Sum: %d"",s);
    getch();
    return 0;
}
</code></pre>
",1
24575967,24575921,0,"<p>Because items are copied. Method swaps two copied came with arguments and drops them.</p>
",0
24078490,24078023,0,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
{
    char *comm1 = ""netstat -aon | findstr "";
    char comm2[50];
    char comms[6];
    scanf(""%s"", &amp;comms);
    strcpy(comm2, comm1);
    strcat(comm2, comms);
    return 0;
}
</code></pre>

<p>this is less efficient than @Blue Moon's answer, but the point is, there are many ways to do that.</p>
",0
24078069,24078023,3,"<p>Read the number and use <code>snprintf()</code>:</p>

<pre><code>   int port;

   if (scanf(""%d"", &amp;port) != 1) { /* input error */};

   snprintf( command, sizeof command, ""netstat -aon | findstr %d"", port );
</code></pre>

<p>Also, use a standard signature for main()  such as: <code>int main(int argc, char *argv[])</code>. </p>
",0
25683497,25683380,2,"<p>You can just use <a href=""http://linux.die.net/man/3/memmove"" rel=""nofollow"">memmove</a>, e.g. like this:</p>

<pre><code>#include &lt;string.h&gt;

const char * src = (char *)0x210a;  // source address
char * dst = (char *)0x2100;        // destination address
const size_t len = 5;               // no of bytes 

memmove(dst, src, len);
</code></pre>
",0
24655723,24641953,-1,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void bubble_sort(int *array, int size);

int main(void){
    FILE *file;
    char line[128];

    if((file = fopen(""inputfile.csv"", ""r"")) == NULL){
        printf(""Unable to open the file"");
        return -1;
    }
    while(fgets(line, sizeof(line), file)){
        int i, a[4], size = sizeof(a)/sizeof(*a);
        sscanf(line, ""%d,%d,%d,%d"", &amp;a[0], &amp;a[1], &amp;a[2], &amp;a[3]);
        bubble_sort(a, size);
        for(i = 0; i &lt; size; ++i){
            printf(""%d"", a[i]);
            if(i&lt;size-1)
                printf("", "");
        }
        printf(""\n"");
    }
    fclose(file);
    return 0;
}

void bubble_sort(int *a, int size){
    int i, temp, swap;

    do{
        for(swap=i=0;i&lt;size-1;++i){
            if(a[i]&gt;a[i+1]){
                swap = 1;
                temp = a[i];
                a[i] = a[i+1];
                a[i+1] = temp;
            }
        }
        --size;
    }while(swap);
}
</code></pre>
",0
28479111,22945731,1,"<p>Try initializing <code>typeofletter</code> array to 0. <code>int typeofletter[26] = {0}</code> ¨C  GoldRoger</p>

<p>Secondly, where do you think fscanf carries on reading from in your second loop?
If you fscanf through a file until you hit an EOF, what do you think happens next time you call EOF? You need to reset where you are reading in the file you wanna start from the start again. ¨C  Asthor</p>
",0
25706102,25706073,2,"<p>At the end of the cycle your <code>p2</code> points to the end of the <code>destination</code> string. <code>destination</code> at that moment does indeed contain a copy of <code>source</code>. But your <code>p2</code> does not point to the beginning of <code>destination</code>. It points to the end of the copied string stored in <code>destination</code>. I.e. <code>p2</code> points to an empty string. That's what your second <code>puts</code> prints - an empty string.</p>

<p>If you want to print the <code>destination</code> string, that exactly what you should write in your code - <code>puts(destination)</code>. Why did you decide to express it as <code>puts(p2)</code>?</p>

<p>If you want to experiment with it, you can make your <code>p2</code> to point to different positions in <code>destination</code> after the cycle. If you make it point to the beginning of <code>destination</code>, <code>puts (p2)</code> will print the whole <code>destination</code> string. If you make it point to the middle of the <code>destination</code> string, then <code>puts (p2)</code> will print something like <code>""ate message""</code> and so on.</p>
",0
25706281,25706073,0,"<p>One other caution. Rather than packing <code>post-increment</code> and <code>assignment</code> into the <code>while test clause</code> followed by an <code>empty line</code>, you can make your code much more readable by actually using the line below the <code>while</code> for <code>post-increment</code> and <code>assignment</code>. You must also take care to <code>null-terminate</code> all strings. When you are learning pointers, it is often useful to just take out pencil and paper, draw your string representation, and follow the loop logic by hand to confirm the loop is accomplishing all you need:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    char *source = ""duplicate message"";
    char *p1,*p2,destination[50];

    p1 = source;
    puts(p1);

    p2=destination;  

    while (*p1)         /* to walk down string, *p evaluates true until '\0' */
        *p2++ = *p1++;  /* dereference pointer, assign, post-increment       */

    p2++;               /* increment pointer to next memory location         */
    *p2 = 0;            /* null-terminate the string                         */

    p2 = destination;   /* reset pointer to beginning of destination         */

    puts (p2);

    return 0;
}
</code></pre>

<p><strong>output:</strong></p>

<pre><code>$./bin/dest
duplicate message
duplicate message
</code></pre>
",0
25706163,25706073,0,"<p>This code might be helpful for you:</p>

<pre><code>char *my_strcpy(char dest[], const char source[])
{
  int i = 0;
  while (source[i] != '\0')
  {
    dest[i] = source[i];
    i++;
  }
  dest[i] = '\0';
  return(dest);
}
</code></pre>

<p>Notice the <code>const</code> for the source, which signifies that the function must not change the source string in anyway.</p>
",0
25712503,25711802,2,"<ol>
<li>Always use proper indentation while coding, this makes the code easy to read.</li>
<li>You are not allocating memory for your <code>char</code> pointers <code>a, b, c</code>.</li>
<li>Instead of <code>scanf()</code> use <code>fgets()</code> to accept the input strings.</li>
</ol>

<p>Try this fixed code( I have included comments where necessary ).</p>

<pre><code>/* student.h is to include the structure for stundent info */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
//#include ""student.h""
typedef struct {
    char sID[9];
    char firstN[30];
    char lastN[30];
    }student[100];
int main()
{
    FILE *sIf;
    student *sI;//Why are you using it?
    char *ptr_pos;
    //Fix 1 Allocate space for a, b and c
    char *c=malloc(sizeof(char)*256);
    if(c==NULL)
    {
        puts(""Failed to allocate memory for variable c"");
        exit(1);
    }
    char *b=malloc(sizeof(char)*256);
    if(b==NULL)
    {
        puts(""Failed to allocate memory for variable b"");
        exit(1);
    }
    char *a=malloc(sizeof(char)*256);
    if(a==NULL)
    {
        puts(""Failed to allocate memory for variable a"");
        exit(1);
    }

    sIf = fopen(""student.txt"", ""a+"");
    if(!sIf)
    {
        printf(""File could not be opened\n\a\a"");
        return EXIT_FAILURE;
    }
    printf(""Student First Name: \n"");
    //Accept string using fgets, it prevents from overflow
    fgets(b,256,stdin);
    b[strlen(b)-1]='\0'; //Remove \n from the input string
    // Or you can use the following to remove `\n` from input string
    //if((ptr_pos=strchr(b, '\n')) != NULL)
    //  *ptr_pos = `\0`;


    printf(""Student Last Name: \n"");
    fgets(a,256,stdin);
    a[strlen(a)-1]='\0';

    printf(""Student ID Number: \n"");
    fgets(c,256,stdin);
    c[strlen(c)-1]='\0';

    fprintf(sIf, ""%s, %s\t%s\n"", a, b, c);       

    fclose(sIf);
    //Free allocated memory
    free(a);
    free(b);
    free(c);

    return EXIT_SUCCESS;
}
</code></pre>
",3
23588134,23587410,0,"<p>There is a problem with:</p>

<pre><code>current-&gt;command=buf;
</code></pre>

<p><code>buf</code> is the buffer allocated by <code>getline</code>, however that function will re-use its buffer each time (and maybe even <code>free</code> it if it needed to reallocate), so it is not a good idea to have your commands point to that buffer. You should <code>malloc</code> new space for each command.</p>

<p>It looks like you tried that with:</p>

<pre><code>current-&gt;command=malloc(sizeof(buf));
</code></pre>

<p>however (as well as mallocing the wrong number of bytes) you never actually use that malloc'd space, you just pointed <code>current-&gt;command</code> at <code>buf</code> immediately after. </p>

<p>Try replacing both lines with:</p>

<pre><code>current-&gt;command = strdup(buf);
</code></pre>
",0
21591017,21590731,0,"<p>I suggest to use <code>double</code> into the array treated by <code>qsort</code> and <code>bsearch</code>.</p>

<p>But if you insist to use <code>char *</code>:</p>

<pre><code>int compare( const void * l, const void * r ) {
   char * lerr  = NULL;
   char * rerr  = NULL;
   double left  = strtod((const char *)l, &amp;lerr );
   double right = strtod((const char *)l, &amp;rerr );
   return (*lerr||*rerr) ? (int)(l-r) : (int)(left-right);
}
</code></pre>

<p><a href=""http://linux.die.net/man/3/strtod"" rel=""nofollow"">Documentation of strtod</a></p>
",0
21321891,21321740,1,"<p>There is possibly a clue on this page <a href=""http://www.ousob.com/ng/borcpp/nga0e24.php"" rel=""nofollow"">http://www.ousob.com/ng/borcpp/nga0e24.php</a> - Guide to Borland C++ 2.x ( with Turbo C )</p>

<blockquote>
  <p>There is no such thing as a negative numeric constant. If
                  a minus sign precedes a numeric constant it is treated as
                  the unary minus operator, which, along with the constant,
                  constitutes a numeric expression.  This is important with
                  -32768, which, while it can be represented as an int,
                  actually has type long int, since 32768 has type long. To
                  get the desired result, you could use (int) -32768,
                  0x8000, or 0177777.</p>
</blockquote>

<p>This implies the use of <a href=""http://en.wikipedia.org/wiki/Two%27s_complement"" rel=""nofollow"">two's complement</a> for negative numbers. Interestingly, the two's complement of 0x8000 is 0x8000 itself (as the value +32768 does not fit in the range for signed 2 byte ints).</p>

<p>So what does this mean for your function? Bit wise, this has the effect of toggling the sign bit, here are some examples:</p>

<pre><code>f(0) = f(0x0000) = 0x8000 = -32768
f(1) = f(0x0001) = 0x8001 = -32767
f(0x8000) = 0
f(0x7fff) = 0xffff
</code></pre>

<p>It seems like this could be represented as <code>val ^= 0x8000</code>, but perhaps the XOR operator was not implemented in Borland back then?</p>
",4
21322086,21321740,3,"<p>In Borland C 3.x, <code>int</code> and <code>short</code> were the same: 16 bits. <code>long</code> was 32-bits.</p>

<p>A hex literal has the first type in which the value can be represented: <code>int</code>, <code>unsigned int</code>, <code>long int</code> or <code>unsigned long int</code>.</p>

<p>In the case of Borland C, <code>0x8000</code> is a decimal value of 32768 and won't fit in an <code>int</code>, but will in an <code>unsigned int</code>. So <code>unsigned int</code> it is.</p>

<p>The statement <code>v -= 0x8000 ;</code> is identical to <code>v = v - 0x8000 ;</code></p>

<p>On the right-hand side, the <code>int</code> value <code>v</code> is implicitly cast to <code>unsigned int</code>, per the rules, the arithmetic operation is performed, yielding an <code>rval</code> that is an <code>unsigned int</code>. That <code>unsigned int</code> is then, again per the rules, implicitly cast back to the type of the <code>lval</code>.</p>

<p>So, by my estimation, the net effect is to toggle the sign bit &mdash; something that could be more easily and clearly done via simple bit-twiddling: <code>*value ^= 0x8000 ;</code>.</p>
",5
24097066,24097023,1,"<ul>
<li><code>MAP_1</code> is 1, hex is arbitrary.</li>
<li><code>MAP_2</code> is 1 &lt;&lt; 1 (bit shift), so the value assigned will be 2 (10 in binary).</li>
<li><code>MAP_3</code> is 1 | 2 (bit or), so the value is going to be 3 (11 in binary).</li>
<li><code>MAP_4</code> is 1 &lt;&lt; 2, so the value will be 4 (100 in binary).</li>
</ul>
",0
24097082,24097023,5,"<blockquote>
  <p>Is the MAP_1 going to be assigned a fixed value of '1' (why hex?)?</p>
</blockquote>

<p>Yes, it is assigned a value of <code>1</code>. Hex is often used to underscore the fact that a certain number if used for its bit pattern, rather than for its numeric value. In this case it is not essential.</p>

<blockquote>
  <p>is MAP_2 going to be the value of MAP_1 + 1?</p>
</blockquote>

<p>No, it is going to have the value of MAP_1 * 2. The <code>&lt;&lt;</code> is a shift left operator. It multiplies by two in binary (to see why, think of shifting a decimal number left by one position).</p>

<blockquote>
  <p>what is MAP_3 going to be?</p>
</blockquote>

<p>It is going to be <code>3</code> - the result of bitwise OR-ing of <code>2</code> and <code>1</code>.</p>

<pre><code>binary 0010 = decimal 2
        OR
binary 0001 = decimal 1
-----------   ---------
binary 0011 = decimal 3
</code></pre>
",0
24349249,24349157,0,"<p>Your variable <code>ptr</code> is a number allocated on the stack that contains an address. The stack is ""freed"" when your function returns. There is nothing else to free.</p>

<p>You should do the same number of <code>free</code> that the number of <code>malloc</code>. If you do no <code>malloc</code>, you should not free anything. If you try to free <code>ptr</code>, it will free the element pointed by <code>ptr</code> which is not something you want.</p>
",0
24349195,24349157,1,"<p>Yes, you don't have to <code>free()</code> anything as you haven't allocated any memory for <code>ptr</code> in <code>Check_the_list()</code>. </p>

<p>The easy way to remember is whenever you do a <code>malloc()</code>/<code>calloc()</code>/<code>realloc()</code>, then you do a <code>free()</code>. </p>

<p>Aside: Your loop condition using <code>brk</code> is not necessary as you return immediately after finding data. So <code>brk == 0</code> needless and you could eliminate <code>brk</code> completely:</p>

<pre><code> while(ptr != NULL)
     {
        if(ptr-&gt;list.a == data)
        {
         return 0;
        }
        else
        {
         ptr = ptr-&gt;next;
        }
     }
</code></pre>
",0
24084685,24084479,1,"<p>Well, there's probably a hundred ways to achieve this in C, but one (easy one) might be to use one of the variants of sscanf.</p>

<p><a href=""http://www.tutorialspoint.com/c_standard_library/c_function_sscanf.htm"" rel=""nofollow"">http://www.tutorialspoint.com/c_standard_library/c_function_sscanf.htm</a></p>

<p>Example/pseudocode</p>

<pre><code>char * line_from_file = read_next_line();
sscanf(line_from_file, ""%s;%d;%s"", rezervations[k].user_login, &amp;rezervations[k].room_number, rezervations[k].date);
</code></pre>

<p>Edit:</p>

<p>Maybe %s only stops reading on whitespace, and as yours is semicolon seperated, you may need something like</p>

<pre><code>sscanf(line_from_file, ""%[^;];%d;%[^;]"", ...)
</code></pre>
",1
24566049,24566036,0,"<p>You're slightly confused as to what <code>pragma pack</code> does. It doesn't care about a particular instantiation, but about the padding in between elements.</p>

<p>Let's look at a simpler object:</p>

<pre><code>struct obj {
    uint64_t x;
    uint32_t y;
};
</code></pre>

<p>Normally, this object will take <strong>16 bytes</strong>. If you use <code>pragma pack(1)</code>, it will only use <strong>12 bytes</strong>.</p>
",0
24566107,24566036,0,"<p>In C it is not possible to define a structure containing an array whose size depends on the contents of the initializer.  You could use a C99 flexible array member, but then you would have to allocate the structure using <code>malloc</code>.</p>

<p>In C++ you could perhaps do something clever with templates and inheritance, but then the <code>name</code> member would not be part of the base type, which would be inconvenient.</p>

<p>In neither case does <code>#pragma pack</code> help.  That common extension only removes padding <em>in between</em> structure fields.</p>
",0
26195564,26194918,0,"<p>I think you mean you are doing this:</p>

<pre><code>#include &lt;stdio.h&gt;
int main ()
{
    unsigned char c = 160;
    printf (""The character is %c\n"",c);
    return 0;
}
</code></pre>

<p>How top bit set characters work depends on your terminal emulation. If you have a UTF-8 terminal, for instance, it will be expecting unicode sequences.</p>
",0
31119181,31118604,1,"<p>This loop</p>

<pre><code>for (nc = 0; getchar(); ++nc) {
        ;
</code></pre>

<p>will iterate until getchar() returns 0. To achieve this without rewritting the program as others are suggesting you should for example in Windows press key combination <code>Ctrl + @</code> and then press Enter. The value of key combination <code>Ctrl + @</code> is equal to 0.</p>
",1
31119214,31118604,0,"<p>If you revise your code to make it:</p>

<pre><code>#include &lt;stdio.h&gt;

int main() {
    double nc;

    while (getchar() != EOF) {
        ++nc;
    }

    printf(""\n%.0f\n"", nc);
}
</code></pre>

<p>Then if you run it in a terminal window and enter the following:</p>

<p>abcCtrl-D</p>

<p>you will get the output:</p>

<p>abc<br>
3</p>

<p>(The Ctrl-D is the EOF character)</p>
",3
31118734,31118604,4,"<p>The <code>getchar()</code> returns the obtained character on success or <code>EOF</code> on failure. Reference <a href=""http://en.cppreference.com/w/c/io/getchar"" rel=""nofollow noreferrer"">here</a>.</p>

<p>Try this</p>

<pre><code>for (nc = 0; getchar() != EOF; ++nc) { }
</code></pre>

<p>Note that, <kbd>Enter</kbd> doesn't means <code>EOF</code>, it means newline or <code>'\n'</code>.</p>

<p>Look at the header <code>stdio.h</code>, says,</p>

<pre><code>#define EOF (-1)
</code></pre>

<p><a href=""https://stackoverflow.com/questions/1118957/c-how-to-simulate-an-eof"">Here</a> you can see how to simulate an EOF.</p>

<pre><code>Windows: Ctrl+Z
Unix :   Ctrl+D
</code></pre>

<p>So long story short, you can put any condition in the <code>for</code> loop, like </p>

<pre><code>for (nc = 0; getchar() != '\n'; ++nc) { } // break the loop if enter pressed
for (nc = 0; getchar() != 'c'; ++nc) { } // break the loop if c pressed
.
.
.
</code></pre>
",3
31118737,31118604,1,"<p><code>getchar()</code> waits on the input from stdin and even if you enter any character it would be read by <code>getchar()</code> but that doesn't make you get out of the loop.</p>

<p>So you need to add some condition on the return value of <code>getchar()</code> to gracefully exit the loop. </p>

<p>For Eg:</p>

<pre><code>for(;getchar() != EOF;)
{
}
</code></pre>

<p>If you want to return on newline character then check should be <code>getchar() != '\n'</code></p>

<p>PS: I have just shown how to check the return value , for me the exit condition is <code>EOF</code> it might vary for you.</p>
",4
23846517,23846409,0,"<p>There are so many errors in your code that I'm just going to show you a proper way to do it.</p>

<pre><code>// Include needed header files.
#include &lt;stdio.h&gt;  // fopen, fprintf, fgets, printf, fclose
#include &lt;stdlib.h&gt; // exit, EXIT_FAILURE
#include &lt;string.h&gt; // strchr

int main(){
    // Allocate more than enough space to hold a line.
    char line[256];

    FILE *file = fopen(""book.txt"",""r"");

    // Ensure that file has opened.
    if (file == NULL) {
        fprintf(stderr, ""Can't open file.\n"");
        exit(EXIT_FAILURE);  // Return an integer indicating failure.
    }

    // Use fgets to avoid buffer overflow.
    // Test for end-of-file directly with the input function.    
    while (fgets(line, sizeof(line), file)) {
        // Remove newline if present
        char *p = strchr(line, '\n');
        if (p != NULL) *p = '\0';

        printf(""%s\n"", line);
    }

    // Explicitly close file.
    fclose(file);    

    return 0;   // Return an integer (0 or EXIT_SUCCESS indicates success)
}
</code></pre>
",0
29464588,29464491,1,"<p>You appear to be using the variable <code>counter</code> for three conflicting purposes:</p>

<ul>
<li>It appears in the terminal condition as the right hand side of a subtraction expression. I believe this, corresponding with the <code>word[i]</code> expression below it, is what's causing your crash.</li>
<li>In the loop immediately before your crash location, you appear to be using it as a punctuation counter.</li>
<li>Everywhere else, you appear to be using it to count the number of correct matches in your dictionary file.</li>
</ul>

<p>Because these purposes conflict with each other, <code>counter</code> becomes useless for any purpose. You need to think carefully about what you intend to do with <code>counter</code>, and make sure you're doing that and only that with it. Why do you need <code>counter</code>?</p>

<p><code>strlen</code> returns a <code>size_t</code> type, which is unsigned (can't possibly be negative). Supposing <code>counter</code> is greater than the return value of <code>strlen</code>, you may end up with a huge number rather than a negative number. Thus, your loop may continue well beyond the bounds of your <code>word</code> array and into undefined behaviour, which coincidentally causes your crash.</p>
",1
26797027,26796700,1,"<p>In C, you would do</p>

<pre><code>t_socket = malloc(sizeof(struct socket_info));
</code></pre>

<p>or</p>

<pre><code>t_socket = malloc(sizeof *t_socket);
</code></pre>
",0
27516768,27516744,3,"<p>It overwrites the last character of the the scanned string with a null character, shortening the string by one character. Why the programmer wanted to do such a thing I can't say.</p>
",8
27516770,27516744,1,"<p>Delete one character from the end of the ""string"" <code>search_for</code>.</p>
",0
26816301,26816030,0,"<p>The below code will help you to get rid of the function movenext</p>

<pre><code>int main()
{
   char *p; 
   char a[20];
   printf(""ENter name:\n"");
   fgets(a,20,stdin);

   p = strtok(a,"" "");
   while( p  != NULL)
   {   
      printf(""%s "",p);
      p = strtok(NULL,"" "");
   }   
}
</code></pre>
",4
27132527,27132488,1,"<p>There is a newline character <code>\n</code>  at the end of first input and that is picked by the <code>scanf()</code> during the second loop.</p>

<p>Chnage your scanf as :</p>

<pre><code>scanf("" %c"", &amp;zime);
</code></pre>
",0
24575790,24575588,4,"<p>It looks like this is a 16-bit DOS program?  So your <code>int</code> is only 16 bits/2 bytes, and your program is overflowing it.</p>

<p>You could try detecting when this condition will happen, and/or use <code>unsigned</code> to avoid negative numbers or a <code>long</code> instead of <code>int</code> to store bigger values (though this program will still output incorrect answers if you overflow).</p>

<p>What's the overall aim?  - Can you just doing it by reversing a string instead?</p>
",3
24575831,24575588,3,"<p>As Bathsheba mentioned, <code>sizeof(int)</code> is apparently 2, and given the headers you're using, the platform is MS-DOS, which means your <code>int</code> only has 16 bits of information available. Because the first bit is the sign bit, that leaves you with 15 bits and 2^15 is 32768, meaning your range is -32767..+32767. What you want is an <code>unsigned int</code> and <code>%u</code> for <code>scanf</code> and <code>printf</code>. That will allow you to use 0..65535.</p>

<p>Need to be able to handle all 5-digit numbers? Switch to <code>long</code> instead (it won't matter if you make it signed or unsigned other than using <code>%ld</code> or <code>%lu</code> for signed or unsigned respectively), and you will have -2147483648..+2147483647 (signed) or 0..4294967295 (unsigned), which will give you more than enough range for a 5-digit number.</p>

<p>If you have problems with using long and the format is correct for scanf and printf, the problem is in your logic and not your reading of numbers at least.</p>
",0
24575860,24575588,2,"<p>If the limit is 32767, then reversing 22333 would yield 33322, which is larger than the limit!!!</p>

<p>If you want to use <code>long</code> instead of <code>int</code>, then you should also use <code>""%ld""</code> instead of <code>""%d""</code>.</p>
",0
24079701,24079606,2,"<p>Your modStr is pointing to the beginning of the string and your code supposes it points to the end. Instead of:</p>

<pre><code>strcpy(modStr, str);
i=strlen(modStr);
--modStr;
</code></pre>

<p>try something like:</p>

<pre><code>strcpy(modStr, str);
modStrBegin = modStr;
i=strlen(modStrBegin);
modStr = modStrBegin + i - 1;
</code></pre>

<p>you will need to add definition <code>char *modStrBegin;</code> at the beginning of your code.</p>
",3
24079815,24079606,0,"<p>Your version is a bit too clumsy and unnecessarily complicated.</p>

<p>The simplest version of a strip string functionality I could come up with is the following:</p>

<pre><code>struct Str
{
    char const *beg, *end;
};

Str strip_string(char const* beg) {
    Str r;
    // Skip the leading whitespace.
    while(*beg &amp;&amp; isspace(*beg))
        ++beg;

    // Find the last non-whitespace character in the string.
    r.beg = r.end = beg;
    while(*beg)
        if(!isspace(*beg++))
            r.end = beg;

    return r;
}
</code></pre>

<p>Note that the above function just finds the begging and ending of the non-whitespace sequences in the string. You may like to duplicate the resulting <code>Str</code> if necessary,</p>
",0
24090076,24089996,1,"<p><code>sizeof(simboliai)</code> returns size of the pointer (usually 4) not the actual length of allocated array. You need to keep track of that separately. For example, in another variable.</p>
",3
24116660,24116638,5,"<p>This:</p>

<pre><code>if(fs=fopen(file_src,""r"")==NULL)
</code></pre>

<p>is wrong. It is probably ending up assigning <code>fs</code> to <code>NULL</code>, when the open  <em>succeeds</em>, which is then <em>not</em> checked and thus causes the fault when the <code>NULL</code> is used in later calls.</p>

<p>It must be</p>

<pre><code>if((fs = fopen(file_src, ""r"")) == NULL)
</code></pre>

<p>due to how operator priority works in C.</p>

<p>By the way, a generic copying program like this should open the files in binary mode.</p>
",5
24577492,24577478,3,"<p>Why do you think there is a difference between an <code>int</code> element in an array, and a plain <code>int</code>? There isn't: it's the same type.</p>

<p>Each of the 40 integers in your array <code>A</code> will have the same range as any other variable of type <code>int</code>.</p>

<p>You should add <code>#include &lt;limits.h&gt;</code> and use the <code>INT_MIN</code> and <code>INT_MAX</code> macros.</p>

<p>For a 32-bit <code>int</code>, the range is much larger than -32000 to 32000, it's from -2147483648 to 2147483647.</p>
",0
24577500,24577478,2,"<p>From Wikipedia:</p>

<blockquote>
  <p>The signed range of integer values that can be stored in 32 bits is
  -2147483648 through 2147483647 (unsigned: 0 through 4,294,967,295).</p>
</blockquote>
",0
24579240,24577478,0,"<p>Given:</p>

<pre><code>int A[40];
</code></pre>

<p><em>Each</em> of the 40 elements of the array have have a range of <em>at least</em> -32,767 to 3,2767.  That is the <em>minimum</em> range on <code>int</code> per the C spec.</p>

<p>Since <code>int</code> on your machine is 32-bit, the range is expected to be -2,147,483,648 to -2,147,483,647.  </p>

<p>32-bit <code>int</code> is common.  To determine the range for a given platforms</p>

<pre><code>#include &lt;limits.h&gt;
printf(""Min %d\n"", INT_MIN);
printf(""Max %d\n"", INT_MAX);
</code></pre>
",0
29208153,29208084,4,"<p>This is the basics of pointer arithmetic. When you have:</p>

<pre><code>int a[4] = {0};
int *p = a;
</code></pre>

<p>when you do <code>p++</code> - compiler automatically increases <code>p</code>
with four bytes (in case size of integer is four).
Same happens with subtraction if you subtract 1
from <code>p</code> compiler will automatically subtract four bytes.
But to more precisely answer your question it seems
<code>-</code> operator when applied to pointer types
divides result on size of element type to which
pointer points to.</p>
",0
26199561,26199552,0,"<p>Use <code>strlen</code> to get the size of the <code>array</code>. You need to include <code>string.h</code>.</p>

<p><code>sizeof()</code> is not a function it is an operator. When <code>sizeof</code> is applied to the name of a static array (not allocated through <code>malloc</code>), the result is the size in bytes of the whole array.</p>

<p>If you are using <code>fgets</code>, then you need to remove <code>\n</code> from the string. A simple way would be:</p>

<pre><code>array[strlen(array) - 1] = '\0';
</code></pre>

<p>A quick example:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stddef.h&gt;

int main()
{
    int i=0;
    char array[50]={0};
    char *p;
    fgets(array, 50, stdin);
    //Remove `\n` from the array.
    if ((p=strchr(array, '\n')) != NULL)
        *p = '\0';
    size_t len = strlen(array);  // Use strlen to find the length of string
    for(i=0; i&lt;len; i++)
    {
        printf(""%c\n"", array[i]);
    }
    return 0;
}
</code></pre>
",11
26199579,26199552,2,"<p>Q: Is it possible to get the number of elements currently stored in an array in C?</p>

<ol>
<li><p>Short answer: No.  You need to track this information yourself.</p></li>
<li><p>You happen to be using <a href=""http://linux.die.net/man/3/fgets"" rel=""nofollow"">fgets()</a> with a character array.  Since in this case you're getting a C ""string"", you can use the C function <a href=""http://linux.die.net/man/3/strlen"" rel=""nofollow"">strlen()</a>.</p></li>
<li><p>It's worth noting that fgets() will also return a newline - so your string might be a one (Mac, Linux) or two (DOS/Windows) characters longer than you expect.</p></li>
</ol>

<p>PS:</p>

<p>Here is a bit more about C strings, including the concept of ""null termination"" (if you're not already familiar with them):</p>

<p><a href=""http://www.cprogramming.com/tutorial/c/lesson9.html"" rel=""nofollow"">http://www.cprogramming.com/tutorial/c/lesson9.html</a></p>
",3
25704962,25704930,1,"<p>You have to use the proper format specifier. Change format specifier <code>%d</code> to <code>%f</code></p>

<pre><code>  scanf(""%f"", &amp;euro);
  printf(""%f"", euro);
</code></pre>
",0
25704974,25704930,3,"<p>Use <code>%f</code> specifier for float values, <code>%d</code> is used for integer.</p>

<pre><code>#include&lt;stdio.h&gt;

float euro;
int main(void){

  printf(""Ange euro: "");
  scanf(""%f"", &amp;euro);
  printf(""%.2f\n"", euro);

  return 0;
}
</code></pre>
",0
25705054,25704930,1,"<p>Since you declared euro as a float variable, you need to have the appropriate format specifier. For floats, it's <code>%f</code>. </p>

<p>Here's a nice list of format specifiers for <code>printf</code> and <code>scanf</code> statements: 
<a href=""http://www.cplusplus.com/reference/cstdio/printf/"" rel=""nofollow"">http://www.cplusplus.com/reference/cstdio/printf/</a></p>
",0
24764079,24763849,2,"<p>Here you go:</p>

<p><strong>Sample Code Listing</strong></p>

<hr>

<pre><code>#include &lt;stdio.h&gt;

#define NUM_SQUARES  (5)

int main(void) {
   int i,j;

   printf(""###########\n"");
   printf(""#         #\n"");
   printf(""# ####### #\n"");
   printf(""# #     # #\n"");
   printf(""# # ### # #\n"");
   printf(""# # # # # #\n"");
   printf(""# # ### # #\n"");
   printf(""# #     # #\n"");
   printf(""# ####### #\n"");
   printf(""#         #\n"");
   printf(""###########\n"");

   return 0;
}
</code></pre>

<p><strong>Sample Output</strong></p>

<hr>

<pre><code>###########
#         #
# ####### #
# #     # #
# # ### # #
# # # # # #
# # ### # #
# #     # #
# ####### #
#         #
###########
</code></pre>
",3
23611218,23609931,0,"<p>Yes, you can use <code>scanf()</code> more than once. Your problem is not actually because of <code>scanf();</code>, Its with your input, To give input for first <code>scanf()</code> in your program, what we naturally do is we type(through keyboard) a character and hit ENTER KEY,Under the hood when you hit ENTER KEY a <code>'\n'</code> character is produced which is read by your second <code>scanf()</code> ,that's why your second <code>scanf()</code> is not waiting for input from you as you expected, You need to clear this <code>'\n'</code> manually when you use <code>%c</code>.(when <code>%d %f %s</code> are used <code>'\n'</code> are automatically removed that's why we don't face this problem when using them).</p>

<pre><code>To solve problem you can use ""%c"" like this "" %c"" (note space before %c, this skips '\n' characters) 

scanf("" %c"",&amp;str1);
printf(""%c"",str1);
//code to add them to array's  
scanf("" %c"",&amp;str1);//Have Re-Used the same variable str1. 
printf(""%c"",str1);
</code></pre>
",0
26136846,26136450,2,"<p>You can get the error from a C89/C90 compiler with code like this:</p>

<pre><code>void function(void)
{
    int i = 23;         /* OK - initialization */
    printf(""%d\n"", i);  /* OK - executable statement (code) */
    enum denomination   /* BAD - declaration mixed with code */
    {
        FIVE_CENTS, TEN_CENTS, TWENTY_CENTS, FIFTY_CENTS, ONE_DOLLAR, 
        TWO_DOLLARS, FIVE_DOLLARS, TEN_DOLLARS
    };
    ¡­
</code></pre>

<p>You could have a plain function call, an assignment, a stray extra semicolon, or something before the line where the errors start.</p>

<p>Note that C99 and C11 follow the lead of C++ and allow variable definitions at (almost) any point in a function (statement block).  The outline code above is fine in C99 and C11.</p>
",2
28162741,28160622,2,"<p>Your code doesn't work because it operates on strings instead of numbers.  When you print <code>&amp;temp[0]</code> it's the same as printing <code>temp</code> directly; when you ""increment"" it, you're incrementing the pointer to the beginning of the string, so it removes one character from the front.</p>

<p>To actually increment it as a number, you need to convert it to one, and display it as one:</p>

<pre><code>void getAddr(unsigned long addr)
{
  printf(""%lx"", addr);
}

int main(int argc, char *argv[]) {
  getAddr(strtoul(argv[1], NULL, 16));
  return 0;
}
</code></pre>

<p>Now you can increment it properly, etc.</p>
",4
26227903,26227868,0,"<p>Assuming the cents you're after is only 2 decimals in length and token is <code>double</code>, subtract the dollars from the token and multiply by 100.</p>

<pre><code>dollars=int(token);
token-=dollars;
cents=int(token*100.);
</code></pre>

<p>EDIT: As from the comment, with <code>token</code> being a <code>char *</code>:</p>

<pre><code>int dollars, cents;
sscanf(token,""%d.%d"",&amp;dollars,&amp;cents);
</code></pre>

<p>EDIT 2: As from the comment, without <code>itoa()</code> and <code>sscanf()</code>:</p>

<p>Implement the following function as described <a href=""https://stackoverflow.com/a/5832882/2710064"">here</a>. Then use it:</p>

<pre><code>double amount=parseFloat(token);
dollars=int(amount);
cents=int((amount-dollars)*100.);
</code></pre>
",6
26227920,26227868,1,"<p>you can use <code>sscanf</code> </p>

<pre><code>sscanf(stringWhereDollarCentValueIsStored , ""%d.%d"" , &amp;dollars , &amp;cents);
</code></pre>
",3
26228004,26227868,0,"<p>You'll want to modify these to handle invalid input gracefully but these functions will work with valid input:</p>

<pre><code>int get_dollars(char *str)
{
    int i = 0;
    int accum = 0;

    // While the current character is neither the null-terminator nor a '.' character
    while(str[i]&amp;&amp;str[i]!='.')
    {
        // Shift any previously accumulated values up one place-value by multiplying it by 10
        accum *= 10;
        // Add the numeric value of the character representation of the digit in str[i] to accum
        // (('0'-'9')-0x30=integer value 0-9)
        accum+=str[i]-0x30;
        // Increment the loop counter
        i++;
    }
    // Return the result
    return accum;
}

int get_cents(char *str)
{
    int i = 0; 
    int accum = 0;
    int start_pos = 0;
    // Get the location of the '.' character so we know where the cent portion begins at
    while(str[i]&amp;&amp;str[i]!='.') {i++; start_pos++; }
    i = start_pos+1;
    // Same algorithm as get_dollars, except starting after the '.' rather than before
    while(str[i])
    {
        accum *= 10;
        accum += str[i]-0x30;
        i++;
    }
    return accum;
}
</code></pre>
",1
26228157,26227868,2,"<p>Should you want to roll your own <code>string</code> to <code>int</code> parser ...</p>

<pre><code>int parse_int(char **s) {
  char sign = **s;
  if (sign == '-' || sign == '+') {
    (*s)++;
  }
  int result = 0;
  unsigned char ch;
  while (isdigit(ch = **s)) {
    (*s)++;
     // By accumulating the int on the negative side, we can parse INT_MIN
    result = result * 10 + '0' - ch;
  }

  if (sign != '-') result = -result;
  return result;
}


void parse_dollars_cents(char **s, int *dollar, int *cent) {
  *dollar = parse_int(s);
  if (**s == '.') {
    (*s)++;
    *cent = parse_int(s);
  } else {
    *cent = 0;
  }
}


int main(void) {
  char buf[100];
  fgets(buf, sizeof buf, stdin);
  int dollar, cent;
  char *s = buf;
  parse_dollars_cents(&amp;s, &amp;dollar, &amp;cent);
  printf(""$%d.%02d\n"", dollar, cent);
  return 0;
}
</code></pre>
",2
26413354,26413312,1,"<p>In this code:</p>

<pre><code>if (array2[d] =1)

        ++onecount;

    else if (array2[d]=2)

        ++twocount;
</code></pre>

<p>You need to use '==' instead of '=', which is the assignment operator in C.</p>

<p>e.g., </p>

<pre><code>if( array2[d] == 1 ) 
</code></pre>
",1
23568794,23568390,0,"<p>As 'Drax' indicated, the code needs to properly terminate the 'new' string. perhaps by inserting a line after the for loop:</p>

<pre><code>  for (i=0 ; i&lt;strlen(read) ; i++)
  {
     for(k=0 ; k&lt;strlen(Encryption) ; k++){
             if (read[i]==' ')  new[i]=' ';
             else if (read[i] ==  Encryption[k]){
                         new[i]=Decryption[k];}
                         }
             }
  }

  new[i] = '\0';
</code></pre>
",0
30141162,30141131,0,"<p>Try removing the star from the declaration of <code>num</code>.</p>

<pre><code>char *num; // &lt;&lt;&lt; This is a pointer to char declaration
char num; // &lt;&lt;&lt; This is a char

int num; // &lt;&lt;&lt; But this is probably what you meant/wanted!
</code></pre>
",2
30141165,30141131,0,"<blockquote>
  <p>Assignment makes pointer from integer ...</p>
</blockquote>

<pre><code> char *num;
 ...
 num = rand()%20;
</code></pre>

<p>The code tries to assign the integer result of <a href=""http://man7.org/linux/man-pages/man3/rand.3.html"" rel=""nofollow""><code>rand()</code></a> to the character pointer <code>num</code>.</p>

<p>From the code you show so far, changing <code>num</code> to be an integer, like</p>

<pre><code> int num;
</code></pre>

<p>would solve this.</p>
",4
30141169,30141131,0,"<p><code>rand()</code> returns an <code>int</code>, and applying the <code>%</code> operator on it also returns an <code>int</code> - you should save this result in an <code>int</code>, not a <code>char*</code>:</p>

<pre><code>int num;
char *buffer;
</code></pre>
",0
26116787,26112644,0,"<p>Fixed program:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;string.h&gt;// for strcmp

int main() 
{

char drinks[5];// you need a string not a float
float shot = 1.5;
int beer = 12;
int wine = 5;
float floz;
float alcohol;
float weight;
float hours;
float bac;




printf(""\nEnter beer if you drank beer, wine if you drank wine, and shot if you drank shots: "");
scanf(""%s"", drinks);// scanning string

printf(""\nEnter how many fluid ounces of alcohol your drank: "");
scanf("" %f"", &amp;floz);

printf(""\nEnter your weight in pounds: "");
scanf("" %f"", &amp;weight);

printf(""\nEnter how long you've been drinking in hours: "");
scanf("" %f"", &amp;hours);


//compare the input and word using strcmp
if(strcmp(drinks,""shot"")==0)        alcohol = shot * floz * .4;


else if(strcmp(drinks,""beer"")==0)
    alcohol = beer * floz * .05;


else if(strcmp(drinks,""wine"")==0)
    alcohol = wine * floz * .12;



bac = ((alcohol * 5.14) / (weight * .73)) - (.015 * hours);

printf(""Your BAC is %f.\n"", bac);

// no need to loop
if (bac &lt;= .03) 
    printf(""You are ok to drive.\n"");
// your condition dosen't do what you think
else if (bac &gt;= .04 &amp;&amp; bac &lt;= .08) 
printf(""You may drive but it would be unsafe.\n"");
// use else as it is sure that bac &gt; .08
else
    printf(""You are guaranteed a DUI if pulled over.\n"");

return 0;
    }
</code></pre>
",0
24624746,24624600,1,"<p>Here's some hints based on your existing code.</p>

<pre><code> int count = 0;
 token = strtok(buffer, "" "");
 while (token != NULL)
 {
       if (count == 0)
       {
           strncpy(student.name, token, 20);
           student.name[19] = '\0'; // ensure null termination
       }
       else if (count == 1)
       {
           /* validate ""is"" */
           if (strcmp(token, ""is"") != 0)
               break;
       }
       else if (count == 2) { /*validate ""enrolled""*/  }

       else if (count == 3) { /* validate ""in""*/  }

       else if (count == 4)
       {
           // set the department field
       }
       else if (count == 5)
       {
           // set the number field
       }
       count++;


       token = strtok(NULL, "" "");
 }
</code></pre>

<p>Of course, this example doesn't handle some robustness issues (e.g. name could be >= than 20 chars, or the string might only have 3 words in it, etc...). But should get you started...</p>
",3
24625488,24624600,0,"<p>You can parse and store strings to structure as follows</p>

<pre><code>/*Add Structres Here*/
token = strtok(line, "" "");
int j = 1;
strncpy(student.name,token,strlen(token));
while(token!=NULL)
{
    token = strtok(NULL, "" "");
    switch(j)
    {
        case 5: strncpy(student.department,token,strlen(token));
                break;

        case 6: student.number = atoi(token);
                break;
    }
    j++;
}
j=0;

/*Your outer loop code continues*/
</code></pre>

<p>Also in your structure declaration you have given <code>int number[4]</code>(which stores 4 integers), which is wrong in your case, change it to <code>int number</code>. And also in <code>char* line[50]</code> is not correct in this context change it to <code>char line[50]</code>.</p>
",0
26445786,26445726,3,"<p>C is pass-by-value, not pass-by-reference.</p>

<p>That means a function always gets a copy of its arguments, and changing its copy has no effect on the expression used on calling.</p>

<p>Use additional indirection, here the modified lines (each has exactly one <code>*</code> or <code>&amp;</code> more):</p>

<pre><code>int load_file(char* filename, FILE** file_to_load);
int load_file(char* filename, FILE** file_to_load)
    if( (*file_to_load = fopen(filename, ""r"")) != NULL )
if ( (load_file(""../bin/test"", &amp;test_file_1)) == 1)
</code></pre>

<p>BTW: It would be better to return the file as the return-value, unless you need the return-value for something else or there are other reasons not shown in the example.</p>
",8
26445971,26445726,0,"<p>Here is a simple program which pretty much does what you want. </p>

<pre><code>int load_file(char *filename, FILE *file_to_load){
 file_to_load = fopen(filename, ""r"");
 if(file_to_load !=0)
  return 1;
 else
  return 0;
 }
int main(int argc, char *argv[]){
 FILE file_to_load;
 if(load_file(argv[1],&amp;file_to_load) == 1)
  printf(""File exists\n"");
 else
  printf(""Error loading the given file\n"");
 }
</code></pre>

<p>I have taken the file as a command line argument and changed the error messages but you can alter it according to your requirements.</p>
",0
24577924,24552060,0,"<pre><code>int arr[6] = {45, 50, 25, 61, 34};//Size after insertion is necessary. 5 &lt; array size
int size = 5;//Actual data size of the original
insertAtGP(arr, &amp;size, 30, 3);//2nd argument requires a pointer to int,
for(i = 0; i &lt; size; i++)//use the updated value. = Does not include
</code></pre>
",1
28151000,28150990,3,"<p>You are performing integer division</p>

<pre><code>per=(m1+m2+m3+m4+m5)/500*100;
</code></pre>

<p>change it to</p>

<pre><code>per = ((float)(m1 + m2 + m3 + m4 + m5)) / 500 * 100;
</code></pre>

<p>and since the maximum value of each <code>mn</code> is <code>100</code> so the maximum value of their sum is <code>500</code>, if it's less than <code>500</code> integer division yields always <code>0</code>.</p>
",1
28151756,28150990,1,"<p>Iharob is right - the problem is in making integer division  (i.e. int_operator / int_operator), and only after that multiplication works.<br>
Modifications of Iharob¡¯s solution can be also:</p>

<pre><code>per = (m1 + m2 + m3 + m4 + m5) / 500.0 * 100; // now 500.0 is of double type
</code></pre>

<p>But assigning float (or double) values to integer variables is not always good idea because int has smaller range. So it is better to optimize your expression, e.g.:</p>

<pre><code>per=(m1+m2+m3+m4+m5)/5;
</code></pre>

<p>Also you can change type of <code>per</code> to float (or double), or decide what you want from the result (rounding / separation integer part from remainder / just integer part)</p>
",0
26198043,26197949,1,"<p>To display the number vertically:</p>

<pre><code>1. get least significant digit,
2. print it and print new line,
3. shift number to the right by one digit
4. goto 1
</code></pre>

<p>Algorithm terminates when the number is zero. Call the input number <code>n</code>; getting the least significant (rightmost) digit can be done with <code>n % 10</code>. Right shift can be done with <code>n = n / 10</code>.</p>

<p>For the second part, observe that the largest divisor cannot be more than <code>n/2</code> (because <code>n = 2 * n/2</code>). So try all number from <code>n/2</code> down to <code>1</code> and break once you find a divisor. You will find the largest divisor because you are considering numbers in decreasing order. To check that <code>x</code> divides <code>y</code> use <code>y % x == 0</code>.</p>

<p>A second way it to check numbers from <code>sqrt(n)</code> down to <code>1</code>. If <code>m</code> divides <code>n</code>, we can write <code>n = m * k</code> for some <code>k</code>. Now you take <code>max(m, n/m)</code> and continue.</p>

<p>Hope this helps :)</p>
",0
26198062,26197949,-1,"<p>For the first part, there are many ways to approach this. But, without using too many of the standard library functions which seems to be a level appropriate for the question, I think the easiest way would be to take the numbers as a character array. Then access each value through it's index in the character array. This requires only the stdio.h header file. Some quick notes: simply use printf to print the value contained at each index, and throw the newline \n character at the end. If you wanted convert the string to an integer, you can do that very easily using the function atoi() which can be found in stdlib.h.  If you want to print out backward, you can simply traverse the array backward. </p>

<pre><code>void displayvert(char str[])
{ 
  int i;

  for (i = 0; str[i] != '\0'; ++i) {
    printf(""%c\n"", str[i]);
  }

}
</code></pre>

<p>Also many ways to approach the second, but in this case for the second question I think I'd use the modulus operator and track the highest value where the result is zero. In order for this to work with the single user provided input, I actually needed atoi() which is in the stdlib.h header. Basically, starting from the value one you'll increase the value up the integer just below the value of 'num' itself. And, if the remainder is zero when you when you divide by it (the purpose of using the modulus operator) then you know it's divisible. Because we're ascending from 1 to the number itself, the last value to return a remainder of zero is the greatest common divisor.</p>

<pre><code>void getgcd(int num)
{
  int i, gcd;

  // remember, you can't do x % 0!                                                               
  for (i = 1; i &lt; num; i++) {
    if ((num % i) == 0 ) {
      gcd = i;
    }
  }

  printf(""The greatest common divisor is: %d\n"", gcd);
}
</code></pre>

<p>Main function and prototypes here so you can see how it all tied together. A couple of quick notes (1) 11 digits was arbitrary; but it's important to note that we used 10 digits for the total input value (you can add checks to this to enforce) and reserved the 11th (at index 10) to allow space for the null terminating character \0.  (2) Use scanf to grab input; note that because character arrays do not require the address operator &amp; because it defaults to that. </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void displayvert(char str[]);
void getgcd(int num);

int main()
{ 
  char input[11]; // additional character added for \0                                           

  printf(""Please enter a value up to 10 digits: "");
  scanf(""%s"", input);
  displayvert(input);
  getgcd(atoi(input));

  return 0;
}
</code></pre>
",0
26245633,26245580,1,"<p>This loop is wrong:</p>

<pre><code>for(int i = corner1; i &lt; corner2; i++) {
    newimg[i] = array[i]; }
</code></pre>

<p>The indices for the source and destination need to be different, since their dimensions are different. You can do soemthing like this:</p>

<pre><code>for (int r = top; r &lt; bottom; r++)             // for each source row
{
    for (int c = left; c &lt; right; c++)         // for each source col
    {
        int src_index = r * cols + c;          // calc source index in array[]
        int dst_index = (r - top) * (right - left) + (c - left);
                                               // calc dest index in newimg[]
        newimg[dst_index] = array[src_index];  // copy src -&gt; dest
    }
}
</code></pre>
",0
26245635,26245580,1,"<p>This</p>

<pre><code>for(int i = corner1; i &lt; corner2; i++) {
    newimg[i] = array[i]; }
</code></pre>

<p>copies <em>from</em> <code>array[i]</code>, which is what you want, but it also copies <em>to</em> <code>newimg</code> in the same position; as if <code>newimg</code> is exactly as large as <code>array</code>. You need to copy to <code>newimg</code> starting at its 0th index:</p>

<pre><code>for(int i = corner1; i &lt; corner2; i++) {
    newimg[i-corner1] = array[i]; }
</code></pre>

<p>or the more clear operation</p>

<pre><code>for(int i = 0; i&lt; corner2 - corner1; i++) {
    newimg[i] = array[corner1 + i]; }
</code></pre>

<p>It's ""more clear"" because then it's obvious you copy <code>corner2 - corner1</code> elements, starting at <code>corner1</code>.</p>

<p>But it's not the only thing wrong! I will only outline it here, as it will take a serious re-write.</p>

<p>You copy the ""rows * columns"" <em>contiguously</em>, that is, starting at the top left corner and continuing to the bottom right corner:</p>

<pre><code>..........
..********
**********
******....
..........
</code></pre>

<p>but you must copy each column (or row) independently:</p>

<pre><code>..........
..****....
..****....
..****....
..........
</code></pre>
",0
26791511,26791474,3,"<p>You probably intended to call the function instead of simply taking its address:</p>

<pre><code>while(!gameOver())
{
    ...
</code></pre>

<p>Note the parentheses.</p>
",0
28234611,28234529,2,"<pre><code>for(i=0; i&lt;=99; ++i) schools[i] = 0;
</code></pre>

<p>Array of out bound access. UB</p>

<pre><code>scanf(""%d"", number);
</code></pre>

<p><code>number</code> is never initialized so this is UB.
It should be</p>

<pre><code>scanf(""%d"", &amp;number);
</code></pre>

<p>Scan to the address of the variable.</p>

<pre><code> scanf(""%s"", string);
 scanf(""%s"", string);
</code></pre>

<p>This doesn't make sense so put together your code is not good as you think it is.</p>
",0
22486881,22486852,4,"<p><code>system()</code> calls an external program. The naming and availability of external programs is highly system dependent.</p>

<p>Since you're using <code>conio.h</code>, use the <code>clrscr()</code> function. <a href=""http://www.programmingsimplified.com/c/conio.h/clrscr"" rel=""nofollow"">ref</a></p>
",1
33016997,33016863,4,"<p><code>main</code> is a function that returns a value like other functions. It is up to you if it returns nothing <code>void main(void){ }</code> or an <code>int</code> value, <code>0</code> is returned in POSIX systems if no error encountered. More sophisticated but readable is to put <code>exit(EXIT_SUCCESS);</code>. </p>

<pre><code>int main(void){
  ...
}
</code></pre>
",3
33017008,33016863,0,"<p>It should be <code>int main()</code> instead of simply main</p>
",0
33017074,33016863,1,"<p>The proper prototype in most environments is:</p>

<pre><code>int main(int argc, char *argv[])
</code></pre>

<p>This means:</p>

<ul>
<li><code>main()</code> is a function that returns an <code>int</code>.</li>
<li>It has one argument called <code>argc</code> that is the number of command-line arguments.</li>
<li>It has one argument called <code>argv</code> that is an array of those arguments.</li>
</ul>
",0
30195648,24518560,1,"<p>Check your configuration file ""ffconf.h"" where you can find a option named <strong>_FS_LOCK</strong>. According to manual from ""FatFs"":</p>

<blockquote>
  <p>If value is >0:   Enable file lock feature. The value defines how many files/sub-directories can be opened simultaneously under file lock control.</p>
</blockquote>

<p>and</p>

<blockquote>
  <p>FR_TOO_MANY_OPEN_FILES:
      Number of open objects has been reached maximum value and no more object can be opened. (Related option: _FS_LOCK)</p>
</blockquote>

<p>With your information provided I can only guess that your <strong>_FS_LOCK</strong> has value 1.</p>
",0
24374070,24374056,2,"<p>Change:</p>

<pre><code>""Health:%d%\nLevel:%d\n""
</code></pre>

<p>to</p>

<pre><code>""Health:%d\nLevel:%d\n""
</code></pre>
",2
24360142,24359256,1,"<p>The problem is this line:</p>

<pre><code>(matrix + i) = GetMatrixU(row, col);
</code></pre>

<p>This tries to make an assignment.  The expression on the right is evaluated; this is the ""r-value"" (""r"" for ""right"").  Then the result should be assigned to the expression on the left, which is the ""l-value"" (""l"" for ""left"").</p>

<p>Well, <code>(matrix + i)</code> is not a valid l-value.  <code>matrix</code> by itself is a single pointer to a two-dimensional array.  In C, you can't just specify a pointer value and assign to it; you must use the <code>*</code> operator to <em>dereference</em> the array, and assign through that.</p>

<p>Here is a short code sample that shows how to dereference a pointer, and then repeats your error.</p>

<pre><code>main()
{
    int a[10];
    *(a + 1) = 0;  // proper use of * to dereference
    a + 1 = 0; // will not compile; error is ""l-value required""
}
</code></pre>

<p>But in C, there is a shortcut way to add to a pointer and then dereference it.  It is the use of square brackets and an index value:</p>

<pre><code>a[1] = 0;  // index the array
</code></pre>

<p>In C, the expressions <code>*(a + i)</code> and <code>a[i]</code> mean exactly the same thing, by definition.</p>

<p><a href=""http://en.wikipedia.org/wiki/C_syntax#Accessing_elements"" rel=""nofollow"">http://en.wikipedia.org/wiki/C_syntax#Accessing_elements</a></p>

<p>It looks like you are trying to create a random matrix, one row at a time.  And you are allocating memory for each row.  Your basic matrix declaration should be an array of pointers to rows.</p>

<pre><code>int *matrix[rows];

for (i = 0; i &lt; rows; ++i)
{
    // either of these lines will work; pick just one
    *(matrix + i) = AllocateRandomRow(cols);  // explicit add-and-dereference
    matrix[i] = AllocateRandomRow(cols);  // simpler: just index array
}
</code></pre>

<p>I favor the second, simpler syntax for solving this problem.  You are indexing an array; just use the square brackets.</p>

<p>Here is a free online text that describes how to dynamically allocate a matrix.</p>

<p><a href=""http://www.eskimo.com/~scs/cclass/int/sx9b.html"" rel=""nofollow"">http://www.eskimo.com/~scs/cclass/int/sx9b.html</a></p>
",0
24359995,24359256,0,"<p>Here's an example of simpler case to understand this more complex case:</p>

<pre><code>int b = 4;
int *a = &amp;b; // Allowed and works because a is a pointer to an integer
a+1 = 5; // Not allowed no idea about the type of a+1 and it could be used!!
</code></pre>

<p>Why this relates to your problem ?</p>

<pre><code>int(*matrix)[5][5];
printf(""%p\n"",matrix);
printf(""%p\n"",matrix+1);
</code></pre>

<p><strong>Output</strong></p>

<pre><code>0xb7753000
0xb7753064
</code></pre>

<p>Difference between the above pointers is of 6*16 + 4 = 100. This number is nothing but row*col*sizeOf(int) = 5*5*4 = 100</p>

<p>Therefore, what you want to do was accessing the cells in matrix, however what you are actually doing is trying to access a memory that your not allowed to use as in the first simple example.</p>

<p><strong>Example of what you are actually doing vs what you wanted the program to do:</strong></p>

<pre><code>int(*matrix)[5][5];
matrix + 0 =&gt; address of matrix
matrix + 1 =&gt; address of matrix + 100 bytes (you expected + 4 bytes instead)
matrix + 2 =&gt; address of matrix + 200 bytes (you expected + 8 bytes instead)
etc...
</code></pre>
",0
22125456,22125437,2,"<p>The instances of <code>1000</code> you have specified are <code>int</code>s, therefore the multiplication takes place by multiplying <code>int</code>s and getting an <code>int</code>. This is overflowing before it gets assigned to a <code>long int</code>. Try:</p>

<pre><code>long int a = 1000L * 1000L * 1000L * 1000L * 1000L * 1000L;
</code></pre>

<p>Also you need to then print the answer using a <code>long int</code> format, e.g.:</p>

<pre><code>printf(""%ld\n"", a);
</code></pre>

<p>Note a <code>long int</code> may also be too small (if you are on some 32 bit platforms the maximum storable in a <code>long int</code> is <code>2^31 - 1</code>, whereas on 64 bit platforms it's <code>2^63 - 1</code> which is sufficient), in which case try:</p>

<pre><code>long long int a = 1000LL * 1000LL * 1000LL * 1000LL * 1000LL * 1000LL;
printf(""%lld\n"", a);
</code></pre>
",0
22125458,22125437,2,"<p>Even though you are assigning to a <code>long int</code>, each of your <code>1000</code>s is an <code>int</code>, so the computer tries to calculate the result as an <code>int</code>. A number that exceeds the maximum <code>int</code> size overflows, causing it to ""wrap around"" and be seen as negative, because one bit of the memory used for an <code>int</code> is a negative flag.</p>

<p>You need to cast the <code>1000</code>s, either with <code>1000L</code> or <code>(long int) 1000</code> for each. You also need <code>%ld</code> instead of <code>%i</code> in your <code>printf</code>.</p>
",0
22125484,22125437,1,"<p>Try using </p>

<pre><code>long long var=1000LL*1000LL*1000LL;  // append LL

printf(""%lld"",var);
</code></pre>
",0
33597987,25450668,1,"<p>Dont worry. Just press
<code>Alt+Space</code> and then press enter.
With this we are giving repaint desktop command, which is available in drop down menu left to file menu.</p>
",0
25451130,25450668,1,"<p>Try to install the 64 bit version of Turbo C if you haven't already. If that isn't an option, you might be able to get it to work by running in compatibility mode. </p>

<p>Right click the icon -> Properties -> Compatibility then select Run this program in compatibility mode for Windows XP. </p>
",0
25450770,25450668,0,"<p>Install dosbox from <a href=""http://www.dosbox.com/download.php?main=1"" rel=""nofollow"">here</a> and then follow the tutorial <a href=""http://blog.windows8downloads.com/2013/02/how-to-install-and-start-turbo-c-on-windows-8-x32-x64/"" rel=""nofollow"">here</a></p>

<p>DOSBox can run old MS-DOS software on modern computers which would not work otherwise, because of incompatibilities between the older software and modern hardware and operating systems.
Turbo C is a 16 bit software,you are trying it on a 64 bit OS</p>
",6
26202412,26201895,0,"<p>this one works with any number</p>

<pre><code>#include &lt;stdio.h&gt;
int digits(int n)
{
    int i;
    for(i=0;n;i++,n=n/10);
    return i; 
    }
int main()
{
    int i,j;
    int column,row;
    int n,cnt;

    printf(""Enter column: "");
    scanf(""%d"",&amp;column);
    printf(""Enter row: "");
    scanf(""%d"",&amp;row);
    scanf(""%d"",&amp;n);
    cnt=digits(n);

    for(i=0;i&lt;row;i++)
    {
        for(j=0;j&lt;column;j++)
        {
            if(i==0 || i==(row-1) || j==0 || j==(column-1))
                printf(""*"");
            else if((i==(row/2)) &amp;&amp; (j==((column-cnt)/2)))
            {
                printf(""%d"",n);
                j=j+(cnt-1);
            }
            else
                printf("" "");
        }
        printf(""\n"");
    }
    return 0;
}
</code></pre>
",3
26202631,26201895,-1,"<p>This should work!</p>

<p>It still has a small margin of error but I try to solve it</p>

<pre><code>/*Import*/
#include &lt;stdio.h&gt;

/*Function Prototyp*/
int countNumber(int number);

int main() {

    /*Variable*/
    int number, column, row;
    int columnCount, rowCount;
    int i;

    printf(""Enter column:\n&gt;"");
    scanf(""%d"",&amp;column);
    printf(""\nEnter row:\n&gt;"");
    scanf(""%d"",&amp;row);
    printf(""\nEnter number for center:\n&gt;"");
    scanf(""%d"",&amp;number);


    for (columnCount = 0; columnCount &lt; column; columnCount++) {

        for (rowCount = 0; rowCount &lt; row; rowCount++) {

            //Middle Row
            if (columnCount == column/2) {
                printf(""*"");

                for (i = 0; i &lt; ((row*2-3)-countNumber(number))/2;i++)
                    printf("" "");

                printf(""%d"", number);

                for (i = 0; i &lt; ((row*2-3)-countNumber(number))/2;i++)
                    printf("" "");

                if (countNumber(number % 2 == 0))
                    printf("" *"");
                else
                    printf(""*"");
                break;
            }

            if (columnCount==0 || columnCount==column-1 || rowCount==0 || rowCount==row-1)
                printf(""* "");
            else
                printf(""  "");

        }
        printf(""\n"");
    }


    return 0;
}

int countNumber(int number) {

    int count;

    for (count = 0; number &gt; 0; count++)
        number = number / 10;

    return count;
}
</code></pre>
",1
25523453,25523340,4,"<p>Like @WhozCraig commented, <code>int array[5]</code> won't hold the number of elements, and needs to be changed to <code>int array[6]</code>. </p>
",3
25492801,25492725,2,"<p><code>EOF</code> is only end of <strong>file</strong>, not end of line. See <a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/getchar.html"" rel=""nofollow"">the documentation</a>. So when you hit enter, your program stays in that <code>for</code> loop. You can fix this one of two ways:</p>

<ul>
<li>Actually send your program <code>EOF</code> (<code>Ctrl-D</code> on most *nix-based systems), or</li>
<li>check for a newline instead of <code>EOF</code>. </li>
</ul>

<p>Try this:</p>

<pre><code>  for (nc = 0; getchar() != '\n'; ++nc)
</code></pre>

<p>Note that your code will exit after the first newline you send.</p>
",0
25512921,25512884,0,"<p>Floating have a precision problem. And the reason is that 0.1 is not perfectly represented with float.</p>

<p>And a good read to start with:- <a href=""http://www.validlab.com/goldberg/paper.pdf"" rel=""nofollow"">What every computer scientist should know about floating-point arithmetic</a></p>
",1
26787350,26786825,0,"<p>Here's the typical scenario:</p>

<pre><code>// functions.c
void check(void) {
    // do stuff
}
</code></pre>

<p>Note: just the definition of check, and nothing else. Then a header:</p>

<pre><code>// functions.h
extern void check(void);
</code></pre>

<p>Just a declaration. Then the main file:</p>

<pre><code>// main.c
#include ""functions.h""

int main(int argc, char *argv[]) {
    check();
}
</code></pre>
",0
26787385,26786825,0,"<p>When definitions are provided in another file, you have to specify that like so using the <code>extern</code> keyword:</p>

<p><code>functions.h</code>:</p>

<pre><code>extern void check();
</code></pre>

<p><code>functions.c</code>:</p>

<pre><code>void check()
{
    printf(""\nThis is a Test\n"");
}
</code></pre>
",2
22113587,22112754,0,"<p>you probably not posted whole code here but looking some code here there is one array <code>bus_inumber[]</code> which might be local or global is might be the key factor for your issue.</p>

<p>Possible issue might be like as follows</p>

<p>During run state of your program you have set state 1 for bus number for which you enter the bus info,Now at reservation time you check that bus state if it set 1 then do reservation.So this logic works until your program loaded in RAM but it close and re-run then <code>bus_inumber[]</code> again initialized (probably with zero).</p>

<p>Now what you need here to save <code>bus_inumber[]</code> in some file  and on run program initialize this array with file data.</p>

<p>Also post more code so we can get idea.and it's not simple as you do so far for program might be related to <code>bus reservation system</code> or something else.it's require lots of validation and error checking mechanism.</p>
",0
28478080,28477931,0,"<p>You will have to initialize crit1[], crit2[], et c. to 0.</p>

<pre><code>for (i=0; i&lt;T; i++)
  crit1[i] = crit2[i] = crit3[i] = crit4[i] = 0
</code></pre>
",1
28478283,28477931,1,"<p>As stated by many others, you have a clear problem of uninitialized array, but it would be very unlikely that in that initialized memory you would find ""ones"". The actual source of your wrong result is that you shouldn't negate your conditions,  e.g.: <code>!islower(string[i][j])</code> should be simply <code>islower(string[i][j])</code></p>
",0
28478284,28477931,3,"<p>Several things.</p>

<p>First, declare a function that will say whether a password is strong. You should be able to pass a string into the function, and it will return an answer
telling you whether the password is strong.</p>

<p><em>Then</em> you can look in detail at the conditions with fewer distractions like that extra loop variable <code>i</code> that's in the middle of everything for no good reason in the old code.</p>

<p>The problem with your conditions turns out to be quite simple: they are all ""inverted"". That is, when you see a digit, you <em>don't</em> check off the criterion <code>crit2</code>, but you <em>do</em> check off <code>crit3</code> and <code>crit4</code>.
So now if you see either a lowercase or uppercase letter, you will
check off <code>crit2</code> (and redundantly check off one other criterion)
and you will say ""strong"" at the end.</p>

<p>So give your variables names that say what they do.
Never <code>crit1</code>, <code>crit2</code>, and so forth. Maybe <code>is_long_enough</code>, <code>has_digit</code>, etc.  That way when you write <code>is_digit = 1</code> at least you have an immediate clue that you should be looking at a digit. 
Then you are less likely to make silly mistakes like setting this criterion true when <code>!isdigit(c)</code> is true, as that is exactly opposite from the
condition you are trying to satisfy.</p>

<p>You also have some uninitialized arrays here, as others have observed, but if you take the advice to write a function to tell whether a single password is strong, and call that function once for each password, four of your arrays simply disappear from the code. They are replaced by four variables inside the function that only have to indicate the strength of one password (the one that function is working on at the moment). Just remember that every variable gets an initializer when you declare it, pick the obvious initializer for each of these, and you'll be OK.</p>
",0
22128069,22127978,1,"<p>It seems when you enter your age, the 'enter' remains in the buffer and gets read into location.</p>

<pre><code>printf(""Enter Your Age: "");
scanf(""%d"",&amp;age); 
printf(""Enter c for city and v for village: "");
scanf(""\n%c"", &amp;location); // add this line to ignore the newline character.
</code></pre>

<p>EDIT: <code>fflush()</code> removed because it seems it works only for output streams and not input. IMO Better is to first read the <code>newline</code> character and then the actual <code>location</code> character.</p>
",3
22128185,22127978,0,"<p>Another option is to </p>

<p><code>scanf("" %c"", &amp;location);</code></p>

<p>include a space before the <code></code> <code>%c</code> for it to ignore the white space or new line.</p>
",0
26426437,26426267,2,"<p>It has no any sense. It seems that it is some old code that was valid when C allowed implicit return type int if the return type is not specified explicitly. But in any case the return value is not an lvalue and can not be changed. So the const qualifier is superfluous.</p>
",0
26426639,26426267,4,"<p>If you turn on warnings you will have two:</p>

<pre><code>warning: type specifier missing, defaults to 'int' [-Wimplicit-int]
warning: 'const' type qualifier on return type has no effect [-Wignored-qualifiers]
</code></pre>

<p>which easily allows you to conclude that this:</p>

<pre><code>extern const func1(int x[], const struct dummy_s* dummy)
</code></pre>

<p>is basically the same as:</p>

<pre><code>extern int func1(int x[], const struct dummy_s* dummy)
</code></pre>
",2
26427199,26426267,2,"<p>In standard C, your code will not compile. You are not allowed to omit the return type of a C function.</p>

<p>In an older, obsolete version of C known as C90, you were allowed to omit the return type, in which case it would default to int. In that old version of C, your code would be equal to:</p>

<pre><code>extern const int func1(int x[], const struct dummy_s* dummy);
</code></pre>

<p>The next question then is, does it ever make sense to return <code>const int</code> from a function, rather than just <code>int</code>? No, it doesn't... because the returned variable is always a hard copy placed on the stack. It is not a lvalue and the function is executed in runtime anyhow, there is no reason why this value needs to be const.</p>
",2
24626486,24625681,0,"<p>While you can set up an elaborate parse routing to handle dates in a custom way. You can also make use of <code>strptime</code> to convert a string into a date object, and then use <code>strftime</code> to output the string to a buffer in any format you desire. The <code>man pages</code> contain all the format specifiers and examples which I've adapted to your situation. Take a look:</p>

<pre><code>#define _XOPEN_SOURCE
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;

int
main(int argc, char *argv[])
{
    struct tm tm;
    char buf[255];

    if (argc &lt; 2 ) {
        fprintf (stderr, ""Error: insufficient input, usage: %s date (mm/dd/yyyy)\n"",
                 argv[0]);
        return 1;
    }

    memset(&amp;tm, 0, sizeof(struct tm));
    strptime(argv[1], ""%m/%d/%Y"", &amp;tm);
    strftime(buf, sizeof(buf), ""%A, %B %e, %Y"", &amp;tm);
    printf (""\n  The formatted date is:  %s\n\n"",buf);
    return 0;
}
</code></pre>

<p>Just enter any date on the command line in <code>mm/dd/yyyy</code> format and it outputs similar to what you were looking for:</p>

<pre><code>$ ./bin/s2t 07/08/2014

The formatted date is:  Tuesday, July  8, 2014
</code></pre>
",0
26426422,26426239,0,"<p>you need to empty your buffer after each call to getchar so do as follows :</p>

<pre><code>s = getchar();
while((s = getchar()) != EOF &amp; s != '\n');
</code></pre>

<p>instead of an alone :</p>

<pre><code>s = getchar();
</code></pre>
",0
26426477,26426239,1,"<p>After entering values , you press the enter key (<code>\n</code>). This character stays in the <code>stdin</code>. In the second iteration,<code>getchar</code> gets the <code>\n</code> character and as it does not fulfill the condition in the <code>if</code> after it,the body of the <code>if</code> does not get executed and the next iteration starts as the condition in the <code>while</code> is true,thus printing it twice.</p>

<p>To remove the character,you need to <a href=""http://www.stackoverflow.com/questions/7898215/how-to-clear-input-buffer-in-c"">clear your <code>stdin</code></a></p>
",1
26426485,26426239,1,"<p>just use the function getch() before s= getchar();</p>

<pre><code>getch();
s=getchar();
</code></pre>

<p>that might help you or you can use</p>

<pre><code>scanf("" %c"",&amp;s);
</code></pre>

<p>instead of s=getchar();</p>

<p>don't forget to put space before %c</p>
",1
26447227,26447096,0,"<p>should fflush your buffer before taking char as an input</p>

<pre><code>do
{//..your code
printf(""\nDo you want to continue.?  \n(y/n) "");
scanf(""%c"",&amp;ch);
scanf(""%c"",&amp;ch);
}
while (ch == 'y');
</code></pre>
",2
26447106,26447096,0,"<pre><code>if (getch() == 'n') {
    // print something
    return;
}
</code></pre>
",0
31891174,31891095,1,"<p>OK, had to test it.  More improvements.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

char* get_line(FILE* f, int maxchar){

    char* string = malloc(maxchar+1);
    int c;
    int i = 0;

    while ((c = fgetc(f)) != EOF &amp;&amp; c != '\n' &amp;&amp; i &lt; maxchar){
        *(string + i++) = c;
    }
    *(string + i) = '\0';
    return string;
}


int main(void){
    FILE* f;
    f = fopen(""file.txt"", ""r"");
    printf(""%s\n"", get_line(f, 3)); 
    printf(""%s\n"", get_line(f, 5));

    fclose(f);
    return 0;
}
</code></pre>

<p>The reason that:</p>

<pre><code>printf(""%s\n %s\n"",get_line(f,3),get_line(f,5));
</code></pre>

<p>gives you unexpected results is due to order of evaluation of the function arguments.  In C which uses cdecl, the actual arguments to printf are evaluated right to left.  How printf handles this you would have to look at the code.  More reliable would be to use two lines as my example.</p>

<p>Your malloc line was wrong because you need to allocate space for number of characters and sizeof FILE* will return the size of a pointer which is not what you want.  You could also have checked the file byte size and use that as your maxchar.</p>

<p>Your use of fgets was also wrong.</p>

<p>In the loop you will have a char array with eg:</p>

<p>'c', ' ', 'l', 'a', 'n'</p>

<p>followed by random values (because you did not pre-assign values to the malloc'd buffer.  So the line:</p>

<pre><code>*(string + i) = '\0';
</code></pre>

<p>appends a null character to the end of the string to make it a null terminated c string - which is expected by the C string functions.</p>

<p>For clarity, *(string+i) means you take the address of string, add i and dereference (asterisk - * is the dereference operator).  </p>

<pre><code>= '\0'
</code></pre>

<p>appends the null character on the end of the string.</p>
",4
31891306,31891095,1,"<p>This statement </p>

<pre><code>char* string = (char*)malloc(sizeof(f));
</code></pre>

<p>does not make sense. You need to allocate memory for a string of size <code>maxchar</code>.</p>

<p>The same can be said about this loop</p>

<pre><code>while((c = fgetc(f)) != EOF &amp;&amp; c != '\n'){
        fgets(string,maxchar,f);
</code></pre>

<p>Either you should use <code>fgetc</code> or <code>fgets</code></p>

<p>The function can be written the following way using <code>fgetc</code></p>

<pre><code>char * get_line( FILE *f, size_t maxchar )
{
    char *record = NULL;

    if ( maxchar &amp;&amp; !feof( f ) &amp;&amp; ( record = malloc( maxchar ) ) != NULL )
    {
        int c;
        size_t i = 0;

        while ( i &lt; maxchar - 1 &amp;&amp; ( c = fgetc( f ) ) != EOF &amp;&amp; c != '\n' ) 
        {
            record[i++] = c;
        }

        record[i] = '\0';
    }

    return record;          
}
</code></pre>

<p>And do not forget to free the record in main before the end of the program. For example</p>

<pre><code>char *s;

if ( ( s = get_line(f,3) ) != NULL ) printf( ""%s\n"", s );
free( s );


if ( ( s = get_line(f,5) ) != NULL ) printf( ""%s\n"", s );
free( s );
</code></pre>

<p>The better approach is to declare the function the following way</p>

<pre><code>char * get_line( FILE *f, char *s, size_t maxchar );
</code></pre>

<p>In this case you can declare a character array in main and pass it in the function.</p>

<p>For example</p>

<pre><code>char * get_line( FILE *f, char *s, size_t maxchar )
{
    size_t i = 0;

    if ( maxchar )
    {
        int c;

        while ( i &lt; maxchar - 1 &amp;&amp; ( c = fgetc( f ) ) != EOF &amp;&amp; c != '\n' ) 
        {
            s[i++] = c;
        }
    }

    s[i] = '\0';

    return s;          
}
</code></pre>

<p>And in main there can be</p>

<pre><code>#define MAX_CHAR 80
//...
int main( void )
{
    char s[MAX_CHAR];

    //...

    printf( ""%s\n"", get_line( f, s, 3 ) );

    printf( ""%s\n"", get_line( f, s, 5 ) );

    //...
</code></pre>
",3
24616687,24616512,2,"<p>Change your variables to <code>float</code>:</p>

<pre><code>float simp_acct = 100, comp_acct = 100, years;
</code></pre>

<p>Otherwise, your values will be rounded off to an integer when you multiply by a fraction.</p>

<p>You also need to fix the compound interest formula, it should be:</p>

<pre><code>comp_acct *= 1.05;
</code></pre>

<p>You're just setting <code>comp_acct</code> to the interest, and losing the principle.</p>
",1
24616717,24616512,2,"<pre><code>#include &lt;stdio.h&gt;

int main() {
    double simp_acct = 100, comp_acct = 100;
    int years = 0;
    simp_acct += 10; /*simple interest*/
    comp_acct *= 1.05; /*compound interest*/
    while(comp_acct &lt; simp_acct) {
        simp_acct += 10;
        comp_acct *= 1.05;
        years++;
    }

    printf(""Compound interest at .05%% beats simple interest at 10%% "");
    printf(""after %d years.\n"", years);
    return 0;
}
</code></pre>

<p>Here is the working code. First of all if you keep multiplying by <code>0.05</code> you actually decrease the number and adding 10 increases it. What happens is <code>simple_acct</code> just overflows and the condition is met, because <code>comp_acct</code> becomes zero at some point. Second of all you use <code>int</code> and that won't give you true results when you work with floating point numbers.</p>
",0
25663339,25663031,3,"<p>If you have integer values, you could abuse <code>printf</code> format specifications.</p>

<p>If you want to print a * preceeded by n spaces, you could use something like:</p>

<pre><code>printf(""%*s\n"", n, ""*"");
</code></pre>

<p>Bear in mind tha tif this is for a class assignment, you also need to be able to explain why this works, but the relevant section should be in the man page for <code>printf</code>.</p>
",2
27678507,27678275,1,"<p>The issue seems to be with program compilation. The program looks fine except for the <code>getch()</code> function call. If you are on Windows you should include <code>&lt;conio.h&gt;</code>. On Linux, as far as I know, there is no standard equivalent of <code>getch()</code>, so you should remove the <code>getch()</code> call.</p>
",9
26140705,26140052,0,"<p>C has a <a href=""http://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_value"" rel=""nofollow"">call-by-value</a> semantics. So any changes to formal <code>input</code> inside <code>dynamic_array</code> is <em>not</em> propagated to the caller (e.g. your <code>main</code>).</p>

<p>Your <code>main</code> does not initialize <code>input</code>. If you compiled with all warnings and debug info (as you should), e.g. with <code>gcc -Wall -g</code>, you'll get a warning about that. </p>

<p><sup>I actually recommend to initialize <em>every</em> local variable. This makes the debugging easier (since runs are more reproductible). Useless initializations will be removed by the optimizer.</sup></p>

<p>You could initialize <code>input</code> inside your <code>main</code> with</p>

<pre><code>  char* input = NULL;
</code></pre>

<p>and you should redesign your program, perhaps by having a <code>grow_array</code> function (instead of your <code>dynamic_array</code>) which you would call in your <code>main</code> like</p>

<pre><code> grow_array (&amp;input, &amp;string_len);
</code></pre>

<p>I leave up to you to declare and implement <code>grow_array</code> correctly. I'm too lame to do your homework.</p>

<p>Inside your <code>grow_array</code> you want to call <code>malloc</code> and test it:</p>

<pre><code>*pptr = malloc(newsize);
if (!*pptr) { perror (""malloc""); exit (EXIT_FAILURE); };
</code></pre>

<p>Don't forget to use the debugger (<code>gdb</code>) to run your program <em>step by step</em>.</p>

<p><sup>I don't recommend using <code>realloc</code> because error handling could be tricky. I would suggest using <code>malloc</code> and <code>free</code> and <em>cleverly</em> copying the data using <a href=""http://www.tutorialspoint.com/c_standard_library/c_function_memcpy.htm"" rel=""nofollow"">mempcy</a>.</sup></p>

<p>Read the documentation of every function that you are using, e.g. <a href=""http://man7.org/linux/man-pages/man3/malloc.3.html"" rel=""nofollow"">malloc(3)</a>, <a href=""http://man7.org/linux/man-pages/man3/printf.3.html"" rel=""nofollow"">printf(3)</a></p>
",0
26140135,26140052,6,"<p>This:</p>

<pre><code>realloc(input, (sizeof(char)));
</code></pre>

<p>is wrong. The <code>realloc()</code> function doesn't modify the given pointer (it can't!), it <em>returns</em> the new pointer. It can also fail, and return <code>NULL</code>.</p>

<p>Also, the second argument doesn't make any sense at all, it should be the new desired <em>total size</em> of the previously allocated buffer, but you're always passing (a very obscure) 1. It's not ""grow this by this amount"", it's the rather more low-level ""attempt to grow this to this new size, and return the new location of the grown buffer"".</p>

<p>Please read <a href=""http://linux.die.net/man/3/realloc"">the documentation</a> very carefully.</p>
",2
26140251,26140052,0,"<pre><code>if(!dynamic_array(input, &amp;string_len)){
return 0;
}
</code></pre>

<p>""input"" variable is used without initialization. </p>

<p>realloc(input, (sizeof(char)));</p>

<p>Above ""realloc"" is returning bad pointer. It may be totally bogus, or it may have been allocated from another heap. The pointer MUST come from the 'local' heap.</p>
",1
26140290,26140052,0,"<pre><code>realloc(input, (sizeof(char)));
</code></pre>

<p>You are reallocating with same size (i.e 1 byte). It shoud be:  </p>

<pre><code>while((temp_c = getchar()) != '\n') {
    realloc(input, (string_len + 1) * (sizeof(char)));
    input[string_len++] = temp_c;
</code></pre>
",2
26151116,26140052,0,"<p>couple of things that I noticed.</p>

<pre><code>int dynamic_array(char *input, int *string_current_len) should change to 
int dynamic_array(char **input, int *string_current_len)
</code></pre>

<p>since this function is trying to modify a pointer.
 also the call to the function here </p>

<pre><code> if(!dynamic_array(input, &amp;string_len)){
       return 0;
      }
</code></pre>

<p>needs to be:</p>

<pre><code>if(!dynamic_array(&amp;input, &amp;string_len)){
       return 0;
      }
</code></pre>
",0
31265327,31265064,1,"<p>yes, foo2() is definitely faster than foo1() because foo2 refers a pointer to that memory block and everytime you access it just points there and fetches value from the mmory.</p>
",3
31265362,31265064,4,"<p>this <a href=""https://goo.gl/xhL1rk"" rel=""nofollow"">assembly version of your code</a> could help you understand why your code is slower. But of course it could vary depending on the target architecture and you optimization flags ( Commpiling with <code>O2</code> or <code>O3</code> flags produce the same code for <code>foo1</code> and <code>foo2</code> )</p>

<p>In <code>foo2</code> the address of <code>ChannelInfo</code> is stored in a register and address are calculated relative to the value stored in the register. Or in the worst case in the stack (local variable ) where in that case it could be as slow as <code>foo1</code>.</p>

<p>In <code>foo1</code> the variable address for printf are calculated relative to the variable <code>gAppInfo</code> stored in memory heap (or in cache ).</p>

<p>As per @Ludin's request I added <a href=""http://norvig.com/21-days.html#answers"" rel=""nofollow"">these numbers for reference</a> :</p>

<ul>
<li>Execution of an instruction : 1 ns</li>
<li>fetch from main memory : ~100 ns </li>
</ul>

<p><a href=""https://goo.gl/kl8ywd"" rel=""nofollow"">assembly version with -O2 flags</a> ( -Os and -O3 flags produce the same code )</p>
",3
31288593,31265064,1,"<p>Pondering things like this isn't meaningful and it is pre-mature optimization, because the code will get optimized so that both those functions are equivalent.</p>

<p>If you for some reason would not optimize the code, foo2() will be slightly slower because it yields a few more instructions.</p>

<p>Please not that the call to printf is approximately 100 times slower than the rest of the code in that function, so if you are truly concerned about performance you should rather focus on avoiding stdio.h instead of doing these kinds of mini-optimizations.</p>

<p>At the bottom of the answer I have included some benchmarking code for Windows. Because the printf call is so slow compared to the rest of the code, and we aren't really interested in benchmarking printf itself, I removed the printf calls and replaced them with volatile variables. Meaning that the compiler is required to perform the reads no matter level of optimization.</p>

<blockquote>
  <p>gcc test.c -otest.exe -std=c11 -pedantic-errors -Wall -Wextra -O0</p>
</blockquote>

<p>Output:</p>

<pre><code>foo1 5.669101us
foo2 7.178366us
</code></pre>

<blockquote>
  <p>gcc test.c -otest.exe -std=c11 -pedantic-errors -Wall -Wextra -O2</p>
</blockquote>

<p>Output:</p>

<pre><code>foo1 2.509606us
foo2 2.506889us
</code></pre>

<p>As we can see, the difference in execution time of the non-optimized code corresponds roughly to the number of assembler instructions produced (see the answer by @dvhh). </p>

<p>Unscientifically: </p>

<p>10 / (10 + 16) instructions = 0.384</p>

<p>5.67 / (5.67 + 7.18) microseconds = 0.441</p>

<hr>

<p>Benchmarking code:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;


struct ChannelInfo
{
  int iData1;
  int iData2;
  int iData3;
  int iData4;
};

struct AppInfo
{
  struct ChannelInfo gChannelInfo[100];

} gAppInfo;


void foo1 (void);
void foo2 (void);

static double get_time_diff_us (const LARGE_INTEGER* freq, 
                                const LARGE_INTEGER* before, 
                                const LARGE_INTEGER* after)
{
  return ((after-&gt;QuadPart - before-&gt;QuadPart)*1000.0) / (double)freq-&gt;QuadPart;
}


int main (void)
{
  /*** Initialize benchmarking functions ***/
  LARGE_INTEGER freq;
  if(QueryPerformanceFrequency(&amp;freq)==FALSE)
  {
    printf(""QueryPerformanceFrequency not supported"");
    return 0;
  }

  LARGE_INTEGER time_before;
  LARGE_INTEGER time_after;

  gAppInfo.gChannelInfo[50].iData1 = 1;
  gAppInfo.gChannelInfo[50].iData2 = 2;
  gAppInfo.gChannelInfo[50].iData3 = 3;
  gAppInfo.gChannelInfo[50].iData4 = 4;


  const size_t ITERATIONS = 1000000;

  QueryPerformanceCounter(&amp;time_before);
  for(size_t i=0; i&lt;ITERATIONS; i++)
  {
    foo1();
  }
  QueryPerformanceCounter(&amp;time_after);
  printf(""foo1 %fus\n"", get_time_diff_us(&amp;freq, &amp;time_before, &amp;time_after));

  QueryPerformanceCounter(&amp;time_before);
  for(size_t i=0; i&lt;ITERATIONS; i++)
  {
    foo2();
  }
  QueryPerformanceCounter(&amp;time_after);
  printf(""foo2 %fus\n"", get_time_diff_us(&amp;freq, &amp;time_before, &amp;time_after));

}


void foo1 (void)
{
  volatile int d1, d2, d3, d4;

  d1 = gAppInfo.gChannelInfo[50].iData1;
  d2 = gAppInfo.gChannelInfo[50].iData2;
  d3 = gAppInfo.gChannelInfo[50].iData3;
  d4 = gAppInfo.gChannelInfo[50].iData4;
}

void foo2 (void)
{
  struct ChannelInfo* pCurrrentChan = &amp;gAppInfo.gChannelInfo[50];
  volatile int d1, d2, d3, d4;

  d1 = pCurrrentChan-&gt;iData1;
  d2 = pCurrrentChan-&gt;iData2;
  d3 = pCurrrentChan-&gt;iData3;
  d4 = pCurrrentChan-&gt;iData4;
}
</code></pre>
",5
26440945,26440710,0,"<p>The correct formulas are as given below</p>

<pre><code>Maximum height: h=pow(v*sin(¦È*M_PI/180),2)/(2*g);
Time in air: t = (2*v*sin(¦È*M_PI/180))/g;
Range: r = (2*pow(v,2)*sin(¦È*M_PI/180)*cos(¦È*M_PI/180))/g;
</code></pre>

<p>You can even reduce Range formula to <code>pow(v,2)*sin(2*¦È*M_PI/180)/g</code> </p>

<p>as <code>sin(2¦È) = 2*sin(¦È)*cos(¦È)</code></p>

<p>From the comments by @Mat, @BLUEPIXY and @Sanhadrin</p>
",1
26442058,26440710,0,"<p>Thanks for your answer, I didn't know that sin &amp; cos use radian. I had to rewrite the whole thing and this is how it looks now:</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;math.h&gt;

int main(void){
    int theta;
    float h, g=9.8, t, r, v;

    printf(""Type a value for the angle that the projectile is launched (in whole degrees): "");
    scanf(""%d"",&amp;theta);
    printf(""Type a value for the initial velocity of the projectile (in m/s): "");
    scanf(""%f"",&amp;v);


    theta = theta*M_PI/180;
    h = pow(v*sin(theta),2)/(2*g);
    t = (2*v*sin(theta))/g;
    r = (2*pow(v,2)*sin(theta)*cos(theta))/g;

    printf(""The maximum height is %f m, the time it takes for the projectile to hit the ground is %f s and it's range is %f m\n"", h, t, r);

    return 0;
}
</code></pre>

<p>And when I run it:</p>

<pre><code>Type a value for the angle that the projectile is launched (in whole degrees): 110
Type a value for the initial velocity of the projectile (in m/s): 6.2
The maximum height is 1.388691 m, the time it takes for the projectile to hit the ground is 1.064718 s and it's range is 3.566673 m
</code></pre>
",0
25496830,25496813,2,"<p>C programs can only return <code>int</code> while being standards compliant, the only valid signatures are </p>

<pre><code>int main(void) { ... }
</code></pre>

<p>and</p>

<pre><code>int main(int argc, char **argv) { ... }
</code></pre>

<p>However many compilers offer others as extensions, such extensions are allowed by the standard but are not guaranteed to be portable between compilers or platforms.</p>
",0
25496847,25496813,0,"<p>Only <code>int</code> is accepted by any good compiler unless you use an extension or Microsoft crud.</p>

<p>The only standards compliant signatures for <code>main</code> are:</p>

<pre><code>int main(void);
</code></pre>

<p>and</p>

<pre><code>int main(int argc, char *argv[]);
</code></pre>

<p>the first taking command line parameters and the second not.</p>

<hr>

<p>In c++ the first signature would be written like this:</p>

<pre><code>int main();
</code></pre>

<p>instead</p>
",0
29160474,29160419,2,"<p>What you see is undefined behavior.</p>

<p>The value <code>f</code> is never initialized and you are printing uninitialized variable which will lead to undefined behavior.</p>

<p><code>printf()</code> returns number of characters successfully printed out so the count here is 5(hello) for printing hello.</p>

<p>You need to return this value if you want then you have defined behavior because you are initializing the variable <code>f</code> in main()</p>

<pre><code>int func()
{
  int j;
  j = printf(""hello"");
  return j;
}
</code></pre>
",4
25454542,25454454,2,"<ol>
<li>You are calling getchar and putchar multiple times (because they are inside a loop) so they get and print multiple characters.</li>
<li>You MUST use an int variable when using getchar, because getchar can return any character or EOF. EOF isn't a character, so it doesn't fit in a char, and it represents the end of the file.</li>
</ol>
",5
25454621,25454454,0,"<p>Variable <code>c</code> will always contain just 1 character, which is <code>int</code>. You are overwriting previous value with return value of a function <code>getchar</code> in each iteration of a loop.</p>

<p>Also try to avoid duplicate code by rewriting the <code>while</code> loop. You can call function <code>getchar</code> and assign value to variable <code>c</code> inside the <code>while</code> condition:</p>

<pre><code>while ((c = getchar()) != EOF) {
    putchar(c);
}
</code></pre>
",5
33026408,33023853,0,"<p>Without telling you exactly the code to write, because you are asking for help with academic work, you can try this:</p>

<ol>
<li>Read in a line of text.</li>
<li><p>Using the length of the line (<code>scanf</code> returns an int with the number of characters read if I'm not mistaken), loop through it backwards, printing each character at a time.<br>
Something to try would be like this:  </p>

<pre><code> //This is pseudocode. Do not copy/paste
 for(int i = length of line; i &gt; 0; i--) {
     print out line[i];
 }
</code></pre></li>
<li><p>Then divide the length by 2 and run two loops in reverse, one starting in the middle:  </p>

<pre><code>//This is Psuedocode. Do not copy/paste
for(int i = middle of line; i &gt; 0; i--) {
    print out line[i];
}
</code></pre>

<p>And then another starting at the end:  </p>

<pre><code>//This is Pseudocode. Do not copy/paste
for(int i = length of line; i &gt; middle of line; i--) {
    print out line[i];
}
</code></pre></li>
<li>????</li>
<li>Profit</li>
</ol>

<p>Obviously, you will have to tweak a few things here and there. For example, <code>i = length of line</code> will cause a runtime error, but you're here to learn and I believe in learning by doing.</p>
",4
26189865,26189808,0,"<p>All you want is: <code>*k = &amp;a;</code></p>

<p>The <code>**</code> thing means it is a pointer to a pointer. I think the following diagram will make it clear. Open the image in a new tab to see it clearly.
<img src=""https://i.stack.imgur.com/Wx4BQ.png"" alt=""enter image description here"">
Read more <a href=""http://www.tutorialspoint.com/cplusplus/cpp_pointer_to_pointer.htm"" rel=""nofollow noreferrer"">here</a>.</p>
",3
25704568,25704551,2,"<p>You are doing 2 reads for each write</p>

<pre><code>  while((c = fgetc(poem)) != EOF) {  // read
       c = getc(poem);               // read
       fputc(c, html);               // write
  }
</code></pre>
",2
24382710,24382527,0,"<p>The main problem I can see here is that you're only checking in a single direction, so if the last counter is dropped into the middle of a '4' then this won't accept it as a win.</p>

<p>I would probably have a function that goes through each direction in turn (think compass points), counts the length of the unbroken 'line' in each direction, and stores it in a temporary variable. After this has been done for each direction, add together the lines in the opposite sides, and see if it adds to 4.</p>

<p>There's probably a million other ways to do this though!</p>
",0
24382925,24382527,0,"<p>I think for-loop is OK for your problem. For position (x,y), (x,y)+(1,0)*k(k=0,1,2,...) will do the same thing as your first line do.</p>

<p>Actually, I think you should check for 4 directions, not just x-axis.</p>

<p>Like I just said, (-1,0) and (1,0) will help you to check positions around (x,y) in x-axis.</p>

<p>Similarly, for other directions.</p>
",0
26414264,26414164,2,"<p><code>scanf(""%d"", &amp;num)</code> expects <code>num</code> to have <code>int</code>-type. Passing the address of a type with <code>sizeof(othertype) &lt; sizeof(int)</code> is undefined behaviour. <br><br> If you want to <code>scanf()</code> into a <code>char</code>-sized variable, you have to use <code>scanf(""%hhd"", &amp;num)</code> or <code>scanf(""%c"", &amp;num)</code>.<br>The same principle applies to <code>printf()</code>, by the way. Use <code>printf(""%hhd"", num)</code> or <code>printf(""%c"", num)</code> when <code>num</code> is of type <code>char</code>.<br><br>Also, the return type of <code>main()</code> in C is <code>int</code>.</p>
",0
27517901,27517869,1,"<p>I think you have an error in this line :</p>

<pre><code>if (z&gt;x&amp;&amp;z&gt;y)
</code></pre>

<p>This should be</p>

<pre><code>else if (z&gt;x&amp;&amp;z&gt;y)
</code></pre>
",0
27517905,27517869,2,"<p>You have the control statements like this</p>

<pre><code>if (x&gt;y&amp;&amp;x&gt;z) ...
if (z&gt;x&amp;&amp;z&gt;y) ...
else
</code></pre>

<p>The <code>else</code> corresponds to the second <code>if</code> condition, and will execute its body if the condition in the second <code>if</code> is false, even if the first condition is true.</p>

<p>I think you mean to do something like this:</p>

<pre><code>if (x&gt;y&amp;&amp;x&gt;z) ...
else if (z&gt;x&amp;&amp;z&gt;y) ...
else
</code></pre>
",1
27517919,27517869,2,"<p>The first statement you see, ""You've entered in no order,"" is printed because your input satisfied the test <code>if (x&gt;y&amp;&amp;x&gt;z)</code>. Then the second top-level <code>if</code> clause is evaluated, and the second statement ""You've chosen in on order"" is printed because your input does not satisfy <code>if (z&gt;x&amp;&amp;z&gt;y)</code>. Both statements are tested because you did not connect them with an <code>else if</code>. If you want only one statement to be printed, your top level <code>if</code> structure needs to look like this:</p>

<pre><code>if (x &gt; y &amp;&amp; x &gt; z)
{


} else if (z &gt; x &amp;&amp; z &gt; y)
{

} else {

}
</code></pre>
",0
27518213,27517869,0,"<p>Short versi¨®n:</p>

<pre><code>if (x&gt;y&amp;&amp;y&gt;z){
   printf(""you've entered in decending order "");
}else if (z&gt;y&amp;&amp;y&gt;x) {
   printf(""you've printed in ascending order"");
}else {
   printf(""you've printed in no order"");
}
</code></pre>
",0
29224913,29224872,0,"<p>In order to fill these values you would have allocated memory to these pointers <code>free()</code> them accordingly. For example:</p>

<pre><code>typedef struct 
{
  unsigned char *name;
  struct QUESTION *ques;
}QUERY;

QUERY *q = malloc(sizeof(QUERY));
q-&gt;name = malloc(20);
q-&gt;ques = malloc(sizeof(struct QUESTION));

//Filling the values and using them when done you need to free the allocated memory
</code></pre>

<p>Now free them</p>

<pre><code>free(q-&gt;name);
q-&gt;name = NULL;
free(q-&gt;ques);
q-&gt;ques = NULL;
free(q); 
q = NULL;
</code></pre>
",0
29224918,29224872,0,"<p>Because of the nested structs and pointers, you can't use bzero or memset(). You just have to set the values to 0 and free them and set them to NULL in the right order. In other words, don't NULL out a reference to anything containing an unfreed pointer.</p>

<p>Straightforward stuff</p>
",0
24368848,24368793,7,"<p>It should be <code>ch = toupper(ch);</code></p>

<p><code>toupper</code> does not modify it's argument.</p>

<p>And, while not in any way related to the issue, I would recommend using <code>switch</code> for code like  this.</p>
",0
24368860,24368793,0,"<p><code>toupper(ch);</code> computes the uppercase of ch but does nothing with it. Your code works fine with UPPERCASE input. With lowercase input you just need to change </p>

<pre><code>toupper(ch);
</code></pre>

<p>to </p>

<pre><code>ch = toupper(ch);
</code></pre>
",0
24368910,24368793,1,"<p>Your problem is in <code>toupper()</code>. The function does not alter your char directly, it returns the altered char. </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

int main(void)
{
    char ch; int sum = 0;

    printf(""Enter a word: "");

    while ((ch = getchar()) != '\n') {
        ch = toupper(ch);
        if (ch == 'A' || ch == 'E' || ch == 'I' || ch == 'L' || ch == 'N' || ch == 'O' || ch == 'R' || ch == 'S' || ch == 'T' || ch == 'U')
            sum += 1;
        else if (ch == 'D' || ch == 'G')
            sum += 2;
        else if (ch == 'B' || ch == 'C' || ch == 'M' || ch == 'P')
            sum += 3;
        else if (ch == 'F' || ch == 'H' || ch == 'V' || ch == 'W' || ch == 'Y')
            sum += 4;
        else if (ch == 'K')
            sum += 5;
        else if (ch == 'J' || ch == 'X')
            sum += 8;
        else if (ch == 'Q' || ch == 'Z')
            sum += 10;
    }
    printf(""\nScrabble value: %d"", sum);
    return 0;
}
</code></pre>
",0
26446354,26446151,2,"<p><code>t1</code> is <code>i * (inumInts * sizeof(int))</code>.</p>

<p>So, <code>inumInts</code> * 32 = 1024.</p>

<p>Thus, <code>inumInts</code> = 32.</p>

<p><code>t1</code> is <code>j * (jnumInts * (inumInts/sizeof(int))</code>, becasue there is 1 <code>j</code> for every row of <code>i</code>.</p>

<p>So, <code>jnumInts</code> * 1 = 32.</p>

<p>Thus, <code>jnumInts</code> = 32.</p>

<p><code>t2</code> is <code>k * (knumInts * (inumInts/sizeof(int) / ((inumInts*jnumInts)/sizeof(int))))</code>. 
(because there is one <code>i</code> and <code>i</code> rows of  <code>j</code> for every <code>k</code>) </p>

<p>So, <code>knumInts</code> * 1/2 = 4.</p>

<p>Thus, <code>knumInts</code> = 8.</p>

<p>Thus, <code>int X[32][32][8]</code>.</p>
",1
26446359,26446151,2,"<p>Not enough info. I'll try to prove it to you:</p>

<p>To make our life easier, let's divide all values by 4, since that's the size of an integer(considering a character size of 8 bits). That leaves us with:</p>

<p>multiplier of i: 256;
multiplier of j: 8;
multiplier of k: 1.</p>

<p>k must be 1, because it's the last index used, witch means it has to jump only 1 integer to get to the next one in the row.</p>

<p>j, on the other hand, has to jump 8 integers, so it can get to the same position on the next row. That means each row has 8 integers. And we have our value for k. Our array X now looks like: X[i][j][8]</p>

<p>i has to jump through 256 integers to get to the next column. Since a row has 8 integers, and 256/8 = 32, that means each column has 32 rows, leaving array X as: X[i][32][8]</p>

<p>finally, we need to know how many pages the array has. But there's no way to know that, since we would need the full size of the array in bytes, so we can divide it by 256 and then know the number of pages. That leads us back to the beginning of this answer: There's simply not enough info.</p>
",1
26446414,26446151,1,"<p>The first dimension of the array has no effect on the address calculation. The <code>sizeof(int)</code> does have an effect on the address calculation. So it might help to rewrite answer a) as</p>

<pre><code>X[][32][8][4]
     i  j  k
</code></pre>

<p>where the last <code>[4]</code> represents the <code>sizeof(int)</code>.  So the address calculation is </p>

<pre><code>(k * 4) + (j * 8 * 4) + (i * 32 * 8 * 4) = i * 1024 + j * 32 + k * 4
</code></pre>

<p>From this, I would conclude that both a) and c) are correct answers.</p>
",0
26446427,26446151,2,"<p>Exp: It is given that Size of int is 4B and of char is 1B. The memory is byte addressable. 
Let the array be declared as Type X[A][B][C] (where Type = int/char and A,B,C are natural 
numbers). </p>

<pre><code>From t0 = i*1024, we conclude that B*C*(size of Type) = 1024. 
From t1 = j*32, we conclude that C*(size of Type) = 32. 
From t2 = k*4, we conclude that size of Type = 4. 
Type = int, and 
C = 8, and 
B = 32.
</code></pre>
",0
26789319,26789157,0,"<p>Your buffer is 32 bytes large; the array parameter sets the size in terms of the unit. On most systems, an unsigned char is 1 byte (8 bits), so your buffer is 8*32 bits in size.</p>

<p>As it stands, you buffer contains 4 bytes of file and then 28 empty bytes after.</p>

<p>You can operate on those first 4 bytes like you would any value in an array, ex</p>

<pre><code>if (0x2 == buffer[0])
{
    printf(""I found a 2 in hex!"");
}
</code></pre>
",0
26789594,26789157,0,"<p>If you want to see the values in your binary files <em>printed</em> as hex bytes, try the following:</p>

<p>Change your declaration of buffer to:</p>

<pre><code>uint32_t buffer;
</code></pre>

<p>and your printf to:</p>

<pre><code>printf(""0x%0X\n"", buffer);
</code></pre>

<p>using the <code>uint32_t</code> type will keep your fread in line with your buffer on machines on which ints may not be 32 bits.  To use it, you may need to </p>

<pre><code>#include &lt;stdint.h&gt;
</code></pre>

<p>Using your fread, this will read 4 bytes from your file into a 4 byte type.  This will then be printed as a hex value.</p>
",0
27561963,27561934,1,"<p>Try using the <code>,</code> symbol to separate data into cells:</p>

<pre><code>fprintf(fp,""%d,%d\n"",100,200);
//            ^
</code></pre>
",0
27561995,27561934,2,"<p>MS DOS standard uses ';'.</p>

<p>Use it instead of '\t'</p>
",1
25488608,25488488,2,"<p>Your check for <code>tok==NULL</code> in the <code>while</code> loop happens <em>after</em> the call to <code>strcpy</code>, not before. You're trying to copy a NULL pointer.</p>

<p>Whenever you get a segmentation fault, the first thing to look for is the possibility of a NULL pointer.</p>
",5
25488613,25488488,2,"<p>In this code:</p>

<pre><code>                    while(tok!=NULL)
                    {
                        tok=strtok(NULL,""^"");
                        strcpy(o[k].objcode,tok);
                    }
</code></pre>

<p>You check for <code>tok</code>'s validity before entering the loop but not after it gets changed by <code>strtok()</code>.</p>

<p>A debugger should have been able to identify exactly which line of code had the problem, and from within the debugger you could see if the value of <code>tok</code> is okay or not at the time <code>strcpy()</code> gets called.</p>
",0
25488728,25488488,0,"<p>strcpy is not safe in terms of array size, use strncpy instead!!</p>

<p>i.e. if you get more data in your input, you will overflow your statement[i].</p>
",0
27150939,27150882,4,"<p>Use <a href=""https://www.gnu.org/software/emacs/manual/html_node/eintr/etags.html"" rel=""nofollow""><code>etags</code></a> with <code>emacs</code> (or else <a href=""http://ctags.sourceforge.net/"" rel=""nofollow""><code>ctags</code></a>, e.g. if using <code>vi</code>). Instead of <code>grep</code> consider using <a href=""http://beyondgrep.com/"" rel=""nofollow"">ack</a>.</p>

<p>Read more about the <a href=""https://en.wikipedia.org/wiki/Linker_%28computing%29"" rel=""nofollow"">linker</a> (e.g. <a href=""http://www.iecc.com/linker/"" rel=""nofollow"">Levine's book <em>Linkers &amp; Loaders</em></a>; details are operating system specific); on Linux see <a href=""http://www.gnu.org/software/binutils/"" rel=""nofollow"">binutils</a>. Notice that <code>extern</code>applies to <em>declarations</em>, not <em>definitions</em> of function or variable names.</p>

<p>Don't forget to run the <code>ctags</code> or <code>etags</code> command from time to time, and before using tags in your <code>emacs</code> or <code>vi</code> editor.</p>

<p>About macros: please understand that the <a href=""https://gcc.gnu.org/onlinedocs/cpp/"" rel=""nofollow"">C preprocessor</a> is the first phase of compilation. Read documentation of <a href=""https://gcc.gnu.org/onlinedocs/cpp/"" rel=""nofollow"">GNU <code>cpp</code></a>. Don't expect macros to be functions, they are textual devices! Use perhaps <code>gcc -Wall -C -E foo.c &gt; foo.i</code> (with some more options to <code>gcc</code>, e.g. <code>-I</code> and <code>-D</code> ones) to get the preprocessed form <code>foo.i</code> of source file <code>foo.c</code>; look inside the generated <code>foo.i</code> with  your editor.</p>
",3
31235853,31235786,2,"<p>I think that the problem arises in this loop</p>

<pre><code>for (w = 0; j &lt; (control - 1); w++)
{
    j = i*i + w*i;
    vetor[j] = FALSE;
}
</code></pre>

<p>It seems that the value calculated such a way as</p>

<pre><code>j = i*i + w*i;
</code></pre>

<p>can be greater than control.</p>

<p>You could rewrite the loop like</p>

<pre><code>for (w = 0; ( j = i*i + w*i ) &lt; (control - 1); w++)
{
    vetor[j] = FALSE;
}
</code></pre>

<p>Also in my opinion the loop</p>

<pre><code>   while (testes != 0)
    {
        //...
        testes--;
        free(vetor);
    }
</code></pre>

<p>would be more readable if it would be rewritten the following way</p>

<pre><code>   while ( testes-- != 0 )
   {
        //...
        free(vetor);
    }
</code></pre>

<p>or</p>

<pre><code>   while ( testes-- )
   {
        //...
        free(vetor);
    }
</code></pre>

<p>Take into account that you wrote the program such a way that it seems nobody understands what it does.:) You should try to write programs more readable even if they are test programs.</p>
",1
31235859,31235786,-1,"<p><code>j = i*i + w*i</code> will become much larger than the last valid index for the array. Accesses beyond the borders of an array presents <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow""><em>undefined behaviour</em></a>.</p>

<p>One effect <em>might</em> be to overwrite memory used by the hep management, so the effect will only become visible when calling <code>free</code>.</p>
",0
27140698,27140656,4,"<pre><code>if (c == '' || c == '\n' || c = '\t')
</code></pre>

<p>should be </p>

<pre><code> if (c == ' ' || c == '\n' || c == '\t')


if (c == '\n')
    if (c == '' || c == '\n' || c = '\t')
</code></pre>

<p>In your code, the first if statement makes the second meaningless.</p>
",4
27140707,27140656,4,"<pre><code>if (c == '' || c == '\n' || c = '\t')
</code></pre>

<p>The first thing wrong with this line is that it should be:</p>

<pre><code>if (c == ' ' || c == '\n' || c == '\t')
</code></pre>
",4
27140734,27140656,1,"<p>If you want to test the value of your variable <code>c</code> with an empty space, you should compare it with <code>' '</code> instead of <code>''</code>. Furthermore, comparison operator is <code>==</code>, not <code>=</code> (assignment), which you used to compare the tab character <code>'\t'</code> in the last condition of your if statement, thus your if statement should be:</p>

<pre><code>if (c == ' ' || c == '\n' || c == '\t')
</code></pre>
",0
27140683,27140656,1,"<p>You are testing the value of <code>c</code> against an empty character constant <code>''</code>, which is not allowed. I think you want to test it against a space <code>' '</code>.</p>
",2
27147580,27140656,1,"<p>this code block:</p>

<pre><code>while((c = getchar()) != EOF)
{
    ++nc;
    if (c == '\n')
        if (c == '' || c == '\n' || c = '\t')
        state = OUT;
    else if (state == OUT) {
        state = IN;
        ++nw;
    }
}

does not indicate (via the indentation) exactly which 'if' clause 
is related to the 'else clause.  
this is a VERY good reason to include ALL the '{' and '}' braces

this is what is actually written in the code:

while((c = getchar()) != EOF)
{
    ++nc;
    if (c == '\n')
    {
        if (c == '' || c == '\n' || c = '\t') // two errors on this line
        {
            state = OUT;
        }
        else if (state == OUT) 
        {
            state = IN;
            ++nw;
        }
    }
}

the question becomes:  is this what you really wanted?
we already know that the code is not correct
because the second 'if' will ALWAYS fail due to 'c' being
already confirmed as containing a '\n'
and the comparison of 'c' to ''
and the assignment of '\t' to 'c'

therefore, I suspect it should be:

while((c = getchar()) != EOF)
{
    ++nc;
    if (('\n' == c) || (' ' == c) || ('\n' == c) || ('\t' == c) ) 
    {
        state = OUT;
    }
    else if (state == OUT) 
    {
        state = IN;
        ++nw;
    }
}

which would have also caught the assignment of '\t' to c at compile time
rather than you having to spend many an hour debugging the code.
I.E. put the literal on the left side of the comparison operator '=='
</code></pre>
",0
27150430,27140656,0,"<p>Well this worked, I used ideas from Amadeus, user3629249 and Min Fu. Thanks everyone for your help.</p>

<p>Working Code:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define IN 1
#define OUT 0

int main()
{
int c, nl, nw, nc, state;
state = OUT;
nc = 0;
nl = 0;
nw = 0;
while((c = getchar()) != EOF)
{
++nc;
if (('\n' == c) || (' ' == c) || ('\n' == c) || ('\t' == c) )
{
    state = OUT;
    ++nl;
}
else if (state == OUT)
{
    state = IN;
    ++nw;
}
}
printf(""%d %d %d \n"", nl, nw, nc);
return 0;
}
</code></pre>
",0
26223312,26222939,0,"<p>It doesn't really peek, it reads the char into the stream's buffer. On an unbuffered stream, or when you've read nothing after opening the file or seeking, <code>ungetc()</code> isn't guaranteed to work.</p>
",3
29504430,29504380,2,"<p><code>func_pointer = func_test</code> and <code>func_pointer = *func_test</code> work because function names are automatically turned into function addresses when used in this context. 
<code>func_pointer(2)</code> works because function pointers automatically dereference themselves, much like references. As to why they do these things, I don't know. Maybe it was decided the syntax was complicated enough already.</p>
",0
32964087,32963111,0,"<p>I think I understand what it is you are trying to do. In addition to Rohan's answer, you are also stumbling over the use of <code>strtok</code>. While it is somewhat a catch 22, since you are reading a string with symbols separated by <code>newlines</code>, you can still make <code>strtok</code> work. Understand though, when using <code>strtok</code>, your first call to <code>strtok</code> uses the pointer to the string as its first argument:</p>

<pre><code>chk = strtok (line, delims);
</code></pre>

<p>while all subsequent calls to <code>strtok</code> use <code>NULL</code> as the first argument:</p>

<pre><code>chk = strtok (NULL, delims);
</code></pre>

<p>What is nice about <code>strtok</code> is it was tailor-made for parsing an entire string in a <code>for</code> loop format. e.g.:</p>

<pre><code>for (chk = strtok (line, delims); chk; chk = strtok (NULL, delims))
</code></pre>

<p>Putting that together, and cleaning up <code>symbolTblChar[MAX_SYMBOLS]</code> to simply be an array of pointers to <code>char</code>, rearranging your logic a bit, provides the following example. I guessed at what you would need for <code>LINE_SIZE</code> and what would work for <code>MAX_SYMBOLS</code> (adjust as required):</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define LINE_SIZE    128
#define MAX_SYMBOLS   32

int main (int argc, char **argv) {

    char *symbolTblChar[MAX_SYMBOLS] = {NULL};
    char line[LINE_SIZE] = {0};
    char *chk = NULL;
    char delims[] = "" \n"";
    int lblCnt = 0;
    int t = 0;
    FILE *fp = argc &gt; 1 ? fopen (argv[1], ""r"") : stdin;

    if (fp != stdin &amp;&amp; !fp) {
        fprintf (stderr, ""error: file open failed '%s'.\n"", argv[1]);
        return 1;
    }

    printf (""\nCollecting Symbols:\n"");
    while (fgets (line, LINE_SIZE, fp)) 
    {                                   
        for (chk = strtok (line, delims); chk; chk = strtok (NULL, delims)) {
            printf (""  Adding %s to symbol table\n"", chk);
            symbolTblChar[lblCnt] = strdup (chk);
            lblCnt++;

            /* check for MAX_SYMBOLS */
            if (lblCnt == MAX_SYMBOLS) {
                fprintf (stderr, ""warining: MAX_SYMBOLS limit reached.\n"");
                break;
            }
        }
    }

    /* close file if not stdin */
    if (fp != stdin) fclose (fp);

    /* output */
    printf (""\nSymbols:\n"");
    for (t = 0; t &lt; lblCnt; t++)
        printf(""  %s\n"", symbolTblChar[t]);

    /* free allocated memory */
    for (t = 0; t &lt; lblCnt; t++)
        free (symbolTblChar[t]);

    return 0;
}
</code></pre>

<p><strong>Output</strong></p>

<p>Using your sample input provides:</p>

<pre><code>$ printf ""SPACE \n LINE \n A1 \n A2\n"" | ./bin/symbltbl

Collecting Symbols:
  Adding SPACE to symbol table
  Adding LINE to symbol table
  Adding A1 to symbol table
  Adding A2 to symbol table

Symbols:
  SPACE
  LINE
  A1
  A2
</code></pre>

<p><strong>Note:</strong> you can of course remove the <code>Adding X ...</code> intermediate print line when you are done with it. Now, even though it may not be apparent, you need to <code>free</code> the memory associate with each symbol added to <code>symbolTblChar</code> using <code>strdup</code> (which both allocates and copies its argument to a new memory location). You can see that taking place at the end of <code>main</code>.</p>

<p>If this isn't what you intended, let me know. After looking at the question and what you were doing, this seemed like your logical intent. Let me know if you have any questions.</p>

<p><strong>File Input:</strong> note, you can also provide an input filename as the first argument to the program and the program will read from the file instead of <code>stdin</code>. For example, the input file:</p>

<pre><code>$ cat symbols.txt
  SPACE
  LINE
  A1
  A2
</code></pre>

<p><strong>Output Reading from File</strong></p>

<pre><code>$ /bin/symbltbl symbols.txt

Collecting Symbols:
  Adding SPACE to symbol table
  Adding LINE to symbol table
  Adding A1 to symbol table
  Adding A2 to symbol table

Symbols:
  SPACE
  LINE
  A1
  A2
</code></pre>
",0
32963256,32963111,1,"<p>You need to allocate and store characters. With your code you are storing pointer of character array <code>line</code> and it will get overwritten when you read subsequent lines.</p>

<p>You need to do something like</p>

<pre><code>*symbolTblChar[lblCnt]= strdup(chk);
</code></pre>

<p>Also, not sure you need double char pointer as</p>

<pre><code>char* symbolTblChar[MAX_SYMBOLS][100];
</code></pre>

<p>You can work with below which will store <code>MAX_SYMBOLS</code> number of strings.</p>

<pre><code>char* symbolTblChar[MAX_SYMBOLS];
</code></pre>
",3
26148476,26148298,1,"<p>do like this:</p>

<pre><code> typedef struct { 
            char  name[MAX_CITY_LEN];
            float latitude;
            float longitude;
 } PLACE_T;

 PLACE_T places[] ={
      {""India,kochi"",57.15,-2.15},
      {""Adelaide,Australia"",-34.92,138.6},
      {""Albany,NY,USA"",42.67,-73.75},
      {""Albuquerque,NM,USA"",35.08,-106.65},
      {""Algiers,Algeria"",36.83,3.0},
      {""Amarillo,TX,USA"",35.18,-101.83},
   };

int main(){
   int j;
  int found=0;
  char city[MAX_CITY_LEN];
  printf(""enter city name:"");
  fgets(city,MAX_CITY_LEN,stdin);
  city[strlen(city)-1]='\0';
  int citySize=(sizeof(places)/sizeof(places[0]));
  for(j=0;j&lt;citySize;j++){
     if(strcmp(city,places[j].name)==0){
        found=1;                                
        printf(""lat = %f, long = %f"",places[j].latitude,places[j].longitude); 
        break;                              
     }
   }
   if(!found)
     printf(""City not found"");

    return 0;

}
</code></pre>
",6
28215582,28215474,1,"<p>If you are using an IDE (<a href=""https://en.wikipedia.org/wiki/Integrated_development_environment"" rel=""nofollow"">Integrated Development Environment</a>) then all the files in the project should be automatically linked together.</p>

<p>If you're build for hand using command line prompt, the simplest way is to list all source files on the command line, like</p>

<pre><code>$ cc -Wall -g main.c file.c -o myprogram
</code></pre>

<p>The above command (<code>cc</code>) compiles <code>main.c</code> and <code>file.c</code> and then links them together into the resulting executable file <code>myprogram</code>.</p>

<p>The flags used are:</p>

<ul>
<li><code>-Wall</code> to add more warnings, always good when developing</li>
<li><code>-g</code> to add debug information, that can be used by a debugger</li>
<li><code>-o</code> what to name the resulting output</li>
</ul>
",1
28215596,28215474,0,"<p>Compile:</p>

<pre><code>gcc main.c file.c -o res
</code></pre>

<p>Now with the both the <code>.c</code> files are compiled and linked together forming an executable file res</p>

<p>and run</p>

<pre><code>./res
</code></pre>
",0
28215679,28215474,0,"<p>To add to the other answers, it could also be good if you create a <code>Makefile</code>, your make file might have the following content</p>



<pre class=""lang-none prettyprint-override""><code>CC      = gcc
CFLAGS  = -Wall -Wextra -Werror
LDFLAGS =
OBJ     = main.o file.o

executable: $(OBJ)
    $(CC) $(CFLAGS) $(LDFLAGS) $(OBJ) -o YourProgramName

%.o: %.c
    $(CC) -c $(CFLAGS) $&lt;
</code></pre>

<p>and then, just type <code>make</code> in your console and an executable binary <code>YourProgramName</code> will be created.</p>

<p>If you are using an IDE, then it might be capable of opening the <code>Makefile</code> and hence load your whole project.</p>
",0
26787144,26786899,1,"<p>Change</p>

<pre><code>while(temp){
  temp = temp-&gt;next;
}

temp = (struct vertex*)malloc(sizeof(struct vertex));
</code></pre>

<p>to </p>

<pre><code>while(temp-&gt;next){
  temp = temp-&gt;next;
}

temp-&gt;next = (struct vertex*)malloc(sizeof(struct vertex));
temp = temp-&gt;next;
</code></pre>
",5
24591557,24591527,-1,"<p>If str is declared as <code>char *</code> then this statement</p>

<pre><code>scanf(""%s"", &amp;str);
</code></pre>

<p>is incorrect. There has to be</p>

<pre><code>scanf(""%s"", str);
</code></pre>

<p>And the next statement</p>

<pre><code>printf(""%c"",str);
</code></pre>

<p>is also incorrect. There has to be</p>

<pre><code>printf(""%c"", *str);
</code></pre>

<p>If you want to output some other character in the character array using pointer <code>char *</code> then you can write either</p>

<pre><code>printf( ""%c"", *( str + n ) );
</code></pre>

<p>or</p>

<pre><code>printf( ""%c"", str[n] );
</code></pre>

<p>or even as</p>

<pre><code>printf( ""%c"", n[str] );
</code></pre>

<p>where n some integer value that less then <code>strlen( str )</code></p>

<p>Take into account that str shall point to some allocated memory. Otherwise the program will have undefined behaviour.</p>
",4
24591777,24591527,2,"<p>1)</p>

<pre><code>  It works fine but I don't know how to access a specific character in that string as I would with a char[]
</code></pre>

<p>Just dereference the pointer-array with [] and access the character at position ""i""</p>

<pre><code>str[i]
</code></pre>

<p>2)</p>

<pre><code>I have been messing around a bit but all I get is the first character or segfaults or bus errors
</code></pre>

<p>Yes - the arrayname itself is a pointer to the first character of the string</p>
",0
24601110,24601084,3,"<p>Your indices are not correct.  In C, indices start with 0.  The first loop should be:</p>

<pre><code>for ( i = 0; i &lt; 10; i++ )
</code></pre>

<p>The indices in second loop are also not correct.  They should be:</p>

<pre><code>int length = strlen ( string[i] );
if( length &gt; 1 &amp;&amp; ( string[i][length-1] == 'd' &amp;&amp; string[i][length -2] == 'e' ) )
</code></pre>

<p>In the above statement, since the indices start at 0, the last element will be at <code>length-1</code>.  If your string is <code>smiled</code>, the character at index 0 is <code>s</code> and the last character is at index 5 (<code>d</code>) while the length of string is 6.</p>
",9
22460512,22460408,2,"<p>It will read only the first 100 chars</p>
",0
24637336,24637272,1,"<pre><code>strcpy(month2, month); 
</code></pre>

<p>Neither <code>month</code> nor <code>month2</code> have been initialized to anything useful at this point.  Their contents are indeterminate and calling <code>strcpy</code> with something other than a properly terminated C-string invokes undefined behavior.</p>

<p>Looks like a typo to me.</p>
",0
24637572,24637272,0,"<p>Lesser code, But without some validations.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
        char date[100];

        char month[100];
        char array[12][100] = {""January"", ""Febuary"", ""March"", ""April"", ""May"", ""June"", ""July"",  ""August"", ""September"", ""October"", ""November"", ""December""};

        printf("" Please enter a date "");
        fgets( date, 100, stdin);

        char month2[100];
        strcpy(month2, date);
        month2[2] = '\0';

        strcpy(month, array[atoi(month2) - 1]);

        printf(""%s \n"", month);
        return 0;
}
</code></pre>
",0
24638748,24637272,0,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;

typedef struct mon {
    const char *name;
    const int len;
} Month;

#define M(x){ x "" "", sizeof(x)}

Month month[] = { {"""", 0}, //dummy
    M(""January""), M(""Febuary""), M(""March""), M(""April""),
    M(""May""), M(""June""), M(""July""), M(""August""),
    M(""September""), M(""October""), M(""November""), M(""December"")
}; 


int main(){
    char in_date[128];
    char out_date[128] = """";
    int m = 0, pos;
     printf("" Please enter a date E.g MM/DD/YYYY\n"");
     fgets( in_date, sizeof(in_date), stdin);

    if(in_date[0] == '0'){
        if(isdigit(in_date[1]) &amp;&amp; in_date[1] != '0'){
            m = in_date[1] - '0';
            pos = month[m].len;
            memcpy(out_date, month[m].name, pos);
        }
    } else if(in_date[0] == '1'){
        if('0' &lt;= in_date[1] &amp;&amp; in_date[1] &lt;= '2'){
            m = 10 + in_date[1] - '0';
            pos = month[m].len;
            memcpy(out_date, month[m].name, pos);
        }
    }
    if(m){
        memcpy(out_date + pos, in_date + 3, 7);
        out_date[pos + 2] = ',';
        out_date[pos + 7] = '\0';
        printf(""%s\n"", out_date); 
    } else {
        printf(""invalid month\n"");
    }
    return 0; 
}
</code></pre>
",0
24630428,24630296,2,"<p>add:</p>

<pre><code>#include &lt;errno.h&gt;
#include &lt;stdio.h&gt;

//other code here

if (frameData == NULL) {
  perror(""fopen()"");
  return;
}
</code></pre>

<p>This should get your debugging started...</p>

<p>Don't forget to <code>fclose(frameData)</code> before returning, that may also be causing an error (file already opened) in the second time the function is called.</p>
",0
24631840,24630296,-1,"<p>Most likely NOT a failure of <code>fopen()</code> but you should check it and exit the program if it's not working as following (it returns a NULL pointer when not working):</p>

<pre><code>FILE* fp = fopen(""SOMEFILE.txt"", ""a"");
if(!fp) //in other words - NOT fp - means FP == NULL
{
  printf(""Error: Could not open the file specified.\n"");
  exit(1);
}
</code></pre>

<p>The logical reason would be you not using <code>fclose()</code>. <code>fopen()</code> always changes (I mean it returns a different pointer for different paths) and so it uses dynamic memory such as <code>malloc()</code> if you learned it which is a lot slower than static memory. The dynamic memory will
still be 'used' in the program (no matter if it's in a function or anywhere) until you supposedly 'free' it - when using <code>malloc()</code> you'd free the memory simply by using the function <code>free()</code>.
When using <code>fopen()</code> - the way to 'free' that dynamic memory is using <code>fclose()</code> on that pointer - this way:</p>

<pre><code>fclose(FILE_POINTER_NAME);
</code></pre>

<p>when FILE_POINTER_NAME is the... hmm... well, the file pointer name.</p>

<p>Hope I helped.</p>
",0
30134610,30134471,0,"<p>Looking at just an excerpt of your code:</p>

<pre><code>fseek(fptr, 0, SEEK_END);
unsigned long len = (unsigned long)ftell(fptr);
if (len &gt; 0) {  //check if the file is not empty.
    while ( !feof( fptr ) ){
        fscanf( fptr,""%f\n"", &amp;p.burst_time );
</code></pre>

<p>For some reason you are seeking to the end of the file before you do any reads.  I'm assuming that you are doing this to figure out the size of the file.</p>

<p>The reason that you get crazy output is that you haven't actually read anything, so <code>feof</code> fails to return an end of file until the first time through.</p>

<p>I'd suggest you resolve this by adding <code>fseek(fptr, 0, SEEK_SET);</code> immediately before the <code>while</code> statement.</p>
",0
29522507,29522364,0,"<p>You are lying both to <code>scanf()</code> and to <code>printf()</code> about the types of variables <code>input1</code> and <code>input2</code>.  The <code>%d</code> field descriptor promises that the corresponding argument is an <code>int</code> (or a pointer to one, for <code>scanf()</code>), but the actual type in your code is <code>char</code>.  The behavior of the resulting program is undefined.</p>

<p>Your program works fine for me if I change the variables' type to <code>int</code>.</p>
",3
29522455,29522364,0,"<p>First, you should (in general, notably for interactive programs) rather put <code>\n</code> at <em>end</em> not beginning of <code>printf</code> of <code>fprintf</code> format control string. Or else use <code>fflush</code></p>

<p>BTW, <code>%d</code> is for <code>int</code>s so declare <code>int input1, input2;</code> and if enabling all warnings with <a href=""http://gcc.gnu.org/"" rel=""nofollow noreferrer"">GCC</a> e.g. compiling with <code>gcc -Wall -Wextra -g</code> you would have been warned.</p>

<p>Then, you should <em>always</em> test the result of <code>scanf</code> (or <code>fscanf</code>); it gives the number of read items.</p>

<p>See <a href=""http://man7.org/linux/man-pages/man3/printf.3.html"" rel=""nofollow noreferrer"">printf(3)</a>, <a href=""http://man7.org/linux/man-pages/man3/fprintf.3.html"" rel=""nofollow noreferrer"">fprintf(3)</a>, <a href=""http://man7.org/linux/man-pages/man3/fflush.3.html"" rel=""nofollow noreferrer"">fflush(3)</a>, <a href=""http://man7.org/linux/man-pages/man3/fscanf.3.html"" rel=""nofollow noreferrer"">fscanf(3)</a></p>

<p>If on Linux, see also <a href=""https://stackoverflow.com/a/29361728/841108"">this answer</a> about not waiting for full lines.</p>
",3
29522458,29522364,1,"<p>change <code>char input1, input2;</code> to <code>int input1, input2;</code></p>
",3
31261819,31261251,3,"<p>Any self-respecting modern compiler will optimize the original code to eliminate the repetitive dereferencing of the same chain of pointers in situations when it is safe.</p>

<p>But, firstly, the original version of the code is much less readable than the one that uses an intermediate variable. When pointer dereference chains are long, it is not immediately obvious to a human eye that the chains are identical. The variant with the intermediate variable makes it explicitly clear that we want to read <code>name</code> and <code>age</code> from the same object. In the first variant it is not even remotely as clear.</p>

<p>Secondly, in situations when the aliasing picture is not as obvious to the compiler as in your case, the compiler might have to abandon optimizations. E.g. in general case when you do something like </p>

<pre><code>some_ptr-&gt;next = first-&gt;next-&gt;next-&gt;next-&gt;next;
some_ptr-&gt;prev = first-&gt;next-&gt;next-&gt;next-&gt;prev;
</code></pre>

<p>the compiler cannot be sure that the first assignment does not affect the value of <code>first-&gt;next-&gt;next-&gt;next</code>. (Consider what happens if <code>some_ptr</code> is equal to <code>first</code>.) This forces the compiler to play it safe and reevaluate <code>first-&gt;next-&gt;next-&gt;next</code> every time from the very beginning. In this case introducing an intermediate variable will indeed optimize the code. For that, of course, you yourself have to be sure that this is the right thing to do, i.e. to use your own knowledge of possible aliasings in your program.</p>
",0
31261894,31261251,2,"<p>What optimizations a compiler does depends on which compiler you use and the optimization flags you pass to it. You can always examine the assembler code the compiler outputs to see what it has done.</p>

<p>For example, the compiler that came installed with Xcode (Apple LLVM version 6.1.0 (clang-602.0.53) (based on LLVM 3.6.0svn)), with the appropriate definitions for <code>node</code>, does not remove the duplicate access chain even with the highest optimization settings:</p>

<pre><code>    movq    %rdi, %rbx
    movq    (%rbx), %rax
    movq    (%rax), %rax
    movq    (%rax), %rsi
    addq    $8, %rsi
    leaq    -40(%rbp), %r14
    movq    %r14, %rdi
    callq   __ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC1ERKS5_
    movq    (%rbx), %rax
    movq    (%rax), %rax
    movq    (%rax), %rax
    movl    32(%rax), %ebx
</code></pre>

<p>If you use a temporary variable though the compiler just reuses the register <code>%rbx</code>, so you get the temporary for free:</p>

<pre><code>    movq    (%rdi), %rax
    movq    (%rax), %rax
    movq    (%rax), %rbx
    leaq    8(%rbx), %rsi
    leaq    -40(%rbp), %r14
    movq    %r14, %rdi
    callq   __ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC1ERKS5_
    movl    32(%rbx), %ebx
</code></pre>

<p>Here's the test program:</p>

<pre><code>#include &lt;string&gt;

using namespace std;

string myname;

struct node {
    node *next;
    string name;
    int age;
};

int foo1(node *first) {
    string name = first-&gt;next-&gt;next-&gt;next-&gt;name;
    int age = first-&gt;next-&gt;next-&gt;next-&gt;age;
    myname=name;
    return age;
}


int foo2(node *first) {
    node* billy_block = first-&gt;next-&gt;next-&gt;next;
    string name = billy_block-&gt;name;
    int age = billy_block-&gt;age;
    myname=name;
    return age;
}
</code></pre>

<p>Compiler options <code>g++ -Wall -S -O3 test.cpp</code></p>
",0
31261624,31261251,2,"<p>The compiler can only coalesce two loads:</p>

<pre><code>int x = *p;
...;
int y = *p;
</code></pre>

<p>if all of:</p>

<ul>
<li><code>p</code> is not a pointer to volatile.</li>
<li>there are no writes during the <code>...</code> that may alias.</li>
</ul>

<p>The problem of alias analysis is <em>really hard</em>, so this mostly means <em>any</em> write. On the other hand, the problem of creating additional variables that are only assigned once and then read zero or more times is fundamentally how compilers work, so never hesitate to add a temporary.</p>

<hr>

<p>If anyone comes across this answer and is using C++, however, beware of destructor ordering.</p>
",0
27531836,27531769,1,"<p>You must check the result of <code>strtok</code> if it's <code>NULL</code> meaning that no tokens where found you will get <code>segmentation fault</code></p>

<pre><code>char *pointer;
pointer = strtok(buf, "" "");
if (pointer != NULL)
    strcpy(command, pointer);
</code></pre>

<p>also, <code>readline</code> allocates new memory on every call so you should <code>free</code> inside the <code>while</code> loop.</p>

<p>Fix it this way</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &lt;readline/readline.h&gt;
#include &lt;readline/history.h&gt;

int main()
{
    char *buf;
    char command[32];
    char name[32];

    while((buf = readline(""\n""))!=NULL)
    {
        char *pointer;
        if (strcmp(buf,""exit"")==0)
            break;

        printf(""%s\n"",buf);

        pointer = strtok(buf, "" "");
        if (pointer != NULL)
        {
            strcpy(command, pointer);
            /* Don't print poitner otherwise since it is unintialized */
            printf(""%s\n"", pointer);
        }

        /* subsequent calls to strtok must have first argument NULL */
        pointer = strtok(NULL, "" "");
        if (pointer != NULL)
        {
            strcpy(name, pointer);
            printf(""%s\n"", pointer);
        }

        if (buf != NULL) // this is never FALSE because of the while condition
            add_history(buf);
        free(buf);
    }
    return 0;
}
</code></pre>

<p>you also have to make sure that <code>command</code> and <code>name</code> will be big enough to fit the resulting stirng.</p>
",5
31149225,31149193,5,"<p>Because the operands to <code>&lt;&lt;</code><sup>*</sup> undergo <em>integer promotion</em>.  It's effectively equivalent to <code>(int)i &lt;&lt; 1</code>.</p>

<p><hr>
<sub>* This is true for most operators in C.</sub></p>
",1
31149280,31149193,4,"<p>Several things are happening.</p>

<p>First, the expression <code>i &lt;&lt; 1</code> has type <code>int</code>, not <code>char</code>; the literal <code>1</code> has type <code>int</code>, so the type of <code>i</code> is ""promoted"" to <code>int</code>, and <code>0x100</code> is well within the range of a signed integer.  </p>

<p>Secondly, the <code>%d</code> conversion specifier expects its corresponding argument to have type <code>int</code>.  So the argument is being interpreted as an integer.</p>

<p>If you want to print the numeric value of a signed <code>char</code>, use the conversion specifier <code>%hhd</code>.  If you want to print the numeric value of an unsigned <code>char</code>, use <code>%hhu</code>.  </p>
",12
31149292,31149193,2,"<p>For arithmetical operations, <code>char</code> is promoted to <code>int</code> before the operation is performed. See <a href=""http://port70.net/~nsz/c/c11/n1570.html#6.3.1.1"" rel=""nofollow"">the standard</a> for details. Simplified: the ""smaller"" type is first brought to the ""larger"" type before the operation is performed. For the shift-operators, the resulting type is that of the left side operand, while for e.g. <code>+</code> and other ""combining"" operators it is the larger of both, but at least <code>int</code>. The latter means that <code>char</code> and <code>short</code> (and their <code>unsigned</code> counterparts are always promoted to <code>int</code> with the result being <code>int</code>, too. (simplified, for details please read the standard)</p>

<p>Note also that <code>%d</code> takes an <code>int</code> argument, not a <code>char</code>.</p>

<p>Additional notes:</p>

<ul>
<li><code>unsigned char</code> has not necessarily the range <code>0..255</code>. Check <code>limits.h</code>, you will find <code>UCHAR_MAX</code> there.</li>
<li><code>char</code> and ""byte"" are synonymously used in the standard, but neither are necessarily 8 bits wide (just very likely for modern general purpose CPUs).</li>
</ul>
",0
31150643,31149193,0,"<p>As others have already explained, the statement ""printf(""\n %d"",i &lt;&lt; 1);"" does integer promotion. So the one right shifting of integer value 128 results in 256. You could try the following code to print the maximum value of ""unsigned char"". The maximum value of ""unsigned char"" has all bits set. So a bitwise NOT operation using ""~"" should give you the maximum ASCII value of 255.</p>

<pre><code> int main()
 {
     unsigned char ch = ~0;
     printf(""ch = %d\n"", ch);
     return 0;
 }

Output:-
M-40UT:Desktop$ ./a.out 
ch = 255
</code></pre>
",0
25500529,25500329,4,"<p>When <code>scanf</code> fails due to the input not being a number, the input remains in the stream. So when you hit the next iteration of the loop, it reads the same thing and fails again in the same way.</p>

<p>Instead you should take some other action when the input fails, e.g. </p>

<pre><code>if ( scanf(""%d"", &amp;option) != 1 )
{
    printf(""You didn't enter a number.\n"");
    break;
}
</code></pre>

<p>In this situation you may also want to flush the input (i.e. discard the bogus characters). Presumably the bogus characters were input by someone typing them and press Enter, so you just read and discard all characters up until a newline. One way of doing this (there are several, including fancy <code>scanf</code> format strings) is:</p>

<pre><code>for ( int ch; (ch = getchar()) != EOF &amp;&amp; ch != '\n'; ) { }
</code></pre>
",2
25500410,25500329,2,"<p>This ""else"" that you used does not make sense. You only use the ""else"" keyword after an ""if"".</p>

<p>Just remove the else, and the program should work.</p>
",1
25500480,25500329,0,"<p>What Is The meaning of <code>else</code> here ? We can't see any <code>if</code> commands here :/
You also need to add this part after <code>scanf(""%d"", &amp;option);</code></p>

<pre><code>scanf(""\n"");
</code></pre>

<p>because, after you entered a number, it gets the EOF. then it compares the EOF. so it will loop forever.</p>
",2
25500918,25500329,0,"<p><code>scanf</code> consumes only the input that matches the format string, returning the number of characters consumed. Any character that doesn't match the format string causes it to stop scanning and leaves the invalid character still in the buffer. </p>

<p>You need to flush the invalid character out of the buffer before you proceed. This is a pretty dirty fix, but it will remove the offending characters from the output.</p>

<p>Try this program-</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;ctype.h&gt;
int main()
{
        int option = 0;
        char c = 0;
        printf(""\nPlease press any number to continue and press enter: "");
        scanf(""%d"", &amp;option);
        while(option &gt;=1 &amp;&amp; option &lt;= 9){
                printf(""\nPlease press any number to continue and press enter: "");

                if (scanf(""%d"", &amp;option) == 0) { //consume non-numeric chars from buffer
                        printf(""Please Enter a number\n"");
                        do {
                                c = getchar();
                        }
                        while (!isdigit(c));
                }
                else
                        // do your stuff here
                        ;
        }
        return 0;
}
</code></pre>
",0
25512948,25512285,1,"<p>Damn-short solution, I could fit it in a comment:</p>

<pre><code>#include&lt;stdio.h&gt;
main(N,L,B)
{
    N=114067,L=B=N&amp;1;
    while(N&gt;&gt;=1)B=(L=(N&amp;1)?L+1:0)&gt;B?L:B;
    return !printf(""%d"",B);
}
</code></pre>

<p><a href=""http://ideone.com/HTXdZO"" rel=""nofollow"">Live demo link.</a></p>

<hr>

<p>Nah... that was too short to understand anything, let's expand it a little:</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    int N = 0; // input value, will be read with scanf()
    int currentLength = 0; // here we will store the current number of consecutive ones
    int bestLength = 0; // here we will store the best result

    scanf(""%d"", &amp;N); // read the input value from standard input

    while (N) // as long as N is greater than 0
    {
        if (N &amp; 1) // if the last bit is set to 1
        {
            // cool, let's increment the current sequence's length
            currentLength += 1;

            // currentLength has changed, maybe now it is better than best known solution?
            if (currentLength &gt; bestLength)
            {
                // awesome! new best solution is found
                bestLength = currentLength;
            }
        }
        else
        {
            // we have encountered 0 while scanning bits, we must start counting the length over
            currentLength = 0;
        }

        // let's move to the next bit!
        N = N &gt;&gt; 1;
    }

    printf(""%d"", bestLength); // print out the value

    return 0;
}
</code></pre>

<p><a href=""http://ideone.com/uNli35"" rel=""nofollow"">One more live demo link.</a></p>
",4
23823605,23823507,1,"<p>The wcstok modifies the string passed in as argument so once you have run your loop to count lines the buffer is basically kaputt.</p>

<p>It seems like overkill to use wcstok to count lines when you easily could just loop through the buffer counting number of \n.</p>
",5
26451878,26451863,4,"<p>Use <code>%.2f</code> as the output format. </p>
",3
26451912,26451863,2,"<p>You can specify how many positions you want to display after the decimal point using <code>.</code> followed by the number of positions between <code>%</code> and <code>f</code> like so: <code>printf(""Your Net Pay is %.2f\n"", net);</code>. There are other formatting options that can be used with  format specifiers and you can read more on them in the man pages by doing <code>man printf</code> since <code>printf</code> is not just a <code>C</code> function.</p>
",0
24093633,24093621,0,"<p>Floating point numbers are not precise.</p>

<p>Therefore stuff like equality have long ago flown out of the window.</p>
",0
24093687,24093621,0,"<p>You cannot compare floating point numbers like that because they are not precise. You can check within a range though.</p>

<pre><code>#define epsilon 0.000005

main()
{
  float i=0.0;
  while(!(i &gt; 1.0 - epsilon &amp;&amp; i &lt; 1.0 + epsilon))
  {
      i+=0.1;
      printf(""%f"",i);
  }
  getch();
}
</code></pre>
",0
24093710,24093621,2,"<p>In the cases where you want to iterate over floating point numbers you should consider to <strong>iterate over integers and divide by floating point numbers</strong>.</p>

<p>In your case:</p>

<pre><code>#include&lt;stdio.h&gt;
main()
{
  int i=0;
  while(i!=10)
  {
      i+=1;
      printf(""%f"",i/10.0f);
  }
}
</code></pre>

<p>That way you get the best approximation and no accumulating rounding errors due to adding floating point numbers.</p>
",0
24093743,24093621,2,"<p>The loop is infinite because under a computer's floating-point arithmetic, adding 0.1 ten times is not equal to 1.</p>

<p>This is because computers use binary numbers to do arithmetic, and the number <code>0.1</code> cannot be expressed as a terminating binary number. So the computer has to pick a binary number that does terminate and that fits inside a <code>float</code> as an approximation to 0.1. Unfortunately, it is imprecise enough that adding ten copies of this approximation together does not create a float that's equal to 1.</p>

<p>If you change the format string in your loop to show a much higher precision, you can see that the values of <code>i</code> in the loop are not exact:</p>

<pre><code>0.10000000149011611938
0.20000000298023223877
0.30000001192092895508
0.40000000596046447754
0.50000000000000000000
0.60000002384185791016
0.70000004768371582031
0.80000007152557373047
0.90000009536743164062
1.00000011920928955078
</code></pre>

<p>Generally, you should not compare floating-point numbers for equality. You can use inequality comparisons, check if two numbers are almost equal by whether their difference is smaller than some small fixed value of epsilon, or use integers for iteration and only convert to floating point when you need it. The other answers already explain these alternatives, so I won't go into them here.</p>
",0
26167851,26167810,1,"<blockquote>
  <p>I am unable to understand the logic of n%2==0. If user input a value less than 2. Then how it give us correct answer? </p>
</blockquote>

<p>The operator <code>%</code> performs the modulus (or remainder) operation. The remainder of dividing a number by 2 (when that number is less than 2) is the number itself (with the quotient being 0). For example, one divided by two has a quotient of 0 and a remainder of 1 so 1%2 = 1.</p>
",2
28498649,28497803,1,"<p>I saw two issues:</p>

<ol>
<li><p>there is no code for printing either forward-slashes or backslashes in your code. I think you should add a <code>printf(""/"");</code> or <code>printf(""\\"");</code> before/after the loops which print the spaces.</p></li>
<li><p>To print a newline, you need <code>printf(""\\n"");</code> -- note the backslash.</p></li>
</ol>

<p>That being said, I mentioned in a comment to your question that the shape is symmetrical so it might be able to reuse the code for painting the upper half to draw the lower half. I mentioned that some function which prints a single <code>row</code> would be useful. Here's what I had in mind:</p>

<pre><code>#include &lt;stdio.h&gt;

/* Could have been passed to printRow() instead of using a global variable. */
int totalRows = 4;

void printRow( int row, char leftSlash, char rightSlash )
{
    int i;

    /* A couple of variables to aid readability. */
    int totalWidth = totalRows * 2;
    int numSpaces = row * 2;
    int numHashes = totalWidth - numSpaces - 2;

    for ( i = 0; i &lt; numHashes / 2; ++i ) {
        printf( ""#"" );
    }
    printf( ""%c"", leftSlash );
    for ( i = 0; i &lt; numSpaces; ++i ) {
        printf( "" "" );
    }
    printf( ""%c"", rightSlash );
    for ( i = 0; i &lt; numHashes / 2; ++i ) {
        printf( ""#"" );
    }
    printf( ""\n"" );
}

int main()
{
    int i;
    for ( i = 0; i &lt; totalRows; ++i ) {
        printRow( i, '/', '\\' );
    }
    for ( i = totalRows - 1; i &gt;= 0; --i ) {
        printRow( i, '\\', '/' );
    }
    return 0;
}
</code></pre>

<p>Note how the program first calls <code>printRow</code> with increasing values, and then with decreasing values for the lower half. The only thing which changes is the kind of slash to use for the left/right side.</p>
",1
28497867,28497803,3,"<p>A backslash in C (and many other languages) is a special ""escape"" character. For example - \n means a newline.
If you want a literal backslash, you need to escape it too - with a backslash - so <code>""\\""</code> will encode the single slash.</p>
",1
26204425,26204277,0,"<p>The Code is a little bit to messed up for me, but this should work:</p>

<pre><code>#include&lt;stdio.h&gt;

int main() {

    /*Variables*/
    int rows, starNumber, spaceNumber;
    int rowCount, spaceCount, starCount, treeTrunkCount, treeTrunkSpaceCount;

    printf(""Enter Rows:\n&gt;"");
    scanf(""%d"",&amp;rows);

    for(rowCount = 1; rowCount &lt;= rows; rowCount++) {
        starNumber = rowCount * 2 - 1;
        spaceNumber = rowCount + rows - starNumber;

        for(spaceCount = 0; spaceCount &lt; spaceNumber; spaceCount++)
            printf("" "");

        for(starCount = 0; starCount &lt; starNumber; starCount++)
            printf(""%c"",'*');

        printf(""\n"");
    }

    for(treeTrunkCount = 0; treeTrunkCount &lt; 3; treeTrunkCount++) {
        for(treeTrunkSpaceCount = 0; treeTrunkSpaceCount &lt; (rows * 2 + 1)/2; treeTrunkSpaceCount++)
            printf("" "");

        printf(""%c\n"",'*');
    }
}
</code></pre>
",0
26204492,26204277,0,"<p>This is the simplest solution to your program..</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
  int i=-1,j=0,rows;

  printf(""Enter Rows:\n"");
  scanf(""%d"",&amp;rows);

  while(j++&lt;rows) // Moving pointer for the first '*'
  {
    printf("" "");
  }
  printf(""*""); // This prints the first '*'
  while(++i&lt;rows)
  {
      for(j=-2;++j&lt;rows-i;) // This loop will print Spaces before '*' on each row
          printf("" "");
      for(j=0;++j&lt;2*i;) // This loop will print * on each row
      {
          printf(""*"");
      }
      printf(""\n""); // This printf will take you to the next Line
    }
}
</code></pre>
",0
26204554,26204277,1,"<p>You have to find a pattern. Say you want a tree with <code>n</code> rows. Last row is going to have <code>2n-1</code> stars. Row before it will have <code>2n-3</code> and so on. To print a row, first you print a number of spaces, then a number of stars. For last row, you print <code>0</code> spaces and <code>2n-1</code> stars. For row before it, you print <code>1</code> space and <code>2n-3</code> stars and so on.</p>

<pre><code>for(int i = 0; i &lt; n; i++)
{   for(int j = i + 1; j &lt; n; j++)
       printf("" "");
    for(int j = 0; j &lt;= 2*i; j++)
       printf(""*"");
    if(i &lt; n - 1) puts("""");
}
</code></pre>
",0
26238585,26238501,7,"<p>ASCII '0' is actually 48 in scalar form, so subtract it out:</p>

<pre><code>resInt[i] = res[i] - '0';
</code></pre>
",1
26239775,26238501,0,"<p>Character literals are of type int in C. You can convert a char type simply by assigning to an int. However, the resulting int values will be ASCII values. So you need to subtract out the ASCII value of char '0' to get the actual value.</p>

<p>resInt[i] = res[i] - '0';</p>
",0
23843316,23842436,1,"<p>You must use either <code>[]</code> or <code>s</code> construct, but not both <strong>and</strong> your format string must incluse the separators.</p>

<p>So you should write something like :</p>

<pre><code>sscanf(str, ""%[^|]|%[^|]|..."",...) 
</code></pre>
",0
23843373,23842436,3,"<p>The syntax is arcane at best ¡ª I'd suggest using a different approach such as <code>strtok()</code>, or parsing with string handling functions <code>strchr()</code> etc.  </p>

<p>However the first thing you must realise is that the <code>%[^&lt;delimiter-list&gt;]</code> format specifier (a 'scan set' in the jargon, documented by POSIX <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/scanf.html"" rel=""nofollow""><code>scanf()</code></a>
amongst many other places) only extracts string fields ¡ª you have to convert the extracted strings to integer if that is what they represent.  </p>

<p>Secondly you still have to include the delimiter as a literal match character outside of the format specifier ¡ª you have separated the format specifiers with commas where <code>|</code> are in the input stream.</p>

<p>Consider the following:</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    char a[32] ;
    char b[32] ;
    char c[32] ;
    char istr[32] ;  // Buffer for string representation of i
    int i ;
    int j ;          // j can be converted directly as it is at the end.

    // Example string
    char str[] = ""fieldA|fieldB|fieldC|15.27"" ;

    int converted = sscanf( str, ""%[^|]|%[^|]|%[^|]|%[^.].%i"", a, b, c, istr, &amp;j ) ;

    // Check istr[] has a field before converting
    if( converted == 5 )
    {
        sscanf( istr, ""%i"", &amp;i) ;
        printf( ""%s, %s %s, %d, %d\n"", a, b, c, i, j ) ;
    }
    else
    {
        printf( ""Fail -  %d fields converted\n"", converted ) ;
    }

    return 0 ;
}
</code></pre>
",1
23843188,23842436,0,"<p>This seems to work...</p>

<pre><code>#include &lt;stdio.h&gt;

main()
{

char x[32] = ""abc|def|123.456."";
char y[20];
char z[20];
int i =0;
int j =0;
sscanf(x,""%[^|]|%[^|]|%d.%d."",y,z,&amp;i,&amp;j);
fprintf(stdout,""1:%s 2:%s 3:%d 4:%d\n"",y,z,i,j);

}
</code></pre>
",0
31895691,31893774,1,"<p>According to the C Standard (5.2.1 Character sets)</p>

<blockquote>
  <ol start=""3"">
  <li>...In both the source and execution basic character sets, <strong>the value of 
  each character after 0 in the above list of decimal digits shall be
  one greater than the value of the previous</strong>.</li>
  </ol>
</blockquote>

<p>Thus expression <code>'9' - '0'</code> has the same value like <code>9 - 0</code> and is equal to 9 whether you are using for example the ASCII table of characters or the EBCDIC.</p>

<p>Expression <code>9 - '0'</code> is implementation defined and depends on the coding table you are using. But in any case the value of the internal representation of character <code>'0'</code> is greater then <code>9</code>. (<code>9</code> is the value of the tab character representation <code>'\t'</code>) </p>

<p>For example in the ASCII the value of the code of character <code>'0'</code> is equal to <code>48</code>.
In the EBCDIC the value of <code>'0'</code> is equal to <code>240</code>.</p>

<p>So you will get that <code>9 - '0'</code> is some negative number. </p>

<p>For example it is equal to <code>-39</code> if the character representations are based on the ASCII table or <code>-231</code> if the character representations are based on the EBCDIC table.</p>

<p>You can see this yourself running this simple program</p>

<pre><code>#include &lt;stdio.h&gt;

int main( void )
{
    printf( ""%d\n"", 9 - '0' );
}
</code></pre>

<p>You could write the printf statement also in the following way;)</p>

<pre><code>printf( ""%d\n"", '\t' - '0' );
</code></pre>

<p>because <code>9</code> as I mentioned is the value of the internal representation of the escape character <code>'\t'</code> (tab).</p>
",0
31893799,31893774,2,"<p>When you do calculations with <code>char</code>s, you have to keep in mind that to <strong>you</strong> it looks like a '0' or '9', but the compiler interprets is as its <a href=""http://www.asciitable.com"" rel=""nofollow"">ASCII</a> value, which is 48 for '0' and 57 for '9'.</p>

<p>So when you do:</p>

<pre><code>int x=9-c1;
</code></pre>

<p>the result is 9 - 48 = -39. And for</p>

<pre><code>int y='9'-c1;
</code></pre>

<p>the result is 57 - 48 = 9.</p>
",8
31893903,31893774,3,"<p>1st <code>char</code> are integers.
2nd <code>char</code>s <em>might</em> have a printable representation or output controlling function (like for ASCII: <code>TAB</code>, <code>CR</code>, <code>LF</code>, <code>FF</code>, <code>BELL</code> ...) depending on the character set in use.</p>

<p>For ASCII</p>

<pre><code>char c = 'A';
</code></pre>

<p>is the same as</p>

<pre><code>char c = 65;
</code></pre>

<p>is the same as</p>

<pre><code>char c = 0x41;
</code></pre>

<p>Another character set widely in use for example is <a href=""https://en.wikipedia.org/wiki/EBCDIC"" rel=""nofollow"">EBCDIC</a>. It uses a different mapping of a character's integer value to its printable/controling representation.</p>

<p>Internally always the <em>same</em> integer value is used/stored. </p>

<p>The printable, often but not always <a href=""https://en.wikipedia.org/wiki/ASCII"" rel=""nofollow"">ASCII</a> representation of, for example <code>65</code> or <code>0x41</code>, which is <code>A</code>, is only used when </p>

<ol>
<li>either printing out using the <code>printf()</code>-family along with the <strong><em>conversion</strong> specifiers</em> <code>%s</code> or <code>%c</code> or <code>puts()</code></li>
<li>or scanning in using the <code>scanf()</code>-family along with the <strong><em>conversion</strong> specifiers</em> <code>%s</code> or <code>%c</code> or <code>fgets()</code></li>
<li>or when coding literals like <code>'A'</code> or <code>""ABC""</code>.</li>
</ol>

<p>On all other operation only the <code>char</code>'s integer value is used.</p>
",0
31894046,31893774,4,"<p>Here is a good explanation. Just compile it and run:</p>

<pre><code>#include &lt;stdio.h&gt;
int main(){
    int c;
    char c1='0';
    int x=9-c1;
    int y='9'-c1;
    printf(""--Code and Explanation--\n"");
    printf(""int c;\n"");
    printf(""char c1='0';\n"");
    printf(""int x=9-c1;\n"");
    printf(""int y='9'-c1;\n"");
    printf(""c1 as char '0' has decimal value: %d\n"", c1);
    printf(""decimal 9 - decimal %d or c1 = %d or x\n"", c1, x);
    printf(""char '9' has decimal value %d - decimal %d or c1 = %d\n"", '9', c1, y);
    printf(""Your Welcome :)\n"");
    return 0;
}
</code></pre>
",3
26425150,26424852,2,"<p>The problem is that <code>_filelength</code> is a Windows-only function.</p>

<p>In Linux/Mac you can use <code>stat</code> for solving the task:</p>

<pre><code>#include &lt;sys/stat.h&gt;

long file_length(char *f)
{
    struct stat st;
    stat(f, &amp;st);
    return st.st_size;
}
</code></pre>

<p>On changing file size. Function <code>chsize</code> is also not a Linux one, but you can use <a href=""http://linux.die.net/man/2/ftruncate"" rel=""nofollow""><code>ftruncate</code></a> to do the job.</p>
",0
25676690,25676530,5,"<p>Using <code>%p</code> with something that's not <code>void *</code> causes undefined behaviour. Often we can gloss over that point, but it's actually relevant here, so that line should be:</p>

<pre><code>printf(""%p %p %p %p"", (void *)a[1], (void *)(a+1), (void *)&amp;a[1] , (void *)&amp;a[1][0]); 
</code></pre>

<p>Moving onto <code>a[1]== a+1== &amp;a[1] == &amp;a[1][0]</code>. I'm sure you recall that <code>==</code> is a binary operator (i.e. takes exactly two arguments), which evaluates to either <code>0</code> or <code>1</code>, and is left-associative. So this expression is:</p>

<pre><code>((a[1] == a+1)== &amp;a[1]) == &amp;a[1][0]
</code></pre>

<p>Now, <code>a[1] == a+1</code> is <code>1</code> since those are alternative syntax for the same thing. So now we move onto evaluating <code>1 == &amp;a[1]</code>.  Since <code>1</code> is an <code>int</code> and <code>&amp;a[1]</code> is a pointer, this comparison is ill-formed.</p>

<p>In general, if your intent is to check that four items are all equal you need to write <code>if ( A == B &amp;&amp; A == C &amp;&amp; A == D )</code> or equivalent.</p>

<p>However, <code>if ( a[1] == &amp;a[1] )</code> is also a constraint violation. To compare two pointers, it only works if they are both the same type (implicit conversions may be done here). However there is no implicit conversion from <code>int *</code> to <code>int (*)[3]</code> or vice versa.  To attempt this comparison you must cast at least one of the operands. One option is to cast both to <code>void *</code> as this is always legal and it must point to the first byte of whatever the operand was pointing to:</p>

<pre><code>if ( (void *)a[1] == (void *)&amp;a[1] )
</code></pre>

<p>So to summarize, your code could better be written as:</p>

<pre><code>void *p = a[1];
void *q = a + 1;
void *r = &amp;a[1];
void *s = &amp;a[1][0];

printf(""%p %p %p %p\n"", p, q, r, s);

if ( p == q &amp;&amp; p == r &amp;&amp; p == s )
    printf(""All are same address\n"");
</code></pre>
",2
30157440,30157375,1,"<p>Some problems :</p>

<ul>
<li>you never set checker to 0 (only point), so after first error all inputs will be rejected</li>
<li>fgets gives you the <code>\n</code> : you should ignore it and initial and terminal white spaces (<code>' '</code>, <code>\r</code>, <code>\t</code>, <code>\f</code>, at least the 2 first)</li>
<li>fflush on an input stream is non standard and as you use fgets is useless</li>
<li><code>c[strlen(c)-1] = '\0';</code> has no sense : you try to put a null to terminate the array, but strlen only gives the position of the first null which is undifined behavious on an unitialized array (thanks to WhozCraig for noticing it) : you could do <code>c[0] = '\0';</code>, or <code>c[sizeof(c) - 1] = '\0';</code> but here again it is useless</li>
</ul>

<p>I did not try to run it, so I do not know if there are still others ...</p>
",1
30157489,30157375,1,"<p>You should use <code>strtod</code> or related functions <code>strtof</code>:</p>

<pre><code>#include&lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
    double d;
    char c[25];
    char * converted;
    for(;;){
        printf(""\nEnter The Process's Burst Time &gt; 0 : "");
        fgets(c, 21, stdin); //Max input is 20.                                                                                     
        d = strtod(c,&amp;converted);
        if (converted == c){
            printf(""Conversion unsuccesful"");
        }
        else {
            printf(""Converted value: %f"",d);
        }
    }
}
</code></pre>

<p>Quoting from the man page:</p>

<blockquote>
<pre><code>   double strtod(const char *nptr, char **endptr);
</code></pre>
  
  <p>If endptr is not NULL, a pointer to the character after the last
  character used in the conversion is stored in the location referenced
  by endptr.</p>
  
  <p>If no conversion is performed, zero is returned and the value of nptr
  is stored in the location referenced by endptr.</p>
</blockquote>

<p>Also I would use <code>getline</code> rather than <code>gets</code> to avoid problems in case the input stream is too big.</p>
",0
29951051,29950949,3,"<blockquote>
<pre><code>  struct Node *pNode=NULL;
  pNode-&gt;m_freq=freq;
</code></pre>
</blockquote>

<p>One of the reasons is dereferencing the NULL pointer in the quoted code block above.</p>

<p>Memory must be allocated before using the pointer. Like this:</p>

<pre><code>struct Node *pNode = malloc (sizeof *pNode);
</code></pre>
",1
26436227,26436220,-1,"<p>You are capturing the \n character at the end of the line.</p>
",3
26436403,26436220,3,"<p>It's likely that you have a blank line at the end of your file, resulting in <code>pch</code> being NULL. Your program should deal with lines that don't contain commas.</p>
",3
25693757,25693492,0,"<p>I not give you the algorithm because it's seems that you are learning how to program and it is important to you to learn to discover how to  solve the problems that are given to you.But I can give you some hints:</p>

<ul>
<li>use binaryString only to compare with '0' or '1'. Don't try to make any operations like '%' on it.</li>
<li>iterate on the binaryString character by character (no <code>while</code> inside <code>for</code> [this is only for this case, there some algorithm that is necessary to do something like this])</li>
<li>your logic to convert is on the right track</li>
</ul>

<p>Also you should call your main function <code>main</code>.</p>
",3
26445939,26445923,2,"<p>you need to copy the 0 too,  do <code>s1[i] = 0</code>  before returning.</p>

<p>or do it </p>

<pre><code>    int i=0;    //initializes element counter at 0 for first element
    do
    {
        s1[i] = s2[i];      //copies the i-th element of string1 to the corresponding element of string2
        i++;            //increments element counter
    } while(s2[i] != '\0')    //loops until null is reached
    return s1;
</code></pre>
",0
26445991,26445923,3,"<p>When the test <code>s2[i] != '\0'</code> fails you're not entering the cycle, that means that you ignore the string terminator <code>'\0'</code>.</p>

<p>So you need to do <code>s1[i]='\0'</code>after the cycle to ensure the termination of string <code>s1</code>. And then you could return your copied string.</p>
",1
28470567,28470516,0,"<p>You may refer <a href=""http://www.keil.com/forum/3909/conversion-of-integer-to-ascii-for-display/"" rel=""nofollow"">this</a></p>

<pre><code>void UlToStr(char *s, unsigned long bin, unsigned char n)
{
    s += n;
    *s = '\0';

    while (n--)
    {
        *--s = (bin % 10) + '0';
        bin /= 10;
    }
}
</code></pre>
",5
26209512,26209360,2,"<pre><code>#include &lt;stdio.h&gt;

int main(){
    FILE *fp = fopen(""data.txt"", ""r"");
    char data_name[16];
    char data_string[32];

    while(2==fscanf(fp, ""%15s \""%31[^\""]\"""", data_name, data_string)){
        printf(""%s, %s\n"", data_name, data_string);
    }
    fclose(fp);
    return 0;
}
</code></pre>
",2
26431303,26431165,2,"<p>In the future, please enable warnings on your compiler. For example for GCC, this would be <code>-Wall</code>. </p>

<pre><code>main.cpp:7:29: warning: array subscript is above array bounds [-Warray-bounds]
         printf(""%d\n"",arr[5]); //here output: 2130567168
                             ^
main.cpp:8:30: warning: array subscript is above array bounds [-Warray-bounds]
         printf(""%d\n"",arr2[5]); //here output: 0
</code></pre>

<p>Note that the C standard says this is undefined behavior: </p>

<p>¡ìJ.2</p>

<blockquote>
  <p>1 The behavior is undefined in the following circumstances:</p>
  
  <p>¡ª An array subscript is out of range, even if an object is apparently
  accessible with the given subscript (as in the lvalue expression
  a[1][7] given the declaration int a[4][5]) (6.5.6).</p>
</blockquote>

<p>Receive your usual lecture about <a href=""http://c2.com/cgi/wiki?UndefinedBehavior"" rel=""nofollow"">undefined behavior</a>.</p>
",1
26431202,26431165,2,"<p>You are acessing data which is outside of the declared range. The index range of your array which has been declared as <code>arr[5]</code>, goes from 0...4, but you want to access arr[5], which is neither defined nor allocated. Thus you get random answers depending on the value of the memory ""cell"" you want to access, in this case 0 and the other number.</p>
",4
26431204,26431165,3,"<p>Both <code>printf</code>s produce undefined behavior, because they are accessing elements past the end of their corresponding arrays. The valid range for indexes of C arrays is zero through <code>length-1</code>, so for both arrays in your program that would be 0..4, inclusive.</p>

<p>Accessing element at index 5 is past the end of the array, so different compilers can produce different behavior, ranging from printing garbage to crashing.</p>
",1
26431227,26431165,2,"<p>This is <strong>undefined behavior</strong>. C does not perform <a href=""http://en.wikipedia.org/wiki/Bounds_checking"" rel=""nofollow"">bound checking</a> on array.</p>
",0
26431274,26431165,0,"<p>The behavior of this code in C is described in section 6.7.8.21 of the C specification (<a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf"" rel=""nofollow"">Online draft for c specs</a>): for the elements that don't have a specified value, the compiler initializes pointers to NULL and arithmetic types to zero (and recursively applies this to aggregates).</p>

<p>Please refer the above document to know . also i am not posting answer directly here as You are newbie as i don't wanna spoon -feed you. Happy Learning. . </p>
",0
25702256,25702185,4,"<p>There is a function called <a href=""https://www.gnu.org/software/libc/manual/html_node/Sleeping.html"" rel=""nofollow"">sleep</a> for a delay in seconds.<br>
Another function called <a href=""https://www.gnu.org/software/libc/manual/html_node/Sleeping.html"" rel=""nofollow"">nanosleep</a> for intervals specified in nanoseconds.</p>
",1
26159971,26159934,4,"<p>It's evaluated left to right. You could have written: (x &lt; y) &lt; z and (z > x) > y.</p>

<p>(x &lt; y) evaluates to 0 or 1, if false or true. This is then compared to the value of z.</p>

<p>To get what you want, you should write:</p>

<p>if ((x > y) &amp;&amp; (y > z))</p>

<p>and</p>

<p>if  ((z &lt; y) &amp;&amp; (y &lt; x))</p>
",0
26213672,26213671,11,"<p>Eventually the C function <code>printf</code> will result in a <code>sys_write</code> system call, directly or by going through <code>write</code> (see <code>man 2 write</code>). The actual implementation depends on the compiler and the standard libraries.</p>
",0
26213673,26213671,0,"<p><code>library ncurses</code> can help you, but if you want to use a low level function use <code>write()</code> and if you want to do kernel programming you have to use <code>printk()</code></p>
",1
26213881,26213671,2,"<p>Printing to screen requires access to framebuffer (hardware) and userspace programs are not allowed to have a direct access to it. So what they do is make a system call and kernel performs the required function for them. <code>printf</code> -> <code>write</code> system call -> kernel writes the data into framebuffer and then control is given back to user program.
Even if you don't want to use <code>printf</code> or <code>puts</code> (they are implemented in hosted libc) still you have to use write system call to tell the kernel on which device you want to write the buffer.</p>
",0
26215651,26213671,1,"<p>The standard headers are not, necessarily, a library containing functions written in C code.<br>
They are functions with C ""interfase"", however it's very probably that they contain explicit machine code, adapted, in each case, to the target system.<br>
The standard headers provide, in this way, ways of doing special process that it would not be possible to achieve in strict C code.  </p>

<p>In the specific case of <code>printf()</code>, the situation is even more clear, because if none header is <code>#include-d</code>, then there is not any mechanism through the use of the C syntax only that performs an Input/Output operation.  </p>
",0
26226290,26226199,0,"<p>this should definitely work</p>

<pre><code>    #include&lt;stdio.h&gt;
int main()
{

int choice;
printf(""Enter 1 for Programmers Name and ID\n"");
printf(""Enter 2 to Perform Integer Operation\n"");
printf(""Enter 3 to Perform Floating Point Operation\n"");
scanf(""%d"", &amp;choice);
getchar();
if (choice == 1)

    printf(""Connor \n000000000\n"");


else if (choice == 2)


{
    char c;
    int num1, num2;
    printf(""Enter operator:"");
    scanf(""%c"", &amp;c);
    printf(""Enter two integer's :"");
    scanf(""%d %d"", &amp;num1, &amp;num2);
    switch (c)
    {

    case '+':
        printf(""%d + %d = %d"", num1, num2, num1 + num2);
        break;
    case '-':
        printf(""%d - %d = %d"", num1, num2, num1 - num2);
        break;
    case '*':
        printf(""%d * %d = %d"", num1, num2, num1*num2);
        break;
    case '/':
        printf(""%d / %d = %d"", num1, num2, num1 / num2);
        break;

    default:
        printf(""The value of c = '%c'\n"" , c);
        return(0);
    }

}
else if (choice == 3)
    printf(""Enter two \n"");

}
</code></pre>
",5
26227179,26226199,-1,"<ol>
<li><p>Change:</p>

<pre><code>scanf(""%c"", &amp;c);
getchar();
</code></pre>

<p>to:</p>

<pre><code>scanf("" %c"", &amp;c);
</code></pre></li>
<li><p>Add an <code>\n</code> to each of these:</p>

<pre><code>printf(""%d + %d = %d\n"", num1, num2, num1 + num2);
                    ^^
</code></pre></li>
<li><p>Actually provide a <code>char</code> when you tell <code>printf()</code> to print one:</p>

<pre><code>printf(""The value of c = '%c'\n"", c);
                                ^^^
</code></pre></li>
</ol>

<p>and it should work for you. Revised code, removing all the <code>system()</code> nonsense:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    int choice;

    printf(""Enter 1 for Programmers Name and ID\n"");
    printf(""Enter 2 to Perform Integer Operation\n"");
    printf(""Enter 3 to Perform Floating Point Operation\n"");
    scanf(""%d"", &amp;choice);

    if ( choice == 1 ) {
        printf(""Connor \n000000000\n"");
    }
    else if ( choice == 2 ) {
        char c;
        int num1, num2;

        printf(""Enter operator:"");
        scanf("" %c"", &amp;c);

        printf(""Enter two integers :"");
        scanf(""%d %d"", &amp;num1, &amp;num2);

        switch ( c ) {

        case '+':
            printf(""%d + %d = %d\n"", num1, num2, num1 + num2);
            break;
        case '-':
            printf(""%d - %d = %d\n"", num1, num2, num1 - num2);
            break;
        case '*':
            printf(""%d * %d = %d\n"", num1, num2, num1 * num2);
            break;
        case '/':
            printf(""%d / %d = %d\n"", num1, num2, num1 / num2);
            break;
        default:
            printf(""The value of c = '%c'\n"", c);
            break;
        }
    } else if ( choice == 3 ) {
        printf(""Enter two \n"");
    }
    else {
        printf(""Invalid choice.\n"");
    }

    return 0;
}
</code></pre>

<p>with sample output:</p>

<pre><code>paul@thoth:~/src/sandbox$ ./cal
Enter 1 for Programmers Name and ID
Enter 2 to Perform Integer Operation
Enter 3 to Perform Floating Point Operation
2
Enter operator:*
Enter two integers :4 6
4 * 6 = 24
paul@thoth:~/src/sandbox$ 
</code></pre>
",2
27160601,27160456,-1,"<pre><code>// the code you wrote has a few flaws
// rather than trying to list the flaws
// I just provide a simplistic/brute force example to accomplish the function

void four_stars(char *start)
{
    start[0] = '*';
    start[1] = '*';
    start[2] = '*';
    start[3] = '*';
}
</code></pre>
",2
27161030,27160456,0,"<p>If you have <code>char *word = ""Word""</code> then it is not possible to modify <code>""Word""</code>. This is because, in C and C++, string literals are not modifiable. You have to start with a string which is in a writable memory area, e.g.:</p>

<pre><code>char word[] = ""Word"";
</code></pre>

<p>or</p>

<pre><code>char *word = malloc(5);
strcpy(word, ""Word"");
</code></pre>

<p>Then your function would work (if you change <code>start = '*';</code> to <code>*start = '*';</code>).</p>
",2
33573772,33573738,3,"<p>You could pass the addresses of the variables you want to assign a value to:</p>

<pre><code>int generator(int* first, int* second, int* third) {
    int one, two, three;

    /* Initialize local variables here. */

    *first = one;
    *second = two;
    *third = three;

    return something;
}

int main(void) {
    int first, second, third;
    generator(&amp;first, &amp;second, &amp;third);
}
</code></pre>

<p>Another way would be to create a <code>struct</code> and return that <code>struct</code>:</p>

<pre><code>struct data {
    int one, two, three;
};
</code></pre>

<p>and return it:</p>

<pre><code>struct data generator() {
    int one, two, three;

     /* Initialize local variables here. */

    return (struct data) { one, two, three };
}
</code></pre>

<p>or fill it in via a function parameter<sup>1</sup>, in analogy to the first method:</p>

<pre><code>void generator(struct data* d) {
    int one, two, three;

    /* Fill one, two, and three here. */

    d-&gt;one = one;
    d-&gt;two = two;
    d-&gt;three = three;
}
</code></pre>

<hr>

<p><sub><sup>1</sup> as proposed by @CraigEstey in the comments to this answer</sub></p>
",1
26451774,26451209,-2,"<p>My code is pretty ""manual"" meaning that I don't use stuff like <code>strtok</code> or <code>tolower</code>. I manually loop through everything myself. If you don't like that, just replace the corresponding parts with those functions. Here you go:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define _WLEN   32  // maximum length of each word
#define _NWORDS 256 // maximum number of words in the sentence

void word_swap(char** w1, char** w2);

int main(int argc, const char * argv[]) {
    char* sentence      = ""The quick brown fox jumps over the lazy dog.""; // the sentence

    char to_ignore[10]  = "".,-\""'!?()"";             // characters that are ignored
    char words[_NWORDS][_WLEN];                     // words will be stored here
    int i, j, k=0, l=0, word_count, swapped=0;      // some variables that will be needed

    /* First we loop through the sentence to separate the words */
    for (i=0; i&lt;_NWORDS*_WLEN; i++) {
        /* If we reach the end of the sentence, finish up the last word with '\0' and quit the loop */
        if (*(sentence+i) == '\0') {
            words[k][l] = '\0';
            word_count = k+1;
            break;
        }
        /* Check if the current character is one that we want to ignore. If so, skip to the next character. */
        for (j=0; j&lt;10; j++) {
            if (to_ignore[j] == *(sentence+i)) goto END_FOR;
        }
        /* If the current character is not a space, add it to a word */
        if (*(sentence+i) != ' ') {
            words[k][l] = *(sentence+i);
            l++;
        }
        /* ... if it is a space, finish the current word with '\0' and move to the next word */
        else {
            words[k][l] = '\0';
            k++;
            l=0;
        }
    END_FOR:;
    }

    /* Convert everything to lowercase so it's easy to sort the words */
    for (i=0; i&lt;word_count; i++) {
        for (j=0; j&lt;_WLEN; j++) {
            if (words[i][j] == '\0') break;
            /* If the letter is uppercase (ASCII codes 65-90) then add 32 to it, which is the lowercase variant */
            if (words[i][j] &gt;= 65 &amp;&amp; words[i][j] &lt;= 90) words[i][j] += 32;
        }
    }

    /* Bubble sort the words in alphabetical order */
    do {
        for (i=0; i&lt;word_count-1; i++) {
            if (strcmp(words[i], words[i+1]) &gt; 0) {
                word_swap(&amp;words[i], &amp;words[i+1]);
                swapped = 1;
                break;
            } else swapped = 0;
        }
    } while (swapped != 0);

    /* Print the words on the screen */
    for (i=0; i&lt;word_count; i++) printf(""%s\n"", words[i]);
}

void word_swap(char** w1, char** w2) {
    char tmp[_WLEN];
    memcpy(&amp;tmp, w1, _WLEN);
    memcpy(w1, w2, _WLEN);
    memcpy(w2, &amp;tmp, _WLEN);
}
</code></pre>
",4
33526703,33526269,1,"<p><strong>Bitwise AND to the Rescue!</strong></p>

<p>So, doing what you require can be done using the bitwise AND opperator on the resulting 32bit number (<code>int</code>?) you get from <code>sscanf</code>.</p>

<p>You first get the number from the string:</p>

<pre><code>char* hexstring = ""0x08fc0021"";
int num = 0;
sscanf(hexstring, ""%x"", &amp;num); //put the number into num.
</code></pre>

<p>Then you get the bits you want using <code>&amp;</code>:</p>

<pre><code>int varA=0, varB=0;
varA = num &amp; 0xFFFF; //will get the second half.
varB = num &amp; 0xFFFF0000; 
varB = varB &gt;&gt; 16; // now you have the first half as well.
</code></pre>

<p>And there you have it.</p>
",0
33526946,33526269,1,"<pre><code>int main(int argc, char *argv[]) {

    char *hexstring = ""08fc0021"";
    unsigned long hexnumber = 0u;
    unsigned short a = 0u;
    unsigned short b = 0u;

    /* Use sscanf() to convert the string to integer */
    sscanf(hexstring, ""%x"", &amp;hexnumber);

    /* Use bitwise and to filter out the two higher bytes *
     * and shift it 16 bits right                         */
    a = ((hexnumber &amp; 0xFFFF0000u) &gt;&gt; 16u);

    /* Use bitwise AND to filter out the two lower bytes */
    b = (hexnumber &amp; 0x0000FFFFu);

    printf(""0x%X 0x%X\n"",a,b);

    return 0;
}
</code></pre>
",0
33526952,33526269,1,"<p>You can use this approach (bit operations):</p>

<pre><code>char *hexstring = ""08fc0021"";

int aux; 
sscanf(hexstring, ""%x"", &amp;aux);
printf(""aux = 0x%x = %d\n"", aux, aux);

int varA = (aux &amp; 0xFFFF0000) &gt;&gt; 16, varB = aux &amp; 0x0000FFFF;
printf(""varA = 0x%x = %d\n"", varA, varA);
printf(""varB = 0x%x = %d\n"", varB, varB);
</code></pre>

<p>Result:</p>

<blockquote>
  <p>aux = 0x8fc0021 = 150732833<br>
  varA = 0x8fc = 2300<br>
  varB = 0x21 = 33</p>
</blockquote>

<p><strong>EDIT:</strong><br>
Or this approach (string manipulation):</p>

<pre><code>// requires a hexstring length of 8 or more sophisticated logic
char *hexstring = ""08fc0021"";
int len = strlen(hexstring);

char varA[5], varB[5];
for(int i = 0; i&lt;len; i++)
{
    if(i &lt; 4) varA[i] = hexstring[i];
    else varB[i-4] = hexstring[i];
}

varA[4] = varB[4] = '\0';

int varAi, varBi;
sscanf(varA, ""%x"", &amp;varAi);
sscanf(varB, ""%x"", &amp;varBi);

printf(""varAi = 0x%x = %d\n"", varAi, varAi);
printf(""varBi = 0x%x = %d\n"", varBi, varBi);
</code></pre>

<p>Same result:  </p>

<blockquote>
  <p>varAi = 0x8fc = 2300<br>
  varBi = 0x21 = 33</p>
</blockquote>
",0
32403076,32402883,8,"<p>Your function <a href=""http://coliru.stacked-crooked.com/a/eb89de7a8e5761f3"">works just fine</a>. The only problem is that your two character arrays are not initialized and that causes Undefined Behavior.</p>
",4
32412214,32402883,0,"<p>here is one implementation, using the command line parameters.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int comp(char str1[], char str2[])
{
    int i = 0;
    while (str1[i] == str2[i])
    {
        if (str1[i] == '\0' || str2[i] == '\0')
            break;
        i++;
    }

    if (str1[i] == '\0' &amp;&amp; str2[i] == '\0')
        return 0;
    else
        return -1;
}


int main(int argc, char * * argv)
{
    if( 3 != argc )
    {
        printf( ""USAGE: %s, firstString secondString\n"", argv[0]);
        exit(EXIT_FAILURE);
    }

    // implied else, correct number of parameters

    if ( !comp( argv[1], argv[2]) )
        printf(""The two strings are identical.\n"");
    else
        printf(""The two strings are different.\n"");
    return 0;
}
</code></pre>
",0
27571357,27568449,1,"<p>This illustrates how a big-endian value is written on my little-endian machine. More explanation: the <code>&amp;0xff</code> part masks off all except the least signifcant 8 bits of the shifted value, although as I am unsure whether that or the <code>(unsigned char)</code> are strictly necessary, I included a macro <code>n2n()</code> without them as a comparison. Without them, I get no compiler warning and no error.</p>

<p>Also I have omitted the <code>L</code> discussed in comments above. Note too that the pointer used must be an <code>unsigned char</code> type - if it was an <code>unsigned int</code> type, <code>c</code> would be incremented by 4 (32-bit architecture). That's why I have used a <code>union</code> to overlay the bytes.</p>

<p>The macro definition must have no space between its identifier and the first bracket. And finally if there seem to be more brackets than necessary in the macros, it is to ensure that any expression is correctly compiled, for example <code>l2n(a+b,c);</code></p>

<pre><code>#include &lt;stdio.h&gt;

#define l2n(l,c) (*((c)++)=(unsigned char)(((l)&gt;&gt;24)&amp;0xff), \
                  *((c)++)=(unsigned char)(((l)&gt;&gt;16)&amp;0xff), \
                  *((c)++)=(unsigned char)(((l)&gt;&gt; 8)&amp;0xff), \
                  *((c)++)=(unsigned char)(((l)    )&amp;0xff))

#define n2n(l,c) (*((c)++)=(l)&gt;&gt;24, \
                  *((c)++)=(l)&gt;&gt;16, \
                  *((c)++)=(l)&gt;&gt; 8, \
                  *((c)++)=(l)    )
typedef union {
    unsigned num;
    unsigned char arr[4];
    } bigend;

int main (void)
{
    bigend number;
    unsigned x;
    char *p;

    // test first macro
    x = 0x12345678;
    p = number.arr;
    printf (""Input  %08X\n"", x);
    l2n(x,p);
    printf (""Output %08X\n\n"", number.num);

    // test second macro
    x = 0x89ABCDEF;
    p = number.arr;
    printf (""Input  %08X\n"", x);
    n2n(x,p);
    printf (""Output %08X\n\n"", number.num);
    return 0;
}
</code></pre>

<p>Program output:</p>

<pre><code>Input  12345678
Output 78563412

Input  89ABCDEF
Output EFCDAB89
</code></pre>
",0
26778681,26770032,1,"<p>This uses fscanf to read from a file. It prompts for each type of word and prints the final text to an output file.  You can supply the filenames as part of the command line as in <code>program inputfile outputfile</code>. If file names are not in the command line, default file names of <code>madlib.txt</code> will be used for the input file and <code>madlib-out.txt</code> will be used for the output file.</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;

int main( int argc, char *argv[]) {
    FILE *fpIn = NULL;
    FILE *fpOut = NULL;
    char cFileIn[100] = { 0};
    char cFileOut[100] = { 0};
    char cIn[500] = { 0};
    char cType[100] = { 0};
    char cWord[100] = { 0};
    char cCh[2] = { 0};
    char *pDash = NULL;

    if ( argc == 3) { // use command line arguments if present
        strcpy ( cFileIn, argv[1]);
        strcpy ( cFileOut, argv[2]);
    }
    else { // default file names
        strcpy ( cFileIn, ""madlib.txt"");
        strcpy ( cFileOut, ""madlib-out.txt"");
    }


    fpIn = fopen ( cFileIn, ""r"");
    if ( fpIn == NULL) {
        printf ( ""could not open input file %s\n"", cFileIn);
        return 1; // fopen failed
    }

    fpOut = fopen ( cFileOut, ""w"");
    if ( fpOut == NULL) {
        fclose ( fpIn); // close the input file
        printf ( ""could not open output file %s\n"", cFileOut);
        return 1; // fopen failed
    }

    // scan up to 499 characters stopping at &lt;
    while ( fscanf ( fpIn, ""%499[^&lt;]"", cIn) == 1) {
        // scan one character, should be the &lt;
        if ( ( fscanf ( fpIn, ""%1s"", cCh)) == 1) {
            if ( cCh[0] == '&lt;') {
                fprintf ( fpOut, ""%s"", cIn); // print to the output file
                // scan the type of word needed
                if ( ( fscanf ( fpIn, ""%99[^&gt;]"", cType)) == 1) {
                    if ( ( pDash = strstr ( cType, ""-""))) {
                        *pDash = ' '; // remove - if present
                    }
                    // for each type, prompt and scan
                    printf ( ""Enter a(n) %s\n"", cType);
                    // skip whitespace then scan up to 99 characters stopping at newline
                    scanf ( "" %99[^\n]"", cWord);
                    fprintf ( fpOut, ""%s"", cWord); // print to the output file
                }
                if ( ( fscanf ( fpIn, ""%1[&gt;]"", cCh)) == 1) {
                    ; // scan the &gt;
                }
            }
        }
    }

    fclose ( fpIn); // close files
    fclose ( fpOut);
    return 0;
}
</code></pre>
",2
26790921,26770032,0,"<p>And since there are real answers already, just a quick additional one to point out that if you have a choice, you could do it more easily if you didn't use C.  Python would make it trivial...</p>

<pre><code>infile = open(""input_file.txt"", ""r"")
template = infile.read()
infile.close()

questions = [ [""What is your name? "", ""[name]""],
              [""How old are you? "", ""[age]""],
              [""Which country are you from? "", ""[country]""],
              [""What is your favourite food? "", ""[favourite food]"" ] ]

for q in questions:
    template = template.replace(q[1], input(q[0]))

outfile = open(""output_file.txt"", ""w"")
outfile.write(template)
outfile.close
</code></pre>

<p>But maybe you have no choice.              </p>
",0
26790612,26770032,0,"<p>This is an alternative answer which just does find and replace (because writing a parser which does not break on dodgy input is <em>hard</em>).</p>

<p>It reads in values from the user, uses the <code>strstr</code> function to find the relevant tag in the text and substitutes the user value (repeatedly if the tag appears more than once).  The substitution involves:</p>

<ol>
<li>Keeping everything before the tag.</li>
<li>Copying what is after the tag to another string.</li>
<li>Inserting the user value.</li>
<li>Copying back the contents of the other string.</li>
</ol>

<p>Code... </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define BUFSIZE 65535
#define MAXSTR 100 

int main(int argc, char ** argv) {

    char string_dict[4][3][MAXSTR]  = 
         { {""What is your name? "", ""[name]"", """"},
           {""What country do you live in? "", ""[country]"", """"},
           {""What is your age? "", ""[age]"", """"},
           {""What is your favourite food?"", ""[favourite food]"", """"} };
    int arr_len = sizeof(string_dict)/sizeof(*string_dict);

    char buf1[BUFSIZE];
    char buf2[BUFSIZE];
    char currtag[MAXSTR];
    char *pos = buf1;
    FILE *fd;
    int i;  

    buf2[0] = '\0';

    fd = fopen(""input_file.txt"", ""r"");
    fread(buf1, BUFSIZE-1, 1, fd); 
    fclose(fd);

    for (i = 0; i &lt; arr_len; i++) {
        printf(""%s"", string_dict[i][0]);
        fgets(string_dict[i][2], MAXSTR, stdin);
        string_dict[i][2][strlen(string_dict[i][2])-1] = '\0';
        while (pos = strstr(buf1, string_dict[i][1])) {
            *pos = '\0';
            strcat(buf2, pos + strlen(string_dict[i][1]));
            strcat(pos, string_dict[i][2]);
            pos += strlen(string_dict[i][2]);
            strcat(pos, buf2);
            pos = buf1; 
            buf2[0] = '\0';
        }

    } 

    fd = fopen(""output_file.txt"", ""w"");
    fputs(buf1, fd);
    fclose(fd);
}
</code></pre>

<p>This is pretty robust, but certainly not foolproof.  Question: what happens if you enter the string <code>[name]</code> when prompted for your name?  Also, you can exceed the input buffer pretty easily.</p>

<p><code>input_file.txt</code> looks like:</p>

<pre><code>My name is [name], and I am [age] years old.  
I live in [country] and my favourite nosh 
is [favourite food].
</code></pre>
",0
26413579,26413565,0,"<p>It is undefined and can be evaluated in any order.</p>
",3
26816012,26815982,3,"<p>Well, the ""proper"" answer here is simple: Never use <code>gets</code>. It's that simple. It has even been removed from C11 standard.</p>

<p>The reason is, you have no way to limit amount of input, so no matter how big buffer you reserve, user can still generate enough input to cause buffer overflow.</p>

<p>You should probably use <code>fgets</code>, if you are writing standard C. You should use <code>getline</code> if you use <em>gcc</em> (like MinGW or Cygwin under Window), or any modern Unix-like OS with support for recent enough POSIX standard.</p>

<hr>

<p>Then to actual question, ignoring problems with <code>gets</code>. Problem is, <code>scanf</code> leaves rest of the line including the enter press into the input stream. One robust solution is to write a function, which will read input until next newline, something like this untested function:</p>

<pre><code>// this function reads given file until newline or end of file or error,
// and returns last value read
int eatLine(FILE *fp) {
    for(;;) {
        int ch = getc(fp);
        if (ch == '\n' || ch &lt; 0) return ch;
    }
}
</code></pre>

<p>Usage:</p>

<pre><code>if (scanf(""%d"", &amp;myint) != 1) exit(0); // exit on invalid input
if (eatLine(stdin) &lt; 0) exit(0); // read and ignore rest of the line, exit on eof
</code></pre>

<hr>

<p>There are other solutions, such as reading a line to buffer and using <code>sscanf</code> on it, above is just one easy possibility.</p>
",2
26816226,26815982,0,"<p>Try replacing <code>scanf(""%d"", &amp;val)</code> with <code>scanf(""%d%*c"", &amp;val)</code>.</p>

<p>The <a href=""http://linux.die.net/man/3/scanf"" rel=""nofollow"">man page</a> says that for <code>%c</code>:</p>

<blockquote>
  <p>The usual skip of leading white space is suppressed.</p>
</blockquote>

<p><code>%c</code> therefore matches up the newline after the value and leaves the buffer empty.  </p>

<p>That way, when you come to the <code>fun()</code> routine, <code>gets</code> waits for input.</p>

<p>The <code>*</code> in <code>%*c</code> means you don't need to store the character in a variable (kudos to @CoolGuy for pointing this out).</p>
",3
26140510,26140237,1,"<p>DevSolar's sprintf solution is good and easy. But I've come up with more optimized, hack version.</p>

<pre><code>void convert_hex_4b_to_string(char buf[9], int ar[4])
{
    static const char tbl[] = ""0123456789ABCDEF"";
    buf[0] = tbl[((unsigned)ar[0] &gt;&gt; 4) &amp; 0x0f];
    buf[1] = tbl[((unsigned)ar[0]) &amp; 0x0f];
    buf[2] = tbl[((unsigned)ar[1] &gt;&gt; 4) &amp; 0x0f];
    buf[3] = tbl[((unsigned)ar[1]) &amp; 0x0f];
    buf[4] = tbl[((unsigned)ar[2] &gt;&gt; 4) &amp; 0x0f];
    buf[5] = tbl[((unsigned)ar[2]) &amp; 0x0f];
    buf[6] = tbl[((unsigned)ar[3] &gt;&gt; 4) &amp; 0x0f];
    buf[7] = tbl[((unsigned)ar[3]) &amp; 0x0f];
    buf[8] = '\0';
}
</code></pre>

<p>... under assumption that all integers are less than 0x100.</p>

<p><a href=""http://ideone.com/xNFM4s"" rel=""nofollow"">(live example)</a></p>
",0
26160462,26160153,0,"<p>you can use <pre><code>char *getcwd(char *buf, size_t size);</pre></code> to get the current work directory. With <code>strncpy</code>, you can get the full path of these files.</p>
",0
27516758,27516408,2,"<p>You need to add a newline character at the end of the format string this way</p>

<pre><code>fprintf(FPC, ""%f \t %f \t %f \t %f \t\n"",&amp;TempData[i].Year, &amp;TempData[i].Month, &amp;TempData[i].Day, &amp;TempData[i].Mean);
                                  /*  ^ this character is newline.
</code></pre>

<p>And since your <code>Year</code>, <code>Month</code> and <code>Day</code> are <code>int</code>'s you have to use the <code>%d</code> specifier</p>

<pre><code>fprintf(FPC, ""%d \t %d \t %d \t %f \t\n"",&amp;TempData[i].Year, &amp;TempData[i].Month, &amp;TempData[i].Day, &amp;TempData[i].Mean);
</code></pre>

<p>And you dont pass the address of the fields to <code>fprintf</code> but instead the fields <b>remove the <code>&amp;</code></b></p>

<pre><code>fprintf(FPC, ""%d \t %d \t %d \t %f \t\n"", TempData[i].Year, TempData[i].Month, TempData[i].Day, TempData[i].Mean);
</code></pre>

<p>And a suggestion, check that <code>fscanf</code> read exactly the number of arguments you want to read in your case change this</p>

<pre><code>fscanf(FPT, ""%f \t %f \t %f \t %f \t"", &amp;TempData[i].Year, &amp;TempData[i].Month, &amp;TempData[i].Day, &amp;TempData[i].Mean) !=EOF
</code></pre>

<p>to this</p>

<pre><code>fscanf(FPT, ""%d \t %d \t %d \t %f \t\n"", &amp;TempData[i].Year, &amp;TempData[i].Month, &amp;TempData[i].Day, &amp;TempData[i].Mean) != 4
</code></pre>

<p>since <code>fscanf</code> returns the number of items succesfully matched, from the Linux manual pages</p>

<p>Also, your <code>fscanf</code> will fail with the first line of your file, thus not updating the stream pointer staying at the beginig of the file, so you must read the entire line and use <code>sscanf</code> otherwise you will not be able to skip the first line and continue reading, instead your code will abort reading at the first line and you will end up with an empty file.</p>

<pre><code>RETURN VALUE
   These  functions  return  the  number  of  input items successfully matched and assigned, which can be fewer than provided for, or even zero in the event of an early
   matching failure.

   The value EOF is returned if the end of input is reached before either the first successful conversion or a matching failure occurs.  EOF is also returned if a  read
   error occurs, in which case the error indicator for the stream (see ferror(3)) is set, and errno is set indicate the error.
</code></pre>

<p>One more thing, your format string could be</p>

<pre><code>""%d\t%d\t%d\t%f\n""
</code></pre>

<p>you don't need the extra spaces and the last <code>\t</code> character.</p>

<p>This code, should do it</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;

//Structure for my Text file read
typedef struct TempTXTData{
    int Year;
    int Month;
    int Day;
    double Mean;
} TempTXTData_t;

int main ()
{
    FILE *FPT; //Represents My Text File
    FILE *FPC; //Represents My .csv File
    int i;
    int done;
    TempTXTData_t TempData[366];

    //Where I open both my text and .csv files
    //FPT= fopen(""Manhattan_temp_data.txt"", ""r"");
    FPT = fopen(""data.dat"", ""r"");
    if (FPT == NULL)
    {
        printf(""Load Failure Press any key to exit...\n"");
        exit(EXIT_FAILURE);
    }

    FPC= fopen(""TemperatureData.csv"", ""w"");
    if( FPC == NULL )
    {
        fclose(FPT);
        printf(""Load Failure Press any key to exit...\n"");
        exit(EXIT_FAILURE);
    }

    done = 0;
    for (i = 1 ; (i &lt; 366) &amp;&amp; (done == 0) ;  i++)
    {
        char  buffer[1024];
        char *pointer;
        /* using fgets is better as was mentioned in other answers */
        pointer = fgets(buffer, sizeof(buffer), FPT);
        if (pointer != NULL)
        {
            int matched;
            matched = sscanf(pointer, ""%d%d%d%lf"", &amp;(TempData[i].Year), &amp;(TempData[i].Month), &amp;(TempData[i].Day), &amp;(TempData[i].Mean));
            if (matched == 4)
                fprintf(FPC, ""%d,%d,%d,%f\n"", TempData[i].Year, TempData[i].Month, TempData[i].Day, TempData[i].Mean);
        }
        else
            done = 1;
    }


    //Closing Files
    fclose(FPT);
    fclose(FPC);

    return 0;
}
</code></pre>
",4
27516914,27516408,2,"<p>You edited the question potentially destroying previous answers, which is not a good manoeuvre.</p>

<p>Since you changed the year, month, day elements into <code>int</code> (from <code>double</code>), you have to change the <code>scanf()</code> and <code>printf()</code> strings.  One of the gotchas with <code>scanf()</code> is that <code>%f</code> is for reading <code>float</code> values and <code>%lf</code> is for reading <code>double</code> values, but <code>printf()</code> uses <code>%f</code> for printing both (because <code>float</code> values are converted to <code>double</code> during the function call).</p>

<p>You don't skip the heading line of the file; that's a problem.</p>

<p>Were it me, I'd read a line at a time using <code>fgets()</code> and then scan the line that was read with <code>sscanf()</code>.  This allows me to detect mis-formatted data more easily.</p>

<p>It seems curious that the years you're dealing with have but 128 days; most of the ones I encounter have 365 or 366 (a problem now fixed in the question!).</p>

<p>Don't test <code>fscanf()</code> for EOF; test for 'gave me the correct number of values'.</p>

<p>Arrays in C start at index 0.</p>

<p>Your code nests the input and output loops; this is mildly disastrous since you print 366 result values for the first row read, then another 366 for the next row read, and so on.  Note that most of those values are undefined; they needn't be zeros or anything useful like that. You only want to print after you've read everything (especially when you get to interpolate missing values).  You don't want to print addresses.  You do want to print newlines.</p>

<pre><code>enum { MAX_DAYS_PER_YEAR = 366 };

char line[4096];

/* Skip header line */
if (fgets(line, sizeof(line), FPT) == 0)
{
    fputs(""Empty file!\n"", stderr);
    exit(1);
}

/* Read up to 366 input lines */
for (i = 0; i &lt; MAX_DAYS_PER_YEAR; i++)
{
    if (fscanf(FPT, ""%d %d %d %lf"", &amp;TempData[i].Year, &amp;TempData[i].Month,
               &amp;TempData[i].Day, &amp;TempData[i].Mean) != 4)
        break;
}

/* Print only the lines that were read */
for (j = 0; j &lt; i; j++) 
    fprintf(FPC, ""%d\t%d\t%d\t%.2f\n"", TempData[i].Year, TempData[i].Month,
            TempData[i].Day, TempData[i].Mean);
</code></pre>

<p>This produces tab-separated data (a TSV file), but it is common to refer to such files as CSV files, even though the C is blatantly inaccurate.  (DSV for 'delimiter separated values' is an accurate but rare term for such files.  The output file is a DSV with tab delimiters, in contrast to a DSV with comma separators.)</p>
",3
27516536,27516408,3,"<p>There are few things but yet, no solution (can't test right now):</p>

<ul>
<li>C array are indexed from <code>0</code> to <code>size - 1</code> (which you actually do using <code>&lt;</code> operator), so your loop should iterate from <code>0</code>. Either you want to avoid the comment text, in that case you should keep the start index to <code>1</code> and store in <code>TempData[i-1]</code> otherwize, change the index to <code>0</code>.</li>
<li>There is no reason for your datatypes for year / month / day not to be <code>int</code>.</li>
<li>The Spreadsheet is uninteresing here. First of all, you should look at the CSV file. There might be something to configure for excel to parse the data correctly.</li>
<li>Finally, and since you get an error because of that, your input file <code>Manhattan_temp_data.txt</code> should be opened read only (<code>r</code>).</li>
<li>Bonus one, I know that you windows guys have to put some C function to avoid closing terminal, but you should at least use a more standard function, such as <code>getchar()</code>. Doesn't cost much for you, and will compile on other operating systems as well.</li>
</ul>

<p>Hope this will help you a bit, or at least to edit your post to fit the actual problems.</p>
",0
31838027,31835910,2,"<p>Bubble sort is a commonly used algorithm for sorting an array of integers. It's called ""bubble sort"" since it causes the largest values to ""bubble"" up to the end of the array.</p>

<p>Bubble sort moves one index at a time up the array essentially pulling the largest value along. For example, If the array is <code>[1,3,2]</code> bubble sort will check the <code>1</code> and see if it is greater than the value ahead of it: <code>3</code>. It isn't so the one will stay in its place. Now the <code>3</code> is the largest value the program has seen so it will compare it to the next value, the <code>2</code>. Is <code>3</code> bigger? Yes! So it will switch the <code>3</code> and the <code>2</code>. Now the largest value is at the end of the array so the algorithm starts at the beginning of the array again. This repeats until the entire array is sorted.</p>

<p><strong>On to the specifics</strong>:</p>

<p>The first for-loop <code>for(i=0;i&lt;n;i++)</code> loops for the same amount of times as the size of the array, i.e. if the size is 7, this loops will execute 7 times. It does this because, in the worst case scenario, every value in the array will need to change location.</p>

<p>The inner-most for-loop <code>for(j=0;j&lt;(n-i)-1;j++)</code> first of all has <code>j</code> never reaching the very last array spot, even when i = 0. This is because the code inside the loop, <code>if(a[j]&gt;a[j+1])</code>, is always checking one value AHEAD of the current index. So, <code>j</code> must never equal the last value of the index because there will be an out of bounds error.</p>

<p>You will also notice that the inner-more for-loop goes from <code>0</code> to <code>n-i-1</code>. The reason this <code>-i</code> is included is because every time the outer loop, if(a[j]>a[j+1])`, is executed, one value will have moved all the way up to the end of the array. So you don't need to check the very last spot in the array because it's already correct!</p>

<p><strong>Summary</strong>:</p>

<p>Bubble sort continually moves the largest value to the end of the list. It does this by constantly checking values as it moves up the list and moving the largest value up one step at a time.</p>

<p><strong>Edit:</strong> See Cool Guy's comment for a link to a great visual representation of bubble sort.</p>
",0
25482988,25482810,0,"<p>First remove the semicolon &amp; remember for control structure you can not put semicolon at the end of it, so remove semicolon , </p>

<p>Seceondly, if you are still getting error put your int i and j outside of for loop, </p>
",1
25482861,25482810,3,"<p>You have a <code>;</code> at the end of both of your <code>for</code> statements, this closes the for loop immediately, which means the <code>i</code> variable is then out of scope and unavailable for use. </p>
",2
25482875,25482810,0,"<p>In C don't declare, variables inside <code>( )</code>.</p>

<pre><code>int i;  // declare globally
//  do your stuff
for(i = 1; i &lt; value+1; i++)
</code></pre>

<p>If you put <code>;</code> colon after loop statement, the loop blocks there itself till the condition fails. it will execute the next line. So remove the <code>;</code> after <code>for</code> loops.</p>

<p>Try this-</p>

<pre><code>#include&lt;stdio.h&gt;
int main()
{
        int value,i,j;
        printf(""Enter the number of rows\n"");
        scanf(""%d"",&amp;value);
        printf(""-----------------\n"");
        for(i = 1; i &lt; value+1; i++)
        {
                for(j = 1; j &lt;= i; j++)
                printf(""0"");
                printf(""\n"");
        }
        return 0;
}
</code></pre>
",8
27493940,27493708,1,"<p>Ok, just ensure the development files for readline are installed for which you need to run this as the root user</p>

<pre><code># apt-get install libreadline-dev
</code></pre>

<p>as someone mentioned in the comments.</p>

<p>Next, you go to the <code>Project-&gt;Build Options</code> menu and a dialog pops up
<img src=""https://i.stack.imgur.com/5CDts.png"" alt=""Build Options Dialog""></p>

<p>then go to the <code>Linker Settings</code> tab<img src=""https://i.stack.imgur.com/RYLVr.png"" alt=""Linker Settings Tab""></p>

<p>now just click the <code>Add</code> button, and type <code>readline</code> in the dialog that pops up <img src=""https://i.stack.imgur.com/6z0Ex.png"" alt=""enter image description here""> </p>

<p>click <code>Ok</code>, and try building now, it should work.</p>
",0
26441588,26441490,1,"<p>Change your <code>if(num==0)</code> to <code>if(num==0 || num==1)</code> </p>

<p>Because your variable <code>num</code> does not come to <code>0</code> at any point.
And the loop would not end at all.</p>

<p>Example: if you take 12 as num </p>

<p>It will execute <code>prime(12, 2);</code> and it print 2.</p>

<p>Then it will execute <code>prime(12/2, 2);</code></p>

<p>Then it will print 2 and execute <code>prime(6/2, 2);</code></p>

<p>Then it will check if condition <code>3%2==0</code> which is <code>false</code>.</p>

<p>Then it will execute the <code>else</code> statement which is <code>prime(3, 3);</code>
This will print <code>3</code> and execute <code>prime(3/3, 2);</code></p>

<p>Which will then again execute <code>prime(1, 2);</code> and Here it will recursively call <code>prime(1, 2);</code> and this will continue forever.</p>
",5
27163972,27163935,0,"<p>You need to read a whole line, e.g. with <a href=""http://man7.org/linux/man-pages/man3/fgets.3.html"" rel=""nofollow"">fgets(3)</a>, <a href=""http://man7.org/linux/man-pages/man3/getline.3.html"" rel=""nofollow"">getline(3)</a>, or even (if running on a terminal, e.g.  under Linux) <a href=""http://man7.org/linux/man-pages/man3/readline.3.html"" rel=""nofollow"">readline(3)</a> (which offers editing abilities). Then convert each line to a number using <a href=""http://man7.org/linux/man-pages/man3/sscanf.3.html"" rel=""nofollow"">sscanf(3)</a> or <a href=""http://man7.org/linux/man-pages/man3/strtol.3.html"" rel=""nofollow"">strtol(3)</a> and test when the conversion fails.</p>

<p>Something like</p>

<pre><code> const int arraysize = sizeof(array)/sizeof(array[0]); // 1000
 printf(""Enter at most %d integers ended by a blank line\n"", arraysize);
 for (c = 0; c&lt;arraysize; c++) {
    char linebuf[80];
    memset(linebuf, 0, sizeof(linebuf)); // perhaps unneeded
    if (!fgets(linebuf, sizeof(linebuf), stdin))
       break;
    if (sscanf(linebuf, ""%d"", &amp;array[c])&lt;=0)
       break;
 }
 // here c contains the number of actually read integers.
</code></pre>

<p>Read the documentation of every function that you are using. Notice that <code>scanf</code>, <code>fscanf</code> and <code>sscanf</code>are returning the count of successfully scanned items.</p>

<p>The clearing <a href=""http://man7.org/linux/man-pages/man3/memset.3.html"" rel=""nofollow"">memset(3)</a> is probably unneeded .. but just in case I always clear buffer.</p>
",1
27165515,27163935,0,"<p>What I understand from your problem is you want to break the following for loop after entering the numbers.</p>

<pre><code>for (c = 0; c&lt;n; c++)
    scanf(""%d"", &amp;array[c]);
</code></pre>

<p>If that's the case. Then you can use following loop.  </p>

<pre><code>    for (c = 0; c &lt; n; c++) {
        if (scanf(""%d"", &amp;array[c]) != 1 ) {
              n = c; // actual number of integer input.
              break;
        }
    }
</code></pre>

<p>Now if you enter some alphabet followed by a enter key then it breaks the for loop.</p>
",0
27173804,27163935,1,"<p>To end input when <kbd>Enter</kbd> or <code>'\n'</code> occurs is challenging using <code>scanf(""%d"",...</code> as <code>""%d""</code> first consumes any white-space including <code>'\n'</code>.  Need a different way to watch for  <code>'\n'</code> first.</p>

<pre><code>for (c = 0; c&lt;n; c++)
  int ch;
  while ((ch = fgetc(stdin)) != '\n' &amp;&amp; isspace(ch));
  if (ch == '\n' || ch == EOF) break;
  ungetc(ch, stdin);
  if (scanf(""%d"", &amp;array[c]) != 1) Handle_NonNumericInput();
}
</code></pre>

<p>or better yet, use <code>fgets()</code>.  Easy to catch all sorts of invalid input.</p>

<pre><code>#include &lt;limits.h&gt;
#define MAX_INT_SIZE (sizeof(int)*CHAR_BIT/3 + 3)

c = 0;
char buf[n*(MAX_INT_SIZE + 1) + 2];
if (fgets(buf, sizeof buf, stdin)) {
  char *p = buf;
  for (; c&lt;n; c++)
    int n;
    if (sscanf(p, ""%d %n"", &amp;array[c], &amp;n) != 1) break;
    p += n;
  }
  if (*p) Handle_Missing_or_Extra_or_Nonnumeric_input(); 
}
</code></pre>
",0
26131772,26131703,2,"<p>main() is a function by itself. The line return main() calls the function again. So in effect it should run an infinite loop. You wouldn't get any output (you said you ran it. didn't it crash?). 
In reality it would be like staring into a mirror with another mirror placed behind you. You would only see endless reflections. . :)</p>
",0
26151106,26150992,2,"<p>This is a mistake:</p>

<pre><code>int i,j,s;
int masivs[i];
</code></pre>

<p>You are declaring <code>masivs</code> with the dimension <code>i</code> but that is an uninitialized variable. That causes undefined behaviour. Perhaps you meant:</p>

<pre><code>int masivs[15];
</code></pre>

<p>You should also check that <code>n1</code> and <code>n2</code> are in the correct range before using them as array indices.</p>
",0
26190014,26189637,2,"<p>The waiting room is filling too fast.</p>

<p>The following process does not pause and quickly fills <code>stdout</code> with endless """"Waiting room is full"".  Similar  for <code>if (barber==0) {</code></p>

<pre><code>if(barber!=0) {
  while(1) {
     ...
  }
}
</code></pre>

<p>Should detect failed <code>fork()</code> the <code>barber &lt; 0</code>/</p>

<pre><code>// if(barber!=0) {
if (barber&gt;0) {
  ...
}
if(barber&lt;0) {
  printf(""failed %i "", barber);
}
</code></pre>

<p>Need to share memory.  See <a href=""https://stackoverflow.com/a/13274800/2410359"">https://stackoverflow.com/a/13274800/2410359</a></p>

<p>""Working"" code follows with various debug prints.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;unistd.h&gt;

static int *waitingRoomCust;

int main(int argc, char const *argv[]) {
  waitingRoomCust = mmap(NULL, sizeof *waitingRoomCust, PROT_READ | PROT_WRITE,
  MAP_SHARED | MAP_ANONYMOUS, -1, 0);

  *waitingRoomCust = 01;

  //srand(time(NULL));
  int barber = fork();
  printf(""%d\n"", barber);
  fflush(stdout);
  if (barber == 0) {
    while (1) {
      if (*waitingRoomCust &gt; 0) {
        (*waitingRoomCust)--;
        printf(""Customer has been given a haircut.\n"");
        fflush(stdout);
        sleep((rand() % 12));
      } else {
        printf(""sleep %d\n"", *waitingRoomCust);
        fflush(stdout);
        sleep(1);
      }

    }
  }

  if (barber &gt; 0) {
    while (1) {
      sleep(7);
      if (*waitingRoomCust &lt;= 3) {
        (*waitingRoomCust)++;
        printf(""The waiting room has now %i customers.\n"", *waitingRoomCust);
        fflush(stdout);
      } else {
        printf(""Waiting room is full, customer has left.\n"");
        fflush(stdout);
      }
    }
  }
  if (barber &lt; 0) {
    printf(""failed %i "", barber);
    fflush(stdout);
  }
  return 0;
}
</code></pre>
",2
26190340,26189637,0,"<p>after the fork, each process has its own copy of the variable waitingRoomCust.</p>

<p>in this block:</p>

<pre><code>        if(waitingRoomCust &gt; 0) {
            waitingRoomCust--;
            sleep((rand() % 12));
            printf(""Customer has been given a haircut."");
        }
</code></pre>

<p>when the value of the variable waitingroomcust is less than zero, nothing else will never happen, cause Nothing can increase this variable</p>

<p>in this block:</p>

<pre><code>        if(waitingRoomCust &lt;= 3) {
            waitingRoomCust++;
            printf(""The waiting room has now %i customers."", waitingRoomCust);
        }
</code></pre>

<p>when the value of the variable waitingroomcust is more than 3, nothing else will never happen, cause Nothing can reduce this variable</p>

<p>if you want to use a different process, you need to made a way of communication them, it can be a fifo or signals.</p>

<p>if you want to use shared memory, then you need threads, they are similar to processes, but share the same memory.</p>

<p>if you need, I can describe in more detail each of the 3 methods</p>
",0
26791345,26791129,0,"<p>To optimized your code a little bit (changes are made based on comments):</p>

<pre><code>long int prime (int n)
{
  int i;
  int e = (int)sqrt(n);
  for(i=2; i&lt;=e;i++)
  {
    if(n%i==0)
    return 0;
  }
  return 1;
}
</code></pre>
",3
26791571,26791129,0,"<p>You can reduce the time substantially by making the following changes to <code>prime()</code>:</p>

<ol>
<li>Stopping at <code>sqrt(n)</code>.</li>
<li>Starting at <code>i=3</code>, and incrementing <code>i</code> by <code>2</code>.</li>
</ol>

<p>Here's a program that contains both versions and the time taken by each.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;

int is_prime1 (int n)
{
    int i;
    for(i=2;i&lt;n;i++)
    {
        if(n%i==0)
        return 0;
    }
    return 1;
}

void do_it1(int max)
{
   clock_t start = clock();
   clock_t end;

   int i=2,counter=0;
   while(1)
   {
      if(is_prime1(i))
         counter++;
      if(counter==max)
         break;
      i++;
   }
   end = clock();

   printf(""%dth prime number is: %d\n"", max, i);
   printf(""Time taken: %lf\n"", 1.0*(end-start)/CLOCKS_PER_SEC);
}

int is_prime2 (int n)
{
    int i;
    int stop = sqrt(n);
    for(i=3;i&lt;=stop;i+=2)
    {
        if(n%i==0)
        return 0;
    }
    return 1;
}

void do_it2(int max)
{
   clock_t start = clock();
   clock_t end;

   int i=3,counter=1;
   while(1)
   {
      if(is_prime2(i))
         counter++;
      if(counter==max)
         break;
      i += 2;
   }
   end = clock();

   printf(""%dth prime number is: %d\n"", max, i);
   printf(""Time taken: %lf\n"", 1.0*(end-start)/CLOCKS_PER_SEC);
}

int main(int argc, char** argv)
{
   int max = atoi(argv[1]);
   do_it1(max);
   do_it2(max);
}
</code></pre>

<p>Sample execution:</p>

<pre><code>./test 10000
</code></pre>

<p>Sample output:</p>

<pre><code>10000th prime number is: 104729
Time taken: 9.469000
10000th prime number is: 104729
Time taken: 0.078000
</code></pre>
",0
26791614,26791129,-1,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

int *prime;
int prime_n;

void make_prime_table(int n){
    prime = malloc(sizeof(int) * n / 2);
    prime_n =0;
    prime[prime_n++] = 2;
    prime[prime_n++] = 3;
    int i, j;
    for(i = 5; i &lt;= n; i +=2){
        bool is_prime = true;
        for(j = 1; j &lt; prime_n ; ++j){
            int t = prime[j];
            if(t * t &gt; i)
                break;
            if(i % t == 0){
                is_prime = false;
                break;
            }
        }
        if(is_prime)
            prime[prime_n++] = i;
    }
}

int main(void){
    int n = 105000;
    make_prime_table(n);
    if(prime_n &gt;= 10000)
        printf(""10000th prime number is: %d\n"", prime[9999]);

    free(prime);
    return 0;
}
</code></pre>
",1
26784651,26784472,0,"<p>You're creating a pointer temp_fp, and then setting that pointer to fp. This isn't actually copying fp, but instead pointing to the same spot in memory as the original.</p>

<p>This link may be useful for you: <a href=""https://www.cs.bu.edu/teaching/c/file-io/intro/"" rel=""nofollow"">https://www.cs.bu.edu/teaching/c/file-io/intro/</a></p>
",2
26199483,26199481,3,"<p>Use strcat to concatenate strings.  strcat_s is similar but is safer since it has length validation.</p>
",0
26199490,26199481,4,"<p>In C you cannot concatenate two strings using <code>+</code>, as strings are not inbuilt datatype, use <code>strcat()</code> which is defined in <code>string.h</code>.</p>

<p>A small example:</p>

<pre><code>/* strcat example */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
int main ()
{
    char *str;  
    char arr[10];
    puts(""Enter some string:"");
    scanf(""%9s"",arr);
    str=malloc(256);
    strcat (str,arr);
    strcat (str,"" World."");
    puts (str);
    return 0;
}
</code></pre>

<p><strong>Input</strong> </p>

<blockquote>
  <p>Hello</p>
</blockquote>

<p><strong>Output</strong></p>

<blockquote>
  <p>Hello World.</p>
</blockquote>
",0
26428547,26428472,0,"<p>You cannot assign a value to <code>&amp;a</code>, because <code>&amp;a</code> denotes the <strong>address</strong> where the variable <code>a</code> is stored, and that address is determined once and for all at program start and it can't be changed.</p>

<p>When using <code>scanf</code>, you want that one or more variables be modified by the <code>scanf</code> function. Therefore you must pass the <strong>address</strong> of the variables to be modified to <code>scanf</code>.</p>
",0
26428597,26428472,0,"<p>As people have commented, understanding <strong><em><a href=""http://www.tutorialspoint.com/c_standard_library/c_function_scanf.htm"" rel=""nofollow"">scanf()</a></em></strong> would benefit you.  This link contains some sample code, and good description of use.</p>

<p>And <strong><em><a href=""http://msdn.microsoft.com/en-us/library/bkbs2cds.aspx"" rel=""nofollow"">This may help understand what L-value and R-value</a></em></strong> are.  </p>

<p><strong><em>Your question:</em></strong><br>
The address of <code>a</code>, i.e. <code>&amp;a</code> is assigned at the time <code>a</code> is created at runtime.      </p>

<p>By attempting the statement <code>&amp;a = 2;</code>, you are trying to re-assign the place where <code>a</code> resides, or the address.  For example:<br>
Say the address of <code>a</code> is 0x0000ABCD<br>
Then your statement would be attempting to assert that  </p>

<pre><code>0x0000ABCD. = 2;// an illegal assignment
</code></pre>

<p>This cannot be true, At compile time, the compiler warning is simply notifying you of that mistake.  Re-assignment of an address <em>in this manner</em> is not allowed.  </p>

<p><strong><em>Note</em></strong>, you <em>can</em> use the address of a variable to set a pointer to point to a specific location:  </p>

<pre><code>int a, *pB;

pB = &amp;a;//now pB points to the location of a  
</code></pre>

<p>Which, to the runtime engine, could look something like:  </p>

<pre><code>pB = 0x0000ABCD; //a legal assignment
</code></pre>
",2
26428710,26428472,0,"<p>You're correct in your thinking that &amp;a=2 is illegal, as it is trying to store an integer value into an integer. For example, it might equate to 0x0fb8b815 = 2, or 4 = 7, and the compiler won't like that. After all, what would that even mean?</p>

<p>As for scanf(), it takes two arguments. The first describes the type of data you're looking for; ""%d"" is looking for an integer. The Second argument is where you want the data to be stored.</p>

<p>So: </p>

<pre><code>int a;
scanf(""%d"", &amp;a);
</code></pre>

<p>You're giving the memory address of a to scanf, and saying that you want an integer. This works out, because we've declared <code>a</code> as type <code>int</code>. The &amp;a is <em>dereferenced</em>, and turned into a number representing the location in memory that a resides in.  Scanf takes user input, and attempts to put that input into the memory location given as the second argument. You <em>could</em> call scanf like this: <code>scanf(""%s"", 0x8484af00);</code>.  You'd be giving it a specific memory location, as an integer literal, for it to store the data. This is a very bad idea, unless you somehow know exactly what that memory location is being used for! the '%s' option says you want a string, so it could be quite lengthy, and an arbitrary memory location like that will have a good chance of upsetting the operating system. A trick like that might try overwriting ram being used by another program, or even by the operating system itself, so it will probably cause a segfault and crash. Always know where you're putting things.  </p>
",2
26244805,26244750,1,"<p>When you do <code>for(j=1; j&lt;=i; j++)</code> you are starting j at <code>1</code> and counting up until it reaches <code>i</code>. What you want to do ois start from <code>i</code> and count down (<code>--</code>) until it reaches <code>1</code>.</p>
",0
26244812,26244750,4,"<p>You can simply reverse your second loop to go from the higher number to the lower number like such:</p>

<pre><code>int i, j;
for(i = 1; i&lt;=20; i++) {
  for(j=i; j&gt;0; j--) {
    printf(""%3d"", j); 
  }
  printf(""\n"");
}
</code></pre>

<p>This will start with printing the largest number and end with a one.</p>
",0
26244848,26244750,0,"<p>Try changing you second for loop to <code>for(j=i;j&gt;=1;j--)</code>.
It will print</p>

<pre><code> 1
 2 1
 3 2 1
 4 3 2 1 and so on...
</code></pre>

<p>I hope this is what you asked..</p>
",0
27503422,27503287,1,"<p>The lines <code>if (i != m)</code> and <code>if (j != h)</code> must be <code>if (i &lt;= m)</code> and <code>if (j &lt;= h)</code>.</p>

<p>Besides, you can omit them as well because they are redundant (leave only the <code>while</code> conditions).
Less code, less bugs.</p>
",0
26427675,26427584,2,"<p>You shouldn't return more than one value as suggested by the function banner comment. Return the 0 or 1 to indicate game status and the value stored in the address pointed to by nextMove is changed by the scanf() function calls:</p>

<pre><code>int getNextMove(move *nextMove) {
    printf(""Make a move (Row = 0 ends the game)\n"");
    printf(""Row = "");
    scanf(""%d"", &amp;nextMove-&gt;row);
    if (nextMove-&gt;row == 0)
    {
        return 0;
    }
    printf(""Column = "");
    scanf(""%d"", &amp;nextMove-&gt;column);

    return 1;
}
</code></pre>

<p>For the record if you did want to return a pointer to a move struct an example could be:</p>

<pre><code>move * getMove(void)
{
    static move moveToReturn;

    /* some operations on the move stucture */

    return &amp;moveToReturn
}
</code></pre>
",1
26427721,26427584,4,"<p>You made a simple error. The function's documentation says:</p>

<pre><code>Output:      Return 0 if the user want to end the game, 1 otherwise.
</code></pre>

<p>But, instead, you're returning <code>0</code> or the value of <code>nextMove</code>.</p>

<p><code>nextMove</code> is a <code>move*</code>, not an <code>int</code>, hence the warning. This is also why warnings are so helpful, because they have pointed out this mistake that you have made in returning the wrong thing.</p>

<p>Change <code>return nextMove</code> to <code>return 1</code>.</p>
",0
26427651,26427584,1,"<p>You are (sometimes) returning the argument.  What's the point of that?  There's no need to return anything in that case.</p>

<p>If you did want to return a pointer to a <code>move</code>, though, then your function should declare that as its return type:</p>

<pre><code>move * getNextMove(move * nextMove) {
    ...
    return nextMove;
}
</code></pre>
",1
29237111,29236890,0,"<p>After you read the first thing from <code>f1</code>, you close all of your file descriptors, reopen the output files for reading, and print out their contents.  Then you go back to the start of the loop to try to read the second thing from <code>f1</code>, but it's closed now.</p>

<p>You probably wanted the <code>while</code> loop to complete <em>before</em> closing all the files.</p>
",0
29237125,29236890,0,"<p>The most visible problem is it fclose()ing everything and trying to present the results WITHIN the loop: it should be doing that AFTER it.</p>
",0
29237447,29236890,1,"<p>You have:</p>

<pre><code>while((number=getw(f1))!=EOF)
{
    if(number%2==0)
        putw(number,f3);
    else
    {
        putw(number,f2);
    }
    fclose(f1);
    fclose(f2);
    fclose(f3);
</code></pre>

<p>That is premature closing of the files. Next call to <code>getw(f1)</code> will be a problem -- it's undefined behavior.</p>

<p>And then you have in thee same loop.</p>

<pre><code>    f2=fopen(""odd"",""r"");
    f3=fopen(""even"",""r"");
</code></pre>

<p>Now <code>f2</code> and <code>f3</code> cannot be used to write into.</p>

<p>Try:</p>

<pre><code>while((number=getw(f1))!=EOF)
{
    if(number%2==0)
        putw(number,f3);
    else
    {
        putw(number,f2);
    }
}

// Now you can safely close the files.
fclose(f1);
fclose(f2);
fclose(f3);

// Reopen the files in read mode to examine their contents.
f2=fopen(""odd"",""r"");
f3=fopen(""even"",""r"");
</code></pre>
",0
29238673,29236890,1,"<p>You mistyped the program.  You typed an extra <code>{</code> after the <code>else</code> before <code>putw(number,f2);</code></p>

<p>Try this:</p>

<pre><code>#include &lt;stdio.h&gt;
int main()
{
    FILE *f1,*f2,*f3;
    int number,i;
    printf(""content of data file\n\n"");
    f1 =fopen(""data"",""w"");
    for(i=0;i&lt;20;i++) {
        if (scanf(""%d"",&amp;number) != 1 || number==-1)
            break;
        putw(number,f1);
    }
    fclose(f1);
    f1=fopen(""data"",""r"");
    f2=fopen(""odd"",""w"");
    f3=fopen(""even"",""w"");
    while((number=getw(f1))!=EOF) {
        if(number%2==0)
            putw(number,f3);
        else
            putw(number,f2);
    }
    fclose(f1);
    fclose(f2);
    fclose(f3);
    f2=fopen(""odd"",""r"");
    f3=fopen(""even"",""r"");
    printf(""\n\ncontent of odd file\n\n"");
    while((number=getw(f2))!=EOF)
        printf(""%4d"",number);
    printf(""\n\ncontent of even number\n\n"");
    while((number=getw(f3))!=EOF)
        printf(""%4d"",number);
}
</code></pre>
",0
28191107,28191024,2,"<p>The difference is in the <strong>return value</strong>:</p>

<p>The <strong>strcpy()</strong> and <strong>strncpy()</strong> functions return a <strong>pointer</strong> to the destination string.</p>

<p>Upon successful completion, <strong>strxfrm()</strong> shall return the <strong>length</strong> of the transformed string (not including the terminating null byte). If the value returned is n or more, the contents of the array pointed to by s1 are unspecified.</p>
",1
28493515,28493475,2,"<pre><code>fgets(string, 512, stdin) != NULL
</code></pre>

<p>What you have is array out of bound access as the array string can hold just 44 characters but you are allowing to write more than 44 characters.So the behavior is undefined.</p>

<pre><code>fgets(string, sizeof(string), stdin) != NULL
</code></pre>

<p>is what you should have </p>
",4
28494053,28493475,0,"<p>As WhozCraig said, a bunch of my array sizes were wrong. I wasn't accounting for spaces when I set the sizes so the spaces were pushing it over the size I specified.</p>
",0
31904262,31904143,3,"<p>An object file is a file containing object code, meaning relocatable format machine code that is usually not directly executable. <strong>.obj</strong> is the compiled object file that is used by the <strong>linker</strong> (along with the necessary library (<strong>.h</strong>) files) to create an executable. The executable is then loaded into the memory for execution using a <strong>loader</strong>.</p>

<p>Please read the following for more information-
<a href=""https://stackoverflow.com/questions/3996651/what-is-compiler-linker-loader"">What is compiler, linker, loader?</a></p>

<p><a href=""https://i.stack.imgur.com/cvvaV.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/cvvaV.png"" alt=""enter image description here""></a></p>
",0
29462468,29462376,4,"<pre><code>gcc -o entry_test -Wl,-eother entry_test.c
</code></pre>

<hr>

<pre><code>#include&lt;stdio.h&gt;       

int other(void){//can't use argc, argv
    printf(""Bye-Bye world!\n"");
    return 0;
}

int main(int argc, char *argv[]){
    printf(""%s\n"",""Hello world!"");
    return 0;
}
</code></pre>
",11
29463010,29462376,1,"<p>If you're using gcc, I found a thread that said you can use the -e command-line parameter to specify a different entry point; as BLUEPIXY stated 
see also :</p>

<p><a href=""https://stackoverflow.com/questions/3379190/avoiding-the-main-entry-point-in-a-c-program"">Avoiding the main (entry point) in a C program</a></p>

<p>-see the following link for more details about ""-e"" option :</p>

<p><a href=""http://gcc.gnu.org/ml/gcc/2001-06/msg01959.html"" rel=""nofollow noreferrer"">http://gcc.gnu.org/ml/gcc/2001-06/msg01959.html</a></p>

<p>Another way is to change the starting function is in the linker ""start up"" file..  linker may include some pre-main startup code in a file like start.o and it is this piece of code which runs to set up the C environment then call main (as in all embedded tool-chains). There's nothing to stop you replacing that with something that calls another function instead.</p>

<p>here is a terrific explanation for startup files:</p>

<p><a href=""https://stackoverflow.com/questions/15696258/what-is-bootloader-and-startup-code-in-the-embedded-systems"">What is the bootloader and startup code in embedded systems?</a></p>

<p>I voted this question up as it really may be useful for some embedded c developers. </p>
",0
23594879,23594761,4,"<p>Unadorned floating point constants are <code>double</code> values.  Therefore, in:</p>

<pre><code>float x = 1.5;
</code></pre>

<p>the <code>1.5</code> is a <code>double</code> value.  Now, in this context, even the most dim-witted compiler is going to generate the same code as it would if you wrote:</p>

<pre><code>float x = 1.5f;
</code></pre>

<p>So in this context, it doesn't matter.  When does it matter?  When you use the constant in a calculation:</p>

<pre><code>float y = x * 2.3;
</code></pre>

<p>The multiplication is done using <code>double</code> and then the result converted to <code>float</code>, compared with:</p>

<pre><code>float z = x * 2.3f;
</code></pre>

<p>where the multiplication is done using <code>float</code>.  In pre-standard C, all floating point computations were done in <code>double</code>, so the distinction didn't matter, but all versions of Standard C allow the computation for all operands <code>float</code> to be done in <code>float</code>.</p>
",1
25491024,25490946,6,"<pre><code>foreach value v
  if (v &gt; biggest)
    second = biggest
    biggest = v
  else if (v &gt; second)
    second = v
</code></pre>

<p>Note: you do have to decide what to do if there are repeated elements.
In other words, suppose the numbers are 5,5,3,1.
Then the largest is obviously 5, but is the second largest 5, or 3?
That's for you to decide and fix the algorithm accordingly.</p>
",0
27685689,27685617,1,"<p>Remove the <code>while(1)</code> loops from the <code>fnSlotN</code> functions and instead:</p>

<pre><code>while(1)
{
    fnSlot1();
    fnSlot2();
    fnSlot3();
}
</code></pre>
",1
27685697,27685617,1,"<p>You have infinite loops in all functions. If you enter one function you never return.</p>

<p>Consider putting this while in main function.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
...

int main(){

        srand( time(0) );
        fnSlotMachine();
        while(1) {
          fnSlot1();
          fnSlot2();
          fnSlot3(); 
        }
}

...    
void fnSlot1(){

            Sleep(50);
            fnGotoXY(5, 9);
            intSlot1 = rand() % 9;
            printf("" | %i %i %i |\n"", intSlot1, intSlot1, intSlot1);
            fnGotoXY(2, 10);
            printf(""    | %i %i %i |\n"", intSlot1, intSlot1, intSlot1);
            fnGotoXY(2, 11);
            printf(""    | %i %i %i |"",   intSlot1, intSlot1, intSlot1);

}

void fnSlot2(){


            Sleep(50);
            fnGotoXY(17, 9);
            intSlot2 = rand() % 9;
            printf(""| %i %i %i |\n"", intSlot2, intSlot2, intSlot2);
            fnGotoXY(17, 10);
            printf(""| %i %i %i |\n"", intSlot2, intSlot2, intSlot2);
            fnGotoXY(17, 11);
            printf(""| %i %i %i |"",   intSlot2, intSlot2, intSlot2);

}

void fnSlot3(){


            Sleep(50);
            fnGotoXY(27, 9);
            intSlot3 = rand() % 9;
            printf(""| %i %i %i |\n"", intSlot3, intSlot3, intSlot3);
            fnGotoXY(27, 10);
            printf(""| %i %i %i |\n"", intSlot3, intSlot3, intSlot3);
            fnGotoXY(27, 11);
            printf(""| %i %i %i |"",   intSlot3, intSlot3, intSlot3);

}
</code></pre>
",0
26205342,26205272,7,"<p>The value of <code>--a</code> is the previous value of <code>a</code> minus <code>1</code>.</p>

<p>Furthermore that expression has the side-effect of changing the value of <code>a</code>.</p>

<p>The left part of the comparison is the value of <code>a</code> ... but is it the value of <code>a</code> before or after the side-effect has been applied?</p>

<p>The C Standard does not force the sequence of checking the value and applying the side-effect; and says that reading the value of a variable and changing its value without an intervening sequence point is <strong>Undefined Behaviour</strong>.</p>

<p>Basically there is a sequence point at every <code>;</code> in the program (it's not as straightforward); your expression (<code>a == --a</code>) does not have sequence points.</p>
",0
26205832,26205272,-3,"<p>I believe the next rule is also valid in C as in Java :
The --x has a higher priority than x--</p>

<pre><code>a=10;
printf(a--) // should be showing 10;
a=10;
printf(--a) //should be showing 9
</code></pre>
",1
27177478,27176536,1,"<p>For example, as one approach to collecting the maximum number, you can simply add a <code>ternary</code> expression following your <code>while</code> loop:</p>

<pre><code>#include &lt;stdio.h&gt;

int main () {
    int i=0, num=0;
    int pasos=0, maxpasos=0;;
    for (i = 2; i &lt;= 100; i++) {
        pasos = 0;
        num = i;
        while (num != 1) {
            if (num % 2 == 0) {
                num = num / 2;
                pasos = pasos + 1;
            }

            else {
                num = num * 3 + 1;
                pasos = pasos + 1;
            }
        }
        maxpasos = (pasos &gt; maxpasos) ? pasos : maxpasos;
        printf (""\n"");
        printf (""El numero de pasos para llegar a 1 desde %i fueron: %i"", i,
                pasos);
    }
    printf (""\n\nMaxpasos : %d\n\n"", maxpasos);
    return 0;
}
</code></pre>

<p><strong>output:</strong></p>

<pre><code>./bin/collatzmax

El numero de pasos para llegar a 1 desde 2 fueron: 1
El numero de pasos para llegar a 1 desde 3 fueron: 7
El numero de pasos para llegar a 1 desde 4 fueron: 2
(snip)
El numero de pasos para llegar a 1 desde 99 fueron: 25
El numero de pasos para llegar a 1 desde 100 fueron: 25

Maxpasos : 118
</code></pre>

<p>If you also need to store <code>i</code> when it occurs, simply add a variable <code>int imax=0;</code>, then when you store <code>maxpaso</code>, also store <code>imax=i;</code>. Example:</p>

<pre><code>int i=0, num=0, imax=0;
...
    // maxpasos = (pasos &gt; maxpasos) ? pasos : maxpasos;
    if (pasos &gt; maxpasos) {
        maxpasos = pasos;
        imax = i;
    }
</code></pre>

<p><strong>output:</strong></p>

<pre><code>Maxpasos (at 97): 118
</code></pre>
",0
26421629,26421578,1,"<p>Assuming that the array you pass are the dimensions 5,20 then you have a mistake in the first for loop:</p>

<pre><code>for (j=0;j&lt;=5;j++)
</code></pre>

<p>Where you go out of bounds</p>

<pre><code>for (j=0;j&lt;5;j++)
</code></pre>

<p>is the correct loop</p>

<p>However this comment <em>//Set the 6th bit in both, then compare</em> indicates that you have larger dimensions than specified.</p>

<p>The better way to form your function would be to specify the dimensions with additional parameters and pass an additional array for storing results.</p>
",1
26434358,26434317,1,"<p><strong>Wrong:</strong></p>

<ul>
<li>Your boolean-logic</li>
<li>Your null-character</li>
<li>Calling <code>atoi</code> when <code>isgood</code> is <code>FALSE</code></li>
</ul>

<hr>

<p><strong>Change this:</strong></p>

<pre><code>isdigit(x[j])==0 || x[j]!='/0'
</code></pre>

<p><strong>To this:</strong></p>

<pre><code>isdigit(x[j])==0 &amp;&amp; x[j]!='\0'
</code></pre>

<p><strong>And this:</strong></p>

<pre><code>a = atoi(x);
if (a&lt;1000 &amp;&amp; isgood == TRUE)   break;
</code></pre>

<p><strong>To this:</strong></p>

<pre><code>if (isgood == TRUE)
{
    a = atoi(x);
    if (0&lt;a &amp;&amp; a&lt;1000)
        break;
}
</code></pre>

<p><strong>Here is a far more simple way of doing the whole thing:</strong></p>

<pre><code>int x;
char c;
do
{
    printf(""Write a where 0&lt;a&lt;1000\n"");
    if (scanf(""%d"",&amp;x) == 0)
        scanf(""%c"",&amp;c);
    else if (0&lt;x &amp;&amp; x&lt;1000)
        break;
}
while (1);
</code></pre>
",6
26791517,26791444,4,"<p>1) Here is the arithmetic:</p>

<pre>0x106879030<sub>16</sub> - 0x106879018<sub>16</sub> = 0x18<sub>16</sub> == 24<sub>10</sub></pre>

<p>2) And here is the layout:</p>

<pre><code>struct one{
    int x[6];     // bytes 0..23 (24 bytes)
    short y[12];  // bytes 24 .. 47 (next 24 bytes)
}a;
</code></pre>
",0
25669850,25669722,1,"<p>I tested your code and it works fine ! There are errors in the code such as : </p>

<pre><code>printf(""Your BMI is: %d"", &amp;bmi); 
</code></pre>

<p>You just have to print it like this : </p>

<pre><code>printf(""Your BMI is: %d"", bmi);
</code></pre>
",3
25669869,25669722,0,"<p>Your compiler is old, it wants you to do something that is not really wrong, just how it was programmed some years ago.</p>

<p>Also you have a problem with your code: 
<code>printf(""Your BMI is: %d"", &amp;bmi);</code></p>

<p>Change it to: </p>

<pre><code>printf(""Your BMI is: %d"", bmi);
</code></pre>
",0
25670335,25669722,0,"<p>With the information you've given, the most likely candidate is that your compiler is enforcing a C89 rule that requires all variable declarations to be placed at the start of a block. Take the following example:</p>

<pre><code>#include &lt;stdio.h&gt;

int main (void)
{
  printf(""Welcome to my program\n"");

  int x = 5;
  printf(""x = %d\n"", x);

  return 0;
}
</code></pre>

<p>I can make <code>gcc</code> extra picky:</p>

<pre><code>$ gcc -pedantic-errors -std=c89 -c vars.c
vars.c: In function ¡®main¡¯:
vars.c:7:3: error: ISO C90 forbids mixed declarations and code [-pedantic]
</code></pre>

<p>To fix this error, the variable declaration must be raised to the top of the block:</p>

<pre><code>#include &lt;stdio.h&gt;

int main (void)
{
  int x = 5;

  printf(""Welcome to my program\n"");
  printf(""x = %d\n"", x);

  return 0;
}
</code></pre>

<p>And now it will build just fine that way. The fact that you see this behavior by default likely means you're using an old compiler (or possibly something specialized that only supports c89).</p>
",0
25673159,25673012,1,"<p>You need to look at your <code>Initialize()</code> function signature, and turn on your compiler warnings (or pay attention to them if they're already on). You are declaring <code>Initialize()</code> to take an array of pointers to <code>struct candidates</code>, which is not what you are passing - an array of <code>struct candidates</code>. The array decays to a pointer, so <code>struct candidates *EC</code> is what your argument should look like (or, alternately, <code>struct candidates EC[]</code>, which is equivalent in this case), not <code>struct candidates *EC[]</code>. And then call your function without the <code>&amp;</code>...</p>
",0
25673190,25673012,0,"<p>Given</p>

<pre><code>struct candidates
    {
     char name[20];
     int votes;
    };
struct candidates electionCandidates[];
</code></pre>

<p>You want</p>

<pre><code>void Initialize(struct candidates EC[])
{
    /* ... */
}

Initialize(electionCandidates);
</code></pre>

<p>When passed as a function argument, the array of structs decays to a pointer to its first element.</p>
",2
25674349,25673012,0,"<p>I got it loading the names and everything but I guess I need to point to SPOIL in this? It is not reading or doing the votes/spoiled votes, giving 0 for both.</p>

<pre><code>#include &lt;stdio.h&gt;

struct candidates
{
 char name[20];
 int votes;
};
struct candidates electionCandidates[7];

void Initialize(struct candidates EC[]);
void Processvotes(struct candidates EC[], int BadVote);
void printResults(struct candidates EC[], int BadVote);

int main()

{

    int i, SPOIL = 0;

    Initialize(electionCandidates);
    Processvotes(electionCandidates, SPOIL);
    printResults(electionCandidates, SPOIL);

}

void Initialize(struct candidates EC[])
{
    int i;

    FILE *fp;
    fp = fopen(""elections.txt"", ""r"");

    for (i = 0; i &lt; 7; i++)

    {
        fgets(EC[i].name, 20, (FILE*)fp);
    }

    fclose(fp);
}


void Processvotes(struct candidates EC[], int BadVote)
{
        int TVOTE, i;

        FILE *fp;
        fp = fopen(""elections.txt"", ""r"");

        fscanf(fp, ""%d"", &amp;TVOTE);

        for (i = 0; i &lt; 365; i++)
        {
            if (TVOTE == 1)
                EC[0].votes++;
            if (TVOTE == 2)
                EC[1].votes++;
            if (TVOTE == 3)
                EC[2].votes++;
            if (TVOTE == 4)
                EC[3].votes++;
            if (TVOTE == 5)
                EC[4].votes++;
            if (TVOTE == 6)
                EC[5].votes++;
            if (TVOTE == 7)
                EC[6].votes++;

            if (TVOTE &lt; 1 || TVOTE &gt; 7)
                BadVote++;
        }

        fclose(fp);
}

void printResults(struct candidates EC[], int BadVote)
{

    int i, Win = 0, WinSCORE = 0, Runner = 0, RunnerSCORE = 0;

    for (i = 0; i &lt; 7; i++)
    {

        if (EC[i].votes &gt; WinSCORE)
        {
            WinSCORE = EC[i].votes;
            Win = i;
        }

        if (EC[i].votes == WinSCORE)
        {
            RunnerSCORE = EC[i].votes;
            Runner = i;
        }
    }


    if (WinSCORE == RunnerSCORE)
    {
        printf(""There was a tie between %s and %s who both got a total of %d votes each. There were %d spoiled votes\n"", EC[Win].name, EC[Runner].name, WinSCORE, BadVote);
    }

    else
        printf(""%s won the election with a total of %d votes. There was a total of %d spoiled votes.\n"", EC[Win].name, WinSCORE, BadVote);


}
</code></pre>
",0
30708903,30708757,0,"<p>Use a pointer</p>

<pre><code>    int *array1 = NULL, *array2 = NULL;
    int *ptr1 = array1;
    int x = add(*ptr1++, array2[0]);
    int y = add(*ptr1++, array2[7]); 
    int x = add(*ptr1++, array2[3]);
    int y = add(*ptr1++, array2[4]);
    int x = add(*ptr1++, array2[6]);
    int y = add(*ptr1++, array2[1]); 
    int x = add(*ptr1++, array2[5]);
    int y = add(*ptr1++, array2[2]);
    ................
    ................
    int x = add(*ptr1++, array2[0]);
    int y = add(*ptr1++, array2[7]); 
    int x = add(*ptr1++, array2[3]);
    int y = add(*ptr1++, array2[4]);
</code></pre>

<p>But remember <em><a href=""http://c2.com/cgi/wiki?PrematureOptimization"" rel=""nofollow"">premature optimization is the root of all evil</a></em>.</p>

<p>Before optimizing measure and make certain you need optimizing the accesses to the array.</p>

<p>After optimizing measure to make certain the optimization had any effect.</p>
",0
30708906,30708757,1,"<p>first step:</p>

<pre><code>for (int i = 0; i &lt; 256; i+=8) {
  x = add(array1[i],   array2[0]);
  y = add(array1[i+1], array2[7]);
  ...
}
</code></pre>
",0
30708989,30708757,5,"<p>what you can is</p>

<pre><code>int j = 0,order[] = {0,7,3,4,6,1,5,2};
for(int i = 0;i &lt;256; i +=2)
{
    int x =add(array1[i],array2[order[j%8]]);
    j++;
    int y =add(array1[i+1],array2[order[j%8]]);
    j++;
}
</code></pre>

<p><strong>UPDATE</strong><br />
alternate solution can be (if you want without using i+=2)</p>

<pre><code>int j = 0,order[] = {0,7,3,4,6,1,5,2};
for(int i = 0;i &lt;256; i ++)
{
    int x =add(array1[i],array2[order[j%8]]);
    j++;
    i++; 
    if(i&gt;=256) break;  //Improves it if you have non even condition
    int y =add(array1[i],array2[order[j%8]]);
    j++;
}
</code></pre>

<p><strong>edit by sam</strong> <br />
<strong>Now i want to compare this two values of x and y and selecting value based on comparision</strong></p>

<pre><code>     CurrentTre=256;
     if (x &gt; y)
     {
     *array3[0]= x;
     *array4[CurrentTre +0] = 0;
     }
     else
     {
     *array3[i] = y;
     *array4[CurrentTre + 0] = 1;
     }
     ..........
     ..........
     if (x &gt; y)
     {
     *array3[0]= x;
     *array4[CurrentTre +127] = 254;
     }
     else
     {
     *array3[i] = y;
     *array4[CurrentTre + 127] = 255;
     }
     /////////////
     my approach is this way

     if (x &gt; y)
     {
     *array3[i]= x;
     *array4[int CurrentTre +i] = int number[i]&lt;&lt;1;
     }
     else
     {
     array3[i] = y;
     array4[int CurrentTre + i] = int number[i]&lt;&lt;1|1;
     }
} //end function main
</code></pre>

<p><strong>I want to optimize the code my optimization is  given below 
   please check whether am i doing right or not..?</strong></p>

<pre><code>uint32 even_number[255] ={0};
uint32 loop_index1=0;
uint32 loop_index2=0;

uint16 order[256]={0,7,3,4,6,1,5,2,4,3,7,0,1,6,2,5,7,0,4,3,2,5,1,6,3,4,0
,7,6,1,5,2,4,3,7,0,1,6,2,5,0,7,3,4,5,2,6,1,3,4,0,7,6,1,5,2,7,0,4,3,2,5
,1,6,5,2,6,1,0,7,3,4,1,6,2,5,4,3,7,0,2,5,1,6,7,0,4,3,6,1,5,2,3,4,0,7,1
,6,2,5,4,3,7,0,5,2,6,1,0,7,3,4,6,1,5,2,3,4,0,7,2,5,1,6,7,0,4,3,3,4,0,7
,6,1,5,2,7,0,4,3,2,5,1,6,4,3,7,0,1,6,2,5,0,7,3,4,5,2,6,1,7,0,4,3,2,5,1
,6,3,4,0,7,6,1,5,2,0,7,3,4,5,2,6,1,4,3,7,0,1,6,2,5,6,1,5,2,3,4,0,7,2,5
,1,6,7,0,4,3,1,6,2,5,4,3,7,0,5,2,6,1,0,7,3,4,2,5,1,6,7,0,4,3,6,1,5,2,3
,4,0,7,5,2,6,1,0,7,3,4,1,6,2,5,4,3,7,0}; //all 256 values



for(loop_index1;loop_index1&lt;256;loop_index1++)
   {    
    m0= (CurrentState[loop_index1]+Branch[order[loop_index2]]);
loop_index2++;
loop_index1++;
if(loop_index1&gt;=256) 
break;

m1= (CurrentState[loop_index1]+Branch[order[loop_index2]]);

loop_index2++;

if (mo &gt; m1)
 {
 NextState[loop_index1]= m0;
 SurvivorState[CurrentTrellis + loop_index1] =
 even_number[loop_index1]&lt;&lt;1;
 }
else
{
 NextState[loop_index1] = StateMetric1;
 SurvivorState[CurrentTrellis + loop_index1] = 
  even_number[loop_index1&lt;&lt;1|1;
}
}
</code></pre>
",15
28247463,28247417,1,"<ol>
<li>The <code>typedef</code> is used to simplify the declaration of the array of function-pointers.</li>
<li><p>As <code>funHandlr</code> is a typedef-name, it cannot be called.</p>

<p>Neither can the array of implicit length 3 (<code>arr</code>) be called, as it is neither a function nor a function-pointer.</p>

<p>A value of type <code>funHandlr</code> <em>is</em> a callable function-pointer though.</p></li>
<li><code>const funHandlr arr[] = { ... };</code> defines an array named <code>arr</code> of deduced length (3, from the initializers) of <code>const funHandlr</code>, <code>funHandlr</code> being the type defined above.</li>
</ol>
",6
28247468,28247417,1,"<ol>
<li>The <code>typedef</code> makes it easier for humans to ""parse"" the definition of the function pointer. It serves no other purpose here, because it's used only once.</li>
<li><code>funHandlr</code> cannot be ""called"" because it is a type. An object of type <code>funHandlr</code> (e.g. any of the array elements) can be called in the same way that you call a function pointer.</li>
<li><code>arr</code> is the name of the array of function pointers. When you wish to call a function, apply an index to it, and then put parentheses to make the call.</li>
</ol>

<p>Here is an example of how to call one of the functions based on its index:</p>

<pre><code>int index;
printf(""Which function you wish to call? Enter 0, 1, or 2 &gt;"");
scanf(""%d"", &amp;index);
// Make a call like this:
arr[index](myId, myProc);
</code></pre>

<blockquote>
  <p>What is the use of array of functions if we can <code>fun1</code>, <code>fun2</code>, or <code>fun3</code> directly?</p>
</blockquote>

<p>Consider what would you do to write a program similar to the one above without function pointers. Here is how your code would look:</p>

<pre><code>scanf(""%d"", &amp;index);
switch (index) {
case 0: fun1(myId, myProc); break;
case 1: fun2(myId, myProc); break;
case 2: fun3(myId, myProc); break;
}
</code></pre>

<p>Apart from being repetitive and error-prone, <code>switch</code> statements like this create a maintenance liability in cases when you wish to change the signature of your function. It is not uncommon for arrays of function pointers to grow to more than a hundred items; adding a new parameter to each invocation would require a lot of effort.</p>

<p>With an array of function pointers, however, there is only one call to change. Moreover, the readers of your code would not have to scroll through hundreds of lines in order to understand what is going on.</p>
",1
23554880,23554701,0,"<p>'Change:</p>

<pre><code>      fopen_s(&amp;clientPtr, (recName), ""w"");
</code></pre>

<p>To:</p>

<pre><code>      int rCode=fopen_s(&amp;clientPtr, (recName), ""w"");
      if(rCode)
         {
         fprintf(stderr, ""fopen() returned failure code: %d\n"", rCode);
         exit(0);
         }
</code></pre>

<p>Then you can determine if the file is being successfully opened; and if it is not successfully opened, it will print an error code that will help to further diagnose the problem.</p>

<hr>

<p><B><I>EDIT:</I></B></p>

<pre><code>22   EINVAL   One of the parameters passed into 'fopen_s()' was invalid.
</code></pre>

<p>In the case of the question code, it means that 'fopen_s()' didn't like either &amp;clientPtr or (readName).</p>

<p>My first guess is that something is wrong with (readName).  To verify this is the problem, you might want to (temporarily) change:</p>

<pre><code>int rCode=fopen_s(&amp;clientPtr, (recName), ""w"");
</code></pre>

<p>To something like: </p>

<pre><code>int rCode=fopen_s(&amp;clientPtr, ""testfile.tmp"", ""w"");
</code></pre>

<p>If rCode is '0' instead of '22', the problem is with (recName).</p>

<p>I am guessing that this is the case.  If so, the problem with recName is that it contains a newline <i>'\n'</i> (and perhaps a carriage return <i>'\r'</i>) character at the end.  This is fairly common when using 'fgets()' to get user input.</p>

<p>The <i>'\n'</i> (and <i>'\r'</i>) can be eliminated from 'recName' like by changing this:</p>

<pre><code>...
{
    puts(""\tWhat is the name of the file you want to create?\n "");
    fgets(recName, 20, stdin);
...
</code></pre>

<p>To this:</p>

<pre><code>....
{
    char *cp;

    puts(""\tWhat is the name of the file you want to create?\n "");
    fgets(recName, 20, stdin);

    for(cp=recName, *cp, ++cp)
       if(('\r' == *cp) || ('\n' == *cp))
          *cp='\0';
....
</code></pre>

<p>This should have fixed the 'recName' problem.  Now change the line back and re-test:</p>

<pre><code>    int rCode=fopen_s(&amp;clientPtr, (recName), ""w"");
</code></pre>

<p>And by the way, parenthesis are not needed around 'recname':</p>

<pre><code>int rCode=fopen_s(&amp;clientPtr, recName, ""w"");
</code></pre>
",3
27130174,27129976,0,"<p>It looks as if you're missing a set of <code>{}</code> brackets:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

main()
{
    int c, nl;

    nl = 0;
    while((c = getchar()) != EOF)
    {   // &lt;- This starts the block to be repeated
        if (c == '\n')
        {   // &lt;- This is just to keep the code 'safe' ...
            ++nl;
        }   // &lt;- ... as is this
    }   // &lt;- This ends the block to be repeated
    printf(""The number of New Line characters entered was %d\n"", nl);
}
</code></pre>
",2
27130074,27129976,2,"<p>Apparently the implementation is supposed to count only the number of newline characters, not the number of total characters, as implemented in the <code>if(c=='\n')</code> condition. The program returns <code>0</code> on your input as it does not contain a newline character.</p>
",0
27130121,27129976,0,"<p>might be that the program want to know if the next char <strong>is not</strong> an end of a line ( <code>'\n'</code>) so you'll need:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

main() {
    int c, nl;

    nl = 0;
    while ((c = getchar()) != EOF)
        if (c != '\n')
            ++nl;
    printf(""%d\n"", nl);
}
</code></pre>

<p>this will count the number of <strong>characters</strong>, but there are others escape characters such as <code>'\t'</code> and so i'm not quite sure what the program is supposed to do, but i think that in your book you'll find some more description clarifying that part</p>

<p>for counting the number of lines simply change '/n' to '\n' as you probably know by now</p>
",2
27130128,27129976,3,"<p>Although the immediate problem is a simple case of replacing <code>'/n'</code> with <code>'\n'</code> (i.e. <em>escaping</em> <code>n</code> for the newline character which is what the backslash does), the fact that your code compiles and runs is due to the C99 standard:</p>

<blockquote>
  <p>6.4.4.4p10: ""The value of an integer character constant containing more than one character (e.g., 'ab'), or containing a character or
  escape sequence that does not map to a single-byte execution
  character, is implementation-defined.""</p>
</blockquote>

<p><code>'/n'</code> is a <em>character array</em> consisting of the forward slash and the letter <code>n</code>.</p>

<p>Once you've fixed that, you then will need to make changes to count characters as opposed to just newline characters.</p>
",1
25666856,25666821,5,"<p>Malloc allocates heap space in chunks of your system page size (typically, 4096 bytes), but it only reserved for your use exactly as much as you requested. If you write beyond your <code>malloc</code>ed memory, then you risk corrupting your heap or crashing your program with a segmentation violation.</p>

<p>Only as much memory as you requested is guaranteed to be actually <strong>yours</strong> to use. The block of memory behind the one you requested may be valid, but in use by something else (e.g. <code>stdio</code> library buffers) or reserved for future use (e.g. the next <code>malloc</code> you call).</p>
",0
28511765,28511762,0,"<p>You have to initialize <code>response</code>, try this</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    char response;

    response = 'F';
    while (response == 'F' || response == 'C')
    {
        printf("" Please enter F or C\n"");
        scanf("" %c"", &amp;response);
    }
    return 0;
}
</code></pre>

<p>and you can of course do it this way</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    char response;

    /* since you don't check for `scanf()`'s return value, 
     * this prevents undefined behavior 
     */
    response = 'F';
    do {
        printf("" Please enter F or C\n"");
        scanf("" %c"", &amp;response);
    } while (response == 'F' || response == 'C');
    return 0;
}
</code></pre>
",7
28511766,28511762,0,"<p>Your loop runs as long as <code>response</code> <em>is</em> <code>'F'</code> or <code>'C'</code>. What you need is</p>

<pre><code>while (response != 'F' &amp;&amp; response != 'C')
</code></pre>

<p>Also, <code>response</code> is not initialized. Start with</p>

<pre><code>char response = '\0';
</code></pre>
",1
28511770,28511762,2,"<p><code>response</code> is uninitialized. Your code hasn't even gotten to the <code>scanf()</code> yet. Consider changing it to a <code>do-while</code> loop.</p>
",2
28511868,28511762,0,"<p>There are two common ways to do a terminate-on-input loop in C:</p>

<pre><code>do {
    ...get input...
    do_stuff();
} while (...input does not indicate exit...);
</code></pre>

<p>or</p>

<pre><code>while (1) {
    ...get input...
    if (...input indicates exit...) break;

    do_stuff();
}
</code></pre>

<p>I think the latter might work better for your case:</p>

<pre><code>while (1) {
    printf("" Please enter F or C\n"");
    scanf("" %c"", &amp;response);

    if ('F' == response) {
         do_f();
    } else if ('C' == response) {
        do_c();
    } else {
        break;
    }
}
</code></pre>
",0
34241181,34241149,0,"<p>You can print on a variable width with this syntax:</p>

<pre><code>printf(""%*d"", width, number);
</code></pre>
",1
29239977,29238015,2,"<p>try out this code first. it's a demo code taken from <a href=""http://blog.csdn.net/liuzhanchen1987/article/details/7455208"" rel=""nofollow"">http://blog.csdn.net/liuzhanchen1987/article/details/7455208</a> , which is in <strong>Chinese</strong>:</p>

<pre><code>#include &lt;sys/mman.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;

typedef struct{
    char name[4];
    int age;
}people;

int
main(int argc, char** argv)
{
    int i;
    people *p_map;
    char temp;
    p_map=(people*)mmap(NULL,sizeof(people)*10,PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS,-1,0);
    if(fork() == 0)
    {
        sleep(2);
        for(i = 0;i&lt;5;i++)
            printf(""child read: the %d people's age is %d\n"",i+1,(*(p_map+i)).age);
        (*p_map).age = 100;
        munmap(p_map,sizeof(people)*10);
        exit();
    }
    temp = 'a';
    for(i = 0;i&lt;5;i++)
    {
        temp += 1;
        memcpy((*(p_map+i)).name, &amp;temp,2);
        (*(p_map+i)).age=20+i;
    }
    sleep(5);
    printf( ""parent read: the first people,s age is %d\n"",(*p_map).age );
    printf(""umap\n"");
    munmap( p_map,sizeof(people)*10 );
    printf( ""umap ok\n"" );
    return 0;
}
</code></pre>

<p>expected result:</p>

<pre><code>child read: the 1 people's age is 20
child read: the 2 people's age is 21
child read: the 3 people's age is 22
child read: the 4 people's age is 23
child read: the 5 people's age is 24
parent read: the first people,s age is 100
umap
umap ok
</code></pre>

<p>in which</p>

<pre><code>mmap(NULL,size,PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS,-1,0);
</code></pre>

<p>is <strong>all</strong> what you need to do before forking(and its return value checking code), and its return value will be the allocated pages starting address(if it's valid).</p>

<p>if all processes are forked. it's very handy to just use mmap to allocate anonymous pages, and additionally, there is no side effect after the processes get collected.</p>

<p>if you use <code>shm_open</code>, then in somewhere there will be a share memory object gets created, and it will be the side effect remains in your system, even after all your processes get collected. however, it's necessary when you plan to have two irrelevant processes talk to each other.</p>
",0
26449312,26449287,3,"<p>Would work:</p>

<pre><code>printf(""Your SSID is:"");
for(i=0;id[i] != '\0';i++) { 
  printf(""%c"", 'x');  
}
printf(""\n"") ;
</code></pre>
",2
26449325,26449287,0,"<p>To get the desired output you should do like the following:</p>

<pre><code>printf(""Your SSID is: "");

for(i=0;id[i] != '\0';i++)
{ 
  printf(""%c"", 'x');
}

printf(""\n"");
</code></pre>
",0
27559187,27435379,0,"<p>I suppose you will have an array of 'digits' for the inputs: <code>unsigned int a[num_ints], b[num_ints]</code></p>

<p>It may be easier for you to use <code>unsigned char a[num_digits], b[num_digits]</code> and store the values <code>0-9</code> ONLY in each byte. But this is very wasteful on a 32 bit machine.</p>

<p>The easy way would be to make your inputs <code>a,b</code> global arrays and simply return carry info recursive function.</p>

<p>Then you could do something like this:</p>

<pre><code>void *recursive_op(unsigned char *ptr){
    carry_t *carry_info = recursive_op(ptr-1));
    //do something with the carry_info
}

unsigned char result[num_digits];
unsigned char a[num_digits];
unsigned char b[num_digits];

int main(int argc, char** argv){
    //initialise a and b...
    //memset result to zeros...

    unsigned char *ptr = &amp;result[num_digits-1];
    carry_t *carry_info = recursive_op(ptr);

    //do something to result[0] with your carry_info ptr
}
</code></pre>

<p>Here I'm assuming a great deal about the endianess of your arry (the most significant 'digit' is at <code>numdigits-1</code>, the least significant 'digit' is at <code>0</code>) AND I'm assuming you want to operate on the least sig. digits first (ie, right-to-left like how we are taught at school).</p>

<p>I haven't compiled the code or sanity checked it. It's really just an outline.</p>
",0
28174524,28174460,0,"<p>The easiest method is to use <code>popen()</code>. This opens a pipe to an executable allowing you to write data to it via the executable's stdin. See the <a href=""http://linux.die.net/man/3/popen"" rel=""nofollow"">man page for popen()</a> for full details.</p>
",2
31145086,31145010,3,"<p>Every hexadecimal digit is four bits. Since you got 8 hexadecimal digits your integers seems to be 8*4=32 bit.</p>

<p>The NOT of 32 = <code>000000000000000000000000000010000</code> would be something like <code>11111111111111111111111111101111</code> which would be the hexadecimal digits above.</p>
",2
31145235,31145010,2,"<p>In C, ~ is the bitwise-not operator. You said you understand how this operator works, but your question indicates that you do not. So let's go through this example:</p>

<p>First, you declare m to be an unsigned int, which happens to be 32 bits wide on your platform. You assign it the decimal value 32. The variable m is 0x00000020.</p>

<p>Then, you print it out. When you print it out normally, the expected output appears. But when you print it out with the ~ operator, you get something completely different.</p>

<p>The ~ (bitwise-not) operator does exactly what it says on the tin: It negates (flips) every bit, so 1s become 0s and 0s become 1s. Let's see what that would do to your number:</p>

<pre><code> m = 0b00000000000000000000000000100000 = 0x00000020
~m = 0b11111111111111111111111111011111 = 0xffffffdf
</code></pre>

<p>As you can see, the result exactly matches what is being output, which is good -- it means both your compiler and CPU are working as expected!</p>
",0
27127172,27127013,0,"<pre><code>ergebnis = calculate(char optr, float opr1, float opr2);//Ausgabe

        float Calculate(char optr, float opr1, float opr2)
    {

        switch (optr)
        {
            case '+': return opr1 + opr2;
            case '-': return opr1 - opr2;
            case '*': return opr1 * opr2; 
            case '/': return opr1 / opr2;
            case 'q': return 0f;
            default: return 0f;
        }
    }
</code></pre>

<p>Your ""Calculate function can only return a float""</p>
",0
27127240,27127013,0,"<p>If you problem is about compilation errors please begin by providing an output of these errors.</p>

<p>It probably comes from this part of your code :</p>

<pre><code>float calculate(char optr, float opr1, float opr2) {

switch(optr) {
case '+': ergebnis = opr1+opr2; break;
case '-': ergebnis = opr1-opr2; break;
case '*': ergebnis = opr1*opr2; break;
case '/': ergebnis = opr1/opr2; break;
case 'q': exit(0);
default: cout &lt;&lt;""unbekanntes Rechenzeichen...\n""; return1;
}
return ergebnis;
}
</code></pre>

<p>You didn't define the variable <code>ergebnis</code> before using or return it. Note that's not cause you get the return of this function into a variable called <code>ergebnis</code> from your <code>main()</code> function that you have to call it by the same name into the <code>calculate(...)</code> function.</p>

<p>Plus you don't need to specify parameters types when you call your <code>calculate()</code> function</p>
",0
27127081,27127013,0,"<p>Change</p>

<pre><code>ergebnis = calculate(char optr, float opr1, float opr2);
</code></pre>

<p>to</p>

<pre><code>ergebnis = calculate(optr,opr1,opr2);
</code></pre>

<p>and add <code>float ergebnis;</code> in the <code>calculate</code> function.Also change <code>return1;</code> to <code>return 1;</code>.You also need to place some check to avoid division by zero. You've also used <code>cout</code> instead of <code>printf</code> in the <code>default</code> case.You need to include <code>&lt;stdlib.h&gt;</code> in order to use <code>exit(0);</code></p>
",0
27127082,27127013,0,"<ul>
<li><p>You need space between return and 1 as below:</p>

<p>return 1;</p></li>
<li><p>Need to call method without any type information of parameters like:</p>

<p>ergebnis = calculate(optr,opr1,opr2);</p></li>
<li><p>In your calculator function, you are using as a variable ergebnis but didnt defined it, so you should define it like below:</p>

<p>float ergebnis = 0;</p></li>
<li><p>You are using c, so remove cout and change it with printf.</p></li>
<li><p>As per your error for exit function, you need to include stdlib.h like below</p>

<p>#include </p></li>
</ul>

<p>This should be the overall code:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

float calculate(char optr, float opr1, float opr2) {
    float ergebnis = 0;
    switch(optr) {
    case '+': ergebnis = opr1+opr2; break;
    case '-': ergebnis = opr1-opr2; break;
    case '*': ergebnis = opr1*opr2; break;
    case '/': ergebnis = opr1/opr2; break;
    case 'q': exit(0);
    default: printf(""unbekanntes Rechenzeichen...\n""); return 1;
}
return ergebnis;
}

int main(void) {
char optr;
float opr1, opr2, ergebnis;
//Eingabe
printf(""\nEingabe Operator(+,-,*,/,q)""); scanf(""%c"", &amp;optr);
printf(""\nEingabe Zahl1""); scanf(""%f"", &amp;opr1);
printf(""\nEingabe Zahl2""); scanf(""%f"", &amp;opr2);
//Verarbeitung
ergebnis = calculate(optr, opr1, opr2);//Ausgabe
printf(""\nErgebnis: %f\n"", ergebnis);
return 0;
}
</code></pre>
",0
27127086,27127013,0,"<p>This should work for you. A few things you did wrong:</p>

<ul>
<li><code>exit()</code> is in the library <code>stdlib.h</code></li>
<li>You have a return too much</li>
<li>You forgot to declar <code>ergebnis</code></li>
</ul>

<p>Fixed code:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

float calculate(char optr, float opr1, float opr2) {
    float ergebnis;
    switch(optr) {
        case '+': ergebnis = opr1+opr2; break;
        case '-': ergebnis = opr1-opr2; break;
        case '*': ergebnis = opr1*opr2; break;
        case '/': ergebnis = opr1/opr2; break;
        case 'q': exit(0);
        default: printf(""unbekanntes Rechenzeichen...\n"");
    }
    return ergebnis;
}

int main(void) {
    char optr;
    float opr1, opr2, ergebnis;

    //Eingabe
    printf(""\nEingabe Operator(+,-,*,/,q)""); scanf(""%c"", &amp;optr);
    printf(""\nEingabe Zahl1""); scanf(""%f"", &amp;opr1);
    printf(""\nEingabe Zahl2""); scanf(""%f"", &amp;opr2);

    //Verarbeitung
    ergebnis = calculate(optr,  opr1,  opr2);//Ausgabe
    printf(""\nErgebnis: %f\n"", ergebnis);
    return 0;
}
</code></pre>

<p><strong>EDIT:</strong></p>

<p>Also i would recommend you from german to german ;D To program with english words! (e.g. result, input, output and so on) So more people can understand your code and understand it faster!</p>
",3
26228280,26228250,1,"<p>Try like this... Do Initialize every element as ASCII <code>char</code>... In elements <code>\</code> should be <code>\\</code> ..</p>

<pre><code>char a[]={  '[',']','{','}','(',')','\\' };
</code></pre>
",2
26228312,26228250,1,"<pre><code>char chars[] ={ '[', ']', '{', '}', '|', '\\', '(', ')', '*', '+', '$', '^', '.', '?' };
</code></pre>

<p>or</p>

<pre><code>const char *p =""[]{}|\\()*+$^.?"";
</code></pre>
",0
33022787,33022401,1,"<p>I have annotated various corrections to your program. It now works, although it does not seem to do anything very useful. In fact it always tells me <em>""Salario menor que 0!""</em></p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;limits.h&gt;                                 // added header

int main(void)
{
    int idade=0, salario=0, maior=INT_MIN, menor=INT_MAX, somasalario=0; 
    char sexo=' ', estadoc=' ';                     // initialised variables

    do { 
        printf(""Insira a sua idade: "");
        if (scanf(""%d"", &amp;idade) != 1)
            return 1;                               // input error
        if (idade &gt; maior) {
            maior = idade;
        }
        if (idade &lt; menor) {
            menor = idade;
        }

        printf(""Insira o seu salario: "");
        if (scanf(""%d"", &amp;salario) != 1)
            return 1;                               // input error
        somasalario += salario;

        printf(""Introduza o seu sexo: "");
        if (scanf("" %c"", &amp;sexo) != 1)               // added space to clean input
            return 1;                               // input error
        printf(""Introduza o seu estado civil: "");
        if (scanf("" %c"", &amp;estadoc) != 1)            // added space to clean input
            return 1;                               // input error

        printf(""Salario menor que 0!\n"");           // added newline
    } while(idade !=-1); 

    printf(""idade maior: %d\n"", maior);             // added newline
    return 0;
}
</code></pre>
",1
23554681,23554637,1,"<p>Even though you don't plan on using the characters of the alphabet from the file, you still need to add the code to read the characters. Otherwise, trying to read the numbers will be stuck at the next letter.</p>

<pre><code>char ch;

// ....

fscanf(values,""%c %d"", &amp;ch, &amp;vec[i]);
</code></pre>
",1
23554763,23554637,1,"<p>This should help you:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

void readvalues(FILE *values);

FILE *datafile;
int vec[26];

int main()
{

    datafile = fopen ( ""my.txt"", ""r"");
    readvalues(datafile);


    return 0;
}

void readvalues(FILE *values)
{
    char tmp[2];
    if (values == NULL) 
    { 
        printf(""Couldn't open values' file\n""); 
        exit(0); 
    } 

    int i=0;

    while (i&lt;26) 
    {   
        if(fscanf(values,""%s %d"",tmp,&amp;vec[i]));
        printf(""%d\n"",vec[i]); 
        i++;
    }
}
</code></pre>
",2
23567235,23554637,0,"<p>Instead looping with a fixed value of 26, you may want to consider looping line-by-line until the data in the file is gone:</p>

<pre><code>int getdata(FILE *ifp, int *data){
    char buf[256];    // potential size of leading string
    int i=0;          // offset into data array

    while (fscanf(ifp, ""%s %d"", buf, &amp;data[i]) != EOF) {
        i++;   
    }    
    return i;         // return how many ints were read and processed
}
</code></pre>

<p>Then your file can have 2 lines or 2 million. You only need to make sure that <code>data</code> is large enough -- either by making that use dynamic memory or precounting the lines in the file.  </p>
",0
27129389,27129006,1,"<p>Floating point math is still available without <code>math.h</code>¡ªyou just don't have access to the functions it provides. You can still do basic operations like <code>1.0 + 1.0</code>.</p>

<p>Have a look at how to compute the <em>exponential</em> and <em>logarithmic</em> functions (to base e) and then compute <em>x</em><sup><em>y</em></sup> using the identity</p>

<blockquote>
  <p><em>x</em><sup><em>y</em></sup> = exp(<em>y</em> ¡¤ ln <em>x</em>).</p>
</blockquote>
",4
26116828,26116559,1,"<p>You are calling the function correctly. Unless it returns INVALID_HANDLE_VALUE, there should be an available port. Note that this might include USB ports!</p>

<p>Also please note that for COM port 10 and above, you need to open them with the command <code>\\.\\COMn</code>, which corresponds to the C string <code>\\\\.\\COMn</code> (where n is the 1 or 2 digits specifying the COM port number). See <a href=""http://support2.microsoft.com/kb/115831"" rel=""nofollow"">http://support2.microsoft.com/kb/115831</a>.</p>
",0
29190584,29190120,2,"<p>One problem is in allocating your node structures:</p>

<pre><code>root = (struct node *)sbrk(sizeof(root));
...
added = (struct node *)sbrk(sizeof(root));
</code></pre>

<p>Should be:</p>

<pre><code>root = (struct node *)sbrk(sizeof(*root));
...
added = (struct node *)sbrk(sizeof(*root));
</code></pre>

<p>At best, your nodes and your allocations would ""share"" memory incorrectly.</p>

<p>Also, I think you need to be careful to ensure proper alignment of your memory.  I'm not sure your code (or <code>sbrk</code>) does that.</p>

<p>Here's a problem with your splitting code:</p>

<pre><code>return best+sizeof(best);
...
newnode = best+best-&gt;mallocsize+sizeof(root);
</code></pre>

<p>Since <code>best</code> is a <code>struct node*</code>, these additions jump further ahead in memory than I think you intended.  I think you meant to cast <code>best</code> to a <code>(char*)</code> in these expressions.</p>

<p>Also, I think the computation for <code>newnode</code> is wrong, even after you cast to <code>(char*)</code>.  I think you want something more like:</p>

<pre><code>newnode = best + 1 + size / sizeof(*root) + !!(size % sizeof(*root));
</code></pre>

<p>You also forget to compute and set <code>newnode-&gt;mallocsize</code>!</p>

<p>The following math probably will be done in unsigned (i.e. - <code>int</code>'s promoted to <code>size_t</code>'s):</p>

<pre><code>if (best-&gt;mallocsize-size-sizeof(short) &lt; sizeof(root)) {
</code></pre>

<p>In that case, you can underflow 0 on the left hand side, which will cause you to improperly split the node.  You can fix this by throwing the subtraction over to the other side of the inequality because you already ensured that <code>size &lt; best-&gt;mallocsize</code>:</p>

<pre><code>if (best-&gt;mallocsize - size &lt; sizeof(root) + sizeof(short)) {
</code></pre>

<p>Couple of other points:</p>

<ul>
<li>In your best fit search, you almost always skip over the root for some reason.</li>
<li>In your best fit search, you don't consider unused node's whose <code>mallocsize</code> equals <code>size</code>.</li>
<li>In your best fit search, once you find an optimally sized unused node (i.e. - <code>size == current-&gt;mallocsize</code>), end the search (i.e. - break the loop).</li>
<li><strong>In your allocations you call <code>sbrk</code> twice: once for your node and once for the application's memory.  If you are doing this to ensure proper alignment of memory, then that's good (assuming <code>sbrk</code> does this for you), but then your assumption that a <code>node + 1</code> gives you the address of the application's memory may not be true.</strong></li>
</ul>
",5
27179657,27179581,-1,"<p>use:</p>

<p>while ((c = fgetc(file )) != EOF) and do fputc to file2 not to same file!!</p>
",2
27179672,27179581,0,"<pre><code>char c;  
long pos;  
pos = ftell(file);
c=fgetc(file);
while (c!=EOF) {
    fseek(file, pos, SEEK_SET);
    fputc(++c, file);
    fflush(file);
    pos = ftell(file);
    c=fgetc(file);  
}  
</code></pre>
",10
33025102,33024456,0,"<p>This line</p>

<pre><code>result_array = hex2binary(baseNumber, count, size);
</code></pre>

<p>is incorrect because this function needs a pointer argument</p>

<pre><code>int* hex2binary(int hex_array[], int input_array_size, int* return_array_size)
</code></pre>

<p>So it should be called like this</p>

<pre><code>result_array = hex2binary(baseNumber, count, &amp;size);   // note the &amp;
</code></pre>

<p>Then the subsequent loop</p>

<pre><code>for (j = 0; j &lt; size; j++)
</code></pre>

<p>will no longer be using the <em>uninitialised variable</em> <code>size</code>.</p>
",1
26789601,26789394,0,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#include &lt;math.h&gt;

void application(void)
{
    int input = 0;
    float number[10];
    float total =0;
    float *ptr;
    float generatedNum; 

    srand(time(NULL));


    for(; input&lt;10; input++)
    {   
        generatedNum = 2 *(float)rand()/(float)RAND_MAX - 1;


        printf(""\n\n\t\tEnter number %d : "", input);
        scanf(""%f"", &amp;number[input]);
        ptr = number;

        printf(""\n\t\t\t\t\tMachine Value: %.1f"", generatedNum);

    }

    for(input = 0; input&lt;10; input++)
    {
        total += *ptr;

        ptr++;

    }
    printf(""\n\n\n\t\tTHE NEURON IS: %.2f"", total);

}

int main(int argc, char *argv[]) 
{
    application();

    return 0;
}
</code></pre>

<p>your array will get out of bound if you go for <code>&lt; 11</code> because it might contain 10 position but it's starting at 0.</p>

<p>Also the first loop manipulates your <code>input</code> variable which is then higher than the required condition of your second loop.
So you need to set it back to 0.</p>

<p><a href=""http://ideone.com/xkNJTf"" rel=""nofollow"">Working example!</a></p>
",2
26789913,26789394,0,"<p>An easier solution is to simply keep everything in one loop. There really isn't a need for a pointer in this situation as nothing requires them, add the values as you get them. Also you never use the generatedNum (although maybe this is for further development??)</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#include &lt;math.h&gt;

void application(void)
    {
    int input = 0;
    float number[10];
    float total =0;
    float generatedNum; 

    srand(time(NULL));


    for(; input&lt;10; input++)
    {   
        generatedNum = 2 *(float)rand()/(float)RAND_MAX - 1;


        printf(""\n\n\t\tEnter number %d : "", input);
        scanf(""%f"", &amp;number[input]);
        total += number[input];

        printf(""\n\t\t\t\t\tMachine Value: %.1f"", generatedNum);
    }    
    printf(""\n\n\n\t\tTHE NEURON IS: %.2f"", total);
    return;

}

int main(int argc, char *argv[]) 
{
    application();

    return 0;
}
</code></pre>
",4
28533543,28533442,1,"<p>You declare <code>x</code> as a pointer, you should not do that if you don't know what a pointer is, your code would work if you make the pointer point to a valid location, to do that you can use the <code>malloc()</code> function so, this</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    int *x;
    x = malloc(sizeof(int));
    if (x == NULL)
        return -1;
    /* use x here */
    *x = 10;
    /* release memory */
    free(x);

    return 0;
}
</code></pre>

<p>in your code, the pointer <code>x</code> is not pointing to valid memory so it invokes undefined behavior, and that is the cause of the garbage value.</p>

<p>Pointers are a very important part of the c language, and I think you need to search for a basic tutorial on pointers.</p>

<p>This for example will also be valid</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    int *x;
    int  y;

    x  = &amp;y;
    *x = 10;

    printf(""%d\n"", y);

    return 0;
}
</code></pre>

<p>the above program will output <code>10</code> the pointer <code>x</code> is pointing to the address where <code>y</code> is stored, so modifying it, will also modify <code>y</code>.</p>
",1
23610627,23610457,4,"<p>Read it all into a string with <code>fgets()</code>.</p>

<p>If you just want everything they enter to be a single <code>int</code>, walk the string and look for <code>isdigit()</code> on each char and then when you find that it is all just digits, call <code>strtod()</code>, if not, emit an error and re-prompt.</p>

<p>If you want multiple things parse from the same input line, then you need to parse the string with something like <code>strtok()</code> to get individual tokens one at a time, then look at each token and determine if it is a number by looking to see if each character <code>isdigit()</code> or is equal to <code>'-' '.'</code> and suchlike.  If so, parse it as a number with <code>strtol()</code> or <code>strtod()</code> (etc) (depending on what you see, int or float/double.) Otherwise, parse the token as a string or emit an error. </p>
",0
28226695,28226661,4,"<p>You need to dereference <code>p</code> and remove the <code>&amp;</code> address operator from <code>b</code></p>

<p>This assigns the value of <code>b</code> to the address where <code>p</code> points to:</p>

<pre><code>void f(int* p) 
{
    *p = b;
}
</code></pre>

<p>The reson why it printed <code>1</code> and not e.g. the address of <code>b</code> is that you assigned: <code>p = &amp;b</code> which just assigns the address of <code>b</code> to the local pointer variable <code>p</code>. This means it <strong>does not</strong> point to <code>a</code> anymore here. But since this was just a local copy it didn't change the value of the <code>p</code> you passed in <code>main()</code>.</p>

<p>This makes it a little more obvious:</p>

<pre><code>void f(int* ptr) 
{
    // assign a value
    *ptr = 1337;
}

int main() 
{ 
    int local_integer = 666;

    // prints ""666""
    printf(""%d\n"", local_integer);

    f(&amp;local_integer);

    // prints ""1337""
    printf(""%d\n"", local_integer);
}
</code></pre>
",3
28226738,28226661,0,"<p>In your code you define a pointer to int on the stack. Its value is the same as the pointer in the <code>main()</code> function which happens to point to the ?ddress of the variable <code>a</code>. Then you change its value (so the pointer on the stack now points to <code>b</code>) then you just drop that pointer.</p>

<pre><code>void f(int* p) {
    p=&amp;b;
}
</code></pre>

<p>That is why if you dereference the pointer in <code>main</code> it still points to the address of the int variable <code>a</code>.</p>
",0
26413476,26413388,1,"<p>You should assign a char, not a string:</p>

<pre><code>toP[i] = ' ';
</code></pre>

<p>as your <code>"" ""</code> in the right hand side of the assignment is an array of two chars (<code>' '</code> and <code>'\0'</code>), i.e. you are actually trying to assign a <code>char *</code> pointer to an element of <code>toP</code> array which is <code>char</code>.</p>
",2
28243026,28242976,0,"<p>Just change these two printf statements:</p>

<pre><code>printf(""  "");
//...   ^^ Note 2 spaces
printf(""* "");
</code></pre>

<p>to this:</p>

<pre><code>printf("" "");
//...
printf(""*"");
</code></pre>

<p>And change your function call to this:</p>

<pre><code>drawTriangle(3);
           //^ If you want 3 layers and not 5
</code></pre>
",4
28243120,28242976,0,"<p>If I understand well, you want your function <code>drawTriangle(int size)</code> to draw a base of <code>size</code> asterisks.</p>

<p>If so, then you should change how the whole loops work. Your function should stop once it has printed <code>size</code> asterisks on a single line, and not when you have printed <code>size</code> lines.</p>

<p>Also, as mentioned in comments and other answers, if you want the output to look exactly like the one you put, then you should remove the trailing space in <code>printf(""* "");</code>.</p>
",0
26793209,26793079,0,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

char encrypt(char in, int key)
{
    if (isalpha(in))
    {
        if (isupper(in))
        {
            return (((in-'A') + key) % 26) + 'A';
        }
        else
        {
            return (((in-'a') + key) % 26) + 'a';
        }
    }
    else return in;
}

int main()
{
    int key;
    char ch, res;
    int checksum = 1;

    printf(""Enter shift amount (1-25):\n"");
    scanf(""%d"", &amp;key);

    printf(""Enter message to be encrypted:\n"");
    getchar();

    while (ch != '\n')
    {
        ch = getchar();
        res = encrypt(ch, key);
        if(checksum) { checksum = 0; printf(""Encrypted message: ""); }
        putchar(res);
    }
    return 0;
}
</code></pre>

<p>I would use that way. If you don't like it.. let me know.
I just solved it on a way that won't violate your code structure.</p>

<hr>

<p>Your problem is putting the <code>printf</code> statement inside a loop. The loop will parse your <code>printf</code> statelement ? times , until <code>ch</code> equals new line. To prevent that you can use a variable outside the scope, initialized with a value for example <code>1</code>. To parse the <code>printf</code> statement once you do a condition if that variable equals its number and then assign 0 or another number to it. So in the next time the <code>printf</code> has to be parsed, it won't go, because the condition will be false.</p>
",0
27139152,27139126,4,"<ol>
<li><p>Generate a random number <code>i</code> in the range [0, 11).*</p></li>
<li><p>Define <code>const unsigned int a[11] = { 0, 1, 2, 3, 4, 5, 8, 9, 10, 11, 12 };</code></p></li>
<li><p>Return <code>a[i]</code>.</p></li>
</ol>

<p><sub>*) This is probably a lot harder than you think, depending on what you think you're achieving.</sub></p>
",4
33511458,33511363,2,"<p>Every call of rand() returns a <em>new</em> random number. The result of the check within the while() statement is unrelated to the result that you print out. The smallest change to your code (not the best) I can think of to make it working right is something like:</p>

<pre><code>int r1 = rand()%7;
int r2 = rand()%7;
while ( r1+r2!=totalSought ) {
    count++;
    printf(""Result of the throw %d: %d \n"",count, r1 + r2);
    r1 = rand()%7;
    r2 = rand()%7;
}
</code></pre>
",2
33512076,33511363,1,"<p>Sometimes it is nice to create a function that handles the dice roll rather than mistakenly ""re-rolling"" when its time to print.</p>

<p>Also a little performance improvement: generate a random number 0 to 35 and then break into 2 6-sided dice.</p>

<pre><code>int SumOf2Dice(int *d1, int *d2) {
  int d36 = rand()%36;
  *d1 = d36/6 + 1;
  *d2 = d36%6 + 1;
  return *d1 + *d2;
}

 ....

 int d1, d2;
 while (SumOf2Dice(&amp;d1, &amp;d2) != totalSought) {
   count++;
   printf(""Result of the throw %d: %d\n"",count, d1 + d2);
 }
</code></pre>
",0
29505122,29505086,5,"<p>You're printing an ASCII digit as an integer. The ASCII value of <code>'4'</code> is <code>52</code>. Change to:</p>

<pre><code>    fprintf(stdout, ""%c    Simple Numeral\n"",buffer[i]);
</code></pre>

<p>Your typecast in the call to <code>isdigit()</code> is completely unnecessary (and unrelated).</p>
",0
29505129,29505086,1,"<p>You're getting <code>52</code> because that's the ASCII code point<sup>1</sup> for the character <code>'4'</code>, as per the following graphic:</p>

<p><img src=""https://i.stack.imgur.com/OV2Po.gif"" alt=""enter image description here""></p>

<p>If you want to print it as a character, you should be using <code>%c</code> rather than <code>%d</code> in your <code>printf</code> statement:</p>

<pre><code>fprintf(stdout, ""%c    Simple Numeral\n"",buffer[i]);
</code></pre>

<blockquote>
  <p>As an aside, I'm not entirely certain why you're using <code>fprintf(stdout,...</code> rather than just <code>printf(...</code>. The latter is functionally identical and would result in a lot less typing on your part.</p>
</blockquote>

<hr>

<p><sup>1</sup> ASCII isn't <em>required</em> by the standard but it's by far the most common and, more importantly here, what <em>you</em> appear to be using.</p>
",1
26443725,26443664,1,"<p>Because it is an infinite loop...</p>

<pre><code>while(number != 0)
{
    if(number % 2 == 0)
    { evencount = evencount + 1;
        evennum += number; }
    else
    { oddcount = oddcount + 1;
        oddnum += number; }
}
</code></pre>

<p>Here,your while-loop guiding variable <code>number</code> never gets modified in-between the iterations which keeps it unchanged and hence,the while condition remans true for-ever...</p>

<p><strong><em>Probable solution</em></strong> seems to be :-</p>

<pre><code>int number=1;     // just for initialisation with a non-zero number...
while(number != 0)
{
  printf(""Enter a number or enter 0 to stop: "");
  scanf_s(""%i"", &amp;number);
    if(number % 2 == 0)
    { evencount = evencount + 1;
        evennum += number; }
    else
    { oddcount = oddcount + 1;
        oddnum += number; }
}
</code></pre>
",6
26443729,26443664,1,"<p>You aren't reading new numbers in after the first one.  Try something like</p>

<pre><code>while( scanf(""%d"", &amp;number) == 1 &amp;&amp; number != 0){
//Count evens and odds
}
</code></pre>

<p>Another way you could handle this would to be to add another scanf at the end of your while loop</p>
",2
29204816,29204591,2,"<p>Your problem maybe with the excess <code>\n</code>s present in your inputs to <code>sprintf()</code>. </p>

<ul>
<li><code>fgets()</code> scans and stores the <code>\n</code> from the <code>stdin</code>. You need to get rid of that <code>\n</code> and replace that with a null.</li>
<li><code>asctime()</code> returns a <code>ctime()</code> return style string, again ended with a newline <code>\n</code>. You need to remove (replace) that too.</li>
</ul>

<p>You can check the following code for your reference.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;time.h&gt;

#define MAXLEN 100


char *now(){
    time_t t;
    time(&amp;t);
    return asctime(localtime(&amp;t));
}

int main(int argc, char *argv[])
{
    char comment[80] = {0};
    char cmd[120] = {0};
    char * timestring = NULL;   //initialize local variables, good practice

    fgets(comment, 80, stdin);
    comment[ strlen(comment) -1] = 0;       //reomve the trailing \n taken by fgtes(), replace by null

    timestring = now();
    timestring[strlen(timestring)-1] = 0;   //remove the \n from ctime() return style string, replace b null

    sprintf(cmd, ""echo '%s %s' &gt;&gt; report.log"", comment, timestring);

    printf(""&gt;&gt; The string is : %s\n"", cmd); 

    system(cmd); // should work now.. :-)

    return 0;
}
</code></pre>
",0
29502262,29502093,1,"<p>You wanted:</p>

<pre><code>timeUpdate (orig);
</code></pre>

<p>instead of:</p>

<pre><code>timeUpdate (struct dateAndTime orig);
</code></pre>

<p>This is the same way you don't write <code>printf(const char* ""Hello world!"")</code> or <code>int x = 1; int y = 2; add(int x, int y)</code>.</p>
",0
27493317,27493056,1,"<p>Just from a quick inspection of your code, I can see that in <code>initDeck</code>, you <code>malloc</code> 52 cards, but I don't see any calls to <code>free</code> anywhere.  I would expect that somewhere in <code>Play</code>, you should be freeing cards as they get ""used up"".  So you were right, there is indeed a memory leak.</p>
",1
26125394,26125374,4,"<p>No, you can't do that.  <code>&amp;i</code> yields an rvalue, which can't be used with the <code>++</code> operator, just as the compiler is telling you.  If you want to point to the memory just past the end of <code>i</code>, you can use:</p>

<pre><code>int i = 10;
int *p = &amp;i + 1;
</code></pre>

<p>But there's not really any reason to do such a thing.</p>
",0
34249219,27410907,1,"<p>If you want to use <a href=""https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol"" rel=""nofollow"">HTTP</a> requests to fetch programatically some web pages from a C program, you'll need a C HTTP client library. Conversely, if you want your C program to act as some specialized web server, you need a C HTTP server library.</p>

<p>I recommend:</p>

<ul>
<li><p><a href=""http://curl.haxx.se/libcurl/"" rel=""nofollow"">libcurl</a> as a good HTTP client library usable in C</p></li>
<li><p><a href=""https://www.coralbits.com/libonion/"" rel=""nofollow"">libonion</a> as a good HTTP server library usable in C</p></li>
</ul>
",0
26144193,26142602,0,"<p>This is ok?</p>

<pre><code>#include &lt;stdio.h&gt;

int main(int argc, char **argv)
{
    int g1,m1,s1; //timp 1
    int g2,m2,s2; //timp 2 
    int g,m,s,mt,gt; //calcule
    printf(""Interval1:""); scanf(""%d%d%d"",&amp;g1,&amp;m1,&amp;s1);
    printf(""Interval2:""); scanf(""%d%d%d"",&amp;g2,&amp;m2,&amp;s2);
    if(s1&lt;s2 &amp;&amp; m1&lt;m2) {
        s=(s1+60)-s2;
        mt=m1-1;
        m=mt-m2;
        g=g1-g2;
        m=(m1+60)-m2;
        gt=g1-1;
        g=gt-g2;
    } else if(s1&lt;s2) {
        s=(s1+60)-s2;
        mt=m1-1;
        m=mt-m2;
        g=g1-g2;
    } else if(m1&lt;m2) {
        m=(m1+60)-m2;
        gt=g1-1;
        g=gt-g2;
        s=s1-s2;
    } else {
        m=m1-m2;
        s=s1-s2;
        g=g1-g2;
    }

    printf(""%d %d %d"",g,m,s);
    return 0;
}
</code></pre>
",1
26144473,26142602,0,"<p>Less complicated:</p>

<pre><code>secs2gms(gms2secs(g1, m1, s1) - gms2secs(g2, m2, s2), &amp;g, &amp;m, &amp;s);

...

long gms2secs(int g, int m, int s) {
    return g * 3600L + m * 60 + s;
}

void secs2gms(long secs, int *g, int *m, int *s) {
    *s = secs % 60;
    secs /= 60;
    *m = secs % 60;
    *g = secs / 60;
}
</code></pre>
",1
26145881,26145691,-1,"<p>There are a couple of problems in this code:</p>

<ol>
<li>Your <code>i</code> value variable is uninitialized</li>
<li>If the garbage value of <code>i</code> is non zero its an infinite loop</li>
<li>In the if condition you need to do a logical operation </li>
<li>You are using <code>scanf()</code> not with pointer you use are using pointer to pointer </li>
</ol>
",0
26145888,26145691,1,"<p>Even if you're a beginner, you should still take the effort to tell us which lines are giving you errors, since it's not easy to tell exactly what line is number 19.</p>

<p>I think this line is giving you trouble.</p>

<pre><code>if (numbers, point){    // bad
</code></pre>

<p>You probably meant to call some function that takes <code>numbers</code> and <code>point</code> as an argument.  As it is right now, this if statement will always evaluate to true because you are using the comma operator, which just uses the value of the thing on its right, which happens to be a non-null pointer (<code>point</code>).  How about something like:</p>

<pre><code>if is_a_prime(numbers, point)
</code></pre>

<p>Moving on, the line that actually is causing the error is most likely this line:</p>

<pre><code> else if ((numbers &lt;= 0) || (numbers &gt;= 41)){    // bad
</code></pre>

<p>Since <code>numbers</code> is an array, it doesn't make much sense to write <code>numbers &lt;= 0</code>.  Perhaps you meant to write <code>numbers[0] &lt;= 0</code>, or <code>*point &lt;= 0</code>, or maybe you wanted to use a <code>for</code> loop to iterate over each number in the array to make sure it is positive.</p>

<p>Also, (thanks to isedev for seeing this), you never set <code>i</code> to any value before accessing it, so your program will have undefined behavior.  Try writing something like <code>i = 1;</code> near the top.</p>
",3
26146161,26145691,0,"<p>First of all, this program will most likely not run. Specifically because you are saying <code>while (i)</code> when i is uninitialized (i.e garbage). It might be zero or any other value its initial address happens to point to.</p>

<p>Secondly, what do you mean by <code>if (numbers, point)</code> ? That doesn't mean anything.<br>
Also, <code>point</code> <b>is</b> <code>numbers</code>, so there's no reason to compare them.</p>

<p>Thirdly, if you want to check for a prime number use the modulo operator. Like <a href=""https://stackoverflow.com/questions/1538644/c-determine-if-a-number-is-prime"">this</a>.</p>

<p>Lastly, a pointer <b>is not</b> an integer or an array. When you say <code>point = numbers</code> that just stores the address of <code>numbers</code> in memory into <code>point</code>, and using pointer arithmetic (and because <code>pointer[3]</code> and <code>array[3]</code> mean the same thing ~ <code>pointer + (3 * sizeof(datatype))</code>), you might think that a pointer is an array, but it's <b>not</b>. Here's an example:</p>

<pre><code>int h, *p;
h = 5;
*p = &amp;h;
printf(""*p: %d\n"", *p);
h = 8;
printf(""*p: %d\n"", *p);
</code></pre>

<p>Here, <code>*p</code> is the value of <code>h</code>, and for a really simple reason.<br>
<code>p</code> stores the address of <code>h</code> in memory, and when you say <code>h = 5</code> the computer changes the value <b>found at the address of</b> h in memory. And because <code>p</code> happens to store the address itself in it, it can simply get the value <b>found there</b>. In short, <code>p</code> has no relation to <code>h</code>, dot.</p>
",0
27556042,27411492,3,"<p><code>scanf(""%d"", &amp;newcard);</code> and <code>scanf(""%d"", &amp;stay);</code> are a problem as the variables are <code>bool</code>, but the format specifier is for <code>int</code>.   In 2 places, change like:</p>

<pre><code>// scanf(""%d"", &amp;newcard);
int t;
scanf(""%d"", &amp;t);
newcard = !!t;
</code></pre>

<p>3 functions return <code>int</code> but do not return anything.  Change to void functions.</p>

<pre><code>// int main_hand() {
void main_hand() {    
</code></pre>

<p>There appears to be other logic issues too.<br>
1) Code sometimes exists without knowing if won/loss<br>
2) @Jongware comment above correct:</p>

<p>Lastly: If the same random sequence is still coming up, strip code to a bare <code>main srand time  printf rand</code> and see if that works.  <code>time()</code>, if not working always returns -1.<br>
Or simple add the following and verify <code>srand()</code> called with different values.</p>

<pre><code> int main(void) {
   unsigned now = (unsigned) time(NULL);
   printf(""now = %u\n"", now);
   srand(now);
</code></pre>
",8
28463176,28463123,0,"<p>Generally, an expected ';' error means you are missing a semi-colon.
If you look at line 10, you are missing the semi-colon after if(1) and after the print statement.</p>
",0
28463197,28463123,0,"<p>After <code>else</code> should NOT be ( 2 ). Else has not additional conditions, and is just the optional part of <code>if</code></p>
",0
28463232,28463123,1,"<p>Here's a list of all compilation errors I found.</p>

<p>The first problem is on this line:</p>

<p><code>printf ( ""What do you want to do? (1/2) \n 1. Fahrenheit to Celcius \n. 2. Celcius to Fahrenheit \n. ""</code></p>

<p>You're missing a closing parentheses and a semicolon.</p>

<p>Another is here:</p>

<p><code>printf ( ""Enter Fahrenheit \n."" )</code></p>

<p>you missed a semicolon at the end.</p>

<p>Another problem is in this line:</p>

<p><code>else ( 2 )</code></p>

<p><code>else</code> doesn't have a condition block like <code>if()</code>, so <code>( 2 )</code> is treated like the statement that needs to execute in case the condition in the <code>if</code> your <code>else</code> belongs to isn't satisfied. However, it misses a ';' at the end, hence the error. The block enclosed by <code>{ }</code> doesn't relate to your <code>else</code> at all.</p>

<p>Here's another:</p>

<p><code>printf ( ""The temperature in Fahrenheit is %d \n, Fahrenheit );</code> you're missing a closing <code>""</code> in your string literal.</p>

<p>Generally, even if you correct all of these mistakes, your code still will not do what you expect it to. I suggest you sit down with a good book or beginner's tutorial on programming before trying to code.</p>
",0
28463290,28463123,0,"<p>you need ; after printf on line 10</p>
",0
31193118,31193088,5,"<p>That's done by the process of <em>linking</em>. Individually compiled translation units have a way of referring to dependent names symbolically, so your code would only say ""call a function with name 'printf'"", and it is the job of the linking procedure to look up those symbols in one of the provided object or library files.</p>

<p>The standard library is usually linked against your code implicitly, so you may not be aware of the fact that you are linking your code with pre-existing library code. You would definitely be aware of this if you used your own libraries.</p>

<p>Note that there is no standard for linking, so you cannot generally compile one file with one compiler and another file with a different compiler and then link them together. The problem is not just to agree on how <em>names</em> are represented, but also on how to generate code for function calls. There are however several ""informal"" <em>calling conventions</em> and <em>name mangling rules</em> on popular platforms that offer a degree of interoperability.</p>
",4
29903962,29903947,5,"<blockquote>
  <p>Does gcc initializes auto variable to 0? </p>
</blockquote>

<p>Yes and No!<br>
Actually uninitialized auto variables get <strong>indeterminate value</strong> (either an unspecified value or a trap representation<sup><strong>1</strong></sup>).  </p>

<p>Using such variables in a program invoke undefined behavior-- <em>behavior, upon use of a nonportable or erroneous program construct or of erroneous data,
for which ANSI C International Standard imposes no requirements.</em> (C11:¡ì3.4.3)  </p>

<p>Once UB is invoked you may get either expected or unexpected result. Result may vary run to run of that program, compiler to compiler or even version to version of same compiler, even on temperature of your system!   </p>

<hr>

<p><sub> <strong>1</strong>. An automatic variable can be initialized to a trap representation without causing undefined behavior, but the value of the variable cannot be used until a proper value is stored in it. (<strong>C11: 6.2.6 Representations of types--Footnote 50</strong>)</sub> </p>
",3
29904021,29903947,0,"<p>Variables declared inside a function are uninitialized. One cannot predict what might show up if you print them out. in your example <code>main</code> is a function too. Hence it so happens that it is zero.</p>

<p>When you declare variable to be static or gloabally, the compiler will have them initialzed to zero.</p>
",0
29904109,29903947,1,"<p>No, I get random values with gcc (Debian 4.9.2-10) 4.9.2.</p>

<pre><code>ofd@ofd-pc:~$ gcc '/home/ofd/Destkop/test.c' 
ofd@ofd-pc:~$ '/home/ofd/Desktop/a.out' 
-1218415715
ofd@ofd-pc:~$ '/home/ofd/Desktop/a.out' 
-1218653283
ofd@ofd-pc:~$ '/home/ofd/Desktop/a.out' 
-1218845795
</code></pre>
",5
29905210,29903947,0,"<p>It has become standard security practice for freshly allocated memory to be cleared (usually to 0) before being handed over by the OS.  Don't want to be handing over memory that may have contained a password or private key!  So, there's no guarantee what you'll get since the compiler is not guaranteeing to initialize it either, but in modern days it will typically be a value that's consistent across a particular OS at least.</p>
",0
28503235,28503171,3,"<p>This is because you cannot use <code>==</code> to compare values of C strings. The proper way of doing it is <a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/strcmp.html"" rel=""nofollow""><code>strcmp</code></a>.</p>

<p>Instead of this</p>

<pre><code>sm.fruit1.face == sm.fruit2.face
</code></pre>

<p>you need to write this:</p>

<pre><code>strcmp(sm.fruit1.face, sm.fruit2.face) == 0
</code></pre>

<p><code>strcmp</code> returns a negative number when the first string is ahead of the second string in lexicographic order, and a positive number when it is behind it. When the two strings are equal, zero is returned. That is the reason behind the <code>== 0</code> part of the equality check. You can use <code>!strcmp(a, b)</code> as a shortcut as well.</p>
",1
28494079,28493819,1,"<p>The problem is by the time your <code>total_data_points()</code>, <code>negative_sum()</code>, etc functions are called, the only data you have left is the most recent call of <code>data_cb(5)</code>. The internal state simply is keeping <code>a = 5</code>.</p>

<p>Instead, you need to update something(s) to keep track of the statistics <em>as you receive data</em>. I would imagine the stipulation of ""you cannot use an array"" in the exercise is to make sure you are processing the data as a stream instead of just holding on to all of it in memory. Thus you would need to do something like the following:</p>

<pre><code>void data_cb(int n)
{
    dataPointsSeen++;
    if (n &gt; 0) {positiveSum += n;}
    if (n &lt; 0) {negativeSum += n;}
    //...
}
</code></pre>

<p>Then simply return these somethings when requested:</p>

<pre><code>int total_data_points()
{
    return dataPointsSeen;
}
</code></pre>
",2
26226098,26225961,0,"<p><code>goto</code>s are actually very easy to use and understand. You write a label that marks a piece of code that you would want to go back to (or skip forward to) the label can be before the <code>goto</code> as well as after it. It doesn't matter; the reason why it's to be avoided at all cost is that it makes the code very difficult to maintain and all tangled up (yes, like spaghetti!) if that makes any sense.</p>
<p>And concerning your last piece of code you should bound the <code>goto</code> with a condition. Otherwise, the code will keep bouncing back and forth between <code>label</code> and <code>goto</code>.</p>
",0
26226227,26225961,2,"<p>A <em>for</em> loop can be thought of as having the following basic form:</p>
<pre><code>for (init; cond; inc)
    statement-block
</code></pre>
<p>The above <em>for</em> loop is basically equivalent to the following form which uses <em>while</em>:</p>
<pre><code>init;
while (cond) {
    statement-block
    inc;
}
</code></pre>
<p>The <em>while</em> loop, on the other hand can be thought of as having the following basic form:</p>
<pre><code>while (cond)
    statement-block
</code></pre>
<p>And it is basically equivalent to the following form using <code>label:</code> and <code>if (cond) goto label;</code></p>
<pre><code>loop_beg:
if (!cond) goto loop_end;
statement-block
goto loop_beg;
loop_end:
</code></pre>
<p>If you use both of these transformations then you should be able to rewrite any piece of code in C which uses <code>for</code> or <code>while</code> to do the same thing using only <code>goto</code>.</p>
",0
26226388,26225961,1,"<p>Consider the first part of your first example:</p>
<pre><code>if (i &gt; 5)
{
    i++;
}
</code></pre>
<p>Where does the control flow go if i &lt;= 5? Where does the control flow go if i &gt; 5? -- you should make sure you can answer this before you read on.</p>
<p>A direct translation would be</p>
<pre><code>if (i &gt; 5)
    goto if-body;
goto end-if
if-body:
    i++;
end-if:
   ....
</code></pre>
<p>You should convince yourself that the control flow in the above is the same as the original.  You can simplify this a bit by flipping the condition:</p>
<pre><code>if(i &lt;= 5)
    goto end-if;
i++;
end-if:
    ....
</code></pre>
<p>Again, you should convince yourself that the control flow is still the same.</p>
<p>From this and what Brandin gave in his answer, you should be able to do the rest of the assignment.</p>
",5
26199123,26199091,2,"<p><strong>First things first:</strong> Your code outputs a ton of warnings. Many of these relate to the fact that you don't have prototypes for your functions before you call them. You should <strong>seriously</strong> fix this.</p>

<p><strong>Secondly:</strong> To pass a pointer to a variable, you use the <code>&amp;</code> operator. As in:</p>

<pre><code>dictionary = memalloc(&amp;count);
</code></pre>
",1
26234777,26234643,0,"<p>You put semicolons after your both if...</p>

<p>Change <code>if(swordch0c1==""b"");</code> by <code>if(swordch0c1=='b')</code> and <code>if(swordch0c1==""a"");</code> by <code>if(swordch0c1=='a')</code></p>

<p>I think you should read again your C tutorial or your C book, chapter instruction.</p>
",0
26234867,26234643,2,"<p>You made a few mistake, but this should work!</p>

<pre><code>#include &lt;stdio.h&gt;

int main() {

    char firstname[15], character, swordch0c1, enter;

    printf(""Hello there! Could I have your first name?\n&gt;"");
    scanf(""%s"", &amp;firstname);

    printf(""\n---------------------The Legend of %s---------------------"", firstname);
    printf(""\nPress Enter to continue."");
    enter=getch();

    printf(""\n\n\nYou are %s, a: \nA.Swordsman\nB.Assassin\nC.Archer\nD.Mage\n&gt;"", firstname);
    scanf("" %c"", &amp;character);

    /*swordsman story starts here*/
    if (character == 'A') {
        printf(""\n\nThere you stand, at your boring everyday post.\nWhen you joined the army, you thought it would be more exciting than this.\nJust then, you see your general walking towards you."");
        printf(""\n\nYou quickly improve your posture. \""Soldier, I have an opurtunity for     you\""\nA.\""Really? What is it?\""\nB.\""I'm not interested\""\n&gt;"");
        scanf("" %c"", &amp;swordch0c1);

        if (swordch0c1 == 'b')
            printf(""\""But... I didn't even tell you what it was. Okay, suit yourself\"" You are DOOMED      to a life of boredom.\n\n\n\n\n"");

        if (swordch0c1 == 'a') {
            printf(""\n\n\n\""Well, you see, there's this dragon. He's been causing big problems.     \nHe's destroyed villages, harrassed the priests on the mountain,\n"");
            printf(""and even attacked a couple cities. His name is Sorrith, and dozens of knights     have already tried to kill him, none of them being successful.\"""");
            printf(""\nA.\""Say no more, I'll do it.\""\nB.\""Dragon? No way! You better find someone     else.\nC.\""Keep talking...\"""");
        }
    }

    return 0;
}
</code></pre>
",1
26235118,26234643,0,"<p>Don't put semicolon after if statement, otherwise it would skipped. Always use single quote for a char, and double for string.</p>
",0
26234726,26234643,2,"<p>Remove all the semicolons after each <code>if</code> and also use <code>'</code> instead of <code>""</code> in all the <code>if(...)</code> . Also,</p>

<pre><code>scanf(""%d"",swordch0c1);
</code></pre>

<p>Is wrong as <code>swordch0c1</code> is not an <code>int</code>. Use <code>%c</code> instead of <code>%d</code> as it is a <code>char</code> that you are scanning</p>
",0
25712703,25707788,1,"<p>Let's look at the main loop of your program:</p>

<pre><code>c = getc(f);    
while (c != EOF) {
    if (c  == ' ') count++; 
    c = getc(f); 
}
</code></pre>

<p>Clearly you are testing for, and therefore finding the EOF case, but where in this loop do you test for a negative input?  Answer: you don't so clearly you aren't going to find it.  Others have suggested using a function other than <code>getc()</code> <em>which reads 1 character at a time (say scanf)</em>.  But, for illustrative purposes let's stay with your basic outline:</p>

<pre><code>c = getc(f);    
while (c != EOF) {
    if (c == '-') break;       /* saw a minus, must be the end */
    if (c  == ' ') count++;    /* saw a space, must be a gap between numbers, count that */
    c = getc(f); 
}
</code></pre>

<p>Note that while better this still isn't quite correct -- imagine this input <code>1.0 2.0 3.0</code> you will count the two inter-number spaces, but you don't count the last number.  Also you don't handle the case of multiple spaces between numbers (<code>1.0      2.0    3.0   -5)</code>.</p>

<pre><code>int ws = 1;                               /* white space mode is on */
while ((c = getc(f)) != EOF) {
    if (ws &amp;&amp; (c == ' ')) continue;       /* more white space, just skip */
    if (ws &amp;&amp; (c == '-')) break;          /* white space ended with a minus, done */
    if (ws) ++count;                      /* white space ended, start of new  positive number */
    ws = (c == ' ');                      /* are we starting whitespace mode again? */
}
</code></pre>

<p>Imagine various input strings and walk through this code a line at a time in your mind.  If you find a problem, think how you could solve it.   Repeat.   <em>Hint: -1 vs -2</em></p>
",0
29189295,29167665,0,"<p>I'm sorry to say your approach is too simplistic. The 'modulus 100000' constraint makes this a hard problem that cannot be solved with a single loop.</p>

<p>You would have noticed this sooner if you would have tested your algorithm with more than just a few trivial numbers. Pick any two 4-digit numbers at random and multiply them; e.g.</p>

<pre><code>1234 * 5678 = 7006652
</code></pre>

<p>Obviously, 1234 and 5678 are divisors of 7006652, but 1234 and 5678 are <em>not</em> divisors of 6652. In fact, it's a rare coincidence for successful keys to be divisors of the lock key (unless of course the product is less than 100000). So why the following line of code?</p>

<pre><code>if (a[i]&lt;=100000L &amp;&amp; lkey % a[i]==0)
</code></pre>

<p>Notice the condition fails for both keys:</p>

<pre><code>lkey % a[i] == 6652 % 1234 == 482 != 0
lkey % a[i] == 6652 % 5678 == 974 != 0
</code></pre>

<p>Neither key would be accepted (except for the one held by Samarpit; but not the other).</p>

<p>Try it in a debugger and you will see. Here is the input file:</p>

<pre><code>1234 6652
1
5678
</code></pre>

<p>Bottom line is, your algorithm is not suitable to solve this problem; you will have to follow a totally different approach.</p>

<p>The most straightforward way is to generate all possible <a href=""http://en.wikipedia.org/wiki/Combination"" rel=""nofollow""><em>k</em>-combinations</a> of keys, starting with <em>k</em> = 1 and increase until you find a match. This may not be most efficient approach, but it works. Worry about optimizations later.</p>
",0
27177040,27177017,1,"<p>Signals are a lightweight way for processes to communicate with each other asynchronously; as such, it shouldn't be a surprise that processes generate signals.</p>
",3
27177191,27177017,0,"<p>Signals provide a way of supporting asynchronous interrupts in a C program.  That said, the C spec is almost completely void of specified behavior for signals, leaving them essentially entirely up to the implementation, so writing portable code that uses signals is almost impossible.  You need to carefully read the documentation for your implementation to see what exactly signals can do.</p>
",0
27177764,27177017,0,"<p>Signals are in C because signals were how you communicated with a process in the original version of UNIX. </p>

<p>They are a fairly simple way of allowing your process to respond to external requests such as ""re-read my config file"", for example. </p>

<p>The K&amp;R chapter is a good intro, but read the C standard to see the minimum for what is defined. In particular, the only portable thing you can do in a signal handler is either abort the process, or set an atomic flag which your main thread of execution will check in due course.   In practice, people do more complicated things in signal handlers such as making system calls.</p>
",0
26240732,26240690,3,"<p>The product of 13 consecutive digits may exceeds range of <code>int</code> which you're using for <code>tmp</code>. You need data types that supports a wider range. Maybe 64bit ones like <code>unsigned long long</code> would do.</p>

<p>Also as @deviantfan has pointed out, you're reading characters, and <code>'0'</code> as an character is not the same thing as a number <code>0</code>. Read about ASCII.</p>

<p>Another problem is that the logic of <code>tmp</code> is not correct: you didn't re-initialize it to <code>1</code> after each 13 step loop.</p>

<h3>EDITED:</h3>

<p>Reply to your comment: I suppose in this case the best solution is to read the data as characters, however after that you could convert the ASCII to integer, e.g.:</p>

<pre><code>while((x = fgetc(fp)) != EOF)
{
    // x - '0' does the conversion, 
    // e.g. the expression obtains 0 from '0' - '0', and 5 from '5' - '0'
    ar[i] = x - '0';
    i++;
}
</code></pre>
",2
26240753,26240690,2,"<p>You are taking the product of digit chars, not of the digits they represent.  '1' != 1.</p>
",2
29194908,29194753,0,"<p>According to <a href=""http://linux.die.net/man/3/strtof"" rel=""nofollow"">float strtof (const char* str, char** endptr);</a>
if your first char is 'a' then you should call :</p>

<pre><code>x = strtof(line+2,&amp;ptr);
</code></pre>

<p>if <code>line</code> is used with no offset, strtof will parse ""a 12"" and stop at 'a', you could have check the <code>ptr</code> value to see where the parsing stopped.</p>
",0
29194931,29194753,1,"<p>You already pointed it out:</p>

<blockquote>
  <p>What the code should do: read a line, e.g. ""a 12"" if the first character is ""a"", than, using strtof, it should set pointer to next white space and save value between the two white spaces to x... (probably wrong)</p>
</blockquote>

<p>From the <a href=""https://www.gnu.org/software/libc/manual/html_node/Parsing-of-Floats.html"" rel=""nofollow"">glibc manual</a> (strtod and strtof are equivalent):</p>

<blockquote>
  <p>If the string is empty, contains only whitespace, or <strong>does not contain an initial substring that has the expected syntax for a floating-point number</strong>, no conversion is performed. In this case, strtod returns a value of zero and the value returned in *tailptr is the value of string. </p>
</blockquote>
",0
29194938,29194753,2,"<p>You don't read the floating value after the ""a"", i think you need to do this:</p>

<pre><code>ptr = strtok(NULL,"" "");
x = strtof(ptr, NULL);
</code></pre>

<p>The next call of <code>strtok</code> will read the ""12"" and the <code>strtof</code>will convert it to a float into the x variable.</p>
",0
27176724,27175576,2,"<p>You need to read the man page for <code>sem_init()</code>.  The type of semaphore you are creating right now is not shared across processes.  This requires a non-trivial change to your program, because you also need to set up shared memory.  Refer to <a href=""https://stackoverflow.com/questions/16400820/c-how-to-use-posix-semaphores-on-forked-processes"">this question</a> for a lengthy explanation of how to make your program work.</p>
",0
29220917,29220389,0,"<p>you can keep this numbers 100,50,20,... in the array and use for loop to check whether some number is equal to any one of them, if so then number is valid, else invalid</p>
",2
29222106,29220389,0,"<p>Well,I found the answer : </p>

<pre><code>while(scanf(""%f"",&amp;input)!=EOF || input!=0)
{
if (input == 0) break;
sum=input+sum;

    if(input!=100 &amp;&amp;input!=50 &amp;&amp;input!=20 &amp;&amp;input!=10 &amp;&amp;input!=5 &amp;&amp;input!=2 &amp;&amp;input!=1 &amp;&amp;input!=0.5 &amp;&amp;input!=0.2 &amp;&amp;input!=0.1 &amp;&amp;input!=0.05 &amp;&amp;input!=0.02 &amp;&amp;input!=0.01)
    {
            if (input ==  (int) input)  
       printf(""%.0f is invalid!\n"" ,input);
      else printf(""%.2f is invalid!\n"" ,input);
            exit(1);
    }


     if (getchar() == '\n') break;
};
</code></pre>

<p>Anyway,thanks for help :)!</p>
",3
28179029,28179000,7,"<pre><code>scanf(""%d"", &amp;celsius);
...
printf (""The converted temperature is %.2f\n"", fahrenheit);
</code></pre>

<p>You declared <code>fahrenheit</code> as an <code>int</code> and <code>celsius</code> as a <code>double</code>, so the <code>%f</code> and <code>%d</code> format specifiers should be switched.</p>

<pre><code>scanf(""%lf"", &amp;celsius);
...
printf (""The converted temperature is %d\n"", fahrenheit);
</code></pre>
",1
28179047,28179000,1,"<p>in your code, </p>

<pre><code>printf (""The converted temperature is %.2f\n"", fahrenheit);
</code></pre>

<p>you're trying to print one <code>int</code> with a format specifier of <code>%f</code>. Not a defined behavior.</p>

<p>Then again</p>

<pre><code>scanf(""%d"", &amp;celsius);
</code></pre>

<p>Should be </p>

<pre><code>scanf(""%f"", &amp;celsius);  //c89 and above
</code></pre>

<p>or</p>

<pre><code>scanf(""%lf"", &amp;celsius); //c99 and above
</code></pre>

<p>Also, initialize the local variable yourself. They aren't <em>auto</em> initialized. Otherwise, don't be surprised if sometimes [less likely but not impossible]</p>

<pre><code>while (celsius != 0 || fahrenheit != 32)
</code></pre>

<p>fails in the first iteration itself.</p>
",0
28209444,28209371,2,"<p>On windows you have the task scheduler, which can execute a programm at a specific time, with a specific user etc.</p>

<p>On linux you got something similar. The cronjobs/crontabs. An introduction you can find <a href=""http://www.howtogeek.com/101288/how-to-schedule-tasks-on-linux-an-introduction-to-crontab-files/"" rel=""nofollow noreferrer"">here</a>.</p>

<p><strong>based on new question:</strong>
What is the sense of this? You can't trigger your own program if it's not running. So basically your program must run in the background 24/7 and wait for events.
Maybe you should take a look at <a href=""https://stackoverflow.com/questions/11027051/how-to-develop-a-program-that-runs-in-the-background-in-net"">this</a> post.</p>
",0
28209474,28209371,1,"<p>In windows you are having the task scheduler and the <code>AT</code> command.  You refer this
<a href=""https://stackoverflow.com/questions/132971/what-is-the-windows-version-of-cron"">link.</a></p>
",0
28210172,28209371,0,"<p>you need to develop a Daemon/Service process whose job is only to execute your application at required intervals or at specific time.</p>
",0
27543894,27543869,2,"<p>The escape sequence for an actual backslash is <code>\\</code>, e.g.</p>

<pre><code>char c = getchar();
if(c == '\\')
    ... stuff ...
</code></pre>
",0
27543904,27543869,1,"<p>compare the \ like this.
<code>if ((str[i] == '\\') &amp;&amp; (str[i+1] == 'n'))</code></p>

<p>because we have to escape the escape sequence \.</p>
",0
27543907,27543869,5,"<p>You have to escape <code>\</code> by doubling it:</p>

<pre><code>if ( ((str[i] == '\\') &amp;&amp; (str[i+1] == 'n')) ){
}
</code></pre>
",0
27543978,27543869,-1,"<p>if user enter like <code>\</code> and <code>n</code> using keyboard .</p>

<p>then try like this</p>

<pre><code> if(str[i] == '\\' &amp;&amp; str[i+1] == 'n')
</code></pre>

<p>As <code>\</code> is represented by <code>\\</code>, so use <code>\\</code> instead of <code>\</code> to check.</p>
",0
27544321,27543869,0,"<p>Instead of escape characters you can use the ASCII values like this</p>

<pre><code>  if ((str[i] == 92) &amp;&amp; (str[i+1] == 'n'))
        ;
</code></pre>
",0
27544444,27543869,0,"<p>you use another \</p>

<pre><code>    if ( str[i] == '\\' &amp;&amp; str[i+1] == 'n');
</code></pre>
",2
28183794,28183757,2,"<p>Your current logic is ""print a comma if the index is less than 9.""  Your logic <em>should</em> be ""print a comma if the index is less than 9, <em>and</em> the index is not the last element in the array""</p>

<p>Working code:</p>

<pre><code>int i;
for (i = 0; i &lt; numberOfItemsInSequence &amp;&amp; i &lt; numberOfItemsToPrint; i++) {
    printf(""%d"", i);
    if (i &lt; numberOfItemsInSequence - 1 &amp;&amp; i &lt; numberOfItemsToPrint - 1) {
        printf("","");
    } else {
        printf(""\n"");
    }
}
</code></pre>
",1
28188011,28183757,1,"<p>sample to fix</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void){
    int sequence[] = {
        'a','b','c','d','g','j','o','p','q','q',
        'j','k','j','f','a','q'
    };
    int wrap_size = 10;
    int i, count=0;
    for(i=0; i&lt; sizeof(sequence)/sizeof(*sequence); ++i){
        if(count++)
            printf("", "");
        printf(""%c"", sequence[i]);
        if(count == wrap_size){
            putchar('\n');
            count = 0;
        }
    }
    if(count)
        putchar('\n');
    return 0;
}
</code></pre>
",0
27162461,27162419,2,"<ol>
<li>At the start, set a variable <code>sum</code> to zero.</li>
<li>Then, every time you currently output a prime number, add it to <code>sum</code> as well.</li>
<li>Then, when you're finished, output <code>sum</code>.</li>
</ol>

<hr>

<p>So, assuming your code works otherwise, you would change, for point 1 above:</p>

<pre><code>int i,n=1,j;
</code></pre>

<p>into:</p>

<pre><code>int i,n=1,j,sum=0;
</code></pre>

<hr>

<p>Point 2 involves changing:</p>

<pre><code>printf(""%d is the prime number %d\n"", i,n);
</code></pre>

<p>into:</p>

<pre><code>printf(""%d is the prime number %d\n"", i,n);
sum += i;
</code></pre>

<hr>

<p>And, finally, point 3 can be enacted by placing:</p>

<pre><code>printf(""Sum of all those primes is %d\n"", sum);
</code></pre>

<p>before the final closing brace.</p>

<hr>

<p>The changes to your code, including commenting and more appropriate variable names in an effort to make readable, would be something like:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

// Find/sum all primes less than this number.

#define LIMIT 500

// Flag indicating a number is non-prime, initialised to zeros.

bool isComposite[LIMIT];

void main (void) {
    int num, mult;
    int count = 1, sum = 0;

    // Check every number for primeness.

    for (num = 2; num &lt; LIMIT; num++) {
        // Ignore if composite.

        if (!isComposite[num]) {
            // Print prime, add to sum.

            printf (""%d is the prime number %d\n"", num, count++);
            sum += num;

            // Mark all multiples of it as composite.

            for (mult = num * 2; mult &lt; LIMIT; mult += num) {
                isComposite[mult] = 1;
            }
        }
    }

    // Now just output the sum.

    printf (""The sum of those primes is %d\n"", sum);
}
</code></pre>

<p>Don't copy that if it's classwork, you'll probably get found out. I include it just to show you how much more readable code can be if you follow a few simple rules, some of which are below:</p>

<ul>
<li>Use comments copiously, generally to describe <em>what</em> you're doing, not <em>how.</em></li>
<li>Use decent variable names.</li>
<li>Try to avoid 'magic' constants like <code>500</code>.</li>
<li>Minimise vertical space taken as long as it doesn't affect readability (it's usually better to see as much code on the screen as possible).</li>
</ul>
",1
27162492,27162419,2,"<p>Add Extra variable <code>sum</code></p>

<p>Like this</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdbool.h&gt;

   bool c[500];
   int main()
   {
    int i,n=1,j,sum=0;
    for (i=2; i&lt;500; i++)
    {
          if (!c[i])
          {
                printf(""%d is the prime number %d\n"", i,n);
                sum+=i;
                  n++;
                 j=2;
                  while (j*i&lt;500)
                 {
                          c[j*i]=1;
                         j++;
                  }
          }
   }
   printf(""Sum is %d"",sum);
 }
</code></pre>
",1
27162495,27162419,1,"<pre><code>  1 #include&lt;stdio.h&gt;
  2 #include&lt;stdbool.h&gt;
  3
  4 bool c[500];
  5 void main()
  6 {
  7  int i,n=1,j; int sum = 0;
  8  for (i=2; i&lt;500; i++)
  9  {
 10         if (!c[i])
 11         {
 12                 printf(""%d is the prime number %d\n"", i,n);
 13                 sum += i; n++;
 14                 j=2;
 15                 while (j*i&lt;500)
 16                 {
 17                         c[j*i]=1;
 18                         j++;
 19                 }
 20         }
 21  } printf(""sum: %d"", sum);
 22 }
</code></pre>
",2
29242431,29242002,3,"<p>Based on the constraints clarified in the comments, the return value which is expected is 0x55555555. Using only bitshifts and ORs, without any assignment or integer greater than 256 we can do something like:</p>

<pre><code>.... 
return 0x00000055 | (0x00000055 &lt;&lt; 8) | (0x00000055 &lt;&lt; 16) | (0x00000055 &lt;&lt; 24);
...
</code></pre>

<p>(Or, in case the ""even"" has different meaning, every <code>5</code> can be replaced by <code>A</code>)</p>
",0
29242178,29242002,1,"<p>Use a <code>char</code> size variable that holds the pattern. Reuse it to create the <code>int</code> size variable.</p>

<pre><code>unsigned char one = 0x01;
unsigned char c = one;  // c is b00000001
c = (c &lt;&lt; 2) | one;     // c is b00000101
c = (c &lt;&lt; 2) | one;     // c is b00010101
c = (c &lt;&lt; 2) | one;     // c is b01010101

unsigned int result = c;    // result is 0x00000055
result = (result &lt;&lt; 8) | c; // result is 0x00005555
result = (result &lt;&lt; 8) | c; // result is 0x00555555
result = (result &lt;&lt; 8) | c; // result is 0x55555555
</code></pre>

<p><strong>Update</strong></p>

<p>A better approach:</p>

<pre><code>int res = 0x01;          // res is b00000001
res = (res &lt;&lt; 2) | res;  // res is b00000101
res = (res &lt;&lt; 4) | res;  // res is b01010101, which is 0x00000055
res = (res &lt;&lt; 8) | res;  // res is 0x00005555
res = (res &lt;&lt; 16) | res; // res is 0x55555555
</code></pre>
",5
29242479,29242002,1,"<pre><code>int evenbits(void)
{
    return 0xAAu &lt;&lt; 24 | 0xAAu &lt;&lt; 16 | 0xAAu &lt;&lt; 8 | 0xAAu;
}
</code></pre>

<p>6 operators, no variables or assignment. The <code>u</code> is to avoid undefined behaviour (<code>0xAA &lt;&lt; 24</code> causes UB).  Using <code>|</code> instead of <code>+</code> means that we do not need parentheses. <code>+</code> has higher precedence than <code>&lt;&lt;</code>, but <code>|</code> doesn't.</p>

<p>If the lowest bit is bit <code>0</code> then change <code>0xAAu</code> to <code>0x55</code>.</p>
",7
29242291,29242002,0,"<pre><code>int evenbits(void) {

    int x = 85;        // x   0101 0101                               ( 8-bits)
    x = (x &lt;&lt; 8) | 85;  // x = 0101 0101 0101 0101                     (16-bits)
    x = (x &lt;&lt; 8) | 85;  // x = 0101 0101 0101 0101 0101 0101           (24-bits)
    x = (x &lt;&lt; 8) | 85;  // x = 0101 0101 0101 0101 0101 0101 0101 0101 (32 bits)
    return x;
}
</code></pre>

<p>Perhaps a little tighter:</p>

<pre><code>int evenbits(void) {

    int x = (85 &lt;&lt; 8) | 85; // x = 0101 0101 0101 0101                     (16-bits)
    x = (x &lt;&lt; 16) | x;      // x = 0101 0101 0101 0101 0101 0101 0101 0101 (32-bits)
    return x;
}
</code></pre>
",0
29242396,29242002,0,"<p>Less than 8 operations (32 bit)</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    int val = 1;
    val = val &lt;&lt;  2 | val;
    val = val &lt;&lt;  4 | val;
    val = val &lt;&lt;  8 | val;
    val = val &lt;&lt; 16 | val;
    printf (""Value = %0X\n"", val);
    return  0;    
}
</code></pre>

<p>Since there isn't a <code>1</code> bit shifted into the ms bit of a signed integer, it works.</p>

<p>Program output:</p>

<pre><code>55555555
</code></pre>
",0
29243816,29242002,0,"<p>I guess the solution is something along the lines of</p>

<pre><code>    return (0x55 | 0x55 &lt;&lt; 8 | 0x55 &lt;&lt; 16 | 0x55 &lt;&lt; 24);
</code></pre>

<p>or</p>

<pre><code>    return ~(0x55 | 0x55 &lt;&lt; 8 | 0x55 &lt;&lt; 16 | 0x55 &lt;&lt; 24);
</code></pre>

<p>or similar, depending on how bit positions are considered (starting from 0 or 1)</p>
",0
27527310,27527254,2,"<pre><code>scanf(""%d"",&amp;a);
</code></pre>

<p>You get an integer ? not a character ? If it is a character, then you should use <code>%c</code> instead of <code>%d</code></p>
",0
27527523,27527254,1,"<p>Add <code>getchar()</code> function between the two <code>scanf()</code>.</p>

<p>Like</p>

<pre><code>#include&lt;stdio.h&gt;
main()
{
        int i;
        char a,b,str[100];
        printf(""Enter the string"");
        gets(str);
        //asking for replacement
        printf(""enter the character to be replaced"");
        scanf(""%c "",&amp;a);
        //Get the pending character.
        getchar();
        // which letter to replace the existing one
        printf(""enter the character to replace"");
        scanf(""%c"",&amp;b);
        for(i=0;str[i]!='\0';i++)
        {
                if(str[i]==a)
                {
                        str[i] = b;
                }
                else
                        continue;
        }
        printf(""the new string is"");
        puts(str);
}
</code></pre>

<p>The problem is when you give a character and pressed enter, newline will acts as one character and it will be get by the next scanf. To avoid that the <code>getchar()</code> is using.</p>

<p><strong>Another Way:</strong></p>

<p>Give space before the access specifier on character to replace,</p>

<p>Like</p>

<pre><code>scanf("" %c"",&amp;b);
</code></pre>

<p>But before remove that <code>getchar()</code>.</p>
",1
27527697,27527254,0,"<p>Try this, it worked for me:</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;
main()
{
  int i;
  char a,b,str[100];
  printf(""Enter the string: "");
  gets(str);
  //asking for replacement
  printf(""enter the character to be replaced: "");
  a = _getch();
  printf(""\n%c"", a);
  // which letter to replace the existing one
  printf(""\nenter the character to replace: "");
  b = _getch();
  printf(""\n%c"", b);

  for(i=0;str[i]!='\0';i++)
  {
    if(str[i]==a)
    {
      str[i] = b;
    }

    else
     continue;
  }
  printf(""\nthe new string is: ""); 
  puts(str);
}
</code></pre>

<p>You can remove the <code>else</code> block. It won't affect anything.</p>
",0
27527827,27527254,1,"<pre><code>#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;
int main() //main returns an int
{
int i;
char a,b,str[100];

printf(""Enter the string\n"");
fgets(str,sizeof(str),stdin);//gets is dangerous

printf(""Enter the character to be replaced\n"");
scanf("" %c"",&amp;a); //space before %c is not neccessary here

printf(""Enter the character to replace\n"");
scanf("" %c"",&amp;b); //space before %c is compulsory here
for(i=0;str[i]!='\0';i++)
{
    if(str[i]==a)
    {
    str[i] = b;
    }
    //else //This part is not neccessary
    //continue;
}
printf(""The new string is "");
puts(str);
return 0; //main returns an int
}
</code></pre>

<p>I've used <a href=""http://www.tutorialspoint.com/c_standard_library/c_function_fgets.htm"" rel=""nofollow""><code>fgets</code></a> because <a href=""http://www.stackoverflow.com/questions/1694036/why-is-the-gets-function-dangerous-why-should-it-not-be-used""><code>gets</code> is dangerous</a> as it does not prevent <a href=""http://www.en.m.wikipedia.org/wiki/Buffer_overflow"" rel=""nofollow"">buffer overflows</a>.</p>

<p>The <a href=""http://www.stackoverflow.com/questions/7166197/why-does-a-space-in-my-scanf-statement-make-a-difference"">space before <code>%c</code> in the <code>scanf</code></a> is to skip blanks,i.e,spaces,new-lines etc and it isn't needed in the first <code>scanf</code> is that <code>fgets</code> also consumes the new-line characters and puts it into the buffer.</p>

<p>The reason that the <code>else continue;</code> isn't needed is that the loop is going to check the condition as it has reached the end of the loop body.</p>

<p>I've used <code>int main()</code> and <code>return 0</code> because as per the latest standards,<a href=""http://www.stackoverflow.com/questions/4207134/what-is-the-proper-declaration-of-main"">it should</a></p>

<p>Finally,you have an unused header <code>conio.h</code> in your program.</p>
",0
32427286,32426982,3,"<p>I've simplified your code, by finding the longest side first, and removing most of the comparisons (and brackets).</p>

<p>But most importantly, your squares comparison for acute and obtuse was the wrong way round. The sum of the smaller sides' squares is greater than the longest, for an acute triangle.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;

//Program that calculates the type of triangle
int main(int argc, char *argv[]) {

    int x,y,z,longest;

    printf(""Type in the integer lengths of 3 sides of a triangle:\n"");
    scanf(""%d %d %d"", &amp;x, &amp;y, &amp;z); //reads the user's inputs
    if((x&lt;=0) || (y&lt;=0) || (z&lt;=0)) {
      printf(""This is not a triangle.\n"");
    } else {
        if((x + y &lt;= z) || (x + z &lt;= y) || (y + z &lt;= x)) {
        printf(""This is not a triangle.\n"");
        } else {

            longest = z;
            if (longest &lt; x) {
                z = longest;
                longest = x;
                x = z;
            }
            if (longest &lt; y) {
                z = longest;
                longest = y;
                y = z;
            }

            if( x * x + y * y == longest * longest ) {
                printf(""This is a right-angled triangle.\n"");
            } else if( x * x + y * y &gt; longest * longest) {
                printf(""This is an acute-angled triangle.\n"");
            } else printf(""This is an obtuse-angled triangle.\n"");
        }
  }

  return 0;
}
</code></pre>
",0
32427306,32426982,0,"<p>For a triangle with sides a,b,c:</p>

<p>to be acute angle: a^2+b^2 > c^2 and b^2+c^2 > a^2 and c^2+a^2 > b^2.</p>

<p>to be obtuse angle: a^2+b^2 &lt; c^2 or b^2+c^2 &lt; a^2 or c^2+a^2 > b^2. </p>
",2
27515724,27515681,1,"<p>Your problem is that integer division is occurring with <code>n1</code> and <code>n2</code>, and thus 5/15 -> 0..  Your problem isn't composition of functions.</p>

<p>So change <code>return (n1/n2) * 100;</code> to <code>return (100.0 * (double)n1 / (double) n2 );</code>
Yes the extra casts are verbose; but it will make it clearer to someone such as yourself who is reading the code that you are trying to carry out floating point division</p>

<p>That aside there won't be any printed output unless you add a print statement of some sort.
perhaps use printf like so:  </p>

<pre><code>double p = GetPercentage( a( 10 ), b( 10 ) );
printf( ""%f\n"", p );
</code></pre>
",0
27515728,27515681,2,"<p>One, you need to print the return value from <code>GetPercentage</code>. As is, you're not doing anything with it, so the program doesn't have any output.</p>

<pre><code>double p = GetPercentage(a(10),b(10));
printf(""%f\n"", p);
</code></pre>

<p>Two, you need to force the division to be done with floating point. Otherwise when you divide two <code>int</code>s the result will be truncated to an integer: 5/15 = 0.3333, which is truncated to 0, and 0*100 is 0 instead of 33.33.</p>

<pre><code>return (((double) n1) / n2) * 100;
</code></pre>
",1
27515729,27515681,1,"<p>You are losing some data due to integer division in the line</p>

<pre><code> return (n1/n2)*100;
</code></pre>

<p>Instead, use</p>

<pre><code> return (100.0*n1/n2);
</code></pre>
",0
27515735,27515681,0,"<p>The code is correct, but you are not doing anything with the return value of <code>GetPercentage</code>. You may add the following changes:</p>

<pre><code>double result = GetPercentage(a(10),b(10));
printf(""%f\n"", result);
</code></pre>

<p>And at the top of your code:</p>

<pre><code>#include &lt;stdio.h&gt;
</code></pre>

<p>Also make sure to return a value of type <code>double</code>. Therefore, change your <code>GetPercentage</code> function to the following:</p>

<pre><code>return (100 * n1/n2);
</code></pre>
",1
27118262,27118210,5,"<p>It has the same behavior as:</p>

<pre><code>*dest = *src;
 dest++;
 src++;
</code></pre>

<p>That is copy the character pointed at by <code>src</code> to the character pointed at by <code>dest</code>. Then move each pointer to the next character element. </p>
",0
27520514,27520451,0,"<p>Make the condition like this.</p>

<pre><code>if( line_num==-1)
    line_len=len_tmp;
else if ( len_tmp &lt; line_len){
     line_num=len_tmp;
    // do the code for getting that line.}
</code></pre>
",1
27520591,27520451,2,"<p>How about</p>

<pre><code>int line_len = MAX_LINE_LEN+1;
</code></pre>

<p>At the start to make sure the first line you read is shorter than the 'stored' shortest line-length.</p>

<pre><code>int LongestLine(FILE *filename) {

  char buf[MAX_LINE_LENGTH] = {0};

  char line_val[MAX_LINE_LENGTH] = {0};
  int line_len = MAX_LINE_LEN+1; //Set initial shortest line to big number.
  int line_num = -1;
  int cur_line = 1;

  filename = fopen(filename, ""r"");

  while(fgets(buf, MAX_LINE_LENGTH, filename) != NULL) {
    int len_tmp = strlen(buf); 

    if(len_tmp&gt;0 &amp;&amp; buf[len_tmp-1] == '\n') {
      buf[len_tmp-1] = '\0';
      --len_tmp;
    }

    if(len_tmp &gt;0 &amp;&amp; line_len &gt; len_tmp) {  //On first pass that encounters a non-empty line this will always trigger because of the read limit in fgets.
      strncpy(line_val, buf, len_tmp + 1);
      line_len = len_tmp;
      line_num = cur_line;
    }

    cur_line++;
  }

  return line_num;
}
</code></pre>

<p>Consider how the wider program should handle an entirely empty file or file of all blank lines.
that code will return <code>MAX_LINE_LENGTH+1</code> in such a condition. That may or may not suit your purpose.</p>

<p>Also it's not clear why your taking a copy of the shortest line and its line number.
You do nothing with them and don't return them from the function.
What good do the following lines do?</p>

<pre><code>      strncpy(line_val, buf, len_tmp + 1);

      line_num = cur_line;
</code></pre>
",11
27497805,27497746,0,"<p>In strcpy is a char * argument. In first case you are passing the character variable. So it is not accepting that and throwing the error.</p>

<pre><code>char *strcpy(char *dest, const char *src); 
</code></pre>

<p>So when you are using the pointer that time it accepting that.</p>
",0
27497933,27497746,0,"<p>You're confusing single characters with strings. Also, <em>both</em> versions of the code are writing to unallocated memory.</p>

<p>Rather than try to explain this in complete detail, I'm going to suggest you go back to the book(s) you're learning C from, because you've misunderstood some really fundamental things here.</p>
",0
27497964,27497746,1,"<p>Issues that I see:</p>

<p>Issue 1:</p>

<pre><code>struct theFile{
    FILE *fPointer;
    char *fileItems[];
    int count;
}myFile;
</code></pre>

<p>is not valid. The flexible array member has to be the last member of the <code>struct</code>. Use</p>

<pre><code>struct theFile{
    FILE *fPointer;
    int count;
    char fileItems[]; // This is an array of char not an array of char*.
}myFile;
</code></pre>

<p>instead.</p>

<p>Issue 2:</p>

<pre><code>strcpy(myFile.fileItems[i], item);
</code></pre>

<p>is not valid since the second argument is of type <code>char</code> not <code>char*</code>. That's what the compiler is telling you.</p>

<p>Issue 3:</p>

<p>Your code needs to be updated for the flexible way you want to keep adding input data to <code>myFile</code>.</p>

<pre><code>void saveFile()
{
   int item;
   int i = 0;

   myFile.fPointer = fopen(""mileage.txt"", ""r"");

   // Deal with error condition.
   if ( myFile.fPointer == NULL )
   {
       // Add an appropriate error message.
       printf(""Unable to open '%s' for reading.\n"", ""mileage.txt"");
       return;
   }

   myFile.fileItems = malloc(i+1);

   while ((item = fgetc(myFile.fPointer)) != EOF )
   {
      if (item != ',' || item != ' ')
      {
         myFile.fileItems = realloc(myFile.fileItems, i+1);
         myFile.fileItems[i] = item;
         i++;
      }
   }
   myFile.count = i;

   // You need to call fclose(myFile.fPointer) somewhere.
   // I am not sure what's the best place in your program to do that.
   // This function might as well be that place.
   fclose(myFile.fPointer);
   myFile.fPointer = NULL;
}
</code></pre>

<p>Issue 4:</p>

<p>The name <code>saveFile</code> seems a bit misleading since you are not saving anything to a file. <code>readFile</code> sounds like a better name to me.</p>
",0
27544590,27544494,0,"<pre><code> int grade[N];
</code></pre>

<p><code>grade</code> is an array. Thus, you can access it using <code>*number[i].grade</code> or <code>number[i].grade[0]</code> (which are equivalent).</p>

<p><code>number[i].grade</code> is a pointer on <code>int</code>.</p>
",1
27544665,27544494,1,"<p>As <code>int grade[N]</code> is an array, here by using <code>*number[i].grade</code> you are accessing the first element of <code>number[i].grade[N]</code>  </p>

<p>That is <code>*number[i].grade</code> same as <code>number[i].grade[0]</code></p>
",0
27546883,27544494,0,"<p>Except when it is the operand of the <code>sizeof</code> or unary <code>&amp;</code> operators, or is a string literal being used to initialize an array, an <em>expression</em> of type ""N-element array of <code>T</code>"" will be converted (""decay"") to an expression of type ""pointer to <code>T</code>"", and the value of the expression will be the address of the first element of the array.</p>

<p>So, in the line</p>

<pre><code>if (*number[i].grade &gt; 90)
</code></pre>

<p>the expression <code>number[i].grade</code> has type ""2-element array of <code>int</code>""; since the expression is not the operand of the <code>sizeof</code> or unary <code>&amp;</code> operators, it ""decays"" to type ""pointer to <code>int</code>"", and the value of the expression is the address of <code>number[i].grade[0]</code>.</p>

<p>Thus, the expression <code>*number[i].grade</code> is equivalent to <code>number[i].grade[0]</code>.  The expression is parsed as <code>*(number[i].grade)</code>; the array subscript operator <code>[]</code> and component selection operator <code>.</code> have higher precedence than the unary <code>*</code> operator.</p>
",0
27510940,27510859,6,"<pre><code>start = rand()%15;
</code></pre>

<p>So <code>start</code> can be 0.</p>

<p>In your while loop you are doing </p>

<pre><code>start--;
</code></pre>

<p>So now start is -1 and you are accessing </p>

<pre><code>start[-1]
</code></pre>

<p>Accessing array which is not within the bound leads to undefined behavior.</p>
",6
27510962,27510859,2,"<p>When you do a modulo of a negative number, the result is also negative, so in some case your <code>start</code> may be negative, therefore your <code>yol[start%15]</code> may reach for a negative index in your array --> corruption.</p>
",0
28204688,28203579,3,"<p>For almost all practical purposes, there is no difference, at least in the simple case you're asking about.</p>

<p>The <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""nofollow noreferrer"">C standard</a> (the link is to the N1570 draft), section 6.5.15.2, says:</p>

<blockquote>
  <p>A compound assignment of the form <strong><code>E1</code></strong> <em>op</em> <strong><code>=</code></strong> <strong><code>E2</code></strong> is equivalent to the
  simple assignment expression <strong><code>E1 = E1</code></strong> <em>op</em> <strong><code>(E2)</code></strong>, except that the lvalue
  <strong><code>E1</code></strong> is evaluated only once, and with respect to an
  indeterminately-sequenced function call, the operation of a compound
  assignment is a single evaluation. If <strong><code>E1</code></strong> has an atomic type, compound
  assignment is a read-modify-write operation with <strong><code>memory_order_seq_cst</code></strong>
  memory order semantics.</p>
</blockquote>

<p>(The text formatting of the above paragraph is a bit tricky; <strong><code>+=</code></strong> is a single token that can't have a space in the middle of it.)</p>

<p>You can safely ignore most of that. I don't completely understand the last sentence myself.</p>

<p>The relevant difference is that the <code>number</code> is evaluated <em>twice</em> if you write</p>

<pre><code> number = number + 10;
</code></pre>

<p>and only once if you write</p>

<pre><code> number += 10;
</code></pre>

<p>(It's evaluated once for each time it appears in the expression.)</p>

<p>Now if the expression is just the name of a variable, there is no difference. In both cases, the same value is stored in <code>number</code>, and the result of the entire expression (which is discarded, but it <em>could</em> be used as part of a larger expression) is the new value that was just assigned.</p>

<p>If <code>number</code> is declared <em>volatile</em>, then the number of times it's evaluated can affect your program's behavior. The details depend on where <code>number</code> is stored and the characteristics of your system. Loosely speaking, <code>volatile</code> inhibits optimizations, requiring the compiler to generate code that does exactly what you told it to. If the variable is some kind of special register connected with some physical device, it can make a big difference.</p>

<p>If rather than just <code>number</code> you have a more complicated expression, evaluating it once vs. twice can also make a big difference. For example:</p>

<pre><code>int arr[100] = ...;
arr[rand() % 100] += 10;
arr[rand() % 100] = arr[rand() % 100] + 10;
</code></pre>

<p>The first assignment increases the value of some random element of <code>arr</code>. The second grabs the value of some random element of <code>arr</code>, adds 10 to it, and stores the result in some <em>other</em> random element of <code>arr</code> (or maybe the same one), because <code>rand()</code> returns a (probably) different result each time it's called.</p>

<p>But in the simple case you're asking about:</p>

<pre><code>number += 10;
</code></pre>

<p>vs.</p>

<pre><code>number = number + 10;
</code></pre>

<p>both statements do the same thing, and a compiler will <em>probably</em> generate exactly the same code for both.</p>

<p>The main purpose of the compound assignment operators like <code>+=</code> is to let you write shorter and clearer code (the two don't always go together, but in this case they do). Because you're only operating on a single variable, it makes sense to be able to refer to its name only once. And for more complicated expressions, being able to write:</p>

<pre><code>a[b].c[d+42]-&gt;e += 10;
</code></pre>

<p>rather than</p>

<pre><code>a[b].c[d+42]-&gt;e = a[b].c[d-42]-&gt;e;
</code></pre>

<p>not having to type the name of the target more than once reduces the risk that at typo will introduce a bug. (Did you notice the typo in the second version?)</p>
",0
24583166,24583151,1,"<p>In C you are not allowed to provide an initializer for VLAs.</p>

<p>I'd suggest using a compile-time constant for the array dimension; then it is not a VLA:</p>

<pre><code>#define NUM_P 100

int main(void)
{  
    char *pS[NUM_P] = { 0 };
}
</code></pre>

<p>For historical reasons, a <code>const</code> variable is not considered to be a constant expression in C. </p>
",1
24583168,24583151,0,"<p>That's valid in C++ but not in C. You can use a preprocessor symbol to do that in C.</p>

<pre><code>#define NUM_P 100
int main (viod)
{
   char *pS[NUM_P] = { NULL};
}
</code></pre>
",0
24583170,24583151,2,"<p>The root of your problem is that <code>NUM_P</code> is a variable, even if it is a <code>const</code> one.</p>

<p>Replace its declaration by <code>#define NUM_P 100</code> and your code will compile again.</p>
",0
32952743,32952145,0,"<p>Note that you are dealing with an int array,which means it normally won't contain '\0' character.To iterate over the array you need to specify number of elements.Here is the correct way :</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int sumOccur(int A[],size_t number_of_elemets);

int main(){

    int input[6] = {1,1,1,2,2,3};

    //Get the number of elements
    size_t n = sizeof(input) / sizeof(int);

    printf(""%d"", sumOccur(input,n));

    return 0;
}

int sumOccur(int A[],size_t number_of_elements) {

    int sum = 0;

    size_t i = 0;

    while( i &lt; number_of_elements )
    {
        sum += A[i];
        i++;
    }
    return sum;
}
</code></pre>
",0
32952199,32952145,0,"<p>Your code invokes undefined behaviour: you access <code>A[6]</code> and subsequent inexistent entries in <code>sumOccur</code> trying to find a final <code>0</code> in the array, but you do not put one in the definition of <code>input</code> in the <code>main</code> function.</p>

<p>-------- cut here if you are not interested in gory implementation details --------</p>

<p>The array is allocated on the stack, very near the top since it is instantiated in the <code>main</code> function.  Reading beyond the end until you find a <code>0</code> likely tries to read beyond the end of the stack pages and causes a segmentation fault.</p>
",0
32952200,32952145,3,"<p>It's not the <code>printf()</code> crashing. It's <code>sumOccur()</code>. Your array has no <code>\0</code> value in it, so your while() never terminates and you end up in a near-infinite loop and run off the end of the array.</p>

<p>The array is an array of numbers, not a string, so there is no reason whatsoever to think there there would be a null-terminator on the values. null terminators are for strings, not arrays of numbers.</p>
",0
32952202,32952145,3,"<p>In your function <code>int sumOccur</code> you have two problems-</p>

<p><strong>1.</strong> <code>sum</code> and <code>i</code> are <strong>not initialized</strong> just declared. Initialize both to <code>0</code> . </p>

<p><strong>2.</strong> Also <code>while(A[i]!='\0')</code> ain't going to work as expected as your array doesn't have that value in it.</p>
",3
32952204,32952145,0,"<p>You are iterating while <code>A[i] != '\0'</code> but there is no <code>'\0'</code> in the array and also you never initialize <code>sum</code> which is unlikely the cause for a crash but it could be.</p>

<p>You need to pass the number of elements in the array, like this</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int sumOccur(size_t count, const int *A);
int sumOccurCHQrlieWay(const int *A, size_t count);

int main()
{
    int input[] = {1, 1, 1, 2, 2, 3};
    printf(""%d"", sumOccur(sizeof(input) / sizeof(*input), input));
    return 0;
}

int sumOccur(size_t count, const int *A) 
{
    int sum;
    sum = 0;
    for (size_t i = 0 ; i &lt; count ; ++i)
        sum += A[i];
    return sum;
}

int sumOccurCHQrlieWay(const int *A, size_t count)
{
    return sumOccur(count, A);
}
</code></pre>
",6
33000330,33000161,2,"<p>You code runs fine for me, however it could be a result of floating point rounding as other have suggested.  Rather than using the <code>pow</code> function, keep track of the current power of 10 in a separate variable and multiply by 10 on each iteration.</p>

<pre><code>#include&lt;stdio.h&gt;

int main()                        // main should always return int, not void
{
    int num, rem, no=0,i=0,p=1;   // p is the current power of 10
    printf(""Enter a number: "");
    scanf(""%d"", &amp;num);
    do{
        rem=num%10;
        if(rem==9)
        {
            rem=0;
        }else{
            rem=rem+1;
        }
        no+=rem*p;     // multiply by the current power of 10
        p*=10;         // increase the power of 10
        num=num/10;
    }while(num!=0);
    printf(""new no: %d\n"", no);
    return 0;
}
</code></pre>
",3
24592572,24591780,0,"<pre><code>if (joyStickX != 0 &amp; joyStickY != 0)
{
    int joyDistance = (sqrt(pow((joyStickX - 0),2)+ pow((-joyStickY - 0),2)));
    joyDistance = ((joyDistance/127)*100);
    return (joyDistance);
}
</code></pre>

<p>The first issues that appears is the conditional within the if statement. The you have a single <code>&amp;</code> that most likely should be <code>&amp;&amp;</code>:</p>

<pre><code>if (joyStickX != 0 &amp;&amp; joyStickY != 0)
</code></pre>

<p>(note: <strong>likely should be</strong> is used above because you can provide a conditional using a logical <code>&amp;</code> of the tests <code>joystickx != 0</code>, but in this case it provides the same result. In that case, I would suggest the more readable <code>&amp;&amp;</code> be used)</p>

<p>The next part of the code is simply the vector distance between <code>0,0</code> and the <code>present position</code> of the joystick. Of the general form <code>dist^2</code> = <code>(x2-x1)^2 + (y2-y1)^2</code> in your case <code>x1,y1</code> = <code>0,0</code>. Taking the square root of both sides provides <code>dist</code> = <code>sqrt((x2-x1)^2 + (y2-y1)^2)</code>, or in C notation:</p>

<pre><code>dist = (sqrt(pow((joyStickX - 0),2)+ pow((-joyStickY - 0),2)));
</code></pre>

<p>Next you have a scaling applied of <code>dist</code> = <code>dist  * 100/127</code> which provides the final distance returned. Hopefully this will help you understand what the code is doing.</p>
",0
29163847,29163759,1,"<p><code>sizeof</code> is a compile-time operator, so it cannot evaluate <code>x==2</code>. It evaluates the <em>type</em> of the ternary expression, which in this case is <code>float</code>, via a conversion to a common type (the second and third operands of the ternary expression must be of the same type, and the <code>int</code> gets converted to <code>float</code>.)</p>
",0
29163854,29163759,6,"<blockquote>
  <p>Here the expression ((x == 2) ? f : i) evaluates to i which is of type short int</p>
</blockquote>

<p>This is not how <em>usual arithmetic conversions</em> work in C. The second and third operands of <code>? :</code> are first converted to a common type, and that type is the type of the result of the expression. And also that type will not in any case be smaller than <code>int</code>, because of promotions.</p>

<p>This is all described in clause <strong>6.3.1 Arithmetic operands</strong> of the <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1548.pdf"" rel=""noreferrer"">C11 standard</a>, which is slightly too long to cite here.</p>
",0
24592956,24592741,1,"<p>Your original code is close to working but you just did a couple of silly mistakes. E.g. while (s[j++]... but then you check s[j] in the next line, it should be the old value of j, not the new value. Also you need to reset j to 0 before the loop. </p>

<p>I'd suggest changing both loops to standard for loops. Also you can use <code>const</code> and <code>restrict</code> to help your compiler out:</p>

<pre><code>void squeeze2(char *restrict s, char const *restrict remove)
{
/* Loop through 'remove' taking each char out of `s` */
    for (; *remove; ++remove)
    {
        size_t out = 0;
        for (size_t in = 0; s[in]; ++in)
        {
            if ( s[in] != *remove )
                s[out++] = s[in];
        }
        s[out] = 0;
    }
}
</code></pre>

<p>Actually my preference would be to have the loops the other way around: loop through <code>s</code>; and use the <code>strchr</code> function to decide whether to keep the current character. It's easier to read, and does fewer writes:</p>

<pre><code>void squeeze2(char *restrict s, char const *restrict remove)
{
/* Loop through 's', only keeping chars that are not in 'remove' */
    char *out = s;

    for (; *s; ++s)
    {
        if ( !strchr(remove, *s) )
            *out++ = *s;
    }
    *out = 0;
}
</code></pre>
",0
24592820,24592741,1,"<p>Here is my solution to your problem.
Let s1 be the string that needs to have letters removed, and let s2 be the string containing the elements to look for.</p>

<pre><code>void squeeze2(char s1[], char s2[]){
  int i, j, k;/*Remove elements of a from s*/
  i=j=k=0;

  /* For each character in s2... */
  while(s2[i] != '\0'){ // Note change of i++ to i

      /* Search for the character in s1...*/
      j = k = 0; // Counters for string1
      while(s1[j]!= '\0'){

        /* If we find a match, remove the character... ('shift' the remaining characters 1 index to the left, overwriting the current character)*/
        if(s1[j]== s2[i]){
            k = j //Start at j
            while(s1[k] != '\0'){ //again, I don't start with k++, just k
              s1[k] = s1[k+1]; // The null-terminator gets copied too.
              k++;
            }
        j++;
        }
      }
      i++;
  }
  //The following line is not necessary because the null-terminator is copied
  //s1[k] = '\0';  
  }
</code></pre>

<p>Please remember to mark correct answers.</p>
",3
27688067,27688047,4,"<p>Multiple issues here.</p>

<ol>
<li><p>After <code>fclose(score);</code>, you're trying to use  <code>fprintf(score,""%d"", s);</code>. Why? Maybe you want to move <code>fclose(score);</code> before <code>return 0</code>;</p></li>
<li><p>Always put a success check on the return value of <code>fopen()</code>. Also, as per your requirement, <code>keep on adding score every time the code is run without deleting the last record</code> you need to <code>fopen()</code> in <em>append</em> mode. Check more about the <em>modes</em> and their usage <a href=""http://linux.die.net/man/3/fopen"" rel=""nofollow"">here</a>.</p></li>
<li><p><code>scanf(""%s"", &amp;n);</code> is wrong. Here what you want is an array, not a single <code>char</code>. Consider changing your <code>char n;</code> to <code>char n[32];</code> or something. [Note: once <code>n</code> is array, change the <code>scanf()</code> to <code>scanf(""%s"", n);</code>]</p></li>
<li><p><code>fprintf(score,""%d"", n);</code> is wrong. Do not use incompatible format specifier. for a string, it should be <code>%s</code>. <em>[Even in your case, <code>n</code> is <code>char</code>. There's no way the format specifier should be <code>%d</code>.]</em></p></li>
</ol>
",7
27688126,27688047,0,"<p>Note also that the name <code>n</code> cannot be stored as a <code>char</code>. It must be either a <code>char []</code> or a <code>char *</code>. This is probably what's causing your crash, though @SouravGhosh is also correct - basically there are (at least) two bugs in your code.</p>

<p>E.g.</p>

<pre><code>char n[80]; // or any other reasonable value, or learn dynamic memory allocation
scanf(""%s"", n);
</code></pre>
",4
27688270,27688047,2,"<p>There are few problems with the code given above.</p>

<ul>
<li>You need to open the file in append mode, if you need to add the new score without deleting the old one. </li>
<li>You have to write the score to file before doing an fclose. </li>
<li>char n can hold only a single char. If your intention is to read a proper name with more characters, you need a char array, like char name[100].</li>
</ul>

<p>The code given below gives a proper way to append to a file. </p>

<pre><code>    FILE *score;
    char name[100];
    int nScore;

// Open the file
    score = fopen(""score.txt"", ""a+"");
    if(!score)
    {
        printf(""Failed to open"");
        return 1;
    }

// Get user inputs
    printf(""You got a high score!\nPlease enter score: "");
    scanf(""%d"", &amp;nScore);
    printf(""\nPlease enter your name: "");
    scanf(""%s"", name);

//Write to file
    fprintf(score, ""Name: %s  Score: %d\n"", name, nScore);

// Close the file
    fclose(score);
    printf(""\nData Stored into score.txt\n"");

    return 0;
</code></pre>
",0
24640599,24640580,6,"<p>You never increment <code>test_num</code> or <code>divisor</code>, so it gets stuck in one of the loops.</p>

<pre><code>while(test_num &lt; num_in) {
    while(divisor &lt; test_num) {
        if(test_num % divisor == 0) {
            primestate = 1;
        }
        divisor++; // NEW LINE            
    }

    if(primestate == 1) {
        printf(""%d is prime and less than %d.\n"", test_num, num_in);
    } else {
        continue;
    }

    test_num++; // NEW LINE
}
</code></pre>

<p>You also have a possible division by 0 (when <code>divisor</code> equals 0) on this line:</p>

<pre><code>if(test_num % divisor == 0) {
</code></pre>
",5
24641190,24640580,0,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

int main(void) {
    unsigned int num_in, test_num, divisor;
    bool primestate;
    printf(""Please enter an integer.\n"");
    scanf(""%u"", &amp;num_in);

    if(2 &lt; num_in)
        printf(""\n%u\n"", 2);
    for(test_num = 3; test_num &lt; num_in; test_num += 2){
        primestate = true;
        for(divisor=3; divisor * divisor &lt;= test_num ; divisor += 2) {
            if(test_num % divisor == 0) {
                primestate = false;
                break;
            }
        }
        if(primestate) {
            printf(""%u\n"", test_num);
        }
    }

    return 0;
}
</code></pre>
",0
29250610,29250471,0,"<p>save your input in a string and use strtok() using delimiter as '.'
Then store it in char array or 4 different char variables</p>
",0
29250699,29250471,0,"<p>Have a look at this example:</p>

<pre><code>#include &lt;stdio.h&gt;

int main() {
    int part1, part2, part3, part4;
    printf(""Enter IP (e.g. 127.0.0.1): "");
    scanf(""%d.%d.%d.%d"", &amp;part1, &amp;part2, &amp;part3, &amp;part4);
    printf(""IP is %d - %d - %d - %d\r\n"", part1, part2, part3, part4);
}
</code></pre>
",1
29250708,29250471,0,"<p>If you are working in a POSIX (or even Windows) environment. You can use: <code>inet_addr</code>:</p>

<ul>
<li><a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/inet_addr.html"" rel=""nofollow"">http://pubs.opengroup.org/onlinepubs/009695399/functions/inet_addr.html</a></li>
<li><a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/ms738563(v=vs.85).aspx"" rel=""nofollow"">https://msdn.microsoft.com/en-us/library/windows/desktop/ms738563(v=vs.85).aspx</a></li>
</ul>

<p>Both these functions returns an integer type suitable for the IPv4 adresses. In practice you should use a variable of type <code>in_addr</code> which contains a member named <code>s_addr</code> (<code>S_addr</code>under windows) of the correct type.</p>

<p>But, beware, it only works for IPv4. As things go, you'd better to prepare for IPv6 addresses too (and these addresses are NOT separated by <code>.</code>).</p>
",0
29251139,29250471,0,"<p>I thing the problem is with <code>target_IP</code> itself.<br>
You are declaring <code>target_IP</code> as a character pointer and nowhere allocating memory to char pointer. Then you are trying to write value to unallocated memory location which will definitely cause segmentation fault.
<br><br>
So first allocate memory to target_IP and then use it as you do.</p>

<pre><code>target_IP = malloc(16); 
scanf(""%s"", target_IP);
</code></pre>
",0
29250973,29250471,1,"<p>The current POSIX standard allows that scanf does a memory allocation to the variable. Notice the additional <code>&amp;</code> to change the variable.</p>

<pre><code>char *target_IP;
scanf(""%ms"", &amp;target_IP);
</code></pre>

<p>Otherwise you need to do</p>

<pre><code>char target_IP[200];
scanf(""%s"", target_IP);
</code></pre>

<p>and still risk a malicious buffer overflow.</p>
",0
29162543,29162219,1,"<p>Fixed code below. It had numerous small issues and a big one.</p>

<p>Please read the related article the big one:</p>

<p><a href=""https://stackoverflow.com/questions/20056892/struct-in-c-error-storage-size-of-params-isnt-known"">struct in C: Error storage size of &#39;params&#39; isn&#39;t known</a> -- this will explain ""storage size unknown"" error; by saying <code>typedef struct FirstLevelHashTable hashTable;</code> you were defining an unfinished struct, rather than referring to existing type.</p>

<p>Header file:</p>

<pre><code>#define MAX1 11
#define MAX2 23

typedef short IP[4];
typedef enum{TRUE = 1,FALSE = 0}boolean;

typedef struct
{
    IP p;
    char *comp_name;
}Element;

typedef struct
{
    Element e;
    boolean deleted; // deleted flag
    boolean empty;
}Cell;

typedef Cell secLevelHashTable[MAX2];
typedef secLevelHashTable* FirstLevelHashTable[MAX1];
typedef FirstLevelHashTable hashTable;
</code></pre>

<p>Main code:</p>

<pre><code>#include""hashDef.h""
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void initSecHTables(Cell *ptr)
{
   ptr-&gt;deleted=0;
   ptr-&gt;empty=1;
}

void initFirstHTable(hashTable H)
{
   int i,j;
   for(i=0;i&lt;MAX1;i++)
   {
       H[i]=(secLevelHashTable *)malloc(sizeof(secLevelHashTable));
       for(j=0;j&lt;MAX2;j++)
       {
           initSecHTables(&amp;((*H[i])[j]));
       }
   }
}

int main()
{
   hashTable h;
   initFirstHTable(h);
   return 0;
}
</code></pre>
",3
31302680,31302417,1,"<p>In <code>isPalindrome</code>, replace the line <code>if(str[i] != str[last-i]){</code> with <code>if(str[i] != str[first+last-i]){</code>.</p>
",0
31302684,31302417,2,"<p>Your code in <code>isPalindrome</code> doesn't work properly unless <code>first</code> is 0.</p>

<p>Consider <code>isPalindrome(6, 10, ""abcdefghhgX"")</code>:</p>

<ul>
<li><code>i = 6</code>;</li>
<li><code>last - i</code> = 4;</li>
<li>comparing <code>str[i]</code> (aka <code>str[6]</code> aka <code>'g'</code>) with <code>str[last-i]</code> (aka <code>str[4]</code> aka <code>'e'</code>) is comparing data outside the range that is supposed to be under consideration.</li>
<li>It should be comparing with <code>str[10]</code> (or perhaps <code>str[9]</code> ¡ª depending on whether <code>last</code> is the index of the final character or one beyond the final character).</li>
</ul>

<p>You need to revisit that code.  Note, too, that your code will test each pair of characters twice where once is sufficient.  I'd probably use two index variables, <code>i</code> and <code>j</code>, set to <code>first</code> and <code>last</code>.  The loop would increment <code>i</code> and decrement <code>j</code>, and only continue while <code>i</code> is less than <code>j</code>.</p>

<pre><code>for (int i = first, j = last; i &lt; j; i++, j--)
{
     if (str[i] != str[j])
         return 0;
}
return 1;
</code></pre>
",1
31302744,31302417,0,"<p>Here's your problem:</p>

<pre><code>for(i = first; i &lt;= last; i++){
    if(str[i] != str[last-i]){
        return 0;
    }
}
</code></pre>

<p>Should be:</p>

<pre><code>for(i = first; i &lt;= last; i++, last--){
    if(str[i] != str[last]){
        return 0;
    }
}
</code></pre>

<p>Also, this:</p>

<pre><code>for(last = strlen(str); last &gt;= i; last--){
</code></pre>

<p>Should be:</p>

<pre><code>for(last = strlen(str) - 1; last &gt;= i; last--){
</code></pre>
",0
30201205,30159153,0,"<blockquote>
  <p>I wanna get this sentence with whitespaces completely: ""I have read this book"" . what should I do?</p>
</blockquote>

<p>The <code>scanf()</code> function only reads one (whitespace-separated) word at a time. To get a full line of text, use the <code>fgets()</code> function instead:</p>

<pre><code>fgets(main_string, sizeof(main_string), stdin);
</code></pre>
",0
28516248,28516211,4,"<p>In your first program, you do <code>i++</code> twice, and <code>m++</code> once. So at the end of the first iteration, the values of i and m are equal (which is 2) - so in the next iteration <code>i &lt; m</code> condition fails, and the loop exits. </p>

<p>In the second case, you set the value of m (the stop condition) to <code>5</code>, and the loop executes until the (<code>m&lt;5</code>) stop condition is met.</p>

<p>Note that it is generally a bad practice to change the value of the stop condition inside the loop, as it leads to confusion such as this. </p>
",0
28516376,28516211,2,"<p>To find errors like these it is helpful to run the program manually line by line and to observe what values the variables take.</p>

<p>For the first program:</p>

<pre><code>int i;             // i = ?
int m = 1;         // i = ?, m = 1
i = 0;             // i = 0, m = 1
i &lt; m              // true
// first iteration
printf (""a"");
i++;               // i = 1, m = 1
m++;               // i = 1, m = 2
i++;               // i = 2, m = 2
i &lt; m              // false
</code></pre>

<p>You see immediately that the problem is the extra <code>i++</code> in the body of the loop.</p>

<p>For the second program:</p>

<pre><code>int i;              // i = ?
int m = 1;          // i = ?, m = 1
i = 0;              // i = 0, m = 1
i &lt; m               // true
// first iteration
printf (""a"");
i++;                // i = 1, m = 1
m = 5;              // i = 1, m = 5
i++;                // i = 2, m = 5
i &lt; m               // true
// second iteration
printf (""a"");
i++;                // i = 3, m = 5
m = 5;              // i = 3, m = 5
i++;                // i = 4, m = 5
i &lt; m               // true
// third iteration
printf (""a"");
i++;                // i = 5, m = 5
m = 5;              // i = 5, m = 5
i++;                // i = 6, m = 5
i &lt; m               // false
</code></pre>

<p>Again you can see why there are only three iterations.</p>

<p>You should learn this ""hand debugging"" technique. It is very helpful to figure out exactly what is happening in your program. Once you have more experience you can use a debugger.</p>
",0
28183691,28160158,0,"<p>The problem is that the initial value of <code>str1</code> is a pointer to a literal string. That pointer cannot be freed. So the fix is to <code>malloc</code> space in <code>main</code>, e.g.</p>

<pre><code>char *str1 = malloc( 100 );  // allocate an initial buffer
int n = 100;                 // the buffer has 100 bytes
strcpy( str1, ""one"" );       // put some text in the buffer
</code></pre>
",0
32389040,32388760,6,"<blockquote>
  <p>First of all does C have a stack class?</p>
</blockquote>

<p>C does not provide a stack class, that's up to you to code.</p>

<blockquote>
  <p>Second How can I do a method to do quicksort in C without using stack and recursion?</p>
</blockquote>

<p>Searching through the internet I found this guy that made a non recursive, non stack quicksort. Looks pretty compact so be careful when reading. Here's the <a href=""http://alienryderflex.com/quicksort/"" rel=""noreferrer"">link</a>.</p>

<blockquote>
  <p>If there is no way to do it without stack can you give me a code for it?</p>
</blockquote>

<p>This one I think is already aswered.</p>
",1
28162768,28162347,0,"<p>Unfortunately, there is no other way. You can simplify memory allocation with another function, like this</p>

<pre><code>Vector* allocate_vector( ) {
  Vector* v = (Vector*)malloc( sizeof(Vector) );
  if( v == NULL ) {
    /**/
  }
  v-&gt;pos = (Point3*)malloc( sizeof(Point3) );
  if( v-&gt;pos == NULL ) {
    /**/
  }
  v-&gt;direction = (Point3*)malloc( sizeof(Point3) );
  if( v-&gt;direction == NULL ) {
    /**/
  }
  return v;
}
</code></pre>

<p>And then use it, when you need new <code>Vector</code>.</p>

<pre><code>Vector* v = allocate_vector( );
</code></pre>
",1
28163039,28162347,1,"<p>To me, it makes far more sense to put the <code>Point3</code> members directly in the <code>Vector</code>, instead of pointers. Fewer allocations, less memory fragmentation, fewer de-references, fewer cache-misses.</p>

<pre><code>typedef struct {
    int x, y, z;
} Point3;

typedef struct {
    Point3 pos, direction;
} Vector;

int main(void) {
    /* Local (stack) allocation of a Vector, initialized to all zeros */
    Vector v = {};    

    /* Dynamic (heap) allocation of a Vector, initialized to all zeros */
    Vector *p;
    p = malloc(sizeof(Vector));
    if (!p) {
       return 1;  // failure
    }
    *p = (Vector){};

    return 0;
}
</code></pre>
",5
28162948,28162347,1,"<p>Yes, there is a shorter way ¡ª one which is one <code>malloc()</code> call shorter.</p>

<pre><code>Vector *p = malloc(sizeof(Vector));
if (p != 0)
{
    p-&gt;pos = malloc(2 * sizeof(Point3));
    if (p-&gt;pos != 0)
        p-&gt;direction = &amp;p-&gt;pos[1];
}
</code></pre>

<p>Allocate an array of 2 <code>Point3</code> values.  <code>p-&gt;pos</code> points to the first, and <code>p-&gt;direction</code> points to the second (or vice versa).</p>

<p>It is still 3 statements (plus error checking) and two calls to <code>malloc()</code>, though.</p>

<p>In practice, you could almost certainly get away with:</p>

<pre><code>Vector *p = malloc(sizeof(Vector) + 2 * sizeof(Point3));
if (p != 0)
{
    p-&gt;pos = (void *)((char *)p + sizeof(Vector));
    p-&gt;direction = (void *)((char *)p + sizeof(Vector) + sizeof(Point3));
}
</code></pre>

<p>I am not sure that is sanctioned by the C standard, but I can't immediately think of a plausible platform configuration where it would actually fail to work correctly. It would fail if you found some bizarre platform where addresses were 16-bits each but <code>int</code> was 8 bytes and had to be 8-byte aligned, but that's hardly plausible.</p>
",0
28200555,28200443,2,"<p>When you do, for example, this:</p>

<pre><code>d = ((x&gt;&gt;24) &amp; mask)&amp;1;
</code></pre>

<p>..you're actually checking whether the lowest bit (with value 1) is set, not whether any of the the mask bits are set... since the <code>&amp;1</code> at the end bitwise ANDs the result of the rest with <code>1</code>.  If you change the <code>&amp;1</code> to <code>== mask</code>, you'll instead get <code>1</code> when all of the bits set in <code>mask</code> are set in <code>(x&gt;&gt;24)</code>, as intended.  And of course, the same problem exists for the other similar lines as well.</p>

<p>If you can't use comparisons like <code>==</code> or <code>!=</code> either, then you'll need to shift all the interesting bits into the same position, then AND them together and with a mask to eliminate the other bit positions.  In two steps, this could be:</p>

<pre><code>/* get bits that are set in every byte of x */
x = (x &gt;&gt; 24) &amp; (x &gt;&gt; 16) &amp; (x &gt;&gt; 8) &amp; x;
/* 1 if all of bits 0, 2, 4 and 6 are set */
return (x &gt;&gt; 6) &amp; (x &gt;&gt; 4) &amp; (x &gt;&gt; 2) &amp; x &amp; 1;
</code></pre>
",8
28200536,28200443,2,"<p>I don't know why you are ANDing your values with 1. What is the purpose of that?</p>

<p>This code is untested, but I would do something along the lines of the following.</p>

<pre><code>int allEvenBits(int x) {
    return (x &amp; 0x55 == 0x55) &amp;&amp;
        ((x &gt;&gt; 8) &amp; 0x55 == 0x55) &amp;&amp;
        ((x &gt;&gt; 16) &amp; 0x55 == 0x55) &amp;&amp;
        ((x &gt;&gt; 24) &amp; 0x55 == 0x55);
} 
</code></pre>
",12
28200588,28200443,0,"<p>the main problem in your code that you're doing &amp;1, so you take first 8 bits from number, mask them with 0x55 and them use only 1st bit, which is wrong</p>

<p>consider straightforward approach:</p>

<pre><code>int evenBitsIn8BitNumber(int a) {
    return (a &amp; (a&gt;&gt;2) &amp; (a&gt;&gt;4) &amp; (a&gt;&gt;6)) &amp; 1;
}

int allEvenBits(int a) {
    return evenBitsIn8BitNumber(a) &amp;
        evenBitsIn8BitNumber(a&gt;&gt;8) &amp;
        evenBitsIn8BitNumber(a&gt;&gt;16) &amp;
        evenBitsIn8BitNumber(a&gt;&gt;24);
}
</code></pre>
",2
28200630,28200443,1,"<p>Say you are checking the first 4 least significant digits, the even ones would make <code>1010</code>. Now you should AND this with the first 4 bits of the number you're checking against. All 1's should remain there. So the test would be <code>((number &amp; mask) == mask)</code> (mask is 1010) for the 4 least significant bits, you do this in blocks of 4bits (or you can use 8 since you are allowed).</p>
",0
28201332,28200443,1,"<p>If you aren't allowed to use constants larger than <code>0xff</code> and your existing program works, how about replacing:</p>

<pre><code>int all_even_bits = 0x55555555;
</code></pre>

<p>by:</p>

<pre><code>int all_even_bits = 0x55;
all_even_bits |= all_even_bits &lt;&lt; 8;  /* it's now 0x5555 */
all_even_bits |= all_even_bits &lt;&lt; 16; /* it's now 0x55555555 */
</code></pre>

<p>Some of the other answers here right shift signed integers (i.e. <code>int</code>) which is undefined behaviour.</p>

<p>An alternative route is:</p>

<pre><code>int allevenbitsone(unsigned int a)
{
    a &amp;= a&gt;&gt;16; /* superimpose top 16 bits on bottom */ 
    a &amp;= a&gt;&gt;8;  /* superimpose top 8 bits on bottom */
    a &amp;= a&gt;&gt;4;  /* superimpose top 4 bits on bottom */
    a &amp;= a&gt;&gt;2;  /* and down to last 2 bits */
    return a&amp;1; /* return &amp; of even bits */
}
</code></pre>

<p>What this is doing is and-ing together the even 16 bits into bit 0, and the odd 16 bits into bit 1, then returning bit 0.</p>
",0
29182631,29182601,0,"<p>In your following program...</p>

<pre><code>#include &lt;stdio.h&gt;

//program to convert Celsius to Fahrenheit


int main()
{
    int c;
    int f;

    printf(""Enter the temperature in Celsius:"");
    scanf(""%d\n"", &amp;c);
</code></pre>

<p>This line waits for user input on console</p>

<pre><code>    f=9*c/5 + 32;
    printf(""The temperature in Fahrenheit is: %d\n"",f);
    return 0;
}
</code></pre>

<p>When you run the program, you are suppose to enter integer when program is waiting. Once you enter the value, program will continue, do the conversion and show you output.</p>
",0
29184600,29182601,2,"<p>The problem lies in this line of code:</p>

<pre><code>scanf(""%d\n"", &amp;c);
</code></pre>

<p>The escape sequence '\n' does not behave like you think it does in this context: it's not telling scanf() to expect an input x number in the form x\n where '\n' is a linefeed but is actually interpreted as pattern that must be matched exactly since scanf() doesn't expand escape sequences.</p>

<p><a href=""https://www.gnu.org/software/libc/manual/html_node/Input-Conversion-Syntax.html#Input-Conversion-Syntax"" rel=""nofollow"">From the glibc manual</a>:</p>

<blockquote>
  <p>Other characters in the template string that are not part of conversion specifications must match characters in the input stream exactly; if this is not the case, a matching failure occurs. </p>
</blockquote>

<p>So, if you enter 10\n as input (where \n are <em>actual</em> characters and not a linefeed), your program works. </p>

<p>Since this is obviously not the behaviour that you were looking for, you can solve the problem by removing \n from the template string that you're using to call scanf().</p>

<p>In any case, scanf() by default ignores whitespace (such as '\n') <em>unless</em> you're using %c or %[ as conversion specifiers, so there's no need to try to handle it.</p>

<p>On a side note, there's a mistake in this line</p>

<pre><code>f=9*c/5 + 32;
</code></pre>

<p>the correct conversion formula is</p>

<pre><code>f=(9/5) * c + 32;
</code></pre>

<p>While doing computer arithmetic the order of operations affects the final result. (Anyway, in this case, it's better to use floats to limit precision loss)</p>
",5
26195936,26195891,0,"<p>There are several correct ways to write this. I would prefer the following:</p>

<pre><code>temp-&gt;children[currChar].children = calloc(27, sizeof(struct node));
</code></pre>

<p>(i.e. use the type name instead of the long expression, and <a href=""https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc"">no cast</a>.)</p>

<p>Apart from that, I am not terribly keen on the magic number (<code>27</code>).</p>
",0
28165107,28164804,2,"<p>The program is invalid. A GCC extension allows GCC to accept it.</p>
<p>To turn the extension off, use the flag <code>-fno-common</code>.</p>
<p>The <a href=""https://gcc.gnu.org/onlinedocs/gcc/Code-Gen-Options.html"" rel=""nofollow noreferrer"">GCC documentation</a> says:</p>
<blockquote>
<p><code>-fno-common</code></p>
<blockquote>
<p>In C code, controls the placement of uninitialized global variables. Unix C compilers have traditionally permitted multiple definitions of such variables in different compilation units by placing the variables in a common block. This is the behavior specified by <code>-fcommon</code>, and is the default for GCC on most targets. On the other hand, this behavior is not required by ISO C, and on some targets may carry a speed or code size penalty on variable references. The <code>-fno-common</code> option specifies that the compiler should place uninitialized global variables in the data section of the object file, rather than generating them as common blocks. This has the effect that if the same variable is declared (without <code>extern</code>) in two different compilations, you get a multiple-definition error when you link them. In this case, you must compile with <code>-fcommon</code> instead. Compiling with <code>-fno-common</code> is useful on targets for which it provides better performance, or if you wish to verify that the program will work on other systems that always treat uninitialized variable declarations this way.</p>
</blockquote>
</blockquote>
",0
28165127,28164804,3,"<p>Formally, you are right: this is an error. But most C implementations support it as an extension (at least by default). C99 actually mentions it in informative Annex J as a common extension</p>
<blockquote>
<p><strong>J.5.11 Multiple external definitions</strong></p>
<p>1 There may be more than one
external definition for the identifier of an object, with or without
the explicit use of the keyword <strong>extern</strong>; if the definitions disagree,
or more than one is initialized, the behavior is undefined (6.9.2)</p>
</blockquote>
",0
29190978,29190899,2,"<p>Lashane suggested:</p>

<blockquote>
  <p>Use recursion without array.</p>
</blockquote>

<p>It is a fantastic idea. Here's how you could go about it.</p>

<pre><code>#include &lt;stdio.h&gt;
void print_rec(int index, int maxindex)
{
    int age;
    printf(""Enter age of person %d"",index);
    scanf(""%d"",&amp;age);
    if (index == maxindex)
    {
        printf(""The ages are %d "",age);
        return;
    }
    print_rec(index + 1, maxindex);
    printf("",%d"",age);
}
int main()
{
    printf(""Enter the number of people : "");
    int num;
    scanf(""%d"",&amp;num);
    print_rec(1,num);
    return 0;
}
</code></pre>

<p>The only shortcoming, though is it prints the age in <strong>reverse order</strong>.</p>
",6
29191098,29190899,1,"<p>If you need to store them you can use following, this is embedded way of doing things. :)</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void) {
  long ages = 0;
  int cnt = 0, i = 0, age = 0;

  printf(""How many people do you have? (8 maximumimum):\t"");
  scanf(""%d"", &amp;cnt);

  for(i = 0; i &lt; cnt; ++i) {
    printf(""Enter the age of person: "");
    scanf(""%d"", &amp;age);
    ages = ages | age;
    ages &lt;&lt;= 8;
  }

  ages &gt;&gt;= 8;
  for(; i;  --i) {
    printf(""Age of person nubmer %d is %d\n"", i, ages &amp; 255);
    ages &gt;&gt;= 8;
  }
}
</code></pre>

<p>This might not help you but is a cool way of doing it :)</p>
",0
26811160,26810573,0,"<p>Assuming b0, b1, and b2 are all bits within the <code>num</code> variable, and assuming little-endianness:</p>

<pre><code>num = 1 | 4;
</code></pre>

<p>If you really needed to use the <code>b*</code> variables (I'm assuming you don't), You could do this:</p>

<pre><code>unsigned char b0 = 1U;
unsigned char b1 = 2U;
unsigned char b2 = 4U;
unsigned char num = b0 | b2;
</code></pre>
",4
29233285,29232447,0,"<p>When you call <code>bst_ins</code>, <code>bst</code> may be <code>NULL</code>, so you can't dereference it. Also, you define a temporary node, which is <code>NULL</code>. When you get to your string comparisons, </p>

<pre><code>if (strcmp(temp-&gt;kvp.key, key) &lt; 0) ...
</code></pre>

<p>you certainly dereference a <code>NULL</code> pointer. Not good. The code below fixes the issue and also calls <code>strcmp</code> only once per pass. Note how <code>temp</code> is defined only in the scope where a new node is created.</p>

<pre><code>BST *bst_ins(BST * bst, char *key, void *value)
{
    int cmp;

    if (bst == NULL) {
        BST *temp = (BST *) malloc(sizeof(*temp));

        temp-&gt;left = NULL;
        temp-&gt;right = NULL;
        temp-&gt;kvp.key = key;
        temp-&gt;kvp.value = value;

        return temp;
    }

    cmp = strcmp(bst-&gt;kvp.key, key);

    if (cmp &lt; 0) {
        bst-&gt;right = bst_ins(bst-&gt;right, key, value);
    } else if (cmp &gt; 0) {
        bst-&gt;left = bst_ins(bst-&gt;left, key, value);
    }

    return bst;
}
</code></pre>

<p>You can now insert new nodes like so:</p>

<pre><code>bst = bst_ins(bst, ""plum"", ""1"");
bst = bst_ins(bst, ""apple"", ""2"");
bst = bst_ins(bst, ""orange"", ""3"");
bst = bst_ins(bst, ""kumquat"", ""4"");
</code></pre>

<p>But that is a bit clumsy, because you have to assign the result to the root node, which is redundant and easy to forget. You also lose the useful possibility to return the (possibly new) node associated with the key.</p>

<p>A better approach might be to pass the address of the root node to functions that may change the tree. If you are not afraid of the <code>(*bst)</code> notation and the address-of poerator <code>&amp;</code>, here goes:</p>

<pre><code>BST *bst_ins(BST **bst, char *key, void *value)
{
    int cmp;

    if (*bst == NULL) {
        *bst = (BST *) malloc(sizeof(**bst));

        (*bst)-&gt;left = NULL;
        (*bst)-&gt;right = NULL;
        (*bst)-&gt;kvp.key = key;
        (*bst)-&gt;kvp.value = value;

        return *bst;
    }

    cmp = strcmp((*bst)-&gt;kvp.key, key);

    if (cmp &lt; 0)  return bst_ins(&amp;(*bst)-&gt;right, key, value);    
    if (cmp &gt; 0)  return bst_ins(&amp;(*bst)-&gt;left, key, value);

    return *bst;
}
</code></pre>

<p>and call it like so:</p>

<pre><code>bst_ins(&amp;bst, ""plum"", ""1"");
bst_ins(&amp;bst, ""apple"", ""2"");
bst_ins(&amp;bst, ""orange"", ""3"");
bst_ins(&amp;bst, ""kumquat"", ""4"");
</code></pre>

<p>The function returns the node associated with the key, but you can easily ignore the return value.</p>

<p>Finally, make sure that your tree is properly deleted when you are done.</p>
",3
29233118,29233098,1,"<p>Remove the semicolon here:</p>

<pre><code>while ( fgets(ch,1000,f) !=NULL) ;//This one
</code></pre>

<p>The semicolon makes the loop equivalent to</p>

<pre><code>while ( fgets(ch,1000,f) !=NULL)
{}
</code></pre>

<p>and therefore, has an empty body. The loop goes on executing the <code>fgets</code> until it returns <code>NULL</code> and when it breaks, <code>ch</code> will contain the last line and this is what your <code>printf</code> prints.</p>
",2
29233132,29233098,0,"<p>There is an extra <code>;</code> at the end of the <code>while</code> condition.</p>

<p>Use this style to avoid such mistakes:</p>

<pre><code>while (fgets(ch, 1000, f) != NULL) {
    printf(""%s"", ch);
}
</code></pre>
",2
28447148,28447041,0,"<p>You should use boolean array of addOn rather then declaring 3 different variable. And to make any modification use functions. </p>

<p>1) Like buy() <br>
2) Modify() <br>
3) Print() </p>

<p>Use sum variable, that will calculate the total cost. And whenever bill is to be modified just send sum to Modify() as argument and add or decrease from the sum.</p>

<p>This is simple approach try it. And make sure to keep a check so that customer can't use Modify() without buying something!</p>
",0
28447159,28447041,0,"<p>First thing, use array to store addon. And use (user input - 1) as array index;</p>

<p>You are not adding prices. In each if statement that check for user input, add prices as well.</p>

<pre><code>price = 0
if(addon1 == 1)
{
        printf(""8 GB Memory:        \t 99.00\n"");
        price += 99.00;
}
else if(addon1 == 2)
{
        printf(""12 GB Memory:       \t 189\n"");
        price += 189.00
}
</code></pre>

<p>..................
And so on.</p>
",0
27521868,27518540,4,"<p>The <em>static</em> storage class is related to the linkage and storage of an <em>object</em>. It doesn't really have anything to do with the <em>type</em> of the object.</p>

<p>Below is an explanation of what (I think) your program is doing:</p>

<hr>

<pre><code>enum day {sun=1,mon,tue,wed,thur,fri,sat};
</code></pre>

<p>This declares an enumerated type with the tag name <code>day</code>, and also defines a number of enumeration constants and their values.</p>

<pre><code>static enum direction {UP,DOWN,RIGHT,LEFT};
</code></pre>

<p>This declares an enumerated type with the tag name <code>directions</code>, and also defines a number of enumeration constants and their values.</p>

<p>The <code>static</code> <em>storage-class</em> is meaningless here, because you are not defining (allocating storage) for an object.</p>

<pre><code>int static_enum()
{
    static enum direction dir = UP;
    printf(""dir = %d\n"",dir);
    dir++;
}
</code></pre>

<p>This defines a block-scope object named <code>dir</code> of type <code>enum direction</code>. The <code>static</code> <em>storage-class</em> means that the object will be allocated and initialized at program startup, and that it will retain its last stored value between function calls.</p>

<pre><code>int main()
{
    printf(""\nsun = %d mon = %d tue = %d wed = %d thurs = %d fri = %d sat = %d\n"",sun,mon,tue,wed,thur,fri,sat);
</code></pre>

<p>This will output the values of the enumeration constants.</p>

<pre><code>enum day fri = 25;
</code></pre>

<p>This defines a block-scope object named <code>fri</code> of type <code>enum day</code>, initialized with the value <code>25</code>. The enumeration constant also named <code>fri</code> will not be visible anymore within this block (unless you re-declare <code>enum day</code>).</p>

<pre><code>// now friday gets modified from 21 to 25 becasue we have re-assigned the value
printf(""\nfri = %d\n"",fri);
</code></pre>

<p>This outputs the value of the <em>object</em> <code>fri</code>, <strong>not</strong> the value of the <em>enumeration constant</em> <code>fri</code>. Nothing has been modified.</p>

<pre><code>// now saturday will still have value 22
printf(""\nsat = %d\n"",sat);
</code></pre>

<p>This outputs the value of the enumeration constant <code>sat</code>, as expected.</p>

<pre><code>printf(""\n""); 
static_enum();
static_enum();
    return 0;
}
</code></pre>

<hr>

<p>One might wonder why the language allows the <code>static</code> <em>storage-class</em> in a declaration that does not define (allocate storage for) an object. I <em>think</em> this is just a syntactical convenience due to the way that declarations and definitions share the same syntax. The C syntax allows you to pile any number of <em>storage-class</em>, <em>type-specifier</em>, <em>type-qualifier</em>, <em>function-specifier</em> and <em>alignment-specifier</em> in any order in a declaration. However, many combinations are disallowed or cause <em>undefined behavior</em> according to various semantic sections of the C standard. I don't <em>think</em> there is anything that prohibits the meaningless <code>static</code> keyword in the declaration of <code>direction</code>.</p>
",1
28484649,28482990,0,"<p>Well it's in haste solution, but it works.. Of course you need to dynamically allocate memory in parse function with some kind of <code>list</code> for example (for different arguments) and some kind of buffer for current argument processing.</p>

<pre><code>    #include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define MAX_TOKEN  5
#define MAX_LENGTH 64

void copy_str( char* dst, char* src, int size ) {
    int i = 0;
    for( i = 0; i &lt; size; ++i ) {
        dst[i] = src[i];
    }
}

char** parse( char* line, int size, int* argc ) {
    int i = 0, j = 0;
    char** argv = NULL;
    argv = (char**)calloc( MAX_TOKEN, sizeof(char*) );
    for( i = 0; i &lt; MAX_TOKEN; ++i ) {
        argv[i] = (char*)calloc( MAX_LENGTH, sizeof(char) );
    }
    for( i = 0; i &lt; size; ++i ) {
        if( line[i] == ' ' ) {
            copy_str( argv[*argc], line + j, i - j );
            j = i + 1; // length of token
            (*argc)++;
        }
    }
    // copy last
    copy_str( argv[*argc], line + j, i - j );
    (*argc)++;
    return argv;
}

int main( ) {
    int t = 0, i;
    char* s = ""cd /mnt/cdrom"";
    char** argv = parse( s, 13, &amp;t );
    for( i = 0; i &lt; t; ++i ) {
        printf( ""%s\n"", argv[i] );
    }
    t = 0;
    s = ""ls -l /home/"";
    argv = parse( s, 12, &amp;t );
    for( i = 0; i &lt; t; ++i ) {
        printf( ""%s\n"", argv[i] );
    }
    return 0;
}
</code></pre>
",4
29467536,29467359,1,"<p>On the topic of undefined behaviour, the <code>l</code> length modifier in <code>%lf</code> is only defined for conversion specifiers using <em>integer</em> types. If you meant to use <code>%Lf</code>, then your argument should be a <code>long double</code>. Perhaps you meant to use <code>%f</code>, which corresponds to a <code>double</code> argument (<code>float</code>s end up promoted to <code>double</code> when passing them to variadic functions such as <code>printf</code>).</p>

<p>As Peter Ivanov explained, your calculations cause an overflow, which IIRC is also undefined behaviour.</p>

<p>As you've probably guessed, you might find a solution to your problem by using the <code>long double</code> type (and the corresponding <code>%Lf</code> format specifier) throughout your code...</p>
",0
29467435,29467359,1,"<p>Because it overflows.</p>

<p>The value of <code>f</code> after 16 iterations is bigger than if your code looked like this and your initial <code>f</code> was 2:</p>

<pre><code>f *= f*f;
</code></pre>

<p>Which is the same as</p>

<pre><code>f = f*f*f
</code></pre>

<p>So you take a cube 16 times - this is HUGE!</p>

<p>2^3 = 8</p>

<p>8^3 = 512</p>

<p>512^3 = 134217728</p>

<p>...</p>
",3
31818932,31175599,0,"<p>In C</p>

<pre><code>if(!found){
    //This statements works only when ""found"" equal to 0
}
</code></pre>

<p>In contrary</p>

<pre><code>if(found){
   //This statement works only when ""found"" not equal to 0
}
</code></pre>

<p>In c++ we can use bool as a Boolean variable... Now suppose</p>

<pre><code>bool found
if(!found){
//This statement works when found = false;
}
</code></pre>
",0
31175618,31175599,4,"<p>In <code>C</code>, <code>0</code> means <code>boolean false</code>, and any other <em>non zero</em> values are treated as <code>boolean true</code>.</p>

<p>So, <code>if (!found)</code> will go to <em>true</em> path if <code>found = 0</code>.</p>

<blockquote>
  <p><code>if(!found)</code> is it the same as saying <code>if(found==0)</code>?</p>
</blockquote>

<p>Yes it is!</p>
",0
31175673,31175599,1,"<p>From what you describe your source should look like this:</p>

<pre><code>find_occurences(const int a[], size_t n, int x, size_t *pfirst, size_t *plast)
{
    size_t i;
    int found = 0; 

    for (i=0; i&lt;n; i++) // go through all items from first to last
    {
        if (a[i] == x) // if the item is the searched one ...
        {
            *plast = i; // mark as last (every time one is found)
            //foundlast = 0; not needed
            if (!found) // if there hasn't been one found yet ...
            {
                *pfirst = i; // mark as first
                found = 1; // will never enter this if again, thus only on first
            }
        }
    }
}
</code></pre>

<p>I assume you had some copy-paste errors.</p>

<p>And to address your main question: All non-zero values in C yield <code>true</code> in an <code>if</code>-statement.</p>

<p>I'd suggest taking a look at this <a href=""https://stackoverflow.com/questions/2319766/how-does-logical-negation-work-in-c"">related question</a> for clarification.</p>
",1
28149984,28149724,1,"<p>You should note that the C specification doesn't actually mention anything about ""the stack"". Using the stack is just an implementation detail, and compiler-designers/-programmers are free to use any other method to implement function calls and local variable storage. However, which method is used, it ultimately will use up some resource (like memory) and like everything else the resources on a computer are limited, so using them up will sooner or later cause some kind of overflow situation.</p>

<p>On the other hand, an <em>empty</em> <code>while</code> loop doesn't actually use any extra resources no matter how many iterations it does. In your case it's more complicated than that because you don't know what <code>printf</code> does or what resources it uses or what resources the layers beneath the <code>printf</code> call uses, so there might be a limit there too. For example, what if the terminal window is set to use ""infinite"" scrollback, then that scrollback will expand until it consumes all available memory.</p>
",0
28149794,28149724,5,"<p>As noted, the recursive method will consume stack, and <em>ultimately</em> you'll run out of stack space.</p>
",0
28149796,28149724,2,"<p>The first one will most likely generate a <a href=""http://en.wikipedia.org/wiki/Stack_buffer_overflow"" rel=""nofollow"">stack overflow</a> while the second one will potentially run forever.</p>
",0
28149812,28149724,4,"<p>The main obvious difference is that the first example will certainly result in a stack overflow while the second example does not.</p>

<p>That's due to the fact that in the first case every time main() is called the return address is pushed to the stack before jumping to the start of the main() function. These return addresses are never popped from the stack since the function never returns.</p>

<p>In the infinite loop, this is not the case and only the printf() function is called and returned from over and over again which will not result in a change in the stack pointer.</p>
",0
28149820,28149724,0,"<p>Infinite recursion will cause an ugly <code>Segmentation Fault</code>, second one will run <em>forever</em>.</p>
",0
28149873,28149724,0,"<p>Infinite recursion is always a horrible idea. Don't do that.</p>

<p>You are at the mercy of your compiler. If it optimizes it into an infinite loop, you're lucky. If not, you'll run out of stack space and your app will (most likely) crash.</p>
",0
28149930,28149724,0,"<p>The loop will run forever, while the recursive code will eventually cause a stack overflow as the stack buffer runs full.</p>

<p>If you have the choice between a recursive function and an iterative, you should prefer the iterative, as recursive code can lead to stack overflow and other issues more likely. Also, it consumes memory (on the stack), while a loop doesn't allocate more memory each run.</p>
",0
28476134,28476014,0,"<pre><code>if( i &gt; j)
{
  swap( i, j );
}
</code></pre>

<p>If your requirement is to swap <code>i</code> and <code>j</code> if <code>i&gt;j</code> then do it as shown in the above code. Not a good idea to use macro here</p>

<pre><code>void func(int *i,int *j)
{
   int t;
   t = *i;
   *i = *j;
   *j = t;
}
</code></pre>

<p>and call</p>

<pre><code>if(i&gt;j)
func(&amp;i,&amp;j);
</code></pre>
",0
28476153,28476014,0,"<p>You need to wrap your macro with a do ... while(0), like this:</p>

<pre><code>#define swap(a,b) do { temp=a; a=b; b=temp;  } while(0)
</code></pre>

<p>Thus, the ""if"" will have an effect on the whole macro.</p>
",2
28476255,28476014,0,"<p>Only the first statement of the macro (i.e. <code>temp=a;</code>) is inside the <code>if(i &gt; j)</code> condition. That's why you don'get what you expect.</p>

<p>You should surround any multi-statement macro with {} to avoid this problem. </p>

<pre><code>#define swap(a,b) {temp=a; a=b; b=temp;}
</code></pre>

<p>This also allows you to declare <code>temp</code> inside the macro as it has its own local scope if you want, although this restricts the data type. </p>
",0
28476085,28476014,8,"<p>The macro <code>swap</code> is not a C function, instead the preprocessor inserts the macro <em>as is</em> in the place of the macro invocation, so the code looks like this:</p>

<pre><code>if( i &gt; j)
temp=i; i=j; j=temp;;
</code></pre>

<p>And after reformatting the code is</p>

<pre><code>if( i &gt; j)
    temp=i;
i=j;
j=temp;
;
</code></pre>

<p>Only the assignment to <code>temp</code> is done if the condition is true, the other two assignments are <em>always</em> done <em>unconditionally</em>.</p>

<p>This can be solved in two ways: Put the macro invocation inside a statement block:</p>

<pre><code>if( i &gt; j)
{
    swap( i, j );
}
</code></pre>

<p><em>Or</em> make the macro body a block:</p>

<pre><code>#define swap(a,b) do { temp=(a); (a)=(b); (b)=temp; } while (0)
</code></pre>

<p>The convention to put multi-statement macros inside a <code>do { ... } while (0)</code> statement is because otherwise you get an empty statement (like you do now, see above), which can cause problems when expanding the macro as part of e.g. an <code>if else</code> statement.</p>
",6
27179014,27178942,0,"<p><code>char string[128];</code> allocates space, so string is not a true pointer.</p>

<p>If you had string defined as follows it will work:  <code>char *string;</code></p>
",0
27179117,27178942,3,"<p><code>char string[128];</code> defines a statically sized array of <code>char</code>s. There is no need to allocate memory for it, but, on the other hand, there is no way to resize the memory portion.</p>

<p>To use a dynamically sized array use <code>char *string;</code> with <code>string = malloc(128)</code>, <code>string = realloc(string, newsize)</code> and <code>free(string)</code> when you are done.</p>
",0
29504905,29504787,0,"<p>You're for loop <code>for (c = 1; c &lt;= space; c++)</code> adds a <code>' '</code> from 1 to whatever <code>space</code> equals. The output you're receiving differs from the output you desire by one space. You can do two things:</p>

<p>Set <code>space</code> equal to n before the loop:</p>

<pre><code>space = n - 1;
</code></pre>

<p>becomes</p>

<pre><code>space = n;
</code></pre>

<p>or set <code>c</code> equal to zero in the loop.</p>

<pre><code>for (c = 0; c &lt;= space; c++)
</code></pre>
",2
29504936,29504787,0,"<p>Add 1 for <code>space</code></p>

<pre><code>for (c = 1; c &lt;= space+1; c++)
</code></pre>

<p>and </p>

<pre><code>for (c = 1; c &lt;= space+1; c++)
</code></pre>

<p>The output is </p>

<p><img src=""https://i.stack.imgur.com/w9BMV.png"" alt=""enter image description here""></p>
",5
29497843,29497798,1,"<p>The variable s is a pointer to a float. It's not a float. To get the value that is being pointed to, you need to use *s like this: comp[j].solde+=*s;</p>
",0
29497859,29497798,1,"<p>You tried to add a pointer to a floating point number.</p>

<p>However in this case the declaration is wrong and it should be ""float s;"" instead of ""float *s;"" In addition, correct ""*s/=4.0;"" to ""s/=4.0;"".</p>
",0
29497942,29497798,1,"<p>In your code, you have</p>

<pre><code>float *s;
scanf(""%i"",&amp;s);
</code></pre>

<p>and you try</p>

<pre><code>*s/=4.0;
</code></pre>

<p>You'll probably get a SIGSEGV for that because you are allocating the address given by the user to <code>s</code>, which will almost surely result in a Segmentation Fault.</p>

<p>Also, you are trying</p>

<pre><code>comp[j].solde+=s;
</code></pre>

<p>and <code>s</code> is a pointer, so you are trying to add the address of <code>s</code> to it ( no idea why you are doing that ) .</p>

<p>So, I suggest you change <code>s</code> from a pointer to a normal float </p>

<pre><code>float s;
</code></pre>
",3
29952613,29952514,0,"<p>The first <code>if</code> block along with the inner one is saying, ""If the input is a space and the <code>inspace</code> flag is zero, print it, and also set the flag to one"". I.e. print space if it is the first one, and indicate the next one won't be the first. The second block is saying ""If the input is not space, print it and reset the previous spaces flag so the next encountered space will be considered the first one."". That's all.</p>
",0
29952623,29952514,1,"<blockquote>
  <p>how does <code>putchar(c)</code> not output the same exact data that came in.</p>
</blockquote>

<p>When the code reaches <code>putchar(c)</code>, it outputs the same exact character that came in. However, the code may not be reaching <code>putchar(c)</code> on some of the iterations.</p>

<blockquote>
  <p>what importance does <code>inspace == 1</code> or <code>0</code> have?</p>
</blockquote>

<p>Once the program sets <code>inspace</code> to <code>1</code>, it stops printing further space characters, because the code will not reach <code>putchar(c)</code> on second and subsequent iterations of the loop.</p>

<p><code>inspace</code> is set to <code>1</code> after printing the first space in a sequence of one or more spaces.  If <code>inspace</code> is set to zero coming into the first conditional, a space would be printed; otherwise, no space would be printed.</p>

<p>Here is a diagram that explains what is happening:</p>

<p><img src=""https://i.stack.imgur.com/8FYvH.png"" alt=""Diagram""></p>

<p>The program starts in the black circle, and proceeds to one of two states, depending on the input character:</p>

<ul>
<li>If the character is space, the state on the left is entered, when the first space is printed, and the rest of spaces are ignored (i.e. <code>inspace</code> is set to <code>1</code>)</li>
<li>If the character is non-space, the state on the right is entered, when each character is printed.</li>
<li>Each time a new character is read the program decides if it wants to switch the state, or to remain in the current state.</li>
</ul>

<p>Note: the diagram is not showing the <code>EOF</code> to save some space. When <code>EOF</code> is reached, the program exits.</p>
",0
29952651,29952514,2,"<p>Think about the logic in this block when there are two ore more consecutive <code>' '</code> characters in the input.</p>

<pre><code>    if(c == ' ')
    {
        if(inspace == 0)
        {
            inspace = 1;
            putchar(c);
        }
    }
</code></pre>

<p>When the first space character is encountered, the code enters the nested <code>if</code> block and prints the character.</p>

<p>When the second space character is encountered, the code does not enter the nested <code>if</code> block and the character is not printed.</p>

<p>If you follow this logic, you'll notice that if there are two or more consecutive space characters in the input, only one is printed.</p>
",1
29952655,29952514,4,"<blockquote>
  <p>First of all, how does putchar(c) not output the same exact data that came in. Despite it checking for a blank or != blank, it still says to output ""c"" which is just getchar(c) meaning whatever was inputted. I see no code that specifies to delete extra spaces and output just one space. Where does the code specify that that is what must take place? I'm having trouble understanding how getchar/putchar works it seems to me.</p>
</blockquote>

<p>You are correct that <em>if</em> putchar is called, it just outputs the input character. The key to this program is that putchar isn't called on every input character. The various <code>if</code> statements control when it is called. At a high level, the program avoids calling putchar on the second, third, fourth, etc., spaces if there are multiple spaces in a row. It's only called on the first space.</p>

<blockquote>
  <p>Also, what importance does inspace == 1 or 0 have? If inspace is == 1 then it just outputs the characters inputted back out. There's nothing saying that the extra blanks are deleted and inspace isn't defined as anything except 0 or 1, there's nothing defining it as a space so how can it possibly have any real meaning as to what the program is doing? </p>
</blockquote>

<p>Don't think of it as spaces being <em>deleted</em>. Think of it as them being <em>omitted</em>. Sometimes putchar is called, sometimes it isn't. Look at the loop and try to figure out what conditions would cause putchar <em>not</em> to be called.</p>

<p>Importantly, look at what happens if you start a loop iteration, <code>inspace == 1</code>, and <code>c == ' '</code>. What happens?</p>

<p>It might help to put together a table showing when putchar is and isn't called.</p>

<pre class=""lang-none prettyprint-override""><code>Is putchar(c) called?
=====================

             | c == ' ' | c != ' '
-------------+----------+---------
inspace == 0 |    Y     |    Y
inspace == 1 |    N     |    Y
</code></pre>
",0
29512900,29512830,4,"<p>You are using</p>

<pre><code>ptr1=(int*)malloc(score*sizeof(int));
</code></pre>

<p>inside your for loop. That causes memory leak. You should free the memory.</p>

<p>You also have</p>

<pre><code> printf(""%d%d "", i, ptr[i]);
</code></pre>

<p>But <code>ptr[i]</code>  has not been assigned any value, so it just gives garbage value. The same problem occurs in</p>

<pre><code>for(j = 1; j&lt;= ptr1[i]; j++)
</code></pre>

<p>So you need to assign some value to them before using them like this.</p>
",4
29513577,29512830,0,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void){
    int **scores;
    int over, score;
    int i, j;

    printf(""Enter the number of over : "");
    scanf(""%d"", &amp;over);
    scores = (int**)malloc(over*sizeof(int*));

    for(i = 0; i &lt; over; i++){
        printf(""%d "", i + 1);
        printf(""Enter the number of run per over : "");
        scanf(""%d"", &amp;score);
        scores[i] = (int*)malloc((score+1) * sizeof(int));// +1 for number of columns
        scores[i][0] = score;
        for(j = 1; j &lt;= score; j++){
            printf(""%d Enter the score : "", j);
            scanf(""%d"", &amp;scores[i][j]);
        }
    }
    for(i = 0; i &lt; over; i++){
        for(j = 1; j &lt;= scores[i][0]; j++){
            printf(""|%d"", scores[i][j]);
        }
        printf(""|\n"");
    }
    //deallocate
    for(i = 0; i &lt; over; i++)
        free(scores[i]);
    free(scores);
    return 0;
}
</code></pre>
",2
29513215,29512830,0,"<ul>
<li>Casting the result of malloc doesn't make any sense, it is <a href=""https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc"">pointless and potentially bad practice</a>.</li>
<li><code>printf(""%d%d "", i, ptr[i]);</code>. You print the value of an uninitialized memory cell. This is undefined behavior and might in theory cause the program to crash on some platforms. If you need the memory allocated to be initialized to zero, you should be using calloc() instead.</li>
<li><code>ptr1=(int*)malloc(score*sizeof(int)); for(j = 1; j&lt;= ptr1[i]; j++)</code> This code makes no sense whatsoever and will crash the program. You use ptr1 as if it was an initialied array of integers, while it is actually an uninitialized, single integer.</li>
</ul>
",0
28528169,28528127,1,"<p>Try doing an fclose on fp_1 before opening the file again as fp_2.</p>
",0
28528602,28528127,0,"<p>The key is to use another file for the second output.
</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    FILE *input_file, *output_file;
    int n, num, num_inc, i;

    input_file = fopen(""input.txt"", ""w+""); // Actually it is the input for the next step.
    if (input_file == NULL) {
        printf(""Error"");
        return 1;
    }
    printf(""How many values you want to write? "");
    scanf(""%i"", &amp;n);
    for (i = 0; i &lt; n; i++) {
        printf(""Write the %i number: "", i + 1);
        scanf(""%i"", &amp;num);
        fprintf(input_file, "" %i "", num);
    }

    rewind(input_file); // Rewind to the beginning to perform reading.

    output_file = fopen(""output.txt"", ""w""); // The name of the output file (must be different from the input one).
    if (output_file == NULL) {
        printf(""Error"");
        return 2;
    }

    printf(""Values read from file:\n"");
    i = 0;
    while (!feof(output_file) &amp;&amp; i &lt; n) {
        fscanf(input_file, ""  %i  "", &amp;num);
        num_inc = num + 1;
        fprintf(output_file, ""  %i  "", num_inc);
        printf(""%i value read is: %i\n"", i+1, num_inc);
        i++;
    }

    fclose(input_file);
    fclose(output_file);
    system(""pause"");
}
</code></pre>
",0
31150396,31149918,0,"<p>proposed amendment</p>

<pre><code>fscanf(fin,""%d %d"",&amp;money,&amp;people);
if(people == 0)//avoid devide by 0
    gmoney = 0;
else
    gmoney=floor(money/people);

...
tmoney[j] -= money;//insert : (final_money_value - initial_money_value) 
tmoney[j]+=money-(gmoney*people);
</code></pre>
",0
29159557,29159548,2,"<p>When we are using the <code>&amp;x</code>, it will refer the address of the x . we need to print the value of x then use this,</p>

<pre><code> printf(""%d"", x);
</code></pre>

<p>In scanf() function, only we need to use <code>&amp;x</code>, to locate the memory address to store the value.</p>
",1
29159588,29159548,2,"<p>You print the address of the x so it will print the address during the compile time it will display the warning 
                                                                                 <code>warning: format ¡®%d¡¯ expects argument of type ¡®int¡¯, but argument 2 has type ¡®int *¡¯ [-Wformat]</code><br>
So use following<br>
<code>printf(""%d"",x);</code></p>
",0
29159591,29159548,3,"<p>The operator '&amp;' represent the address of that variable. we need, the actual value of that variable use like this...</p>

<pre><code>            printf(""%d"",x);
</code></pre>
",0
29159593,29159548,2,"<p>Please print the value of X instead address like printf(""%d"",x);</p>
",0
27130274,27129374,0,"<p>As mentioned in the comments:  </p>

<pre><code>  fprintf(desFile, ""%s"",data2[numOfHeaders]);  //okay            
  printf(desFile, ""%s"",data2[numOfHeaders]);  //wrong  
</code></pre>

<p>Second line should be:  </p>

<pre><code>  printf(""%s"",data2[numOfHeaders]);  //okay
</code></pre>

<p>Or, you could do this:   </p>

<pre><code>  sprintf(buffer, ""%s"",data2[numOfHeaders]);
  fprintf(desFile, buffer);
  printf(buffer);    
</code></pre>

<p><strong><em>Other possible issues</em></strong>:<br>
Without an input file it is not possible to know for certain what <code>strtok()</code> is doing, but here is a guess based on what you have described:  </p>

<p><strong><em>In these two lines</em></strong>:  </p>

<pre><code>  data2[numOfHeaders]= malloc(strlen(line)+1);

  char *s  = strtok(line, ""\n "");          
</code></pre>

<p>if the string contained in data2 has any embedded spaces, <strong><em>s</em></strong> will only contain the segment occurring before that space. And because you are only calling it once before <strong><em>line</em></strong> gets refreshed:  </p>

<pre><code>while (fgets(line, sizeof line, pfile ))  
</code></pre>

<p>only one token (the very first segment) will be read.  </p>

<p>Not always, but <strong><em>Normally</em></strong>, <code>strtok()</code> is called in a loop:  </p>

<pre><code>char *s = {0};
s= strtok(stringToParse, ""\n "");//make initial call before entering loop
while(s)//ALWAYS test to see if s contains new content, else NULL
{
    //do something with s
    strcpy(data2[numOfHeaders],s);
    //get next token from string
    s = strtok(NULL, ""\n "");//continue to tokenize string until s is null
}
</code></pre>

<p>But, as I said above, you are calling it only once on that string before the content of the string is changed.  It is possible then, that the segment not printing has simply not yet been tokenized by <code>strtok()</code>.  </p>
",0
30144008,30143489,0,"<p>The main problem is that the ""updates"" to the stack are not remembered when you descend more than one level in your <code>build_tree()</code> function. When you do for example <code>root-&gt;right = build_tree(S);</code> and you pop the stack in context of that call to <code>build_tree()</code>, the stack hasn't actually been popped in context of the caller.</p>

<p>I would suggest that you alter your functions according to something like this:</p>

<pre><code>void
pop(struct snode **stack) {
  struct snode *S;
  if (*stack == NULL)
    return;

  S = (*stack)-&gt;bottom;
  free(*stack);
  *stack = S;
}


struct tnode*
build_tree(struct snode **S)
{

  struct tnode* root;
  if (*S == NULL)
    return NULL;

  char top = peek(*S);

  if (top == 'A' || top == 'S' || top == 'X' || top == 'D' || top == 'M')
    {
      root = create_node(top);
      pop(S); 
      root-&gt;right = build_tree(S);
      pop(S);
      root-&gt;left = build_tree(S);
      return root;
    } 

  root = create_node(top);

  return root;
}

int
main(int argc, const char *argv[])
{
  ...

  tree =  build_tree(&amp;stack);

  ...
}
</code></pre>

<p>The difference becomes more obvious if you add a <code>printf()</code> call to <code>peek()</code> where you output the datum of the visited stack node.</p>

<p>For your other error, where <code>./project 12 3 D 2 D</code> doesn't work, and <code>12</code> is replaced with <code>1</code>, I would suggest that you use the <code>atoi()</code> function to convert a string to an integer, instead of just <code>value = argv[i][0]</code>. You could test if <code>value</code> is a digit, and if so do <code>value = atoi(argv[i])</code> afterwards.</p>

<p>In addition, as already commented on by <a href=""https://stackoverflow.com/questions/30143489/creating-an-abstract-syntax-tree-from-a-stack#comment48396078_30143489"">Nikolai</a>, you need to define operator precedence rules, and add parentheses as necessary. The simplest approach would be to add a left parenthesis before each time you go left, and add a right parenthesis after each time you return from the right.</p>

<p><strong>Edit</strong></p>

<p>Also note that <code>1 2 X 3 4 X A *</code> isn't valid rpn, whereas <code>1 2 X 3 4 X A</code> is (because the extra <code>*</code> has no matching right operator).</p>

<p><strong>Edit 2</strong></p>

<p>A solution for supporting multi-digit numbers could be to use strings instead of characters to represent all tokens. You would need to change all occurences of <code>char</code> with <code>char *</code> in:</p>

<ul>
<li>The definitions of <code>struct snode</code> and <code>struct tnode</code></li>
<li>The argument to <code>push()</code> and <code>create_node()</code></li>
<li>The return value from <code>peek()</code>.</li>
<li>The variable <code>value</code> in <code>main()</code> and <code>top</code> in <code>build_tree()</code>.</li>
</ul>

<p>In addition, you would need to change <code>value = argv[i][0]</code> to simply <code>value = argv[i]</code> (I would also suggest removing the <code>const</code> qualifier from the <code>argv</code> argument to <code>main()</code>, unless you want to be const-correct). You would also need to change the operator equality check. For example, you could do:</p>

<pre><code>int
is_operator(char *tok)
{
  return !strcmp(tok, ""A"") || !strcmp(tok, ""S"") || !strcmp(tok, ""X"") || !strcmp(tok, ""D"") || !strcmp(tok, ""M"");
}
</code></pre>

<p>and then simply write <code>if (is_operator(top))</code> in <code>build_tree()</code>.</p>

<p>Finally, you would need to change the <code>printf()</code> format string from <code>%c</code> to <code>%s</code>.</p>
",5
31147927,31147850,1,"<p>Read each line one by one with <a href=""http://man7.org/linux/man-pages/man3/getline.3.html"" rel=""nofollow"">getline(3)</a> -if available- or with <a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/fgets.html"" rel=""nofollow"">fgets</a> (you'll then need a large enough line buffer, at least 256 bytes), then parse each line buffer appropriately, using <a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/sscanf.html"" rel=""nofollow"">sscanf</a> (the <code>%n</code> might be useful, and you should test the scanned item count result of <code>sscanf</code>) or other functions (e.g. <a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/strtok.html"" rel=""nofollow"">strtok</a>, <a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/strtol.html"" rel=""nofollow"">strtol</a>, etc...)</p>
",0
31148824,31147850,1,"<p>Remember that 'feof()' is only set AFTER trying to read PAST the end of the file, not when at the end of the file.  </p>

<p>So the final iteration through the loop will try to read/process data that contains trash or prior contents.  </p>

<p>Always check the returned value from 'fscanf()' before trying to use the associated data.   </p>

<p>strongly suggest </p>

<p>eliminate the call to feof() and use the fscanf() to control the loop</p>
",2
29478493,29477986,1,"<p>The solution using <code>scanf_s</code> is tricky:</p>

<pre><code>char playerX;
int playerY;

if (scanf_s(""%c%d"", &amp;playerX, (size_t)1, &amp;playerY) == 2) {
    /* input parsed correctly */
    /* input stopped after the last digit in playerY */
    /* You cannot limit the number of digits this way */
} else {
    /* end of file or missing number */
    /* input stopped before the offending character */
}
</code></pre>

<p><code>scanf_s</code> is a poor fix for <code>scanf</code>'s very many shortcomings.  The array size must be passed after each pointer argument for <code>c</code>, <code>s</code> and <code>[</code> formats.  But this size must be passed as an <code>rsize_t</code>, which is the same as a <code>size_t</code> with a restriction on the maximum value.  Passing <code>1</code> is plain wrong as <code>1</code> is an <code>int</code> and <code>scanf_s</code> takes a variable number of arguments, thus does not convert extra arguments automatically.  If will fail in mysterious ways on architectures where <code>int</code> and <code>size_t</code> differ in size, such as 64 bit windows, linux and OS/X.</p>

<p>You can avoid subtle problems like this by increasing the warning level of the compiler. <code>gcc -Wall -Werror</code> or <code>clang -Wall -Werror</code> are a good start.  Never ignore these helpful warnings, if you don't understand them, you probably do not know what your code really does.</p>

<p>Unless <code>scanf_s</code> is mandated by your coding rules or your compiler, it is simpler to use <code>scanf</code> and just as safe for this format:</p>

<pre><code>if (scanf(""%c%d"", &amp;playerX, &amp;playerY) == 2) ...
</code></pre>
",4
28492734,28468653,0,"<p>You are wrong in using <code>garage[i]-&gt;</code>. You should be using <code>(*garage)[i].</code> instead. With <code>garage[i]</code>, you're not traversing the allocated array, but rather the memory in direct proximity to the <code>garage</code> pointer, and then trying to write it, which most probably causes the segfault.</p>

<p>And now you have changed your code to pass values instead of pointers to <code>fscanf</code>. You should use <code>&amp;(*garage)[i].year</code> and <code>&amp;(*garage)[i].miles</code>.</p>
",11
28493023,28468653,1,"<p><code>fscanf</code> with <code>%d</code> format requires a <em>pointer</em> to <code>int</code> as an argument. You are apparently trying to pass the <code>int</code> itself instead of a pointer</p>

<pre><code>fscanf(file,""%d%s%s%d"", 
  &amp;(*garage)[i].year,
  (*garage)[i].make,
  (*garage)[i].model,
  &amp;(*garage)[i].miles);
</code></pre>

<p>Note the placement of <code>&amp;</code> operators in arguments of <code>fscanf</code>.</p>
",0
28456529,28455955,0,"<p>Unless <code>sizeof(int)==sizeof(int*)</code> on your platform the line:</p>

<pre><code>table = (int **)malloc(sizeof(int)*a);
</code></pre>

<p>Will cause trouble.  Use:</p>

<pre><code>table = malloc(sizeof(*table)*a);
</code></pre>

<p>NB: Old boys get ventilated about casting the return of <code>malloc()</code>. </p>
",0
28456260,28455955,1,"<pre><code>table = (int **)malloc(sizeof(int)*a);
</code></pre>

<p>should be</p>

<pre><code>table = malloc(sizeof(int *)*a);
</code></pre>

<p>and also</p>

<pre><code>test = malloc(sizeof(int *)*m);
result = malloc(sizeof(int *)*m);
</code></pre>

<p><a href=""https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc"">Dont cast <code>malloc()</code></a></p>
",6
29154535,29153359,0,"<p>What your problem is: you're reading a complex data structure that contains pointers directly from a file as binary data.</p>

<p>That approach has several drawbacks:</p>

<ul>
<li><p>If the data structure contains pointers, it will only read the values of the pointers, not the data the pointers point to</p></li>
<li><p>If you write the data on one machine and access it on a different machine, the representations can differ (e.g. due to differences between 32-bit and 64-bit machines)</p></li>
</ul>

<p>Don't do that. You should really read about serialization. I.e. if you want to serialize a char* string, you could first write the length of the string using 4 bytes in network byte order, and then write the individual bytes of the string. When you read the data, you read the string length, allocate memory using malloc() and read the individual bytes.</p>

<p>Unfortunately you will need WAY more lines of code than what your example program shows. E.g. I recently wrote data serialization and unserialization routines for a reasonably simple data structure (albeit more complex than yours) and they are 1000 lines of code.</p>

<p>If you don't understand why the data structure raw read/write doesn't work, you should perhaps be using a different language than C at this point of time. C is for experts.</p>
",0
29457316,29457306,1,"<p>Change </p>

<pre><code>scanf(""%s"",&amp;eingabe);
</code></pre>

<p>to</p>

<pre><code>scanf("" %c"",&amp;eingabe);
</code></pre>

<p>and</p>

<pre><code>printf(""your input was: %s\n"", eingabe);
</code></pre>

<p>to</p>

<pre><code>printf(""your input was: %c\n"", eingabe);
</code></pre>

<p>because <code>%c</code> is the right format specifier for a <code>char</code>. <code>%s</code> is the format specifier for a string. The space before <code>%c</code> in the <code>scanf</code> skips any number of whitespace characters(<code>' '</code>,<code>\n</code> etc) includeing none before scanning a character(<code>%c</code>).</p>
",0
26167042,26166702,0,"<p>It seems like you are looking for a simple dynamic array (<a href=""http://en.wikipedia.org/wiki/Dynamic_array"" rel=""nofollow"">the advanced data type dynamic array</a>, that is). There should be many implementations for this out there. You can simply start with a small dynamic array and push new items to the back just like you would do with a vector in c++ or java. One implementation would be <a href=""https://developer.gnome.org/glib/unstable/glib-Arrays.html"" rel=""nofollow"">GArray</a>. You will only allocate the memory you need.</p>

<p>If you have to/want to do it manually, the usual method is to store the capacity and the size of the array you allocated along with the pointer in a struct and call realloc() from within push_back() whenever you need more space. Usually you should increase the size of your array by a factor of 1.3 to 1.4, but a factor of 2 will do if you're not expecting a HUGE array. If you call remove and your size is below a certain threshold (e.g. capacity/2) you shrink the array again with realloc();</p>
",0
28313622,28313602,0,"<p>You have to store the null value after reading characters into the character array. </p>

<pre><code>char c[100],p[100];
int n;
scanf(""%d"",&amp;n);
for(int i=0; i&lt;n; i++)
    scanf(""%c %c"", &amp;c[i], &amp;p[i]);
c[i] = '\0';
p[i] = '\0';
</code></pre>
",2
28313623,28313602,1,"<pre><code>scanf(""%c %c"", &amp;c[i], &amp;p[i]);
</code></pre>

<p>should be</p>

<pre><code>scanf("" %c %c"", &amp;c[i], &amp;p[i]);
</code></pre>

<p>There is a newline character at the end of input value <code>n</code> so you need to ignore it by placing a space before <code>%c</code></p>

<p>Note the value of n should be <code>n&lt;=100</code> else you have array out of bound access.</p>

<p>Make sure you null terminate the strings once the characters are scanned or have </p>

<pre><code>char c[100] = """";
char p[100] = """";
</code></pre>

<p>In C a valid string should be null terminated.</p>

<p>If you are looking for a VLA(Variable length array) based on the size of <code>n</code> then have your array as</p>

<pre><code>scanf(""%d"",&amp;n);
char c[n];
char p[n];
for(int i=0; i&lt;n-1; i++)
scanf("" %c %c"", &amp;c[i], &amp;p[i]);
</code></pre>
",1
32404308,32404219,5,"<p>You should do neither. Instead I suggest you learn about how command line arguments are passed to the <code>main</code> function through the <code>argc</code> and <code>argv</code> arguments.</p>

<p>I suggest you try this program to help your understanding:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
    printf(""argc = %d\n"", argc);

    for (int a = 0; a &lt; argc; ++a)
        printf(""argv[%d] = \""%s\""\n"", a, argv[a]);
}
</code></pre>

<p>For your example invocation</p>

<pre><code>./a.out foo bar
</code></pre>

<p>the program above will print</p>

<pre><code>argc = 3
argv[0] = ""./a.out""
argv[1] = ""foo""
argv[2] = ""bar""
</code></pre>
",4
32404528,32404219,3,"<p>This solution should work:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(int argc, char *argv[]) {
    if(argc != 3) {
        puts(""Wrong number of arguments"");
        return 0;
    }

    if(strcmp(argv[1], argv[2]))
        puts(""The two strings are different."");
    else
        puts(""The two strings are identical."");
}
</code></pre>
",0
28446727,28446067,0,"<p>OK....</p>

<ol>
<li>Do a search of your computer for the file <code>stdio.h</code>, just to see if it is installed on your system.  The file <code>stdio.h</code>, is one of many include files that are used by the compiler.  Include files contain function declarations as well as definitions of various constants.  It usually gets installed with either a compiler, or a part of a Software Development Kit (SDK).</li>
</ol>

<p>1a.  If you are able to find <code>stdio.h</code>, then you need to configure netbeans, setting the path to where the file is found.  I am unable to give directions on how to do this, as I don't use netbeans.</p>

<p>1b.  If you don't find <code>stdio.h</code>, then you need to install a compiler, actually I recommend using mingw along with msys as an entry point.  You can read about mingw <a href=""http://www.mingw.org/"" rel=""nofollow"">here</a>, and msys <a href=""http://www.mingw.org/wiki/MSYS"" rel=""nofollow"">here</a>.  Once these tools are installed, you really just need a simple text editor to write code, there are numerous ones out there.  </p>
",0
31193627,31193516,3,"<p>You have to ensure <code>\</code> is the last character of your line before the new-line character. This is not the case in your program: there are whitespaces after <code>\</code>.</p>
",0
31193645,31193516,2,"<p>Your macro has spaces after the continuation character <code>\</code>, that's not allowed</p>

<pre><code>#define v(x) do {                                                             \
        if (!is_visited(n-&gt;line) &amp;&amp; ANNOTATE_SOURCE)                          \
        {                                                                     \
          visit(n-&gt;line);                                                     \
          sprintf(buffer, ""#\n# LINE %d: %s#\n"", n-&gt;line, get_line(n-&gt;line)); \
          program = emit(program, buffer);                                    \
        }                                                                     \
    } while (0)
</code></pre>

<p>As you can see above, I also used a <code>do {} while (0)</code> loop that doesn't loop to allow using a <code>;</code> after the macro invocation,</p>

<pre><code>v(a);
</code></pre>

<p>is now valid.</p>
",0
32472711,32472461,1,"<p>A string in C is <em>an array of characters</em>. A pointer is <em>not</em> an array of characters.</p>

<p>Buffer is an array of 3 pointers. You haven't allocated memory to hold the strings anywhere. And the pointers aren't initialized, so they point at garbage locations. </p>

<p>You have to make the pointers point at allocated memory, or alternatively declare an array of arrays (2D array), such as for example <code>char buffer [3][50]</code>, where 3 is the number of strings and 50 is the maximum string length, including null termination.</p>

<p><a href=""http://c-faq.com/aryptr/index.html"" rel=""nofollow"">http://c-faq.com/aryptr/index.html</a></p>
",0
32473013,32472461,0,"<p>In your code <code>buffer</code> has a maximum size of 3 characters, not three strings. You are also doing a lot of things that are unnecessary, like calculating the loop length from the buffer size, casting the would-be buffer strings to <code>const char *</code>, and printing the strings right after getting them.</p>

<p>This code is better...</p>

<pre><code>#include &lt;stdio.h&gt;

int
main (void)
{
    int i;
    int len = 3;
    const char buffer[len][100];

    // Get the strings
    for (i = 0; i &lt; len; i++)
    {
        printf(""Enter word: "");
        scanf(""%s"", buffer[i]);
    }

    // Print the strings
    for (i = 0; i &lt; len; i++)
    {
        printf(""%s\n"", buffer[i]);
    }

    return 0;
}
</code></pre>
",2
29504204,29504169,5,"<p>You get <code>65</code> because you are using <code>%x</code> as the format specifier, change it to <code>%c</code> for the character value.</p>

<p>Note that you don't have enough space for <code>charstring</code> for the null terminator. Fix it.</p>
",1
28514205,28514125,0,"<p>First Don't cast the result of malloc.</p>

<pre><code>w=malloc(sizeof (char));// here you are allocating the one byte. 
</code></pre>

<p>change that into take bytes you have to store.</p>

<pre><code>w=malloc(1024);
</code></pre>

<p>While using the array of pointers, each and every pointer you have to do the memory allocation for each pointer to pointing the different pointers.</p>

<pre><code>while(fscanf(f, ""%s"", w) != EOF &amp;&amp; i &lt; MAX)
{
     printf(""%s "",w);
     word[i]=w; 
     w=malloc(1024); // It is for next index will point to another memory.
     i++;
}
</code></pre>
",0
28527601,28527363,0,"<p>To access the Debian Package Management functionallity there is this library: <a href=""http://dpkg.alioth.debian.org/doc/index.html"" rel=""nofollow"">http://dpkg.alioth.debian.org/doc/index.html</a></p>

<p>However be warned about the following from its <code>README.api</code> file (as per version 1.16.15 of the Debian package <code>libdpkg-dev</code>):</p>

<blockquote>
  <p>What: libdpkg.a (C static library)</p>
  
  <p>Status: volatile</p>
  
  <p>Description:</p>
  
  <p>The API provided by this library is highly volatile, still in the process
   of being cleaned up. It's only supposed to be used internally by dpkg for
   now. Header files, functions, variables and types might get renamed,
   removed or change semantics. If you still have a need to use it, which
   you'd be doing anyway, say by locally building dpkg to get the library,
   then define the C preprocessor macro LIBDPKG_VOLATILE_API in your build
   to acknowledge that fact.</p>
</blockquote>
",1
25481474,25481218,3,"<p>I can see 2 problems.</p>

<p>There is a semicolon on the while that's causing the program to hang.</p>

<p>There is nothing that ensures that the output buffer is flushed before you read the guess.</p>

<p>I have put comments to indicate the code changes.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

#define NO 0
#define YES 1

int main (void)
{
    int guess_value = -1;
    int number;
    int nbr_of_guesses;
    int done = NO;


    printf(""\nGetting a random number\n"");

    /*use the time to seed the random number generator*/

    srand( (unsigned) time(NULL)); 
    number = rand();


    nbr_of_guesses = 0;

    while (done == NO)   // Removed the ;
    {
        printf(""\nPick a number between 0 and %d&gt;"", RAND_MAX);
        fflush(stdout);  // stdout is line buffered, and since there is no \n in the printf we need an explicit call to fflush,
        scanf(""%d"", &amp;guess_value); /*get a number*/

        nbr_of_guesses++;

        if (number == guess_value)
        {
            done = YES;
        }
        else
            if (number &lt; guess_value)
            {
                printf(""\nYou guessed high!"");
            }
            else
            {
                printf(""\nYou guessed low!"");
            }

    }

    printf(""\nCongratulations! you guessed right in %d Guesses!"", nbr_of_guesses);
    printf(""\n\nThe number was %d"", number);

    return 0;
}
</code></pre>
",2
28531069,28530901,0,"<p><code>argc</code> is the number of arguments passed. The first argument for a <code>main()</code> function is the program name itself. So first check <code>argc</code> to see if there was an argument typed, then convert the argument to integer (it is passed as a string) and then make the odd/even test. Note you only need to do the even test, because if it is not even, it must be odd.</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;ctype.h&gt;

int main(int argc, char** argv) {
    if (argc &lt; 2)                         // check number of arguments
        printf(""No argument entered\n"");
    else if (!isdigit(argv[1][0]))        // check first char of user arg
        printf(""Not a number\n"");
    else if (atoi(argv[1]) % 2 == 0)      // convert to int and test
        printf(""Even\n"");
    else 
        printf(""Odd\n"");
    return 0;
}
</code></pre>
",0
25498928,25498764,1,"<p>First of all, this line is a bit strange:</p>

<pre><code>while(key != 27);
</code></pre>

<p>The semicolon means you have a tight loop and you stay there as long as The condition is true. You are lucky here that you key=27 at that point, otherwise your program would hang.</p>

<p>Second, the formatted input</p>

<pre><code>scanf(""%.2f\n"",&amp;payment);
</code></pre>

<p>is most probably not doing what you think it would do. Try</p>

<pre><code>scanf(""%f"",&amp;payment);
</code></pre>

<p>instead.</p>
",2
25498992,25498764,0,"<p>check out dis code instead!</p>

<pre><code>    float payment = 0;
    printf(""Payment = RM "");
    scanf(""%f"",&amp;payment);
    printf(""Payment = RM "");
    printf(""%.2f\n"",payment);
</code></pre>
",1
29203426,29203399,1,"<p>Use of uninitialized variable is cause for undefined behavior. One compiler may initialize the variable to <code>0</code>, but that could easily change if you change compilers or even by changes to compile flags, such as using different optimization levels.</p>

<p>Don't count on it.</p>
",0
29203440,29203399,1,"<p>It is an undefined behavior. You are not initializing the value for x. If you are
not doing that , then it take some garbage value. Garbage value can any value we can't expect that this value will come. So simply initialize the variable you are using.</p>
",0
31894149,31894068,0,"<p>In 2's complement 0xFFFF would be the representation of -1. If you have a variable containing 0xFFFF you would assign it like this:</p>

<pre><code>   int16_t a = -1;
   uint16_t b = a;
   printf(""%x %d %d %x"", a, a, b, b);
</code></pre>

<p>would print both formats for you as follows.</p>

<pre><code>   ffffffff -1 65535 ffff
</code></pre>
",6
31894201,31894068,1,"<p>If I understand you right (and I really don't know if I do) you want something like this</p>

<pre><code>short a = 0xff25;
printf(""hexadecimal %04x equals decimal %hd\n"", a, a);
</code></pre>

<hr>

<p>And like I and others said in comments, the numbers are not <em>stored</em> in hexadecimal, decimal or octal, only in binary bits, ones and zeroes. Hexadecimal, decimal and octal are just for <em>presentation</em>, to make input or output look nicer, and more readable.</p>

<p>When you do e.g.</p>

<pre><code>int a = 0xff25;
</code></pre>

<p>What is actually stored in <code>a</code> is the bits <code>1111111100100101</code>. What those bits actually means, it's up to you when you for example print them.</p>
",2
29953503,29953467,0,"<p>It should be sizeof (double) * 100 + sizeof (char *).</p>

<p>More directly, you could use sizeof on a variable of that type and take the result.</p>

<p>For most current CPUs, this should be 8 * 100 + (4 or 8), depending on whether it is targeted at a 32 or 64 bit architecture:  4 bytes are used for 32-bit pointers, and 8 bytes for 64-bit pointers.</p>

<p>Note that ""a 64-bit compiler"" doesn't say anything about the <em>target</em> architecture.</p>
",4
29953504,29953467,1,"<p>Use the <code>sizeof</code> operator.</p>

<pre><code>printf(""%zd\n"", sizeof(struct my_data));
</code></pre>
",0
29953920,29953467,0,"<p>You have to declare a struct my_data variable and then ask for the sizeof(variable) result. Here's the code:</p>

<pre><code>struct my_data MyData;

printf(""%lu\n"", sizeof(MyData));
</code></pre>
",0
30410293,30409934,1,"<p>You have not used a outer loop with <code>nlines</code>. That's why it is only reading a single maze.</p>

<p>You can do following thing:</p>

<pre><code>for(i = 0; i &lt; nlines; i++){
    // your code.
}
</code></pre>

<p>and if you do not need <code>nlines</code> anywhere else then,</p>

<pre><code>while(nlines--){
    //your code
}
</code></pre>
",6
29160332,29159898,1,"<p>Here's a fixed version that may be of some help to you.  It successfully fills in a Person, prints it, and writes it to the file.  Then it reads the data back from the file into a different Person and prints it.</p>

<p>The structure is similar to what you had, but I made all the reading/writing explicit so you'd see the steps.  In general it isn't a good idea to have functions that perform extra duties you might not always want.  I also made <code>create_person</code> require no input for faster testing.  Your input code looked okay, I just didn't want to type it every time.</p>

<p>One thing to keep in mind, if you plan to write binary data to a file you should open the file in binary mode (""wb"" or ""rb"") to avoid line ending translation on systems that perform that on text files.</p>

<p>You might also consider that a file written on one system may not be readable on a different system if the size of the Person structure changes due to different alignment or <code>int</code> being a different size.  Probably not an issue for you, but if it becomes one you might look into a different serialization scheme.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

#define MAXLEN 100
typedef struct Person
{
    char name[MAXLEN];
    int age;
    char color[MAXLEN];
    char education[MAXLEN];

} Person;

void create_person(Person *who)
{
    strcpy(who-&gt;name, ""Fred Smith"");
    who-&gt;age = 21;
    strcpy(who-&gt;color, ""Red"");
    strcpy(who-&gt;education, ""Some School"");
}

void print_record(Person *who)
{
    printf(""name: %s\n"", who-&gt;name);
    printf(""age: %d\n"", who-&gt;age);
    printf(""color: %s\n"", who-&gt;color);
    printf(""education: %s\n"", who-&gt;education);
}

void load_db(FILE *fp, Person *who)
{
    int result = fread(who, sizeof(*who), 1, fp);
    if(!result)
        printf(""cannot load database"");
}

FILE *connect_db(char *file_name, char *mode, Person *who)
{
    FILE *fp = NULL;
    if(strcmp(mode, ""w"") == 0)
    {
        fp = fopen(file_name, mode);
    }
    else if(strcmp(mode, ""r"") == 0)
    {
        fp = fopen(file_name, mode);
    }
    else
    {
        printf(""incorrect mode"");
    }
    return fp;
}

int save_db(FILE *fp, Person *who)
{
    int result = fwrite(who, sizeof(*who), 1, fp);
    if(result)
    {
        return 0;
    }
    printf(""cannot save db"");
    return -1;
}

int main(int argc, char *argv[])
{
    FILE* fp = NULL;
    Person who1;
    Person who2;
    create_person(&amp;who1);
    print_record(&amp;who1);

    fp = connect_db(""record2.dat"", ""w"", &amp;who1);
    save_db(fp, &amp;who1);
    fclose(fp);

    fp = connect_db(""record2.dat"", ""r"", &amp;who2);
    load_db(fp, &amp;who2);
    print_record(&amp;who1);
    fclose(fp);

    return 0;
}
</code></pre>
",3
29160003,29159898,1,"<p>It's likely to be this:</p>

<pre><code>free(fp);
fclose(fp);
</code></pre>

<p>You are not permitted to free memory that wasn't given to you by <code>malloc</code> (or <code>realloc</code>).</p>

<p>And, yes, you may <em>think</em> you've allocated it inside <code>connect_db</code> but (1) that's totally unnecessary, and (2) you overwrite the pointer when you call <code>fopen</code>.</p>

<p>In addition, <code>save_db</code> is using the size of the <code>who</code> <em>pointer</em> which will most likely not be the same as the type it points to.</p>

<p>So, make the following changes:</p>

<ul>
<li>get rid of the call to <code>malloc</code>, just use <code>FILE *fp;</code> within <code>connect_db</code>.</li>
<li>get rid of the <code>free(fp)</code> within <code>main</code>.</li>
<li>in <code>save_db</code>, use <code>sizeof(Person)</code> rather than <code>sizeof(who)</code>.</li>
</ul>
",3
29160079,29159898,1,"<p>fread() reads individual bytes. You want to read in numbers which you have printf'd. </p>

<p>Your files will look like this:</p>

<pre><code>name: Samuel Thornkey
age: 24
colour: blue
education: PHD in computer science
</code></pre>

<p>But when you use fread, the program directly reads bytes from the file and fills them into the record. Your person will then contain:</p>

<pre><code>char name[MAXLEN]: first MAXLEN characters i.e. ""name: Samuel Thornkey\n  age: 24\ncolour: blue\n"" or something similar
int age: the rest of the characters, encoded as bytes, hence very large number
char color[MAXLEN]: empty
char education[MAXLEN]: empty
</code></pre>

<p>Instead, use fscanf:</p>

<pre><code>fscanf(fp,""name:%s "",&amp;who-&gt;name);
fscanf(fp,""age:%d "",&amp;who-&gt;age);
</code></pre>

<p>and so on.</p>
",1
29170267,29170169,4,"<p>The function <code>strlen</code> returns an object of type <code>size_t</code> (cf. ISO 9899:2011¡ì7.24.6.3). You need to specify that the argument you pass to <code>printf</code> has type <code>size_t</code>, as opposed to <code>int</code>. You can do that by adding a <code>z</code> length modifier (cf. ISO 9899:2011¡ì7.21.6.1/7) specifying an object of type <code>size_t</code>. You should also use the <code>u</code> formatting specifier as <code>size_t</code> is an unsigned type.</p>

<pre><code>printf(""%zu\n"",strlen(line));
</code></pre>
",1
27495268,27495111,1,"<p>If the statement is really that simple (or at least optimal) then use a macro:</p>

<pre><code>#define THIS_IS_NOT_A_FUNCTION(X) if (x == 1){ printf (""\a"");}
</code></pre>

<p>Then the macro is used like this:</p>

<pre><code>// do some tedious task that I can't be bother typing out fully:
THIS_IS_NOT_A_FUNCTION(g_sound);
</code></pre>

<p>As David C. Rankin pointed out in his comment, macros are expanded to their defined value pre-compile time so don't have the overhead of calling a function. The downside is that the code can become unreadable if macros are used too liberally.</p>

<p>If the statement is a complex operation it may pay to write a function and call that.</p>
",0
29147682,29128632,1,"<p>There is nothing wrong in your program. I tested your function and indeed if I add printf(""%d\n"", random); to it and if sum is 5, then the value can be either 1, 2, 3, 4 or 5 but nothing else. I don't understand what your problem is, but it is not in the line of code you highlighted. It generates random numbers between 1 (inclusive) and sum (inclusive). However, you didn't provide the full code so it isn't possible to understand from your limited code what the real purpose of the full comp_output function is.</p>

<p>Do note that using the low-order bits of the rand() implementation may not necessarily be a good idea. rand()%2 on many systems provides an alternating sequence 0, 1, 0, 1, 0, 1, 0, 1, ... The real fix is obviously to use a better random number generator such as the Mersenne Twister (<a href=""http://en.wikipedia.org/wiki/Mersenne_twister"" rel=""nofollow"">http://en.wikipedia.org/wiki/Mersenne_twister</a>) or PCG (<a href=""http://www.pcg-random.org/"" rel=""nofollow"">http://www.pcg-random.org/</a>).</p>
",0
25660673,25660490,4,"<p>The only obvious problem in your program is that you are passing pointer arguments corresponding to <code>printf</code>'s <code>%d</code> format. This is undefined behavior. It can happen to work for some compilation platforms, but you shouldn't count on it.</p>

<p>The most likely explanation is that the ABI for passing pointer arguments to a variadic functions such as <code>printf</code> is, on your platform, different from the ABI for passing <code>int</code> arguments. For all we know, on your platform, pointers are not even the same width as <code>int</code>.</p>

<p>Use the <code>%p</code> format to print a pointer. Or better, use <code>printf(""%p"", (void*)¡­);</code>, which is even more portable, in case not all pointer types have the same representation.</p>
",4
25660695,25660490,2,"<p>The problem is that you are using the wrong format code for printing a pointer. As @PascalCuoq says, you should use <code>%p</code>, not <code>%d</code>.</p>

<p>The reason is that pointers and integers are clearly not the same size, on your system.</p>

<p>When you pass the two pointers to different <code>printf</code> calls <code>%d</code> will print the first part of the pointer value.</p>

<p>When you pass the two pointers to the same <code>printf</code> call, getting the lengths wrong will mean that it will print two different values that do not line up with either pointer.</p>
",0
25661140,25660490,1,"<p>Your <code>printf</code> statements are printing an integer, put you're putting a pointer (<code>&amp;t[i]</code> means address of the <strong>i</strong> th element of the <strong>t</strong> array).</p>

<p>An integer and a pointer are not necessarily the same number of bytes and most implementations of <code>printf</code> takes a fixed number of bytes from the stack for each % field.  Also the 'endianism' of the machine will determine whether the least or most significant bit of the address are used as in integer when <code>printf</code> takes its field data from the stack.  It looks like you are running on a 16 bit machine with 24 bit addresses and LSB ordering - some kind of micro-controller, I'd guess.</p>

<p>Your arrays are at the memory addresses (converted to hex from your output:
<strong>s</strong> : 0xC12198
<strong>t</strong> : 0xC121A0
(24 bit addreses, I think.)</p>

<p>The first loop handles each array seperately in diffierent <code>printf</code> statements, hence you can see the least significant bits of each array incrementing with each iteration.</p>

<p>The second loop tries to handle both arrays in one `printf.  So you get values indicating the incrementing part of one of the addresses, plus the second is the most significant part of the address, which is not incrementing, and the second array's address is not output at all.</p>
",0
29147359,29133043,1,"<p>You need to have the following changes:</p>

<ol>
<li><p>""int data"" into ""char data[255]""</p></li>
<li><p>Change the argument of insert_at_end to ""char *value""</p></li>
<li><p>The following lines instead of the assignment into insert_at_end:</p>

<p>strncpy(var->data, value, sizeof(var->data));</p>

<p>var->data[sizeof(var->data)-1] = '\0';</p></li>
<li><p>Change %d into %s</p></li>
<li><p>Change the code that reads the value from input into the following:</p>

<p>char value[255];</p>

<p>fgets(value, sizeof(value), stdin);</p>

<p>insert_at_end(value);</p></li>
</ol>

<p>This code doesn't strip the newline that fgets will read. It is left as an exercise to the reader how to strip the extra newline. It is also left as an exercise to the reader how to allocate memory dynamically so that variable-length strings can be supported (hint: use malloc and remember to free it!)</p>

<p>However, to understand why these changes need to be made and to understand how arrays, strings and pointers work in C I recommend reading a basic C book. The full explanation doesn't fit into this limited answer. I see from your question that you fail to understand some basic principles of C, and it may be the case C is not necessarily the best language for you to use now.</p>

<p>I also recommend reading some basic secure coding guidelines to understand why the '\0' assignment is done after strncpy as strncpy is an inherently unsafe function.</p>
",0
25663988,25663715,5,"<p>The <code>revrse</code> var isn't initialized so there are rubbish in it. Remember to always init a variable!</p>
",0
25664259,25663715,1,"<p>To get the reversed form of your number properly, you need to first set an initial value for <code>revrse</code> of 0 for each iteration of your loop, otherwise the behavior is undefined.  It also helps to set an initial value for <code>maks</code> to compare against.  Finally, why use a function to check for palindromes when you can just check for equality between your number and its reverse?</p>

<pre><code>int main()
{
    int number;
    int i,j,temp;
    int maks = -1;
    int revrse;

    for(i=999;i&gt;99;i--) {
        for(j=999;j&gt;99;j--) {
            number = i*j;
            revrse = 0;
            temp=number;
            while (temp != 0){
                revrse = revrse * 10;
                revrse = revrse + temp%10;
                temp = temp/10;
            }
            if(number == revrse) {
                if(number &gt; maks) {
                    maks = number;
                }
            }
        }
    }
    printf(""%d"",maks);
    return 0;
}
</code></pre>
",1
25664178,25663715,2,"<p>Complementing the answer from @kleszcz, <code>revrse</code> must always be initialized before the <code>while</code> loop begins, otherwise, it will hold the previous value (and rubbish in the first iteration, as he intelligently pointed out).</p>

<p>Another issue is that you do not need the <code>is_palindrome</code> function. You can check directly if the numbers are equal.</p>
",0
30176416,30176180,0,"<p>Your code is written as if sting type were char * so you should turn</p>

<pre><code>char *string[MAX], *string2[MAX];
</code></pre>

<p>into </p>

<pre><code>char buffer[MAX] ;
char *string = buffer ;
char buffer2[MAX];
char *string2 = buffer2 ;
</code></pre>
",0
30176854,30176180,0,"<p>As @marom has mentioned in his answer, you're treating <code>char[]</code> exactly as <code>char*</code> and it's not correct.</p>

<p>Here you can see your correct version of code. I've tried to describe it in comment.</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

#define MAX 1000

int IsPalindrome(char *);

int main(){
    char string[MAX];
    char *p=string; // points to last valid index
    int i, len;

    gets(string);
    len = strlen(string);

    for(i=0; i&lt;len; i++)
    {
        if( isalnum(string[i])!=0)
        {
            // we keep just alphabet(in uppercase) and digits
            *p = toupper(string[i]);
            p++;
        }
    }
    *p=NULL; // terminate end of string
    //////////////////////////////////////////////////////////////////////////
    if(IsPalindrome(string)==1)
        printf(""YES"");
    else
        printf(""NO"");
    return 0;
}

int IsPalindrome(char *string){
    int len=strlen(string);
    if(len&lt;=1)
        return 1;
    if( string[0] != string[len-1])
        return 0;
    //////////////////////////////////////////////////////////////////////////
    // we need to remove one letter from both side
    string[len-1]='\0'; // remove one letter from end
    //Notice we do above line as It's allowed to change the origin string
    return IsPalindrome(&amp;string[1]) ; // send 2nd letter as start point
}
</code></pre>

<p>Ask any further question in comment section of answers or ""Piazza"" ;)</p>
",0
30170589,30170487,2,"<p>To calculate a power in C, the best way is to use the function <code>pow()</code>. It takes two <code>double</code> arguments: the first is the number that will be raised by the power, and the second argument is the power amount itself.</p>
<p>So:
<code>double z = pow(double x, double y);</code></p>
<p>Then the result will be saved into the double z. You will have to use the <code>math.h</code> library in order to use this function.</p>
",0
30170598,30170487,1,"<pre><code>#include &lt;stdio.h&gt;
int main()
{
  int base, exp;
  long long int value=1;
  printf(""Enter base number and exponent respectively: "");
  scanf(""%d%d"", &amp;base, &amp;exp);
  while (exp!=0)
  {
      value*=base;  /* value = value*base; */
      --exp;
  }
  printf(""Answer = %d"", value);
}
</code></pre>
",0
29203162,29202717,1,"<p>Lines like this one:</p>

<pre><code>place_bet (&amp;places [10], location, amount);
</code></pre>

<p>are passing in the address of the 11th element of <code>places</code>, which is past the end of the array. The <code>place_bet</code> function then uses this address as the starting point of its <code>places</code> parameter, which means it will write even further past the end of the array. Writing past the end of the <code>places</code> array is undefined behavior and may cause the value of other variables to change as their memory is overwritten.</p>

<p>To fix this, change the function calls (not the definitions or declarations) to pass the array, rather than the address of an element past the end of the array:</p>

<pre><code>place_bet (places, location, amount);
</code></pre>
",0
29201247,29201193,2,"<p>You can also use a for loop:</p>

<pre><code>for(input = strtok(input_buffer, ""\n "");input != NULL;input = strtok(NULL, ""\n""))
{
    // Print first.
    printf(""%s"", input);
}
printf(""\n"");
</code></pre>
",0
29201218,29201193,2,"<p>Switch the order of the printf/strtok in the loop, since you already have the first token from outside the loop</p>

<pre><code>input = strtok(input_buffer, ""\n "")
while (input != NULL)
{
    printf(""%s"", input);
    input = strtok(NULL, ""\n"");
}
printf(""\n"");
</code></pre>
",0
29201221,29201193,2,"<p>Adjust the order of things a bit.</p>

<pre><code>input = strtok(input_buffer, ""\n "")
while (input != NULL)
{
    // Print first.
    printf(""%s"", input);
    input = strtok(NULL, ""\n"");
}
printf(""\n"");
</code></pre>
",0
29201395,29201193,1,"<p>You are first assigning values to variable <strong>input</strong> and then printing it.Remember, you are changing the value of <strong>input</strong> inside while loop.Just interchange 4th and 5th line. Try this: </p>

<pre><code>input = strtok(input_buffer, ""\n "")
while (input != NULL)
                {
                    printf(""%s"", input);
                    input = strtok(NULL, ""\n"");
                }
                printf(""\n"");
</code></pre>
",0
29204397,29201193,1,"<p>After separating a string your printing the string, so the previous string will be lose , so print the string before separate on next time.</p>

<pre><code>    input = strtok(input_buffer, ""\n  "");
    while (input != NULL)
   {
   printf(""%s"", input);
   input = strtok(NULL, ""\n"");

  }
   printf(""\n"");
</code></pre>
",0
29216324,29212640,2,"<p>You are suffering from RAM exhaustion/rollover: As you use an array of <em>int</em>, each of them requires 4 bytes. Your memory mapping is handled using <em>size_t</em>-type indexes. If you are compiling in 32-bit mode (which is probably your case), the maximum number it can get at is 2147483648 (2^31). With 4 bytes per int, you can only handle 536870912 elements (2^31 / 4).</p>

<p>As the system requires some RAM for other purposes (e.g. globals), you can only use a bit more than 500K entries.</p>

<p>Solution: Use a 64-bit compiler and you should be fine.</p>

<p>BR</p>
",1
29228474,29212640,1,"<p>Here is another and simpler implementation.</p>

<pre><code>void quickSort(int a[], int begin, int end)
{
    int left = begin - 1, right = end + 1, tmp;
    const int pivot = a[(begin+end)/2];

    if (begin &gt;= end)
        return;

    while(1)    
    {
        do right--; while(a[right] &gt; pivot);
        do left++; while(a[left] &lt; pivot);

        if(left &lt; right)
        {
            tmp = a[left];
            a[left] = a[right];
            a[right] = tmp;
        }
        else 
            break;
    }
    quickSort(a, begin, right);    
    quickSort(a, right+1, end);
}
</code></pre>

<p>You call it like this</p>

<pre><code>int main(void)
{
    int tab[5] = {5, 3, 4, 1, 2};
    int i;

    quickSort(tab, 0, 4); // 4 is index of lest element of tab

    for(i = 0; i &lt; 5; i++)
        printf(""%d "", tab[i]);
    printf(""\n"");

    return 0;
}
</code></pre>
",0
26189100,26189067,4,"<blockquote>
  <p>is it correct to use <code>sizeof(loc_buf[0])</code> instead of <code>sizeof(int)</code>?</p>
</blockquote>

<p>Technically, this is correct, because it's the same thing: <code>sizeof(loc_buf[0])</code>, <code>sizeof(*loc_buf)</code>, and <code>sizeof(int)</code> are all the same. However, since in both cases the size is taken to deal with the same dynamically allocated buffer, this is inconsistent. One should rewrite both <code>sizeof</code>s in the same way of your choice; it does not matter which one you prefer.</p>

<blockquote>
  <p>Will this <code>memset</code> resets all <code>loc_buf</code> to <code>-1</code>?</p>
</blockquote>

<p>Yes, it would. The situation is not entirely straightforward, though: the value that you supply gets converted to <code>unsigned char</code> before being set to the elements of the memory block. In two's complement representation <code>-1</code> consists of all bits set to <code>1</code>. this gets converted to an <code>unsigned char</code> with all ones, which gets set in all bytes in the block. Now the entire block consists of bytes with all their bits set to ones. When these bytes get re-interpreted as <code>int</code>s, they become <code>-1</code>s again.</p>
",0
26189219,26189067,3,"<p>Operator <code>sizeof</code> has two forms: <code>sizeof(type)</code> and <code>sizeof expression</code>. In your case you can use <code>sizeof(int)</code> or <code>sizeof loc_buff[0]</code> or <code>sizeof *loc_buff</code> with identical results. Note that the <code>()</code> are completely optional when the argument of <code>sizeof</code> is an expression (not a type). <code>sizeof</code> operator has high priority, which makes those <code>()</code> redundant in most cases (including your example).</p>

<p>As for <code>memset</code>... formally it is not guaranteed to set <code>loc_buff</code> elements to <code>-1</code> in general case. This <code>memset</code> is guaranteed to fill the memory with <code>0xFF...F</code> bit pattern, but what that bit pattern means when interpreted as an <code>int</code> object is implementation-dependent. On a 2's-complement machine this is indeed <code>-1</code>, but on non-2's-complement machine it is something completely different.</p>

<p>From the very pedantic point of view, the only portable use <code>memset</code> has with non-char integer arrays is setting everything to <code>0</code>.</p>
",3
29211860,29207753,0,"<p>I'd say the problem is that in your .c file you declare the function as extern void, I think it should be just void</p>
",0
29475792,29475398,1,"<p>Your first code is bad, it accesses the array out of it's boundaries. Your second code is better although it flips the image then it reflips it back. </p>

<p>And just to straight things out, number of rows is picture height, number of columns is picture width, the first index in the 2-d arrays is row selection (height index), and the second index is colum selection (width index). Horizontal flip exchanges pixels from left to right.
Vertical flip exchanges pixel from top to bottom.</p>

<p>Having that, This should be a horizontal flip</p>

<pre><code>int row, col;
for(row = 0; row &lt; myPic-&gt;rows; row++) {
    for(col = 0; col &lt; myPic-&gt;cols / 2 ; col++) { /*notice the division with 2*/
        Pixel temp = myPic-&gt;pixels[row][col];
        myPic-&gt;pixels[row][col] = myPic-&gt;pixels[row][myPic-&gt;cols - col -1];
        myPic-&gt;pixels[row][myPic-&gt;cols - col -1] = temp;
    }
}
return myPic;
</code></pre>

<p>After you modify the image in memory, you need to save it, or redraw the modified image with the graphic library you are using.</p>
",2
29907251,29907217,0,"<p>It just print these value to stdout, in float number format with specified format.
More details can be found at <a href=""http://www.codingunit.com/printf-format-specifiers-format-conversions-and-formatted-output"" rel=""nofollow""><code>printf()</code></a>.</p>
",0
29907252,29907217,1,"<p>The <a href=""http://www.cplusplus.com/reference/cstdio/printf/"" rel=""nofollow""><code>printf()</code></a> function prints to stdout, which is usually the console, and uses a particular variable-replacement syntax in strings - what you're looking at is thus a format string. Breaking it down:</p>

<ul>
<li><code>\n</code> : newline</li>
<li><code>%12.6f</code> : next variable,
<ul>
<li>width 12 -- Padded with spaces to make the string exactly 12 characters if it's not already</li>
<li>precision 6 -- Six digits after the decimal point</li>
<li>in decimal floating point format</li>
</ul></li>
<li>+2 more iterations of this</li>
</ul>

<p>The array lookup syntax is the same as in Java, so it's looking up the second (because zero-based indexing) element in R and LS.</p>
",2
29907396,29907217,0,"<p>Here is a tiny test program, and its output:</p>

<pre><code>#include &lt;stdio.h&gt;
int main(int argc, char **argv) {
    float R[2] = {1./7. * 10000, 2./7. * 10000};
    float LS[2] = {3./7. *10000, 4/7. * 10000};
    float LAMBDA = 5/7. *10000;
    printf(""BEFORE"");
    printf(""\n%12.6f%12.6f%12.6f"", R[1], LS[1], LAMBDA);
    printf(""AFTER\n"");
}
</code></pre>

<p>BEFORE
 2857.142822 5714.285645 7142.856934AFTER</p>

<p>So, a newline, then all on one line, with each number taking up 12 spaces, R[1], LS[1], and LAMBDA, printed to 6 digits of accuracy. Then, no newline, so they must want something else to happen on the line line after.</p>
",0
31844707,31844658,1,"<p>If the following if statement condition is false:</p>

<pre><code>if(current-&gt;name.next) {
</code></pre>

<p>Then how will your while loop ever terminate?  That's your problem.</p>

<p>See this on <a href=""http://ericlippert.com/2014/03/05/how-to-debug-small-programs/"" rel=""nofollow"">debugging small programs</a>.</p>
",1
31844751,31844658,1,"<p>If you add a <code>fflush(stdout);</code> after <code>printf(""chiis added"");</code> you'll see that printf is indeed executed and your program gets stuck somewhere else (see @i_am_jorf's answer).</p>

<p>Whatever you pass to printf() is buffered by the standard library to improve the performance of writing to the terminal. You can manually flush the buffer with fflush().</p>
",2
31903739,31903701,2,"<p>You aren't adding the string terminator character to the end of your string.  </p>

<pre><code>int main(){
    /*main method*/
    char original[10];
    int c;
    int i;

    for(i=0;i &lt; 9 &amp;&amp; (c=getchar())!=EOF;i++){           
        original[i]=c;
    }
    original[i] = '\0';
    printf(""%d\n"", totalElements(original));

    return 0;

}

int totalElements(char a[]){
    char c;
    int i=0;

    while((c=a[i])!='\0'){
        i++;
    }
    return i;
}
</code></pre>

<p>And also your printf is incorrect.</p>
",3
31903751,31903701,1,"<p>A Windows error dialog such as ""Windows is trying to find a solution"" after stopping a program indicates that there is a defect in the application being run that has caused it to abnormally terminate.</p>

<p>If you are getting this many times it is because the program(s) you are writing or using have defects in them which are causing errors when run.</p>

<p>This error message is to inform the user of the application that the application has abnormally terminated and that Windows is checking the Microsoft abnormal termination database to see if this problem has been documented. Since these are applications you are writing yourself rather than a Microsoft or other vendor's application, the chances of Windows finding a solution is fairly slim.</p>

<p>This article, <a href=""http://www.techspot.com/community/topics/disable-windows-is-checking-for-a-solution-to-the-problem-prompt-after-a-program-hangs-up.193376/"" rel=""nofollow"">Disable ""Windows is checking for a solution to the problem..."" prompt after a program hangs up</a> provides a procedure for disabling this message. The basic procedure is to go to the ""Change Action Center settings"" and change the setting for ""Problem reporting settings"".</p>
",0
29184384,29184343,7,"<p>A string literal such as <code>""string""</code> is a <code>char[7]</code> stored in a read-only memory location. Array names can decay to pointers to their first element, so it is possible to initialize a <code>char*</code> to such a literal expression.</p>

<p>An integer literal such as <code>3</code> is just an int rvalue which is not stored anywhere. The initialization <code>int* i = 3</code> initializes <code>i</code> to point to a memory location with value <code>3</code>. This is unlikely to be a valid location, which is why de-referencing <code>i</code> gives you a segmentation violation.</p>
",2
29184395,29184343,3,"<p>In case of string literals, compiler allocate space for it in memory. <code>str</code> will be initializes with the starting address of the allocated chunk.<br>
In case of <code>int *i=3;</code>, compiler initializes <code>i</code> with the address value <code>3</code>. Generally lower addresses are reserved for operating systems and programs will most likely crash on accessing these location</p>
",0
32417281,32417194,4,"<p>The lenght of a string can never be negative, whilst an integer <em>could</em> be - the warning is because the range of values for <code>size_t</code> is different to <code>int</code>, and some positive values of <code>size_t</code> would be treated as negative if cast to an <code>int</code>. The better option is to have the return type to your function match, in this case, have <code>foo</code> return a <code>size_t</code> - you'll soon see that the datatype would permiate most of the code, and leave some other oddities that <em>could</em> do odd things (<code>size_t - size_t</code> could underflow...)</p>
",20
32417305,32417194,-3,"<p>i think there must be varying from compiler to compiler.....because i tried it on a online compiler and it didn't show any warning.<a href=""https://i.stack.imgur.com/IDUwq.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/IDUwq.png"" alt=""enter image description here""></a> </p>
",4
32417625,32417194,1,"<p>There are 2 issues:</p>

<ol>
<li><p><code>strlen()</code> returns type <code>size_t</code>.  <code>size_t</code> is some unsigned integer type likely as wide or wider than <code>int</code>.  It is compiler/platform dependent.</p></li>
<li><p>Code needs to compare and <code>int</code> to <code>size_t</code>.  Since <code>size_t</code> is unsigned, and to prevent a warning of mixed signed/unsigned comparrison, explicitly change <code>int</code> to an unsigned integer.  To change an non-negative <code>int</code> to an unsigned integer, cast to <code>(unsigned)</code>.</p></li>
</ol>

<p>To compare, test if <code>c</code> is negative and if not, then compare <code>(unsigned)c</code> directly to <code>len</code>.  Compiler will covert types as needed and result in an arithmetically correct answer.</p>

<p>..</p>

<pre><code>size_t len = strlen(""SomeString"");
int c = 20;  // some int

if (c &lt; 0 || (unsigned)c &lt; len) puts(""c less than len"");
else puts(""c &gt;= len"");
</code></pre>
",14
32417642,32417194,2,"<p>This will compile without warnings:</p>

<pre><code> #include&lt;stdio.h&gt;
 #include&lt;string.h&gt;

 size_t foo(char *s){
    size_t len = strlen(s);
    /* code here */
    return len;
 }

int main(void){
    char *name = ""Michi"";
    size_t len = foo(name);
    size_t a = 20, b = 10, c = a - b;

    if(c &lt; len){
        printf(""True:  C(%zu) &lt; Len(%zu)\n"",c,len);
    } else {
        printf(""False:  C(%zu) &gt; Len(%zu)\n"",c,len);
    }

    return 0;
}
</code></pre>

<p>as well explained in the answers and comments by @thomasdickey, @rolandshaw, @andreaghidini, @olaf, @juanchopanza and others.</p>

<p>Did you really made a better approach? No: why should a stringlen function return values that can be negative? There is no such thing as a string with negative size. </p>

<p>The standard strlen function is already there, is more efficient, is able to deal with strings with a maximum size which is twice the maximum size handled by stringLEN, and has a more precise definition of the return type.</p>
",9
32417877,32417194,6,"<p>Digging through all the other answers, your <em>true</em> question seems to be how to deal with a situation like this:</p>

<pre><code>#include &lt;string.h&gt;
#include &lt;libfoo.h&gt;

extern void foo(void);
extern void bar(void);

void pick_foo_or_bar(const char *s)
{
   size_t slen = strlen(s);
   int   value = libfoo_api_returning_an_int();

   if (slen &gt; value) // -Wconversion warning on this line
      foo();
   else
      bar();
}
</code></pre>

<p>... where you <em>can't</em> change the type of either <code>slen</code> or <code>value</code>, because both are correct for the API they're receiving the result of.</p>

<p>The <code>-Wconversion</code> warning is trying to tell you something meaningful.  Comparison of signed and unsigned integer types in C does something very strange, <em>not</em> what you would expect from the laws of arithmetic in <a href=""https://en.wikipedia.org/wiki/Integer"" rel=""nofollow"">?</a>; a naive comparison like what I wrote above can and has caused catastrophic bugs.  But the cure is not casts or inventing your own <code>strlen</code>; the cure is to <em>fix the comparison</em> so it does what you expect from the laws of arithmetic.  The principles for this are:</p>

<ul>
<li>First check whether the signed quantity is negative.  If so, treat it as smaller than the unsigned quantity.</li>
<li>Otherwise, cast the <em>smaller</em> type to the <em>larger</em> type before comparing them.</li>
</ul>

<p>In this case, <code>size_t</code> is almost certain to be larger than, or the same size as, <code>int</code>, so you would write</p>

<pre><code>#include &lt;assert.h&gt;
#include &lt;limits.h&gt;
#include &lt;string.h&gt;
#include &lt;libfoo.h&gt;

extern void foo(void);
extern void bar(void);

// Code below is correct only if size_t is at least as large as int.
static_assert(SIZE_MAX &gt;= INT_MAX);

void pick_foo_or_bar(const char *s)
{
   size_t slen = strlen(s);
   int   value = libfoo_api_returning_an_int();

   if (value &lt; 0 || (size_t)value &lt; slen)
      foo();
   else
      bar();
}
</code></pre>

<p>The <code>static_assert</code> is present because, if I remember correctly, the C standard does <em>not</em> guarantee <code>size_t</code> being at least as large as <code>unsigned int</code>.  I could, for instance, imagine an ABI for the 80286 where <code>int</code> was four bytes wide but <code>size_t</code> only two.  In that situation you would need to do the casting the other way around:</p>

<pre><code>void pick_foo_or_bar(unsigned short a, long b)
{
    if (b &lt; 0 || b &lt; (long)a)
        foo();
    else
        bar();
}
</code></pre>

<p>If you don't know which of the two types is bigger, or if you don't know which of them is signed, your only recourse in standard C is <code>(u)intmax_t</code>:</p>

<pre><code>void pick_foo_or_bar(uid_t a, gid_t b)
{
    if (a &lt; 0 &amp;&amp; b &lt; 0) {
        if ((intmax_t)a &lt; (intmax_t)b)
            bar();
        else
            foo();
    } else if (a &lt; 0) {
       bar();
    } else if (b &lt; 0) {
        foo();
    } else {
        if ((uintmax_t)a &lt; (uintmax_t)b)
            bar();
        else
            foo();
    }
 }
</code></pre>

<p>... and, given the exceedingly unfortunate precedent set by C99 wrt <code>long</code>, there probably <em>will</em> come a day when <code>(u)intmax_t</code> is <em>not</em> the biggest integer type supported by the compiler, and then you're just hosed.</p>
",6
32417238,32417194,0,"<p>The normal way to solve this is to use variables typed <code>size_t</code>, and choose an appropriate format for printing them.  Then no cast is needed.  For printf, see these:</p>

<ul>
<li><a href=""https://stackoverflow.com/questions/3168275/printf-format-specifiers-for-uint32-t-and-size-t"">printf format specifiers for uint32_t and size_t</a></li>
<li><a href=""https://stackoverflow.com/questions/940087/whats-the-correct-way-to-use-printf-to-print-a-size-t"">What's the correct way to use printf to print a size_t?</a></li>
</ul>
",6
31244640,31244540,12,"<p>No! <code>static</code> globals have file scope (internal linkage), so you can't use them as they have external linkage... This does not means that you cannot have a variable of the same name with external linkage but it cannot be that one that is <code>static</code>.</p>

<p>Correct for <code>i</code>.</p>

<p>Incorrect for <code>j</code>, at least it cannot be the one defined in <code>file1.c</code>.</p>

<p>Incorrect for <code>foo</code>, at least for the local variable used in <code>file2.c</code> which does not have external linkage (no linkage at all). A local variable only exists when the block where it is declared is activated, so having access to it outside is a non-sense.</p>
",0
31244926,31244540,0,"<p><strong>extern int j;</strong>    is not a valid -> static variables are with in the file scope </p>

<p><strong>extern int foo;</strong>  is not valid -> foo is a local variable whose scope is with in the 'for' loop </p>
",0
29478980,29465665,0,"<p>I suppose the main problem in your solution of Number Grid problem is nested <code>for</code> loops. The simplest optimization is to minimaze number of recalculations for each move of the scope.</p>

<p>I tryed the following changes in the original code:</p>

<pre class=""lang-cpp prettyprint-override""><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;

int main() {

    int N, M, Y, X;
    scanf(""%d %d %d %d"", &amp;N, &amp;M, &amp;Y, &amp;X);

    int max = 0;
    int total = 0;

    int data[N][M];

    for(int i = 0; i &lt; N; i++)
        for(int j = 0; j &lt; M; j++)
            scanf(""%d"",&amp;(data[i][j]));  
     ////////////////////////////////////////////////////////////
    // calculation of the first total and initial max
    int startTotal = 0;
    int r, c;
    for(r = 0; r &lt; Y-1; r++)
    {
        for(c = 0; c &lt; X-1; c++)
        {
            startTotal += data[r][c];
        }
    }
    max = startTotal;

    for(int i = 0; i+Y &lt;= N; i++)
    {
        // add next line
        for(int c = 0; c &lt; X-1; c++)
        {
            startTotal += data[i+Y-1][c];
        }
        total = startTotal;
        for(int j = 0; j+X &lt;= M; j++)
        {
            // add next column
            for(int r = i; r &lt; i+Y; r++)
                total += data[r][j+X-1];
            // compare
            if(total &gt; max)
            {
                max = total;
            }
            // subtract the first column
            for(int r = i; r &lt; i+Y; r++)
                total -= data[r][j];
        }
        // subtract the first line
        for(int c = 0; c &lt; X-1; c++)
        {
            startTotal -= data[i][c];
        }
    }
    ////////////////////////////////////////////////////////
    printf(""%d"",max);
    return 0;
}
</code></pre>

<p>I have tryed to run the program at hackerrank.com, and received</p>

<p><img src=""https://i.stack.imgur.com/JraKq.jpg"" alt=""enter image description here""></p>
",0
32421042,32420518,1,"<p>Go with <a href=""https://stackoverflow.com/a/32420863/2410359"">@BLUEPIXY</a> for brevity.</p>

<p>A deeper answer.</p>

<p>C allows various ""locales"" such that, in theory, <code>snprintf(..., ""%lu"",...)</code> could print a longer string than expected.  Instead of ""1234567"", the output could be ""1,234,567"".</p>

<p>Recommend:<br>
1. Determine the size in bits, <code>n</code>, of the maximum integer.<br>
2. <code>n * log2(10)</code> rounded-up + 1 to get then <code>char</code> count.<br>
3. Set-up a buffer that is 2x max need.<br>
4. Check snprintf result.<br>
5. Niche concern: Using the double call with <code>snprintf()</code> needs to insure the ""locale"" and number do not change between calls - not use here as <code>snprintf()</code> is a functionally expensive call.</p>

<pre><code>char *ulong_to_buf(char *buf, size_t size, unsigned long x) {
    int n = snprintf(buf, size, ""%lu"", x);
    if (n &lt; 0 || n &gt;= size) return NULL;
    return buf;
}

// Usage example
void foo(unsigned long x)
  // 1/3 --&gt; ~log2(10)
  #define ULONG_PRT_LEN (sizeof(unsigned long)*CHAR_BIT/3 + 2)
  char buf[ULONG_PRT_LEN*2 + 1];  // 2x for unexpected locales
  if (ulong_to_buf(, sizeof buf, x)) {
    puts(buf);
  }
</code></pre>

<hr>

<p>If code is <em>really</em> concerned, simple write your own </p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;limits.h&gt;
#include &lt;string.h&gt;
#define PRT_ULONG_SIZE (sizeof(unsigned long) * CHAR_BIT * 10 / 33 + 3)

char *ulong_strnull(int x, char *dest, size_t dest_size) {
  char buf[PRT_ULONG_SIZE];
  char *p = &amp;buf[sizeof buf - 1];
  // Form string
  *p = '\0';
  do {
    *--p = x % 10 + '0';
    x /= 10;
  } while (x);
  size_t src_size = &amp;buf[sizeof buf] - p;
  if (src_size &gt; dest_size) {
    // Not enough room
    return NULL;
  }
  return memcpy(dest, p, src_size); // Copy string
}
</code></pre>
",0
32420854,32420518,1,"<p>From the documetation for <code>snprintf</code>:</p>

<blockquote>
  <p>Concerning  the  return  value  of snprintf(), SUSv2 and C99
  contradict
         each other: when snprintf() is called with size=0 then SUSv2 stipulates
         an  unspecified  return  value  less than 1, while C99 allows str to be
         NULL in this case, and gives the return value (as always) as the number
         of  characters  that  would have been written in case the output string
         has been large enough.</p>
</blockquote>

<p>If you are using C99 you can determine the size using snprintf (as BLUEPIXY commented):</p>

<pre><code>int size = snprintf(NULL, 0, ""%lu"", ULONG_MAX);
</code></pre>

<p>However if you can't use C99 then you can determine the string size by determining how many digits you require and adding an additional character for the terminating <code>\0</code> character:</p>

<pre><code>int size = (int) log10((double) ULONG_MAX) + 1;
</code></pre>

<p>In order to allocate your array with <code>size</code> bytes you can simply use</p>

<pre><code>char str[size];
</code></pre>

<p>However this only works if your compiler/version supports <a href=""https://stackoverflow.com/a/20011090/2372604"">VLAs</a>, if you compiler doesn't support this you can dynamically allocate the array with</p>

<pre><code>char *str = malloc(size);    //&lt; Allocate the memory dynamically
// TODO: Use the str as you would the character array
free(str);                   //&lt; Free the array when you are finished
</code></pre>
",0
32420863,32420518,1,"<pre><code>#if ULONG_MAX == 4294967295UL
#  define SIZE (10 + 1)
#elif ULONG_MAX &lt;= 18446744073709551615ULL
#  define SIZE (20 + 1)
#endif
</code></pre>
",3
28153541,28153377,3,"<p>What you appear to be doing is:</p>

<ol>
<li><p>Running some external command to write to a file</p></li>
<li><p>Polling to see whether you can open the file (that's in <code>waitAndExecuteScript</code>)</p></li>
<li><p>Immediately afterwards, reading the file (that's in <code>java</code>).</p></li>
</ol>

<p>This strategy will not work. Unless you know that the external command creates the file atomically (e.g. by writing it to a different file then renaming it), the file will exist and become readable before it is fully written. Consider the following ordering:</p>

<ol>
<li><p>External process opens the file for writing, but writes nothing yet</p></li>
<li><p><code>waitAndExecuteScript</code> successfully opens the empty file</p></li>
<li><p><code>java</code> reads the empty file</p></li>
<li><p>External process writes data.</p></li>
</ol>

<p>As you can see, the data may be partially written.</p>

<p>What you should do is check that the process that is doing the writing has completed. Alternatively, make it write to a pipe and use blocking reads.</p>
",3
28153710,28153377,1,"<p>Your memory management is also flawed:</p>

<pre><code>resultval = buffer;    
...
if(buffer != NULL)
{
    free (buffer);
}
...
return resultval;  //Return the result value of the script
</code></pre>

<p><code>resultval = buffer</code> makes a pointer variable <code>resultval</code> points to the same location as <code>buffer</code> points.  But then you <code>free()</code>-ed the memory chunk which is located there.  So <code>resultval</code> points to an invalid memory location when you return it from your <code>java()</code> function.</p>

<p>If your platform is Linux, I'd recommend you to install and use the Valgrind memory debugger to easily spot bugs like this.</p>

<ul>
<li><a href=""http://valgrind.org/docs/manual/quick-start.html"" rel=""nofollow"">http://valgrind.org/docs/manual/quick-start.html</a></li>
</ul>
",5
26250341,26250224,0,"<p>First you need to show how the structure look like.
In the first look I could see that <code>strcpy</code> is the one which is causing the segmentation fault. I see you are not allocating any memory using new/malloc to the pointer inside the strcuture for each menu item. </p>
",0
26250562,26250224,2,"<p>Remember that ""declaration mimicks use"", so in your initialisation function, where you pass a pointer to an array of menu item structs:</p>

<pre><code>struct menu_item (*menu_items)[]
</code></pre>

<p>you should access them in the same fashion:</p>

<pre><code>(*menu_items)[i].func = menuTable[i].func;
</code></pre>

<p>as WhozCraig has pointed out. (Declaring the dimension in the argument actually hides a useful warning here: <code>(*menu_items[1])</code> points after the whole chunk of items, which is into undefined territory.)</p>

<p>But I think your approach to the problem is too complicated in the first place. You don't need to pass a pointer to the array; it is sufficient to pass the array:</p>

<pre><code>void menu_init(struct menu_item menu_items[])
{
    int i;

    static struct menu_item menuTable[] = {
        // ... snip ...
    };

    for (i = 0; i &lt; NUM_MENU_ITEMS; i++) {
        strcpy(menu_items[i].name, menuTable[i].name);
        menu_items[i].func = menuTable[i].func;
    }
}

void initialize(struct menu_item menu_items[])
{
    menu_init(menu_items);
}

int main()
{
    struct menu_item menu_items[NUM_MENU_ITEMS];

    initialize(menu_items);

    // .. snip ...
}
</code></pre>

<p>You'd only need to pass the pointer, if the array base itself could change, but you don't want that.</p>

<p>(And maybe even that is too complicated. Why not just declare the menu items in file scope and work on them directly?)</p>
",0
32396599,32396522,6,"<p>The right way to do it is to declare an integer array and not 10 different variables:</p>

<pre><code>int n[10];
</code></pre>

<p>Now you can access 10 int variables with <code>n[0]</code> through <code>n[9]</code>.</p>
",7
32396716,32396522,-2,"<pre><code>int n[10] = {0};
/*or you can initilize like this also , this will make all the elements 0 in array*/

for(i = 0; i &lt; 10; i++){
    if(digit == 1){
        n[i] = n[i] + 1;
    }               
}
</code></pre>

<p>Try this and let me know</p>
",2
32396727,32396522,8,"<p>Simple answer: declare an array instead, as <code>int n[10]</code>. </p>

<hr>

<p>Advanced answer: it doesn't seem to be the case here, but in the case where you do need to use individual variable names of array items, for whatever reason, you can use an union:</p>

<pre><code>typedef union
{
  struct
  {
    int n0;
    int n1;
    int n2;
    ... // and so on
    int n9;
  };

  int array[10];

} my_array_t;
</code></pre>

<p>In case you have an old dinosaur compiler, then declare the struct with a variable name such as <code>struct { ... } s;</code></p>

<hr>

<p>How to use the above type in a practical, real world program:</p>

<pre><code>  my_array_t arr = {0};

  for(int i=0; i&lt;10; i++)
  {
    arr.array[i] = i + 1;
  }

  // access array items by name:    
  printf(""n0 %d\n"", arr.n0); // prints n0 1
  printf(""n1 %d\n"", arr.n1); // prints n1 2
</code></pre>

<hr>

<p>Or you could initialize members by name:</p>

<pre><code>  my_array_t arr = 
  { 
    .n0 = 1, 
    .n1 = 2,
    ...
  };
</code></pre>

<hr>

<p>Silly, artificial example of how to use the above type to assign values to the variables without using array notation:</p>

<pre><code>  my_array_t arr = {0};

  // BAD CODE, do not do things like this in the real world:

  // we can't use int* because that would violate the aliasing rule, therefore:
  char* dodge_strict_aliasing = (void*)&amp;arr;

  // ensure no struct padding:
  static_assert(sizeof(my_array_t) == sizeof(int[10]), ""bleh"");

  for(int i=0; i&lt;10; i++)
  {
    *((int*)dodge_strict_aliasing) = i + 1;
    dodge_strict_aliasing += sizeof(int);
  }

  printf(""n0 %d\n"", arr.n0); // prints n0 1
  printf(""n1 %d\n"", arr.n1); // prints n1 2

  for(int i=0; i&lt;10; i++)
  {
    printf(""%d "",arr.array[i]); // prints 1 2 3 4 5 6 7 8 9 10
  }
</code></pre>
",1
32396732,32396522,0,"<p>It is barely <strong>not possible</strong> to access your variables just like you want to, without any array.</p>

<p>All that comes to my mind, is to consider 10 separate cases for each variable, so:</p>

<pre><code>int i;
int n0, n2, n3 ... n9;

for(i=0; i&lt;10; i++)
{
  switch(i)
  {
    case 0: n0++; break;
    case 1: ...
  }
}
</code></pre>
",0
32397715,32396522,0,"<p>Since you can't use ""real"" arrays, lets use some dynamic memory instead (really silly but ...):</p>

<pre><code>#define NUMVALS 10
int main(int argc, char *argv[])
{
    int *values, *ptr, i;
    ptr = values = malloc(sizeof(int) * NUMVALS);

    for (i = 0; i &lt; NUMVALS; i++) {
        ptr++ = 0; /* Set the values here or do what you want */
                   /* Ofc values[i] would work but looks like array access... */
    }
    ...
}
</code></pre>

<p>If you really have several variables that you want to access like you say, well save the pointers to them in an array (or like above) and access them that way, but it's still not by name. If you <strong>must</strong> access them by name well I think you're left with the pre-processor. I don't know of any other proper way to do it.</p>
",0
28187881,28187837,6,"<p>The problem is that the <code>struct numbers</code> <em>declaration</em> is global, but the <em>definition</em> is local in <code>main</code>, To use the members of a structure, the <code>swap</code> function must know what members the structure have, and as it can't see the definition it doesn't know that. Remove the declaration and put the definition in the global scope.</p>
",0
28187882,28187837,8,"<p>You're expecting the code in <code>swap()</code> to be able to access the fields of <code>struct numbers</code>, but the full declaration of that type is <em>inside</em> <code>main()</code>, so it's not visible.</p>

<p>Break out the declaration, it must be visible to all who need it. Putting it first will also remove the need to pre-declare the structure.</p>

<p>The same with <code>swap()</code> itself, putting it before <code>main()</code> will remove the need to have a prototype for it in the same file.</p>

<p>It should be:</p>

<pre><code>struct numbers
{
 .
 .
 .
}

static void swap(struct numbers *s)
{
 .
 .
 .
}

int main(void)
{
 .
 .
 .
}
</code></pre>
",4
28187979,28187837,4,"<p>Function <code>swap</code> can't see the definition of <code>struct numbers</code>. Put it globally outside <code>main</code>.</p>

<p>Extra Tip - Use <code>typedef</code> with structs, it gives you flexibility in declaration:</p>

<pre><code>typedef struct typeNumbers
{
    int a;
    int b;
    int c;
} numbers;
</code></pre>

<p>Note that typeNumbers is optional. Declare it like:</p>

<pre><code>numbers x = {1, 2, 3};
</code></pre>
",0
28188137,28187837,1,"<p>The problem was that the structure was in main, I did some fixes also to the code and comment them.</p>

<pre><code>#include &lt;stdio.h&gt;

//By defining the struct at the beginning you can avoid the forward declaration 
//and it make more sense to know what ""numbers"" is before continuing reading the code.
struct numbers {
    int a;
    int b;
    int c;
};

void swap(struct numbers* s)
{
    //Small change to use only one temp variable...
    int temp2 = s -&gt; b;
    s -&gt; b = s -&gt; a;
    s -&gt; a = s -&gt; c;
    s -&gt; c = temp2;
}

int main(void)
{
    struct numbers x = {1, 5 , 9};
    swap(&amp;x);
    printf(""%i, %i, %i\n"", x.a, x.b, x.c);
    return 0;
}
</code></pre>
",0
31244735,31244556,0,"<p>If you open in write mode (""w"" or ""w+""), the last text is saved in file, but if you will open in append mode (""a"" or ""a+""), your file will include all of your writing.</p>
",0
31244637,31244556,3,"<p>You are using write mode to write output to an already existing file. To preserve it's contents, use append modes like <code>a</code> or <code>a+</code>. For example</p>

<pre><code>FILE * ptrFILE = fopen(""Phone Book.txt"", ""a"");
</code></pre>

<p>The <a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/fopen.html"" rel=""nofollow"">description</a> of other modes (may not be compatible with all platforms):</p>

<ol>
<li><code>r</code> or <code>rb</code> - Open file for reading.</li>
<li><code>w</code> or <code>wb</code> - Truncate to zero length or create file for writing.</li>
<li><code>a</code> or <code>ab</code> - Append; open or create file for writing at end-of-file.</li>
<li><code>r+</code> or <code>rb+</code> or <code>r+b</code> - Open file for update (reading and writing).</li>
<li><code>w+</code> or <code>wb+</code> or <code>w+b</code> - Truncate to zero length or create file for update.</li>
<li><code>a+</code> or <code>ab+</code> or <code>a+b</code> - Append; open or create file for update, writing at end-of-file.</li>
</ol>
",0
31244641,31244556,2,"<p>You should open it in append mode. Try this: <br> <code> if ((ptrFILE = fopen(""Phone Book.txt"", ""a"")) == NULL) </code> <br> Append mode will add contents to the end of your existing file contents.</p>
",0
31245967,31244556,0,"<p>Well in above mentioned programs-</p>

<ol>
<li><p>Fisrt Program always enters the last record you enetres as you opened file in ""w"" mode and you call function <code>void newRecord()</code> again to enter another record thus closing file then again opening it. As already contains data you want next record after it but as file is opened in ""w"" mode it discards already present data in file and the file is treated as a new empty file.</p></li>
<li><p>In second program you mentioned in your answer  is just main function thus not causing opening and closing of file again and again. That is why it normally saves your data.</p></li>
</ol>

<p>Use ""a"" or ""a+"" mode to make your first program work normally.</p>
",0
31246058,31244556,0,"<p>No need a or a+ mode. I insist :) Here are new codes. The problem has been solved.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;     // ""stdlib"" library contains of exit() and malloc function
#include &lt;Windows.h&gt;   // ""Windows"" library contains of Sleep() function which waits the system as you want

struct personKnowledge
{
    char number[16];
    char name[16];
    char surname[16];
};

void newRecord(FILE *);///
void display();
void deletE();
void add();
void update();

FILE *ptrFILE;

int main()
{
    int choice;
    if ((ptrFILE = fopen(""Phone Book.txt"", ""w+"")) == NULL)
    {
        printf(""The file couldn't open\n"");
    }
    do
    {
        printf(""\n\t\t *-* Phone Book Program *-*"");
        printf(""\n\n\t\t 1) New record"");   // The options are being presented to user
        printf(""\n\n\t\t 2) Display person knowledge"");
        printf(""\n\n\t\t 3) Delete someone"");
        printf(""\n\n\t\t 4) Add new person"");
        printf(""\n\n\t\t 5) Update person knowledge"");
        printf(""\n\n\t\t 6) Exit"");
        printf(""\n\n\nEnter your choice: "");
        scanf(""%d"", &amp;choice);
        switch (choice)
        {
        case 1:
        {
            newRecord(ptrFILE);
            break;
        }
        case 2:
        {
            break;
        }
        case 3:
        {
            break;
        }
        case 4:
        {
            break;
        }
        case 5:
        {
            break;
        }
        case 6:
        {
            printf(""\nWorking has been completed.\n"");
            exit(EXIT_SUCCESS);
            break;
        }
        default:
        {
            printf(""\nWrong entry! The program has been terminated.\n"");
        }
        }
    } while (choice &gt;= 1 &amp;&amp; choice &lt;= 6);
    fclose(ptrFILE);
    return 0;
}

void newRecord(FILE *ptrFILE)
{
    static int counter = 0;
    system(""cls"");   // Screen is being cleaned
    struct personKnowledge *p;   // p means person
    p = (struct personKnowledge *)malloc(sizeof(struct personKnowledge));   // Memory is being allocated
    fflush(stdin);
    printf(""\n\nDetermine person name: "");   // User is entering the person's knowledge and they are being saved in file
    gets(p-&gt;name);
    printf(""Determine %s's surname: "", p-&gt;name);
    gets(p-&gt;surname);
    printf(""Determine %s's number: "", p-&gt;name);
    gets(p-&gt;number);
    if (counter == 0)
    {
        fprintf(ptrFILE, ""Name\t\t\t\tSurname\t\t\t\tNumber\n"");
        fprintf(ptrFILE, ""--------\t\t   ----------------\t\t------------------------\n"");
    }   
    fprintf(ptrFILE, ""\n%33s%33s%38s\n"", p-&gt;name, p-&gt;surname, p-&gt;number);
    printf(""Please wait, information is saving to file..\n"");
    Sleep(750);
    printf(""*-* Saving operation has been completed. *-*"");
    counter++;
    free(p);
}
</code></pre>
",0
29190435,29190372,0,"<p>To try to compile a simple program with gcc and run it, type this at the bash prompt in a terminal window:</p>

<pre><code>cat &gt; myprog.c
main() {
    printf(""Hello world!\n"");
}
^d
gcc -o myprog myprog.c
./myprog  
</code></pre>

<p><em>Note ""^d"" means press the CTRL key + the D key at the same time</em></p>
",12
28488587,28487806,0,"<p>Here is some code:</p>

<pre><code>char buf[32];
sscanf(""%31s"", buf);

size_t i;

for (i = 0; i &lt; sizeof(buf) &amp;&amp; buf[i]; ++i)
{
switch (buf[i])
{
case 'A': case 'B': case 'C':
    buf[i] = '2'; break; // Note: character literal, not integer
case 'D': case 'E': case 'F':
   buf[i] = '3'; break;
....
}
}
printf(""%s"", buf);
</code></pre>

<p>If you have a Posix-compliant library, you can use dynamic allocation:</p>

<pre><code>char *buf;
scanf(""%ms"", &amp;buf); //scanf would allocate memory

for (i = 0; buf[i]; ++i)
{
.....
}

printf(""%s"", buf);
free(buf);
</code></pre>
",0
28488706,28487806,0,"<p>There are so many problems in your code, it will almost need a re-write to make it work. I think you should start something small. Make sure it works before adding more functionality. I would suggest dividing the code in <code>main</code> into three sections -- reading the phone number, converting phone number and printing the converted phone number.</p>

<p>Here's a skeletal program that captures those three steps.</p>

<pre><code>#define SIZE 50

void readPhoneNumber(char phoneNumber[])
{
}

void convertTextToNumber(char phoneNumber[], char dialedNumber[])
{
}

void printPhoneNumber(char phoneNumber[])
{
}

int main(void)
{
   char phoneNumber[SIZE];
   char dialedNumber[SIZE];

   readPhoneNumber(phoneNumber);

   convertTextToNumber(phoneNumber, dialedNumber);

   printPhoneNumber(dialedNumber);
}
</code></pre>

<p>Now, you can start fleshing out the functions. For example, <code>readPhoneNumber</code> can be implemented as:</p>

<pre><code>void readPhoneNumber(char phoneNumber[])
{
   printf(""Enter phone number: \n"");
   fgets(phoneNumber, SIZE, stdin);
}
</code></pre>

<p><code>printPhoneNumber</code> can be implemented as:</p>

<pre><code>void printPhoneNumber(char phoneNumber[])
{
   printf(""%s\n"", phoneNumber);
}
</code></pre>

<p>I'll leave you to work out the implementation of <code>convertTextToNumber</code>.</p>
",0
28488717,28487806,3,"<p><strong>EDIT</strong>: Revised. There were many comments pointing out problems, here is my answer which works with a reasonable length phone number. It skips any non-dialing characters, such as <code>'-'</code> which is not part of a phone number.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;

int main(void){
    int k, d, e, len;
    char dial[20], entry[20] = {0};
    printf(""Enter phone number: "");
    fgets(entry, 19, stdin);
    len = strlen(entry);
    d = 0;                                 // dial string index of output
    for (e=0; e&lt;len; e++) {                // entry string index of input
        k = entry[e];
        switch (toupper(k)) {
            case 'A': case 'B': case 'C':           dial[d++] = '2'; break;
            case 'D': case 'E': case 'F':           dial[d++] = '3'; break;
            case 'G': case 'H': case 'I':           dial[d++] = '4'; break;
            case 'J': case 'K': case 'L':           dial[d++] = '5'; break;
            case 'M': case 'N': case 'O':           dial[d++] = '6'; break;
            case 'P': case 'Q': case 'R': case 'S': dial[d++] = '7'; break;
            case 'T': case 'U': case 'V':           dial[d++] = '8'; break;
            case 'W': case 'X': case 'Y': case 'Z': dial[d++] = '9'; break;
            default:
                if (isdigit(k) || k=='*' || k=='#') dial[d++] = k;
        }
    }
    dial[d] = 0;          // terminate string
    printf(""Dial %s\n"", dial);
    return 0;   
}
</code></pre>
",1
28488809,28487806,0,"<p>Here you have undefined behavior, len is not initialized.</p>

<pre><code>int c=0, len, a[len];   
char n[len];
</code></pre>

<p>Use instead a constant value instead, i bet the phone number in your country has some kind of maximum length.</p>

<hr>

<p>This way to read from the keyboard is not recommended, scanf does not check for length of string so you can do a faceroll on the keyboard and your program will crash. Instead use fgets( ) to read from stdin then go through the string char by char skipping the included <code>\n</code></p>

<pre><code>printf(""Enter phone number: \n"");
scanf(""%c"", n);
</code></pre>

<hr>

<p>This makes no sense, you calculate the sizeof n i.e. of the integer that holds n. If you want the length of the string use strlen( n ); btw try to use more descriptive variable names.</p>

<pre><code>len = sizeof(n) / sizeof(n[0]);
</code></pre>

<hr>

<p>Instead of </p>

<pre><code>while (len &gt; c){
</code></pre>

<p>why not use a normal for-loop ? you seem to increment c++ everywhere.</p>

<hr>

<p>this here will not do what you expect it to do</p>

<pre><code>printf(""%d\n"", a);
</code></pre>

<p>but you assign 'a' integers e.g.</p>

<pre><code>a[c] = 2;
</code></pre>

<p>printf can not magically print a number of your array, instead you want to print out is a string with the numbers. the ascii value of a digit is 48 + digit. e.g. '0' is 48, by knowing this have a character buffer and add the ascii values to it. make sure it ends with \0 which is end of string. then print out the string</p>

<pre><code>buf[c++] = 48 + digit;
...
buf[c] = '\0';   
puts( buf );
</code></pre>
",0
29248084,29248041,4,"<p>One way would be to have a macro like</p>

<pre><code>#define bar() bar_test()
</code></pre>

<p>Now calling <code>bar()</code> by the macro calls <code>bar_test()</code></p>

<p>The function which is defined should be called as per the standard.
There is no option to change the function name during runtime and it doesn't make sense also. </p>
",3
29220449,29220119,0,"<p>Of course I initialize my structure with this function :</p>

<pre><code>void initDataOutput(DataOutput *out)
{
  out-&gt;data = NULL;
  out-&gt;pos = 0;
}
</code></pre>

<p>But i can't do that :</p>

<pre><code>DataOutput out;
char tmp[4];
out.data = tmp;
out.pos = 0;
</code></pre>

<p>Because in my code i could write things like that for example :</p>

<pre><code>DataOutput out;
writeInt(&amp;out, 1);
writeString(&amp;out, ""Hello"");
sendData(&amp;out);
</code></pre>

<p>where the int is a kind of packet id and ""Hello"" is the connexion message, but if it's an other id it's not the same information in out->data</p>

<p>Oh sorry and I don't understand what you mean when you say : avoid shifting signed integers and chars</p>

<p>I must use an unsigned char *data in my DataOutput structure ?</p>
",4
29220749,29220119,0,"<p>The DataOutput.data should be forced to unsigned char because char are sometimes signed, depending of the compiler, and shifting signed chars or casting them to int (even implicitly) will propagate the sign bit:</p>

<pre><code>typedef struct t_dataoutput
{
  unsigned char *data;
  unsigned int pos;
} DataOutput;
</code></pre>

<p>The memory for out->data has to be allocated before filled.
You can use realloc in the writeInt function like that:</p>

<pre><code>int writeInt(DataOutput *out, int i)
{
  // here i resize my char *data
  out-&gt;data = realloc(out-&gt;data, out-&gt;pos + 4);
  // TODO: test if out-&gt;data == NULL --&gt; not enough memory!
  out-&gt;data[out-&gt;pos] = (i &gt;&gt; 24) &amp; 0xff;
  out-&gt;data[out-&gt;pos + 1] = (i &gt;&gt; 16) &amp; 0xff;
  out-&gt;data[out-&gt;pos + 2] = (i &gt;&gt; 8) &amp; 0xff;
  out-&gt;data[out-&gt;pos + 3] = i &amp; 0xff;
  out-&gt;pos += 4;
}
</code></pre>
",3
29216715,29216404,0,"<p>After denesting the code the reason for the results can be deduced in a single run in a debugger.</p>

<p>e() is recursive and called once before the print and once after. So before you hit your print statement you'll have to go through e again, and again, and again till it finally hits 0.</p>

<p>After that things start unlooping and you'll see prints popping up but it's still a big recursive mess because of the second call to e(n) in which n dips into the negative. I was rather grateful n was signed because if it was unsigned it would loop round to 2^32 and the program would get stuck in, pretty much, an infinite loop.</p>

<p>So yeah, TL;DR: run it through a debugger and learn from the FUBAR a recursion like this can cause.</p>
",0
29216841,29216404,4,"<p>Here' the flow of execution after <code>e(3)</code> is called from <code>main</code>.</p>

<pre><code>e(3)
   e(2) 
      e(1) 
         e(0) ... return
         n is now 0
         print n. results in output 0
         e(-1) ... return
      n is now 1
      print n. results in output 1
      e(0) ... return
   n is now 2
   print n. results in output 2
   e(1) 
      e(0) ... return
      n is now 0
      print n. results in output 0
      e(-1) ... return
   return
</code></pre>

<p>And you see the output</p>

<pre><code>0 1 2 0
</code></pre>
",1
29216858,29216404,2,"<p>I'm assuming the following is what you want:</p>

<pre><code>#include &lt;stdio.h&gt;

void e(int);

int main()
{
    e(3);
    return 0;
}

void e(int n)
{
    if(n &gt; 0) {
        e(--n);
        printf(""%d"", n);
        e(--n);
    }
}
</code></pre>

<p>This is an example of a recursive function - a function calling itself. Here, at each call the parameter is decremented and the function is again called until the condition <code>n &gt; 0</code> is not met. Then, the <code>printf(""%d"", 0)</code> happens. Now the second <code>e(--n)</code> will have no effect until <code>n</code> is at least <code>2</code>, since  the <code>if</code> condition cannot be passed with a value of <code>n</code> less than <code>1</code>. Further <code>printf()</code>s happen in the reverse order of the call as the function calls are removed from the stack. When the value gets to <code>2</code>, the second <code>e(--n)</code> gets a chance to make an effect thus printing <code>0</code>.</p>

<p>You need to learn about <strong>recursion</strong> (if you still haven't) and then you can get a good picture of how things happen. Also, it will help you if learn more about how the stack is set up when a function is called, and later returned.</p>
",0
29216913,29216404,0,"<p>The 'flow' goes as follows:</p>

<pre><code>main -&gt; e(3)
e(3) -&gt; IF(3&gt;0)
{
    // n is pre-decremented to 2
    e(2) -&gt; IF(2&gt;0)
    {
        // n is pre-decremented to 1
        e(1) -&gt; IF(1&gt;0)
        {
            // n is pre-decremented to 0
            e(0) -&gt; 0 is not &gt; 0 so this call does nothing.
            // n is still 0 in this function call so...
            printf(0)  &lt;-- The first '0' in the output
            // n is pre-decremented to -1
            e(-1) -&gt; -1 is not &gt; 0) so this call does nothing.
        }
        // n is still 1 in this function call so...
        printf(1)  &lt;-- The '1' in the output
        // n is pre-decremented to 0
        e(0) -&gt; 0 is not &gt; 0 so this call does nothing
    }
    // n is still 2 in this function call so...
    printf(2)  &lt;-- The '2' in the output
    // n is pre-decremented to 1
    e(1) -&gt; (1 is &gt; 0)
    {
        // n is pre-decremented to 0
        e(0) -&gt; 0 is not &gt; 0 so this call does nothing
        // n is still 0 in this function call so...
        printf(0)  &lt;-- The second '0' in the output
        // n is pre-decremented to -1
        e(-1) -&gt; -1 is not &gt; 0 so this call does nothing
    }
}
</code></pre>

<p>It helps if you set the code out more clearly:</p>

<pre><code>#include&lt;stdio.h&gt;

main()
{
    e(3);
}

void e(int n)
{
    if(n&gt;0)
    {
        e(--n);    //  First recursion here, but with n=n-1 on entry to the call.
        printf(""%d"",n);  // outputs (original value of n) - 1.
        e(--n);    // Second recursion here, now with n=n-2 on entry to the call.
    }
}
</code></pre>
",0
29235559,29235306,1,"<p>I think your problem is that you don't handle <code>EOF</code> in <code>dossier</code>. So, the infinite loop would be in the <code>dossier</code> function in certain cases, not in the <code>dossierp</code> function.</p>

<p>And note that <code>getc</code> returns an <code>int</code>, not a <code>char</code>. <code>char</code> cannot represent <code>EOF</code>.</p>
",0
29246651,29235306,0,"<pre><code>The function has a problem because 

when dossierp calls dossier 
then reads the rest of the line, the EOF indication is NOT set

the dossirp then jumps to the top of the loop 
and calls dossier
but the fgetc results are not being checked for EOF
so they keep on trying to read characters, and always failing
so that is where the infinite loop is at.

suggest adding a check of the results of each call to fgetc 
for EOF and exiting the function when EOF is encountered,
returning an indication to dossierp that EOF was encountered
so dossierp can exit its loop and exit the function.

Note: reading the last line (or last character) of a file
      does not set EOF.
      Rather trying to read past the last line (or last char)
      of a file sets EOF.

 Note: EOF is an integer, so the fgetc() return variables must
       be int, not char

 a few minutes with a debugger and attention to what 
 each function returns when EOF is encountered
 (and/or an error is encountered)
 would have made finding the root of this problem very easy.
</code></pre>
",0
31869171,30571632,1,"<p>The ANSI escape sequence is not well formed when you provide a <em>negative</em> value for either row or column, which is why you're seeing something like:</p>

<pre><code>[0;-14fMon Jun 1 13:39:49 2015
</code></pre>

<p>rather than the string:</p>

<pre><code>Mon Jun 1 13:39:49 2015
</code></pre>

<p>positioned somewhere.</p>

<p>Basically, the ANSI sequence interpreter has no idea how to place the cursor fourteen character to the left of the leftmost side of your screen, so you should probably revisit <em>why</em> you're subtracting <code>20</code> from the random value to get the column.</p>

<p>If it's to ensure the text fits on the line chosen without wrapping to the next line, you should instead use (changing the value as well since there's more than 20 characters in your date string):</p>

<pre><code>random_column = rand() % (columns - 25);
</code></pre>
",0
28219813,28219103,-1,"<p>I see you fixed your access error by increasing your buffer size, but now you are wondering why the file is not being updated. The problem is you need to rewind the stream before writing.</p>

<pre><code>char* replace(char* line, char* search_pat, char* repl_pat) {
    char* ma = strstr(line, search_pat);
    if (ma == NULL)
        return NULL;
    memcpy(ma, repl_pat, strlen(repl_pat));
    return line;
    }

BOOL SearchAndReplace(const char *destFileName, const char *srcString, const char *newString)
{
    FILE *ostream = fopen(destFileName, ""r+"");
    if (ostream == 0) return false;
    int f=0,n=0;
    long pos;
    char st[64*1024]; /* make sure it's big enough */
    while(!feof(ostream))
    {
        pos = ftell(ostream);        /* save position before read */
        fscanf(ostream,""%s"",st);
        char* newline = replace(st, srcString, newString);
        if (newline != NULL) {
            fseek(ostream, pos, 0);  /* rewind to where read from */
            fprintf(ostream,""%s"",newString);
        }
    }
    fclose(ostream);
    return true;
}

SearchAndReplace(""file.txt"", ""\""en\"""", ""\""tr\"""");
</code></pre>

<p><em>NOTE</em>: Your code assumes the <code>newString</code> is the EXACT same length as the <code>srcString</code>. If they are not, this code will not work. Consider instead creating a new file, then delete the original and rename your output to input.</p>
",2
28219857,28219103,1,"<p>To prevent the error you can limit <code>scanf()</code> to read just as many characters as your array can hold, for that use this</p>

<pre><code>fscanf(""%29s\n"", st);
       /* ^ your array has room for 30, 29 characters + '\0' */
</code></pre>

<p>also, <code>feof()</code> wont return true until a read is attempted past the end of the file, so you would need one extra iteration for <code>feof()</code> to return true, and in that extra iteration, the last value at <code>st</code> will be repeated so if it matches the search string it will be printed twice, a fix would be to simple check if <code>fscanf()</code> did read a string.</p>

<pre><code>BOOL SearchAndReplace(const char *destFileName, const char *srcString, const char *newString)
{
    int   f = 0;
    int   n = 0;
    char  st[30];
    FILE *ostream;

    ostream = fopen(destFileName, ""r+"");
    if (ostream == 0)
        return false;
    while (fscanf(ostream, ""%29s"", st) == 1)
    {
        if (strcmp(st, srcString) == 0)
            fprintf(ostream, ""%s"", newString);
    }
    fclose(ostream);

    return true;
}
</code></pre>

<p>and one last thing, your code wont replace the occurrences, but that's another problem.</p>

<p>This answer addresses your problem, but you nead a very different approach to read that file, specially if you intend to parse the file content.</p>
",2
28219317,28219103,0,"<p>I modified your code a little bit and ran, it worked fine for me. Here is my code:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

bool SearchAndReplace(const char *destFileName, const char *srcString, const char *newString)
{
    FILE *ostream = fopen(destFileName, ""r+"");
    if (ostream == 0) return false;
    int f = 0, n = 0;
    char st[30];
    while (!feof(ostream))
    {
        fscanf(ostream, ""%s"", st);
        if (strcmp(st, srcString) == 0)
        {
            fprintf(ostream, ""%s"", newString);
        }
    }
    fclose(ostream);
    return true;
}
int main()
{
    bool found = SearchAndReplace(""example.txt"", ""en"", ""tr"");
    if (found){
        cout &lt;&lt; ""found"";
    } else {
        cout &lt;&lt; ""not found"";
    }

    getchar();
    return 0;
}
</code></pre>

<p>I am suspecting that you are running your program will lesser priveleges...</p>

<p>Please <strong>run your program as administrator</strong> and check if it still gives error.</p>
",1
28219340,28219103,1,"<p>This is wrong:</p>

<pre><code>char st[30];
while(!feof(ostream))
{
    fscanf(ostream,""%s"",st);
</code></pre>

<p>You cannot ask fscanf to read a string into such a small buffer, unless you know the string is <strong>always</strong> smaller than the buffer. Most likely you are encountering a larger-than-30-char string. </p>

<p>Allocate a larger buffer, or use some modern C++ construct, like ifstream >> string.</p>

<p>Also, the code above will remove whitespace. fscanf will not return the whitespace on %s. </p>

<p>Lastly, it will only replace exact match, surrounded by whitespace. So, replacing ""foo"" into ""bar"" in a string like ""blah'foo'blah"" will not work, since fscanf will not separate words at ""'"" (or at any other non-whitespace character)</p>
",3
28531146,28530768,0,"<p>There is a difference between <code>char</code> and <code>char*</code>. The latter is a pointer to char, also used as a string (a sequence of chars). So, wherever you can have more than one <code>char</code>, you use a pointer (to the first one) instead - this is your <code>argv[3]</code>.</p>

<p>So, to get one <code>char</code> from a sequence of <code>char</code>s, you apply square brackets:</p>

<pre><code>argv[3] - is the whole string, let's pretend it's ""192"" to reduce confusion
argv[3][0] - is the first char, '1'
argv[3][1] - is the second char, '9'
argv[3][2] - is the third char, '2'
</code></pre>

<p>In your case, you need <code>argv[3][i]</code>. But you have to fix your other bugs too (there are many, as other people noted).</p>
",2
28234628,28233875,0,"<p>You need first get the lenth of number, which is used to determine how many times you need to get into loop to calculate each bit.</p>

<p>For example, number 123, you first need to know the number is 3 bits len, then you can mutilply number 3 three times, number 2 twice, and number 1 once.</p>

<p>I use a temporary string to achieve this</p>

<p>here is code£¬ a little bit alteration on yours</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define MAX_NUM_LEN     16  

int main()
{
    char tmp_num[MAX_NUM_LEN] = {0};
    int len,n,d,s=0,o,i,tmp_len, tmp_o;
    printf(""n="");scanf(""%d"",&amp;n);
    sprintf(tmp_num, ""%d"", n);
    len = strlen(tmp_num);
    tmp_len = len;
    d=n;
    while(d!=0)
    {
        o=d%10;
        for (tmp_o = 1, i = tmp_len; i &gt; 0; i--)
            tmp_o *= o;
        s=s+tmp_o;
        d=d/10;
        tmp_len--;
    }

    printf(""sum:%d\n"",s);
    printf(""number of digits:%d\n"",len);
    return 0;
}
</code></pre>

<p>results:</p>

<p><img src=""https://i.stack.imgur.com/cJvU0.png"" alt=""enter image description here""></p>
",2
28235326,28233875,0,"<p>According of what I've understood I think this is what the OP is looking for:</p>

<pre><code>int power(int base, int exp)
{
    if (base == 0) return 0;
    int result=1;
    while (exp-- &gt; 0) result*=base;
    return result;
}

void calculate(int number)
{
    int d=number;
    int tmpnumber=number;
    int n=0;
    while (d &gt; 0) 
    {
        n++;
        d /=10;
    }
    printf(""Number of digits: %d\n"", n);

    int k=0;
    int sum=0;
    while (n--) 
    {
        // get digits from left to right
        d=number / power(10, n);
        k++;
        sum+=power(d, k);
        number %= power(10, n);
        printf(""%d^%d=%d\n"", d, k, power(d, k));
    }
    printf(""\n%5d %5d"", tmpnumber, sum);
}

int main(int argc,char *argv[])
{
    int value;

    while (TRUE)
    {
        printf(""Enter value (0 = Quit): ""); 
        scanf(""%d"", &amp;value);
        if (value &lt;= 0) return 0;
        calculate(value);
        printf(""\n"");
    }
}
</code></pre>
",0
28458805,28458581,2,"<p>You'd form the integral array. Modify to something like:</p>

<pre><code>int *array = (int*)malloc(N * sizeof(int));
int *integralArray = (int*)malloc(N * sizeof(int));

for (int i = 0; i &lt; N; i++) {
    fscanf(input,""%d"",&amp;array[i]);
    integralArray[i] = array[i] + ((i &gt; 0) ? integralArray[i-1] : 0);
}
</code></pre>

<p>So the element at <code>integralArray[i]</code> is the sum of all elements in <code>array</code> from <code>0</code> to <code>i</code>.</p>

<p>Then, to get the sum from <code>a</code> to <code>b</code>, where <code>a &gt; b</code>, <code>integralArray[b]</code> is the sum from <code>0</code> to <code>b</code> and <code>integralArray[a]</code> is the sum from <code>0</code> to <code>a</code> so you can just compute <code>integralArray[b] - integralArray[a]</code> to get the total from <code>a</code> to <code>b</code>. Intuitively, <code>integralArray[b]</code> includes the numbers you want but it also includes the numbers up to and including <code>a</code>. You don't want those so you take them off again.</p>

<p>Vary appropriately for inclusion or exclusion of the number at <code>a</code> and the number at <code>b</code>. That as given will include the number at <code>b</code> but not that at <code>a</code>. You could adjust your <code>integralArray</code> to be one earlier (so <code>integralArray[b]</code> is the sum from 0 to <code>b-1</code>) or adjust your indices.</p>
",11
29506157,29505924,2,"<p>This following line behaves in a way that you probably didn't intend it to.</p>

<pre><code>while(fgets(str, 80, src) &amp;&amp; fgetc(src)!=EOF){
</code></pre>

<p>It will eat away the first character of every line except the first one and will skip over processing of the last line.</p>

<p>You need</p>

<pre><code>while(fgets(str, 80, src) != NULL){
</code></pre>
",0
29506192,29505924,0,"<p>It looks as if you might want to be using something like <a href=""http://linux.die.net/man/3/getline"" rel=""nofollow"">getline</a> to read in a line at a time and parse. See example code in man page for more info.</p>
",0
29478791,29477496,3,"<p>You cannot have been printing an unsigned integer, because it has printed a <em>sign</em>. Even if you declare the variable as <code>unsigned</code>, once it is on the stack for <code>printf()</code> to use, it is interpreted as a binary value to be used as specified by the format in <code>printf()</code>.</p>

<p>Note the difference between these, and the results. In the the third example, you can see that bit 31 is set, which is the sign bit for <code>signed long int</code>.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main () {
    unsigned long int a=2075000020, b=100000000, c;
    c = a + b;
    printf (""Signed %ld\n"", c);
    printf (""Unsigned %lu\n"", c);
    printf (""Hexadecimal 0x%lX\n"", c);
    return 0;
}
</code></pre>

<p>Program output:</p>

<pre><code>Signed -2119967276
Unsigned 2175000020
Hexadecimal 0x81A3DDD4
</code></pre>
",0
28507156,28507028,2,"<p>First, only include header (.h) files containing declaration, don't include .c files with definitions.</p>

<p>That said, the reason it's failing is that you have a typo in the <code>CreateList.c</code> file. <code>testCreatetList</code> should be <code>testCreateList</code> (notice the surplus <code>t</code>).</p>

<p>You might consider declaring the <code>void testCreateList(struct ListNode *ListHead,int length)</code> in a header and include that instead of the .c file.</p>

<p>There might be other issues with the code - I really didn't look that long at it.</p>
",5
32463926,32463881,4,"<p>The way pointer arithmetic works, <code>s[i]</code> is equal to <code>*(s + i)</code>.  So <code>s[1]+1</code> is actually <code>*(s + 1) + 1</code>, which is not the same as either <code>s + 2</code> or <code>*(s + 2)</code>.</p>
",0
32465301,32463881,1,"<p>So, let's talk about pointer arithmetic for a second.  Given a pointer to any type <code>T</code>:</p>

<pre><code>T *p;
</code></pre>

<p>the expression <code>p+1</code> will evaluate to the address of the next <em>object</em> of type <code>T</code>.  So if <code>T</code> is <code>int</code>, then <code>p+1</code> will give us the address of the next <em><code>int</code> object</em> after <code>p</code>.  If <code>p</code> is <code>0x8000</code> and <code>sizeof (int)</code> is 4, then <code>p+1</code> evaluates to <code>0x8004</code>.  </p>

<p>Where things get fun is if we're working with array expressions.  Assume the following:</p>

<pre><code>T a[N];
</code></pre>

<p>Except when it is the operand of the <code>sizeof</code> or unary <code>&amp;</code> operators, an <em>expression</em> of type ""N-element array of <code>T</code>"" will be converted (""decay"") to an expression of type ""pointer to <code>T</code>"" and its value will be the address of the first element of the array.  </p>

<p>So if we write</p>

<pre><code>int a[10];
int *p = a + 1;
</code></pre>

<p>the expression <code>a</code> is converted from ""10-element array of <code>int</code>"" to ""pointer to <code>int</code>"", and the value of <code>a</code> is the address of the first element (i.e., <code>&amp;a[0]</code>).  So the expression <code>a + 1</code> gives us the address of the next <em>integer</em> object following <code>a</code>, which just happens to be <code>&amp;a[1]</code><sup>1</sup>.  </p>

<p>Now assume we're working with a 2-D array:</p>

<pre><code>int a[2][3];
int (*p)[3] = a + 1;
</code></pre>

<p>The expression <code>a</code> has type ""2-element array of 3-element array of <code>int</code>"".  In this case, <code>a</code> ""decays"" to type ""pointer to 3-element array of <code>int</code>"", or <code>int (*)[3]</code>. So <code>a + 1</code> gives us the address of the next *3-element array of <code>int</code>"". Again, assuming <code>a</code> starts at <code>0x8000</code> and <code>sizeof (int)</code> is 4, then <code>a + 1</code> evaluates to <code>0x800c</code> </p>

<p><hr>
<sup>1.  The expression <code>a[i]</code> is evaluated as <code>*(a+i)</code>; that is, we're offsetting <code>i</code> elements from the address specified by <code>a</code> and dereferencing the result.  Note that this treats <code>a</code> as a pointer, not an array.  In the B language (from which C is derived), the array object <code>a</code> would have been a pointer object that contained the address of the first element (<code>a[0]</code>).  Ritchie changed that in C so that the array expression would be converted to a pointer expression as necessary.<br>
</sup></p>
",0
33512319,33501285,5,"<p>The idea of the suggested approach is to use an indirect function call so that the function address must be computed first and then called. The C Preprocessor is used to provide a way to define a proxy function for the actual function and this proxy function provides the calculation needed to determine the actual address of the real function which the proxy function provides access to.</p>

<p>See <a href=""https://en.wikipedia.org/wiki/Proxy_pattern"" rel=""nofollow noreferrer"">Wikipedia article Proxy pattern</a> for details about the Proxy design pattern which has this to say:</p>

<blockquote>
  <p>The proxy design pattern allows you to provide an interface to other
  objects by creating a wrapper class as the proxy. The wrapper class,
  which is the proxy, can add additional functionality to the object of
  interest without changing the object's code.</p>
</blockquote>

<p>I would suggest an alternative which implements the same type of indirect call however it does not require using the C Preprocessor to hide implementation details in such a fashion as to make reading of the source code difficult.</p>

<p>The C compiler allows for a <code>struct</code> to contain function pointers as members. What is nice about this is that you can define an externally visible struct variable with function pointers a members yet when the struct is defined, the functions specified in the definition of the struct variable can be <code>static</code> meaning they have file visibility only (see <a href=""https://stackoverflow.com/questions/572547/what-does-static-mean-in-a-c-program"">What does ""static"" mean in a C program</a>.)</p>

<p>So I can have two files, a header file func.h and an implementation file func.c which define the <code>struct</code> type, the declaration of the externally visible struct variable, the functions used with a <code>static</code> modifier, and the externally visible struct variable definition with the function addresses.</p>

<p>What is attractive about this approach is that the source code is easy to read and most IDEs will handle this sort of indirect much nicer because the C Preprocessor is not being used to create source at compile time which affects readability by people and by software tools such as IDEs.</p>

<p>An example func.h file, which would be #included into the C source file using the functions, could look like:</p>

<pre><code>// define a type using a typedef so that we can declare the externally
// visible struct in this include file and then use the same type when
// defining the externally visible struct in the implementation file which
// will also have the definitions for the actual functions which will have
// file visibility only because we will use the static modifier to restrict
// the functions' visibility to file scope only.
typedef struct {
    int (*p1)(int a);
    int (*p2)(int a);
} FuncList;

// declare the externally visible struct so that anything using it will
// be able to access it and its members or the addresses of the functions
// available through this struct.
extern FuncList myFuncList;
</code></pre>

<p>And the func.c file example could look like:</p>

<pre><code>#include &lt;stdio.h&gt;

#include ""func.h""

// the functions that we will be providing through the externally visible struct
// are here.  we mark these static since the only access to these is through
// the function pointer members of the struct so we do not want them to be
// visible outside of this file. also this prevents name clashes between these
// functions and other functions that may be linked into the application.
// this use of an externally visible struct with function pointer members
// provides something similar to the use of namespace in C++ in that we
// can use the externally visible struct as a way to create a kind of
// namespace by having everything go through the struct and hiding the
// functions using the static modifier to restrict visibility to the file.

static int p1Thing(int a)
{
    return printf (""-- p1 %d\n"", a);
}

static int p2Thing(int a)
{
    return printf (""-- p2 %d\n"", a);
}

// externally visible struct with function pointers to allow indirect access
// to the static functions in this file which are not visible outside of
// this file.  we do this definition here so that we have the prototypes
// of the functions which are defined above to allow the compiler to check
// calling interface against struct member definition.
FuncList myFuncList = {
    p1Thing,
    p2Thing
};
</code></pre>

<p>A simple C source file using this externally visible struct could look like:</p>

<pre><code>#include ""func.h""

int main(int argc, char * argv[])
{
    // call function p1Thing() through the struct function pointer p1()
    myFuncList.p1 (1);
    // call function p2Thing() through the struct function pointer p2()
    myFuncList.p2 (2);
    return 0;
}
</code></pre>

<p>The assembler emitted by Visual Studio 2005 for the above <code>main()</code> looks like the following showing a computed call through the specified address:</p>

<pre><code>; 10   :    myFuncList.p1 (1);

  00000 6a 01        push    1
  00002 ff 15 00 00 00
    00       call    DWORD PTR _myFuncList

; 11   :    myFuncList.p2 (2);

  00008 6a 02        push    2
  0000a ff 15 04 00 00
    00       call    DWORD PTR _myFuncList+4
  00010 83 c4 08     add     esp, 8

; 12   :    return 0;

  00013 33 c0        xor     eax, eax
</code></pre>

<p>As you can see this function calls are now indirect function calls through a struct specified by an offset within the struct.</p>

<p>The nice thing about this approach is that you can do whatever you want to the memory area containing the function pointers so long as before you call a function through the data area, the correct function addresses have been put there. So you could actually have two functions, one that would initialize the area with the correct addresses and a second that would clear the area. So before using the functions you would call the function to initialize the area and after finishing with the functions call the function to clear the area.</p>

<pre><code>// file scope visible struct containing the actual or real function addresses
// which can be used to initialize the externally visible copy.
static FuncList myFuncListReal = {
    p1Thing,
    p2Thing
};

// NULL addresses in externally visible struct to cause crash is default.
// Must use myFuncListInit() to initialize the pointers
// with the actual or real values.
FuncList myFuncList = {
    0,
    0
};

// externally visible function that will update the externally visible struct
// with the correct function addresses to access the static functions.
void myFuncListInit (void)
{
    myFuncList = myFuncListReal;
}

// externally visible function to reset the externally visible struct back
// to NULLs in order to clear the addresses making the functions no longer
// available to external users of this file.
void myFuncListClear (void)
{
    memset (&amp;myFuncList, 0, sizeof(myFuncList));
}
</code></pre>

<p>So you could do something like this modified <code>main()</code>:</p>

<pre><code>myFuncListInit();
myFuncList.p1 (1);
myFuncList.p2 (2);
myFuncListClear();
</code></pre>

<p>However what you would really want to do is to have the call to <code>myFuncListInit()</code> be someplace in the source that would not be near where the functions are actually used.</p>

<p>Another interesting option would be to have the data area encrypted and in order to use the program, the user would need to enter the correct key to properly decrypt the data to get the correct pointer addresses.</p>
",9
32428136,32428093,0,"<p>You have not linked the libraries.</p>

<p>-lgl (or similar)</p>
",0
31861498,31861374,0,"<p>Generally the answer is that you can't. While you could do the assignment like you do, for values that fit in a <code>char</code>, how would you know that it was a number to output and not a character?</p>

<p>The only way I see it is if you know that the second character in the array will <em>always</em> be a number and not a character, then you could just print it as a character, a number and a character:</p>

<pre><code>printf(""%c%d%c\n"", ch[0], ch[1], ch[2]);
</code></pre>
",4
31862302,31861374,0,"<p>What you need here is <code>snprintf</code>, which allows you to do <code>printf</code> style formatting and put the results in a string.</p>

<pre><code>char ch[10];
int number;
scanf(""%d"",&amp;number);
snprintf(ch,sizeof(ch),""a%db"",number);
</code></pre>
",1
29499711,29498752,0,"<p>This function takes the argument you queried, <code>Byte data[]</code>, which is a pointer to an array of unsigned char:</p>

<pre><code>void showsignal(char str[], Byte data[], int size) {
</code></pre>

<p>It displays the array in binary and is called from <code>main()</code> like this:</p>

<pre><code>int main(int argc, char *argv[]) {
    float f;
    int i;
    f = atof(argv[1]);
    i = trunc(f);
    if (f-i == 0) {
        showsignal(""sinal"", (Byte *) &amp;i, sizeof(i));
</code></pre>

<p>The code inputs a number <code>float f</code> and converts it to <code>int i</code>. It then passes the <code>int</code> to the function by casting it to appear as an array of unsigned bytes. The function then prints it in binary. It knows the length of the array it is passed because of the <code>sizeof(i)</code> which is the number of bytes of <code>i</code>.</p>

<p>The cast in needed because the compiler will not accept <code>int</code> for the argument <code>unsigned char*</code>. So the program writer took the address of the <code>int</code> with <code>&amp;i</code>, cast it to <code>unsigned char*</code> pointer using <code>(Byte *) &amp;i</code>, then the function can treat it as an array to print in binary bits.</p>
",0
29499537,29498752,0,"<p>The line </p>

<pre><code>showsignal(""signal"", (Byte *) &amp;i, sizeof(i));
</code></pre>

<p>means we call the function showsignal and pass it 3 arguments. </p>

<p>The first argument is an the string ""signal"", that's simple.</p>

<p>The second argument is a bit more complicated. The &amp;i gets you the address of the variable i and then we cast that address to a Byte pointer. Because the function expects a pointer to a Byte we can't just send it the address of an integer. That's why we got to cast it to a Byte pointer.</p>
",0
27169423,27169280,-1,"<p>You can do something like this (You have to declare <code>number</code> and <code>found = 0</code> at the top(line 4)):</p>

<pre><code>    if(sum &gt;= 1000000 &amp;&amp; !found) {
        specialNumber = fibonacci;
        found = 1;
    }
</code></pre>

<p>So it checks if the sum get's bigger then a 7 digit number! And if yes the last fibonacci  number was then number you search, which is the number that makes the sum bigger then 7 digits! And found is that only the first number is assign to specialNumber.</p>

<p>So you program should look something like this:</p>

<pre><code>#include &lt;stdio.h&gt;

int main() {

    int count, sum, specialNumber, fibonacci, numberOne, numberTow, found;
    sum = 0, fibonacci = 0, numberOne = -1, numberTow = 1, found = 0;
    int n;

    printf(""Enter the limit :\n&gt;"") ;
    scanf(""%d"", &amp;n) ;

    printf(""\nThe fibonacci series is :"") ;
    for(count = 1 ; count &lt;= n ; count++) {
        fibonacci = numberOne + numberTow;
        printf(""\n%d"", fibonacci);
        sum += fibonacci;
        if(sum &gt;= 1000000 &amp;&amp; !found) {
            specialNumber = fibonacci;
            found = 1;
        }

        numberOne = numberTow;
        numberTow = fibonacci;
    }

    printf(""\nThe sum of the fibonacci series is : %d\n"", sum);
    printf(""%d makes the sum bigger than 7 digits"", specialNumber);

  return 0;

}
</code></pre>
",0
27169644,27169280,1,"<p>If you want to get the first sum of seven digits, set your threshold to one million, also known as <code>1e6 = 10**6 = 1000000</code>. Notice that there are seven digits in <code>1000000</code>.</p>

<p>If you want the sum to have more than seven digits, set the threshold to ten million. That number has eight digits.</p>

<p>The following code will do the trick. Note that instead of a <code>for</code> loop, we have a <code>while</code> loop that keeps iterating while the sum is less than the threshold.</p>

<pre><code># include &lt;stdio.h&gt;

int main() {
  int previous, current = 0, next = 1,
      sum = current, threshold;
  printf(""Enter the threshold: "") ;
  scanf(""%d"", &amp;threshold) ;
  printf(""Fibonacci series: %d"", current) ;
  while (sum &lt; threshold) {
    previous = current;
    current = next;
    next = previous + current;
    printf("" + %d"", current) ;
    sum += current;
  }
  printf("" = %d\n"", sum);
  return 0;
}
</code></pre>
",3
27169735,27169280,0,"<pre><code>#include&lt;stdio.h&gt;
void main()
{
 int a = -1, b = 1, c = 0, i, n, term1, term2;
 long sum = 0;
 printf(""Enter the limit : "");
 scanf(""%d"", &amp;n);
 printf(""\nThe fibonacci series is :"");
 for(i = 1 ; i &lt;= n ; i++)
 {
  c = a + b ;
  printf(""%d \n"", c) ;
  sum = sum + c ;
  if(sum &gt;= 1000000){
  term1 = a;
  term2 = b;
  break;
  }
a = b ;
b = c ;
}

printf(""\nThe sum of the fibonacci series is : %ld"", sum);
printf(""\n terms are %d and %d"", term1, term2);
printf(""\n"");
}
</code></pre>

<p>This program breaks from the loop when it finds the right terms that makes sum more that 7 digits.
Hope I understood what you meant to say.</p>
",0
27169848,27169280,0,"<p>Changing your code as little as possible:</p>

<pre><code># include &lt;stdio.h&gt;
int main(int argc, char ** argv)
{
    int a = -1, b = 1, c = 0, i = 1, n = 0, sum = 0 ;
    printf(""\nThe fibonacci series is :"") ;
    while (sum &lt;= 10000000)
    {
        c = a + b ;
        printf(""%d-"", c) ;
        sum = sum + c ;
        a = b ;
        b = c ;
        n = i;
        i++;
    }
    printf(""\nThe sum of the fibonacci series is : %d"", sum) ;
    printf(""\nThe term is %d the value is %d"", n , c);
    printf(""\n"");
    return 0;
}   
</code></pre>
",1
29442342,29442089,0,"<p>You had a mess. First do NOT use <code>gets</code>. It is no longer part of libc and is horribly insecure. Next, you cannot assign a string with <code>=</code> after the initial declaration and initialization. It is also a good idea to <strong>always</strong> initialize <strong>all</strong> of your variables. (attempting to read/use an uninitialized value is <strong>Undefined Behavior</strong>)</p>

<p>There are a number of ways to use <code>strtok</code>. One of the most effective is simply to use a <code>for</code> loop. The initial condition uses the name of the string variable, while the increment uses <code>NULL</code>. The test condition is simply that the return is not <code>NULL</code>. When using <code>strtok</code> it will destroy the original string (by embedding <code>null-terminating</code> characters in it). While not required in your code, it is a good idea to always send a copy to <code>strtok</code>. (it is imperative if <code>str</code> is dynamically allocated) Also, <strong>note:</strong> the return from <code>strtok</code> (a pointer to the current token), is <strong>only good</strong> for the current iteration. If you need to preserve the token, make a copy of it as well.</p>

<p>Next, when you compile your program, always compile with <strong>warnings</strong> enabled. At minimum <code>gcc -Wall -o progname yourfile.c</code>. You can also add <code>-Wextra</code>.</p>

<p>Here is an updated version of your code. Take a look and let me know if you have questions:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define MAXS 256

/* calls and functon prototypes */
void printlatinwork (char *thiss);

int main (void)
{
    char again = 'n';

    do {
        char *thiss = 0;
        char str[MAXS] = {0};
        char copy[MAXS] = {0};
        size_t nchr = 0;
        int c = 0;

        /* prompt the user to enter his phrase */
        printf (""please enter the phrase to be converted: "");
        // str[20] = gets (str); /* NEVER USE gets */
        fgets (str, MAXS - 1, stdin);

        /* get the length of str */
        nchr = strlen (str);

        /* strip newline or carriage rtn    */
        while (nchr &gt; 0 &amp;&amp; (str[nchr-1] == '\n' || str[nchr-1] == '\r'))
            str[--nchr] = 0;

        /* strtok destroys original string, make copy */
        strncpy (copy, str, strlen (str));

        /*  THIS LOOPS THRU TOKENS AND PRINTS */
        for (thiss = strtok (copy, "" ""); thiss != NULL; thiss = strtok (NULL, "" ""))
            printlatinwork (thiss);

        printf (""\ngo again? enter y to go again\n"");
        scanf (""%c"", &amp;again);

        /* always flush the input buffer after calling scanf
           or craft a format string that consumes the newline
           that remains in stdin (created by pressing [Enter]) */
        while ((c = getchar()) != '\n' &amp;&amp; c != EOF);

    } while (again == 'y');

    return 0;
}

/*  FUNCTION TO PRINT, CALLED THERE */
void printlatinwork (char *thiss)
{
    printf (""%s%c%s "", thiss + 1, thiss[0], ""ay"");
}
</code></pre>

<p><strong>Output</strong></p>

<pre><code>$ ./bin/findchar
please enter the phrase to be converted: this is my phrase
histay siay ymay hrasepay
go again? enter y to go again
y
please enter the phrase to be converted: this is my phrase
histay siay ymay hrasepay
go again? enter y to go again
n
</code></pre>

<p><strong>Note</strong> in <code>printlatinwork</code> you should check the length of <code>thiss</code> is greater than <code>1</code> to prevent an <strong>undefined read past end of string</strong> (bad).</p>
",2
29502271,29502152,-2,"<p>You need to start the loop with a condition that is true and then end it when it becomes false.  Otherwise the loop does not know when the condition becomes false i.e. it is always true and therefore it continues to loop.  My obs.</p>
",2
29502431,29502152,3,"<p>Check compiler warnings (e.g.: gcc -Wall file.c).  You should get a warning on the line ""while(fp !=EOF){"" that you are comparing a pointer to an integer.  The function works if you rewrite the while statement as:</p>

<pre><code>while ((text[t] = fgetc(fp)) != EOF){
    printf(""%c"",text[t]);
    t++;
}
</code></pre>

<p>Notice that you need to look for EOF in the character retrieved by fgetc, not in the file pointer fp.</p>
",0
31165678,31165565,0,"<p>Position is zero (pos = 0) at the beginning of each line and increments everytime a character is not a new line.</p>
",2
27548050,27547752,1,"<p>They typically compile down to the same assembly code especially with optimizations turned on or, otherwise, with a simple loop (e.g <code>rep stos</code>).
However, it depends on the context: you usually don't even need (although you think so) to zero an array.  </p>

<p>I would definitely prefer the first version as it's less error prone and (imho) states clearly your intent.</p>
",0
28516449,28516380,0,"<p>Reason for infinite loop : In your second case you do not progress the stream as in first case</p>

<p><a href=""http://www.cplusplus.com/reference/cstdio/getc/"" rel=""nofollow""><code>getc()</code></a></p>

<blockquote>
  <p>Returns the character currently pointed by the internal file position indicator of the specified stream. The internal file position indicator is then advanced to the next character.</p>
</blockquote>

<p>A solution :</p>

<pre><code>#include &lt;stdio.h&gt;

void main()
{
    FILE *fp;
    char c;

    long n = 0L;
    fp=fopen(""main.c"",""r"");

    while(getc(fp)!=EOF)
    {
        fseek(fp,n,0);
        printf(""\n position '%ld'"",ftell(fp));
        n++ ;
    }
    fclose(fp);

}
</code></pre>

<p>Furthermore : </p>

<p><code>fseek()</code> do not progress the file pointer.</p>

<blockquote>
  <p>Sets the position indicator associated with the stream to a new position.</p>
</blockquote>

<p><code>feof()</code></p>

<blockquote>
  <p>This indicator is generally set by a previous operation on the stream
  that attempted to read at or past the end-of-file.""</p>
</blockquote>

<p>So this explains your failure. Second implementation does not come across EOF as first case. Provided sample of code would provide you an workaround. </p>
",0
28516547,28516380,0,"<p>Check in documentation if <code>fseek</code> or <code>ftell</code> sets <code>feof()</code> result. Possibly not, so when you removed <code>getc</code> call <code>feof</code> can no longer return 'true', hence infinite loop.</p>

<p>Anyway, are you interested in the explanation why <strong>this</strong> program behaves strange or rather how you should write your program properly to achieve the result described...?</p>
",0
28516587,28516380,0,"<p><code>fseek()</code> will not set the <code>EOF</code> marker, and in fact it can unset the <code>EOF</code> marker and it should do it after a succesful call.</p>

<p>Also, as the link points out the <code>while (feof(fp) == 0)</code> is always wrong, it's because you need to <code>fgetc()</code> one extra <code>char</code> for the <code>EOF</code> marker to be set, so you will have one extra iteration, instead you have to do it this way</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    FILE    *fp;
    int      c; /* this should be 'int' and not 'char' */
    long int n;

    fp = fopen(""myfile.txt"", ""w"");
    if (fp == NULL)
        return -1;
    printf(""Enter the data into file:\n"");
    while ((c = getchar()) != EOF)
        putc(c, fp);
    printf(""Total character into file:%ld\n"", ftell(fp));
    fclose(fp);

    fp = fopen(""myfile.txt"",""r"");
    if (fp == NULL)
        return -1;
    while ((c = fgetc(fp)) != EOF)
    {
        if (c == '\n')
            printf(""charcater `\\n' at position '%ld'\n"", ftell(fp));
        else
            printf(""charcater `%c' at position '%ld'\n"", c, ftell(fp));
        n++;
    }
    fclose(fp);

    return 0;
}
</code></pre>
",0
28516593,28516380,0,"<p>A successful call <code>fseek</code> function clear the end-of-file indicator, but your loop condition rely on <code>feof</code>, so <code>feof(fp) == 0</code> always true.</p>
",0
28516612,28516380,0,"<p>fseek(SEEK_SET) merely sets the FILE's pointer to a position in the file.  It doesn't actually do any reading of the file or anything.  So, it will gladly let you set the position to WAY past the end of the file (and it clears any existing EOF set on the stream).  ftell() merely returns the position of the file pointer.</p>

<p>Without doing a read of some sort (e.g. - getc()), EOF won't be set on the stream and your loop will be infinite.</p>

<p>You can do a fseek(fp, 0, SEEK_END) and then an ftell() to know the size / end of the file position.</p>

<p>PS - You really need to check your return values more carefully and handle any failures.</p>
",0
26435568,26435507,1,"<p>The whole thing gets a pointer to the second half of the <code>k32</code>nd element in the array.</p>

<p>The array element is a <code>long long</code>. Half of a <code>long long</code> is a <code>long</code>. The second half is found by casting the <code>long long *</code> pointer to a <code>long *</code> and then incrementing by 1. That gives you a pointer to the second half.</p>

<pre><code>           a64[k32]       // the k32'nd element of the array     type: long long
          &amp;a64[k32]       // address of the k32'nd element       type: long long *
 (long *) &amp;a64[k32]       // that address re-cast to long *      type: long *
((long *) &amp;a64[k32] + 1)  // the second half of the k32'nd item  type: long *
</code></pre>

<p>This is not completely portable. It would be safer to use <code>int32_t</code> and <code>int64_t</code> instead of <code>long</code> and <code>long long</code>. It also assumes a particular endianness.</p>
",1
32397823,32396188,0,"<p>Let me just give a few comments in your own writing:</p>

<p><code>getpass()</code> only reads 8 characters, so don't use it.</p>

<p>Own code should be written in a way that permits to detect whether the user entered more characters than expected.</p>

<p><code>filedes.h</code> does not exist and is not needed.</p>

<p>The paswd is usually read either from /dev/tty or from stderr.</p>

<p>If you do not catch important signals, the code may leave the tty in an unusable state.</p>

<p>See the UNIX source code for a working implementation:</p>

<p><a href=""http://sourceforge.net/p/schillix-on/schillix-on/ci/default/tree/usr/src/lib/libc/port/stdio/getpass.c"" rel=""nofollow"">http://sourceforge.net/p/schillix-on/schillix-on/ci/default/tree/usr/src/lib/libc/port/stdio/getpass.c</a></p>
",0
32396815,32396188,2,"<p>If your terminal supports these escape codes, this will conceal what you type for a password.</p>

<pre><code>#include &lt;stdio.h&gt;

void UserPW ( char *pw, size_t pwsize) {
    int i = 0;
    int ch = 0;

    printf ( ""\033[8m"");//conceal typing
    while ( 1) {
        ch = getchar();
        if ( ch == '\r' || ch == '\n' || ch == EOF) {//get characters until CR or NL
            break;
        }
        if ( i &lt; pwsize - 1) {//do not save pw longer than space in pw
            pw[i] = ch;       //longer pw can be entered but excess is ignored
            pw[i + 1] = '\0';
        }
        i++;
    }
    printf ( ""\033[0A"");//move cursor up one line
    printf ( ""\033[21C"");//move cursor 21 places
    while ( i) {
        printf ( ""*"");//overwrite password on screen. this is still concealed
        i--;
    }
    printf ( ""\033[28m"");//reveal typing
}

int main ( ) {
    char password[20];

    printf ( ""Enter your password: "");
    fflush ( stdout);//prompt does not have '\n' so make sure it prints
    UserPW ( password, sizeof ( password));//password array and size
    printf ( ""\nentered [%s]\n"", password);//instead of printing you would verify the entered password
    return 0;
}
</code></pre>
",1
29506761,29506742,2,"<p><code>%c</code> is for a single character.  <code>%s</code> is what you want, which will output the entire string.  When you change to <code>%s</code> you will no longer need to dereference the <code>notes[]</code> string element:</p>

<pre><code>printf(""%s"", notes[i]);
</code></pre>
",0
29506768,29506742,1,"<p>You need to use <code>%s</code> format specifier instead of <code>%c</code>. <code>%c</code> is used for character literal and <code>%s</code> is used for string literal. So try this:</p>

<pre><code>printf(""%s"", notes[i]);
</code></pre>
",0
29506833,29506742,0,"<p>The statement</p>

<pre><code>printf(""%c"", *notes[i]);
</code></pre>

<p>will give you a <em>character,</em> located at the address specified by <code>notes[i]</code>. In other words, the first character of the string.</p>

<p>If you want the <em>entire string,</em> you should be using:</p>

<pre><code>printf (""%s"", notes[i]);
</code></pre>

<p>You can see the difference in the following program:</p>

<pre><code>#include &lt;stdio.h&gt;
int main (void) {
    char *notes[] = {
        ""A"", ""A#"", ""B"", ""C"", ""C#"", ""D"", ""D#"", ""E"", ""F"", ""F#"", ""G"", ""G#""
    };
    for (int i = 0; i &lt; sizeof(notes) / sizeof(*notes); i++)
        printf(""bad = %c, good = %s\n"", *notes[i], notes[i]);
    return 0;
}
</code></pre>

<p>which outputs:</p>

<pre><code>bad = A, good = A
bad = A, good = A#
bad = B, good = B
bad = C, good = C
bad = C, good = C#
bad = D, good = D
bad = D, good = D#
bad = E, good = E
bad = F, good = F
bad = F, good = F#
bad = G, good = G
bad = G, good = G#
</code></pre>
",0
29508321,29506742,1,"<p>Thanks for everyone's help answering my original question. That was a dumb     mistake, I thought there was a problem somewhere else and I didn't think about     other things that could cause issues. Anyway, I finished the program so I wanted to share it, maybe other people would like to use it.</p>

<p>I'm also wondering if anybody sees anything that I could do to improve my programs in the future. I know that scanf is bad and can be used to cause an overflow, but I don't really get fgets, there was some strange behavior when a user entered more characters than the input array was defined to have, so I just used scanf instead. Until I figure out a solution for that, just keep your input at 9 characters (for this program you will only need a <strong>maximum</strong> of two characters for your answers, anyway).</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#include &lt;math.h&gt;

/*
Author: DreadedEntity
Date: 4/8/15
*/

int calculateNote(char *notes[], char *string[], int fret);
int notePosition(char *notes[], char *string[]);

int main()
{
    srand(time(NULL));

    char input[10];

    int playerPoints = 0;
    int compPoints = 0;

    int string;
    int fret;

    int round = 1;

    int answer;

    char *notes[12] = {""A"",""A#"",""B"",""C"",""C#"",""D"",""D#"",""E"",""F"",""F#"",""G"",""G#""};
    char *strings[6] = {""E"",""B"",""G"",""D"",""A"",""E""};

    printf(""Let's play a game!\n\nI will give you a string and a fret on a guitar and you tell me what note it is!\nIf you answer correctly, you get a point, but if you answer incorrectly I get a point.\n\nWhoever has the most points after 20 rounds wins!\n"");
    system(""pause"");

    do
    {
        string = (rand() % 6) + 1;
        fret = (rand() % 24);

        printf(""%d. Tell me what the note is on string %d, fret %d: "", round, string, fret);
        //printf(""\n%s\n"", strings[string-1]);

        answer = calculateNote(notes, strings[string-1], fret);

        //printf(""%s"", notes[answer]); //take the comment away from this line to get all the answers

        scanf(""%s"", &amp;input);

        if (strcmp(input, notes[answer]) == 0)
        {
            printf(""Wow, you got that one! One point for you!\n"");
            playerPoints++;
        } else
        {
            printf(""Sorry, that's not right! One point for me!\n"");
            compPoints++;
        };

        round++;
    } while (round &lt;= 20);

    printf(""\nThe game is over! Let's take a look at our points!\n\nYou: %d\nMe:  %d\n\n"", playerPoints, compPoints);

    system(""pause"");

    if (playerPoints &gt; compPoints)
    {
        printf(""\nYou beat me! I'll get you next time! "");
    } else
    {
        if (playerPoints == compPoints)
        {
            printf(""\nWow a tie, great job! "");
        } else
        {
            printf(""\nBetter luck next time! "");
        };
    };

    system(""pause"");

    return 0;
}

//get position of the actual note on the fret for ""notes"" array
int calculateNote(char *notes[], char *string[], int fret)
{
    int position = notePosition(notes, string);

    position += fret;

    while (position &gt;= 12)
    {
        position -= 12;
    };

    return position;
};

//get position of the note of the input string(unfretted) in ""notes"" array
int notePosition(char *notes[], char *string[])
{
    int i = 0;

    while (strcmp(notes[i], string) != 0)
    {
        i++;
    };

    return i;
};
</code></pre>
",0
31226912,31226791,1,"<pre><code>                                      State after the line has been executed
                                      ======================================

                                      n      m      p1  p2   q1  q2
                                      -----  -----  --  ---  --  --
void foo(int *q1, int *q2)            1,2,3  4,5,6  n   m    n   m
{
    q1=q2;                            1,2,3  4,5,6  n   m    m   m
    *q1=*q2+1;                        1,2,3  5,5,6  n   m    m   m
}

                                      n      m      p1  p2   r1   r2
                                      -----  -----  --  ---  ---  ---
void bar(int **r1, int **r2)          1,2,3  5,5,6  n   m    &amp;p1  &amp;p2
{
    r1=r2;                            1,2,3  5,5,6  n   m    &amp;p2  &amp;p2
    *r1=*r2+1;                        1,2,3  5,5,6  n   m+1  &amp;p2  &amp;p2
    **r1=**r2+2;                      1,2,3  5,7,6  n   m+1  &amp;p2  &amp;p2
}

                                      n      m      p1  p2
                                      -----  -----  --  ---
void main(void)
{
    int n[]={1,2,3};                  1,2,3
    int m[]={4,5,6};                  1,2,3  4,5,6
    int *p1=n;                        1,2,3  4,5,6  n
    int *p2=m;                        1,2,3  4,5,6  n   m

    foo(p1,p2);                       1,2,3  5,5,6  n   m
    bar(&amp;p1,&amp;p2);                     1,2,3  5,7,6  n   m+1
    printf(""%d %d\n"", *p1, *p2);
}
</code></pre>

<p>Renamed some variables to avoid having to distinguishing between the various variables named <code>p1</code> and <code>p2</code>. Doing so has no effect on what happens, though.</p>
",2
31227034,31226791,0,"<p>To reduce confusion, let's call the pointers in <code>foo()</code> <code>fp1</code> and <code>fp2</code>, and the pointers in <code>bar()</code> <code>bp1</code> and <code>bp2</code>... so that we can easily distinguish them from the pointers in <code>main()</code>.  </p>

<p>In <code>main()</code>, before calling <code>foo()</code>, you've set <code>p1</code> to point at <code>n[0]</code>, and <code>p2</code> to point at <code>m[0]</code>.</p>

<p>When you call <code>foo()</code>, at first <code>fp1</code> and <code>fp2</code> have the values of <code>p1</code> and <code>p2</code> from <code>main()</code> and point at <code>n[0]</code> and <code>m[0]</code>... but then you set <code>fp1=fp2;</code>, so both point at <code>m[0]</code>.  The line <code>*fp1 = *fp2 + 1;</code>, then essentially does <code>m[0] = m[0] + 1;</code> so <code>main()</code>'s <code>m</code> then contains <code>{5,5,6}</code>.  <code>p1</code> and <code>p2</code> in <code>main()</code> remain unchanged (as you were working with local copies in <code>foo()</code>), so when <code>foo()</code> returns they still point at <code>n[0]</code> and <code>m[0]</code>.</p>

<p>When you call <code>bar()</code>, you pass pointers to <code>main()</code>'s <code>p1</code> and <code>p2</code> themselves, rather than just the values they hold.  So initially, <code>bp1</code> and <code>bp2</code> point at <code>p1</code> and <code>p2</code>, <code>*bp1</code> and <code>*bp2</code> (which <em>are</em> <code>main()</code>'s <code>p1</code> and <code>p2</code>) point at <code>n[0]</code> and <code>m[0]</code>.  The line <code>bp1 = bp2;</code> makes <code>bp1</code> also point at <code>main()</code>'s <code>p2</code>, so then both <code>*bp1</code> and <code>*bp2</code> <em>are</em> <code>main()</code>'s <code>p2</code>.  So the next line, <code>*bp1 = *bp2 + 1;</code>, is essentially <code>p2 = p2 + 1;</code> which increments <code>main()</code>'s <code>p2</code> to point at <code>m[1]</code> instead of <code>m[0]</code>.  The last line of <code>bar()</code>, <code>**bp1 = **bp2 + 2;</code>, then increments <code>m[1]</code> by <code>2</code> (since <code>bp1</code> and <code>bp2</code> are both pointers to main()'s <code>p2</code>, which points to <code>m[1]</code>).  When the function exits, <code>p2</code> in <code>main()</code> still points at <code>m[1]</code>.</p>

<p>So when the <code>printf()</code> occurs in <code>main()</code>, after the calls to <code>foo()</code> and <code>bar()</code>, <code>p1</code> still points at <code>n[0]</code> which still has the value <code>1</code>, and <code>p2</code> points at <code>m[1]</code> which now has the value <code>7</code>.</p>
",2
31226828,31226791,1,"<p>It makes perfect sense. I won't explain <code>foo</code> because it does nothing of import -- I wouldn't be surprised if it was optimized out.</p>

<p><code>bar</code> is passed <code>n</code> and <code>m</code> as parameters, then immediately overwrites <code>p1</code> (formerly <code>n</code>) with <code>p2</code> (<code>m</code>), so you have <code>m</code> and <code>m</code> as parameters. Then it increments the pointers (thus you now have <code>m+1</code> in both parameters), then it adds 2 to the first element of <code>m+1</code>. So at this point <code>m</code> looks like <code>4,7,6</code> (technically <code>5,7,6</code> if we don't ignore <code>foo</code>, but again that's irrelevant).</p>

<p>Outside the function you write the first number of <code>p1</code> (<code>n</code>) and <code>p2</code> (<code>m+1</code>), so you get <code>1</code> and <code>7</code>.</p>
",12
32473645,32473061,1,"<p>I'm not sure to understand your question.</p>

<p>I tried this code (a little bit modified) :</p>

<pre><code>char getstr()
{
    static char s[]=""GATE2016"";
    printf(""in getstr : %p\n"", s);
    return s;
}

int main()
{
    printf(""in main : %p\n"",getstr());
    return 0;
}
</code></pre>

<p>And I get</p>

<pre><code>in getstr : 0x601040
in main : 0x40
</code></pre>

<p>We can see here that only one byte is passed by getstr, as expected.</p>

<p>Anyway, many printf implementations use <a href=""http://linux.die.net/man/3/va_arg"" rel=""nofollow"">va_args</a>, and va_args convert every <code>char</code> or <code>short</code> into an <code>int</code>. That's how you end up with a 32bit variable.</p>
",1
32474481,32473061,-2,"<p>It isn't being promoted at all.  Assuming that you're programming for a desktop computer, <code>printf</code> uses the stack in a clever way to allow you to pass a variable number of arguments.</p>

<p>The first parameter to <code>printf</code> is the format string.  This contains a run-time specification of the type and number of all of the other parameters.  Since parameters are passed by pushing 'them' onto the stack, the code can work out where each parameter is in memory based on the stack address of the format string.</p>

<p>In your code, you use the <code>%s</code> format specifier to tell <code>printf</code> that you have placed a pointer to an array of contiguous characters, terminated by a <code>\0</code> null character in the next position on the stack.  What you have actually placed on the stack is a single byte (<code>char</code>).  So, <code>printf</code> will read a number of bytes from the stack, including the one you placed there, that are sufficient for it to interpret as a pointer.  However, that pointer will be effectively random, since it is not a real memory address.  <code>printf</code> then attempts to read characters from that memory and the segmentation fault occurs because the memory either doesn't physically exist or is not accessible to your process.</p>

<p>The cause of this is probably that the <code>getstr</code> function is incorrect: it is defined as returning a single <code>char</code>, but it actually returns the least significant byte of the address of the <code>s</code> array.  You probably should define the return value as a <code>char*</code>:</p>

<pre><code>char* getstr()
{
    static char s[]=""GATE2016"";
    return s;
}
</code></pre>

<p>Doing this will make the parameter passed to <code>printf</code> the correct type (a pointer to a string) and it should work as expected.</p>
",0
31224001,31223963,5,"<p>You need to initialize <code>c</code> before the inner loop:</p>

<pre><code> while(i&lt;=500)
 {
     b=i;
     c=0;    /* reset 'c' */
     while(b&gt;0)
     {
        a=b%10;
        c=(a*a*a)+c;
        b=b/10;
     }
}
</code></pre>

<p>You are using non-standard signature for <code>main()</code>. See: <a href=""https://stackoverflow.com/questions/204476/what-should-main-return-in-c-and-c"">What should main() return in C and C++?</a></p>
",5
31224870,31223963,0,"<p>if you run the following code</p>

<p>you will see why there is only one output.</p>

<p>Note: correct declaration of main()</p>

<p>Note: using common functions rather than the proprietary conio.h</p>

<p>Note: uses simple 'for' statement rather than 'while' and increment of 'i'</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
//#include&lt;conio.h&gt;

int main()
{
    //clrscr();
    int a;
    int b;
    int c=0;
    int i=1;

    for( ; i&lt;=500; i++ )
    {
        b=i;

        while(b&gt;0)
        {
            a=b%10;
            c=(a*a*a)+c;
            b=b/10;
        }

        printf( ""a=%d. b=%d, c=%d\n"", a,b,c);
        if(c==i)
            printf(""%d\n"",i);
    } // end for

    //getch();
    getchar();
    return(0);
} // end function main
</code></pre>
",0
31281362,31281252,2,"<p>You've got several errors.</p>

<ol>
<li>In your first loop, you want to read into <code>a[i]</code>, not <code>a[10]</code>.</li>
<li>Your code corrently assumes you always type in 10 numbers.  It looks like you wanted a value of 0 to end the list.  Me, I'd use end-of-file to end the list.  To check for <code>0</code> you need an extra line <code>if(a[i] == 0) break;</code> in the loop.  To check for EOF (or other non-numeric input which will cause problems) you could check to see that <code>scanf</code> returns 1.</li>
<li>In case you enter less than 10 numbers, you'll need a new variable that knows how many variables you actually entered.  I set <code>nn = i</code> after the first loop.</li>
<li>Then you just need to change the second loop to run from <code>1</code> to <code>nn</code>, not <code>10</code>.</li>
</ol>

<p>Putting this all together, we have:</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
  int a[10];
  int i,max, count, nn;

  printf(""Enter numbers: "");        
  for(i=0;i&lt;10;i++)
  {
    if(scanf(""%d"",&amp;a[i]) != 1) break;
    if(a[i] == 0) break;
  }
  nn = i;
  max=a[0];                     
  count=1;
  for(i=1;i&lt;nn;i++)
  {
    if(max&lt;a[i])
    {
        count = 1;
        max = a[i];
    }
    else if(max==a[i])
    {
        count++;
    }
  } 

  printf(""The largest number is %d\n"",max);
  printf(""The occurrence count of the largest number is %d\n"",count);

  return 0;
}
</code></pre>

<p>This seems to work.</p>
",0
31281701,31281252,0,"<p>Code is OK other than the user needs to enter 10 numbers.</p>

<p>There is no need to store previous numbers, so code can simply examine each new number until <code>'\n'</code> is encountered.   Just keep look for the end-of-line before looking for the number.</p>

<pre><code>#include &lt;limits.h&gt;
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

int main(void) {
  int count = 0;
  int max = INT_MIN;
  printf(""Enter numbers: "");
  for (;;) {
    int ch;
    int num;
    while (isspace(ch = fgetc(stdin)) &amp;&amp; ch != '\n') {
      ;
    }
    if (ch == '\n' || ch == EOF) break;
    ungetc(ch, stdin);
    if (scanf(""%d"", &amp;num) != 1) break;
    if (num &gt;= max) {
      count++;
      if (num &gt; max) {
        max = num;
        count = 1;
      }
    }
  }
  printf(""The largest number is %d\n"", max);
  printf(""The occurrence count of the largest number is %d"", count);
  return 0;
}
</code></pre>
",1
31293102,31292794,0,"<p>If you are interested only with integers, then use this</p>

<pre><code>int a = 5;
int b = 0;
int c = a * 10 + b
</code></pre>

<p>For the string manupulation</p>

<pre><code> char a = '5';
 char b = '0';
 char c[3];
 snprintf(c, 3, ""%c%c"", a, b);
 c[2] = '\0';
</code></pre>
",2
31292910,31292794,0,"<p>There's no <code>+=</code> concatenating operator in C.</p>

<p>You can <a href=""http://man7.org/linux/man-pages/man3/printf.3.html"" rel=""nofollow""><code>snprintf()</code></a> those two numbers into a char array. And convert it back to integer using <a href=""http://man7.org/linux/man-pages/man3/strtol.3.html"" rel=""nofollow""><code>strto*</code></a> function if you need it in integer representation.</p>
",3
31292930,31292794,2,"<p>Adding digits using integers and addition:</p>

<pre><code>int i1 = 5;
int i2 = 0;
int result = i1 * 10 + i2; /* 50 */
</code></pre>

<p>Concatenating characters to get a string <code>""50""</code>:</p>

<pre><code>char c1 = '5';
char c2 = '0';
char result[3];
result[0] = c1;
result[1] = c2;
result[2] = '\0'; /* End of string */ 
</code></pre>
",0
29481084,29480964,1,"<p>Let c the cent part then the numerator of your fraction is <code>c/pgcd(c,100)</code> and the denominator is <code>100/(pgcd(100,c))</code></p>
",5
32939647,32938679,0,"<p>Use %*c in scanf to consume the newlines along with space around %d in the scanf in main(). I tested the below code on MingW and it seem to work. The '\n' in your scanf is being consumed making it scanf() return while the '\n' at the press of enter key still remains in IO buffer to be consumed by scanf() again; hence the weird behaviour.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define length 20

int insert(float *a, int size)
{
    int  n = 0;
    while(n&lt;size &amp;&amp; scanf(""%f%*c"", &amp;a[n]))
    {
        printf(""you entered: "");
        printf(""%2.1f\n"", a[n]);
        n++;
    }
    return n;
}

int main(int argc, char* argv[])
{
float x;
    int y;
    float array1[length], array2[length], array3[length];
    float ray[length];
    int size1 = insert(array1, length);
    printf(""enter number: "");
    scanf(""%d"", &amp;y);
    int size2 = insert(array2, length);
    int size3 = insert(array3, length);
    return 0;    
}
</code></pre>
",3
32939654,32938679,0,"<p>In the <code>scanf</code> format string, change <code>""%f\n""</code> to <code>""%f""</code>.  The <code>\n</code> in a scanf format string does not mean ""wait for newline"".  </p>

<p>You do not need to worry about waiting for newline, because the only format specifiers you use are <code>%f</code> and <code>%d</code>, which both discard any leading whitespace.</p>
",0
32456061,32455935,0,"<p>The reason it is not working is that system is starting a separate process, changing its working directory, then exiting. Your program needs to change its own directory by calling <code>chdir</code>.</p>
",6
32456259,32455935,0,"<p>If you're using a unix based OS, use <a href=""http://linux.die.net/man/2/chdir"" rel=""nofollow""><code>chdir()</code></a>. For windows you'll have to use <a href=""https://msdn.microsoft.com/en-us/library/bf7fwze1.aspx"" rel=""nofollow""><code>_chdir()</code></a>, although an alias chdir exists, it is deprecated.</p>

<p>Both the functions return 0 on success and -1 if an error occurred. </p>

<p>You can only change the directory in which the program executes. <strong>You can't change the working directory of your shell.</strong></p>
",0
31867279,31866843,0,"<p>If <code>mem</code> actually points to bytes which form a valid representation for a <code>struct st</code> then this code is correct, apart from <code>sizeof(st)</code> which should be <code>sizeof(struct st)</code> or <code>sizeof st1[i]</code>.  However, since the three blocks are contiguous you could have done it all in one copy:</p>

<pre><code>memcpy(&amp;st1, ptr, sizeof st1);
</code></pre>

<p>If <code>mem</code> does not point to such bytes then this whole approach will not work.</p>
",0
33529572,33529389,1,"<p>Most likely explanation is that each process on your system is only allowed to have 1024 open file descriptors at a time. 3 of those are reserved for <code>stdin</code>, <code>stdout</code> and <code>stderr</code>.</p>

<p>So the problem is that each time you call <code>gethostbyname</code>, you create a new <code>sockfd</code>, but the code doesn't <code>close</code> the socket when it's done with it.</p>
",1
28213839,28213690,2,"<p>An array is a sequence of data item of homogeneous value(same type. A string in C, is an array of characters ending with the NUL-terminator(<code>\0</code>).</p>

<p>The declaration for the <code>strlen</code> function is</p>

<pre><code>size_t strlen(const char *str)
</code></pre>

<p>Which means that it takes an argument of type <code>const char*</code>, not an <code>int*</code> or an <code>int[]</code>. So it won't work for integer arrays. You'll get a warning if you try to pass it as an argument to <code>strlen</code>-</p>

<pre><code>warning: passing argument 1 of ¡®strlen¡¯ from incompatible pointer type
</code></pre>

<p>And then, if you try to execute the program, you'll run into <a href=""http://en.m.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow"">UB(Undefined Behaviour)</a> which means that anything can happen including segmentation faults,crashes,formatting you hard disk etc etc etc</p>
",0
27139680,27139349,1,"<p>Here is the <strong>non-technical explanation of project layout</strong>.</p>

<p><strong>(1.)</strong> All of the jargon can be boiled down to <strong>keeping your code clean, readable and maintainable</strong> so navigating a 100,000 (or 1,000,000) line source doesn't interfere with your coding thought process. If you are getting lost in your source, it's time to think about pairing things down and putting like code in separate files.</p>

<p><strong>(2.)</strong> What goes where? Well.., <strong>keep stuff that is logically related together</strong>. If you have a short project, then there may be no need to split the code up at all. If on the other-hand you are using an abstract data structure for data handling (e.g a <code>linked-list</code>, etc.), then it will make sense to split the data-handling structures and function off into a separate header and source so your main source isn't cluttered with 1000 lines of list manipulation code. If it is a scientific project with functions related to orbital mechanics, then it would make sense to split those routines off as well. Basic rule <strong>keep stuff that goes together -- together.</strong> Not only does this promote <strong>maintainability</strong>, but it promotes <strong>reusability</strong> as well. If you have another project that needs the same orbital mechanics routines, you can reuse the source and header you have already created, rather than reinventing the wheel each time.</p>

<p><strong>(3.)</strong> As your custom code base grows, it may make sense to <strong>start grouping like functions together in their own files, which you can later turn into libraries</strong>, or that you can use whenever. If you have a collection of functions that provide <code>binary output representation</code> and/or handled <code>bit operations</code>, those may make sense to you to keep together. Same with your <code>file/directory</code> routines. Same with your <code>string manipulations</code> routines. The bottom line <strong>whatever logical groupings make sense to you</strong>, and help <strong>keep your code clean and maintainable</strong> make sense to be kept together.</p>

<p><strong>(4.)</strong> Another consideration is <strong>data hiding/protection &amp; function access</strong>. By splitting your data into separate headers, you can to some extent control in C what functions and what source files have access to what data by whether you make that data available through header inclusion. For an extreme example of the extent to which this can be used, see <a href=""https://ritdml.rit.edu/handle/1850/8544"" rel=""nofollow""><strong>Object oriented programming with ANSI-C</strong></a>.</p>

<p><strong>(5.)</strong> <strong>When is a good time to split things up?</strong> Here again, when you start a project, you either have those pieces you have already split up that you plan on using, that you bring in, or you find yourself prototyping from basically 1 file. As that file grows, when you get to the point that you are spending brain-power hunting/searching through your file for functionX or variableY, then it is probably time to look and see if you can clean up your code and make life easier by collecting the like code into a separate file. You are the judge. If you are one of those people that can slice/dice 100,000 lines without ever losing track of the logic-flow, locations, etc., then you won't get to the ""It might make sense to collect and separate"" point much later than others. It's what works for you.</p>

<p>There are other considerations, <strong>no doubt 6-500 more</strong>, but that is the jest of why you would want to split your code up between various headers and source files. You often see examples when you are learning, of code nicely split between files where there is no other reason but to show it can be done behind it. If you have 27 lines of code in 3 functions and 2 variables, there is no reason to split anything up, but you will find example, after example, that does it -- just to show what you can do to compartmentalize your data and code. That doesn't mean you need to start splitting when you hit line 28. Do what works for you.</p>
",2
27139681,27139349,1,"<p>The answer is relatively simple, but the details are up to you, the system designer:</p>

<ol>
<li>create a .h file for each and every .c file</li>
<li>only include a specific header file when it is needed</li>
<li>from a top level project directory,
<ul>
<li>create a sub directory that include all the .h files (<code>include</code> is a common name)</li>
<li>create a sub directory that include all the .c files (<code>src</code> is a common name)</li>
</ul></li>
<li>in your <code>makefile</code>, in the top level project directory,
<ul>
<li>define a macro that has the path to the .h file(s)</li>
<li>define a macro that has the path to the source file(s)</li>
<li>define a macro that has the path to where the .o files are to be placed</li>
<li>define a macro to where any other files are to be kept 
  (for instance .d dependency files)</li>
<li>use those macros in the gcc compile statements</li>
<li>use the .o macro in the gcc linker statements</li>
</ul></li>
</ol>
",4
30180690,30179044,1,"<p>It looks like the problem is worded poorly; is <code>c</code> supposed to direct you to read the words into an unsorted list?  That would make sense to me.</p>

<p>Anyway, design your <code>insertionsort</code> function to match the prototype of the standard library's <code>qsort</code>.  This way you can reuse your code and move the logic for comparing two words out of your sort function.  Determining whether a word ""comes before"" another word is trivial.</p>

<p>For calculating the running time of your algorithm, take a look at the <code>clock</code> function.  This does not return the running time of your program but be a better indicator of how much CPU time your sorting algorithm took.  A good way to minimize the running time of your program is to refrain from making system calls and heap allocations in your loops, if possible.  Note that insertion sort has a very bad worst-case time complexity but is very good for almost-sorted data.  Selecting the right sorting algorithm for your data set can make a big difference.</p>
",0
30215812,30215728,3,"<p>The code shown here  invokes <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow"">undefined behaviour</a>. The problems in your code:</p>

<ol>
<li><code>scanf()</code> requires a <em>pointer</em> type argument to store the scanned value.</li>
<li><code>%s</code> is for <em>strings</em>, <code>%c</code> is for <code>char</code>.</li>
<li>for <code>%c</code>, the <code>\n</code> is <em>not</em> ignored. So, you've to use it like <code>"" %c""</code> to avoid the trailing <em>newline</em>.</li>
</ol>

<p>However, I don't see any logic to ""extract <strong>only one</strong> integer from a random array"". You may need to check your logic once again.</p>

<p>Notes:</p>

<ul>
<li>The recommended signature of <code>main()</code> is <code>int main(void)</code>.</li>
<li>always initalize all your local variables.</li>
</ul>
",2
29210189,29210174,5,"<p>The error is telling you that your decision to use a bitwise shift is non-sensical.</p>

<p>Stick with the multiplication operator.</p>
",0
29210196,29210174,8,"<p>In C the operands of <code>&lt;&lt;</code> and <code>&gt;&gt;</code> operator must be of integer type.</p>
<h3>C11: 6.5 Expressions (p4):</h3>
<blockquote>
<p>Some operators (the unary operator <code>~</code>, and the binary operators <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&amp;</code>, <code>^</code>, and <code>|</code>, collectively described as <strong>bitwise operators</strong>) <strong>are required to have operands that have integer type</strong>.[...]</p>
</blockquote>
<p>Note that in</p>
<pre><code>float32_t num = num *scale ;  
</code></pre>
<p><code>num</code> is not initialized and its value is unspecified and may result in undefined behavior.</p>
",1
29210317,29210174,0,"<p>A bitwise shift of a floating-point value makes no sense.</p>

<p>If you want to multiply a floating point number by 2<sup>n</sup>, to get the same numeric effect as shifting an integer by <code>n</code> bits, there's a library function for that:</p>

<pre><code>#include &lt;cmath&gt;                           // C++, &lt;math.h&gt; in C
float32_t scaled_num = std::ldexp(num, 6); // C++, ldexpf in C (assuming `float32_t` is `float`)
</code></pre>
",0
29210323,29210174,3,"<p>Shifting floating point values doesn't make any sense. Even if you forced the compiler to generate code that shifts the bits of the floating point value the result would definitely not be equivalent to multiplication. Bits in floating point numbers aren't generally organized like integers.</p>

<p>If there's any optimization that your compiler can do to make a multiplication by a power of two faster the compiler will figure it out for you.</p>

<p>If your complier is terrible and can't figure out the optimization the standard function you're looking for is called <code>ldexp</code>. It multiplies a floating point value by a power of two. But if your code is ever running on a machine where <code>FLT_RADIX</code> isn't 2 (very uncommon), <code>ldexp</code> will probably be a bad idea, so don't do this unless you can show it's strictly necessary.</p>
",0
33032766,33030921,0,"<p>First of all: Run this through a compiler, I'd wager it wont compile. Enable compiler warnings. </p>

<p>Secondly:</p>

<pre><code>main() {
</code></pre>

<p>That wont work. Do:</p>

<pre><code>void main(void) {
</code></pre>

<p>Thirdly:</p>

<pre><code>n&lt;H_SIZE
</code></pre>

<p>Wtf is that supposed to be doing? You probably wanted to type <code>r1</code> instead. Note that also your <code>n</code> is never initialised and never used anywhere else in the code</p>

<p>Fourthly:</p>

<pre><code>printf(""%d\t"", hadamard_matrix);
</code></pre>

<p>Thats not how printing a matrix works.</p>

<p>You also seem to be missing a closing brace in there somewhere.</p>
",0
32952793,32952689,2,"<p><a href=""http://curl.haxx.se/libcurl/"" rel=""nofollow"">Libcurl</a> is a popular choice for making HTTP requests, which I assume is what you're interested in doing.</p>
",0
32952798,32952689,2,"<p>In pure C wirthout any library it is not possible as network access depends on the specific platform. However, the <a href=""https://en.wikipedia.org/wiki/Network_socket"" rel=""nofollow"">socket</a> API is some kind of standard library which permits sending data via TCP/IP. The necessary HTTP handling, if desired, would have to be implemented on top of that.</p>
",0
26793239,26793210,1,"<p>Testing to see if the while condition will fail is one way. </p>

<pre><code> while (num &gt; 0) {
    int remainder = num % 10;
    num = num / 10;
    i++;
    if (num &gt; 0) {
        printf(""Digit: %d\n"", remainder);
    } else {
        printf(""Last Digit: %d\n"", remainder);
    }
 }
</code></pre>

<p>Or change the while condition...</p>

<pre><code> while (num &gt; 9) {
    int remainder = num % 10;
    num = num / 10;
    i++;
    printf(""Digit: %d\n"", remainder);   
 }
 printf(""Last Digit: %d\n"", num);
</code></pre>
",1
26793258,26793210,2,"<p>Use</p>

<pre><code>if (num &gt; 0) //Indicates that there are more digits to come
{
    printf(""Digit: %d\n"", remainder );
} 
else // Otherwise, it is the last digit
{
    printf(""Last Digit: %d\n"", remainder);
}
</code></pre>

<p>Instead of just</p>

<pre><code>printf(""Last Digit: %d\n"", remainder);
</code></pre>
",0
30164972,30164886,0,"<p>Compile time operators -> Calculated during compilation</p>

<p>Run time operators -> During execution</p>

<p>Example:</p>

<p>INPUT A,B</p>

<p>C = A + B</p>

<p>Here + is run time operator as it depends on values you input.</p>
",0
30166613,30164886,1,"<p>For C; various optimisations (e.g. constant propagation and constant folding) mean that every operator can potentially be done at compile time (if the situation permits it).</p>

<p>For a simple example, consider this function:</p>

<pre><code>int foo(int a, int b) {
    return a+b;
}
</code></pre>

<p>This looks like the addition needs to be done at run time. </p>

<p>Now consider this code:</p>

<pre><code>int x = foo(1, 2);
</code></pre>

<p>Now the compiler can ""inline"" the function, propagate the constants, and do the addition at compile time. You'd end up with <code>int x = 3;</code> (plus a potentially redundant copy of the <code>foo()</code> function which is capable of doing the addition at run time).</p>

<p>There are also cases where an optimisation can't be done at compile time but can be done during linking (with LTO/Link Time Optimisation); where the operator isn't evaluated at compile time or run time. A simple example would be if code in another object file (""compilation unit"") did <code>int x = foo(1, 2);</code>.</p>

<p>Also, in general, the opposite is also true - nothing guarantees that an operator will be evaluated at compile time when it is possible; so you can't say that an operator is always ""compile time"". For a simple example of this, consider string concatenation (e.g. <code>char *myString = ""Hello "" ""World!"";</code>) - it would be legal for the compiler to generate code that does the concatenation at run time (even though it's hard to think of a reason why a compiler would want to).</p>
",0
30148790,30148695,2,"<p>I strongly recommend you to use arrays, if your prof. will be ok with it.
And there is a question: do you want to just print it ? or change .. </p>

<pre><code>#include&lt;stdio.h&gt;
int main(){
    int n[4];
    int i;

    for(i=0;i&lt;4;i++){
        printf(""Enter 4 numbers"");
        scanf(""%d"",&amp;n[i]);  
    }
    for(i=0;i&lt;4;i++){
        printf(""%c = %d\n"",(97+i),n[i]);    
    }

}
</code></pre>
",1
31902296,31902237,1,"<p>This:</p>

<pre><code>sum=(limit*(2*1+(limit-1)*1))/ 2;
</code></pre>

<p>actually is the same as this formula:</p>

<p><a href=""https://i.stack.imgur.com/kRzwH.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/kRzwH.png"" alt=""enter image description here""></a></p>

<p>where <code>Sn</code> denotes the sum of <code>n</code> terms, <code>n</code> is the number of terms(<code>limit</code>) and <code>a1</code> is the first term of the AP and <code>d</code> is the common difference. All this information is found in the <a href=""https://en.wikipedia.org/wiki/Arithmetic_progression#Sum"" rel=""nofollow noreferrer"">Wikipedia page for arithmetic progressions</a>.</p>
",0
31902326,31902237,1,"<p>One way to explain this.</p>

<p>Write all the the numbers twice, once forward once backwards, then add these two series:</p>

<pre><code>    1 +   2 +   3 + ... + n-2 + n-1  +  n    
    n + n-1 + n-2 + ... +   3 +   2  +  1
-----------------------------------------
  n+1 + n+1 + n+1 + ... + n+1 + n+1 + n+1
</code></pre>

<p>So there are n x (n+1)'s and since you added two copies, divide this by 2, so the formula is</p>

<pre><code>sum = (n * (n+1)) / 2
</code></pre>
",0
30168735,30168087,2,"<p>This:</p>

<pre><code>write(fd, ""%s"", strlen(z));
</code></pre>

<p>makes no sense, the <code>write()</code> function is not <code>printf()</code>. Read more documentation.</p>

<p>You need something like:</p>

<pre><code>char buf[32];

const size_t len = snprintf(buf, sizeof buf, ""%d\n"", z);
write(fd, buf, len);
</code></pre>
",0
29955700,29955661,2,"<pre><code>scanf(""%s"", &amp;word);
</code></pre>

<p>needs an array of characters to read the data. <code>&amp;word</code> only has space for one character.</p>

<p>You are running into undefined behavior.</p>

<p>Use</p>

<pre><code>char word[26];
scanf(""%25s"", &amp;word);
</code></pre>
",0
29955710,29955661,0,"<p>The reason is that you are passing the address to the <code>char</code> variable you declared and <code>scanf()</code> is trying to write two bytes where it only fits one.</p>

<pre><code>char word
</code></pre>

<p>this declares a <code>char</code> variable, it can hold a single byte</p>

<pre><code>scanf(""%s"", &amp;word);
</code></pre>

<p>whill require at least one byte for an empty string the <code>'\0'</code>.</p>

<p>But also, you declared a lot of functions inside <code>void grab_user_input(void)</code>, that is not valid standard c, it might work with some compiler, but it's not standard.</p>
",0
30197787,30197660,1,"<pre><code>typedef struct node{Check check ;struct node *next; } *link;
</code></pre>

<p>So, <code>link</code> is a pointer to <code>node</code>.</p>

<pre><code>link *temp;
</code></pre>

<p><code>temp</code> is a pointer to <code>link</code>, or pointer to pointer to node.</p>

<pre><code> if(temp-&gt;check.refc == refc)
</code></pre>

<p>This can also be written as <code>(*temp).check.refc</code>. <code>(*temp)</code> is a pointer to node, but you are accessing it with <code>.</code> which is reserved for structs and unions. </p>

<p>You need to either to <code>(*temp)-&gt;check.refc</code> or (much preferred) refactor your code to not use those pesky double pointers.</p>
",0
31840079,31839750,0,"<p>ASCII characters are simply sequential 8 bit values i.e. 'a'=97, 'b'=98, 'A'=65, 'B'=66.</p>

<p>Therefore, to get the 'weight' of a letter, you simply compute your lowercase char minus 'a'+1 or your uppercase char minus 'A' + 1.</p>

<p>So in pseudocode (because I'm not going to write your homework for you:</p>

<pre><code>function char_weight(c):
    weight = c - 'A'
    if c greater than or equal to 'a':
        weight = weight + 'a' - 'A'
    return weight

function word_weight(word):
   add char_weight(each_char) to total
   return total 
</code></pre>
",0
31840080,31839750,0,"<p>Assuming that the words are separated by one space, the code would look something like this :</p>

<pre><code>c=fgetc(stdin);
while(c!=EOF) {
    s=0;
    while(c!=' ') { //while we are in a word
           if(c&gt;='a' &amp;&amp; c&lt;='z')
               s+=(c-'a'+1);
           else
               s+=(c-'A'+1);
           c=fgetc(stdin);
    }
    printf(""%d\n"", s);
}
</code></pre>

<p>This <code>s+=(c-'a'+1);</code> is possible due to ASCII code. In ASCII  (American Standard Code for Information Interchange), every character has a value : <em>'a' = 97</em>. This means that you don't have to write <code>s+=(c-97+1)</code> (which works too), but you just don't have to remember the ASCII code of any character.</p>

<p>To convince yourself, write something like :</p>

<pre><code>if('b' == 98)
    printf(""They are equal);
else
    printf(""They aren't equal"");
</code></pre>

<p>To proof that you can add a number to a character :</p>

<pre><code>char ch;
ch='a';
ch=ch+1;
if(c == 'b')
  printf( ""you can add a number to a character"" );
</code></pre>
",0
30193429,30193324,2,"<p>Yes, it does. As per <code>C11</code> standard, chapter ¡ì6.7.2.2, <strong>Enumeration specifiers</strong>, paragraph 3, (<em>emphasis mine</em>)</p>

<blockquote>
  <p>The identifiers in an enumerator list are declared as constants that have type int and may appear wherever such are permitted.<sup>127)</sup> An enumerator with <code>=</code> defines its enumeration constant as the value of the constant expression. <strong>If the first enumerator has no <code>=</code>, the value of its enumeration constant is <code>0</code>. Each subsequent enumerator with no <code>=</code> defines its enumeration constant as the value of the constant expression obtained by adding <code>1</code> to the value of the previous enumeration constant.</strong> (The use of enumerators with
  = may produce enumeration constants with values that duplicate other values in the same enumeration.) The enumerators of an enumeration are also known as its members.</p>
</blockquote>

<p>So, in your case, <code>NUMBER_OF_SPIIP</code> holds a value of <code>2</code>.</p>
",0
30406719,30406693,4,"<p>In your code, <code>name</code> is just a <code>char</code>.</p>

<p>OTOH, <code>""King""</code> is called a <em>string literal</em>. You need to have a <code>char</code> pointer to hold the base address of the string literal.</p>

<p>Change your code to</p>

<pre><code>char *name;
</code></pre>

<p>That said, to print a string, you need <code>%s</code> format specifier. Use it like</p>

<pre><code>printf(""%s"",name);
</code></pre>

<p>Suggestion: The recommended signature of <code>main()</code> is <code>int main(void)</code>.</p>
",4
30406877,30406693,0,"<p>""char"" designates just that: a single character.</p>

<p>To store a chain of characters, you need to use an array of chars or a pointer on a char like so:</p>

<pre><code>char name[10]; //array of characters, stores up to 10, indexed from 0 to 9.

char *name; //pointer to a character, stores as many as you want, but beware of memory allocation.
</code></pre>
",0
30407271,30406693,2,"<p>In C, declaring a variable as ""char"" means your variable can only hold one character. i.e. 'a', 'b', '-', '=', etc.</p>

<p>If you wish to hold more characters, i.e. a string, you need to declare the char variable according to the character length of what you want to copy to your variable.</p>

<p>In your case, if you wish to assign ""King"" to name, name must be declared as such:</p>

<pre><code>char name[5] = ""King""; 
</code></pre>

<p>Note that we declare name as size 5 because the last character of a string is the invisible null character '\0'. Because C doesn't have an inbuilt string type   but an array of chars, we need the null character to indicate that we have reached the ""end of the current string."" Also note that if you use the ""string.h"" header function ""strlen"", which gives you the length of the string, the return value doesn't include the null character. So, calling <code>strlen(name)</code> would return ""4"" not ""5"". The null character is neglected.</p>

<p>If you wish to declare name first and THEN copy ""King"" to it, you can include the ""string.h"" header and use the strcpy function.</p>

<pre><code>#include ""stdio.h""
#include ""string.h""

int main(void){

    char name[5];
    strcpy(name,""King"");
    printf(""%s"", name);

return 0;
}   
</code></pre>

<p>You cannot assign string literals to a char array as such: <code>name = ""king"";</code> in C.</p>

<p>I hope the code above wasn't too confusing as you're just starting out. It gets easier with practice!</p>
",3
28443290,28443236,0,"<p>Use the <code>ncurses</code> library, which was designed for this task. <code>stdio</code> will not (at least not easily) give you access to your terminal's capabilities; you can then overwrite arbitrary positions on your screen.</p>
",1
28443320,28443236,1,"<p>Last time I used the centering formula it was:</p>

<pre><code>left_column = (width / 2) - (text/2);
</code></pre>

<p>So you could brute for this: </p>

<pre><code>const std::string hw = ""Hello World!""; 
unsigned int spaces = (columns / 2) - (hw.length() / 2);
for (unsigned int i = 0; i &lt; spaces; ++i)
{
  std::cout &lt;&lt; ' ';
}
std::cout &lt;&lt; hw &lt;&lt; std::endl;
</code></pre>

<p><strong>Edit 1:</strong><br>
The above assumes the use of a fixed-pitch font.<br>
For variable pitch font, you will need to sum up all the character widths and spacings.  The string length will not suffice.</p>

<p><strong>Edit 2:</strong><br>
Another way to cheat is to use the <code>std::width</code> manipulator along with the <code>std::left</code> or <code>std::right</code> manipulators.<br>
So you could set the width to the number of spaces, then print out one space.
See also <code>std::fill</code>.</p>

<p><strong>Edit 3: Vertical Centering</strong><br>
The vertical centering using the same formula:  </p>

<pre><code>Lines to print after = (lines in console) / 2; // Assuming your text is only 1 line. 
</code></pre>

<p>For portability, you can print half the lines to clear the junk, then print the text line, then print half the lines.</p>

<p>But since there is no standard for consoles, especially with windowing systems, you will have to get that information on the fly.</p>
",1
28443388,28443236,2,"<p>No idea why this was down voted.  Seems a perfectly valid question.</p>

<p>You've solved the horizontal.  Nice job!</p>

<p>If you are in a UNIX environment (Bash especially) you can query the environment variables <code>$LINES</code> and <code>$COLUMNS</code> to find out what the length and width of the screen is.</p>
",1
28443478,28443236,0,"<p>You can rely on the fact that text which goes off the right of the screen scrolls onto the left, so you can find out how many characters to add to repeatedly move off the right of the screen and onto the next line at the left of the screen and add it to your current calculation:</p>

<pre><code>printf(""%*s\n"", (columns / 2 + stringLength)+((rows/2)*columns), string );
</code></pre>
",0
28460840,28443236,1,"<p>thank you all for your input. I have no idea why my question was down voted. My bad if it was kind of a dumb question but that's why we are here right!? anyway, I figured out the answer, might not be the best but it worked :) I thought, I would share it with you. By the way, this is compiled in an UNIX environment. </p>

<pre><code>#include &lt;sys/ioctl.h&gt;                                  //Use of binary forms tog et the terminal size
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void writeScr(char *string, int rows, int cols);

int main()
{

    struct winsize w;                                   //struct winsize : will get the screensize width and height.
    ioctl(0, TIOCGWINSZ, &amp;w);                           //TIOCGWINSZ, IOCtl to Get the WINdow SiZe.

    int columns = w.ws_col;                             //w.ws_col : number of columns from IOCTL 
    int rows = w.ws_row;                                //w.ws_row : number of rows from IOCTL


    writeScr(""Hello world\n"", w.ws_row, w.ws_col);


    return 0;
}

/*Functions*/

void writeScr(char *string, int rows, int cols)
{
    int vertl = rows/2;
    int hortl = 0;
    int stringLength = strlen(string) / 2;

    hortl = (cols - strlen(string))/2;                  //Calculate the center Horizontally

    for (int x = 0; x &lt;= rows; x++)                     //For loop to print blank spaces
    {
        printf(""\n"");
        if (x == vertl)                                 //If x is in the middle (vertically centered), print the string
        {
            printf(""\n%*s\n"", cols / 2 + stringLength, string );            //Print string to the center horizontally
        }
    }
}
</code></pre>
",0
29211429,29211343,0,"<p>Type definitions should go in the header only. They do not need to be repeated in the <code>.c</code> files. Simply include the header in your source files to access the type definitions.</p>

<h3>time.h</h3>

<pre><code>typedef struct
{
  ...
} time;
</code></pre>

<h3>time.c</h3>

<pre><code>#include ""time.h""
</code></pre>
",4
29211452,29211343,1,"<p>Declaring a global variable is not the same thing as declaring a type. If the typedef should be visible to everyone that includes your h file, then naturally the typedef needs to be in the h file.</p>

<p>And the other way around: if the typedef is local to your C file, there is no need to present it to the caller at all.</p>

<p>Please note that there is never a reason to use global non-constant variables in C. Replace them with static file scope variables in your C file, that are accessed through setter/getter functions.</p>
",0
29211478,29211343,1,"<p>Into the .h go:</p>

<ul>
<li>Definitions of all types to be used for externally visible variables</li>
<li>All <code>extern</code> declarations of variables (thus externally visible variables)</li>
</ul>

<p>Into the .c go:</p>

<ul>
<li>Definitions of all types to be used by internal-only visible variables</li>
<li>Definitions of all variables (visible externally and internally)</li>
</ul>
",0
33017666,33017625,5,"<p><code>argv[0]</code> holds the name of the executable which most likely you don't want to include in the loop. so, you need to start the loop from <code>i=1</code>.</p>

<p>As per your input, the <code>argv[0]</code> does not contain a numeric value hence causing a failure to <code>sscanf()</code>, leaving <code>a</code> uninitialized.</p>

<p>So, in your code, the primary issue is with,</p>

<pre><code>b = a + sum;
</code></pre>

<p>where, for the first iteration, <code>a</code> and <code>sum</code> are both uninitialized local variables having indeterminate value. So, for the very first loop, you're invoking <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow"">undefined behavior</a>. </p>

<p>Also, <code>a</code> being an <code>int</code>, you need to use <code>%d</code> format specifier for it.</p>

<p>Two things to mention:</p>

<ol>
<li>Always check for the return value of <code>scanf()</code> family for success.</li>
<li>Always initialize your local variables. </li>
</ol>
",2
33034443,33017625,0,"<ul>
<li><p>You are getting garbage value because you are not initialized varuiable <strong>sum</strong> on declaration.</p></li>
<li><p>Just initialize is as <code>sum = 0</code> and u will get expected result.</p></li>
<li><p>Or u can use below code also.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char*argv[]){
int n = argc;
int i, a, b, sum=0;

for(i = 0; i &lt; n; i++){
  a = atoi(argv[i]);     
  sum += a;
}

 printf(""%d\n"", sum);
 return 0;
}
</code></pre></li>
</ul>
",0
34209917,34209854,5,"<p><kbd>ESC</kbd> is <code>27</code> in ASCII.</p>

<p>So, you want <code>#define ESC 27</code> and check the value returned by <code>_getch</code>. </p>

<p><a href=""http://www.asciitable.com"" rel=""noreferrer"">Here's an ASCII table</a></p>
",3
34210000,34209854,2,"<p>A general solution to this problem would be to just print out the value c is set to. That way any key you press you can get the value for.</p>

<pre><code>default:
   printf(""Key pressed has value = %d\n"",c);
   break;
</code></pre>
",1
34210854,34209854,8,"<p><code>Up,Down,Left,Right</code> is known as extended key and to detect them you have to read Two <code>Char</code> first one is <code>Null</code> and the second is the <code>ASCII</code> code but <code>ESC</code> is not extended key so you can detect it with only one <code>char</code>.</p>

<p>I hope that code will help you:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define esc 27

int main()
{
    char ch;
    do
    {
        ch = getch();
        switch(ch)
        {
            case esc:
                // your logic goes here
                break;
        }
    }
    while(exitflag != 1);
}
</code></pre>
",0
34210745,34209854,3,"<p>I think you are confusing the <code>Esc</code> key with the general term &quot;escape sequence&quot;, in which a particular value is used to indicate that values which follow do not have their usual meaning - and often the <code>ESC</code> value <code>27</code> <em><strong>is</strong></em> used to do this, but not in this case.</p>
<p>When you press the Arrow (and other non-printing) keys, <code>_getch()</code> returns two values from consective calls. The first value is <code>0</code> or <code>224</code> which acts as an &quot;escape&quot; character to indicate that the next call will inform of the actual key pressed.</p>
<p>The code you posted does not detect the Arrow keys, it detects the keys <code>'H'</code>, <code>'P'</code>, <code>'K'</code> and <code>'M'</code>, although I suspect that the first <code>_getch()</code> was intended to read the escape value.</p>
<p>When I run the following program and press the keys <code>1</code>, <code>Up-arrow</code>, <code>Esc</code></p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;

int main(void)
{
    int k;
    do {
        k = _getch();
        if (k == 0 || k == 224) {   // Escape sequence?
            printf(&quot;Special key: &quot;);
            k = _getch();           // read again
        }
        printf(&quot;%d\n&quot;, k);          // print numeric key value
    } while (k != 27);              // end when Esc pressed
    
    return 0;
}
</code></pre>
<p>I get the following output:</p>
<pre><code>49
Special key: 72
27
</code></pre>
<p>Conclusion: I recommend you detect <code>0</code> and then have a nested <code>switch</code> statement to figure out which non-printing key was pressed.</p>
",1
30696342,30695587,0,"<p>It's not easy to make you understand, but look here at my code. I hope you will find what you need.</p>

<pre><code>int min(int a,int b)
{
    return(a&lt;b?a:b);
}
struct node
{
 int val;
 struct node* next;
};
struct graph
{   
 int v;
 struct node** arr;
};
struct graph* createGraph(int v)
{
    int i;
    struct graph* temp =(struct graph*)malloc(sizeof(struct graph));
    temp-&gt;v=v;
    for(i=0;i&lt;v;i++)
     temp-&gt;arr=(int**)malloc(sizeof(int*)*v);
    for(i=0;i&lt;v;i++)
     temp-&gt;arr[i]=NULL;
    return temp;
}
void addEdge(struct graph* g,int u,int v)
{
    struct node* temp =(struct node*)malloc(sizeof(struct node));
    temp-&gt;val = v;
    temp-&gt;next = g-&gt;arr[u];
    g-&gt;arr[u] = temp;     
}
void apUtil(struct graph * g,int node,int* isVisited,int* des,int* parent,int* low,int* ap)
{
    struct node* temp=NULL;
    static int time=0;
    int children=0;
    temp = g-&gt;arr[node];
    isVisited[node]=1;
    time++;
    //printf(""\nsetting time for %d"",node);
    des[node]=low[node]=time;

    while(temp!=NULL)
    {       
       if(!isVisited[temp-&gt;val])
        {
          children++;
          parent[temp-&gt;val]=node;
          apUtil(g,temp-&gt;val,isVisited,des,parent,low,ap);

      low[node]= min(low[node],low[temp-&gt;val]);

          if(parent[node]==-1 &amp;&amp; children&gt;1)
             ap[node]=1;

      if(parent[node]!=-1 &amp;&amp; des[node]&lt;=low[temp-&gt;val])
            ap[node]=1;           
        }    
        else if(temp-&gt;val!=parent[node])
        {
            low[node]=min(low[node],des[temp-&gt;val]);
        }
       temp= temp-&gt;next;
      }
     //printf(""%d"",node);
}
void AP(struct graph* g)
{
    int i;
    int* des = (int*)malloc(sizeof(int)*g-&gt;v);
    int* isVisited = (int*)malloc(sizeof(int)*g-&gt;v);
    int* parent = (int*)malloc(sizeof(int)*g-&gt;v);
    int* low = (int*)malloc(sizeof(int)*g-&gt;v);
    int* ap = (int*)malloc(sizeof(int)*g-&gt;v);
    for(i=0;i&lt;g-&gt;v;i++)
    {
        isVisited[i]=0;
        parent[i]=-1;
        ap[i]=0;
    }
    for(i=0;i&lt;g-&gt;v;i++)
    {
        if(isVisited[i]==0)
        {
            apUtil(g,i,isVisited,des,parent,low,ap);
        }
    }
    printf(""\n"");
    for(i=0;i&lt;g-&gt;v;i++)
    {
        printf("" %d "",ap[i]);
    }
}
main()
{
    struct graph* g = createGraph(5);
    addEdge(g,1,0);
    addEdge(g,0,2);
    addEdge(g,2,1);
    addEdge(g,0,3);
    addEdge(g,3,4);
    AP(g);
}   
</code></pre>
",0
30214785,30214537,4,"<p>Here(in function <code>lowerCase</code>):</p>

<pre><code>letterfreq[i] = letterfreq[i] - 32;
</code></pre>

<p>you need to <em>add</em> 32 to convert the character into uppercase. Look at the <a href=""http://www.asciitable.com/index/asciifull.gif"" rel=""nofollow noreferrer"">ASCII table</a> to know why.</p>

<p>Here(in function <code>countFreq</code>):</p>

<pre><code>for(i = 0; i &lt; STRSIZE; i++)
{   
    while(letterfreq[i] != '\0')
    {   
        if(letterfreq[i] &gt;= 'a' &amp;&amp; letterfreq[i] &lt;= 'z')
        {
            counter[c]++;
            c++;
        }
        else 
            if((letterfreq[i] &lt; 'a') || (letterfreq[i] &gt; 'z'))
            {   
                counter[COUNT-1]++;
            }
    }
}
</code></pre>

<p>the <code>for</code> loop doesn't make any sense. Remove it. Then, the <code>while</code> loop never ends as you don't increment <code>i</code>. You need <code>i++;</code> at the end of the <code>while</code> loop.</p>

<p>Here:</p>

<pre><code>        if(letterfreq[i] &gt;= 'a' &amp;&amp; letterfreq[i] &lt;= 'z')
        {
            counter[c]++;
            c++;
        }
</code></pre>

<p><code>counter[c]++</code> won't count the frequency of each character. You need </p>

<pre><code>counter[letterfreq[i]-'a']++;
</code></pre>

<p>for that. <code>c</code> is not needed. Remove it from the function.</p>

<hr>

<p>Also, as <a href=""https://stackoverflow.com/users/1983495/iharob"">@iharob</a> <a href=""https://stackoverflow.com/questions/30214537/its-still-crashing-where-am-i-going-wrong/30214785#comment48533162_30214537"">has mentioned in a comment</a>,</p>

<pre><code> }while(reset == 'y' || 'Y');
</code></pre>

<p>should be</p>

<pre><code> }while(reset == 'y' || reset == 'Y');
</code></pre>

<p><hr>
Fixed program:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

const int COUNT = 27;
const int STRSIZE = 100;

void readString(char letterfreq[], int STRSIZE)
{
    printf(""The capacity of the string array is %d\n"", STRSIZE-1);

    printf(""Please enter your string:\n"");
    fgets(letterfreq, STRSIZE, stdin);

    letterfreq[strlen(letterfreq) - 1] = '\0';

    //return; Not required
}

void lowerCase(char letterfreq[], int STRSIZE)
{
    int i;

    for(i = 0; i &lt; STRSIZE; i++)
    {
        if(letterfreq[i] &gt;= 'A' &amp;&amp; letterfreq[i] &lt;= 'Z')
        {
            letterfreq[i] = letterfreq[i] + 32; //Add instead of subtract
        }
        //i++; You already increment i from the loop
    }


}

void countFreq(int counter[], int COUNT, char letterfreq[], int STRSIZE)
{
    int i=0; // You forgot to initialize i with 0

    while(letterfreq[i] != '\0')
    {   
        if(letterfreq[i] &gt;= 'a' &amp;&amp; letterfreq[i] &lt;= 'z')
        {
            counter[letterfreq[i]-'a']++;
        }
        else if((letterfreq[i] &lt; 'a') || (letterfreq[i] &gt; 'z')) //is always true; Use `else`
        {   
            counter[COUNT-1]++;
        }

        i++; //You forgot this
    }

    //return; Not required
}

void printFreq(int counter[], int COUNT)
{
    int c;

    printf(""Here is the letter frequency of your string:\n"");

    for(c = 0; c &lt; COUNT-1; c++) //See change here too
    {
        printf(""%c \t %d \n"", c + 'a', counter[c]);
    }

    printf(""There were also %d special characters in the string.\n"", counter[26]);

    //return; Not required
}

char promptReset(char reset)
{
    printf(""Would you like to calculate the letter frequency of another string? (Y/N)\n"");
    scanf(""%c%*c"", &amp;reset);

    return(reset);
}

int main()
{
    char letterfreq[STRSIZE];
    char reset = '\0'; //Always initialize variables to prevent unexpected behavior
    int counter[COUNT];


    printf(""Welcome to the Letter Frequency program\n"");

    do
    {
        memset(counter,0,sizeof(counter)); //Initializing counter with zeros
        memset(letterfreq,'\0',sizeof(letterfreq)); //Do the same for letterfreq

        readString(letterfreq, STRSIZE);

        lowerCase(letterfreq, STRSIZE);

        countFreq(counter, COUNT, letterfreq, STRSIZE);

        printFreq(counter, COUNT);

        reset = promptReset(reset);

    }while(reset == 'y' || reset == 'Y'); //Changed

    return(0);
}
</code></pre>
",0
29473791,29473670,2,"<p>When writing the pixel data, this line</p>

<pre><code>myPic-&gt;pixels[i] = malloc(sizeof(Pixel) *myPic-&gt;cols);
</code></pre>

<p><em>overwrites</em> the existing pointer, and makes it point to new (and more importantly, uninitialized) data.</p>

<p>Copy-paste programming (which you seem to have been doing) can work sometimes, but you have to take care to modify the copied code properly.</p>

<hr>

<p>On an unrelated note, you don't print a newline after each line, so the resulting PPM file will actually not be correct.</p>
",1
29475435,29473670,0,"<p>@Joachim is correct. so do something like this:</p>

<pre><code>int i,j;
for(i=0; i&lt;myPic-&gt;rows;++i) {

    Pixel[myPic-&gt;cols] temp = *myPic-&gt;pixels[i];

    //Moves up and down the columns reaching all Pixels
    myPic-&gt;pixels[i] = malloc(sizeof(Pixel) *myPic-&gt;cols);
    //Moves across left to right across all columns
    for (j=0;j&lt;myPic-&gt;cols;++j) {
    //Inverstion requires the actual value to be subtracted from the max
        myPic-&gt;pixels[i][j].red = myPic-&gt;colors - temp[j].red;
        myPic-&gt;pixels[i][j].green = myPic-&gt;colors - temp[j].green;
        myPic-&gt;pixels[i][j].blue = myPic-&gt;colors - temp[j].blue;
        }
    }
    return myPic;
}
</code></pre>
",0
28178854,28178790,9,"<p>It is compiler dependent. Most compilers by default don't generate intermediate pre-processor files.</p>

<p>With <code>gcc</code>, if you add <code>-save-temps</code> option to get the intermediate files, the output of the pre-processor is dumped in a <code>.i</code> file. With <code>-E</code> option (to perform only the pre-processing), without <code>-o</code> to specify the output file, the result is dumped to <code>stdout</code>.</p>
",0
28179782,28178790,2,"<p>In most <em>current</em> compilers (e.g. <a href=""http://gcc.gnu.org/"" rel=""nofollow noreferrer"">GCC</a> or <a href=""http://clang.llvm.org/"" rel=""nofollow noreferrer"">Clang/LLVM</a>) - and for performance reasons - the <a href=""http://en.wikipedia.org/wiki/C_preprocessor"" rel=""nofollow noreferrer"">C/C++ preprocessor</a> is an internal part of the compiler (in GCC it is <a href=""https://gcc.gnu.org/viewcvs/gcc/trunk/libcpp/"" rel=""nofollow noreferrer"">libcpp/</a> and is a library ...), so no preprocessed form is output into a file.</p>
<p>In the very first <a href=""http://en.wikipedia.org/wiki/C_%28programming_language%29"" rel=""nofollow noreferrer"">C</a> or proto-C compilers (1970s PDP-8) the memory was so small (64kilobytes!) that such an organization was not possible, and the preprocessor was a separate program <code>/lib/cpp</code></p>
<p>Today, our laptops have several gigabytes of memory, which is usually much larger than the preprocessed form (of the largest source file you'll feed to your compiler). So current compilers keep some internal representation of the whole <a href=""http://en.wikipedia.org/wiki/Translation_unit_%28programming%29"" rel=""nofollow noreferrer"">translation unit</a> and are able to <a href=""http://en.wikipedia.org/wiki/Optimizing_compiler"" rel=""nofollow noreferrer"">optimize</a> it entirely (<a href=""http://en.wikipedia.org/wiki/Interprocedural_optimization"" rel=""nofollow noreferrer"">inter-procedural optimizations</a>, including inlining).</p>
<p>All compilers keep several forms of the <a href=""http://en.wikipedia.org/wiki/Abstract_syntax_tree"" rel=""nofollow noreferrer"">abstract syntax tree</a> (AST); the bulk of the work of a compiler is not <a href=""http://en.wikipedia.org/wiki/Parsing"" rel=""nofollow noreferrer"">parsing</a> or <a href=""http://en.wikipedia.org/wiki/Code_generation_%28compiler%29"" rel=""nofollow noreferrer"">code generation</a>, but transforming some internal representation of the AST into another internal representation (itself further transformed). In GCC most of the optimizations are working on the <a href=""https://gcc.gnu.org/onlinedocs/gccint/GIMPLE.html"" rel=""nofollow noreferrer"">GIMPLE</a> form. You can extend the compiler by adding your own optimization passes, e.g. with your <a href=""https://gcc.gnu.org/onlinedocs/gccint/Plugins.html"" rel=""nofollow noreferrer"">GCC plugin</a>.</p>
<p>In turn, this technological evolution has fertilized the (evolution of) the definition of our programming languages, recent <a href=""http://en.wikipedia.org/wiki/C%2B%2B11"" rel=""nofollow noreferrer"">C++11</a> is designed for a very optimizing compiler. The recent style guiding or coding hints around C++11 are presupposing (and makes sense only because of) very powerful optimizations.</p>
<p>You still can usually invoke the compiler to spit the preprocessed form, e.g. with <code>gcc -C -E source.c &gt; source.i</code>, in a seperate file (conventionally suffixed <code>.i</code> or <code>.ii</code>, and such suffixes can be known to builder like <code>make</code>)</p>
",0
31235411,31235367,3,"<p>You are invoking undefined behaviour. <code>sizeof</code> yields the size of the argument in <em>bytes</em>/<code>char</code>s, not the <em>length</em> of the array. So you are iterating over more elements than the array actually contains and try to access elements past its bounds.</p>

<p>Use <code>sizeof(options) / sizeof(options[0])</code> to get the length independent from the type of each entry.</p>

<p>Note: Declaring the array <code>static</code> would make its allocation and initialization before <code>main</code> is called. Your current version will do that each time the function is called. While uncritical for <code>main</code>, it will be significant for other functions which are called more than once.</p>
",4
31235464,31235367,0,"<p>To get the number strings in <code>options</code>, you need <code>(sizeof(options)/sizeof(options[0]))</code>, not just <code>sizeof(options)</code>... so your <code>for</code> loop is looping too many times, and you're accessing out of bounds.</p>

<p>Also, your second <code>if</code> never executes because <code>i</code> will never get to <code>sizeof(options)</code>.</p>
",0
32473244,32473032,2,"<p>If your values length is fixed, you may want to specify the lenght of each value you're trying to capture. Ex : </p>

<p><code>sscanf(msg, ""%2d%2d%1d%1d%"", &amp;num[0], &amp;num[1], &amp;num[2], &amp;num[3]);</code></p>
",4
32473424,32473032,0,"<p>It's hard to believe that if you did a printf of x that you'd see 177.  It should be 131249 based on your code.  Try Nicolas' suggestion.  You might also want to initialize your num array, i.e.</p>

<p>int num[10] = {0};</p>
",1
27680845,27680693,1,"<p>This is your code with some changes to make it work (you can improve it)</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

int main(void){

int i;
int bits[16];
int bits_2[16];
int number;
int decimal;
int rest;
int msb;
int result=1;

printf( ""Input number smaller than 65536: "");
scanf(""%d"", &amp;decimal);
if(decimal &gt;= 65536) {
printf( ""\n\nincorrect input!"");
return EXIT_FAILURE;
}

number=decimal;
for(i=0; result!=0; i++){
    result = number / 2; //change this line 
    rest = number %2; // change this line
    number=result; // add this line
    bits[i]=rest;
    msb = i;
 //   return msb; //delete this line
    }

printf(""\n\n %d as binary number : "", decimal); // change this line

for(i=msb; i+1; i--){ // change the condition
   // bits_2[msb-i+1] = bits[msb]; // delete this line
    printf(""%d"", bits[i]);  // change this line 
    }

return 0;
}
</code></pre>
",0
27680880,27680693,1,"<pre><code>result = number = decimal;

for(bits[0]=msb=i=0; result != 0; i++){
    bits[i] = result % 2;
    result = result / 2;

    msb = i;
}

printf(""\n\n %d as binary number : "", number);

for(i=msb; i &gt;= 0; i--){
    bits_2[msb-i] = bits[i];
    printf(""%d"", bits_2[msb-i]);
}
</code></pre>
",0
27680951,27680693,0,"<p>I noticed that you have a lot of <strong>useless</strong> variables so this is a <strong>compact</strong> version of your program:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void){

int i;
int bits[16];
unsigned int decimal;
int rest;
int result=1;

printf( ""Input number smaller than 65536: "");
scanf(""%d"", &amp;decimal);
if(decimal &gt;= 65536) {
printf( ""\n\nincorrect input!"");
return EXIT_FAILURE;
}
else
printf(""\n\n %d as binary number : "", decimal);

for(i=0; result!=0; i++){
    result = decimal / 2;
    rest = decimal %2;
    decimal=result;
    bits[i]=rest;
    }
i--;

for(; i+1; i--){
    printf(""%d"", bits[i]);
    }

return 0;
}
</code></pre>
",0
31538274,31538094,1,"<p>If you have a conditional statement controlling the flow of the execution of this line ... (the line wrapped in a if) ... then there is potentially some branch prediction going on in the CPU running your program. 
Even without branch-prediction issues, the condition has to be tested each time.</p>

<p>If this is about debug prints, change to using pre-processor logic so the statement and surrounding if-branch is never compiled into the resulting executable when you are not debugging.
Something in the lines of:</p>

<pre><code>#ifdef DEBUG
your_statement_here
#endif
</code></pre>

<p>The downside is that you cannot toggle debugging on and off during runtime, but you wanted performance, right? :)</p>
",0
27123640,27118855,0,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int *f(const char *s, int *n /* out */){
    if(strncmp(s, ""* SEARCH"", 8)!=0){
        fprintf(stderr, ""format error!\n"");
        *n = 0;
        return NULL;
    }
    s += 8;
    const char *p = s;
    int v, len, status;
    int count = 0;
    while((status=sscanf(p, ""%d%n"", &amp;v, &amp;len))==1){
        ++count;
        p +=len;
    }
    if(status==0){
        fprintf(stderr, ""format error!\n"");
        *n = 0;
        return NULL;
    }
    int *ret = malloc(count * sizeof(*ret));
    p = s;
    count = 0;
    while(EOF!=sscanf(p, ""%d%n"", &amp;v, &amp;len)){
        ret[count++]=v;
        p +=len;
    }
    *n = count;
    return ret;
}

int main (void){
    int i, n, *nums = f(""* SEARCH 1 2 3"", &amp;n);

    for(i=0; i&lt;n; ++i)
        printf(""%d "", nums[i]);
    printf(""\n"");
    free(nums);
    return 0;
}
</code></pre>
",0
30698617,30698589,2,"<p>You are getting confused between compiling and running code.</p>

<p>Your code is compiled first when you build it so it understands what printName is then. Later you run the code that then runs the command called ""printName"". So it already ""knows"" what it is from when you compiled it.</p>
",0
30698656,30698589,2,"<p>the program is not ""executed"" so to speak in the language you wrote it in. Technically speaking, the only real execution language is binary, the computer chips dont understand code, they only understand on or off.</p>

<p>When you write your code, it is compiled into lower level languages like assembly, and eventually to binary. All the connections you make in your code are created at that time, before execution.</p>
",0
30698671,30698589,2,"<p>Remember that programming languages are there to make our lives easier; writing binary machine code (1's and 0's) is a pain, so languages let us express ourselves more concisely.</p>

<p>Some languages are interpreted (goes through line by line, roughly speaking), some are statically compiled (a compiler goes through all the code and generates an executable when it's done), and some do something else entirely.</p>

<p>C is statically compiled.</p>

<pre><code>void PrintName(string name);
</code></pre>

<p>This is a function declaration. This tells the compiler ""a function called <code>PrintName</code> that takes a <code>string</code> argument exists"".</p>

<p>So when your program is being compiled and the identifier <code>PrintName</code> is hit, the compiler knows about it, can check you're giving it a string (amongst other things) and carries on happily.</p>

<p>The compiler later comes across the definition of <code>PrintName</code> and uses that to generate the executable.</p>

<p>If you declare a function, but do not define it, you'll later get an error along the lines of <code>undefined reference to MyFunction</code>, which is saying ""you told me this function definition existed somewhere, but I can't find it"".</p>
",0
30698733,30698589,1,"<p>C programs are compiled before you're able to run them. This includes reading <em>all</em> of the sources and building a graph with all functions and entry points. In general, it is possible to call or otherwise use a function defined anywhere, but in C you should declare a <em>forward</em> prototype if your callee function is defined below the place it is used.</p>

<p>So, C programs are not executed line-by-line.</p>

<p>Some scripting languages have a notion of sml line-by-line execution, but mainly it is really statement-by-statement. I.e. an <code>if</code> line cannot be executed at all, because it only controls the program flow. So, interpreter must read the entire body of the statement (see below) before it is able to correctly execute them.</p>

<pre><code>if (condition) {
    ...
} &lt;- here it starts executing the entire sentence

function foo(bar) {
    while (true) {
        bar = bar - bar
    } &lt;- not here!
} &lt;- last brace closed, statement is complete
</code></pre>
",0
30184077,30184010,4,"<p>You're missing a semicolon on line 29.</p>

<pre><code>void swap_2(int *x, int *y)
{
    int temp;

    temp = *x;
    *x = *y  &lt;----------- missing semicolon
    *y = temp;      **//LINE 30**
}
</code></pre>
",0
30184135,30184010,1,"<pre><code>void swap_2(int *x, int *y)
{
    int temp;

    temp = *x;
    *x = *y
    *y = temp;      **//LINE 30**
}
</code></pre>

<p>You have a missing colon at the end of line 29""</p>

<p>Try:</p>

<pre><code>*x = *y;
</code></pre>
",1
31297739,30818722,0,"<p>The biggest conceptual or mathematical error (apart from the programming errors explained in the other answer) is that you use integers for the arguments in the value function. It is rarely the case that random polynomials have integer roots. Rename <code>n</code> to <code>x</code> for intuitive readability and set the type of <code>x</code> to float.</p>

<p>Check again your assignment, if the prototype is really <code>value(p,n,a)</code>, then maybe the intention is that <code>n</code> is the degree and <code>a</code> the evalution point, thus the signature should be <code>(*float,int,float)</code>.</p>

<hr>

<p>Using this signature, you should really use the Horner scheme to evaluate densely coded polynomials</p>

<pre><code>float value(float *p, int deg, float a) {
    int i;
    float val = p[deg];
    for(i=deg; i-- &gt; 0; ) val = val*a+p[i];
    return val;
}
</code></pre>

<p>and use descriptive names for variables in the bisection method (instead of <code>j,k,l</code> usually associated to integers) to avoid mixing them up</p>

<pre><code>float left=a, right = a+1, mid =(left+right)/2;
</code></pre>

<p>etc.</p>
",0
32446542,32445882,1,"<p>With an input of ""70.0""  the result is 4524.369754... which displays as ""4524.370"" - What OP gets.</p>

<p>With an input of ""69.999975""  the result is 4524.369002... which displays as ""4524.369"" - what OP wants.</p>

<p>If OP expects ""70.0"" to result in ""4524.369"", then some minor adjustment to the formula is needed.  The precision of <code>double</code> is at least 10 significant digits and often is 15+.  Even doing this in <code>float</code> then <code>f(70.0)--&gt; 4524.370</code>.  </p>

<p>Else OP has the wrong expectation.</p>

<hr>

<p>Response to OP's <a href=""https://stackoverflow.com/questions/32445882/how-to-stop-rounding-decimals-with-double-in-c#comment52756419_32445882"">comment</a>:</p>

<p>""to shorten the decimal place to 3 spots without rounding"".  Hmmm seems strange to want this:</p>

<pre><code>// properly rounded result    
printf(""%.3lf\n"", v);
// shorten to 3 places without rounding
double v3 = floor(v*1000.0)/1000.0;
printf(""%.3lf\n"", v3);
</code></pre>
",0
28503183,28502808,2,"<p><code>j</code> contains 0 when entering the first <code>for</code> loop. It becomes 4 when exiting the <code>while</code> loop as only then will the condition <code>a[i] != b[j]</code> be false.</p>

<p>Then, in the next iteration of the first <code>for</code> loop, <code>j</code> gets incremented and you try to read past the array (<code>b[5]</code>,<code>b[6]</code> etc) and this invokes <a href=""http://en.m.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow"">Undefined Behavior</a> which means that anything can happen.</p>

<p>The reason that it worked perfectly is by pure luck. But you cannot rely on this.</p>
",0
28503187,28502808,1,"<p>If you print the <em>address</em> of the array elements whose <em>values</em> match, you can see the truth of @Marian's comment, that <code>j</code> indexes the same array as <code>i</code> does, after the first match.</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    int a[5] = {5, 2, 1, 6, 3}, b[5] = {1, 6, 3, 2, 5}, c[10], i = 0, j = 0, k = 0;
    for (i = 0 ; i &lt; 5 ; i++)
    {
        while (a[i] != b[j])
            j++;
        printf (""%p %p\n"", (void*)&amp;a[i], (void*)&amp;b[j]);   // added a cue
        c[k]   = a[i];
        c[k+1] = b[j];
        k      = k + 2;
    }
    for (i = 0 ; i &lt; 10 ; i += 2)
        printf(""%d-&gt;%d\n"", c[i], c[i + 1]);
    getch();
}
</code></pre>

<p>Program output</p>

<pre><code>0018FF2C 0018FF24
0018FF30 0018FF30
0018FF34 0018FF34
0018FF38 0018FF38
0018FF3C 0018FF3C
5-&gt;5
2-&gt;2
1-&gt;1
6-&gt;6
3-&gt;3
</code></pre>
",1
32419120,32418977,0,"<p>You know every row has the same number of chars, counting the spaces and #, which is n. In the first row you have only one #, so n - 1 spaces, on the second you have 2 #'s, so n - 2 spaces, and so on. So you iterate from 0 to n - 1, and print a char every iteration, and you just have to keep count of how many chars you've already print. Start printing spaces and as soon as you have printed enough spaces, print a #. Code for it:</p>

<pre><code>for (int i = 0 ; i &lt; n ; i++) 
{
    int j = 0;
    while (j &lt; n)
    {
        if (j &lt; n - i - 1)
             printf("" "");
        else
             printf(""#"");
        j++;
    }
    printf(""\n"");
}
</code></pre>
",0
32419449,32418977,1,"<p>First, the problem with the code. It is based on an incorrect understanding of <code>printf</code>. <code>printf</code> cannot be used in the way desired in the code. Furthermore, even if did, it wont be printing spaces 'gradually' because you have fixed 'n-1'. You probably meant 'n-i' so it can gradually shrink.</p>

<p>Anyways, to fix:
There are a number of solutions, including rewriting with new logic. For your homework though, the code can still be 'fixed' by writing your own printf variant with desired functionality. e.g:</p>

<pre><code>void mprintf(const char *fmt, int n, char c)
{
    while (n--)
   {
       printf(""%c"", c);
    }
 }
</code></pre>

<p>And your code becomes:</p>

<pre><code>for (int i = 0 ; i &lt; n ; i++)
{
    mprintf(""%c"",n-i,' ');  // printing the blank spaces gradually
    mprintf(""%c"",i,'#'); // printing the hashes gradually
    printf(""\n"");
}
</code></pre>

<p>Extra credit:
Find out how you can simplify this code by removing certain useless thing.</p>
",0
32421112,32418977,0,"<p>You say:</p>

<blockquote>
  <p>Please consider helping me by saying what is wrong with my code, not giving me an actual new working one.</p>
</blockquote>

<p>Ignoring cosmetic changes, your loop body is currently:</p>

<pre><code>for (int i = 0; i &lt; n; i++) 
{
    printf(""%c"", n-1, ' ');    // printing the blank spaces gradually
    printf(""%c\n"", i+2, '#');  // printing the hashes gradually
}
</code></pre>

<p>Problems include:</p>

<ul>
<li>Too many arguments to the <code>printf()</code> calls.</li>
<li><code>%c</code> requires a single argument, which is the character to be printed.</li>
<li>For <code>n = 6</code>, you will be printing <kbd>Control-E</kbd> rather than any blanks with the first print.</li>
<li>For the second print, you'll be printing <kbd>Control-B</kbd> through <kbd>Control-G</kbd> and no hashes.</li>
</ul>

<p>You could use:</p>

<pre><code>printf(""%.*s"", n - i - 1, "" "");
</code></pre>

<p>to print a field of blanks of the appropriate width.  You can't repeat a single character with <code>printf()</code>, though, so you'd have to use some other technique, such as a loop using <code>putchar()</code>, to print the appropriate number of hashes.</p>

<p>You should read, and re-read, and re-re-read the specification for <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/printf.html"" rel=""nofollow""><code>printf()</code></a>.  I have to read it a couple of times a year to try and keep current; I usually find something new (or forgotten) on a given re-reading.  Of course, I've only been coding in C for 30 years, and the specification has changed a few times over the years (and it hasn't gotten any simpler yet!), so it isn't very surprising.</p>
",0
29486314,29486269,1,"<p><code>*string</code> is  point out the single character.Here <code>""abc""</code> is string literal. It is not a character. </p>

<pre><code>*string='a'; // It will work.
</code></pre>

<p><a href=""https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc"">Don't cast</a> the result of malloc and its family.</p>

<p>You can use the <code>strcpy</code> function to do this.</p>

<pre><code>strcpy(string,""abc"");
</code></pre>
",0
29486674,29486269,2,"<p>Why <code>*string = ""abc""</code> is not working?</p>

<p><code>string</code> is defined as pointer to char. <code>*string</code> is a char. <code>""abc""</code> is a string literal. You are actually assigning address of string literal to char and compiler should issue warning like:</p>

<pre><code>warning: assignment makes integer from pointer without a cast
</code></pre>

<p>For example, <code>*string = 'a';</code> will work because just one char is assigned.</p>

<p>How <code>string = ""abc""</code> is working?</p>

<p>Because address of string literal <code>""abc""</code> is assigned to <code>string</code> which is a pointer to char.</p>

<p>And BTW, doing that you lost previously allocated memory by <code>malloc()</code> and produced memory leak.</p>

<p>How to store a string into a char pointer? You can use just:</p>

<pre><code>strcpy(string, ""abc"");
</code></pre>
",2
30401848,30401784,3,"<p>I think, you need to change</p>

<pre><code>printf(""%d\n"", prices+item);
</code></pre>

<p>to</p>

<pre><code>printf(""%d\n"", *(prices+item) );
</code></pre>

<p>as <code>%d</code> expects an <code>int</code> argument. To print a pointer you need to use <code>%p</code>.</p>

<p>That said, using the <code>argv[n]</code> directly without checking for <code>argc</code> can lead to erratic behavior causing segmentation fault, if command line args are not supplied properly.</p>

<hr>

<p><strong>EDIT:</strong></p>

<p>The problem here is, you're returning the address of a automatic local variable (array) <code>prices</code> from <code>displayProducts()</code>. Using the return value will result in <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow"">undefined behaviour</a>.</p>
",3
29143531,29143338,1,"<p>Change to:</p>

<pre><code>else { 
  puts( ""Enter the account, name, and balance."" );
  puts( ""Enter to end input."" );

  // write account, name and balance into file with fprintf
  while (scanf( ""%d%29s%lf"", &amp;account, name, &amp;balance)==3)
  { 
     fprintf( cfPtr, ""%d %s %.2f\n"", account, name, balance );
     printf( ""%s"", ""? "" );
  }
  fclose( cfPtr ); // fclose closes file   
} // end else
</code></pre>
",1
29144050,29143338,4,"<p>the point is that the EOF test must always follow the scanf(), and be before printing the read information.</p>

<p>The if-else condition is just for handling the eventual open error condition, so how you have modified the code is not totally clear. However people often try to do:</p>

<pre><code>  while ( !feof( stdin ) ) { 
     scanf( ""%d%29s%lf"", &amp;account, name, &amp;balance );
     fprintf( cfPtr, ""%d %s %.2f\n"", account, name, balance );
     printf( ""%s"", ""? "" );
  }
</code></pre>

<p>and this is wrong because when reading the last data it will not ""read the EOF"" (EOF is the condition you met <em>after</em> you have finished reading data): only the subsequent <code>scanf()</code> will do, and the output functions will print wrong data (the previous ones, not overwritten because of the input error, that's why the last line is repeated).</p>

<p>For example this is correct:</p>

<pre><code>  for ( ;; ) { 
     scanf( ""%d%29s%lf"", &amp;account, name, &amp;balance );
     if (feof( stdin )) break;
     fprintf( cfPtr, ""%d %s %.2f\n"", account, name, balance );
     printf( ""%s"", ""? "" );
  }
</code></pre>

<p>And actually I prefer it over repeating the same <code>scanf()</code> line twice as suggested by Deitel. </p>
",0
29184401,29184185,0,"<p>You don't need to allocate n + 1 positions (that is horrible :P)</p>

<p>Here you have an example i found in the internet that can be useful for you using the heap sort algorithm.</p>

<pre><code>/*
 * C Program to sort an array based on heap sort algorithm(MAX heap)
 */ 
#include &lt;stdio.h&gt;

int main()
{
    int heap[10], no, i, j, c, root, temp;

    printf(""\n Enter no of elements :"");
    scanf(""%d"", &amp;no);
    printf(""\n Enter the nos : "");
    for (i = 0; i &lt; no; i++)
       scanf(""%d"", &amp;heap[i]);
    for (i = 1; i &lt; no; i++)
    {
        c = i;
        do
        {
            root = (c - 1) / 2;             
            if (heap[root] &lt; heap[c])   /* to create MAX heap array */
            {
                temp = heap[root];
                heap[root] = heap[c];
                heap[c] = temp;
            }
            c = root;
        } while (c != 0);
    }

    printf(""Heap array : "");
    for (i = 0; i &lt; no; i++)
        printf(""%d\t "", heap[i]);
    for (j = no - 1; j &gt;= 0; j--)
    {
        temp = heap[0];
        heap[0] = heap[j];    /* swap max element with rightmost leaf element */
        heap[j] = temp;
        root = 0;
        do 
        {
            c = 2 * root + 1;    /* left node of root element */
            if ((heap[c] &lt; heap[c + 1]) &amp;&amp; c &lt; j-1)
                c++;
            if (heap[root]&lt;heap[c] &amp;&amp; c&lt;j)    /* again rearrange to max heap array */
            {
                temp = heap[root];
                heap[root] = heap[c];
                heap[c] = temp;
            }
            root = c;
        } while (c &lt; j);
    } 
    printf(""\n The sorted array is : "");
    for (i = 0; i &lt; no; i++)
       printf(""\t %d"", heap[i]);
    printf(""\n Complexity : \n Best case = Avg case = Worst case = O(n logn)\n"");

    return 0;
}
</code></pre>

<p>Source: <a href=""http://www.sanfoundry.com/c-program-heap-sort-algorithm/"" rel=""nofollow"">http://www.sanfoundry.com/c-program-heap-sort-algorithm/</a></p>

<p>Hope this helps.</p>
",5
32428551,32428518,0,"<p>By using</p>

<pre><code>printf(""%d"", '\t');
</code></pre>

<p>for example, which prints</p>

<pre><code>9
</code></pre>

<p>In this example, the apparent <code>char</code> type is actually defining an <code>int</code>.</p>
",0
32428561,32428518,0,"<p>Did you manage to print the values of 'normal' characters? If so, printing the special characters would work the same. </p>

<p>For instance, printing <code>""A\tB\n""</code> would result in <code>65 9 66 10</code> if you just process the characters in the string one by one. The escaping is merely done so you can use these special characters in a string in source code. As soon as the code is compiled, the characters are un-escaped.</p>
",0
29186526,29186314,0,"<p>How about</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;

char *
addspaces (const char *src)
{
  /* first find the length of the required string */
  int l = 1;                    /* to allow for terminating NUL */
  const char *s;
  char *dest;
  char *d;

  for (s = src; *s; s++, l++)
    if (isupper (*s))
      l++;

  /* now allocate memory for the string */
  dest = malloc (l);
  if (!dest)
    return NULL;

  /* now copy the original string into the buffer */
  for (s = src, d = dest; *s;)
    {
      if (isupper (*s))
        *d++ = ' ';
      *d++ = *s++;
    }
  *d = 0;
  return dest;
}

int
main (int argc, char **argv)
{
  char *test = ""AddSpacesToThisString"";
  char *out = addspaces (test);
  printf (""Result: %s\n"", out);
  free (out);
  exit (0);
}
</code></pre>

<p>You can see it working here: <a href=""http://ideone.com/eKMIV0"" rel=""nofollow"">http://ideone.com/eKMIV0</a></p>

<p>This has the advantage of dynamically allocating the return buffer, rather than relying on a fixed length string.</p>
",1
29186386,29186314,1,"<p>To see why this wouldn't work try running your code with a pencil on a piece of paper. When you see a capital letter, all you do is skipping the index. Moreover, you never do any copying (and you do need to copy, because the letters after the capital ones need to move).</p>

<p>To figure out what to do, think of doing the move from the back: walk the indexes down from the end, inserting a space <em>after</em> each capital letter that you encounter.</p>

<p>There is only one wrinkle to this - knowing where the updated string ends. That's easy to compute, though, if you add the number of capital letters to the length of the string.</p>

<p>Of course you need to be sure that the updated string is going to fit in the space of the old string.</p>

<pre><code>char str[100];
scanf(""%50s"", str);
int len = strlen(str);
if (len == 0) return; // Stop if the string is empty.
for (int i = 1 ; str[i] != '\0' ; i++) {
    if (str[i] &gt;= 'A' &amp;&amp; str[i] &lt;= 'Z')
        len++;
}
int pos = strlen(str);
while (pos &gt; 0) {
    str[len] = str[pos--];
    if (str[len] &gt;= 'A' &amp;&amp; str[len] &lt;= 'Z') {
        str[--len] = ' ';
    }
    len--;
}
printf(""%s\n"", str);
</code></pre>

<p><a href=""http://ideone.com/uIl8IE"" rel=""nofollow"">Demo.</a></p>
",5
30157746,30157723,4,"<p>You should replace this definition line in the header</p>

<pre><code>struct Student a = {""John"", ""Jackson""};
</code></pre>

<p>with this declaration:</p>

<pre><code>extern struct Student a;
</code></pre>

<p>This declares a global variable of type <code>struct Student</code>.</p>

<p>Move the definition into one of the C files to complete the fix:</p>

<pre><code>// This goes into one of the C files, does not matter which one.
struct Student a = {""John"", ""Jackson""};
</code></pre>
",1
30157790,30157723,0,"<p>Do not have definitions in a header file. These are solely meant to hold the declaration. The definition has to go into an implementation file (<code>*.c</code>). Think of the header file like the interface.</p>

<p>Disclaimer: I very well know ther might be exceptions to this rule. Also <code>typedef</code> is actually a definition, but one could just see it as an alias for the actual declaration (this is different from C++, btw).</p>
",0
33598671,33598638,2,"<p>Should be:</p>

<pre><code>#include&lt;stdio.h&gt;
int main() {

int i, j, n;
scanf(""%d"",&amp;n);
for (i=0;i&lt;=n;i++){
    for (j=0;j&lt;=i;j++){
        printf(""*"");
    }
    printf(""\n"");
}
return 0;
}
</code></pre>

<p>You forgot to tell scanf you were reading in an integer by using the %d argument</p>
",2
33599086,33598638,1,"<p>There is mistake in </p>

<blockquote>
  <p>scanf(""%"",&amp;n);</p>
</blockquote>

<p>it will be: </p>

<blockquote>
  <p>scanf(""%d"",&amp;n);</p>
</blockquote>

<p>to tell the complier that the value of n is an integer type.</p>
",0
33826598,33826412,7,"<p>A typical <code>float</code> (IEEE754 32 bit) will only be accurate to about 7 significant digits. You exceed that.</p>

<p>A solution? Use a <code>double</code> instead. That will give you about 15 significant figures. But note that the result may well still not be <em>exact</em>. That's the nature of floating point arithmetic.</p>

<p>A decent solution? Use a <code>stuct</code> instead containing the time values. There's one called <code>tm</code> in <code>&lt;time.h&gt;</code>. </p>
",0
33826608,33826412,2,"<p>Your problem lies with the lack of precision in the 32 bit <code>float</code> type. Use type <code>double</code> instead for the time variable. It has the precision you require.</p>
",0
32410609,32410248,0,"<p>example like this:</p>

<pre><code>while(fgets(buffer, 80, fp) != NULL)
{
    char ch, cx = 0;
    double n;

    if(sscanf(buffer, ""%c %c"", &amp;ch, &amp;cx) == 1){
        if(ch == '/'){
            puts(""/"");
        } else if(ch == '*'){
            puts(""*"");
        }
    } else if(sscanf(buffer, ""%lf %c"", &amp;n, &amp;cx) == 1){
        puts(""number"");
    } else {//Check further limiting condition?
        puts(""string"");
    }
    memset(buffer, 0, 80);
}
</code></pre>
",0
32410708,32410248,0,"<p>You are thinking correctly. The key to any of these type problems is to read the line into the buffer, as you have done. Then you have to make sense of what's in the buffer. Generally, most decisions can be made on the first character in the buffer (e.g. <code>+,-,/,*,...</code>). </p>

<p>There are other situations where you will need to process the line further after you have passed your initial test (e.g. <code>isdigit()</code>, or <code>isalpha()</code> (which can be reduced to simple character comparisons to avoid the function calls).</p>

<p>The simple way to handle both, is to simply assign a pointer to the buffer, and then work through the buffer using the pointer to test, extract, or pass, the needed element(s) to your handling function.</p>

<p>Now the next challenge is loop control. Some tests my need the entire string, some may only care about the first <code>char</code>. An approach something like the following will allow you to handle any line in a graceful manner to get the information you need:</p>

<pre><code>while(fgets(buffer, 80, fp) != NULL)
{
    char *p = buffer;
    while (*p)
    {
        if(/)
        {
            //do something for ""/"" character
        }
        if(*)
        {
            //do something for ""*"" character
        }
        if(('A' &lt;= *p &amp;&amp; *p &lt;= 'Z') || ('a' &lt;= *p &amp;&amp; *p &lt;= 'z'))
        {
            // do something for string
            // handle initial char
            while (*p) {
                // handle rest of string;
                p++;
            }
            if (!*p)
                goto nextline;
        }
        if('1' &lt;= *p &amp;&amp; '9' &lt;= *p)
        {
            // do something for numbers
            convert numbers with atoi() or strtol(), ....
            if (endofline)
                goto nextline;
        }
        p++;
    }
    nextline:;
    //memset(buffer, 0, 80); /* not needed */
}
</code></pre>

<p>There are more varied and different ways to do this than you can swing a dead cat at. It's up to you to choose the method of program control that fits your data. Let me know if you have questions.</p>
",6
31291262,31291181,3,"<p>That is called <a href=""https://www.google.se/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=2&amp;cad=rja&amp;uact=8&amp;ved=0CCgQFjAB&amp;url=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FCall_graph&amp;ei=4widVaDcBYKlNu7Lr5AK&amp;usg=AFQjCNHbVfQGUWqdGUurRN6Od5NxMhffbg&amp;sig2=lkRt3kj-F7efirwA8SeLsw&amp;bvm=bv.96952980,d.eXY"" rel=""nofollow noreferrer"">the call graph</a>.</p>

<p>That would require either:</p>

<ul>
<li>Instrumentation, i.e. adding code into each function to record when entering/leaving it</li>
<li>Profiling, i.e. sampling the program's state and recording which functions are detected</li>
<li>Emulation, i.e. running the program on a fake/virtual CPU and recording when jumps occur</li>
</ul>

<p>Of the above, only the first one would provide 100% accuracy, and of course in general its very hard to do since you often use libraries and those wouldn't be instrumented even  if you got your own code to be.</p>

<p>The reason this is hard is that the stack frame ""history"" isn't normally recorded; once the program has stopped running there is no current stack frame to inspect, unlike when breaking in a debugger.</p>

<p>See also <a href=""https://stackoverflow.com/questions/517589/tools-to-get-a-pictorial-function-call-graph-of-code"">this question</a>.</p>
",3
31292022,31291181,0,"<p>If your OS provides <code>dtrace</code>, you can use the <a href=""https://wikis.oracle.com/display/DTrace/pid+Provider"" rel=""nofollow noreferrer"">PID provider</a>:</p>
<blockquote>
<p><strong>pid Provider</strong></p>
<p>The pid provider allows for tracing of the entry and return of any function in a user process ...</p>
</blockquote>
",0
29237741,29237581,3,"<p>You allocate memory to hold the cell pointers:</p>

<pre><code>returnField-&gt;cells = malloc(ysize * sizeof(State *));
</code></pre>

<p>But you never free that memory. You do free the individual cells, but never the cell pointer itself:</p>

<pre><code>    if (returnField-&gt;cells[j] == NULL) {
        for (i = 0; i &lt; j; i++) {
            free(returnField-&gt;cells[i]);
        }
        free(returnField-&gt;cells);
        // ^^ This was missing
        free(returnField);
        return NULL;
    }
</code></pre>

<p>The same problem appears in your <code>releaseField()</code> implementation. I'd even suggest making it <em>robust</em> against partial allocation:</p>

<pre><code>/* Free memory allocated for field &lt;f&gt;.
 */
void releaseField(Field *f)
{
    unsigned int j;
    if (f != NULL) {
       if (f-&gt;cells != NULL) {
           for (j = 0; j &lt; f-&gt;ysize; j++) {
               free(f-&gt;cells[j]);
           }
       }
       // free cell pointer array memory, too
       free(f-&gt;cells);
       free(f);
    }
}
</code></pre>

<p>Also replace <code>returnField-&gt;cells = malloc(ysize * sizeof(State *));</code> by</p>

<pre><code>returnField-&gt;cells = calloc(ysize, sizeof(State *));
</code></pre>

<p>Do the same thing when allocating the <code>returnField</code> struct itself and you can even use <code>releaseField()</code> for partially allocated fields and thus avoid code duplication:</p>

<pre><code>returnField = calloc(1, sizeof(Field));
</code></pre>

<p>This way, you should be able to simply call <code>releaseField()</code> even when you only have a partially allocacted field structure.</p>
",3
29237753,29237581,2,"<p>This might not be the real problem but you are not deallocating the memory allocated for <code>cells</code> in this block.</p>

<pre><code>    if (returnField-&gt;cells[j] == NULL) {
        for (i = 0; i &lt; j; i++) {
            free(returnField-&gt;cells[i]);
        }

        // Need to deallocate returnField-&gt;cells
        // Add the following line.
        free(returnField-&gt;cells);

        free(returnField);
        return NULL;
    }
</code></pre>
",1
31156462,31156400,4,"<p>Use the <code>rename()</code> function.</p>

<pre><code>#include &lt;stdio.h&gt;
int rename(const char *old, const char *new);
</code></pre>

<blockquote>
  <p>Description</p>
  
  <p>The rename function causes the file whose name is the string pointed to by old to be
  henceforth known by the name given by the string pointed to by new. The file named
  old is no longer accessible by that name. If a file named by the string pointed to by new
  exists prior to the call to the rename function, the behavior is implementation-defined.</p>
  
  <p>The rename function returns zero if the operation succeeds, nonzero if it fails, in
  which case if the file existed previously it is still known by its original name.</p>
</blockquote>
",3
34212193,34211985,1,"<p>You're using <code>sizeof(buffer)</code> in the call to <code>fread</code> but it's not doing what you think.  Look at how you pass <code>buffer</code> into <code>readFile</code>:</p>

<pre><code>int readFile( FILE *streamf, char buffer[] );
</code></pre>

<p>This means that <code>buffer</code> is just a pointer, and so <code>sizeof(buffer)</code> will be equal to <code>sizeof(char*)</code>.  It's a classic mistake people make with <code>sizeof</code> so this is a rite of passage for you.</p>

<p>You will need to actually pass in a size to your function, or redefine it to accept <code>char buffer[1000]</code>.  I would pass a size explicitly though:</p>

<pre><code>int readFile( FILE *streamf, char buffer[], size_t buffer_size );
</code></pre>

<p>Also, as appeared in the comments, you are using <code>fseek</code> incorrectly.  You need to use an offset of <code>0</code> with both <code>SEEK_SET</code> and <code>SEEK_END</code>.</p>
",0
31171485,31171241,0,"<p>As I and others mentioned, you need to allocate at least one more byte to your string.  But I would also recommend replacing your for loop (%c) with a simple call to <code>snprintf()</code>.  That will let you specify the 16 bytes you want from <code>buf</code>.</p>
",0
31171490,31171241,0,"<p>You need a nul character (<code>'\0'</code>) at the end of your string if you want to use it with standard C string functions.</p>

<p>Arrays in C don't have any length information associated with them, so in order for <code>printf</code> to know when it's reached the end of a string it needs some sort of marker.  The nul character is used for this (also by all other string related functions like <code>strlen</code>, <code>strcpy</code>, etc.).</p>
",0
31171509,31171241,0,"<p>You're using the <code>layout</code> field as an array of characters, but you're trying to print it as a string.  In C a string is a NULL terminated array of characters.  Since your array doesn't have a NULL terminator, <code>printf</code> keeps looking until it finds a 0 byte, which it ends up finding in the <code>arrowClr</code> field which is laid out next in memory.  That's why it's printing out the number.</p>

<p>You need to either make <code>layout</code> one character bigger, i.e. <code>char layout[17]</code>, and set <code>layout[16] = 0</code>, or you would need to run <code>printf</code> in a loop to print each character individually.  I'd recommend the former.</p>

<p>To get the numerical values of the last two characters, you need to do this:</p>

<pre><code>tiles[i].arrowClr = buf[16] - '0';
tiles[i].spPlacing = buf[17] - '0';
</code></pre>
",1
31171410,31171241,0,"<ol>
<li>You are not null terminating the layout string. If this string is has
16 characters, add one to the layout array for the null. <code>layout[16]
= '\0'</code></li>
<li>You need to convert ASCII strings to numbers if that is your intent. <code>arrowClr = buf[16] - '0';</code> </li>
</ol>
",2
31171437,31171241,0,"<p>In this line</p>

<pre><code>printf(""%s\n"",tiles[i].layout);
</code></pre>

<p>there is expected to be a string terminator <code>'\0'</code> at the end of the string. But you didn't put one. You built the string like this</p>

<pre><code>for (int e=0;e&lt;16;e++) {
    sprintf(&amp;tiles[i].layout[e],""%c"",buf[e]);
    ...
</code></pre>

<p>Your struct definition needs an extra char length</p>

<pre><code>char layout[17];        // &lt;--- 16 to 17
</code></pre>

<p>and then after copying chars from the file, you need</p>

<pre><code>tiles[i].layout[16] = '\0';
</code></pre>

<p>to terminate the string so you can print it.</p>

<p>Then, the last two fields which you obtain with</p>

<pre><code>tiles[i].arrowClr = buf[16];
tiles[i].spPlacing = buf[17];
</code></pre>

<p>should be like this, to convert the single digit ASCII value to an <code>int</code> type</p>

<pre><code>tiles[i].arrowClr = buf[16] - '0';
tiles[i].spPlacing = buf[17] - '0';
</code></pre>

<p>asuming that you intended the read value to be the number <code>1</code> or <code>2</code> and not the character <code>'1'</code> or <code>'2'</code>.</p>
",0
31896613,31895971,0,"<p>The problem with floating point numbers is that they're not completely accurate. If you try dividing 10 by 9 in the decimal system, you'll end up with a value that has an infinite number of 1s. A floating point number has the same issue (except that your computer works in base 2 rather than 10, but that's really a detail). Since you can't describe an infinite number of ones to a computer, that means you'll have some rounding in your result. As such, if you do a complex calculation that involves more than one operation your 'integer' isn't going to be one in some cases, even though if you were to calculate it by hand it would be.</p>

<p>If what you're trying to do is figure out whether the result of a particular calculation on an floating point value yields an integer value, a better approach is to do a check with the reverted algorithm on a rounded value; that is, in this case, perform the <code>log()</code> of the input, round the result, and feed it to the <code>pow()</code> function with the appropriate arguments. If the result of that <code>pow()</code> is your input again, you're good.</p>
",1
31896621,31895971,0,"<p>You can check the modulus of 1.</p>

<pre><code>while( fmod(i,1) != 0)
</code></pre>

<p>Or rather with thresholds</p>

<pre><code>int is_integer(double d, double threshold)
{
    return d &lt; threshold &amp;&amp; d &gt; -threshold;
}
</code></pre>

<p>Example how to call</p>

<pre><code>while(!is_integer(x, 1e-6))
</code></pre>
",0
31896749,31895971,3,"<blockquote>
  <p>... to check if the value stored in a float type variable is actually an integer ...</p>
</blockquote>

<p>Use 2 tests.</p>

<p>1) Test if <code>float value</code> has an fractional part:  ""The <code>modf</code> functions break the argument value into integral and fractional parts, each of which has the same type and sign as the argument.""  This is sufficient to test if the a floating point value is a whole number.  Note: use <code>modf()</code> for <code>double</code></p>

<pre><code>    #include &lt;math.h&gt;
    float ipart;
    float frac = modff(value, &amp;ipart);
    if (!(frac == 0.0f)) puts(""Not a whole number"").
</code></pre>

<p>2) If also converting to an integer type, test if the <code>value</code> is in range of the desired type before converting:</p>

<pre><code>    #include &lt;limits.h&gt;
    if (value &lt; INT_MIN*1.0 || value &gt; INT_MAX*1.0) puts(""Outside `int` range"").
    int y = (int) value;
</code></pre>
",0
31895984,31895971,-5,"<pre><code>int n;
scanf(""%d"", &amp;n);
double i = log(n);
while( i-int(i) !=0 )
{
    printf(""\n Enter another number"");
    scanf(""%d"", &amp;n);
    i = log(n);
}
return 0;
</code></pre>
",2
31896073,31895971,-2,"<p>Check if the value not <a href=""http://www.java2s.com/Code/C/math.h/isfinite.htm"" rel=""nofollow"">isfinite</a> or the difference between it and its cast to long is different than zero.<br>
This does not work for doubles with a value too large as it is not representable as a long. But all finite double values greater than 2^52 or lower than -(2^52) are always integer so there is no need to check those.</p>

<pre><code>!isfinite(i) || (i&gt;-4503599627370496.0 &amp;&amp; i&lt;4503599627370496.0 &amp;&amp; ((long)i)-i != 0 )
</code></pre>

<p>Previous expresion returns true if <code>i</code> is not an integer.</p>

<p>This only works for an architecture where <code>long</code> is at least 53 bits long though.</p>

<p>For compilers supporting <code>long long</code> that is a type guaranteed to have at least 64 bits so this would work regardless of architecture :</p>

<pre><code>!isfinite(i) || (i&gt;-4503599627370496.0 &amp;&amp; i&lt;4503599627370496.0 &amp;&amp; ((long long)i)-i != 0 )
</code></pre>
",4
31896888,31895971,1,"<p>Check this out :</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main()
{
    int n;
    scanf(""%d"", &amp;n);
    double i = log(n);
    while(!(i == (int)i))
    {
        printf(""\n Enter another number"");
        scanf(""%d"", &amp;n);
        i = log(n);
    }
    return 0;
}  
</code></pre>
",1
31222203,31221769,2,"<p>The program has undefined behaviour. </p>

<p>We will not take into account that there is a typo and instead of identifier <code>strings</code> there is sometimes used identifier <code>string</code>. Let's assume that everywhere in the code snippet there is used identifier <code>strings</code>.</p>

<p>In this statement</p>

<pre><code>char*p=*strings;
</code></pre>

<p>the first element of the array is assigned to the pointer. The first element of the array is pointer to the first character of string literal <code>""abc""</code>. So p points to character <code>'a'</code> of the string literal.</p>

<p>In this statement</p>

<pre><code>p += *strings[2] - *strings[1];
</code></pre>

<p><code>strings[2]</code> is the third element of the array having type <code>char *</code> and its value is the address of the first character of string literal <code>""dddd""</code>. Dereferencing this pointer <code>*strings[2]</code> you will get the first character of this string literal that is <code>'d'</code></p>

<p><code>strings[1]</code> is the second element of the array having type <code>char *</code> and its value is the address of the first character of string literal <code>""bbb""</code>. Dereferencing this pointer <code>*strings[1]</code> you will get the first character of this string literal that is `'b'</p>

<p>The difference between internal codes of characters <code>'d'</code> and <code>'b' (for example in ASCII the code of character</code>'b'<code>is 98 while the code of</code>'d'` is 100) is equal to 2.</p>

<p>So this statement</p>

<pre><code>p += *strings[2]-*strings[1];
</code></pre>

<p>increases the pointer by 2. At first it pointed to character <code>'a'</code> of the first string literal <code>""abc""</code> and after increasing by 2 it points now to character <code>'c'</code> of the same string literal <code>""abc""</code>.</p>

<p>Thus in this statement</p>

<pre><code>res[0] = *p;
</code></pre>

<p>character <code>'c'</code> is assigned to <code>res[0]</code>.</p>

<p>After this statement</p>

<pre><code>p+=3;
</code></pre>

<p>the value of <code>p</code> becomes invalid because it now points beyond the string literal ""abc"" and it is not necessary that the compiler placed string literal <code>""bbb""</code> exactly after string literal <code>""abc""</code>.</p>

<p>So dereferencing this pointer in the next statement </p>

<pre><code>res[1]=*p;
</code></pre>

<p>results in undefined behaviour.</p>

<p>According to the C Standard</p>

<blockquote>
  <p>If the result points one past the last element of the array object, it
  shall not be used as the operand of a unary * operator that is
  evaluated</p>
</blockquote>

<p>It simply occured such a way that the compiler placed the string literals one after another in the memory. Though this is not guaranteed by the Standard.</p>

<p>So if after statement</p>

<pre><code>res[1]=*p;
</code></pre>

<p>res[1] does not contain character <code>'\0'</code> then the next statement</p>

<pre><code>printf(""%s\n"",res);
</code></pre>

<p>also has undefined behaviour.</p>
",2
31221906,31221769,1,"<p>First thing is there is nothing like <code>string</code> defined in your program, so your statement should be <code>p+=*strings[2]-*strings[1]</code></p>

<p>Answer to both of your question is <strong>Dereferencing  a pointer</strong>. You need to understand, how pointers work on Strings. Please check <a href=""https://www.cs.bu.edu/teaching/c/string/intro/"" rel=""nofollow"">this link</a>.</p>
",0
31173801,31173751,0,"<p>I believe the below question answers yours. Let me know if this helps!</p>

<p>It is using a <code>while loop</code> to ensure the input is only numbers, but could easily bee altered to be only <code>chars</code>. Also you can set your variable to be only numbers such as <code>double</code> or <code>integer</code>, the same way you can make it only a <code>string</code>.</p>

<p><strong>Original Answered Link:</strong>
<a href=""https://stackoverflow.com/questions/10828937/how-to-make-cin-to-take-only-numbers"">How to make cin take only numbers</a></p>

<blockquote>
  <p>From Jesse Good's Answer</p>
</blockquote>

<p>I would use <code>std::getline</code> and <code>std::string</code> to read the whole line and then only break out of the loop when you can convert the entire line to a double.</p>

<pre><code>#include &lt;string&gt;
#include &lt;sstream&gt;

int main()
{
    std::string line;
    double d;
    while (std::getline(std::cin, line))
    {
        std::stringstream ss(line);
        if (ss &gt;&gt; d)
        {
            if (ss.eof())
            {   // Success
                break;
            }
        }
        std::cout &lt;&lt; ""Error!"" &lt;&lt; std::endl;
    }
    std::cout &lt;&lt; ""Finally: "" &lt;&lt; d &lt;&lt; std::endl;
}
</code></pre>

<p>Hope this helps!</p>
",0
31225462,31225424,2,"<p>This code has undefined behavior because it will access elements outside the array.  You can see this behavior if you change your code to the following:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
  int i, a[7] = {-6, -4, -2, 0, 2, 4, 6};
  for (i = 0; i &lt; 4 || a[i]; i++) {
    printf(""Accessing element: %d\n"", i);
    putchar('*');
  }
}
</code></pre>

<p>On my machine I get the following output:</p>

<pre><code>Accessing element: 0
*Accessing element: 1
*Accessing element: 2
*Accessing element: 3
*Accessing element: 4
*Accessing element: 5
*Accessing element: 6
*Accessing element: 7
*Accessing element: 8
*
</code></pre>

<p>This is accessing 9 elements (index 8 is element 9 of a zero based index array).  Once you have undefined behavior all bets are basically off.  It is also possible that the program will loop until it reaches a segmentation fault.</p>

<p>It doesn't break when <code>i == 4</code> or when <code>i</code> is greater than 4 because <code>a[i]</code> is true and therefore <code>i &lt; 4 || a[i]</code> is also true.  <code>a[i]</code> is true up to the array length and then you access something outside the array (the 8th element, index 7) and then you have undefined behavior.</p>
",0
31225464,31225424,1,"<p>Your code invokes <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow""><em>undefined behaviour</em></a> because the loop condition is bogus and leads to accessing the array beyond its bounds.</p>

<p>Remember there's no bounds check on arrays done by the language or any implicit <em>null</em> at the end of array in C. A lot of invalid code compiles just fine. It's your responsibility as a programmer to ensure your code is valid. </p>

<p>A correct loop condition would ensure the array is not accessed outside it's boundary:</p>

<pre><code>for (i = 0; i &lt; (sizeof a/sizeof a[0]) &amp;&amp; a[i]; i++)
    putchar('*');
</code></pre>
",0
31225466,31225424,0,"<p>An integer is considered ""true"" if it is nonzero. All the cases in your first example where it gets as far as looking at a[I] have that value nonzero, and anything ored with true is true.</p>

<p>(@CyberSpock spells this out in more detail)</p>
",2
31226213,31225424,0,"<pre><code>int i, a[7] = {-6, -4, -2, 0, 2, 4, 6};
for (i = 0; i &lt; 4 || a[i]; i++)
</code></pre>

<p>If you look at the condition</p>

<pre><code>i &lt; 4 || a[i]
</code></pre>

<p>It means that the expression is true if <em>either</em> <code>i</code> is less than 4 i.e. elements at [0-3] of the array will be true <strong>OR</strong> if <code>a[i]</code> is not 0 (<code>a[i]</code> is the short form for <code>a[i] != 0</code>) </p>

<p>The array has an element that is zero, it is at a[3] but will anyway be printed because the other part of the or condition is true for that position: <code>i &lt; 4</code></p>

<p>When dealing with arrays like this it is good to know the size of the array and have that as the max value even if you want to break on a particular value.</p>

<pre><code>int N=sizeof(a)/sizeof(a[0])
</code></pre>

<p>or </p>

<pre><code>#define N 7

for (i = 0; i &lt; N &amp;&amp; a[i]; i++)
</code></pre>

<p>this will prevent you from reading random values from the stack (in this case).</p>
",0
32937418,32937090,0,"<p>Here's an example of how to use <a href=""http://osr507doc.sco.com/en/netguide/dusockD.socketpairs_codetext.html"" rel=""nofollow"">socketpair()</a> to  pass data between parent/child processes (in UNIX-like OSes): </p>

<pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;stdio.h&gt;

#define DATA1 ""In Xanadu, did Kublai Khan . . .""
#define DATA2 ""A stately pleasure dome decree . . .""


/*
 * This program creates a pair of connected sockets, then forks and
 * communicates over them.  This is very similar to communication with pipes;
 * however, socketpairs are two-way communications objects. Therefore,
 * this program can send messages in both directions.
 */


main()
{
    int sockets[2], child;
    char buf[1024];


    if (socketpair(AF_UNIX, SOCK_STREAM, 0, sockets) &lt; 0) {
        perror(""opening stream socket pair"");
        exit(1);
    }


    if ((child = fork()) == -1)
        perror(""fork"");
    else if (child) {   /* This is the parent. */
        close(sockets[0]);
        if (read(sockets[1], buf, 1024, 0) &lt; 0)
            perror(""reading stream message"");
        printf(""--&gt;%s\n"", buf);
        if (write(sockets[1], DATA2, sizeof(DATA2)) &lt; 0)
            perror(""writing stream message"");
        close(sockets[1]);
    } else {        /* This is the child. */
        close(sockets[1]);
        if (write(sockets[0], DATA1, sizeof(DATA1)) &lt; 0)
            perror(""writing stream message"");
        if (read(sockets[0], buf, 1024, 0) &lt; 0)
            perror(""reading stream message"");
        printf(""--&gt;%s\n"", buf);
        close(sockets[0]);
    }
}
</code></pre>
",0
31115270,31115192,1,"<p>The result is 7 because b is initialized as 1 and stays 1 the whole time. The outer loop is run 3 times (1, 2, 3), the inner loop is run 2 times (1 and 2), so there are 6 runs where b is added to a (which is initialized as 1). 1 + 6 = 7.</p>
",0
31115300,31115192,2,"<p>The structure is like below</p>

<pre><code>- Outer `for` loop
 - inner `for` loop
     - instruction
</code></pre>

<p>so the ""instruction"" (statement/block) will get executed inner <code>for</code> loop count times, for outer <code>for</code> loop count times.</p>

<p>What is basically says is, add the value of <code>b</code> to the latest value of <code>a</code> (in a recurring way) to get the current value of a. Now , do that for ""outer"" number of time, for which, do the same for ""inner"" number of times.</p>

<p>Outer <code>for</code> loop ==> 3 times,<br>
inner <code>for</code> loop ==> 2 times</p>

<p>So, final value =<code>3*2 (increment)</code> + <code>(initial)</code> = <code>(3*2)*1 + 1</code> = <code>7</code>.</p>
",0
31115329,31115192,1,"<p>In such scenarios, you should add a watch and debug your code line by line. I believe the shortcut is F11. Regards to why the output of your code is 7...
The inner loop runs six times. J loops twice - 1, 2, (ends when it is 3), and I loops thrice (1, 2, 3, 4 - end)... for a total of 2 X 3 = 6.</p>

<p>Since b is '1', you are basically adding the number 1 to a six times. Since a started with '1', the output is:</p>

<p>a = 1 + 1 + 1 + 1 + 1 + 1 + 1 = 7</p>
",0
31273082,31273007,2,"<pre><code>printf(""Please enter a number between 1 and 6.\n"");
scanf(""%d"", &amp;yourNumber);
while(yourNumberCounter&lt;= 20)
</code></pre>

<p>is outside of the loop</p>

<p>should be</p>

<pre><code>while(yourNumberCounter&lt;= 20){
printf(""Please enter a number between 1 and 6.\n"");
scanf(""%d"", &amp;yourNumber);
</code></pre>

<p>The break statement terminates the execution of the nearest enclosing do, for, switch, or while statement in which it appears. Control passes to the statement that follows the terminated statement.</p>

<p>delete all the breaks.</p>

<p>also learn to use the debugger.</p>

<p>google: ""how to debug c code"" and the name of your IDE - the program you write code with.</p>
",8
31228491,31228449,1,"<p>You have declared <code>init</code> as function with parameter <code>char*</code> , but calling it without parameters.</p>
",0
31228953,31228449,0,"<p>Do not name your function 'init' if it is not designed for initializing anything. Name it <code>getRandomWord</code> instead, or something likethat.</p>

<p>Your <code>words</code> array contains 50 items, so its valid indices span the range 0 till 49. Consequently you should truncate your <code>rand()</code> result modulo 50, not 51. Anyway it's safer to use a predefined macro for a constant:</p>

<pre><code>int randomNumber = rand() % NUM_WORDS;
</code></pre>

<p><strong>ADDED</strong></p>

<p>You can also drop the size at all and make the compiler calculate it when needed. Then you can freely add new words in future versions without updating <code>NUM_WORDS</code> definition: This is the trick: take the size of array (in bytes) and divide it by the size of the array item.</p>

<pre><code>const char* words[] = {  // size defined implicitly by a words list
  ""array"",      ""auto"",       ""break"",      ""case"",       ""cast""
  // .....
};

int num_words = sizeof words / sizeof words[0];
int randomNumber = rand() % num_words;
</code></pre>

<p>(End of 'added'.)</p>

<p>Use <code>srand()</code> once, <code>rand()</code> multiple times:</p>

<pre><code>main()
{
    char word[ MAX_WORD_LEN + 1];

    // some preparations
    .....
    srand( time(NULL) );

    // main work

    while( still_want_to_work )
    {
        getRandomWord( word );
        processTheWord( word ); // eg. print it
    }
}
</code></pre>

<p>Then <code>getRandomWord(char *word)</code> may deliver a random word to the caller:</p>

<pre><code>void getRandomWord(char* word)
{
    const char* words[] = {
      ""array"",      ""auto"",       ""break"",      ""case"",       ""cast""
      //......
   };

    int randomNumber = rand() % (sizeof words / sizeof words[0]);
    printf(""%d\n"", randomNumber);
    int wordLength = strlen(words[randomNumber]);
    printf(""%d %s\n"", wordLength, words[randomNumber]);

    // copy the word to a buffer prepared by a caller
    strncpy( word, words[randomNumber], MAX_WORD_LEN );
    // and terminate the result in case the source is too long
    word[MAX_WORD_LEN] = 0;
}
</code></pre>
",1
31228745,31228449,0,"<p>Modify you function prototype as well as definition from <code>void init(char * word)</code> to <code>void init()</code> since you already have <code>const char* words[NUM_WORDS]</code> defined inside your function, you don't need to pass any arguments.</p>
",2
31274835,31274676,3,"<p>Every time you call <code>insert</code>, you're passing in the address of a buffer that was allocated on the stack, i.e. <code>server_reply</code>, and saving that in your list.  Then, when <code>send_receive</code> exist, that memory points to garbage.</p>

<p>Instead of doing this:</p>

<pre><code>new_node-&gt;request= send;
new_node-&gt;response = receive;
</code></pre>

<p>Do this:</p>

<pre><code>new_node-&gt;request= strdup(send);
new_node-&gt;response = strdup(receive);
</code></pre>

<p>That makes a copy of the sent/recieved data in a newly allocated buffer.  Just be sure to <code>free()</code> all of that memory when you clean up.</p>
",0
32440152,32440081,6,"<p>It's to demonstrate padding issues done by the compiler. What it (the compiler) did here was to align each part of the struct to 4 byte word boundaries (=> 4*3 = 12 bytes) instead of packing them into 9 bytes. This is performed by the compiler to allow for data member access that respects the target CPU memory access patterns.</p>
",0
31903922,31903501,3,"<p>As mentioned in lurker's comment, this is not doing what you expect:</p>

<pre><code>while(!(rr == (int)rr))
</code></pre>

<p>A better method would be:</p>

<pre><code>while((rr - floor(rr)) &gt; .0001)
</code></pre>

<p>This avoids casting and accounts for the fact that floating point is not always an exact representation.</p>
",1
31294251,31293931,1,"<pre><code>int celsius;
scanf(""%d"", &amp;celsius);
int kelvin = 273 + celsius;
float farenheit = 1.8 * celsius + 32;    // To make it a float
</code></pre>

<p><strong>Input</strong></p>

<pre><code>100
0
</code></pre>

<p><strong>Output</strong></p>

<pre><code>212.000000 373
32.000000 273
</code></pre>

<p>See <a href=""http://ideone.com/6ikg23"" rel=""nofollow"">http://ideone.com/6ikg23</a> demo.</p>
",4
31294270,31293931,0,"<p>the 9/5 is an integer divide.</p>

<p>an integer divide drops any fraction.</p>

<p>So the result is 1.</p>

<p>To fix the problem, use float rather than int</p>

<pre><code>9.0f/5.0f
</code></pre>
",0
31294381,31293931,0,"<p>First, the code you provided is missing a brace at the end and won't calculate the proper  Fahrenheit conversion due to integer truncation; however, the first one can be chalked up to a copy-paste error, and the second is a common mistake among programmers (new and old).</p>

<p>You code compiled and ran perfectly fine for me, and after fixing the Fahrenheit error (hint: use a decimal point, <code>(9./5)</code>, to calculate it in floating-point) it returned the correct values for my inputs.</p>

<p>Unfortunately, I'm not familiar with Eclipse, so I can't be much help there. But it's definitely a tooling issue, not a problem with your code.</p>
",3
33523648,33521994,1,"<p>Please note that a variable is <em>never</em> declared ""on the heap"". Only memory pointed to by a pointer can be <em>allocated</em> on (from) the heap.</p>

<p>In your example, you can declare <code>name</code> indeed outside any function and then it will exist in global memory. You can also delcare the variable inside a function, preceded by the keyword <code>static</code>. This latter will allocate the variable also in global memory, but it will only be visible in the function where you declared it.</p>

<p>To use your pointer variable, you now must alocate memory for it to point to, which you allocate on the heap using <code>malloc</code>.</p>
",0
33526232,33521994,0,"<p><strong>TL;DR Version</strong></p>

<p>You cannot declare a variable such that the variable itself lives on the heap.</p>

<p><strong>James Michener Version</strong></p>

<p>The C language definition doesn't talk about stacks or heaps; it talks about <em>storage durations</em>.</p>

<p>Objects with <code>auto</code> storage duration (anything declared within a block and without the <code>static</code> keyword) have lifetimes that extend from the beginning of that block and end when the block exits<sup>1</sup>:</p>

<pre><code>void foo( void )
{
  int a = 0;                        // lifetime of a extends to the end of
                                    // the function
  for ( int i = 0; i &lt; 10; i++ )    // lifetime of i and b extend to the end
  {                                 // of the for loop
    int b = a + i;    
    printf( ""b = %d\n"", b );     
  }
}
</code></pre>

<p>Most implementations allocate storage for <code>auto</code> objects from the hardware stack, because a stack makes that behavior easy to implement<sup>2</sup>.  </p>

<p>Objects with <code>static</code> storage duration (anything declared outside of a function or with the <code>static</code> keyword) have lifetimes that extend from the time the program is loaded into memory until the program exits:</p>

<pre><code>int a = 0;                   // lifetime of a extends over the lifetime of
                             // the entire program
int main( void )
{
  static int b = 10;         // lifetime of b also extends over the lifetime
                             // of the program, but is only visible within
                             // main
  ...
}
</code></pre>

<p>Most implementations will set aside storage for <code>static</code> objects within the body of the executable itself (for an executable using the <a href=""https://en.wikipedia.org/wiki/Executable_and_Linkable_Format"" rel=""nofollow"">ELF</a> format, such objects will be stored in the <code>.bss</code>, <code>.data</code>, or <code>.rodata</code> sections of the image).  </p>

<p>Objects with <code>allocated</code> storage duration (anything allocated with <code>malloc</code>, <code>calloc</code>, or <code>realloc</code>) have lifetimes that extend from the time that they are allocated until they are explicitly deallocated with a call to <code>free</code>.  </p>

<pre><code>int *foo( size_t size )
{
  int *ptr = malloc( sizeof *ptr * size );  
  return ptr;                               
}

void bar( void )
{
  int *p = foo( 10 );                       
  // do something with p
  free( p );
}
</code></pre>

<p>The <em>variables</em> <code>ptr</code> and <code>p</code> only exist for the lifetimes of their respective functions, and they will be typically allocated from the stack.  The object both variables <em>point to</em> exists from the time it is allocated with <code>malloc</code> until it is deallocated with <code>free</code>.  </p>

<p>Most implementations allocate storage for <code>allocated</code> objects from the heap.  </p>

<p>There's really no way for you to <em>declare</em> an object that has <code>allocated</code> storage duration; the only way you can create such an object is via <code>malloc</code>, <code>calloc</code>, or <code>realloc</code>.  Whatever object you declare to store the pointer value returned by any of those functions will have either <code>auto</code> or <code>static</code> storage duration.  </p>

<p><hr>
<sup>1.  In practice, storage for all local objects is allocated at function entry and released at function exit, regardless of whether the object's lifetime is over the entire function or limited to a block within the function.  However, you should never rely on that storage being accessible outside of that object's lifetime.  For example, the lifetimes of <code>i</code> and <code>b</code> are limited to the <code>for</code> loop; even though the storage for each may have been allocated at function entry, you should not attempt to access that storage outside of the loop body.<br><br>
2.  C was designed on a machine with a stack, after all.<br>
</sup></p>
",0
31239534,31238832,0,"<p>As for determining whether or not a letter/char exists in the word you can use <a href=""http://www.tutorialspoint.com/ansi_c/c_strchr.htm"" rel=""nofollow"">strchr() function</a>:</p>

<pre><code>if(strchr (word,firstGuess)){
    printf(""Correct Guess!!"");
    flag_guess_correct = 1;     //flag is set when the guessed character is present in word
}
</code></pre>
",0
31238883,31238832,0,"<p>In your case, at first look,</p>

<pre><code>scanf(""%d\n"", firstGuess);
</code></pre>

<p>is wrong. You're using wrong conversion specifier. It should actually be</p>

<pre><code>scanf("" %c"", &amp;firstGuess);   //notice ALL the chnages
</code></pre>

<ul>
<li>Point 1: You need to use <code>%c</code> to read a <code>char</code>.</li>
<li>Point 2: Your input should <em>exactly</em> match the supplied format string. I believe, you do not need to have a <code>\n</code> in the format string.</li>
<li>Point 3: <code>%c</code> format specifier expects the corresponding argument to be a <strong>pointer</strong> to a <code>char</code> (as field width defaults to <code>1</code>)</li>
<li>Point 4: Note the space <code></code> before <code>%c</code>, it helps to <em>eat up</em> any possible whitespace before the <em>expected</em> non-whitespace character input.</li>
</ul>
",4
31238971,31238832,1,"<p>You have many problems.</p>

<p>Less serious problem:</p>

<pre><code>int guessedLetters[ALPHABET_SIZE] = {
   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
</code></pre>

<p>can be shortened to </p>

<pre><code>int guessedLetters[ALPHABET_SIZE] = {0};
</code></pre>

<p>Serious problems:</p>

<ul>
<li><p>You use <code>word = words[randomNumber];</code>. This simply changes the local pointer <code>word</code> and makes it point to the string literal pointer to by <code>words[randomNumber]</code>. You probably need to copy each character by character. This can be done by using the <code>strcpy</code> function from <code>string.h</code>:</p>

<pre><code>strcpy(word, words[randomNumber]);
</code></pre></li>
<li>You <code>return word;</code> from <code>getRandomWord</code> which is a function returning <code>void</code> (does not return anything). This is wrong. Remove <code>return word;</code></li>
<li><p>You call <code>displayWord( word, wordLength );</code> with second argument <code>wordLength</code> which is an <code>int</code>. But </p>

<pre><code>void displayWord(char* word, int* guessedLetters)
</code></pre>

<p>expects an <code>int*</code> as its second parameter. Since <code>wordLength</code> is global, you don't have to pass it. <code>displayWord</code> cannot see <code>guessedLetters</code> as it is local in <code>main</code>. Pass it to <code>displayWord</code> instead of passing <code>wordLength</code>:</p>

<pre><code>displayWord( word, guessedLetters );
</code></pre></li>
<li>Here <code>if ( word[x] != guessedLetters )</code> you compare a <code>char</code> with an <code>int*</code>. This makes no sense. It should probably be <code>if ( guessedLetters[x] == 0 )</code></li>
<li>You use <code>printf(guessedLetters);</code> and pass an <code>int*</code> as the first argument to <code>printf</code> which expects a <code>const char*</code> as its first argument. It should probably be <code>printf(""%c"", word[x]);</code>.</li>
<li><code>scanf(""%d\n"", firstGuess);</code> should be <code>scanf("" %c"", &amp;firstGuess);</code> for the reasons mentioned in <a href=""https://stackoverflow.com/users/2173917/sourav-ghosh"">@SouravGhosh's</a> <a href=""https://stackoverflow.com/a/31238883/3049655"">answer</a>.</li>
<li><p>You return <code>GOOD_GUESS</code> and <code>BAD_GUESS</code> from <code>guessLetter</code>, but never use the return value. You need not return anything from this function. Just assign some value other than 0 to that position in <code>guessLetters</code>. So remove both the return statements and change</p>

<pre><code>int guessLetter(char* word, int* guessedLetters)
</code></pre>

<p>to</p>

<pre><code>void guessLetter(char* word, int* guessedLetters)
</code></pre>

<p>and </p>

<pre><code>if( firstGuess == word[x])
{
    printf(""Correct Guess!!"");
    return GOOD_GUESS;
}
else
{
    printf(""Incorrect"");
    return BAD_GUESS;
}
</code></pre>

<p>to</p>

<pre><code>if( firstGuess == word[x])
{
    printf(""Correct Guess!!"");
    guessedLetters[x] = 1;     //Change the value of the current position
}
else
{
    printf(""Incorrect"");
}
</code></pre></li>
<li><p>You declare just one function:</p>

<pre><code>void getRandomWord(char* word);
</code></pre>

<p>what about the rest? Use:</p>

<pre><code>void getRandomWord(char* word);
void displayWord(char* word, int* guessedLetters)
void guessLetter(char* word, int* guessedLetters)
</code></pre></li>
</ul>

<hr>

<p><strong>Fixed code:</strong> (untested):</p>

<pre><code>// Includes
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include ""hangman.h""

//Function Declarations
void getRandomWord(char* word);
void displayWord(char* word, int* guessedLetters)
void guessLetter(char* word, int* guessedLetters)

// Global Variable Declarations
int wordLength = 0;

int main(void)
{
   char word[MAX_WORD_LEN + 1];
   unsigned wrongGuesses = 0;
   int guessedLetters[ALPHABET_SIZE] = {0};

   srand( time(NULL));

   getRandomWord( word );
   displayWord( word, guessedLetters );
   guessLetter( word, guessedLetters);

   return EXIT_SUCCESS;
}


//Gets Random Word from Words Array
void getRandomWord(char* word)
{
    const char* words[NUM_WORDS] = {
       ""array"",      ""auto"",       ""break"",      ""case"",       ""cast"",
       ""character"",  ""comment"",    ""compiler"",   ""constant"",   ""continue"",
       ""default"",    ""double"",     ""dynamic"",    ""else"",       ""enum"",
       ""expression"", ""extern"",     ""file"",       ""float"",      ""function"",
       ""goto"",       ""heap"",       ""identifier"", ""library"",    ""linker"",
       ""long"",       ""macro"",      ""operand"",    ""operator"",   ""pointer"",
       ""prototype"",  ""recursion"",  ""register"",   ""return"",     ""short"",
       ""signed"",     ""sizeof"",     ""stack"",      ""statement"",  ""static"",
       ""string"",     ""struct"",     ""switch"",     ""typedef"",    ""union"",
       ""unsigned"",   ""variable"",   ""void"",       ""volatile"",   ""while""
    };

    int randomNumber = rand() % NUM_WORDS;
    printf(""Random Number is: %d\n"", randomNumber);
    wordLength = strlen(words[randomNumber]);
    printf(""Word Length is: %d\nWord is: %s\n"", wordLength, words[randomNumber]);
    strcpy(word, words[randomNumber]);
}


//Prints Word Formatted with dashes
void displayWord(char* word, int* guessedLetters)
{

    int x = 0;
    //printf(""%s \n"", word); Why print it here? No need for this


    for (x = 0; x &lt;= wordLength * 2; x++)
    {
        printf(""="");
    }
    printf(""\n|"");

    for(x = 0; x &lt; wordLength; x++)
    {

        if ( guessedLetters[x] == 0 )
        {
            printf(""_|"");
        }
        else
        {
            printf(""%c"", word[x]);
        }
    }
    printf(""\n"");

    for (x = 0; x &lt;= wordLength * 2; x++)
    {
        printf(""="");
    }
}


//User Makes Guess, Determines whether Guess is Correct or Incorrect
void guessLetter(char* word, int* guessedLetters)
{
    char firstGuess;
    int x;

    printf(""\nEnter Your Guess: "");
    scanf("" %c"", &amp;firstGuess);

    for(x = 0; x &lt; wordLength; x++)
    {
        if( firstGuess == word[x])
        {
            printf(""Correct Guess!!"");
            guessedLetters[x] = 1;     //Change the value of the current position
        }
        else
        {
            printf(""Incorrect"");
        }
    }
}
</code></pre>
",19
33560220,33559303,2,"<p>I can't quite follow how your code is supposed to work. So here's a simple implementation that computes the syndrome for the code <code>1000110</code>. The output from the program is <code>6</code>, i.e. the error is in bit 6.</p>

<pre><code>#include &lt;stdio.h&gt;

int main( void )
{               //  7654321
    char input[] = ""1000110"";
    int parity = 0;
    for ( int mask = 4; mask; mask &gt;&gt;= 1 )
    {
        for ( int bit = 1; bit &lt;= 7; bit++ )
            if ( bit &amp; mask )
                if ( input[7-bit] == '1' )
                    parity ^= mask;
    }
    printf( ""%d\n"", parity );
}
</code></pre>
",2
32945027,32943456,1,"<p>Note that <code>content</code>, the pdf file's content, is in the particular pdf format. When you do:</p>

<pre><code>memcpy(buffer + strlen(buffer),content,lSize);
sprintf(buffer, ""%s\r\n"", buffer);
</code></pre>

<p>then the sprintf will stop the printing at the first <code>\0</code> (null character).</p>

<p>You should do something like:</p>

<pre><code>//print header
sprintf(buffer, ""%s\r\nContent-Disposition: form-data; name=\""%s\""; filename=\""%s\""\r\n"", boundary, nameForm, filename);
sprintf(buffer, ""%sContent-Type: %s\r\n"", buffer, type);
sprintf(buffer, ""%sContent-Length: %d\r\n"", buffer, lSize);

strcat(buffer, ""\r\n"");
int len= strlen(buffer);                // remember length of header
memcpy(buffer + len, content, lSize);   // append contents
char *buf_tail= buffer+len+lSize;       // start of tail
strcpy(buf_tail, ""\r\n"");
buf_tail += 2;

strcpy(buf_tail, boundary);
buf_tail += strlen(boundary);
strcpy(buf_tail, ""--\r\n"");
</code></pre>

<p>that is, you keep track of the end of the buffer and add data there.</p>
",18
33018843,32943456,0,"<p>Concerning your last comment to my previous answer, you probably ran out of memory. There are also other errors. The following function should be correct:</p>

<p>(note: using strict C and TCHARS removed as I don't use those)</p>

<pre><code>#define ERROR_OPEN_FILE       10
#define ERROR_MEMORY          11
#define ERROR_SIZE            12
#define ERROR_INTERNET_OPEN   13
#define ERROR_INTERNET_CONN   14
#define ERROR_INTERNET_REQ    15
#define ERROR_INTERNET_SEND   16
#define ERROR_NO_PATH         17
#define ERROR_FINDNEXT        18

int InetPDF(void)   // returns 0 upon success
{
    static char *type = ""text/pdf"";
    static char hdrs[] = ""Content-Type: multipart/form-data; boundary=---------------------------7d82751e2bc0858"";
    static char boundary[] = ""-----------------------------7d82751e2bc0858"";            //Header boundary
    static char nameForm[] = ""uploadedfile"";     //Input form name
    static char iaddr[] = ""localhost"";        //IP address
    static char url[] = ""/xampp/testing/upload.php?folder=aaaa&amp;&amp;foldername=bbbb"";

    char *buffer;       // Buffer containing file + headers
    FILE *pFile;        // File pointer
    long lSize;         // File size
    int len, sent, retval= 0;
    char *buf_tail;
    HINTERNET hSession=0, hConnect=0, hRequest=0;
    WIN32_FIND_DATA fdFile;
    HANDLE hFind = NULL;
    char sPath[2048];
    char sDir[]= ""C:\\boot\\config"";

    sprintf(sPath, ""%s\\*.*"", sDir);

    if ((hFind = FindFirstFile(sPath, &amp;fdFile)) == INVALID_HANDLE_VALUE)
    {
        printf(""Path not found: [%s]\n"", sDir);
        return ERROR_NO_PATH;
    }
    do
    {
        if ((fdFile.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY)==0)
        {
            sprintf(sPath, ""%s\\%s"", sDir, fdFile.cFileName);

            // Open file
            if ((pFile = fopen(sPath, ""rb"")) == NULL)
            {
                printf(""ERROR_OPEN_FILE"");
                return ERROR_OPEN_FILE;
            }
            // obtain file size:
            fseek(pFile, 0, SEEK_END);
            lSize = ftell(pFile);
            rewind(pFile);

            //allocate memory to contain the whole file + HEADER and trailer
            if ((buffer = malloc(sizeof(char)*lSize + 2048))== NULL)
            {
                printf(""ERROR_MEMORY"");
                fclose(pFile);
                return ERROR_MEMORY;
            }
            // create the header
            sprintf(buffer, ""%s\r\nContent-Disposition: form-data; name=\""%s\""; filename=\""%s\""\r\n"", boundary, nameForm, fdFile.cFileName);
            sprintf(buffer, ""%sContent-Type: %s\r\n"", buffer, type);
            sprintf(buffer, ""%sContent-Length: %d\r\n"", buffer, lSize);
            strcat(buffer, ""\r\n"");
            len= strlen(buffer);

            // read the file into the buffer:
            if (fread(buffer + len, 1, lSize, pFile) != lSize)
            {
                printf(""ERROR_SIZE"");
                fclose(pFile);
                retval= ERROR_SIZE;
                goto cleanup;
            }
            fclose(pFile);

            // create the trailer
            buf_tail= buffer+len+lSize;
            strcpy(buf_tail, ""\r\n"");
            strcat(buf_tail, boundary);
            strcat(buf_tail, ""--\r\n"");

            // Open internet connection
            if ((hSession = InternetOpen(""WINDOWS"", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0)) == NULL)
            {
                printf(""ERROR_INTERNET_OPEN"");
                retval= ERROR_INTERNET_OPEN;
                goto cleanup;
            }
            if ((hConnect = InternetConnect(hSession, iaddr, INTERNET_DEFAULT_HTTP_PORT, NULL, NULL, INTERNET_SERVICE_HTTP, 0, 1)) == NULL)
            {
                printf(""ERROR_INTERNET_CONN"");
                retval= ERROR_INTERNET_CONN;
                goto cleanup;
            }
            if ((hRequest = HttpOpenRequest(hConnect, (const char*)""POST"", url, NULL, NULL, NULL, INTERNET_FLAG_RELOAD, 1))  == NULL)
            {
                printf(""ERROR_INTERNET_REQ"");
                retval= ERROR_INTERNET_REQ;
                goto cleanup;
            }
            if ((sent = HttpSendRequest(hRequest, hdrs, strlen(hdrs), buffer, len+lSize+strlen(buf_tail))) == 0)
            {
                printf(""ERROR_INTERNET_SEND"");
                retval= ERROR_INTERNET_SEND;
                goto cleanup;
            }
          cleanup:
            if (hSession) {InternetCloseHandle(hSession); hSession= 0;}
            if (hConnect) {InternetCloseHandle(hConnect); hConnect= 0;}
            if (hRequest) {InternetCloseHandle(hRequest); hRequest= 0;}
            free(buffer);
            if (retval!=0) {
                break;  // an error occurred: break out of the while-loop
            }
        }
    } while(FindNextFile(hFind, &amp;fdFile));

    if (GetLastError()!=ERROR_NO_MORE_FILES) {
        printf(""ERROR_FINDNEXT"");
        retval= ERROR_FINDNEXT;
    }
    FindClose(hFind);
    return retval;
}
</code></pre>

<p>EDIT: in one of your comments you said it didn't upload all files. The following is a test program to read all files/filenames in a directory. If this succeeds, then the error is in the uploading:</p>

<pre><code>int InetPDFtest(void)   // returns 0 upon success
{
    int retval= 0, n= 0;
    WIN32_FIND_DATA fdFile;
    HANDLE hFind = NULL;
    char sPath[2048];
    char sDir[]= ""C:\\Tmp"";

    sprintf(sPath, ""%s\\*.*"", sDir);

    if ((hFind = FindFirstFile(sPath, &amp;fdFile)) == INVALID_HANDLE_VALUE)
    {
        printf(""Path not found: [%s]\n"", sDir);
        return ERROR_NO_PATH;
    }
    do
    {
        if ((fdFile.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY)==0)
        {
            sprintf(sPath, ""%s\\%s"", sDir, fdFile.cFileName);
            n++;

        }
    } while(FindNextFile(hFind, &amp;fdFile));

    if (GetLastError()!=ERROR_NO_MORE_FILES) {
        printf(""ERROR_FINDNEXT"");
        retval= ERROR_FINDNEXT;
    }
    else {
        printf(""%d files processed\n"", n);
    }
    FindClose(hFind);
    return retval;
}
</code></pre>
",14
32980847,32980767,0,"<p>Using scanf is suboptimal.</p>

<p>I'd add a</p>

<pre><code>while (getchar());
</code></pre>

<p>line before the last scanf.</p>

<p>Please make sure you don't miss or mangle other data due to the newlines in the input buffer.</p>
",0
31814441,31814291,14,"<p>Due to <a href=""http://en.cppreference.com/w/c/language/operator_precedence"">operator precedence</a>,</p>

<p><code>++*p++</code> is same as <code>++(*(p++))</code>.</p>

<p>That is equivalent to:</p>

<pre><code>int* p1 = p++; // p1 points to a[0], p points to a[1]
++(*p1);       // Increments a[0]. It is now 11.
</code></pre>

<p>That explains the output.</p>
",0
31814448,31814291,2,"<p>This is because the postfix operator returns the value before the increment. So the pointer is well incremented but the prefix operator still applies to the original pointer value.</p>
",3
32423076,32423000,1,"<p>What about</p>

<pre><code>ptr = malloc(sizeof(int*));
*ptr = malloc(sizeof(int));
**ptr = 4;
</code></pre>
",1
32406105,32406068,2,"<p>You have to use the <code>&amp;</code> operator. For example replace <code>scanf(""%f"", v);</code> with <code>scanf(""%f"", &amp;v);</code>. This will pass the address of the variable (instead of the value) to <code>scanf()</code>.</p>
",0
32406131,32406068,2,"<p>You have to write <code>scanf(""%f"", &amp;i);</code> e.t.c, as you want the variable to be passed as a pointer as C has no reference type like C++</p>
",0
32406132,32406068,7,"<p>You're getting that warning because you failed to pass a pointer to a float (<code>float*</code>) to the function <code>scanf</code>. The compiler tells you that it's a double because <code>scanf</code> is a <a href=""https://en.wikipedia.org/wiki/Variadic_function"" rel=""nofollow"">variadic function</a>. Variadic parameters are subject to default argument promotion, where arguments of certain data types are converted to larger data types. In this case, <code>float</code> is promoted to <code>double</code>.</p>

<p>The only way for a function in C to modify variables <code>v</code>, <code>i</code>, and <code>choice</code> is to pass them as pointers, so you need to pass pointers to <code>scanf</code>, using the <code>&amp;</code> ""address of"" operator.</p>

<p>Your code should look like this:</p>

<pre><code>int main(int argc, const char * argv[]) {
    char choice[10];

    float v;
    float i;
    float r;

    printf(""What would you like to calculate?: "");
    scanf(""%9s"", &amp;choice); /* this specifier prevents overruns */
    printf(""\nYou chose: \n""""%s"", choice);

    if (strcmp(choice, ""r"") == 0)
    { 
        printf(""\nPlease enter voltage (V): \n"");
        scanf(""%f"", &amp;v); /* use a pointer to the original memory */

        printf(""\nPlease enter current (I): \n"");
        scanf(""%f"", &amp;i); /* use a pointer to the original memory */

        r = v/i;

        printf(""%f"", r);
    }
}
</code></pre>

<p>Note also that I used the format specifier <code>%9s</code>. That way, if the user inputs more than 9 characters, adjacent memory won't be overwritten. You have to reserve the last element of the array for the null character <code>\0</code> because strings in C end with <code>\0</code>.</p>
",0
32406281,32406068,4,"<blockquote>
  <p>I don't get it since I have not declared any double type variables.</p>
</blockquote>

<p>When there is no visible prototype to indicate what type a function expects for a given argument, or when that argument is among a set of variadic arguments, then default argument promotion is performed on that argument.  This provides for compatibility with pre-ANSI C code that assumed such promotions were performed on <em>all</em> arguments.</p>

<p>In this case, <code>scanf()</code> is variadic, with this prototype:</p>

<pre><code>int scanf(const char *fmt, ...);
</code></pre>

<p>so everything but the format is subject to default argument promotion.  For arguments of type <code>float</code>, that is a promotion to <code>double</code>, and that's where your <code>double</code> comes from.</p>

<p>Of course, as other answers describe, you shouldn't be passing the <code>float</code> at all, but rather a pointer to it.</p>
",0
31801800,31791866,0,"<p>I copied and pasted your code into my text editor and then compiled it and then got the same error you were receiving, so you're not alone, which is fantastic news. Luckily, I was able to fix it. The issue is arising from these three lines of code:</p>

<pre><code>      if (c &gt;= ¡¯0¡¯ &amp;&amp; c &lt;= ¡¯9¡¯)
</code></pre>

<p>and</p>

<pre><code>      ++ndigit[c - ¡¯0¡¯];
</code></pre>

<p>and</p>

<pre><code>       else if (c == ¡¯ ¡¯ || c == ¡¯\n¡¯ || c == ¡¯\t¡¯)
</code></pre>

<p>I was able to fix this issue by changing the single quotation marks.  For example, when I use the correct apostrophe, the if loop looks like:</p>

<pre><code>    if (c &gt;= '0' &amp;&amp; c &lt;= '9')
</code></pre>

<p>As for corrections, that's it! Your code should run perfectly after you fix those apostrophes. And as a parting note, when you do get it to compile and run, look up what the EOF is on your operating system. On mine (Ubuntu) I use CTRL+d. Good luck to you!</p>
",0
27675939,27674323,1,"<p>You can try this for <code>Factorials of large numbers</code> :</p>

<pre><code>#include&lt;iostream&gt;
#include&lt;cstring&gt;

int max = 5000;

void display(int arr[]){
    int ctr = 0;
    for (int i=0; i&lt;max; i++){
        if (!ctr &amp;&amp; arr[i])         ctr = 1;
        if(ctr)
            std::cout&lt;&lt;arr[i];
    }
}


void factorial(int arr[], int n){
    if (!n) return;
    int carry = 0;
    for (int i=max-1; i&gt;=0; --i){
        arr[i] = (arr[i] * n) + carry;
        carry = arr[i]/10;
        arr[i] %= 10;
    }
    factorial(arr,n-1);
}

int main(){
    int *arr = new int[max];
    std::memset(arr,0,max*sizeof(int));
    arr[max-1] = 1;
    int num;
    std::cout&lt;&lt;""Enter the number: "";
    std::cin&gt;&gt;num;
    std::cout&lt;&lt;""factorial of ""&lt;&lt;num&lt;&lt;""is :\n"";
    factorial(arr,num);
    display(arr);
    delete[] arr;
    return 0;
}
</code></pre>
",0
31870613,31870501,3,"<p>use something like:<br></p>

<pre><code>int a[10];               //array to input
int c=0;                 //counter that counts till 10 numbers
while(c&lt;10){
    char s[10];          //assuming 10 is the max number of digits in your input number
    scanf(""%10s"",s);
    if(checkInt(s, strlen(s))){     //a function that you must write to check if input verifies your criteria of correct, like no alphabets, decimal, spl char etc. 
        a[c]=atoi(s);
        c++;
    }
    else{
        printf(""Enter number in correct integer format\n"");
    }
}
</code></pre>

<p>A possible checkInt function can be like this:</p>

<pre><code>int checkInt(char s[], int l){
    int i;
    for(i=0;i&lt;l;i++){
        if(s[i]&lt;'0' || s[i]&gt;'9')
            return 0;
    }
    return 1;
}
</code></pre>
",6
32413929,32413713,1,"<p>For what you want you can try something like this -</p>

<pre><code> char *s;
 s=malloc(255);
 while(fscanf(fp,""%254s"",s)==1)
 {
    i++;
 }
 ...
 free(s);
</code></pre>

<p>This will give desired output.</p>

<p>Also -</p>

<pre><code> while(!feof(fp))
</code></pre>

<p><code>feof</code> to control loop is always wrong .And you should never use <code>feof</code> in loop . <a href=""https://stackoverflow.com/questions/5431941/why-is-while-feof-file-always-wrong"">Refer here</a></p>
",0
32413937,32413713,2,"<p>The problem is that there is no advance by calling <code>feof(fp)</code>, so the execution halts at the beggining of the file. You need to explicitly call something like, <code>getchar(), fscanf(), fgetc(),</code> etc. Here is an example</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

FILE *fp;
int main() {
    fp=fopen(""test.txt"",""r"");
    int i=0, ch=0;

    while((ch = fgetc(fp)) &gt; 0){
        if(ch == '\n') 
            i++;          
    }
    fclose(fp);
    printf(""The Number Of Sentence In That File: %d\n"",i);
    getchar();
}
</code></pre>
",0
32414008,32413713,1,"<p>Your loop does not terminate because you are not doing anything with the file within the loop.</p>

<p>Instead of using <code>feof</code> to control the loop, I would propose to use <code>getline()</code>.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

FILE *fp;
int main() {
    fp=fopen(""C:\\Users\\Alan\\Desktop\\text.txt"",""r"");

    int i = 0;
    char *line = NULL;
    size_t len = 0;

    while (getline(&amp;line, &amp;len, fp) != -1)
        i++;

    free(line);
    fclose(fp);
    printf(""The Number Of Sentence In That File: %d\n"",i);
}
</code></pre>

<p>Note: In this case <code>line</code> is set to <code>NULL</code> and <code>len</code> is set <code>0</code>, hence <code>getline()</code> will allocate a buffer for storing the <code>line</code>. This buffer should be freed before the program returns.</p>

<p><strong>Update</strong></p>

<p>You can use the return value of <code>getline</code>, if you also want to know the number of chars in the file:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

FILE *fp;
int main() {
    fp=fopen(""C:\\Users\\Alan\\Desktop\\text.txt"",""r"");

    int i = 0;
    int j = 0;
    int read = 0;
    char *line = NULL;
    size_t len = 0;

    while ((read = getline(&amp;line, &amp;len, fp)) != -1) {
        i++;
        j += read;
    }

    free(line);    
    fclose(fp);
    printf(""The Number Of Lines In That File: %d\n"", i);
    printf(""The Number Of Chars In That File: %d\n"", j);
}
</code></pre>
",0
33819577,33819414,2,"<p>You can put your if inside a dummy <code>do..while</code> loop like this:    </p>

<pre><code>for(..;..;..)
{
    do
    {
        if ()
        {
            //use break somewhere here according to your logic
        }
    }while(false);

    //statements
} 
</code></pre>

<p>This will cause the <code>break</code> to only skip the inner <code>do..while</code> loop.</p>

<p>The condition is <code>false</code> in <code>do..while</code> so that the loop runs only once as is expected in case of a normal if. The loop is there just to allow a <code>break</code> in the middle.</p>
",0
33819764,33819414,4,"<p>A common way to handle this situation is to put the body of the <code>if</code> statement into a separate function, and then return from the middle of the function if, for some reason, the function is unable to finish. After the function returns, the remainder of the statements in the <code>for</code> loop will run.</p>

<pre><code>void foo(void)
{
    //statements
    //statements

    if ( something_bad_happened )
        return;

    //statements
    //statements

    if ( some_other_bad_thing_happened )
        return;

    //statements
    //statements
}

void bar(void)
{
    for(..;..;..)
    {
        if ( some_foo_is_needed )
            foo();

        //statements
        //statements
    }
}
</code></pre>
",0
33819935,33819414,2,"<p>Instead of an if, use a switch statement. You can break out of a switch at any point. This isn't a very practical solution... but it works.</p>

<pre><code>for(..;..;..)
{
    switch(boolean_expression) { //break just leaves this switch statement
    case 0: //false is 0

        break;
    default: //true is not zero
        //statements
        if(something) 
            break;
        //statements you want to skip
        break;
    }
    //statements
}
</code></pre>
",0
33820244,33819414,1,"<p>If I understand your question, that you want to write a statement inside <code>if</code> and <em>goto</em> your marked statements only if that condition is true, then a <code>goto</code> statement can be useful, if for instance <code>//statements</code> only need to be run if the condition is true:</p>

<pre><code>for(..;..;..)
{
    if(true)
    {
        goto dothis;
    }
    /* other statements */
    return A;

    dothis:;
    //statements

    return B;
}
</code></pre>

<p>The <code>//statements</code> need not be in the <code>for</code> loop with <code>goto</code>, for example:</p>

<pre><code>for(..;..;..)
{
    if(true)
    {
        goto dothis;
    }
    /* other statements */
}
return A;

dothis:;
//statements

return B;
</code></pre>
",0
31823887,31823867,4,"<p>You are assigning the value for <strong>c</strong> instead of comparing.</p>

<pre><code>if (c == ' ' || c == '\n' || c = '\t') state = OUT;
</code></pre>

<p>should be </p>

<pre><code>if (c == ' ' || c == '\n' || c == '\t') state = OUT;
</code></pre>

<p>And your main function should be like <code>int main(void)</code> and put a <code>return 0</code> at the end</p>
",0
31824039,31823867,2,"<p>you are assigning value rather than comparing it:<code>if (c == ' ' || c == '\n' || c = '\t')</code>, <code>==</code> is used for comparison and <code>=</code> is used for assignment. </p>
",0
31824858,31823867,0,"<p>first of all change main function to <code>int main()</code>  at line 5.</p>

<p>Also at line 13 try to use <code>==</code>  for making it equal in the way shown below.</p>

<p><code>if (c == ' ' || c == '\n' || c == '\t') state = out;</code> 
 //you assign a value instead</p>

<p>Also to terminate a program, at the end write  return 0; </p>
",0
31853159,31852909,0,"<p>You can add 1 to your value and then cast into <code>int</code>. It also works with negative numbers.</p>

<pre><code>float f = 12.1;
float temp = f + ((f &lt; 0) ? 0 : 1);
int result = (int)temp;// 13
</code></pre>
",4
31853753,31852909,2,"<p>You can use the following method:</p>

<pre><code>int roundedOffValue(float value) //rounded off value will be an integer that can be caught in float
{
    return ceil(value);
}
</code></pre>

<p>Do not forget to include the <code>math.h</code> library.<br>
Hope this helps.</p>
",0
31853841,31852909,1,"<p>You can write a simple function like this.</p>

<pre><code>int roundFloatToUpper(float f)
{
    if (f &lt; 0)
         return ((int)(f))
    else
         return ((int)(f + 1)
}
</code></pre>

<p>i think that using math.h is overkill for something like that.</p>
",2
31894140,31894024,0,"<p>Well, the problem is the <strong>return 0;</strong></p>

<p>You leave the program and you can not see the results because there aren't more scanf to pause.</p>

<p>You need to put a getchar or a system pause before the return 0 and you will see the results.</p>
",6
32448363,32448341,3,"<p>Exactly as the error message says. <code>i</code> must have an integral type such as <code>int</code>. You can't use a <code>float</code> as an array index.</p>
",7
32449700,32448341,1,"<p>[too long for a comment]</p>

<p>If you have (more or less) complex expression in one line which does not compile, distrubute it over several lines to give the compiler a chance to point you what it does not like:</p>

<p>For example replace</p>

<pre><code>sum = sum + a[i]*pow(10, max -1 -i);
</code></pre>

<p>by</p>

<pre><code>sum = 
  sum + 
    a[i] * 
      pow(
        10, 
        max 
          -1 
          -i);
</code></pre>

<p>After have fixed the bug, remove those masive new-lines.</p>
",0
31889710,31889611,-1,"<p>corrected as below.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
void adderval(int a,int b,int c);
void adderRef(int a,int b,int *c );


int main()
{
        int a,b,c=0;
        printf(""enter two numbers.\n"");
        scanf(""%d %d"",&amp;a,&amp;b);
        adderval(a,b,c);
        printf(""the pass by value of c is %d \n"",c);
        adderRef(a,b,&amp;c);
        printf(""the pass by reference of c is %d \n"",c );
        return 0;
}
void adderRef (int a, int b, int *c )
{
        *c = a + b;
}
void adderval (int a , int b,int c )
{
        c=a+b;
}
</code></pre>
",5
28505177,28504634,0,"<p>I don't know why you are getting SIGSEGV. However, I see couple of errors in your code. </p>

<ol>
<li><p>You are using <code>scanf(""%s"",&amp;a[i][0]);</code> but <code>i</code> is never changed from its initial value of <code>0</code>. I suggest changing</p>

<pre><code>while (q-- &gt; 0)
</code></pre>

<p>to</p>

<pre><code>for ( i = 0; i &lt; z; ++i )
</code></pre></li>
<li><p>You are printing <code>a[i]</code> even though you are using <code>p</code> as the for loop index in</p>

<pre><code>for (p = 0; p &lt;z ; p++)   
   printf(""%s\n"",a[i]);
</code></pre>

<p>That's easily fixed by changing the second line to:</p>

<pre><code>   printf(""%s\n"",a[p]);
</code></pre></li>
<li><p>In your input, you didn't include the value of <code>z</code>. I hope that is an error in creating the post and that you have the value of <code>z</code> in your input.</p></li>
</ol>

<p>With those changes, I don't see any problem in my environment. I tested using gcc 4.7.3. Not sure fixing those will fix the problem in your environment.</p>
",0
31898081,31897905,0,"<p>This statement: <code>client = ""******"";</code> sets <code>client</code> to the address of the string literal, which the compiler puts in read only memory. Then when you try to change this memory with <code>scanf(""%s"", client);</code> it will cause a crash.</p>

<p>You could initialize the client as an array like: <code>char client[] = ""******"";</code> so the compiler will put it in a write-able memory segment.</p>
",0
32398002,32397875,3,"<blockquote>
  <p>MEDIA+=1/2*A + 1/3*B + 1/5*C;</p>
</blockquote>

<p>Because <code>1/2</code>, <code>1/3</code> and <code>1/5</code> will be evaluated as 0. Since they are integers.
Either write </p>

<p><code>1.0/2</code>, <code>1.0/3</code> and <code>1.0/5</code> instead. So the compiler will know to treat the result as <code>float</code>.</p>

<p>Or</p>

<pre><code>MEDIA+=A/2 + B/3 + C/5;
</code></pre>

<p>P.S.</p>

<p>Maybe I am wrong but if I understood correctly what you wrote at the description then I think your calculation of the weighted average is incorrect. It should be something like</p>

<p>(A*2 + B*3 + C*5)/10</p>
",0
28211902,28209751,2,"<p>It is not a simple task.</p>

<p>First: your ¦ÌC probably has a different archictecture and a different instruction set than your PC. Some operations your PC can do in 1 cycle while your ¦ÌC can't, for others your ¦ÌC might behave better. Your PCs processor has different number of registers, you have SSE units, Floating point, CRC32 in hardware etc. Your ¦ÌC might have different DSP units etc.</p>

<p>Second: You probably use two different compilers for these two different architectures which also implement special optimizations.</p>

<p>Third: Memory behavior: your PC has a huge cache compared to your ¦ÌC. </p>

<p>To answer your question: to get a more solid estimate you will need an instruction set simulator on your PC. In the simulator the execution time is much slower but you get a really good idea about how many isntructions your program takes.
Together with the ¦ÌC Clock-speed and a guesstimate on parallelism and cache-hits of your program you can then estimate the time it really takes.</p>

<p>Long story short, profile it on the target.  </p>
",1
28212507,28209751,1,"<p>This doesn't make any sense. Any performance tests for the microcontroller has to be performed with that MCUs architecture in mind. It is possible that the ""perf"" program has support for your given ARM Cortex, but it will still just be a rough approximation.</p>

<p>The advantage of microcontrollers is that you don't have to rely on such fluffy ""best guess"" profilers, but you can actually measure the real execution time live. This is done by toggling an I/O pin at relevant places in your program, then use an oscilloscope to measure the execution time. You cannot write microcontroller software without an oscilloscope, it is a mandatory tool and the only one giving trustworthy performance measurements, end of story.</p>

<p><strong>EDIT</strong></p>

<p>If you have no hardware available, the best way to ""guess"" is to get a disassembler for your MCU, count the number of instructions (or CPU ticks if available) in your program, then multiply it with the oscillator frequency to get the total execution time.</p>
",2
32416541,32416513,0,"<p>It is having integer overflow. You have to use <code>unsigned long long</code> or <code>long long</code> .</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef long long ll;
ll power(ll a,ll b){

ll c,i;
c=1;

for(i=1;i&lt;=b;++i){
    c=c*a;
}
return c;
}

int main(){

ll nice=power(5,20);
printf(""answer =%lld , and size is=%lld "", nice, sizeof(nice));
return 0;
}
</code></pre>

<h2>NOTE:</h2>

<p>You will have a good idea about this -> read this <a href=""https://stackoverflow.com/questions/199333/how-to-detect-integer-overflow-in-c-c"">SO question</a>.</p>

<h2>QUESTION-2: WHat happens for a=5 b=100</h2>

<p>Then you have to write your custom function for manipulating the multiplications. Use int <code>arr[100]</code> to hold the digits of the large number and then multiply it accordingly.C/C++ doesn't provide anything like <code>BIgInt</code> of <code>Java</code>, you have to build it. </p>
",3
33558497,33558423,2,"<p>Another typo:</p>

<pre><code>while (i=!0){
</code></pre>

<p>should be:</p>

<pre><code>while (i != 0){
</code></pre>

<p>Your code was assigning <code>!0</code> to <code>i</code>, instead of comparing <code>i</code> with <code>0</code>. <code>!0</code> is <code>1</code>, so you had an infinite loop, and you were writing beyond the bounds of the array.</p>

<p>Also note that if the file has more than 20 numbers in it, you'll write outside the array. And if it has fewer than 20 numbers, the loop that prints <code>values[k]</code> will read uninitialized array entries.</p>
",0
33558504,33558423,0,"<p>There are a couple of things that are wrong with the code:</p>

<ul>
<li>You are not checking for error after opening input.txt</li>
<li>While i=!0 is syntactically correct it probably does not do what you want !0 is 1, so it is the same as i=1, you are putting value 1 into i</li>
</ul>

<p>To help you with debugging:</p>

<ul>
<li>add printf() statements to your code to verify that you reached a certain line and to check the values of the variables</li>
<li>learn to use a debugger</li>
</ul>
",0
30413362,30307956,0,"<p>I have figured out the problem with help from @Blidny and @MikeofSST
It turns out that my code above contained in a file <code>app_data.c</code> wasn't running code outside if the functions created in <code>app_data.h</code>. I moved my code up into the void where my <code>temperature</code> values were formatted and written, and <code>strcpy()</code> worked like a charm. </p>
",0
33513647,33513605,2,"<p>Because when <code>scanf</code> sees input that doesn't match its format, it simply stops reading, and leaves the invalid input in the buffer. So next time you try to read, you will attempt to read the exact same invalid input again, and again, and...</p>

<p>A simple solution is to read a line using <code>fgets</code> and then use <code>sscanf</code> to get the data.</p>
",2
29197787,29197730,8,"<p>Don't strcpy into pointers that aren't pointing at allocated memory.  Instead, just set them equal to the pointers in the argv array, which already do point at allocated memory.  Like so:</p>

<pre><code>int main(int argc, char *argv[])
{
    if (argc &lt; 5)
        fprintf(stderr, ""usage: %s &lt;file1&gt; &lt;file2&gt; &lt;file3&gt; &lt;num&gt;\n"", argv[0]), exit(1);

    char *file1 = argv[1];
    char *file2 = argv[2];
    char *file3 = argv[3];
    long  num   = strtol(argv[4], NULL, 0);

    /* Do stuff */

    return 0;
}
</code></pre>
",0
29197831,29197730,3,"<p>If you want to copy strings from argv then you have to allocate memory for these strings in the program. For example</p>

<pre><code>int main(int argc, char* argv[])
{
    char *file1, *file2, *file3;
    long num = 0;

    if ( argc &gt; 1 )
    {
        file1 = malloc( strlen( argv[1] ) + 1 ); 
        strcpy( file1, argv[1] );
    }

    if ( argc &gt; 2 )
    {
        file2 = malloc( strlen( argv[2] ) + 1 ); 
        strcpy( file2, argv[2] );
    }

    if ( argc &gt; 3 )
    {
        file3 = malloc( strlen( argv[3] ) + 1 ); 
        strcpy( file3, argv[3] );
    }

    if ( argc &gt; 4 )
    {
        num = strtol( argv[4], NULL, 0 );
    }

    //...
</code></pre>
",2
29204580,29197730,2,"<p>some times we missed some of the argument, for that we need check whether all 
the arguments are given or not.</p>

<pre><code>  main(int argc,char *argv[])
  {
         if(argc != 5)
            printf(""Error message"");
         else{
             //perofmr your operation what you want
             }
  }
</code></pre>
",0
33537586,33537562,0,"<p>The only thing that could be crashing here is this line:</p>

<pre><code>the_list-&gt;lower-&gt;set_size = 0;
</code></pre>

<p>Either the_list or the_list->lower must be uninitialized or NULL or be pointing to invalid or inaccessible memory.</p>

<p>Edit: Yeah this line will crash because you don't initialize the_list.lower:</p>

<pre><code>result = set_init( &amp;the_list );
</code></pre>

<p>And this line will crash because you're passing NULL:</p>

<pre><code>result = set_init( NULL );
</code></pre>
",9
33552135,33552024,3,"<p>You have random values left in memory for your values array in main. It is working the way it's supposed to. However, you are using it on the data you don't want to work on.</p>

<p>Try initializing your values array before shuffling. Eg.:</p>

<pre><code>for (i = 0; i &lt; max_value; ++i){
    array[i] = i;
}
</code></pre>
",2
34087799,34086171,0,"<p>There is a bug in the leap year calculation:</p>

<pre><code>if (year % 400 == 0)leap = 0; 
</code></pre>

<p>should be </p>

<pre><code>if (year % 400 == 0) leap = 1;
</code></pre>
",0
33561246,33561050,0,"<p>A simpler way is to mark a node as 'deleted' in a list, and delete them in one go when necessary. All you need is modify your struct by adding an extra field (e.g. 'int deleted').</p>

<p>Edit:</p>

<p>My wrong here, sorry!</p>

<p>If you want to delete a list from head to tail and tail to head, it's better that your list be doubly linked, i.e. every node must have two pointers with a 'next' pointing to the next node and a 'prev' pointing to the previous node. Otherwise it is not very efficient and convenient to traverse the list in both directions.</p>

<p>In addition, if we mark a node as 'deleted' but not really delete it. We can implement a 'clear list' method which clears the list node by node, not worrying that we might mess up with pointers, especially when the list is being used in the program.</p>
",2
33585359,33585298,0,"<p>In C, to compare strings you need to use either <code>strcmp</code> or <code>strncmp</code>.</p>

<pre><code>if (strcmp(dirname, "".."") != 0) { ... }
</code></pre>
",1
32394522,32393124,0,"<p>As Giorgi pointed out, you have to initialize <code>check</code> before you start testing its value. You also need to initialize <code>winner</code> to <code>EMPTY</code> at the start of the <code>getWinner()</code> function, otherwise if there is no winner, your function will return some unpredictable junk value and your <code>main()</code> function will probably print out the wrong result.</p>

<pre><code>int getWinner(int board[SIZE][SIZE]){
  int i;
  int j;
  int check;
  int winner=EMPTY /* &lt;&lt;&lt; */;

  for(i=0; i&lt;SIZE; i++){
    for(j=0, check=TRUE /* &lt;&lt;&lt; */; j&lt;SIZE-1 &amp;&amp; check == TRUE; j++){
      if(board[i][j] != board[i][j+1]){
        check = FALSE;
      }
    }
    if(check == TRUE &amp;&amp; j == SIZE-1){
      winner=board[i][0];
    }
  }
  for(j=0; j&lt;SIZE; j++){
    for(i=0, check=TRUE /* &lt;&lt;&lt; */; i&lt;SIZE-1 &amp;&amp; check == TRUE; i++){
      if(board[i][j] != board[i+1][j]){
        /** etc... **/
</code></pre>

<p>(Note: There's also no need to continue checking once you've found a winner, so perhaps instead of <code>winner=board[i][j];</code> you could just <code>return board[i][j];</code>. Not a big deal, though.)</p>

<p>You are also checking one of the diagonals twice (in two different directions). The other diagonal isn't being checked at all.</p>
",1
32393186,32393124,0,"<p>I did not go completely through your checking logic but here directly in <code>getWinner</code>, you are trigerring undefined behaviour:</p>

<pre><code>  for(j=0; j&lt;SIZE-1 &amp;&amp; check == TRUE; j++){
</code></pre>

<p>by <em>reading</em> <code>check</code> variable which has not been initialized (result of this is that any kind of behaviour can happen). So you may want to initialize it to default value first.</p>

<p>There are some implementationos of that game around, I suggest you look at some <a href=""https://codereview.stackexchange.com/questions/41304/4%C3%974-tic-tac-toe-in-c"">similar</a> implementation and compare against your winner checking logic for example.</p>
",3
30135239,30109738,0,"<p>user4872257. I do believe that you and I both go to the same university, mainly because we both had this problem yesterday and are both working on a program called rpcalc. The issue was with the IT department not emptying their tmp folder, I went down and spoke with them about it. The server should now be working fine, you might try once again compiling your code. Good luck!</p>
",0
31817603,31817400,0,"<p>As long as <code>two.c</code> and <code>one.c</code> properly <code>#include ""three.h""</code> then the compiler will be able to chain the dependencies together without a problem. If you wanted to run something from <code>three.c</code> in <code>coderTest.c</code> it would want you to #include it in there as well. </p>

<p>Do your files have the preprocessor directives <code>#IFNDEF</code>, <code>#DEFINE</code>, and <code>#ENDIF</code>in place to prevent duplicate importing?</p>
",1
31817605,31817400,2,"<blockquote>
  <p>Do I need to include three.c in coderTest.c, or will it take care of
  it's dependency on it's own?</p>
</blockquote>

<p>You don't need to include <code>""src/three.h""</code> in <code>coderTest.c</code>, but this does not mean, that compiler does handle dependency automagically. This header needs to be included in <code>one.c</code>, <code>two.c</code>  and <code>three.c</code>. The last one is to confirm that header's declarations and definitions match with each other properly.</p>

<p>As a result, you project might look as:</p>

<h3><code>coderTest.c</code>:</h3>

<pre><code>#include ""src/one.h""
#include ""src/two.h""
// ...
</code></pre>

<h3><code>src/one.c</code>:</h3>

<pre><code>#include ""one.h""
#include ""three.h""
// ...
</code></pre>

<h3><code>src/two.c</code>:</h3>

<pre><code>#include ""two.h""
#include ""three.h""
// ...
</code></pre>

<h3><code>src/three.c</code>:</h3>

<pre><code>#include ""three.h""
// ...
</code></pre>

<p>To prevent multiple includes of same header, use <a href=""https://en.wikipedia.org/wiki/Include_guard"" rel=""nofollow""><em>header guards</em></a> for each header file individually.</p>
",0
31817692,31817400,0,"<p>In coderTest.c, include the following:
<code>#include ""src/two.h</code>
<code>#include ""src/one.h</code></p>

<p>In one.c, include:
<code>#include ""src/three.h</code></p>

<p>In two.c, include:
<code>#include ""src/three.h</code></p>

<blockquote>
  <p>Do I need to include three.c in coderTest.c, or will it take care of it's dependency on it's own?</p>
</blockquote>

<p>No you don't need to include three.c in coderTest.c, because one.c and two.c abstract it away.</p>
",0
31817697,31817400,0,"<p>You can do what you want several ways as long as <em>visibility to necessary prototypes is provided</em>.  In addition to where best to include header files, consider  using <strong><em><a href=""https://gcc.gnu.org/onlinedocs/cpp/Once-Only-Headers.html"" rel=""nofollow"">wrappers</a></em></strong> to guarantee your header is used only once:</p>

<pre><code> #ifndef _SOMEFILE_H_
 #define _SOMEFILE_H_

     the entire file

 #endif /* SOMEFILE_H__SEEN */  
</code></pre>

<p>Also consider readability.  For example given:  coderTest.c, one.c/.h, two.c/.h, three.c/.h  are as you described:<br>
<strong><em>1)</em></strong>  You should include three.h in both one.c and two.c.<br>
<strong><em>2)</em></strong>  For coderTest.c,  #include headers of all supporting headers either in the file itself, <strong><em>or</em></strong> perhaps in a <em>collector</em> header: conderTest.h:</p>

<p><strong><em>coderTest.h:</em></strong>  </p>

<pre><code>#include ""./src/one.h""
#include ""./src/two.h""
#include ""./src/three.h""
</code></pre>

<p><strong><em>coderTest.c</em></strong>  </p>

<pre><code>#include ""coderTest.h""
</code></pre>
",0
33603773,33602051,2,"<p>This works, please read // NOTE in the code</p>

<pre><code>#define _CRT_SECURE_NO_WARNINGS
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#define PAUSE system(""pause"")
#define SIZE 365
#define FLUSH fflush(stdin)
#define CLS system(""cls"")
#define LB 0
#define UB 999

int main(  )
{
  int userInput = 0;
  int userNumber = 0;
  int count = 0;
  int userNumbers[9 + 1] = { 0 };
  int i;
  int j;
  int f;
  int winningNumbers[SIZE] = { 0 };
  int moneySpent = 3600;
  int moneyEarned = 0;
  int profitMade = 0;
  int timesWon = 0;
  int matchingNumbers[SIZE] = { 0 };
  int userNumberOne = 0;
  int userNumberTwo = 0;
  int userNumberThree = 0;
  int userNumberFour = 0;
  int userNumberFive = 0;
  int userNumberSix = 0;
  int userNumberSeven = 0;
  int userNumberEight = 0;
  int userNumberNine = 0;
  int userNumberTen = 0;
  int a = 0;
 // NOTE +1 needed below
  int lotnum[UB + 1] = { 0 };
 // NOTE some new variables here
  int most_repeated = 0;
  int tempint = 0;

  do
  {
    // Display Menu
    CLS;
    printf( ""$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n"" );
    printf( ""$$                         $$\n"" );
    printf( ""$$    THE LOTTERY GAME     $$\n"" );
    printf( ""$$                         $$\n"" );
    printf( ""$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n\n\n"" );
    printf( ""1. Enter your 10 lottery numbers. \n"" );
    printf( ""2. Play the lottery. \n"" );
    printf( ""3. Display summary of your 10 numbers. \n"" );
    printf( ""4. Display most repeated number. \n"" );
    printf( ""5. QUIT \n"" );
    printf( ""\n\nEnter your selection: "" );
    // Get User Choice
    scanf( ""%i"", &amp;userInput );
    CLS;

    srand( ( unsigned ) time( NULL ) ); // Seeds the rand function

    //Write the Switch
    switch ( userInput )
    {

    case 1:         // User inputs 10 lottery numbers to play
      for ( count; count &lt; 10; count++ )
      {             //Loops 10 times
    printf( ""\nEnter #%i of 10 for your lottery numbers [BETWEEN 0 - 999]: "", count + 1 );  // Tells u    ser to input 10 numbers
    scanf( ""%i"", &amp;userNumber ); // Gets users' 10 lottery numbers
    userNumbers[count] = userNumber;    // Stores the users' lottery numbers into an array
      }             // End for loop
      PAUSE;
      break;
    case 2:         // Plays the lottery

      for ( i = 0; i &lt; SIZE; i++ )
      {
    winningNumbers[i] = LB + rand(  ) % ( UB - LB + 1 );    // Generates 365 random lottery numbers
    printf( ""\nwN==%d"", winningNumbers[i] );

      }             // End for loop
      for ( j = 0; j &lt; SIZE; j++ )
      {
    if ( userNumbers[0] == winningNumbers[j] )
    {
      matchingNumbers[timesWon] = userNumbers[0];
      timesWon++;
      userNumberOne++;
    }
    else if ( userNumbers[1] == winningNumbers[j] )
    {
      matchingNumbers[timesWon] = userNumbers[1];
      timesWon++;
      userNumberTwo++;
    }
    else if ( userNumbers[2] == winningNumbers[j] )
    {
      matchingNumbers[timesWon] = userNumbers[2];
      timesWon++;
      userNumberThree++;
    }
    else if ( userNumbers[3] == winningNumbers[j] )
    {
      matchingNumbers[timesWon] = userNumbers[3];
      timesWon++;
      userNumberFour++;
    }
    else if ( userNumbers[4] == winningNumbers[j] )
    {
      matchingNumbers[timesWon] = userNumbers[4];
      timesWon++;
      userNumberFive++;
    }
    else if ( userNumbers[5] == winningNumbers[j] )
    {
      matchingNumbers[timesWon] = userNumbers[5];
      timesWon++;
      userNumberSix++;
    }
    else if ( userNumbers[6] == winningNumbers[j] )
    {
      matchingNumbers[timesWon] = userNumbers[6];
      timesWon++;
      userNumberSeven++;
    }
    else if ( userNumbers[7] == winningNumbers[j] )
    {
      matchingNumbers[timesWon] = userNumbers[7];
      timesWon++;
      userNumberEight++;
    }
    else if ( userNumbers[8] == winningNumbers[j] )
    {
      matchingNumbers[timesWon] = userNumbers[8];
      timesWon++;
      userNumberNine++;
    }
    else if ( userNumbers[9] == winningNumbers[j] )
    {
      matchingNumbers[timesWon] = userNumbers[9];
      timesWon++;
      userNumberTen++;
    }
      }             // End for loop
      printf( ""You WON the lottery %i times!\n\n"", timesWon );
      printf( ""Your winning numbers are: \n"" );
      for ( f = 0; f &lt; timesWon; f++ )
      {
    printf( ""%i \n"", matchingNumbers[f] );
      }             // End for loop
      moneyEarned = 500 * timesWon;
      profitMade = moneyEarned - moneySpent;
      printf( ""\n\n"" );
      printf( ""You WON $%i total!\n"", moneyEarned );
      printf( ""You spent $%i total.\n"", moneySpent );
      printf( ""Your profit is $%i! \n\n"", profitMade );
      PAUSE;
      break;
    case 3:         // Displays summary of the user's 10 numbers
      printf( ""$$$$ Your lottery number summary $$$$\n\n"" );
      printf( ""Lottery number %i won %i times.\n"", userNumbers[0],
          userNumberOne );
      printf( ""Lottery number %i won %i times.\n"", userNumbers[1],
          userNumberTwo );
      printf( ""Lottery number %i won %i times.\n"", userNumbers[2],
          userNumberThree );
      printf( ""Lottery number %i won %i times.\n"", userNumbers[3],
          userNumberFour );
      printf( ""Lottery number %i won %i times.\n"", userNumbers[4],
          userNumberFive );
      printf( ""Lottery number %i won %i times.\n"", userNumbers[5],
          userNumberSix );
      printf( ""Lottery number %i won %i times.\n"", userNumbers[6],
          userNumberSeven );
      printf( ""Lottery number %i won %i times.\n"", userNumbers[7],
          userNumberEight );
      printf( ""Lottery number %i won %i times.\n"", userNumbers[8],
          userNumberNine );
      printf( ""Lottery number %i won %i times.\n\n\n"", userNumbers[9],
          userNumberTen );
      PAUSE;
      break;

    case 4:         // Displays most repeated number

      for ( i = 0; i &lt; SIZE; i++ )
      {
    tempint = winningNumbers[i]; // NOTE could be shorter, but this is easier to read
    lotnum[tempint]++;

    printf( ""\n lotnum[%d]==%d"", tempint, lotnum[tempint] );  // NOTE switch off this line after you understand it
      }
      most_repeated = 0;
      for ( i = 0; i &lt; UB; i++ )
         if ( lotnum[i] &gt; most_repeated )
            most_repeated = i;

      printf( ""\nMost repeated number==%d\n"", most_repeated );
      // NOTE : you could have multiple numbers with same score

      PAUSE;
      break;
    case 5:         // QUIT
      printf( ""Thank you for playing the lottery game!\n\n"" );
      break;
    }               //End Switch
  }
  while ( userInput != 5 );
  PAUSE;

}               // End main
</code></pre>
",0
28236368,28236326,0,"<p>You have to include <code>&lt;string.h&gt;</code> or <code>&lt;cstring&gt;</code> to compile this code in gcc for the <code>strcpy()</code> function.</p>

<p>Also, you need to increase the size of your array to fit <code>""DefaultName""</code>, so ideally your <code>myname</code> array should be of size <code>strlen(""DefaultName"")+1</code>. Also, change </p>

<pre><code>scanf(""%s"",&amp;myname);
</code></pre>

<p>to</p>

<pre><code>scanf(""%s"",myname);
</code></pre>

<p>because <code>myname</code> is already a <em>pointer</em> pointing to the first element of the <code>char</code> array.</p>
",0
28236369,28236326,1,"<p>Because your code exhibits Undefined Behavior which means that anything can happen. This is because you try to copy <code>""DefaultName""</code> that has more than 10 bytes(12 bytes including the <code>\0</code> character at the end of the string) into <code>myname</code> that can hold atmost 9 characters +1 for the <code>\0</code> at the end. Also,</p>

<pre><code>scanf(""%s"",&amp;myname);
</code></pre>

<p>Should be</p>

<pre><code>scanf(""%s"",myname);
</code></pre>

<p>This is because the name of an array decays to a pointer to its first element(<code>char*</code>) which is the same as</p>

<pre><code>scanf(""%s"",&amp;myname[0]);
</code></pre>

<p>Increase the safety by limiting the amount of characters that <code>scanf</code> reads so that you prevent buffer overflows by using</p>

<pre><code>scanf(""%9s"",myname);
</code></pre>

<p>Also, you need to include <code>string.h</code> in order to use the <code>strcpy</code> function. You also need to know that <code>main()</code> isn't a valid declaration. It needs to be either</p>

<pre><code>int main()
</code></pre>

<p>Or</p>

<pre><code>int main(void)
</code></pre>

<p>in newer standards of C(C99,C11). You also need to supply </p>

<pre><code>return 0;
</code></pre>

<p>at the end of the function. Usually, a program returns 0 on success and 1 on failure(due to some problem).</p>
",0
28236375,28236326,0,"<pre><code>strcpy(myname,""DefaultName"");
</code></pre>

<p>The mistake is here please make sure the string fits into the array before using <code>strcpy()</code> safer is to use <code>strlcpy()</code></p>

<p>Your array can just hold 10 characters including <code>\0</code> but you are trying to write more characters to it than it can hold leading to undefined behavior.</p>

<p>Make sure your array can hold the data which you are trying to write or use a safer function like <code>memcpy()</code> or <code>strlcpy()</code>(Not a standard) which takes care of buffer overflow.</p>
",0
28236418,28236326,1,"<p>You have to remember that strings in C doesn't really have a length, so it uses a special character to tell the end of the string, the so-called ""null"" character (<code>'\0'</code>).</p>

<p>So if you have an array of ten characters, it can only hold a string of <em>nine</em> characters since there must be space for the terminator character as well.</p>

<p>The string <code>""DefaultName""</code> is <em>twelve</em> character including the string terminator, and when you copy it over to your array you will write beyond the limits of the array, and that leads to <a href=""http://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow""><em>undefined behavior</em></a>. If you increase the size of the array by two characters, the string will fit, but it will only fit strings eleven (not including terminator) characters or less.</p>

<p>Side note: The string literal <code>""DefaultName""</code> is actually a pointer to a constant array of twelve characters, whose contents is <code>""DefaultName\0""</code>.</p>

<p>Another side note: Arrays decays to pointers to their first element, so you don't have to use the address-of <code>&amp;</code> operator on arrays when passing them to functions. In fact, I consider it to be a bad habit to use the address-of operator when passing variables supposed to hold strings as arguments to functions. The reason is that often when you programming in C you will be handling pointers instead of arrays, and if you by mistake use the address-of operator on a pointer you will again ave <em>undefined behavior</em> and you then pass a pointer <em>to the pointer</em>.</p>
",0
28189010,28188752,1,"<p>Only way I can think of is:</p>

<pre><code>bool prime(const int i) 
{
  assert(i &gt;= 0);
  return char_array_odd_primes_const[i / 8] &amp; (1U &lt;&lt; (i % 8)) ? true : false;
}
</code></pre>

<p>Where <code>char_array_primes_const</code> contains 2<sup>31</sup> bits which are set to 1 for prime numbers and 0 for non-prime.</p>

<hr>

<p>More efficient would be:</p>

<pre><code>bool prime(const int i) 
{
  assert(i &gt;= 0);
  if(2 == i) return true;
  if(i % 2) return false;
  return char_array_primes_const[i / 16] &amp; (1U &lt;&lt; ((i/2) % 8)) ? true : false;
}
</code></pre>
",0
28189149,28188752,0,"<p>Randomized Algorithms are known to exist for determining whether a no. is prime or not (and <strong><em>most probably they use only a single input</em></strong>(i do not have idead regarding <em>all</em> such algorithms), i.e., the number itself that is to be tested for its primality). These algorithms are proven to be accurate in <strong><em>maximum</em></strong> no. of situations, i.e., the probability with which they can give the correct result is very high(although not 100% like the usual deterministic algorithms that are written). If you want, you can use them.</p>

<p>Refer to the following link for more details:<br>
<a href=""http://en.wikipedia.org/wiki/Primality_test#Probabilistic_tests"" rel=""nofollow"">http://en.wikipedia.org/wiki/Primality_test#Probabilistic_tests</a> </p>
",0
28189158,28188752,2,"<p>With an auxiliary function it should be more or less easy, although terrible innefficient:</p>

<pre><code>bool prime(const int i) 
{
    prime_aux(i, i-1);
}

bool prime_aux(const int i, const int d)
{
    if (d == 1) return true;
    if (i % d == 0) return false;
    return prime_aux(i, d - 1);
}
</code></pre>

<p>There are some easy optimizations out there, but I omitted them because the code is prettier this way. Also some checks to the input parameters may be needed before proceeding.</p>
",0
30142435,30142253,-1,"<p>As <code>m-2</code> is constant, write <code>m= m-2;</code> before the loop. Now, what remains is that n times <code>prod=prod*m;</code> is executed. This is equivalent to <code>prod= prod*pow(m,n);</code> The math library may have an efficient implementation of pow() that will prevent your timing issue.</p>

<p>In C you may have to cast the parameters to double, and the return value to long int.</p>

<pre><code>int anti_palindrome(long int n,long int m,int mod)
{
    int prod;
    prod=m;
    if(prod&gt;1)
        prod=prod*(m-1);
    if(prod&gt;2)
    {
        n=n-2;
        m=m-2;
        prod= prod*pow(m,n);
    }
    return prod%mod;
}
</code></pre>
",0
30142834,30142253,1,"<blockquote>
  <p>Please help me which part makes my code slower.</p>
</blockquote>

<p>There aren't many parts to consider.  Generally speaking, I/O is much slower than computation, but you haven't any more I/O than is needed, so let's disregard that for the moment.</p>

<p>Consider, then, your <code>anti_palindrome()</code> function.  In the general case, it loops <code>N</code> times, performing three arithmetic operations and two assignments in each iteration.  That's not expensive on a per-iteration basis, but you may have a billion iterations per test case, and ten thousand test cases, for a total of around 5x10<sup>14</sup> mixed operations.  That number of operations is going to take more than a few seconds.</p>

<p>While I'm at it, I observe that your algorithm is wrong anyway.  You are supposed to report the answer modulo 10<sup>9</sup> + 7, but long before you get to the end of the computation, you will have overflowed the <code>prod</code> variable.  The resulting behavior is undefined.  If prod had an unsigned type then the behavior would be defined, but still wrong.  Switching to <code>pow()</code> instead of a loop would improve the performance enormously, but would not solve this problem.  You need something cleverer.</p>
",1
28162953,28162899,0,"<p>Create a <code>static</code> variable in the function and print it.</p>

<pre><code>void counter(void)
{
    static int num;
    printf(""%d\n"",++num);
}
</code></pre>

<p><code>static</code> is essential because <code>static</code> variables exist as long as the program does. So, the variable still exists once the function ends. Also, <code>static</code> variables are automatically initialized to 0 when the program starts.</p>
",0
28162962,28162899,0,"<p>Your <code>counter()</code> function needs to maintain state. You probably want to use the <code>static</code> keyword.</p>

<p>In a real-world non-homework situation, I would advise against doing it this way. Hidden state almost always leads to complexity and makes it difficult to unit test your functions.</p>
",0
28197753,28197649,24,"<p><code>fread()</code> returns the number of bytes read. You can loop until that's 0.</p>
<pre><code>FILE *file = NULL;
unsigned char buffer[1024];  // array of bytes, not pointers-to-bytes
size_t bytesRead = 0;

file = fopen(myfile, &quot;rb&quot;);   

if (file != NULL)    
{
  // read up to sizeof(buffer) bytes
  while ((bytesRead = fread(buffer, 1, sizeof(buffer), file)) &gt; 0)
  {
    // process bytesRead worth of data in buffer
  }
}
</code></pre>
",3
32982689,32982589,1,"<blockquote>
  <p>1) Which one is the main function?</p>
</blockquote>

<p>The one named <code>main</code>.</p>

<blockquote>
  <p>2) Is the problem asking me to finish up the code so that it produces the desired result?</p>
</blockquote>

<p>No, it's asking you to act like the computer and ""run the program"" on paper and say what it would output.</p>

<blockquote>
  <p>3) Also, ""show the values of a, b, c in FindSum immediately after executing each function call to FindSum"" Where is the function call to findsum</p>
</blockquote>

<p>They're marked with comments in the code. Search for ""call to FindSum"".</p>
",0
32982699,32982589,0,"<p>It's important to understand the basic structure of a program.  Including how functions work and the difference between pass by value and pass by reference.  Understanding this is key towards answering these questions.  The ""int main(void)"" line is the main function declaration.  The left and right brackets define it's scope.  Note the values of the variables a,b,c,x,y,&amp;z at the beginning.  Write them on a piece of paper.  The FindSum function takes in two parameters and outputs one parameter.  Perform the calculation and write down your results.  This answers the first part of the question.  Then step through line of code and write down the results after each call to FindSum.  This is not asking for you to modify the code, but simply execute what the computer would compute.</p>
",0
28204109,28203943,0,"<p>When you say the <em>'the y and z bytes of x'</em> this implies x is an array of bytes, not an integer. If so:</p>

<pre><code>x[z] ^= x[y];
x[y] ^= x[z];
x[z] ^= x[y];
</code></pre>

<p>will do the trick, by swapping <code>x[y]</code> and <code>x[z]</code> </p>

<p>After your edit, it appears you want to swap individual bytes of a 32 bit integer:</p>

<p>On a little-endian machine:</p>

<pre><code>int
swapbytes (int x, int y, int z)
{
    char *b = (char *)&amp;x;
    b[z] ^= b[y];
    b[y] ^= b[z];
    b[z] ^= b[y];
    return x;
}
</code></pre>

<p>On a big-endian machine:</p>

<pre><code>int
swapbytes (int x, int y, int z)
{
    char *b = (char *)&amp;x;
    b[3-z] ^= b[3-y];
    b[3-y] ^= b[3-z];
    b[3-z] ^= b[3-y];
    return x;
}
</code></pre>

<p>With a strict interpretation of the rules, you don't even need the xor trick:</p>

<pre><code>int
swapbytes (int x, int y, int z)
{
    char *b = (char *)&amp;x;
    char tmp = b[z];
    b[z] = b[y];
    b[y] = tmp;
    return x;
}
</code></pre>

<p>On a big-endian machine:</p>

<pre><code>int
swapbytes (int x, int y, int z)
{
    char *b = (char *)&amp;x;
    char tmp = b[3-z];
    b[3-z] = b[3-y];
    b[3-y] = tmp;
    return x;
}
</code></pre>

<p>If you want to do it using bit shifts (note <code>&lt;&lt;3</code> multiplies by 8):</p>

<pre><code>int
swapbytes (unsigned int x, int y, int z)
{
    unsigned int masky = 0xff &lt;&lt; (y&lt;&lt;3);
    unsigned int maskz = 0xff &lt;&lt; (z&lt;&lt;3);
    unsigned int origy = (x &amp; masky) &gt;&gt; (y&lt;&lt;3);
    unsigned int origz = (x &amp; maskz) &gt;&gt; (z&lt;&lt;3);
    return (x &amp; ~masky &amp; ~maskz) | (origz &lt;&lt; (y&lt;&lt;3)) | (origy &lt;&lt; (z&lt;&lt;3));
}
</code></pre>
",2
28204778,28203943,1,"<p>Extract the ith byte by using <code>((1ll &lt;&lt; ((i + 1) * 8)) - 1) &gt;&gt; (i * 8)</code>. Swap using the XOR operator, and put the swapped bytes in their places.</p>

<pre><code>int x, y, z;
y = 1, z = 3;
x = 0x12345678;

int a, b; /* bytes to swap */
a = (x &amp; ((1ll &lt;&lt; ((y + 1) * 8)) - 1)) &gt;&gt; (y * 8);
b = (x &amp; ((1ll &lt;&lt; ((z + 1) * 8)) - 1)) &gt;&gt; (z * 8);

/* swap */
a = a ^ b;
b = a ^ b;
a = a ^ b;

/* put zeros in bytes to swap */
x = x &amp; (~((0xff &lt;&lt; (y * 8))));
x = x &amp; (~((0xff &lt;&lt; (z * 8))));

/* put new bytes in place */
x = x | (a &lt;&lt; (y * 8));
x = x | (b &lt;&lt; (z * 8));
</code></pre>
",0
29237781,29237670,0,"<p>I think you want a dictionary or <a href=""https://en.wikipedia.org/wiki/Hash_table"" rel=""nofollow"">hashtable</a>:</p>

<ul>
<li>Use <code>buff</code> as string key</li>
<li>Use function pointer as values</li>
</ul>
",1
29238129,29237670,1,"<p>I created a code to illustrate what you wanted to do, because I it's pretty entertaining.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

// your functions
void my_ls()  { puts(""fun:my_ls"")  ;}
void my_cd()  { puts(""fun:my_cd"")  ;}
void my_user(){ puts(""fun:my_user"");}
void my_pwd() { puts(""fun:my_pwd"") ;}
void my_quit(){ puts(""fun:my_quit"");}


int main(int argc, char const *argv[])
{
    char* buff=""ls\n""; // the string you have to compare

    void (*tab[5]) (void)={my_ls,my_cd,my_user,my_pwd,my_quit};
    char *names[5]={""ls\n"",""cd\n"",""user\n"",""pwd\n"",""quit\n""};

    int i;
    for (i=0; i&lt;5; i++)
    {
        if(strncmp(buff,names[i],strlen(names[i]) )==0){
            tab[i]();
            return 0;
        }
    }
    return 0;
}
</code></pre>

<p>There are other ways to write it. Actually <code>my_function</code> is the same as <code>&amp;my_function</code> since a function name alone is converted to the adress of the function.
Also <code>tab[i]()</code> is equivalent to <code>(*tab[i])()</code>... Those are weird behaviours but I think it's specified by C standard</p>
",0
29238189,29237670,1,"<p>There's no problem with an array of function pointers, but you'd need to convert the sequence of boolean strncmp() results to a single index.</p>

<p>If the list is long, the hash table idea might be a winner.  For compact, simple code and easy maintenance, I've used an array of structs:</p>

<pre><code>typedef struct cmdtable_t
{
    void (*fptr)();
    unsigned char length
    char name[11];
} cmdtable_t, *pcmdtable_t;

cmd_table_t commands = {
    { my_ls,   2, ""ls""},
    { my_cd,   2, ""cd"" },
    { my_user, 4, ""user"" },
    ...etc.
};
</code></pre>

<p>That could also be what a hash table entry looks like, could be sorted in advance to allow a binary search, or simply sequentially searched for a KISS version until you find out whether this needs optimizing at all.</p>
",0
28242609,28242537,0,"<p>your g_arg pointers info1 and info2 need to be tied to some memory to be able to assign to them latter.</p>

<p>Since those are pointers, you cannot assign one string to another, so use some thing like strcpy.</p>

<p>Also if you know the sizes, you can make info1 and info2 as char arrays instead of having to dynamically allocate memory for them.</p>
",5
28242612,28242537,0,"<p>Point 1. allocate memory to <code>g.info1</code> using <a href=""http://linux.die.net/man/3/malloc"" rel=""nofollow""><code>malloc()</code></a> [or family].</p>

<p>Point 2 . use <a href=""http://linux.die.net/man/3/strcpy"" rel=""nofollow""><code>strcpy()</code></a> to copy the data to <code>d[0].value</code></p>

<p>Point 3. You don't need to use <code>&amp;g.info1</code>, <code>g.info1</code> will suffice.</p>
",0
28242930,28242537,0,"<p>In your code, <code>g.info1</code> has type <code>char *</code>, so <code>&amp;g.info1</code> has type <code>char **</code>.  You can certainly assign that to the <code>void *</code> element <code>value</code> of a <code>struct data</code>, but it is a <em>pointer</em> to a (maybe) string, not a string itself.</p>

<p>Moreover, the result is a pointer to a stack-allocated pointer.  If this pointer value survives past the end of the function then it will cease to be valid, and any attempt to dereference it will produce undefined behavior.</p>

<p>If you want to <em>copy</em> string values into elements of array <code>d</code> instead of assigning pointers to them as you now do, then you must first have strings to copy.  In that case, you can use <code>strdup()</code> to allocate space and copy the string in one step:</p>

<pre><code>struct g_arg g = { ""info 1"", ""info 2"", 42 };

struct data d[] = {
    {""info1="", NULL},
    {""info2="", NULL},
    {""info3="", NULL},
    {NULL, NULL},
};
d[0].value = strdup(g.info1);
d[1].value = strdup(g.info2);
d[2].value = malloc(sizeof(int));
*((int *) d[2].value) = g.info3;
</code></pre>

<p>Note that in this case, all the resulting pointers recorded in the <code>value</code> members of elements of <code>d</code> refer to dynamically allocated memory.  This allows them to remain valid past the function's exit, but it requires the program to later <code>free()</code> them to avoid leaking memory.</p>
",0
28243794,28242537,0,"<p>wrt to <code>d[0].value = some_info;</code> this would in theory work if some_info was already an object of type <code>struct g_arg</code> whose member <code>info1</code> was already set to a string.</p>

<p>But it seems that you want <code>some_info</code> to be a string (<code>char *</code>, C style);</p>

<p>So you'll need to reference the <code>info1</code> member of <code>d[0].value</code>.  So you'll need to cast the <code>void*</code> to the appropriate data type <code>(struct g_arg *)(d[0].value)</code> and then access the member <code>info1</code>, like so: <code>((struct g_arg *)(d[0].value))-&gt;info1</code>.</p>

<p>Since info1 is a char * you should use <code>strdup()</code> to copy the string into an appropriately allocated buffer or manually allocate the memory for the string before copying.  You end up with this:</p>

<p><code>((struct g_arg *)(d[0].value))-&gt;info1 = strdup(some_info);</code></p>

<p>Remember to <code>free()</code> the memory when you're done.</p>
",0
34185570,34184826,1,"<p>Functions <code>read()</code> and <code>write()</code> and their cousins are used for binary files. Reading a text file would be better using <code>fgets()</code> and analysing the contents of each line, then outputting that line with the extra fields you calculate. Bear in mind that <code>fgets()</code> retains any <code>newline</code>, which has to be removed before appending text to that line.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define LLEN 100

int main(void)
{
    FILE *inf, *outf;
    int val1, val2, val3, sum;
    char buff[LLEN];

    if((inf = fopen(""input.txt"", ""rt"")) == NULL) {
        perror(""Can't open file input.txt"");
        exit(1);
    }
    if((outf = fopen(""output.txt"", ""wt"")) == NULL) {
        perror(""Can\t open file output.txt"");
        exit(1);
    }

    if(fgets(buff, LLEN, inf) == NULL) {            // read the header
        perror(""Cannot read header line"");
        exit(1);
    }
    buff [ strcspn(buff, ""\r\n"") ] = '\0';          // truncate any newline
    fprintf(outf, ""%s sum     average\n"", buff);    // write expanded header line

    while(fgets(buff, LLEN, inf) != NULL) {         // read each line
        buff [ strcspn(buff, ""\r\n"") ] = '\0';      // truncate any newline
        if(sscanf(buff, ""%*s%d%d%d"", &amp;val1, &amp;val2, &amp;val3) != 3) {   // ignore ID
            perror(""Cannot convert fields"");
            exit(1);
        }
        sum = val1 + val2 + val3;
        fprintf(outf, ""%s%9d%7d \n"", buff, sum, sum/3);
    }

    if (fclose(outf))
        perror(""Unable to close output file"");
    fclose(inf); 
    return 0;
}
</code></pre>

<p>Output file:</p>

<pre><code>ID              UNIX    C Language      Network sum     average
20150001        98      95              97      290     96 
20150002        84      88              90      262     87 
</code></pre>

<p>Incidentally your average was incorrect on the last line!</p>
",4
33022588,33022491,1,"<p>I believe the author meant you can declare a variable anywhere as long as it is before using it, it may be anywhere in the file and not only at the beginning of it. </p>
",0
33022689,33022491,2,"<p>It means the variable can appear at file scope but also at block scope. </p>

<pre><code>void foo(void)
{
    extern int x;
    x = 42;
}
</code></pre>

<p>The author didn't mean that the variable can be declared after it is used.</p>
",0
28526673,28526653,2,"<p><code>c</code> is defined to be a <code>char</code> and <code>"" ""</code> is a ""string"" literal, which in C is implemtned as an array of <code>char</code>s, which in turn decays to a pointer to it's 1st element, that is  a <code>char *</code>.</p>

<p>To fix this compare <code>c</code> to a <code>char</code>.</p>

<pre><code>if (c != ' ')  /* Use ' to code a char literal, use "" to code a string literal. ""/
</code></pre>

<hr>

<p>Also as you assign the result of <a href=""http://man7.org/linux/man-pages/man3/ungetc.3.html"" rel=""nofollow""><code>fgetc()</code></a> to <code>c</code> and test <code>c</code> against <code>EOF</code> (which typically is <code>-1</code>) make <code>c</code> an <code>int</code>, that is make it the type <code>fgetc()</code> returns.</p>
",0
28526698,28526653,-1,"<p>You compare <code>char</code> with <code>char *</code>. You can not do it, and set <code>c</code> to be <code>signed char</code> because it need to store <code>EOF</code>. It depends on compiler does <code>char</code> will <code>signed</code> or <code>unsigned</code>, so you can't know.
It need to be like this: </p>

<pre><code>if(c!= ' ')
  {
    a[i][j]=c;
    j++;
   }
</code></pre>
",6
33020926,33020791,2,"<p>To answer the first part</p>

<blockquote>
  <p><em>Automatic arrays, unlike automatic variables, cannot be initialized</em></p>
</blockquote>

<p><sup>assuming the <em>""Automatic arrays""</em> are actually <em>""array data structure of automatic storage duration whose length is determined at run time""</em></sup> </p>

<p>Yes, here what is referred to is called a <a href=""https://en.wikipedia.org/wiki/Variable-length_array"" rel=""nofollow"">variable length array</a>. It cannot be initialized as for the simple logic, the size is determined at runtime.</p>

<p>To quote the <code>C11</code> standard, chapter ¡ì6.7.9, <em>Initialization</em> (emphasis mine)</p>

<blockquote>
  <p>The <strong>type of the entity to be initialized</strong> shall be an array of unknown size or a complete object type that is <strong>not a variable length array type.</strong></p>
</blockquote>

<p>Otherwise, for a local variable without any storage class specifier, defaults to <code>auto</code> and an <em>automatic array</em> of non-VLA type, <strong>can be</strong> initialized, for sure.</p>
",3
33021441,33020791,2,"<p>Trivial demonstration that the statement is actually <em>wrong</em> (as opposed to e.g. array-initialization being a common but non-standard extension):</p>

<pre><code>void doSomethingWithArray(size_t sz, int arr[static sz]);

int main(void) {
    doSomethingWithArray(5,
        (int[]){ 1, 2, 3, 4, 5 }
    );
}
</code></pre>

<p>An anonymous array is created with automatic storage duration within the scope of <code>main</code>. Since it is anonymous, there is no way for code within <code>main</code> to refer to it to set element values. The <em>only</em> way to put values into this particular automatic array is via initialization. This feature - being able to initialize automatic arrays - is therefore legal, standard, and necessary.</p>

<p>QED.</p>
",1
32395695,32395509,1,"<p>When you have a recursive function the statements following the recursive call are pushed to the stack.</p>

<p>So the statement after <code>sum(x+1)</code> is the <code>printf()</code> which is pushed to the stack and retrieved when you return from the function.</p>

<p>When you call <code>sum(2+1)</code> </p>

<pre><code>printf(""\nvalue of x after is %d"",x);/* x =2 */
</code></pre>

<p>is pushed to the stack. So the last push will be <code>printf()</code> with <code>x=8</code></p>
",0
32395778,32395509,1,"<p>Each call to <code>sum(i)</code> is replaced by</p>

<pre><code>print value of x before is i
call sum(i + 1)
print value of x after is i
</code></pre>

<p>which is then replaced by</p>

<pre><code>print value of x before is i

print value of x before is i + 1
call sum(i + 2)
print value of x after is i + 1

print value of x after is i

. . .
</code></pre>

<p>until i reaches the value 8. With the help of print statements, it is self explanatory.</p>
",0
32400398,32395509,0,"<p>Look at this code:</p>

<pre><code>#include&lt;stdio.h&gt;

void p(int x) {
    while(x--) putchar(' ');
}

void sum(int x)
{
    if(x==9)
        return;

    p(x); printf(""value of x before is %d\n"",x);

    /* recursive calling of Sum() function */

    sum(x+1);

    p(x); printf(""value of x after is %d\n"",x);
}

int main()
{    
    sum(2);
}
</code></pre>

<p>Will output this:</p>

<pre><code>$ ./rec
  value of x before is 2
   value of x before is 3
    value of x before is 4
     value of x before is 5
      value of x before is 6
       value of x before is 7
        value of x before is 8
        value of x after is 8
       value of x after is 7
      value of x after is 6
     value of x after is 5
    value of x after is 4
   value of x after is 3
  value of x after is 2
</code></pre>

<p>What this means is that the function calls are behaving like the following:</p>

<pre><code> sum(2)
 2  is 2 == 9? NO
 2  print before
 2  sum(3)
 2  3   is 3 == 9? NO
 2  3   print before
 2  3   sum(4)
 2  3   4   is 4 == 9? NO
 2  3   4   print before
 2  3   4   sum(5)
 2  3   4   5   is 5 == 9? NO
 2  3   4   5   print before
 2  3   4   5   sum(6)
 2  3   4   5   6   is 6 == 9 ? NO
 2  3   4   5   6   print before
 2  3   4   5   6   sum(7)
 2  3   4   5   6   7   is 7 == 9 ? NO
 2  3   4   5   6   7   print before
 2  3   4   5   6   7   sum(8) 
 2  3   4   5   6   7   8       is 8 == 9 NO
 2  3   4   5   6   7   8       print before
 2  3   4   5   6   7   8       sum(9)
 2  3   4   5   6   7   8       9   is 9 == 9? YES 
 2  3   4   5   6   7   8       9   RETURN  
 2  3   4   5   6   7   print after
 2  3   4   5   6   7   RETURN
 2  3   4   5   6   print after
 2  3   4   5   6   RETURN
 2  3   4   5   print after
 2  3   4   5   RETURN
 2  3   4   print after
 2  3   4   RETURN
 2  3   print after
 2  3   RETURN
 2  print after
 2  RETURN

 main continues here
</code></pre>

<p>The leading number indicate ""which"" <code>sum()</code> function you're. It's the value of <code>x</code> inside that function. </p>

<p>Furthermore, note that the function with value 3 is ""inside"" the function with value 2. And function with value 4 is ""inside"" the function with value 3.</p>

<p>I say inside because the <a href=""https://en.wikipedia.org/wiki/Call_stack"" rel=""nofollow"">stack frames</a> of subsequent function calls lives within the stack frame of the caller function. However, this <strong>does not mean that recursive called functions can access their caller's data</strong>. To do that, you must use pointers like any other function call.</p>
",0
32444960,32444841,-1,"<p>You are using <code>j</code> as the prime number variable, so the problem is that your are making an incremental operation for <code>j</code> before printing. The correct example would be:</p>

<pre><code>#include &lt;stdio.h&gt;
#include&lt;conio.h&gt;

int main()
{
    int count,n,counte=0,j=2,i;
    printf(""enter a number of prime numbers to print:"");
    scanf(""%d"",&amp;n);
    for(counte=1;counte&lt;=n;)//for no.of prime numbers to be printed
    {
        while(j&lt;=(j+1))
        {
            count=0;
            for(i=1;i&lt;=j;i++)
            {
                if((j%i)==0)
                {
                    count++;
                }
            }

            // Here was incremental.

            if(count==2)

            {
                printf(""%d \n"",j);
                counte++;

                break;
            }

            j++; //Here is now.


        }
    }

    getch();
    return 0;
}   
</code></pre>
",2
32446239,32444841,0,"<p>the following code:</p>

<pre><code>compiles cleanly
performs the desired operation
checks for errors
is consistently indented


#include &lt;stdio.h&gt;
//#include&lt;conio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    int count;
    int n;
    int counte=0;
    int j=2; // number to test to see if it is prime
    int i;

    printf(""enter a number of prime numbers to print:"");
    if( 1 != scanf(""%d"",&amp;n) )
    { // then scanf failed
        perror( ""scanf failed"" );
        exit( EXIT_FAILURE );
    }

    // implied else, scanf successful

    if( 0 &gt; n )
    {
        printf( ""positive counts only\n"");
        exit( EXIT_FAILURE );
    }

    // implied else, num primes to print is positive

    for(counte=0, j=2; counte&lt;n; j++)//for no.of prime numbers to be printed
    {
        count=0;

        for(i=1;i&lt;=j;i++)
        {
            if((j%i)==0)
            {
                count++;
            }
        }


        if(2 == count)
        {
            printf(""%d \n"",j);
            counte++;
        }
    } // end for

    getchar(); // gets leftover newline
    getchar(); // waits for user to hit a key
    return 0;
}
</code></pre>
",1
32408677,32408598,1,"<p>You have a good framework but there are two flaws in your program. First of all, <code>scanf</code> takes a pointer to the variables it reads into so as to be able to alter their values, but <code>printf</code> does not require a pointer, just the value. Secondly, you should print the value you want, not some other value. The line</p>

<pre><code>printf(""The APY is: %.4lf\n"", &amp;nominalIntRate);
</code></pre>

<p>should read</p>

<pre><code>printf(""The APY is: %.4lf\n"", apy);
</code></pre>
",2
34235863,34235812,1,"<p>When you initialize a char pointer with a string literal the compiler may store the string in read-only memory. If you really want to have the string be modifiable then try storing it on the local stack:</p>

<pre><code>Char q[]=""Bye"";
</code></pre>
",0
28467940,28467858,-1,"<p>I have a magic crystal ball which says:</p>

<pre><code>int is_builtin(command_t* command) {
    return (command-&gt;flags &amp; CMD_BUILT_IN) != 0;
}
</code></pre>

<p>Try that! You might have to define <code>flags</code> in the <code>command_t</code> structure, and populate that at the time the <code>command_t</code> object is instantiated from parsing the command input. Also, to supply the <code>CMD_BUILT_IN</code> constant in some header file somewhere.</p>
",0
32413519,32413248,2,"<p><code>/</code> is not an escape character. The escape character is <code>\</code>. With <code>\</code> you make clear that your intention is to use the next character, <code>n</code> as a newline, not as an n letter. So, use <code>\n</code>:</p>

<pre><code>printf(""Your gross salary is: %0.2f \n"", GS);
printf(""The amount of your income tax is: %0.2f \n"", Taxes);
printf(""Your net salary is: %0.2f \n"", NS);
</code></pre>
",0
32413312,32413248,5,"<p><code>/n</code> isn't a newline character. It is a two character sequence, with a <code>/</code> followed by a <code>n</code>. You need character <code>\n</code>.</p>
",0
32416446,32416335,3,"<p>You are not breaking the input taking loop. 
Use <code>while ( scanf (""%d %d"", &amp;a, &amp;b) != EOF )</code> when taking <code>a,b</code>in <code>main()</code>.
You should break the input taking loop otherwise it waits for more input.</p>

<pre><code>int main()
{
    int a,b;
    while(scanf (""%d %d"", &amp;a, &amp;b) != EOF )
    {
       int max;
       max=execute(a, b);
       printf(""%d %d %d\n"", a, b, max);
    }
    return 0;
}
</code></pre>
",1
32433710,32432596,1,"<p>What that warning is saying is that the compiler, is not always happy accepting your function as inline, or it wants it to be declared as inline. </p>

<p>I guess it's that <code>__attribute__ ((always_inline))</code> implies <code>inline</code> - in which case the parsing of the attribute needs to set <code>DECL_DECLARED_INLINE_P</code>.</p>

<p>The GCC manual specifies </p>

<blockquote>
  <p>always_inline Generally, functions are not inlined unless optimization is specified. For functions declared inline, this attribute inlines the function even if no optimization level is specified.</p>
</blockquote>

<p>Here's the <code>gcc</code> <a href=""https://gcc.gnu.org/viewcvs/gcc/trunk/gcc/testsuite/gcc.dg/vmx/gcc-bug-i.c?view=markup&amp;pathrev=178730"" rel=""nofollow"">test</a> for the revision</p>
",0
32449246,32432596,2,"<h2>finally, after spending two days efforts found the solution as it is below</h2>

<p>it is just because of a compiler(arm-none-eabi-gcc) option in Makefile
<code>CFLAGS= -D inline</code> if this flag is set, it throws warning as <code>__attribute__( ( always_inline ) ) __STATIC_INLINE(inline) uint32_t __SLA (int32_t o1, int32_t o2, int32_t o3)</code> when trying to include a .h file which consists of always inline functions </p>
",3
32495731,32495668,3,"<p>Visual Studio 2013 supports C++. Headers files with a <code>.h</code> extensions are C style headers. In C++ prefix <code>c</code> before header files and remove the <code>.h</code>. Also <code>main</code> should return an <code>int</code> as per C/C++ ISO Standard.</p>

<p>Also, there is no <code>string</code> datatype in <code>C</code>. Try this:</p>

<pre><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
int main()    
{
    const char *s = ""abcd"";
    return 0;
}
</code></pre>

<p>And make you save your code file with a <code>.cpp</code> extension.</p>
",3
32934460,32934366,3,"<h1>Main issues:</h1>

<ol>
<li><p>This:</p>

<pre><code>for(i=0;i&lt;tam;i++){
arreglo=(int *)(rand()%101);
printf(""soy %d \n"",((int)(arreglo)));
arreglo++;
}
</code></pre>

<p>doesn't make any sense. You probably wanted</p>

<pre><code>for(i = 0; i &lt; tam; i++) {
    arreglo[i] = (rand() % 101);
    printf(""soy %d \n"", arreglo[i]);
}
</code></pre></li>
<li><p>Here:</p>

<pre><code>int calcular(int *_arreglo, int *_tam){
int pro=0;
int i;
_arreglo=_arreglo-(*_tam);
for(i=0;i&lt;*_tam;i++){
pro=pro+((int)(_arreglo));
_arreglo++;
}
return (pro/(*_tam));
}
</code></pre>

<p>you probably wanted</p>

<pre><code>int calcular(int *_arreglo, int *_tam){
    int pro = 0;
    int i;

    for(i = 0; i &lt; *_tam; i++){
        pro = pro + _arreglo[i];
    }

    return (pro / (*_tam));
}
</code></pre></li>
</ol>

<h1>Other issues:</h1>

<ol>
<li>You need to call seed <code>rand</code> for getting a different set of random values on each run of the program so that you don't get the same set of random numbers on each run of the program. Add <code>srand(time(NULL));</code> at the start of <code>main</code> after including <code>time.h</code>. This will return a different set of random numbers, provided that the program isn't run more than one time in the same second.</li>
<li>It doesn't make sense why you are passing <code>tam</code> by reference into <code>calcular</code>. Pass it by value instead.</li>
<li><a href=""https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc"">There is no need cast the result of <code>malloc</code> (and family)</a> in C.</li>
<li><p>Consider checking the return value of <code>malloc</code> to see if it was successful. Change:</p>

<pre><code>arreglo = (int * ) malloc(sizeof(int) * tam);
</code></pre>

<p>to</p>

<pre><code>if((arreglo = malloc(sizeof(int) * tam)) == NULL) /* If malloc failed */
{
    fputs(""malloc failed; Exiting..."", stderr); /* Print the error message in the `stderr` */
    exit(-1); /* Exit the program */
}
</code></pre></li>
</ol>
",9
32934461,32934366,1,"<p>You have a serious mistake</p>

<pre><code>arreglo = (int *) (rand() % 101);
</code></pre>

<p>is assigning a random address to the pointer <code>arreglo</code>, dereferencing it is undefined behavior.</p>

<p>Reassigning the pointer after <code>malloc()</code> will cause a memory leak, because now you can't <code>free()</code> the pointer returned by <code>malloc()</code>. Moreover, you <code>free()</code> the pointer with the invalid address assigned with <code>rand()</code>, and that is undefined behavior.</p>

<hr>

<p><strong>Some other considerations</strong></p>

<ol>
<li><p>Make your code readable to humans</p>

<ul>
<li><p>Surround operatrs with white spaces, it adds a lot of clarity to the code because otherwise it becomes difficult to differentiate between <em>tokens</em>.</p></li>
<li><p>Indent your code correctly.</p></li>
</ul></li>
<li><p>You don't need to cast <code>malloc()</code>, this also improves readability.</p></li>
<li><p>Check the pointer returned by <code>malloc()</code> for <code>NULL</code>, on error <code>malloc()</code> returns <code>NULL</code>, if you dereference a <code>NULL</code> pointer undefined behavior will occur.</p></li>
<li><p>Use <code>strtol()</code> instead of <code>atoi()</code> to check for invalid input, like this</p>

<pre><code>char *endptr;
tam = strtol(argv[1], &amp;endptr, 10);
if (*endptr != '\0')
    return -1; /* invalid input */
</code></pre></li>
</ol>
",0
30408330,30408317,2,"<p>The problem is here</p>

<pre><code>else
    if (c=!7); { . . .
</code></pre>

<p>You have a <code>;</code> after <code>if ()</code></p>

<p>I would suggest you use a <code>switch</code> statement like this</p>

<pre><code>switch (c) {
  case 2:   two_assesments(); break;
  case 3: three_assesments(); break;
  case 4:  four_assesments(); break;
  case 5:  five_assesments(); break;
  case 6:   six_assesments(); break;
  default: printf(""\nInvalid\n"");
}
</code></pre>

<p>to make your code more readable.</p>
",0
30408619,30408317,0,"<p>To understand the problem, consider what happens if the user enters <code>2</code>. The first <code>if</code> statement evaluates true and the <code>two_assesments</code> function is called. The next three <code>if</code> statements fail. Then we get to the <code>if (c==6)</code>. That also fails, so the <code>else</code> is evaluated.  And here you have two problems. </p>

<p>First is the semi-colon. Because you have a semicolon after the <code>if (c=!7)</code> the compiler sees your code as</p>

<pre><code>    if (c==6) {
        six_assesments();
    }
    else {
        if (c=!7)
            ; /* do nothing */
    }
    printf(""\nInvalid"");
</code></pre>

<p>In other words, because of the semicolon, the final <code>if</code> statement has no effect, and the <code>printf</code> isn't even part of the <code>else</code>. So ""Invalid"" always gets printed. </p>

<p>The other problem is the <code>=!</code>. What you meant to say was <code>if (c!=7)</code>. By reversing the <code>=</code> and the <code>!</code>, you actually assign <code>0</code> to <code>c</code>, and the <code>if</code> always evaluates to false. The compiler should be giving you a warning about that.</p>

<p>A slightly improved version of the code would look like this</p>

<pre><code>    if (c==2)
        two_assesments();
    else if (c==3)
        three_assesments();
    else if (c==4)
        four_assesments();
    else if (c==5)
        five_assesments();
    else if (c==6)
        six_assesments();
    else
        printf(""\nInvalid"");
</code></pre>
",0
30413193,30413077,0,"<p>Here I recommend cracking open your books or whatever other learning resources you have and babystepping a little further before you attempt to write these types of programs.</p>

<p>As you learned the hard way, when you have a large number of elements, you don't want to be writing a separate line of code for every single thing you could ever do with them on an individual basis.</p>

<p>Here you want to learn about control structures, your <code>for/while/do-while</code> loops, arrays to store elements that are indexable (allowing you to retrieve the nth element from a collection of them), possibly even file I/O and <code>structs</code> to define your own data types.</p>
",0
28440382,28440290,4,"<p>Since you increment <code>a</code> at the end of your <code>for</code> loop, once the loop has finished executing (assuming <code>num</code> is in fact prime), <code>a</code> will be equal to <code>num</code>, which means that the output ""Number is prime"" is correct.  </p>
",0
28443500,28443489,5,"<p>Because the <code>&amp;&amp;</code> operator returns a non zero value if both its operands are not zero. Maybe you mean <code>&amp;</code>.</p>

<pre><code>int a;
if (scanf(""%i"", &amp;a) == 1)
    printf(""%i"", a &amp; 1);
</code></pre>

<ul>
<li><a href=""http://en.wikipedia.org/wiki/Logical_conjunction"" rel=""nofollow""><code>&amp;&amp;</code></a> is the logical <code>AND</code> operator.</li>
<li><a href=""http://en.wikipedia.org/wiki/Bitwise_operation#AND"" rel=""nofollow""><code>&amp;</code></a> is the bitwise <code>AND</code> operator.</li>
</ul>
",3
28443546,28443489,1,"<p>Operator <code>&amp;&amp;</code> is the logical AND operator that returns true/false.
In C language false is 0 (zero) otherwise 1 (one) for true as C does not have boolean type.
So the result of your operator is correct and as expected.</p>

<p>If you insist on using bool type you can include definition for it as below</p>

<pre><code>// standard way
#include &lt;stdbool.h&gt;
</code></pre>

<p>which is basically</p>

<pre><code>#define bool _Bool
#define true 1
#define false 0
</code></pre>
",8
29487447,29487252,10,"<p>Your struct declaration is a bit muddled up, and the typedef is wrong on many levels. Here's what I'd suggest:</p>

<pre><code>//typedef + decl in one
typedef struct _memory {
    int type;
    int prot;
} Memory;
</code></pre>

<p>Then allocate like so:</p>

<pre><code>Memory *mem = malloc(sizeof *mem);
</code></pre>

<p>Read the <code>malloc</code> call like so: <em>""Allocate the amount of memory required to store whatever type <code>mem</code> is pointing to""</em>. If you change <code>Memory *mem</code> to <code>Memory **mem</code>, it'll allocate 4 or 8 bytes (depending on the platform), as it now stands it'll probably allocate 8 bytes, depending on the size of <code>int</code> and how the compiler pads the struct <a href=""http://en.wikipedia.org/wiki/Data_structure_alignment#x86"" rel=""nofollow noreferrer"">check wiki for more details and examples</a>.</p>

<p>Using <code>sizeof *&lt;the-pointer&gt;</code> is generally considered to be the better way of allocating memory, but if you want, you can write:</p>

<pre><code>Memory *mem = malloc(sizeof(Memory));
Memory *mem = malloc(sizeof(struct _memory));
</code></pre>

<p>They all do the same thing. Mind you, if you <code>typedef</code> a struct, that's probably because you want to abstract the inner workings of something, and want to write an API of sorts. In that case, you should discourage the use of <code>struct _memory</code> as much as possible, in favour of <code>Memory</code> or <code>*&lt;the-pointer&gt;</code> anyway</p>

<p>If you want to <code>typedef</code> a pointer, then you can write this:</p>

<pre><code>typedef struct _memory {
    int type;
    int prot;
} *Memory_p;
</code></pre>

<p>In which case this:</p>

<pre><code>Memory_p mem = malloc(sizeof *mem);
</code></pre>

<p>might <em>seem</em> counter intuitive, but is correct, as is:</p>

<pre><code>Memory_p mem = malloc(sizeof(struct _memory));
</code></pre>

<p>But this:</p>

<pre><code>Memory_p mem = malloc(sizeof(Memory_p));
</code></pre>

<p>is wrong (it won't allocate the memory required for the struct, but memory to store a pointer to it).</p>

<p>It's a matter of personal preference, perhaps, but I personally find <code>typedef</code>s obscure certain things. In many cases this is for the better (ie <code>FILE*</code>), but once an API starts hiding the fact you're working with pointers, I start to worry a bit. It tends to make code harder to read, debug and document...</p>

<p>Just think about it like this:</p>

<pre><code>int *pointer, stack;
</code></pre>

<p>The <code>*</code> operator modifies a variable of a given type, a pointer typedef does both. That's just my opinion, I'm sure there are many programmers that are far more skilled than me who do use pointer typedefs.<br>
Most of the time, though, a pointer <code>typedef</code> is accompanied by custom allocator functions or macro's, so you don't have to write odd-looking statements like <code>Memory_p mem = malloc(sizeof *mem);</code>, but instead you can write <code>ALLOC_MEM_P(mem, 1);</code> which could be defined as:</p>

<pre><code>#define ALLOC_MEM_P(var_name, count) Memory_p var_name = malloc(count * sizeof *var_name)
</code></pre>

<p>or something</p>
",2
29487531,29487252,2,"<p>Both</p>

<pre><code> typedef struct Memory * Memory;
</code></pre>

<p>and</p>

<pre><code> Memory mem = malloc (sizeof (Memory));
</code></pre>

<p>are wrong. The correct way to do it is :</p>

<pre><code>typedef struct memory
{
     int type;
     int prot;
} *MEMPTR;
</code></pre>

<p>or</p>

<pre><code>struct memory
{
     int type;
     int prot;
};

typedef struct memory *MEMPTR;
</code></pre>

<p>The name of the structure should be different than the name of a pointer to it.</p>
",0
29487622,29487252,2,"<p>This construction</p>

<pre><code>struct {
    int type;
    int prot;
} Memory;
</code></pre>

<p>defines an object with name <code>Memory</code> that has type of unnamed structure.</p>

<p>Thus the next construction</p>

<pre><code>typedef struct Memory *Memory;
</code></pre>

<p>defined 1) a new type <code>struct Memory</code>  that has nothing common with the definition above and the name Memory.  and 2) another new type name <code>Memory</code> that is pointer to <code>struct Memory</code>.</p>

<p>If the both constructions are present in the same compilation unit then the compiler will issue an error because name <code>Memory</code> (the name of the pointer) in the typedef declaration tries to redeclare the object of the type of the unnamed structure with the same name <code>Memory</code>.</p>

<p>I think you mean the following</p>

<pre><code>typedef struct Memory {
    int type;
    int prot;
} Memory;
</code></pre>

<p>In this case you may use the both records of using malloc like</p>

<pre><code>Memory *mem = malloc( sizeof( Memory ) );
</code></pre>

<p>and</p>

<pre><code>struct Memory *mem = malloc( sizeof( struct Memory ) );
</code></pre>

<p>or</p>

<pre><code>Memory *mem = malloc( sizeof( struct Memory ) );
</code></pre>

<p>or</p>

<pre><code>struct Memory *mem = malloc( sizeof( Memory ) );
</code></pre>

<p>because now the two identifiers Memory are in two different name spaces, The first one is used with tag <code>struct</code> and the second is used without tag struct. </p>
",2
32932550,32931171,1,"<p>Obviously your code should be:</p>

<pre><code>struct movie* search(struct movie* movie) {
    struct movie *my_list= list;        // use a local variable so not to overwrite the global list root
    while (my_list != NULL) {
        if (strcmp(movie-&gt;name, my_list-&gt;name) == 0) {
            movie-&gt;rating = my_list-&gt;rating;
            return movie;   // found
        } else {
            my_list = my_list-&gt;next;      
        }
    }
    return NULL;            // not found
}
</code></pre>

<p>Most of my changes have already been mentioned in the comments to your question.</p>
",0
34198909,34198608,2,"<p>First of all <code>128</code> is <strong>not</strong> equal to <code>-128</code> on a 8-bit platform.</p>

<p>Second this has nothing to do with the preprocessor. What the preprocessor does is to replace <code>WIDTH</code> with whatever it's defined as. That is the question is why you write <code>128</code> or <code>128u</code> in your source.</p>

<p>The suffix <code>u</code> is not about type casting, it's about to indicate the type of the literal. In this example <code>128</code> is an literal with value 128 of type <code>int</code> while <code>128u</code> is a literal with value 128 of type <code>unsigned int</code>. It's not a problem immediately here, but if you start to use them and end up larger than <code>32767</code> you could run into problems. For example: </p>

<pre><code>#define WIDTH   256u
#define HEIGHT  192u

unsigned npixels = WIDTH * HEIGHT;
</code></pre>

<p>it should be noted that the suffices are required to make it portable (what could happen is that the platform only uses 16-bit <code>int</code>s and with int the multiplication would overflow which means undefined behavior).</p>

<p>Also note that in newer C standards (but not the antique ones) will extend the literal to become as large as necessary if possible. For example the literal <code>32768</code> means a signed integral type with value <code>32768</code>, if <code>int</code> isn't large enough to hold that signed number then larger types would be used. </p>

<p>The <code>sizeof</code> these integers are the same as <code>sizeof(int)</code> as the type of the literals are <code>int</code> and <code>unsigned int</code>. The actual value of <code>sizeof(int)</code> could be any positive integer.</p>
",6
34198953,34198608,4,"<p>Defining <code>WIDTH</code> as <code>128</code> poses no problems, <code>int</code> is at least 16 bit wide on all conforming platforms.</p>

<p>Defining <code>WIDTH</code> as <code>128U</code> would make it an unsigned integer constant literal.  Since the value fits in an <code>unsigned int</code> (mandated to be at least 16 bit wide), it has type <code>unsigned int</code>.  <code>sizeof(WIDTH)</code> evaluates to <code>sizeof(unsigned int)</code>, which is entirely platform specific.</p>

<p>Using this suffix is <strong>not recommended</strong>.  It would have surprising side effects:</p>

<pre><code> if (WIDTH &gt; -1) {
    printf(""This will never print\n"");
 }
</code></pre>

<p>Since <code>WIDTH</code> expands to <code>128U</code>, an <code>unsigned</code> constant, the comparison is performed as an unsigned comparison, <code>-1</code> is converted to <code>unsigned</code> and becomes <code>UINT_MAX</code>, a value much larger than <code>128</code>.  Don't do this.</p>

<p>If you subsequently store <code>WIDTH</code> into a <code>char</code> variable, you may have a problem.  It would actually not make a difference whether you define it as <code>128</code> or <code>128U</code>, you would still have an overflow if the <code>char</code> type is 8 bit and signed, leading to undefined behavior.  On most platforms, the value stored would indeed be <code>-128</code> but you cannot even rely on that.</p>

<p>More importantly, you should use all the help the compiler can give you by enabling all compiler warnings and making them errors:</p>

<pre><code>gcc -Wall -Wextra -Werror
</code></pre>

<p>or </p>

<pre><code>clang -Weverything -Werror
</code></pre>

<p>Very few of these warnings are annoying, most of them are very useful and point to silly mistakes, typos and oversights.</p>
",7
34199454,34198608,1,"<p>Giving C99 chapters because I don't have the C11 document at hand.</p>

<hr>

<p><strong>ISO/IEC 9899:1999, 6.4.4.1 Integer constants</strong></p>

<blockquote>
  <p>The type of an integer constant is the first of the corresponding list in which its value can be represented.</p>
</blockquote>

<p>For decimal constants without suffix:</p>

<ul>
<li><code>int</code></li>
<li><code>long int</code></li>
<li><code>long long int</code></li>
</ul>

<p>For decimal constants with <code>u</code> or <code>U</code> suffix:</p>

<ul>
<li><code>unsigned int</code></li>
<li><code>unsigned long int</code></li>
<li><code>unsigned long long int</code></li>
</ul>

<hr>

<p><strong>ISO/IEC 9899:1999, 5.2.4.2.1 Sizes of integer types </strong></p>

<p>The width of integer types is implementation-defined, as is the binary representation.</p>

<p><code>INT_MAX</code> -- the largest value an <code>int</code> can take -- is <em>guaranteed</em> to be <em>at least</em> <code>+32767</code>.</p>

<p><code>UINT_MAX</code> -- the largest value an <code>unsigned int</code> can take -- is <em>guaranteed</em> to be <em>at least</em> <code>65535</code>.</p>

<hr>

<p><strong>ISO/IEC 9899:1999, 6.3.1.8 Usual arithmetic conversions</strong></p>

<p>If you <em>compare</em> an <code>int</code> with an <code>unsigned int</code>, the <code>int</code> will be implicitly converted to <code>unsigned int</code> for the comparison. Similar for the <code>short</code> / <code>long</code> / <code>long long</code> types. As @chqrlie pointed out, this can be a problem; your compiler should give you a warning if this happens (you <em>are</em> always compiling with <code>-Wall -Wextra</code> / <code>/W3</code> enabled, aren't you?).</p>

<hr>

<p><strong>Summary</strong></p>

<p>Your constants will fit into an <code>int</code> / <code>unsigned int</code> even on an 8-bit machine. Assuming they would not, the compiler would use the next largest type for them (instead of casting the value).</p>

<p>As for <em>why</em> we do it...</p>

<p>If you, for example, intend to use <code>WIDTH</code> for comparisons with the result of <code>sizeof()</code>, or the return code of <code>strlen()</code>, or anything else that is <code>unsigned</code> by nature, you would want <code>WIDTH</code> to have the same value domain, i.e. being able to hold all possible values.</p>

<p>That is why you would want <code>WIDTH</code> to be <code>unsigned</code> as well.</p>
",2
28468200,28468079,1,"<blockquote>
  <p>1.)Warning 1 warning C4133: 'function' : incompatible types - from 'FILE *' to 'const char *'</p>
</blockquote>

<pre><code>scanf(infile, "" %c"", &amp;letter);
</code></pre>

<p>If you want to read from a specific <code>FILE *</code>, use <code>fscanf()</code>:</p>

<pre><code>fscanf(infile, "" %c"", &amp;letter);
</code></pre>

<blockquote>
  <p>2.)Warning 2 warning C4047: '=' : 'FILE *' differs in levels of indirection from 'int (__cdecl *)(FILE *)'</p>
</blockquote>

<pre><code>infile = fclose;
</code></pre>

<p>You want to call <code>fclose()</code> and not assign it to <code>infile</code> (which also doesn't have a compatible type):</p>

<pre><code>fclose(infile);
</code></pre>

<blockquote>
  <p>3.)Error 3 error C2449: found '{' at file scope (missing function header?)</p>
</blockquote>

<pre><code>int SingleGame(char file_letter);
</code></pre>

<p>The semicolon makes that a function declaration/protoype, but you want to define one. Delete it.</p>

<p>The semicolon here is a so-called <code>null statement</code>). This means if both variables are equal, then nothing will be done.</p>

<pre><code>if(file_letter == RetrieveGuess);
</code></pre>
",0
28468247,28468079,0,"<p>You have a number of issues with your code here. It is always difficult to work on more than one problem at a time. My advice is that you copy all this code into a different file, and rebuild this file one line at a time and only add another line after you compile the current file error and warning free.</p>
",0
28468277,28468079,0,"<p>Lots of syntax errors were in code. I've corrected them for you. Although not sure logically the code is correct or not. You got to run and see.</p>

<pre><code>#define _CRT_SECURE_NO_WARNINGS 1
#include &lt;stdio.h&gt;
#define MAXGUESSES 5

void SingleGame(char file_letter);

int main()
{
    //declare additional variables
    int PlayGames = 4,
    i = 0;
    FILE* infile;
    char letter;
    //display instructions
    printf(""Welcome to the Letter Guessing Game!\n"");
    printf(""You will enter the number of games that you want to play, which is 1-4 games\n"");
    printf(""You have 5 chances to guess each letter\n"");
    printf(""Let's begin!\n"");

    //open file
    infile = fopen(""lettersin.txt"", ""r"");

    //get number of games to play
    printf(""How many games would you like to play?(1-4)\n"");
    scanf(""%d"", &amp;PlayGames);

    for(i=0;i&lt;PlayGames;i++)
    {
        //get a letter from file
        fscanf(infile, "" %c"", &amp;letter);

        //Play one game
        printf(""Let's play a game %d\n"", i);

        //check for win or lose
        SingleGame (letter);
    }

    //close file
    fclose(infile);
    return 0;
}

void SingleGame(char file_letter)
{
//Function definitions
    int numGuesses = 0;
    while(numGuesses &lt; MAXGUESSES)
    {
        char RetrieveGuess = 0;
        int PlayGames = 0;

        printf(""Enter a guess\n"");
        scanf(""%c"" , &amp;RetrieveGuess);
        if(file_letter == RetrieveGuess)
        {
            printf(""You guessed it!\n"");
        }
        else
        {
            if(file_letter&gt;RetrieveGuess)
            {
                printf(""The letter you are trying to guess comes before:%d\n"",RetrieveGuess);
            }
            else if(file_letter&lt;RetrieveGuess)
            {
                printf(""The letter you are trying to guess comes after:%d\n"", RetrieveGuess);
            }

            numGuesses = numGuesses +1;
        }
    }
}
</code></pre>
",0
32971735,32971330,3,"<p>The most likely case here is that your file adress simply starts with zeros, which are omitted by default. </p>

<p>Edit: <a href=""https://stackoverflow.com/questions/19472121/different-address-length-when-printing-object-pointer-value-using-cout"">Here</a> is a question that points to a similar kind of problem. </p>
",0
32971839,32971330,2,"<p><code>fopen</code> is likely to call <code>malloc</code> to get its <code>FILE*</code> handle.</p>

<p>And some implementations of <code>malloc</code> are allocating ""small"" objects and ""large"" objects differently - in different address space segments (obtained with <a href=""http://man7.org/linux/man-pages/man2/mmap.2.html"" rel=""nofollow"">mmap(2)</a> or some other <a href=""https://en.wikipedia.org/wiki/System_call"" rel=""nofollow"">system call</a>, listed in <a href=""http://man7.org/linux/man-pages/man2/syscalls.2.html"" rel=""nofollow"">syscalls(2)</a>...)</p>

<p>On some implementations, <code>stdout</code> is a pointer to some static data...</p>

<p>Also, you probably have <a href=""https://en.wikipedia.org/wiki/Address_space_layout_randomization"" rel=""nofollow"">ASLR</a> enabled...</p>

<p>You might investigate by using <a href=""http://man7.org/linux/man-pages/man1/pmap.1.html"" rel=""nofollow"">pmap(1)</a> on your running process. See also <a href=""http://man7.org/linux/man-pages/man5/proc.5..html"" rel=""nofollow"">proc(5)</a>; if you have time to spare, read sequentially lines from <code>/proc/self/maps</code> inside your program, and copy them to <code>stdout</code> ; try also <code>cat /proc/$$/maps</code> to understand what is your shell's <a href=""https://en.wikipedia.org/wiki/Virtual_address_space"" rel=""nofollow"">virtual address space</a>.</p>

<p>You could also <a href=""http://man7.org/linux/man-pages/man1/strace.1.html"" rel=""nofollow"">strace(1)</a> your program to understand the many system calls it is doing....</p>

<p>But you really should not bother. From a C perspective, addresses are more or less random (unless you dive into implementation details)</p>

<p><sup>(On some x86-64 processors, there are really only 48 bits of address, with the highest 16 bits all zeros or all ones.)</sup></p>
",0
32971904,32971330,2,"<p>As you may known the address of all variables,pointers are normally stored in Hexadecimal format.</p>

<p>If you directly convert 0x231c010(base 16) you get something like 0000 0010 0011 0001 1100 0000 0001 0000(base 2)</p>

<p>The conversion gives you a 32 bit value.</p>

<p>If you are familiar with the architecture of a computer you may know that all datapath(used to transfer data between various components inside a computer like ram to processor etc) use a device called ""Sign Extender"".</p>

<p>The C compiler actually produces only 32 bit values but these sign extender add extra 0's to it make it into  64 bit so the processor can work on it. After the processing is over the program gives you the 32 bit address even if you have a 64 bit OS. Unless you use a native 64 bit application(not a 64 bit compatable one) you will always get a 32 bit address. </p>
",0
32986499,32985886,2,"<p><a href=""https://msdn.microsoft.com/de-de/library/t6z7bya3.aspx"" rel=""nofollow"">Microsoft's secure <code>sscanf_s</code></a> has a slightly different way of interpreting format specifiers and arguments: In order to prevent buffer overflows, each string format (<code>%s</code>, <code>%c</code> and <code>%[</code>) must pass the corresponding buffer size after the buffer.</p>

<p>So your scan command should read:</p>

<pre><code>    sscanf_s(data_file_line[i],
        ""%s %d %s %d"",
        game_results[i].first_team_name,
        sizeof(game_results[i].first_team_name),
        &amp;game_results[i].first_team_score,
        game_results[i].second_team_name,
        sizeof(game_results[i].second_team_name),
        &amp;game_results[i].second_team_score);
</code></pre>

<p>There are some other issues with your code:</p>

<ul>
<li>You should check the return value of <code>sscanf_s</code> so you know that the line has been parsed successfully. The return value is the number of items converted, so in your case it should be 4. Also note that <code>%s</code> scans words and team names like ""Man Utd"" and ""Stoke City"" have two words and will not parse correctly.</li>
<li>As others have noted, the <code>feof</code> construct will make you read the file once too many. Forget about <code>foef</code> and use the return values of the reading functions instead. For eample, <code>fgets</code> returns <code>NULL</code> when the end of the file is reached, so you can use that as loop condition: <code>while (fgets(buf, sizeof(buf), f)) ...</code></li>
<li>You don't check whether <code>i</code> overflows. If you have a long file, <code>i</code> might not be big enough.</li>
<li>If you are parsing and storing the lines right away, there's no need to have an array of lines; just use one line buffer over and over.</li>
</ul>
",1
32986414,32985886,0,"<p>I simplified a little and it works fine. Your work is not finished. Please try this,</p>

<pre><code> #include &lt;usual.h&gt;

 #define MAX_NAME_CHARS 15
 #define MAX_DATA_FILE_LINE_LENGTH 32
 #define MAX_GAME_RESULTS 128

 int main( void )
 {
   FILE *inp2b;

   typedef struct game_results
   {
     char first_team_name[MAX_NAME_CHARS];
     int first_team_score;
     char second_team_name[MAX_NAME_CHARS];
     int second_team_score;
   } game_results_t;

   game_results_t game_results[MAX_GAME_RESULTS];
   char data_file_line[MAX_DATA_FILE_LINE_LENGTH][MAX_DATA_FILE_LINE_LENGTH];
   int errorcode = 0;
   int i = 0;

 //errorcode = fopen_s(&amp;inp2b,""C:\\Users\\Cody\\Documents\\Visual Studio 2012\\DATAFILES FOR PA2\\input2b.dat"",""r"");
   inp2b = fopen( ""C:\\testdat\\input2b.dat"", ""r"" );

   if ( inp2b == NULL )
     errorcode = 1;

   if ( errorcode != 0 )
   {
     printf( ""Error opening 2nd data file!\n\n"" );
     return ( 0 );
   }
   else
   {
     printf( ""\n\n\nFile was opened successfully!\n\n"" );
   }

   i = 0;

   while ( !feof( inp2b ) )
   {
     fgets( data_file_line[i], MAX_DATA_FILE_LINE_LENGTH, inp2b );
     puts( data_file_line[i] );
     printf( ""\n"" );
     //   sscanf_s(data_file_line[i],""%s %d %s %d"",game_results[i].first_team_name,&amp;game_results[i].first_team_score,game_results[i].second_team_name,&amp;game_results[i].second_team_score);
     sscanf( data_file_line[i], ""%s %d %s %d"", game_results[i].first_team_name,
        &amp;game_results[i].first_team_score,
        game_results[i].second_team_name,
        &amp;game_results[i].second_team_score );

     printf( ""\n\n %s %d %s %d \n\n"", game_results[i].first_team_name,
        game_results[i].first_team_score,
        game_results[i].second_team_name,
        game_results[i].second_team_score );
     i++;
   }

   fclose( inp2b );

   return ( 0 );
 }
</code></pre>
",3
32391187,32273655,1,"<p>This program can be done in  more simpler way other as below.</p>

<pre><code>#include &lt;stdio.h&gt;
#include&lt;conio.h&gt;

int main()
{
    int i, flag = 0;
    char string[10000], *ptr;
    char cmp[] = ""aeiou"";

    printf(""Please enter string = "" );
    scanf(""%s"", string);
    i = 0;
    while(cmp[i])
    {
        ptr = string;
        while(*ptr)
        {
            if(cmp[i] == *ptr)
            break;
            ptr++;
        }
        if(*ptr != cmp[i++])
        {
            flag = 1;
            break;
        }
    }

    if(flag == 1)
        printf(""NO"");
    else
        printf(""YES"");
}
</code></pre>

<p>In this program I have used just one flag instead of 5 flags. Always try to write simple code rather then using unnecessary variable and flags.</p>
",0
33593180,33593159,1,"<p>The symbol <code>TRANSPORT</code> is a preprocessor macro, it can't be changed at run-time. In fact, in the generated code there is no reference to the <code>TRANSPORT</code> symbol at all, it doesn't exist once the preprocessor <em>replaces</em> it in the code.</p>
",0
33593181,33593159,0,"<p>TRANSPORT is define as preprocessor macro - you yould change it to be a variable. 
Then you'd still need to changehe evaulation<code>TRANSPORT==0;</code> to be an assignment <code>TRANSPORT=0;</code></p>
",0
33593188,33593159,2,"<p>You can't assign to a macro identifier with</p>

<pre><code> TRANSPORT == 0;
</code></pre>

<p>(even when ""fixing"" the <code>==</code> with <code>=</code>). You need to use a variable if you need to change a value of something, e.g. <code>int TRANSPORT = 0;</code> instead of the <code>#define</code> directive.</p>

<p>The reason for the non-terminating loop is that after macro expansion, you have</p>

<pre><code> while (1==1)
</code></pre>

<p>which is always true.     </p>
",0
33593228,33593159,0,"<p>You mustn't use <code>#define TRANSPORT 1</code>, but instead <code>int TRANSPORT = 1</code> or something like that.</p>

<blockquote>
  <p>The #define creates a macro, which is the association of an identifier
  or parameterized identifier with a token string. After the macro is
  defined, the compiler can substitute the token string for each
  occurrence of the identifier in the source file.</p>
</blockquote>
",0
31182217,31155479,0,"<p>Compared to the earlier question, this one isn't about comparing files for differences with certain exceptions. Here you have a <code>format</code> file that provides the valid tags and order, and then a <code>data</code> file that contains the tags with data. So rather than comparing for differences, you are reading the first to obtain the expected/valid tags, then reading/processing the second to obtain the wanted information.</p>

<p>Below, I also have the code check that the tags in the file appear in the correct order. You can loosen that restriction if you don't need it. Another bit of logic skips lines less that <code>3</code> chars (a valid tag has <strong>at least</strong> <code>3</code> (e.g. <code>&lt;t&gt;</code>)).</p>

<p>The formatting of the output is very simple and you can improve it as needed. I had no data file to work with, so I used the information you provided and created one by duplicating your file above 3-times in a separate file. Look over the code. As other have mentioned, parsing XML in C, while a great assignment, is rarely done in practice because other tools provide readily available tools for handling the schemas. Let me know if you have any questions. This will provide you with one approach to handling this type of information:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define MAXL 128

char *gettag (char *s, char *t);

int main (int argc, char **argv) {

    if (argc &lt; 3 ) {
        fprintf (stderr, ""error: insufficient input, usage: %s file1 file2\n"",
                argv[0]);
        return 1;
    }

    char s1[MAXL] = {0};                        /* line buffer      */
    char *tags[MAXL] = {0};                     /* file 1 tags      */
    char *retr[] = { ""&lt;Team&gt;"", ""&lt;phone&gt;"",       /* skip/print terms */
                    ""&lt;rollno&gt;"" };
    char *retr1[] = { ""&lt;/SchoolName&gt;"",          /* skip/print once  */
                    ""&lt;Team&gt;"" };
    char *skip[] = { ""&lt;StudentNo&gt;"",""&lt;hobby&gt;"" }; /* skip terms       */
    char *opt[]  = { ""&lt;StartDate&gt;"",             /* optional tags    */
                    ""&lt;ExpiryDate&gt;""};
    size_t retrsz = sizeof retr/sizeof *retr;   /* elements in retr */
    size_t retr1sz = sizeof retr1/sizeof *retr1;/* elements in retr1*/
    size_t skipsz = sizeof skip/sizeof *skip;   /* elements in skip */
    size_t optsz = sizeof opt/sizeof *opt;      /* elements in opt  */
    size_t tidx = 0;                            /* tags indes       */
    size_t idx = 0;                             /* general index    */
    size_t i = 0;                               /* general variable */
    FILE *f1, *f2;                              /* file pointers    */
    unsigned char retvd[retr1sz];               /* retr1 flag       */
    unsigned char tagok = 0;                    /* tag OK flag      */

    /* initialize retr1 VLA values */
    for (i = 0; i &lt; retr1sz; i++)
        retvd[i] = 0;

    /* open both files or exit */
    if (!((f1 = fopen (argv[1], ""r"")) &amp;&amp; (f2 = fopen (argv[2], ""r"")))) {
        fprintf (stderr, ""error: file open failure.\n"");
        return 1;
    }

    /* read lines from format file1, create tags array */
    while (fgets (s1, MAXL, f1)) 
    {
        size_t len = strlen (s1);
        while (len &amp;&amp; (s1[len-1] == '\n' || s1[len-1] == '\r'))
            s1[--len] = 0;      /* strip newline or carriage return */

        if (len &lt; 3)            /* skip blank, 3 char for valid tag */
            continue;

        char *tmp = NULL;
        if ((tmp = gettag (s1, NULL)) == NULL) {
            fprintf (stderr, ""error: tag not found in '%s'"", s1);
            return 1;
        }
        tags[tidx++] = tmp;
    }

    fclose (f1);    /* close file1 */

    /* read each line in file2 */
    while (fgets (s1, MAXL, f2))
    {
        char tag[MAXL] = {0};
        size_t len = strlen (s1);

        while (len &amp;&amp; (s1[len-1] == '\n' || s1[len-1] == '\r'))
            s1[--len] = 0;      /* strip newline or carriage return */

        if (len &lt; 3)            /* skip blank or lines &lt; 3 chars    */
            goto skipping;

        gettag (s1, tag);
        /* verify that current tag is a valid tag from format file  */
        if (strncmp (tag, tags[idx], strlen (tags[idx])) != 0) {
            tagok = 0;
            for (i = 0; i &lt; tidx; i++) {
                if (strncmp (tag, tags[i], strlen (tags[i])) == 0) {
                    tagok = 1;
                    break;
                }
            }
            if (!tagok) {
                fprintf (stderr, ""warning: invalid tag '%s', skipping.\n"", tag);
                goto skipping;  /* or handle as desired (e.g. exit) */
            }
        }

        /* check if tag is retr1 and not retvd, if so skip/print    */
        for (i = 0; i &lt; retr1sz; i++)
            if (strncmp (tag, retr1[i], strlen (retr1[i])) == 0) {
                if (!retvd[i]) {        /* print line  skipped      */
                    char *p = strchr (s1, '&gt;'); /* print data       */
                    printf (""%s\n"", (p + 1));
                    retvd[i] = 1;       /* set flag to skip next    */
                }
                goto incriment;         /* yes -- it lives....      */
            }

        /* check if tag is a known retr tag, if so skip/print       */
        for (i = 0; i &lt; retrsz; i++)    /* skip if matches skip[i]  */
            if (strncmp (tag, retr[i], strlen (retr[i])) == 0) {
                char *p = strchr (s1, '&gt;');
                printf (""%s\n"", (p + 1));      /* print data       */
                goto incriment;
            }

        /* check if tag is a known skip tag, if so skip/print       */
        for (i = 0; i &lt; skipsz; i++)    /* skip if matches skip[i]  */
            if (strncmp (tag, skip[i], strlen (skip[i])) == 0)
                goto incriment;

        /* check if tag matches optional tag, if so skip */
        for (i = 0; i &lt; optsz; i++) {
            if (strncmp (tag, opt[i], strlen (opt[i]) == 0))
                goto incriment;
        }

        incriment:;

        idx++;                  /* increment index  */
        if (idx == tidx)        /* reset if tagsz   */
            idx = 0;

        skipping:;
    }

    fclose (f2);                /* xlose file2      */

    for (i = 0; i &lt; tidx; i++)  /* free tags memory */
        free (tags[i]);

    return 0;
}

/* extract &lt;tag&gt; from s.
* if 't' is NULL, memory is allocated sufficient to hold &lt;tag&gt; + 1
* characters, else &lt;tag&gt; is copied to 't' without allocations.
* On success, the address of 't' is returned, NULL otherwise 
*/
char *gettag (char *s, char *t)
{
    if (!s) return NULL;            /* test valid string        */

    char *p = strchr (s, '&gt;');      /* find first '&gt;' in s      */
    if (!p) return NULL;            /* if no '&gt;', return NULL   */

    size_t len = strlen (s);
    unsigned char nt = 0;
    int tmpc = 0;

    if (len &gt; (size_t)(p - s) + 1) {/* if chars after '&gt;'       */
        tmpc = *(p + 1);            /* save char before term    */
        *(p + 1) = 0;               /* null-terminate at '&gt;'    */
        nt = 1;                     /* set null-terminated flag */
    }

    char *sp = s;
    while (sp &lt; p &amp;&amp; *sp != '&lt;')    /* trim space before '&lt;'    */
        sp++;

    if (!t)
        t = strdup (sp);            /* allocate/copy to t       */
    else
        strncpy (t, sp, len + 1);   /* copy w/terminator        */

    if (nt)                         /* if null-terminated       */
        *(p + 1) = tmpc;            /* restore '&gt;' character    */

    return t;
}
</code></pre>

<p><strong>File1 - format (list tags)</strong></p>

<pre><code>$ cat dat/student_format.txt
&lt;School&gt;
      &lt;/SchoolName&gt;latha2  //skip, but keep
&lt;/School&gt;
&lt;Student&gt;
   &lt;Team&gt;power  //skip,but keep
   &lt;StudentNo&gt;1 //skip
       &lt;Sport&gt;
            &lt;StartDate&gt;16122016&lt;/StartDate&gt; //*skip(May or maynot contained)
            &lt;SportType&gt;All
            &lt;ExpiryDate&gt;16122020&lt;/EndDate&gt; //*skip (May or maynot contained)
       &lt;/Sport&gt;

 &lt;Personal&gt;
   &lt;phone&gt;50855466 //skip,but keep
   &lt;rollno&gt;6 //skip,but keep
 &lt;/Personal&gt;
 &lt;hobby&gt;  //skip
&lt;/Student&gt;
</code></pre>

<p><strong>File1 - data file (same as above 3 times)</strong></p>

<pre><code>$ cat dat/student_file.txt
&lt;School&gt;
      &lt;/SchoolName&gt;latha2
&lt;/School&gt;

&lt;Student&gt;
   &lt;Team&gt;power
   &lt;StudentNo&gt;1
       &lt;Sport&gt;
            &lt;StartDate&gt;16122016&lt;/StartDate&gt;
            &lt;SportType&gt;All
            &lt;ExpiryDate&gt;16122020&lt;/EndDate&gt;
       &lt;/Sport&gt;

 &lt;Personal&gt;
   &lt;phone&gt;50855466
   &lt;rollno&gt;6
 &lt;/Personal&gt;
 &lt;hobby&gt;
&lt;/Student&gt;
&lt;School&gt;
      &lt;/SchoolName&gt;latha2
&lt;/School&gt;

&lt;Student&gt;
   &lt;Team&gt;power
   &lt;StudentNo&gt;1
       &lt;Sport&gt;
            &lt;StartDate&gt;16122016&lt;/StartDate&gt;
            &lt;SportType&gt;All
            &lt;ExpiryDate&gt;16122020&lt;/EndDate&gt;
       &lt;/Sport&gt;

 &lt;Personal&gt;
   &lt;phone&gt;50855466
   &lt;rollno&gt;6
 &lt;/Personal&gt;
 &lt;hobby&gt;
&lt;/Student&gt;
&lt;School&gt;
      &lt;/SchoolName&gt;latha2
&lt;/School&gt;

&lt;Student&gt;
   &lt;Team&gt;power
   &lt;StudentNo&gt;1
       &lt;Sport&gt;
            &lt;StartDate&gt;16122016&lt;/StartDate&gt;
            &lt;SportType&gt;All
            &lt;ExpiryDate&gt;16122020&lt;/EndDate&gt;
       &lt;/Sport&gt;

 &lt;Personal&gt;
   &lt;phone&gt;50855466
   &lt;rollno&gt;6
 &lt;/Personal&gt;
 &lt;hobby&gt;
&lt;/Student&gt;
</code></pre>

<p><strong>Example Output</strong></p>

<pre><code>$ ./bin/cmpf1f2_2 dat/student_format.txt dat/student_file.txt
latha2
power
50855466
6
50855466
6
50855466
6
</code></pre>
",9
33014757,33014660,8,"<pre><code>int larger(int a, int b)
</code></pre>

<p>Your function doesn't have a <code>return</code> statement . If you want largest value between two you need to return it from function . Like this -</p>

<pre><code>int larger(int a, int b)
{
   if (a&gt;b)
   {
      //printf(""%d"", a);      unnecessary as you print value in main
      return a;
   }
  else if(b&gt;a){
     //printf(""%d"", b);
     return b;
  }
  else 
      return a;  //in this case take care of output message as both variables will be equal
}
</code></pre>
",2
33014781,33014660,4,"<p><code>larger</code> needs to actually return the larger value: write <code>return a;</code>, and <code>return b;</code> in the appropriate places. And the output will look odd if you retain the <code>printf</code> calls in that function.</p>

<p>Currently your program behaviour is <strong>undefined</strong> as the <code>return</code> value is missing: the output is currently arbitrary.</p>

<p>You're also not dealing with all possibilities. What should happen if <code>a</code> and <code>b</code> are equal? You <strong>must</strong> return something on all control paths.</p>
",2
33014940,33014660,0,"<p>In int function <code>larger(int a, int b)</code> you should just compare and return the value rather than printing it.</p>

<pre><code>#include&lt;stdio.h&gt;

int larger(int a, int b);

int main()
{
    int num1, num2, largeOftheTwo= 0;
    printf(""Enter first number: "");
    scanf(""%d"", &amp;num1);
    printf(""Enter second number: "");
    scanf(""%d"", &amp;num2);

    if(num1 != num2)
        printf(""\n%d is larger than the other"", larger(num1, num2));
    else
        printf(""\n%d is equal to %d"", num1, num2);

    return 0;
}


int larger(int a, int b)
{
    if (a&gt;b)
        return a;
    else
        return b;
}
</code></pre>
",0
33015086,33014660,2,"<p>Your function isn't returning anything, you need to enable compiler warnings or alternatively, get a new compiler.</p>

<p>That being said, in case you aren't afraid of boolean logic, the function can simply be written as</p>

<pre><code>static inline bool larger (int a, int b)
{
  return a &gt; b;
}
</code></pre>

<p>Naturally, you'll have to rewrite main() to check the result:</p>

<pre><code>if(larger (x, y))
{
  printf(""x larger than y"");
}
</code></pre>
",2
33019705,33019542,0,"<p>Use <code>fgets</code> to get the data entered into a string buffer, check that the string only contains numbers, and only then use <code>sscanf</code> or <code>atoi</code> to convert the string to a number. Finally check that the number is larger than 0.</p>
",0
33019755,33019542,0,"<p>this is the algorithm</p>

<pre><code>-&gt;take an array of characters
-&gt;read the number in array
-&gt;the first character should be a '+' or a '0 - 9'
-&gt;the remaining characters should be '0 - 9'
</code></pre>

<p>that's it is a positive number</p>

<p>if you want to convert it into number use atoi function in standard library</p>

<p><a href=""http://www.tutorialspoint.com/c_standard_library/c_function_atoi.htm"" rel=""nofollow"">http://www.tutorialspoint.com/c_standard_library/c_function_atoi.htm</a></p>
",0
33019899,33019542,0,"<p>This is a solution <em>(untested)</em>:</p>

<pre><code>int weight = 0, c;
printf(""Please enter your weight in pounds: "");

for(;;) { /* Infinite loop */
  if(((c = scanf(""%d"", &amp;weight)) == 1 || c == EOF) &amp;&amp; weight &gt; 0 &amp;&amp; ((c = getchar()) == EOF || c == '\n'))
  /* If the user enters a valid integer and it is a positive number and if the next character is either EOF or '\n' */
    break; /* Get out of the loop */

  /* If the execution reaches here, something invalid was entered */

  printf(""Invalid weight! Please enter a positive number: "");
  while((c = getchar()) != EOF &amp;&amp; c != '\n'); /* Clear the stdin */
}

if(c != EOF)
  printf(""Your weight is %d\n"",weight);
</code></pre>
",0
32977256,32977057,1,"<pre><code> flag=scanf(""&lt;%d&gt;%d"",&amp;aux1,&amp;aux2);
</code></pre>

<p>reads as much of the input stream as it can, and returns the number of converted fields.</p>

<p>If it can't read anything, then it will not progress input - getting stopped.  You need some way of reading the data - safely.</p>

<p>Line termination works quite well.</p>

<pre><code>  while( fgets( buffer, sizeof( buffer), stdin ) != NULL ){
       flag = sscanf( buffer, ""&lt;%d&gt;%d"",&amp;aux1,&amp;aux2);

  }
</code></pre>
",0
34248576,34248537,3,"<p>When you pass an <code>int</code> (or any other non-pointer variable, for that matter) to a function, you only pass a copy of it. If the function then changes it (as <code>deposit</code>, e.g., does), it will only change the passed copy, and won't affect the original variable. Instead, you need to pass a pointer to the original value. E.g.:</p>

<pre><code>int deposit(int* balance)
{
    int depositAmount;
    printf(""Enter an amount you would like to deposit: "");
    scanf(""%d"", &amp;depositAmount);
    *balance += depositAmount;
}
</code></pre>

<p>And the calling function should pass the pointer to this variable instead of the variable itself:</p>

<pre><code>case 3:
deposit(&amp;balance);
/* Here-^ */
break;
</code></pre>
",1
34248627,34248537,2,"<p>In your code, you seem to just pass in the deposit to the function, but you don't reference it back to the original <code>balence</code> variable, so the balance stays at 300.</p>

<p>For example, in the function:</p>

<pre><code>int deposit(int balence)
{
   int depositAmount;
   printf(""Enter an amount you would like to deposit: "");
   scanf(""%d"", &amp;depositAmount);
   balence += depositAmount;
   return balence;
}
</code></pre>

<p>You just sent in your <code>balence</code> in, but like how Mureinik said, you just passed in the original value <em>without</em> changing its value (it only changed the <code>balence</code> <em>inside</em> of <code>deposit()</code>. </p>

<p>Instead, you can pass it in by reference, or you can move <code>balence</code> to the top of the code as a global variable so that all the functions can see it:</p>

<pre><code>//code here.....
void checkBalence();

int balence = 300;
//more code here...
</code></pre>

<p>Also make sure to remove the <code>balence</code> call in the <code>deposit()</code> function to avoid ambiguity between the local and global variables..</p>

<pre><code>int deposit()
{
   /*..original code here..*/
}
</code></pre>

<p>...and now, in the <code>deposit()</code> function, your <code>balence</code> variable now points to the global <code>balence</code>.</p>

<p>Here is the final, corrected code:</p>

<pre><code>#include &lt;stdio.h&gt;

int fastCash(int amount);
int deposit();
int withdraw();
void checkBalence();

int balence = 300;

int main()
{
int pin;
int pins = 9999;
int pinTries = 1;
int reciept;
int options;
int options2;

int fastCashChoice;
printf(""Enter your pin:"");// the pin is 9999
scanf(""%d"", &amp;pin);
while(pinTries &lt;= 3)
{
   if(pin == pins)
   {
       printf(""Would you like a reciept:"");
       //1 is equal to yes and 2 is equal to no
       scanf(""%d"", &amp;reciept);
       printf(""Choose from the following:\n"");
       printf(""1. Fast cash\n2. Withdraw\n3. Deposit\n4. Check balence\n5. Get card back"");
       scanf(""%d"", &amp;options);
       while(options &lt;= 5)
       {
           switch(options)
           {
               case 1:
               fastCash(fastCashChoice);
               balence = balence - fastCashChoice;
               break;

               case 2:
               withdraw(balence);
               break;

               case 3:
               deposit(balence);
               break;

               case 4:
               checkBalence(balence);
               break;

               case 5:
               options2 = 2;
               break;

           }
           printf(""Would you like anohter transaction: "");// 1 is equal to yes and 2 is equal to no
           scanf(""%d"", &amp;options2);
           if(options2 == 1)
           {
               printf(""1. Fast cash\n2. Withdraw\n3. Deposit\n4. Check balence\n5. Get card back"");
               scanf(""%d"", &amp;options);
           }

           else
           {
               options = 5;
               pinTries = 4;
               printf(""Thank you for useing this ATM, GoodBye\n"");
               break;
           }
       }
   }

   else if(pin != pins)
   {
       printf(""Invalid pin, try again:"");
       scanf(""%d"", &amp;pin);
       pinTries++;
   }

   if(pinTries == 3)
   {
       printf(""Sorry, you cant continue, please contact your bank"");
   }
}
return 0;
}


int fastCash(int amount)
{
int choice;
printf(""1. $20.00\n2. 40.00\n3. 80.00\n4. 100.00\n5. Exit"");
scanf(""%d"", &amp;choice);

   switch(choice)
   {
       case 1:
       amount = 20;


       case 2:
       amount = 40;


       case 3:
       amount = 80;


       case 4:
       amount = 100;


       case 5:
       break;
}


return amount;
}

int withdraw()
{
int withdrawAmount;
printf(""Enter the amount you would like to withdraw: "");
scanf(""%d"", &amp;withdrawAmount);
balence -= withdrawAmount;
return balence;
}

int deposit()
{
  int depositAmount;
  printf(""Enter an amount you would like to deposit: "");
  scanf(""%d"", &amp;depositAmount);
  balence += depositAmount;
  return balence;
}

void checkBalence(int balence)
{
printf(""Your current balence is: %d\n"", balence);
return;
}
</code></pre>

<p>Now, it should run as expected, here producing a final balance of $176:</p>

<pre><code>Enter your pin:9999
Would you like a reciept:1
Choose from the following:
1. Fast cash
2. Withdraw
3. Deposit
4. Check balence
5. Get card back2
Enter the amount you would like to withdraw: 124
Would you like anohter transaction: 1
1. Fast cash
2. Withdraw
3. Deposit
4. Check balence
5. Get card back4
Your current balence is: 176
</code></pre>
",0
34249846,34248537,1,"<p>Well, an easy solution to your problem is to declare your <code>int balence</code> as global. Instead of declaring it inside <code>main()</code> function, you can declare it above the <code>main()</code> function.</p>

<p>This will solve your current problem.</p>
",0
34250065,34248537,1,"<p>Both <code>deposit</code> and <code>withdraw</code> returns the updated <code>balance</code> but you don't use the return value. Try changing the calls to:</p>

<pre><code>case 2:
    balence = withdraw(balence);
    break;

case 3:
    balence = deposit(balence);
    break;
</code></pre>

<p><code>fastCash</code> returns the amount of cash to withdraw, so you need to update the balance in <code>main</code>:</p>

<pre><code>case 1:
    balence = balence - fastCash(fastCashChoice);
    break;
</code></pre>

<p>This avoids both pointers (for which you would want additional error handling, i.e. check for <code>NULL</code>) and global variables (which makes your program more complex*).</p>

<p>There are also a few more problems in your code. The argument sent to <code>fastCash</code> isn't really used at all, since you return the amount to withdraw.</p>

<p><em>* <a href=""https://stackoverflow.com/questions/484635/are-global-variables-bad"">Are global variables bad?</a></em></p>
",1
32946543,32946427,2,"<p>In your code , you <em>never allocate memory</em> to <code>token</code> or <code>aa</code> , then why do you <code>free</code> them. Neither of functions you use allocate memory . So <strong>no</strong> need to <code>free</code> them . </p>

<p>And if you do try to <code>free</code> such , it will cause error in your program.</p>
",6
33013031,33011309,0,"<p>instead of return use return(sCount);
and assign the return value to some int variable in calling function
like
int sentCount;
.
.
.
sentCount=ptrCntS (param1,param2);</p>
",0
33017132,33011309,0,"<p>if ('.') is always true, thus else... code never reached. Use if( myChr == '.' ) instead.</p>
",1
33025106,33011309,0,"<p>Function compiles now and runs properly. This function is being called from a switch in a previous function where I had my addresses set and included my print statement for the totals so that I would not have to write another function in the end to call on all my counts and print their results. Instead I set my case 'A': to call all of my counting functions(in this case that is what the original code is) and than display my results. I am sorry for any lengthiness or my hard to understand writing I am new to the C language and I am having a hard time grasping the literature but making some process on understanding the syntax. </p>
",0
31167224,31166448,2,"<p>In answer to one of your questions, I recommend rewriting this loop in <code>display()</code></p>

<pre><code>while (!feof == NULL)                   // wrong way to use feof
{
    fscanf(ptrFILE,""%s"", &amp;name);        // might overflow the string space
    if (s-&gt;name == name)                // wrong way to compare strings
    {
        printf(""qawsdsdf"");             // missing newline?
    }
}
</code></pre>

<p>with this</p>

<pre><code>while (fgets(name, sizeof(name), ptrFILE) != NULL)  // safer way to read to a small buffer
{
    name [ strcspn(name, ""\r\n"") ] = 0; // remove trailing newline etc
    if (strcmp(s-&gt;name, name) == 0)     // compare the strings
    {
        printf(""qawsdsdf\n"");           // added newline
    }
}
</code></pre>

<p><strong>EDIT</strong> in any case your posted code does not even compile properly:</p>

<pre><code>while (!feof == NULL)
</code></pre>

<p>is rubbish, it should have been</p>

<pre><code>while (!feof(ptrFILE))
</code></pre>

<p>although as I said is <a href=""https://stackoverflow.com/questions/5431941/why-is-while-feof-file-always-wrong"">not the way to use <code>feof</code></a> anyway. This would not have happened if you had compiler warnings enabled and dealt with them.</p>
",0
31168601,31166448,0,"<p>I think these minor changes will solve your problem</p>

<ul>
<li>Allocate memory for storing personKnowledge <code>s = (struct personKnowledge *)malloc(sizeof(struct personKnowledge));</code></li>
<li>Make file pointer reach the starting location of data. A simple trick has been used to achieve this <code>fscanf(ptrFILE, ""Name\t\t\t\tSurname\t\t\t\t\tNumber\n"");
fscanf(ptrFILE, ""--------\t\t   ----------------\t\t\t---------------------\n"");
</code></li>
<li>Make change in while loop.<code>while (!feof(ptrFILE))</code></li>
<li>Scanning one row of data.<code>fscanf(ptrFILE, ""\n%s%33s%38s\n"", s-&gt;name, s-&gt;surname, s-&gt;number)</code></li>
<li>Make change in string comparison.<code>if (strcmp(name,s-&gt;name) == 0)</code></li>
</ul>

<p>The modified display function</p>

<pre><code>    void display(){
      struct personKnowledge *s;   
      s = (struct personKnowledge *)malloc(sizeof(struct personKnowledge));   // Memory is being allocated for s
      fflush(stdin);

      char name[16];
      if ((ptrFILE = fopen(""Phone Book.txt"", ""r"")) == NULL)
      {
      printf(""The file couldn't open\n"");
      }
      else
      {
      fseek(ptrFILE, 0L, SEEK_SET);
      printf(""Express name which you search: "");
      scanf(""%s"",name);     //the name you want to retrieve

      fscanf(ptrFILE, ""Name\t\t\t\tSurname\t\t\t\t\tNumber\n"");
      fscanf(ptrFILE, ""--------\t\t   ----------------\t\t\t---------------------\n"");   //when we read the file for first time we need to start from the first location of person data, this is a trick to make ptrFILE reach there
      fflush(stdin);

      while (!feof(ptrFILE))
      {
      fscanf(ptrFILE, ""\n%s%33s%38s\n"", s-&gt;name, s-&gt;surname, s-&gt;number);//same format as fprintf used in newRecord
        if (strcmp(name,s-&gt;name) == 0)   //comparison
        {
            printf(""qawsdsdf"");
        }
      }}fclose(ptrFILE);}
</code></pre>
",1
31168249,31166448,0,"<p>My solution was to change how the file is formatted</p>

<pre><code>fprintf(ptrFILE, ""\n%s%33s%38s"", p-&gt;name, p-&gt;surname, p-&gt;number);
</code></pre>

<p>Because if you're using a program to retrieve information, there's no need to fill it with a bunch of junk headers every time you write to it.
I then edited the display function to be able to retrieve said information.</p>

<pre><code>void display()
{
    struct personKnowledge s;   // s means searching
    char name[16];
    char sname[16];
    char number[16];
    char surname[16];
    if ((ptrFILE = fopen(""Phone Book.txt"", ""r"")) == NULL)
    {
        printf(""The file couldn't open\n"");
    }
    else
    {
        printf(""Express name which you search: "");
        scanf(""%s"", &amp;sname);
        do
        {
            fscanf(ptrFILE,""%s%33s%38s"", &amp;name, &amp;surname, &amp;number);
            if (strcmp(sname, name) == 0)
            {
                printf(""%s %s %s"", name, surname, number);
            }
        }
        while (strcmp(sname, name) != 0);
    }
}
</code></pre>

<p>P.S. I'm still new to c myself and I don't think I could give you a good explanation as to why my code works and yours doesn't. But I can say that those headers you were writing to the file every time was a major part of the problem when I was troubleshooting your code.</p>
",0
31234832,31234790,0,"<p>In this declaration</p>

<pre><code>char surnm[4] = {'P', 'i', 'n', 'e', '\0'};
</code></pre>

<p>there are 5 initializers but only 4 elements in array <code>surnm</code>. So the array will not contain a string because it did not included the terminating zero. You should write either</p>

<pre><code>char surnm[5] = {'P', 'i', 'n', 'e', '\0'};
</code></pre>

<p>or</p>

<pre><code>char surnm[] = {'P', 'i', 'n', 'e', '\0'};
</code></pre>

<p>or</p>

<pre><code>char surnm[5] = { ""Pine"" };
</code></pre>

<p>or</p>

<pre><code>char surnm[5] = ""Pine"";
</code></pre>

<p>or</p>

<pre><code>char surnm[] = { ""Pine"" };
</code></pre>

<p>or</p>

<pre><code>char surnm[] = ""Pine"";
</code></pre>
",1
31234848,31234790,3,"<p>You can define a string as an array of chars or a pointer to a char, strings terminate with a null (0 byte)</p>

<p>Examples:</p>

<pre><code>char c[]=""abcd"";  
char c1[5]=""abcd""; 
char c2[]={'a','b','c','d','\0'}; 
char c3[5]={'a','b','c','d','\0'};
char *c4=""abcd""; 
</code></pre>
",5
31234896,31234790,2,"<h2>String: array of characters</h2>

<ol>
<li>string: array of characters terminated by null character <code>'\0'</code>. Declaration: <code>char S[array_size];</code></li>
<li><p>string in/output:</p>

<p><code>scanf(""%s"",S);</code>  <code>printf(""%s"",S);</code></p></li>
<li><p><code>string.h</code> :collection of functions for string manipulation</p></li>
<li>no standard operators for string assignment and comparisons!
(remember: strings are arrays!)</li>
</ol>

<p>A sample code:</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

#define MAX_STRING_LEN 80

int main() {

  /* strings are array of characters 
   * terminated by the NULL character
   * which is different from '0' */

  char S[MAX_STRING_LEN];
  int l, i;

  S[0] = 'a';
  S[1] = 'b';
  S[2] = 'c';
  S[3] = 'd';
  S[4] = 'e';
  S[5] = 'g';
  S[6] = '0';
  S[7] = 0;

  l = strlen(S);

  printf(""S:\t%s\n"",S);
  printf(""length:\t%d\n"",l);

  /* print characters in S */

  printf(""forward\n"");
  for (i = 0; i &lt; l; ++i) 
    printf(""A[%d] = %c\n"",i,S[i]);

  /* print characters in S backwards */

  printf(""\nbackward\n"");
  for (i = l-1; i &gt;= 0; --i) 
    printf(""A[%d] = %c\n"",i,S[i]);
}
</code></pre>
",1
31232355,31232252,0,"<p>*p has higher precedence than +1 so this is what is happening:</p>

<p>you're sending three argments:</p>

<pre><code>-&gt;aaa
-&gt;eee
-&gt;iii
</code></pre>

<p>*p+1 points at the first character plus one, so it points at the second character. So, you print <code>aa</code> instead of <code>aaa</code>
**p+1 returns that value of the first character and adds one to it, giving you <code>b</code>. </p>

<p>Each of the commands operates the same, moving one into the string the first printf and incrementing the character by one in the interesting putchar command.</p>
",0
31232375,31232252,1,"<p>What else would you expect?</p>

<p>This:</p>

<pre><code>*p+1
</code></pre>

<p>means: ""Dereference <code>p</code>, and add <code>1</code> to the resulting value.""<br>
Since <code>p</code> dereferenced is a <code>char*</code>, you get an offset of 1 character, resulting in ""aaa"" becoming ""aa"", and likewise for ""e"" and ""i"".</p>

<p>And this:</p>

<pre><code>**p+1
</code></pre>

<p>means: ""Dereference <code>p</code>, then dereference the resulting value, then add <code>1</code>.""<br>
Since the result of dereferencing a <code>char**</code> twice is the first character of the first string of that array, the ""resulting value"" is <code>97</code>, or <code>'a'</code>, interpreted as a character.<br>
Add <code>1</code> to that and you get <code>98</code>, or <code>'b'</code>, interpreted as a character.<br>
The same goes for ""e"" and ""i"" again.</p>

<p>Also:</p>

<blockquote>
  <p>Did the line: <code>void (*pFunc)(void*);</code> create a function pFunc that is similar to function <code>print</code>?</p>
</blockquote>

<p>No. You just made <code>pFunc</code> another name for <code>print</code>.<br>
The functionality is therefore not similar, but identical.</p>
",0
31232386,31232252,1,"<blockquote>
  <p>Did the row: <code>void (*pFunc)(void*);</code> creates a function <code>pFunc</code> that is similar to function print?  </p>
</blockquote>

<p>Yes. <code>void (*pFunc)(void*);</code> declare <code>pFunc</code> as a pointer to a function that return type is <code>void</code> and expects an argument of type <code>void *</code>.   </p>

<blockquote>
  <p>Why is the output: <code>aa b ee f ii j</code>?  </p>
</blockquote>

<p>The snippet  </p>

<pre><code>for(i=1; i&lt; argc;i++) 
      pFunc(argv+i);  
</code></pre>

<p>passes all of you strings <code>aaa</code>, <code>eee</code> and <code>iii</code> to the function <code>print</code>. There you are casting <code>a</code> to <code>char **</code>.<br>
For first string <code>aaa</code>, <code>*p</code> is pointer to its first <code>char</code> and <code>*p+1</code> to second <code>char.</code>   Statement  </p>

<pre><code>printf(""%s"",(*p+1));  
</code></pre>

<p>will print the string from second character, i.e it will print <code>aa</code>.<br>
<code>**P</code> is a <code>char</code> and <code>**p+1</code> increment the ascii value of that character and <code>putchar(**p+1);</code> will print that character.  ASCII value of <code>a</code> is <code>97</code> and <code>98</code> <code>b</code>.    </p>

<p>Therefore, the output for <code>aaa</code> is <code>aa b</code>. Same goes for other arguments.</p>
",0
32956295,32955980,0,"<p>To do this, and allow other things to happen between calls, suggests using a thread.<br>
This is <strong><em>untested pseudo code</em></strong>, but if you are using Linux, it could look something like this:    (launch a thread and make it sleep for 60 seconds in the worker function loop between calls to your periodic function call)</p>

<pre><code>void *OneMinuteCall(void *param);
pthread_t thread0;

int gRunning == 1;

OneMinuteCall( void * param )
{
    int delay = (int)param;
    while(gRunning)
    {
        some_func();//periodic function
        sleep(delay);//sleep for 1 minute
    }
}

void some_func(void)
{
    //some stuff
}

int main(void)
{
    int delay = 60; //(s)
    pthread_create(&amp;thread0, NULL, OneMinuteCall, delay);
    //do some other stuff
    //at some point you must set gRunning == 0 to exit loop;
    //then terminate the thread

    return 0;
}
</code></pre>
",1
32956062,32955980,4,"<p>You cannot do that in standard C99 (that is, using <em>only</em> the functions defined by the language standard).</p>

<p>You can do that on <a href=""https://en.wikipedia.org/wiki/POSIX"" rel=""nofollow"">POSIX</a> systems. </p>

<p>Assuming you focus a Linux system, read <a href=""http://man7.org/linux/man-pages/man7/time.7.html"" rel=""nofollow"">time(7)</a> carefully. Then read about <a href=""http://man7.org/linux/man-pages/man3/sleep.3.html"" rel=""nofollow"">sleep(3)</a>, <a href=""http://man7.org/linux/man-pages/man2/nanosleep.2.html"" rel=""nofollow"">nanosleep(2)</a>, <a href=""http://man7.org/linux/man-pages/man2/clock_gettime.2.html"" rel=""nofollow"">clock_gettime(2)</a>, <a href=""http://man7.org/linux/man-pages/man2/getrusage.2.html"" rel=""nofollow"">getrusage(2)</a> and some other <a href=""http://man7.org/linux/man-pages/man2/syscalls.2.html"" rel=""nofollow"">syscalls(2)</a>...  etc...</p>

<p>The issue is to define what should happen if a command is running for more than X minutes.</p>

<p>Read some book about <a href=""http://www.makelinux.net/alp/"" rel=""nofollow"">Advanced Linux Programming</a> or <a href=""http://www.makelinux.net/books/lkd2/ch05lev1sec1"" rel=""nofollow"">Posix</a> programming.</p>

<p>BTW, Linux has <a href=""http://man7.org/linux/man-pages/man5/crontab.5.html"" rel=""nofollow"">crontab(5)</a> and all the related utilities are <a href=""https://en.wikipedia.org/wiki/Free_software"" rel=""nofollow"">free software</a>, so you could study their source code.</p>
",1
32956166,32955980,1,"<p>You could ask your calling  thread to <a href=""http://linux.die.net/man/3/sleep"" rel=""nofollow noreferrer""><code>sleep</code></a> for specified seconds.</p>

<pre><code>#include &lt;unistd.h&gt;

unsigned int sleep(unsigned int seconds);
</code></pre>

<p>This conform to POSIX.1-2001.</p>

<p><code>sleep</code> is a non-standard function. As mentioned <a href=""https://stackoverflow.com/questions/14818084/what-is-the-proper-include-for-the-function-sleep-in-c"">here</a>:</p>

<blockquote>
  <ul>
  <li>On UNIX, you shall include <code>&lt;unistd.h&gt;</code>.</li>
  <li>On MS-Windows, <code>Sleep</code> is rather from <code>&lt;windows.h&gt;</code></li>
  </ul>
</blockquote>
",2
32960084,32955980,0,"<p>As user3386109 suggested, using some form of clock for the delay and sleep to reduce cpu overhead would work. Example code to provide the basic concept. Note that the delay is based on an original reading of the time, (lasttime is updated based on desired delay, not the last reading of the clock). numsec should be set to 60*X to trigger every X minutes. </p>

<pre><code>/* numsec = number of seconds per instance */
#define numsec 3
time_t lasttime, thistime;
int i;
    lasttime = time(NULL);
    for(i = 0; i &lt; 5; i++){     /* any loop here */
        while(1){
            thistime = time(NULL);
            if(thistime - lasttime &gt;= numsec)
                break;
            if(thistime - lasttime &gt;= 2)
                sleep(thistime - lasttime - 1);
        }
        /* run periodic code here */
        /* ... */
        lasttime += numsec;     /* update lasttime */
    }
</code></pre>
",0
31283409,31283074,0,"<p>If your goal is to assign value to pointer in function using <code>scanf</code> then rather do something like this:</p>

<pre><code>int whatsbigger(int *p, int *p2)
{
    int b;
    scanf(""%d"", &amp;b);
    if (*p &gt; *p2)
    {
        *p = b;
    }
    else
    {
        *p2 = b;
    }
    return 0;
}
</code></pre>

<p>Declaration <code>int b;</code> must precede usage of <code>b</code>. Leaving <code>""%d\n""</code> as format string to <code>scanf</code> will force you to supply new line in terminal, so remove<code>\n</code>. As stated in previous answer it would be good idea to return result of comparison so that <code>main</code> actually knows what is bigger.</p>
",0
31283127,31283074,1,"<pre><code>#include    &lt;stdio.h&gt;

int *whatsbigger(int*, int*);

int main(void){
    int x = 10;
    int y = 25;
    int *biggest = whatsbigger(&amp;x, &amp;y);

    printf(""The biggest Value is: %d\n"", *biggest);
}

int *whatsbigger(int *p, int *p2){
    return (*p &gt; *p2) ? p : p2;
}
</code></pre>
",0
32928851,32928830,4,"<p>In C, <code>this</code> is a normal parameter name, no different from any other name.</p>

<p>You're probably using a C++ compiler, where <code>this</code> is a keyword and will give an error when used as a parameter.</p>
",0
32928852,32928830,2,"<p>In C++, <code>this</code> is a reserved word used in class methods as a pointer to the object in question.  It is <em>not</em> a reserved word in C, so in this case it's simply the name of the parameter.</p>

<p>This code will compile fine with gcc (provided you change <code>this-&gt;.name</code> to <code>this-&gt;name</code>), but it will not compile with g++ for this reason.</p>
",3
34178014,34177931,1,"<p>""\0"" is a string, '\0' is a character. As you comparing a character, you need the latter.</p>

<p>Also, as pointed out by  chqrlie, there are many other issues - you need to check your compiler warnings/errors and fix them all. For example,</p>

<ul>
<li><code>name[i]=="" ""</code> is wrong with the same reason.</li>
<li>where is <code>b</code> declared?</li>
<li>where is <code>i</code> initialized??</li>
</ul>
",2
34178481,34177931,0,"<p>There are many errors/ warnings in your code.</p>

<ol>
<li>It should be '\0'. Not ""\0"";</li>
<li>You have not declared b[];</li>
<li>Initialize i=0;</li>
<li>Instead of strcpy, you can use another method which is shown in below code.</li>
<li>Also, you should not use scanf in last line. You should use printf. scanf is used to take input from user. printf is used to print the results.</li>
</ol>

<p>Code-</p>

<pre><code>#include &lt;stdio.h&gt;
int main()
{
    int i=0,n;
    char name[20],b[20];
    printf(""Enter name: "");
    scanf(""%s"",name);
    printf(""Your name is %s\n"",name);
    while(name[i]!='\0') 
    {
        b[i]=name[i];  // to copy from name[] to b[]. Instead of strcpy
         i++;
    }
    printf(""copied name: "");
    for(n=0;n&lt;=i;n++)
  {
      printf(""%c"",b[n]);  // to show the copied result.
  }
    printf(""\n"");
    return 0;
}
</code></pre>
",0
32968134,32967160,0,"<p>Googling some of the header names, it looks like you are trying to compile a Linux kernel module. That means the compiler will be gcc at whatever version is recommended for the kernel you are compiling against. The OS will be Linux + the kernel development kit.</p>
",0
32992878,32987335,0,"<p>You need a char for the final <code>\0</code>, I have used a loop to get the 2 char</p>

<pre><code>#include &lt;string.h&gt; 
#include &lt;stdio.h&gt; 



int main(void) { 
    static char pvtsWsMthDayTab[25]=""312831303130313130313031""; 
    char sDaysInMth[12][3] ; 

    memset(sDaysInMth, 0, sizeof(sDaysInMth)); 

    for(int i = 0; i &lt; 12; i++) { 
        for (int j = 0; j &lt; 2; j++ ) { 
            sDaysInMth[i][j] = pvtsWsMthDayTab[i * 2 + j ]; 
        } 
    } 

    for(int i = 0; i &lt; 12; i++) { 
        printf(""%s\n"",sDaysInMth[i]); 
    } 


    return 0; 
} 
</code></pre>
",0
32992819,32992347,0,"<p>Count continuous characters, and output characters if the number of repetitions isn't exceeding the limit.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

/* this function make alphabet lower and make it not case sensitive */
/* note that tolower, which is in ctype.h, is not available here */
char normalizeAlphabet(char in)
{
    static const char* upperAlphabets = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ"";
    static const char* lowerAlphabets = ""abcdefghijklmnopqrstuvwxyz"";
    int index = -1;
    int i;
    for (i = 0; upperAlphabets[i] != '\0'; i++)
    {
        if (in == upperAlphabets[i])
        {
            index = i;
            break;
        }
    }
    if (index &gt;= 0)
    {
        return lowerAlphabets[index];
    }
    else
    {
        return in;
    }
}

void ReduceString(char *word, int Maximum)
{
    char *out = word;
    int currentRepetition = 0;
    int doNotOutput = 0;
    char currentChar = '\0';
    char normalizedChar;
    while (*word != '\0')
    {
        normalizedChar = normalizeAlphabet(*word);
        if (normalizedChar == currentChar)
        {
            /* continuous same characters */
            if (currentRepetition &lt; Maximum)
            {
                currentRepetition++;
            }
            else
            {
                doNotOutput = 1;
            }
        }
        else
        {
            /* hit to another character */
            currentChar = normalizedChar;
            currentRepetition = 1;
            doNotOutput = 0;
            if (Maximum &lt; currentRepetition) doNotOutput = 1;
        }
        if (!doNotOutput)
        {
            /* if repetition is not touching the limit, output the character */
            *out = *word;
            out++;
        }
        word++;
    }
    *out = '\0';
}

int main(void)
{
    char input[1024];
    char buf[1024];
    while (fgets(input, sizeof(input), stdin))
    {
        int i;
        printf(""input : %s"", input);
        for (i = 1; i &lt; 5; i++)
        {
            strcpy(buf, input);
            ReduceString(buf, i);
            printf(""reduced Maximum = %d : %s"", i, buf);
        }
    }
    return 0;
}
</code></pre>
",1
32992907,32992347,1,"<p>Simple solution:</p>

<pre><code>void x(char *s, int n)
{
    char *cp= s;
    int i, j;

    while (*cp) {
        i= 1;
        while (*(cp+i) &amp;&amp; ((*(cp+i))&amp;~32)==((*cp)&amp;~32)) i++;    // count character repeat
        for (j=0; j&lt;n &amp;&amp; j&lt;i; j++)              // repeat at most max repeat (n)
            *s++ = *(cp+j);
        cp += i;
    }
    *s= '\0';
}
</code></pre>

<p>EDIT: added max repeat (n)</p>

<p>EDIT: made case insensitive: <code>&amp;~32</code> removes the lower case bit in ASCII (this will get me the obfuscated C price).</p>
",1
31874612,31869031,2,"<p>As long as you're just reading in a file, you could just allocate the whole space for the file at once like:</p>

<pre><code>struct stat statbuf;
stat(""testfile"", &amp;statbuf);
char *myhtml = calloc(1,statbuf.st_size);
</code></pre>

<p>and maybe free the rest after you're done reading in.
Which is way cheaper because malloc is pretty expensive</p>
",1
31898696,31869031,0,"<p>there are several 'problems' with the posted code.</p>

<p>Rather than my detailing each problem.  just compare the posted code with the following</p>

<p>The following code eliminates those 'problems' and is faster as 'counter' is not being tested nor incremented, nor is 'counter' cluttering the stack.</p>

<pre><code>char *myhtml = NULL; // the accumulated lines
char *line = NULL;   // the current line
int len;             // set by the readline() function

// read and discard first two lines
getline(&amp;line, &amp;len, fp);
free(line);
line = NULL;
getline(&amp;line, &amp;len, fp);
free(line);
line = NULL;

while ((getline(&amp;line, &amp;len, fp)) != -1)
{
    char *temp = NULL; // so do not lose pointer to already allocated memory
    if( NULL ==(temp=realloc(myhtml,strlen(myhtml)+len+1) ) ) )
    { // realloc failed
        perror( ""realloc failed"");
        free( myhtml ); // cleanup
        free( line );   // cleanup
        exit( EXIT_FAILURE);
    }

    // implied else, realloc successful

    myhtml = temp;
    strcat(myhtml,line);
    free(line); // getline() performs a hidden malloc(), so have to free())
    line = NULL;  // reset for next iteration
}
</code></pre>
",0
32939281,32936236,1,"<p>In main, change:</p>

<pre><code>salida = fopen(final, ""r"");
</code></pre>

<p>Into:</p>

<pre><code>salida = fopen(final, ""w"");
</code></pre>

<p>This will truncate the file.  If you wanted to <em>update</em> the file (meaning change the existing file's contents without deleting it), you'd want ""r+"".</p>
",0
32939321,32936236,0,"<p>Your description of the problem is vague. Please update your question to show us the exact (copy-and-pasted) error message.</p>

<p>But when I compile your program, I get:</p>

<pre><code>c.c:1:26: fatal error:  stdio.h : No such file or directory
     #include &lt; stdio.h &gt; 
                          ^
compilation terminated.
</code></pre>

<p>Remove the spaces from the <code>#include</code> directives.  Change this:</p>

<pre><code>#include &lt; stdio.h &gt; 
#include &lt; stdlib.h &gt; 
#include &lt; string.h &gt;
</code></pre>

<p>to this:</p>

<pre><code>#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt; 
#include &lt;string.h&gt;
</code></pre>

<p>(The interpretation of the name between <code>&lt;</code> and <code>&gt;</code> is compiler-specific, but in this case the compiler is probably looking for a file whose name is literally <code>"" stdio.h ""</code>, including the leading and trailing spaces.)</p>
",3
30151759,30151736,0,"<p>You should run <code>srand</code> <em>once</em> - otherwise you're just reinitializing the state every time, which given you use <code>time(NULL)</code>, the generated number changes only every next second and is completely predictable.</p>
",5
29189468,29189417,0,"<p>When you do the strcat(A,B), you are modifying the string A points to.  You need to create a working buffer.  Something like:</p>

<pre><code>char work[12];
strcpy(work, A);
strcat(work, B);
printf(""%s"", work);
strcpy(work, A);
strcat(work, C);
printf(""%s"", work);
</code></pre>
",0
29189844,29189417,1,"<p>When you use strcat(A, B), the null char ('\0') marking the end of the A string gets replaced by the first char in B and all the following chars in B get appended from this point onward to A (that must be large enough to hold the result of the concatenation or undefined behaviour could occur).</p>

<p>After the strcat() call, A is no longer what you initially defined it to be, but a new string resulting from the concatenation.</p>

<p>If you want to reverse this, a simple solution is to keep A's lenght <em>before</em> doing the concatenation using <a href=""https://www.gnu.org/software/libc/manual/html_node/String-Length.html"" rel=""nofollow"">strlen()</a>:</p>

<pre><code>int A_len = strlen(A);
</code></pre>

<p>This way to reverse strcat(A, B) you only need to set the null char where it used to be before the concatenation:</p>

<pre><code>A[A_len] = '\0';
</code></pre>

<p>After this replacement, strcat(A, C) returns hellojames.</p>
",0
29191927,29191884,0,"<p>Enter the position of the square? You just need to know the position of the square to put a x over that square.</p>

<pre><code>#define CROSS -1
int i,j;
scanf(""%d%d"",&amp;i,&amp;j);
game_board[i][j]=CROSS;
</code></pre>

<p>So what should you do?</p>

<pre><code>#define CROSS -1
int row1,col1;
printf(""enter the position of the square you want to place an x in\n"");
scanf(""%d%d"",&amp;row1,&amp;col1 );//what goes here?
// modify game_board[row1][col1] as you need. Assuming zero-indexing.
if(row1&lt;3 &amp;&amp; col1&lt;3)
    game_board[row1][col1]=CROSS;
</code></pre>

<p><strong>Note</strong>: Instead of hardcoding the <code>magic numbers</code> here 3, just use them as a macro. In this case it will be...</p>

<pre><code>#define MAXROW 3
#define MAXCOL 3
</code></pre>

<p>These will help you change your code easily later.
You put checks like this ..</p>

<pre><code>if(row&lt;MAXROW &amp;&amp; col &lt;MAXCOL)
   // do something
</code></pre>

<p>The benefit is if you reconsider using a board size of 9x9 then you don't have to change all the 3's to 9's. Rather just change</p>

<pre><code>#define MAXROW 9
#define MAXCOL 9
</code></pre>
",1
29191943,29191884,0,"<pre><code>int r, c;

printf(""enter the row number of the square you want to place an x in\n"");
scanf(""%d"", &amp;r);

printf(""enter the column number of the square you want to place an x in\n"");
scanf(""%d"", &amp;c);

if (r &lt;= row &amp;&amp; c &lt;= column)
    game_board[r][c] = 'x';
else
    /* error */
printf(""%d\n"", game_board[r][c]);
</code></pre>
",0
29231411,29230907,-1,"<p><code>scanf()</code> receives until a spacebar is entered ie.only one string is accepted . This can be overcome by using </p>

<p><code>scanf(""%[^\n]s"",str);</code>.</p>

<p>It waits until newline is entered. <code>gets()</code> is also an alternative to receive string until newline is entered.</p>
",0
32952758,32952334,0,"<ol>
<li><p>scanf only counts to the first spacer if you use ""%s"" as initiater.</p></li>
<li><p>char kalimat[100000]; is ugly, ugly coding and still not safe to overflow. Just limit the chars you can enter to 200 or so.</p></li>
<li><p>String indexes start with 0, so your i counter should, too.</p></li>
</ol>
",0
32952791,32952334,0,"<p>The <code>%s</code> conversion specifier tells <code>scanf</code> to read up to the next whitespace character; it won't read in multiple words separated by whitespace.</p>

<p>The safer approach would be</p>

<pre><code>if ( !fgets( kalimat, sizeof kalimat, stdin ) )
{
  // error on input, handle as appropriate
}
else
{
  // process kalimat
}
</code></pre>

<p>Just be aware that <code>fgets</code> will store the trailing newline into <code>kalimat</code> if there's room.  And 10 kilobytes is a bit large for an auto array.  </p>
",0
32953182,32952334,0,"<p>Please try this, expand to other letters as needed, 'Y' maybe.</p>

<pre><code> #include &lt;string.h&gt;
 int main(  )
{
  int i = 0;
  int counter = 0;
  char c;
  char kalimat[100000];

  printf(""\n please enter text\n"");
  fgets( kalimat, 100000, stdin );

 for ( i = 0; i &lt; strlen( kalimat ); i++ )
 {
  c = toupper( kalimat[i] );
  if ( c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' )
   counter++;
 }
 printf( ""\n I counted %d vowels "", counter );
 getchar(  );
}
</code></pre>
",0
32952487,32952334,5,"<p><code>scanf</code> is only grabbing up until the first space. You need to pass a pattern to <code>scanf</code> that accepts whitespace. Try replacing the <code>""%s""</code> with <code>""%[^\n]""</code>.</p>
",2
33578150,33577920,1,"<p>Running your code through the popular online c compiler here: </p>

<p><a href=""http://www.tutorialspoint.com/compile_c_online.php"" rel=""nofollow"">http://www.tutorialspoint.com/compile_c_online.php</a></p>

<p>Your code ran as expected. What happens when you type "".""?</p>

<p>EDIT: (Solution)</p>

<p>The problem was that when you input a negative number,</p>

<pre><code>a = '-'
</code></pre>

<p>which has an integer value greater than zero, hence not triggering the negative case.</p>

<p>The solution then, is to check for the negative sign:</p>

<pre><code>if (a == '-') {...}
</code></pre>

<p>Also, note that the '.' entered to terminate the loop is being counted as a positive number.</p>
",0
33578248,33577920,0,"<p>You should just read the input into a string and convert it to an integer if the first character isn't a '.'.  Something like this:</p>

<pre><code>    printf(""type a number\n"");
    scanf(""%s"", a);
    if (a[0] == '.') {
        break;
    }
    i = strtoul(a, NULL, 10);
</code></pre>

<p>Then you can see if i is positive or negative.  Declare a as a char[10] or something.</p>
",4
34258672,34258641,2,"<p>You are not allowed to divide by 0. If the denominator is not 0, dividing ints results in an int, so you need to use floats or doubles to get a number between 0 and 1.  </p>
",4
31893246,31893227,2,"<p>A <code>static</code> pointer is used to implement a function which returns the <code>same buffer</code> to the program, allocating it the first time it is called</p>
",0
31893261,31893227,0,"<p><code>static</code> is persistent so if you declare it in a function, when you call the function again the value is the same as it was last time.</p>

<p>So use them when you need same value whenever function is called.</p>

<p>And about local pointer if pointer points to a local variable in the function block , so outside function block scope of variable ends and the pointer  becomes dangling pointer . And thus accessing such pointer will cause segmentation fault.</p>
",0
31893274,31893227,1,"<p>Apart from</p>

<pre><code>ptrb = &amp;b;
</code></pre>

<p>being pointless (scope etc...)</p>

<p>Why use static pointer?</p>

<p>It serves no purpose and is very bad coding style.</p>
",3
31893318,31893227,0,"<p>I think the other answer is correct. I would add this as explanation: A static pointer (or variable) has the same life cycle than a global pointer (or variable), except that its ""scope"" is limited to the function.<br>
It is not only used to return the same buffer (only one use case). You can also use it for other situations. For example if you want to implement a global counter or just save some state during the whole program life cycle (can be useful for a recursive function).</p>

<p>From my personal experience you may use it only in very rare cases.</p>
",0
31893425,31893227,1,"<p>If using a non <code>static</code> definition covers all needs, then use this. If it doesn't, use <code>static</code>.</p>
",0
33516920,33516807,0,"<p>The error is near the end of the line:</p>

<pre><code>(2.0(Dx*Dx)+(Dy*Dy))  
</code></pre>

<p>You need an operator between <code>2.0</code> and the parenthesis.
I guess you are missing a <code>*</code>?</p>

<p><strong>Note:</strong></p>

<p>I compiled it with <code>gcc</code> and got the much clearer error message:</p>

<blockquote>
  <p>error: called object '2.0e+0' is not a function</p>
</blockquote>
",0
34181797,34181643,5,"<p>This is a bit of a blind shot since you didn't provide the code that uses the <code>#define</code>, but you are violating one of the fundamental best practices about constants in <code>#define</code>s.</p>

<p>Since <code>#define</code>s are applied as a blind text replacement, if you don't surround calculations with parentheses you are potentially making a mess of the expressions of code that uses your define. Consider</p>

<pre><code>#define SEVEN 5+2
</code></pre>

<p>and then someone using it as</p>

<pre><code>printf(""thirty-five: %d"", SEVEN*5);
</code></pre>

<p>This will actually print 15, as it will be replaced as:</p>

<pre><code>printf(""thirty-five: %d"", 5+2*5);
</code></pre>

<p>So, to avoid problems always surround your constant defines with parentheses. Why the last one seems to work is behind me, maybe you didn't actually recompile with it?</p>
",3
34182328,34181643,2,"<p>I do not believe your claim that variation (2) produces the behavior you expect but (1) and (3) produce different behavior than each other. Furthermore, if indeed you were using the macro as you describe:</p>

<pre><code>*(OSLongType *)(SRAM1)= 0;
</code></pre>

<p>then you would not see any difference in behavior between (1) and (2).</p>

<p>I'm inclined to suppose that what you actually had a problem with was instead along the lines of</p>

<pre><code>*(OSLongType *)SRAM1= 0;
</code></pre>

<p>That has different meaning with your variations (1) and (3) than with your variation (2).  With variation (1), for example, it expands to</p>

<pre><code>*(OSLongType *)0xb0000000+((1024*1024)-64)= 0;
</code></pre>

<p>.  The cast and indirection operators have higher precedence than does <code>+</code>, so that's equivalent to</p>

<pre><code>(*((OSLongType *)0xb0000000)) + ((1024*1024) - 64) = 0;
</code></pre>

<p>.  That won't compile because the left-hand side of the assignment is not an lvalue.  Variation (3) does not solve this problem.</p>

<p>With variation (2), however, the expression expands instead to ...</p>

<pre><code>*(OSLongType *)(0xb0000000+((1024*1024)-64))= 0;
</code></pre>

<p>... which is perfectly valid.  The address is computed as an integer, then converted to a pointer, then dereferenced.  The result of the conversion is implementation defined, but the code should at least compile, and it may do what you want.</p>

<p>The only possible difference between variations (1) and (3) is the data types chosen for the integer constants.  The constant <code>1024</code> definitely has type <code>int</code>, and the expression <code>1024*1024</code> therefore also has type <code>int</code>.  If your system's <code>int</code>s are only 16 bits wide, however, then the arithmetic product of 1024 and 1024 does not fit in a 16-bit integer.  In that case, the resulting value of that expression is implementation-defined, and definitely not 1048576.  In that case, however, the constant <code>1048676</code> represents a valid value of type <code>long int</code>, making (3) different from (1).</p>

<p><strong>Updated to add:</strong></p>

<p>I would recommend consistently using this form:</p>

<pre><code>#define SRAM1     (0xb0000000+(((uintptr_t)1024*1024)-64))
</code></pre>

<p>Type <code>uintptr_t</code> is defined in <code>stdint.h</code>, which you will therefore need to include if you do not do so already.  You could throw in some more casts to <code>uintptr_t</code> if you are comforted by such consistency, but they are not necessary.</p>
",2
31893048,31892277,0,"<p>On the creation of the stack you don't have to create a node, I would only create a pointer to the top node, then set it to NULL so after creation the stack would be empty.</p>

<p>Try this:</p>

<p>Stack.h</p>

<pre><code>struct Node;
typedef int ElementType;
typedef struct Node *PtrToNode;
typedef PtrToNode Stack;

int IsEmpty(Stack S);
Stack CreateStack(void);
void DisposeStack(Stack *S);
void MakeEmpty(Stack *S);
void Push(ElementType X, Stack *S);
ElementType Top(Stack S);
void Pop(Stack *S);
</code></pre>

<p>Stack.c</p>

<pre><code>#include ""Stack2.h""
#include &lt;stdlib.h&gt;

struct Node {
    ElementType Element;
    PtrToNode Next;
};

int IsEmpty(Stack S) {
    return S == NULL;
}

Stack CreateStack(void) {
    Node *S = NULL;
    return S;
}

void DisposeStack(Stack *S) {
    MakeEmpty(S);
    free(*S);
}

void MakeEmpty(Stack *S) {
    while (!IsEmpty(*S)) Pop(S);
}

void Push(ElementType X, Stack *S) {
    PtrToNode newNode = (PtrToNode)malloc(sizeof(struct Node));
    newNode-&gt;Element = X;
    newNode-&gt;Next = NULL;
    if (IsEmpty(*S))
    {
        *S = newNode;
        return;
    }
    newNode-&gt;Next = (*S);
    *S = newNode;
}

ElementType Top(Stack S) {
    if (!IsEmpty(S))
        return S-&gt;Element;
    return 0;
}

void Pop(Stack *S) {
    if (IsEmpty(*S)) return;
    PtrToNode toPop = *S;
    *S = (*S)-&gt;Next;
    free(toPop);
}
</code></pre>

<p>tryStack.c  </p>

<pre><code>#include &lt;stdio.h&gt;
#include ""Stack2.h""

int main()
{
    int num;
    char c;
    Stack nums = CreateStack();
    while ((c = getchar()) != 'x' &amp;&amp; (c &gt;= '0' &amp;&amp; c &lt;= '9' || c == '\n')) {
        if (c == '\n') continue;
        num = c - '0';
        Push(num, &amp;nums);
    }
    while (!IsEmpty(nums)) {
        printf(""%d\n"", Top(nums));
        Pop(&amp;nums);
    }
    DisposeStack(&amp;nums);

    return 0;
}
</code></pre>

<p>When typing in the numbers you have to ignore '\n', it also good if you check if they are digits or not.</p>

<p>If You stick with your creation function, You can also use this code to get the input without the newline characters:</p>

<pre><code>while ((c = getchar()) != 'x' &amp;&amp; (c &gt;= '0' &amp;&amp; c &lt;= '9' || c == '\n')) 
{
    if (c == '\n') continue;
    num = c - '0';
    Push(num, nums);
}
</code></pre>
",0
33514177,33513479,2,"<p><code>stdin</code> is usually line buffered.  </p>

<p>Code does not see <em>any</em> input until <code>'\n'</code> is entered.   Entering <code>""123.""</code> is not enough.  Code needs a final <kbd>Enter</kbd>: <code>'\n'</code> (or closure of <code>stdin</code>).</p>
",0
33535248,33513479,0,"<p>the stdin is being input in 'cooked' mode, which means nothing is actually visible to the program until either EOF or  is entered by the user.  </p>

<p>If you want the data to be available to the program, keystroke by keystroke, then the terminal needs to be in 'raw' mode</p>

<p>the following code demonstrates how to set the terminal into 'raw' mode</p>

<p>Note: code swiped from:  <a href=""http://www.minek.com/files/unix_examples/raw.html"" rel=""nofollow"">http://www.minek.com/files/unix_examples/raw.html</a></p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;signal.h&gt;
#include &lt;termios.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

struct termios oldtermios;

int ttyraw(int fd)
{
    /* Set terminal mode as follows:
       Noncanonical mode - turn off ICANON.
       Turn off signal-generation (ISIG)
        including BREAK character (BRKINT).
       Turn off any possible preprocessing of input (IEXTEN).
       Turn ECHO mode off.
       Disable CR-to-NL mapping on input.
       Disable input parity detection (INPCK).
       Disable stripptcsetattr(fd, TCSAFLUSH, &amp;newtermios)ing of eighth bit on input (ISTRIP).
       Disable flow control (IXON).
       Use eight bit characters (CS8).
       Disable parity checking (PARENB).
       Disable any implementation-dependent output processing (OPOST).
       One byte at a time input (MIN=1, TIME=0).
    */
    struct termios newtermios;
    if(tcgetattr(fd, &amp;oldtermios) &lt; 0)
        return(-1);
    memcpy( newtermios, oldtermios, sizeof(struct termios) );

    newtermios.c_lflag &amp;= ~(ECHO | ICANON | IEXTEN | ISIG);
    /* OK, why IEXTEN? If IEXTEN is on, the DISCARD character
       is recognized and is not passed to the process. This
       character causes output to be suspended until another
       DISCARD is received. The DSUSP character for job control,
       the LNEXT character that removes any special meaning of
       the following character, the REPRINT character, and some
       others are also in this category.
    */

    newtermios.c_iflag &amp;= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);
    /* If an input character arrives with the wrong parity, then INPCK
       is checked. If this flag is set, then IGNPAR is checked
       to see if input bytes with parity errors should be ignored.
       If it shouldn't be ignored, then PARMRK determines what
       character sequence the process will actually see.

       When we turn off IXON, the start and stop characters can be read.
    */

    newtermios.c_cflag &amp;= ~(CSIZE | PARENB);
    /* CSIZE is a mask that determines the number of bits per byte.
       PARENB enables parity checking on input and parity generation
       on output.
    */

    newtermios.c_cflag |= CS8;
    /* Set 8 bits per character. */

    newtermios.c_oflag &amp;= ~(OPOST);
    /* This includes things like expanding tabs to spaces. */

    newtermios.c_cc[VMIN] = 1;
    newtermios.c_cc[Vtcsetattr(fd, TCSAFLUSH, &amp;newtermios)TIME] = 0;

    /* You tell me why TCSAFLUSH. */
    if(tcsetattr(fd, TCSAFLUSH, &amp;newtermios) &lt; 0)
        return(-1);
    return(0);
}


int ttyreset(int fd)
{
    if(tcsetattr(fd, TCSAFLUSH, &amp;oldtermios) &lt; 0)
        return(-1);

    return(0);
}

void sigcatch(int sig)
{
    ttyreset(0);
    exit(0);
}

void main()
{
    int i;
    char c;

    /* Catch the most popular signals. */
    if((int) signal(SIGINT,sigcatch) &lt; 0)
    {
        perror(""signal"");
        exit(1);
    }
    if((int)signal(SIGQUIT,sigcatch) &lt; 0)
    {
        perror(""signal"");
        exit(1);
    }
    if((int) signal(SIGTERM,sigcatch) &lt; 0)
    {
        perror(""signal"");
        exit(1);
    }

    /* Set raw mode on stdin. */
    if(ttyraw(0) &lt; 0)
    {
        fprintf(stderr,""Can't go to raw mode.\n"");
        exit(1);
    }

    while( (i = read(0, &amp;c, 1)) == 1)
    {
        if( (c &amp;= 255) == 0177) /* ASCII DELETE */
            break;
        printf( ""%o\n\r"", c);
    }

    if(ttyreset(0) &lt; 0)
    {
        fprintf(stderr, ""Cannot reset terminal!\n"");
        exit(-1);
    }tcsetattr(fd, TCSAFLUSH, &amp;newtermios)

    if( i &lt; 0)
    {
        fprintf(stderr,""Read error.\n"");
        exit(-1);
    }

    exit(0);
}
</code></pre>

<p>the main criteria is to declare a <code>struct termios</code>, use <code>tcgetattr(fd, &amp;oldtermios)</code> to acquire the current terminal settings, (for safety, now make a copy of the original terminal settings.)  copy <code>oldtermios</code> to a <code>newtermios</code> and modify the <code>newtermios</code> settings for the desired mode, then use <code>tcsetattr(fd, TCSAFLUSH, &amp;newtermios)</code> to modify the terminal to the 'raw' mode.</p>

<p>When done, be sure to call <code>tcsetattr(fd, TCSAFLUSH, &amp;oldtermios);</code> to return the terminal mode to 'cooked'</p>

<p>Note: <code>signal()</code> is obsolete/unreliable,  replace with <code>sigaction()</code></p>
",0
33566393,33566315,0,"<pre><code>int suma(int);
int produs(int);
</code></pre>

<p>and</p>

<pre><code>struct calcul{
    int suma();
    int produs();
};
</code></pre>

<p>are two completely different sets of functions, even though they have the same name. The functions in your struct are member functions and can only be called on an instance of your struct. You would do it like so:</p>

<pre><code>int main()
{
    calcul x;
    int a = x.suma(0);
    int b = x.produs(1);
}
</code></pre>
",0
33566416,33566315,0,"<p>I guess you want something like:</p>

<pre><code>struct calcul
{
    int suma(int n)
    {
        int result = 0;
        for (int i = 1; i &lt;= n; ++i)
            result += n;
        return result;
    }
    //... similar for produs
};

int main()
{
     calcul sp;
     int x = sp.suma(10);
};
</code></pre>
",0
33591207,33591177,3,"<p>One thing I noticed is that you are using the wrong size in first call to <code>malloc</code>.</p>

<pre><code>int **X = malloc(examples * sizeof(int));
                                   ^^^^^
</code></pre>

<p>It needs to be <code>sizeof(int*)</code>, or <code>sizeof(*X)</code>.</p>

<p><strong>PS</strong> That might not solve everything.</p>
",6
29535033,29534977,2,"<p>No, it should not be 4.</p>

<p>Your assumption is incorrect: Pointer arithmetic is done in units of the type being pointed at (i.e. <code>sizeof (int)</code> here), <em>not</em> in bytes.</p>

<p>Your array looks like this in memory:</p>

<pre><code>[ 2 | 3 | 1 | 6 ]
</code></pre>

<p>You are printing the difference between the addresses of the <code>1</code> and the <code>3</code>, which are adjacent, i.e. there's exactly 1 <code>int</code>'s worth of bytes between them.</p>

<p>Also, you're incorrect to print a pointer difference as if it's an <code>int</code> (with <code>%d</code>). The proper way is to use <code>""%"" PRIdPTR</code> and cast to <code>intptr_t</code>.</p>
",1
29535105,29534977,4,"<p>You're doing substraction on int pointers, so you get a result in ""sizeof(int) units"".
If you run your current code, it'll print 1, because those integers are indeed next to each other.</p>

<p>What you probably want to do is arithmetic on the addresses as numbers :</p>

<pre><code>int a[2][2]={{2,3},{1,6}};
printf(""%"" PRIiPTR,(intptr_t)&amp;a[1][0] - (intptr_t)&amp;a[0][1]);
</code></pre>

<p>Casting the pointers to <code>intptr_t</code> (in header <code>stdint.h</code>) is a way to do that.</p>

<p><code>PRIiPTR</code> is a macro (from header <code>inttypes.h</code>) used to output an <code>inptr_t</code> variable with printf.</p>
",2
33558835,33554136,0,"<p>this part of the posted code: </p>

<pre><code>if (idf==NULL)
    printf(""ERROR openning file..."");
else {
    for(i=0;number[i]!='\0';i++){
        if(number[i]!=' '){
            fscanf(idf,""%d"",&amp;number[i]);                
        }
    }        
}
</code></pre>

<p>contains a few problems</p>

<pre><code>1) it will exit the loop early 
   if some un-initialized value in the `number[100]` array 
      happens to be all 0x00
2) it does not pay attention to the returned value from `fscanf()` 
   so does not know when EOF is reached or an I/O error occurs.
3) it does not set a final entry in the `numbers[100]` array 
   to the termination flag `0` 
   BTW: poor method for indicating last entry in array
        Suggest using the variable 'i' and passing 'i' to each
        of the sub functions
4) it keeps executing when the `fopen()` function 
   returned a failure condition
</code></pre>

<p>Suggest writing it like so:</p>

<pre><code>// always place literal on left so compiler can catch `=` 
//   when should be `==` errors
if( NULL == idf )
{ // then fopen failed
    perror( ""fopen for Exercise_1.txt for read failed"" );
    exit( EXIT_FAILURE );
}

// implied else, fopen successful

// pre-init array to all 0 - this is a problem if input contains a 0
memset( number, 0x00, sizeof( number ) );

// input numbers into array until EOF or I/O error
for( i=0; 1==fscanf( idf, ""%d"", &amp;number[i] ); i++ ) {;}
</code></pre>
",1
33511503,33494217,2,"<p>Global names declared <code>static</code> have <em>internal linkage</em>, which means that such a name is private to the translation unit. More specifically, <em>within</em> one translation unit, all <code>static</code> declarations of a name refer to the same object or function, but in each translation unit, such a declaration refers to a distinct object or function. (By contrast, all names with <em>external</em> linkage refer to the same entity across the entire program.)</p>
",0
34224971,34224899,0,"<p>Putting this into a complete program, segv.c:</p>

<pre><code>int
main(
    void)
{
    *(int *) 0 = 'X';
    return 0;
}
</code></pre>

<p>and compiling:</p>

<pre><code>clang -Oz -Wno-error -s -o segv segv.c
</code></pre>

<p>Now, when I run it on my 64-bit GNU/Linux system, I do in fact get a segmentation fault:</p>

<pre><code>fish: ""./segv"" terminated by signal SIGSEGV (Address boundary error)
</code></pre>

<p>However, if you are seeking to generate segmentation faults, as some people in comments have pointed out, you should use <code>raise(3)</code> from <code>signal.h</code>.</p>
",0
34225039,34224899,3,"<p>The behaviour of <code>*(int *)0='X';</code> is <em>undefined</em>. </p>

<p>The compiler is free to do anything it pleases. (i) raise a SIGSEGV, (ii) not compiling the line at all are two possibilities.</p>

<p>To generate a fault explicitly, use <code>raise</code> as appropriate (defined in <code>&lt;signal.h&gt;</code>).</p>
",0
31273950,31272224,2,"<p>Your algorithm is O((m-n)*n) which of course won't run within the allocated time limit. Let's go over your code:</p>

<pre><code>count=0;
for(k=1;k&lt;=j/2;k++)
{
if(j%k==0)
count++;
if(count&gt;1)
break;
}
if(count==1)
printf(""%lld\n"",j);
</code></pre>

<p><em>Micro optimization</em>: Why do you need a counter? You could get away with a bool.</p>

<p><em>Optimization</em>: Why are you testing primes <code>j/2</code>? If <code>j</code> has a divisor greater than 1 than it's guaranteed that <code>j</code> has a divisor that's at most <code>sqrt(j)</code>.</p>

<p><em>Micro Optimization</em>: Don't consider even numbers at all, except for 2.</p>

<pre><code>bool prime = j==2 || j%2==1 ;
for(k=2;prime &amp;&amp; k*k&lt;=j;k++)
{
if(j%k==0) prime = false;
}
}
if(prime) printf(""%lld\n"",j);
</code></pre>

<p>Now this is O((m-n)*sqrt(n)) which is a lot faster.</p>

<p>I suppose this won't make the limit. You could extend the second micro-optimization to skip numbers divisible by 3 very easy.</p>

<p><em>Optimization</em>: If this is still not enough then you have to do a pseudo-primality test. One test that's very easy to implement in O(log(n)) is <a href=""https://en.wikipedia.org/wiki/Fermat_primality_test"" rel=""nofollow"">https://en.wikipedia.org/wiki/Fermat_primality_test</a>. With this the complexity is down to O((m-n)*log(n)) which should be run in the available time limit.</p>
",0
32467476,32467414,4,"<pre><code>while (cur-&gt;next != NULL)
</code></pre>

<p>This stops when <code>cur</code> is at the last element (<code>next</code> is <code>NULL</code>); i.e. you don't process the last node.</p>

<p>Changing it to</p>

<pre><code>while (cur != NULL)
</code></pre>

<p>and returning <code>head</code> should fix it.</p>
",3
32446677,32445572,1,"<pre><code>int main(){

char str[255];
int K;
int M;

for(;;)
{
    printf(""Enter the value of K: \n"");
    scanf(""%s"", &amp;str);
    if (str[0] == 'q' || str[0] == 'Q') break;
    sscanf(str, ""%d"",&amp;K);

    printf(""Enter the value of M: \n"");
    scanf(""%s"", &amp;str);
    if (str[0] == 'q' || str[0] == 'Q') break;
    sscanf(str, ""%d"",&amp;M);

    printf(""The Hash address of %d and %d is %d"",K,M,K%M);
}
return system(""pause"");}
</code></pre>
",3
32466346,32445572,1,"<p>This checks the return of <code>scanf()</code> to see if the scan was successful. If not, the buffer is cleared and checked for a 'q' that indicates that the program should exit.<br>
<code>getint()</code> accepts a prompt message and a pointer to a flag. Setting the flag to -1 tells the caller to exit.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int getint ( char *prompt, int *result);

int main ( int argc, char* argv[])
{
    int K, M;
    int ok = 0;

    do {
        K = getint ( ""\nEnter the value of K ( or q to quit)\n"", &amp;ok);
        if ( ok == -1) {
            break;
        }
        M = getint ( ""\nEnter the value of M ( or q to quit)\n"", &amp;ok);
        if ( ok == -1) {
            break;
        }
        printf(""\nThe Hash address of %d and %d is %d\n"", K, M, K % M);
    } while ( ok != -1);

    return 0;
}

//the function can return only one value.
//int *result allows setting a flag:
//  0 the function is looping
//  1 the function is returning a valid int
// -1 the function returns and the program should exit
// the caller can see the flag of 1 or -1
int getint ( char *prompt, int *result)
{
    int i = 0;
    int n = 0;

    *result = 0;

    do {
        printf(""%s"", prompt);
        if ( scanf(""%d"",&amp;n) != 1) {// scan one int
            while ( ( i = getchar ( )) != '\n' &amp;&amp; i != 'q') {
                //clear buffer on scanf failure
                //stop on newline
                //quit if a q is found
            }
            if ( i != 'q') {
                printf ( ""problem with input, try again\n"");
            }
            else {//found q. return and exit
                *result = -1;
                n = 0;
            }
        }
        else {//scanf success
            *result = 1;//return a valid int
        }
    } while ( *result == 0);

    return n;
}
</code></pre>
",1
33583562,33583478,2,"<p>you have to check character by character.
try this code : </p>

<pre><code>    int main(){
    int i = 0 ; int j = 1;
    char key[6]=""april"",ckey[6];
    printf(""Enter the key: "");
    scanf(""%s"",ckey);
    for(i = 0; i &lt; 6; i++){
      if(ckey[i] != key[i])
            j=0;
    }
    if(j == 1)
        printf(%s,""Correct."");
    else
        printf(%s,""Wrong."");  
    return 0;
}
</code></pre>
",3
33583572,33583478,-6,"<p>In the condition of the if statement</p>

<pre><code>if(ckey==key){
</code></pre>

<p>there are compared two addresses of the memory areas occupied by the arrays.</p>

<p>So you will always get false because the arrays occupy different memory areas.</p>

<p>If you may not use other standard functions as for example <code>strncmp</code> or <code>memcmp</code> declared in header <code>&lt;string.h&gt;</code> then you can write the following way</p>

<pre><code>#include &lt;stdio.h&gt;

int main( void ){
    char key[5]=""april"",ckey[6];
    printf(""Enter the key: "");
    scanf(""%5s"",ckey);

    size_t i = 0;

    while ( i &lt; sizeof( key ) &amp;&amp; key[i] == ckey[i] ) ++i;

    if( i == sizeof( key ) ){
        printf(""Correct."");
    }
    else{
        printf(""Wrong."");
    }
    return 0;
}
</code></pre>

<p>Instead of <code>scanf</code> it would be better to use <code>fgets</code>. In this case the size of the array <code>ckey</code> must be increased.</p>

<p>This declaration</p>

<pre><code>char key[5]=""april"";
</code></pre>

<p>is totally valid in C though is not valid in C++.:) </p>
",7
33583716,33583478,2,"<p>You have to leave space before ""%s"" inside the <code>scanf</code> statement,so that the '\n character is not stored in <code>ckey</code> to ensure success of comparison.note: <code>ckey</code> must have size 6 or more.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(){
    char key[] = ""april"",ckey[6];
    printf(""Enter the key: "");
    scanf("" %5s"",ckey);
    if(!strcmp(ckey, key)){
        printf(""Correct."");
    }
    else{
        printf(""Wrong."");
    }
    return 0;
}
</code></pre>
",4
33590685,33583478,1,"<p>You make several mistakes in array sizing for your keys. Remember, a C string is always terminated by a nul character and you must account for this when you size your arrays to accept such strings.</p>

<p>scanf is unsafe, don't use it. Use fgets instead. A safe use of fgets is:</p>

<pre><code>fgets (buffer, sizeof(buffer), stdin);
</code></pre>

<p>The answer to your question is no, it would be better to use strcmp if you want to lexically compare strings in C and that would involve including the  header. But even so, this is not adding any other ""libraries"" since fgets and strcmp are in the same standard C library.</p>

<p>If you must not add any other headers (which makes no sense if this is part of a larger project but makes perfect sense if this is a homework problem) then you can write your own strcmp (we'll call it compare here) and call it from main.</p>

<pre><code>#include &lt;stdio.h&gt;

int compare (const char* src, const char* dst)
{
    int ret = 0;
    while( ! (ret = *src - *dst) &amp;&amp; *dst){
        ++src, ++dst;
    }
    if ( ret &lt; 0 )
        ret = -1 ;
    else if ( ret &gt; 0 )
        ret = 1 ;
    return( ret );
}

    int main(void){
    char key[6]=""april"",ckey[6];
    printf(""Enter the key: "");
    fgets(ckey, sizeof ckey, stdin);

    if(!compare(key,ckey)) {
        printf(""Correct."");
    }
    else {
        printf(""Wrong."");
    }
    return 0;
}
</code></pre>

<p>A better use of your time would be to write it using the functions available to you in the standard C library:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void){
    char key[6]=""april"",ckey[6];
    printf(""Enter the key: "");
    fgets(ckey, sizeof ckey, stdin);

    if(!strcmp(key,ckey)) {
        printf(""Correct."");
    }
    else {
        printf(""Wrong."");
    }
    return 0;
}
</code></pre>

<p>But even this solution has a flaw. It will accept ""aprilaaaa"" or any string beginning with ""april"" as a valid ckey. Can you explain why? How would you fix this?</p>
",0
33533230,33532250,1,"<p>If i understood it right, you want to achieve the requirements by using the program you wrote above. 
<br/>It possible to re-design it using your own code. </p>

<p>eg : For  get() </p>

<pre><code>struct node *get(int key, void *data)
{
    if(*head_ref != NULL)
    {
        key = *head_ref-&gt;data;
        return *head_ref;
    }
    else
    { 
        printf(""Error in retrieving data from head of list\n"");
    }
}
</code></pre>

<p>In this way you can use code from your program and modify it slightly to achieve what is asked. 
The first node that you visit, if the list does exist- is the head of the list. You are asked to return a pointer to the head of the list and also copy the data in that node into variable 'key'.
If you are still having trouble, i would suggest you go through linked list concept once more to be sure you won't have any trouble. You can refer to Youtube to find videos on these concepts.</p>
",0
34222992,34222931,3,"<p>You need a pointer to pointer, not just a pointer.</p>

<p>If you want to change a variable in another function, you have to send a pointer to that variable. If the variable is an integer variable, send a pointer to that integer variable. If the variable is a pointer variable, send a pointer to that pointer variable.</p>

<p>You are saying in your question that ""when I give the <code>create_node</code> function the pointer to the root node, then it actually changes the <code>x</code> and the <code>next</code> of root."" Your wording makes me suspect that there is some confusion here. Yes, you are changing the contents of <code>x</code> and <code>next</code>, but not of <code>root</code>. <code>root</code> has no <code>x</code> and <code>next</code>, since <code>root</code> is a pointer that <em>points</em> to a struct that contains an <code>x</code> and a <code>next</code>. Your function does not change the contents of <code>root</code>, since what your function gets is only a <em>copy</em> of that pointer.</p>

<p>Changes to your code:</p>

<pre><code>int create_node(struct node **create_me, int init) {
    *create_me = malloc(sizeof(struct node));
    if (*create_me == 0){
        perror(""Out of momory in ''create_node'' "");
        return -1;
    }
    (*create_me)-&gt;x = init;
    (*create_me)-&gt;next = 0;
    return 1;
}

int main( void ){
    struct node *root;
    create_node(&amp;root, 0);
    print_all_nodes(root);

}
</code></pre>
",0
34223024,34222931,1,"<p>You need to do something like <code>create_node(&amp;root, 0);</code> and then access it as a <code>**</code> in the called method. C doesn't have pass by reference concept. You need to give the address to access it in another function.</p>
",1
34223165,34222931,1,"<p>This is a question of the scope of your variables. In the first example, where you supply a <em>pointer to a node</em>, you could change that node and the changes would persist afterwards. However, your <code>malloc</code> changes this pointer, which is discarded after the scope (your function) ends.</p>

<p>In the second example you return this pointer and therefore copy it before being discarded.</p>

<p>This would correspond to this in your given example no. 3:</p>

<pre><code>void change_i(int* p){
    *p = 5; // you can 'change i'
    p = 5 // but not p (pointer to i), as it is local -&gt; gets discarded after following '}'
}
</code></pre>
",1
34223370,34222931,1,"<blockquote>
  <p>when I give the create_node function the pointer to the root node, then it actually changes the x and the next of root.</p>
</blockquote>

<p>You <strong>don't</strong> give the <code>create_node()</code> function (in both versions) a pointer to the root node because you don't have the root node, in the first place.</p>

<p>The declaration:</p>

<pre><code>struct node *root;
</code></pre>

<p>creates the variable <code>root</code>, of type <code>struct node *</code> and lets it uninitialized. <code>root</code> is a variable that can store the address in memory of a <code>struct node</code> value (a pointer to a <code>struct node</code> value). But the code doesn't create any <code>struct node</code> value and the value of <code>root</code> is just garbage.</p>

<p>Next, both versions of function <code>create_node()</code> receive the garbage value of <code>root</code> in parameter <code>create_me</code> as a consequence of the call:</p>

<pre><code>create_node(root, 0);
</code></pre>

<p>The first thing both implementations of <code>create_node()</code> do is to ignore the value they receive in <code>create_me</code> parameter (be it valid or not), create a value of type <code>struct node</code> and store its address in <code>create_me</code>.</p>

<p>The lines:</p>

<pre><code>(*create_me).x = init;
(*create_me).next = 0;
</code></pre>

<p>put some values into the properties of the newly allocated <code>struct node</code> object.</p>

<p>The first version of the function then returns 1 and ignores the value stored in <code>create_me</code>. Being a function parameter (a local variable of the function), its value is discarded and lost forever. The code just created a memory leak: a block of memory that is allocated but inaccessible because there is no pointer to it. <strong>Don't do this!</strong></p>

<p>The second version of the function returns the value of <code>create_me</code> (i.e. the address of the newly allocated value of type <code>struct node</code>). The calling code (<code>root = create_node(root, 0);</code>) stores the value returned by the function into the variable <code>root</code> (replacing the garbage value used to initialize this variable).</p>

<p><strong>Great success!</strong> The second version of the <code>create_node()</code> function creates a new <code>struct node</code> object, initializes its properties and returns the address of the new object to be stored and/or further processed. Don't forget to call <a href=""http://en.cppreference.com/w/c/memory/free"" rel=""nofollow""><code>free(root)</code></a> when the object is not needed any more.</p>
",1
33512804,33512634,1,"<p>When the input matrix is of size <code>n x n</code>, the size of the auxiliary matrix, <code>aux</code>, needs to be <code>n-1 x n-1</code>.</p>

<p>Change </p>

<pre><code>int i, j, k, x, y, soma=0, aux[n][n];
</code></pre>

<p>to</p>

<pre><code>int i, j, k, x, y, soma=0, aux[n-1][n-1];
</code></pre>

<p>You said in a comment:</p>

<blockquote>
  <p>Can someone explain me please why it have to be that way?</p>
</blockquote>

<p>If you use <code>aux[n][n]</code> and <code>n</code> is 3, the memory layout of the object is:</p>

<pre><code>+---+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+---+
</code></pre>

<p>and you fill up the data as though it is a <code>2 x 2</code> matrix.</p>

<pre><code>0           1           2
+---+---+---+---+---+---+---+---+---+
| x | x |   | x | x |   |   |   |   |
+---+---+---+---+---+---+---+---+---+
</code></pre>

<p>In the next recursive call, you treat that memory as though it is a <code>2 x 2</code> array.</p>

<pre><code>0       1              
+---+---+---+---+---+---+---+---+---+
| x | x |   | x | x |   |   |   |   |
+---+---+---+---+---+---+---+---+---+
         ^        ^
         |        Ignored
         Using uninitialized array element
</code></pre>

<p>In theory, the program is subject to undefined behavior if you use <code>aux[n][n]</code> instead of <code>aux[n-1][n-1]</code>.</p>
",3
33514622,33514412,2,"<p>There is no way to <code>free</code> just some memory from allocated one. But have option of <code>realloc</code> is attempts to <strong>resize the memory block</strong> pointed to by ptr that was previously allocated with a call to malloc or calloc.</p>

<pre><code>void func()
{
        //allocate 1000 byte
    void *ptr = malloc(1000);

        //reallocate with new size 
    ptr = realloc(ptr ,500);
        //Now you have memory of 500 byte


      //free memory after use
    return;
}
</code></pre>
",0
33514486,33514412,1,"<p>There is no way to deallocate just 500 bytes out of 1000bytes allocated.</p>

<p><code>free()</code> function takes pointer returned by only <code>malloc()</code> and its family functions for allocation. So it will free all the memory allocated.</p>

<p>If your purpose is to show memory leak then</p>

<pre><code>void func()
{
  void *p =  malloc(1000);
  // Some stuff
  return;
}
</code></pre>

<p>Memory allocated is not freed here and you have a memory leak.</p>
",0
31217879,31217860,1,"<p><code>n</code> is uninitialized and you create an array of size <code>n</code> (guess what's the value of <code>n</code>) here:</p>

<pre><code>int t,i,j,n,p[n][n];
</code></pre>

<p>Declare the array <em>after</em> <code>n</code> gets initialized, i.e, change</p>

<pre><code>int t,i,j,n,p[n][n];
</code></pre>

<p>to</p>

<pre><code>int t,i,j,n;
</code></pre>

<p>and add</p>

<pre><code>int p[n][n];
</code></pre>

<p>after</p>

<pre><code>scanf(""%d"",&amp;n);
</code></pre>
",0
33553328,33553060,1,"<p>Especially if you are using pointers in a struct you should always memset it to 0 or call calloc. You should also check the return value of malloc. If it returns NULL then it failed to allocate.</p>

<pre><code>struct Name {
    char *p;
};


//allocate
struct Name *name = malloc(sizeof *name);
memset(name, 0, sizeof *name);
name-&gt;p = malloc(50 * sizeof *name-&gt;p);


//deallocate
free(name-&gt;p);
free(name);
</code></pre>
",0
33553110,33553060,3,"<p>First you have to deallocate name->p before deallocating name.</p>

<pre><code>free(name-&gt;p);
free(name);
</code></pre>
",0
32484199,32483746,1,"<p>Problems that I see:</p>

<ol>
<li><p>You are passing the wrong argument to <code>write</code>. Instead of </p>

<pre><code>write(STDERR_FILENO, s, MAX_SIZE); 
</code></pre>

<p>it should be</p>

<pre><code>write(STDERR_FILENO, s, r); // Write the number of characters that were read
                            // not MAX_SIZE
</code></pre></li>
<li><p>The strategy to skip till the end of the line is not well thought out. You have:</p>

<pre><code>int r = read(STDIN_FILENO, s, MAX_SIZE);
if(r==-1) printf(""error"");
else{
    write(STDERR_FILENO, s, MAX_SIZE);
}
while(getchar()!='\n');
</code></pre>

<p>First of all, <code>read</code> will not stop reading when it encounters a newline. It will read up to <code>MAX_SIZE</code> characters. It will gobble up as many newlines as it can in the process. What you need to do is use <code>fgets()</code> instead.</p>

<pre><code>char* cp = fgets(s, MAX_SIZE, stdin);
if ( cp == NULL )
{
   // If fgets fails, you probably reached the end of the file.
   break;
}

fprintf(stderr, ""%s"", s);
</code></pre></li>
<li><p>The line</p>

<pre><code>while(strcmp(s,""end\n"")!=0);
</code></pre>

<p>will lead to undefined behavior if you use <code>read</code> to read the data from a file since <code>read</code> does not automatically add a terminating null character to <code>s</code>. Using <code>fgets</code> avoids that problem.</p></li>
</ol>

<p>Also, since you know the size of the array at compile time, you can use:</p>

<pre><code>char s[MAX_SIZE];
</code></pre>

<p>instead of using <code>malloc</code> to allocate memory at run time.</p>
",0
32484521,32483746,0,"<p>FYI, an equivalent C++ program</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
    for (std::string line; std::getline(std::cin, line); ) {
        if (line == ""end"")
            break;
    }
}
</code></pre>
",1
33552870,33552385,1,"<p>What your compiler prints is correct. Here is the program flow:</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;

void main(void)
{
    clrscr();
    int n,a,b;

    n = 400;     // n has value 400
    a = n % 100; // a has value 0
    b = n / 10;  // b has value 40
    n = n % 10;  // n has value 0

    // n++ evaluates to  0, afterwards n has the value  1
    // ++b evaluates to 41, afterwards b has the value 41
    // ++a evaluates to  1, afterwards a has the value  1
    printf(""%d %d %d"",n++,++b,++a);
    // Thus, 0 41 1 is printed.
    getch(); 
}
</code></pre>

<p>Notice especially that the postfix-incrememnt operator <code>n++</code> returns the value of <code>n</code> unchanged and then changes <code>n</code>. That's why <code>0</code> is printed in the first column.</p>
",6
32470001,32469939,3,"<p>Even though you'd verbally express it as ""not 1 or 2"", programatically you'd use an <code>and</code> instead because it's only if neither values match up that you'd display your error prompt.</p>

<pre><code>if (type != 1 &amp;&amp; type != 2){
    printf (""Enter numbers 1 or 2"");
}
</code></pre>

<p>Using an <code>or</code> would cause issues. If you entered a <code>2</code>, the first statement is true and the if statement result would trigger.</p>

<p>Note: I am not factoring in what data type the <code>type</code> variable is.</p>
",0
33572772,33572694,1,"<pre><code> char* local_line;
 strncpy(local_line,line,counter+1);
</code></pre>

<p>In this before using <code>strncpy</code> you need to allocate memory to <code>local_line</code> using <code>malloc</code> or similar function.</p>
",2
33585084,33585053,4,"<p>That is because you are printing the character before you check.</p>

<p>What you want to do is to check and then print.</p>

<pre><code>do
{
    c = fgetc(fp);
    d += 1;
    if (c == '\n') {
        putchar(' ');
    }
    else
        putchar(c);
    arr[d] = c;
}
while (c != EOF);
</code></pre>
",1
32477877,32477810,2,"<pre><code>scanf("" %f"", &amp;num1);
</code></pre>

<p>should be</p>

<pre><code>scanf(""%f"", &amp;num1);
</code></pre>

<p>and check the return value of <code>scanf()</code></p>

<pre><code>if(scanf(""%f"", &amp;num1) != 1)
{
  printf(""scanf failed\n"");
}
</code></pre>

<p>When you enter <code>N</code> or <code>\n</code> you should be able to exit the loop after this</p>
",1
32477927,32477810,4,"<p>It will stop running if you type <strong>N</strong> (<code>'N'</code>) or <strong>Enter</strong> (<code>'\n'</code>). If you want to stop it typing a lowercase <strong>n</strong> (<code>'n'</code>) too, you should write:</p>

<pre><code>while (choice != 'N' &amp;&amp; choice != 'n' &amp;&amp; choice  != '\n');
</code></pre>
",1
32479963,32477810,-1,"<p>The mistake you had made that is about <code>scanf</code> statement. The running code for your program is below:</p>

<pre><code>       #include &lt;stdio.h&gt;
       int main() {
       float num1, num2, result;
       char choice;
       do {
           num1 = num2 = result = 0;
           printf(""first number?\n"");
           scanf(""%f"", &amp;num1);
           printf(""second number?\n"");
           scanf(""%f"", &amp;num2);
           result = num1*num2;
           printf(""ans = %.0f\n"", result);
           printf(""do you want to enter another pair of numbers?  (Y/N)\n"");
           scanf(""%c"", &amp;choice);
           } while (choice != 'N' &amp;&amp; choice  != 'n');
           return 0;
           }
</code></pre>
",2
34200533,34200481,2,"<p><code>rx_buffer</code> doesn't have NUL terminator. So you can't use <code>strcmp()</code> on it. Looking at your comparisons, you really wanted to compare chars.
So use <code>==</code> operator:</p>

<pre><code>if ( rx_buffer[0] == 'A' &amp;&amp; rx_buffer[5] == 'B' ) {
     printf(""Correct Message\n"");
}
</code></pre>

<p><code>strcmp()</code> is for comparing C-strings (A sewuence of characters terminated by a NUL byte) which is not what you have.</p>
",2
34200548,34200481,0,"<p>Comparing <code>char</code> should be done with <code>==</code>.</p>

<p>The <code>strcmp()</code> calls read past the end of <code>rx_bytes[]</code>.</p>
",0
33540463,33540433,1,"<p>change</p>

<pre><code>scanf (""%d"", radius);
</code></pre>

<p>with</p>

<pre><code>scanf (""%lf"", &amp;radius);
</code></pre>

<p>EDIT: added arc676's hint</p>
",2
33540518,33540433,6,"<p>This line <code>scanf (""%d"", radius);</code> should be <code>scanf(""%lf"", &amp;radius);</code> </p>

<p>Radius is not an <code>int</code> so you can't use <code>%d</code> and you need to give the address of the variable where the input has to be stored hence using <code>&amp;</code></p>

<p>Here is an excerpt from the man page of <code>scanf</code></p>

<blockquote>
  <p>The scanf() family of functions scans input according to format as
         described below.  This format may contain conversion specifications;
         the results from such conversions, if any, are stored in the
         locations pointed to by the pointer arguments that follow format.</p>
</blockquote>

<p>You can refer to this <a href=""http://man7.org/linux/man-pages/man3/scanf.3.html"" rel=""noreferrer"">man page</a> for more information on conversion and <code>scanf()</code> in general</p>
",0
34275070,34275041,8,"<p>It's because <code>stdout</code> is usually line-buffered. So your C library buffers the output. You can flush this by using <code>\n</code> in <code>printf()</code> or by calling <a href=""http://man7.org/linux/man-pages/man3/fflush.3.html""><code>fflush(stdout)</code></a>.</p>

<pre><code>  printf(""Whats up\n"");
</code></pre>

<p>or </p>

<pre><code>fflush(stdout); // call after the printf
</code></pre>

<p>You can also turn off the buffering with <a href=""http://man7.org/linux/man-pages/man3/setbuf.3.html""><code>setbuf()</code></a>:</p>

<pre><code>setbuf(stdout, 0);
</code></pre>
",1
33599339,33598629,0,"<p>Reading from binary files can definitely be performed via the functions <code>open</code>, <code>read</code>, <code>malloc</code>, <code>free</code> on platforms that support them, but be aware that binary files may contain <code>'\0'</code> bytes.</p>

<p>Therefore you cannot rely on the string functions that you use such as <code>ft_strchr</code>, <code>ft_join</code>, <code>printf</code> etc.  These handle C strings and will stop on embedded <code>'\0'</code> bytes.  You need to handle blocks of bytes directly, not C strings.</p>

<p>Furthermore, handling binary files as sequences of lines is not recommended: line endings may be transcoded by the runtime library: for instance CR LF pairs are converted to single <code>'\n'</code> bytes when reading files in text mode on Windows and vice versa when writing to <code>stdout</code> where text mode is the default. Other such transcoding may occur on other platforms.  Sadly, not every computer is a unix box.</p>

<p>Finally, even if no such transcoding occurs, the file may not end with a <code>'\n'</code> and adding one in the output may corrupt the file.</p>
",0
33594704,33594645,0,"<p>that's because there is a function called delete on line 38 but delete is a keyword in c++, rename the function!</p>

<p>EDIT:</p>

<p>as pointed out by my commenter you can also use the proper compiler</p>
",1
29954022,29953933,11,"<p><code>scanf</code> allows you to read all characters up to a specific character(s) by using this format specifier:</p>

<pre><code>%[^;,#]
</code></pre>

<p>This means ""read a string of characters until you hit a semicolon, a comma, or an octothorpe (pound)"". The <code>^</code> character at the beginning of the range means that the characters need to be excluded.</p>

<p>When you read into a fixed-size buffer, add the max number of characters to your format string:</p>

<pre><code>char name[100];
int id, points;
int count = scanf(""%d %99[^;];%d"", &amp;id, name, &amp;points);
if (count == 3) {
    // the read was successful
}
</code></pre>

<p><code>99</code> above means the max number of characters that can fit into the <code>name</code> buffer. Note that the buffer must have an additional <code>char</code> for the null terminator.</p>
",0
33827741,33827627,2,"<pre><code>Matrix[i][j]=matrixinput;
</code></pre>

<p>What you are doing is assign a <code>char</code> array of size <code>1</code> to an <code>int</code>. Your compiler issues a warning for this.</p>

<p>Don't assign arrays like this . </p>

<p>You want to take input in 2-d array, directly take inout in it using <code>scanf</code> -</p>

<pre><code>scanf(""%d"",&amp;Matrix[i][j]);
</code></pre>

<p>And this loop -</p>

<pre><code>while (i&lt;=(sizeint-1) &amp;&amp; j&lt;=(sizeint-1)){
</code></pre>

<p>This loop won't iterate for once , because condition will remain always <code>flase</code> as <code>sizeint-1</code> is <code>-1</code> as <code>sizeint</code> is <code>-1</code> . So , you need to work on this condition also .  </p>

<p><strong>Note</strong> - Increase your array's size and don't use <code>gets</code> , use <code>fgets</code> instead.</p>
",4
34253895,34253856,1,"<p>You have to allocate some memory for the string:</p>

<pre><code>#define MAX_CH 128

char string[MAX_CH];
</code></pre>

<p>then you can use it with an index ranged from 0 to 127:</p>

<pre><code>string[i] = ch;
</code></pre>

<p>your inner loop should be something like:</p>

<pre><code>int i = 0;
while( i &lt; MAX_CH &amp;&amp; (ch = fgetc(file))!= EOF){
    if(ch &gt;= 'A' &amp;&amp; ch &lt;= 'z'){
         string[i] = ch;
         i++;
         continue;
    }
}
</code></pre>
",1
34253967,34253856,1,"<p>The line triggering the compiler error is:</p>

<pre><code>string++ = ch;
</code></pre>

<p>Since <code>string</code> is a pointer, <code>string++</code> is also a pointer.  Further, because the pointer on the LHS of the assignment is the result of the increment, it is a non-modifiable 'lvalue'.  You need:</p>

<pre><code>*string++ = ch;
</code></pre>

<p>Now you're assigning to the thing the pointer points at (and then incrementing the pointer).</p>

<p>You also have a problem at:</p>

<pre><code>string = '\0';
</code></pre>

<p>This is a funny way of writing <code>string = NULL;</code> or <code>string = 0;</code> (setting the pointer to null) when what you want is <code>*string = '\0';</code> (null terminating the string).</p>

<p>You still have a problem: <code>string</code> points to an empty and non-modifiable string literal.  You haven't allocated any space for it to point to.  You might use something like this:</p>

<pre><code>char buffer[256];
char *string = buffer;
</code></pre>

<p>You then need to worry about not overflowing the end of the buffer that you're using.</p>
",0
34254128,34253856,0,"<p>Two things:
One, string++ is like writing string = string + 1, you can't do it on a assignment.
You'll get an error saying that left value must be modifiable, (string++) is not a modifiable value.</p>

<p>Two, before writing into memory you must allocate it first, so you have two options, either you allocate enough memory to contain your string on the stack:</p>

<pre><code>char string_buffer[1024];

char *string = &amp;(string_buffer[0]);
</code></pre>

<p>or, you can use a malloc/realloc scheme, but that's a slightly more complicated code, something along the lines of:</p>

<pre><code>#define INITIAL_SIZE 64
#define GROWTH_FACTOR 2
char *string_ptr = (char *)malloc(INITIAL_SIZE); // Allocates INITIAL_SIZE bytes.

if (!string_ptr) { /* malloc can return null value, when no memory is available. Handle here. */}

char *string = string_ptr;

// Doing stuff here, string outgrows it's boundaries.

string_ptr = (char *)realloc(string_ptr, INITIAL_SIZE * GROWTH_FACTOR);

if (!string_ptr) { /* malloc can return null values, when no memory is available. Handle here. */ }
</code></pre>

<p>Malloc'd memory must be freed eventually or you'll experience memory leaks.</p>

<p>Stack allocated strings (char[]) should not be returned to the calling function - since when it no longer 'lives' when the function on whose stack it was allocated returns.</p>

<p>Either way, you must use allocated memory to build your string.</p>
",0
34248619,34248569,0,"<p>Possible correction:</p>

<pre><code>#include &lt;stdio.h&gt;

#define SIZE 50

struct student{
    char name[30];
    int rollno;
    int sub[3];
    int total;
};

int main(void) /* use standard int main(void) instead of implementation-defined void main() */

{

    int i, j, max, count, tot=0, n, a[SIZE],ni;
    struct student st[SIZE];

    printf(""Enter how many students:""); /* prinf -&gt; printf */
    scanf(""%d"", &amp;n); /* the position of "" was wrong */


    for (i=0; i&lt;n; i++){
        tot=0;
        printf(""\nEnter name and roll number for student %d:"", i+1);
        scanf(""%s"", st[i].name); /* &amp;st[i].name is char (*)[30], but %s expects char* */
        scanf(""%d"", &amp;st[i].rollno);

        for (j = 0; j &lt;= 2; j++){
            printf(""Enter marks of student %d for subject %d:"", i+1, j+1);
            scanf(""%d"", &amp;st[i].sub[j]);
            tot=tot+st[i].sub[j];

        }
        st[i].total=tot;

    }

    printf(""\n\n\n"");

    for (i=0; i&lt;n; i++){
        printf(""Student %d Name:%s\n"", i+1,st[i].name);
        printf(""Student%d Rollno: %d\n"", i+1, st[i].rollno);
        for (j=0;j&lt;=2;j++) /* add loop */
            printf(""marks of subject %d: %d\n"", j+1, st[i].sub[j]);
        printf(""Total marks: %d\n\n"", st[i].total); /* put this line inside the loop */
    }


    return 0; /* add return 0; */
}
/* remove junk } */
</code></pre>
",1
34248653,34248569,2,"<p>I count five <code>{</code> characters and six <code>}</code> characters. That's not going to work out well for you :-)</p>

<p>Probably the easiest solution is to get rid of the spurious <code>}</code> at the end. It won't solve <em>all</em> your problems but it's most likely the cause of the <em>specific</em> problem you asked about, the ""error at the end or on the last line of my program"".</p>
",0
33554680,33554532,-4,"<pre><code>#include &lt;stdio.h&gt;

int main (void)
{
    int x = 3;

    int p = 8;

    double y = -3.1415;

    x = 11 % 3 + 1/x * 3.9 - (double)x;

    y = -(p/x) * (x/p);

    printf(""%d\n"",x);

    printf(""%lf\n"",y);

    return 0;
}
</code></pre>
",20
34253715,34253645,0,"<p>The array <code>edges</code> is uninitialized. So you can't deference its elements. This <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow"">undefined behaviour</a>. You don't really seem to need an array of pointers. So just use an array:</p>

<pre><code>Edge* edges[NUM_EDGES];
</code></pre>

<p>to </p>

<pre><code>Edge edges[NUM_EDGES];
</code></pre>

<p>and change the <code>-&gt;</code> to <code>.</code> operator everywhere in your code.</p>
",0
30139224,30139191,1,"<pre><code>#include &lt;iostream&gt;

int main()
{
  const int n = 10;
  int array[n] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
  int odd[n/2];
  int even[n/2];
  int l = 0; int k = 0;
  for (int i = 0; i &lt; n; i++) {
    if ((array[i] % 2) == 0) {
      even[l] = array[i];
      l++;
    } else {
      odd[k] = array[i];
      k++;
    }
  }

  std::cout &lt;&lt; ""Even Number: "" &lt;&lt; ""\n"";
  for (int i = 0; i &lt; n/2; i++) {
    std::cout &lt;&lt; even[i] &lt;&lt; "" "";
  }

  std::cout &lt;&lt; ""\nOdd Number: "" &lt;&lt; ""\n"";
  for (int i = 0; i &lt; n/2; i++) {
    std::cout &lt;&lt; odd[i] &lt;&lt; "" "";
  }
}
</code></pre>
",0
30139244,30139191,2,"<p>You are checking the loop variable <code>i</code>, not the values <code>num[i]</code>. Use</p>

<pre><code>for(i=1; i&lt;10; i++)    
{    
    if(num[i]%2 == 0)
        printf(""%d"",num[i]);    
}
</code></pre>
",0
30139454,30139191,1,"<p>If it is a C program then it can look like</p>

<pre><code>#include &lt;stdio.h&gt;

#define BILMAX 10

int main( void )
{
    int num[BILMAX];
    int i;

    printf( ""Enter %d numbers separated by space\n"", BILMAX );

    for ( i = 0; i &lt; BILMAX; i++ ) scanf( ""%d"", &amp;num[i] );

    printf( ""\n\nEven Numbers\n"" )

    for ( i = 0; i &lt; BILMAX; i++ )
    {
        if ( num[i] % 2 == 0 ) printf( ""%d "", num[i] );
    }

    printf(""\n\nOdd Numbers\n"");

    for ( i = 0; i &lt; BILMAX; i++ )
    {
        if ( num[i] % 2 != 0 ) printf( ""%d "", num[i] );
    }

    getchar();
}
</code></pre>

<p>If it is a C++ program then it can look like</p>

<pre><code>#include &lt;iostream&gt;

int main()
{
    const int BILMAX = 10;
    int num[BILMAX];

    std::cout &lt;&lt; ""Enter "" &lt;&lt; BILMAX &lt;&lt; "" numbers separated by space\n""; 

    for ( int i = 0; i &lt; BILMAX; i++ ) std::cin &gt;&gt; num[i];

    std::cout &lt;&lt; ""\n\nEven Numbers\n"";

    for ( int x : num )
    {
        if ( x % 2 == 0 ) std::cout &lt;&lt; x &lt;&lt; ' ';
    }

    std::cout &lt;&lt; ""\n\nOdd Numbers\n"";

    for ( int x : num )
    {
        if ( x % 2 != 0 ) std::cout &lt;&lt; x &lt;&lt; ' ';
    }

    std::cin.get();
    std::cin.get();
}
</code></pre>
",0
30140500,30139191,0,"<pre><code>  #include &lt;stdio.h&gt;  //use stdio.h instead of include .h//
  #include &lt;conio.h&gt;  //include conio.h if you are using getch()/
 #define BILMAX 10

int main(void)
 {
int num[BILMAX], i;

printf(""insert 10 number and separated by space\n"");

for(i = 0; i &lt; 10; i++)
   {
    scanf(""%d"", &amp;num[i]);//print num[i] instead of i//
   }

  printf(""\n\nEven Number: \n"");

  for(i = 0; i &lt; 10; i++)
   {
    if(num[i] % 2 == 0)
        printf(""%d "", num[i]);//print num[i] instead of i//
   }

printf(""\n\nOdd Number: \n"");

for(i = 0; i &lt; 10; i++)
   {
     if(num[i] % 2 != 0)
        printf(""%d "", num[i]);
   }
   getch();  
   return 0;

  }
</code></pre>
",0
32478959,32478314,0,"<p>The initializers for an array must be constant initializer-list. <code>s</code> being a <code>char</code>-array <a href=""http://port70.net/~nsz/c/c11/n1570.html#6.7.9p14"" rel=""nofollow"">requires</a> a string-literal or a constant array-initializer.</p>

<p>gcc has an extension, allowing auto-variables to be initialized with non-constant expressions, so it might work for gcc. Other compilers (e.g. clang) might(!) also allow this. Either way, you need to have extensions enabled.</p>

<p>This is true for all ISO-C versions (links are for C11).</p>

<p>You <a href=""http://port70.net/~nsz/c/c11/n1570.html#6.7.9p11"" rel=""nofollow"">can</a>, however, use <code>char *s</code> (<code>const char *</code> if you only use string-literals). This allows to use a normal expression, including non-constant.</p>
",4
32478438,32478314,4,"<p>Compiling with <code>-Wall</code> shows the error:</p>

<pre><code>$ gcc -Wall test.c
test.c:5:10: error: array initializer must be an initializer list or string literal
    char s[100] = (i == 2)? ""botton"":""bottle"";
         ^
1 error generated.
</code></pre>

<p>However, you can initialize with <code>strcpy()</code>:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main()
{
    int i = 2;
    char s[100] = {0};
    strcpy(s, (i == 2) ? ""botton"" : ""bottle"");
    printf(""%c\n"", s[0]);
    return EXIT_SUCCESS;
}
</code></pre>

<p>When the variable <code>s[]</code> is initialized, the initialization value must be known at compile-time. The equality test <code>(i == 2)</code> occurs at run-time, thus it cannot generate a valid initializer. </p>

<p>You can, however, use <code>char *s</code>, because you can change the value of a pointer at run-time:</p>

<pre><code>char *s = (i == 2) ? ""botton"" : ""bottle"";
</code></pre>

<p>You cannot, however, use <code>static char *s</code> with this initializer, because it is not a constant at compile-time.</p>
",14
34228809,34228629,1,"<p>The big change is the condition in the while loop:</p>

<pre><code>while (t != NULL)
</code></pre>

<p>and</p>

<pre><code>while (t-&gt;next != NULL)
</code></pre>

<p>In the first one a new node is created but there is no ""link"" to the existing list used, the pointer used to traverse the nodes has already gone past the end point.</p>

<p>In the second case the use of the conditional and the code</p>

<pre><code>t-&gt;next = tmp;
</code></pre>

<p>means that the new tmp node does in fact have a connection to the existing list, it isn't just dangling in some limbo like the first case's new nodes.</p>
",0
34228836,34228629,1,"<p>The 2nd example works because the <code>while</code> loop does not go all the way till the last node. See the <code>while</code> condition. The first example fails because you go to the last node, and set the newly allocated <code>Node *tmp</code> to t(which is <code>NULL</code>) by definition of your <code>while</code> loop condition.</p>

<p>Graphically: </p>

<p>When your while loop breaks:</p>

<p><strong>NODE 1--> NODE 2--> NODE 3--> NODE 4--> NODE 5 -->NULL</strong></p>

<pre><code>                                  t points here  ^(1st case)
</code></pre>

<p><strong>NODE 1--> NODE 2--> NODE 3--> NODE 4--> NODE 5 -->NULL</strong></p>

<pre><code>                            t points here ^       (2nd case)
</code></pre>

<p>(So, basically you're assigning something to <code>NULL</code>. <code>NULL</code> is <em>not</em> your last node). Also, t is a local variable</p>

<p>This is correct since you're not assigning a new node at the end of the last one.</p>
",0
34228933,34228629,0,"<p>The first code does not insert multiple elements in the list. It inserts only one, which is why it prints only one.</p>

<p>At the end of this loop <code>while (t != NULL)</code>, t is NULL. The rest of the block simply creates a new node, and assigns it to t, without updating the list.</p>

<p>In the second code, t points to the last element of the list. So adding an element at <code>t-&gt;next</code> does update the list.</p>
",0
34249249,34249134,0,"<p>Why do you want to do this? Just take as input an integer array without commas. But if you want, then here is how to achieve it.
You can use a character array to keep such data. An integer array will not do.
Your input will be stored as: </p>

<pre><code>char a[3];
a[0]='1';
a[1]=',';
a[2]='2';
</code></pre>

<p>So to take the input, first define a character array  <code>a[n]</code> of size <code>n</code>, then take the input as</p>

<pre><code>while(i&lt;n)
{
    a[i]=getchar();
    i++;
}
</code></pre>

<p>This will keep your data in the array as <code>a[n]={'1' , ',' , '2' , ',' upto n}</code>
You can then print them as </p>

<pre><code>i=0;
while(i&lt;n)
{
    putchar(a[i]);
    i++;
}
</code></pre>

<p>You give your input as:</p>

<pre><code>1,2,3,4,5
</code></pre>

<p>and the output will be:</p>

<pre><code>1,2,3,4,5
</code></pre>

<p>The even numbered indexes will contain the numbers and the odd numbered indexes will contain commas.</p>
",0
34249416,34249344,6,"<p>If your <code>INT_MAX</code> is <code>2147483647</code> (<code>pow(2, 31) - 1</code>), <code>2*a</code> and <code>a+a</code> do cause overflow, and overflow in signed integer aritimetic is <em>undefined behavior</em> in C.</p>

<p>Quote from <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf"" rel=""nofollow"">N1256</a> 6.5 Expressions:</p>

<blockquote>
  <p>5 If an <em>exceptional condition</em> occurs during the evaluation of an expression (that is, if the
  result is not mathematically defined or not in the range of representable values for its
  type), the behavior is undefined.</p>
</blockquote>

<p>Undefined behavior can cause <em>everything</em>. See your compiler's output to know the reason for this specific result.</p>

<p>To know where the value of <code>2*a</code> and <code>a+a</code> are stored, also see your compiler's output. I guess they should be stored in register, not in memory if your compiler is smart enough. Some poor compiler may store their value on the stack on the memory.</p>
",3
34253947,34253854,3,"<p>You can't use <code>switch</code> to compare strings.  It only works on integer types.  Also, string constants are denoted with double quotes (<code>""</code>), not single quotes (<code>'</code>).  You need to use <code>strcmp</code> to compare strings:</p>

<pre><code>if (!strcmp(name, ""name1"")) {
    printf(""\nYou are good\n"");
} else if (!strcmp(name, ""name2"")) {
    printf(""\nYou are not so good\n"");
} else if (!strcmp(name, ""name3"")) {
    printf(""\nYou are bad\n"");
} else if (!strcmp(name, ""name4"")) {
    printf(""\nYou are very ba\n"");
} else {
    printf(""\nYou entered an invalid letter\n"");
}
</code></pre>
",2
34254053,34253854,1,"<p><code>switch(expression)</code></p>

<p><em>The <code>expression</code> used in a switch statement must have an integral or enumerated type, or be of a class type in which the class has a single conversion function to an integral or enumerated type.</em></p>

<p>You can't use <code>switch</code> to compare two strings as <em>dbush</em> said.It is better to compare the two strings and print the desired result.</p>

<p>You should also remove the trailing newline character as otherwise you won`t get the desired result:</p>

<pre><code>fgets(name,20,stdin);
len = strlen(name);
name[len - 1] = '\0';
</code></pre>
",3
33544061,33543520,1,"<p>Roughly speaking, the basic mechanism to use would be the same. In <code>MyMalloc</code>, allocate <code>2*sizeof(int)</code> space more, store the content of a <code>chunk</code> there and return the address behind the <code>2*sizeof(int)</code>. On deallocation, do the same process in reverse - subtract <code>2*sizeof(int)</code> from the argument to access the content of which was stored in <code>chunk</code> before.</p>
",0
34186477,34185799,1,"<p>I think you are already pretty close to a solution. Just keep a <code>char*</code> in your struct and allocate it via char-array. In order to have the save trailing zero at the end of string, just allocate an extra char additional to the size and initialize the whole array with zeroes.</p>

<pre><code>typedef struct
{
    int length;
    char* str;
} strbuf_t;

#define STRBUF(varname, size) \
    char _buffer_ ## varname[size + 1] = {'\0'}; \
    strbuf_t varname = { size, _buffer_ ## varname }

int main()
{
    STRBUF(a, 10);

    strncpy(a.str, ""Hello, world!"", a.length);
    printf(""a.length = %d\n"", a.length);
    puts(a.str);
}
</code></pre>
",6
34188239,34185799,1,"<p>Perhaps the following.  Allocate the memory with an aligned VLA and then overlay.</p>

<pre><code>typedef struct strbuf_t_ {
    int  length;
    char str[];
} strbuf_t;

#include &lt;stddef.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdalign.h&gt;

int main(void) {
  char *s = ""Hello"";

  size_t length = strlen(s);
  size_t n = sizeof (strbuf_t) + length + 1;
  _Alignas(strbuf_t) unsigned char mem[n];

  strbuf_t *xx = (strbuf_t*) mem;
  xx-&gt;length = length;
  memcpy(xx-&gt;str, s, n+1);

  printf(""int:%zu s:%zu n:%zu mem:%zu\n"", 
      sizeof xx-&gt;length, sizeof (strbuf_t), n, sizeof mem);
  return 0;
}
</code></pre>

<p>Output</p>

<pre><code>int:4 s:4 n:6 mem:10
</code></pre>

<p>Note: C99 allows the last <code>struct</code> member to have an indefinite array count of <code>[]</code></p>
",0
34250753,34250703,2,"<p>Multi character constants are of <code>int</code> type and their value is not strictly defined-- it's platform dependent stuff. So using them as normal letters is not best idea, even though you can use them in every context as normal char there is no guarantee that they will be compiled as you intend (as in your example you get only last char from ur string).
here you have explanation of the topic:
<a href=""https://stackoverflow.com/questions/6944730/multiple-characters-in-a-character-constant"">Multiple characters in a character constant</a></p>
",0
34250754,34250703,2,"<p>While it is technically valid C to define <code>OK</code> as <code>'_/'</code>, the value of a multi-character character constant is implementation defined, so this is probably not something you want to do.</p>

<p>There is no way you will be able to print more than one character without resorting to strings.</p>
",0
32478116,32477786,0,"<p>Starting at the end of the path you can copy characters from the path to another string until you find the '\' character. So after the while loop the <code>reverseFileName</code> string will be <code>'txt.olleH'</code>. The for loop reverses the <code>'txt.olleH'</code> to <code>'Hello.txt'</code></p>

<pre><code>char* GetFileName(char[] path)
{
      char *reverseFileName = malloc(100*sizeof(char));
      int len = strlen(path);
      int i=len-1;
      int j=0;
      while( (path[i] != '\') &amp;&amp; (i&gt;=0) )
      {
        reverseFileName[j] = fileName[i];
        i--;
        j++;
      }
      reverseFileName[j+1]='\0';
      int reverseLength = strlen(reverseFileName)
      char *fileName = malloc( (reverseLength+1)*sizeof(char) );
      j=0;
      for(i=reverseLength-1; i&gt;=0; i++)
      {
        fileName[j] = reverseFileName[i];
        j++;
      }
      free(reverseFileName);
      return fileName;
 }
</code></pre>
",2
32478153,32477786,2,"<p>Loop through the string looking for the last separator. If <code>/</code>, <code>\</code> and <code>:</code> are valid path separators (Windows):</p>

<pre><code>char *getFileName(char *path) {
    char *retVal = path, p;
    for (p = path; *p; p++) {
        if (*p == '/' || *p == '\\' || *p == ':') {
            retVal = p;
        }
    }
    return retVal;
}
</code></pre>
",3
32478632,32477786,2,"<p>Without using built-in string functions, I assume you can't use <code>strlen</code> or <code>strdup</code>. The simplest way you can achieve that is:</p>

<pre><code>char *fname(char *path)
{
    char *aux = path;

    /* Go to end of string, so you don't need strlen */
    while (*path++) ;

    /* Find the last occurence of \ */
    while (*path-- != '\\' &amp;&amp; path != aux) ;

    /* It must ignore the \ */
    return (aux == path) ? path : path + 2;
}
</code></pre>

<p><br>
<hr> 
<br>
<strong>EDIT:</strong> Thanks to <a href=""https://stackoverflow.com/users/646887/klas-lindb%C3%A4ck"">Klas Lindb?ck</a> for pointing out that the original function had no boundary check and would fail in case the provided <code>path</code> had no occurrence of <code>\\</code>.</p>
",1
34197073,34196943,1,"<pre><code>ptr=(char *)&amp;a;
</code></pre>

<p>You are type casting the address of float variable to as character pointer.</p>

<p>and next you are accessing that memory.</p>

<p>So here you need to understand how float variable are stored. and then see architecture of your system(Little endian or big endian) then only you can map its content</p>

<p>see <a href=""https://stackoverflow.com/questions/6910115/how-to-represent-float-number-in-memory-in-c"">How to represent FLOAT number in memory in C</a></p>
",0
34197098,34196943,-1,"<p>Without knowing what it is running on, and what it was compiled on it would be hard to say?
Are you are aware some systems store bytes that make up longer types the opposite way around, that the size of an int or float will be a different number of bytes, and that compilers may space out parameters on the stack, or reorder them....</p>

<p>So you (conceivably) could end up with a two byte float (ok, not terrible realistic, but possible) that laid out in memory next to the int is:</p>

<pre><code>Float a [Low byte]
Float a [High byte]
Int i [Low byte]
Int i [High byte]
char * ptr [Low byte]
char * ptr ... etc
</code></pre>

<p>And your iteration of 4 bytes' worth would go straight through both stack variables....</p>

<p>More interestingly what if the compiler laid it out the way you have listed but again has that (silly) two byte float (ignore the byte order):</p>

<pre><code>Int i [Low byte]
Int i [High byte]
Float a [Low byte]
Float a [High byte]
char * ptr [Low byte]
char * ptr ... etc
</code></pre>

<p>your four byte iteration will start examining the contents of the pointer that is examining (itself).</p>

<p>So, when examining data in the loop, you may want to use the size of the type you are examining:</p>

<pre><code>for (i=0; i&lt;= sizeof(a); i++)
</code></pre>
",0
34200431,34196943,0,"<p>I guess You are trying to understand how <a href=""https://en.wikipedia.org/wiki/IEEE_754-1985"" rel=""nofollow"">IEE754</a> works.</p>

<p>The following code could show you how float is represented:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

typedef union {
  float f;
  struct {
    unsigned int mantissa : 23;
    unsigned int exponent : 8;
    unsigned int sign : 1;
  } parts;
} myStruct;

int main()
{
    myStruct a;

    a.f=5.2;
    float Calculated;

    unsigned int Temp = a.parts.mantissa;
    double significand = 1;

    // LSB will be 1/(2^24)
    double bitValue = (double)(1)/(double)(16777216);

    // Calculate the significand value
    do
    {
        bitValue *= 2;
        significand += ((Temp&amp;0x00000001) == 1) ? bitValue : 0;

    }while (Temp&gt;&gt;=1);

    printf(""Hex Value   = %04x\n"",*((unsigned int *)&amp;a.f));
    printf(""Float Value = %f\n"",a.f);
    printf(""exp         = %i, 0x%02x\n"",a.parts.exponent, (unsigned int)(a.parts.exponent));
    printf(""sign        = %i\n"",a.parts.sign);
    printf(""mantissa    = %i, 0x%02x\n"",a.parts.mantissa,(unsigned int)(a.parts.mantissa));
    printf(""significand = %1.10f\n\n"", significand);


    Calculated = pow(-1, a.parts.sign) * pow(2,a.parts.exponent-127) * significand;
    printf (""Calculated: %f\n"", Calculated);

    return 0;
}
</code></pre>

<p>Compile it with command:</p>

<pre><code>gcc -o float_IEEE754 float_IEEE754.c -lm -Wall
</code></pre>
",0
34215985,34215696,1,"<p>The code on line 57 is illegal.  Functions may not be defined inside other functions in ISO C.  </p>

<p>The error suggests your compiler has an extension to allow nested functions, giving them <em>internal linkage</em>. But you gave a prototype with external linkage, a mismatch.</p>

<p>To fix this, stop using nested functions. (You probably could fix it by adding <code>static</code> to the start of the prototype, however this is bad coding style).</p>
",1
31816228,31816152,0,"<p>In the original code, if (for example) <code>h-&gt;data[temp]&gt;h-&gt;data[temp*2]</code> were false, <code>DO()</code> wouldn't be executed, but the loop would continue.  In the new version, the loop would stop.</p>
",0
31816470,31816152,0,"<blockquote>
  <p>For example int A=1; if(A==1){}; is similar to int A=1 while(A!=1).</p>
</blockquote>

<p>As already mentioned, your loop is breaking. The above statement is also incorrect.</p>

<pre><code>int a = 1;
if(a == 1) {} //this is true, and will happen once
</code></pre>

<p>BUT</p>

<pre><code>int a = 1;
while(a != 1) {} //false on entry, skip loop ( never entered )
</code></pre>

<p>You could also consider a switch / case if you can isolate the condition.
This might achieve your goal of removing the ifs, and make the code more readable.</p>

<p>e.g</p>

<pre><code>int a = 1;
while(a)
{
    switch(a)
    {
        case 1: ++a; continue;
        case 2: do();
        default: break;    //end loop
    }
}
</code></pre>
",0
31819971,31816152,0,"<p>As others said, there is no reason to obfuscate the code with an extra while statement; the original is perfectly clear. There is also no need for the <code>else</code> in your original:</p>

<pre><code>while(C1)
{
    if(C2)
    {
        if( h-&gt;data[temp] &lt; h-&gt;data[temp*2] &amp;&amp; h-&gt;data[temp] &lt; h-&gt;data[temp*2+1] )
        {
             break;
        }
        if(C4)
        {
            DO();
        }

    }
}
</code></pre>
",0
34079163,34079071,1,"<p>When you make an assignment with array of char in C, it will not copy the content of the array.</p>

<p>Instead of use:</p>

<pre><code>temp.name = shift_data[i].name;
</code></pre>

<p>do:</p>

<pre><code>strncpy(temp.name, shift_data[i].name, 99);
temp.name[99] = '\0';
</code></pre>

<p>I'm sorry, I advised you to use <code>memcpy()</code>, but you have to check the lenght of the string to know how many bytes to copy and is not the correct function to use.</p>

<p>Using <code>strncpy</code> is better, because the copy stops when reach a null byte or 
the maximum number of characters that can be stored. Note, the lenght of your string is <code>100</code>. The <code>99</code> will make <code>strncpy</code> copy from index 0 to 98 in your string. And the line <code>temp.name[99] = '\0';</code> will fill the last position of your string with <code>\0</code>.</p>

<p>On this page: <a href=""http://linux.die.net/man/3/strncpy"" rel=""nofollow"">http://linux.die.net/man/3/strncpy</a>, has a better description about <code>strncpy</code> and a simple code for this function.</p>
",0
34079704,34079655,2,"<p><code>fgetc</code> returns a single character code which is not equivalent to the characters numeric value. In your code you are comparing and adding character code values.</p>

<p>You need to convert the character code to an integer with something like:</p>

<pre><code> int num = cse - '0';
</code></pre>
",0
34079707,34079655,2,"<p>Two issues:</p>

<ul>
<li><code>total += cse;</code> should be <code>total += ( cse - '0' );</code></li>
<li><code>fprintf(outp, ""Total is %c\n"", total);</code> should be <code>fprintf(outp, ""Total is %d\n"", total);</code></li>
</ul>
",1
34079708,34079655,3,"<p>Two things. First, you're adding the character ASCII value, not what the character represents:</p>

<pre><code>total += cse;
</code></pre>

<p>You may want to subtract the value of character zero from that, as a barely simple conversion:</p>

<pre><code>total += cse - '0';
</code></pre>

<p>Then, second, you're printing a character value:</p>

<pre><code>fprintf(outp, ""Total is %c\n"", total);
</code></pre>

<p>Use an integer formatter like <code>%d</code>. </p>
",1
34080198,34080191,3,"<p>The first expression in your <code>for</code> loop is not used and it's equivalent to writing</p>

<pre><code>i;
</code></pre>

<p>change it to</p>

<pre><code>for (; i &lt; maxAccounts ; ++i)
</code></pre>

<p>or better, since it's only executed the very first time the loop is found, use it to initialize and declare <code>i</code>, like this</p>

<pre><code>for (int i = 0 ; i &lt; maxAccounts ; ++i)
</code></pre>
",0
30694200,30685865,0,"<p>Edit: There is another solution, described in the bottom of this answer.</p>

<p>I tested your code, it seems you need to acceed data in shared memory using a one dimension array. For example:</p>

<pre><code>int * grid;

for(i=0; i&lt;nbr; i++)
  for(j=0; j&lt;nbr; j++)
    grid[i*nbr + j] = 0;
</code></pre>

<p>You can have a look at this code, that seems to solve the problem you described:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;time.h&gt;
#include &lt;sys/sem.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdio.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;sys/ipc.h&gt;
#include &lt;sys/shm.h&gt;




typedef struct {
    int num_lapin;
    int posx,posy;
    //struct cellule *next;

}Cellule;
struct sembuf buffer;

//Structure for initializing all the semaphores   
typedef union
{
  int valeur;
} semun_t;


typedef Cellule Lapin;


int *grille;//the grid (shared memory of the land)
int nbr=4; // nbr process
int x,y;// 
int semid;//id  semaphore 
Lapin *lapin;// Array of rabbits
int nbr_lapin = 0; // nbr rabbits initialized with 0
int pid; 





// Operation P
void p(int i){
    struct sembuf buffer;
    buffer.sem_num = i;
    buffer.sem_op = -1;
    buffer.sem_flg = 0;

    semop(semid, &amp;buffer,1);

    }

// Operation V
void v(int i){
struct sembuf buffer;
buffer.sem_num = i;
buffer.sem_op = 1;
buffer.sem_flg = 0;

    semop(semid, &amp;buffer,1);

}



//start init_grille()
int* init_grille(){

int i,j;

 int t[2] = {0,-1},taille=2; //  0 pour vide/ -1 pour lapin 

    //________________________________
    //INITIALIZING THE GRILLE With RABBITS 
    //________________________________

//START FOR
    for(i=0;i&lt;nbr;i++){
        for(j=0;j&lt;nbr;j++){
            int temp;
            temp = t[rand()%2];


                //%%%%%%%%%%%%%%%%%%%
                //if is RABBIT
                //%%%%%%%%%%%%%%%%%%%
              if(temp == -1){
                if(nbr_lapin&lt;=nbr*nbr*0.5){// 50% of rabbit in the grid


                 grille[i*nbr+j] = -1; //filling with rabbit


                    if(nbr_lapin==nbr*nbr*0.5) {//if it exceeds 50% 
                        t[1]=0;
                        taille--;}
                }

            }
            else   grille[i*nbr+j] = 0; //filling with empty
        }


}
//END FOR

return grille;

 }
 //END init_grille();


 //START Partag¨¦e la grille
 int partage_grille(key_t cle){

    int shmid;              //id of Shared memory

    // allocation Shared memory
      //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      shmid = shmget(cle,nbr*nbr*sizeof( int),IPC_CREAT | IPC_EXCL | 0666);
      if (shmid == -1)
        perror (""Probl¨¨me creat Shared memory\n"");
      else
        printf("" creat Shared memory\n"");



    return shmid;
 }

 //END PARTAGE



//START AFFICHER la grille
 void afficher_grille(int numero,int ii,int jj,int* add){
int i,j;
system(""\n\n"");

printf(""NUMERO %d \t PID %d  GRILLE %p \n"",numero,pid,add);
for(i=0;i&lt;nbr;i++){
    for(j=0;j&lt;nbr;j++){
        if(i==ii &amp;&amp; j==jj) printf("" #%d#\t"",grille[i*nbr+j]);
        else
         printf(""  %d \t"",grille[i*nbr+j]);
    }
    printf(""\n"");
}

    printf(""\n\n"");


   }
    //END AFFICHER




//START Creation du semaphore
int creat_sem(int size){
int i,erreur;
semun_t semun;

semid=semget(IPC_PRIVATE,1,IPC_CREAT|IPC_EXCL|0666);
if(semid==-1){
    printf(""Mutex No Create"");
    exit(-1);}

else printf("" Mutex  %d  is Creat \n"",semid);

semun.valeur = 1;


    if (semctl(semid,0,SETVAL,semun) == -1){
        perror(""Fatale Initialize Mutex\n"") ;
        exit(1) ;
    }
   printf("" Mutex Inisialized \n"");

return semid;

}
//END CREAT_SEM




//START initializing the array rabbits with position exists in the grid
Lapin* init_lapin(Lapin* lapin){
lapin = malloc(nbr*sizeof(Lapin));
int i,j; 

for(i=0;i&lt;nbr;i++){
    for(j=0;j&lt;nbr;j++){

        if(grille[i*nbr+j]==-1){
            lapin[nbr_lapin].posx=i;
            lapin[nbr_lapin].posy=j;
            lapin[nbr_lapin].num_lapin= nbr_lapin++;


            grille[i*nbr+j]=-1; // lapin

            }

    }
}

return lapin;
}
//END INIT_LAPIN





// START MOVE Rabbit
void deplacer_lapin(int num){


sleep(4);
printf(""\n################################\n\n"");
 srand(time(NULL));//initalize random

int t[3] = {-1,0,1};


 x = lapin[num].posx;// position X Current number ""num"" of rabbit 
 y = lapin[num].posy;//position Y

printf(""Lapin AVANT %d a X-&gt; %d\t Y-&gt; %d   - %p \n"",num,x,y,lapin);


x = x + t[rand()%3];//access a new position adjacent X rabbit number ""num""
y = y + t[rand()%3];//access a new position adjacent X 


// x and y should not go out of the grid area 
if(x==-1)x=0;
else if(x==nbr)x=nbr-1;

if(y==-1)y=0;
else if(y==nbr)y=nbr-1;

grille[lapin[num].posx*nbr + lapin[num].posy] = 0;//old value = empty

//Update rabbit""num""  position 
lapin[num].posx = x;
lapin[num].posy = y;


grille[x*nbr + y] = num; // new value = number rabbit

    printf(""Lapin APRES %d a X-&gt; %d\t Y-&gt; %d         - %p\n"",num,x,y,lapin);

    afficher_grille(num,x,y,grille);

}


// END DEPLACER


void traitement(int num){

while(1){

    p(0);
    deplacer_lapin(num);
    v(0);

   }
    }


int main(int argc, char *argv[])
{
    int i, id=1;
    key_t cle;
    pid = 0;
    cle=atoi(argv[0]) ;
   int  shmid =  partage_grille(cle);

//ATTACH The grid with a shared memory
     grille =shmat(shmid,0,0);
    if (grille== NULL)
        perror (""Probl¨¨me shmat\n"");
    else
        printf(""shmat r¨¦ussit\n"");


    grille = init_grille();

lapin = init_lapin(lapin);


 afficher_grille(0,0,0,grille);

//creat semaphore
    semid = creat_sem(1);





                for(i=0;i&lt;nbr;i++){

                    pid = fork();
                     if(pid!=0){

               traitement(i);

     }
     }

return 0;
}
</code></pre>

<p>You can also allocate a table of pointers <code>grille = malloc(nbr*sizeof(int*))</code>, and then allocate each <code>grille[i]</code> with <code>shmget()/shmat()</code>. You may also have to use <code>shmctl()</code> and <code>shmdt()</code> to deallocate shared memory or use a new key <code>cle</code> when you relaunch the program. Have a look at the following code, that use a grid like <code>grille[i][j]</code>, I have modified the functions <code>creation_grille()</code> and <code>partage_grille()</code>:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;time.h&gt;
#include &lt;sys/sem.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdio.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;sys/ipc.h&gt;
#include &lt;sys/shm.h&gt;




typedef struct {
    int num_lapin;
    int posx,posy;
    struct cellule *next;

}Cellule;
struct sembuf buffer;

//Structure for initializing all the semaphores   
typedef union
{
  int valeur;
} semun_t;


typedef Cellule Lapin;


int **grille;//the grid (shared memory of the land)
int nbr=4; // nbr process
int x,y;// 
int semid;//id  semaphore 
Lapin *lapin;// Array of rabbits
int nbr_lapin = 0; // nbr rabbits initialized with 0
int pid; 



// creat grid
int** creation_grille(int** grille){

int i;
grille = malloc(nbr*sizeof(int*));

return grille;
}

// Operation P
void p(int i){
    struct sembuf buffer;
    buffer.sem_num = i;
    buffer.sem_op = -1;
    buffer.sem_flg = 0;

    semop(semid, &amp;buffer,1);

    }

// Operation V
void v(int i){
struct sembuf buffer;
buffer.sem_num = i;
buffer.sem_op = 1;
buffer.sem_flg = 0;

    semop(semid, &amp;buffer,1);

}



//start init_grille()
int** init_grille(){

int i,j;

 int t[2] = {0,-1},taille=2; //  0 pour vide/ -1 pour lapin 

    //________________________________
    //INITIALIZING THE GRILLE With RABBITS 
    //________________________________

//START FOR
    for(i=0;i&lt;nbr;i++){
        for(j=0;j&lt;nbr;j++){
            int temp;
            temp = t[rand()%2];


                //%%%%%%%%%%%%%%%%%%%
                //if is RABBIT
                //%%%%%%%%%%%%%%%%%%%
              if(temp == -1){
                if(nbr_lapin&lt;=nbr*nbr*0.5){// 50% of rabbit in the grid


                 grille[i][j] = -1; //filling with rabbit


                    if(nbr_lapin==nbr*nbr*0.5) {//if it exceeds 50% 
                        t[1]=0;
                        taille--;}
                }

            }
            else   grille[i][j] = 0; //filling with empty
        }


}
//END FOR

return grille;

 }
 //END init_grille();


 //START Partag¨¦e la grille
 int partage_grille(key_t cle){
int i;
    int shmid;              //id of Shared memory

    // allocation Shared memory
    //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    for(i = 0; i &lt; nbr; i++) {
      shmid = shmget(cle+i,nbr*sizeof( int),IPC_CREAT | 0666);
      if (shmid == -1)
        perror (""Probl¨¨me creat Shared memory\n"");
      else
        printf("" creat Shared memory\n"");
      grille[i] = shmat(shmid,NULL,0);
      if(grille[i] == (int*)-1) perror(""\nshmat""); else printf(""\nshmat reussit\n"");
    }
}

 //END PARTAGE



//START AFFICHER la grille
 void afficher_grille(int numero,int ii,int jj,int** add){
int i,j;
system(""\n\n"");

printf(""NUMERO %d \t PID %d  GRILLE %p \n"",numero,pid,add);
for(i=0;i&lt;nbr;i++){
    for(j=0;j&lt;nbr;j++){
        if(i==ii &amp;&amp; j==jj) printf("" #%d#\t"",grille[i][j]);
        else
         printf(""  %d \t"",grille[i][j]);
    }
    printf(""\n"");
}

    printf(""\n\n"");


   }
    //END AFFICHER




//START Creation du semaphore
int creat_sem(int size){
int i,erreur;
semun_t semun;

semid=semget(IPC_PRIVATE,1,IPC_CREAT|IPC_EXCL|0666);
if(semid==-1){
    printf(""Mutex No Create"");
    exit(-1);}

else printf("" Mutex  %d  is Creat \n"",semid);

semun.valeur = 1;


    if (semctl(semid,0,SETVAL,semun) == -1){
        perror(""Fatale Initialize Mutex\n"") ;
        exit(1) ;
    }
   printf("" Mutex Inisialized \n"");

return semid;

}
//END CREAT_SEM




//START initializing the array rabbits with position exists in the grid
Lapin* init_lapin(Lapin* lapin){
lapin = malloc(nbr*sizeof(Lapin));
int i,j; 

for(i=0;i&lt;nbr;i++){
    for(j=0;j&lt;nbr;j++){

        if(grille[i][j]==-1){
            lapin[nbr_lapin].posx=i;
            lapin[nbr_lapin].posy=j;
            lapin[nbr_lapin].num_lapin= nbr_lapin++;


            grille[i][j]=-1; // lapin

            }

    }
}

return lapin;
}
//END INIT_LAPIN





// START MOVE Rabbit
void deplacer_lapin(int num){



sleep(4);
printf(""\n################################\n\n"");
 srand(time(NULL));//initalize random

int t[3] = {-1,0,1};


 x = lapin[num].posx;// position X Current number ""num"" of rabbit 
 y = lapin[num].posy;//position Y



printf(""Lapin AVANT %d a X-&gt; %d\t Y-&gt; %d   - %p \n"",num,x,y,lapin);


x = x + t[rand()%3];//access a new position adjacent X rabbit number ""num""
y = y + t[rand()%3];//access a new position adjacent X 


// x and y should not go out of the grid area 
if(x==-1)x=0;
else if(x==nbr)x=nbr-1;

if(y==-1)y=0;
else if(y==nbr)y=nbr-1;




    grille[lapin[num].posx][lapin[num].posy] = 0;//old value = empty




//Update rabbit""num""  position 
lapin[num].posx = x;
lapin[num].posy = y;


grille[x][y] = num; // new value = number rabbit




    printf(""Lapin APRES %d a X-&gt; %d\t Y-&gt; %d         - %p\n"",num,x,y,lapin);



    afficher_grille(num,x,y,grille);



}


// END DEPLACER


void traitement(int num){

while(1){

    p(0);
    deplacer_lapin(num);
    v(0);

   }
    }


int main(int argc, char *argv[])
{
    int i, id=1;
    key_t cle;
    pid = 0;
    cle=atoi(argv[0]) ;

   grille = creation_grille(grille);
   int  shmid =  partage_grille(cle);


    grille = init_grille();

lapin = init_lapin(lapin);


 afficher_grille(0,0,0,grille);

//creat semaphore
    semid = creat_sem(1);





                for(i=0;i&lt;nbr;i++){

                    pid = fork();
                     if(pid!=0){

               traitement(i);

     }
     }

            //}

return 0;
}
</code></pre>
",0
34086578,34086510,2,"<p>You probably called <code>listen</code> lexically before the definition, so the call let it default to <code>int listen()</code>. Add this line at the top of the file (after all includes):</p>

<pre><code>char *listen(void);
</code></pre>

<p>Or better, create an include (<code>.h</code>) file for this.</p>
",2
34255656,34255617,1,"<p>You want:</p>

<pre><code>sscanf(line, ""%d\t%d"", &amp;first, &amp;second);
</code></pre>

<p>Note the <code>&amp;</code>s. They make a pointer holding the addresses for <code>first</code> and <code>second</code>. That is required since they need to be modified by <code>sscanf()</code> and they can be through these pointers.</p>

<p>The way it was, your program invoked <em>Undefined Behavior</em> since, you passed uninitialized integers that were considered addresses by <code>sscanf()</code>, trying to dereference them in order to store the result in <code>first</code> and <code>second</code> was causing the mentioned <em>undefined behavior</em> leading to the segmentation fault.</p>

<p>There is another risk in your code. If you ignore the value returned by <code>sscanf()</code> and yet you try to read from <code>first</code> or <code>second</code>, there is another chance for undefined behavior. Read <a href=""http://man7.org/linux/man-pages/man3/scanf.3.html"" rel=""nofollow""><code>scanf(3)</code></a> for more information.  Better would be:</p>

<pre><code>int n;
...
n = sscanf(line, ""%d\t%d"", &amp;first, &amp;second);
if (n != 2) { /* do something appropriate here */ }
</code></pre>

<p>Finally, you would know all this if you turn on compilation warnings, it's hard to tell you how to do it since, every compiler and/or IDE are different but just google it for your particular situation and you will find warnings very helpful.  For example, using gcc on a unix system:</p>

<pre><code>% pr -t -n xx.c
    1   #include &lt;stdio.h&gt;
    2   
    3   int main ( void ) {
    4           char line[100];
    5           int     first, second;
    6   
    7           (void)fgets(line, sizeof(line), stdin);
    8           (void)sscanf(line, ""%d\t%d"", first, second);
    9           return 0;
   10   }
   11   
% cc -c xx.c
% cc -c -Wall xx.c
xx.c: In function `main':
xx.c:8: warning: format argument is not a pointer (arg 3)
xx.c:8: warning: format argument is not a pointer (arg 4)
</code></pre>

<p>Note how the first compile (<code>cc -c xx.c</code>) was less helpful than the second (<code>cc -c -Wall xx.c</code>) where we asked for ""all"" warnings.</p>
",6
32928791,32928741,3,"<p>The statement</p>

<pre><code>char greeting[] = ""Hello!"";
</code></pre>

<p>causes the compiler to work out the size of the string literal <code>""Hello!""</code> (7 characters including the terminating <code>'\0'</code>), create an array of that size, and then copy that string into that array.   The result of that <code>greeting</code> can be modified (e.g. its characters overwritten).</p>

<p>The statement </p>

<pre><code>char * farewell=""Goodbye!"";
</code></pre>

<p>creates a pointer that points at the first character in the string literal <code>""Goodbye!""</code>.   That string literal cannot be modified without invoking undefined behaviour.</p>

<p>Either <code>greeting</code> or <code>farewell</code> can be passed to any function that does not attempt to modify them.   <code>greeting</code> can also be passed to any function which modifies it (as long as only characters <code>greeting[0]</code> through to <code>greeting[6]</code> are modified, and no others).   If <code>farewell</code> is modified, the result is undefined behaviour.</p>

<p>Generally speaking, it is better to change the definition  of <code>farewell</code> to</p>

<pre><code>const char * farewell=""Goodbye!"";
</code></pre>

<p>which actually reflects its true nature (and will, for example, cause a compilation error if <code>farewell</code> is passed to a function expecting a non-<code>const</code> parameter).    The fact that it is possible to define <code>farewell</code> as a non-<code>const</code> pointer while it points at (the first character of) a string literal is a historical anomaly.</p>

<p>And, of course, if you want <code>farewell</code> to be safely modifiable, declare it as an array, not as a pointer.</p>
",2
32928928,32928741,1,"<p>The string literals <code>""Hello""</code> and <code>""Goodbye""</code> are stored as arrays of <code>char</code> such that they are allocated at program startup and released at program exit, and are visible over the entire program.  They may be stored in such a way that they cannot be modified (such as in a read-only data segment).  Attempting to modify the contents of a string literal results in <em>undefined behavior</em>, meaning the compiler isn't required to handle the situation in any particular way - it may work the way you want, it may result in a segmentation violation, or it may do so ething else.</p>

<p>The line</p>

<pre><code>char greeting[] = ""Hello""; 
</code></pre>

<p>allocates enough space to hold a copy of the literal and writes the contents of the literal to it.  You may modify the contents of this array at will (although you can't store strings longer than <code>""Hello""</code> to it).</p>

<p>The line</p>

<pre><code>char *farewell = ""Goodbye"";
</code></pre>

<p>creates a pointer and writes the address of the string literal <code>""Goodbye""</code> to it.  Since this is a pointer to a string literal, we cannot write to the contents of the literal through that pointer.</p>
",0
34205007,34204791,1,"<p>I've done something similar while studying C with Kochan manual and in chapter 7 I had to solve a problem like yours, so I came up with this solution:</p>

<pre><code>// Program to convert a positive integer to another base

#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

int       convertedNumber[64];
long int  numberToConvert;
int       base;
int       digit;

void  getNumberAndBase (void)
{
    bool askAgain = true;

    printf (""Number to be converted? "");
    scanf (""%li"", &amp;numberToConvert);

    if (numberToConvert == 0)
    {
        askAgain = false;
    }

    while (askAgain)
    {
        printf (""Base? "");
        scanf (""%i"", &amp;base);        
        if  ( base &lt; 2  ||  base &gt; 16 ) {
            printf (""Bad base - must be between 2 and 16\n"");
        } else {
            askAgain = false;
        }
    };

}

void  convertNumber (void)
{
    digit = 0;
    do {

         convertedNumber[digit] = numberToConvert % base;
         ++digit;
         numberToConvert /= base;
    }
    while  ( numberToConvert != 0 );
}

void  displayConvertedNumber (void)
{
    const char  baseDigits[16] =
           { '0', '1', '2', '3', '4', '5', '6', '7',
             '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
    int   nextDigit;

    printf (""Converted number = "");

    for (--digit;  digit &gt;= 0; --digit ) {
        nextDigit = convertedNumber[digit];
        printf (""%c"", baseDigits[nextDigit]);
    }

    printf (""\n"");
}

int main (void)
{
    void  getNumberAndBase (void), convertNumber (void),
          displayConvertedNumber (void);

    while (true)
    {
        getNumberAndBase ();

        if (numberToConvert == 0)
        {
            break;
        }
        convertNumber ();
        displayConvertedNumber ();
    }
    return 0;
}
</code></pre>

<p>Actually you don't need a recursive function, a while loop like the one in convertNumber function will do, you have to divide until there's nothing left.</p>

<p>The example I post is simple with no function arguments but global variables because that was the level on that chapter of the book but I think that will give you a good direction that you can elaborate further</p>
",2
34244324,34244285,0,"<p>Just replace the line</p>

<pre><code>char path=""./client.c"";
</code></pre>

<p>with</p>

<pre><code>char path[]=""./client.c"";
</code></pre>
",3
34244357,34244285,2,"<p>You are not declaring the array size in </p>

<pre><code>char path=""./client.c"";
</code></pre>

<p>Change it to:</p>

<pre><code>char path[]=""./client.c"";
</code></pre>

<p>Now your code should run as desired.</p>

<p>And if you are interested in using pointers use</p>

<pre><code>const char* path=""./client.c"";  
</code></pre>

<p>to point directly to the string</p>
",2
34244359,34244285,1,"<p>Replace </p>

<pre><code>char path=""./client.c"";
</code></pre>

<p>with </p>

<pre><code>const char* path=""./client.c""; 
//^no array, just point to the string literal
</code></pre>

<p>if you don't need to modify the path.</p>

<p>If you do, then:</p>

<pre><code>char path[]=""./client.c"";
//^create a modifiable array from the string literal
</code></pre>

<hr>

<pre><code>char path=""./client.c"";
</code></pre>

<p>compiles because a string literal autoconverts to the adress of the string literal 
(they're placed in a static, usually read-only, segment of your executable) which is an integer that can be, with a loss, assigned to a char.</p>

<p>However, you should absolutely get a warning about this from the compiler. </p>

<p>Aim for compilation without any warnings.</p>
",3
34258651,34258621,1,"<p><code>*(x + 4)</code> dereferences the fifth element of the array, which has value <code>4</code>.</p>

<p><code>(x + 4)</code> is the address of the fifth element of the array (which is the corresponding address of the value <code>4</code>).</p>

<p>You can check what <code>(x + 4)</code> is, and why:</p>

<pre><code>printf( ""sizeof( int ) = %ld \n"", sizeof( int ) );
printf( ""x = %p \n"", x );
printf( ""(x + 4) = %p \n"", (x + 4));
</code></pre>

<p>Sample output:</p>

<pre><code>sizeof( int ) = 4 
x = 0x7fff3c0e5fc0         # address of the first element
(x + 4) = 0x7fff3c0e5fd0   # address of the fifth element
</code></pre>
",2
31250998,31250666,1,"<p>In <code>int main()</code> you opened file with ""w+"" mode so everything is discarded in file when it is called.</p>

<p>Also in function <code>void display(FILE *ptrFILE)</code> you have not closed the text file.And you have used <code>feof()</code> inside while loop which may create problem .</p>

<p>Please see following link why you should not use <code>while(!feof())</code>-<a href=""https://stackoverflow.com/questions/5431941/why-is-while-feof-file-always-wrong/5432517#5432517"">Why is ¡°while ( !feof (file) )¡± always wrong?</a></p>
",0
31250914,31250666,1,"<p>The <a href=""https://msdn.microsoft.com/en-us/library/yeby3zcb.aspx"" rel=""nofollow"">MSVC documentation</a> of <code>fopen</code> says about <code>mode</code>: <em>""w"" Opens an empty file for both reading and writing. If the file exists, its contents are destroyed.</em></p>

<p>Since the first file open in <code>main</code> is</p>

<pre><code>if ((ptrFILE = fopen(""Phone Book.txt"", ""w+"")) == NULL)
</code></pre>

<p>you destroy anything you already have.</p>

<p>To read the content, use mode <code>""r""</code> to open the file, read the content, then close it.</p>

<p>To add new content, either re-open with mode <code>""w""</code> and write the whole content, or open in append mode <code>""a""</code> and just write the new records(s).</p>

<p>Or you can open in mode <code>""r+""</code> for reading and writing, but before writing you need to <code>fseek</code> the end of the file.</p>
",0
31251199,31250666,0,"<pre><code>void display(FILE *ptrFILE)
{
    fclose(ptrFILE);//!! flush out
    if ((ptrFILE = fopen(""Phone Book.txt"", ""r"")) == NULL)
    {
        printf(""The file couldn't open\n"");
    }
    else
    {
        char buff[128];//!!for fgets
        system(""cls"");   // Screen is being cleaned
        struct personKnowledge *s;   // s means searching
        s = (struct personKnowledge *)malloc(sizeof(struct personKnowledge));
        //fseek(ptrFILE, 0L, SEEK_SET);//!!no need
        fflush(stdin);
        printf(""\n\nExpress name which you search: "");
        gets(s-&gt;sName);
        while (fgets(buff, sizeof buff, ptrFILE))//!!
        {
            sscanf(buff, ""%15s%15s%15s\n"", s-&gt;name, s-&gt;surname, s-&gt;number);//!!
</code></pre>
",7
33016172,33015802,0,"<p>You defined <code>daybuffer[9]</code>, but the worst case is wednesday that is 9 chars long + <code>null</code> terminator.</p>

<p>This means that text_layer_set_text will invoke <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow"">UB</a> when will print your string.</p>

<p>Enlarge your buffer to <code>10</code> chars.</p>

<p>Take a look at <a href=""http://man7.org/linux/man-pages/man3/strftime.3.html"" rel=""nofollow"">strftime</a> ManPage</p>

<p>Where you can find</p>

<blockquote>
  <p><strong>RETURN VALUE</strong></p>
  
  <p>Provided that the result string, including the terminating null byte,
         does not exceed max bytes, strftime() returns the number of bytes
         (excluding the terminating null byte) placed in the array s.  <strong>If the
         length of the result string (including the terminating null byte)
         would exceed max bytes, then strftime() returns 0, and the contents
         of the array are undefined.</strong>
         Note that the return value 0 does not necessarily indicate an error.
         For example, in many locales %p yields an empty string.  An empty
         format string will likewise yield an empty string.</p>
</blockquote>
",0
31218219,31218164,1,"<pre><code>scanf(""%c"",&amp;a[i]);
i++;
if(a[i]==' ')
    k++;
</code></pre>

<p>When you compare <code>a[i]</code> against <code>' '</code>, it's not assigned yet. This leads you to undefined behavior.</p>
",2
31219946,31218164,0,"<p>Whenever you get errors while running loops, try to run them manually on paper for two or three iterations which will make us understand how our code flow is happening in a loop.</p>

<p>In your code, when you run the loop for first time, you are taking the character into <code>a[0]</code>, incrementing value of i and which now makes the value of <code>i</code> as <code>1</code>, now you are comparing the value of <code>a[1]</code> to <code>' '</code> which is a garbage. correct it to the following code,        </p>

<pre><code>scanf(""%c"",&amp;a[i]);    
//i++;    
if(a[i++]==' ')    
   k++;    
</code></pre>

<p>you are declaring <code>int main(void)</code> and not returning any value. include a <code>return 0;</code> statement at the end along with the above code.</p>
",0
31125895,31125819,5,"<p>Q1: Pass your actual input file path as command line parameter</p>

<p>Q2: Who can know that? But that code seems to assume so.</p>

<p>Q3: Define your main function as </p>

<pre><code>   int main(int argc, char* argv[]) {
// ^^^
     // ...
   }
</code></pre>

<p>to get rid of that error.</p>

<hr>

<p><sub>Usually you can ask exactly one question per question, and there are pretty good reasons for this. Feel lucky that your questions were answered here. Don't wonder if your question might be downvoted and removed.</sub></p>
",0
31125985,31125819,0,"<p>Q2: According to the <code>fscanf</code> format string, your data will be read from the file in batches of 6 values (5 integers and 1 floating-point) separated by whitespace. There's absolutely no requirement for these values to be organized in columns or ""nicely"" formatted in any other way. The file will be seen by <code>fscanf</code> as a linear stream (a tape) of values separated by whitespace. Whitespace includes spaces, tabs, newline characters. I.e. <code>fscanf</code> does not care how your stream of values is split into the physical file lines. You can format the input file as a huge single line of values, or you can chop it up into lines in any way you please.</p>

<p>BTW, the <code>\n</code> at the end of that format string is redundant and achieves nothing at all. <code>""%d%d%d%d%d%lf""</code> would work the same.</p>

<p>Also</p>

<pre><code>fscanf(in_file, ""%d%d%d%d%d%lf\n"", &amp;year, &amp;month, &amp;date, &amp;hour, &amp;minute, &amp;par ) &gt; 0
</code></pre>

<p>is a rather dangerous success condition. If at least one, but less than six values are read from the file, it will treat it as a successful read. However, the unread variables will simply retain their original values, producing a generally meaningless combination. This</p>

<pre><code>fscanf(in_file, ""%d%d%d%d%d%lf\n"", &amp;year, &amp;month, &amp;date, &amp;hour, &amp;minute, &amp;par ) == 6
</code></pre>

<p>would make more sense as a success condition.</p>

<p>Q3: As the compiler has already told you, <code>main</code> must be declared as returning <code>int</code>. <code>void main</code> is illegal.</p>

<p>P.S. Another minor nitpick: <code>%lf</code> format in <code>printf</code> became legal in C99. So, from the pedantic point of view this code requires a C99 (or later) compiler, even though it appears to be written for ""old"" C compilers in all other respects.</p>
",0
31163760,31163386,0,"<p>You're missing a space within your first <code>scanf</code>:</p>

<pre><code>...
puts(intro);
scanf("" %c"", &amp;choice);  /* missing the space in your code*/
...
</code></pre>
",2
31164187,31163386,1,"<p>The program I compiled does not ""stop working"" (I filled in the missing strings). It simply exits when I enter <code>'n'</code> at the first response, because, to summarise, it is like this.</p>

<pre><code>int main() {
    char choice;
    puts(intro);
    scanf(""%c"", &amp;choice);
    if (choice == 's' || choice == 'S') {
        //  ...
    }
    return 0;
}
</code></pre>

<p>So <code>'n'</code> simply exits the program, otherwise when I start with <code>'s'</code> and then continue with <code>'n'</code> or <code>'s'</code> I get the printed dialogs. Although as I commented above, what is supposed to happen when neither <code>'n'</code> or <code>'s'</code> are entered?</p>

<p>BTW you have no prompts to help the user know what they are supposed to enter, or why.</p>
",0
31163832,31163386,0,"<p>The behavior of <code>scanf</code> is interesting especially when you include whitespace in the format string.  When I wrote more console-oriented applications and wasn't using something like curses, I used a function like the following to read input:</p>

<pre><code>char
get_next_input(void)
{
        int ch;
        while ((ch=getchar()) != EOF) {
                if (!isspace(ch)) {
                        return (char)ch;
                }
        }
        return (char)'\0';
}
</code></pre>

<p>It returns the next non-whitespace character in the stream or <code>'\0'</code> on EOF.  I found it more reliable than using <code>scanf</code> across various implementations.</p>

<p>The problem that you are probably experiencing is line buffering on <code>stdin</code>.  The call to <code>scanf</code> might not return until you press enter (e.g., enter a newline character).</p>
",1
31174131,31173851,0,"<pre><code>char kDelimiter = ',';
char* start = my_string;
char* end = my_string;
char *substrings[SUBSTRINGS_MAX_NUM];
uint32_t substring_idx = 0;
uint32_t finished = 0; /* false */
do {
    end = strchr(start, kDelimiter);
    if (!end) {
        end = my_string + strlen(my_string);
        finished = 1; /* true */
    }
    ssize_t substring_len = end - start;
    substrings[substring_idx] = NULL;
    substrings[substring_idx] = malloc(substring_len + 1);
    if (!substrings[substring_idx]) {
        fprintf(stderr, ""Error: Could not allocate space for substring!\n"");
        exit(EXIT_FAILURE);
    }
    memcpy(substrings[substring_idx], start, end - start);
    substrings[substring_idx] + (end - start) = '\0';
    start = end + 1;
    substring_idx++;
} while (!finished);
</code></pre>
",0
31173865,31173851,2,"<p>Firstly, character constant syntax in C language uses single quotation marks: <code>','</code>, not <code>"",""</code>.</p>

<p>Secondly, don't compare character values to <code>NULL</code>. <code>NULL</code> is reserved to pointer contexts. Terminating zero character can be described as <code>'\0'</code> or simply as <code>0</code>.</p>

<p>Thirdly, there are dedicated library functions specifically designed to simplify this task, like <code>strtok</code>. I don't know though whether you can use them.</p>

<p>As for variable declarations, yes, you can put them all in <code>for</code> as long as they all have the same type</p>

<pre><code>for (int e = 0, r = 0, c = 0; ...
</code></pre>

<p>Note though that variables declared in this way will not be available after <code>for</code>. And you will definitely need your <code>c</code> after this <code>for</code>.</p>
",1
31290926,31290357,1,"<p>On Linux, Ctrl-D does not mean End-Of-File (EOF). It means 'end-of-transmission', which means that the currently typed input is immediately sent to your program. It is similar to newline with the exception that Ctrl-D itself is not sent. Your <code>getchar</code> returns EOF when it receives  an empty ""transmission"". This is why you have to type Ctrl-D three times (or a newline followed by two Ctrl-D) to get two EOFs.</p>
",2
32422730,32422634,0,"<p>This:</p>

<pre><code>int mark[3];
mark[3] = scanf(""%d"",mark[3]);
</code></pre>

<p>is wrong because of several reasons. It seems that you don't know how to use <code>scanf</code> properly. It should be</p>

<pre><code>int mark[3];
scanf(""%d"", &amp;mark[0]);
scanf(""%d"", &amp;mark[1]);
scanf(""%d"", &amp;mark[2]); /* Get each number from stdin and store it in the address of the variable given */
</code></pre>

<p>or better</p>

<pre><code>int mark[3];
scanf(""%d %d %d"", &amp;mark[0], &amp;mark[1], &amp;mark[2]);
</code></pre>

<p>or even better</p>

<pre><code>int mark[3], i;
for(i = 0; i &lt; 3; i++) /* Loop 3 times */
{
    scanf(""%d"", &amp;mark[i]);
}
</code></pre>
",2
32422777,32422634,0,"<p>You can get the numbers from the input using <code>scanf()</code> and then find the highest number using <code>fmax()</code>:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main()
{
    int mark[3] = {0, 0, 0};
    int highest = 0;

    printf(""Enter the Marks\n"");
    for (int i = 0; i &lt; 3; i++) {
        printf(""%d: "", i + 1);
        scanf(""%d"", &amp;mark[i]);
        highest = fmax(highest, mark[i]);
    }

    printf(""The Highest Mark is %d: \n"", highest);
}
</code></pre>
",0
33590309,33590228,2,"<pre><code>while ( fgets ( line, sizeof line, file ) != NULL )
{ int idx, port; char ip[MAX_IP + 1];
  sscanf(line, "" %d %s %d"", &amp;idx, ip, &amp;port);
  strncpy(servers[idx-1], ip, MAX_IP + 1);
}
</code></pre>

<p>But of course, if you are not sure about the correctness of your input file, you should add error checking.</p>

<p>EDIT: Since you are asking for ""efficient way"", you can do the reading in one step, instead of reading a line and then parsing it. You can do this as well:</p>

<pre><code>int idx, port; char ip[MAX_IP + 1];
while (3 == fscanf(file, "" %d %s %d"", &amp;idx, ip, &amp;port))
   memcpy(servers[idx-1], ip, MAX_IP + 1);
</code></pre>

<p>Notice that memcpy is faster than strcpy, unless the source string is much smaller than the buffer's size, which is rarely the case with ip addesses...</p>
",2
33605027,33604740,1,"<p>From what I see, it seems that you need a function that swaps position of every 2 bits in a number. few examples:</p>

<ol>
<li>10'00'11'01'01 -> 01'00'11'10'10</li>
<li>11'01'10'10'11 -> 11'10'01'01'11</li>
</ol>

<p>for this operation, a very simple function is following:</p>

<pre><code>unsigned int change_bit(unsigned int num)
{
    return ((num &amp; 0xAAAAAAAA) &gt;&gt; 1) | ((num &amp; 0x55555555) &lt;&lt; 1);
}
</code></pre>
",0
33556767,33550179,0,"<p>Try the following:<br>
It's written to run on a Linux terminal so it uses fgets() for user input.<br>
The idea is to just have a loop in main() that continues to run until the user wants to stop or runs out of money. In this loop call your dice rolling function.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;


int diceRoll(int moneyinput);

int diceRoll(int moneyinput)
{
    int dice1 = (rand() % 6 + 1);
    int dice2 = (rand() % 6 + 1);// from 1 to 6
    int dice3 = (rand() % 6 + 1);

    moneyinput -= 10;
    if (dice1 == 6 &amp;&amp; dice2 == 6 &amp;&amp; dice3 == 6)
    {
        printf(""you have won 100\n "");
        moneyinput += 90;
    }
    else if (dice1 == dice2 &amp;&amp; dice2 == dice3)
    {
        printf(""you have won 50kr \n"");
        moneyinput += 40;
    }
    else if (dice1 == dice2 || dice1 == dice3 || dice2 == dice3)
    {
        printf(""you have won 10kr \n"");
        moneyinput += 10;
    }
    else
    {
        printf(""Sorry! you have lost. good luck next time \n"");
    }
    return( moneyinput);
}


int main()
{
    int money = 100;
    char choice[2];

    srand((int)time(NULL));

    printf(""welcome to the game! \n \n"");

    printf(""1.it cost you 10kr to play \n"");
    printf(""2.if all the dicies are sixes you win 100kr \n"");
    printf(""3. if all the dicies are alike except number (6) you win 50kr \n"");
    printf(""4. if you get at least two alike you 1 \n"");
    printf(""5. otherwise you win nothing\n"");

    do
    {
        printf(""you have %d kr, if you want to play press (y): "", money);
        fgets( choice, sizeof(choice)+1, stdin );   // read a char then LF

        if( 'y' == choice[0] )
        {
            money = diceRoll( money );
        }
    }while( (money &gt;= 10) &amp;&amp; choice[0] == 'y' );

    printf(""Quitting game with %dkr!\n"", money);

}
</code></pre>
",0
33556192,33550179,1,"<p>You need to move your question to user into the rolling function. Your main function does not operate independent for your rolling function.</p>

<p>Also you have some logic errors in your if statements that will make your result be different then what you desire.</p>

<pre><code>if (dice1 == 6 &amp;&amp; dice2 == 6 &amp; dice3 == 6)
</code></pre>

<p>should be</p>

<pre><code>if (dice1 == 6 &amp;&amp; dice2 == 6 &amp;&amp; dice3 == 6)
</code></pre>

<p>And</p>

<pre><code>else if (dice1 == dice2 == dice3)
</code></pre>

<p>should be</p>

<pre><code>else if (dice1 == dice2 &amp;&amp; dice2 == dice3)
</code></pre>

<p>Beyond that you also need to make a return from the rolling function.</p>
",0
31543979,31542494,2,"<p>The idea is this:</p>

<p>Pseudocode:</p>

<pre><code>while ((c = getchar()) != EOF)
{
   // c contains the character we've just read

   if (c is blank and the previous read char is blank)
   {
     // do nothing
     continue;
   }

   putchar(c);   // print that char

   copy c to previous char
}
</code></pre>
",3
31544027,31542494,0,"<p>Well. Correct me if I'm wrong but</p>

<p>""ex) Write a program to copy its input to its output, replacing each string of one or more blanks by a single blank.""</p>

<p>As I understand it, you gotta :
-Take the input</p>

<p>-Clear the input if more than one blank is there (could be a space, a '\t' or anything, man ascii)</p>

<p>-print the cleared string</p>

<p>-return</p>

<p>I will not explain how to take the input, just use main's argument.</p>

<p>Then you have to check for blanks.</p>

<p>Just increment a counter to the first blank occurrence and check if the next one is a blank or not. 
If it is, just keep incrementing, if it's not, copy the char to a new char*.</p>

<p>return that char * (don't make this whole thing in one function please).</p>

<p>print it.</p>

<p>return 0.</p>
",2
31544106,31542494,0,"<pre><code>#include&lt;stdio.h&gt;

int main(int argc, char* argv[])
{
    char c = 0;
    char  prevchar = 0;

    while((c = getchar()) != '\n')
    {
        if(c != ' ' || prevchar != ' ')
            putchar(c);
        prevchar = c;
    }
}
</code></pre>

<p>What this does:  Declares a second var to act as a sort single character buffer to check if the previous character was a space.  The if then ensures that putchar only fires if one them is not a space.  You can change the '\n' to EOF I use '\n' here so it only reads until the next return.</p>
",6
33526640,33526489,1,"<p>This is how i have moved a file in the past without having to open it:</p>

<pre><code>#include &lt;stdio.h&gt;
int main()
{
  rename(""C:\\oldFile.txt"", ""C:\\newfile.txt"");
  return 0;
}
</code></pre>
",2
33526698,33526489,1,"<p><strong>One thing to be aware</strong> is that you're copying the slowest possible way, because you're doing it character by character. One improvement would be to copy full lines or bigger text chunks, using <code>fgets</code> and <code>fputs</code></p>

<p><strong>Even better is to not copy the file as a text file</strong>, but instead just as a binary chunk. This is achieved by opening the file in binary mode with the <code>b</code> flag, so e.g. <code>target = fopen(target_file, ""wb"");</code> and using <code>fread</code> and <code>fwrite</code> instead of the put character functions. </p>

<p>In both scenarios you have to use a temporary buffer with a reasonable size (could be the size of the file or fixed). To determine the optimal size is not trivial.</p>

<p><strong>Yet another way to copy</strong>, and according to my operating systems professor <strong>what <code>cp</code> does</strong>, is by using <a href=""https://en.wikipedia.org/wiki/Memory-mapped_file"" rel=""nofollow"">memory mapped files</a>.
How to use memory mapped files is unfortunately not portable, but depending on your operating system i.e. platform. For unix the manpage of <code>mmap</code> is your friend. This is an example unix implementation by me:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdint.h&gt;
#include &lt;errno.h&gt;
#include &lt;time.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/shm.h&gt;
#include &lt;signal.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;assert.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;


int main(int argc, const char * argv[]) {

    if (argc != 3)
    {
        fprintf(stderr, ""Usage %s &lt;SourceFile&gt; &lt;DestinationFile&gt;\n"",argv[0]);
        return EXIT_FAILURE;
    }

    int source_file_desc = open(argv[1], O_RDONLY);
    if (source_file_desc == -1) {
        perror(""Can't open source file"");
        return EXIT_FAILURE;
    }
    struct stat source_info;
    if (stat(argv[1], &amp;source_info) != 0) {
        perror(""Can't get source file infos"");
        return EXIT_FAILURE;
    }
    void *source_mem = mmap(NULL, source_info.st_size, PROT_READ, MAP_FILE|MAP_PRIVATE, source_file_desc, 0);
    if (source_mem == MAP_FAILED) {
        perror(""Mapping source file failed"");
        return EXIT_FAILURE;
    }

    int destination_file_desc = open(argv[2], O_TRUNC|O_CREAT|O_RDWR);
    if (destination_file_desc == -1) {
        perror(""Can't open destination file"");
    }
    if (chmod(argv[2], source_info.st_mode) != 0) {
        perror(""Can't copy file permissions"");
    }
    if (lseek(destination_file_desc, source_info.st_size-1, SEEK_SET) == -1) {
        perror(""Can'T seek to new end of destination file"");
    }
    unsigned char dummy = 0;
    if (write(destination_file_desc,  &amp;dummy, 1) == -1)
    {
        perror(""Couldn't write dummy byte"");
    }


    void *destination_mem = mmap(NULL, source_info.st_size, PROT_WRITE,MAP_FILE|MAP_SHARED, destination_file_desc,0);
    if (destination_mem == MAP_FAILED) {
        perror(""Mapping destination file failed"");
    }

    memcpy(destination_mem, source_mem, source_info.st_size);

    munmap(source_mem,source_info.st_size);
    munmap(destination_mem, source_info.st_size);
    close(source_file_desc);
    close(destination_file_desc);

    return EXIT_SUCCESS;
}
</code></pre>
",6
33527198,33526489,3,"<p>Well, what do you imagine the <code>cp</code> command itself do for copying files? If opens source file in read mode, destination file is write mode and copy everything by binary chunks! Ok more things can be involved if you pass other options to <code>cp</code>, but the copy itself is not more magic than that.</p>

<p>That being said, what you do is not that. You are copying the file character by character. Even if the standard library does some buffering, you are repeatedly calling an function when it could be avoided. And... <strong>never use gets</strong>. It is deprecated for ages because it is unsecure. If the user enters looong file names (more than 19 characters) you get a buffer overflow. And do not forget to test <strong>all</strong> io functions including output ones. When writing a huge file on a external media such an USB key, you could get out of space on device, and you program would just say it could successfully do the copy.</p>

<p>Copying loop could be something like:</p>

<pre><code>#define SIZE 16384
char buffer[SIZE];
int crin, crout = 0;

while ((crin = fread(buffer, 1, SIZE, source)) &gt; 0) {
    crout = fwrite(buffer, 1, crin, target);
    if (crout != crin) { /* control everything could be written */
        perror(""Write error"");
        crout = -1;
        break;
    }
if (crin &lt; 0) { /* test read error (removal of amovible media, ...) */
    perror(""Read error"");
}
</code></pre>

<p>A low level optimization here would be to directly use posix functions instead of standard library ones, because as soon as you are using binary IO in big chunks, the buffering of the standard library gives no advantage, and you simply have its overhead.</p>
",0
33530561,33526489,0,"<p>If it¡¯s not a problem that any changes to one copy would affect the other, you can create a link to the file.  How this works depends on the OS.</p>

<p>If you want to optimize a file copy as much as possible using only the standard library, here is what I suggest (untested):</p>

<pre><code>#include &lt;errno.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

extern bool copy_file( FILE* dest, FILE* restrict src );
static bool error_helper( const char* file, int line, const char* msg );

#if defined(__amd64) || defined(__amd64__) || defined(__x86_64) || defined(__x86_64__) || defined(_M_X64) || defined(_M_AMD64) || defined(__i386) || defined(_M_IX86) || defined(_X86_) || defined(__X86__) || defined(__I86__) || defined(__INTEL__) || defined(__386)
#  define PAGE_SIZE 4096U
#else
#  error ""Define the page size on your system, or use a system call such as sysconf() to find it.""
#endif

#define non_fatal_stdlib_error() error_helper( __FILE__, __LINE__, strerror(errno) )

bool copy_file( FILE* dest, FILE* restrict src )
{
  errno = 0;
  if ( !(dest = freopen( NULL, ""w+"", dest )) )
    return non_fatal_stdlib_error();

  /* Try to help the library out by turning buffering off and allocating an aligned block; it might be able to detect that at runtime.
   * On the other hand, the unbuffered implementation might be worse. */
  setvbuf( src,  NULL, _IONBF, BUFSIZ );
  setvbuf( dest, NULL, _IONBF, BUFSIZ );

  char* const buffer = aligned_alloc( PAGE_SIZE, PAGE_SIZE );
  if (!buffer)
    return non_fatal_stdlib_error();

  size_t n = fread( buffer, 1, PAGE_SIZE, src );
  while ( PAGE_SIZE == n ) {
    const size_t written = fwrite( buffer, 1, PAGE_SIZE, dest );
    if ( written != PAGE_SIZE )
      return non_fatal_stdlib_error();

    n = fread( buffer, 1, PAGE_SIZE, src );
  } // end while

  if (ferror(src))
    return non_fatal_stdlib_error();

  if ( n &gt; 0 ) {
    const size_t written = fwrite( buffer, 1, n, dest );
    if ( written != n )
      return non_fatal_stdlib_error();
  }

  return true;
}

bool error_helper( const char* file, int line, const char* msg )
{
  fflush(stdout);
  fprintf( stderr, ""Error at %s, line %d: %s.\n"", file, line, msg );
  fflush(stderr);
  return false;
}
</code></pre>

<p>This at least gives the library implementation a chance to detect that all reads and writes are single memory pages.</p>
",0
31888304,31887458,0,"<p>The code is looking for 5 cards. Found variable works as a counter.. When you find a card you add one to the previous muber of found cards. This way, when founs reaches 5, you'll know you've find 5 cards</p>
",0
31887537,31887458,2,"<p>The function has to select five cards. Variable <code>found</code> is used like a counter of selected cards. If a card was selected the counter that is variable <code>found</code> is increased</p>

<pre><code>found = found + 1;
</code></pre>

<p>The selection continues until <code>found</code> is equal to 5 as it is required.</p>

<p>Initially <code>found</code> is set to 0</p>

<pre><code>int found = 0;
</code></pre>

<p>because no card is selected yet.</p>
",0
31887556,31887458,0,"<pre><code>found = found + 1;
</code></pre>

<p>counts the cycles of the cards drawn.</p>

<p>If you increase it by 4, the while would only cycle twice:</p>

<p>the first for found == zero</p>

<p>the second for found == 4</p>

<p>Also, if I may: quite a few details in the code may be improved.</p>

<p>Example1: get rid of the <code>switch</code>. Include the description of the card as an attribute of the structure for the card, alongside <code>.value</code> and <code>.type</code>. That way you just need to print it out.</p>

<p>Example2: make the <code>.used</code> flag an <code>int</code> (holding nonzero if used, zero if not).</p>
",0
31887557,31887458,0,"<ul>
<li><p><code>found</code> is a counter to count select times and make your card select logic continue</p>

<pre><code>int found = 0;
while(found &lt; 5){ //found = 0,1,2,3,4, totally 5 cards will be selected
...
//pick up one card
...
found = found + 1; //to count pick up times and make while loop continue
}
</code></pre></li>
<li><p>to change <code>found</code> will change selected card num(<code>5 - initial_value_of_ found</code>)  </p>

<pre><code>int found = 4; // will select ""5-4"" cards
while(found &lt; 5){ //found = 4, totally 1 cards will be selected
...
//pick up one card
...
found = found + 1; //to make while loop continue
}
</code></pre></li>
</ul>
",0
31887648,31887458,0,"<p>Take out stuff from the code unrelated to your question and you get</p>

<pre><code>void shuffle( aDeck * thisDeck )
{
     int found = 0;

     while ( found &lt; 5 )
     {
          //  pick a card, print out what has been picked, and register it as used

      found = found + 1;
      } // end while loop

} //end shuffle
</code></pre>

<p>So the body of the while loop will be executed <code>5</code> times.   In this case, that means picking five cards.   The value of <code>found</code> controls that:  for the first card, <code>found</code> will be <code>0</code>, the second <code>1</code>, ..... and the fifth <code>4</code>.</p>

<p>Changing the expression to something else will potentially change the number of cards picked.   It is probably easier to change the <code>while</code> condition though.</p>

<p>So changing to <code>found = found + 4</code> will change the number of iterations.   First iteration it will be <code>0</code>, second <code>4</code>, third <code>8</code>.   Eight is not less than five, so the result of the change is only picking two cards.</p>
",0
33572092,33571878,1,"<p>The character 0 to 9 are actually ascii values 48 to 57. switch( (int)(c-48) )  would work.  The express (int)(c-48) changes the ascii digits to integers.  </p>
",0
33572375,33571878,3,"<p>As <code>c</code> is declared as having character type then entered 1 and 2 are characters correspondingly '1' and '2'. </p>

<p>So write</p>

<pre><code>switch (c)
{
case '1':
    printf(""%d + %d is %d\n"", x, y, x+y);
    break;

case '2':
    printf(""%d - %d is %d\n"", x, y, x-y);
    break;

default: printf(""Wrong value\n"");
    break;
}
</code></pre>
",0
33572414,33571878,0,"<p>An alternative to the previous answer using character literals:</p>

<pre><code>switch(c)
{
  case '1':
    ...
    break;
  ...
 }
</code></pre>

<p>This allows you to even handle 'q' and the like.</p>

<p>When doing 'q', keep in mind the case sensitivity:</p>

<pre><code>switch(c)
{
  case 'q':
  case 'Q':
    ... handle q
    break;
}
</code></pre>

<p>In short: You are reading a char, treat it as a char.</p>
",0
33568680,33568655,0,"<p>The thing is <code>strcmp()</code> returns <code>0</code> when the strings are equal.</p>

<blockquote>
<pre><code>int strcmp(const char *s1, const char *s2);
</code></pre>
  
  <p><strong>RETURN VALUE</strong></p>
  
  <p>The <code>strcmp()</code> and <code>strncmp()</code> functions return an integer less than,
       equal to, or greater than zero if <code>s1</code> (or the first <code>n</code> bytes thereof)
       is found, respectively, to be less than, to match, or be greater than
       <code>s2</code>.</p>
</blockquote>
",5
33568696,33568655,1,"<p>You're missing a closing brace <code>}</code> just before the <code>while</code>.</p>

<p>Once you've fixed this syntax error, be sure to understand that <code>strcmp</code> returns zero <em>if</em> the strings are equal.</p>
",1
33568722,33568655,1,"<p>Because you are not closing the do !! </p>

<pre><code>do{.......} 
while(...);
</code></pre>
",1
33568736,33568655,2,"<ol>
<li>You are missing a <code>}</code> before the <code>while</code>. </li>
<li>You need to move username and password out of your loop.</li>
<li>You shouldn't use <code>scanf</code> <a href=""http://c-faq.com/stdio/scanfprobs.html"" rel=""nofollow noreferrer"">http://c-faq.com/stdio/scanfprobs.html</a></li>
<li>You are not allocating enough space for your <code>username</code> and <code>password</code></li>
</ol>

<p>Maybe you should read a tutorial about proper reading first?
The answer to this question looks pretty nice:
<a href=""https://stackoverflow.com/questions/4023895/how-to-read-string-entered-by-user-in-c"">how to read string entered by user in c</a></p>
",2
33568999,33568655,1,"<p>thanks for your question,</p>

<ul>
<li>After you corrected the syntactical errors (braces)</li>
<li>After you have made the indentation look better</li>
<li>After you have understood the idea of strcmp</li>
<li>After you have understood that doing it this way is VERY dangerous</li>
</ul>

<p>then and only then:</p>

<p>should you end the do .. while .. loop with a conditional statement where it is checked IF the user is NOT the admin, then you repeat!</p>

<pre><code>    while (strcmp(username,""admin"") != 0 &amp;&amp; strcmp(password,""vdedote"") != 0);
</code></pre>

<p>so the loop knows it needs to repeat because it is not the admin with the right password login in!</p>
",0
33554389,33554217,1,"<p>This is because your function has a possible code path that lets the if's fall through without the function returning anything. Technically it shouldn't be possible, but the compiler has noticed the possibility, and won't let you continue. Your function should look more like this:</p>

<pre><code>Degree climate_control(Degree degree) {
    if (degree == LOW_TEMPERATURE_BOUNDARY) {
        return 0;
    } else if (degree &lt; LOW_TEMPERATURE_BOUNDARY) { 
    return LOW_TEMPERATURE_BOUNDARY; }
    else if (degree == HIGH_TEMPERATURE_BOUNDARY) {
        return 0;
    } else if (degree &gt; HIGH_TEMPERATURE_BOUNDARY) { 
    return HIGH_TEMPERATURE_BOUNDARY; }

    return 0;
}
</code></pre>

<p>Why does the compiler think this? What would happen to the above code if some brain-dead (or drunk) programmer did this:</p>

<pre><code>const  Degree LOW_TEMPERATURE_BOUNDARY  = 18.5; 
const  Degree HIGH_TEMPERATURE_BOUNDARY = -22.2;  //Notice the sign change?
</code></pre>

<p>Now your <code>climate_control</code> function will fall through.</p>
",0
33583697,33583538,1,"<p>By ""not working"", I suppose you mean that it never enters a second iteration, but that is exactly what it is supposed to do.  <code>catcode==!'Q'&amp;&amp;catcode==!'q'</code> is true if <code>catcode</code> is equal to <code>!'Q'</code> and equal to <code>!'q'</code>.  <code>'Q'</code> is some non-zero integer (depends on your system, but is probably 81), and <code>!'Q'</code> is zero.  Similarly, <code>!'q'</code> is zero.  <code>catcode</code> isn't zero, so the loop terminates.</p>
",0
33583713,33583538,1,"<p>There are two problems in your code:</p>

<p>First of all, the specifiers in <code>scanf</code>...</p>

<pre><code>scanf(""%s"", &amp;catcode);
</code></pre>

<p>This won't work. The <code>""%s""</code> specifier expects its corresponding argument to be a <code>char*</code> to a buffer of unspecified length (i.e: this has <a href=""https://stackoverflow.com/a/22419911/5249858"">the same problem as <code>gets()</code></a>). You probably meant <code>""%c""</code>, whose corresponding argument shall point to <em>a single character</em>. Now, your format specifier is not recommended to be <code>""%c""</code>, but <code>"" %c"", because that extra space indicates</code>scanf()<code>to ignore all whitespace it can before</code>""%c""`. So, that line becomes...</p>

<pre><code>scanf("" %c"", &amp;catcode);
</code></pre>

<p>Now, you're right, there's a problem in your <code>while</code> loop:</p>

<pre><code>while(catcode==!'Q'&amp;&amp;catcode==!'q');
</code></pre>

<p>Let's ""expand"" this with whitespace, to make what you (apparently) intended more obvious (that's reason #1 to use spaces between operators!)...</p>

<pre><code>while(catcode ==! 'Q' &amp;&amp; catcode ==! 'q');
</code></pre>

<p>For you it appears okay. Not for me. The C language does not define any operator <code>==!</code>, rather, it defines operator <code>==</code> (that compares for equality), and operator <code>!</code> (that negates its single operand). The compiler would have understood that line as...</p>

<pre><code>while(catcode == !'Q' &amp;&amp; catcode == !'q');
</code></pre>

<p>Now, what does that mean? If the operand is non-zero, the <code>!</code> operator returns zero (in this case, the null character, <code>'\0'</code>). Otherwise, it returns a non-negative value (usually <code>1</code> (does the standard mandates this?)). Because <code>'Q'</code> is not <code>'\0'</code>, and same for <code>'q'</code>, that means that your loop is effectively...</p>

<pre><code>while(catcode == '\0' &amp;&amp; catcode == '\0'); // Think of '\0' as 0
</code></pre>

<p>Absolute non-sense expressed in code! The solution is to simply use operator <code>!=</code> (compares for inequality)...</p>

<pre><code>while(catcode != 'Q' &amp;&amp; catcode != 'q');
</code></pre>

<p>I hope this has led some light on you!</p>
",0
33594980,33594935,1,"<ul>
<li>read input as string</li>
<li>parse the input read</li>
<li>decide if what has been read could be an integer, (else if float,) else if a double or else something completely different.</li>
</ul>

<hr>

<p>Update:</p>

<p>The question indeed is not fully defined. That is, it does not specify the possible allowed number of integer bases.</p>
",0
33595190,33594935,1,"<p>How I would do it, schematically:</p>

<ol>
<li>Read the entire line of input as a string.</li>
<li>Trim all leading and trailing whitespace from the string.</li>
<li>Use a (standard library) function to parse the string as an integer, that also returns the number of characters successfully parsed.</li>
<li>Use a (standard library) function to parse the string as an float, that also returns the number of characters successfully parsed.</li>
<li>Compare the two parses. If the integer parse managed the entire string, then it's an integer. Else, if the float managed the entire string, then it's a float. Else, if neither managed, then it's bogus input.</li>
</ol>

<p>It's important in step 5 to first check for integer and then for float, as an integer input can typically be parsed as a float as well, so integer should take precedence.</p>
",6
33601527,33594935,1,"<blockquote>
  <p>... if the given number by the user is integer or double?<br>
  ... we should get from the user a number. (scanf) ... </p>
</blockquote>

<p>Let us consider various inputs:</p>

<ol>
<li>""123"", is certainly an <em>integer</em>, yet that would also parse successful a <code>double</code>.  Much text that parses as an <em>integer</em> would also parse as a <code>double</code>.</li>
<li>""123.5"" would parse as a double, but not an <em>integer</em>.  </li>
<li>""xyz"" would fail both.  </li>
<li>""1e10000"" would overflow most <code>double</code>, but it is also an <em>integer</em>.  </li>
</ol>

<p>Other considerations: </p>

<ol start=""5"">
<li><em>integer</em> is a math concept and not a C type.  </li>
<li>Inputs like ""123.1"" would not likely parse <em>exactly</em> into a <code>double</code>.  </li>
<li>Inputs with hundreds of character pose problems.  </li>
<li>Inputs like ""123x"" parse initially as an <em>integer</em> but fail with the trailing <code>'x'</code>.</li>
</ol>

<p>Proceed with these reasonable assumptions.</p>

<p>A. Input is not too many characters.  <em>integer</em> fits in a <code>long long</code>.<br>
B. Overflow/underflow/rounding is not an issue.<br>
C. If parses as both, call it an <em>integer</em>.<br>
D. Requirements imply using <code>scanf()</code> - yuk - much rather use <code>fgets()</code></p>

<pre><code>const char *TestInput(void) {
  char buf[100];
  if (sscanf("" %99[^\n]"", buf) != 1) 
    return ""No interesting input"";
  char end;
  long long ll;
  if (sscanf(buf, ""%lli %c"", &amp;ll, &amp;end) == 1)
    return ""Integer"";
  double d;
  if (sscanf(buf, ""%lf %c"", &amp;d, &amp;end) == 1)
    return ""double"";
  return ""neither"";
}
</code></pre>
",0
32481095,32476921,0,"<p>Codeblocks, like most IDEs, does not contain a compiler and won't generate warnings like this by itself. Instead it calls a command-line compiler like gcc, and displays to you the errors and warnings the compiler returns.</p>

<p>You should check what compiler is called, with what compiler options, in Codeblocks/project settings.</p>

<p>gcc should generate an <em>""array subscript is above array bounds""</em> warning for your code, but only with the <code>-Wall</code> and <code>-O2</code> options (or equivalent).</p>

<p>Optimization (<code>-O2</code>) is often not enabled for debugging, which could be an explanation why you don't get the warning <em>while debugging</em>.</p>
",0
32481241,32476921,0,"<blockquote>
  <p>When you access an array index, C and C++ don't do bound checking. The values you get when you read are just what happens to exist on the <em>stack</em> at this particular place. They are completely undefined.</p>
</blockquote>

<p>The difference between the two compilers is possibly due to the fact that one of those is a newer version including some array bound checking.</p>
",0
34182314,34181374,0,"<p>When you merge <code>a_b</code> with <code>c_d</code> you have the sizes back to front with</p>

<pre><code>while(i&lt;size3+size4 &amp;&amp; j&lt;size1+size2)
</code></pre>

<p>This should be </p>

<pre><code>while(i&lt;size1+size2 &amp;&amp; j&lt;size3+size4)
</code></pre>

<p>The same applies below when you merge the remaining parts of the arrays, and these have an additional problem: instead of repeating the <code>while</code> loops you used to build <code>a_b</code> and <code>c_d</code> you've used a different technique. I suggest revisiting this section building <code>e</code>, and making it work like you did when buildling <code>a_b</code> and <code>c_d</code>.</p>

<p>Here is the corrected code - except I didn't look at the part after the creation of <code>e[]</code> as I am not sure what you are trying to do.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
    int size1 = 4, a[] = {1,1,1,2};
    int size2 = 4, b[] = {2,2,2,3};
    int size3 = 4, c[] = {3,3,3,4};
    int size4 = 5, d[] = {4,4,4,5,6};
    int a_b[30], c_d[30], e[30];
    int i,j,k,t, sizefull;

    sizefull=size1+size2+size3+size4;
    printf(""%d\n"", sizefull);

    i=j=k=0;
    while (i &lt; size1 &amp;&amp; j &lt; size2) 
    {
        if (a[i] &lt;= b[j]) 
            {
            a_b[k] = a[i];
            i++;
            k++;
            }
       else {
            a_b[k] = b[j];
            k++;
            j++;
            }
    }
    while (i &lt; size1) 
    {
        a_b[k] = a[i];
        i++;
        k++;
    }
    while (j &lt; size2) 
    {
        a_b[k] = b[j];
        k++;
        j++;
    }
    printf(""\nMerged array is :"");
    for (i = 0; i &lt; size1 + size2; i++)
        printf(""%d "", a_b[i]);

    i=j=k=0;
    while (i &lt; size3 &amp;&amp; j &lt; size4) {
        if (c[i] &lt;= d[j]) {
            c_d[k] = c[i];
            i++;
            k++;
        } else {
            c_d[k] = d[j];
            k++;
            j++;
        }
    }
    while (i &lt; size3) {
        c_d[k] = c[i];
        i++;
        k++;
    }
    while (j &lt; size4) {
        c_d[k] = d[j];
        k++;
        j++;
    }
    printf(""\nMerged array is :"");
    for (i = 0; i &lt; size3 + size4; i++)
        printf(""%d "", c_d[i]);

    i=j=k=0;
    while (i &lt; size1+size2 &amp;&amp; j &lt; size3+size4) 
    {
        if (a_b[i] &lt;= c_d[j]) 
            {
            e[k] = a_b[i];
            i++;
            k++;
            }
       else {
            e[k] = c_d[j];
            k++;
            j++;
            }
    }
    while (i &lt; size1+size2) 
    {
        e[k] = a_b[i];
        i++;
        k++;
    }
    while (j &lt; size3+size4) 
    {
        e[k] = c_d[j];
        k++;
        j++;
    }

    printf(""\n After merging: \n"");
    for (i = 0; i &lt; sizefull; i++)
    {
        printf(""%d "", e[i]);
    }

    for (i=0;i&lt;sizefull;i++)
    {
        for(j=i+1;j&lt;sizefull;j++)
        {
            if(e[i]&gt;e[j])
            {
                t=e[i];
                e[i]=e[j];
                e[j]=t;
            }
        }
    }
    printf(""\nAscending Order is:"");
    for(j=0;j&lt;sizefull;j++)
    {
        printf(""%d "",e[j]);
    }

    printf(""\n\n Final Array is \n"");
    for(i=0;i&lt;sizefull;i++)
    {
        printf("" %d"",e[i]);
    }

    for(i=0; i&lt;sizefull;)
    {
        for(j = (i + 1); j&lt;sizefull; j++)
        {
            if( e[i] != e[j])
                break;
        }
        printf(""\nunique element = %d, at index = %d\n"", e[i], i);
        printf(""\nunique element = %d, at index = %d\n"", e[i], i);
        i = j;
        return 0;
    }
}
</code></pre>

<p>Program output:</p>

<pre><code>17

Merged array is :1 1 1 2 2 2 2 3
Merged array is :3 3 3 4 4 4 4 5 6
 After merging:
1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 6
Ascending Order is:1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 6

 Final Array is
 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 6
unique element = 1, at index = 0

unique element = 1, at index = 0
</code></pre>
",5
34182602,34181374,0,"<p>Well First, You should try to put some comments on your code so that it becomes easy for others to read your code at one go. And I can see a lot of errors in your code. You have taken incorrect sizes of arrays ans also a for loop of yours is incorrect. The loop after you printed your final array  <code>for(i=0; i&lt;sizefull;)</code> is not correct.
I will try to provide a simple solution to your problem.
First, merge the four arrays, Second, perform a sorting algorithm(bubble, say), then try to find unique numbers from them. </p>

<pre><code>int main()
{
    int size1, size2, size3, size4,sizefull,a[30],b[30],c[30],d[30],e[120];      
    int i,j,t,match,temp;
    printf(""Insert the size of A: "");
        scanf(""%d"",&amp;size1);
    printf(""Insert %d elements of A:\n"", size1);
    for(i=0;i&lt;size1;i++)
        scanf(""%d"",&amp;a[i]);
    printf(""Insert the size of B: "");
        scanf(""%d"",&amp;size2);
    printf(""Insert %d elements of B:\n"", size2);
    for(i=0;i&lt;size2;i++)
        scanf(""%d"",&amp;b[i]);
    printf(""Insert the size of C: "");
        scanf(""%d"",&amp;size3);
    printf(""Insert %d elements of C:\n"", size3);
    for(i=0;i&lt;size3;i++)
        scanf(""%d"",&amp;c[i]);
    printf(""Insert the size of D: "");
        scanf(""%d"",&amp;size4);
    printf(""Insert %d elements of D:\n"", size4);
    for(i=0;i&lt;size4;i++)
        scanf(""%d"",&amp;d[i]);
    sizefull=size1+size2+size3+size4;
    //The below code is for copying.
    i=0;
    j=0;
    while(i&lt;size1)  
    {
             e[j]=a[i];
             i++;
             j++;
    }
    i=0;
    while(i&lt;size2)  
    {
             e[j]=b[i];
             i++;
             j++;
    }
    i=0;
    while(i&lt;size3)  
    {
             e[j]=c[i];
             i++;
             j++;
    }
    i=0;
    while(i&lt;size4)  
    {
             e[j]=d[i];
             i++;
             j++;
    }
     //bubble sort
    for(i=0;i&lt;sizfull-i;i++)
    {
         for(j=0;j&lt;sizefull-i;j++)
         {
              if(e[j]&gt;e[j+1])
              {
                  temp=e[j];
                  e[j]=e[j+1];
                  e[j+1]=temp;
              }
         }
    }
    //Code below is for finding and printing unique numbers.
    for(i=0;i&lt;sizefull-1;i++)
    {
        match=0; 
        for(j=i+1;j&lt;sizefull;j++)
         {
             if(e[i]==e[j])
             {
                 match++;
                 break;
             }
         }
         if(match==0)
         printf(""unique number=%d at index %d"",e[i],i);
    }


}
</code></pre>
",1
34184297,34181374,0,"<p>Changed example code to get user input. The merge part is the same as Antoine Mathys answer, so this code example mostly shows a simple way to print unique numbers from a sorted array. Added qsort() calls to sort the 4 arrays, since it's not clear if the arrays were supposed to be already sorted.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

/* print unique numbers from sorted array */
void print_uniques(int x[], int sizex)
{
int i, j;
    if(sizex == 0)
        return;
    i = j = 0;
    while(i != sizex){
        i++;
        if(i != sizex &amp;&amp; x[i] == x[j])
            continue;
        if((i - j) == 1)
            printf(""%d\n"", x[j]);
        j = i;
    }
}

/* merge two already sorted arrays */
void merge(int m[], int x[], int sizex, int y[], int sizey)
{
int i=0, j=0, k=0;
    while (i &lt; sizex &amp;&amp; j &lt; sizey) 
    {
        if (x[i] &lt;= y[j]) 
            m[k++] = x[i++];
        else 
            m[k++] = y[j++];
    }
    while (i &lt; sizex) 
        m[k++] = x[i++];
    while (j &lt; sizey) 
        m[k++] = y[j++];
}

/* compare function for qsort() */
int cmp(const int *i, const int *j)
{
    return *i - *j;
}

/* get data (no size check) */
int getdata(int x[], char l)
{
int s, i;
    printf(""Enter the number of elements for %c : "", l);
    if(0 == scanf(""%d"", &amp;s))
        return 0;
    for(i = 0; i &lt; s; i++){
        printf(""Enter an element for %c : "", l);
        scanf(""%d"", x+i);
    }
    return s;
}

int main()
{
int a[64], b[64], c[64], d[64];
int a_b[128], c_d[128];
int e[256];
int sizea, sizeb, sizec, sized;
int sizea_b, sizec_d, sizee;

    sizea = getdata(a, 'A');
    sizeb = getdata(b, 'B');
    sizec = getdata(c, 'C');
    sized = getdata(d, 'D');

    sizea_b = sizea   + sizeb;
    sizec_d = sizec   + sized;
    sizee   = sizea_b + sizec_d;

    /* sort the arrays */
    qsort(a, sizea, sizeof(a[0]), cmp);
    qsort(b, sizeb, sizeof(b[0]), cmp);
    qsort(c, sizec, sizeof(c[0]), cmp);
    qsort(d, sized, sizeof(d[0]), cmp);

    /* merge the arrays */
    merge(a_b, a, sizea, b, sizeb);
    merge(c_d, c, sizec, d, sized);
    merge(e, a_b, sizea_b, c_d, sizec_d);

    printf(""\n"");
    print_uniques(e, sizee);

    return 0;
}
</code></pre>

<p>Alternate get data that lets user input multiple elements on a single line without having to specify the number of elements.</p>

<pre><code>/* get data (no size check) */
int getdata(int x[], char l)
{
char d[] = "" ,\t\n"";
char t[80];
int i = 0;
char *pt;
    printf(""enter element(s) for %c :\n"", l);
    if(NULL == fgets(t, sizeof(t), stdin))
        return 0;
    pt = strtok(t, d);
    while(pt){
        sscanf(pt, ""%d"", x+i);
        i++;
        pt = strtok(NULL, d);
    }
    return i;
}
</code></pre>
",13
34181415,34181391,4,"<p>It works, but you are trying to put multiple character into a single one which doesn't make sense.</p>

<p>Try:</p>

<pre><code>char symbol = '@';
const char symbols[] = ""@@@@@@"";
const char* symbols2 = ""@@@@@@@"";
</code></pre>

<p>Note that you need to use single quotes <code>'</code> for single characters and double quotes <code>""</code> for strings.</p>

<p>Also note that char is usually defined as 8-bit integer so you can only hold the usual ASCII characters. If you need Unicode you should use char arrays to accommodate all the bits needed and preferably use a library that  takes care of handling, conversions, and any other operation you might want to do.</p>
",2
34181454,34181391,1,"<p>You should use a <em>pointer to char</em> if you want to assign multiple values. </p>

<pre><code>const char *smth = ""@@@@"";
</code></pre>

<p>If you need only one, then simply <code>char smth = '@';</code></p>
",0
32414545,32414326,2,"<p>Your program invokes undefined behavior here:</p>

<pre><code>if (temp1[j]&lt;temp2[k]) { ... }
</code></pre>

<p>In your specific example, it happens when <code>i == r</code>, since you'll be comparing <code>temp1[2]</code> with <code>temp2[2]</code>, but <code>temp2</code> has 2 elements only, so that's an out of bounds access.</p>

<p>Attempting to reason about programs with UB is frowned upon; fix the mistake and that should stop you from having other surprises.</p>

<p>One possible fix is to change the last loop to:</p>

<pre><code>for (i=p; i&lt;=r; i++) {
    if (k &lt; n2 &amp;&amp; j &lt; n1) {
        if (temp1[j] &lt; temp2[k]) {
            a[i] = temp1[j];
            j++;
        } else {
            a[i] = temp2[k];
            k++;
        }
    } else if (k &lt; n2) {
        a[i] = temp2[k];
        k++;
    } else {
        a[i] = temp1[j];
        j++;
    }
}
</code></pre>
",3
34252717,34252675,3,"<p>You are using the wrong preprocessor operator, for token-pasting you want to use <code>##</code>, not <code>#</code></p>

<pre><code>#define THREAD(x)    void THREAD_##x (void)
</code></pre>
",0
34196379,34196348,1,"<p><code>const int x</code> only means that <code>x</code> itself cannot be changed inside the function. It has nothing to do with the return value.</p>
",0
34196411,34196348,4,"<p>This line</p>

<pre><code>   return (x+10);
</code></pre>

<p>Doesn't add 10 to <code>x</code> and return it. It forms the value that is <code>x+10</code> and returns that but leaves <code>x</code> itself unchanged.</p>

<p>If you wrote</p>

<pre><code> int c;
 c=x+10;
</code></pre>

<p>Would you expect x to be increased by 10 after that second line executes?</p>

<p>Try</p>

<pre><code>int aFunction(const int x){
    int c=(x+10);
    printf(""aFunction: x=%d c=%d\n"",x,c);
    return c;
}
</code></pre>
",0
34196460,34196348,3,"<p>Basically, applying the const qualifier to a variable prevents the value of the variable from being modified.
In your function, aFunction(), the variable x is given a const qualifier which prevents the value of x from being modified in your function. There is no reason why your code shouldn't be able to compile since all the function is doing is returning a value which is 10 more than x. It is not in any way modifying the value of x.</p>

<p>If you did something like x += 10 which is short for x = x + 10, then you will get some compiler errors.</p>
",0
34196617,34196348,1,"<p><strong><em>Simple:</em></strong> 
x is not changed until or unless you re-initialize it, look into these lines :</p>

<p><strong>const int x</strong> : means X will never be changed.</p>

<p><strong>x+10</strong> : means just add 10 in X but never save the status.</p>

<p><strong>x = x +10 ""</strong> means overwrite the value of x which will Crash: and you will get desired Error</p>
",0
32934728,32934691,2,"<pre><code>num1 = i;
</code></pre>

<p><code>i</code> is just declared not initialized and you compare it in loop-</p>

<pre><code>while (i &lt; num1) {
</code></pre>

<p>Initialize <code>i</code> and then use it .</p>

<p>What you wrote in question and what you did is little confusion , but to make it work -</p>

<pre><code>  i=0;
  //num1=i;               I didn't get these parts so commented it 
  while (i &lt; num1) {             //you loop will run now
       // printf(""Enter days"");       // these also didn't get it either
        //scanf(""%d"", &amp;num1);

        printf(""Hello World"");
        printf(""Bye World"");
        i++;
 }
</code></pre>
",4
32934850,32934691,0,"<pre><code>num1 = i;
while (i &lt; num1) {
</code></pre>

<p>How it is possible, while condition will be false always. It should be like</p>

<pre><code>i = 0;
while (i &lt; num1) {
</code></pre>

<p>Rest all looks good.</p>
",0
32935108,32934691,1,"<p>You can use a <code>while</code> loop if you want, but using a <code>for</code> loop might make more sense and reduce the amount of code you need to write. I think that in this case the following would be reasonable:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void){
    int num1, i;

    printf(""Enter your number:"");
    scanf(""%d"", &amp;num1);

    for(i = 0 ; i &lt; num1 ; ++i) {
            printf(""Hello World"");
    }

    printf(""Bye World"");
}
</code></pre>

<p>Best of luck.</p>
",0
34160641,34160311,0,"<p>Not sure if I got the question right, but I would suggest you to try something like this:</p>

<pre><code>int i, j,array[4][10], number=0;

    for (j =0; j &lt; 10; j++) {
        for (i=0; i &lt; 4; i++) {
            array[i%4][j] = ++number;
        }
    }

    for(i=0;i&lt;4;i++) {  
        for(j=0;j&lt;10;j++) {
            printf(""%d\t"", array[i][j]);    
        }
    }
</code></pre>

<p>I hope this helps.</p>
",4
34160703,34160311,2,"<p>There are a whole bunch of problems, which people are noting. I've noticed that in the comments (by the time I'd finished writing this) you've said ""it works"" once you added the right assign. God knows how, but presumably the code in your question is not representative of your actual code...</p>

<p>For posterity, problems listed below.</p>

<h2>1. Declaration</h2>

<p>You need to declare array[][] at the start of the function/Main/Program</p>

<pre><code>int array[10][4];
</code></pre>

<p>you also need to define i and j and set them as 0. Presumably you're doing all this outside the posted code.</p>

<p>Note that I've swapped around the ""i"" and ""j"" values you've been using. This is because [4][10] will give you 4 arrays of 10 elements, not 10 arrays of 4 elements, which is what you apparently want.</p>

<h2>2. Order of cycling through the array</h2>

<p>you want the numbers to go down before they go across. In order to get that pattern you need to be cycling through the ""i"" value faster than the ""j"":</p>

<pre><code>for(j=0;i&lt;10;i++)
{
    for(i=0;i&lt;4;j++)
   {
   ...
   }
}
</code></pre>

<h2>3.The Assign</h2>

<p>I have no idea what this if statement is meant to be doing:</p>

<pre><code>if(i=0)
{
 ... 
}
</code></pre>

<p>Not only will this <strong>ALWAYS</strong> return <strong>false</strong>, it will set i back to 0 every time so you'll just keep overwriting the first element and your for loop will never end. I would consider taking this out as it is doing nothing.</p>

<p>As @JohnBode pointed out, i=0 returns 0 (an assignment operation always returns the value being assigned), so this if statement is equivalent to if(0), which will always be false. </p>

<p>The assign is then relatively simple:</p>

<pre><code>array[i][j] = (i + 1) + (4*j)
</code></pre>

<p>Note the +1's as the array index will be one less than the required value. I think the calculation is correct, it might be slightly wrong by to be honest that's the least of your worries with this code!</p>

<p>The print function is fine. As far as I can tell that's everything!</p>
",3
34181560,34171089,2,"<p>Your problem is the <code>if</code> condition you put at the starting of the <code>while</code> loop, to check if any coordinates have the same value.</p>

<p>It is not always necessary that if any 2 points sharing the common x-coordinate, must also be sharing a same y-coordinate to form a right-angled triangle, which you seem to assume in your code. Example take these coordinates::</p>

<blockquote>
  <p>(0, 0), (0, 5), (2.5, 2.5)</p>
</blockquote>

<p>(I know the problem statement says only integer values, but this was the easiest case that came to mind, and I believe you can form a test case like this with only integer values.)</p>

<p>If we follow, your code then <code>x1 = x2</code> but, no y-values are the same and your code does not count this as a right angle triangle, though it is a right angled triangle.</p>

<p>So, the easiest solution would be to remove the first <code>if</code> condition, and let the rest of the code run, and you will get an AC.</p>

<p><strong>EDIT::</strong> </p>

<p>Example with integer coordinates ::</p>

<blockquote>
  <p>(0, 0), (0, 6), (3, 3)</p>
</blockquote>
",0
34182428,34171089,0,"<p><strong>Edit : m1,m2,m3 being the product of slopes.</strong> </p>

<p>What's wrong is your approach I believe, change your code as follows with comments added :  </p>

<pre><code>//if(x1==x2||x2==x3||x3==x1){ not required,no such property for a right angle triangle
                    //if(y1==y2||y2==y3||y3==y1)
                            //count++;
            //}
            //else{
                    //printf(""hello"");
                    m1=((y1-y2)*(y3-y2))/((x1-x2)*(x3-x2));
                    m2=((y1-y2)*(y1-y3))/((x1-x2)*(x1-x3));
                    m3=((y3-y2)*(y1-y3))/((x3-x2)*(x1-x3));
                    //      printf(""%lf %lf %lf\n"",m1,m2,m3);
                    if( m1 == -1 ||m2==-1 || m3*m1==-1 ) //product of slope of two perpendicular lines is -1
                            count++;
</code></pre>

<blockquote>
  <p>Note : by this method you are applying an INT to INT division which
  might actually trim the exact slope into incorrect values. Insist you
  to use the double value and then cast it after evaluating the product
  of slopes.</p>
</blockquote>
",1
34206197,34206137,6,"<p><code>&amp;p</code> takes the address of <code>p</code>, not the value of <code>p</code>. That for you <code>&amp;p + 1 == a</code> is pure coincidence and depends on your stack alignment. Your compiler could have sorted the both variables in another order or put a gap in between.</p>
",1
34206257,34206137,3,"<p>That's a funny one. Write down <em>precisely</em> what &amp;p+1 means. It has nothing to do with any addresses in the array a. What it prints is pure coincidence. </p>

<p>Add another array b. Then set p = b and print &amp;p + 1 and &amp;b [0]. Maybe you figure out what happens. </p>
",2
34206272,34206137,3,"<p>An array is not a pointer is not an array.</p>

<p><code>&amp;p</code> is the address of <code>p</code>, not the address it contains (i.e. its value), which would be <code>p</code> (FYI: the value of the object it points to is <code>*p</code>). Similarly, <code>&amp;a[0]</code> is the address of the first element in the array. It is pure coincidence the array is at the next address location (<code>&amp;p +1</code>).</p>

<p>Additionally, the correct <code>printf</code> conversion-specifier for pointers is <code>%p</code> and it expects a <code>void *</code> (you are required to cast here, because that is a variadic function). Using a different specifier invokes undefined behaviour.</p>

<p>You should enable compiler warnings. Modern compilers will warn about such fundamental mismatches of types between the <code>printf</code> (and <code>scanf</code>) format strings and the arguments.</p>
",4
34206283,34206137,-3,"<p>Check that you're running what you think you are. I just tried it, and it worked.</p>

<pre><code>bash $ cc -o foo foo.c
foo.c:6:23: warning: format specifies type 'unsigned int' but the argument has type
      'int **' [-Wformat]
    printf(""%x\n%x\n"",&amp;p+1, &amp;a[0]);
            ~~        ^~~~
foo.c:6:29: warning: format specifies type 'unsigned int' but the argument has type
      'int *' [-Wformat]
    printf(""%x\n%x\n"",&amp;p+1, &amp;a[0]);
                ~~          ^~~~~
2 warnings generated.
bash $ ./foo
58af0888
58af0890
bash $ 
</code></pre>

<p>Observe the warnings, btw. </p>
",5
34213622,34213397,2,"<p>This should come near to how your program is supposed to look like:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(int argc, char *argv[] ){
    if( argc &gt; 1 ) {
        printf( ""You passed (at least) one parameter, let's see if we can handle that\n"");

        if( strcmp( argv[1], ""1"") == 0 ) {
            printf( ""Oh yes, it's a boy ! Ahem a one !\n"");
        } else {
            printf( ""%s\n"", argv[1]);
        }
    } else {
        printf( ""There is nothing we can work with\n"");
    }
}
</code></pre>

<p><a href=""http://coliru.stacked-crooked.com/a/4bd0a904d9a9e6d2"" rel=""nofollow"">http://coliru.stacked-crooked.com/a/4bd0a904d9a9e6d2</a></p>

<p>As your homework perhaps is to only support a single character the final touch might be missing. I will leave this up to you. </p>

<p>Besides missing curly braces (<code>{</code> and <code>}</code>) your code has several problems, I mention some:</p>

<pre><code>if (ad=1)
</code></pre>

<p>You never assigned <code>ad</code> anywhere. And instead of a comparison (<code>==</code>) you made an assignment (<code>=</code>). If you wanted to compare a character <code>== '1'</code> would have been the way to go.</p>

<pre><code>printf(""%ad"");
</code></pre>

<p>This is an invalid format specifier, <code>%d</code> would be valid for an <code>int</code> and <code>%c</code> for a character</p>
",2
34253047,34252793,1,"<p>This prototype is wrong:</p>

<pre><code>void disp(int *p[][20],int R,int C)
</code></pre>

<p>here <code>p</code> is a 2D array of pointers to <code>int</code>. The <code>*</code> binds to the left.</p>

<p>you want</p>

<pre><code>void disp(int p[20][20],int R,int C)
</code></pre>

<p>which is internally rewritten to be the same as</p>

<pre><code>void disp(int (*p)[20],int R,int C)
</code></pre>

<p>But you should really stick to the version with the <code>[20][20]</code> which makes your intentions clear.</p>
",0
34253083,34253010,1,"<p>Make sure to compile with the <code>-lcairo</code> flag. </p>

<p>If you're using the command line on linux do it like so:</p>

<p><code>gcc -o main main.c -Wall -Wextra -lcairo</code></p>

<p>Or if you're using an IDE just add <code>-lcairo</code> to the linker options.</p>
",0
34273959,34273675,1,"<p><code>*mat = (int **)malloc(n*sizeof(int *));</code> is dereferencing an un-allocated pointer. This causes <em>undefined behavior</em> ... </p>

<p><em>Undefined</em> means anything can happen. Have a read of <a href=""https://stackoverflow.com/a/4105123/1294207"">this.</a> It is certainly possible that you are not seeing the results of your bad de-allocation until the end of your program. </p>

<p>As a further note, <a href=""https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc"">you should not cast the result of malloc</a>.So the following:</p>

<pre><code>*mat = (int **)malloc(n*sizeof(int *));
</code></pre>

<p>needs to be replaced with:</p>

<pre><code>mat = malloc(n * sizeof mat*);
</code></pre>

<p>Along with some modifications to the rest of your memory allocation lines. </p>
",1
34274144,34273675,3,"<p>To actually answer your question, the reason you are getting a segmentation fault <strong>after</strong> the end of the main() function is because the stack has been corrupted.  </p>

<p>The <a href=""https://en.wikipedia.org/wiki/Stack_register"" rel=""nofollow"">stack pointer</a> has been overwritten, which means that when main() attempts to return, the stack pointer contains an invalid value.  This causes your program to attempt to access memory from outside the process's address space.  If you use exit(0) you <em>may</em> avoid the segmentation fault altogether.</p>

<p>Keep in mind that your program results in an undefined behavior.  Sometimes you'll get a segmentation fault at the end, sometimes during execution, sometimes none at all (And all sorts of other weird things may happen).</p>
",3
34273714,34273675,4,"<pre><code>*mat = (int **)malloc(n*sizeof(int *));
</code></pre>

<p>should be</p>

<pre><code>mat = (int **)malloc(n*sizeof(int *)); 
</code></pre>

<p>Unless I change the line to this, the program segfaults right there. Through sheer luck and undefined behaviour your program manages to run for a little longer.</p>

<p>Also there is no need to cast the return value of malloc. <a href=""https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc"">Here</a> are a couple reasons why you probably shoudn't.</p>
",5
32938519,32938415,3,"<p>You have to understand how the increment operator works.</p>

<p>You have two operations : </p>

<ul>
<li>X++ => Return the value of X, then increment it by 1.</li>
<li>++X => Increment X by 1 then return it.</li>
</ul>

<p>In your situation, the line with a problem is here : <code>x = 1 + a++;</code></p>

<p>This translates into : </p>

<ul>
<li><p>Return the value of a (1) and increment it (a becomes 2).</p></li>
<li><p>Set the value of x equal to the 1 + the value returned by a (1) (x becomes 2)</p></li>
</ul>

<p>Hope this helps.</p>
",6
32938646,32938415,1,"<p><strong>C Language Pre-increment and Post-increment Operators</strong></p>

<pre><code>#include &lt;stdio.h&gt;
int main()
{
    int a = 1, b = 1, x = 0, y = 0;
    double w;
    x = 1 + a++;
    printf(""x = %d\n"", x);
    printf(""a = %d\n"", a);
    y = ++b;
    printf(""y = %d\n"", y);
    printf(""b = %d\n"", b);
}
</code></pre>

<p>Pre-increment means <em>increment variable <strong>before</strong> its value is used</em>. Post-increment means <em>increment variable <strong>after</strong> its value has been used</em>. To understand how these operators work, let's look at the first case:</p>

<pre><code>a = 1;
x = 1 + a++; // ++ on right means post-increment
</code></pre>

<p>First you're setting the value of <code>a</code> to <code>1</code>. Then you're saying add <code>a</code> (<em>value is <code>1</code></em>) to <code>x</code> (<em>value is <code>1</code></em>). The result is <code>x</code> has a value of <code>2</code>.  And then, <em>after</em> the statement is done executing, as a side-effect, <code>a</code> is incremented, because you used the post-increment form of <em><code>++</code></em>. So after <code>x</code> has been set to a value of <code>2</code>, the value of <code>a</code> will become <code>2</code>.</p>

<p>Instead, if you used a a pre-increment operator:</p>

<pre><code>a = 1;
x = 1 + (++a); // ++ on left means pre-increment
</code></pre>

<p>Again, you start with <code>a = 1</code>, but this time, <code>a</code> is incremented <em>before</em> its value is used in the statement, because <code>++</code> on the left-side means pre-increment. In other words, first, <code>a</code> is incremented to the value of <code>2</code>. Then <code>a</code> is added to <code>x</code> (whose value is <code>1</code>), setting the value of <code>x</code> to <code>3</code>.</p>

<p>In both the above cases, <code>a</code> starts out with a value of <code>1</code> and becomes <code>2</code>. The difference is whether that happens before or after the value of <code>a</code> is used in the expression.</p>
",1
33597974,33597922,0,"<p>Firstly you cannot fflush stdin, unless you are using Windows.</p>

<p>From C11 7.21.5.2 The fflush function, fflush works only with output/update stream, not input stream.</p>

<blockquote>
  <p>If stream points to an output stream or an update stream in which the most recent operation was not input, the fflush function causes any unwritten data for that stream to be delivered to the host environment to be written to the file; otherwise, the behavior is undefined.</p>
</blockquote>

<p>There are two way to get around this. Firstly you can read the 3 digits as string, and does arithmetic through strings. Or you utilize both modulus operations, %, and division. Hopefully that helps you without just giving you the answer. </p>
",4
33598093,33597922,0,"<p>Pseudo code to test that the number was correctly entered:</p>

<pre><code>read an int value
if it worked
    read a char value
    if it worked
        if the char value is newline
            if the int value's range is correct
                print the int value
</code></pre>

<p>You check ""if it worked"" by testing the function return value from <code>scanf()</code>. See the man page for what that should be. </p>

<p>The reason for inputting another char is to test if the next char was a newline. If the input was for example <code>123a</code> then the number will be input correctly but the next char read will be <code>a</code> not <code>newline</code>. It will also detect if you enter say <code>123.45</code> because the next char will be <code>.</code></p>

<p>There should be no need to flush the input buffer - in fact it's in the wrong place and would destroy my second test for presence of next char being <code>newline</code>.</p>
",0
34250497,34250476,4,"<p>Loop over third array and assign true if any of previous two array contain true at that position: <code>grid3[i][j] = grid[i][j] || grid2[i][j]</code></p>
",0
34255264,34254794,2,"<p>Skimming through your code, there seems to be several problems. You should learn to use a debugger, which would let you step through the code line-by-line during execution and observe the actual behavior.</p>

<p>Here are some obvious issues I think you should look at:</p>

<ol>
<li>What do you think the value of <code>*employees</code> will be when the <code>while</code> loop exits? Specifically, think about this statement: <code>*employees = (*employees)-&gt;next;</code></li>
<li>I assume you want this list to be NULL-terminated (otherwise, the <code>while (employees != NULL)</code> in your main function wouldn't make sense). In that case, where do you set the <code>NULL</code> terminator value? You don't seem to ever set the <code>next</code> field to <code>NULL</code> anywhere...</li>
<li>Why do you call <code>malloc</code> twice in the body of your loop? You seem to be allocating two different blocks of memory to represent the same employee.</li>
</ol>

<p>I think #1 above is the reason that your program is crashing right now. (But if you fix that issue, your program will probably still crash due to one of the other issues.)</p>

<p>Right now, on the last iteration of your loop, you do this:</p>

<pre><code>    (*employees)-&gt;next = (empNode*) malloc(sizeof (empNode));
    *employees = (*employees)-&gt;next;
</code></pre>

<p>This means that <code>*employees</code> (which points to <code>employees</code> from <code>main</code>) will always end up pointing to an uninitialized <code>empNode</code> struct. Since the memory is uninitialized, the <code>next</code> pointer will be garbage. That's definitely going to cause some problems.</p>
",0
34255609,34254794,2,"<p>In your function <code>void load_employees_from_file(empNode **employees)</code></p>

<p>Change :</p>

<pre><code>(*employees)-&gt;next = (empNode*) malloc(sizeof (empNode));
</code></pre>

<p>to</p>

<pre><code>(*employees)-&gt;next = NULL;
</code></pre>

<p>as immediately after that <code>*employees</code> becomes <code>next</code> and the <code>while</code> loop starts from the beginning where memory is dynamically allocated:</p>

<pre><code>*employees = (empNode*) malloc(sizeof (empNode));
</code></pre>

<p>and then populated.</p>

<p>Otherwise, if this was the last employee, the <code>next</code> element remains the <code>NULL</code> pointer.</p>

<p>In this way, your <code>main</code>'s <code>while</code> loop termination condition will be <code>true</code> when the last <code>next</code> element (pointing to <code>NULL</code>) is reached.   </p>
",8
34195488,34195358,1,"<p>If you want to allow embedded spaces, modify the <code>scanf</code> formats this way:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void) {
    char job[100], hobby[100];
    printf(""Enter job:"");
    scanf(""%99[^\n]%*c"", job);
    printf(""Enter hobby:"");
    scanf(""%99[^\n]%*c"", hobby);
    printf(""%s,%s"", job, hobby);
    return 0;
}
</code></pre>

<p>But be aware that empty lines will not be accepted by this <code>scanf</code> format. The linefeed will stay in the input stream, the second <code>scanf</code> will fail too and <code>job</code> and/or <code>hobby</code> will have indeterminate contents, letting <code>printf</code> invoke undefined behavior.</p>

<p>Is is much more reliable to use <code>fgets()</code> and strip the <code>'\n'</code>.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void) {
    char job[100], hobby[100];

    printf(""Enter job:"");
    if (!fgets(job, sizeof job, stdin))
        return 1;
    job[strcspn(job, ""\n"")] = '\0';

    printf(""Enter hobby:"");
    if (!fgets(hobby, sizeof hobby, stdin))
        return 1;
    hobby[strcspn(hobby, ""\n"")] = '\0';

    printf(""%s,%s"", job, hobby);
    return 0;
}
</code></pre>
",0
34242880,34242535,1,"<p>You need to get a new random number <code>c</code> for the 50% condition each loop.</p>

<p>Move the line like <code>int c= (rand()%20)+1;</code> into the loop so that it gets a fresh number each time.</p>

<p>But you don't need to do the %20 or +1 on c. You are doing % 2 in the if() statement. Don't add 1 since you are already comparing it to 0 or != 0. So something like:</p>

<pre><code>while (randomNum!=userGuess)    
{
    int c = rand();

    if(userGuess&gt;randomNum &amp;&amp; c%2 == 0)

...
</code></pre>
",4
34255021,34254587,0,"<p>There are several issues with your code. You probably want an array of char, char start[99]. You should use strcmp or strncmp to compare strings. Just making your code work could be done like this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;

int main()
{
    char start[99];
    printf(""Welcome to MyOS 1"");
    printf(""\n"" ""#: "");
    fgets(start, sizeof(start), stdin);
    if (isalpha((unsigned char) *start) != 0)
    {
        if (strncmp(start, ""help"", 4) == 0)
            printf(""All commands: File Calculator\n"");
        else
            printf(""No such command.\n"");
    }
    else
        fprintf(stderr, ""Error\n"");
}
</code></pre>
",5
34254621,34254587,2,"<p><code>start</code> is an array of pointers to char and you probably want an array of char. So change</p>

<pre><code>char *start[99];
</code></pre>

<p>to </p>

<pre><code>char start[99];
</code></pre>

<p>and change <code>scanf(""%[98]"", &amp;start);</code> to <code>scanf(""%[98]"", start);</code></p>

<p>And to compare c-strings, use <code>strcmp()</code>. So change</p>

<pre><code> if (&amp;start == ""help"")
</code></pre>

<p>to </p>

<pre><code> if ( strcmp(start, ""help"") == 0 )
</code></pre>

<p>If you want to read a <em>line</em>, use <a href=""http://man7.org/linux/man-pages/man3/fgets.3.html"" rel=""nofollow""><code>fgets()</code></a> instead of <code>scanf()</code>.</p>

<p>Enabling compiler warnings would help too. For your code, GCC issues:</p>

<blockquote>
  <p>warning: format ¡®%[98¡¯ expects argument of type ¡®char *¡¯, but argument
  2 has type ¡®char * (*)[99]¡¯ [-Wformat=]</p>
  
  <p>warning: comparison of distinct pointer types lacks a cast</p>
  
  <p>warning: comparison with string literal results in unspecified
  behavior [-Waddress]</p>
</blockquote>
",5
34263386,34263166,0,"<p>When you doing  </p>

<pre><code>unsigned char num = -1; /* unsigned int */
</code></pre>

<p>It storing in <code>num</code>  is 255 (Max Number) in decimal. So in every loop <code>if(num &amp; 128u)</code> is satisfying so the o/p is .... </p>

<blockquote>
  <p>/* output is printed as ""1 1 1 1 1 1 1 1"" */</p>
</blockquote>

<p>There are some more mistakes in question you are saying abot <code>int</code> but in program you have taken <code>char</code> variable and storing <code>signed</code> number in <code>unsigned</code> variable so , you will not get o/p what you expect.</p>
",3
28453999,28453813,3,"<p>A casting like that is guaranteed to succeed by C99 standard:</p>

<blockquote>
  <p>6.7.2.1-13: A pointer to a structure object, suitably converted, points to its initial member (or if that member is a bit-field, then to the unit in which it resides), and vice versa. There may be unnamed padding within a structure object, but not at its beginning.</p>
</blockquote>
",1
28453912,28453813,-1,"<p>Of course you can cast it. But if you want to be able access to <code>char *inner_value;</code> and <code>char *outer_value;</code> you need to change order in <code>_outer</code>:</p>

<pre><code>struct _outer {
    char *outer_value; // &lt;----|
    struct _one common; // &lt;---|
};
</code></pre>
",0
26780947,2343099,0,"<p>Use like this:</p>

<pre><code>char c[20];
int s=23;

itoa(s,c,2);
puts(c);
</code></pre>

<p>Output:</p>

<pre><code>10111
</code></pre>
",1
28251567,3638851,1,"<p>The value is a string literal which cannot be modified because literals are stored in read only memory, try p[] instead.segmentation errors generally occur due to wrong use of pointers.</p>
",0
27077178,27077114,1,"<p>If <code>World()</code> is something that always returns ""World"", then define it as a macro:</p>

<pre><code>#define World ""World""
</code></pre>

<p>And then do:</p>

<pre><code>char text[1024] =
""Hello ""
World;  //Without parentheses
</code></pre>

<p><strong>EDIT</strong></p>

<p>String concatenation in the way you expect to do is made by the C preprocessor.You are actually looking for a runtime concatenation of two strings, which can be performed in multiple ways. The simplest one is achieved by <code>strcat</code> function, but the initialization should be performed explicitly by a function:</p>

<pre><code>char text[1024];
void init_text() {
    strcpy(text, ""Hello "");
    strcat(text, World());  //World() defined somewhere else
}
</code></pre>

<p>Alternative using <code>sprintf</code> :</p>

<pre><code>void init_text() {
    sprintf(text, ""Hello %s"", World());
}
</code></pre>

<p>Then in the <code>main</code> function, call <code>init_text()</code> at the beginning:</p>

<pre><code>int main() {
    init_text();
    ...
}
</code></pre>
",2
26245031,26244985,7,"<p>You are misreading Wikipedia. Here is a more complete <a href=""http://en.wikipedia.org/wiki/C_data_types#Basic_types"" rel=""nofollow"">quote</a> (emphasis mine):</p>

<blockquote>
  <p><strong>At least</strong> in the [?32767,+32767] range</p>
</blockquote>

<p>On most modern platforms (at least those powerful enough to run R), <code>int</code> is at least 32 bits wide, which gives a range of <code>[?2147483647,+2147483647]</code> or more.</p>

<p>Additionally, R's <code>?integer</code> has the following to say:</p>

<blockquote>
  <p>Note that current implementations of R use 32-bit integers for integer vectors, so the range of representable integers is restricted to about +/-2*10^9: doubles can hold much larger integers exactly.</p>
</blockquote>

<p>Finally, <code>?.Machine</code> say:</p>

<blockquote>
  <p><code>integer.max</code> - the largest integer which can be represented. Always 2147483647.</p>
</blockquote>
",2
28473827,28473724,2,"<p>Yes, data[1] is already 1 char long, so this is included in <code>sizeof(struct data_send)</code>.  So, <code>sizeof(struct data_send) + len</code> would yield a block which is slightly longer than necessary.</p>
",3
33592087,33591937,4,"<p>There are two bugs in your method 2:</p>

<ol>
<li><p><code>(rawtemp[2] &lt;&lt; 6 ) | (rawtemp[3] &gt;&gt; 2) / 16382</code> should be <code>((rawtemp[2] &lt;&lt; 6 ) | (rawtemp[3] &gt;&gt; 2)) / 16382</code> , because the priority of bitwise OR is lower than divide.</p></li>
<li><p>In C, if the two operands of <code>'/'</code> are both int, the result is also int, or <code>floor(a/b)</code>, you can use <code>(float)((rawtemp[2] &lt;&lt; 6 ) | (rawtemp[3] &gt;&gt; 2)) / 16382</code> (or write 16382 as 16382.0) to convert one of the operand into float, then the result will also be int.</p></li>
</ol>
",0
33592157,33591937,0,"<p>Another way is to do the type cast of the expression <code>(rawtemp[2] &lt;&lt; 6 ) | (rawtemp[3] &gt;&gt; 2)</code>  to float as in</p>

<pre><code>//method 2  
test = ((((float) ((rawtemp[2] &lt;&lt; 6 ) | (rawtemp[3] &gt;&gt; 2))) / 16382) * 165) - 40;
</code></pre>
",0
33591987,33591937,2,"<p>So the correct <code>method2</code> is :</p>

<pre><code> test = ((((rawtemp[2] &lt;&lt; 6 ) | (rawtemp[3] &gt;&gt; 2)) / 16382.0) * 165) - 40;
</code></pre>
",5
31223850,31223753,1,"<pre><code>newdata[k]=localstring[k];
</code></pre>

<p>If should come just after </p>

<pre><code>for(int k=0;k&lt;maxL;k++)
 {
 //here
</code></pre>

<p>And if that is not solving it then please provide related complete 
code.</p>
",3
31224131,31223753,0,"<p>clearing the array , which would have some values in it, would solve this, and this is because when you print it, and there are some other values in it, you get them printed too </p>

<pre><code>  for( int i = 0; i &lt; maxL;  ++i )
   newdata[i] = (char)0;
</code></pre>

<p>solve it completely .</p>

<p>EDIT:
And to anyone who needs, this is the complete function that works :</p>

<pre><code>char * getHeader( char localString[], int seperatorNum)
{


   int maxL=50;
   const char seperator=':';
   char newdata[maxL];
   int counter=0;
   int divider=0;
   //clear array when it has garbage it added
   for( int i = 0; i &lt; maxL;  ++i )
      newdata[i] = (char)0;

   for(int k=0;k&lt;maxL;k++)
   {


        if ( localString[k]==  seperator   )
       {

           counter++;
           divider=k+1;
           if(counter==seperatorNum)
           {   return newdata;     } 
       }
         if(  (seperatorNum-1) ==counter)
             newdata[k-divider]=localString[k];

   }


 }
</code></pre>
",1
31223899,31223753,0,"<pre><code>char * getHeader( char localString[], int seperatorNum)
{ 
    int maxL=50;
    const char seperator=':';
    char newdata[maxL];
    memset(newdata, '\0', maxL);///////
    int counter=0;
    int i = 0; ///////
    for(int k=0;k&lt;maxL;k++)
    {
        if ( localString[k] ==  seperator   )
        {
            counter++;
            if(counter == seperatorNum)
            { 
                Serial.println(newdata);    
                return newdata;     
            } 
        }else{
           newdata[i] = localString[k];//outside the else this was alway executed.  I assume you didn't want the seperator in this
           i++;
        }
    }
}
</code></pre>
",3
34272957,34272895,6,"<p><code>assert(i &gt; 0);</code> is more readable to other programmers that <code>i</code> is checked for positive integers and including the case for <code>i = 0</code>.  </p>

<hr>

<p><strong>Note:</strong> As <a href=""https://stackoverflow.com/users/440558/joachim-pileborg"">Joachim</a> pointed in his <a href=""https://stackoverflow.com/questions/34272895/is-uint-strictly-positive/34272957#comment56287914_34272895"">comment</a> that keep in mind that <em>if the macro <code>NDEBUG</code> was defined at the moment <code>&lt;assert.h&gt;</code> was last included, the macro <a href=""http://man7.org/linux/man-pages/man3/assert.3.html"" rel=""nofollow noreferrer""><code>assert()</code></a> generates no code, and hence does nothing at all.</em></p>
",0
34272981,34272895,3,"<p>I prefer</p>

<pre><code>assert(i &gt; 0); /*option 1*/
</code></pre>

<p>For 2 reasons.</p>

<p>Firstly it's one less character, and characters cost money.</p>

<p>Secondly if your intent is to show the number is strictly positive this makes it clear even without the knowledge that i is an unsigned int.</p>
",2
34273156,34272895,2,"<p>Both certainly generate the same code so <strong>whatever conveys the overall function's goal</strong> is the better selection:</p>

<pre><code>unsigned int i = ...;
assert(i &gt; 0); /*option 1*/
assert(i != 0); /*option 2*/
</code></pre>

<p>Option 1 works better in most cases as it is a positive assertion: what should the value be vs. what it should not be.  Usually this is easier to understand.  Also when the arithmetic nature of <code>i</code> is being tested, this is the way to go.</p>

<p>Option 2 works better in limited cases when <code>i</code> is solely used for its zero, or non-zero-ness - especially if it is a collection of logical bits whose arithmetic value is irrelevant.</p>
",0
24769192,24769144,4,"<blockquote>
  <p>Does the behaviour differ depending on the type?</p>
</blockquote>

<p>Kind of. When you return something in C, you return the value, not a pointer to the value or anything that depends on any variables still existing. However, there's an unrelated rule that says that in almost all contexts, a value of array type is implicitly converted to a pointer to the array's first element. Thus, the second code snippet is returning a pointer into the array, while the first snippet just returns an int.</p>
",2
24769178,24769144,1,"<p>In the first code snip, the value of an int variable is being returned.  Very OK.</p>

<p>In the second code snip, the address of a local (stack) variable is being returned. Not OK.</p>

<hr>

<p>And, perhaps the line:</p>

<pre><code>char[10] result;
</code></pre>

<p>would be better as: </p>

<pre><code>char result[10];
</code></pre>

<hr>

<p>If the second example declared result as follows:</p>

<pre><code>char result;
</code></pre>

<p>then the value in result could be returned:</p>

<pre><code>return(result);
</code></pre>

<p>However, the second example defines result as an array of char; making result a pointer to the beginning of this array.  Hence, the true value of result in the second example is an address to local stack memory (which disappears when the function scope terminates).</p>

<p>The first example captures the value of result (an integer value) and sends the value back to the caller, (not the address of the value in the function's local scope).</p>
",0
24769341,24769144,7,"<p>In your <code>add()</code> function, you return the <em>value</em> that is held (until the function exits) in its local variable <code>result</code>.  The storage for that <em>variable</em> is no longer available once the function returns, but the value that was stored there is just a number, not in itself dependent on that storage.</p>

<p>In your <code>concat()</code> function, the expression <code>result</code> evaluates to a <em>pointer</em> to the local storage for an array of 10 <code>char</code>.  You can still return the pointer's value, but once the function exits the meaning of that value is no longer defined.</p>

<p>So, no, the behavior of returning a value does not itself differ between those cases, but the <em>usefulness</em> -- indeed the risk -- associated with doing so varies greatly.</p>
",0
26411607,26411421,0,"<p>A simple code</p>

<pre><code>  #include&lt;stdio.h&gt;
int n = 6; //number of elements in array1
int array1[] = {1,3,5,8,9,11};
int *funCount;//Count of elements in array1
int count(int a)
{
  int i;
  for(i = 0; i &lt; n; i++)
    if(a == array1[i])
      break;
  funCount[i]++;
}

int main()
{
  funCount = (int*)calloc(n, sizeof(int));
  int i;
  count(1);
  count(3);
  count(5);
  count(8);
  count(9);
  count(11);
  for(i = 0; i &lt; n; i++)
    printf(""%d "",funCount[i]);
  return 0;
}
</code></pre>

<p>This approach is okay if your <code>array1</code> is going to be small!
Otherwise I would recommend you to use hashing</p>
",6
29223082,9407873,0,"<p>If I get your question right. Your <code>int a[]={1,2,3,4,5};</code> I believe only stores the address of element 0 so putting this <code>if(&amp;a[0] == a)</code>
 is probably not required. The c string theory states that an array identifier without the bracket is the address of the first element of the characters. ""a"" is not defined in the program. it would probably give you a stack error. I would write it this way <code>if(&amp;a == a[]){printf(""------"");</code> this would only compare the address of the pointer to the address of the first element of the array.</p>
",0
32987967,32987541,1,"<p>You could use this method, devoid of loop, branch or modulo:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;

int main(void)
{
    uint8_t x = 15; 
    printf(""%u"", x - (x/9)*9);
    return 0;
}
</code></pre>

<p>Program output:</p>

<pre><code>6
</code></pre>
",2
32988255,32987541,3,"<p>I don't understand why one would want to replace the modulo operator.
If it is about <em>efficiency</em>, consider the following two examples:</p>

<pre><code>int main(int argc, char* argv[]) {
  int x  = argc % 9;
  return x;
}
</code></pre>

<p>and </p>

<pre><code>int main(int argc, char* argv[]) {
  int x = argc - (argc / 9) * 9;
  return x;
}
</code></pre>

<p>For both implementation, <code>gcc -g -O3</code> is generating the <em>same assembly</em> (I am using gcc 4.8.1 on x86):</p>

<pre><code>main:
    movl    %edi, %eax  # argc, tmp71
    movl    $954437177, %edx    #, tmp65
    imull   %edx    # tmp65
    movl    %edi, %eax  # argc, tmp67
    sarl    $31, %eax   #, tmp67
    sarl    %edx    # x
    subl    %eax, %edx  # tmp67, x
    leal    (%rdx,%rdx,8), %eax #, tmp70
    subl    %eax, %edi  # tmp70, x
    movl    %edi, %eax  # x,
    ret
</code></pre>

<p>Conclusion: <strong>don't care about efficiency</strong> (in this case and in the most other cases), let the compiler do that.</p>

<p>BTW: <code>954437177</code> is <code>(2^33 + 1) / 9</code></p>
",0
32988347,32987541,3,"<p>This is what compilers are for. You enter code that generates the output you want, and the compiler generates the most efficient assembly to produce that output.</p>

<p>In fact the C language is defined in terms of an abstract machine in which only its observable behaviour is defined.</p>

<p>For the program:</p>

<pre><code>int main(int x, char **z)
{ 
    x  = x % 9;
    return x;
}
</code></pre>

<p>gcc 5.2 -O3 generates:</p>

<pre><code>main:
    movl    %edi, %eax
    movl    $954437177, %edx
    imull   %edx
    movl    %edx, %eax
    movl    %edi, %edx
    sarl    %eax
    sarl    $31, %edx
    subl    %edx, %eax
    leal    (%rax,%rax,8), %eax
    subl    %eax, %edi
    movl    %edi, %eax
    ret
</code></pre>

<p>I am not sure exactly what this is, but 954437177 is <code>0b00111000111000111000111000111001</code>.  If you are interested perhaps you could benchmark this assembly against anything else that you come up with by hand.</p>
",0
22443031,22442746,2,"<p>To answer the question: yes. You now have a type <code>Building</code> that is a pointer to a <code>struct building</code> and you can do this:</p>

<pre><code>Building someBuilding = malloc(sizeof(struct building));
someBuilding-&gt;floor = malloc (sizeof(char)*20);
strcpy(someBuilding-&gt;floor, ""First floor"");
someBuilding-&gt;nextBuilding = NULL;
</code></pre>

<p>etc.</p>

<p>note that this might not be a good idea in all cases. For example if you declare a method:</p>

<pre><code>void setFloorName(Building building, char* name)
</code></pre>

<p>you can't really tell that you need to pass a pointer to a building struct, but if you do:</p>

<pre><code>void setFloorName(Building* building, char* name)
</code></pre>

<p>you immediately see that the function takes a pointer.</p>
",0
22443066,22442746,2,"<p>Yes, when you write:</p>

<pre><code> typedef struct building { ¡­ } *Building;

 Building bp;
</code></pre>

<p>then <code>bp</code> is a pointer to a <code>struct building</code>.  However, it is frequently regarded as bad style to include the pointer in the <code>typedef</code>; code is easier to understand if you use:</p>

<pre><code> typedef struct building { ¡­ } Building;

 Building *bp;
</code></pre>

<p>Now it is clear looking at the definition of <code>bp</code> that the type is a pointer.  If you are never going to access the internals of the structure, then it doesn't matter too much (but look at <code>FILE *</code> in <code>&lt;stdio.h&gt;</code>; you always write <code>FILE *fp</code>, etc).  If you're going to access the internals:</p>

<pre><code>printf(""Floor: %s\n"", bp-&gt;floor);
</code></pre>

<p>then it is better to have the pointer visible.  People will be mildly surprised to see <code>Building bp;</code> and then later <code>bp-&gt;floor</code> instead of <code>bp.floor</code>.</p>
",2
23812766,11336032,1,"<p>Yes, this appears to be a quirk in C standard. However, it looks like this is only to do with <code>va_arg()</code>.</p>

<p>You can take a look at various implementations of <code>printf()</code> to see how to overcome this. For example, the <a href=""http://git.kernel.org/cgit/libs/klibc/klibc.git/tree/usr/klibc/vsnprintf.c"" rel=""nofollow"">one in klibc</a> is pretty easy to read.</p>
",0
28213412,14297169,-1,"<blockquote>
  <p>A Very very basic code explanation on How to Return
  array back from a user defined function to main function hope it
  helps. Below, I have written a complete code to make.
  pardon the c++ language, however please 
  feel free to comment if you need exactly the c program</p>
</blockquote>

<pre><code>#include&lt;iostream&gt;
using namespace std;

int * function_Random()// function with returning pointer type of integer
{
     static int arr[100];
     cout&lt;&lt;""We are Inside FunctionRandom""&lt;&lt;endl;
    for(int i=0;i&lt;100;i++)//loop to add elements in array
    {
        arr[i]=rand();//rand() function to put random numbers generated by system
        cout&lt;&lt;""\t""&lt;&lt;arr[i]; //to show how our array will look
    }
    cout&lt;&lt;endl&lt;&lt;endl;//endl for end line to look well formatted 
    return arr;
}
int main()
{


    int *arrptr; //pointer to get back base address of array
    arrptr=function_Random();//function that returns base address
    cout&lt;&lt;""We are Inside Main""&lt;&lt;endl;
    for(int j=0;j&lt;100;j++)
    {
         cout&lt;&lt;""\t""&lt;&lt;arrptr[j];//returned base address has complete link of array that's why it is able to print the array:contiguous memory locations.
    }       
    return 0;//nothing to return that's why 0
}
</code></pre>
",3
27760954,27759954,0,"<p>sample of fix</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

typedef struct {
    int len;
    char *s;
} string;
//typedef string_t string;//no need pointer type.

void set (string *s1, const char *s);
void concat (string *s1, const string *s2);//Unified to pointer
string *create(const char *s);

int main(void) {
    string *str1 = create(NULL);//calloc(1, sizeof(*str1));//create("""");//create(""hello "");
    string *str2 = create(NULL);//calloc(1, sizeof(*str2));//create("""");

    set(str1, ""hello "");
    set(str2, ""world!"");
    printf(""\nconcatenate str1 and str2\n"");
    concat(str1, str2);

    printf(""concatenation result is:\n"");
    printf(""%s"", str1-&gt;s);

    printf(""\n------End------\n"");
    free(str1-&gt;s);free(str1);
    free(str2-&gt;s);free(str2);
    return EXIT_SUCCESS;
}

string *create(const char *s){
    string *str = malloc(sizeof(*str));
    if(str){
        if(s){
            str-&gt;len = strlen(s);
            str-&gt;s = strdup(s);//strdup isn't standard
/*
            str-&gt;s = malloc(str-&gt;len + 1);
            if(!str-&gt;s){
                free(str);
                str = NULL;
            } else {
                memcpy(str-&gt;s, s, str-&gt;len + 1);
            }
*/
        } else {
            str-&gt;len = -1;
            str-&gt;s = NULL;
        }
    }
    return str;
}

void set(string *s1, const char *s){
    if(s1 != NULL){
        free(s1-&gt;s);
        if(s == NULL){
            s1-&gt;s = NULL;
            s1-&gt;len = -1;
        }else{
            s1-&gt;s = strdup(s);
            s1-&gt;len = strlen(s);
        }
    }
}

void concat (string *s1, const string *s2){
    if(!s1 || !s2 || s1-&gt;len == -1 || s2-&gt;len == -1)
        return ;

    int totalLen = s1-&gt;len + s2-&gt;len;
    char rslt[totalLen+1];//char *rslt = malloc(totalLen+1);

    strcpy(rslt, s1-&gt;s);//use standard library
    memcpy(rslt + s1-&gt;len, s2-&gt;s, s2-&gt;len + 1);

    set(s1, rslt);
    //free(rslt);
}
</code></pre>
",2
27762743,27759954,0,"<pre><code>// code readability is every bit as important as the algorithm used
// when compiling, have all warnings enabled, and then fix them
// OP can add parameter checking and make the str1 and str1 be pointers
//    with appropriate changes to the rest of the code
// I changed return types from void to int
// for set() and concat() so main could free the allocated memory areas
// the 'software contract' concept says the sub functions in the file
// do not need to check their parameters for validity


#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt; // strlen()
// strdup() should have been prototyped by string.h,
// but was not on my computer
char *strdup(const char *s); 


// dont clutter the code with frivilous typedef's
struct string_t
{
    int    len;
    char * s;
};

// prototypes
int concat (struct string_t*, struct string_t* );
int set( struct string_t*, char* );

int main(void)
{
    //create variables
    // your learning C, so keep it simple
    struct string_t str1 = {0,NULL};  // good programming practice to initialize local variables
    struct string_t str2 = {0,NULL};

    if( !set( &amp;str1, ""hello "" ) )
    {
        if( !set( &amp;str2, ""world!"" ) )
        {
            printf(""\nconcatenate str1 and str2\n"");
            if( !concat(&amp;str1,&amp;str2) )
            {
                printf(""concatenation result is:\n"");
                printf(""%p , %s"",(void*)&amp;(str1.s), str1.s);

                printf(""\n------End------\n"");
            } //  end if
        } // end if
    } // end if

    free(str1.s);
    free(str2.s);
    return EXIT_SUCCESS;
} // end function: main


// &lt;-- pString1 must point to an instance of struct string_t
// do not free() the pNewString
// as it is a pointer to a literal,
// not a pointer to allocated memory
int set( struct string_t* pString1, char* pNewString ) // &lt;-- use meaningful/descriptive names
{
    int returnValue = 0; // indicate success


    char * temp = strdup(pNewString);
    if( NULL == temp )
    { // then strdup failed
        perror( ""strdup failed"" );
        returnValue = 1; // indicate failure
    }

    else
    { // else, strdup successful
        pString1-&gt;s   = temp;
        pString1-&gt;len = strlen(pString1-&gt;s)+1;
    }
    return( returnValue );
} // end function: set


int concat (struct string_t* pString1, struct string_t* pString2)
{
    int returnValue = 0; // indicate success

    int totalLen = pString1-&gt;len + pString2-&gt;len + 1;
    //printf( ""\nbefore: string1-&gt;len =%i,string2-&gt;len=%d, totalLength=%i\n"",
    //            pString1-&gt;len,
    //            pString2-&gt;len,
    //            totalLen);
    //printf(""\nbefore: string1:%s, string2:%s\n"",
    //            pString1-&gt;s, pString2-&gt;s);

    // &lt;-- there is no room in string1-&gt;s for any more chars so:
    char * temp;
    if( NULL == (temp = realloc(pString1-&gt;s, totalLen) ) )
    { // then realloc failed
        perror( ""realloc failed"" );
        returnValue = 1; // indicate failure
    }

    else
    {
        free( pString1-&gt;s);
        pString1-&gt;s = temp;
        //printf(""\n after realloc: str1.len:%i, strl.s:%s\n"",
        //       pString1-&gt;len, pString1-&gt;s);

        int i=0;
        for(;i&lt;totalLen;i++)
        {
            pString1-&gt;s[strlen(pString1-&gt;s)] = pString2-&gt;s[i];
            pString1-&gt;s[strlen(pString1-&gt;s)] = '\0';
        } // end for

        pString1-&gt;len = totalLen;
        pString1-&gt;s[totalLen] = '\0';

        //printf(""after: str1addr:%p , str1:%s\n"",pString1-&gt;s,pString1-&gt;s);
        //printf( ""\nstring1-&gt;len =%i,string2-&gt;len=%d, totalLength=%i\n"",
        //        pString1-&gt;len,
        //        pString2-&gt;len,
        //        totalLen);
    } // end if

    return( returnValue );
} // end function: concat
</code></pre>
",0
22436865,22436645,1,"<p>I think you are wondering what will be the general term of such a sequence. Once you know it coding is easy.</p>

<p>Let me reveal that for all such sequences with some finite number of terms there are infinitely many representations for it. So there is no point in arguing or worrying whether your interpretation of the sequence is right or wrong. So your logic of generating the number is correct, although it us not the only correct answer.For example an another possible solution would be <img src=""https://i.stack.imgur.com/ysFLB.png"" alt=""enter image description here""></p>

<p>You can find any such possible solution, in mathematics finding out a possible function to represent all the set of point is termed as interpolation. Here is an <a href=""http://www.solvemymath.com/online_math_calculator/interpolation.php"" rel=""nofollow noreferrer"">interpolation calculator</a></p>
",0
22437110,22436645,-1,"<pre><code>#include&lt;stdio.h&gt;

main()
{
    int n=14, c, k, temp;

    temp = n;

    for ( c = 0 ; c &lt;= 4 ; c++ )
    {
        for( k = 2 ; k &lt;= temp ; k++ )
            printf(""*"");

        if(k&lt;=13)
        {
             temp=temp-3;
        }
        else
        {
        temp=temp-2;
        } 
     printf(""\t\t%d"",k-2);
        printf(""\n"");
    }

    return 0;
}
</code></pre>

<p><img src=""https://i.stack.imgur.com/ysEyg.png"" alt=""enter image description here""></p>
",0
23086110,23085381,0,"<p>Assuming the code actually compiles... then:</p>

<blockquote>
  <p>x1 = c->buf;</p>
</blockquote>

<p>x1 could be anything, as the rvalue of the expression doesn't affect or determine the type of x1.</p>

<p>c->buf is an array, which in turn decays into pointer. A pointer can be converted to any other pointer type. And it can be converted to an int.</p>

<blockquote>
  <p>x2 = *c->buf;</p>
</blockquote>

<p>x2 could be anything, as the rvalue of the expression doesn't affect or determine the type of x2.</p>

<p>*c->buf is a <code>char</code>, but that type can be converted to any other integer type and also to pointer types or floating point etc etc.</p>

<blockquote>
  <p>x3 = &amp;c->buf[c->curp];</p>
</blockquote>

<p>x3 could be anything, as the rvalue of the expression doesn't affect or determine the type of x3.</p>

<p>For the same reasons as for x1, except the rvalue in this case is a char pointer.</p>

<blockquote>
  <p>x4 = *c;</p>
</blockquote>

<p>x4 could be anything, as the rvalue of the expression doesn't affect or determine the type of x4.</p>

<p>However, *c is a struct, so x4 would have to be another struct or the code wouldn't compile.</p>
",0
23085635,23085381,0,"<p>The possible types as,</p>

<p>x1 = c->buf;</p>

<p>x1 is pointer to a character since buf is the base pointer.</p>

<p>x2 = *c->buf;</p>

<p>x2 is a character since base pointer is dereferenced to get the first character</p>

<p>x3 = &amp;c->buf[c->curp];</p>

<p>x3 is a pointer to a character since c->buf[c->curp] gives a character and <code>&amp;</code> gives its address</p>

<p>x4 = *c;</p>

<p>x4 is a variable of struct client since c is a pointer to a variable of that struct and is dereferenced. </p>

<p>It is not necessary since other types can also be used to hold these values. these are possible types.</p>
",2
31122612,31122444,4,"<p>I think your question belongs on another network.</p>

<p>Answers here: <a href=""https://superuser.com/q/291224/447379"">Equivalent to ^D (in bash) for cmd.exe?</a></p>

<blockquote>
  <p>No. <kbd>Ctrl</kbd><kbd>D</kbd> on *nix generates a EOF, which various
  shells interpret as running <code>exit</code>. The equivalent for EOF on Windows
  is <kbd>Ctrl</kbd><kbd>Z</kbd>, but cmd.exe does not interpret this
  specially when typed at the prompt.</p>
</blockquote>
",2
31122670,31122444,1,"<p><kbd>Ctrl</kbd>+<kbd>D</kbd> to sends <code>EOF</code> to standard input and stops the read on *nix.</p>

<p>Have a look <a href=""https://superuser.com/questions/291224/equivalent-to-d-in-bash-for-cmd-exe"">here</a>.</p>
",0
31123287,31122444,0,"<p>You have to check whether you use *nix or windows.</p>

<p>On Windows, EOF is represented by <code>Ctrl+Z</code>, whereas on *nix EOF is represented by <code>Ctrl+D</code> </p>
",0
21321690,21321614,3,"<p>You are always printing the value of <code>str</code>, which is not an <code>int</code>.</p>
",0
21321694,21321614,4,"<p>You're printing a char array with <code>printf</code> using <code>""%d""</code>, which is for printing integers. Use <code>""%s""</code> for printing char arrays:</p>

<pre><code> printf(""%s\n"", str, gt75);
</code></pre>

<p>Or, if you're trying to print the value of <code>gt75</code> as an integer:</p>

<pre><code>printf(""%d\n"", gt75);
</code></pre>

<p>I do not know why you would pass <code>str</code> in this case, though.</p>

<p>When you use <code>""%d""</code>, you are telling <code>printf</code> to interpret the input as an <code>int</code>. Since <code>str</code> is actually a char array, it does not output correctly. Instead, you're printing the memory location of <code>str</code>, which is the value of an array.</p>
",3
21321709,21321614,5,"<p>You have two errors.</p>

<p>First, <code>int r = rand() % 99;</code> should be <code>int r = rand() % 100;</code>  Otherwise you just get numbers between 0 and 98.</p>

<p>Second, your printf statements are odd.  They should be:</p>

<pre><code>printf(""Greater than 75: %d\n"", gt75);
printf(""Less than 50: %d\n"", lt50);
</code></pre>

<p>In the current printf statements, the str is cast to an int, which is interpreting the str pointer as an int, thus your strange output.</p>
",0
26425492,26425450,6,"<p>This happens because you're calling the function before it's declared. Undeclared functions are assumed to return <code>int</code>, which explains the error.</p>

<p>Move the <code>printMenu()</code> definition to before the function that's doing the call, or add a prototype:</p>

<pre><code>char * printMenu(void);
</code></pre>

<p>And make sure you add <code>void</code>, <code>()</code> is wrong for a function accepting no parameters.</p>

<p>Also, your code is broken since each time you call <code>printMenu()</code> it will call <code>strcat()</code> four times, causing the menu text to grow and grow and eventually cause a buffer overrun.</p>
",0
26425495,26425450,4,"<p>Please include these lines at the top of your code:</p>

<pre><code>#include &lt;string.h&gt;
char * printMenu();
</code></pre>

<p>In the future, please include a fully compilable test case.</p>
",0
22874421,22874377,1,"<p>Have you tried <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/ms646293%28v=vs.85%29.aspx"" rel=""nofollow"">MSDN</a>?</p>

<blockquote>
  <p>If the most significant bit [0x8000] is set, the key is down, and if the least significant bit is set [0x0001], the key was pressed after the previous call to GetAsyncKeyState.</p>
</blockquote>

<p>-32767 = 0x8001, so  both of the above bits are set.</p>
",8
28490779,28490705,5,"<pre><code>#include &lt;math.h&gt;

typedef struct 
{
    float x, y, z;
} VECTOR;

void normalize( VECTOR* p )
{
    float w = sqrt( p-&gt;x * p-&gt;x + p-&gt;y * p-&gt;y + p-&gt;z * p-&gt;z );
    p-&gt;x /= w;
    p-&gt;y /= w;
    p-&gt;z /= w;
}
</code></pre>
",7
26159610,26158977,1,"<p>Your problem seems to be related to your development environment. It seems like, in your IDE, when the program ends, the program window is closed. </p>

<p>There are two ways to work around the problem.</p>

<p>The first way is to compile your program into an exe file and run it from a cmd window.</p>

<p>The second way is to introduce a delay before the program ends. You could insert a call to <code>sleep</code> for a number of seconds or <code>read</code>/<code>scanf</code> something from standard input.</p>

<p>I ran your program and instead of printing at coordinate col, row I printed <code>(col, row) i</code>.</p>

<p>The output looked like this (looks fine to me):</p>

<pre><code>please enter size of magic box
3
total magic square size 9
(2, 1) 1
(1, 3) 2
(3, 2) 3
(3, 3) 4
(2, 2) 5
(1, 1) 6
(1, 2) 7
(3, 1) 8
(2, 3) 9
</code></pre>
",0
23074498,23074431,0,"<p>Add a variable (say, <code>inctemp</code>) to count seeing increases in a row, and increment it in your loop if there is an increase.  Reset it to 0 if there is not an increase.  At the end of your loop, you know how many in a row there were (at least at the end of the data set)</p>

<p><em>Modified for arbitrary number of reads</em></p>

<pre><code>int inctemp = 0;
float curtemp, prevtemp;

...

if ( fscanf(fpt, ""%f"",&amp;prevtemp) == 1)
    printf(""%.2f"",prevtemp);
    while( fscanf(fpt, ""%f"",&amp;curtemp) == 1)
    {
        printf(""%.2f"",curtemp);
        if( curtemp &gt; prevtemp ) {
            inctemp++;
        } 
        else {
            inctemp = 0;
        }
        if( inctemp == 6 ) {
            printf(""Six increases in a row!\n"");
        }
        prevtemp = curtemp;
  }
}
</code></pre>
",4
23074517,23074431,1,"<p>There is no need to use an extra loop. You can just do</p>

<pre><code>totalInc = 0;

for(i=0;i&lt;7;++i) {
    fscanf(fpt, ""%f"",&amp;t[i]);
    printf(""%.2f"",t[i]);

    if (i &gt; 0) {
        if (t[i] &gt; t[i-1]) totalInc += 1;
        else               totalInc -= 1;
    }
}
</code></pre>

<p>The <code>totalInc</code> will tell you the number of times the current value is greater than the previous value. For your case, you can then just check for <code>totalInc == 6</code> but really, you can just check for any number of increments. A positive number will indicate a general incremental trend, while a negative number will indicate a general decreasing trend. </p>
",0
23074592,23074431,0,"<p>Finding a delta between the temperatures will help you.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;cstdlib&gt;

int main()
{
    FILE *fpt;  /*define a pointer to predefined structure type FILE*/

    fpt = fopen(""temperature.dat"",""r"");

    char temp[10];
    float t[7];
    int i, loweringdelta;

    fscanf(fpt, ""%s"",temp);
    printf(""%s"",temp);

    loweringdelta = 1;
    for (i=0; i&lt;7; ++i)
    {
        fscanf(fpt, ""%f"", &amp;t[i]);
        printf(""%.2f"", t[i]);
        if (i &gt; 0 &amp;&amp; (t[i]-t[i-1]&lt;= 0))
        {       
          loweringdelta = t[i]-t[i-1];
        }

    }

    if (loweringdelta &gt; 0)
    {
        // Your error message here
    }

    printf(""%f"", t[3]);  /*just testing whether the program is reading correctly*/

    fclose(fpt);
    system(""pause"");
}
</code></pre>
",0
23074608,23074431,1,"<p>To detect whether a file of floats has at least 6 increasing values in a row, you could do something like this:</p>

<pre><code>#include &lt;stdio.h&gt;

#define IN_A_ROW 6

int main() {
  FILE *f = fopen(""temps.txt"", ""r"");
  float x, last_x;
  int inc = 0;
  fscanf(f, ""%f"", &amp;last_x);
  while (fscanf(f, ""%f"", &amp;x) == 1) {
    if (x &gt; last_x) {   // or maybe &gt;=
      if (++inc &gt;= IN_A_ROW) {
        printf(""Found %d increases in a row\n"", IN_A_ROW);
        return -1;
      }
    }else
      inc = 0;
    last_x = x;
  }
  fclose(f);
  return 0;
}
</code></pre>
",2
23074683,23074431,0,"<p>You will need some kind of counter to see how many times you have seen incrementing temperatures. Also, read the file in a while loop:</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    FILE *fpt;  /*define a pointer to predefined structure type FILE*/

    fpt = fopen(""temperature.dat"",""r"");

    char temp[10];
    int count = 0;
    int i;
    float prev_temp = -999.00;
    float current_temp;
    int threshold = 6;

    fscanf(fpt, ""%s"",temp); // header?
    printf(""Header: %s\n"",temp);

    while(!feof(fpt)) {
        fscanf(fpt, ""%f"", &amp;current_temp);
        if (current_temp &gt; prev_temp) count++;
        else count = 0;
        prev_temp = current_temp;
        if (count &gt; threshold) printf(""Saw %d consecutive increases\n"", count);
    }

    fclose(fpt);
}
</code></pre>
",0
23078966,23078672,4,"<p>Your current program stops it when the user hits ""Enter"" key only and it doesn't stop if you enter a single space.</p>

<p><code>gets</code> removes the newline and doesn't store it in the buffer, so buffer[0] will equal '\0' with no input and <code></code> if you enter a space.</p>

<p>A few notes:</p>

<ul>
<li><p>Enable compiler warnings. Warnings give you hints on potential bugs.</p></li>
<li><p>You are missing 2 <code>#include</code> files: <code>stdlib.h</code> and <code>string.h</code>.</p></li>
<li><p><code>gets</code> has been deprecated due to its unsafe nature visavi buffer overruns. Use <code>fgets</code> instead!</p></li>
</ul>
",3
23080263,23078672,1,"<p>Ok, the most <em>""traditional""</em>, basic approach I can think of would be to do this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main ( void )
{
    int c, i, j=0;
    char buffer[80], *dynArray[5];
    for (i=0;i&lt;5;++i)
    {
        j = 0;
        while((c = getchar()) != EOF &amp;&amp; c != '\n' &amp;&amp; j &lt; 79)
            buffer[j++] = c;
        if (j == 0)
        {//an empty string was encountered!
            for (--i;i&gt;-1;--i)
            {//use --i, because current i is not allocated yet!
                printf(""Freeing memory containing \""%s\""\n"", dynArray[i]);
                free(dynArray[i]);
            }
            return EXIT_SUCCESS;//exit program here, then
        }
        buffer[j] = '\0';//add NULL-char
        dynArray[i] = calloc(j, sizeof *dynArray[i]);//calloc to initialize memory
        if (dynArray[i] == NULL)
            exit(EXIT_FAILURE);
        strcpy(dynArray[i], buffer);
    }
    //allow user to see a specific input string again:
    puts(""Choose a string to see again [1-5], or enter q to proceed"");
    while ((c = getchar()) != EOF &amp;&amp; c != 'q')
    {
        c -= (1 + '0');//simple atoi trick
        if (c &lt; 5 &amp;&amp; c &gt; -1)//input char is 1, 2, 3, 4 or 5
            printf(""string %d: %s\n"", c+1, dynArray[c]);
    }
    //q was fetched from stdin, clear buffer...
    while((c = getchar()) != EOF &amp;&amp; c != '\n');
    for (i=0;i&lt;5;++i)
    {
        printf(""free-ing memory containing: %s\n"", dynArray[i]);
        free(dynArray[i]);
    }
    getchar();//press any key to continue...
    return 0;
}
</code></pre>

<p>You can play around with this as you see fit (splitting bits and pieces of this into functions and such)...<br>
Here's a more usable example:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int get_key( const int max )
{
    int c, r = 0;
    while ((c = getchar()) != EOF &amp;&amp; c != 'q' &amp;&amp; c != '\n')
    {
        c -= '0';
        if (c &gt; -1 &amp;&amp; c &lt; 10)
        {
            if (r &gt; 0)//suppose input was 22, r will be 2 on second iteration of loop
                r *=10;//multiply by 10, to get 20
            r += c;//add 2 == 22
        }//optionally add else, clean buffer and procede if r &gt; 0
    }
    if (r &gt; max || r == 0)//perhaps move to loop body
        r = -1;//out-of-bounds request = -2
    if (c == 'q')
    {
        r = 0;//stop = -1
        //clean buffer
        while (c != EOF &amp;&amp; c != '\n')
            c = getchar();
    }
    return r-1;//subtract 1 to get array index (zero indexed)
}

int main ( void )
{
    int c, k, i;
    char buffer[80], *myDynamicArray[25];
    puts(""Enter string"");
    for (k=0;k&lt;25;++k)
    {
        i=0;
        while((c = getchar()) != EOF &amp;&amp; c != '\n' &amp;&amp; i &lt; 79)
            buffer[i++] = c;
        if (i == 0)
            break;
        if (i == 79)
            while (c != EOF &amp;&amp; c != '\n')
                c = getchar();//clean buffer
        buffer[i] = '\0';
        myDynamicArray[k] = calloc(i, sizeof *myDynamicArray[k]);
        if (myDynamicArray[k] == NULL)
            exit(EXIT_FAILURE);
        strcpy(myDynamicArray[k], buffer);
    }
    printf(""Choose which string you'd like to see again [1-%d], press q to quit\n"", k);
    while ((c = get_key(k)) != -1)
        if (c != -2)
            printf(""String %d: %s\n"", c+1, myDynamicArray[c]);
        else
            printf(""input must be in the 1 - %d range\n"", k);
    for (i=0;i&lt;k;++i)
    {
        printf(""%s\n"", myDynamicArray[i]);
        free(myDynamicArray[i]);
    }
    printf(""Press any key to continue..."");
    getchar();
    return 0;
}
</code></pre>
",3
25461727,25461708,5,"<p>It will compile just fine. The product of the compilation however will produce undefined behavior, which means anything can happen. It can work, it can crash, it can summon pink unicorns to dance in front of your computer. It's undefined. </p>

<p>Fix the code, it's bad code no matter if it compiles or not.</p>

<p>On some compilers it may produce a warning and you can configure a compiler so it issues an error when there is a warning. So <em>maybe</em> with certain settings under certain compilers, it might not even compile.</p>
",3
25461732,25461708,3,"<p>The local variable expires after the function is exited. Add a static keyword and the compiler will stop complaining. The memory location of variable static int x will always be reserved.</p>

<pre><code>int *f1(void)
{
   static int x = 10;
   return &amp;x;
}
</code></pre>
",0
25461754,25461708,0,"<p>The scope of the variable <em>x</em> is local to the function <em>f1</em>. This means that when all the instructions of the <em>f1</em> will be executed <em>x</em> won't be accessible.</p>

<p>This is a really bad practice which will lead to undefined behaviour because the address to the <em>x</em> variable won't exist anymore.</p>

<p>If you need to modify a value using a function you can always pass a pointer as a parameter:</p>

<pre><code>void f1(int *val) {
    *val = 10;
}
</code></pre>
",1
25461882,25461708,1,"<p>compilation will work fine. but since it is a local variable and its scope will no more after the function. so whatever  memory it reference you will get in after function return but it will be free as   point of you operating system and it will allocate to some other variable whenever memory request come to OS. so it will create problem at run time not compile time.</p>
",0
31275777,31275627,0,"<p>For a time before the first departure time, or after the last departure time, it should be easy even for a beginner such as you. For the other, you need to calculate the middle between the departure times, and compare the entered time with that to find the closest departure time.</p>

<p>For example, lets take the two departure times <code>11:19 a.m.</code> and <code>12:47 p.m.</code> Halfway between those times is <code>12:03 p.m.</code> If the entered time is before (less than) 12:03 pm, then the closest departure time is 11:19 am, and if the entered time is after (larger than) 12:03 pm then the 12:47 pm departure time is closer.</p>

<p>My suggestion is that you make a structure, containing the departure and arrival times, and make an array of them for the specified departure and arrival times. Then make another array, containing information about the middle times. Something like</p>

<pre><code>struct times
{
    char *departure;
    char *arrival;
} times[] = {
    { ""8:00"", ""10:16"" },
    { ""9:43"", ""11:52"" },
    .
    .
    .
};

char *inbetween_times[] = {
     ""8:51"",  // Time between the first and second departure
    ""10:31"",  // Time between the second and third departure
    .
    .
    .
};
</code></pre>

<p>With the above system, and the above data, times before 8:51 is closest to the first departure, times between 8:51 and 10:31 is closest to the second, end so on.</p>

<p>I don't know it it's the best way, and it's most certainly isn't the only way, it's just the way that popped into my head first.</p>
",2
31275811,31275627,0,"<p>A common programming shindig is to compare the difference between two numbers. </p>

<pre><code>#include &lt;math.h&gt;
if(abs(value1 - value2) &lt; somethingYouCompareItTo)
</code></pre>

<p>That's the (mathematical) absolute difference between two numbers. ie, it removes negative values.  Slap a couple of those in a for-loop to compare it to all the values in the data structure and you've got yourself a <code>findClosestTime()</code> function. </p>

<p>Everyone starts at the beginning, good luck. </p>
",0
26170956,26156733,0,"<p>The answer depends on whether id is known at compile time.  For example:</p>

<pre><code>#include &lt;stdio.h&gt;

#define read_dr(id, result) \
   __asm__ ( \
      ""movq %%dr%c1, %0"" \
      : ""=r"" (result) \
      : ""i"" (id) \
      : ""cc"")

int main(int argc, char *argv[])
{
   long long a;
   read_dr(1, a);
   printf(""%lld\n"", a);
}
</code></pre>

<p>If at any time the compiler cannot resolve id to a constant, you'll get compile errors (impossible constraint).</p>

<p>Note that reading debug registers is a privileged instruction.  Also, this is 64bit code (a slightly fancier version would work for both 32 and 64bit).  Finally, while this can work as a macro, I doubt this will work as an actual function (except maybe a forceinline one).</p>
",0
34234053,34233890,5,"<p>No such limit is imposed by the C standard.</p>

<p>The C standard does require any conforming implementation to support <em>some</em> program that passes at least 127 arguments in a function call (see <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"">N1570</a> section 5.2.4.1), but that's neither an upper nor a lower bound for variadic functions; the call needn't be to a variadic function, and implementations are free to support more than 127 arguments. The section that defines <code>&lt;stdarg.h&gt;</code>, 7.16, doesn't mention any limits.</p>

<p>In practice, any limit is likely to be imposed by available resources, either at compile time (when compiling the call) or at run time (when executing it). </p>

<p>And simply due to common sense and market forces, compilers are likely to support arbitrarily long argument lists rather than imposing some fixed limit. Once you're required to support 127 arguments, it's probably easier to allocate any needed data structures dynamically than to use fixed-size structures. (The point of the translation limits in 5.2.4.1 is, in my opinion, to encourage compilers not to impose fixed limits at all.)</p>

<p>On the other hand, a conforming compiler <em>could</em> impose an unreasonable small limit, and a compiler for a very small embedded system might even have a valid reason to do so.</p>
",2
24094448,24094434,5,"<p><code>--</code> is the decrement operator. You can't apply the decrement operator to numeric constants, because it <em>changes</em> what it's applied to. That is</p>

<pre><code>--a;
</code></pre>

<p><em>changes</em> the value of <code>a</code>. So <code>--3</code> is invalid, you can't change a constant.</p>

<p>If you want to subtract a negative number, you need a space between the minus operator <code>-</code> and the negation operator <code>-</code>, or <code>()</code> around the thing being negated:</p>

<pre><code>a = -3 - -25;
b = -3 - -(-3);
</code></pre>

<p>Separately, note that <code>-(-3)</code> is a long-winded way to write <code>3</code>.</p>

<hr>

<p>In general, <em>spaces and blank lines are not the enemy</em>. Putting spaces around operators, and judicious use of blank lines, generally improves readability.</p>

<pre><code>#include&lt;stdio.h&gt;

int main()
{
    int a, b;

    a = -3 - -25;
    b = -3 - -(-3);
    printf(""a = %d, b = %d\n"", a, b);
    return 0;
}
</code></pre>
",0
24094452,24094434,0,"<p>Place some spaces between <code>-</code> sign and let the compiler know that you only want to use unary and binary <code>-</code>, not decrement operator <code>--</code>.   </p>

<pre><code>a= -3 - -25;
b= -3 - -(-3);  
</code></pre>

<p>Since <code>--</code> is decrement operator so <code>a= -3--25;</code> is not converted by compiler to <code>a= -3 - -25;</code></p>
",0
25466760,25466750,7,"<p>The value of <code>10^4</code> is 14 because the <code>^</code> is the XOR operator.</p>

<p>You can't simply write 1E4 which is 10<sup>4</sup> because that's a floating point constant and array bounds must be integer constants.  You could cast it (<code>char string[(int)1E4];</code>), but why not just write clearly and concisely what you mean: <code>char string[10000];</code> as you did in the second example.</p>

<p>There's an argument that you should write:</p>

<pre><code>if (scanf(""%9999s"", string) != 1)
    ¡­handle input error or EOF¡­
</code></pre>

<p>This protects you from a buffer overflow.</p>
",8
25466783,25466750,4,"<pre><code>char string[10^4];
</code></pre>

<p>The above is an array of length 14, because <code>^</code> is bitwise-exclusive-or, not power.<br>
All else is the same as for the second case, though with much lower ceiling.</p>

<pre><code>char string[10000];
scanf(""%s"", string); 
</code></pre>

<p>The above has 3 points-of-failure:</p>

<ol>
<li>10000 bytes might be too much (just about always on the stack, which is often severely limited. Consider heap-allocation with <code>malloc()</code>, or static buffers).</li>
<li>The input might contain a token more that 9999 bytes long (+1 for terminator).</li>
<li>You do not check for input-failure, but will probably blithely assume success.</li>
</ol>
",6
34245616,34245485,4,"<p>From the C11 standard draft N1570, ¡ì6.3.1.1.2:</p>

<blockquote>
  <p>If an <code>int</code> can represent all values of the original type (as
  restricted by the width, for a bit-field), <strong>the value is converted to
  an</strong> <code>int</code>; otherwise, it is converted to an <code>unsigned int</code>. These are
  called the <strong>integer promotions</strong>.<sup>58)</sup> All other types are unchanged by the
  integer promotions.<br>
  [...]<br>
  <sup>58)</sup> The integer promotions are [...] as part of the usual
  arithmetic conversions, to certain argument expressions, to the
  operands of the unary <code>+</code>, <code>-</code>, and <code>~</code> operators, and to both operands of
  the shift operators, as specified by their respective subclauses.</p>
</blockquote>

<p>In short, every expression with a type smaller than <code>int</code> or <code>unsigned int</code> is converted to <code>int</code> or to <code>unsigned int</code>, respectively.<br>
An <code>int</code> has to be <strong>at least 16 bits wide</strong>, so definitely no wrap-around will occur and your expression will yield <code>256</code>.</p>
",1
25484457,16410340,1,"<p>In C/C++ a structures are used as data pack. It doesn't provide any data encapsulation or data hiding features (C++ case is an exception due to its semantic similarity with classes).</p>

<p>Because of the alignment requirements of various data types, every member of structure should be naturally aligned. The members of structure allocated sequentially increasing order.</p>
",0
26144568,26144227,3,"<p>When you <code>getc</code> the input, it's important to note that the user has put in more than one character: at the very least, the <code>stdin</code> contains 2 chars:</p>

<pre><code>2\n
</code></pre>

<p>when <code>getc</code> gets the ""2"" the user has put in, the trailing <code>\n</code> character is still in the buffer, so you'll have to clear it. The simplest way here to do so would be to add this:</p>

<pre><code>if (*choice == '2')
    puts(""Hi"");
while (*choice != '\n' &amp;&amp; *choice != EOF)//EOF just in case
    *choice = getc(stdin);
</code></pre>

<p>That should fix it</p>

<p><em>For completeness:</em><br>
Note that <code>getc</code> returns an int, not a <code>char</code>. Make sure to compile with <code>-Wall -pedantic</code> flags, and always check the return type of the functions you use.</p>

<p>It is tempting to clear the input buffer using <code>fflush(stdin);</code>, and on some systems, this will work. However: <strong><em>This behavior is undefined: the standard clearly states that <code>fflush</code> is meant to be used on update/output buffers, not input buffers</em></strong>:</p>

<blockquote>
  <p>C11 7.21.5.2 The fflush function, fflush works only with output/update stream, not input stream</p>
</blockquote>

<p>However, some implementations (for example <a href=""http://msdn.microsoft.com/en-us/library/9yky46tz.aspx"" rel=""nofollow"">Microsoft</a>) do support <code>fflush(stdin);</code> as an extension. Relying on it, though, goes against the philosophy behind C. C was meant to be portable, and by sticking to the standard, you are assured your code is portable. Relying on a specific extension takes away this advantage.</p>
",3
26144863,26144227,1,"<p>The reason why this is happening is because stdin is buffered. </p>

<p>When you get to the line of code *choice = getc(stdin); no matter how many characters you type, getc(stdin) will only retrieve the first character. So if you type ""foo"" it will retrieve 'f' and set *choice to 'f'. The characters ""oo"" are still in the input buffer. Moreover, the carriage return character that resulted from you striking the return key is also in the input buffer. Therefore since the buffer isn't empty, the next time the loop executes, rather than waiting for you to enter something, getc(stdin); will immediately return the next character in the buffer. The function getc(stdin) will continue to immediately return the next character in the buffer until the buffer is empty. Therefore, in general it will prompt you N number of times when you enter a string of length N.</p>

<p>You can get around this by flushing the buffer with fflush(stdin); immediately after the line *choice = getc(stdin);</p>

<p>EDIT: Apparently someone else is saying not to use fflush(stdin); Go with what he says. </p>
",3
26146296,26144227,2,"<p>What seems to be a very simple problem is actually pretty complicated. The root of the problem is that terminals operate in two different modes: raw and cooked. Cooked mode, which is the default, means that the terminal does not read characters, it reads lines. So, your program never receives any input at all unless a whole line is entered (or an end of file character is received). The way the terminal recognizes an end of line is by receiving a newline character (0x0A) which can be caused by pressing the Enter key. To make it even more confusing, on a Windows machine pressing Enter causes TWO characters to be generated, (0x0D and 0x0A).</p>

<p>So, your basic problem is that you want a single-character interface, but your terminal is operating in a line-oriented (cooked) mode. </p>

<p>The correct solution is to switch the terminal to raw mode so your program can receive characters <em>as the user types them</em>. Also, I would recommend the use of <code>getchar()</code> rather than <code>getc()</code> in this usage. The difference is that getc() takes a file descriptor as an argument, so it can read from any stream. The <code>getchar()</code> function only reads from standard input, which is what you want. Therefore, it is a more specific choice. After your program is done it should switch the terminal back to the way it was, so it needs to save the current terminal state before modifying it.</p>

<p>Also, you should handle the case that the EOF (0x04) is received by the terminal which the user can do by pressing CTRL-D.</p>

<p>Here is the complete program that does these things:</p>

<pre><code>#include    &lt;stdio.h&gt;
#include    &lt;termios.h&gt;
main(){
    tty_mode(0);                /* save current terminal mode */
    set_terminal_raw();         /* set -icanon, -echo   */
    interact();                 /* interact with user */
    tty_mode(1);                /* restore terminal to the way it was */
    return 0;                   /* 0 means the program exited normally */
}

void interact(){
    while(1){
        printf( ""\nPlease enter a choice: \n1)quit\n2)Something\n"" );
        switch( getchar() ){
            case 'q': return;
            case '2': {
               printf( ""Hi\n"" );
               break;
            }
            case EOF: return;
        }
    }
}

/* put file descriptor 0 into chr-by-chr mode and noecho mode */
set_terminal_raw(){
    struct  termios ttystate;
    tcgetattr( 0, &amp;ttystate);               /* read current setting */
    ttystate.c_lflag          &amp;= ~ICANON;   /* no buffering     */
    ttystate.c_lflag          &amp;= ~ECHO;     /* no echo either   */
    ttystate.c_cc[VMIN]        =  1;        /* get 1 char at a time */
    tcsetattr( 0 , TCSANOW, &amp;ttystate);     /* install settings */
}

/* 0 =&gt; save current mode  1 =&gt; restore mode */
tty_mode( int operation ){
    static struct termios original_mode;
    if ( operation == 0 )
        tcgetattr( 0, &amp;original_mode );
    else
        return tcsetattr( 0, TCSANOW, &amp;original_mode ); 
}
</code></pre>

<p>As you can see, what seems to be a pretty simple problem is quite tricky to do properly.</p>

<p>A book I can highly recommend to navigate these matters is ""Understanding Unix/Linux Programming"" by Bruce Molay. Chapter 6 explains all the things above in detail.</p>
",1
21565976,21565936,2,"<pre><code>double f2(int x){ return 1.0/x; }
</code></pre>
",0
21566009,21565936,2,"<p>Your code doesn't do any part of what you specify...</p>

<p>There is no reason to use scanf. You also use an int to store a floating point value. You also don't return the calculated value.</p>

<p>Here is your function, expanded for clarity:</p>

<pre><code>double f2(int x){
    double val = 1.0 / x;
    return val;
}
</code></pre>

<p>One line:</p>

<pre><code>double f2(int x){ return 1.0 / x; }
</code></pre>
",0
33027232,33026938,2,"<p>I am not sure about the usage of the mmap function you are doing since mmap  returns a pointer. </p>

<ul>
<li><p>Regarding conversion you can basically convert any variable to anything using a cast, however it is your responsibility to verify that this will work for example:</p>

<pre><code>int i;
double d;    
d = 42.3;
i = (int)d;
printf(""i = %d"", i);
</code></pre></li>
</ul>

<p>Output will be 42, without the cast <code>(int)</code> some compilers would probably complain and warn you that you will lose floating precision.</p>

<ul>
<li>About the why of all these different sizes, first thing <code>size_t</code> is meant to represent a size so you can grossly think of it as an <code>unsigned int</code>, regarding why not use a <code>unsigned int</code> rather than a typedef'ed ""size_t"", see this post <a href=""https://stackoverflow.com/a/131833/2308258"">unsigned int vs size_t</a>.</li>
</ul>
",0
22865474,22865412,0,"<p>a and b will both point to the string <code>""olleh""</code></p>
",0
22865502,22865412,0,"<p>strcpy copies the string, by looking at the location of the pointer and copying characters until it copies a null terminator. a and b will point to different strings with the same contents.</p>

<p>a = b is pointer assignment, so a and b will then both point to the SAME memory containing the string ""olleh"".</p>
",0
22866130,22865412,0,"<pre><code>{
    char *a=""hello"";
    char *b=""olleh"";

    printf(""\n  Before a=b \n"");
    printf(""a: %d\nb: %d \n\n"",a,b);

    a=b;

    printf(""\n  After a=b \n"");
    printf(""a: %d\nb: %d "",a,b);

    return 0;
}
</code></pre>

<p>The above program is self explanatory. Before the assignment (a=b), a and b are pointing to two different strings, hence they will print two different addresses. But after the assignment (a=b), the contents of a and b will be same, because they point to the same string i.e., ""hello"".</p>
",0
21024861,21024717,2,"<p>An automatic variable resides on the (function-call) stack. Thus, when the next function is called, (<code>printf</code> in this example), the stack contents get over written. Hence the unpredictable errors.</p>

<p>Whereas, static variables get stored in data segment. (Very similar to global variables, as far as storage is considered.)</p>

<p>Hence static variables are not overwritten during the next function call. Hence it works fine.</p>
",0
21024946,21024717,0,"<pre><code>char buffer[30];
</code></pre>

<p>That line allocates the space for buffer on the stack.  The storage goes away when the function exits and will be overwritten by the automatic variables declared in printf.  </p>

<pre><code>static char buffer[30];
</code></pre>

<p>causes the buffer to be allocated from the data segment of the program, so it won't get overwritten when you call printf.  However, as it only gets allocated once, each call to <code>fun</code> overwrites the previous value (not a problem for you because you are strcpy'ing a constant string into it. </p>
",0
21026030,21024717,0,"<p>In the code</p>

<pre><code>char *fun( ){    
  char buffer[30] ;
  strcpy ( buffer, ""RAM - Rarely Adequate Memory"") ;
  return ( buffer ) ;
}
</code></pre>

<p>the <code>buffer</code> array only exists for the lifetime of the function itself; once the function exits, the memory that was used by <code>buffer</code> is made available for other threads or processes to use.  This means that in the time between the execution of the statements</p>

<pre><code>s = fun( ) ;
printf ( ""%s"", s ) ;
</code></pre>

<p>another thread or process could have overwritten the memory that <code>buffer</code> was using.  </p>

<p>If you declare <code>buffer</code> as <code>static</code>, such as</p>

<pre><code>char *fun( ){    
  static char buffer[30] ;
  strcpy ( buffer, ""RAM - Rarely Adequate Memory"") ;
  return ( buffer ) ;
}
</code></pre>

<p>then the memory used by <code>buffer</code> is allocated at program startup and held until the program terminates, meaning nothing else can overwrite it.  This comes at a cost, however; <code>fun</code> is no longer <a href=""http://en.wikipedia.org/wiki/Reentrancy_%28computing%29"" rel=""nofollow"">re-entrant</a>.  As the function is currently written, it's not a problem, since it returns the same value for any invocation.  However, if <code>fun</code> were meant to return a different string for different circumstances, you could run into problems if one call is interrupted by another call.  </p>

<p>A third option is to allocate the memory for <code>buffer</code> dynamically:</p>

<pre><code>char *fun( ){    
  char *buffer = malloc( sizeof *buffer * 30 ) ;
  if ( buffer )
    strcpy ( buffer, ""RAM - Rarely Adequate Memory"") ;
  return ( buffer ) ;
}
</code></pre>

<p>This solves the first two problems; the contents of the buffer are preserved after the function exits, and you're not limited to a single, static buffer.  But since there's no such thing as a free lunch, now the calling function has to make sure to release that memory when it's finished with it:</p>

<pre><code>int main(){    
  char *s ;
  char *fun( ) ;
  s = fun( ) ;
  printf ( ""%s"", s ) ;
  free( s );
}
</code></pre>
",0
21024755,21024717,5,"<p>A <code>static</code> variable exists for the entire run-time of your program, unlike a normal ""automatic"" variable that only exists as long as its parent scope exists.</p>

<p>If you do return a pointer to a non-<code>static</code> variable, that means the caller gets a reference to memory that, when the called function has returned, no longer holds what it did inside the function. That memory cannot validly be accessed by the caller, and doing so will invoke undefined behavior.</p>
",2
33818751,33818728,4,"<p>if you want the size of a struct use the <code>sizeof</code> operator.</p>

<p>e.g.</p>

<pre><code>size_t struct_size = sizeof(line);
</code></pre>

<p>it returns the size of the struct in bytes. Note that sizeof(char) == 1 always, so technically byte does not always mean 8 bits.</p>

<p>From <a href=""https://www.seebs.net/c/c_tcn4e.html"" rel=""nofollow"">C:TCN, ""Page 348"" at the bottom of the page</a> :-</p>

<blockquote>
  <p>It is in theory possible for a machine to have char be larger than 8
  bits, though it's not very common for hosted environments (basically,
  desktop computers and the like -- the only environments required to
  even have the  functions to begin with). </p>
  
  <p>On such a machine,
  contrary to many people's expectations, <strong><em>sizeof(char) is still 1</em></strong>; what
  changes is the value <strong>CHAR_BIT</strong>. The relevance of this is that, on such
  a machine, it is possible for int to still have its required range,
  but to be the same size as a char. </p>
  
  <p>Thus, on such a machine, there
  might exist at least one value of unsigned char such that, converted
  to int, it was a negative value, and compared equal to EOF. However,
  to the best of my knowledge, all such systems that have provided the
  getchar() function and related functions have ensured that, in fact,
  the EOF value is distinct from any value which can actually be read
  from a file. For instance, char could be a 32-bit type, but you would
  still only see values 0-255 when reading ""characters"" from a file.</p>
</blockquote>

<p>From WG14 n1256 - section 6.5.3.4:</p>

<blockquote>
  <p>The sizeof operator yields the size <strong>(in bytes)</strong> of its operand ... When applied to an operand that has type , unsigned char, or signed char,
  (or a qualified version thereof) the result is 1.</p>
</blockquote>
",3
33818790,33818728,0,"<p>Just use sizeof. Here's a program to tell you the size of line:</p>

<pre><code>#include &lt;stdio.h&gt;

typedef struct {
    char valid;
    char tag;
    char block[4];
} line;

int main(void) {
    printf(""%zu\n"", sizeof(line));
    return 0;
}
</code></pre>
",0
33820416,33818728,1,"<p>It is 6. Simple call to sizeof will confirm this.
Is this the question or is there any other question related to padding of structures?</p>
",0
25525633,25525381,2,"<p>A <code>#</code> at the start of a line introduces a preprocessing directive. Preprocessing is conceptually an earlier stage of translation than compilation, which is why it uses an easily-recognisable syntax.</p>

<p>If the <code>#</code> is followed by <em>anything other than</em> <code>include</code>, <code>define</code>, <code>undef</code>, <code>line</code>, <code>error</code> or <code>pragma</code>, then it is a <em>non-directive</em> (6.10p1), and is ignored.</p>

<p>This means that <code>#</code> at the start of a line is a simple way for the compiler to pass information between stages of translation; here it is being used to pass source file and line number information.</p>
",0
25525643,25525381,8,"<p>This looks like the output of the preprocessor. The line</p>

<pre><code># 41 ""stdio.h""
</code></pre>

<p>can be interpreted like:</p>

<ul>
<li>41 has the meaning:  </li>
</ul>

<blockquote>
  <p>It specifies the line number which should be reported for the following line of input. Subsequent lines are counted from linenum.</p>
</blockquote>

<ul>
<li><code>""stdio.h""</code> is just the filename from which the lines are taken.</li>
</ul>

<blockquote>
  <p>The following line and all subsequent lines are
  reported to come from the file it specifies, until something else happens to
  change that. filename is interpreted according to the normal rules for a string
  constant: backslash escapes are interpreted.</p>
</blockquote>

<p>And all this information is taken from <a href=""https://gcc.gnu.org/onlinedocs/cpp/Line-Control.html#Line-Control"" rel=""nofollow"">https://gcc.gnu.org/onlinedocs/cpp/Line-Control.html#Line-Control</a> and <a href=""https://gcc.gnu.org/onlinedocs/cpp/Preprocessor-Output.html#Preprocessor-Output"" rel=""nofollow"">https://gcc.gnu.org/onlinedocs/cpp/Preprocessor-Output.html#Preprocessor-Output</a> </p>

<p>For the single <code>#</code>:</p>

<blockquote>
  <p>The null directive consists of a ¡®#¡¯ followed by a newline, with only whitespace (including comments) in between. A null directive is understood as a preprocessing directive but has no effect on the preprocessor output. The primary significance of the existence of the null directive is that an input line consisting of just a ¡®#¡¯ will produce no output, rather than a line of output containing just a ¡®#¡¯. Supposedly some old C programs contain such lines.</p>
</blockquote>

<p>taken from <a href=""https://gcc.gnu.org/onlinedocs/cpp/Other-Directives.html#Other-Directives"" rel=""nofollow"">https://gcc.gnu.org/onlinedocs/cpp/Other-Directives.html#Other-Directives</a></p>
",0
26208349,26208260,1,"<p>The appropriate way to do that is by separating your code into modules, and defining those globals as static, which will make them only module visible and will not export their symbol outside. You can then add a getter function to expose their value, without exposing them to modifications from outside the module.</p>
",1
22107009,22106988,1,"<p>You don't need that extra</p>

<p><code>z++;</code></p>

<p>sentence after the loop. This is because <code>z</code> is incremented in the last iteration, and after that the condition <code>z&lt;strlen(str)</code> fails, when z == strlen(str) is true. </p>

<p>That extra letter you are getting:</p>

<p>Original: If</p>

<p>Copy: if<code>u</code></p>

<p>Is just garbage in the memory. Because if you increment <code>z</code> after the loop, the value is not within the array's dimension anymore.</p>

<p>So, I believe this should work:</p>

<pre><code>void process(char * str){

  int z = 0;
  char * copy = malloc(sizeof(char)*(strlen(str)+1));

  printf(""Original: %s\n"", str);
  for(z = 0; z&lt;strlen(str);z++){
    char tempone = tolower(str[z]);
    copy[z] = tempone;
  }

  copy[z] = '\0';
  printf(""Copy: %s\n"", copy);

 }
</code></pre>

<p>Assume the simplest examples:</p>

<p>Original: I</p>

<p>Copy: i</p>

<ol>
<li><p>You will do a malloc(sizeof(char)*(1+1)). Noticed that <a href=""http://www.cplusplus.com/reference/cstring/strlen/"" rel=""nofollow"">strlen</a> does not include the null character.</p></li>
<li><p><code>for(z = 0; z &lt; 1; z++)</code> -> This will be executed once. Because when trying to iterate for the second time, you will increment <code>z</code> from <code>0</code> to <code>1</code>, so the condition <code>z &lt; 1</code> will be <code>1 &lt; 1</code> which is false.</p></li>
<li><p>Outside the loop you want to put a <code>'\0'</code> in the <code>copy[1]</code>, not in <code>copy[2]</code>. This is why you really don't need that <code>z++</code> outside the loop.</p></li>
</ol>

<p>Hope it helps.</p>
",3
22107267,22106988,-1,"<p>I figured out the solution. I used strcpy before the for loop, as seen here. </p>

<pre><code>  int z = 0;
char * copy = malloc(sizeof(char)*(strlen(str)+1));
strcpy(copy, str);
for(z = 0; z&lt;strlen(str);z++){
    *(copy+z) = tolower(*(copy+z));
}
</code></pre>

<p>Why this worked and the other code didn't, I have no idea. </p>
",1
29198852,29198653,1,"<p>You are using your <code>cir_user_input</code> in your <code>getRadius</code>function like a variable/pointer, although it is a function. It is surprising that this works without any warnings or errors (would be interesting to know what compiler you are using).</p>

<p>I think what you actually intended was something like this, i.e., a call to <code>cir_user_input</code> which stores the result in a float variable.</p>

<pre><code>double getRadius()
{
    float diameter = cir_user_input(); //float type; not static (see below)
    double radius = diameter / 2;
    return radius;
}
</code></pre>

<p>Furthermore, the switch statement in your <code>main</code> function only calls the user input function <code>cir_user_input</code>, but none of the calculation routines (<code>case 1</code>). Since the return value of the function is not store, it cannot be used later.</p>

<p>In addition, you have seem to be confused about the use of the <code>static</code> key word:</p>

<blockquote>
  <p>This problem occured while trying to get rid of all global variables in my program.</p>
</blockquote>

<p>When you use the <code>static</code> key word to declare variables inside a function, they retain their values throughout function calls, i.e., they are effectively global.</p>

<p>Conversely, if you use the <code>static</code> key word for a global variable/function etc., it is only visible inside the file you specified it in. For beginners, this is often confusing since the key word is written in exactly the same way, see <a href=""https://stackoverflow.com/questions/572547/what-does-static-mean-in-a-c-program"">What does &quot;static&quot; mean?</a>.</p>

<p>Best regards
Andreas</p>
",2
29200212,29198653,0,"<pre><code>here is a good implementation of the main() function

#include &lt;stdio.h&gt;

#include ""menu/menu.h""
#include ""circle/circlemenu.h""
#include ""input/input.h""

int main(void)
{
    int done = 0;
    while( !done )
    {
        menu();
        switch(menu_user_input())
        {

            case 0:
                done = 1;
                break;

            case 1:
                info_top();
                cir_user_input();
                info_bottom();
                break;

            case 2:
                system(""cls"");
                break;

            case 3:
                system(""cls"");
                break;

            case 8:
                system(""cls"");
                break;

            case 9:
                system(""cls"");
                break;

            default:
                system(""cls"");
                printf(""\n **Wrong choice try again...**\n"");
                break;
        } // end switch

    } // end while
    return 0;
} // end function: main
</code></pre>
",0
29176893,29176826,1,"<p>You are currently using global variables, which is (almost) always a bad design.  Your current calculation function:</p>

<pre><code>void circle_functions()
{
  radius = diameter / 2;
  surface = PI * (radius * radius);
  outline = 2 * PI * radius;
}
</code></pre>

<p>Much better would be to pass in the needed inputs and return the result:</p>

<pre><code>double circle_functions(double diameter)
{
  double radius = diameter / 2;
  double surface = PI * (radius * radius);
  double outline = 2 * PI * radius;
  return outline;
}
</code></pre>
",2
29176930,29176826,0,"<p>The problem is in the following line of code:</p>

<pre><code>cir_user_input();
</code></pre>

<p>...in which you're ignoring the return value of cir_user_input.</p>

<p>Instead you should be using:</p>

<pre><code>diameter = cir_user_input();
</code></pre>

<p>...because the other functions expect the global variables to be set.</p>

<p>However, you are overusing global variables. I would consider restructuring your code to not use global variables.</p>
",1
24364815,24364737,0,"<p>If you compare <code>C</code> with <code>java</code>, C is closer to the hardware, because java does not directly operate on the system. Java is executed on the <a href=""http://de.wikipedia.org/wiki/Java_Virtual_Machine"" rel=""nofollow"">java virtual machine</a>, which then operates on the system. </p>

<p>C does not have such a layer between it and the system and is therefore closer to the harware.</p>
",1
24364820,24364737,0,"<p>It does not provide abstractions to protect you from the specifics of the hardware and platform, such as memory layout and system APIs. Thus is it ""closer to the hardware"" in the sense that there is less code between your code and the hardware.</p>
",0
24364923,24364737,5,"<p>There's no virtual machine interpreting C executable code.  It's compiled into machine instructions, specific to a particular CPU, that are linked together and run on your hardware.</p>

<p>Another reason is the design of the language itself.  When Kernighan and Ritchie were developing C for DEC hardware, they were very mindful of actual hardware features like registers, bit shifting, etc.  There wasn't a layer of abstraction between their thinking and the machine for which they were writing the language.</p>
",1
24368361,24364737,0,"<p>A <a href=""http://cm.bell-labs.com/who/dmr/chist.html"" rel=""nofollow"">definitive answer</a>:</p>

<blockquote>
BCPL, B, and C all fit firmly in the traditional procedural family typified by Fortran and Algol 60...<strong>They are `close to the machine' in that the abstractions they introduce are readily grounded in the concrete data types and operations supplied by conventional computers</strong>, and they rely on library routines for input-output and other interactions with an operating system. With less success, they also use library procedures to specify interesting control constructs such as coroutines and procedure closures. At the same time, their abstractions lie at a sufficiently high level that, with care, portability between machines can be achieved.</blockquote>

<p>For a specific example, a C <code>int</code> will most likely map to an object of the native word size (16-, 32-, 64-, or 128-bit), and operations on that <code>int</code> object will be performed using native opcodes (ADD, MUL, etc.).  </p>

<p>Contrast that with languages like Lisp or Haskell that use <em>arbitrary-precision</em> arithmetic; integers in those languages are often represented by arrays of digits, and operations on them are performed almost exclusively in software.  </p>

<p>In this respect, C is ""close to the hardware"" in that it's taking advantage of the native infrastructure for integer operations.  </p>

<p>All things being equal, integer arithmetic in C will be a <em>lot</em> faster since it's taking advantage of the native hardware, but it cannot represent or operate on arbitrarily large values.  </p>
",0
25518417,25518376,2,"<p>It is not giving wrong output. The size of int on your system would be 4, the size of a void pointer also 4, and while char can usually be 8 bits long, the struct itself will not be 9 bytes long, as most systems are at least 32 bit, so the compiler is ""padding"" them to be multiples of 4 bytes.
A void pointer is just a pointer that can point to anything.</p>
",0
27536073,27536017,8,"<p>It is sometimes used for implementing ""structured goto"". Inside such <code>do-while</code> region <code>break</code> and <code>continue</code> statements will pass control to the end of the region and continue execution of the code that follows such ""cycle"".</p>

<p>Another use, already mentioned in the comments, is to work as a compound statement envelope inside macros. The unique feature of <code>do-while</code> is that it requires a <code>;</code> at the end. This allows it to work as a compound statement envelope that will ""consume"" the following <code>;</code>. That feature allows one to write function-like macros with allow the caller to safely place a <code>;</code> after them (see here: <a href=""https://stackoverflow.com/questions/2381300/what-does-do-while-0-do-exactly-in-kernel-code"">What does &quot;do { ... } while (0)&quot; do exactly in kernel code?</a>)</p>
",3
27536088,27536017,1,"<p>One example od such thing is to have conditinal break inside this ""loop"". You can stop executing the rest of code - some sofisticated way to avoid infamous ""goto"".</p>
",0
27536108,27536017,1,"<p>It is a flow control style that allows for skipping all the remaining code in the code block of the <code>do { code block } while( false );</code>. Very useful when you want to stop processing the remaining code in the code block, but still perform the rest of the code after the <code>while(false);</code>. This is a common pattern allowing a function to clean up after an error, for instance.</p>

<p>So in other words: it is a way to ""hide"" <code>goto</code> functionality.</p>
",0
25466972,25466899,2,"<p>Your code will give a warning, like:</p>

<blockquote>
  <p>main.c:5:12: warning: initialization makes pointer from integer
  without a cast [enabled by default]</p>
</blockquote>

<p>since you try to assign an integer to a pointer without a cast. Even with a cast, it will rarely be what you want, a pointer to the address you gave.</p>

<p>I will provide an example, were I declare a variable <code>a</code> initialized with 5 and then, assign its address to a pointer <code>p</code>.</p>

<p>Also, notice that C, unlike C++ and Java doesn't provide a <code>+</code> operator for strings. You have to use <code>string.h</code> library for this kind of operations.</p>

<p>[EDIT] (see comments, thanks to Deduplicator)</p>

<pre><code>#include &lt;stdio.h&gt;

int main() 
{
    int a = 5;
    // Assign the address of 'a' to the pointer 'p'.
    int *p = &amp;a;
    // Now p points to variable 'a', thus 5.
    // The value of 'p' is the address of the variable 'a'.

    char const *str = ""msg"";

    // print the string 'str' and the number, that 'p'
    // points to. Since `p` is of type `int*`, we expect
    // it to point to an integer, thus we use %d in the
    // printf().
    printf(""string is: %s%d"", str, *p);

  return 0;
}
</code></pre>

<p>Output:</p>

<blockquote>
  <p>string is: msg5</p>
</blockquote>
",7
27562798,27562750,0,"<p>Yes you can do. While you are including that header file it will inherit all the things from that header. So you can use that Macro.</p>
",0
27562823,27562750,0,"<p>Yes. Including a file is as the same as if you copy and pasted the contents of the header file at the exact location as the <code>#include</code> directive.</p>
",0
27562898,27562750,1,"<p>Yes you can do that.</p>

<p>An include works as follows:</p>

<p>imagin you have a file.</p>

<pre><code>header.h
</code></pre>

<p>content:</p>

<pre><code> void HappyMakerPrototype();
 void AnotherPrototype();
</code></pre>

<p>and a source file</p>

<pre><code>src.c
</code></pre>

<p>content:</p>

<pre><code>void dummydec();
#include ""header.h""

void main ()
{
    return;
}
</code></pre>

<p>In the first step of compilation it will run through the preprocessing.</p>

<p>Here the include line just gets replaced by all the content of your included file.</p>

<p>So that If you would request the output for the preprocessed file it would look like:</p>

<p>(in gcc and clang compiler you can request the preprocessed file with parameter <code>-E</code> I guess that will help you understanding)</p>

<pre><code>void dummydec();
void HappyMakerPrototype();
void AnotherPrototype();

void main ()
{
    return;
}
</code></pre>
",10
22436551,22436451,2,"<p>First, change <code>2^Nitems</code> to <code>1&lt;&lt;Nitems</code>.</p>

<p>Then, reconsider the <code>if (((1&lt;&lt;Nitems) % 1000) == 0)</code> condition.</p>

<p>That's because no power of 2 is an integer multiple of 1000 (i.e. divisible by 1000).</p>

<p>Perhaps something like <code>if ((Nitems % 4) == 0)</code> would be more suitable for your needs.</p>

<p>BTW, looking into your question again, it doesn't seem that you are changing the value of <code>Nitems</code> anywhere within your code. In fact, you are not even initializing it, so your intentions here are not clear!</p>
",1
28150320,28129178,0,"<p>This issue is often the result of undefined behavior.  In this specific instance, there was an implicit function declaration (a header file hadn't been included elsewhere in the program) which caused UB, and resulted in this bug.</p>
",0
22444595,22444541,4,"<p>Won't <code>(int) floor(longtitude) / 100</code> do ?</p>

<p>It's in <code>math.h</code>. Link it using <code>-lm</code>, like this:</p>

<p><code>gcc program.c -o program -lm</code></p>

<hr>

<p><strong>EDIT</strong></p>

<p>As mentioned  in the comments below, <code>floor()</code> is indeed not needed in this case.</p>

<p>A simple cast to <code>int</code> and fixing the sign as you want it, will do.</p>
",4
22444754,22444541,3,"<p>Rather just use <code>(int) longitude / 100</code> <em>without the <code>floor</code></em> if you want to obtain the digits before the decimal point, excluding the first two; accurately for both positive and negative values.</p>

<p><code>(int) floor( longitude ) / 100</code> would result in <code>-10</code> for <code>longitude = -999.36</code>, for example.</p>

<p>If you want positive outcome strictly, then use if conditions or a <a href=""http://en.m.wikipedia.org/wiki/%3F%3a#C"" rel=""nofollow"">ternary operator</a> like this:</p>

<pre><code>( longitude &gt; 0 ) ? (int) longitude / 100 : (int) longitude / -100
</code></pre>
",0
22445005,22444541,1,"<p>Everyone is making this too complicated. <code>int degrees = longitude / 100;</code> will suffice.</p>

<p>Do not use <code>floor</code> because it will cause negative values to be rounded further from zero. The default rounding mode when assigning floating-point values to integer variables in C is toward zero, also known as truncation, or throwing out the fraction.</p>

<p>If the <code>nn.nnnn</code> digits were fractional degrees, then one could argue that the floating-point division <code>/ 100</code> could cause rounding to the next degree due to imprecision. But this is impossible because <code>nn.nnnn</code> stores minutes, which max out at 60.</p>

<p>If you need to separate the sign from the magnitude, use <code>abs</code> as normal. Do not do this at the same time as you are doing something else, for heaven's sake.</p>

<p>Just keep it simple.</p>
",1
27175437,27175342,0,"<pre><code>while ((to[i] = from[i]) != '\0')
</code></pre>

<p>Look at parenthesis, first from[i] is getting assigned to to[i], then result of will be compared to '\0'(0).</p>
",0
25443668,25443585,0,"<p>You need <code>-&gt;</code> instead <code>.</code> because of structure pointer and remove <code>*</code> before it.</p>

<p>it should be </p>

<pre><code>int xx = dotyk-&gt;x;
int yy = dotyk-&gt;y;
</code></pre>
",0
25443949,25443585,0,"<p>Jayesh is right with his answer, but to clarify things I think it's important that you know the difference between your code and his answer.</p>

<p>Your problem is you assumed that * operator has higher precedence than <strong><em>"".""</em></strong>. And that's wrong assumption.</p>

<p>If you put (*dotyk).y it woult work as fine as ->.</p>

<p><strong><em>""->""</em></strong> is just a shortcut for (*something).member.</p>
",0
25445326,25443585,0,"<p>The variable <code>dotyk</code> is a <code>Coordinate</code> (which is a typedef of a struct) pointer.
Now, when you try to access your variable variables (the variables that are in that structure) you did so:</p>

<pre><code>int yy = *dotyk.y;
</code></pre>

<p>The problem is that as there are mathmatic operators with order of doing each (<code>*</code> and <code>/</code> before <code>+</code> and `- for example) so there is an order in C operators.</p>

<p>In C, <code>.</code> goes before <code>*</code> so what you are doing is actually calling a variable y in the address of the pointer ITSELF (<code>dotyk</code>) and not the address of WHERE IT IS POINTING TO (the structure).</p>

<p>There are two solution:</p>

<ol>
<li><p>Use brackets.</p>

<p>int yy = *dotyk.y;
turns to</p>

<p>int yy = (*dotyk).y;
so that you'll mention that you want the operator <code>*</code> to be performed first so the Y variable request would be performed on the content of the pointer (where it is pointing to) and not the pointer itself.</p></li>
<li><p>Use <code>-&gt;</code> operator.</p></li>
</ol>

<p>The <code>-&gt;</code> operator is very useful when it comes to structure pointers.</p>

<p>Instead of writing <code>int yy = *dotyk.y;</code> you would just write <code>int yy = dotyk-&gt;y;</code> and that would say something like ""Hey, I want you to treat <code>dotyk</code> as a pointer and lead me to the Y variable that can be found where it is pointing towards"".</p>

<p>Hope I've helped.</p>
",0
34185423,34182301,1,"<p>Check your status values:</p>

<pre><code>rv = loadFile(&amp;board, filename);
if (rv == -1) {
  perror(""Error opening file"");
  return 1;
}
</code></pre>

<p>This should (hopefully) give you an error message you can troubleshoot further. Using a <code>const char *</code> as an argument to <code>fopen()</code> should be OK.</p>
",0
34185290,34182301,2,"<p>Following many comments with suggestions, I have seen strange things when a constant char literal is passed:</p>

<pre><code>#define NAME ""name""
char* filename = NAME;
</code></pre>

<p>This assigns a pointer to a constant char literal to <code>filename</code>. Please try:</p>

<pre><code>#define NAME ""name""
char filename[] = NAME;
</code></pre>
",2
21033328,21032153,1,"<p>In <code>case 1:</code> you are <code>fclose</code>-ing every time you loop which means that after the first loop it will close the file then when it tries to <code>feof</code> and <code>fscanf</code> in the next loop the program will fail.</p>
",0
26221906,26221491,2,"<p>The core C language only supports integers of a definite size.  The stock facility for converting decimal (text) numbers to binary (machine) numbers is the <a href=""http://linux.die.net/man/3/strtol"" rel=""nofollow""><code>strto*</code></a> family of functions<sup>1</sup> and, as you have probably already noticed, they require you to choose an appropriately-sized integer type for the input you expect.  Normally, when programming in C, it's possible to say that your program only needs to be able to support numbers in some fixed range, and just raise an error if you receive input outside that range.</p>

<p>If you truly need to support <em>arbitrarily large</em><sup>2</sup> numbers, then you need an add-on library.  The general terms for these libraries are ""bignum"", ""multiple precision arithmetic"", and ""arbitrary precision arithmetic"".  One well-written, freely-licensed bignum library is <a href=""https://gmplib.org/"" rel=""nofollow"">GNU MP</a>.</p>

<p><sup>1</sup> The related <code>ato*</code> and <code>*scanf</code> functions are broken as designed - never use them for anything.  One of the ways they are broken is that they make it impossible to tell when you've received input outside the supported range.</p>

<p><sup>2</sup> in absolute value, i.e. arbitrarily far away from zero in either direction</p>
",0
26223351,26221491,1,"<p>here's my attempt , I'm working with a maximum of 64bit int (but you can change the type to whatever it is that you like) with 8 offset , meaning if you surpass 8bit (ex. 257), it'll output 16 bits , if you surpass 16 bits it'll output 24bits ... etc, I also used the first bit as the sign bit 1 for negative and 0 for positive;</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;math.h&gt;

void btd(int64_t num , char* res);
int act_size(int64_t num);
int main(void)
{
    char res[64];
    btd(-200 , res);
    printf(""%s\n"" , res);
}

void btd(int64_t num , char* res)
{
    int64_t tmp;
    int neg = 0;
    int size = 0;
    int64_t one_check;
    int i;

    if(num &lt; 0)
        neg++;
    if(num &lt; 0) 
        tmp = num * -1;
    else
        tmp = num;  
    size = act_size(tmp);
    one_check = pow(2 , size - 1); 

    printf(""size %d\none flag : %ld\n"" , size , one_check);

    for( i = 0 ; i &lt; size + 1; i++)
    {
        if(!i)
        {
            if(neg)
            {
                neg = 0;
                res[0] = '1';
                num &lt;&lt;= 1;
            }
            else
            {
                res[0] = '0';
                num &lt;&lt;= 1;
            }
            continue;
        }

        if(tmp &amp; one_check)
        {
            res[i] = '1';
            tmp &lt;&lt;= 1;
        }
        else
        {
            res[i] = '0';
            tmp &lt;&lt;= 1;
        }

    }
    res[i]  = '\0';
}

int act_size(int64_t ar)
{
    int count = 1;
    int last_one;
    int size;
    int64_t num = ar;

    if(num &lt; 0)
        num *= -1;
    while(num)
    {
        printf(""NUM : %ld\n"" , num);
        if(num &amp; 1)
        {
            last_one = count;
            num &gt;&gt;= 1;
        }
        else
            num &gt;&gt;=1;
        count++;
    }
    printf(""NUM : %ld\nLAST : %d\n"" , num , last_one);
    if(last_one &lt;= 8)
        return 8;
    else if (last_one &lt;= 16)
        return 16;
    else if (last_one &lt;= 24)
        return 24;
    else if (last_one &lt;= 32)
        return 32;
    else if (last_one &lt;= 40)
        return 40;
    else if (last_one &lt;= 48)
        return 48;
    else if (last_one &lt;= 56)
        return 56;
    else
        return 64;
}
</code></pre>

<p>the output of this will be (since we gave it -200 as an argument)</p>

<pre><code>NUM : 200
NUM : 100
NUM : 50
NUM : 25
NUM : 12
NUM : 6
NUM : 3
NUM : 1
NUM : 0
LAST : 8
size 8
one flag : 128
111001000
</code></pre>
",0
21015224,21015174,4,"<p>This feature (ala c# verbatim string literal) is available starting with C++11. You can use raw string literals like below:</p>

<pre><code>    const char* s = R""( "" "" "" \n \a )"";     
    cout &lt;&lt; s;
</code></pre>

<p>prints:</p>

<pre><code>    "" "" "" \n \a
</code></pre>

<p>a raw string starts with <code>R""(</code> and ends with <code>)""</code></p>
",2
23809805,23809763,1,"<p>You macro <code>#define</code> is wrong; try with</p>

<pre><code>     #define MAX_NAME_SIZE   1024
</code></pre>

<p>(or some other number, perhaps 128)</p>

<p>And you should compile with <code>gcc -Wall -g string.c -o string</code>; BTW, you could get the preprocessor output with <code>gcc -C -E string.c</code></p>
",0
23809840,23809763,0,"<p>You must allocate memory for <code>x</code>, and then pass it's address (of type <code>char*</code>) to <code>fgets</code>.  Something like:</p>

<pre><code>char* getString(void)
{
    char* s = malloc(MAX_NAME_SIZE);
    if ((s = fgets(s, MAX_NAME_SIZE, stdin)) == NULL)
    {
        free(s);
    }

    return s;
}
</code></pre>

<p>The caller must now <code>free()</code> the memory allocated in <code>getString()</code>.</p>

<p>Alternatively you can pass in the string:</p>

<pre><code>char* getString(char* s, size_t size)
{
    return fgets(s, size, stdin);
}
</code></pre>

<p>I would say that there is hardly a reason to have a <code>getString()</code> function here.</p>
",1
23809906,23809763,0,"<p>The error message is fairly clear - you are passing a char where you should be passing a char*. You could just pass &amp;c, which would fix the compiler error, but would be a really bad idea since you presumably want a name to be more than one character long. That's enough hints for now...</p>
",0
25479899,25479824,4,"<p>If you're getting values like <code>0.0034</code>, you can't simply cast that to an <code>int</code> since it will come out as zero. In fact, the majority of floating point values between zero and one will come out as zero.</p>

<p>You need to first scale up the value, <em>then</em> cast it to an integer.</p>

<p>For example, to turn the output of a <code>sine</code> function into a value between -100 and 100, you could use something like:</p>

<pre><code>int val = (int)(fpVal * 100);
</code></pre>

<p>That will turn the range <code>(-1,1)</code> (but mostly <code>0</code>) into something more usable, <code>(-100,100)</code> (with slightly better distribution across the range).</p>

<p>You may also want to <em>round</em> the value rather than truncate it, to ensure the values generated more accurate represent the inputs.</p>
",0
25484365,25479824,0,"<p>You could try to save the float value into 3 unsigned integers, one for the values left of the decimal point and two for the values on the right of the decimal point.
For example, we get the float number ""359.042042"" and save it as variable flt.</p>

<pre><code>int main(void)
{
    unsigned int int1, int2, int0;

    float flt = 359.042042;

    int1 = floor(flt);
    int2 = (flt - int1) * pow(10.0, 8.0);
    int0 = 8 - log10(int2);

    printf(""%d."", int1);
    while (int0 != 0)
    {
        printf(""0"");
        int0--;
    }
    printf(""%d"", int2);

    return 0;
}
</code></pre>

<p>int1 are the digits on the left side of the decimal points, int2 are the digits on the right and int0 are the ""0"" before int2.
This would print ""359.042042"". Good luck.</p>
",0
21306474,21305918,0,"<p>This might help u understand</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
FILE *fp;
int main(void)
{

struct store
{
char id[128];
}stock[10];

int printnum;
int allrec=0;
int startrec=0;

fp=fopen(""Test 24 Definitions.txt"",""r"");

while(!feof(fp))
{
    fscanf(fp,""%[^\t]s"",stock[startrec].id);
    printf(""%s"", stock[startrec].id); 
}

fclose(fp);
return 0;
}
</code></pre>
",2
21306673,21305918,0,"<p>Get the size of the file using <code>ftell</code>. Then read the file content using <code>fgets</code>. Don't use <code>feof</code> to find the end of the file. <a href=""https://stackoverflow.com/questions/5431941/while-feof-file-is-always-wrong"">¡°while( !feof( file ) )¡± is always wrong</a>.</p>

<p>Try this code.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

#define MAX_LINE_LENGH 255

int main(void)
{
    char id[MAX_LINE_LENGH];
    int size;
    FILE *fp;
    fp=fopen(""test.txt"",""r"");

    fseek(fp, 0, SEEK_END); 
    size = ftell(fp); 
    fseek(fp, 0, SEEK_SET); 

    while(size&gt;0)
    {
        fgets(id, MAX_LINE_LENGH, fp);
        printf(""%s"", id);
        /* copy this id to any char array if you want */
        size = size-strlen(id);
    }   
    fclose(fp); 
    printf(""\n"");
}
</code></pre>
",0
21306794,21305918,0,"<p>Some remarks before the code:</p>

<ul>
<li>I removed conio - not used or needed</li>
<li>I removed allrec since you can just use startrec which I renamed to rec</li>
<li>There's no need to use getc() (not getch(), that's from libcurses), fgets reads till the newline, including that one</li>
<li>I check if the file is actually opened or you're gonna risk reading from NULL, resulting in a segfault </li>
<li>In the printing for-loop, I use getchar() instead of getch()</li>
</ul>

<blockquote>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
</code></pre>
</blockquote>

<pre><code>FILE *fp;
int main(void)
{

    struct store
    {
        char id[128];
    } stock[10];

    int allrec=0;
    int rec=0;
    int res;
    fp = fopen(""text.txt"",""r"");
    if(!fp) printf(""failed to open file\n"");

    while(!feof(fp))
    {
        res = fgets(&amp;stock[rec].id, 128, fp);
        if(!res) {
            break;
        }
        printf(""%s"", stock[rec].id);
        rec++;
    }
    fclose(fp);

    printf(""\n\n\n\n"");
    int i;
    fflush(stdin);
    for (i=0; i&lt;rec; i++)
    {
        printf(""%s"",stock[i].id);
        getchar();
    }
}
</code></pre>
",2
21313111,21305918,0,"<p>To read a line of text using <code>fscanf()</code> rather than words, for this code in 2 places use:</p>

<pre><code>fscanf(fp,""%127[^\n]%*c"", stock[startrec].id);
</code></pre>

<hr>

<p><code>""%127[^\n]""</code> Without skipping leading white-space, read up to 127 <code>char</code>.  Except do not read in a <code>'\n'</code>.  Store the result, with an appended <code>'\0'</code> to <code>stock[startrec].id</code>.</p>

<p><code>""%*c""</code> Without skipping leading white-space, read any 1 <code>char</code>.  This is either the <code>'\n'</code> that stopped the preceding  or we are now in an EOF condition.  <code>'*'</code> means to not save the result.</p>

<p>Or better yet...</p>

<p>Use <code>fgets()</code>, trimming the typical trailing <code>\n</code> as needed.</p>

<pre><code>fgets(stock[startrec].id, sizeof stock[startrec].id, fp);
</code></pre>

<hr>

<p>Suggest checking the results of <code>fscanf()</code> and <code>fgets()</code> and dropping <code>feof()</code></p>

<pre><code>printf(""i"");
if (fp != NULL) {
  int cnt;
  while((cnt = fscanf(fp, ""%s"", stock[startrec].id)) != EOF) {
    if (cnt &lt; 1) Handle_NothingWasRead();
    printf(""%s"", stock[startrec].id);
    printf("" \n"");
    getch();
    startrec = startrec + 1;
    allrec = startrec;
  }
}
</code></pre>
",2
21312774,21310772,2,"<p>Compiling with warnings enabled tells me, </p>

<p><code>warning: implicit declaration of function ¡®getch¡¯</code></p>

<p><code>getch</code> is apparently declared in the Console I/O header <code>conio.h</code>.  The <code>getch</code> is not part of the core functionality of your routine, so </p>

<ol>
<li><p>commenting those out (as well as the <code>system(""cls"")</code> line that my Mac doesn't understand at runtime) and </p></li>
<li><p>providing both command-line args </p></li>
</ol>

<p>gives a working routine:  </p>

<pre><code>./zpa fakefilename Sky
A match found on line: 4

Skywalker jedi
</code></pre>

<p>Note that the <code>fname</code> argument for <code>Search_in_File</code> isn't being used, so command-line input could be reduced to one argument.  Reducing borrowed code to the minimal core that you need is usually very helpful for debugging things.</p>
",0
21325277,21325190,1,"<p>use strlen function to find the length of greatest string, like</p>

<pre><code>int greatestlength=arrlength(a);
if(greatestlength&lt;arrlength(b))
{
    greatestlength=arrlength(b);
}
</code></pre>

<p>use strlen inside of arrlength or directly or write your own code in arrlength whatever you want</p>
",1
28311260,28311201,0,"<p><a href=""http://linux.die.net/man/3/__fbufsize"" rel=""nofollow""><code>__fbufsize</code></a> man page says:</p>

<blockquote>
  <p>The <code>__fbufsize()</code> function returns the size of the buffer currently <em>used</em> by the given stream.  </p>
</blockquote>

<p>so I think this is buffer size used by the stream.</p>
",0
28311583,28311201,9,"<p>Note that the correct return type for <code>main()</code> is <code>int</code>, not <code>void</code>.</p>

<p>This code compiles on Linux (Ubuntu 14.04 derivative tested):</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdio_ext.h&gt;

int main(void)
{
    FILE *f;
    size_t bufsize;

    f = fopen(""test.txt"", ""wb"");
    if (f == NULL)
    {
        perror(""fopen failed\n"");
        return -1;
    }

    bufsize = __fbufsize(f);
    printf(""The buffer size is %zd\n"", bufsize);

    putc('\n', f);
    bufsize = __fbufsize(f);
    printf(""The buffer size is %zd\n"", bufsize);

    fclose(f);
    return 0;
}
</code></pre>

<p>When run, it produces:</p>

<pre><code>The buffer size is 0
The buffer size is 4096
</code></pre>

<p>As suggested in the comments, until you use the file stream, the buffer size is not set. Until then, you could change the size with <code>setvbuf()</code>, so the library doesn't set the buffer size until you try to use it. </p>

<p>The macro <code>BUFSIZ</code> defined in <code>&lt;stdio.h&gt;</code> is the default buffer size. There's no standard way to find the buffer size set by <code>setvbuf()</code>. You need to identify the platform you're working on to allow useful commentary on <code>__fbufsize()</code> as a function (though it seems to be a GNU libc extension: <a href=""http://linux.die.net/man/3/__fbufsize"" rel=""noreferrer""><code>__fbufsize()</code></a>).</p>

<p><sup><em>There are numerous small improvements that should be made in the program, but they're not immediately germane.</em></sup></p>
",2
21675728,21674846,1,"<p>Your basic error was already pointed out by MadHatter: Your loops omit the last entry.</p>

<p>Another error is in main: The CNP is 13 characters long, so your <code>cnp</code> array must have at least 14 characters - you have to provide space for the terminating null character <code>'\0'</code>. You should also limit the length of the characters to read in oder to avoid buffer overflow:</p>

<pre><code>scanf(""%13s"", cnp);
</code></pre>

<p>Here, the thirteen means that at most 13 characters (plus the terminating null character) are read.</p>

<p>It is a good idea to check whether your string actually has 13 digits, so that you don't process garbage characters. And you've forgotten to cater for the case where the remainder is 10 - in which case the check digit is 1.</p>
",1
24578609,24534549,0,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(){
    int a[5] ={1, 2, 3, 4, 5};
    int i;
    char *b;
    int n = sizeof(a)/sizeof(*a);
    size_t len = 0;

    for(i=0 ; i&lt;n ; ++i){
        len += snprintf(NULL, 0, ""%d"", a[i]);
    }
    b = malloc(len + 1);
    len = 0;
    for(i=0 ; i&lt;n ; ++i){
        len += sprintf(b + len, ""%d"", a[i]);
    }

    printf(""\n%s\n"", b);
    free(b);

    return 0;
}
</code></pre>
",0
24578962,24534549,0,"<p>Notice the following code:</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
   int i, a[5] ={1,2,3,4,5};
   char buff[sizeof(a)/sizeof(a[0]) + 1] = {0};
   char *b = buff;

   for(i=0 ; i&lt;sizeof(a)/sizeof(a[0]) ; i++)
   {   
      sprintf(b++,""%d"",a[i]);
   }   
   printf(""%s\n"", buff);
   return 0;
}
</code></pre>

<p>Your code needs to make sure to do the following:</p>

<p>-- Create a place to store your string of numbers. This is done like so:</p>

<pre><code>char buff[sizeof(a)/sizeof(a[0]) + 1] = {0};
</code></pre>

<p>Notice a few things. </p>

<p>a. You can calculate the number of ints in your <code>a</code> array by dividing the total size of the array by the size of one of it's elements. You need make sure your buffer has space for the NULL at the end so add 1.</p>

<p>b. You want to initialize the buffers values. By assigning this buffer to {0} you will end up with a buffer where all elements are set to 0 ( NULL ). This guarantees our buffer has a NULL at the end which is needed so printf() knows how many bytes to print. Even though <a href=""http://www.tutorialspoint.com/c_standard_library/c_function_sprintf.htm"" rel=""nofollow"">sprintf()</a> adds a NULL at the end of the string it's a good idea to get into the habit of properly initializing your buffers and variables.</p>

<p>-- You need to make sure <code>b</code> is pointing to your buffer. You do it like this:</p>

<pre><code>char *b = buff;
</code></pre>

<p>Because buff is an array <code>buff</code> is the address of the first element.</p>

<p>-- And finally in your for loop, it's good form to once again calculate the number of elements in your array that you are iterating over so that you don't have to remember to change the loop if you change the size of your int array.</p>
",0
21789879,21789757,0,"<p>This code lets you get the nth digits you can compare and make a count of each symbol you need to return</p>

<pre><code>char nthdigit(int x, int n)
{
    while (n--) {
        x /= 10;
    }
    return (x % 10) + '0';
}
</code></pre>

<p>And this is how you get the length of a number, check this <a href=""https://stackoverflow.com/questions/3068397/c-how-to-find-the-length-of-an-integer"">post</a></p>
",0
21790013,21789757,1,"<p>Taking you at your word that you've already successfully completed most of your assignment, and by giving you code that you'll have to work through and understand to figure it out and adapt it to your needs, this will do what you want. The fact that you don't have to output the signs in the same order as the numbers themselves is what makes this easier.</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void) {
    int num1 = 1234;
    int num2 = 2315;

    int lt = 0, gt = 0, eq = 0;

    while ( num1 &gt; 0 &amp;&amp; num2 &gt; 0 ) {
        int op1 = num1 % 10;
        int op2 = num2 % 10;

        if ( op1 &lt; op2 ) {
            ++lt;
        } else if ( op1 &gt; op2 ) {
            ++gt;
        } else {
            ++eq;
        }
        num1 /= 10;
        num2 /= 10;
    }

    for ( int i = 0; i &lt; eq; ++i ) {
        putchar('=');
    }

    for ( int i = 0; i &lt; lt; ++i ) {
        putchar('&lt;');
    }

    for ( int i = 0; i &lt; gt; ++i ) {
        putchar('&gt;');
    }

    putchar('\n');

    return 0;
}
</code></pre>

<p>and outputs:</p>

<pre><code>paul@MacBook:~/Documents/src/scratch$ ./eq
&lt;&lt;&lt;&gt;
paul@MacBook:~/Documents/src/scratch$ 
</code></pre>
",1
23071978,23071950,1,"<p>All your statements are correct, but you are missing one definition, the difference between definition and declaration.</p>

<p><code>int c;</code> both declares <strong>and</strong> defines <code>c</code>, but does not initialize it.</p>

<p><code>extern int c;</code> will declare it but not define it. (It does not allocate storage.)</p>
",4
23071984,23071950,2,"<p>Initialization is the setting of the initial value of a variable, so you are correct. </p>

<p>This is the first line off the Wikipedia article on initialization:</p>

<blockquote>
  <p>In computer programming, initialization is the assignment of an initial value for a data object or variable.</p>
</blockquote>
",0
23072040,23071950,3,"<pre><code>int c;
</code></pre>

<p>declares and defines <code>c</code>.</p>

<pre><code>c = 5;
</code></pre>

<p>is not an <em>initializer</em>, but it <em>assigns</em> the value <code>5</code> to <code>c</code>, which has the same effect.</p>

<p>An initializer is a syntactic construct, part of a declaration. An assignment is a different syntactic construct that does more or less the same thing.</p>

<p>This:</p>

<pre><code>int c = 5;
</code></pre>

<p>declares and initializes <code>c</code>; the <code>5</code> is the initializer.</p>

<p>This:</p>

<pre><code>int c;
c = 5;
</code></pre>

<p>has the same effect, but there is no initializer.</p>

<p>(You can informally say that assigning a value to a variable ""initializes"" it, but it does so without using an initializer.)</p>

<p>One case where the distinction is important:</p>

<pre><code>const int c = 5;
</code></pre>

<p>This initializes <code>c</code> to <code>5</code>. You can't do the same thing with an assignment because you can't assign to a <code>const</code> (read-only) object.</p>
",0
22435464,22435445,3,"<p>Read about the <a href=""http://en.wikipedia.org/wiki/Comma_operator"" rel=""nofollow"">comma operator</a>. Your <code>(b,a)</code> expression is evaluated to 5 (the value of <code>a</code>).</p>

<p><sup>Also, take the good habit of ending your <code>printf</code> format control strings with a newline <code>\n</code> or else call sometimes <code>fflush</code> (which gets automatically called after <code>main</code>, using <code>atexit</code> techniques). Remember that <code>&lt;stdio.h&gt;</code> streams are buffered!</sup></p>
",0
22435466,22435445,1,"<p>In C, <code>(b,a)</code> means ""calculate b, then calculate and return a"". So, It's practically the same as just <code>a</code> in your case.</p>
",0
22871624,22871411,0,"<p>Everything looks ok, except </p>

<pre><code> empty(root);
 insert(root, 6);
</code></pre>

<p>After <code>empty(root);</code> root is not <code>NULL</code>, just some garbage, so you need to reassign it again ( <code>root = NULL;</code>) before you call <code>insert</code> function. The call to <code>insert</code> is also problematic, do it the same way you did before <code>root = insert (root, 6);</code> </p>

<p>Also do what Deduplicator advised in <code>empty</code> function. In case <code>root</code> is <code>NULL</code>, <code>empty</code> will crash, so check if the node is not NULL before you take  left and right pointers</p>
",0
22871984,22871411,0,"<p>Repaired empty:</p>

<pre><code>Node* empty(Node * node) {
    if(node) {
        empty(node-&gt;left);
        empty(node-&gt;right);
        free(node);
    }
    return 0;
}
</code></pre>

<p>Also, bad sequence in main (probably because you stopped after the errors...):</p>

<pre><code>empty(root);
insert(root, 6);
inorder(root);
</code></pre>

<p>Replace with:</p>

<pre><code>root = empty(root);
root = insert(root, 6);
inorder(root);
/*free(root);*/
</code></pre>
",3
22865995,22865622,15,"<p>It is only sensible to consider <code>strtol()</code> and <code>strtoul()</code> (or <code>strtoll()</code> or <code>strtoull()</code> from <code>&lt;stdlib.h&gt;</code>, or perhaps <code>strtoimax()</code> or <code>strtoumax()</code> from <code>&lt;inttypes.h&gt;</code>) if you care about error conditions. If you don't care about error conditions on overflow, any of them could be used.  Neither <code>atoi()</code> nor <code>atol()</code> nor <code>sscanf()</code> gives you control if the values overflow.  Additionally, neither <code>atoi()</code> nor <code>atol()</code> provides support for hex or octal inputs (so in fact you can't use those to meet your requirements).</p>

<p>Note that calling the <code>strtoX()</code> functions is not entirely trivial.  You have to set <code>errno</code> to 0 before calling them, and pass a pointer to get the end location, and analyze carefully to know what happened.  Remember, all possible return values from these functions are valid outputs, but some of them may also indicate invalid inputs ¡ª and <code>errno</code> and the end pointer help you distinguish between them all.</p>

<p>If you need to convert to <code>int</code> after reading the value using, say, <code>strtoll()</code>, you can check the range of the returned value (stored in a <code>long long</code>) against the range defined in <code>&lt;limits.h&gt;</code> for <code>int</code>: <code>INT_MIN</code> and <code>INT_MAX</code>.</p>

<p>For full details, see my answer at: <a href=""https://stackoverflow.com/questions/14176123/correct-usage-of-strtol/14176593#14176593"">Correct usage of <code>strtol()</code></a>.</p>

<p>Note that none of these functions tells you which conversion was used.  You'll need to analyze the string yourself.  Quirky note: did you know that there is no decimal 0 in C source; when you write <code>0</code>, you are writing an octal constant (because its first digit is a <code>0</code>).  There are no practical consequences to this piece of trivia.</p>
",6
22866001,22865622,38,"<blockquote>
<p>which function would be best to convert either a decimal, hexadecimal, or octal number to an <code>int</code> the best (?)</p>
</blockquote>
<p>To convert such text to <code>int</code>, recommend <code>long strtol(const char *nptr, char **endptr, int base);</code> with additional tests when converting to <code>int</code>, if needed.</p>
<p>Use <code>0</code> as the <code>base</code> to assess early characters in steering conversion as base 10, 16 or 8.<br />
<a href=""https://stackoverflow.com/questions/22865622/atoi-vs-atol-vs-strtol-vs-strtoul-vs-sscanf/22866001#comment34885747_22865622"">@Mike Holt</a></p>
<pre><code>Convert text per:
Step 1: Optional whitespaces like `' '`, tab, `'\n'`, ... .
Step 2: Optional sign: `'-'` or `'+'`.
Step 3:
  0x or 0X followed by hex digits--&gt; hexadecimal  
  0 --&gt; octal  
  else --&gt; decimal  
</code></pre>
<p>Sample code</p>
<pre><code>#include &lt;errno.h&gt;
#include &lt;limits.h&gt;
#include &lt;stdlib.h&gt;

int mystrtoi(const char *str) {
  char *endptr;
  errno = 0;
  //                                   v--- determine conversion base
  long long_var = strtol(str, &amp;endptr, 0);
  //   out of range   , extra junk at end,  no conversion at all   
  if (errno == ERANGE || *endptr != '\0' || str == endptr) {
    Handle_Error();
  }

  // Needed when `int` and `long` have different ranges
  #if LONG_MIN &lt; INT_MIN || LONG_MAX &gt; INT_MAX
  if (long_var &lt; INT_MIN || long_var &gt; INT_MAX) {
    errno = ERANGE;
    Handle_Error();
  }
  #endif

  return (int) long_var;
}
</code></pre>
<hr />
<blockquote>
<p><strong>atoi vs atol vs strtol vs strtoul vs sscanf ... to int</strong></p>
</blockquote>
<p><code>atoi()</code><br />
Pro: Very simple.<br />
Pro: Convert to an <code>int</code>.<br />
Pro: In the C standard library.<br />
Pro: Fast.<br />
Con: On out of range errors, <em>undefined behavior</em>. <a href=""https://stackoverflow.com/questions/22865622/atoi-vs-atol-vs-strtol-vs-strtoul-vs-sscanf/22866001?noredirect=1#comment125906290_22866001"">@chqrlie</a><br />
Con: Handle neither hexadecimal nor octal.</p>
<p><code>atol()</code><br />
Pro: Simple.<br />
Pro: In the C standard library.<br />
Pro: Fast.<br />
Con: Converts to an <code>long</code>, not <code>int</code> which may differ in size.<br />
Con: On out of range errors, <em>undefined behavior</em>.<br />
Con: Handle neither hexadecimal nor octal.</p>
<p><code>strtol()</code><br />
Pro: Simple.<br />
Pro: In the C standard library.<br />
Pro: Good error handling.<br />
Pro: Fast.<br />
Pro: Can handle binary. (base 2 to base 36)<br />
Con: Convert to an <code>long</code>, not <code>int</code> which may differ in size.</p>
<p><code>strtoul()</code><br />
Pro: Simple.<br />
Pro: In the C standard library.<br />
Pro: Good error handling.<br />
Pro: Fast.<br />
Pro: Can handle binary.<br />
---: Does not complain about negative numbers.<br />
Con: Converts to an <code>unsigned long</code>, not <code>int</code> which may differ in size.</p>
<p><code>sscanf(..., &quot;%i&quot;, ...)</code><br />
Pro: In the C standard library.<br />
Pro: Converts to <code>int</code>.<br />
---: Middle-of-the-road complexity.<br />
Con: Potentially slow.<br />
Con: OK error handling (overflow is not defined).</p>
<p>All suffer/benefit from <code>locale</code> settings.  ¡ì7.22.1.4 6 ¡°In other than the &quot;C&quot; locale, additional locale-specific subject sequence forms may be accepted.¡±</p>
<hr />
<p>Additional credits:<br />
<a href=""https://stackoverflow.com/questions/22865622/atoi-vs-atol-vs-strtol-vs-strtoul-vs-sscanf/22866001#comment34889805_22866001"">@Jonathan Leffler</a>: <code>errno</code> test against <code>ERANGE</code>, <code>atoi()</code> decimal-only, discussion about <code>errno</code> multi-thread concern.<br />
<a href=""https://stackoverflow.com/questions/22865622/atoi-vs-atol-vs-strtol-vs-strtoul-vs-sscanf/22866001#comment34886779_22866001"">@Marian</a> Speed issue.<br />
@Kevin Library inclusiveness.</p>
<hr />
<p>For converting <code>short</code>, <code>signed char</code>, etc., consider <a href=""https://stackoverflow.com/a/29378380/2410359""><code>strto_subrange()</code></a>.</p>
",11
25711270,25711237,0,"<p>I think that the code that the compiler will generate for expression <code>s1 = s2</code> will be faster than using explicitly a user defined loop. Very likely the compiler will use stnadard C function <code>memcpy</code></p>
",2
25711603,25711237,2,"<h3>Executive Summary:</h3>

<p>On my compiler, all of these are transformed into calls to <code>memcpy()</code> like functions. They happen to be different, but the compiler more or less recognizes that all of these implementations are functionally identical.</p>

<p>The performance difference between these various <code>memcpy()</code> implementations would likely be minimal.</p>

<h3>Code:</h3>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

struct S {
    int x[10000];
};

void impl1(struct S *x, struct S *y) __attribute__((noinline));
void impl1(struct S *x, struct S *y) {
    *x = *y;
}

void impl2(struct S *x, struct S *y) __attribute__((noinline));
void impl2(struct S *x, struct S *y) {
    memcpy(x, y, sizeof(*x));
}

void impl3(struct S * restrict x, struct S * restrict y) __attribute__((noinline));
void impl3(struct S * restrict x, struct S * restrict y) {
    for (int i=0; i&lt;10000; ++i)
        x-&gt;x[i] = y-&gt;x[i];
}

int main() {
    struct S x, y;
    impl1(&amp;x, &amp;y);
    impl2(&amp;x, &amp;y);
    impl3(&amp;x, &amp;y);
}
</code></pre>

<h3>Resultant LLVM Code</h3>

<pre><code>define void @impl1(%struct.S* nocapture %x, %struct.S* nocapture readonly %y) #0 {
  %1 = bitcast %struct.S* %x to i8*
  %2 = bitcast %struct.S* %y to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1, i8* %2, i64 40000, i32 4, i1 false), !tbaa.struct !1
  ret void
}

define void @impl2(%struct.S* %x, %struct.S* %y) #0 {
  %1 = bitcast %struct.S* %x to i8*
  %2 = bitcast %struct.S* %y to i8*
  %3 = tail call i64 @llvm.objectsize.i64.p0i8(i8* %1, i1 false)
  %4 = tail call i8* @__memcpy_chk(i8* %1, i8* %2, i64 40000, i64 %3) #1
  ret void
}

define void @impl3(%struct.S* noalias nocapture %x, %struct.S* noalias nocapture readonly %y) #0 {
  %x2 = bitcast %struct.S* %x to i8*
  %y3 = bitcast %struct.S* %y to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %x2, i8* %y3, i64 40000, i32 4, i1 false)
  ret void
}
</code></pre>

<h3>Compiler Information</h3>

<pre><code>[10:04am][wlynch@watermelon /tmp] clang -v
Apple LLVM version 5.1 (clang-503.0.40) (based on LLVM 3.4svn)
Target: x86_64-apple-darwin13.3.0
Thread model: posix
</code></pre>
",0
28239207,28238850,0,"<p>Do you really need to avoid <strong>reading</strong> the last buffer? Or just avoid doing anything with it? Perhaps a different form of loop? Perhaps a check for eof() after reading each buffer?</p>

<pre><code>while(read(server_to_client,serverString2,sizeof(serverString2)))
{
   if (! eof(server_to_client))
   {
      printf(""Client : PID %d"",getpid());
      printf(""-Target&gt;&gt;%s&lt;&lt;"", clientString2);
      printf(serverString2);
   }
   else
   {
      // do special stuff for the last buffer here
   }
}
</code></pre>
",2
28239381,28238850,1,"<p>You can't.  The question does not even make sense.</p>

<p>The question supposes that a ""buffer"" is a meaningful unit of measure for your data, but it is not.  In particular, the third argument to <strong>read</strong>(2) is a <em>maximum</em> number of bytes to read, but the call may actually transfer fewer bytes for a large number reasons, with reaching the end of the data being only one.  Other reasons are in fact a lot more likely to manifest when the file descriptor being read is connected to a pipe, as you say yours is, than when it is connected to a file.  Note that this means you must <em>always</em> capture <code>read()</code>'s return value if you intend to examine the data it reads, for otherwise you cannot know how much of the buffer contains valid data.</p>

<p>More generally, you cannot tell from an open file descriptor for a pipe how much data is available to be read from it.  You need to include that information in your protocol (for example, HTTP's <code>Content-Length</code> header), or somehow communicate it out-of-band.  That still doesn't tell you how much data is available to be read <em>right now</em>, but it can help you determine when to stop trying to read more.</p>

<hr>

<p><strong>Edited to add:</strong></p>

<p>If you ask because you want to avoid dealing with partially-filled buffers, then you are flat out of luck.  At minimum you need to be prepared for a partially-filled buffer when the data are prematurely truncated.  Unless the total size of the data to be transferred is certain to be a multiple of the chosen buffer size, you will also have to be prepared to deal with a partial buffer at the end of your data.  You can, however, avoid dealing with partial buffers in the middle of your data by repeatedly <code>read()</code>ing until you fill the buffer, perhaps via a wrapper function such as this:</p>

<pre><code>ssize_t read_fully(int fd, void *buf, size_t count) {
    char *byte_buf = buf;
    ssize_t bytes_remaining = count;

    while (1) {
        ssize_t nread = read(fd, byte_buf, bytes_remaining);

        if ((nread &lt;= 0) || ((bytes_remaining -= nread) &lt;= 0)) {
            break;
        }
        byte_buf += nread;
        bytes_remaining -= nread;
    }

    return count - bytes_remaining;
}
</code></pre>

<hr>

<p>Alternatively, you can approach the problem altogether differently.  Instead of trying to avoid reading certain data, you may be able to read it but avoid <em>processing</em> it.  Whether that could be sensible depends on the nature of your program.</p>
",3
23856545,23856482,1,"<p><code>parseQuestion()</code> duplicates the choices but misses to duplicate the question as well as the answer.  </p>

<p>Instead it simply copies the two arrays' addresses to the locally defined variable <code>QUESTION q</code> which is copied on return. </p>

<p>The memory for the question and answer strings is free'd on returning from the function, accessing it afterwards invokes undefined behaviuor.</p>
",1
23819497,23819445,4,"<p>If you have an unsigned, you can't use character literals.</p>

<p>'\xff' is -1, not 255, because the a character literal is signed.</p>

<p>The while condition is always true. If you are unsigned you should be using numbers only: 0 to 255, or casting characters you know are &lt;128 to unsigned.</p>
",3
23819576,23819445,4,"<p><code>\xff</code> is a character constant. It's of type <code>int</code>, not <code>char</code> (this is one way in which C differs from C++), but its value depends on whether plain <code>char</code> is signed or unsigned, which is implementation-defined.</p>

<p>The wording in the C standard is:</p>

<blockquote>
  <p>The hexadecimal digits that follow the backslash and the letter <strong><code>x</code></strong> in a
  hexadecimal escape sequence are taken to be part of the construction
  of a single character for an integer character constant or of a single
  wide character for a wide character constant. The numerical value of
  the hexadecimal integer so formed specifies the value of the desired
  character or wide character.</p>
</blockquote>

<p>If plain <code>char</code> is unsigned, then <code>'\xff'</code> is equivalent to <code>0xff</code> or <code>255</code>; it's of type <code>int</code> and has the value <code>255</code>.</p>

<p>If plain <code>char</code> is signed, then <code>'\xff'</code> specifies a value that's outside the range of <code>char</code> (assuming that <code>char</code> is 8 bits). The wording of the standard isn't 100% clear to me, but at least with gcc the value of <code>'\xff'</code> is <code>-1</code>.</p>

<p>Just use an integer constant <code>0xff</code> rather than a character constant <code>\xff'</code>. <code>0xff</code> is of type <code>int</code> and is guaranteed to have the value <code>255</code>, which is what you want.</p>
",0
23819606,23819445,2,"<blockquote>
  <p>I know that 0xff can have different representations depending on what the variable type is. Like -1 for signed (chars/ints(?)) and 255 for unsigned chars.</p>
</blockquote>

<p>This needs some explanation. The integer literal <code>0xFF</code> in a C program always means <code>255</code>. If you assign this to a type for which <code>255</code> is out of range, e.g. a <code>signed char</code> then the behaviour is implementation-defined.   Typically on 2's complement systems this is defined as assigning the value <code>-1</code>.</p>

<p>Character literals have different rules to integer literals. The character literal <code>'\xff'</code> must be a value that can sit in a <code>char</code>. You appear to have signed <code>char</code>, so it's implementation-defined what happens here, but again the most common behaviour is that this gets value <code>-1</code>. Note that character literals actually have type <code>int</code> despite the fact that they must have values representable by <code>char</code>.</p>

<p>In the line <code>packet.msg[strlen(""hello"")] = '\xff';</code> , you try to assign <code>(int)-1</code> to a <code>uint8_t</code>. This is out of range, but the behaviour is well-defined for out-of-range assignment to signed types, so the value you get is <code>-1 (mod 256)</code> which is <code>255</code>.</p>

<p>Finally, when using the <code>==</code> operator (and most operators), the values are promoted to <code>int</code> if they were not already int. The 8-bit int <code>255</code> is promoted to <code>(int)255</code>, and you compare this against <code>(int)-1</code>, and they differ.</p>

<p>To solve this , change your comparison to have either <code>0xFF</code>, or <code>(uint8_t)'\xFF'</code>.</p>
",0
22443189,22442740,1,"<p>The function given totals the number of each integer in an array. The offset of each total is the number being counted. It's a simple matter of feeding it an input, length, and output:</p>

<pre><code>int main(void) {
    int A[] = {8, 4, 6, 8, 1, 4, 8, 5, 7, 9};
    int N = 10;
    int counts[10];
    int n0, n1;
    memset(counts, 0, 10);
    gatherCounts(A, N, counts);
    for (n0 = 0; n0 &lt; N; n0++) {
        for (n1 = 0; n1 &lt; counts[n0]; n1++)
            printf(""%d "", n0 + 1);
    }
    printf(""\n"");
    return 0;
}
</code></pre>

<p>Make sure to do more research, and of course test your code using output before asking any more questions like this.</p>
",0
22446612,22427612,0,"<p>Wrong use of <code>scanf()</code> format parameter.  Check <code>scanf()</code> result.</p>

<pre><code>// int ... *order[1];
// scanf(""...%s..."",...,&amp;order,...);
</code></pre>

<p>Should be </p>

<pre><code>char order[80];  // select size as needed.

if (scanf(""%c%d%79s%c%d"", &amp;columnch, &amp;rowch, order, &amp;column, &amp;row) != 5) {
  // Handle format error
  exit(1);
}
</code></pre>

<p>[Edit]</p>

<p>With OP supplied sample input of ""a 11 king a 12"" recommend a different format: spaces before <code>%c</code>.</p>

<pre><code>"" %c%d%79s %c%d""
</code></pre>
",0
22517761,22517739,4,"<pre><code>char *currstring = malloc(128 * sizeof(char));
<strike>currstring = NULL;</strike></code></pre>

<p>You allocate memory, but then you immediately discard it and set the pointer to NULL. Get rid of the second line.</p>

<p>If you were trying to set it to an empty string (<code>""""</code>), instead do:</p>

<pre><code>currstring[0] = '\0';
// or
strcpy(currstring, """");
</code></pre>

<p>This probably isn't necessary, though. You don't need to set the string to <code>""""</code> if you're going to do a <code>strcpy()</code> later.</p>

<p><strike></p>

<pre><code>char *token = malloc(64 * sizeof(char));
</code></pre>

<p></strike></p>

<p>You also do not need to allocate memory for <code>token</code>. <code>strtok()</code> will cause <code>token</code> to point somewhere within <code>s</code>, so allocating memory for <code>token</code> will simply leak memory once you do <code>token = strtok(s, delim);</code>.</p>
",1
24125063,24122201,0,"<p>I would use <code>fscanf</code> instead of <code>fgets</code> to automatically get integer values from the file without worrying about the temporary string buffer.</p>

<pre><code>int read_value = 0, read_count = 0, pgFault_number = 0;

while(1)
{
  read_count = fscanf(fp, ""%d"", &amp;read_value);
  if(read_count==EOF)
    break;
  refArr[pgFault_number++] = read_value;
}
</code></pre>

<p>Then the count of numbers is already stored in <code>pgFault_number</code>.</p>
",1
24125626,24122201,1,"<p>Since you have many integers to read and don't know in advance how many, I suggest allocating storage for the list of integers dynamically. Your input seems to be unformatted, so Austin Mullins's suggestion to use <code>fscanf</code> is good.</p>

<p>Here's a function that reads integers from a file with the given filename. It returns a newly allocated array of integers and writes its length to <code>*len</code> if it is given:</p>

<pre><code>int *read_ints_new(const char *fn, int *len)
{
    FILE *f = fopen(fn, ""r"");
    int *arr = NULL;
    int size = 0;
    int n = 0;

    if (f == NULL) return NULL;

    for (;;) {
        int res, x = 0;

        res = fscanf(f, ""%d"", &amp;x);

        if (res == EOF) break;
        if (res == 0) fscanf(f, ""%*s"");
        if (res == 1) {
            if (n &gt;= size) {
                size = size ? 2 * size : 64;
                arr = realloc(arr, size * sizeof(*arr));
                if (arr == NULL) {
                    n = 0;
                    break;
                }
            }
            arr[n++] = x;
        }
    }
    fclose(f);

    arr = realloc(arr, n * sizeof(*arr));

    if (len) *len = n;
    return arr;
}
</code></pre>

<p>The function allocates successively greater chunks of memory, so that all integers that were read will fit. At the end, the exact amount of memory needed is allocated in oder not to waste space.</p>

<p>The <code>fscanf</code> tries to parse and convert integer. If it succeeds, it returns 1, i.e the number of conversions made. If it reaches the end of the file, it returns <code>EOF</code>. If there is a parsing error (because the next word of data was not an integer), it returns 0 and resets the file pointer to where it left before trying to parse a number. Therefore, we must eat up the next word (without storing it, that's what the asterisk in ¡ä%*s` is for) in oder to skip non-numeric entries.</p>

<p>You can use this function like so:</p>

<pre><code>int *array;
int n, i;

array = read_ints_new(""file.txt"", &amp;n);
if (array == NULL) return 1;

printf(""%d entries:\n"", n);

for (i = 0; i &lt; n; i++) {
    if (i) printf("", "");
    printf(""%d"", array[i]);
}
printf(""\n"");

free(array);
</code></pre>

<p>Remember to release the allocated array with <code>free</code> after using it.</p>
",1
23059609,23059549,0,"<p>You can do it using XOR logic like this:</p>

<pre><code>char* rev(char* str)
{
    int end = strlen(str) - 1;
    int start = 0;

    while (start &lt; end)
    {
        str[start] ^= str[end];
        str[end] ^= str[start];
        str[start] ^= str[end];

        ++start;
        --end;
    }

    return str;
}
</code></pre>
",0
32476182,32475478,1,"<pre><code> char *x = ""1234 is a test"";
</code></pre>

<p>Depending on whether you can <strong>rely</strong> on the fifth character not being a hex digit, you might skip the copying, and aim <code>strtol()</code> at <code>x</code> directly. It will stop parsing at the first character that is not a valid digit in the base you selected.</p>

<p>If you cannot rely on that, your copying code needs some cleaning up: <code>char dest[5]</code> declares an array with <em>five</em> elements, indices <strong>0</strong> through <strong>4</strong>, so <code>dest[5] = '\0';</code> would be setting a non-existent <strong>sixth</strong> element to zero, resulting in undefined behaviour. The digits will reside in <code>dest[0]</code> through <code>dest[3]</code> after copying, so it is really <code>dest[4]</code> that you would want to zero.</p>

<p>And drop the <code>char</code> in <code>char dest[4] = '\0';</code>, otherwise you are redeclaring <code>dest</code>...</p>

<pre><code>char dest[5];
strncpy( dest, x, 4 );
dest[4] = '\0';
</code></pre>

<p>Somewhat more elegant would be:</p>

<pre><code>char dest[5] = { 0 }; // actually sets *all* elements to zero
memcpy( dest, x, 4 );
</code></pre>

<blockquote>
  <p>i have tried using strtol(dest, &amp;ptr,16 );</p>
</blockquote>

<p>That should have worked, really. You did not show the code; from your comments that <code>strtol()</code> ""finds the numerical values and seperates"", I assume you were confused a bit and looked at <code>ptr</code> for the result. That is just a pointer at where <code>strtol()</code> stopped parsing. The <em>result</em> is <em>returned</em> by <code>strtol()</code>:</p>

<pre><code>char * ptr;
int i = strtol( dest, &amp;ptr, 16 );
</code></pre>

<p>If you are not interested in the end pointer, you can just pass <code>NULL</code>:</p>

<pre><code>int i = strtol( dest, NULL, 16 );
</code></pre>

<hr>

<p>If, indeed, the first 4 bytes are <em>not</em> hex digits at all, but the <em>binary</em> representation of an <code>int</code> (which your last paragraph edited in later <em>seems</em> to imply), the way to go about it would be a <code>union</code>.</p>

<pre><code>union
{
    int ival;
    char cval[4];
} convert;

memcpy( &amp;convert.cval, x, 4 );

int i = convert.ival;
</code></pre>

<p>This is, of course, assuming that <code>sizeof( int ) == 4</code> and that receiver has the same byte order (endianness) as the sender.. If not, you're in trouble, <code>unions</code> are tricky that way.</p>
",1
32478654,32475478,-1,"<p>Assuming first byte is the most significant byte:</p>

<pre><code>int convert_char(char c) {
    if (c &gt;= '0' &amp;&amp; c &lt;= '9') {
        return c - '0';
    }
    else if (c &gt;= 'A' &amp;&amp; c &lt;= 'F') {
        return (10 + c - 'A');
    }
    else  if (c &gt;= 'a' &amp;&amp; c &lt;= 'f') {
        return (10 + c - 'a');
    }
    return 0;
}
</code></pre>

<hr>

<pre><code>char *x = ""1234 is a test"";
int y = 0;
y = convert_char(x[0]) * 16 * 16 * 16 + convert_char(x[1]) * 16 * 16 + convert_char(x[2]) * 16 + convert_char(x[3]);
</code></pre>
",1
33593794,33593772,1,"<p>Put parentheses around your macro to evaluate arguments in the correct order:</p>

<pre><code>#include &lt;stdio.h&gt; 
#define MACRO(b)  printf(""%d\n"", (b)*(b))

int main()
{
    MACRO(4+1); 
}
</code></pre>
",0
33593884,33593772,1,"<p>When you use the macro, the preprocessor replaces it and its arguments quite verbatim, so the macro expansion in your code will look like</p>

<pre><code>printf(""%d\n"", 4+1*4.1);
</code></pre>

<p>That will not provide you with the result you want, and it is one of the reasons that function-like macros are looked down upon.</p>

<p>You need to use parentheses to make sure this problem doesn't occur:</p>

<pre><code>#define MACRO(b)  printf(""%d\n"", (b)*(b))
</code></pre>

<p>while will then result in the following expansion:</p>

<pre><code>printf(""%d\n"", (4+1)*(4.1));
</code></pre>

<p>Whenever you have problems with something preprocessor related, there are options for just about all compilers to stop after the preprocessing stage, which allows you to look at the preprocessed source and which will help you with problems like this.</p>

<hr>

<p>Also note that <em>another</em> possible problem here is if the expression you pass as argument to the macro is e.g. a function call with some side-effect that function will be called twice and the side-effect will be happen twice, even when using parentheses.</p>

<p>A simple example, using your macro:</p>

<pre><code>int my_function(void)
{
    printf(""Foo\n"");
    return 1;
}

int main(void)
{
    MACRO(my_function());
}
</code></pre>

<p>The above program will print <code>""Foo\n""</code> <em>twice</em>. If <code>MACRO</code> was a proper function the call to <code>my_function</code> would only happen once and the printout from the function would only happen once.</p>
",2
25507312,25507211,1,"<p>I changed a few incorrect statements, the resulting code is:    </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void receive(int *point, const int size);

int main(void) {
    int a;
    int *b;
    scanf(""%d"", &amp;a);
    b= malloc(sizeof(int)*a); //removed implicit declaration of malloc return value

    printf(""size of input: %d\n"", a);
    receive(b, a); //changed sizeof(b) to a as second argument of function
    free(b);
    return 0;
}

void receive(int *point, const int size) {

    //removed int c = sizeof(*point); unnecessary statement
    printf(""filling the array to zero"");
    int i;
    for (i=0; i&lt;size; i++) {              //substituted c with size
        printf(""\n previous_value:%d\n"", point[i]);
        point[i]=0;
        printf("", current_value %d\n"", point[i]);
    }
}
</code></pre>
",2
23613697,23613542,0,"<p>You realloc() function has an incorrect parameter: size. You should be allocating a size of a pointer times the number i, but you allocate only i.</p>

<pre><code>temp=(char **)realloc(arr, sizeof( char* ) * (i+1) );
</code></pre>

<p>The only problem remaining could be that you didn't include necessary headers.</p>
",1
26791744,26791693,2,"<p>So, let's look at some cases:</p>

<ol>
<li><code>1 + 2.3</code>, which is an integer plus a double.</li>
<li><code>1f + 2.3</code>, which is a float plus a double.</li>
<li><code>1. + 2.3</code>, which is a double plus a double.</li>
</ol>

<p>In all three of these cases, the first argument either already is, or will be promoted to a double. Additionally, the result of these expressions will always be a double.</p>
",2
26793869,26791693,1,"<p>When you write <code>1.f</code> you create a float number in memory.
When you write <code>(float)1</code>, you create an integer number in memory, but this number will be interpreted like a float number in the expression (casting).</p>
",0
29241099,29239533,1,"<p>You are trying to read a string one character at a time, but using the edit descriptor for reading a whole string.  You're trying to make it harder than it needs to be.</p>

<p>Also, the term ""matrix"" is normally understood to mean a 2-dimensional array of elements all the same type, whereas it sounds like you want a 1-dimensional array of <code>struct</code>s containing members of different types.   For example:</p>

<pre><code>#define MAX_BANKS 10

struct bank {
    char nome[42];
    int rating;
    int ref;
};

struct bank banks[MAX_BANKS];
int num_banks = 0;

/* ... */

void read_banks(void) {
    while (num_banks &lt; MAX_BANKS) {
        int fields;

        fields = scanf(""%41s %d %d"", banks[num_banks].nome,
                &amp;banks[num_banks].rating, &amp;banks[num_banks].ref);
        if (fields != 3) {
            /* handle error */
            break;
        } else {
            num_banks += 1;
        }
        /* ... */
    }
}
</code></pre>
",1
29241374,29239533,0,"<p>Since you are working with a collection of different types of information (e.g. <code>char*</code>, <code>int</code>, <code>int</code>), the proper way to collect this information is in a structure (or <code>struct</code>). You have two choices on how to create space for any array or array of struct, (1) statically allocate on stack, or (2) dynamically allocate on heap. Given your question requirement, static allocation is the most basic. However, it is not as flexible as dynamically allocating the data, and you are limited to the initial size you choose.</p>

<p>Just as with storing the data, you have choices on how you read the data from <code>stdin</code>. As a general proposition, when reading from <code>stdin</code>, the preferred way is to read a line-at-a-time into a buffer and then parse the buffer for the desired content. Just as above, line input is more flexible than squeezing the data into a <code>scanf</code> format string, but is a bit more involved. For purposes here, we will use <code>scanf</code>, but know that line-input with <code>getline</code> or <code>fgets</code> provide certain advantages.</p>

<p>Next, you can just declare the number of structs you need, or you can take the time to initialize all the values in each of the structs. (this has advantages as you will see below). Aside for allowing some iteration tricks, the primary reason you <strong>initialize all your variables</strong> is to prevent the possibility of reading from them uninitialized. Reading an uninitialized variable results in <strong>Undefined Behavior</strong> (<code>bad</code>). So take the time to learn how to initialize each of your variable types.</p>

<p>With that said, you can tell there are a number of valid ways to approach any problem. How you do it is up to you, as long as you do it correctly. Here is another approach to meet your requirements. Note that the maximum name length <code>MAXNM</code> and maximum number of lines to read <code>MAXLN</code> are defined at the top of the code. This allows you to easily adjust the values later on. Let me know if you have any questions:</p>

<pre><code>#include &lt;stdio.h&gt;

#define MAXNM 41
#define MAXLN 100

typedef struct mix {
    char name[MAXNM + 1];
    int num1;
    int num2;
} mix;

int main (void) {

    /* initialize array of structs &amp; variables */
    mix array[MAXLN] = {{ {0}, 0, 0 }};
    size_t i = 0;
    size_t read = 0;

    /* read array of struct contents from stdin */
    while (scanf (""%s %d %d"", array[i].name, &amp;array[i].num1, &amp;array[i].num2) == 3) {
        i++;
        /* check if lines &gt; MAXLN allowed */
        if (i &gt;= MAXLN) {
            fprintf (stderr, ""warning: lines read from stdin exceed MAXLN.\n"");
            break;
        }
    }

    /* set the number of elements read to i */
    read = i;

    /* iterate over elements using 'read' */
    printf (""\nIterating array using 'while (i &lt; read)'\n\n"");
    i = 0;
    while (i &lt; read) {
        printf ("" array[%zu]  %-41s  %4d  %4d\n"", i, array[i].name, array[i].num1, array[i].num2);
        i++;
    }

    /* iterate over array by virtue of initization of name to 0/null */
    i = 0;
    printf (""\nIterating array using 'while (array[i].name[0])'\n\n"");
    while (array[i].name[0]) {
        printf ("" array[%zu]  %-41s  %4d  %4d\n"", i, array[i].name, array[i].num1, array[i].num2);
        i++;
    }

    printf (""\n"");

    return 0;
}
</code></pre>

<p><strong>Input</strong></p>

<pre><code>$ cat dat/staticstruct.txt
TheNamesofVaryingWidth 123 456
SomeOtherName 234 567
Bank_1 12 34
Bank_2 23 45
Bank_3 34 56
OneLastNameThatHasCloseToTheMaximumChars 777 9999
</code></pre>

<p><strong>Output</strong></p>

<p>$ ./bin/ptrarraystatic &lt; dat/staticstruct.txt</p>

<pre><code>Iterating array using 'while (i &lt; read)'

 array[0]  TheNamesofVaryingWidth                      123   456
 array[1]  SomeOtherName                               234   567
 array[2]  Bank_1                                       12    34
 array[3]  Bank_2                                       23    45
 array[4]  Bank_3                                       34    56
 array[5]  OneLastNameThatHasCloseToTheMaximumChars    777  9999

Iterating array using 'while (array[i].name[0])'

 array[0]  TheNamesofVaryingWidth                      123   456
 array[1]  SomeOtherName                               234   567
 array[2]  Bank_1                                       12    34
 array[3]  Bank_2                                       23    45
 array[4]  Bank_3                                       34    56
 array[5]  OneLastNameThatHasCloseToTheMaximumChars    777  9999
</code></pre>
",0
29241195,29239533,0,"<p>In this example I have interpreted your ""matrix"" requirement, such that each line of the input fills in a <code>struct</code> having different field types, so we end up with a 1-D array of the <code>struct</code> instead of a 2-D array of differing data types.</p>

<p>And instead of entering the data from the keyboard, which is so boring every time you test the program, I have put your data in a file and read from that - although the technique is quite similar.</p>

<p>Also, because your input format is not consistent, I have skipped any chars that don't form part of the data, see <code>delims</code>.</p>

<p>The program is possibly rather more complicated than you would have liked, but I hope it can help you do what you want. The complexity level rose when I decide not to use a fixed length string in the <code>struct</code> but a pointer to string memory, allocated for a variable length string.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

typedef struct {
    char *nome;
    int rating;
    int ref;
    } customer;

void fatal(char *msg) {
    printf(""%s\n"", msg);
    exit (1);
    }

int main()
{
    FILE *fp;                                       // for fopen
    char line[1000];                                // for fgets
    char *delims = "", {}\t\r\n"";                    // for strtok
    char *sptr;                                     // for strtok
    customer *mark = NULL;                          // an empty array
    int marks = 0;                                  // number of customers
    int len;                                        // length of input string
    fp = fopen(""input.txt"", ""r"");                   // open the file
    if (fp == NULL)                                 // did it open?
        fatal(""Cannot open file"");
    while (fgets(line, 1000, fp) != NULL) {         // each line of file
        mark = realloc(mark, sizeof(customer) * (marks+1));  // extend
        if (mark == NULL)
            fatal(""Cannot extend array"");           // failed extend the array

        sptr = strtok(line, delims);                // split first field
        if (sptr == NULL)
            fatal(""Cannot get first field"");
        len = strlen(sptr);                         // length of bank name
        mark[marks].nome = malloc(len+1);           // memory for the string
        if (mark[marks].nome == NULL)
            fatal(""Cannot allocate string array"");
        strcpy(mark[marks].nome, sptr);             // copy string to struct

        sptr = strtok(NULL, delims);                // split second field
        if (sptr == NULL)
            fatal(""Cannot get second field"");
        mark[marks].rating = atoi(sptr);            // extract number

        sptr = strtok(NULL, delims);                // split third field
        if (sptr == NULL)
            fatal(""Cannot get third field"");
        mark[marks].ref = atoi(sptr);               // extract number

        marks++;                                    // one more record
    }
    fclose (fp);

    // print the results (re-using len for convenience)
    for (len=0; len&lt;marks; len++)
        printf(""%s %d %d\n"", mark[len].nome, mark[len].rating, mark[len].ref); 

    // release the data array
    for (len=0; len&lt;marks; len++)
        free(mark[len].nome);
    free(mark);

    return 0;
}
</code></pre>

<p>Input file:</p>

<pre><code>{ bank, 1, 10,  
  bank2, 2, 15,  
  bank3, 3, 20  }  
</code></pre>

<p>Program output:</p>

<pre><code>bank 1 10
bank2 2 15
bank3 3 20
</code></pre>
",0
29519064,29518227,1,"<p>A sequence that is strictly increasing/decreasing upto a point and then strictly decreasing/increasing is what I would expect to be called as crescent order. </p>

<p>E.g. <code>[1 2 3 2 1]</code> or <code>[9 8 7 6 10 12 15]</code>.</p>

<p>So no,  <code>[5,5,5,5,5]</code> is not in crescent order.</p>
",0
31255179,31255065,4,"<p>You take input <code>char deci</code>. It's a single character. </p>

<p>Change the condition:</p>

<pre><code>if(deci=='P') // only P is able to identify 'PM'. you can work with this single char
{
  //
}
</code></pre>
",0
31255200,31255065,2,"<p>You probably want to read in <code>deci</code> as a string rather than as a single character.  Also note that you can't do a simple comparison on string constants, and that string constants are surrounded in double quotes, not single quotes.</p>

<pre><code>char deci[5];
int hours,min;

printf(""Enter a 12-hour time: "");
scanf(""%d:%d %s"",&amp;hours,&amp;min,deci);

if(strcmp(deci,""PM"") == 0) {
...
</code></pre>

<p>Also, the output won't be quite what you expect even with that fix.  This should work:</p>

<pre><code>if(strcmp(deci,""PM"") == 0) {
    if (hours == 12) {
        printf(""Equivalent 24-hour time: 12:%d"",min);
    } else {
        printf(""Equivalent 24-hour time: %d:%d"",hours+12,min);
    }
} else {
    if (hours == 12) {
        printf(""Equivalent 24-hour time: 0:%d"",min);
    } else {
        printf(""Equivalent 24-hour time: %d:%d"",hours,min);
    }
}
</code></pre>
",0
26197596,26197151,3,"<p><code>printf()</code> expects a valid (non-NULL) <code>char*</code> matching the <code>%s</code>. Passing a <code>(char*)NULL</code> is <em>technically</em> undefined behaviour. glibc <code>printf()</code>, for probably bad reasons, decides that ""undefined behaviour"" to them means printing ""(null)"".<br>
But the C-compiler sees you dereference a pointer, and then <strong>afterwards</strong> check whether it was NULL. The compiler is free to conclude that, since you've already dereferenced that pointer, and the world hasn't ended, that pointer <em>wasn't</em> NULL, so it removes the <code>if(!chant){//can't happen}</code>.<br> Welcome to C.<br>
To get defined behaviour, you could go with code like this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main(int argc, char *argv[])
{
    if (argc &lt; 3)
        exit(EXIT_FAILURE);     //to avoid passing a NULL-ptr to printf()/strstr()
    int i;
    for(i=1; i&lt;argc; i++) 
    {
        printf(""%s\n"", argv[i]);
    }
    printf(""\n"");
    char *chant;
    chant = strstr(argv[1], argv[2]);
    printf(""The subtring is: %s\n"", chant?chant:""(null)"");
        //prints ""(null)"" when substring not found, substring otherwise
    if(chant==NULL)
    {
       printf(""good bye"");
    }
    return 0;
} 
</code></pre>
",0
24107301,24107178,0,"<p>you are decrementing <code>n</code> in the recursion but you don't check the case when <code>n</code> becomes 0 or negative, so the segfaul basically tells you that you get into an infinite recursion.</p>

<p>just add some stop criterion in addition to <code>n==k || k==0</code>.</p>

<p>I didn't look at the problem description so I don't know what the correct condition is, but perhaps you need something like </p>

<pre><code>if (n==k || k==0 || n==0)
</code></pre>
",3
24113243,24113228,2,"<p>Problem is that in the first case pointer 'x' doesn't point to a valid memory location. And you're trying to change the value of un-allocated memory which your program doesn't own.<br>
Pointers must always be initialized properly before they are used.</p>
",0
24113270,24113228,3,"<blockquote>
  <p>From what I know, this program initializes the pointer *x to an
  integer value, and subsequently assigns the value of 3 to the
  deferenced pointer *x.</p>
</blockquote>

<p>That is incorrect.  <code>int *x;</code> declares an int pointer, but <em>it does not initialize it to anything</em>.  What <code>x</code> points to at this time is unknown, and depends on the current state of memory.  Before you can dereference a pointer, you need to set it to point to something (eg, <code>x = &amp;y;</code>).</p>
",5
24113340,24113228,2,"<p>In the first example x is uninitialized and therefore doesn't point to valid memory.</p>

<p>You could change your code to</p>

<pre><code>int *x = malloc(sizeof(int));     
*x = 3;
printf(""%d"", *x);
</code></pre>

<p>and it would work. </p>

<p>In your second example </p>

<pre><code>int *x, y; 
</code></pre>

<p>You are declaring x as a pointer and y as a normal int variable, not another pointer. If you wanted 2 pointers the syntax would be.</p>

<pre><code>int *x, *y;
</code></pre>

<p>This can be confusing and is part of the reason some C programmers never declare multiple variables on one line.</p>

<pre><code>x = &amp;y;  
</code></pre>

<p>Here you are assigning the address of y to x and therefore causing x to point to valid memory and a subsequent assignment through dereferencing the pointer will work.</p>

<p>You would find that if you printed the value of y then it would also be 3 as you changed it through x.</p>
",0
28467280,28467227,4,"<p>This is wrong</p>

<pre><code>printf(""\n%i"", &amp;feet);
</code></pre>

<p>it should be</p>

<pre><code>printf(""\n%i"", feet);
/*             ^ no &amp; here */
</code></pre>

<p><code>printf(""\n%i"", &amp;feet);</code> prints the <a href=""http://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B"" rel=""nofollow"">address of</a> <code>feet</code>, and not it's value.</p>

<p>Your program also assumes that the <code>scanf()</code>ed value was read successfuly, you must check the return value of <code>scanf()</code> to ensure that it succeeded</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    int centimeters, feet, inches;

    printf(""Please enter an amount in centimeters\n"");
    if (scanf(""%i"", &amp;centimeters) == 1)
    {
        getchar();

        inches = centimeters / 2.54;
        feet   = inches % 12;

        printf(""\n%i"", feet);
    }
    return 0;
}
</code></pre>

<p>also, apparently the formula is wrong as mentioned in another answer, please check it.</p>
",0
28467357,28467227,0,"<p>Your modulus calculation for <code>feet</code> is wrong. It should be</p>

<pre><code>feet = inches / 12;
inches %= 12;
printf(""\n%i feet, %i inches"", feet, inches);
</code></pre>
",0
24377550,24377498,2,"<p>You can use an infinite loop and break it just in case gallons_used = -1</p>

<pre><code>for(;;) { // &lt;-- infinite loop
    printf(""Enter the gallons used (-1 to end): "");
    scanf(""%f"", &amp;gallons_used);
    if (gallons_used == -1)
        break; // &lt;-- exit the loop
    printf(""Enter the miles driven: "");
    scanf(""%f"", &amp;miles);
    mpg = miles / gallons_used;
    printf(""Miles / gallon for this tank was %f\n"", mpg);
    total += mpg;
    count++;
}
</code></pre>
",2
24377554,24377498,1,"<pre><code>while(true) {
printf(""Enter the gallons used (-1 to end): "");
    scanf(""%f"", &amp;gallons_used);
    printf(""Enter the miles driven: "");
    scanf(""%f"", &amp;miles);
    if(gallons_used== -1 )break;
    mpg = miles / gallons_used;
    printf(""Miles / gallon for this tank was %f\n"", mpg);
    total += mpg;
    count++;
}
</code></pre>
",1
24377570,24377498,0,"<pre><code>#include &lt;stdio.h&gt;

int main(void) {
    int total = 0, count = 0;
    float gallons_used, mpg, miles;
    while(gallons_used != -1) {
    printf(""Enter the gallons used (-1 to end): "");
        scanf(""%f"", &amp;gallons_used);
        if (gallons_used &lt; 0)             // check gallons_used
            break;
        printf(""Enter the miles driven: "");
        scanf(""%f"", &amp;miles);
        mpg = miles / gallons_used;
        printf(""Miles / gallon for this tank was %f\n"", mpg);
        total += mpg;
        count++;
    }
    total /= count;
    printf(""Average miles to the gallon was: %d\n"", total);
    return 0;
}
</code></pre>
",0
24377644,24377498,0,"<p>You are using <code>gallons_used</code> uninitialized. Using uninitialized variables invokes <strong>undefined behavior</strong>. You need to initialize it first before comparing it in <code>while</code>'s conditional expression. You can do this as </p>

<pre><code>printf(""Enter the gallons used (-1 to end): "");
scanf(""%f"", &amp;gallons_used);           // Reading value for gallons_used

while(gallons_used != -1) {
    printf(""Enter the miles driven: "");
    scanf(""%f"", &amp;miles);
    mpg = miles / gallons_used;
    printf(""Miles / gallon for this tank was %f\n"", mpg);
    total += mpg;
    count++;
    printf(""Enter the gallons used (-1 to end): "");
    scanf(""%f"", &amp;gallons_used);
}  
</code></pre>
",0
24643773,24643651,0,"<p>The code you have given so far only shows the attempt at building the structure. </p>

<p>For strings, you need to have room for the null character at the end.  </p>

<ul>
<li>department and course_number need to be larger</li>
</ul>

<p>Your strtok tokens are aren't working because you need to strtok on "" "" not "" .""</p>

<p>You will need to grab the 1st, 5th, and 6th iterations of strtok and put them into the corresponding fields in the stucture: name, department, and course number. </p>
",0
24643839,24643651,0,"<p>A few problems:</p>

<p>1) <code>department</code> has 4 elements, which means there is no room for a terminating null if the department name has 4 characters.</p>

<p>2) <code>course_number</code> is declared as an <code>int</code> so it doesn't need to be an array.</p>

<p>3) However, you will have to convert course numbers to int using <code>atoi</code>, <code>sscanf</code> or something similar.</p>

<p>4) <code>student</code> is only a single instance, not an array of structs as it needs to be to contain multiple students.</p>

<p>5) When your outer loop terminates, <code>line</code> will contain the name ""John"", <code>student.name</code> will contain the text ""1201"", and <code>student.department</code> will contain garbage, as will <code>student.course_number</code>.</p>

<p>Fix those five problems and you will have a working program.</p>
",2
24649888,24643651,0,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct classes {
    char name[20];
    char department[5];//+1 for '\0'
    int course_number;
};

int main(void){
    FILE *file;
    char buffer[50];
    struct classes student, students[48];
    int i, count=0;

    file = fopen(""inputfile.txt"", ""r"");

    while (fgets(buffer, sizeof(buffer), file)){
        //Format : NAME is enrolled in DEPARTMENT NUMBER.
        if(3 == sscanf(buffer, ""%19s %*s %*s %*s %4s %d"",
                student.name, student.department, &amp;student.course_number))
                students[count++] = student;
    }
    fclose(file);
    for(i = 0; i &lt; count; ++i){
        printf(""%-*s %-*s %d\n"",
            (int)sizeof(student.name), students[i].name,
            (int)sizeof(student.department), students[i].department,
            students[i].course_number);
    }
    return 0;
}
</code></pre>
",3
29218075,29217940,0,"<p>Use:</p>

<pre><code>// Loop as long as there is an error in reading 
// the level or the value of level is not right.
while ( ( scanf(""%d"", &amp;level) != 1 ) ||
        ( level != levelOne ) ||
        ( level != levelTwo )
{       

   if (feof(stdin))
   {
       // Deal with EOF
   }

   // Ignore the rest of the line up to the newline.
   scanf(""%*[^\n]"");

   printf(""Enter (%d or %d): "", levelOne, levelTwo);
}
</code></pre>
",1
24765116,24765034,1,"<p>If you enter a credit-card with 6 or more digits, such as <code>987654</code>, then this line:</p>

<pre><code>int luhn_array[(credit_card-(credit_card % 2)) / 2][2];
</code></pre>

<p>becomes:</p>

<pre><code>int luhn_array[987654 - 0/2][2];
</code></pre>

<p>or just  <code>int luhn_array[987654][2]</code>;</p>

<p>that is effectively trying to allocate:</p>

<pre><code>987,654 * 2 * 4-bytes-per-int = 7,901,232 bytes on the stack!
</code></pre>

<p>That is just short of 8-Gigs!   Your <a href=""http://msdn.microsoft.com/en-us/library/8cxs58a6.aspx"" rel=""nofollow"">default stack on Win32</a> is about 1MB!<br>
No wonder you are overflowing.</p>

<p><strong>Edit</strong>: Oops, I messed up the initial math.  Its worse than I thought!  Answer revised.</p>
",0
28232380,28232297,2,"<p>By ""C scripting language"", you probably mean this: <a href=""http://csl.sourceforge.net/csl.html"" rel=""nofollow noreferrer"">http://csl.sourceforge.net/csl.html</a> or some other project to create an interpretable version of C (see <a href=""https://stackoverflow.com/questions/584714/is-there-an-interpreter-for-c"">Is there an interpreter for C?</a>)</p>

<p>What's the difference? Well, ""C"" normally refers to a compiled version of the language, and ""C scripting language"" normally refers to an interpreted one. That's all there is to it. From the point of view of the language's standard, there might not be an actual difference between a compiled and an interpreted implementation if both follow the standard.</p>
",5
31846180,31846164,8,"<p><code>|</code> is the binary bitwise <code>or</code> operator. For example: <code>0x00ff | 0xff00</code> is <code>0xffff</code>. </p>
",0
31846192,31846164,5,"<p>bitwise OR operator, so if you have x = 5 (101) y = 8 (1000) and z = 20 (10100), values in parenthesis are binary values so
<code>x | y | z = 101 | 1000 | 10100 = 11101</code></p>
",0
31846450,31846164,1,"<p>The operator <code>|</code> in C is known a s <a href=""https://msdn.microsoft.com/en-us/library/17zwb64t.aspx"" rel=""nofollow noreferrer"">bitwise <em>OR</em> operator</a>. Similar to other bitwise operators (say <em>AND</em> <code>&amp;</code>), bitwise <em>OR</em> only operates at the bit level. Its result is a <code>1</code> if one of the either bits is <code>1</code> and zero only when both bits are <code>0</code>. The <code>|</code> which can be called a pipe! Look at the following:</p>

<pre><code>bit a   bit b   a | b (a OR b)
   0       0       0
   0       1       1
   1       0       1
   1       1       1
</code></pre>

<p>In the expression, you mentioned:</p>

<pre><code>var1 = x | y | z | ...;
</code></pre>

<p>as there are many <code>|</code> in a single statement, you have to know that, bitwise <em>OR</em> operator has <a href=""http://en.cppreference.com/w/c/language/operator_precedence"" rel=""nofollow noreferrer"">Left-to-right Associativity</a> means the operations are grouped from the left. Hence the above expression would be interpreted as:</p>

<pre><code>var1 = (x | y) | z | ...
=&gt; var1 = ((x | y) | z) | ...
....
</code></pre>

<p>Read more about Associativity <a href=""https://stackoverflow.com/questions/25589257/what-does-left-to-right-associativity-mean"">here</a>.</p>
",5
27528365,27528277,1,"<p>This certainly gives you the size of a pointer, and by that the theoretical maximum of memory that can be addressed in the current CPU mode.</p>

<p>However, not all bits in a pointer may actually be used in addressing: Current 64 bit CPUs use only 48 bits of a 64 bit pointer. Likewise, there were CPUs that used only 24 bits for addressing while storing pointers in 32 bit registers.</p>

<p>Also, the current CPU mode may not reflect the capabilities of the hardware: 64 bit CPUs have compatibility modes for 32 bit software. Such software will never be able to detect a 64 bit pointer.</p>
",2
27528795,27528277,2,"<p>The problem is that the definition of an <em>x</em>-bit machine a bit vague to begin with. The most common definition I know of is that <em>x</em> is the number of bits for a general-purpose register of that machine.</p>

<p>Take the 8086 as an example: it's widely considered to be a 16-bit machine since it's registers are 16 bits wide. Yet a pointer is formed by combining two registers which yields a 20-bit address (since 20/8 == 2.5 I guess compilers would round up to 3 or 4 bytes; it's up to the compiler).</p>

<p><a href=""https://stackoverflow.com/questions/24296235/sizeof-pointer-differs-for-data-type-on-same-architecture?rq=1"">The C standard even allows pointers to different types to be of different sizes</a>. So it's possible that <code>sizeof(char*) != sizeof(myFunction)</code>, for example.</p>

<p>Also, some machines support different modes, like x86-64 machines support executing x86-32 code. This further complicates things. And then there's this weird old thing called <em>near</em> and <em>far</em> pointers: <a href=""https://stackoverflow.com/a/1474076/400056"">pointers in Turbo C for x86-16 thus were 2 byte or 4 byte wide, depending on what they pointed to</a>. And the <a href=""https://stackoverflow.com/a/399999/400056"">Open Watcom compiler can give you 6-byte pointers on x86-32</a> if it's defined to be <em>far</em>.</p>

<p>Last but not least there's the <em>char size</em>. It's defined to be 1. But how many <em>bits</em> make up a char is a different thing: the <code>CHAR_BIT</code> macro tells you and it's usually 8, but on some DSPs today and some former CPUs it could be values like 7, 9, 16, or even more. If <code>CHAR_BIT</code> is 16 and a pointer is 32 bit wide, then <code>sizeof(void*) == 2</code> on such a machine.</p>

<p>So you <strong>cannot</strong> rely on <code>sizeof(pointer)</code> to determine the machine's ""CPU size""¡­ but in practice, this is often Good Enough?. It depends on <em>why</em> you want/need the information.</p>
",3
31813416,31813311,4,"<p>You can't.</p>

<p>The behaviour on going past the bounds of the array is undefined.</p>

<p>You could model the array with some sort of value acting as a terminator, but that's hardly practical. Pass the size as an extra parameter, of if you really want to have just one argument, use a <code>struct</code>.</p>
",5
31813481,31813311,8,"<p>The most common way of sending data around in arrays is by null-terminating the arrays. (However, this may not work for you if, for example, <code>0</code> is a valid integer to have in your array. In this case, you might want to use <code>-1</code>, for example.)</p>

<pre><code>int array_len(int *arr)
{
    const int TERMINATOR = 0; // or -1, as the case may be
    int i = 0;
    while (arr[i] != TERMINATOR)
        i++;
    return i;
}
</code></pre>

<p>However, a better method is probably just sending not <em>only</em> an array, but an array <em>and</em> a length whenever passing around data. That way, you don't need to keep calling functions like this to get array lengths in your various functions.</p>
",1
31813491,31813311,3,"<p>C does not store the size of the array with it. In C strings a NULL terminator is used to determine the size of the array, but this is convention. Either pass the size as an argument to the function, or choose a value that is considered the end of the array and search for it.</p>
",5
31813764,31813311,1,"<p>In you <code>while</code> loop condition -</p>

<pre><code>while(a[i]!=NULL)//replace NULL with such value which is unique and not used in your array.
</code></pre>

<p>Use <code>-1</code> or something. </p>

<p>You may think to use <code>'\0'</code> instead of <code>NULL</code>  but then if your array has <code>0</code> in between also then also loop will stop. (if <code>0</code> is in array don't use <code>'\0'</code>).</p>
",0
25545664,25544980,0,"<p>This program reads a size of an array the user wants to input, next it calls ""read"" which reads array elements of the given size recursively and fills in global array ""a"". Next it tries to find a minimal value of the local ""a"" array using recursive function ""rec"", that is initialized with garbage by the fact of being of ""auto"" variable type and types this value to the terminal screen. Next it waits for the user to type any character.</p>
",0
25545167,25544980,0,"<pre><code>int rec(int a[],int n)
{
    int min;

    if(n==1)
        return a[0];
    else {
        min=rec(a,n-1);

        if(min&lt;a[n-1])
            return min;
        else
            return a[n-1];
    }
} 
</code></pre>

<p>This function will go through all of your array elements, then compare them one by one, and each time return the smaller one, giving you the minimum of your array : </p>

<p>example : for a = {10,2,4,5}</p>

<ul>
<li>rec will start from 5 and just calls itself with the previous elem until he's at the first : 10</li>
<li>then will return 10</li>
<li>will compare 10 with 2 and return 2 because 2 &lt; 10</li>
<li>will compare 2 with 4 and return 2 because 2 &lt; 4</li>
<li>will compare 2 with 5 and return 2 because 2 &lt; 5</li>
</ul>
",1
25545177,25544980,0,"<p>It calculates the minimal value in the array. Look at it that way:
Suppose you're given an array with 10 numbers. A magician tells you the the minimal value of that last 9 elements is 5. You now take the first element and compare it to 5. if it's smaller you return it, otherwise you return 5. The magician is the recursive call to the array with the last n-1 numbers.</p>
",0
25545208,25544980,1,"<p>if <strong>n=1</strong>, then min. is a[0] as there is only one element.</p>

<p>if <strong>n>1</strong>, then it is calling rec with the array and n-1 as the length each time. So, there will be a time when n=1 and returns a[0]. Then it will compare a[0] with a[1]. And return the minimum. Then it will compare the returned value minimum with a[2] and return the smaller value....and so on.</p>
",0
25545213,25544980,0,"<p><code>rec(a, n)</code> return the minimum value in {a[0], ..., a[n-1]}</p>

<p>Now we discuss two cases:</p>

<p>If n = 1, then <code>rec(a,n)</code> should be <code>a[0]</code>, since there is only one value</p>

<p>Otherwise, <code>rec(a,n)</code> should be the minimum value of <code>rec(a,n-1)</code> (that is, the minimum value in {a[0],..,a[n-2]}) and <code>a[n-1]</code>, which is what the following code do:</p>

<pre><code>    min=rec(a,n-1);

    if(min&lt;a[n-1])
        return min;
    else
        return a[n-1];
</code></pre>
",0
25458107,25458076,1,"<p>You will get an error for missing quotes or <code>&lt;&gt;</code> in the filename for the <code>#include</code>. It should be:</p>

<pre><code>#include &lt;stdio.h&gt;
</code></pre>

<p>Apart from that, it should compile with a warning about an implicit declaration to <code>printf()</code>. On Clang, it gives me:</p>

<pre><code>test.c:3:5: warning: implicitly declaring library function 'printf' with type 'int (const char *, ...)'
    printf(""hello world"");
    ^
</code></pre>
",1
25458123,25458076,0,"<p>When your <code>main()</code> function is being declared, the compiler will run into the first line of <code>main()</code> and it will have no idea what <code>printf()</code> is. You will get an error about the compiler complaining about an undeclared function. </p>

<p>Assuming, of course, the missing <code>&lt;</code> and <code>&gt;</code> was a mistake introduced when you copied your question over.</p>
",2
25458129,25458076,7,"<p>It depends on the compiler.</p>

<p>Most C compilers will <em>probably</em> accept that code (perhaps with a warning) and produce an executable that prints the expected output.</p>

<p>Under C90 rules, the behavior of the <code>printf</code> call is undefined; it's invalid to call a variadic function with no visible prototype. Variadic functions can have a different calling convention from ordinary functions, and you have to let the compiler know that <code>printf</code> is variadic so it can generate correct code for the call.</p>

<p>Under C99 and later rules, calling any function with no visible declaration (which may or may not be a prototype) is a <em>constraint violation</em>, requiring at least a compile-time warning.</p>

<p>The standard doesn't hint at what happens if you call <code>printf</code> without the required prototype, but in practice most compilers will handle it ""correctly"".</p>

<p>The missing <code>'\n'</code> at the end of the output means that the program's behavior is undefined <em>if</em> the implementation requires a newline at the end of the output; whether that's required or not is implementation-defined. In any case, adding a newline is a good idea.</p>

<p>The <code>#include &lt;stdio.h&gt;</code> at the end of the source file should be useless but harmless.</p>

<p>I'm assuming that the source file actually contains <code>#include &lt;stdio.h&gt;</code> and not <code>#include stdio.h</code>; the latter would be a syntax error.</p>

<p>(Practically speaking, of course, the <code>#include &lt;stdio.h&gt;</code> <em>should</em> be at the top. In a professional setting, the output is irrelevant, since the program will never survive a code review.)</p>
",0
25458136,25458076,0,"<p>There are two errors here.  The first is that the include directive must happen before the code that requires that header information, in this case printf() is declared in stdio.h, and the second is that the filename in the include directive must be enclosed in angle brackets, &lt;>, or quotes, """".</p>
",2
34207733,25493707,1,"<pre><code>/* Program to find the second largest number without using array */
        main()
        {
         int num,large=0,slarge=0,i=0;
         clrscr();
         printf(""Enter the number:"");
         while(i&lt;10)
         {
          scanf(""%d"",&amp;num);
          if(i==0)
          {
          large=num;
          }
          else if(num&gt;large)
          {
           slarge=large;
           large=num;
          }
          else if(num&gt;slarge)
          {
           slarge=num;
          }
          i++;
         }
         printf(""Large number:%d"",large);
         printf(""\nSecond large=%d"",slarge);
         getch();
         return 0;
        }
</code></pre>
",0
25493900,25493707,1,"<p>the statement:</p>

<pre><code>num = m1 = m2;
</code></pre>

<p>is wrong and it does not cause the three variables to have the same value. You need to assign m1 and m2 to num. You are overwriting the variable that you previously had read. Change it to:</p>

<pre><code>m1 = num;
m2 = num;
</code></pre>

<p>Then, print out the m2.
<br><br>
<strong>EDIT:</strong>
<br><br>
As others found out, the -1 states for end of your input. Adding simple if statement solves the problem and for your input -169 is the second largest element.
<br>
Full code:</p>

<pre><code>#include&lt;stdio.h&gt;
int main(){
int i, m1, m2, n, num;
puts(""\n"");
scanf(""%d"",&amp;n);
for(i=0;i&lt;n;i++)
{
     scanf(""%d"",&amp;num);
     if(i==0)
     {
          m1 = num;
          m2 = num;
     }
     else if(num == -1)  /* if -1 was read, then terminate the loop. */
     {
         break;
     }
     else if(num&gt;m1)
     {
          m2 = m1; 
          m1 = num; 
     }
     else if(num&gt;m2)
     {
          m2=num;
     }
 }
printf(""%d\n"",m2);
return 0;
}
</code></pre>

<p>For input:</p>

<pre><code>7
-950 -588 -169 -187 -445 400 -1
</code></pre>

<p>and current code output is -169.</p>

<p><br>
Another EDIT:
<br>
Ok, your code is wrong because of the scanf for number of elements. In future It would be helpful if you were more clear about your problems. I hope that following code will work for you.</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    int curr, second, first;
    scanf(""%d"", &amp;curr);
    second = curr;
    first = curr;
    while (1) {
        scanf(""%d"", &amp;curr);
        if (curr == -1) {
            break;
        }
        if (curr &gt; first) {
            second = first;
            first = curr;
        }
        else if (curr &gt; second) {
            second = curr;
        }
    }
    printf(""%d\n"",second);
    return 0;
}
</code></pre>
",15
25494249,25493707,0,"<p>The problem with your code is you are using <code>m2</code> uninitialized. To correct the problem, set <code>m2</code> to some reasonable negative number (like the smallest integer allowed). Here we are just using a negative number for example:</p>

<pre><code>m2 = -1000000;
</code></pre>

<p><strong>outout</strong></p>

<pre><code>argument [0]:  -950
argument [1]:  -588
argument [2]:  -169
argument [3]:  -445
argument [4]:  400
argument [5]:  -1

m1: 400
m2: -1
</code></pre>

<p>Your code does what you intend. <code>-1</code> is the second largest number (<code>400</code> is the largest). If you want <code>-169</code>, then you want the 3rd largest. Remember:</p>

<p><strong>ALWAYS INITIALIZE YOUR VARIABLES</strong></p>
",0
25496518,25493707,0,"<p>here's a working and simpler version :</p>

<pre><code>  #include &lt;stdio.h&gt;
  #include &lt;limits.h&gt;

  int main(int argc , char** argv)
  {
    int m1 , m2 , rc = 1;
    m1 = m2 = INT_MIN ;

    while(rc)
    {
            scanf(""%d"" , &amp;rc);
            if(rc &gt; m1)
                    m1 = rc;
            else if(rc &lt; m1 &amp;&amp; rc &gt; m2)
                    m2 = rc;

    }
    printf(""%d\n"" , m2);

  }
</code></pre>
",0
25495974,25495943,0,"<p>The problem is here:</p>

<pre><code>char* ch;
</code></pre>

<p>this is just a char pointer, it needs to point to allocated memory to hold the string:</p>

<pre><code>char ch[32];
</code></pre>
",2
25495985,25495943,4,"<blockquote>
  <p>In the video they show the following code snippet: [...]</p>
</blockquote>

<p>If this is a snippet that they say should work, stop watching that video: the snippet has undefined behavior, there is no chance that it would work properly unless by an unlucky coincidence.</p>

<blockquote>
  <p>I've decided to make my own little program and test it.</p>
</blockquote>

<p>Your program has the same exact problem: the buffer to which <code>sprintf</code> is writing has not been initialized. Change the declaration of <code>ch</code> to allocate some space to it, like this:</p>

<pre><code>char ch[20];
</code></pre>

<p>This will prevent your code from writing to memory pointed to by an uninitialized pointer, fixing the undefined behavior.</p>

<blockquote>
  <p>Could you explain to me how char* could be used?</p>
</blockquote>

<p>If you would like to use <code>char*</code>, assign it a result of <code>malloc</code> of a proper size, and <code>free</code> the result at the end:</p>

<pre><code>char *ch = malloc(20);
... // Put the rest of the code here
// Add this line before the end:
free(ch);
</code></pre>
",8
25496010,25495943,2,"<p>You need to alocate memory for ch or else use an array instead of a pointer.</p>

<pre><code>char* ch = malloc(sizeyouwant * sizeof(char));
</code></pre>

<p>Where sizeyouwant is the number of characters you will store.</p>
",5
25545116,25544867,4,"<p>There does not need to be any logic to compiler warnings. Compilers try to produce useful warnings about issues you may want to know about, and to avoid wasting your time with false positives. Any heuristic that satisfies this two conflicting goals may be implemented in a compiler.</p>

<p>The most likely explanation here is that in <code>myFunct(5000)</code>, it is obvious that the <em>conversion</em> fails to preserve the value, whereas in <code>myFunct(test)</code>, it is not obvious looking only at the function call. Warning about the latter would require knowing the value of <code>test</code> at that point, and the compiler may not have the mechanisms to determine that the value of <code>test</code> at that point it <code>5000</code>.</p>

<p>Although it is obvious that the value of <code>test</code> is always <code>5000</code> in this particular example, the fact that a mechanism to predict the values of variables wouldn't work well in all cases (non-const variables the values of which are difficult to predict) may discourage compiler writers to even attempt to implement such a warning.</p>

<p><em>Static analyzers</em> settle for different goals than compilers. They try to predict values of variables in at least the easy cases, and some of them may be configurable to warn for <code>myFunct(test)</code> in your example. Most static analyzers still reserve the right not to warn if they aren't certain that a problem is present, and you never know what they will be certain about or not. But you would have a better chance of getting a warning with a static analyzer than with a compiler.</p>

<p><sub>Note that what happens to the argument of <code>myFunct</code> in <code>myFunct(5000)</code> is a <em>conversion</em>. A <em>cast</em> is a syntactic construct. There is no such thing as an ¡°implicit cast¡±.</sub></p>
",2
25545115,25545003,-1,"<p>this is historic. 7 bits are all you needed for US-ASCII Characters plus control characters (CR, LF, RET, BS, ...), so you had one bit left for other use (EOF f.e.). To represent this, char was designed as signed.</p>
",0
25676326,25676290,2,"<p>There's a direct equivalence between regular expressions and finite automata.  Here's a summary of the regular expression to nondeterministic finite automaton conversion, with performance analysis: <a href=""http://swtch.com/~rsc/regexp/regexp1.html"" rel=""nofollow"">http://swtch.com/~rsc/regexp/regexp1.html</a>.  It also covers converting NFAs to DFAs.</p>
",1
26197157,26197091,1,"<pre><code>while (cur_factor &lt; n) {

            // Found a factor.
            while (n%cur_factor == 0) {

                n = n/cur_factor;
               count++;
            }
          while(count--)
          printf(""%d x "", cur_factor);
          count=0;

            // Going to the next possible factor.
            else
                cur_factor++;
        }
</code></pre>
",0
26197182,26197091,0,"<p>Use a variable <code>power</code> to keep track of the exponent and print it.</p>

<p>Also use a <code>while</code> loop to keep dividing <code>n</code> by <code>cur_factor</code> until <code>n</code> cannot be divided anymore by that factor.</p>

<pre><code>    int cur_factor = 2;
    int power = 0;
    while (cur_factor &lt; n) {

        // Found a factor.
        while (n % cur_factor == 0) {
            power++;
            n = n/cur_factor;

        }

        // Going to the next possible factor.
        if (power &gt; 0) 
            printf(""%d^%d x"", cur_factor, power);
        power = 0;
        cur_factor++;
        }
    }
</code></pre>
",0
26442060,26441991,3,"<p>There are few guarantees for how a pointer is printed with <code>%p</code>, the standard just mandates ""some implementation-defined manner"":</p>

<blockquote>
  <h3>7.21.6.1 The <code>fprintf</code> function</h3>
  
  <p><code>p</code> The argument shall be a pointer to <code>void</code>. The value of the pointer is
  converted to a sequence of printing characters, in an implementation-defined
  manner.</p>
</blockquote>

<p>Thus, the implementation must document how it prints, but is free to choose any suitable format, like ""hexadecimal without leading zeroes, including prefix <code>0x</code>"" (that is a variant of <code>%#X</code> with suitable length and converted argument).</p>

<p>If that representation has a different number of significant (not leading-zero) digits for two pointers, you get output of different length.</p>
",0
26442847,26441991,0,"<p>Were these done in the same run of the same program?  Were the programs compiled differently?  Optimized differently?  I used to program using Borland C on DOS which would compile and link for different memory models, all of which could run on the same machine.</p>

<p>Lots of different things can happen during compiling, linking, and running.  Compiling is going to reduce your code to machine language that is understood by the processor.  These may have near and far pointers, depending on whether or not the target of the pointer is on the same memory page or not.  Was one variable declared locally, in which case it may have been allocated on the runtime stack, and the other globally, which may have been allocated on the heap?</p>

<p>I would try to read too much into the actual pointer values.</p>
",0
28202086,28201665,3,"<p>Even if you type several characters and hit Enter the getchar() would return one character at a time for each invocation. </p>

<p>So for the first iteration, <code>i=0</code> and <code>c='h'</code> --> <code>s[0]='h'</code>. On the second iteration <code>s[1]='e'</code>, on the third <code>s[2]='l'</code>, etc.</p>
",1
28202005,28201665,0,"<p>What the code does is fetch one character from the input stream at a time, and then store the character at the <code>i</code>th position in the <code>s</code> array, then it increments <code>i</code>.</p>

<p>It tests for two conditions, if <code>i == lim - 1</code> then the loop ends, and the <code>'\0'</code> is appended at the <code>lim</code> position in the array, if a <code>'\n'</code> was encounterd or the <code>EOF</code> end of file was reached, then the loop also ends.</p>

<p>In case the last character read was <code>'\n'</code> then it's appended at the <code>i</code>th position, and <code>i</code> is incremented, and then a <code>'\0'</code> is appended at new <code>i</code>th position.</p>

<p>If not, then just append <code>'\0'</code> at the <code>i</code>th position, and return.</p>

<p>No character will be read until the <kbd>Enter</kbd> key is pressed, so the loop will actually start running after the moment <kbd>Enter</kbd> is pressed, and the algorithm will do what I describe.</p>
",3
30133307,30133210,6,"<p>it does'nt work because you have to fopen it and fseek to the end first:</p>

<pre><code>FILE *fptr;
if ( !( fptr = fopen( ""saving.txt"", ""r"" ))){
    printf( ""File could not be opened to retrieve your data from it.\n"" );
}
else {
    fseek(fptr, 0, SEEK_END);
    unsigned long len = (unsigned long)ftell(fptr);
    if (len &gt; 0) {  //check if the file is empty or not.
        rewind(fptr);
        while ( !feof( fptr ) ){
            fscanf( fptr, ""%f\n"", &amp;p.burst_time );
            AddProcess(&amp;l,p.burst_time);
        }
    }
    fclose( fptr );
}
</code></pre>
",7
30133326,30133210,3,"<p>Call <code>ftell()</code> does not tell you the size of the file, it tells you the current value of the file position indicator which, when you first open the file, will always be 0.</p>

<p>Using <a href=""http://pubs.opengroup.org/onlinepubs/009695399/basedefs/sys/stat.h.html"" rel=""nofollow"">sys/stat.h</a> and call the value of the <code>st_size</code> member, if its 0, your file is empty.  </p>

<p>So basically, </p>

<pre><code>#include &lt;sys/stat.h&gt;
char* filename; //I'm assuming this was defined somewhere earlier in your code
FILE *fptr;
struct stat fileStat;
stat(filename, &amp;fileStat)

if( fileStat.st_size !=0 ){   //check if the file is not empty.
    if ( !( fptr = fopen( ""saving.txt"", ""r"" ))){
        printf( ""File could not be opened to retrieve your data from it.\n"" );
    }
    else{
        while ( !feof( fptr ) ){
            fscanf( fptr, ""%f\n"", &amp;p.burst_time );
            AddProcess(&amp;l,p.burst_time);
        }
    fclose( fptr );
}
</code></pre>

<p>}</p>

<p>Hope this helps.</p>
",1
30133993,30133210,1,"<p>You can use <code>fseek</code> to the end, then check if <code>ftell</code> returns <code>0</code>.</p>

<pre><code>bool isEmpty(FILE *file){
    long savedOffset = ftell(file);
    fseek(file, 0, SEEK_END);

    if (ftell(file) == 0){
        return true;
    }

    fseek(file, savedOffset, SEEK_SET);
    return false;
}
</code></pre>

<p>or you can use <code>sys/stat.h</code> and call the value of the <code>st_size</code> struct member:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/stat.h&gt;

int main (int argc, char *argv[]) {
   if (argc != 2) {
   return EXIT_FAILURE;
   }

   const char *filename = argv[1];
   struct stat st;

   if (stat(filename, &amp;st) != 0) {
       return EXIT_FAILURE;
   }
   fprintf(stdout, ""file size: %zd\n"", st.st_size);
   return EXIT_SUCCESS;
}
</code></pre>
",0
31216746,31216604,2,"<p>Since you are not using standard C strings, and instead want to create your own type of string, you can't use common C methods to loop through your string. I suggest you make a data structure like</p>

<pre><code>struct string {
    const char *text;
    int length;
};
</code></pre>

<p>that keeps track of the length of the string. Loop using the additional length information. You will probably have to create your own versions of many of the C standard library functions that handle strings, and conversion and factory functions would be useful.</p>

<p>Here are a couple of examples of string implementations in C that keep track of length:</p>

<p><a href=""http://bstring.sourceforge.net/"" rel=""nofollow"">bstring</a> by Paul Hsieh</p>

<p><a href=""https://github.com/kev009/cii/blob/master/include/text.h"" rel=""nofollow"">Text</a> from D. R. Hanson's C <em>Interfaces and Implementations</em></p>

<p>Otherwise, just use null-terminated strings as this is the default in C. For example, string literals end with a null character.</p>
",0
31216812,31216604,0,"<p>Replace  <code>while(s!=NULL)</code> with <code>while(*s!=NULL)</code>.</p>
",1
26224864,26224623,0,"<p>Works perfectly for me:</p>

<pre><code>Enter grade, -1 to end: 5
Enter grade, -1 to end: 5
Enter grade, -1 to end: 4
Enter grade, -1 to end: 3
Enter grade, -1 to end: -1
Class average is 4.25



$ gcc --version
gcc (Ubuntu/Linaro 4.6.3-1ubuntu5) 4.6.3
</code></pre>
",1
26224962,26224623,-1,"<pre><code>#include &lt;stdio.h&gt;
int main (void) {
    unsigned int counter;
        int grade;
        int total;
        float average;
        total = 0;
        counter = 0;
        grade = -2;

        fflush(stdin);
        while (grade != -1) {
            printf( ""%s"", ""Enter grade, -1 to end: "" );
            scanf( ""%d"", &amp;grade);
            total = total + grade;
            counter = counter + 1;
        };

        if ( counter != 0 ) {
            average = (float) total / counter;
            printf( ""Class average is %.2f\n"", average);
        } 
        else {
            puts( ""No grades were entered"" );
        }
        return 0;
    }
</code></pre>
",3
26225008,26224623,0,"<p>If you know how to use a debugger, you might try that. Sometimes debuggers and interactive programs get along poorly, so you could read the input from a file instead of standard input to make the debugger happy.</p>

<p>If you aren't yet handy with a debugger, a good place to start is to add some debug code to echo the figures you're using. For example, after exiting the loop, add this:</p>

<pre><code>printf(""counter = %d, total = %d\n"", counter, total);
</code></pre>

<p>One possible problem is in the division particularly if you're using a dubious compiler, as your comment on another reply hints). The precedence for cast is <em>supposed</em> to be higher than division, but you might try casting both numbers to float:</p>

<pre><code>average = (float) total / (float) counter;
</code></pre>

<p>You could also try a general <code>%f</code> on the results print.</p>
",3
26225028,26224623,-1,"<p>In UNIX/Linux environment, the STDIN keyboard-mapped file IO will be initialized. Therefore, in GCC/G++, it might work.</p>

<p>In Visual C/C++, it might not work.</p>

<p>Issue:</p>

<ul>
<li>Firstly, in strict coding, your C variable, grade, should get grade value first prior to the while-loop block. That might cause the issue depending on your OS environment. </li>
</ul>

<p>To make it run on every standard C environment, you will be able to clear the stdard input file system first. </p>
",0
26236462,26236353,1,"<p>1->
You need to allocate memory to <code>argsWithoutFile</code>
 using <code>new</code>/<code>malloc</code> before doing <code>strncpy</code>
2->
filename is not initialized and you are printing it in printf. this is Undefined behavior.</p>
",0
26236474,26236353,1,"<pre><code>  struct redirCode {
        /* For code:
         * 0 = none
         * 1 = stdin
         * 2 = stdout
         */
        int code;
        char *argsWithoutFile;
        char *fileName;
    };
</code></pre>

<p>You need to allocate memory for structure member named <code>char *argsWithoutFile;</code> and <code>char *fileName;</code> before using it.</p>

<p>You can do like this</p>

<pre><code>struct redirCode *redirToReturn = malloc(sizeof(struct redirCode ));
redirToReturn-&gt;argsWithoutFile = malloc(1024);
redirToReturn-&gt;fileName = malloc(1024);
</code></pre>
",0
28155748,28155706,1,"<p>Since almost assuredly <code>buff</code> is a local array, it is stack allocated and fread is overwriting your stack including j since most likely <code>40 - sizeof(int) - 4</code> is greater than <code>sizeof(buff)</code>.</p>

<p>Yeah - there's your problem. <code>sizeof(buff) = sizeof(int)</code>, so assuming <code>sizeof(int)</code> is 4, you're asking to read 40 bytes, which will overwrite 36 bytes past buff.</p>

<p>If you're trying to read an array of ints, you should declare an array of ints (and read no more than its size).</p>

<p>If you're trying to read 40 ints, you should do something like this:</p>

<pre><code>int buff[40];
size_t amountRead = fread(buff, sizeof(int), 40);
</code></pre>

<p>or if it makes you happy.</p>

<pre><code>int buff[40];
size_t size = sizeof(buff);
size_t amountRead = fread(buff, size, 1);
</code></pre>

<p>The latter is better in that the code will work independent of changes to the the dimension of buff.</p>

<p>And just to stave off future questions, it looks like you can read and write structs using <code>fread</code>, and you can, but this is not a portable serialization strategy (mostly due to byte ordering, data type sizes and struct padding differences on differenct computers or compiler configurations).</p>

<p>It also looks like you can serialize arrays of integers with <code>fread</code>, and you can, but it is also not portable because of data type size differences and byte ordering differences.</p>

<p>As long as you're on one computer, one compiler, one set of compiler settings, you're OK.</p>
",3
28155822,28155706,2,"<p>The prototype of fread is </p>

<pre><code>size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)
</code></pre>

<p>Where </p>

<p><code>size</code> This is the size in bytes of each element to be read.</p>

<p>In your case you are trying to read 32 bytes into 4 byte int which is undefined behavior.</p>

<p>If you have <code>int buff[40];</code></p>

<p>The buff can hold 40 integer elements so the call can be like</p>

<pre><code>fread(buff,sizeof(buff),1,inp);
</code></pre>
",2
28184530,28184508,5,"<p>You can use the combination of strerror and the fprintf.</p>

<p>Consider,</p>

<pre><code> fprintf(stderr,""%s:Error NO:%d\n"",strerror(errno),number);
</code></pre>
",0
28184534,28184508,4,"<p>You may use <a href=""http://www.tutorialspoint.com/c_standard_library/c_function_sprintf.htm"" rel=""nofollow"">sprintf</a> for that.
Then use the result in <code>perror</code>.</p>
",0
28184537,28184508,1,"<p>No, not a standard version of <code>perror()</code> anyway.
Instead I would simply use <code>fprintf()</code> to <code>STDERR</code>. You could <code>#define</code> so the name is more descriptive, but either way <code>fprintf</code>(stderr, .....)` will do the job simply enough.</p>
",0
27134519,27134426,1,"<p>There are three problems with your code:</p>

<ul>
<li>You are trying to free components of <code>struct student</code>. Since these component arrays were not allocated with <code>malloc</code>, you cannot free them; you need to free only the <code>struct</code> itself.</li>
<li>You are using <code>gets</code>, which can cause buffer overruns. You should use <code>fgets</code> instead, passing buffer size, and <code>stdin</code> for the <code>FILE*</code> parameter.</li>
<li>You copy <code>s[100]</code> into <code>info-&gt;name</code>. This can potentially overrun the buffer, because <code>info-&gt;name</code> fits only 25 characters.</li>
</ul>

<p>Once you fix these issues, your program should run correctly.</p>
",0
27134522,27134426,1,"<p>It should be:</p>

<pre><code>int i;
for (i = 0; i &lt; count; i++) {
    free(studptr[i]);
}
</code></pre>

<p>Since you allocated each <code>student</code> as a single block, you free them the same way.</p>
",0
26452117,26452061,0,"<p>This is non-deterministic behavior. The array is 5 characters in memory, but scanf is not safe. It is putting all 8 characters into sequential memory starting at c[0] although 3 of the characters are technically not part of the array c. The last three characters may end up getting changed by some other application or function because they are not owned by the array c.</p>

<p>If you use the proper scan_s function it will throw an error when you try to do this. You should always use the ""safe"" functions for this.</p>

<p>Any array like this is actually a pointer to the first element of the array and the [5] indicates a 5 memory location offset from the first memory location defined by ""c"". You can freely set the number inside [] to any offset although it may go outside the bounds of what you allocated to c.</p>
",3
26452127,26452061,0,"<p>In C, arrays have no bound-check. So basically, if you declare a 5-element array, you could store 100 elements in it and, if you are lucky (here, by lucky I mean to not overwrite some other, important things, that affect the program execution), it will work. But it is dangerous and wrong. It's your responsibility to make sure this will not happen. </p>
",0
26452143,26452061,0,"<p>the variable c is allocated into the stack, when allocating space into the stack, the compiler may allocate more than what you're function really need so, that why when you write 8 character into the stack of the function main, you don't receive a segmentation fault.</p>

<p>you should change you're code and use :</p>

<pre><code>fgets(c, sizeof c, stdin);
</code></pre>
",1
27675836,27675829,2,"<pre><code>for (i = 0; i &lt; 0; ++i)
</code></pre>

<p>This is wrong.</p>
",6
27675852,27675829,4,"<p>This:</p>

<pre><code>printf(""digits ="");
for (i = 0; i &lt; 0; ++i)
    printf("" %d "", ndigit[i]);
</code></pre>

<p>has a broken middle part in the <code>for</code> loop's header; <code>i &lt; 0</code> will not be true (ever!) so the loop will not run.</p>
",4
26797327,26794889,0,"<p><code>fopen</code> opens a file.</p>

<p><code>fscanf</code> reads from a file and splits what is read into bits according to a format specification (e.g. <code>""%d %s""</code> means an integer followed by whitespace followed by a string of non-whitespace characters).</p>

<p><code>qsort</code> is a standard library function that will sort an array.  It sorts the array by comparing one item to another item.  You give it the name of a function (which you write) that does this comparison.</p>

<p>I encourage you to read the manual pages for these functions if you are not familiar with them.</p>

<p>The program below uses all this to:</p>

<ol>
<li>Open a file <code>test.txt</code> </li>
<li>Read lines from the file into an array <code>arr</code></li>
<li>Sort the array using <code>qsort</code>, using the rowcmp function (rowcmp looks at the numerical value in the first column to determine whether one element is greater than, equal to, or less than another element)</li>
<li>Print out the elements of the array.</li>
</ol>

<p>The code...</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define MAXLEN 100
#define MAXITEMS 100

// A row has two columns, the first is a number and
// the second is any string of up to MAXLEN chars
struct row {
    int col1;
    char col2[MAXLEN];
};

// Function to do comparison of rows
// Sorts numerically on the value in the first column
int rowcmp(struct row * r1, struct row * r2) {
    if (r1-&gt;col1 &lt; r2-&gt;col1) return -1;
    if (r1-&gt;col1 == r2-&gt;col1) return 0; 
    return 1; 
}

int main(int argc, char ** argv) {

    struct row arr[MAXITEMS]; // up to MAXITEMS rows
    int rows = 0, i;
    FILE * stream = fopen(""test.txt"", ""r"");

    // Read in rows and put first and second columns into struct,
    // building up an array
    while (fscanf(stream, ""%d %s"", &amp;(arr[rows].col1), arr[rows].col2) !=EOF) {
        rows++;
    }

    // Sort the array using the rowcmp function to compare items
    qsort(&amp;arr[0], rows, sizeof(struct row), (__compar_fn_t)rowcmp);

    fclose(stream);

    // Print the sorted array
    for (i=0; i&lt;rows; i++) {
        printf(""%d\t%s\n"", arr[i].col1, arr[i].col2);
    }
}
</code></pre>

<p>With input file:</p>

<pre><code>1 apple
3 cucumbers
21 dates
7 figs
4 grapes
</code></pre>

<p>output is</p>

<pre><code>1   apple
3   cucumbers
4   grapes
7   figs
21  dates
</code></pre>
",0
26812347,26812317,1,"<p>You're calling <code>scanf()</code> incorrectly. You need to give the address of the variables to store into:</p>

<pre><code>scanf(""%c"", &amp;selection);
</code></pre>
",1
31151215,31151174,0,"<p>Order of operations and integer overflow. If <code>n</code> is large, option B keeps the intermediate value the lowest. Option D gives a <code>double</code> which is not percise and still may overflow in the first part of the calculation.</p>

<p>Option C fails because the intermediate <code>n(n-1)/3</code> may not be an integer.</p>
",1
27127487,27127427,1,"<p>The problem is here</p>

<pre><code>return k_vector_calculation(&amp;krec[3]);
</code></pre>

<p>You have passed an <code>int</code> array <code>krek[3]</code> in which the valid locations are <code>krek[0]</code>,<code>krek[1]</code> and <code>krek[2]</code>.Also,you have an infinite recursion as you call the function again and again in the last <code>return</code> statement.</p>
",4
28196056,28195602,4,"<p>The reason for the warning is that char values are usually positive, but sometimes they may be negative; this may come unexpected to the programmer (especially because on some implementations char is always positive), and using a negative index for an array is obviously a bad thing. </p>

<p>isalpha does exactly that behind your back. You fix the warning by casting the char to int or by storing it in an int in the first place - this doesn't fix the problem though, because a negative char will be cast to a negative int which has exactly the same problem. You can fix the warning and the problem by casting the char to an unsigned char. </p>
",2
28196064,28195602,3,"<p>So if we look at the <a href=""https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html"" rel=""nofollow"">gcc document for warnings which covers -Wchar-subscripts</a> it says:</p>

<blockquote>
  <p>Warn if an array subscript has type char. This is a common cause of error, as programmers often forget that this type is signed on some machines. This warning is enabled by -Wall. </p>
</blockquote>

<p>It is implementation defined whether <em>char</em> is signed or unsigned, if you use an <em>unsigned char</em> then the warning will go away.</p>

<p>We can see from the draft C99 standard that the arguments to functions in <code>&lt;ctype.h&gt;</code> are expected to be representable as <em>unsigned char</em> or <code>EOF</code>, from section <code>7.4</code> <em>Character handling &lt;ctype.h&gt;</em>:</p>

<blockquote>
  <p>In all cases the argument is an int, the value of which shall be
  representable as an unsigned char or shall equal the value of the macro EOF. If the
  argument has any other value, the behavior is undefined</p>
</blockquote>

<p>So most likely <code>isalpha</code> and <code>isblank</code> are implemented as a macro which uses a lookup table and so this code would indeed be using a char to index an array.</p>
",1
28196070,28195602,0,"<p>The input type of <code>isalpha</code> and <code>isblank</code> is expected to be <code>int</code>, not <code>char</code>. That's the core issue. The rest are details of how those are implemented. If use the <code>-E</code> flag to just pre-process the code, the function <code>can_print_it</code> expands to:</p>

<pre><code>int can_print_it(char ch)
{
    return (((__ctype_ptr__+sizeof(""""[ch]))[(int)(ch)])&amp;(01|02)) || __extension__ ({ __typeof__ (ch) __x = (ch); (((__ctype_ptr__+sizeof(""""[__x]))[(int)(__x)])&amp;0200) || (int) (__x) == '\t';});
}
</code></pre>

<p>As you can see, the input, <code>ch</code>, is used as an array index in the implementation of <code>isalpha</code>. A temporary, <code>__x</code>, which is of the same type as <code>ch</code>, is use as an array index in the implementation of <code>isblank</code>.</p>

<p>You can fix the warnings by:</p>

<ol>
<li><p>Changing the argument type of <code>can_print_it</code> to <code>int</code>.</p>

<pre><code>int can_print_it(int ch)
{
    return isalpha(ch) || isblank(ch);
}
</code></pre></li>
<li><p>Creating a temporary variable in the function and using it to call <code>isalpha</code> and <code>isblank</code>.</p>

<pre><code>int can_print_it(char ch)
{
    int temp = ch;
    return isalpha(temp) || isblank(temp);
}
</code></pre></li>
</ol>
",11
28196167,28195602,0,"<p>It would appear that your compiler is old or broken. GCC 4.9.1 compiles this code with no warnings/errors, given:</p>

<pre><code>gcc test.c -std=c11 -pedantic-errors -Wall -Wextra
</code></pre>

<p>The compiler is obliged to implicitly promote your char to the int that the isalpha etc functions require. It will do this promotion no matter the implementation-defined signedness of char. The size of char should not matter either, since char is always a small integer type.</p>

<p>The only kind of warning I'd expect a compiler to give from this code is something along the lines of ""implicit conversion from char to int"".</p>
",0
29201777,29197280,1,"<p>$ man strtok</p>

<p>is your friend.  The routine eats all occurrences of the delimiter group and returns the address of a null-terminated string.</p>

<p>Don't try to count the spaces, count the number of times strtok(3) returns a non-null value.</p>
",0
31863193,31862682,1,"<p><code>feof</code> returns true (1) if you have previously attempted to read past the end of the file, and have not cleared it with <code>clearerr</code>.  When you first open the file and haven't read anything, you haven't read past the end, so it returns 0.</p>

<p>This behavior is why using <code>while(feof(infile) != 0)</code> is <a href=""https://stackoverflow.com/questions/5431941/why-is-while-feof-file-always-wrong"">almost always wrong</a>.  Instead, you should check the return value of your <code>fread</code> call and use that to control the loop.</p>
",3
29453281,29452976,0,"<p>There's a \n left in the input buffer.
One solution is:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define MAX_SONG_SIZE 501

int main(void){
    int t;
    scanf(""%d"", &amp;t);
    getchar();

    char song[MAX_SONG_SIZE];
    while(t--){
        fgets(song, MAX_SONG_SIZE * sizeof(char), stdin);
        printf(""foo\n"");
    }
    return 0;
}
</code></pre>

<p>See also:
<a href=""https://stackoverflow.com/questions/7898215/how-to-clear-input-buffer-in-c"">How to clear input buffer in C?</a></p>
",0
29453007,29452976,3,"<p>There's a <code>\n</code> left in the input buffer, see <a href=""http://c-faq.com/stdio/scanfinterlace.html"" rel=""nofollow"">http://c-faq.com/stdio/scanfinterlace.html</a></p>

<p>A quote from the link:</p>

<blockquote>
  <p>As a general rule, you shouldn't try to interlace calls to scanf with
  calls to gets() (or any other input routines); scanf's peculiar
  treatment of newlines almost always leads to trouble. Either use scanf
  to read everything or nothing.</p>
</blockquote>
",3
30165332,30163991,0,"<p>Ok, i wrote some code:</p>

<pre><code>char str[100];
int n, x, i;

scanf(""%d"", &amp;n);

for(i = 0; i&lt;=n; i++){

    fgets(str, sizeof str, stdin);

    if (!strncmp(str, ""insert"", 6)) {
        sscanf(str,""%*[^0-9]%d"", &amp;x);
        insert(&amp;root, x);
        str[0] = '\0';          
    }


    if (!strncmp(str, ""delete"", 6)) {
        sscanf(str,""%*[^0-9]%d"", &amp;x);
        delete(&amp;root, x);
        str[0] = '\0';              
    }


    if (!strncmp(str, ""max"", 3)) {
        max(&amp;root);
        str[0] = '\0';          
    }

    if (!strncmp(str, ""min"", 3)) {
        min(&amp;root);
        str[0] = '\0';      
    }
}   
</code></pre>

<p>Its good solution?</p>

<p>Edit:</p>

<p>Ok its working. Here is full code of main with some new operations:</p>

<pre><code>node *root;
root = NULL;
node *tmp;
tmp = NULL;

char str[100];
int n, x, i;

scanf(""%d"", &amp;n);

for(i = 0; i&lt;=n; i++){
    fgets(str, sizeof str, stdin);

    if (!strncmp(str, ""insert"", 6)) {
        sscanf(str,""%*[^0-9]%d"", &amp;x);
        insert(&amp;root, x);
        str[0] = '\0';          
    }

    if (!strncmp(str, ""delete"", 6)) {
        sscanf(str,""%*[^0-9]%d"", &amp;x);
        tmp = find(root, x);
        if(tmp) removeAVL(&amp;root, tmp);  
        str[0] = '\0';              
    }

    if(!strncmp(str, ""find"", 4)) {
        sscanf(str,""%*[^0-9]%d"", &amp;x);
        tmp = find(root, x);
        if(tmp) printf(""%d\n"", 1);
        else printf(""%d\n"", 0);
        str[0] = '\0';
    }

    if(!strncmp(str, ""inorder"", 7)) { 
        if(root) print_inorder(root);         
        else printf("" "");
        printf(""\n"");
        str[0] = '\0';      
    }     

    if (!strncmp(str, ""max"", 3)) {
        if(root) max(root);
        else printf("" \n"");
        str[0] = '\0';          
    }

    if (!strncmp(str, ""min"", 3)) {
        if(root) min(root);
        else printf("" \n"");
        str[0] = '\0';      
    }
                            }   

return 0;
</code></pre>
",0
28152761,28152595,-1,"<pre><code>if(c == 'f')
    putchar(c);
</code></pre>

<p>This prints one <code>f</code>, the one you see.</p>

<pre><code>while(c == 'f')
    getchar(c);
</code></pre>

<p>This is where the <code>f</code> disappears. If you just used <code>putchar(c)</code> before, that means that the loop will execute at least once <strong>because</strong> <code>c == f</code>. So the <code>f</code> is gone (<code>c != f</code>)</p>

<p>Finally, you just use <code>putchar(c)</code> on the first character which is not <code>f</code>.</p>
",2
28152972,28152595,0,"<p>I'll step through with comments in the code; for <code>f</code> (or in reality <code>f\n</code>) as input:</p>

<pre><code>#include &lt;stdio.h&gt;
main()
{
    int c;
    while ((c = getchar()) != EOF) // You type f and hit return key (remember this)
    {
        if (c == 'f')  // c contains 'f' is true
        {
            putchar(c); // print 'f'
        }
        while (c == 'f') // c == 'f' is true
        {
            c = getchar(); // '\n' is buffered on stdin from return key
                           // so getchar() returns '\n'. So c will be set to '\n'
                           // It goes back to the while loop and checks if c == 'f'
                           // but it's not, it's '\n'! So this will run once only.
        }
        if (c != EOF) putchar(c); // '\n' != EOF, so print '\n' newline, back to loop
    }   
}
</code></pre>

<p>Thus giving <code>f\n</code> as input will yield the output <code>f\n</code></p>

<p>In the case of input <code>fffff</code> (in reality <code>fffff\n</code>), see below:</p>

<pre><code>#include &lt;stdio.h&gt;
main()
{
    int c;
    while ((c = getchar()) != EOF) // You type fffff and hit return key
    {
        if (c == 'f')  // c contains 'f' is true, first 'f'
        {
            putchar(c); // print 'f'
        }
        while (c == 'f') // First loop, c == 'f'
                         // Second loop, c == 'f'
                         // Last loop, c == '\n', so false
        {
            c = getchar(); // First loop: 'ffff\n' is still buffered on stdin
                           // c = 'f', loop again
                           // Last loop: c = '\n'
        }
        if (c != EOF) putchar(c); // '\n' != EOF, so print '\n' newline, back to loop
    }   
}
</code></pre>

<p>You see that your inner <code>while</code> loop will eat all the <code>f</code> until you hit <code>\n</code>, thus the same affect as above.</p>
",6
28182114,28182074,1,"<p>Your Idea is almost correct except because</p>

<ol>
<li>You are copying the <code>'\0'</code> to the begining of the <code>reversed</code> string.</li>
<li>You are <code>scanf()</code>ing into an invalid pointer</li>
<li><p>You are doing the assignment in reverse, i.e. Instead of</p>

<pre><code>normal[i] = reversed[n - i];
</code></pre>

<p>it has to be</p>

<pre><code>reversed[n - i - 1] = normal[i];
/*               ^ you should start at the n - 1 position, and '\0'
 *                 should be at position n.
 */
</code></pre></li>
</ol>

<p>Try this instead</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
    char normal[100]; // initialize the original string
    char reversed[100]; // declare reversed string

    printf(""Give me a word.\n""); // ask for user input        
    if (scanf(""%99s"", normal) != 1) // retrieve input, set variable
        return -1;
    int n = strlen(normal); // retrieve length of string

    for (int i = 0 ; i &lt; n ; i++) {
        /* for i in the original string, the reversed string
         * equals n minus i, to reverse the string one by one 
         */
        reversed[n - i - 1] = normal[i];
    }
    reversed[n] = '\0';

    // print the newly reversed string
    printf(""%s\n"", reversed);

    return 0;
}
</code></pre>
",0
28182150,28182074,1,"<p>You dereference a wild pointer:</p>

<pre><code>char* normal; // uninitialized, points to random location

scanf(""%s"", &amp;*normal);    // write to random location (at best)
</code></pre>

<p>The <code>&amp;*</code> has no effect by the way. Anything else that happens from hereon in is undefined as a result.</p>

<p>To fix this you could write:</p>

<pre><code>char normal[10];
scanf(""%9s"", normal);
</code></pre>

<p>Then your loop goes on and copies from <code>reverse</code> (which is blank) into <code>normal</code>. You probably meant to copy from <code>normal</code> into <code>reverse</code>. The assignment operator is <code>destination = source</code> .</p>

<p>Finally, your loop (if you made that fix) starts from <code>normal[strlen(normal)]</code> which is the null terminator. You need to check <code>n &gt; 0</code> and then start from <code>i = n-1</code> .</p>
",0
28182163,28182074,0,"<p>This should work for you:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define SIZE 30

int main() {

    char normal[SIZE+1], reversed[SIZE+1];
    int n = 0, i = 0;

    printf(""Give me a word.\n"");
    fgets(normal, SIZE, stdin);
    //^ Reads in the text
    n = strlen(normal);


    for(i = n-1; i &gt;= 0; i--)
       reversed[n-i-1] = normal[i];
    //^ Changed, also note that the index starts with 0

    reversed[n] = '\0';
    //^ End string

    printf(""%s\n"", reversed);

    return 0;
}
</code></pre>
",0
28184576,28184389,0,"<p>You have problem with cases.<br>
As you are using  </p>

<pre><code>case '1' :  //Code
            break;
case '2' :  //Code
            break;
case '3' :  //Code
            break;
case '4' : //Code
            break;
</code></pre>

<p>Change this to  </p>

<pre><code>case 1 :  //Code
            break;
case 2 :  //Code
            break;
case 3 :  //Code
            break;
case 4 : //Code
            break;
</code></pre>

<p>because <code>payrate</code> is a integer variable.<br>
Change your function declaration like this:  </p>

<pre><code>void grossCal(double*, double, double);  //make it void and 1st parameter should be of pointer type. 
void taxCal(double, double*);  //make it void type and 2nd parameter should be of pointer type.
</code></pre>
",0
28184604,28184389,1,"<p>You have mismatching function declarations, function calls, and function definitions.</p>

<p><em>Declaration</em></p>

<pre><code>double grossCal(double, double, double);
double taxCal(double, double);
</code></pre>

<p><em>Usage</em></p>

<pre><code>  case '1' :  grossCal(&amp;gross, pay1, hours); // &amp;gross is not double
              taxCal(gross, &amp;taxes);         // &amp;taxes is not double.
              break;
  case '2' :  grossCal(&amp;gross, pay2, hours);
              taxCal(gross, &amp;taxes);
              break;
  case '3' :  grossCal(&amp;gross, pay3, hours);
              taxCal(gross, &amp;taxes);
              break;
  case '4' :  grossCal(&amp;gross, pay4, hours);
              taxCal(gross, &amp;taxes);
</code></pre>

<p><em>Implementation</em></p>

<pre><code>double grossCal(double *grossPay, double pay, double hours){
...

double taxCal(double gross, double *taxestotal){
...
</code></pre>

<p>Your usage and implementation match even though the functions don't return anything.</p>

<p>You can clean things up by:</p>

<p><strong>Minimal Changes</strong></p>

<p><em>Change the declarations</em></p>

<pre><code>void grossCal(double*, double, double);
void taxCal(double, double*);
</code></pre>

<p><em>Keep the current usage</em></p>

<p><em>Change the implementations</em></p>

<pre><code>void grossCal(double *grossPay, double pay, double hours){
...

void taxCal(double gross, double *taxestotal){
...
</code></pre>

<p><strong>Slightly More Change But Way Better</strong></p>

<p><em>Interfaces</em></p>

<pre><code>// Return the gross pay
double grossCal(double pay, double hours);

// Return the taxes.
double taxCal(double);
</code></pre>

<p><em>Usages</em></p>

<p>Simplify it so that there is minimal duplicate code. Add a new variable
 called pay.</p>

<pre><code>  case 1 :  pay = pay1;
            break;
  case 2 :  pay = pay2;
            break;
  case 3 :  pay = pay3;
            break;
  case 4 :  pay = pay4;
            break;
</code></pre>

<p>After the switch statement,</p>

<pre><code>  gross = grossCal(pay, hour);
  taxes = taxCal(gross);
</code></pre>

<p><em>Implementations</em></p>

<pre><code>double grossCal(double pay, double hours){
   if (hours &lt;= BASEHRS)
      return (hours * pay);
   else
      return (BASEHRS * pay + (hours - BASEHRS) * pay * OVERTIME);
}

double taxCal(double gross){
   if (gross &lt;= AMT1)
      return (gross * RATE1);
   else if (gross &lt;= AMT1 + AMT2)
      return (AMT1 * RATE1 + (gross - AMT1) * RATE2);
   else
      return (AMT1 * RATE1 + AMT2 * RATE2 + (gross - AMT1 - AMT2) * RATE3);
}
</code></pre>
",0
28205357,28205315,3,"<p>In C all arguments are passed by-value, so if you want a by-ref-like argument you must pass a pointer. And since you want to return a <code>float*</code> you need to pass a <code>float**</code>.</p>

<p>Actually you are passing that, but you are not using it correctly (please use <code>-Wall</code> or equivalent for your compiler to enable warnings).</p>

<p>The code should like more or less like this:</p>

<pre><code>int  readWav(const char *fname, long *numFrames, int *sRate, float **buffer) 
{
    *buffer = malloc(...);
    //if you do not feel comfortable writing `*buffer` everywhere:
    float *data = *buffer;
    ///....
    *numFrames = sf_readf_float(...);
    ///....
    *sRate = sndInfo.samplerate;
    ///....
}

int main()
{
    long nSamples;
    int sRates;
    float *datas;
    ret =  readWav(argv[1], &amp;nSamples, &amp;sRates, &amp;datas);
    //...
}
</code></pre>
",4
28205447,28205315,1,"<p>You have several errors in your code</p>
<ol>
<li><p>You don't declare <code>readWav()</code> and you call it from <code>main()</code>, it's working by coincidence, namely because it does return <code>int</code>.</p>
</li>
<li><p>You are passing the address of <code>datas</code> to <code>readWav()</code>, note that <code>&amp;datas</code> has type <code>float **</code> and <code>readWav()</code> is expecting a <code>float *</code>.</p>
<p>If you had compiler warnings turned on, youl'd have noticed this.</p>
</li>
<li><p>You are passing the value of <code>nSamples</code> and <code>sRate</code> to <code>readWav()</code> and you are expecting the <code>nSamples</code> and <code>sRate</code> in your main to get initialized, you need to pass their addresses instead.</p>
</li>
<li><p>You check the return value of <code>readWav()</code> and yet you still try to acces the <code>datas</code> pointer.</p>
</li>
</ol>
<p>This is a fixed version of your code</p>
<pre><code>#include &lt;stdio.h&gt;
#include &quot;sndfile.h&quot;

int  readWav(const char *const fname, long *numFrames, int *sRate, float **buffer);

int main(int argc, char *argv[])
{
    int   sRates, sRatem, ret;
    long  nSamples = 0, nSamplem;
    float *datas, *datam;


    printf(&quot;Read Test\n&quot;);
    if (argc != 3) {
        fprintf(stderr, &quot;Expecting two wav file as argument\n&quot;);
        return 1;
    }


    ret = readWav(argv[1], &amp;nSamples, &amp;sRates, &amp;datas);
    if (ret != 0) {
        printf(&quot;Error\n&quot;);
        return 1;
    }
    // Output Info
    printf(&quot;Read %ld frames from %s, Sample rate: %d, Length: %fs\n&quot;,
        nSamples, argv[1], sRates, (float)nSamples/sRates);
    printf(&quot;Read %ld frames from %s, Sample rate: %d, Length: %fs\n&quot;,
        nSamples, argv[1], sRates, (float)nSamples/sRates);
    free(datas);

    return 0;
}

int  readWav(const char *const fname, long *numFrames, int *sRate, float **buffer)
{
    // Open sound file
    SF_INFO sndInfo;

    if ((sRate == NULL) || (numFrames == NULL) || (buffer == NULL)) {
        fprintf(stderr, &quot;Invalid arguments passed to readWav()\n&quot;);
        return 1;
    }

    SNDFILE *sndFile = sf_open(fname, SFM_READ, &amp;sndInfo);
    if (sndFile == NULL) {
        fprintf(stderr, &quot;Error reading source file '%s': %s\n&quot;, fname, sf_strerror(sndFile));
        return 1;
    }

    printf(&quot;1Format of the audio file = %i\n&quot;, sndInfo.format);
    printf(&quot;2Number of channels = %i\n&quot;, sndInfo.channels);
    printf(&quot;3Sample Rate  = %d\n&quot;, sndInfo.samplerate);
    printf(&quot;4 Sample count  = %ld\n&quot;, (long)sndInfo.frames);

    // Allocate memory
    *buffer = malloc(sndInfo.frames * sndInfo.channels * sizeof(float));
    if (*buffer == NULL) {
        fprintf(stderr, &quot;Could not allocate memory for file\n&quot;);
        sf_close(sndFile);

        return 1;
    }

    *sRate = sndInfo.samplerate;
    // Load data
    *numFrames = sf_readf_float(sndFile, *buffer, sndInfo.frames);
    // Check correct number of samples loaded
    if (*numFrames != sndInfo.frames) {
        fprintf(stderr, &quot;Did not read enough frames for source\n&quot;);
        sf_close(sndFile);
        free(*buffer);
    }
    else {
        printf(&quot;Successfully read file\n&quot;);
        *numFrames = sndInfo.frames;
    }
    // Output Info
    printf(&quot;Read %ld frames from %s, Sample rate: %d, Length: %fs\n&quot;,
        *numFrames, fname, *sRate, (float)*numFrames/sndInfo.samplerate);

    sf_close(sndFile);
    return(0);

}
</code></pre>
<p><strong>Tip</strong>: You should try to write your function in such a way that it has only one exit point, I like using <code>goto</code> for that, despite what religious programmers believe about <code>goto</code>, it makes your code more readable consistent and maintainable.</p>
<p>What I mean is you can have a label where you return the error code from the function and do all the cleanup, something like this</p>
<pre><code>int function()
{
    /* set errorCode */
    if (firstFailureCondition == 1)
        goto cleanup;
    if (secondFailureCondition == 1)
        goto cleanup;
                 .
                 .
                 .
    if (nthFailureCondition == 2)
        goto cleanup;
cleanup:
    /* do your cleanup */
    return errorCode;
}
</code></pre>
",13
28227298,28227114,1,"<p>If you <code>NULL</code> terminate your character array, then it is effectively a string representation of a number as far as C is concerned.  You can then just use <code>atoi()</code> directly on it:</p>

<pre><code>int data_int;
char data_str[N+1];

for (i = 0; i &lt; N; i++)
{
    data_str[i] = fgetc(fp);

    /* to be really sure, you should make sure each character
     * you read is a decimal digit from '0' - '9'
     */

}

data_str[N] = '\0';
data_int = atoi(data_str);
</code></pre>
",0
28227542,28227114,1,"<p>I'm assuming you are interested in reading the lines of data like:</p>

<pre><code>09,08,2014,""BOOK SHOP"",12.34,5.67,
10,08,2014,""CAR MECHANIC"",52.44,5.67,
11,08,2014,""CHIP SHOP"",67.34,5.67,
</code></pre>

<p>It looks like you can use <code>fscanf()</code>, but you need to be careful:</p>

<pre><code>int day[20];
int month[20];
int year[20];
char name[20][15];
double amount[20];
double balance[20];

for (int i = 0; i &lt; 20; i++)
{
    if (fscanf(fp, ""%d ,%d ,%d , \"" %14[^\""] \"" ,%lf ,%lf ,"",
              &amp;day[i], &amp;month[i], &amp;year[i], name[i],
              &amp;amount[i], &amp;balance[i]) != 6)
        break;
}
</code></pre>

<p>You might not need every one of the spaces, and you'll never know whether the final comma on the line was missing.  Note that the code avoids buffer overflows, both by limiting the number of iterations on the loop and by limiting the length of the string field.  I chose <code>15</code> for the length of the names simply so that it is clear which number is the number of entries and which is the length of each entry.</p>

<p>You might prefer the <code>fgets()</code> and <code>sscanf()</code> approach:</p>

<pre><code>int day[20];
int month[20];
int year[20];
char name[20][15];
double amount[20];
double balance[20];
char buffer[4096];
int i;    // Outside loop so it can be accessed after the loop

for (i = 0; i &lt; 20 &amp;&amp; fgets(buffer, sizeof(buffer), fp) != 0; i++)
{
    if (sscanf(buffer, ""%d ,%d ,%d , \"" %14[^\""] \"" ,%lf ,%lf ,"",
              &amp;day[i], &amp;month[i], &amp;year[i], name[i],
              &amp;amount[i], &amp;balance[i]) != 6)
        break;
}
</code></pre>

<p>This will reject lines which don't match, whereas the original code using <code>fscanf()</code> directly would work with data like this:</p>

<pre><code>09,08,2014,""BOOK SHOP"",12.34,5.67,10,08,2014,""CAR MECHANIC"",
52.44,5.67,11,
08,

2014,
""CHIP SHOP"",


67.34,
5.67,
</code></pre>

<p>The code shown more or less replaces the lines in the question from <code>char data[5];</code> through the end of the loop.  You can add code to print the values read.</p>

<pre><code>for (int j = 0; j &lt; i; j++)
    printf(""%.4d-%.2d-%.2d  %-14s  %8.2f  %8.2f\n"",
           year[j], month[j], day[j], name[j], amount[j], balance[j]);
</code></pre>
",5
28530108,28529973,0,"<p>Your <code>make</code> and <code>model</code> members are <code>char *</code> and have not been allocated when you attempt to <code>fscanf</code> them in. That is, <code>update[i].make</code> and <code>update[i].model</code> are undefined pointers to <code>char</code>. You need to allocate them with <code>malloc</code>. Note you need to have space for a terminating null for strings, thus the <code>+ 1</code>:</p>

<p>For example:</p>

<pre><code>for(i=0;i&lt;size1;i++)
{
    update[i].make = malloc(&lt;size of the make string you need + 1&gt;);
    update[i].model = malloc(&lt;size of the model string you need + 1&gt;);
    fscanf(file, ""%d%s%s%d"", &amp;update[i].year, update[i].make, update[i].model, &amp;update[i].miles);
}
</code></pre>

<p>And do not use the address of (<code>&amp;</code>) the <code>char *</code> items (which is the address of the pointer), as shown above.</p>

<p>As Peter Schneider points out in the comments, you could also just define your <code>struct</code> using statically allocated members:</p>

<pre><code>typdef struct{
    int year;
    char make[MAX_MAKE_LEN+1];
    char model[MAX_MODEL_LEN+1];
    int miles;
} Car;
</code></pre>

<p>And given the amount of data you likely have, this is a perfectly reasonable approach. It's good, though, to learn good dynamic memory management techniques for scalability.</p>
",5
28443026,28442922,3,"<ol>
<li><p><a href=""https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc"">Don't</a> cast <code>malloc()</code></p>

<pre><code>struct match *matches = (struct match *) malloc(sizeof(match) * MAX_MATCHES);
</code></pre>

<p>is better as</p>

<pre><code>struct match *matches = malloc(sizeof(struct match) * MAX_MATCHES);
</code></pre></li>
<li><p>Check the result of <code>malloc()</code>, it returns <code>NULL</code> on failure.</p></li>
<li><p>Don't check <code>!feof()</code> because it's <a href=""https://stackoverflow.com/questions/5431941/while-feof-file-is-always-wrong"">always wrong</a>, so change this</p>

<pre><code>while(!feof(fp))
</code></pre>

<p>with</p>

<pre><code>while (fscanf(fp, "" %s %i/%i %i.%i %s - %s %i - %i %i.%i \n"", 
       matches[i].weekday, &amp;matches[i].day, &amp;matches[i].month, &amp;matches[i].hours,
       &amp;matches[i].minutes, matches[i].home_team, matches[i].away_team,
       &amp;matches[i].home_team_goals, &amp;matches[i].away_team_goals,
       &amp;matches[i].spectators_thds, &amp;matches[i].spectators_hdrs) == 11)
</code></pre></li>
<li><p>And this is the most <strong>important</strong>: you iterate until <code>MAX_MATCHES</code> in the <code>printf()</code> loop, when you don't necessarily have read <code>MAX_MATCHES</code>. So you need to keep a count of the successfuly read items, and use that in the second <code>for</code> loop.</p>

<p>You can for example return the count of read items from <code>read_file</code> to main, and use it.</p>

<p>You already have a counter in <code>read_file()</code> but read the next point.</p></li>
<li><p>You never increment <code>i</code> in the <code>while</code> loop in <code>read_file()</code>.</p></li>
<li><p>This is very weired</p>

<pre><code>void read_file(struct match *matches);
</code></pre>

<p>do you mean</p>

<pre><code>read_file(matches);
</code></pre></li>
<li><p>This is incorrect</p>

<pre><code>free(fp);
</code></pre>

<p>you already did <code>fclose(fp)</code> which is the correct way to release a <code>FILE *</code>'s resources, the <code>free()</code> there will cause undefined behavior, which could be a segmentation fault, or any thing else, since it's undefined.</p></li>
<li><p>This makes no sense</p>

<pre><code>while (!fp) { ... }
</code></pre>

<p>you meant</p>

<pre><code>if (!fp) { ... }
</code></pre></li>
<li><p>Your <code>read_file()</code> function only localy allocates the <code>structs</code> and then you have no access to them from <code>main()</code>, what you can do is this</p>

<pre><code>int read_file(struct match **matches)
{
    FILE         *fp;
    int           i;
    struct match *match;        
    if (matches == NULL)
        return 0;
    *matches = NULL;
    fp       = fopen(""superliga-2013-2014"", ""r"");
    if (!fp)
    {
        error(""Cannot open file."");
        return 0;
    }        
    match = malloc(sizeof(struct match) * MAX_MATCHES);
    if (match == NULL)
        return 0;
    while ((fscanf(fp, "" %s %i/%i %i.%i %s - %s %i - %i %i.%i \n"",
               match[i].weekday, &amp;match[i].day, &amp;match[i].month, &amp;match[i].hours,
               &amp;match[i].minutes, match[i].home_team, match[i].away_team,
               &amp;match[i].home_team_goals, &amp;match[i].away_team_goals,
               &amp;match[i].spectators_thds, &amp;match[i].spectators_hdrs) == 11) &amp;&amp; (i &lt; MAX_MATCHES))
    {
        i++;
    }
    fclose(fp);

    *matches = match;
    return i;
}
</code></pre>

<p>and then your <code>main()</code></p>

<pre><code>int main(int argc, char *argv[]) 
{
    int           i;
    struct match *matches;
    int           count;
    count = read_file(&amp;matches);
    for (i = 0 ; i &lt; MAX_count ; ++i) 
    {
        printf("" %s %i/%i %i.%i %s - %s %i - %i %i.%i "",
               matches[i].weekday, matches[i].day, matches[i].month, matches[i].hours,
               matches[i].minutes, matches[i].home_team, matches[i].away_team,
               matches[i].home_team_goals, matches[i].away_team_goals,
               matches[i].spectators_thds, matches[i].spectators_hdrs);
    }
    free(matches);        
    return 0;
}
</code></pre></li>
</ol>
",1
28529326,28528338,0,"<p><code>%llu</code> is not necessarily a valid format specifier for <code>rlim_t</code>. This is the source of the nonsensical huge values; you're invoking UB by passing mismatching types to <code>printf</code>. Cast to <code>long long</code> and the value printed should be correct.</p>
",1
28528456,28528338,1,"<p><code>setrlimit</code> does not return the current value. You need to call <code>getrlimit</code> after setting the value to retrieve the current value.</p>

<pre><code> struct rlimit rl;
 getrlimit (RLIMIT_CPU, &amp;rl);
 rl.rlim_cur = 1;     
 setrlimit (RLIMIT_CPU, &amp;rl);

 getrlimit (RLIMIT_CPU, &amp;rl);
 printf(""The soft limit is %llu\n"", rl.rlim_cur);
</code></pre>

<p>Or you can use <code>prlimit</code> to both set and get in one call <a href=""http://linux.die.net/man/2/prlimit"" rel=""nofollow"">http://linux.die.net/man/2/prlimit</a></p>
",2
28469950,28469917,0,"<p><code>size_t</code> is the type <code>sizeof()</code> returns so use <code>zu</code> format specifier. Using wrong format specifier leads to undefined behavior.</p>

<pre><code>printf(""Storage size for unsigned float : %zu  bytes \n"", sizeof(float));
</code></pre>

<p>Note: <code>%zd</code> is for signed ssize_t</p>
",6
28483529,28483267,3,"<p>The most likely culprit is the following <code>scanf</code> call:</p>

<pre><code>scanf(""%c "",&amp;myChar[i]);
</code></pre>

<p>Change it to the following:</p>

<pre><code>scanf("" %c"", &amp;myChar[i]);
</code></pre>

<p>Note that I switched the blank space to before the <code>%c</code> conversion specifier.</p>

<p>Here's what's happening: when you enter your array size, the input stream will contain the following characters: <code>'5' '\n'</code>.  The first <code>scanf</code> call consumes the <code>'5'</code> and leaves the <code>'\n'</code> in the input stream.</p>

<p>When you enter <code>hello</code>, the input stream contains <code>'\n' 'h' 'e' 'l' 'l' 'o' '\n'</code>.  The next <code>scanf</code> call reads <code>'\n'</code> from the input stream and assigns it to <code>myChar[0]</code> because <code>%c</code> does not skip leading whitespace.  So you wind up reading <code>'\n' 'h' 'e' 'l' 'l'</code> from the input stream and assigning them to your <code>myChar</code> array.</p>

<p>By putting the blank space before the <code>%c</code> conversion specifier, you tell <code>scanf</code> to skip any leading whitespace and consume the next non-whitespace character.  </p>
",0
28483588,28483267,0,"<p>You can also call </p>

<pre><code>fflush (stdin); 
</code></pre>

<p>after the fifth line</p>
",0
28483439,28483267,3,"<p>The problem is with your <code>scanf()</code> change it to</p>

<pre><code>scanf("" %c"",&amp;myChar[i]);
</code></pre>

<p>The space before the <code>%c</code> will consume the newline character in the buffer because of the enter key following the value of <code>x</code> else the newline character will be fetched as by <code>%c</code> in the loop. So have a space before <code>%c</code> not after it.</p>
",0
28483513,28483267,0,"<p>The first <code>scanf</code> isn't <em>eating</em> the return key used to finish the length entry, so it becomes the first of your <code>x</code> characters read, so the last character <em>isn't</em> being read.  @Gopi's fix will address this.</p>
",0
28504471,28504331,4,"<p>In</p>

<pre><code>if (c = 0)
</code></pre>

<p>you're <em>assigning</em> <code>0</code> to <code>c</code>, the expression of the assignment returns the <strong>assigned value</strong>, so the expression will be <em>always</em> evaluated to false as it's equivalent to <code>if(0)</code>, it should be <code>if(c == 0)</code>.</p>

<p>Also </p>

<pre><code>if (c == c + 1)
</code></pre>

<p>doesn't make any sense, what exactly do you mean? I think it should be <code>c &gt; 0</code>.</p>

<p>In all cases, you should use the debugger, it can save you a lot of time, and will help you to really understand your code.</p>
",0
28505613,28505329,0,"<p>The <code>...</code> in <code>OUT(fmt, ..)</code> implies the need to pass at least one more argument then just <code>fmt</code>. Like for example:</p>

<pre><code>OUT(""%s"", ""Hello World"");
</code></pre>

<p>If doing so the <code>##</code> is useless and the macros should look like:</p>

<pre><code>#define LOG(fp, fmt, ...) fprintf((fp), ""%s:%d: ""fmt, __FILE__, __LINE__, __VA_ARGS__) 
#define OUT(fmt, ...) LOG(stdout, fmt, __VA_ARGS__) 
</code></pre>
",0
28505513,28505329,3,"<p>Short explanation because I take from the comments that this was cargo-culted into the code: The <code>##</code> in <code>##__VA_ARGS__</code> is a <strong>non-standard extension</strong> of the preprocessor (originally from gcc, now also supported by clang). Its effect is that if a variadic macro is called with no variadic parameters, a superfluous preceding comma is removed. That is to say, where</p>

<pre><code>#define FOO(bar, ...) foo(bar, __VA_ARGS__)
</code></pre>

<p>cannot be called with one argument because it would expand to <code>foo(argument,)</code>,</p>

<pre><code>#define FOO(bar, ...) foo(bar, ##__VA_ARGS__)
</code></pre>

<p>can because the comma is silently removed and the expansion is <code>foo(argument)</code>.</p>

<p>Therefore, the solution to your problem is to use</p>

<pre><code>//                                     vv--- these are important here
#define OUT(fmt, ...) LOG(stdout, fmt, ##__VA_ARGS__) 
</code></pre>

<p>Otherwise in an expansion of <code>OUT</code> with only one argument, the <code>__VA_ARGS__</code> in <code>LOG</code> will not be empty because it is expanded from</p>

<pre><code>LOG(stdout, ""Hello, world."",)
</code></pre>

<p>instead of</p>

<pre><code>LOG(stdout, ""Hello, world."")
</code></pre>

<p>...and the <code>##</code> before <code>__VA_ARGS__</code> in <code>LOG</code>  will then have no effect. You get the compiler message because there's an extra comma in the expansion of <code>LOG</code> (the <code>fprintf</code> call ends with <code>,)</code>).</p>

<p><a href=""https://gcc.gnu.org/onlinedocs/cpp/Variadic-Macros.html"" rel=""nofollow"">Link to specifics</a>.</p>
",3
28532436,28532075,0,"<p>Change your <code>saisir</code> function as follow, this should work for you. In this code I only corrected you <code>malloc</code> in order to reallocate array and also correct allocation size to allocate based on previous size plus new size and I did not add checking for array out of bound error and ... so this code is not safe.</p>

<pre><code>emp *saisir(emp *t, int *m)
{
    int i, s;
    printf(""\n  Donner le nombre des employes a ajouter : "");
    scanf(""%d"", &amp;s);

    t = realloc(t, (*m + s) * sizeof(emp));
    if (!t) {
         exit(1);
    }

    for (i = *m; i &lt; *m + s; i++)
    {
        printf(""\n\n\n donner les info de %d eme employe \n"" , i + 1);
        printf(""\n le nom : "") ;
        scanf(""%s"", (t + i)-&gt;nom);
        printf(""\n le prenom : "") ;
        scanf(""%s"",(t + i)-&gt;prenom);
        printf (""\n l \' age  : "") ;
        scanf (""%d"", &amp;(t + i)-&gt;age);
        printf (""\n le salaire : "") ;
        scanf (""%f"", &amp;(t + i)-&gt;salaire);
    }
    *m = *m + s ;
    return t;
}
</code></pre>

<p>and if you want to decrease value of <code>m</code> in function <code>trier_non()</code> using <code>*m--</code> you must change it into <code>(*m)--</code>.</p>
",11
28532733,28532075,1,"<p>in function main()
 -- warning: return type defaults to int</p>

<p>-- the function getch() is only available in windows system</p>

<pre><code>suggest using getchar() which returns an int, not a char
       so could also check for EOF and certain I/O failures

Note: getch() is prototyped in conio.h, 

      however, the code is missing the line: $include &lt;conio.h&gt;
</code></pre>

<p>-- execution reaches end of non-void function without a 'return' statement</p>

<p>in function supprimer()</p>

<p>-- this line: '*m--;' calculates a value that is not used</p>

<p>in function trier_non()</p>

<p>-- variable 'min' set but not used</p>

<p>in function trier_age()</p>

<p>-- variable 'min' set but not used</p>

<p>It makes it extremely difficult to debug a program when the program doesn't compile</p>
",1
29457899,29457836,1,"<p>The reason it is always zero is that the inner loop condition is satisfied in the first iteration:</p>

<p><code>for(n=0; n==i; n++)</code></p>

<p>Additionally, your outer loop will never run.  It is written to say that it should <em>only</em> loop when <code>contador == 1000</code>, which can never happen as written.</p>
",1
29458243,29457836,4,"<p>A <code>for</code> loop consist of 3 parts</p>

<pre><code>for( init ; cond ; step )
</code></pre>

<p>When the execution reaches the loop,</p>

<ol>
<li><code>init</code> is executed.</li>
<li><p><code>cond</code> is evaluated.</p>

<ul>
<li>If false, break the loop</li>
<li>If true, proceed to the next step</li>
</ul></li>
<li>Execute the body of the loop.</li>
<li>Do <code>step</code>(in many cases, this is increment/decrement)</li>
<li>Goto step 2</li>
</ol>

<p>So, in your code, when the execution reaches</p>

<pre><code>for (i = 0; contador == 1000; i++)
</code></pre>

<p><code>i</code> is set to 0. Then the condition <code>contador == 1000</code> is checked. It is false as <code>contador</code> is initialized to 0. So, the loop breaks and the execution reaches the <code>printf</code> which prints the value of <code>variavel</code> which is 0 and then</p>

<pre><code>return 0;
</code></pre>

<p>executes. This ends the execution of your program.</p>

<p>Your inner <code>for</code> loop has a somewhat similar issue. If the condition of the outer <code>for</code> loop is corrected, then the inner <code>for</code> loop executes. <code>n</code> is set to zero and then, the condition <code>n==i</code> is checked. It will be true only when <code>i=0</code>,i.e, it will be true only in <em>the first iteration</em> of the outer <code>for</code> loop. </p>

<p>You need to correct these mistakes.</p>
",2
29175514,29175493,6,"<p>No.  <code>fgets</code> guarantees zero termination on a successful read.  Your loop condition handles the unsuccessful case.  For completeness, you should check that the calloc worked though.</p>
",2
29158946,29158779,0,"<p>What you posit is <em>exactly</em> how you should do it. By piping information into your program, it's mostly indistinguishable<sup>(a)</sup> from regular input, as the following transcript shows:</p>

<pre><code>pax$ cat testprog.c
#include &lt;stdio.h&gt;
int main (void) {
        char line[1000];
        while (fgets (line, sizeof(line), stdin)) {
                printf (""%s"", line);
        }
        return 0;
}

pax$ gcc -o testprog testprog.c

pax$ ( echo echo abc;echo echo def;echo echo ghi ) | ./testprog
echo abc
echo def
echo ghi
</code></pre>

<hr>

<p><sup>(a)</sup> There are ways to tell, such as with <code>isatty()</code> but you have to expend some effort. Mostly, input from a file or pipe or device can be treated as if you were entering it on the keyboard yourself.</p>
",1
31856603,31856361,4,"<p>The conversion specifiers (like %u) <em>must</em> match the type of the corresponding value given as argument.</p>

<p>printf uses a variable parameter list. After integer promotion, the actual arguments are pushed on the function stack, but the offsets of each individual actual argument are not known to the callee (printf); those offsets are instead reconstructed from the format string.</p>

<p>Thus, the strange behavior you see can be explained if you consider all your actual arguments to be first concatenated by the caller and read by the callee (printf) with different offsets (according to the conversion specifiers, which do not match the actual arguments).</p>
",0
31856761,31856361,4,"<p>This triggers <code>undefined behavior</code>, as stated before, because you do not use the good format string.</p>

<p>If you want an in depth analysis of what's happening (again, it's UB, so what you see here might change on another computer/compier/...), here it is:</p>

<p>From what happens, I assume that you're working on a 32bit machine, in which <code>sizeof long == sizeof int == 4</code>. In this case, <code>%d</code> and <code>%ld</code> have the same behavior (read 4 bytes from variadic arguments and print them as a signed integer), while <code>%lld</code> will read 8 bytes. Same goes for <code>%u</code> and variants, with unsigned integer values.</p>

<p>That explains the first line : the <code>%u</code> prints only half the bytes of <code>end1</code> (so the value is ... bad).</p>

<p>For the second line, as your number in <code>end2</code> is small enough to fit either in a signed or an unsigned <code>long</code>, then printing with <code>%u</code> produces the same result as printing with <code>%d</code>, which in turn produces the same result as <code>%ld</code>.</p>

<p>For the third line, the <code>%d</code>?and <code>%ld</code>?works, then the <code>%lld</code> reads 8 bytes from the arguments (so it reads the two remaining <code>end2</code>) and prints something that you consider ""wrong"". Then the last <code>%u</code> will read 4 bytes after the last argument (somewhere on the stack), and then the value is ""garbage"" for you.</p>

<p>Hope this helps ;).</p>

<p>Note: Remember that the most important thing is ""Using a wrong format string leads to <code>undefined behaviour</code>"", which means that your code could produce completely different output on another compiler/computer/... !</p>
",0
29471002,29470417,0,"<p>As per the updated code, the definition of <code>LCD_E_PORT</code> is not visible from <code>LCD1602.c</code> file.</p>

<p>You might want to add the <code>#define</code> in the header file (<code>LCD1602.h</code> or any other, at your choice) itself which will be included in all the source files making use of the macro.</p>
",2
29518254,29518222,3,"<p>There is no difference. Both are same. <code>int</code> and <code>const</code> both are <strong>declaration specifiers</strong> and they can occur in any order. Grammar says all about it  </p>

<h3>C11: 6.7 Declarations:</h3>

<blockquote>
  <p>declaration-specifiers:  </p>
  
  <blockquote>
    <p>storage-class-specifier declaration-specifiers<sub>opt</sub><br>
            <strong>type-specifier declaration-specifiers<sub>opt</sub><br>
            type-qualifier declaration-specifiers<sub>opt</sub></strong><br>
            function-specifier declaration-specifiers<sub>opt</sub><br>
            alignment-specifier declaration-specifiers<sub>opt</sub>  </p>
  </blockquote>
</blockquote>

<h3>C11: 6.7.2 Type specifiers (p2):</h3>

<blockquote>
  <p>[...] the <strong>type specifiers</strong> may occur in any order, possibly intermixed with the other <strong>declaration specifiers</strong>.</p>
</blockquote>
",1
29518278,29518222,0,"<p>They  are both same. You declared  2  constants  variables.</p>
",0
29518286,29518222,2,"<p>No difference.</p>

<p>From <a href=""https://en.wikipedia.org/wiki/Const_%28computer_programming%29#Simple_data_types"" rel=""nofollow"">Wikipedia</a>:</p>

<blockquote>
  <p>For simple non-pointer data types, applying the <code>const</code> qualifier is straightforward. It can go on either side of the type for historical reasons (that is, <code>const char foo = 'a';</code> is equivalent to <code>char const foo = 'a';</code>). On some implementations, using <code>const</code> on both sides of the type (for instance, <code>const char const</code>) generates a warning but not an error.</p>
</blockquote>
",0
29184854,29183887,4,"<ol>
<li><p><strong>Reading user input</strong></p>

<p>To read input from the user you can use <a href=""http://www.cplusplus.com/reference/cstdio/scanf/"" rel=""nofollow""><code>scanf</code></a>. You need to pass it the <em>memory address</em> of the variable where you want to store the input:</p>

<pre><code>char userinput[256]; // make it large enough to hold what the user inputs
scanf(""%s"", userinput); // array decays to pointer so no '&amp;' here
</code></pre>

<p>The <code>%s</code> means were reading string input. We could also read an <code>int</code> using <code>%d</code>, like this:</p>

<pre><code>int i;
scanf(""%d"", &amp;i); // note the address-of operator '&amp;' to get the address of i
</code></pre></li>
<li><p><strong>Printing variables</strong></p>

<p>Your <code>SecondFunction</code> is almost correct. To <code>printf</code> a C-string you need to use a syntax similar to when you <code>scanf</code> to a variable:</p>

<pre><code>printf(""%s"", string);
</code></pre>

<p>Similarly, you could print the <code>int i</code> like this:</p>

<pre><code>printf(""The number is: %d"", i);
</code></pre></li>
<li><p><strong>Copying C-strings</strong></p>

<p>When you tried doing this: <code>char string[] = str</code>, that's not possible. Arrays cannot be assigned or even copy constructed.</p>

<p>Just in case for the future, when you want to copy a C-string, you need to use <a href=""http://www.cplusplus.com/reference/cstring/strcpy/"" rel=""nofollow""><code>strcpy</code></a>:</p>

<pre><code>char string[256]; // again, must be large enough to hold the new contents
strcpy(string, str); // copies from str to string
</code></pre>

<p>So in conclusion, your function could look something like this:</p>

<pre><code>void SecondFunction(char* str)
{
    char string[256];
    strcpy(string, str);
    char *p = string;
    for (; *p; ++p)
    {
        if (*p == ' ')
            *p = '\t';
    }
    printf(""%s"", string);
}
</code></pre>

<p><strong>Bonus:</strong> Why you can't write to the <code>str</code> parameter directly</p>

<p>When you write this: <code>SecondFunction(""Hi s"")</code>, the string <code>""Hi s""</code> gets stored in a <em>read-only</em> memory segment.</p>

<p>If you then go and try to modify the parameter inside <code>SecondFunction</code>, you get <em>undefined behavior</em>, possibly a segmentation fault.</p></li>
</ol>
",0
29186109,29185240,0,"<p>If you want <code>ca_count_hashtable</code> to work with <code>VgHashTable</code> instead of <code>VgHashTable *</code>, you need the actual <code>struct _VgHashTable {...};</code> lines before <code>ca_count_hashtable</code> is declared because the compiler doesn't know what <code>struct _VgHashTable</code> contains at that point (what its size is, what its members are, etc.)</p>

<p>An example of what I mean:</p>

<pre><code>struct Foo;

int Foo_n(struct Foo f) { return f.n; }

// Needs to be moved before ""Foo_n"" for ""Foo_n"" to work!
struct Foo { int n; };
</code></pre>

<p>Because <code>Foo_n</code> has no idea what members <code>struct Foo</code> has, it can't determine the size of the structure (including structure padding), the offsets of the members to access them in memory, etc.  Unless you fully define the type before the function is declared, you can't do anything with objects of that type.  You can, of course, declare the function to require a pointer to an object of that type, but the function cannot access any members of the structure object until the type is fully defined.  In other words, this is invalid:</p>

<pre><code>/*
 * Foo.h
 */
struct Foo;
int Foo_n(struct Foo *); //Pointers to incomplete types are OK in declarations.

/*
 * Foo.c
 */
#include ""Foo.h""

int Foo_n(struct Foo *f)
{
    /*
     * Invalid: does ""struct Foo"" contain a member named ""n""?  Where is it located
     * (relative to the beginning of the structure)?
     */
    return f-&gt;n;
}

struct Foo { int n; }; //""Foo_n"" needs me, but I'm stuck down here.  Please move me?
</code></pre>

<p>But this is valid:</p>

<pre><code>/*
 * Foo.h
 */
struct Foo;
int Foo_n(struct Foo *); //Pointers to incomplete types are OK in declarations.

/*
 * Foo.c
 */
#include ""Foo.h""

struct Foo { int n; }; //""Foo_n"" can use me!  I'm so happy I moved!

int Foo_n(struct Foo *f)
{
    return f-&gt;n;
}
</code></pre>
",0
29192393,29192259,1,"<p>You can implement <code>mergesort</code> iteratively, merging adjacent slices of 2^k elements, from k=0 until 2^k >= n. It is quite straightforward, there is no need for a <em>stack conversion</em> of the recursive algorithm.</p>

<p>You will need extra space to perform this, typically the same size as the dataset.  You can allocate this space with <code>malloc</code> or use automatic storage if that's not too large (stack based allocation).  But this memory requirement is similar to that of the recursive implementation.</p>

<p>Merging slices of 2^k elements is slightly less efficient if the total number of elements is not a power of 2, and it performs more comparisons and uses upto twice as much memory but the overall complexity is still O(n*log(n)) in the worst case, and a clever implementation can bring it down to O(n) for the sorted case.</p>

<p>Try this approach, I will post some code after you show your own attempts.</p>
",2
31239484,30925204,0,"<p>You don't need to reverse the string to convert to hex ascii:</p>

<pre><code>#include &lt;stdio.h&gt;

const char* hexlat=""0123456789ABCDEF"";

char *binaryToHex(unsigned int answer, char *result){
  if(answer==0) return result;
  else{
     result=binaryToHex(answer&gt;&gt;4,result);
    *result=hexlat[answer &amp; 0x0F];
    return result+1;
  }
};

int main(void) {
    unsigned int answer=0x12340ADF;
    char hexAnswer[32];
    *binaryToHex(answer,hexAnswer)='\0';
    printf(""%s"",hexAnswer);
    return 0;
}
</code></pre>
",0
29244822,29244785,1,"<p>You must separate your validations like that:</p>

<pre><code>if (height &gt; 23) {
    goto ask;
}
if (height &lt; 0) {
    goto ask;
}
</code></pre>

<p>You can also make one condition like that:</p>

<pre><code>if (height &gt; 23 || height &lt;= 0) {
    goto ask;
}
</code></pre>
",2
29244831,29244785,1,"<pre><code>if (height &gt; 23) {
 goto ask;
}
else (height &lt; 0) {
 printf(""The number must be higher than 0"");
}
</code></pre>
",1
29448704,29448674,0,"<p>One commenter pointed out you can use <a href=""http://linux.die.net/man/3/bsearch"" rel=""nofollow"">bsearch</a>.
But a simple loop based coding example to answer your question about how to walk the array follows.</p>

<pre><code>#define MAX_NUMBER_OF_PEOPLE 100
#define NAME_BOB ""Bob""

struct person {
    int age;
    int length;
    char fname[20];
    char lname[20];
};

typedef struct person Person;

int main()
{
    Person people[MAX_NUMBER_OF_PEOPLE];
    for (int i; i &lt; sizeof (people) / sizeof (struct people); i++) {
         Person *person = &amp;people[i];
         if (person-&gt;age == 21) {
             println(""%s %s can legally drink\n"", 
                   person-&gt;fname,  person-&gt;lname);
         }
         if (strncmp(person-&gt;fname, NAME_BOB, sizeof (NAME_BOB)) == 0) {
             println(""Bob is %d years old\n"", 
                   person-&gt;age);
         }
    }
}    
</code></pre>
",2
33028326,33027885,0,"<p>A few problems I think could be breaking your code:</p>

<p>In the <code>get_Array</code> method, in the second for loop, the way it is right now it expects an input like this:</p>

<pre><code>A space B space C space \n
</code></pre>

<p>Notice that last space? I'm not sure that is what you intended. Just removing the last <code>getchar();</code> might do it.</p>

<p>Also important noting that <code>fgets()</code> will also include the NewLine ate the end of the string, so if you are separating the words like <code>'word\word\n'</code> this might be an issue.</p>
",0
29464209,29462968,1,"<p>One pretty smart trick to more easily spot the (argc = 1) instead of (argc == 1) kind of mistake is to actually get used to put the constant on the left hand side.
If you had written if (1 = argc), the compiler would have complained saying you were trying to assign a value to a constant, and you would instantly spot that.
This comes from the gnu coding style by the way.</p>
",6
29465295,29462968,0,"<p>Following up on an earlier comment, your block of code comparing <code>&lt;</code>, <code>&gt;</code> and <code>=</code> is susceptible to error and will never match <code>&lt;=</code> or <code>&gt;=</code> as written. As part of your routine, you are reading <code>c</code> twice at the beginning of your <code>while</code> loop. Forcing the read of two characters, you will never have <code>nc</code> read <code>=</code> in <code>&lt;=</code> because the second character has already been consumed:</p>

<pre><code>while((c = getchar()) != EOF || (c = getchar()) != '\n')
</code></pre>

<p>While the intent may be to strip the newline from the input buffer, the effect is to prevent any character from remaining for <code>nc</code> to read. A better way to structure the beginning of the loop may be:</p>

<pre><code>while (1)
{
    c = fgetc (src);
    if (c == 'q' || c == EOF)    /* just `q` for quit :) */
        break;
    ...
</code></pre>

<p>In addition to this read issue, if the user enters anything other than <code>&lt;=</code> or <code>&gt;=</code> you always report <code>comparison operator</code>. Take for example <code>&lt;h</code>, you check <code>c</code> for <code>&lt;</code> or <code>&gt;</code> and then read <code>nc</code> (in this case <code>h</code>). While <code>nc</code> does not match <code>=</code>, the very next condition is satisfied:</p>

<pre><code> else if(c == '&gt;' || c == '&lt;') 
</code></pre>

<p>This results in your code outputting <code>comparison operator</code> no matter what the character following the <code>&gt;</code> or <code>&lt;</code> sign was. A little rewrite of the logic could prevent the error. For example change:</p>

<pre><code>    else if(c == '&lt;' || c == '&gt;' || c == '=')
    {
        ...
    }
</code></pre>

<p>to:</p>

<pre><code>    else if ( c == '=')
    {
        printf(""\t %c \t equals operator\n"", c);
    }
    else if(c == '&lt;' || c == '&gt;')
    {
        if ((nc = fgetc (src)) == '=')
        {
            if(c == '&lt;')
            {
                printf(""\t %c= \t comparison equivalence operator\n"", c);
            }
            else if(c == '&gt;')
            {
                printf(""\t %c= \t comparison equivalence operator\n"", c);
            }
        }
        else
        {
            printf(""\t %c \t comparison operator\n"", c);
            ungetc (nc, src);  /* the next character may be important */
        }
    }
</code></pre>

<p>Next, if you noticed the use of <code>fgetc</code> above, it is important. At the beginning of your code you want to use either <code>stdin</code> or a file for input. However, throughout your code you have used <code>getchar()</code> for reading the character. This will <strong>not</strong> work if the user supplies a filename as the first argument. You may open the file, but you will be left with a blinking cursor waiting for input on <code>stdin</code>. If you intend to have the option of reading from a file, you need to change each:</p>

<pre><code> getchar()
</code></pre>

<p>to</p>

<pre><code>fgetc (src)
</code></pre>

<p>Lastly, and this is just a pet peeve. I you are asking the user for input, give the user a prompt so they know they are supposed to do something and are not just left wondering if the program is hung. (a simple <code>input:</code> is fine). Since you have structured the program to read from either <code>stdin</code> or a file, it may not be apparent how to only prompt in the case the program is reading from <code>stdin</code> (no prompt is wanted or needed when reading from a file). The solution is to simply pass a pointer to a flag as an argument to your <code>input_from_args</code> function. You function sets the flag if reading from <code>stdin</code> or leaves it <code>0</code> if reading from a file. That allows you to provide a prompt as follows:</p>

<pre><code>if (stdf) printf ("" input : "");   /* stdf being the stdinflag */
</code></pre>

<p>Putting it all together, an updated version of the code that reads from either a file or <code>stdin</code> could be similar to:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;

FILE *
input_from_args (int argc, const char *argv[], size_t *stdinflag)
{
    if (argc == 1)
    {
        *stdinflag = 1;
        return stdin;
    } 
    else
    {
        *stdinflag = 0;
        return fopen(argv[1], ""r"");
    }
}

int main (int argc, const char **argv)
{
    size_t stdf = 0;
    FILE *src = input_from_args (argc, argv, &amp;stdf);

    if(src == NULL)
    {
        fprintf(stderr, ""%s: unable to open %s\n"", argv[0], argv[1]);
        exit(EXIT_FAILURE);
    }

    int c = 0;
    int nc = 0;
    int strip = 0;

    while (1)
    {
        if (stdf) printf ("" input : "");
        c = fgetc (src);

        if(c == ' ' || c == '\t')
        {
            printf(""\t    Blank Space\n"");
        }
        else if(c == '+' || c == '-' || c == '*' || c == '/' || c == '^')
        {
            if(c == '+')
            {
                printf(""\t %c \t addition operator\n"", c);
            }
            else if(c == '-')
            {
                printf(""\t %c \t subtraction operator\n"", c);
            }  
            else if(c == '*')
            {
                printf(""\t %c \t multiplication operator\n"", c);
            }
            if(c == '/')
            {
                printf(""\t %c \t division operator\n"", c);
            }
            else if(c == '^')
            {
                printf(""\t %c \t exponentiation\n"", c);
            }
        }
        else if(c == '(' || c == ')')
        {
            if(c == '(')
            {
                printf(""\t %c \t open parentheses\n"", c);
            }
            else if(c == ')')
            {
                printf(""\t %c \t close parentheses\n"", c);
            }
        }
        else if ( c == '=')
        {
            printf(""\t %c \t equals operator\n"", c);
        }
        else if(c == '&lt;' || c == '&gt;')
        {
            if ((nc = fgetc (src)) == '=')
            {
                if(c == '&lt;')
                {
                    printf(""\t %c= \t comparison equivalence operator\n"", c);
                }
                else if(c == '&gt;')
                {
                    printf(""\t %c= \t comparison equivalence operator\n"", c);
                }
            }
            else
            {
                printf(""\t %c \t comparison operator\n"", c);
                ungetc (nc, src);
            }
        }
        else if(isdigit(c))
        {
            printf(""\t %c \t simple numeral \n"", c);
        }
        else if(isalpha(c))
        {
            if (tolower (c) == 'q')
            {
                printf (""\t\n 'q' received, quitting.\n\n"");
                break;
            }
            printf(""\t %c \t invalid token\n"", c);
        }

        while ((strip = fgetc (src)) != '\n' &amp;&amp; strip != EOF);
    }

    if (src &amp;&amp; !stdf) fclose (src);

    return 0;
} 
</code></pre>

<p><strong>Output - stdin</strong></p>

<pre><code>$ ./bin/getchar_token_calc
 input :
            Blank Space
 input :
            Blank Space
 input : +
         +       addition operator
 input : -
         -       subtraction operator
 input : *
         *       multiplication operator
 input : /
         /       division operator
 input : ^
         ^       exponentiation
 input : (
         (       open parentheses
 input : )
         )       close parentheses
 input : &lt;
         &lt;       comparison operator
 input : &gt;
         &gt;       comparison operator
 input : &lt;=
         &lt;=      comparison equivalence operator
 input : &gt;=
         &gt;=      comparison equivalence operator
 input : 6
         6       simple numeral
 input : a
         a       invalid token
 input : q

 'q' received, quitting.
</code></pre>

<p><strong>Output - file</strong></p>

<pre><code>$ ./bin/getchar_token_calc dat/tokens.txt
            Blank Space
            Blank Space
         +       addition operator
         -       subtraction operator
         *       multiplication operator
         /       division operator
         ^       exponentiation
         (       open parentheses
         )       close parentheses
         =       equals operator
         &lt;       comparison operator
         &gt;       comparison operator
         &lt;=      comparison equivalence operator
         &gt;=      comparison equivalence operator
         6       simple numeral

 'q' received, quitting.
</code></pre>
",0
31131035,29656999,0,"<p>I am answering my own question here, I have gotten better since the past few days and intend to improve my above code. </p>

<p>I have eliminated the need to make a function to find the number of divisors of <code>n</code> since that is immaterial in storing the divisors in an array. I have improved my <code>storeDivisors</code> function which not only stores all the divisors but if needed will also give the count of divisors. Here is the updated code --</p>

<pre><code>#include &lt;stdio.h&gt;

void storeDivisors(int n,int a[],int *x)
{
    int i;
    for(i=1;i&lt;=n;i++)
    {
        if(n%i==0)
            a[(*x)++]=i;
    }
}

int main()
{
    int n = 100;
    int a[100];
    int x = 0;
    int i;

    storeDivisors(n,a,&amp;x);

    for(i=0;i&lt;x;i++)
        printf(""%d\n"",a[i]);
    printf(""number of divisors = %d\n"",x);

    return 0;
}
</code></pre>
",0
32997447,32997367,2,"<p>The message seems pretty clear. It's telling you that, somewhere inside the implementation of <code>fclose</code>, there is a requirement (enforced by assertion) that the input not be <code>NULL</code>.</p>

<p>Indeed, if you read the <em>documentation</em> you'll see that <code>fclose</code> takes a <code>FILE*</code> that points to a stream, not a null pointer.</p>

<p>In your code you literally <em>only</em> call <code>fclose(fin)</code> when <code>fin</code> is <code>NULL</code>.The complete lack of logic in that aside, if you really want to write C++, there are <em>much</em> better ways to handle file I/O than this. Open your C++ book to the file I/O chapter and read on! Good luck.</p>
",0
29955466,29954370,0,"<p>rewrite sample with malloc and realloc</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define LINE(n) do { int num = n; while(num--){ putchar('-'); } putchar('\n'); }while(0)

int main(void){
    system(""COLOR A"");
    srand(time(NULL));

    int a, b;
    int **pinak;
    int i, j;

    printf(""input a and b for pinak[a][b] : "");
    scanf(""%d %d"", &amp;a, &amp;b);

    /* creation and filling of table pinak[a][b] */
    pinak = malloc(a * sizeof(*pinak));//malloc(a * sizeof(int*));
    for(i = 0; i &lt; a; i++){
        pinak[i] = malloc(b * sizeof(*pinak[0]));//malloc(b * sizeof(int);
        for(j = 0; j &lt; b; j++){
            pinak[i][j] = (rand()%(500-1))+1;/*Fillinig the table  */
        } 
    }

    /*printing the table*/
    for(i = 0; i &lt; a; i++){
        LINE(b * 6 + 1);
        for(j=0;j&lt;b;j++){
            printf(""|%4d "", pinak[i][j]);
        }
        printf(""|\n"");
    }
    LINE(b * 6 + 1);

    int a2 = a*2, b2 = b*2;//expand width and height
    pinak = realloc(pinak, a2 * sizeof(*pinak));
    for(i = 0; i &lt; a; i++) {
        pinak[i] = realloc(pinak[i], b2 * sizeof(*pinak[0]));
        for(j = b; j &lt; b2; j++){
            pinak[i][j]=(rand()%(500-1))+1;
        } 
    }
    for(i = a; i &lt; a2; i++) {
        pinak[i] = malloc(b2 * sizeof(*pinak[0]));
        for(j = 0; j &lt; b2; j++){
            pinak[i][j] = (rand()%(500-1))+1;
        } 
    }

    /*printing the table*/
    for(i = 0; i &lt; a2; i++){
        LINE(b2 * 6 + 1);
        for(j = 0; j &lt; b2; j++){
            printf(""|%4d "", pinak[i][j]);
        }
        printf(""|\n"");
    }
    LINE(b2 * 6 + 1);

    //release
    for(i = 0; i &lt; a2; i++)
        free(pinak[i]);
    free(pinak);

    system(""PAUSE"");
    system(""COLOR 7"");
    return 0;
}
</code></pre>
",0
31167524,30246478,2,"<p>The problem with your code is ""You have opened both the file in initial stage"". To solve the problem just open the source file in the write mode and write all the data, then close and reopen the source file in read mode, Then open the target file in the write mode. 
The modified code is given below and it was not tested</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;

#define BUFFSIZE 8192

int main(){
    int fdsource, fdtarget;
    int n;
    char buff[BUFFSIZE];

    fdsource = open(""source.txt"", O_RDWR | O_CREAT, S_IRUSR | S_IWUSR); // Create and open a source file in read/write
    if (fdsource &lt; 0){
        printf(""Source file open error!\n"");
        exit(1);
    }
    printf(""\nInsert text:\n"");
    while ((n = read(STDIN_FILENO, buff, BUFFSIZE)) &gt; 0){ // Read from STDIN and write to source file
        if ((write(fdsource, buff, n)) != n){
            printf(""Source file write error!\n"");
            exit(1);
        }
    }

    close(fdsource);
    fdsource = open(""source.txt"", O_RDWR | O_CREAT, S_IRUSR | S_IWUSR); // Create and open a source file in read/write
    if (fdsource &lt; 0){
        printf(""Source file open error!\n"");
        exit(1);
    }

    fdtarget = open(""target.txt"", O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR); // Create and open a source file in write only
    if (fdtarget &lt; 0){
        printf(""Target file open error!\n"");
        exit(1);
    }

    while ((read(fdsource, buff, n)) &gt; 0){ // Read from source file and write to target file
        if ((write(fdtarget, buff, n)) != n){
            printf(""Source file open error!\n"");
            exit(1);
        }
    }
    close(fdsource);
    close(fdtarget);
    exit(0);
    return 0;
}
</code></pre>

<p>If am wrong anywhere use the logic mentioned above.</p>
",0
33001004,33000972,5,"<p>Two things:</p>

<p>You need to <code>#include &lt;math.h&gt;</code> at the top of your file.</p>

<p>You need to link with the math library by passing <code>-lm</code> to gcc:</p>

<pre><code>gcc -o myprog myprog.c -lm
</code></pre>
",2
33001029,33000972,1,"<p>Apart from including <code>math.h</code>, simply compile your file by writing <code>-lm</code> <strong>at the end of the command</strong>.</p>

<p>Since you are stating that your program sometimes work, maybe you are compiling your code differently at different times or some optimization takes place. Please take a look  <a href=""https://stackoverflow.com/questions/8266183/linking-with-gcc-and-lm-doesnt-define-ceil-on-ubuntu"">here</a> (credits to dannas):</p>

<blockquote>
  <p>Archives (static libraries) are acted upon differently than are shared objects (dynamic libraries). With dynamic libraries, all the library symbols go into the virtual address space of the output file, and all the symbols are available to all the other files in the link. In contrast, static linking only looks through the archive for the undefined symbols presently known to the loader at the time the archive is processed.
  <hr/>
  If you specify the math library (which is usually a static one) before your object files, then the linker won't add any symbols.</p>
</blockquote>
",0
31242610,31242228,2,"<p><code>for (i=0;i&lt;*p2-*tab;i++)</code> exposes <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer""><strong>undefined behaviour</strong></a> and it is semantically wrong anyway.</p>
<p>The correct code is:</p>
<pre><code>for (i=0;i&lt;p2-tab;i++)
{
    printf(&quot;value n %d of the table : %d\n&quot;,i,tab[i]);
}
</code></pre>
<p><code>i</code> is used as an index in <code>tab</code> (<code>tab[i]</code>), <code>p2</code> points to the first element after the last element of the array after the elements equal with <code>val</code> were removed.
<code>p2-tab</code> is the number of elements in the array after removal which is the correct number of iterations to do in order to print the remaining numbers.</p>
<h3>Why is <code>for (i=0;i&lt;*p2-*tab;i++)</code> wrong?</h3>
<p>From the semantically point of view, <code>*p2</code> and <code>*tab</code> are two elements in the array (ignore the case when <code>*p2</code> is beyond the array boundaries, we'll talk about it two paragraphs below).</p>
<p>Consequently, <code>*p2-*tab</code> is some random number, it can be even negative. It doesn't make any sense to use it as the number of iterations over the array.</p>
<p>From the language point of view, if <code>val</code> is not present in the initial content of the array, after its &quot;removal&quot;, <code>p2</code> is equal to <code>tab+nb</code>. But <code>tab</code> points to a block of allocated memory that can hold at most <code>nb</code> values and that means <code>tab+nb</code> is outside this memory block.</p>
<p>This makes the code have <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer""><strong>undefined behaviour</strong></a> and that means anything could happen; some times it runs apparently well; most of the times it produces unexpected results; depending on the OS and compiler implementations, it can also generate an unhandled exception and be terminated by the OS.</p>
",2
30702866,30702075,1,"<p>At first you have to include header <code>&lt;stdio.h&gt;</code>:</p>

<pre><code>#include &lt;stdio.h&gt;
</code></pre>

<p>If you call the function with the second parameter equal to <code>LINELIM</code></p>

<pre><code>getLine(line1, LINELIM)
</code></pre>

<p>then <code>line1</code> has to be defined with the same size</p>

<pre><code>char line1[LINELIM];
</code></pre>

<p>As for me I would rewrite function <code>getline</code> the following way:)</p>

<pre><code>int getLine( char s[], int lim )
{
    int c;

    int i = 0;

    while ( i &lt; lim - 1 &amp;&amp; ( c = getchar() ) != EOF &amp;&amp; ( s[i++] = c ) !='\n' ); 

    s[i] = '\0';

    return i;
}
</code></pre>

<p>The main loop in main can be written like</p>

<pre><code>while ( ( len = getLine( line1, LINELIM ) ) &gt; 0 )
{
    int i = len;

    while ( i != 0 &amp;&amp; ( line1[i-1] == ' ' || line1[i-1] == '\t' || line1[i-1] == '\n' ) ) --i;

    line1[i] = '\0';

    if ( line1[0] ) printf( ""%s\n"", line1 );
}
</code></pre>

<p>You should move the declaration of <code>i</code> from main inside the while loop because except this while loop the variable is not used anywhere in main.</p>

<p>As for your code then setting <code>i</code> to <code>len - 2</code> is incorrect.</p>

<pre><code>for (i=len-2; i&gt;=0; i--){
     ^^^^^^
</code></pre>

<p>Let's assume that the <code>line1</code> contains only the new line character <code>'\n'</code>. In this case <code>len</code> is equal to <code>1</code> and as result i will be equal to <code>-1</code>. So the trailing new line character will not be removed.</p>
",2
34182512,34182351,0,"<p>As already pointed out by the others, the character 10 in ASCII is LF (line feed).</p>

<p>If you wanted <code>printf</code> to output the character (not see its ordinal value), you could use the <code>%c</code> format specifier to pass a single character.</p>

<p>Example:</p>

<pre><code>printf(""-%c-"", input[6]);
</code></pre>

<p>should yield:</p>

<pre><code>-
-
</code></pre>

<p>I.e. two dashes separated by a line feed. Please keep in mind that the outcome on Windows depends on how your C runtime handles a single LF without CR as on Windows a line break is customarily represented by CRLF instead of just LF which is the standard on unixoid systems. The only exception to that rule were old Mac systems which used to use only CR to encode a line break.</p>
",0
34182374,34182351,2,"<p>The value <code>10</code> is the ASCII value for the newline character (LF, or linefeed). Closely related is character <code>13</code>, which is CR, or carriage return, which, on Windows systems, often precedes the LF character. I would suggest getting a copy of the ASCII table (they're all over the web) and referencing it from time to time.</p>

<p>Character <code>10</code> can be represented by <code>'\n'</code> in C code, as well as <code>'\012'</code>, <code>'\x0a'</code>, and <code>'\u000a'</code>
Character <code>13</code> (carriage return) can be represented by <code>'\r'</code>, <code>'\015'</code>, <code>'\x0d'</code>, and <code>'\u000d'</code>.</p>
",6
34182390,34182351,0,"<p>It is the newline (LF  (NL line feed, new line)) in <code>ASCII</code>. See all of the values <a href=""https://www.cs.cmu.edu/~pattis/15-1XX/common/handouts/ascii.html"" rel=""nofollow"">here</a>.</p>
",0
31116130,31113346,0,"<p>OP's unposted error message is likely telling that too large of a local variable is being made.  To make large variables, suggest using <code>malloc()</code>.</p>

<p>Per the C language, the maximum array size is no larger than <code>SIZE_MAX</code>.  Other factors may considerable further limit a system's maximum <code>char[]</code>.  These are usually large values  This typically means there is no practical limit on user input from the code's point-of-view.  Yet robust code would limit, and detect, user input of insanely large input as more likely errant input or a hacker attack than legitimate.</p>

<pre><code>#define N 4096
char *buf = malloc(N);
if (buf &amp;&amp; fgets(buf, N, stdin)) {
  size_t length = strlen(buf);
  if (length &gt;= N-1) Handle_LongInput();
}
</code></pre>

<p>The proper value for <code>N</code> is program dependent.</p>
",0
32429550,32428769,0,"<pre><code>#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;

#define BUFFER_SIZE 100

void split_one(const char **p, char *out){
    if(**p){
        while(isspace(**p))
            ++*p;
        if(isalpha(**p)){
            while(isalpha(**p))
                *out++ = *(*p)++;
        } else if(isdigit(**p)){
            while(isdigit(**p))
                *out++ = *(*p)++;
        } else {
            while(**p &amp;&amp; !isalpha(**p) &amp;&amp; !isdigit(**p) &amp;&amp; !isspace(**p))
                *out++ = *(*p)++;
        }
    }
    *out = '\0';
}

int main (void){
    char str[BUFFER_SIZE] = ""(I) 44like22 .cookies. ,This, /is\\ ?tricky?"";
    char *strings[BUFFER_SIZE] = {0};
    char piece[BUFFER_SIZE];
    const char *p = &amp;str[0];

    int k = 0;

    while(*p){
        split_one(&amp;p, piece);
        if(!*piece)
            continue;
        strings[k++] = strdup(piece);
    }
    for(int i = 0; i &lt; k; ++i){
        printf(""'%s'\n"", strings[i]);
        free(strings[i]);
    }
    return 0; 
} 
</code></pre>
",1
32429318,32428769,0,"<p>I'm not entirely happy with this code, but it is relatively clean and seems to do the job.</p>

<h3><code>splitit.c</code></h3>

<pre><code>#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
{
    const char  str[] = ""(I) 44like22 .cookies. ,This, /is\\ ?tricky?"";
    const char *s = str;

    char   out[2 * sizeof(str)];
    char  *ptr[sizeof(str)];
    char **p = ptr;
    char  *o = out;
    int    n = 0;

    /* ( I ) 44 like 22 . cookies . , This , / is \ ? tricky ? */

    int c;

    printf(""Whole string: &lt;&lt;%s&gt;&gt;\n"", str);

    while ((c = (unsigned char)*s++) != '\0')
    {
        if (isdigit(c))
        {
            *p++ = o;
            *o++ = c;
            while (isdigit((unsigned char)*s))
                *o++ = *s++;
            *o++ = '\0';
            n++;
        }
        else if (isalpha(c))
        {
            *p++ = o;
            *o++ = c;
            while (isalpha((unsigned char)*s))
                *o++ = *s++;
            *o++ = '\0';
            n++;
        }
        else if (ispunct(c))
        {
            *p++ = o;
            *o++ = c;
            while (ispunct((unsigned char)*s))
                *o++ = *s++;
            *o++ = '\0';
            n++;
        }
        else if (!isspace(c))
        {
            printf(""Hmmm: don't know how to classify %d (%c)\n"", c, c);
        }
    }

    for (int i = 0; i &lt; n; i++)
        printf(""Fragment[%2d] = %s\n"", i, ptr[i]);

    return 0;
}
</code></pre>

<p>Compilation (GCC 5.1.0 on Mac OS X 10.10.5):</p>

<pre><code>$ gcc -O3 -g -std=c11 -Wall -Wextra -Wmissing-prototypes -Wstrict-prototypes \
      -Wold-style-definition -Werror splitit.c -o splitit
</code></pre>

<p>Sample run:</p>

<pre><code>Whole string: &lt;&lt;(I) 44like22 .cookies. ,This, /is\ ?tricky?&gt;&gt;
Fragment[ 0] = (
Fragment[ 1] = I
Fragment[ 2] = )
Fragment[ 3] = 44
Fragment[ 4] = like
Fragment[ 5] = 22
Fragment[ 6] = .
Fragment[ 7] = cookies
Fragment[ 8] = .
Fragment[ 9] = ,
Fragment[10] = This
Fragment[11] = ,
Fragment[12] = /
Fragment[13] = is
Fragment[14] = \
Fragment[15] = ?
Fragment[16] = tricky
Fragment[17] = ?
</code></pre>

<p>I observe that there are no multi-punctuation sequences in the sample data; however, the code is symmetric so it will handle them OK.</p>

<p>I'm not happy with the code because of the repetition in the <code>if</code> statements, but the amount of control data to be manipulated makes writing a function messy.</p>

<p>You can argue about the variable names too; I'll accept that they're on the overly-terse side of 'brief but meaningful'.</p>

<hr>

<h3>Avoiding repetition</h3>

<p>This code uses function pointers to avoid repetition.  Using pointers to functions is powerful, but not necessarily something you're ready to handle.  It does allow me to avoid using a separate function with half a dozen or so parameters.</p>

<pre><code>#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
{
    const char  str[] = ""(I) 44like22 .cookies. ,This, /is\\ ?tricky?""
        ""\nBut (as he said, \""Isn't it delicous fun!\""), he vanished."";
    const char *s = str;

    char   out[2 * sizeof(str)];
    char  *ptr[sizeof(str)];
    char **p = ptr;
    char  *o = out;
    int    n = 0;
    int    c;

    printf(""Whole string: &lt;&lt;%s&gt;&gt;\n"", str);

    while ((c = (unsigned char)*s++) != '\0')
    {
        int (*ctype)(int c) = 0;
        if (isdigit(c))
            ctype = isdigit;
        else if (isalpha(c))
            ctype = isalpha;
        else if (ispunct(c))
            ctype = ispunct;
        else if (isspace(c))
            continue;
        else
        {
            printf(""Hmmm: don't know how to classify %d (%c)\n"", c, c);
            continue;
        }
        *p++ = o;
        *o++ = c;
        while ((*ctype)((unsigned char)*s))
            *o++ = *s++;
        *o++ = '\0';
        n++;
    }

    for (int i = 0; i &lt; n; i++)
        printf(""Fragment[%2d] = %s\n"", i, ptr[i]);

    return 0;
}
</code></pre>

<p>Sample output:</p>

<pre><code>Whole string: &lt;&lt;(I) 44like22 .cookies. ,This, /is\ ?tricky?
But (as he said, ""Isn't it delicous fun!""), he vanished.&gt;&gt;
Fragment[ 0] = (
Fragment[ 1] = I
Fragment[ 2] = )
Fragment[ 3] = 44
Fragment[ 4] = like
Fragment[ 5] = 22
Fragment[ 6] = .
Fragment[ 7] = cookies
Fragment[ 8] = .
Fragment[ 9] = ,
Fragment[10] = This
Fragment[11] = ,
Fragment[12] = /
Fragment[13] = is
Fragment[14] = \
Fragment[15] = ?
Fragment[16] = tricky
Fragment[17] = ?
Fragment[18] = But
Fragment[19] = (
Fragment[20] = as
Fragment[21] = he
Fragment[22] = said
Fragment[23] = ,
Fragment[24] = ""
Fragment[25] = Isn
Fragment[26] = '
Fragment[27] = t
Fragment[28] = it
Fragment[29] = delicous
Fragment[30] = fun
Fragment[31] = !""),
Fragment[32] = he
Fragment[33] = vanished
Fragment[34] = .
</code></pre>

<h3>Working with <code>fgets()</code></h3>

<p>The key thing is to work out where the boundaries are between the code that just happens to set the string to a value and the code that works reasonably generically, and separate the more generic code into a function which is called from the <code>main()</code> function.  I've adapted the more repetitive code for the purpose:</p>

<pre><code>#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

 static void split_string(const char *buffer, size_t buflen)
 {
    const char *s = buffer;
    char   out[2 * buflen];
    char  *ptr[buflen];
    char **p = ptr;
    char  *o = out;
    int    n = 0;
    int c;

    printf(""Whole string: &lt;&lt;%s&gt;&gt;\n"", buffer);

    while ((c = (unsigned char)*s++) != '\0')
    {
        if (isdigit(c))
        {
            *p++ = o;
            *o++ = c;
            while (isdigit((unsigned char)*s))
                *o++ = *s++;
            *o++ = '\0';
            n++;
        }
        else if (isalpha(c))
        {
            *p++ = o;
            *o++ = c;
            while (isalpha((unsigned char)*s))
                *o++ = *s++;
            *o++ = '\0';
            n++;
        }
        else if (ispunct(c))
        {
            *p++ = o;
            *o++ = c;
            while (ispunct((unsigned char)*s))
                *o++ = *s++;
            *o++ = '\0';
            n++;
        }
        else if (!isspace(c))
        {
            printf(""Hmmm: don't know how to classify %d (%c)\n"", c, c);
        }
    }

    for (int i = 0; i &lt; n; i++)
        printf(""Fragment[%2d] = %s\n"", i, ptr[i]);
}

int main(void)
{
    const char  str[] = ""(I) 44like22 .cookies. ,This, /is\\ ?tricky?"";
    split_string(str, sizeof(str));

    char buffer[4096];
    while (fgets(buffer, sizeof(buffer), stdin) != 0)
        split_string(buffer, strlen(buffer)+1);

    return 0;
}
</code></pre>

<p>There are four changes up to and including the first <code>printf()</code> in the function (apart from defining the function itself); the remainder of the function is unchanged from the previous code.  The four changes make the revised code refer to the arguments to the function (<code>buffer</code> and <code>buflen</code>) instead of the variable <code>str</code> and its size in <code>main()</code>. </p>

<p>Note that it would be simple to use the less repetitive code in this function.  You'd change the same lines at the top of the function in the same way, and leave the rest unchanged ¡ª and the revised <code>main()</code> wouldn't be any the wiser about the change in the mechanics. </p>

<p>Sample run:</p>

<pre><code>$ ./splitit
Whole string: &lt;&lt;(I) 44like22 .cookies. ,This, /is\ ?tricky?&gt;&gt;
Fragment[ 0] = (
Fragment[ 1] = I
Fragment[ 2] = )
Fragment[ 3] = 44
Fragment[ 4] = like
Fragment[ 5] = 22
Fragment[ 6] = .
Fragment[ 7] = cookies
Fragment[ 8] = .
Fragment[ 9] = ,
Fragment[10] = This
Fragment[11] = ,
Fragment[12] = /
Fragment[13] = is
Fragment[14] = \
Fragment[15] = ?
Fragment[16] = tricky
Fragment[17] = ?
Californian(*) Avocados--a joyous fruit--are ""wonderful!"" to eat.
Whole string: &lt;&lt;Californian(*) Avocados--a joyous fruit--are ""wonderful!"" to eat.
&gt;&gt;
Fragment[ 0] = Californian
Fragment[ 1] = (*)
Fragment[ 2] = Avocados
Fragment[ 3] = --
Fragment[ 4] = a
Fragment[ 5] = joyous
Fragment[ 6] = fruit
Fragment[ 7] = --
Fragment[ 8] = are
Fragment[ 9] = ""
Fragment[10] = wonderful
Fragment[11] = !""
Fragment[12] = to
Fragment[13] = eat
Fragment[14] = .
$
</code></pre>
",5
32429513,32428769,0,"<p>To gather ranges of inclusive or exclusive characters, use <code>strspn</code> (inclusive) or <code>strcspn</code> (exclusive; both are described <a href=""http://man7.org/linux/man-pages/man3/strspn.3.html"" rel=""nofollow"">in the same link</a>). They both return the number of characters that fulfill the condition, and you can print this range, or process it any other way you like, and then skip that section to continue with the rest.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void print_range (char *input, int start, int length)
{
    putchar ('""');
    while (length--)
        putchar (input[start++]);
    printf (""\""\n"");
}

void print_continuous (char *input, int start, int length)
{
    while (length--)
        putchar (input[start++]);
    printf ("" "");
}

void split_string (char *input, void(*process)(char *,int,int) )
{
    int current_pos = 0, next_length;

    while (input[current_pos])
    {
        /* 1. letters? */
        next_length = strspn (input+current_pos, ""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"");
        if (next_length)
        {
            process (input, current_pos, next_length);
            current_pos += next_length;
            continue;
        }
        /* 2. digits? */
        next_length = strspn (input+current_pos, ""0123456789"");
        if (next_length)
        {
            process (input, current_pos, next_length);
            current_pos += next_length;
            continue;
        }
        /* 3. neither letters nor digits */
        /* first, skip spaces. These don't need processing (apparently?) */
        next_length = strspn (input+current_pos, "" "");
        current_pos += next_length;

        /* then skip all others as well */
        next_length = strcspn (input+current_pos, "" 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"");
        if (next_length)
        {
            process (input, current_pos, next_length);
            current_pos += next_length;
        }
    }

}

int main(void)
{
    char str[] =""(I) 44like22 .cookies. ,This, /is\x5C ?tricky?"";

    printf (""input: [%s]\n"", str);

    split_string (str, print_range);
    split_string (str, print_continuous);


    return 0;
}
</code></pre>

<p>For convenience, I added the <code>process</code> function as a function <em>pointer</em>. That way you can easily adjust the function to do whatever you want with each fragment.</p>

<p>Output: the full string, one fragment per line, and separated with a single space:</p>

<pre class=""lang-none prettyprint-override""><code>input: [(I) 44like22 .cookies. ,This, /is\ ?tricky?]
""(""
""I""
"")""
""44""
""like""
""22""
"".""
""cookies""
"".""
"",""
""This""
"",""
""/""
""is""
""\""
""?""
""tricky""
""?""
( I ) 44 like 22 . cookies . , This , / is \ ? tricky ? 
</code></pre>
",0
31129952,31129858,1,"<p>You just need to use unicode characters. <a href=""http://www.cprogramming.com/tutorial/unicode.html"" rel=""nofollow"">This</a> should help you out .</p>
",0
31298690,31297287,0,"<p>I think you can achieve this with <em>named pipes</em>.  nodejs shouldn't matter for this because as far as your programs are concerned, it's just a normal file.</p>

<h3>Read session</h3>

<pre><code>$ mkfifo text.fifo
$ cat text.fifo
</code></pre>

<h3>foo.c</h3>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
  FILE * f = fopen (""text.fifo"", ""w"");

  for (int i = 0; i &lt; 10; ++i)
  {
    fprintf (f, ""Sup %d\n"", i);
    fflush (f);
    sleep(1);
  }

  fclose(f);

  return 0;
}
</code></pre>

<h3>Write Session</h3>

<pre><code>$ gcc foo.c -std=c99
$ ./a.exe
$
</code></pre>

<h3>Read Session</h3>

<pre><code>$ mkfifo text.fifo
$ cat text.fifo
Sup 0
Sup 1
Sup 2
Sup 3
Sup 4
Sup 5
Sup 6
Sup 7
Sup 8
Sup 9

$
</code></pre>
",1
31299597,31297287,0,"<p>My ugly final solution:</p>

<p><strong>writer:</strong></p>

<pre><code>for (;;){`

   //printing single chatacters
   char c[25] = ""ABCDEFGHIJLMNOPQRSTUVXZ"";

    //fprintf(f, ""A character: %c\n"", c[i]);
    fprintf(f, ""-%c"", c[i]);
    fflush(f);
    printf(""-%c"", c[i]);
    i++;
    _sleep(1000);
    if (i == 20){
        break;
    }

    fclose(f); 
</code></pre>

<p><strong>reader:</strong></p>

<pre><code>file = fopen(""file.txt"", ""r"");

if (file) {
    //while (((nread = fread(buf, 1, sizeof buf, file)) &gt; 0)){
    while ((((nread = fread(buf, 1, sizeof buf, file)) &gt;= 0))){
        fwrite(buf, 1, nread, stdout);
        //_sleep(1000);

        int size= sizeof buf;
        for (int i = 0; size; i++){
            if (buf[i] == 'R') { //my [eof]
                out = 1;
                break;
            }
            if (i == 10){//preventing buf[] empty - need improvement
                break;
            }
        }
        if (out== 1) break;
    }
    if (ferror(file)) {
        printf(""Bad. \n"");
    }
    fclose(file);
}
</code></pre>

<p>Is not very efficient but works fine.</p>
",0
31144704,31140168,2,"<p>Look at using <a href=""http://www.freebsd.org/cgi/man.cgi?query=curses&amp;apropos=0&amp;sektion=3&amp;manpath=FreeBSD%204.3-RELEASE&amp;format=html"" rel=""nofollow"">[n]curses(3)</a>.</p>

<ul>
<li><a href=""https://en.wikipedia.org/wiki/Ncurses"" rel=""nofollow"">https://en.wikipedia.org/wiki/Ncurses</a></li>
<li><a href=""http://www.gnu.org/software/ncurses/"" rel=""nofollow"">http://www.gnu.org/software/ncurses/</a></li>
<li><a href=""http://heather.cs.ucdavis.edu/~matloff/UnixAndC/CLanguage/Curses.pdf"" rel=""nofollow"">http://heather.cs.ucdavis.edu/~matloff/UnixAndC/CLanguage/Curses.pdf</a></li>
</ul>

<p>If you are on a *nix or OS X, it should be already installed. If you are on Windows, you can get a distribution of <a href=""http://sourceforge.net/projects/pdcurses"" rel=""nofollow"">PdCurses</a> at</p>

<ul>
<li><a href=""http://pdcurses.sourceforge.net/"" rel=""nofollow"">http://pdcurses.sourceforge.net/</a></li>
<li><a href=""https://github.com/wmcbrine/PDCurses"" rel=""nofollow"">https://github.com/wmcbrine/PDCurses</a></li>
<li>documentation: <a href=""http://pdcurses.sourceforge.net/doc/PDCurses.txt"" rel=""nofollow"">http://pdcurses.sourceforge.net/doc/PDCurses.txt</a></li>
</ul>

<p>However, from a design perspective, you should separate your <em>model</em> (an 80 x 25 array ) from the <em>user interface</em>. you have two tasks:</p>

<ol>
<li>Maintain the model by responding to user events.</li>
<li>Maintain the user interface by responding to changes in the model.</li>
</ol>

<p>This leads you to a <em>design pattern</em> called <em>Model-View-Controller</em> or <em>MVC</em>. In classic MVC, you have:</p>

<ul>
<li>A <em>model</em>, essentially a headless application with no user interface.</li>
<li>A <em>view</em>, the user interface. In your case, you have a console/terminal window as the output and a keyboard as the input, right?</li>
<li>A <em>controller</em>. The job of the controller is to wire up the view to the model. The controller relays events (such as input events such as a key press or the entry of a line of text) to the model. The model responds to the event be reacting appropriately and notifies the controller if its visual state has changed. The controller, in turn, responds by instructing the view (or the required parts of the view) that its state has changed so it may re-render itself.</li>
</ul>

<p>This <em>separation of concerns</em> makes it (among other things) simpler to write and test the code in the first place.</p>
",0
31270728,31270655,0,"<pre><code>for(i=0; i &lt; numberOfProducts; ++i)
</code></pre>

<p>and</p>

<pre><code>for(i=0; i &lt; numberOfProducts; i++)
</code></pre>

<p>are both equivalent as you are not reading the result of the operation (like in <code>a = i++</code> vs <code>a = ++i</code>). The latter form is more common.</p>

<p>If you have different results, you probably have issues in the way you are testing your program.</p>
",2
31270765,31270655,0,"<p><code>++i</code> is a pre-increment operation, meaning that <code>i</code> is first incremented then the incremented value is used in an expression.  <code>i++</code> is a post-increment operation, meaning that the existing value of <code>i</code> is first used in an expression, then it is incremented.</p>

<p>For example:</p>

<pre><code>i=3;
x = 6 - i++;
printf(""x=%d\n"",x);
</code></pre>

<p>Outputs 3.</p>

<pre><code>i=3;
x = 6 - ++i;
printf(""x=%d\n"",x);
</code></pre>

<p>Outputs 2.</p>
",0
31255197,31255085,3,"<p>Well: Hope the following helps you.</p>

<ul>
<li>Unlike for and while loops, which test the loop condition at the top
of the loop, the do...while loop in C programming language checks its
condition at the bottom of the loop</li>
<li>A do...while loop is similar to a while loop, except that a    do...while loop is guaranteed to execute at least one time.</li>
</ul>

<p>A sample syntax would be:</p>

<pre><code>do{
statement(x);

}while(condition);
</code></pre>

<p>Notice that the conditional expression appears at the end of the loop, so the statement(x) in the loop execute once before the condition is tested.</p>

<p>If the condition is true, the flow of control jumps back up to do, and the statement(x) in the loop execute again. This process repeats until the given condition becomes false.</p>

<p>Try this code and you will be good:</p>

<pre><code>#include &lt;stdio.h&gt;

int main ()
{
   // local variable definition 
   int x = 5;

   // do loop execution 
   do
   {
       printf(""value of x: %d\n"", x);
       x = x + 1;
   }while( x &lt; 10 );

   return 0;
}
</code></pre>
",0
31257469,31255085,0,"<p>Here is a great way to understand the difference between a <code>while</code> loop and a <code>do</code> / <code>while</code> loop.</p>

<p>(But first, a side note: <code>do</code> / <code>while</code> are actually pretty rare in practice.  You don't usually need them.  The good, clean algorithms that you usually want to write, that naturally do the right thing for any input, and that properly do nothing when they're given no input, usually end up being written in terms of <code>while</code> loops.  ""<code>while (there's something to do) { do something; }</code>"".  But there are times when a <code>do</code> / <code>while</code> loop is exactly what you want.)</p>

<p>Suppose you're trying to convert an integer to a string, that is, construct a string containing the base-10 representation of an integer, basically just like <code>printf</code> <code>%d</code>.  This is a standard exercise.  Here is the standard solution:</p>

<pre><code>void itoa(int n, char buf[], int size)
{
    char *p = buf;
    while(n &gt; 0)
        {
        if(p &gt;= &amp;buf[size-1]) abort();
        *p++ = n % 10 + '0';
        n /= 10;
        }
   *p = '\0';

   strrev(buf);
}
</code></pre>

<p>We use the <code>%</code> operator to generate digits, filling them into a destination array.  The standard additional difficulty with this technique is that it generates digits in the wrong order; the standard way to compensate for that is with a string-reverse function.  Anyway, here's the string-reverse function and a little test driver so you can try it out:</p>

<pre><code>void strrev(char str[])
{
    char *p1 = str, *p2;
    for(p2 = str; *p2 != '\0'; p2++)
        ;
    p2--;
    while(p1 &lt; p2)
        {
        char tmp = *p1;
        *p1 = *p2; *p2 = tmp;
        p1++; p2--;
        }
}
</code></pre>

<p>So go ahead and type that code in, and compile it, and play with it.  You should discover that it works fine for just about any number you can type into it, except...</p>

<p>It does not work for zero!  If you type in 0, the test <code>while(n &gt; 0)</code> fails immediately, and we make zero trips through the loop, and we compute no digits, and we generate an empty string.</p>

<p>So: suppose you want to generate the string <code>""0""</code> for zero.  In other words, suppose we always want to make at least one trip through the loop, even when <code>n</code> is initially <code>0</code>.  This sounds like a job for... <code>do</code> / <code>while</code>!  Just rewrite the loop like this -- same body, same condition <code>(n &gt; 0)</code>, but with the condition tested at the bottom of the loop instead of at the top:</p>

<pre><code>do  {
    if(p &gt;= &amp;buf[size-1]) abort();
    *p++ = n % 10 + '0';
    n /= 10;
    } while(n &gt; 0);
</code></pre>

<p>Try this, and you'll see that it generates the same output for positive numbers, <em>and</em> now it works as expected for <code>0</code>, too.</p>

<p>(But, in case you were wondering, the other thing this simple code doesn't handle, and the <code>do</code>/<code>while</code> modification does nothing to address, is negative numbers.)</p>
",0
32406907,32406806,3,"<p>Your question is not related to the structures, but to the way C evaluates expressions. You have <code>ptr</code>, which is a pointer to some memory location that stores a structure. Basically, is the address of a memory location (an integer value). Then, you have 2 pointers, Head and Current, which are global pointers to a structure of the same type as ptr, and you want to make them point to the same structure as ptr. Basically, what you want is to allocate memory for the new structure, which is referenced by ptr, and make Head and Current point to the same memory location. Thus, you want the following assignments:</p>

<pre><code>Head = ptr;
Current = ptr;
</code></pre>

<p>You can contract those 2 expressions in one:</p>

<pre><code>Head = Current = ptr;
</code></pre>

<p>, which is evaluated as:</p>

<pre><code>(Head = (Current = ptr));
</code></pre>

<p>So, ptr is first assigned to Current, then the value of that assignment (which is ptr) is assigned to Head. And now you have a Head, which is the beginning of the linked list, and a Current pointer, which may be used for iteration and has an initial value equal to Head.</p>
",0
31883220,31883174,1,"<p>The arguments are pointers, so before calling the function, you need to create two local variables that will hold the result. Your input to the function is the pointers, and the function will produce its output in the variables being pointed to. This is a common way to allow a function to return more than one value. Call the function like this:</p>

<pre><code>long jdResult;
float fracResult;
flmoon(42, 2, &amp;jdResult, &amp;fracResult); // &amp; creates a pointer to a variable
printf(""Results: %l and %f\n"", jdResult, fracResult);
</code></pre>

<p>The variable names could well have been <code>jd</code> and <code>frac</code>, but I chose different names just to avoid the common misconception that the names of the variables you pass to the function must be the same as the function's parameter names.</p>
",0
31883269,31883174,1,"<p>The parameters <code>jd</code> and <code>frac</code> are pointers, meaning you pass in the addresses two local variables which get populated when the function completes</p>

<pre><code>long jd;
float frac;
flmoon(1,2,&amp;jd,&amp;frac);
printf(""jd=%l, frac=%f\n"",jd,frac);
</code></pre>
",0
31883695,31883174,0,"<p>There are no arguments <code>*jd</code> and <code>*frac</code>. The <code>*</code> is part of the type, designating those parameters (<code>jd</code> and <code>frac</code>) to be pointers. Looking at the function signature:</p>

<pre><code>void flmoon(int n, int nph, long *jd, float *frac);
</code></pre>

<p>This means that you have to pass some values (<code>n</code> and <code>nph</code>) as well as those two pointers to that function. The pointers need to point to some valid memory, where the function will then store it's computed results:</p>

<pre><code>*jd = // ... dereferencing, i.e. accessing the pointed memory
</code></pre>

<p>The caller can then access the results (because it's in the memory the pointer passed to the function pointed to):</p>

<pre><code>float frac;
long jd;
flmoon(n, nph, &amp;jd, &amp;frac);
// &amp; means address of
// jd and frac now contain the computed values
</code></pre>

<p>This kind of passing results is often used to pass more than one value as result (since functions can only return of value).</p>

<hr>

<p>Also, I'm quite surprised. Is this the real code used in the book? I wouldn't count that code as ""good"" ... not something that should be part of some book.</p>
",0
31886419,31886405,5,"<p>If your loop is without side-effects, probably the compiler is optimizing it away completely. To trick the compiler into generating the loop anyway a common trick is to insert an <code>asm nop</code> inside the loop (compilers usually don't mess with hand-inserted assembly, and its cost is negligible).</p>
",2
31888218,31886405,1,"<p>At least in the case of Microsoft compilers, you can use volatile on a variable to prevent the compiler from optimizing the loop away, but this will force the variable to be in memory instead of a register. You could also write a small test loop in assembler, sort of a very simple processor benchmark.</p>

<p>In a more realistic situation, where the loop is actually doing something, it shouldn't get optimized away and you'll be able to time it.</p>
",0
31886519,31886405,1,"<p>To prevent your loops from being optimized out by the compiler, you need to do something unpredictable inside the loops. The easiest thing to do is call a random number generator, like this</p>

<pre><code>srand(time(NULL));
int total = 0;
for ( int i = 0; i &lt; 1000; i++ )
    for ( int j = 0; j &lt; 1000; j++ )
       total += rand();
printf( ""%d\n"", total );
</code></pre>

<p>Note that you also have to do something with the results, e.g. print the total. Otherwise, the compiler can still optimize out the loops.</p>
",7
31887208,31886405,2,"<p>I did an experiment with gcc and here is my results. Basically as you can see below in my post compiler removes empty/idle loops in high optimization mode.</p>

<p><strong>Source file:</strong></p>

<pre><code>#include &lt;stdio.h&gt;

int main(void) {
  int i;
  for (i=0; i&lt;1024; i++);
  return 0;
}
</code></pre>

<p><strong>Compilation with no optimization:</strong></p>

<pre><code>gcc -O0 main.c
</code></pre>

<p><strong>Program dissasembly with no optimization:</strong></p>

<pre><code>00000000004004ed &lt;main&gt;:
  4004ed:   55                      push   %rbp
  4004ee:   48 89 e5                mov    %rsp,%rbp
  4004f1:   c7 45 fc 00 00 00 00    movl   $0x0,-0x4(%rbp)
  4004f8:   eb 04                   jmp    4004fe &lt;main+0x11&gt;
  4004fa:   83 45 fc 01             addl   $0x1,-0x4(%rbp)
  4004fe:   81 7d fc ff 03 00 00    cmpl   $0x3ff,-0x4(%rbp)
  400505:   7e f3                   jle    4004fa &lt;main+0xd&gt;
  400507:   b8 00 00 00 00          mov    $0x0,%eax
  40050c:   5d                      pop    %rbp
  40050d:   c3                      retq   
  40050e:   66 90                   xchg   %ax,%ax
</code></pre>

<p><strong>Compilation with maximum optimization level:</strong></p>

<pre><code>gcc -O3 main.c
</code></pre>

<p><strong>Program dissasembly with maximum optimization level:</strong></p>

<pre><code>0000000000400400 &lt;main&gt;:
  400400:   31 c0                   xor    %eax,%eax
  400402:   c3                      retq   
</code></pre>

<p><strong>You can dissasembly the program with the following command line tool:</strong></p>

<pre><code>objdump -d a.out
</code></pre>

<hr>

<p><strong>Besides you can always disable compiler optimization for any function you want with following compiler directives.</strong></p>

<p>Under GCC compiler you can turn off optimization for selected functions manually   with compiler directives like in the example below.</p>

<pre><code>#pragma GCC push_options
#pragma GCC optimize (""O0"")
static void your_not_optimized_function() {
    // your code
}
#pragma GCC pop_options
</code></pre>

<p>Under VC compiler you can turn off optimization for selected functions manually with compiler directives like in the example below.</p>

<pre><code>#pragma optimize( """", off )
static void your_not_optimized_function() {
    // your code
}
#pragma optimize( """", on ) 
</code></pre>
",3
32422904,32422879,2,"<p>It's true that <code>d &lt; p</code> is not true on the first iteration of the outer loop, but on the next iteration, <code>p</code> has the value 3.</p>

<p>The inner <code>for</code> loop does not execute when <code>p</code> is 2. It does when <code>p</code> > 2.</p>
",0
32422937,32422879,1,"<p>I think your code is working as intended.</p>

<p>When <code>p=2</code> and <code>d=2</code>,</p>

<pre><code>for ( d = 2; d &lt; p; d++)
        if ( p % d == 0 )
            isPrime = false;
</code></pre>

<p>This <code>for</code> loop is not executed, <code>isPrime</code> is still <code>True</code>, and thus it prints <code>printf("" %i "", p);</code></p>

<p><strong>Note</strong></p>

<p>If the above <code>for</code> loop would have been executed for <code>p=2</code> and <code>d=2</code>, then</p>

<pre><code>if ( p % d == 0 )
    isPrime = false;
</code></pre>

<p>This condition would have been true, <code>isPrime</code> would have been <code>False</code>, and the <code>printf("" %i "", p);</code> would not have executed.</p>
",0
32445308,32445161,0,"<p>You can use file handing/ manipulation and specifically the function:</p>

<h2>fseek()</h2>

<pre><code>int fseek(FILE *stream, long offset, int whence);
</code></pre>

<p>The <code>fseek()</code> function is used to set the <strong>file position indicator</strong> for the stream to a new position. This function accepts three arguments. The first argument is the FILE stream pointer returned by the <code>fopen()</code> function. The second argument ¡®offset¡¯ tells the amount of bytes to seek. The third argument ¡®whence¡¯ tells from where the seek of ¡®offset¡¯ number of bytes is to be done. The available values for whence are <code>SEEK_SET</code>, <code>SEEK_CUR</code>, or <code>SEEK_END</code>.  These three values (in order) depict the start of the file, the current position and the end of the file. Upon success, this function returns <code>0</code>, otherwise it returns <code>-1</code>.</p>

<blockquote>
  <p>How to reverse the order of the contents a text file?</p>
</blockquote>

<p>So, you can start reading your file backwards instead of saving all its content and then reversing its order.</p>
",2
32445446,32445161,0,"<p>As I understand your question,  you want to sort some data groups, in reverse order.  then output the resulting data groups to a new file.</p>

<p>My suggestions:</p>

<pre><code>1) read the input file, a line at a time, perhaps with fgets() or getline()
2) generate a linked list where each node in the list contains one data group.
3) always insert at the 'head' of the linked list 
4) To output, start at the 'head' and walk through the list, outputting the contents of each node.
5) you could use strstr() to find each occurrence of the end of a data group, then use memcpy to place a copy of the data into the new node to be inserted into the front of the linked list.
</code></pre>
",1
33532895,33531980,1,"<p>I corrected your Code. Here is the Corrected code,</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
//#pragma warning(disable:4996)

typedef struct
{
  int stnumber;
  char stname[20];
  char gender;
  float quiz1;
  float quiz2;
  float assigment;
  float midterm;
  float final;
  float total;
}student;


 void add_rec(student st[], int *itemcount)
 {
     againID:

      int temp = 0,count=0;
      printf(""\nEnter the student's ID (9 digits): "");
      scanf(""%d"", &amp;st[*itemcount].stnumber);
      temp = st[*itemcount].stnumber;
      while (temp != 0)//Checks if it 9 digit number or not
      {
       temp = temp / 10;
       ++count;
      }
      if (count!= 9)
      {
       printf(""Error!9 digit Number!\n"");
       goto againID;
      }

      printf(""Enter the student's Name: "");
      scanf(""%s"", &amp;st[*itemcount].stname);

    againGender:

      printf(""Enter the student's Gender(F or M): "");
      scanf(""%s"", &amp;st[*itemcount].gender);
      if (st[*itemcount].gender != 'm' &amp;&amp; st[*itemcount].gender != 'M' &amp;&amp;   st[*itemcount].gender != 'f' &amp;&amp; st[*itemcount].gender != 'F')
      {
        printf(""invalid\n""); goto againGender;
      }

    againquiz1:

     printf(""Enter the student's 1st quiz score: "");
     scanf(""%f"", &amp;st[*itemcount].quiz1);
     if (st[*itemcount].quiz1 &lt; 0 || st[*itemcount].quiz1 &gt; 100)
     {
       printf(""invalid\n""); goto againquiz1;
     }

    againquiz2:

      printf(""Enter the student's 2nd quiz score: ""); scanf(""%f"",   &amp;st[*itemcount].quiz2);
      if (st[*itemcount].quiz2 &lt; 0 || st[*itemcount].quiz2 &gt; 100)
      {
         printf(""invalid\n""); goto againquiz2;
      }

    againAssigment:

      printf(""Enter the student's assigment score: ""); scanf(""%f"",  &amp;st[*itemcount].assigment);
      if (st[*itemcount].assigment &lt; 0 || st[*itemcount].assigment &gt; 100)
      {
        printf(""invalid\n""); goto againAssigment;
      }

    againMidterm:

      printf(""Enter the student's mid-term score: ""); scanf(""%f"", &amp;st[*itemcount].midterm);
      if (st[*itemcount].midterm &lt; 0 || st[*itemcount].midterm &gt; 100)
      {
         printf(""invalid\n""); goto againMidterm;
      }

    againFinal:

       printf(""Enter the student's final score: ""); scanf(""%f"", &amp;st[*itemcount].final);
       if (st[*itemcount].final &lt; 0 || st[*itemcount].final &gt; 100)
       {
          printf(""invalid\n""); goto againFinal;
       }

       st[*itemcount].total = st[*itemcount].quiz1 + st[*itemcount].quiz2 +   st[*itemcount].assigment + st[*itemcount].midterm + st[*itemcount].final;

      ++(*itemcount);
}
int main()
{
  student st[20];
  int itemcount = 0,i=0;
  char confirm;
  do
  {
    add_rec(st, &amp;itemcount);
    printf(""Press y or Y to continue: "");
    scanf(""%c"", &amp;confirm);
  } while (confirm == 'y' || confirm == 'Y');
  for (i = 0; i &lt; itemcount; i++)
  {
    printf(""%s\n"", st[i].stname);
    printf(""%d\n"", st[i].stnumber);
    printf(""%c\n"", st[i].gender);
    printf(""%f\n"", st[i].quiz1);
    printf(""%f\n"", st[i].quiz2);
    printf(""%f\n"", st[i].assigment);
    printf(""%f\n"", st[i].midterm);
    printf(""%f\n"", st[i].final);
    printf(""%f\n"", st[i].total);
    printf(""\n"");
  }
  return 0;
 }
</code></pre>

<p>The Things which I changed/Added to your code are,</p>

<ol>
<li><p>I Changed <code>char stnumber[10];</code> to <code>int stnumber</code></p></li>
<li><p>Accordingly,I changed this code </p>

<pre><code> againID:
  printf(""\nEnter the student's ID (9 digits): "");
  scanf("" %s"",&amp;st[*itemcount].stnumber);
  if (strlen(st[*itemcount].stnumber) != 9)
  {
    printf(""invalid\n""); goto againID;
  }
</code></pre>

<p>To this code,</p>

<pre><code> againID:
  int temp = 0,count=0;
  printf(""\nEnter the student's ID (9 digits): "");
  scanf(""%d"", &amp;st[*itemcount].stnumber);
  temp = st[*itemcount].stnumber;
  while (temp != 0)//Checks if it 9 digit number or not
  {
     temp = temp / 10;
     ++count;
  }
  if (count!= 9)
  {
     printf(""Error!9 digit Number!\n"");
     goto againID;
  }
</code></pre></li>
<li><p>Changed this code <code>scanf(""%s"",&amp;confirm);</code> to <code>scanf(""%c"",&amp;confirm);</code></p></li>
<li><p>Finally, I added the following code to show that your data is saved.</p>

<pre><code>for (i = 0; i &lt; itemcount; i++)
{
  printf(""%s\n"", st[i].stname);
  printf(""%d\n"", st[i].stnumber);
  printf(""%c\n"", st[i].gender);
  printf(""%f\n"", st[i].quiz1);
  printf(""%f\n"", st[i].quiz2);
  printf(""%f\n"", st[i].assigment);
  printf(""%f\n"", st[i].midterm);
  printf(""%f\n"", st[i].final);
  printf(""%f\n"", st[i].total);
  printf(""\n"");
}
</code></pre></li>
</ol>
",0
33533375,33531980,1,"<p>The first two call to scanf in add_rec are wrong you have to remove the &amp;:</p>

<p>those are the lines corrected:</p>

<pre><code>scanf(""%s"", st[*count].stnumber);

scanf(""%s"", st[*count].stname);
</code></pre>

<p>Moreover in the main this:</p>

<pre><code>scanf(""%s"",&amp;confirm);
</code></pre>

<p>should be </p>

<pre><code>scanf("" %c"",&amp;confirm);
</code></pre>

<p>see also <a href=""https://stackoverflow.com/questions/6582322/what-does-space-in-scanf-mean"">What does space in scanf mean?</a></p>
",3
33533581,33531980,0,"<p>It might have been easier to see cleaned up a bit.  Good style is important because it let's you see the logics bugs more easily.  Don't go past 80 chars per line.  Simplify where possible.  Don't use goto's.  You used negative if's instead of positive if's.  add_rec had huge amounts of needless replication.</p>

<p>I cleaned up Mutex202's solution for your existing style [credit to Mutex202]:</p>

<pre><code>void
add_rec_score(const char *prompt,float *score)
{

    while (1) {
        printf(""Enter the student's %s score: "",prompt);
        scanf(""%f"", score);
        if (*score &gt;= 0 &amp;&amp; *score &lt;= 100)
            break;
        printf(""invalid\n"");
    }
}

void
add_rec(student *st, int *itemcount)
{
    int temp;
    int count;

    st += *itemcount;

    while (1) {
        printf(""\nEnter the student's ID (9 digits): "");
        scanf(""%d"", &amp;st-&gt;stnumber);
        temp = st-&gt;stnumber;

        // Checks if it 9 digit number or not
        count = 0;
        while (temp != 0) {
            temp = temp / 10;
            ++count;
        }
        if (count == 9)
            break;

        printf(""Error!9 digit Number!\n"");
    }

    printf(""Enter the student's Name: "");
    scanf(""%s"", &amp;st-&gt;stname);

    while (1) {
        printf(""Enter the student's Gender(F or M): "");
        scanf(""%s"", &amp;st-&gt;gender);
        if (st-&gt;gender == 'm' || st-&gt;gender == 'M' ||
            st-&gt;gender == 'f' || st-&gt;gender == 'F')
            break;
        printf(""invalid\n"");
    }

    add_rec_score(""1st quiz"",&amp;st-&gt;quiz1);
    add_rec_score(""2nd quiz"",&amp;st-&gt;quiz2);
    add_rec_score(""assignment"",&amp;st-&gt;assignment);
    add_rec_score(""mid-term"",&amp;st-&gt;midterm);
    add_rec_score(""final"",&amp;st-&gt;final);

    st-&gt;total = st-&gt;quiz1 + st-&gt;quiz2 + st-&gt;assigment + st-&gt;midterm + st-&gt;final;

    *itemcount += 1;
}
</code></pre>

<p>Notice that I replaced the <code>st[*itemcount].whatever</code> with <code>st-&gt;whatever</code> because it was invariant throughout add_rec.</p>
",0
32447330,32447268,12,"<p>When you use</p>

<pre><code>while (*s++ != '\0');
</code></pre>

<p><code>s</code> points to one character past the null character when the loop breaks. You end up copying the contents of <code>t</code> to <code>s</code> but after the null character.</p>

<p>If <code>s</code> is <code>""string 1""</code> before the function and <code>t</code> is <code>""string 2""</code>, at the end of the function, you will end up with a character array that will look like:</p>

<pre><code>{'s', 't', 'r', 'i', 'n', 'g', ' ', '1', '\0', 's', 't', 'r', 'i', 'n', 'g', ' ', '2', '\0', ... }
                                         ^^^^
</code></pre>

<p>Due to the existence of the null character in the middle, you won't see <code>""string 2""</code> in most uses.</p>

<p>On the other hand, when you use:</p>

<pre><code>while (*s != '\0')
        s++;
</code></pre>

<p><code>s</code> points to the null character when the loop breaks. Given the same input, you will end up with a character array that will look like:</p>

<pre><code>{'s', 't', 'r', 'i', 'n', 'g', ' ', '1', 's', 't', 'r', 'i', 'n', 'g', ' ', '2', '\0', ... }
                     No null character in the middle.
</code></pre>
",2
32960071,32960054,2,"<pre><code>printf(""name is : %c"", name); // and this prints a weird symbol on the terminal
</code></pre>

<p>The <code>%c</code> format specifier is for printing a character, but <code>name</code> is an array of characters terminated by an ASCII nul (also called a C-style string). For strings, use <code>%s</code>, not <code>%c</code>.</p>
",2
33602698,33602680,9,"<p><code>sizeOf(Node)</code> should be <code>sizeof(Node)</code>, note the small <code>o</code>.  After all this is C, not Java.  :)</p>
",3
32968207,32968012,0,"<p><code>p[0]</code>  is identical to <code>*(p+0)</code> , similarly goes for <code>s[1]</code> . <code>[]</code> always operates on a pointer and is same for arrays and pointers.</p>

<p><em>Note</em> - There is no array declared in your program.</p>
",5
33008946,32968012,0,"<p>Please note the following facts first( They are neutral to programming LANGUAGE )</p>

<ol>
<li><p>Any pointer has/ takes memory equals to <strong>size of your systems data bus</strong></p></li>
<li><p>even void* takes size equals <strong>size of your systems data bus</strong></p></li>
<li><p>Now size of data bus is size of <strong>processors data fetching/manipulating capacity</strong>, you might heard 32 Bit processor, 64 Bit processor</p></li>
<li><p>Finally <strong>processors data fetching/manipulating capacity</strong> equals size of your int, that's why we use following code to calculate Architecture of CPU</p></li>
</ol>

<p><br></p>

<pre><code>#include&lt;stdio.h&gt;
int main(){
if(sizeof(int)==2) {
    printf(""\n 16 Bit Architecture, may be using DOS &amp; Turbo C++ IDE"");
}else if(sizeof(int)==4)  {
    printf(""\n 32 Bit Architecture"");
}else {
    printf(""\n 64 Bit Architecture"");
}
return 0;
}
</code></pre>

<p><a href=""https://i.stack.imgur.com/CEOIU.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/CEOIU.jpg"" alt=""Showing RAM Status""></a></p>
",0
33035252,33033405,1,"<p>I'd suggest a simpler and faster approach like this</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

int main(void) {
    char str[1000];
    scanf(""%s"", str);
    int c[26] = {0}, ans = 1;
    for (int i = 0; str[i]; ++i)
        if (isalpha(str[i]))    // Only if alphabet
            c[tolower(str[i]) - 'a']++;
    for (int i = 0; i &lt; 26; ++i)
        if (!c[i]) {    // Break if not pangram
            ans = 0;
            break;
        }
    printf(ans ? ""pangram"" : ""not pangram"");
    return 0;
}
</code></pre>

<blockquote>
  <p>Time Complexity <strong>O(string length + constant)</strong></p>
</blockquote>
",0
33033851,33033405,1,"<p>Modify your code as follow :</p>

<pre><code>int a[27];count=0;
for(k=0;k&lt;27;k++)
    a[k]=0;
for(i=0;str[i]!='\0';i++)
{
    if(str[i]&gt;96 &amp;&amp; str[i]&lt;123)
        a[str[i]-96]++;
    else if(str[i]&gt;64 &amp;&amp; str[i]&lt;91)
        a[str[i]-64]++;
}
for(k=1;k&lt;27;k++)
   if(a[k]&gt;0)
      count++;
if(count==26)
    printf(""panagram"");
</code></pre>
",3
33034086,33033405,1,"<p>You have a typo on</p>

<pre><code>for(l=65;i&lt;91;l++)
</code></pre>

<p>Should be</p>

<pre><code>for(l=65;l&lt;91;l++)
</code></pre>

<p>Another problematic thing that can invoke <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow"">UB</a> is the code            </p>

<pre><code>if(str[i+1]=='\0')
{
   i=i+2;
   printf("".-----------%d --- %c\n"", i, str[i]);
}
</code></pre>

<p>Beacuse of is inside <code>for(i=0;str[i]!='\0';)</code></p>

<p>It means that each time a <code>null</code> terminator is found the for continue until a sequence of <code>""\0\0""</code> is found. This will invoce <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow"">UB</a> because of your <code>str</code> is not inited and anyway if <code>str</code> will be <code>1000</code> chars long. </p>
",5
32960262,32960125,2,"<p>Why not <code>char *inp = argv[1];</code>?</p>

<p>Or better yet:</p>

<pre><code>fp = fopen(argv[1], ""r"");
</code></pre>

<hr>

<p>The problem with your code is this:</p>

<pre><code>char *inp;
strcpy(inp,argv[1]);
</code></pre>

<p>You're copying <code>argv[1]</code> into <code>inp</code>, but you have no idea what <code>inp</code> points to. If you really want to go that route, you have to allocate memory for <code>inp</code>.</p>

<pre><code>char *inp = malloc(strlen(argv[1]) + 1); /* allocate enough for the string and null-terminator */
strcpy(inp,argv[1]); /* copy the contents */
</code></pre>

<p>Just remember to <code>free()</code> afterwards.</p>

<p>P.S. <strong>Never</strong> use <code>while(!feof(fp))</code>. Just use <code>while(fgets(str,4,fp))</code>. 
See <a href=""https://stackoverflow.com/questions/5431941/why-is-while-feof-file-always-wrong"">this question</a> for more info.</p>
",0
32993756,32993665,1,"<pre><code>*(c+b)
</code></pre>

<p>It is known as <strong>Pointer Arithmetic</strong>.</p>
",1
32993765,32993665,1,"<pre><code>*(c+b)
</code></pre>
<p>This is equivalent to <code>c[b]</code> .</p>
<p>According to C99 standard -</p>
<blockquote>
<p>6.5.2.1 Array subscripting</p>
<p>Constraints</p>
<p>1.One of the expressions shall have type ''pointer to complete object type'', the other expression shall have integer type, and the result has type ''type''.</p>
<p>Semantics</p>
<p>2 A postfix expression followed by an expression in square brackets [] is a subscripted designation of an element of an array object. The definition of the subscript operator [] is that E1[E2] is identical to (*((E1)+(E2))). Because of the conversion rules that apply to the binary + operator, if E1 is an array object (equivalently, a pointer to the initial element of an array object) and E2 is an integer, E1[E2] designates the E2-th element of E1 (counting from zero).</p>
</blockquote>
",1
33558285,33558240,0,"<p>if you cant use a modern serialization format like json or yaml how about</p>

<pre><code>`0010first data0011second data` 
</code></pre>

<p>etc. ie fixed length length length followed by string</p>
",0
33558135,33558115,6,"<p>The code:</p>

<pre><code>return(*scriptFunction[x])(arguments);
</code></pre>

<p>actually <em>is</em> only returning one value.</p>

<p>The variable <code>scriptFunction</code> will be an array of function pointers<sup>(1)</sup>. You look up element number <code>x</code> of that array, and call that function, passing the argument <code>arguments</code>. Then the return value from <em>that</em> function is what you return to your caller.</p>

<p>Other than the function pointer aspect, it's no different to <code>return sqrt(42)</code>.</p>

<hr>

<p>By way of example, the following program demonstrates how this can be done:</p>

<pre><code>#include &lt;stdio.h&gt;

// Two simple functions which add a fixed value.

int fnPlus3 (int n) { return n + 3; }
int fnPlus7 (int n) { return n + 7; }

// An array holding those two functions.

int (*scriptFunction[])(int) = { fnPlus3, fnPlus7 };

int main (void) {
    // Call first function in array.

    int x = 0;
    printf (""%d\n"", (*scriptFunction[x])(100));

    // Then call second one.

    x = 1;
    printf (""%d\n"", (*scriptFunction[x])(100));

    return 0;
}
</code></pre>

<p>Although it <em>prints</em> the return value from the function rather than returning it again, it still uses the same <em>expression</em> and you can see it calls a different function based on the value of <code>x</code>:</p>

<pre><code>103
107
</code></pre>

<hr>

<p><sup>(1)</sup> Or some form of equivalent, such as a pointer to an array of function pointers, or a pointer to a single function pointer (assuming <code>x</code> is always set to zero in that latter case).</p>
",2
33558143,33558115,2,"<p>Presumably <code>scriptFunction</code> is an array of pointers to functions. <code>*scriptfunction[x]</code> is then the dereferenced pointer to function (the <code>x</code>-th one). Finally, <code>*scriptfunction[x](arguments)</code> represents the invocation of that function applied to <code>arguments</code>, so the result of that function is what's returned in the end.</p>

<p>Side comment: the <code>*</code> is not really necessary. A pointer to function does not need to be dereferenced to call the function, i.e. you can use</p>

<pre><code>return scriptFunction[x](arguments);
</code></pre>

<p>instead.</p>
",1
33558162,33558115,0,"<p>From the looks of it, it seems the line <code>return (*scriptFunction[x])(arguments);</code> <code>scriptFunction</code> is an array of function pointers, and this is simply invoking the function at position indexed by variable <code>x</code> and sending <code>arguments</code> variable contents as its input.</p>

<p>The return value of this invoked function is what ultimately gets returned.</p>

<hr>

<p>This working example should be useful:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

void func_a(int i)
{
        cout &lt;&lt; ""func_a: "" &lt;&lt; i &lt;&lt; endl;
}

void func_b(int i)
{
        cout &lt;&lt; ""func_b: "" &lt;&lt; i &lt;&lt; endl;
}

int main()
{
        void (*funcs[])(int) = { func_a, func_b };

        for(int i = 0; i &lt; 2; ++i)
                (*funcs[i])(i+1);

        return 0;
}
</code></pre>

<p>The output is below:</p>

<pre><code>?  /tmp  g++ test.cpp -o test
?  /tmp  ./test
func_a: 1
func_b: 2
</code></pre>

<hr>

<p>Also, for future reference, you should consult: <a href=""https://stackoverflow.com/help/how-to-ask"">How to ask good questions?</a></p>
",2
33532184,33531976,0,"<p>Two issues:</p>

<p>First, you have some very large arrays in main, which are allocated on the stack.  This can cause issues with stack overflow.</p>

<p>Either declare these large arrays as globals, or allocate them dynamically using <code>malloc</code>.</p>

<p>The second issue is that <code>i</code> is not initialized when entering the first <code>do...while</code> loop.   This value could be anything, so it could result in indexing off the end of the array <code>v</code>, leading to undefined behavior.  This is what caused your program to crash.  The fact that it didn't crash after changing the size of the arrays was luck.  Any other change to the code could cause the crash to resurface.</p>

<p>Set <code>i</code> to 0 and you should be fine.</p>

<pre><code>i=0;
do{
    i++;
    printf(""N¨²mero de votos do %do partido: "",i);
    scanf(""%f"",&amp;v[i]);
}while(i&lt;n);
</code></pre>

<p>EDIT:</p>

<p>Regarding making the block of code you mentioned a function, move any variables defined in <code>main</code> that are used ONLY in this block to the function, and pass in the remaining parameters that <code>main</code> uses.</p>
",1
34207335,34206858,1,"<p>The code has several serious problems :</p>

<ul>
<li>line 64 delete <code>;</code>, you have an infinite loop here!</li>
<li>it is not useful to compare <code>str</code> against <code>NULL</code> (this is always false!), this seems to cause your problem at runtime (my compiler complains at compile-time)</li>
<li>the two <code>printf</code> line 78 and 88 have too much arguments (reconsider the format...).</li>
</ul>

<p>After correcting, it seems to work (at least I was able to answer two questions)...</p>
",0
33584861,33584836,0,"<p>Missing a semicolon in function prototype definition</p>

<pre><code>int reverse (int x);
                   ^
</code></pre>

<hr>

<pre><code>v=10*(int reverse (int x))+z
</code></pre>

<p>Thats not how a function is called, you have call like this</p>

<pre><code>v=10*(reverse(x))+z; //a missing semicolon here too
</code></pre>

<hr>

<p>Your function<code>reverse()</code> is not returning anything.</p>

<pre><code>int reverse(int x);
{
    if(x&gt;=10)
        reverse(n/10);
    printf(""%d"",n%10);
    return;            //Return whatever int you want to here
}
</code></pre>

<hr>

<p><em>Please go through some good Basic C programming book.</em></p>
",0
34244810,34244787,2,"<p>Replace <code>\</code> with double slash <code>\\</code>:</p>

<pre><code>pFile = fopen(""C:\\Users\\Wilmer\\Desktop\\abc.txt"", ""w"");
</code></pre>

<p>A single slash makes them interpret as escape sequences. Escaping the single slash will do.</p>
",0
34244830,34244787,1,"<p>You need to escape the backslash (<code>\</code>) characters:</p>

<pre><code>pFile = fopen(""C:\\Users\\Wilmer\\Desktop\\abc.txt"", ""w"");
</code></pre>

<p>Or use slash (<code>/</code>):</p>

<pre><code>pFile = fopen(""C:/Users/Wilmer/Desktop/abc.txt"", ""w"");
</code></pre>
",0
34194139,34194120,1,"<p><strong>How does this thing work?</strong></p>

<p>This works because <code>scanf()</code> reads only till a <code>space</code> or <code>newline</code> or <code>tab</code> is encountered.</p>

<p>So, when you give input <code>1 2 3 4 5</code>, at the first iteration <code>scanf()</code> reads <code>1</code> and a <code>space</code> is encountered and <code>scanf()</code> terminates keeping the value <code>1</code> to a[0]<code>. At the next iteration</code>2` is read the same way.</p>
",0
34194147,34194120,0,"<p><a href=""http://en.cppreference.com/w/c/io/fscanf"" rel=""nofollow"">The <code>scanf</code> (and family) function</a> with the <code>""%d""</code> format reads <em>white-space delimited</em> input. If the white-space is a newline or a single space doesn't matter.</p>

<p>The <kbd>Enter</kbd> key simply tells the input stream system that input is ready (<code>stdin</code> which is used by <code>scanf</code> is <em>line buffered</em> by default), exactly what that input is doesn't matter.</p>
",0
34086338,34085506,0,"<p>The two main problems are these:</p>

<blockquote>
  <p>scanf(""  %c"", &amp;Template );</p>
</blockquote>

<p>should be </p>

<pre><code>scanf(""  %c"", &amp;Template[0]);
</code></pre>

<blockquote>
  <p>sprintf(name, ""%c"", Template);</p>
</blockquote>

<p>should be </p>

<pre><code>sprintf(zahl, ""%c"", Template[0]);
</code></pre>
",0
34085733,34085506,0,"<p>First problem seems to be that you're using spaces in scanf when reading variable Template.
See hints here: <a href=""https://stackoverflow.com/questions/4358383/c-scanf-with-spaces-problem"">C scanf with spaces problem</a></p>
",3
34087375,34085506,0,"<p>Been testing a little, this works:</p>

<pre><code>int main()
{
  int CaseSize, Type, Counter;
  char name[100];
  char zahl[20];
  char Template;

  FILE *stream;

  scanf(""%d"", &amp;CaseSize);
  scanf(""%d"", &amp;Type);
  scanf("" %c"", &amp;Template);
  scanf(""%2d"", &amp;Counter);

  strcpy(name, ""File "");
  sprintf(zahl, ""%d"", CaseSize);
  strcat(name, zahl);
  strcat(name, ""-"");
  sprintf(zahl, ""%d"", Type);
  strcat(name, zahl);
  strcat(name, ""B-"");
  sprintf(zahl, ""%c"", Template);
  strcat(name, zahl);

  sprintf(zahl, ""%02d"", Counter);
  strcat(name, zahl);
  strcat(name, "".dat"");
  printf(""%s\n"", name);
  stream=fopen(name, ""a"");
  fclose(stream);
  return 0;
}
</code></pre>
",0
34088256,34085506,0,"<p>You can do all that in a single <code>sprintf</code> statement:</p>

<pre><code>sprintf( name, ""File %d-%dB-%c%02d.dat"", CaseSize, Type, Template, Counter );
</code></pre>

<p>Given how you're using <code>Template</code>, you should not declare it as a 1-element array of <code>char</code>; the types of the expressions <code>&amp;Template</code> and <code>Template</code> will be <code>char (*)[1]</code> and <code>char *</code> respectively, which is not what you want.  Declare it as a plain <code>char</code> instead.</p>
",0
34088804,34085506,3,"<p>The code has a number of issues with format specifiers and data types, but apart from that is remarkably inefficient and unnecessarily complex. </p>

<p>Changing <code>char Template[1]</code> to just <code>char Template</code>, and removing the redundant <code>zahl[]</code>, the 12 lines you have for constructing <code>name</code> can be reduced to just:</p>

<pre><code>sprintf( name, ""%s %d-%dB-%c%02d.dat"", ""File"", CaseSize, Type, Template, Counter ) ;
</code></pre>

<p>One problem with C strings is that they contain no length information, so functions such as <code>strcat()</code> must iterate from the beginning searching for the nul terminator; here you are using <code>strcat()</code> repeatedly on an increasingly long string.  In this short string construction, thus is perhaps not significant, but in some cases it can become <a href=""http://www.joelonsoftware.com/articles/fog0000000319.html"" rel=""nofollow"">prohibitively slow</a>.  Apart from that, more lines of code simply mean more code to maintain and debug. Here the entire format is described in one line of code, so it is mich easier in maintenance to see what it is that should be constructed.</p>
",1
34188695,34188576,5,"<p>You need to declare an actual <code>myStruct</code>. Not a pointer to one. Declaring a pointer to one doesn't actually allocate any memory for the struct.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;string.h&gt;

struct myStruct {

   uint8_t arr[10];
};


int main(int argc, char **argv) {

    int i;
    uint8_t test[10] = {0,1,2,3,4,5,6,7,8,9};
    struct myStruct struc;
    memcpy(struc.arr, test, sizeof(struc.arr));


    printf(""struc.arr[] = "");

    for( i=0; i &lt; sizeof(test); i++ )
    {
        printf(""%d "", struc.arr[i]);
    }

    printf(""\n"");
    return( 0 );
}
</code></pre>
",1
34188707,34188576,0,"<p>You are getting a segmentation fault because you didn't allocate your struct pointer.</p>

<pre><code>int main(int argc, char **argv) {
    uint8_t test[10] = {0};
    struct myStruct *struct = malloc(sizeof(struct myStruct));
    if (!struc)
        return -1;
    memcpy(struc-&gt;arr, test, sizeof(test));
    free(struc);
    return 0;
}
</code></pre>

<p>But, as @Chimera mentioned, you perfectly can not use a point and directly a heap-allocated structure, and access to its inner fields with the <code>.</code> operator</p>
",3
34213968,34213896,2,"<p>Try something like:</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    int grade;
    int r=0;
    while(r != 1)
    {
    scanf(""%i"", &amp;grade);
        switch(grade)
            {
                case 10:
                case 9:
                    printf(""Your grade is an A\n"");
                    r=1
                    break;
                case 8:
                    printf(""Your grade is a B\n"");
                    r=1
                    break;
                case 7:
                    printf(""Your grade is a C\n"");
                    r=1
                    break;
                case 6:
                    printf(""Your grade is a D\n"");
                    r=1
                    break;
                case 5:
                case 4:
                case 3:
                case 2:
                case 1:
                case 0:
                    printf(""Your grade is an F\n"");
                    r=1
                    break;
                default:
                    printf(""Invalid score, please re-enter\n"");
                    break;
            }
    }

    return 0;
}
</code></pre>
",1
34213971,34213896,0,"<p>The reason your code always loops is because there is no way to exit out of your <code>while</code> other than to kill the program. Remember that <code>break</code> only breaks out of the inner-most <code>switch</code> or loop.</p>

<p>The cleanest way to break out of multiple levels is to use a flag. One way to do what you want is like this:</p>

<pre><code>bool valid_grade = false;
while(!valid_grade &amp;&amp; (r = scanf(""%i"", &amp;grade)) != EOF)
{
    valid_grade = true;
    switch(grade)
        {
            case 10:

             // unchanged from your code

            default:
                valid_grade = false;
                printf(""Invalid score, please re-enter\n"");
        }
}
</code></pre>
",2
34214315,34213896,1,"<p>This will clear the input buffer on an invalid input and allow a retry.</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    int grade;
    int r;
    while((r = scanf(""%i"", &amp;grade)) != EOF)
    {
        if ( r != 1) {//r == 1 is successful input of integer
            grade = -1;//reset grade on invalid input
        }
        switch(grade)
        {
            case 10:
            case 9:
                printf(""Your grade is an A\n"");
                break;
            case 8:
                printf(""Your grade is a B\n"");
                break;
            case 7:
                printf(""Your grade is a C\n"");
                break;
            case 6:
                printf(""Your grade is a D\n"");
                break;
            case 5:
            case 4:
            case 3:
            case 2:
            case 1:
            case 0:
                printf(""Your grade is an F\n"");
                break;
            default:
                printf(""Invalid score, please re-enter\n"");
                while ( getchar() != '\n');//clear input buffer
        }
    }
    return 0;
}
</code></pre>
",0
34256533,34256492,0,"<p>Make a <code>for</code> loop, let it iterate from <code>i = 0</code> to <code>9</code>. In each iteration, allocate one <code>struct hash</code> and point <code>v[i]</code> to it. Afterwards, initialize <code>*v[i]</code> as needed. Don't forget to check if <code>malloc()</code> failed.</p>
",0
34269214,34269110,2,"<p>The type of <code>current</code> is <code>struct node*</code> but your <code>push</code> function is returning a <code>struct node</code>.</p>

<p>So changing</p>

<pre><code>struct node push(node_t * head, int val)
</code></pre>

<p>to</p>

<pre><code>struct node *push(node_t * head, int val)
</code></pre>

<p>should do the job.</p>
",1
26231235,6325940,7,"<p>You can detect failure when:</p>
<h3><code>malloc(n)</code> returns <code>NULL</code></h3>
<p>This is the most common and reliable test to detect an allocation failure. If you want to be portable beyond POSIX/SUS, I wouldn't trust <code>errno</code> though. If you need detail, say for logging, I'd zero <code>errno</code> before the call, see if it changed, then maybe log that.</p>
<h3><code>malloc(n)</code> returns a non-<code>NULL</code> address which is not backed by actual memory</h3>
<p>Touch it and see if you get killed by the OS. Yes, this can happen. It's called <strong>memory overcommit</strong> and resembles <a href=""https://en.wikipedia.org/wiki/Fractional_reserve_banking"" rel=""nofollow noreferrer"">fractional reserve banking</a>. It's the optimistic approach of an OS or hypervisor to return addresses to virtual memory they're gambling they won't ever have to actually provide. This happens on <a href=""http://lwn.net/Articles/317814/"" rel=""nofollow noreferrer"">Linux</a>, <a href=""http://blog.scottlowe.org/2008/03/18/more-on-memory-overcommitment/"" rel=""nofollow noreferrer"">VMware</a>. (I can't find any explicit evidence of Windows overcommitting, although requested <a href=""http://blogs.msdn.com/b/ntdebugging/archive/2007/10/10/the-memory-shell-game.aspx"" rel=""nofollow noreferrer"">pages are only &quot;committed&quot; when they are touched</a>.)</p>
<p>The question then is &quot;how do I portably detect if my program is about to crash on accessing an address I got from the malloc I previously trusted like a teenage crush?&quot;. One way might be to <a href=""https://stackoverflow.com/a/4404125/19502""><code>read()</code> a random file into the test area</a> and see if the OS returns EINVAL or equivalent.</p>
<p>For extra points,</p>
<h3><code>malloc(0)</code> returns <code>NULL</code> and leaves <code>errno</code> undefined</h3>
<p>I know the question asked for &quot;non-zero [sized] memory block&quot;, but this is interesting. Consider a SUS-compliant allocator that <em>intends</em> to return non-<code>NULL</code> for a zero-sized allocation (it can do that), but then it fails, so it has to return <code>NULL</code>. And it could try to set <code>errno</code>. Is that a failure? I think Hoare says we paid a billion dollars for this ambiguity. So, calling <code>malloc(0)</code> is not portable and the questioner probably knew that!</p>
",0
26238996,6325940,4,"<p><code>malloc(n)</code> returns <code>NULL</code> on failure.<br>
<code>malloc(0)</code> <em>may</em> return <code>NULL</code>.  </p>

<p>To detect failure:</p>

<pre><code>void* ptr = malloc(n);
if (ptr == NULL &amp;&amp; n &gt; 0) Handle_Failure();
</code></pre>

<hr>

<p>Notes:</p>

<p>As in OP's case: ""... allocate non-zero memory block"", often code is such that a <code>0</code> allocation request can not occur and so the <code>0</code> test is not needed.</p>

<pre><code>size_t nstr = strlen(some_string) + 1;
void* ptrstr = malloc(nstr);
if (ptrstr == NULL) Handle_Failure();
</code></pre>

<p>Some systems set <code>errno</code> on failure, but not all.  Setting <code>errno</code> due to memory allocation failure is <em>not</em> specified in the C11 spec.</p>

<p><code>malloc(n)</code> expects <code>n</code> to be the unsigned type <code>size_t</code>.  Using an <code>int n</code> with a negative value will certainly convert to some large unsigned value and then likely fail the memory allocation.</p>
",0
29536391,29536376,7,"<p>The reason is that you placed a <code>\n</code> character in <code>scanf</code>. This will let <code>scanf</code> to ignore any number of <code>\n</code> (or <kbd>Enter</kbd> button hit) after the input.  Remove <code>\n</code> character from <code>scanf</code>.  </p>

<pre><code>scanf(""%d\n"", (vector+j));  
      // ^^Remove this.
</code></pre>
",0
25689370,25689240,4,"<p>as per dasblinkenlight</p>

<p>You need to do this:</p>

<pre><code>sscanf(argv[1], ""%x"", &amp;hex);
</code></pre>

<p>BUT</p>

<p>sscanf returns the number of arguments (as in %x) successfully parsed. So I would add a check for it to be 1. If it isn't they entered something that could be parsed to hex.</p>

<pre><code>printf(""\n argc : %d argv[1] : %s \n"",argc,argv[1]);
if (sscanf(argv[1], ""%x"", &amp;hex)==1)
    printf(""\n hex : %x \n"",hex);
else
    printf(""\nargv[1] is not a valid hex value."");
</code></pre>

<p>if you don't check the return value you will not pick up the point of failure in your code.</p>

<p>sscanf can be used to match patterns and extract the variable values from them like a date import for example:</p>

<pre><code>int day, month, year;
int count = sscanf (inputstr, ""%d/%d/%d"", &amp;day, &amp;month, &amp;year );
if (count!=3)
     printf(""bad date value"");
</code></pre>
",4
25689286,25689240,5,"<p>This is incorrect:</p>

<pre><code>hex = argv[1];
</code></pre>

<p>The compiler should have warned you about assigning a <code>char*</code> to <code>int</code>, because <code>argv[1]</code> is a string representation of a hex number (i.e. <code>{'3','4','3','e','d','4','\0'}</code>), not a hex number itself.</p>

<p>You need to do this:</p>

<pre><code>sscanf(argv[1], ""%x"", &amp;hex);
</code></pre>

<p><code>sscanf</code> parses the hex number for you, and stores the result in <code>hex</code>.</p>
",1
25471144,25470814,1,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

char *last(const char *s, char sep){
    char *tmp = strdup(s);
    char *ret, *p = strrchr(tmp, sep);
    if(p){
        if(p[1]){
            ret = strdup(p+1);
        } else {
            *p = '\0';
            p = strrchr(tmp, sep);
            ret = strdup(p ? p+1 : tmp);
        }
        free(tmp);
        return ret;
    }
    return tmp;
}

int main(){
    char *str = ""/angus/declan/"";
    char *str1 = ""dir1/"";
    char *str2 = ""/clington"";
    char* lname,*lname1,*lname2;
    lname  = last(str, '/');
    lname1 = last(str1, '/');
    lname2 = last(str2, '/');
    printf(""\n lname : %s, lname1 : %s, lname2 : %s \n"",lname,lname1,lname2);
    free(lname);free(lname1);free(lname2);
    return 0;
}
</code></pre>
",9
29951252,19238390,0,"<p>I like this thread to include a ""comment stripper"" in my project before handing it to the JSON parser. Only I like a FSM approach better. Hopefully my implementation is understandable and useful to anybody:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void strip(int ch, FILE *stream)
{
    static enum strip_states {
        STRIP_STATE_PUTC = 0,
        STRIP_STATE_SINGLE,
        STRIP_STATE_MULTI,
        STRIP_STATE_STRING,
    } state = STRIP_STATE_PUTC;
    static char _ch = 0;
    static unsigned char _nestlevel = 0;

    /* String */
    if (state == STRIP_STATE_PUTC &amp;&amp;
        ch == '""') {
        state = STRIP_STATE_STRING;
    } else if (state == STRIP_STATE_STRING &amp;&amp;
        ch == '""') {
        state = STRIP_STATE_PUTC;
    /* Multiline */
    } else if (_ch == '/' &amp;&amp; ch == '*') {
        if (state == STRIP_STATE_PUTC)
            state = STRIP_STATE_MULTI;
        else if (state == STRIP_STATE_MULTI)
            _nestlevel++;
    } else if (_ch == '*' &amp;&amp; ch == '/') {
        if (state == STRIP_STATE_MULTI &amp;&amp;
            _nestlevel &gt; 0)
            _nestlevel--;
        else if (state == STRIP_STATE_MULTI &amp;&amp;
            _nestlevel == 0)
            state = STRIP_STATE_PUTC;
    /* Singleline */
    } else if (state == STRIP_STATE_PUTC &amp;&amp;
            _ch == '/' &amp;&amp; ch == '/') {
        state = STRIP_STATE_SINGLE;
    } else if (state == STRIP_STATE_SINGLE &amp;&amp;
            ch == '\n') {
        state = STRIP_STATE_PUTC;
    }

    /* Put character */
    if ((state == STRIP_STATE_PUTC &amp;&amp; ch != '/') ||
        state == STRIP_STATE_STRING)
        fputc(ch, stream);

    _ch = ch;
}

int main(void)
{
    int ch;
    while ((ch = fgetc(stdin)) != EOF)
        strip(ch, stdout);

    return 0;
}
</code></pre>

<p>What works:</p>

<ul>
<li>Single line comments <code>""xxx // comment""</code> </li>
<li>Normal multiline comments <code>""xxx /* comment\n another comment */ yyy""</code></li>
<li>Nested comments <code>""xxx /* comment /* nested comment */ end of comment */ yyy</code></li>
</ul>

<p>Currently not implemented and tested:</p>

<ul>
<li>Multiline comment behind single-line comment</li>
<li>Line continuation</li>
<li>Escaped characters</li>
</ul>

<p>Kind regards,
Jerry</p>
",0
22876573,22828609,0,"<p>I ended up starting a new thread with more relevant information and somebody found the answer. New thread is here:</p>

<p><a href=""https://stackoverflow.com/questions/22876433/gcc-segmentation-fault-and-debugging-program-that-only-crashes-when-optimized/22876481#22876481"">GCC: Segmentation fault and debugging program that only crashes when optimized</a></p>
",0
27141813,27063678,2,"<p>Michael, I don't know which version of Visual Studio 2013 you tried this on, but it is most certainly outdated. <strong>Visual Studio 2013 Update 4</strong> correctly produces the following error message on the first use of <code>totaldiff</code>:</p>

<pre><code>error C4700: uninitialized local variable 'totaldiff' used
</code></pre>

<p>You should consider updating your work environment.</p>

<p>By the way, here is what I see directly in the editor:</p>

<p><img src=""https://i.stack.imgur.com/oXSwx.png"" alt=""Visual Studio 2013 caught the error""></p>
",0
21308559,21307428,2,"<p>If you know that the result buffer will be bin enough (which you usually can ensure by allocating the maximum space necessary for any of the formats and validating your inputs before formatting them), you can do something like the following:</p>

<pre><code>char* buffer = malloc(BIG_ENOUGH);
char* t = buffer;
t+=sprintf(t, ""%d"", sid-&gt;Revision);
t+=sprintf(t, ""%d"", sid-&gt;IdentifierAuthority.Value[5]);
for (i = 0; i &lt; sid -&gt; SubAuthorityCount; i++) {
    t += sprintf(t, ""-%lu"", sid -&gt; SubAuthority[i]);
}
printf(""Result: %s\n"", buffer);
</code></pre>
",2
21308829,21307428,1,"<p>Looks all to complicated to me. I'd replace most of it with a single <code>snprintf()</code></p>

<p>So this...</p>

<pre><code>snprintf(revision, 2, ""%d"", sid -&gt; Revision);
snprintf(identifierAuthority, 2, ""%d"", sid -&gt; IdentifierAuthority.Value[5]);

/* Push prefix in to result buffer */
strcpy (result,sidStringPrefix);
/* Add revision so now should be S-{revision} */
strcat(result, revision);
/* Append another - symbol */
strcat(result, ""-"");
/* Add the identifier authority */
strcat(result, identifierAuthority);
</code></pre>

<p>...would become</p>

<pre><code>snprintf(""S-%d-%d"", size, sid-&gt;Revision, sid-&gt;IdentifierAuthority.Value[5]);
</code></pre>

<p>Also, in your loop, you're not using <code>size</code> correctly.</p>

<pre><code>      concatLength += snprintf(result + concatLength, size, ""-%lu"", sid -&gt; SubAuthority[i]);
</code></pre>

<p>You should use <code>size-concatLength</code> so that the size reflects how much has already been written. </p>

<p>Oh, and this:-</p>

<pre><code>     concatLength = snprintf(result, size, ""%s-%lu"", result, sid -&gt; SubAuthority[i]);
</code></pre>

<p>.. is probably unsafe, as your destination is one of your source parameters. Generally, for the loop I;d use a solution like @MagnusReftel's.</p>
",3
28525633,28525610,10,"<p>But you never passed the <code>100</code> to the <code>strcpy_s</code> method. You passed 5 (length of hello). And indeed, as copying ""hello"" would take 6 bytes (5 plus a nul byte), the buffer is assumed to be too small.</p>

<p>You <em>must</em> pass the size of your buffer as parameter. Passing the size of your string to copy invalidates the whole use of the function. If you pass the size of the string to copy you could as well use <code>strcpy</code> because it would do the same.</p>
",1
28526398,28525610,6,"<pre><code>strcpy_s(mem, strlen(""hello""), ""hello""); // &lt;----- Assertion Fail
</code></pre>

<p>should be changed to </p>

<p><code> strcpy_s(mem, 100, ""hello"");</code></p>

<p>argument 2 in strcpy_s() is the size of the destination buffer not the size of the source.</p>
",0
23834128,23812559,0,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

char *combine (const char *nodehashkey, const char *ngbrhashkey){
    int i, dup, len, pos_count = 0;
    const char *p1, *p2, *pos[64];
    char *combo_hashkey, *p3;

    if(!nodehashkey || !ngbrhashkey)
        return NULL;

    //store key position
    pos[0] = p1 = nodehashkey;
    while(*p1){
        sscanf(p1, ""#%*d#%*[.0123456789]%n"", &amp;len);
        pos[++pos_count] = (p1 += len);
    }
    len = p1 - nodehashkey;
    p2 = ngbrhashkey;
    p3 = combo_hashkey = malloc(len + strlen(p2) + 1);
    memcpy(p3, nodehashkey, len);
    p3 += len;
    while(*p2){
        sscanf(p2, ""#%*d#%*[.0123456789]%n"", &amp;len);
        for(dup=i=0;i&lt;pos_count;++i){
            if(pos[i+1]-pos[i] == len &amp;&amp; strncmp(pos[i], p2, len)==0){
                dup = 1;
                break;
            }
        }
        if(!dup){
            memcpy(p3, p2, len);
            p3 += len;
        }
        p2 += len;
    }
    *p3 = '\0';
    return combo_hashkey;
}

int main(){
    char *str1, *str2, *str3;
    str1 = combine(""#1#.1.2.3#1#.6.7.8"", ""#1#.6.7.8#1#.5.6"");
    printf(""%s\n"", str1);//#1#.1.2.3#1#.6.7.8#1#.5.6
    free(str1);

    str2 = combine(""#1#.1.6"", ""#1#.2.4"");
    str3 = combine(""#1#.1.6"", ""#1#.3.5"");
    printf(""str2:%s\n"", str2);
    printf(""str3:%s\n"", str3);

    char *weird = combine(str2, str3);

    printf(""weird: %s\n"", weird);//weird: #1#.1.6#1#.2.4#1#.3.5
    free(str2);free(str3);free(weird);
    return 0;
}
</code></pre>
",0
29442819,29442792,0,"<p>You're using the assignment operator in</p>

<pre><code>if( str = ""success.txt"" )
</code></pre>

<p>And not the equality conditional ( <code>""==""</code> )</p>

<p>EDIT: As in the comments, for strings, the equality conditional doesn't work and you ought to use <code>strcmp()</code>.</p>

<p>The assignment operator evaluates to true since it was able to successfully assign the value.</p>

<p>EDIT: The assignment operator evaluates to true because it assigned a non-zero value, not because it successfully assigned it.</p>
",4
29442836,29442792,3,"<p>In your code you are getting the character from the user. But you are checking that with <code>string</code>. </p>

<p>Use <code>fgets</code> get the input from the user.</p>

<pre><code> char *fgets(char *s, int size, FILE *stream);

 int len=stlen(array)-1;
 if ( len &gt; 0 &amp;&amp; array[len] == '\n' )
          array[len] ='\0';
</code></pre>

<p>While you need to compare that file , then use <code>strcmp</code> function.</p>

<pre><code> if ( strcmp(array,""success.txt\n"") == 0 )
</code></pre>

<hr>
",2
29442926,29442792,1,"<p>You don't need to check the file name entered by the user. You can try opening the file and if it fails (<code>fopen()</code> returning a <code>NULL</code>) then your desired file is either inaccessible (you don't have enough privileges) or the file simply does not exist. Checking the value of <code>errno</code> will tell you what exactly went wrong. Also I don't understand why you ask the user for a file name and then compare it against a hard-coded name. If you want a file with a constant name then hard-coding is a better option. Why ask the user if the name really matters and is not going to change?! Your design is flawed altogether. You don't need to do all this just to see the correctness of the entered file name.</p>
",0
29498916,29498614,1,"<p>There's only two options:</p>

<ol>
<li><p>Store a terminating byte. Often people use the null character for this. Of course, you must make sure that the terminating byte is not found in the valid data part of the array.</p></li>
<li><p>Add a length member to your struct.</p></li>
</ol>
",0
29499193,29498614,2,"<p>Add a size field to the structure.</p>

<pre><code>#define DATA (""\x10\x20\x30\x00\x10"")
struct stest
{
    int x;
    size_t size;
    unsigned char data[];
} x = 
{
    1, sizeof DATA, { DATA } 
};
</code></pre>
",0
29498643,29498614,2,"<p>Since x.data is a null terminated char array you could just use strlen function.</p>

<pre><code>printf( ""sizeof x.data: %u\n"", strlen(x.data)+1 );
</code></pre>

<p>This code will not work correctly if the array contains null. In this case you need to store length of the array in separate member of struct.</p>
",3
29499052,29498614,2,"<p>As others have said, strlen will get you what you want. </p>

<p>The reason you're running into trouble isn't due to the string literal aspect, but rather <a href=""http://en.wikipedia.org/wiki/Sizeof#sizeof_and_incomplete_types"" rel=""nofollow noreferrer"">the lack of a definite size of the array in your struct</a>. It's an incomplete type.  The compiler doesn't know how big the array is, and so sizeof can't figure it out.</p>

<p>Specifically, this is a ""flexible array member"". C99 added these. Structs with array's with an incomplete array as the last element (so it has room to grow).</p>

<p>Sizeof gets the size of the datatype. <br>
Sizeof when applied to arrays, gets the size of the whole array.<br>
Sizeof when applied to structs with a flexible array member, <a href=""https://stackoverflow.com/questions/6732184/does-a-flexible-array-member-increase-sizeof-a-struct"">ignores the array</a>. <br>
Sizeof when applied to incomplete types simply fails. It gives up trying to figure out how big the array is. </p>

<p>So long story short, slap a number in your array. (Or pass along that information)</p>

<pre><code>struct
{
  int x;
  int thesizeofmyarrayisfive = 5;
  unsigned char data[5];
}
</code></pre>
",0
29181370,29181249,1,"<p><code>*(is.previous)</code> is the struct itself. The struct is transferred to <code>printf</code> by value, i.e. copied onto stack. The first field of the struct is <code>name</code> pointer, that is just <code>char*</code> which <code>printf</code> simply takes. As <code>printf</code> is vararg, the caller cleans the stack after the call.</p>

<p>P.S. Although <code>*(is.previous)</code> accidentally worked, but the code must be changed to <code>is.previous-&gt;name</code>.</p>
",0
29181378,29181249,2,"<p>A struct is guaranteed to be laid out in memory with no padding before its first element. This means e.g. that a pointer to the struct, and a pointer to the first element of the struct, are the same thing.</p>

<p><code>printf</code> doesn't have any ability to actually check what you pass to it, but takes on faith that the description in the format string is an accurate representation of the argument list (NB. a good compiler will add the check anyway). So <code>printf</code> assumes that the argument it's receiving is a <code>char *</code> and interprets it accordingly.</p>

<p>Because the argument you actually passed was a struct with a <code>char*</code> in the leading position, the data in that argument slot was identical to the data that <em>would</em> have been in that argument slot, if you had passed just the member instead of the whole struct.</p>

<p>The fact that that data was also followed by the rest of the struct doesn't affect anything in this case because - <em>only</em> because - <code>printf</code> wasn't instructed by the format string to look for any more arguments. More data was indeed passed to it, and had there been more arguments expected by the string, the remaining members of the <code>island</code> would have got in the way and corrupted the argument list.</p>

<p>Doing this is not safe in general and you should really only rely on the struct first-element-layout rule when handling <em>pointers</em>, not structs passed by value.</p>
",0
26419685,26419618,4,"<p>You probably want <code>-L.</code> not <code>-L</code> in your last line, so:</p>

<pre><code>main: main.o libmatrix.so
    $(CC) $(CFLAGS) -o $@ $&lt; -L. -lmatrix
</code></pre>

<p>You should read <a href=""http://tldp.org/HOWTO/Program-Library-HOWTO/"" rel=""nofollow"">Program Library HOWTO</a> and <a href=""http://www.akkadia.org/drepper/dsohowto.pdf"" rel=""nofollow"">Drepper's paper: <em>How to Write Shared Libraries</em></a>; you might want to set some <code>-rpath</code> at link time (maybe using <code>-Wl,-rpath,.</code> ...), and you might want to link with <code>-rdynamic</code> ....</p>

<p>Alternatively, set your <code>LD_LIBRARY_PATH</code> environment variable to contain <code>.</code> (I don't recommend that), or install your shared library in <code>/usr/local/lib/</code> (and add it to <code>/etc/ld.so.conf</code> then run <code>ldconfig</code>). See also <a href=""http://man7.org/linux/man-pages/man3/dlopen.3.html"" rel=""nofollow"">dlopen(3)</a>, <a href=""http://man7.org/linux/man-pages/man7/environ.7.html"" rel=""nofollow"">environ(7)</a>, <a href=""http://man7.org/linux/man-pages/man8/ld.so.8.html"" rel=""nofollow"">ld.so(8)</a>, <a href=""http://man7.org/linux/man-pages/man8/ldconfig.8.html"" rel=""nofollow"">ldconfig(8)</a></p>
",1
23589335,9385250,1,"<blockquote>
  <p>How can i display all my output.</p>
</blockquote>

<p>
Write your output into a file.</p>
",0
29478831,29478715,5,"<p>It¡¯s an identifier character, just like alphanumeric characters and underscores. Allowing <code>$</code> in identifiers is <a href=""https://gcc.gnu.org/onlinedocs/gcc/Dollar-Signs.html"" rel=""noreferrer"">a GNU extension</a> to C and C++. You can enable it explicitly with the <code>-fdollars-in-identifiers</code> flag. Here it seems to be used in a naming convention where <code>$$</code> separates namespace components.</p>
",1
28469364,28468908,2,"<p>After Accept Answer.</p>

<p>Something for OP to consider as another approach:</p>

<p>For fun, a not-so-serious recursive approach to reverse the file.</p>

<pre><code>void reverse(int fileIn, int fileOut) {
  char data;
  if (read(fileIn, &amp;data, 1) == 1) {
    reverse(fileIn, fileOut);
    write(fileOut, &amp;data, 1);
  }
}

int main(void) {
  int fileOut = open(""output.txt"", O_WRONLY | O_APPEND);
  int fileIn = open(""input.txt"", O_RDONLY);
  reverse(fileIn, fileOut);
  close(fileIn);
  close(fileOut);
  return 0;
}
</code></pre>
",2
28469049,28468908,0,"<p>You must understand that what is presented to you as an array in C, in reality is just a pointer, pointing to the beginning of the memory belonging to that array. This snippet should make everything quite clear:</p>

<pre><code>int test[] = { 1, 2, 3 };
int* ptr = test + 2;       // ptr now points to the third element
</code></pre>

<p><strong>EDIT</strong></p>

<p>As for loading data into an array: again, remember that array itself is just a pool of memory (a buffer) - it begins where the pointer mentioned above points to, and has the size equal to <code>numberOfElements</code> * <code>sizeOfSingleElement</code>. Now look at the signature of the <code>read</code> function:</p>

<pre><code>size_t read(int fildes, void* buf, size_t nbytes);
</code></pre>

<p>It reads <code>nbytes</code> into buffer pointed to by <code>buf</code>. Rings a bell?</p>
",3
25516451,25516260,0,"<pre><code>uint16_t t1, t2, t3;
uint8_t t4, t5, t6;

t1 = *(uint16_t*)src;       // Whatever src is pointing to, treat the next
                            // 16 bits as an unsigned number
                            // Safer would be memcpy(&amp;t1, src, sizeof(t1));
t2 = htobe(t1);             // Guessing this changes the value to have big-endian
                            // byte order
t3 = t2 &gt;&gt; (11-offset);     // Shift t2 to the right by (11-offset) bits
t4 = t3 &amp; (uint16_t)0x001F; // t4 contains the lower 5 bits of t3
t5 = BASE32_ALPHABET[t4];   // t5 gets the t4-th byte of the base32 alphabet
t6 = byte++;                // t6 gets the value of byte, byte's value is then
                            // incremented, so t6 + 1 == byte
dest[t6] = t5;              // t5 is assigned to dest[t6]
</code></pre>

<p>Bit shifting to the right a value by n bits is equivalent to dividing the value by 2<sup>n</sup>.</p>
",2
31282689,31282495,1,"<p>Do you mean that you want to build a linked list using binary tree? However, you may add a new item into your list when (k == level), then you call nivel(a->left, k, l, level+1). It won't add any node here, because k != level+1 now, so your list will contain just one node actually...</p>

<p>BTW, you should ensure nivel add one node into your list everytime.</p>
",1
31282703,31282495,0,"<pre><code>} *SList; 
</code></pre>

<p>will create a pointer type called SList. This causes confusion within your code, because you use <code>SList *l</code> which is a pointer to a pointer! Change your struct typedef to just <code>} SList</code>. This way you don't have to dereference a pointer of a pointer to reach the pointer value. </p>
",0
31294326,31282495,1,"<p>Regarding your difficulty with the prototype: it is fairly common to be restricted to a function prototype which doesn't meet the needs of your implementation. In such cases, it is often easier to call your function from the prototyped function then to shoehorn your functionality into the prototype.</p>
",0
26208583,26208563,3,"<p><code>strcat</code> adds characters to the end of an array of characters. You can't modify a constant. So when you pass in a constant, it fails. You have to allocate a new array of chars, copy your working dir in, and then concatenate your additional path. Or use sprintf instead of strcat, but otherwise the same.</p>
",0
26208595,26208563,0,"<p><code>strcat</code> appends to first argument, so what you are doing is neither correct nor secure. Allocate enough space to hold path name.</p>

<pre><code>const int MAX_PATH = 300;
char path_name[MAX_PATH + 1];
</code></pre>

<p>Copy argument into path_name (use <code>snprintf</code> for that) and append file name (use <code>snprintf</code> for that as well).</p>

<pre><code>void test(char *dir)
{   FILE *fp;
    size_t len_dir, len_file;

    len_dir = strlen(dir);
    len_file = strlen(""Th.txt"");

    assert(len_dir + len_file &lt;= MAX_PATH);

    snprintf(path_name, MAX_PATH, ""%s%s"", dir, ""Th.txt"");

    fp = fopen(path_name, ""wt"");
    if(fp)
    {   // process file
        fclose(fp);
    }
}
</code></pre>
",1
26208596,26208563,-2,"<pre><code>test1(""/my/directory/"")
</code></pre>

<p>passes a const char pointer (const char*) to a readonly (non-mutable) string. You're probably getting a SIGSEGV.</p>

<p>you're passing a const char*; not a char*</p>
",3
22437291,22437242,7,"<p>It's an expected result.</p>

<p>The memory <code>malloc()</code> chooses each time it is called depends on many many things. It probably chooses different memory on the same computer at different times! Let alone on different computers.</p>

<p>The important thing is the contents of the memory. And they're (about) the same, as expected, on your test.</p>

<p><strong>However you have a few errors</strong>:</p>

<p>line 15: <code>str1</code> is invalid. It has been made invalid be the previous call to <code>realloc()</code>.</p>

<p>line 16: the contents of <code>str2</code> are not a ""string"". it does not have a proper terminator. It is invalid to print it with <code>printf()</code></p>

<p>line 27: <code>str3</code> is invalid. It has been made invalid be the previous call to <code>realloc()</code>.</p>
",8
31244728,12784642,0,"<p>This answer is for everyone that came to C++ from Java/C# or some other modern Object Oriented language.</p>

<p>For me this issue happened for the following reason:</p>

<p>I created my own custom C++ class.</p>

<p><strong>MyClass.h</strong></p>

<pre><code>class MyClass {

public:
    void work();

};
</code></pre>

<p><strong>MyClass.cpp</strong></p>

<pre><code>#include ""MyClass.h""
#include &lt;iostream&gt;

class MyClass{
    int64 propA, propB;

    public:
        void work();

};

void MyClass::work() {
    // some work that uses propA and propB
}
</code></pre>

<p>My intuition was that <code>propA</code> and <code>propB</code> will simply be private properties, invisible from the code outside this class.</p>

<p>The problem turned out to be that I haven't put <code>propA</code> and <code>propB</code> in <code>MyClass.h</code>.
Compiler doesn't know how much memory it should allocate when <code>MyClass</code> is getting instantiated by callers.</p>

<p>I simply added the properties to the header <code>MyClass.h</code>:</p>

<p><strong>MyClass.h (fixed)</strong></p>

<pre><code>class MyClass {
    int64 propA, propB;

public:
    void work();

};
</code></pre>
",0
21726829,21726674,2,"<pre><code>size_t myvar;

myvar = htonl(myvar); // For the endian issues

memcpy(buffer, &amp;myvar, sizeof(size_t));
</code></pre>
",0
21726928,21726674,2,"<pre><code>char c8[8] = {0};
size_t s = 0x1233456789abcdef0, s_be = 0;

if (4 == sizeof(s))
{
  s_be = htonl(s);
}
else if (8 == sizeof(s))
{
  s_be = htobe64(s);
}
else
{
  assert(0);
}

memcpy(c8, &amp;s_be, sizeof(s_be));
</code></pre>

<p>For <code>htobe64()</code> have a look here: <a href=""https://stackoverflow.com/a/4410728/694576"">https://stackoverflow.com/a/4410728/694576</a></p>
",1
23586251,23586199,4,"<p>This is probably happening because you are calling <code>GetPosition</code> and you have declared <code>getPosition</code> (check case).</p>

<p>Because it hasn't seen a prototype the compiler plays pretend that there is a function <code>GetPosition</code> that returns an <code>int</code>. Everything else is correct.</p>
",8
22891876,22891853,3,"<p>Preprocessor macros are nothing but a textual substitution. Thus if you write</p>

<pre><code>  const char *pointer = kOID;
</code></pre>

<p>the preprocessor will substitute the text with</p>

<pre><code>  const char *pointer = ""1.3.6.1.4.1.1.1.2.4.0"";
</code></pre>

<p>One thing to bear in mind is that the <code>const</code> specifier is necessary since once the textual substitution is made, the memory will be allocated on read-only segments.</p>

<p>Also be careful to have the macro visible at the point where you'd like to declare that pointer.</p>
",8
22891877,22891853,1,"<p>include the header file first.</p>

<pre><code>#include &lt;header.h&gt;
</code></pre>

<p>Add the defined constant</p>

<pre><code>char * s = kOID;
</code></pre>

<p>This will compile the program fine. However as <code>kOID</code> is a string literal it'll be saved on read only memory of your program. So if you modify the <code>s</code> it'll cause <code>Segmentation fault</code>. The get around is to make <code>s</code> constant.</p>

<pre><code>const char * s = kOID;
</code></pre>

<p>Now if you compile the program compiler will check any assignment on <code>s</code> and notice accordingly. </p>

<pre><code>a.c: In function ¡®main¡¯:
a.c:10:5: error: assignment of read-only location ¡®*s¡¯
</code></pre>

<p>So you'll be safe.</p>
",4
22891999,22891853,2,"<p><strong>Assuming that you're not planning to change the contents of this string, you can simply use:</strong></p>

<pre><code>char* p = kOID;
</code></pre>

<p>The string will reside in a read-only section of the program, so any attempt to change its contents will result with a memory access violation during runtime. So for your own safety, you should generally use:</p>

<pre><code>const char* p = kOID;
</code></pre>

<p>Thus, any attempt to change the contents of the string pointed by <code>p</code> will lead to a compile-time error instead of a runtime error. The former is typically much easier to track-down and fix than the latter.</p>

<p><strong>To summarize the <code>const</code> issue, here are the options that you can use:</strong></p>

<pre><code>      char*       p = kOID;
      char* const p = kOID; // compilation error if you change the pointer
const char*       p = kOID; // compilation error if you change the pointed data
const char* const p = kOID; // compilation error if you change either one of them
</code></pre>

<p><strong>UPDATE - Memory Usage Considerations:</strong></p>

<p>Please note that every such declaration may result with an additional memory usage, adding up to the length of the string plus one character, plus 4 or 8 bytes for the pointer (depending on your system). Now, the pointer is perhaps less of an issue, but the string itself might yield an extensive memory usage if you instantiate it in several places in the code. So if you're planning to use the string in various places within your program, then you should probably declare it globally in one place.</p>

<p>In addition, please note that the string may reside either in the code-section of the program or in the data-section of the program. Depending on your memory partitions, you may prefer having it in one place over the other.</p>
",8
22892134,22891853,0,"<p>To add to what has been said by others, also you can initialize your array this way:</p>

<pre><code>const char some_string[] = kOID;
</code></pre>

<p>This is similar to <code>const char *const some_string = kOID;</code>. Possibly, it may lead to additional memory allocation but this depends on compiler.</p>
",0
23115134,23114919,1,"<p>You'll need to keep a ""sliding window"" of 3 values indicating how many are over 180.</p>

<p>So one approach would be something like this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main(void)
{
    char temp[20];
    float t;

    const int min_over = 2;
    const int max_window = 3;
    const int max_value = 180;
    char over[max_window];      // a 1 means over, 0 otherwise
    int oi = 0;
    int num_values = 0;

    FILE *fpt;

    fpt = fopen(""case i.txt"", ""r"");

    fscanf(fpt, ""%s"", temp);    // read and display the column header
    printf(""%s\n"", temp);

    memset(over, 0, max_window);

    while (fscanf(fpt, ""%f"", &amp;t) == 1)
    {
        int num_hit, i;

        printf(""%.2f\n"", t);

        // Calculate num_hit: how many over in a window of max_window
        //
        over[oi] = (t &gt; max_value) ? 1 : 0;

        if (++oi &gt;= max_window)
            oi = 0;

        for ( num_hit = i = 0; i &lt; max_window; i++ ) num_hit += over[i];

        // Only check for min_over/max_window after at least
        // max_window values read; Reset the check
        //
        if ((++num_values &gt;= max_window) &amp;&amp; (num_hit &gt;= min_over))
        {
            printf(""It happened!\n"");
            memset(over, 0, max_window);
            num_values = 0;
        }
    }

    fclose(fpt);
    system(""pause"");
}
</code></pre>

<p>Since you want a ratio of 2/3, that corresponds to <code>min_over / max_window</code> values.</p>

<p>I ran this on your commented data sample:</p>

<pre><code>Temperature
190.00
190.00
170.00
It happened!
200.00
190.00
100.00
It happened!
100.00
190.00
190.00
It happened!
</code></pre>
",11
23115634,23114919,1,"<p>There are about a million billion different ways to do this, but you just need to keep track of how many samples exceed the threshold and then do whatever you want to do when you hit that mark. </p>

<p>Let's say, once you find your ""2 out of 3"" samples that exceed 180 you want to print the list and stop reading from the file:</p>

<pre><code>FILE *fpt;
float t;
float samples[3] = {0};             // keep a record of 3 samples
int total = 0, i;
fpt = fopen(""file1.txt"", ""r"");

while (fscanf(fpt, ""%f"", &amp;t) == 1)  // read until there are no more samples
{
    total = 0;   // clear our counter
    samples[2] = samples[1];   // toss out the old 3rd sample
    samples[1] = samples[0];   // and shift them to make room for the
    samples[0] = t;            // one we just read

    for(i = 0; i&lt;3; i++)
        if(samples[i] &gt; 180)        // if any are over 180
            total++;                // increment our counter
    if(total == 2) {                // if 2 of the 3 are over 180, we got 2 out of 3
        printf(""2 out of 3 samples are greater than 180!\n"");
        printf(""1: %f\n2: %f\n3:%f\n"", samples[2],samples[1],samples[0]);
        break;
    }
}

fclose(fpt);
</code></pre>

<p>It's not very efficient.. but should be pretty easy to understand.</p>
",0
21317207,21316461,1,"<p>I made some mods to get this to run and it did in fact populate x: </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

bar(){
    double x;
    foo(&amp;x);
    printf(""%f\n"", x);
}

foo(double *p){
    char bytes[8];
    bytes[0]=-62;
    bytes[1]=-120;
    bytes[2]=41;
    bytes[3]=23;
    bytes[4]=-16;
    bytes[5]=-57;
    bytes[6]=47;
    bytes[7]=-40;
    memcpy(p,bytes,sizeof(double));
}

int main(int argc, char* argv[]){
    bar();
}
</code></pre>

<p>Output is: -626117722098128509564427792535309566746344523980579928553066490382037451337019090855228509979567689660741872330473472.000000</p>

<p>If this is not working for you, the problem is likely either in the rest of the code, or the debugger setup.</p>
",1
21317279,21316461,0,"<p>Try  </p>

<pre><code>foo(double *p){
  unsigned char * chr;
  bytes[0]=62;
  bytes[1]=-120;
  bytes[2]=41;
  bytes[3]=23;
  bytes[4]=-16;
  bytes[5]=-57;
  bytes[6]=47;
  bytes[7]=-40;
  memcpy(p,bytes,sizeof(double));
  // (1)

  chr = (unsigned char *)p;

  printf(""%x"", *chr);
}
</code></pre>

<p>You get the correct value 62.</p>
",0
32393823,32393721,1,"<p>You need to take all your input as string first then parse this input to check if it is number or not. In case of failed condition you can feel sure that input was string -</p>

<p>Have a look on below demo code -</p>

<pre><code>fgets(s, sizeof(s), stdin);
valid = TRUE;
for (i = 0; i &lt; strlen(s); ++i)
{
    if (!isdigit(s[i]))
    {
        valid = FALSE;
        break;
    }
}
</code></pre>
",0
32393833,32393721,0,"<p>First of all, when using scanf to scan in %d format, you will get one of the following:</p>

<ol>
<li>scan an int, and then no need to check</li>
<li>infinite loop - because of wrong user input, and then no need to check either.</li>
</ol>

<p>If you want to scan user input you should use some other functions like getchar.</p>

<p>There is a function <code>isdigit()</code> inside <code>&lt;ctype.h&gt;</code>library to help you iterate over a string and determine if a char represents an int or not <a href=""http://www.cplusplus.com/reference/cctype/isdigit/"" rel=""nofollow"">here</a>.</p>

<p>Example:</p>

<pre><code>char* str = ""abc1"";
int counter=0;
while(counter &lt; 4){
  if(isdigit(*(str+counter))){
    printf(""digit"")
  };
  counter++;
}
</code></pre>
",0
32393874,32393721,0,"<p>You can use the combination of <code>getchar()</code> and <code>ungetc()</code> to look at the first character on stdin, determine whether it is a digit using <code>isdigit()</code> and then put it back into the stream and read it with the corresponding <code>scanf</code>. </p>
",0
32393943,32393721,0,"<p>First of all you must ask to the user before read an input to user, then:</p>

<pre><code>printf(""Please enter a digit or a string and then a newline\n"");
is_digit = scanf(""%d"", &amp;input);
</code></pre>

<p>Second, <code>scanf</code> wants a pointer to int, in case of %d format, then</p>

<pre><code>scanf(""%d"", &amp;input);
</code></pre>

<p>Third, <code>printf</code>, to print an int, wants the value, then:</p>

<pre><code>printf(""You entered the digit: %d\n"", input);
</code></pre>

<p>Fourth, you cannot print a string (<code>%s</code>) passing an <code>int</code> variable, then your code is completely wrong.</p>

<p>A simple solution could be, using <a href=""http://www.tutorialspoint.com/c_standard_library/c_function_isdigit.htm"" rel=""nofollow"">isdigit</a> standard function, this</p>

<pre><code>int main()
{
    char buffer[128];
    int i=0;
    printf(""Please enter a digit or a string and then a newline\n"");
    scanf(""%s"", buffer);

    // Checks until the end of string that all chars are digits
    while ((buffer[i] != '\0') &amp;&amp; (isdigit(buffer[i]) != 0))
    {
        i++;
    }

    // If index of buffer doesn't point to the end of string, means that a non digit char was found
    if (buffer[i] != 0)
    {
         printf(""You entered a string\n"");
    }
    else
    {
         printf(""You entered digits\n"");
    }

    return 0;
}
</code></pre>
",0
32393949,32393721,0,"<p>The input you receive from scanf are in ascii-format, see <a href=""http://www.asciitable.com/"" rel=""nofollow"">Ascii Table</a>.</p>

<blockquote>
  <p>All digits (0-9) are between the ascii values: 48-57 (decimal).</p>
</blockquote>

<p>What you should begin with is to input only one digit/character and print it out in integer format (%d). Compare it with the ascii table. Just to get a feeling for it.</p>

<p>When you have done that you should continue with your task. Considering you want to be able to interpret characters and digits I'd read in a string instead of a digit. See <a href=""http://www.tutorialspoint.com/c_standard_library/c_function_scanf.htm"" rel=""nofollow"">scanf</a>, on how to read strings. </p>

<p>Declare a char with a predetermined size. And be sure not to overflow it with scanf.</p>

<p>Then the following should be considered:</p>

<ol>
<li>If there is atleast one character that's not a digit, you should consider it a string.</li>
</ol>

<p>Simply, you create a while loop (or for-loop) that will break whenever a null-terminator has been found. This is the end of the string.</p>

<p>In the loop, you have an int that increments each round (starts at 0). This int is the index to read one character at a time. Keep reading the characters, whenever there is a ascii-value being not a digit (see the ascii-values above) you set a flag to indicate it's a string. This will you get u on the track. </p>
",0
24630200,24629049,0,"<p>GNU C compiler has a <a href=""https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html#index-g_t_005f_005fbuiltin_005fexpect-3668"" rel=""nofollow"" title=""__builtin_expect""><code>__builtin_expect</code></a> to tell the optimizer the most probable outcome of a value.</p>

<p>It is not standard C though.</p>

<p>You can <code>#define</code> macros to wrap around it and conditionally switch which definition to use, based on the compiler.</p>

<p>Linux kernel uses it this way (include/linux/compiler.h):</p>

<pre><code>#define likely(x)      __builtin_expect(!!(x), 1)
#define unlikely(x)    __builtin_expect(!!(x), 0)
</code></pre>

<p>The <code>ifs</code> then become:</p>

<pre><code>if (likely(an_expression)) { ... } 

if (unlikely(another_expression)) { ... }
</code></pre>
",2
26207445,15652090,0,"<p>You can easily use the map file to find the allocations for static varibles.</p>

<p>If you want to sort this information based on the file containing the declaration one would have to write a program that does that, which should be possible. Same goes for code allocation.</p>
",0
23087323,23087070,1,"<p>You need to skip newlines. If you know only scanf, then you can do it as follows::</p>

<pre><code>char dummy;
scanf(""%d %d"", &amp;nl,&amp;nc);
scanf(""%c"", &amp;dummy);  \\ newline is consumed here.
</code></pre>

<p>and the same for the newline after each line, so for reading the matrix:</p>

<pre><code>for (i=0;i&lt;nl;i++) {
    for (j=0;j&lt;nc;j++)
        scanf(""%c"",&amp;matrix[i][j]);   //Input matrix
    scanf(""%c"", &amp;dummy);
}
</code></pre>
",1
23089054,23087070,0,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

int main (){
        int nl, nc, i,j;

        scanf (""%d %d\n"", &amp;nl,&amp;nc); //Input number of lines and collums of the matrix

        char* matrix = (char*) malloc(sizeof(char)*nl*nc);

        for (i=0;i&lt;nl;i++) {
                char c;
                for (j=0;j&lt;nc;j++) {
                        scanf(""%c"",&amp;matrix[i*nc+j]);   //Input matrix
                }
                scanf(""%c"", &amp;c);
        }

        printf(""This is your matrix:\n"");
        for (i = 0; i &lt; nl; i++) {
                for (j = 0; j &lt; nc; j++)
                        printf(""%c"", matrix [i*nc+j]);
                printf(""\n"");
        }

        free(matrix);
        return 0; }
</code></pre>
",1
23089087,23087070,0,"<p>Since you originally tagged this as C++, this should help:  </p>

<pre><code>unsigned int rows;
unsigned int columns;
cin &gt;&gt; rows;
cin &gt;&gt; columns;
std::vector&lt;char&gt; matrix(rows * columns);
for (unsigned int r = 0; r &lt; rows; ++r)
{
  std::string row_text;
  getline(cin, row_text);
  for (unsigned int c = 0; c &lt; columns; ++c)
  {
    matrix.push_back(row_text[c]);
  }
}

for (unsigned int row = 0; row &lt; rows; ++row)
{
  for (unsigned int col = 0; col &lt; columns; ++col)
  {
    cout &lt;&lt; matrix[row * columns + col];
  }
  cout &lt;&lt; ""\n"";
}
</code></pre>
",1
23088498,23087070,0,"<p>Try this:</p>

<pre><code>void main (){
int nl, nc, i,j;

scanf (""%d %d\n"", &amp;nl,&amp;nc); //Input number of lines and collums of the matrix

char matrix [nl] [nc];

for (i=0;i&lt;nl;i++){
    for (j=0;j&lt;nc;j++)
            scanf(""%c"",&amp;matrix[i][j]);   //Input matrix
    scanf(""\n"");
}
printf(""This is your matrix:\n"");
for (i = 0; i &lt; nl; i++)
    for (j = 0; j &lt; nc; j++)
       printf(""%c"", matrix [i][j]);
}
</code></pre>
",2
23089216,23087070,1,"<p>OP: ""What am i doing wrong?""<br>
A: <code>scanf(""%c"", ..</code> is reading <code>'\n'</code> left over from the previous <code>scanf (""%d%d""...</code>  To avoid that and other white-spaces, consume them by pre-pending a <code>' '</code> in the <code>""%c""</code> format.</p>

<p>1) Check <code>scanf()</code> results.</p>

<p>2) Use Space before <code>""%c""</code> to consume whitespace, especially the previous line's <code>\n</code>.</p>

<p>3) Use <code>main()</code> correctly.</p>

<p>4) Better to use fputs() or puts() when simply printing a string</p>

<p>Edit: Meet ability to enter a scant line</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

void ConsumeToEOL(void) {
  int ch;
  do {
    ch = getchar();
  } while (ch != '\n' &amp;&amp; ch != EOF);
}

int main() {
  int nl, nc, i, j;
  // Space between ""%d %d"" not really needed
  if (scanf(""%d%d"", &amp;nl, &amp;nc) != 2) {
    fputs(""Bad number Input\n"", stdout);
    exit(1);
  }
  ConsumeToEOL();

  char matrix[nl][nc];
  for (i = 0; i &lt; nl; i++) {
    for (j = 0; j &lt; nc; j++) {
      int ch = getchar();
      if (ch == '\n' || ch == EOF)
        break;
      matrix[i][j] = (char) ch;
    }
    if (j == nc) ConsumeToEOL();
    for (; j &lt; nc; j++) {
      matrix[i][j] = 0;
    }
  }
  // Better to use fputs() or puts() when simply printing a string
  fputs(""This is your matrix:\n"", stdout);
  for (i = 0; i &lt; nl; i++) {
    for (j = 0; j &lt; nc; j++) {
      if (matrix[i][j]) {
        printf(""%c"", matrix[i][j]);
      }
    }
    // Add EOL
    fputs(""\n"", stdout);
  }
  return 0;
}
</code></pre>
",5
23089299,23087070,0,"<pre><code>#include &lt;stdio.h&gt;


int main (){
        int nl, nc, i,j;

        scanf (""%d %d\n"", &amp;nl,&amp;nc); //Input number of lines and collums of the matrix

        char matrix [nl][nc];

        for (i=0;i&lt;nl;i++) {
                char c;
                for (j=0;j&lt;nc;j++) {
                        scanf(""%c"",&amp;matrix[i][j]);   //Input matrix
                }
                scanf(""%c"", &amp;c);
        }

        printf(""This is your matrix:\n"");
        for (i = 0; i &lt; nl; i++) {
                for (j = 0; j &lt; nc; j++)
                        printf(""%c"", matrix [i][j]);
                printf(""\n"");
        }

        return 0;
}
</code></pre>
",0
23088201,23087070,0,"<p>Try this, maybe will help:</p>

<pre><code>int main()
{
int nl, nc, i,j;

scanf (""%d %d"", &amp;nl,&amp;nc); //Input number of lines and collums of the matrix

char* matrix=(char*)malloc(sizeof(char)*nl*nc);

char* s=(char*)malloc(sizeof(char)*nl);


for (i=0;i&lt;nl;i++)
{
    scanf(""%s"",s);
    for (j=0;j&lt;nc;j++)
        matrix[i*nl+j]=s[j];
}
printf(""This is your matrix:\n"");
for (i = 0; i &lt; nl; i++)
{
    for (j = 0; j &lt; nc; j++)
       printf(""%c"", matrix [i*nl+j]);
    printf(""\n"");
}


  return 0;
}
</code></pre>
",3
25522235,25515006,0,"<p>Yes, it works.
fgets returns NULL if there is an Error or there is no next word typed in.</p>
",0
31879444,31879356,0,"<p>Because both <code>add.h</code> and <code>sub.h</code> contain this:</p>

<pre><code>int num1 = 0, num2 = 0;
</code></pre>

<p>The declarations interfere with each other.  This is a good example of why global variables are bad.</p>

<p>Your functions should instead be designed to take the parameters they require and return a result:</p>

<pre><code>int add(int num1, int num2)
{
    return num1 + num2;
}

int sub(int num1, int num2)
{
    return num1 - num2;
}
</code></pre>
",5
31879921,31879356,0,"<pre><code>#ifndef _NUMDEF_
#define _NUMDEF_
int num1, num2;
#else
extern int num1, num2;
#endif
</code></pre>

<p>Edit both <code>add.h</code> and <code>sub.h</code> if you are uncompromising about your design, though many programmers might frown upon on such an approach. Further assign values to <code>num1</code> and <code>num2</code> in <code>add.c</code> and <code>sub.c</code>.</p>

<p>It is better to create new header file with above code and include it in both <code>add.h</code> and <code>sub.h</code>.</p>
",3
25542295,25542100,0,"<p>The value of arr1 is not ""qwert""<br>
I compiled and ran the program and it gives the following output   </p>

<p>Output console:   </p>

<pre><code>[root@abhishek replies]# ./rep2   
qwertyuiop    
qwertyuiop   
abcdefgqwert   
qwertyuiop    
[root@abhishek replies]#
</code></pre>

<p>the program is working fine.<br>
here strncat is working perfectly fine.     </p>
",3
25542318,25542100,2,"<p>Don't use <code>gets</code> to read the data from the user, If you enter the input more then the array size <code>arr2[10]</code>, The array holds the 10 bytes, So there is no space for <code>\0</code>. It leads to ""Undefined Behavior""</p>

<p>Due to this you are getting-</p>

<pre><code>qwertyuiop
qwert
qwertyuiopqwert // Note the extra characters with arr2, That is more then your input
</code></pre>

<p>Use <code>fgets</code> to read input from user-</p>

<pre><code>fgets(arr2,10,stdin);
</code></pre>

<p>Then the program is working fine. Try this change-</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main()
{
    char arr1[13] = ""abcdefg"";
    char arr2[10];
    // gets(arr2);
    fgets(arr2,10,stdin); // it will read only 9 characters from user, 1 byte for null
    puts(arr2);
    strncat(arr1, arr2, 5);
    puts(arr1);
    puts(arr2);

    return 0;
}
</code></pre>

<p>Output-</p>

<pre><code>root@sathish1:~/My Docs/Programs# ./a.out 
qwertyuiopasdf   &lt;- i have entered more than 10 character. But it reads only first 9 byte
qwertyuio
abcdefgqwert
qwertyuio
</code></pre>
",4
25542365,25542100,2,"<p>The function <code>gets</code> reads in a string from stdin until it reads either a newline, or the end of file. In both cases it appends a NUL byte at the end.</p>

<p>Your input string <code>qwertyuiop</code> is 10 characters, so the total string length is 11 characters. You only allocated 10 characters in your array. So, the behaivour of your program is undefined. It could segfault, or behave weirdly.</p>

<p>In fact, the <code>gets</code> function is inherently dangerous. The <a href=""http://linux.die.net/man/3/gets"" rel=""nofollow"">man page</a> says</p>

<blockquote>
  <p>Never use gets(). Because it is impossible to tell without knowing the
  data in advance how many characters gets() will read, and because
  gets() will continue to store characters past the end of the buffer,
  it is extremely dangerous to use. It has been used to break computer
  security. Use fgets() instead.</p>
</blockquote>
",0
26162669,26162593,1,"<p>From the POSIX 2008 standard:</p>

<blockquote>
  <p>Since pause() suspends thread execution indefinitely unless interrupted by a signal, there is no successful completion return value. A value of ?1 shall be returned and errno set to indicate the error.</p>
</blockquote>
",0
26162674,26162593,6,"<p>The only time <code>pause()</code> stops pausing is when it is interrupted, and that is a return on failure (to continue pausing).  So, correctly, it returns -1 to indicate that it failed to continue pausing.</p>
",0
25514989,25514963,4,"<ol>
<li><code>uint</code> isn't a type.</li>
<li>The first line is missing a semicolon.</li>
<li><code>i &gt;= 0</code> is always true.</li>
<li><code>arr[0U - 1]</code> is undefined behavior because it access outside the bounds of the arr array.</li>
<li>It's not clear that this snippet is running as part of a function. If it is not, then the entire for-loop is a syntax error.</li>
</ol>

<p>Additionally, if this class is taking place before 1999, then:</p>

<ol>
<li>You can't declare variables in a for loop. Instead, the <code>uint i</code> should be declared before the loop.</li>
</ol>

<p>This code should probably be rewritten as simply:</p>

<pre><code>unsigned arr[100] = {0};
</code></pre>
",8
29193000,29192894,1,"<p>You can also do it like this</p>

<pre><code>   double getRadius(double diameter)
{
  double radius = diameter / 2;
  return radius;
}

double getSurface(double diameter){
   double radius = getRadius(diameter);
   return PI * (radius * radius);
}

double getOutline(double diameter){
    double radius = getRadius(diameter);
    return 2 * PI * radius;
}
</code></pre>

<p>And you use these getter functions around your program. It will make your code readable and clean.</p>

<p>Use it like this:</p>

<pre><code>void someFunction(double diameter){
    //need surface for some calculations.
    double surface = getSurface(diameter);
    //need outline to do something
    double outline = getOutline(diameter);

    //now use these as you want in your function.
}
</code></pre>

<p>As per your example:</p>

<pre><code>void info_bottom(double diameter)
{

    printf("" ----------------------------------------\n"");
    printf("" The radius = %f \n\n"" , getRadius(diameter));
    printf("" The surface = %f \n\n"" , getSurface(diameter));
    printf("" The outline = %f \n"" , getOutline(diameter));
    printf("" ----------------------------------------\n"");
}
</code></pre>
",6
29193053,29192894,1,"<p>another popular way is to use macros.</p>

<p>e.g
lets say you want the surface when given a raduis.</p>

<pre><code> #define SURFACE(x) (PI*(x)*(x))
</code></pre>

<p>in the code you can just use it , and it doesnt matter if the radius is given as int / double / float ...
thats way this way is popular.</p>

<p>One caveat: macros are substituted whole wherever they are used in a program: this is potentially a huge amount of code repetition. The advantage of a macro over an actual function, however, is speed. No time is taken up in passing control to a new function, because control never leaves the home function; the macro just makes the function a bit longer.</p>

<p>A second caveat: function calls cannot be used as macro parameters.</p>

<p>(The GNU C Programming Tutorial)</p>
",4
34181528,34181239,3,"<p>Your code has the following problems:</p>

<ul>
<li><p><code>fseek(f, SEEK_SET, 0);</code> serves no purpose, the file opened with <code>fopen</code> is at position 0 by default.</p></li>
<li><p><code>fread(s, 2919, 1, f);</code>: you do not store the number of bytes read. You cannot properly null terminate the buffer for printf to stop at the last decoded byte.  How do you know the file size anyway?</p></li>
<li><p>The encoded string <code>H4sIAIM4aFYCAwtJLS6JyQsBklwAMrDLnwsAAAA=</code> decodes as <code>Test\nTest</code>, with a litteral <code>\</code> character followed by an <code>n</code>, not a linefeed character. Reading these characters from file <code>r</code> with <code>fread</code> will not convert escape sequence <code>\n</code> to the actual linefeed character.  Such conversion is a feature of the compiler when parsing string and character literals.  If you intend to do that with your file contents, you have to hand code the conversion yourself.</p></li>
</ul>

<p>Here is a corrected version:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void) {   
    FILE *f;
    char *s = malloc(2919 + 1);
    char *p;
    int nread;

    strcpy(s, ""printf 'H4sIAIM4aFYCAwtJLS6JyQsBklwAMrDLnwsAAAA=' | base64 -d | gunzip &gt; r""); //Test\nTest after decoding
    system(s);
    f = fopen(""r"", ""r"");
    nread = fread(s, 2919, 1, f);
    if (nread &gt;= 0) {
        s[nread] = '\0';
        while ((p = strstr(s, ""\\n"")) != NULL) {
            /* converting \ n sequences to linefeed characters */
            *p = '\n';
            memmove(p + 1, p + 2, strlen(p + 2) + 1);
        }
        printf(""%s"", s); //puts(s); will not give the same result
    }
    fclose(f);
    system(""rm r"");
    free(s);
    return 0;
}
</code></pre>
",2
34181683,34181239,4,"<p>The text you've encoded looks like this:</p>

<pre><code>Test\nTest
</code></pre>

<p>This is a 10 character string with ""\"" for the fifth character and ""n"" for the sixth.  This is different from this:</p>

<pre><code>char str[]=""Test\nTest"";
</code></pre>

<p>Which is a 9 character string with a newline for the fifth character.</p>

<p>If you want to print a newline, your encoded string needs to contain it.  Either that, or you have to parse the resulting string and perform the newline substitution manually.</p>
",0
34181686,34181239,2,"<p>Well, obviously, you have encoded the bytes <code>'\'</code> and <code>'n'</code> at the respective places in the string.</p>

<p>If you don't want that, you can</p>

<ol>
<li><p>either compress and encode the correct string:</p>

<pre><code>$ echo $'Test\nTest' | gzip | base64
H4sIAEs+aFYAAwtJLS7hCgERAF0muOIKAAAA
$ echo $'Test\nTest' | gzip -n | base64
H4sIAAAAAAAAAwtJLS7hCgERAF0muOIKAAAA
</code></pre></li>
<li><p>or somehow interpret the <code>\n</code> in the string as wanted. But this makes everything more complicated.</p></li>
</ol>
",0
34181779,34181239,2,"<p>@lurker has hit the nail on the head...</p>

<blockquote>
  <p>The encoding evidently has a literal backslash and nothing in your
  pipeline of system commands interprets it. One way to get it to
  interpret the escapes is: ""echo -e $(printf
  'H4sIAIM4aFYCAwtJLS6JyQsBklwAMrDLnwsAAAA=' | base64 -d | gunzip)
  r""</p>
</blockquote>

<p>To be a little more verbose in answering the question - specifically what's happened is you've compressed the literal ASCII (or UTF-8) characters:</p>

<pre><code>T  e  s  t  \  n  T  e  s  t
</code></pre>

<p>Given your question, you were (presumably) meaning to have either compressed a new line character (often interpreted by tools from the string <code>\n</code>) rather than the two literal characters <code>\</code> and <code>n</code>.</p>

<p>You could create a different gzipped input.  That's one option.  I don't know how you generated the current gzipped binary data - if you post that, we can take a look and propose a fix.</p>

<p>Alternatively as @lurker said - you can do something on the <em>output</em> to convert any occurrences of <code>\</code> and <code>n</code> to newline characters - and there's lots of ways to do that.</p>

<p>But it really depends on <strong>what you were trying to do</strong>.  If you thought you had zipped this text:</p>

<pre><code>Test
Test
</code></pre>

<p>...then it's the input that's gone wrong.</p>

<p>If you thought you had zipped this text:</p>

<pre><code>Test\nTest
</code></pre>

<p>...(as in literally a back-slash-and-n), then you presumably are trying to add some output-processing to convert it to a real new line character.</p>

<p>Does that make sense?</p>
",0
34181841,34181239,2,"<p>The C compiler transforms the ""\n"" sequence into a newline character (ASCII code 10) ONLY IF it is encountered in a <em>literal character string</em> (a constant presented in the source code), not in any character string variable.</p>

<p>Examples:</p>

<pre><code>char s1[] = ""TEST\nTEST"";
printf(s1); // ---&gt; TEST newline TEST.

char s2[] = ""TEST\\nTEST""; // s2 = ""TEST\nTEST""
printf(s2); // ---&gt; TEST\nTEST (the characters \ and n are present inside the string)
</code></pre>

<p>As you can see, in the case of <code>s1</code>, the string was first parsed by the C compiler, which then transformed <code>\n</code> into newline. In the second case, the escape character <code>\</code> prevented the interpretation so the string <code>s2</code> was exactly <code>TEST\nTEST</code>, but now this is no longer a literal (given explicitly in the code), but a real character string residing in memory. Hence it will no longer be interpreted.</p>

<p>Therefore, <code>printf(s2)</code> is not like <code>printf(""TEST\nTEST"")</code> because in the former case there is no interpretation, while in the latter case, the C compiler sees a literal and will interpret it, replacing <code>\n</code> by <code>newline</code>.</p>
",0
28245992,28245913,3,"<p>That's what the <code>argv</code> array is for. It will contain all arguments passed to the program.</p>

<p>For example take this simple test program:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
    printf(""argc = %d\n"", argc);

    for (int a = 0; a &lt; argc; ++a)
    {
        printf(""argv[%d] = \""%s\""\n"", a, argv[a]);
    }
}
</code></pre>

<p>If you build that source, and execute the program such as</p>

<pre>
$ ./a.out argument1 argument2 argument3
</pre>

<p>It will output</p>

<pre>
argc = 4
argv[0] = ""./a.out""
argv[1] = ""argument1""
argv[2] = ""argument2""
argv[3] = ""argument3""
</pre>

<p>In other words, the arguments passed to a program does not match the arguments in the source code, instead they are converted to the <code>argv</code> array.</p>
",1
25692531,25692500,3,"<p>A C compiler needs a function to be declared before it can be called.</p>

<pre><code>#include &lt;stdio.h&gt;

void printMessage(void);

int main()
{
    printMessage();

    return 0;
}

void printMessage()
{
    printf(""HELLO WORLD\n"");
}
</code></pre>

<p>This is true except in C89, in which undeclared functions are implicitly declared with an <code>int</code> return type, which is what you encountered here.</p>

<p>The way that your code is compiled by a C89 compiler (the default behavior of gcc):</p>

<pre><code>#include &lt;stdio.h&gt;

int printMessage(void);

int main()
{
    printMessage();

    return 0;
}

void printMessage()
{
    printf(""HELLO WORLD\n"");
}
</code></pre>

<p>When the compiler reaches the line <code>void printMessage()</code>, it throws an error, because the function was already implicitly declared with an <code>int</code> return type.</p>

<p>In your question, when you defined the function before defining main, you also declared the function and its return type.</p>

<p>My suggestion, use the c99 or c11 standard. <code>gcc -o main --std=c11 main.c</code></p>
",6
25692536,25692500,1,"<p>Note that in second case, the compiler has no way to know 'what is the behavior' of printMessage (it's signature: function name, return and parameters). That's why the code doesn't compile.</p>

<p>Try giving the signature first (which is called a function's prototype):</p>

<pre><code>#include &lt;stdio.h&gt;
void printMessage(void); //&lt;-- here is the prototype
int main(void)
{
    printMessage();

return 0;
}
void printMessage(void)
{
  printf(""HELLO WORLD\n"");
}
</code></pre>
",3
26220527,26220440,5,"<p>If you don't have an explicit return statement an int c function is apt to return whatever value was returned by the last function called (although I believe the actual behavior is undefined).  Therefore
you are returning the result of printf when you mean to return the value of the recursive call to sumdig.</p>

<p>Instead of <code>sumdig(n);</code>, try <code>return sumdig(n);</code></p>
",0
26220582,26220440,2,"<p>Right, firstly you should compile this with as many warnings as your compiler will give you.</p>

<p>This'd show you that although <code>sumdig</code> returns a value, there's at least one code path that doesn't return anything so the caller will get rubbish.</p>

<p>Secondly you have a static variable that is never re-initialised so every client call will accumulate extra stuff in s.</p>
",0
22134432,22134276,1,"<p>You can also define <code>total</code> in <code>main</code> and pass it as a parameter to <code>fun1</code>, same as you do for <code>x</code> and <code>y</code>.</p>

<p>This way your function can do the addition and <code>main</code> can still do the printing (since <code>total</code> would be accessible from <code>main</code>)</p>
",1
23554862,19086455,0,"<p>I guess that problems are here:</p>

<p>(1)</p>

<pre><code>  ...
  //open a binary file to write.
      fp = fopen(""ticket.bin"", ""wb"");  
                                 |
                                 v
     ///...fopen(""ticket.bin"", ""w"" ); /// 
  ...
</code></pre>

<p>(2)</p>

<pre><code>  ...
    //write data into binary file.
      if (fwrite(list, sizeof(list[0]), STATIONNUM, fp) != STATIONNUM);
                 |
                 v
    ///...fwrite(&amp;list,...  /// 
  ...
</code></pre>

<p>Follow by this example and try to change your code step by step:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define STATIONNUM 10 //Maximun number of station.

#define rate1 160
#define rate2 190
#define rate3 230

struct Ticket
{
  int  code;//code of the list
  char station[20];//destination name.
  int  price;//transportation fee.
};

int main()
{ FILE *fp;
  int i; //use at for loop.
  struct Ticket list[STATIONNUM] =
  {
    {  1, ""NewYork      "", rate1 },
    {  2, ""London       "", rate1 },
    {  3, ""Paris        "", rate1 },
    {  4, ""Tokyo        "", rate1 },
    {  5, ""HongKong     "", rate2 },
    {  6, ""Sydney       "", rate2 },
    {  7, ""Milan        "", rate2 },
    {  8, ""Berlin       "", rate2 },
    {  9, ""Vancouver    "", rate3 },
    { 10, ""Afghanistan  "", rate3 },
  };

  // open a binary file to write; write it; and close ///
  if (!(fp = fopen(""ticket.bin"", ""w""))) { printf(""open file fail""); }
  if (fwrite(&amp;list, sizeof(list[0]), STATIONNUM, fp) != STATIONNUM);
  if ((fclose(fp))==-1) { printf(""File close failed.\n""); }

  // 1-st
  // open binary file to read; read; and close it ///
  if (!(fp = fopen(""ticket.bin"", ""r""))) { printf(""open file fail""); }
  fread(&amp;list, sizeof(struct Ticket), STATIONNUM, fp);
  if ((fclose(fp))==-1) { printf(""File close failed.\n""); }

  // Display initial information
  for (i=0;i&lt;STATIONNUM;i++)
      { printf(""%3d %s %d \n"", list[i].code, list[i].station, list[i].price); }
  getchar();

  // Change some thing :) ///
  list[0].code = 20;  strcpy(list[0].station, ""MOSKOW       ""); list[0].price = 200;
  list[1].code = 30;  strcpy(list[1].station, ""MINSK        ""); list[1].price = 250;
  list[8].code = 60;  strcpy(list[8].station, ""ALMATY       ""); list[8].price = 330;
  list[9].code = 90;  strcpy(list[9].station, ""VLADIVOSTOK  ""); list[9].price = 530;

  // open a binary file to write; write it; close the file ///
  if (!(fp = fopen(""ticket.bin"", ""w""))) { printf(""open file fail""); }
  if (fwrite(&amp;list, sizeof(list[0]), STATIONNUM, fp) != STATIONNUM);
  if ((fclose(fp))==-1) { printf(""File close failed.\n""); }

  // 2-nd
  // open binary file to read; read; and close it ///
  if (!(fp = fopen(""ticket.bin"", ""r""))) { printf(""open file fail""); }
  fread(&amp;list, sizeof(struct Ticket), STATIONNUM, fp);
  if ((fclose(fp))==-1) { printf(""File close failed.\n""); }

  // Display new information again
  for (i=0;i&lt;STATIONNUM;i++)
      { printf(""%3d %s %d \n"", list[i].code, list[i].station, list[i].price); }
  getchar();
  return 0;
}
</code></pre>

<p>Good luck!    </p>
",0
22108442,22108423,3,"<p><code>sizeof(buf) / sizeof(*buf)</code> only works if <code>buf</code> has array type, not a pointer. It will evaluate to a constant 4 or 8 depending whether you're on a 32- or 64-bit target.</p>

<p>You need to pass an argument specifying the available buffer size.</p>

<p>This doesn't exactly point to a crash, since the result is only used for the <code>offset &lt; length</code> test. (Which is, by the way, incorrect; you should use <code>length</code> to limit the space specified to <code>snprintf</code>.) To see what's going wrong, we need a complete, self-contained test case.</p>
",8
22108443,22108423,3,"<p>You can't do <code>sizeof(buf) / sizeof(*buf)</code>, since</p>

<pre><code>sizeof(buf) == sizeof(char*)
sizeof(*buf) == sizeof(char)
</code></pre>

<p>So you are effectively doing: <code>sizeof(char*)/sizeof(char)</code></p>
",0
28193716,28193589,7,"<p>You need <code>#include &lt;stdlib.h&gt;</code>.</p>

<p>The function prototype for <code>atof()</code> is declared in <code>&lt;stdlib.h&gt;</code>. Failure to include this results in the <code>atof()</code> function being assumed to return an <code>int</code>.</p>

<p>You would have known if you turned on compiler warnings. For example, gcc gives the following warning:</p>

<pre><code>warning: implicit declaration of function ¡®atof¡¯ [-Wimplicit-function-declaration]
</code></pre>
",3
28193874,28193589,2,"<p>You should add header file <code>stdlib.h</code> and <code>atof</code> return double type not float so try this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
int main (int argc, char *argv[])
{
    if(argc&gt;1)
    {
        printf(""%s\n"", argv[1] ); // 222

        double floatNumber = atof( argv[1] );

        printf(""%lf\n"", floatNumber ); //0.000000

    }
    return 0;
}
</code></pre>

<p>besides, <code>atof()</code> is for both <a href=""http://linux.die.net/man/3/atof"" rel=""nofollow"">c99 or c89</a>:</p>

<pre><code>zookeepdeMacBook-Pro:Desktop zookeep$ gcc test.c -o test
zookeepdeMacBook-Pro:Desktop zookeep$ ./test 222
222
222.000000
</code></pre>

<p>will works fine.</p>
",1
28193620,28193589,-1,"<p>First of all include <code>stdlib.h</code>, then change this</p>

<pre><code>printf(""%lf\n"", floatNumber );
</code></pre>

<p>to</p>

<pre><code>printf(""%f\n"", floatNumber );
</code></pre>

<p>the correct specifier for <code>float</code> in <code>printf()</code> is <code>""%f""</code>.</p>

<p>By omiting <code>stdlib.h</code> the compiler assumes that <code>atof()</code> returns <code>int</code>, which is the cause of the porblem.</p>

<p>You should also use a function that allows you to be sure that the conversion was performed correctly, instead of assuming that <code>argv[1]</code> is convertible, so for example a version of your program that will check for conversion errors would be</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main (int argc, char *argv[])
{
    if(argc&gt;1)
    {
        char *endptr;

        printf(""%s\n"", argv[1] ); // 222         

        float floatNumber = strtof(argv[1], &amp;endptr);
        if (*endptr != '\0')
            printf(""%s is not convertible to float\n"", argv[1]);
        else
            printf(""%f\n"", floatNumber ); //0.000000            
    }
    return 0;
}
</code></pre>

<p><strong>Finally</strong>: to prevent this kind of problems, use compiler warnings, the compiler should have warned you about implicit function declaration, since <code>atof()</code> is implicitly declared in your program.</p>

<p>When a funciton is implicitly declared the compiler assumes that it's return value is <code>int</code>.</p>
",4
21181713,21181162,0,"<p>Please give a full example. I think you have to use <strong><em>time()</em></strong> to get the approximate current time..After that you can go ahead.</p>
",0
21181363,21181162,7,"<p>In C, there are no constructors, so <code>time_t start;</code> just declares a variable of type <code>time_t</code>. It does not set that equal to the current time. You thus need to read the current time before the loop (and assign that to starttime), and read it within the loop (or within the while condition).</p>

<p>Also, the loop should be</p>

<pre><code>while ((currenttime = [code to assign time]) &lt; endwait)
{
    ...
}
</code></pre>

<p>or neater</p>

<pre><code>while ([code to assign time] &lt; endwait)
{
    ...
}
</code></pre>

<p>IE look at currenttime, not starttime.</p>

<p>In order to read the time, you want to use <code>time(NULL)</code> (if you are using time values in seconds. So your completed program would look something like (untested):</p>

<pre><code>#include &lt;time.h&gt;

int main(void)
{
    time_t endwait;
    int seconds = 123;

    endwait = time (NULL) + seconds ;
    while (time (NULL) &lt; endwait)
    {
        /* Do stuff while waiting */
    }
}
</code></pre>

<p>Note also that if the number of seconds is small, you might want to use the higher precision <code>gettimeofday</code>. This will prevent waiting for 1 second waiting for anything from 0 seconds to 1.</p>
",0
21181967,21181162,5,"<p>How about try my test code:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include &lt;unistd.h&gt;

int main(void)
{
    time_t endwait;
    time_t start = time(NULL);
    time_t seconds = 10; // end loop after this time has elapsed

    endwait = start + seconds;

    printf(""start time is : %s"", ctime(&amp;start));

    while (start &lt; endwait)
    {
        /* Do stuff while waiting */
        sleep(1);   // sleep 1s.
        start = time(NULL);
        printf(""loop time is : %s"", ctime(&amp;start));
    }

    printf(""end time is %s"", ctime(&amp;endwait));

    return 0;
}
</code></pre>

<p>A example outprint is :</p>

<pre><code>wugq@SSDEV016:~/tools/test $ ./a.out
start time is : Fri Jan 17 17:12:57 2014
loop time is : Fri Jan 17 17:12:58 2014
loop time is : Fri Jan 17 17:12:59 2014
loop time is : Fri Jan 17 17:13:00 2014
loop time is : Fri Jan 17 17:13:01 2014
loop time is : Fri Jan 17 17:13:02 2014
loop time is : Fri Jan 17 17:13:03 2014
loop time is : Fri Jan 17 17:13:04 2014
loop time is : Fri Jan 17 17:13:05 2014
loop time is : Fri Jan 17 17:13:06 2014
loop time is : Fri Jan 17 17:13:07 2014
end time is Fri Jan 17 17:13:07 2014
</code></pre>
",0
30313962,30293105,0,"<p>Another way of achieving reversing string is this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

char *reverse(const char *);

int main(void){
    char *s = ""hello world"";
    char *s_rev = reverse(s);
    printf(""%s =&gt; %s"", s, s_rev);
    free(s_rev);
    return 0;
}
char *reverse(const char *s){
    char *s_new = strdup(s);
    char *s_begptr = &amp;s[0];
    char *s_endptr = &amp;s[strlen(s) - 1];
    char *ptr = NULL;
    for (ptr = s_endptr; ptr &gt;= s_begptr; ptr--, s_new++){
        *s_new = *ptr;
    }
    *s_new = '\0';
    s_new -= strlen(s);
    return s_new;
}
</code></pre>

<p>Notice we are not using any temporary variables to store the value, rather, using both start and end pointers of the same string and using the loop to work backwards from the end of string in reverse.</p>
",0
28147962,28147620,0,"<p>That used to be a problem with C and macros were used to solve such problems. But in C++ if you use ""const"" keyword then the compiler should automatically replace those values during compile time so there shouldn't be any problem with g++. That code runs perfectly fine when compiled with g++. Maybe you are trying to compile it with gcc (I got the same error with gcc which is as expected).</p>
",0
28148008,28147620,0,"<p>Actually, having a <code>const</code>-variable doesn't mean it is constant at compile time. For example, I can</p>

<pre><code>void f(int x) {
    const int y = x;
    int m[y]; // should that work?
}
</code></pre>

<p>It won't work in good old C++03, as compiler cannot determine <code>y</code> at compile time. Though it would be possible in C++ soon with the feature called <a href=""http://en.wikipedia.org/wiki/Variable-length_array"" rel=""nofollow"">Variable Length Arrays</a>, it seems all you want is plain compile-time constant. Just say it's also <code>static</code>:</p>

<pre><code>static const int size_t row_size = 3;
</code></pre>

<p>Since now, you can use it in compile-time.</p>
",4
26429871,26429801,6,"<p>Your function is attempting to pass by <strong><em>value</em></strong>.<br>
However, in C, passing a non-array variable by <strong><em>address</em></strong> is the <em>only</em> way to allow a function to change it. </p>

<p>Your use of function arguments can be corrected like this...<br>
Change function to:  </p>

<pre><code>void init(int *num1, int *num2, int *num3){

 printf(""Enter value for num1: "");
 scanf(""%d"",num1);//because argument is already a 
                  //pointer, you do not need to de-reference (&amp;)
 printf(""Enter values for num2: "");
 scanf(""%d"",num2);
 printf(""Enter values for num3: "");
 scanf(""%d"",num3);
 }
</code></pre>

<p>And, Change call:  </p>

<pre><code> init(a, b, c); 
</code></pre>

<p>to:  </p>

<pre><code> init(&amp;a, &amp;b, &amp;c); 
</code></pre>
",2
26429936,26429801,0,"<p>Change your function declaration and definition to</p>

<pre><code>void init(int *num1, int *num2, int *num3)
</code></pre>

<p>And call the function using</p>

<pre><code>init(&amp;a, &amp;b, &amp;c);
</code></pre>

<p>Also remove the <code>&amp;</code> in all the <code>scanf</code> in that function as you are already passing adresses of the variables to the function.</p>
",0
21318336,21318269,5,"<p>The problem is that <code>fgets</code> stores the newline in the destination string. So your <code>strstr</code> needs to find <code>""town\n""</code>. One solution would be to trim <code>search_for</code> after  <code>fgets</code> to get rid of the newline.</p>
",0
30143954,30143902,3,"<p>Sorry, both examples are very wrong and lead to undefined behaviour, that might or might not crash. Let me try to explain why:</p>

<ul>
<li><code>str1</code> is a dangling pointer. That means <code>str1</code> points to <em>somewhere</em> in your memory, writing to <code>str1</code> can have arbitrary consequences. For example a crash or overriding some data in memory (eg. other local variables, variables in other functions, everything is possible)</li>
<li>The line <code>*str1 = ""Hello"";</code> is also wrong (even if <code>str1</code> were a valid pointer) as <code>*str1</code> has type <code>char</code> (<em>not</em> <code>char *</code>) and is the first character of <code>str1</code> which is dangling. However, you assign it a pointer (<code>""Hello""</code>, type <code>char *</code>) which is a type error that your compiler will tell you about</li>
<li><code>str2</code> is a valid pointer but presumably points to read-only memory (hence the crash). Normally, constant strings are stored in read-only data in the binary, you <em>cannot</em> write to them, but that's exactly what you do in <code>strcpy(str1,str2);</code>.</li>
</ul>

<p>A more correct example of what you want to achieve might be (with an array on the stack):</p>

<pre><code>#define STR1_LEN 128
char str1[STR1_LEN] = ""Hello""; /* array with space for 128 characters */
char *str2 = ""World"";
strncpy(str1, str2, STR1_LEN);
str1[STR1_LEN - 1] = 0; /* be sure to terminate str1 */
</code></pre>

<p>Other option (with dynamically managed memory):</p>

<pre><code>#define STR1_LEN 128
char *str1 = malloc(STR1_LEN); /* allocate dynamic memory for str1 */
char *str2 = ""World"";
/* we should check here that str1 is not NULL, which would mean 'out of memory' */
strncpy(str1, str2, STR1_LEN);
str1[STR1_LEN - 1] = 0; /* be sure to terminate str1 */
free(str1); /* free the memory for str1 */
str1 = NULL;
</code></pre>

<p><strong>EDIT:</strong> @chqrlie requested in the comments that the <code>#define</code> should be named <code>STR1_SIZE</code> not <code>STR1_LEN</code>. Presumably to reduce confusion because it's not the length in characters of the ""string"" but the length/size of the buffer allocated. Furthermore, @chqrlie requested not to give examples with the <code>strncpy</code> function. That wasn't really my choice as the OP used <code>strcpy</code> which is very dangerous so I picked the closest function that can be used correctly. But yes, I should probably have added, that the use of <code>strcpy</code>, <code>strncpy</code>, and similar functions is not recommended.</p>
",7
30143959,30143902,3,"<p><strong>Edit</strong>: In the first snippet you wrote <code>*str1 = ""Hello""</code> which is equivalent to assigning to <code>str[0]</code>, which is obviously wrong, because <code>str1</code> is uninitialized and therefore is an invalid pointer. If we assume that you meant <code>str1 = ""Hello""</code>, then you are still wrong:</p>

<p>According to C specs, <em>Attempting to modify a string literal results in undefined behavior: they may be stored in read-only storage (such as .rodata) or combined with other string literals</em> so both snippets that you provided will yield undefined behavior.</p>

<p>I can only guess that in the second snippet the compiler is storing the string in some read-only storage, while in the first one it doesn't, so it works, but it's not guaranteed. </p>
",5
30144089,30143902,2,"<p>There seems to be some confusion here. Both fragments invoke undefined behaviour. Let me explain why:</p>

<ul>
<li><p><code>char *str1;</code> defines a pointer to characters, but it is uninitialized.  It this definition occurs in the body of a function, its value is invalid.  If this definition occurs at the global level, it is initialized to <code>NULL</code>.</p></li>
<li><p><code>*str1 = ""Hello"";</code> is an error: you are assigning a string pointer to the character pointed to by <code>str1</code>.  <code>str1</code> is uninitialized, so it does not point to anything valid, and you channot assign a pointer to a character.  You should have written <code>str1 = ""Hello"";</code>.  Furthermore, the string <code>""Hello""</code> is constant, so the definition of <code>str1</code> really should be <code>const char *str1;</code>.</p></li>
<li><code>char *str2 = ""World"";</code>  Here you define a pointer to a constant string <code>""World""</code>.  This statement is correct, but it would be better to define <code>str2</code> as <code>const char *str2 = ""World"";</code> for the same reason as above.</li>
<li><code>strcpy(str1,str2); //Works as expected</code>  <strong>NO it does not work at all!</strong>  <code>str1</code> does not point to a <code>char</code> array large enough to hold a copy of the string ""World"" including the final <code>'\0'</code>. Given the circumstances, this code invokes undefined behaviour, which may or may not cause a crash.</li>
</ul>

<p>You mention the code <em>works as expected</em>: it only does no in appearance: what really happens is this: <code>str1</code> is uninitialized, if it pointed to an area of memory that cannot be written, writing to it would likely have crashed the program with a segmentation fault; but if it happens to point to an area of memory where you can write, and the next statement <code>*str1 = ""Hello"";</code> will modify the first byte of this area, then <code>strcpy(str1, ""World"");</code> will modify the first 6 bytes at that place. The string pointed to by <code>str1</code> will then be ""World"", as expected, but you have overwritten some area of memory that may be used for other purposes your program may consequently crash later in unexpected ways, a very hard to find bug!  This is definitely <em>undefined behaviour</em>.</p>

<p>The second fragment invokes undefined behaviour for a different reason:</p>

<ul>
<li><code>char *str1 = ""Hello"";</code> No problem, but should be <code>const</code>.</li>
<li><code>char *str2 = ""World"";</code> OK too, but should also be <code>const</code>.</li>
<li><code>strcpy(str1,str2); //SEGMENTATION FAULT</code> <strong>of course it is invalid</strong>: you are trying to overwrite the constant character string <code>""Hello""</code> with the characters from the string <code>""World""</code>.  It would work if the string constant was stored in modifiable memory, and would cause even greater confusion later in the program as the value of the string constant was changed. Luckily, most modern environemnts prevent this by storing string constants in a read only memory. Trying to modify said memory causes a segment violation, ie: you are accessing the data segment of memory in a faulty way.</li>
</ul>

<p>You should use <code>strcpy()</code> only to copy strings to character arrays you define as <code>char buffer[SOME_SIZE];</code> or allocate as <code>char *buffer = malloc(SOME_SIZE);</code> with <code>SOME_SIZE</code> large enough to hold what you are trying to copy plus the final <code>'\0'</code></p>
",2
30144221,30143902,1,"<p>Both code are wrong, even if ""it works"" in your first case. Hopefully this is only an academic question! :)</p>

<p>First let's look at <code>*str1</code> which you are trying to modify.</p>

<pre><code>char *str1;
</code></pre>

<p>This declares a dangling pointer, that is a pointer with the value of some unspecified address in the memory. Here the program is simple there is no important stuff, but you could have modified very critical data here!</p>

<pre><code>char *str = ""Hello"";
</code></pre>

<p>This declares a pointer which <em>will</em> point to a protected section of the memory that even the program itself cannot change during execution, this is what a segmentation fault means.</p>

<p>To use strcpy(), the first parameter should be a char array dynamically allocated with malloc(). If fact, don't use strcpy(), learn to use strncpy() instead because it is safer.</p>
",1
25471302,25471237,3,"<p>Example 1:</p>

<pre><code>int x; // declares and defines global variable

int main()
{
   int x; // declares and defines *new* local variable, which hides (shadows) the global variable **in this scope**
}
</code></pre>

<p>Example 2:</p>

<pre><code>int main()
{
   extern int x; // declares variable that will refer to variable defined *somewhere*
}

int x;
</code></pre>

<p>Example 3:</p>

<pre><code>int x; // declares and defines global variable

int main()
{
   extern int x; // redundant, declares variable that will refer to variable defined *somewhere*, but it is already visible in this scope
}
</code></pre>
",0
25471309,25471237,2,"<p><code>extern</code> doesn't mean outside the current scope, it means an object with external linkage. An automatic variable never has external linkage, so your declaration <code>int x</code> inside main can't possibly refer to that. Hence it's hiding the global <code>int x</code>, that is, the the variable x with <code>auto</code> storage class is hiding the global x. You need to read more about <a href=""http://www.tutorialspoint.com/ansi_c/c_storage_classes.htm"" rel=""nofollow"">storage classes in C</a>
Refer the below program AFTER reading about them :</p>

<pre><code>#include &lt;stdio.h&gt;
int i = 6;
int main()
{
    int i = 4;
    printf(""%d\n"", i); /* prints 4 */
    {
        extern int i; /* this i is now ""current"". */
        printf(""%d\n"", i); /* prints 6 */
        {
            int *x = &amp;i; /* Save the address of the ""old"" i,
                          * before making a new one. */
            int i = 32; /* one more i. Becomes the ""current"" i.*/
            printf(""%d\n"", i); /* prints 32 */
            printf(""%d\n"", *x); /* prints 6 - ""old"" i through a pointer.*/
        }
        /* The ""previous"" i goes out of scope.
         * That extern one is ""current"" again. */
        printf(""%d\n"", i); /* prints 6 again */
    }
    /* That extern i goes out of scope.
     * The only remaining i is now ""current"". */
    printf(""%d\n"", i); /* prints 4 again */
    return 0;
}
</code></pre>
",5
21039712,21039524,2,"<p>char ranges from -128 to 127. so u can pass an int with a value in the given range. if the value of int is out of this range an overflow occurs and undefined behavior is observed.</p>

<p>To know how it exactly works 
print the value of char u get in the function and see the behavior. </p>
",0
21039760,21039524,3,"<blockquote>
  <p>A prvalue of an integer type or of an unscoped enumeration type can be converted to any other integer type.</p>
</blockquote>

<p><a href=""http://en.cppreference.com/w/cpp/language/implicit_cast#Integral_conversions"" rel=""nofollow noreferrer"">http://en.cppreference.com/w/cpp/language/implicit_cast#Integral_conversions</a></p>

<p>Signedness of <code>char</code> is implementation-dependent </p>

<p><a href=""https://stackoverflow.com/questions/2054939/char-is-signed-or-unsigned-by-default"">Is char signed or unsigned by default?</a></p>

<p>And because of the following:</p>

<blockquote>
  <p>If the destination type is signed, the value does not change if the source integer can be represented in the destination type. Otherwise the result is implementation-defined.</p>
</blockquote>

<p>The behavior of the type conversions is wildly implementation-specific.</p>

<p>So the answer is maybe. For small values of n you're probably okay, but all bets are off once you run into truncation and signedness etc.</p>
",0
21039663,21039524,0,"<p>In C, <code>char</code> is nothing than a (bit bizarre) integer type. When calling your function, implicit conversion between the arguments are taking place and everything is in order.</p>

<p>Such an implicit conversion only works well, because prior to the use of the function, a prototype has been provided, so the compiler knows what the arguments have to be.</p>

<p>Using <code>char</code> for <code>x</code> looks straight forward to me, here, since it is an entity to be compared to the contents of <code>a</code>. For <code>n</code> I don't think that it is a good idea. Generally everything that is sizes or indices should use the semantic type <code>size_t</code> that is provided for such cases, be it in <code>main</code> or in <code>event</code>.</p>
",0
24624961,21074682,15,"<pre><code>void main(){
   int a,b,i=0;
   clrscr();
   printf(""Enter the dividend and divisor"");
   scanf(""%d%d"",&amp;a,&amp;b);
   while(a&gt;=b){
      a=a-b;
      i++;
   }

   printf(""qoutient is :%d \n remainder : %d"",i,a);
   getch();
}
</code></pre>
",2
21715325,21074682,1,"<p>Below method is the implementation of binary divide considering both numbers are positive. If subtraction is a concern we can implement that as well using binary operators.</p>

<p>======</p>

<pre><code>-(int)binaryDivide:(int)numerator with:(int)denominator
{

    if (numerator ==0 || denominator ==1) {
        return numerator;
    }

    if (denominator ==0) {

#ifdef DEBUG
        NSAssert(denominator==0, @""denominator should be greater then 0"");
#endif
        return INFINITY;
    }


//    if (numerator &lt;0) {
//        numerator = abs(numerator);
//    }




    int maxBitDenom = [self getMaxBit:denominator];
    int maxBitNumerator = [self getMaxBit:numerator];
    int msbNumber = [self getMSB:maxBitDenom ofNumber:numerator];

    int qoutient = 0;

    int subResult = 0;

    int remainingBits = maxBitNumerator-maxBitDenom;


    if(msbNumber&gt;=denominator){
        qoutient |=1;
        subResult = msbNumber- denominator;
    }
    else{
        subResult = msbNumber;
    }


    while(remainingBits&gt;0){
        int msbBit = (numerator &amp; (1&lt;&lt;(remainingBits-1)))&gt;0?1:0;
        subResult = (subResult &lt;&lt;1) |msbBit;
        if(subResult &gt;= denominator){
            subResult = subResult-denominator;
            qoutient= (qoutient&lt;&lt;1)|1;
        }
        else{
            qoutient = qoutient&lt;&lt;1;
        }
        remainingBits--;

    }
    return qoutient;
}

-(int)getMaxBit:(int)inputNumber
{
    int maxBit =0;
    BOOL isMaxBitSet = NO;
    for(int i=0;i&lt;sizeof(inputNumber)*8;i++){
        if( inputNumber &amp; (1&lt;&lt;i) ){
            maxBit = i;
            isMaxBitSet=YES;
        }
    }
    if (isMaxBitSet) {
        maxBit+=1;
    }
    return maxBit;
}



-(int)getMSB:(int)bits ofNumber:(int)number
{
    int numbeMaxBit = [self getMaxBit:number];
    return number&gt;&gt;(numbeMaxBit -bits);
}
</code></pre>
",0
21019487,21019291,0,"<p>Your function readData doesn't know about your people array. If you rewrite it along these lines:</p>

<pre><code>void readData(person** people) {
    your code
}

void main() {
   person* people[100];
   readData(people);
}
</code></pre>

<p>It should go better.</p>

<p>Please see zavgs answer for more things to improve.</p>
",2
21019491,21019291,2,"<p><code>people</code> variable is undefined in the body of your <code>readData</code> function. 
That is why the complier fails with error.</p>

<ol>
<li><p>You can pass variable to the function <code>person *readData(person *people)</code>. 
Do not forget to change  <code>readData();</code> to <code>readData(people);</code> in the <code>main</code> function.</p></li>
<li><p>Do not mix pointer notation with array notation if you need just 1-dimensional array.
Use <code>person people[1000];</code> instead of <code>person *people[1000];</code></p></li>
</ol>
",8
21318540,21318278,-1,"<p>Try something like this:</p>

<pre><code>char c,line[300];
int emptyLine = 0;      
int operators = 0;
printf(""Input your text and press ctr+Z on a new line when done: \n"");
while(gets(line)) { 
    bool isEmpty = true;  // Assume empty line
    for (int i = 0; 0 != line[i]; i++) {
        if (!isspace(line[i])) {
            isEmpty = false;   // Line not empty
        }
        if (line[i] == '+'|| line[i] == '-' || line[i] == '/' || line[i] == '*' || line[i] == '%') {
            operators++;    
        }
    }
    if (isEmpty) {
        emptyLine += 1;
    }
}
printf(""The number of empty lines is: %d"",emptyLine);
printf(""\nThe number of operators is: %d"",operators);
</code></pre>
",2
21299378,21299343,2,"<p>This assignment transfers the ownership of the buffer:</p>

<pre><code>cmd.myArray[cmd.size++] = buffer;
</code></pre>

<p>In other words, from that assignment on you must not modify the buffer, because by doing so you would alter a previously stored command. In order for this to work properly, you need to either copy the buffer, or allocate a new one on each iteration. If you would like to use a copy, add a call to <code>strdup</code>:</p>

<pre><code>cmd.myArray[cmd.size++] = strdup(buffer);
</code></pre>

<p>If you would prefer to allocate a new buffer, add</p>

<pre><code>cmd.myArray[cmd.size++] = buffer;
buffer = malloc(BUF_SIZE); // buffer needs to be a `char *`
</code></pre>
",0
21299381,21299343,4,"<p>You're setting every element of <code>myArray</code> to the same thing, <code>buffer</code>. You need to make copies of it to get distinct values:</p>

<pre><code>char *temp = malloc(strlen(buffer)+1);
strcpy(temp, buffer);
cmd.myArray[cmd.size++] = temp;
</code></pre>
",0
21299474,21299343,0,"<p>If buffer is also a char*, you might need something like this instead:</p>

<pre><code>cmd.myArray[cmd.size++] = buffer[cmd.size];
</code></pre>
",0
22110226,22110196,5,"<p>Your if contains empty statement</p>

<pre><code>if(current_votes + num_votes_1 &gt;= 270);
</code></pre>

<p>Remove the <code>;</code></p>

<p>Also c is not like python, indentation does not make code part of the if block.</p>

<pre><code>if(current_votes + num_votes_1 &gt;= 270)
    printf(""Your candidate wins if he/she wins %s"", &amp;name_state_1);
    x++;
</code></pre>

<p>will always execute x++. Only the printf part is part of the if block. Use <code>{}</code> to enclose the code.</p>

<p>At the end, you are also printing the address of x which is why it is a big number. Finally, using x to count ways to win and also as your loop condition is not a good idea. The way I see it, you don't even need the loop.</p>

<p>This seems sufficient:</p>

<pre><code>x = 0;
if(current_votes + num_votes_1 &gt;= 270);
{
    printf(""Your candidate wins if he/she wins %s"", &amp;name_state_1);
    x++;
}

if(current_votes + num_votes_2 &gt;= 270);
{
    printf(""Your candidate wins if he/she wins %s"", &amp;name_state_2);
    x++;
}

if(current_votes + num_votes_1 + num_votes_2 &gt;= 270);
{
    printf(""your candidate wins if he/she wins %s"", &amp;name_state_1, &amp;name_state_2);
    x++;
}
</code></pre>
",2
26797893,26797825,6,"<p>You want an array of array of <code>char</code>, but <code>char *a1[10]</code> is an array of pointers to <code>char</code> (tipically placed in read-only segments / string literals), trying to modify a string literal usually leads to a segmentation fault.</p>

<p>Change</p>

<pre><code>char *a1[10] = {""123"",""121""};    /* Array of string literals (read only) */
</code></pre>

<p>to</p>

<pre><code>char a1[][10] = {""123"",""121""};  /* Array of array of char (read - write) */
</code></pre>
",0
26798702,26797825,3,"<p>The problem is <strong>not</strong> really the modification of string litterals. But the line </p>

<pre><code>char *a1[10];
</code></pre>

<p>affects an array of 10 <code>char *</code> and not a pointer to an array of <code>char[10]</code> what I suppose OP was expecting (as noted in Jdamian comments).</p>

<p>To create an array of <code>char[10]</code>, you must write :</p>

<pre><code>char a1[][10] = {""123"",""121""};
</code></pre>

<p>That way, you create an array of 2 <code>char[10]</code> initialized respectively to <code>""123""</code> (in fact, <code>{ '1', '2, '3, '\0', '\0', '\0', '\0', '\0', '\0', '\0'}</code> as it is <strong>really</strong> a <code>char[10]</code>) and ""121"";</p>

<p>That way you can safely <code>strcat</code> <code>""0000""</code> to <code>a1[i]</code> because 3 (initial length) + 4 (added length) + 1 (terminating null) gives 8 &lt;= 10.</p>

<p>But the really safe way would be :</p>

<pre><code>a=strncat(a1[i],""0000"", sizeof(a1[0]) - strlen(a1[i]) - 1);
</code></pre>
",2
22504802,22504271,1,"<p>This piece of code: </p>

<pre><code>p=0;
scanf(""%lld"",&amp;i);
for (j=5;j&lt;=i;j*=5)
{
    p=p+i/j;
}
</code></pre>

<p>counts the number of factor <code>5</code> in all the integers in <code>[1, i]</code> and stores the result in <code>p</code>.</p>

<ul>
<li>Loop 1: <code>j=5</code>, <code>p+=i/5</code> counts numbers that are divisible by <code>5</code> in the range <code>[1, i]</code></li>
<li>Loop 2: <code>j=25</code>, <code>p+=i/25</code> counts numbers that are divisible by <code>25</code> in the range <code>[1, i]</code> (notice that such numbers have been already counted once in loop 1)</li>
<li>Loop 3: <code>j=125</code>, <code>p+=i/125</code> counts numbers that are divisible by <code>125</code> in the range <code>[1, i]</code> (notice that such numbers have been already counted twice in loop 1 and 2)</li>
<li>....</li>
</ul>
",0
22504810,22504271,3,"<p>In short the problem is to find the number of zeroes of a factorial of number between <code>1</code> to <code>1000000000</code>.<br>
Now take a pencil and a paper. Start with <code>1</code>. From <code>1</code> to <code>4</code> there is no <code>0</code>. First <code>0</code> occurs at <code>5!</code>. The next is at <code>10!</code> and then at <code>15!, 20!, .....</code>. This means that number of zeroes increases at the interval of <code>5</code>.   </p>

<p>Coming to the loop  </p>

<pre><code>for (j=5;j&lt;=i;j*=5)
{
      p=p+i/j;
}
</code></pre>

<p>See the <code>i</code> is stand for <code>N</code> here (see the question). Since number of zeroes increases at the interval of <code>5</code>, <code>j</code> is initialized to <code>5</code> and <code>j</code> will be incremented as a multiple of <code>5</code> .    </p>

<p>Now the simple rule is that <strong>the number of trailing zeros in the decimal representation of <code>N!</code> is simply the multiplicity of the prime factor <code>5</code> in <code>N!</code></strong>. </p>

<p>In the statement <code>p=p+i/j;</code>, same rule is followed. The author of the program incremented <code>j</code> by <code>5</code> till <code>N/j &gt;= 5</code> leaving <code>N</code> (i.e <code>i</code>) here as it is.  </p>

<pre><code>N = i = 30
p = 30/5 + 30/(5*5) = 6  // 30/25 is 1 and does not satisfying the condition N/j &gt;= 5
</code></pre>
",7
22504980,22504271,2,"<p>This algorithm makes more sense if you understand the method they are using to find the number of trailing zeros of a factorial which is outlined in <a href=""http://en.wikipedia.org/wiki/Trailing_zero"" rel=""nofollow"">Trailing zero Factorial</a> and in <a href=""http://www.purplemath.com/modules/factzero.htm"" rel=""nofollow"">Factorials and Trailing Zeroes</a>. Basically relies on the insight that you need to account for all the products of <code>5</code> and <code>2</code> in the factorial expansion to discover how many zeros there will be in the end.</p>

<p>The algorithm to finding the number of trailing zeros in <code>x!</code> boils down to to:</p>

<ol>
<li>Finding successive powers of <code>5</code></li>
<li>Dividing <code>x</code> by the result add the truncated result to the total</li>
<li>Stop when the result of division is less than <code>1</code> or in this specific case we know this will happen when the result is greater than <code>x</code> <BR></li>
</ol>

<p>So if go back to the code we can find the following steps:</p>

<pre><code>         step 3
         |    step 1
         V    V
for (j=5;j&lt;=i;j*=5)
{
   p=p+i/j;  // step 2
}
</code></pre>
",0
21600359,21600252,2,"<p>This is not possible to do in a portable way (the way the executable is structured will be different on every system - ELF vs .exe, amb64 vs ARM), but you can bundle something like libgcc or libclang with your output file which should allow codegeneration + compilation.</p>

<p>Look at the code for the clang executable <a href=""http://llvm.org/viewvc/llvm-project/cfe/trunk/tools/driver/cc1_main.cpp?revision=126577&amp;view=markup"" rel=""nofollow"">here</a> which should give you some good ideas.</p>

<p>What you might do (in pseudo code):</p>

<pre><code>string myNewCode(""#include &lt;stdio.h&gt;\nint main(int argc, char *argv[]){ printf(\""Bus error\\n\"");return 1; }"");
var compiler = new Compiler();
var temp_file = new tempFile();
compiler-&gt;compile(myNewCode, temp_file);
move_file(temp_file, argv[0]);
</code></pre>

<p>(secondary edit: having giving this a little more thought, this is completely possible and portable with libclang)</p>
",0
21600313,21600252,1,"<p>Not portably, no.</p>

<p>In many flavors of Windows, you can't modify the executable of a program being run. This is often highly annoying, even when doing something ""more sane"" than what you're proposing.</p>

<p>In Linux I think it would be fine, just open <code>argv[0]</code> and modify it. Of course if your process was loaded off the path you migth have issues locating the proper file, but there should be some <code>/sys</code> entry or something that can lead you (down) to the absolute path.</p>
",7
25458223,21638225,0,"<pre><code>#include&lt;stdio.h&gt;
main()
{
int n;
for(n=1;n&lt;4;n++){
    printf(""*"");
}
for (n=1;n&lt;4;n++){
    printf(""*   *\n"");
}
for (n=1;n&lt;=5;n++){
    printf(""*"");
}
for(n=5;n&lt;4;n--){
    printf(""*\n"");
}
getch();
}
</code></pre>
",0
21717551,21717247,0,"<p>By the C Operator Precedence Table: <a href=""http://www.difranco.net/compsci/C_Operator_Precedence_Table.htm"" rel=""nofollow"">http://www.difranco.net/compsci/C_Operator_Precedence_Table.htm</a></p>

<p><strong>For 1:</strong></p>

<pre><code>A1 /= ++B1 / --C1
</code></pre>

<ul>
<li>C1 will first be decremented by 1 to 4</li>
<li>B1 will then be incremented by 1 to 6</li>
<li>B1 (6) will be divided by C1 (4), result of which will be 1</li>
<li>A1 will be assigned with the result of the division A1 (5) and 1, which is 5</li>
</ul>

<p>Results for each will be 5, 6 and 4 for A1, B1 and C1, respectively.</p>

<p><strong>For 2:</strong></p>

<pre><code>A2 += ++B2 % C2--
</code></pre>

<ul>
<li>C2 will first be marked to get decremented close to the end of the statement, remains 5 for now</li>
<li>B2 will then be incremented by 1 to 6</li>
<li>The remainder from the division B2 (6) by C2 (5) will get calculated, which is 1</li>
<li>A2 will be assigned with the result of the addition of A2 (5) and 1, which is 6</li>
<li>C2 will be decremented by 1 to 4</li>
</ul>

<p>Results for each will be 6, 6 and 4 for A2, B2 and C2, respectively.</p>

<p>Pardon me if I have made any mistakes, you can always check these with your compiler.</p>
",2
21717323,21717247,2,"<p>Variables:</p>

<pre><code>int A1 = 5;
int B1 = 5;
int C1 = 5;

int A2 = 5;
int B2 = 5;
int C2 = 5;
</code></pre>

<p>Your code:</p>

<pre><code>A1 /= ++B1 / --C1;
A2 += ++B2 % C2--;
</code></pre>

<p>Will probably compile into something similar too:</p>

<pre><code>++B1;
--C1;
A1 /= B1 / C1;

++B2;
A2 += B2 % C2;
C2--;
</code></pre>

<p>You can output the ASM using your compiler, with GCC its the -S flag. Here is the ASM output with GCC on my computer (I added the comments):</p>

<pre><code>movl    $5, -20(%rbp) // A1 = 5
movl    $5, -24(%rbp) // B1 = 5
movl    $5, -28(%rbp) // C1 = 5
movl    $5, -32(%rbp) // A2 = 5
movl    $5, -36(%rbp) // B2 = 5
movl    $5, -40(%rbp) // C2 = 5
</code></pre>

<p>Then for the first one calculation, this is performed (comments simplified for easier understanding):</p>

<pre><code>addl    $1, -24(%rbp)      // ++B1
subl    $1, -28(%rbp)      // --C1
movl    -24(%rbp), %eax    // 
cltd
idivl   -28(%rbp)          // divide B1 by C1
movl    %eax, %esi         // 
movl    -20(%rbp), %eax    // 
cltd
idivl   %esi               // divide A1 by the previous
movl    %eax, -20(%rbp)
</code></pre>
",4
23069323,23069236,1,"<p>(A previous answer here was incorrect and has been amended.)</p>
<p>Per the ANSI C specification (similar language exists in C99 and C++ specifications):</p>
<blockquote>
<p>The type of an integer constant is the first of the corresponding list
in which its value can be represented.</p>
<p>Unsuffixed decimal: int, long
int, unsigned long int.</p>
<p>Unsuffixed octal or hexadecimal: int, unsigned
int, long int, unsigned long int.</p>
<p>Suffixed by the letter u or U: unsigned int, unsigned long int.</p>
<p>Suffixed by the letter l or L: long
int, unsigned long int.</p>
<p>Suffixed by both the letters u or U and l or L: unsigned long int.</p>
</blockquote>
<p>Therefore, there will not be any difference between the two expressions, since C guarantees that the constant's type will be long enough to hold the value.</p>
",0
23069464,23069236,3,"<p>The type of an unsuffixed integer constant like <code>131071100</code> is the first of <code>int</code>, <code>long int</code>, and <code>long long int</code> in which its value can be represented. The value of <code>131071100</code> is <em>always</em> mathematically correct; only its type varies (and since <code>long int</code> is at least 32 bits, it's always either an <code>int</code> or a <code>long int</code>).</p>

<p>With the <code>L</code> suffix, it's of type <code>long int</code> or <code>long long int</code>; again, the value is always correct -- and it happens that <code>131071100L</code> is always of type <code>long int</code>.</p>

<p>It's perfectly valid to initialize an object of some arithmetic type with an expression of a different numeric type. The value is implicitly <em>converted</em> to the target type. And in this case, since the target type is <code>long int</code>, there is no risk of overflow.</p>

<p>For your particular case, the <em>only</em> difference between</p>

<pre><code>long int numberOfPoints = 131071100;
</code></pre>

<p>and</p>

<pre><code>long int numberOfPoints = 131071100L;
</code></pre>

<p>is that the latter is slightly more explicit; the meaning is exactly the same.</p>

<p>The <code>L</code> suffix is still needed if the expression is more complicated than a single constant.  For example, if you write:</p>

<pre><code>long int foo = 1024 * 1024 * 1024;
</code></pre>

<p>then each constant <code>1024</code> is of type <code>int</code> -- and so is the entire expression. If <code>int</code> happens to be just 16 bits, then the multiplication will overflow, even though the <em>mathematical</em> result would fit in a <code>long int</code>. (The type of a literal is adjusted depending on its value; the type of a large expression is not.) To avoid that problem, you can write:</p>

<pre><code>long int foo = 1024L * 1024L * 1024L;
</code></pre>
",0
24113733,24113548,1,"<p>Well there are a few things to say. First the easy part: if the max number of integers allowed to read is 100 your variable ""v"" should be <code>v[100]</code>. This is not a char array, so this array don't need to have an extra element (<code>v[100]</code> will be an array of <code>int</code> that goes from <code>v[0]</code> to <code>v[99]</code>; adjust the loop limit too).</p>

<p>Also, you are checking if the number you have is prime in the variable <code>f</code>, but this var is assigned with the variable <code>i</code> and <code>i</code> is not an element of the array. You want to assign <code>f</code> something like <code>v[i]</code> (for i equal to 0 to the count of numbers read minus one). So you will need 2 loops: the one you are using now for checking if the number is prime, and another one that assigns <code>v[i]</code> to <code>f</code>.</p>

<p>Another thing to say is that you are calling <code>scanf</code> two times for reading, you could just read numbers and store it in a temporary variable. If this number is not zero then you store it in the array and keep reading, else you stop the reading.</p>

<p>By last I strongly recommend you set var names that make sense, use single letters only for the index variables; names like <code>temp</code>, <code>array</code>, <code>max</code> and <code>countnumbers</code> should appear in your code. It will be easier for you and everyone else to read your code, and you will reduce the number of mistakes.</p>
",0
24113848,24113548,1,"<p>Here's the solution to your problem. Very easy stuff.</p>

<pre><code>/* C program to find average of all prime numbers from the inputted array(you can predefine it if you like.) */        

#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
void main()
{
    int ar[100], i, n, j, counter;
    float avg = 0, numprime = 0;
    printf(""Enter the size of the array "");
    scanf(""%d"", &amp;n);
    printf(""\n Now enter the elements of the array"");
    for (i = 0; i &lt; n; i++)
    {
        scanf(""%d"", &amp;ar[i]);
    }
    printf("" Array is -"");
    for (i = 0; i &lt; n; i++)
    {
        printf(""\t %d"", ar[i]);
    }
    printf(""\n All the prime numbers in the array are -"");
    for (i = 0; i &lt; n; i++)
    {
        counter = 0;
        for (j = 2; j &lt; ar[i]; j++)
        {
            if (ar[i] % j == 0)
            {
                counter = 1;
                break;
            }
        }
        if (counter == 0)
        {
            printf(""\t %d"", ar[i]);
            numprime += 1;
            avg += at[i];
        }
    }
    avg /= numprime;
    printf(""Average of prime numbers is ¨Gf"", avg);
    getch();
}
</code></pre>

<p>You just need counter variables like above for all average computations. (Cause we need to know number of prime numbers in the array so we can divide the total of them and thus get average.) Don't worry about typecasting it is being done downwards... This solution works. I've written it myself.</p>
",0
24113863,24113548,1,"<p>Here is a cut at doing what you wanted. You don't need near the number of variables you originally had. Also, without knowing what you wanted to do with the prime number, I just output when a prime was encountered. Also as previously mentioned, using a function for checking prime really helps:</p>

<pre><code>#include &lt;stdio.h&gt;
// #include &lt;windows.h&gt;

/* see: http://stackoverflow.com/questions/1538644/c-determine-if-a-number-is-prime */
int IsPrime(unsigned int number) {
    if (number &lt;= 1) return 0; // zero and one are not prime
    unsigned int i;
    for (i=2; i*i&lt;=number; i++) {
        if (number % i == 0) return 0;
    }
    return 1;
}

int main(void)
{
    int i, v[101], sum, pcnt=0, psum=0;
    float ave;

    i=0;

    printf (""\nEnter array values below, use [ctrl + d] to end input\n\n"");
    printf (""Set the value of the element %d =&gt; "", i);
    while((i&lt;101) &amp;&amp; scanf (""%d"", &amp;v[i]) != EOF ){
        sum += v[i];
        if (IsPrime (v[i]))
            psum += v[i], pcnt++;
        i++;
        printf (""Set the value of the element %d =&gt; "", i);
    }

    ave=(float)psum/pcnt;

    printf(""\n\n  Number of elements     : %d\n"",i);
    printf(""  The sum of the elements: %d\n"",sum);
    printf(""  The number of primes   : %d\n"",pcnt);
    printf(""  The average of primes  : %f\n\n"", ave); 

    return 0;
}
</code></pre>

<p>Sample Output:</p>

<pre><code>Enter array values below, use [ctrl + d] to end input

Set the value of the element 0 =&gt; 10
Set the value of the element 1 =&gt; 20
Set the value of the element 2 =&gt; 30
Set the value of the element 3 =&gt; 40
Set the value of the element 4 =&gt; 51
Set the value of the element 5 =&gt; 11
Set the value of the element 6 =&gt; 37
Set the value of the element 7 =&gt;

Number of elements     : 7
The sum of the elements: 199
The number of primes   : 2
The average of primes  : 24.000000
</code></pre>
",3
24113904,24113548,3,"<p>First lets make a readable method to test if a number is prime; <a href=""https://stackoverflow.com/questions/1538644/c-determine-if-a-number-is-prime"">this answer</a> from another SO post gives us a good one:</p>

<pre><code>int IsPrime(int number) {
  int i;
  for (i=2; i*i&lt;=number; i++) {
    if (number % i == 0) return 0;
  }
  return 1;
}
</code></pre>

<p>Second, let's clean your code, and compute a running sum of all the prime numbers encountered so far. Also, we will check the return values of <code>scanf</code> (but we should <a href=""http://c-faq.com/stdio/scanfprobs.html"" rel=""nofollow noreferrer"">avoid scanf</a> !)</p>

<p>And third, we add some indentation.</p>

<pre><code>int main(void)
{

    int n = 0;
    int i = 0;
    int j = 0;
    int k = 0;
    int sum = 0;

    while( i&lt;101 )
    {
       i++;
       printf (""Set the value of the element %d =&gt; "", i);
       if(scanf (""%d"", &amp;k) != 1)
           continue;

       if(is_prime(k))
       {
        sum += k;
        ++n;
       }

       printf (""To stop press 0 =&gt; "");
       if(scanf (""%d"", &amp;j) == 1)
          if(j == 0)
              break;
    }

    float ave = sum / (double) n;
    printf(""The average is =&gt; %f \n"", ave);
    system(""pause"");
}
</code></pre>
",5
22423443,22423369,1,"<p>You put semicolon at the end of line so your loop do nothing</p>

<pre><code>for (j=0; text[i] != table[j] ;j++);
</code></pre>

<p>You got wrong if in <code>text</code> is symbol missing in <code>table</code>, for example space or <code>'\n'</code>-new line sign.</p>
",1
22427719,22427703,5,"<p>You need to include <code>stdlib.h</code> for <code>exit</code>.</p>
",2
29456172,29456006,1,"<p>It is unclear what you want to achieve. Masking the low bits while keeping the sign bit is something you could do with a single mask on architectures where <code>int</code> is represented as sign / magnitude. It is quite unlikely that you would be thinking of this peculiar case. What is your goal then ?</p>

<p>Be aware that masking is not the same as limiting the range. Except in the most trivial cases, limiting the range cannot be achieved with masking (the trivial cases being limiting to <code>0..0</code> and limiting to <code>INT_MIN..INT_MAX</code>)</p>

<p>If you just want to limit the range use this:</p>

<pre><code>int j = i &lt; -31 ? -31 : i &gt; 31 ? 31 : i;
</code></pre>

<p>You can substitute any <code>int</code> values for minimum and maximum. <code>i</code> is evaluated twice in this expression: if you substitute a complex expression, it better to use a temporary variable. In some cases, the compiler can generate code without jumps for these tests, forget trying to do this by hand.</p>
",0
22431483,22431366,0,"<p>You should use <code>%f</code> for printing a float, and also check that each <code>fscanf</code> suceeded or failed.</p>
",0
22431561,22431336,0,"<p>This piece of code has a problem:</p>

<pre><code>for( i = 1; i &lt; count; i++ )
{
    struct TreeNode next = {elements[i], NULL, NULL};
    addToTree( root, &amp;next );
}
</code></pre>

<p>The <code>addToTree</code> function just puts the pointer you give it into the tree. However, this is a pointer to an object that ceases to exist at the end of the current loop iteration.</p>

<p>I suppose you want to dynamically allocate <code>next</code> each iteration, instead of using a local object. </p>

<p>(There may be other issues too, just this one stood out to me on a quick scan of the code).</p>
",0
22445256,22431336,0,"<p>Wow, I feel stupid. In the <strong>addToTree</strong> function, in the else statement:</p>

<pre><code>else
{
    if( (*root)-&gt;right == NULL )
{
    (*root)-&gt;right = next;
}
else
{
    addToTree( &amp;(*root)-&gt;left, next );
}
}
</code></pre>

<p>I called <strong>addToTree( &amp;(*root)->left, next );</strong> which is supposed to add it to the tree in the right spot, but sends it to the left. Thus, it got stuck here. Basically a syntax error.</p>

<p>So it should be:</p>

<pre><code> addToTree( &amp;(*root)-&gt;right, next );
</code></pre>

<p>That makes it functional, but there is still a lot of work before it is efficient in the memory sense.</p>
",0
22434292,22434244,5,"<p>In the first case <code>ar</code> is most probably <strong>a pointer to a pointer</strong> (declared as <code>int **ar;</code>), thus <code>*(a + i)</code> is <strong>a pointer</strong> or an array and <code>*(*(a + i) + j)</code> is the element.</p>

<p>In C and C++ however there is a rule that says that an array can implicitly ""decay"" to a pointer to the first element in many cases and thus it's also possible that <code>ar</code> has been declared in other ways:</p>

<pre><code>int **ar;     // (1) A pointer to a pointer
int *ar[3];   // (2) An array of pointers
int ar[3][3]; // (3) An array of arrays
</code></pre>

<p>When writing <code>ar + i</code> in case <code>ar</code> is an array it decays to a pointer to the first element (case 2 and 3) and the result is the address of a pointer (case 2) or the address of an array (3). Using the dereference operator <code>*</code> then gets the element that is either a pointer or an array.</p>

<p>When you the add <code>j</code> and the element is an array (case 3) this array also decays to a pointer to its first element before computing the addition. Thus to recap, dependin on how <code>ar</code> is defined:</p>

<pre><code>ar                // (1) a pointer to a pointer,
                  // (2) a pointer to array,
                  // (3) an array of array

ar + i            // (1) and (2) address of a pointer
                  // (3) address of array

*(ar + i)         // (1) and (2) a pointer
                  // (3) an array

*(ar + i) + j     // address of an integer in any case

*(*(ar + i) + j)  // an integer in any case
</code></pre>

<p>Don't worry if this seems confusing, because it is. Normally when you use <code>*(x + i)</code> is because <code>x</code> is a pointer however and that's why I guessed that <code>ar</code> has been declared as <code>int **ar;</code>. Note also that in C and C++ <code>*(x + i)</code> is perfectly equivalent to <code>x[i]</code> or even to <code>i[x]</code>.</p>

<p>In the second case the reason is how the declaration are written in C.</p>

<pre><code>char * s = ""foo"";
</code></pre>

<p>should be read as</p>

<pre><code>(char *s) = (""foo"");  // Not legal C, just to show type declaration and
                      // initialization
</code></pre>

<p>in other words the <code>*</code> is part of the type declaration of <code>s</code>, not an operation applied to <code>s</code>.</p>

<p>Note however that</p>

<pre><code>char *s, t;
</code></pre>

<p>declares <code>s</code> as a <code>char *</code> and <code>t</code> as a <code>char</code>.</p>

<p>Type declarations are probably the most powerful but difficult part of C syntax because it's not obvious what is the part being declared. For example</p>

<pre><code>int *(*f)(int *(*g)(int x));
</code></pre>

<p>is a valid declaration for the type of <code>f</code> and the names <code>g</code> and <code>x</code> are instead irrelevant and could be omitted.</p>

<pre><code>int *(*f)(int *(*)(int));  // Same as above
</code></pre>

<p>The type of <code>f</code> in this case is a pointer to a function accepting a pointer to a function accepting an int and returning a pointer to an int, and returning a pointer to an int.</p>

<p>My guess is that the vast majority of C programmers would however need to think a bit before being able to decipher that :-D</p>
",1
22434305,22434244,1,"<p>For Question 1) <code>*(*(ar+i)+j)=ar[i][j];</code>
this is because, ar is base address of the complete 2D array.
And <code>ar[i]</code> (or <code>*(ar+i)</code>) where <code>i</code> goes from 0 to no_of_rows-1 will consist of address of each row in array.
and then <code>ar[i][j]</code> (or <code>*(*(ar+i)+j</code>)  gives you values at specific addresses.</p>

<p>You should also have a look at memory representation of 2D (also 3D) arrays for more clearance.</p>

<p>For Question 2):</p>

<p>when you say <code>ptr=""abc"";</code> address of string <code>""abc""</code> gets stored into <code>ptr</code>.</p>
",0
22434381,22434244,2,"<p>To elaborate a bit:</p>

<ul>
<li><code>a[b]</code> is always a shorthand of <code>*(a+b)</code>.</li>
</ul>

<p>If you combine that with the pointer arithmetics rules (or derive these from there), any of <code>a</code> and <code>b</code> can be a pointer, the other one an integer, denoting the offset.</p>

<p>With this rule, you can transform an expression like <code>*(*(ar + i) + j)</code> to <code>*(ar[i] + j)</code> and then to <code>ar[i][j]</code>.</p>

<p>Alas, you don't tell us what your <code>ar</code> is, but we can tell the following:</p>

<ul>
<li>As <code>ar[i][j]</code> is a valid expression, <code>ar[i]</code> is a pointer or an array which has decayed into a pointer in this expression.</li>
<li>The same counts for <code>ar</code>.</li>
<li><p>In order for this to be true, <code>ar</code> can be any of</p>

<ul>
<li><code>type** ar</code></li>
<li><code>type (*ar)[]</code></li>
<li><code>type ar[][]</code></li>
<li><code>type * ar[]</code></li>
</ul>

<p>where <code>type</code> is the type of each of the components.</p>

<p>These four alternatives all have a different memory layout, but are accessed the same way.</p></li>
</ul>

<p>That's how pointer arithmetics and array decaying works. Best have a look at a good book or tutorial.</p>

<p>The second question should better be a separate question.</p>

<p>It is just because of the assignment and initialization rules of C.</p>

<p>You define a pointer</p>

<ul>
<li>either uninitialized: <code>type * p;</code></li>
<li>or initialized: <code>type * p = &lt;init value&gt;;</code></li>
</ul>

<p>but</p>

<p><code>p = &lt;new value&gt;;</code></p>

<p>is how you assign it.</p>

<p>Keep in mind that a string literal is transformed into the address of that string in its readonly memory section.</p>
",0
22434448,22434244,1,"<p>I think <code>ar</code> is a pointer to pointer.   </p>

<pre><code>int **ar;   
</code></pre>

<p><code>ar</code> refers to the address of the pointer <code>ar</code> points to, i.e a pointer to pointer to <code>int</code>.<br>
<code>*ar</code> refers to the content of the address <code>ar</code> points to, i.e a pointer to <code>int</code>.<br>
<code>*(*ar)</code> refers to the content of the address the pointer points to ( to which <code>ar</code> points) , i.e an <code>int</code>.     </p>

<blockquote>
  <p>why (1) can not be char *ptr; *ptr=""this a string"" when declaration and assignment is separated ?  </p>
</blockquote>

<p>Note that <code>*</code> is not an indirection operator when used in declaration. It performs indirection only when it is used as a unary operator in a statement.</p>
",0
26430483,26429909,0,"<p>I think you will find that in <code>1.44*log(n)</code> that's log <em>base 2</em>... so that's ~<code>2.08*ln(n)</code>, which for 7 is ~4.0475.</p>

<p>I have seen, variously:</p>

<pre><code>  1.4404 * log2(n + 2) - 0.328

  1.44   * log2(n + 1) ? 0.3
</code></pre>

<p>but all in terms of log2().</p>
",0
22487106,22487033,1,"<p>You need to combine the first two loops into one, or else <code>total</code> will always be only the last roll you made.</p>
",1
22487111,22487033,3,"<p>The issue is that you have two loops instead of one to record the roll. Your code rolls and overwrites <code>total</code> <code>num_roll</code> times. Then you loop and try to update how many times each number was rolled. This should be done in one loop:</p>

<pre><code>for (k = 0; k &lt; num_roll; k++)
{
    roll_1 = rand() %6 +1;
    roll_2 = rand() %6 +1;
    total = roll_1 + roll_2;
    count++;

    if (total == 2) d2++;
    else if (total == 3) d3++;
    else if (total == 4) d4++;
    // ...
}
</code></pre>

<p>Also note, this is the type of construct that a <code>switch</code> statement solves:</p>

<pre><code>switch( total )
{
     case 2: d2++; break;
     case 3: d3++; break;
     case 4: d4++; break;
     case 5: d5++; break;
     //...
     default: //Error
}
</code></pre>
",1
22487227,22487033,0,"<p>Total variable is inside a loop, so it value is going to be erased on each turn.
When you make the second loop, only last total value is going to be used.</p>

<p>You have two solutions,</p>

<p>First is build an array and store all total value. Then in second loop you can access all value.
Second, (the simple one) is to use the current value of total.</p>

<pre><code>for (k = 0; k &lt; num_roll; k++)
{
    roll_1 = rand() %6 +1;
    roll_2 = rand() %6 +1;
 -&gt;    total = roll_1 + roll_2;
    count++;

    if (total == 2) d2++;
    else if (total == 3) d3++;
    else if (total == 4) d4++;
    // ...
}
</code></pre>

<p>If you need an extra explanations, you are welcome.</p>
",0
22487505,22487033,0,"<p>I can barely imagine why you would be given a task like this, yet not be allowed to use arrays. It's only going to teach you bad habits -- of which naming variables a1, a2, ... is one.</p>

<p>If you haven't yet been taught to use arrays, then this problem is not a suitable one to give you. If you <em>have</em> been taught to use arrays, then perhaps the challenge is to find an alternative syntax that's equivalent to an array.</p>

<pre><code> int *ptr = malloc(10 * sizeof(int)); /* This isn't an array, but it's as good */
 memset(ptr,0,10);      /* Fill it with zeroes */

 /* Let's roll */
 for(i=0; i&lt;num_roll; i++) {
     int roll = rand() % 6 + rand() %6; /* Our dice have sides from 0 to 5 */
     *(ptr + roll * sizeof(int)) ++; /* increment the appropriate part of our ""array""
 }

 /* Print the results */
 for(int i=0; i&lt;10;i++) {
     /* Add 2 to every roll for display, as if our dice had sides from 1 to 6 */
     printf(""There were %d rolls with value %d\n"", *(ptr+i), i+2);
 }
</code></pre>
",0
22511149,22510877,0,"<p>Your functions looks erroneous:</p>

<ol>
<li><pre><code>int myNumbers(int userPick[]) // 1. userPick is not used anywhere
{

int i;
int numbers;               // 2. initialize this variable to 1 first 
int input[NUMS];
printf (""Please enter your lucky numbers\n"");

for (i=0;i&lt;NUMS;i++)
{
    scanf(""%d"",&amp;input[i]);                
}//end for loop
numbers = *(input+i);     // 3. is this suppose to be inside the loop ?

return (numbers);
}//end function myNumbers
</code></pre></li>
</ol>

<p>And in </p>

<pre><code>void displayNums(int print[])//implement function
{
    int i;
    int output;
    int numbers[NUMS];
    output = myNumbers(numbers);
    printf(""Your numbers are %d \n"",output);
}//end function displayNums
</code></pre>

<p>You don't use <code>print</code> but create a new array <code>numbers</code></p>
",0
22511154,22510877,1,"<p>Each of your functions declares a new array, rather than using the array passed to it as an argument.</p>

<pre><code>void displayNums(int print[])
{
    int i;
    int output;
    int numbers[NUMS];
    output = myNumbers(numbers);
    printf(""Your numbers are %d \n"", output);
}
</code></pre>

<p>Note that nowhere is the <code>print</code> argument used, and you're using <code>int numbers[NUMS]</code> instead. Remove that declaration and use <code>print</code>. (Also please consider naming your argument something other than <code>print</code>; this name is confusing and does not accurately describe what the variable stores.)</p>
",0
22511204,22510877,0,"<p>Most of your code is erroneous. It won't compile. Here's some sample code. Work with it to implement the rest</p>

<pre><code>#include &lt;stdio.h&gt;
#define NUMS 6

void displayNums(int nums[])
{
    int i;
    printf(""Your numbers are:\n"");
    for(i = 0; i &lt; NUMS; i++)
        printf(""%d "", nums[i]);
    printf(""\n"");
}

void myNumbers(int nums[])
{
    printf(""Please Enter your lucky numbers\n"");
    int i;
    for(i = 0; i &lt; NUMS; i++)
        scanf(""%d"", &amp;nums[i]);
}

int main()
{
    int numbers[6];
    myNumbers(numbers);
    displaynums(numbers);

    //do the rest of the stuff here

    return 0;
}
</code></pre>

<p>Going through a C tutorial might be helpful? Check out <a href=""http://c.learncodethehardway.org/book/"" rel=""nofollow"">http://c.learncodethehardway.org/book/</a> for a nice intro to the language.</p>
",0
22511339,22510877,1,"<p>you are not using arrays properly to communicate the numbers, see the function</p>

<pre><code>int myNumbers(int userPick[]) //implememt function 
{
    int i;
    int numbers;
    int input[NUMS];
    printf (""Please enter your lucky numbers\n"");

    for (i=0;i&lt;NUMS;i++)//loop through array to take input
    {
        scanf(""%d"",&amp;input[i]);                
    }//end for loop
    numbers = *(input+i);

    return (numbers);        
}//end function myNumbers
</code></pre>

<p>it reads the number to a local array and returns <code>*(input+i)</code> which will be a random number since your read array is from input+0 to input+i-1. you should pass array or pointer to global array.</p>

<p>Even in case of display() function you are passing one array and using some other array inside display() function.<br>
you should use a common array to communicate values. you can create a array in global scope and use it in all functions or create a array in main() and pass pointer to it to other functions and use the same array in other functions. learn <code>how to pass arrays between functions and use arrays</code></p>
",0
22511560,22511162,0,"<p>Change this line:</p>

<pre><code>no_of_variables_or3 = complement(no_of_variables[20][20]);
</code></pre>

<p>to be:</p>

<pre><code>no_of_variables_or3 = complement(no_of_variables);
</code></pre>

<p>The compiler should have pointed you to this by issuing a warning.</p>
",3
22514561,22514196,0,"<p>Your <a href=""http://en.cppreference.com/w/c/string/byte/strncpy"" rel=""nofollow""><code>strncpy</code></a> function calls don't add the terminator to the strings you copy to. Besides, they are to small to contain the terminator.</p>

<p>That means that when you call functions such as <code>atoi</code> on an unterminated string it will cause <em>undefined behavior</em>, as the function continues beyond the end of the allocated memory.</p>
",1
22515429,22514196,0,"<p>use <code>strtok()</code> on cadena[] to divide the string into tokens as,</p>

<pre><code>token[0]=strtok(cadena,""\n"")  //considering the output you gave each date is in newline
token[1]=strtok(NULL,""\n"")
token[2]=strtok(NULL,""\n"")
token[3]=strtok(NULL,""\n"")
token[4]=strtok(NULL,""\n"")
token[5]=strtok(NULL,""\n"")
</code></pre>

<p>then use <code>sscanf()</code> to get the required data from the token as,</p>

<pre><code>sscanf(token[5],""ESSID:%s"",ESSID);
sscanf(token[3],""Quality=%d/%d"",&amp;q1,&amp;q2 )  //quality=q1/q2
sscanf(token[0],""Channel:%d"",&amp;channel)
</code></pre>

<p>this will give the required values from the string cadena[].</p>
",2
30153862,22517069,-3,"<pre><code>int main(void)
{
    int a, b, c;
    printf(""Enter phone number: [(xxx) xxx-xxxx]: "");   scanf(""(%d)%d-%d"", &amp;a, &amp;b, &amp;c);
    printf(""You entered: %d.%d.%d"", a, b, c);
    return 0;

}
</code></pre>
",0
22517272,22517069,2,"<p>You can get the input into a string. e.g.</p>

<pre><code>#include &lt;stdio.h&gt;
#define NUMBER_LEN 14 //the number of characters in the string (the phone number)

int main()
{
    char phone[NUMBER_LEN];
    printf(""enter phone number[(xxx) xxx-xxxx]: "");
    gets(phone);
    printf(""You entered %s"", phone);
    return 0;
}
</code></pre>

<p>Further, you can play with your string and format it.</p>
",1
22517281,22517069,5,"<p>You meant to use <code>scanf</code> instead of <code>sscanf</code>. Also, you should memory address of the variable to be written into to <code>scanf</code>. You should change the format string of <code>scanf</code> to <code>""""</code>. <code>scanf</code> returns the number of input items assigned successfully. Check this value for <code>3</code> to find if the input was entered in the required format.</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void) {    
    int d1, s2, d3;
    int val; // to check if scanf was successful

    // newline causes the string to be immediately 
    // written to stdout

    printf(""enter phone number[(xxx) xxx-xxxx]:\n""); 
    val = scanf(""(%d)%d-%d"", &amp;d1, &amp;s2, &amp;d3);

    // check if scanf was successful
    if(val == 3)
        printf(""you entered %d.%d.%d"", d1, s2, d3);
    else 
        printf(""input not in the correct format.\n"");

    return 0;
}
</code></pre>
",3
22517299,22517069,-1,"<p>Use scanf instead sscanf("" %c"", &amp;char);</p>
",2
25467255,25467208,1,"<p>You wrapped filename in quotes, so it looks for a file named <code>filename</code> and not whatever is in your filename variable. Try:</p>

<pre><code>fp=fopen(filename,""r"");
fgetc(fp);
</code></pre>
",0
25467257,25467208,0,"<pre><code>#include &lt;stdio.h&gt;

int main(void){
    FILE *fp;
    char filename[20];
    int c;

    clrscr();

    printf(""ENTER FILE NAME: "");
    scanf(""%19s"", filename);//You cannot use spaces in the file name.
    if(fp=fopen(filename,""r"")){
        while(EOF!=(c=fgetc(fp))){
            printf(""%c"", c);
        }
        fclose(fp);
    }
    getch();
    return 0;
}
</code></pre>
",0
25467271,25467208,2,"<p>First off, this statement is wrong:</p>

<pre><code>scanf(""%s"",&amp;filename);
</code></pre>

<p>What you are doing is passing a <code>char **</code> (technically, a <code>char (*)[20]</code>) to <code>scanf</code>, but instead you want just a <code>char *</code>, so you can get rid of the <code>&amp;</code>, like so:</p>

<pre><code>scanf(""%s"", filename);
</code></pre>

<p>Also note, that <code>scanf</code> has no way of knowing how big <code>filename</code> is (in this case, just 20 characaters), so if you type in too large of a file name, your program will crash (or worse). Also, if there are any spaces in the file name, you'll only get the first part of the file name. Instead, you can use <code>fgets</code> like so:</p>

<pre><code>fgets(filename, 20, stdin);
</code></pre>

<p>Just be warned that this will also read a newline into <code>filename</code>, so you need to use <code>strlen</code> to remove it.</p>

<p>Second, the expression <code>fopen(""filename"",""r"")</code> is using the string <code>""filename""</code> as the file name. Just get rid of the quotes to use the variable.</p>

<p>Also, you call <code>feof(fp)</code> in your outer <code>while</code> loop without actually initializing <code>fp</code>. Don't do that. Instead, you should have <code>fp = fopen(...)</code> be in a separate <code>if</code> statement to make sure it opened properly:</p>

<pre><code>if (fp = fopen(...))
{
    // TODO: read file here
}
else
{
    // file could not be opened properly!
}
</code></pre>

<p>Finally, you never assign the return value of <code>fgetc</code> to your local variable <code>c</code> (which, by the way, needs to be an <code>int</code> to distinguish <code>EOF</code> from other characters).</p>
",1
22891899,22891721,0,"<p>Use this function to get Max of all the rows :</p>

<pre><code>int GetMaxOFRow(int arr[][N],int N)
{
    int row_sum = 0;
    int row_max = -1;
    for(int i =0 ;i&lt;N;i++)
    {
        row_sum = 0;
        for (j = 0; j &lt; N; ++j)
        {
            row_sum +=  arr[i][j] ;
        }
        if(row_max &lt; row_sum)
        {
            row_max = row_sum;
        }
    }
    return row_max;
}
</code></pre>
",0
33005882,33005843,1,"<p>A right shift of n-bits would use the "">>"" operator.</p>

<pre><code>5 &gt;&gt; n;
</code></pre>

<p>The example you gave of 5 &lt;&lt; (32-n) is a left shift. The 32-n does not make a left shift into a right shift.</p>
",9
33005911,33005843,3,"<p>In the comments you said the real use case was:</p>

<pre><code>x &gt;&gt; (32 - n)
</code></pre>

<p>You're allow to use bit invert (e.g. <code>~0</code> instead of <code>-1</code>), so just do either:</p>

<pre><code>x &gt;&gt; (32+(n * ~0)) // Straightforward negate of n using substitute for -1
</code></pre>

<p>or</p>

<pre><code>x &gt;&gt; (33 + ~n)  // Direct use of two's complement to get -n, since -n == (~n) + 1
</code></pre>
",3
33005943,33005843,2,"<p>Okay this is a bit gross and not efficient, but I'm assuming this is more of a theoretical experiment rather a something anyone would do. </p>

<p>You can represent -1 by using ~0  (This inverts all the bits of 0 so that that all bits are set. This is -1 on regular processors).
So if you wanted -n you could go n*(~0)</p>

<pre><code>5 &gt;&gt; (32 + ((~0) * n))
</code></pre>
",0
22885474,22885196,0,"<p>I am not sure exactly what your error is, but a few things that immediately jump out to me are in <code>Calcgrade()</code> and in <code>Getgpa()</code>. In both of these functions, you declare the letter grades as <code>char A,B,C,D;</code> yet this only <em>declares</em> them but does not initialize them (i.e., give them a value); as a result <code>A,B,C,D</code> do not contain any values. I think you mean instead something along the lines of <code>char A='A',B='B',C='C',D='D'</code>; this declaration and assignment will give the variables actual values.</p>

<p>Also in the if's of <code>Calcgrade()</code>, assignment is done with <code>=</code> and not <code>==</code>.</p>
",0
24076989,24073245,0,"<p>No, it won't cause buffer overflow. In fact, a '\0' indicates a NULL position, which is considered as the end of an array. When you go from the beginning to the end of an array, the last position containing the '\0' character will never be considered as a position containing valid data. </p>

<p>You could go over all the array by using while(index &lt; size) as a condition, or by using while(array[position] != NULL)</p>
",0
24073255,24073245,5,"<p>The <code>'\0'</code> is just another character.  It is stored right after the last character of the string.</p>

<p>Often, you can ""get away"" with writing off the end of a buffer with no obvious harm, but don't do it.  It's a bug.</p>

<p>I once had to debug a program that contained an error like this.  The program was writing a single byte past the end of one buffer.  In the debug build, there was enough extra stuff on the stack that the single byte extra caused no harm; the crash only occurred in the release build, but the debugger didn't really work since it was the non-debug build.  This is an example of why it is good to test your code both in a ""debug"" build and in a release build (compiled the way you would give it to your users).</p>
",1
24371299,24371220,4,"<p>Assuming we have 4-byte integers, stored in little-endian fashion (lowest byte first), the array is stored (in bytes) as:</p>

<pre><code>01 00 00 00 02 00 00 00 03 00 00 00 04 00 00 00 ...etc.
</code></pre>

<p><code>p</code> points to the second byte, and <code>q</code> points to the integer starting at that same place, so:</p>

<pre><code>   00 00 00 02
</code></pre>

<p>since we're stored low-to-high, that integer is:</p>

<pre><code>0x02000000
</code></pre>

<p>in hex, or <code>33554432</code> in decimal.</p>
",2
23090229,23090089,1,"<p>the program ends because of the character [enter] left in the input buffer.<br>
You give input value for type then for i and press [enter]. this [enter] is a character left in the input buffer which will be read by next </p>

<pre><code>scanf(""%c"",type);
</code></pre>

<p>so the loop exits. Therefore use <code>getchar()</code> after</p>

<pre><code>int ret = scanf(""%d"", &amp;i);
</code></pre>

<p>To clear the input buffer. and the loop will not end unexpectedly.<br>
Make these changes,</p>

<pre><code> printf(""\t Please input one ASCII code \n""); 
             int ret = scanf(""%d"", &amp;i);
             getchar();          //this will read the [enter] character in input buffer
/* My aim here is to get the amount of integers the user inputs,*/ 
/* and use that to categorize, but I think I am failing to do so. */
             if(ret==1){
</code></pre>
",2
23090379,23090089,1,"<p>In general, I find it better to use <code>fgets()</code> (alternatively, if you are using C99, <code>gets_s()</code> -- although I still prefer fgets() for maximum portability to older compiler environments) for all user-based input, then if necessary use <code>sscanf()</code>, <code>strtol()</code>, and the like to convert the string into other data types, as this will read data by line in a way that is buffer-safe and you won't have to worry about things left in the input buffer.  This is especially true for user-based input which is never well-formed (due to typos, etc).  <code>scanf()</code> really only works well when reading from well-formed input files.</p>

<p>See the comp.lang.c FAQ which describes some of the problems that often occur when using <code>scanf()</code> in detail, including the problem you are seeing above, where inputs seem to be getting skipped:</p>

<ul>
<li><a href=""http://c-faq.com/stdio/scanfprobs.html"" rel=""nofollow"">http://c-faq.com/stdio/scanfprobs.html</a></li>
<li><a href=""http://c-faq.com/stdio/scanfhang.html"" rel=""nofollow"">http://c-faq.com/stdio/scanfhang.html</a></li>
<li><a href=""http://c-faq.com/stdio/scanfinterlace.html"" rel=""nofollow"">http://c-faq.com/stdio/scanfinterlace.html</a></li>
<li><a href=""http://c-faq.com/stdio/scanfjam.html"" rel=""nofollow"">http://c-faq.com/stdio/scanfjam.html</a></li>
</ul>

<p>To find out more about any C standard library function, at a linux command prompt (or Google) type: <code>man 3 fgets</code> and so on.</p>

<ul>
<li>fgets: <a href=""http://linux.die.net/man/3/fgets"" rel=""nofollow"">http://linux.die.net/man/3/fgets</a></li>
<li>sscanf: <a href=""http://linux.die.net/man/3/sscanf"" rel=""nofollow"">http://linux.die.net/man/3/sscanf</a></li>
<li>strtol: <a href=""http://linux.die.net/man/3/strtol"" rel=""nofollow"">http://linux.die.net/man/3/strtol</a></li>
</ul>

<p>Example:</p>

<pre><code>char buffer[256], type;
fgets( buffer, sizeof(buffer), stdin );
if( sscanf( buffer, ""%c"", &amp;type ) == 1 ) {
    // Was able to read a char from the buffer, now you can use it.
}
else {
    // Wasn't able to read a char from the buffer.  handle it if required.
}
</code></pre>
",3
29450812,29450034,2,"<pre><code>#include &lt;stdio.h&gt;
#include ""second.h""
</code></pre>

<p>include those headers in second.c file too and then write Makefile and compile it with make. </p>

<p>Makefile:</p>

<pre><code>CFLAGS = -g -O -Wall
OBJ = first.o second.o

# An explicit rule is required to link.
# Compilation is handled automatically.
first: $(OBJ)
    $(CC) $(CFLAGS) -o first $(OBJ)

# Declare that both object files depend on the header file.
first.o second.o: second.h

# Conventionally 'make clean' removes what 'make' creates.
# Not strictly required.    
.PHONY: clean
clean:
    -rm -f first $(OBJ)
</code></pre>

<p>You can't just copy and paste the above; you must also change both indented lines (the ones with shell commands on them) so that the indentation is a single hard <kbd>TAB</kbd> character.  If you don't do this you will get a cryptic error message:</p>

<blockquote>
  <p>Makefile:5: *** missing separator.  Stop.</p>
</blockquote>

<p>first.c:</p>

<pre><code>#include &lt;stdio.h&gt;
#include ""second.h""

int main(void){
  printf(""%d\n"", addone(5));
  return 0;
}
</code></pre>

<p>second.c</p>

<pre><code>#include &lt;stdio.h&gt;
#include ""second.h""

int addone(int a){
  return ++a;
}
</code></pre>

<p>second.h</p>

<pre><code>#include &lt;stdio.h&gt;

int addone(int a);
</code></pre>
",0
28202747,28202691,3,"<p>The following line is incorrect:</p>

<pre><code>void printstring(char[] s){
</code></pre>

<p>Change that to:</p>

<pre><code>void printstring(char s[]){
</code></pre>
",2
28202755,28202691,1,"<p>Your line:</p>

<pre><code>void printstring(char[] s){
</code></pre>

<p>should be:</p>

<pre><code>void printstring(char s[]){
</code></pre>

<p>The square brackets for the array come after the variable name, just as they would if you indexed it with <code>s[i]</code> in the code.</p>
",0
28457630,28457573,4,"<p>If the end state is <code>OUT</code>, as it usually is, then there is no difference. If the end state is <code>IN</code> (i.e., input does not have trailing whitespace, such as newline) this terminates the last line of output with a newline. </p>
",1
23612380,23612255,4,"<p>The <code>scanf()</code> leaves an <kbd>ENTER</kbd> hanging in the input buffer.</p>

<p>The first time through the loop an empty line is processed.</p>

<p>Hint: read the number of instruments with <code>fgets()</code> and <code>strtol()</code>.</p>
",0
25442252,25442188,3,"<p>So the first part you are confused about is the mismatch between declarations and definitions.</p>

<p>For the build process, that's ok as long as no compilation unit sees them both. But the program doesn't work at this place, does it?</p>

<p>The second part, which is about putting declarations into other .c files, is very bad style. It should - if at all - only be used during debugging where I temporarily need a function in another file.</p>

<p>You can fix both by putting the (correct) declaration into a header file which you include from where you need it as well as - in order to detect mismatches - from where you declare it.</p>
",0
25442518,25442188,4,"<p>You have several things to worry about here. </p>

<ol>
<li>The appalling programming style that puts prototypes in source code rather than header files. This is easy(but tedious) to fix.</li>
<li>The mismatch between the declarations and the definitions. Given that you have a different number of parameters in the prototype and the two definitions of the function. It seems likely that these prototypes aren't actually used, because if they were the program would crash (assuming that is that the actual code doesn't do something truly disgusting with its arguments). So you may have the opportunity to do some cleanup.</li>
<li>You have two implementations of put_column_value. Presumably these are in what is intended to be in different libraries that should never be used together. It looks like one of these directories contains a new version of the library with some sort of alarm but I'm just guessing from the name.</li>
</ol>
",1
25442524,25442188,3,"<p>OUCH! My guess is that the prior programmer needed to add a parameter to <code>put_column_value</code> in one place, but was too lazy to do it everywhere. It is also possible that he was halfway through the implementation and meant to fix the other files, but then quit before the job was finished.</p>

<p>You should look at the linker command(s) to see which definition is actually linked with the program(s).</p>

<p>You should also check to see if <code>put_column_value</code> is ever called (at runtime) from the files that have the faulty declaration. Since the extra parameter is placed first, calls using the faulty declaration could still work as long as the implementation doesn't actually use the new parameter in those instances (if it writes to it, it will corrupt the stack). Hence ""Magic hack"". It breaks the C standard and technically results in undefined behaviour. </p>

<p>My advice is that you either fix the call everywhere or that you spit the function into two, and rename one of them. In either case, you should move the declaration(s) back to the header file.</p>
",2
27135163,27135101,2,"<p>In your loops, <code>string2</code> is indexed by <code>i</code>, and <code>string1</code> by <code>j</code>:</p>

<pre><code>for (i = 0; string2[i] != '\0'; i++)
{
  for( ; string1[j] != '\0'; j++)
  {
</code></pre>

<p>But in your comparison, the indices are backwards:</p>

<pre><code>if (string1[i] == string2[j])
</code></pre>

<p>correct that to:</p>

<pre><code>if (string1[j] == string2[i])
</code></pre>
",2
26223663,26223642,28,"<h2>They're both undefined behavior.</h2>
<p>To print a pointer with printf, you should cast the pointer to <code>void *</code> and use <code>&quot;%p&quot;</code>.</p>
<h2>That being said:</h2>
<p>We can talk about the difference between <code>&quot;%ld&quot;</code> and <code>&quot;%lx&quot;</code> when trying to print integers. <code>%ld</code> expects a variable of type <code>long int</code>, and <code>%lx</code> expects a variable of type <code>long unsigned int</code>.</p>
<p>More or less though, The difference between <code>x</code>, <code>o</code>, <code>d</code> and <code>u</code> are about how numbers are going to be printed.</p>
<ul>
<li><code>x</code> prints an unsigned number in hexadecimal.</li>
<li><code>o</code> prints an unsigned number in octal.</li>
<li><code>u</code> prints an unsigned number in decimal.</li>
<li><code>d</code> prints a signed number in decimal.</li>
<li><code>i</code> prints a signed number in decimal.</li>
</ul>
<p>We can then attach <code>l</code> to the format string for formats like <code>%lx</code> to specify that instead of an <code>int</code>, we're using a <code>long int</code> (That is, an <code>unsigned long int</code>, or <code>long int</code>).</p>
<p>There is a table at cppreference that has additional information: <a href=""http://en.cppreference.com/w/c/io/fprintf"" rel=""noreferrer"">http://en.cppreference.com/w/c/io/fprintf</a></p>
",10
26223665,26223642,2,"<p><code>%p</code> and <code>%lx</code> prints the address in hexadecimal while <code>%ld</code> prints it in decimal</p>
",0
24128839,24128740,4,"<p>Just like with <code>malloc</code>, when you call <code>realloc</code> you should multiply the number of elements by the size of an element(in this case <code>sizeof(int)</code>.</p>
",2
27119890,27119872,1,"<p>you need to change </p>

<pre><code>struct boot_sect_t* boot = malloc(sizeof(boot_sect_t));
</code></pre>

<p>to</p>

<pre><code>boot_sect_t* boot = malloc(sizeof(boot_sect_t));
</code></pre>

<p><code>boot_sect_t</code> is already a <code>typedef</code>. no need to write <code>struct boot_sect_t</code>.</p>
",0
24349441,24348476,0,"<p>The question has strong bonds with <a href=""http://en.wikipedia.org/wiki/Competitive_programming"" rel=""nofollow"">competitive programming</a>. Usually there is a problem displayed and user is expected to submit code which gives expected output for tested input for <a href=""http://en.wikipedia.org/wiki/Online_judge"" rel=""nofollow"">online judge</a>, and <a href=""http://www.spoj.com/"" rel=""nofollow"">SPOJ</a> being one of them. And actually there is sample input and sample output displayed an almost all problems. So your code would give same output as shown in sample output for problem's sample input in <a href=""http://ideone.com/"" rel=""nofollow"">ideone</a>, but your code is tested to huge amount of data in online judge and that would result in NZEC. </p>
",0
24349069,24348476,1,"<p>Wait what, MANY problems here.
Here are few, first:</p>

<pre><code>  int n,i;
  scanf(""%d"",&amp;n);
  long num[n];
</code></pre>

<p>isn't possible (or isn't supposed to be possible at least) to declare an array in the size of a certain variable, use <a href=""http://www.cplusplus.com/reference/cstdlib/malloc/"" rel=""nofollow"">malloc()</a> for that by doing so:</p>

<pre><code>long* num = malloc(sizeof(long)*n);
</code></pre>

<p>Another problem, is that you cross the boundary of the array in the first loop, which is weird because you took care of it in the second one :P
Just change: <code>for(l = 0 ; l &lt; n ; l++)</code> to <code>for(l = 0 ; l &lt; n-1 ; l++)</code> as in your IF statement you use the array l+1 element, and when l is n-1 you actually test n-1 element compared to the Nth one - which isn't in the boundary of your array.
Other than that the code seems okay.</p>
",3
32939486,32938358,3,"<p>Segmentation faults are often caused by invalid memory accesses. Recompile your program with <a href=""/questions/tagged/address-sanitizer"" class=""post-tag"" title=""show questions tagged &#39;address-sanitizer&#39;"" rel=""tag"">address-sanitizer</a> and/ or <a href=""/questions/tagged/ubsan"" class=""post-tag"" title=""show questions tagged &#39;ubsan&#39;"" rel=""tag"">ubsan</a> on a sufficiently modern version of Clang or GCC.</p>

<p>It aborts pretty much here with a meaningful backtrace:</p>

<pre><code>$ gcc -Wall -g prime.c -fsanitize={undefined,address} -pthread
$ ./a.out
prime.c:121:9: runtime error: index 1 out of bounds for type 'long long unsigned int [1]'
prime.c:121:9: runtime error: index 1 out of bounds for type 'long long unsigned int [1]'
prime.c:121:9: runtime error: load of address 0x0000006043e8 with insufficient space for an object of type 'long long unsigned int'
0x0000006043e8: note: pointer points here
 20 8a a2 ec  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  00 00 00 00
              ^ 
=================================================================
==3351==ERROR: AddressSanitizer: global-buffer-overflow on address 0x0000006043e8 at pc 0x0000004018cb bp 0x7fc153ae0e30 sp 0x7fc153ae0e20
READ of size 8 at 0x0000006043e8 thread T31
    #0 0x4018ca in my_thread /tmp/so/prime.c:121
    #1 0x7fc1660064a3 in start_thread (/usr/lib/libpthread.so.0+0x74a3)
    #2 0x7fc165d4413c in clone (/usr/lib/libc.so.6+0xe913c)

0x0000006043e8 is located 0 bytes to the right of global variable 'buffer' defined in 'prime.h:15:29' (0x6043e0) of size 8
0x0000006043e8 is located 56 bytes to the left of global variable 'mutex' defined in 'prime.c:12:29' (0x604420) of size 40
SUMMARY: AddressSanitizer: global-buffer-overflow /tmp/so/prime.c:121 my_thread
</code></pre>

<p>Line 121 contains <code>buffer[local_current/64]</code>:</p>

<pre><code>static void * my_thread (void * arg) {
    unsigned long long * argi;
    argi = (unsigned long long *) arg;   // cast it to a int pointer
    unsigned long long local_current = * argi;
    unsigned long long helper = local_current;
    free(arg);
    while (local_current &lt;= NROF_SIEVE) {
        local_current = local_current + helper;
        pthread_mutex_lock (&amp;mutex);
        BIT_CLEAR(buffer[local_current/64], local_current % 64);
        pthread_mutex_unlock (&amp;mutex);
    }
    return NULL;
}
</code></pre>

<p>This seems to suggest that your <code>local_current</code> becomes larger than <code>NROF_SIEVE</code> which is indeed the case if <code>helper &gt; 0</code>. Something is fishy...</p>

<p>With a debugger (<code>gdb</code>), you can set (conditional) breakpoints, inspect variables and more. An example:</p>

<pre><code>$ gdb -q ./a.out 
Reading symbols from ./a.out...done.
(gdb) break prime.c:121 if local_current &gt;= 64
Breakpoint 1 at 0x4017e6: file prime.c, line 121.
(gdb) run
Starting program: /tmp/so/a.out 
[Thread debugging using libthread_db enabled]
Using host libthread_db library ""/usr/lib/libthread_db.so.1"".
[Switching to Thread 0x7fffe21de700 (LWP 4118)]

Breakpoint 1, my_thread (arg=0x60200000ebd0) at prime.c:121
121             BIT_CLEAR(buffer[local_current/64], local_current % 64);
(gdb) print local_current
$1 = 70
(gdb) step
__ubsan::__ubsan_handle_out_of_bounds (Data=0x602ea0, Index=1) at /build/gcc-multilib/src/gcc-5.2.0/libsanitizer/ubsan/ubsan_handlers.cc:227
227     /build/gcc-multilib/src/gcc-5.2.0/libsanitizer/ubsan/ubsan_handlers.cc: No such file or directory.
(gdb) next
prime.c:121:9: runtime error: index 1 out of bounds for type 'long long unsigned int [1]'
228     in /build/gcc-multilib/src/gcc-5.2.0/libsanitizer/ubsan/ubsan_handlers.cc
(gdb) info threads 
  Id   Target Id         Frame 
  40   Thread 0x7fffdf9d9700 (LWP 4128) ""a.out"" 0x00007ffff5f4dcfc in __lll_lock_wait () from /usr/lib/libpthread.so.0
  39   Thread 0x7fffe01da700 (LWP 4127) ""a.out"" 0x00007ffff5f4dcfc in __lll_lock_wait () from /usr/lib/libpthread.so.0
  38   Thread 0x7fffe09db700 (LWP 4125) ""a.out"" 0x00007ffff5f4dcfc in __lll_lock_wait () from /usr/lib/libpthread.so.0
  37   Thread 0x7fffe11dc700 (LWP 4124) ""a.out"" 0x00007ffff5f4dcfc in __lll_lock_wait () from /usr/lib/libpthread.so.0
  36   Thread 0x7fffe19dd700 (LWP 4123) ""a.out"" 0x00007ffff5f4dcfc in __lll_lock_wait () from /usr/lib/libpthread.so.0
* 35   Thread 0x7fffe21de700 (LWP 4118) ""a.out"" __ubsan::__ubsan_handle_out_of_bounds (Data=0x602ea0, Index=1)
    at /build/gcc-multilib/src/gcc-5.2.0/libsanitizer/ubsan/ubsan_handlers.cc:227
  34   Thread 0x7fffe29df700 (LWP 4117) ""a.out"" 0x00007ffff5f4dcfc in __lll_lock_wait () from /usr/lib/libpthread.so.0
  33   Thread 0x7fffe31e0700 (LWP 4116) ""a.out"" 0x00007ffff5f4dcfc in __lll_lock_wait () from /usr/lib/libpthread.so.0
  32   Thread 0x7fffe39e1700 (LWP 4115) ""a.out"" 0x00007ffff5f4dcfc in __lll_lock_wait () from /usr/lib/libpthread.so.0
  9    Thread 0x7fffef1f8700 (LWP 4092) ""a.out"" 0x00007ffff5f4dcfc in __lll_lock_wait () from /usr/lib/libpthread.so.0
  7    Thread 0x7ffff01fa700 (LWP 4089) ""a.out"" 0x00007ffff5f4dcfc in __lll_lock_wait () from /usr/lib/libpthread.so.0
  6    Thread 0x7ffff09fb700 (LWP 4088) ""a.out"" 0x00007ffff5f4dcfc in __lll_lock_wait () from /usr/lib/libpthread.so.0
  4    Thread 0x7ffff19fd700 (LWP 4086) ""a.out"" 0x00007ffff5f4dcfc in __lll_lock_wait () from /usr/lib/libpthread.so.0
  1    Thread 0x7ffff7fac7c0 (LWP 4080) ""a.out"" 0x00007ffff5f4dcfc in __lll_lock_wait () from /usr/lib/libpthread.so.0
(gdb) continue
Continuing.
prime.c:121:9: runtime error: index 1 out of bounds for type 'long long unsigned int [1]'
prime.c:121:9: runtime error: load of address 0x0000006043e8 with insufficient space for an object of type 'long long unsigned int'
0x0000006043e8: note: pointer points here
 20 8a a2 a8  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  00 00 00 00
              ^ 
=================================================================
==4080==ERROR: AddressSanitizer: global-buffer-overflow on address 0x0000006043e8 at pc 0x0000004018cb bp 0x7fffe21dde30 sp 0x7fffe21dde20
</code></pre>

<p>Good luck with your homework!</p>
",2
26782669,26782626,8,"<p>Your syntax is wrong, it's:</p>

<pre><code>#define TAILLE_TAB 100
</code></pre>
",9
25470869,25470733,2,"<p>The good idea is to run the program in debugger or memory access validator.</p>

<p>One option is gdb that can be started with command gdb ./yourprogaram. Next you have to start running it with command run. Later on you can view backtrace of crash and read the variables in the program memory.</p>

<p>Another option is valgrind that does memory access checking and prints useful information about errors.</p>

<p>Mastering debugging tools is a very important skill for programmers. That why it is best to try them on simple programs from start.</p>
",0
25470807,25470733,0,"<p>You haven't initialized <code>Lista</code> which is likely the cause for your segfault. Add some headers (<code>#include &lt;stdio.h&gt;</code> and <code>#include &lt;stdlib.h&gt;</code>) and recompile it with debugging symbols and warnings on (and a <code>main</code> function):</p>

<pre><code>cc -Wall -Wextra -g yourfile.c -o yourfile
</code></pre>

<p>Then use <code>gdb</code> to debug this:</p>

<pre><code>gdb -q -ex r ./yourfile
</code></pre>
",0
26804536,26804448,2,"<p>No, I don't think you can do so, at least not cleanly. But I also fail to understand your usage case fully.</p>

<p>If your object is <code>static</code>, nobody knows its name outside of your module. So nobody can use <code>&amp;</code> to take its address.</p>

<p>If you need to expose it, and don't want other parts of the program modifying it, write a function that exposes it as a constant pointer:</p>

<pre><code>static int array[SIZE];

const int * get_array(void)
{
  return array;
}
</code></pre>

<p>Then compile with warnings. If somebody casts away the <code>const</code>, it's their problem.</p>
",5
26805270,26804448,1,"<p>Assuming you are concerned with security issues, here are a few things to consider:</p>

<ol>
<li><p>The purpose of <code>register</code> keyword was to recommend the compiler to keep that variable in a register, as it will be intensively used. As the registers don't have a memory address, it is impossible to get it (although this wasn't the primary purpose of this keyword; it is merely a side-effect). As compilers got better at generating efficient code, this is not needed any more.</p></li>
<li><p>Even if you could make all objects in your code ""addess-proof"" (impossible to get their address), the program will still not be 100% safe. Those objects are still stored in memory, which is still visible. By analysing the binary files, using debuggers, analysing the memory map and so on, one could find out those memory addresses.</p></li>
<li><p>This is not a good practice. In order for someone to get the variable of an object in a module, that object must be global, which is bad. So you should worry about having global variables, not about their visibility. <a href=""https://softwareengineering.stackexchange.com/questions/148108/why-is-global-state-so-evil"">Here</a> you can find more details about why is it bad to have variables in the global scope.</p></li>
<li><p>As a semi-solution to your ""problem"", you can declare them const static. This way they cannot be accessed from outside the module and if it happens, no one can change their value.</p></li>
</ol>
",2
24582570,24582556,0,"<p><strong>NEVER USE GETS()</strong></p>

<p>It's unsafe to use <code>gets()</code> under any circumstances, because it doesn't check the length of its input against the length of the array.  Use <code>fgets()</code> instead.</p>

<p>Now that you understand that, take a look at your inner loop:  </p>

<pre><code>for(p2=ch2;p2&lt;ch2;p2++)
</code></pre>

<p>You set <code>p2=ch2</code>, then check if <code>p2&lt;ch2</code>.  This will always be false.  Perhaps you mean to check if <code>p2&lt;ch2+100</code>?</p>
",4
24582722,24582556,0,"<p>First of all, you need bounds checking. <code>gets()</code> does not provide bounds checking.</p>

<p>As for for your loops, you will never enter the nested loops:
<code>for(p2=ch2;p2&lt;ch2;p2++)</code>
Your initialization will always make your condition false, and you will never enter the loop.</p>
",0
24582738,24582556,1,"<p><code>strcpy()</code> expects that its source and destination arguments don't overlap in memory ¡ª in other words, writing to the destination string shouldn't overwrite parts of the source string.  So you can't use it to ""shift"" a string by an amount that's less than its length.  Instead, you can use <code>memmove()</code>, which supports overlapping ranges.</p>

<p>You can replace your <code>strcpy</code> line with:</p>

<pre><code>memmove(p1, p1+1, strlen(p1+1));
</code></pre>

<p>which will correctly do what you had expected the <code>strcpy()</code> call to do.</p>

<hr>

<p>Also, your termination condition for the inner loop is <code>p2&lt;ch2</code>, which is always false since they start out equal.  You probably meant to write <code>p2&lt;ch2+100</code>.</p>

<p>Your loop conditions have another problem, though:  they go past the end of the actual string that's stored in the array.  If the user types fewer than 99 characters of input for either string, the corresponding array will contain garbage characters after the null terminator.  In the <code>ch1</code> array, scanning past the end of the string may cause <code>strlen()</code> to go past the end of the whole array looking for another null terminator, and in <code>ch2</code>, going past the end of the string will cause the program to filter out characters that the user didn't specify.</p>

<p>You should change the two loop conditions to <code>*p1 != '\0'</code> and <code>*p2 != '\0'</code>.  This will make the loops stop when they reach the end of the two strings.</p>
",1
24582801,24582556,0,"<p>Here is one solution to the problem.  This code eliminates the inner loop of the question code by implementing strchr() to determine if a specific character of string1 is present in string2:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
   {
   char ch1[100] , ch2[100];
   char *p1, *p2;

   /* Get string1 from stdin. */
   printf(""first chaine "");
   fgets(ch1, sizeof(ch1), stdin);

   /* Get string2 from stdin. */
   printf(""sd chaine "");
   fgets(ch2, sizeof(ch2), stdin);

   /* Eliminate all chars from string1 that appear in string2. */
   for(p1=ch1, p2=ch1; *p1; p1++)
      {
      if(strchr(ch2, *p1))
         continue;

      *p2++ = *p1;
      }
   *p2 = '\0';   

   /* Print modified string1. */
   puts(ch1);

   return(0);
   }
</code></pre>

<hr>

<p>Execution example of the above code:</p>

<pre><code>SLES11SP2:~/SO&gt; ./test
first chaine Now is the time for all good men to come to the aid of their country.
sd chaine aeiou
Nw s th tm fr ll gd mn t cm t th d f thr cntry.
SLES11SP2:~/SO&gt; 
</code></pre>
",0
24642570,24641303,0,"<p>Just think what needs to be done when you get  ','. You may have to add else if rather than just stopping at else.</p>
",1
24621832,24621793,4,"<p>You need to add string terminators <code>'\0'</code> to your string before printing (or zero out the buffers memory first).</p>

<p>Also: you have declared buffers of size 20, but have no guards in your code to respect that allocated length, which means you could overrun them and corrupt memory. [Run with two words greater than 20 characters...]</p>
",0
24621891,24621793,1,"<p>'\n' and '\0' are different here. You need to add '\0' at the end of string because printf prints out string until it meets '\0'. C doesn't initializes array. If you do not initialize manually it will have garbage values.</p>

<p>I would do:</p>

<pre><code>char temp3[20] = {0};
char temp4[20] = {0};
</code></pre>

<p>to fill out temp3 and temp3 with 0, which is same as '\0'.</p>
",1
24622260,24621793,1,"<p>The string in C requires to be NULL-terminated.
A lot of functions use that <strong>terminator</strong> to announce the processor  where the string ends.</p>

<p>What will hapan if not terminated? Lets get one simple string, with consumpption of 5 bytes of memory.</p>

<p><code>...[?][?][H][e][l][l][o][?][?][?]...</code></p>

<p>That causes a leak. As you see we haven't store a NULL. It causes u/b and you may get different signs on any new run. For us.. the processor puts the string in random blocks of memory. However gcc by default has optimizations to prevent that.</p>
",0
24625215,24621793,1,"<p>when you give a string as 'abc' it will be saved as 'abc\0',so check for \0 also and dont print it</p>
",0
24624161,24624129,1,"<p>Yes it is allowed. You may try like this:</p>

<pre><code>#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;

int main() {
    putchar(tolower('A'));
}
</code></pre>
",2
24624245,24624129,1,"<p>Yes it is allowed because you are editing a local copy of s. See the live example here:</p>

<p>Try this:</p>

<pre><code>int convert(int s){
    (s &gt;= 97 &amp;&amp; s &lt;= 122)? (s -= 32) : (s += 32);
    return s;
}

int main(void) {

    int val = 10, val2;
    val2 = convert(val);
    printf(""%d %d\n"", val, val2);
    return 0;
}
</code></pre>

<p>Here is a live example. </p>

<p><a href=""http://ideone.com/5aJcOv"" rel=""nofollow"">http://ideone.com/5aJcOv</a></p>

<p>Of course you should be using <code>toupper</code> and <code>tolower</code> in conjunction with <code>isupper</code> and <code>islower</code> to change the case of the ascii characters:</p>

<pre><code>#include &lt;ctype.h&gt;
char toggleCase(char c)
{
    if (c &gt;= 'a') {  // Check that it is a letter
        if (isupper(c)) return tolower(c); //Convert it
        return toupper(c);
    }
    return c; // Otherwise dont 
}
</code></pre>
",0
24596394,24596257,0,"<p>You can avoid the issue with the <code>\n</code> (newline) mentioned by BLUEPIXY -- namely, that <code>gets()</code> removes it but <code>fgets()</code> does not -- by reversing the terms in your call to <code>checkAnswer()</code>:</p>

<pre><code>checkAnswer(answer, strGame[x]);
</code></pre>

<p><code>checkAnswer()</code> then uses the same order with <code>strstr()</code>.  If you search for ""foobar"" in ""foobar\n"", <code>strstr()</code> will return a pointer.  But if you search for ""foobar\n"" in ""foobar"", it won't.</p>

<p>The newline is there because the user hits <kbd>Enter</kbd>.  So another way around this would be to add a <code>\n</code> to the end of all your <code>strGame[]</code> strings.  Or, you could remove any newline in the answer with:</p>

<pre><code>void truncateAtNewline (char *str) {
    char *p = strchr(str, '\n');
    if (p) *p = '\0';
}
</code></pre>
",3
24596461,24596257,0,"<p>The problem is that <code>fgets()</code> will leave the newline at the end of the string. When you type the word, then you press <kbd>Enter</kbd> and <code>fgets()</code> interprets that as input.</p>

<p>So, a way to bypass this is to eat the newline by doing this:</p>

<pre><code>fgets(answer, 80, stdin);
// go to the last position where the
// newline is placed and replace it
// with the null terminator
answer[strlen(answer)-1] = '\0';
</code></pre>

<p>Also here:</p>

<pre><code> for (x = 0; x &lt;= strlen(string2); x++)
    string2[x] = toupper(string2[x]);
</code></pre>

<p>the <code>&lt;=</code> is not needed, since you start from 0, thus change it to this:</p>

<pre><code> for (x = 0; x &lt; strlen(string2); x++)
    string2[x] = toupper(string2[x]);
</code></pre>

<p>How I found your problem? I used printf to output the strings before comparing them.</p>

<pre><code>void checkAnswer(char *string1, char string2[]) {
  int x;

  for (x = 0; x &lt; strlen(string2); x++)
    string2[x] = toupper(string2[x]);
  printf(""|%s|\n"", string1);
  printf(""|%s|\n"", string2);
  if (strstr(string1, string2) != 0)
    printf(""\nGreat job!\n"");
  else
    printf(""\nSorry, word not found!\n"");

}
</code></pre>

<p>Output before my fix:</p>

<pre><code>|ADELANGUAGEFERVZOPIBMOU|
|ADEL
|
</code></pre>

<p>Output after the fix:</p>

<pre><code>|ADELANGUAGEFERVZOPIBMOU|
|ADEL|
</code></pre>

<p>Or you can use a function to  trim newlines and spaces. I have some methods <a href=""http://gsamaras.wordpress.com/code/eat-spaces-and-newline-c/"" rel=""nofollow noreferrer"">here</a>.</p>

<p>Consider also <a href=""https://stackoverflow.com/questions/4622693/issuing-system-commands-in-linux-from-c-c"">not using system()</a>.</p>

<p>Moreover, always add a <code>return 0;</code> line of code before your main() ends.</p>
",0
25517057,25516958,0,"<p>error is here:</p>

<pre><code>int raices(float r,float discriminante,float a,float b,float c, float *r1, float *r2)
{
</code></pre>

<p>should be</p>

<pre><code>void raices(float a,float b,float c, float *r1, float *r2)
{
    float r;
    float discriminante;
</code></pre>
",3
27522017,27521899,2,"<p>By doing something like <code>read 10 characters in a buffer</code> is not going to give you 10 <code>float</code> [or whatever] in the <code>buffer</code>. This is not the way you should be reading from a file. My suggestion is</p>

<ol>
<li><p>read a line from file using <a href=""http://linux.die.net/man/3/fgets"" rel=""nofollow""><code>fgets()</code></a>.</p></li>
<li><p>tokenize the read buffer using proper delimiter [space in your case, maybe] using <a href=""http://linux.die.net/man/3/strtok"" rel=""nofollow""><code>strtok()</code></a>.</p></li>
<li><p>convert each token to float using <a href=""http://linux.die.net/man/3/strtof"" rel=""nofollow""><code>strtof()</code></a> (better than <code>atof()</code>) and store into array.</p></li>
</ol>

<p><sup>
Notes:
</sup> </p>

<p><sup>
1. <code>fgets()</code> reads and stores the trailing <code>\n</code>. Take care when tokenizing. 
2. The supplied buffer in <code>fgets()</code> should be long engouh to hold a complete <em>line</em> input from the file.
</sup></p>

<p>Also, worthy to mention, please check the success of <code>fopen()</code> call by putting a <code>NULL</code> check on <code>fp</code> after the call. Same goes for <code>fread()</code>.</p>

<hr>

<p>EDIT:</p>

<p>Working code below.</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define MAXVAL 1024

int main()

{
        FILE * fp  = NULL;
        int read = 0;
        int i = 0;
        char * token = NULL;

        char buffer[MAXVAL] = {0};
        float bufferFloat[10] = {0}; //better way, use dynamic allocation

        fp=fopen(""Xvalues.txt"", ""r"");
        if(fp==NULL)
        {
                printf(""error opening the file"");
                return -1;      //don't continue
        }

        //storing one line  in  buffer using fgets
        if ( ! fgets(buffer, MAXVAL, fp) ){
            printf(""error reading the file"");
            return -2;      //don't continue
        }
        //Tokanizing 
        const char *s = "" \n"";      //because of fgets() stroing \n
        //get the first token  

        token = strtok(buffer, s);
        i = 0;
        while (token!=NULL)
        {
                bufferFloat[i++] = strtof(token, NULL);     //I used NULL used for simplicity, you follow the proper way.
                token  = strtok(NULL, s);
        }

        for(i=0; i&lt; 10; i++)
        {
                printf(""float values are%f\n"", bufferFloat[i]);
        }

        fclose (fp);
        return 0;
}
</code></pre>

<p>Compile using </p>

<pre><code>gcc test.c --std=c99
</code></pre>

<p>Run</p>

<pre><code>./a.out
</code></pre>

<p>Output:</p>

<pre><code>[sourav@broadsword temp]$ ./a.out 
float values are20.500000
float values are20.490000
float values are20.469999
float values are20.459999
float values are20.510000
float values are20.500000
float values are20.500000
float values are20.490000
float values are20.490000
float values are20.500000
[sourav@broadsword temp]$ 
</code></pre>
",5
27522090,27521899,1,"<p>If you have fixed  numbers as you mentioned you may use <code>fscanf()</code></p>

<p>Guide - <a href=""http://www.tutorialspoint.com/c_standard_library/c_function_fscanf.htm"" rel=""nofollow"">http://www.tutorialspoint.com/c_standard_library/c_function_fscanf.htm</a></p>

<p>Assumption - 10 numbers per line and it will not change </p>

<p>solution </p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;


int main(){

FILE *fp;
char read;

fp=fopen(""Xvalues.txt"",""r"");


float array[10];

int i;

 do{
    read=fscanf(fp,""%f %f %f %f %f %f %f %f %f %f"",&amp;array[0],&amp;array[1],&amp;array[2],&amp;array[3],&amp;array[4],&amp;array[5],&amp;array[6],&amp;array[7],&amp;array[8],&amp;array[9]);
    fclose(fp);

    for(i=0 ; i&lt; 10 ;i++){
        printf(""%f "",array[i]);
    }
    printf(""\n"");

 }while(read != EOF);

 return 0;
}
</code></pre>

<p>output </p>

<blockquote>
  <p>20.500000
  20.490000
  20.469999
  20.459999
  20.510000
  20.500000
  20.500000
  20.490000
  20.490000
  20.500000</p>
</blockquote>
",2
27522784,27521899,0,"<p>If data has been written as float into file then better to use fscanf() to get data in appropriate format.</p>
",0
27527021,27521899,0,"<p>Read the line with <code>fgets()</code> the use <code>strod()</code> to parse it.</p>

<p>Anytime input data is in a <em>line</em>, consider <code>fgets()</code></p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

#define MAX_EXPECTED_FLOAT_WIDTH (7)
#define MAX_EXPECTED_LINE_WIDTH(n)  (n * (MAX_EXPECTED_FLOAT_WIDTH + 1) + 2)

int ReadNfloat(FILE *stream, float *dest, int n) {
  char buffer[MAX_EXPECTED_LINE_WIDTH(n) * 2];  // I like 2x buffers
  if (fgets(buffer, sizeof buffer, stream) == NULL) {
    return -1;
  }
  char *p = buffer;

  for (int i=0; i&lt;n; i++) {
    char *endptr;
    double number = strtod(p, &amp;endptr);
    if (p == endptr) {  // no conversion
      return i;
    }

    // Code could do various tests. like to see if in expected range.
    if (number &lt; 0 || number &gt; 9999.99) {
      return i;
    }

    dest[i] = (float) number;
    p = endptr;
  }

  // Detect extra garbage
  while (isspace((unsigned char) *p) p++;
  if (*p) {
    return -1; 
  }

  return n;
}
</code></pre>
",0
25473319,25473263,1,"<p>There isn't a simple way to do it in C.  The C++ code relies on constructors (the copy constructor) to implement the copy, which is necessary because you can't tell a priori whether there are pointers in the class or allocated memory that need to be altered when an independent copy of the structure is made.</p>

<p>If you are going to copy the structures in a C ADT, then at a bare minimum you will need to specify the size of the structure to be copied as part of the interface.  However, you really need a copy function that knows how to deal with the pointers in a copy of the structure.</p>

<p>Passing pointers around is simpler; it is clear that the object that is pointed at continues to exist unmodified by the fact that its pointer is now stored in a list.</p>
",0
27503066,27503029,2,"<p>Add <code>#include &lt;ctype.h&gt;</code> in the beginning to get the prototype of <code>isspace()</code>, and</p>

<pre><code>if(isspace(str))
</code></pre>

<p>should be</p>

<pre><code>if(isspace(str[i]))
</code></pre>
",1
27503072,27503029,1,"<p>Change the condition like this.</p>

<pre><code> if(isspace(str[i]))
</code></pre>

<p>Because isspace is <code>int isspace(int c);</code></p>
",0
27503116,27503029,2,"<p>Try this..</p>

<pre><code>for(i = 0; i &lt; len; i++)
{
   if(isspace(str[i]))
   {
       ++word;
       continue;
   }
  ++nc;
}

if(len&gt;0) word++;

printf(""%d %d\n"",nc, word);
</code></pre>
",4
27503147,27503029,0,"<pre><code>int isspace(int c);
</code></pre>

<p>This is the prototype of <code>isspace()</code> function.</p>

<p>You need to pass the the value which you want to check like:</p>

<pre><code>isspace(str[i]);
</code></pre>

<p>not the whole string.</p>
",0
27503181,27503029,2,"<p>First, add <code>#include &lt;ctype.h&gt;</code> in your code.</p>

<p>Next, <a href=""http://linux.die.net/man/3/isspace"" rel=""nofollow""><code>isspace()</code></a> intakes one <code>int</code> argument and checks the input [in terms of ASCII value] to be </p>

<blockquote>
  <p>white-space characters. In the ""C"" and ""POSIX"" locales, these are: space, form-feed ('\f'), newline ('\n'), carriage return ('\r'), horizontal tab ('\t'), and vertical tab ('\v').</p>
</blockquote>

<p>So, you need to provide the elements of the array <code>str</code> one-by-one to <code>isspace()</code>. For that, you need to change your code to</p>

<pre><code>if(isspace(str[i]))
</code></pre>

<p>which will give non-zero value if <code>str[i]</code> is a white-space character.</p>

<p>Also, to match your required output [as mentioned in the question], you need to make use of the intermediate values of <code>str[i]</code> and reset <code>nc</code> after every <code>TRUE</code> value of <code>isspace()</code>.</p>
",0
27503456,27503029,0,"<p>Give it a try</p>

<pre><code>int len = strlen(str);    //len will be number of letters
for(int i = 0; i &lt; len; i++)
{
    if(isspace(str[i]))       
         ++word;   
}

if(len){
//if you dont want to count space letters then write
//len -= word; 
    word++;     //counting last word
}
printf(""letters = %d, Words =%d"", len,word);
</code></pre>

<p>As you are getting <code>len</code> it will give you number of letters so no need to count <code>nc</code>.</p>
",0
25506495,25506414,1,"<p>The <code>^</code>  (binary xor) operator is not defined for floats while using it in <code>t^2</code></p>

<p><a href=""http://msdn.microsoft.com/en-us/library/3akey979.aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/3akey979.aspx</a> says: ""Both operands to the bitwise exclusive OR operator must be of integral types. ""</p>
",0
25506498,25506414,4,"<pre><code>y[n]= sin(X_beta*t+X_ahp*(t^2)); 
</code></pre>

<p>You must think <code>t^2</code> means the power 2 of <code>t</code>. It's not. <code>^</code> is the bitwise xor operator. You can use <code>pow</code> function instead.</p>

<p>As @Matt McNabb points out, for the power of 2, you can use <code>t * t</code> here.</p>
",1
25675254,25670288,3,"<p>In C90, a decimal constant gets the type it first fits into</p>

<pre><code>int, long, unsigned long
</code></pre>

<p>In C99 onward, a decimal constant gets the type it first fits into</p>

<pre><code>int, long, long long
</code></pre>

<p>In your system, <code>2150000000</code> is bigger than <code>LONG_MAX</code> (certainly 2147483647).  So with a C90 compiler, it is <code>unsigned long</code>.  With current compilers, it is <code>long long</code>.</p>

<p>Should you ignore?  It depends on subsequent code.  Recommended to not ignore and explicitly declaring the decimal constant as an unsigned one by appending the <code>u</code> suffix like <code>2500000000u</code>.</p>
",5
25674924,25674808,0,"<p>I'm pretty sure it's a problem with the precedence of the operators. Try this:
    if (TVOTE &lt; 1 || TVOTE > 7)
       (*BadVote)++;</p>
",0
25674879,25674808,4,"<p>The postfix <code>++</code> operator takes precedence over the <code>*</code>; when you write <code>*BadVote++</code>, you're actually incrementing the pointer, not the value being pointed to. You should instead write <code>(*BadVote)++</code>. See <a href=""https://stackoverflow.com/questions/8208021/how-to-increment-a-pointer-address-and-pointers-value"">this question</a> for more.</p>
",1
26813372,26813343,-1,"<p>You can write your own. It's better to check digits since there're less cases for digits.</p>

<pre><code>bool isDigit(char c) {
    bool rtn = false;
    switch(c) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            rtn = true;
            break;
        default:
            rtn = false;
            break;
    }
return rtn;
}
</code></pre>
",2
26813384,26813343,0,"<p>You will need to use <code>scanf</code> to get user input with <code>%d</code> as you want to scan an integer. In your case, <code>scanf</code> will return 1 on sucessfull scanning. </p>

<pre><code>int num;
//loop to prompt use to enter valid input
while(scanf(""%d"",&amp;num)==0) //scanning an integer failed
{
    printf(""invalid input ! Try again\n"");
    scanf(""%*s""); //remove the invalid data from stdin
}
</code></pre>

<p>The functions <code>isalpha()</code> and <code>isdigit()</code> works when you are getting a character input using <code>%c</code> in the <code>scanf</code>. If you want to scan input using <code>%c</code> , then you can simply check like what you have done in your code provided that you get input using <code>%c</code>. Note that character 1 (<code>'1'</code>) is note equal to integer 1 . Characters have their integer values as represented by <a href=""http://www.asciitable.com/index/asciifull.gif"" rel=""nofollow"">the ASCII table</a>. Your program to prompt the user again when the user enters anything other that a number using <code>%c</code> will look like this:</p>

<pre><code>    char ch;
    while(1){
        printf(""Enter a number\n"");
        scanf("" %c"",&amp;ch);

        printf(Your input is %c\n"",ch);
        if(isdigit(ch))
        {
            printf(""This is a number\n"");
            break;
        }
       else
           printf(""This is not a number. Invalid input\n"");
    }
</code></pre>
",0
26813440,26813343,0,"<p>I tried the below code which worked fine..using isdigit()</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include&lt;ctype.h&gt;

void main()
{
    system(""clear"");
    char str[1];

    printf(""Enter a number\n"");
    scanf(""%s"",str);

    printf(""What you entered was %s\n"",str);
    if(isdigit(str[0]))
        printf(""this is not an alphabet\n"");
    else
        printf(""this is an alphabet\n"");
}
</code></pre>
",0
26813470,26813343,0,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdbool.h&gt;
#include&lt;ctype.h&gt;
int main()
{
    char c;
    printf(""Enter a character: "");
    scanf(""%c"",&amp;c);
    bool check=true;

    while(check)
    {
    if( (c&gt;='a'&amp;&amp; c&lt;='z') || (c&gt;='A' &amp;&amp; c&lt;='Z'))
       {
           printf(""%c is an alphabet."",c);
           check=true;
           break;
       }
    else
    {
       printf(""%c is not an alphabet."",c);
        check=false;
    }
    }
    return 0;
}
</code></pre>
",0
26238847,26238813,3,"<p><code>while..else</code> is not a valid C construct.</p>

<p>Did you perhaps mean <code>if..else</code>?</p>
",1
26238851,26238813,1,"<p>In C, there is no <code>while - else</code> clause. In language like python, there is a <code>for-else</code> clause but still there is no <code>while-else</code>. You need to change <code>while</code> to <code>if</code> or remove <code>else</code> statement.</p>
",0
26239384,26238813,0,"<p>Replace <code>while</code> with <code>if</code>. If I am not wrong you are trying to break number into digits here?</p>
",0
29498747,29498653,2,"<p><em>typedef struct X {} Y;</em></p>

<p><em>X</em> - is a TAG which you can convert to something useful with syntax '<em>struct X val</em>'. <em>Y</em> is typename which you can use directly: <em>'Y val;'</em></p>

<p>Then, type name Y (in your case 'Person' is not visible inside of struct as it is defined later. That is why you have to use TAG inside of struct:</p>

<pre><code>typedef struct tag_Person {
    struct tag_Person (*func)(int arge, int salary);
} Person;
</code></pre>
",1
29498698,29498653,4,"<pre><code>typedef struct
{
    int age, salary;
    struct Person(*func) (int age, int salary);
} Person;
</code></pre>

<p>Shouldn't this be:</p>

<pre><code>typedef struct Person
{
    int age, salary;
    struct Person(*func) (int age, int salary);
} Person;
</code></pre>

<p>In the first case, you don't name your struct, so <code>struct Person</code> isn't a valid type name. My version of GCC gives more helpful output:</p>

<pre><code>$ gcc test.c
test.c: In function ¡®main¡¯:
test.c:20:11: warning: assignment from incompatible pointer type
     p.func= other_func;
           ^
test.c:21:5: error: invalid use of undefined type ¡®struct Person¡¯
     p = p.func(30, 3000);
</code></pre>

<p>Note that the two names don't need to match. All you're doing is combining a typedef and a struct declaration. This is would be equally valid:</p>

<pre><code>struct X {
    int age, salary;
    struct X(*func) (int age, int salary);
};

typedef struct X Person;
</code></pre>

<p>You may want to read <a href=""https://stackoverflow.com/a/1675446/212555"">this excellent answer about struct typedef'ing</a>.</p>
",2
33571955,33571442,1,"<p>There are several methods.  Answer 1 above is ok for min, max as doubles.  The important thing to remember for <code>rand()</code> is that it returns a random integer between <code>0</code> and <code>RAND_MAX</code> inclusive.  <code>RAND_MAX</code> is a least <code>2^15</code>, but on most systems <code>2^31</code>.  If min and max are integers and their difference is less than <code>RAND_MAX</code> then a very easy method is:</p>

<pre><code>delta = max - min;
r  = rand() % delta + min;
</code></pre>
",0
33571770,33571442,0,"<pre><code>#include &lt;stdlib.h&gt; /* rand(), srand(), RAND_MAX */

double randd(double min, double max) {
    int r = rand();
    double delta = max - min; /* assume max &gt; min */
    double tmp = r / (RAND_MAX + 1.0); /* generate up to but excluding max */
    return tmp * delta + min;
}
</code></pre>
",4
26415411,26415365,5,"<p>One solution is to return a status and use an OUT parameter like so:</p>

<pre><code>bool function(uint64_t Value, uint64_t N, uint64_t *result) {

   if (N &gt; 0){
     //do something;
     *result = 31337;
     return true;
   }
   else{
     return false;
   }
}
</code></pre>

<p>Then when you call this function you check that the function returns true before using the result.</p>
",2
26415417,26415365,3,"<p>For integer types, you can't.</p>

<p>There are exactly 2<sup>64</sup> possible values of type <code>uint64_t</code>, and each one of them is a valid integer value.</p>

<p>In some cases, you can choose one value (perhaps <code>UINT64_MIN</code>) that you can treat as an error indication, and return that -- but that's not always practical.</p>

<p>Or you can have the function return a success or failure result, and communicate the <code>uint64_t</code> value back to the caller by some other means, probably by storing it via a pointer passed in by the caller.</p>
",2
26415521,26415365,1,"<p>Another option is to return a struct. This works better in C++ (look at Boost Optional) but here's a C version:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

struct optional_int {
    bool valid;
    int  value;
};

struct optional_int f(int x)
{
    struct optional_int result = {false, 0};
    if(x &gt; 0 &amp;&amp; x &lt; 10) {
        result.valid = true;
        result.value = x * 1024;
    }
    return result;
}

int main()
{
    struct optional_int v;

    v = f(9);
    if(v.valid) {
        printf(""Result is %d\n"", v.value);
    }
    return 0;
}
</code></pre>
",0
26430379,26430317,2,"<p>In your code</p>

<pre><code>while (current != NULL)
{
    count++;
    printf(""The data is %d \n"", current-&gt;data);
}
</code></pre>

<p>you never change the value of <code>current</code>.  Either it starts as NULL and the loop never executes, or it starts non-NULL and the loop runs forever.</p>

<p>You should add</p>

<pre><code>current = current-&gt;next
</code></pre>

<p>after your <code>printf</code> to advance to the next element in the linked list.</p>
",0
26430397,26430317,0,"<p>In your <code>traverse</code> function, the <code>current</code> node is not pointing to next node. So the while condition <code>while (current != NULL)</code> will not be true and hence the while loop is running infinitely.</p>

<p>To fix it, <code>current</code> node should point to the next node (<code>current = current-&gt;next</code>) in the list after printing the data.</p>

<hr>

<p>For example:</p>

<pre><code>void traverse(elementptr f)
{
    elementptr current;
    int count = 0;

    current = f;
    while (current != NULL)
    {
        count++;
        printf(""The data is %d \n"", current-&gt;data);
        // Fix 
        current = current-&gt;next;  // Point to next node in link list
    }
}
</code></pre>
",0
26430539,26430317,2,"<p><code>current = current -&gt; next;</code> you are missing this statement in the while loop. Although I would suggest :</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
struct linked_list
{
    int number;
    struct linked_list *next;
    struct linked_list *prev;
};
typedef struct linked_list node;
void create(node *p);
void print(node *p);
int main()
{
    node *head;
    printf(""---Start of the list ---\n"");
    printf(""enter -1 to exit\n"");
    head = (node*)malloc(sizeof(node));
    create(head);
    print(head);
}
void create(node *list)
{
     printf(""enter the data"");
     scanf("" %d"",&amp;list-&gt;number);
     if(list-&gt;number == -1)//Enter -1 to exit untill then keep on taking values
     {
         list-&gt;next=NULL;
     }
     else
     {
         list-&gt;next = (node*)malloc(sizeof(node));
         create(list-&gt;next);
     }
}

void print(node *list)
{
    if(list-&gt;next != NULL)
    {
        printf(""%d--&gt;"",list-&gt;number);
        if((list-&gt;next-&gt;next == NULL) &amp;&amp; (list-&gt;next-&gt;number!=-1))
        printf(""%d --&gt;End of the List"",list-&gt;next-&gt;number);
        print(list-&gt;next);
    }
}
</code></pre>
",0
26238973,26238905,5,"<p>Your indentation is wrong. That might be an indication that your code doesn't do what you think it does. An ""else"" goes together with the ""if"" just before it, not the one you think. </p>
",2
26239024,26238905,2,"<pre><code>if(playerMove == 'H' || playerMove == 'h')
        flag = hitMe(&amp;count, &amp;check);
        if(flag == 2)
            break;
    else
        flag = 0; 
</code></pre>

<p>Here is the problem. else is not counted as else paired with first if</p>

<pre><code>if(playerMove == 'H' || playerMove == 'h')
</code></pre>

<p>It is paired with last if</p>

<pre><code>if(flag == 2)
</code></pre>

<p>Solution: Use {} delimiters to define from where your bodies of if and else are starting and where they are ending. Its good practice. Now you know why.</p>
",3
29189807,29189766,1,"<pre><code>the execution will never get beyond this 'if control block:

char a;
ch = &amp;a;

if(a != '\n'){
   return 0;
}else{
    return 1;
}

there is a few reasons it 'always' returns 0
1) 'a' is on the stack and could contain anything.
2) the chances of the 'trash' that is on the stack where 'a'
   is located are 255:1 against the trash happening to contain
   a new line character.

nothing beyond the 'if control block is ever executed because
an 'if' control block only has two execution paths 
and both paths contain a return statement.
</code></pre>
",1
26127588,26127324,2,"<p>you have several issues with your code. i will try to point them out</p>

<pre><code>numTries = numTries + 1;
</code></pre>

<p>you are using this variable, incrementing it in every iteration, but not using it anywhere.</p>

<pre><code>if (guess == myWord [0])
{
   printf(""\n %c----"", myWord [0]);
   printf(""\nGood Guess!\n"");
   printf(""\nPlease guess another letter: "");
   scanf("" %c"", &amp;guess);
}
</code></pre>

<p>you are comparing the guessed character with different characters of the word, but not remembering in anyway which letters or how many letters have been correctly guessed. ( maybe use a flag variable for this)</p>

<pre><code>if ( if word is completed and guessed correctly )
{
   printf(""\nCongrats! You guessed the secret word!\n"");
}
</code></pre>

<p>the above if loop makes no sense in c language</p>

<pre><code>else if ( guess != myWord )
{
   printf(""\nSorry. That is not a correct letter. Please guess again:\n"");
   scanf("" %c"", &amp;guess);
}
</code></pre>

<p>the above elseif statement compares a character variable with an array's base address</p>
",0
26127737,26127324,0,"<p>Here's a basic skeleton that you want your program to have. It doesn't work perfectly (I won't even guarantee that it compiles), but it should give you ideas on how you can improve your code.</p>

<pre><code>#include &lt;stdio.h&gt;

void main()
{
    char guess, newline;
    char myWord [6] = {'a','p','p','l','e','\0'};               // Initialization of variables
    char dashedArray [6] = {'-','-','-','-','-','\0'};
    int totalTries = 5;
    int currentTries = 0;
    int i, j;

    printf(""\nLet's play a game! The objective of the game is to guess my secret word. You will have five chances to guess.\n"");
    printf(""\nLet's get started!\n"");

    for (i=0; i&lt;totalTries; i++)
    {
        printf(""\nPlease enter a letter: "");
        scanf(""%c\n"", &amp;guess);

        for (j=0; j&lt;6; j++)
        {
            if (guess == myWord[j])
                dashedArray[j] = guess;
        }

        printf(""Result: %s"", dashedArray);

    }

    printf(""You lose."");
}
</code></pre>
",0
26130166,26130114,1,"<p>Simply pass in <code>argv[2]</code>.</p>

<pre><code>int main(int argc, char **argv)
{
    if((argc==3) &amp;&amp; (strcmp(""-open"", argv[1]) == 0))
    {
        FILE *fp = fopen(argv[2]);
        //OR
        otherFuncThatCallsFopen(argv[2]);
    }
}
</code></pre>

<p><code>argv[2]</code> is a valid <code>char *</code> that points to the 2nd argument.</p>
",0
26130226,26130114,0,"<p>You could write a function with signature like <code>unsigned int count_characters(const char *file_name)</code></p>

<p>and call it with <code>count_characters(argv[2])</code></p>
",0
26133515,26133433,2,"<p>For example, <code>a++</code> means first return <code>a</code>, then add <code>1</code> to <code>a</code>, while <code>++a</code> means first add <code>1</code> to <code>a</code>, then return <code>a</code>.</p>

<p>So</p>

<pre><code>i = ++a[1];
j = a[1]++;
m = a[i++];
</code></pre>

<p>equals to </p>

<pre><code>//i = ++a[1];
a[1] = a[1] + 1;//a[1] = 2
i = a[1];//i = 2
//j = a[1]++;
j = a[1];//j = 2
a[1] = a[1] + 1;//a[1] = 3
//m = a[i++];
m = a[i];//m = a[2] = 15
i = i + 1;//i = 3
</code></pre>

<p>So finally, i = 3, j = 2, m = 15.</p>
",0
26149309,26148970,1,"<p>Change the declaration of main to:</p>

<pre><code>int main(int argc, char * argv[]) {..
</code></pre>

<p>Then get rid of the two locals:</p>

<pre><code>  int argc;
  char argv;
</code></pre>

<p>Then see how you get on.  </p>

<p>Oh - and fix the return types and other stuff posted by @Fred and others:)</p>
",0
26410486,26409706,-1,"<p>This part of code is wrong</p>

<pre><code>while((strcmp(address,""Street"")) == 0 || (strlen(address) &gt; 50)  || (strcmp(address,""Street"") != 0));
</code></pre>

<p>Because you wrote <code>strcmp(address,""Street"") == 0 || strcmp(address,""Street"") != 0</code> which will result in <code>true</code> always.</p>

<p>try using this</p>

<pre><code>while((strstr(address,""Street"")==NULL || strlen(address)&gt;50 ));
</code></pre>
",0
26410000,26409706,0,"<p>try this</p>

<pre><code>while((strstr(address,""Street"")==NULL || strlen(address)&gt;50 ));
</code></pre>

<p><a href=""http://www.tutorialspoint.com/c_standard_library/c_function_strstr.htm"" rel=""nofollow"">http://www.tutorialspoint.com/c_standard_library/c_function_strstr.htm</a></p>
",0
29220348,29219852,2,"<p>First of all, you have not checked if there is a program argument. It should be routine to do this.</p>

<pre><code>if (argc &lt; 2)
    { /*error*/ }
</code></pre>

<p>You did not allocate enough memory for the <code>int[]</code> array. I would suggest either a <code>#define</code> to state the number of elements or a <code>const int</code>.</p>

<pre><code>#define ELEMS 5
</code></pre>

<p>Add to that, you've casted the return value from <code>malloc()</code> (unnecessary) but not checked the return value (necessary).</p>

<pre><code>addr = malloc(ELEMS * sizeof(int));
if (addr == NULL)
    { /*error*/ }
</code></pre>

<p>In both cases adding the code is simple compared to the grief it can otherwise cause.</p>
",1
26787051,26786980,0,"<p>I am interpreting the question to mean generate all numbers under 150 that could are perfect numbers.</p>

<p>Therefore, if your program works for calculating perfect numbers, you keep calculating them until the starting number is <code>&gt;= 150</code>.</p>

<p>Hope that makes sense.</p>
",4
26787354,26786980,1,"<p>Suppose you have a function which can tell whether a given integer is perfect or not:</p>

<pre><code>int isPerfect(int);
</code></pre>

<p>(function body not shown)</p>

<p>Now your main program will look like:</p>

<pre><code>int candidate;
int perfectNumbers;

for(candidate = 1, perfectNumbers = 0; perfectNumbers &lt; 150; candidate++) {
  if (isPerfect(candidate)) {
    printf(""Number %d is perfect\n"", candidate);
    perfectNumbers++;
  }
}
</code></pre>

<p><strong>EDIT</strong>
For the same program without functions:</p>

<pre><code>int candidate;
int perfectNumbers;

for(candidate = 1, perfectNumbers = 0; perfectNumbers &lt; 150; candidate++) {

  [... here your algorithm to compute the sum of the divisors of ""candidate"" ...]

  if (candidate*2 == sum_of_divisors) {
    printf(""Number %d is perfect\n"", candidate);
    perfectNumbers++;
  }
}
</code></pre>

<p><strong>EDIT2:</strong> Just a note on perfect numbers</p>

<p>As noted in the comments section below, perfect numbers are very rare, only 48th of them are known as of 2014. The sequence (<a href=""https://oeis.org/A000396"" rel=""nofollow"">A000396</a>) also grows very fast: using 64-bit integers you'll be able to compute up to the 8th perfect number (which happen to be 2,305,843,008,139,952,128). In this case the variable <code>candidate</code> will wrap around and start ""finding"" ""new"" perfect numbers from the beginning (until 150 of them are found: actually 19 repetitions of the only 8 findable in 64-bit integers). Note though that your algorithm must not choke on a <code>candidate</code> equals to <code>0</code> or to negative numbers (only to <code>0</code> if you declare <code>candidate</code> as <code>unsigned int</code>).</p>
",4
26788379,26786980,0,"<p>Well, here's my solution ..</p>

<p>First, you have to make a reliable way of getting divisors.<br>Here's a function I made for that:</p>

<pre><code>size_t
getdivisors(num, divisors)
    long long num;
    long long *divisors;
{
    size_t divs = 0;
    for(long long i = num; i &gt; 0; --i)
        if (num%i == 0)
            divisors[divs++] = i;
    return divs;
}
</code></pre>

<p>Second, you need to check if the number's divisors match the perfect number's divisors properties (the sum of them is half the number).<br>
Here's a second function for that:</p>

<pre><code>bool
isperfect(num)
    long long num;
{
    long long divisors[num/2+1];
    size_t divs = getdivisors(num, divisors);
    if (divs == 0)
        return false;
    long long n = 0;
    for(int i = 1; i &lt; divs; ++i)
        n += divisors[i];
    return (n == num);
}
</code></pre>

<p>Now, from your question, I think you need to print all perfect numbers less than 150, right ?<br>
See this:</p>

<pre><code>int
main(argc, argv)
    int argc;
    char ** argv;
{
    for(int i = 1; i &lt; 150; ++i)
        if (isperfect(i))
            printf(""%d is perfect.\n"", i);
    return 0;
}
</code></pre>

<p>I hope that answers your question ..</p>
",0
30698510,30698463,4,"<p>You forgot to reset the value of <code>arr-&gt;base</code> after the call to <code>realloc</code>.</p>

<p>Use:</p>

<pre><code>    p = (int *)realloc(arr-&gt;base, arr-&gt;max*2*sizeof(int));
    if(p != NULL){
        arr-&gt;max *= 2;  
        arr-&gt;base = p; // Missing line
        cout&lt;&lt;""reallocate successful base = "" &lt;&lt; arr-&gt;base &lt;&lt; endl;
    }else{
        cout&lt;&lt;""reallocate failed base = ""&lt;&lt; arr-&gt;base &lt;&lt;endl;
    }
</code></pre>
",0
26813318,26813290,3,"<p>Since you'v already pass the address as parameter into the function GetData, so you need to replace your function:</p>

<pre><code>int GetData (int* PR, int* IY, int* NY)
{
    printf(""Amount of the loan (Principle)? "");
    scanf(""%d"", PR);   //PR is the address already
    printf(""Interest rate / year (percent)? "");
    scanf(""%d"", IY);   //IY is the address already
    printf(""Number of years? "");
    scanf(""%d"", NY);   //NY is the address already
}
</code></pre>
",0
28211811,28211768,7,"<p><code>s</code> names the <code>struct stack</code> type. Not an instance of that type.</p>

<p>What you can do is:</p>

<pre><code>s a_stack;
</code></pre>

<p>and then use <code>&amp;a_stack.n</code></p>
",0
28211856,28211768,2,"<p><code>s</code> is a typedef which is not a variable of <code>struct stack</code> to access members in the structure. To access member variables, first declare a variable of type <code>s</code> and then access members in them. </p>

<pre><code>s variable;
scanf(""%d"",&amp;variable.n);
</code></pre>
",0
31804189,31803511,3,"<p>If you need to duplicate (copy) <code>ptr2</code>, you need to declare <code>ptr1</code> with the proper type, allocate room for the <code>ptr1</code> array, then copy <code>ptr2</code>'s contents over to <code>ptr1</code></p>

<pre><code>#include &lt;malloc.h&gt;
#include &lt;string.h&gt;

int *ptr2[(i-1)*100];
int **ptr1; // a pointer to a pointer to an int

ptr1 = malloc(sizeof(ptr2));
memcpy(ptr1, ptr2, sizeof(ptr2));
</code></pre>

<p><strong>Note</strong>: this is an example. Always make sure  <code>malloc</code> has allocated the memory block before using it and free it up when it's not needed anymore (use <code>free</code>)</p>

<p>On the other hand, if you just want to create an alias to <code>ptr2</code></p>

<pre><code>int *ptr2[(i-1)*100];
int **ptr1; // a pointer to a pointer to an int

ptr1 = ptr2;
</code></pre>
",4
31805150,31803511,0,"<p>You can use <a href=""http://man7.org/linux/man-pages/man3/memcpy.3.html"" rel=""nofollow""><code>memcpy</code></a> to copy values-</p>

<pre><code>int *ptr2[(i-1)*100];
int **ptr1;

prt1=malloc(sizeof(ptr2));     //also remember to free allocated memory.

memcpy(ptr1,ptr2,sizeof(ptr2));
</code></pre>
",7
30710668,30710065,0,"<pre><code>m0 = add(CurrentState[0], Branch[0]);
m1 = add(CurrentState[1], Branch[7]);
if(m0 &gt; m1) 
{
NextState[0] = m0;
SurvivorState[CurrentTrellis + 0] = 0;
}
else
{ 
NextState[0] = m1;
SurvivorState[CurrentTrellis + 0] = 1;
}
</code></pre>

<p>This repetitive part of code should become a function and the changing numbers (indices) should become its parameters. The variables <code>CurrentState</code>, <code>Branch</code>, <code>NextState</code>, <code>SurvivorState</code> and <code>CurrentTrellis</code> can become global variables or parameters, depending on their overall usage.</p>

<p>If there is a pattern for choosing the indices (I could not find any), you could call the function in a loop.</p>
",2
26804766,26804366,1,"<p>Let's make it more clear first. You have a void function, called <code>mark_function</code>, which takes 2 parameters. The first parameter is a void pointer and the second parameter is a pointer to a function that returns void and takes as a parameter a void pointer. Let's create a function that will be apropiate to pass as parameter to <code>mark_function</code>.</p>

<pre><code>void param(void *p) {
    // function body
}
</code></pre>

<p>Assume <code>a</code> and <code>b</code> are 2 void pointers. I will not enter into details about their scope, but you need to pay attention to it: they must be available in the scope they are used.
Then, the <code>mark_function</code> will be called as:</p>

<pre><code>mark_function(a, param);
</code></pre>

<p>Inside <code>mark_function</code> body you can have something like:</p>

<pre><code>param(b);
</code></pre>

<p>, which is a call to the function passed as a parameter.</p>

<hr>

<p>Long story short: the function pointers used as parameters are meant to make it possible for the function that requires them to perform different activities by calling different functions. The value of a pointer function is simply the name of a function that has the appropiate signature (return value and parameter list). Your function can use this to call the function provided as parameter as needed.</p>
",0
26804794,26804366,0,"<p>You should call the function with one pointer to an object, and one pointer to a function of suitable type.</p>

<pre><code>int my_int;

void mark_function(void *obj, void (*mark_obj)(void *));

void my_func (void *vp)
{
  /* Convert vp to a pointer to a real type */
  int *ip = vp;

  /* Do something with ip or *ip */
}

mark_function (&amp;my_int, my_func);
</code></pre>

<p>A pointer to object (<code>&amp;my_int</code>) can safely be convert to a <code>void *</code> and back to the same type. The resulting pointer is guaranteed to be identical to the original pointer. This allows <code>mark_function()</code> to perform some task regardless of the actual type that the pointer points to.</p>

<p>Typical examples of such tasks include sorting of arrays with a custom compare function provided by the caller, or maintaining linked lists without knowing the types of the object stored inside, an so on.</p>
",0
31896696,31896604,1,"<p>C Standard n1124 says</p>

<p><strong>¡ì</strong> 5.1.2.2.1 Program startup</p>

<blockquote>
  <p>The function called at program startup is named main. The
  implementation declares no prototype for this function. It shall be
  defined with a return type of int and with no parameters: int
  <code>main(void) { /* ... */ }</code> or with two parameters (referred to here as
  argc and argv, though any names may be used, as they are local to the
  function in which they are declared): </p>
</blockquote>

<pre><code>int main(int argc, char *argv[])
{ /* ... */ }
</code></pre>

<blockquote>
  <p>or equivalent;9) or in some other implementation-defined
  manner.</p>
</blockquote>

<p>Therefore it is undefined what has happened to your program as you do not obey the rules it should adhered to.</p>
",0
29187745,29187628,0,"<p>Both of these functions appear to have been deliberately written to be confusing, to the point where <em>I</em> am not 100% sure what they are supposed to do, or whether they actually do it.  So instead of explaining them, I am going to give you my own program that does what I <em>think</em> they are supposed to do, but in a less peculiar fashion:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

void reverse_word(void)
{
    int c = getchar();
    if (c == EOF)
        return;
    if (isspace(c)) {
        ungetc(c, stdin);
        return;
    }
    reverse_word();
    putchar(c);
}

void skip_whitespace(void)
{
    int c = getchar();
    if (c == EOF)
        return;
    if (!isspace(c)) {
        ungetc(c, stdin);
        return;
    }
    putchar(c);
}

int main(void)
{
    do {
        reverse_word();
        skip_whitespace();
    } while (!feof(stdin));
    return 0;
}
</code></pre>

<p>You will note that <code>reverse_word</code> and <code>skip_whitespace</code> are almost the same.  Ponder the differences to understand how <code>reverse_word</code> works.</p>

<pre><code>$ echo 'the quick brown fox jumps over the lazy dog' | ./a.out
eht kciuq nworb xof spmuj revo eht yzal god
</code></pre>
",0
29187714,29187628,1,"<p>Your first expression:</p>

<pre><code>return b = c &amp; '\n';
</code></pre>

<p>will assign the value of the expression<code>c &amp; '\n'</code> to variable <code>b</code> and return it. 
<code>c &amp; '\n'</code> is a bitwise operation, doing a logical AND operation on binary representations of <code>c</code> and <code>\n</code>. </p>

<p>To make it more illustrious, let's take the ASCII table and decode those chars:
<code>c</code> : decimal 99 -> binary 01100011
'\n' : decimal 10 -> binary 00001010</p>

<p>So we just <code>AND</code> them bit by bit, as a result we get <code>00000010</code>, which is decimal 2. The <code>b</code> variable is assigned that value, and the same value is returned. </p>

<pre><code>b + e ?: f(0);
</code></pre>

<p>is a ternary conditional statement, which will first check the logical value of <code>b+e</code> and if it evaluates to <code>true</code> will do nothing (as there is nothing before <code>:</code>), otherwise will call the function <code>f</code>. </p>
",1
27681263,27679518,1,"<p>When I compiled your code first time, I only got two warnings ¡ª that <code>argc</code> and <code>argv</code> to <code>main()</code> were unused.  That is well done ¡ª few programs presented on SO compile that cleanly.</p>

<p>I created a file <code>text.txt</code> containing:</p>

<pre><code>lol
abracadabra
a
a
d
d
d
a
d
c
</code></pre>

<p>When I ran the program, instrumented enough to print some information as it goes (and modified to terminate cleanly on EOF), I got:</p>

<pre><code>$ ./ht
Adding [lol]
Adding [abracadabra]
Adding [a]
Adding [a]
Adding [d]
Adding [d]
Adding [d]
Adding [a]
Adding [d]
Adding [c]
HASH_TABLE IS READY!!!!11111
Enter WORDS!!!1111
c
 KOLI4ESTVO!! [c] = 9
d
 KOLI4ESTVO!! [d] = 9
a
 KOLI4ESTVO!! [a] = 9
lol
 KOLI4ESTVO!! [lol] = 1
abracadabra
 KOLI4ESTVO!! [abracadabra] = 9
$
</code></pre>

<p>That's odd; I didn't create that many entries of any single word.  When run under <a href=""http://valgrind.org/"" rel=""nofollow""><code>valgrind</code></a>, there are many problems:</p>

<pre><code>==98849== Invalid write of size 4
==98849==    at 0x100001173: init (ht.c:49)
==98849==    by 0x1000019A9: main (ht.c:188)
==98849==  Address 0x10080b588 is 120 bytes inside an unallocated block of size 2,736 in arena ""client""
==98849== 
==98849== Invalid write of size 4
==98849==    at 0x100001180: init (ht.c:50)
==98849==    by 0x1000019A9: main (ht.c:188)
==98849==  Address 0x10080b58c is 124 bytes inside an unallocated block of size 2,736 in arena ""client""
==98849== 
Adding [lol]
==98849== Invalid read of size 4
==98849==    at 0x1000015C9: put (ht.c:89)
==98849==    by 0x1000019F1: main (ht.c:196)
==98849==  Address 0x10080b58c is 124 bytes inside an unallocated block of size 2,736 in arena ""client""
==98849== 
==98849== Invalid write of size 1
==98849==    at 0x1003FE3A0: _platform_memmove$VARIANT$Nehalem (in /usr/lib/system/libsystem_platform.dylib)
==98849==    by 0x1001B4113: strcpy (in /usr/lib/system/libsystem_c.dylib)
==98849==    by 0x10000175A: put (ht.c:91)
==98849==    by 0x1000019F1: main (ht.c:196)
==98849==  Address 0x10080b590 is 128 bytes inside an unallocated block of size 2,736 in arena ""client""
==98849== 
==98849== Invalid write of size 4
==98849==    at 0x10000175B: put (ht.c:93)
==98849==    by 0x1000019F1: main (ht.c:196)
==98849==  Address 0x10080b58c is 124 bytes inside an unallocated block of size 2,736 in arena ""client""
==98849== 
¡­and a whole lot more in a similar vein¡­
</code></pre>

<p>A quick look at <code>init()</code> shows some of the problem:</p>

<pre><code>struct HT* init(int size) // create a hash table
{
    struct HT* table = (struct HT*)calloc(sizeof(struct HT*),size);
    int i = 0;

    if (size &lt; 1)
        return NULL;

    if(NULL == table)
        return  NULL;

    for (i = 0; i &lt; size; ++i)
    {
        table[i].amount = 0;
        table[i].occup = 1;
    }
</code></pre>

<p>You've allocated an array of <code>size</code> pointers, but you try to use them as if you've allocated an array of <code>size</code> entries of <code>struct HT</code>.</p>

<p>At minimum, you need to write:</p>

<pre><code>    struct HT *table = (struct HT *)calloc(sizeof(*table), size);
</code></pre>

<p>This allocates an array of structures instead of an array of pointers.</p>

<p>Fixing that removes the <code>valgrind</code> errors.  The output is still not correct, though:</p>

<pre><code>$ ./ht
Adding [lol]
Adding [abracadabra]
Adding [a]
Adding [a]
Adding [d]
Adding [d]
Adding [d]
Adding [a]
Adding [d]
Adding [c]
HASH_TABLE IS READY!!!!11111
Enter WORDS!!!1111
a
 KOLI4ESTVO!! [a] = 9
lol
 KOLI4ESTVO!! [lol] = 1
abracadabra
 KOLI4ESTVO!! [abracadabra] = 9
b
 KOLI4ESTVO!! [b] = 9
c
 KOLI4ESTVO!! [c] = 9
d
 KOLI4ESTVO!! [d] = 9
e
 KOLI4ESTVO!! [e] = 0
antimony
 KOLI4ESTVO!! [antimony] = 0
$
</code></pre>

<p>I think I have established that the 9 is not a coincidence given that there are 10 lines in the data file.  When I reduced the data to 6 lines, with just <code>a</code> repeated, and the output was:</p>

<pre><code>$ ./ht
Adding [lol]
Adding [abracadabra]
Adding [a]
Adding [d]
Adding [a]
Adding [c]
HASH_TABLE IS READY!!!!11111
Enter WORDS!!!1111
a
 KOLI4ESTVO!! [a] = 5
d
 KOLI4ESTVO!! [d] = 5
c
 KOLI4ESTVO!! [c] = 5
abracadabra
 KOLI4ESTVO!! [abracadabra] = 5
lol
 KOLI4ESTVO!! [lol] = 1
$
</code></pre>

<p>I also tried a lot of lines (15) with a number of repeats, and the program crashed.  I think the numerology should give you some hints.  I'd not be surprised to find that the code that rebuilds the hash table has similar size bugs to the one in <code>init()</code>.</p>

<p>I think you need to create yourself a function that can print the details about and contents of the hash table so that you can use that to see what is being created.</p>
",0
27491033,27491002,2,"<ul>
<li><code>new</code>: <code>#define new(type) malloc(sizeof(type))</code> (have to call it using function syntax, like <code>struct stat *st = new(struct stat)</code>)</li>
<li>dynamically expanding arrays: <code>realloc</code> plus some custom array-manipulation functions (like <code>push_back</code>, etc.) - this is commonly implemented by third-party C utility libraries (and, as @Mgetz points out, some compilers have built-in extensions for it)</li>
<li>classes: structs with function pointer members (this is very common in several projects, such as the Linux kernel)</li>
</ul>

<p>You might want to look at GObject, which is a C library providing some object-oriented features to C.  Also see the dozens of hits you get for googling ""Object-Oriented C"".</p>
",5
27491082,27491002,-1,"<p>It depends if it is OK for you to reimplement the compiler.
If it's ok - you can do whatever you wish, otherwise:</p>

<p>new - as an operator - no, but you can define a function + macros that will simulate it.
classes - yep, you can. you may simulate it pretty closely with static functions and an array of pointers to functions. But there will be no overloading.
expanding arrays - yes, with the classes simulation above.</p>
",2
27491120,27491002,0,"<p>A quick google search revealed this:
<a href=""http://ooc-coding.sourceforge.net/"" rel=""nofollow"">http://ooc-coding.sourceforge.net/</a></p>

<p>Haven't read it through but it sounds like what you're after.</p>

<p>Yes, it is possible (common?) to implement object orientedness in C - or at least the bits that are especially needed. </p>

<p>An example is a once created a garbage collector by storing the pointers to malloced memory and the free function in linked lists.</p>

<p>The best thing about C is that it just works and there is almost zero overhead. The more work a language does for you automatically <em>can</em> mean there is a lot more overhead - though this is not always the case.</p>
",0
27556083,27555965,3,"<p>Just initialize the variables</p>

<pre><code>#include&lt;stdio.h&gt;
// program counts blanks, tabs, and new lines
int
main()
{
    int c;
    int blank, tab, newl;

    blank = tab = newl = 0;
    while((c = getchar()) != EOF) {
        // } if (c == '    ') { this is wong
        if (c == ' ') {
            ++blank;
        } else if (c == '\t') { // add else, you don't need to check this if the previous was true.
            ++tab;
        } else if (c == '\n') {
            ++newl;
        }
    }

    printf(""There are %d blank lines, %d tabs, and %d new lines\n"", blank, tab, newl);
    return 0;
}
</code></pre>
",1
27556432,27555965,4,"<p>Smaller, simpler version:</p>

<pre><code>int main()
{
    int c;
    int count[255] = {0};

    while((c = getchar()) != EOF)
    {
        count[c]++;
    }

    printf(""There are %d blank lines, %d tabs, and %d new lines\n"",
        count[' '],
        count['\t'],
        count['\n']);

    return 0;
}
</code></pre>
",0
27517508,27517484,8,"<p>You need to include the case in which the character satisfies neither condition:</p>

<pre><code>while (str[i])
{
  if (isupper(str[i])){
      c=str[i];
      putchar(tolower(c));
      i++;
  } else if (islower(str[i])){
      c=str[i];
      putchar(toupper(c));
      i++;
  } else {
      c=str[i];
      putchar(c);
      i++;
  }
}
</code></pre>

<p>Otherwise, the program gets ""stuck"" on the space, never advancing <code>i</code>, not printing out anything.</p>

<hr>

<p>This program can also be simplified. There's a lot of repetition as it currently stands. Here's a simpler version:</p>

<pre><code>char str[] = ""Test String"";

for (int i = 0; str[i]; i++)
{
    putchar(isupper(str[i]) ? tolower(str[i]) : toupper(str[i]));
}
return 0;
</code></pre>
",1
27517509,27517484,2,"<p>add </p>

<pre><code>else
{
    c=str[i];
    putchar(c);
    i++;
}
</code></pre>
",1
27532709,27532625,1,"<p>First you have to check that <code>fopen</code> succeeded</p>

<pre><code>failas = fopen(""nuskaitymas.txt"", ""r"");
if (failas == NULL)
    return -1;
</code></pre>

<p>then </p>

<pre><code>while (ch != '\n')
</code></pre>

<p>will never end replace it with</p>

<pre><code>if (ch == '\n')
    p++;
</code></pre>

<p>also, this is not right</p>

<pre><code>while (ch = fgetc(failas) != EOF)
</code></pre>

<p>it's because <code>!=</code> operator has higher precedence than <code>=</code> operator, so it will be evaluated first and then the result will be assigned to <code>ch</code>.</p>

<p>do it this way</p>

<pre><code>while ((ch = fgetc(failas)) != EOF)
</code></pre>

<p>And last but not least declare <code>ch</code> as <code>int</code> since <code>fgetc</code> returns <code>int</code>.</p>
",6
27532772,27532625,0,"<p>First of all, you need to close your file, so put the line</p>

<pre><code>fclose(failas);
</code></pre>

<p>at the end of your code.  Your next problem is how you are incrementing <code>p</code>.  Each time you go through the loop and <code>ch</code> is not <code>\n</code>, p gets increased.  if you have a large enough file, p will have problems because you will exceed the size of the integer.  change the inner loop to an <code>if</code> statement, like this:</p>

<pre><code>if(ch == '\n'){
  p++;
}
</code></pre>

<p>that should clear up all of your problems.</p>
",1
27745806,27744622,1,"<p>A couple things that might help;</p>

<ol>
<li><p>as others have suggested learn some debugging skills.  </p></li>
<li><p>learn about algorithms and how to estimate the run-time complexity. </p></li>
<li><p>In your second example you have the code shown below (comments are mine).  In this code you are trying to determine if <code>i</code> is a prime or not by looking for factors of the number.  If <code>i</code> is set to five, then the while loop assigns these values to <code>j</code>: [2, 3, 4, 5] and we then perform the following 
modulus operations: <code>5%2, 5%3, 5%4</code> and <code>5%5</code>.  You do not really need to test if <code>i</code> is divisible by itself (isn't that what a prime is?  only divisible by 1 and itself).  You will need to rework the following logic a bit, but you get rid of one modulus operation per iteration through the outer-loop.</p>

<pre><code>    for (i=m; i&lt;=n; i++)           // outer loop
    {
        while (j&lt;=i)               // inner loop
        {
            if (i%j==0)            // does this work as intended?
                counter++;
            j++;
        }
</code></pre></li>
<li><p>Considering the same loop, lets see what happens if <code>m</code> is 100 (this means that <code>i</code> will start at 100).  What your inner loop will do is calculate the remainder of dividing the test number (<em>i.e.</em> <code>i</code>) by every number in the range [2,100].  The first modulus operation (100 % 2) will return 0, so we immediately know that 100 is a composite number.  At this point, there is no reason to continue to perform additional tests.  To fix the issues that I've brought up in point 3 and 4, you can rewrite the inner loop as (I've move the initialzation of <code>j</code> to the top of the inner loop, and introduced a new variable, <code>isPrime</code>):</p>

<pre><code>    bool     isPrime;
    for (i=m; i&lt;=n; i++)           // outer loop
    {
        j = 2;
        isPrime = true;
        while (j &lt; i)               // range of j is now [2, i)
        {
            if (i%j==0)             // number is a composite
            {            
                isPrime = false;
                break;
            }
            j++;
        }

        if(isPrime)            // never found a divisor
        {
             printf (""%d\n"",i);
        }
    }   
</code></pre></li>
<li><p>Notice that in points 3 and 4, all I did was ask what happens with small input and see what happens looking for logic errors.</p></li>
<li><p>Consider doing something other than a brute-force method.  In the problem, you are told <code>1 &lt;= m &lt;= n &lt;= 1000000000, n-m&lt;=100000</code>, so there is probability that you may need to determine if a large number of test cases are prime (<em>i.e.</em> n-m = 100,000) or are working with very large test-cases (<em>i.e.</em> n = 1,000,000,000).  Given these extremes a brute-force method may be very computationally expensive.  To see this consider that <code>m = 999,900,000 and n = 1,000,000,000</code> is a valid range.  This means you might need to look at other methods for primality testing.</p></li>
<li><p>Don't give up.  Programming is an intellectual exercise, and the only way to get better is to practice, try things, learn from your mistakes (and there will be many).  This is really the only way to get better at programming </p></li>
</ol>
",1
29912502,29912401,2,"<p>Try calculating the powers first using <code>pow()</code> from <code>math.h</code> and then:</p>

<p>You can use %10f to precede the number with blanks in the example total of 10 spaces:</p>

<pre><code>printf (""Preceding with blanks: %10f \n"", 10000.01);
</code></pre>

<p>Source: <a href=""http://www.cplusplus.com/reference/cstdio/printf/"" rel=""nofollow"">cplusplus.com</a></p>
",4
29912627,29912401,1,"<p>Try this example code</p>

<pre><code>float y[7]={0.000100f,0.0010f,0.0100,0.1000f,1.0f,10.000f,100.00f};
int a[7]={-4,-3,-2,-1,0,1,2};
for(int i=0;i&lt;7;i++)
    printf(""%2d%20f\n"",a[i],y[i]);
</code></pre>

<p>Output will like that.</p>

<p><img src=""https://i.stack.imgur.com/kNcNR.jpg"" alt=""enter image description here""></p>
",2
29912632,29912401,2,"<p>Basicly you can use variable length to perform this:</p>

<pre><code>printf(""%d %.*lf"", kPower, -kPower, raisePower);
</code></pre>

<hr>

<p>Advantage over other methods is that this method does not need any extra buffer(s) </p>
",0
29913089,29912401,3,"<pre><code>#include &lt;stdio.h&gt;

char *get_number_formatted(double f)
{
    static char buf[128]; // this function is not thread-safe
    int i, j;

    i = snprintf(buf, 128, ""%20.10f"", f) - 2;

    for (j = i - 8; i &gt; j; --i)
        if (buf[i] != '0')
            break;

    buf[i + 1] = '\0';
    return buf;
}

int main(void)
{
    int i;
    for (i = -4; i &lt; 5; ++i)
        printf(""%5d %s\n"", i, get_number_formatted(pow(10.0, i)));
   return 0;
}
</code></pre>

<p><a href=""http://ideone.com/KBiSu0"" rel=""nofollow"">http://ideone.com/KBiSu0</a></p>

<p>Output:</p>

<pre><code>   -4         0.0001
   -3         0.001
   -2         0.01
   -1         0.1
    0         1.0
    1        10.0
    2       100.0
    3      1000.0
    4     10000.0
</code></pre>

<p><code>printf()</code> cannot print a variating length of decimal digits, so basically what I did was print the formatted number into a buffer and then cut the exceeding zeros.</p>
",0
29913112,29912401,2,"<p>With a little help of <code>modf</code>, you can use <code>%g</code> to skip the trailing zeroes and <code>\b</code> to skip the leading zero:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main(void)
{
    int i, iarr[] = {-4, -3, -2, -1, 0, 1, 2, 3, 4};
    double darr[] = {0.0001, 0.001, 0.01, 0.1, 1., 10., 100., 1000., 10000.};
    double intpart, fractpart;

    for (i = 0; i &lt; 9; i++) {
        fractpart = modf(darr[i], &amp;intpart);
        if (fractpart == 0.0)
            printf(""%10d%10d.0\n"", iarr[i], (int)intpart);
        else
            printf(""%10d%10d\b%g\n"", iarr[i], (int)intpart, fractpart);
    }
    return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>    -4         0.0001
    -3         0.001
    -2         0.01
    -1         0.1
     0         1.0
     1        10.0
     2       100.0
     3      1000.0
     4     10000.0
</code></pre>
",0
29913138,29912401,1,"<p>You can use <code>sprintf</code> and then trim the zeros. This is the same idea as @Havenard's answer, but writing spaces over the zeros instead of cutting the string.
And my C-style is somewhat different FWIW. My style is that I don't want to count or do any arithmetic in my head; that's what the C optimizer is for :).</p>

<pre><code>#include &lt;math.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
    int kPower;
    for(kPower=-4; kPower&lt;5; kPower++){
        enum { bufsize = 2+5+10+1+4+1+1 };
        char buf[bufsize];
        int j,n,i;
        double raisePower = pow(10,kPower);
        //printf(""%2d     %10.4f\n"",kPower,raisePower);
        snprintf(buf,bufsize,""%2d     %10.4f\n"",kPower,raisePower);
        j=strchr(buf,'.')-buf;
        j+=1;
        n=strchr(buf+j,'\n')-buf;
        for (i=n-1; i&gt;j; i--)
            if (buf[i]=='0')
                buf[i]=' ';
            else
                break;
        printf(""%s"",buf);
    }   
    return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>-4         0.0001
-3         0.001 
-2         0.01  
-1         0.1   
 0         1.0   
 1        10.0   
 2       100.0   
 3      1000.0   
 4     10000.0   
</code></pre>
",0
28248769,28248734,1,"<pre><code>firstBand = scanf("" %c"",&amp;firstBand);
</code></pre>

<p><code>firstband</code> is a character read and scanf() returns number of elements successfully read.</p>

<p>So <code>firstBand</code> is no more a char which you have scanned and it is actually the value of number of elements read.</p>

<pre><code>if(scanf("" %c"",&amp;firstBand) == 1)
printf(""%c"",firstBand);
</code></pre>
",0
28248820,28248734,0,"<p>Change all of your scanf statements from</p>

<pre><code>firstBand = scanf("" %c"",&amp;firstBand);
</code></pre>

<p>to</p>

<pre><code>scanf("" %c"",&amp;firstBand);
</code></pre>

<p>That should fix it.</p>
",0
28476109,28475427,4,"<p><strong>Its very tough to get some clocks needed for some instructions. Because it depends upon a lot of factors as CPU clock Frequency, No of CPU cores, Processor Architecture(How memory cache are assigned), instruction scheduling, and branch prediction,instructions executed before your measured instruction(s), etc.</strong></p>

<p>If you need to measure very short time intervals or you need extremely high precision in your figures,you can resort to platform-dependent resources.</p>

<p>Every CPU manufacturers include some clock counters(REGISTERS) and these are incremented for every lapsed clock on that CPU core. So you can access these REGISTER(s) if your CPU allowed(Manufacturer dependent) and calculate much more precise execution time.
Example: The most renowned counter register is the TSC (timestamp counter), introduced in x86 processors with the Pentium and present in all CPU designs ever since¡ªincluding the x86_64 platform. It is a 64-bit register that counts CPU clock cycles; it can be read from both kernel space and user space.</p>

<pre><code>&lt;asm/msr.h&gt;
unsigned long start, stop;
rdtscl(start); 
//Your measured code here
rdtscl(stop);
printk(""Time Taken: %li\n"", stop- start);
</code></pre>

<p><em>Even its also not perfect because there are some clock cycles lapsed in reading these registers, but anyhow we can't remove it.</em></p>

<p>For more info you can see link provided by @Daniel. and <a href=""http://www.makelinux.net/ldd3/chp-7-sect-1"" rel=""nofollow"">http://www.makelinux.net/ldd3/chp-7-sect-1</a></p>
",0
28475826,28475427,-3,"<p>Instead Use <code>gettimeofday()</code>. </p>

<p><code>clock()</code> time granularity is not enough probably.</p>
",8
28475839,28475427,6,"<p>The short answer for why your code isn't working is that your program executes too quickly. <code>CLOCKS_PER_SEC</code> is usually defined so that each tick is equal to one microsecond (<code>CLOCKS_PER_SEC</code> equals 1 million) - a single addition operation takes <em>far</em> less than that. In fact, on my machine I had to execute several million instructions before I was able to get a non-zero measurement.</p>

<p>There's no standard way in C to measure the length of a single add instruction. You can use the <a href=""http://en.wikipedia.org/wiki/Time_Stamp_Counter"" rel=""nofollow"" title=""rdtsc"">rdtsc</a> instruction in modern x86 processors to measure CPU clock cycles, though even then precision is not guaranteed.</p>
",0
28464196,28464073,1,"<p>1) free (p_cmd);</p>

<p>2) p_cmd = NULL;</p>

<p>E.g.:</p>

<pre><code>  void cleanup( command_t* p_cmd )
  {
      if( p_cmd )
      {
          free (p_cmd);
          p_cmd = NULL;
      }
  }
</code></pre>
",0
28466311,28464073,0,"<p>This is the naive answer. It assumes that command was allocated with a single <code>malloc()</code> or <code>strdup()</code>...</p>

<pre><code>void cleanup(command_t *command) {
    free(command);
}
</code></pre>

<p>As a matter of style I would call your function something like <code>free_command()</code> or <code>destroy_command()</code> and keep it near to the functions that allocates the memory in the first place. E.g...</p>

<pre><code>typedef char command_t;

command_t *create_command_from_stdin(int line_length) {
    command_t *command = malloc(line_length + 1);
    fgets(command, line_length, stdin);
    command[line_length] = '\0';
    return command;
}

void free_command(command_t *command) {
    free(command);
}
</code></pre>

<p>You cannot free something twice without trouble. If you fail to free something <code>malloc()</code>'d then you get a memory leak. To avoid this, you often keep the create and free functions in the same scope so you don't lose track of them...</p>

<pre><code>void shell(void) {
    while(true) {
        command_t *command = create_command(80);
        do_something_with_command(command);
        do_insane_things_with_command(command);
        free_command(command);
    }
}

void do_something_with_command(const command_t *command) { ... }

void do_insane_things_with_command(const command_t *command) { ... }
</code></pre>

<p>The <code>const</code> tag will protect you from accidently freeing them inside the functions and also acts as a hint to others that these functions do not take ownership of the command. That is, they do not take on the responsibility of freeing the memory.</p>

<p>yours, Marcus</p>
",0
28444445,28444376,1,"<p>You have a buffer overflow here</p>

<pre><code>A[i][j] = A[i+1][j+1];
</code></pre>

<p>you need to iterate to <code>i &lt; M - 1</code> and <code>j &lt; N - 1</code>.</p>

<p>You are accessing invalid memory which explains the observed values, that also invokes undefined behavior so you could observe some strange behavior eventually.</p>
",1
28444706,28444376,3,"<p>By far the easiest way to do what you want is:</p>

<pre><code>void LeftShift2D(int A[M][N])
{
    int i;
    int temp = A[0][0];
    int *base = &amp;A[0][0];
    for (i = 0; i &lt; M * N - 1; i++)
        base[i] = base[i+1];
    A[i] = temp;
}
</code></pre>

<p>This treats the array as a vector and shifts the data down one space, rotating the value originally at the start to the end.  If you wanted to rotate each row separately, you'd use different code, more closely related to what you show:</p>

<pre><code>void LeftShift2D(int A[M][N])
{
    int temp;
    for (int i = 0; i &lt; M; i++)
    {
        int j;
        int temp = A[i][0]
        for (j = 0; j &lt; N - 1; j++)
            A[i][j] = A[i][j+1];
        A[i][j] = temp;
    }
}
</code></pre>

<p>Your code has various problems.  The <code>A[i][j] = A[i+1][j+1];</code> assignment accesses data out of bounds, and copies data 'diagonally', copying the cell to the bottom-right (or south-east) of the current cell, not the cell to the right (east) of the current cell.  It has problems wrapping, too.</p>
",0
28466757,28466715,21,"<p>When creating a file, you need a third parameter to open (the <code>mode</code>). If you don't do this, unpredictable things happen.</p>

<p>Also, if you want to create a file if it's not there, you will need <code>O_CREAT</code> or'd in, i.e.</p>

<pre><code>fd = open(tmpname, O_WRONLY | O_APPEND | O_CREAT, 0644);
</code></pre>

<p><code>O_CREAT</code> (roughly speaking) creates the file if it isn't present.</p>

<p>From the man page:</p>

<pre>
NAME
       open, creat - open and possibly create a file or device

SYNOPSIS
       #include 
       #include 
       #include 

       int open(const char *pathname, int flags);
       int open(const char *pathname, int flags, mode_t mode);

       int creat(const char *pathname, mode_t mode);

...
       O_CREAT
              If the file does not exist it will be created.  The owner (user ID) of
              the  file  is  set to the effective user ID of the process.  The group
              ownership (group ID) is set either to the effective group  ID  of  the
              process  or  to  the  group  ID  of the parent directory (depending on
              filesystem type and mount options, and the mode of the  parent  direc©\
              tory,  see  the  mount  options  bsdgroups and sysvgroups described in
              mount(8)).

              mode specifies the permissions to use in case a new file  is  created.
              This  argument must be supplied when O_CREAT is specified in flags; if
              O_CREAT is not specified, then mode is ignored.  The effective permis©\
              sions  are  modified by the process's umask in the usual way: The per©\
              missions of the created file are (mode & ~umask).  Note that this mode
              applies  only to future accesses of the newly created file; the open()
              call that creates a read-only file may well return a  read/write  file
              descriptor.

</pre>
",5
28499909,28499731,1,"<p>I am modifying your code by adding one more variable <code>TempAlarmTriggered</code> and initializing it with zero.</p>

<pre><code>if (DU_Reason.bits.EmergencyDialIn) {                       
    if (Send_Update) {
        Compose_Report();
        GSM_Send_Text_Sms (GSM_Tx_Buff, SenderNum);
        num_Leaks_month = 0;    
        monthly_timer = 0;
        Send_Update = 0;
        DU_Reason.bits.EmergencyDialIn = 0;
    } 
    else if ((TempAlarm) &amp;&amp; (TempAlarmTriggered == 0)) {
        TempAlarmTriggered  = 1;
        Compose_Temp_Report();
        GSM_Send_Text_Sms (GSM_Tx_Buff, SenderNum); 
        DU_Reason.bits.EmergencyDialIn = 0;
    } 
    else {
        Compose_Leak_Report();
        GSM_Send_Text_Sms (GSM_Tx_Buff, SenderNum); 
        DU_Reason.bits.EmergencyDialIn = 0;
    }    
</code></pre>

<p>When your temp resets clear both <code>TempAlarmTriggered</code>  and <code>TempAlarm</code>.</p>
",0
28531420,28530300,2,"<h1>Take a look at <a href=""http://www.cprogramming.com/tutorial/modulus.html"" rel=""nofollow"">Modulus Operand in C</a></h1>

<p>Here's what's wrong with the program:<br>
Let's look at this calculation: <code>b = a % 50;</code><br>
This gives us: <code>100 % 50 = 0;</code> (if we say the input is 100).<br>
And when you try to take modulus of b what happens is this: <code>c = b % 10;</code><br>
This will leave you with <code>0 % 10 = 0</code><br>
You're trying to find out what the remainder of 100 divided by 50 is, which is zero.  </p>

<p>To solve this (Using your assignment):<br>
Step 1. Divide input by the amount of 100 (representing 100 dollar bills).<br>
Step 2. Now take modulus of your input and the amount of 100 - and then divide it by the amount of 50 (representing 50 dollar bills). </p>

<p>Here's an example for better understanding:<br>
Let's say the amount you want change from is 285, then:<br>
<code>285 / 100 = 2</code> (This should be 2.85, but since you're using integers you can't represent decimals)  </p>

<p>Next up:<br>
<code>285 / 100 = 2</code><br>
<code>285 % 100 / 50 = 1</code><br>
<code>285 % 100 % 50 / 20 = 1</code><br>
<code>285 % 100 % 50 % 20 / 1 = 15</code>  </p>

<p><code>&lt;start value&gt; % &lt;previous compare value&gt; / &lt;newest compare value&gt;</code></p>

<p>This results in:<br>
100 dollar bills: 2<br>
50 dollar bills: 1<br>
20 dollar bills: 1<br>
1 dollar bills: 15<br>
Which amounts to 285 dollars.</p>

<h1>Solution:</h1>

<pre><code>#include &lt;stdio.h&gt;      
#include &lt;stdlib.h&gt;    

int main(){     
int a, b, c, d, e;      

printf(""Enter the change amount in Dollars: "");    
scanf(""%d"", &amp;a);      

b = a/100;      
c = (a%100)/50;     
d = (a%100%50)/20;     
e = (a%100%50%20)/1;       

printf(""Number of 100 Dollar bills = %d \n"", b);    
printf(""Number of 50 Dollar bills = %d \n"", c);    
printf(""Number of 20 Dollar bills = %d \n"", d);    
printf(""Number of 1 Dollar bills = %d \n"", e);    

return(0);     
}
</code></pre>

<h1>Tips:</h1>

<p>Arrange your C code in a good manner, if you're starting with C and want to have other people help you or collaborate with other programmers you should improve the way you set up your commands.<br>
Take a look at the Solution i posted and see how i separated the calculations and print functions. This will help readability and set you on a path to do good programming!<br>
If posting on Stackoverflow.com please try to use as much time as possible to explain your problem and preferably your code and it's purpose!  </p>
",0
32467985,32467839,4,"<p>Here is your problem</p>

<pre><code>int main(void);
</code></pre>

<p>Please remove the final <code>;</code> since you are declaring a function prototype, not a function implementation. So, the following statements are out of context, because they are not within the body of any function.</p>
",0
29173544,29173437,2,"<p>This should be on the CodeReview site, but to start with you have a problem in your initial input loop</p>

<pre><code>while(!(start&lt;6));
</code></pre>

<p>Will allow the user to enter a value like -1,234,567, so it needs to be</p>

<pre><code>while(start &lt; -5 || start &gt; 5);
</code></pre>

<p>That said, in the simplest form you just need an <code>if</code> statement</p>

<pre><code>if (start &gt; 0)
{
    // code to count down
}
else if (start &lt; 0)
{
    // code to count up
}
else
{
    print(""All Done""); // user entered zero
}
</code></pre>
",0
29175490,29173437,1,"<p>Try this example:</p>

<pre><code>#include &lt;stdio.h&gt;
int main()
{
    int start = -6;
    int increment;

//Asking for user input -5 to +5
    while(start &lt; -5 || start &gt; 5)
    {
        printf(""Enter number to start the countdown (1 - 5): "");
        scanf(""%d"",&amp;start);
    }

    increment = (start &lt; 0) ? +1 : -1;
//while the number is not just past zero
    while(start != increment)
    {
        printf(""%d\n"",start);
        start += increment;
    }
    return 0;
}
</code></pre>
",0
29208070,29207876,0,"<p>Do like this.</p>

<pre><code> int a[5][5];

 for ( i=0; i &lt; rows ; i ++) 
      for ( j=0; j &lt; cols ; j++ ) 
             printf(""%d\t"",a[i][j]);
</code></pre>
",0
29208171,29207876,2,"<p>Each method here assumes that your <code>matrix</code> variable contains an array of rows (each inner array represents a row of your matrix).</p>

<h2>Using pointer-to-pointer</h2>

<p>You could do it like this:</p>

<pre><code>void display(int** matrix,int rows, int cols) {
   int i,j;
   for(i=0; i &lt; rows; i++) {
       for(j=0; j &lt; cols; j++) {
           printf(""%d\t"", matrix[i][j]);
       }
       printf(""\r\n"");
   }
}
</code></pre>

<p>To initialize the matrix, you could do something like this:</p>

<pre><code>int** matrix;
int i,j;
int rows = 4, columns = 2;
matrix = (int**)malloc(rows*sizeof(int*));
for(i=0; i&lt;4; i++) {
matrix[i] = (int*)malloc(columns*sizeof(int));
for(i=0; i&lt;4; i++) {
   for(j=0; j&lt;2; j++) {
      matrix[i][j] = i+j;
   }
}
</code></pre>

<h2>Using 2D-arrays</h2>

<p>You could do it like this, note that this only works with the current <code>C99</code> standard:</p>

<pre><code>void display(int rows, int cols, int matrix[rows][cols]) {
    int i,j;
    for(i=0; i &lt; rows; i++) {
        for(j=0; j &lt; cols; j++) {
            printf(""%d\t"", matrix[i][j]);
        }
        printf(""\r\n"");
    }
}
</code></pre>

<p>You can call the function like this:</p>

<pre><code>int matrix2[4][2];
for(i=0; i&lt;4; i++) {
    for(j=0; j&lt;2; j++) {
        matrix2[i][j] = i+j;
    }
}
display(4, 2, matrix);
</code></pre>

<h2>Using 1D-array</h2>

<p>As suggested in the comments, you can make your life much easier by simply using unbounded 1D-arrays and using a helper to access your matrix:</p>

<pre><code>int elementAt(int matrix[], int x, int y, int columns) {
    return matrix[x*columns+y];
}

void display(int rows, int cols, int matrix[]) {
    int i,j;
    for(i=0; i &lt; rows; i++) {
        for(j=0; j &lt; cols; j++) {
            printf(""%d\t"", elementAt(matrix, i, j, cols));
        }
        printf(""\r\n"");
    }
}
</code></pre>

<p>You would call this like so:</p>

<pre><code>int matrix3[] = {1,2,3,4,5,6,7,8};
display(4, 2, matrix3);
</code></pre>
",8
33038572,33037895,0,"<p>I do not know if you would like this, but another way you can do this will be to accept inputs like you punch in calculators, and parse to int before applying the operations on them.</p>

<p>Something like this</p>

<pre class=""lang-c prettyprint-override""><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main ()
{
    char buffer[256];
    char * pch;

    printf(""input your numbers in this format ${number1}+${number2}...: "");
    fgets (buffer, 256, stdin);

    int sum = 0;
    pch = strtok (buffer, ""+"");
    while (pch != NULL)
    {
        sum += atoi (pch);
        pch = strtok (NULL, ""+"");
    }
    printf(""the sum is %\n"", sum);
    return 0;
}
</code></pre>

<p>so, run it and input 2+2+2 and it does the calculation for you. thanks</p>
",4
29467271,29467239,3,"<p>You are printing the wrong variable:</p>

<pre><code>total=power(first,second); //here you are getting return value in variable total
printf(""The value for power is %d"",power);  // power is the function name not variable
</code></pre>

<p>Replace this line with:</p>

<pre><code>printf(""The value for power is %d"",total);  // you need to print `total`  
</code></pre>

<p>Also you have to declare your function prototype before <code>main()</code>:</p>

<pre><code>int power(int ,int);
</code></pre>

<p>and you should use <code>int main()</code>:</p>

<pre><code>int main()
{
    // your code
    return 0;
}
</code></pre>
",0
29467856,29467239,1,"<p>In addition to passing <code>total</code> to <code>printf</code> instead of <code>power</code>, as you are just starting, make a point to always give your variables an initial value (initialize them). This prevents an attempt to read from uninitialized space which is the bane of new C programmers. (it will save you a lot of headaches). Attempting to read from an uninitialized variable is <strong>Undefined Behavior</strong>. That can result in anything from slipping by unnoticed, to causing your program to crash. It is to be avoided.</p>

<p>Also, as I explained in the comment, in C, the function <code>main()</code> is type <code>int</code> and it returns a value to its caller (usually the shell, or another program). When using <code>main</code> without arguments, the proper form is:</p>

<pre><code>int main (void)
</code></pre>

<p>When accepting arguments, the proper form is:</p>

<pre><code>int main (int argc, char **argv)
</code></pre>

<p>In either case, it should return a <strong>positive</strong> value upon completion. A <code>return 0;</code> at the end is all that is required. <code>exit (0);</code> is another function you can use to return a value. You will also see the form of <code>main</code> with arguments written as:</p>

<pre><code>int main (int argc, char *argv[])
</code></pre>

<p>The first and second forms are the practical equivalents of each other, the first recognizing that an array passed to a function in C will decay to a pointer. But for now, just understand that they are equivalent.</p>

<p>You also have an error in your <code>my_power</code> calculation. <code>int temp = doom1;</code> should be <code>int temp = 1;</code> Your calculation was returning a value twice the actual product.</p>

<p>Your style of syntax is up to you, but I would suggest that expanding your syntax a little by using discretionary spaces and lines will make your code much more readable and make finding errors a bit easier. Here is an example regarding all of these points:</p>

<pre><code>#include &lt;stdio.h&gt;

int my_power (int doom1, int doom2);

int main (void)
{
    int first = 0;      /* Always initialize your variable to prevent */
    int second = 0;     /* an inadvertant read from an unitialized    */
    int total = 0;      /* value which is Undefined Behavior (bad).   */

    printf (""\n enter the value for the first : "");
    scanf (""%d"",&amp;first);

    printf ("" enter the value for the second: "");
    scanf (""%d"",&amp;second);

    total = my_power (first,second);

    printf (""\n The value for my_power is: %d\n\n"", total);

    return 0;
} 

int my_power (int doom1, int doom2)
{
    int temp = 1;
    int i = 0;

    for (i = 1; i &lt;= doom2; i++)
        temp = doom1 * temp;

    return temp;
}
</code></pre>

<p><strong>Output</strong></p>

<pre><code>$ ./bin/simple_function

 enter the value for the first : 2
 enter the value for the second: 7

 The value for my_power is: 128
</code></pre>
",3
29468957,29467239,0,"<p>you are trying to print ""power"" without parameter</p>

<pre><code>printf(""The value for power is %d"",power);
</code></pre>

<p>you should do </p>

<pre><code>printf(""The value for power is %d"",total);
</code></pre>

<p>or </p>

<pre><code>printf(""The value for power is %d"",power(first,second));
</code></pre>
",0
29187938,29187684,2,"<p><code>int a[i];</code> is creating an array of arbitrary size since i is not initialized.</p>

<p>Instead, you can dynamically create the equivalent of an array of int once you know total_number.</p>

<pre><code>int* a;

. . . snip . . .

/* once you know total_number */

a = (int*) malloc(total_number, sizeof(int));

/* you can use a with array notation as long as you stay in bounds */

a[i] = something;

/* don't forget to free a when you are done */

free(a);
</code></pre>
",0
29188532,29187684,3,"<p>The segmentation fault is caused by this line:</p>

<pre><code>scanf(""%d"",total_number);
</code></pre>

<p>You're missing the address of (&amp;) operator, it should be like this:</p>

<pre><code>scanf(""%d"",&amp;total_number);
</code></pre>

<p>The operator is also missing in this line:</p>

<pre><code>    scanf(""%d"",a[i]);
</code></pre>

<p>You can find more details on scanf in the <a href=""https://www.gnu.org/software/libc/manual/html_mono/libc.html#Formatted-Input"" rel=""nofollow"">glibc manual</a>:</p>

<blockquote>
  <p>Another area of difference between scanf and printf is that you must remember to supply pointers rather than immediate values as the optional arguments to scanf; the values that are read are stored in the objects that the pointers point to. Even experienced programmers tend to forget this occasionally, so if your program is getting strange errors that seem to be related to scanf, you might want to double-check this. </p>
</blockquote>

<p>But there are other subtle errors in your code, too: the fact the int i in array[i] is not initialized leads to undefined behaviour i.e., anything could happen. You can use malloc to allocate space for the array, but a simple reordering could be enough:</p>

<pre><code>scanf(""%d"",&amp;total_number);
int a[total_number];
</code></pre>

<p>Uses user input to allocate the array.</p>

<p>Lastly, it seems like you're trying to implement an insertion sort algorithm, but the logic is slightly flawed: even correcting the bugs in the code the input </p>

<pre><code>1 3 5 0
</code></pre>

<p>gets ""ordered"" to</p>

<pre><code>1 5 3 0
</code></pre>

<p>But I don't know what you were trying to implement. In case you were actually trying to implement insertion sort, you could use the pseucode from the <a href=""https://en.wikipedia.org/wiki/Insertion_sort#Algorithm"" rel=""nofollow"">insertion sort</a> wiki article to get an idea of what's missing in your implementation.</p>
",0
30178487,30178409,1,"<p>You are well on your way!  Here are some recommended adjustments:</p>

<p>First, <code>char ch</code> should be <code>int ch</code>.  Take a look at the manual page for <code>fgetch</code> and you will find that it returns an <code>int</code>.  This is actually pretty important, because the EOF returned will be out of range for a <code>char</code> but in range for an <code>int</code>.</p>

<p>Next, you could simplify a bit.  Why not:</p>

<pre><code>while((ch = fgetc(ptr)) != EOF)
{
  printf(""%c"", (char)ch);
}
</code></pre>

<p>This moves your logical test and your read into a single line, eliminating the two lines that currently have the <code>fgetch</code> in them.</p>

<p>Finally, you should <code>#include&lt;ctype.h&gt;</code> since that is the header file where <code>int toupper(int)</code> is defined.</p>
",3
32419199,32419181,2,"<p>Very simple: use <a href=""http://linux.die.net/man/3/sprintf"" rel=""nofollow"">""sprintf()""</a> instead of ""printf()"" to do formatted output to a string.  </p>

<p>You don't need ""strcpy()"", and you <em>can't</em> use strcpy with formatting commands.</p>

<p>EXAMPLE:</p>

<pre><code>/* The exact same output will go to your terminal as to the string ""actualResult"" */
printf(""Q3: Result from func(x, y) = %d and mac(x, y) = %d."", p, q);
sprintf(actualResult, ""Q3: Result from func(x, y) = %d and mac(x, y) = %d."", p, q);
</code></pre>
",3
29143055,29141977,0,"<p>Change your 'printf' function, like above this, and you will receive your missing variables. </p>

<pre><code>int sk,a=0,b=0,c=0;
printf (""Write number: "");
scanf(""%d"", &amp;sk);

while (sk != 0) {
  if (sk%10 == 0){
    a++;
  }
  else if (sk%2 == 0){
    b++;
  }
  else {
    c++;
  }

  sk = sk/10;
}
printf("" Zeros %d \n Evens %d \n Odss %d \n Without Zeros: %d \n Without Odds: %d \n"",a , b, c, b+c, a+b);
</code></pre>
",3
29143836,29141977,1,"<p>This may help :)</p>

<pre><code>int sk,a=0,b=0,c=0;

int cnt_a=1,cnt_b=1,cnt_c=1;

printf (""Write number : "");
scanf(""%d"", &amp;sk);

while (sk != 0){
    if (sk%10 != 0){
        a = a + (sk%10 * cnt_a);
        cnt_a *= 10;
    }
    if (sk%2==0){
        b = b + (sk%10 * cnt_b);
        cnt_b *= 10;
    }
    else {
        c = c + (sk%10 * cnt_c);
        cnt_c *= 10;
    }
    sk = sk/10;
}
printf("" Without Zeros : %d \n Only Evens : %d \n Only Odds : %d "", a , b, c);
</code></pre>
",0
29185477,29185362,0,"<p>A loooooooong time ago I developed an algorithm like the one you have, maybe it can help you.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

long Solutions;

void AllocBoard(int *** Board, int Queens)
    {
    int i;

    *Board = (int **)malloc(sizeof(int *) * Queens);

    for(i = 0; i &lt; Queens; i++)
        {
        (*Board)[i] = (int *)malloc(sizeof(int) * Queens);
        memset((*Board)[i], 0, sizeof(int) * Queens);
        }
    }

void DeallocBoard(int *** Board, int Queens)
    {
    int i;

    for(i = 0; i &lt; Queens; i++)
        free((*Board)[i]);

    free(*Board);
    }

void SavePosition(int *** Board, int Queens, int Col, int Row, int Inc)
    {
    int i, j;

    for(i = 0; i &lt; Queens; i++)
        {
        if((*Board)[Col][i] &gt;= 0) (*Board)[Col][i] += Inc;
        if((*Board)[i][Row] &gt;= 0) (*Board)[i][Row] += Inc;
        }

    for(i = Col, j = Row; j &lt; Queens &amp;&amp; i &lt; Queens; i++, j++)
        if((*Board)[i][j] &gt;= 0) (*Board)[i][j] += Inc;

    for(i = Col, j = Row; j &gt;= 0 &amp;&amp; i &gt;= Col; i--, j--)
        if((*Board)[i][j] &gt;= 0) (*Board)[Col][j] += Inc;

    for(i = Col, j = Row; j &gt;= 0 &amp;&amp; i &lt; Queens; i++, j--)
        if((*Board)[i][j] &gt;= 0) (*Board)[i][j] += Inc;

    for(i = Col, j = Row; j &lt; Queens &amp;&amp; i &gt;= Col; i--, j++)
        if((*Board)[i][j] &gt;= 0) (*Board)[i][j] += Inc;
    }

void FindSolutions(int *** Board, int Queens, int Col)
    {
    int i, j;

    for(i = 0; i &lt; Queens; i++)
        {
        if((*Board)[Col][i] != 0) continue;

        (*Board)[Col][i] = -1;
        if(Col + 1 == Queens)
            Solutions++;
        else
            {
            SavePosition(Board, Queens, Col, i, 1);
            FindSolutions(Board, Queens, Col + 1);
            SavePosition(Board, Queens, Col, i, -1);
            }

        (*Board)[Col][i] = 0;
        }
    }

void main(int argc, char **argv)
    {
    int Queens, ** Board = NULL;
    clock_t Start, End;

    clrscr();
    if(argc &lt; 2)
        Queens = 8;
    else
        Queens = atoi(argv[1]);

    Solutions = 0;

    Start = clock();
    AllocBoard(&amp;Board, Queens);
    FindSolutions(&amp;Board, Queens, 0);
    DeallocBoard(&amp;Board, Queens);
    End = clock();

    printf(""Solutions %ld\n"", Solutions);
    printf(""Estimated time: %f"", (End - Start) / CLK_TCK);
    getch();
    }
</code></pre>

<p>Hope this helps</p>
",0
29185594,29185362,0,"<p>Asking ""why it doesn't work"" about short and simple programs is not very well. Try debug it yourself with any debugger or simply using printing in important places/on each step. Actually, C has no arrays, instead it has pointers. You can work with them very alike, that is why all you need is to change <code>int board[4][4]</code> to <code>int **board</code> and add one argument: <code>int N</code>(count of cells) and that's all. All your other code shouldn't be changed.</p>
",0
29185685,29185362,0,"<p>You should initialize your <code>board</code>. As is, you start with a board full of garbage values. You are using a variable-length array as board. Such arrays cannot be initialized, so you have to set the board to all zero with a loop or with <code>memset</code> from <code>&lt;string.h&gt;</code>:</p>

<pre><code>int board[n][n];

memset(board, 0, sizeof(board));
</code></pre>

<p>You can pass variable-length arrays to functions when the dimensions are passed in as earlier arguments, for example:</p>

<pre><code>int GetQueenSettings(int n, int board[n][n], int currentRow) { ... }
</code></pre>

<p>Also fix the <code>=</code>/<code>==</code> switch in <code>setInvalid</code>:</p>

<pre><code>    if (board[row][i] == 0)
        board[row][i] = -(1 + currentRow);
</code></pre>

<p>Finally make sure that all functions have proper prototypes when they are called.</p>
",1
29165193,29165148,2,"<p><strong>Point 1.</strong> With a definition like</p>

<pre><code>char a[5];
</code></pre>

<p>using</p>

<pre><code>while (a[5]!=EOF)
</code></pre>

<p>invokes <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behaviour</a>.
You're facing off-by-one error. Remember, array index in c starts from 0. The valid access it at most upto <code>a[4]</code>.</p>

<hr>

<p><strong>Point 2.</strong>  <code>fscanf(file1, ""%s"", a);</code> is unsafe. It can cause buffer overflow. Atleast, you need to write</p>

<pre><code> if ( fscanf(file1, ""%4s"", a) != 1)
 {
         //scanning not successful, take necessary measures
 }
 //otherwise, continue nomal execution.
</code></pre>

<hr>

<p><strong>Point 3.</strong> The logic for <code>while</code> loop is not correct. You don't have a <code>break</code> condition there.</p>

<hr>

<p><strong>Point 4.</strong> <code>c+=b;</code>, here <code>c</code> is used uninitalized. <em>read-before-write</em> scenario. Again, <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behaviour</a>. Remember, <code>auto</code> local variables doesnot get initialized to <code>0</code> or some value automatically. You've to initialize explicitly.</p>

<hr>

<p><strong>Point 5.</strong> Do not continue normal execution if <code>if (file1==NULL)</code> condition satisfies. Only printing a message is not sufficient. You should discontinue the program and avoid using <code>file1</code>, <code>file1</code> etc.</p>

<hr>

<p><sup>Credits for point 5: <a href=""https://stackoverflow.com/users/4402433/user4402433"">user4402433</a></sup></p>
",0
29165616,29165148,0,"<p>Include <code>return</code> in the file check as </p>

<pre><code>if (file1==NULL)
{
    puts("" File not exisiting\n"");
    return 0;
} 
</code></pre>

<p>as there is no use of proceeding with the code if any one of the file is opened.
  Also initialize the value of <code>c=0;</code> before while so that any garbage value can be avoided.    </p>

<p>The array <code>a[]</code> has to be indexed to update the file content. So place the </p>

<pre><code>fscanf(file1, ""%s"", a[i]); 
</code></pre>

<p>inside the <code>for()</code> loop . This is to avoid buffer overflow which occurs in rare cases.</p>
",3
31192141,31192078,0,"<p>The reason why it does not work is because if you do add the ! in the if statement, only the non matching characters in a are printed, but not b. Just add a line: <code>printf(""%c"", b1[b])</code>. </p>
",0
31193160,31192078,1,"<p>This is correct and pretty efficient, even for far longer strings.  It prints the results in collation order, however, which may or may not be suitable.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include &lt;limits.h&gt;

int main(){
    char a[50];
    char b[50];
    int a_chars[UCHAR_MAX + 1] = {0};
    int b_chars[UCHAR_MAX + 1] = {0};
    int i;

    clrscr();
    printf(""Enter any value here\n"");
    scanf(""%49s%*[^\n]"",&amp;a);
    printf(""Enter any value here\n"");
    scanf(""%49s%*[^\n]"",&amp;b);

    for (i = 0; a[i]; i++) {
        a_chars[(unsigned char) a[i]] = 1;
    }
    for (i = 0; b[i]; i++) {
        b_chars[(unsigned char) b[i]] = 1;
    }
    for (i = 1; i &lt;= UCHAR_MAX; i++) {
        if (a_chars[i] ^ b_chars[i]) {
            putchar(i);
        }
    }
    putchar('\n');

    getch();
    return 0;
}
</code></pre>

<p>It scans each string to record a table of which characters it contains, then scans the two tables to find the characters in one but not the other.</p>

<p>Also, unlike your code, it adapts to the actual length of the input strings, up to the maximum allowed (49 characters), and does not produce undefined behavior in the event that the user enters longer strings.  In the event that the user provides longer strings, the excess characters are ignored.</p>
",6
31192495,31192078,0,"<p>There are several possible methods, depending on what you mean by finding ""the non-matching characters between them."" If you want to find all characters that are in either <code>a</code> or <code>b</code> but not in both, a simple (but not optimal) approach is:</p>

<ol>
<li>Create an array <code>c</code> of all characters that are in both of the arrays (union).</li>
<li>Loop through <code>a</code> and find all characters that are not in <code>c</code>.</li>
<li>Loop through <code>b</code> and find all characters that are not in <code>c</code>.</li>
</ol>

<p>For example:</p>

<p>Here's one way:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
int main( int argc, char **argv )  {

   char a[50];
   char b[50];
   char unmatched[100];
   int lena, lenb, i;
   int numUnmatched = 0;
   printf(""Enter any value here\n"");
   scanf(""%s"",a);
   printf(""Enter any value here\n"");
   scanf(""%s"",b);
   lena = strlen(a);
   lenb = strlen(b);
   unmatched[0] = '\0';
   for(i=0; i&lt;lena; i++) {
      if ( !strchr( b, a[i] ) ) {
         if ( ! strchr(unmatched, a[i]) ) {
            unmatched[numUnmatched++] = a[i];
         }
      }
   }
   for(i=0; i&lt;lenb; i++) {
      if ( !strchr( a, b[i] ) ) {
         if ( ! strchr(unmatched, b[i]) ) {
            unmatched[numUnmatched++] = b[i];
         }
      }
   }

   for ( i=0; i &lt; numUnmatched; i++ ) {
      printf( ""%c "", unmatched[i] );
   }
   printf( ""\n"" );
   return EXIT_SUCCESS;
}
</code></pre>
",0
29223773,29223695,1,"<p>Plain <code>strcpy</code> will copy character by character until it encounters a null character (x'00'). If your string does not end with a null it will continue copying until it either hots a null by accident or reaches the end of the memory you are allowed to address.</p>

<p>Switch to  <code>strncpy</code> where you can specify the max length to be copied.</p>

<p>Also are you sure you will actually encounter a ""next == NULL"" condition.</p>
",1
29245819,29245724,1,"<p>You cannot do it this way.  <code>index</code> must be updated in the parent as well.</p>

<p>Try this method instead:</p>

<pre><code>int inorderCli(clientes t, int index, char a[]) {
    if (t != NULL) {
      index = inorderCli(t-&gt;esq, index, a);
      if (a) strcpy(a + index, t-&gt;cli);
      index = inorderCli(t-&gt;dir, index + 5, a);
    }
    return index;
}
</code></pre>

<p>and call this function from your <code>main</code> like this:</p>

<pre><code>int size = inorderCli(client_root, 0, NULL);
char *a = malloc(size);
inorderCli(client_root, 0, a);
</code></pre>

<p>Notice how calling with <code>NULL</code> computes the size needed for the output array.</p>
",0
29447396,29447390,6,"<p>Remove the semicolon from here:</p>

<pre><code>for(i=0;i&lt;7;i++);
</code></pre>

<p>The semicolon makes the <code>for</code> loop have an empty body. It makes it equivalent to</p>

<pre><code>for(i=0;i&lt;7;i++){}
</code></pre>

<p>Including warning flags in your compiler(<code>-Wextra</code> in GCC) emits a warning about these kind of issues.</p>
",0
29447464,29447390,2,"<p>Semicolon (<strong>;</strong> ) punctuation mark in C means that block of code is finished. That means if you use</p>

<pre><code>for(i=0;i&lt;7;i++);
    {
        x++;
    }
</code></pre>

<p>For loop ends before it reaches brackets. Then code between your brackets runs like normal lines out of loop. If you want your loop to include brackets, get rid of the semicolon, like:</p>

<pre><code>for(i=0;i&lt;7;i++)
    {
        x++;
    }
</code></pre>
",0
29442788,29442720,1,"<p>It isn't too difficult, just check the first character of <code>TOKEN</code> against a list of <code>vowels</code>. Something similar to:</p>

<pre><code>void printlatinwork (char *TOKEN)
{
    char *vowels = ""aeiouAEIOU"";

    if (strchr (vowels, *TOKEN))
        printf (""%sway"", TOKEN);
    else
        printf (""%s%c%s "", TOKEN + 1, TOKEN[0], ""ay"");
}
</code></pre>

<p><strong>Note:</strong> requires <code>string.h</code></p>

<p>If you need a version that does not rely on any additional header, something like this will work as well:</p>

<pre><code>void printlatinwork (char *TOKEN)
{
    char *vowels = ""aeiouAEIOU"";
    char firstisvowel = 0;
    char *v = vowels;

    while (*v)
        if (*TOKEN == *v++)
            firstisvowel = 1;

    if (firstisvowel)
        printf (""%sway"", TOKEN);
    else
        printf (""%s%c%s "", TOKEN + 1, TOKEN[0], ""ay"");
}
</code></pre>
",1
29481654,29481566,0,"<p>Can I suggest you another way to print your entire file ?</p>

<p>Replace your function readDataFile() with this :</p>

<pre><code>void readDataFile(){

  int   nbread;
  int   fd;
  char  buf[2048];

  fd = open(""text.txt"", O_RDONLY);
  while ((nbread = read(fd, buf, 2048)) != 0)
    {
      buf[nbread] = '\0';
      printf(""%s\n"", buf);
    }
}
</code></pre>

<p>And don't forget to add the library fcntl at the beginning of your file :</p>

<pre><code>#include &lt;fcntl.h&gt;
</code></pre>

<p>Good luck ! :)</p>
",0
29481672,29481566,0,"<p>fgets() takes in a line at a time and stores it in the string provided as the first argument. It looks like you are iterating through every line of the file and printing a single character from it. What you should try is:</p>

<pre><code>while((fgets(text, LENGTH, fp)) !=NULL){
    printf(""%s"", text);
}
</code></pre>
",2
29900460,29900419,3,"<pre><code>#define ABS(x) (((x)&lt;0)?(-(x)):(x))
</code></pre>

<p>(Or as correctly pointed out, there's the built-in <code>abs()</code> in <code>stdlib</code>).</p>
",4
29900472,29900419,7,"<p>Assuming that <code>x</code> is an <code>int</code> variable, <code>printf(""%d"", x&lt;0 ? -x : x)</code> prints <code>x</code> without a sign for all values except <code>INT_MIN</code> on a 2's complement platform.</p>

<p>R.. below has suggested:</p>

<pre><code>printf(""%u"", (unsigned) (x&lt;0 ? (-1 - x) + 1 : x);
</code></pre>

<p>¡­ because that handles <code>INT_MIN</code> too for any reasonable platform.</p>
",4
32430932,32430891,1,"<p>It simply converts the number to its hex representation by taking the quotient (<code>&gt;&gt;4</code>) and remainder (<code>&amp;0xF</code>) and using them as indices in an array of hex characters (<code>""0123456789abcdef""</code>). And it does it for the 20 numbers in the <code>hash</code> array.</p>
",3
32431055,32430891,1,"<p>You don't need to store the hash in a variable, because it's saved already in a variable inside of your Sha1 object. The function <code>Sha1.resultHmac()</code> will return an pointer to an array of 20 elements:</p>

<pre><code>Sha1.initHmac(hmacKey, 20);
Sha1.print(""Test"");
uint8_t* hash = Sha1.resultHmac(); // the variable hash[] has 20 fields, from hash[0]...hash[19]
</code></pre>

<p>To compare the hash later with a second hash, you can write an simple function like this:</p>

<pre><code>int compareHash(uint8_t* hash1, uint8_t* hash2) {
  int retVal = 1;
  for (size_t i=0; i&lt;20; i++) {
    if(hash1[i] != hash2[i]){
      retVal = 0;
      break;
    } 
  }
  return retVal;
}
</code></pre>

<p>Which will return 0 if the hashes are different or 1 if they are identical.</p>
",2
32461689,32461626,2,"<p>When you use:</p>

<pre><code>scanf( ""%c"", &amp;letter );
</code></pre>

<p>you end up reading even newline characters into <code>c</code>. Use:</p>

<pre><code>scanf( "" %c"", &amp;letter );
//     ^^^^ add a space before %c.
</code></pre>

<p>Use of <code>"" %c""</code> will make sure that all whitespace characters are skipped and only a non-whitespace character will be read into <code>c</code>.</p>
",6
32461711,32461626,2,"<p>Usually you want to add a space before the %c to eat up the white spaces:</p>

<pre><code>scanf( "" %c"", &amp;letter );
</code></pre>

<p>See there for more information: <a href=""https://gsamaras.wordpress.com/code/caution-when-reading-char-with-scanf-c/"" rel=""nofollow"">https://gsamaras.wordpress.com/code/caution-when-reading-char-with-scanf-c/</a></p>
",0
30146028,30145988,0,"<p>First get file name:</p>

<pre><code>char name[100] = {0};
fgets (name, 100, stdin);
</code></pre>

<p>Then create text file:</p>

<pre><code>// Open as text file
FILE *f = fopen(name, ""w"");
if (f == NULL)
{
    printf(""Error opening file!\n"");
    exit(1);
}

// write some text 
const char *text = ""Write this to the file"";
fprintf(f, ""Some text: %s\n"", text);

fclose(f);
</code></pre>
",1
30408407,30408392,4,"<p>Use <code>%lf</code> in the <code>scanf</code> since <code>a</code> and <code>b</code> are of type <code>double</code>. </p>

<p><code>%d</code> is for integer input.</p>
",0
30408408,30408392,2,"<p><code>%d</code> means to read an <code>int</code>.  <code>%f</code> will let you read a <code>float</code> type.  So change that in your <code>scanf</code> and you should be set</p>
",1
33826269,33826060,1,"<p>Recursion for the win :-)</p>

<ul>
<li>the combinations of 1 digit is <code>1</code></li>
<li>the combinations of <code>N</code> digits is the <em>recursive</em> combinations of <code>N - 1</code> digits with <code>N</code> added at every possible place</li>
</ul>
",0
33826207,33826060,0,"<p>try to think of an algorithmn before you actually try to write the code. 
Think of how you solved the Problem in your head when you wrote your desired output down. just find a systematic way to do this: for example you start with the lowest number and then check for the other numbers...</p>
",0
31139996,31138835,1,"<p>The program as given in the book is an example of what not to do:</p>

<p>Don't try to access a value through a pointer when the pointer is not a pointer to the same type as the original value.</p>

<p>In the book, <code>i</code> is an <code>int</code>, but the code deliberately makes a <code>char*</code> point to the integer. So, when <code>ii</code> is dereferenced you just get a value that seems to be a <code>char</code>.</p>

<p><strong>edit:</strong> So, the expression <code>(char*)&amp;i;</code> first takes the address of <code>i</code>, which the compiler thinks of as type <code>int*</code> and then converts the type to <code>char*</code> without changing the value of the pointer.</p>

<p>The important thing to note about the different types of pointers is that they often imply a different size of object pointed to.</p>

<p>Also note that the output of all the whole program will depend on the platform you are using.</p>
",1
31192092,31191949,0,"<p>You are not seeing any issue by removing \n because '\n' is a new line character.
So previously your output was 
**""Hello World</p>

<p>""** (newline)
And now your output is 
<strong>""Hello World""</strong>
That's why you don't see any difference.</p>
",0
31192175,31191949,4,"<p><strong>Case 1:</strong> your book is wrong. Removing <code>\n</code> will never raise any error. <code>\n</code> means <a href=""https://en.wikipedia.org/wiki/Newline"" rel=""nofollow noreferrer"">newline</a> which will print a new line after <em>Hello World</em>.</p>

<p><strong>Case 2:</strong> May be you are not building the code again, because without including the <code>stdio</code> (means standard input/output) you may not invoke <code>printf()</code> function if you use newer C standards (C99, C11). Read more about <a href=""https://en.wikipedia.org/wiki/C_file_input/output"" rel=""nofollow noreferrer"">stdio.h</a>.</p>

<p>Note that, in pre C99 standard if you remove the prototype (<code>#include &lt;stdio.h&gt;</code>) C will automatically provide an implicit declaration for a function. Which will look like this:</p>

<pre><code>int printf();
</code></pre>

<p>means, it will take any number of arguments and return <code>int</code>. But in C99 implicit deceleration were removed. So most probably your compiler does not confront C99. </p>

<p>Take a look <a href=""http://ideone.com/SDhIdh"" rel=""nofollow noreferrer"">here</a>, compile fine!</p>

<p>Read more about <a href=""https://stackoverflow.com/questions/9182763/implicit-function-declarations-in-c"">implicit declarations in c</a>.</p>

<p><strong>EDIT:</strong> As AnT mentioned in the comment, removing <code>#include&lt;stdio.h&gt;</code>, the call to printf will ""compile"" in pre-C99 version of language. However, the call will produce undefined behavior. Variadic functions (like printf) have to be declared with prototype before the call even in C89/90. Otherwise, the behavior is undefined.</p>
",2
31192921,31191949,2,"<ol>
<li><p>Your program already contains an error. Functions in modern C have to be declared with an explicitly specified return type. Your <code>main()</code> is declared without a return type, which has been illegal since C99.</p>
</li>
<li><p>There are different kinds of &quot;errors&quot;. Some errors cause compiler to issue a diagnostic message. Some errors simply make your program behave unpredictably at run time (exhibit undefined behavior). The latter might be harder to detect, since &quot;unpredictable&quot; might look perfectly fine on the first sight.</p>
<p>In your case removing <code>#include &lt;stdio.h&gt;</code> will trigger a diagnostic message in C99-compiliant compiler, but will lead to mere undefined behavior in C89/90 compiler. Undefined behavior might still produce the same screen output as before.</p>
</li>
</ol>
",2
31192569,31191949,0,"<p>The reason for not getting an error while removing <code>\n</code> is because it is an <a href=""https://en.wikipedia.org/wiki/Escape_sequences_in_C"" rel=""nofollow"">escape equence</a> that denotes a newline character. Adding or removing escape sequence would not result in error until and unless other part of code is not affected. For example if you remove only <code>\</code> from <code>\n</code>, this would result in error since your <code>""</code> would be escaped as <code>\""</code>.</p>

<p>For the second case, either you are not building the code again before running it or your IDE would be setting it by itself. Removing the <code>#include</code> line would result in error since your <code>printf()</code> function is declared in the <code>stdio.h</code> header file. Without the function declaration, calling a fucntion would result in an error.</p>

<hr>

<p>If you are using any shell, it would be better if you write your code in a text editor and compile it using gcc in shell as:</p>

<pre><code>gcc filename.c
</code></pre>

<p>The executable would be named by default as <code>a.out</code>. More about <code>gcc</code> can be read using <code>man gcc</code>.</p>
",0
31192641,31191949,0,"<p>Case 2:</p>

<p>Without the <code>printf()</code> prototype in <code>#include&lt;stdio.h&gt;</code>, many compliers use a pre-C99 standard.  That assumes the function has the prototype of <code>int printf(...)</code> where all arguments, including the format go through the <em>usual</em> argument promotions with no type checking.  Since code passed the expected format parameter and and <code>int</code> was returned, code worked.  Had code been <code>printf(5.0)</code>, it likely would compile but crash on execution.</p>
",0
31193064,31191949,0,"<p>Removing the ""\n"" from the "" Hello world \n"" won't produce any errors, but it <em>MAY</em> produce a different result on execution. Depending on the operating system, it may write nothing until the next time a ""\n"" is sent to stdout, or until the output buffer flushes.</p>
",0
31243251,31241580,0,"<p>Also, check if file you are opening opens correctly or not.</p>

<pre><code>...
if (f == NULL) {
    perror(""new1.c"");
    return 1;
}
...
</code></pre>

<p><strong>EDIT</strong> The file name in your code looks like you are trying to open a C code. Give correct name if it doesn't already have.</p>
",3
31243157,31241580,2,"<p>The warnings <em>and</em> the crash is because you haven't included the correct header files.</p>

<p>Before the C99 standard, compilers were allowed to guess the prototype of undeclared functions when it found one, and while compilers often gets the arguments correct the return type will always be <code>int</code>.</p>

<p>Now take your call of <code>fopen</code>, the compiler will guess that the arguments are two constant strings (<code>const char *</code>), but the return type will be <code>int</code> and not <code>FILE *</code> as expected. This will cause problems because a signed integer and a pointer is not the same thing, and if you're on a 64-bit platform where pointers are 64 bits and <code>int</code> is usually 32 bits, you will have major problems. All this leads to <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow""><em>undefined behavior</em></a> which is a common cause for crashes.</p>

<p>To solve your problems, both the warnings and the crashes, you need to <code>#include</code> the correct header files. For the file functions (<code>fopen</code>, <code>printf</code> etc.) it's <code>&lt;stdio.h&gt;</code>, for the string functions (e.g. <code>strtok</code>) it's <code>&lt;string.h&gt;</code>.</p>

<p><strong><em>Always</em></strong> include the header proper header files. If you don't know which header file to include for the standard functions, search e.g. <a href=""http://en.cppreference.com/w/c"" rel=""nofollow"">this excellent reference site</a>.</p>
",0
31230779,31230478,0,"<p><code>2 10</code> is the input, not the output.</p>

<p>You have to read both numbers at once to have them in the same line:</p>

<pre><code>printf(""ent two nos.\n"");
scanf(""%d %d"",&amp;n1, n2);
</code></pre>

<p>Now you have to enter your numbers separated by a space and not by an enter.</p>
",0
32451929,32451832,0,"<p>The parenthesis evaluate the expression. Consider:</p>

<pre><code>int a = (2, 4);
</code></pre>

<p>This sets <code>a</code> equal to the result of the evaluating the expression <code>2, 4</code>.</p>

<p>Your next question is probably what the <a href=""https://en.wikipedia.org/wiki/Comma_operator"" rel=""nofollow"">comma operator</a> does. It evaluates the first expression, throws the result away, evaluates the second expression, and then the expression evaluates to the type and value of that second expression. So the expression <code>2, 3</code>evaluates to 3.</p>
",1
32452023,32451832,1,"<pre><code>int a=1,3,15;
</code></pre>

<p>is not allowed:</p>

<pre><code>prog.c: In function ¡®main¡¯:
prog.c:2:13: error: expected identifier or ¡®(¡¯ before numeric constant
     int a=1,3,15;
</code></pre>

<p>This is because it is parsed as a list of declarations, the items being <code>a=1</code>, <code>3</code>, and <code>15</code> (and <code>3</code> is not a valid variable name).</p>

<p>If you write</p>

<pre><code>int a;
a = 1,3,15;
</code></pre>

<p>that is parsed as <code>(a = 1), 3, 15;</code> because <code>=</code> binds tighter than <code>,</code>.</p>

<p>On the other hand,</p>

<pre><code>int b=(1,2,4);
</code></pre>

<p>declares a single variable <code>b</code> initialized from the expression <code>(1,2,4)</code>. The parens are simply for grouping.</p>

<p><code>,</code> (comma) is an operator that evaluates (and throws away the result of) its left operand, then evaluates and returns its right operand. So <code>b</code> ends up being <code>4</code> (and some compilers will warn about ignoring the values of <code>1</code> and <code>2</code>).</p>
",0
32452037,32451832,0,"<pre><code>int a=1,3,15;
</code></pre>

<p>is not valid, at least a diagnostic has to generated and the compiler to refuse to translate the code. </p>

<pre><code>int b=(1,2,4);
</code></pre>

<p>is valid and equivalent to:</p>

<pre><code>int b=4;
</code></pre>

<p>The comma expression <code>(1, 2, 4)</code> is equivalent to <code>((1, 2), 4)</code> and evaluates to <code>4</code>.</p>
",0
31256632,31254380,3,"<p>This is a tricky question, something that needs probably more depth than a StackOverflow answer. I'll try, nonetheless.</p>

<p>Tokenizing the input is the <a href=""https://en.wikipedia.org/wiki/Lexical_analysis"" rel=""nofollow"">first part of the compilation process</a>. The objective is to simplify the task of the parser, which is going to make an abstract syntax tree with the contents of the file. How do we simplify this? We do recognize those tokens that have a special meaning, also identifiers, operators... C is indeed a tricky, complex language. Let's simplify the language to tokenize: we'll start with a typical calculator.</p>

<p>An input example would be:</p>

<pre><code>( 4 +5)* 2
</code></pre>

<p>When syntax is free, you can add or skip spaces, so as you have already experimented, splitting by space is not an option.</p>

<p>The tokenized output for the example above would be: LPAR, LIT, OP, LIT, RPAR, OP, LIT. The meaning goes as follows:</p>

<pre><code>LPAR: Left parenthesis
RPAR: Right parenthesis
LIT:  Literal (a number)
OP:   Operator (say: +, -, * and /).
</code></pre>

<p>The complete ouput would therefore be:</p>

<pre><code>{ LPAR, LIT(4), OP('+'), LIT(5), RPAR, OP('*'), LIT(2) }
</code></pre>

<p>Your lexer basically has to advance in the input string, char by char, using a state machine. For example, when you read a number, you enter in the ""input literal"" state, in which only other numbers and '.' are allowed.</p>

<p>Now the parser has an easier task. If you feed it with the previous tokens, it does not have to skip spaces, or distinguish between a negative number and a minus operator, it can just advance in a list or array. It can behave following the type of the token, and some of them have associated data, as you can see.</p>

<p>This is only an introduction of the introduction, anyway. Information about <a href=""https://en.wikipedia.org/wiki/Compiler"" rel=""nofollow"">the whole compilation process</a> could fill a book. And there are actually many books devoted to this topic, such as the famous ""<a href=""http://www.amazon.es/dp/0201101947/"" rel=""nofollow"">Dragon book</a>"" from Aho, Sethi&amp;Ullman. A more updated one is the ""<a href=""http://www.amazon.es/dp/0521607655/"" rel=""nofollow"">Tiger book</a>"".</p>

<p>Finally, lexers are quite similar among each others, and it is therefore possible to find <a href=""http://www.cs.princeton.edu/~appel/modern/c/software/flex/flex.html"" rel=""nofollow"">generic lexers</a> out there. You can also even find the <a href=""http://www.lysator.liu.se/c/ANSI-C-grammar-l.html"" rel=""nofollow"">C grammar</a> for that kind of tools.</p>

<p>Hope this (somehow) helps.</p>
",0
31895929,31285658,0,"<p>Declare <code>ch</code> as a global variable.</p>

<p>The following program will change all uppercase letters to lower case and all lower case letters to upper case.</p>

<p>Your program needed few modifications to get the desired result.I have made the required changes.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;

void chaCap(char ch);
char ch;

int main()
{

  printf(""Enter Sentence\n"");

  while((ch=getchar()) != '\n')
  {
   chaCap(ch);
    printf(""%c"",ch);
  }
  printf("" \n"");

  return 0;
}
void chaCap(char ch)
{
  if(ch &gt;= 'a' &amp;&amp; ch &lt;='z')
     ::ch=ch-32;
  else if(ch&gt;='A'&amp;&amp;ch&lt;='Z')
     ::ch=ch+32;
}
</code></pre>
",0
31287228,31285658,2,"<p>you need to return value in function <code>chaCap(char n)</code>,</p>

<pre><code>char chaCap(char n)//need to return char instead of void
{
  if(n &gt;= 'a' &amp;&amp; n &lt;='z')
      n-=32;
  return n; // return capital letter here
}
</code></pre>

<p>and then get return value when call it in <code>main()</code>,</p>

<pre><code>int main()
{
  //... 
  while((ch=getchar()) != '\n')
  {
    a = chaCap(ch); // get return value
    printf(""%c"",a);
  }

}
</code></pre>
",0
31287084,31285658,2,"<p>Use the <strong>tolower()</strong> function :</p>

<pre><code>  while((ch=getchar()) != '\n')
  {
    printf(""%c"", tolower(ch));
  }
</code></pre>
",0
31290393,31285658,1,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;

char *strlwr(char *str){
    char *s;
    for(s = str; *s; ++s){
        if(isupper(*s))
            *s = tolower(*s);
    }
    return str;
}

char *strupr(char *str){
    char *s;
    for(s = str; *s; ++s){
        if(islower(*s))
            *s = toupper(*s);
    }
    return str;
}

char *strvrs(char *str){
    char *s;
    for(s = str; *s; ++s){
        if(islower(*s))
            *s = toupper(*s);
        else if(isupper(*s))
            *s = tolower(*s);
    }
    return str;
}

int main(void){
    int ch;
    size_t i = 0, size = 32;
    char *str = malloc(size);

    printf(""Enter Sentence\n"");

    while((ch=getchar()) != '\n' &amp;&amp; ch != EOF){
        str[i++] = ch;
        str[i++] = '\0';
        if(i-- == size){
            char *temp = realloc(str, (size += 32));
            if(!temp){
                fprintf(stderr, ""realloc error\n"");
                free(str);
                exit(EXIT_FAILURE);
            }
            str = temp;
        }
    }
    printf(""original   : %s\n"", str);
    printf(""vice versa : %s\n"", strvrs(str));
    printf(""upper      : %s\n"", strupr(str));
    printf(""lower      : %s\n"", strlwr(str));
    free(str);

    return 0;
}
</code></pre>
",0
31298985,31298732,7,"<p>You don't have a prototype for <code>int round_near(float b)</code>, so you're relying on implicit declarations.</p>

<p>Try adding this to your code.</p>

<pre><code>int round_near (float b); // Prototype

int main(void) // Nitpick: main returns an int!
</code></pre>

<p>Using implicit declarations for <code>round_near(b)</code>, <code>b</code> is being promoted to a <em>double</em>.  But the definition assumes it's a <em>float</em>, which has a different binary layout, so you get crazy random results.</p>

<p>You should make sure your code compiles without any warnings to avoid this sort of stuff.  The only reason implicit declaration is in the language is for backwards compatibility, but every compiler for the last decade or two warns you that it's bad on compile.</p>
",5
31299127,31298732,-2,"<p>Output like -241... instead of 1 or 2 usually denote uninitialized integers... 
However, your code compiles just fine with GNU C compiler (gcc) on Linux, only after either moving the <code>round_near</code> function BEFORE the <code>int main()</code> or simply inserting a blank definition of that function (as <code>int round_near(float b);</code>) before the <code>int main()</code> -- that is ""prototyping"". </p>

<p>Otherwise, your function will be ""seen"" as <code>int round_near()</code> (see the lack of argument definition) and hence the uninitialized integers printed out by the program. </p>

<p>On the other, such a practice won't produce portable code, so without the modifications bellow your (actually C) code may compile in Visual Studio ... but not with other compilers. </p>

<p>Just another off-topic: don't use floats in <code>for</code> loops. Floats are nasty!</p>
",2
31298913,31298732,2,"<p>When I tried to compile this under gcc I got the following error:</p>

<pre><code>/tmp/x1.c:23: error: conflicting types for ¡®round_near¡¯
/tmp/x1.c:23: note: an argument type that has a default promotion can¡¯t match an empty parameter name list declaration
/tmp/x1.c:16: error: previous implicit declaration of ¡®round_near¡¯ was here
</code></pre>

<p>The funny results you're getting is because your compiler didn't know the definition of <code>round_near</code> at the time it was first encountered and assumed it was <code>int round_near()</code>.  So this resulted in undefined behavior.</p>

<p>If you either move <code>round_near</code> above main or put in a declaration above main you should get the expected results.</p>
",1
31306952,31298732,2,"<p><a href=""https://stackoverflow.com/a/31298985/2410359"">@QuestionC</a> well answered OP's immediate problem: implied function signature of <code>int round_near(...)</code> is incompatible with <code>int round_near(float b)</code> and call of <code>round_near(b)</code> which passes <code>b</code> as a <code>double</code>.   </p>

<p>Simple solution: prototype the function. </p>

<p>Some issues about the <code>round_near()</code></p>

<ol>
<li><p>Casting to <code>int</code> severely narrows the legitimate range.  Better to use <code>long long</code>.</p></li>
<li><p>General incorrect functionality with negative numbers. <a href=""https://stackoverflow.com/users/4253229/eugene-sh"">@Eugene Sh.</a>  Code should test for sign.</p></li>
</ol>

<p>Below is a solution that takes advantage of the range of <code>long long</code> as it is usually greater than the continuous range of integers a <code>float</code> can represent exactly.  Alternatively OP can replace <code>my_roundf()</code> with <code>round_near()</code> and use this code for testing.   <code>round_near()</code> fails about 40% of the time.</p>

<pre><code>#include &lt;limits.h&gt;
#include &lt;stdio.h&gt;

float my_roundf(float x) {
  // Large `float`s typically have no fractional portion to round
  if (x &gt; LLONG_MAX / 2) return x;
  if (x &lt; LLONG_MIN / 2) return x;
  return x &gt; 0 ? (long long) (x + 0.5f) : (long long) (x - 0.5f);
}

float rand_float(void) {
  union {
    unsigned char uc[sizeof(float)];
    float f;
  } u;
  do {
    unsigned i;
    for (i = 0; i &lt; sizeof(float); i++) {
      u.uc[i] = rand();
    }
  } while (u.f != u.f);  // re-do if NaN encountered
  return u.f;
}

void my_roundf_test(void) {
  unsigned n = 100000;
  while (n-- &gt; 0) {
    float x = rand_float();
    float ymath = roundf(x);
    // float ymy = round_near(x);
    float ymy = my_roundf(x);
    // Exact half-way cases may fail
    if (ymath != ymy) {
      printf(""x:% .9e math:% .9e my:% .9e\n"", x, ymath, ymy);
    }
  }
}
</code></pre>

<p>Note: There are exact half-way cases per various floating point rounding modes, negative zero, etc. to consider for a complete answer. But leave that for another day.</p>
",1
31308722,31298732,0,"<p>A simple one (<code>float</code> won't fit in an <code>int</code> type, so <code>long long</code>)</p>

<pre><code>long long round(float a) {
    long long b = a;
    if (a &gt;= 0)
        return a - b &lt; 0.5 ? b : b + 1;
    else
        return b - a &lt; 0.5 ? b : b - 1;
}
</code></pre>
",0
31907176,31907142,0,"<p>Macros aren't functions, they're (mostly) dumb text replacement. Your macro lacks parentheses, so when the preprocesor replaces it, you'd get the following:</p>

<pre><code>printf(""%d"",64/4*4);
</code></pre>

<p>Since <code>/</code> and <code>*</code> have the same precedence, this is like stating <code>(64/4)*4</code>, which is, of course, <code>64</code>.</p>

<p>If you want your <code>sqr</code> macro to safely square its argument, wrap it in parentheses:</p>

<pre><code>#define sqr(a) (a*a)
</code></pre>
",0
31907178,31907142,0,"<p><code>64/sqr(4)</code> is expanded to <code>64/4*4</code>.</p>

<p>You have to parenthetise the macro body and should also put parenthesis aroud the argument:</p>

<pre><code>#define sqr(a) ((a)*(a))
</code></pre>

<p>Yields:<code>64/(4*4)</code></p>

<p>Note that macros are pure <em>textual</em> replacements performed by the <em>C preprocessor</em> <strong>before</strong> the actual compilation starts.</p>

<p>A better and type-safe approach would be to use an <code>inline</code> function:</p>

<pre><code>static inline int sqr(int a)
{
    return a * a;
}
</code></pre>

<p>This will likely be <em>inlined</em> into the caller code by the compiler as much as the macro would be. OTOH, the compiler might very well decide not to, depending on internal heuristics. In general, you should trust the compiler to use the proper way, unless you have serious performance/code-size issues.</p>

<p>This will also protect against evaluating the argument <code>a</code> twice. That is critical if there are side-effects like</p>

<pre><code>int i[2], *p = i;
sqr(*p++);
</code></pre>

<p>For the macro version, this will result in undefined behaviour (undefined order of evaluation):</p>

<pre><code>((*p++) * (*p++))
</code></pre>
",0
31907179,31907142,6,"<p>After preprocessing the printf line will be:</p>

<pre><code>printf(""%d"",64/4*4);
</code></pre>

<p>which should explain why it prints 64.</p>

<p>Always use parenthesis in macros definitions when they contain expressions:</p>

<pre><code>#define sqr(a) ((a)*(a))
</code></pre>

<p>Even this is not safe against macro invocations like:  <code>sqr(x++)</code>. So don't use marcos unless you have to :)</p>
",0
32404102,32403962,0,"<p>You'll need to use double quotes:-</p>

<pre><code>system(""start \""C:\\program files\\...\"");
</code></pre>
",1
32407821,32403962,0,"<p>I have found the right way:</p>

<pre><code>if(number==8) {
    system(""\""C:\\Program Files\\LibreOffice 5\\program\\soffice.exe\"""");
}
</code></pre>
",0
32416835,32416624,2,"<h3>Issue 1</h3>
<p>The sum of all primes below 2000000 is 142913828922 (~1.4*10^11 ).</p>
<p>The maximum number that fits into an 32bit <code>int</code> is 2147483647 = 2^31-1 (~2.1*10^9).</p>
<p>So you are getting an integer overflow.</p>
<h3>Fix 1</h3>
<pre><code>unsigned long long sum = 0;
</code></pre>
<p>and</p>
<pre><code>printf(&quot;The sum is: %lld\n&quot;, sum);
</code></pre>
<p>should give the expected result.</p>
<h3>Issue 2</h3>
<p>2 is also a prime, but you are not counting it.</p>
<h3>Fix 2</h3>
<p>A quick hack would be to initialize <code>sum</code> with 2.</p>
",0
32417081,32416624,0,"<p>2 is also a prime number. So, you can initialize <code>sum = 2</code> (according @sergej).</p>

<p>In </p>

<pre><code>if (number % i == 0)
{
      counter++;
      break;
 }
</code></pre>

<p>You should use a <code>break</code> for reducing extra iteration because <code>if (number % i == 0)</code> is <code>true</code> then counter value is increase and it will be 1 and also perfectly work.</p>

<p>And you should use <code>unsigned long long int sum = 0</code> because for 2 million, <code>sum</code>  is much higher from <code>2^31-1</code> (<code>if you use int</code>). </p>

<p>And you display your sum value by <code>printf(""%lld"", sum)</code></p>
",5
32450091,32449631,5,"<ol>
<li><code>*(num+1)[1]</code> and <code>**(num+2)</code> are different ways of writing the same thing. That is, the third element of <code>num</code>.</li>
<li>The type of <code>num</code> is <code>short (*)[2]</code>. That is, it is a pointer to an array of 2 <code>short</code> values.</li>
</ol>

<p>With these two facts in mind we can work out what the code is doing. Below assumes a 32 bit system for simplicity.</p>

<ul>
<li><code>num+1</code>. Since <code>num</code> points to two <code>short</code> values, using pointer arithmetic, <code>num+1</code> will be 4 bytes (2 shorts) after <code>num</code>.</li>
<li><code>(num+1)[1]</code>. The array index gives the second element starting from <code>num+1</code>. That means another 4 bytes past <code>num+1</code> and hence 8 bytes past <code>num</code>.</li>
<li>Accessing 8 bytes after <code>num</code> gives exactly <code>15</code>.</li>
</ul>
",0
33024810,33024759,4,"<p>You've produced undefined behavior by passing the wrong type to <code>printf</code>: the <code>%d</code> format required a matching argument of type <code>int</code> but your argument has type <code>double</code>. You need <code>%f</code> (or <code>%e</code> or <code>%g</code> or <code>%a</code>) to print it. Also, there may be other problems, e.g. if you omitted <code>#include &lt;math.h&gt;</code>.</p>
",8
33026145,33024759,1,"<p>As others have pointed out, the problem here is that the format specifier is wrong.  You need to <code>#include &lt;math.h&gt;</code> to get the proper return type of <code>sqrt()</code>, then use a format specifier like <code>%f</code>.  Also, turn up your compiler warnings until it tells you something was wrong here.  <code>-Wall -Wextra -pedantic -Wno-system-headers</code> is a good choice.</p>

<p>I¡¯m adding an answer, though, to provide historical background on why <code>float</code> variables get promoted to <code>double</code> in <code>printf()</code> argument lists, but not <code>scanf()</code>, since this confused people in the comments.</p>

<p>In the instruction set of the DEC PDP-10 and PDP-11 computers, on which C was originally developed, the <code>float</code> type existed only to save space, and a program needed to convert a <code>float</code> to <code>double</code> to do any calculations on it.  In early versions of C, before ANSI function prototypes, all <code>float</code> arguments to a function were promoted to <code>double</code> automatically before being passed (and also <code>char</code> to <code>int</code>).  Originally, this ran better at a low level, and also had the advantage of avoiding round-off and overflow error on math using the shorter types.  This convention also simplified writing functions that took a varying number of arguments of varying types, such as <code>printf()</code>.  The caller could just pass anything in, the compiler would let it, and it was the called function¡¯s job to figure out what the argument list was supposed to be at runtime.</p>

<p>When C added function prototypes, these old rules were kept for backward-compatibility only with legacy function declarations (<code>extern double sqrt()</code> rather than <code>extern double sqrt(double)</code> or the C14 generic equivalent).  Since basically nobody writes functions that way any more, this is a historic curiosity¡ªwith one exception.  A <code>varargs</code> function like <code>int printf(const char*, ...);</code> <em>cannot</em> be written in C with type checking of the variable arguments.  (There is a C++14 way to do this using templates.)  The standards committee also did not want to break all existing code that printed a <code>float</code>.  So those are still promoted according to the old rules.</p>

<p>In <code>scanf()</code>, none of this applies because the storage arguments are passed by reference, and <code>scanf()</code> needs to be sure it¡¯s writing the data in the same type as the variable that holds it.  Argument-promotion never comes into play, because only pointers are ever passed.</p>
",3
32961378,32960873,2,"<p><code>length</code> and <code>width</code> in <code>area</code> and <code>perimeter</code> are computed as function pointers, for which multiplication is not defined.</p>
",1
32961463,32960873,0,"<p>Here is quick fix:</p>

<pre><code>#include &lt;stdio.h&gt;

float width(){
    float width;
    printf(""Input Width: "");
    scanf(""%f"", &amp;width);
    return width;
}

float length(){
    float length;
    printf(""Input Length: "");
    scanf(""%f"", &amp;length);
    return length;
}

float area() {
   return length() * width();
}

float perimeter(){
    float perimeter=(length()*2) + (width()*2);
    return perimeter;
}

int main(){
    printf(""Area = %f\n"", area());
    printf(""Perimeter = %f\n"", perimeter());
}
</code></pre>

<p>but here is how would I do it:</p>

<pre><code>#include &lt;stdio.h&gt;

float width(){
   float width;
   printf(""Input Width: "");
   scanf(""%f"", &amp;width);
   return width;
}

float length(){
   float length;
   printf(""Input Length: "");
   scanf(""%f"", &amp;length);
   return length;
}

float area(float length, float width) {
   return length * width;
}

float perimeter(float length, float width){
   return length*2 + width*2;
}

int main(){
   float l = length();
   float w = width();
   printf(""Area = %f\n"", area(l, w));
   printf(""Perimeter = %f\n"", perimeter(l, w));
}
</code></pre>
",9
33003137,33003060,1,"<p>You have missed out the file pointer from the <code>fprintf</code> statement</p>

<pre><code>fprintf(""Datos leidos del sensor"");
</code></pre>

<p>Try </p>

<pre><code>fprintf(f, ""Datos leidos del sensor"");
</code></pre>
",12
33005466,33003060,1,"<p>Note:  You used <code>""W""</code> instead of <code>""w""</code> as the open mode to fopen.  That's the real problem.</p>

<p>But, you should always check the ""f"" variable for NULL after the fopen.  I'm fairly sure that it's NULL [which means you couldn't open the file].  This is just good practice.  It's much easier than tracking down a segfault.</p>

<p>You have:</p>

<pre><code>f=fopen(""./home/debian/Desktop/Comunicacion/Prueba.txt"",""W"");
fprintf(f,""Datos leidos del sensor"");
</code></pre>

<p>Change this to:</p>

<pre><code>f=fopen(""./home/debian/Desktop/Comunicacion/Prueba.txt"",""w"");
if (f == NULL) {
    perror(""fopen"");
    exit(1);
}
fprintf(f,""Datos leidos del sensor"");
</code></pre>
",0
33018992,33018755,0,"<p>Your source file is .cpp but you're writing C code.  Change the name of your file to test_1.c</p>
",1
33019338,33018755,0,"<p>You declared <code>notification_callback</code> with the following types for its parameters:</p>

<pre><code>(void *, double, void *)
</code></pre>

<p>Looking for esa.h for opnet in Internet (I have found version 10.0.A, but probably that has not changed), the parameters for a <code>Esa_Interface_Callback_Register</code> should be:</p>

<pre><code>(void *, double, va_list)
</code></pre>

<p>You could use your function in a similar way, but you should declare it using va_list, and take the first parameter if you know it is the only one that you are going to get.</p>

<p>And also, as KevinDTimm answered, I think it is better to avoid C++ if you are not using it for anything, and just work with plain C.</p>
",1
33511907,33511771,1,"<p>Something seems very wrong with this.</p>

<pre><code>int temp = &amp;current-&gt;next-&gt;data;     // Assignes a pointer into temp
current-&gt;next-&gt;data = current-&gt;data; // Copies current into next
current-&gt;data = temp;                // Copies the pointer into data 
</code></pre>

<p>This is unlikely to do nothing. It's quite likely to corrupt your data.</p>

<p>Could it be as simple as to change the first of these lines to:</p>

<pre><code>int temp = current-&gt;next-&gt;data;
</code></pre>

<p><strong>Edit</strong></p>

<p>Cleaning up your code a little I get to this:</p>

<pre><code>void set_sort(set_t *the_set)
{
    assert(the_set);
    int sorted;
    int x;
    do {
        set_node_t *current = the_set-&gt;head;
        sorted = 1;
        for( x = 0; x &lt; the_set-&gt;set_size - 1; x++){
            if(current-&gt;data &gt; current-&gt;next-&gt;data){
                sorted = 0;
                int temp = current-&gt;next-&gt;data;
                current-&gt;next-&gt;data = current-&gt;data;
                current-&gt;data = temp;
            }
            current = current-&gt;next;
        }
    }
    while (!sorted);
}
</code></pre>

<p>Removing the use of unnecessary recursion removes the risk of causing a stack overflow.  Removing the continue makes the code marginally quicker (I believe).  Removing the spurious use of the pointer should fix your code.</p>

<p>If your code isn't fixed by this then then you will need to post the definition of <code>set_node_t</code>, its possible your comparison is not working (<code>if (current-&gt;data &gt; current-&gt;next-&gt;data)</code>).</p>

<p><strong>Edit 2</strong></p>

<p>As comments and updated question has now pointed out you need to perform your comparison on the data itself and not the pointer to the data.</p>

<pre><code>if(*(current-&gt;data) &gt; *(current-&gt;next-&gt;data)){
</code></pre>
",6
33531954,33531606,1,"<p>You have to correct for rounding errors when using floating point numbers.  An easy way that often works is to add 0.5 before converting to an int.  So, something like this should work better:</p>

<pre><code>centy= (int) (0.5 + suma * 100.0) - cele * 100;
</code></pre>

<p>It's probably better to read the input as a string and parse it into euros and cents using the '.' as a delimiter. But this will get the code working easily. Adding 0.5 often works when you don't need exact precision, but close enough will do.</p>
",6
33569652,33569557,0,"<p><em>""printf never supplies new line automatically, so several calls may be used to build up an output line in stages""</em></p>

<p>This means that a newline <code>\n</code> is not inserted automatically after a <code>printf()</code> call. Meaning</p>

<pre><code>printf(""Hello"");
printf(""World"");
</code></pre>

<p>Would print</p>

<pre><code>HelloWorld
</code></pre>

<p>Even though it is printed in 2 different, <code>printf()</code>. A newline won't occur when one <code>printf()</code> has executed.</p>

<p>So, you can use multiple <code>printf()</code> to print the text in a single line.</p>

<hr>

<p>If you want a newline <code>\n</code> between <code>printf()</code>, you need to supply that explicitly, like</p>

<pre><code>printf(""Hello\n"");
printf(""World"");
</code></pre>

<p>Would print</p>

<pre><code>Hello
World
</code></pre>

<hr>
",2
33569660,33569557,0,"<p>your  code is wrong for <strong>printf()</strong> function. You wrote printf function terminating character("") in second line. That's why you got termination character error after compile. It will be same line.</p>

<p>like this:</p>

<pre><code>int main()
{
    printf(""Hello, world"");
    return 0;
}
</code></pre>

<p>if you want to add new line you can add <strong>\n</strong> in printf.</p>

<p>like this:</p>

<pre><code>printf(""Hello, world\n"");
</code></pre>
",1
33540432,33539645,0,"<p>You have 43*90 cars, as you just declared <code>Car car[43][90]</code>.
Even if you declared them as 'empty' (containing 0).</p>

<p>I suggest you modify your code as following: <code>Car* car[43][90] = {{0}};</code> and basically have every pointer set as <code>NULL</code> and the non empty ones pointing to a dynamically allocated car (moving it would also be more efficient, aside from the obvious minimization in memory consumption. Of course you'll need to modify your map drawing function accordingly.</p>

<p>Your <code>position[i][j]</code> is wrong as both <code>i</code> and <code>j</code> travel outside of the array limits (position is only <code>[2][2]</code>). I suppose that your map is 43x90 and that's where your confusion came from. If this is the case, you shouldn't even have a position variable (<code>pos_i</code> and <code>pos_j</code>) as the array index already marks the position (say <code>arr[i][j]</code> is the car, then the car is in <code>i, j</code>).</p>
",1
33539879,33539645,0,"<p>Well, first of all you're not creating 2 cars, you're creating 43*90 = 3870 cars.  You are declaring a 43x90 array of cars, for a total of 3870 cars.  You then iterate over all of the cars in the array, initializing all 3870 of them.  But you're indexing outside of the bounds of your <code>position</code> array.  <code>position</code> is a 2x2 array, so both indices must be in the range [0,1].  But you're using your loop indices to index into it, so you are going way past the bounds of the array, and you're getting whatever values happen to be on the call stack.</p>

<p>It sounds like what you want to do just have 2 cars.  That should work a lot better.</p>
",1
33557072,33556880,0,"<p>There is one major problem: you're trying to determine the length of the input before receiving any input.</p>

<p>so switch the lines like this:</p>

<pre><code>printf (""input\n"");
fgets (input, sizeof (input), stdin);
n = strlen(input);
</code></pre>

<p>Then your for-loop ... why so heavy testing, wouldn't</p>

<pre><code>for ( front = 0, back = n-1; front &lt; back; ++front, --back)
</code></pre>

<p>be sufficient?</p>

<p>And at last: the rest of your code.  Please think about it again.  You want to:</p>

<ul>
<li>print all characters from the beginning up to and including <code>front</code></li>
<li>print all characters from back till the end</li>
<li>print a newline</li>
</ul>

<p>Your code does nothing about this.  But we're not here to solve your homework ;)</p>

<p>A last hint: there are two different types of stop-condition, and they depend on if your input length is even or odd.  (My suggested test should be ok to catch'em both, tho).</p>
",0
33579872,33579844,3,"<p>You should keep a copy of i, so that it could be kept for comparison with the sum variable.</p>

<p>As of now, you compare sum and i, at every step when i has become 0.</p>

<p>You should use a temp variable to store value of i(before performing i/=10).</p>

<p>Also, you can't keep i in the while-loop as it would always be 0, and hence post increment will have no effect on it. You should need another temporary variable, say <code>div</code>.</p>

<p>And, you should finally print <code>temp</code>.</p>

<p>Also, an Armstrong number is an n-digit number that is equal to the sum of the nth powers of its digits. </p>

<p>So, for 1000, you need to caclculate the 4th power.</p>

<pre><code>int temp,div;
for(i=1;i&lt;=1000;i++)
     {
       temp = i;
       div = i;
       while(div!=0)
       {
         rem = div%10;
         sum = sum + pow(rem,3);
         div = div / 10;
       } 
       if(temp == sum)
       printf(""\n %d"", temp);
     }
</code></pre>

<p>NOTE :- Probably you're using Turbo C compiler(check that header <code>&lt;conio.h&gt;</code>), which you shouldn't(you should avoid it). You should use GCC(on Linux system), CodeBlocks IDE(on Windows).</p>
",6
33581289,33579844,0,"<p>You can also use this code to print Armstrong number in given range.</p>

<pre><code>#include&lt;stdio.h&gt;
int main()
   {
    int num,r,sum,temp;
    int min,max;

    printf(""Enter the minimum range: "");
    scanf(""%d"",&amp;min);

    printf(""Enter the maximum range: "");
    scanf(""%d"",&amp;max);

    printf(""Armstrong numbers in given range are: "");
    for(num=min;num&lt;=max;num++)
       {
         temp=num;
         sum = 0;

         while(temp!=0)
             {
               r=temp%10;
               temp=temp/10;
               sum=sum+(r*r*r);
             }
         if(sum==num)
             printf(""%d "",num);
       }
     return 0;
  }
</code></pre>
",0
33581593,33581529,4,"<p>It is because you open <code>text2.txt</code> in every iteration of your while loop. And what is more, you open it with mode <code>""w""</code> which if you look at the <a href=""http://www.cplusplus.com/reference/cstdio/fopen/"" rel=""nofollow"">documentation</a> states:</p>

<blockquote>
  <p><strong>write</strong>: Create an empty file for output operations. If a file with the same name already exists, its contents are discarded and the file is treated as a new empty file.</p>
</blockquote>

<p>So what is happening is, at every iteration, you open the file, discarding whatever was there before, (which after the first iteration would be a file with a single word in it).</p>

<p>Instead you should open it before you enter the while loop.</p>

<p>Additionally, you stated that you wanted to sort the words you found in lexicographical order before you wrote them to the new file. If your code had written the words as you had intended, then they would be in the order they appeared in the original file, not lexicographic order. You are better off saving the pointers to the n-length words in an array, sorting that array, and then writing it all in one go to your output file.</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define MAX_WORDS 100

int
qstrcmp(const void *a, const void *b)
{
  const char
    *s = *(const char **)a,
    *t = *(const char **)b;

  return strcmp(s, t);
}

int
main()
{
  FILE *input, *output;
  input = fopen(""text.txt"", ""r"");

  // Get length to filter by
  unsigned long n;
  scanf(""%lu"", &amp;n);

  char *words[MAX_WORDS];
  int i = 0;

  // Find words of correct length
  char buf[100];
  while (fscanf(input, ""%99s"", buf) != EOF) {
    // Protect from buffer overflow
    if (i &gt;= MAX_WORDS) {
      printf(""Too many words!"");
      break;
    }

    if (strlen(buf) == n) {
      words[i++] = strncpy(malloc(n+1), buf, n+1);
    }
  }
  fclose(input);

  // Sort in lexicographical order.
  qsort(words, i, sizeof(char *), qstrcmp);

  // Write to output
  output = fopen(""text2.txt"", ""w"");
  for (int j = 0; j &lt; i; ++j) {
    fprintf(output, ""%s\n"", words[j]);
  }
  fclose(output);

  // Print number found.
  printf(""Found %d word%s of length %lu.\n"", i, i == 1 ? """": ""s"", n);

  return 0;
}
</code></pre>

<h3>Implementation Notes</h3>

<ul>
<li>Sorting is achieved with <a href=""http://www.cplusplus.com/reference/cstdlib/qsort/"" rel=""nofollow""><code>qsort</code></a> from <code>""stdlib.h""</code>.</li>
<li>Pay attention to buffer overflows! In this case I just bail, but alternatively, you could re-allocate the memory for the <code>words</code> array.</li>
<li>Remember to copy the null-byte over when saving the word.</li>
<li><code>qsort</code> passes references to the array elements it's sorting to its comparator function, so it will pass values of type <code>const char **</code>, this is why we need to use the <code>qstrcmp</code> wrapper function.</li>
</ul>
",1
33584409,33584168,3,"<p>You can use the absolute value of <code>n</code> (i.e. <code>abs(n)</code>) as <code>i</code>'s upper bound, and record <code>n</code>'s sign (i.e. <code>bool sgn = ( n &gt; 0 ) ? 1 : 0;</code>) for output.</p>
",0
34081565,34081516,1,"<p>""Normal types in C can usually only store up to 64 bits, so you'll have to store big numbers in an array, for example, and write mathematical operations yourself. But you shouldn't reinvent the wheel here - you could try the GNU Multiple Precision Arithmetic Library for this purpose."" </p>

<p><em>-AndiDog</em></p>

<p>Source:<a href=""https://stackoverflow.com/questions/2640625/store-and-work-with-big-numbers-in-c"">Store and work with Big numbers in C</a></p>
",1
34082057,34081516,0,"<p>Take advantage that mod 3 and mod 11 can easily be chained one digit at a time.</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;ctype.h&gt;

void mod3_11(void) {
  int mod3 = 0;
  int mod11 = 0;
  int ch;
  while (isdigit(ch = fgetc(stdin))) {
    int digit = ch - '0';
    mod3 = (digit + mod3)%3;
    mod11 = (digit - mod11 + 11)%11;
  }
  printf(""mod 3  = %d\n"", mod3);
  printf(""mod 11 = %d\n"", mod11);
  fflush(stdout);
  }

int main(void) {
  mod3_11();
  return 0;
}
</code></pre>

<hr>

<p>This works as each successive digit is processed, code is taking the previous ""mod"" * 10</p>

<pre><code>// math
mod_n &lt;-- (10*mod_n + digit)%n

mod3 &lt;-- (mod3*10 + digit) % 3
mod3 &lt;-- (mod3*1 + mod3*3*3 + digit) % 3   
mod3 &lt;-- (mod3 + 0 + digit) % 3    (mod3*3*3 % 3 is 0)
mod3 &lt;-- (mod3 + digit) % 3

mod11 &lt;-- (mod11*10 + digit) % 11
mod11 &lt;-- (mod11*11 - mod11*1 + digit) % 11
mod11 &lt;-- (mod11*11 - mod11 + digit + 11) % 11  (add 11 to avoid negative numbers)
mod11 &lt;-- (-mod11 + digit + 11) % 11
</code></pre>

<p>Why add 11?  <a href=""https://stackoverflow.com/a/20638659/2410359"">What's the difference between ¡°mod¡± and ¡°remainder¡±?</a>    </p>
",0
34080914,34080846,10,"<blockquote>
  <p>Why do I get clang: error: linker command failed with exit code 1?</p>
</blockquote>

<p>You just declared the function. There is not any definition in code. At the time of linking process , compiler(here clang) cannot link <code>power</code> function to its definition so linker throws the error in this kind of situation. If you define </p>

<pre><code>int power(int x, int y)  
         { 
               \*do calculation*/
         }
</code></pre>

<p>Then linker can link your declaration of <code>power</code> function to its definition ,you will not get any error.</p>

<p>For integer number I have made function for you.</p>

<pre><code>#include &lt;stdio.h&gt;
int power(int base, int exp);
int main()
{
int i;

for (i=0; i&lt;10; ++i)
    printf(""%d %d %d\n"", i, power(2,i), power(-3,i));

return 0;
}

int power(int base, int exp)
{
    int result = 1;
    while (exp)
    {
        if (exp &amp; 1)
            result *= base;
        exp &gt;&gt;= 1;
        base *= base;
    }

    return result;
}
</code></pre>

<p>Compile this with <code>gcc file.c</code></p>

<p>Hope you understand the function. Good luck :-)</p>
",6
34080971,34080846,1,"<p>you can define <code>power</code> function </p>

<pre><code>int power(int m, int n){
//implement the function body
}
</code></pre>

<p>then your issue will get fixed.</p>

<p>Your getting error, because there is not deceleration for the defined function. So add the deceleration as shown in above. </p>
",5
34081174,34080846,1,"<p>There is a standard library function which does just that...</p>

<pre><code>#include &lt;math.h&gt;
double pow(double x, double y)
</code></pre>

<p>You have to link it explicitly because the default <code>linker</code>, that is <code>ld</code> invoked when no other options given, doesn't link with standard math library.</p>

<p>So you have to do it like...</p>

<p><code>gcc file.c -lm</code></p>
",0
34081206,34080846,0,"<p>First you get the error because the compiler can not find the definition of the power function that you are using. Even if you write</p>

<pre><code>int power(int m, int n);
</code></pre>

<p>There is an error because you are not defining the function. There is missing {} at the end of the definition and even if you are putting it at the end of the definition, you will get an error because you are not returning nothing for a int function. So, at least if you want to define a function, you have to proceed like this :</p>

<pre><code>int power(int m, int n){return 0};
</code></pre>

<p>Then, you will be able to use your function power() in the main function. But, you are doing nothing in the power() function, so you will get nothing back of calling it. If you want to compute the power of a number, you can use the function pow() that is present in the cmath library. A straightforward way of doing it is something like this :</p>

<pre><code>#include &lt;stdio.h&gt; // printf
#include &lt;cmath&gt;  // pow()
#include &lt;iostream&gt; //cout

void main()
{
    for (int i = 0; i &lt; 10; i++)
        std::cout &lt;&lt; i &lt;&lt; "" "" &lt;&lt; pow(2, i) &lt;&lt; "" "" &lt;&lt; pow(-3,i) &lt;&lt; std::endl;
}
</code></pre>

<p>I included the iostream to use a different way of printing out using the object cout defined in the std namespace. Note that the pow() function has some requirements for its definition, so be careful with the types you are using. You can take a look at <a href=""http://www.cplusplus.com/reference/cmath/pow/"" rel=""nofollow"">http://www.cplusplus.com/reference/cmath/pow/</a> for more details.</p>
",0
34081550,34080846,3,"<p>You missed the definition of function <code>int power (int base,int n)</code> which is given after your main ends on the next page of the book.</p>

<p>When you declare prototype of a function you need to define what it should do you just declared the power function and never defined that, that's why you got error.</p>

<p>Include the following definition, your code will compile the way you wants it to be.</p>

<pre><code>int power (int base,int n){
int i,p;
p=1;
for (i=1;i&lt;=n;++i)
p=p*base;
return p;
}
</code></pre>

<p><strong>PRE-EDIT ANSWER</strong>
<strong>NOW THIS IS NOT RELEVANT BUT USEFULL</strong></p>

<p>I think you want to use function <code>pow()</code> defined in <code>math.h</code>.</p>

<pre><code>double pow(double a, double b)
</code></pre>

<p>The C library function <code>pow(double a, double b)</code> returns <code>a</code> raised to the power of <code>b</code>. This function returns a double value so to print that correct specifier will be <code>""%lf""</code>.</p>

<p>In this case you just need to include header file</p>

<pre><code>#include&lt;math.h&gt;
</code></pre>

<p>In your program.</p>

<p>There is no need to give function declaration <code>int power(int m, int n);</code></p>

<p>The error you are having is due to giveing I as on of the parameter to <code>pow()</code>
because when you will compile your code (after including <code>math.h</code> and using <code>pow()</code> replacing <code>i</code> with any integer numbers will compile your code and will give proper output.</p>

<pre><code>printf(""%lf %lf %lf\n"", i, pow(2,3), pow(3,2));
</code></pre>

<p>This will give you proper result but when you compile it with</p>

<pre><code>for (i=0; i&lt;10; ++i){
printf(""%lf %lf %lf\n"", i, pow(2,i), pow(-3,i));
}
</code></pre>

<p>It throws same error so I think <code>pow()</code> takes only <strong>constants</strong> as input so it won't run in <code>for</code> loop.</p>

<p>And if you don't want to include <code>math.h</code> you can simply declare</p>

<pre><code>extern double pow (double base, double exponent); 
</code></pre>

<p>That will link correctly with the library code without using the <code>math.h</code> include file, here is an example.</p>

<pre><code>int main() {
extern double pow (double base, double exponent);
printf(""%lf"",pow( 8.0, 8.0 ));
return 0;
} 
</code></pre>

<p>For more on <code>pow()</code> you can check man page on Linux i.e. <code>man pow</code>.</p>
",1
33818455,33818238,1,"<p>The problem is that you always read the next word into ""word"" and you make all your ligne[i] elements point to the same variable, ""word"". If you really do know the size of the words and the number of lines you can do:</p>

<pre><code> int main( int argc, char **argv ) {
     int i=0 ,k;
     char ligne[4][25]; // three char pointer that take each ligne

     FILE* file = fopen(""dico.txt"" , ""r"");

     if(file != NULL){
         while ( fgets(ligne[i] , 25 , file) != NULL ) {
             i++;
         }

// print each ligne of the file text

     for( i =0 ; i &lt; 3 ; i++){
         printf(""%s"" , ligne[i]);
         printf(""\n"");
         }
     }  return 0; 
}
</code></pre>

<p>Note that ligne is declared for 4 rows. The reason is that after the 3rd line you still pass in ligne[4] to fgets, and even though fgets will return with NULL, the pointer you pass in should be valid. </p>

<p>Also note that the code as is is very dangerous. I relies on the file not having more than 3 lines, or more precisely, fgets returning NULL for the 4th call. These are not the same as the number of characters consumed in each call is limited to 24 (25-1) in each call. If that assumption fails then you'll have all sorts of interesting memory errors.</p>
",0
33818462,33818238,1,"<p>You are overwriting the previously read value with any new reads. Debugging will show that each ligne element points to the same memory address. Instead explicitly create a multi dimensional array and manually reference which element you want to assign to.</p>

<pre><code>const unsigned int NUM_LINES = 3;
int i = 0;
char *ligne[3] = { NULL }; // three char pointer that take each ligne
char word[NUM_LINES][25];

FILE* file = fopen(""dico.txt"", ""r"");

if (file != NULL)
{
    while (fgets(word[i], 25, file) != NULL){
        ligne[i] = word[i];
        i++;
    }

    // print each ligne of the file text
    for (i = 0; i &lt; 3; i++)
    {
        printf(""%s"", ligne[i]);
        printf(""\n"");
    }
}  
return 0;
</code></pre>
",0
33818397,33818238,2,"<p>The problem is that you are making each index in the ligne array point to the word array. So, when you are done with the fgets while loop, all the indices will be pointing to the data inside the word array, which is sasa (since this was the last word put into the word array, i.e., you overwrote the other words).
A possible solution is to declare your ligne array as follows:</p>

<p><code>char ligne[4][25]</code>.</p>

<p>Then call fgets as such :</p>

<p><code>fgets(ligne[i], 25, file)</code></p>

<p>On each round of the while loop.</p>
",2
33823482,33818239,0,"<p>Trial Division Theorem: <br>
The most basic method of checking the primality of a given integer n is called trial division. This routine consists of dividing n by each integer m that is greater than 1 and less than or equal to the square root of n. <br></p>

<p>Hence, lets check primality of 37. </p>

<pre><code>floor(sqrt(37)) = 6
</code></pre>

<p>So, check from 2 to 6, weather 37 is divisible by any of number in between. If 37 is not divisible by any number, then number is prime.</p>

<p>So, in your example:</p>

<pre><code>floor(sqrt(11)) = 3  that's why started j = 3,
</code></pre>

<p>Also, instead of performing sqrt on i, we have considered square of j i.e. j*j &lt;= i;</p>

<p>And, for last question answer by @dasblinkenlight is best.</p>
",0
33818514,33818239,0,"<p>First of all, the theory behind it:</p>

<blockquote>
  <p><a href=""https://chart.googleapis.com/chart?cht=tx&amp;chl=P"" rel=""nofollow""><img src=""https://chart.googleapis.com/chart?cht=tx&amp;chl=P"" alt=""P""></a> is a prime number if there is no other factor like <a href=""https://chart.googleapis.com/chart?cht=tx&amp;chl=j"" rel=""nofollow""><img src=""https://chart.googleapis.com/chart?cht=tx&amp;chl=j"" alt=""j""></a> in <a href=""https://chart.googleapis.com/chart?cht=tx&amp;chl=P"" rel=""nofollow""><img src=""https://chart.googleapis.com/chart?cht=tx&amp;chl=P"" alt=""P""></a>, which <a href=""https://chart.googleapis.com/chart?cht=tx&amp;chl=2%5Cleq%20j%5Cleq%20%5Csqrt%7BP%7D"" rel=""nofollow""><img src=""https://chart.googleapis.com/chart?cht=tx&amp;chl=2%5Cleq%20j%5Cleq%20%5Csqrt%7BP%7D"" alt=""2 &lt; j &lt; strq(P)""></a>.</p>
</blockquote>

<p>In your code, you are following the same path. The inner loop is trying all possible <a href=""https://chart.googleapis.com/chart?cht=tx&amp;chl=j"" rel=""nofollow""><img src=""https://chart.googleapis.com/chart?cht=tx&amp;chl=j"" alt=""j""></a> less than or equal to <a href=""https://chart.googleapis.com/chart?cht=tx&amp;chl=%5Csqrt%7BP%7D"" rel=""nofollow""><img src=""https://chart.googleapis.com/chart?cht=tx&amp;chl=%5Csqrt%7BP%7D"" alt=""sqrt(i)""></a>.</p>

<blockquote>
  <p>we use <code>""i=11""</code> because we want only the two digits primes but why <code>j=3</code> and not <code>j=11</code></p>
</blockquote>

<p>Based on what I just said, you should ask why <a href=""https://chart.googleapis.com/chart?cht=tx&amp;chl=3%5Cleq%20j"" rel=""nofollow""><img src=""https://chart.googleapis.com/chart?cht=tx&amp;chl=3%5Cleq%20j"" alt=""3&lt;j""></a>! not <a href=""https://chart.googleapis.com/chart?cht=tx&amp;chl=3%5Cleq%20j"" rel=""nofollow""><img src=""https://chart.googleapis.com/chart?cht=tx&amp;chl=3%5Cleq%20j"" alt=""2&lt;j""></a>? The answer is simple! <code>j</code> is a factor in <code>i</code> (e.g. 3 a factor in 12=3*2*2) In this code in order to make it even faster, you just skipped all even numbers (<code>i+=2</code>), then you don't need j=2 to check if 'i' is dividable by j.</p>

<blockquote>
  <p>8th line <code>""j*j&lt;=i""</code> why he did that?what we gain?</p>
  
  <p>why we have this <code>if (j*j&gt;i)</code> and not something <code>(j==i)</code></p>
</blockquote>

<p>Both questions are related to this part: <a href=""https://chart.googleapis.com/chart?cht=tx&amp;chl=j%5Cleq%20%5Csqrt%7BP%7D"" rel=""nofollow""><img src=""https://chart.googleapis.com/chart?cht=tx&amp;chl=j%5Cleq%20%5Csqrt%7BP%7D"" alt=""3&lt;j""></a>.</p>
",1
33818385,33818239,2,"<blockquote>
  <p>why <code>j=3</code> and not <code>j=11</code></p>
</blockquote>

<p>Because <code>j</code> is your candidate <em>divisor</em>. You need to try all divisors up to square root except <code>2</code>, which has been eliminated by construction of the algorithm (you start with <code>11</code> and go up by <code>2</code>, so you see only odd numbers; no need to check divisibility by <code>2</code>).</p>

<blockquote>
  <p>8th line <code>j*j&lt;=i;</code> Why he did that? What we gain?</p>
</blockquote>

<p>If you tried all numbers up to and including the square root of the candidate prime, and found no divisors, then there would be no divisors above the square root as well. This saves you a lot of unnecessary iteration.</p>

<blockquote>
  <p>why we have this if <code>(j*j&gt;i)</code> and not something <code>(j==i)</code></p>
</blockquote>

<p>The loop terminates under two conditions: (a) you reach a <code>break</code>, or (b) <code>j</code> goes past the square root of <code>i</code>. If you reached <code>break</code>, it means you found a divisor; if you reached past the square root, you didn't.</p>
",0
33820243,33818209,0,"<p>Try this code</p>

<p>I make some changes in your code..</p>

<p>1.Here your are using two function hence we need to declare structure globally. So that both the function can use prototype of structure</p>

<p>2.C language has top-down type of approach hence we need to give prototype of <code>printList</code> function at the top of program or define function in top itself</p>

<p>3.In <code>while(c&lt;11)</code> block we have to add the statement <code>current-&gt;next=NULL</code> to identify end position of list which is used in <code>printList</code> function</p>

<p>4.When we use <code>malloc</code> function type conversion is must.</p>

<p>5.It is not needed to send <code>headptr</code> by address. It increase the complexity of program. So just I changed that portion to somewhat easier method</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct list
{                //creating structure
    int num;
    struct list *next;  //used to point to next node on list
};

void printList(struct list* head)
{
    while(head-&gt;next!=NULL)
    {
      printf(""%d "",head-&gt;num);
      head=head-&gt;next;
    }

}
int main()
{
    struct list *head;             //used to navigate the linked list
    struct list *current;
    struct list *newp;
    head=(struct list *)malloc(sizeof(struct list));  //gives memory space to start off linked list
    head-&gt;num=0;
    head-&gt;next=NULL;
    current=head;                      //current equals head now so that one can easily navigate the list with the loop

    int c=0;                      //loop counter int
    while(c&lt;11)      //populates the linked list with integers
    {
       newp=(struct list *)malloc(sizeof(struct list));
       current-&gt;next=newp;
       current=newp;
       current-&gt;num=c+1;
       current-&gt;next=NULL;
       c++;
    }
    struct list *headptr=head;   //PROBLEM: I'm assuming here is where I'm having the issue.
    printList(headptr);
}
</code></pre>
",1
34186441,34186375,1,"<p>When the application is first called in your main function, it expects a return value.  Unless the <code>n</code> that you pass to it is -1, the lines following the self-invoked function will happen once because it is called in <code>main</code> and has to reach the end of the function.  When the self-invoked function returns a number, that doesn't end the function call to <code>display</code> in <code>main</code>, the last <code>return n;</code> in your <code>else</code> block does.</p>

<p>Recursion is easiest to understand when followed step-by-step.  So I would recommend doing that to fully understand it.</p>
",3
34211192,34210998,1,"<p>The logic in the conditional of following line is wrong.</p>

<pre><code>for(i=0; strcmp(course[i-1], ""0"") ; i++){
</code></pre>

<p>It should be:</p>

<pre><code>for(i=0; strcmp(course[i-1], ""0"") == 0 ; i++){
                                  ^^^^
</code></pre>

<p>However, the more important error is that you will end up using <code>course[-1]</code> in the first iteration of the loop. That leads to undefined behavior.</p>

<p>You need to adjust your logic for the loop a little. Something like:</p>

<pre><code>// Don't exceed the limit of the valid indices for course.
for (i=0; i &lt; 10  ; i++)
{
   printf(""Enter the name of the #%d course: "", i+1);
   scanf(""%s"", course[i]);

   // If the condition to stop is met, break out of the loop.
   if(strcmp(course[i], ""0"") == 0 )
   {
      break;
   }

   printf(""Enter the credit hours for %s course: "", course[i] );
   scanf(""%d"", &amp;credit[i]);

   printf(""Enter your grade in %s course: "", course[i]);
   scanf("" %s"", letter[i]);
   count++;
}
</code></pre>
",2
34082225,34082165,1,"<p>The first char of an array starts at index <code>0</code>, not <code>1</code>. So, you need change it to:</p>

<pre><code>  if (name[0] &gt;= 65 &amp;&amp; name[0] &lt;= 90 || name[0] &gt;= 97 &amp;&amp; name[0] &lt;= 122) {

   }
</code></pre>

<p>You can use <a href=""http://man7.org/linux/man-pages/man3/isalpha.3.html"" rel=""nofollow"">isalpha()</a> which is even  simple and portable.</p>

<p>Note that <code>fflush(stdin);</code> is <em>undefined behaviour</em> in ISO C.</p>
",0
34082231,34082165,1,"<pre><code> if (name[1] &gt;= 65 &amp;&amp; name[1] &lt;= 90 || name[1] &gt;= 97 &amp;&amp; name[1] &lt;= 122) {
        flag = 1;
    }
</code></pre>

<p><code>name[1]</code> will check for second character not first . Array indexing start with <code>0</code> (<code>0</code> to <code>29</code> <em>in your case</em> ), so first character is <code>name[0]</code>. </p>

<p>A point - instead of calculating string length inside loop , calculate it first ,store into variable and then use it in condition.</p>

<p><strong>Note</strong>- When you use <code>do-while</code> loop then why do you even use <code>goto</code> . Loop is going to iterate any way (<em>ofcourse until</em> <code>flag</code> is not <code>1</code>). There is no need of it . </p>
",0
34217542,34217228,0,"<p>The members in the structure arranged as a group of 4 bytes in 32 bit processor.So you are getting 28 bytes as size.
for more details see <a href=""http://fresh2refresh.com/c/c-structure-padding/"" rel=""nofollow"">here</a>
It is due to padding</p>
",0
34217727,34217228,2,"<p>The principles of allocating local variables on stack are roughly the same for all systems</p>

<p>1 --  Stack grows from high addresses to low addresses</p>

<p>2 --  The order of declaration of your variables in your program corresponds to growth of stack</p>

<p>3 --  Each type has alignment - the address of any variable must be divisible by its size (1 for char, 2 for short, etc).Try to waste as little space as possible </p>

<p>In this way, we try to use some waste space to improve the speed of memory access.
So in your codes, it meams that</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct                   //  the base address is &amp;a
{
    int         m;       // [0, 4)  
    int         s;       // [4, 8)
    int         l;       // [8, 12)
    union
    {
        char    c[10];   // [12, 22)
    };
    // char     m_align[2]  //  there are 4 byte for align
    float       p;       // [24, 28)
}a;                      //  sizeof = 28
</code></pre>

<p>the value <code>m</code> is begin at the start of type <code>a</code>, and occupancy 4 byte in 32bit system, so it's address is [0, 4). and it's start address can divisible by sizeof(int).</p>

<p>this is the same to <code>s</code> and <code>l</code>.</p>

<p>and then the union value <code>c[10]</code> occupancy, occupancy [12, 22), the begining od it's address 12 can divisible by sizeof(int).</p>

<p>What's importment the next address is 22£¬ and the value <code>p</code> will occupancy <code>sizeof(float) = 4</code> bytes£¬but the address 22 can't divisible by <code>sizeof(float)</code>. we must fill the space to alignment the struct and try to waste as little space as possible. So the base address of value <code>p</code> will be 24 which can divisible by <code>sizeof(float)</code>, so the adddress of <code>p</code> is [24, 28]...</p>

<p>you can see this <a href=""https://en.wikipedia.org/wiki/Data_structure_alignment"" rel=""nofollow"">https://en.wikipedia.org/wiki/Data_structure_alignment</a> for detail</p>
",0
34180632,34180537,1,"<p>Reason is this -</p>

<pre><code>fgets(buffer,100,f);       // check return of fgets
a[i]=buffer;               // Note - buffer is modified in each iteration
</code></pre>

<p>You point to string which is stored in <code>buffer</code> in <strong>last iteration</strong>. Every pointer points to <em>last string read</em> . And each time you print same string is printed . </p>

<p>What you should do is <em>allocate memory</em> to pointer <code>a[i]</code> , and use <code>strcpy</code> to copy the string .</p>
",1
34181109,34180537,0,"<p>If you know it's always 10 lines, you could declare a as a 2d array.</p>

<p>Something like this should be better.</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main()
{
    int i;
    char buffer[100];
    char a[10][100];
    FILE *f,*p;
    f=fopen(""Frozen_snowman.txt"",""r"");
    p=fopen(""Reverse.txt"",""w"");
    for(i=0;i&lt;10;i++)
    {
        fgets(buffer,100,f);
        strcpy (a[i], buffer);
    }
    for(i=9;i&gt;-1;i--)
    {
        fputs(a[i],p);
    }

    return 0;   
}
</code></pre>
",0
34209354,34180537,0,"<p>The following code works, compiles cleanly, performs error checking, reverses the order of the lines in the input file and always cleans up after itself.</p>

<pre><code>#define _GNU_SOURCE
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define MAX_LINES (100)

int main( void )
{
    int    i;

    char *a[MAX_LINES] = {NULL};  // initialize pointers for up to 100 lines
    FILE *fin = NULL;       // input file pointer
    FILE *fout = NULL;      // output file pointer

    if( NULL ==(fin=fopen(""Frozen_snowman.txt"",""r"") ) )
    { // then fopen failed
        perror( ""fopen for input file: Frozen Snowman.txt failed"");
        exit( EXIT_FAILURE );
    }

    // implied else, fopen for input successful

    if( NULL == (fout = fopen(""Reverse.txt"",""w"") ) )
    { // then fopen failed
        perror( ""fopen for output file Reverse.txt failed"");
        fclose( fin ); // close the file opened above
        exit( EXIT_FAILURE );
    }

    // implied else, fopen for output successful

    // read each line into allocated memory
    // and place allocated memory pointer in array
    i = 0;
    while( i &lt; MAX_LINES &amp;&amp; getline(&amp;(a[i]), NULL, fin) )
    {
        i++;
    }

    // count backwards through saved lines, printing them, then
    // returning the associated memory to the 'heap'
    for(i--; i&gt;=0; i--)
    {
        fputs( a[i],fout);
        free( a[i] );  // no longer need this line 
    }

    // close open files before exiting
    fclose( fin );
    fclose( fout );

    return 0;
} // end function: main
</code></pre>
",0
34205247,34205208,4,"<p>Remember math at school: logA_B = logA_C/logB_C</p>
",0
34205303,34205208,21,"<p>The C function <a href=""http://en.cppreference.com/w/c/numeric/math/log""><code>log</code></a> is the natural logarithm, which mathematicians usually write as ""ln"".</p>

<p>The C function <a href=""http://en.cppreference.com/w/c/numeric/math/log10""><code>log10</code></a> is the logarithm base 10, which is sometimes written ""log"".</p>
",0
34205356,34205208,1,"<pre><code>double ln(double x) { return log(x); }
</code></pre>

<p>Or in a pinch</p>

<pre><code>#define ln(x) log(x)
</code></pre>
",0
34210569,34210524,1,"<p>You can use something called the NDK to create statically linked libraries that Android can call. Remember these are linked libraries (.so files) and so they do not have a Main in the traditional sense. To find more information on that follow this link. <a href=""http://developer.android.com/tools/sdk/ndk/index.html"" rel=""nofollow"">http://developer.android.com/tools/sdk/ndk/index.html</a></p>

<p>It's important to note that you will still need to write some Java code but it allows you to do a lot of the non GUI work via C code.</p>

<p>On the flip side IOS programs are written in Objective-C which sounds similar to C but from what I've been told it's very far apart.</p>
",2
34259715,34259625,4,"<p>The<code>0x</code>part means the following number is in hexadecimal notation.</p>

<p>Since in hex, <code>0x10 == 16</code> and <code>0xb = 11</code>, we have:</p>

<pre><code>0x2B = 0x20 + 0xB = 32 + 11 = 43
</code></pre>

<p>So <code>0x2B</code> is<code>43</code>in decimal (the system we commonly use), and that's</p>

<pre><code>101011
</code></pre>

<p>in binary.</p>

<p>To clarify, no matter what notation you use (decimal or hexadecimal) to declare/overwrite variables in C, the result is the same.</p>

<pre><code>char a = 0x2B;
char b = 43;
if (a == b)
    printf(""But of course they're the same!\n"");
else
    printf(""This should not happen\n"");
</code></pre>
",0
34266939,34266773,3,"<p>Is this</p>

<pre><code>cpy[start++] = s[start++];
</code></pre>

<p>supposed to increment <code>start</code> once or twice? While you might know the answer, the compiler scratched its head.</p>

<p>There might be languages where this has a defined result (usually by order of evaluation from left to right), but C is not one of them (it's <em>undefined behavior</em>).</p>

<p>The word <strong>unsequenced</strong> in the error message refers to the C language concept of <strong>sequence points</strong>. In the shown expression there is only <em>one</em> sequence point -- the semicolon. But there are two post-increments. Which one should be executed first? C leaves this open^Wundefined.</p>
",0
34266837,34266773,5,"<pre><code>cpy[start++] = s[start++];
</code></pre>

<p>In this you modify <code>start</code> more than once without an intervening sequence point. This is <em>undefined behaviour</em>. Your compiler helpfully points that out. </p>

<p>If you want to copy the bytes from one location to another you probably don't want to modify <code>start</code> twice anyway. So, do:</p>

<pre><code>while (len &gt; 0)
{
   len--
   cpy[start] = s[start];
   start++;
}
</code></pre>

<p>Please read:   </p>

<p><a href=""https://stackoverflow.com/questions/4176328/undefined-behavior-and-sequence-points"">Undefined behaviour and sequence points</a></p>

<p><a href=""http://blog.regehr.org/archives/213"" rel=""nofollow noreferrer"">A Guide to Undefined Behavior in C and C++</a></p>

<p><a href=""http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html"" rel=""nofollow noreferrer"">What Every C Programmer Should Know About Undefined Behavior</a></p>

<p>for more informationn on this subject.</p>
",0
34266981,34266773,0,"<p>Quoting directly from <code>C11</code>, chapter ¡ì6.5.16, <em>Assignment operators</em>,</p>

<blockquote>
  <p>[...] The side effect of updating the stored value of the left operand is
  sequenced <strong>after the value computations of the left and right operands. The evaluations of
  the operands are unsequenced.</strong></p>
</blockquote>

<p>That means, in your code,</p>

<pre><code>cpy[start++] = s[start++];
</code></pre>

<p>you're making attempt to modify the value of <code>start</code> more than once without having a sequence point in between, which is plain wrong and will invoke <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow"">undefined behavior</a>.</p>
",0
