119121,119114,2,"<p>You can set preproccesor variables in the properties->c++->preprocessor<br>
in visual studio settings you can use $(enviromentvariable)</p>
",1
119127,119114,1,"<p>I generally use config files, then just create a symlink to the appropriate configuration.</p>
",0
119148,119114,6,"<p>On your home and work machines, set an environment variable <code>LOCATION</code> that is either ""1"" for home or ""2"" for work.</p>

<p>Then in the preprocessor options, add a preprocessor define /DLOCATION=$(LOCATION). This will evaluate to either the ""home"" or ""work"" string that you set in the environment variable.</p>

<p>Then in your code:</p>

<pre><code>#if LOCATION==1
  // home
#else
  // work
#endif
</code></pre>
",1
121330,119114,3,"<p>If the only difference between work and home is where the test files are located... then (IMHO) you shouldn't pollute your build files with a bunch of static paths &amp; IPs.</p>

<p>For the example you showed, I would simply map drives on both work and home. I.e. at work map a drive T: that points to \\212.45.68.43\Project\Blah\Test, at home map a drive T: that points to \\192.168.0.1\Test. </p>

<p>Then your build process uses the path ""T:\"" to refer to where tests reside. </p>

<p>Of course, if you need to change something more drastic, setting environment variables is probably the best way to go. </p>
",0
37451,37428,10,"<p>My favorites are Effective C++, More Effective C++, and Effective STL by Scott Meyers. Also C++ Coding Standards by Sutter and Alexandrescu.</p>
",0
37461,37428,7,"<p>The best way to get back into C++ is to jump in.  You can't learn a real language without spending any serious time in a country where they speak it.  I wouldn't try to learn a programming language without spending time coding in it either.</p>

<p>I wouldn't recommend learning C first though.  That's a good way to pick up some bad habits in C++.</p>
",0
37463,37428,6,"<p>I haven't tried it myself but have heard from people and sources I trust that ""Accelerated C++"" by Koenig and Moo is a good book for people who want to pick up C++ quickly. Compared to the more traditional route of learning C first then C++ as a kind of C with classes the K+M approach helps you become productive quickly while avoiding pitfalls and bad habits associated with the legacy of the language.</p>
",0
38191,37428,2,"<p>A good starting place is ""Thinking in C++"" by Bruce Eckel, I've rarely had anyone complain about the book. Well written and also has a version available online.</p>
",1
37723,37428,1,"<p><a href=""https://rads.stackoverflow.com/amzn/click/com/0201700735"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">The C++ Programming Language</a> by Bjarne Stroustrup covers C++ in depth. Bjarne is the inventor of C++. It also provides insights into why the language is the way it is. Some people find the book a little terse. I found it to be an enjoyable read. If you have done some C++ before it's a great place to start. It is by no means a beginners book on C++.</p>
",0
38185,37428,1,"<p>My book recommendations:  </p>

<p><strong>Essential C++</strong> (Lippman)<br>
<strong>C++ Common Knowledge: Essential Intermediate Programming</strong> (Dewhurst)<br>
...and I second the <strong>Effective C++</strong> suggestion above.</p>

<p>A very handy alternative to buying books in meatspace is to subscribe to a service like <a href=""http://techbus.safaribooksonline.com/home"" rel=""nofollow noreferrer"">Safari Books Online</a>. For a not unreasonable monthly fee you'll get access to all of the above books plus a bajillion others. If you desire fast random access to more than a couple books, it pretty much pays for itself. It's an easy case to make if you want to convince your employer to pay for it. </p>

<p>Beyond that, sit yourself in front of an IDE that has a C++ code completion feature (I use Eclipse/CDT most of the time).</p>
",0
38640,37428,2,"<p>Another online book that I pick up whenever I need to get back into C++ is ""C++ In Action"" by Bartosz Milewski. Its <a href=""http://www.relisoft.com/book/index.htm"" rel=""nofollow noreferrer"">online</a> at his site.</p>
",1
325736,325734,8,"<p>You should have them in the order you want them initialised, because that's the order they will be initialised, regardless of your initialiser list within the constructor. Not all compilers will warn you about inconsistencies, either.</p>
",1
325740,325734,12,"<p>I group them according to semantics, i.e.</p>

<pre><code>class Foo
{
private:
    std::string peach;
    bool banana;
    int apple;

    int red;
    std::string green;
    std::string blue;
    ...
};
</code></pre>

<p>The more readable, the better.</p>
",1
325748,325734,2,"<p>If you care about the size of your objects, and if the compiler doesn't re-order members within a class (if there are no access-specifiers between the members, it must not reorder), then the objects might come out smaller if you order your members from biggest to smallest. The reason is that there is less likely to be a need for padding to satisfy alignment requirements. This ordering will result in members of the same type being closer together.</p>

<p>Compared with code clarity, this usually loses. Compared with initialization order of course it always loses (although you can add access-specifiers and hope for the best). But you did ask if there's <em>any</em> benefit.</p>
",0
325845,325734,0,"<p>In most cases you should not have too many members in a structure. </p>

<p>If you do, maybe you should think about substructures...</p>

<p>I know there are exceptions, but as a general rule of thumb, try to keep your structures small.</p>
",0
325876,325734,0,"<p>In order of effective priority :</p>

<p>0) IF members have dependencies between them on construction OR if members need to be constructed in a specific order : declare them in the order of construction you wish to be exectued. On construction, the only order of member construction is the member order of declaration in the class.</p>

<p>0.5) IF the class instance object size matters (you want the minimum size for this type - but dont do early optimization!), with some compilers it is better to order your members in size order, the bigger the first, for byte alignement or other similar behavior on compilation.</p>

<p>1) Prioritize CLARITY first : write for the reader first (be clear, order in thematic/purpose groups, etc), then for the compiler (maybe following the previous advices).</p>

<p>In almost all cases, only 1) is important. Prefer thematic, purpose and ""composants of the same system"" for grouping members over grouping by type.</p>

<p>Note : if you group your members by system and you see you have lot of groups, maybe you should encapsulate those systems in classes.</p>
",0
325835,325734,1,"<ol>
<li>Group semantically.</li>
<li>If you need to group semantically, it's a code smell.  Extract a class.  Lucky for you, related members are already in a group, so it's easy to pick the right ones to move.</li>
</ol>
",0
325991,325734,0,"<p>I agree with the others about some reasons for ordering the variables, but beyond that, I like to see the variables that are most important to the class functioning near the beginning, and the variables that are less important near the end.  If you have other reasons to override this, fine, but when other things fail, that's what I do.</p>

<p>Of course, this usually ends up happening by declaring the variables in the order they occur to me.  The most important variables are the ones I think of first, and the others I encounter as I'm actually writing the class implementation.</p>
",0
326030,325734,1,"<p>From Steve McConnell's Code Complete, p762:-</p>

<blockquote>
  <p><strong>Order declarations sensibly</strong>: ...
  Grouping by types is usually sensible since variables of the same type tend to be used in related operations
  ... If your list of variables is so
  long that alphabetical ordering helps,
  your routine is probably too big.</p>
</blockquote>

<p>Also, on the previous page, he lays into the style from my previous answer showing multiple declarations ""crowded"" onto one line...</p>

<pre><code>bool a_, b_, c_;
</code></pre>

<p>... with a ""Coding Horror"" icon. So I'm reconsidering that approach. Thanks to commenters for making me reevaluate this.</p>
",0
84494,84427,-1,"<p>It is legal. We use it sometime to provide a default value which we might want to ignore.</p>

<pre><code>int dosomething(error_code&amp; _e = ignore_errorcode()) {
    //do something
}
</code></pre>

<p>In the above case it will construct an empty error code object if no <code>error_code</code> is passed to the function.</p>
",1
84505,84427,-1,"<p>for //2 you need a const reference</p>

<p>for //1 I think it's legal but useless</p>
",1
84521,84427,10,"<p>No, it's against the standard to pass a non-const reference to a temporary object. You can use a const reference:</p>

<pre><code>class A{};

void bar(const A&amp;);

int main(void)
{
    bar(A());  // 2
}
</code></pre>

<p>So while some compliers will accept it, and it would work as long as don't use the memory after the semicolon, a conforming compiler will not accept it.</p>
",0
84457,84427,-2,"<p>Perfectly legal.</p>

<p>The object will exist on the stack during the function call, just like any other local variable as well. </p>
",0
84471,84427,0,"<p>It looked lke it would work, but it did not compile with g++ with the Wall option, here is what I get:</p>

<pre>
michael@hardy-lenovo:~/Desktop$ g++ -Wall a.cpp
a.cpp: In function ¡®int main()¡¯:michael@hardy-lenovo:~/Desktop$ g++ -Wall a.cpp
a.cpp: In function ¡®int main()¡¯:
a.cpp:8: warning: taking address of temporary
a.cpp:9: error: invalid initialization of non-const reference of type ¡®A&¡¯ from a temporary of type ¡®A¡¯
a.cpp:4: error: in passing argument 1 of ¡®void bar(A&)¡¯
michael@hardy-lenovo:~/Desktop$ 
</pre>

<p>Looks like you will need to use a constant reference.</p>
",1
84475,84427,1,"<p>Those A objects will only exist until execution reaches the semicolon.  So, the calls are safe, but don't try to save the pointer and use it later.   Also, the compiler may require bar take a const reference.</p>
",1
84562,84427,16,"<p>1: Taking the address of a temporary is not allowed. Visual C++ allows it as a language extension (language extensions are on by default).</p>

<p>2: This is perfectly legal.</p>
",3
89059,84427,6,"<p><em>foo</em> is not allowed in fully standard compliant C++, whereas <em>bar</em> is okay. Though chances are, <em>foo</em> will compile with warning, and <em>bar</em> may or may not compile with a warning as well.</p>

<p><em>A()</em> create a temporary object, which unless bound to a reference (as is the case in <em>bar</em>), or used to initialize a named object, is destroyed at the end of the full expression in which it was created. A temporary created to hold a reference initializer persists until the end of its reference's scope. For the case of <em>bar</em>, that's the function call, so you can use <em>A</em> inside <em>bar</em> perfectly safely. It is forbidden to bound a temporary object (which is a rvalue) to a non-const reference. It is similarly forbidden to take the address of a rvalue (to pass as argument to initialize <em>A</em> for <em>foo</em>).</p>
",2
373147,373142,4,"<p>I had an idea about <a href=""https://stackoverflow.com/questions/354254/ramdrive-for-compiling-is-there-such-a-thing"">using a RAM drive</a>. It turned out that for my projects it doesn't make that much of a difference after all. But then they are pretty small still. Try it! I'd be interested in hearing how much it helped.</p>
",7
373148,373142,2,"<p>If you have a multicore processor, both Visual Studio (2005 and later) as well as <a href=""http://en.wikipedia.org/wiki/GNU_Compiler_Collection"" rel=""nofollow noreferrer"">GCC</a> support multi-processor compiles. It is something to enable if you have the hardware, for sure.</p>
",1
373263,373142,6,"<p>You could use <a href=""http://buffered.io/posts/the-magic-of-unity-builds/"" rel=""nofollow noreferrer"">Unity Builds</a>.</p>

<p>??</p>
",2
373158,373142,16,"<p>I will just link to my other answer: <em><a href=""https://stackoverflow.com/questions/364240/how-do-you-reduce-compile-time-and-linking-time-for-visual-c-projects-native-c#364257"">How do YOU reduce compile time, and linking time for Visual C++ projects (native C++)?</a></em>. Another point I want to add, but which causes often problems is to use precompiled headers. But please, only use them for parts which hardly ever change (like GUI toolkit headers). Otherwise, they will cost you more time than they save you in the end.</p>

<p>Another option is, when you work with GNU make, to turn on <code>-j&lt;N&gt;</code> option:</p>

<pre><code>  -j [N], --jobs[=N]          Allow N jobs at once; infinite jobs with no arg.
</code></pre>

<p>I usually have it at <code>3</code> since I've got a dual core here. It will then run compilers in parallel for different translation units, provided there are no dependencies between them. Linking cannot be done in parallel, since there is only one linker process linking together all object files.</p>

<p>But the linker itself can be threaded, and this is what the <a href=""http://sourceware.org/ml/binutils/2008-03/msg00162.html"" rel=""nofollow noreferrer""><code>GNU gold</code></a> <a href=""https://en.wikipedia.org/wiki/Executable_and_Linkable_Format"" rel=""nofollow noreferrer"">ELF</a> linker does. It's optimized threaded C++ code which is said to link ELF object files a magnitude faster than the old <code>ld</code> (and was actually included into <a href=""https://en.wikipedia.org/wiki/GNU_Binutils"" rel=""nofollow noreferrer"">binutils</a>).</p>
",2
373165,373142,12,"<p>Here are some:</p>

<ul>
<li>Use all processor cores by starting a multiple-compile job (<code>make -j2</code> is a good example).</li>
<li>Turn off or lower optimizations (for example, GCC is much faster with <code>-O1</code> than <code>-O2</code> or <code>-O3</code>).</li>
<li>Use <a href=""http://en.wikipedia.org/wiki/Precompiled_header"" rel=""nofollow noreferrer"">precompiled headers</a>.</li>
</ul>
",3
373166,373142,4,"<ul>
<li><p>Upgrade your computer</p>

<ol>
<li>Get a quad core (or a dual-quad system)</li>
<li>Get LOTS of RAM.</li>
<li>Use a RAM drive to drastically reduce file I/O delays. (There are companies that make IDE and SATA RAM drives that act like hard drives).</li>
</ol></li>
<li><p>Then you have all your other typical suggestions</p>

<ol>
<li>Use precompiled headers if available.</li>
<li>Reduce the amount of coupling between parts of your project.  Changing one header file usually shouldn't require recompiling your entire project.</li>
</ol></li>
</ul>
",0
373171,373142,6,"<p>Use</p>

<pre><code>#pragma once
</code></pre>

<p>at the top of header files, so if they're included more than once in a translation unit, the text of the header will only get included and parsed once.</p>
",2
373173,373142,9,"<p>When I came out of college, the first real production-worthy C++ code I saw had these arcane #ifndef ... #endif directives in between them where the headers were defined. I asked the guy who was writing the code about these overarching things in a very naive fashion and was introduced to world of large-scale programming.</p>

<p>Coming back to the point, using directives to prevent duplicate header definitions was the first thing I learned when it came to reducing compiling times.</p>
",2
373179,373142,267,"<h2>Language techniques</h2>

<h3>Pimpl Idiom</h3>

<p>Take a look at the <em><a href=""https://en.wikipedia.org/wiki/Opaque_pointer"" rel=""noreferrer"">Pimpl idiom</a></em> <a href=""http://www.gotw.ca/gotw/028.htm"" rel=""noreferrer"">here</a>, and <a href=""http://www.gotw.ca/gotw/024.htm"" rel=""noreferrer"">here</a>, also known as an <a href=""http://en.wikipedia.org/wiki/Opaque_pointer"" rel=""noreferrer"">opaque pointer</a> or handle classes. Not only does it speed up compilation, it also increases exception safety when combined with a <a href=""http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Non-throwing_swap"" rel=""noreferrer"">non-throwing swap</a> function. The Pimpl idiom lets you reduce the dependencies between headers and reduces the amount of recompilation that needs to be done.</p>

<h3>Forward Declarations</h3>

<p>Wherever possible, use <a href=""http://www.gotw.ca/publications/mill04.htm"" rel=""noreferrer"">forward declarations</a>. If the compiler only needs to know that <code>SomeIdentifier</code> is a struct or a pointer or whatever, don't include the entire definition, forcing the compiler to do more work than it needs to. This can have a cascading effect, making this way slower than they need to be.</p>

<p>The <a href=""http://en.wikipedia.org/wiki/Input/output"" rel=""noreferrer"">I/O</a> streams are particularly known for slowing down builds. If you need them in a header file, try #including <code>&lt;iosfwd&gt;</code> instead of <code>&lt;iostream&gt;</code> and #include the <code>&lt;iostream&gt;</code> header in the implementation file only.  The <code>&lt;iosfwd&gt;</code> header holds forward declarations only. Unfortunately the other standard headers don't have a respective declarations header.</p>

<p>Prefer pass-by-reference to pass-by-value in function signatures. This will eliminate the need to #include the respective type definitions in the header file and you will only need to forward-declare the type. Of course, prefer const references to non-const references to avoid obscure bugs, but this is an issue for another question.</p>

<h3>Guard Conditions</h3>

<p>Use guard conditions to keep header files from being included more than once in a single translation unit.</p>

<pre><code>#pragma once
#ifndef filename_h
#define filename_h

// Header declarations / definitions

#endif
</code></pre>

<p>By using both the pragma and the ifndef, you get the portability of the plain macro solution, as well as the compilation speed optimization that some compilers can do in the presence of the <code>pragma once</code> directive.</p>

<h3>Reduce interdependency</h3>

<p>The more modular and less interdependent your code design is in general, the less often you will have to recompile everything. You can also end up reducing the amount of work the compiler has to do on any individual block at the same time, by virtue of the fact that it has less to keep track of.</p>

<h2>Compiler options</h2>

<h3>Precompiled Headers</h3>

<p>These are used to compile a common section of included headers once for many translation units. The compiler compiles it once, and saves its internal state. That state can then be loaded quickly to get a head start in compiling another file with that same set of headers.</p>

<p>Be careful that you only include rarely changed stuff in the precompiled headers, or you could end up doing full rebuilds more often than necessary. This is a good place for <a href=""http://en.wikipedia.org/wiki/Standard_Template_Library"" rel=""noreferrer"">STL</a> headers and other library include files.</p>

<p><a href=""http://ccache.samba.org/"" rel=""noreferrer"">ccache</a> is another utility that takes advantage of caching techniques to speed things up.</p>

<h3>Use Parallelism</h3>

<p>Many compilers / IDEs support using multiple cores/CPUs to do compilation simultaneously. In <a href=""https://en.wikipedia.org/wiki/Make_%28software%29#Derivatives"" rel=""noreferrer"">GNU Make</a> (usually used with GCC), use the <code>-j [N]</code> option. In Visual Studio, there's an option under preferences to allow it to build multiple projects in parallel. You can also use the <a href=""http://msdn.microsoft.com/en-us/library/bb385193.aspx"" rel=""noreferrer""><code>/MP</code> option</a> for file-level paralellism, instead of just project-level paralellism.</p>

<p>Other parallel utilities:</p>

<ul>
<li><a href=""http://www.xoreax.com/main.htm"" rel=""noreferrer"">Incredibuild</a></li>
<li><a href=""http://buffered.io/posts/the-magic-of-unity-builds/"" rel=""noreferrer"">Unity Build</a></li>
<li><a href=""http://distcc.org/"" rel=""noreferrer"">distcc</a></li>
</ul>

<h3>Use a Lower Optimization Level</h3>

<p>The more the compiler tries to optimize, the harder it has to work.</p>

<h3>Shared Libraries</h3>

<p>Moving your less frequently modified code into libraries can reduce compile time. By using shared libraries (<code>.so</code> or <code>.dll</code>), you can reduce linking time as well.</p>

<h2>Get a Faster Computer</h2>

<p>More RAM, faster hard drives (including SSDs), and more CPUs/cores will all make a difference in compilation speed.</p>
",18
373215,373142,6,"<p>Use forward declarations where you can. If a class declaration only uses a pointer or reference to a type, you can just forward declare it and include the header for the type in the implementation file.</p>

<p>For example:</p>

<pre><code>// T.h
class Class2; // Forward declaration

class T {
public:
    void doSomething(Class2 &amp;c2);
private:
    Class2 *m_Class2Ptr;
};

// T.cpp
#include ""Class2.h""
void Class2::doSomething(Class2 &amp;c2) {
    // Whatever you want here
}
</code></pre>

<p>Fewer includes means far less work for the preprocessor if you do it enough.</p>
",2
373325,373142,5,"<p>Just for completeness: a build might be slow because the build system is being stupid as well as because the compiler is taking a long time to do its work. </p>

<p>Read <em><a href=""http://aegis.sourceforge.net/auug97.pdf"" rel=""nofollow noreferrer"">Recursive Make Considered Harmful</a></em> (PDF) for a discussion of this topic in Unix environments.</p>
",0
373224,373142,34,"<p>I'd recommend these articles from ""Games from Within, Indie Game Design And Programming"":</p>

<ul>
<li><a href=""http://gamesfromwithin.com/physical-structure-and-c-part-1-a-first-look"" rel=""noreferrer"">Physical Structure and C++ ¨C Part 1: A First Look</a></li>
<li><a href=""http://gamesfromwithin.com/physical-structure-and-c-part-2-build-times"" rel=""noreferrer"">Physical Structure and C++ ¨C Part 2: Build Times</a></li>
<li><a href=""http://gamesfromwithin.com/even-more-experiments-with-includes"" rel=""noreferrer"">Even More Experiments with Includes</a></li>
<li><a href=""http://gamesfromwithin.com/how-incredible-is-incredibuild"" rel=""noreferrer"">How Incredible Is Incredibuild?</a></li>
<li><a href=""http://gamesfromwithin.com/the-care-and-feeding-of-pre-compiled-headers"" rel=""noreferrer"">The Care and Feeding of Pre-Compiled Headers</a></li>
<li><a href=""http://gamesfromwithin.com/the-quest-for-the-perfect-build-system"" rel=""noreferrer"">The Quest for the Perfect Build System</a></li>
<li><a href=""http://gamesfromwithin.com/the-quest-for-the-perfect-build-system-part-2"" rel=""noreferrer"">The Quest for the Perfect Build System (Part 2)</a></li>
</ul>

<p>Granted, they are pretty old - you'll have to re-test everything with the latest versions (or versions available to you), to get realistic results. Either way, it is a good source for ideas.</p>
",0
373866,373142,12,"<p>Once you have applied all the code tricks above (forward declarations, reducing header inclusion to the minimum in public headers, pushing most details inside the implementation file with <a href=""https://en.wikipedia.org/wiki/Opaque_pointer"" rel=""nofollow noreferrer"">Pimpl</a>...) and nothing else can be gained language-wise, consider your build system. If you use Linux, consider using <a href=""https://en.wikipedia.org/wiki/Distcc"" rel=""nofollow noreferrer"">distcc</a> (distributed compiler) and <a href=""https://en.wikipedia.org/wiki/Ccache"" rel=""nofollow noreferrer"">ccache</a> (cache compiler).</p>

<p>The first one, distcc, executes the preprocessor step locally and then sends the output to the first available compiler in the network. It requires the same compiler and library versions in all the configured nodes in the network.</p>

<p>The latter, ccache, is a compiler cache. It again executes the preprocessor and then check with an internal database (held in a local directory) if that preprocessor file has already been compiled with the same compiler parameters. If it does, it just pops up the binary and output from the first run of the compiler.</p>

<p>Both can be used at the same time, so that if ccache does not have a local copy it can send it trough the net to another node with distcc, or else it can just inject the solution without further processing.</p>
",1
373730,373142,3,"<p>Where are you spending your time? Are you CPU bound? Memory bound? Disk bound? Can you use more cores? More RAM? Do you need RAID? Do you simply want to improve the efficiency of your current system?</p>

<p>Under gcc/g++, have you looked at <a href=""http://ccache.samba.org/"" rel=""nofollow noreferrer"">ccache</a>? It can be helpful if you are doing <code>make clean; make</code> a lot.</p>
",0
375532,373142,3,"<p>Dynamic linking (.so) can be much much faster than static linking (.a).  Especially when you have a slow network drive.  This is since you have all of the code in the .a file which needs to be processed and written out.  In addition, a much larger executable file needs to be written out to the disk.</p>
",1
395023,373142,8,"<p>More RAM.</p>

<p>Someone talked about RAM drives in another answer. I did this with a <a href=""https://en.wikipedia.org/wiki/Intel_80286"" rel=""noreferrer"">80286</a> and <a href=""https://en.wikipedia.org/wiki/Turbo_C%2B%2B"" rel=""noreferrer"">Turbo C++</a> (shows age) and the results were phenomenal. As was the loss of data when the machine crashed.</p>
",2
399464,373142,15,"<p>There's an entire book on this topic, which is titled <em><a href=""http://www.informit.com/store/large-scale-c-plus-plus-software-design-9780201633627"" rel=""nofollow noreferrer"">Large-Scale C++ Software Design</a></em> (written by John Lakos).</p>

<p>The book pre-dates templates, so to the contents of that book add ""using templates, too, can make the compiler slower"".</p>
",2
49036,49035,1,"<p>that will cause the method to not be able to alter any member variables of the object</p>
",0
49039,49035,3,"<p>Functions with <code>const</code> qualifier are not allowed to modify any member variables. For example:</p>

<pre><code>class A
{
    int x;
    mutable int y;

    void f() const
    {
      x = 1; // error
      y = 1; // ok because y is mutable
    }
};
</code></pre>
",0
49044,49035,2,"<p>C++ objects can be declared to be const:</p>

<pre><code>const A obj = new A();
</code></pre>

<p>When an object is const, the only member functions that can be called on that object are functions declared to be const.  Making an object const can be interpreted as making the object readonly.  A const object cannot be changed, i.e. no data members of the object can be changed.  Declaring a member function const means that the function is not allowed to make any changes to the data members of the object.</p>
",1
49056,49035,12,"<p>Consider a variation of your class <code>A</code>.</p>

<pre><code>class A {
public:
    void Foo() const;
    void Moo();

private:
    int m_nState; // Could add mutable keyword if desired
    int GetState() const   { return m_nState; }
    void SetState(int val) { m_nState = val; }
};

const A *A1 = new A();
A *A2 = new A();

A1-&gt;Foo(); // OK
A2-&gt;Foo(); // OK

A1-&gt;Moo(); // Error - Not allowed to call non-const function on const object instance
A2-&gt;Moo(); // OK
</code></pre>

<p>The <code>const</code> keyword on a function declaration indicates to the compiler that the function is contractually obligated not to modify the state of <code>A</code>. Thus you are unable to call non-<code>const</code> functions within <code>A::Foo</code> nor change the value of member variables.</p>

<p>To illustrate, <em>Foo()</em> may not invoke <code>A::SetState</code> as it is declared non-<code>const</code>, <code>A::GetState</code> however is ok because it is explicitly declared <code>const</code>. The member <code>m_nState</code> may not be changed either unless declared with the keyword <code>mutable</code>.</p>

<p>One example of this usage of <code>const</code> is for 'getter' functions to obtain the value of member variables.</p>

<blockquote>
  <p>@1800 Information: I forgot about mutable!</p>
</blockquote>

<p>The <code>mutable</code> keyword instructs the compiler to accept modifications to the member variable which would otherwise cause a compiler error. It is used when the function needs to modify state but the object is considered logically consistent (constant) regardless of the modification.</p>
",0
49076,49035,5,"<p>This is not an answer, just a side comment.  It is <strong>highly</strong> recommended to declare variables and constants <code>const</code> as much as possible.  </p>

<ol>
<li>This communicates your intent to users of your class (even/especially yourself).</li>
<li>The compiler will keep you honest to those intentions. -- i.e., it's like compiler checked documentation.</li>
<li>By definition, this prevents state changes you weren't expecting and can, possibly, allow you to make reasonable assumptions while in your methods.</li>
<li><code>const</code> has a funny way of propagating through your code.  Thus, it's a really good idea to start using <code>const</code> as early and as often as possible.  Deciding to start <code>const</code>-ifying your code late in the game can be painful (easy, but annoying).</li>
</ol>

<p>If you're using a language with static, compile time checks it's a great idea to make as much use of them as possible... it's just another kind of testing really.</p>
",0
58843,49035,2,"<p>Two suggested best practices from experience:</p>

<p>(1) <strong>Declare const functions whenever possible</strong>.  At first, I found this to be just extra work, but then I started passing my objects to functions with signatures like f(const Object&amp; o), and suddenly the compiler barfed on a line in f such as o.GetAValue(), because I hadn't marked GetAValue as a const function.  This can surprise you especially when you subclass something and don't mark your version of the virtual methods as const - in that case the compile could fail on some function you've never heard of before that was written for the base class.</p>

<p>(2) <strong>Avoid mutable variables</strong> when it's practical.  A tempting trap can be to allow read operations to alter state, such as if you're building a ""smart"" object that does lazy or asynchronous i/o operations.  If you can manage this with only one small mutable variable (like a bool), then, in my experience, this makes sense.  However, if you find yourself marking every member variable as mutable in order to keep some operations const, you're defeating the purpose of the const keyword.  What can go wrong is that a function which thinks it's not altering your class (since it only calls const methods) my invoke a bug in your code, and it could take a lot of effort to even realize this bug is in your class, since the other coder (rightly) assumes your data is const because he or she is only calling const methods.</p>
",0
60123,49035,2,"<blockquote>
  <p>const has a funny way of propagating through your code. Thus, it's a really good idea to start using const as early and as often as possible. Deciding to start const-ifying your code late in the game can be painful (easy, but annoying).</p>
</blockquote>

<p>Additionally, you will easily run into problems if methods that should be const aren't! This will creep through the code as well, and make it worse and worse.</p>
",0
321075,321068,2,"<p>Alternatives include arrays, <a href=""http://en.wikipedia.org/wiki/Generator_(computer_science)"" rel=""nofollow noreferrer"">generators</a>, and <a href=""http://en.wikipedia.org/wiki/Inversion_of_Control"" rel=""nofollow noreferrer"">inversion of control</a>, but none is appropriate here.</p>

<p>Some (e.g. Microsoft in historical Win32) tend to use reference parameters for simplicity, because it's clear who allocates and how it will look on the stack, reduces the proliferation of structures, and allows a separate return value for success.</p>

<p>""Pure"" programmers prefer the struct, assuming it <em>is</em> the function value (as is the case here), rather than something that's touched incidentally by the function.  If you had a more complicated procedure, or something with state, you'd probably use references (assuming you have a reason for not using a class).</p>
",0
321216,321068,4,"<p>If your function returns a value via reference, the compiler cannot store it in a register when calling other functions because, theoretically, the first function can save the address of the variable passed to it in a globally accessible variable, and any subsecuently called functions may change it, so the compiler will have (1) save the value from registers back to memory before calling other functions and (2) re-read it when it is needed from the memory again after any of such calls.</p>

<p>If you return by reference, optimization of your program will suffer</p>
",0
321079,321068,17,"<p>It's entirely dependent upon the actual function and the meaning of the multiple values, and their sizes:</p>

<ul>
<li>If they're related as in your fraction example, then I'd go with a struct or class instance.</li>
<li>If they're not really related and can't be grouped into a class/struct then perhaps you should refactor your method into two.</li>
<li>Depending upon the in-memory size of the values you're returning, you may want to return a pointer to a class instance or struct, or use reference parameters.</li>
</ul>
",1
321080,321068,265,"<p>For returning two values I use a <code>std::pair</code> (usually typedef'd).  You should look at <code>boost::tuple</code> (in C++11 and newer, there's <code>std::tuple</code>) for more than two return results.</p>

<p>With introduction of structured binding in C++ 17, returning <code>std::tuple</code> should probably become accepted standard.</p>
",11
321082,321068,30,"<pre><code>std::pair&lt;int, int&gt; divide(int dividend, int divisor)
{
   // :
   return std::make_pair(quotient, remainder);
}

std::pair&lt;int, int&gt; answer = divide(5,2);
 // answer.first == quotient
 // answer.second == remainder
</code></pre>

<p>std::pair is essentially your struct solution, but already defined for you, and ready to adapt to any two data types. </p>
",3
321084,321068,3,"<p>I tend to use out-vals in functions like this, because I stick to the paradigm of a function returning success/error codes and I like to keep things uniform.  </p>
",0
321142,321068,2,"<p>I'd say there is no preferred method, it all depends on what you're going to do with the response. If the results are going to be used together in further processing then structures make sense, if not I'd tend to pass then as individual references unless the function was going to be used in a composite statement:</p>

<p><code>x = divide( x, y, z ) + divide( a, b, c );</code></p>

<p>I often choose to pass 'out structures' by reference in the parameter list rather than having the pass by copy overhead of returning a new structure (but this is sweating the small stuff).</p>

<p><code>void divide(int dividend, int divisor, Answer &amp;ans)</code> </p>

<p>Are out parameters confusing? A parameter sent as reference suggests the value is going to change (as opposed to a const reference). Sensible naming also removes confusion.</p>
",1
321157,321068,1,"<p>Boost tuple would be my preferred choice for a generalized system of returning more than one value from a function. </p>

<p>Possible example:</p>

<pre><code>include ""boost/tuple/tuple.hpp""

tuple &lt;int,int&gt; divide( int dividend,int divisor ) 

{
  return make_tuple(dividend / divisor,dividend % divisor )
}
</code></pre>
",0
321542,321068,5,"<p>Use a struct or a class for the return value. Using <code>std::pair</code> may work for now, but </p>

<ol>
<li>it's inflexible if you decide later you want more info returned; </li>
<li>it's not very clear from the function's declaration in the header what is being returned and in what order.</li>
</ol>

<p>Returning a structure with self-documenting member variable names will likely be less bug-prone for anyone using your function. Putting my coworker hat on for a moment, your <code>divide_result</code> structure is easy for me, a potential user of your function, to immediately understand after 2 seconds. Messing around with ouput parameters or mysterious pairs and tuples would take more time to read through and may be used incorrectly. And most likely even after using the function a few times I still won't remember the correct order of the arguments.</p>
",0
321431,321068,146,"<p>Personally, I generally dislike return parameters for a number of reasons:</p>
<ul>
<li>it is not always obvious in the invocation which parameters are ins and which are outs</li>
<li>you generally have to create a local variable to catch the result, while return values can be used inline (which may or may not be a good idea, but at least you have the option)</li>
<li>it seems cleaner to me to have an &quot;in door&quot; and an &quot;out door&quot; to a function -- all the inputs go in here, all the outputs come out there</li>
<li>I like to keep my argument lists as short as possible</li>
</ul>
<p>I also have some reservations about the pair/tuple technique.  Mainly, there is often no natural order to the return values.  How is the reader of the code to know whether <code>result.first</code> is the quotient or the remainder?  And the implementer could change the order, which would break existing code.  This is especially insidious if the values are the same type so that no compiler error or warning would be generated.  Actually, these arguments apply to return parameters as well.</p>
<p>Here's another code example, this one a bit less trivial:</p>
<pre><code>pair&lt;double,double&gt; calculateResultingVelocity(double windSpeed, double windAzimuth,
                                               double planeAirspeed, double planeCourse);

pair&lt;double,double&gt; result = calculateResultingVelocity(25, 320, 280, 90);
cout &lt;&lt; result.first &lt;&lt; endl;
cout &lt;&lt; result.second &lt;&lt; endl;
</code></pre>
<p>Does this print groundspeed and course, or course and groundspeed?  It's not obvious.</p>
<p>Compare to this:</p>
<pre><code>struct Velocity {
    double speed;
    double azimuth;
};
Velocity calculateResultingVelocity(double windSpeed, double windAzimuth,
                                    double planeAirspeed, double planeCourse);

Velocity result = calculateResultingVelocity(25, 320, 280, 90);
cout &lt;&lt; result.speed &lt;&lt; endl;
cout &lt;&lt; result.azimuth &lt;&lt; endl;
</code></pre>
<p>I think this is clearer.</p>
<p>So I think my first choice, in general, is the struct technique.  The pair/tuple idea is likely a great solution in certain cases.  I'd like to avoid the return parameters when possible.</p>
",6
321551,321068,13,"<p>The OO solution for this is to create a ratio class.  It wouldn't take any extra code (would save some), would be significantly cleaner/clearer, and would give you some extra refactorings letting you clean up code outside this class as well.</p>

<p>Actually I think someone recommended returning a structure, which is close enough but hides the intent that this needs to be a fully thought-out class with constructor and a few methods, in fact, the ""method"" that you originally mentioned (as returning the pair) should most likely be a member of this class returning an instance of itself.</p>

<p>I know your example was just an ""Example"", but the fact is that unless your function is doing way more than any function should be doing, if you want it to return multiple values you are almost certainly missing an object.</p>

<p>Don't be afraid to create these tiny classes to do little pieces of work--that's the magic of OO--you end up breaking it down until every method is very small and simple and every class small and understandable. </p>

<p>Another thing that should have been an indicator that something was wrong: in OO you have essentially no data--OO isn't about passing around data, a class needs to manage and manipulate it's own data internally, any data passing (including accessors) is a sign that you may need to rethink something..</p>
",2
321528,321068,10,"<p>There is precedent for returning structures in the C (and hence C++) standard with the <code>div</code>, <code>ldiv</code> (and, in C99, <code>lldiv</code>) functions from <code>&lt;stdlib.h&gt;</code> (or <code>&lt;cstdlib&gt;</code>).</p>

<p>The 'mix of return value and return parameters' is usually the least clean.</p>

<p>Having a function return a status and return data via return parameters is sensible in C; it is less obviously sensible in C++ where you could use exceptions to relay failure information instead.</p>

<p>If there are more than two return values, then a structure-like mechanism is probably best.</p>
",0
140942,140935,20,"<p>Try inheritance</p>

<p>Specifically</p>

<pre><code>class AllPlatforms {
public:
    int common();
};
</code></pre>

<p>and then</p>

<pre><code>class PlatformA : public AllPlatforms {
public:
    int specific();
};
</code></pre>
",0
140944,140935,40,"<p>This is not possible in C++, it will give you an error about redefining already-defined classes. If you'd like to share behavior, consider inheritance.</p>
",0
140958,140935,2,"<p>As written, it is not possible.</p>

<p>You may want to look into namespaces. You can add a function to a namespace in another file. The problem with a class is that each .cpp needs to see the full layout of the class.</p>
",0
140966,140935,2,"<p>Nope.</p>

<p>But, you may want to look up a technique called ""Policy Classes"".  Basically, you make micro-classes (that aren't useful on their own) then glue them together at some later point.</p>
",1
140967,140935,1,"<p>Declaring a class body twice will likely generate a type redefinition error.  If you're looking for a work around.  I'd suggest #ifdef'ing, or using an <a href=""http://en.wikipedia.org/wiki/Abstract_base_class"" rel=""nofollow noreferrer"">Abstract Base Class</a> to hide platform specific details.</p>
",0
140969,140935,2,"<p>Either use inheritance, as Jamie said, or #ifdef to make different parts compile on different platforms.</p>
",0
140978,140935,2,"<p>Since headers are just textually inserted, one of them could omit the ""class Test {"" and ""}"" and be #included in the middle of the other.</p>

<p>I've actually seen this in production code, albeit Delphi not C++. It particularly annoyed me because it broke the IDE's code navigation features.</p>
",1
141028,140935,2,"<blockquote>
  <p>For me it seems quite useful for definining multi-platform classes that have common functions between them that are platform-independent.</p>
</blockquote>

<p>Except developers have been doing this for decades without this 'feature'.</p>

<p>I believe partial was created because Microsoft has had, for decades also, a bad habit of generating code and handing it off to developers to develop and maintain.</p>

<p>Generated code is often a maintenance  nightmare.  What habits to that entire MFC generated framework when you need to bump your MFC version?  Or how do you port all that code in *.designer.cs files when you upgrade Visual Studio?</p>

<p>Most other platforms rely more heavily on generating <strong>configuration files</strong> instead that the user/developer can modify.  Those, having a more limited vocabulary and not prone to be mixed with unrelated code.  The configuration files can even be inserted in the binary as a resource file if deemed necessary.</p>

<p>I have never seen 'partial' used in a place where inheritance or a configuration resource file wouldn't have done a better job.</p>
",2
141043,140935,1,"<p>You can get something like partial classes using <em>template specialization</em> and <em>partial specialization</em>.  Before you invest too much time, check your compiler's support for these.  Older compilers like MSC++ 6.0 didn't support partial specialization.</p>
",0
141085,140935,11,"<p>or you could try PIMPL</p>

<p>common header file:</p>

<pre><code>class Test
{
public:
    ...
    void common();
    ...
private:
    class TestImpl;
    TestImpl* m_customImpl;
};
</code></pre>

<p>Then create the cpp files doing the custom implementations that are platform specific.</p>
",0
141092,140935,4,"<p>How about this:</p>

<pre><code>class WindowsFuncs { public: int f(); int winf(); };
class MacFuncs { public: int f(); int macf(); }

class Funcs
#ifdef Windows 
    : public WindowsFuncs
#else
    : public MacFuncs
#endif
{
public:
    Funcs();
    int g();
};
</code></pre>

<p>Now <code>Funcs</code> is a class known at compile-time, so no overheads are caused by abstract base classes or whatever.</p>
",1
141482,140935,9,"<pre><code>#include will work as that is preprocessor stuff.

class Foo
{
#include ""FooFile_Private.h""
}

////////

FooFile_Private.h:

private:
  void DoSg();
</code></pre>
",0
150018,140935,19,"<p>You can't partially define classes in C++.</p>
<p>Here's a way to get the &quot;polymorphism, where there's only one subclass&quot; effect you're after without overhead and with a bare minimum of #define or code duplication. It's called simulated dynamic binding:</p>
<pre><code>template &lt;typename T&gt;
class genericTest {
public:
    void genericMethod() {
        // do some generic things
        std::cout &lt;&lt; &quot;Could be any platform, I don't know&quot; &lt;&lt; std::endl;
        // base class can call a method in the child with static_cast
        (static_cast&lt;T*&gt;(this))-&gt;doClassDependentThing();
    }
};

#ifdef _WIN32
    typedef Win32Test Test;
#elif MAC
    typedef MacTest Test;
#endif
</code></pre>
<p>Then off in some other headers you'll have:</p>
<pre><code>class Win32Test : public genericTest&lt;Win32Test&gt; {
public:
    void win32Method() {
        // windows-specific stuff:
        std::cout &lt;&lt; &quot;I'm in windows&quot; &lt;&lt; std::endl;
        // we can call a method in the base class
        genericMethod();
        // more windows-specific stuff...
    }
    void doClassDependentThing() {
        std::cout &lt;&lt; &quot;Yep, definitely in windows&quot; &lt;&lt; std::endl;
    }
};
</code></pre>
<p>and</p>
<pre><code>class MacTest : public genericTest&lt;MacTest&gt; {
public:
    void macMethod() {
        // mac-specific stuff:
        std::cout &lt;&lt; &quot;I'm in MacOS&quot; &lt;&lt; std::endl;
        // we can call a method in the base class
        genericMethod();
        // more mac-specific stuff...
    }
    void doClassDependentThing() {
        std::cout &lt;&lt; &quot;Yep, definitely in MacOS&quot; &lt;&lt; std::endl;
    }
};
</code></pre>
<p>This gives you proper polymorphism at compile time. genericTest can non-virtually call doClassDependentThing in a way that gives it the platform version, (almost like a virtual method), and when win32Method calls genericMethod it of course gets the base class version.</p>
<p>This creates no overhead associated with virtual calls - you get the same performance as if you'd typed out two big classes with no shared code. It may create a non-virtual call overhead at con(de)struction, but if the con(de)structor for genericTest is inlined you should be fine, and that overhead is in any case no worse than having a genericInit method that's called by both platforms.</p>
<p>Client code just creates instances of Test, and can call methods on them which are either in genericTest or in the correct version for the platform. To help with type safety in code which doesn't care about the platform and doesn't want to accidentally make use of platform-specific calls, you could additionally do:</p>
<pre><code>#ifdef _WIN32
    typedef genericTest&lt;Win32Test&gt; BaseTest;
#elif MAC
    typedef genericTest&lt;MacTest&gt; BaseTest;
#endif
</code></pre>
<p>You have to be a bit careful using BaseTest, but not much more so than is always the case with base classes in C++. For instance, don't slice it with an ill-judged pass-by-value. And don't instantiate it directly, because if you do and call a method that ends up attempting a &quot;fake virtual&quot; call, you're in trouble. The latter can be enforced by ensuring that all of genericTest's constructors are protected.</p>
",3
175379,175244,2,"<p>I have a little copy of the operator precedence chart tacked to my cube wall.</p>
",0
175246,175244,9,"<p>I keep a PDF of the C++ standard open.  It's good for quickly looking up all the library interfaces (particularly the container interfaces and iostream stuff).  It's also useful for quickly resolving co-workers' arguments about C++ syntax and semantics.</p>

<p>I haven't yet figured out how to load the PDF into my brain.</p>
",4
175253,175244,0,"<p>Actually, the thing that gets me the most switching between C# &amp; C++ is constructor syntax.  (I keep wanting to use ""new"" for everything).</p>
",0
175255,175244,2,"<p>Template specialization. I always need to look it up.</p>
",0
175278,175244,6,"<p>Since I work in C++ all the time I keep most of the syntax in my head. For library reference I use <a href=""http://www.sgi.com/tech/stl"" rel=""noreferrer"">sgi</a> and <a href=""https://rads.stackoverflow.com/amzn/click/com/0201379260"" rel=""noreferrer"" rel=""nofollow noreferrer"">Josuttis'</a> book. When I haven't done C++ for a while and really want a refresher I go back to <a href=""https://rads.stackoverflow.com/amzn/click/com/0321334876"" rel=""noreferrer"" rel=""nofollow noreferrer"">Effective C++</a>.</p>

<p>When I need to ansewer a deeper question I'll refer to the standard or <a href=""https://rads.stackoverflow.com/amzn/click/com/0201700735"" rel=""noreferrer"" rel=""nofollow noreferrer"">Stroustrup's</a> book.</p>

<p>When all else fails, google and stackoverflow are great tools.</p>
",0
175289,175244,5,"<h2>Implementing a Callback to a non-static C++ Member Function</h2>

<p>Every time I have to do this I need to look this one up. Really anything that deals with function pointer details always tends to tweak my brain. I've found the <a href=""http://www.newty.de/fpt/index.html"" rel=""noreferrer"">Function Pointer Tutorials</a> to be a fairly good reference. </p>
",1
175294,175244,3,"<p>I use the site <a href=""http://www.cplusplus.com/"" rel=""nofollow noreferrer"">cplusplus.com</a>.  It is a great reference for C and C++ programming.</p>
",1
175564,175244,18,"<p>When I switch back from Java to C++, I like to review items from <a href=""http://www.gotw.ca/publications/c++cs.htm"" rel=""noreferrer"">C++ Coding Standards</a> by Herb Sutter and Andrei Alexandrescu.</p>

<p>Scott Meyers' <a href=""http://www.aristeia.com/books.html"" rel=""noreferrer"">Effective C++</a> series are great for this too.</p>

<p>Here are quick basic stuffs that work for me:</p>

<ul>
<li>Use <a href=""http://en.cppreference.com/w/cpp/algorithm/swap"" rel=""noreferrer""><code>std::swap()</code></a></li>
<li>""When in doubt, do as the ints do."" (Scott Meyers)</li>
<li><code>const *</code> means constant data, <code>* const</code> means constant pointer (read the decl. backwards!).</li>
<li>Declare an assignment operator and a copy constructor in classes with dynamically assigned data. </li>
<li>C++ will write an assignment operator &amp; copy constructor for you if you don't declare one yourself. Except if you declare them (private, most likely) and omit to define them. </li>
<li>Have operator=() return a reference to <code>*this</code> </li>
<li>Call Base(rhs) in Derived's copy constructor's init list.</li>
<li>Call <code>Base::operator=(rhs);</code> in Derived's <code>operator=()</code> </li>
<li>Check for assignment to self in <code>operator=()</code></li>
<li>Don't implement <code>operator=()</code> by calling the copy constructor (Herb Sutter, <a href=""http://www.gotw.ca/publications/advice97.htm"" rel=""noreferrer"">Write what you Know, and Know what you Write</a>)</li>
<li>Remember <a href=""http://en.wikipedia.org/wiki/Resource_acquisition_is_initialization"" rel=""noreferrer"">RAII</a></li>
<li>catch exceptions by reference</li>
</ul>
",0
175314,175244,5,"<p>On my C Cheatsheet (and on the C++ one by extension), pointer to function syntax.</p>
",1
175356,175244,4,"<p>Not really on a cheat sheet, and not really specific to C++, but I have ""Flush the buffer!"" on a sticky note to remind me of what's probably wrong when I'm not receiving data.</p>
",0
175638,175244,0,"<p><a href=""http://www.dinkumware.com/manuals/"" rel=""nofollow noreferrer"">Dinkumware Compleat Reference</a> for STL and other standard &lt;include&gt;s.</p>
",0
177108,175244,15,"<p>On my cheatsheet: interactions between const and pointers:</p>

<pre><code>int       *       p;  // pointer
int const *       p;  // pointer to const value
int       * const p;  // const pointer
int const * const p;  // const pointer to const value
</code></pre>

<p>Essentially, split the declaration on the <code>*</code> symbol and if the const falls to the left, the pointed-to value is const, and if it falls to the right, the pointer itself is const.</p>
",4
177131,175244,4,"<p>I keep this whole site handy for cheatsheets in general: </p>

<p><a href=""http://www.cheat-sheets.org/#CPP"" rel=""nofollow noreferrer"">http://www.cheat-sheets.org/#CPP</a></p>

<p>The cpp cheatsheet is a bit basic, but the STL is useful.</p>
",0
177859,175244,1,"<p>Scott Meyer's TR1 summary page, <a href=""http://www.aristeia.com/EC3E/TR1_info.html"" rel=""nofollow noreferrer"">http://www.aristeia.com/EC3E/TR1_info.html</a></p>
",0
1882343,175244,0,"<p>For those who want a quick reference and recap , here are C++ Cheat Sheet</p>

<p><a href=""http://www.skill-guru.com/blog/2009/11/22/c-cheat-sheet-1/"" rel=""nofollow noreferrer"">C++ cheat sheet - part 1</a> <br/>
<a href=""http://www.skill-guru.com/blog/2009/11/22/c-cheat-sheet-part-2/"" rel=""nofollow noreferrer"">C++ cheat sheet - part 2</a></p>
",0
1972192,1972086,2,"<pre><code>void Function(double data[][2], int n);
double* pData = new double[2*n];
Function((double (*)[2])pData, n);
</code></pre>

<p>Function parameters of the form <code>T[]</code> are identical to <code>T*</code> (not even <code>T* const</code> that some people expect).  This is a special case for parameter types in both C and C++.  So your <code>double[][2]</code> follows this rule, with T being <code>double[2]</code>.  Typedefs help illustrate this:</p>

<pre><code>typedef double T[2];
void Function(T data[], int n);
// identical to:
void Function(double data[][2], int n);
// also identical to:
void Function(double (*data)[2], int n);
</code></pre>

<p>So you write <code>T*</code> when T is <code>double[2]</code> as <code>double (*)[2]</code>.</p>

<hr>

<p>You could also do this:</p>

<pre><code>void Function(double data[][2], int n);
double (*pData)[2] = new double[n][2];
Function(pData, n);
</code></pre>

<p>Which requires no cast because pData is already the correct type.  Or with typedefs:</p>

<pre><code>typedef double T[2];
T* pData = new T[n];
</code></pre>
",0
1972228,1972086,0,"<p>Just to spell it out, Andrew's answer </p>

<pre><code>Function(&amp;pData, n) 
</code></pre>

<p>doesn't work, you get:</p>

<pre><code>error C2664: 'Function' : cannot convert parameter 1 from 'double **' to 'double [][2]'
</code></pre>

<p>Roger Pate's compiles, the syntax without typedefs is this:</p>

<pre><code>Function( (double (*)[2]) &amp;pData, n);
</code></pre>
",0
877207,877107,3,"<p>You can see the problem much more clearly in the following code:</p>

<pre><code>struct B {
    B( int a, int x  ) {}
};

int main() {
    const B &amp; b( 1, 2);
}
</code></pre>

<p>which produces the following errors with g++:</p>

<pre><code>t.cpp: In function 'int main()':
t.cpp:6: error: initializer expression list treated as compound expression
t.cpp:6: error: invalid initialization of reference of type 'const B&amp;' from expression of type int'
</code></pre>

<p>VC++ 6.0 gives the even more gnomic error:</p>

<pre><code> error C2059: syntax error : 'constant'
</code></pre>

<p>Simply put, you can't initialise references like that.</p>
",0
877130,877107,5,"<p>m_bar is declared as a ""const reference"" and therefore can't be instantiated with the constructor you've supplied.</p>

<p>Consider making m_bar a member, or passing a pre-constructed Bar object to the constructor.</p>
",0
877156,877107,21,"<p>m_bar is a reference, so you can't construct one. </p>

<p>As others have noted, you can initialise references with the object it refers to,  but you can't construct one like you're trying to do.</p>

<p>Change line 30 to </p>

<pre><code>const Bar m_bar
</code></pre>

<p>and it'll compile / run properly.</p>
",0
281502,281445,3,"<p>Really the inner struct is your best bet.  Another possibility would be to use a typedef to bring in a class of statics.  This works well for code generation in that you can separate the extras from the generated code:</p>

<p>In the generated file that doesn't care at all what's in Zot_statics:</p>

<pre><code>class Zot_statics;    
class Zot
{
public:
    typedef Zot_statics A;

    int x; // This is ok
};
</code></pre>

<p>In a hand-maintained header for when you need to access x and y:</p>

<pre><code>class Zot_statics
{
public:
    static int x;
    static int y;
};
</code></pre>

<p>In a hand-maintained cpp file:</p>

<pre><code>int Zot_statics::x;
int Zot_statics::y;
</code></pre>

<p>And your template should work just fine with <code>Zot::X</code> referring to the instance variable X on Zot, and Zot::A::x refering to the static variable.</p>
",0
365492,365476,5,"<pre><code>at k = 0, c = 1
at k = 1, c = 2
at k = 2, c = 8
</code></pre>

<p>That is because:</p>

<pre><code>input = 10011100
c = 0

`k=0, b=1` shift by 0 add 1 =&gt; `c = 1`, dec = 1
`k=1, b=0` shift by 1 add 0 =&gt; `c = 10`, dec = 2
`k=2, b=0` shift by 2 add 0 =&gt; `c = 1000`, dec = 8
</code></pre>

<p>b means ""current bit"". Possibly you don't want to shift by <code>k</code>, but by <code>1</code> ? If you look for a standard C++ solution, you can use <code>std::bitset</code>:</p>

<pre><code>std::bitset&lt;8&gt; bits(""10011100"");
unsigned char c = bits.to_ulong();
</code></pre>

<p>For your output into the stream, you can use the <code>put</code> function:</p>

<pre><code>outFile.put(c);
</code></pre>

<p>It avoids casting pointers and also outputs unformatted (settings like the field-width are ignored).</p>
",0
383976,383973,25,"<p>It is not always. It's the value that you gave the program by the Operation System. For example when starting a program using <code>exec</code> you can set that to an arbitrary value:</p>

<pre><code>int execve(const char *filename, char *const argv[],
           char *const envp[]);
</code></pre>

<p>The first parameter is the file to start, and argv will contains argv[0] and all other parameters for main. envp contains the environment variables (not defined by Standard C or C++. This is a posix thing). </p>

<p>More precisely, this is the definition of argv in C++:</p>

<blockquote>
  <p>An implementation shall not predefine the main function. This function shall not be overloaded. It shall
  have a return type of type int, but otherwise its type is implementation-defined. All implementations
  shall allow both of the following definitions of main:</p>
</blockquote>

<pre><code>int main() { /* ... */ }
</code></pre>

<blockquote>
  <p>and</p>
</blockquote>

<pre><code>int main(int argc, char* argv[]) { /* ... */ }
</code></pre>

<blockquote>
  <p>In the latter form argc shall be the number of arguments passed to the program from the environment in
  which the program is run. If argc is nonzero these arguments shall be supplied in <code>argv[0]</code> through
  <code>argv[argc-1]</code> as pointers to the initial characters of null-terminated multibyte strings (NTMBSs)
  (17.3.2.1.3.2) and <code>argv[0]</code> shall be the pointer to the initial character of a NTMBS that represents the
  name used to invoke the program or """". The value of argc shall be nonnegative. The value of
  <code>argv[argc]</code> shall be 0. [Note: it is recommended that any further (optional) parameters be added after
  argv. ]</p>
</blockquote>

<p>It's pretty much up to the implementation what defines a ""name used to invoke the program"". If you want to get the full path of your executable, you can use <a href=""http://msdn.microsoft.com/en-us/library/ms683197%28VS.85%29.aspx"" rel=""noreferrer"">GetModuleFileName</a> on Windows, and <code>argv[0]</code> (for getting the name used to execute, may be relative) together with <code>getcwd</code> (for getting the current working directory, trying to make the name absolute).</p>
",3
383986,383973,2,"<p>Here's what the C standard says that <code>argv[0]</code> should be:</p>

<blockquote>
  <p>If the value of <code>argc</code> is greater than
  zero, the string pointed to by
  <code>argv[0]</code> represents the program name;
  <code>argv[0][0]</code> shall be the null
  character if the program name is not
  available from the host environment.</p>
</blockquote>

<p>As for whether it contains the full path, the answer is that argv[0] does not necessarily contain the full path to the executable.  On Windows it seems to be exactly what was provided on the command line. Dunno what Linux/Unix does.</p>
",0
383994,383973,6,"<p>No. On Windows GetModuleFileName gurantees the exact full path to the current executing program. On linux there is a symlink /proc/self/exe. Do a readlink on this symlink to get the full path of the currently executing program. Even if youprogram was called thorugh a symlink /proc/self/exe will always point to the actuall program.</p>
",0
384001,383973,4,"<p>It's so not-guaranteed that students used to try to hide the fact that they were playing Rogue on the school mainframe by writing C programs that would start it with argv[0] of ""cc"" or ""tcsh"".</p>
",0
487892,285723,-1,"<p>I <a href=""http://khason.net/blog/pinvoke-cheat-sheet/"" rel=""nofollow noreferrer"">wrote small cheat sheet</a> for such programmers. You also might be interested with more complicated cases, such <a href=""http://khason.net/blog/how-to-pinvoke-varargs-variable-arguments-in-c-or-hidden-junk-in-clr/"" rel=""nofollow noreferrer"">as varargs</a></p>
",1
380019,285723,1,"<p><em>In response to ""Referencing/using other libraries""</em></p>

<p>Information regarding explicit loading of DLL's in C/C++ for both windows and linux include...</p>

<p><strong>Windows:</strong></p>

<p><a href=""http://www.codeguru.com/cpp/cpp/cpp_mfc/tutorials/article.php/c9855#more"" rel=""nofollow noreferrer"">Windows DLL Tutorial</a> </p>

<p>Functions: <em>LoadLibrary, GetProcAddress, FreeLibrary</em></p>

<p><strong>Linux:</strong></p>

<p>Functions: <em>dlopen, dlsym, dlerror, dlclose</em></p>

<p><a href=""http://www.ibm.com/developerworks/library/l-dll.html"" rel=""nofollow noreferrer"">Linux DLL Tutorial</a></p>
",0
285819,285723,202,"<p>I know you say you've got a good grasp of pointers and memory management, but I'd still like to explain an important trick.
As a general rule of thumb, <em>never</em> have new/delete in your user code.</p>

<p>Every resource acquisition (whether it's a synchronization lock, a database connection or a chunk of memory or anything else that must be acquired and released) should be wrapped in an object so that the constructor performs the acquisition, and the destructor releases the resource. The technique is known as <a href=""http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization"" rel=""noreferrer"">RAII</a>, and is basically <em>the</em> way to avoid memory leaks. Get used to it.
The C++ standard library obviously uses this extensively, so you can get a feel for how it works there. Jumping a bit in your questions, the equivalent of <code>List&lt;T&gt;</code> is <code>std::vector&lt;T&gt;</code>, and it uses RAII to manage its memory. You'd use it something like this:</p>

<pre><code>void foo() {

  // declare a vector *without* using new. We want it allocated on the stack, not
  // the heap. The vector can allocate data on the heap if and when it feels like
  // it internally. We just don't need to see it in our user code
  std::vector&lt;int&gt; v;
  v.push_back(4);
  v.push_back(42); // Add a few numbers to it

  // And that is all. When we leave the scope of this function, the destructors 
  // of all local variables, in this case our vector, are called - regardless of
  // *how* we leave the function. Even if an exception is thrown, v still goes 
  // out of scope, so its destructor is called, and it cleans up nicely. That's 
  // also why C++ doesn't have a finally clause for exception handling, but only 
  // try/catch. Anything that would otherwise go in the finally clause can be put
  // in the destructor of a local object.
} 
</code></pre>

<p>If I had to pick one single principle that a C++ programmer must learn and embrace, it's the above. Let the scoping rules and the destructors work for you. They offer all the guarantees you need to write safe code.</p>

<h2>String handling:</h2>

<p><code>std::string</code> is your friend there. In C, you'd use arrays of char's (or char pointers), but those are nasty, because they don't behave as strings. In C++, you have a std::string class, which behaves as you'd expect. The only thing to keep in mind is that ""hello world"" is of type char[12] and NOT std::string. (for C compatibility), so sometimes you have to explicitly convert your string literal (something enclosed in quotes, like ""hello world"") to a std::string to get the behavior you want:
You can still write</p>

<pre><code>std::string s = ""hello world"";
</code></pre>

<p>because C-style strings (such as literals, like ""hello world"") are implicitly convertible to std::string, but it doesn't always work:
""hello"" + "" world"" won't compile, because the + operator isn't defined for two pointers.
""hello worl"" + 'd' however, <em>will</em> compile, but it won't do anything sensible.
Instead of appending a char to a string, it will take the integral value of the char (which gets promoted to an int), and add that to the value of the pointer.</p>

<p>std::string(""hello worl"") + ""d"" does as you'd expect however, because the left hand side is already a std::string, and the addition operator is overloaded for std::string to do as you'd expect, even when the right hand side is a char* or a single character.</p>

<p>One final note on strings:
std::string uses char, which is a single-byte datatype. That is, it is not suitable for unicode text.
C++ provides the wide character type wchar_t which is 2 or 4 bytes, depending on platform, and is typically used for unicode text (although in neither case does the C++ standard really specify the character set). And a string of wchar_t's is called std::wstring.</p>

<h2>Libraries:</h2>

<p>They don't exist, fundamentally.
The C++ language has no notion of libraries, and this takes some getting used to.
It allows you to #include another file (typically a header file with the extension .h or .hpp), but this is simply a verbatim copy/paste. The preprocessor simply combines the two files resulting in what is called a translation unit. Multiple source files will typically include the same headers, and that only works under certain specific circumstances, so this bit is key to understanding the C++ compilation model, which is notoriously quirky. Instead of compiling a bunch of separate modules, and exhanging some kind of metadata between them, as a C# compiler would, each translation unit is compiled in isolation, and the resulting object files are passed to a linker which then tries to merge the common bits back together (if multiple translation units included the same header, you essentially have code duplicated across translation units, so the linker merges them back into a single definition) ;)</p>

<p>Of course there are platform-specific ways to write libraries. On Windows, you can make .dll's or .libs, with the difference that a .lib is linked into your application, while a .dll is a separate file you have to bundle with your app, just like in .NET. On Linux, the equivalent filetypes are .so and .a, and in all cases, you have to supply the relevant header files as well, for people to be able to develop against your libraries.</p>

<h2>Data type conversions:</h2>

<p>I'm not sure exactly what you're looking for there, but one point I feel is significant is that the ""traditional"" cast as in the following, is bad:</p>

<pre><code>int i = (int)42.0f; 
</code></pre>

<p>There are several reasons for this.
First, it attempts to perform several different types of casts in order, and you may be surprised by which one the compiler ends up applying. Second, it's hard to find in a search, and third, it's not ugly enough. Casts are generally best avoided, and in C++, they're made a bit ugly to remind you of this. ;)</p>

<pre><code>// The most common cast, when the types are known at compile-time. That is, if 
// inheritance isn't involved, this is generally the one to use
static_cast&lt;U&gt;(T); 

// The equivalent for polymorphic types. Does the same as above, but performs a 
// runtime typecheck to ensure that the cast is actually valid
dynamic_cast&lt;U&gt;(T); 

// Is mainly used for converting pointer types. Basically, it says ""don't perform
// an actual conversion of the data (like from 42.0f to 42), but simply take the
// same bit pattern and reinterpret it as if it had been something else). It is
// usually not portable, and in fact, guarantees less than I just said.
reinterpret_cast&lt;U&gt;(T); 

// For adding or removing const-ness. You can't call a non-const member function
// of a const object, but with a const-cast you can remove the const-ness from 
// the object. Generally a bad idea, but can be necessary.
const_cast&lt;U&gt;(T);
</code></pre>

<p>As you'll note, these casts are much more specific, which means the compiler can give you an error if the cast is invalid (unlike the traditional syntax, where it'd just try any of the above casts until it finds one that works), and it's big and verbose, allowing you to search for it, and reminds you that they should be avoided when possible. ;)</p>

<h2>The standard library:</h2>

<p>Finally, getting back to data structures, put some effort into understanding the standard library. It is small, but amazingly versatile, and once you learn how to use it, you'll be in a far better position.</p>

<p>The standard library consists of several pretty distinct building blocks (the library has kind of accumulated over time. Parts of it were ported from C. The I/O streams library are adopted from one place, and the container classes and their associated functionality are adopted from a completely different library, and are designed noticeably different. The latter are part of what is often referred to as the STL (Standard Template Library). Strictly speaking, that is the name of the library that, slightly modified, got adopted into the C++ Standard Library.</p>

<p>The STL is key to understanding ""modern C++"". It is composed of three pillars, containers, iterators and algorithms.
In a nutshell, containers expose iterators, and algorithms work on iterator pairs.</p>

<p>The following example takes a vector of int's, adds 1 to each element, and copies it to a linked list, just for the sake of example:</p>

<pre><code>int add1(int i) { return i+1; } // The function we wish to apply

void foo() {
  std::vector&lt;int&gt; v;
  v.push_back(1);
  v.push_back(2);
  v.push_back(3);
  v.push_back(4);
  v.push_back(5); // Add the numbers 1-5 to the vector

  std::list&lt;int&gt; l;

  // Transform is an algorithm which applies some transformation to every element
  // in an iterator range, and stores the output to a separate iterator
  std::transform ( 
  v.begin(),
  v.end(), // Get an iterator range spanning the entire vector
  // Create a special iterator which, when you move it forward, adds a new 
  // element to the container it points to. The output will be assigned to this
  std::back_inserter(l) 
  add1); // And finally, the function we wish to apply to each element
}
</code></pre>

<p>The above style takes some getting used to, but it is extremely powerful and concise.
Because the transform function is templated, it can accept <em>any</em> types as input, as long as they behave as iterators. This means that the function can be used to combine any type of containers, or even streams or anything else that can be iterated through, as long as the iterator is designed to be compatible with the STL. We also don't have to use the begin/end pair. Instead of the end iterator, we could have passed one pointing to the third element, and the algorithm would then have stopped there. Or we could have written custom iterators which skipped every other elements, or whatever else we liked.
The above is a basic example of each of the three pillars. We use a container to store our data, but the algorithm we use to process it doesn't actually have to know about the container. It just has to know about the iterator range on which it has to work. And of course each of these three pillars can be extended by writing new classes, which will then work smoothly together with the rest of the STL.</p>

<p>In a sense, this is very similar to LINQ, so since you're coming from .NET, you can probably see some analogies. The STL counterpart is a bit more flexible though, at the cost of slightly weirder syntax. :)
(As mentioned in comments, it is also more efficient. In general, there is <em>zero</em> overhead to STL algorithms, they can be just as efficient as hand-coded loops. This is often surprising, but is possible because all relevant types are known at compile-time (which is a requirement for templates to work), and C++ compilers tend to inline aggressively.)</p>
",2
285863,285723,3,"<p>I'll not repeat what others have said about libraries and such, but if you're serious about C++, do yourself a favor and pick up Bjarne Stroustrup's ""The C++ Programming Language.""</p>

<p>It took me years of working in C++ to finally pick up a copy, and once I did, I spent an afternoon slapping my forehead saying ""of course!  I should have realized!  etc.""</p>

<p>(Ironically, I had EXACTLY the same experience with K&amp;R's ""The C Programming Language.""  Someday, I'll learn to just go get ""The Book"" on day 1.)</p>
",0
285753,285723,3,"<p>You've got some toolkits available.  For example, there are STL (Standard Template Library) and Boost/TR1 (extensions to STL) that are considered industry standards (well, STL is, at least).  These provide lists, maps, sets, shared pointers, strings, streams, and all sorts of other handy tools.  Best of all, they're widely supported across compilers.</p>

<p>As for data conversions, you can either do casts or create explicit converter functions.</p>

<p>Libraries - You can either create static libraries (get absorbed into the final executable) or DLLs (you're familiar with these, already).  MSDN is an awesome resource for DLLs.  Static libraries depend on your build environment.</p>

<p>In general, this is my advice:
 - Get to know your IDE of choice very well
 - Purchase ""C++ The Complete Reference"" by Herbert Schildt, which I consider to be an excellent tome on all things C++ (includes STL)</p>

<p>Considering your background, you should be well set once you do both of those.</p>
",0
285755,285723,1,"<p>Referencing and using other libraries, if you're including the source, is accomplished simply by #including the header files for the library into whatever .cpp file you need them in (and then compile the source for the library along with your project).  Most of the time, however, you'll probably be using a .lib (static library) or .dll (dynamic library).  Most (all?) DLLs come with a .lib file, so the procedure for both types is the same: include the appropriate header files where you need them, then add the associated .lib file during the linking step (in visual studio, I think you can just add the file to the project).</p>

<p>It's been a long time since I've created my own libraries for others to use, so I'll let someone else answer that part.  Or I'll come back and edit this answer tomorrow, since I'm going to have to create a .lib for work tomorrow :)</p>

<p>String stuff is usually accomplished with std::string.  Under special circumstances, you may also use the old C-style sprintf() function, but that's generally discouraged.</p>

<p>As far as the data structures you're looking for, check out the STL (Standard Template Library).  It includes List, Vector, Map, String, etc that should be familiar to you.
I'm not sure what you mean by type conversions... I assume you know about casting, so you must mean something more complex than that, in which case it's probably specific to the types you're trying to convert.  Maybe someone else can offer more info.</p>
",0
212019,212006,23,"<p>Inside the class body is considered to be inline by the compiler.
If you implement outside of body, but still in header, you have to mark the method as 'inline' explicitly.</p>

<pre><code>namespace test_ns{

class TestClass{
public:
    inline void testMethod();
};

void TestClass::testMethod(){
    // some code here...
}

} // end namespace test_ns
</code></pre>

<p><strong>Edit</strong></p>

<p>For myself it often helps to solve these kinds of compile problems by realizing that the compiler does not see anything like a header file. Header files are preprocessed and the compiler just sees one huge file containing every line from every (recursively) included file. Normally the starting point for these recursive includes is a cpp source file that is being compiled. 
In our company, even a modest looking cpp file can be presented to the compiler as a 300000 line monster. </p>

<p>So when a method, that is not declared inline, is implemented in a header file, the compiler could end up seeing void TestClass::testMethod() {...} dozens of times in the preprocessed file. Now you can see that this does not make sense, same effect as you'd get when copy/pasting it multiple times in one source file.
And even if you succeeded by only having it once in every compilation unit, by some form of conditional compilation ( e.g. using inclusion brackets ) the linker would still find this method's symbol to be in multiple compiled units ( object files ).</p>
",0
212022,212006,23,"<p>These are not equivalent. The second example given has an implicit 'inline' modifier on the method and so the compiler will reconcile multiple definitions itself (most likely with internal linkage of the method if it isn't inlineable).</p>

<p>The first example isn't inline and so if this header is included in multiple translation units then you will have multiple definitions and linker errors.</p>

<p>Also, headers should really always be guarded to prevent multiple definition errors in the same translation unit. That should convert your header to:</p>

<pre><code>#ifndef EXAMPLE_H
#define EXAMPLE_H

//define your class here

#endif
</code></pre>
",1
212037,212006,4,"<p>Don't put a function/method definition in an header file unless they are inlined (by defining them directly in a class declaration or explicity specified by the inline keyword)</p>

<p>header files are (mostly) for declaration (whatever you need to declare). Definitions allowed are the ones for constants and inlined functions/methods (and templates too). </p>
",0
213107,212006,1,"<p>Your first code snippet is falling foul of C++'s ""One Definition Rule"" <a href=""http://en.wikipedia.org/wiki/One_Definition_Rule"" rel=""nofollow noreferrer"">- see here for a link to a Wikipedia article describing ODR.</a> You're actually falling foul of point #2 because every time the compiler includes the header file into a source file, you run into the risk of the compiler generating a globally visible definition of <code>test_ns::TestClass::testMethod()</code>. And of course by the time you get to link the code, the linker will have kittens because it will find the same symbol in multiple object files.</p>

<p>The second snippet works because you've inlined the definition of the function, which means that even if the compiler doesn't generate any inline code for the function (say, you've got inlining turned off or the compiler decides the function is too big to inline), the code generated for the function definition will be visible in the translation unit only, as if you'd stuck it in an anonymous namespace. Hence you get multiple copies of the function in the generated object code that the linker may or may not optimize away depending on how smart it is.</p>

<p>You could achieve a similar effect in your first code snippet by prefixing <code>TestClass::testMethod()</code> with <code>inline</code>.</p>
",0
171218,171213,4,"<p>I actually use exactly the process you describe, and it works fine except for the edge case that happens when you suddenly run out of disk space and can no longer create files.</p>

<p>The ""correct"" way to do this is probably to use shared memory: <a href=""http://www.cs.cf.ac.uk/Dave/C/node27.html"" rel=""nofollow noreferrer"">http://www.cs.cf.ac.uk/Dave/C/node27.html</a></p>
",0
171220,171213,36,"<p>There are several methods you can use to accomplish only allowing one instance of your application:</p>

<p><strong>Method 1: Global synchronization object or memory</strong></p>

<p>It's usually done by creating a named global mutex or event.  If it is already created, then you know the program is already running.</p>

<p>For example in windows you could do:</p>

<pre><code>    #define APPLICATION_INSTANCE_MUTEX_NAME ""{BA49C45E-B29A-4359-A07C-51B65B5571AD}""

    //Make sure at most one instance of the tool is running
    HANDLE hMutexOneInstance(::CreateMutex( NULL, TRUE, APPLICATION_INSTANCE_MUTEX_NAME));
    bool bAlreadyRunning((::GetLastError() == ERROR_ALREADY_EXISTS));
    if (hMutexOneInstance == NULL || bAlreadyRunning)
    {
        if(hMutexOneInstance)
        {
            ::ReleaseMutex(hMutexOneInstance);
            ::CloseHandle(hMutexOneInstance);
        }
        throw std::exception(""The application is already running"");
    }
</code></pre>

<p><strong>Method 2: Locking a file, second program can't open the file, so it's open</strong></p>

<p>You could also exclusively open a file by locking it on application open.  If the file is already exclusively opened, and your application cannot receive a file handle, then that means the program is already running.  On windows you'd simply not specify sharing flags <code>FILE_SHARE_WRITE</code> on the file you're opening with <code>CreateFile</code> API. On linux you'd use <code>flock</code>.</p>

<p><strong>Method 3: Search for process name:</strong></p>

<p>You could enumerate the active processes and search for one with your process name. </p>
",3
171222,171213,5,"<p>Your method of writing the process pid to a file is a common one that is used in many different established applications. In fact, if you look in your <code>/var/run</code> directory right now I bet you'll find several <code>*.pid</code> files already.</p>

<p>As you say, it's not 100% robust because there is chance of the pids getting confused. I have heard of programs using <code>flock()</code> to lock an application-specific file that will automatically be unlocked by the OS when the process exits, but this method is more platform-specific and less transparent.</p>
",3
171225,171213,0,"<p>I don't have a good solution, but two thoughts:</p>

<ol>
<li><p>You could add a ping capability to query the other process and make sure it's not an unrelated process.  Firefox does something similar on Linux and doesn't start a new instance when one is already running.</p></li>
<li><p>If you use a signal handler, you can ensure the pid file is deleted on all but a <code>kill -9</code></p></li>
</ol>
",0
171231,171213,0,"<p>I scan the process list looking for the name of my apps executable with matching command line parameters then exit if there is a match.</p>

<p>My app can run more than once, but I don't want it running the same config file at the same time.</p>

<p>Obviously, this is Windows specific, but the same concept is pretty easy on any *NIX system even without specific libraries simply by opening the shell command 'ps -ef' or a variation and looking for your app.</p>

<pre><code>   '*************************************************************************
   '     Sub: CheckForProcess()
   '  Author: Ron Savage
   '    Date: 10/31/2007
   '
   ' This routine checks for a running process of this app with the same
   ' command line parameters.
   '*************************************************************************
   Private Function CheckForProcess(ByVal processText As String) As Boolean
      Dim isRunning As Boolean = False
      Dim search As New ManagementObjectSearcher(""SELECT * FROM Win32_process"")
      Dim info As ManagementObject
      Dim procName As String = """"
      Dim procId As String = """"
      Dim procCommandLine As String = """"

      For Each info In search.Get()
         If (IsNothing(info.Properties(""Name"").Value)) Then procName = ""NULL"" Else procName = Split(info.Properties(""Name"").Value.ToString, ""."")(0)
         If (IsNothing(info.Properties(""ProcessId"").Value)) Then procId = ""NULL"" Else procId = info.Properties(""ProcessId"").Value.ToString
         If (IsNothing(info.Properties(""CommandLine"").Value)) Then procCommandLine = ""NULL"" Else procCommandLine = info.Properties(""CommandLine"").Value.ToString

         If (Not procId.Equals(Me.processId) And procName.Equals(processName) And procCommandLine.Contains(processText)) Then
            isRunning = True
         End If
      Next

      Return (isRunning)
   End Function
</code></pre>
",1
171440,171213,1,"<p>If you want something that's bog standard, then using a file as a 'lock' is pretty much the way to go.  It does have the drawback that you mentioned (if your app doesn't clean up, restarting can be an issue).</p>

<p>This method is used by quite a few applications, but the only one I can recall off the top of my head is VMware.  And yes, there are times when you have to go in and delete the '*.lck' when things get wedged.</p>

<p>Using a global mutex or other system object as mentioned by <a href=""https://stackoverflow.com/questions/171213/how-to-block-running-two-instances-of-the-same-program#171220"">Brian Bondy</a> is a better way to go, but these are platform specific, (unless you use some other library to abstract the platform specifics away).</p>
",0
171988,171213,4,"<p>It is very un-unix to prohibit multiple instances of a program to run.</p>

<p>If the program is, say, a network daemon, it doesn't need to actively prohibit multiple instances--only the first instance gets to listen to the socket, so subsequent instances bomb out automatically.  If it is, say, an RDBMS, it doesn't need to actively prohibit multiple instances--only the first instance gets to open and lock the files.  etc.</p>
",4
75224,75213,1,"<p>referring to the global scope</p>
",0
75249,75213,4,"<p>When you already have a function named foo() in your local scope but you need to access the one in the global scope.</p>
",0
75251,75213,3,"<p>My c++ is rusty but I believe if you have a function declared in the local scope, such as foo() and one at global scope, foo() refers to the local one. ::foo() will refer to the global one.</p>
",0
75262,75213,86,"<p>It means global scope.  You might need to use this operator when you have conflicting functions or variables in the same scope and you need to use a global one.  You might have something like:</p>

<pre><code>void bar();    // this is a global function

class foo {
    void some_func() { ::bar(); }    // this function is calling the global bar() and not the class version
    void bar();                      // this is a class member
};
</code></pre>

<p>If you need to call the global bar() function from within a class member function, you should use ::bar() to get to the global version of the function.</p>
",2
75309,75213,8,"<p>Also you should note, that name resolution happens before overload resolution. So if there is something with the same name in your current scope then it will stop looking for other names and try to use them.</p>

<pre><code>void bar() {};
class foo {
    void bar(int) {};
    void foobar() { bar(); } // won't compile needs ::bar()
    void foobar(int i) { bar(i); } // ok
}
</code></pre>
",0
1430903,1430884,5,"<p>A::GetAInstance should be static.  </p>

<p>Then you should be able to just do the following</p>

<pre><code>if (condition)
{ 
    A::GetAInstance().CreateBInstance(name);
}
</code></pre>
",2
1431025,1430884,1,"<p>Something doesn't smell right about the whole design, but its hard to say what without having more details provided. Anyway, you could do something like this which avoids a cyclic dependency but still has B call A:</p>

<pre><code>class BRegistry
{
   virtual void CreateBInstances(std::string&amp; name) = 0;
   ...
};

class A : public BRegistry
{
   public:

      virtual void CreateBInstances(std::string&amp; name) {
         map[name] = new B(name, *this);
      }

      // Singleton stuff...

      ...
};

class B
{
   public:

      B (std::string&amp; name, BRegistry&amp; registry) {
         ...
      }

      void checkCondition()
      {
         if  (condition == true)
         {
            registry.CreateBInstances(name);
         }
      }

      ...
};
</code></pre>

<p>Basically, I extract an interface from A and have B use the interface. A passes itself to B at creation time, but from B's point of view it is the interface. No cycles. </p>

<p>Just a comment. 99% of the time when I see Singleton, it is an inappropriate use of the pattern. Usually it is misused as just a convenient global variable, as exhibited by all the comments that jumped to say to use it from within B.</p>
",9
1432035,1430884,2,"<p>Much of the fluff about circular dependencies out there is confused when applied at implementation mechanisms rather than at package or module level, and some of it comes out of deficiencies in testing frameworks for Java. Because of the Java influence on the meme, solutions are phrased in the idioms of that rather than C++. It's not clear whether you're trying to remove a concrete circular dependency ( the code won't compile in C++ ) or have metaphysical objections.</p>

<p>One idiom for decoupling concrete circular dependencies is found in <a href=""http://www.codeproject.com/KB/cpp/allocator.aspx"" rel=""nofollow noreferrer"">allocators</a> in the C++ standard library. </p>

<p>When you declare a list so:</p>

<pre><code>std::list &lt; int, my_allocator &lt; int &gt; &gt;
</code></pre>

<p>the allocator has a nested struct which allows access to the raw template for different specialisations so the <code>std::list</code> implementation can allocate node objects rather than just ints.</p>

<p>Assuming that you have the following requirements:</p>

<ul>
<li>the registry is global to the program ( ie. you don't need more than one registry per object type, otherwise you need something like the factory pattern SingleShot proposes, though in C++ you'd more normally use template rather than virtual function polymorphism ); as such I tend to use static factory rather than singletons.</li>
<li>objects of class <code>B</code> should only be created by calling <code>A::CreateInstance(name)</code></li>
<li><code>A</code> acts as a registry, so repeated calls to create instance with the same name return the same object</li>
<li>code compiles correctly without concrete circular references</li>
<li>it is possible to replace the type of either the registry or registered type for testing </li>
</ul>

<p>This global registry doesn't require any knowledge of the types it creates, other than that they supply a constructor taking a reference to a const std::string:</p>

<pre><code>#include &lt;string&gt;
#include &lt;map&gt;

template &lt; class T = int &gt;
class Registry {
    static std::map&lt;std::string,T*&gt; map;

    public:

    static T&amp; CreateInstance ( const std::string&amp; name ) {
        typename std::map&lt; std::string, T* &gt;::iterator it = map.find ( name );

        if ( it == map.end() )
            return * ( map [ name ] = new T ( name ) );
        else
            return *it-&gt;second;
    }

    public:

    template &lt; typename U &gt; 
    struct rebind {
        typedef Registry&lt;U&gt; other;
    };
};

template  &lt; class T &gt;
std::map &lt; std::string, T* &gt; Registry&lt;T&gt;::map;
</code></pre>

<p>The corresponding registered object supplies a private constructor and has the CreateInstance function as a friend:</p>

<pre><code>template &lt; typename R = class Registry&lt;&gt; &gt;
class Registered {
        typedef typename R::template rebind&lt; Registered &lt; R &gt; &gt; ::other RR;

    private:
        friend Registered&lt;R&gt;&amp; RR::CreateInstance ( const std::string&amp; name );

        explicit Registered ( const std::string&amp; name ) {
            // ...
        }

        Registered ( const Registered&lt;R&gt;&amp; ) ; // no implementation

    public:
        void checkCondition()
        {
            bool condition = 7 &gt; 5;

            if  ( condition )
            {
                RR::CreateInstance ( ""whatever"" );
            }
        }

    // ...
};
</code></pre>

<p>Because of the <code>rebind::other</code> idiom, you don't have to write <code>Registered&lt;Registry&lt;Registered&lt;Registry ...</code> and avoid the concrete circular dependency. Because the default <code>Registry&lt;int&gt;</code> is never actually used except to supply <code>rebind</code>, it's not instantiated and so doesn't report an error that you can't construct an int using <code>new int ( name )</code>.</p>

<p>You can then use the types for your B and A:</p>

<pre><code>typedef Registered&lt;&gt;  B;
typedef Registry&lt;B&gt;   A;

int main () {
    B&amp; b1 = A::CreateInstance(""one""); // create a B

    b1.checkCondition(); // uses A to create object internally

    B b2(""two""); // compile error - can only create B using A

    return 0;
}
</code></pre>

<p>You can of course construct a <code>Registered&lt; MyMockRegistry &gt;</code> for testing, the other main objection to circularly dependent types.</p>
",0
116839,116469,1,"<p>The function 'getWords' is doing a lot of distinct actions that could be split out into other functions.  There's a good chance that by splitting it up into it's individual parts, you would have found the bug yourself.</p>

<p>From the basic structure, I think you could split the code into (at least):</p>

<ul>
<li>getNextWord: Return the next (non blank) word from the stream (returns false if none left)</li>
<li>clean_entry: What you have now</li>
<li>getNextCleanWord: Calls getNextWord, and if 'true' calls CleanWord.  Returns 'false' if no words left.</li>
</ul>

<p>The signatures of 'getNextWord' and 'getNextCleanWord' might look something like:</p>

<pre><code>bool getNextWord (std::ifstream &amp; input, std::string &amp; str);
bool getNextCleanWord (std::ifstream &amp; input, std::string &amp; str);
</code></pre>

<p>The idea is that each function does a smaller more distinct part of the problem.  For example, 'getNextWord' does nothing but get the next non blank word (if there is one).  This smaller piece therefore becomes an easier part of the problem to solve and debug if necessary.</p>

<p>The main component of 'getWords' then can be simplified down to:</p>

<pre><code>std::string nextCleanWord;
while (getNextCleanWord (input, nextCleanWord))
{
  ++map[nextCleanWord];
}
</code></pre>

<p>An important aspect to development, IMHO, is to try to Divide and Conquer the problem.  Split it up into the individual tasks that need to take place.  These sub-tasks will be easier to complete and should also be easier to maintain.</p>
",0
116510,116469,7,"<p>The problem with empty entries is in your while loop.  If you get an empty string, you clean the next one, and add it without checking.  Try changing: </p>

<pre><code>not_s = """";
clean_entry(s, not_s);

if((int)not_s.length() == 0)
 {
  input &gt;&gt; s;
  clean_entry(s, not_s);
 }    

mapz[not_s]++;              //increment occurence
input &gt;&gt;s;
</code></pre>

<p>to</p>

<pre><code>not_s = """";
clean_entry(s, not_s);

if((int)not_s.length() &gt; 0)
{
    mapz[not_s]++;              //increment occurence
}    

input &gt;&gt;s;
</code></pre>

<p>EDIT:  I notice you are checking if the characters are alphanumeric.  If numbers are not allowed, you may need to revisit that area as well.</p>
",4
116555,116469,1,"<p>A blank string is a valid instance of the string class, so there's nothing special about adding it into the map.  What you could do is first check if it's empty, and only increment in that case:</p>

<pre><code>if (!not_s.empty())
    mapz[not_s]++;
</code></pre>

<p>Style-wise, there's a few things I'd change, one would be to return clean from clean_entry instead of modifying it:</p>

<pre><code>string not_s = clean_entry(s);
...
string clean_entry(const string &amp;non_clean)
{
    string clean;
    ... // as before 
    if(begin ==(int)non_clean.length())
        return clean;
    ... // as before
    return clean;
 }
</code></pre>

<p>This makes it clearer what the function is doing (taking a string, and returning something based on that string).</p>
",1
116616,116469,2,"<p>Further improvements would be to</p>

<ul>
<li>declare variables only when you use them, and in the innermost scope</li>
<li>use c++-style casts instead of the c-style (int) casts</li>
<li>use empty() instead of length() == 0 comparisons</li>
<li>use the prefix increment operator for the iterators (i.e. <code>++mapzIter</code>)</li>
</ul>
",3
174450,174349,1,"<p>It could be rather nasty for any header you have. Like <code>&lt;vector&gt;</code>, or any of the Boost headers. It would also cause quite a few false bugreports. So, no, I don't expect a compiler to add such a #pragma.</p>
",0
174367,174349,0,"<p>I think the answer is no!</p>

<p>Sorry, its not a very constructive answer. I hope somebody else might know more!</p>
",0
174372,174349,0,"<p>There's no such option available in standard c++, and I don't believe there is in Visual Studio either.</p>
",0
174397,174349,22,"<p>Nope, you have to do it all by hand. It's a pain, but you certainly should get in the habit of making single argument constructors explicit. I can't imagine the pain you would have if you did find a solution and then had to port the code to another platform. You should usually shy away from compiler extensions like this because it will make the code less portable.</p>
",9
175468,174349,1,"<p>There is no such option in the compilers, as far as I am aware. But there is a Lint warning for such cases (see <a href=""http://www.gimpel.com/lintinfo.htm"" rel=""nofollow noreferrer"">http://www.gimpel.com/lintinfo.htm</a>).</p>
",0
177294,174349,2,"<p>If there was a pragma or command line option that made constructors explicit by default, how would you declare one that is not explicit? There would have to be another compiler-specific token or pragma to make it possible to declare an implicit conversion constructor.</p>
",2
565778,565765,0,"<p>You need to make Person::operator== virtual.</p>
",3
565784,565765,7,"<p>Add a virtual function int Compare(const Person&amp; rPerson) and use that in your operators</p>
",0
565785,565765,5,"<p>There is no neat solution to this problem.</p>

<p>Which is not a problem actually, in C++. What sense does it makes to compare entities on a equality basis?</p>

<p>EDIT: a few links to meditate regarding the pertinence of equality applied to entities:</p>

<ul>
<li><a href=""http://www.two-sdg.demon.co.uk/curbralan/papers/ObjectsOfValue.pdf"" rel=""nofollow noreferrer"">Objects Of Value</a>, Kevlin Henney</li>
<li><a href=""http://www.angelikalanger.com/Articles/JavaSolutions/SecretsOfEquals/Equals.html"" rel=""nofollow noreferrer"">Secrets Of Equals</a>, by Angelika Langer, check ""Entities vs values"" section</li>
</ul>

<p>EDIT2 (2018 nov 27th):</p>

<p>There is another problem here, problem which also has its root in OO design, not in C++. It's impossible to design a comparison operator that is reflexive (<code>x == x</code>), symmetric (<code>x == y &lt;=&gt; y == x</code>), and transitive (<code>x == y &amp;&amp; y == z =&gt; x == z</code>) , that also complies with <a href=""https://en.wikipedia.org/wiki/Liskov_substitution_principle"" rel=""nofollow noreferrer"">Liskov Substitution Principle</a>. There is a thorough demonstration of this limitation in Joshua Bloch's <em>Effective Java</em>, 2nd ed.</p>

<p>TL;DR: Let's say we have <code>ColouredPoint</code> that inherits from <code>Point</code>, a function that works on references to <code>Point</code>s and that needs to compare them. If <em>{1,2} == {1,2,blue}</em> , we will end up with <em>{1,2,blue} == {1,2,green}</em>. Or we refuse to compare points with coloured points, which breaks LSP. And so on. There is no solution. My conclusion is that inheriting comparison, while it's a appealing, it doesn't work.</p>
",11
565805,565765,6,"<p>You still have a major problem if you have one person and one employee - the person may compare equal to the employee, but not the employee to the person. i.e:</p>

<pre><code>(employee == person) != (person == employee)
</code></pre>

<p>This is a bad thing (tm). Basically you've made an equality operator that isn't <a href=""http://c2.com/cgi/wiki?EqualityOperator"" rel=""noreferrer"">symmetric</a> </p>

<p>Edit:</p>

<p>Ok, no virtual operators - add the virtual Compare function suggested elsewhere I think - but you still have the symmetric problem. </p>
",1
565809,565765,0,"<p>You can also take  operator== outside of the class scope. In which case, you can either create necessary overloads or make it generic by way of templates.</p>
",0
565947,565765,2,"<p>The big question here is - how do you determine equality?</p>

<p>Can any object be compared to any other object in the hierarchy?  Can only objects of the same type be compared? Where does the criteria for the comparison live?</p>

<p>The solution implementation will depend on the answers to these questions.</p>
",0
565987,565765,1,"<p>It doesn't make sense to have the same person equal two different employees but that is what you class design allows. You are better off arranging for identity to be attached to a person. You then ask if a.identity() == b.identity().</p>
",0
565999,565765,1,"<p>In order to make <code>operator==</code> symmetric you have to have a person and employee with the same shared details differ so that:</p>

<pre><code>Person p(""Foo"");
Employee e(""Foo"" , 1);
p == e; // false
e == p; // false
</code></pre>

<p>This is unintuitive but necessary. </p>

<p>To do this you can use the <a href=""http://en.wikipedia.org/wiki/Typeid"" rel=""nofollow noreferrer""><code>typeid</code> keyword</a></p>

<pre><code>bool operator==(const Person&amp; other) const
{
     return m_Name == other.m_Name &amp;&amp; typeid(other) == typeid(*this);
}
</code></pre>

<p>Of course <code>Person</code> must be a polymorphic type (have at least one virtual function).</p>
",0
566465,565765,11,"<p>What you want to do is essentiall &quot;virtualize&quot; the comparison operator.</p>
<p><del>Since operators cannot be virtual</del> (operators can be <code>virtual</code>), you will need to delegate it to something else.  Here's one possible solution.</p>
<pre><code>class Person
{
   public:
      /* ... */
      bool operator==(const Person&amp; rhs)
      {
         return m_Name == rPerson.m_Name &amp;&amp; this-&gt;doCompare(rhs);
      }
   private:
      virtual bool doCompare() = 0;
   };
}
class Employee : public Person
{
   /* ... */
   private:
      virtual bool doCompare(const Person&amp; rhs)
      {
         bool bRetval = false;
         const Employee* pRHSEmployee = dynamic_cast&lt;const Employee*&gt;(&amp;rhs);
         if (pEmployee)
         {
            bRetval = m_Id == pRHSEmployee-&gt;m_Id
         }
         return bRetval;
      }
};
</code></pre>
<p>The question didn't make clear whether Person needs to be a concrete class.  If so, you can make it not pure-virtual, and implement it to return true.</p>
<p>This also uses RTTI, which you may or may not be happy with.</p>
",2
988935,988925,36,"<p>You can't.  There is only one destructor per class in C++.  </p>

<p>What you can do is make a private destructor and then have several public methods which call the destructor in new and interesting ways.  </p>

<pre><code>class Foo {
  ~Foo() { ... }
public:
  DestroyFoo(int) { ... };
  DestroyFoo(std::string) { ... }
};
</code></pre>
",2
988939,988925,1,"<p>You can't! Each class can only have one destructor. How could you have more than one? The destructor is triggered automatically; there's no way the language would know which one to call.</p>

<p>Virtual destructors, however, are another matter.</p>
",0
988940,988925,0,"<p>You don't.  You can't have 2 destructors in one class.</p>

<p>What are you trying to accomplish?</p>
",0
988956,988925,5,"<p>Overloading means having several functions with the same name which take different arguments.  Like <code>swap(int &amp;a, int &amp;b)</code> and <code>swap(double &amp;a, double &amp;b)</code>.  A destructor takes no arguments.  Overloading it would not make sense.</p>

<p>If you need to do different things when destroying an object depending on certain circumstances, then you just need the appropriate if statements in your destructor to check for those circumstances.</p>
",0
989133,988925,4,"<p>Interesting question but the only reason why you'd want to overload a destructor would be because you want to free some resource in one destructor and leave it behind in another one, right?</p>

<p>Basically, you can achieve such behavior from your own destructor by using an additional boolean value which would tell you if a specific resource should be freed or not. This boolean would be set in your constructor and/or one of your other methods and in your destructor you check if it's set. If it's not set, then you'd free the resource. Otherwise, you just leave the resource and probably some other task will free it. (This would make sense when you share resources between multiple objects.)</p>

<p>The reason why you can't overload a destructor is because your code wouldn't have a clue about which destructor it needs to call when you destroy an object. Unless you're calling destructors badly but then you're behaving badly! ;-)</p>
",0
197689,197675,4,"<p>This isn't something that's in the spec -- it's implementation dependent.</p>
",0
197698,197675,2,"<p>Because the array to be 'deleted' should have been created with a single use of the 'new' operator.  The 'new' operation should have put that information on the heap.  Otherwise, how would additional uses of new know where the heap ends?</p>
",0
197699,197675,206,"<p>When you allocate memory on the heap, your allocator will keep track of how much memory you have allocated. This is usually stored in a ""head"" segment just before the memory that you get allocated. That way when it's time to free the memory, the de-allocator knows exactly how much memory to free.</p>
",16
197706,197675,0,"<p>It is not standardized. In Microsoft's runtime the new operator uses malloc() and the delete operator uses free(). So, in this setting your question is equivalent to the following: How does free() know the size of the block?</p>

<p>There is some bookkeeping going on behind the scenes, i.e. in the C runtime.</p>
",1
197716,197675,11,"<p>The information is not standardised. However in the platforms that I have worked on this information is stored in memory just before the first element. Therefore you could theoretically access it and inspect it, however it's not worth it.</p>

<p>Also this is why you must use delete [] when you allocated memory with new [], as the array version of delete knows that (and where) it needs to look to free the right amount of memory - and call the appropriate number of destructors for the objects.</p>
",0
206355,197675,8,"<p>It's defined in the C++ standard to be compiler specific. Which means compiler magic. It can break with non-trivial alignment restrictions on at least one major platform.</p>

<p>You can think about possible implementations by realizing that <code>delete[]</code> is only defined for pointers returned by <code>new[]</code>, which may not be the same pointer as returned by <code>operator new[]</code>. One implementation in the wild is to store the array count in the first int returned by <code>operator new[]</code>, and have <code>new[]</code> return a pointer offset past that. (This is why non-trivial alignments can break <code>new[]</code>.)</p>

<p>Keep in mind that <code>operator new[]/operator delete[]</code>!=<code>new[]/delete[]</code>.</p>

<p>Plus, this is orthogonal to how C knows the size of memory allocated by <code>malloc</code>. </p>
",0
206407,197675,5,"<p>Basically its arranged in memory as:</p>

<p>[info][mem you asked for...]</p>

<p>Where info is the structure used by your compiler to store the amount of memory allocated, and what not.</p>

<p>This is implementation dependent though.</p>
",0
561847,561839,13,"<p>Well, one practical difference would be that <code>WCHAR</code> doesn't exist on my platform. For Windows only (and with no intention of ever porting the program to another platform) and with the necessary headers included, it's the same (since <code>WCHAR</code> is just a <code>typedef</code>).</p>
",2
561859,561839,0,"<p>Practically speaking there isn't much difference.  They both represent the same underlying type.  A 2 byte width value.  </p>

<p>LibT will be on shortly to give you the real insane differences between the various platforms an the C++ standard :)</p>
",1
561918,561839,17,"<p><code>wchar_t</code> is a distinct type, defined by the C++ standard.</p>

<p><code>WCHAR</code> is <em>non</em>standard, and as far as I know, exists only on Windows. However, it is simply a <code>typedef</code> (or possibly a macro) for <code>wchar_t</code>, so it makes no practical difference.</p>

<p>Older versions of MSVC did not have <code>wchar_t</code> as a first-class type¡ªinstead it was simply a <code>typedef</code> for <code>short</code></p>

<p>Most likely, Microsoft introduced <code>WCHAR</code> to represent a ""wide character type"" across any compiler version, whether or not <code>wchar_t</code> existed as a native type.</p>

<p>You should use <code>wchar_t</code> in your code though. That's what it's for.</p>
",0
564059,561839,5,"<p>Does anybody know how old <code>WCHAR</code> is? I would imagine it dates to at least Windows NT 3.1. I'd speculate that when Microsoft started using <code>WCHAR</code> in the Windows headers, <code>wchar_t</code> was not defined in either the C or C++ standard. Please correct me if I'm wrong.</p>

<p>Microsoft is in the unenviable position of having to support declarations and headers that a) must work in either C and C++ ; b) compile under very different architectures (i86, MIPS, PowerPC, Alpha, ...) and c) must be backwards-compatible with source code written for 15+ year old compilers. Plus, any breaking changes and thousands of books, reference manuals, online documentation, etc published over the last two decades would suddenly become WRONG.</p>

<p><code>WCHAR</code> is an interface¡ªonce it became published it was written in stone, even if it's not needed for new code.</p>
",0
223047,223021,67,"<p>When you #include a header file in C++, it places the whole contents of the header file into the spot that you included it in the source file. So including a file that has a <code>using</code> declaration has the exact same effect of placing the <code>using</code> declaration at the top of each file that includes that header file.</p>
",4
223050,223021,127,"<p>There's nothing special about header files that would keep the <code>using</code> declaration out.  It's a simple text substitution before the compilation even starts.</p>

<p>You can limit a <code>using</code> declaration to a scope:</p>

<pre><code>void myFunction()
{
   using namespace std; // only applies to the function's scope
   vector&lt;int&gt; myVector;
}
</code></pre>
",2
223221,223021,8,"<p>The scope is whatever scope the using declaration is in.</p>

<p>If this is global scope, then it will be at global scope.  If it is in global scope of a header file, then it will be in the global scope of every source file that includes the header.</p>

<p>So, the general advice is to <strong>avoid using declarations in global scope of header files</strong>.</p>
",2
223250,223021,58,"<p>The scope of the using statement depends on where it is located in the code:</p>

<ul>
<li>Placed at the top of a file, it has scope throughout that file.</li>
<li>If this is a header file, it will have scope in all files that include that header.  In general, this is ""<em>not a good idea</em>"" as it can have unexpected side effects</li>
<li>Otherwise the <em>using</em> statement has scope within the block that contains it from the point it occurs to the end of the block.  If it is placed within a method, it will have scope within that method.  If it is placed within a class definition it will have scope within that class.</li>
</ul>
",3
223030,223021,6,"<p>In the case cited, the file (""translation unit""), which means yes, every file that includes it.</p>

<p>You can also put the using statement inside the class, in which case, it's in effect just for that class. </p>

<p>Generally, if you need to specify a namespace in a header, it's often best to just fully-qualify every identifier necessary. </p>
",1
223036,223021,2,"<p>That is correct. The scope is the module that uses the <code>using</code> declaration. If any header files that a module includes have <code>using</code> declarations, the scope of those declarations will be that module, as well as any other modules that include the same headers.</p>
",0
224909,223021,1,"<p>There are a few comments that are rather unqualified when they say ""Don't"". That is too stern, but you have to understand when it is OK.</p>

<p>Writing <code>using std::string</code> is never OK. Writing <code>using ImplementationDetail::Foo</code> in your own header, when that header declares ImplementationDetail::Foo can be OK, moreso if the using declaration happens in your namespace. E.g.</p>

<pre><code>namespace MyNS {
    namespace ImplementationDetail {
        int Foo;
    }
    using ImplementationDetail::Foo;
}
</code></pre>
",4
212997,212990,7,"<p>You could try <a href=""http://www.sparxsystems.com.au/products/ea/index.html"" rel=""nofollow noreferrer"">Sparx Enterprise Architect</a> but the code quality would be average, not excellent.</p>

<p>I am not aware of any great automatic code generators for C++</p>

<p>Prices start from $135</p>
",1
213402,212990,0,"<p>Visio also supports this.</p>
",0
213416,212990,1,"<p>Visio is slow, and ate a whole weekend's worth of work one day.  Don't use it for UML.  </p>

<p>I've used <a href=""http://www.pragsoft.com/"" rel=""nofollow noreferrer"">UMLStudio</a> in the past -- it's cheap, and it did a decent job of reverse engineering my C++ code to make diagrams.  It's a little wonky to use, but it's fast as hell once you get into the spirit of the thing.</p>

<p>It will also generate code, but I was mainly in ""make pretty diagrams"" mode, rather than a full round-trip back and forth attempt to use UML like architecture astronauts say it should be use.</p>
",0
213699,212990,0,"<p>Not the answer you are looking for, but if the UML is that simple, then just write the code by hand, you will have far more control over you project in the long run. If you are wanting to use this as a technique to save large amts of repetitive typing, then on the face of it is sound like you may have a design problem to be addressed first.</p>

<p>I am slightly biased, as I would also say that if the UML is too complex then write the code yourself anyway, in fact I would seldom recommend generating code from UML.</p>

<p>UML is a modeling tool, it is not a programming language and should be language agnostic. You need be clear that those 2 concepts are different. Just because in your UML Model have a conceptual class, does not mean that when it comes to implementing that model that you need to create it as a class for various reasons ( Performance, Language constraints etc )</p>

<p>In short, let the design tools help you design, and the dev tools dev.</p>
",0
977817,212990,0,"<p><a href=""http://www.borland.com/us/products/together/index.html"" rel=""nofollow noreferrer"">Borland Together</a> was quite good for this when I used it during a c++ course.
The instructor recommended it, and it did seem to be quite feature-rich, but I'm unsure how much it costs.</p>
",0
832924,832810,11,"<ol>
<li>Pretty extensively, although people are mindful of the overhead of virtual function calls</li>
<li>It depends. Some developers swear off it completely, others make limited use of containers like vectors that will have good cache coherency and runtime performance and won't allocate constantly. I think a general observation would be that the more console-oriented the studio the less STL they use. PC developers can get away with it because they can fall back on the virtual memory system and there's plenty of CPU. Console guys care about every allocation and if you are doing a multiplatform title you get into the wonderful world of different platform's STL implementations behaving differently and having different bugs, although this situation has certainly improved in recent years. Game developers also like to manage their own heaps and allocations and this can be difficult to deal with with STL.</li>
<li>Expect it to be disabled in the compiler settings</li>
<li>Haha, good one.</li>
<li>I'm not sure. I haven't really seen smart pointer use in game code, although aside from a general aversion to dynamic memory I don't think there's anything particularly objectionable about smart pointers from a game development standpoint.</li>
<li>This one again depends. PC guys may allocate and deallocate like they just don't care. Console guys care about every allocation. That doesn't mean no new and delete but it can mean that dynamic allocations are only done once when the game or current level is set up and then left until the game or current level is torn down. Per frame allocating and deallocating is best avoided, not just to keep total memory use down but to avoid fragmentation. You'll see a lot of fixed sized arrays and statically allocated structures in a console game engine.</li>
</ol>
",3
832925,832810,26,"<p>I've worked in 2 game companies, seen a number of codebases, and observed a number of debates on matters such as these among game developers, so I might be able to offer some observations.  The short answer for each point is that it varies highly from studio to studio or even from team to team within the same studio.  Long answers enumerated below:</p>

<ul>
<li>polymorphism,</li>
</ul>

<p>Used by some studios but not others.  Many teams still prefer to avoid it.  Virtual function calls do come at a cost and that cost is noticeable at times even on modern consoles.  Of those that do use polymorphism, my cynical assumption is that only a small percentage use it well.</p>

<ul>
<li>STL,</li>
</ul>

<p>Split down the middle, for many of the same reasons as polymorphism.  STL is easy to use incorrectly, so many studios choose to avoid it on these grounds.  Of those that use it heavily, many people pair it with custom allocators.  EA has created <a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2271.html"" rel=""noreferrer"">EASTL</a>, which addresses many of the issue STL causes in game development.</p>

<ul>
<li>exception safety/handling,</li>
</ul>

<p>Very few studios use exception handling.  One of the first recommendations for modern consoles is to turn off both RTTI and exceptions.  PC games probably use exceptions to much greater effect, but among console studios exceptions are very frequently shunned.  They increase code size, which can be at a premium, and literally are not supported on some relevant platforms.</p>

<ul>
<li>templates with policy-based class design,</li>
</ul>

<p>Policy based design... I haven't come across any of it.  Templates are used pretty frequently for things like introspection/reflection and code reuse.  Policy based design, when I read Alexandrescu's book, seemed like a flawed promise to me.  I doubt it's used very heavily in the game industry, but it will vary highly from studio to studio.</p>

<ul>
<li>smart pointers</li>
</ul>

<p>Smart pointers are embraced by many of the studios that also use polymorphism and STL.  Memory management in console games is extremely important, so a lot of people dislike reference counting smart pointers because they're not explicit about when they free... but these are certainly not the only kind of smart pointer.  The smart pointer idea in general is still gaining traction.  I think it will be much more commonplace in 2-3 years.</p>

<ul>
<li>new/delete, placement new/delete</li>
</ul>

<p>These are used frequently.  They are often overridden to use custom allocators underneath, so that memory can be tracked and leaks can be found with ease.</p>

<p>I think I agree with your conclusion.  C++ isn't used in game studios to as much of an extent as it could be.  There are good and bad reasons for this.  The good ones are because of performance implications or memory concerns, the bad ones are because people are stuck in a rut.  In a lot of ways it makes sense to do things the way they've always been done, and if that means C with limited C++ then it means C with limited C++.  But there are a number of anti-C++ biases floating around... some justified and some not.</p>
",0
833659,832810,7,"<ol>
<li>Lots</li>
<li>Way to much. But we are trying to limit ourselves to std::vector at runtime.</li>
<li>None what so ever.</li>
<li>What?</li>
<li>Our code has been infected by this illness yes. We will start whipping people for spreading the scourge however.</li>
<li>Yes. Lots.</li>
</ol>
",2
326452,28124,0,"<p>With <a href=""http://www.antlr.org"" rel=""nofollow noreferrer"">ANTLR</a> you can create a parser/compiler that will interpret the user input, then execute the calculations using the Visitor pattern.  <a href=""http://www.codeproject.com/KB/recipes/sota_expression_evaluator.aspx"" rel=""nofollow noreferrer"">A good example is here</a>, but it is in C#.  You should be able to adapt it quickly to your needs and remain using C++ as your development platform.  </p>
",0
28129,28124,0,"<p>Using <a href=""http://spirit.sourceforge.net/"" rel=""nofollow noreferrer"">Spirit</a> (for example) to parse (and the 'semantic actions' it provides to construct an expression tree that you can then manipulate, e.g., evaluate) seems like quite a simple solution. You can find a grammar for arithmetic expressions <a href=""http://www.cs.sunysb.edu/~warren/xsbbook/node24.html"" rel=""nofollow noreferrer"">there</a> for example, if needed... (it's quite simple to come up with your own).</p>

<p>Note: Spirit is <em>very</em> simple to learn, and quite adapted for such tasks.</p>
",0
28130,28124,3,"<p>If it will be used frequently and if it will be extended in the future, I would almost recommend adding either Python or Lua into your code. <a href=""http://www.lua.org/"" rel=""nofollow noreferrer"">Lua</a> is a very lightweight scripting language which you can hook into and provide new functions, operators etc. If you want to do more robust and complicated things, use Python instead.</p>
",0
28134,28124,0,"<p>There's generally two ways of doing it, with three possible implementations:</p>

<ol>
<li>as you've touched on yourself, a library to evaluate formulas</li>
<li>compiling the formula into code</li>
</ol>

<p>The second option here is usually done either by compiling something that can be loaded in as a kind of plugin, or it can be compiled into a separate program that is then invoked and produces the necessary output.</p>

<p>For C++ I would guess that a library for evaluation would probably exist somewhere so that's where I would start.</p>
",0
28137,28124,0,"<p>If you want to write your own, search for ""formal automata"" and/or ""finite state machine grammar""</p>

<p>In general what you will do is parse the string, pushing characters on a stack as you go.  Then start popping the characters off and perform tasks based on what is popped.  It's easier to code if you force equations to reverse-polish notation.</p>
",0
28159,28124,1,"<p>You can represent your formula as a tree of operations and sub-expressions. You may want to define types or constants for Operation types and Variables.</p>

<p>You can then easily enough write a method that recurses through the tree, applying the appropriate operations to whatever values you pass in.</p>
",0
28172,28124,0,"<p>To make your life easier, I think getting this kind of input is best done through a GUI where users are restricted in what they can type in. </p>

<p>If you plan on doing it from the command line (that is the impression I get from your post), then you should probably define a strict set of allowable inputs (e.g. only single letter variables, no whitespace, and only certain mathematical symbols: ()+-*/ etc.).</p>

<p>Then, you will need to:<br>
Read in the input char array<br>
Parse it in order to build up a list of variables and actions<br>
Carry out those actions - in <a href=""http://en.wikipedia.org/wiki/BOMDAS"" rel=""nofollow noreferrer"">BOMDAS</a> order</p>
",0
621747,621745,0,"<p>Try file.good() or cast the file to bool:</p>

<pre><code>file.open(""no such file"");
if (file)
  cout &lt;&lt; ""Open OK"" &lt;&lt; endl;
else
  cout &lt;&lt; ""Open FAILED"" &lt;&lt; endl;
</code></pre>
",1
621748,621745,3,"<p>file is an object - it cannot be null. However, ifstream has an operator void*() overload which returns 0 when the file is in a bad state. When you say (for example):</p>

<pre><code>cout &lt;&lt; file &lt;&lt; endl;
</code></pre>

<p>the compiler converts this to:</p>

<pre><code>cout &lt;&lt; file.operator void*() &lt;&lt; endl;
</code></pre>

<p>This conversion will be used in all sorts of places - basically anywhere that a pointer or integer type could be used. It is used when you say:</p>

<pre><code>(file == NULL)
</code></pre>

<p>You compare the zero returned by operator void*() zero with NULL and get 1.</p>
",1
988110,987960,5,"<p>Sit down with a piece of paper and decide your library architecture.  </p>

<p>The library should be designed as a set of levels.  </p>

<ul>
<li>A libary on level A (the base) should have dependencioes only on system libraries and only if it must on libraries on level A.  </li>
<li>A library on level B can have dependencies on libraries at level A and system libararies and only if it must on libraries on level B.</li>
<li>etc</li>
</ul>

<p>Each library should represent a complete job at its particular level. Things at lower level generally have smaller jobs but lots of them. A library at a higher level should reresent a complete task. ie don't have a lib for windows objects and a lib for events. At this level the job here is handline all interaction with a window (this includes how it interacts with events).</p>

<p>You seem to have identified some resonable functional groups. The only one that see a bit suspicious is io. If you truly have some generic IO routines that provide real functionality fine. But if it is just grouping the IO for a bunch of different objects then I would scrap that (it all depends on the usage).  </p>

<p>So the next step is to identify the relationship between them. </p>

<p>As for using directory structures. Usually everything in one directory will be present within the same library, but that does not exclude the posability of other directories also being present. I would avoid putting half the classes in directory in libA and the other half of the classes in libB etc.</p>
",2
988055,987960,1,"<p>I like starting from a package diagram that only has one way arrows.  </p>

<p><a href=""http://www.agilemodeling.com/style/packageDiagram.htm"" rel=""nofollow noreferrer"">http://www.agilemodeling.com/style/packageDiagram.htm</a></p>

<p>Your list looks like a good start.</p>
",0
988975,987960,1,"<p>Seems reasonable.</p>

<p>I'd query what your <code>unit_tests</code> library is supposed to do.
Given a collection of ""projects"" building libA, libB, libC... I'd expect to see some matching projects testA testB testC (whether they build libraries or executables depends whether the built tests run standalone or are loaded into some test runner).</p>

<p>I'm also slightly wary of ""utilities"" libraries.  These seem to have a surprising ability to cause pain and suffering in the long run.  For example, maybe your IO library has no other dependency than the utilities library.  One day you want to reuse the IO library in another project on another platform.  Only problem is, you now also have to port all of the utilities library (90% of which IO doesn't use), or disentangle the 10% of it which IO actually depends on.  Sometimes it's better to have libraries be a bit more dependency free, at the cost of some code duplication.</p>
",1
990074,987960,2,"<p>You should have a read of Large-Scale C++ Software Design by John Lakos. </p>

<p>You may not be able to read it before you start your work, but you should put this book on your list.</p>

<p>Otherwise Martin York's advise is sound.</p>

<p>One more thing though, I would recommend picking up a tool like doxygen that can give you dependency diagrams of your code base. If your bothering to do this type of restructuring you should rid yourself of circular dependencies between your libraries. Lakos describes a lot of ways to cut dependencies - some obvious, some less so.</p>
",2
1135217,1135187,2,"<p>Try to <code>#include &lt;A.h&gt;</code> in that file. The compiler needs to know what <code>class A</code> looks like.</p>
",0
1135271,1135187,0,"<p>You'll find that there are a lot of things that g++ lets you get away with that sunpro will complain about, and vice-versa.</p>

<p>Be prepared for a lot of this sort of thing.</p>

<p>GMan's answer looks right to me.</p>
",0
77457,77293,2,"<p>You can use ""OK"" and ""Cancel""</p>

<p>By substituting <code>MessageBoxButtons::YesNo</code> with <code>MessageBoxButtons::OKCancel</code></p>

<p><a href=""http://msdn.microsoft.com/en-us/library/system.windows.forms.messageboxbuttons.aspx"" rel=""nofollow noreferrer"">MessageBoxButtons Enum</a></p>

<p>Short of that you would have to create a new form, as I don't believe the Enum can be extended.</p>
",0
86358,77293,0,"<p>From everything I can find it looks like <a href=""https://stackoverflow.com/users/1736/corin"">Corin</a> is right. Here is the code that I used to accomplish the original goal. I am not usually a Managed C++ programmer, so any editing would be appreciated.</p>

<p>CustomMessageBox.h:</p>

<pre><code>using namespace System::Windows::Forms;

/// &lt;summary&gt;
/// A message box for the test. Used to ensure user wishes to continue before starting the test.
/// &lt;/summary&gt;
public ref class CustomMessageBox : Form
{
private:
    /// Used to determine which button is pressed, default action is Cancel
    static String^ Button_ID_ = ""Cancel"";

    // GUI Elements
    Label^ warningLabel_;
    Button^ continueButton_;
    Button^ cancelButton_;

    // Button Events
    void CustomMessageBox::btnContinue_Click(System::Object^ sender, EventArgs^ e);
    void CustomMessageBox::btnCancel_Click(System::Object^ sender, EventArgs^ e);

    // Constructor is private. CustomMessageBox should be accessed through the public ShowBox() method
    CustomMessageBox();

public:
    /// &lt;summary&gt;
    /// Displays the CustomMessageBox and returns a string value of ""Continue"" or ""Cancel""
    /// &lt;/summary&gt;
    static String^ ShowBox();
};
</code></pre>

<p>CustomMessageBox.cpp:</p>

<pre><code>#include ""StdAfx.h""
#include ""CustomMessageBox.h""

using namespace System::Windows::Forms;
using namespace System::Drawing;

CustomMessageBox::CustomMessageBox()
{
    this-&gt;Size = System::Drawing::Size(420, 150);
    this-&gt;Text=""Warning"";
    this-&gt;AcceptButton=continueButton_;
    this-&gt;CancelButton=cancelButton_;
    this-&gt;FormBorderStyle= ::FormBorderStyle::FixedDialog;
    this-&gt;StartPosition= FormStartPosition::CenterScreen;
    this-&gt;MaximizeBox=false;
    this-&gt;MinimizeBox=false;
    this-&gt;ShowInTaskbar=false;

    // Warning Label
    warningLabel_ = gcnew Label();
    warningLabel_-&gt;Text=""This may take awhile, do you wish to continue?"";
    warningLabel_-&gt;Location=Point(5,5);
    warningLabel_-&gt;Size=System::Drawing::Size(400, 78);
    Controls-&gt;Add(warningLabel_);

    // Continue Button
    continueButton_ = gcnew Button();
    continueButton_-&gt;Text=""Continue"";
    continueButton_-&gt;Location=Point(105,87);
    continueButton_-&gt;Size=System::Drawing::Size(70,22);
    continueButton_-&gt;Click += gcnew System::EventHandler(this, &amp;CustomMessageBox::btnContinue_Click);
    Controls-&gt;Add(continueButton_);

    // Cancel Button
    cancelButton_ = gcnew Button();
    cancelButton_-&gt;Text=""Cancel"";
    cancelButton_-&gt;Location=Point(237,87);
    cancelButton_-&gt;Size=System::Drawing::Size(70,22);
    cancelButton_-&gt;Click += gcnew System::EventHandler(this, &amp;CustomMessageBox::btnCancel_Click);
    Controls-&gt;Add(cancelButton_);
}

/// &lt;summary&gt;
/// Displays the CustomMessageBox and returns a string value of ""Continue"" or ""Cancel"", depending on the button
/// clicked.
/// &lt;/summary&gt;
String^ CustomMessageBox::ShowBox()
{
    CustomMessageBox^ box = gcnew CustomMessageBox();
    box-&gt;ShowDialog();

    return Button_ID_;
}

/// &lt;summary&gt;
/// Event handler: When the Continue button is clicked, set the Button_ID_ value and close the CustomMessageBox.
/// &lt;/summary&gt;
/// &lt;param name=""sender""&gt;The source of the event.&lt;/param&gt;
/// &lt;param name=""e""&gt;The &lt;see cref=""System.EventArgs""/&gt; instance containing the event data.&lt;/param&gt;
void CustomMessageBox::btnContinue_Click(System::Object^ sender, EventArgs^ e)
{
    Button_ID_ = ""Continue"";
    this-&gt;Close();
}

/// &lt;summary&gt;
/// Event handler: When the Cancel button is clicked, set the Button_ID_ value and close the CustomMessageBox.
/// &lt;/summary&gt;
/// &lt;param name=""sender""&gt;The source of the event.&lt;/param&gt;
/// &lt;param name=""e""&gt;The &lt;see cref=""System.EventArgs""/&gt; instance containing the event data.&lt;/param&gt;
void CustomMessageBox::btnCancel_Click(System::Object^ sender, EventArgs^ e)
{
    Button_ID_ = ""Cancel"";
    this-&gt;Close();
}
</code></pre>

<p>And then finally the modification to the original code:</p>

<pre><code>// Launch a Message Box with advice to the user
String^ result = CustomMessageBox::ShowBox();

// The test will only be launched if the user has selected Continue on the Message Box
if(result == ""Continue"")
{
    // Execute Code
}
</code></pre>
",0
143262,143233,2,"<p>I think you want your classes to use an input stream instead of <code>std::cin</code> directly.  You'll want to either pass the input stream into the classes or set it on them via some method.  You could, for exmaple, use a <code>stringstream</code> to pass in your test input:</p>

<pre><code>
std::istringstream iss(""1.0 2 3.1415"");
some_class.parse_nums(iss, one, two, pi);
</code></pre>
",0
143271,143233,3,"<p><a href=""http://www.cplusplus.com/reference/iostream/ios/rdbuf.html"" rel=""nofollow noreferrer"">rdbuf</a> does exactly what you want. You can open a file for reading and replace cin's rdbuf with the one from the file. (see the link for a example using cout).</p>

<p>On unix-like OS you could close the 0 file handle (stdin) and open another file. It will have the lowest avaiable handle, which in this case would be 0. Or use one of posix calls that do exactly this. I'm not sure, but this may also work on Windows.</p>
",0
143239,143233,10,"<p>The appropriate method is to rewrite your classes so that they are testable. They should accept as a parameter the handle, stream or file from which they are supposed to read data - in your test framework, you can then mock in the stream or supply the path to the file containing the test data.</p>
",0
143243,143233,3,"<p>You should be able to use freopen() to point stdin to an arbitrary file.</p>
",0
143948,143233,2,"<p>We can redirect cin in order it read data from a file. Here is an example :</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;

int main()
{
    std::ifstream inputFile(""Main.cpp"");
    std::streambuf *inbuf = std::cin.rdbuf(inputFile.rdbuf());

    string str;
    // print the content of the file without 'space' characters
    while(std::cin &gt;&gt; str)
    {
        std::cout &lt;&lt; str;
    }

    // restore the initial buffer
    std::cin.rdbuf(inbuf);
}
</code></pre>
",0
425411,425400,0,"<p>This book may give you some ideas:</p>

<p><a href=""https://rads.stackoverflow.com/amzn/click/com/0201633620"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">http://www.amazon.com/Large-Scale-Software-Addison-Wesley-Professional-Computing/dp/0201633620</a></p>

<p>Large-Scale C++ Software Design</p>

<p>by John Lakos</p>
",0
425414,425400,4,"<p>As you mentioned in your question, using an abstract interface is your best option. Your DLL should have factory methods for creating/destroying instances of your concrete class. I didn't quite get your point about the downside of this.</p>
",2
425436,425400,7,"<p>You can hide parts of a class using the so-called ""cheshire cat"", ""letter/envelope"", or ""pimpl"" technique (which are, all, different names for the same technique):</p>

<pre><code>class MainWindow
{
private:
    //opaque data
    class ImplementationDetails;
    ImplementationDetails* m_data;
public:
    ... declare your public methods here ...
}
</code></pre>

<p>The best way is probably the abstract class mentioned in your 2nd paragraph (however I  failed to understand your last sentence, in which you (tried/failed to) explain what your counter-argument to that is).</p>
",1
426349,425400,0,"<p>As has been said before, you want to use a pimpl. I've done it and it works really well. It's totally transparent to the user of your library.</p>
",0
425849,425400,1,"<p>One way or the other, you have two options:</p>

<ol>
<li>let the library user's compiler figure out the memory size needed for your data - then the compiler can place it on stack</li>
<li>or allocate the data on the heap for the library user so that the user's compiler does not need to know how big the data are.</li>
</ol>

<p>Whether you expose (2) via pimpl or MyAbstractObject *o = createMyObject() is not much different.</p>

<p>A third option (a hack so terrible, it's funny) creates a large byte array in the object you expose to the user, and you initialize your real objects in that array using ""in-place"" new. Please don't do this. I'll go and wash my brains with soap.</p>
",0
644037,643971,2,"<p>I prefer a map</p>

<pre><code>void foo( Object* obj ){
    // Print out the name of each object only once 
    static std::map&lt;Object*, size_t&gt; calls;
    if(calls[obj] == 0) {
        std::cout &lt;&lt; ""This gets printed only once per object! ""
                  &lt;&lt; obj-&gt;GetName();
        calls[obj] = 1;
    }
}
</code></pre>

<p>You may also decide to increment the counter if you want to count the calls too. But note that it is also not really fail-safe. If you delete an object, and then new it again and it happens to get the same address, it will be assumed to be already printed. </p>
",1
644048,643971,1,"<pre><code>#include &lt;iostream&gt;
#include &lt;ostream&gt;
#include &lt;set&gt;
#include &lt;string&gt;

class Object
{
public:
    Object( const std::string&amp; name ):
        name_( name )
    {}
    std::string GetName() const
    {
        return name_;
    }
private:
    std::string name_;
};

void print( Object* object )
{
    std::cout &lt;&lt; object-&gt;GetName() &lt;&lt; std::endl;
}

template &lt;typename T, typename TFunction&gt;
void doOnce( T* object, TFunction function )
{
    static std::set&lt;T*&gt; objectsThatWasThere;

    if ( objectsThatWasThere.end() == objectsThatWasThere.find( object ) )
    {
        function( object );
        objectsThatWasThere.insert( object );
    }
}

int main()
{
    Object obj1(""Test"");
    Object obj2(""The"");

    doOnce( &amp;obj1, print );
    doOnce( &amp;obj1, print );
    doOnce( &amp;obj1, print );
    doOnce( &amp;obj2, print );
    doOnce( &amp;obj2, print );
    doOnce( &amp;obj2, print );

    return 0;
}
</code></pre>
",0
644061,643971,1,"<p>You'll probably need to memoize the objects.   Something linke</p>

<pre><code>bool do_once( Object * obj )
{
    static std::set&lt;Object*&gt; memo; 
    if ( memo.count(obj) )
    {
        memo.insert(obj);
        return true;
    }
    return false;
}
#define DO_ONCE(o,a) (do_once(obj) &amp;&amp; a)
</code></pre>
",0
644020,643971,3,"<p>Put your objects in a container and filter/group so each one only appears once. This can be done trivially by using <code>set</code> (or <code>std::tr1::unordered_set</code>) as the container for your objects. This effectively makes them unique. You can then iterate over the container.</p>

<p>Or, as others have proposed, use the container inside the function as a memoization device. However, in general I think explicitly grouping the results may be more appropriate.</p>
",0
644263,643971,1,"<pre><code>#include &lt;set&gt;

...

#define DO_ONCE(type, val, stmt) \
do \
{ \
    type __tmp = (val); \
    static std::set &lt; type &gt; __memo; \
    if (__memo.find(__tmp) == __memo.end()) \
    { \
        __memo.insert(__tmp); \
        do { stmt; } while(0); \
    } \
} \
while(0)

...

DO_ONCE(Object *, obj, printf(...));
</code></pre>
",5
295149,295120,23,"<p>In GCC you can declare your function with the attribute deprecated like this:</p>

<pre><code>void myfunc() __attribute__ ((deprecated));
</code></pre>

<p>This will trigger a compile-time warning when that function is used in a .c file.</p>

<p>You can find more info under ""Diagnostic pragmas"" at 
<a href=""http://gcc.gnu.org/onlinedocs/gcc/Pragmas.html"" rel=""noreferrer"">http://gcc.gnu.org/onlinedocs/gcc/Pragmas.html</a></p>
",0
295154,295120,4,"<p>Dealing with portable projects it's almost inevitable that you at some point need a section of preprocessed alternatives for a range of platforms. #ifdef this #ifdef that and so on. </p>

<p>In such a section you could very well conditionally define a way to deprecate symbols. My preference is usually to define a ""warning"" macro since most toolchains support custom compiler warnings. Then you can go on with a specific warning macro for deprecation etc.
For the platforms supporting dedicated deprecation methods you can use that instead of warnings.</p>
",0
295229,295120,131,"<p>This should do the trick:</p>

<pre><code>#ifdef __GNUC__
#define DEPRECATED(func) func __attribute__ ((deprecated))
#elif defined(_MSC_VER)
#define DEPRECATED(func) __declspec(deprecated) func
#else
#pragma message(""WARNING: You need to implement DEPRECATED for this compiler"")
#define DEPRECATED(func) func
#endif

...

//don't use me any more
DEPRECATED(void OldFunc(int a, float b));

//use me instead
void NewFunc(int a, double b);
</code></pre>

<p>However, you will encounter problems if a function return type has a commas in its name e.g. <code>std::pair&lt;int, int&gt;</code> as this will be interpreted by the preprocesor as passing 2 arguments to the DEPRECATED macro. In that case you would have to typedef the return type.</p>

<p>Edit: simpler (but possibly less widely compatible) version <a href=""https://stackoverflow.com/a/21265197/2651243"">here</a>.</p>
",12
577334,577243,9,"<p>To guarantee you trigger compiler errors if there is a macro that might be defined with the same name as your member function and you're not certain if it has been reliably undefined.</p>

<p>No kidding, I'm pretty sure I've had to do exactly this for that reason!</p>
",3
577247,577243,2,"<p>I can think of readability like when you use additional parenthesis to make things clear.</p>
",0
577249,577243,1,"<p>I don't think it makes a difference to the compiler, but I always write this-> because I believe it makes the code self-documenting. </p>
",0
577250,577243,2,"<p>I think it is mainly as an aid to the reader. It makes it explicit that what is being called is a method on the object, and not an ordinary function. When reading code, it can be helpful to know that the called function can change fields in the current object, for instance.</p>
",0
577251,577243,31,"<p>If there is another variable in the same scope with the same name, the this-> will remove the ambiguity.</p>

<pre><code>void Bar::setFoo(int foo)
{
    this-&gt;foo = foo;
}
</code></pre>

<p>Also it makes it clear that you're refering to a member variable / function.</p>
",4
577253,577243,1,"<p>Disambiguation: in case you have another similar naming function/variable in the same namespace? I've never seen usage for any other reason.</p>
",0
577257,577243,2,"<p>It's your own choice. I find it more clear when you use this. But if you don't like it, you can ommit it.</p>
",0
577258,577243,5,"<p>As ""code reason"", to distinguish a local parameter or value (that takes precedence) from a member:</p>

<pre><code>class Foo
{
    int member;
    void SetMember(int member)
    {
       this-&gt;member = member;
    }
}
</code></pre>

<p>However, that's bad practive to begin with, and usually can be solved locally.</p>

<p>The second reason is more ""environment"": it sometimes helps Intellisense to filter what I am really looking for. However, I also thing when I use this to find the member I am looking for I should also remove this.</p>

<p>So yes, there are good reasons, but they are all temporary (and bad on the long run).</p>
",3
577260,577243,2,"<p>This is really a matter of style and applies to many other languages such as Java and C#. Some people prefer to see the explicit <code>this</code> (or <code>self</code>, or <code>Me</code>, or whatever) and others do not. Just go with whatever is in your style guidelines, and if it's your project, you get to decide the guidelines.</p>
",1
577262,577243,1,"<p>I prefer it without the explicit this pointer as well. For method calls it doesn't add a lot of value, but it helps distinguish local variables from member variables. </p>
",0
577269,577243,2,"<p>This is done to be explicit about the fact that the variable being used is a member variable as opposed to a local or global variable.  It's not necessary in most cases, but being explicit about the scope could be helpful if you've trumped the variable with a declaration of the same name in a tighter scope.</p>

<p>At companies I've worked at, we just prepended ""m_"" to member variables.  It can be helpful sometimes, and I much prefer it to using ""this->"".</p>

<p>Edit:
Adding a link to <a href=""http://gcc.gnu.org/onlinedocs/gcc/Name-lookup.html"" rel=""nofollow noreferrer"">the GCC docs</a>, which explain a case where using this-> is necessary to get a non-dependent lookup to work correctly.</p>
",0
577290,577243,42,"<p>The only place where it really makes a difference is in templates in derived classes:</p>

<pre><code>template&lt;typename T&gt;
class A {
protected:
  T x;
};

template&lt;typename T&gt;
class B : A&lt;T&gt; {
public:
  T get() {
    return this-&gt;x;
  }
};
</code></pre>

<p>Due to <a href=""http://www.parashift.com/c++-faq-lite/templates.html#faq-35.19"" rel=""noreferrer"">details in the name lookup in C++ compilers</a>, it has to be made explicitly clear that <code>x</code> is a (inherited) member of the class, most easily done with <code>this-&gt;x</code>. But this is a rather esoteric case, if you don't have templated class hierarchies you don't really need to explicitly use <code>this</code> to access members of a class.</p>
",1
577292,577243,1,"<p>I can't quite remember the exact circumstances, but I've seen (very rare) instances where I had to write ""this->membername"" to successfully compile the code with GCC. All that I remember is that it was not in relation to ambiguity and therefore took me a while to figure out the solution. The same code compiled fine without using this-> in Visual Studio. </p>
",1
334883,334882,12,"<p>They don't have to be! A default parameter can be any expression within certain limitations. It is evaluated every time the function is called.</p>
",0
335289,334882,59,"<p>Default parameter can be a subset of the full set of expressions. It must be bound at compile time and at the place of declaration of the default parameter. This means that it can be a function call or a static method call, and it can take any number of arguments as far as they are constants and/or global variables or static class variables, but not member attributes. </p>

<p>The fact that it is bound at compile time and in the place where the function is declared also means that if it makes use of a variable, that variable will be used even if a different variable shadows the original at the place of the function call.</p>

<pre><code>// Code 1: Valid and invalid default parameters
int global = 0;
int free_function( int x );

class Test
{
public:
   static int static_member_function();
   int member_function();

   // Valid default parameters
   void valid1( int x = free_function( 5 ) );
   void valid2( int x = free_function( global ) );
   void valid3( int x = free_function( static_int ) );
   void valid4( int x = static_member_function() );

   // Invalid default parameters
   void invalid1( int x = free_function( member_attribute ) ); 
   void invalid2( int x = member_function() );
private:
   int member_attribute;
   static int static_int;
};

int Test::static_int = 0;

// Code 2: Variable scope
int x = 5;
void f( int a );
void g( int a = f( x ) ); // x is bound to the previously defined x
void h()
{
   int x = 10; // shadows ::x
   g(); // g( 5 ) is called: even if local x values 10, global x is 5.
}
</code></pre>
",3
81003,80923,0,"<p>This is not exactly what you are searchng for, and it might not be easy to setup, but may be you could have a look at lxr : lxr.linux.no is a browseable kernel tree.</p>

<p>In the search box, if you enter a filename, it will give you where it is included.
But this is still guessing, and it does not track chained dependencies.</p>

<p>Maybe </p>

<pre><code>strace -e trace=open -o outfile make
grep 'some handy regex to match header' 
</code></pre>
",0
81014,80923,1,"<p>If you wish to know which files are included most of all, use this bash command:</p>

<blockquote>
  <p>find . -name '<em>.cpp' -exec egrep '^[:space:]</em>#include[[:space:]]+[""&lt;][[:alpha:][:digit:]_.]+["">]' {} \;</p>
  
  <blockquote>
    <p>| sort | uniq -c | sort -k 1rn,1<br>
     | head -20</p>
  </blockquote>
</blockquote>

<p>It will display top 20 files ranked by amount of times they were included.</p>

<p>Explanation: The 1st line finds all *.cpp files and extract lines with ""#include"" directive from it. The 2nd line calculates how many times each file was included and the 3rd line takes 20 mostly included files.</p>
",2
81016,80923,3,"<p>Using the Unix philosophy of ""gluing together many small tools"" I'd suggest writing a short script that calls gcc with the -M (or -MM) and -MF (OUTFILE) options (As detailed <a href=""http://gcc.gnu.org/onlinedocs/gcc-4.3.2/gcc/Preprocessor-Options.html#Preprocessor-Options"" rel=""nofollow noreferrer"">here</a>). That will generate the dependency lists for the make tool, which you can then parse easily (relative to parsing the source files directly) and extract out the required information.</p>
",1
81030,80923,4,"<p>The answers <a href=""https://stackoverflow.com/questions/42308/tool-to-track-include-dependencies"">here</a> will give you tools which track #include dependencies. But there's no mention of optimization and such.</p>

<p>Aside: The book ""Large Scale C++ Software Design"" should help.</p>
",0
81065,80923,2,"<p>From the root level of the source tree and do the following (\t is the tab character):</p>

<pre><code>find . -exec grep '[ \t]*#include[ \t][ \t]*[""&lt;][^""&gt;][""&gt;]' {} ';'
    | sed 's/^[ \t]*#include[ \t][ \t]*[""&lt;]//'
    | sed 's/[""&gt;].*$//'
    | sort
    | uniq -c
    | sort -r -k1 -n
</code></pre>

<p>Line 1 get all the include lines.
Line 2 strips off everything before the actual filename.
Line 3 strips off the end of the line, leaving only the filename.
Line 4 and 5 counts each unique line.
Line 6 sorts by line count in reverse order.</p>
",2
81075,80923,1,"<p>Use <a href=""http://ccache.samba.org/"" rel=""nofollow noreferrer"">ccache</a>.  It will hash the inputs to a compilation, and cache the results, which will drastically increase the speed of these sorts of compiles.</p>

<p>If you wanted to detect the multiple includes, so that you could remove them, you could use makedepend as Iulian ?erb?noiu suggests:</p>

<pre><code>makedepend -m *.c  -f - &gt; /dev/null
</code></pre>

<p>will give a warning for each multiple include.</p>
",0
80933,80923,0,"<p>IIRC gcc could create dependency files.</p>
",0
80950,80923,0,"<p>You might want to look at distributed compiling, see for example <a href=""http://distcc.samba.org/"" rel=""nofollow noreferrer"">distcc</a></p>
",0
80965,80923,4,"<p>Check out <a href=""http://www.xfree86.org/current/makedepend.1.html"" rel=""nofollow noreferrer"">makdepend</a></p>
",1
80975,80923,2,"<p>Tools like <a href=""http://www.doxygen.org"" rel=""nofollow noreferrer"">doxygen</a> (used with the graphviz options) can generate dependency graphs for include files... I don't know if they'd provide enough overview for what you're trying to do, but it could be worth trying.</p>
",0
81353,80923,1,"<p>Bash scripts found in the page aren't good solution. It works only on simple project. In fact, in large project, like discribe in header page, C-preprocessor (#if, #else, ...) are often used. Only good software more complex, like <a href=""http://www.xfree86.org/current/makedepend.1.html"" rel=""nofollow noreferrer"">makedepend</a> or <a href=""http://www.scons.org/"" rel=""nofollow noreferrer"">scons</a> can give good informations. gcc -E can help, but, on large project, its result analysis is a wasting time.</p>
",0
560858,560845,0,"<p>C++ or C/C++? I would say for both the most misunderstood parts are memory management and pointers. The former because people don't free appropriately (too early or not at all!) and the latter because a lot of people just don't ""get"" pointers (either in the pass by reference ""guise"" or in general in something like a linked list).</p>
",0
560859,560845,22,"<p>In decreasing order: </p>

<ol>
<li>make sure to release pointers for allocated memory</li>
<li><em>when destructors should be virtual</em> </li>
<li>how virtual functions work</li>
</ol>

<p>Interestingly not many people know the full details of virtual functions, but still seem to be ok with getting work done.</p>
",7
560875,560845,9,"<p>Pointers.</p>

<p>Dereferencing the pointers. Through either <code>.</code> or <code>-&gt;</code></p>

<p>Address of using <code>&amp;</code> for when a pointer is required.</p>

<p>Functions that take params by reference by specifing a <code>&amp;</code> in the signature.</p>

<p>Pointer to pointers to pointers <code>***</code> or pointers by reference <code>void someFunc(int *&amp; arg)</code></p>
",4
560877,560845,12,"<p>Here are some:</p>

<ol>
<li>Using templates to implement polymorphism without vtables, ¨¤ la ATL.</li>
<li>Logical <code>const</code>-ness vs actual <code>const</code>-ness in memory. When to use the <code>mutable</code> keyword.</li>
</ol>

<hr>

<p>ACKNOWLEDGEMENT: Thanks for correcting my mistake, spoulson.</p>

<p>EDIT:</p>

<p>Here are more:</p>

<ol>
<li>Virtual inheritance (not virtual methods): In fact, I don't understand it at all! (by that, I mean I don't know how it's implemented)</li>
<li>Unions whose members are objects whose respective classes have non-trivial constructors.</li>
</ol>
",5
560889,560845,4,"<p>Memory Alignment.</p>
",2
560896,560845,13,"<p>The <strong>static</strong> keyword which can mean one of three distinct things depending on where it is used.</p>

<ol>
<li>It can be a static member function or member variable.</li>
<li>It can be a static variable or function declared at namespace scope.</li>
<li>It can be a static variable declared inside a function.</li>
</ol>
",6
560897,560845,12,"<p>Here is an important concept in C++ that is often forgotten:</p>

<blockquote>
  <p>C++ should not be simply used like an object
  oriented language such as Java or C#.
  Inspire yourself from the STL and write generic code.</p>
</blockquote>
",15
560903,560845,80,"<p><strong>C++ is not C with classes!</strong></p>

<p>And there is no language called C/C++. Everything goes downhill from there.</p>
",4
560937,560845,-2,"<p>Very nice resource I can't get tired to promote - <a href=""http://yosefk.com/c++fqa/"" rel=""nofollow noreferrer"">C++ Frequently Questioned Answers</a></p>
",9
560941,560845,27,"<p>The difference between assignment and initialisation:</p>

<pre><code>string s = ""foo"";    // initialisation
s = ""bar"";           // assignment
</code></pre>

<p>Initialisation always uses constructors, assignment always uses operator=</p>
",3
561079,560845,9,"<p>There are a few things that people seem to be constantly confused by or have no idea about:</p>

<ol>
<li><p>Pointers, especially function pointers and multiple pointers (e.g. int(*)(void*), void***)</p></li>
<li><p>The const keyword and const correctness (e.g. what is the difference between const char*, char* const and const char* const, and what does void class::member() const; mean?)</p></li>
<li><p>Memory allocation (e.g. every pointer new'ed should be deleted, malloc/free should not be mixed with new/delete, when to use delete [] instead of delete, why the C functions are still useful (e.g. expand(), realloc()))</p></li>
<li><p>Scope (i.e. that you can use { } on its own to create a new scope for variable names, rather than just as part of if, for etc...)</p></li>
<li><p>Switch statements. (e.g. not understanding that they can optimise as well (or better in some cases) than chains of ifs, not understanding fall through and its practical applications (loop unrolling as an example) or that there is a default case)</p></li>
<li><p>Calling conventions (e.g. what is the difference between cdecl and stdcall, how would you implement a pascal function, why does it even matter?)</p></li>
<li><p>Inheritance and multiple inheritance and, more generally, the entire OO paradigm.</p></li>
<li><p>Inline assembler, as it is usually implemented, is not part of C++.</p></li>
</ol>
",7
561091,560845,10,"<p>a classic among beginners to c++ from c: </p>

<p>confuse <code>delete</code> and <code>delete[]</code></p>

<p>EDIT:</p>

<p>another classic failure among all levels of experience when using C API:</p>

<pre><code>std::string helloString = ""hello world"";
printf(""%s\n"", helloString);
</code></pre>

<p>instead of:</p>

<pre><code>printf(""%s\n"", helloString.c_str());
</code></pre>

<p>it happens to me every week. You could use streams, but sometimes you have to deal with printf-like APIs.</p>
",6
561100,560845,19,"<p>The overuse of inheritance unrelated to polymorphism.  Most of the time, unless you really do use runtime polymorphism, composition or static polymorphism (i.e., templates) is better.</p>
",5
561210,560845,-3,"<p>A big one is that the languages are not 100% syntactically compatible.  C++ is fully link compatible with C, but some C++ style syntax will generate a complier error in C.  Some compilers aren't picky and don't follow the C standard to the letter.  The basics of these need to be learned when moving from one language to the other.  Note I haven't read the latest C standard, but last I knew this was true.</p>
",5
561218,560845,8,"<ul>
<li>Pointers to members and pointers to member functions.</li>
<li>Non-type template parameters.</li>
<li>Multiple inheritance, particularly virtual base classes and shared base objects.</li>
<li>Order of construction and destruction, the state of virtual functions in the middle of constructing an intermediate base class.</li>
<li>Cast safety and variable sizes. No, you can't assume that <code>sizeof(void *) == sizeof(int)</code> (or any other type for that matter, unless a portable header specifically guarantees it) in portable code.</li>
<li>Pointer arithmetic.</li>
</ul>
",2
561334,560845,1,"<ul>
<li>That anonymous namespaces are almost always what is truly wanted when people are making static variables in C++</li>
<li>When making library header files, the pimpl idiom (<a href=""http://www.gotw.ca/gotw/024.htm"" rel=""nofollow noreferrer"">http://www.gotw.ca/gotw/024.htm</a>) should be used for almost all private functions and members to aid in dependency management</li>
</ul>
",1
561253,560845,3,"<p>C++ is not C with string and vector!</p>
",5
561464,560845,21,"<p>The most pernicious concept I've seen is that it should be treated as C with some addons.  In fact, with modern C++ systems, it should be treated as a different language, and most of the C++-bashing I see is based on the ""C with add-ons"" model.</p>

<p>To mention some issues:</p>

<p>While you probably need to know the difference between <code>delete</code> and <code>delete[]</code>, you should normally be writing neither.  Use smart pointers and <code>std::vector&lt;&gt;</code>.</p>

<p>In fact, you should be using a <code>*</code> only rarely.  Use std::string for strings.  (Yes, it's badly designed.  Use it anyway.)</p>

<p>RAII means you don't generally have to write clean-up code.  Clean-up code is bad style, and destroys conceptual locality.  As a bonus, using RAII (including smart pointers) gives you a lot of basic exception safety for free.  Overall, it's much better than garbage collection in some ways.</p>

<p>In general, class data members shouldn't be directly visible, either by being <code>public</code> or by having getters and setters.  There are exceptions (such as x and y in a point class), but they are exceptions, and should be considered as such.</p>

<p>And the big one:  there is no such language as C/C++.  It is possible to write programs that can compile properly under either language, but such programs are not good C++ and are not normally good C.  The languages have been diverging since Stroustrup started working on ""C with Classes"", and are less similar now than ever.  Using ""C/C++"" as a language name is prima facie evidence that the user doesn't know what he or she is talking about.  C++, properly used, is no more like C than Java or C# are.</p>
",6
561513,560845,12,"<p>Given this:</p>

<pre><code>int x = sizeof(char);
</code></pre>

<p>what value is X? </p>

<p>The answer you often hear is dependant on the level of understanding of the specification.</p>

<ol>
<li>Beginner - x is one because chars are always eight bit values.</li>
<li>Intermediate - it depends on the compiler implementation, chars could be UTF16 format.</li>
<li>Expert - x is one and always will be one since a char is the smallest addressable unit of memory and sizeof determines the number of units of memory required to store an instance of the type. So in a system where a char is eight bits, a 32 bit value will have a sizeof of 4; but in a system where a char is 16 bits, a 32 bit value will have a sizeof of 2.</li>
</ol>

<p>It's unfortunate that the standard uses 'byte' to refer to a unit of memory since many programmers think of 'byte' as being eight bits.</p>
",11
563086,560845,0,"<ol>
<li>The difference between pointer (*) and reference (&amp;)</li>
<li>Accesing multi dimentional arrays using pointers.</li>
<li>Using * to acess the value of a pointer - i.e. *ptr = 5</li>
<li>When to release allocated memory.</li>
</ol>
",0
563217,560845,40,"<p>That C++ <em>does</em> have automatic resource management.</p>

<p>(Most people who claim that C++ does not have memory management try to use new and delete way too much, not realising that if they allowed C++ to manage the resource themselves, the task gets much easier).</p>

<p>Example: (Made with a made up API because I do not have time to check the docs now)</p>

<pre><code>// C++
void DoSomething()
{
  File file(""/tmp/dosomething"", ""rb"");
  ... do stuff with file...
  // file is automatically free'ed and closed.
}

// C#
public void DoSomething()
{
  File file = new File(""/tmp/dosomething"", ""rb"");
  ... do stuff with file...

  // file is NOT automatically closed.
  // What if the caller calls DoSomething() in a tight loop?
  // C# requires you to be aware of the implementation of the File class
  // and forces you to accommodate, thus voiding implementation-hiding
  // principles.
  // Approaches may include:
  // 1) Utilizing the IDisposable pattern.
  // 2) Utilizing try-finally guards, which quickly gets messy.
  // 3) The nagging doubt that you've forgotten something /somewhere/ in your
  //    1 million loc project.
  // 4) The realization that point #3 can not be fixed by fixing the File
  //    class.
}
</code></pre>
",7
563226,560845,13,"<p><strong>Arrays are not pointers</strong></p>

<p>They are different. So <code>&amp;array</code> is not a pointer to a pointer, but a pointer to an array. This is the most misunderstood concept in both C and C++ in my opinion. You gotta have a visit to all those SO answers that tell to pass 2-d arrays as <code>type**</code> !</p>
",0
563345,560845,10,"<p>C++ is a multi-paradigm language. Many people associate C++ strictly with OOP.</p>
",0
563450,560845,0,"<p>Why is A[b] the same thing as b[A]?</p>

<p>Ok, not really a COMMON question, but it came up in a class I was teaching once...</p>
",2
563363,560845,35,"<p><strong>Free functions are not bad just because they are not within a class</strong> C++ is not an OOP language alone, but builds upon a whole stack of techniques. </p>

<p>I've heard it many times when people say free functions (those in namespaces and global namespace) are a ""relict of C times"" and should be avoided. Quite the opposite is true. Free functions allow to decouple functions from specific classes and allow reuse of functionality. It's also recommended to use free functions instead of member functions if the function don't need access to implementation details - because this will eliminate cascading changes when one changes the implementation of a class among other advantages.</p>

<p>This is also reflected in the language: The range-based for loop in <code>C++0x</code> (next C++ version released very soon) will be based on free function calls. It will get begin / end iterators by calling the free functions <code>begin</code> and <code>end</code>. </p>
",6
563578,560845,3,"<p><strong>C structs VS C++ structs</strong> is often misunderstood.</p>
",2
563437,560845,3,"<p>C++ is not a typical object oriented language. </p>

<p>Don't believe me? look at the STL, way more templates than objects.</p>

<p>It's almost impossible to use Java/C# ways of writing object oriented code; it simply doesn't work.</p>

<ul>
<li>In Java/C# programming, there's alot of <code>new</code>ing, lots of utility objects that implement some single cohesive functionality.</li>
<li>In C++, any object <code>new</code>ed must be deleted, but there's always the problem of who owns the object</li>
<li>As a result, objects tend to be created on the stack</li>
<li>But when you do that, you have to copy them around all the time if you're going to pass them around to other functions/objects, thus wasting a lot of performance that is said to be achieved with the unmanaged environment of C++</li>
<li>Upon realizing that, you have to think about other ways of organizing your code</li>
<li>You might end up doing things the procedural way, or using metaprogramming idioms like smart pointers</li>
<li>At this point, you've realized that OO in C++ cannot be used the same way as it is used in Java/C#</li>
</ul>

<p><a href=""http://en.wikipedia.org/wiki/Q.E.D."" rel=""nofollow noreferrer"">Q.E.D.</a></p>

<p>If you insist on doing oop with pointers, you'll usually have large (gigantic!) classes, with clearly defined ownership relationships between objects to avoid memory leaks. And then even if you do that, you're already too far from the Java/C# idiom of oop. </p>

<blockquote>
  <p><em>Actually I made up the term ""object-oriented"", and I can tell you I did not have C++ in mind.</em><br>
  -- <a href=""http://video.google.com/videoplay?docid=-2950949730059754521"" rel=""nofollow noreferrer"">Alan Kay</a> (click the link, it's a video, the quote is at 10:33)</p>
</blockquote>

<p><em>Although from a purist point of view (e.g. Alan Kay), even Java and C# fall short of true oop</em></p>
",4
566369,560845,4,"<p><strong><code>std::vector</code> does not create elements when reserve is used</strong></p>

<p>I've seen it that programmers argue that they can access members at positions greater than what <code>size()</code> returns if they <code>reserve()</code>'ed up to that positions. That's a wrong assumption but is very common among programmers - especially because it's quite hard for the compiler to diagnose a mistake, which will silently make things ""work"". </p>
",1
566393,560845,3,"<p><strong>A pointer is an iterator, but an iterator is not always a pointer</strong></p>

<p>This is also an often misunderstood concept. A pointer to an object is a random access iterator: It can be incremented/decremented by an arbitrary amount of elements and can be read and written. However, an iterator class that has operator overloads doing that fulfill those requirements too. So it is also an iterator but is of course not a pointer.</p>

<p>I remember one of my past C++ teachers was teaching (wrongly) that you get a pointer to an element of a vector if you do <code>vec.begin()</code>. He was actually assuming - without knowing - that the vector implements its iterators using pointers. </p>
",1
566416,560845,7,"<p><strong>If a function accepts a pointer to a pointer, <code>void*</code> will still do it</strong></p>

<p>I've seen that the concept of a <em>void pointer</em> is frequently confused. It's believed that if you have a pointer, you use a <code>void*</code>, and if you have a pointer to a pointer, you use a <code>void**</code>. But you can and should in both cases use <code>void*</code>. A <code>void**</code> does not have the special properties that a <code>void*</code> has.</p>

<p>It's the special property that a <code>void*</code> can also be assigned a pointer to a pointer and when cast back the original value is received. </p>
",1
566353,560845,7,"<p><strong>Headers and implementation files</strong></p>

<p>This is also a concept misunderstood by many. Questions like what goes into header files and why it causes link errors if function definitions appear multiple times in a program on the one side but not when class definitions appear multiple times on the other side. </p>

<p>Very similar to those questions is why it is important to have <em>header guards</em>.</p>
",0
576186,560845,1,"<p>I still don't get why vector doesn't have a pop_front and the fact that I can't sort(list.begin(), list.end()).. </p>
",1
1331723,560845,5,"<p><strong><code>NULL</code> is always zero.</strong></p>

<p>Many confuse <code>NULL</code> with an address, and think therefor it's not necessarily zero if the platform has a different null pointer address. </p>

<p>But <code>NULL</code> is always zero and it is not an address. It's an zero constant integer expression that can be converted to pointer types. </p>
",0
1191161,560845,1,"<p>I know this is old question but I thought object slicing / failure of polymorphism with objects on the stack worth mentioning. If I do not use C++ for six months, this one always comes out and bites me when I use the language again.</p>

<pre><code>#include &lt;iostream&gt;

class base {
    public:
    base(int val) { var1 = val; };
    virtual void doSomething() { var1 *= 2; };
    int getVar1() { return var1; };
    virtual ~base() { };
    protected:
    int var1;
};

class deriv : public base {
    public:
    deriv(int val) : base(val) { };
    void doSomething() { var1 *= 4; };
};

void use_object_ptr(base *arg) {
    arg-&gt;doSomething();
    std::cout &lt;&lt; arg-&gt;getVar1() &lt;&lt; std::endl;
};

void use_object_copy(base arg) {
    arg.doSomething();
    std::cout &lt;&lt; arg.getVar1() &lt;&lt; std::endl;
};

int main(int argc, char **argv) {
    deriv d(42);

    deriv *p2d = new deriv(42);

    use_object_ptr(p2d); // calls deriv::doSomething(), prints 168

    use_object_copy(d); // calls base::doSomething(), prints 84

    use_object_ptr(&amp;d); // calls deriv::doSomething(), prints 168

    return 0;
}
</code></pre>
",2
1192648,560845,1,"<ol>
<li>Allocation of objects, stack or heap.</li>
<li>Use of const.</li>
<li>Use of friend</li>
</ol>
",0
522358,502902,0,"<p>The file is still there in Visual Studio 2008. Check to make sure your include paths are correct. Make sure they are pointing to your Visual Studio 2008 directories. Perhaps if you include the first few errors/warnings in your project, I can help you further.</p>
",0
1302662,1214876,5,"<p>Instead of <code>offset_t</code> do you mean <code>ptrdiff_t</code>? This is the type returned by such routines as <code>std::distance</code>. My understanding is that <code>size_t</code> is unsigned (to match the address space as previously mentioned) whereas <code>ptrdiff_t</code> is signed (to theoretically denote ""backwards"" distances between pointers, though this is very rarely used).</p>
",1
1214888,1214876,1,"<p><code>offset_t</code> isn't mentioned at all in my copy of the C++ standard.</p>

<p><code>size_t</code> on the other hand, is meant simply to denote object or array sizes. A <code>size_t</code> is guaranteed to be big enough to store the size of any in-memory object, so it should be used for that. </p>
",0
1214897,1214876,1,"<p>You use <code>size_t</code> whenever the C++ language specification indicates that it is used in a particular expression. For example, you'd use <code>size_t</code> to store the return value of <code>sizeof</code>, or to represent the number of elements in an array (<code>new[]</code> takes <code>size_t</code>). </p>

<p>I've no idea what <code>offset_t</code> is - it's not mentioned once in ISO C++ spec.</p>
",0
1214910,1214876,13,"<p>You are probably referring to <code>off_t</code>, not <code>offset_t</code>. <code>off_t</code> is a POSIX type, not a C type, and it is used to denote file offsets (allowing 64-bit file offsets even on 32-bit systems). C99 has superceded that with <code>fpos_t</code>.</p>

<p><code>size_t</code> is meant to count bytes or array elements. It matches the address space.</p>
",3
834008,833882,0,"<p>If the functions you're using in the same expression are somehow related (one affects the results of the other), so different order of calls give different results, then refrain of using nested functions in expressions.</p>

<p>I do it as good practice, exactly because, as the other said, the calling order is undefined (you could have even interlaced execution, if the optimizer thought it will be more optimal).</p>
",0
833905,833882,2,"<p>The evaluation order is not specified by the standart. It depends only on your compiler.</p>
",1
833912,833882,3,"<p>I don't know what the standard says, but I think that if it matters to you, then you should probably re-arrange the code so that you know what's going to happen in which order (temp variables are your friends). Even if you figure out what the standard says, AND if we assume that your compiler implements that correctly, you're still leaving a maintenance time bomb, because your successors WON'T know everything you do.</p>
",1
833929,833882,14,"<p>The evaluation order is unspecified - see section 5.2.2/8 of the Standard:</p>

<blockquote>
  <p>The order of evaluation of arguments
  is unspecified. All side effects of
  argument expression evaluations take
  effect before the function is entered.</p>
</blockquote>
",4
406050,406043,8,"<p>POD, Plain Old Data, is any C++ type that has an equivalent in C.</p>

<p>cv-qualified type is a type that have been qualified either as a const or volatile.</p>

<pre><code>// non cv_qualified
int one; 
char *two; 

// cv-qualified 
const int three; 
volatile char * four; 
</code></pre>

<p>POD type's data members must be public and can be of any the primitive types: bool, numeric types, enumeration types, data-pointer types, pointer-to-function type, also arrays of any of the previous.</p>

<pre><code>struct A //POD
{
 int n;
 double y;
};

struct B //non-POD
{
private:
 int n;
 double y;
};
</code></pre>
",3
406068,406043,5,"<p><strong>POD</strong> stands for <strong>Plain Old Data</strong> type.  It usually refers to a class that is used to hold data and accessors---nothing else.  It is also implied that the function does not have a vtable, which means that there are no polymorphic members of the class.  These are popular for lightweight objects where you don't want to pay the price of the polymorphic class overhead.</p>

<p><strong>CV-qualified</strong>.  <strong>C=Const, V=Volatile</strong>.  </p>
",1
406291,406043,1,"<p>Very Nice article on <a href=""http://www.fnal.gov/docs/working-groups/fpcltf/Pkg/ISOcxx/doc/POD.html"" rel=""nofollow noreferrer"">POD</a> </p>
",0
406834,406043,0,"<blockquote>
  <p>what things in c++ that makes c++ type
  non equivalent to c ¨C rajKumar</p>
</blockquote>

<p>As CMS said, a POD type is a C++ type that has an equivalent in C: so, it has to follow the same rules C uses for:</p>

<ul>
<li>initialization</li>
<li>copying</li>
<li>layout</li>
<li>addressing</li>
</ul>

<p>The C++ type should <strong>not</strong> have any constructor, must <strong>not</strong> overload the assignment operator, must <strong>not</strong> have virtual functions, base classes, destructor and also non-static members that are private or protected.</p>
",0
1929049,1929037,6,"<p>Direct base classes are always initialised first, no matter what order you put the initialisation statements in.
If you turn on more compiler warnings, you should get a warning about this.</p>

<p>Which means that yes, it is wrong to initialise a base class with a member, sorry!</p>
",0
1929054,1929037,2,"<p>Yes it's wrong.</p>

<p>The order of initialization is:</p>

<ol>
<li>Base class objects (if present)</li>
<li>Member data objects</li>
<li>Constructor function code</li>
</ol>

<p>So this :</p>

<pre><code>explicit MyStream( SomeUsefulData&amp; data ) : 
    buffer_( data ),
    std::basic_iostream&lt; char &gt;( &amp;buffer_ )
</code></pre>

<p>Actually means that:</p>

<pre><code>explicit MyStream( SomeUsefulData&amp; data ) : 
    std::basic_iostream&lt; char &gt;( &amp;buffer_ ),
    buffer_( data )
</code></pre>
",0
1929083,1929037,0,"<p>its wrong
Rememebr that the base class is constructed first 
and then the derived class </p>

<p>here </p>

<pre><code>explicit MyStream( SomeUsefulData&amp; data ) : 
        ...
        std::basic_iostream&lt; char &gt;( &amp;buffer_ )
    {
    };
</code></pre>

<p>you try to init  the base class with buffer_ that isn't yet constructed </p>
",0
178308,178265,3,"<p>C, but present in C++, I find the comma operator really obfuscates code, take this...</p>

<pre><code>ihi = y[0]&gt;y[1] ? (inhi=1,0) : (inhi=0,1);
</code></pre>

<p>Terse and quite elegant, but very easy to miss or misunderstand.</p>
",1
178356,178265,11,"<p>I know it's C and not C++ but there is always the the <a href=""http://www.ioccc.org/"" rel=""noreferrer"">International Obfuscated C Code Contest</a>.  I have seen some code there that would make your head spin.</p>
",0
178361,178265,10,"<p>This is well known but still impressive way to swap two integers without creating temp variable:</p>

<pre><code>// a^=b^=a^=b;     // int a and int b will be swapped
// Technically undefined behavior as variable may only 
// be assined once within the same statement.
// 
// But this can be written correctly like this.
// Which still looks cool and unreadable ;-)

a^=b;
b^=a;
a^=b;
</code></pre>
",15
178367,178265,-3,"<p>Binary shift confuses me all the time. An example from the <code>java.util.concurrent.ConcurrentHashMap</code> package:</p>

<pre><code>return ((h &lt;&lt; 7) - h + (h &gt;&gt;&gt; 9) + (h &gt;&gt;&gt; 17))
</code></pre>
",1
178446,178265,33,"<p>This was on reddit recently   <a href=""http://www.eelis.net/C++/analogliterals.xhtml"" rel=""noreferrer"">http://www.eelis.net/C++/analogliterals.xhtml</a></p>

<pre><code> assert((o-----o
        |     !
        !     !
        !     !
        !     !
        o-----o ).area == ( o---------o
                            |         !
                            !         !
                            o---------o ).area );
</code></pre>
",3
178574,178265,-5,"<p>I vote for some black-magic-hackerish template metaprogramming (unfortunately don't have any on hand to post it).</p>
",0
178591,178265,16,"<p>Duff's Device (<a href=""http://en.wikipedia.org/wiki/Duff%27s_device"" rel=""nofollow noreferrer"">http://en.wikipedia.org/wiki/Duff%27s_device</a>) give me nightmares:</p>

<pre><code>strcpy(to, from, count)
char *to, *from;
int count;
{
    int n = (count + 7) / 8;
    switch (count % 8) {
    case 0: do { *to = *from++;
    case 7:      *to = *from++;
    case 6:      *to = *from++;
    case 5:      *to = *from++;
    case 4:      *to = *from++;
    case 3:      *to = *from++;
    case 2:      *to = *from++;
    case 1:      *to = *from++;
            } while (--n &gt; 0);
    }
}
</code></pre>
",2
178501,178265,10,"<pre><code>unsigned int reverse(register unsigned int x)
{
 x = (((x &amp; 0xaaaaaaaa) &gt;&gt; 1) | ((x &amp; 0x55555555) &lt;&lt; 1));
 x = (((x &amp; 0xcccccccc) &gt;&gt; 2) | ((x &amp; 0x33333333) &lt;&lt; 2));
 x = (((x &amp; 0xf0f0f0f0) &gt;&gt; 4) | ((x &amp; 0x0f0f0f0f) &lt;&lt; 4));
 x = (((x &amp; 0xff00ff00) &gt;&gt; 8) | ((x &amp; 0x00ff00ff) &lt;&lt; 8));
 return((x &gt;&gt; 16) | (x &lt;&lt; 16));
}
</code></pre>

<p>Reverses the order of the bits in an int.</p>
",3
179208,178265,7,"<p>Most Boost stuff - the template metaprogramming is bad enough, but when you factor in the workarounds necessary to get it to work on some compilers (*coughborlandcough*), it gets pretty ridiculous. Just try to understand Boost.Bind. Just try.</p>
",0
179225,178265,44,"<p>The inverse square root implementation in Quake 3:</p>

<pre><code>float InvSqrt (float x){
    float xhalf = 0.5f*x;
    int i = *(int*)&amp;x;
    i = 0x5f3759df - (i&gt;&gt;1);
    x = *(float*)&amp;i;
    x = x*(1.5f - xhalf*x*x);
    return x;
}
</code></pre>

<p><strong>Update:</strong>
<a href=""http://www.lomont.org/Math/Papers/2003/InvSqrt.pdf"" rel=""noreferrer"">How this works</a> (thanks ryan_s)</p>
",3
1713505,576767,0,"<p>Virtual function would be the answer I think, have you noticed COM, create a instance, it gives you a pointer to that interface represented as class. I guess that methods declared are not resolved by name,
but by slot index.</p>
",0
576769,576767,4,"<p>I don't believe so. Name mangling is used so that each overloaded function has a different name as viewed by the linker.</p>

<p>You could rewrite them in C and use the <code>extern ""C"" {}</code> construct but then you lose all your beautiful inheritance, polymorphism and so forth. You could also wrap the C++ inside C functions and expose only the C functions.</p>
",0
576770,576767,2,"<p>The only way I could think of is declaring functions as extern ""C"". The name mangling is required for the linker to distinguish e.g. overloaded functions by their parameter list (which would be unavailable to the linker if not for name mangling).</p>
",0
576782,576767,3,"<p>I think the best way to do this is to provide C wrappers around the C++ library. This was quite popular 10 or more years back when I was programming in C++ but I don't know if it is done any more.</p>

<p>Basically, for every <code>class C</code>, for every constructor <code>ctor</code> to be exposed to create an <code>extern ""C"" CPtr cCtor(....)</code> method that returns an opaque pointer <code>CPtr</code> and for every function <code>func</code> to be exposed you create <code>extern ""C"" cFunc(CPtr,....)</code></p>

<p>Another approach is to create a <code>CStruct</code> that has member variables of function pointer types, implement them to call the class methods and let the client do all the hard work.</p>
",0
169645,166641,1,"<p>If you were using a container where <code>size()</code> was O(n) (like <code>std::list</code>) and not O(1) (like <code>std::vector</code>), you would not be iterating through that container using indices. You would be using iterators instead.</p>

<p>Anyway, if the body of the loop is so trivial that recalculating <code>std::vector::size()</code> matters, then there is probably a more efficient (but possibly platform-specific) way to do the calculation, regardless of what it is. If the body of the loop is non-trivial, recalculating <code>std::vector::size()</code> each time is unlikely to matter.</p>
",0
170641,166641,1,"<ul>
<li>If you are modifying the vector (adding or removing elements) in the for loop then you should not use a temporary variable since this could lead to bugs.</li>
<li>If you are not modifying the vector size in the for loop then I would all the time use a temporary variable to store the size (this would make your code independant on the implementation details of vector::size.</li>
</ul>
",0
382516,382480,3,"<p>I'm no expert but i gonna try answering you anyway :) </p>

<ol>
<li>FooClass is a non-POD type. This mean it could have more than one sections of <code>private</code>, <code>public</code> or <code>protected</code>. Within such a section, the order is that of the definition of the members, but across those sections, order is arbitrary and unspecified. </li>
<li>foo will always point to FooClass. Well so we have guarantee there is no offset adjustment done. At least in one compilation, offsets will be the same then (don't have the backing up Standard quote. But it can't work if they were different).</li>
<li>We only care about behavior on a single compiler. Well since the order of members is unspecified across sections of access modifiers and the compiler is allowed to put padding between members, this won't buy us much.</li>
<li>We only care about objects on the stack (automatic storage duration). Well i don't see how that changes anything of the object layout.</li>
</ol>

<p>So after all i don't think you have any guarantee that the offset will be constant across compilations. For considerations within one compilation (so if we would play with a compiler whose generated code uses an ABI that changes with each different compilation), the offset just can't be different. But even if you know the offset, you can't access the member. Your only way to access a member is using the member access operator <code>-&gt;</code> and <code>.</code> (that's said in 9.2/9). </p>

<p>Why not use data member pointers? They allow accessing members safely. Here is an example: (<a href=""https://stackoverflow.com/questions/286402/initializing-struct-using-an-array#287353"">looking up members by name</a>).</p>
",4
382520,382480,1,"<p>There are two things off the top of my head that will affect the internal layout of an object:</p>

<ul>
<li>the size of member objects.  Hopefully you'll recompile all affected modules if you change a member definition.</li>
<li>packing pragmas may change the padding added between members.  Be sure that the packing is the same for all modules that use the class, or at least the section where the class is defined.  If you don't, you'll have bigger problems than unpredictable offsets.</li>
</ul>
",2
382533,382480,1,"<p>Bottom line: If this class contains anything other than PODs, then you can make absolutely no assumptions about the offsets. If the class is just a collection of public PODs, then you're safe.</p>

<p>Here is a link to a portion of a chapter in an excellent intermediate C++ book. I recommend everyone to read this book if you're serious about C++.</p>

<p>This particular excerpt addresses a portion the question presented here:</p>

<p><a href=""http://my.safaribooksonline.com/0321321928/ch11?portal=oreilly"" rel=""nofollow noreferrer"">http://my.safaribooksonline.com/0321321928/ch11?portal=oreilly</a></p>

<p>For the rest of the details, check out the book. My ""bottom line"" above is a simplistic summary of this chapter.</p>
",0
382559,382480,3,"<p>Under a single compiler where the compiler settings are always the same and there is nothing added to or taken away from FooClass, then yes, the distance between the address stored at <code>foo</code> and <code>&amp;(foo-&gt;bar)</code> will always be the same, or the compiler wouldn't be able to generate proper code that worked across compilation units.</p>

<p>However, once you add anything to the class, or change the compiler settings, all bets are off.</p>
",0
382561,382480,3,"<p>As far as I know, this should always be the case, POD class or not. At compile time, based on the compiler, architecture, settings, etc., the compiler determines the size of the class and the offsets of all its members. This is then fixed for all instances of the class in the compilation unit (and by extension the linked unit, if the one-definition rule is preserved).</p>

<p>Since the compiler treats type pointers literally, even if the underlying type is wrong (eg: the pointer has been c-style cast incorrectly), the computed distance between &amp;foo and &amp;(foo.bar) will be the same, since the offset is known statically at compile time.</p>

<p>Note: This has definitely been done before, effectively. See, for example, Microsoft's ATL data binding code using their 'offsetof' macro...</p>
",2
382586,382480,5,"<p>After you have compiled your program, <strong>Yes*</strong>.</p>

<p>The offset will remain constant.</p>

<p>There is one very important restriction, however:  <strong>foo must be pointing specifically to a FooClass object</strong>.  Not a class derived from FooClass, or anything else for that matter.</p>

<p>The reason that C++ makes the POD distinction regarding member offsets is because both multiple inheritance and the location (or lack of) a vtable pointer can create situations where the address of an object is not the same as the address of that object's base.</p>
",0
382761,382480,1,"<p>Yes, the offset is determined at compile-time, so as long as you're not comparing offsets across compilations or compilers, it will always be constant. </p>
",0
276814,276807,29,"<p>You refer to the C++ Standard, chapter 3.6.1 paragraph 5:</p>

<blockquote>
  <p>A return statement in main has the
  effect of leaving the main function
  (destroying any objects with automatic
  storage duration) and calling
  exit with the return value as the
  argument. If control reaches the end
  of main without encountering a return
  statement, the effect is that of
  executing <code>return 0;</code></p>
</blockquote>

<p>If you haven't got the Standard at hand, you can show then the paragraph in a Working Draft. Here is one for c++98, which already had this defined.</p>

<p>You can learn more <a href=""http://www.kuzbass.ru:8086/docs/isocpp/basic.html#basic.start.main"" rel=""noreferrer"">here</a>.</p>
",1
276817,276807,0,"<p>You could show them the line in <a href=""http://www.research.att.com/~bs/3rd.html"" rel=""nofollow noreferrer"">Bjarne Stroustrup's book</a> defining the standard where it states it: since it is the canonical standard for the language, it is not open for debate. Unfortunately I don't have a copy to look it up myself.</p>
",2
315999,315987,2,"<p>Often,</p>

<pre><code>operator string () const;
</code></pre>

<p>or</p>

<pre><code>friend ostream& operator &lt;&lt; (ostream&, const MyClass&);
</code></pre>
",1
316029,315987,3,"<p>Adding a semicolon after the class definition. This continuously bites me in the ass every time I forget to do it since gcc's error messages are vague and it generally says something like <em>""can't define a type in the return type of a function""</em> which doesn't mean a whole lot...</p>
",0
316038,315987,10,"<p>I find turning on the gcc flags <code>-Wall</code>, <code>-Werror</code>, and (this is the fun one) <code>-Weffc++</code> help catch a lot of potential problems. From the gcc man page:</p>

<blockquote>
<pre><code>  -Weffc++ (C++ only)
      Warn about violations of the following style guidelines from Scott
      Meyers¡¯ Effective C++ book:

      ¡¤   Item 11:  Define a copy constructor and an assignment operator
          for classes with dynamically allocated memory.

      ¡¤   Item 12:  Prefer initialization to assignment in constructors.

      ¡¤   Item 14:  Make destructors virtual in base classes.

      ¡¤   Item 15:  Have ""operator="" return a reference to *this.

      ¡¤   Item 23:  Don¡¯t try to return a reference when you must return
          an object.

      and about violations of the following style guidelines from Scott
      Meyers¡¯ More Effective C++ book:

      ¡¤   Item 6:  Distinguish between prefix and postfix forms of incre-
          ment and decrement operators.

      ¡¤   Item 7:  Never overload ""&amp;&amp;"", ""©¦©¦"", or "","".

      If you use this option, you should be aware that the standard
      library headers do not obey all of these guidelines; you can use
      grep -v to filter out those warnings.
</code></pre>
</blockquote>
",0
316040,315987,1,"<p>In header files, do</p>

<pre><code>#ifndef __SOMEDEFINE__
#define __SOMEDEFINE__

#endif
</code></pre>

<p>In VS, I add</p>

<pre><code>#pragma warning(disable: 4786)
</code></pre>

<p>Oh, I also use </p>

<pre><code>#include &lt;inttypes.h&gt;
</code></pre>

<p>cuz I &lt;3 C99 types.</p>
",3
316043,315987,1,"<p>I <strong>usually</strong> include an enum of return codes, so the class can tell its callers what happened in its member functions. Most often, this will be the only type returned by all the members of the class. All results are passed back by reference.</p>
",0
316079,315987,4,"<p>The first i do when putting a class together is putting some doxygen comment above it about why it exists and what it does. </p>

<p>I once worked on a group project where they said they want to document the stuff at the end of the project. And it was all of a mess to put the comments into the code later on. I don't want to have this happen again.</p>
",0
316127,315987,14,"<p>Oddly, most of the suggestions here are things I specifically don't do.</p>

<ul>
<li>I don't make dtors virtual unless I am designing it specifically to be inherited. It adds a lot of overhead and prevents automatic inlining, which is bad since most dtors are empty anyways (and few classes benefit from inheritance)</li>
<li>I don't make copy ctor/assignment op unless the defaults won't work -- and if it won't, I may want to reconsider the design. Remember, between string &amp; vector, there's hardly ever a reason to call new anymore. And creating your own copy ctor identical to the default one will almost certainly be less efficient.</li>
<li>I don't add string cast.  It causes too many problems where the cast is called silently where you didn't intend it to be.  Better to add a ToString() method.</li>
<li>I don't add a friend oper&lt;&lt;, because friends are evil and messy.  Better to add a Display(ostream) method.  Then the oper&lt;&lt; can call that, and doesn't need to be a friend.  In fact, you could make the oper&lt;&lt; a template function calling Display() and never have to worry about it again.</li>
</ul>
",5
316712,315987,1,"<p>I start by calling the development environment macro that sets up the include guards (#ifdefs and/or #pragma once).</p>

<p>Next I stub out the class name and any namespace it will be in, without adding any functionality at all.</p>

<p>Then I create the unit test file for that class, and add the first test (usually a parameter constructor test).</p>

<p>I just work from there, writing and refactoring the class as I think about what I really need from it.  Things I tend to test specifically: const-correctness, implicit and explicit conversions, types of exceptions thrown, etc.</p>
",0
316975,315987,3,"<p>Stop and think</p>
",0
318587,315987,1,"<p>The first thing I do with a totally new class file is to write several paragraphs of comments on what the class does, why it exists, what classes it uses and how to use it. It should be enough that someone who randomly opens up a file in a module knows enough from that comment to find the file they are actually looking for.</p>

<p>I agree with James - I am very careful not to add functionality to a class that does not need it, most classes do not need a virtual destructor (or a destructor at all). If they do, I question why they don't just use smart pointers and other automatic memory management. Obviously there are many classes (i.e smart scoped locks) that DO need a destructor but it is not just a matter of course to make on.</p>
",0
1988667,1988192,1,"<p>Browing through the doxygen docs for ACE_Mutex, I don't understand how your code could possibly compile.  The time-out value (tv) is passed either by reference or a pointer so that acquire() can update the absolute time at which the mutex was acquired.  You cannot pass an expression.  Try it like this:</p>

<pre><code>ACE_Time_Value time = ACE_OS::gettimeofday() + ACE_Time_Value(30);
m_specsMutex.acquire(&amp;time);
</code></pre>
",3
370293,370283,4,"<p>I don't know why it would treat a double different from an int.  I thought I had used that form before.  Here's an alternate workaround:</p>

<pre><code>class Now_Better
{
    static double const d;
};
</code></pre>

<p>And in your .cpp file:</p>

<pre><code>double const Now_Better::d = 1.0;
</code></pre>
",1
370311,370283,49,"<p>The problem is that with an integer, the compiler <em>usually</em> doesn't have to ever create a memory address for the constant.  It doesn't exist at runtime, and every use of it gets inlined into the surrounding code.  It can still decide to give it a memory location - if its address is ever taken (or if it's passed by const reference to a function), that it must.  In order to give it an address, it needs to be defined in some translation unit.  And in that case, you need to separate the declaration from the definition, since otherwise it would get defined in multiple translation units.</p>

<p>Using g++ with no optimization (<code>-O0</code>), it automatically inlines constant integer variables but not constant double values.  At higher optimization levels (e.g. <code>-O1</code>), it inlines constant doubles.  Thus, the following code compiles at <code>-O1</code> but NOT at <code>-O0</code>:</p>

<pre><code>// File a.h
class X
{
 public:
  static const double d = 1.0;
};

void foo(void);

// File a.cc
#include &lt;stdio.h&gt;

#include ""a.h""

int main(void)
{
  foo();
  printf(""%g\n"", X::d);

  return 0;
}

// File b.cc
#include &lt;stdio.h&gt;

#include ""a.h""

void foo(void)
{
  printf(""foo: %g\n"", X::d);
}
</code></pre>

<p>Command line:</p>

<pre><code>g++ a.cc b.cc -O0 -o a   # Linker error: ld: undefined symbols: X::d
g++ a.cc b.cc -O1 -o a   # Succeeds
</code></pre>

<p>For maximal portability, you should declare your constants in header files and define them once in some source file.  With no optimization, this will not hurt performance, since you're not optimizing anyways, but with optimizations enabled, this can hurt performance, since the compiler can no longer inline those constants into other source files, unless you enable ""whole program optimization"".</p>
",6
370337,370283,18,"<p>I see no technical reason why </p>

<pre><code>struct type {
    static const double value = 3.14;
};
</code></pre>

<p>is forbidden. Any occasion you find where it works is due to non-portable implementation defined features. They also seem to be of only limited use. For integral constants initialized in class definitions, you can use them and pass them to templates as non-type arguments, and use them as the size of array dimensions. But you can't do so for floating point constants. Allowing floating point template parameters would bring its own set of rules not really worth the trouble.</p>

<p>Nonetheless, the next C++ version will allow that using <code>constexpr</code>:</p>

<pre><code>struct type {
    static constexpr double value = 3.14;
    static constexpr double value_as_function() { return 3.14; }
};
</code></pre>

<p>And will make <code>type::value</code> a constant expression. In the meantime, your best bet is to follow the pattern also used by <code>std::numeric_limits</code>:</p>

<pre><code>struct type {
    static double value() { return 3.14; }
};
</code></pre>

<p>It will not return a constant expression (value is not known at compile time), but that only matters theoretical, since practical the value will be inlined anyway. See the <a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2235.pdf"" rel=""noreferrer"">constexpr</a> proposal. It contains</p>

<blockquote>
  <p>4.4</p>
  
  <p><code>Floating-point constant expressions</code></p>
  
  <p>Traditionally, evaluation of
  ?oating-point constant expression at
  compile-time is a thorny issue. For
  uniformity and generality, we suggest
  to allow constant-expression data of
  ?oating point types, initialized with
  any ?oating-point constant
  expressions. That will also increase
  compatibility with C99 [ISO99, ¡ì6.6]
  which allows</p>
  
  <p>[#5] An expression that evaluates to a
  constant is required in several
  contexts. If a ?oating expression is
  evaluated in the translation envi-
  ronment, the arithmetic precision and
  range shall be at least as great as if
  the expression were being evaluated in
  the execution environ- ment.</p>
</blockquote>
",5
370433,370283,7,"<p>It doesn't really give a rationale, but here's what Stroustrup has to say about this in ""The C++ Programming Language Third Edition"":</p>

<blockquote>
  <p>10.4.6.2 Member Constants</p>
  
  <p>It is also possible to initialize a
  static integral constant member by
  adding a <em>constant-expression</em>
  initializer to its member declaration.
  For example:</p>

<pre><code>class Curious {
    static const int c1 = 7;        // ok, but remember definition
    static int c2 = 11;             // error: not const
    const int c3 = 13;              // error: not static
    static const int c4 = f(17);    // error: in-class initializer not constant
    static const float c5 = 7.0;    // error: in-class not integral
    // ...
};
</code></pre>
  
  <p>However, an initialized member must still be (uniquely) defined
  somewhere, and the initializer may not
  be repeated:</p>

<pre><code>const int Curious::c1;  // necessary, but don't repeat initializer here
</code></pre>
  
  <p>I consider this a misfeature.  When you need a symbolic constant
  within a class declaration, use an
  enumerator (4.8, 14.4.6, 15.3).  For
  example:</p>

<pre><code>class X {
    enum { c1 = 7, c2 = 11, c3 = 13, c4 = 17 };
    // ...
};
</code></pre>
  
  <p>In that way, no member definition is needed elsewhere, and you are not
  tempted to declare variables,
  floating-point numbers, etc.</p>
</blockquote>

<p>And in Appendix C (Technicalities) in Section C.5 (Constant Expressions), Stroustrup has this to say about ""constant expressions"":</p>

<blockquote>
  <p>In places such as array bounds (5.2), case labels (6.3.2), 
  and initializers for enumerators (4.8), C++ requires a 
  <em>constant expression</em>.  A constant expression evaluates to 
  an integral or enumeration constant.  Such an expression 
  is composed of literals (4.3.1, 4.4.1, 4.5.1), 
  enumerators (4.8), and <em>consts</em> initialized by 
  constant expressions.  In a template, an integer template 
  parameter can also be used (C.13.3). Floating literals (4.5.1) 
  can be used only if explicitly converted to an integral 
  type.  Functions, class objects, pointers, and references 
  can be used as operands to the <em>sizeof</em> 
  operator (6.2) only. </p>
  
  <p>Intuitively, constant expressions are simple expressions 
  that can be evaluated by the compiler before the program 
  is linked (9.1) and starts to run.</p>
</blockquote>

<p>Note that he pretty much leaves out floating point as being able to play in 'constant expressions'. I suspect that floating point was left out of these types of constant expressions simply because they are not 'simple' enough.</p>
",7
1929247,1929206,6,"<p><strong>EDIT:</strong> I missed the <code>MyObject</code> part of your question so my original answer will probably not be of much help. I guess your problem lies in the code you did not post, the stripped-down example should work fine.</p>

<hr>

<p>Class <code>B</code> does not ¡°own¡± the object passed by reference, therefore the objects <code>a</code> and <code>b</code> have different life cycles. If the object refered to by <code>B::a_</code> is destroyed, <code>B</code>'s destructor will access an invalid reference.</p>

<p>Some code to explain what I mean:</p>

<pre><code>class A;

class B {
public:
    B(A a) : a_(a) {}  // a is copied to a_
    ~B() { /* Access a_ */ }
private:
    A a_;
};

class C {
public:
    C(A&amp; a) : a_(a) {}  // a_ is a reference (implicit pointer)
                        // of an external object.
    ~C() { /* Access a_ */ }
private:
    A&amp; a_;
};


int main(int argc, char** argv) {
    A* a = new A();

    B b(*a);
    C c(*a);

    delete a;
    // Now b has a valid copy of a, c has an invalid reference.
}
</code></pre>
",4
1929266,1929206,5,"<p>a_ should be constructed before b_, and b_ should be destructed before a_, based on the order you have defined them in MyObject.</p>
",0
1929381,1929206,6,"<p>In the code above the destruction order is well defined.<br>
The destruction order is the reverse of the creation order.<br>
The creation order is the order the members were declared within the class.<br>
So in this case:</p>

<pre><code>Default Construction:
  a_:  constructed first using default constructor.
  b_:  constructed using a valid a_ passed to the constructor.

Destruction:
  b_:   destroyed first. The destructor can use the reference to a 
        As long as the object has not been copied (see below)
  a_:   destroyed second.
</code></pre>

<p>But you have a potential problem if you make a copy of the object using the copy constructor.</p>

<p>The following copy constructor is defined by the compiler:</p>

<pre><code>MyObject::MyObject(MyObject const&amp; copy)
    :a_(copy.a_)
    ,b_(copy.b_)
{}
</code></pre>

<p>So you may have a potential problem here. As the copy will contain an object 'b_' that contains a reference that was copied from another object. If the other object is destroyed then this 'b_' will have an invalid reference.</p>
",0
677331,677325,22,"<p>put at the first line:</p>

<pre><code>class B;
</code></pre>
",0
677332,677325,4,"<p>forward declare one class before other with</p>

<pre><code>class B;
or
class A;
</code></pre>

<p>But still you won't be able to implement </p>

<pre><code>void doSomething(B *b)
</code></pre>

<p>using only forward declaration of B. So you have to put definition of doSomething below full class A declaration</p>
",0
677334,677325,12,"<p>If I remember well, you can 'pre-declare' your class B.</p>

<pre><code>class B; // predeclaration of class B

class A
{
   public:
      void doSomething(B* b);
}

class B
{
    public
      void doSomething(A* a) {}
}

public void A::doSomething(B* b) {}
</code></pre>

<p>Then, your class 'A' knows that a class 'B' will exists, although it hasn't been really defined yet.</p>

<p>Forward declaration is indeed the correct term, as mentionned by Evan Teran in the comments.</p>
",1
677336,677325,3,"<p>Yes.  You need a forward declaration:</p>

<pre><code>class B; // add this line before A's declaration

class A {
    public:
        void doSomething(B *b) {};
};

class B {
    public:
        void doSomething(A *a) {};
};
</code></pre>
",0
677346,677325,1,"<p>You can try a forward declaration like</p>

<pre><code>class B;
class A {
  void Method( B* );
};
class B{
};
</code></pre>

<p>but you will only be able to declare pointer and reference variables for B then. If you want more (like a method that dereferences B* variable) you can provide a declaration only and define methods later in the same file - at the point where both classes declaration is already available.</p>
",0
677348,677325,1,"<p>You need to forward declare B.</p>

<pre><code>class B; 

class A
{
public:        
   void doSomething(B *b) {}
};

class B 
{    
public:        
   void doSomething(A *a) {}
};
</code></pre>

<p>(And BTW, you don't need the semi-colons after the member function curly braces. :) )</p>
",0
677349,677325,3,"<p><a href=""http://www.parashift.com/c++-faq-lite/misc-technical-issues.html#faq-39.11"" rel=""nofollow noreferrer"">The C++ FAQ Lite</a> answers this question and others.  I'd seriously considering reading that thing end to end, or getting the book and doing the same.</p>
",0
677367,677325,0,"<p>Add another declaration of B before A:</p>

<pre><code>class B;

class A {
    public:
        void doSomething(B *b) {};
};

class B {
    public:
        void doSomething(A *a) {};
};
</code></pre>
",0
522939,522931,3,"<p>You could use a <code>std::map&lt;unsigned int, std::vector&lt;unsigned int&gt; &gt;</code>, so that the character of interest is the key to the vector of offsets.  That way, you don't have to code up N different vectors for each possible character in the file.</p>
",8
912881,522931,0,"<p>This question is pretty old but what I was asking was really ""Does C++ have variable variable names?""</p>

<p>PHP has this...</p>

<pre><code>$foo = 'bar';
$bar = 'foobar';
echo $$foo;    //This outputs foobar
</code></pre>

<p>I was looking for something simliar in C++.</p>
",0
1397766,1397737,45,"<p>The following prints the digits in order of ascending significance (i.e. units, then tens, etc.):</p>

<pre><code>do {
    int digit = n % 10;
    putchar('0' + digit);
    n /= 10;
} while (n &gt; 0);
</code></pre>
",6
1397767,1397737,8,"<p>You want to some thing like this?</p>

<pre><code> int n = 0;
    std::cin&gt;&gt;n;

    std::deque&lt;int&gt; digits;
    if(n == 0)
    {
        digits.push_front(0);
        return 0;
    }

    n = abs(n);
    while(n &gt; 0)
    {
        digits.push_front( n % 10);
        n = n /10;
    }
    return 0;
</code></pre>
",2
1397749,1397737,0,"<p>Use a sequence of mod 10 and div 10 operations (whatever the syntax is in C++) to assign the 
digits one at a time to other variables.</p>

<p>In pseudocode</p>

<pre><code>lsd = number mod 10
number = number div 10
next lsd = number mod 10
number = number div 10
</code></pre>

<p>etc...</p>

<p>painful! ... but no strings or character arrays.</p>
",0
1397760,1397737,1,"<p>First digit (least significant) = num % 10, second digit = floor(num/10)%10, 3rd digit = floor(num/100)%10. etc</p>
",2
1397761,1397737,6,"<p>Something like this:</p>

<pre><code>int* GetDigits(int num, int * array, int len) {
  for (int i = 0; i &lt; len &amp;&amp; num != 0; i++) {
    array[i] = num % 10;
    num /= 10;
  }
}
</code></pre>

<p>The mod 10's will get you the digits.  The div 10s will advance the number.</p>
",3
1398173,1397737,15,"<p>Since everybody is chiming in without knowing the question.<br>
Here is my attempt at futility:</p>

<pre><code>#include &lt;iostream&gt;

template&lt;int D&gt; int getDigit(int val)       {return getDigit&lt;D-1&gt;(val/10);}
template&lt;&gt;      int getDigit&lt;1&gt;(int val)    {return val % 10;}

int main()
{
    std::cout &lt;&lt; getDigit&lt;5&gt;(1234567) &lt;&lt; ""\n"";
}
</code></pre>
",5
1398200,1397737,20,"<p>What about <code>floor(log(number))+1</code>?</p>

<p>With <em>n</em> digits and using base <em>b</em> you can express any number up to <code>pow(b,n)-1</code>. So to get the number of digits of a number <em>x</em> in base <em>b</em> you can use the inverse function of exponentiation: base-b logarithm. To deal with non-integer results you can use the <code>floor()+1</code> trick.</p>

<p>PS: This works for integers, not for numbers with decimals (in that case you should know what's the precision of the type you are using).</p>
",5
1398845,1397737,11,"<p>I have seen many answers, but they <strong>all</strong> forgot to use <code>do {...} while()</code> loop, which is actually the canonical way to solve this problem and handle <code>0</code> properly.</p>

<p>My solution is based on <a href=""https://stackoverflow.com/questions/1397737/how-to-get-the-digits-of-a-number-without-converting-it-to-a-string-char-array/1397767#1397767"">this</a> one by <a href=""https://stackoverflow.com/users/39742/naveen"">Naveen</a>.</p>

<pre><code>int n = 0;
std::cin&gt;&gt;n;

std::deque&lt;int&gt; digits;
n = abs(n);
do {
    digits.push_front( n % 10);
    n /= 10;
} while (n&gt;0);
</code></pre>
",0
56101,56091,1,"<p>You can certainly do it, although the CaseMethod call isn't correct (it's a pointer to member function, so you have to specify the object on which the method should be called). The correct call would look like this:</p>

<pre><code>bool res = this-&gt;*CaseMethod( 999, ""hello world"" );
</code></pre>

<p>On the other hand, I'd recommend <a href=""http://www.boost.org/doc/libs/1_36_0/libs/bind/mem_fn.html"" rel=""nofollow noreferrer"">boost::mem_fn</a> - you'll have less chances to screw it up. ;)</p>
",0
56111,56091,8,"<p>What you have there is a pointer-to-member-function. It will solve your problem. I am surprised that your ""TestSwitch"" function compiles, as the calling syntax is slightly different to what you might expect. It should be:</p>

<pre><code>bool res = (this-&gt;*CaseMethod)( 999, ""hello world"" );
</code></pre>

<p>However, you might find a combination of boost::function and boost::bind makes things a little easier, as you can avoid the bizarre calling syntax.</p>

<pre><code>boost::function&lt;bool(int,std::string)&gt; f=
    boost::bind(&amp;MyClass::CaseMethod1,this,_1,_2);
</code></pre>

<p>Of course, this will bind it to the current <code>this</code> pointer: you can make the <code>this</code> pointer of the member function an explicit third parameter if you like:</p>

<pre><code>boost::function&lt;bool(MyClass*,int,std::string)&gt; f=
    boost::bind(&amp;MyClass::CaseMethod1,_1,_2,_3);
</code></pre>

<p>Another alternative might be to use virtual functions and derived classes, but that might require major changes to your code.</p>
",0
56129,56091,0,"<p>There's nothing intrinsically wrong with the localised example you've given here, but class method pointers can often be tricky to keep 'safe' if you use them in a wider context, such as outside the class they're a pointer of, or in conjunction with a complex inheritance tree. The way compilers typically manage method pointers is different to 'normal' pointers (since there's extra information beyond just a code entry point), and consequently there are a lot of restrictions on what you can do with them.</p>

<p>If you're just keeping simple pointers the way you describe then you'll be fine, but fore more complex uses you may want to take a look at a more generalised functor system such as <a href=""http://www.boost.org/doc/libs/1_36_0/libs/bind/bind.html#with_member_pointers"" rel=""nofollow noreferrer"">boost::bind</a>.  These can take pointers to just about any callable code pointer, and can also bind instanced function arguments if necessary.</p>
",0
56160,56091,1,"<p>I don't see the difference between your call and simply calling the method within the switch statement.</p>

<p>No, there is no semantic or readability difference.</p>

<p>The only difference I see is that you are taking a pointer to a method and so forbids to the compiler to inline it or optimizes any call to that method.</p>
",0
57101,56091,1,"<p>Without wider context, it's hard to figure out the right answer, but I sew three possibilities here:</p>

<ul>
<li><p>stay with normal switch statement, no need to do anything. This is the most likely solution</p></li>
<li><p>use pointers to member function in conjunction with an array, as @Simon says, or may be with a map. For a case statement with a large number of cases, this may be faster.</p></li>
<li><p>split t he class into a number of classes, each carrying one function to call, and use virtual functions. This is probably the best solution, buy it will require some serious refatoring. Consider GoF patterns such as State or Visitor or some such.</p></li>
</ul>
",0
57045,56091,3,"<p>You could also build a lookup (if your key range is reasonable) so that you end up writing:</p>

<pre><code>this-&gt;*Methods[num]( 999, ""hello world"" );
</code></pre>

<p>This removes the switch as well, and makes the cleanup a bit more worthwhile.</p>
",0
58798,56091,0,"<p>There are other approaches available, such as using an abstract base class, or specialized template functions.</p>

<p>I'll describe the base class idea.</p>

<p>You can define an abstract base class</p>

<pre><code>class Base { virtual bool Method(int i, const string&amp; s) = 0; };
</code></pre>

<p>Then write each of your cases as a subclass, such as</p>

<pre><code>class Case1 : public Base { virtual bool Method(..) { /* implement */; } };
</code></pre>

<p>At some point, you will get your ""num"" variable that indicates which test to execute.  You could write a factory function that takes this num (I'll call it which_case), and returns a pointer to Base, and then call Method from that pointer.</p>

<pre><code>Base* CreateBase(int which_num) { /* metacode: return new Case[which_num]; */ }
// ... later, when you want to actually call your method ...
Base* base = CreateBase(23);
base-&gt;Method(999, ""hello world!"");
delete base;  // Or use a scoped pointer.
</code></pre>

<p>By the way, this application makes me wish C++ supported static virtual functions, or something like ""type"" as a builtin type - but it doesn't.</p>
",0
190753,190748,2,"<p>It might be because the contents of the while clause are evaluated each loop, thus it would try and declare ""ch"" multiple times.</p>

<p>The if, switch, and for loop examples you gave will all have ""ch"" being defined only once.</p>
",0
190768,190748,11,"<p>This doesn't appear to be compliant behaviour. Part 6.5.1.2 of the standard states: </p>

<blockquote>
  <p>When the condition of a while statement is a declaration, the scope of the variable that is declared extends
  from its point of declaration (3.3.1) to the end of the while statement. A while statement of the form</p>
  
  <p>while (T t = x) statement</p>
  
  <p>is equivalent to</p>
</blockquote>

<pre><code>label:
{ //start of condition scope
    T t = x;
    if (t) {
        statement
        goto label;
    }
}
</code></pre>

<p>So in your example, ch should be declared within the scope of the loop and work correctly (with it being recreated through each loop iteration). Reason for the observed behaviour is most likely due to the compiler not scoping the variable correctly and then declaring it multiple times.</p>
",1
191550,190748,2,"<p>You <em>can</em> put a variable declaration in the test expression  of a while loop. What you <em>cannot</em> do is put a declaration statement in other expressions. For instance, in the expression a+b+c, you cannot replace b by <code>int i = f()</code>. And the same hold for the expression <code>(a)</code>; you can't insert <code>int i=f()</code> to get an expression <code>(int i=f())</code>.</p>

<p>So, in <code>while (int i = foo())</code>, the outermost brackets are part of the while statement, and not of the text-expression, and everything is legal. In <code>while ((int i = foo()))</code>, the outermost brackets are still part of the while statement. The test-expression would have the form <code>""("" expr "")""</code>, and you end up with a syntax error.</p>
",3
191876,190748,14,"<p>The grammar for a condition in the '03 standard is defined as follows:</p>

<pre><code>condition:
  expression
  type-specifier-seq declarator = assignment-expression
</code></pre>

<p>The above will therefore only allow conditions such as:</p>

<pre><code>if ( i &amp;&amp; j &amp;&amp; k ) {}
if ( (i = j) ==0 ) {}
if ( int i = j ) {}
</code></pre>

<p>The standard allows the condition to declare a variable, however, they have done so by adding a new grammar rule called 'condition' that can be an expression or a declarator with an initializer.  The result is that just because you are in the condition of an <code>if</code>, <code>for</code>, <code>while</code>, or <code>switch</code> does not mean that you can declare a variable inside an expression.</p>
",1
191737,190748,0,"<p><strike>Try</strike> <strong>This doesn't work</strong></p>

<pre><code>while (int ch = stream.get(), ch != -1) ...
</code></pre>

<p><strike>I've never tried it, but if the comment in your edit is correct, this should work.</strike><br>
VS 2005 won't even compile it.</p>
",3
193051,190748,14,"<p>The problem is, the standard permits you a <em>declaration</em> inside parenthesis. What you want to do is to get a declaration as part of expression, which is something that standard will not let you do.</p>

<p>while() can have one of two syntaxes: while(&lt;declaration&gt;) or while(&lt;expression&gt;). The declaration uses ""="", and looks like expression, but it's a different syntactical entity. </p>

<p>When you write</p>

<pre><code>while(int i = 1) {
}
</code></pre>

<p>, that's perfectly fine. ""int i=1"" is a declaration. However, what you want is </p>

<pre><code>while ( (int i = 1) + 3) {
}
</code></pre>

<p>This is a very different animal. You want an expression inside while(), where one of the terms of the expression is a declaration. Now, declaration is a statement, and as such cannot be part of expression. That's why what you need to be done cannot be done.</p>

<p>(after writing the whole rant, I noticed that 2 other people wrote the same thing. Oh well, the more the merrier.)</p>
",0
530557,530519,4,"<p>mktime assumes that the date value is in the local time zone. Thus you can change the timezone environment variable beforehand (setenv) and get the UTC timezone.</p>
<p><a href=""https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/tzset?view=msvc-160"" rel=""nofollow noreferrer"">Windows tzset</a></p>
<p>Can also try looking at various home-made <a href=""http://www.koders.com/c/fidB1A0A680FBCF84DDC534E66371053D726A5546EB.aspx?s=md5"" rel=""nofollow noreferrer"">utc-mktimes, mktime-utcs, etc.</a></p>
",2
530582,530519,1,"<p>The tm structure used by mktime has a timezone field.<br>
What happens if you put 'UTC' into the timzone field?  </p>

<p><a href=""http://www.delorie.com/gnu/docs/glibc/libc_435.html"" rel=""nofollow noreferrer"">http://www.delorie.com/gnu/docs/glibc/libc_435.html</a></p>
",3
48501,48496,6,"<p>If they are coming from a Java world, they are used to garbage collection. As such, I'd probably spend a bit of time talking about smart (reference counted) pointers, and how they compare to garbage collection.</p>
",0
48508,48496,22,"<p>I can only once again point to <a href=""http://www.research.att.com/~bs/new_learning.pdf"" rel=""nofollow noreferrer"">Stroustrup</a> and preach: Don't teach the C subset! It's important, but not for beginners! C++ is complex enough as it is and the standard library classes, especially the STL, is much more important and (at least superficially) easier to understand than the C subset of C++.</p>

<p>Same goes for pointers and heap memory allocation, incidentally. Of course they're important but only after having taught the STL containers.</p>

<p>Another important concept that new students have to get their head around is the concept of different compilation units, the One Definition Rule (because if you don't know it you won't be able to decypher error messages) and headers. This is actually quite a barrier and one that has to be breached early on.</p>

<p>Apart from the language features the most important thing to be taught is how to understand the C++ compiler and how to get help. Getting help (i.e. knowing how to search for the right information) in my experience is the single most important thing that has to be taught about C++.</p>

<p>I've had quite good experiences with this order of teaching in the past.</p>

<p>/EDIT: If you happen to know any German, take a look at <a href=""http://madrat.net/coding/cpp/skript"" rel=""nofollow noreferrer"">http://madrat.net/coding/cpp/skript</a>, part of a <em>very</em> short introduction used in one of my courses.</p>
",5
48509,48496,3,"<p>Memory management (pointers, allocation etc), basics of STL and templates (since STL uses templates). I think STL is important since one would be missing the richness of the Java SE class library in C++.</p>
",0
48634,48496,4,"<p>If you are going to put a lot of Java programmers <em>straight out of college</em> to write production code, I'd say the first thing you should be concerning is pointers and memory management.</p>

<p>Really, those who come directly from managed code rarely have the skills to debug pointer-related exception, let alone use it correctly, or even understands how their language/tools utilize it.</p>

<blockquote>
  <p>Pointers is how you <strong>think</strong> not just write code.</p>
</blockquote>

<p>The framework and coding practices can be taught as tips and notes along the way.</p>

<p>But failing to understand pointers when writing C code is just waiting to shoot yourself in the foot, if not the head.</p>
",0
48646,48496,3,"<p>I would spend a whole day discussing how to write a good class in C++. <a href=""https://rads.stackoverflow.com/amzn/click/com/0136152503"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">Deitel &amp; Deitel</a> may help as a reference.</p>

<ul>
<li>When are constructors called?</li>
<li>When are assignment operators called?</li>
<li>When are destructors called?</li>
<li>What's the point for const Foo &amp; a_foo?</li>
</ul>
",1
48673,48496,4,"<p>I would like to add that you should make sure to point out where they can find language and API references.  In java, the API and language specification is at your fingertips online at java.sun.com... with C or C++, it's not quite as simple and easy to find reference documentation.</p>

<p>Whenever I am doing something in C or C++, that is my biggest problem... trying to find what I need.  I usually turn to <a href=""http://www.cplusplus.com/"" rel=""nofollow noreferrer"">cplusplus.com</a>, which usually has what I need, otherwise I google for it.  If you have a set of references you use (online or in the form of books), list them and tell them what you use each reference for.</p>
",0
878664,878636,2,"<p>MS Visual C++ 6.0 and g++ 4.4.0 produce numerous errors - as they should. I find it hard to believe 
that a C++ compiler would accept this - are you sure you really compiled this code?</p>
",0
878679,878636,1,"<p>default is a <a href=""http://www.cppreference.com/wiki/keywords/start"" rel=""nofollow noreferrer"">reserved word</a>, gcc 4.3.2 won't compile that code, not sure what the MS compiler is playing at there!</p>
",0
878680,878636,0,"<p>No, default is a reserved c++ keyword, that's why its failing to compile.</p>
",1
544080,124322,3,"<p><a href=""http://code.google.com/p/gosu/"" rel=""nofollow noreferrer"">Gosu</a> is a compact, thoughtful library for C++ (with Ruby bindings as well). I'm using Gosu right now for a project, and it lives up to its promise: it is indeed minimal, but it doesn't get in your way.</p>

<p>Alternatively, there is <a href=""http://www.libsdl.org/"" rel=""nofollow noreferrer"">SDL. SDL is ultimately a fairly low-level API for doing 2D graphics with OpenGL.</p>

<p>I used to use <a href=""http://clanlib.org/"" rel=""nofollow noreferrer"">ClanLib</a> all the time. It was very feature-rich. However, its development seemed extraordinarily slow, and I eventually moved on. It's certainly worth looking at, though.</p>

<p>For basic physics in 2D, you may find <a href=""http://www.box2d.org/"" rel=""nofollow noreferrer"">Box2D</a> useful. Its documentation is unfortunately somewhat poor and confusing, but overall it's a good library. Using a 3D physics engine if you're just going to do 2D work is definitely over-kill and will make your job much harder than it needs to be.</p>

<p>Using one of these libraries is not strictly necessary, although I would strongly recommend. It's entirely possible to build a game using OpenGL or Direct3D directly. This route is preferable if you have plans on implementing rather advanced graphical techniques.</p>

<p>As Ben said, <a href=""http://www.gamedev.net"" rel=""nofollow noreferrer"">gamedev.net</a> is a phenomenal place for questions about game development. I've been viewing the forums there for years now.</p>

<p>Finally, I have an incomplete listing of free game development technologies here</a>, including libraries for languages other than C++.</p>
",0
124420,124322,2,"<p>You definitely want to look at shaders.  Shaders allow you to use world data or previous frame data to decorate the current scene.  Doing so it's relatively easy to create motion blur and other effects using shaders.</p>

<p>I'd recommend reading up on <a href=""http://gamedev.net"" rel=""nofollow noreferrer"">http://gamedev.net</a> and maybe checking out some of the books called Game Programming Gems.</p>
",0
124427,124322,5,"<p>I use mainly these two libraries for 3d gaming:</p>

<p><a href=""http://www.libsdl.org/index.php"" rel=""noreferrer"">SDL</a> </p>

<blockquote>
  <p>Simple DirectMedia Layer is a cross-platform multimedia library designed to provide low level access to audio, keyboard, mouse, joystick, 3D hardware via OpenGL, and 2D video framebuffer.</p>
</blockquote>

<p><a href=""http://www.ode.org/"" rel=""noreferrer"">ODE</a></p>

<blockquote>
  <p>ODE is an open source, high performance library for simulating rigid body dynamics. It is fully featured, stable, mature and platform independent with an easy to use C/C++ API. It has advanced joint types and integrated collision detection with friction. ODE is useful for simulating vehicles, objects in virtual reality environments and virtual creatures.</p>
</blockquote>
",0
124603,124322,3,"<p><a href=""http://www.devmaster.net/engines/"" rel=""nofollow noreferrer"">DevMaster</a> is a nice place to start with.</p>

<p>Check <a href=""http://irrlicht.sourceforge.net/"" rel=""nofollow noreferrer"">Irrlicht</a> - one of the best, free engines. It is very easy to start and get going.</p>
",0
249668,215233,1,"<p>@Doug: no, this is not related, afaik, because the code you linked to tries to fetch the document from the parse() method, but this is a <a href=""http://xerces.apache.org/xerces-c/apiDocs-2/classAbstractDOMParser.html#c0b30b3d2116c488920646f0d700d9f0"" rel=""nofollow noreferrer"">void function</a>, so the result will always be ""null"" this way.</p>

<p>Otherwise, I don't see any problem with the parent post. It compiles almost ok and here I have a correct result (non-null parser).</p>
",0
257006,215233,0,"<p>It was a bug some where else in my code.</p>
",0
1418247,1418036,4,"<p>No they will not be included in the next standard update to C++ (C++0x).  The idea of implicit function calls (informally: use of a niladic function name in an expression evaluates to a function call instead of decaying to its address) is interesting, and it wasn't dismissed by the committee as a bad idea.  It was classified as: ""Not ready for C++0x, but open to resubmit in future."" (<a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2869.html"" rel=""nofollow noreferrer"">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2869.html</a>).</p>
",2
890319,890292,4,"<p>By reading Stroustroup's C++ Programming Language.
Switched from Common Lisp.</p>
",0
890321,890292,1,"<p>I have an idea: try looking up all those ""Java for C++ Programmers"" articles, because there are so many of them.  They're written for those who took the historical path (like I did), but it seems like there ought to be an awful lot of useful information, examples, etc., of what the parallels are and how they're different.</p>

<p>That, and spend a lot of time developing in C++ :-)</p>
",0
890334,890292,0,"<p>Since you already have some C programming skills, I would suggest <a href=""https://rads.stackoverflow.com/amzn/click/com/0131774298"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">Expert C Programming: Deep C Secrets</a> by Peter van der Linden.  It has a great section on C++ to get you from C to C++.  That should get you running with C++ syntax.  Of course you can go straight to the Stroustrup if you feel more hungry...</p>

<p>Get a good C/C++ compiler and get working...  </p>
",0
890339,890292,1,"<p>Pretty much like you do any other language.  Pick a project to work on and write it in C++.  Immerse yourself in the language by reading C++ code to pick up on proper idioms.  Reading good books like Effective C++, etc... will help you write correct C++.  C++ is a really nice language that gets beat up a lot by the C# and Java programmers, so try and go into it with a positive mindset.</p>
",0
890342,890292,0,"<p>I would probably start by concentrating on the commonalities among those language that you already know somewhat, i.e. namely the C syntax, classes and encapsulation from Java/C#, and from there on it's mostly a matter of the different types in C, and well <strong><em>pointers</em></strong> of course, as well as manual memory management.</p>

<p>A pretty good multimedia introduction (flash video with animations) to the C-family of programming languages is provided by Bruce Eckel's <a href=""http://mindview.net/CDs/ThinkingInC/beta3"" rel=""nofollow noreferrer"">Thinking in C</a>.</p>

<p>Once you got these basics sorted, I would recommend to concentrate on getting to grips with the STL and eventually boost.</p>

<p>Also, one thing that might be worth a try in order to get started actually <strong>using</strong> your new knowledge, might be to start splitting your future projects into distinct modules, where certain components/parts could possibly be implemented in C++. </p>

<p>This encourages modular design and will provide for a way to actually learn new things and apply your knowledge step by step. This could be done for example by planning to implement one tiny part of a new project as a DLL or in managed C++ code.</p>

<p>And in cases where you find that you cannot directly use/embed C++ components, you could still try to follow a C++ oriented approach, deliberately sacrificing some of those Java/C# facilities that you know are not available in C++. </p>

<p>In other words, there's usually a common denominator between platforms and languages, in network programming it's for example BSD style sockets, on Windows there's often the possibility to make use of the Win32 API.</p>
",0
890345,890292,0,"<p>Try <a href=""https://stackoverflow.com/questions/789659/what-is-the-best-approach-for-a-java-developer-to-learn-c"">this question</a>.</p>
",3
587992,584824,4,"<p>I wrote almost exactly the same class:</p>

<pre><code>template &lt;class C&gt;
class _StringBuffer
{
    typename std::basic_string&lt;C&gt; &amp;m_str;
    typename std::vector&lt;C&gt; m_buffer;

public:
    _StringBuffer(std::basic_string&lt;C&gt; &amp;str, size_t nSize)
        : m_str(str), m_buffer(nSize + 1) { get()[nSize] = (C)0; }

    ~_StringBuffer()
        { commit(); }

    C *get()
        { return &amp;(m_buffer[0]); }

    operator C *()
        { return get(); }

    void commit()
    {
        if (m_buffer.size() != 0)
        {
            size_t l = std::char_traits&lt;C&gt;::length(get());
            m_str.assign(get(), l);    
            m_buffer.resize(0);
        }
    }

    void abort()
        { m_buffer.resize(0); }
};

template &lt;class C&gt;
inline _StringBuffer&lt;C&gt; StringBuffer(typename std::basic_string&lt;C&gt; &amp;str, size_t nSize)
    { return _StringBuffer&lt;C&gt;(str, nSize); }
</code></pre>

<p>Prior to the standard each compiler did it differently. I believe the old Annotated Reference Manual for C++ specified that temporaries should clean up at the end of the scope, so some compilers did that. As late as 2003, I found that behaviour still existed by default on Sun's Forte C++ compiler, so StringBuffer didn't work. But I'd be astonished if any current compiler was still that broken.</p>
",2
584835,584824,114,"<p>The destructor for that sort of temporaries is called at the end of the full-expression. That's the most outer expression which is not part of any other expression. That is in your case after the function returns and the value is evaluated. So, it will work all nice. </p>

<p>It's in fact what makes expression templates work: They can keep hold references to that sort of temporaries in an expression like</p>

<pre><code>e = a + b * c / d
</code></pre>

<p>Because every temporary will last until the expression </p>

<pre><code>x = y
</code></pre>

<p>Is evaluated completely. It's quite concisely described in <code>12.2 Temporary objects</code> in the Standard.</p>
",5
584837,584824,4,"<p>After the call to GetString returns.</p>
",0
584843,584824,3,"<p>StringBuffer is in the scope of GetString.  It should get destroyed at the end of GetString's scope (ie when it returns).  Also, I don't believe that C++ will guarantees that a variable will exist as long as there is reference.</p>

<p>The following ought to compile:</p>

<pre><code>Object* obj = new Object;
Object&amp; ref = &amp;(*obj);
delete obj;
</code></pre>
",7
584974,584824,19,"<p>litb's answer is accurate. The lifetime of the temporary object (also known as an rvalue) is tied to the expression and the destructor for the temporary object is called at the end of the full expression and when the destructor on StringBuffer is called, the destructor on m_buffer will also be called, but not the destructor on m_str since it is a reference.</p>

<p>Note that C++0x changes things just a little bit because it adds rvalue references and move semantics.  Essentially by using an rvalue reference parameter (notated with &amp;&amp;) I can 'move' the rvalue into the function (instead of copying it) and the lifetime of the rvalue can be bound to the object it moves into, not the expression. There is a really good <a href=""http://blogs.msdn.com/vcblog/archive/2009/02/03/rvalue-references-c-0x-features-in-vc10-part-2.aspx"" rel=""noreferrer"">blog post from the MSVC team on that walks through this in great detail</a> and I encourage folks to read it.</p>

<p>The pedagogical example for moving rvalue's is temporary strings and I'll show assignment in a constructor.  If I have a class MyType that contains a string member variable, it can be initialized with an rvalue in the constructor like so:</p>

<pre><code>class MyType{
   const std::string m_name;
public:
   MyType(const std::string&amp;&amp; name):m_name(name){};
}
</code></pre>

<p>This is nice because when I declare an instance of this class with a temporary object:</p>

<pre><code>void foo(){
    MyType instance(""hello"");
}
</code></pre>

<p>what happens is that we avoid copying and destroying the temporary object and ""hello"" is placed directly inside the owning class instance's member variable.  If the object is heavier weight than a 'string' then the extra copy and destructor call can be significant.</p>
",1
452612,452390,1,"<p>I think that what you want is not easily doable with a class hierarchy. </p>

<p>One possible solution is to use a library that handle signal/slots (I've use sigslot <a href=""http://sigslot.sourceforge.net/"" rel=""nofollow noreferrer"">http://sigslot.sourceforge.net/</a>). </p>

<p>In the base class you declare a signal.</p>

<pre><code>class Base : has_slots&lt;&gt; {
  public:
    Base() { SignalUpdate.connect(this, &amp;Base::OnUpdate); }
    void Update() { SignalUpdate.emit(); }
    void OnUpdate() { cout &lt;&lt; ""Base::OnUpdate"" &lt;&lt; endl; }
  private:
    signal0&lt;&gt; SignalUpdate;
};
</code></pre>

<p>Now on each ""derived"" class you connect such signal with you own method</p>

<pre><code>class Derived : public Base {
  public:
    Derived() { SignalUpdate.connect(this, &amp;Derived::OnDerivedUpdate); }
    void OnDerivedUpdate() { cout &lt;&lt; ""Derived::OnDerivedUpdate"" &lt;&lt; endl; }
};
</code></pre>

<p>(Note that this class no longer need to be a derivated from Base).</p>

<p>Now each time Update is called all methods that are connected will be called.</p>

<p>There are other framework that implement a similar behavior: boost signals, qt slots, libsigc++. You should try to take a look at these an see if they fit your needs.</p>
",0
452400,452390,3,"<p>Sounds like you want composition instead of inheritance.  What if there was an interface IUpdateable, and Foo held a collection of IUpdateable objects, and called an Update method on each one every tick?  Then Bar and Baz could just implement Update; your only worry would be how best to register them with Foo.</p>

<p>Based on your further info: You might want to consider your main object being analagous to your PhysicsObject, and using composition to include objects that implement specific behaviors, such as those of the Camera object.</p>
",2
452417,452390,2,"<p>That's a great question, I've encountered it many many times. </p>

<p>Unfortunately, there are at present no language mechanisms that I am familiar with for mainstream languages like C++ to do that, though I expect (at least in the future) for Java to have something with annotations.</p>

<p>I've used a variety of techniques including what you've suggested, each with pros and cons. Convulted approaches are not always worth the cost. </p>

<p>My view today is that if you really need to use inheritance (rather than composition), as it sounds here, then it is better to go for the elegant solution and observe the written contract. I admit, it's dangerous, but there are risks to the other approaches as well. </p>

<p>Generally speaking people are more careful reading the documentation of an overridden method than they are of a method they are using. In other words, while you would want to avoid ""surprising"" the user of your class, and can't count on him reading docs, you can count a little more on that in the case of inheritance, especially if you are the only user.</p>

<p>If you are presenting an API function and you expect many other individuals to override your subclass, you could put all kinds of sanity checks to ensure that the method was called, but in the end, you have to rely on the contract, just as so many standard library classes do.</p>
",1
842182,719364,1,"<p>In this blog post, they mention that they use Delphi:</p>

<p><a href=""http://www.safer-networking.org/en/news/2005-06-22.html"" rel=""nofollow noreferrer"">http://www.safer-networking.org/en/news/2005-06-22.html</a></p>
",0
719455,719364,0,"<p>It looks like an MFC application to me.</p>

<p><a href=""http://www.safer-networking.org/de/tutorial/index.html"" rel=""nofollow noreferrer"">http://www.safer-networking.org/de/tutorial/index.html</a></p>
",0
719470,719364,0,"<p>Most of the GUI framworks that use native operating system widgets will allow you to produce something similar. </p>

<p>Here are 2 GUI Frameworks that uses the native widgets of the OS.</p>

<ul>
<li>MFC</li>
<li>wxWidgets</li>
</ul>
",0
719499,719364,3,"<p>AFAICR it's written in Delphi. With C++ Builder you can use Delphi libraries from C++.</p>
",0
583145,583122,1,"<p>I never found anything definite on this, although you could look in the <code>winsxs</code> folder in the users <code>windir</code> for the right folders and files.</p>

<p>I've got our app's installer running it quietly when they install, which won't cause any problems if it is already there.</p>
",0
583190,583122,0,"<blockquote>
  <p>so my app is placing the
  vcredist_x86.exe on their machines and
  running it.</p>
</blockquote>

<p>This is a highly irregular way of doing this.<br>
Usually the side by side packages are automatically added to the dependencies of an installer object under the ""detected dependencies""</p>
",2
583398,583122,0,"<p>Keeping it simple: just run the redist setup as part of a batch file that writes some registry value when it's done (so you could check and not run it twice) or write some file to a known location.</p>

<p>true, this way if your uses ran vcredist on their own sometime in the past your first installation would be superfluous, but I guess it can't really hurt and isn't that big of a deal.</p>

<p>Other than that (I realize it ain't pretty) I suspect you'll have to check that every single file that comes in the 2005 redist package is there (wasn't deleted by any chance or damaged), which is pretty much what the redist setup ought to do anyway.</p>
",0
1480106,1480090,0,"<p>It isn't a problem as long as your class derives from their class.  As far as c++ is concerned a pointer is a pointer.  It doesn't matter if what it points to is heap or stack allocated.  If however they aren't in the same inheritance hierarchy then it won't work.</p>
",2
1480111,1480090,1,"<p>Yes, it looks like you are constructing a temporary <code>b2PolygonShape</code>, taking the address of that and storing it in the <code>fd.shape</code> member, so that is a problem - it would indeed become invalid.</p>

<p>Given <code>fd.shape</code> is a pointer, it would presumably point to something allocated on the heap anyway (without your wrapper).  So what would the ordinary lifecycle of the <code>Fixture</code> and <code>Polygon</code> objects be?</p>

<p>It appears you are wrapping your own polygon object <code>m_polygon</code> and returning that.  So can't you just create your own <code>b2PolygonShape</code> in the containing object (as a member alongside m_polygon) and return a pointer to that?  Then the lifecycle would be the same as the original polygon and the object it came from.  This way, even if you allocated the <code>b2PolygonShape</code> on the heap, you can clean it up in the destructor of your wrapper class.</p>
",3
1480277,1480090,1,"<p>In your case it seems that heap allocation is the only way to go. You'll have to think about who has ownership of the object and make it responsible for deleting the object later.</p>
",3
1480340,1480090,1,"<p>A conversion operator always has to make a copy of everything, so that the result is valid even if the original object is freed. Which means that you need to make a copy of <code>m_polygon</code> as b2PolygonShape and assign a pointer to it to b2FixtureDef::shape. </p>

<p>You can make a copy by implementing a copy constructor in b2PolygonShape or a conversion operator in whatever type <code>m_polygon</code> is. [...]</p>

<p>b2FixtureDef::shape looks like a has-a relation, so the destructor of b2FixtureDef should free it anyway, doesn't it?</p>

<hr>

<p>Hmm, you say b2FixtureDef::shape is not freed automatically, what if you create a proxy class that has a b2FixtureDef as member and a conversion operator b2FixtureDef?</p>

<p>When you create the proxy object you create b2PolygonShape on the heap and fill the b2FixtureDef members just like in your code. In the conversion operator you simply return the b2FixtureDef member and in the proxy destructor you free the b2PolygonShape:</p>

<pre><code>class FixtureProxy
{
  b2FixtureDef m_Fixture;
  FixtureProxy(Fixture aFixture) {m_Fixture.Shape = new b2PolygonShape(aFixture.m_polygon);...}
  ~FixtureProxy() {delete m_Fixture.Shape}
  operator b2FixtureDef() const {return m_Fixture}
}
</code></pre>

<p>you then use it like this</p>

<pre><code>void Body::addFixture(const Fixture&amp; fixture) {
    m_fixtures.append(fixture);
    m_body-&gt;CreateFixture(&amp;b2FixtureDef(FixtureProxy(fixture)));
}
</code></pre>
",6
1777751,1777730,0,"<p>I learned C++ in college and found the <a href=""https://rads.stackoverflow.com/amzn/click/com/0136152503"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">Dietel book</a> extremely thorough.</p>

<p>Being proficient in C# helps but C++ is closer to C.</p>
",0
1777761,1777730,2,"<blockquote>
  <p>Also, would you agree that to be good
  at C++, a lot of experience and being
  proficient in C# will help? As C++ is
  harder...  </p>
</blockquote>

<p>Yes I agree with that. A lot of experience in development in any language helps in my opinion. With experience comes appreciation of best practices. Those practices may be different, but you will not dismiss them outright because you know (from your experience) that they are usually good for you.<br>
Good book... Get ""C++ primer"" with ""Effective (and more effective) C++"" and you will be all set. Then if you need STL get yourself Josuttis and ""Effective STL"". Good luck</p>
",0
1777763,1777730,1,"<p>Since you already know c# you already know more syntax than there is in c++.  There are very few c++ syntax elements that you'll need that are not also available in C#.</p>

<p>Here are the main areas where I think you see some challenges:</p>

<p>a) Many, many constructs in c# are simply not available in c++.  I'm talking about language features not data types.  i.e.  Generic Collections, etc... while similar results can be obtained with c++ language features it is soooo much more work in c++ </p>

<p>b) It's really the libraries/framework you choose that are going to be substantially different.</p>

<p>c) Why not mix the two. They both play well together.  Do your image processing work in a c++ library but keep the work there to a minimum and wrap the whole thing in c# for consumption in a UI.   Of course the interoperability will be another challenge but it is well documented on the web.</p>

<p>As far as good book goes...  there is still none better than Steve McConnell's  ""Code Complete""</p>

<p><a href=""http://cc2e.com/"" rel=""nofollow noreferrer"">http://cc2e.com/</a></p>

<p>Good Luck.</p>
",0
1777770,1777730,0,"<p>I don't have any links on the subject, but I can offer some general advice.</p>

<ol>
<li>Remember that you no longer have memory management. You <em>have</em> to delete your pointers after you're done with them.</li>
<li>In C++, there is no physical difference between a struct and a class. Both live on the heap or on the stack based on how you use them. In C#, a struct is a ValueType and lives on the stack, while a class is a ReferenceType and lives in the heap. In C++, a struct has public member visibility by default, while a class has private member visibility by default; that's it. In C++ a type (class or struct) lives on the stack by default, and only lives on the heap if you declare it as a pointer (and new it up). </li>
<li>Learn the Standard Template Library (STL). It's easily the best thing C++ has going for it. </li>
<li>Learn to hate the Microsoft Foundation CLass library (MFC), but learn to use it. If you're doing windows development in C++, you pretty much have to do it.</li>
</ol>
",3
1777865,1777730,0,"<blockquote>
  <p>Also, would you agree that to be good at C++, a lot of experience and being proficient in C# will help? As C++ is harder.</p>
</blockquote>

<p>Yeah I agree with you on the fact that C++ is harder. In fact it is considered to be one of the most complicated programming languages. Its syntax(at some places) is a bit ugly as compared to C# and Java but yeah it is one of the most widely used language in the industry, so best of luck with it.</p>

<p>As far as good books are concerned I'll go with</p>

<p>1) C++ Primer by Stan Lippman (strongly recommended)<br>
2) Thinking in C++ by Bruce Eckel</p>

<p>and style books like Effective and More Effective C++ by Scott Mayers.</p>

<p>Apart from that the 'Bible' for C++ is ""The C++ Programming Language by Stroustrup"".</p>

<p>Enjoy!</p>
",0
1777895,1777730,0,"<p>I've actually done the conversion the other way around. I wouldn't say C++ is hard. Only as hard as you can make it. There are certain standard to follow with such things as memory allocation, pointers, type casting and etc. But it's nothing you cannot iron out as you get deeper into it. </p>

<p>Actually, (and some may see this as an overkill) if i were you i would try to get a decent assembler book and read the first few chapters on registers, memory addresses, stack, heap and etc. I think it'll paint a better picture for you when you start messing with memory management, which is probably the hardest thing to grasp in C/C++.</p>
",0
234393,234388,6,"<p>Use 'T' instead of 10.</p>
",0
234394,234388,5,"<p>Have you tried replacing J with 11, Q with 12 and K with 13? Then you could use <code>int</code>egers rather than <code>char</code>acters. Replace 11-13 with the appropriate letter later on.</p>
",1
234407,234388,12,"<p>Try to create class of Card with suit and card as a member and set it as a type of vector. Like</p>

<pre><code>public class Card {
 public:
  Card(char suit, char card);
  char suit, card;
};

int main() {
    vector&lt;Card&gt; deck;
    char suit[] = {'h','d','c','s'};
    char card[] = {'2','3','4','5','6','7','8','9','T','J','Q','K','A'};
    for (int j=0; j&lt;13; j++) {
        for (int i=0; i&lt;4; i++) {
                deck.push_back(new Card(card[j],suit[i]));
        }               
    }
    return 0;
}
</code></pre>

<p>also using enums instead of chars in suit and card would make it clearer.</p>
",5
234414,234388,2,"<p>As mentioned by others, you can use 'T' for ten, J, Q, and K for the figures.
As far as push_back.. since deck is a vector of chars, you can pass only one char to push_back as argument. Passing both the card value (1...9, T, J, Q, K) and its suite doesn't work.</p>

<p>I personally would create a little struct, to represent a Card, with a Value and a Suite property. Then, you can make your deck a vector of Cards .</p>

<p>Edited: fixing last word since vector (less-than) Card (greater-than) was rendered as vector (nothing).</p>
",0
234416,234388,3,"<p>Well, first of all, deck[0] is one char, yet you are trying, to stuff ""2h"" into it. (for the moment, we'll ignore that how you are doing that is wrong.)</p>

<p>Basically, you'll need to make deck a <code>vector&lt;std::string&gt;</code>.  Make card an array of const char*s, and convert the elements to string.</p>

<p>then use:  </p>

<pre><code>deck.push_back(std::string(card[j]) + suit[i]);
</code></pre>
",1
234422,234388,31,"<p>I think what you are looking to use is an enumeration. It will make your code clearer and resolve your problem.</p>

<pre><code>enum SUIT { HEART, CLUB, DIAMOND, SPADE }; 
enum VALUE { ONE, TWO, THREE, ..., TEN, JACK, QUEEN, KING};
</code></pre>
",0
234437,234388,1,"<p>Since this is a blackjack program, you will be adding and comparing the value of the cards.</p>

<p>That being the case, you can save yourself some additional programming and pain by giving the cards <em>int</em> values (1-13) instead of <em>char</em> values.</p>
",2
234456,234388,0,"<p>I would go with Ross's suggestion to use integers. Most card games will involve some bits of math so that's a better representation.</p>

<p>Convert to 'A' or 'ACE' etc. on output.</p>
",0
234517,234388,9,"<p>The way you model it really depends on what you're trying to do.</p>

<p>Are you creating an actual game, and the data structures just need to support the gameplay?</p>

<p>If so, I'd create a card class, with an enum field for the suit and a numeric type (with values 1 - 13) for the face value.</p>

<p>On the other hand, if you're building an analysis application or an AI player, then the model might be a little bit different.</p>

<p>A few years ago, I wrote a simulator to calculate probabilities in various Texas Holdem scenarios, and I wanted it to crunch numbers REALLY quickly. I started out with a very straightforward model (card class, suit enum, etc) but after a lot of profiling and optimization, I ended up with a bitwise representation.</p>

<p>Each card was a sixteen-bit value, with the thirteen high-order bits representing the face value, the two low order bits representing the suit, and with bit[2] as a special flag indicating an ace (used only in cases where the ace might appear in an A2345 straight).</p>

<p>Here are a few examples:</p>

<pre><code>0000000000001001  &lt;----  Two of hearts
0100000000000011  &lt;----  King of spades
1000000000000110  &lt;----  Ace of diamonds

^^^^^^^^^^^^^            (""face-value"" bits)
             ^           (""low-ace"" flag)
              ^^         (""suit"" bits)
</code></pre>

<p>You can imagine how, with a design like this, it's lighting fast to look for pairs, threes-of-a-kind, and straights (flushes are slightly more tricky).</p>

<p>I won't go into all the particular operations, but suffice it to say that this kind of model supports millions of operations per second...</p>

<p>Of course, keep in mind, I'm not actually advocating that you use a design like this in a straightforward game implementation. The only reason I ended up with this design is because I needed to conduct massive statistical simulations.</p>

<p>So think carefully about how you want to model:</p>

<ul>
<li>Each card</li>
<li>A player's hand</li>
<li>The entire deck</li>
<li>The state of the table... including all player hands (including players who have split their initial hand), maybe a six-deck shoe, the discard pile, etc</li>
</ul>

<p>The overall application model, and the goals of the application in general, will determine to a large extent the types of data structures that'll be most appropriate.</p>

<p>Have fun!!!</p>
",0
234805,234388,0,"<p>Since this is homework for C++ I am going to guess you are expected to use classes.
Otherwise use the enums, and if this were C use a struct or something.</p>

<p>And for some games, apart from points value, you'd want to store some kind of rank for the card, which would depend on the current mode of play.</p>

<p>I haven't done plain C in forever, but I mean something like this:</p>

<pre><code>typedef struct struct_card {
  unsigned short int suit:2;
  unsigned short int card:4;
//  unsigned short int valu:4;
} card;

int main() {
  card a_card;
  card std_deck[52];
  const unsigned short int rummy_value[13] = {1,2,3,4,5,6,7,8,9,10,10,10,10};
  const char *std_card_name[13] = {""Ace"",""Two"",""Three"",""Four"",""Five"",""Six"",
    ""Seven"",""Eight"",""Nine"",""Ten"",""Jack"",""Queen"",""King""};
  const char *std_suit_name[4] = {""Spades"",""Clubs"",""Hearts"",""Diamonds""};

  int j, k, i=0;
  for(j=0; j&lt;4; j++){
    for(k=0; k&lt;13; k++){
      a_card.suit=j; a_card.card=k;
      std_deck[i++] = a_card;
    }
  }

  //check our work
  printf(""In a game of rummy:\n"");
  for(i=0;i&lt;52;i++){
    printf(""  %-5s of %-8s is worth %2d points.\n"",
        std_card_name[std_deck[i].card],
        std_suit_name[std_deck[i].suit],
        rummy_value[std_deck[i].card]);
  }

  //a different kind of game.
  enum round_mode {SHEILD_TRUMP, FLOWER_TRUMP, BELL_TRUMP, ACORN_TRUMP, BOCK, GEISS} mode;
  const card jass_deck[36]={
    {0,0},{0,1},{0,2},{0,3},{0,4},{0,5},{0,6},{0,7},{0,8},
    {1,1},{1,1},{1,2},{1,3},{1,4},{1,5},{1,6},{1,7},{1,8},
    {2,2},{2,1},{2,2},{2,3},{2,4},{2,5},{2,6},{2,7},{2,8},
    {3,3},{3,1},{3,2},{3,3},{3,4},{3,5},{3,6},{3,7},{3,8},
  };
#define JASS_V {11,0,0,0,0,10,2,3,4}
  const unsigned short int jass_value[9] = JASS_V;
#define JASS_TRUMP_V {11,0,0,0,14,10,20,3,4}
  const unsigned short int jass_trump_value[9] = JASS_TRUMP_V;
#define JASS_BOCK_V {11,0,0,8,0,10,2,3,4}
  const unsigned short int jass_bock_value[9] = JASS_BOCK_V;
#define JASS_GEISS_V {0,11,0,8,0,10,2,3,4}
  const unsigned short int jass_geiss_value[9] = JASS_GEISS_V;
  const char *jass_card_name[9] = {""Ace"",""Six"",""Seven"",""Eight"",""Nine"",""Banner"",
    ""Under"",""Ober"",""King""};
  const char *jass_suit_name[4] = {""Sheilds"",""Flowers"",""Bells"",""Acorns""};
  const unsigned short int jass_all_value[6][4][9] = {
    { JASS_TRUMP_V, JASS_V, JASS_V, JASS_V },
    { JASS_V, JASS_TRUMP_V, JASS_V, JASS_V },
    { JASS_V, JASS_V, JASS_TRUMP_V, JASS_V },
    { JASS_V, JASS_V, JASS_V, JASS_TRUMP_V },
    { JASS_BOCK_V, JASS_BOCK_V, JASS_BOCK_V, JASS_BOCK_V },
    { JASS_GEISS_V, JASS_GEISS_V, JASS_GEISS_V, JASS_GEISS_V }
  };

  //check our work 2: work goes on summer vacation
  printf(""In a game of jass with trump (Sheilds | Flowers | Bells | Acorns) | Bock | Geiss\n"");
  for(i=0;i&lt;36;i++){
    printf(""  %-6s of %-7s is worth %8d%10d%8d%9d%8d%8d\n"",
        jass_card_name[jass_deck[i].card],
        jass_suit_name[jass_deck[i].suit],
        jass_all_value[SHEILD_TRUMP][jass_deck[i].suit][jass_deck[i].card],
        jass_all_value[FLOWER_TRUMP][jass_deck[i].suit][jass_deck[i].card],
        jass_all_value[BELL_TRUMP][jass_deck[i].suit][jass_deck[i].card],
        jass_all_value[ACORN_TRUMP][jass_deck[i].suit][jass_deck[i].card],
        jass_all_value[BOCK][jass_deck[i].suit][jass_deck[i].card],
        jass_all_value[GEISS][jass_deck[i].suit][jass_deck[i].card]);
  }
  return 0;
}
</code></pre>

<p>Output looks like:</p>

<pre><code>In a game of rummy:
  Ace   of Spades   is worth  1 points.
  Two   of Spades   is worth  2 points.
  Three of Spades   is worth  3 points.
  Four  of Spades   is worth  4 points.
  Five  of Spades   is worth  5 points.
...
  Nine  of Diamonds is worth  9 points.
  Ten   of Diamonds is worth 10 points.
  Jack  of Diamonds is worth 10 points.
  Queen of Diamonds is worth 10 points.
  King  of Diamonds is worth 10 points.
In a game of jass with trump (Sheilds | Flowers | Bells | Acorns) | Bock | Geiss
  Ace    of Sheilds is worth       11        11      11       11      11       0
  Six    of Sheilds is worth        0         0       0        0       0      11
  Seven  of Sheilds is worth        0         0       0        0       0       0
  Eight  of Sheilds is worth        0         0       0        0       8       8
  Nine   of Sheilds is worth       14         0       0        0       0       0
  Banner of Sheilds is worth       10        10      10       10      10      10
...
  Under  of Acorns  is worth        2         2       2       20       2       2
  Ober   of Acorns  is worth        3         3       3        3       3       3
  King   of Acorns  is worth        4         4       4        4       4       4
</code></pre>

<p>Blackjack is boring.
This code does compile.</p>
",0
235769,234388,2,"<p>This might not compile, but here is the approach I would (and have used). You're going to want to use ints to represent your cards, but you can easily abstract this in a class. Which I'll write for you.</p>

<pre><code>class Card
{
public:
    enum ESuit
    {
        kSuit_Heart,
        kSuit_Club,
        kSuit_Diamond,
        kSuit_Spade,
        kSuit_Count
    };

    enum ERank
    {
        kRank_Ace,
        kRank_Two,
        kRank_Three,
        kRank_Four,
        kRank_Five,
        kRank_Six,
        kRank_Seven,
        kRank_Eight,
        kRank_Nine,
        kRank_Ten,
        kRank_Jack,
        kRank_Queen,
        kRank_King,
        kRank_Count
    };

    static int const skNumCards = kSuit_Count * kRank_Count;

    Card( int cardIndex )
    : mSuit( static_cast&lt;ESuit&gt;( cardIndex / kRank_Count ) )
    , mRank( static_cast&lt;ERank&gt;( cardIndex % kRank_Count ) )
    {}

    ESuit GetSuit() const { return mSuit );
    ERank GetRank() const { return mRank );

private:
    ESuit mSuit;
    ERank mRank;
}
</code></pre>

<p>Now its very simple to add to this class to get everything you want out of it.
To generate the list its as simple as below.</p>

<pre><code>rstl::vector&lt;Card&gt; mCards;
mCards.reserve( Card::skNumCards );

for ( int cardValue = 0; cardValue &lt; Card::skNumCards; ++cardValue )
{
    mCards.push_back( Card( cardValue ) );
}
</code></pre>

<p>Do you need to shuffle?</p>

<pre><code>#include &lt;algorithm&gt;
std::random_shuffle( mCards.begin(), mCards.end() );
</code></pre>

<p>How about see what the value of the first card is?</p>

<pre><code>if ( mCards[0].GetSuit() == Card::kRank_Club &amp;&amp; mCards[0].GetRank() == Card::kRank_Ace )
{
    std::cout &lt;&lt; ""ACE OF CLUBS!"" &lt;&lt; std::endl;
}
</code></pre>

<p>I didn't compile any of this, but it should be close.</p>
",0
342568,300208,0,"<p>Both statements compile:</p>

<pre><code>( a != b ) ? cout&lt;&lt;""not equal"" : NULL;

( a != b ) ? NULL : cout&lt;&lt;""equal"";
</code></pre>
",0
300223,300208,1,"<p>This is very confusing code. You <em>could</em> just write</p>

<pre><code>cond ? cout &lt;&lt; ""equal"" : cout;
</code></pre>

<p>but you won't (will you?) because you've got conventional <code>if</code> for that.</p>
",0
300225,300208,22,"<p>If it really is for a ternary operator that doesn't need a second action, the best option would be to replace it for an if:</p>

<pre><code>if (a!=b) cout &lt;&lt; ""not equal"";
</code></pre>

<p>it will smell a lot less.</p>
",2
300226,300208,0,"<pre><code>if (a!=b) cout&lt;&lt;""not equal"";
</code></pre>
",0
300229,300208,11,"<p>Simple: I would code it as</p>

<pre><code>if (a != b)
   cout &lt;&lt; ""not equal"";
</code></pre>

<p>The ternary operator requires the two results to be of the same type.  So you might also be able to get away with</p>

<pre><code>(a != b) ? cout &lt;&lt; ""not equal"" : cout;
</code></pre>

<p>because the stream operator (&lt;&lt;) just returns the ostream reference.  That's ugly and unnecessary in my opinion though.</p>
",0
300239,300208,1,"<p>I think the problem here is that the operator : has two EXPRESSIONS as arguments.
Let's say..
a = x ? y : z;</p>

<p>Expression by definition must have a value...that's why you cannot just ""skip"".</p>
",0
300247,300208,4,"<p>The only thing missing from the other answers is this:
There is no way, directly, to code a ""noop"" in C/C++.  </p>

<p>Also, doing: <code>(a != b) ? : printf(""equal\n"");</code> does actually compile for me (gcc -ansi in gcc 4.2.4).</p>
",2
300250,300208,0,"<p>The syntax just requires a expression. You can just go:
(a!=b)?cout&lt;&lt;""not equal"":1;</p>
",2
302092,300208,5,"<p>The following will achieve what you're looking for, however, it may not be clear to people reading your code <em>why</em> it works:</p>

<pre><code>(a != b) &amp;&amp; (cout &lt;&lt; ""equal"");
</code></pre>

<p>Personally, I agree with <a href=""https://stackoverflow.com/questions/300208/how-does-one-execute-a-no-op-in-cc#300225"">this</a> answer from Vinko Vrsalovic.  </p>
",2
302145,300208,1,"<p>If the focus of the code is the output operation and not the condition, then something like this could be done:</p>

<pre><code>cout &lt;&lt; (cond ? ""not equal"" : """");
</code></pre>

<p>I suspect that's not the case, though, because you want to do nothing in the ""else"" clause.  </p>
",0
263911,263906,2,"<p>The IMEvent constructor is called before alertText's constructor is called. In particular therefore its argument <code>alertText.c_str()</code> is evaluated before alertText's constructor is called. This ain't good.</p>

<p>Initializer expressions are called in the order that the things being initialized are declared (not necessarily the order the initializers are listed). So parent classes first, then members. Compilers sometime helpfully warn you if you don't list the initializers in the order they will actually be executed. So provided you get that right, the rule is ""don't use anything you haven't initialized"". This code uses alertText before it is initialized.</p>
",0
263914,263906,4,"<p>alertText may be shown as a string in a debugger, but it has not been constructed yet (and therefore alertText.c_str() will return an indeterminate pointer).</p>

<p>To avoid this, one could initialize use text.c_str() as an argument to the IMEvent ctor.</p>

<pre><code>AlertEvent::AlertEvent(const std::string&amp; text) :
    IMEvent(kIMEventAlert, text.c_str()),
    alertText(text)
{
    //inspection at time of crash shows alertText is a valid string
}


IMEvent::IMEvent(long eventID, const char* details)
{
    //during construction, details==0xcccccccc
}
</code></pre>
",3
263918,263906,1,"<p><em>The IMEvent constructor is called before alertText's constructor is called.</em></p>

<p>Almost. <code>alertText.c_str()</code> is called before alertText is constructed, that is the real problem. The easiest solution is replacing it with <code>text.c_str()</code></p>
",1
452779,452771,0,"<p>You don't need malloc(). You can use <code>new</code> for the array of pointers, too:</p>

<pre><code>    test **objs = new test* [50];
</code></pre>
",1
452787,452771,4,"<p>Why do you need array?</p>

<pre><code>std::vector&lt;test*&gt; v(50);
</code></pre>

<p>Or as <code>@j_random_hacker</code> suggested in the comments:</p>

<pre><code>std::vector&lt;test&gt; v(50, test(1));
</code></pre>

<p>An example:</p>

<pre><code>/** g++ -Wall -o vector_test *.cpp &amp;&amp; vector_test */
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;

struct Test {
  int value;
  Test(int x) : value(x) 
  {
    std::cout &lt;&lt; ""Test("" &lt;&lt; value &lt;&lt; "")"" &lt;&lt; "" "";
  }
  operator int() const
  {
    std::cout &lt;&lt; ""int("" &lt;&lt; value &lt;&lt; "")"" &lt;&lt; "" "";
    return value;
  }
};

int main()
{
  using namespace std;

  vector&lt;Test&gt; v(5, Test(1));

  cout &lt;&lt; endl;
  copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, "" ""));
  cout &lt;&lt; endl;

  v[1] = 2;
  v[2].value = 3;

  cout &lt;&lt; endl;
  copy(v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout, "" ""));
  cout &lt;&lt; endl;

  return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>Test(1) 
int(1) 1 int(1) 1 int(1) 1 int(1) 1 int(1) 1 
Test(2) 
int(1) 1 int(2) 2 int(3) 3 int(1) 1 int(1) 1 
</code></pre>
",3
452789,452771,7,"<p>You cannot create an array of objects, as in <strong>Foo&nbsp;foo&nbsp;[N]</strong>, without a default constructor.  It's part of the language spec.</p>

<p><strong>Either</strong> do:</p>

<pre><code>test * objs [50];
for() objs[i] = new test(1).
</code></pre>

<p>You don't need malloc().  You can just declare an array of pointers.</p>

<pre><code>c++decl&gt; explain int * objs [50]
declare objs as array 50 of pointer to int
</code></pre>

<p>But you probably ought to have some sort of automatic RAII-type destruction attached.</p>

<hr>

<p><strong>OR</strong> subclass <em>test</em> publicly:</p>

<pre><code>class TempTest : public test
{
public:
  TempTest() : test(1) {}
  TempTest(int x) : test(x) {}
  TempTest(const     test &amp; theTest ) : test(theTest) {}
  TempTest(const TempTest &amp; theTest ) : test(theTest) {}
  test &amp; operator=( const     test &amp; theTest ) { return test::operator=(theTest); }
  test &amp; operator=( const TempTest &amp; theTest ) { return test::operator=(theTest); }
  virtual ~TempTest() {}
};
</code></pre>

<p>and then:</p>

<pre><code>TempTest  array[50];
</code></pre>

<p>You can treat every <em>TempTest</em> object as a <em>test</em> object.</p>

<p>Note:  operator=() &amp; copy constructor are not inherited, so respecify as necessary.</p>
",4
452986,452771,2,"<p>I think that other responders are treating this question too literally.</p>

<p>If all you really want to do is make a ""group"" of 50 objects that you can treat as an array, then by far the easiest and most maintainable way of accomplishing what you're trying to do is:</p>

<pre><code>std::vector&lt;test&gt; objs(50, test(1));
</code></pre>

<p>This declares a <code>vector</code> of 50 objects, each of which is a copy of <code>test(1)</code>.  A <code>vector</code> is basically a C++ growable array; although you may not need the growability, the fact that it can be called with a 2-arg constructor that copy-constructs each element is useful here.</p>

<p>You can use this more-or-less exactly like an array -- e.g. the 5th element is <code>objs[4]</code>.  Performance is the same too -- the C++ standard guarantees that internally the elements are stored in a contiguous array.</p>
",0
453270,452771,0,"<p>Boost's <a href=""http://www.boost.org/doc/libs/1_37_0/libs/ptr_container/doc/ptr_container.html"" rel=""nofollow noreferrer"">Pointer Container</a> library might come to rescue here. With <code>boost::ptr_vector&lt;T&gt;</code> you can hold a list of heap-allocated objects which can be even polymorphic (virtual functions), which isn't possible with simply <code>std::vector&lt;T&gt;</code>.</p>

<p>Unlike <code>std::vector&lt;T&gt;</code>, the objects won't be stored in subsequential memory addresses. Things like resizing the container however will be faster because the elements will keep their original memory addresses. The best bonus is, you don't need to call <code>delete</code> yourself: the contained objects will be destroyed when the <code>ptr_vector</code> goes out of scope. Example:</p>

<pre><code>#include &lt;boost/ptr_vector.hpp&gt;
#include &lt;iostream&gt;
class test() {
protected:
    int const i;
public:
    explicit test(int i) : i(i) {}
    virtual void who_am_i() const { std::cout &lt;&lt; ""I am test "" &lt;&lt; i &lt;&lt; std::endl; }
};
class special_test : public test {
public:
    explicit special_test(int i) : test(i) {}
    virtual void who_am_i() const { std::cout &lt;&lt; ""I am special_test "" &lt;&lt; i &lt;&lt; std::endl; }
};
int main() {
    boost::ptr_vector&lt;test&gt; objs;
    for (int i=0; i&lt;50; ++i)
        objs.push_back(new test(i)); // NB: constructing to heap here!
    objs.push_back(new special_test(123)); // objs can also hold inherited classes
    objs[13].who_am_i(); // outputs: I am test 13
    objs[50].who_am_i(); // outputs: I am special_test 123
} // all created objects are automatically destroyed here
</code></pre>
",0
454052,452771,3,"<p>Contrary to what many people believe, you can actually create an array of objects that do not have a default constructor. What you cannot do is make it use a set of arguments for all constructor invokations. You just have to initialize all elements of it. That is, you can do the following:</p>

<pre><code>#define PRINTT(z, n, initializer) initializer
test objs[50] = {
    BOOST_PP_ENUM(50, PRINTT, 1) // yields 1, 1, 1, .... 1
};
#undef PRINTT
</code></pre>

<p>That will initialize all 50 elements with 1. <code>boost::pp</code> is used to print a <code>1</code> 50 times in a row automatically. </p>
",3
44886,23209,2,"<p>If you still wish to get the project to compile using VS2008 (or in the future) I can suggest using a binary editor to view the object file in question <em>mainapp.obj</em>.</p>

<p>Here is an example from a small project of mine.</p>

<p>The zdbException.obj contains the following excerpt</p>

<pre><code>DEFAULTLIB:""libc
pmtd"" /DEFAULTLI
B:""uuid.lib"" /DE
FAULTLIB:""uuid.l
ib"" /include:?id
@?$num_put@DV?$o
streambuf_iterat
or@DU?$char_trai
ts@D@std@@@std@@
@std@@2V0locale@
2@A /include:?id
@?$numpunct@D@st
d@@2V0locale@2@A
 /DEFAULTLIB:""LI
BCMTD"" /DEFAULTL
IB:""OLDNAMES"" /E
DITANDCONTINUE 
</code></pre>

<p>Note the entry <strong>/DEFAULTLIB:""LIBCMTD""</strong>. This indicates the object file was compiled with the static c run-time multi-threaded debug.</p>

<p>There is also the possibility that the functions referenced in the obj are deprecated in the standard run-time lib shipped with VS2008.</p>
",0
26180,23209,-2,"<p>After trying to get this stuff to compile under VS 2008, I tried earlier versions of VS - 2005 worked with warnings, and 2003 just worked.  I double checked the linkages and couldn't find any problems, so either I just couldn't find it, or that wasn't the problem.  </p>

<p>So to reiterate, downgrading to VS 2003 fixed it.</p>
",0
26217,23209,2,"<p>Check this on <a href=""http://msdn.microsoft.com/en-us/library/2kzt1wy3(VS.80).aspx"" rel=""nofollow noreferrer"" title=""MSDN"">MSDN</a>:</p>

<ul>
<li>/MD Causes your application to use the multithread- and DLL-specific version of the run-time library.</li>
<li>/MT  Causes your application to use the multithread, static version of the run-time library.</li>
</ul>

<p>Note:  ""... so that the linker will use LIBCMT.lib to resolve external symbols""</p>

<p>So you'll need a different set of libraries.</p>

<p>How I went about finding out which libraries to link:</p>

<ol>
<li>Find a configuration that <em>does</em> link, and add /verbose option.</li>
<li>Pipe the output to a text file.</li>
<li>Try the configuration that <em>doesn't</em> link.</li>
<li>Look in the verbose output from step 2 for the symbols that are unresolved (""_declspec(dllimport) public: void thiscall std::locale::facet::Register(void)"" in your case) and find the used libraries.</li>
<li>Add those libraries to the list of libraries you're linking to.</li>
</ol>

<p>Old skool but it <a href=""https://stackoverflow.com/questions/9570/what-libraries-do-i-need-to-link-my-mixed-mode-application-to"">worked</a> for me.</p>

<p>Jan</p>
",0
23212,23209,4,"<p>These are standard library references. Make sure that all libraries (including the standard library) are using the <em>same</em> linkage. E.g. you can't link statically while linking the standard lib dynamically. The same goes for the threading model used. Take special care that you and the 3rd party library use the same linkage options.</p>

<p>This can be a real pain in the *ss.</p>
",0
142635,142602,4,"<p>To sharpen your C++ skills I'd suggest going over some of your old C++ code if you still have access to it.  Revisiting it will hopefully trigger those parts of your brain that have laid dormant after switching to C# :)</p>

<p>For libraries STL is good, then boost.  I don't think there is too much new stuff going on with ATL/WTL from what you would have known back in 2001.</p>
",0
142638,142602,4,"<p>Just start a project. The libraries you use will depend on your project, but you should certainly read up on the STL. If you haven't used C++ for a long time you might need learn more about templates.</p>
",0
142641,142602,3,"<p>For a start, I'd say try writing code that will work on both a Mac and Windows or Linux and Windows. This will force you to write code that is much more portable than the type of C++ code you can get away with on Visual C++ - there a lot of finer points that are very different when you go cross platform. </p>

<p>I'd suggest stay away from libraries for now if you can - perfect your ANSI C++ game first. I'd also suggest reading up on C++0x - the next standard is due soon and it would help you more to work towards that. To that end, brush up on the STL (the concepts behind it, not the implementation so much) and templates. </p>

<p>If you'd like to try BOOST, go ahead, but you can generally get by without using it. The reason I stayed away from it mostly is because of the way templates are used to do what is needed - a lot of which will become much easier once the new standard is introduced.</p>

<p>UPDATE: Once you're comfortable with the STL and start needing to do things that require a lot of code with the STL or are just plain tricky, then head over to BOOST. Buy a book on BOOST and read it and understand it well.</p>
",0
142643,142602,10,"<p><a href=""http://boost.org"" rel=""noreferrer"">Boost</a> - though it, and other libraries were around back then, its only relatively recently that it's taken off in a big way. Google for TR1 and c++0x standards too. You should defintely read up on STL because (IMHO) its the thing that makes C++ special.</p>

<p>ATL is as good a dead technology (don't get me wrong, I liked it and still use it somewhat, but its not fashionable in the MS world anymore). </p>

<p>Something like QT is probably more new and cool for C++ developers, and has the advantage of getting you into all the new Linux and web development that'll be increasingly popular over the next few years.</p>

<p>However, once you start looking at the things you can do, I think it'll all come back quite quickly. </p>
",0
142661,142602,2,"<p>Take some old piece of code and add to it. This won't get you back on top of the latest C++ trends but it will get your feet wet. </p>

<p>At my job I had to add some features to a C++ ActiveX control and I hadn't touched C++ in years and years and have never done it professionally. Figuring out how to do it again was actually pretty damn cool. </p>
",0
142683,142602,8,"<p>I personally find that syntax is where i mostly need to catch up when i wander back to a language i havent used in a long time. But the concepts and what the language is about stays the same in memory. </p>

<p>Assuming its the same with you, i would say its a good idea to relook at the texts you remember to have been useful to you while learning C++. I would recommned Thinking in C++ for getting up fast on the syntax. </p>

<p>STL would be really useful yes. Thats one thing i have found commonly appreciated by all mature C++ programmers. It would be useful to know the libraries that Boost provides. </p>

<p>The changes to C++ world, depends on the changes your favourite compiler has decided to implement. Since you mentioned ATl/COM i assume it would be VC++. The changes to MFC would be support for Windows Forms (2005 vc++) and Vista compliant uI's and ribbon support(?) (2008 Vc++)</p>

<p>VC++ now supports managed C++ -i'm sure you know what that is coming from the C# world - 2008 adds supports for managed STL too. </p>

<p>VC++ is trying to be more standards compliant and are making some progress in that area. </p>

<p>They have introduced lots of secure functions that depreciate the old stds like strcpy and the compilers will also give warnings if you use the old fns. </p>

<p>VC++2005 also has something called function attributes, which it uses to describe the parameters so that it can do more checking on the inputs you pass in and statically flag a warning if it sees soething amiss. Usefuli would say though our shop has not progressed to using the 2005 compiler. </p>

<p>MSDN has the list of breaking changes for each releases. Oh &amp; Support for Windows 95, Windows 98, Windows Millennium Edition, and Windows NT 4.0 has been removed from 2005 version of VC++. Additionally the core libraries you required till now (CRT, ATL, MFC etc) now support a new deployment model which makes them shared side sy side assemblies and requires a manifest. </p>

<p>This link should get you going - <a href=""http://msdn.microsoft.com/en-us/library/y8bt6w34.aspx"" rel=""noreferrer"">http://msdn.microsoft.com/en-us/library/y8bt6w34.aspx</a></p>

<p>2008 adds even more like Tr1 recommendations, more optimizning compiler, parallel compilation(/mp), support for new processor architectures etc. Open Mp support has also been enhanced in one of these versions is what i remember. </p>

<p>Again refer MSDN - thats the suthentic source for all the answers. </p>

<p>Good luck. </p>
",2
142717,142602,2,"<p>I was in a similar situation: switched from C++ to C# in 2005 and then switched back to C++ in 2007. I can't say C++ universe really changed in those 2 years. The most crucial thing was to regain my memory-management instincts, but that can only be done by practicing.</p>

<p>Now that you have both C++ and .NET under your belt you might want to study C++ CLI a bit (new incarnation of late ""Managed C++"").</p>

<p>As for books, read everything with ""Meyers"" and ""Sutter"" on the cover.</p>
",1
142739,142602,3,"<p>Rewrite some of your C# stuff using C++</p>
",1
142814,142602,5,"<p>Definitely read the latest edition of ""Effective C++"" by Scott Meyers.  I would also recommend ""C++ Gotchas: Avoiding Common Problems in Coding and Design"" by Stephen C. Dewhurst.</p>
",0
142871,142602,4,"<p>Pickup one of the C++ Unit Test frameworks out there (I suggest <a href=""http://code.google.com/p/googletest/"" rel=""nofollow noreferrer"">Google C++ Testing Framework</a>, aka. <code>gtest</code>).  Pick a small project that you can start from scratch and try some <a href=""https://rads.stackoverflow.com/amzn/click/com/0321146530"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">TDD</a>.  The TDD will encourage you to make small steps and to reflect on your code.  Also, as you build your suite of unit tests, it gives you a base from which you can experiment with different techniques.</p>
",0
694816,694807,0,"<p>It's very common to not know how many items you have to deal with - they might come from a file or whatever. To store items which come from outside your program you need dynamic sized arrays.</p>

<p>PS: Be sure to use STL classes like std::vector, not ""arrays"".</p>
",0
694817,694807,0,"<p>You need dynamic allocation when you don't know how many objects you'll need to allocate.</p>
",0
694819,694807,7,"<p>Another issue for dynamic memory is lifetime.  Dynamic memory (new, malloc, etc ...) lives on the heap.  It will stay alive until it is explicitly deleted by a piece of code through the appropriate memory function.  This is very useful for long lived objects.</p>

<p>Non dynamic memory, or the stack, has a very definite lifetime.  The memory allocated on the stack will only be around while that method is executing.  Once the method is finished the memory will be automatically reclaimed.</p>
",1
772156,772146,3,"<pre><code>if (in == out) {
    delete in;
}
else {
    delete in;
    delete out;
}
</code></pre>

<p>?</p>
",1
772160,772146,3,"<p>Rule of thumb: match your <code>new</code>s with your <code>delete</code>s. </p>

<pre><code>~App::App()
{
    delete out;
    // the next line tries to free
    // memory no longer in the app's
    // control invoking UB
    delete in;
}
</code></pre>

<p>Here, you run into the classic <em>double-free</em> problem. </p>

<pre><code>~App::App()
{
    if (in != out)
    {
        delete out;
    }
    // if in == out the out object is not deleted
    // for a non trivial object this tantamounts to
    // leaking resources held by TCPChannelOut other
    // than d
    delete in;
}
</code></pre>

<p>The only solution seems to be to use a smart reference counted pointer.</p>
",5
772163,772146,9,"<p>You'll need something along the lines of:</p>

<pre><code>~App::App()
{
    if (in != out)
    {
        delete out;
    }
    delete in;
}
</code></pre>

<p>As when the channels are different the pointers will be different.</p>

<p>However, as danatel has pointed out in the comments <code>in</code> and <code>out</code> are not comparable. A safe (but inelegant) solution would be to use a <code>dummy</code> flag. Set if <code>in</code> and <code>out</code> are set to the dummy channel, the destructor would become:</p>

<pre><code>~App::App()
{
    if (!dummy)
    {
        delete out;
    }
    delete in;
}
</code></pre>

<p>Though I wouldn't be happy with this.</p>

<p>The only other solution I can see at the moment is to change the definitions of <code>IChannelIn</code> and <code>IChannelOut</code> so that they can be compared safely.</p>
",4
772165,772146,7,"<p>If you are using boost you could consider using the <a href=""http://www.boost.org/doc/libs/1_38_0/libs/smart_ptr/shared_ptr.htm"" rel=""nofollow noreferrer"">boost::shared_ptr</a>  This will automatically delete the object when the last instance is released.</p>
",4
772191,772146,0,"<p>I always think of object ownership at design time: </p>

<ul>
<li>who creates the object?</li>
<li>Who owns (therefore deletes the
object)?</li>
<li>How can I avoid to use a reference to
an object that is already destroyed
(or how can I determine whether a
referenced object is still valid or
not)?</li>
</ul>

<p>When trying to answer these questions I determine the way to implement it, too (destructors, smart pointers, etc.).</p>
",0
772224,772146,3,"<p>How does your class <em>know</em> that this is a freestore pointer? E.g. what speaks against the following code?</p>

<pre><code>DummyChannel d;
in = &amp;d;
out = &amp;d;
</code></pre>

<p>This is an entirely sensible piece of code but your destructor <strong>will</strong> crash when trying to delete either of the pointers.</p>

<p>Long story short: reclaiming resources is the job of whoever has allocated the resources in the first place. If your class gets passed a pointer, the class cannot know and does not care about deallocation. This is strictly the responsability of the caller.</p>

<p>Elegant ways to solve this dilemma without making the client to a lot of work are smart pointers, as mentioned before.</p>
",1
774081,772146,0,"<p>Don't forget to make your IChannelIn and IChannelOut destructors virtual. If the destructors are not virtual the TCPChannel or DummyChannel destructors will not get called when the IChannel destructors are called (i.e. when the IChannel ptr contents are deleted).</p>
",0
226368,225250,0,"<p>Create one test application which reads the header file and creates the source file. Test application should parse the header file to know the function names.</p>
",0
226459,225250,1,"<p>This is a harder problem than you might like, as parsing C++ can quickly become a difficult task. Your best bet would be to pick an existing parser with a nice interface.</p>

<p>A quick search found <a href=""http://compilers.iecc.com/comparch/article/06-09-169"" rel=""nofollow noreferrer"">this thread</a> which has many recommendations for parsers to do something similar.</p>

<p>At the very worst you might be able to use SWIG --> Python, and then use reflection on that to print a dummy implementation.</p>

<p>Sorry this is only a half-answer, but I don't think there is an existing tool to do this (other than a mocking framework, which is probably the same amount of work as using a parser).</p>
",0
391567,391553,5,"<p>I found <a href=""http://web.archive.org/web/20090823155413/http://www.sfu.ca/~vwchu/projects/CPPQuickRef.pdf"" rel=""nofollow noreferrer"">this one</a> that seems to be detailed enough.</p>

<p>It covers basics of templates, inheritance, operators, exceptions, etc. It has a lot of information in a very small space.</p>
",0
391633,391553,2,"<p>The O'Reilly book <a href=""http://oreilly.com/catalog/9780596004965/"" rel=""nofollow noreferrer"">C++ Pocket Reference</a> would be one such useful tool.</p>

<blockquote>
  <p>The C++ Pocket Reference is a memory
  aid for C++ programmers, enabling them
  to quickly look up usage and syntax
  for unfamiliar and infrequently used
  aspects of the language. The book's
  small size makes it easy to carry
  about, ensuring that it will always be
  at-hand when needed. Programmers will
  also appreciate the book's brevity; as
  much information as possible has been
  crammed into its small pages.</p>
</blockquote>
",0
391642,391553,2,"<p>I've been using the <a href=""http://sparkcharts.sparknotes.com/cs/cplusplus/"" rel=""nofollow noreferrer"">SparkCharts C++ cheat sheet</a>.  I found it at a Borders, but you can print it out online for the same price.</p>
",0
633387,391553,2,"<p><a href=""http://interviewpattern.com/Resources/CPP_Language_Reference.pdf"" rel=""nofollow noreferrer"">CPP_Language_Reference</a> </p>

<p><a href=""http://interviewpattern.com/Resources/CppQuickReference.pdf"" rel=""nofollow noreferrer"">CppQuickReference</a></p>
",0
1521941,1521924,6,"<pre><code>    for(vector&lt;int&gt;::iterator iter = sudokuBoard[i][j].possibleIntegers.begin(); iter!= sudokuBoard[i][j].possibleIntegers.end();)
</code></pre>

<p>You don't seem to be advancing the iterator in that loop, so it will never end. Add <code>++iter</code> to the counting expression (after the last ; in the for loop).</p>

<p>As to why your debugger can't find source for that location, that's platform dependent. What debugger are you using?</p>
",0
1521948,1521924,2,"<p>You do not increase the iterator on the inside loop: </p>

<pre><code>   for(vector&lt;int&gt;::iterator iter = sudokuBoard[i][j].possibleIntegers.begin(); iter!= sudokuBoard[i][j].possibleIntegers.end(); ++iter)
</code></pre>

<p>Resulting an infinate for loop (Compiler knows this and ""optimized"" it for an infinite loop, which is why there is no code available).</p>
",7
1521951,1521924,0,"<p>I suggest you recode it to use ...</p>

<pre><code>class SudokuBoard
{
  SudokuNode nodes[9];
};
</code></pre>
",0
1501862,1501859,14,"<p>The function itself is not actually stored in the class. </p>

<p>Only the class's data members (and possibly its vtable pointer, if it has one) affect its size. The function itself lives in the executable code region, and all instances of the same type of class use that one definition of the function. The compiler does not actually copy out the entirety of a function body every time you create a new instance of the class. </p>

<p>Also, <code>sizeof(t1.Test11())</code> does not mean ""the size of the function Test::Test11's executable code in bytes."" It means ""the size of the type returned by Test::Test11"". </p>
",1
1501893,1501859,3,"<p>Function implementation is not contained in each instance of a class, so instance of a class could have size 0, but it is not. Bjarne Stroustrup wrote here <a href=""http://www.research.att.com/~bs/bs_faq2.html#sizeof-empty"" rel=""nofollow noreferrer"">why is the size of an empty class not zero?</a></p>
",0
720542,710604,-1,"<p>istream is not going to help a lot - it functions as designed. However, it delegates the actual reading to streambufs. If your streambuf wrapper trims trailing whitespace, an istream reading from that streambuf won't notice it.</p>
",0
710622,710604,-1,"<blockquote>
  <p>How do I end this function with something to check if there's nothing left to read in formatted in the file (eg. only whitespace)?</p>
</blockquote>

<p>Whitespace characters are characters in the stream. You cannot assume that the stream will do intelligent processing for you. Until and unless, you write your own filtering stream.</p>
",6
710825,710604,1,"<p>Construct an <code>istream::sentry</code> on the stream. This will have <a href=""http://www.cplusplus.com/reference/istream/istream/sentry/"" rel=""nofollow noreferrer"">a few side effects</a>, the one we care about being:</p>

<blockquote>
  <p>If its <code>skipws</code> format flag is set, and the constructor is not passed <code>true</code> as second argument (<em>noskipws</em>), all leading <em>whitespace characters</em> (locale-specific) are extracted and discarded. If this operation exhausts the source of characters, the function sets both the <code>failbit</code> and <code>eofbit</code> <em>internal state flags</em></p>
</blockquote>
",0
589539,589535,0,"<p>Assuming that you're working with C++, the my answer is NO. It's perfectly reasonable, but you'll should really stick to that convention.</p>

<p>However, statically typed languages such as C# assume such naming conventions to be somewhat redundant.</p>

<p>Personally I think it's ugly, but it's not apparent where a variable comes from in C++ as such the sugaring might help.</p>
",0
589542,589535,1,"<p>Everyone has his/her own preferences as far as naming conventions are concerned. I'd say more people would agree on not having any public variables in a class.</p>
",0
589543,589535,10,"<p>Some concerns:</p>

<ul>
<li><p>Why do you have public variables?</p></li>
<li><p>Identifiers starting with _ and __ are reserved for system libraries.  In practice this doesn't matter very often, but it's nice to be aware.</p></li>
</ul>

<p>With those things said, there's nothing wrong with creating a naming convention, regardless of how it looks.  Just be consistent.</p>
",1
589589,589535,8,"<p>The same goes for C++ and for Java: you do not need any hungarian notation nor any prefixes/suffixes. You got keyword ""this""!</p>

<pre><code>class MyClass {
    private:
        int value;

    public:
        MyClass(int value) {
            this-&gt;value = value;
        }
}
</code></pre>

<p>Of course in this simple example you can (should!) use constructor initialization list ;)</p>

<p>So, instead using any awkward notations just employ language's possibilities. When you know the name of your member variable - you know that it is perfect. Why would you obfuscate it with ""_""?</p>

<p>As for using the same names for public and private members: this absolutely wrong thinking! Why would one need two things to represent the same in the same class? Make it private, name it perfectly and give getters and setters public.</p>
",0
592088,589535,2,"<p>You should not use names that begin with an underscore or contain a double underscore. Those names are reserved for the compiler and implementation. Besides that restriction, you can use any naming convention you and your team likes. Personally, I hate any form of ""Hungarian"" notation and dislike the m_something notation as well. It really bothers me that if I need to change the type of a variable I need to go update its name everywhere where it occurs. That's a maintenance headache. </p>
",0
1406048,1405911,1,"<p>Can you derive from IRasterProps? Being that the case you can construct your own interface to it.</p>

<p>EDIT: Following on the concept you can probably also apply the Adapter design pattern (or even a Facade if you wish to apply a common interface to several like-minded classes of the SDK).</p>
",0
1406049,1405911,7,"<p>I know I've already answered, but here's another way.  It's better in that it's faster (no boost::function overhead) and avoids the binders (since people seem to have an aversion to them), but is worse in that it's much less general (since it only works for one-argument member functions).</p>

<pre><code>template &lt;typename P, typename T, typename A&gt;
A magic(P p, void (T::*f)(A &amp;)) {
    A a;
    ((*p).*f)(a);
    return a;
}
</code></pre>

<p>Which you'd call like this:</p>

<pre><code>long output_width = magic(raster_props_object, &amp;IRasterProps::get_Width);
</code></pre>

<p>Or, if you happen to be using GCC, we can use some more tricks:</p>

<pre><code>#define MORE_MAGIC(p,f) ({ \
    typedef __typeof(*(p)) big_ugly_identifier; \
    magic((p),(&amp;big_ugly_identifier::f)); \
})
</code></pre>

<p>Which will let us do this:</p>

<pre><code>long output_width = MORE_MAGIC(raster_props_object, get_Width);
</code></pre>

<p>(Bonus points if the naming conventions made you think of a PDP-10.)</p>

<p><strong>EDIT</strong>: Updated to take any pointer-like type, so it will now work with shared_ptr, iterators, and hopefully _com_ptr.</p>

<p><strong>EDIT</strong>: Oops, they're pointers, not references.  Here's a version (or overload) that deals with that, and allows -- by ignoring -- arbitrarily-typed return values.</p>

<pre><code>template &lt;typename P, typename T, typename A, typename R&gt;
A magic(P p, R (T::*f)(A *)) {
    A a;
    ((*p).*f)(&amp;a);
    return a;
}
</code></pre>
",13
1406084,1405911,1,"<p>Looks like a COM object to me. 
Visual C++ supports an <a href=""http://msdn.microsoft.com/en-us/library/8etzzkb6(VS.71).aspx"" rel=""nofollow noreferrer"">#import</a> directive to import the type library, and create high-legel wrappers. So you either end up with </p>

<pre><code>width = ptr-&gt;GetWidth();
</code></pre>

<p>or - even better - </p>

<pre><code>width = ptr-&gt;Width;
</code></pre>

<p>If a function fails, the HRESULT returned will be transformed into an <code>_com_error</code> exception. </p>

<p>I've used that successfully on many OS and 3rd party COM objects, makes them much easier to use.</p>

<p>Note that you control the wrapper generation through options, the first thing I do is usually adding a <code>rename_namespace</code> or <code>no_namespace</code>, because otherwise the symbold end up in a namespace depending on the typelib name, which is usually ugly.</p>

<p>also, unless you use <code>named_guids</code> option, you might needto change <code>CLSID_xxx</code> and <code>IID_xxx</code> constants to <code>__uuidof(xxx)</code>.</p>
",0
1405987,1405911,0,"<p>Don't think this is possible.  Assigning void to a long should be an error in any case.</p>

<p>Remember, it's probably more performant to pass-by-reference than to return a large object.  (won't really make a difference with long's though)</p>

<p>Compiling this:</p>

<pre><code>void foo(long &amp;a) {
}

    int main(void) {

    long a=0;
    a = foo(a);
    return 0;
}
</code></pre>

<p>gives this error:</p>

<pre><code>g++ x.cc 
x.cc: In function ¡®int main()¡¯:
x.cc:9: error: void value not ignored as it ought to be
</code></pre>
",0
1405990,1405911,2,"<p>This is not quite what you specified because you need to wrap get() around the method, but it works:</p>

<pre><code>template&lt;class T, class S&gt;
T get(S fun(T&amp;)) {
  T result;
  fun(result);
  return result;
}

void foo(int&amp; x) {
  x = 5;
}

bool bar(char&amp; x) {
  x = 'c';
  return false;
}

int main() {
  int x = get(foo);
  char y = get(bar);

  return 0;
}
</code></pre>
",4
1406014,1405911,0,"<p>I'm not aware of something insane you could do, precisely like you're asking, and if there was some insane hackery that did work on some peculiar platform I'm pretty sure in a code-review I'd hate it.</p>

<p>It may may more sense to either...</p>

<ul>
<li><p>define some trivial inline function wrappers around the APIs you care about</p></li>
<li><p>make a specialized class descend from IRasterProps (or whatever) that provides the appropriate accessor methods.</p></li>
</ul>

<p>Either of those will impact maintenance time of the code but would safely and cleanly give you the call syntax you are looking for.</p>
",1
1406026,1405911,1,"<p><strong>EDIT</strong>: In  retrospect, I'm not sure this one will actually work, since I don't think the template arguments will deduce.  Buyer Beware.</p>

<p>Sure!  What you need is something to which you can pass a function that will call it and return you the outputted value.</p>

<p>Here's the easy, if less efficient way:</p>

<pre><code>template &lt;typename T&gt;
T magic(boost::function&lt;void(T&amp;)&gt; f) {
    T x;
    f(x);
    return x;
}
</code></pre>

<p>Which you'd then call like this using boost::lambda:</p>

<pre><code>long output_width = magic(raster_props_object-&gt;*&amp;IRasterProps::get_Width);
</code></pre>

<p>Or like this, using boost::bind:</p>

<pre><code>long output_width = magic(bind(&amp;IRasterProps::get_Width, raster_props_object, _1));
</code></pre>

<p>You can get rid of boost::function, but that's uglier.  Probably worth it, though.</p>
",3
475757,475750,8,"<p>Because object returned by t2+t3 is const, and you cannot call its non-const function (3).</p>

<p>It works fine in case of ""t1 = t2 + 100 +t3;"", because object returned by t2+100 is const too, but you are calling its const function (2), which is ok.</p>
",1
475761,475750,1,"<ol>
<li>Change X to test.</li>
<li>Add a semicolon to the end of the penultimate statement.</li>
<li>Remove the const from the addition operator return values as you're modifying them.</li>
</ol>

<p>The following compiles:</p>

<pre><code>class test {
 public:
  test&amp; operator=(const test &amp; other){} // 1
  test&amp; operator+(const X&amp; other) const {} // 2
  test&amp; operator+(int m) {} //3
 private:
  int n;
};

int main()
{
  test t1, t2, t3;

  t1 = t2 + t3; 
  t1 = t2 + 100;
  t1 = t2 + 100 + t3;  // &lt;-- added a ';'
  t1 = t2 + t3 + 100; 

  return 0;
}
</code></pre>
",0
476146,475750,1,"<p>You missed a const:</p>

<pre><code>const test &amp; operator+(int m) /* ADD CONST HERE */ const {} //3
</code></pre>
",0
1678483,536439,-3,"<p>It's amaizing how little effort goes into making c++ more stable. The warning system is in place, but it's not evolving much. It's even easier to shoot yourself in a foot than it was 10 years ago. Dont know why, but c++ is still my favorite language. :)</p>
",5
1678433,536439,1,"<p>Yes and no. Certainly for new projects it is increasingly popular. However, there are still barriers to adoption that are practical, not political, that others haven't mentioned. There are a lot of commercial C++ libraries that use ABIs from ancient compilers that don't properly support the features seen in Modern C++, and a lot of companies rely on these libraries. Sun Studio on Solaris for example can't work with Boost without the use of STLport, but any 3rd party commercial library you want to use will require Sun's version of the STL. Same story with GCC 2.95 and Redhat Enterprise Linux.</p>
",0
1681236,536439,2,"<p>I have looked at <a href=""http://www.indeed.com/jobtrends?q=c%2B%2B+Qt%2C+c%2B%2B+boost%2C+c%2B%2B+stl%2C+c%2B%2B+mfc&amp;l="" rel=""nofollow noreferrer"">C++ Jobs on indeed</a> and ""modern"" libraries are more and more used in job descriptions, MFC which is quite an ""old-style"" c++ library is less used.</p>
",0
1682348,536439,4,"<p>I think the biggest barrier I've encountered is toolchain support, especially on cross-platform projects. Until a few years ago, it was common to see build notes saying ""x platform needs STLport to work because their compiler is borked"". Even now, I see issues with people trying to use multiple third-party dependencies tied to different versions of BOOST. This makes linking impossible, meaning you have to go back and rebuild your deps from scratch.</p>

<p>Now that just about everyone has stopped using MSVC++ 6, the STLport mess is behind us. But as soon as TR1 is out the door, we're back to ""which versions of which environments support it and get it right"" and once again this will slow adoption.</p>

<p>I work on a project begun in C (not C++) in 1992. Deploying modern practices across the legacy codebase would be impossible. Likewise I work on another project that is much closer to the cutting edge of C++ language.</p>
",0
1684524,536439,3,"<p>Before answering such a question, you'd have to agree on what ""Modern"" is. This not likely to happen, since ""Modern"" is a poorly defined word, and means different things to different people. The title of Alexandrescu's book (Modern C++ Design) doesn't really help either, since it is largely a book on Template Metaprogramming, which is a specific area of C++ but by no means the only one. </p>

<p>For me, ""Modern C++"" != ""Template Metaprogramming"". I would say C++'s features on top of C would fall into these categories:</p>

<ul>
<li>Classes (Constructors, Destructors, RAII, Dynamic Casting and RTTI)</li>
<li>Exceptions</li>
<li>References</li>
<li>Data Structures and Algorithms in the standard library (STL)</li>
<li>iostreams</li>
<li>Simple class and function templates</li>
<li>Template metaprogramming</li>
</ul>

<p>None of these are particularly modern, since they've all been around nearly 10 years or more. Most of these features are useful and will allow you to be more productive than straight C for many use cases. A good programmer should and will use all of them in a decent sized project, but one of these things is not like the other:</p>

<p>Template Metaprogramming.</p>

<p>The short answer to template metaprogramming is just say no. Unfortunately to some people it's synonymous to ""Modern C++ programming"", due to the book, but in the end it creates more problems than it solves. Unless C++ develops better generic programming mechanisms like reflection, it will be ill suited for generic programming, and higher level languages like Python will be a better fit for those use cases. For that and many other reasons, see the <a href=""http://yosefk.com/c++fqa/"" rel=""nofollow noreferrer"" title=""C++ FQA"">C++ FQA</a></p>
",2
536520,536439,25,"<p>In the days of Windows 3.1, C was the standard.  When C++ hit the developer market and later became ANSI standard, it was the new hotness.  It popularized the OOP acronym and some of the basic design patterns using polymorphism.</p>

<p>Now, with the greater acceptance of low-barrier-to-entry managed platforms, like C#/.NET, there's less of a reason to use C++.  So much of the developer base will have a choice and let's be honest: C++ is a bear to learn for a novice.  With C#, you can just run with it.</p>

<p>That leaves really only the platforms that NEED C++ and the die-hard C++ evangelists to continue practicing the art.  This is the community that needs and wants all the layers of abstraction that is considered ""Modern C++"".</p>

<p>So yes, I believe ""Modern C++"", as you state it, is becoming more prevalent.  Albeit, it's prevalent with a different audience than has used it in the past.</p>
",6
536522,536439,1,"<p>The standardization of the language in the late 1990s was the first step, it allowed the compiler makers to focus on the ""standard"" set of features, also allowed the language to fix some of the rough edges, which appeared trough the standardization process. </p>

<p>This in turn allowed development of frameworks based on standard features of the language, and not on features provided by a particular compiler implementation. The Boost library is notably in this regard. Also this permitted that new development is based on previous work, thus making possible solutions to more complex problems.</p>

<p>A notable change here is how previously frameworks were based on the notion of base classes and derivated classes (a run time feature). But now most advanced features often are heavily based on ""recursive"" templates (a compile time feature).</p>

<p>The STL has its pros and cons but it survived the test of time, if you want something that works and is simple STL surely has something to help you start. There's no point in reinventing the wheel (unless for didactic reasons).</p>

<p>Computer hardware has also made great leaps from the 1990s, then the memory and CPU are no longer a constraint for the compiler. So most of the theoretical optimizations from books are now possible.</p>

<p>The next steps of the language is the support of multi-core programming, which is part of 0x standard effort.</p>
",0
537304,536439,78,"<p>Here's how I think things have evolved.</p>

<p>The first generation of C++ programmers were C programmers, who were in fact using C++ as C with classes.  Plus, the STL wasn't in place yet, so that's what C++ essentially was.</p>

<p>When the STL came out, that advanced things, but most of the people writing books, putting together curricula, and teaching classes had learned C first, then that extra C++ stuff, so the second generation learned from that perspective.   As another answer noted, if you're comfortable writing regular for loops, changing to use <code>std::for_each</code> doesn't buy you much except the warm fuzzy feeling that you're doing things the ""modern"" way.</p>

<p>Now, we have instructors and book writers who have been using the whole of C++, and getting their instructions from that perspective, such as Koenig &amp; Moo's Accelerated C++ and Stroustrup's new textbook.  So we don't learn <code>char*</code> then <code>std::strings</code>.  </p>

<p>It's an interesting lesson in how long it takes for ""legacy"" methods to be replaced, especially when they have a track record of effectiveness.</p>
",2
537221,536439,6,"<p>In my experience (Spanish University), unfortunately, the norm is to not to consider languages in itself. They use the easiest languages to teach programming (i.e. Java), because it is supposed to be easy for teachers and students, and then they use C for the OS classes and such.</p>

<p>C++ is introduced very slightly (at any rate at any course), just to provide a C with classes. They don't get into boost or even STL. I think keeping up with all the characteristics and way of thinking of C++ is costly for both teachers and students. How many of C++ programmers here know enough of all the Boost libraries to use them to give a better solution or to design it? One has to have an interest in keeping up with all the new libraries and idioms.</p>

<p>However, as I said, it seems that programming in general (and programming languages in particular) are not taken too seriously, as it seems to be a temporal assignment when they start a job, then forget how to program as they go up in the enterprise tree. Many enterprises here, and the University itself, have the feel that programming can be done by anybody.</p>

<p>If you follow this philosophy, then for most people I know, C++ will always be ""C with classes"".</p>

<p>Regards,</p>
",2
537382,536439,6,"<p>In my experience it vastly depends on the age of the software product/project. Most new projects that I am aware of do use modern C++ (RAII, STL, Boost). However, there are many C++ projects that are more than 10 years old, and you don't see modern C++ there.</p>

<p>Also, keep in mind that some of the most popular STL implementations were pretty much broken until maybe 5 years ago (MSVC &lt; 7.0 and GNU &lt; 3.00)</p>
",0
537770,536439,9,"<p>In my C++ jobs, I've found the modern features to be increasingly used, and more people asked me about them in phone screenings and interviews.  As far as I can tell, they're catching on.</p>

<p>I learned C++ originally as something like C with Classes; although the language had advanced far beyond that, the books I read and people I worked with were firmly stuck on ""old C++"".  RAII something people would think about, rather than automatically do, and I remember reading some of the early articles on the problems of exception safety.</p>

<p>As pointed out, there's new books out now.  Many of the old ones are still relevant, but they increasingly seem to be full of explaining why obviously bad ideas are bad.  (Similarly, it's hard for modern readers to understand how revolutionary Freud's ideas of an unconscious mind were, since it's now conventional wisdom.)</p>

<p>Stroustrup just came out with a textbook, <em>Programming:  Principles and Practice Using C++</em>.  I bought it because I haven't yet failed to learn good stuff from a book of Stroustrup's, but haven't gotten past the first few chapters.  So far, all I can say is that I approve of the way he's starting out, and it's at least a good introduction to how C++ should be used.</p>
",2
536456,536439,2,"<p>The best book for learning C++. ""Accelerated C++"" by Koenig &amp; Moo, teaches what you describe as modern C++, so I guess most people these days are using it. For those of us that have been using C++ for quite a while (since the mid 80s in  my case), modern C++ is a great relief from the tedious tasks of writing our own arrays, strings, hash tables (repeat ad nauseam).</p>
",1
536457,536439,56,"<p>Absolutely yes. To me if you're not programming C++ in this ""Modern C++"" style as you term, then there's no point using C++! You might as well just use C. ""Modern C++"" should be the only way C++ is ever programmed in my opinion, and I would expect that everyone who uses C++ and has programmed in this ""Modern"" fashion would agree with me. In fact, I am always completely shocked when I hear of a C++ programmer who is unaware of things such as an auto_ptr or a ptr_vector. As far as I'm concerned, those ideas are basic and fundamental to C++, and so I couldn't imagine it any other way. </p>
",8
536466,536439,12,"<p>I think you just had a bad experience starting off.</p>

<p>You need to get yourself <a href=""http://www.aristeia.com/"" rel=""noreferrer"">Scott Meyers</a> Effective C++ books. I started on C++ in anger in 1999, my team lead made me sit and read Effective C++ and More Effective C++ before I was allowed to check in ANY code.</p>

<p>Most of his advice is on the lines of ""Don't use this <em>feature</em>, but if you must, keep <em>this</em> in mind""</p>

<p>If you follow his advice you'll write good or ""Modern"" C++. </p>

<p>He has a book on STL now too, but that I haven't read.</p>
",1
536472,536439,6,"<p>I wouldn't say that std::vector qualifies as ""modern"" these days. It is really basic.</p>

<p>Generally my impression is that people have gained some experience with modern C++ style and sobered up a little. Just to take a simple example, STL for_each was interesting but in practice it does not add a terrible lot of value over a plain C loop. It is harder to debug and sometimes does not provide the best performance. Also the constructs for functional programming in current STL are generally very cumbersome, especially if you got experience from a real functional language like ML.</p>
",5
536482,536439,16,"<p>I am one of these guys who learned how to work with the STL and heard a lot about RAII and good C++ programming practices from day 1. Looks like some of the most recommended books for learning C++ today (like Accelerated C++ and the Effective C++ series) focus on using STL tools instead of rolling up your own stuff, and also give lots of ""rules"" for effective (or ""modern"") programming.</p>

<p>But talking with friends I also noted some companies still work with ""C with Classes"", not ""Modern C++"". Maybe the culture proposed by the authors and users of the ""Modern C++"" will prevail someday :)</p>
",1
1337597,536439,8,"<p>While working on the project I am presently involved with, there's a lot of C++ code which has evolved over a significant period of time (over 10 years now). The evolution you speak of is clearly visible there: the older code is often ""C with classes"" - raw pointers, <code>char*</code> strings and use of associated C functions, arrays etc; newer code uses ATL smart pointers and such to manage resources, but still sticks to hand-coded loops most of the time, and iterator is a rare sight; and the newest one is chock-full of STL containers, algorithms, <code>shared_ptr</code> (including custom deleters to manage handles etc), heavily genericized function and class templates, and so on. Most traditional ""C with classes"" coding techniques, such as raw unencapsulated pointers with manual lifetime management, are very much frowned upon in code reviews these days. Judging by this, it seems that your observation is accurate.</p>

<p>The most recent development seems to be a fad for C++0x lambdas - which has a positive side in that it also tilts the balance in favor of using standard algorithms over hand-coded loops, since now you can have all your code inline with algorithms as well.</p>
",0
1337642,536439,3,"<p>Many teams I've been on and heard about consider the big ""are we using exceptions?"" question.  This is code for ""are we using modern C++?""</p>

<p>Once you aren't using exceptions, you are precluded from using the full power of the language and its libraries.</p>

<p>But many older codebases are exception-less, and it is perceived to be difficult to shoehorn exceptions into a codebase that doesn't expect them, or into a team that doesn't know how to use them, so the answer in such cases is often 'no.'</p>

<p>In my experience, modern C++ needs someone who is passionate about it on the team, who can't stand the sight of anything less, to push for it.  It also needs to overcome the objections of those who want it to be more like the legacy code.</p>

<p>While I don't think that old-C++ codebases are going away very quickly, I do believe there are more of these passionate people in the world than there were five years ago.  They face the same uphill battle they faced five years ago, but they are more likely to find kindred spirits.</p>
",0
294636,294554,2,"<p>they merged with frobbs a couple years ago: <a href=""http://www.ddj.com/cpp/cuj.jhtml"" rel=""nofollow noreferrer"">http://www.ddj.com/cpp/cuj.jhtml</a>. you might find something there.</p>
",0
399742,399740,6,"<p>You are looking for <a href=""http://en.wikipedia.org/wiki/Factory_method_pattern"" rel=""nofollow noreferrer"">http://en.wikipedia.org/wiki/Factory_method_pattern</a></p>
",0
399748,399740,2,"<p>First, you should use a factory or factory method as litb has mentioned.</p>

<p>But in addition to that I advise you to use an enum, or at least symbolic constants to determine which class to instantiate. This is much easier to read, and it allows you to build safeguards for unexpected values.</p>
",0
625440,625333,4,"<p>Few ideas:</p>

<ul>
<li><p>Unfortunately you will have to use macros to avoid some platform specific or compiler specific issues. You can look at the headers of Boost libraries to see that it can quite easily get cumbersome, for example look at the files:</p>

<ul>
<li><a href=""http://www.boost.org/doc/libs/1_38_0/boost/config/compiler/gcc.hpp"" rel=""nofollow noreferrer"">boost/config/compiler/gcc.hpp</a></li>
<li><a href=""http://www.boost.org/doc/libs/1_38_0/boost/config/compiler/intel.hpp"" rel=""nofollow noreferrer"">boost/config/compiler/intel.hpp</a></li>
<li><a href=""http://www.boost.org/doc/libs/1_38_0/boost/config/platform/linux.hpp"" rel=""nofollow noreferrer"">boost/config/platform/linux.hpp</a></li>
<li>and so on</li>
</ul></li>
<li><p>The integer types tend to be messy among different platforms, you will have to define your own typedefs or use something like <a href=""http://www.boost.org/doc/libs/1_38_0/libs/integer/cstdint.htm"" rel=""nofollow noreferrer"">Boost cstdint.hpp</a></p></li>
<li><p>If you decide to use any library, then do a check that the library is supported on the given platform</p></li>
<li><p>Use the libraries with good support and clearly documented platform support (for example Boost)</p></li>
<li><p>You can abstract yourself from some C++ implementation specific issues by relying heavily on libraries like Qt, which provide an ""alternative"" in sense of types and algorithms. They also attempt to make the coding in C++ more portable. Does it work? I'm not sure.</p></li>
<li><p>Not everything can be done with macros. Your build system will have to be able to detect the platform and the presence of certain libraries. Many would suggest <code>autotools</code> for project configuration, I on the other hand recommend <code>CMake</code> (rather nice language, no more <code>M4</code>)</p></li>
<li><p>endianness and alignment might be an issue if you do some low level meddling (i.e. <code>reinterpret_cast</code> and <strike>friends</strike> things alike (friends was a bad word in C++ context)).</p></li>
<li><p>throw in a lot of warning flags for the compiler, for gcc I would recommend at least <code>-Wall -Wextra</code>. But there is much more, see the documentation of the compiler or this <a href=""https://stackoverflow.com/questions/399850/best-compiler-warning-level-for-c-c-compilers"">question</a>.</p></li>
<li><p>you have to watch out for everything that is implementation-defined and implementation-dependend. If you want the truth, only the truth, nothing but the truth, then go to ISO standard.</p></li>
</ul>
",1
625343,625333,4,"<p>Well, the variable sizes one mentioned is a fairly well known issue, with the common workaround of providing typedeffed versions of the basic types that have well defined sizes (normally advertised in the typedef name). This is done use preprocessor macros to give different code-visibility on different platforms. E.g.:</p>

<pre><code>#ifdef __WIN32__
typedef int int32;
typedef char char8;
//etc
#endif
#ifdef __MACOSX__
//different typedefs to produce same results
#endif
</code></pre>

<p>Other issues are normally solved in the same way too (i.e. using preprocessor tokens to perform conditional compilation)</p>
",2
625351,625333,2,"<p>A good solution is to use common headings that define typedeff'ed types as neccessary.</p>

<p>For example, including sys/types.h is an excellent way to deal with this, as is using portable libraries.</p>
",0
625359,625333,3,"<p>The most obvious implementation dependency is size of integer types. There are many ways to handle this. The most obvious way is to use typedefs to create ints of the various sizes:</p>

<pre><code> typedef signed   short  int16_t;
 typedef unsigned short  uint16_t;
</code></pre>

<p>The trick here is to pick a convention and stick to it. Which convention is the hard part: INT16, int16, int16_t, t_int16, Int16, etc. C99 has the stdint.h file which uses the int16_t style. If your compiler has this file, use it.</p>

<p>Similarly, you should be pedantic about using other standard defines such as size_t, time_t, etc.</p>

<p>The other trick is knowing when not to use these typedef. A loop control variable used to index an array, should just take raw int types so the compile will generate the best code for your processor. for (int32_t i = 0; i &lt; x; ++i) could generate a lot of needless code on a 64-bite processor, just like using int16_t's would on a 32-bit processor.</p>
",2
625380,625333,1,"<p>One of the key ways of avoiding dependancy on particular data sizes is to read &amp; write persistent data as text, not binary. If binary data must be used then all read/write operations must be centralised in a few methods and approaches like the typedefs already described here used.</p>

<p>A second rhing you can do is to enable all your your compilers warnings. for example, using the <strong>-pedantic</strong> flag with g++ will warn you of lots of potential portability problems.</p>
",2
625381,625333,0,"<p>If you're concerned about portability, things like the size of an int can be determined and dealt with without much difficulty. A lot of C++ compilers also support C99 features like the int types: <code>int8_t</code>, <code>uint8_t</code>, <code>int16_t</code>, <code>uint32_t</code>, etc. If yours doesn't support them natively, you can always include <code>&lt;cstdint&gt;</code> or <code>&lt;sys/types.h&gt;</code>, which, more often than not, has those <code>typedef</code>ed. <code>&lt;limits.h&gt;</code> has these definitions for all the basic types.</p>

<p>The standard only guarantees the minimum size of a type, which you can always rely on: <code>sizeof(char) &lt; sizeof(short) &lt;= sizeof(int) &lt;= sizeof(long)</code>. <code>char</code> must be at least 8 bits. <code>short</code> and <code>int</code> must be at least 16 bits. <code>long</code> must be at least 32 bits.</p>

<p>Other things that might be implementation-defined include the ABI and name-mangling schemes (the behavior of <code>export ""C++""</code> specifically), but unless you're working with more than one compiler, that's usually a non-issue.</p>
",0
625488,625333,2,"<p>There are two approaches to this:</p>

<ul>
<li>define your own types with a known size and use them instead of built-in types (like typedef int int32 #if-ed for various platforms)</li>
<li>use techniques which are not dependent on the type size</li>
</ul>

<p>The first is very popular, however the second, when possible, usually results in a cleaner code. This includes:</p>

<ul>
<li>do not assume pointer can be cast to int</li>
<li>do not assume you know the byte size of individual types, always use sizeof to check it</li>
<li>when saving data to files or transferring them across network, use techniques which are portable across changing data sizes (like saving/loading text files)</li>
</ul>

<p>One recent example of this is writing code which can be compiled for both x86 and x64 platforms. The dangerous part here is pointer and size_t size - be prepared it can be 4 or 8 depending on platform, when casting or differencing pointer, cast never to int, use intptr_t and similar typedef-ed types instead.</p>
",0
412636,412611,5,"<p>If you're looking for a type with values {true, false, null}, that type is not bool. However, <code>boost::optional&lt;bool&gt;</code> is such a type. In the same way, <code>boost::optional&lt;int&gt; </code> can hold any int, or no int at all.</p>
<p>[edit]
Or <code>std::optional</code>, since C++17.</p>
",0
412640,412611,1,"<p>It's the c++ way not to pay for anything you don't use and default initialization and the ability to have uninitialized bool is something that many people won't need.</p>

<p>If you really want this kind of behavior you can build a nullable version of the type you are working with.
Something along the lines:</p>

<pre><code>class NullBool {
  bool m_null;
  bool m_value;
  public:
  NullBool() : m_null(true) {}
  NullBool(bool value) : m_null(false), m_value(value) {}
  void isNull() const {
    return m_null;
  }
  void value() const {
    return m_value;
  }
  ...
  // lots of operations
  ...
};
</code></pre>

<p>This should probably be built as a template so it works for more types out of the box. And since it's your own type you can easily make the default constructor to make it null by default.</p>
",2
412614,412611,10,"<p>You can do </p>

<pre><code>struct a {
    a():field1(), field2(), field3() { }
    int field1;
    bool field2;
    bool field3;
};
</code></pre>

<p>And all fields will be zero and false respectively. If you want to say that the fields have an indeterminate value, i'm afraid you have to use other techniques. One is to use <a href=""http://www.boost.org/doc/libs/1_35_0/libs/optional/doc/html/index.html"" rel=""noreferrer""><code>boost::optional</code></a>:</p>

<pre><code>struct a {
    a():field1(int()), field2(bool()) { }
    optional&lt;int&gt; field1;
    optional&lt;bool&gt; field2;
    optional&lt;bool&gt; field3;
};
</code></pre>

<p>Leaves field3 indeterminate. Access the values with <code>*field_name</code>. Test for a none value with <code>field == boost::none</code> or <code>if(field) { ... }</code>. </p>
",0
412616,412611,3,"<p>A boolean has two states. That's what makes it a boolean. So, in any strongly typed language, a boolean is either true or false.</p>

<p>An integer in c/c++ (and java) is the direct binary representation of a number. You can assign one value of that number to mean ""this number has no value"", but this does not make sense in all situations - and if the language were to take that into account, every math operation would have to be preceded by a check - it would really slow things down.</p>

<p>Bottom line: If you want a weak type system, use another language.</p>
",0
412619,412611,2,"<p>You seem to want to be able to say the fields are in an undefined state.</p>

<p>This goes against the principles of a strongly types language (such as C++) so you are out of luck.<br>
If you want to check if something has been defined of not you need to explicitly track it yourself. You could potentially use pointers to solve your problem but I don't personally think that would be a good idea.</p>

<p>Maybe if you tried to explain the real problem you are trying to solve we could provide better advice.</p>
",0
1486146,1486141,0,"<p>It depends on the purpose of the array. If you plan on showing the values in a list (for a user selection, perhaps) the array would be the most efficient way of storing them. If you plan on frequently looking up values by their <code>enum</code> key, you should look into a more efficient data structure like a map.</p>
",2
1486155,1486141,0,"<p>There is no need to write a loop. You can use the enum value as index for the array.</p>
",1
1486163,1486141,3,"<p>If the <code>enum</code> values are contiguous starting from <code>0</code>, use an array with the enum as index. </p>

<p>If not, this is what I usually do: </p>

<pre><code>const char* find_language(Language lang)
{
  typedef std::map&lt;Language,const char*&gt; lang_map_type;
  typedef lang_map_type::value_type lang_map_entry_type;

  static const lang_map_entry_type lang_map_entries[] = { /*...*/  }
  static const lang_map_type lang_map( lang_map_entries
                                     , lang_map_entries + sizeof(lang_map_entries)
                                                        / sizeof(lang_map_entries[0]) );
  lang_map_type::const_iterator it = lang_map.find(lang);
  if( it == lang_map.end() ) return NULL;
  return it-&gt;second;
}
</code></pre>

<p>If you consider a map for constants, always also consider using a vector. </p>

<p>Function-local statics are a nice way to get rid of a good part of the dependency problems of globals, but are dangerous in a multi-threaded environment. If you're worried about that, you might rather want to use globals: </p>

<pre><code>typedef std::map&lt;Language,const char*&gt; lang_map_type;
typedef lang_map_type::value_type lang_map_entry_type;

const lang_map_entry_type lang_map_entries[] = { /*...*/  }
const lang_map_type lang_map( lang_map_entries
                            , lang_map_entries + sizeof(lang_map_entries)
                                               / sizeof(lang_map_entries[0]) );

const char* find_language(Language lang)
{
  lang_map_type::const_iterator it = lang_map.find(lang);
  if( it == lang_map.end() ) return NULL;
  return it-&gt;second;
}
</code></pre>
",7
1486168,1486141,0,"<p>I would make an enum with sequential language codes</p>

<pre><code>enum { GERMAN=0, ENGLISH, SWAHILI, ENOUGH };
</code></pre>

<p>The put them all into array</p>

<pre><code>const char *langnames[] = {
    ""German"", ""English"", ""Swahili""
};
</code></pre>

<p>Then I would check if <code>sizeof(langnames)==sizeof(*langnames)*ENOUGH</code> in debug build.</p>

<p>And pray that I have no duplicates or swapped languages ;-)</p>
",1
1486239,1486141,0,"<p>If you want fast and simple solution , Can try like this    </p>

<pre><code>enum ELanguage {GERMAN=0, ENGLISH=1};

    static const string Ger=""GERMAN"";
    static const string Eng=""ENGLISH"";

    bool getLanguage(const ELanguage&amp; aIndex,string &amp; arName)
    {
        switch(aIndex)
        {
        case GERMAN:
            {
                arName=Ger;
                return true;
            }
        case ENGLISH:
            {
                arName=Eng;
            }
        default:
            {
                // Log Error
                return false;
            }
        }
    }
</code></pre>
",1
1486524,1486141,2,"<p>There are three basic approaches that I'd choose from. One is the switch statement, and it is a very good option under certain conditions. Remember - the compiler is probably going to compile that into an efficient table-lookup for you, though it will be looking up pointers to the case code blocks rather than data values.</p>

<p>Options two and three involve static arrays of the type you are using. Option two is a simple linear search - which you are (I think) already doing - very appropriate if the number of items is small.</p>

<p>Option three is a binary search. Static arrays can be used with standard library algorithms - just use the first and first+count pointers in the same way that you'd use begin and end iterators. You will need to ensure the data is sorted (using std::sort or std::stable_sort), and use std::lower_bound to do the binary search.</p>

<p>The complication in this case is that you'll need a comparison function object which acts like operator&lt; with a stored or referenced value, but which only looks at the key field of your struct. The following is a rough template...</p>

<pre><code>class cMyComparison
{
  private:
    const fieldtype&amp; m_Value;  //  Note - only storing a reference

  public:
    cMyComparison (const fieldtype&amp; p_Value) : m_Value (p_Value) {}

    bool operator() (const structtype&amp; p_Struct) const
    {
      return (p_Struct.field &lt; m_Value);
        //  Warning : I have a habit of getting this comparison backwards,
        //            and I haven't double-checked this
    }
};
</code></pre>

<p>This kind of thing should get simpler in the next C++ standard revision, when IIRC we'll get anonymous functions (lambdas) and closures.</p>

<p>If you can't put the sort in your apps initialisation, you might need an already-sorted boolean static variable to ensure you only sort once.</p>

<p>Note - this is for information only - in your case, I think you should either stick with linear search or use a switch statement. The binary search is probably only a good idea when...</p>

<ol>
<li>There are a lot of data items to search</li>
<li>Searches are done <em>very</em> frequently (many times per second)</li>
<li>The key enumerate values are sparse (lots of big gaps) - otherwise, switch is better.</li>
</ol>

<p>If the coding effort were trivial, it wouldn't be a big deal, but C++ currently makes this a bit harder than it should be.</p>

<p>One minor note - it may be a good idea to define an enumerate for the size of your array, and to ensure that your static array declaration uses that enumerate. That way, your compiler should complain if you modify the table (add/remove items) and forget to update the size enum, so your searches should never miss items or go out of bounds.</p>
",0
1491264,1486141,2,"<p>I think you have two questions here:</p>

<ul>
<li>What is the best way to store a constant global variable (with possible Multi-Threaded access) ?</li>
<li>How to store your data (which container use) ?</li>
</ul>

<p>The solution described by sbi is elegant, but you should be aware of 2 potential problems:</p>

<ol>
<li>In case of Multi-Threaded access, the initialization could be skrewed.</li>
<li>You will potentially attempt to access this variable after its destruction.</li>
</ol>

<p>Both issues on the lifetime of static objects are being covered in <a href=""https://stackoverflow.com/questions/335369/finding-c-static-initialization-order-problems#335746"">another thread</a>.</p>

<p>Let's begin with the <strong>constant global variable</strong> storage issue.</p>

<p>The solution proposed by sbi is therefore adequate if you are not concerned by 1. or 2., on any other case I would recommend the use of a Singleton, such as the ones provided by <a href=""http://loki-lib.sourceforge.net/index.php?n=Pattern.Singleton"" rel=""nofollow noreferrer"">Loki</a>. Read the associated documentation to understand the various policies on lifetime, it is very valuable.</p>

<p>I think that the use of an array + a map seems wasteful and it hurts my eyes to read this. I personally prefer a slightly more elegant (imho) solution.</p>

<pre><code>const char* find_language(Language lang)
{
  typedef std::map&lt;Language, const char*&gt; map_type;
  typedef lang_map_type::value_type value_type;

  // I'll let you work out how 'my_stl_builder' works,
  // it makes for an interesting exercise and it's easy enough
  // Note that even if this is slightly slower (?), it is only executed ONCE!
  static const map_type = my_stl_builder&lt;map_type&gt;()
                          &lt;&lt; value_type(GERMAN, ""German"")
                          &lt;&lt; value_type(ENGLISH, ""English"")
                          &lt;&lt; value_type(DUTCH, ""Dutch"")
                          ....
                          ;

  map_type::const_iterator it = lang_map.find(lang);
  if( it == lang_map.end() ) return NULL;
  return it-&gt;second;
}
</code></pre>

<p>And now on to the <strong>container type</strong> issue.</p>

<p>If you are concerned about performance, then you should be aware that for small data collection, a vector of pairs is normally more efficient in look ups than a map. Once again I would turn toward Loki (and its AssocVector), but really I don't think that you should worry about performance.</p>

<p>I tend to choose my container depending on the interface I am likely to need first and here the map interface is really what you want.</p>

<p>Also: why do you use 'const char*' rather than a 'std::string'? </p>

<p>I have seen too many people using a 'const char*' like a std::string (like in forgetting that you have to use strcmp) to be bothered by the alleged loss of memory / performance...</p>
",1
418155,418121,6,"<p>foo takes vec by reference-to-const, and you cannot change a const. So either remove the line that calls setBool, or if you really want to set the bool, change the argument type to std::vector&amp;.</p>

<p>Or to be more strict about the implementation... You see, these two functions exist:  </p>

<pre><code>T&amp; vector&lt;T&gt;::operator[](int);  
T const&amp; vector&lt;T&gt;::operator[](int) const;  
</code></pre>

<p>When you call ""vec[i]"" on a const object, only the second one is valid, so it gets selected. But this overload obviously returns T const&amp;, and that's the thing you can't change.</p>
",3
418165,418121,0,"<p><code>foo</code> takes a <code>const vector &amp;</code>, meaning that the contents of the vector cannot be modified.  This, in turn, means that you are not allowed to call a non-const member function on any of the elements of <code>vec</code>, and <code>setBoo</code>.</p>
",0
418172,418121,0,"<p>The object probably is const. Although the vector contains ABCs and not const ABCs, the vector itself is const, so when you call operator[] on it, the const version of the operator is used. The const version of operator[] on a vector returns a vector::const_reference. So, from what I can tell you are trying to call a non-const method on a const ABC&amp;.</p>
",0
418193,418121,0,"<p>As another workaround, you could store pointers to ABC objects in the vector and it will work fine - albeit at the extra cost of managing the cleanup. In this case you are not modifying the contents of the vector since the vector is only holding pointers.</p>
",0
806718,806561,3,"<p>You should also look at defining a virtual destructor in your Interface if you might be deleting using an Interface or Base pointer.</p>

<p>Without a virtual destructor you will have problems if you do something like:</p>

<pre><code>Base *b = new Class2();
delete b;
</code></pre>
",3
806604,806561,5,"<p>Class2 inherits from an abstract class (Interface2) but does not implement the pure virtual method, so it remains as an abstract class.</p>
",5
806644,806561,3,"<p><strong>Regarding <code>Class</code>:</strong> All you need to do is derive <code>Class</code> from <code>Base</code> -- the fact that it implements <code>Interface</code> is implied, and in fact, inescapable:</p>

<pre><code>class Class: public Base  // virtual inheritance is unnecessary here
{
};
</code></pre>

<p><code>Class</code> will inherit <code>method()</code> from <code>Base</code> as desired.</p>

<p><strong>Regarding <code>Class2</code>:</strong></p>

<p><strong>Disclaimer: Negative result ahead</strong></p>

<p>Based on your comment on <a href=""https://stackoverflow.com/questions/806561/interfaces-in-c/806604#806604"">Tom's answer</a>, I <strong>thought I had</strong> the answer for <code>Class2</code>:</p>

<pre><code>// concrete class - specialised
class Class2: public Interface2, public Base
{
public:
    using Base::method;    // ""Imports"" all members named ""method"" from Base
};
</code></pre>

<p>But actually, this doesn't work.  Grovelling through the C++ standard reveals that 
section 7.3.3, paragraph 14 explains that <code>using</code> can't be used to resolve ambiguous accesses to inherited members:</p>

<blockquote>
  <p>... [Note: because a using-declaration designates a base class member (and not a member subobject or a member function of a base class subobject), a using-declaration cannot be used to resolve inherited member ambiguities. ...]</p>
</blockquote>

<p>It seems that the only way to get the desired behaviour in <code>Class2</code> is to manually forward the method:</p>

<pre><code>// concrete class - specialised
class Class2: public Interface2, public Base
{
public:
     virtual int method() { return Base::method(); }
};
</code></pre>

<p><strong>Regarding <code>virtual</code> inheritance:</strong> You <em>don't</em> need it for <code>Class</code>'s declaration, but you probably <em>do</em> need it for <code>Interface2</code>'s declaration to ensure that <code>Class2</code> only has a single subobject of type <code>Interface</code> -- as it stands, every <code>Class2</code> object has two subobjects of this type.  (Although that won't cause problems if <code>Interface</code> is in fact a pure interface, lacking member variables.)  If it helps, draw a diagram: every time a base class appears without the keyword <code>virtual</code>, it appears as a distinct object; all base classes that appear with the keyword <code>virtual</code> are condensed into one object.</p>

<p><strong>[UPDATE: <a href=""https://stackoverflow.com/questions/806561/interfaces-in-c/807643#807643"">markh44's excellent answer</a> shows that the above approach (of making <code>Interface2</code> inherit <em>virtually</em> from <code>Interface</code>) will in fact allow <code>Class2</code> to automatically inherit the implementation of <code>method()</code> from <code>Base</code>!  Problem solved!]</strong></p>
",2
806826,806561,4,"<p>Based on this comment</p>

<pre>
If the method is not reimplemented in Class2 or Class (it is not in 
this case) Base::method() will be called. Otherwise the reimplementation 
will be called. There is an interface hierarchy with a common base 
dumb implementation. 

¨C danatel 16 mins ago
</pre>

<p>That's not what you got, you don't have a common base, you've got </p>

<pre><code>Interface -&gt; Interface2 -&gt; Class2
Interface -&gt; Base -&gt; Class2
</code></pre>

<p>The interface is not 'merged' in the derivation tree, interface2 does not inherit virtually from interface, so it'll have its own interface super class.
It's like the pure virtual <code>method()</code> exists twice in Class2, once implemented via Class, and once not-implemented.</p>

<p>And even if you had inherited virtually, the common base (Interface) still would not have an implementation</p>

<p>If Base contains trivial operations that should be usuable in the whole hierarchy, then why not have Base as your startpoint? (even if still pure virtual with an implementation). </p>

<p>If this was just a very simple example to make the question short, something like the <a href=""http://en.wikipedia.org/wiki/Bridge_pattern"" rel=""nofollow noreferrer"">Bridge Pattern</a> might be more usefull. But it's hard to guide you further without knowing more.</p>
",3
806855,806561,1,"<p>In general, you should avoid the diamond inhertance pattern:</p>

<pre><code>            Interface
            /      \
          Base   Interface2
            \      /
             Class2
</code></pre>

<p>This will cause you call kinds of grief down the road if you're not careful. Ambiguity will bite you.</p>

<p>In your specific instance there's no need for Interface2 to inherit from Interface. Interface2 doesn't need to specify ""method"" since it's abstract. Remove the inheritance between Interface and Interface2 to break the diamond. Then you're hierarchy looks like:</p>

<pre><code>        Interface                Interface  Interface2
           |                          |       |
          Base                      Base      |
           |                           \      /
         Class                          Class2
</code></pre>

<p>And your implementation looks like:</p>

<pre><code>// concrete class - not specialised - OK
class Class: public Base
{
};

// concrete class - specialised
class Class2: public Base, public Interface2
{
    virtual int method() {return 35;}

    virtual void Inteface2Method { ... }
};
</code></pre>
",1
807093,806561,2,"<p><a href=""http://www.velocityreviews.com/forums/showpost.php?p=3783768&amp;postcount=6"" rel=""nofollow noreferrer"">This answer</a> in a different forum seems to tackle the exact problem you mention.</p>
",1
807643,806561,4,"<p>Heh heh, this problem tickles something buried deep in my head somewhere.  I can't quite put my finger on it but I think it's to do with defining an interface heirarchy and then inheriting both an interface and an implementation.  You then avoid having to implement all functions with by forwarding calls to a base class.  I think.</p>

<p>I think this simple example shows the same thing, but is maybe a bit easier to understand because it uses things that can be easily visualized: (please forgive the struct laziness)</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

struct Vehicle
{
    virtual void Drive() = 0;
};

struct VehicleImp : virtual public Vehicle
{
    virtual void Drive() 
    {
        cout &lt;&lt; ""VehicleImp::Drive\n"";
    }
};

struct Tank : virtual public Vehicle
{ 
    virtual void RotateTurret() = 0;
};

struct TankImp : public Tank, public VehicleImp
{
    virtual void RotateTurret() 
    {
        cout &lt;&lt; ""TankImp::RotateTurret\n"";
    }
    // Could override Drive if we wanted
};

int _tmain(int argc, _TCHAR* argv[])
{
    TankImp myTank;
    myTank.Drive();         // VehicleImp::Drive
    myTank.RotateTurret();  // TankImp::RotateTurret
    return 0;
}
</code></pre>

<p>TankImp has essentially inherited the Tank interface and the Vehicle implementation.</p>

<p>Now, I'm pretty sure this is a well known and acceptable thing in OO circles (but I don't know if it has a fancy name), so the dreaded diamond thing is ok in this case, and you can safely suppress the dominance warning because it's what you want to happen in this case.</p>

<p>Hope that somehow helps point you in the right direction!</p>

<p>BTW, your code didn't compile because you hadn't implemented the pure virtual ""method"" in Class2.</p>

<p><strong>EDIT:</strong></p>

<p>Ok I think I understand your problem better now and I think the mistake is in Interface2.  Try changing it to this:</p>

<pre><code>// specialized interface
class Interface2: public virtual Interface // ADDED VIRTUAL
{
public:
    //virtual int method() = 0;   COMMENTED THIS OUT
    // some other methods here
};
</code></pre>

<p>Interface2 should not have the pure virtual defintion of method, since that is already in Interface.</p>

<p>The inheritance of Interface needs to be virtual otherwise you will have an ambiguity with Base::method when you derive from Interface2 and Base in Class2.</p>

<p>Now you should find it will compile, possibly with dominance warnings, and when you call c2.method(), you get 27.</p>
",3
365206,365198,2,"<p>Put a <code>typename</code> before the declaration:</p>

<pre><code>typename BST&lt;DataType&gt;::BinNodePointer locptr = myRoot;
</code></pre>

<p>The point is that due to potential template specialization, the compiler cannot know that the dependent identifier <code>BinNodePointer</code> identifies a type.</p>
",0
992445,992435,4,"<p>When the b object gets pushed onto the vector a copy is made, but not by the <code>operator=()</code> you have - the compiler generated copy constructor is used.</p>

<p>When the main() goes out of scope, the <code>b</code> object is destroyed and the copy in the vector is destroyed.</p>

<p>Add an explicit copy constructor to see this:</p>

<pre><code>MyClass( MyClass const&amp; other) {
    cout &lt;&lt; ""copy ctor\n"";
};
</code></pre>
",6
992458,992435,3,"<p>If you want to log all copies and constructions you should add an explicit copy constructor so that the compiler doesn't create one for you.</p>

<pre><code>MyClass( const MyClass&amp; )
{
    cout &lt;&lt; ""Copy constructor\n"";
}
</code></pre>

<p>You can, in your copy constructor, call your assignment operator. It is a reasonably common way of implementing things, however with your definition of operator=, this may have serious problems.</p>

<p>You have an unconventional implementation of operator=. operator= should return a <em>reference</em> to the class on which it is called (to enable proper chaining), but you return a new class instance by value. This means that if you tried to call operator= from your copy constructor you may well end up with infinite recursion. Try this operator= instead:</p>

<pre><code>MyClass&amp; operator=( const MyClass&amp; )
{
    cout &lt;&lt; ""operator=\n"";
    return *this;
}
</code></pre>

<p>When defining an assignment operator you should always consider the possibility that the parameter and *this may refer to the same object and ensure that the definition of the operator won't have any unintended effects in this scenario.</p>
",6
186670,152387,0,"<p>The popular way to use C++ in the mobile space would involve learning Symbian OS development.</p>

<p><a href=""http://developer.symbian.com"" rel=""nofollow noreferrer"">http://developer.symbian.com</a></p>
",0
459950,459942,4,"<p>Hmmm, a std::string is not the same as a const char *.  I usually err on the side of using std::string because it is a class that has many additional capabilities that make it much easier to use.  </p>

<p>If performance is paramount and you are using const char * for efficiency, go that way.</p>
",0
459951,459942,2,"<p>The first example requires less overhead for managing the string (i.e., just a pointer to the TEXT section). Also, the second method may require a heap allocation as well to copy the string literal to the std:string class buffer. So, you would end up with two copies of the data.</p>
",0
459952,459942,1,"<p>The second version has the advantage that it comes with a pre-calculated length and the other benefits of a fleshed out string class.  The first has the advantage that the only initialization is just assigning a pointer to static data already loaded in the executable image, where the second one has to initialize the string from that same pointer.</p>
",2
459970,459942,57,"<p>Usually you should prefer <code>std::string</code> over plain char pointers. Here, however, the char pointer initialized with the string literal has a significant benefit. </p>

<p>There are two initializations for static data. The one is called static initialization, and the other is called dynamic initialization. For those objects that are initialized with constant expressions and that are PODs (like pointers), C++ requires that their initialization happens at the very start, before dynamic initialization happens. Initializing such an std::string will be done dynamically.</p>

<p>If you have an object of a class being a static object in some file, and that one needs to access the string during its initialization, you can rely on it being set-up already when you use the <code>const char* const</code> version, while using the <code>std::string</code> version, which isn't initialized statically, you don't know whether the string is already initialized - because the order of initialization of objects across translation unit boundaries is not defined. </p>
",4
459986,459942,3,"<p>I tend to favor std::string's over char *'s when doing C++.  I prefer std::string mainly for its built in capabilities as well as convenience and safety of not having to deal with pointers.</p>

<p>However, as others have mentioned, the const char * version may be favorable if you are overly concerned about performance.  I seem to recall that someone smart once stated that premature optimization is the root of all evil (or some such).  :)</p>
",0
460034,459942,2,"<p>In large projects involving several platforms with different compilers and libraries, many teams, and lots of people we have repeatedly run into problems with static std::strings. On some platforms the std:string implementation isn't thread safe. On one platform the compiler optimized code skipped initializing a local std:string form the global static const. After chasing a few of these problems we only allow global static consts for built in types.</p>
",0
460056,459942,1,"<p>First of all, if wouldn't use a char*.  If you want an ASCIIZ string, define one of them directly:</p>

<p><code>const char Test::str[] = ""mystr"";</code></p>

<p>For the most part, that's what I'd use.  Why waste time and memory for the overhead of  string class.  </p>

<p>Note that ""sizeof(Test::str)"" will accurately give you the length of the array, which is the length of the string, including the terminating NUL (strlen(str)+1).</p>
",2
1714929,1714874,0,"<p>Ya definately it should work ..</p>

<p>since string text = erase_whitespace(string(""this is a test"")) </p>

<p>is converted to following code by compiler :</p>

<p>string temp(""this is a test"");</p>

<p>string text = erase_whitespace(temp);</p>
",2
1714963,1714874,7,"<p>If you're using Visual C, then it would be better to do the following:</p>

<pre><code>string erase_whitespace (const string &amp;input)
{
  string output = input.erase (...);
  return output;
}
</code></pre>

<p>It may look worse but the compiler, when building an optimised version, can utilise <a href=""http://msdn.microsoft.com/en-us/library/ms364057%28VS.80%29.aspx"" rel=""noreferrer"">Named Return Value Optimisations</a> which eliminates the overhead of returning by value (i.e. eliminates the copy constructors involved in returning by value). So, not only does it look right, it is probably more efficent.</p>
",4
1714967,1714874,0,"<p>I concur with Mike, but let me also mention that I don't think passing references to <code>string</code> around is a good idea in the first place. I'm pretty sure the string class is light-weight to pass by value since it stores the actual character array by reference internally.</p>
",2
1714974,1714874,9,"<p>From ¡ì 12.2.3 of the C++ 2003 standard (draft)</p>

<blockquote>
  <p>Temporary objects are destroyed as the last step in evaluating the full-expression (1.9) that (lexically) contains the point where they were created.</p>
</blockquote>

<p>¡ì 12.2.4:</p>

<blockquote>
  <p>There are two contexts in which temporaries are destroyed at a different point than the end of the full- 
  expression. ...</p>
</blockquote>

<p>¡ì 12.2.5:</p>

<blockquote>
  <p>The second context is when a reference is bound to a temporary. The temporary to which the reference is 
  bound or the temporary that is the complete object to a subobject of which the temporary is bound persists 
  for the lifetime of the reference except as specified below. ... A temporary bound to a reference 
  parameter in a function call (5.2.2) persists until the completion of the full expression containing the call.</p>
</blockquote>

<p>¡ì8.5.3.5 is what determines when the reference must be a const type. It is possible for a temporary to be bound to a non-const reference if the temporary is an instance of a class that has a conversion operator that returns an appropriate reference (that's a mouthful). An example might be easier to understand:</p>

<pre><code>class Foo {
    ...
    operator Bar&amp;() const;
...
void baz(Bar &amp;b);
...
    baz(Foo()); // valid
    baz(Bar()); // not valid
</code></pre>

<p>The last line isn't valid because of ¡ì 12.3.2.1, which states ""A conversion function is never used to convert [an ...] object to the [...] same object type (or a reference to 
it)"". You might be able to make it work using casting via an ancestor of Bar and a virtual conversion function.</p>

<p>An assignment is an expression (¡ì 5.17), thus the full-expression (¡ì 1.9.12) in your code is the assignment. This gives the following sequence (forgetting for the moment that a temporary string probably can't be bound to a non-const reference):</p>

<ol>
<li>A temporary string is created</li>
<li>The temporary is bound to the <code>string&amp; text</code> argument of <code>erase_whitespace</code></li>
<li><code>erase_whitespace</code> does its thang.</li>
<li><code>erase_whitespace</code> returns a reference to the temporary</li>
<li>The temporary is copied to <code>string text</code></li>
<li>The temporary is destroyed.</li>
</ol>

<p>So all is kosher in this case. The problem case, as Mike Seymour points out, would be assigning the result of <code>erase_whitespace</code> to a reference. Note that this likely wouldn't cause an immediate problem, as the area that stored the string probably contains the same data it did before the temporary was destroyed. The next time something is allocated on the stack or heap, however...</p>
",1
1714984,1714874,4,"<p>There are two questions here.</p>

<p>First, returning a reference is allowed of course, an example:</p>

<pre><code>struct myclass
{
    myclass&amp; foo()
    { cout &lt;&lt; ""myclass::foo()""; return *this }
    myclass&amp; bar()
    { cout &lt;&lt; ""myclass::bar()""; return *this }
};
...
myclass obj;
obj.foo().bar();
</code></pre>

<p>Second, passing a temporary object to a non-const reference is not allowed in C++ (discussed a lot on SO, just search for it):</p>

<pre><code>// passing string(""this is a test"") is wrong
string text = erase_whitespace(string(""this is a test""));
</code></pre>

<p>Unfortunately, some compilers (e.g. VC) allow this behavior, although it is not standard. If you turn your compiler warning level, you should get a warning at least.</p>
",0
1715072,1714874,2,"<p>I'm not sure how representative your example is, but your function looks fine, as long as you document that it modifies the passed-in object.  It's the calling that is bogus.  I don't see why you can't just write:</p>

<pre><code>std::string text(""this is a test"");
erase_whitespace(text);
cout &lt;&lt; test;
</code></pre>

<p>Which does <em>exactly</em> the same thing as what you would hope happens in your original code, i.e. make a <code>std::string</code>, strip its whitespace, and output it, while keeping the <code>std::string</code> object itself on the stack instead of in the heap, and minimizing copies. Of course, the <code>std::string</code>'s real storage is still on the heap, but you get the benefit of C++ disposing of the thing when the function or block is done.</p>

<p>I don't see why you need to save that line of code when it translates into no actual compiled code savings.</p>

<p>Now if you really needed this to, say, get stuffed into an equation, the usual thing to do is something like what Skizz wrote above (which works in regular C++, not just Visual C):</p>

<pre><code>std::string erase_whitespace (const string &amp;input)
{
    std::string output(input);
    output.erase (...);
    return output;
}
</code></pre>

<p>What's nice about this is that you can pass a <code>const char*</code> as the parameter, and C++ will automatically create a temporary <code>std::string</code> from it, since <code>std::string</code> has a constructor that takes a <code>const char*</code>.  Also, this doesn't mess with the passed-in object.  And as Skizz pointed out, optimizers like this kind of construct for return values.</p>
",1
1715086,1714874,0,"<p>Well in the situation you give it DOES work.  Your problem comes when you try and use the return as a reference.  ie:</p>

<pre><code>string&amp; text = erase_whitespace(string(""this is a test""));
</code></pre>

<p>This is perfectly valid VC++ code but you are now well into ""undefined"" territory.  Your main problem comes from the fact that anyone else using this code will not know, without looking at the implementation, that they cannot do this.</p>

<p>All in its a very dangerous bit off code that will only work on VC++.</p>

<p>Skizz's response gives you code that will work perfectly as a drop-in replacement and fix ALL the problem's mentioned above.</p>
",1
1715087,1714874,3,"<p>It looks wrong and it <em>is</em> wrong since non-const references are not allowed to bind to rvalues. In your case the compiler seems to accept it as an <em>extension</em>. You shouldn't rely on it.</p>

<p>As for possible chrashes: No this works fine with this compiler extension enabled. But this would not:</p>

<pre><code>string const&amp; dangling_reference =
    erase_whitespace(string(""this is a test""));
</code></pre>

<p>because the function returns a reference to a temporary object that will be destroyed. If you return by value instead, this line will be safe due to a special C++ rule (the life of the temporary will be extended).</p>

<p>Another disadvantage is that the function is mutating its argument. This might be an unexpected behaviour for a function which takes a string and also returns a string.</p>

<p>In case you wrote the function this way to improve performance you could try this one and measure it:</p>

<pre><code>string erase_whitespace(string text)
{
    text.erase(**etc.**);
    string ret; ret.swap(text);
    return ret;
}
</code></pre>

<p>If you have a good compiler that can elide unnecessary copies this should perform very well. To be specific, a compiler could elide the copy for accepting the parameter by value if the function is invoked with an rvalue. Your compiler might also be smart enough to apply NRVO (named return value optimization). If it is that smart, the following code</p>

<pre><code>string foo = erase_whithespace(""  blah  "");
</code></pre>

<p>will not call any copy ctor of std::string. Swapping is only done because no compiler is currently able to apply NRVO when a parameter is returned.</p>
",3
1714889,1714874,0,"<p>Better would probably be to explicitly make it a heap allocation w/pointer:</p>

<pre><code>string* erase_whitespace(string* text)
{
    text-&gt;erase(**etc.**);
    return text;
}

string* text = erase_whitespace(new string(""this is a test""));
cout &lt;&lt; *text;
delete text;
</code></pre>
",1
1714897,1714874,0,"<p>Your return parameter as well as the function parameter needs to const-reference. VC++ is non-compliant compiler in this regard and allows a temporary to be passed as a nonconst-reference.</p>
",1
438462,438444,0,"<p>std::auto_ptr implements ownership passing on copy and assignment, so there is nothing special you should do about it:</p>

<pre><code>std::auto_ptr&lt; T &gt; p = somePtr; // not p owns object, referenced by somePtr
std::auto_ptr&lt; T &gt; q = myObj.GetAutoPtr(); // not q owns object referenced by auto_ptr in myObj
</code></pre>

<p>But passing object ownership is not a good design practice, it conducts to leaks and object lifetime relative errors.</p>
",2
438464,438444,0,"<p>I don't remember std::auto_ptr being deprecated.<br>
Anybody have a link to the appropriate standards meeting where they discuss this?</p>

<p>A quick google found this:
<a href=""http://objectmix.com/c/113487-std-auto_ptr-deprecated.html"" rel=""nofollow noreferrer"">http://objectmix.com/c/113487-std-auto_ptr-deprecated.html</a></p>

<pre><code>&gt;&gt; In fact the latest publicly available draft lists auto_ptr in appendix
&gt;&gt; D, meaning that there is clear intent to formally deprecate it in the
&gt;&gt; next revision of C++. A new class named unique_ptr is going to provide
&gt;&gt; a replacement for auto_ptr, the main difference being that unique_ptr
&gt;&gt; uses rvalue-references instead of voodoo magic to properly achieve
&gt;&gt; move semantic.
&gt;
&gt; Is a reference implementation available? Is it too early to start using it?
&gt;

In order to use unique_ptr you need first to have a compiler which
properly supports rvalue references. These can be hard to find nowadays,
as the feature has not yet been standardized, although the situation is
quickly improving. For example GCC has very recently added the feature
in v4.3 (http://gcc.gnu.org/gcc-4.3/cxx0x_status.html). If you are lucky
enough to have one of those compilers, most probably they already ship a
version of unique_ptr (it's a sort of benchmark for the feature, you
know). In any case, you can find reference implementations on the
internet by just googling unique_ptr.
</code></pre>

<p>So it looks like their are moves to deprecate auto_ptr in favor of unique_ptr (which has the same semantics). But it needs a compiler that supports the proposed new features in the upcoming version of C++.</p>

<p>But there is still another meeting and thus vote to come so things could change before the standard is made concrete.</p>
",0
438480,438444,9,"<p><code>boost::interprocess</code> is a library for interprocess communication, so I wouldn't use it for different purposes.</p>

<p>As discussed on this forum:</p>

<p><a href=""http://objectmix.com/c/113487-std-auto_ptr-deprecated.html"" rel=""noreferrer"">http://objectmix.com/c/113487-std-auto_ptr-deprecated.html</a></p>

<p><code>std::auto_ptr</code> will be declared deprecated in the next version of the standard, where it will be recommended the usage of <code>std::unique_ptr</code>, which requires rvalue references and move semantics to be implemented (that's a fairly complicated feature).</p>

<p>Until the new standard is released, I would simply try to disable the warning if possible, or ignore it, for maximum portability.</p>

<p>If you want to already switch to the next language standard, it is possible since rvalue references have been implemented (see <a href=""http://russ.yanofsky.org/rref/"" rel=""noreferrer"">http://russ.yanofsky.org/rref/</a>), so also <code>std::unique_ptr</code> should be supported.</p>

<p>On of the advantages of the new semantics is that you can pass to the move constructor also a temporary or any rvalue; in other cases, this allows avoiding to copy (for instance) objects contained inside a <code>std::vector</code> (during reallocation) before destroying the original ones.</p>
",4
438487,438444,3,"<p><code>std::unique_ptr</code> is indeed the new recommended way.  With C++0x containers will become move-aware, meaning that they can handle types which are movable correctly (i.e., <code>std::vector&lt;std::auto_ptr&lt;x&gt; &gt;</code> does not work, but <code>std::vector&lt;std::unique_ptr&lt;x&gt;&gt;</code> will).</p>

<p>For <code>boost</code>, the <code>boost::interprocess</code> containers already support movable types, where <code>boost::interprocess::unique_ptr</code> is one of them.  They resemble movable types in pre C++0x by using some of the ""normal"" boost-template wizardry, and use r-value references where they are supported.</p>

<p>I didn't know about the <code>auto_ptr</code> dedicated deprecation, though, but I've not followed the new standard evolution closely.</p>

<p>(<strong>edit</strong>) The implementation of <code>boost::interprocess::unique_ptr</code> is indeed not a ""public"" smart-pointer like <code>boost::shared_ptr</code> or <code>boost::scoped_ptr</code>, but it is (see <a href=""http://www.boost.org/doc/libs/1_35_0/boost/interprocess/smart_ptr/unique_ptr.hpp"" rel=""nofollow noreferrer"">boost.interprocess's site</a>) not just for shared-memory, but can also be used for general-purpose.</p>

<p>However, I'm quite sure that if GCC deprecates the <code>auto_ptr</code> template, they already provide their own <code>unique_ptr</code> implementation (not much use to deprecate if you not have a viable alternative yet).</p>

<p>However, that all being said, if you're working on a C++0x platform, use <code>unique_ptr</code>, available from the compiler's lib, if not, stick with <code>auto_ptr</code>.</p>
",3
438791,438444,2,"<p>I agree where possible you should use types where the compiler assists in ownership transfer.</p>

<p>Where you don't have that choice of data types and are passing raw pointers, I follow the Taligent programming guidelines of naming methods which relinquish ownership as <strong>orphanBlah</strong> and parameters which take ownership as <strong>adoptBlah</strong>.</p>
",0
1025718,1025707,5,"<p>There's certainly no recommended way, as doing this is definitely not recommended at all in C++. This is one of those questions where the correct answer has to be ""Don't do that!""</p>

<p>The whole reason for using C++ instead of C is that you want to encapsulate the structure of data inside classes with sensible operations defined on them, instead of allowing the whole program to have knowledge of the internal layout of data structures.</p>

<p>That said, the <code>offsetof</code> technique you describe will work on plain old data objects, because they are no different to C structs.</p>
",3
1025728,1025707,3,"<p>Because <strong>ptr</strong> has no knowledge of its overlaying struct, I don't think there's an elegant way of getting back to <strong>myStruct</strong>.
I just recommend to not do this!</p>
",0
1025774,1025707,1,"<p>Your <code>reinterpret_cast</code> solution is the standard way to achieve what you want. The reason that it must involve at least one casts is that the operation that you want to perform is inherently unsafe. Obviously, not every pointer to an <code>int</code> is a pointer to the third member of a <code>myStruct</code> so there can't be a simple type-safe way to perform the conversion.</p>
",0
1025782,1025707,1,"<p>Your text &amp; example use a POD struct; your title talks about classes as well, however.  The answer below won't work for non-POD types.</p>

<p>For POD types, check out the <a href=""http://www.cplusplus.com/reference/clibrary/cstddef/offsetof/"" rel=""nofollow noreferrer"">""offsetof"" macro</a>....</p>

<p>Find the offset, use that &amp; pointer arithmetic to back up say a char * the base.</p>
",1
1026313,1025707,0,"<p>You can maybe use the fact, that when you make a cast from a pointer to a base class, that is not the only base class, the compiler will adjust the pointer so that it will point to the beginning of the super class. Therefore, if your ""c"" member would exist at the beginning of some base class, you could do a trick like:</p>

<pre><code>struct myStructBase1 { int a; };
struct myStructBase2 { int b; };
struct myStructBase3 { int c; };

struct myStruct : public myStructBase1,myStructBase2,myStructBase3 {
    int d;
};

int main() {
    myStruct my;

    int * bptr = &amp;my.b;
    int * cptr = &amp;my.c;
    // The only dirty part in the code...
    myStructBase2 * base2ptr = reinterpret_cast&lt;myStructBase2*&gt; (bptr);
    myStructBase3 * base3ptr = reinterpret_cast&lt;myStructBase3*&gt; (cptr);

    // In each (myStruct*) cast the pointers are adjusted to point to the super class.
    cout &lt;&lt; &amp;my &lt;&lt; endl &lt;&lt;
            (myStruct*) base2ptr &lt;&lt; endl &lt;&lt;
            (myStruct*) base3ptr &lt;&lt; endl;
    return 0;
}
// Output:
// 0xbfbc779c
// 0xbfbc779c
// 0xbfbc779c
</code></pre>

<p>The requirement for this to work is: <strong>if a member is the first member in its class, then its address in a object is equal to address of the object (of that class).</strong> I'm not sure if this is true.</p>

<p>EDIT: it should hold when the wrapper-base classes will be PODs. After following modifications:</p>

<pre><code>struct myStructBase1 { int a; virtual void g() {} };
struct myStructBase2 { int b; virtual void f() {} };
struct myStructBase3 { int c;  };
struct myStruct : public myStructBase1,myStructBase2,myStructBase3 {
    int d;
    virtual void h() {}
};
</code></pre>

<p>The output is:</p>

<pre><code>0xbfa305f4
0xbfa305f8
0xbfa305f4
</code></pre>

<p>For the c member, the constraint still holds. So generally the answer is: yes, there is an alternative way. However, defining a base class for each ""reversible""-member is probably not wise way..</p>
",0
520117,467851,0,"<p>For design scope you can use so :<br></p>

<p>Test::isVal = str;</p>
",0
467876,467851,8,"<p>You also don't really need to use <code>this</code> explicitly to access member variables/methods. You can simply say:</p>

<pre><code>isVal = str;
</code></pre>
",1
467853,467851,33,"<p>In C++, <code>this</code> is a pointer (as opposed to a reference). So you have to say <code>this-&gt;isVal</code> instead.</p>
",0
467860,467851,15,"<p>Adding to <a href=""https://stackoverflow.com/questions/467851/why-cant-we-use-this-inside-the-class#467853"">Chris's answer</a>, you can also do:</p>

<pre><code>(*this).isVal = str;
</code></pre>

<p>However, it's better to do what Chris said, as it is more orthodox. This is just illustrating that you need to de-reference the pointer before calling methods on it.</p>
",12
401761,401621,2,"<p>Register each template at run-time in the constructor. Use a static variable per template to check if the type has already been registered. The following is a quickly hacked together example:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

class Registerable {
    static vector&lt;Registerable *&gt; registry_;

public:
    static void registerFoo(Registerable *p)
    {
        registry_.push_back(p);
    }

    static void printAll()
    {
        for (vector&lt;Registerable *&gt;::iterator it = registry_.begin();
             it != registry_.end(); ++it)
            (*it)-&gt;print();
    }

    virtual void print() = 0;
};

vector&lt;Registerable *&gt; Registerable::registry_;

template &lt;typename T&gt;
class Foo : public Registerable {
    static bool registered_;

public:
    Foo()
    {
        if (!registered_) {
            registerFoo(this);
            registered_ = true;
        }
    }

    void print()
    {
        cout &lt;&lt; sizeof (T) &lt;&lt; endl;
    }
};

template &lt;typename T&gt; bool Foo&lt;T&gt;::registered_ = false;

int
main(int argc, char *argv[])
{
    Foo&lt;char&gt; fooChar;
    Foo&lt;short&gt; fooShort;
    Foo&lt;int&gt; fooInt;

    Registerable::printAll();

    return 0;
}
</code></pre>

<p>It should output the size of each template parameter in the order the classes were instantiated:</p>

<pre><code>1
2
4
</code></pre>

<hr>

<p>This version removes the registration code from each constructor and puts it in a base class.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

class Registerable {
    static vector&lt;Registerable *&gt; registry_;

public:
    static void registerFoo(Registerable *p)
    {
        registry_.push_back(p);
    }

    static void printAll()
    {
        for (vector&lt;Registerable *&gt;::iterator it = registry_.begin();
             it != registry_.end(); ++it)
            (*it)-&gt;print();
    }

    virtual void print() = 0;
};

vector&lt;Registerable *&gt; Registerable::registry_;

template &lt;typename T&gt;
class Registerer : public Registerable {
    static bool registered_;

public:
    Registerer(T *self)
    {
        if (!registered_) {
            registerFoo(self);
            registered_ = true;
        }
    }
};

template &lt;typename T&gt; bool Registerer&lt;T&gt;::registered_ = false;

template &lt;typename T&gt;
class Foo : public Registerer&lt;Foo&lt;T&gt; &gt; {
public:
    Foo() : Registerer&lt;Foo&lt;T&gt; &gt;(this) { }

    void print()
    {
        cout &lt;&lt; sizeof (T) &lt;&lt; endl;
    }
};

int
main(int argc, char *argv[])
{
    Foo&lt;char&gt; fooChar;
    Foo&lt;short&gt; fooShort;
    Foo&lt;int&gt; fooInt;

    Registerable::printAll();

    return 0;
}
</code></pre>

<p>I added an example of another non-template class using the registry. So, the final output would be:</p>

<pre><code>foo: 1
foo: 2
foo: 4
bar
</code></pre>
",0
401796,401621,0,"<p>The Registerable solution is a neat idea, but has a couple of issues.
Ideally, I'd like to not add code to the constructor:</p>

<ol>
<li><p>Because it relies on calling the constructor in order to register the type, it's a 
little haphazard about what gets registered and what doesn't.
For things like persistence, I may never call the constructor of a particular type
before using the list, but I may need the type's data in the list in order to 
know how to un-persist an object in a file.</p></li>
<li><p>There's runtime cost during the constructor call. I'd like to front load the time cost 
and not pay the cost many times. If I had a vector of these objects and resized the 
vector I'd pay the time-cost each time the copy constructor was called.</p></li>
</ol>
",1
401801,401621,11,"<p>You can execute something before main once if a instantiation of a template is made. The trick is to put a static data member into a class template, and reference that from outside. The side effect that static data member triggers can be used to call the register function:</p>

<pre><code>template&lt;typename D&gt;
struct automatic_register {
private:
    struct exec_register {
        exec_register() {
            persistenceSystem::registerPersistableType(
                D::getPersister()
            );
        }
    };
    // will force instantiation of definition of static member
    template&lt;exec_register&amp;&gt; struct ref_it { };

    static exec_register register_object;
    static ref_it&lt;register_object&gt; referrer;
};

template&lt;typename D&gt; typename automatic_register&lt;D&gt;::exec_register 
    automatic_register&lt;D&gt;::register_object;
</code></pre>

<p>Derive the class you want to be auto-registered from <code>automatic_register&lt;YourClass&gt;</code> . The register function will be called before main, when the declaration of <code>referrer</code> is instantiated (which happens when that class is derived from, which will implicitly instantiate that class from the template). </p>

<p>Having some test program (instead of the register function, a function do_it is called):</p>

<pre><code>struct foo : automatic_register&lt;foo&gt; {    
    static void do_it() {
        std::cout &lt;&lt; "" doit ""; 
    } 
}; 

int main() { 
    std::cout &lt;&lt; "" main ""; 
}
</code></pre>

<p>Yields this output (as expected):</p>

<pre><code>doit main
</code></pre>
",6
590032,590027,2,"<p>Under windows you can encapsulate each instance in different DLLs.</p>
",1
590033,590027,1,"<p>Remember that the library also depends on the singleton nature of the singleton. If you want to update the library you need to verify that your changes don't violate library functioning. That can only be done manually each time.</p>
",0
590034,590027,3,"<p>Find out who wrote the library in the first place, visit their home address and beat them to a bloody pulp, preferrably with a book about software design. :)</p>

<p>Apart from that: maintain your changes to the original library as a patch set so you can (more or less) easily apply it to each new version. Also, try to get your changes into the library so you don¡¯t have to maintain the patches yourself. ;)</p>
",0
590042,590027,1,"<p>The answer is ""it depends"". A good example is the C++ heap used by Microsofts C runtime. This is implemented as a singleton, of course. Now, when you statically link the CRT into multiple DLLs, you end up with multiple copies. The newer implementations have a single heap, whereas the older CRTs created one heap per library linked in.</p>
",0
364163,364146,12,"<p>You've got something like this:</p>

<pre><code>class Ship
{
    class Coordinate
    {
        Ship m_ship;
    };

    Coordinate m_coordinate;
};
</code></pre>

<p>The problem is that each Ship object contains as a member a Coordinate, which contains as a member a Ship, ad nauseum.  The size of a Ship would become infinitely large if this were allowed to continue.  What you really want is to replace those member variables with pointers or references - a pointer/reference has a known size (e.g. 4 bytes on a 32-bit CPU), and can be declared without knowing any information about the type being pointed/referred to.</p>
",4
1622838,1622817,4,"<p>In-place array rotation is trickier than it looks.  You might be interested in this article:</p>

<p><a href=""http://www.azillionmonkeys.com/qed/case8.html"" rel=""nofollow noreferrer"">http://www.azillionmonkeys.com/qed/case8.html</a></p>
",0
1623697,1622817,2,"<p>Tips:</p>

<p>Add assertions (<code>r</code> is positive, nonzero?, less than <code>maxsize</code>, <code>maxsize</code> is nonzero, etc.)</p>

<p>Write tests for this function, starting from an easy array and going up. Do not throw them away - keep them written and run all of them in a row.</p>

<p>Give clear names to variables.</p>

<p>Do not reuse <code>r</code>.</p>

<p>Your code looks a bit too obscure for me. At first sight it is crying ""Off by one errors here! Come see!"". Assert each and every possible boundary error.</p>

<p>For any more detailed answers, you should expand a bit on <em>""its still not comming out right""</em>.</p>
",0
268650,268604,-1,"<p>Look into the iomanip header.  It has a lot of width-precision etc... functionality.</p>
",3
268693,268604,1,"<p>I don't think this is possible with standard manipulators. (if it is, I'd love to be corrected and learn how)</p>

<p>Your only remaining option is creating a streambuf yourself, and intercepting all exponent numbers that go to the stream, reformat them by hand, and pass them on to the underlying stream.</p>

<p>Seems a lot of work, and while not rocket science, no trivial task either.</p>

<p>On the 'why' question: I know linux defines the exponent as minimum two digits, I suppose Windows specifies it as minimum three?</p>

<pre><code>// on linux
std::cout &lt;&lt; std::scientific &lt;&lt; 1.23e4 &lt;&lt; std::endl
</code></pre>

<p>Also adds a leading zero:</p>

<pre><code>1.230000e+04
</code></pre>
",1
268947,268604,1,"<p>As a follow-up of @Pieter's answer, I've been looking inside the operator&lt;&lt; (ostream&amp;, double).  Indeed, there is no field to specify the significance or width of the exponent.  On windows, the operator&lt;&lt; forwards to sprintf, which has no exponent-size either.</p>

<p>In it's turn, the sprintf function (on Windows) calls into _cfltcvt_l, a function we have no source code for, but whose signature doesn't provide for an exponent-precision.</p>

<p>I know nothing of the implementation on Linux.</p>
",0
1608268,1608252,12,"<p>Learn <a href=""http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization"" rel=""nofollow noreferrer"">Resource Acquisition Is Initialization</a>.</p>
<blockquote>
<p>The technique was invented by Bjarne Stroustrup, to deal with resource deallocation in C++.</p>
<p>[...]</p>
<p>RAII is vital in writing exception-safe C++ code: to release resources before permitting exceptions to propagate (in order to avoid resource leaks) one can write appropriate destructors once rather than dispersing and duplicating cleanup logic between exception handling blocks that may or may not be executed.</p>
</blockquote>
<p>C++ is an object-oriented language with features like inheritance, encapsulation and polymorphism that is also found in popular languages like Java, C# etc. C++ also features generics via templates. However, in C++ you have to explicitely handle memory deallocation (ie. no garbage collection). This makes it very important to be able to release resources and deallocate memory in a controlled manner, and that is why I believe RAII is a very fundamental concept in C++. You will have a hard time understanding a &quot;smart pointer&quot; unless you understand RAII.</p>
",3
1608271,1608252,6,"<p>This is really an impossible to create list. Every place I work has a different acceptable subset of C++. So its going to be different depending on what you're developing on. I've seen C++ that truly is just C with occasional use of the ""class keyword"" to very run-time polymorphism oriented code to template meta-programming heavy code. Then the practices are going to change based on what frameworks/libraries/platforms you are targeting.</p>

<p>The best I could suggest is reading various coding standards and seeing the how they suggest you ought to write code using C++.</p>

<ul>
<li><a href=""http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml"" rel=""nofollow noreferrer"">Google's Coding Standard</a></li>
<li><a href=""http://www.keenzo.com/showproduct.asp?M=ADDISON_-_WESLEY_9780321113580&amp;ID=2193035"" rel=""nofollow noreferrer"">Sutter's Coding Standard Book</a></li>
</ul>
",5
1608281,1608252,6,"<p>You learn and remember them by having a need for them. I'm not sure what sort of ""features"" you're looking for. ""<strong>virtual functions</strong>"" are definitely something you want to learn, but I don't really know your background. Should I be suggesting <strong>polymorphism/class inheritance</strong> too? <strong>Template classes/functions</strong>?</p>
",0
1608283,1608252,0,"<p>I think templates are such a feature...</p>
",1
1611813,1608252,0,"<p>Do you have a tool box containing too many tools? Then don't use them all? Use the ones you need.</p>

<p>Read a good book with C++ best practices and design patterns.</p>
",0
1402396,1402341,0,"<p>Two choices:</p>

<p>1) Use a high level library that solves the problem.  <a href=""http://www.boost.org/doc/libs/1_40_0/libs/multi_index/doc/index.html"" rel=""nofollow noreferrer"">Boost MultiIndex</a> containers allow shared nodes with multiple ordered/mapped organizations.</p>

<p>2) Instead of two (sorted by rating and name) singly linked lists, use two doubly linked lists.  Then deletion of a given node is O(1).  To find a node quickly by name, you could use an efficient map (hash table or balanced tree).  If you don't mind scanning through one list to find the node, then that list doesn't need to be doubly linked.</p>

<p>As for deletion for linked lists, you're right to suspect that your code can be simplified immensely.  Either:</p>

<p>1) use a sentinel (dummy) node for the empty list; that way the ""previous node"" always exists for actual list items</p>

<p>2) instead of ""pointer to previous node"" in singly linked list deletion, store ""pointer to ""next pointer to this node"""".</p>

<p>Here's what I mean by 2):</p>

<pre><code>node **pn=&amp;headByRating; // we will update headByRating=n via (*pn)=n if needed
node *c=*pn;  // we will have c == *pn except momentarily
while ( c &amp;&amp; strcmp(name, c-&gt;item.getName()) {
    pn=&amp;c-&gt;nextByRating; // c is now the previous node
    c=*pn; // c is *pn again
}
// now (*pn) points to the node we want to delete, i.e. c
*pn=c-&gt;next; // (*pn) skips right over c now.
// delete c; // or else you leak memory; you didn't specify how nodes are allocated
return true;
</code></pre>

<p>This should be equivalent to your:</p>

<pre><code>while ( NULL != currByRating &amp;&amp; 
      ( strcmp( name, currByRating-&gt;item.getName() ) != 0 ) )
{
    prev_node = currByRating;
    currByRating = currByRating-&gt;nextByRating;
    prev_node-&gt;nextByRating  = currByRating;
}
    if ( currByRating == headByRating ) // was it the head?
    {
        currByRating = currByRating-&gt;nextByRating;
        headByRating = currByRating;
        return true;
    }
    else if ( currByRating-&gt;nextByRating == NULL ) // could it be the tail?
    {
        currByRating = prev_node;
        currByRating-&gt;nextByRating = NULL;
        return true;
    }
    else
    {
        currByRating = prev_node;
        currByRating-&gt;nextByRating = currByRating-&gt;nextByRating-&gt;nextByRating;
        return true;
    }
</code></pre>
",4
1402687,1402341,0,"<p>It might be solved, but somehow I think I can do without two while loops..and redeclaring..</p>

<pre>

node **previous_node = &headByRating; // we will update headByRating via (*prev_node)=n if needed
    node *current_node   = *previous_node;  // we will have current == *prev_node except momentarily

    while ( current_node && strcmp( name, current_node->item.getName() ) != 0 ) 
    {
        previous_node = &current_node->nextByRating; // c is now the previous node
        current_node  = *previous_node; // current is *prev_node again
    }
        // now (*prev_node) points to the node we want to delete; current
        *previous_node = current_node->nextByRating; // (*prev_node) skips right over current now.

        node **prev_node = &headByName;
        node *cur_node   = *prev_node;

        while ( current_node && strcmp( name, cur_node->item.getName() ) != 0 )
        {
            prev_node = &cur_node->nextByName;
            cur_node = *prev_node;
        }

        *prev_node = cur_node->nextByName;

        delete current_node;// or else
        current_node = NULL; 

        return true;
}

</pre>

<p>I will study this =)
Thanks to wrang wrang for his exellence.</p>
",0
1128154,1128144,11,"<p>You can either use two maps or you can use <a href=""http://www.boost.org/doc/libs/1_39_0/libs/bimap/doc/html/index.html"" rel=""nofollow noreferrer"">Boost.Bimap</a>.</p>
",2
1128166,1128144,0,"<p>I don't know of any prepackaged data structure to do this in standard C++.  Seems to me like you'd need two data structures, of the form:</p>

<pre><code>std::map&lt;unsigned long,std::vector&lt;unsigned long&gt; &gt; employee_projects
</code></pre>

<p>And one such as:</p>

<pre><code>std::map&lt;unsigned long,std::vector&lt;unsigned long&gt; &gt; project_employees
</code></pre>

<p>Where employee_projects is a list of integers (employeeIDs) mapping to a list of projectIDs), and project_employees is the converse.  Prepopulate both, and you can quickly reference them throughout your application.</p>

<p>Caveat: Any modifications during runtime will have to be manually applied to each structure.</p>
",0
1128214,1128144,0,"<p>Pick the relationship that you think will be the most common and create that map. Then, either write function or derive from a map class and extend with a method for doing the lookup the other direction. That lookup will obviously be much slower (will have to iterate over the values) but it would let you get away with using only one map.</p>

<p>Probably would make the most sense to wrap the whole thing in a class so you can change the map if you realize you need the other look up more or you want to switch to using 2 maps or some other solution.</p>
",0
1128914,1128144,2,"<p>You can go with two big global-ish multimaps as you suggest, or you could maintain the information locally in the project and employee data structures.  Have the Project class contain a vector (or set) of pointers to Employee, and the Employee class contain a vector/set of pointers to Project, plus a function that associates an Employee to a Project by pushing a pointer to each onto the vector of the other.  Then given either object, you can get the collection of objects of the other type that are associated with it.  Something like:</p>

<pre><code>    (in Employee.h):
class Project;  // Forward declare project

class Employee {
public:
  AddProject(Project *proj);
  vector&lt;Project *&gt; projects();
  size_t num_projects() {return projects_.size();}
  Project *project(size_t i) {return projects_[i];}
private:
  vector&lt;Project *&gt; projects_;
};
</code></pre>

<p>and similarly for Project.h.</p>

<p>Either approach can work; the local approach is the way you would typically do it in a language like C where you don't have multimap available.  You can also use indices or IDs in place of pointers.  One advantage of the local approach is that more of the work you need to do with Projects and Employees can become local behavior of the Project/Employee classes, implemented with methods of those classes, and unit tested separately from the rest of the system.  That doesn't work with the multimap approach, since the individual classes know nothing of the multimaps.</p>

<p>The difference isn't so apparent here, where you only have the two classes, but I've seen cases where lots of these kinds of relationships were represented with large global-ish data structures that were part of a huge monster class, and unit testing became almost impossible (since you needed to set up so many data structures in the monster class to get anything done).</p>
",0
777857,777764,5,"<p>CppUnit for unit testing and test driven development</p>
",0
777958,777764,8,"<p><a href=""http://loki-lib.sourceforge.net/"" rel=""noreferrer"">http://loki-lib.sourceforge.net/</a> might also be good addition.</p>

<p>It's another template library, which introduces typelists, and implementations for various design patterns.</p>

<p>I never used it, but I read Alexandrescu's book to get a better understanding of templates.</p>
",1
778545,777764,32,"<p>Sorry for repeating some of the stuff already written, but:</p>

<ul>
<li>UI: <a href=""http://qt.nokia.com/"" rel=""noreferrer"">Qt</a></li>
<li>Database: <a href=""http://soci.sourceforge.net/"" rel=""noreferrer"">SOCI</a></li>
<li>General purpose: <a href=""http://boost.org"" rel=""noreferrer"">Boost</a>, <a href=""http://loki-lib.sourceforge.net/"" rel=""noreferrer"">Loki</a>, <a href=""http://www.stlsoft.org/"" rel=""noreferrer"">STLSoft Libraries</a>, <a href=""http://stlab.adobe.com/"" rel=""noreferrer"">ASL</a></li>
<li>Threading: <a href=""http://www.boost.org/doc/libs/1_38_0/doc/html/thread.html"" rel=""noreferrer"">Boost.Thread</a></li>
<li>Testing: <a href=""http://www.boost.org/doc/libs/1_38_0/libs/test/doc/html/index.html"" rel=""noreferrer"">Boost.Test</a></li>
<li>Build tools: <a href=""http://www.boost.org/doc/tools/build/index.html"" rel=""noreferrer"">Boost.Build</a>, <a href=""http://www.scons.org/"" rel=""noreferrer"">SCons</a></li>
</ul>

<p>(Should at least get you started)</p>
",0
778432,777764,11,"<p>On Windows...</p>

<p>ATL for COM development
  WTL for user interface</p>
",0
782146,777764,206,"<p><strong>Cross-platform libraries that are free for commercial (or non-commercial) applications</strong></p>
<p><em>Feel free to expand this list</em></p>
<hr />
<ul>
<li>General Purpose
<ul>
<li><a href=""http://www.boost.org/"" rel=""nofollow noreferrer"">Boost</a></li>
<li><a href=""http://loki-lib.sourceforge.net"" rel=""nofollow noreferrer"">Loki</a></li>
<li><a href=""https://code.google.com/p/mili/"" rel=""nofollow noreferrer"">MiLi</a></li>
<li><a href=""http://pocoproject.org/"" rel=""nofollow noreferrer"">POCO</a></li>
<li><a href=""http://en.wikipedia.org/wiki/Standard_template_library"" rel=""nofollow noreferrer"">STL</a> (of course)</li>
<li><a href=""http://stxxl.sourceforge.net/"" rel=""nofollow noreferrer"">STXXL</a> (STL re-implementation for extra large data sets)</li>
<li><a href=""http://www.qt.io/"" rel=""nofollow noreferrer"">Qt</a></li>
<li><a href=""http://stlab.adobe.com/"" rel=""nofollow noreferrer"">ASL</a></li>
<li><a href=""http://www.juce.com"" rel=""nofollow noreferrer"">JUCE</a></li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>Audio
<ul>
<li><a href=""http://www.fmod.org/"" rel=""nofollow noreferrer"">FMOD</a></li>
<li><a href=""https://ccrma.stanford.edu/software/stk/"" rel=""nofollow noreferrer"">Synthesis ToolKit</a></li>
</ul>
</li>
<li>Database
<ul>
<li><a href=""http://soci.sourceforge.net"" rel=""nofollow noreferrer"">SOCI</a></li>
<li><a href=""http://otl.sourceforge.net/"" rel=""nofollow noreferrer"">OTL</a></li>
<li><a href=""http://lmdbxx.sourceforge.net/"" rel=""nofollow noreferrer"">LMDB++</a></li>
</ul>
</li>
<li>Design
<ul>
<li>IoC Frameworks
<ul>
<li><a href=""https://github.com/ybainier/Hypodermic"" rel=""nofollow noreferrer"">Hypodermic</a></li>
<li><a href=""http://www.pocomatic.com/docs/whitepapers/pococapsule-cpp/"" rel=""nofollow noreferrer"">PocoCapsule</a></li>
<li><a href=""http://wallaroolib.sourceforge.net"" rel=""nofollow noreferrer"">Wallaroo</a></li>
</ul>
</li>
</ul>
</li>
<li>Documents
<ul>
<li><a href=""http://api.libreoffice.org/"" rel=""nofollow noreferrer"">LibreOffice API</a></li>
<li><a href=""http://podofo.sourceforge.net/"" rel=""nofollow noreferrer"">PoDoFo</a></li>
</ul>
</li>
<li>Graphics
<ul>
<li><a href=""http://alleg.sourceforge.net/"" rel=""nofollow noreferrer"">Allegro</a></li>
<li><a href=""http://www.ogre3d.org/"" rel=""nofollow noreferrer"">OGRE</a></li>
<li><a href=""http://www.sfml-dev.org/"" rel=""nofollow noreferrer"">SFML</a></li>
</ul>
</li>
<li>GUI
<ul>
<li><a href=""http://www.fltk.org/"" rel=""nofollow noreferrer"">FLTK</a></li>
<li><a href=""http://www.gtkmm.org/"" rel=""nofollow noreferrer"">GTK</a></li>
<li><a href=""http://www.qt.io/"" rel=""nofollow noreferrer"">Qt</a></li>
<li><a href=""http://qwt.sourceforge.net/"" rel=""nofollow noreferrer"">Qwt</a></li>
<li><a href=""http://www.wxwidgets.org"" rel=""nofollow noreferrer"">wxWidgets</a></li>
<li><a href=""http://vtk.org"" rel=""nofollow noreferrer"">VTK</a></li>
</ul>
</li>
<li>Hashing
<ul>
<li><a href=""https://code.google.com/p/smhasher/wiki/MurmurHash3"" rel=""nofollow noreferrer"">MurmurHash3</a></li>
</ul>
</li>
<li>Imaging
<ul>
<li><a href=""http://www.boost.org/doc/libs/1_38_0/libs/gil/doc/index.html"" rel=""nofollow noreferrer"">Boost.GIL</a></li>
<li><a href=""http://cimg.sourceforge.net"" rel=""nofollow noreferrer"">CImg</a></li>
<li><a href=""http://openil.sourceforge.net/"" rel=""nofollow noreferrer"">DevIL</a></li>
<li><a href=""http://easybmp.sourceforge.net/"" rel=""nofollow noreferrer"">EasyBMP</a></li>
<li><a href=""http://freeimage.sourceforge.net/"" rel=""nofollow noreferrer"">FreeImage</a></li>
<li><a href=""http://itk.org"" rel=""nofollow noreferrer"">ITK</a></li>
<li><a href=""http://opencv.willowgarage.com/"" rel=""nofollow noreferrer"">OpenCV</a></li>
</ul>
</li>
<li>Logging
<ul>
<li><a href=""http://boost-log.sourceforge.net/libs/log/doc/html/index.html"" rel=""nofollow noreferrer"">Boost.Log</a></li>
<li><a href=""http://logging.apache.org/log4cxx/index.html"" rel=""nofollow noreferrer"">log4cxx</a></li>
<li><a href=""http://www.pantheios.org/"" rel=""nofollow noreferrer"">Pantheios</a></li>
</ul>
</li>
<li>Mocking
<ul>
<li><a href=""https://code.google.com/p/googlemock/"" rel=""nofollow noreferrer"">Google Mock</a></li>
<li><a href=""https://www.assembla.com/wiki/show/hippomocks"" rel=""nofollow noreferrer"">Hippo Mocks</a></li>
<li><a href=""http://turtle.sourceforge.net/"" rel=""nofollow noreferrer"">Turtle</a> (C++ mock object library for Boost)</li>
</ul>
</li>
<li>Multimedia
<ul>
<li><a href=""http://openframeworks.cc"" rel=""nofollow noreferrer"">openframework</a></li>
<li><a href=""http://libcinder.org/"" rel=""nofollow noreferrer"">Cinder</a></li>
<li><a href=""http://www.libsdl.org/"" rel=""nofollow noreferrer"">SDL</a></li>
</ul>
</li>
<li>Networking
<ul>
<li><a href=""http://www.cs.wustl.edu/%7Eschmidt/ACE.html"" rel=""nofollow noreferrer"">ACE</a></li>
<li><a href=""http://www.boost.org/doc/libs/1_37_0/doc/html/boost_asio.html"" rel=""nofollow noreferrer"">Boost.Asio</a></li>
<li><a href=""http://www.zeroc.com/"" rel=""nofollow noreferrer"">ICE</a></li>
</ul>
</li>
<li>Testing
<ul>
<li><a href=""http://www.boost.org/doc/libs/1_38_0/libs/test/doc/html/index.html"" rel=""nofollow noreferrer"">Boost.Test</a></li>
<li><a href=""http://googletest.googlecode.com/"" rel=""nofollow noreferrer"">Google Test</a></li>
<li><a href=""http://unittest-cpp.sourceforge.net/"" rel=""nofollow noreferrer"">UnitTest++</a></li>
<li><a href=""https://github.com/onqtam/doctest"" rel=""nofollow noreferrer"">doctest</a></li>
</ul>
</li>
<li>Threading
<ul>
<li><a href=""http://www.boost.org/doc/libs/1_38_0/doc/html/thread.html"" rel=""nofollow noreferrer"">Boost.Thread</a></li>
</ul>
</li>
<li>Version Control
<ul>
<li><a href=""http://libgit2.github.com/"" rel=""nofollow noreferrer"">libgit2</a></li>
</ul>
</li>
<li>Web Application Framework
<ul>
<li><a href=""http://cppcms.com/"" rel=""nofollow noreferrer"">CppCMS</a></li>
<li><a href=""http://www.webtoolkit.eu/"" rel=""nofollow noreferrer"">Wt</a></li>
</ul>
</li>
<li>XML
<ul>
<li><a href=""http://xmlsoft.org/"" rel=""nofollow noreferrer"">Libxml2</a></li>
<li><a href=""http://pugixml.org/"" rel=""nofollow noreferrer"">pugixml</a></li>
<li><a href=""http://rapidxml.sourceforge.net/"" rel=""nofollow noreferrer"">RapidXml</a></li>
<li><a href=""http://www.grinninglizard.com/tinyxml/"" rel=""nofollow noreferrer"">TinyXML</a></li>
<li><a href=""http://xerces.apache.org/xerces-c/"" rel=""nofollow noreferrer"">Xerces-C++</a></li>
</ul>
</li>
</ul>
<hr />
<p>Links to additional lists of open source C++ libraries:</p>
<p><a href=""http://en.cppreference.com/w/cpp/links/libs"" rel=""nofollow noreferrer"">http://en.cppreference.com/w/cpp/links/libs</a></p>
",9
637901,637892,3,"<p>Looks like there is a <code>String</code> class in the header mentioned by the compiler. The compiler thinks you made a typo.</p>

<p>If you want to use STL strings use the following:</p>

<pre><code>#include &lt;string&gt;

int populateBindingHandle(rpc_if_handle_t p_if_spec, std::string ...)
</code></pre>

<p>or have a <code>using</code> declaration somewhere:</p>

<pre><code>using std::string;

int populateBindingHandle(rpc_if_handle_t p_if_spec, std::string ...)
</code></pre>

<p>Note, the old-style headers have been deprecated, i.e. you should no longer use <code>#include &lt;string.h&gt;</code></p>
",1
1539431,1539396,1,"<p>PList files are not only mimicing XML, they are XML, including valid XML headers. </p>

<p>Any XML reader should be able to parse these files as a result. If you're looking for a logical class that abstracts the files, I'm not aware of any existing ones. Given Apple's documentation, you should be able to write one yourself with an XML reader, although it would take some work for full compatibility.</p>
",1
1539468,1539396,0,"<p>Is that target-specific?</p>

<p>For Windows, there is a crude solution which consists of using the functions of iTunes dynamic libraries to parse plist files (either binary or plain text format work).</p>

<p>That's a code originally written to interface an iPod, but you can easily extract the few functions you are interested in.</p>

<p>The repository is on this project page: <a href=""http://code.google.com/p/t-pot/"" rel=""nofollow noreferrer"">http://code.google.com/p/t-pot/</a></p>

<p>Look for the file iPoTApi.h and iPoTApi.cpp, the function <code>TranslatePLIST</code> of the class <code>CiPoTApi</code>.</p>

<p>I wish there were a better solution, at the time I tried to compile it from Apple's sources targeted at Windows but it is a real nightmare, and files are missing. So using their libraries was a considerable shortcut.</p>
",0
775177,775144,0,"<p>The STL implementations I've used support an allocator as a template parameter, which you could use to make a container <strong>use</strong> your segregated free list, but you'd still be writing your own.</p>
",0
775179,775144,3,"<p>I don't think STL has anything, but it looks like the Boost library might have it, <a href=""http://www.boost.org/doc/libs/1_38_0/libs/pool/doc/interfaces/simple_segregated_storage.html"" rel=""nofollow noreferrer"">http://www.boost.org/doc/libs/1_38_0/libs/pool/doc/interfaces/simple_segregated_storage.html</a></p>
",0
544218,544206,10,"<p>It sure is.  But what you probably want - for expandability purposes later - create a second class - ""polygon"", that holds a list of points.  Then use a list of polygons.</p>

<p>EDIT: I'm no C++ programmer, so I'm sure an implementation like <a href=""https://stackoverflow.com/questions/544206/is-it-possible-or-ok-to-have-a-stdlist-of-stdlists/544685#544685"">j_random_hacker's</a> response is better if you're needing this for a real project.  I merely wanted to give a quickie code example of this design.</p>

<pre><code>class Point {
public:
    int x, y;
    Point(int x1, int y1)
    {
        x = x1;
        y = y1;
    }
};

class Polygon {
public:
    std::list &lt;Point&gt; currentPolygon;
    Polygon(std::list &lt;Point&gt; p1)
    {
        currentPolygon = p1
    }
};
</code></pre>
",5
544225,544206,9,"<p>You could use this:</p>

<pre><code>std::list&lt; std::list&lt;Point&gt; &gt; polygons;
</code></pre>

<p>To make things easier, use typedefs.</p>

<pre><code>class Point {
public:
    int x, y;
    Point(int x1, int y1)
    {
        x = x1;
        y = y1;
    }
};
typedef std::list&lt;Point&gt; PolygonType;
typedef std::list&lt;PolygonType&gt; PolygonsType;
</code></pre>
",1
544685,544206,4,"<p>Here is Jeffrey's code again, tidied up slightly to fix what I was whingeing about in the comments :)</p>

<pre><code>class Point {
public:
    int x, y;
    Point(int x1, int y1) : x(x1), y(y1)
    {
    }
};

class Polygon {
public:
    std::list &lt;Point&gt; currentPolygon;    // Consider making this private.
    explicit Polygon(std::list &lt;Point&gt; const&amp; p1) : currentPolygon(p1)
    {
    }
};
</code></pre>

<p><strong>[EDIT: Thanks to Matt Davis for pointing out that the user-defined copy constructor I provided was unnecessary, which simplifies things.]</strong></p>
",2
1280346,1280304,3,"<p>I believe the answer is <a href=""http://msdn.microsoft.com/en-us/library/3t4w2bkb(VS.80).aspx"" rel=""nofollow noreferrer"">here</a>.</p>

<p>Quote:</p>

<blockquote>
  <p>Most C operators perform type
  conversions to bring the operands of
  an expression to a common type or to
  extend short values to the integer
  size used in machine operations.</p>
</blockquote>
",0
1280353,1280304,4,"<p>The result of a short * short could overflow a short, so it's probably storing the intermediate result in an int in the second example. If anything they both should have warnings.</p>

<p>The first one is probably complaining because it's storing the result directly in the original short value, while the second one is creating an intermediate int and then casting that to a short (still a lossy operation, but many compilers won't complain).</p>
",0
1280362,1280304,12,"<p>Yes. All arithmetic operators in C++ are defined on <code>int</code> and wider. When you multiply two <code>short</code>s (doesn't matter if you use <code>*</code> or <code>*=</code>) they are both converted to <code>int</code> first. This is covered by ISO C++ 5[expr]/9:</p>

<blockquote>
  <p>Many binary operators that expect operands of arithmetic or enumeration type cause conversions and yield result types in a similar way. The purpose is to yield a common type, which is also the type of the result. This pattern is called the usual arithmetic conversions, which are defined as follows:</p>
  
  <ul>
  <li>If either operand is of type long double, the other shall be converted to long double.</li>
  <li>Otherwise, if either operand is double, the other shall be converted to double.</li>
  <li>Otherwise, if either operand is float, the other shall be converted to float.</li>
  <li>Otherwise, the integral promotions (4.5) shall be performed on both operands.</li>
  <li>Then, if either operand is unsigned long the other shall be converted to unsigned long.</li>
  <li>Otherwise, if one operand is a long int and the other unsigned int, then if a long int can represent all the values of an unsigned int, the unsigned int shall be converted to a long int; otherwise both operands shall be converted to unsigned long int.</li>
  <li>Otherwise, if either operand is long, the other shall be converted to long.</li>
  <li>Otherwise, if either operand is unsigned, the other shall be converted to unsigned. </li>
  </ul>
  
  <p>[Note: otherwise, the only remaining case is that both operands are int]</p>
</blockquote>

<p>and 4.5[conv.prom]:</p>

<blockquote>
  <p>1 An rvalue of type char, signed char, unsigned char, short int, or unsigned short int can be converted to an rvalue of type int if int can represent all the values of the source type; otherwise, the source rvalue can be converted to an rvalue of type unsigned int.</p>
  
  <p>2 An rvalue of type wchar_t (3.9.1) or an enumeration type (7.2) can be converted to an rvalue of the first of the following types that can represent all the values of its underlying type: int, unsigned int, long, or unsigned long.</p>
  
  <p>3 An rvalue for an integral bit-field (9.6) can be converted to an rvalue of type int if int can represent all the values of the bit-field; otherwise, it can be converted to unsigned int if unsigned int can represent all the values of the bit-field. If the bit-field is larger yet, no integral promotion applies to it. If the bit-field has an enumerated type, it is treated as any other value of that type for promotion purposes.</p>
  
  <p>4 An rvalue of type bool can be converted to an rvalue of type int, with false becoming zero and true becoming one.</p>
  
  <p>5 These conversions are called integral promotions.</p>
</blockquote>

<p>Why it only gives a warning on one line but not both is unclear, however.</p>
",0
1280999,1280304,0,"<p>This seems to be a very weird warning in general. Some observations:</p>

<pre><code>short s = 12345;
s *= 0xffff;       // no warning
s *= (int)0xffff;  // no warning
s *= 0x10000;      // C4244
s *= -0x8000;      // no warning
s *= -0x8001;      // C4244

short t = -12345;
s *= t;            // no warning
s *= (int)t;       // no warning
s *= (unsigned)t;  // no warning

s *= (int)t * 0xffff;  // no warning
s *= (int)t * 0x10000; // C4244
</code></pre>

<p>It doesn't seem to care about specific operators - all of <code>+-*/</code> give the same results. It seems to not actually look at expression types alone, but also at literals involved, and as soon as you cross the magic threshold, the warning pops up.</p>
",0
698435,698415,5,"<p>I would say it makes no sense at all, and that you have gone too far already. If you are new to C++ you are in no position to write a detailed design document for a C++ project. I would recommend you try to implement what you already have in C++, learn by the inevitable mistakes (like public attributes) and then go back and revise it.</p>
",0
698436,698415,4,"<p>Since you're new, it probably makes sense <em>not</em> to drill down.</p>

<p>Reason: You're still figuring out the language and how things are best structured.  That means you'll make mistakes initially and you'll want to correct them without constantly updating the documentation.</p>
",1
698437,698415,6,"<p>I wouldn't recommend going to this level, but then again you've already gone past where I would go in a design specification.  My personal feeling is that putting a lot of effort into detailed design up-front is going to be wasted as you find out in developing code that your guesses as to how the code will work are wrong.  I would stick with a high-level design and think about using TDD (test driven development) to guide the low-level design and implementation.</p>
",1
698468,698415,2,"<p>The best way to specify how the code should actually fit together is <strong>in code</strong>.  The design document is for other things that are not easily expressed in code.  You should use it for describing the actual need the program fills, How it interacts with users, what the constraints are in terms of hardware and operating systems.  Certainly describe the overall architecture of your application in a design document, but, for instance, the API should actually be described in the code that exposes the API.</p>
",0
698508,698415,0,"<p>You have already gone far enough with the documentation part. As you still a beginner in C++, when you would understand the language, you might want to change the structure of your program. Then you would have to do changes in the documentation. I would suggest that you have already gone too far with the documentation. No need to drill more into it</p>
",0
698533,698415,3,"<p>It really depends on who the design document is targeted at. If it's for a boss who is non-technical, then you are good with what you have.</p>

<p>If it's for yourself, then you are using the tool to help you, so you decide. I create method level design docs when I am creating a project, but it's at a high level so I can figure out what the features of the various classes should be. I've found that across languages, the primary functionalities of a class have little to do with the programming language we are working in. Some of the internal details and functions required <em>certainly</em> vary due to the chosen language, but those are implementation details that I <em>don't</em> bother with during the design phase.</p>

<p>It certainly helps me to know that for instance an authorization class might have an authenticate function that takes a User object as a parameter. I don't really care during design that I might need an internal string md5 function wrapper to accomplish some specific goal. I find out about that while coding.</p>

<p>The goal of initial design is to get organized so you can make progress with clarity and forethought rather than tearing out and reimplementing the same function 4 times because you forgot some scenario due to not planning.</p>

<p>EDIT:  I work in PHP a lot, and I actually use PhpDoc to do some of the design docs, by simply writing the method signature with no implementation, then putting a detailed description of what the method should do in the method header comments. This helps anyone that is using my class in the future, because the design IS the documentation. I can also change the documentation if I do need to make some alterations while coding. </p>

<p>I work in php4 a lot, so I don't get to use interfaces. In php5, I create the interface, then implement it elsewhere.</p>
",0
699524,698415,0,"<p>Like everyone else says, you've gone way past where you need to go with the design. Do you have a good set of requirements to the simple true/false statement level that you derived that design from? You can design all day long, but if you don't have requirements that simply say WHAT you're going to do, it doesn't matter how good your design is.</p>
",0
1777198,1776971,0,"<p>I would use the STL, templates and throw an empty class. Now, you can't return anything from a constructor... so either do something like this:</p>

<pre><code>#include &lt;string&gt;
using std::basic_string;

class EmptyFile{};

template&lt;typename T&gt;
    class File
    {
    public:
        File(const basic_string&lt;T&gt; &amp;FILE)
        {
            if (isEmpty(FILE)) throw EmptyFile();
            openFile(FILE);
        }
        bool isEmpty(const basic_string&lt;T&gt; &amp;FILE) const
            { return FILE.empty(); }
    };
</code></pre>

<p>or you could do this:</p>

<pre><code>#include &lt;string&gt;
using std::basic_string;

template&lt;typename T&gt;
class File
{
public:
    bool Open(const basic_string&lt;T&gt; &amp;FILE) const
    {
        bool empty = isEmpty(FILE);
        if(!empty)
           /* open the file */;
        return isEmpty;
    }
    bool isEmpty(const basic_string&lt;T&gt; &amp;FILE) const
    { return FILE.empty(); }
};
</code></pre>
",0
1776982,1776971,6,"<p>Your constructor should throw an exception in the case that the file couldn't be opened.</p>

<pre><code>File::File( const char* pPath )
{
  if ( !openFile( pPath ) )
    throw FileNotFound( pPath );
}
</code></pre>
",1
1776984,1776971,1,"<p>The only way to do checking like that in the constructor is to throw an exception.  But that's not considered good design - you should create it, check if it's valid, and delete it if it isn't.</p>
",5
1776997,1776971,1,"<p>I suggest using a static factory method that does the check for you and if the object is invalid deletes it and throws an exception. You would create the file like this:</p>

<pre><code>File* file = File::open(""whatever"");
</code></pre>
",0
1777006,1776971,0,"<p>If I understand what you correctly, you want to return null from the constructor when <code>""filepath""</code> is invalid? This isn't (directly) possible in C++, although there are a few possibilities. You could throw an exception from your constructor, but this can get hairy in C++. You could have some functions that can check the validity of a File object, so <code>if(file)</code> would become <code>if(isValid(file))</code>. You could also wrap some of this logic in some sort of factory that would return null if the file to be created is invalid.</p>
",1
949055,949045,7,"<p>It is to make ""chaining"" of the operator work, in examples like this:</p>

<pre><code>std::cout &lt;&lt; ""hello,"" &lt;&lt; "" world"";
</code></pre>

<p>If the first (leftmost) use of the <code>operator&lt;&lt;()</code> hadn't returned a reference, there would not be an object to call for the second use of the operator.</p>
",1
949061,949045,4,"<p>It's for operator chaining (if you return a pointer, you have to dereference it) and for not make a potentially huge and expensive copy of an object (in the case you return a value), if it is even possible to do so.</p>
",1
949066,949045,3,"<p>A general rule, stated by Scott Meyers in Effective C++, is that when in doubt, ""do as the <code>ints</code> do"". So for example, operator= should return a reference so code like this works:</p>

<pre><code>MyClass A, B, C;
A = B = C = 0;
</code></pre>
",0
571728,571652,6,"<p>You could make use of the <strong>Service Locator</strong> pattern. <a href=""http://martinfowler.com/articles/injection.html"" rel=""nofollow noreferrer"">This article</a> introduces both dependency injection (which you are currently using) and service locator.</p>

<p>However, consider this: the idea of dependency injection is to have a system where each component has a well-defined responsibility and minimizes knowledge of other components where possible. If the component needs other components to do its job, then these are explicitly passed to it. This makes the component simpler to understand, more likely to be correct, and easier to maintain.</p>

<p>If you regularly need to add components which need to be known throughout the system, then there may be something wrong with the design of the system (or the way new features are being added to it). The dependency injection pattern just results in this problem being explicitly visible.</p>
",0
571752,571652,1,"<p>use a singleton and don't forget about: <a href=""http://www.parashift.com/c++-faq-lite/ctors.html#faq-10.12"" rel=""nofollow noreferrer"">http://www.parashift.com/c++-faq-lite/ctors.html#faq-10.12</a></p>
",0
571659,571652,2,"<p>I would say having factories with static class methods to create objects as needed -- if they don't keep state themselves -- is probably a better solution.  If the objects are needed everywhere and need to keep global state, then using the Singleton pattern may be justified.  I'd really need to know that the factory methods and recreating the objects as needed wouldn't work before I'd look at Singleon, though.  Using Singleton will complicate your testing efforts.</p>
",1
571664,571652,11,"<p>You can make your GlobalState, Log, DAL classes singletons:</p>

<pre><code>class GlobalState {
public:
  static GlobalState&amp; getInstance();
protected:
  GlobalState();
  GlobalState(const GlobalState&amp;);
  GlobalState&amp; operator= (const GlobalState&amp;);
private:
  static GlobalState* p_instance;
};

static GlobalState* GlobalState::p_instance = NULL;

/*static*/
GlobalState&amp; getInstance() {
  // TODO: acquire lock if multi-threaded
  if (!p_instance) {                 // first time?
    p_instance = new GlobalState(); // create sole instance
  }
  // TODO: release lock if multi-threaded
  return *p_instance;               // sole instance
}
</code></pre>

<p>Then, inside your various methods,</p>

<pre><code>Honda::MyMethod() {
  ...
  const GlobalState&amp; my_state = GlobalState::getInstance();
  ...
}
</code></pre>

<p>You can further simplify your life (and reduce the amount of code duplication) by <a href=""http://gpwiki.org/index.php/Programming_Techniques:Singleton#A_Singleton_Class_Template_in_C.2B.2B"" rel=""nofollow noreferrer"">defining a singleton C++ template</a>, under certain conditions (e.g. all classes' constructors take the same number and types of arguments, etc.)</p>
",4
571696,571652,1,"<p>The nice thing about making state objects into singletons is that you no longer have to pass const references to them into all your constructors anymore.</p>

<p>So, if your, global state were defined as suggested by <a href=""https://stackoverflow.com/users/66516/vlad-r"">Vlad R</a>, you could refer to it within the constructors (and elsewhere) using, e.g.:</p>

<pre><code>GlobalState::getInstance()
</code></pre>

<p>and therefore remove the constructors' parameters as well as the member variables, making your interfaces cleaner.</p>
",0
571697,571652,1,"<p>I use globally-named instances for most of my global state objects. The pattern is similar to the traditional singleton, except that with the singleton, purists will insist its constructor also be private to prevent independent construction, whereas my pattern allows independent construction as necessary (ie: my singleton template doesn't require the singleton class's constructor be private). Otherwise the pattern is similar to what Vlad wrote out.</p>

<p>One thing to be careful of: if you need to de-allocate your singletons at program exit (for example, you have an imposed requirement that you not leak memory you allocated), handling that can get very messy very fast. Describing all the things I have had to muck with to try to achieve no memory leaks using singletons would take up way to much space, and many of them are not pretty; so if you need cleanup, consider using simple globals instead (as methodologically distasteful as that may be).</p>
",0
576721,571652,0,"<p>To answer your question, Michael, there are effectively four different things that you can do in this situation:</p>

<ol>
<li>Make all your utility objects into globals. </li>
<li>Change all your utility classes into Singletons.</li>
<li>Use a Service Locator.</li>
<li>Use Dependency Injection (which you are already doing)</li>
</ol>

<p>Let's address the first three options:</p>

<ol>
<li>Using globals might be convienent, but it hides the object dependency and makes testing in isolation more difficult.</li>
<li><A HREF=""http://www.codingwithoutcomments.com/2008/10/08/singleton-i-love-you-but-youre-bringing-me-down/"" rel=""nofollow noreferrer"">It's not a good idea to use Singletons.</A></li>
<li><A HREF=""http://misko.hevery.com/2008/11/11/clean-code-talks-dependency-injection/"" rel=""nofollow noreferrer"">It's not a good idea to use a Service Locator.</A></li>
</ol>

<p>Therefore, <A HREF=""http://misko.hevery.com/2009/01/14/when-to-use-dependency-injection/"" rel=""nofollow noreferrer"">keep using Dependency Injection</A>.</p>
",0
739015,738941,4,"<p><a href=""http://curl.haxx.se/"" rel=""nofollow noreferrer"">libcURL</a> is pretty popular. I don't know that the interface is especially object-oriented, but it's certainly usable from C++.</p>
",0
738980,738941,6,"<p>Use <a href=""http://en.wikipedia.org/wiki/Wget"" rel=""nofollow noreferrer"">wget</a> with the query URL</p>

<pre><code>wget --output-document=result.html http://en.wikipedia.org/wiki/Special:Search?search=jon+skeet&amp;go=Go
</code></pre>

<p>This searches for <strong>jon skeet</strong> and stores the result in <strong>result.html</strong></p>

<p>To use it from C++ you can e.g. use the system() call to execute wget in a seperate process.</p>
",6
739000,738941,1,"<p>There are a number of client APIs for MediaWiki (the wiki engine that powers Wikipedia). <a href=""http://www.mediawiki.org/wiki/API:Client_Code"" rel=""nofollow noreferrer"">Here</a>'s a listing. They provide the ability to create/delete/edit/search articles. Nothing in straight C++ but it still may be useful.</p>

<p><a href=""http://dotnetwikibot.sourceforge.net/"" rel=""nofollow noreferrer"">DotNetWikiBot</a> was quite useful on one project that I had...</p>
",1
1479138,1479117,1,"<p>Set up the operator>() as a friend-of-Nodes function taking two Nodes.</p>

<p>Use the <code>friend</code> keyword.</p>

<p>Some refs:</p>

<p><a href=""http://www.cprogramming.com/tutorial/friends.html"" rel=""nofollow noreferrer"">http://www.cprogramming.com/tutorial/friends.html</a></p>

<p><a href=""http://msdn.microsoft.com/en-us/library/465sdshe(VS.80).aspx"" rel=""nofollow noreferrer"">http://msdn.microsoft.com/en-us/library/465sdshe(VS.80).aspx</a></p>

<p>Edit: This won't work in the pointer case, but will work in the regular Nodes case.</p>
",1
1479145,1479117,7,"<p>You need to write your own functor for the comparison because you can't overload operator> for pointers. So, instead of greater you would be using your own dedicated class with the appropriate function call operator. This could be even done generically.</p>

<pre><code>template&lt;typename T, typename Cmp = std::less&lt;T&gt; &gt;
struct deref_compare : std::binary_function&lt;T const*,T const*,bool&gt;
{
    deref_compare(Cmp const&amp; cmp = Cmp())
    : cmp(cmp) {}

    bool operator()(T const* a, T const* b) const {
        return cmp(*a,*b);
    }
private:
    Cmp cmp;
};

typedef deref_compare&lt;Node,std::greater&lt;Node&gt; &gt; my_comparator_t;
</code></pre>

<p>Edit1: I just realized you could do it even <em>more</em> generically, with iterators instead of pointers. ;-)</p>

<p>Edit2: If you're not comfortable with the template and don't need this generalization you could just as well use</p>

<pre><code>struct my_node_ptr_compare
{
    bool operator()(Node const* a, Node const* b) const {
        return *a &gt; *b;
    }
};

priority_queue&lt;Node*,vector&lt;Node*&gt;,my_node_ptr_compare&gt; foo;
</code></pre>
",5
1479263,1479117,0,"<p>The simplest way would be to implement a compare function that takes Node pointers as its parameters, like this:</p>

<pre><code>bool nodePtrGreater(Node const *a, Node const *b) {
  return *a &gt; *b;
}
</code></pre>

<p>This function should use the operator> of your Node class properly.</p>

<p>[edit] The old version didn't define the queue correctly.</p>

<p>Create your priority queue like this:</p>

<pre><code>priority_queue&lt;Node*,vector&lt;Node*&gt;, bool(*)(Node const *, Node const *)&gt; myQueue(nodePtrGreater);
</code></pre>
",5
655955,655856,1,"<pre><code>template&lt;class T&gt;
class SafeMember {
public:
    T _;    /* short name for convenience */
    SafeMember(T const&amp; obj) : _(obj) { }
};
</code></pre>

<p>Used like this:</p>

<pre><code>class Student {
public:
    Student(string surname, Color hairColor)
        : surname(surname)
        , hairColor(hairColor) { }

    Student(Student const&amp; other)
        : surname(other.surname)
        , hairColor(other.hairColor) { }

    Student&amp; operator=(Student const&amp; other) {
        surname = other.surname;
        hairColor = other.hairColor;
        return *this;
    }

    string getSurname() const { return surname._; }

    // The foo._ syntax is better than implicit conversion because
    // it lets us call member functions, like substr in this example:
    bool isSlavic() const {return surname._.substr(surname._.size()-2)==""ev"";}

    void dyeHair(Color newColor) { hairColor = newColor; }

private:
    SafeMember&lt;string&gt; surname;
    SafeMember&lt;Color&gt; hairColor;
};
</code></pre>

<p>Now when you add a ""<code>SafeMember&lt;int&gt; age</code>"" member and forget to update your copy-constructor, the compilation will helpfully fail.</p>

<p>And for a ""no-op"" hint, the developer would add an initializer like "":age(0)"".</p>

<p><strong>Note:</strong> this doesn't protect your operator=() or serialize() functions from bit-rot, only the constructors. Hopefully, though, this should be enough: once you see your omission from the constructors, you will probably remember to go through the other functions as well.</p>
",6
657771,655856,0,"<p>It looks like there is no satisfying solution to your problem (Iraimbilanja solution is probably one of the best approaches, but still it's not perfect). I wonder if there are features in upcoming C++0x that will allow to solve this?</p>
",2
691383,655856,1,"<p>Add this functionality to your unit test. If your unit test covers serializaiton/deserialization (for example, by making sure <code>deser(ser(x)) == x</code>), failure to add members to the serialization function would fail during unit testing. The same could work for copy ctors.</p>

<p>It's not as ideal as compile time errors, but if you have a good unit test framework in place and you make sure that you have proper coverage, then these errors of neglect would be harder to make.</p>
",1
1802205,1802185,2,"<p>You can eliminate the LNK2005 error by declaring the definition of <code>a::fun()</code> as <code>inline</code>.  For example:</p>

<pre><code>// a.h

// ...

inline int a::fun()
{
    int t;
    std::cout &lt;&lt; ""a"" &lt;&lt; std::endl;
    return t;
}
</code></pre>

<p>With templates, the problem doesn't occur because the compiler/linker take care of ensuring that there is only one definition of each template instantiation.</p>

<p>If, for some reason, you don't want the function to be <code>inline</code>, then you'll have to ensure that it only gets compiled once.  For example, something like this:</p>

<pre><code>// a.h

// ...

#ifdef DEFINE_CLASS_A_FUNCTIONS

int a::fun()
{
    int t;
    std::cout &lt;&lt; ""a"" &lt;&lt; std::endl;
    return t;
}

#endif
</code></pre>

<p>and then, somewhere, you'll need to do something like this (exactly once):</p>

<pre><code>#define DEFINE_CLASS_A_FUNCTIONS
#include ""a.h""
</code></pre>
",4
1802209,1802185,1,"<blockquote>
  <p>1>b.obj : error LNK2005: ""public:
  virtual int __thiscall a::fun(void)""
  (?fun@a@@UAEHXZ) already defined in
  main.obj</p>
</blockquote>

<p>You are getting this error because <code>a::fun()</code> is not <code>inline</code> </p>

<pre><code>inline int a::fun()
{
    int t;
    std::cout &lt;&lt; ""a"" &lt;&lt; std::endl;
    return t;
}
</code></pre>

<p>Also, refer C++ FAQ : <a href=""http://www.parashift.com/c++-faq-lite/templates.html#faq-35.13"" rel=""nofollow noreferrer"">How can I avoid linker errors with my template functions?</a></p>
",0
1926616,1926605,4,"<p>Number of objects for what? If you want to count the number of objects of a specific class, you can use a static counter. Something like below.. Increment counter on creation and decrement while destruction..</p>

<pre><code>class A
{
  public:
    static int counter;
    A()
    {
      counter ++;
    }
    virtual ~A()
    {
      counter --;
    }
};

int A :: counter = 0;
</code></pre>
",2
1926623,1926605,0,"<p>You could create a counter variable into the public: of your class (assuming here you're talking about counting objects from a class you created)</p>

<pre><code>class Widget {
public:
    Widget() { ++count; }
    Widget(const Widget&amp;) { ++count; }
    ~Widget() { --count; }

    static size_t howMany()
    { return count; }

private:
    static size_t count;
};
// obligatory definition of count. This
// goes in an implementation file
size_t Widget::count = 0;
</code></pre>

<p>Taken from <a href=""http://www.ddj.com/cpp/184403484"" rel=""nofollow noreferrer"">ddj.com</a></p>
",1
1926630,1926605,33,"<p>Create template class with a static counter.</p>

<p>Each object in your application would then extend this template class.</p>

<p>When constructor is called increment static count (static variable is per class - shared by all objects of that class).</p>

<p>For example see Object Counter using <a href=""http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern"" rel=""nofollow noreferrer"">Curiously recurring template pattern</a>:</p>

<pre><code> template &lt;typename T&gt;
    struct counter
    {
        counter()
        {
            objects_created++;
            objects_alive++;
        }

        counter(const counter&amp;)
        {
             objects_created++;
             objects_alive++;
        }   

    protected:
        virtual ~counter()
        {
            --objects_alive;
        }
        static int objects_created;
        static int objects_alive;
    };
    template &lt;typename T&gt; int counter&lt;T&gt;::objects_created( 0 );
    template &lt;typename T&gt; int counter&lt;T&gt;::objects_alive( 0 );

    class X : counter&lt;X&gt;
    {
        // ...
    };

    class Y : counter&lt;Y&gt;
    {
        // ...
    };

Usage for completeness:

    int main()
    {
        X x1;

        {
            X x2;
            X x3;
            X x4;
            X x5;
            Y y1;
            Y y2;
        }   // objects gone

        Y y3;

        cout &lt;&lt; ""created: ""
             &lt;&lt; "" X:"" &lt;&lt; counter&lt;X&gt;::objects_created
             &lt;&lt; "" Y:"" &lt;&lt; counter&lt;Y&gt;::objects_created  //well done
             &lt;&lt; endl;

        cout &lt;&lt; ""alive: ""
             &lt;&lt; "" X:"" &lt;&lt; counter&lt;X&gt;::objects_alive
             &lt;&lt; "" Y:"" &lt;&lt; counter&lt;Y&gt;::objects_alive
             &lt;&lt; endl;
    }
</code></pre>

<p>Output:</p>

<pre><code>created:  X:5 Y:3
alive:  X:1 Y:1
</code></pre>
",14
1926643,1926605,12,"<pre><code>template &lt;class T&gt;
class Counter
{
  private:
      static int count;
  public:
    Counter()
    {
       count++;
    }  
    Counter(const Counter &amp;c)
    {
       count++;
    }   
    ~Counter()
    {
       count--;
    }    
    static int GetCount() {

         return count;
    }
}

template&lt;class T&gt; 
int Counter&lt;T&gt;::count = 0; 



class MyClass : private Counter&lt;MyClass&gt;
{
   public:
      using Counter&lt;MyClass&gt;::GetCount;
}
</code></pre>

<p>This technique is called <a href=""http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern"" rel=""noreferrer"">CRTP</a></p>
",2
1926720,1926605,4,"<p>You have to overload the new and delete operators
to count memory allocations.</p>

<pre><code>void * operator new (size_t size)
{
    void * p = malloc (size);
    num_allocations++;
    return p;
}

void operator delete (void * p)
{
    num_deletions++;
    free (p);
}
</code></pre>
",5
412090,412084,15,"<p>A reference does contain nothing in itself. The C++ Standard even states that an implementation is not required to allocate any storage for a reference. It's really just an alias for the object or function that it references. Trying to take the value of a reference will take the value of the object or function (in that case, you get a function pointer, just like when you would try to get the value out of the function using its original name) it references, instead.</p>

<p>Of course, when you go on lower levels and look at the assembler code, references are just like pointers. But at the language level, they are completely different beasts. References to const, for example, can bind to temporaries, they are required to implement a copy constructor, for overloading operators and they can't be put into an array (not even if you initialize all elements of it), because references are no objects (as opposed to pointers). They are, as trivial as it may sound, reference types. </p>
",3
412106,412084,3,"<blockquote>
  <p>it stores the actual value of an object just like any other non-pointer simple variables on Stack?</p>
</blockquote>

<p>Not exactly: because you don't have <strong>two</strong> copies of the value (one copy in the object, and another copy in the reference to the object); instead, the reference is probably implemented as a pointer to the object.</p>

<p>Differences between a pointer and an object:</p>

<ul>
<li>reference can't be null</li>
<li>reference can't be uninitialized (must be initialized when it's defined)</li>
<li>reference can't be changed to reference a different object</li>
</ul>
",0
412112,412084,2,"<p>I'd say that it's just a pointer with a different syntax.</p>
",0
414686,412084,4,"<p>Internally, it's just a pointer to the object (although the standard not necessarily mandates it, all compilers implement this way). Externally, it behaves like the object itself. Think of it as a pointer with an implicit '*' operator wherever it is used (except, of course, the declaration). It's also a const-pointer (not to be confused with a pointer-to-const), since it cannot be redirected once declared.</p>
",0
1678991,1678924,0,"<p>Generally, I would not recommend using an array if you want to pop items off the front.  You would be much better off using a <a href=""http://en.wikipedia.org/wiki/Linked_list"" rel=""nofollow noreferrer"">linked list</a>, or some other structure which will allow you to remove items in O(1) time.  It will be much easier to remove (pop) items this way.</p>

<p>As for your current code, I really can't comment without a better idea of what your class looks like.  Please post the class definition at least so we can tell what all your variables are referring to, and what you're code is actually doing.</p>
",0
1678997,1678924,1,"<p>My suggestion are :</p>

<p>1).  Put statement --count where it keeps object's state valid on exceptional condition.</p>

<p>2).  clear your concepts of pointers which will help you a lot.</p>
",1
1679015,1678924,0,"<p>There are quite a few problems.  But I believe your major one is this loop:</p>

<pre><code>for (int temp; intFrontPtr &lt; intBackPtr ;)
{
     intFrontPtr++;
     temp = *intFrontPtr;
     *intFrontPtr = temp;
}
</code></pre>

<p>It looks to me like you are trying to shift all your items down.  Since this is homework, I'm not going to give you the answer but I'll give you some hints to help debug this.</p>

<p>What you want to do is examine your items array at the beginning and end of the loop.</p>

<pre><code>for (int temp; intFrontPtr &lt; intBackPtr ;)
{
     // whats does array look like here
     intFrontPtr++;
     temp = *intFrontPtr;
     *intFrontPtr = temp;
     // and what does array look like here
}
</code></pre>

<p>If you don't have experience with a debugger, add a function call that will dump your array.</p>
",0
1585921,1494716,0,"<p>I don't know what your goal with this question is. <strong>If your goal is to find a good c++ hash table</strong>, use std::tr1::unordered_map if your compiler supports it, otherwise go for e.g <a href=""http://code.google.com/p/google-sparsehash/"" rel=""nofollow noreferrer"">Google sparse-hash</a>.</p>

<p><strong>If your goal is to learn about hash tables</strong>, then read on.</p>

<p>In a response to <a href=""https://stackoverflow.com/questions/282712/the-fundamentals-of-hash-tables/"">this SO question</a>, I implemented a very simple Hash table in Java in <a href=""https://stackoverflow.com/questions/282712/the-fundamentals-of-hash-tables/282836#282836"">my answer</a>:</p>

<p>First, you have to understand a what a hash function is.
A hash function is a function that takes a key (for example, an string of arbritrary length) and returns a number <em>as unique as possible</em>. The same key must always return the same hash. A really simple string hashing function in java might look like</p>

<pre><code>public int stringHash(String s) {
    int h = s.length();
    for(char c : s.toCharArray()) {
        h ^= c;
    }
    return h;
}
</code></pre>

<p>You can study a good hash function at <a href=""http://www.azillionmonkeys.com/qed/hash.html"" rel=""nofollow noreferrer"">http://www.azillionmonkeys.com/qed/hash.html</a></p>

<p>Now, the hash map uses this hash value to place the value into an array. Simplistic java method:</p>

<pre><code>public void put(String key, Object val) {
    int hash = stringHash(s) % array.length;
    if(array[hash] == null) {
        array[hash] = new LinkedList&lt;Entry&lt;String, Object&gt; &gt;();
    }
    for(Entry e : array[hash]) {
        if(e.key.equals(key)){
            e.value = val;
            return;
        }
    }
    e.add(new Entry&lt;String, Object&gt;(key, val));
}
</code></pre>

<p>(This map enforces unique keys. Not all maps do.)</p>

<p>It is possible for two different keys to hash to the same value, or two different hashes to map to the same array index. There exists many techniques for dealing with this. The simplest is to use a linked list (or binary tree) for each array index. If the hash function is good enough, you will never need a linear search.</p>

<p>Now to look up a key:</p>

<pre><code>public Object get(String key) {
    int hash = stringHash(key) % array.length;
    if(array[hash] != null) {
        for(Entry e : array[hash]) {
            if(e.key.equals(key))
                return e.value;
        }
    }

    return null;
}
</code></pre>
",0
1494784,1494716,5,"<p>Ascii sum isn't a good hash function.  Here are some with explanations:</p>

<p><a href=""http://www.cse.yorku.ca/~oz/hash.html"" rel=""nofollow noreferrer"">http://www.cse.yorku.ca/~oz/hash.html</a></p>
",0
1494818,1494716,5,"<p>You are misunderstanding how hash tables work. You need to allocate a fixed-length array (in the simplest case) and then each entry must have a linked list so you can resolve duplicates. That is, two strings may result in the same hash value and you will need to walk the linked list and compare the keys.</p>

<p>And yes, like the other poster said, adding characters is a terrible approach. Think about it - ""abc"" and ""cba"" will result in the same hash value.</p>
",4
365844,365823,5,"<p>I like to find out if people actually know anything about the tools they're using. And I also find that ""senior"" developers can have serious gaps in their knowledge. </p>

<p>You could consider asking </p>

<ul>
<li>What a vtable is. </li>
<li>How templates work</li>
<li>What the difference between the heap and the stack is. The depth of the reply to this one could be quite illuminating!</li>
</ul>

<p>The ""you really need to interview me"" answer to the last question would cover</p>

<ul>
<li>allocation - limits, use-cases, failure modes, efficiency, resource cleanup, destructors</li>
<li>stack call-frames - what happens when a function is called, parameters, backtraces</li>
</ul>
",4
365862,365823,12,"<p>I'd ask about resource/memory management, because it's an important subject in C++, and it doesn't require concrete code. Just sketch a simple hypothetical scenario, and ask how they'd ensure some vital resource gets freed even in the face of errors/exceptions. Say they're developing a network app, how do they ensure that we close our sockets properly? Of course the proper answer would be to wrap it in a RAII object, but don't ask them that directly (it's easy to  google ""RAII"", while the above question ""how would you ensure resources get released properly"" actually shows you whether or not they know the appropriate techniques. If they answer ""wrap everything in try/catch"", they might have a problem. And this ties in nicely with questions about the differences between heap and stack.</p>

<p>You might be able to come up with some simple question about exception safety too, which doesn't require any real code. In general, I'd say a discussion of all the various C++ idioms might be a good idea, because many of them don't require much actual code, but are still vital language-specific concepts.</p>

<p>See if they know about smart pointers (again preferably by giving them a situation where smart pointers are called for, and see how they would solve the problem), and maybe templates/metaprogrammin (in the latter case, probably just find out if they're aware that it's possible ,rather than requiring them to code actual metaprograms on the phone)</p>

<p>You might also want to ask about some common areas of undefined behavior (what are the values of a and b after executing <code>a = b++ + b++?</code>?), or allocate an array of 10 elements, and add 10 or 11 to the array pointer, and ask what the result is in each case (+=10 is legal, gives you a past-the-end pointer, +=11 is undefined). Or give them a scenario where they need to copy a lot of objects, and ask how they'd do that (plain for-loop copying each element at a time, memcpy or std::copy are obvious answers. Note the caveats with memcpy, that it's not safe for non-POD objects)</p>

<p>Or ask about their coding style in general. How do they feel about iterators? Do they prefer plain old for-loops? Do they know how to use std::for_each or std::transform?</p>

<p><em>Edit:</em>
Seems the <code>a = b++ + b++</code> (the answer is undefined behavior, btw) suggestion in particular generated a lot of comments. Perhaps people read too much into it. As the OP said he preferred to ask <em>concrete</em> (not abstract, and easy to explain/answer/discuss over the phone) questions, that'd reveal a bit about the interviewee's C++ skills, and this is a simple (and yes, perhaps nitpicky) example of that. The reasoning behind it is that 1) it has an intuitive meaning, which is wrong, and 2) you have to have a certain level of experience with C++ before you realize this. And of course 3), it's short and easy to ask over the phone. It doesn't require anyone to write code down. No, it won't reveal whether the candidate is a ""great programmer"", but as I understood the question, that wasn't the goal either. If someone gets it wrong, it doesn't mean much at all, but if they get it right, you can be fairly sure that they know a bit of C++. But if you read my answer again, you'll see that it was just a quick example of a category of questions I thought should be represented. C++ is full of undefined behavior, even in code that looks completely harmless and intuitive. Asking the candidate to recognize <em>some</em> instance of this may be useful, whether it's the ""modify the same variable twice in the same expression"" example above, or something different.</p>
",10
366312,365823,1,"<ul>
<li>Design Patterns</li>
<li>Basics of C/C++</li>
<li>Virtual Functions</li>
<li>Poly morphism</li>
<li>Concepts from Scott Mayer's series</li>
<li>About templates.
(Not in particular order)</li>
</ul>

<p>Last but not the least. I will give some sample problem I tell them to design the classes. Just the interfaces.</p>
",3
730463,365823,3,"<p>As part of a phone screen for C++ positions I've taken to asking 'Who is Bjarne Stroustrup"".</p>

<p>I find it amazing that many many people claiming to be be senior C++ devs can't identify.  Hint for English speakers: Go to his FAQ and listen to the correct pronunciation before you ask the question. </p>
",0
1495661,1495621,1,"<p>If <code>maxSize</code> is a normal member of class X then you can't access it that way. You would have to pass it as another parameter to the function.</p>

<p>If <code>maxSize</code> is a static member of the class, then that code should work.</p>

<p>If this wasn't what you were asking, then you need to clarify your question and maybe add some more code showing what you're having trouble with.</p>

<hr>

<p><em>Edit:</em></p>

<p>In your new example, the line you marked ""illegal"" would actually compile the way you've written it. (It's declaring a local <code>X</code> pointer named <code>myX</code> which only exists inside that function.)</p>

<p>But I'm guessing you actually meant:</p>

<pre><code>int X::foo( const char * const key )
{
    myX = NULL;
}
</code></pre>

<p>And that would fail because <code>myX</code> is not a static variable. Static functions cannot access normal member variables. They can only access static variables.</p>

<p>You would need to revise your design:</p>

<ul>
<li>Either make <code>myX</code> a static member of <code>X</code> if that is appropriate in your program.</li>
<li>Or make <code>X::foo</code> a non-static member function.</li>
<li>Or add another parameter to <code>X::foo</code> through which you can get access to <code>myX</code>. There would be several ways depending how you want to design things. Here's an example: <code>int X::foo( const char * const key, X *&amp; theXpointer )</code></li>
</ul>
",0
1498865,1495621,0,"<p>You can't access member data in a static function. It only has access to static data and other static functions.  If you need a class function to act on members of an object, you shouldn't declare that function static, or you need to pass in that object as a parameter to the static function.</p>
",0
1498961,1495621,0,"<p>I'm not sure what you mean when you say ""access class object types.""  Your code as you wrote it will allow you to use the X type in the static X::foo function (of course, you have to return a value from it since you have declared that it returns an int).</p>

<p>As you've written it, you are declaring a pointer to an instance of X and from your code I'm not sure if that's what you've intended or what you will do with that pointer.</p>
",0
1970475,1970316,4,"<p>Your functions are more like <a href=""http://dinkumware.com/manuals/?manual=compleat&amp;page=string2.html#basic_string::find"" rel=""nofollow noreferrer""><code>std::string::find</code></a> than any of the iterator-based functions in the algorithm header. It returns an <em>index</em>, not an iterator.</p>

<p>I don't like that your function returns the collection size to emulate ""one past the end."" It requires the caller to know the collection size in order to check whether the function succeeded. I like your second function better since it returns a single constant value that always means ""not found."" The <code>std::string</code> type combines both of those by returning <a href=""http://dinkumware.com/manuals/?manual=compleat&amp;page=string2.html#basic_string::npos"" rel=""nofollow noreferrer""><code>std::string::npos</code></a>, which has a value of -1, but as an <em>unsigned</em> type.</p>

<p>Stay away from the exception approach of your third function unless you have some other function that call tell in advance whether the item <em>would</em> be found. That is, provide some way for callers to avoid the exception.</p>

<p>Your fourth function is most appropriate when the returned index would be useful even when the item <em>isn't</em> found. If you were doing a binary search, it could be useful to know the index where the item <em>would</em> be found if it were in the collection. Then you could provide an <code>insert</code> function that accepts that value as a hint, just like <a href=""http://dinkumware.com/manuals/?manual=compleat&amp;page=map.html#map::insert"" rel=""nofollow noreferrer""><code>std::map::insert</code></a>. If you can't provide that kind of information, then don't use that kind of function since it's just more cumbersome for callers to use. Prefer your first style instead.</p>
",0
1970503,1970316,2,"<p>Use something like boost.optional.</p>

<p>Read on what is the idea behind it, and how to implement it yourself, here:  <a href=""http://cplusplus.co.il/2009/12/04/boost-optional-and-its-internals/"" rel=""nofollow noreferrer"">http://cplusplus.co.il/2009/12/04/boost-optional-and-its-internals/</a></p>

<p>It also contains an example matching your exact question.</p>
",0
1970505,1970316,0,"<pre><code>std::pair&lt;size_t,bool&gt;

class ItemCollection
{
public:
    typedef std::pair&lt;size_t,bool&gt; RC;
    // Return size of collection if not found.
    RC getIndex(Item * inItem)
    {
        size_t idx = 0;
        for (; idx != mItems.size(); ++idx)
        {
            if (inItem == mItems[idx])
            {
                return RC(idx,true);
            }
        }
        return RC((-1),false);
    }
</code></pre>

<p>To me, in this day and age, using magic numbers is suspect</p>
",0
1970522,1970316,4,"<p>Do like the STL does.</p>

<p>In most case this means return an iterator one past the end.<br>
So it is comparable to end().</p>

<p>Your case is more like std::string where you are comparing against a const value.<br>
I would modify your -1 case (as magic numbers tend to be brittle). Make a static const member of your class (and don't define the value in the documentation, just say that it can only be returned on a find failure) and test against this constant. Then for version 1 of your class make this const -1.</p>

<pre><code>class ItemCollection
{
    static int const npos = -1;

    .....

    int getIndexV2(Item * inItem)  // returns npos on failure.

};
</code></pre>
",0
1970353,1970316,1,"<p>I think it depends on the context of what you are searching for. Is this information critical? If the information is critical, than you need to throw an exception, especially if not doing so would causes further errors down the line. </p>

<p>I like the return -1 if no match is found, just because you always will know exactly what that function will return if something isn't found. If you base it on the size of the collection, then you won't ever know exactly what is being returned there.</p>

<p>I'm also not a big fan of returning it in an output parameter, just because it's a bit more complicated, and you have to ask yourself if that added complexity is really needed for a function such as this. </p>
",0
1970382,1970316,1,"<p>One rule-of-thumb I've come to adopt is:</p>

<blockquote>
  <p>When in doubt, do as the STL does.</p>
</blockquote>

<p><code>std::find</code> returns an iterator beyond the end of the sequence.</p>

<p>The problem with deciding whether to throw an exception or return some sort of error value can be difficult.  Only the higher-level code knows if something is exceptional or not, but it's the lower-level code that has to make the decision.</p>
",1
1970383,1970316,1,"<p>In general, I would not use your first and fourth example for any situation. Returning the size of the collection is not communicating clearly enough that no item was found, IMO (think off by one errors). I see no need to return two outputs, when you can do the same by returning only one (as in <code>-1 = ItemNotFound</code>).</p>

<p>Which method you use of the remaining two depends on the exact situation in your program. If the item <strong>should</strong> be in your collection, this situation is <em>¨¨xceptional</em>. Throwing an exception would be ok in this case.</p>

<p>If on the other hand the item <strong>could</strong> be in your collection, this is a <em>regular</em> situation, so an exception is not adequate.</p>

<p>If you are writing a function that might be used in both situations, you should not throw an exception. Since you never know when you might need a function in some other context than you thought of first, my advise is to return -1 for <em>item not found</em>. You can also folow that approach for other functions, thus making your code base more consistent.</p>
",0
1970391,1970316,1,"<blockquote>
  <p>I mostly use the ""return size of collection"" approach because it is similar to how STL iterators work.</p>
</blockquote>

<p>Iterator, if you are using these as accessors/mutators, based algorithms return an iterator to one-past-the-end of the collection (which you can compare to <code>coll.end()</code>. That is definitely a good thing IMO. </p>
",0
1575024,1574976,5,"<p>For the type of hash collision you're using, deletion is problematic at best. Then again, this style of hashing doesn't do anything else very well either -- it leads to significant clustering even at relatively low loading ratios.</p>

<p>If you want to support deletion, you probably want to use chaining to resolve collisions. In this case, removal is simple and straightforward. You hash to find the right linked list, search for the item in the linked list, and (if you find it) remove it from the linked list.</p>

<p>Edit: Removal is more difficult than may be immediately obvious. For example, assume you want to remove something that hashed to position N in the table, but you find it at position N+3. There could, however, be something at position N+4 that (just for example) may have originally hashed to position N-1. So, if you insist on trying to delete from a table like this, you have to walk from wherever this hashed to all the way to the next empty spot in the table, and re-hash each of those item to figure out where it originally came from, and assure that if you remove something, every one of those chains remains intact from its original hash point to wherever it ended up.</p>

<p>It <em>is</em> possible to make this work -- but it's <strong>not</strong> easy. Given how poorly linear probing works in general, it's just not worth it!</p>
",2
1578652,1578635,10,"<p>As it is you are creating a separate copy of the variable in each compiled file. These are then colliding at the linking stage. Remember that the preprocessor reads in all the header files and makes one big file out of all of them. So each time this big file is compiled, another identical copy of <code>gMemoryManager</code> is created.</p>

<p>You need to use <code>extern</code> and define it in one non-header file.</p>

<p>In your header file</p>

<pre><code>extern DLL_EXPORT MemoryManager* gMemoryManager;
</code></pre>

<p>In one of your C++ files</p>

<pre><code>DLL_EXPORT MemoryManager * gMemoryManager;
</code></pre>

<p>By the way I have no idea what DLL_EXPORT does, I am just assuming it needs to go in both places.</p>
",3
1578667,1578635,2,"<p>This </p>

<pre><code>MemoryManager* gMemoryManager;
</code></pre>

<p><em>defines</em> a variable. If you do this in a header, the variable will be defined in each translation unit that includes that header, hence the linker errors. If you want to <em>declare</em> a variable, do it this way: </p>

<pre><code>extern DLL_EXPORT MemoryManager* gMemoryManager;
</code></pre>

<p>and put the definition into exactly one cpp file. </p>
",0
625867,625849,2,"<p>You're returning a stack-based pointer (a pointer that resides in the stack of the called process) that will be released whenever the <code>Marks::name()</code> method ends.</p>

<p>This is basic C/C++ memory management question, so I encourage you to read some books on the topic.</p>

<p>There are several ways of doing this correctly. For example, reserving the memory for the string in the calling function and passing this pointer to the function:</p>

<p>In the <code>main()</code> method:</p>

<pre><code>char name[30];
Marks test1;
test1.name(name);
</code></pre>

<p>(here <code>name</code> has the correct value) with the corresponding method:</p>

<pre><code>char* Marks::name(char* temp)
{
    cout&lt;&lt;""Enter a name:""&lt;&lt;endl;
    cin.getline(temp,30);
    return temp;
}
</code></pre>

<p>But there are other ways of managing static and dynamic memory for strings.</p>
",0
625868,625849,5,"<p>The problem is because the value that name is pointing to has been destroyed. You are returning the address of a local variable from <code>Marks::name()</code>. Most likely a side affect of the first <code>cout</code> is causing the contents of <code>name</code> to be destroyed. You're probably just getting lucky when the first <code>cout</code> is commented out.</p>

<p>The correct way to do this is to allocate some memory, return that, and then destroy it when you're done:</p>

<pre><code>char* Marks::name()
{
    char* temp = new char[30];
    cout&lt;&lt;""Enter a name:""&lt;&lt;endl;
    cin.getline(temp,30);
    return temp;
}

int main ()
{
    char *name;
    Marks test1;
    name=test1.name();

    cout&lt;&lt;""name:"";
    cout&lt;&lt;name&lt;&lt;endl;

    delete[] name;

    return 0;
}
</code></pre>

<p>Don't forget to use <code>delete[]</code>, rather than just <code>delete</code>, since otherwise only the first character would be deallocated.</p>
",2
625869,625849,1,"<p>Well, you have a pretty nasty bug in Marks::name() where you return a pointer to a temporary variable. temp will be destroyed at the exit of the function as it's going out of scope, so you are returning a pointer to a variable that doesn't exist anymore.</p>
",0
625871,625849,8,"<p>You are returning address of a local variable:</p>

<pre><code>char temp[30];
// ...
return temp;
</code></pre>

<p>This is a strict no-no in C or C++. The moment you come out of <code>Marks::name()</code> your <code>temp</code> variable goes BOOM! You can no longer access it -- doing that invokes Undefined Behavior. Try this,</p>

<pre><code>#include &lt;string&gt; // somewhere at the top
// ...
std::string Marks::name()
{
   std::string line;
   cout&lt;&lt;""Enter a name:""&lt;&lt;endl;
   std::getline(cout, line);
   return line;
}
</code></pre>
",6
625888,625849,0,"<p>All the answers so far are correct, but some of the ways of implementing this could have been better. I know its a very simple test application, but consider the following:</p>

<pre><code>char* Marks::name()
{
    char* temp = new char[30];
    cout&lt;&lt;""Enter a name:""&lt;&lt;endl;
    cin.getline(temp,30);
    return temp;
}

int main ()
{
    char *name;
    Marks test1;
    name=test1.name();

    cout&lt;&lt;""name:"";
    cout&lt;&lt;name&lt;&lt;endl;

    delete[] name;

    return 0;
}
</code></pre>

<p>Here, it is the function name() which is allocating the memory, but it is not deleting it. This is an inconsistancy which can lead to problems, especially in a more complicated senario. It might be better to do this (assuming you know ahead of time how much space you are going to give people to write in...)</p>

<pre><code>//this time, pass in some ALREADY allocated memory, and a length count.
void Marks::name(char *buf, int len)
{
    cout&lt;&lt;""Enter a name (max "" &lt;&lt; len &lt;&lt;"" letters):""&lt;&lt;endl;
    cin.getline(buf,len); //read into the memory provided
}

int main ()
{
    //preallocate your memory so that the same code that allocates...
    char *name = new char[30];
    Marks test1;
    test1.name(name, 30);

    cout&lt;&lt;""name:"";
    cout&lt;&lt;name&lt;&lt;endl;

    //... also deallocates it. This is perhaps cleaner in terms of responcibility.
    delete[] name;

    return 0;
}
</code></pre>

<p>In reality there is no right or wrong way to do this kind of thing. Sometimes a function has to allocate memory to use and return this for other applications to use, this is just an example where you should think about who is newing and try to make it consistant when coming to delete.</p>
",0
625900,625849,1,"<p>Marks::name() returns a pointer to a local variable. 
That memory will be freed when the function exits.</p>

<p>The reason you still get the right output as long as you don't call any functions in between your calls to Marks::name and cout::operator &lt;&lt; is that no other allocation claims that memory area.</p>

<p>You could use std::string instead of a char* if you intend to return a non-static string by value. </p>

<p>Alternatively, you could pass the char buffer to the name function as a char* and also pass the buffer's size and have Marks::name fill that buffer (e.g. using strncpy or strncpy_s)</p>

<pre><code>void Marks::name( char* buffer, int length )
{
  cout&lt;&lt;""Enter a name:""&lt;&lt;endl;
  cin.getline(buffer,length);
}

void main()
{
  char buffer[30];
  Marks::name( buffer, 30 );
}
</code></pre>
",1
1133210,1133002,5,"<p>Hmm, Eclipse's answer is gone, but I thought it was on the right track.</p>

<pre><code>class Base {
public:
    static Base *create() { return new Base; }
    static Base *create(size_t n) { return new Base[n]; }
private: 
    // Prevent heap allocation
    void *operator new(size_t s);
    void *operator new[](size_t s);
};
</code></pre>

<p>This isn't <em>nice</em>, as it obligates you to use <code>Base::create()</code> instead of <code>new Base</code>, and <code>class Derived</code> could still go and implement its own <code>public operator new</code>, but I think it's workable.</p>
",5
1133211,1133002,0,"<p>Here's one solution I found on the web: </p>

<p>Another standard new, the so-called ""placement-new,"" doesn't allocate memory at all, but can be called to invoke an object's constructor on an arbitrary piece of memory. It is typically defined as:</p>

<pre><code>inline void *
operator new(size_t, void *p)
{
  return p;
}
</code></pre>

<p>From <a href=""http://www.scs.stanford.edu/~dm/home/papers/c++-new.html"" rel=""nofollow noreferrer"">http://www.scs.stanford.edu/~dm/home/papers/c++-new.html</a> . </p>
",3
1133338,1133002,0,"<p>While there are ways to ""discourage"" heap allocation of an object in code (several good ones discussed and linked to here), there is no way to fully prevent it. There are some types such as shared_ptr&lt;T&gt; that I generally never want heap allocated (or perhaps a variant that I truly <em>never</em> want heap allocated). For these, the absolute best solution is understanding <em>and documenting why</em> you never want them heap allocated. With that in place, we never ran into problems because we were consistent about it.</p>
",1
1135444,1133002,0,"<p>how about privately derive Base?</p>

<pre><code>class Base {
public:
    void *operator new(size_t); 
};

class Derived : private Base {
public:
};
</code></pre>
",0
1136610,1133002,4,"<p>I feel bad for stealing <a href=""https://stackoverflow.com/questions/1133002/c-puzzle-prevent-heap-allocation-for-derived-classes-allow-automatic-and-stat/1133210#1133210"">ephemient's</a> thunder here, but the only thing &quot;wrong&quot; with his answer is that he's made Base's operator new private, and not Derived's:</p>
<p>The following code compiles except for the last line, which I think is what you require:</p>
<pre><code>#include &lt;new&gt;
#include &lt;vector&gt;

class Base {};

class Derived : public Base {
private:
  void * operator new (size_t);
};

void foo ()
{
    static Base sb;              // OK
    Base ab, *hb = new Base;     // OK
    static Derived sd;           // OK
    Derived ad;                  // OK
    Derived *pd = &amp;ad;           // OK

    struct Composite {
        Base cb;
        Derived cd;
    } *hc = new Composite;       // OK 

    std::vector&lt;Base&gt; vb;        // OK 
    std::vector&lt;Derived&gt; vd;     // OK


    Derived *hd = new Derived;   // Compile error
}
</code></pre>
<p><strong>UPDATE:</strong></p>
<p>As Tal points out, you can still call &quot;new Derived&quot; from a static member of Derived, however by not defining the &quot;operator new&quot; this will result in a link error.</p>
<p>But you can change the code slightly so that it generates a compile error (which is always preferable).  We can declare a placement operator new that will still stop us calling the usual operator new.</p>
<pre><code>class Derived : public Base {
public:
  static Derived * create ()
  {
    return new Derived;
  }

private:
  class dont_dynamically_allocate_type_derived;
  void * operator new (size_t, dont_dynamically_allocate_type_derived);
};
</code></pre>
<p>Using g++, the the above generates:</p>
<blockquote>
<p>t.cc: In static member function static Derived* Derived::create():</p>
<p>t.cc:10: error: no matching function for call to Derived::operator new(unsigned int)</p>
<p>t.cc:15: note: candidates are: static void* Derived::operator new(size_t, Derived::dont_dynamically_allocate_type_derived)</p>
</blockquote>
<p><strong>UPDATE (part duex):</strong></p>
<p>I cannot think of any construct where a base class propagates a property that it itself doesn't also have.  Tweaking the requirements slightly, if it's allowed to add an extra layer of inheritance you can create two leaf classes, one for Base the type that will be used to instantiate Base objects, and the other that is inherited from:</p>
<pre><code>class Base
{
public:

private:
  friend class BaseInstance;
  friend class BaseDerived;
  ~Base () {}
};

class BaseInstance : public Base
{
public:
  ~BaseInstance () {}
};

class BaseDerived : public Base
{
public:
  ~BaseDerived () {}

private:
  static void * operator new (size_t);
  static void * operator new[] (size_t);
};

class Derived : public BaseDerived {
public:
  static Derived * create ()
  {
    return new Derived;
  }
};
</code></pre>
<p>There is still a problem that people can derive from &quot;BaseInstance&quot;, although it's name could be made explicitly to stop that happening.  There's also the possibility that that class is on the other side of an API and so clients only ever get to see &quot;BaseDerived&quot;.</p>
",3
981811,981714,3,"<p>According to the standard (12.6.1 [class.expl.init] ) self initialization is perfectly legal.</p>

<p>Therefore the following is legal.</p>

<pre><code>A a = a;
</code></pre>

<p>You just need to write your copy constructor to deal with it correctly.</p>

<pre><code>A(const A&amp; rv)
{
    if(&amp;rv == this) {
        p = new int(0);
        return;
    }

    p = new int(*rv.p);
}
</code></pre>

<p>Edit: Updated code based on comments.</p>
",5
981738,981714,8,"<p>Your code is not calling the standard constructor but the copy constructor, so you are accessing an uninitialized pointer.</p>
",3
981756,981714,1,"<p><code>A a = a;</code> definitely should not be written. But <code>a = a</code> could be written.  Your assignment operator must check for <code>&amp;rv == this</code> and do nothing in case of a self-copy.</p>

<p>Oh, yes, you do need to write an assignment operator for class A.</p>
",4
981978,981714,3,"<p>Interesting reading on self-assignment: <a href=""http://www.gotw.ca/gotw/011.htm"" rel=""nofollow noreferrer"">http://www.gotw.ca/gotw/011.htm</a></p>

<p>In particular, note ""Postscript #1"" in relation to this question and some of the answers given.</p>
",0
1070397,1070363,1,"<p>when you view an XML page in IE it uses an XSLT to turn it into this kind of collapsible tree structure. This XSL can be viewed by entering this in the address bar:</p>

<pre><code>res://msxml.dll/DEFAULTSS.XSL
</code></pre>

<p>Personally I would use a similar method for your problem but if you must use C++ you can use the above to get an idea of what markup is required.</p>

<p><strong>EDIT</strong> - I should have mentioned this before, that if you wanted to use the XSL method, you'll need to pre-process the header file into xml. This might sound long-winded but the two layers mean you can switch the xsl out to change the way it looks on screen whilst keeping the code that arranges what you want displayed separate. Over-engineering for a simple test project - maybe.</p>
",4
1070404,1070363,2,"<p>You might want to checkout <strong>ctags</strong> and <strong>DOxygen</strong> because they create HTML from various source code files for documentation purposes. Probably has what you need, and ctags I am sure will have C++ bindings.</p>
",0
1070457,1070363,6,"<p>The hardest part will be parsing the C header files.  <a href=""http://www.gccxml.org/HTML/Index.html"" rel=""nofollow noreferrer"">GCCXML</a> will do that for you, outputting an XML structure that's then trivial to parse.</p>
",2
1070595,1070363,1,"<p>You could use <a href=""http://clang.llvm.org/"" rel=""nofollow noreferrer"">Clang</a>'s parser. It's supposed to have a pretty nice API.</p>
",0
731215,731208,1,"<p>Well I use pointers to member functions regularly with standard algorithms. There is nothing special about them as far as I am concerned.</p>
",0
731224,731208,3,"<p>Pointers to member function are great for creating psuedo lamba expressions with for_each</p>

<pre><code>vector&lt;SomeClass*&gt; v = getAVector();
for_each(v.begin(), v.end(), mem_fun(&amp;SomeClass::print));
</code></pre>
",3
731226,731208,1,"<p>You can bind member variables and functions with boost::bind and get usual functor.<br>
Next work with them will like on usual functions usage:  </p>

<ul>
<li>passing as callback or signal function;</li>
<li>using in standard algorithms;</li>
<li>using as comparator in std::map/set;   </li>
<li>using as data accessors; </li>
</ul>
",0
731232,731208,0,"<p>In addition to the previous, you can for example use them as callback functions.</p>
",0
731241,731208,3,"<p>The coolest thing I've done with them, I did a long time ago. There's probably a better way to do it today.</p>

<p>I created a self-generating command-line parser for a network management tool. The classes representing the objects to be managed each had their own tables of sub-classes (name, pointer-to-factory-member), instances (id, pointer to instance from a list), and commands (name, pointer to member function). This allowed the parser to handle things like:</p>

<pre><code>SET NETWORK ROUTE 192.168.0.0 HOPS 1
</code></pre>

<p>or</p>

<pre><code>QUERY NETWORK NAMESERVER servername
</code></pre>

<p>without knowing anything about routes, or name servers.</p>
",0
731370,731208,5,"<p>I once was needed to operate with criteria data as pure structure to be able to store the list of all criteria in the queue. And I had to bind the structure with the GUI and other filter elements, etc. So I came up with the solution where pointers to members are used as well as pointers to member functions. </p>

<p>Let's say you have an</p>

<pre><code>struct Criteria
{
    typedef std::string Criteria::* DataRefType;
    std::string firstname;
    std::string lastname;
    std::string website;
};
</code></pre>

<p>Than you can wrap criteria field and bind with the string representation of the field with  </p>

<pre><code>class Field
{
public:
    Field( const std::string&amp; name,
           Criteria::DataRefType ref ):
        name_( name ),
        ref_( ref )
    {}
    std::string getData( const Criteria&amp; criteria )
    {
        return criteria.*ref_;
    }
    std::string name_;
private:
    Criteria::DataRefType ref_;
};
</code></pre>

<p>Then you can register all the fields to use whenever you want: GUI, serialization, comparison by field names, etc.</p>

<pre><code>class Fields
{
public:
    Fields()
    {
        fields_.push_back( Field( ""First Name"", &amp;Criteria::firstname ) );
        fields_.push_back( Field( ""Last Name"", &amp;Criteria::lastname ) );
        fields_.push_back( Field( ""Website"", &amp;Criteria::website ) );
    }
    template &lt; typename TFunction &gt;
    void forEach( TFunction function )
    {
        std::for_each( fields_.begin(), fields_.end(),
                       function );
    }
private:
    std::vector&lt; Field &gt; fields_;
};
</code></pre>

<p>By calling for instance <code>fields.forEach( serialization );</code> or</p>

<pre><code>GuiWindow( Criteria&amp; criteria ):
    criteria_( criteria )
{
    fields_.forEach( std::bind1st( 
                         std::mem_fun( &amp;GuiWindow::bindWithGui ),
                         this ) );
}
void bindWithGui( Field field )
{
    std::cout &lt;&lt; ""name "" &lt;&lt; field.name_
              &lt;&lt; "" value "" &lt;&lt; field.getData( criteria_ ) &lt;&lt; std::endl;
};
</code></pre>
",0
731390,731208,0,"<p>I did it in a ""DomainEditor"" class for this huge application I wrote.  All my type (domain) tables in the database could be edited by the admins of the program and since the clients called some of the types by different names than others did, I made a dialog that allowed you to edit them.  Well, I didn't want to make an editor for the 15+ domain types, so I wrote a super-class that I could cast each class to, and using pointers I could make simple calls to each domain table.  Each one supported all the same properties, a Description (name), an ID, an Inactive flag, and a Required flag.  So, the code started with a Macro to setup my calls:</p>

<pre><code>#define DomainList(Class, Description, First, Next, Item, UpdateItem, DeleteItem, IsItemRequired, MaxLength) { \
   CWFLHandler *handler = new CWFLHandler; \
   handler-&gt;pWFL = new Class;\
   handler-&gt;LoadFirstType = (LoadFirst)&amp;Class::First;\
   handler-&gt;LoadNextType  = (LoadNext)&amp;Class::Next;\
   handler-&gt;LoadType      = (Load)&amp;Class::Item;\
   handler-&gt;UpdateType    = (Update)&amp;Class::UpdateItem;\
   handler-&gt;DeleteType    = (Delete)&amp;Class::DeleteItem;\
   handler-&gt;IsRequiredType= (IsRequired)&amp;Class::IsItemRequired; \
   handler-&gt;MAX_LENGTH    = MaxLength;\
   PopulateListBox(m_Domain, Description, (long)handler); }\
</code></pre>

<p>Then, lots of calls to the Macro: (Here is just a single one)</p>

<pre><code>   DomainList(CConfigWFL,   ""Application Parameter Types"",        LoadFirstParameterType,                   LoadNextParameterType,                 LoadParameterTypeByTypeId,                                        UpdateParameterType,                DeleteParameterType,                IsParameterTypeRequired,            LEN_APPL_PARAMETER_DESC);
</code></pre>

<p>Then, the calls to edit the data were all common, and I didn't have to duplicate any code at all...</p>

<p>For example, to populate the list with the selected item in the DropDownList (populated by the Macro), the code would look like this:</p>

<pre><code> if((pWFLPtr-&gt;pWFL-&gt;*pWFLPtr-&gt;LoadFirstType)(true))
  {
     do
     {
        m_Grid.AddGridRow();
        m_Grid.SetCheck(COLUMN_SYSTEM,         (pWFLPtr-&gt;pWFL-&gt;*pWFLPtr-&gt;IsRequiredType)(pWFLPtr-&gt;pWFL-&gt;TypeId));
        m_Grid.SetCheck(COLUMN_STATUS,      pWFLPtr-&gt;pWFL-&gt;InactiveIndc == false);
        m_Grid.AddTextToGrid(COLUMN_NAME,   pWFLPtr-&gt;pWFL-&gt;TypeDesc);
        m_Grid.AddTextToGrid(COLUMN_DEBUG,  pWFLPtr-&gt;pWFL-&gt;TypeId);
        m_Grid.AddTextToGrid(COLUMN_ID,     pWFLPtr-&gt;pWFL-&gt;TypeId);
     }
     while((pWFLPtr-&gt;pWFL-&gt;*pWFLPtr-&gt;LoadNextType)());
</code></pre>

<p>Of, course, this was all stored in a class that was part of the dialog.  And I simply created new instances of the class, stored them in the ListBox's ItemData member.  So, I did have to clean all that up when the dialog closed..  I left that code out of this message however.</p>

<p>The class to store all this stuff in was defined as:</p>

<pre><code>   typedef bool (CMyWFL::*LoadFirst)(bool);
   typedef bool (CMyWFL::*LoadNext)();
   typedef bool (CMyWFL::*Load)(long);
   typedef bool (CMyWFL::*Update)(long, const char*, bool);
   typedef bool (CMyWFL::*Delete)(long);
   typedef bool (CMyWFL::*IsRequired)(long);

   class CWFLHandler {
   public:
      CWFLHandler()  {};
      ~CWFLHandler() { if(pWFL) delete pWFL; }

      CMyWFL    *pWFL;
      LoadFirst   LoadFirstType;
      LoadNext    LoadNextType;
      Load        LoadType;
      Update      UpdateType;
      Delete      DeleteType;
      IsRequired  IsRequiredType;
      int         MAX_LENGTH;
   };
   CWFLHandler *pWFLPtr;
</code></pre>

<p>All this work made it really nice to be able to add new domains to the application with very little work to add them to the domain editor...  There may have been a better way, I don't know.  But this is the way I went, and it worked VERY well for me, and IMHO, it was very creative...  :)</p>
",0
733520,731208,0,"<p>I used them as part of a StructSerlialiser to populate C++ POD structures from SAX Parser events, i.e. to map XML onto a C++ data model.</p>

<pre><code>template&lt;class STRUCT, typename FIELDTYPE&gt;
struct FieldBinderImpl : public FieldBinder&lt;STRUCT&gt;
{
    typedef FIELDTYPE (STRUCT::*MemberPtr);

    FieldBinderImpl (const std::string&amp; tag, MemberPtr memberPtr)
        : FieldBinder (tag)
        , memberPtr_ (memberPtr)
    {
    }

    virtual SerialiserBase* createSerialiser (STRUCT&amp; data) const
    {
        return new Serialiser&lt;FIELDTYPE&gt; (&amp;(data.*memberPtr_));
    }

private:
    MemberPtr memberPtr_;
};

template&lt;class T&gt;
class StructSerialiser : public SerialiserData&lt;T&gt;
{
public:
    typedef std::vector&lt;FieldBinder&lt;T&gt;*&gt; FieldBinderList;

private:
    static FieldBinderList fieldBinderList_;

protected:
    template&lt;typename FIELDTYPE&gt;
    static void bind (const std::string&amp; tag, FIELDTYPE (T::* member))
    {
        fieldBinderList_.push_back (new FieldBinderImpl&lt;T, FIELDTYPE&gt; (tag, member));
        if (tag.empty ())
            fieldBinderList_.back ()-&gt;tags_ = Serialiser&lt;FIELDTYPE&gt;::getTags ();
    }

    // ...
}

// ...
</code></pre>

<p>Also had Serialisers for double, strings, vectors, etc. To use it you would just bind struct members to names, e.g.:</p>

<pre><code>class Index
{
public:
    std::string         currency;
    std::string         name;
};

template&lt;&gt;
class Serialiser&lt;Index&gt; : public StructSerialiser&lt;Index&gt;
{
public:
    Serialiser (Index* data) : StructSerialiser&lt;Index&gt; (data) {}

    static void initialise ()
    {
        bind (""currency"", &amp;Index::currency);
        bind (""name"", &amp;Index::name);
    }
};
</code></pre>
",0
640030,639937,3,"<p>First of all, use references for this type of thing, it reduces uneccessary code and can't be NULL.</p>

<p>onto the issue, to add to a vector, use push_back or some other method that adds to a vector, what you've done is try to assign to the vector:</p>

<pre><code>vector&lt;sStruct&gt; *addElement(vector&lt;sStruct&gt; &amp;vAddElement) {
    myStruct sAddElement;  // referring to the same struct.

    cout &lt;&lt; ""Enter a String: "";
    cin  &gt;&gt; sAddElement.feild1  // save user spec in struct member

    vAddElement.push_back(sAddElement);
    cout &lt;&lt; vectorAddress.size() &lt;&lt; endl;

    return &amp;vAddElement; // since you said you must return a pointer (which is silly)
                         // we'll return the address of the object passed in.
}
</code></pre>

<p><strong>EDIT:</strong> Why are you using pointers so much (at all) there is absolute no need in your
 program for any sort of dynamic allocation or taking the address of members. usual stack allocation and pass by reference would let you do the same work with half the code (and correctly).</p>

<p><strong>EDIT:</strong> Also, your loop is broken, you can't correctly test for EOF until <strong>after</strong> you attempted a read. It is easier to do something like:</p>

<pre><code>while(getline(file, line)) { /* process line */ }
</code></pre>

<p><strong>EDIT:</strong></p>

<p>also this code of yours isn't even close to what you think it does, 
I'll recomment it for you so you know:</p>

<pre><code>vector&lt;sStruct&gt; *addElement(vector&lt;sStruct&gt; *vAddElement) {    
    myStruct sAddElement;

    // ...

    vector&lt;sStruct&gt; vectorAddress;  // creates a new *vector* on the stack
    vAddElement = &amp;vectorAddress;   // makes vAddElement point to the new vector
                                    // but does *not* effect the vector whose
                                    // address you passed

    // ...

    vectorAddress.push_back( sAddElement ); // adds an element to the new vector
    cout &lt;&lt; vectorAddress.size() &lt;&lt; endl;   // it's size will always be 1, 
                                            // since you just added the first element

    (*vAddElement) = vectorAddress; // does absolutely nothing, you are assigning 
                                    // the new vector to itself

    return vAddElement;    // erroneously returns a pointer to the new vector
                           // it was allocated on the stack and no longer exists 
                           // after the return, **never do that **
}
</code></pre>
",3
959625,959621,0,"<p>Option 1: Use Java :)</p>

<p>Option 2: Use auto_ptr</p>

<pre><code>std::auto_ptr&lt;part1&gt; _ptr1;
std::auto_ptr&lt;part2&gt; _ptr2;

public:
addPart1()
{
   _ptr1 = auto_ptr&lt;part1&gt;(new part1);
}

...

// no destructor is needed
</code></pre>
",3
959631,959621,10,"<p>Use a smart pointer such as <a href=""http://www.boost.org/doc/libs/1_39_0/libs/smart_ptr/smart_ptr.htm"" rel=""noreferrer"">boost:shared_ptr , boost:scoped_ptr</a> is recommended to manage the raw pointer. <a href=""http://www.gotw.ca/publications/using_auto_ptr_effectively.htm"" rel=""noreferrer"">auto_ptr</a> is tricky to work with, you need pay attention to that.</p>
",5
959632,959621,2,"<p>Use construction is initialization instead.</p>

<pre><code>class Info
{
    private:
    part1* _ptr1;
    part2* _ptr2;    

    public:
    Info() : _ptr1(new part1), _ptr2(new part2)
    {
    }

    ~Info()
    {
      delete _ptr1; 
      delete _ptr2;
    }
};
</code></pre>

<p>But in this case you might as well create the parts on the stack, so no new and delete is required.</p>

<pre><code>class Info
{
    private:
    part1 _part1;
    part2 _part2;    

    public:
    Info()
    {
    }

    ~Info()
    {
    }
};
</code></pre>

<p>But I guess you want the pointers to be lazy created, then I wouldn't suggest to create public class methods that takes care of the initializations. This should be handled internally in the class, when the class need to allocate them.</p>
",0
959633,959621,4,"<p>Checking for nonzero pointer before delete is redundant. <code>delete 0</code> is guaranteed to be a no-op.</p>

<p>A common way to handle this is</p>

<pre><code>delete _ptr1;
_ptr1 = 0;
_ptr1 = new part1;
</code></pre>

<p>Zeroing the pointer ensures there won't be any dangling pointers for example in the case part1 construction throws an exception.</p>
",6
959641,959621,3,"<p>Your suggested fix will work (though of course you're still at risk for a memory leak if addPart2() is called twice). A much safer approach is to use scoped_ptr from the Boost library collection (www.boost.org), which is a container that acts like a pointer, but guarantees that its target is deleted when the container is destroyed. Your revised class would then look like</p>

<pre><code>class Info
{
    private:
    boost::scoped_ptr&lt;part1&gt; _ptr1;
    boost::scoped_ptr&lt;part2&gt; _ptr2;    

    public:
    Info() {}  // scoped_ptrs default to null

    // You no longer need an explicit destructor- the implicit destructor
    // works because the scoped_ptr destructor handles deletion

    addPart1()
    {
      _ptr1.reset(new part1);
    }

    addPart2()
    {
      _ptr2.reset(new part2);         
    }   
};
</code></pre>

<p>As a general principle, it's a good idea to avoid writing code that requires you to explicitly delete pointers. Instead, try to use containers that do it automatically at the appropriate time. Boost is a good resource for this kind of thing.</p>

<p>All this assumes you have a reason ptr1_ and ptr2_ need to be pointers. If not, it's much better to make them ordinary objects; then you get memory management for free.</p>
",0
959657,959621,5,"<p>You should read about the <a href=""http://www.google.co.il/url?sa=t&amp;source=web&amp;ct=res&amp;cd=1&amp;url=http%3A%2F%2Fen.wikipedia.org%2Fwiki%2FSmart_pointer&amp;ei=12wqSvT8HM-Q_QbLxrXwCg&amp;usg=AFQjCNGeVayKuk2pN0Uck0nTjqtKHgHhMg&amp;sig2=ACD0Z1-zMomIaoPhCXi-Vw"" rel=""nofollow noreferrer"">smart pointer idiom</a> and about <a href=""http://www.google.co.il/url?sa=t&amp;source=web&amp;ct=res&amp;cd=1&amp;url=http%3A%2F%2Fen.wikipedia.org%2Fwiki%2FResource_Acquisition_Is_Initialization&amp;ei=92wqSuvIEpGX_QaDtu3eCg&amp;usg=AFQjCNFKEzMHJRecJDAsT3j7pX_hkMAAYQ&amp;sig2=VFjOs746vaahJKTyuJR0yg"" rel=""nofollow noreferrer"">RAII</a>.
I suggest taking a look into the new technical report (TR1).<br>
Take a good look <a href=""http://beans.seartipy.com/2006/12/10/getting-started-with-c-tr1-libraries/"" rel=""nofollow noreferrer"">here</a> and <a href=""http://en.wikipedia.org/wiki/Technical_Report_1"" rel=""nofollow noreferrer"">here</a>.<br>
Also take a look at boost's smart pointers.<br>
I recommend <a href=""http://www.google.co.il/url?sa=t&amp;source=web&amp;ct=res&amp;cd=1&amp;url=http%3A%2F%2Floki-lib.sourceforge.net%2F&amp;ei=r2wqSvWvAdO0sgbl_cyeDA&amp;usg=AFQjCNEjR6zfmUsbZnO_cP3-wB0rqDKTnA&amp;sig2=4jBUZtTLxgyrP0IystDcPQ"" rel=""nofollow noreferrer"">loki-lib</a>'s SmartPtr or StrongPtr classes.</p>
",0
959698,959621,0,"<p>You should take a look at <a href=""http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization"" rel=""nofollow noreferrer"">RAII</a></p>
",0
959700,959621,1,"<p>If you want it to have a lazy behavior you might consider this:</p>

<pre><code>addPart1()
{
    if(_ptr1 == NULL) {
        _ptr1 = new part1;
    }
}
</code></pre>

<p>The way you suggested is also an alternative depending how you want it to behave.
But other people have suggested better ways to do it, but as we really don't know why you made it this way and how the surrounding code works ...</p>
",0
959708,959621,5,"<p>Bear with me here...</p>

<p>In the distant past, programmers used constructs like ""jump"" and ""goto"" for flow control.  Eventually common patterns emerged and constructs like for, do/while, function call and try/catch emerged, and the spaghetti was tamed.  Those named constructs give a lot more information about intent than a generic goto, where you have to examine the rest of the code for context to understand what it's doing.  In the unlikely event you see a goto in modern code by a competent coder, you know something pretty unusual is going on.</p>

<p>In my opinion, ""delete"" is the ""goto"" of memory management.  There are enough smart pointer and container classes available to the modern developer that there's very little reason for most code to contain a single explicit delete (other than in the smart pointer implementations of course).  When you see a plain ""delete"" you get no information about intent; when you see a scoped_ptr/auto_ptr/shared_ptr/ptr_container you get a lot more.</p>

<p>ie the idiom should be to aspire to write delete-free code by using appropriate smart pointer types (as recommended by just about every other answer here).</p>

<p><strong>Update 2013-01-27:</strong> I note Herb Sutter's <a href=""http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2012/-Not-Your-Father-s-C-"" rel=""nofollow noreferrer"">excellent talk on C++11</a> includes some similar sentiments re delete free code.</p>
",0
959834,959621,0,"<p>On the far extreme of possible ways to deal with memory leaks is the <a href=""http://www.hpl.hp.com/personal/Hans_Boehm/gc/"" rel=""nofollow noreferrer"">boehm</a> garbage collector, a conservative mark &amp; sweep collector.  Interestingly, this can be used in addition to all the good advice offered in other answers.</p>
",0
959926,959621,1,"<p>I agree with the group that you should use some kind of smart pointer.</p>

<p>If you do decide to continue with bare pointers, be aware that your class above does not have a copy constructor defined by you. Therefore, the C++ compiler has defined one for you that will just do a simple copy of all the pointers; which will lead to a double delete. You'll need to define your own copy constructor (or at least create a stub private copy constructor if you don't think you need a copy constructor).</p>

<pre><code>Info(const Info &amp;rhs)
{
  _ptr1 = new part1[rhs._ptr1];
  _ptr2 = new part2[rhs._ptr2];
}
</code></pre>

<p>You will have a similar problem with the default assignment operator.</p>

<p>If you choose the correct smart pointer, these problems will go away. :)</p>
",0
753336,753312,3,"<p>Yes in the second case it will make a copy of the object, possibly twice - once to return the value from the function, and again to assign it to the local copy in main.  Some compilers will optimize out the second copy, but in general you can assume at least one copy will happen.  </p>

<p>However, you could still use the second approach for clarity even if the data in the object is large without sacrificing performance with the proper use of smart pointers.  Check out the suite of smart pointer classes in boost.  This way the internal data is only allocated once and never copied, even when the outer object is.</p>
",0
753461,753312,50,"<p>The second approach is more idiomatic, and expressive. It is clear when reading the code that the function has no preconditions on the argument (it does not have an argument) and that it will actually create an object inside. The first approach is not so clear for the casual reader. The call implies that the object will be changed (pass by reference) but it is not so clear if there are any preconditions on the passed object.</p>

<p>About the copies. The code you posted is not using the assignment operator, but rather copy construction. The C++ defines the <a href=""http://en.wikipedia.org/wiki/Return_value_optimization"" rel=""noreferrer"">return value optimization</a> that is implemented in all major compilers. If you are not sure you can run the following snippet in your compiler:</p>

<pre><code>#include &lt;iostream&gt;
class X
{
public:
    X() { std::cout &lt;&lt; ""X::X()"" &lt;&lt; std::endl; }
    X( X const &amp; ) { std::cout &lt;&lt; ""X::X( X const &amp; )"" &lt;&lt; std::endl; }
    X&amp; operator=( X const &amp; ) { std::cout &lt;&lt; ""X::operator=(X const &amp;)"" &lt;&lt; std::endl; }
};
X f() {
    X tmp;
    return tmp;
}
int main() {
    X x = f();
}
</code></pre>

<p>With g++ you will get a single line <em>X::X()</em>. The compiler reserves the space in the stack for the <em>x</em> object, then calls the function that constructs the <em>tmp</em> over <em>x</em> (in fact <em>tmp</em> <strong>is</strong> <em>x</em>. The operations inside <em>f()</em> are applied directly on <em>x</em>, being equivalent to your first code snippet (pass by reference).</p>

<p>If you were not using the copy constructor (had you written: <em>X x; x = f();</em>) then it would create both <em>x</em> and <em>tmp</em> and apply the assignment operator, yielding a three line output: <em>X::X()</em> / <em>X::X()</em> / <em>X::operator=</em>. So it could be a little less efficient in cases.</p>
",3
753352,753312,-1,"<p>Your first snippet is especially useful when you do things like have getObjData() implemented in one DLL, call it from another DLL, and the two DLLs are implemented in different languages or different versions of the compiler for the same language.  The reason is because when they are compiled in different compilers they often use different heaps.  You must allocate and deallocate memory from within the same heap, else you will corrupt memory. <code>&lt;/windows&gt;</code></p>

<p>But if you don't do something like that, I would normally simply return a pointer (or smart pointer) to memory your function allocates:</p>

<pre><code>LargeObj* getObjData()
{
  LargeObj* ret = new LargeObj;
  ret-&gt;fillWithData() ;
  return ret;
}
</code></pre>

<p>...unless I have a specific reason not to.</p>
",1
753369,753312,15,"<p>Use the second approach. It may seem that to be less efficient, but the C++ standard allows the copies to be evaded. This optimization is called <a href=""http://www.google.com/search?q=NRVO"" rel=""noreferrer"">Named Return Value Optimization</a> and is implemented in most current compilers.</p>
",0
753372,753312,0,"<p>Alternatively, you can avoid this issue all together by letting the object get its own data, i. e. by making <code>getObjData()</code> a member function of <code>LargeObj</code>.  Depending on what you are actually doing, this may be a good way to go.</p>
",2
753374,753312,2,"<p>The way to avoid <strong>any</strong> copying is to provide a special constructor. If you 
can re-write your code so it looks like:</p>

<pre><code>LargeObj getObjData()
{
  return LargeObj( fillsomehow() );
}
</code></pre>

<p>If fillsomehow() returns the data (perhaps a ""big string"" then have  a constructor that takes a ""big string"". If you have such a constructor, then the compiler will very likelt construct a single object and not make any copies at all to perform the return. Of course, whether this is userful in real life depends on your particular problem.</p>
",0
753390,753312,0,"<p>Depending on how large the object really is and how often the operation happens, don't get too bogged down in efficiency when it will have no discernible effect either way. Optimization at the expense of clean, readable code should only happen when it is determined to be necessary.</p>
",0
753392,753312,0,"<p>The chances are that some cycles will be wasted when you return by copy. Whether it's worth worrying about depends on how large the object really is, and how often you invoke this code.</p>

<p>But I'd like to point out that if <code>LargeObj</code> is a large and non-trivial class, then in any case its empty constructor should be initializing it to a known state:</p>

<pre><code>LargeObj::LargeObj() :
 m_member1(),
 m_member2(),
 ...
{}
</code></pre>

<p>That wastes a few cycles too.  Re-writing the code as</p>

<pre><code>LargeObj::LargeObj()
{
  // (The body of fillWithData should ideally be re-written into
  // the initializer list...)
  fillWithData() ;
}

int main()
{
  LargeObj a ;
}
</code></pre>

<p>would probably be a win-win for you: you'd have the LargeObj instances getting initialized into known and useful states, and you'd have fewer wasted cycles.</p>

<p>If you don't always want to use <code>fillWithData()</code> in the constructor, you could pass a flag into the constructor as an argument.</p>

<p><strong>UPDATE</strong> (from your edit &amp; comment) : Semantically, if it's worthwhile to create a typedef for <code>LargeObj</code> -- i.e., to give it a name, rather than referencing it simply as <code>typedef std::vector&lt;HugeObj&gt;</code> -- then you're already on the road to giving it its own behavioral semantics. You could, for example, define it as</p>

<pre><code>class LargeObj : public std::vector&lt;HugeObj&gt; {
    // constructor that fills the object with data
    LargeObj() ; 
    // ... other standard methods ...
};
</code></pre>

<p>Only you can determine if this is appropriate for your app. My point is that even though <code>LargeObj</code> is ""mostly"" a container, you can still give it class behavior if doing so works for your application.</p>
",2
753808,753312,2,"<p>A somewhat idiomatic solution would be:</p>

<pre><code>std::auto_ptr&lt;LargeObj&gt; getObjData()
{
  std::auto_ptr&lt;LargeObj&gt; a(new LargeObj);
  a-&gt;fillWithData();
  return a;
}

int main()
{
  std::auto_ptr&lt;LargeObj&gt; a(getObjData());
}
</code></pre>
",0
1573271,1573225,8,"<p>__stdcall refers to the calling convention, and doesn't necessarily have to do with exporting functions.  Take a look at Wikipedia's article on <a href=""http://en.wikipedia.org/wiki/X86_calling_conventions"" rel=""nofollow noreferrer"">calling conventions</a> if you want to know more.  In brief, the compiler needs to know where to pass the parameters to your function, on the stack or in registers etc.</p>
",2
1573339,1573225,4,"<p>Think about it. The reason functions exported from a DLL has to have a fixed, known calling convention is so that users of the dll can call them. And likewise, with your WindowProc, it has to have a known calling convention so that Windows can call it. The same for WinMain. It has to be callable by the OS when it starts your program. :)</p>
",3
1573397,1573225,6,"<p><code>__stdcall</code> also helps to reduce size of the code in general on the X86 architecture.  Instead of each calling instance restoring the stack, the stack is restored only once at the end of the function before it returns.</p>

<p>Export from a DLL can also be <code>__cdecl</code> just as long as it is declared that way.  For example: <code>wsprintf()</code> is not exported as <code>WINAPI</code>.</p>
",1
708633,708573,1,"<p>This line:</p>

<pre><code>static void myMemberCounter;
</code></pre>

<p>Should generate a compile-time error. It looks like a variable, but has type <code>void</code>, which doesn't make sense.</p>

<p>If you want a static (""class variable"") counter, you should use a type like <code>int</code>. Then it would be easy for the class to use that counter to count the number of instances, by just incrementing the counter in the constructor. The count can be read by the outside world by adding a <code>public</code> class function to return it.</p>
",0
1677648,1677635,2,"<p>I've been developing on Microsoft stack since 1997, starting with C/C++/MFC/ATL, but all of the recent projects were on .NET platform (C#), so I would recommend learning .NET/C#. C/C++ still has its place, but it loses relevance rather rapidly. If not for legacy projects, we would not even bother with C/C++. Just my 2 cents.</p>
",2
1677687,1677635,2,"<p>If you want to get back into modern Windows programming you should learn C#/WPF.</p>
",0
1677689,1677635,1,"<p>If you're looking to get back into windows programming C# ASP.NET 3.5 is a fairly common and current language and framework to start with.  This is the direction that the masses of C# .NET guys have been migrating as of late and you may be able to find a wealth of communities and bloggers contributing to that scene.</p>

<p>From the sounds of it, however, it looks like you were doing something along the lines of game development (DirectX and C++).  Although more niche and slightly dated there are still a great deal of coders using the language.  One of my favorite stops is <a href=""http://www.gamedev.net"" rel=""nofollow noreferrer"">GameDev.net</a> because of the active community and active forums.</p>

<p>Good luck and have fun!</p>
",1
1679352,1677635,0,"<p>You could check out the VC++2010 beta, which comes with C++0x support and some <a href=""http://channel9.msdn.com/posts/Charles/Pat-Brenner-Visual-Studio-2010-MFC-and-Windows-7/"" rel=""nofollow noreferrer"">MFC updates</a>. 
Since you're experienced with Linux, you might want to check out <a href=""http://qt.nokia.com/products/platform/qt-for-windows"" rel=""nofollow noreferrer"">Qt for Windows</a> too. </p>
",1
1679617,1677635,0,"<p>I fancy <a href=""http://www.wxwidgets.org"" rel=""nofollow noreferrer"">wxWidgets</a> very much. It portable, effective and easy to learn especially if you've got some experience from MFC.</p>
",0
1610070,1609975,2,"<p>At the end of video, Sean Parent mentions <a href=""http://opensource.adobe.com/"" rel=""nofollow noreferrer"">http://opensource.adobe.com/</a></p>

<p>You can check out <a href=""http://stlab.adobe.com/"" rel=""nofollow noreferrer"">Adobe STLab</a></p>

<p>(BTW, I've ordered <em>Elements of Programming</em> and I'll receive it tomorrow ;-)</p>
",1
1610606,1609975,17,"<p>I was a proofreader for the book, and my feedback to Alex greatly influenced the style of presentation.  I am happy to call myself one of his disciples.  I find the material fascinating, and it has totally changed the way I write code, even Java code.</p>

<p>Some of Alex's ""methods"" are radical despite the vague wording I am providing:</p>

<ul>
<li>Progamming is about two things: algorithms and data structures.</li>
<li>Think very hard about every line of code you write.</li>
<li>Understand the structure of the problem you are trying to solve.</li>
<li>Good code is often rewritten to be better.</li>
<li>The goal is to write code that is both as general and as fast as possible.</li>
<li>Naming things correctly is very important.</li>
<li>Often the core of an algorithm is already a well-understood idea.</li>
<li>If your function computes something interesting, return it.</li>
</ul>

<p>How does that turn into source code?  My posts on StackOverflow were done after this improvement in my understanding, so you can read those if you want.  Otherwise, I'm not sure how to answer your question to your satisfaction.</p>
",0
1309982,1309960,4,"<p>Why are you rolling your own linked list? Why not use <code>std::list</code>?
If it's for the double-sorting thing, two separate lists of pointers would work, and be a hell of a lot easier if you can then use the provided container classes.</p>

<p>Or alternatively, if you need to sort it, is a linked list the best option? <code>std::vector</code> is often easier for sorting, or <code>std::set</code> maintains the order itself.</p>
",0
1310013,1309960,0,"<p>It looks like you have several problems here:</p>

<ol>
<li>It will always skip the while
statement since temp->nextByName
will always be NULL since temp
points to current which is a new
object.</li>
<li>You're creating a node
object from winery twice</li>
<li>You're
assigning the item member to winery
after you sent it in the constructor</li>
<li>You're making the nextByName and
nextByRating members point to itself</li>
</ol>

<p>I'd recommend removing everything from this method and writing high-level pseudo code in its place. Then create a smaller method for each line of pseudo code. Smaller logical methods called inside insert will help it make sense.</p>
",0
1310104,1309960,0,"<p>If you want to make your List type for experimentation, do it, otherwise use std::list.
<br>
If you want to keep your list sorted while you insert new elements then you have to implement an ordered list.
<br></p>

<p>It's better to remove ""winery field"" dependencies from your List. A node should have only one <em>next</em> node, not many. You are making a List, not a Tree.</p>

<pre><code>// list.h
struct node
{
    winery  item;
    node *  next;
};

class list
{
    ...
private:
    node * head;
};
</code></pre>

<p>You can't have one List ordered by different winery fields.<br>
Make a new type, like CWinery, which will act as a container for your winery records.<br>
In there, you can have a list to store your elements and methods to sort it or whatever you need.</p>
",0
1310270,1309960,0,"<p>If you are need to use list with several indexes you should consider using <a href=""http://www.boost.org/doc/libs/1_39_0/libs/multi_index/index.html"" rel=""nofollow noreferrer"">boost::multi_index</a> instead of inventing the wheel.</p>
",0
659447,659231,1,"<p>The reason for the compiler error is a circular dependency. Each of your operator=() functions require knowledge of the operator=() function inside the other class, so no matter which order you define your classes in, there will always be an error.</p>

<p>Here is one way to sort it out. It isn't very elegant, but it will do what you want:</p>

<pre><code>class A;
class B;

A &amp; set_equal(A &amp; a, const B &amp; b);
B &amp; set_equal(B &amp; a, const A &amp; a);

class A
{
    private:
        int x;
    public:
        A &amp; operator=(const B &amp; b) { return set_equal(*this, b); }
        friend B &amp; set_equal(B &amp; b, const A &amp; a);
        friend A &amp; set_equal(A &amp; a, const B &amp; b);
};

class B
{
    private:
        int y;
    public:
        B &amp; operator=(const A &amp; a) { return set_equal(*this, a); }
        friend A &amp; set_equal(A &amp; a, const B &amp; b);
        friend B &amp; set_equal(B &amp; b, const A &amp; a);
};

A &amp; set_equal(A &amp; a, const B &amp; b) { a.x = b.y; return a; }
B &amp; set_equal(B &amp; b, const A &amp; a) { b.y = a.x; return b; }
</code></pre>

<p>You may also be able to solve this problem with inheritance.</p>

<p><b>edit:</b> here is an example using inheritance. This will work if the copying procedure only needs access to some common data shared by both A and B, which would seem likely if the = operator is to have any meaning at all.</p>

<pre><code>class A;
class B;

class common
{
    protected:
        int x;
        void copyFrom(const common &amp; c) { x = c.x; }
};

class A : public common
{
    public:
        A &amp; operator=(const common &amp; c) { copyFrom(c); return *this; }
};

class B : public common
{
    public:
        B &amp; operator=(const common &amp; c) { copyFrom(c); return *this; }
};
</code></pre>
",0
659315,659231,2,"<p>There is no way to forward-declare member functions. I'm not sure if there is a more elegant way than this to get what you want (I've never had reason to do something like this), but what would work would be to make for the second class a non-member function that is a friend to both classes, and delegate copying to it. Note that operator= cannot be itself a non-member, but something like this should work:</p>

<pre><code>class B;

class A {
public:
  A&amp; operator = ( const B &amp;b );
  friend B&amp; do_operator_equals ( B&amp; b, const A&amp; b);
};

class B {
public:
  B &amp;operator = ( const A &amp;a );
  friend A&amp; A::operator = ( const B &amp;b );
  friend B&amp; do_operator_equals ( B&amp; b, const A&amp; a);
};
</code></pre>

<p>And then in your implementation file</p>

<pre><code>A&amp; A::operator= (const B&amp; b) {
   // the actual code to copy a B into an A
   return *this;
}

B&amp; B::operator= (const A&amp; a) {
   return do_operator_equals(*this, a);
}

B&amp; do_operator_equals(B&amp; b, const A&amp; a) {
  // the actual code to copy an A into a B
  return b;
}
</code></pre>

<p><strong>Edit:</strong> Got the A's and B's backwards, oops. Fixed.</p>
",1
659338,659231,-3,"<p>You don't forward declare the member function, you forward declare the class.</p>

<pre><code>class B;  // DECLARE class B but don't define its contents

class A { // ... uses B as above
};

class B { // ... now you define the class.
};
</code></pre>

<p>See the <a href=""http://www.parashift.com/c++-faq-lite/misc-technical-issues.html"" rel=""nofollow noreferrer"">C++ FAQ section 39</a>.</p>
",1
659339,659231,0,"<p>Why do you want them to be friends in the first place?<br>
This seem to be impossible the way you write it. The solution would probably be to not have them as friends at all. </p>
",1
1711084,1711058,8,"<p>I prefer <code>sizeof(variable)</code> over <code>sizeof(type)</code> wherever possible since it's less error prone, in case your variable changes type.</p>
",0
1711090,1711058,10,"<p>The only reason I can think of to avoid <code>sizeof(*this)</code> is that it could be misunderstood as the size of the actual object (e.g., a derived class).</p>
",0
1711285,1711058,3,"<p>My view is that sizeof( type ) is preferable to sizeof( variable ) in order to preclude ambiguity.  The following example shows an instance of a derived class referenced through a base class pointer.  The size method returns sizeof( Derived ) so sz1 == sz3 == sz4.  The caller could reasonably expect sizeof( Base ) if they have no insight into the implementation.</p>

<pre><code>class Base
{
  public:
    virtual size_t size( void )
    {
        return sizeof( *this ) ;
    }
  private:
    int    a ;
    double b ;
} ;

class Derived : public Base
{
  public:
    virtual size_t size( void )
    {
        return sizeof( *this ) ;
    }
  private:
    long c ;
  } ;

int main( int argc , char * argv[] )
{
    Base    b ;
    Derived d ;

    size_t sz0 = sizeof( Base ) ;
    size_t sz1 = sizeof( Derived ) ;
    size_t sz2 = b.size() ;
    size_t sz3 = d.size() ;

    Base * pb = &amp;d ;
    size_t sz4 = pb-&gt;size() ;
}
</code></pre>
",2
1780939,1780933,0,"<p>One way (and some may argue that the this is the C++ way) would be to prefix your class's fields with <code>m_</code> to disambiguate between the field and the constructor argument name.</p>
",0
1780943,1780933,1,"<p><a href=""http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml"" rel=""nofollow noreferrer"">Google style</a> is to make the members have the trailing underscore:</p>

<pre><code>public:
  A(int x) : x_(x) {
  }

private:
  int x_;
</code></pre>

<p>Much prettier.</p>
",3
1780945,1780933,3,"<p>You can actually do this the Java way in C++:</p>

<pre><code>public:
    A(int x)
    {
        this-&gt;x = x;
    }
</code></pre>

<p>But then it's also possible to just say x(x):</p>

<pre><code>public:
    A(int x) : x(x) { }
</code></pre>
",2
1780946,1780933,1,"<p>I don't think this is possible.  However, I would highly recommend using a consistent naming convention for member variables to differentiate them from parameters and local variables.</p>

<p>In my company we usually denote member variables with an 'm' prefix, e.g.:</p>

<pre><code>int mMyMemberVariable;
</code></pre>

<p>or</p>

<pre><code>int m_MyMemberVariable;
</code></pre>

<p>This is just an example of a style - consistency is the key.</p>
",0
1780947,1780933,5,"<p>In C++, you can, if you want:</p>

<pre><code>struct A {
  int x;
  A(int x) : x(x) {
    foo(this-&gt;x);
    // if you want the member instead of the parameter here
  }
};
</code></pre>

<p>Though I also commonly use stylistic names for members (e.g. <code>_x</code>), I do it for <em>non-public</em> members.  If <code>x</code> is public as in this example, I would do it like this, and look at renaming the ctor's parameter if I thought it would be more readable.</p>

<p><em>Edit:</em> Since people seem to be getting sidetracked, I'll clarify on <code>_x</code>.  The standard reserves some identifier names:</p>

<ul>
<li>any name with two adjacent underscores, in any namespace</li>
<li>any name with a leading underscore followed by an uppercase letter, in any namespace</li>
<li>any name with a leading underscore at global scope</li>
</ul>

<p>Since members are scoped to the class, they do not fall in the third category.  That said, it would be nice to not continue getting sidetracked. :)  Feel free to ask a question about reserved identifiers in C++ and post a link to it in the comments if you want.</p>
",11
1780964,1780933,3,"<p>C++ is smart enough to figure out which <code>x</code> you mean, you can write:</p>

<pre><code>class A {
  int x;
  A( int x ) : x(x) {};
};
</code></pre>
",0
975808,975792,17,"<p><a href=""http://www.parashift.com/c++-faq-lite/freestore-mgmt.html#faq-16.14"" rel=""noreferrer"">Section 16.14</a> of the C++ FAQ lite answers this:</p>

<blockquote>
  <p>There are two popular techniques that
  do this. Both these techniques are in
  use by commercial-grade compilers,
  both have tradeoffs, and neither is
  perfect. These techniques are:</p>

<pre><code>* Over-allocate the array and put n just to the left 
  of the first Fred object.
* Use an associative array with p as the key and n as the value.
</code></pre>
</blockquote>
",5
975815,975792,0,"<p>My guess is that new[] actually allocates more data than it seems.  It probably has a few bytes before the pointer that is returned that tells how many items are in the array.</p>
",0
975820,975792,21,"<p>It would delete an array of size 9.
It deletes the array pointed to by the pointer.</p>

<p>It is unspecified how the size information is stored, so each compiler may implement it in a different way, but a common way to do it is to allocate an extra block before the array. That is, when you do this:</p>

<pre><code>int* table = new int[5];
</code></pre>

<p>it actually allocates an array of 6 integers, and stores the array size in the first element. Then it returns a pointer to the second element. So to find the size, delete[] just has to read table[-1], basically.</p>

<p>That's one common way to do it, but the language standard doesn't specify that it <em>must</em> be done in this way. Just that it has to <em>work</em>.</p>

<p>Another approach might be to use the address of the array as a key into some global hash table. Any method is valid, as long as it produces the correct results.</p>
",1
975821,975792,4,"<p>How this is done is a compiler specific detail.  But the call to delete[], assuming no memory corruption, will always delete the right number of elements.  There are several ways to achieve this but one simple way is to hide the length in the memory.  </p>

<p>Here's a nice and simple way to implement this for demonstration purposes.  Say your code calls new int[10].  Instead of allocating 10 * sizeof(int), the compiler allocates (10 * sizefo(int))+sizeof(size_t).  It then returns a pointer to you which is offset size_t from the start.  Inside that initial size_t space it writes the number 10.  Now when you call delete[] and pass in a pointer, the compiler just goes backward size_t bytes and finds the number of elements to delete.</p>
",4
975823,975792,1,"<p>The mechanism is implementation-dependent, but it will not be ""fooled"", by you reassigning the pointer in your example. It will deallocate the array of size 9, just like you told it to (and in this case there will be a memory leak because the array of size 5 now has nothing pointing to it).</p>
",0
975831,975792,2,"<p>How delete[] works is implementation-dependent, but the global new operator associates a descriptor with the allocated memory in some way (in most cases, it's prepended to the allocated memory, or stored in a lookup table).  The descriptor contains the actual size of the memory that was allocated.</p>

<p>In your second code example, delete[] will correctly delete the nine-element array of int, and the original five-element array will be leaked.</p>
",0
975837,975792,0,"<p>You could imagine that the system store the size of the table in a structure like this:</p>

<pre><code>struct MemoryAllocated
  {
  size_t sizeOfMemory;
  char* yourData;
  }
</code></pre>

<p>each type your allocating some memory, the system returns a pointer to 'yourData'.
And each type your memory is 'free', the system shift the pointer to get the 'sizeOfMemory'. See also std::allocator</p>
",1
1711489,1711426,2,"<p>If you need many output formats for many classes, I would try to make it a n + m problem instead of an n * m problem.  The first way I come to think of is to have the classes reductible to some kind of dictionary, and then have a method to serlalize those dictionarys to each output formats.</p>
",0
1711536,1711426,1,"<p>I used OpenH323 (famous enough for VoIP developers) library for long enough term to build number of application related to VoIP starting from low density answering machine and up to 32xE1 border controller. Of course it had major rework so I knew almost anything about this library that days.</p>

<p>Inside this library was tool (ASNparser) which converted ASN.1 definitions into container classes. Also there was framework which allowed serialization / de-serialization of these containers using higher layer abstractions. Note they are auto-generated. They supported several encoding protocols (BER,PER,XER) for ASN.1 with very complex ASN sntax and good-enough performance.</p>

<p>What was nice?</p>

<ul>
<li>Auto-generated container classes which were suitable enough for clear logic implementation.</li>
<li>I managed to rework whole container layer under ASN objects hierarchy without almost any modification for upper layers.</li>
<li>It was relatively easy to do refactoring (performance) for debug features of that ASN classes (I understand, authors didn't intended to expect 20xE1 calls signalling to be logged online).</li>
</ul>

<p>What was not suitable?</p>

<ul>
<li>Non-STL library with lazy copy under this. Refactored by speed but I'd like to have STL compatibility there (at least that time).</li>
</ul>

<p>You can find Wiki page of all the project <a href=""http://en.wikipedia.org/wiki/OpenH323"" rel=""nofollow noreferrer"">here</a>. You should focus only on PTlib component, ASN parser sources, ASN classes hierarchy / encoding / decoding policies hierarchy.</p>

<p>By the way,look around ""Bridge"" design pattern, it might be useful.</p>

<p>Feel free to comment questions if something seen to be strange / not enough / not that you requested actuall.</p>
",1
1711601,1711426,1,"<p>Assuming you have full access to the classes that must be serialized. You need to add some form of reflection to the classes (probably including an abstract factory). There are two ways to do this: 1) a common base class or 2) a ""traits"" struct. Then you can write your encoders/decoders in relation to the base class/traits struct.</p>

<p>Alternatively, you could require that the class provide a function to export itself to a container of boost::any and provide a constructor that takes a boost::any container as its only parameter. It should be simple to write a serialization function to many different formats if your source data is stored in a map of boost::any objects.</p>

<p>That's two ways I might approach this. It would depend highly on the similarity of the classes to be serialized and on the diversity of target formats which of the above methods I would choose.</p>
",1
1722766,1711426,3,"<p>Reading through the already posted responses, I can only agree with a middle-tier approach.</p>

<p>Basically, in your original problem you have 2 distinct hierarchies:</p>

<ul>
<li>n classes</li>
<li>m protocols</li>
</ul>

<p>The naive use of a <code>Visitor</code> pattern (as much as I like it) will only lead to <code>n*m</code> methods... which is really gross and a gateway towards maintenance nightmare. I suppose you already noted it otherwise you would not ask!</p>

<p>The ""obvious"" target approach is to go for a <code>n+m</code> solution, where the 2 hierarchies are clearly separated. This of course introduces a middle-tier.</p>

<p>The idea is thus <code>ObjectA -&gt; MiddleTier -&gt; Protocol1</code>.</p>

<p>Basically, that's what Protocol Buffers does, though their problematic is different (from one language to another via a protocol).</p>

<p>It may be quite difficult to work out the middle-tier:</p>

<ul>
<li>Performance issues: a ""translation"" phase add some overhead, and here you go from 1 to 2, this can be mitigated though, but you will have to work on it.</li>
<li>Compatibility issues: some protocols do not support recursion for example (xml or json do, edifact does not), so you may have to settle for a least-common approach or to work out ways of emulating such behaviors.</li>
</ul>

<p>Personally, I would go for ""reimplementing"" the JSON language (which is extremely simple) into a C++ hierarchy:</p>

<ul>
<li>int</li>
<li>strings</li>
<li>lists</li>
<li>dictionaries</li>
</ul>

<p>Applying the <code>Composite</code> pattern to combine them.</p>

<hr>

<p>Of course, that is the first step only. Now you have a framework, but you don't have your messages.</p>

<p>You should be able to specify a message in term of primitives (and really think about versionning right now, it's too late once you need another version). Note that the two approaches are valid:</p>

<ul>
<li>In-code specification: your message is composed of primitives / other messages</li>
<li>Using a code generation script: this seems overkill there, but... for the sake of completion I thought I would mention it as I don't know how many messages you really need :)</li>
</ul>

<hr>

<p>On to the implementation:</p>

<p>Herb Sutter and Andrei Alexandrescu said in their <code>C++ Coding Standards</code></p>

<blockquote>
  <p>Prefer non-member non-friend methods</p>
</blockquote>

<p>This applies really well to the <code>MiddleTier -&gt; Protocol</code> step > creates a <code>Protocol1</code> class and then you can have:</p>

<pre><code>Protocol1 myProtocol;
myProtocol &lt;&lt; myMiddleTierMessage;
</code></pre>

<p>The use of <code>operator&lt;&lt;</code> for this kind of operation is well-known and very common. Furthermore, it gives you a very flexible approach: not all messages are required to implement all protocols.</p>

<p>The drawback is that it won't work for a dynamic choice of the output protocol. In this case, you might want to use a more flexible approach. After having tried various solutions, I settled for using a Strategy pattern with compile-time registration.</p>

<p>The idea is that I use a Singleton which holds a number of Functor objects. Each object is registered (in this case) for a particular <code>Message - Protocol</code> combination. This works pretty well in this situation.</p>

<hr>

<p>Finally, for the <code>BOM -&gt; MiddleTier</code> step, I would say that a particular instance of a <code>Message</code> should know how to build itself and should require the necessary objects as part of its constructor.</p>

<p>That of course only works if your messages are quite simple and may only be built from few combination of objects. If not, you might want a relatively empty constructor and various setters, but the first approach is usually sufficient.</p>

<hr>

<p>Putting it all together.</p>

<pre><code>// 1 - Your BOM
class Foo {};
class Bar {};

// 2 - Message class: GetUp
class GetUp
{
  typedef enum {} State;
  State m_state;
};

// 3 - Protocl class: SuperProt
class SuperProt: public Protocol
{
};

// 4 - GetUp to SuperProt serializer
class GetUp2SuperProt: public Serializer
{
};

// 5 - Let's use it
Foo foo;
Bar bar;

SuperProt sp;
GetUp getUp = GetUp(foo,bar);

MyMessage2ProtBase.serialize(sp, getUp); // use GetUp2SuperProt inside
</code></pre>
",2
1515673,1515656,1,"<p>AFAICT, <code>object_1</code> and <code>object_2</code> are unrelated classes (except that they are friends). So an <code>object_2</code> does not have any state relevant to an <code>object_1</code>.</p>

<p>Therefore, when you try to print an <code>object_2</code> as if it were an <code>object_1</code>, this cannot possibly work. It is surprising that this call works at all:</p>

<pre><code>ostream&amp; operator&lt;&lt;(ostream&amp; out, const object_2&amp; obj_2)
{
object1::display(out)  //Calls method display in object1's I.F.
return out;
}
</code></pre>

<p>since there is no <code>object_1</code> around here for which a method can be called (but then, you probably didn't mean this to be real code, since it's missing a semicolon also).</p>

<p>It's not completely clear what you want to achieve. Maybe you want <code>object_2</code> to inherit from <code>object_1</code>, so that any <code>object_2</code> will also have the members <code>pCh_mem1</code> etc? Maybe you want a member of <code>object_2</code> to be an object of type <code>object_1</code>?</p>
",3
1515718,1515656,0,"<pre><code>ostream&amp; operator&lt;&lt;(ostream&amp; out, const object_2&amp; obj_2)
{
    out &lt;&lt; object_1[thatIndexThatIstoreditAt]
    return out;
}
</code></pre>

<p>I need to write a few reports on this stuff. =)
</p>
",0
102038,102009,3,"<p>Use the heap for only allocating space for objects at runtime. If you know the size at compile time, use the stack. Instead of returning heap-allocated objects from a function, pass a buffer into the function for it to write to. That way the buffer can be allocated where the function is called as an array or other stack-based structure.</p>

<p>The fewer malloc() statements you have, the fewer chances for memory leaks. </p>
",0
102044,102009,70,"<p>Use the stack when your variable will not be used after the current function returns.  Use the heap when the data in the variable is needed beyond the lifetime of the current function.</p>
",4
102046,102009,4,"<p>This question is related (though not really a dupe) to <a href=""https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap"">What and where are the stack and heap</a>, which was asked a couple days ago.</p>
",0
102060,102009,0,"<p>The question is ill formed.</p>

<p>There are situations where you need the stack, others where you need the heap, others where you need the static storage, others where you need the const memory data, others where you need the free store.</p>

<p>The stack is fast, because allocation is just an ""increment"" over the SP, and all ""allocation"" is performed at invocation time of the function you are in. Heap (or free store) allocation/deallocation is more time expensive and error prone.</p>
",0
102061,102009,35,"<p>As a rule of thumb, avoid creating huge objects on the stack.</p>

<ul>
<li>Creating an object on the stack frees you from the burden of remembering to cleanup(read delete) the object. But creating too many objects on the stack will increase the chances of stack overflow.</li>
<li>If you use heap for the object, you get the as much memory the OS can provide, much larger than the stack, but then again you must make sure to free the memory when you are done. Also, creating too many objects too frequently in the heap will tend to fragment the memory, which in turn will affect the performance of your application.</li>
</ul>
",1
102145,102009,18,"<p>Use the stack when the memory being used is strictly limited to the scope in which you are creating it. This is useful to avoid memory leaks because you know exactly where you want to use the memory, and you know when you no longer need it, so the memory will be cleaned up for you.</p>

<pre><code>int main()
{ 
   if (...)
   {
      int i = 0;
   }
   // I know that i is no longer needed here, so declaring i in the above block 
   // limits the scope appropriately
}
</code></pre>

<p>The heap, however, is useful when your memory may be accessed outside of the scope of its creation and you do not wish to copy a stack variable. This can give you explicit control over how memory is allocated and deallocated.</p>

<pre><code>Object* CreateObject();

int main()
{
    Object* obj = CreateObject();
    // I can continue to manipulate object and I decide when I'm done with it

    // ..
    // I'm done
    delete obj;
    // .. keep going if you wish
    return 0;
}

Object* CreateObject()
{
   Object* returnValue = new Object();
   // ... do a bunch of stuff to returnValue
   return returnValue;
   // Note the object created via new here doesn't go away, its passed back using 
   // a pointer
}
</code></pre>

<p>Obviously a common problem here is that you may forget to delete your object. This is called a memory leak. These problems are more prevalent as your program becomes less and less trivial where ""ownership"" (or who exactly is responsible for deleting things)  becomes more difficult to define.</p>

<p>Common solutions in more managed languages (C#, Java) are to implement garbage collection so you don't have to think about deleting things. However, this means there's something in the background that runs aperiodically to check on your heap data. In a non-trivial program, this can become rather inefficient as a ""garbage collection"" thread pops up and chugs away, looking for data that should be deleted, while the rest of your program is blocked from executing.</p>

<p>In C++, the most common, and  best (in my opinion) solution to dealing with memory leaks is to use a smart pointer. The most common of these is <a href=""http://www.boost.org/doc/libs/1_36_0/libs/smart_ptr/shared_ptr.htm"" rel=""noreferrer"">boost::shared_ptr</a> which is (<a href=""http://en.wikipedia.org/wiki/Reference_counting"" rel=""noreferrer"">reference counted</a>)</p>

<p>So to recreate the example above
   boost::shared_ptr CreateObject();</p>

<pre><code>int main()
{
    boost::shared_ptr&lt;Object&gt; obj = CreateObject();
    // I can continue to manipulate object and I decide when I'm done with it

    // ..
    // I'm done, manually delete
    obj.reset(NULL);
    // .. keep going if you wish
    // here, if you forget to delete obj, the shared_ptr's destructor will note
    // that if no other shared_ptr's point to this memory 
    // it will automatically get deleted.
    return 0;
}

boost::shared_ptr&lt;Object&gt; CreateObject()
{
   boost::shared_ptr&lt;Object&gt; returnValue(new Object());
   // ... do a bunch of stuff to returnValue
   return returnValue;
   // Note the object created via new here doesn't go away, its passed back to 
   // the receiving shared_ptr, shared_ptr knows that another reference exists
   // to this memory, so it shouldn't delete the memory
}
</code></pre>
",0
102203,102009,8,"<p>as a rule of thumb use the stack whenever you can. i.e. when the variable is never needed outside of that scope.</p>

<p>its faster, causes less fragmentation and is going to avoid the other overheads associated with calling malloc or new. allocating off of the stack is a couple of assembler operations, malloc or new is several hundred lines of code in an efficient implementation.</p>

<p>its never best to use the heap... just unavoidable. :)</p>
",2
102753,102009,9,"<p>An exception to the rule mentioned above that you should generally use the stack for local variables that are not needed outside the scope of the function:</p>

<p>Recursive functions can exhaust the stack space if they allocate large local variables or if they are recursively invoked many times.  If you have a recursive function that utilizes memory, it might be a good idea to use heap-based memory instead of stack-based memory.</p>
",0
204364,204360,10,"<p>Looks to me like you are describing a fluent interface. Ive also heard it referred to as pipelineing or chaining.</p>

<p>Update-Gishu: <a href=""http://martinfowler.com/bliki/FluentInterface.html"" rel=""noreferrer"">http://martinfowler.com/bliki/FluentInterface.html</a> </p>
",3
204366,204360,10,"<blockquote>
  <p>It chains these method calls, which is why this is called <a href=""https://isocpp.org/wiki/faq/references#method-chaining"" rel=""nofollow noreferrer"">method chaining</a></p>
</blockquote>
",0
204372,204360,8,"<p>It's usually called method chaining. An example of its application is the <a href=""http://www.parashift.com/c++-faq-lite/ctors.html#faq-10.18"" rel=""noreferrer"">Named Parameter Idiom</a>.</p>

<p>As an aside, I find it amusing that searching in Google for ""object method1 method2"" comes up with exactly the page you were looking for. :)</p>
",0
204373,204360,1,"<p>The term you're looking for is <a href=""https://isocpp.org/wiki/faq/references#method-chaining"" rel=""nofollow noreferrer"">method chaining</a>.</p>
",0
204382,204360,2,"<p>chaining is a more common name in the industry and most developers have at least heard of it, while fluent interface is more academic and lots of people will have no idea what your talking about.</p>
",0
1402323,1402260,4,"<p>He was probably referring to the <a href=""http://www.parashift.com/c++-faq-lite/ctors.html#faq-10.12"" rel=""nofollow noreferrer"">Static Initialization Order Fiasco</a>.</p>

<p>I don't see a problem from what you've posted here.  You'd need dependencies on static variables in other translation units to have the fiasco problem.</p>
",0
1402507,1402260,1,"<p>Your code seems fine to me, and definitly way better than enums with reserved values in all ""layers"" of the system. Even though there was a problem using statics in this way, there would have been solutions, e.g. <a href=""http://en.wikipedia.org/wiki/Globally_Unique_Identifier"" rel=""nofollow noreferrer"">GUID</a>. You're idea was fine indeed. Remember, software architect is just a fancy name of a developer with an increase wage - it doesn't mean he's more skilled than you ;)</p>
",0
1402943,1402260,4,"<p>Is it important that the ""types"" be assigned the same IDs between different runs of your program?  If not, everything should be fine.  If so...</p>

<p>How are different ""types"" grabbing their IDs?  One way might be:</p>

<pre><code>class FooType
{
private:
    static UniqueId myId;
...
};
</code></pre>

<p>This invokes the <a href=""http://www.parashift.com/c++-faq-lite/ctors.html#faq-10.12"" rel=""nofollow noreferrer"">static initialization order fiasco</a> that Fred Larson linked to.   Since initialization order of statics is undefined, you might get different values assigned to myId from build to build, or if you're really unlucky, from run to run.</p>

<p>You might instead create instances of <code>UniqueId</code> only when needed, say in the object's constructor or as a method with a static variable.  For example:</p>

<pre><code>class BarType
{
private:
    const UniqueId &amp;getMyId()
    {
        static UniqueId myId;
        return myId;
    }
    ....
};
</code></pre>

<p>Now you might have to worry about thread safety (if you're developing a multithreaded program).  Aside from that, <code>UniqueId</code> values depend greatly on the flow of your program, and will quite likely change from run to run.  In one run of the program you may never need to instantiate <code>BarType</code>, and so it won't claim an ID.  In another run you may need a <code>BarType</code> early on; in another you may need a <code>BarType</code> later. </p>

<p>Even more sinister is that everything might work right for many builds, until you've forgotten all about this setup.  Someone adds a new ""type"", juggles some of the existing types, or quite possibly makes a completely unrelated change.  Then all of the sudden everything breaks for one of the reasons listed above.</p>
",4
1026139,1026136,0,"<p>You can just import single classes:</p>

<pre><code>using ourlib::networking::lpAddress;
</code></pre>

<p>At least if I remember correctly ;)</p>

<p>This might pollute the global namespace still, though. I tend to just live with the long namespace prefixes in header files. This makes it easier to read the header file for other developers (since you don't have to lookup which class comes from which namespace).</p>
",3
1026175,1026136,4,"<p>You <strong>may</strong> put, most of frequently use classes in ::ourlib namespace like</p>

<pre><code>namespace ourlib {
   using networking::lpAddress;
}
</code></pre>

<p>So, if they unique in the project, most likely you would not have problem. So in, any
place in headers you would be able access <code>lpAddress</code> directly without putting in into
global namespace (I assume all your headers inside <code>namespace ourlib</code>)</p>
",0
1619808,1619797,1,"<p>Sure, it applies to anything you try to do with the hash table.  Remove, delete (which sound like the same thing to me), insert, search, you name it.</p>
",3
1619823,1619797,1,"<p>Yes. Nearly any operation may require following these chains. The key is to select a table size and hash function such that chains are typically short (ideally, nearly all of them should have no more than one item).</p>
",0
1600413,1600399,19,"<p>If you are distributing static libraries, you may be able to distribute version-independent  libraries, depending on exactly what you are doing.  If you are only making calls to the OS, then you may be OK.  C RTL functions, maybe.  But if you use any C++ Standard Library functions, classes, or templates, then probably not.</p>

<p>If distributing DLLs, you will need separate libraries for each VS version.  Sometimes you even need separate libraries for various service-pack levels.  And as mentioned by VolkerK, users of your library will have to use compatible compiler and linker settings.  And even if you do everything right, users may need to link with other libraries that are somehow incompatible with yours.</p>

<p>Due to these issues, instead of spending time trying to build all these libraries for your users, I'd spend the time making them as easy to build as possible, so that users can can build them on their own with minimal fuss.</p>
",1
1600427,1600399,21,"<p>Not normally, no. Libraries built with the VS tools are linked into the 'Microsoft C Runtime' (called MSVCRT followed by a version number) which provides C and C++ standard library functions, and if you attempt to run a program that requires two different versions of this runtime then errors will occur.</p>

<p>On top of this, different compiler versions churn out different compiled code and the code from one compiler version frequently isn't compatible with another apart from in the most trivial cases (and if they churned out the same code then there would be no point having different versions :))</p>
",1
1600452,1600399,8,"<p>Generally it's not possible to link against libraries built with different compilers, different versions of the same compiler, and even different settings of the same compiler version and get a working application. (Although it might work for specific subsets of the language and std library.) There is no standard binary interface for C++ - not even one for some common platform as there are in C. </p>

<p>To achieve that, you either need to wrap your library in a C API or you will have to ship a binary for every compiler, compiler version, and compiler setting you want to support. </p>
",2
1692328,1692319,4,"<p>It appears that you want different overloads to be called depending on the path taken through the conditional structure. This is not possible in a static language like C++ because the compiler needs to decide which overload to call at <em>compile</em> time, and can only pick one for each call.</p>

<p>Do this instead:</p>

<pre><code>if (...) {
    int a = ...;
    f(a);
} else if (...) {
    char a = ...;
    f(a);
} else {
    double a = ...;
    f(a);
}
</code></pre>
",2
1692335,1692319,4,"<p>C++ is a statically typed language. If you want to deal with a variable its type must be known at compile-time. If the conditions you want to check for are also known at compile-time there's probably a nice solution involving templates. If the expressions in your if statements are runtime dependent you have to move the function call inside the blocks that declare a.</p>
",1
1692382,1692319,1,"<p>You can also make f() as template function and implement the function for different data types.</p>

<p>f(template class T)
{</p>

<p>}</p>
",0
1692387,1692319,3,"<p>you could use a union.</p>

<pre>
union my_type
{
   int i;
   char c;
   double d;
}

my_type a;
if(){
    a.i = ...;
} else if(){
    a.c = ...;
} else {
    a.d = ...;
}
f(a);
</pre>

<p>I don't know what f() will be doing, so I don't know if this will work in your situation. As someone else stated, templates are one option. Or you could try just type-casting instead of using a union.</p>
",2
1692393,1692319,3,"<p>Consider this instead:</p>

<pre><code>union T
{
  int i;
  double d;
  char c;
}

void process()
{
  T t;
  if(....) { work with t.i }
  else if(....) { work with t.d }
  else if(....) { work with t.c }

  f(t);
}

void f(T t)
{
  // now you have all your possible answers inside one variable
  // you might need to send a 2nd flag to mark the actual type inside
  // depending on your problem however, you might not need it

  // work with t.i, t.d or t.c
}
</code></pre>
",0
1692675,1692319,2,"<p>If you must have <code>f()</code> on the outside and don't want to use unions, you can consider polymorphism:</p>

<pre><code>class Base {};
class AInt : public Base { int a; };
class AChar : public Base { char a; };
class ADouble : public Base { double a; };

Base *p = NULL;
if(){
    p = new AInt();
} else if(){
    p = new AChar();
} else {
    p = new ADouble();
}

f(a, b, c);
</code></pre>

<p>Ofcourse for this to have any real OOP quality you'll have to add some virtual methods to the <code>Base</code> class and implement them in the inheriting class to do the actual work you need be done or else you'll have this switch again somewhere inside <code>f()</code>, probing the real type of <code>a</code>.</p>
",0
1692696,1692319,5,"<p>One way of doing what you seem to want is by defining a <a href=""http://www.cplusplus.com/doc/tutorial/templates/"" rel=""noreferrer"">template function</a>.  You define the template and the compiler will compile versions of the function for each type you call it with.</p>

<pre><code>template &lt;typename T_my_type&gt; T_my_type MyTemplateFunction(T_my_type a)
{
  a++;
  std::cout &lt;&lt; a;
  return a;
}

if(){
    int a;
    MyTemplateFunction(a);
} else if(){
    char a;
    MyTemplateFunction(a);
} else {
    double a;
    MyTemplateFunction(a);
}
</code></pre>

<p>In this case <code>T_my_type</code> is the template parameter and will be implicitly replaced with the type of the parameter that you call the function with.</p>

<p>Template programming in C++ is a rather large can of worms to open though, and as others have suggested, I think you may need to rethink your approach.</p>
",1
1693113,1692319,0,"<p>If it possible, define macros for your conditions. In that way you can use this syntax</p>

<pre><code>#if defined(CONDITION1)
    int a;
    f(a);
#elif defined(CONDITION2)
    char a;
    f(a);
#elif defined(CONDITION3)
    double a;
    f(a);
#endif
</code></pre>
",0
1693131,1692319,0,"<p>you can use boost library. For example
1. Boost::Any
boost::any a;</p>

<p>a=std::string(""A string"");
a=42;
a=3.1415;</p>

<p>f(a);
Link <a href=""http://www.boost.org/doc/libs/1_40_0/doc/html/any.html"" rel=""nofollow noreferrer"">http://www.boost.org/doc/libs/1_40_0/doc/html/any.html</a></p>

<ol start=""2"">
<li>Boost::Variant
boost::variant a;</li>
</ol>

<p>a=24;
a=2.52;
a=""Fabulous!"";
a=0;</p>

<p>f(a);</p>

<p>Link <a href=""http://www.boost.org/doc/libs/1_40_0/doc/html/variant.html"" rel=""nofollow noreferrer"">http://www.boost.org/doc/libs/1_40_0/doc/html/variant.html</a></p>
",0
1123712,1123700,1,"<p>Creating your own client / server application using socket programming is a big and fun area in programming which you should check out.</p>

<p><a href=""http://subjects.ee.unsw.edu.au/tele3118/wk6_sockets.pdf"" rel=""nofollow noreferrer"">http://subjects.ee.unsw.edu.au/tele3118/wk6_sockets.pdf</a></p>
",1
1123719,1123700,0,"<blockquote>
  <p>...but my problem is being able to
  view, fix, and add to code I haven't
  written myself.</p>
</blockquote>

<p>That is tough even for experienced programmers.<br>
A book that might help you is <a href=""https://rads.stackoverflow.com/amzn/click/com/0201799405"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">Code Reading: The Open Source Perspective</a> by <a href=""https://stackoverflow.com/users/20520/diomidis-spinellis"">Diomidis Spinellis</a>.</p>
",0
1123730,1123700,3,"<p>If you are already able to create own projects, I think the best way to learn how to read&amp;change someone's code is to get job in software company. They even will pay for it :)</p>
",0
1123833,1123700,0,"<p>Read <a href=""http://catb.org/esr/writings/taoup/html/"" rel=""nofollow noreferrer"">The Art of Unix Programming</a> ( TAOUP ). Its available online, well written and has lots of case  studies that represent well designed programs. You may also find some good C++ opensource software amongst those case studies. </p>

<p>Apart from TAOUP, take a look at <a href=""http://www.boost.org/"" rel=""nofollow noreferrer"">Boost C++ Libraries</a>. They provide peer reviewed source libraries that are very well documented.</p>

<p>Another one, I have heard is <a href=""http://www.postfix.org/"" rel=""nofollow noreferrer"">Postfix</a> ( an Open source email server for Unix ) that is said to have well written C++ code. Though, I must admit I do not have any direct experience with it.</p>

<p>Hope this helps :)</p>
",0
680917,680885,0,"<blockquote>
  <p>sort(myVector1.begin(),myVector1.end(),sortx);</p>
</blockquote>

<p>You need to tell <code>std::sort</code>, which you are using inside <code>main</code>, if you are going to use this form, that you want to use the member function <code>sortx</code>. Try:</p>

<pre><code>sort(myVector1.begin(),myVector1.end(), std::mem_fun_ref(&amp;QSweep::sortx));
</code></pre>

<p>Also, your sort function takes incorrect parameters:</p>

<blockquote>
  <p>bool sortx(const vector&lt; vector >&amp; edge1, const vector&lt; vector  >&amp; edge2)</p>
</blockquote>

<p>To sort your <code>vector</code> of <code>vector</code> of <code>int</code>s your <code>sortx</code> should take:</p>

<pre><code>bool sortx(const vector&lt;int&gt;&amp; edge1, const vector&lt;int&gt;&amp; edge2)
</code></pre>

<p>Also, note that you cannot use multiple indexes with a vector of vector as you can with multidimensional arrays. I think you have over complicated your problem :)</p>

<p>Here is a simplified solution for sorting your tuple Point type:</p>

<pre><code>#include &lt;iostream&gt;

#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

using namespace std;

template &lt;class _MyType&gt;
struct Point  {
    Point() {}

    void insert(_MyType const&amp; p) { 
        _pts.push_back(p); 
    }

    bool operator&lt;(Point&lt;_MyType&gt; const&amp; o) {
        return _pts[ 0 ] &lt; o._pts[ 0 ];
    }

private:
    typename vector&lt;_MyType&gt; _pts;
};

int main()
{
    Point&lt;int&gt; p;
    p.insert(1); p.insert(0); p.insert(2); // {1, 0, 2}
    Point&lt;int&gt; q;
    q.insert(-1); q.insert(10); q.insert(2); // {-1, 10, 2}
    vector&lt;Point&lt;int&gt; &gt; sweep;
    sweep.push_back(p);
    sweep.push_back(q);
    sort(sweep.begin(), sweep.end());    

    return 0;
}
</code></pre>
",0
680923,680885,0,"<p>At first sight, from your text, it seems that <code>static bool QSweep::sortx(...)</code> makes invalid use of <code>this</code> data members.  This explains the compiler error.  Note that in the source code you provided, the function isn't static.</p>

<p>At second sight, you cannot define an incomplete ordering to <code>std::sort</code>: if you say ""I don't care if my second member is bigger or smaller, if the first one is bigger, the whole object is bigger"", you leave the <code>sort</code> algorithm in the void for values that have <em>equal</em> first members.</p>

<p>That's why <code>sort</code> takes a <em>strict weak ordering</em>.  You have to define the order for values with an equal first member, too.</p>
",0
681023,680885,2,"<p>Your <code>order</code> functor is the right way do go; it just seems you have omitted to initialize its <code>o</code> member.</p>

<p>Have you tried:</p>

<pre><code>class order{
public:
  QSweep* o;
  order(QSweep* o_) : o(o_) {}
  bool operator() (const vector&lt;int&gt;&amp; edge1, const vector&lt;int&gt;&amp; edge2){
    return o-&gt;myPoints_[edge1[0]][0]&lt;o-&gt;myPoints_[edge2[0]][0];
  }
};

sort(myVector1.begin(),myVector1.end(),order(qsweep));
</code></pre>

<p>The comparison function is OK, <code>sort</code> doesn't require all elements to compare greater or less than others.</p>
",0
751117,751104,3,"<p>Don't use pointers, unless you have to. Use <code>vector</code> again:</p>

<pre><code>vector&lt;MxInt2d&gt; loops;
</code></pre>

<p>Right now, the <code>loops</code> container is empty (i.e. there are no matrices inside). If you want it to contain 2 <code>MxInt2d</code> object, you'll either have to insert them or initialize <code>loops</code> differently:</p>

<pre><code>// loops will contain two empty MxInt2d objects
vector&lt;MxInt2d&gt; loops(2);

// after the following command,
// loops will contain 3 MxInt3d objects
loops.push_back(MxInt2d());
</code></pre>

<p>Only after you've populated <code>loops</code> you can start populating its elements.</p>
",0
751125,751104,3,"<p>Before getting into your problem-- an observation:</p>

<p>Are you inheriting the vector ? Deriving vector is not a good idea. All the the standard STL containers, lacks a virtual destructor, and publicly inheriting from classes without virtual destructors is a major C++ no-no.</p>
",2
751126,751104,0,"<p>It's not a good idea to inherit from STL containers because they don't have virtual destructors, which can lead to underfined behaviour, if you try to delete a derived pointer through a base pointer (hope I got that right).</p>
",0
751130,751104,0,"<p>As it is, your data structure looks complex.  By creating a pointer of it, you are making it even more complicated.  It's better if you can create an array/vector of MxInt2d instead of making it a pointer.</p>
",0
751131,751104,0,"<p>No, not necessarily. std::vector will initialize all elements to 0, so if this is what you need, you won't have to write a custom constructor.</p>
",0
751310,751104,0,"<p>Arrays are evil in C++. You can use vector for almost anything that you can use array for. One common problem; that of initialization can be solved. Refer to this discussion <a href=""https://stackoverflow.com/questions/231491/how-to-initialize-const-stdvectort-like-a-c-array/661359#661359"">how-to-initialize std::vector like 'C' array</a>.</p>

<p>So, you can use 'vector loops;' without problems.</p>

<p>HTH,</p>
",0
752029,751104,0,"<p>You have a couple of problems here.</p>

<p>One, you should not derive from vector.  If you need code that does custom stuff with a vector, you should write a class with your custom stuff that has-a vector, not is-a vector.  For example:</p>

<pre><code>class Seq
{
public:
   // assorted constructors

// construct vec_ with zero elements
   Seq() {}; 

// construct vec_ with one element
   Seq(int singleItemToAdd) 
: vec_(1, singleItemToAdd) {};

// construct vec_ with 'multipleItemsToAdd' elements
   Seq(const int* multipleItemsToAdd, size_t numItemsToAdd) 
: vec_(multipleItemsToAdd,multipleItemsToAdd+numItemsToAdd) {}; 


   // assorted custom operations (instead of deriving from vector)
   void customSeqOperation() const
   {
      /// your custom stuff here
      :   :
   }
private:
   vector&lt;int&gt; vec_;
};
</code></pre>

<p>Next problem, you are saying this code compiles but crashes at runtime:</p>

<pre><code>vector&lt;MxInt2d&gt; loops;
for (int i=0;i&lt;5;i++)
  loops[0].push_back(myEdges_[i]);
</code></pre>

<p>If this is your essentially compete code, the reason why it crashes is because there is no element at loops[0] -- you haven't added it yet.  You need to add an element to loops (which is a vector) before you can access the first one:</p>

<pre><code>vector&lt;MxInt2d&gt; loops;
MxInt2d firstElement = getTheElement();
loops.push_back(firstElement);   
for (int i=0;i&lt;5;i++)
  loops[0].push_back(myEdges_[i]);
</code></pre>
",0
1386647,1386611,0,"<p>I think you are trying to do this all wrong. Your algorithm is likely to be extremely inefficient since you are doing a linear search repeatedly through the whole list. I would copy the list into an array, and then sort the array. Something like this:</p>

<pre><code>node *current_node  = headByName

std::vector&lt;node *&gt; list;
while (current_node)
{
  list.push_back(current_node);
  current_node = current_node-&gt;nextByName;
}

std::sort(list.begin(), list.end(), someKindOfSortByNameFunction);

std::foreach(list.begin(), list.end(), std::ostream_iterator&lt;node&gt;(out, std::endl));
</code></pre>
",4
1386694,1386611,1,"<p>I bet you won't benefit from my answer, but there are O(Nlog(N)) algorithms that are applicable to doubly-linked lists.</p>

<p>The first one is <a href=""http://en.wikipedia.org/wiki/Merge_sort"" rel=""nofollow noreferrer"">merge-sort</a>.  This algorithm is applicable not only to doubly-linked lists, but for any sets (if we assume the <a href=""http://en.wikipedia.org/wiki/Axiom_of_choice"" rel=""nofollow noreferrer"">Axiom of choice</a> ;-) ).  You select an arbitrary element from the list and then bulk your list into two piles: elements that are greater than the one picked and the elements that are greater that it.  Then you recursively sort these piles and <em>merge</em> them together.</p>

<p>The second one is <a href=""http://en.wikipedia.org/wiki/Quicksort"" rel=""nofollow noreferrer"">Hoare's quicksort</a>.  You pick an arbitrary element and iterate the list from its ends towards each other.  You swap values referenced by the iterators if first one is greater that selected value and the second one is lower (we sort ascendingly).  When iterators meet, you sort list to the left and list to the right in the same way.</p>
",0
886559,886546,1,"<p>Its a compilation error. You cant modify a non-lvalue.</p>
",3
886571,886546,0,"<p>there is no valid lvalue in that operation so it shouldn't compile.</p>

<p>the left hand side of an assignment must be... err... assignable</p>
",0
886574,886546,4,"<p>It has no meaning. That's an error. It's parsed as this</p>

<pre><code>(((int)0) = 0)
</code></pre>

<p>Thus, trying to assign to an rvalue. In this case, the right side is a cast of <code>0</code> to <code>int</code> (it's an int already, anyway). The result of a cast to something not a reference is always an rvalue. And you try to assign <code>0</code> to that. What Rvalues miss is an object identity. The following would work:</p>

<pre><code>int a;
(int&amp;)a = 0;
</code></pre>

<p>Of course, you could equally well write it as the following</p>

<pre><code>int a = 0;
</code></pre>

<p><strong>Update</strong>: Question was badly formatted. The actual code was this</p>

<pre><code>*(int*)0 = 0
</code></pre>

<p>Well, now it <em>is</em> an lvalue. But a fundamental invariant is broken. The Standard says</p>

<blockquote>
  <p>An lvalue refers to an object or function</p>
</blockquote>

<p>The lvalue you assign to is neither an object nor a function. The Standard even explicitly says that dereferencing a null-pointer (<code>(int*)0</code> creates such a null pointer) is undefined behavior. A program usually will crash on an attempt to write to such a dereferenced ""object"". ""Usually"", because the act of dereferencing is already declared undefined by C++. </p>

<hr>

<p>Also, note that the above is not the same as the below:</p>

<pre><code>int n = 0;
*(int*)n = 0;
</code></pre>

<p>While the above writes to something where certainly no object is located, this one will write to something that results from reinterpreting n to a pointer. The mapping to the pointer value is implementation defined, but most compilers will just create a pointer referring to address zero here. Some systems may keep data on that location, so this one may have more chances to stay alive - depending on your system. This one is not undefined behavior necessarily, but depends on the compiler and runtime-environment it is invoked in.</p>

<p>If you understand the difference between the above dereference of a null pointer (only constant expressions valued 0 converted to pointers yield null pointers!) and the below dereference of a reinterpreted zero value integer, i think you have learned something important. </p>
",1
886595,886546,3,"<p>It will usually cause an access violation at runtime. The following is done: first 0 is cast to an <code>int *</code> and that yields a null pointer. Then a value 0 is written to that address (null address) - that causes undefined behaviour, usually an access violation.</p>

<p>Effectively it is this code:</p>

<pre><code>int* address = reinterpret_cast&lt;int*&gt;( 0 );
*address = 0;
</code></pre>
",3
886612,886546,1,"<p>It puts a zero on address zero.  On some systems you can do this.  Most MMU-based systems will not allow this in run-time.  I once saw an embedded OS writing to address 0 when performing time(NULL).</p>
",0
732009,731971,0,"<p>Maybe it happened because expression result could be calculated without it.<br>
E.g.:</p>

<pre><code>false &amp;&amp; someFunction(); - function will not be called
true || someFunction(); - function will not be called
</code></pre>

<p>This is nice rule, it allow us write next:</p>

<pre><code>if ( ptr &amp;&amp; ptr-&gt;someMethod() ) 
// call method will not be called for NULL pointers
</code></pre>
",2
732018,731971,1,"<p>crikey! It looks quite complex, firstly have you tried with a less complex set of values to compute - ie I see you have cout statements, I trust that they work correctly when you run it?</p>

<p>If so, can iut be that your inputs to getSlope are wrong - shouldn't</p>

<pre><code>getSlope(myPoints_[edge2[0][0],myPoints_[edge2[0][1],    
         myPoints_[edge2[1]][0],myPoints_[edge2[1]][0])
</code></pre>

<p>be</p>

<pre><code>getSlope(myPoints_[edge2[0][0],myPoints_[edge2[0][1],    
         myPoints_[edge2[1]][0],myPoints_[edge2[1]][1])
</code></pre>
",1
680693,680672,4,"<p>sorry but why do you have 2 arrays (and 2 sizes)? Now if you create a derived class you have a 2 times a p_array. I think the compiler should give an error on this.</p>

<p>Don't you want this?</p>

<pre><code>class base
{
public:
     base():size(), p_array(0){}
     base(size_t array_size):size(array_size)
     {
          p_array.reset(new unsigned char[size]);
     }
private:
     size_t size;
     boost::shared_ptr&lt;unsigned char&gt; p_array;

};

class derived
{
public:
     derived(size_t array_size):base(array_size)
     {
     }
private:
};
</code></pre>
",7
680702,680672,3,"<p>You can pass the size to the base class' constructor:</p>

<pre><code>class base
{
   base(size_):size(size_), p_array(new char[size_]) {}
}
</code></pre>

<p>Your derive class determines the size, though it needs to know it upon base construction:</p>

<pre><code>class largebufferderived : public base
{
   public:
     largebufferderived() : base(77220) {}
}
</code></pre>

<hr>

<p>Or you can initialize the buffer on demand (that's not always a good idea in multithreaded scenarions):</p>

<pre><code>boost::shared_ptr&lt;char&gt; Buffer() 
{
   if (!p_Array)
     p_array.reset(new unsigned char[size]);
}
</code></pre>

<p>Make p_Array private in the base class, so derived classes can access only through Buffer().</p>

<hr>

<p>Alternatively, just add a ""FinalConstruct"" methood to call in the derived classes Constructors. Thi does not avoid calling it, but at least isolates WHAT needs to be done after all constructors were called.</p>

<p>btw. why shared_ptr, not shared_array?</p>
",5
599995,599664,1,"<p>Using a vector as you have done is almost certainly the best solution. oefe has given you a solution where you include some indirection in the Info's themselves, another option is to indirect in the map, i.e. <code>map&lt;ID, Info*&gt;</code> (or since you're using boost <code>map&lt;ID, shared_ptr&lt;Info&gt; &gt;</code>) and define Info like. Actually don't do this. Use a vector. It's the best solution. </p>

<pre><code> struct Info {
    const char *name;
    int flagCount;
    int flags[1]; // this is cheating...
 };   

 Info* make_info(int count) {
        char *buf = new char[sizeof(Info) + (sizeof(int) * (count - 1))];
        Info *rv = static_cast&lt;Info*&gt;(static_cast&lt;void*&gt;(buf));
        rv-&gt;flagCount = count;
 }
</code></pre>
",0
599723,599664,1,"<p>The elements in an array must be the same size as each other, otherwise you can't use <code>infos[i]</code> to access them - the compiler would have to step through the array and look at the size of each element up to <code>i</code> to find where the next one started. You can allocate enough memory for each element contiguously, and then create an array of pointers to the elements (pointers being a fixed size). If you only need the mapping and not to index the infos then your map will be identifier to pointer. </p>

<p>Alternatively, as you know the size at compile time, if there are only a few flags, make the <code>Info::flags</code> array large enough for the maximum flags, or make it a pointer to an array of flags, so that Info is a fixed size struct. </p>
",1
599923,599664,1,"<p>Either use a pointer to the variable-length array:</p>

<pre><code>struct Info
{
    const char* name;
    int flagCount;
    int *flags;
};
</code></pre>

<p>or fixed-size array large enough to hold all flags:</p>

<pre><code>struct Info
{
    const char* name;
    int flagCount;
    int flags[MAX_FLAGS];
};
</code></pre>

<p>Both solutions will waste some memory; but for solution 1, it's just one pointer per struct; note that you are already implicitly using this solution for the name field.</p>
",0
847853,847721,1,"<p>Naming conventions aside, if you're on a unix-like system, you can probably parse the output of:</p>

<pre><code>objdump -g mylib.a
</code></pre>

<p>If you only get empty lines or lines starting with object file names, then you have no debug information in the library.</p>

<p>Note that this does not generally mean that the library is ""release"" or ""debug"", but it <em>may</em> mean it in your case.</p>
",0
847740,847721,2,"<p>Can you not solve this using naming conventions (i.e., <code>foo_rel.a</code> and <code>foo_dbg.a</code> )?</p>
",0
847758,847721,0,"<p>Normally one would distinguish the versions using a slightly different names. For example under debug builds all the libraries are suffixed with a character 'd' before their extension. Ex. <code>commonUtilsd.lib</code> Under release mode the same would be <code>commonUtils.lib</code>. This approach IMHO is simpler and cleaner. In MSVC use can specify the output filename under </p>

<pre><code>Librarian--&gt;General--&gt;Output File
</code></pre>

<p>Another recommendation is to have these output files in the configuration directory. i.e. have debug-version in the Debug folder and release-versions under Release folder. Again under MSVC this can be done generically using the $(ConfigurationName) IDE-macro. And attach the right path in the lookup directories during build.</p>
",0
847766,847721,1,"<p>The normal approach is eithr to give the libraries different names or store them in different directories, such as Debug and Release. And if your build is correctly automated, I can't see how you can make mistakes.</p>
",1
848009,847721,4,"<p>Yes. You can check the <code>Characteristics</code> field of the <code>IMAGE_FILE_HEADER</code> structure of the file. If the library is a release build, then bit 0x0200 (<code>DEBUG_STRIPPED</code>) will be set; on a debug build, it will be clear.</p>

<p>You can find technical information on the PE Format used by Windows EXEs and DLLs, to see how to retrieve that structure, in various places on the 'net (such as <a href=""http://www.csn.ul.ie/~caolan/publink/winresdump/winresdump/doc/pefile.html"" rel=""nofollow noreferrer"">here</a>).</p>
",1
848300,847721,2,"<p>How about having a simple function which returns the version of the library? Return different things based on your build being debug or release. Call that function at the start of your app and report the error.</p>
",1
1799901,1799733,0,"<p>It's doable:</p>

<pre><code>int main()
{
  std::vector&lt;int&gt; v;
  for (int i = 1; i &lt;= 10; i++)
    v.push_back(i);

  int hits = 0;
  CountEven evens(&amp;hits);
  std::for_each(v.begin(), v.end(), evens);
  std::cout &lt;&lt; ""hits = "" &lt;&lt; hits &lt;&lt; std::endl;

  return 0;
}
</code></pre>

<p>But look at the nasty implementation of <code>CountEvens</code>:</p>

<pre><code>class CountEven {
  public:
  CountEven(int *hits) : hits(hits) {}
  CountEven(const CountEven &amp;rhs) : hits(rhs.hits) {}
  void operator() (int n) { if (n % 2 == 0) ++*hits; }

  private:
  int *hits;
};
</code></pre>

<p>Note that the copy constructor causes multiple instances to share the same pointer.</p>

<p>Use <a href=""http://www.sgi.com/tech/stl/count.html"" rel=""nofollow noreferrer""><code>std::count</code></a> or <a href=""http://www.sgi.com/tech/stl/count_if.html"" rel=""nofollow noreferrer""><code>std::count_if</code></a>.</p>
",0
1799905,1799733,3,"<p>If you want powerful foreach there is BOOST_FOREACH makro. Also boost is mostly header library so you can include only boost_foreach.hpp (afair) to your project. Example:</p>

<pre><code>BOOST_FOREACH( int &amp; i , my_vector )
{
     i = 0;
}
</code></pre>

<p>My_vector can be <code>vector&lt;int&gt;</code> or <code>int[]</code> or any other kind of iterator.</p>
",1
1799744,1799733,5,"<p>No. But you can make <code>myfunction</code> a functor, pass it a pointer to some memory, and store your return value through that pointer.</p>

<pre><code>struct MyFunctor {
    int *count;
    MyFunctor(int *count_) : count(count_) { }
    void operator()(int n) {
        if (n &gt; 5) (*count)++;
    }
};

int main() {
    vector&lt;int&gt; vec;
    for (int i=0; i&lt;10; i++) vec.push_back(i);
    int count = 0;
    for_each(vec.begin(), vec.end(), Myfunctor(&amp;count));
    printf(""%d\n"", count);
    return 0;
}
</code></pre>

<p><b>Edit:</b> As the comments have pointed out, my first example would've failed as <code>for_each</code> would have made a copy of <code>MyFunctor</code>, so we couldn't have retrieved the return value from our original object. I've fixed along the lines of the original approach; but you really should look at GMan's solution which is more elegant. I'm not sure about the portability, but it does work on my <code>gcc</code> (4.4.2). And as the others have mentioned, whenever possible, use what <code>&lt;algorithm&gt;</code> provides.</p>
",4
1799748,1799733,2,"<p>Isn't this what <a href=""http://en.wikipedia.org/wiki/Function_object#In_C_and_C.2B.2B"" rel=""nofollow noreferrer"">functors</a> are for ?</p>
",0
1799757,1799733,13,"<p>There is a special-purpose <code>std::count</code> (count occurrences of a value) and <code>std::count_if</code> (count when predicate returns true) for that. Don't abuse <code>std::for_each</code> for what it was not intended for.</p>
",1
1799766,1799733,9,"<p><code>for_each</code> will return a copy of the functor you passed it. This means you could do this:</p>

<pre><code>template &lt;typename T&gt;
class has_value
{
    has_value(const T&amp; pValue) : mValue(pValue), mFlag(false) {}

    void operator()(const T&amp; pX)
    {
        if (pX == mValue)
            mFlag = true;
    }

    operator bool(void) const { return mFlag; }
private:
    T mValue;
    bool mFlag;
};

bool has_seven = std::for_each(myvector.begin(), myvector.end(), has_value&lt;int&gt;(7));
</code></pre>

<p>For example. But for counting and the like, check out <a href=""http://www.cplusplus.com/reference/algorithm/"" rel=""noreferrer""><code>algorithm</code></a> and see if your function already exists. (Like <a href=""http://www.cplusplus.com/reference/algorithm/count/"" rel=""noreferrer""><code>count</code></a>)</p>
",6
1799768,1799733,0,"<p>Take a look at <a href=""http://www.cplusplus.com/reference/algorithm/"" rel=""nofollow noreferrer"">&lt;algorithm></a>.</p>

<p>I think <a href=""http://www.cplusplus.com/reference/algorithm/count_if/"" rel=""nofollow noreferrer"">std::count_if</a> is the one you are looking for.</p>
",0
1799830,1799733,1,"<p><code>std::for_each</code> isn't designed for that. Use <code>std::count</code> to count the number of elements which is equal to some value, or <code>std::count_if</code> to count the elements which satisfies some predicate:</p>

<pre><code>std::vector&lt;SomeType&gt; vec;
std::count(vec.begin(), vec.end(), SomeType(9));
/*or */
bool myfunc(const SomeType&amp; v)
{
    return v == 9;
}
std::count_if(vec.begin(), vec.end(), f);
</code></pre>

<p>If you just want to copy the contents of a container to an ostream object like <code>std::cout</code>, use std::copy instead:</p>

<pre><code>std::vector&lt;SomeType&gt; vec;
...
std::copy(vec.begin(), vec.end(), \
    std::ostream_iterator&lt;SomeType&gt;(std::cout,"" ""));
</code></pre>

<p>If you need the return value from each invocation of the function, use <code>std::transform</code>:</p>

<pre><code>std::vector&lt;SomeType&gt; src;
std::vector&lt;SomeType&gt; result;
int myfunc(int val)
{
    ...
}
std::transform(src.begin(), src.end() \
    result.begin(), myfunc);
</code></pre>

<p><code>std::transform</code> is also overloaded so it works for binary functions as well as unary functions.</p>
",0
1802798,1799733,1,"<p>Okay, I fear that you chose your example badly when you picked up a counting problem...</p>

<p>The problem is that <code>for_each</code> is extremely general and more specific algorithms exist for particular implementation (<code>count</code>, <code>accumulate</code>, <code>transform</code>, ...)</p>

<p>So let's pick up another example: <code>for_each</code> is typically used to apply a mutating operation on the objects it treats. It does not prevent you to collect statistics while doing so.</p>

<p>We have to take care, though <code>for_each</code> does return a <code>Predicate</code> object, there is no guarantee that this object was used on every item in the range. The implementation is free to copy the predicate around and use copies on part of the range... so the copy you are finally returned could be off the bat.</p>

<pre><code>class Predicate
{
public:
  Predicate(size_t&amp; errors) : m_errors(errors) {}
  void operator()(MyObject&amp; o)
  {
    try { /* complicated */ } catch(unfit&amp;) { ++m_errors; }
  }
private:
  size_t&amp; m_errors;
};

std::vector&lt;MyObject&gt; myVec;
// fill myVec

size_t errors = 0;
std::for_each(myVec.begin(), myVec.end(), Predicate(errors));
</code></pre>

<p>The trick here is that all copies of the original predicate will point to the same <code>size_t</code> variable, thus this variable has been correctly updated.</p>
",0
1803726,1799733,1,"<p>You <strong>can</strong> adapt <code>std::for_each</code> to do this as GMan showed.</p>

<p>But a better solution is to use the correct algorithm.</p>

<p>You should be able to use <code>std::count</code> or <code>std::count_if</code>, or perhaps <code>std::accumulate</code>.
These allow you to return one result for processing the entire sequence.</p>

<p>Alternatively <code>std::transform</code> allows you to return a result for each element in the sequence, creating a new output sequence containing the results.</p>
",0
697360,697343,9,"<p>If they are always two values, wouldn't it be more logical (and more useful) to return a <code>std::pair&lt;double, double&gt;</code>? This might save a lot of pain, especially related to explicit memory management (since you're using <code>new</code>/<code>delete</code>):</p>

<pre><code>std::pair&lt;double, double&gt; QSweep::computeIntersection(
    double m1, double b1, double m2, double b2
) {
    return std::make_pair( (b2-b1)/(m1-m2), (m1*b2-m2*b1)/(m1-m2));
}
</code></pre>
",0
697406,697343,1,"<p>Perhaps you should have a type called Intersection, which is done very quickly:</p>

<pre><code>typedef std::pair&lt;double, double&gt; Intersection
</code></pre>

<p>Or perhaps there should be something more explicit in there, because the members of pair are ""first"" and ""second"" and perhaps you might want something more descriptive.</p>

<p>In any case, you'd rather return these things by value than returning a pointer to heap-allocated memory.</p>
",0
697426,697343,0,"<p>Use a <code>vector</code> to maintain your history of doubles.  If you continue to use an array of doubles, to hold onto them, do something like this:</p>

<pre><code>std::vector&lt;double*&gt; history;
history.push_back(v);
</code></pre>

<p>Note, you will still need to <code>delete</code> the memory pointed to by each element when you are done with the vector (or individual vector elements).  In order to get around this, use a <code>pair</code> to track your original array of doubles (if you are just using two), or a <code>vector&lt;double&gt;</code>.</p>
",1
697719,697343,1,"<p>Your example doesn't include enough to be able to provide an answer to your question about why it's crashing.</p>

<p>The following example would ensure that there are no memory leaks from un-freed pointers, and keeps a similar structure.</p>

<pre><code>typedef std::pair&lt;double, double&gt; Intersection;
typedef std::vector&lt;Intersection&gt; Plane;

Intersection QSweep::computeIntersection
  ( double m1
  , double b1
  , double m2
  , double b2) 
{
    return Intersection( (b2-b1)/(m1-m2), (m1*b2-m2*b1)/(m1-m2));
}

main() 
{
  Plane plane;
  while( input ){
    plane.push_back( Intersection( ... ) );
  }
}
</code></pre>

<p>There could be other ways of storing this, for instance as you are using double, you could use calloc and realloc to maintain one piece of memory the right size. (don't recommend it given your example so far)</p>
",0
697438,697343,2,"<p>Your other option is to change the signature:</p>

<pre><code>void QSweep::computeIntersection(double m1, double b1, double m2, double b2, double&amp; return_v0, double&amp; return_v1)
{
    return_v0 = (b2-b1)/(m1-m2);
    return_v1 = (m1*b2-m2*b1)/(m1-m2);
}
</code></pre>
",0
697843,697343,0,"<p>Given that what you have is an array of two doubles, i wouldn't doubt there is a need to raise that number up at some time. Like, if at some point you decide to add 3d functions too. I would therefor prefer to stay with an array. But there is no need to use a dynamic array. Use an array wrapped in a struct like <code>boost::array</code>:</p>

<pre><code>boost::array&lt;double, 2&gt; QSweep::computeIntersection(
    double m1, double b1, double m2, double b2
) {
    boost::array&lt;double, 2&gt; array = { (b2-b1)/(m1-m2),  (m1*b2-m2*b1)/(m1-m2) };
    return array;
}
</code></pre>

<p>Then you can add it to a vector which will contain those:</p>

<pre><code>typedef std::vector&lt; boost::array&lt;double, 2&gt; &gt; vec_of_2darray_t;
vec_of_2darray_t v;
v.push_back(computeIntersection(a, b, c, d));
// ...
</code></pre>

<p>This is probably the best you can get if you aim for both simplicity and extensibility.<a href=""http://www.boost.org/doc/libs/1_38_0/doc/html/array.html"" rel=""nofollow noreferrer""><code>boost::array</code></a> is a pretty small and simple struct. It basically amounts to </p>

<pre><code>template&lt;typename T, size_t N&gt;
struct array { T data[N]; };
</code></pre>

<p>And several functions, of course, like <code>operator[]</code>, <code>begin()</code> and <code>end()</code> and other stuff. But without constructors, so that you can initialize it like a normal array as we did above. </p>
",0
701548,697343,0,"<p>thank you:),
it worked with push_back the value obtained each time in a new vector of type </p>

<pre><code>vector &lt;double *&gt;,
</code></pre>

<p>madalina</p>
",0
701725,701699,1,"<p>The assignment operator is just a function with a funny name. If you can call a function on a temporary (which you can), then you can assign to a temporary, given a suitable operator=().</p>
",0
701745,701699,3,"<p>This kind of thing is ubiquitous in many object-oriented programming languages, especially those with object overloading.</p>

<p>If the first statement were written</p>

<pre><code>Text x = Test(5).add(Test(5)).set(8);
</code></pre>

<p>where .add and .set return the lefthand Test instances with the expected values, would you still be confused?</p>

<p>To break this example down, you're creating a Test object with value 5, then adding another Test object with value 5 to it, and returning the first Test object, now with value 10. Then you're setting its value to 8, and assigning that object to x (well actually it's not assignment, again you're creating a Test object named x, then setting its value to the temporary's value).</p>
",0
701768,701699,8,"<p>Let's go line by line:</p>

<pre><code>    Test x = Test(5) + Test(5) = 8;//assign to a temporary
</code></pre>

<p>There's no big deal here.  Temporaries are still just normal objects, and thus the assignment operator works on them just as it would on anything else.</p>

<pre><code>    Test&amp; xRef = Test(5) + Test(5);//reference to a temporary
</code></pre>

<p>Like Metroworks, my GCC doesn't allow a non-const reference to a temporary.</p>

<pre><code>    Test* xPtr = &amp;(Test(5) + Test(5));//address of a temporary
</code></pre>

<p>In addition, GCC warns about taking the address of a temporary, for obvious reasons.</p>

<pre><code>   Test(5) = Test(10);//assign to a temporary
</code></pre>

<p>Again, this is just assignment, which, as I explained above, is no big deal.</p>

<pre><code>    Test(8).non_const_function();//call a non-const function
</code></pre>

<p>Temporary objects aren't constant.  There's nothing stopping them from calling non-const functions.</p>
",0
701775,701699,1,"<p>My reading of your question tells me you are confused with the lifetime of temporaries more than anything else. I think it will help if you put a couple of <code>cout</code>s as below:</p>

<pre><code>struct Test{
    int i;
    Test(int ii):i(ii){ std::cout &lt;&lt; ""new object\n""; }
    Test&amp; operator=(int ii){
        i = ii;
        return *this;
    }
    Test operator+(const Test&amp; rhs){
        return Test(i + rhs.i);
    }
    void non_const_function(){
        i *= i;
    }
    ~Test() { std::cout &lt;&lt; ""deleting ...\n""; }
};
</code></pre>

<p>Now run, and you should be able to see what exactly is going on under the hoods. (Style Check:Not checking for self-assignment is not a good thing.)</p>

<p>It will also help if you refer the standard: It discusses something similar to what you have posted:</p>

<blockquote>
  <p><strong>12.2 Temporary objects</strong></p>
  
  <p>4 There are two contexts in which temporaries are destroyed at a different point than the end of the fullexpression. The first context is when a default constructor is called to initialize an element of an array. If the constructor has one or more default arguments, the destruction of every temporary created in a default argument expression is sequenced before the construction of the next array element, if any.</p>
  
  <p>5 The second context is when a reference is bound to a temporary. The temporary to which the reference is bound or the temporary that is the complete object of a subobject to which the reference is bound persists for the lifetime of the reference except as specified below. A temporary bound to a reference member in a constructor¡¯s ctor-initializer (12.6.2) persists until the constructor exits. A temporary bound to a reference parameter in a function call (5.2.2) persists until the completion of the full-expression containing the call. A temporary bound to the returned value in a function return statement (6.6.3) persists until the function exits. A temporary bound to a reference in a new-initializer (5.3.4) persists until the completion of the
  full-expression containing the new-initializer.</p>
</blockquote>

<pre><code> struct S { int mi; const std::pair&lt;int,int&gt;&amp; mp; };
 S a { 1, {2,3} };
 S* p = new S{ 1, {2,3} }; // Creates dangling reference
</code></pre>

<blockquote>
  <p>[ Note: This may introduce a dangling reference, and implementations are encouraged to
  issue a warning in such a case. ¡ªend note ] The destruction of a temporary whose lifetime is not extended by being bound to a reference is sequenced before the destruction of every temporary which is constructed earlier in the same full-expression. If the lifetime of two or more temporaries to which references are bound ends at the same point, these temporaries are destroyed at that point in the reverse order of the completion of their construction. In addition, the destruction of temporaries bound to references shall take into account the ordering of destruction of objects with static, thread, or automatic storage duration (3.7.1, 3.7.2, 3.7.3); that is, if <code>obj1</code> is an object with the same storage duration as the temporary and created before the temporary is created the temporary shall be destroyed before <code>obj1</code> is destroyed; if <code>obj2</code> is an object with the same storage duration as the temporary and created after the temporary is created the temporary shall be destroyed after <code>obj2</code> is destroyed. <em>Example:</em></p>
</blockquote>

<pre><code> struct S {
    S();
    S(int);
    friend S operator+(const S&amp;, const S&amp;);
    ~S();
 };
 S obj1;
 const S&amp; cr = S(16)+S(23);
 S obj2;
</code></pre>

<blockquote>
  <p>the expression <code>C(16)+C(23)</code> creates three temporaries. A first temporary <code>T1</code> to hold the result of the expression <code>C(16)</code>, a second temporary <code>T2</code> to hold the result of the expression <code>C(23)</code>, and a third temporary <code>T3</code> to hold the result of the addition of these two expressions. The temporary <code>T3</code> is then bound to the reference <code>cr</code>. It is unspecified whether <code>T1</code> or <code>T2</code> is created first. On an implementation where <code>T1</code> is created before <code>T2</code>, it is guaranteed that <code>T2</code> is destroyed before <code>T1</code>. The temporaries <code>T1</code> and <code>T2</code> are bound to the reference parameters of <code>operator+</code>; these temporaries are destroyed at the end of the full-expression containing the call to <code>operator+</code>. The  temporary <code>T3</code> bound to the reference <code>cr</code> is destroyed at the end of <code>cr</code>¡¯s lifetime,
  that is, at the end of the program. In addition, the order in which <code>T3</code> is destroyed takes into account the destruction order of other objects with static storage duration. That is, because <code>obj1</code> is constructed before <code>T3</code>, and <code>T3</code> is constructed before <code>obj2</code>, it is guaranteed that <code>obj2</code> is destroyed before <code>T3</code>, and that <code>T3</code> is destroyed before <code>obj1</code>.</p>
</blockquote>
",3
701883,701699,3,"<p>Regarding the first case, assigning to a temporary, I recall from my Effective C++ that it is good practice to declare your operators like</p>

<pre><code>const Test operator+(const Test&amp;) const
</code></pre>

<p>This will make the objects behave like built-in types in that respect, at least.</p>
",0
701969,701699,0,"<p>Take a look at the <a href=""http://www.gotw.ca/gotw/004.htm"" rel=""nofollow noreferrer"">GotW #4</a> which discusses the mechanics creating a user-defined class that most closely mirrors built-in arithmetic types.  If you take his advice, your Test struct would look more like this:</p>

<pre><code>struct Test{
    ...
    Test&amp; operator+=( const Test&amp; other ) {
        i += other.i;
        return *this;
    }
    ...
};

const Test operator+( const Test&amp; lhs, const Test&amp; rhs ) {
    Test ret( lhs );
    ret += rhs;
    return ret;
}
</code></pre>

<p>Now Test behaves much better in the addition situations (lines 1, 2, and 3 fail to compile).   This is one of the rare instances where returning a const copy is actually useful,</p>
",0
1529000,1528981,1,"<p>Is the values at line:</p>

<pre><code>getSymbol = h.hashTable[hashIndex].getSymbol();
</code></pre>

<p>fine, but crap afterwards?</p>

<p>You could be having a case where you have a const char* to something inside an anonymous variable, which gets deleted when the line is done.</p>
",3
1529048,1528981,5,"<p>Make sure the stream is set to print in decimal</p>

<pre><code>out &lt;&lt; dec &lt;&lt; s.m_sharePrice;
</code></pre>

<p>(<code>m_sharePrice</code> is a non-pointer type, right?)</p>
",1
1428791,1428786,17,"<p>Use <a href=""http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes"" rel=""noreferrer"">sieve of Eratosthenes</a> is if you want to enumerate primes. If you want to generate a large prime, generate a random odd number and <a href=""http://en.wikipedia.org/wiki/Primality_test"" rel=""noreferrer"">check for primality</a>.</p>
",4
1428804,1428786,13,"<p>If it's below a certain range, best way would be to look it up in a precomputed list. There's plenty of them, up to very high numbers.<p>
Example, all the primes up to 10,000,000,000 at <a href=""http://www.prime-numbers.org/"" rel=""noreferrer"">http://www.prime-numbers.org/</a></p>
",0
1428814,1428786,45,"<p>When it comes to finding prime numbers, the <a href=""http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes"" rel=""noreferrer"">Sieve of Eratosthenes</a> and the <a href=""http://en.wikipedia.org/wiki/Sieve_of_Atkin"" rel=""noreferrer"">Sieve of Atkin</a> are two possible solutions. The Sieve of Eratosthenes has a complexity of O((n log n)(log log n)). The Sieve of Atkin has a complexity of O(N / log log n).</p>

<p>If you have a number and you want to find out if it's prime, that is called performing a <a href=""http://en.wikipedia.org/wiki/Primality_test"" rel=""noreferrer"">primality test</a>. The naive approach is to check all numbers m from 2 to sqrt(n) and verify that n % m is not 0. If you want to expand this slightly, you can throw out all even numbers (except 2). There are also some other enhancements to this naive approach that might improve performance, along with other, more advanced techniques.</p>
",7
1428839,1428786,10,"<p>Inspired by <a href=""http://xkcd.com/221/"" rel=""noreferrer"">xkcd</a>:</p>

<pre><code>int findPrimeNumber() {
    return 2; // guaranteed to be prime
}
</code></pre>
",6
1429270,1428786,0,"<p>Take a look at existing libraries e.g. OpenSSL and GNU MP.</p>
",0
1428913,1428786,3,"<p>If you want to generate primes from 1 to whatever, then the fastest way is probably a wheeled Sieve as implemented <a href=""https://stackoverflow.com/questions/1024640/calculating-phik-for-1kn/1134851#1134851"">here</a>, which can typically test more than 3,000,000 candidate primes a second on an average laptop (and that's using an <em>unoptimized</em> language like VB.net), and factor the non-primes to boot.  In c++ it could be easily 5 to 20 times faster.</p>
",6
1428967,1428786,1,"<p>Although there are more efficient algorithms, the <a href=""http://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test"" rel=""nofollow noreferrer"">Miller-Rabin</a> primality test is one of the simplest tests to implement.</p>
",0
1428985,1428786,1,"<p>There are two different questions:</p>

<p>1) How to find <code>if a number</code> is a prime number? If you discover an efficient algorithm for this one, you will be famous for the next <code>2000</code> years ;)</p>

<p>2) How to find <code>the prime numbers</code> up to a limit <code>N</code>?</p>

<p>probably this is what you are asking about. <code>Sieve of Atkin</code> is the most efficient one If your range or limit <code>N</code> is really big number. In reasonable ranges, you could implement an optimized variation of Sieve of Eratosthenes. I found these two sites to be more than useful:</p>

<ul>
<li><a href=""http://www.qsl.net/w2gl/blackkey.html"" rel=""nofollow noreferrer""><code>The Black Key Sieve</code></a> </li>
<li><a href=""http://wwwhomes.uni-bielefeld.de/achim/prime_sieve.html"" rel=""nofollow noreferrer""><code>The Sieve of Eratosthenes</code></a></li>
</ul>

<p><strong>EDIT: @avakar</strong></p>

<p>While I am more than beginner on the subject, I don't think <code>AKS</code> is the waited algorithm! From the same source:</p>

<blockquote>
  <p>However, some composite numbers also
  satisfy the equivalence. The proof of
  correctness for AKS consists of
  showing that there exists a suitably
  small r and suitably small set of
  integers A such that if the
  equivalence holds for all such a in A
  then n must be prime.</p>
</blockquote>
",6
1851122,1428786,-2,"<p>I found a way.But may its lengthy, but its perfect ..no flaws in it.</p>

<pre><code>package javaapplication4;
import java.io.*;
import java.util.*;

public class Main
{ 
    static Vector vprime = new Vector();
    static Vector vnotprime = new Vector();
    static Vector newVect = new Vector(new LinkedHashSet());
    static TreeSet&lt;Integer&gt; st = new TreeSet&lt;Integer&gt;();
    static int n = 0;
    static int starr[];    

    void prime()
    {
        Scanner sc = new Scanner(System.in);
        System.out.println(""Enter number to begin"");
        int beg = sc.nextInt();
        System.out.println(""Enter number to end"");
        int end = sc.nextInt();
        try
        {
            for (int i = beg; i &lt;= end; i++)
            {
                if (i == 1)
                {
                    vnotprime.add(i);
                    st.add(i);
                }
                if (i == 2)
                {
                    vprime.add(i);
                }
                if (i%2 != 0 &amp;&amp; i%(Math.sqrt(i)) != 0)
                {
                    vprime.add(i);
                }
                if (i%2 == 0 &amp;&amp; i != 2)
                {
                    vnotprime.add(i);
                    st.add(i);
                }
                if (i%(Math.sqrt(i)) == 0)
                {
                    vnotprime.add(i);
                    st.add(i);   
                }
                /*if (i%(Math.sqrt(i)) == 0 &amp;&amp; i != 1)
                {
                    vnotprime.add(i);
                }*/
            }
        }
        catch(Exception ex)
        {
            System.out.println(""Enter proper value"");
        }   
    }

    void showprime()
    {
        System.out.println(""Prime Numbers are"");
        Iterator it = vprime.iterator();
        while (it.hasNext())
        {
            System.out.println(it.next());
            for (int i : st)
            {    
            }
        }
    }

    void shownonprime()
    {
        System.out.println(""these are non-Prime Numbers are"");
        Iterator it = st.iterator();
        int len = st.size(), k = 0;
        starr = new int[len];
        while (it.hasNext())
        {
            System.out.println(it.next());
        }
        for (int i:st)
        {
            starr[k++] = i;
        }
    }

    public static void main(String[] args) throws IOException, Exception
    {
        Main m = new Main();
        m.prime();
        m.showprime();
        m.shownonprime();
        for(int i = 0; i &lt; starr.length; i++)
        {
            System.out.println(""I got it "" + starr[i]);
        }            
    }
}
</code></pre>
",1
898811,898789,5,"<p>If you want to locally modify <code>t</code> (without affecting the original) in the body of your method (say in the process of calculating something), the first method would be preferential.</p>
",2
898931,898789,1,"<p>If the most straightforward implementation of the function involves modifying the parameter value locally, then it makes sense to pass it by value rather than by const reference</p>

<p>For example, the one line version of strcpy:</p>

<pre><code>char *strcpy(char *dest, const char *src)
{
   while (*dest++ = *src++);

   return s1;
}
</code></pre>

<p>If you took in the pointers as const references, you would need to copy them to temporaries in the body of your program, rather than letting the paramater passing mechanism do it for you.</p>
",0
898844,898789,12,"<p>Built-in types and small objects (such as STL iterators) should normally be passed by value.</p>

<p>This is partly to increase the compiler's opportunities for optimisation. It's surprisingly hard for the compiler to know if a reference parameter is aliasing another parameter or global - it may have to reread the state of the object from memory a number of times through the function, to be sure the value hasn't changed.</p>

<p>This is the reason for C99's <code>restrict</code> keyword (the same issue but with pointers).</p>
",3
898845,898789,0,"<ol>
<li>As previously noted, prefer pass-by-value if you want a copy of the object in your function.</li>
<li>I usually use pass-by-value if copying T is cheaper than creating/copying a reference, e.g. T=char, T=short.  The benefit here could be platform dependent, and you'd probably still want const where applicable to help the optimizer.</li>
</ol>
",0
898846,898789,2,"<p>If the object being passed is a smart pointer (i.e. it does its own reference counting) then passing by value might be more reasonable.</p>

<p>I realize that's sort of a sideways answer to your question - the object wrapped by the smart pointer is not copied when passed by value, so it's more similar to passing by reference in that case.  Nevertheless, you don't need ""by reference"" semantics in this case.</p>

<p>There is a problem with my line of reasoning so far, though - you'll lose the ""const-ness"" of the argument by passing by value.  Perhaps you should just use the ""by reference"" semantics after all...</p>
",2
898847,898789,1,"<p>In addition, foo(T t) is normally used when T is a simple type (int, bool, etc).</p>
",0
898870,898789,1,"<p>Another case that hasn't been mentioned is heavy use of the object. Let's say you pass a struct with 5 ints as members. If you are going to be accessing all 5 quite a lot in your function, there comes a point when the dereference cost outweighs the copy cost. However, you'd have to run a profiler to know when that is.</p>

<p>I should point out, though, that things like STL containers, which allocate memory on the heap, should almost never be passed by value if avoidable, because heap allocation is very slow compared to stack allocation.</p>
",1
898875,898789,1,"<p>Here is a case when you don't have other option but only to pass a parameter by value. Of course boost does handle this. But without boost we have to pass a Value to function by value.</p>

<pre><code>class Test
{
public:
    Test()
    {
        std::set&lt;std::string&gt; values;
        values.insert(""A"");
        values.insert(""V"");
        values.insert(""C"");

        std::for_each(values.begin(), values.end(), 
                bind1st(mem_fun(&amp;Test::process), this));
    }

private:
    void process( std::string value )
    {
        std::cout &lt;&lt; ""process "" &lt;&lt; value &lt;&lt; std::endl;
    }
};
</code></pre>
",0
898880,898789,1,"<p>The reason pass by const reference and by value are conceptually the same is that neither can modify the original. </p>

<p>Normally, I am big fan of pass by value because it creates code that avoids many of the complexities that occur when multiple threads are sharing access to common data.</p>

<p>That said, it does potentially make you're code slower. My take in the past has always been to prefer pass by value unless I know their is (or will be) a performance problem by doing so. I may have to modify this slightly to include pass by const reference as an even better option.</p>
",0
898891,898789,0,"<p>Some routines require a copy, and so should not be pass by reference. For example, a chess playing program's move generator might need a copy of the current position to work on (recursively) rather than actually modifying the original instance of the position.</p>
",1
899065,898789,2,"<p>Don't forget that there are cases where there is a difference - when you're dealing with objects that have strange copy/assignment semantics.</p>

<p><code>auto_ptr&lt;&gt;</code> is the classic example - pass those around by value without thinking about the consequences and you may end up with a mess.</p>
",0
900190,898789,1,"<p>Two very specific cases:</p>

<p>When you are writing assignment operators with strong exception guarantees you can either write them like</p>

<pre><code>X&amp; X::operator=(const X&amp; orig)
{
    X tmp(orig);
    swap(this, tmp);
    return *this;
}
</code></pre>

<p>or you can recognize that the first thing that happens is that you make a copy and just have it done as part of the call</p>

<pre><code>X&amp; X::operator=(X tmp)
{
    swap(this, tmp);
    return *this;
}
</code></pre>

<p>If you have a smart pointer with ownership semantics, e.g. <code>auto_ptr</code>, and you want to transfer ownership to the called function you should pass it by value. Of course 8 people will now quickly point out that you probably don't want to use <code>auto_ptr</code> and they're probably right, but sometimes you don't make that choice.</p>

<p>While not at all specific, I frequently end up passing smallish objects around by value when that saves me an allocation on the heap. Not only does the actual allocation and eventual deallocation take time but referencing everything through a pointer does nothing to improve your data locality. It might in other words make a difference to your performance. Exactly where the break-even point is will depend on your application, but I would personally don't hesitate to pass an object that is a few pointer sizes large. </p>
",0
900301,898789,1,"<p>They're not conceptually equal at all...</p>

<p>The former creates a copy of the object inside the function.  This implies that the value can be modified in the function safely.  It also implies that a full copy of the object occurred, which can be a problem if the object is large.</p>

<p>The latter creates an alias to the object and states that it cannot be modified within the object.  No copying occurs, but each access to the object inside the function will require a dereference.  The compiler takes care of this for us, but it's still important to know.</p>

<p>The difference becomes very important if you have a type that is normally passed in registers.  For example, integers, floating point numbers, and even 4-float vectors on some platforms.  Performance concerns dictate that you want to object to stay in a register for as long as possible without writing itself back to memory, and pass by value makes this much more likely.</p>

<p>So for basic types (char, short, int, long, float, double), you should always prefer pass by value <em>unless</em> you specifically need to use a reference to store a value for use after the function exits.  For full objects, generally prefer to pass by const reference.</p>
",0
1528661,1528609,2,"<p>Those date constructors look wrong.  Neither of the no-args or copy constructors actually initialize any of the fields.</p>
",4
1528679,1528609,7,"<pre>
stock::stock(/* snip */ date priceDate ) : m_sharePrice( sharePrice )
{
    /* Snip */
    dateObj = &priceDate;
}
</pre>

<p>Don't do that.  <code>priceDate</code> is one of your parameters on the stack.  As soon as the contructor ends, <code>&amp;priceDate</code> becomes a stale pointer.  Consider actually copying the object (rather than using a pointer, eg. declare <code>date dateObj;</code> and assign with <code>dateObj = priceDate;</code>)</p>
",1
514991,514977,7,"<p>You can't cast an A* pointing to Class C as a B* because Class C doesn't have any relation with Class B.  You'll get undefined behavior which will probably be the wrong function called and stack corruption.</p>

<p>If you intended for class C to derive from class B then you could.  However, you wouldn't need to.  If class C doesn't have fun() defined, it will inherit A's.  You didn't declare fun() virtual though so you'll get strange behavior if you even implement C::fun() or B::fun().  You almost certainly want fun() to be declared virtual.</p>
",3
515008,514977,0,"<p>You don't have to do the casting  (B*) ptr->fun();   since the fun() is already in the base class. both objects of class B or C will invoke the same fun() function in your example.</p>

<p>I'm not sure what happens when u override the fun() function in class B...</p>

<p>But trying to invoke function from another class (not the base class) is bad OO, in my opinion.</p>
",1
515016,514977,0,"<p>I'm guessing here but I suspect the behavior of this might depend on the compiler you use and how it decides to organize the vf pointer table.</p>

<p>I'm also going to note that I think what you are doing is a bad idea and could lead to all kinds of nightmarish problems (use of things like static_cast and dynamic_cast are generally a good idea). The other thing is because fun() is defined in the base class (and it is not virtual) ptr->fun() will always call A::fun() without having to cast it to B*.</p>
",0
516390,514977,0,"<p>You can cast from A * to B *, and it should work if the original pointer was B *. </p>

<pre><code>A* p = new B;
B* q = static_cast&lt;B*&gt;(p); // Just work (tm)
</code></pre>

<p>But in this case it is a C *, and it is not guaranteed to work, you will end with a dangling pointer, if you are lucky you will get an access violation, if not you man end up silently corrupting your memory. </p>

<pre><code>A* p = new C;
B* q = static_cast&lt;B*&gt;(p); // Owned (tm)
</code></pre>
",0
1783812,1783762,7,"<p>Yes, this means that <code>PUINT_PTR</code> is a pointer and <code>UINT_PTR</code> is not a pointer.  It's a little confusing, but a <code>UINT_PTR</code> (as well as the more standardized <code>uintptr_t</code>) is defined to be an unsigned integer that is guaranteed to be large enough to hold a pointer value.  It's typically used for tricky code where pointers are put into integer values and vice-versa.</p>

<p>The <code>_W64</code> annotation is a note to the Miscrosoft compiler that when compiling for a 64-bit target, the variable should be 64 bits wide instead of the usual 32, since on 64-bit platforms, pointers are 64 bits, but <code>unsigned int</code>s are usually still 32 bits.  This ensures that <code>sizeof(UINT_PTR) &gt;= sizeof(void*)</code> for all target platforms.</p>

<p>The second declaration just declares <code>PUINT_PTR</code> to be a pointer to a <code>_W64 unsigned int</code>, or more specifically, a pointer to a <code>UINT_PTR</code>.</p>
",0
1719647,1719607,18,"<pre><code>BYTE* data = new BYTE[size];
</code></pre>

<p>In this code, whatever size is given, the returned memory region is <strong>consecutive</strong>. If the heap manager can't allocate consecutive memory of <code>size</code>, it's fail. an exception (or NULL in <code>malloc</code>) will be returned.</p>

<p><strong>Programmers will always see the illusion of consecutive (and yes, infinite :-) memory in a process's address space.</strong> This is what virtual memory provides to programmers.</p>

<p>Note that programmers (other than a few embedded systems) always see virtual memory. However, virtually consecutive memory could be mapped (in granularity of 'page' size, which is typically 4KB) in physical memory in arbitrary fashion. That mapping, you can't see, and mostly you don't need to understand it (except for very specific page-level optimizations).</p>

<p>What about this?</p>

<pre><code>BYTE* data1 = new BYTE[size1];
BYTE* data2 = new BYTE[size2];
</code></pre>

<p>Sure, you can't say the relative address of <code>data1</code> and <code>data2</code>. It's generally non-deterministic. It depends on heap manager (such as <code>malloc</code>, often <code>new</code> is just wrapped <code>malloc</code>) policies and current heap status when a request was made.</p>
",5
1719658,1719607,2,"<p>The virtual addresses of the allocated bytes will be contiguous. They will also be physically contiguous within resident pages backing the address space of your process. The mapping of physical pages to regions of the process virtual space is very OS and platform specific, but in general you cannot assume physically contiguous range larger then or not aligned on a page.</p>
",0
1719675,1719607,4,"<p>Case 1:
 Using ""new"" to allocate an array, as in</p>

<pre><code>int* foo = new int[10];
</code></pre>

<p>In this case, each element of foo <strong>will</strong> be in contiguous virtual memory.</p>

<p>Case 2:
 Using consecutive ""new"" operations non-atomically, as in</p>

<pre><code>int* foo = new int;
int* bar = new int;
</code></pre>

<p>In this case, there is never a guarantee that the memory allocated between calls to ""new"" will be adjacent in virtual memory.</p>
",0
1719719,1719607,0,"<p>Yes.</p>

<p>Don't bother about the ""virtual memory"" issue: apart that there could be cases when you haven't at all a system that supports virtual memory, from <strong>your</strong> PoV you get a consecutive memory chunk. That's all.</p>
",0
1719966,1719607,1,"<p>If by your question you mean ""Will successive (in time) new() operations return adjacent chunks of memory, with no gaps in between?"", this old programmer will suggest, very politely, that you should not rely on it.</p>

<p>The only reason that question would come up was if you intended to walk a pointer ""out"" of one data object and ""into"" the next one.  This is a really bad idea, since you have no guarantee that the next object in the address space is of anything remotely resembling the same type as the previous one.</p>
",0
1720221,1719607,0,"<p>Physical memory is never contiguous its logical memory which is contiguous.</p>
",0
1719609,1719607,7,"<p>The memory allocated in <em>your process's address space</em> will be contiguous.  </p>

<p>How those bytes are mapped into physical memory is implementation-specific; if you allocate a very large block of memory, it is likely to be mapped to different parts of physical memory.</p>

<p><strong>Edit:</strong>  Since someone disagrees that the bytes are guaranteed to be contiguous, the standard says (3.7.3.1):</p>

<blockquote>
  <p>The allocation function attempts to allocate the requested amount of storage.  If it is successful, it shall return the address of the start of a block of storage whose length in bytes shall be at least as large as the requested size.</p>
</blockquote>
",10
1056976,1056964,6,"<p>Probably the line is off by one and it crashes in the delete.</p>
",2
1056998,1056964,3,"<p>Note that although it is OK to delete a NULL pointer, it is not necessarily OK to delete a a non-NULL pointer. The pointer must have been allocated with new and must not already have been deleted. Note also that allocating NULL to deleted pointers can add to a false sense of security - simply checking for NULL is not enough, your programs memory allocation semantics need to be correct too.</p>
",0
1057004,1056964,2,"<p>I suspect that you are double-deleting.  This has all sorts of strange effects.  Set a break point on the delete and look at the object there before deleting.  Does it look valid?  Another way is to set the breakpoint on the delete and make sure you only get there once.</p>
",0
1057005,1056964,2,"<p>Here's what springs to my mind:</p>

<ul>
<li>Make sure s_counter is initialized to NULL (or better 0 in C++) before any allocation, this will ensure you'll never attempt to delete garbage (and crash).</li>
<li>If s_counter is part of an object, then the object may have been deleted.</li>
<li>If s_counter is a static as its name seems to imply, the fact that you can't reproduce it reliably could be caused by a race condition, check your thread access patterns.</li>
</ul>
",1
1057020,1056964,0,"<p>One other thing that could happen is if your <code>s_counter</code> pointer is pointing to an array of objects instead of a single object. In that case you should use <code>delete[]</code> instead of <code>delete</code> . If you use delete on an array of objects then the memory will be corrupted and all sorts of strange things might start to happen.</p>
",0
548515,548509,1,"<pre><code>const char *filename = argv[1];
</code></pre>

<p>Then pass the pointer to your subroutine. argv[1] remains valid for the whole execution of the program.</p>
",1
548516,548509,0,"<p>First of all, you may want to check that argv[1] is not null before you try to assign it to the C++ string.</p>

<p>You can move the C++ string object around to functions.</p>

<p>Eventually, you can use c_str() to make a C string</p>

<p>For example:
  char* sData = (char*)str.c_str()</p>
",2
548639,548509,6,"<p>The following code shows how to do exactly what you want, checking that argv[1] exists before passing it to functions as C char-pointers or C++ strings and using the value within that function.</p>

<pre><code>#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

static void f1 (char *s) {
    cout &lt;&lt; ""1: "" &lt;&lt; s &lt;&lt; endl;
}

static void f2 (const string&amp;  s) {
    cout &lt;&lt; ""2: "" &lt;&lt; s &lt;&lt; endl;
    cout &lt;&lt; ""3: "" &lt;&lt; s.c_str() &lt;&lt; endl;
}

int main (int argc, char *argv[]) {
    if (argc &lt; 2) {
        cout &lt;&lt; ""Usage: "" &lt;&lt; argv[0] &lt;&lt; "" &lt;test_string&gt;"" &lt;&lt; endl;
        return EXIT_FAILURE;
    }

    char *s1 = argv[1];
    string s2(argv[1]);

    f1 (s1);
    f2 (s2);

    return EXIT_SUCCESS;
}
</code></pre>

<p>The output is, as expected:</p>

<pre><code>1: hello
2: hello
3: hello
</code></pre>

<p>As for your edit, you cannot access argc/argv without storing them in a global or passing them to a function. That's because they're passed to the <code>main</code> function as arguments so inherently local to that function.</p>
",0
548647,548509,2,"<blockquote>
  <p>is there a way to do this without:
  global variables, passing the string
  as an argument parameter to the
  sub-routine.</p>
</blockquote>

<p>No, you have to get it to the routine somehow.</p>

<p>What is wrong with passing it as a parameter?</p>

<pre><code>void my_sub( char* s){}

void main(int argc, char* argv[])
{
    my_sub( argv[1] );
}
</code></pre>
",0
548667,548509,0,"<p>You would have to pass the argument as a parameter to the sub-routines.</p>

<pre><code>void method1(char* filename) {
  // ..
}

void method2(char* filename) {
  // ...
}

void main(int argc, char* argv[]) {
  method1(argv[1]);
  method2(argv[1]);
}
</code></pre>

<p>I'm not sure if this answers your question, so please expand.</p>
",1
548678,548509,0,"<pre><code>class myprog {
public:
    myprog(const string&amp; filename) : m_filename(filename) {}

    void menufunc();
    void otherfunc();
private:
    string m_filename;
};

int main(int argc, char** argv)
{
    myprog prog(argv[1]);

    prog.menufunc();
    prog.otherfunc();
    return 0;
}
</code></pre>
",0
838932,838917,6,"<p>The compiler effectively stores a <code>bool</code> with each <code>static</code> to remember whether it has been initialised.</p>

<p>This is the order:</p>

<p>Inside main:</p>

<ul>
<li>Construct <code>A</code></li>
<li>Destruct <code>A</code></li>
<li><ul>
<li>Construct <code>static B</code></li>
</ul></li>
</ul>

<p>Clean-up of statics:</p>

<ul>
<li>Destruct <code>static B</code></li>
<li><ul>
<li>Construct <code>static A</code></li>
<li>Destruct <code>static A</code></li>
</ul></li>
</ul>

<p>3.6.3/1 in the Standard specifies it should work this way, even when a <code>static</code> is constructed during clean-up as in this case.</p>
",5
838954,838917,0,"<p>That behaviour is probably caused because you are using static instances. The compiler surely takes care of the status of static variables to avoid performing multiple initialization / deinitializations.</p>
",0
479137,478806,1,"<p>Using <strong><em>instream>>dvalue</em></strong> is certainly the <strong>right</strong> way to do things.  But sometimes what's right isn't always easiest or necessarily best.</p>

<p>We could do something like this:</p>

<pre><code>int
main()
{
  string s = ""grrr,some text,45.4321,54.22134"";
  double a,b;

  ASSERT_IS( 2, sscanf( s.c_str(), ""%*[^,],%*[^,],%lf,%lf"", &amp; a, &amp; b ) );

  cout &lt;&lt; setprecision(8);
  SHOW(a);
  SHOW(b);
}
</code></pre>

<p>Or perhaps something like this, while less efficient, might be easier to understand...</p>

<pre><code>int
main()
{
  string s = ""grrr,some text,45.4321,54.22134"";
  vector&lt;string&gt; v;

  StringSplit( &amp; v, s, "","" );

  cout &lt;&lt; setprecision(8);
  SHOW(v);
  SHOW(atof(  v[2].c_str()));
  SHOW(strtod(v[3].c_str(), (char**)NULL));
}
</code></pre>

<p>Assuming:</p>

<pre><code>#define SHOW(X)  cout &lt;&lt; # X "" = "" &lt;&lt; (X) f &lt;&lt; endl


    /* A quick &amp; easy way to print out vectors... */
template&lt;class TYPE&gt;
inline ostream &amp; operator&lt;&lt; ( ostream &amp; theOstream,
                              const vector&lt;TYPE&gt; &amp; theVector )
{
  theOstream &lt;&lt; ""Vector ["" &lt;&lt; theVector.size() &lt;&lt; ""] {""
             &lt;&lt; (void*)(&amp; theVector) &lt;&lt; ""}:"" &lt;&lt; endl;

  for ( size_t i = 0;  i &lt; theVector.size();  i ++ )
    theOstream &lt;&lt; ""    ["" &lt;&lt; i &lt;&lt; ""]:   \"""" &lt;&lt; theVector[i] &lt;&lt; ""\"""" &lt;&lt; endl;

  return theOstream;
}


inline void
StringSplit( vector&lt;string&gt; * theStringVector,  /* Altered/returned value */
             const  string  &amp; theString,
             const  string  &amp; theDelimiter )
{
  UASSERT( theStringVector, !=, (vector&lt;string&gt; *) NULL );
  UASSERT( theDelimiter.size(), &gt;, 0 );

  size_t  start = 0, end = 0;

  while ( end != string::npos )
  {
    end = theString.find( theDelimiter, start );

      // If at end, use length=maxLength.  Else use length=end-start.
    theStringVector -&gt; push_back( theString.substr( start,
                   (end == string::npos) ? string::npos : end - start ) );

      // If at end, use start=maxSize.  Else use start=end+delimiter.
    start = (   ( end &gt; (string::npos - theDelimiter.size()) )
              ?  string::npos  :  end + theDelimiter.size()     );
  }
}
</code></pre>
",0
478851,478806,2,"<p>Your code is a little tough to read. You probably want to think some point about encapsulation and breaking it up into functions.</p>

<p>Additionally, I would try to avoid reading in single characters and use the various functions and methods for reading data in fields - you can read a whole floating point or integer number using the <code>&gt;&gt;</code> stream extractors.</p>

<p>Finally, a useful skill to learn is how to use a debugger. You can step through the code and inspect the values of variables as you go.</p>

<p>That said, it looks like your problem is here:</p>

<pre><code>          if ( sBuffer[ x ] == ',' )
          {
               nStart = x;
               break;
               }

          **** sLine = sBuffer[ x ];     
          inStream.clear();
          inStream.str( sLine );

          if ( inStream &gt;&gt; dValue2 )
          cout &lt;&lt; setprecision(1) &lt;&lt; dValue2;
</code></pre>

<p>On the line marked with ""****"", you place exactly one character into the variable called ""sLine"". Having done so, you convert that one character into a double precision variable dValue2 and then output it. It should be obvious why this one character is converted into the first digit of the number you want.</p>
",0
478852,478806,0,"<p>Two points:</p>

<ul>
<li>You might want to use <a href=""http://www.cplusplus.com/reference/string/string/find.html"" rel=""nofollow noreferrer""><code>sBuffer.find(',')</code></a></li>
<li>You set <code>sLine</code> to the last character before "","", is this intended to be so? You only parse single digit numbers correctly this way.</li>
</ul>
",0
755910,755892,0,"<p>If your array size really is fixed at compile time then you may be better off looking at a 2D array, rather than a 2 element vector containing 2 2 elemnet vectors.</p>
",1
755927,755892,1,"<p>Try:</p>

<pre><code>edge2d_t ev(10, edge_t(10, 0));
</code></pre>

<p>(change the size from 10 to something that fits you.)</p>
",0
755921,755892,1,"<p>edge2d_t is a vector of vectors.  In your first code block you set the size of the outer vector when you instantiate your edge2d variable, but not the inner vectors, so they are all size 0.</p>

<p>try this:</p>

<pre><code>edge2d_t edge2d(2);
edge2d[0].resize(2);
edge2d[1].resize(2);

 //creating the vector of edges of intersections whenever an intersection is detected
for (int i=0;i&lt;1;i++){
        edge2d[0][0]=sweepEvents[i][0];
        edge2d[0][1]=sweepEvents[i][1];
        edge2d[1][0]=sweepEvents[i+1][0];
        edge2d[1][1]=sweepEvents[i+1][1];
        std::cout&lt;&lt;edge2d[0][0]&lt;&lt;"" ""&lt;&lt;edge2d[0][1]&lt;&lt;endl;
        std::cout&lt;&lt;edge2d[1][0]&lt;&lt;"" ""&lt;&lt;edge2d[1][1]&lt;&lt;endl;
        myEdgesIntersect.push_back(edge2d);
        std::cout&lt;&lt;myEdgesIntersect[i][0][0]&lt;&lt;"" ""&lt;&lt;myEdgesIntersect[i][0][1]
            &lt;&lt;""    ""&lt;&lt;myEdgesIntersect[i][1][0]&lt;&lt;"" ""&lt;&lt;myEdgesIntersect[i][1][1]&lt;&lt;endl;
}
</code></pre>
",0
755941,755892,1,"<p>In addition to what John said, I suspect your 'for' loop may have an off-by-one error:</p>

<pre><code>for (int i=0;i&lt;1;i++){ // i will only be 0
</code></pre>

<p>perhaps you want</p>

<pre><code>    for (int i=0;i&lt;=1;i++){ // i will iterate 0,1
</code></pre>
",0
372746,372714,7,"<p>So you named your class the same as a preprocessor directive? That is something I would avoid.</p>

<p>Try changing your preprocessor Weapon or making a different class name.  I think it will work better.</p>
",0
372756,372714,19,"<pre><code>#ifndef Weapon
#define Weapon
</code></pre>

<p>This is almost certainly going to cause weirdness; call the constant WEAPON_H instead.</p>
",7
372759,372714,5,"<p>I think the problem is in the #define Weapon - any occurence of ""Weapon"" later on in the code will be removed or replaced by something you didn't intend.</p>
",0
373120,372714,0,"<p>GCC also supports ""#pragma once"" but it's not standard and code will be more portable if you use the traditional include guard #ifndef _MYFILE_H_ or some variant.</p>
",0
372788,372714,4,"<p>To anplify Tim's answer. You see the code like this:</p>

<pre><code>#ifndef Weapon
#define Weapon
#include &lt;allegro.h&gt;
#include &lt;stdio.h&gt;
#include &lt;iostream&gt;

using namespace std;

class WeaponsDB;
class MenuDriver;
class Ammo;

class Weapon
{
public:
   Weapon(const WeaponsDB * wepDB);
   Weapon(const WeaponsDB * wepDB_, int * weaponlist);
   ~Weapon(void);
}
</code></pre>

<p>But you've defined the preprocessor macro <code>Weapon</code> as an empty string, so the compiler sees this:</p>

<pre><code>#ifndef Weapon
#define Weapon
#include &lt;allegro.h&gt;
#include &lt;stdio.h&gt;
#include &lt;iostream&gt;

using namespace std;

class sDB;
class MenuDriver;
class Ammo;

class 
{
public:
   (const sDB * wepDB);
   (const sDB * wepDB_, int * weaponlist);
   ~(void);
}
</code></pre>

<p>Just change the include guard to use a string that doesn't occur as a name (e.g. <code>WEAPON_H_INCLUDED</code>).</p>
",1
372818,372714,0,"<p>I don't know if this is Microsoft-specific (I have only used VS2005 recently), but this works. I start all my header files with:</p>

<pre><code>#pragma once
</code></pre>
",0
374257,372714,-1,"<p>Just a quick note: in C++, unlike C, when a function (or destructor, in this case) doesn't have any parameter, you don't need to use (void), you just use ().</p>
",0
375587,372714,2,"<p>Like other answers already made available, I also suspect the preprocessor directive.</p>

<p>To confirm, say on GCC, you can request it to only run the preprocessor and save that output somewhere. There's probably similar features for the compiler that you use.</p>
",1
279411,279404,8,"<p>See <a href=""https://isocpp.org/wiki/faq/templates#separate-template-fn-defn-from-decl-export-keyword"" rel=""nofollow noreferrer"">this</a> explanation for its use</p>

<p>Quite a few compilers don't support it either because it's too new or in the case of gcc - because they disaprove.</p>

<p>This post describes standard support for many compilers.
<a href=""https://stackoverflow.com/questions/146381/visual-studio-support-for-new-c-c-standards"">Visual Studio support for new C / C++ standards?</a></p>
",2
279426,279404,2,"<p><a href=""http://www.codeproject.com/KB/mcpp/stdexport.aspx"" rel=""nofollow noreferrer"">Standard Features Missing From VC++ 7.1. Part II: export</a></p>
",0
279571,279404,5,"<p>To put it simply:</p>

<p><code>export</code> lets you separate the declaration (ie. header) from the definition (ie. the code) when you write your template classes.  If <code>export</code> is not supported by your compiler then you need to put the declaration and definition in one place.</p>
",0
279498,279404,2,"<p>The only compilers that support exported templates at the moment (as far as I know) are Comeau, the one that came with Borland C++ Builder X but not the current C++ Builder, and Intel (at least unofficially, if not officially, not sure).</p>
",0
279617,279404,7,"<p>See <a href=""http://www.ddj.com/cpp/184401563"" rel=""noreferrer"">here</a> and <a href=""http://www.ddj.com/showArticle.jhtml?articleID=184401584"" rel=""noreferrer"">here</a> for Herb Sutter's treatment of the subject.</p>

<p>Basically: export has been implemented in only <a href=""http://www.comeaucomputing.com/"" rel=""noreferrer"">one</a> compiler - and in that implementation, export actually increases the coupling between template definition and declaration, whereas the only point in introducing export was to decrease this coupling.</p>

<p>That's why most compilers don't bother. I would have thought they would have just removed export from the language in C++0x, but I don't think they did. Maybe some day there will be a good way to implement export that has the intended use.</p>
",7
280921,279404,5,"<p>Export is a feature that introduces a circular dependency between linker and compiler. As others noted, it allows one translation unit to contain the definition of a template used in another. The linker will be the first to detect this, but it needs the compiler for the instantiation of the template. And this involves real hard work, like name lookup.</p>

<p>Comeau introduced it first, about 5 years ago IIRC. It worked quite well on the first beta release I got. Even testcases like A&lt;2> using B&lt;2> using A&lt;1> using B&lt;1> using A&lt;0>, worked, if templates A and B came from different TU's. Sure, the linker was repeatedly invoking the compiler, but all name lookups worked OK. Instantiation A&lt;1> found names from A.cpp that were invisible in B.cpp.</p>
",0
1082416,1081843,2,"<p>You could look at the source code of MySQL GUI Tools. Its written using gtkmm, and the code does some interesting difficult-to-implement GUI things.</p>
",0
1084261,1081843,0,"<p>Check the <a href=""http://code.google.com/p/arora/"" rel=""nofollow noreferrer"">arora</a> browser sources. It shows the beauty of the Qt toolkit and elegant and well written code for a somewhat complex application.</p>
",0
1085177,1081843,1,"<p>Tou should take a look at the source code of <a href=""http://www.netbsd.org/"" rel=""nofollow noreferrer"">NetBSD</a>. It's really clear and well documented.</p>
",1
1085184,1081843,3,"<p>IMHO...</p>

<p><a href=""http://notepad-plus.sourceforge.net/uk/site.htm"" rel=""nofollow noreferrer"">Notepad++</a></p>
",0
1085243,1081843,1,"<p>Loki is a pretty nice library especially if you're interested in how design patterns and various idioms are expressed in C++.  Reading the source might also be a good way to understand C++'s metaprogramming facility using templates.</p>

<p><a href=""http://loki-lib.sourceforge.net/"" rel=""nofollow noreferrer"">http://loki-lib.sourceforge.net/</a></p>
",0
1085312,1081843,2,"<p>It think ""Qt""</p>
",0
1085331,1081843,0,"<p>I've heard that Google's Chromium source code is very clean.</p>
",0
1085971,1081843,0,"<p>The source code for the <a href=""http://pocoproject.org"" rel=""nofollow noreferrer"">Poco C++ libraries</a> is very neat as well.</p>
",0
301138,301129,3,"<p>IF you are targetting Windows, then you might want to use ODBC.</p>
",1
301140,301129,3,"<p>You should have a look at C preprocessors that exists traditionaly with databases (<a href=""http://www.postgresql.org/docs/8.3/interactive/ecpg.html"" rel=""nofollow noreferrer"">ecpg</a> for postgres, <a href=""http://www.cs.umbc.edu/help/oracle8/server.815/a68022/toc.htm"" rel=""nofollow noreferrer"">Pro*C</a> for oracle ... which lets you embed straight SQL directly in your source files) or an <a href=""http://dev.mysql.com/doc/refman/6.0/en/apis-cplusplus.html"" rel=""nofollow noreferrer"">orginal system</a> for mysql. ECPG will do with C++, that is/was not the case for some other preprocessors ...</p>
",0
301462,301129,0,"<p>If you targeting windows you can always use the import ability.</p>

<pre><code>#import ""c:\Program Files\Common Files\System\ADO\msado15.dll"" no_namespace rename( ""EOF"", ""EndOfFile"" )
</code></pre>

<p>Then you could make a wrapper to deal with the SQL.</p>

<p>Little example, just to open close a connection</p>

<pre><code>// H
class CExtAdoDatabase
{

public:
    CExtAdoDatabase( const char* p_cConnectString="""", const char* p_cUsername="""", const char* p_cPwd="""" );
    virtual ~CExtAdoDatabase();

    bool Open( const char* p_cConnectString="""", const char* p_cUsername="""", const char* p_cPwd="""" );
    bool Close();



private:
    HRESULT _hInitRes;
    bool _bIsValid;

    _ConnectionPtr *_p_pConnection;
};



// CPP
CExtAdoDatabase::CExtAdoDatabase( const char* p_cConnectString, const char* p_cUsername, const char* p_cPwd ) : _hInitRes( CoInitialize( NULL ))
{
    _p_pConnection = new _ConnectionPtr( ""ADODB.Connection"" );

    if( FAILED( _hInitRes ))
            _bIsValid = false;
    else
    {
        _bIsValid = true;
        (*_p_pConnection)-&gt;ConnectionTimeout=0;
        (*_p_pConnection)-&gt;CommandTimeout=0;

        if( p_cConnectString != NULL &amp;&amp; strlen(p_cConnectString) )
        {
            _bstr_t scs( p_cConnectString );
            _bstr_t susr( p_cUsername );
            _bstr_t spwd( p_cPwd );
            (*_p_pConnection)-&gt;Open( scs, susr, spwd, NULL );
        }
    }
}
CExtAdoDatabase::~CExtAdoDatabase()
{
    Close();
    delete _p_pConnection;
    CoUninitialize();
}

bool CExtAdoDatabase::Open( const char* p_cConnectString, const char* p_cUsername, const char* p_cPwd )
{
    if(_bIsValid)
    {
        _bstr_t scs( p_cConnectString );
        _bstr_t susr( p_cUsername );
        _bstr_t spwd( p_cPwd );
        return ((*_p_pConnection)-&gt;Open( scs, susr, spwd, NULL ) == S_OK);
    }
    else
        return false;
}

bool CExtAdoDatabase::Close()
{
    if( _bIsValid )
    {
        if( (*_p_pConnection)-&gt;GetState() == adStateOpen )
            return !!(*_p_pConnection)-&gt;Close();
        else
            return true;
    }
    else
        return false;
}
</code></pre>
",0
301245,301129,1,"<p>you could try wxSqlite with SQLite as Database. This offers you an open source connection header / c++ file to get started. </p>

<p>In general - you should get some kind of library that offers you the required functionality. All major DB vendors should offer at least a C library. Most of the time you get a C++ library or wrapper for the C one.</p>
",0
301254,301129,0,"<p>Use SQLAPI++ - it's cross platform and supports MS SQL Server, Oracle, Postgres and others.  Very easy to use.</p>

<p><a href=""http://www.sqlapi.com/"" rel=""nofollow noreferrer"">http://www.sqlapi.com/</a></p>
",0
1023517,1023511,3,"<p>Take a look at <a href=""http://en.wikipedia.org/wiki/Dynamic_cast"" rel=""nofollow noreferrer"">dynamic_cast</a>.</p>
",3
1023527,1023511,1,"<p>The interfaces define what a class <em>does</em>, and not <em>what it is</em>. You should not use them as a ""Is a"" relation. In your case it would be better to define a IsDangerous() method in the IFish interface.</p>

<p>Casting in this case is possible in C++, but it will be bad design.</p>
",1
1023547,1023511,-2,"<p>if this were Java, you could do:</p>

<pre><code>if( fish instanceof IAggressive )
    runAway();
</code></pre>

<p>Perhaps there is some C++ equivalent? I've heard a lot about RTTI.. will that help?</p>

<p>jrh</p>
",0
1023554,1023511,5,"<p>Expanding on what Drakosha posted, you would dynamic_cast the IFish pointer into an IAggressive pointer and check if it is NULL or not. Like this;</p>

<pre><code>#include &lt;iostream&gt;

class IFish {
public:
    virtual void eat() = 0;
};

class IFriendly {
public:
    virtual void protect() = 0;
};

class IAggressive {
public:
    virtual void attack() = 0;
};

class Dolphin : public IFish, public IFriendly {
public:
    virtual void eat() {
        std::cout &lt;&lt; ""Dolphin::eat()\n"";
    }

    virtual void protect() {
        std::cout &lt;&lt; ""Dolphin::protect()\n"";
    }
};

class Shark : public IFish, public IAggressive {
public:
    virtual void eat() {
        std::cout &lt;&lt; ""Shark::eat()\n"";
    }

    virtual void attack() {
        std::cout &lt;&lt; ""Shark::attack()\n"";
    }
};

class Diver {
public:
    void shouldRunAway( IFish *fish ) {
        if ( dynamic_cast&lt;IAggressive *&gt;( fish ) != NULL ) {
            std::cout &lt;&lt; ""Run away!\n"";
        } else {
            std::cout &lt;&lt; ""Don't run away.\n"";
        }
    }
};

int main( int argc, char *argv[] ) {
    Dolphin dolphin;
    Shark shark;
    Diver diver;

    diver.shouldRunAway( &amp;dolphin );
    diver.shouldRunAway( &amp;shark );

    return 0;
}
</code></pre>
",0
290159,289568,2,"<p>And no, i think he is NOT trying to spam. This is a valid question and quite interesting i think. </p>

<p>Ok now i think compilers can do that. The standard says in 9.2. p12:</p>

<p><code>Implementation alignment require-
ments might cause two adjacent members not to be allocated immediately after each other; so might
requirements for space for managing virtual functions (10.3) and virtual base classes (10.1).
</code></p>
",0
290208,289568,1,"<p>The way I interpret the standard, it sees the code example as follows:  since there is no access specifier between i and j, the address of i must come before the address of j.  The proposed ordering satisfies this.  Idem for k and n.  So in my interpretation, compilers <em>are</em> allowed to use this ordering.</p>
",0
290250,289568,3,"<p>I checked out the C++ standard.  In section 9.2, paragraph (or clause or whatever) 12, it says ""The order of allocation of nonstatic data members separated by an access-specifier is unspecified.""  ""Unspecified"" means implementation-dependent behavior that need not be documented.</p>

<p>Therefore, the standard is explicitly saying nothing about the allocation, except that i must precede j and k must precede n.  Therefore, a compiler is allowed to allocate in the order i, k, j, n, and nothing about the ordering need be documented.</p>
",1
1406658,1406643,10,"<p>Short circuiting applies to all expressions, regardless of <code>const</code>-ness. Skipping the call to <code>someFunction()</code> is correct.</p>
",0
1406661,1406643,4,"<p>It doesn't matter if the second operand to <code>&amp;&amp;</code> is const or not.  After the first operand evaluates to <code>false</code> the return value is known, so there's no reason to evaluate the second operand.</p>

<p>If the function has side effects that require it to be executed, put it first.</p>
",0
1406664,1406643,7,"<p>The <code>&amp;&amp;</code> and <code>||</code> operators are defined to evaluate lazily, this is the way the language works. If you want the side effects to always happen, invoke the function first and stash the result, or refactor the function to split the work from the state query.</p>
",2
1406667,1406643,2,"<p>Short-circuit evaluation has nothing to do with const or non-const.  It happens no matter what.</p>

<p>The statement <code>A() &amp;&amp; B();</code> will do exactly what <code>if (A()) B();</code> does (although it isn't a perfect substitute, as the second one allows an <code>else</code>).  This is sometimes used to change a statement into an expression (such as when writing a macro, or embedding it in another statement).</p>
",3
1406671,1406643,1,"<p>The &amp;&amp; operator is also called the shortcut operator, which means it only evaluates the second part if the first part returned true. That's the main difference between &amp;&amp; and &amp;:</p>

<pre><code>value = func1() &amp;&amp; func2(); // evaluates func2() only if func1() returns true

value = func1() &amp; func2(); // evaluates both func1() and func2()
</code></pre>
",1
1406676,1406643,1,"<p>For &amp;&amp; operator, </p>

<pre><code>1 &amp;&amp; X = X
0 &amp;&amp; X = 0
</code></pre>

<p>so in case first var is 0, compiler will evaluate the expression to 0, no question, what ever the X is.</p>

<p>Compiler will ignore the X part as it wont impact the result. Here X can be any thing function/variable/expression.....  </p>
",2
1406841,1406643,5,"<p>As others have explained, || and &amp;&amp; always perform short-circuit evaluation.</p>

<p>Also note that short-circuit evaluation can be <em>very useful</em>, since it lets you write code like this:</p>

<pre><code>retval = obj_pointer &amp;&amp; obj_pointer-&gt;SomeBooleanMethod();
</code></pre>

<p>Without short-circuit evaluation, this would crash on a NULL pointer.</p>
",0
1983663,1983639,3,"<p>What you have declares the friend op== as a non-template, but you implement it as a template.  That is why the definition is not found when linking.</p>

<p>How I usually overload op== for class templates:</p>

<pre><code>template&lt;class T&gt;
struct A {
  friend bool operator==(A const&amp; a, A const&amp; b) {
    return a.var == b.var;
  }
private:
  T var;
};
</code></pre>
",1
1983948,1983639,1,"<pre><code>template&lt;typename T&gt;
class Sample
{
public:
    template&lt;typename T&gt; friend bool operator==(const Sample&lt;T&gt;&amp; lhs, const Sample&lt;T&gt;&amp; rhs);
private:
     T val_;
};

template&lt;typename T&gt;
bool operator==(const Sample&lt;T&gt;&amp; lhs, const Sample&lt;T&gt;&amp; rhs)
{
    return lhs.val_ == rhs.val_;
}

int main()
{
    Sample&lt;char*&gt; s1;
    Sample&lt;char*&gt; s2;
    cout &lt;&lt; (s1 == s2) &lt;&lt; endl;
}
</code></pre>
",3
1984012,1983639,0,"<p>Is there any difference between the following two implementations?</p>

<blockquote>
  <p>1)</p>
</blockquote>

<pre><code>template &lt;class T&gt;
class a ;
template &lt;class T&gt;
bool operator==(const a&lt;T&gt; &amp;, const a&lt;T&gt; &amp;);
template&lt;typename T&gt;
class a
{
private:
    T var;
    friend bool operator== &lt;&gt;(const a&lt;T&gt; &amp;, const a&lt;T&gt; &amp;);
};

template&lt;typename T&gt; inline bool operator==(const a&lt;T&gt; &amp;r1, const a&lt;T&gt; &amp;r2)
{
    return r1.var==r2.var;
}
</code></pre>

<p>2)</p>

<pre><code>template&lt;typename T&gt;
class a
{
private:
    T var;
    template &lt;class T1&gt;
    friend bool operator==(const a&lt;T1&gt; &amp;, const a&lt;T1&gt; &amp;);
};

template&lt;typename T&gt; inline bool operator==(const a&lt;T&gt; &amp;r1, const a&lt;T&gt; &amp;r2)
{
    return r1.var==r2.var;
}
</code></pre>

<p>If so, which one is preferred?</p>
",4
1134996,1134931,1,"<p>Great question. I think that this should be addressed thoroughly, so I'm going to try to make my answer as thorough as possible.</p>

<p>One thing that I do when approaching large projects that I've either inherited or contributing to is automatically generate their sources, UML diagrams, and anything that can ease the various amounts of A.D.D. encountered when learning a new project:)</p>

<p>I believe someone here already mentioned Doxygen, that's a great tool! You should look into it and write a small bash script that will automatically generate sources for the application you're developing in some tree structure you've setup.</p>

<p>One thing that I've haven't seen people mention is <a href=""http://bouml.free.fr/"" rel=""nofollow noreferrer"" title=""BOUML"">BOUML</a>! It's fantastic and free! It automatically generates reverse UML diagrams from existing sources and it supports a variety of languages. I use this as a way to really capture the big picture of what's going on in terms of architecture and design before I start reading code.</p>

<p>If you've got the money to spare, look into Understand for %language-here%. It's absolutely great and has helped me in many ways when inheriting legacy code.</p>

<p>EDIT:</p>

<p>Try out ack (betterthangrep.com), it is a pretty convenient script for searching source trees:)</p>
",0
1134938,1134931,1,"<p>One of the better ways to understand it is to attempt to document it yourself. By going and trying to document it yourself, it forces you to really dive in and test and test and test and make sure you know what each statement is doing at what times. Then you can really start to understand what the previous developer may have been thinking (or not thinking for that matter).</p>
",0
1134940,1134931,0,"<p>Familiarize yourself with the information available in the headers. The functions you call will be declared there. Then try to identify the valid arguments and pre-/post-conditions of the functions, as those are your primary guidance (even if they are not documented!). The example programs are your next bet.</p>
",0
1134941,1134931,0,"<p>If you have code completion/intellisense I like opening up the library and going '.' or 'namespace::' and seeing what comes up. I always find it helpful, you can navigate through the objects/namespaces and see what functionality they have. This is of course assuming its an OOP library with relatively good naming of functions/objects.</p>
",0
1134949,1134931,5,"<p>I frequently use a couple of tools to help me with this:</p>

<ul>
<li><a href=""http://www.gnu.org/software/global"" rel=""noreferrer"">GNU Global</a>.  It generates cross-referencing databases and can produce hyperlinked HTML from source code.  Clicking function calls will take you to their definitions, and you can see lists of all references to a function.  Only works for C and perhaps C++.</li>
<li><a href=""http://www.doxygen.org"" rel=""noreferrer"">Doxygen</a>.  It generates documentation from Javadoc-style comments.  If you tell it to generate documentation for undocumented methods, it will give you nice summaries.  It can also produce hyperlinked source code listings (and can link into the listings provided by htags).</li>
</ul>

<p>These two tools, along with just reading code in Emacs and doing some searches with recursive grep, are how I do most of my source reverse-engineering.</p>
",0
1138054,1134931,0,"<p>There really isn't a silver bullet other than just rolling up your sleeves and digging into the code.  </p>

<p>This is where we earn our money.</p>
",0
1139741,1134931,0,"<p>Three things;</p>

<p>(1) try to run the test or example apps available, set low debug levels, and walk through logs.
(2) use source navigator tool / cscope ( available both on windows and linux) and browse the code to understand the flow.
(3) also in parallel use gdb to walk into code while running test/example apps.</p>
",0
539560,539536,2,"<p>You could use braces:</p>

<pre><code>A&lt;B*&gt; a;
B* b = (a[i]); // Now it must evaluate the sub-expression a[i]
</code></pre>

<p>NB. Your  example above compiles fine and calls the operator[] as expected.</p>
",0
539570,539536,2,"<p>The following code compiles for me with g++ 3.x. I don't think your analysis of the problem is correct, but in any case could you post the error message you are getting.</p>

<pre><code>template &lt;class X&gt;
struct A {
    X&amp; operator[] (int i) { static X x; return x; }
    operator const X* () { return 0; }
};

class B {};

int main() {
    A&lt;B*&gt; a;
    B* b = a[0];
}
</code></pre>
",0
542574,539536,0,"<p>You can force compiler to bind to <code>operator [ ]</code> by this:</p>

<pre><code>B* b = a::operator [ ] ( 0 );
</code></pre>

<p>But anyway, defining conversions is always a bad idea. I would search every other way around it before resorting to conversion operators.</p>
",0
1245725,1245430,4,"<p>Good books to help prospective C++ programmers learn how to use the language properly. Effective C++ by Scott Meyers was a massive help for me. There are <a href=""https://stackoverflow.com/questions/1122921/suggested-c-books"">other</a> <a href=""https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list"">threads</a> on C++ books.</p>
",6
1245747,1245430,5,"<p>Developers who actually understand OO rather than C with Classes.</p>

<p>Though the field is still full of C programmers with think they know C++ (but don't they are just C with Classes people).</p>
",0
1245834,1245430,10,"<h2>C++0x</h2>

<p>Modern C++ is not only a OOP language. <strong>C++0x</strong> (the new standard) will include many new additions. It might take some time before it is applied thoroughly in every IDE/compilers but it will add a lot to an already excellent language.</p>

<p>Here is a list of new features of the new standard: <a href=""http://en.wikipedia.org/wiki/C%2B%2B0x"" rel=""nofollow noreferrer"">C++0x</a></p>

<p>**Edit: C++0x is the result of the past 8-9 years (thank you jalf).</p>
",5
1245862,1245430,1,"<ul>
<li><p>It¡¯s usually not the first language
you learn at college or university
anymore. This makes prospective
learners appreciative of C++ and
eases them into it.</p></li>
<li><p>The internet, video editing sites,
and forums that help programmers of
all levels to get help and feedback
in a very timely fashion.</p></li>
</ul>
",0
1245443,1245430,54,"<p><a href=""http://www.boost.org/"" rel=""nofollow noreferrer"">Boost</a>:</p>

<blockquote>
  <p>free peer-reviewed portable C++ source libraries.</p>
  
  <p>We emphasize libraries that work well with the C++ Standard Library...</p>
  
  <p>We aim to establish ""existing practice"" and provide reference implementations so that Boost libraries are suitable for eventual standardization. Ten Boost libraries are included in the <a href=""http://www.open-std.org/jtc1/sc22/wg21/"" rel=""nofollow noreferrer"">C++ Standards Committee's</a> Library Technical Report (<a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1745.pdf"" rel=""nofollow noreferrer"">TR1</a>) and in the new C++11 Standard. C++11 also includes several more Boost libraries in addition to those from TR1. More Boost libraries are proposed for standardization in C++17...</p>
</blockquote>
",5
1245453,1245430,9,"<p>Qt is also pretty useful, 'pretty', well-documented, portable, and free (now under LGPL).</p>
",10
1245458,1245430,4,"<p>Although it started in 1998, but it really got going in the last 7-8 years, the boost libraries have added a huge amount of high quality code, which in many ways has helped keep c++ somewhat up to date with the capabilities of more modern languages.</p>
",0
1245624,1245430,2,"<p>Commercially available <a href=""http://en.wikipedia.org/wiki/Whole_program_optimization"" rel=""nofollow noreferrer"">whole-program</a> and <a href=""http://en.wikipedia.org/wiki/Profile-guided_optimization"" rel=""nofollow noreferrer"">profile-guided optimization</a> from various C++ compilers, notably Intel's and Microsoft's.  In particular, cross-module inlining makes it easier to write well-factored code that blazes.</p>
",0
1245650,1245430,20,"<p>""<a href=""https://rads.stackoverflow.com/amzn/click/com/0201704315"" rel=""noreferrer"" rel=""nofollow noreferrer"">Modern C++</a>"", STL, template metaprogramming and Generic programming.</p>

<p>(And yes, they're one single answer, because they're pretty closely intertwined and together represent a complete paradigm shift in C++ development. While some of them are older than 8-9 years, it's pretty much in the last years that they've really gained traction and really left ""C with classes"" in the dust.</p>
",5
1246870,1245430,1,"<p>To me, besides the already mentioned boost, TMP, MC++D etc., the shift away from teaching C++ as ""C plus some extras"" towards ""C++ is a very different language that's not to be used like C"" is very important. That would make <a href=""http://www.acceleratedcpp.com/"" rel=""nofollow noreferrer"">Koenig/Moo ""Accelerated C++""</a> is a huge influence, even though it's a beginners book and even though it's a beginners book that has (with only 250 pages) much too steep a learning curve. </p>

<p>Stroustrup had been saying things about a better language hidden within C++ and the need to teach it better, but I never really understood what he meant until, after 10 years of C++ programming and experience in TMP, I read the book and was enlighted. <code>:^&gt;</code> It's not that I learned any new technical facts from the book. It just taught me a better way to look at (and teach) C++. </p>

<p>And, yes, I have been programming different since then. </p>
",0
1246991,1245430,3,"<p>Scott Meyers wrote about <a href=""http://www.artima.com/cppsource/top_cpp_people.html"" rel=""nofollow noreferrer"">most important C++ people</a> and the <a href=""http://www.artima.com/cppsource/top_cpp_books.html"" rel=""nofollow noreferrer"">most important C++ books</a>. These all had a major influence on how programmers write C++ today.</p>
",0
289671,289559,8,"<blockquote>
  <p>This freedom makes it impossible in theory to link binaries created by different compilers.</p>
</blockquote>

<p>It's impossible for a number of reasons, and structure layout is the most minor. vtables, implementations of <code>operator new</code> and <code>delete</code>, data type sizes...</p>

<blockquote>
  <p>So what are the remaining reasons for the strict in-section ordering?</p>
</blockquote>

<p>C compatibility, I would have thought, so that a struct defined in C packs the same way it does in C++ <em>for a given compiler set</em>.</p>

<blockquote>
  <p>And does the new C++<s>09</s>11 standard provide a way to fully determine object layouts ""by hand""?</p>
</blockquote>

<p>No, no more than the current standard does.</p>

<p>For a <code>class</code> or <code>struct</code> with no vtable and entirely private (or public) fields, though, it's already possible if you use the <code>[u]int[8|16|32|64]_t</code> types. What use case do you have for more than this?</p>
",1
289679,289559,0,"<p>EDIT: I'm afraid i misunderstood your question</p>
<p>I think it's an optimization for memory access.
For example, if we got this structure:</p>
<pre><code>struct example
{
   int16 intData;
   byte  byteData;
   int32 intData;
   byte intData;
   int32 intData;
}
</code></pre>
<p>Let's suppose the word in this platform are 32 bits. Then you will need 4 complete words to pass all the data in the struct:</p>
<blockquote>
<p>int16 + byte = 24 bits (the netx field doesn't fit here)</p>
<p>int32 = 32 bits  (the netx field doesn't fit here)</p>
<p>byte = 8 bits (the netx field doesn't fit here)</p>
<p>int32 = 32 bits</p>
</blockquote>
<p>But if you rearrange the fields to:</p>
<pre><code>struct example
{
   int16 intData;
   byte  byteData;
   byte intData;
   int32 intData;
   int32 intData;
}
</code></pre>
<p>then you can save one memory access.</p>
",0
289762,289559,2,"<p>[edit]
I learnt something new today! found the following standard quote:</p>

<blockquote>
  <p>Nonstatic data members of a
  (non-union) class declared without an
  intervening access-specifier are
  allocated so that later members have
  higher addresses within a class
  object. The order of allocation of
  nonstatic data members separated by an
  access-specifier is unspecified
  (11.1). Implementation alignment
  requirements might cause two adjacent
  members not to be allocated
  immediately after each other; so might
  requirements for space for managing
  virtual functions (10.3) and virtual
  base classes (10.1).</p>
</blockquote>

<p>Interesting - i have no idea why this degree of freedom is given. Continuing to th rest of my previous reply...</p>

<hr>

<p>As mentioned, the reason for preserving the ordering is C compatibility, and back then I guess noone thought of benefits of reordering members, while memory layout was typically done by hand anyway. Also, what now would be considered ""ugly tricks"" (like zeroing selected members with memset, or having two structs with the same layout) were quite common. </p>

<p>The standard does not give you a way to enforce a given layout, but most compilers provide measures to control padding, e.g. #pragma pack on MSVC compilers.</p>

<p>The reason for automatic padding is platform portability: different architectures have different alignment requirements, e.g. some architectures throw on misaligned ints (and these were the simple cases back then).</p>
",3
289988,289559,0,"<p>You are never supposed to link objects created by different compilers. Even if what you talk about is changed, you would still have far more issues that prevent you to link against another compilers' generated files. (aligning, name mangling, calling conventions to only name a few of them). </p>

<p>One reason the compiler is free to order access sections around might be so the compiler could establish an order for the access sections: members with lower addresses are more protected than members with higher addresses, for example. </p>

<p>You would not gain anything if that reordering wasn't allowed: Only PODs provide C compatibility and a way to give you byte offsets of members inside a class/struct (using the macro <code>offsetof</code>) or allows you to memcpy them. A type will become non-POD if you define a custom constructor, copy constructor, a private member or some other stuff. In particular, deriving from a class currently breaks PODness.</p>

<p>C++1x lowers the requirements for PODs. For example, in C++1x <code>std::pair&lt;T, U&gt;</code> is actually a POD, even though it provides its own constructor (which has to fit certain rules though).</p>
",0
718482,718477,18,"<blockquote>
  <p>Now strPtr and strArray are considered to be string literals.</p>
</blockquote>

<p>No, they aren't.  String literals are the things you see in your code.  For example, the <code>""Hello""</code>.  <code>strPtr</code> is a <em>pointer</em> to the literal (which is now compiled in the executable).  Note that it should be <code>const char *</code>; you cannot legally remove the <code>const</code> per the C standard and expect defined behavior when using it.  <code>strArray</code> is an array containing a copy of the literal (compiled in the execuable).</p>

<blockquote>
  <p>Both the above statements should be illegal. compiler should throw errors in both cases.</p>
</blockquote>

<p>No, it shouldn't.  The two statements are completely legal.  Due to circumstance, the first one is undefined.  It would be an error if they were pointers to <code>const char</code>s, though.</p>

<p>As far as I know, string literals may be defined the same way as other literals and constants.  However, there are differences:</p>

<pre><code>// These copy from ROM to RAM at run-time:
char myString[] = ""hello"";
const int myInt = 42;
float myFloats[] = { 3.1, 4.1, 5.9 };

// These copy a pointer to some data in ROM at run-time:
const char *myString2 = ""hello"";
const float *myFloats2 = { 3.1, 4.1, 5.9 };

char *myString3 = ""hello"";  // Legal, but...
myString3[0] = 'j';         // Undefined behavior!  (Most likely segfaults.)
</code></pre>

<p>My use of ROM and RAM here are general.  If the platform is only RAM (e.g. most Nintendo DS programs) then const data <em>may</em> be in RAM.  Writes are still undefined, though.  The location of const data shouldn't matter for a normal C++ programmer.</p>
",0
718485,718477,9,"<pre><code>char *strPtr =""Hello"" ;
</code></pre>

<p>Defines <code>strPtr</code> a pointer to char pointing to a string literal <code>""Hello""</code> -- the effective type of this pointer is <code>const char *</code>. No modification allowed through <code>strPtr</code> to the pointee (invokes UB if you try to do so). This is a backward compatibility feature for older C code. This convention is deprecated in C++0x. See Annex C:</p>

<blockquote>
  <p><strong>Change: String literals made const</strong>
  The type of a string literal is changed from ¡°array of char¡± to ¡°array of const char.¡± [...] </p>
  
  <p><strong>Rationale:</strong> This avoids calling an inappropriate overloaded function, which might expect to be able to modify its argument. </p>
  
  <p><strong>Effect on original feature:</strong> Change to semantics of well-defined feature. Difficulty of converting: Simple syntactic transformation, because string literals can be converted to char*; (4.2). The most common cases are handled by a new but deprecated standard conversion:</p>
  
  <p><code>char* p = ""abc""; // valid in C, deprecated in C++</code></p>
  
  <p><code>char* q = expr ? ""abc"" : ""de""; // valid in C, invalid in C++</code></p>
  
  <p><strong>How widely used:</strong> Programs that have a legitimate reason to treat string literals as pointers to potentially modifiable memory are probably rare.</p>
</blockquote>

<pre><code>char strArray[] =""Hello"";
</code></pre>

<p>The declared type of <code>strPtr</code> is -- it is an array of characters of unspecified size containing the string <code>Hello</code> including the null terminator i.e. 6 characters. However, the initialization makes it a complete type and it's type is array of 6 characters. Modification via <code>strPtr</code> is okay.</p>

<blockquote>
  <p>Where exactly do string literals are stored ?</p>
</blockquote>

<p>Implementation defined.</p>
",1
718652,718477,1,"<p>The older C and C++ compilers were purely based on low level coding where higher standards of data protection were not available, and they can not even be enforced, typically in C and C++ you can write anything you want..</p>

<p>You can even write a code to access and modify your const pointers as well, if you know how to play with the addresses.</p>

<p>Although C++ does enforce some compile level protection, but there is no protection on runtime. You can certainly access your own stack, and use its values to manipulate any data that came in const pointer as well.</p>

<p>That is the reason C# was invented where little higher level standards are enforced because whatever you access is reference,  it is a fixed structure governing all rules of data protection and it has hidden pointer which can not be accessed and nor modified.</p>

<p>The major difference is, C++ can only give you compile time protection, but C# will give you protection even at runtime.</p>
",0
275146,275128,1,"<p>Or Perl. But no, it's not possible (as far as I'm aware), you need to use a temporary variable, as in:</p>

<pre><code>int a = 4;
int b = 5;

{
    int tmp = a;
    a = b;
    b = tmp;
}
</code></pre>

<p>FYI, internally those languages (or Perl atleast) create a temporary list <code>{ a, b }</code>, then assign the list to the two variables. In other words, this is atleast as performant, if only a little more messy.</p>
",0
275149,275128,16,"<p>That's not possible. Your code example</p>

<pre><code>a, b = b, a;
</code></pre>

<p>is interpreted in the following way:</p>

<pre><code>a, (b = b), a
</code></pre>

<p>It does nothing. The comma operator makes it return the value of a (the right most operand). Because assignment binds tighter, b = b is in parens. </p>

<p>The proper way doing this is just </p>

<pre><code>std::swap(a, b);
</code></pre>

<p>Boost includes a tuple class with which you can do</p>

<pre><code>tie(a, b) = make_tuple(b, a);
</code></pre>

<p>It internally creates a tuple of references to a and b, and then assigned to them a tuple of b and a.</p>
",0
275155,275128,3,"<p>Parallel assignment is not supported in C++.  Languages that support this usually treat <code>a,b,c</code> as a list on either side of the assignment operator, this isn't the way the comma operator works in C++.  In C++, <code>a, b</code> evaluates a and then b, so <code>a, b = b, a</code> is the same as <code>a; b = b; a;</code>.</p>
",0
275196,275128,0,"<p>Or Lua...<br>
There are tricks with C/C++, like using xor or operations, but with risk of overflow and such. Just do it the painful way, with three assignments. Not a big deal.</p>
",1
277954,275128,0,"<p>There is no such function in the Standard Library. You could write a set of template functions :</p>

<pre><code>template &lt;typename T1&gt; void ParAssign(T1&amp; Lhs_1, T1 const&amp; Rhs1);
template &lt;typename T1, typename T2&gt; void ParAssign(T1&amp; Lhs1, T2&amp; Lhs2, T1 const&amp; Rhs1, T2 const&amp; Rhs2);
// etc.
ParAssign(a,b,
          b,a);
</code></pre>

<p>That's non-trivial if there is aliasing, as in your swap example. </p>
",1
580070,580053,8,"<p>In this case, storing a vector of <code>Animal</code> would not work for you, as your animals have different sizes, and you wouldn't be able to store the derived objects in the spaces intended to hold the base class. (And even if they're the same size, you won't get the intended polymorphic effect, as base class methods will be executed - the virtualness of a method doesn't come into play unless you access it through a pointer or reference.)</p>

<p>If you want to avoid the annoyance of managing the memory yourself, you could consider storing a smart pointer such as a <a href=""http://www.boost.org/doc/libs/1_38_0/libs/smart_ptr/shared_ptr.htm"" rel=""nofollow noreferrer"">shared_ptr</a> (note that <a href=""http://en.wikipedia.org/wiki/Auto_ptr"" rel=""nofollow noreferrer"">auto_ptr</a> doesn't work with STL containers, according to Max Lybbert), or some variant thereof. That way you can still use your polymorphic class, but it's a little less work for you.</p>

<p>There's no real hard and fast rules about when to use objects and pointers, although it's worth noting that in some cases, like yours, objects just aren't going to work for you. I tend to use objects whenever nothing precludes it though, although you do have to be concerned about expensive copy operations as you note (although sometimes they can be ameliorated by passing containers by reference).</p>
",8
580082,580053,18,"<p>You should use a vector of objects whenever possible; <a href=""https://stackoverflow.com/questions/274626/what-is-the-slicing-problem-in-c"">but in your case it isn't possible</a>.</p>

<p>Containers of pointers let you avoid the slicing problem.  But then you have to call delete on each element, like you are doing.  That's annoying but possible.  Unfortunately there are cases (when an exception is thrown) where you can't be sure that delete is properly called, and you end up with a memory leak.</p>

<p>The main solution is to use a smart pointer.  Pre-C++11 comes with <code>auto_ptr</code>, <a href=""http://www.gotw.ca/publications/using_auto_ptr_effectively.htm"" rel=""nofollow noreferrer"">but that cannot be used in a standard container</a>.  C++11 has <code>std::unique_ptr</code> and <code>std::shared_ptr</code> which are designed to be usable in containers (I prefer <code>std::unique_ptr</code> unless I really need reference counting).  If you can't use C++11, the best solution is <a href=""http://www.boost.org/libs/smart_ptr"" rel=""nofollow noreferrer"">Boost smart pointers</a>.</p>
",2
580489,580053,8,"<p>Rather than using shared_ptr with standard STL containers, take a look at the <a href=""http://www.boost.org/doc/libs/1_38_0/libs/ptr_container/doc/ptr_container.html"" rel=""nofollow noreferrer"">Boost Pointer Container Library</a>. It is designed to solve exactly this problem.</p>
",0
581001,580053,1,"<p>If you ever hear the argument <em>but it'll be so costly to copy them structures all the time</em> when you want to use full objects instead of pointers in a vector, then your 2 main arguments are:</p>

<ol>
<li>We don't need to worry about the lifetime issues of the pointers, which means no leaks from <strong>that</strong> particular code (unless, of course, the structures themselves have pointer data, but that's another story).</li>
<li>The data locality of adjacent structures in memory will boost performance in typical usage scenarios, not slow things down like pointer indirection would (relatively speaking).</li>
</ol>

<p>The added cost of copying is normally taken when adding stuff to the container, not when using the data - think a bit about it: what do you do most? add items or use them?</p>

<p>However, when adding polymorphical objects, the pointers are necessary to avoid slicing.</p>
",0
1332688,1332632,2,"<p>The main factor in choosing which method to use would be that your functions themselves may want to operate on private state or utilize private methods, in which case a static class is definitely the better option.</p>

<p>There's a few other nuances, but ultimately a static class will afford you more control in your encapsulation.</p>
",0
1332653,1332632,9,"<p>They mean different things. In a <code>class</code> context, <code>static</code> means that methods do not required an object to act on, so are more like free functions. In a <code>namespace</code> context, it means that the functions have internal linkage so are unique to the translation unit that they are defined in.</p>

<p>In addition, the members of a <code>class</code> are private by default so, as written, your class functions are only callable from each other. You would need to add a <code>public:</code> access specifier or make the <code>class</code> a <code>struct</code> to change this. </p>

<p>If you need a bunch of free functions and don't need class objects then it's probably more suitable to define them as non-<code>static</code> functions in a namespace. If they are defined in line in a header file, then they usually need to be declared <code>inline</code>. This is implied if they are defined in a <code>class</code>.</p>
",0
1332657,1332632,6,"<p>Without seeing the body of these functions, I would say that namespaces are more appropriate. With namespaces, you can have <code>using</code> statements, so that you don't have to fully-qualify the function names when calling them.</p>

<p>The only case in which to use classes is when the static methods have any relationship with objects of the class, e.g. when they need to access private members of instances. From your description, it seems that you won't be creating any instances of xyz, so you shouldn't be using classes here.</p>

<p>From a memory management point of view, there is no difference between these approaches.</p>
",1
1990755,1990636,1,"<p>It's possible, but it's way more likely that there is a bug in your code.</p>

<p>Perhaps you should post some code.</p>
",0
1614679,1614641,1,"<p>Take a look at this Microsoft article:</p>

<p><a href=""http://msdn.microsoft.com/en-us/library/ms235291.aspx"" rel=""nofollow noreferrer"">How to: Deploy using XCopy</a></p>
",2
1614681,1614641,1,"<p>If you just depend on the CRT, then yes you can simply XCOPY deploy it as a private assembly and it will work just fine.  Put it in the same folder as your application.  </p>

<p>Doing this will prevent your application from taking advantage of servicing releases of the CRT though.  This may or may not be an issue for you.</p>
",0
1709636,1709562,-2,"<p>I've used similar to both in different circumstances but you've overcomplicated the first IMO:</p>

<pre><code>bool MyApplication::ReportGenerator::GenerateReport(){
    bool retval = false;
    if (!isAdmin()){
    }
    else if (!isConditionOne()){
    }
    else if (!isConditionTwo()){
    }
    else if (!isConditionThree()){
    }
    else
        retval = generateReport();
    return retval;
}
</code></pre>
",2
1709646,1709562,3,"<p>Regarding example 1: If you want goto, why don't you write goto??? It's much clearer than your suggestion. And considering that goto should only be used rarely, I vote for #2.</p>
",1
1709655,1709562,26,"<p>I would personally prefer a variation on your second code segment. The short circuiting will work the same, but the conditional is less verbose.</p>

<pre><code>bool MyApplication::ReportGenerator::GenerateReport()
{
    if(isAdmin() &amp;&amp; isConditionOne() &amp;&amp; isConditionTwo() &amp;&amp; isConditionThree())
    {
        return generateReport();
    }

    return false;
}
</code></pre>

<p>It says everything in one nice clean spot. ""If all these conditions are met, then do this. Otherwise, don't.""</p>

<p>I feel like your first code segment makes that logic harder to see by spreading the condition across 12 lines. Also, the encasing loop might cause someone to do a double take.</p>
",2
1709657,1709562,4,"<p>Code 1 is, IMO, worst as it does not immediately convey the intendend meaning which is to generate the repoort only in certain circumstances.</p>

<p>Using:</p>

<pre><code>   if (condition_1) return false;
   if (condition_2) return false;
   ...
</code></pre>

<p>would be better.</p>

<p>Also, what I dislike in code 1 is the fact that it try to mask gotos using a while and breaks (which <em>are</em> gotos). I would then prefer to use directly a goto, at least it would have been easier to see where the landing point is.</p>

<p>Code 2 might be formatted to look nicely, I guess:</p>

<pre><code> bool MyApplication::ReportGenerator::GenerateReport(){
     if (!isAdmin()        || !isConditionOne() ||
         !isConditionTwo() || !isConditionThree()) {
        return false;
     }
     return generateReport();
 }
</code></pre>

<p>Or  something similar.</p>
",0
1709658,1709562,5,"<p>I prefer a modification of sample 2:</p>

<pre><code>bool MyApplication::ReportGenerator::GenerateReport()
{
    bool returnValue = false;
    if (isAdmin() &amp;&amp;
        isConditionOne() &amp;&amp;
        isConditionTwo() &amp;&amp;
        isConditionThree())
    { 
        returnValue = generateReport();
    } 
    return returnValue;
}
</code></pre>

<p>It has the benefit of having a single exit point for the function, which is recommended for easier maintenance.  I find stacking conditions vertically instead of horizontally easier to read quickly, and it's a lot easier to comment individual conditions if you need to.</p>
",1
1709659,1709562,0,"<p>A switch would be a better solution to your problem I think. You would need to overload the method to take in an int param and I don't know if that's something you would want to do or not.</p>

<pre><code>Bool MyApplication::ReportGenerator::GenerateReport(int i)
{
  switch(i)
  {
    case 1:
       // do something
       break;
    case 2:
       // do something
       break;
   // etc
 }
 return GeneratReport()
}
</code></pre>

<p>Not really sure what your plan is since you're calling the method recursively and as some point you will want to leave the method.</p>
",0
1709768,1709562,17,"<pre><code>bool MyApplication::ReportGenerator::GenerateReport()
{
   return isAdmin()  
      &amp;&amp; isConditionOne() 
      &amp;&amp; isConditionTwo()
      &amp;&amp; isConditionThree()
      &amp;&amp; generateReport();    // Everything's ok.
}
</code></pre>
",7
1710073,1709562,0,"<p>Code Complete is a commonly recommended book that goes into some detail about those kinds of stylistic issues. Also consider taking a look at some of the published organization style guides to see if they have any opinions on the issue; <a href=""http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml"" rel=""nofollow noreferrer"" title=""Google&#39;s Style Guide"">Google's Style Guide</a>, for instance.</p>

<p>As to what I prefer, the second example is much better to my mind. The first is essentially an abuse of the do {} while construct to avoid using a goto, dogmatically sticking to the letter of ""avoid gotos at all cost"" while missing its spirit of ""code for clarity, don't use unobvious language tricks"". </p>

<p>In fact, the only reason to even use a goto at all would be to dogmatically stick to a ""only one return statement per function"" approach when you could get away with a simple, readable</p>

<pre><code>if (!isAdmin()){
    return false;
}
else if (!isConditionOne()){
    return false;    }
else if (!isConditionTwo()){
    return false;    }
else if (!isConditionThree()){
    return false;    }
else
    return generateReport();
</code></pre>

<p>Other thoughts?</p>

<p>Don't name local variables that are used to hold a computed success state ""returnValue"" or similar. <em>Obviously</em> whatever you return is the return value, any one who can read C can see what is being returned. Tell me <em>what</em> computation it holds. The name ""returnValue"" gives me no information as to what it means when it is true or false. In this example ""couldGenerateReports"" or similar would be far more preferable.</p>
",0
1709589,1709562,6,"<p>It really depends on the future expectations of the code.  Code1 above implies that there may be additional logic to be added for each of the conditions; Code2 above implies rather that there is a rational grouping of the conditionals.  Code1 may be more relevant if you expect to add logic for the conditions at a later date; if you don't, though, Code2 is probably more sensible because of the brevity and implied grouping.</p>
",0
1709591,1709562,40,"<p>I don't really like using a do/while loop in this way.  One other way to do this would be to break your conditional in Code2 into separate if checks.  These are sometimes referred to as ""guard clauses.""</p>

<pre><code>bool MyApplication::ReportGenerator::GenerateReport()
{
    if (!isAdmin())
        return false;

    if (!isConditionOne())
        return false;

    // etc.

    return generateReport();

}
</code></pre>
",5
1709595,1709562,1,"<p>Personally I prefer sample 2.  It groups those items that will not result in the report being generated together.</p>

<p>As far as general coding guidelines, the book Code Complete (<a href=""https://rads.stackoverflow.com/amzn/click/com/0735619670"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">Amazon)</a> is a good reference for coding style issues.  </p>
",0
1709599,1709562,4,"<p>Which on do you think best expresses what the code is trying to say. Which one do you need to work hardest to understand?</p>

<p>I would do this:</p>

<pre><code>bool MyApplication::ReportGenerator::GenerateReport(){
    if (isAdmin()  &amp;&amp; isConditionOne() &amp;&amp; isConditionTwo() &amp;&amp; isConditionThree()){
         return generateReport();
    } else {
        return false;
    }

}
</code></pre>

<p>Because: </p>

<p>a). Prefer to say what I want rather than what I don't want
b). prefer symmetry, if and else. Clearly all cases covered.</p>
",1
1709614,1709562,8,"<pre><code>bool MyApplication::ReportGenerator::GenerateReport(){
    if ( ! isAdmin         () ) return false ;
    if ( ! isConditionOne  () ) return false ;
    if ( ! isConditionTwo  () ) return false ;
    if ( ! isConditionThree() ) return false ;
    return generateReport() ;
}
</code></pre>
",0
1710900,1709562,0,"<p>Personally I prefer my <code>for</code>, <code>while</code> and <code>do ... while</code> loops to be actual loops.  In the first code example this is not the case.  So I would opt for example 2.  Or, as others have already said, for breaking example 2 into a number of <code>if ... return</code> statements.</p>
",0
1711008,1709562,4,"<p>I like the answers that are a variation of version 2, but just to give an alternative: If those conditions are logically tied together, chances are that you will need to check for them again in other places. If this is true, then maybe a helper function would do the job better. Something like this:</p>

<pre><code>bool isReportable(anyParametersNeeded){
    //stuffYouWantToCheck
}

bool MyApplication::ReportGenerator::GenerateReport(){
    if (isReportable(anyParametersNeeded)){
        return generateReport();
    }
    return false;
}
</code></pre>

<p>As this function is small, maybe you can even inline it (or let the compiler decide ;)). Another bonus is that if you want to include some extra checks in the future, you only have to change that function and not every spot where it's used.</p>
",1
568226,568218,7,"<p>Is ""total_pairs"" an int? If so, the divide is done as integer division. You need to explicitly cast one of the numbers to a double (and the other will be automatically promoted to double):</p>

<pre><code>double percent = ((double)total_pairs)/10000; // or just simply 10000.0
</code></pre>
",4
568233,568218,2,"<p>Dividing integers gives you an integer in C and C++ (I am not sure about the right English word for the corresponding operation, but 10/4 gives you 2, etc... that is the integer part of the division). So the following:</p>

<pre><code>double a = 1000 / 10000;
</code></pre>

<p>First compute, as an int, 1000 / 10000 (0 in this case), and then cast this to double.</p>

<p>Casting the argument is one way - I prefer to simply input float instead of integers myself, but that's personal preference:</p>

<pre><code>double a = 1000. / 10000.;
</code></pre>

<p>(just one is enough: that is 1000 / 10000. will work as well).</p>
",1
568234,568218,8,"<p>Yes, this is the case, the following performs integer division. The result (0) is then converted to a double. </p>

<pre><code>double percent = 5600/10000
</code></pre>

<p>The line below forces 5600 to be a double so now you have actual division of doubles</p>

<pre><code>double percent = (double) 5600/10000
</code></pre>

<p>If one of your numbers is a constant you can just make sure you use decimal format for it to force floating point division:</p>

<pre><code>double percent = 5600.0/10000
</code></pre>

<p>Another trick I sometimes use is to multiply by a 1.0 which converts what follows to a double:</p>

<pre><code>double percent = 1.0 * inta / intb
</code></pre>
",0
568239,568218,2,"<p>The problem with your code:</p>

<pre><code>double percent = (double) 5600/10000;
</code></pre>

<p>is you are assuming that the typecast applies to the 5600. It does not. What actually happens is the division is done (and truncated, because both numbers are ints), and then the final result is cast to a double. So, you get the truncated result. The above code is equivalent to:</p>

<pre><code>double percent = (double) (5600/10000);
</code></pre>

<p>What you need for the division to function as you need is for the numerator (first number) to be a double. You can do this by wrapping the cast in parentheses</p>

<pre><code>double percent = ((double) 5600)/10000;
</code></pre>

<p>Which is more useful if the numerator is actually a variable. Alternately you can just put a decimal place at the end of the number, if you are dealing with a numerical constant.</p>

<pre><code>double percent = 5600.0/10000;
</code></pre>
",2
567333,567323,3,"<p>I'd suggest starting with Bruce Eckel's <a href=""http://www.mindview.net/Books/TICPP/ThinkingInCPP2e.html"" rel=""nofollow noreferrer"">Thinking in C++</a> for a start.   </p>

<p>It's already around for some time (latest version 2003) but it provides a good path from beginner to the more advanced techniques and interiors of C++. It has also some OO foundations in case you like to want to know more about that basics.</p>

<p>(<a href=""http://www.mindviewinc.com/Books/"" rel=""nofollow noreferrer"">Master download site</a> for the book)</p>
",0
567353,567323,3,"<ol>
<li>cprogramming.com </li>
<li>cplusplus.com</li>
</ol>
",1
567355,567323,1,"<p><a href=""http://www.amazon.co.uk/Accelerated-Practical-Programming-Example-Depth/dp/020170353X/ref=sr_1_4?ie=UTF8&amp;s=books&amp;qid=1235080299&amp;sr=1-4"" rel=""nofollow noreferrer"">http://www.amazon.co.uk/Accelerated-Practical-Programming-Example-Depth/dp/020170353X/ref=sr_1_4?ie=UTF8&amp;s=books&amp;qid=1235080299&amp;sr=1-4</a></p>

<p>is great for c++, you'll know the .net from your c#</p>
",0
567366,567323,3,"<p>For a beginner I think a good starting place is <a href=""http://books.google.com/books?id=4vRE_Q41ZHEC&amp;dq=c%2B%2B+primer&amp;printsec=frontcover&amp;source=bn&amp;hl=en&amp;ei=PdSdSYvWNYGCtweFvPWGDQ&amp;sa=X&amp;oi=book_result&amp;resnum=6&amp;ct=result"" rel=""nofollow noreferrer"">C++ Primer</a>.  From there I'd recommend Scott Meyers' <a href=""https://rads.stackoverflow.com/amzn/click/com/0201924889"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">Effective C++</a> books.</p>

<p>Certainly this has been asked before, I just can't find the duplicate.</p>
",0
567380,567323,7,"<p>There's no such thing as "".Net c++"".</p>

<p>Maybe you mean <strong>C++/CLI</strong>, which is Microsoft's language specification intended to supersede Managed Extensions for C++ (See <a href=""http://en.wikipedia.org/w/index.php?title=C%2B%2B/CLI"" rel=""nofollow noreferrer"">Wikipedia</a>). <strong>Managed extensions to C++</strong> are its inferior and now defunct ancestor [thanks @dp for your comment].</p>

<p>Bear in mind when you choose your learning material that C++/CLI is not equal to the (standard) <strong>C++</strong> programming language; so if you want to learn the former, you should edit the question title and tags.</p>

<p>(Note: This is not to be nitpicky, but to help. I think getting the right idea for each name, and the right name for each concept, is an important factor for consistent learning. And of course it's especially important if you search for information on the web.)</p>
",4
567816,567323,0,"<p>The biggest tip: in C# you'd do everything with classes, and in C++, you do anything to do with the Win32 API with function calls. </p>

<ol>
<li>google.com and msdn.microsoft.com are your friends.</li>
<li>Never give up. C++ is much more time-consuming to write, and it's easier to make mistakes.</li>
<li>As you are writing your programs, look for small examples that do small pieces of what you want to achieve, and study them.</li>
</ol>
",0
1196559,1196540,1,"<p>It is valid to allow this sort of pattern:</p>

<pre><code>void foo(const SomeType &amp;);

foo(SomeType(bar))
</code></pre>

<p>In this case, a temporary SomeType is constructed and passed to foo. Most likely, the fact that you can also have constant references on the stack to temporaries is a side effect of the verbiage used to define this behavior in the standard. Note that, as onebyone mentioned in the comments, the temporary's lifetime is extended to be that of the reference itself.</p>
",3
1196812,1196540,0,"<p>There could be several reasons:</p>

<p>what if you don't want a const object referred to?
For example this won't work:</p>

<pre>
    const Foo &myFoo = getFoo();
    myFoo.myfield = x;
</pre>

<p>Or, what if you are returning a temp object from getFoo()?  This will warn about returning a reference (or address) to a local:</p>

<pre>
    const Foo &getFoo(void)
    {
       Foo localFoo();
       // do the things you want to localFoo
       return( localFoo );
    }
</pre>

<p>the internals of <code>const Foo&amp; myFoo = getFoo()</code> do pretty much the same thing as 
<code>Foo myFoo = getFoo()</code> so the argument that there is performance value to the const ref return are invalid.  I find it no problem to return objects of reasonable size.</p>

<p>Disclaimer - I did not try these examples on gcc.  Your mileage may vary accordingly.</p>
",1
1197331,1196540,4,"<p>I think <a href=""http://herbsutter.wordpress.com/2008/01/01/gotw-88-a-candidate-for-the-most-important-const/"" rel=""nofollow noreferrer"">GotW #88</a> answers this best</p>
",0
1199192,1196540,4,"<p>Contrary to popular opinion, there is no guarantee that assigning the result of a function returning an object by value to a const reference will result in fewer copies than assigning it to the object itself.</p>

<p>When you assign an rvalue to a const reference, the compiler may bind the reference in one of two ways. It may create a new temporary by copying the rvalue and bind the reference to that, or it may bind the reference directly to the rvalue itself.</p>

<p>If the compiler is not able to make the 'obvious' optimization to remove the temporary and elide the copy constructor for the return value of <code>getFoo</code>, then how likely is it to be able to do the more efficient form of binding an rvalue to a const reference without making a new temporary?</p>

<p>One reason to use a const reference would be to make the function more robust against potential slicing. If the return type were actually a type derived from <code>Foo</code>, then assigning to a base class const reference would be guaranteed not to slice, even if the compiler did make a temporary object from the rvalue returned by the function. The compiler will also generate the correct call to the derived class destructor <em>whether or not the destructor in the base class is virtual or not</em>. This is because the type of the temporary object created is based on the type of the expression being assigned and not on the type of the reference which is being initialized.</p>

<p>Note that the issue of how many copies of the return value are made is entirely separate from the <em>return value optimization</em> and the <em>named return value optimization</em>. These optimizations refer to eliminating the copy of either the rvalue result of evaluating a return expression or of a named local variable into the return value of a function in the  body of the function itself. Obviously, in the best possible case, both a return value optimization can be made and the temporary for the return value can be eliminated resulting in no copies being performed on the returned object.</p>
",4
481227,481196,4,"<p>If you're checking to see if it's binary, it will always return true.  If your method takes a <code>double</code> as the parameter, the number is already represented in binary (<code>double</code> is a binary type, usually 64 bits).  Looking at your code, I think you're actually trying to see if it can be represented exactly as an integer, in which case why can't you just cast to <code>int</code>, then back to <code>double</code> and compare to the original.  Any integer stored in a double that's within the range representable by an <code>int</code> should be exact, IIRC, because a 64 bit <code>double</code> has 53 bits of mantissa (and I'm assuming a 32 bit int).  That means if they're equal, it's an integer.</p>
",5
481245,481196,0,"<p>Or even easier: </p>

<pre><code>return pNumber == floor(pNumber);
</code></pre>

<p>On the other hand, if you have some  weird fractional representation (numerator denominator pair, or string with a decimal in it, or something), and you really do want to know if the value can be exactly represented as a double, it's a bit harder.</p>

<p>But you would need a different parameter(s) for that...</p>
",1
481352,481196,1,"<p>As rmeador have pointed out, it might not be a good idea to accept the double, because the number has been converted to a double, an possible approximation to the number that you're trying to check.</p>

<p>So, in a very abstract way, you should split your check into integers, and decimals. Integers should not be too large such that the mantissa cannot express all the integers, (e.g. 9007199254740993 should not be represented properly by a 64-bit fp)
Decimal points may be a bit easier, mentally, because if anything after the decimal point (e.g. yyy in xxx.yyy) contains a factor of anything other than 2, the floating point repeats in order to try to represent it. It's the reason why 1/3 cannot be represented with finite digits in base 10 = base (2*5)... See <a href=""http://en.wikipedia.org/wiki/Recurring_decimal"" rel=""nofollow noreferrer"">Recurring Decimal</a></p>

<p>EDIT: As the comments pointed out, if the decimal number has a factor of anything other than 1/2, that would be the mathematically correct way to say it...</p>
",2
481357,481196,0,"<p>I don't think this is what he's asking...  I think he's looking for a solution that will tell him if a number can be represented EXACTLY in binary form.  For example, 33.3.. That's a number cannot be represented in binary, because it will go on forever, so depending on your FPU settings, it will be represented as something like ""33.333333333333336"".  So, it looks like his method will do the job.  I don't know of a better way off the top of my head.
\</p>
",2
481382,481196,5,"<p>I think what you are looking for is a number which has a fractional portion which is the sum of a sequence of negative powers of 2 (aka: 1 over a power of 2). I believe this should always be able to be represented exactly in IEEE floats/doubles.</p>

<p>For example:</p>

<p>0.375 = (1/4 + 1/8) which should have an exact representation.</p>

<p>If you want to generate these. You could try do something like this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cstdlib&gt;

int main() {
    srand(time(0));
    double value = 0.0;
    for(int i = 1; i &lt; 256; i *= 2) {
        // doesn't matter, some random probability of including this
        // fraction in our sequence..
        if((rand() % 3) == 0) {
            value += (1.0 / static_cast&lt;double&gt;(i));        
        }
    }
    std::cout &lt;&lt; value &lt;&lt; std::endl;
}
</code></pre>

<p>EDIT: I believe your function has a broken interface. It would be better if you had this:</p>

<pre><code>bool canBeRepresentedExactly(int numerator, int denominator);
</code></pre>

<p>because not all fractions have exact representations, but the moment you shove it into a double, you've chosen a representation in binary... defeating the purpose of the test.</p>
",0
481849,481196,1,"<p>You can't pass IN a Double because it's already lost precision.  You should be able to use the toString() method of Double to check for this. (example in Java)</p>

<pre><code>public static Boolean canBeRepresentedInBase2(String thenumber)
{
    // Reuturns true of the parsed Double did not loose precision.
    // Only works for numbers that are not converted into scientific notation by toString.
    return thenumber.equals(Double.parseDouble(thenumber).toString())
}
</code></pre>
",0
481959,481196,0,"<p>Given a number r it can be represented exactly with finite precision in base 2 iff r can be written as r = m/2^n, where m, n are integers, and n >= 0.</p>

<p>For example 1/7 doesn't have a finite binary expression, also 1/6 and 1/10 can't be written with a finite expression in base 2.</p>

<p>But 1/4+1/32+1/1024, have a finite expression in base.</p>

<p>PS: In general you can express a number r with finite digits in a base b iff r=m/b^n where m, n are integers an n >= 0.</p>

<p>PPS: As almost everybody has stated previously using a double as input is a bad idea, because you are loosing precision, and you will end up with a different number.</p>
",0
481486,481196,1,"<p>As others have mentioned, your method doesn't do what you mean, since you pass a number represented as a (binary) double. The method actually detects, if the number you passed is in the form <code>integer/2^48</code>. This should fail for numbers like <code>(1+2^-50)</code>, which is binary, and <code>259/255</code>, which isn't.</p>

<p>If you really want to test a number for being exactly representable by finite binary string, you have to pass a number in an exact form.</p>
",2
481500,481196,2,"<p>If you're passing in a double, then by definition, it has already been represented in binary and if not, then you've already lost accuracy. </p>

<p>Maybe try passing in numerator and denominator of the fraction to the function. Then you have not lost accuracy and can check to see if you can come up with a binary representation of the answer that is the same as the fraction you've passed in. </p>
",0
481556,481196,1,"<p>You asked for C++ but maybe this algorithm will help.  I use ""EE"" to mean ""exactly expressible as a float.""</p>

<p>Start with a decimal representation of the number you want to test.  Remove any trailing zeroes (that is, 0.123450000 becomes 0.12345).</p>

<p>1)  If the number is not an integer, check to see if the rightmost digit is 5.  If it's not, then stop -- the number is not EE.
2)  Multiply the number by 2.  If the result is an integer, then stop -- the number is EE.  Otherwise, go back to step 1.</p>

<p>I don't have rigorous proof for this but a ""warm fuzzy.""  Fire up Calculator and enter your favorite fractional power of 2, like 0.0000152587890625.  Add it to itself a few dozen times (I just hit ""+"" once then ""="" a bunch of times).  If there are any non-zero digits to the right of the decimal point, the last digit is always 5.</p>
",2
489870,481196,0,"<p>Ignoring the general criticism of using a double...
For a general finite decimal, you can determine if it has a finite representation in binary with the following algorithm:</p>

<ol>
<li>Extract the fraction part of the decimal <em>f</em>.</li>
<li>Determine <em>f</em> x 10<sup><em>b</em></sup> = <em>c</em>, where <em>b</em> and <em>c</em> are integers.</li>
<li>Determine 2<sup><em>d</em></sup> >= 10<sup><em>b</em></sup>, where <em>d</em> is an integer.</li>
<li>If <em>c</em> x 2<sup><em>b</em></sup> / 10<sup><em>b</em></sup> is an integer, then the decimal has a finite representation in binary. Otherwise, it doesn't.</li>
</ol>

<p>You can generalize this to any two bases.</p>
",4
922687,481196,1,"<p>Here is the code in C# and it works. Because it works with the Decimal data - there are no inherent rounding errors that show up in the original code which uses double. (decimal in C# stores using base 10 instead of base 2 - which is what double does)</p>

<pre><code>static bool canBeRepresentedInBase2(decimal pNumberInBase10)
{
    //check if a number in base 10 can be represented exactly in base 2
    //reference: http://en.wikipedia.org/wiki/Binary_numeral_system
    bool funcResult = false;

    int nbOfDoublings = 16*3;
    decimal doubledNumber = pNumberInBase10;
    for (int i = 0; i &lt; nbOfDoublings ; i++)
    {
        doubledNumber = 2*doubledNumber;
        decimal intPart;
        decimal fracPart = ModF(doubledNumber/2, out intPart);
        if (fracPart == 0) //number can be represented exactly in base 2
        {
                funcResult = true;
                break;
        }
    }
    return funcResult;
}

static decimal ModF(decimal number, out decimal intPart)
{
    intPart = Math.Floor(number);
    decimal fractional = number - (intPart);
    return fractional;
}
</code></pre>

<p>Tested with the following code (where WL does a Console.WritelLine - SnippetCompiler)
WL(canBeRepresentedInBase2(-1.0M/4.0M)); //true
WL(canBeRepresentedInBase2(0.0M)); //true
WL(canBeRepresentedInBase2(0.1M)); //false
WL(canBeRepresentedInBase2(0.2M)); //false
WL(canBeRepresentedInBase2(0.205M)); //false
WL(canBeRepresentedInBase2(1.0M/3.0M)); //false
WL(canBeRepresentedInBase2(7.0M/8.0M)); //true
WL(canBeRepresentedInBase2(1.0M));   //true
WL(canBeRepresentedInBase2(256.0M/255.0M)); //false
WL(canBeRepresentedInBase2(1.02M)); //false
WL(canBeRepresentedInBase2(99.005M)); //false
WL(canBeRepresentedInBase2(2.53M)); //false</p>
",0
473484,473324,1,"<p>I'm afraid you'll have to be more specific.</p>

<p>The state space of a class is the Cartesian product of the state space of each component, and it doesn't take a particularly complicated class to have more possible states than there are protons in the Universe.  With a few exceptions, C++ code is not well suited to analysis with state space.</p>

<p>State machines are usually associated with regular expressions.  Do you want a tool that does something with a regular expression?</p>

<p>If so, what?  Languages that accept regular expressions do something to convert them to a form of state space representation, leaving it in some sort of internal form.  Do you want it in the form of a readable diagram, as the tag implies?</p>
",0
377922,377862,0,"<p>You could instanciate a new window and show it on the click event</p>
",0
378011,377862,1,"<p>It depends completely on the windowing system you are using, or the graphics library.  ?Are you using .NET? ?MFC?</p>

<p>In any case, your button object will have a way to associate a function to its click event.  Just write a function that does what you need (in this case, open the ""Edit"" window), associate this function to the click event of your button, and you are done.</p>
",0
378236,377862,1,"<p>Make your edit window hidden by default in the resource editor and show it with ShowWindow(hEditWnd,SW_SHOW) when the button is clicked.</p>
",0
1482414,1482397,6,"<p><code>priority_queue</code> class is designed for using as queue with priorities. And it designed to remove elements with <code>pop</code> function. If you want to get different behavior you should use different class. For instance, <code>std::map</code>.</p>

<p>If you're ready to manually control a consistence of the queue you may take a look on <code>std::make_heap</code>. It's easy to create a max-heap with it. But in this case you need to manually rebuild a queue each time you want to remove an element.</p>
",2
1022577,1022556,1,"<p>Your question is very hard to understand but it sounds like you could use the <a href=""http://en.wikipedia.org/wiki/Observer_pattern"" rel=""nofollow noreferrer"">Observer Pattern</a>.</p>

<p>You might want to look at different <a href=""http://www.cercs.gatech.edu/multicore/images/f/f0/MultithreadingModels.ppt"" rel=""nofollow noreferrer"">threading models (power point slides)</a> as well.</p>
",0
1022601,1022556,3,"<p>I recommend you to read a Design pattern book like GoF or Head First Design Patterns. You have to know where is good place for every pattern and the pattern ""will come to you"" when it is needed for your code.</p>

<p>It's a very bad practice try to use a pattern in every place.</p>
",0
1022690,1022556,0,"<p>If you want to have the one process automatically update when the other processes change, then Observer pattern is the one you want to use where the one process observes the states of the others and is notified when to check for updates.  Even if you are doing this on a user's request instead of automatically, an Observer pattern is still a good one to use.</p>

<p>For these other processes, does their state determine their behavior?  If so then you might want to look into a <a href=""http://en.wikipedia.org/wiki/State_pattern"" rel=""nofollow noreferrer"">State Pattern</a> so you don't have to deal with multiple or nested if statements.</p>
",0
1022886,1022556,0,"<p>If we're talking about sending messages between remote processes, and for some service to collate all the responses together, then perhaps you are looking for the <a href=""http://www.eaipatterns.com/Aggregator.html"" rel=""nofollow noreferrer"">Aggregator</a>, or <a href=""http://www.eaipatterns.com/BroadcastAggregate.html"" rel=""nofollow noreferrer"">Scatter-Gather</a> patterns?</p>
",0
982643,982529,1,"<p>I would suggest contacting the publisher.  </p>
",0
982650,982529,3,"<p>The only thing I can think of is the book ""C++ Gems"", which is basically 42 articles from the first 7 years, published in 1996. I got a copy from a used bookstore a few years ago.</p>

<p>It would be nice to have a dvd - I have the Dr. Dobbs and C/C++ UJ ones. The indexing seems a little flakey, but everything is there if you look hard enough.</p>
",2
646309,646169,38,"<pre><code>#include &lt;iostream&gt;
class tclass
{
  public:
    void operator &lt;&lt;(char *s)
    {
          std::cout&lt;&lt;""I""&lt;&lt;s&lt;&lt;""You""&lt;&lt;std::endl;
    }
};

tclass cout;

int main()
{
  cout&lt;&lt;""love"";
}
</code></pre>
",2
646357,646169,9,"<p>Not as elegant as litb's, but an alternative:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int foo()
{
    cout &lt;&lt; ""I Love You"" &lt;&lt; endl;
    return cout.rdbuf(0);
}
int i = foo();

int main()
{
    cout &lt;&lt; ""Love"" &lt;&lt; endl;
}
</code></pre>
",2
646359,646169,0,"<p>The lesson is that C++ can execute code before and after main() through static constructors/destructors, eg. the code posted by litb.</p>
",1
646555,646169,13,"<p>Not as elegant as litb's, but it works</p>

<pre><code>#include &lt;iostream&gt; 
#include &lt;cstdio&gt; 
#include &lt;sstream&gt; 

#define cout     printf(""I love you\n""); std::ostringstream os; os 

int main() 
{ 
    cout &lt;&lt; ""love""; 
}
</code></pre>

<p>Of course, you don't need to use a <code>stringstream</code>, you could use any class with <code>operator&lt;&lt;</code>.</p>
",0
646173,646169,-1,"<p>You need to change the main, by either calling another function or by changing the text. Since <code>main()</code> is the main output of your program</p>
",1
646175,646169,-1,"<p>Can you be a little more precise? </p>

<p>You want the output of that piece of code to be ""I love you"" instead of ""Love""?</p>

<p>Edit: I don't think you can't without changing at least one line of code in main(). You can either change from cout&lt;&lt;""Love"" to cout&lt;&lt;""I love you"" or just add a function that outputs that specific line. </p>
",2
646176,646169,0,"<p>Shouldn't your main function return an int? You're either going to need to change the method, or write another program that this one pipes into, but that's the most round about way to change a simple string...</p>
",2
646179,646169,2,"<p>That code has no using std but anyway it would require writing your own wrapper around cout and removing the using std if there was and replace with using mystd where the wrapper is defined.</p>
",0
646180,646169,1,"<p>I guess you could write an operator&lt;&lt; that added ""I"" before and ""You"" after the current output.</p>
",2
646182,646169,90,"<p>Ok, fixing your main function and iostream.h ... This is the way</p>

<pre><code>#include &lt;iostream&gt;

// to make sure std::cout is constructed when we use it
// before main was called - thxx to @chappar
std::ios_base::Init stream_initializer;

struct caller {
    caller() { std::cout &lt;&lt; ""I ""; }
    ~caller() { std::cout &lt;&lt; "" You""; }
} c;

// ohh well, for the br0ken main function
using std::cout;

int main()
{
    cout&lt;&lt;""Love"";
}
</code></pre>

<p>I figured i should explain why that works. The code defines a structure that has a constructor and a destructor. The constructor is run when you create an object of the struct and the destructor is run when that object is destroyed. Now, at the end of a struct definition, you can put declarators that will have the type <code>caller</code>. </p>

<p>So, what we did above is creating an object called <code>c</code> which is constructed (and the constructor called) at program start - even before main is run. And when the program terminates, the object is destroyed and the destructor is run. In between, <code>main</code> printed ""Love"". </p>

<p>That pattern actually is very well known by the term <code>RAII</code> which usually claims some resource in the constructor and releases it again in the destructor call. </p>
",13
646186,646169,8,"<p>Like this:</p>

<pre><code>#include &lt;iostream&gt;
int main() {
   std::cout &lt;&lt; ""I Love You"" &lt;&lt; std::endl;
   return 0;
}

/*
#include&lt;iostream.h&gt;
void main()
{
    cout&lt;&lt;""Love"";
}
*/
</code></pre>

<p>This way, you haven't changed anything in <em>the</em> <code>main</code>. :-p</p>
",3
1888990,646169,5,"<p>We can do it like this too:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
using namespace std;

int fnfoo(int inum){
   cout &lt;&lt; ""I Love You"" &lt;&lt; endl;
   return (exit(0),inum);
}

int dummy = fnfoo(5);

int main()
{
   cout &lt;&lt; ""Love"" &lt;&lt; endl;
}
</code></pre>

<p>Simple and works perfectly ;)</p>
",0
683085,683059,11,"<p>No, there is no easy way to determine if a pointer is bad.</p>

<p>Windows does have IsBadReadPtr, IsBadWritePtr.  These functions are inherently flawed - they only determine if a function is readable or writable in your address space at the moment of the call.  They can also be the cause of <a href=""http://blogs.msdn.com/LarryOsterman/archive/2004/05/18/134471.aspx"" rel=""nofollow noreferrer"">security</a> <a href=""http://blogs.msdn.com/oldnewthing/archive/2006/09/27/773741.aspx"" rel=""nofollow noreferrer"">issues</a> and should never be used.</p>

<p>The main issue is that there is no way to differentiate between a ""bad"" pointer that is still accessible to your process, and a good pointer.</p>

<p>For instance,</p>

<pre><code>int g[5];
int somethingElse;

void* GetPointer()
{
   return &amp;g[5]; // Whoops, off by one.
}
</code></pre>

<p>&amp;g[5] is probably a valid pointer in your process, and might be pointing to somethingElse, you'll be able to access it without crashing but writing to it will corrupt your state.</p>
",1
683111,683059,8,"<p>Your real problem is that you're calling a function that returns bad pointers.  Do you have access to its source code? 90% of the time I've encountered problems like this, it's because either:</p>

<p>1) The function is returning a pointer to the stack; e.g.,</p>

<pre><code>char a[10];
...
return a;
</code></pre>

<p>2)  The function is returning a pointer that was never assigned valid memory to begin with:</p>

<pre><code>char* foo; // Invalid pointer
 ...
return foo;
</code></pre>

<p>3)  The function is returning a pointer that was already deleted (or free'd):</p>

<pre><code>char* foo = new char[10];
...
delete[] foo;
return foo;
</code></pre>

<p>You really need to find the real problem, rather than work around it.</p>
",0
683119,683059,1,"<p><code>LPVOID</code> is a <code>typedef</code> to a pointer to <code>void</code>, Visual studio typically displays <code>NULL</code> values as ""bad pointer"" in the watch pane, are you sure that this pointer is not <code>NULL</code>?</p>
",1
120129,120033,0,"<p>Array members are not initialized by default.  So you could use a static helper function that does the initialization, and store the result of the helper function in a member.</p>

<pre><code>#include ""stdafx.h""
#include &lt;algorithm&gt;
#include &lt;cassert&gt;

class C {
public: // for the sake of demonstration...
  typedef int t_is[4] ;
  t_is is;
  bool initialized;

  C() : initialized( false )
  {
  }

  C( int deflt )
    : initialized( sf_bInit( is, deflt ) )
  {}

  static bool sf_bInit( t_is&amp; av_is, const int i ){
    std::fill( av_is, av_is + sizeof( av_is )/sizeof( av_is[0] ), i );
    return true;
  }
};

int _tmain(int argc, _TCHAR* argv[])
{

  C c(1), d;

  assert( c.is[0] == 1 );

  return 0;
}
</code></pre>

<p>Worth noting is that in the next standard, they're going to support array initializers.</p>
",1
120084,120033,4,"<p>One possible workaround is to avoid the compiler calling the OtherClass constructor at all, and to call it on your own using placement new to initialize it whichever way you need. Example:</p>

<pre><code>  class Foo
  {
  private:
    char inst[3*sizeof(OtherClass)]; // Array size fixed. OtherClass has no default ctor.

    // use Inst to access, not inst
    OtherClass &amp;Inst(int i) {return (OtherClass *)inst+i;}
    const OtherClass &amp;Inst(int i) const {return (const OtherClass *)inst+i;}
  public:
    Foo(...)
    {
      new (Inst(0)) OtherClass(...);
      new (Inst(1)) OtherClass(...);
      new (Inst(2)) OtherClass(...);
    }
    ~Foo()
    {
      Inst(0)-&gt;~OtherClass();
      Inst(1)-&gt;~OtherClass();
      Inst(2)-&gt;~OtherClass();
    }
  };
</code></pre>

<p>To cater for possible alignment requirements of the OtherClass, you may need to use __declspec(align(x)) if working in VisualC++, or to use a type other than char like:</p>

<pre><code>Type inst[3*(sizeof(OtherClass)+sizeof(Type)-1)/sizeof(Type)];
</code></pre>

<p>... where Type is int, double, long long, or whatever describes the alignment requirements.</p>
",5
120089,120033,2,"<p>What data members are in OtherClass?  Will value-initialization be enough for that class?</p>

<p>If value-initialization is enough, then you can value-initialize an array in the member initialization list:</p>

<pre><code>class A {
public:
  A ()
  : m_a()  // All elements are value-initialized (which for int means zero'd)
  {
  }

private:
  int m_a[3];
};
</code></pre>

<p>If your array element types are class types, then the default constructor will be called.</p>

<p><strong>EDIT:</strong> Just to clarify the comment from Drealmer.</p>

<p>Where the element type is non-POD, then it should have an ""accessible default constructor"" (as was stated above).  If the compiler cannot call the default constructor, then this solution will not work.</p>

<p>The following example, would not work with this approach:</p>

<pre><code>class Elem {
public:
   Elem (int);  // User declared ctor stops generation of implicit default ctor
};

class A {
public:
  A ()
  : m_a ()         // Compile error: No default constructor
  {}

private:
  Elem m_a[10];
};
</code></pre>
",8
686574,120033,0,"<p>Use inheritance for creating proxy object</p>

<pre><code>class ProxyOtherClass : public OtherClass {
public:   
  ProxyOtherClass() : OtherClass(0) {}
};

class Foo {
private:
  ProxyOtherClass inst[3]; // Array size fixed and known ahead of time.
public:
  Foo(...) {}
};
</code></pre>
",1
415226,415199,3,"<p>Well, that depends on Object.  But the Objects <em>are</em> being copied, when you pass them to push_back.  You can check this by adding some debug code to the copy constructor.  So if Object is well-behaved and keeps distinct copies separate, then foo1 can change the vector it gets all it likes.</p>

<p>A more efficient way to do this would be to have foo1 accept a start and end iterators:</p>

<pre><code>void foo1(std::vector&lt;Object&gt;::const_iterator start,
          std::vector&lt;Object&gt;::const_iterator end);

...
foo1(objectVec.begin(), objectVec.end() - 5);
</code></pre>

<p>If you don't use const_cast, then the type system will ensure that foo1 does not change any elements, as these are const_iterators.</p>
",0
415230,415199,1,"<p>Your <code>tempObjectVec</code> can't be a vector of references, so I presume it should be declared as something like:</p>

<pre><code>std::vector&lt;Object&gt; tempObjectVec;
</code></pre>

<p>When you execute the <code>tempObjectVec.push_back(a)</code>, a copy of the object will be made to push it into the <code>tempObjectVec</code> vector. Since this is making a copy, you shouldn't even need to use the <code>const_cast</code> to remove the constness, I'm not clear on why you needed to do that.</p>
",0
415254,415199,1,"<p>I believe this is the statement your looking for:</p>

<p><code>const_cast&lt;std::vector&lt;Object&gt;&amp;&gt; (objectVec)</code> this will return a reference to a non-const <code>std::vector</code> which should be palatable to foo1 (I'm assuming).</p>

<p>Modifying your original example:</p>

<pre><code>foo(const std::vector&lt;Object&gt; &amp; objectVec) {

    ...
    foo1(const_cast&lt;std::vector&lt;Object&gt; &amp;&gt;(objectVec));
}
</code></pre>

<p>However I do recommend looking at the actual requirements of <code>foo1</code> that require it to use a non-const vector as you seem to be indicating that all your interested in is modifying the <code>Object</code> instances themselves.</p>
",0
417230,415199,1,"<p>As other ones already say, your vector's push_back takes the reference, but then it copies the object it references. So, at the end you end up with a copy of <code>objectVec[i]</code> within your <code>tempObjectVec</code>. </p>

<p>A vector can't store references, because they can't be assigned (assignments to it affect not the reference itself, but the object referenced instead), which is a requirement for objects to be held in a vector. References are also no objects. They don't have an own size. They therefor can't be pushed into an array or any vector. Usually you want to store pointers or smart pointers in such a container to reference some other object. Look into the <a href=""http://www.boost.org/doc/libs/1_35_0/libs/ptr_container/doc/ptr_container.html"" rel=""nofollow noreferrer""><code>boost pointer container</code></a> library which looks like exactly what you want. </p>
",0
1304071,1304040,5,"<p>The problem is in where the arrays are declared.</p>

<p>You can's declare an array with non-constant size at file level since the compiler needs to know at compile time how much to allocate and in your case this would require a function call.</p>

<p>When you do the same at function level the C++ extension your compiler supports kicks in (this is not allowed by the standart) ¨C the compiler emits code that will call the function, compute the value and allocate the array on stack in runtime.</p>
",2
496327,496305,3,"<p>This basically does this:</p>

<pre><code>Widget wag = *(new Widget());

// or
Widget wag;
</code></pre>

<p>I don't know if this will properly free it or not.  My guess it wouldn't.</p>

<p>To answer your question, I feel its poor design choice.  Probably they wanted to start using pointers, but then just got ugly.</p>
",0
496341,496305,4,"<p>Maybe they're trying for memory leaks? With the default implementation of new that will allocate a Widget on the heap, then copy construct wag from it, then it will promptly leak the new object.</p>

<p>Bottom line: don't imitate. And I would regard that SDK with suspicion.</p>

<p><strong>Edit:</strong> If this is done in the context of a smart pointer, then it's certainly possible they're saving the pointer for later deletion. If there's an XPtr template that's doing that, you should be able to look at the code and see if that's what it's doing. The SDK should also provide you some kind of documentation somewhere about that construct, since it isn't normal, and I don't really see much advantage to it. Still, I stand by what I said: even though it's not a guaranteed leak, I still wouldn't imitate it.</p>
",0
496347,496305,4,"<p>It constructs a new object and then makes a <em>copy</em> of it. The pointer to the original object is discarded, so there may be a memory leak.</p>

<p>There isn't <em>necessarily</em> a memory leak, though. It could be that <code>Widget</code> maintains a list of all its instances, and it updates that list in its constructor and destructor. There might be some other way of attaining the contents of the list.</p>

<p>But it seems rather pointless. The reason was probably due to a misunderstanding of how the code really works. Your best bet for finding out why the code was made that way is to ask the ones who wrote it. There might be clues in the code's comments. Can you reveal more specifics about what code you're looking at?</p>
",1
496574,496305,1,"<p>It's not necessarily leaking. For example consider the following</p>

<pre><code>int &amp;a = *new int();
delete &amp;a;
</code></pre>

<p>It's assigning to a reference. It will preserve the identity of the object created (not creating a copy), so it will not lose track of it, and will delete it fine afterwards. Putting it into the form of your code, that class could be defined as </p>

<pre><code>template&lt;typename T&gt;
struct XPtr {
    T *ptr;
    XPtr(T &amp;t):ptr(&amp;t) { }
    ~XPtr() { delete ptr; }
};

...
XPtr&lt;T&gt; p = *new T;
</code></pre>

<p>Or even more complex, with reference counting - so that p can be copied, and XPtr keeps track of all its copies, and so on.</p>
",1
496586,496305,2,"<p>A commom smart pointer pattern for ref-counted objects is that the following code will store the object and IncRef it:</p>

<pre><code>SmartPtr&lt;Type&gt; ptr = new Type();
</code></pre>

<p>And the following code will store the object and <em>not</em> IncRef it:</p>

<pre><code>SmartPtr&lt;Type&gt; ptr = *new Type();
</code></pre>

<p>The second form is useful if the object's constructor applies the first IncRef.  Otherwise, your object would have a ref count of 2 and when the smart pointer went out of scope, it still wouldn't free the object.</p>

<p>No idea if this is the case in the library you're using.  A quick perusal of the XPtr code would probably tell you, though.</p>
",0
594587,594582,4,"<p>Yes, you might want to process or transform an input text file. It'll prove handy.</p>
",1
594590,594582,9,"<p>Yes, as long as console applications exist, cout and cin will exist. </p>
",0
594591,594582,2,"<blockquote>
  <p>Do people acutally still use these. I mean I've not seen one in an actual public application ever. </p>
</blockquote>

<p>Define public application. What do you think the command line tools on any *nix use? And yes, we too use them, for our SDKs (at least cout and cerr). <code>cin</code> is often not the best when you have complex enough input -- you are left to write a lexer and a parser of sorts.</p>
",0
594592,594582,1,"<p>It would be more acceptable, from a language standpoint, if the answer to ""when will this program end"" was ""when EOF is received"". Just because ""Control-Z"" is EOF in DOS, does not mean Ctrl-Z is the right answer.</p>

<p><strong>Edit</strong>
Edited with comment info.</p>
",7
594594,594582,6,"<p>So you want to say that you are a programmer and never used or wrote console application?</p>
",3
594596,594582,22,"<p>Terminals are widely used, and will be used. The reason is that, when used skillfully, they're far more powerful than any GUIs.</p>
",3
594601,594582,12,"<p>No, such questions are not very relevant, but yes, people use std::cin and std::cout all the time. Even the ones who design graphical interfaces may use cout for debugging !</p>
",2
594611,594582,6,"<p>Of course it's relevant.</p>

<p>Many automation and admin scripts on a variety of servers rely on text output/input, for example. This is especially true on *nix systems, not as much on windows now that Powershell has come about with its fancy object support.</p>

<p>Then there are the ones of us (a dying breed, I admit) that pretty much LIVE in the terminal. I use the terminal for about 70-80% of my work. I just find it more natural, faster and more powerful than most related GUI apps.</p>
",0
594615,594582,2,"<p>If you only ever write GUI or Web applications in your career you probably won't have much use for cin and cout.  If you ever write anything embedded you'll change your position.  You just use a different set of libraries for console apps, text-based apps, GUI apps, and Web apps.</p>
",0
594648,594582,2,"<p>I'd rather use wcin and wcout, at least you get the Unicode stuff.</p>
",2
595351,594582,2,"<p>I've worked on many professional applications and we've not used cin or cout on any of them, even for logging/debugging.  Why?  Because the stateless *printf methods work perfectly well.  One thing I've learned over the years is that stateless trumps statefull for maintainability.</p>
",1
639589,639496,3,"<p>you can write a set of template functions which will help you through with this, for example:</p>

<pre><code>template &lt;typename T&gt;
bool InSet(const T &amp; item, const T &amp; i1, const T &amp; i2) {
  return item==i1 || item==i2;
}

template &lt;typename T&gt;
bool InSet(const T &amp; item, const T &amp; i1, const T &amp; i2, const T &amp; i3) {
  return item==i1 || item==i2 || item==i3;
}
</code></pre>

<p>Note that you can make InSet to work like it took a variable number of arguments by creating multiple templates with different number of arguments.</p>

<p>And then:</p>

<pre><code>int i;
if (InSet(i, 3, 4, 5)) { ... }
string s;
if (InSet(s, ""foobar"", ""zap"", ""garblex"")) { ... }
</code></pre>

<p>etc.</p>
",3
639596,639496,1,"<p>You don't <strong>need</strong> a <em>std::set</em> or a <em>std::vector</em>.  Just use <strong>std::set_intersection()</strong>...</p>

<p>Code is best...</p>

<pre><code>#include &lt;set&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
using namespace std;

#define COUNT(TYPE,ARRAY)  ( sizeof(ARRAY) / sizeof(TYPE) )

inline bool CaseInsensitiveCompare (const char * a, const char * b)
  {  return strcasecmp( a, b ) &lt; 0;  }

int  main()
{
  const char * setA[] = { ""the"", ""world"", ""is"", ""flat"" };
  const char * setB[] = { ""the"", ""empty"", ""set"", ""is"", ""boring"" };

  stable_sort( setA,  setA + COUNT( const char *, setA ),
               CaseInsensitiveCompare );

  stable_sort( setB,  setB + COUNT( const char *, setB ),
               CaseInsensitiveCompare );

  cout &lt;&lt; ""Intersection of sets:  "";
  set_intersection( setA, setA + COUNT( const char *, setA ),
                    setB, setB + COUNT( const char *, setB ),
                    ostream_iterator&lt;const char *&gt;(cout, "" ""),
                    CaseInsensitiveCompare );
  cout &lt;&lt; endl &lt;&lt; endl;
}
</code></pre>

<hr>

<p>Or perhaps, given your 1-N lookup problem:
<br>(Note: Use <em>binary_search()</em> <strong>AFTER</strong> sorting!)</p>

<pre><code>if ( binary_search( setA, setA + COUNT( const char *, setA ),
            ""is"", CaseInsensitiveCompare ) )
  ...

if ( binary_search( setA, setA + COUNT( const char *, setA ),
            ""set"", CaseInsensitiveCompare ) )
  ...
</code></pre>
",3
639510,639496,0,"<p><code>std::find_first_of</code>.</p>

<p>Of course, if you only care about finding a single value, you can create your own wrapper around <code>std::find</code>.</p>
",3
639516,639496,0,"<p>I would recommend your method 2, using a std::vector or other container and looking for membership. Since the order of elements that you're checking against is probably not relevant, you may want to use a std::set or std::map. If you have very many items in your set of values, then using a set or a map will be a faster, while if you have only a few a vector may be faster.</p>

<p>The advantage of any of these approaches is that you can then store the set/map somewhere common, and avoid having to build the set of matching responses every time.</p>
",0
639630,639496,0,"<p>It depends on the source of the retrieved values, if you're reading in from a file or stream then you'd do something different but if your source is a series of functions then the following is a different way to do it, not perfect but may suit your needs:</p>

<pre><code>const int count = 3;
std::string value = ""world"";
boost::function&lt;std::string(void)&gt; funcArray[count];
funcArray[0] = &amp;getValue1;
funcArray[1] = &amp;getValue2;
funcArray[2] = &amp;getValue3;

for( int i = 0; i &lt; count; ++i )
{
    if( funcArray[i]() == value )
        return 1;
}
</code></pre>

<p>If you know which functions are the source (as well as the count of objects) I expect you could assemble the function pointer array using the preprocessor.</p>
",2
639524,639496,0,"<p>i like the collections approach, maybe use a hash_set instead of a vector. store the values in a property file and have a method to populat the hash_set from the file, and another one to return a boolean if the value is in the hash_set. then you can get down to one 2 lines in the main code.</p>
",0
639525,639496,7,"<p>If the values you're looking for are Comparable with operator&lt; (like ints, float and std::strings), then it's faster to use an std::set to put the values there and then check set.find(value) == set.end(). This is because the set will store the values with a certain order that allows for faster lookups. Using an hash table will be even faster. However, for less than 50 values or so you might not notice any difference :) So my rule of thumb would be:</p>

<ul>
<li><p>Less then 5 items: if with multiple ||</p></li>
<li><p>5 or more: put in a set or hash table</p></li>
</ul>
",2
639662,639496,1,"<p>For your request to do </p>

<pre><code>if (InSet(value)(GetValue1(), GetValue2(), GetValue3()))
{
   // Do something here...
}
</code></pre>

<p>Try this:</p>

<pre><code>template &lt;typename T&gt;
class InSetHelper
{
     const T &amp;Value;
     void operator=(const InSetHelper &amp;);
public:
     InSetHelper(const T &amp;value) : Value(value) {}

     template&lt;class Other, class Another&gt;
     bool operator()(const Other &amp;value1, const Another &amp;value2) const
     {
         return Value == value1 || Value == value2;
     }
     template&lt;class Other, class Another, class AThird&gt;
     bool operator()(const Other &amp;value1, const Another &amp;value2, const AThird &amp;value3) const
     {
         return Value == value1 || Value == value2 || Value == value3;
     }
};

template &lt;typename T&gt; 
InSetHelper&lt;T&gt; InSet(const T &amp;value) { return InSetHelper&lt;T&gt;(value); }
</code></pre>

<p>This syntax might be more clear though:</p>

<pre><code>if (MakeSet(GetValue1(), GetValue2(), GetValue3()).Contains(value))
{
   // Do something here...
}

template &lt;typename T, typename U, typename V&gt;
class Set3
{
    const T&amp; V1;
    const U&amp; V2;
    const V&amp; V3;
    void operator=(const Set3 &amp;);
public:
    Set3(const T &amp;v1, const U &amp;v2, const V &amp;v3) : V1(v1), V2(v2), V3(v3) {}

    template &lt;typename W&gt;
    bool Contains(const W &amp;v) const
    {
        return V1 == v || V2 == v || V3 == v;
    }
};

template &lt;typename T, typename U&gt;
class Set2 
{ 
     // as above 
};

template &lt;typename T, typename U, typename V&gt;
Set3&lt;T, U, V&gt; MakeSet(const T &amp;v1, const U &amp;v2, const V &amp;v3)
{
    return Set3&lt;T, U, V&gt;(v1, v2, v3);
}

template &lt;typename T, typename U&gt;
Set3&lt;T, U&gt; MakeSet(const T &amp;v1, const U &amp;v23)
{
    return Set3&lt;T, U, V&gt;(v1, v2);
}
</code></pre>

<p>If those values are really part of a tree or a linked list, then you have your set/container already, and your best bet is to just use some recursion:</p>

<pre><code>parent.ThisOrDescendantHasValue(value);
</code></pre>

<p>You'd just add this to whatever class parent and child belong to:</p>

<pre><code>class Node
{
public: 
    Value GetValue();
    Node *GetChild();
    bool ThisOrDescendantHasValue(const Value &amp;value)
    {
        return GetValue() == value
           || (GetChild() &amp;&amp; GetChild-&gt;ThisOrDescendantHasValue(value));
    }
};
</code></pre>
",3
639684,639496,1,"<p>Which changes more, the 'value' or the values returned by 'getValueX()'?  You can insert everything into a hash_map/map and then do a search that way, as you've suggested with the containers. </p>
",0
639706,639496,0,"<p>How about using a boost::array (or std::tr1::array) and creating a simple function like this:</p>

<pre><code>template &lt;typename ValueType, size_t arraySize&gt;
bool contains(const boost::array&lt;ValueType, arraySize&gt;&amp; arr, const ValueType&amp; val)
{
    return std::find(arr.begin(), arr.end(), val)!=arr.end();
}
</code></pre>

<p>You could then reuse that pretty easily:</p>

<pre><code>#include &lt;string&gt;
#include &lt;iostream&gt;

#include &lt;boost\array.hpp&gt;

template &lt;typename ValueType, size_t arraySize&gt;
bool contains(const boost::array&lt;ValueType, arraySize&gt;&amp; arr, const ValueType&amp; val)
{
    return std::find(arr.begin(), arr.end(), val)!=arr.end();
}

int _tmain(int argc, _TCHAR* argv[])
{
    boost::array&lt;std::string, 3&gt; arr = {""HI"", ""there"", ""world""};

    std::cout &lt;&lt; std::boolalpha 
        &lt;&lt; ""arr contains HI: "" &lt;&lt; contains(arr, std::string(""HI"")) &lt;&lt; std::endl
        &lt;&lt; ""arr contains blag: "" &lt;&lt; contains(arr, std::string(""blag"") ) &lt;&lt; std::endl
        &lt;&lt; ""arr contains there: "" &lt;&lt; contains(arr, std::string(""there"") ) &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p><strong>Edit:</strong> So boost is out. It's pretty easy to adapt this to a regular array:</p>

<pre><code>template &lt;typename ValueType, size_t arraySize&gt;
bool contains(ValueType (&amp;arr)[arraySize], const ValueType&amp; val)
{
    return std::find(&amp;arr[0], &amp;arr[arraySize], val)!=&amp;arr[arraySize];
}

int _tmain(int argc, _TCHAR* argv[])
{
    std::string arr[3] = {""HI"", ""there"", ""world""};

    std::cout &lt;&lt; std::boolalpha &lt;&lt; ""arr contains HI: "" &lt;&lt; contains(arr, std::string(""HI"")) &lt;&lt; std::endl
        &lt;&lt; ""arr contains blag: "" &lt;&lt; contains(arr, std::string(""blag"") ) &lt;&lt; std::endl
        &lt;&lt; ""arr contains there: "" &lt;&lt; contains(arr, std::string(""there"") ) &lt;&lt; std::endl;

    return 0;
}
</code></pre>
",3
833267,833258,0,"<p>No, you must store a <strong>pointer</strong> to the base class to get the polymorphical behavior. The way you do now will lead to <a href=""http://en.wikipedia.org/wiki/Object_slicing"" rel=""nofollow noreferrer"">slicing</a>.</p>
",0
833270,833258,15,"<p>Polymorphism doesn't work in that case because the std::map stores the Base as a value type, so the <a href=""http://en.wikipedia.org/wiki/Object_slicing"" rel=""noreferrer"">objects get sliced</a>.</p>

<p>If you want to have polymorphism on stored objects, you need to store pointers or use one of the <a href=""http://www.boost.org/doc/libs/1_38_0/libs/ptr_container/doc/tutorial.html"" rel=""noreferrer"">boost ptr containers</a> to effect the same. This means you need to remember to delete the memory afterwards (please don't put pointers to stack objects into the map)</p>
",0
833273,833258,3,"<p>Its case of <a href=""http://en.wikipedia.org/wiki/Object_slicing"" rel=""nofollow noreferrer"">Object Slicing</a>. Try to insert with pointers. </p>

<p>In the presence of inheritance copying leads to slicing. That is, if you create a map of base class objects and you try to insert derived class objects into it, the derivedness of the objects will be removed as the objects are copied (via the base class copy constructor) into the map.</p>

<p>Hence, it is recommended to use pointers rather than copies itself.</p>
",0
833282,833258,1,"<p>First idea is that to get polymorphism you need to call member method on pointer or reference. I would store pointer to base class in the map (the element that you store gets copied) and then call via pointer like this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;map&gt;

class Base
{
    public:
    virtual void Foo() { std::cout &lt;&lt; ""1""; }
};

class Child : public Base
{
    public:
    void Foo() { std::cout &lt;&lt; ""2""; }
};

int main (int argc, char * const argv[])
{
    std::map&lt;std::string, Base*&gt; Storage;
    Storage[""rawr""] = new Child();
    Storage[""rawr""]-&gt;Foo();
    return 0;
}
</code></pre>

<p>You get result ""2"".</p>

<p>Note: You have to take care of the allocated memory now.</p>
",0
833284,833258,1,"<p>Dynamic polymorphism works only with references and pointers. In case of using containers, which copy objects around inside them -- only with pointers.</p>

<p>If you would force a cast from super type to base type without using pointer or reference, the object memory would be <strong>sliced</strong>. Check this out: <a href=""http://en.wikipedia.org/wiki/Object_slicing"" rel=""nofollow noreferrer"">Object slicing wikipedia article</a></p>
",0
502349,502345,1,"<p>I had never ever overloaded this one in production code. Although you might want do this if you log a lot, it'll be useful.</p>
",0
502357,502345,4,"<p>I would only overload operator&lt;&lt; when that has anything to do with streaming, or with shifting and the class is purely numeral. For writing something into an ostream, as in your code, i think it's fine. Anything else, i think, will cause confusion and i would better use member functions for those other purposes. One other application, which i think i would still do as an exception to the rule, is doing something like this:</p>

<pre><code>StringList list;
list &lt;&lt; ""foo"" &lt;&lt; ""bar"" &lt;&lt; ""baz"";
</code></pre>

<p>It is how Qt does it with its string list, and which i find quite nice. </p>
",0
502594,502345,3,"<p>A benefit of Martin's answer above is that you also get polymorphism for free.  If you make <code>print(ostream&amp;)</code> a <strong>virtual</strong> function, then the &lt;&lt; operator acts like a virtual function as well!</p>

<p>As to when to overload the operator, do so anytime you think the class should be able to be written to a stream (file, socket, etc...).  This might even be only for debug purposes.  It is often useful to be able to output the internals of a class, so there is no real downside to overloading this operator.</p>
",0
502522,502345,8,"<p>IF I want to stream a class I normally write this:</p>

<pre><code>std::ostream&amp; operator &lt;&lt; (std::ostream&amp; o, const SomeClass&amp; a)
{
    a.print(o);
    return o; 
}
</code></pre>

<p>Then make print a const method on SomeClass that knows how to serialize the class to a stream.</p>
",3
503018,502345,0,"<p>I implement this if, and only if, I intend to make use of that operator. This is pretty much never... my reasons for not implementing it are therefore not using it. If its for public use then include it for completeness, but certainly I wouldn't include this in every class in a project of your own, since for the most part you will not need to output a class to a stream. e.g. If you wrap your entry point in a class, providing this operator will be pointless.</p>
",0
503075,502345,2,"<p>I would consider using it for something like logging. So you can do:</p>

<pre><code>SystemLog systemLog;
systemLog &lt;&lt; ""Processing Item #15"";
systemLog &lt;&lt; ""Error 0014: Bad things happened."";
systemLog &lt;&lt; system.executeCommand(cmd); // returns a result string
</code></pre>

<p>Or maybe for networking as in:</p>

<pre><code>NetworkInterface networkInterface;
string message(""Hello World! I'm a server."");
networkInterface &lt;&lt; message;
</code></pre>

<p>Of course implementing these things as regular function is also possible and might just be preferable. Generally, you should beware of operator overloading. Only use it when it really fits.</p>
",0
504677,502345,0,"<p>I do it very frequently since it makes dumping the object to a log for debugging really convenient.</p>
",0
1608978,1608953,3,"<p>Sounds like the string in the file isn't null-terminated, and intellisense is assuming that it is.  Or perhaps when you wrote the length of the string (30) into the file, you didn't include the null character in that count.  Try adding:</p>

<pre><code>fname[fname_length] = '\0';
</code></pre>

<p>after the file.read().  Oh yeah, you'll need to allocate an extra character too:</p>

<pre><code>char * fname = new char[fname_length + 1];
</code></pre>
",4
1608997,1608953,1,"<p>I guess that intellisense is trying to interpret <code>char*</code> as C string and is looking for a <code>'\0'</code> byte.</p>
",0
1609018,1608953,1,"<p><code>fname</code> is a <code>char*</code> so both the debugger display and <code>m_material_file = fname</code> will be expecting it to be terminated with a '\0'.  You're never explicitly doing that, but it just happens that whatever data follows that memory buffer has a zero byte at some point, so instead of crashing (which is a likely scenario at some point), you get a string that's longer than you expect.</p>
",0
1609059,1608953,1,"<p>Use</p>

<pre><code>m_material_file.assign(fname, fname + fname_length);
</code></pre>

<p>which removes the need for the zero terminator. Also, prefer <code>std::vector</code> to raw arrays.</p>
",2
1609174,1608953,1,"<p><code>std::string::operator=(char const*)</code> is expecting a sequence of bytes terminated by a <code>'\0'</code>.  You can solve this with any of the following:</p>

<ol>
<li>extend <code>fname</code> by a character and add the <code>'\0'</code> explicitly as others have suggested <em>or</em></li>
<li>use <code>m_material_file.assign(&amp;fname[0], &amp;fname[fname_length]);</code> instead <em>or</em></li>
<li>use repeated calls to <code>file.get(ch)</code> and <code>m_material_file.push_back(ch)</code></li>
</ol>

<p>Personally, I would use the last option since it eliminates the explicitly allocated buffer altogether.  One fewer explicit <code>new</code> is one fewer chance of leaking memory.  The following snippet should do the job:</p>

<pre><code>std::string read_name(std::istream&amp; is) {
    unsigned int name_length;
    std::string file_name;
    if (is.read((char*)&amp;name_length, sizeof(name_length))) {
        for (unsigned int i=0; i&lt;name_length; ++i) {
            char ch;
            if (is.get(ch)) {
                file_name.push_back(ch);
            } else {
                break;
            }
        }
    }
    return file_name;
}
</code></pre>

<h2>Note:</h2>

<p>You probably don't want to use <code>sizeof(unsigned int)</code> to determine how many bytes to write to a binary file.  The number of bytes read/written is dependent on the compiler and platform.  If you have a maximum length, then use it to determine the specific byte size to write out.  If the length is guaranteed to fewer than 255 bytes, then only write a single byte for the length.  Then your code will not depend on the byte size of intrinsic types.</p>
",0
1904362,1904340,0,"<p>You might be able to grep something in the artifacts of compilation such as listing files or object files.</p>
",0
1904363,1904340,6,"<p>A better method is to have your compiler print a map file.  Most map files list all the global variables and their locations.  If you're lucky, the map file may even indicate which translation unit the global variable belongs to.</p>
",0
1904430,1904340,0,"<p>Have you considered using something like <a href=""http://www.calvin-studio.fr/docs/Cplusplus/susv3/utilities/cflow.html"" rel=""nofollow noreferrer"">cflow</a>? You can get the GNU's version of cflow, the output, can then be greppable?</p>

<p>Hope this helps.</p>
",0
1904348,1904340,4,"<p>Grep has no knowledge of the syntax or the grammar; it operates on lines. I don't think this is possible.</p>

<p>Here's a snippet of some code I'm working on:</p>

<pre><code>int count;
</code></pre>

<p>Can you tell me if it's global?</p>
",0
744795,744768,1,"<p>I've worked for long periods of time in three C++ shops.  In all cases, they were real C++ shops, using C++ as it was intended to be used, and staying fairly up-to-date, given the times I worked at them.</p>
",0
744914,744768,2,"<p>The places I've worked at weren't necessarily using C soley.  They weren't cranking out new programs one after another...they were usually building something big and maintaining it.  In my experience it becomes harder to keep implementing new an exciting features of a language into an older piece of software that keeps growing and the main job is to maintain/update it.  </p>

<p>I think asking in the interview about those cool new features would help a lot...you should at least be able to weed out the obvious ones.  Another thing would be to ask if you could talk to some of the people that actually write the code.  Most interviews are with manager types...and they aren't always the people involved with using the latest features of a language.</p>
",0
744918,744768,3,"<p>If you read between the lines, you'll probably find a heck of a lot of information buried in their questions, both in terms of what they want you for and their level of sophistication.</p>

<p>You may also want to return their questions not only with answers, but with harder questions requiring clarification on ambiguities in their questions.</p>

<p>Just don't come off as an arrogant jerk when you do it.  ;-)</p>
",0
744922,744768,9,"<p>It's really all across the board. On one end of the spectrum, I've worked in one place where the code was recently rewritten in C. Recently being 10 years ago. Everyone was highly skeptical of this new-fangled technology.</p>

<p>Slightly farther down the spectrum, you'll find C programmers who happen to have compilers with C++ features enabled. They'll dabble in the ""class"" keyword. But other than that, they are practically writing in C.</p>

<p>Next down the line I think you'll find those who just groked inheritance and polymorphism. These are the kind of guys and gals that would swoon over an MFC or wxWidgets program, thinking it was the greatest.</p>

<p>You'll go a little farther and find the folks who just read Meyer. They are all about figuring out how to use STL efficiently. They've got a basic notion of templates that equates mostly to the way STL uses them.</p>

<p>Then you've got the Modern C++ Template Metaprogramming geeks. Many of us these days use their work in the form of boost and all its goodness. Few actually dork around with template metaprogramming. That's probably a good thing.</p>

<p>I have seen perfectly good code written at each level.</p>

<p>The cool thing I always liked about C++ is that at each level of added complexity, the cost could be conceptualized in terms of ""how this new abstraction might be implemented in C"". So I can conceptualize that inheritance and polymorphism is adding the cost of a function pointer lookup. Since I have seen this and written this in C, I know what I'm in for. I also have a sense of how templates work in part because of how the preprocessor works in C. This applies to most features in the C++ and C world.</p>

<p>Since it's easy to map concepts to how they are implemented in C, I can easily visualize how the underlying architecture runs my code.</p>
",3
744941,744768,-2,"<p>Interestingly, I consider the level of advancement pretty much the opposite of your preferences. Therefore this response might not be directly useful, but I hope it's at least somewhat informative.</p>

<hr>

<p>First, any environment that encourages ""cleverness"" is suspect. If I see a lot of Boost, a lot of template metaprogramming, and especially any use of C++'s ""functional"" features, it's a big red warning sign. It means the developers have some idea of what correct programming is, but are constrained by either lack of imagination or politics to using a decrepit junk language such as C++. C is boring and tedious to work with, but ""advanced"" C++ goes out of its way to interfere with development.</p>

<p>Second, check whether a particular technology or concept is treated as a buzzword. If the prospective employer uses XML, there's an easy check you can do -- do they use a real parser/serializer (either SAX or DOM is fine), or do they parse it with regexes and serialize it with raw character streams? If the latter, it shows they don't understand <em>why</em> XML is useful, and they're just using it to have another three-letter acronym on the project description.</p>

<p>Third, figure out what language the developers <em>wish</em> they were using and why. Every good developer has a favorite obscure language -- it doesn't matter whether it's Python, Ruby, Smalltalk, Haskell, or Factor -- and a reason for preferring it. If everybody is content to work in C++, it's another warning sign that they've not got much curiosity about programming in general.</p>
",4
360372,360338,3,"<p>I find the structure of java projects quite nice. I do it like this (root is the root directory)</p>

<p><em>root/include/foo/bar/baz.hpp</em> becomes</p>

<pre><code>namespace foo { 
namespace bar {
    // declare/define the stuff (classes, functions) here
} } // foo::bar
</code></pre>

<p>in code. </p>

<p>I keep the source in</p>

<p><em>root/src/foo/bar/baz.cpp</em> . If i have some stuff that is not exposed to the outside, i put it into a <em>detail/</em> directory and namespace. I keep the makefiles at <em>root/</em>. </p>
",0
360515,360338,1,"<blockquote>
  <p>a) (is it) good practice to do a similar structure in a C++,</p>
</blockquote>

<p>One way to find out would be to download a few open source projects and look at their file structure.</p>

<p>In my experience, the build tool used really ends up dictating the file structure.  If it's a bit of a pain to have lots of subdirectories with your build tool of choice then you won't have lots of subdirectories.</p>

<blockquote>
  <p>b) if so, what is the best way to set it up?</p>
</blockquote>

<p>That depends on your build/dev environment.  I personally use vim and Linux file tools, so I set this all up by hand.  Somebody using Eclipse or Visual Studio probably has a number of wizards to work from.</p>
",1
828216,648998,0,"<p>Stroustrup is not that stupid to say that! It is definitely a hoax!</p>
",1
828231,648998,1,"<p>There is <strong>not a single</strong> framework which uses all language features of C++. This introduces a huge <strong>inconsistency</strong> to the language's <strong>ecosystem</strong>.</p>

<p>QT is one of the few APIs which I would call a framework (or API for a <strong>lot</strong> of things):<br>
But it defines own string, own array, ...</p>

<p>What's the point of a ""standard"" library when no one can use it in a portable and compatible way (from the aspect of <strong>interaction</strong> with other APIs)?</p>

<p>I know, there is <strong>boost</strong>, but what is boost compared to an API such as QT? Nothing.</p>

<p>Look at Java: The is the standard Java API, and every ""foreign"" API uses it, it's all perfectly compatible.</p>
",2
649006,648998,40,"<p>It's a <a href=""http://jimmod.blogspot.com/2007/01/interview-with-bjarne-stroustrup-hoax.html"" rel=""noreferrer"">well-known hoax</a>.</p>

<p>And no, learning C++ isn't a waste of your time, something that's been discussed on StackOverflow many times.</p>
",2
649144,648998,4,"<p>As others mentioned, this Interview is hoax.</p>

<p>Well, I am one of the persons who hate C++ and normally doesnt use it, but learning it was definitely not a waste of time. At least now I know why I hate C++ and I understand why other persons use this language and think it is good.</p>

<p>If you want to learn this language to know about its concepts, its benefits and its drawbacks, to be able to read code written in it, and in general to be able to ""talk about"" it, it is never a waste of time. Same for any other programming language. It will increase your expierience. For example, C++ shows one common way of OOP - a way I dont like, but a way many other people use.</p>

<p>But if you want to learn it because ""the people say that it is the best"" (as I sometimes read), then it is really a waste of time. Same for any other programming language.</p>
",0
649028,648998,0,"<p>C++ (and Java) probably the best language to learn to understand concepts of OOP. 
I remember learning it in college benefited me a lot.</p>
",1
649035,648998,51,"<p>You just have to check the <a href=""http://www.stroustrup.com/bs_faq.html#IEEE"" rel=""noreferrer"">Stroustrup's website (the FAQ part)</a> to find that it's wrong - a well known hoax as Judah Himango already pointed :</p>

<blockquote>
  <p><strong>Did you really give an interview to IEEE?</strong></p>
  
  <p>in which you confessed that C++ was
  deliberately created as an awful
  language for writing unmaintainable
  code to increase programmers'
  salaries? Of course not. <a href=""http://www.stroustrup.com/ieee_interview.html"" rel=""noreferrer"">Read the
  real IEEE interview.</a></p>
</blockquote>
",1
649040,648998,6,"<p>From the article titled ""The Real Stroustrup Interview"" in IEEE Computer Magazine Vol. 31 Issue 6 pp.110-114 (June 1998):</p>

<blockquote>
  <p>For the past few months, a hoax interview between Stroustrup and Computer has been making the rounds in cyberspace. While we regret the incident, it offers us a welcome opportunity to have the father of C++ share his insights on Standard C++ and software development in general. We can also attest to his continued sense of proportion and humor¡ªhe suggests that the ?ctitious interview would have been a much funnier parody had he written it himself.</p>
</blockquote>
",0
649049,648998,27,"<p>As mentioned, this is a well-known hoax.</p>

<p>But it does provoke some interesting points. These days C++ is a waste of time, except for when you can't afford to waste time. Less opaquely: C++ is a waste of <strong>development time</strong>, except for when you can't afford to waste <strong>execution</strong> time.</p>
",3
649051,648998,1,"<p>C++ is far from being a waste of your time. You'll understand valuable concepts that will help you understand many other concepts in different programming languages. I.E.: VTABLE.</p>
",2
475462,474867,0,"<p>You can write the Visual Studio plugin. In which you can access each class, and each methods in it. This uses COM technology and Visual studio extensibility feature.</p>

<p>EDIT: I have never seen the tag cocoa in question. This answer applies only to Visual studio</p>
",0
474880,474867,0,"<p>I dunno if doxygen --> <a href=""http://www.doxygen.nl/"" rel=""nofollow noreferrer"">http://www.doxygen.nl/</a> does it, but I wouldn't be surprised if it also does that.</p>

<p>It generates documentation from the header files + javadoc like comments. </p>

<p>It will find the functions also so that kinda is counting.</p>
",0
474921,474867,8,"<p>Try this:</p>

<pre><code>ctags --c++-kinds=f -x myfile.h
</code></pre>

<p>To list all functions in the file myfile.h . To count the number of functions in <code>deque.tcc</code>:</p>

<pre><code>$ ctags --c++-kinds=f --language-force=c++ -x deque.tcc | wc -l
24
</code></pre>
",2
688506,688494,3,"<p>Several problems:</p>

<p>1) Why are you repeating the variable declaration in the first constructor? </p>

<p>2) Why are you declaring the myAddress as a reference rather than just as a pointer?
A reference always has to be initialized in the constructor initialization list. This is likely the cause of your error message. Initializing in the constructor body is not acceptable to C++.</p>

<p>In the second constructor, you probably want something like:</p>

<pre><code>myClass::myClass( const myClass&amp; classType ):myAddresss(classType.myAddress), myFloater(classType.myFloater)
{
}
</code></pre>

<p>The reason for this has to do with how objects are constructed. At the point where the body of the constructor executes, the object is already considered to have been ""built"" so references should already be valid, so your assignment of a reference is rejected by C++. </p>

<p>And by the way, this is not really a deep copy...</p>
",0
688511,688494,7,"<pre><code>const char* &amp;myAddress;
</code></pre>

<p>is a reference, so it must be initialized in an initializer list during the constructor, i.e.</p>

<pre><code>myClass::myClass(const char *&amp; cPtr, const float fValue): myAddress(cPtr)
</code></pre>

<p>Note that this is a bad way to handle this situation (of course, depending on what you're trying to do), since if the <em>pointer</em> passed goes out of scope, then you're screwed.</p>

<p>A better way to do this (again, depending on what you're trying to do) is just to copy the pointer over, and during your ""deep"" copy, reallocate and copy its contents. Unless you actually need a reference to the pointer, of course.</p>
",0
688515,688494,2,"<p>You are not initializing the members in the constructor, you are declaring two new local variables with the same names as the ones in the class. And initializing them with an initializer list would look like this:</p>

<pre><code>myClass::myClass( const char *cPtr, const float fValue )
    : myAdress(cPtr), myFloater(fValue)
{
}
</code></pre>
",0
688518,688494,3,"<p>in addition to what others said, you are not really doing a 'deep copy' what you are doing is setting the pointer to point the same, that is not a deep copy. You need to duplicate whatever the pointer is pointing to as well (to be on the safe side).</p>
",0
688520,688494,0,"<p>Try having your code like this:</p>

<pre><code>class myClass
{
public:

    myClass ( const char *cPtr, const float fValue );
    myClass ( const myClass&amp; myClassT );

private:

    const char* &amp;myAddress;
    float MyFloater;

};

//myClass.cpp

myClass::myClass( const char *cPtr, const float fValue ) : myAddress(cPtr), MyFloater(fValue)
{
}

myClass::myClass( const myClass&amp; classType ) : myAddress(classType.myAddress), MyFloater(classType.MyFloater)
{
// copy what we did ... 
}
</code></pre>
",0
365111,365104,19,"<p>If you're asking why C++ classes have destructors, some classes have requirements other than just freeing memory. You may have an object that's allocated a socket connection that needs to be shut down cleanly, for example.</p>

<p>Also, 'unscoping' a pointer does <em>not</em> free the memory that it points to since other pointers may be referencing it.</p>

<p>If you have a pointer on the stack, exiting the function will free the memory used by the pointer but <em>not</em> that memory pointed to by the pointer. There's a subtle but very important distinction.</p>
",0
365115,365104,15,"<p>When a pointer goes out of scope, the memory taken by <em>the pointer</em> is released. The 4 or 8 bytes (usually) of memory that are taken by the pointer, that is.</p>

<p>The <em>object</em> (or other memory) that the pointer points to is <em>not</em> released when the pointer goes out of scope. You do that by <em>delete</em>'ing the pointer. And that invokes the destructor, if there is any.</p>
",0
365147,365104,0,"<p>When ever there is a pointer(exist as class member),there should be a destructor for that class that should delete the object pointed by the pointer member.
If you have smart_pointer in place of pointer in class then there is no need of destructor.</p>

<p>below qn will help u understand better.
<a href=""https://stackoverflow.com/questions/147572/will-the-below-code-cause-memory-leak-in-c"">Will the below code cause memory leak in c++</a></p>
",0
365160,365104,9,"<p>First, you mistakenly state that the memory is freed when the pointer goes out of scope. With raw pointers that is false, the memory is lost, and any resource held by the pointed object with it.</p>

<p>Destructors are a core feature of the language, and the base for the <a href=""http://en.wikipedia.org/wiki/Resource_acquisition_is_initialization"" rel=""noreferrer"">RAII</a> idiom for resource management. Objects acquire resources during construction and releases those same resources in the destructor. It is a simple, controllable and simple approach to resource management. Note here that resource is anything from memory (smart pointers destructors free the memory they control, containers free their internal memory structure) or any other resource (ofstreams release open files, database connections free the sockets).</p>

<p>While with managed languages as C# or Java memory is released automatically by the garbage collector, it is only memory that gets realeased, and the user has the strain of controlling all other resources manually in the place of use. </p>

<p>If you check exception control structures in C#/Java you will notice that there is a finally clause non-existent in C++. The reason is that managed languages must provide the user with a block of code that is guaranteed to be executed as to manually free the resources. The strain of releasing resources is placed in the programmer that uses the libraries.</p>

<p>In C++, using the RAII idiom, each object is responsible for the resources it is holding and must release them during destruction. This implies that if you are using objects in the stack resources will be released without user's interaction. The responsibility for controlling resources is in the class, and the user must not remember to free each resource manually.</p>

<p>Many managed language defendants gladly say that not having to remember when or where to release memory as it will be claimed by the garbage collector is a great advantage, but they won't get into the discussion of how other resources are controlled. Memory management is just a subset of the problem of resource management and the same solution applies. If you hold memory inside smart pointers (std::auto_ptr, boost::shared_ptr, std::tr1::unique_ptr, std::tr1::shared_ptr..., choose the one that fits your use) then memory will be managed for you.</p>

<p>While this post seems to have disgressed from the original question of destructors, it is really very closely related. All resource control must be performed in destructors, that is how smart pointers work: when the stack allocated smart pointer goes out of scope the destructor is called and it checks whether the heap (new) allocated memory must be released and if so, <em>delete</em> is called. But then again, this is just a subset of the more general problem.</p>
",0
776504,365104,0,"<p>If you're writing good C++ then you should have very few destructors (in fact I think ""few destructors"" is a good metric for C++ code quality).</p>

<p>A couple of exceptions I can think of are:</p>

<p>a) When you're working with things which don't destruct themselves, eg. ""FILE*"".</p>

<p>b) When you're using the ""pimpl"" idiom (google for ""pimpl idiom"").</p>

<p>nb. Classes like std::auto_ptr and std::vector will fall into category (a) because at some point they need a C-style pointer to memory.</p>
",0
486590,486581,0,"<p>I think this is perfectly fine. The only possible drawback is the limited scope of an object created on the stack, but that's not necessarily related to polymorphism.</p>
",0
486599,486581,0,"<p>There's no problem with using the stack.</p>

<p>When you're using the stack then you often know exactly what type of object it is ... so there's no need for the method to be virtual, it's harmless but unnecessary, for example:</p>

<pre><code>Derived derived;
derived.Foo();
</code></pre>

<p>However, the object (which exists on the stack) can be passed to subroutines which accept a superclass instance as a parameter (in which case the fact that it's a subclass is useful/used):</p>

<pre><code>void foo(Base* base)
{
  ...
}

void test()
{
  Derived derived;
  foo(&amp;derived);
}
</code></pre>
",0
486625,486581,0,"<p>Using the stack will be fine for the simple case you show.  One real time issue with dynamic polymorphism vs static is the added time to to go through the indirection of the method call.  Which is an extra memory access per method call.   </p>

<p>You need to explain more about what your doing to analyze other factors, e.g. is the stack frame guaranteed to be in physical memory, sharing, number of instances, lifespan of instances</p>
",0
486586,486581,7,"<p>A better example would be:</p>

<pre><code>void func(Base &amp;base);

int main()
{
    Derived derived;

    func(derived);

    return 0;
}
</code></pre>

<p>The use of polymorphism doesn't have to be near where the object is created on the stack.</p>

<p>A lot of our unit-testing code these days looks roughly like:</p>

<pre><code>void test()
{
    MockObject mockObj;
    RealObject objectToBeTested(mockObj);

    // Do tests
}
</code></pre>

<p>This depends intimately on polymorphism, but creates objects on the stack.</p>
",0
486762,486581,4,"<p>You don't <em>have</em> to use the heap if you want to use polymorphism, as you pointed out in your question. But you often have no other choice. Small contrived example:</p>

<pre><code>void doSomething(int what) {
    // figure out which implementation to create
    Base * b;
    if(doA) {
        b = new ConcreteA; // 1a
    } else if(doB) {
        b = new ConcreteB; // 1b
    }
    ...
    b-&gt;...; // 2
}
</code></pre>

<p>You can't use the stack, because at the moment you know what to do, 1a and 1b, every storage you get from the stack will be reclaimed when that scope is left again. You have to use the heap because you need some storage that lasts that local scope. </p>

<p>Some libraries advertise with them being able to not use the heap, but still behave polymorphic. They usually do that with placement new:</p>

<pre><code>void doSomething(int what) {
    // allocate form *the stack*, outside the if blocks, so this
    // storage lasts until the function returns
    char buffer[MAX(sizeof (ConcreteA), sizeof(ConcreteB))];
    if(doA) {
        new (buffer) ConcreteA; // 1a
    } else if(doB) {
        new (buffer) ConcreteB; // 1b
    }
    Base *b = static_cast&lt;Base*&gt;(static_cast&lt;void*&gt;(buffer));
    b-&gt;...; // 2
}
</code></pre>

<p>The new calls in 1a and 1b now use the buffer created on the stack as the storage for the created object. So, no heap memory allocation is required anymore. That form of allocation has the main disadvantage that it's currently not possible in C++ to tell whether the buffer is correctly aligned for the types ConcreteA and ConcreteB though. So, it can be that the array is aligned on a 2 byte boundary, but the objects are required to be created on a 4 byte boundary, resulting in undefined behavior when you try to create those objects into that buffer. </p>

<p>Boost.Function is one of those libraries that use such a placement new approach to create objects of polymorphic types without using heap allocation using a small buffer (hence, what it does is called <em>small buffer optimization</em>).</p>
",0
480253,480248,16,"<p>I've used them before to add customization to classes by passing them to the constructor in a way like the strategy pattern</p>
",3
480355,480248,13,"<p>I think your example usage is quite good. Because if you would use an ordinary function pointer, and you then apply the address-of operator, you would get the address of the function pointer. Using a reference to function will do the expected thing, in that it returns a pointer to the function itself. </p>

<p>I also can't think of many examples. Keeping function references, as you point out, has some ugly consequences. Another possibly unwanted consequence is, if kept as a class-member, your objects will be non-assignable if you don't write your own operator= and refrain from trying to re-assign the function-reference. </p>

<p>I think most uses of function references are implicit, much like most uses of array-references - although much more so, when you accept arguments by-reference:</p>

<pre><code>template&lt;typename T&gt;
void do_something(T const&amp; t) { ... }
</code></pre>

<p>While accepting arrays by reference has the advantage of not losing their size information, accepting functions by reference explicitly doesn't seem to have an advantage (at least as far as I can see). I suppose the existence of function references largely is justified by the idealistic view of a reference as an <em>alias</em>-name of some object or function, together with the fact that it allows passing functions to such templates that accept their argument by reference.</p>

<p>I would probably avoid using them if I wouldn't need them inevitably. Constant function pointers also provide non-reassignable callables, and will probably avoid confusions when other programmers, who possibly are not very familiar with this language niches, read your code. Worth to note that Vandervoorde &amp; Josuttis also recommend to avoid them to reduce confusion (in their book C++ Templates - The Complete Guide). </p>
",3
480422,480248,1,"<p>I've used them in a plug-in system where plug-in DLLs could be loaded/unloaded at run-time. I would look for known symbols in each DLL and cast them to function pointers.</p>
",2
849571,849309,2,"<p>It is worth mentioning, that in c++0x you will have another options (besides passing by reference or by pointer):</p>

<ol>
<li>std::move. Streams are not copyable, but you will be able to move them into another place (it depends if streams will implement the move operator, but they probably will).</li>
<li>unique_ptr. Streams are not copyable. When using pointers, a risk of resource leak arises. Using shared_ptr incorporates unnecessary costs when you want to have streams stored in a collection, and nowhere else. Unique_ptr solves this. You will be able to store streams in a collection in safe and efficient way.</li>
</ol>
",0
849322,849309,9,"<p>You must pass stream objects by reference:</p>

<pre><code>Object::Object( ofstream &amp; filein )
{
 filein &lt;&lt; ""Success"";
}
</code></pre>

<p>And why are you using a typedef on the class? It should look like this:</p>

<pre><code>class Object
{
   public:
     Object(ofstream &amp; filein);
};
</code></pre>
",1
392365,392359,6,"<p>See the article <a href=""http://www.codeproject.com/KB/cpp/templatesourceorg.aspx"" rel=""nofollow noreferrer"">How to Organize Template Source Code</a>. I think you are after the second method described there: explicit template instantiation.</p>
",1
1786994,1786986,10,"<p>You need to wrap your key and value in an <code>std::pair</code> object:</p>

<pre><code>sprites.insert(std::make_pair(sprite, texture));
</code></pre>

<p>This is because <code>std::map</code> is a <a href=""http://www.sgi.com/tech/stl/PairAssociativeContainer.html"" rel=""nofollow noreferrer"">Pair Associative Container</a>.  The <code>value_type</code> of <code>std::map&lt;K,V&gt;</code> is <code>std::pair&lt;const K,V&gt;</code>.</p>
",0
1787019,1786986,3,"<p>Alternatively, you could use <code>operator[]</code>. For std::map, this will <a href=""http://www.cplusplus.com/reference/stl/map/operator[]/"" rel=""nofollow noreferrer"">autovivify</a> for you. Depending on what you are doing, it may make calling std::map::insert unnecessary.</p>
",1
728156,713704,0,"<p>If you're four months in and doing fine, stay the course.  However, I wouldn't recommend C++ as a first language in general. </p>

<p>In grad school, I was a teaching assistant for a first year computer course that all engineering students had to take.  The course used C++ as the teaching language and I think now that this was a very poor choice.  About 10-20% of the students 'got it' right away and breezed through the course (as a SO user, you're probably in this catagory), the middle 70-90% worked hard and did OK, and the bottom 10-20% were still having trouble telling the difference between a variable declaration and a function declaration half way through the course.  </p>

<p>Too many students were bogged down in the syntax of C++ as opposed to using computers to solve problems, which is what a general first-year computer course should have really been about.</p>
",0
728217,713704,0,"<p>C++ was the first ""real"" language I started on.  Yeah, it was a tough learning curve at times, but the best part there was that since I didn't know any better - I didn't know any better.  That is, having not been introduced to anything easier, C++ was the easiest language I had ever used.</p>

<p>Personally, I think the benefits have been enormous.  As with others, I managed to become professionally competent in Java in under a week.  I was up to speed in Embedded C in a few days.  Delphi, VB.Net, C# - all were easy transitions, and I attribute that to having C++ as the baseline.</p>

<p>If you made it past the first few days, you're good to go.  By all means, stick with it.</p>
",0
503210,500748,0,"<p>the first thing I thought of when I looked at this question - it`s a simple misprint</p>
",0
909319,909289,3,"<p>There is a problem in your while loop in that if the delimiter is found then <code>temp</code> will point to the first delimiter after the first <code>find</code> call.</p>

<p>At the end of the while loop you set <code>beg</code> to the value of <code>temp</code>.</p>

<p>Now <code>beg</code> also points to the first delimiter.</p>

<p>When <code>find</code> is next called it will return the current value of <code>beg</code> again as it does point to a delimiter.</p>

<p><code>temp</code> hasn't moved on from it's previous value so you are in an infinite loop.</p>
",0
909632,909289,2,"<p>Maybe this one:</p>

<pre><code>std::vector&lt;std::string&gt; &amp;mysplit(const std::string &amp;s, char delim, std::vector&lt;std::string&gt; &amp;elems) {
    std::stringstream ss(s);
    std::string item;
    while(std::getline(ss, item, delim)) {
        elems.push_back(item);
    }
    return elems;
}
</code></pre>
",0
909398,909289,1,"<pre><code>vector&lt;string&gt; split( const string &amp;str, const char &amp;delim )
{
    typedef string::const_iterator iter;

    iter beg = str.begin();

    vector&lt;string&gt; tokens;

    while(beg != str.end())
    {
        iter temp = find(beg, str.end(), delim);
        if(beg != str.end())
            tokens.push_back(string(beg, temp));
        if(temp != str.end())
            temp++;
        beg = temp;
    }

    return tokens;
}
</code></pre>
",2
909401,909289,0,"<p>The simplest way to debug this code, is to print all the positions <code>beg</code> will be. If <code>beg</code> doesn't increase then that's your problem.</p>
",0
909404,909289,0,"<p>Apart from the <code>beg</code> needing to be incremented with the size of the delimiter, one special case is missed: the case where no delimiters are in the string.</p>
",3
909691,909289,5,"<p>I've got to love <a href=""http://www.boost.org/doc/libs/1_39_0/doc/html/string_algo/usage.html#id3408774"" rel=""nofollow noreferrer"">Boost</a>, as it's providing a handy solution to this one as well:</p>

<pre><code>
std::vector&lt;std::string&gt; Split(const std::string &amp;s, const std::string &amp;d)
{
        std::vector&lt;std::string&gt; v;

        for (boost::split_iterator&lt;std::string::iterator&gt; i = boost::make_split_iterator(s, boost::first_finder(d, boost::is_iequal()));
             i != boost::split_iterator&lt;std::string::iterator&gt;();
             ++i) {
                v.push_back(boost::copy_range&lt;std::string&gt;(*i));
        }

        return v;
}
</code></pre>
",0
909311,909289,1,"<p>find() will return the position X of the next token. When you then assign this to beg and go into the next iteration, it will start searching at position X again - and again - and again ... i.e. you are stuck in an endless loop.</p>

<p>Try this code:</p>

<pre><code>vector&lt;string&gt; split( const string &amp;str, const char &amp;delim )
{
    typedef string::const_iterator iter;

    vector&lt;string&gt; tokens;
    iter pos = str.begin(), last = str.begin();

    while(pos != str.end()) {
        last = pos;
        pos = find(pos, str.end(), delim);

        if (pos != str.end()) {
            string token = string(last, pos);
            if (token.length() &gt; 0)
                tokens.push_back(token);

            last = ++pos;
        }
    }

    string lastToken = string(last, pos);
    if (lastToken.length() &gt; 0)
        tokens.push_back(lastToken);

    return tokens;
}
</code></pre>

<p>This has the added benefit that it will include the last token in the list (e.g. when splitting on space, the string ""a b c"" will now return tokens a, b and c instead of only a and b) and that multiple delims will not lead to empty tokens.</p>
",0
909313,909289,5,"<p>I <em>could</em> debug it for you, I guess but that won't help you in the long run. Here's what you do.</p>

<p>After every line, put a printf() or cout staement dumping the changed variables to standard output. Then run your code, passing a simple set of parameters to it:</p>

<pre><code>vector&lt;string&gt; x = split (""Hello there, Bob."", ' ');
</code></pre>

<p>Then, examine the output to see why your implementation isn't working. You'll probably have to break out of the code since, if it's just sitting there, you've probably got yourself one of those new-fangled infinite loops.</p>

<blockquote>
  <p>Give a man a fish and he'll eat for a day, teach a man <em>to</em> fish, he'll never be hungry again.</p>
</blockquote>

<p>Or the Terry Pratchett version:</p>

<blockquote>
  <p>Give a man some fire and he'll be warm for a day, set a man <em>on</em> fire, he'll be warm for the rest of his life.</p>
</blockquote>

<p><strong>Update:</strong></p>

<p>Since you've stated that you've actually done what I suggested, here's what <em>I</em> found out from doing it. It's evident that when you set <code>beg</code> to <code>temp</code> at the end of the <code>while</code> loop, it's pointing at the space. That was discovered by printing the <code>beg</code> string at the top of the <code>while</code> loop - it never changed after the first word was extracted.</p>

<p>Then, when you do the next <code>find</code>, it finds that exact same space rather than first skipping spaces then calling <code>find</code> properly. You need to skip the spaces after each <code>find</code>, making sure you don't iterate beyond the end of the string.</p>

<p>This is my solution. Use it as you wish.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

vector&lt;string&gt; split( const string &amp;str, const char &amp;delim ) {
    typedef string::const_iterator iter;
    iter beg = str.begin();
    vector&lt;string&gt; tokens;

    while(beg != str.end()) {
        //cout &lt;&lt; "":"" &lt;&lt; beg._Myptr &lt;&lt; "":"" &lt;&lt; endl;
        iter temp = find(beg, str.end(), delim);
        if(beg != str.end())
            tokens.push_back(string(beg, temp));
        beg = temp;
        while ((beg != str.end()) &amp;&amp; (*beg == delim))
            beg++;
    }

    return tokens;
}

int main () {
    vector&lt;string&gt; x = split (""Hello, my name is Bob. "", ' ');
    return 0;
}
</code></pre>

<p>Without that space-skipping code at the end of the <code>while</code> loop, the output was:</p>

<pre><code>:Hello, my name is Bob. :
: my name is Bob. :
: my name is Bob. :
: my name is Bob. :
: my name is Bob. :
: my name is Bob. :
: my name is Bob. :
: my name is Bob. :
</code></pre>

<p>and so on, ad infinitum. <em>With</em> the skipping code, you get:</p>

<pre><code>:Hello, my name is Bob. :
:my name is Bob. :
:name is Bob. :
:is Bob. :
:Bob. :
</code></pre>
",2
909767,909289,1,"<p>You don't have to reinvent the wheel, boost provides a <a href=""http://www.boost.org/doc/libs/1_39_0/doc/html/string_algo/usage.html#id3408774"" rel=""nofollow noreferrer"">string splitting</a> function for you.<br>
Example code:</p>

<pre><code>string stringtobesplit = ""AA/BB-CC"")
vector&lt;string&gt; tokens;

boost::split(tokens, stringtobesplit, boost::is_any_of(""/-"")); 
// tokens now holds 3 items: AA BB CC
</code></pre>
",0
924033,909289,6,"<p>Here is another nice and short Boost-based version that uses a whole string as delimiter:</p>

<pre><code>std::vector&lt;std::string&gt; result;
boost::iter_split(result, str, boost::first_finder(delim));
</code></pre>

<p>Or case-insensitive:</p>

<pre><code>std::vector&lt;std::string&gt; result;
boost::iter_split(result, str, 
    boost::first_finder(delim, boost::is_iequal()));
</code></pre>
",1
531928,531916,34,"<p>Ok I fixed it myself. It was a stupid mistake! I have a file called ""String.h"" in a library project which is being picked up by the &lt;cstring&gt; header. Probably because I have added the path to &lt;String.h&gt; as an additional include directory in my test project (where I am getting this error.) Hope this helps someone.</p>
",5
531947,531916,1,"<p>Your compiler may be (correctly) placing the memchr function in the C++ std namespace. Try prefixing memchr call with std:: and if that fails, post the code that causes the problem.</p>
",1
534079,531916,-5,"<p>Preprocessor defines are pretty handy when you want to avoid this sort of mistake.</p>

<pre><code>//whatev.h
#ifndef WHATEV
#define WHATEV

// your code here

#endif
</code></pre>
",1
390590,390385,-1,"<p>The problem is that a double** is a pointer to a pointer.  Your 'f' function wants to be passed the address of a pointer to a double.  If you call f(var), well, where exactly do you think that pointer is?  It doesn't exist.</p>

<p>This will work:</p>

<pre><code>double *tmp = (double *) var;
f (&amp;tmp);
</code></pre>

<p>Also, it would work to change the definition of f:</p>

<pre><code>void f (double a[4][2]) { }
</code></pre>

<p>Now f takes a pointer to the kind of array you have.  That will work.</p>
",3
390417,390385,19,"<p><a href=""https://stackoverflow.com/questions/308279/c-vs#308724"">C++ strings: [] vs. *</a></p>

<p>Look at the <em>Excursion: Multi Dimensional Arrays</em> which describes how you pass multi dimensional arrays to functions as arguments. Basicially you want to change your code into this:</p>

<pre><code>// same as void f(double (*a)[2]) {
void f(double a[][2]) { 

}

int main() {
    // note. this is not a pointer to a pointer, 
    // but an array of arrays (4 arrays of type double[2])
    double var[4][2];

    // trying to pass it by value will pass a pointer to its
    // first element 
    f(var);
}
</code></pre>

<p>All but the last dimensions have to be known to the called function. Otherwise indexing the array, the compiler would not be able to calculate the correct distance to values into your array (a[1] is <code>sizeof(double[2])</code> bytes away from a[0]).</p>

<p>You seem to want to be able to accept the array without knowing the size of the dimensions. You can use templates for this:</p>

<pre><code>template&lt;std::size_t N&gt;
void f(double a[][N]) { 
    // N == 2 for us
}

int main() {
    double var[4][2];
    f(var);
}
</code></pre>

<p>The compiler will make a copy of (instantiate) that template for each value of N used with the function, auto-deducing the right N.</p>
",1
1304186,1304174,13,"<p>Use conditinal compilation and a macro:</p>

<pre><code>#ifdef _DEBUG
   #define LOG( x ) debugPrint( x )
#else
   #define LOG( x )
#endif
</code></pre>

<p>Define <code>_DEBUG</code> for the debug build and not define it for the release build. Now in release build every</p>

<pre><code>LOG( blahbhahblah );
</code></pre>

<p>will be expanded into an empty string - even the parameters will not be evaluated and will not be included into the emitted code.</p>

<p>You can use any already existing preprocessor symbol that is defined in debug build and not defined in release instead of <code>_DEBUG</code>.</p>
",7
1304192,1304174,1,"<p>I've done something like this before with the preprocessor.</p>

<pre><code>#ifndef DEBUG
#define debugPrint
#endif
</code></pre>

<p>Essentially that will remove all the debug lines</p>
",5
1304193,1304174,7,"<p>Make the function inline, and inside the function have the #ifdef's, like this:</p>

<pre><code>inline void debugPrint(whatever_t wtvr)
{
    #ifdef DEBUG
        Logger::log(wtvr);
    #endif
}
</code></pre>

<p>That way the optimizer will strip the empty function while keeping the code clean.</p>
",4
1304200,1304174,1,"<pre><code>
#ifdef _DEBUG
#define debugPrint(x) _debugPrint(x)
void _debugPrint(int foo) {
    // debugPrint implementation
}
#else
#define debugPrint(x)
#endif
</code></pre>
",0
617834,617825,5,"<p>Your <code>char</code> probably is represented signed. Cast it to <code>unsigned char</code> instead to avoid that it becomes a negative integer when casting to <code>int</code>:</p>

<pre><code>if ((unsigned char)newString[i] &gt;128)
</code></pre>

<p>Depending on your needs, <code>isprint</code> might do a better job, checking for a printable character, including space:</p>

<pre><code>if (!isprint((unsigned char)newString[i])) 
    ...
</code></pre>

<p>Note that you have to cast to <code>unsigned char</code>: input for <code>isprint</code> requires values between <code>0</code> and <code>UCHAR_MAX</code> as character values. </p>
",2
631306,631282,1,"<p>Your <code>Ptr</code> class has a non-const pointer member. You will not be able to assign a <code>const Base*</code> without some unsafe casts. Do you want that? Try this instead:</p>

<pre><code>template &lt;class f, class g&gt;
class Ptr
{
   public:
    Ptr(){};
    Ptr(Base&lt;f,g,Ptr&lt;f,g&gt; &gt; const* a) { in = *a; }
    Base&lt;f,g,Ptr&lt;f,g&gt; &gt;* operator-&gt;()
    {
        return &amp;in;
    };

    Base&lt;f,g,Ptr&lt;f,g&gt; &gt;&amp; operator*()
    {
        return in;
    };

private:
    Base&lt;f,g,Ptr&lt;f,g&gt; &gt; in;
};
</code></pre>
",2
631364,631282,1,"<p>according your example you should do</p>

<pre><code>Ptr( const Base&lt; f,g, Ptr&lt; f, g &gt; &gt;* a )
{
   in = const_cast&lt; Base&lt;f,g,Ptr&lt;f,g&gt; &gt;* &gt; ( a );
}
</code></pre>

<p>ps: I don't like const_cast and in similar cases I try to avoid this. Maybe need do two implementation of Ptr for const and non const arguments.</p>
",4
631393,631282,2,"<p>I think you need to define a separate class to wrap pointers to const, since not only the arguments of the constructor, but also the return types of the operators should be changed to const versions. If you make the <code>ConstPtr</code> a <code>friend</code> of <code>Ptr</code>, this should work out quite nicely:</p>

<pre><code>template&lt;...&gt;
class ConstPtr {
  const Base&lt;...&gt; *in;
  ConstPtr(Base&lt;...&gt;* a) { in = a; }
  ConstPtr(const Base&lt;...&gt;* a) { in = a; }
  ConstPtr(const Ptr&lt;...&gt; &amp;a) { in = a.in; }
  ...
};
</code></pre>

<p>To construct wrappers from raw pointers you could add an overloaded function, more or less like this:</p>

<pre><code>template&lt;..., class P&gt;
P make_ptr(Base&lt;...&gt; *t);

template&lt;...&gt;
Ptr&lt;...&gt; make_ptr&lt; ..., Ptr&lt;...&gt; &gt;(Base&lt;...&gt; *t) {
  return Ptr(t);
}

template&lt;...&gt;
ConstPtr&lt;...&gt; make_ptr&lt; ..., ConstPtr&lt;...&gt; &gt;(const Base&lt;...&gt; *t) {
  return ConstPtr(t)
}
</code></pre>
",5
820727,820696,2,"<p>The <code>getline</code> functions takes an input stream and a string to write to. So, two <code>getline</code> calls read in two lines. Your input mechanism is broken. Either, use <code>getline</code> or the stream extraction operator (i.e. <code>&gt;&gt;</code>) but not both. </p>

<p>If you plan to use <code>getline</code> you need to parse the string (which is effectively one line of input) into tokes, and then store them in appropriately typed arrays. The second and fourth tokens are numbers, hence you will need to convert these from string to <code>int</code> or <code>double</code>.</p>

<p>The <code>operator &gt;&gt;</code> approach:</p>

<pre><code>string name, surname;
int year;
double pay;
while (infile) {
    infile &gt;&gt; name &gt;&gt; surname &gt;&gt; year &gt;&gt; department &gt;&gt; pay;
    namearray[ i ] = name + "" "" + surname;
    // ...
    payarray[ i ] = pay;
    ++i;
}
</code></pre>

<p>The <code>getline</code> approach:</p>

<pre><code>string line;
while (getline(infile, line)) {
    parse(line, tokens);
    namearray[ i ] = token[ 0 ] + "" "" + token[ 1 ];
    // ...
    payarray[ i ] = strTodouble(token[ 4 ]);
    ++i;   
}

// parse definition
void parse(string line, vector&lt;string&gt;&amp; token) {
    // roll your own
}

double strToDouble(string s) {
   // ...
}
</code></pre>
",0
820733,820696,0,"<p>I dont see where you define infile but I will assume that it is an ifile . In that case you should use it the same way u use cin to get input. </p>

<p>Why do you do a getline () ?
That function will stop only at an '\n' char or at an EOF char. So it means, you start reading the int after the end of the line, some random data.</p>

<p>Correct me if i'm wrong, but are there 20 or 19 characters in that first string (James Dean) before the number (10) ?</p>
",0
679863,679825,4,"<p>I find <a href=""http://www.parashift.com/c%2B%2B-faq-lite/index.html"" rel=""nofollow noreferrer"">The C++ FAQ Lite</a> to be one of the best sites for C++ advice.  It is not oriented toward beginners, but then, neither is the C++ language. :)</p>

<p>I'll also second Brian's recommendation of ""Effective C++"" by Scott Meyers.  That is one of the best C++ books you can read.</p>
",0
679832,679825,5,"<p>A great free tutorial is the <a href=""http://cplusplus.com/doc/tutorial/"" rel=""nofollow noreferrer"">C++ language tutorial at cplusplus.com</a> and its <a href=""http://cplusplus.com/"" rel=""nofollow noreferrer"">other resources</a>.</p>

<p>You could also checkout popular C++ books like: The C++ Programming Language by Bjarne Stroustrup or Effective C++ by Scott Meyers,</p>
",1
679838,679825,1,"<p>It's not an exact answer to your request, but if you're going to have to deal with maintaining existing C++ code and/or if you learn well by example, I've found <a href=""https://rads.stackoverflow.com/amzn/click/com/1886411956"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">How Not to Program in C++</a> a very handy book. The sample ""bad"" programs are easy to understand but you're forced to find the bug in the code. </p>

<p>I was in a similar situation. I had learned using C++ in school but had spent most of my career with Perl/Python/C#/Bash and had forgotten my ""basics"".</p>
",0
550054,549979,3,"<p>You need to show us the code, we can't offer any really specific advice without knowing more detail on what you're doing. You touched upon one of the differences between MS Visual C++ and Dev C++ (and its cousins also using GCC under the covers). See final two paragraphs for my suggestions.</p>

<p>However, standard C++ programs should compile and run in either so, if you're having troubles, it's likely because you're using some Microsoft-provided stuff that's not in Dev C++. I don't know what this is since I've never used Dev C++ but my first thoughts would be MFC or Win32 API calls.</p>

<p>Dev C++ should be able to link to the Microsoft libraries but you may need to configure that. Visual C++ will almost certainly make that an easily-configured option (or the default) but you'll probably have to work harder to achieve it in a non-MS product.</p>

<p>If you really want to develop programs easily and you're less concerned with free-as-in-speech as opposed to free-as-in-beer software, get your hands on a copy of Visual C++ Express. It's basically the Microsoft IDE for learning purposes at zero cost and you'll find it a more polished product than the others - this is my opinion, others will argue otherwise and they may be right, that's why it's an opinion :-).</p>

<p>I tend to use the VS2010 Professional package nowadays simply because MS goes out of their way to make it a polished product and I don't mind paying for it since I, in turn, get paid well for my work :-)</p>

<p>If you're more concerned with free-as-in-speech, then Dev C++, Code::Blocks, Eclipse CDT and others, are probably all excellent environments. If you're a beginner, you may need help setting them up for nice debugging or accessing Microsoft libraries but it's well worth it in my opinion. Eclipse was my favorite simply because I used to do a lot of Java at work and I'm familiar with it but everyone seems to rave about Code::Blocks for C++ work. Having had a play, it's very easy to get used to.</p>

<p>And re-iterating my advice for the ""it didn't work"" part of your question, you should show us the code or the errors that you're getting - it may be blindingly obvious to us once we've seen them.</p>
",0
550077,549979,0,"<p>I can second the <a href=""http://www.codeblocks.org/"" rel=""nofollow noreferrer"">Code::Blocks</a> recommendation. It's like an open source version of VC++ 6.0, which was probably the highpoint of the VC++ IDEs. </p>

<p>Regarding your question - you need post some code and/or the error messages you are getting.</p>
",3
550081,549979,0,"<p>Visual C++ uses a common header file for applications made in that environment called stdafx.h (which stands for STandard Application Framework eXtensions). This is probably one of the main reasons it would not compile. Visual C++ is also a much more complete IDE for windows development. The debugger works wonders and is very well integrated in the IDE.</p>

<p>Dev on the other hand is great for starting out. It hasn't been updated in a long time, but for beginners this is great - there are less features there to overwhelm them. Although once developers move on, such features are basically a necessity for productivity enhancement.</p>
",0
1496269,1496229,1,"<p>A hashmap could easily utilise a <code>std::map&lt;std::string, list&lt;T *&gt;&gt;</code> to save a lot of time. Utilising a private map, your remove-symbol function would be as simple as:</p>

<pre><code>bool hashmap::remove (const char *key)
{
    m_map.remove(key);
}
</code></pre>
",5
1496432,1496229,3,"<p>If you really want a hashmap, I would recommend that you directly use std::tr1::unordered_map, accepted into the TR1 of the C++ standard back in 2003 and implemented in many compilers. It will become std::unordered_map within the next standard (C++0x).</p>

<p>Now, if you want criticism on the code: do not use C style strings, prefer std::string. If your code is going to unconditionally return true, then consider that maybe your code should not return at all. Comment your algorithm (not each line): <em>Search backwards until I find a match and remove it. Removal is performed ...</em> that will help others detect where your code does not comply with your intentions. I am yet to understand how you are trying to iterate the array. The code probably differs from your intentions in more than one place.</p>

<p>If you are really implementing a hashmap then you should use the hash algorithm to find the element to remove (if it does exist). It does not make sense building a complex system that has O(1) search time to linearly search.</p>
",0
1723306,1723270,7,"<p>This mingling of a switch statement and a while loop is called ""Duff's Device"". It is a way to unroll loops, which was an optimization often used in earlier times.</p>

<p>So this code still copies the memory contents from one place to the other, but it might be more efficient. Beware, on today's architectures you should always measure that, because with cache locality and blindingly fast CPUs loop unrolling is often a bad idea.</p>
",0
1723310,1723270,4,"<p><a href=""http://en.wikipedia.org/wiki/Duff%27s_device"" rel=""nofollow noreferrer"">Duff's device</a></p>

<blockquote>
  <p>In <a href=""http://en.wikipedia.org/wiki/Computer_science"" rel=""nofollow noreferrer"">computer science</a>, <strong>Duff's device</strong> is an <a href=""http://en.wikipedia.org/wiki/Optimization_%28computer_science%29"" rel=""nofollow noreferrer"">optimized</a> <a href=""http://en.wikipedia.org/wiki/Implementation"" rel=""nofollow noreferrer"">implementation</a> of a serial copy that uses a technique widely applied in <a href=""http://en.wikipedia.org/wiki/Assembly_language"" rel=""nofollow noreferrer"">assembly language</a> for <a href=""http://en.wikipedia.org/wiki/Loop_unwinding"" rel=""nofollow noreferrer"">loop unwinding</a>. Its discovery is credited to <a href=""http://en.wikipedia.org/wiki/Tom_Duff"" rel=""nofollow noreferrer"">Tom Duff</a> in November of 1983, who at the time was working for <a href=""http://en.wikipedia.org/wiki/Lucasfilm"" rel=""nofollow noreferrer"">Lucasfilm</a>. It is perhaps the most dramatic use of <a href=""http://en.wikipedia.org/wiki/Switch_statement"" rel=""nofollow noreferrer"">case label fall-through</a> in the <a href=""http://en.wikipedia.org/wiki/C_%28programming_language%29"" rel=""nofollow noreferrer"">C programming language</a> to date. Duff does not claim credit for discovering the concept of <a href=""http://en.wikipedia.org/wiki/Loop_unwinding"" rel=""nofollow noreferrer"">loop unrolling</a>, just this particular expression of it in C.</p>
</blockquote>
",0
1723332,1723270,5,"<p>This is functionally identical to the code below:</p>

<pre><code>for(int i=0;i&lt;n;i++)
{
  *to++=*from++;
}
</code></pre>

<p>The difference is that your code <strong>unrolls the loop</strong> so that only 1 loop iteration is required for each 8 integers copied. Since there are no breaks for any of the <strong>cases</strong>, execution falls through from each case label to the next. </p>

<p>When count%8==0, 8 copies are executed inside of the loop <strong>for the first iteration</strong></p>

<p>when count%8==7, 7 copies are executed <strong>for the first iteration</strong></p>

<p>and so forth. After the first iteration with %8 copies, exactly 8 copies happen per iteration.</p>

<p>By unrolling the loop in this manner, the loop overhead is significantly reduced. It's important to note the order of the case values (0,7,6,5,4,3,2,1) which lend themselves to being translated into a jump table by the compiler.</p>

<p><strong>update</strong></p>

<p>An issue with the example code posted by OP is that a count value of 0 will cause 8 copies to take place, potentially resulting in a buffer overflow.</p>
",1
831471,831445,0,"<p>If I were you I would start again from scratch. I would:</p>

<ul>
<li>use std::strings instead of character arrays for your data</li>
<li>reads line at a time from the file using std::getline</li>
<li>parse the line up using a stringstream</li>
<li>avoid mixing formatted and unformatted input</li>
</ul>
",3
831474,831445,0,"<p>My approach to this would be the following:</p>

<p>1) Read each line into a null terminated buffer.
2) Use a split() function that you're gonna have to write. This function should take a string as its input and return a list. It should also take a separator. The separator in this case is ' '.
3) iterate over the list carefully (are there never middle names?) What about 1 word, or 3 word street names? Since many of these columns are really variable in number of words, and you have no seperator other than whitspace, this may prove a fairly tough task. If you NEVER have middle names, you could assume the first two columns are first and last name. You know for sure what the last two are. Everything between them could be assigned to a single address field.</p>
",0
831476,831445,3,"<p>The problem is <code>istream::get()</code> breaks for <code>streetAddress</code> which has spaces in it.</p>

<p>One way is to tokenize the input line first into say, a <code>vector</code> of <code>strings</code> and then depending on the number of tokens convert these to appropriate fields of your <code>CustomerType</code>:</p>

<pre><code>vector&lt;string&gt; tokenize(string&amp; line, char delim=' ') {
      vector&lt;string&gt; tokens;
      size_t spos = 0, epos = string::npos;
      while ((epos = line.find_first_of(delim)) != string::npos) {
          tokens.push_back(line.substr(spos, epos - spos));
          spos = epos; 
      }
      return tokens;     
}
</code></pre>

<p>I'd rather a stream extraction operator for <code>CustomerType</code> :</p>

<pre><code>struct CustomerType  {
   friend istream&amp; operator&gt;&gt;(istream&amp; i, CustomerType&amp; c);
   string firstName, lastName, ...;
   // ...
};

istream&amp; operator&gt;&gt;(istream&amp; i, CustomerType&amp; c) {       
   i &gt;&gt; c.firstName &gt;&gt; c.lastName;
   string s1, s2, s3;
   i &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; s3;
   c.streetAddress = s1 + s2 + s3;  
   i &gt;&gt; c.city &gt;&gt; c.state &gt;&gt; c.zipCode;
   return i;
}
</code></pre>
",5
831479,831445,1,"<p>You're getting 8 characters for State, which includes all your zipcode, and is larger than your field.</p>

<p>It'd also be tempting to use the <code>skipws</code> operator:</p>

<pre><code>infile &gt;&gt; skipws &gt;&gt; CT_Struct.firstName
       &gt;&gt; CT_Struct.lastName 
       &gt;&gt; ... ;
</code></pre>

<p>(Update: that's what I get for doing that from memory.  This is more closely approximating correct.)</p>
",0
399094,399053,0,"<p>It seems you shouldn't need to return by pointer in the above case.</p>

<p>If you do need to return a modified result, you may want to look into return value optimization(RVO). With RVO, you save yourself copying of temporaries (and in your case dynamic allocation) by passing in the output parameter by reference.</p>

<p>For example</p>

<pre><code>void openInputFile(ifstream&amp; file)
{
    file.open(...);
}

int main()
{
    ifstream file;
    openInputFile(file);

    // Work with file, since file is
    // on the stack you don't have to worry about cleanup/etc
}
</code></pre>

<p>This gets rid of a lot of the problems dealing with dynamic allocation and may avoid the problems you are coming across. You seem to be kind-of onto this, so I'm puzzled as to the need to return the ifstream.</p>

<p>If you need <em>do need</em> to return by pointer, in that case in seems all your missing is an asterisk. For example this function:</p>

<pre><code>    ifstream* Blah();
</code></pre>

<p>should work.</p>
",0
399124,399053,1,"<p>The C++ way to do this would be to create a class that wraps up all of the opening, reading and writing. Note that this would also handle closing the file automatically, a good example of <a href=""http://en.wikipedia.org/wiki/Resource_acquisition_is_initialization"" rel=""nofollow noreferrer"">RAII</a>.</p>

<pre><code>// FancyFile.h:

class FancyFile
{
    private:
        std::ifstream stream;

    public:
        void DoMagic();

        InputFile(const std::string FilePath)
            { stream.open(FilePath.c_str()); }
        ~InputFile(void)
            { stream.close(); }
};
</code></pre>

<pre><code>// FancyFile.cpp:

#include &lt;fstream&gt;
#include &lt;string&gt;

#include ""FancyFile.h""

void FancyFile::DoMagic()
{
    //.. your custom file handling code goes here
}
</code></pre>

<pre><code>// main:

#include ""FancyFile.h""

int main()
{    
    FancyFile myFancyFile(""test.txt"");

    myFancyFile.DoMagic();

    system(""pause"");
    return 0;
}
</code></pre>
",0
399152,399053,0,"<p>The example doesn't actually show you opening the ifstream with the file name specified?<br>
The example is requesting user input of the file name, and then saying it can only be one value?</p>

<p>As Doug T. said, it would probably be nicer from the example code to make use of scope to manage the ifstream.<br>
Anyway, here is an example returning a pointer</p>

<pre><code>ifstream * openInputFile( ) {
  string MyFil;
  string sFile = ""test.txt"";

  cout &lt;&lt; ""Enter a file: "";
  cin &gt;&gt; MyFile ;

  if ( MyFile == sFile )   
  {
    ifstream * inputFile = new ifstream( MyFile.c_str() );
    // do some other stuff here?
    return inputFile;
  } else {
    return null;
  }
}
</code></pre>

<p>Then main can be</p>

<pre><code>int main()
{
  int chgLine;
  string sLine;
  ifstream *inputFile = openInputFile();
  if( NULL == inputFile )
  {
    cout &lt;&lt; ""Error"";
    exit(0);
  }
...
</code></pre>
",0
1502177,1502167,3,"<pre><code>unsigned n = 0;
for ( ; str[n] != NULL; ++n ); // how many characters?
</code></pre>

<p>You know you could just use <code>strlen(str)</code>, right?</p>

<p>And the line:</p>

<pre><code>return result % maxSize;
</code></pre>

<p>Where's this <code>result</code> from? I don't see any <code>result</code> variable.</p>
",4
1502227,1502167,7,"<pre><code>s[0](31^(n-1)) + s[1](31^(n-2)) + ... + s[n-1]
</code></pre>

<p>In the formula <code>^</code> indicates exponentiation, not the bitwise <code>xor</code> operation.<br>
Check out <a href=""https://stackoverflow.com/questions/822363/proof-why-does-java-lang-string-hashcodes-implementation-match-its-documentat"">this</a> SO question.</p>
",0
1502463,1502167,0,"<p>Just going from this code, you could do the following:</p>

<pre><code>void function (const char *str)
{
    while (*str)
    {
        /* process whatever with *str which is the same as str[i] in a for loop */
        str++;
    }
}
</code></pre>

<p>Also, you don't need the second const on those <code>const char *const</code> parameters. <code>const char *</code> is fine.</p>
",0
1990308,1990277,2,"<p>I see you found your solution, but please note that you could also get away with writing a class wrapper for SDL_rect, or even a global function <code>SDL_rect createRect( int x, int y, int w, int h )</code></p>
",1
992917,992661,2,"<p>In the MSDN doc <a href=""http://msdn.microsoft.com/en-us/library/aa376389(VS.85).aspx"" rel=""nofollow noreferrer"">here</a>... There is a note mentioning issues when using this on VISTA (or later). </p>

<p>To paraphrase, if you're using this on Vista - the API will return true - because of the way Vista uses a split token for security. </p>

<p>Here is the original note (originally written by <a href=""http://msdn.microsoft.com/en-us/library/user-591363.aspx"" rel=""nofollow noreferrer"">tchao</a>):</p>

<blockquote>
  <p>When UAC is enabled in Windows
  Vista--which is the default setup, a
  thread in an administrator account
  will have a pair of split tokens: a
  filtered token and an elevated token.
  The filtered token will have the local
  administrators group SID in its group,
  but that SID is not enabled until the
  thread gets the elevated token after
  user's approval via the UAC dialog or
  programmatically. The above sample
  code shows that both a filtered
  administrator token and an elevated
  administrator token as having the
  local administrators group SID
  ""enabled,"" but that is not the case
  with the filtered administrator token
  which has its TOKEN_ELEVATION_TYPE as
  TokenElevationTypeLimited.</p>
  
  <p>If you look at the local
  administrators group association with
  the administrator filtered token, it's
  for deny only, but
  CheckTokenMembership() will show that
  the administrator filtered token is a
  member (enabled?) of the local
  administrators group. Perhaps this is
  also a function implementation bug?!</p>
</blockquote>
",1
841483,841464,1,"<p>I am reading a word from each line.</p>

<pre><code>    #include&lt;fstream&gt;
    #include&lt;string&gt;
    using namespace std;    
    int main(int argc, char **argv)
    {
    fstream inFile;
    string str;
    while(!inFile.eof())
    {
    inFile.open(""file.txt"");
    infile&gt;&gt;str;
    }
    inFile.close();
    return 0;
    }
</code></pre>
",8
841503,841464,2,"<pre><code>#include &lt;fstream&gt;
#include &lt;string&gt;

int main()
{
    std::ifstream file(""myfile.txt"");  // open the file
    std::string line, whole_file;

    // Read one line at a time from 'file' and store the result
    // in the string called 'line'.
    while (std::getline(file, line))
    {
        // Append each line together so the entire file will
        // be in one string.
        whole_file += line;
        whole_file += '\n';
    }

    return 0;
    // 'file' is closed automatically when the object goes out of scope.
}
</code></pre>

<p>A couple of things to note here.  <code>getline()</code> returns a reference to the stream object, which fails the while-test if anything bad happens or if you reach the end of the file.  Also, the trailing newline is <em>not</em> included in the string, so you have to append it manually.</p>
",3
841559,841464,2,"<p>The shortest code: (not effecient)</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;fstream&gt;

int main()
{
    std::ifstream f(""plop"");


    std::string buffer;
    std::copy(std::istreambuf_iterator&lt;char&gt;(f),
              std::istreambuf_iterator&lt;char&gt;(),
              std::back_inserter(buffer));
}
</code></pre>

<p>How I would probably do it:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;    
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;fstream&gt;



int main()
{
    // Find the size of the file
    std::ifstream       file(""Plop"");
    file.seekg(0,std::ios_base::end);

    std::streampos      size    = file.tellg();

    // Read the file in one go.
    file.seekg(0);
    std::vector&lt;char&gt;   buffer(size); // pre-szie the vector.
    file.read(&amp;buffer[0],size);

    // or

    // Until the next version of the standard I don't think string gurantees contigious storage.
    // But all the current versions I know do use continious storage so it should workd.
    file.seekg(0);
    std::string         buffer1(size);
    file.read(&amp;buffer1[0],size);
}
</code></pre>
",0
841594,841464,0,"<p>This is longer than the short solutions, but is possibly slightly more efficient as it does a bit less copying - I haven't done any timing comparisons though:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
using namespace std;;

unsigned int FileRead( istream &amp; is, vector &lt;char&gt; &amp; buff ) {
    is.read( &amp;buff[0], buff.size() );
    return is.gcount();
}

int main() {
    ifstream ifs( ""afile.dat"", ios::binary );
    const unsigned int BUFSIZE = 64 * 1024; 
    std::vector &lt;char&gt; buffer( BUFSIZE );
    unsigned int n;
    string s;
    while( n = FileRead( ifs, buffer ) ) {
        s.append( &amp;buffer[0], n );
    }

    cout &lt;&lt;  s;
}
</code></pre>
",0
841601,841464,2,"<p>I'm not seeing as much:</p>

<pre><code>#include &lt;fstream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
using namespace std;

int main() {
    ifstream ifs(""filename"");
    stringstream ss;
    ss &lt;&lt; ifs.rdbuf();
    string s = ss.str();
}
</code></pre>

<p>... as I'd expect. You'd want some error-checking too.</p>

<p>Konrad Rudolph gave this as the answer to the ""related question"" linked above. I suppose this isn't a duplicate, since this asks for the shortest code, but the answer is the same either way. So I repost it here as wiki.</p>
",2
900110,841464,0,"<p>If you <em>know</em> that your file contains text, then you can use <a href=""http://www.stlsoft.org/"" rel=""nofollow noreferrer"">STLSoft</a>'s <code>platformstl::memory_mapped_file</code>:</p>

<pre><code>platformstl::memory_mapped_file file(""your-file-name"");
std::string contents(static_cast&lt;char const*&gt;(file.memory()), file.size());
</code></pre>

<p>or</p>

<pre><code>platformstl::memory_mapped_file file(""your-file-name"");
std::wstring contents(static_cast&lt;wchar_t const*&gt;(file.memory()), 
          file.size() / sizeof(wchar_t));
</code></pre>

<p>On WIndows, that will leave your string containing <code>\r\n</code> sequences, so you could instead use the <code>winstl::load_text_file()</code> function:</p>

<pre><code>std::string contents;
winstl::load_text_file(""your-file-name"", contents);
</code></pre>

<p>If you want it loaded into a collection of lines, then use <code>platformstl::read_lines()</code>:</p>

<pre><code>platformstl::basic_file_lines&lt;char&gt; lines(""your-file-name"");
size_t n = lines.size();
std::string line3 = lines[3];
</code></pre>
",0
356728,356726,78,"<p>bool is a fundamental datatype in C++. Converting <code>true</code> to an integer type will yield 1, and converting <code>false</code> will yield 0 (4.5/4 and 4.7/4). In C, until C99, there was no bool datatype, and people did stuff like</p>

<pre><code>enum bool {
    false, true
};
</code></pre>

<p>So did the Windows API. Starting with C99, we have <code>_Bool</code> as a basic data type. Including <code>stdbool.h</code> will <strike>typedef</strike> <code>#define</code> that to <code>bool</code> and provide the constants <code>true</code> and <code>false</code>. They didn't make bool a basic data-type (and thus a keyword) because of compatibility issues with existing code. </p>
",0
356730,356726,5,"<p>C++ does lots of automatic casting for you - that is, if you have a variable of type <code>bool</code> and pass it to something expecting an <code>int</code>, it will make it into an <code>int</code> for you - <code>0</code> for <code>false</code> and <code>1</code> for <code>true</code>.</p>

<p>I don't have my standard around to see if this is guaranteed, but every compiler I've used does this (so one can assume it will always work).</p>

<p>However, relying on this conversion is a bad idea. Code can stop compiling if a new method is added that overloads the <code>int</code> signature, etc.</p>
",0
356734,356726,2,"<p>yes, it was introduced in 1993.</p>

<p>for further reference: <a href=""http://en.wikipedia.org/wiki/Boolean_datatype#C.2B.2B"" rel=""nofollow noreferrer"">Boolean Datatype</a></p>
",3
356737,356726,8,"<p>Yes, bool is a built-in type.</p>

<p>WIN32 is C code, not C++, and C does not have a bool, so they provide their own typedef BOOL.</p>
",3
356762,356726,2,"<p>C is meant to be a step above assembly language. The C if-statement is really just syntactical sugar for ""branch-if-zero"", so the idea of booleans as an independent datatype was a foreign concept at the time. (1)</p>

<p>Even now, C/C++ booleans are usually little more than an alias for a single byte data type. As such, it's really more of a purposing label than an independent datatype.</p>

<p>(1) Of course, modern compilers are a bit more advanced in their handling of if statements. This is from the standpoint of C as a new language.</p>
",0
356768,356726,-1,"<p>Allthough it's now a native type, it's still defined behind the scenes as an integer (int I think) where the literal <code>false</code> is 0 and <code>true</code> is 1. But I think all logic still consider anything but 0 as true, so strictly speaking the true literal is probably a keyword for the compiler to test if something is not false. </p>

<pre><code>if(someval == true){
</code></pre>

<p>probably translates to:</p>

<pre><code>if(someval !== false){ // e.g. someval !== 0
</code></pre>

<p>by the compiler</p>
",3
841633,841619,7,"<p>You need to use a member initializer in your Structure2 ctor.</p>

<pre><code>Structure2(const Structure1&amp; structurein) : structure(structurein) {}
</code></pre>

<p>It's trying to use a default constructor for your Structure1 member, and there isn't one.</p>
",0
841641,841619,0,"<p>Since you have declared a constructor for Structure2, the compiler refuses to create a default constructor for it which is needed in order to access members of the class like you do in this constructor:</p>

<pre><code>  Structure2(const Structure1&amp; structurein) { structure = structurein; }
</code></pre>

<p>You should probably do:</p>

<pre><code>Structure2(const Structure1&amp; structurein) : structure(structurein) {}
</code></pre>
",0
841666,841619,1,"<p>By the way, I think you need to fix the copy constructor:</p>

<pre><code>Structure1::Structure1(const Structure1&amp; structurein)
{
 ///!!!! Initialize N
 N = structurein.N;

 vec = new double[structurein.N];
 for(int i = 0; i &lt; structurein.N; i++)
 {
  vec[i] = structurein.vec[i];
 };
}
</code></pre>
",3
551100,551082,7,"<p>Lets examine the line </p>

<pre><code>cout &lt;&lt; file;
</code></pre>

<p>The reason this outputs a number is because deep under the hood fstream is a file pointer. By passing file to cout you're essentially asking for a cout of an fstream.  This will default to the value of the underlying handle for the file.  </p>

<p>If you want to output the contents of the file, you'll need to read it in and output it line by line.  </p>

<pre><code>fstream file;
file.open(""test.txt"",ios::in|ios::out);
file &lt;&lt; ""Hello World"";
file.seekg (0, ios::beg);
while ( !file.eof() ) {
  string temp;
  file &gt;&gt; temp;
  cout &lt;&lt; temp &lt;&lt; std::eol;
}

file.close();
</code></pre>
",5
551104,551082,6,"<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;

int main(int, char **) 
{
  std::ifstream input(""test.txt"");
  char c;                                                          
  while (input &gt;&gt; c) {
    std::cout &lt;&lt; c;
  }
  return 0;
}
</code></pre>

<p>Don't include the whole standard namespace.
If you want an input file stream, use an ifstream.</p>

<p>You want to output the contents of the file, not the file.</p>

<p>If you want to write to a file, then read it back and send it to stdout,</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;

int main(int, char **)
{
  std::fstream file(""test.txt"",std::ios::in|std::ios::out);
  file &lt;&lt; ""Hello"" &lt;&lt; std::endl;
  file.seekp(std::ios::beg);
  char c;
  while (file &gt;&gt;c) {
      std::cout &lt;&lt; c ;
  }
  return 0;
}
</code></pre>

<p>Konrad has the best answer, but consider the high-level approach:</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;iterator&gt;

int main(int, char **)
{
  std::fstream file(""test.txt"",std::ios::in|std::ios::out);
  file &lt;&lt; ""Hello"" &lt;&lt; std::endl;
  file.seekp(std::ios::beg);
  std::copy(
      std::istream_iterator&lt;char&gt;(file),
      std::istream_iterator&lt;char&gt;(), 
      std::ostream_iterator&lt;char&gt;(std::cout)
      );
  return 0;
}
</code></pre>
",0
551116,551082,12,"<p><strong>EDIT:</strong> With mrree's suggestions.</p>

<pre><code>ifstream fin(""file.txt"");

if (fin.is_open() == false) {
  // error
}

string line;

while( getline(fin, line) ) {  
  cout &lt;&lt; line;
}
</code></pre>
",1
551149,551082,25,"<h2>Simple solution</h2>

<p>As others have pointed out, directly printing a file to a stream does't work. Printing the file contents would require opening <em>another stream</em> that reads from the file, or re-setting your stream's read pointer to the beginning and then reading the whole file again (as others have shown).</p>

<p>C++ doesn't do this automatically but you can do it manually (here, opening a new stream):</p>

<pre><code>ifstream ifs(""filename"");
</code></pre>

<p>Now, writing the file contents to another stream is a trivial addition. Instead of writing the file, simply write the file buffer:</p>

<pre><code>cout &lt;&lt; ifs.rdbuf() &lt;&lt; endl;
</code></pre>

<p>That's all! No loop needed to read the file line by line.</p>

<h2>Testing for valid streams</h2>

<p>While we're on the subject of loops, beware of code that reads files in a loop in the following manner:</p>

<pre><code>while ( !file.eof() )
</code></pre>

<p>This code produces an endless loop when there's a reading error. This an happen in many, many situations. Consider e.g. that the file is deleted while you read it, or that someone removes the USB device containing the file or that the file is wrongly formatted. All these cases would create an infinity loop here. <em>Never</em> only test for <code>eof</code> in a stream.</p>

<p>Luckily, the solution to this problem is also quite simple. Furthermore, it explains why your original code yielded such a weird result. In fact, streams in C++ have an implicit conversion to a <em><code>bool</code>-like</em> type. For reasons explained elsewhere (cue: <a href=""https://stackoverflow.com/questions/263227""><strong>safe bool idiom</strong></a>), it is actually converted to <code>void*</code>.</p>

<p>This makes it easy to test whether a stream is in a valid, not-at-end state and can safely be read from. Therefore, we can reformulate the loop appropriately:</p>

<pre><code>while (file) ¡­
</code></pre>

<p>The above code relies on the conversion to <code>void*</code> taking place. Any non<code>null</code> pointer indicates a valid stream. Now, the same happens in your code:</p>

<pre><code>cout &lt;&lt; file;
</code></pre>

<p>Since there's no appropriate overload for <code>operator &lt;&lt;</code> that takes a stream, C++ looks for other overloads and finds an overload for pointers. So it implicitly calls something like this:</p>

<pre><code>cout &lt;&lt; static_cast&lt;void*&gt;(file);
</code></pre>

<h2>Better solution</h2>

<p>I've explained a simple, working solution above. However, this solution requires re-opening the file and reading it to memory again. This doubles the work required. We can make this better by introducing a new class that acts like a stream and that actually sends each output to two streams at once. This way, you can write your data both to the file and to the standard stream at the same time. No need to re-read the file.</p>

<p>The class in itself is quite simple. The following complete code demonstrates the general principle:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;

struct sinkpair {
    sinkpair(std::ostream&amp; a, std::ostream&amp; b) : a(a), b(b) { }

    // Forward all ouputs to both streams.
    template &lt;typename T&gt;
    sinkpair&amp; operator &lt;&lt;(T const&amp; value) {
        a &lt;&lt; value;
        b &lt;&lt; value;
        return *this;
    }

    // Explicit overload needed for manipulators such as `endl`.
    sinkpair&amp; operator &lt;&lt;(std::ostream&amp; (*manip)(std::ostream&amp;)) {
        a &lt;&lt; manip;
        b &lt;&lt; manip;
        return *this;
    }

private:
    std::ostream&amp; a;
    std::ostream&amp; b;
};

int main() {
    std::ofstream ofs(""test.txt"");
    sinkpair sp(std::cout, ofs);
    sp &lt;&lt; ""Hello"" &lt;&lt; std::endl;
}
</code></pre>
",6
841817,841705,1,"<p>This has nothing to do with the question, that has been properly answered by mmyers (and already accepted), but since it seems that you are learning, just a couple of advices:</p>

<p>You do not need typedefs for structs or classes, the typename will automatically be available in the namespace. [*]</p>

<p>Make 1 argument constructors <em>explicit</em> and prefer initialization lists to code in the constructor block. Marking explicit will avoid implicit casts from the argument type to the class type.</p>

<p>Constness is important: Mark non-mutating methods as const so that the compiler knows.</p>

<p>Prefer libraries over hand made equivalent solutions. Know the STL (std::vector is probably quite similar to what you are working on, now I understand this is probably for learning)</p>

<pre><code>class Structure1 // typedef removed
{
   int N;
   double *vec;
public:
   explicit Structure1( int Nin );        // explicit to disable implicit conversions from int to Structure1
   Structure1( const Structure1 &amp; stin );
   int get_N() const { return N; }        // marked as const: it won't change the object
   double* get_vector() { return vec; }   // not const: user can change the contents of the vector!
                                          // if you don't want the user to change it return a const double*
};

Structure1::Structure1( int Nin ) 
   : N( Nin ), vec( new double[Nin] )
{
   for ( int i = 0; i &lt; N; ++i ) vec[i] = i;
}
Structure1::Structure1( const Structure1 &amp; other )
   : N( other.N ), vec( new double[other.N] )
{
   for ( int i = 0; i &lt; N; ++i ) vec[i] = other.vec[i];
}
</code></pre>

<p>[*] There is a subtle difference, but it won't show up in 99.99% of the code and most C++ programmers don't even know. Most people are used to not typedef-ing classes or structs in C++.</p>
",0
841716,841705,1,"<p>Looks like you don't set <code>N</code> in <code>Structure1</code>'s copy constructor. You need:</p>

<pre><code>Structure1::Structure1(const Structure1&amp; structurein){
 N = structurein.N;
 vec = new double[structurein.N];
 for(int i = 0; i &lt; structurein.N; i++) {
  vec[i] = structurein.vec[i];
 }
}
</code></pre>

<p>(Also, you don't need a semicolon after a for-loop. But that's another matter.)</p>

<p><strong>Edit:</strong> This was actually mentioned in <a href=""https://stackoverflow.com/questions/841619/c-constructor-problem/841666#841666"">an answer</a> to your other question. ;)</p>
",1
850469,850436,2,"<p>You don't mention what sort of errors you are getting, but one very obvious problem with your code is that the constructor for <code>Contains_List</code> expects a pointer to <code>Integer_Class</code> while the parameter you are sending it (<code>list</code>) is of type <code>vector&lt;Integer_Class&gt;</code>.</p>

<p>A vector is not the same as an array, so you cannot pass it as pointer to the type it contains. Either change your constructor to accept a vector or pointer/reference to vector, or change the code that is causing you problems so that it sends it a pointer to an array.</p>
",0
850470,850436,0,"<p>The 'Contains_List' constructor takes in an 'Integer_Class*'</p>

<p>You declare 'list' to be of type 'vector', yet you pass it to the the 'Contians_List' constructor.  You should change the 'Contains_List' class so that it holds a vector instead of an Integer_List array.  The two are not interchangeable.</p>

<p>You could also change the vector to be an array of Integer_List's instead, if you so wished.</p>
",0
1534840,1534819,3,"<p>It's no different than using stream operator &lt;&lt; for any other type (it is called operator <em>overloading</em> for a reason).</p>

<p>However, outputting should not modify an object, hence you really should pass it by const reference (otherwise calls with temporaries would fail to compile).</p>

<pre><code>friend ostream&amp; operator&lt;&lt;(ostream&amp; out, const stack&amp; s);
friend ostream&amp; operator&lt;&lt;(ostream&amp; out, const stack::myItem&amp; theItem);
</code></pre>
",0
1535501,1534819,1,"<p>Call it from where?  As it's coded only the class knows about the private struct.  No code external to the class could use that method since it couldn't create an instance of the struct.  Marking it as friend doesn't do you much good.</p>
",0
1536380,1534819,3,"<p>This operator is a classic binary operator.</p>

<pre><code>// Say I have an operator declared like this:
return_type operator@(left_type lhs, right_type rhs);

// Then the invocation is done this way:
left_type L;
right_type R;
return_type result = L @ R;
</code></pre>

<p>In the case of the streaming operator, it is a bit special since the left hand argument and the return type actually have the same type (and indeed, will refer to the same object, albeit at different times). This has been done to allow chaining.</p>

<pre><code>// Chaining
std::cout &lt;&lt; ""&lt;Output&gt;  "" &lt;&lt; 1 &lt;&lt; std::endl;

// Which can be analyzed like such
operator&lt;&lt;(
  operator&lt;&lt;(
    operator&lt;&lt;(
      std::cout ,
      ""&lt;Output&gt;  ""
    ),
    1
  ),
  std::endl
);
</code></pre>

<p>As you can see, the syntax merely allows a convenient invocation. One might note that the order is very well defined, it is a strict left to right evaluation.</p>

<p>So with your object, it would become:</p>

<pre><code>stack s;
std::cout &lt;&lt; s &lt;&lt; std::endl;
</code></pre>

<p>Just like that!</p>
",0
917171,917120,1,"<p>It is possible to pass a member function pointer to a function as follows:</p>

<pre><code>typedef bool (NeedleUSsim::*compFunctionPtr)(NeedleUSsim &amp;x, NeedleUSsim &amp;y);

void NeedleUSsim::FindIdxRho(compFunctionPtr comparison)
{
    //..
    p = std::find_if(tplRho_deg, tplRho_deg+sampleDim[2], comparison);
    //..
}
</code></pre>

<p>Which can then be called like so:</p>

<pre><code>//..
someNeedleUSsim.FindIdxRho(&amp;NeedleUSsim::LessThanOrEqualTo);
//..
</code></pre>

<p>Have a look at <a href=""http://www.parashift.com/c++-faq-lite/pointers-to-members.html"" rel=""nofollow noreferrer"">this</a> C++ FAQ Lite article for more information.</p>
",0
917173,917120,3,"<blockquote>
  <p>Is there any easy way of passing &amp;NeedleUSsim::GreaterThanOrEqualTo function as a parameter of the function that I'm trying to write easily?</p>
</blockquote>

<p>There's a couple ways to do this.</p>

<ol>
<li>You can pass the function pointer around</li>
<li>You can create and pass a function object using run-time polymorphism</li>
<li>You can make your common function templated on a function object (compile time polymorphism)</li>
</ol>

<p>The first method is covered above by eJames.</p>

<h2>Option 2</h2>

<p>The second method involves wrapping your comparison functions in some function-object hierarchy. A function object is an instance of a class with the () operator overloaded. This makes the instance callable:</p>

<pre><code> class IComparator
 {
 public:
    virtual bool operator()(lhs, rhs) = 0;
 }


 class CComparatorLessThan : public IComparator
 {
 public:
    virtual bool operator()(lhs, rhs) {...}
 }


 class CComparatorGreaterThan : public IComparator
 {
 public:
    virtual bool operator()(lhs, rhs) {...}
 }
</code></pre>

<p>Your common function would take an ICompatator reference and the behavior would be dynamically bound at runtime.</p>

<h2>Option 3</h2>

<p>The third method involves templatizing instead of creating an object hierarchy</p>

<pre><code>template &lt;class Comparator&gt;
void foo(...)
{
   ...
   Comparator comparer;
   std::find_if(..., comparer);
}
</code></pre>

<p>then calling foo would involve:</p>

<pre><code>foo&lt;CComparatorGreaterThan&gt;(...);
</code></pre>

<p>This eliminates a lot of the runtime overhead of the second solution. Here you don't have to define the base class. You only have to have some kind of class that has operator() overloaded and will return bool.</p>
",1
917176,917120,1,"<p>The easy way to take functions and more complex parameters into a function is to template them (I'm guessing at some of the parameter types)</p>

<pre><code>template &lt;typename F&gt;
void NeedleUSsim::FindIdx(double *ninfoMember, double *tplParam, size_t dimension, F CompareFunc, int &amp;target)
{
    searchTmp = ninfoMember;
    double *p = std::find_if(tplParam, tplParam+sampleDim[dimension], CompareFunc);
    while(p != tplParam+sampleDim[dimension])
    {
        target= p - tplParam;
        p = std::find_if(p+1, tplParam+sampleDim[dimension], CompareFunc);
    }
}
</code></pre>

<p>Then call it:</p>

<pre><code>FindIdx(&amp;ninfo-&gt;rho, tplRho_deg, 2, &amp;NeedleUSsim::GreaterThanOrEqualTo, idxRho);
FindIdx(&amp;ninfo-&gt;l, tplL, 1, &amp;NeedleUSsim::LessThanOrEqualTo, idxL);
</code></pre>
",0
917184,917120,6,"<p>The simplest way to make your code a bit more generic is the following :</p>

<pre><code>template&lt;typename ComparisonType&gt;
double* NeedleUSsim::FindIdx(double* containerBegin, double* containerEnd, ComparisonType comparison) {
    double* p = std::find_if(containerBegin, containerEnd, comparison);
    double* idx = 0;
    while(p != containerEnd)
    {
        idx = p - containerBegin;
        p = std::find_if(p+1, containerEnd, comparison);
    }
    return idx;
}

void NeedleUSsim::FindIdxRho()
{
  searchTmp = &amp;ninfo-&gt;rho;
  double* idx = FindIdx(tplRho_deg, tplRho_deg+sampleDim[2], &amp;NeedleUSsim::GreaterThanOrEqualTo);
  if( idx != 0 )
  {
    idxL = idx;
  }

}

void NeedleUSsim::FindIdxDepth()
{
  searchTmp = &amp;ninfo-&gt;l;
  double* idx = FindIdx(tplL, tplL+sampleDim[1], &amp;NeedleUSsim::LessThanOrEqualTo);
  if( idx != 0 )
  {
    idxRho = idx;
  }
}
</code></pre>
",4
918520,917120,1,"<pre><code>double *p = std::find_if(b, e, &amp;NeedleUSsim::GreaterThanOrEqualTo);
while(p != e)
{
    idxRho = p - b;
    p = std::find_if(p + 1, e, &amp;NeedleUSsim::GreaterThanOrEqualTo);
}
</code></pre>

<p>Note that this loop that you use is not necessary. Use reverse iterators</p>

<pre><code>std::reverse_iterator&lt;double*&gt; rb(e), re(b);
rb = std::find_if(rb, re, &amp;NeedleUSsim::GreaterThanOrEqualTo);
if(rb != re) {
    idxRho = re - rb;
}
</code></pre>

<p>Now its more obvious what it does. If writing to idxRho only when something was found was a mistake or doesn't matter, you can shorten it to this</p>

<pre><code>std::reverse_iterator&lt;double*&gt; rb(e), re(b);
idxRho = re - std::find_if(rb, re, &amp;NeedleUSsim::GreaterThanOrEqualTo);
</code></pre>
",0
741321,741306,1,"<p>I am assuming the following things as it is not clear from the code posted:</p>

<p>(1). ClassObject is defined like this: ClassType* ClassObject[/<em>some value</em>/10];</p>

<p>(2). The class definition in MyHeader.h is of ClassType and not of ClassObject.</p>

<p>In such a case, the following statement is the problem:</p>

<pre><code>ClassObject[wrdCount] = new ClassType[x]
</code></pre>

<p>Here it creates 'x' number of ClassType objects. I don't think thats what you want. I guess you want to construct a ClassType object by passing const char* as the constructor parameter. If that is so you should use it like this:</p>

<pre><code>ClassObject[wrdCount] = new ClassType(tmpAray);
</code></pre>

<p>Also note that you are assuming size of the array passed. I suggest it is better to use something like a std::string instead of raw character arrays.</p>
",0
741330,741306,0,"<p>I'm not entirely clear on what you're doing, but you cannot explicitly call a constructor like that. If you have a pointer-to-a-pointer-to-a-<code>ClassType</code> called <code>ClassObject</code>, you need to do something like this to initialize it:</p>

<pre><code>ClassObject[wrdCount] = new ClassType*[x]; // create a new 'row' in the array with x columns
for (int i = 0; i &lt; x; ++i) // initialize each 'column' in the new row
    ClassObject[wrdCount][i] = new ClassType(tmpArray);
</code></pre>

<p>This doesn't seem to make much sense given the code you have pasted though (since wrdCount doesn't change). It's hard to say without an exact problem description.</p>
",0
741498,741306,0,"<p>You need to use identifiers. The following:</p>

<pre><code>ClassObject[wrdCount] = new ClassType[x] ;
</code></pre>

<p>tries to apply the <code>operator[]</code> to a class type name. What good can that do? None. Try:</p>

<pre><code>ClassObject *a = new ClassType[x];
</code></pre>

<p>This'd create an object <code>a</code> of type array of size <code>x</code> of <code>Classtype</code>s. Do you need an array here -- it's upto you. If all you need is a single variable use:</p>

<pre><code>ClassObject *a = new ClassType;
</code></pre>
",1
724025,661760,1,"<p>The Parser from Eclipse CDT seems to be pretty complete by now, as some refactoring methods have been alredy contributed to CDT.</p>
",0
467681,467649,0,"<p>If sBuffer is an array of chars, then it doesn't contain a double.</p>
",0
467688,467649,2,"<p>It looks like sBuffer is a string or an array of chars, so when you print sBuffer[x], it's treating it as a character instead of a floating point number.</p>

<p>You need to convert the string representation of the number into a double. You can use the <code>atof</code> or <code>strtod</code> functions from C, or <code>boost::lexical_cast&lt;double&gt;</code>.</p>
",0
467718,467649,2,"<p>It doesn't look like your <code>sBuffer[x]</code> would contain a double, you compare it against <code>','</code> after all. So <code>sBuffer</code> is a buffer of characters? Then <code>sBuffer[x]</code> is just one character of your ""4.1415679"" and setprecision won't do what you want if you just output this character.</p>

<p>You can use stringstreams to read a double from a string:</p>

<pre><code>#include &lt;sstream&gt;

istringstream strm(""4.1415679"");
double d;

if (strm &gt;&gt; d) {
  cout &lt;&lt; ""Your number: "" &lt;&lt; setprecision(2) &lt;&lt; d &lt;&lt; endl;
}
else {
  cout &lt;&lt; ""Not a number."" &lt;&lt; endl;
}
</code></pre>

<p>If you have the <a href=""http://boost.org/"" rel=""nofollow noreferrer"">boost</a> libraries installed (always a good idea), you can also use <code>boost::lexical_cast&lt;double&gt;(""..."")</code>, like Matthew Crumley said.</p>
",0
467676,467649,0,"<p>You probably want <a href=""http://www.cplusplus.com/reference/iostream/manipulators/fixed.html"" rel=""nofollow noreferrer""><code>std::fixed</code></a>:</p>

<pre><code>cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; sBuffer[ x ];
//      ^^^^^
</code></pre>
",0
524635,524633,7,"<p>You mean so you can export your function from a library?
<a href=""http://www.devx.com/tips/Tip/12527"" rel=""nofollow noreferrer""><code>extern &quot;c&quot; { your code here }</code></a></p>
",0
524636,524633,29,"<p>You can't. It's built into compilers to allow you overloading functions and to have functions with the same name in different classes and such stuff. But you can write functions that are mangled like C functions. Those can be called from C code. But those can't be overloaded and can't be called by ""normal"" C++ function pointers:</p>

<pre><code>extern ""C"" void foo() {

}
</code></pre>

<p>The above function will be mangled like C functions for your compiler. That may include no change at all to the name, or some changes like a leading ""_"" in front of it or so. </p>
",6
1675839,1675820,2,"<p>Not sure what your problem is. Are you trying to implement a queue (which <em>also</em> can work as a stack, no need for your <code>quack</code>) as a <a href=""http://en.wikipedia.org/wiki/Ring_buffer"" rel=""nofollow noreferrer"">ring buffer</a>?</p>

<p>In that case, you need to save both a front and a back index. The mechanics are described in the article linked above. Pay attention to the ¡°Difficulties¡± section: in particular, you need to either have an extra variable or pay attention to leave one field empty ¨C?otherwise you won¡¯t know how to differentiate between a completely empty and a completely full queue.</p>
",2
1675849,1675820,2,"<p>Well, it seems kind of silly to rule out the stl, since <a href=""http://www.sgi.com/tech/stl/Deque.html"" rel=""nofollow noreferrer""><code>std::deque</code></a> is exactly what you want.  Amortized constant time random access.  Amortized constant insert/removal time from both the front and the back.  </p>

<p>This can be achieved with an array with extra space at the beginning and end.  When you run out of space at either end, allocate a new array with twice the space and copy everything over, again with space at both the end and the beginning.  You need to keep track of the beginning index and the end index in your class.</p>
",3
1677382,1675820,-1,"<p>It seems to me that you have some conflicting requirements:</p>

<ol>
<li>You have to push to the head of a C++ array primitive.</li>
<li>Without shifting all of the existing elements.</li>
<li>Maintain insertion order.</li>
</ol>

<p>Short answer: You can't do it, as the above requirements are mutually exclusive.</p>

<p>One of these requirements has to be relaxed.</p>

<p>To help you without having to guess, we need more information about what you are trying to do.</p>
",0
637587,637438,0,"<p>Are the user specified fields in a single line or spread across multiple lines? </p>

<pre><code>     getline( *inFile, feild1, ',' );
     sStruct.m_1 = field1;
     getline( *inFile, feild2, ',' );
     sStruct.m_2 = field2;
     getline( *inFile, field3, ',' );
     sStruct.m_3; = feild3
     getline( *inFile, feild4 );
     sStruct.m_4 = feield4;
</code></pre>

<p>The code snippet above reads in four lines. Can you paste the first few lines of your user input file?</p>
",0
637483,637438,1,"<p>Your function addElement() gets a parameter vAddElement, but you are pushing into vectorData...?!?</p>
",0
637509,637438,1,"<p>This is because you are creating a new instance of the vector each time you enter loadFile() method. If you want to preserve the contents of the vector, then don't create the vector object inside loadFile. Create it outside this function ( probably from the one which calls loadFile()) and pass it to this function.</p>
",0
637511,637438,1,"<ol>
<li>Make the changes to loadFile() function to take vector object by reference and update the same in loadfile().</li>
</ol>

<p>Something like this:</p>

<pre><code>bool loadFile(char *myTextFile, vector&lt;sStruct&gt;&amp; vectorData_out)
{
      //Read the file
      //push_back the element into vectorData_out
      //vectorData_out.push_back() ...code to push
}
</code></pre>

<p>2.Then change the addElement to accept vectorData_out by reference:</p>

<pre><code>bool addElement(vector&lt;sStruct&gt;&amp; vAddElement_out)
{
      //initilization code for addElement 
     vAddElement_out.push_back( addElement );
     cout &lt;&lt; vAddElement-&gt;size() &lt;&lt; endl;
}
</code></pre>

<p>Now your calling code looks line this:</p>

<pre><code>std::vector&lt;sStruct&gt; aVectorData;
loadFile(""filename.txt"", aVectorData);
addElement(aVectorData);
</code></pre>

<p><strong>EDIT</strong>: Also, try avoiding allocating on heap unless it is absolutely necessary</p>
",0
1678470,1659641,1,"<p>The original question seems to be that you don't understand why the function popFront returns 3 times when there are 3 elements?</p>

<p>If that's the case, I think you are missing the point of recursion.</p>

<p>When you make a recursive call, you are calling the same function again, basically creating a new stack frame and jumping back to the same function. So if there are 3 elements, it will recurse by encountering the first element, encountering the second element, encountering the third element, returning from the third encounter, returning from the second encounter, and returning from the first encounter (assuming you are properly consuming your array, which you don't appear to be).</p>

<p>The current function cannot return until the recursive call has iterated, thus it may appear to return from the last element before the second, and the second before the first.</p>

<p>That is <a href=""http://en.wikipedia.org/wiki/Recursion#Recursion_in_computer_science"" rel=""nofollow noreferrer"">how recursion works</a>.</p>

<p>I wasn't able to make sense of your example, so I whipped one up real fast:</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

bool popfront(int* ptr_, int* back_) {
    cerr &lt;&lt; ptr_[0] &lt;&lt; endl;
    if(ptr_ != back_) {
        popfront(++ptr_, back_);
    }
    return true;
}

int main() {
   int ar[4] = {4,3,2,1};
   popfront(ar, ar + 3);
   return 0;
}
</code></pre>

<p>That's not great, but it should get the point across.</p>
",1
1695712,1659641,2,"<p>I'm not entirely sure I understand what you're trying to do, but if I;m guessing right you're trying to 'pop' the 1st element of the array (<code>items[0]</code>) into the <code>nPopFront</code> int reference, then move all the subsequent elements of the array over by one so that the 1st element is replaced by the 2nd, the 2nd by the 3rd, and so on. After this operation, the array will contain one less total number of elements.</p>

<p>Not having the full declaration of the <code>quack</code> class makes most of the following guesswork, but here goes:</p>

<p>I'm assuming that <code>item[0]</code> represents the 'front' of your array (so it's the element you want 'popped').</p>

<p>I'm also assuming that 'count` is the number of valid elements (so item[count-1] is the last valid element, or the 'back' of the array).</p>

<p>Given these assumptions, I'm honestly not sure what <code>top</code> is supposed to represent (so I might be entirely wrong on these guesses).</p>

<p>Problem #1:  your <code>nPopFront</code> assignment is reversed, it should be:</p>

<pre><code>nPopFront = items[0].n;
</code></pre>

<p>Problem #2; your <code>for</code> loop is a big no-op. It walks through the array assigning elements back to their original location.  I think you want it to look more like:</p>

<pre><code>for (int i = 1; i &lt; count; ++i)
{
    items[i-1].n = items[i].n;  // move elements from back to front
}
</code></pre>

<p>Finally, you'll want to adjust <code>count</code> (and probably <code>top</code> - if you need it at all) before you return to adjust the new number of elements in the data structure. The whole thing might look like:</p>

<pre><code>bool quack::popFront(int&amp; nPopFront)
{   
    if ( count &gt;= maxSize ) return false;
    if ( count == 0 ) return false; // nothing to pop

    nPopFront = items[0].n;
    intFrontPtr = &amp;items[0].n;      // do we really need to maintain these pointers?
    intBackPtr  = &amp;items[count-1].n;

    for (int i = 1; i &lt; count; ++i)
    {
        items[i-1].n = items[i].n;  // move elements from back to front
    }

    count -= 1;     // one less item in the array
    return true;
}
</code></pre>
",0
1695801,1659641,1,"<p>Can't you just use a std::list?</p>

<p>That makes it really to pop from either end using pop_front or pop_back.  You can also add to the front and the back.  It also has the advantage that after popping from the front (or even removing from the middle of the list) you don't have to shift anything around (The link is simply removed) which makes it much more efficient than what you are, seemingly, proposing.</p>
",1
1719256,1659641,0,"<pre><code>bool quack::popFront(int&amp; nPopFront)
{
   if(items.n==0) throw WhateverYouUseToSignalError;
   nPopFront = items[0];
   for (int =0;i&lt;items.n-1,++i){
      items[i]=items[i+1]
   }
   //update size of items array
}
</code></pre>
",0
1389906,1389899,10,"<p>It has nothing todo with copy ctor. You are initializing the variable m_nSize using initializer list with the sizeof the template argument t1.</p>
",0
1389909,1389899,3,"<p>There is no way to initialize a member variable directly in the class defination. This is called initialization list. You can imagine it to be something like:</p>

<pre><code>const int m_nSize = sizeof(t1);
</code></pre>

<p>C++0x allow the above form by the way.</p>
",0
1389951,1389899,1,"<p>CTypeSize(const T &amp;t1) is the constructor of the class.
Members of the class can be initialised in the constructor.</p>

<p>class testclass
{
  // constructor: a, b, c are set to
  // 0, 1, 2
  testclass() : a(0), b(1), c(2)
  {
  }</p>

<p>int a, b, c; // members
};</p>

<p>In your example, "": m_nSize(sizeof(t1))""
means that m_nSize is initialised with the 
value of sizeof(t1).</p>
",0
1389959,1389899,1,"<p>Your question is double:</p>

<p>The <code>: member( value )</code> syntax initializes a new object's member to <code>value</code>.</p>

<p>But <code>template&lt; typename T&gt; Class( const T&amp; )</code> is <em>not</em> the copy constructor.  That one is <code>Class( const Class&amp; )</code>.</p>

<p>So </p>

<pre><code>#include &lt;iostream&gt;
struct C {
   template&lt; typename T &gt;
   C( const T&amp; t ) { std::cout &lt;&lt; ""T""; }

  // C( const C&amp; c ) { std::cout &lt;&lt; ""C""; }
};

int main() { C c1(1); C c2(c1); }
</code></pre>

<p>Will result in the template constructor to be called, followed by the 'synthesized' copy constructor (will output just ""T"".)</p>

<p>When you insert the copy constructor explicitly, that one will be called (output will be ""TC"").</p>
",0
346616,346613,215,"<p>Use a return statement!</p>

<pre><code>return;
</code></pre>

<p>or</p>

<pre><code>if (condition) return;
</code></pre>

<p>You don't need to (and can't) specify any values, if your method returns <code>void</code>.</p>
",5
346619,346613,13,"<p>You mean like this?</p>

<pre><code>void foo ( int i ) {
    if ( i &lt; 0 ) return; // do nothing
    // do something
}
</code></pre>
",0
346621,346613,11,"<pre><code>void foo() {
  /* do some stuff */
  if (!condition) {
    return;
  }
}
</code></pre>

<p>You can just use the return keyword just like you would in any other function.</p>
",0
1083158,1082527,0,"<p>I don't see how making a copy could possibly be faster. Just handle each case of the size of the replacement.</p>

<pre><code>list&lt;char&gt;::iterator q;

for (list&lt;char&gt;::iterator p = productions.begin(); p != productions.end(); p = q)
{
    // save the next position since we might be deleting p
    q = p;
    ++q;

    char* p_rule = productionRules[*p];

    // if points to empty string, nuke
    if (!*p_rule)
        productions.erase(p);
    else
    {
        // if single char, replace
        *p = *p_rule;

        // insert all other chars
        ++p_rule;
        while (*p_rule)
        {
            // check me on this
            // I want to insert before q
            productions.insert(q, *p_rule);
            ++p_rule;
        }
    }
}
</code></pre>
",0
1082534,1082527,2,"<p>It depends on how likely it is that each character would be replaced by zero or >2 characters. If it's unlikely that any such replacement will take place, then you'll probably win by iterating over it. But if it's likely that you will often perform that operation you should almost certainly just create a new list.</p>

<p>You can have your algorithm try to iterate over the list, and if you find you have to do a zero or >2 replacement, then create a new list. Whether or not this wins or not again depends on how likely you are to run into a case where you have to do such a replacement.</p>
",0
1082536,1082527,1,"<p>Create one is always appending to the end which is more efficient and less complicated to implement.</p>
",0
392134,392120,1,"<p>AFAIK, In C++ typedef does not create a full-fledged synonyms when used in conjuction with classes. In other words, it's not like a macro. </p>

<p>Among the restrictions is that the synonym cannot appear after a class or struct prefix, or be used as a destructor or constructor name. You also cannot subclass the synonym. I would bet that is also means you can't friend it.</p>
",0
392136,392120,1,"<p>I tried in the VC++ 8.0 the code:</p>

<pre><code>...
class C
{
public:
  friend class A;       
  friend X;             
  friend B::SUPERCLASS; 
};
...
</code></pre>

<p>It is compiled without errors.</p>

<p>I am not aware whether it MS specific or not.</p>
",0
392138,392120,9,"<p>It can't, currently. I don't know the reason yet (just looking it up, because i find it interesting). Update: you can find the reason in the first proposal to support typedef-names as friends: <a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1520.pdf"" rel=""noreferrer"">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1520.pdf</a> . The reason is that the Standard only supported elaborated-type-specifiers. It's easy to allow only those, and say if the entity declared as friend is not declared yet, it will be made a member of the surrounding namespace. But this means that if you want to use a template parameter, you would have to do (a class is required then for example)</p>

<pre><code>friend class T;
</code></pre>

<p>But that brought additional problems, and it was figured not worth the gain. Now, the paper proposes to allow additional type specifiers to be given (so that this then allows use of template parameters and typedef-names).</p>

<p>The next C++ version (due to 2010) will be able to do it. </p>

<p>See this updated proposal to the standard: <a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1791.pdf"" rel=""noreferrer"">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1791.pdf</a> . It will not allow only typedef names, but also template parameters to be used as the type declared as friend.</p>
",0
322188,322128,0,"<p>Thanks all, wish I could grant multiple points for the answers :)</p>

<p>litb also pointed out a problem I was having in my declaration of the vector.  I removed the second argument in the vector declaration and it worked.</p>

<p>Stackoverflow parsed out some of my code, I'll be more careful in posting next time.</p>
",0
322139,322128,1,"<p>This is the first problem I noticed:</p>

<p><code>std::vector</code> is a template.</p>

<p>You have:</p>

<pre><code>vector unsortedFiles;
</code></pre>

<p>you need something like:</p>

<pre><code>vector&lt;CFileInfo&gt; unsortedFiles;
</code></pre>

<p>Now that I think about it, your template definition may have just gotten parsed out by the stackoverflow comment system.</p>
",1
322145,322128,3,"<p>Use (*iter).member or iter->member.</p>

<p>You can also use temporaries:</p>

<pre><code>CFileInfo &amp;fileInfo = *iter;
cout &lt;&lt; "" "" &lt;&lt; fileInfo.myMember;
</code></pre>

<p>Also, for what you're doing, you'd probably want a const_iterator instead of an (mutable) iterator.</p>

<p>In addition, std::vector is a template accepting a typename and an allocator, not two typenames.  You can use the default allocator by stripping the second template argument:</p>

<pre><code>vector&lt;CFileInfo&gt; unsortedFiles;
vector&lt;CFileInfo&gt;::iterator Iter;
</code></pre>

<hr>

<p>Some nit-picking:</p>

<ul>
<li>main should return an int.</li>
<li>It'd probably be best to declare your iterator variable in the for statement.</li>
<li>It'd probably be faster in run-time performance to use the prefix ++ operator (++iter) instead of the postfix operator (iter++) in your for loop.</li>
<li>No need for your comment about main() ending.</li>
</ul>
",0
322146,322128,1,"<p>First correct you'r vector declaration:</p>

<pre><code>vector&lt;CFileInfo &gt; unsortedFiles;
</code></pre>

<p>Next you need to define an output operator for your class:</p>

<pre><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; str,CFileInfo const&amp; data)
{
       // Do something here
       /* Potentailly you could do this
        *    But this requires that this function be a friend of the class

       str &lt;&lt; data.m_PackLine &lt;&lt; "":""
           &lt;&lt; data.m_FileDateTime &lt;&lt; "":""
           &lt;&lt; data.m_NumDownloads &lt;&lt; "":"";

       *  Or you could do this

           data.print(str);  // Make print a public const method.

       */

       return str;
}
</code></pre>

<p>Usually you either make the output operator a friend of your class or provide a public print method that takes a stream. Either way you can then access the members and stream them manually to the output.</p>

<p>Once you have the output iterator defined you can change your loop to use the standard library versions:</p>

<pre><code>std::for_each(unsortedFiles.begin()
              unsortedFiles.end()
              std::ostream_iterator&lt;CFileInfo&gt;(std::cout,"" "")
             );
</code></pre>
",0
322148,322128,1,"<pre><code>iter-&gt;m_PackLine
</code></pre>

<p>or</p>

<pre><code>(*iter).m_PackLine
</code></pre>
",0
322153,322128,17,"<pre><code>cout &lt;&lt; "" "" &lt;&lt; *Iter;
</code></pre>

<p>will only work if <code>CFileInfo</code> has an overloaded <code>operator&lt;&lt;</code> that can output your struct. You can output individual members of the struct instead like this:</p>

<pre><code>cout &lt;&lt; "" "" &lt;&lt; Iter-&gt;m_PackLine;
</code></pre>

<p>Alternatively, the following is equivalent to that:</p>

<pre><code>cout &lt;&lt; "" "" &lt;&lt; (*Iter).m_PackLine;
</code></pre>

<p>You have to put parentheses around *Iter, since the member-access operator binds thighter otherwise.</p>

<p>On a side-node, make your main function return int instead of void. making it return void is not valid in C++.</p>

<hr>

<p>You declare the vector like this:</p>

<pre><code>vector&lt;CFileInfo, CFileInfo&amp;&gt; unsortedFiles;
</code></pre>

<p>The second argument to <code>vector</code> should be another thing. It's not needed for your code to give the vector a second argument at all. Just use this:</p>

<pre><code>vector&lt;CFileInfo&gt; unsortedFiles;
</code></pre>

<hr>

<p>Another thing i noticed is you increment the iterator using <code>Iter++</code> (called <code>postfix increment</code>). For iterators, always prefer <code>++Iter</code>, which is called <code>prefix increment</code>. </p>
",1
322296,322128,0,"<p><code>vector&lt;CFileInfo, CFileInfo&amp;</code>> will not work at all. The second parameter to vector is the allocator the vector uses, and <code>CFileInfo</code> does not meet those requirements, nor does any reference type. I think you just want <code>vector&lt;CFileInfo&gt;</code>, the iterators and members will return <code>CFileInfo&amp;</code> automatically.</p>
",0
702191,702185,22,"<p>Initializer lists are preferred. See <a href=""http://www.parashift.com/c++-faq-lite/ctors.html#faq-10.6"" rel=""noreferrer"">FAQ 10.6</a></p>
",2
702212,702185,5,"<p>Use the initializer list when possible. For an int, it doesn't matter much either way, but for a more complex member object, you'd end up with the default constructor of the object being called, followed by an assignment to that object, which is likely to end up being slower.</p>

<p>Plus, you have to do it that way anyway for const members or members which don't have a default constructor.</p>
",1
702213,702185,2,"<p>If possible, use the first version.</p>

<p>The first is initializing using intializer lists, and actually calls the constructors of the members.</p>

<p>The second is assignment.  If n was of a type with a default constructor, it the would have already been called, and then you'd be assigning to it.  If n didn't have a default constructor, you'd be forced to use the first type.  Likewise if n was a reference: <code>int &amp;n</code>.  </p>

<p>If there are no constructors of you members that directly take one of the parameters to your constructor, it may be worthwhile to add private static functions that can do the conversion for you.</p>
",0
702225,702185,1,"<p>I generally try to do the initializer list when I can. For one thing, this makes it explicit that you are initializing code in the constructor. const memebers <em>have</em> to be initialized this way. </p>

<p>If you just put code in the constructor's body, it is quite possible someone may decide to come along and move a big chunk of it into a non-constructor ""setup"" routine later.</p>

<p>It can be taken overboard though. I have a coworker who likes to create classes that have 2 pages of initilizer code, no constructor code, and perhaps 2 pages for the entire rest of the class' code. I find that really tough to read.</p>
",0
702245,702185,0,"<p>The second option is not initialization but assignment. With types that have user defined default constructors, the second option will call the default constructor and later on call the assignment operator (whether user defined or not) to assign the value.</p>

<p>Some types cannot be default initialized: If you have an attribute without default constructor, hold references (constant or not) or have constant attributes they must be initialized in the initializer list.</p>

<p>Arrays can be value-initialized in the initialization list, but not in the constructor body:</p>

<pre><code>class X {
public:
   X() : array() {} // value-initializes the array
// equivalent to:
// X() { for ( int i = 0; i &lt; 10; ++i ) array[i]=0; }    
private:
   int array[10];
};
</code></pre>

<p>For POD types, you can value-initialize them in the initialization list but not inside the brackets:</p>

<pre><code>class X {
public:
   X() : pod() {} // value-initializes
// equivalent to (but easier to read and subtly faster as it avoids the copy):
// X() { pod = {}; } 
private:
   PODType pod;
};
</code></pre>

<p>Finally, some classes offer functionality through the use of constructors that will be more complex (if achievable) after default construction.</p>

<pre><code>class X
{
public:
   X() : v(10) {} // construct a vector of 10 default initialized integers
// equivalent to:
// X() { for ( int i = 0; i &lt; 10; ++i ) v.push_back(0); }
private:
   std::vector&lt;int&gt; v;
};
</code></pre>

<p>Last, whenever they are in fact equivalent, initialization lists are more idiomatic in C++.</p>
",0
702264,702185,13,"<p>One big advantage to using initializers: If an exception is thrown anywhere within the initializer list, the destructors will be called for those members that had already been initialized -- and only for those members.</p>

<p>When you use the contructor body to initialize the object, it's up to you to handle exceptions properly and unwind the object as appropriate.  This is usually much harder to get right.</p>
",0
702284,702185,0,"<p>I want to add that you don't need to declare the initializer list on the Header (.h). It can be done at the implementation of the constructor (which is very common).</p>

<p>So then:</p>

<pre><code>//Stuff.h
class Stuff {
public:
     Stuff( int nr );
private:
     int n;
}

//Stuff.cpp
Stuff::Stuff(int nr)
: n(nr)
{
    //initalize complex members
}
</code></pre>

<p>is legal and imo concentrates the initialization of fields where it matters. Sometimes we need to initialize complex members in the body, so you have your initializer list and the complex initialization all in the .cpp file.</p>
",0
445489,445475,2,"<p>No, there's no way to completely prohibit such bad usage in C++.</p>

<p>As a general rule, the user of any library code should never call delete on any wrapped pointers unless specifically documented. And in my opinion, all modern C++ code should be designed so that the user of the classes never was left the full responsibility to manually release her acquired resources (ie. use <a href=""http://en.wikipedia.org/wiki/RAII"" rel=""nofollow noreferrer"">RAII</a> instead).</p>

<p>Aside note: <code>std::auto_ptr&lt;T&gt;</code> isn't the best option anymore. Its bad behaviour on copying can lead to serious coding errors. Often a better idea is to use <code>std::tr1::scoped_ptr&lt;T&gt;</code> or <code>std::tr1::shared_ptr&lt;T&gt;</code> or their <a href=""http://www.boost.org/doc/libs/1_37_0/libs/smart_ptr/smart_ptr.htm"" rel=""nofollow noreferrer"">Boost</a> variants instead.</p>

<p>Moreover, in C++0x, <code>std::unique_ptr&lt;T&gt;</code> will functionally supercede <code>std::auto_ptr&lt;T&gt;</code> as a safer-to-use class. Some discussion on the topic and a recent C++03 implementation for unique_ptr emulation can be found <a href=""http://home.roadrunner.com/~hinnant/unique_ptr03.html"" rel=""nofollow noreferrer"">here</a>.</p>
",1
445501,445475,4,"<p>In order to provide fast, convenient, ""pointer-like"" access to the underlying object, operator-> unfortunately has to ""leak"" its abstraction a bit. Otherwise, smart pointers would have to manually wrap all of the members that are allowed to be exposed. These either requires a lot of ""configuration"" work on the part of those instantiating the smart pointer, or a level of meta-programming that just isn't present in C++. Besides, as pyrsta points out, even if this hole was plugged, there are still many other (perhaps non-standard) ways to subvert C++'s access control mechanisms.</p>
",1
445507,445475,2,"<blockquote>
  <p>Is there any way to write a smart pointer without this problem.</p>
</blockquote>

<p>It isn't easy, and generally no (i.e., you can't do it for every, general Foo class).</p>

<p>The only way I can think of, to do this, would be by changing the declaration of the <code>Foo</code> class: make the <code>Foo</code> destructor private (or define a private <code>delete</code> operator as a member of the <code>Foo</code> class), and also specify in the declaration of the <code>Foo</code> class that <code>std::auto_ptr&lt;Foo&gt;</code> is a <code>friend</code>.</p>
",3
446678,445475,5,"<p>There are two desirable properties a smart pointer should have:</p>

<ol>
<li>The raw pointer can be retrieved (e.g. for passing to legacy library functions)</li>
<li>The raw pointer cannot be retrieved (to prevent double-delete)</li>
</ol>

<p><strong>Obviously, these properties are contradictory and cannot be realised at the same time!</strong>  Even Boost's <code>shared_ptr&lt;Foo&gt;</code> et al. have <code>get()</code>, so they have this ""problem.""  In practice, the first is more important, so the second has to go.</p>

<p>By the way, I'm not sure why you reached for the slightly obscure <code>operator-&gt;()</code> when the ordinary old <code>get()</code> method causes the same problem:</p>

<pre><code>std::auto_ptr&lt;Foo&gt; fooPtr(new Foo);
delete fooPtr.get();
</code></pre>
",4
1581787,1581778,7,"<p>You'd need to do something like:</p>

<ul>
<li>translate by (-<code>playerx</code>-<code>playerwidth</code>/2, -<code>playery</code>-<code>playerheight</code>/2)</li>
<li>rotate by <code>rotateangle</code></li>
<li>translate by (<code>playerx</code>+<code>playerwidth</code>/2, <code>playery</code>+<code>playerheight</code>/2)</li>
</ul>

<p>The idea is to center your sprite on the origin then rotate around the origin (<code>glRotate</code>) and after you get the rotated sprite you translate it back in its place.</p>

<p>NB: If your sprite is initially ""centered"" around the origin, but with a corner not the actual center of the sprite, you first translate the object to center the sprite's center with the origin. So like if your sprite had the top-left corner in the origin, you'd translate by (-playerwidth/2, -playerheight/2), then rotate then translate by (playerx,playery).</p>
",6
842771,842753,3,"<p>it looks like vec0 isn't initialized by your copy constructor...</p>

<p>Try modifying your copy constructor to:</p>

<pre><code>Structure1::Structure1(const Structure1&amp; structurein)
{
    N = structurein.N;
    vec = new double[N];
    for (int i = 0; i &lt; N; i++)
    {
        vec[i] = structurein.vec[i];
    }
    // ADD THIS LINE
    vec0 = structurein.vec0;
}
</code></pre>
",1
842774,842753,0,"<p>Your copy-constructor Structure1::Structure1(const Structure1 &amp;) doesn't copy vec0. It's not getting initialised at all, so gets whatever is in memory.</p>

<p>Also, you might want to check Structure1's operator=. If you assign a large vector to a small vector, then you'll potentially overflow the array in the destination. You might need to reallocate memory in operator=.</p>
",0
617888,617842,1,"<p>Is it perhaps so that the vector 'v' you return from <code>firstFunc()</code> is allocated on the stack? If so, then that's probably your problem, since you're returning the address of an object that is going out of scope as the function exits.</p>

<p>So fix that, return the vector by value, or create it on the heap using <code>new</code>.</p>
",0
617894,617842,2,"<p>Declare your functions this way:</p>

<pre><code>void firstFunc(vector&lt;myStruct&gt; &amp;v) 
{
...
}

void otherFunc(vector&lt;myStruct&gt; &amp;v) 
{
...
}
</code></pre>

<p>and use them this way</p>

<pre><code>void foo()
{
vector&lt;myStruct&gt; v;
firstFunc(v);
otherFunc(v);
}
</code></pre>
",0
485383,485358,2,"<p>Without more information, it's not easy to say, but what are you inserting? Could it simply be that you run out of memory? Although, I do think normal C++ would throw an exception in that case, are you using any custom allocators, malloc, or arrays on the stack which are overrun perhaps?</p>

<p>Perhaps a snippet of code describing what you do could be helpful in determining the cause of your problem.</p>
",0
485413,485358,1,"<p>It easily happens if you either modify the keys of the elements already in the data structure or if you have a bad compare function, which misleads the search algorithm.</p>

<p>If you can detect which concrete insert operation causes the seg.fault, then try debugging/logging with what values the compare function is called.</p>

<p>Alternatively, you should print the contents of the map before the erroneous insert, the keys will probably not be in order.</p>
",0
485426,485358,5,"<p>Are you inserting using the iterator you called erase() on? Or using that iterator in any way? After erase(p) is called, p is invalidated.</p>
",0
485431,485358,2,"<blockquote>
  <p>could you guess what happened here?</p>
</blockquote>

<p>You're abusing memory in some way.</p>

<p>There are a <strong>lot</strong> of ways to do that, in C++!</p>

<p>Rather than guess, and without reading your code, I suggest run the kind of platform-specific debugger which will detect this problem, for example <code>valgrind</code>.</p>

<p>Your alternative is to make the problem smaller: reproduce the problem in only a few lines of code, which you can then post for people to look at.</p>
",0
485434,485358,1,"<p>The type in question is <code>pair&lt;string, vector&lt;float&gt; &gt;</code>. You will be copying that pair on every insert. If either the string or the vector are big then you could be running out of memory.</p>

<p>Edit: to fix running out of memory, you can change how you insert key-value pairs to:</p>

<pre><code>pair&lt;map::iterator, bool&gt; insert_result= map.insert(make_pair(name, vector&lt;float&gt;());
if (insert.second) { insert_result.first-&gt;second.swap(vector_read_in); }
</code></pre>

<p>That will ensure that you do not copy memory, only move it.</p>
",2
485644,485358,0,"<p>Remember that if you are looping through the map, finding stuff to delete, save off the key for later deletion.  If you delete while iterating, you run the risk of invalidating the iteration loop.</p>

<pre><code>std::map&lt;string, vector&lt;float&gt; &gt;::iterator iter = my_map.begin();
while (iter != my_map.end()) {
  if (somethingBadAboutItem(iter)) {
    my_map.erase(iter);   // this can mess up my_map iteration above 
                          // and cause bad data access later
  }
  ++iter;
}
</code></pre>

<p>instead, try</p>

<pre><code>std::map&lt;string, vector&lt;float&gt; &gt;::iterator iter = my_map.begin();
std::vector&lt;string&gt; keys_to_delete;
while (iter != my_map.end()) {
  if (somethingBadAboutItem(iter)) {
    keys_to_delete.push_back(iter-&gt;first);
  }
  ++iter;
}

for (std::size_t i = 0; i &lt; keys_to_delete.size(); ++i) {
  iter = my_map.find(keys_to_delete[i]);
  my_map.erase(iter);
}
</code></pre>

<p>I am interested if other people have found something more elegant than this, but this is my preferred technique.</p>
",0
485460,485358,0,"<p>please post some code, you cant expect us to debug your problem on guess work alone.</p>

<p>...but ill give it a stab anyway :) Also what compiler, and system are you doing this on?</p>

<p>If you are reading the data in a loop you may run out of stack space which would cause a seg fault.</p>

<p>Ill edit my answer if you post some code.</p>
",0
485689,485358,0,"<p>Bill: Have you tried something like this:</p>

<pre><code>for(std::map&lt;string, vector&lt;float&gt; &gt;::iterator iter = my_map.begin(); iter != my_map.end();) {
    if(somethingBadAboutItem(iter)) {
        my_map.erase(iter++);
    } else {
        ++iter;
    }
}
</code></pre>

<p>The key is to postincrement the iterator when deleting, so it's still valid when incremented but you erase (and hence invalidate) a copy pointing to the previous item.</p>

<p>I'm not sure this technique necessarily works for all STL containers; I can't remember all the invalidation rules offhand (seems unlikely to work for vector for example, but you're normally better off using remove_if for those for non-trivial sizes) but it should be fine for map.</p>
",0
1082398,1082378,9,"<p>Well, apart from your use of <code>reinterpret_cast</code>, it looks ok to me. (I'm not 100% sure on the second one).</p>

<p>The problem with <code>reinterpret_cast</code> is that it makes no guarantees about the result of the cast, only that if you cast the result back to the original type, you get the original value. So there is no guarantee that the result of the cast will contain the same bit pattern, or point to the same address.</p>

<p>As far as I know, a portable solution for casting a pointer x to a type T* is <code>static_cast&lt;T*&gt;(static_cast&lt;void*&gt;(x))</code>, since <code>static_cast</code> to and from <code>void*</code> is guaranteed to turn a pointer to the same address.</p>

<p>But that's only tangentially related to your question. :)</p>
",7
544847,544842,14,"<p>What you would really want is a templated typedef. Unfortunately those are not supported in the current version of C++, but they will be added in C++0x.</p>

<p>For now, here's a possible workaround:</p>

<pre><code>template&lt;class T&gt; struct My {
    typedef std::vector&lt;T&gt; Array;
};

My&lt;Object&gt;::Array ObjectArray
</code></pre>

<p>Whether or not that is better than simply using <code>std::vector</code> directly, I'll leave to you to decide.</p>
",1
547695,544842,5,"<p>Another way:</p>

<pre><code>#include &lt;vector&gt;

template &lt;typename T&gt;
struct MyArray
    :std::vector&lt;T&gt;
{
};

void func()
{
    MyArray&lt;int&gt; my;

    my.push_back(5);

    MyArray&lt;int&gt;::iterator i;
}
</code></pre>

<p>Compiles for me, but you may find that some things
available in vector&lt;> need to be ""pulled up""
into MyArray.</p>
",2
1684439,1684418,15,"<p>Your <code>getA</code> method is returning a temporary <em>copy</em> of <code>a</code>, so your call to <code>setMap</code> is modifying that copy, not the original. One way to fix this would be to have <code>getA</code> return a reference or pointer to <code>a</code></p>
",0
1684446,1684418,0,"<p>Each call to getA() is creating and returning a new temporary object.</p>

<p>So the first call:</p>

<pre><code>b.getA().setMap(mm);
</code></pre>

<p>Creates an A object adds mm into it.<br>
This then goes out of scope and destroys the map.</p>

<p>This line:</p>

<pre><code>cout &lt;&lt; ""Size "" &lt;&lt; b.getA().getMap().size() &lt;&lt; std::endl;
</code></pre>

<p>Creates a completely new A object with its own empty map.<br>
As it is a new object the size of the map is zero.<br>
Once this goes out of scope it is again destroyed.</p>

<p>I think what you meant to do is:</p>

<pre><code>class B
{ 
    A&amp; getA()         // Notice the &amp; just after the A 
    {                 // rather than return an object by value
        return a;     // you want to return a reference to the object inside
    }                 // your B object.
    private:
        A a;  
}
</code></pre>
",0
1684452,1684418,0,"<p>You're returning a copy of an A, not the A object you're modifying.  Try out this code to understand the difference:</p>

<pre><code>int main (int argc, char* argv[])
{
  map&lt;int, string*&gt; mm;
  mm.insert(std::make_pair(1, new string(""abc"")));
  mm.insert(std::make_pair(2, new string(""def"")));

  B b;
  A a = b.getA();
  B bb;
  bb.getA().setMap(mm);
  a.setMap(mm);

  cout &lt;&lt; ""A Size "" &lt;&lt; a.getMap().size() &lt;&lt; std::endl;
  cout &lt;&lt; ""BA Size "" &lt;&lt; bb.getA().getMap().size() &lt;&lt; std::endl;
}
</code></pre>
",0
1684454,1684418,0,"<p>B::getA() is returning an object by value.  Si when you call A::setMap() you are setting the map of the temporary object.</p>

<p>Change the signature of getA() to:</p>

<pre><code>A &amp;getA();
</code></pre>
",0
1684457,1684418,0,"<p>Your method getA currently returns a copy, instead of a reference to, the a member.  Instead, you want to return A&amp; from getA.  This will allow you to return a reference to your member variable instead of a copy of it.</p>
",0
537321,537303,13,"<p>You can use &lt;&lt; if you like.</p>

<pre><code>int hasNukes = 1;
int hasBioWeapons = 1 &lt;&lt; 1;
int hasChemWeapons = 1 &lt;&lt; 2;
</code></pre>
",1
537332,537303,2,"<p>Java doesn't support binary literals either, unfortunately. However, it has <strong><a href=""http://java.sun.com/docs/books/tutorial/java/javaOO/enum.html"" rel=""nofollow noreferrer"">enums</a></strong> which can be used with an <a href=""http://java.sun.com/javase/6/docs/api/java/util/EnumSet.html"" rel=""nofollow noreferrer""><code>EnumSet</code></a>. An <code>EnumSet</code> represents enum values internally with bit fields, and presents a <a href=""http://java.sun.com/javase/6/docs/api/java/util/Set.html"" rel=""nofollow noreferrer""><code>Set</code></a> interface for manipulating these flags.</p>

<p>Alternatively, you could use <strong>bit offsets</strong> (in decimal) when defining your values:</p>

<pre><code>const int HAS_NUKES        = 0x1 &lt;&lt; 0;
const int HAS_BIO_WEAPONS  = 0x1 &lt;&lt; 1;
const int HAS_CHEM_WEAPONS = 0x1 &lt;&lt; 2;
</code></pre>
",1
537337,537303,71,"<p>I'd use a bit shift operator:</p>

<pre><code>const int has_nukes        = 1&lt;&lt;0;
const int has_bio_weapons  = 1&lt;&lt;1;
const int has_chem_weapons = 1&lt;&lt;2;
// ...
int dangerous_mask = has_nukes | has_bio_weapons | has_chem_weapons;
bool is_dangerous = (country-&gt;flags &amp; dangerous_mask) == dangerous_mask;
</code></pre>

<p>It is even better than flood of 0's.</p>
",5
537342,537303,9,"<p><strike><a href=""http://archives.free.net.ph/message/20090115.031436.7fdfe7c5.ca.html"" rel=""nofollow noreferrer"">This discussion</a> may be interesting</strike>... Might have been, as the link is dead unfortunately. It described a template based approach similar to other answers here.</p>

<p>And also there is a thing called <a href=""http://www.boost.org/doc/libs/1_58_0/libs/utility/utility.htm"" rel=""nofollow noreferrer"">BOOST_BINARY</a>.</p>
",2
537346,537303,16,"<p>The C++ Standard Library is your friend: </p>

<pre><code>#include &lt;bitset&gt;

const std::bitset &lt;32&gt; has_nukes( ""00000000000000000000000000000001"" );
</code></pre>
",2
537361,537303,9,"<p>The term you want is <em>binary literals</em></p>

<p><a href=""http://wordaligned.org/articles/binary-literals"" rel=""nofollow noreferrer"">Ruby has them</a> with the syntax you give.</p>

<p>One alternative is to define helper macros to convert for you. I found the following code at <a href=""http://bytes.com/groups/c/219656-literal-binary"" rel=""nofollow noreferrer"">http://bytes.com/groups/c/219656-literal-binary</a></p>

<pre><code>/* Binary constant generator macro
 * By Tom Torfs - donated to the public domain
 */

/* All macro's evaluate to compile-time constants */

/* *** helper macros *** */

/* turn a numeric literal into a hex constant
 * (avoids problems with leading zeroes)
 * 8-bit constants max value 0x11111111, always fits in unsigned long
 */
#define HEX_(n) 0x##n##LU

/* 8-bit conversion function */
#define B8_(x) ((x &amp; 0x0000000FLU) ?   1:0) \
             | ((x &amp; 0x000000F0LU) ?   2:0) \
             | ((x &amp; 0x00000F00LU) ?   4:0) \
             | ((x &amp; 0x0000F000LU) ?   8:0) \
             | ((x &amp; 0x000F0000LU) ?  16:0) \
             | ((x &amp; 0x00F00000LU) ?  32:0) \
             | ((x &amp; 0x0F000000LU) ?  64:0) \
             | ((x &amp; 0xF0000000LU) ? 128:0)

/* *** user macros *** /

/* for upto 8-bit binary constants */
#define B8(d) ((unsigned char) B8_(HEX_(d)))

/* for upto 16-bit binary constants, MSB first */
#define B16(dmsb, dlsb) (((unsigned short) B8(dmsb) &lt;&lt; 8) \
                                         | B8(dlsb))

/* for upto 32-bit binary constants, MSB first */
#define B32(dmsb, db2, db3, dlsb) (((unsigned long) B8(dmsb) &lt;&lt; 24) \
                                 | ((unsigned long) B8( db2) &lt;&lt; 16) \
                                 | ((unsigned long) B8( db3) &lt;&lt;  8) \
                                 |                  B8(dlsb))

/* Sample usage:
 * B8(01010101) = 85
 * B16(10101010,01010101) = 43605
 * B32(10000000,11111111,10101010,01010101) = 2164238933
 */
</code></pre>
",0
537362,537303,1,"<p>One, slightly horrible way you could do it is by generating a .h file with lots of #defines...</p>

<pre><code>#define b00000000 0
#define b00000001 1
#define b00000010 2
#define b00000011 3
#define b00000100 4
</code></pre>

<p>etc.
This might make sense for 8-bit numbers, but probably not for 16-bit or larger.</p>

<p>Alternatively, do this (similar to Zach Scrivena's answer):</p>

<pre><code>#define bit(x) (1&lt;&lt;x)
int HAS_NUKES       = bit(HAS_NUKES_OFFSET);
int HAS_BIO_WEAPONS = bit(HAS_BIO_WEAPONS_OFFSET);
</code></pre>
",2
537407,537303,4,"<p>The next version of C++, C++0x, will introduce <a href=""http://en.wikipedia.org/wiki/C%2B%2B0x#User-defined_literals"" rel=""nofollow noreferrer"">user defined literals</a>. I'm not sure if binary numbers will be part of the standard but at the worst you'll be able to enable it yourself:</p>

<pre><code>int operator """" _B(int i);

assert( 1010_B == 10);
</code></pre>
",0
537919,537303,2,"<p>There's no syntax for literal binary constants in C++ the way there is for hexadecimal and octal.  The closest thing for what it looks like you're trying to do would probably be to learn and use <a href=""http://www.cplusplus.com/reference/stl/bitset/"" rel=""nofollow noreferrer"">bitset</a>.</p>
",0
538343,537303,14,"<p>GCC supports binary constants as an extension since 4.3. See the <a href=""http://gcc.gnu.org/gcc-4.3/changes.html"" rel=""noreferrer"">announcement</a> (look at the section ""New Languages and Language specific improvements"").</p>
",3
538101,537303,37,"<p>By the way, the next C++ version will support user defined literals. They are already included into the working draft. This allows that sort of stuff (let's hope i don't have too many errors in it):</p>

<pre><code>template&lt;char... digits&gt;
constexpr int operator """" _b() {
    return conv2bin&lt;digits...&gt;::value;
}

int main() {
    int const v = 110110110_b;
}
</code></pre>

<p><code>conv2bin</code> would be a template like this:</p>

<pre><code>template&lt;char... digits&gt;
struct conv2bin;

template&lt;char high, char... digits&gt;
struct conv2bin&lt;high, digits...&gt; {
    static_assert(high == '0' || high == '1', ""no bin num!"");
    static int const value = (high - '0') * (1 &lt;&lt; sizeof...(digits)) + 
                             conv2bin&lt;digits...&gt;::value;
};

template&lt;char high&gt;
struct conv2bin&lt;high&gt; {
    static_assert(high == '0' || high == '1', ""no bin num!"");
    static int const value = (high - '0');
};
</code></pre>

<p>Well, what we get are binary literals that evaluate fully at compile time already, because of the ""constexpr"" above. The above uses a hard-coded int return type. I think one could even make it depend on the length of the binary string. It's using the following features, for anyone interested:</p>

<ul>
<li><a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2235.pdf"" rel=""noreferrer"">Generalized Constant Expressions.</a></li>
<li><a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2080.pdf"" rel=""noreferrer"">Variadic Templates</a>. A brief introduction can be found <a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2087.pdf"" rel=""noreferrer"">here</a></li>
<li><a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1720.html"" rel=""noreferrer"">Static Assertions (static_assert)</a></li>
<li><a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2378.pdf"" rel=""noreferrer"">User defined Literals</a></li>
</ul>

<p>Actually, current GCC trunk <a href=""http://gcc.gnu.org/projects/cxx0x.html"" rel=""noreferrer"">already</a> implements variadic templates and static assertions. Let's hope it will support the other two soon. I think C++1x will rock the house. </p>
",10
538132,537303,4,"<p>I write binary literals like this:</p>

<pre><code>const int has_nukes        = 0x0001;
const int has_bio_weapons  = 0x0002;
const int has_chem_weapons = 0x0004;
</code></pre>

<p>It's more compact than your suggested notation, and easier to read.  For example:</p>

<pre><code>const int upper_bit = 0b0001000000000000000;
</code></pre>

<p>versus:</p>

<pre><code>const int upper_bit = 0x04000;
</code></pre>

<p>Did you notice that the binary version wasn't an even multiple of 4 bits?  Did you think it was 0x10000?</p>

<p>With a little practice hex or octal are easier for a human than binary.  And, in my opinion, easier to read that using shift operators.  But I'll concede that my years of assembly language work may bias me on that point.</p>
",1
540121,537303,1,"<p>As an aside:</p>

<p>Especially if you're dealing with a large set, instead of going through the [minor] mental effort of writing a sequence of shift amounts, you can make each constant depend on the previously defined constant:</p>

<pre><code>const int has_nukes        = 1;
const int has_bio_weapons  = has_nukes        &lt;&lt; 1;
const int has_chem_weapons = has_bio_weapons  &lt;&lt; 1;
const int has_nunchuks     = has_chem_weapons &lt;&lt; 1;
// ...
</code></pre>

<p>Looks a bit redundant, but it's less typo-prone. Also, you can simply insert a new constant in the middle without having to touch any other line except the one immediately following it:</p>

<pre><code>const int has_nukes        = 1;
const int has_gravity_gun  = has_nukes        &lt;&lt; 1; // added
const int has_bio_weapons  = has_gravity_gun  &lt;&lt; 1; // changed
const int has_chem_weapons = has_bio_weapons  &lt;&lt; 1; // unaffected from here on
const int has_nunchuks     = has_chem_weapons &lt;&lt; 1;
// ...
</code></pre>

<p>Compare to:</p>

<pre><code>const int has_nukes        = 1 &lt;&lt; 0;
const int has_bio_weapons  = 1 &lt;&lt; 1;
const int has_chem_weapons = 1 &lt;&lt; 2;
const int has_nunchuks     = 1 &lt;&lt; 3;
// ...
const int has_scimatar     = 1 &lt;&lt; 28;
const int has_rapier       = 1 &lt;&lt; 28; // good luck spotting this typo!
const int has_katana       = 1 &lt;&lt; 30;
</code></pre>

<p>And:</p>

<pre><code>const int has_nukes        = 1 &lt;&lt; 0;
const int has_gravity_gun  = 1 &lt;&lt; 1;  // added
const int has_bio_weapons  = 1 &lt;&lt; 2;  // changed
const int has_chem_weapons = 1 &lt;&lt; 3;  // changed
const int has_nunchuks     = 1 &lt;&lt; 4;  // changed
// ...                                // changed all the way
const int has_scimatar     = 1 &lt;&lt; 29; // changed *sigh*
const int has_rapier       = 1 &lt;&lt; 30; // changed *sigh* 
const int has_katana       = 1 &lt;&lt; 31; // changed *sigh*
</code></pre>

<p>As an aside to my aside, it's probably equally hard to spot a typo like this:</p>

<pre><code>const int has_nukes        = 1;
const int has_gravity_gun  = has_nukes        &lt;&lt; 1;
const int has_bio_weapons  = has_gravity_gun  &lt;&lt; 1;
const int has_chem_weapons = has_gravity_gun  &lt;&lt; 1; // oops!
const int has_nunchuks     = has_chem_weapons &lt;&lt; 1;
</code></pre>

<p>So, I think the main advantage of this cascading syntax is when dealing with insertions and deletions of constants.</p>
",0
1576256,1576128,1,"<p><em>If</em> I read the code right as the formatting is somewhat off, the problem is most likely that your stock copy constructor does a shallow copy whereas the assignment operator for the same class makes a deep copy. From reading the rest of the code, I assume you meant to make a deep copy instead of just duplicating the m_name and m_symbol pointers.</p>

<p>I'd also strongly suggest that you use std::string instead of raw char pointers - doing that in the first place would have avoided the issues I describe above. It would've also allowed you to use the compiler generate copy constructor, assignment operator and destructor. Less code is <em>good</em>.</p>
",0
1576376,1576128,1,"<p>Something went wrong with the formatting when you posted your code, so I had to move it to an external editor to read.</p>

<p>The problem is not a memory leak - that would be memory that you failed to reclaim. This is quite the opposite issue. Here, you are trying to reclaim memory that was already freed.</p>

<p>I would bet anything that the failing delete call in the destructor is occuring on an object that was either copied or populated using either the copy constructor or the second overloaded assignment operator. You are performing a shallow copy in those places, resulting in two stock objects referencing exactly the same memory for their mname and msymbol members. Whichever one of the two (or more if you copied many times) is destroyed first will have no problems. Whichever one is destroyed second will fail.</p>

<p>I also make the following observation: your constructor carefully checks symbol and name to see if they actually reference any data. Only then do you proceed to use their values. If they are null, then you assign a value of null to the corresponding members. The first overloaded assignment operator, on the other hand, is copying an instance of stock that for all you know could have null mname or msymbol members. You should treat those values with the same care you did in the constructor and test them before using.</p>
",0
1576770,1576128,0,"<p>The problem is here:</p>

<pre><code>stock&amp; stock::operator=(stock const * const s)
</code></pre>

<p>Look at the logic of this operator and the other assignment operator you declared: you copy <em>m_symbol</em> and <em>m_name</em> differently!</p>

<p>You would be better off defining the assignment operator only once:</p>

<pre><code>stock&amp; stock::operator=(stock const * const s)
{
  return this-&gt;operator=(*s);
}
</code></pre>

<p>Or the other way around if you prefer, but remember that the implementation of this one is off.</p>
",1
1693919,1693908,12,"<p>Well, there's not much here, but the first thing is: make sure you have a declaration for g that's included before f is defined.</p>

<pre><code>void g(int a);
</code></pre>

<p>Otherwise, when you get to f, function f has no idea what function g looks like, and you'll run into trouble. From what you've given so far, that's the best I can say.</p>
",2
1693925,1693908,1,"<p>Your function <code>g()</code> needs to be defined above <code>f()</code></p>
",2
1693928,1693908,0,"<p>There are two things wrong:</p>

<p>1) g is not declared before it is used, so the compiler will compain about that. Assuming you fixed that issue, then the next issue is:</p>

<p>2) f is not returning an int.</p>
",0
1517276,1517232,7,"<p>You can use <a href=""http://www.cplusplus.com/reference/iostream/manipulators/noskipws/"" rel=""nofollow noreferrer""><code>std::noskipws</code></a> to disable the whitespace skipping that <code>std::cin</code> does by default:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;

int main() {
  char c;
  std::cin &gt;&gt; std::noskipws;
  while (std::cin &gt;&gt; c) {
    if (c == ' ')
      std::cout &lt;&lt; ""A space!"" &lt;&lt; std::endl;
  }
  return 0;
}
</code></pre>
",3
1517245,1517232,1,"<p>Use cin.getline to read the line with the space.</p>

<p><a href=""http://www.cplusplus.com/reference/iostream/istream/getline/"" rel=""nofollow noreferrer"">http://www.cplusplus.com/reference/iostream/istream/getline/</a></p>
",1
1517251,1517232,3,"<pre><code>string str;
getline(cin, str); // get the whole line
</code></pre>

<p>If you want to deal with c-strings you could use the mentioned <code>cin.getline(....)</code> which is different from strings <code>getline</code>.</p>
",0
1517252,1517232,3,"<p>Cin breaks on whitespace, of any kind.  If you need to read an entire line, you need to use the get line function:</p>

<pre><code>getline(cin, line);
</code></pre>

<p>Where line is a std::string.  This will still cut off any new lines or carriage returns.</p>

<p>To test the string for spaces examine every character in the string and compare it to the space character "" "".  That is left as an exercise for the reader ;)</p>
",1
885630,885609,1,"<p>It sounds like you might be trying to build a <A HREF=""http://java.sun.com/blueprints/patterns/ServiceLocator.html"" rel=""nofollow noreferrer"">Service Locator</A>.</p>

<p>As a side-comment: I would personally recommend not doing that, because <A HREF=""http://www.youtube.com/watch?v=RlfLCWKxHJ0"" rel=""nofollow noreferrer"">it is going to make testing really, really painful if you ever want to do it</A>.  Constructor injection (Something that you are trying to avoid) will make testing much easier.</p>
",0
885642,885609,0,"<p>Shouldn't you use the refcounted class, so that your reference will be managed until your primary class get destroyed.</p>
",0
885842,885609,0,"<p>You are most likely looking for <code>boost::shared_ptr</code>.</p>
",0
886756,885609,1,"<p>I agree with other comments that you should use <code>boost::shared_ptr</code>.  </p>

<p>However if you don't want the class holding these references to part-control the lifetime of the objects it references you should consider using <code>boost::weak_ptr</code> to hold the references then turn this into a <code>shared_ptr</code> when you want to us it.  This will allow the referenced objects to be deleted before your class, and you will always know if object has been deleted before using it.</p>
",0
886788,885609,0,"<p>Despite all the recommendations that you use boost:;shared_pointer, it is far from obvious from your post that it would be appropriate to do so, as the class appears to have no ownership semantics. An ordinary C++ pointer will do just fine here. </p>

<p>It is difficult at the end of the day to prevent deletion via  smart pointer, as the 
smart pointer must, in some form or other, provide access to the underlying dumb pointer, which of course can always be deleted. For some problems there is no technological solution, and in this case a code review is the best way to detect semantic errors in using the contained pointers.</p>
",0
886815,885609,0,"<p>The object you want to reference could be derived from with something like this. That would prevent you from deleting them.</p>

<p>class T
class NonDeletable : public T
{ 
private: 
void operator delete(void*); 
};</p>
",0
1021169,1021135,0,"<p>Take a look on how iterators are implemented for std::vector class, for example.</p>
",0
1021186,1021135,1,"<p>What is your problem? A nested class behaves the same way as a top-level class, so you may return its objects just as you would have returned any other.</p>
",2
1021206,1021135,0,"<p>I prefer to keep <em>iterators</em> interal to the class and exposing only an interface for iteration.<br>
For example, you can implement a <code>List&lt;&gt;</code> with the methods:</p>

<ul>
<li><code>void prepare_iteration() // reset the internal iterator</code></li>
<li><code>bool step_iteration() // move internal iterator</code></li>
<li><code>DATA_TYPE &amp; read() // return the data by using the iterator</code></li>
<li><code>write( DATA_TYPE &amp; ) // update the data by using the iterator</code></li>
</ul>

<p>In this example the iterator can be a simple node pointer and it's never exposed to the user.
I find this approach much easier and safer than iterator objects.<br>(well the 'safer' part  needs a lot of discussion)</p>

<ol>
<li>The above interface can be implemented as an abstract class.</li>
<li>Your <em>container</em> (or whatever) classes can inherit it and implement it.</li>
</ol>

<p>I know that's not the answer that you are looking for but it's just an alternative idea to design your classes.</p>
",4
878046,878022,4,"<p>If you have 2 different criteria for sorting then you should have 2 different functors.</p>

<p>Give them meaningful names such as:</p>

<p>OrderBySlopes and OrderByXYZ</p>

<p>If the 2 functors use some common code, you can refactor this out. i.e. into a base class</p>
",0
878158,878022,0,"<p>What <a href=""https://stackoverflow.com/questions/878022/several-functors-for-redefining-order-for-sort-function-of-vector/878046#878046"">Glen</a> said.</p>

<p>If you really really insist on having one function do double duty, you can rely on having different parameter types to overload two versions of operator().</p>
",0
881475,878022,0,"<p>Your <code>orderDet::operator()</code> takes three arguments.  The <code>std::sort</code> wants only two to compare two values.</p>

<p>A solution may be to add the edges vector as a member of your functor:</p>

<pre><code>struct orderDet {
    const vector&lt;int&gt;&amp; edges;
    orderDet( const vector&lt;int&gt;&amp; edges ):edges(edges){};

    bool operator()( const vector&lt;int&gt;&amp; v1, const vector&lt;int&gt;&amp; v2 ) const {
       ....
    }
 };
</code></pre>

<p>By the way, if you want people to understand your code when they read it, I rather think you should use a typedef for your inner vector than for the outer one.
Next to that, it's better to define a struct containing a 'first' and 'second' point, than a very generic vector which you use only the first two points of.  It will make your code more readable, too.</p>

<p>Regards.</p>
",1
658105,657964,5,"<p>I'm curious - does function 'f' actually check for this condition? Because if it doesn't, and it tries to use the string, then this is clearly going to crash when you try to use it. </p>

<p>And if 'f' does check the reference for NULL, then why isn't it just using a pointer? Is there some hard and fast rule that you won't use pointers and some knucklehead obeyed the letter of the law without thinking about what it meant?</p>

<p>I'd just like to know...</p>
",1
657968,657964,54,"<p>No. It is undefined behaviour and can lead to code to do anything (including reformatting you hard disk, core dumping or insulting your mother).</p>

<p>If you need to be able to pass NULL, then use pointers. Code that takes a reference can assume it refers to a valid object.</p>

<hr>

<p>Addendum: The C++03 Standard (ISO/IEC 14882, 2<sup>nd</sup> edition 2003) says, in ¡ì8.3.2 ""References"", paragraph 4:</p>

<blockquote>
  <p>A reference shall be initialized to refer to a valid object
  or function. [<em>Note:</em> in particular, a null reference cannot exist in a well-defined program, because the <strong>only
  way to create such a reference would be to bind it to the ¡°object¡± obtained by dereferencing a null pointer,
  which causes undefined behavior.</strong> As described in 9.6, a reference cannot be bound directly to a bit-field. ]</p>
</blockquote>

<p>[Bold added for emphasis]</p>
",0
658068,657964,3,"<blockquote>
  <p>Is using NULL references OK?</p>
</blockquote>

<p>No, unless you do not like your boss and your job ;)</p>

<p>This is something VERY bad. One of most important point of reference that it
can't be NULL (unless you force it)</p>
",0
659239,657964,3,"<p>for the case you can make ""empty object"", which will play the role of the zero pointer</p>

<pre><code>class Foo
{
static Foo empty;
public:
  static bool isEmpty( const Foo&amp; ref )
  {
    return &amp;ref==&amp;empty;
  }
}
</code></pre>
",0
1920079,1919849,0,"<p>Anything returning any value like any function call can be done inside if but you can not declare variables in that, really silly.</p>

<p>This can be done as printf will return some value and if will check that return value for condition</p>

<pre><code> if(printf(""Hello""))
</code></pre>

<p>but not this </p>

<pre><code>if(std::string str)
</code></pre>
",2
1920106,1919849,3,"<p>As this is C++ <code>main</code> must have a return type in it's declaration. The actual error that you are getting seems to indicate that you need to <code>#include &lt;sstream&gt;</code> at some point.</p>

<p>While you can declare a variable inside an if's condition expression it's not a feature that's used very often and the one object that's constructed must have an valid implicit conversion sequence to a <code>bool</code>. You can't use a <code>,</code> to attempt to declare two variables, it's not a valid expression for an <code>if</code> clause.</p>

<p>If construction of any object fails then an exception will have to have been thrown so this isn't a necessary or correct way to test for construction failure. You should probably just declare your variables in the function scope of <code>main</code>.</p>
",2
1922938,1919849,0,"<p>The only valid pattern is:</p>

<pre><code>Base* b = ...;
if (Derived* d = dynamic_cast&lt;Derived*&gt;(b)) {
  d-&gt;stuff();
}
</code></pre>
",0
995295,995281,0,"<p>There seems to be nothing obviously wrong with the code you have posted. How are you creating the QSweep object? Can you narrow down the code you have to a simple example and post that?</p>
",0
995300,995281,1,"<p>It's nothing to do with the code you have posted. The problem must lie elsewhere. Do you do any dynamic memory allocation? If so, it is probably screwed up, and use of the vector (which also does dynamic allocation) is merely exposing the problem.</p>

<p>As your code uses lots of vectors, another possible problem by be out-of-bounds access using vector's operator. These are not checked and can be hard to track down. The only thing I can suggest is code inspection and judicious use of the vector's at() access function, which will throw an error on bounds violation.</p>

<p>Depending on your platform, you may also want to consider using memory debugging tools such as Valgrind.</p>

<p><strong>Edit:</strong> Your vector of pointers to double seems very suspicious to me - there aren't may cases where such a data structure is good soluition. I'd take a close look at how that is being used.</p>
",0
995313,995281,0,"<p>As others indicated there is nothing wrong with this piece of code. Only thing I can think of is since you are changing the size of the class (by adding an additional member variable) you need to build all the binaries (if there are multiple binaries) which are dependent on this. Otherwise, there will be inconsistency between the size of the object created.</p>
",2
995406,995281,1,"<p>As it is not possible for us to determine the cause by looking at the code at this stage, you should start working with a debugger on it. I personally recommend <code>valgrind</code>. It is very good at often finding the cause earlier than when the segfault actually occurs.</p>
",0
995736,995281,0,"<p>Does QSweep's 2-parameter constructor call functions in its initialiser list, e.g.</p>

<pre><code>QSweep(const MxDouble2d&amp; myPoints, const MxInt2d&amp; myEdges)
:   sweepEvents(MemberFunctionCall())
...
</code></pre>

<p>That's something that is dependent on the declaration order of the class members, and so might cause your problem. The member function might call the member vector before it has been constructed.</p>
",0
958526,943267,-1,"<p>That is absolutely a valid use of unions in C++.  Depending on what you want to do, you can change your class to a union so you don't have nesting.  Unions can have methods and use inheritance.  If that is not possible (there are other data members) then you might want to use an anonymous union like this:</p>

<pre><code>class Color
{
private:
   union
   {
       unsigned int intValue;
       unsigned char argbBytes[4];
   };
public:
    unsigned int GetIntValue() { return intValue; }
};
</code></pre>
",3
1303991,1303908,2,"<p>Given the code above, the allocation would read:</p>

<pre><code>node* new_node = new node(winery);
</code></pre>

<p>then it's a matter of correctly inserting <code>new_node</code> into your two lists (name and rating) by iterating each separately and setting the pointers correctly.</p>
",7
1304016,1303908,2,"<p>I'm a little confused by this question. Why do you need to default construct a node? Use the supplied constructor that takes a winery. Like fbereton suggested in his answer.</p>

<pre><code>node* aNode = new node(aWinery);
</code></pre>

<p>You need to use a node pointer (<code>node*</code>) not a node reference (<code>node&amp;</code>) since you are going to be explicitly managing the memory in the list data structure. Also, it is not a good idea to set the head pointers to NULL at the beginning of the insert function</p>

<pre><code> headByName   = NULL;
 headByRating = NULL;
</code></pre>

<p>You want to do that in the constructor. Otherwise, you lose the nodes in your list every time you insert.</p>

<p>But on to the error you are describing. It would really help if you post the error you are getting, but it sounds like the node(const winery&amp;) constructor is not defined anywhere and the linker wants you to define it. It sounds like you think you are not allowed to define that constructor because the homework instructions mandate that you use the node as defined.  However, I think that the instructions probably mean that you only need to use the given header definition of the node struct. That is, you are given the specifications for node, but you need to implement the details yourself.</p>

<p>One of these details is the constructor implementation. You don't need to modify the header to define the constructor. In one of your .cpp files (list.cpp, main.cpp, winery.cpp, it doesn't matter which) Define the following function</p>

<pre><code>list::node::node(const winery&amp; aWinery)
{
    item = aWinery;
    nextByName = NULL;
    nextByRating = NULL;
}
</code></pre>

<p>Now the constructor is defined and that should resolve the link error. As a side note, a lot of your functions have this argument signature: <code>const winery&amp; winery</code>. Now I don't know exactly what the C++ standard has to say about this, but I'd guess it is illegal to have a variable and a type with the same name. Even if your compiler lets you do it, it is confusing.</p>
",0
1304190,1303908,0,"<p>To specify winery such that a default constructor is not necessary:</p>

<p><strong>Option 1</strong>: Specify default values for each parameter in its constructor:</p>

<pre><code>winery(const char * const name = """",
       const char * const location = """", 
       const int acrces = -1,
       const int rating = -1);
</code></pre>

<p>Note that if you go this route you'll have to add support code to check and make sure your <code>winery</code>'s data is valid.</p>

<p><strong>Option 2</strong>: The other option to take is to eliminate the case that requires the default constructor. To find it/them, put the default constructor in the <code>private</code> space of the winery struct, and see where the compiler emits an error. Those instances of <code>winery</code> will need valid initial constructor data.</p>
",1
1394144,1394132,1,"<p>Yep, I've meet the same problem. I found only one solution:</p>

<pre><code>#ifdef min
#undef min
#endif //min
</code></pre>

<p>Place it right after includes have done.</p>
",1
1394199,1394132,29,"<p>The only really general solution is to <strong>not include windows.h in your headers</strong>.</p>

<p>That header is a killer, and does pretty much anything it can to make your code blow up. It won't compile without MSVC language extensions enabled, and it is the worst example of macro abuse I've ever seen.</p>

<p>Include it in a single .cpp file, and then expose wrappers in a header, which the rest of your code can use. If windows.h isn't visible, it can't conflict with your names.</p>

<p>For the min/max case specifically, you can <code>#define NOMINMAX</code> before including windows.h. It will then not define those specific macros.</p>
",7
1394361,1394132,2,"<p>In addition to jalf's answer, you could also <code>#define WINDOWS_LEAN_AND_MEAN</code> before including windows.h. It will get rid off min, max and some more noise from windows headers. </p>
",1
1581567,1581539,7,"<p>You can use std::getline from &lt;string&gt; to read whole lines and use a std::stringstream, from &lt;sstream&gt; to parse the lines.</p>
",0
1582373,1581539,0,"<pre><code>int array[42];
int* ptr = array;
for (string line; getline(cin, line); ) {
    istringstream stream(line);
    stream &gt;&gt; *ptr++;
}
</code></pre>

<p>Error checking elided.</p>
",0
1582084,1581539,0,"<p>though you mention c++ here is something that i often use to read in an array of doubles from a file </p>

<pre><code> char line[512+1];

  unsigned int row = 0 ;
  unsigned int col = 0 ;

  while( fgets(line, sizeof(line), file) )
    {
      col = 0 ;
      tempChr = strtok(line, delimters);

      // ignore blank lines and new lines
      if ( tempChr[0] == '\n' )
    {
      continue ;
    }

      tempDbl = atof(tempChr);

      data[row*numCols+col] = tempDbl ;


      for(col = 1 ; col &lt; numCols ; ++col)
    {
      tempDbl = atof(strtok(NULL, delimters));
      data[row*numCols+col] = tempDbl;
    }

      row = row + 1;
      if( row == numRows )
    {
      break ;
    }
    }
</code></pre>
",0
1582500,1581539,0,"<p>The istream extraction operator will automatically skip the blank lines in the input, so the read_ints() function in the below example will return a vector of the whitespace (including the newlines) separated values in the input stream.</p>

<pre><code>#include &lt;vector&gt;
#include &lt;iostream&gt;

using namespace std;

vector&lt;int&gt;
read_ints(istream &amp; is)
{
    vector&lt;int&gt; results;
    int value;
    while ( is &gt;&gt; value )
    {
        results.push_back(value);
    }
    return results;
}

int
main(int argc, char * argv[])
{
    vector&lt;int&gt; results = read_ints(cin);
    for ( vector&lt;int&gt;::const_iterator it = results.begin(); it != results.end(); ++it )
        cout &lt;&lt; *it &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>The above code stops reading if any of the input cannot be parsed as an int and allows integers to be separated by spaces as well as newlines, so may not exactly match the requirements of the question.</p>
",0
378845,359276,0,"<p>Looks like this had nothing to do with static initialization after all - after a lot of logging we found out some unrelated code was destroying the pointer, apparently.</p>
",0
359388,359276,1,"<p>The linker is allowed to drop a compilation unit completely if it thinks that it contains no reachable code. So if none of the functions in your .cpp file is explicitly called from elsewhere, it may get discarded entirely, and the object that should have been registered is simply missing from your executable.</p>

<p>Try to put a dummy external function in the .cpp of the missing puzzle and call it from your main() to see if it solves your problem.</p>
",10
359297,359276,2,"<p>This is probably a <a href=""http://www.parashift.com/c++-faq-lite/ctors.html#faq-10.12"" rel=""nofollow noreferrer"">static initialization</a> order issue.  Try rewriting it as ""<a href=""http://www.parashift.com/c++-faq-lite/ctors.html#faq-10.13"" rel=""nofollow noreferrer"">construct on first use</a>"".</p>
",1
1315285,1315263,2,"<p>I think that problem is here:</p>

<pre><code>headByName-&gt;nextByName     = next_node;
headByRating-&gt;nextByRating = next_node;
</code></pre>

<p>You're always override second node. As I understand you should find last one by iterating through whole list and insert after last node.</p>
",0
1315287,1315263,1,"<p>Well the primary issue is that when you insert a node you ALWAYS set </p>

<pre><code>headByName-&gt;nextByName     = next_node;
headByRating-&gt;nextByRating = next_node;
</code></pre>

<p>So the second node gets filled appropriately.  Then the third comes along and ovrwrites the second node and the second node disappears into oblivion.</p>
",0
1315338,1315263,0,"<p>Your constructor is not related but the first thing that sticks out is this error in assignment logic:</p>

<pre><code>headByName-&gt;nextByName     = next_node;
headByRating-&gt;nextByRating = next_node;
</code></pre>

<p>Here you're always setting the next node of the head node (the 2nd node) to whatever the new node is. That's why the second node in the list is always the newest one.</p>

<p>If you wish to add items onto the end of the list, you should keep a tail pointer that points to last item inserted, starting from the head item.</p>

<p>With that your assignment would instead be:</p>

<pre><code>tail_pointer-&gt;nextByName = current_node;
tail_pointer-&gt;nextByRating = current_node;

tail_pointer = current_node;
</code></pre>

<p>Secondly, the do/while loop is unnecessary. <code>headByName</code> and <code>headByRating</code> will always be set to point to the newly allocated node <code>current_node</code>, meaning that </p>

<pre><code>while ( headByName == NULL || headByRating )
</code></pre>

<p>will always break out of the loop (provided that you aren't running out of memory of course). </p>

<p>You are always assigning both variables by using lazy initialization in the first if block in list::insert.</p>

<p>Linked List inserts are constant time, O(1), because you don't have to iterate anything in a loop - you always know exactly where to operate on: <code>tail_pointer</code>.</p>

<p>Also, this:</p>

<pre><code>next_node    = NULL;
current_node = NULL;
</code></pre>

<p>is good style in my opinion, but don't forget that you are not actually deallocating the data with this, in case that was your intention :-)</p>

<p>Keep a tail pointer that always points to the newest item!</p>
",0
1413616,1413486,0,"<p>Do something fun and don't worry too much about code style yet. I started out with BASIC on Commodore 64 without even realizing that there was such a thing as clean code vs dirty code. If I had worried a lot about that then, it might have hindered me from progressing. You always learn best when doing it playfully.</p>
",4
1413495,1413486,14,"<p>Look to the open source community.  There are plenty of existing and new projects that would love an eager (if inexperienced) developer to offer support.</p>

<p>Going this route offers two advantages:</p>

<ol>
<li>You get to see great code in action and learn from it</li>
<li>Any changes you submit will be reviewed by an experienced developer and they will often give you excellent suggestions as to how to improve your code before it will be accepted</li>
</ol>

<p>Start by choosing a project in your language (there are a bunch in c++) and check out the code.  You don't need to understand it all, but you must be able to understand at least a portion of it.</p>

<p>If the project looks way to complicated, keep looking.  Younger projects tend to have less code that you need to learn.</p>
",0
1413496,1413486,9,"<p>Why don't you try <a href=""http://refactormycode.com/"" rel=""nofollow noreferrer"">RefactorMyCode</a>?</p>
",1
1413523,1413486,9,"<p>If you can't get great programmers to look at your code, do the next best thing:  look at theirs!</p>

<p>Look for a bunch of code snippets that do the same (simple) thing.  Before you look at them too closely, write your own code to perform the same task.  Compare all of the snippets with your own (and each other!) and try to figure out the reasons for the differences.</p>

<p>I recommend looking for code from well established projects.  Code from tutorials often ignores important details for the sake of simplicity.</p>
",0
1413529,1413486,4,"<p>I think the best way to learn is the way I learned (I may be biased): trial and error.  I just wrote programs all the time, teaching myself as I went.  I'd write terrible code, and I would wrestle with making it do what I wanted.  Often it would make me give up on that particular project.  But on the next project, I'd take a different approach, and it would work better.  Repeat ad nauseam.  Once you know where the rough spots are in your designs, you'll be able to ask specific questions on places like SO, or, better yet IMHO, come up with better designs yourself.  I independently invented all the major design patterns just through frustration at the solutions I'd created in the past.  I think this gives me a valuable perspective, since for most people design patterns are just a ""best practice"", but I know the pain that comes with using other designs, and I can see signs of bad designs in code very easily (it takes one to know one).  This last skill is one that I often see lacking in other programmers... they can't see why their design is deficient and they should use something else.</p>
",0
1413555,1413486,5,"<p>I would try not to write useless code, but attempt to solve some particular problem. Your learning will be more advanced if you are learning in the context of a real-world scenario. It doesn't have to be a big business domain; could even be a game or a shareware utility.</p>

<p>As for getting your code reviewed, the open source community is a good way to go as <a href=""https://stackoverflow.com/users/65843/the-lame-duck"">The Lame Duck</a> says - in fact you're guaranteed it gets some form of review if you actually contribute to a project. Other avenues to explore: your local C++ users' group, checking out a co-op program available through a junior college, or engaging someone in a company that sponsors interns.</p>

<p>I haven't tried sites such as <a href=""http://refactormycode.com/"" rel=""nofollow noreferrer"">RefactorMyCode</a> as suggested by <a href=""https://stackoverflow.com/users/11515/gilad-naor"">Gilad Naor</a>, but that seems promising. And, yes, <a href=""http://stackoverflow.com"">StackOverflow</a> is a good place for bite-sized chunks of code. If you do that, explain what you are trying to do, and why you are trying to do it that way, and ask if there's a better approach. Good luck!</p>
",0
1417099,1413486,1,"<p>You could always try a site like <a href=""http://projecteuler.net/"" rel=""nofollow noreferrer"">Project Euler</a>, where there are a whole load of problems that will test your skills and a whole bunch of solutions to those problems, submitted by others. Project Euler tends to focus on algorithms rather than higher level programming constructs, but I imagine that there are others in a similar vein.</p>
",0
1424496,1424169,0,"<p>Check out <a href=""http://www.topcoder.com"" rel=""nofollow noreferrer"">http://www.topcoder.com</a>.  This is an amazing tool for practicing programming in many different languages (C++, Java, C, C#).  You can even win money if you get good at it:)</p>
",0
1424631,1424169,0,"<p>As with anything, write many programs, (re)read the best books (such as Effective C++, already mentioned). :-)</p>

<p>And <a href=""http://github.com/jwiegley/ledger"" rel=""nofollow noreferrer"">ledger</a> is an open source finance program written in C++.  (<a href=""http://www.gnucash.org/"" rel=""nofollow noreferrer"">GnuCash</a> is another but written in C.)</p>
",1
1424742,1424169,0,"<p>Most of KDE is written in C++, albeit with Qt's signal extensions.  Probably lots of examples of good code there.</p>
",1
1424176,1424169,16,"<p>I was facing a similiar situation a while back, and my conclusion was - no matter how many smart books you read nothing will suit you better then practicing. </p>

<p>Find some tutorials or set yourself some simple goals and learn by doing.</p>

<p>Hope that helps</p>

<p>PS. A friend of mine asked me once ""How do you eat an elefant? - in small pieces, one at a time""</p>
",0
1424190,1424169,2,"<p>I'd start in on a real project.</p>

<p>If nothing else, download an open source C++ project that's in the same realm as the jobs you want to target, and start modifying.  Practice helps more than anything for being comfortable.</p>

<p>If you're going to focus on reading, or in addition to practice, I'd actually focus on reading books that work more on using C++ well, not necessarily learning C++.  <a href=""https://rads.stackoverflow.com/amzn/click/com/0201924889"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">Effective C++</a>, <a href=""https://rads.stackoverflow.com/amzn/click/com/020163371X"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">More Effective C++</a>, and <a href=""https://rads.stackoverflow.com/amzn/click/com/0201749629"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">Effective STL</a> are great for this - you'll learn new things while refreshing your old knowledge.  You can always use the primer book as a reference to study things you've forgotten as you read about them elsewhere.</p>
",2
1424198,1424169,0,"<p>Pick something that you know very little about and attempt to make a program that works with that subject area.  For example if you've never done GUI work fire up C++ and try to create a simple paint program in the GUI framework of your choice (Qt, WTL, whatever).  Or if you've never worked with a database grab SQLite and create a little app that manages your time.  Or better yet, combine all these areas into a larger program.</p>

<p>The key is to force yourself to learn how to do real, practical things and solve problems using the languages paradigms.  Books are great to reinforce certain practices but they'll never replace hours of frustration trying to figure out why your pointers aren't pointing where they're supposed to.  </p>
",0
1424277,1424169,0,"<p>If you are good at maths (or statistics, probability, finance, geometry)  and want to recall how to build re-useable functions, classes, and templates, you are welcome to help us at <a href=""http://sourceforge.net/projects/mathlibcpp/"" rel=""nofollow noreferrer"">mathlibcpp</a>. I recommend it, its good learning. Building a complete library on a large subject is very educatively hard ;) I found a chance to use all OO methods I know in C++, even forced to learn more.</p>
",0
1424370,1424169,0,"<p>Regarding Fix, there is <a href=""http://code.google.com/p/quickfast/"" rel=""nofollow noreferrer"">QuickFAST</a>, a very efficient implementation of the 'Fix for streaming' protocol. </p>

<p>Regarding C++, I would look for something that uses Boost, as it seems to be a premiere library for C++ (QuickFAST uses it to some degree).</p>
",0
1991154,1991147,1,"<p>Calling a virtual function won't call the overriding functions in the derived classes. Calling a pure virtual function in a constructor or destructor is <strong>Undefined behavior</strong>.</p>

<p>You might be interested in reading <a href=""http://www.artima.com/cppsource/nevercall.html"" rel=""nofollow noreferrer"">this</a> and <a href=""http://www.parashift.com/c++-faq-lite/strange-inheritance.html#faq-23.5"" rel=""nofollow noreferrer"">this.</a></p>
",0
1991156,1991147,1,"<p>At construction time, when the <code>Sample_Base</code> constructor is called, the object is not fully constructed yet. Specifically the parts belonging to <code>Sample_Derived</code> are not yet created calls to virtual functions that would be overwritten by <code>Sample_Derived</code> will not call the implementation in <code>Sample_Derived</code>, but the version defined in <code>Sample_Base</code>. And since the function has no implementation there you get an error.</p>

<p>For more information and possible workarounds also see <a href=""http://www.parashift.com/c++-faq-lite/strange-inheritance.html#faq-23.5"" rel=""nofollow noreferrer"">this entry in the C++ FAQ Lite</a>.</p>
",5
1991218,1991147,4,"<p>Providing a definition for a pure virtual function is not necessarily meaningless. Marking a virtual function pure means that the enclosing class is abstract and that any class that derives from it is abstract unless the final override for that function is not a pure virtual function. A pure virtual function can still be called via an explicit non-virtual call.</p>

<p>In the body of a base class constructor (but not from a <em>ctor-initializer</em>) the version of a virtual function called through a virtual call is one defined in the class itself or one of its bases and not of any class overriding it (which would not yet have been constructed). This is specified explicitly in 12.7 [class.cdtor]/3.</p>

<p>It is legal to call a pure virtual function explicitly in a constructor body (i.e. using an explicit class qualifier) - although this would required the function to have a body defined - but it is undefined behaviour to call a pure virtual function via a virtual call which is only possible from the constructor or destructor of an abstract class. This is specified explicitly in 10.4 [class.abstract]/6.</p>
",0
1991220,1991147,7,"<p>When you call the function directly, since you are in the constructor, the compiler resolves the static type of your object (<code>Sample_Base</code>) and calls <code>Sample_Base::fun()</code> directly.  Since you provided an implementation for it, the compiler finds the function and it works.</p>

<p>When you call it indirectly, through <code>bar()</code>, the compiler must use the dynamic type, so it does a virtual call that gets resolved at runtime.  And there it fails, because it calls a pure virtual function.</p>

<p>So the difference is in the moment it binds the function to the call.</p>
",2
1992385,1991147,1,"<p>This behavior is not undefined, it's explicitly defined: virtual functions are not virtual in constructors and destructors. They call the static version of the function. If the function is pure virtual, this results in the famous ""pure virtual call"" error in VC.</p>

<p>I've seen an amusing variation of this in a multithreaded program: an object is being destructed on thread A, while thread B is attempting to call a virtual function. There was no virtual function call in the constructor or destructor, but we still got hit with a pure virtual call error.</p>
",0
818657,818647,0,"<p>The net is chock-full of open-source C++ code.  Why not pick a few such projects, and, even better, start helping out of them?  No better way of learning than by doing!</p>
",1
818659,818647,4,"<p>I think your two best bets for finding C++ code are to go to the popuplar open source repositories.</p>

<ul>
<li>CodePlex: <a href=""http://codeplex.com"" rel=""nofollow noreferrer"">http://codeplex.com</a></li>
<li>Google Code: <a href=""http://code.google.com"" rel=""nofollow noreferrer"">http://code.google.com</a></li>
<li>SourceForge: <a href=""http://sourceforge.net/"" rel=""nofollow noreferrer"">http://sourceforge.net/</a></li>
</ul>

<p>These all have high quality C++ projects you can take a look at.  I don't think there's a great metric for judging quality on a large scale.  I would start with the more popular projects which may be more likely to have quality code.  </p>
",0
818660,818647,0,"<p>I would recommend getting a good book, which will be packed full of source code examples!</p>

<p><a href=""http://product.half.ebay.com/C-in-a-Nutshell_W0QQprZ2430159QQtgZinfo"" rel=""nofollow noreferrer"">C++ in a Nutshell</a></p>

<p>You can also search open source code at <a href=""http://www.koders.com"" rel=""nofollow noreferrer"">www.koders.com</a></p>
",1
818664,818647,5,"<p>I would recommend <a href=""http://www.boost.org/"" rel=""nofollow noreferrer"" title=""Boost"">Boost</a>.  Using Boost will simplify your program design.  Reading Boost source code can show you how to use C++ to solve some challenging problems in a concise way.</p>

<p>This add on library is itself written in C++, in a peer-reviewed fashion, and has a high standard of quality.</p>
",4
818672,818647,-1,"<p>C++ is a great language, but kind of heavy as a first language.  Try <a href=""http://wiki.python.org/moin/BeginnersGuide"" rel=""nofollow noreferrer"">python</a>.</p>

<blockquote>
  <p>1) Where can I find source code </p>
</blockquote>

<p>Reading code is harder than writing it.  This is especially true of large, complex languages like C++.  Without already knowing the intricacies of the language, you don't stand much chance of getting knowledge from the complex code others write in production.  You're going to have to learn the very smallest parts first, on your own by writing it.  As you learn c++, you will also learn programming.</p>

<blockquote>
  <p>2) What is a good litmus test on code's quality</p>
</blockquote>

<p>There isn't one.  That's not going to be an easy thing to learn, either.  It comes from experience.  But really, the way you know the good code from the bad, is that after you've had some time to familiarize yourself with the layout of a project, you can understand what any given piece does, after you look at it.  Readable code has quality, whereas confusing code falls short.</p>

<p>Looking at other peoples code is a hard way to learn the basics.  Find a <a href=""http://www.cplusplus.com/doc/tutorial/"" rel=""nofollow noreferrer"">tutorial</a> on the net and get your feet wet that way.  I'm sure there are many, fine <a href=""https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list"">printed books</a> on the subject as well.</p>

<p>As you go, and get stuck or confused or lost, post questions <a href=""https://stackoverflow.com/"">here</a>.</p>
",2
818706,818647,0,"<p>I think you got some good answers already, I would like to add this suggestions for picking a project from one of the open source project repositories: Pick a widely used but preferably smaller project that has been around for a while and targets a domain that you are specifically interested in. That way you will be able to get a better idea of production ready code and be able to learn something about that domain.</p>
",0
818718,818647,1,"<p>The List:</p>

<ul>
<li>SourceForge: <a href=""http://sourceforge.net/"" rel=""nofollow noreferrer"">http://sourceforge.net/</a></li>
<li>Boost: <a href=""http://www.boost.org/"" rel=""nofollow noreferrer"">http://www.boost.org/</a></li>
<li>CodePlex: <a href=""http://www.codeplex.com/"" rel=""nofollow noreferrer"">http://www.codeplex.com/</a></li>
<li>Google Code: <a href=""http://code.google.com/"" rel=""nofollow noreferrer"">http://code.google.com/</a></li>
<li>Google Code University:  <a href=""http://code.google.com/edu/"" rel=""nofollow noreferrer"">http://code.google.com/edu/</a></li>
<li>koders.com: <a href=""http://www.koders.com/"" rel=""nofollow noreferrer"">http://www.koders.com/</a></li>
</ul>
",0
819033,818647,0,"<p>I found the source code and documentation of <a href=""http://pocoproject.org/blog/?p=219"" rel=""nofollow noreferrer"">POCO</a> are quite readable, and </p>

<ol>
<li>unlike some other open source projects that focus on handling one specific problem, say GUI or Logging, this library focuses on developing a complete application, thus covering a quite broad area(file system, text processing, networking, logging etc ).  </li>
<li>it uses modern C++ idioms. So by reading the implementation you can learn modern C++ skills as well. </li>
</ol>
",0
773604,773599,32,"<p>You need to use the new keyword instead to create new Foo on the heap.<br>
The object on the stack will be freed when the function ends, so you are returning a pointer to an invalid place in memory.</p>

<p>Here is the correct code. </p>

<pre><code>Foo * ReturnFooPointer()
{
  Foo * foo_ptr = new Foo();
  return foo_ptr;
}
</code></pre>

<p>Remember later to delete the pointer you are returning.</p>

<p>So later in code: </p>

<pre><code>Foo *pFoo = ReturnFooPointer();
//Use pFoo
//...
delete pFoo;
</code></pre>
",1
773606,773599,6,"<p>You're returning a pointer to a local object on the stack.  It goes out of scope the moment your function returns, and is invalid.</p>

<p>You should create a new instance to return, i.e.,</p>

<pre><code>Foo* foo_ptr = new Foo();
</code></pre>

<p>This will create an object in the heap and will live until you call <code>delete</code> on it.</p>
",0
773609,773599,2,"<p>the actual object is allocated on the stack so it is destroyed when it goes out of scope (when the function returns). If you allocate it on the heap (with <code>new</code>), it will be alive until you <code>delete</code> it</p>
",0
1496923,1493581,1,"<p>If you want to determine if it's ""any good"" you will need to compare your rasterizer with other rasterizers. ""30 fps with 1 light"" might be <em>extremely</em> good, if no-one else has ever managed to go beyond, say, 10 fps.</p>
",0
1504635,1493581,3,"<p>What do you want to measure? I suggest fillrate and triangle rate. Basically fillrate is how many pixels your rasterizer can spit out each second, Triangle rate is how many triangles your rasterizer + affine transformation functions can push out each second, independent of the fillrate. Here's my suggestion for measuring both:</p>

<p>To measure the fillrate without getting <em>noise</em> from the time used for the triangle setup, use only two triangles, which forms a quad. Start with a small size, and then increase it with a small interval. You should eventually find an <em>optimal size</em> with respect to the render time of one second. If you don't, you can perform blending, with full-screen triangle pairs, which is a pretty slow operation, and which only burns fillrate. The fillrate becomes <em>width x height</em> of your rendered triangle. For example, <em>4 megapixels / second</em>.</p>

<p>To measure the triangle rate, do the same thing; only for triangles this time. Start with two tiny triangles, and increase the <em>number</em> of triangles until the rendering time reaches one second. The time used by the triangle/transformation setup is much more apparent in small triangles than the time used to fill it. The units is <em>triangle count/second</em>.</p>

<p>Also, the overall time used to render a frame might be comparable too. The render time for a frame is the derivative of the global time, i.e <em>delta time</em>. The reciprocal of the delta time is the number of <em>frames per second</em>, if that delta time was constant for all frames.</p>

<p>Of course, for these numbers to be half-way comparable across rasterizers, you have to use the same techniques and features. Comparing numbers from a rasterizer which uses per-pixel lighting against another which uses flat-shading doesn't make much sense. Resolution and color depth should also be equal.</p>

<p>As for optimization, getting a proper profiler should do the trick. GCC has the GNU profiler gprof. If you want an opinion on clever things to optimize in a rasterizer, ask that as a seperate question. I'll answer to the best of my ability.</p>
",0
1035015,1034957,1,"<p>Look into lex &amp; yacc for easier and more elegant way to implement this.</p>
",2
1035044,1034957,0,"<p>One thing you can do is have the functions return bools instead of strings and pass in references to strings as parameters to the function calls. This would at least enable you to check the return values of the functions.</p>
",0
1035072,1034957,1,"<p>Parsing natural languages is a really hard task. Especially to do it completely from scratch.</p>

<p>You may consider using existing libraries, like <a href=""http://www.abisource.com/projects/link-grammar/"" rel=""nofollow noreferrer"">Link Grammar Parser</a> (C, custom GPL-compatible free software license which seems a lot like BSD to me, has bindings to many languages) or <a href=""http://opencog.org/wiki/RelEx"" rel=""nofollow noreferrer"">RelEx</a> (Java, Apache License).</p>

<p><strong>Add:</strong> Found some <a href=""http://www.agfl.cs.ru.nl/"" rel=""nofollow noreferrer"">AGFL</a> <a href=""http://lands.let.kun.nl/TSpublic/dreumel/formal_grammar_english.en.html"" rel=""nofollow noreferrer"">grammar for English</a>.</p>
",0
1035075,1034957,0,"<p>I've done it with <a href=""http://www.nltk.org/"" rel=""nofollow noreferrer"">NLTK</a></p>

<p>It is very powerful but uses Python instead of C++. A lot of chatbots are coded with this toolkit, you can also try them out</p>
",0
701664,701648,0,"<p>Assuming you are on Windows and using Visual Studio, you could use <a href=""http://msdn.microsoft.com/en-us/library/ms763742.aspx"" rel=""nofollow noreferrer"">MSXML</a> or other 3rd party libraries.</p>
",0
701668,701648,0,"<p>behold a hack...</p>

<pre><code>cout &lt;&lt; ""&lt;point name=\""intersectPoints\"" size=\""4\"" color=\""rgb\""&gt;""&lt;&lt;endl;
cout &lt;&lt; ""  ""&lt;&lt;-2.68&lt;&lt;"" ""&lt;&lt;1.82&lt;&lt;"" ""&lt;&lt;0.0&lt;&lt;"" ""&lt;&lt;255&lt;&lt;"" ""&lt;&lt;0&lt;&lt;"" ""&lt;&lt;0&lt;&lt;"""";
</code></pre>

<p>that's how i write xml files with little overhead just save to the file the raw xml.</p>
",4
701670,701648,5,"<p>Check out <a href=""http://sourceforge.net/projects/tinyxml"" rel=""nofollow noreferrer"">TinyXml</a>. It's extremely lightweight. From the documentation:</p>

<blockquote>
  <p>TinyXML uses a Document Object Model (DOM), meaning the XML data is parsed into a C++ objects that can be browsed and manipulated, and then written to disk or another output stream. You can also construct an XML document from scratch with C++ objects and write this to disk or another output stream.</p>
</blockquote>

<p>I've used TinyXml in my own projects and it is a joy to use.</p>

<p>Edit: In addition to TinyXML, I also use <a href=""http://code.google.com/p/ticpp/"" rel=""nofollow noreferrer"">ticpp</a> (TinyXml++) which introduces more features of C++ (exceptions, templates, iterators, etc) on top of the library.</p>
",0
701692,701648,7,"<p>Please. Please don't create XML on your own. </p>

<p>Use libraries which will generate valid and correct XML file.<br>
Same things is related to reading XML. You aren't going to read XML with ifstream, are you? So if you have XML library to read XML files I am pretty sure that this library allows XML creation.</p>

<p>Here is sample code with <a href=""http://sourceforge.net/projects/tinyxml/"" rel=""noreferrer"">tinyxml</a></p>

<pre><code>int main()
{
    VertexList vl;

    vl.push_back( Vertex( Point3d( -2.68, 1.82, 0.0 ), RGB( 255, 0, 0 )));
    vl.push_back( Vertex( Point3d( -2.63, 1.03, 0.0 ), RGB( 255, 0, 0 )));

    std::ostringstream ss;
    std::for_each( vl.begin(), vl.end(), VertexPrint( ss ) );

    // write xml
    TiXmlDocument doc;
    TiXmlDeclaration decl( ""1.0"", """", """" );  
    doc.InsertEndChild( decl );  

    TiXmlElement point( ""point"" );  

    TiXmlComment comment( ""My Points"" );
    point.InsertEndChild( comment );  

    point.SetAttribute(""name"", ""intersectPoints"");
    point.SetAttribute(""size"", vl.size());
    point.SetAttribute(""color"", ""rgb"");

    TiXmlText values( ss.str() );
    point.InsertEndChild( values );  

    doc.InsertEndChild( point );  
    doc.SaveFile( ""out.xml"" );  
}
</code></pre>

<p>Where <code>Vertex</code></p>

<pre><code>struct Point3d
{
    Point3d( double x, double y, double z ):
        x_(x), y_(y), z_(z)
    {}
    double x_;
    double y_;
    double z_;
};
struct RGB
{
    RGB( int r, int g, int b ):
        r_(r), g_(g), b_(b)
    {}
    int r_;
    int g_;
    int b_;
};
struct Vertex
{
    Vertex( const Point3d&amp; coord, const RGB&amp; color ):
        coord_( coord ), color_( color )
    {}
    Point3d coord_;
    RGB color_;
};
typedef std::vector&lt; Vertex &gt; VertexList;
</code></pre>

<p>and <code>VertexPrint</code> is</p>

<pre><code>struct VertexPrint
{
    VertexPrint( std::ostringstream&amp; result ):
        result_( result )
    {}
    void operator() ( const Vertex&amp; v )
    {
        result_ &lt;&lt; v.coord_.x_ &lt;&lt;"" ""&lt;&lt; v.coord_.y_ &lt;&lt;"" ""&lt;&lt; v.coord_.z_ &lt;&lt;"" ""
                &lt;&lt; v.color_.r_ &lt;&lt;"" ""&lt;&lt; v.color_.b_ &lt;&lt;"" ""&lt;&lt; v.color_.b_ &lt;&lt;"";"";
    }
    std::ostringstream&amp; result_;
};
</code></pre>

<p>You can also consider <a href=""http://www.boost.org/doc/libs/1_38_0/libs/serialization/example/demo_xml.cpp"" rel=""noreferrer"">boost XML serialization</a></p>
",3
701701,701648,0,"<p>To read and write xml files you would usually use an <a href=""http://en.wikipedia.org/wiki/Xml_parser#Processing_files"" rel=""nofollow noreferrer"">xml parser (sax or dom based)</a></p>

<p>One I have used is a sax parser called <a href=""http://xerces.apache.org/xerces-c/"" rel=""nofollow noreferrer"">xerces</a></p>
",0
701737,701648,0,"<p>I am looking at TinyXml now. I have downloaded it I hope I can install it.
I use MacOSX, I can see the Makefile for Linux was also successfully tested for MacOSX so I will try to install it and if successfully installed worked with it.</p>
",0
701766,701648,0,"<p>For something simple like this, writing the tags directly would not be very complicated:</p>

<pre><code>void WriteToFile(fstream&amp; file, vector&lt;double *&gt; intersections)
{
    file &lt;&lt; ""&lt;point"";
    file &lt;&lt; "" name=\""intersectPoints\"""";
    file &lt;&lt; "" size=\"""" &lt;&lt; intersections.size() ""\"""";
    file &lt;&lt; "" color=\""rgb\""""
    file &lt;&lt; ""&gt;\n""

    vector&lt;double *&gt;::iterator it;
    for (it=intersections.begin(); it != intersections.end(); it++)
    {
        file &lt;&lt; (*it)[0] &lt;&lt; "" "" &lt;&lt; (*it)[1] &lt;&lt; "" "" &lt;&lt; (*it)[2] &lt;&lt; "" "";
        file &lt;&lt; ""255 0 0\n"";
    }

    file &lt;&lt; ""&lt;/point&gt;"" &lt;&lt; endl;
}
</code></pre>
",0
701788,701648,1,"<p>If you are just writing XML, a full blown parser is an overkill. Better take a look at something like <a href=""http://www.tbray.org/ongoing/genx/docs/Guide.html"" rel=""nofollow noreferrer"">Genx</a></p>
",1
702604,701648,1,"<p>I have used xerces to generate XML files, and it very expensive in terms of memory and CPU usage. I eventually got ""out of memory"" exceptions trying to generate files with only a few hundreds of thousands of lines of XML. If you can get away with generating it directly as some other answers have suggested, and as your question implies should be possible, I would go that route. Reading and parsing is a different story, but using xerces to generate XML is overkill.</p>
",0
722829,722822,2,"<p>A class variable must be marked as ""static"". If your variable is an instance variable and not a class variable you must initialize it in the constructor or other method.</p>
",0
722833,722822,5,"<p>You're attempting to initialize an instance member via a static initialization construct.  If you want this to be a class level variable (static) then precede the variable with the static keyword.</p>

<pre><code>class Foo {
private:
  static int myInt;
};
</code></pre>
",2
722879,722822,37,"<p>What you have there is an instance variable.  Each instance of the class gets its own copy of myInt.  The place to initialize those is in a constructor:</p>

<pre><code>class Foo {
private:
    int myInt;
public:
    Foo() : myInt(1) {}
};
</code></pre>

<p>A class variable is one where there is only one copy that is shared by every instance of the class.  Those can be initialized as you tried. (See JaredPar's answer for the syntax)</p>

<p>For integral values, you also have the option of initializing a static const right in the class definition:</p>

<pre><code>class Foo {
private:
    static const int myInt = 1;
};
</code></pre>

<p>This is a single value shared by all instances of the class that cannot be changed.</p>
",2
722886,722822,13,"<p>To extend on Jared's answer, if you want to initialize it the way it is now, you need to put it in the Constructor.</p>

<pre><code>class Foo
{
public:
    Foo(void) :
    myInt(1) // directly construct myInt with 1.
    {
    }

    // works but not preferred:
    /*
    Foo(void)
    {
        myInt = 1; // not preferred because myInt is default constructed then assigned
                   // but with POD types this makes little difference. for consistency
                   // however, it's best to put it in the initializer list, as above
                   // Edit, from comment: Also, for const variables and references,
                   // they must be directly constructed with a valid value, so they
                   // must be put in the initializer list.
    }
    */

private:
    int myInt;
};
</code></pre>
",1
1110691,1110658,3,"<p>You should consider putting names and ages together in structured record.</p>

<p>Then sort the records.</p>

<p>J.</p>
",0
1110692,1110658,11,"<p>Rather than two vectors (one for names, and one for ages), have a vector of a new type that contains both:</p>

<pre><code>struct Person
{
    string name;
    double age;
};

vector&lt;Person&gt; people;
</code></pre>

<hr>

<p><strong>edit for comments:</strong></p>

<p>Keep in mind what you're now pushing onto the vector.  You must push something of type Person.  You can do this in a couple of ways:</p>

<p>Push back a default constructed person and then set the name and age fields:</p>

<pre><code>people.push_back(Person());
people.back().name = name;
people.back().age = age;
</code></pre>

<p>Give Person a constructor that takes a name and an age, and push a Person with some values:</p>

<pre><code>struct Person
{
    Person(const string&amp; name_, double age_) : name(name_), age(age_) {}
    string name;
    double age;
};

people.push_back(Person(name, age));
</code></pre>

<p>Create a Person, give it some values, and push that into the vector:</p>

<pre><code>Person person;
person.name = name;
person.age = age;

people.push_back(person);
</code></pre>

<p>Or more simply:</p>

<pre><code>Person person = { name, age };
people.push_back(person);
</code></pre>

<p>(thanks avakar)</p>
",2
1110699,1110658,1,"<p>You either need to swap elements in both vectors at the same time (the FORTRAN way), or store a <code>vector</code> of <code>struct</code>s or <code>pair</code>s. The later approach is more idiomatic for c-like languages.</p>
",2
1110704,1110658,1,"<p>You should use the <code>pair&lt;&gt;</code> utility template.  Reference <a href=""http://www.fredosaurus.com/notes-cpp/stl-containers/map/pair.html"" rel=""nofollow noreferrer"">here</a>.</p>
",1
1110707,1110658,2,"<p>You could have a vector of structs/classes, where each one has both a name and an age. When sorting, use a custom comparator that only looks at the name field.</p>

<p>Alternately, build an additional vector of integers [0,names.size()-1]. Sort that, with a custom comparator that instead of comparing a &lt; b compares names[a] &lt; names[b]. After sorting, the integer vector will give you the permutation that you can apply to both the names and ages vectors.</p>
",0
1110711,1110658,5,"<p>In addition to the solution posted by jeje and luke, you can also insert the pairs into a <code>map</code> (or <code>multimap</code>, in case duplicate names are allowed).</p>

<pre><code>assert(names.size() == ages.size());

map&lt;string, double&gt; people;
for (size_t i = 0; i &lt; names.size(); ++i)
    people[names[i]] = ages[i];

// The sequence [people.begin(), people.end()) is now sorted
</code></pre>

<p>Note that using <code>vector&lt;person&gt;</code> will be faster if you fill it up only once in advance. <code>map</code> will be faster if you decide to add/remove people dynamically.</p>
",0
1116696,1110658,0,"<p>G'day,</p>

<p>Given how you're trying to model this, my gut feeling is that you haven't approached the problem from an OO perspective. Try using a class instead of a struct.</p>

<p>struct's are soooo K&amp;R!  (-:</p>

<p>Think of a Person as an object and they have attributes that are tightly coupled, e.g. Name and Age. Maybe even address, email, Twitter, weight, height, etc.</p>

<p>Then add to your objects the functions that are meaningful, e.g. comparing ages, weights, etc. Writing a &lt; operator for email addresses or Twitter id's is a bit bizarre though.</p>

<p>OOA is just looking at what attributes your ""objects"" have in real life and that gives you a good starting point for designing your objects.</p>

<p>To get a better idea of OOA have a look at the excellent book ""Object Oriented Systems Analysis: Modeling the World in Data"" by Sally Shlaer and Stephen Mellor (<a href=""https://rads.stackoverflow.com/amzn/click/com/013629023X"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">sanitised Amazon link</a>). Don't faint at the Amazon price though $83.33 indeed! At least it's $0.01 second hand... (-:</p>

<p>HTH</p>

<p>cheers,</p>
",0
1062700,1062585,1,"<p>First of all you have a bug in the destructor, it should be</p>

<pre><code>~matrix1() { delete []data; }
</code></pre>
",0
1310869,1310853,1,"<p>yes - I've implemented state machine for 'unsigned int'. To store/compare states basic_string has been used</p>
",4
1310905,1310853,4,"<p>It was designed as a string class (hence, for example, <code>length()</code> and all those dozens of find functions), but after the introduction of the STL into the std lib it was outfitted to be an STL container, too (hence <code>size()</code> and the iterators, with <code>&lt;algorithm&gt;</code> making all the find functions redundant). </p>

<p>It's main purpose is to store characters, though. Using anything than PODs isn't guaranteed to work (and doesn't work, for example, when using Dinkumware's std lib). Also, the necessary <code>std::char_traits</code> isn't required to be available for anything else than <code>char</code> and <code>wchar_t</code> (although many implementations come with a reasonable implementation of the base template). </p>

<p>In the original standard, the class wasn't required to store its data in a contiguous piece of memory, but this has changed with C++03. </p>

<p>In short, it's mostly useful as a container of characters (a.k.a. ""string""), where ""character"" has a fairly wide definition. </p>

<p>The ""wildest"" I have used it for is for storing differently encoded strings by using different character types. That way, strings of different encodings are incompatible even if they use the same character size (ASCII and UTF-8) and, e.g., assignment causes compile-time errors. </p>
",1
489334,487866,1,"<p>Here is the link to the paper describing HOT queues. It's very abstract, that's why i wanted
to see a coded example (I'm still trying to fin my way around it).
<a href=""http://www.star-lab.com/goldberg/pub/neci-tr-97-104.ps"" rel=""nofollow noreferrer"">http://www.star-lab.com/goldberg/pub/neci-tr-97-104.ps</a></p>

<p>The ""cheapest"", sort to speak variant of this is a two-level heap queue (maybe this sounds more familiar). What i wanted to do is to improve the running time of the Dijkstra's shortest path algorithm.</p>
",0
492015,487866,1,"<blockquote>
  <p>What i wanted to do is to improve the
  running time of the Dijkstra's
  shortest path algorithm.</p>
</blockquote>

<p>Have you considered using the <a href=""http://www.boost.org/doc/libs/1_37_0/libs/graph/doc/table_of_contents.html"" rel=""nofollow noreferrer"">Boost Graph Library</a>?
If you are using your own implementation of the algorithm you might already get better results using <a href=""http://www.boost.org/doc/libs/1_37_0/libs/graph/doc/dijkstra_shortest_paths.html"" rel=""nofollow noreferrer"">the one the BGL provides</a>.</p>

<p>However It might be nontrivial to modify your code so it works with the BGL.</p>

<p>Of course speed-up could also be gained by not using Dijkstra at all but another algorithm.</p>
",0
492525,487866,2,"<p><a href=""http://www.lonesock.net/misc.html"" rel=""nofollow noreferrer"">Here is a page</a> I found that provides at least a clue toward what data structures you might use to implement this.  Scroll down to the section called ""Making A* Scalable.""  It's unfortunate that the academic papers on the subject mention having written C++ code but don't provide any.</p>
",0
772671,772655,4,"<p>Directly off my head:</p>

<ul>
<li>Create an integer static field in
each class. Watch out for integer overflow.</li>
<li>Initialize it to 0 in an
<a href=""http://www.cpptalk.net/emulating-a-static-constructor-vt12077.html"" rel=""nofollow noreferrer"">emulated static constructor</a>.</li>
<li>Increment it at each (nonstatic)
constructor body. Decrement it in the
destructor.</li>
<li>GetInstancesCount() is a static function that returns the value of your integer static field.</li>
</ul>

<p><strong>Note:</strong> See Mykola's comments. This would print 4 for A, 3 for B and 2 for C i.e. it would count one instance of B as ""one A and one B"", and one C as ""one A, one B and one C"". Which is in a way true, but is not what the question asks for. In other words, my answer is wrong :)</p>
",7
772680,772655,2,"<p>Use a <code>static</code> member variable for each class. </p>

<pre><code>struct A {
    A() { mInstances++; }
    ~A() { mInstances--; }
    static size_t mInstances;
    static size_t GetInstancesCount() { return mInstances; }
};

size_t A::mInstances;

int main() {
    A* a = new A;
    A* aa = new A;
    cout &lt;&lt; A::GetInstancesCount() &lt;&lt; endl;
    delete a;
    delete aa;
    cout &lt;&lt; A::GetInstancesCount() &lt;&lt; endl;
    return 0;
}
</code></pre>
",0
772697,772655,6,"<p>There is a problem with proposed solutions: when you create B you A constructor will be called automatically and thus increment count of A. </p>

<pre><code>class A
{
public:
    A(bool doCount = true)
    {
        if (doCount)
            ++instanceCount_;
    }

    static std::size_t GetInstanceCount()
    {
        return instanceCount_;
    }

    virtual ~A(){}
private:
    static std::size_t instanceCount_;
};

class B: public A
{
public:
    B(bool doCount = true):A(false)
    {
        if (doCount)
            ++instanceCount_;
    }

    static std::size_t GetInstanceCount()
    {
        return instanceCount_;
    }
private:
    static std::size_t instanceCount_;
};

std::size_t A::instanceCount_ = 0;
std::size_t B::instanceCount_ = 0;
</code></pre>
",1
772699,772655,3,"<p>A bit of the ""Curiously reoccurring template pattern"".  </p>

<pre><code>template&lt;typename P&gt;
class Counter
{
    public: Counter(bool inc)
        :m_wasInc(inc)
    {
        if (m_wasInc)
        {   getCount()++;}
    }
           ~Counter()
    {
        if (m_wasInc)
        {   getCount()--;}
    }
    static std::size_t GetInstancesCount()
    {
         return getCount();
    }
    private:
       bool m_wasInc;
       /*
        * Alternatively this can be a static member variable.
        * I just used a function because this means I do not need to declare
        * the variable for each type class. The down size is that it becomes
        * more complex if used in the presence of a DLL's.
        *
        * But that is way easy to change. See Alternative Version below.
        */
       static std::size_t&amp; getCount()
       {
           static std::size_t count = 0;
           return count;
       }
};

class A: public Counter&lt;A&gt;
{
    public: A(bool count = true): Counter&lt;A&gt;(count){}
};

class B: public A,Counter&lt;B&gt;
{
    public: B(bool count = true): A(false), Counter&lt;B&gt;(count){}
};

class C: public A, Counter&lt;C&gt;
{
    public: C(bool count = true): A(false), Counter&lt;C&gt;(count){}
};

template&lt;typename P&gt;
class CounterAlt
{
    public: CounterAlt()
    {    ++count;
    }
    static std::size_t GetInstancesCount()
    {
         return count;
    }
    private:
       static std::size_t count;
};

class D: public CounterAlt&lt;D&gt;
{
};
std::size_t CounterAlt&lt;D&gt;::count = 0;
</code></pre>
",6
772701,772655,1,"<p>A very crude way would be:</p>

<pre><code>class A
{
public:
    static int m_instanceCount;
    A(bool derivedInstance = false)
    {
        if(! derivedInstance)
        {
            ++m_instanceCount;
        }
    }
    virtual ~A()
    {
        --m_instanceCount;
    }
    virtual int GetInstanceCount()
    {
        return m_instanceCount;
    }
};

int A::m_instanceCount = 0;


class B : public A
{
public:
    static int m_instanceCount;
    B(bool derivedInstance = false): A(true) 
    {
        if(! derivedInstance)
        {
            ++m_instanceCount;
        }
    }
    virtual ~B()
    {
        --m_instanceCount;
    }
    virtual int GetInstanceCount()
    {
        return m_instanceCount;
    }
};

int B::m_instanceCount = 0;


class C : public B
{
public:
    static int m_instanceCount;
    C(): B(true) {++m_instanceCount;}
    virtual ~C()
    {
        --m_instanceCount;
    }
    virtual int GetInstanceCount()
    {
        return m_instanceCount;
    }
};

int C::m_instanceCount = 0;




void main(int argc,char *argv[])
{   
    A* p1 = new A;
    B* p2 = new B;
    C* p3 = new C;
    C* p4 = new C;
    A* p5 = new A;

    delete p5;

    std::cout&lt;&lt;p1-&gt;GetInstanceCount()&lt;&lt;""\n"";
    std::cout&lt;&lt;p2-&gt;GetInstanceCount()&lt;&lt;""\n"";
    std::cout&lt;&lt;p3-&gt;GetInstanceCount()&lt;&lt;""\n"";
}   
</code></pre>
",1
772718,772655,1,"<p>This is a simple counter I use each so often for debugging:</p>

<pre><code>// counter.hpp
#ifndef COUNTER_HPP
#define COUNTER_HPP

template &lt;typename T&gt;
class Counter
{
public:
    Counter( bool do_count = true ) : counted(do_count) 
    { if ( counted ) get_count()++; }
    ~Counter() { if (counted) --count_; }

    static unsigned long count() { return count_; }
    static unsigned long&amp; get_count() { 
       static unsigned long count=0;
       return count;
    }
private:
    bool do_count;
};
#endif 
</code></pre>

<p>The usage is simple, just inherit from it:</p>

<pre><code>class BaseClass : public Counter&lt;BaseClass&gt;
{
public:
   explicit BaseClass( bool do_count = true ) 
      : Counter&lt;BaseClass&gt;( do_count )
   {}
};
class DerivedClass : public BaseClass, Counter&lt;DerivedClass&gt;
{
public:
   explicit DerivedClass( bool do_count = true )
      : BaseClass(false), Counter&lt;DerivedClass&gt;(do_count)
   {}
};
</code></pre>

<p>User code will call a parameterless constructor:</p>

<pre><code>int main() {
   BaseClass b; // will call Counter&lt;BaseClass&gt;(true)
   DerivedClass d; // will call Counter&lt;BaseClass&gt;(false), Counter&lt;DerivedClass&gt;(true)
}
</code></pre>
",3
772765,772655,0,"<p>Create the classes through a factory so the factory will be able to keep track of how many have been created.</p>

<p>Not as clean as just calling new on the class but it may do what you need.</p>
",0
773065,772655,0,"<p>The current solutions all seem to count in constructors, and therefore also count in constructors of base type. (except Mykola, but that solution has an implicit conversion from bool - bad) This double-counting wasn't desired. The tricky part, though, is that <em>during</em> the construction of a derived type, the object temporary has intermediate base types. And with virtual base classes, this situation is even worse. In that case, the intermediate type isn't even well-defined.</p>

<p>Ignoring such transients, there are a few solutions to the double-counting:</p>

<ul>
<li>Use a flag to disable counting </li>
<li>Use a protected base class constructor which doesn't count</li>
<li>Decrease the instance count of your base classes in derived constructors '*(this->base::count)--`</li>
<li>Keep the counts in a dedicated virtual base class. </li>
</ul>

<p>The latter option (virtual base class) is probably the nicest; the compiler will enforce it's initialized once and only once, from the final ctor.</p>

<pre><code>class counter {
    template&lt;typename T&gt; struct perTypeCounter { static int count =  0; }
    int* count; // Points to perTypeCounter&lt;MostDerived&gt;::count

    protected:
    template&lt;typename MostDerived&gt; counter(MostDerived*) 
    {
        count = &amp;perTypeCounter&lt;MostDerived&gt;::count;
        ++*count;
    }
    ~counter() { --*count; }
};
</code></pre>
",0
773259,772655,0,"<p>You can use virtual inheritance to force the counting base class constructor to be called by every super class constructor and only that constructor.  This fixes the double counting problem.  Then use RTTI for the rest:</p>

<pre><code>#include &lt;map&gt;
#include &lt;typeinfo&gt;
#include &lt;iostream&gt;

struct type_info_less
{
    bool operator() (const std::type_info * t1, const std::type_info * t2) {
        return t1-&gt;before(*t2);
    }
};

struct InstCounter
{
    typedef std::map&lt;const std::type_info *, size_t, type_info_less&gt; CountMap;
    static CountMap countMap_;
    const std::type_info * my_type_;

    InstCounter(const std::type_info &amp; type) : my_type_(&amp;type){
        ++countMap_[my_type_];
    }

    ~InstCounter() {
        --countMap_[my_type_];
    }

    static size_t getCount(const std::type_info &amp; type) {
        return countMap_[&amp;type];
    }

    size_t getCount() {
        return countMap_[my_type_];
    }
};

InstCounter::CountMap InstCounter::countMap_;

struct A : public virtual InstCounter
{
    A() : InstCounter(typeid(A)) {}
};

struct B : public A
{
    B() : InstCounter(typeid(B)) {}
};

struct C : public B
{
    C() : InstCounter(typeid(C)) {}
};


int main(int argc, char * argv[])
{
    std::cout &lt;&lt; ""A: "" &lt;&lt; InstCounter::getCount(typeid(A)) &lt;&lt; std::endl;
    std::cout &lt;&lt; ""B: "" &lt;&lt; InstCounter::getCount(typeid(B)) &lt;&lt; std::endl;
    std::cout &lt;&lt; ""C: "" &lt;&lt; InstCounter::getCount(typeid(B)) &lt;&lt; std::endl;

    {
        A a1, a2, a3;
        B b1;
        C c1, c2;

        std::cout &lt;&lt; ""A: "" &lt;&lt; InstCounter::getCount(typeid(A)) &lt;&lt; std::endl;
        std::cout &lt;&lt; ""A: "" &lt;&lt; a1.getCount() &lt;&lt; std::endl;
        std::cout &lt;&lt; ""B: "" &lt;&lt; InstCounter::getCount(typeid(B)) &lt;&lt; std::endl;
        std::cout &lt;&lt; ""B: "" &lt;&lt; b1.getCount() &lt;&lt; std::endl;
        std::cout &lt;&lt; ""C: "" &lt;&lt; InstCounter::getCount(typeid(C)) &lt;&lt; std::endl;
        std::cout &lt;&lt; ""C: "" &lt;&lt; c1.getCount() &lt;&lt; std::endl;
    }

    std::cout &lt;&lt; ""A: "" &lt;&lt; InstCounter::getCount(typeid(A)) &lt;&lt; std::endl;
    std::cout &lt;&lt; ""B: "" &lt;&lt; InstCounter::getCount(typeid(B)) &lt;&lt; std::endl;
    std::cout &lt;&lt; ""C: "" &lt;&lt; InstCounter::getCount(typeid(C)) &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>This results in</p>

<pre><code>A: 0
B: 0
C: 0
A: 3
A: 3
B: 1
B: 1
C: 2
C: 2
A: 0
B: 0
C: 0
</code></pre>

<p>Unfortunately you must store the type for each instance as calling typeid(*this) in InstCounter::getCount() returns the type_info for InstCounter and not the most derived type. (At least with VS2005)</p>

<p>NOTE: Each constructor for A, B and C have to call the InstCounter constructor explicitly then pass their typeid in.  There is a down side to this, if you copy and paste this code for each new sub class you can forget to change the parameter to typeid.</p>

<p>Updated to add decrementing destructor.</p>
",0
773373,772655,1,"<p>One way to get around the double-counting when counting objects in the constructor is to count the objects at the point of need, rather than in the constructor, using RTTI.  This is minimally intrusive:</p>

<pre><code>#include &lt;vector&gt;
#include &lt;typeinfo&gt;
#include &lt;iostream&gt;
#include &lt;functional&gt;


class A
{

public:

    A();
    virtual ~A() { }

};

class B: public A
{

public:

    virtual ~B() { }
};

class C: public B
{

public:

    virtual ~C() { }

};

template&lt;class T&gt;
struct TypeIdsEqual: public std::binary_function&lt;T, T, bool&gt;
{
    bool operator() (const T&amp; obj1, const T&amp; obj2) const
    {
        return typeid(*obj1) == typeid(*obj2);
    }
};

struct Counter
{
    static std::vector&lt;A*&gt; objects;

    static void add(A* obj)
    {
        objects.push_back(obj);
    }

    static int count(A* obj)
    {
        return std::count_if(objects.begin(), objects.end(),
                             std::bind1st(TypeIdsEqual&lt;A*&gt;(), obj));
    }

};

std::vector&lt;A*&gt; Counter::objects;

// One intrusive line in the base class constructor.  None in derived classes...
A::A()
{
    Counter::add(this);
}

int main(int *argc, char* argv[])
{
    A* a  = new A;
    B* b  = new B;
    C* c  = new C;
    C* c2 = new C;
    std::cout &lt;&lt; Counter::count(*a) &lt;&lt; std::endl;  // Output: 1
    std::cout &lt;&lt; Counter::count(*b) &lt;&lt; std::endl;  // Output: 1
    std::cout &lt;&lt; Counter::count(*c) &lt;&lt; std::endl;  // Output: 2
}
</code></pre>
",0
599353,599321,4,"<p>Your question is totally dependant on WHICH system you are using. Each system has its own functions for getting the current time. For finding out how long the system has been running, you'd want to access one of the ""high resolution performance counters"". If you don't use a performance counter, you are usually limited to microsecond accuracy (or worse) which is almost useless in profiling the speed of a function.</p>

<p>In Windows, you can access the counter via the 'QueryPerformanceCounter()' function. This returns an arbitrary number that is different on each processor. To find out how many ticks in the counter == 1 second, call 'QueryPerformanceFrequency()'.</p>

<p>If you're coding under a platform other than windows, just google performance counter and the system you are coding under, and it should tell you how you can access the counter.</p>

<p><strong><em>Edit (clarification)</em></strong><br>
This is c++, just include windows.h and import the ""Kernel32.lib""  (seems to have removed my hyperlink, check out the documentation at: <a href=""http://msdn.microsoft.com/en-us/library/ms644904.aspx"" rel=""nofollow noreferrer"">http://msdn.microsoft.com/en-us/library/ms644904.aspx</a>). For C#, you can use the ""System.Diagnostics.PerformanceCounter"" class.</p>
",1
599330,599321,1,"<p>You can use <a href=""http://en.wikipedia.org/wiki/Time_t"" rel=""nofollow noreferrer"">time_t</a></p>
",0
599337,599321,6,"<p>The approach I use when timing my code is the time() function. It returns a single numeric value to you representing the <a href=""http://en.wikipedia.org/wiki/Unix_time"" rel=""nofollow noreferrer"">epoch </a> which makes the subtraction part easier for calculation.</p>

<p>Relevant code:</p>

<pre><code>#include &lt;time.h&gt;
#include &lt;iostream&gt;

int main (int argc, char *argv[]) {

int startTime, endTime, totalTime;

startTime = time(NULL);

/* relevant code to benchmark in here */

endTime = time(NULL);

totalTime = endTime - startTime;

std::cout &lt;&lt; ""Runtime: "" &lt;&lt; totalTime &lt;&lt; "" seconds."";

return 0;
}
</code></pre>

<p>Keep in mind this is user time. For CPU, time see Ben's reply.</p>
",0
599583,599321,0,"<p>Under Linux, try <code>gettimeofday()</code> for microsecond resolution, or <code>clock_gettime()</code> for nanosecond resolution.</p>

<p>(Of course the actual clock may have a coarser resolution.)</p>
",0
834569,834314,4,"<p>You should only make functions you intend and design to be overridden virtual.  Making a method virtual is not free in terms of both maintenance and performance (maintenance being the much bigger issue IMHO).  </p>

<p>Once a method is virtual it becomes harder to reason about any code which uses this method.  Because instead of considering what one method call would do, you must consider what N method calls would do in that scenario.  N represents the number of sub classes which override that method.  </p>

<p>The one exception to this rule is destructors.  They should be virtual in any class which is intended to be derived from.  It's the only way to guarantee that the proper destructor is called during deallocation.  </p>
",0
834323,834314,0,"<p>The interface functions should be, in general, virtual. Functions that provide fixed functionality should not.</p>
",0
834329,834314,2,"<p>I tend to make only the things I want to be overridable virtual. If my initial assumptions about what I will want to override turn out to be wrong, I go back and change the base class.</p>

<p>Oh, and obviously always make your destructor virtual if you're working on something that will be inherited from.</p>
",0
834356,834314,0,"<p>Why declare something virtual until you are really overriding it? I believe it's not a question of being sure or not. Follow the facts: is it overriden somewhere? No? Then it must not be virtual.</p>
",2
834357,834314,1,"<p>If you are creating a base class ( you are sure that somebody derives the class ) then you can do following things:</p>

<ul>
<li>Make destructor virtual (a must for base class)</li>
<li>Define methods which should be
derived and make them virtual.</li>
<li>Define methods which need not be ( or
should not be) derived as
non-virtual.</li>
<li>If the functions are only for derived
class and not for base class then mark
them as protected.</li>
</ul>
",0
834362,834314,8,"<p>A function only needs to be virtual iff a derived class will implement that function in a different way.</p>

<p>For example:</p>

<pre><code>class Base {
public:
  void setI (int i)  // No need for it to be virtual
  {
    m_i = i;
  }

  virtual ~Base () {}         // Almost always a good idea

  virtual bool isDerived1 ()  // Is overridden - so make it virtual
  {
    return false;
  }

private:
  int m_i;
};

class Derived1 : public Base {
public:
  virtual ~Derived () {}

  virtual bool isDerived1 ()  // Is overridden - so make it virtual
  {
    return true;
  }
};
</code></pre>

<p>As a result, I would error the side of not having anything virtual unless you know in advance that you intend to override it or until you discover that you require the behaviour.  The only exception to this is the destructor, for which its <em>almost</em> always the case that you want it to be virtual in a base class.</p>
",1
834468,834314,1,"<p>Compiler wouldn't know which actual piece of code will be run when pointer of base type calls a virtual function. so the actual piece of code that would be run needs to be evaluated at run-time according to which object is pointed by base class pointer. So avoid the use of virtual function if the function is not gonne be overriden in an inherited class.</p>

<p>TLDR version:
""you should have a set of virtual functions and a set of non-virtual functions which you are sure are not going to be inherited."" Because virtual functions causes a performance decrease at run-time.  </p>
",0
834830,834314,4,"<p>The non-virtual interface idiom (C++ Coding Standards item 39) says that a base class should have non-virtual interface methods, allowing the base class to guarantee invariants, and non-public virtual methods for customization of the base class behaviour by derived classes. The non-virtual interface methods call the virtual methods to provide the overridable behaviour.</p>
",1
1810389,1810348,1,"<p>Except that Books and Book isn't the same (typ0)</p>

<p>And you have to have some data member in Books to store the number, and some way of generating it.<br>
You probably also need some sort of factory to create a unique number for each Books()</p>
",0
1810400,1810348,4,"<p>It's really hard to tell what you are asking.  Let me offer some criticisms, though.  Maybe these will help.</p>

<p>The show_results method should be const-correct.  That means you should pass foreign_books as a const:</p>

<pre><code>const Book&amp; foreign_books
</code></pre>

<p>This way, your compiler will complain if you try to modify foreign_books at all in your method.</p>

<p>As mgb points out, your Books class won't work because the show_results method requires a Book, not a Books.  But once you fix that, you probably want to make the getBooksNumber const-correct as well:</p>

<pre><code>int getBooksNumber() const;
</code></pre>

<p>You haven't told us what you are trying to accomplish here, so it's really hard to tell if you are close to correct in what you are doing.</p>

<p>Finally, you missed a semicolon in your show_results method:</p>

<pre><code>void show_results(Book&amp; foreign_books) {
   int total_books; // **here**

   total_books = foreign_books.getBooksNumber();
   cout &lt;&lt; total_books &lt;&lt; endl;
}
</code></pre>
",2
1882530,1882477,1,"<p>You might want to look into the scanf function as a starting point.</p>
",2
1882543,1882477,2,"<p>The obvious approach would be something like <code>std::getline(intput, your_string, '=');</code></p>
",0
730000,729905,0,"<p>Create a abstract class, declaring the methods, which behavior must be variable, as virtual.
Create concrete classes, that will implement the virtual methods. There are many ways to achieve this, using design patterns.</p>
",0
730001,729905,0,"<p>You can change the object behavior using <a href=""http://www.elilabs.com/~rj/dreams/node18.html"" rel=""nofollow noreferrer"">dynamic binding</a>. The design patterns like <a href=""http://en.wikipedia.org/wiki/Decorator_pattern"" rel=""nofollow noreferrer"">Decorator</a>, <a href=""http://en.wikipedia.org/wiki/Strategy_pattern"" rel=""nofollow noreferrer"">Strategy</a> would actually help you to realize the same.</p>
",0
730079,729905,3,"<p>Coplien's Envelope/Letter Pattern (in his <em>must read</em> book <em>Advanced C++ Programming Styles and Idioms</em>) is the classic way to do this.</p>

<p>Briefly, an Envelope and a Letter are both subclasses of an abstract base class/interfcae that defines the public interface for all subclasses. </p>

<p>An Envelope holds (and hides the true type of) a Letter.</p>

<p>A variety of Letter classes have different implementations of the abstract class's public interface.</p>

<p>An Envelope has no real implementation; it just forards (delegates) to its Letter. It holds a pointer to the abstract base class, and points that at a concrete Letter class instance. As the implementation needs to be changed, the type of Letter subclass pointer to is changed.</p>

<p>As users only have a reference to the Envelope, this change is invisible to them except in that the Envelope's behavior changes.</p>

<p>Coplien's examples are particularly clean, because it's the Letters, not the envelope that cause the change. </p>

<p>One example is of a Number class hierarchy. The abstract base declares certain operations over all Numbers, e.g, addition. Integer and a Complex are examples of concrete subclasses.</p>

<p>Adding an Integer and an Integer results in an Integer, but adding a Interget and a Complex results in a Complex.</p>

<p>Here's what  the Envelope looks like for addition:</p>

<pre><code>public class Number {
  Number* add( const Number* const n ) ; // abstract, deriveds override
}

public class Envelope : public Number {
  private Number* letter;

...

  Number* add( const Number&amp; rhs) { // add a number to this
    // if letter and rhs are both Integers, letter-&gt;add returns an Integer
    // if letter is a a Complex, or rhs is, what comes back is a Complex
    //
    letter = letter-&gt;add( rhs ) ) ;
    return this;
  }
}
</code></pre>

<p>Now in the client's pointer never changes, and they never ever need to know what the Envelop is holding. Here's the client code:</p>

<pre><code>int main() {
  // makeInteger news up the Envelope, and returns a pointer to it
  Number* i = makeInteger( 1 ) ;  
  // makeComplex is similar, both return Envelopes.
  Number* c = makeComplex( 1, 1 ) ;

  // add c to i
  i-&gt;add(c) ;


  // to this code, i is now, for all intents and purposes, a Complex!
  // even though i still points to the same Envelope, because 
  // the envelope internally points to a Complex.
}
</code></pre>

<p>In his book, Coplien goes into greater depth -- you'll note that the add method requires multi-dispatch of some form --, and adds syntactic sugar. But this is the <em>gist</em> of how you can get what's called ""runtime polymorphism"".</p>
",0
729916,729905,1,"<p>Objects always have the behaviour that's defined by their class.</p>

<p>If you need different behaviour, you need a different class...</p>
",0
729923,729905,0,"<p>There are many ways to do this proxying, pImpl idiom, polymorphism, all with pros and cons. The solution that is best for you will depend on exactly which problem you are trying to solve.</p>
",0
729932,729905,2,"<p>You can achieve it through dynamic binding (polymorphism)... but it all depends on what you are actually trying to achieve.</p>
",0
729952,729905,0,"<p>Many many ways:</p>

<p>Try <code>if</code> at first. You can always change the behavior with if statement. Then you probably find the 'polymorphism' way more accurate, but it depends on your task.</p>
",0
729971,729905,9,"<p>The standard pattern for this is to make the outer class have a pointer to an ""implementation"" class.</p>

<pre><code>// derive multiple implementations from this:
class Implementation
{
    virtual ~Implementation() {} // probably essential!

    virtual void foo() = 0;
};

class Switcheroo
{
    Implementation *impl_;

public:
    // constructor, destructor, copy constructor, assignment 
    // must all be properly defined (any that you can't define, 
    // make private)

    void foo()
    {
        impl_-&gt;foo();
    }
};
</code></pre>

<p>By forwarding all the member functions of <code>Switcheroo</code> to the <code>impl_</code> member, you get the ability to switch in a different implementation whenever you need to.</p>

<p>There are various names for this pattern: Pimpl (short for ""private implementation""), Smart Reference (as opposed to Smart Pointer, due to the fowarding member functions), and it has something in common with the Proxy and Bridge patterns.</p>
",0
729986,729905,2,"<p>You can't change the behavior of arbitrary objects using any sane way unless the object was intended to use 'plugin' behaviour through some technique (composition, callbacks etc). </p>

<p>(Insane ways might be overwriting process memory where the function code lies...)</p>

<p>However, you can overwrite an object's behavior that lies in virtual methods by overwriting the vtable (<a href=""http://www.cs.nmsu.edu/please/ddl/cppredirection.php"" rel=""nofollow noreferrer"">An approach can be found in this article</a> ) without overwriting memory in executable pages. But this still is not a very sane way to do it and it bears multiple security risks.</p>

<p>The safest thing to do is to change the behavior of objects that were designed to be changed by providing the appropriate hooks (callbacks, composition ...).</p>
",0
729993,729905,6,"<p>I'm mentioning this only as trivia and can't unrecommend it more, but here we go...</p>

<p><strong>WARNING DANGER!!!</strong></p>

<p>A <strong>stupid</strong> trick I've seen is called clutching, I think, but it's only for the truely foolish. Basically you swap the virtualtable pointer to that of another class, it works, but it could theoretically destroy the world or cause some other undefined behavior :)</p>

<p>Anyways instead of this just use dynamic classing and kosher C++, but as an experiment the above is kind of fun...</p>
",2
1425779,1425695,2,"<p>You're doing something rather weird here.</p>

<p>The following would work and is entirely safe:</p>

<pre><code>class CBase {
      void SomeChecks() {};
   public:
      CBase() {
         /* Do some checks */
         SomeChecks();
      }
};

class CDerived: public CBase{
      void SomeOtherChecks() {};
   public:
      CDerived() {
         /* Do some other checks */
         SomeOtherChecks();
      }
};
</code></pre>

<p>In this hierarchy, when CDerived is constructed, first CBase performs its SomeChecks() and then CDerived is doing its own OtherChecks(). That's how it should be. </p>

<p>The fact that you made SomeChecks() virtual shows an intention to allow SomeChecks to be fully overridden in derived classes, while those checks still have to be executed in constructor. This is usually an indication of broken architecture; in fact, you are trying to put some knowledge of the derived class in the parent, which is generally wrong. </p>
",2
1425783,1425695,1,"<p>There's no clean solution to this. You can't call CDerived functions safely until the CDerived ctor body has been entered. At that point the CBase ctor must have returned.</p>

<p>One workaround might be the following:</p>

<pre><code>protected: CBase(boost::function&lt;void(*)(CBase*)&gt; SomeChecks) {
    // Base checks
    SomeChecks(this); // Checks provieded by derived ctor but running on CBase member.
}
</code></pre>
",0
1426513,1425695,-1,"<p>Maybe this works for you:</p>

<pre><code>class CBase {
   public:
      CBase() {
         /* Do some checks */
         SomeChecks();
         /* Do some more checks */
      }
      virtual ~CBase(){} /*don't forget about this*/
      virtual void SomeChecks() {}
};


class CDerived : public CBase {
   public:
      void SomeChecks() { //without virtual
           /* Do some other checks */
           CBase::SomeChecks(); //if you want checks from CBase
      }
      CDerived() : CBase() {}
};

CBase* fromBase = new CBase(); //checking with CBase::SomeChecks()
CBase* fromDerived = new CDerived(); //checking with CDerived::SomeChecks
CDerived* alsoDerived = new CDerived(); //checking with CDerived::SomeChecks
</code></pre>
",3
1426834,1425695,3,"<p>Calling virtual methods in the constructor/destructor is not allowed.<br>
The though processes behind this is that virtual methods are calling the most derived version of a method and if the constructor has not finished then the most derived data has not been correctly initialized and therefore doing so potentially provides an opertunity for use of an invalid object.</p>

<p>What you are looking for is the PIMPL design pattern:</p>

<pre><code>class CBase { ... };
class CDerived: public CBase { ... }

template&lt;typename T&gt;
class PIMPL
{
    public:
        PIMPL()
            :m_data(new T)
        {
           // Constructor finished now do checks.
           m_data-&gt;SomeChecks();
        }
        // Add appropriate copy/assignment/delete as required.
    private:
        // Use appropriate smart pointer.
        std::auto_ptr&lt;T&gt;    m_data;
};
int main()
{
    PIMPL&lt;CDerived&gt;    data;
}
</code></pre>
",5
1426172,1425695,3,"<p>What you want is called two-phase construction. C++ doesn't offer this as a syntactcical construct, so you have to do it on your own. </p>

<p>A common way to do this is to use the Programmer's All-Purpose Ointment (add another layer of indirection): You wrap your classes in some other class. That class's constructor first calls your class' constructor and then the additional initialization function. Of course, this messes up your design a bit. </p>
",0
1426231,1425695,0,"<p>One should design one's class hierarchy in such a way that only a base class is responsible for checking the base constraints.  This <em>can</em> be a problem when for instance the child class has to invent some constructor arguments for the parent class' constructor.  </p>

<p>The other problem, calling another constructor with the same argument signature, can be solved using the 'tagged constructor' trick: create a template constructor.</p>

<pre><code>struct C {
   enum eConstructor { cCheck, cNoCheck };

   template&lt; eConstructor constr = cCheck &gt; C( int i );

   int positive_value;
};

template&lt;&gt; C::C&lt;C:: cCheck &gt;( int i ) : positive_value( std::max( 0, i ) ) { }
template&lt;&gt; C::C&lt;C::cNoCheck&gt;( int i ) : positive_value( i ) { }


struct CFive : public C {
   CFive(): C&lt;C::cNoCheck&gt;(5) {}
};
</code></pre>
",0
1084334,1084251,0,"<p>How about making a second loop like this:</p>

<pre><code>char option;
do
{
    cout &lt;&lt; ""do you want to input another number? (y)es/(n)o..."" &lt;&lt; endl;
    cin &gt;&gt; option;
    if ( option == 'y' )
        acceptInput(); // here enter whatever code you need
}
while ( option != 'n' );
</code></pre>
",1
1084338,1084251,3,"<p>There are several ways to approach your problem.  The easiest is probably to move out of a direct cin/cout loop and to use std::getline instead.  Specifically, you could write something like:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;sstream&gt;
using namespace std;

int main( int argc, char **argv )
{
  vector&lt;int&gt; reftest;

  while ( true )
  {
    string input;
    getline( cin, input );

    // You can do whatever processing you need to do
    // including checking for special values or whatever
    // right here.

    if ( input.size() == 0 ) // empty input string
    {
      cout &lt;&lt; ""Assuming you're bored with the Entering Numbers game."" &lt;&lt; endl;
      break;
    }
    else
    {
      int value;
      // Instead of using the input stream to get integers, we 
      // used the input stream to get strings, which we turn 
      // into integers like this:

      istringstream iss ( input ); 
      while ( iss &gt;&gt; value )
      {
        reftest.push_back( value );
        cout &lt;&lt; ""Inserting value: "" &lt;&lt; value &lt;&lt; endl;
      }
    }
  }
}
</code></pre>

<p>Other approaches include cin.getline() (which I'm not a big fan of because it works on char* instead of strings), using the cin.fail() bit to figure out whether or not the incoming value was any good, etc.  And depending on your environment, there are probably many richer ways of getting user input than through iostreams.  But this should point you towards the information you need.</p>
",0
1084356,1084251,0,"<p>I'm afraid there is no good way of doing this. Real-world interactive programs simply do not use formatted (or unformatted, come to that) input from a stream to read the keyboard - they use operating system specific methods.</p>
",0
1430172,1430166,11,"<p>Accessing past the end of a vector is undefined behavior.  Anything could happen.  You might have <a href=""http://www.urbandictionary.com/define.php?term=nasal%20demons"" rel=""nofollow noreferrer"">nasal demons</a>.</p>
",0
1430176,1430166,5,"<p>Your application does not crash because there is some standard that specifies that it should crash. Crashing is just random (undefined) behaviour. You will not always get a crash when you exceed the bounds of an array as you have found out.</p>

<p>Essentially, anything could happen such as printing a blank line, crashing or even as just posted - have demons fly out of your nose.</p>
",0
1430198,1430166,2,"<p>C++ doesn't do range-checking of arrays.</p>

<p>Reading beyond the end of an array is what's called ""undefined"" behaviour: i.e. it's not guaranteed to throw an exception, it's not guaranteed to <em>not</em> throw an exception, and it's not guaranteed to have consistent behaviour from one run to the next.</p>

<p>If people say that C++ is an ""unsafe"" language, this is part of what they mean by that. C++ doesn't check the range at run-time, because doing that a run-time take extra CPU instructions, and part of the design philosophy of C++ is to make it no slower than C.</p>

<p>Your compiler might have been able to warn you at compile-time (are you using the compiler command-line options to give you the maximum possible number of warnings?), though that too isn't guaranteed/required by the language.</p>
",0
1430285,1430166,5,"<p>You have an array of only six elements. When you try to access the supposed ""seventh"" element, you get <em>undefined behavior</em>. Technically, that means anything can happen, but that doesn't seem to me like a very helpful explanation, so let's take a closer look.</p>

<p>That array occupies memory, and when you accessed the element beyond the end, you were reading whatever value happened to occupy that memory. It's <em>possible</em> that that address doesn't belong to your process, but it probably is, and so it's generally safe to read the <code>sizeof(string)</code> bytes that reside in that space.</p>

<p>Your program read from it and, since it was reading it through a <code>string</code> array, it treated that memory as though it were a real <code>string</code> object. (Your program can't tell the difference. It doesn't know any better. It's just trying to carry out your instructions.) Apparently, whatever data happened to be there looked enough like a real <code>string</code> object that your program was able to treat it like one, at least long enough to make a copy of it in the <code>vector</code> and then print its (empty) value. It worked this time, but that doesn't mean it will work every time.</p>

<p>There was no such luck with the data in the ""eighth"" position of the array. It did not look enough like a valid <code>string</code> object. A <code>string</code> object usually contains a pointer to the character data, along with a length. Maybe the area of the object that would normally represent that pointer didn't contain a valid address for your program. Or maybe the part that represented the length field contained a value far larger than what was available at the address in the pointer.</p>
",0
1123566,1123558,4,"<p>You should qualify <code>Node</code>:</p>

<pre><code>BinarySearchTree::Node* BinarySearchTree::Search(int val);
</code></pre>
",0
839700,839644,32,"<p>Streams by default do not throw exceptions on error, they set flags. You can make them throw exceptions by using the stream's exception() member function:</p>

<pre><code>ifstream ifs;
ifs.exceptions( std::ios::failbit );   // throw if failbit get set
</code></pre>

<p>Theoretically, you could then do something like this:</p>

<pre><code>try {
  int x;
  ifs &gt;&gt; x;
}
catch( const std::exception &amp; ex ) {
   std::cerr &lt;&lt; ""Could not convert to int - reason is "" 
                  &lt;&lt; ex.what();
}
</code></pre>

<p>Unfortunately, the C++ Standard does not specify that thrown exceptions contain any error message, so you are in implementation specific territory here.</p>
",0
839703,839644,10,"<p>Short answer: no. Even checking <code>errno</code> after you detect failure (using e.g. <code>bad()</code>, <code>fail()</code>) after various operations doesn't reliably work. Creating an <code>ifstream</code>/<code>ofstream</code> wrapping a file that can't be opened doesn't necessarily set a failure bit until you try to read, write, or close it.
<p>
Long answer: you can call <code>ios::exceptions(ios_base::iostate)</code> to request that <code>ios_base::ios_failure</code> exceptions be thrown when a corresponding bit (badbit, failbit, eofbit) is set, but this (at least on GNU and Microsoft C++ libraries) doesn't get you any more information than manually checking the bits, and ends up being largely pointless, IMHO.</p>
",0
872971,839644,3,"<p>From checking it out I found that also <code>errno</code> and also <code>GetLastError()</code> do set the last error and checking them is quite helpful. For getting the string message use:</p>

<pre><code>strerror(errno);
</code></pre>
",2
1787611,1787599,1,"<p>It looks like you are compiling a straight-C++ application using the .NET <code>Int32</code> class to parse a value.</p>

<p>You'll either need to reference the <code>System</code> namespace and CLR support if you are indeed compiling a .NET application, or use a function like <a href=""http://www.cplusplus.com/reference/clibrary/cstdlib/atoi/"" rel=""nofollow noreferrer""><code>atoi()</code></a> to parse your string value.</p>
",0
1787614,1787599,2,"<p><a href=""http://msdn.microsoft.com/en-us/library/f02979c7.aspx"" rel=""nofollow noreferrer"">Int32::TryParse Method</a> is not a native C++ API. Its <a href=""http://en.wikipedia.org/wiki/C%2B%2B/CLI"" rel=""nofollow noreferrer""><code>C++ \CLI</code></a> method.
You will have to use .NET Framework and include the namespace <code>System</code> to get it working.</p>

<p>If you just want to convert the string to integer, you can use: 
<a href=""http://www.cplusplus.com/reference/clibrary/cstdlib/atoi/"" rel=""nofollow noreferrer"">atoi()</a> or refer FAQ : <a href=""http://www.parashift.com/c++-faq-lite/misc-technical-issues.html#faq-39.2"" rel=""nofollow noreferrer"">How do I convert a std::string to a number?</a></p>
",0
1787623,1787599,3,"<p>Try using <a href=""http://www.cplusplus.com/reference/clibrary/cstdlib/atoi/"" rel=""nofollow noreferrer"">atoi()</a> instead. States is a std::string so you will need to say:</p>

<pre><code>numStates = atoi( states.c_str() );
</code></pre>
",1
1414018,1413998,1,"<p>Take look at - <a href=""http://faq.cprogramming.com/cgi-bin/smartfaq.cgi?answer=1044873249&amp;id=1043284392"" rel=""nofollow noreferrer"">http://faq.cprogramming.com/cgi-bin/smartfaq.cgi?answer=1044873249&amp;id=1043284392</a></p>

<pre><code>#include&lt;stdio.h&gt;

int main()
{
    char choice;

    printf(""Do you want to enter a number:"");
    scanf(""%c"",&amp;choice);

    while (choice == 'y')
    {
        while ((choice = getchar()) != '\n' &amp;&amp; choice != EOF);
        printf(""Entered number\n"");
        printf(""Do you want to enter a number:"");
        scanf(""%c"",&amp;choice);
    }

    printf(""End\n"");

    return 0;
}
</code></pre>

<p>DONOT USE : <strong>fflush</strong> <a href=""http://faq.cprogramming.com/cgi-bin/smartfaq.cgi?answer=1052863818&amp;id=1043284351"" rel=""nofollow noreferrer"">Why fflush(stdin) is wrong</a></p>
",0
1331708,1331696,16,"<p>This is called a forward declaration.  It means that there IS a class named CFoo, that will be defined later in the file (or another include).  This is typically used for pointer members in classes, such as:</p>

<pre><code>class CFoo;
class CBar {
    public:
        CFoo* object;
};
</code></pre>

<p>It is a hint to the C++ compiler telling it not to freak out that a type name is being used without being defined, even though it hasn't seen the full definition for CFoo yet.</p>
",2
1331709,1331696,1,"<p>It's called a forward declaration.</p>

<p><a href=""http://en.wikipedia.org/wiki/Forward_declaration"" rel=""nofollow noreferrer"">http://en.wikipedia.org/wiki/Forward_declaration</a></p>
",0
1331710,1331696,1,"<pre><code>class CFoo;
</code></pre>

<p>Is just a declaration that the class exists; even if you haven't seen the definition yet, you can still play with (CFoo *) or (CFoo &amp;) - that is, pointers and references to CFoo.</p>
",2
873755,873745,-1,"<p>Because in most cases, you'll want to use the class somewhere besides the file in which you implement it.  If you make the whole program in one file, you don't need the separation.</p>

<p>You hardly ever want to write a C++ program all in one file.</p>
",7
873757,873745,5,"<p>Well, one of the benefits of having the code this way is that it reduces compile time.</p>

<p>Let's say you have these files on your project:</p>

<ul>
<li>a.h</li>
<li>a.cpp</li>
<li>b.cpp</li>
</ul>

<p>If you already have a.cpp compiled into an object file <strong>a.o</strong>, then if you include <strong>a.h</strong> in <strong>b.cpp</strong>, compilation should be quicker because parser won't have to deal with the whole declaration/definition of <strong>a</strong>.</p>
",0
873759,873745,25,"<p>C++ has something called the One Definition Rule. It means that (excluding inline functions), definitions can only appear in one compilation unit. Since C++ header files are just ""copy and pasted"" at every include file, now you are putting definitions in multiple places if you just put the definitions in header files.</p>

<p>Of course, you may say, why not make everything inline. Well, if the compiler respects your inline suggestion, code for long functions will be replicated at every call site, making your code excessively large, and possibly causing thrashing, cache issues, and all sorts of unfun stuff.</p>

<p>On the other hand, if the compiler does not listen to you, and doesn't inline anything, now you have 2 problems: 1) you don't know which translation unit got your classes definitions, and 2) the compiler still has to wade through your definitions every time you #include them. Moreover, there's no easy way to make sure you haven't accidentally defined the same method twice, in 2 different headers, differently.</p>

<p>You also get a circular dependency issue. For a class to invoke another class's method, that class needs to be declared first. So if 2 classes need to invoke each other's methods, each must be declared before either can be defined. There is no way to do this with declarations and definitions in one file.</p>

<p>Really, it's how the language and parser were built. It's a pain, but you just have to deal with it.</p>
",1
873760,873745,2,"<p>Because even within your DLL other classes will use your class. Those files must see the class declaration at compile time, by including the .h. They must not see the definition or there will be multiple definitions of the class functions.</p>
",0
873764,873745,0,"<p>In C++, separate compilation of code modules (.c or .cpp files) require the function prototypes to be defined prior to usage. If you want to use classes or methods defined somewhere else, you have to import the .h files to get their definition. At the end, the linker makes sure all promises made in the .h files can be fulfilled by all c/cpp files. </p>

<p>Also, it allows to created whole frameworks such as boost only by defining .h files.</p>
",1
873852,873745,2,"<p>Your edit re: Boost makes an important distinction.  Template classes are almost always defined in headers because of the way the compiler and linker work in the current C++ standard.  You will find most template libraries (not just Boost) are implemented in header files for the same reason.</p>
",0
873860,873745,4,"<p>Boost doesn't inline all of it's code; it inlines template definitions for classes it expects its consumers to instantiate, like shared_ptr. Many libraries have sections that need to be compiled separately, like boost::serialization and program_options.</p>

<p>Inlining can have severe negative effects as the size of your code base increases. It increases the coupling between your components, not to mention nuking your compile time (which boost does for plenty of other reasons :). Effectively, all of your translational units would have almost a complete copy of the program, and a tiny change would cause you to rebuild/retest everything. On some projects, this could take many, many hours.</p>

<p>I've never really noticed it being harder to edit; in my experience, it makes it easier because of the clear separation of interface and implementation, and I know which file to go to find what I'm looking for.</p>
",1
730924,730910,-1,"<p>The <code>ifstream::open</code> function takes a filename and an optional mode. Since you want to read the whole file, why not just start at the begining:</p>

<pre><code>ifstream obj(cArray);
if (obj) { // file successfully opened for reading
    while (obj.good()) {
        // read in a line at a time
        string line;
        getline(line, obj);
        if (!line.empty()) { // we have something to work with
           // parse
        }
    }
}
</code></pre>

<p>Of course, a sleeker version is to test for <code>getline</code> in the <code>while</code> loop as Neil Butterworth.</p>
",5
730936,730910,7,"<p>Please will you and everyone else note that the correct way to read a text file does NOT require the use of the eof(), good(), bad() or indifferent() functions (OK, I made the last one up). The same is true in C (with fgets(), feof() et al). Basically, these flags will only be set AFTER you have attempted to read something, with a function like getline(). It is much simpler and more likely to be correct to  test that read functions, like getline() have actually read something directly.</p>

<p>Not tested - I'm upgrading my compiler:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;
using namespacr std;

imt main() {

   string filename;
   getline( cin, filename );

   ifstream ifs( filename.c_str() );
   if ( ! ifs.is_open() ) {
       // error
   }

   string line;
   while( getline( ifs, line ) ) {
       // do something with line
   }
}
</code></pre>
",2
1430038,1430026,8,"<p>Because otherwise you would get the number of bytes that words array takes up, not the number of elements (char pointers are either 4 or 8 bytes on Intel architectures)</p>
",2
1430044,1430026,6,"<p><code>sizeof(char*)</code> returns the system's pointer size. sizeof(words) returns the number of bytes in the array. Since each element in the array is <code>sizeof(char*)</code> big, the number of elements is number_of_bytes/bytes_per_element, so <code>sizeof(words)/sizeof(char*)</code>.</p>
",0
1723918,1723419,0,"<p>I would support the decreased binary compatibility here.</p>

<p>The problem I see comes from the direct access to a struct fields.</p>

<pre><code>struct AConfig1 { int a; int b; };
struct AConfig2 { int a; std::map&lt;int,int&gt; b; }
</code></pre>

<p>Since I modified the representation of <code>b</code>, I am screwed, whereas with:</p>

<pre><code>class AConfig1 { public: int getA() const; int getB() const;  /* */ };
class AConfig2 { public: int getA() const; int getB(int key = 0) const; /* */ };
</code></pre>

<p>The physical layout of the object might have change, but my getters have not and the offset to the functions have not either.</p>

<p>Of course, for binary compatibility, one should check out the <a href=""http://en.wikipedia.org/wiki/Opaque_pointer"" rel=""nofollow noreferrer"">PIMPL</a> idiom.</p>

<pre><code>namespace details { class AConfigurationImpl; }

class AConfiguration {
public:
  int getA() const;
  int getB() const;
private:
  AConfigurationImpl* m_impl;
};
</code></pre>

<p>While you do end up writing more code, you have the guarantee here of backward compatibility of your object as long as you add supplementary methods AFTER the existing ones.</p>

<p>The representation of an instance in memory does not depend on the number of methods, it only depends on:</p>

<ul>
<li>the presence or absence of virtual methods</li>
<li>the base classes</li>
<li>the attributes</li>
</ul>

<p>Which is what is VISIBLE (not what is accessible).</p>

<p>And here we guarantee that we won't have any change in the attributes. The definition of <code>AConfigurationImpl</code> might change without any problem and the implementation of the methods might change too.</p>

<p>The more code means: constructor, copy constructor, assignment operator and destructor, which is a fair amount, and of course the getters and setters. Also note that these methods can no longer be inlined, since their implementation are defined in a source file.</p>

<p>Whether or not it suits you, you're on your own to decide.</p>
",0
1723439,1723419,1,"<p>Using this method makes binary compatability harder.</p>

<p>If the struct is changed (one new optional field is added), all code using the class might need a recompile. If one new non-virtual setter function is added, no such recompilation is necessary.</p>
",3
1723443,1723419,2,"<p>The main upside is that the A object can be unmutable.  I don't know if having the AConfiguration stuct actualy gives any benefit over just an a and a b parameter to the constructor.</p>
",0
1723484,1723419,4,"<p>Using this method makes binary compatibility easier.</p>

<p>When the library version changes and if the configuration <code>struct</code> contains it, then constructor can distinguish whether ""old"" or ""new"" configuration is passed and avoid ""access violation""/""segfault"" when accessing non-existant fields.</p>

<p>Moreover, the mangled name of constructor is retained, which would have changed if it changed its signature.  This also lets us retain binary compatibility.</p>

<p>Example:</p>

<pre><code>//version 1
struct AConfiguration { int version; int a; AConfiguration(): version(1) {} };
//version 2
struct AConfiguration { int version; int a, b; AConfiguration(): version(2) {} };

class A {  
   A(const AConfiguration&amp; conf) {
     switch (conf.version){
       case 1: a = conf.a; b = 0;  // No access violation for old callers!
       break;
       case 2: a = conf.a; b = conf.b;  // New callers do have b member
       break;
     }
   }  
};  
</code></pre>
",0
1723520,1723419,7,"<p>Whether you pass the data individually or per struct is a question of style and needs to be decided on a case-by-case basis. </p>

<p>The important question is this: Is the object is ready and usable after construction and does the compiler enforce that you pass all necessary data to the constructor or do you have to remember to call a bunch of setters after construction who's number might increase at any time without the compiler giving you any hint that you need to adapt your code. So whether this is </p>

<pre><code> A(const AConfiguration&amp; conf) : a(conf.a), b(conf.b) {}
</code></pre>

<p>or </p>

<pre><code> A(int a_, int b_) : a(a_), b(b_) {}
</code></pre>

<p>doesn't matter all that much. (There's a number of parameters where everyone would prefer the former, but which number this is - and whether such a class is well designed - is debatable.) However, whether I can use the object like this</p>

<pre><code>A a1(Configuration(42,42));
A a2 = Configuration(4711,4711);
A a3(7,7);
</code></pre>

<p>or have to do this </p>

<pre><code>A urgh;
urgh.setA(13);
urgh.setB(13);
</code></pre>

<p>before I can use the object, <em>does</em> make a huge difference. Especially so, when someone comes along and adds another data field to <code>A</code>. </p>
",0
1057046,1056921,0,"<p>NOTE: This is just an edit of my answer to your previous question, since the two are so similar - you just have to reverse the process.</p>

<hr>

<p>You will first of all have to access each of the colour components (i.e. extract the R value, the G value, and the B value).  The way to do this will depend totally on the way that the colour is stored in memory.  If it is stored as RGB, with 5-6-5 bits for the components, you could use something like this:</p>

<pre><code>blueComponent  = (colour &amp; 0x3F);
greenComponent = (colour &gt;&gt;  6) &amp; 0x3F;
redComponent   = (colour &gt;&gt; 12) &amp; 0x3F;
</code></pre>

<p>This will extract the colour components for you, then you can use the method outlined above to convert each of the components (I presume 18-bit will use 6 bits per component):</p>

<pre><code>blueComponent  = (blueComponent  / 64.0) * 32;
//greenComponent = (greenComponent / 64.0) * 64;    //not needed
redComponent   = (redComponent   / 64.0) * 32;
</code></pre>

<p>Note that with the above code, it is important that you use <em>64.0</em>, or some other method that will ensure that your program represents the number as a floating point number.  Then to combine the components into your 18-bit colour, use:</p>

<pre><code>colour = (redComponent &lt;&lt; 11) | (greenComponent &lt;&lt; 5) | blueComponent;
</code></pre>
",0
728557,728068,8,"<p>You can also use the <a href=""http://www.tin.org/bin/man.cgi?section=3&amp;topic=clock_gettime"" rel=""noreferrer"">clock_gettime</a>. This method can be used to measure:</p>

<ol>
<li>System wide real-time clock</li>
<li>System wide monotonic clock</li>
<li>Per Process CPU time</li>
<li>Per process Thread CPU time</li>
</ol>

<p>Code is as follows:</p>

<pre><code>#include &lt; time.h &gt;
#include &lt;iostream&gt;
int main(){
  timespec ts_beg, ts_end;
  clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &amp;ts_beg);
  clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &amp;ts_end);
  std::cout &lt;&lt; (ts_end.tv_sec - ts_beg.tv_sec) + (ts_end.tv_nsec - ts_beg.tv_nsec) / 1e9 &lt;&lt; "" sec"";
}
</code></pre>

<p>`</p>
",0
728070,728068,129,"<p>See <a href=""http://en.cppreference.com/w/cpp/chrono/c/clock"" rel=""noreferrer""><code>std::clock()</code></a> function.</p>

<pre><code>const clock_t begin_time = clock();
// do something
std::cout &lt;&lt; float( clock () - begin_time ) /  CLOCKS_PER_SEC;
</code></pre>

<p>If you want calculate execution time for self ( not for user ), it is better to do this in clock ticks ( not seconds ).  </p>

<p><strong>EDIT:</strong><br>
responsible header files - <code>&lt;ctime&gt;</code> or <code>&lt;time.h&gt;</code></p>
",7
728086,728068,5,"<p>Just a side note: if you're running on Windows, and you really really need precision, you can use <a href=""http://msdn.microsoft.com/en-us/library/ms979201.aspx"" rel=""noreferrer"">QueryPerformanceCounter</a>. It gives you time in (potentially) <strong>nano</strong>seconds.</p>
",0
728092,728068,4,"<p>Get the system time in milliseconds at the beginning, and again at the end, and subtract.</p>

<p>To get the number of milliseconds since 1970 in POSIX you would write:</p>

<pre><code>struct timeval tv;

gettimeofday(&amp;tv, NULL);
return ((((unsigned long long)tv.tv_sec) * 1000) +
        (((unsigned long long)tv.tv_usec) / 1000));
</code></pre>

<p>To get the number of milliseconds since 1601 on Windows you would write:</p>

<pre><code>SYSTEMTIME systime;
FILETIME filetime;

GetSystemTime(&amp;systime);
if (!SystemTimeToFileTime(&amp;systime, &amp;filetime))
    return 0;

unsigned long long ns_since_1601;
ULARGE_INTEGER* ptr = (ULARGE_INTEGER*)&amp;ns_since_1601;

// copy the result into the ULARGE_INTEGER; this is actually
// copying the result into the ns_since_1601 unsigned long long.
ptr-&gt;u.LowPart = filetime.dwLowDateTime;
ptr-&gt;u.HighPart = filetime.dwHighDateTime;

// Compute the number of milliseconds since 1601; we have to
// divide by 10,000, since the current value is the number of 100ns
// intervals since 1601, not ms.
return (ns_since_1601 / 10000);
</code></pre>

<p>If you cared to normalize the Windows answer so that it also returned the number of milliseconds since 1970, then you would have to adjust your answer by 11644473600000 milliseconds. But that isn't necessary if all you care about is the elapsed time.</p>
",0
728141,728068,30,"<p>I would seriously consider the use of Boost, particularly boost::posix_time::ptime and boost::posix_time::time_duration (at <a href=""http://www.boost.org/doc/libs/1_38_0/doc/html/date_time/posix_time.html"" rel=""noreferrer"">http://www.boost.org/doc/libs/1_38_0/doc/html/date_time/posix_time.html</a>).</p>

<p>It's cross-platform, easy to use, and in my experience provides the highest level of time resolution an operating system provides. Possibly also very important; it provides some very nice IO operators.</p>

<p>To use it to calculate the difference in program execution (to microseconds; probably overkill), it would look something like this [browser written, not tested]:</p>

<pre><code>ptime time_start(microsec_clock::local_time());
//... execution goes here ...
ptime time_end(microsec_clock::local_time());
time_duration duration(time_end - time_start);
cout &lt;&lt; duration &lt;&lt; '\n';
</code></pre>
",1
728153,728068,6,"<p>just in case you are on Unix, you can use <code>time</code> to get the execution time:</p>

<pre><code>$ g++ myprog.cpp -o myprog
$ time ./myprog
</code></pre>
",0
728473,728068,12,"<p>In Windows: use <a href=""http://msdn.microsoft.com/en-us/library/ms724408(VS.85).aspx"" rel=""noreferrer"">GetTickCount</a></p>

<pre><code>//GetTickCount defintition
#include &lt;windows.h&gt;
int main()
{

    DWORD dw1 = GetTickCount();

    //Do something 

    DWORD dw2 = GetTickCount();

    cout&lt;&lt;""Time difference is ""&lt;&lt;(dw2-dw1)&lt;&lt;"" milliSeconds""&lt;&lt;endl;

}
</code></pre>
",2
1419453,1419449,1,"<p>Yes, that's exactly what you do: read from <code>stdin</code> and write to <code>stdout</code>.</p>

<p>One of the strokes of genius behind linux is the simplicity of redirecting input and output almost effortlessly, as long as your apps obey some very simple, basic rules.  For example: send data to <code>stdout</code> and errors or informational messages to <code>stderr</code>.  That makes it easy for a user to keep track of status, and you can still use your app to send data to a pipe.</p>

<p>You can also redirect data (from <code>stdout</code>) and messages (from <code>stderr</code>) independently:</p>

<pre><code>myapp | tail -n 5 &gt; myapp.data # Save the last 5 lines, display msgs
myapp 2&gt; myapp.err | sort      # Sort the output, send msgs to a file
myapp 2&gt; /dev/null             # Throw msgs away, display output
myapp &gt; myapp.out 2&gt;&amp;1         # Send all output (incl. msgs) to a file
</code></pre>

<p>Redirection may be a bit confusing at first, but you'll find the time spent learning will be well worth it!</p>
",0
952923,952907,7,"<p>My rule of thumb is: If it's not a really simple structure (e.g. <code>Point</code> and <code>Complex</code>) implement it as accessors to private member variables. And if you are not sure if your structure is simple enough, it probably isn't ;) ..</p>

<p>This way, you always have the option to extend the logic of setting/getting the variable without breaking existing code. Yes, it might be a little more work to implement the accessors in the first place, but it's much much much more work to modify the code to accessors if it was a direct variable access before.</p>
",0
952925,952907,2,"<p>Always.  Never make a member variable public.  There is no advantage to it: you can always make your get and set methods inline.</p>
",7
952930,952907,1,"<p>This is a matter of encapsulation.  You generally do not want to expose member variables to the caller as then you lose significant control over the state of the object.  Classes with strong, simple interfaces and no exposed fields are easier to maintain, debug, and scale.</p>
",0
952949,952907,3,"<p>The only time to use public member variables is when the class is just a ""bag of bits"". This means there is absolutely no chance that you will ever have to add an invariant. In that case, you should probably use a <code>struct</code>.</p>
",0
952963,952907,4,"<p>Using an accessor will enforce the client to treat the members as functions, not as raw memory. For instance it will not allow taking the address of said member. So even if the member is as POD as a simple int I still use a get-set pair of function for it. This pays of in the long run as refactoring can change the implementation w/o surprises like 'oh wait, I was taking a void* to your member'. </p>

<p>Performance wise all compiler will inline this set/get accessors and the assembly will look just as if referencing a public member field.</p>

<p>I don't think in the past 5 years I ever wrote a class that exposed its members public.</p>
",8
953220,952907,1,"<p>I think there are two important questions to ask about your data to make that decision:
1) is the data bounded by certain ranges of values?
and
2) does the class depend on the consistency of the state of the data from one operation to another?
If you answer ""yes"" to either of those questions than you had better use accessors and mutators.</p>

<p>For example, let's say you have a class representing a point in 2D space.  If you can set that point to any arbitrary location then there is no reason to make that data private.  But now lets say that the points have to be on a graph from [-100,-100] to [100,100].  In that case you would want to limit the values that the point can be assigned to (case 1).</p>

<p>Another example (this one is a little contrived): you have a class that represents a priority queue and you are storing the minimum value in a variable.  If you change the value of that variable then it may no longer be the minimum value in which case you need to re-order the heap.  Since the state of the heap depends on the value of that variable, you need to limit its access (either but not allowing it to be modified, or when it is modified re-ordering the heap as necessary).</p>
",0
953241,952907,1,"<p>Make your data private in your class whenever it would be possible for an object of your class to be screwed up if a client changed that data, or you don't want clients dependent on your implementation of the class.</p>

<p>Which translates to ""almost always.""</p>
",0
955953,952907,0,"<p>While most answers focus on the design / encapsulation standpoint (and I agree to the general consensus, ""why not use setter / getter?""). I'd like to add that once you've hunted for a bug in some large legacy code bases, with public members, you'll never, ever, EVER, write a class without setter / getters.</p>

<p>Imagine the following: you have a large codebase (talking over 1M+ lines of code), where a lot of highly optimized legacy code passes pointers around, does bit twiddling etc. etc.</p>

<p>Now, after hours of debugging, you found that a certain member is in an inconsistent state, you're wondering ""hmm, this causes the bug, now how did this member get that value...""</p>

<p>1) setter/getters: you put a breakpoint, 5 minutes later, bug is solved</p>

<p>2) public member: you're in for hours and hours of annoying detective work </p>

<p>Public members: don't do it, no gain, only potential pain</p>
",0
1509070,1509059,7,"<p>For this kind of thing I recommend:</p>

<p><a href=""https://rads.stackoverflow.com/amzn/click/com/0321113586"" rel=""noreferrer"" rel=""nofollow noreferrer"">C++ Coding Standards: 101 Rules, Guidelines, and Best Practices</a></p>
",0
1509082,1509059,14,"<p>You're probably looking for C++ ""best practices"", not ""laws"". This should help you searching on the net.</p>

<p>Moreover, there's a book called ""C++ Coding Standards: 101 Rules, Guidelines, and Best Practices"" by Herb Sutter and Andrei Alexandrescu which is supposed to be good, but I haven't read it myself. You can order it, e.g., over at <a href=""https://rads.stackoverflow.com/amzn/click/com/0321113586"" rel=""noreferrer"" rel=""nofollow noreferrer"">amazon.com</a>.</p>
",1
1509430,1509059,1,"<p>Well, it seems everyone agree on the value of Herb Sutter and Andrei Alexandrescu's amazing book.</p>

<p><a href=""https://rads.stackoverflow.com/amzn/click/com/0321113586"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">C++ Coding Standards</a> is a most interesting read. The items are grouped very logically, and each item is detailed just enough that you understand the risk for not heeding the advice. Also each item comes with possible exception to the rule and why they are exception.</p>

<p>All in all it is a very valuable asset to one trying to put in place a number of practices, especially when installing code reviews.</p>

<p>There is another 'book' though only available in PDF / HTML format as far as I know. It is a mash-up of several standards referenced</p>

<p><a href=""http://www.codingstandard.com/HICPPCM/index.html"" rel=""nofollow noreferrer"">High Integrity C++</a> is also very interesting in that it qualifies the items (Rule / Guideline distinction) and sometimes offer alternatives (two mutually exclusive advices). It is much more detailed than C++ coding standards so you might want to read it in second position :)</p>

<p>You can obtain the PDF version <a href=""http://www.codingstandard.com/HICPP_MANUAL_REQUEST.htm"" rel=""nofollow noreferrer"">here</a>, they will send it to you by email.</p>
",0
1510152,1509059,5,"<p>I also find Scott Myers' ""Effective C++"" series very useful, written in a very readable and memorable style.</p>
",0
839864,839856,3,"<p>There is no way to do this in native C++, as it would be highly platform dependent. On Linux/UNIX, you can do this with <a href=""http://linux.die.net/man/2/flock"" rel=""nofollow noreferrer""><code>flock</code></a> or <a href=""http://linux.die.net/man/2/fcntl"" rel=""nofollow noreferrer""><code>fcntl</code></a>. I'm not really sure how to do it on Windows.</p>

<p>On windows, it looks like you have to pass some flags to <a href=""http://msdn.microsoft.com/en-us/library/aa363858.aspx"" rel=""nofollow noreferrer""><code>CreatFile</code></a> or use <a href=""http://msdn.microsoft.com/en-us/library/aa365203.aspx"" rel=""nofollow noreferrer""><code>LockFileEx</code></a> (which allows byte range locking).</p>

<p>Note that, all of these methods work on the underlying OS file descriptors/handles, not with <code>fstream</code>s. You will either need to use the Posix or Windows API to read/write from the file, or wrap the file descriptor/handle in an <code>fstream</code>. This is platform dependent again. I'm sure there is a way to do it, but I don't remember it off the top of my head.</p>
",1
839897,839856,17,"<p>You cannot do it with the standard fstream, you'll have to use platform specific functions.</p>

<p>On Windows, you can use <a href=""http://msdn.microsoft.com/en-us/library/aa363858(VS.85).aspx"" rel=""noreferrer"">CreateFile()</a> or <a href=""http://msdn.microsoft.com/en-us/library/aa365203.aspx"" rel=""noreferrer"">LockFileEx()</a>. On Linux, there is <a href=""http://linux.die.net/man/2/flock"" rel=""noreferrer"">flock()</a>, <a href=""http://linux.die.net/man/3/lockf"" rel=""noreferrer"">lockf()</a>, and <a href=""http://linux.die.net/man/2/fcntl"" rel=""noreferrer"">fcntl()</a> (as the previous commenter said).</p>

<p>If you are using MSVC, you can pass a third parameter to fstream's constructor. See the documentation for <a href=""http://msdn.microsoft.com/en-us/library/aa243822(VS.60).aspx"" rel=""noreferrer"">Visual Studio 6</a> or <a href=""http://msdn.microsoft.com/en-us/library/8et8s826.aspx"" rel=""noreferrer"">newer versions</a>. Of course it won't work with other compilers and platforms.</p>

<p>Why do you want to lock others out anyway? There might be a better solution...</p>
",1
1987460,1987448,5,"<p>You can initialize an array of characters....   </p>

<pre><code>char a[] = ""hello"";
</code></pre>
",6
1987575,1987448,2,"<p>By and large, <strong>you <em>can</em> make simple tasks less tedious</strong>.  For example, use smart pointers such as auto_ptr, boost::shared_ptr, or scoped_ptr and you won't have to call delete yourself.  Use functions such as std::fill, specify the initializer for arrays, or use a different type (caveats and examples below, and more functionality available in C++0x).</p>

<pre><code>struct A {
  char s[20];
  A() : s() { assert(s[0] == '\0'); /*always true*/ }
  // you can only use the ""default ctor"", in this case char(), which is equal
  // to '\0'
};
// of course, if the item type of the array has a non-trivial ctor, it will
// always be called for each item even if you leave the array member out of
// the ctor init list
</code></pre>

<pre><code>struct B {
  char s[20];
  B() { std::fill(s, s + boost::size(s), 'a'); s[boost::size(s)-1] = '\0'; }
  // and if this is common, write your own function
  // even make it a private static function if it's only used within this class
  // (e.g. each ctor calls it, or several methods do)
private:
  template &lt;int N>
  static void fill_null_term(char (&a)[N], char value) {
    // fill and null terminate
    fill(a, a + N - 1, value);
    a[N-1] = '\0';
  }
  // notice two things:
  // 1) certainly possible to pull this out of the class as required
  // 2) don't hardcode constants, use the type system to your advantage
  //    (passing the array length) when possible
};
</code></pre>

<pre><code>struct C {
  std::string s;
  C() : s(19, 'a') {}
  // mentioned last, but this would really be the first solution you use;
  // refactoring to something else, such as A and B, as requirements change
  // or are more clearly defined
};
</code></pre>
",0
1988547,1987448,0,"<p>Since you've tagged your question as C++, consider following:</p>

<pre><code>class x
{
public:
    explicit x(const std::string &amp;str)
        : str_(str)
    {}

    explicit x(const char *str)
        : str_(str ? str : """")
    {}

    ~x() {}

private:
    std::string str_;
};
</code></pre>

<p>Don't see how C++ would make me be too explicit in any way. Yes, <code>std::string</code> is not exactly an array of characters, but, ask yourself, do you <em>really</em> need it? I wouldn't expect <code>std::string</code> to perform considerably worse than a char array in probably 99% of possible use cases. So, don't make your life complicated, use the good things that C++ provides you, not the things left for C compatibility, unless you absolutely need to and know what you're doing.</p>

<p><strong>EDIT:</strong> Ah, I see, the <code>explicit</code> keyword adds ""explicitness"" to C++ :) Keep forgetting it on a first round of typing.</p>
",1
1988803,1987448,0,"<p>Here's a simpler C++ version, which looks almost exactly like your C# sample:</p>

<pre><code>class loai { 
public:
  std::vector&lt;char&gt; a;
  loai(const std::vector&lt;char&gt;&amp; a) : a(a) {}
};
</code></pre>

<p>Of course you can make everything awfully complicated by using the wrong datatypes, regardless of language. In C++, plain arrays are very simple types, and so in many cases, something like <code>std::vector</code> is more convenient to use.</p>
",0
1601486,1601457,7,"<p>You can't ""put"" objects of a class that has pure virtual functions(because you can't instantiate it). Maybe you mean:</p>

<pre><code>// store a pointer which points to a child actually.
typedef list&lt;ILesson*&gt; TLessonList;
</code></pre>

<hr>

<p>OK, as others pointed out, you have to make <code>PrintLessonName</code> a <code>const</code> member function. I would add that there is another small pitfall here. <code>PrintLessonName</code> must be <code>const</code> in both the <code>base</code> and the <code>derived</code> classes, otherwise they will <strong>not</strong> have the same signature:</p>

<pre><code>class ILesson
{
public:
    virtual void PrintLessonName() const = 0;
    virtual ~ILesson() {}
};


class SomeLesson : public ILesson
{
public:
    // const is mandatory in the child
    virtual void PrintLessonName() const
    {
        //
    }
    virtual ~SomeLesson() {}
};
</code></pre>

<p>To be honest, I find <a href=""https://stackoverflow.com/questions/1601457/c-interfaces-in-stllist/1601534#1601534"">Jerry Coffin's</a> answer helpful for redesigning the printing functionality.</p>
",4
1601489,1601457,1,"<p><strong>You call a non-const method for a const object refered through a reference to const object.</strong></p>

<p>Anyways:</p>

<p>I'm 100% sure you need to have a list of pointers:</p>

<pre><code>typedef list&lt;ILesson*&gt; TLessonList;
</code></pre>

<p>in order to take advantage of polymorphism.</p>

<p>Having a list of values of ILesson is not possible, since ILesson is an abstract class.</p>

<p>Don't forget to delete the objects in the list of pointers, to avoid memory leaks.</p>
",0
1601490,1601457,3,"<p>Use <code>iterator</code> instead of <code>const_iterator</code> or make <code>PrintLessonName()</code> const function:</p>

<pre><code>virtual void PrintLessonName() const = 0
</code></pre>
",7
1601493,1601457,10,"<p>PrintLessonName must be declared as const to be able to be called on const ILessons. Otherwise the compiler assumes it may modify the ILesson and prevents the call.</p>

<pre><code>virtual void PrintLessonName() const = 0;
</code></pre>
",0
1601502,1601457,3,"<p>You have to make PrinLessonName const.</p>

<pre><code>virtual void PrintLessonName() const = 0;
</code></pre>

<p>Or not use a const_iterator, of course.</p>
",0
1601534,1601457,3,"<p>You want a list of pointers to ILesson's.</p>

<p>IMO, you'd also be considerably better off adding something like:</p>

<pre><code>std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, ILesson const *il) { 
    il-&gt;PrintLessonName(os);
    return os;
}
</code></pre>

<p>Then, instead of the loop you've written above, you can use something like:</p>

<pre><code>std::copy(lessons.begin(), lessons.end(), 
          std::ostream_iterator&lt;ILesson *&gt;(std::cout));
</code></pre>

<p>As you can see, I've added one other minor embellishment in the process -- PrintLessonName takes a stream as its argument, instead of always printing to the same place. Of course, if you're not using streams, you may not want that...</p>

<p>Edit: Of course the other comments that you want to make PrintLessonPlan const are also correct...</p>
",0
1601588,1601457,0,"<p>People are correct about the lack of const.
I'd favour using the for_each algorithm this will prevent calling lessons.end() for every entry.</p>

<pre><code>#include &lt;algorithm&gt; //for for_each()
</code></pre>

<p>Then use this:</p>

<pre><code>std::for_each(  lessons.begin(), lessons.end(), std::mem_fun(&amp;ILesson::PrintLessonName) )
</code></pre>
",0
1601703,1601457,1,"<p>A version like this:</p>

<pre><code>for (TLessonList::const_iterator i=lessons.begin(), m=lessons.end();  i!=m;  ++i)
    {
        i-&gt;PrintLessonName();
    }
</code></pre>

<p>lessons.end() gets called once, and also note ++i instead of i++, which is faster (the post-increment operator involves creation of a temporary object, while the pre-increment doesn't).</p>
",0
959968,959951,3,"<p>When you define and initialize a pointer to char like this:</p>

<pre><code>char * word = ""hello"";
</code></pre>

<p>you are actually telling the compiler to put the fixed string ""hello"" into a fixed piece of storage somewhere and then create the <code>word</code> pointer variable to point at it.</p>

<p>Although you change change the <code>word</code> variable to point at something else and if it did point at some mutable storage you could change what it points to via * and [] operators, you are not allowed to change the fixed string ""hello"" through it.</p>

<p>C++ allows assigning a fixed string to a pointer to non-const <code>char</code> purely for backwards compatibility. It is much better to only assign these strings to pointers to <code>const char</code>. e.g.</p>

<pre><code>const char * word = ""hello"";
</code></pre>

<p>This way you prevent causing illegal run time behaviour through compile time type checks.</p>

<p>Edit:</p>

<p>In your example there is essentially no externally visible difference between having the local variable declared static and not. This affects the life time of the pointer variable in each function. It does not affect the lifetime of the fixed strings that the pointer variables point at. As the functions return the <em>value</em> of the pointer variable (in C++ returns are always by value), it doesn't particularly matter whether the pointer variable in the function is destroyed at the end of the function or not. The strings themselves will always live beyond the scope of the function as string literals have static storage duration.</p>
",0
959971,959951,0,"<p>Your static is a const string literal.  You should not modify it.  Some compilers might allow you to.  If instead your static was a std::string, then you would be able to modify it from the caller.</p>
",0
959972,959951,20,"<p>The two functions are not itself illegal. First, you in both case return a copy of a pointer, which points to an object having static storage duration: The string literal will live, during the whole program duration. </p>

<p>But your <code>main</code> function is all about undefined behavior. You are not allowed to write into a string literal's memory :) What your main function does can be cut down to equivalent behavior</p>

<pre><code>""hello""[0] = '5';
""why am I not legal?""[0] = '5';
</code></pre>

<p>Both are undefined behavior and on some platforms crash (good!). </p>

<p><strong>Edit</strong>: Note that string literals have a const type in C++ (not so in C): <code>char const[N]</code>. Your assignment to a pointer to a non-const character triggers a deprecated conversion (which a good implementation will warn about, anyway). Because the above writings to that const array <em>won't</em> trigger that conversion, the code will mis-compile. Really, your code is doing this</p>

<pre><code>((char*)""hello"")[0] = '5';
((char*)""why am I not legal?"")[0] = '5';
</code></pre>

<p>Read <a href=""https://stackoverflow.com/questions/308279/c-strings-vs/308724#308724""><code>C++ strings: [] vs *</code></a></p>
",0
959984,959951,4,"<p>Only the pointer is static and it points to a constant string. Doing  leg[ 0 ] = '5' is not ok as it modifies the constant string.</p>

<p>static make little difference in this case, this is really the same:</p>

<pre><code>char* alsoNotLegal()
{
     return ""why am I not legal?"";
}
</code></pre>
",1
959992,959951,0,"<p>From <a href=""http://en.wikipedia.org/wiki/Static_variable"" rel=""nofollow noreferrer"">wikipedia</a>:</p>

<blockquote>
  <p>In the C programming language and its
  descendants, the term static variable
  has at least two specific and
  essentially unrelated meanings, each
  related to the semantics of C's static
  keyword:</p>
  
  <ol>
  <li><p>static local variables, which are scoped normally, but have static
  storage duration (as opposed to
  automatic local variables declared
  with the auto keyword)</p></li>
  <li><p>static global variables, which have the usual static storage duration, but
  are scoped to the file in which they
  are defined (as opposed to external
  variables declared with the extern
  keyword)</p></li>
  </ol>
</blockquote>

<p>So. The static variables you are declaring are scoped normally - their scope is still within their respective functions, and are not available outside of those functions.</p>

<p>You can still return the pointers, but they don't really mean anything.</p>

<p>Edit:</p>

<p>Also from <a href=""http://en.wikipedia.org/wiki/Local_variable#Static_local_variables"" rel=""nofollow noreferrer"">this page</a>:</p>

<blockquote>
  <p>Static locals in global functions can
  be thought of as global variables,
  because their value remains in memory
  for the life of the program.<a href=""http://en.wikipedia.org/wiki/Static_variable"" rel=""nofollow noreferrer"">1</a> The
  only difference is that they are only
  accessible (i.e., scoped) to one
  function.</p>
</blockquote>
",0
959994,959951,0,"<p>Works for me...?</p>

<pre><code>#include&lt;iostream&gt;
using namespace std;

char* legal() {
    char* word = ""helllo"";
    return word;
}

char* alsoLegal() {
    static char* word = ""hello!"";
    return word;
}

int main(){

    cout &lt;&lt; legal() &lt;&lt; endl;
    cout &lt;&lt; alsoLegal() &lt;&lt; endl;
    return 0;
}
</code></pre>

<p>But as already noted in a comment in your question, we're returning pointers rather then references, which is its just a char&amp;, you'll justget the first letter of the ""string"". </p>
",0
960017,959951,2,"<p>What you probably wanted was:</p>

<pre><code>char* alsoNotLegal()
{
    static char[] word = ""why am I not legal?"" ;
 // static char*        x = ""X""; &lt;- Not good.
 // static const char*  y = ""Y""; &lt;- Good. As the compiler will warn you about
 //                                       Illegal attempts to modify it.

    return word ;
}
</code></pre>

<p>Note: Here you are creating an array 'word' of characters and copying ""why am I not legal?"" into the array. You are allowed to make changes to the array.  </p>

<p>Also because of the way arrays are handled by the language, they will de-generate into pointers at the drop of a hat, when you return an array (or pass it as a parameter) it will auto convert into a pointer. </p>
",0
960106,959951,1,"<p>These ""instant"" strings are stored in a READ-ONLY ""r"" section of the PE on Windows. This is why you get an OS exception when you try to write to that location.</p>

<p>If you have Ollydbg or if you read the disassembly output, you can see that the strings are in the RDATA section (Read-only data section).
If it was a regular string stored on the heap, there would be no problem</p>

<pre><code>char* alsoNotLegal()
{
  static char word[] = ""why am I not legal?"" ;
  return word ;
}
</code></pre>

<p>This will work because the string will be stored on the ""heap"", a read/write section of your executable image.</p>
",0
1911032,1911018,2,"<p>Quoted from the accepted answer on a <a href=""https://stackoverflow.com/questions/213907/c-stdendl-vs-n"">related question</a>:</p>
<blockquote>
<p>The varying line-ending characters don't matter, assuming the file is open in text mode, which is what you get unless you ask for binary. The compiled program will write out the correct thing for the system compiled for.</p>
<p>The only difference is that std::endl flushes the output buffer, and '\n' doesn't. If you don't want the buffer flushed frequently, use '\n'. If you do (for example, if you want to get all the output, and the program is unstable), use std::endl</p>
</blockquote>
<p>In your case, since you specifically want <code>&lt;CR&gt;&lt;LF&gt;</code>, you should explicitly use <code>\r\n</code>, and then call <code>std::flush()</code> if you still want to flush the output buffer.</p>
",4
1911039,1911018,0,"<p>Looks like your question got munged. Each command ends in []? For an over-the-wire protocol, I'd suggest using a delimiter that doesn't vary by platform. std::endl could resolve to '\r\n' or '\n\r' depending on the platform. </p>
",1
1911041,1911018,4,"<p>Use <code>stream &lt;&lt; ""\r\n""</code> (and open the stream in binary mode). <code>stream &lt;&lt; std::endl;</code> is equivalent to <code>stream &lt;&lt; ""\n"" &lt;&lt; flush;</code>. The ""\n"" might be converted to a ""\r\n"" if the code runs on Windows, but you can't count on it -- at least one Windows compiler converts it to ""\n\r"". On a Mac, it's likely to be converted to ""\r"" and on Unix/Linux and most similar systems, it'll be left as just a ""\n"".</p>
",6
1911066,1911018,7,"<p>The C++ standard says that it:</p>

<blockquote>
  <p>Calls os.put(os.widen(¡¯\n¡¯) ), then
  os.flush()</p>
</blockquote>

<p>What the '\n' is converted to, if it is converted at all, is down to the stream type it is used on, plus any possible mode the stream may be opened in.</p>
",0
1911279,1911018,12,"<p>The code:</p>

<pre><code>stream &lt;&lt; std::endl;

// Is equivalent to:

stream &lt;&lt; ""\n"" &lt;&lt; std::flush;
</code></pre>

<p>So the question is what is ""\n"" mapped too.<br>
On normal streams nothing happens. But for file streams (in text mode) then the ""\n"" gets mapped to the platfrom end of line sequence. Note: The read converts the platform end of line sequence back to a '\n' when it reads from a file in text mode.</p>

<p>So if you are using a normal stream nothing happens. If you are using a file stream, just make sure it is opened in binary mode so that no conversion is applied:</p>

<pre><code>stream &lt;&lt; ""\r\n""; // &lt;CR&gt;&lt;LF&gt;
</code></pre>
",0
1484741,1484739,3,"<p>If you do <code>new &lt;type&gt;[]</code> you must do <code>delete []</code>. It's a simple enough rule, and worth remembering.</p>
",0
1484742,1484739,5,"<p>If you allocate an array of objects using the <code>new []</code> operator then you must use the <code>delete []</code> operator and therefore the non-array <code>new</code> can only be used with the non-array <code>delete</code>.</p>

<pre><code>int *a = new int[10];
int *b = new int;

delete [] a;
delete b;
</code></pre>
",0
1484743,1484739,9,"<p>It's:</p>

<pre><code>delete[] foo;
</code></pre>

<p><strong>Edit: Modern compilers really need you to use the correct <code>delete</code> operator, or they may leak memory or fail to run the proper destructors.</strong></p>

<p>(I earlier stated that it didn't make a difference in practice. About 10 years ago, I tried many different compilers and failed to find one that actually leaked memory if you mistakenly omitted the <code>[]</code>. However the howls of the mob - see below - have forced me to re-try my experimentation, and it seems that modern compilers/libc++s really do care.)</p>
",7
1484770,1484739,2,"<p>You walked in the front door and left it open. Then you walked through to the back door and tried to close it but you smashed it because it was already closed.</p>

<pre><code>foo = new int [10];  // so when you open the front door
delete [] foo;       // please remember to close the front door.

foo = new int;       // and when you open the back door
delete foo;          // please remember to close the back door.
</code></pre>

<p>Don't mix them up!</p>
",0
1484906,1484739,19,"<p>The requirement to match <code>new[]</code> with <code>delete[]</code> is technically correct.</p>

<p>Much better, however (at least in my opinion), would be to forget that you ever even heard of <code>new[]</code>, and never use it again. I'm pretty sure it's been (at least) 10 years since the last time I used <code>new[]</code>, and if I'd understood the situation very well, I'd have stopped even sooner than that. Pretty nearly any time you'd even consider using <code>new[]</code>, an <code>std::vector</code> (or possibly <code>std::deque</code>) will be a better choice.</p>

<p>If you're trying to create something roughly equivalent to a <code>vector</code> or <code>deque</code> yourself, you don't normally want to use <code>new[]</code> for that either. They way they (at least normally, though it's possible to change this via a custom <code>Allocator</code> class) is to allocate ""raw"" storage with <code>operator new</code> (which is pretty much like <code>malloc</code>--you just give it a size, and it gives you that many bytes of storage). Then you use the placement <code>new</code> operator to create objects in that space, and explicitly invoke the object's destructor to destroy objects in that space.</p>

<p>To give one example, this is what allows <code>std::vector</code> to support <code>reserve</code>, which allows you to allocate extra space, which won't be turned into objects until you call something like <code>push_back</code> or <code>emplace_back</code> to create an actual object in the space you allocated.</p>

<p>When you use <code>new[]</code>, it has to create objects of the specified type filling all the space you allocate. You can't create something like <code>push_back</code> that adds a new object to the collection, because the collection is always already ""full"". All you can do is allocate a new collection that's larger than the old one (so every addition to the collection is O(N) instead of  the amortized O(1) supported by <code>std::vector</code>--a huge loss of efficiency).</p>
",2
1495023,1484739,2,"<p>Anytime you <code>new</code>ed an array you use <code>delete[]</code>. Sometimes you new'ed an array using <code>new</code> - then you still have to use <code>delete[]</code> - no way out. So it's not exactly a rule ""use delete[] when you new[]'ed"" but rather ""use delete[] when deleting an array"". </p>

<pre><code>typedef int array[5];

int *a = new array;
delete[] a; // still delete[] !
</code></pre>
",0
1430922,1430907,3,"<p>If you just change the line</p>

<pre><code>            return putTrianglePosition(render, (Coord *)valueList[i]);
</code></pre>

<p>into:</p>

<pre><code>Coord* vertexList = (Coord*) valueList[i];
</code></pre>

<p>followed by the whole body of what's now <code>putTrianglePosition</code> from the opening <code>{</code> to the closing <code>}</code> included, I believe it should just work. If not, please edit your question to add the exact, complete, code as obtained by this edit and the exact, complete error messages you get.</p>
",0
1430931,1430907,9,"<p>You shouldn't put functions together, you should split them apart. Put a new function wherever you can name them -- try to make them as small as you can. If you want a function that does all of that stuff, have a function that calls the other functions.</p>

<pre><code>int foobar() {

    int a;
    int b;

    /* do a whole bunch of stuff with a */

    /* do a whole bunch of stuff with b */

    return  a + b;

}
</code></pre>

<p>this is sort of what you're trying to do. Instead, do this:</p>

<pre><code>int foo(){

    int a;

    /* do a bunch of stuff with a */

    return a;

}

int bar() {

    int b;

    /* do a bunch of stuff with b */

    return b;

}

int foobar() {

    return foo() + bar();

}
</code></pre>

<p>The result will be cleaner, easier to maintain and re-usable.</p>
",1
1430949,1430907,1,"<p>I strongly recommend you to go with Functions because it allows better separation of logic and allows you to reuse the logic. But still in case if you want to use it that way please check the function below :</p>

<pre><code> int Triangle(Render *render, int numParts, Token *nameList, Pointer *valueList) 
        {
            int iOuter;
            for (iOuter=0; iOuter&lt;numParts; iOuter++)
            {
                switch (nameList[iOuter])
                {
                case GZ_NULL_TOKEN:
                        break;

                case GZ_POSITION:
                        {

                            Coord* vertexList = (Coord*) valueList[i];
                             Coord *pv[3];
                            int i,j;

                            // sort verts by inc. y and inc. x
                            pv[0] = &amp;vertexList[0];
                            pv[1] = &amp;vertexList[1];
                            pv[2] = &amp;vertexList[2];
                            for (i=0; i&lt;2; i++)
                                for (j=i+1; j&lt;3; j++)
                                {
                                        if ((*pv[i])[1]&gt;(*pv[j])[1] || 
                                                (*pv[i])[1]==(*pv[j])[1] &amp;&amp; (*pv[i])[0]&gt;(*pv[j])[0]) {
                                                Coord *tmp;
                                                tmp = pv[i];
                                                pv[i] = pv[j];
                                                pv[j] = tmp;
                                        }
                                }
                            ;

                            // all y the same?
                            if ((*pv[0])[1] == (*pv[2])[1]) {
                                drawHorizonLine(render, *pv[0], *pv[2]);
                                return SUCCESS;  
                            }

                            // assign middle point
                            Coord mid; 
                            mid[1] = (*pv[1])[1];       // y
                            float ratio = ((*pv[1])[1] - (*pv[0])[1]) / ((*pv[2])[1] - (*pv[0])[1]);
                            mid[0] = (*pv[0])[0] + ratio * ((*pv[2])[0] - (*pv[0])[0]); // x
                            mid[2] = (*pv[0])[2] + ratio * ((*pv[2])[2] - (*pv[0])[2]); // z

                            if (mid[0]&lt;=(*pv[1])[0]) {  // compare X
                                drawTrapzoid(render, *pv[0], mid, *pv[0], *pv[1]); // upper tri
                                drawTrapzoid(render, mid, *pv[2], *pv[1], *pv[2]); // lower tri
                            }else{
                                drawTrapzoid(render, *pv[0], *pv[1], *pv[0], mid); // upper tri
                                drawTrapzoid(render, *pv[1], *pv[2], mid, *pv[2]); // lower tri
                            }

                            return SUCCESS;

                        }

                        break;
                }
            }

            return SUCCESS;
        }
</code></pre>
",0
1431762,1430907,1,"<p>Well, since the tag says C++ (even though the code seems to be pure C), the solution would be to put an <code>inline</code> modifier before the function: </p>

<pre><code>inline int putTrianglePosition(Render *render, Coord vertexList[3])
{
  ...
}
</code></pre>

<p>However, even after thinking about this for ten minutes, I still fail a valid reason for wanting this. </p>
",0
1198075,1198044,11,"<p>Yes:</p>

<p><code>STC&lt;</code><strong><code>void (*)()</code></strong><code>&gt; s(foo2, fp); // like this</code></p>

<p>It's the same as taking the <code>typedef</code> declaration and removing the <code>typedef</code> keyword and the name.</p>
",0
1198230,1198044,3,"<p>It is totally possible, 
I'd also recommend looking up boost::function &amp; boost::bind as an alternative solution.</p>
",0
1200578,1198044,0,"<p>I you cannot use boost as Maciek suggested (e.g. you cannot use external libraries in your project) you might try to use a functor.</p>
",0
1496540,1496536,19,"<p><a href=""http://en.cppreference.com/w/cpp/string/byte/strtoul"" rel=""noreferrer""><code>std::strtoul()</code></a> is the one. And then again there are the old ones like <code>atoi()</code>.</p>
",2
1496541,1496536,11,"<p>Boost provides lexical_cast.</p>

<pre><code>#include &lt;boost/lexical_cast.hpp&gt;
[...]
unsigned int x = boost::lexical_cast&lt;unsigned int&gt;(strVal);
</code></pre>

<p>Alternatively, you can use a stringstream (which is basically what lexical_cast does under the covers):</p>

<pre><code>#include &lt;sstream&gt;
[...]
std::stringstream s(strVal);
unsigned int x;
s &gt;&gt; x;
</code></pre>
",3
1496542,1496536,-2,"<p>How about <a href=""http://www.cplusplus.com/reference/clibrary/cstdlib/atoi/"" rel=""nofollow noreferrer"">int <strong>atoi</strong> ( const char * str )</a> ?</p>

<pre><code>string s(""123"");
unsigned u = (unsigned)atoi(s.c_str());
</code></pre>
",1
1496543,1496536,1,"<p><a href=""http://www.cplusplus.com/reference/clibrary/cstdio/sscanf/"" rel=""nofollow noreferrer"">sscanf</a> will do what you want.</p>

<pre><code>char* myString = ""123"";  // Declare a string (c-style)
unsigned int myNumber;   // a number, where the answer will go.

sscanf(myString, ""%u"", &amp;myNumber);  // Parse the String into the Number

printf(""The number I got was %u\n"", myNumber);  // Show the number, hopefully 123
</code></pre>
",2
1069351,1069335,1,"<pre><code>#include &lt;iostream&gt;
using namespace std;

struct A {
  virtual ostream &amp; print( ostream &amp; out ) const {
      return out &lt;&lt; ""A"";
  }
};
</code></pre>

<p>It is common to make a print function virtual, because the &lt;&lt; operator commonly used for stream output cannot be made so (because it is not a member function).</p>
",0
1069367,1069335,1,"<p>some implementation:</p>

<pre><code>ostream&amp; ClassA::print( ostream&amp; out) const
{
    out &lt;&lt; myMember1 &lt;&lt; myMember2;
    return out;
}
</code></pre>

<p>Returning the same ostream allows combinations like</p>

<pre><code>a.print( myStream) &lt;&lt; someOtherVariables;
</code></pre>

<p>However, it is still strange to use it this way.</p>

<p>Regarding the error, ostream is part of std namespace, and not part of the global namespace or the namespace the class you're refering is part of. </p>
",0
1069376,1069335,2,"<p>You probably forgot to include <code>iostream</code> which makes <code>ostream</code> visible. You also need to change this into <code>std::ostream</code>, because C++ standard library names are within the namespace <code>std</code>. </p>

<blockquote>
  <p>Do <strong>not</strong> write <code>using namespace std;</code> in a header-file, ever!</p>
</blockquote>

<p>It's ok to place it into the implementation file, if you want, or if you write up an example for a friend. Because any file that includes that header will have all of the standard library visible as global names, which is a huge mess and smells a lot. It suddenly increases the chance for name-clashes with other global names or other <code>using</code>'ed names - i would avoid using directives at all (see <a href=""http://www.ddj.com/cpp/184401782"" rel=""nofollow noreferrer"">Using me</a> by Herb Sutter).  So change the code into this one</p>

<pre><code>#include &lt;iostream&gt;
// let ScaryDream be the interface
class HereBeDragons : public ScaryDream {
    ...
    // mentioning virtual in the derived class again is not
    // strictly necessary, but is a good thing to do (documentary)
    virtual std::ostream &amp; print( std::ostream &amp; out ) const;
    ...
}; 
</code></pre>

<p>And in the implementation file ("".cpp"")</p>

<pre><code>#include ""HereBeDragons.h""

// if you want, you could add ""using namespace std;"" here
std::ostream &amp; HereBeDragons::print( std::ostream &amp; out ) const {
    return out &lt;&lt; ""flying animals"" &lt;&lt; std::endl;
}
</code></pre>
",0
1128935,1128929,3,"<p>Well you could simply make each function return a bool, then in the loop check if the function returned false. If so break.</p>

<p>You could also throw an error from within the functions, catch it externally and handle it appropriately but I think this is a little extreme. I get the impression you are just looking for an 'exit code' type thing. If this is the case I would suggest simply returning a bool and checking whether you should break out of the loop.</p>

<p><strong>Edit:</strong> So your updated code seems a little complicated, but this is what I was getting at as far as returning a bool goes:</p>

<pre><code>void Name_pairs::read_names()
{
    cout &lt;&lt; ""Enter name: "";
    cin &gt;&gt; name;
    names.push_back(name);
}

bool Name_pairs::read_ages()
{
    cout &lt;&lt; ""Enter corresponding age: "";
    cin &gt;&gt; age;

    if ( age == 0 )
        return false;
    ages.push_back(age);
    cout &lt;&lt; endl;
    return true;
}

// Now we can test if its time to break.
while ( true )
{
    np.read_names();
    if ( !np.read_ages() )
        break;
}
</code></pre>
",2
1128952,1128929,0,"<p>You can have the functions return a value then check the value and break if necessary.</p>

<p>You could also just check the value that's been read in after you call the functions. In this case, it looks like doing if(names.back() == ""something"") or if(ages.back() == 0) would work.</p>

<p>EDIT: </p>

<p>Your general idea is fine(running test() on every iteration of the loop which returns false if your exit condition is met), but there are a couple implementation errors:</p>

<pre><code>   if(ages[bool_counter] = 0 || names[bool_counter] == ""0"")
</code></pre>

<p>You need ""=="" instead of ""="" for the first condition. I bet your compiler warned you about this, you should generally listen to his warnings :). Your current statement is assigning 0 to ages[0] not checking it for being 0.</p>

<p>You should also check the size before attempting to dereference the first element, or you will, as you noted, get errors if ages or names are empty.</p>

<p>So changing that to</p>

<pre><code> if( (ages.size() &gt; 0 ) &amp;&amp; (ages.back() == 0)) ||
     (names.size() &gt; 0) &amp;&amp; (names.back() == ""0""))
</code></pre>

<p>Should work, though I prefer deus's response for clarity.</p>
",2
1128978,1128929,0,"<p>You could explicitly check in <code>test()</code> if <code>ages</code>/<code>names</code> are empty, and only do the ""real"" check if they are not:</p>

<pre><code>bool Name_pairs::test() {
    if (ages.empty() || names.empty())
      return true;
    return (ages.back() != 0) &amp;&amp; (names.back() != ""0"");
}
</code></pre>
",2
1129005,1128929,1,"<p>If you change the problem and view it upside down it becomes quite simple.</p>

<p>Change your setter methods to actually return the value that was just entered.  I also made age a local variable of the method to prevent side effects from creeping :</p>

<pre><code>Double Name_pairs::read_ages()
{
     Double age;
     cout &lt;&lt; ""Enter corresponding age: "";
     cin &gt;&gt; age;
     ages.push_back(age);
     cout &lt;&lt; endl;
     return age;
}
</code></pre>

<p>Then in the loop you can test directly for the returned value :</p>

<pre><code> bool finished = false;
 while(!finished)
 {
   finished = finished || ""0"" == np.read_names();
   finished = finished || 0 == np.read_ages();
 }
</code></pre>

<p>Since you are setting your exit condition in the main (type 0 to exit) it is preferable to test the exit condition there for consistency.  </p>

<p>Is how I see it anyway... code is shorter and easier to understand</p>

<hr>

<p>Edit   I changed the code to reflects comments aem. This way the correct logical operator is used.  As for the cascading evaluation it is quite true that if the first answer was 0 then the second question will not even be asked (finished evaluated to true thus the rest of the or statement will not be evaluated) and as such you must be careful of this (if for example you expect both Vectors to always have the same length).  However I found that usability wise since the user already stated that he wanted to exit I saw no use in asking him the other question.</p>
",5
1129150,1128929,0,"<p>""Break a loop when outside of it?"" - this question doesn't make sense. If you're outside the loop, there's no need to break out of it, because you're already outside of it.</p>

<p>I suggest reading up on the basics, specifically ""sequence"" which is a shared common point of these types of languages.
<a href=""http://javascript.about.com/library/blstruc1.htm"" rel=""nofollow noreferrer"">http://javascript.about.com/library/blstruc1.htm</a></p>

<p>Then you can go on with loops - it's linked on the same page.</p>

<p>Now, this link describes Javascript, but the logic is essentially the same, and the coding style hardly differ at all from other C-type languages.</p>
",1
1129175,1128929,0,"<p>a |= b is a shorthand for a = a | b.
If either a or b is true, then a is true at the end.</p>
",0
1118921,1118905,1,"<p>well all static members must be intialised in a cpp file.  Seeing as BCGateway::instance is not intialised at any point it will be unable to find the symbol.  The problem is, however, that if you create a BCGateway.cpp and initialise the instance then you will end up only having one instance across, potentially, many processes.  This may or may not be a problem depending on how you use the DLL.</p>
",3
1118939,1118905,11,"<p>I put the error through <code>c++filt</code>, it says that the mangled name stands for</p>

<pre><code>BCGateway::instance()
</code></pre>

<p>This suggests that you call <code>BCGateway::instance()</code> somewhere and forgot to link against <code>BCGateway.o</code> or you even forgot to define <code>BCGateway::instance()</code>.</p>
",2
1139815,1139790,1,"<p>You would have to do something like this:</p>

<pre><code>   enum ISBN_begin {
            ZERO, ONE, TWO // etc.
        };
</code></pre>
",0
1139820,1139790,1,"<p>I would suggest using a string for each of the begin/end criteria, ie:</p>

<pre><code>string BeginCriteria = ""0123456789"";
string EndCriteria = ""0123456789abcd... so forth"";

// Now to validate the input    
// for the first three input characters:

if ( BeginCriteria.find( chInput ) != npos )
    // Then its good.

// For the last 3 characters:

if ( EndCriteria.find( chInput ) != npos )
    // Then its good.
</code></pre>
",0
1139823,1139790,0,"<p>If you can't use regular expressions, why not just use an array of char instead?  You could even use the same array, and just have a const index number where the ISBN_last chars begin in the array.</p>
",0
1139831,1139790,0,"<p>enums are not defined with literals, they are defined with variables</p>
",1
1139841,1139790,6,"<p>I think you're going about this the wrong way...why not just use a simple regex that will validate the entire thing a bit more simply?  </p>

<p>(yes, I know, that wasn't the original question, but it might make your life a lot easier.)</p>

<p><a href=""http://regexadvice.com/blogs/dneimke/archive/2003/12/06/179.aspx"" rel=""nofollow noreferrer"">This page</a> and <a href=""http://www.geekzilla.co.uk/viewD8902276-CCD3-4B93-8D27-A7A1908D25D3.htm"" rel=""nofollow noreferrer"">this page</a> provide some good examples on using regex to validate isbn numbers.</p>

<p>I think creating an enumeration whose values are equal to the entities they're enumerating...I think you're doing a lot more than you have to.</p>
",0
1139843,1139790,4,"<p>Why would you want to enumerate numbers? Enums exist to give numbers a name. If you want to store a number, store an integer - or in this case a char (as you also need characters to be stored). For validation, accept a string and write a function like this:</p>

<pre><code>bool ISBN_Validate(string val)
{
    if (!val.length == &lt;length of ISBN&gt;) return false;
    if (val[0] &lt; '0' || val[0] &gt; '9') return false;
    foreach (char ch in val)
    {
        if (ch is not between '0' and 'z') return false;
    }
}
</code></pre>

<p>Easy - and no silly enumerations ;)</p>
",3
1139851,1139790,1,"<p>enums really aren't what you want to use. They aren't sets like that. The members of an enum have to be symbols like variables or function names and you can give them values. </p>

<pre><code>enum numbers { One = 1, Two, Three };
</code></pre>

<p><code>One</code> after this is equivalent to a named constant with integer value 1. <code>numbers</code> is equivalent to a new type with a subrange of integer values. </p>

<p>What you probably want is to use a regular expression.</p>
",0
1140756,1139790,4,"<pre><code>#include &lt;ctype.h&gt;
</code></pre>

<p>Don't forget the basics. The above include file gives you <a href=""http://linux.die.net/man/3/isalpha"" rel=""nofollow noreferrer""><code>isalpha()</code></a>, <a href=""http://linux.die.net/man/3/isdigit"" rel=""nofollow noreferrer""><code>isdigit()</code></a>, etc.</p>
",0
1142062,1139790,0,"<p>Some languages (Ada for one) allows what you want, so your request is not too silly.  You are simply forgetting that in C and C++, character literals are just another form of integer literals (of type <code>int</code> in C, of type <code>char</code> in C++)</p>
",0
1144425,1144399,1,"<p>Try</p>
<pre><code>  std::cin.ignore(INT_MAX);();
</code></pre>
<p>So something like this:</p>
<pre><code>string Book::what_title()
{
       cout &lt;&lt; &quot;Title: &quot;;
       std::cin.ignore(INT_MAX);
       getline(cin,title);
       cout &lt;&lt; endl;
       return title;
}
</code></pre>
<p>If that does not help check out <a href=""https://stackoverflow.com/questions/257091/how-do-i-flush-the-cin-buffer"">How do I flush the cin buffer?</a></p>
<p>Reading the full line (using <em>getline</em>) as some of the other answers are indicating should also take care of the rogue EOL character in the input stream.</p>
<p><em>Edit: Removed cin.flush since that as not as standard as I thought.</em></p>
",1
1144427,1144399,5,"<p>The following line:</p>

<pre><code>cin &gt;&gt; question;
</code></pre>

<p>reads in the 'Y' or the 'N' character. When you enter the input, you also type a 'return' or 'enter'. That return/enter is still in the buffer. When you get to getline(cin,title);
the second time through the loop, that return/enter that is still in the buffer is read in and interpreted as the entire line.</p>

<p>What you need to do is either clear the input buffer with cin.flush(); or you need to read in question as a string and not as a character.</p>

<p>Here is what your code should look like</p>

<pre><code>int main()
{
    Book store;
    char question = '0';
    while(true){
        store.what_title();
        store.what_author();
        store.what_copyright();
        store.store_ISBN();
        store.is_checkout();
        store.books.push_back(store);
        cout &lt;&lt; ""Are you finished?(Y or N): "";
        cin &gt;&gt; question;
        if(question == 'Y') break;
        else if(question == 'N')
        {
            cout &lt;&lt; endl;
            cin.flush();
        }
        else error(""Invalid value."");
        }
    cout &lt;&lt; endl;
    keep_window_open();
}
</code></pre>
",2
1144445,1144399,1,"<p>do you hit enter while answering </p>

<pre><code>    Are you finished?(Y or N):
</code></pre>

<p>can you replace </p>

<pre><code>cin &gt;&gt; question;
</code></pre>

<p>with </p>

<pre><code>getline(cin,question);
</code></pre>

<p>?</p>
",0
1719065,554847,2,"<p>Learn <a href=""http://qt.nokia.com/"" rel=""nofollow noreferrer"">Qt</a>. Trust me on this; I develop all kinds of C++ app for a living. C++ with Qt makes you infinitely more productive. I used to combine so many different libraries (Boost, Intel's, database connectors, etc..) just to achieve the kind of stuff we do (high-performance/real-time computing). At the end, I found that more than 80% of what I need is already included in Qt.</p>

<p>Not to mention, imo, Qt has the best documentation on any framework/library I've worked on, which makes it <em>very</em> easy to just learn everything on your own.</p>

<p>Try it, and see for yourself.</p>

<p>Disclaimer: I'm just a developer--I dont work for Nokia. =p</p>
",0
1204486,1204313,0,"<p>That was fun:</p>

<pre><code>#include &lt;map&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;

struct IncrementMap
{
    IncrementMap(std::map&lt;int,int&gt;&amp; m): m_map(m)    {}
        void operator()(int val) const
    {
        ++m_map[val];
    }
    std::map&lt;int,int&gt;&amp; m_map;
};
struct SpecialPrint
{
    SpecialPrint(std::ostream&amp; s):  m_str(s)    {}
    void operator()(std::map&lt;int,int&gt;::value_type const&amp; value) const
    {
        m_str &lt;&lt; value.first;
        if (value.second != 1)
        {
            m_str &lt;&lt; ""\t"" &lt;&lt; value.second;
        }
        m_str &lt;&lt; ""\n"";
    }
    std::ostream&amp;   m_str;
};
int main()
{
    std::fstream        x(""Plop"");
    std::map&lt;int,int&gt;   data;

    std::for_each(  std::istream_iterator&lt;int&gt;(x),
                     std::istream_iterator&lt;int&gt;(),
                     IncrementMap(data)
                );
    std::for_each(  data.begin(),
                    data.end(),
                    SpecialPrint(std::cout)
                );
}
</code></pre>
",0
1204337,1204313,6,"<p>How about using a map, where the key is the number you're tracking and the value is the number of occurrences?</p>

<p>If you must use a vector, you've already got it sorted. So just keep track of the number you previously saw. If it is the same as the current number, increment the counter. Every time the number changes: print out the current number and the count, reset the count, set the last_seen number to the new number.</p>
",3
1204341,1204313,1,"<blockquote>
  <p>This program reads strings of numbers
  from a txt file, converts them to
  integers, <strong>stores them in a vector</strong>, and
  then tries to output them in an
  organized fashion like so....<em>(emphasis added)</em></p>
</blockquote>

<p>What is the point of this storage step?  If you are reading the numbers from a file, then you already have them in order, ready to be processed (counted) one at time, as you encounter them.</p>

<blockquote>
  <p>However, I would need a way for it to know when it sees a new number.</p>
</blockquote>

<p>I advise you to have a look at <code>std::set</code> or <code>std::map</code>.  I expect either of these containers would do what you're looking for.</p>
",0
1204347,1204313,8,"<p>You could use a map of numbers to counters:</p>

<pre><code>typedef map&lt;int,unsigned int&gt; CounterMap;
CounterMap counts;
for (int i = 0; i &lt; numbers.size(); ++i)
{
   CounterMap::iterator it(counts.find(numbers[i]));
   if (it != counts.end()){
      it-&gt;second++;
   } else {
      counts[numbers[i]] = 1;
   }
}
</code></pre>

<p>... then iterate over the map to print results.</p>

<p>EDIT:
As suggested by lazypython: if you have the <a href=""http://en.wikipedia.org/wiki/C%2B%2B_Technical_Report_1"" rel=""nofollow noreferrer"">TR1 extensions</a> [wikipedia.org] available, unordered_map should have better performance...</p>

<pre><code>typedef std::tr1::unordered_map&lt;int,unsigned int&gt; CounterMap;
CounterMap counts;
for (int i = 0; i &lt; numbers.size(); ++i)
{
   CounterMap::iterator it(counts.find(numbers[i]));
   if (it != counts.end()){
      it-&gt;second++;
   } else {
      counts[numbers[i]] = 1;
   }
}
</code></pre>
",3
1204398,1204313,1,"<p><a href=""http://www.sgi.com/tech/stl/count.html"" rel=""nofollow noreferrer""><code>Std::count()</code></a> fits the bill nicely.</p>

<pre><code>std::vector&lt;int&gt;::const_iterator cur = numbers.begin();
std::vector&lt;int&gt;::const_iterator last = numbers.end();
while (cur != last) {
    unsigned cnt = std::count(cur, last, *cur);
    std::cout &lt;&lt; *cur;
    if (cnt != 1) {
        std::cout &lt;&lt; "" "" &lt;&lt; c;
    }
    std::cout &lt;&lt; std::endl;
    int saved = *cur;
    while (*cur == saved) {
        ++cur;
    }
}
</code></pre>

<p>Of course there are a bunch of other algorithms out there that will do the same job. Play with things like <a href=""http://www.sgi.com/tech/stl/equal_range.html"" rel=""nofollow noreferrer""><code>std::equal_range()</code></a> in conjunction with <a href=""http://www.sgi.com/tech/stl/distance.html"" rel=""nofollow noreferrer""><code>std::distance()</code></a> will do the job just as nicely.</p>
",0
1204399,1204313,4,"<p>Using a map is the <strong>practical</strong> solution. What you should do is to solve this problem :)</p>

<p>This is called frequency counter. So, you have a sorted vector and all what you have to do is to count successive equal numbers. In other words, you have to check each number with its successor.</p>

<pre><code>for(size_t i = 0; i &lt; numbers.size(); i++)
{
    size_t count = 1;

    size_t limit = numbers.size() - 1;
    while(i &lt; limit  &amp;&amp; numbers[i] == numbers[i+1])
    {
        count++;
        i++;
    }

    std::cout &lt;&lt; numbers[i] &lt;&lt; ""\t"" &lt;&lt; count &lt;&lt; std::endl;
}   
</code></pre>
",0
478982,478967,1,"<p>to dynamically allocate the memory you may need to use the 'new' keyword like</p>

<p>objects would be defined like:</p>

<pre><code>int * objects;
</code></pre>

<p>inside the constructor you would do:</p>

<pre><code>objects = new int [maxLimit];
</code></pre>

<p>edit:</p>

<p>forgot to mention, you'll need to deallocate the array when you're done, probably in the destructor of the class.</p>

<pre><code>delete[] objects;
</code></pre>
",2
478984,478967,0,"<p><code>const int</code>s have to be initialized at declaration. If you don't know the value that it has to be at the time of declaration, you're going to have to adopt a different strategy.</p>

<p>You'll need to create the array in the constructor, while keeping a pointer outside. Is this what you want to do?</p>

<p>In your class :</p>

<pre><code>private:
    int maxLimit;
    int* objects;
</code></pre>

<p>And outside:</p>

<pre><code>Entities::Entities() : maxLimit(50)
{
    currentUsage = 0;
    cout &lt;&lt; ""Entities constructed with max of 50"" &lt;&lt; endl;
    objects = new int[maxLimit];
}

Entities::~Entities()
{
    delete [] objects;
}
</code></pre>
",2
478986,478967,36,"<p>The array must have a constant length. I mean a length that is the same for all objects of that class. That is because the compiler has to know the size of each object, and it must be the same for all objects of that particular class. So, the following would do it:</p>

<pre><code>class Entities
{
    private:
            static const int maxLimit = 50;
            int objects[maxLimit];
            int currentUsage;

    public:
            Entities();

            bool addObject(int identifier);
            void showStructure();
};
</code></pre>

<p>And in the cpp file:</p>

<pre><code>const int Entities::maxLimit;
</code></pre>

<p>I prefer to use an enumeration for that, because i won't have to define the static in the cpp file then:</p>

<pre><code>class Entities
{
    private:
            enum { maxLimit = 50 };
            int objects[maxLimit];
            int currentUsage;

    public:
            Entities();

            bool addObject(int identifier);
            void showStructure();
};
</code></pre>

<p>If you want to have a per-object size of the array, then you can use a dynamic array. <code>vector</code> is such one:</p>

<pre><code>class Entities
{
    private:
            const int maxLimit;
            std::vector&lt;int&gt; objects;
            int currentUsage;

    public:
            Entities();

            bool addObject(int identifier);
            void showStructure();
};

// Entities.cpp
Entities::Entities(int limit) 
    : maxLimit(limit), objects(limit), currentUsage(0)
{
    cout &lt;&lt; ""Entities constructed with max of 50"" &lt;&lt; endl;
}
</code></pre>

<p>Best is to do as much initialization in the initialization list as possible. </p>
",7
479004,478967,11,"<p>You can use template argument if you need to set array size at compile time:</p>

<pre><code>template&lt;size_t maxLimit&gt;
class Entities
{
    int objects[maxLimit];
    public:
        Entities() {}
        ...
};

Entities&lt;1000&gt; inst;
</code></pre>
",2
479100,478967,0,"<p>If all objects have the same length, then length can be static. This makes it a constant integral expression allowed as an array bound:</p>

<pre><code>class Entities
{
    private:
        static const int maxLimit = 50;
        int objects[maxLimit];
        int currentUsage;
    //...
};
</code></pre>

<p>Remember that sizeof(Entities) is a valid expression. Each Entities object has that same size.</p>
",0
479440,478967,0,"<p>Use std::vector and you get the expected behaviour. No need to worry about pointers, copies, etc</p>

<pre><code>#include &lt;vector&gt;

class Entities
{
private:
  const int limit;
  std::vector&lt;int&gt; objects;

public:
  Entities(int a_limit)
    : limit(a_limit), objects(a_limit)
  { }

  void addObject(int identifier)
  {
    if (objects.size() == limit)
      throw whatever;
    objects.push_back(identifier);
  }
};
</code></pre>
",0
1985886,1166342,-1,"<p>You can also try wxwidgets its very helpful. Here is a big picture of a simple game:</p>

<ul>
<li><strong>gameEngine class</strong> (responsible for creating sprite(s), setting up the environment, checking for key i/o, monitor various statistics of the game eg score, how many tries etc)</li>
<li><strong>Sprite Class</strong> (it will monitor things like life, health, direction etc)</li>
<li><strong>Hero</strong> -> Inherits from sprite class with some of its own functionality.</li>
<li><strong>Enemy</strong> -> Also inherits from sprite class.</li>
<li><strong>Fire</strong> -> Inherits from sprite as well.</li>
</ul>
",3
1150787,1150777,0,"<p>There is no such standard C++ function as strdate. Whether putting those lines ""inside a struct"" causes a problem is impossible to say without seing the code. I suggest what you really want is the <a href=""http://www.cplusplus.com/reference/clibrary/time/asctime/"" rel=""nofollow noreferrer"">asctime(</a>) function, or one of its relatives.</p>
",3
1150903,1150777,1,"<p>Where to start? Difficult to tell without seeing the code, but here's some thoughts.</p>

<p>First, you should probably NOT store the date as a character array <em>within</em> your struct because that will make manipulation of it awkward. Better to store it in it's native form as a <strong>time_t</strong>, and convert it to/from strings as required.</p>

<p>Second, if you must store it as ascii, don't store it as char[]. You're just asking for buffer overruns etc. Use string or vector </p>

<p>However, I think the <em>real</em> answer to your question concerns constructors. If you want Transaction to hold a date, then define it like this</p>

<pre><code>struct Transaction
{
   char dateStr[9];
}
</code></pre>

<p>If you want transactions to be datestamped, then assign the date in the constructor</p>

<pre><code>struct Transaction
{
   char dateStr[9];

   Transaction()
   {
      _strdate(dateStr); // or asctime or whatever
   }
}
</code></pre>

<p>Now, whenever you create a Transaction, it will automatically be filled with the return value from _strdate, whatever that is. Here's how I'd do it with time_t.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

struct Transaction
{
  time_t theTime;

  Transaction()
  {
    theTime = time(NULL);
  }
}
</code></pre>
",4
1191416,1191349,2,"<p>Files are sort of like a list, a sequential byte stream. When you open the file you position the file pointer at the very start, every read/write repositions the file pointer in the file with an offset larger than the last. You can use seekg() to move back in the file and overwrite previous content. Another problem with your approach above is that there will probably be some delimiters between the words typically one or more spaces for instance, you will need to handle read/write on these too.</p>

<p>It is much easier to just load the whole file in memory and do your manipulation on that string then rewriting the whole thing back.</p>
",2
1191440,1191349,4,"<p>Reading and writing on the same stream results in an error.  Check <code>f.bad()</code> and <code>f.eof()</code> after the loop terminates.  I'm afraid that you have two choices:</p>

<ol>
<li>Read and write to different files</li>
<li>Read the entire file into memory, close it, and overwrite the original</li>
</ol>

<p>As <a href=""https://stackoverflow.com/questions/1191349/why-doesnt-this-change-the-txt-file/1191416"">Anders</a> stated, you probably don't want to use <code>operator&lt;&lt;</code> for this since it will break everything up by whitespace.  You probably want <a href=""http://www.cplusplus.com/reference/string/getline/"" rel=""nofollow noreferrer""><code>std::getline()</code></a> to slurp in the lines.  Pull them into a <code>std::vector&lt;std::string&gt;</code>, close the file, edit the vector, and overwrite the file.</p>

<h2>Edit:</h2>

<p><a href=""https://stackoverflow.com/questions/1191349/why-doesnt-this-change-the-txt-file/1191416"">Anders</a> was right on the money with his description. Think of a file as a byte stream. If you want to transform the file <em>in place</em>, try something like the following:</p>

<pre><code>void
remove_vowel(char&amp; ch) {
    if (ch=='a' || ch=='e' || ch=='i' || ch =='o'  || ch=='u') {
        ch = ' ';
    }
}

int
main() {
    char const delim = '\n';
    std::fstream::streampos start_of_line;
    std::string buf;
    std::fstream fs(""file.txt"");

    start_of_line = fs.tellg();
    while (std::getline(fs, buf, delim)) {
        std::for_each(buf.begin(), buf.end(), &amp;remove_vowel);
        fs.seekg(start_of_line);     // go back to the start and...
        fs &lt;&lt; buf &lt;&lt; delim;          // overwrite the line, then ...
        start_of_line = fs.tellg();  // grab the next line start
    }
    return 0;
 }
</code></pre>

<p>There are some small problems with this code like it won't work for MS-DOS style text files but you can probably figure out how to account for that if you have to.</p>
",3
1191354,1191349,0,"<p>Are you sure your while loop is actually executing? Try adding some debugging output to verify that it's doing what you think it is.</p>
",3
1061586,1061578,5,"<p>This might be what you're looking for?</p>

<pre><code>if (t.kind == help_user) {
    help();  
    continue;
}
</code></pre>
",1
1061589,1061578,2,"<p>You can return to the top of a loop with the <code>continue</code> statement. That's the easiest way to achieve what you want since you have a <code>while</code> loop surrounding your code:</p>

<pre><code>if (t.kind == help_user) {
    help();
    continue;
}
</code></pre>

<p>There's also the <code>goto</code> statement though that is almost always a bad idea. I'll leave that to you to read about on your own. For more information read up on ""control flow"".</p>

<p>In this specific instance I'd probably opt for just restructuring your code slightly by adding an <code>else</code> statement, like so:</p>

<pre><code>    if (t.kind == help_user)
        help();  
    else if (t.kind == quit)
        return;
    else {
        while (t.kind == print)
            t=ts.get();
        ts.unget(t);

        cout &lt;&lt; result &lt;&lt; statement() &lt;&lt; endl;
    }
</code></pre>
",1
1061591,1061578,5,"<p>You can use goto, but the moment you do that consider yourself over. It's considered bad practice and good uses of it are rare and far apart.</p>

<p>I think what you're looking for is continue:</p>

<pre><code>void do_calculate(void)
{
    while (true)
    {
        cout &lt;&lt; prompt;
        Token t = ts.get();

        if (t.kind == help_user)
        {
            help();  
            continue; // &lt;- here
        }
        else if (t.kind == quit)
        {
            return;
        }

        while (t.kind == print)
        {
            t = ts.get();
        }
        ts.unget(t);

        cout &lt;&lt; result &lt;&lt; statement() &lt;&lt; endl;
    }
}

void calculate()
{
    try
    {
        do_calculate();
    }
    catch (const std::exception&amp; e)
    {
        cerr &lt;&lt; e.what() &lt;&lt; endl;
        clean_up_mess();
    }
}
</code></pre>

<p>I have also reformatted your code. I think this is more readable, to each his own but just wanted to let you compare.</p>

<ul>
<li><p>The try/catch clause is now no longer interfering with the calculation function.</p></li>
<li><p>The 'if' statements use brackets for consistency. Also, it's much easier to read, because I <em>know</em> whatever the if is controlling is within these brackets.</p></li>
<li><p>The catch will catch a std::exception, rather than runtime_error. All standard exceptions inherit from std::exception, so by catching that you know you can catch anything.</p></li>
</ul>
",1
1061597,1061578,1,"<p>Yes, it is called logic:</p>

<pre><code>void calculate()
{
    while(true)
    {
    try {
        cout &lt;&lt; prompt;
        Token t = ts.get();
        if (t.kind == help_user)
            help();  
        else
        {
            if (t.kind == quit) return;
            while (t.kind == print) t=ts.get();
            cout &lt;&lt; result &lt;&lt; statement() &lt;&lt; endl;
        }
        ts.unget(t);  // if statement above needs this then leave it in and 
                      // add one call after help() as well ... not sure from code
    }
    catch(runtime_error&amp; e) {
        cerr &lt;&lt; e.what() &lt;&lt; endl;
        clean_up_mess();
    }
}
</code></pre>
",0
1247044,1247041,6,"<p>Sure, use an iterator:</p>

<pre><code>for (std::map&lt;char, std::vector&lt;char&gt; &gt;::iterator i = m.begin(); i != m.end(); ++i) {
    std::vector&lt;char&gt;::iterator j = std::find(i-&gt;second.begin(), i-&gt;second.end(), 'b');
    if (j != i-&gt;second.end()) {
        i-&gt;second.erase(j);
    }
}
</code></pre>
",3
1247225,1247041,1,"<p>If you expect there can be multiple 'b's in the vector, I would write this way. </p>

<pre><code>for (std::map&lt;char, std::vector&lt;char&gt; &gt;::iterator i = m.begin(); i != m.end(); ++i) {
  i-&gt;second.erase(std::remove(i-&gt;second.begin(), i-&gt;second.end(), 'b'), i-&gt;second.end());
}
</code></pre>
",2
1248407,1247041,0,"<p>I'm only reproducing other people's algorithms here, but I find that without a couple of judicious typedefs and temporary reference variables the extra long lines can become significantly less readable.</p>

<p>The original question doesn't fully specify the required behaviour, but it may be appropriate to remove the map entry if the vector is left empty. This could be done as part of the map iterator, or as a pass at the end.</p>

<p>Also might want the remove the first 'b' in the first vector containing a 'b', or all 'b' in every vector, or some combination.</p>

<p>Remove all the 'b' in all the vectors in the map.</p>

<pre><code>typedef std::map&lt;char, std::vector&lt;char&gt; &gt; MapVecChar;

for( MapVecChar::iterator i = m.begin(); i != m.end(); ++i )
{
    std::vector&lt;char&gt; &amp;v = i-&gt;second;
    v.erase( std::remove( v.begin(), v.end(), 'b' ), v.end() );
}
</code></pre>

<p>Remove the first 'b' found in a the vector in the map.</p>

<pre><code>typedef std::map&lt;char, std::vector&lt;char&gt; &gt; MapVecChar;

for( MapVecChar::iterator i = m.begin(); i != m.end(); ++i )
{
    std::vector&lt;char&gt; &amp;v = i-&gt;second;

    std::vector&lt;char&gt;::iterator j( std::find( v.begin(), v.end(), 'b' ) );

    if( j != v.end() )
    {
        v.erase( j );
        break;
    }
}
</code></pre>

<p>Remove empty map entries.</p>

<pre><code>for( MapVecChar::iterator i = m.begin(); i != m.end(); )
{
    if( i-&gt;second.empty() )
        m.erase( i++ );
    else
        ++i;
}
</code></pre>
",0
1515558,1515552,2,"<p>Use enums when the value of the constant is either not important or sequential as in your example.</p>

<p>Use constants if you need special constant values assigned to the identifier.</p>
",0
1515560,1515552,0,"<p>Non explicit enums can cause some platform compatibility issues, and also, they're not type safe. Global constants are type safe and generally preferred. However, if you overlook this, enums are generally use for related things and constants for more unrelated things.   </p>

<p>Example when you would use enums:</p>

<pre><code>enum Colors {
COLOR_RED=0xFF0000,
COLOR_GREEN=0x00FF00,
COLOR_BLUE=0x0000FF
}  
</code></pre>

<p>Example when you would use global consts:</p>

<pre><code>volatile const void *VRAM=0x00FC0000;
</code></pre>

<p>Finally, my advice is that if you really care about platform compatibility, then use global consts.</p>
",3
1515569,1515552,4,"<p>Two related advantages of enums are their <strong>self-documenting</strong> nature, and the fact that they <strong>keep the namespace clearer</strong>.  Basically enums are like bundles of semantically related constants, within their own namespace.  By using enums in intefaces you indicate implicitly what set of values would be expected.</p>

<p><strong>Edit:</strong> Correction!  (I've been doing too much C# and such lately, and not enough C/C++ !)<br>
<em>With C and C++</em> the identifiers in an enumeration are scoped like ordinary variables and constants and must therefore be distinct that any other identifier in the same scope, including identifiers within other enumeration lists.  This is unlike more modern languages where the enum introduces its own namespace.  The notion that C/C++ enums help with keeping the namespace tidy is consequently incorrect.  Thank you, Michael Burr, for pointing that out.</p>

<p>The main drawback of enums is that they are <strong>not as readily portable</strong>.  A constant type and value  are unambiguously defined, there's less clarity with enums.</p>
",2
1515573,1515552,1,"<p>The biggest advantage of an enum is that it can be enforced by the compiler, such is not the case with a constant.</p>
",1
1516939,1515552,4,"<p>One nice thing about enums is that they're portable between C and C++, while <code>const</code> items can't be used in C in all the places you might like (Like array declarations).  So for headers that I'd like to work in either C or C++ I have tended to use enums in preference to const declarations or macro definitions.  Actually I've tended to use them regardless of whether the header is intended only for C++ or not (one less decision I have to think about).</p>

<p>Having the type of the enum be ambiguous isn't a problem very often - if you're overloading based on various different integral types you'll have potential problems with enums, and in that case const items would probably be better.  But I can't remember the last time I've needed different behavior for different types of the same number (ie., treating <code>5U</code> differently than <code>5</code> or <code>5L</code>).  I think that type of overloading is only really seen in puzzle/interview types of problems, or it's code that'll breed bugs anyway whether you use enums or not.</p>

<p>So bottom line is I'd prefer enums - but good luck getting your co-workers to stop using macros.  Using macros for named constants is pretty well ingrained in the C/C++ culture and even though they pollute the namespace in a big way, there's not enough real word problems to convince many people to even think about changing the habit.</p>
",0
1535156,1515552,0,"<p>When there is no special reason for backward compatibility, I prefer forward compatibility.
In this case, using global consts is more compiler-independent, but I vote for enums for several reasons:<br>
1. consts may have different types. All it takes is a bad search-replace when you want to replace the type of your enum. It can lead to some unexpected effects (consider signed/unsigned and value size). in enums a single type is enforced.<br>
2. strongly typed enums are introduced in C++0x. There are some implementations for this already in C++.<br>
3. enums, IMHO, are very difficult to write in an unclear way. You can't say that on consts (spread across several files, etc.).  </p>

<p>BTW, If you use const, I prefer using static consts inside a class scope (and not global). </p>
",0
445724,445702,5,"<p>Line 60 does not access a depending name. What you use is <code>ITier&lt;T&gt;</code> of which the compiler knows it's a template given an argument. Instead of <code>typename</code> you want to use <code>typedef</code> ;)</p>

<p>Line 64 <em>does</em> access the depending name <code>iterator</code> which is a type-name, so you have to put <code>typename</code> before <code>std::map</code>. I put the two disambiguations, <em>template</em> and <em>typename</em> on this answer: <a href=""https://stackoverflow.com/questions/389797/gcc-template-issue#390201"">Disambiguations of dependent names</a>.</p>

<p>Line 74 would be right, if you fix the bug in Line 60, as far as i can see.</p>

<p>Line 83 is alright in itself as far as i can see. </p>
",0
445751,445702,0,"<p>Thanks a lot litb. I was able to fix my code with the guidelines you provided.</p>

<pre><code>class IStatMsg;

template &lt;typename T&gt;
class ITier
{
public:

    // Methods
    ITier(){};
    ITier(TierType oType) : o_Type(oType){};
    virtual ~ITier(){};

    //typename ITier&lt;T&gt; ParamITier; 

    ITier&lt;T&gt;* Get(T oKey)
    {
        typename std::map&lt;T, ITier&lt;T&gt;*&gt;::iterator it = map_Tiers.find(oKey);    

        if (it != map_Tiers.end())
            return it-&gt;second;

        return NULL;
    }

    void Set(T oKey, ITier&lt;T&gt;* pTier)
    {
        map_Tiers.insert(std::pair&lt;T, ITier&lt;T&gt;*&gt;(oKey, pTier));
    }

    TierType GetType() { return o_Type; }

protected:
    // Methods

    // Attributes
    std::map&lt;T, ITier&lt;T&gt;*&gt; map_Tiers;
    TierType o_Type;

private:
    // Methods

    // Attributes
};
</code></pre>
",1
446122,445702,1,"<p>Also, I would recommend that you pass <code>const T&amp;</code> to the functions instead of <code>T</code>, since you cannot be sure (it's a template parameter!) that it'll be a ""cheap"" copy.</p>
",0
877538,877523,775,"<pre><code>Foo foo2();
</code></pre>

<p>change to</p>

<pre><code>Foo foo2;
</code></pre>

<p>You get the error because compiler thinks of</p>

<pre><code>Foo foo2()
</code></pre>

<p>as of function declaration with name 'foo2' and the return type 'Foo'.</p>

<p>But in that case If we change to <code>Foo foo2</code> , the compiler might show the error   <code>"" call of overloaded ¡®Foo()¡¯ is ambiguous""</code>.</p>
",5
1133420,1132987,1,"<p>Any interaction with web page (posting a reply or tweeting or searching) is typically either POST or GET http request. As meantioned by greyfade - to construct such requests - you whouls use cURL or smth like asio from Boost library.</p>
",0
1133258,1132987,1,"<p>That problem can be approached as simply as using <a href=""http://curl.haxx.se/"" rel=""nofollow noreferrer"">cURL</a> (or a similar library) to GET pages and <a href=""https://stackoverflow.com/questions/84619/how-do-i-make-a-post-request-with-curl"">POST</a> form data, or it could be as complicated as writing a Firefox <a href=""https://developer.mozilla.org/en/Gecko_SDK"" rel=""nofollow noreferrer"">XPCOM</a> extension.</p>
",0
1146425,1146337,1,"<p>books refers to a vector of Book class. You are comparing Book to an integer, which is undefined behavior. You need to dereference the Book object before you can access its data members.</p>

<p>First, don't access vectors using subscript [] notation. It is inefficient and makes life difficult. Use an iterator (something like, not sure on how you would want to implement):</p>

<pre><code>for (std::vector::iterator it = books.begin(); it != books.end(); ++it)
{
}
</code></pre>

<p>That isn't your problem, however. You use the <code>-&gt;</code> operator to dereference objects to get to their members. You made your members private, however, so you either need a get function like</p>

<pre><code>ISBNf() { return ISBNfirst; }
</code></pre>

<p>Or make your members public, but that is a bad idea (people can fool with your data). However, for simplicity, assume they are public, this is what you want:</p>

<pre><code>for (std::vector::iterator it = books.begin(); it != books.end(); ++it)
{
    if (*this == *it) cout &lt;&lt; ""test""; 
}
</code></pre>

<p>There is no good solution, here, because I have no idea what you are trying to achieve. I think you are trying to compare the number of digits on the integer, but this is not how to achieve that. If you are just trying to make sure you are assigning ISBNfirst properly, let me put your mind to rest: you are. However, you aren't accessing them correctly, which is where the -> operator comes in. </p>

<p>Next, this code is overkill:</p>

<pre><code>else if(!isdigit(ISBNlast) &amp;&amp; !isalpha(ISBNlast)
</code></pre>

<p>instead, use the isalphnum() function:</p>

<pre><code>else if (!isalphnum(ISBNlast));
</code></pre>

<p>Posted; I will edit my post to point out all the flaws in your code.</p>
",6
1146428,1146337,4,"<p>I'm not sure quite what the user is expected to type for an ISBN.</p>

<p>Reading from a stream into an int will read digits up to a space, and convert the result to int (if all goes well, anyway). Reading into a char will store the char value. So at the moment you're validating than an ISBN looks like three single digits (0-9), and then the next char. That's not what I think an ISBN looks like.</p>

<p>Your <code>operator==</code> looks OK, although note that for a bool return value,</p>

<pre><code>if (X) return true;
else return false;
</code></pre>

<p>can be replaced with</p>

<pre><code>return X;
</code></pre>

<p>because conditionals are already of type bool.</p>

<p>After setting your ISBN values (and any other fields you plan to use in <code>operator==</code>, if it's not finished yet), the way to look for a matching book in the store is:</p>

<pre><code>for(int i = 0; i &lt; books.size(); ++i)
    if(*this == books[i]) cout &lt;&lt; ""test"";
</code></pre>

<p>In other words, look for a book equal to this book. Or you could use <code>std::find</code> from <code>&lt;algorithms&gt;</code>, although in this case it wouldn't really be any more concise.</p>

<p>By the way, it is unusual to use the same class (Book) to represent both a single book, and the whole store. Unpicking that is a fairly complex set of changes and decisions, though, so I'll just say that a class should represent a single kind of thing, and an object of the class represent an example of that kind. So normally Book and Bookstore are different kinds of thing. The vector in Book is an instance variable, meaning that every Book has its own vector of Books. That doesn't really make sense.</p>
",10
1126079,1126071,2,"<p>Try using std::string instead of char[20] for name and the sample should work just fine.  </p>

<pre><code>struct contributions
{
    std::string name;
    double dollars;
};
</code></pre>

<p>also change the access to </p>

<pre><code>ptr[i].name
</code></pre>
",1
1126103,1126071,3,"<pre><code>cin &gt;&gt; ptr[i].name;
</code></pre>

<p><code>ptr</code> is the name of the variable, it is of type <code>contributions*</code>. It is an array of <code>contributions</code>, so to access the <em>i</em>th member, use <code>ptr[i]</code>. Then access the <code>name</code> field of that member via <code>ptr[i].name</code>. Also, <code>cin &gt;&gt; char[]</code> may not work (I don't recall for sure), as <code>char[]</code> is more of a C-ish thing, whereas <code>cin</code> is C++. So you might need to change the type of <code>name</code> to std::string.</p>

<p>As an aside, convention is to name your structs/classes with a singular noun. Thus <code>contribution</code> would be a more correct name; every instance represents a <em>single contribution</em>.</p>
",3
1126110,1126071,0,"<p>Also, using a std::vector of contributions w2ill make the code much simpler.  as it is, you have a memory leak. If this is direct from C++ Primer Plus I'd seriously suggest changing to a text book that will teach you modern, correct C++, such as <a href=""http://www.acceleratedcpp.com/"" rel=""nofollow noreferrer"">Accelerated C++</a> by Koenig &amp; Moo.</p>
",0
1126120,1126071,0,"<p><code>cin &gt;&gt; ptr[i].name;</code> (the correct form) would stop at the first whitespace character (and risk a buffer overflow if no such character comes before the 20 spaces in the array are exhausted). Use <code>cin.getline(ptr[i].name, 20)</code> instead.</p>
",2
1598217,1598207,5,"<p>You want:</p>

<pre><code>Bullet fired_bullet(*this);
</code></pre>

<p>But your coupling is very tight. What does Bullet need from Ship, and what does Ship need from bullet?</p>

<p>I assume the bullet needs to know what ship it came from so enemy bullets don't hurt enemy's and vice versa. Perhaps you need a team type?</p>

<pre><code>enum bullet_team
{
    bullet_player,
    bullet_enemy,
}
</code></pre>

<p>And your ships and enemies will only tell the bullet what team they are on, rather than forcing the bullet to keep track of where it came from:</p>

<p>About firing, maybe make a BulletManager singleton. Tell the manager you want to make a bullet at a position X, with team orientation Y, and properties Z, and the manager will take care of it for you.</p>

<pre><code>BulletManager::reference().fire(getPosition(), bullet_player);
</code></pre>
",6
1598219,1598207,2,"<p>replace:</p>

<pre><code>Bullet(*this) fired_bullet;
</code></pre>

<p>with:</p>

<pre><code>Bullet fired_bullet(*this);
</code></pre>
",0
1598232,1598207,1,"<p>You'll have to move the definitions out of your headers into your source files, leaving only the declarations in the headers.  It should look something like this:</p>

<pre><code>// Ship.h
class Bullet;
class Ship
{
    // Declare stuff, using only pointers/references to Bullet instances
    Ship();
    ...
};

// Bullet.h
class Ship;
class Bullet
{
    // Declare stuff, using only pointers/references to Ship instances
    Bullet(const Ship &amp; ship);
    ...
};

// Ship.cpp
#include ""Bullet.h""
#include ""Ship.h""

// Ship definitions
Ship::Ship()
{
    ...
}
...

// Bullet.cpp
#include ""Bullet.h""
#include ""Ship.h""

// Bullet definitions
Bullet::Bullet(const Ship &amp; ship)
{
    ...
}
...
</code></pre>

<p>Finally, your syntax for instantiating a Bullet is wrong.  You should be instantiating it like this:</p>

<pre><code>Bullet fired_bullet(*this);
</code></pre>
",1
1598257,1598207,0,"<p>A way to do it is as follows.</p>

<p><strong>Bullet.h</strong></p>

<pre><code>class Ship; //forward declaration
class Bullet
{
  //declaration of Bullet
  //may use Ship references and Ship pointers
};
</code></pre>

<p><strong>Bullet.cpp</strong></p>

<pre><code>#include ""Bullet.h""
#include ""Ship.h""
//definitions of Bullet methods go here
</code></pre>

<p><strong>Ship.h</strong></p>

<pre><code>class Bullet; //forward declaration
class Ship
{
  //declaration of Ship
  //may use Bullet references and Bullet pointers
};
</code></pre>

<p><strong>Ship.cpp</strong></p>

<pre><code>#include ""Ship.h""
#include ""Bullet.h""
//definitions of Ship methods go here
</code></pre>

<p>This will always work:</p>

<ul>
<li><p>In each header file, declare one class; use a forward declaration (name only) for other classes, and refer to those classes (as member method parameters, and as member instance data) only by reference or by pointer, not by value.</p></li>
<li><p>In each CPP file, include your own header file first; and then include any other headers, for classes whose declarations you need (you need them if the methods which you're defining instantiate instances of these other classes by value, or invoke methods of these other classes).</p></li>
</ul>

<p>Sometimes you may want to refer to a second class by value (instead of by pointer or reference) in the header file; that's OK, but if you do then you're half-way to a circular dependency. If do do end up with a circular dependency, then you need to change it so that at least one of the classes (if not both) refers to the other only by pointer or reference instead of by value.</p>
",0
1482036,1481996,0,"<p>Any data that you want <code>run</code> to see can be stored as member data of <code>svThread</code> class. A good way to get it stored as member data would be to pass it as a parameter to the <code>svThread</code> constructor.</p>
",0
1482047,1481996,1,"<p>You should store the data the thread needs as member variables of the thread, e.g.:</p>

<pre><code>class svThread : public Thread
{
private:
    const std::string filename_;
public:
    svThread(const std::string&amp; filename)
      : filename_(filename) 
    {}
    void run()
    {
        // ...
            __strexp(filename_, /* ... */);
        // ...
    }
};

void svDialog::ProcessUpload(wxCommandEvent &amp;event)
{
    UploadRoutine = new svThread(tb_file-&gt;GetValue());
    // ...
}
</code></pre>
",0
1482063,1481996,3,"<p>It's quite simple.</p>

<p>You should create a start function that takes a std::string (or any other parameters) and store it (them) in the svThread object. Then you can access it in the run function:</p>

<pre><code>class svThread : public Thread
{
   private:
      char* ThreadName;
      std::string FileName;

   public:
      svThread(const char* szThreadName)
      {
         Thread::setName(szThreadName);
         this-&gt;ThreadName = (char* )szThreadName;
      }

      void Start(const std::string&amp; filename)
      {
         this-&gt;FileName = filename;
         Thread::Start();
      }

      void Run()
      {
         // ...
         if(FtpPutFile(hFtpSession, FileName,(LPCWSTR)filenameOnServer.c_str(), FTP_TRANSFER_TYPE_BINARY, 0))
         // ...
      }
};
</code></pre>

<p>In your dialog class you just need to start your thread like this:</p>

<pre><code>UploadRoutine = new svThread(""Upload"");
UploadRoutine-&gt;start(tb_file-&gt;GetValue().c_str());
</code></pre>
",0
1482242,1481996,0,"<p>I'd also make hInternet and hFTPSession not global and pass them to each thread. That way you wont get into trouble later when utilizing multiple ftp sessions for instance.
I'd also rather not declare them in maindlg.cpp, the main dialog is a gui part, and those variables do not have any much to do with the gui.</p>

<p>btw what is the purpose of</p>

<pre><code>if(this-&gt;ThreadName == ""Upload"")
</code></pre>

<p>I mean, if the thread is meant for uploading, why should it doublecheck that against it's name string?</p>
",1
1673045,1671728,0,"<p>Besides using strncpy() or std::string, it might be good to see why it goes wrong.
I would recommend checking this faq to see the ins and outs of pointers and arrays.
<a href=""http://c-faq.com/aryptr/index.html"" rel=""nofollow noreferrer"">http://c-faq.com/aryptr/index.html</a></p>
",0
1599552,1599536,1,"<p>Writing:</p>

<pre><code>private:
  MyInterface();
</code></pre>

<p>does the trick in two ways: for a start, no-one except friends can access it, but what's better: if a friend does try to access it, the linker will complain because there is no implementation.</p>

<p>Same trick works for copy constructor and assignment operator.</p>
",2
1599566,1599536,10,"<p>In your case, since you have already provided a constructor that takes one parameter <code>SomeController*</code>, compiler doesn't provide any default constructor for you. Hence, default constructor is not available.</p>

<p>ie, </p>

<pre><code>MyInterface a;
</code></pre>

<p>will cause compiler to say no appropriate constructor.</p>

<p>If you want to make constructor explicitly not available then make the same as private.</p>

<p><strong>EDIT</strong> for the code you have posted:</p>

<ul>
<li><p>You need to call base class <code>MyInterface</code> constructor (with single parameter) explicitly. Otherwise, by default the derived class constructor ( <code>Inherited</code>) will look for Base class default constructor which is missing.</p>

<p>class Inherited : public MyInterface
    {
    private:
            Inherited ();
    public:</p>

<pre><code>    Inherited(SomeController *controller):MyInterface(controller)
    {}
};
</code></pre></li>
</ul>
",3
1599573,1599536,4,"<p>Just don't put it in at all. A class with a non-default ctor does not have a compiler-provided default constructor. It DOES have a compiler-generated <strong>copy</strong> constructor; inherit from <a href=""http://www.boost.org/doc/libs/1_40_0/libs/utility/utility.htm"" rel=""nofollow noreferrer""><code>boost::noncopyable</code></a> to remove that.</p>
",1
911061,911035,13,"<p>The C99 header file stdint.h defines typedefs of this nature of the form <code>uint32_t</code>. As far as I know, standard C++ doesn't provide a cstdint version of this with the symbols in namespace std, but some compilers may, and you will typically be able to include the C99 header from C++ code anyways. The next version of C++ will provide the cstdint header.</p>

<p>You will often see code from other people who use non-standard forms of this theme, such as <code>Uint32_t</code> or <code>Uint32</code> or <code>uint32</code> etc. They typically just provide a single header that defines these types within the project. Probably this code was originally developed a long time ago, and they never bothered to sed replace the definitions out when C99 compilers became common.</p>
",1
911065,911035,1,"<p>Try UINT32 for Microsoft.</p>

<p>The upper case makes it clear that this is defined as a macro. If you try to compile using a different compiler that doesn't already contain the macro, you can define it yourself and your code doesn't have to change.</p>
",0
911241,911035,19,"<p>Unix platforms define these types in <strong>stdint.h</strong>, this is the preferred method of ensuring type sizing when writing portable code.</p>

<p>Microsoft's platforms do not define this header, which is a problem when going cross-platform. If you're not using <a href=""http://www.boost.org/doc/libs/1_38_0/libs/integer/index.html"" rel=""noreferrer"">Boost Integer Library</a> already, I recommend getting Paul Hsieh's <a href=""http://www.azillionmonkeys.com/qed/pstdint.h"" rel=""noreferrer"">portable stdint.h</a> implementation of this header for use on Microsoft platforms. </p>

<p><strong>Update:</strong> Visual Studio 2010 and later do define this header.</p>
",0
911076,911035,12,"<p>Visual c++ doesn't support the fixed-width integer types, because it doesn't include support for C99. Check out the answers to <a href=""https://stackoverflow.com/questions/734802/fixed-width-integers-in-c"">my question on this subject</a> for various options you have for using them.</p>
",4
911079,911035,3,"<p>The main reason for using them is that you then don't have to worry about any possible problems arising when switching between 64bit and 32bit OS.</p>

<p>Also if you are interfacing to any legacy code that you new was destined for 32bit or even 16bit then it avoids potential problems there as well.</p>
",2
911257,911035,1,"<p>uint32 <em>et al.</em> are defined by macros. They solve a historic portability problem of there being few guarantees across platforms (back when there there more platform options than now) of how many bits you'd get when you asked for an int or a short. (One now-defunct C compile for the Mac provided 8-bit shorts!).</p>
",0
1081258,1081250,9,"<p>Take a look at <a href=""http://en.wikipedia.org/wiki/SIGFPE"" rel=""noreferrer"">this page</a>. </p>

<p>Relevant part for your question:</p>

<blockquote>
  <p>SIG is a common prefix for signal names; FPE is an acronym for floating-point exception. Although SIGFPE does not necessarily involve floating-point arithmetic, there is no way to change its name without breaking backward compatibility.</p>
</blockquote>
",0
1081262,1081250,33,"<p>The operation triggers <a href=""http://en.wikipedia.org/wiki/SIGFPE"" rel=""noreferrer"">SIGFPE</a>:</p>

<blockquote>
  <p>SIG is a common prefix for signal
  names; FPE is an acronym for
  floating-point exception. Although
  SIGFPE does not necessarily involve
  floating-point arithmetic, there is no
  way to change its name without
  breaking backward compatibility.</p>
</blockquote>

<p>GDB is a bit clearer about this and calls it ""Arithmetic exception"":</p>

<pre><code>(gdb) run
Starting program: /home/emil/float

Program received signal SIGFPE, Arithmetic exception.
0x0804837d in main () at float.c:4
4           int c=a%b;
</code></pre>
",0
913582,913573,6,"<p>Rewriting tools is a good idea - my C++ professor made us rewrite all the standard library string functions by hand before we were allowed to use them in our homework assignments so that is something that may help you as well.  You could also check out <a href=""http://projecteuler.net/"" rel=""noreferrer"">Project Euler</a>.</p>
",0
913591,913573,6,"<p>Here's a good task that involves I/O, has interesting algorithm, is not too simple, not too difficult, and can even have practical application:</p>

<p><strong>Write a simple compressor / decompressor.</strong></p>

<p>Simple ideas to start with: LZW, Huffman codes.</p>
",0
913603,913573,1,"<p>Try TopCoder.  They're competition applet has hundreds of example programming problems.  Some of them are sure to be more interesting than the exercises in the books, and you have the added bonus of seeing how your problem solving abilities measure up to other users.</p>
",0
913608,913573,4,"<p>I write stuff I'm interested in ... games for example.  Poker games or blackjack games.  I also take existing libraries and see if I can make better versions of their stuff, like try and make a QuickSort that outperforms the Framework version. Some day I will write a chess game, but that will take some time. :)</p>
",0
913768,913573,4,"<p>Write a language! Make C# compile to Sparc V9 assembly (just kidding.) But seriously, I think, writing a small compiler that produces actual machine code is one of the greatest ways to learn a great deal about software and hardware (and operating systems, and libraries, etc. etc.) and pick up lots of useful skills along the way. Here's the <a href=""http://dragonbook.stanford.edu/"" rel=""nofollow noreferrer"">The Dragon</a> to get you started :)</p>
",0
913812,913573,4,"<p>You can try getting involved in some open-source projects if you are wanting to write code. If you find a project that has some use to you personally, it is going to greatly increase your interest levels and decrease the likelihood that you'll get bored with it and move on to something else. Plus you'll be able to get some feedback from other developers on the same project. </p>
",0
1333423,1333348,3,"<p>You haven't new'd items, so you can't delete it in the destructor. Assuming you require 'Stack' to be a dynamically sized class then the items array must be dynamically allocated in which case the declaration for items should be</p>

<pre><code>Type *items;    (as hacker mentions above)
</code></pre>

<p>and the constructor should call 'items = new Type[ARRAY_SIZE]' to allocate the memory, or at the very least initially assign the 'items' pointer to NULL.</p>

<p>Edit based on comments - </p>

<p>To complete and secure the memory allocation responsibilities for this class you should also include a copy constructor and an assignment operator which allocates new memory and copies the values stored in items to the new object. This avoids the pointer simply being copied by the compiler generated copy constructor or assignment operator which would lead to multiple objects pointing to the same dynamically allocated memory. Upon destruction of the first of these objects this memory will be deleted. Further use of the now deleted memory by the other objects which share the pointer would be likely to result in a crash.</p>

<p>Rather than adding code here I refer you to the code in Martin's answer for  <a href=""https://stackoverflow.com/questions/255612/c-dynamically-allocating-an-array-of-objects/255744#255744"">this question</a>.</p>
",4
1333357,1333348,6,"<p>You should only <code>delete[]</code> what you have explicitly allocated with <code>new[]</code>. Your <code>items</code> member is not a dynamically allocated array, so you must not free it as if it were.</p>

<p>On the other hand, you have</p>

<pre><code>Type items[];
</code></pre>

<p>which doesn't actually allocate any space in your object instances for the stack.</p>
",0
1333360,1333348,4,"<p>I don't think that's a memory leak! It's a crash occurring because you deleted a non-heap object.</p>
",1
1333369,1333348,1,"<p>The first thing I've seen is that you're likely to mean <code>Type *items</code>, not <code>Type items[]</code>.</p>

<p>And then you don't want to (can't) use <code>sizeof</code> on the dynamically allocated data.</p>
",0
1333403,1333348,2,"<p><em>items</em> is a pointer to Type. This pointer must be initialised 
before it is used (it is a <a href=""http://en.wikipedia.org/wiki/Dangling_pointer"" rel=""nofollow noreferrer"">wild pointer</a> as it is). That 
is why your program crashes. That it happens in the 
destructor is a coincidence. It could just as well have 
happened earlier. E.g. in push() memory is overwritten in the 
location that <em>items</em> happens to point to.</p>

<p>You need to allocate memory for a number of elements. See below.</p>

<p>You already have the logic for the dynamic growth of the 
array in place. But an array in C++ does not know its size 
(it is just a pointer of some type). You need to keep track 
of the current capacity/size. Thus instead of</p>

<pre><code>sizeof(items)
</code></pre>

<p>define a new member to hold the current capacity.</p>

<p>E.g.:</p>

<p>int capacity;</p>

<p>and in the constructor:</p>

<pre><code>capacity = 100;
items = new Type[capacity];
</code></pre>

<p>The last line allocates a number of elements and is the main solution to your problem.</p>

<p>And in push():</p>

<pre><code>if (top == capacity / sizeof(Type)) {
</code></pre>

<hr>

<p>The logic for reallocation will need to change. E.g.:</p>

<pre><code>capacity *= 2;
items = new Type[capacity];
</code></pre>

<p>instead of<br>
    items = new Type[2*top];</p>

<p>I have just sketched out a solution here. Yon can fill in the details.</p>

<hr>

<p><strong>Note</strong>: you have only one instance of Stack in your program; body of main() is:</p>

<pre><code>Stack&lt;double&gt; st;
</code></pre>

<p>If you instead were to assign one instance of Stack to another instance, e.g.</p>

<pre><code>{
   Stack&lt;double&gt; st;
   Stack&lt;double&gt; st2 = st; //Copy constructor will be invoked for st2. If not defined the compiler generated copy constructor will do a copy of the pointer value.
   Stack&lt;double&gt; st3;
   st3 = st; //Assignment operator will be invoked for st3. If not defined the compiler generated assignment operator will do a copy of the pointer value.
}
</code></pre>

<p>then the copy constructor (to work for st2) and the 
assignment operator (to work for st3) for Stack must be 
defined properly (make a copy of the referenced member 
<em>items</em>). Otherwise a double or triple delete in the destructor and 
undefined behavior (e.g. a crash) will be the result when 
st, st2 and st3 goes out of scope at the close brace.</p>
",3
899559,899483,1,"<p>Having any constness at all is more than you'll find in many languages!</p>

<p>Once you understand (as you have) the difference between 'physically const' and 'logically const', then the 'ambiguous' scenarios remain just that: subject to debate. Consider for example even the fact that the <code>mutable</code> keyword exists.</p>

<p>I think you have the right general idea: and beyond that it's all debatable and subjective and varies according to the particular problem and constraints etc.</p>

<p>I tend to prefer 'no exceptions to the rule', so I'd avoid returning a pointer-to-non-const from a const method; but I suppose I can imagine some scenarios where I might be tempted ... though I might instead be more likely to decide to make the method non-const.</p>
",0
899603,899483,1,"<p>(I'm ignoring the fact that you are returning object state directly like that, which is usually a bad idea because it breaks encapsulation -- I'm looking at this as ""sample code"")</p>

<p>There is no relation between the two. A <code>const</code> member function is a member that doesn't modify the underlying object -- ""while it's executing"". There is no promise or requirement that the return value be <code>const</code> or not. The <code>const</code>-ness contract is ""over"",  once the method returns. I think you're getting confused because you are trying to connect the return value with the method that produced it.</p>

<p>Whether the returned value should be <code>const</code> or not <code>const</code> depends exclusively on the nature of the returned value, and the semantics that you want to ascribe to the method.</p>

<p>In your specific first case, the two methods should return the same <code>const</code>-ness. The const overloading is probably not what you want to use. If you want the two variations, I would probably make it explicit, like such:</p>

<pre><code>const ownedByFoo *getOwnedByFoo() const { return m_ownedByFoo; }
ownedByFoo *getOwnedByFooForEdit() { return m_ownedByFoo; }
</code></pre>

<p>That way there is no ambiguity and no mysterious tying of the two. Note that I made the second non-const because we probably don't want client code to modify m_ownedByFoo on a const object. That's a requirement born out of the semantic of the method (""returns internal state""), not out of a linkage between the method's <code>const</code>-ness and the <code>const</code>-ness of the return value. If the value being returned was not part of the object's state, I would probably do something else.</p>
",3
899671,899483,0,"<p>Do not return a non-const pointer or reference to member data from a const method.</p>
",0
899999,899483,0,"<p>If the returned reference is const, make the function const, if it's not, don't.  You should try to avoid returning a non-const reference to member data though because that breaks encapsulation, unless the class is primarily some kind of container class.</p>
",0
900008,899483,0,"<p>If returning a non-const reference/pointer would allow the caller to invalidate an invariant that the class should be maintaining, then don't return that non-const reference/pointer. (It should be const.)</p>
",0
1273772,1273739,3,"<p>You need to figure out which system call you made that caused the crash. Normally this kind of thing is the result of passing garbage into some windows API.</p>

<p>Use a debugger and look at the call stack. The last entry that is inside your code is likely to be the cause of the problem. It probably has some bad data that is it not handling correctly.</p>
",0
1274878,1273739,1,"<p>This sounds like you are using global objects/singletons.  If any of these depend on each other you are in trouble.  I would look for all your globals and put a break point in the contructor of each.  It sounds like the contructor for one global is using another global but the second has not been contructed yet.</p>

<p>Finally if this is not the cause, and your application is loading 3rd party dlls they might be clashing.  I remember once orbix and ms message queue dlls classing in one was loaded before the other, everything worked if they were loaded the other way around.  In the end to find this I removed every thing till I was just left with an empty main and then started adding things one by one until I found the problem.</p>
",0
1305144,1305132,3,"<p>If:</p>

<pre><code>LibProcess * process = createLibProcess();
</code></pre>

<p>returns NULL, or a process that is invalid in some way, you will get exactly the behaviour you are seeing.</p>
",1
1305149,1305132,2,"<p>Is process definitely set to a non-NULL valid pointer before it is dereferenced to call run?</p>
",0
873765,873758,3,"<p>I don't know PHP, but I don't think you can do that in C++. A variable name has no runtime representation in a compiled C++ program, so there is no way to load its name at runtime like that.</p>

<p>This seems to be something you can only do in a scripting language where the original source code is in memory or at least some representation of the syntax tree.</p>
",1
873769,873758,1,"<p>This isn't something you can do in C++.  When you compile C++ code, the information about what names functions and variables are is lost (technically, it can be stored in symbol tables, but those are only for debugging purposes). To accomplish anything like this, you'd need to use a <a href=""http://www.sgi.com/tech/stl/Map.html"" rel=""nofollow noreferrer"">map</a> or other similar data structure, which is rather like a PHP array.</p>
",0
873771,873758,1,"<p>It sounds like you may want to use pointers:</p>

<pre><code>string testVar;
string *str = &amp;testVar;
*str = ""test"";
cout &lt;&lt; testVar &lt;&lt; endl; // test
</code></pre>

<p>After compiling, the C++ compiler discards information like the original names of variables, so you have to use lower level constructs to do the same kinds of things.</p>
",0
873785,873758,6,"<p>How about using a map?</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;string&gt;

using namespace std;

map&lt;string, string&gt; hitters;

hitters[""leadoff""] = ""Jeter"";
hitters[""second""] = ""Damon"";
hitters[""third""] = ""Teixiera"";
hitters[""cleanup""] = ""Matsui"";

string hitter = ""cleanup"";

cout &lt;&lt; hitters[hitter] &lt;&lt; endl;
</code></pre>
",0
1539042,1539003,16,"<p>Think about if from the code perspective - there is this symbol <code>superGlobal</code> that points at an integer. </p>

<p>You have a bunch of .o files to link together into a single executable. Each of the .o files has it's own <code>superGlobal</code> symbol. Which should the linker use?</p>

<p>The <code>extern</code> declaration says: another of the compilations units (.o files) is going to declare this symbol, so I can use it. Thus there is only one copy so the linker knows what to do.</p>
",0
1539047,1539003,5,"<p>the #ifndef guard only works on a per-file basis.  So if you leave the extern off, then you get superGlobal defined 3 times, once when compiling each of the files main.cpp, filethatUsesSuperglobal1.cpp, and externvardef.cpp.</p>
",2
1539103,1539003,2,"<p>You are violating the One Definition Rule (ODR).  A given variable may only be defined once.</p>

<p>When the header says ""int SuperGlobal;"", each file that includes the header defines the variable.  When the header says ""extern int SuperGlobal;"", the variable is declared (so the various files know how to access it), but it will only be defined once - in an appropriate source file.</p>
",0
1539108,1539003,2,"<p>The #ifndef guards only prevent the header from showing up more than once <strong>per cpp file</strong>.  Once the compiler is done processing one cpp file, it starts over with the next, throwing away any knowledge of what happened while compiling the previous file.  Each cpp file results in an object file, each of which has its own copy of the global variable.  When the linker tries to tie everything together, it finds multiple definitions of where in memory to find the global variable.  The linker has no way of knowing which object file to respect and which to ignore.  Some linkers will just pick one and ignore all the others, others will barf.  Either way, it's a mistake.</p>
",1
1540147,1539003,4,"<blockquote>
  <p>should not the #include guards on ""externvardef.h"" avoid redefinition?</p>
</blockquote>

<p>The include guards protect against <em>multiple declarations in a single compilation unit</em>; wheras the extern <em>declaration</em> is required to prevent <em>multiple definitions in a single executable unit</em>.</p>

<p>Note the key thing here is to distinguish between <em>declaration</em> and <em>definition</em>. You will see this distinction in the error messages generated. Get the include guards wrong, and you get multiple <em>declaration</em> errors from the <em>compiler</em>. Get the extern wrong, and you get multiple <em>definition</em> errors from the <em>linker</em>. Notice also the roles of the compiler and linker in this.</p>
",0
880296,880269,2,"<p>Another poster suggested:</p>

<pre><code> delete b;
 memset(b,0,sizeof(B));
</code></pre>

<p>Please don't do this!!! Writes to address space that is returned to the memory manager are UNDEFINED!!!!</p>

<p>Even if your compiler and library let you get away with it now, it is bad bad bad. A change in library or platform, or even an update in the compiler will bite you in the ass.</p>

<p>Think of a race condition where you delete b, then some other thread makes an allocation, the memory at b is given out, and then you call memset! Bang, you're dead.</p>

<p>If you must clear the memory (which who cares) zero it out before calling delete.</p>

<pre><code> memset(b,0,sizeof(B));
 delete b;
</code></pre>
",4
880344,880269,2,"<p>Use placement ""new"" if you can (<a href=""http://www.parashift.com/c++-faq-lite/dtors.html#faq-11.10"" rel=""nofollow noreferrer"">http://www.parashift.com/c++-faq-lite/dtors.html#faq-11.10</a>)
and zero out the chunk you gave after calling the object destructor manually.</p>
",0
880383,880269,3,"<blockquote>
  <p>accessBMemberVariable should coredump, but it doesn't</p>
</blockquote>

<p>Nah, why should it? It's quite possible that the memory that b used to occupy is now owned by the CRT, the CRT that your application owns. The CRT may opt to not release memory back to the OS. Core dumps will only happen if you access memory <em>not</em> owned by your application.</p>

<p>Zeroing out the memory occupied by b may not do you any good depending on the type of variable that A has the address of.</p>

<p>My advice would be to allocate B on the stack, that should bring out the fireworks... but then again, not quite in the way you'd expect...</p>

<p>So if you really want a core dump you should use the OS functions to allocate memory and free it:</p>

<pre><code>char *buf = OS_Alloc(sizeof(B));
B *b = new(buf) B();
a-&gt;someBMember = &amp;b-&gt;myMember;
b-&gt;~B();
OS_Free(buf);
a-&gt;accessBMemberVariable();
</code></pre>
",0
880289,880269,-3,"<p>Once you've deleted <code>b</code> you don't really have permission to write over where it was.  But you usually can get away with doing just that; and you'll see code where programmers use <code>memset</code> for this.</p>

<hr>

<p>The approved way to do this, though, would be to call the destructor directly, then write over the memory (with, say, <code>memset</code>) and then call <code>delete</code> on the object.  This does require your destructor to be pretty smart because <code>delete</code> is going to call the destructor.  So the destructor must realize that the whole object is nothing but <code>0</code>'s and not do anything:</p>

<pre><code>b-&gt;~B();
memset(b, 0, sizeof(b));
delete b;
</code></pre>
",3
880292,880269,20,"<p>You probably should override the <code>delete</code> operator.</p>

<p>Example for the given class B:</p>

<pre><code>class B
{
public:

  // your code
  ...

  // override delete
  void operator delete(void * p, size_t s)
  {
    ::memset(p, 0, s);
    ::operator delete(p, s);
  }
};
</code></pre>

<p><strong>EDIT:</strong> Thanks <em>litb</em> for pointing this out.</p>
",3
880721,880269,0,"<p>In your example you write</p>

<p>'A->accessBMemberVariable' is this a typo? shouldn't it be 'a->accessBMemberVariable' ?</p>

<p>Assuming it is a typo (otherwise the whole design seems a bit weird).</p>

<p>If you want to verify that 'a' is deleted properly it probably be better to instead change the way you handle the allocation and use auto_ptr's instead. That way you will be sure things are deleted properly:</p>

<pre><code>auto_ptr&lt;A&gt; a( new A );
{
  auto_ptr&lt;B&gt; b( new B(a) ); // B takes ownership of 'a', delete at scope exit
}
a-&gt;accessBMemberVariable(); // shouldn't do to well.
</code></pre>

<p>and a constructor for B in the form of </p>

<pre><code>B( auto_ptr&lt;A&gt;&amp; a ) : m_a(a) {;}
</code></pre>

<p>where </p>

<pre><code>auto_ptr&lt;A&gt; m_a
</code></pre>
",0
1398464,1398436,6,"<p>Checkout Joel's <a href=""http://www.joelonsoftware.com/articles/GuerrillaInterviewing3.html"" rel=""nofollow noreferrer"">Guerrilla guide to interviewing</a>. Seems a lot like what you are looking for.</p>
",0
1398443,1398436,3,"<p><a href=""http://www.artima.com/wbc/interprog.html"" rel=""nofollow noreferrer"">This article</a> offers some general ideas that are relevant regardless of what language you're working with.</p>
",0
1398495,1398436,14,"<p><a href=""http://www.mistybeach.com/articles/WhyIDontLikeCPlusPlusForLargeProjects.html"" rel=""noreferrer"">This one</a> is a great complex task, even though it is looking quite harmless.</p>
",7
1398508,1398436,2,"<p>You can choose potentially problematic task and see how they approach it. Ask them to write a smart pointer for example, you'll see if they understand pointers, references and templates in one step :) Usually they are stressed so they will do mistakes, those mistakes might help you find out how good they problem solving skills are, what paths would they use to fix a mistake and so on. The only problem with this approach is that sometimes interviewee just don't know anything about the task and you would have to quickly figure out something easier. If they do perfect code you can discuss their choices but when there's nothing to look at it is depressing for both of you.</p>
",1
1398525,1398436,21,"<p>I wouldn't make them write code. Instead, I'd give them a couple of code snippets to review. </p>

<p>For example, the first would be about <strong>design by contract</strong>: See if they know what preconditions, postconditions and invariants are. Do a couple of small mistakes, such as never initializing an integer field but asserting that it is >= 0 in the invariant, and see if they spot them.</p>

<p>The second would be to give them <code>bool contains(char * inString, char c)</code>. Implement it with a trivial loop. Then ask whether there are any mistakes. Of course, your code here does not <em>check for null</em> in the input parameter <code>inString</code> (even if the very previous question talked about preconditions!). Also, the loop finishes at character 0. Of course, the candidate should spot the possible problems and insist on using <code>std::string</code> instead of this <code>char *</code> crap. It's important because if they do complain, you'll know that they won't add their own <code>char *</code>'s to new code.</p>

<p>An alternative which addresses <strong>STL containers</strong>: give them a <code>std::vector&lt;int&gt;</code> and code which searches for prime numbers or counts the odd numbers or something. Make some small mistake. See if they find any issues and they understand the code. Ask in which situation a <code>std::set</code> would be better (when you are going to search elements quite systematically and original order of entrance doesn't matter.).</p>

<p>Discuss everything live, letting them think a couple minutes. Capture the essence of what they say. Don't focus on ""coverage"" (how many things they spot) because some people may be stressed. Listen to what they actually say, and see if it makes any sense.</p>

<p>I disagree with writing code in interviews. I'd never ask anyone to write code. I know my handwritten code would probably suck in a situation like that. Actually, I have seldom been asked to do so, but when I have, I haven't been hired.</p>
",6
1398566,1398436,7,"<p>I believe that a C++ programmer needs more than just generic programming skills, because... </p>

<blockquote>
  <blockquote>
    <p>In C++ it's harder to shoot yourself in the foot, but when you do, you blow off your whole leg.</p>
  </blockquote>
</blockquote>

<p>Writing bug-free, maintainable C++ code places a much higher demand on a few areas than most languages.</p>

<p>One thing I'll call ""pedanticness"". You know how some people can spot spelling errors in something at a glance? A C++ programmer needs to be able to spot simple bugs while they read or write code (whether the code is their own or not). A programmer who relies on the ""compile and test"" technique just to get rid of simple bugs is incompatible with the C++ language, because those bugs don't always lead to immediate failure in C++.</p>

<p>C++ programmers also need a good knowledge of low-level stuff. Pointers, memory allocators, blocking, deadlocks. And ""nitty gritty"" C++ issues, like multiple inheritance and method hiding and such, particularly if they need to maintain other people's code.</p>

<p>Finally, C++ programmers need to be able to write code that's easy for other people to use. Can they design stuff well?</p>

<p>A good test for the first two areas is ""Here's some C++ code I got off the internet. Find the bugs, and identify the unneccessary bits."" (There's lots of really bad C++ code available on the internet, and often the programmer does unnecessary things due to a faulty understanding of how to be ""safe"" in C++.)</p>

<p>The last area you can test with more generic interview questions.</p>
",3
1398762,1398436,3,"<p>Depending on what your organisation's pre-screening is like, assume that the person knows nothing at all about C++ and has just put in on their CV because it makes them look supertechnical. Seriously. Start with something simple, like reversing a string. I have had candidates who couldn't even write a function prototype for this !!</p>
",7
1399406,1398436,2,"<p><a href=""https://stackoverflow.com/questions/154112/c-potential-interview-questiontoo-hard/154385#154385"">Here is my answer</a> to a similar question geared towards C#, but notice that my answer is language agnostic.  My interview question is, in fact, in C.  I rarely interview a person with the goal of finding out if they can program.  I want to find out if they can think, problem solve, collaborate, communicate, understand something new, and so on.  In the meantime, I circle around trying to see if they ""get it"" in terms of the big picture of software engineering.  I use programming questions because that's a common basis and an easy ruse.</p>
",0
1399458,1398436,0,"<blockquote>
  <blockquote>
    <p>So has anybody got any suggestions?</p>
  </blockquote>
</blockquote>

<p>I'd recommend getting a copy of this:</p>

<p><a href=""http://www.amazon.co.uk/Programming-Interviews-Exposed-Secrets-Programmer/dp/047012167X/ref=sr_1_1?ie=UTF8&amp;s=books&amp;qid=1252499175&amp;sr=8-1"" rel=""nofollow noreferrer"">http://www.amazon.co.uk/Programming-Interviews-Exposed-Secrets-Programmer/dp/047012167X/ref=sr_1_1?ie=UTF8&amp;s=books&amp;qid=1252499175&amp;sr=8-1</a></p>

<blockquote>
  <blockquote>
    <p>ie it doesn't matter whether they get the right answers or not its how they approach the problem that interests me</p>
  </blockquote>
</blockquote>

<p>You could ask the candidate to come up with a UML design to a common problem. If they show you a design pattern, then you can talk through the pros/cons of the pattern. You could then ask them to produce some code for one of the classes.</p>

<p>This would help you determine their technical knowledge level and their communication abilities.</p>

<blockquote>
  <blockquote>
    <p>I do care that they have a good solid understanding of pointers as well as understanding the under lying differences between pointers and references</p>
  </blockquote>
</blockquote>

<p>Linked list problems are good for determining whether a candidate has a solid grasp of pointers.</p>

<p>As for references, you could show them some code that does not use references correctly, and ask them to describe the problem.</p>

<p>e.g show them a class definition that contains a reference member variable, and the implementation of the constructor with the reference initialization missing.</p>

<blockquote>
  <blockquote>
    <p>I would also love to see how they approach optimisation of a given problem because solid fast code is a must, in my opinion.</p>
  </blockquote>
</blockquote>

<p>I'd start off simple...</p>

<p>Show them a code example that passes strings to a function by value. (the strings should not be modified in the function). You should check they correct the code to pass the strings by const reference.</p>

<p>After this, you could show a constructor that uses assignment instead of initialization (for objects). Ask them to improve it.</p>

<p>Lastly, ask them simple questions about data structure selection.</p>

<p>e.g. When they should use a list rather than a vector.</p>

<p>If you feel they have a grasp of the fundamentals you could either ask how they approach optimization problems (discuss profilers etc), or ask them to optimize something less obvious.</p>
",0
1399534,1398436,3,"<p>Don't test only the C++ and overall technical skills! Those are of course important, but they are nothing if people don't listen, don't answer properly or don't follow the commitments they made.</p>

<p>Check at most for the ability to clearly communicate. If people cant tell you what roughly they did in their former jobs within a few minutes, they will also be unable to report about their work at your place etc.</p>

<p>In a recent company we invited people for interviews in groups of about 3 people together. They were surprised, but nobody was angry about that. It was very interesting, because people had to communicate not only with us, but also with others in the same position. In case we were interested further, we arranged a second interview.</p>
",2
1399245,1398436,0,"<p>Whatever you do, pairing would be a good idea. Come up with a good program and pair with the guy and work towards solving the problem. IMHO, that a very good idea</p>
",0
1399333,1398436,4,"<p>Do not forget to also test for <em>code bigotry</em>. I know I don't want anyone working for or with me that isn't a flexible and consequently practical programmer both in their attitude to the programming language, but also in their approach to problem solving.</p>

<ul>
<li>Denying any type of preconceptions</li>
<li>Understanding the value of the
exceptions in any Best Practices</li>
<li>Being capable of refusing long term
habits in favor of something else if
the need arises</li>
</ul>

<p>These are characteristics dear to me. The manner of testing for these is not ideal if the interviews aren't lengthy or don't involve presenting code. But showing code snippets with purposely debatable techniques while offering a use case scenario and asking the candidate how they feel about the solution is one way.</p>
",2
1399874,1398436,7,"<p>A few questions can allow you to know a lot about a candidate:</p>

<ul>
<li>Differences between a pointer and a reference, when would you use each?  </li>
<li>Why would you make a destructor virtual?  </li>
<li>Where is the construction order of a class attributes defined?  </li>
<li>Copy constructor and operator=. When would you implement them? When would you make them private?</li>
<li>When would you use smart pointers? what things would you take into account to decide which?  </li>
<li>Where else have you seen RAII idiom?  </li>
<li>When would you make a parameter const? when a method? </li>
<li>When would you make an attribute mutable?  </li>
<li>What is virtual inheritance?</li>
<li>What is template specialization?</li>
<li>What are traits?</li>
<li>What are policies?</li>
<li>What is SFINAE?  </li>
<li>What do you know about C++Ox standard?</li>
<li>What boost libraries have you used?</li>
<li>What C++ books have you read? (Sutter? Alexandrescu?)</li>
</ul>

<p>Some short exercises (no more than 10 minutes) about STL containers, memory management, slicing, etc. would also be useful. I would allow him to do it in a computer with a ready environment. It's important to observe the agility.</p>
",6
1401051,1398436,5,"<p>""Write a program that receives 3 integers in the range of 0..2^32-1, and validates if they represent valid edges of a triangle"".</p>

<p>It seems to be a simple question. The input is considered valid if the sum of any two edges is greater than the third edge. However, there are some pitfalls, that a good programmer will handle:</p>

<ul>
<li>The correct type to use should be unsigned long. Many ""programmers"" will fail here.</li>
<li>Zero values should be considered as non-valid.</li>
<li>Overflow should be avoided: ""if (a+b &lt;= c) return false"" is problematic since a+b may cause an overflow.</li>
<li>if (a &lt;= c-b) is also bad solution since c-b may be negative. Not a good thing for unsigned types.</li>
<li>if (c > b) { if (a &lt;= c-b) return false; } else { if (a &lt;= b-c) return false; } This looks much better, but it will not work correctly if (a >= b+c). </li>
</ul>

<p>A good programmer must be detail oriented. This simple exercise will help checking if he is.</p>
",1
1326478,1326468,0,"<p><code>StaticClass</code> needs a place to store <code>a</code>, a static variable that will be shared by all class instances - there are two lines that do so, one in each file. Removing one will fix the linker error.</p>
",0
1326479,1326468,9,"<p>The following is a definition of the static data member. It has to occur only in one file that's compiled and then linked. </p>

<pre><code>int StaticClass::a = 0;
</code></pre>

<p>If you have multiple such definitions, it is as if you had multiple functions called <code>first</code>. They will clash and the linker will complain. </p>

<p>I think you are mistaking static members with static applied to namespace scope variables. At the namespace level, static gives the variable or reference internal linkage. But at the class scope level (when applied to a member), it will become a static member - one that is bound to the class instead of each object separately. That then has nothing to do with the C meaning of ""static"" anymore. </p>
",4
1326482,1326468,3,"<p>The statement</p>

<pre><code>int StaticClass::a = 0;
</code></pre>

<p>actually allocates storage for the variable, this is why it should be only written once.</p>

<p>As for your remark, you are probably confusing two different uses of the <code>static</code> keyword. In C static used to mean ""use internal linkage"", this means that the name of a variable or function would not be seen outside the translation unit where it was defined.</p>

<p>In classes, <code>static</code> is used to define class members, that is variables or methods that don't refer to a specific instance of the class. In this case the storage for a static variable must be allocated somewhere (as it is not part of any instance), but only in one place of course.</p>
",0
1326513,1326468,20,"<p>It seems like you're trying to have local classes in each source file, with the same name. In C++ you can encapsulate local classes in an anonymous namespace:</p>

<pre><code>namespace {
class StaticClass
{
public:

    void    setMemberA(int m)   { a = m;    }   
    int     getMemberA() const  { return a; }

private:
    static  int     a;  

};
int StaticClass::a = 0;
} // close namespace

void first()
{
    StaticClass statc1;
    static1.setMemberA(2);
}
</code></pre>
",1
1579501,1579487,6,"<p>My first thought is: ""<strong>NO</strong>...just say <strong>NO</strong>!""</p>

<p>Do you have some really, truly, unbelievably good reason not to use vector?</p>

<pre><code> std::vector&lt;int&gt; i(5, 0);
</code></pre>

<p>Edit: Of course, if you want it initialized to zeros, that'll happen by default...</p>

<p>Edit2: As mentioned, what you're asking for is value initialization -- but value initialization was added in C++ 2003, and probably doesn't work quite right with some compilers, especially older ones. </p>
",1
1579527,1579487,3,"<p>I agree with litb's comment. It would appear to be a compiler bug.</p>

<p>Putting your code in a <code>main</code> function and prefixing with:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;ostream&gt;
using std::cout;
using std::endl;
using std::size_t;
</code></pre>

<p>I got five zeros with both gcc 4.1.2 and a gcc 4.4.0 on a linux variant.</p>

<p><strong>Edit:</strong></p>

<p>Just because it's slightly unusual with array type: In a new expression an initializer of <code>()</code> means that the dynamically allocated object(s) are <em>value initialized</em>. This is perfectly legal even with array <code>new[...]</code> expressions. It's not valid to have anything other than a pair of empty parentheses as an initializer for an array <code>new</code> expression, although non-empty initializers are common for for non-array <code>new</code> epxressions.</p>
",1
1581393,1581390,6,"<p>Change line 107 to:</p>

<pre><code>PluginDiskstats::~PluginDiskstats()
</code></pre>
",1
850150,850142,8,"<p>In C++ you don't need <code>typedef</code>s for <code>class</code>es and <code>struct</code>s. So:</p>

<pre><code>class Object
{
 int var;
public:
 Object(const int&amp; varin) : var(varin) {}
};
</code></pre>

<p>Also, descriptive names are always preferrable, <code>Object</code> is much abused.</p>

<pre><code>int main (int argc, char * const argv[])
{
 int var = 1;

 Object obj_array[10]; // would work if Object has a trivial ctor

 return 0;
}
</code></pre>

<p>Otherwise, in your case:</p>

<pre><code>int main (int argc, char * const argv[])
{
 int var = 1;

 Object init(var);
 Object obj_array[10] = { var, ..., var }; // initialize manually

 return 0;
}
</code></pre>

<p>Though, really you should look for <code>vector</code></p>

<pre><code>#include &lt;vector&gt;
int main (int argc, char * const argv[])
{
 int var = 1;

 vector&lt;Object&gt; obj_vector(10, var); // initialize 10 objects with var value

 return 0;
}
</code></pre>
",0
850423,850142,4,"<p>dirkgently's rundown is fairly accurate representation of arrays of items in C++, but where he is initializing all the items in the array with the same value it looks like you are trying to initialize each with a distinct value.</p>

<p>To answer your question, creating an array of objects that take an int constructor parameter. You can't, objects are created when the array is allocated and in the absence of a trivial constructor your compiler will complain. You can however initialize an array of pointers to your object but you really get a lot more flexibility with a vector so my following examples will use std::vector.</p>

<p>You will need to initialize each of the object separately if you want each Object to have a distinct value, you can do this one of two ways; on the stack, or on the heap. Lets look at on-the-stack first.</p>

<p>Any constructor that take a single argument and is not marked as <code>explicit</code> can be used as an implicit constructor. This means that any place where an object of that type is expected you can instead use an instance of the single parameter type. In this example we create a vector of your Object class and add 100 Objects to it (push_back adds items to a vector), we pass an integer into push_back which implicitly creates an Object passing in the integer.</p>

<pre><code>#include &lt;vector&gt;
int main() {
    std::vector&lt;Object&gt; v;

    for(int i = 0; i &lt; 100; i++) {
        v.push_back(i);
    }
}
</code></pre>

<p>Or to be explicit about it:</p>

<pre><code>#include &lt;vector&gt;
int main() {
    std::vector&lt;Object&gt; v;

    for(int i = 0; i &lt; 100; i++) {
        v.push_back(Object(i));
    }
}
</code></pre>

<p>In these examples, all of the Object objects are allocated on the stack in the scope of the for loop, so a copy happens when the object is pushed into the vector. Copying a large number of objects can cause some performance issues especially if your object is expensive to copy.</p>

<p>One way to get around this performance issue is to allocate the objects on the heap and store pointers to the objects in your vector:</p>

<pre><code>#include &lt;vector&gt;
int main() {
    std::vector&lt;Object*&gt; v;

    for(int i = 0; i &lt; 100; i++) {
        v.push_back(new Object(i));
    }

    for(int i = 0; i &lt; 100; i++) {
        delete v[i];
    }
}
</code></pre>

<p>Since our objects were created on the heap we need to make sure that we delete them to call their deconstructor and, free their memory, this code does that in the second loop. </p>

<p>Manually calling <code>delete</code> has it's own caveats, if you pass these pointers to other code you can quickly loose track of who owns the pointers and who should delete them. An easier way to solve this problem is to use a smart pointer to track the lifetime of the pointer, see either <code>boost::shared_ptr</code> or <code>tr1::shared_ptr</code> which are reference-counted pointers :</p>

<pre><code>#include &lt;vector&gt;
int main() {
    std::vector&lt;shared_ptr&lt;Object&gt; &gt; v;

    for(int i = 0; i &lt; 100; i++) {
        Object* o = new Object(i);
        v.push_back(shared_ptr&lt;Object&gt;(o));
    }
}
</code></pre>

<p>You'll notice that the shared_ptr constructor is explicit, this is done intentionally to make sure that the developer is intentionally stuffing their pointer into the shared pointer. When all references to an object are released the object will automatically be deleted by the shared_ptr, freeing us of the need to worry about it's lifetime.</p>
",1
852315,850142,0,"<p>If you want to stick to arrays, then you must either initialize manually or use the default constructor.  However, you can get some control by creating a constructor with a default argument.  This will be treated as a default constructor by the compiler.  For example, the following code prints out the numbers 0, ..., 9 in order.  (However, I'm not sure that the standard dictates that the objects in the array must be constructed in order.  It might be implementation dependent, in which case the numbers may appear in arbitrary order.)</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

struct A {
   int _val;

   A(int val = initializer()) : _val(val) {}

   static int initializer() { static int v = 0;  return v++; }
};

int main()
{
   A a[10];
   for(int i = 0; i &lt; 10; i++)
      cout &lt;&lt; a[i]._val &lt;&lt; endl;
}
</code></pre>
",0
833114,833034,16,"<p>There are a few things I don't understand here. I see that this is tagged for <a href=""http://en.wikipedia.org/wiki/C%2B%2B/CLI"" rel=""noreferrer"">C++/CLI</a>, but what I describe below should be the same as <a href=""http://en.wikipedia.org/wiki/C%2B%2B"" rel=""noreferrer"">Standard C++</a>. </p>

<h3>Doesn't compile</h3>

<p>The code you give doesn't compile; <code>get_error_from_header</code> does not specify a return type. In my experiments I made the return type <code>size_t</code>.</p>

<h3>Signature of C++ <code>strstr()</code></h3>

<p>The signature for <code>strstr()</code> in the standard C library is:</p>

<pre><code>char *
strstr(const char *s1, const char *s2);
</code></pre>

<p>but the signature for <code>strstr()</code> in the <a href=""http://www.cplusplus.com/reference/clibrary/cstring/strstr/"" rel=""noreferrer"">C++ library</a>, depending on the overload, is one of:</p>

<pre><code>const char * strstr ( const char * str1, const char * str2 );
      char * strstr (       char * str1, const char * str2 );
</code></pre>

<p>I would choose the first overload, because you don't want to modify the string, you only want to read it. Therefore you can change your code to:</p>

<pre><code>const char* err = strstr((const char *)ptr, ""550"");
if (err != NULL) {
    ...
}
</code></pre>

<p>Also, I'm assuming your comment reporting the error:</p>

<pre><code>//error  cannot convert const char** to char*
</code></pre>

<p>is a typo: there's no <code>const char**</code> to be seen.</p>

<h3>Assignment to <code>err</code> unnecessary</h3>

<p>As is pointed out in a previous answer, the use of <code>err</code> to store the result of <code>strstr</code> is unnecessary if all it's used for is checking <code>NULL</code>. Therefore you could use:</p>

<pre><code>if (strstr((const char *)ptr, ""550"") != NULL) {
    ...
}
</code></pre>

<h3>Use of <code>reinterpret_cast&lt;&gt;</code> encouraged</h3>

<p>As is pointed out in another answer you should be using <code>reinterpret_cast&lt;&gt;</code> instead of C-style casts:</p>

<pre><code>if (strstr(reinterpret_cast&lt;const char *&gt;(ptr), ""550"") != NULL) {
    ...
}
</code></pre>

<h3>Use of <code>const_cast&lt;&gt;</code> to strip <code>const</code></h3>

<p>Given the example in the question, I don't see where this is necessary, but if you had a variable that you need to strip of <code>const</code>-ness, you should use the <code>const_cast&lt;&gt;</code> operator. As in:</p>

<pre><code>const char * p1;
char * p2;

p2 = const_cast&lt;char *&gt;(p1);
</code></pre>

<p>As is pointed out in a comment, the reason to use <code>const_cast&lt;&gt;</code> operator is so that the author's intention is clear, and also to make it easy to search for the use of <code>const_cast&lt;&gt;</code>; usually stripping const is the source of bugs or a design flaw.</p>
",8
833044,833034,8,"<p>Can't you just do:</p>

<pre><code>char* err = strstr((char *)ptr,""550"");
</code></pre>

<p>The error is because if you pass in a const char* to strstr you get one out (because of the overload).  </p>
",1
833051,833034,9,"<p>You don't appear to use <code>err</code> in the rest of that function, so why bother creating it?</p>

<pre><code>if (NULL != strstr((const char *)ptr, ""550""))
{
</code></pre>

<p>If you do need it, will you really need to modify whatever it points to? If not, then declare it as <code>const</code> also:</p>

<pre><code>const char* err = strstr((const char *)ptr, ""550"");
</code></pre>

<p>Finally, as casts are such nasty things, it is best to use a specific modern-style cast for the operation you want to perform. In this case:</p>

<pre><code>if (NULL != strstr(reinterpret_cast&lt;const char *&gt;(ptr), ""550""))
{
</code></pre>
",0
833055,833034,0,"<p>Well is ptr (which you passed in as void*) actually const or not? (In other words, is the memory under your control?) If it's not, then cast it to char* instead of const char* when calling strstr. If it is, however, you'll get a const char* out (pointing to a location inside of the string pointed to by ptr), and will then need to strncpy out to another string which you are responsible for managing.</p>
",0
898425,898387,9,"<p>Try initializing the variable outside the class definition, here is a working example:</p>

<pre><code>#include &lt;iostream&gt;

class Foo {
    static const double _bar;

public:
    Foo();

    void Bar();
};

const double Foo::_bar = 20.0;

Foo::Foo() {
    std::cout &lt;&lt; Foo::_bar &lt;&lt; std::endl;
}

void Foo::Bar() {
    std::cout &lt;&lt; Foo::_bar &lt;&lt; std::endl;
}

int main( int argc, char *argv[] ) {
    Foo f;
    f.Bar();

    return 0;
}
</code></pre>
",0
898433,898387,2,"<p>What you have marked as ""// Initialization"" is actually a creating and initializing a second variable with the same name, in a different scope. The static_double_variable variable created inside the constructor is a local variable in the constructor, and does not refer to the class-level static variable with the same name.</p>

<p>What you need to do to avoid this is to simply remove the type information so that it's a normal statement rather than an initialization, like so:</p>

<pre><code>   // Initialization:
   static_double_variable = 20.0;
</code></pre>

<p>But of course this won't actually work because it's an assignment to a const variable, and you still have a second problem, which is what I think is actually causing the error you see. When you write:</p>

<pre><code>  // Private member variable:
 static const double static_double_variable;
</code></pre>

<p>You are declaring that such a variable will exist. However you are not actually defining that variable (i.e. instructing the compiler to create storage for it).</p>

<p>In order to do that, and fix both your issues outside of your <code>class { }</code> construct, you would write:</p>

<pre><code> const double  TestStaticVariables::static_double_variable = 20.0;
</code></pre>

<p>This both defines the variable and gives it an initial, constant value.</p>

<p>In case that was unclear, this issue is also described succinctly in the C++ FAQ:
<a href=""http://www.parashift.com/c++-faq-lite/ctors.html#faq-10.10"" rel=""nofollow noreferrer"">http://www.parashift.com/c++-faq-lite/ctors.html#faq-10.10</a></p>
",0
898445,898387,2,"<p>What you are doing in the constructor is <b>hiding</b> the member variable.<br>
You have to initialize the <code>static_double_variable</code> outside of the class declaration.</p>
",0
898457,898387,1,"<p>Your constructor declares and defines a local static variable, which just so happens to have the same name as the class static member variable. The local variable hides the class member.</p>

<p>This is what you can see in the constructor. Then when you try to link against the class member in the other method, the linker discovers that it is declared but not defined, so it gives up.</p>

<p>You probably shouldn't initialize a static class member in a constructor anyway, since there is only one variable for the class, but the constructor is called once for each instance. You should define the variable outside any function (or just in the declaration, unless you want to conceal the value from users of your API).</p>
",0
1406950,1406941,23,"<p>using std::string simply imports std::string into the current scope (aka, you can just use 'string' rather than 'std::string') without importing everything from ::std into the current scope.</p>

<hr>

<p>edit: clarification after comment.</p>
",2
1406952,1406941,3,"<p>In this case it allows you to bind to a specific type within a namespace without qualification.  As opposed to the first case which allows you to bind to any type.</p>
",0
1406955,1406941,3,"<p>You will be able to use <code>string</code> class without putting std:: before it. However if you want to use something else for example a vector then you need to use <code>std::vector</code></p>
",0
1406957,1406941,12,"<p><code>using namespace foo</code> allows you to access all names in the namespace foo without qualification. <code>using foo::bar</code> allows you to use <code>bar</code> without qualification, but not any other names in foo.</p>
",0
1407026,1406941,1,"<p>too make things more complicated it's possible to do that:</p>

<pre><code>class Base {
protected:
    void f();
};
class Fun: public Base {
public:
    using Base::f;
};
</code></pre>

<p>and now you have nice public method.</p>
",0
746744,746735,3,"<p><a href=""http://www.cplusplus.com/reference/iostream/ostringstream/"" rel=""nofollow noreferrer""><code>std::ostringstream</code></a> part of <code>sstream</code> header.</p>

<p>How about this:</p>

<pre><code>void appendStuff(string&amp; in) {
   ostringstream os;
   os &lt;&lt; 34 &lt;&lt; "" bla bla"";
   in += os.str();
}
</code></pre>
",7
746753,746735,2,"<p>If you are asking can you alter the buffering of ostreams, then the answer is yes. However, depending on what you actually want the buffer to do,  this is not a particularly simple task. You will want to consult a book like <a href=""http://www.angelikalanger.com/iostreams.html"" rel=""nofollow noreferrer"">Langer &amp; Kreft</a> for more info.</p>

<p>L&amp;K have an example of how to implement an unbuffered output stream - it begins on page 229 of the book. It's too long to reproduce here, but basically you need to redefine the overflow() method of a derived streambuf class. </p>

<p>Note the book is not available on-line but the source code apparently is - see this <a href=""http://www.angelikalanger.com/IOStreams/examples.htm"" rel=""nofollow noreferrer"">page</a> for details.</p>
",1
746821,746735,1,"<p>Short answer: no</p>

<p>Long answer: Yes, but this requires writing your own <code>streambuf</code> class, which you then set with <code>rdbuf</code>. Also, now deprecated <a href=""http://www2.roguewave.com/support/docs/leif/sourcepro/html/stdlibref/strstream.html"" rel=""nofollow noreferrer"">strstream</a> does almost what you want and may still be in your compiler libraries.</p>
",0
750211,746735,1,"<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

class intostring : public std::basic_streambuf&lt;char&gt; {
  std::string &amp;str;
public:
  intostring(std::string &amp;pstr):str(pstr) {}
  virtual std::streamsize xsputn(const char *const p, const std::streamsize n) {
    str.append(p, n);  
  }
};

int main() {
  std::string s(""Original string: "");

  intostring newbuf(s);

  std::streambuf *oldbuf = std::cout.rdbuf(&amp;newbuf);
  std::cout &lt;&lt; ""Should go to string"" &lt;&lt; std::endl;
  std::cout.rdbuf(oldbuf);  

  std::cout &lt;&lt; ""Should go to console again ... and here's the string: '"" 
            &lt;&lt; s &lt;&lt; ""'"" &lt;&lt; std::endl;
}
</code></pre>

<p>Outputs:</p>

<p>Should go to console again ... and here's the string: 'Original string: Should go to string'</p>
",0
1111847,1111744,8,"<p>What you want is to change C++ into something very different. One of the (many) goals of C++ was efficient implementation. Doing string lookup for function calls (no matter how well you implement it), just isn't going to be very efficient compared to the normal call mechanisms.</p>

<p>Basically, I think you're trying to shoehorn in functionality of a different language. You CAN make it work, to some degree, but you're creating C++ code that no one else is going to be able (or willing) to try to understand. </p>

<p>If you really want to write in a language that can change it's objects on the fly, then go find such a language (there are many choices, I'm sure). Trying to shoehorn that functionality into C++ is just going to cause you problems down the road.</p>

<p>Please note that I'm no stranger to bringing in non-C++ concepts into C++. I once spent a considerable amount of time removing another engineer's attempt at bringing a based-object system into a C++ project (he liked the idea of containers of 'Object *', so he made every class in the system descend from his very own 'Object' class). </p>

<p>Bringing in foreign language concepts almost always ends badly in two ways: The concept runs up against other C++ concepts, and can't work as well as it did in the source language, AND the concept tends to break something else in C++. You end up losing a lot of time trying to implement something that just isn't going to work out.</p>

<p>The only way I could see something like this working at all well, is if you implemented a new language on top of C++, with a cfront-style pre-compiler. That way, you could put some decent syntax onto the thing, and eliminate some of your problems. </p>
",1
1111872,1111744,0,"<p>I keep thinking of the Visitor pattern.  That allows you to do a vtable lookup on the visiting object (as well as the visited object, thought that doesn't seem relevant to your question).</p>

<p>And at runtime, you could have some variable which refers to the visitor, and call </p>

<pre><code>Dynamic dynamic;
DynamicVisitor * dv = ...;
dynamic-&gt;Accept(dv);
dv = ...; // something else
dynamic-&gt;Accept(dv);
</code></pre>

<p>The point is, the visitor object has a vtable, which you said you wanted, and you can change its value dynamically, which you said you wanted.  Accept is basically the ""function to call things I didn't know about at compile time.""</p>
",3
1111776,1111744,0,"<p>I don't think there's a library for this exact thing.</p>

<p>Of course, you have to have these functions pre-written somehow, so it seems there would be an easier way to do what you want. For example you could have just one method to execute arbitrary code from your favorite scripting language. That seems like an easier way to do what you want.</p>
",1
1111845,1111744,2,"<p>I don't think it would be a good idea to change C++ enough to make this work.  I'd suggest working in another language, such as Lisp or Perl or another language that's basically dynamic, or imbedding a dynamic language and using it.</p>
",3
1112032,1111744,1,"<p>What you are doing is actually a variation of the <a href=""http://en.wikipedia.org/wiki/Visitor_pattern"" rel=""nofollow noreferrer"">Visitor pattern</a>.</p>

<p>EDIT: By the way, another approach would be by using Lua, since the language allows you to add functions at runtime. So does Objective-C++.</p>

<p>EDIT 2: You could actually inherit from FuncMap as well:</p>

<pre><code>class Dynamic;

typedef std::map&lt;std::string, boost::function&lt;void (Dynamic&amp;)&gt; &gt; FuncMap;

class Dynamic : public FuncMap
{
public:
};

void f(Dynamic&amp; self) {
    //doStuffWithDynamic(self);
}

int main()
{
    Dynamic dyn;
    dyn[""f""] = boost::bind(&amp;f, _1);
    dyn[""f""](dyn); // invoke f, however, 'dyn'param is awkward...
    return 0;
}
</code></pre>
",2
1112115,1111744,0,"<p>I've considered doing this before as well.  Basically, however, you'd be on your way to writing a simple VM or interpreter (look at, say, Lua or <a href=""http://sourceforge.net/projects/topaz/files/"" rel=""nofollow noreferrer"">Topaz</a>'s source to see what I mean -- Topaz is a dead project that pre-dates Parrot).</p>

<p>But if you're going that route it makes sense to just use an existing VM or interpreter.</p>
",2
1112127,1111744,1,"<p>If I understand what you are trying to accomplish correctly, it seems as though dynamic linking (i.e. Dynamically loaded libraries in <a href=""http://msdn.microsoft.com/en-us/library/ms682599%28VS.85%29.aspx"" rel=""nofollow noreferrer"">windows</a> or <a href=""http://www.linux.org/docs/ldp/howto/Program-Library-HOWTO/dl-libraries.html"" rel=""nofollow noreferrer"">linux</a>) will do most of what you are trying to accomplish.</p>

<p>That is, you can, at runtime, select the name of the function you want to execute (eg. the name of the DLL), which then gets loaded and executed. Much in the way that COM works. Or you can even use the name of the function exported from that library to select the correct function (C++ name mangling issues aside).</p>
",1
1114277,1111744,3,"<p>If you implemented this, even as a pure library, and then used it extensively, you would in a way be using a new language - one with a hideous syntax, and a curious combination of runtime method resolution and unreliable bounds checking.</p>

<p>As a fan of C/C++ style syntax and apparently a fan of dynamic method dispatch, you may be interested in C# 4.0, which is now in Beta, and has the <code>dynamic</code> keyword to allow exactly this kind of thing to be seamlessly mixed into normal statically typed code.</p>
",2
550459,550455,2,"<p>If you declare the main function in another file, then you must compile the two files separately, and then link them into 1 executable.</p>

<p>Unless you include the entire contents of the file from the file with the main function, that will work too, though a bit odd. But, if you do this then you have to make sure that you compile the file which has the main() function.</p>
",0
550462,550455,28,"<p>You have tried to link it already:</p>

<pre><code>g++ file.cpp
</code></pre>

<p>That will not only compile it, but try to already create the executable. The linker then is unable to find the main function that it needs. Well, do it like this:</p>

<pre><code>g++ -c file.cpp
g++ -c hasmain.cpp
</code></pre>

<p>That will create two files file.o and hasmain.o, both only compiled so far. Now you can link them together with g++:</p>

<pre><code>g++ -omy_program hasmain.o file.o
</code></pre>

<p>It will automatically figure out that those are files already compiled, and invoke the linker on them to create a file ""my_program"" which is your executable.</p>
",0
896113,896103,1,"<p>std::string to const char*:</p>

<pre><code>  my_str.c_str();
</code></pre>

<p>char* to std::string:</p>

<pre><code>  string my_str1 (""test"");
  char test[] = ""test"";
  string my_str2 (test);
</code></pre>

<p>or even</p>

<pre><code>  string my_str3 = ""test"";
</code></pre>
",4
896115,896103,0,"<pre><code>std::string buf2str(const char* buffer)
{
    return std::string(buffer);
}
</code></pre>

<p>Or just</p>

<pre><code>std::string mystring(buffer);
</code></pre>
",1
896148,896103,26,"<p>Given your input strings are not null terminated, you shouldn't use str... functions.  You also can't use the popularly used <a href=""http://en.cppreference.com/w/cpp/string/basic_string/basic_string"" rel=""noreferrer""><code>std::string</code> constructors</a>.  However, you can use this constructor:</p>

<p><code>std::string str(buffer, buflen)</code>: it takes a <code>char*</code> and a length. (actually <code>const char*</code> and length)</p>

<p>I would avoid the C string version.  This would give:</p>

<pre><code>std::string bufferToString(char* buffer, int bufflen)
{
    std::string ret(buffer, bufflen);

    return ret;
}
</code></pre>

<p>If you really must use the <code>C-string</code> version, either drop a <code>0</code> at the <code>bufflen</code> position (if you can) or create a buffer of <code>bufflen+1</code>, then <code>memcpy</code> the buffer into it, and drop a <code>0</code> at the end (<code>bufflen</code> position).</p>
",8
896181,896103,5,"<p>If the data buffer may have null ('\0') characters in it, you don't want to use the null-terminated operations.</p>

<p>You can either use the constructor that takes char*, length.</p>

<pre><code>char buff[4] = {'a', 'b', 'c', 'd'};
cout &lt;&lt; std::string(&amp;buff[0], 4);
</code></pre>

<p>Or you can use the constructor that takes a range:</p>

<pre><code>cout &lt;&lt; std::string(&amp;buff[0], &amp;buff[4]); // end is last plus one
</code></pre>

<p>Do NOT use the std::string(buff) constructor with the buff[] array above, because it is not null-terminated.</p>
",1
896183,896103,0,"<p>Use string constructor that takes the size: </p>

<blockquote>
<pre><code>string ( const char * s, size_t n );
</code></pre>
  
  <p>Content is initialized to a copy of the string formed by the first n
  characters in the array of characters
  pointed by s.</p>
</blockquote>

<pre><code>cout &lt;&lt; std::string(buff, sizeof(buff)) &lt;&lt; endl;
</code></pre>

<p><a href=""http://www.cplusplus.com/reference/string/string/string/"" rel=""nofollow noreferrer"">http://www.cplusplus.com/reference/string/string/string/</a></p>

<p>Non-null-terminated buffer to C string:</p>

<pre><code>memcpy(str, buff, buffSize);
str[bufSize] = 0; // not buffSize+1, because C indexes are 0-based.
</code></pre>
",0
896254,896103,1,"<p>The method needs to know the size of the string. You have to either:</p>

<ol>
<li>in case of char* pass the length to
method</li>
<li>in case of char* pointing to null
terminating array of characters you can
use everything up to null
character</li>
<li>for char[] you can use templates to
figure out the size of the char[]</li>
</ol>

<p>1) example - for cases where you're    passing the bufflen:</p>

<pre><code>std::string bufferToString(char* buffer, int bufflen)
{
    return std::string(buffer, bufflen);
}
</code></pre>

<p>2) example - for cases where buffer is points to null terminated array of characters:</p>

<pre><code>std::string bufferToString(char* buffer)
{
    return std::string(buffer);
}
</code></pre>

<p>3) example - for cases where you pass char[]:</p>

<pre><code>template &lt;typename T, size_t N&gt;
std::string tostr(T (&amp;array)[N])
{
    return std::string(array, N);
}


Usage:
char tstr[] = ""Test String"";
std::string res = tostr(tstr);
std::cout &lt;&lt; res &lt;&lt; std::endl;
</code></pre>

<p>For the first 2 cases you don't actually have to create new method:</p>

<pre><code> std::string(buffer, bufflen);
 std::string(buffer);
</code></pre>
",0
880319,871354,0,"<p>I would move the 'sqrt' detection into another method for function detection. Essentially, I would remove the 's' detection and add something inside the default case that would read the string up to a '('. </p>

<p>If no '(' is detected, then error. </p>

<p>If you successfully read a string, pass that to a function name parser that uses string compares to generate a token that represents a call to sqrt or sin or whatever function you like. The method that checks for the function names can also error if it reads a string that it doesn't recognize.</p>
",1
880473,871354,10,"<p>I thought a map of strings to function pointers might be a concise way to represent things like sqrt, sin, cos, etc. that take a single double and return a double:</p>

<pre><code>map&lt;std::string, double (*)(double)&gt; funcs;
funcs[""sqrt""] = &amp;sqrt;
funcs[""sin""] = &amp;sin;
funcs[""cos""] = &amp;cos;
</code></pre>

<p>Then when the parser detects a correct string (str) it can call the function with an argument (<code>arg</code>) like so:</p>

<pre><code>double result = funcs[str](arg);
</code></pre>

<p>With this method, a single call can handle all cases of functions (of that type).</p>

<p>Actually I'm not sure if that's the correct syntax, can anyone confirm?</p>

<p>Does this seem like a usable method?</p>
",1
883164,871354,4,"<p>It is easier to work with derived classes and virtual functions: each specialized class reading its own input...</p>

<pre><code>class base {
    public:
        virtual double calc() = 0;
};

class get_sqrt : public base {
    int useless;

    public:
        virtual double calc() {
            cin &gt;&gt; number;
            return sqrt(number);
        }
}

get_sqrt;
</code></pre>

<p>Now we organize these in a map, and we will only use their pointers:</p>

<pre><code>map&lt;string,base*&gt; func;
func[""sqrt""] = &amp;get_sqrt;
</code></pre>

<p>There is also a specialized method which only looks at the next character: peek();</p>

<pre><code>char c = cin.peek();
</code></pre>

<p>You can get rid of the switch by using 1 if putting <code>!</code>, <code>+</code>, <code>-</code>, etc. in <code>func</code>; (they should operate on left_param for simplicity):</p>

<pre><code> if (c&gt;='0' &amp;&amp; c&lt;='9')
     cin &gt;&gt; right_param; // Get a number, you don't have to put the
                         // character back as it hasn't been removed
 else {
     string s;
     cin &gt;&gt; s;
     right_param = func[s]-&gt;calc();
 }
</code></pre>

<p>So basically some kind of function pointers, but without the messy syntax and in which you could store data between calculations.</p>

<p>I thought about the whitespace problem; it can be added before it starts to compute, I also think there could be a way to set different separators, like numbers, but I don't know how.</p>
",4
887999,871354,215,"<ol>
<li><p>There are a few solutions posted on <a href=""http://www.stroustrup.com/Programming/"" rel=""nofollow noreferrer"">Stroustrup - Programming</a> and more will be coming over time.</p></li>
<li><p>Try solving exercises only with the language features and the library facilities presented so far in the book -- real novice users can't do anything else. Then return later to see how a solution can be improved.</p></li>
</ol>
",4
954278,954261,2,"<p><a href=""http://en.wikipedia.org/wiki/Libavcodec#Implemented_video_codecs"" rel=""nofollow noreferrer"">libavcodec</a> (a library behind ffmpeg and other heavily-used programs) supports some common Real video formats.  See <a href=""http://www.inb.uni-luebeck.de/~boehme/using_libavcodec.html"" rel=""nofollow noreferrer"">this page</a>; the tutorial itself is obsolete, but there are linked updates such as <a href=""http://www.dranger.com/ffmpeg/"" rel=""nofollow noreferrer"">An ffmpeg and SDL Tutorial</a></p>

<p>Helix may be an option, but keep in mind the actual Real Video codecs are only available as binaries, while libavcode is fully open source.</p>

<p>Don't expect this to be trivial, whichever library you use. </p>
",0
894598,894521,1,"<p>You should add friend classes/methods there, but friendship is clear: in C++ <em>friends can touch your private parts</em>.</p>
",0
894602,894521,0,"<p>Your best bet is to learn the meaning of the public, protected, and private keywords. If the table helps you learn that then by all means use it; it is correct. If you want to be an effective C++ programmer this should be as easy as breathing.</p>
",0
894606,894521,1,"<p>The table is correct, if that's what you're asking.</p>

<p>What it's saying in words is that you can always access member variables of the class your method is in. If the member variable is defined in a parent class then you can only access it if the member variable is protected or public. If you're outside the class then you can only access public member variables.</p>

<p>There is no ""best way"" -- these are the rules presented in a reasonable fashion.</p>
",0
894617,894521,0,"<p>It's correct, aside from friends.</p>

<p>That being said, for any class that's more than a C-like struct of more or less related data, all member variables should be private.  There is almost never a good reason to use protected variables.</p>
",0
1413246,1413239,8,"<p>You probably has UNICODE defined, and LPTSTR expands into wchar_t*. Use TEXT macro for string literals to avoid problems with that, e.g. <code>foo(TEXT(""bar""))</code>.</p>
",3
1413250,1413239,2,"<p>An LPTSTR is a non-const pointer to a TCHAR. A TCHAR, in turn, is defined as char in ANSI builds and wchar_t in Unicode builds (with the UNICODE and/or _UNICODE symbols defined).</p>

<p>So, an LPTSTR is equivalent to:</p>

<pre><code>  TCHAR foo[] = _T(""bar"");
</code></pre>

<p>As it's not const, you can't safely call it with a literal -- literals can be allocated in read-only memory segments, and LPTSTR is a signal that the callee may alter the contents of the string, e.g.</p>

<pre><code>  void truncate(LPTSTR s)
  {
     if (_tcslen(s) &gt; 4)
        s[3] = _T('\0');
  }
</code></pre>

<p>That would crash if you passed in a literal, when compiled with Visual C++ 2008.</p>
",1
1413392,1413239,1,"<pre><code>foo(const_cast&lt;LPTSTR&gt;(""bar""));
</code></pre>

<p>Will crash as explained above when foo tries to change the data that's been passed to it.</p>
",0
1989139,1988978,1,"<p>To summarize:</p>

<ul>
<li>There is no such thing as partial specialization of functions. Only overloading that function with your specific types</li>
<li>It is generally forbidden to put stuff in namespace std</li>
<li>What you really want is to put an overload for for_each in the namespace of the specific iterator types (""next to"") you're overloading on. This ensures ADL will find it.</li>
</ul>
",0
1989013,1988978,1,"<p>std::for_each  is a public well documented algorithm function,   I don't think I wound like it if some library I am using goes around changing it ;-.  Possibly other parts of my program need the good old for_each </p>

<p>So I would go with the solution that doesn't break this interface and leaves std::for_each as it is. </p>
",0
1989082,1988978,6,"<p>You can specialize templates in std (17.4.3.1), but you can't add overloads. Your definition is an overload, not a specialization of the standard for_each template, and in any case functions can't be partially specialized. So it's undefined to put any definition in namespace std that might do what you want.</p>

<p>ADL is supposed to make this work smoothly without any need for that, though. I assume the stxxl iterators are in the stxxl namespace, so <code>for_each(first, last, f, 4);</code> should call <code>stxxl::for_each</code>. If you want <code>std::for_each</code>, you fully qualify the name when you call it.</p>
",0
1989089,1988978,2,"<p>As much as I would like to say that you want to inject into the <code>std</code> namespace, it really is a sticky wicket as Neil pointed out.  The <a href=""https://stackoverflow.com/questions/11562/how-to-overload-stdswap/109613#109613"">related thread of <code>std::swap</code></a> points out a number of the details as does the now infamous <a href=""http://groups.google.com/group/comp.lang.c++.moderated/browse_thread/thread/b396fedad7dcdc81"" rel=""nofollow noreferrer"">USENET discussion on the subject</a>.</p>

<p>To sum it up, the only way that you are allowed to inject a name into <code>std</code> is if you can fully specialize it.  So, you can write:</p>

<pre><code>namespace std {
    template &lt;&gt;
    MyFunction for_each(stxxl::vector&lt;Data&gt;::const_iterator first,
                        stxxl::vector&lt;Data&gt;::const_iterator last,
                        MyFunction func)
    {
        return stxxl::for_each(first, last, func);
    }
}
</code></pre>

<p>for every combination of container and function and you are well within the rules.  Unfortunately, partial function template specialization doesn't exist in the current incarnation of the Standard.  If you are really curious, dedicate an evening to reading the entire <a href=""http://groups.google.com/group/comp.lang.c++.moderated/browse_thread/thread/b396fedad7dcdc81"" rel=""nofollow noreferrer"">USENET post</a>.  It really is quite enlightening and a little frightening.  You can probably write a nifty macro (gasp) to automate this for you if you only use a few type/function combinations.</p>

<p>You can use <a href=""http://en.wikipedia.org/wiki/Argument_dependent_name_lookup"" rel=""nofollow noreferrer"">ADL</a> to solve the problem as well provided that none of the <code>stxxl</code> stuff simply exposes an iterator from <code>std</code> using a typedef.  I believe that this is generally the preferred solution today.</p>

<p>I would add your own wrapper around <code>for_each</code> that forwards to the appropriate one and call it done.  This isn't the most elegant, but it will work now and doesn't rely on any magic to make it happen.</p>
",5
1989094,1988978,0,"<p>I would not try and specialize std::for_each().<br>
Especially since what you want is partial specialization.</p>

<p>Rather I would write a function that used std::for_each() but had a specialization for stlxxl.<br>
I don't have stlxxl so I have done some code that demonstrates what I mean.</p>

<pre><code>#include &lt;vector&gt;
#include &lt;list&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

//
// Normal version.
template&lt;typename U,typename T,typename A,template&lt;class I,class A&gt; class C&gt;
U Ufor_each(C&lt;T,A&gt;&amp; cont,U const&amp; f)
{
    std::cout &lt;&lt; ""NORMAL Start"" &lt;&lt; std::endl;
    return std::for_each(cont.begin(),cont.end(),f);
    return f;
}

// 
// Specialized version.
// You could write a specialized version for stlxxl::vector
template&lt;typename U,typename T&gt;
U Ufor_each(std::vector&lt;T&gt;&amp; cont,U const&amp; f)
{
    std::cout &lt;&lt; ""Vector Start"" &lt;&lt; std::endl;
    return std::for_each(cont.begin(),cont.end(),f);
}

struct X
{
    void operator()(int data) const
    {
        std::cout &lt;&lt; ""Item: "" &lt;&lt; data &lt;&lt; std::endl;
    }
};

int main()
{
    std::vector&lt;int&gt;    vect;
    std::list&lt;int&gt;      list;

    vect.push_back(1);
    list.push_back(4);

    X                   x;
    Ufor_each(vect,x);
    Ufor_each(list,x);
}
</code></pre>

<p>I tried but failed to get it working with iterators.</p>
",1
879793,879535,141,"<p>This is a common point of confusion for many (including the Generic Programming page on Wikipedia, some C++ tutorials, and other answers on this page).  As far as C++ is concerned, <strong>there is no such thing as a ""template class,"" there is only a ""class template.""</strong>  The way to read that phrase is ""a template for a class,"" as opposed to a ""function template,"" which is ""a template for a function.""  <strong>Again: classes do not define templates, templates define classes</strong> (and functions).  For example, this is a <em>template</em>, specifically a <em>class template</em>, but <em>it is <strong>not</strong> a class</em>:</p>

<pre><code>template&lt;typename T&gt; class MyClassTemplate
{ 
    ...
};
</code></pre>

<p>The declaration <code>MyClassTemplate&lt;int&gt;</code> <strong>is a class,</strong> or pedantically, a class based on a template.  <em>There are no special properties of a class based on a template vs. a class not based on a template.</em>  The special properties are <em>of the template itself</em>.</p>

<p>The phrase ""template class"" means nothing, because the word ""template"" has no meaning as an adjective when applied to the noun ""class"" as far as C++ is concerned.  It implies the existence of a <em>class</em> that <strong>is</strong> (or defines) a <em>template</em>, which is not a concept that exists in C++.</p>

<p>I understand the common confusion, as it is probably based on the fact that the words appear in the order ""template class"" in the actual language, which is a whole other story.</p>
",6
879550,879535,6,"<p>A template class is related to the <a href=""http://en.wikipedia.org/wiki/Template_method_pattern"" rel=""noreferrer"">Template Method design pattern</a>, while class template is just a ""fill-in-the-blanks"" class template.</p>
",0
880323,879535,15,"<p>The difference is that the term ""template class"" does simply not exist in the C++ Standard. It's a term used mostly by people that think that the term ""class template"" is confusing (like the Qt companies Nokia and formerly Trolltech). </p>

<p>The Standard has no concept of it, so it's up to other peoples to make a difference. Some people use it synonymously, and others say that the term ""template class"" refers to an instantiated or explicitly specialized class template, which would make it equivalent to the term ""class template specialization"". Historyically, it had this meaning. The <a href=""https://rads.stackoverflow.com/amzn/click/com/0201514591"" rel=""noreferrer"" rel=""nofollow noreferrer"">Annotated Reference Manual</a> defines at page 343</p>

<blockquote>
  <p>A class generated from a class template is called a template class, as is a class specifically defined with a <em>template-class-name</em> as its name</p>
</blockquote>

<p>The non-terminal <em>template-class-name</em> is equivalent to the non-terminal <em>template-id</em> used in todays Standard and comes down <code>template-name &lt; arguments &gt;</code>. </p>

<hr>

<p>To get you familiar with the today terms, which is more important than using dubious old terms</p>

<pre><code>// (1) defines a class template
template&lt;typename T&gt; class A { }; 

// (2) defines a class template explicit specialization 
template&lt;&gt; class A&lt;int&gt; { };

// (3) defines a class template partial specialization
template&lt;typename T&gt; class A&lt;T*&gt; { };

// (4) explicitly instantiates A&lt;char&gt;. 
template class A&lt;char&gt;;

// (5) implicitly instantiates A&lt;short&gt; (because of the member declaration)
struct D { A&lt;short&gt; a; };
</code></pre>

<ul>
<li>The ARM called the class (2), and the classes generated by (4) and (5) a <em>template class</em>. I'm not sure whether the ARM already knew about partial specializations. But if so (3) was not called a template class, because (3) does not define a class, but defines a template. </li>
<li>The current Standard calls class (2), and the ones generated by (4) and (5) <em>class template specializations</em>. And (3) is called a <em>partial specialization</em>, as opposed to an <em>explicit specialization</em>. It also sometimes calls (3) a specialization (3.2/5 - however with clarifying cross-links), although i find this isn't entirely clear to me, since it defines a ""specialization"" as being a ""class, function or class member"", which (3) doesn't satisfy. </li>
</ul>
",2
1226462,1225177,2,"<p>Some compilers don't properly implement <em>value initialization</em>. For example, see Microsoft Connect, <a href=""https://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=100744"" rel=""nofollow noreferrer"">Value-initialization in new-expression</a>, reported by Pavel Kuznetsov.</p>

<p>Fernando Cacciola's <a href=""http://www.boost.org/doc/libs/1_39_0/libs/utility/value_init.htm"" rel=""nofollow noreferrer"">boost::value_initialized</a> (mentioned already here by <a href=""https://stackoverflow.com/users/34509/litb"">litb</a>) offers a workaround to such compiler bugs.</p>
",0
1226393,1225177,5,"<blockquote>
  <p>This is a valid pattern?</p>
</blockquote>

<p>It's a known ""valid"" pattern, i would say. Boost has a class template called <a href=""http://www.boost.org/doc/libs/1_39_0/libs/utility/value_init.htm"" rel=""noreferrer""><code>value_initialized</code></a> that does exactly that, too.</p>

<blockquote>
  <p>I am using the right terminology?</p>
</blockquote>

<p>Well, your template can be optimized to have fewer requirements on the type parameter. As of now, your type <code>T</code> requires a copy constructor, unfortunately. Let's change the initializer to the following </p>

<pre><code>DefaultInitialize():m_value(){}
</code></pre>

<p>Then, technically this kind of initialization is called <code>value initialization</code>, starting with C++03. It's a little bit weird, since no kind of value is provided in the first place. Well, this kind of initialization looks like default initialization, but is intended to fill things with zero, but respecting any user defined constructor and executing that instead.</p>

<p>To summarize, what you did was to value initialize an object having type <code>T</code>, then to copy that object to <code>m_value</code>. What my version of above does it to value initialize the member directly. </p>
",1
1208972,1208961,6,"<p>Exactly what effect are you trying to acheive?  </p>

<p>Even if you could assign a new pointer (or <code>NULL</code>) to '<code>this</code>' (which you can't), it wouldn't affect the pointer '<code>a</code>'.</p>
",1
1208973,1208961,4,"<p><code>this</code> is a constant pointer. You can change what it points to but you can't change the pointer itself.</p>

<p>As noted in comments, yes, you can cast the <code>const</code> away, but even if you change that, it's just a local variable. It won't affect the actual outside reference.</p>
",1
1208986,1208961,1,"<p>I can't see any reason you would ever want to do this. It would cause a memory leak, as <code>a</code> would be floating around presumably without any pointers to it. And I'm almost certain you can't assign to <code>this</code> anyway, largely because it doesn't make any sense. Why do you want to do it?</p>
",0
1209000,1208961,5,"<p>No. The object knows nothing about the external references to it (in this case, ""a""), so it can't change them.</p>

<p>If you want the caller to forget your object, then you can do this:</p>

<pre><code>class MyClass
{
    void Release(MyClass **ppObject)
    {
        assert(*pObject == this);   // Ensure the pointer passed in points at us
        *ppObject = NULL;           // Clear the caller's pointer
    }
}


MyClass *pA = new A;
pA-&gt;Release(&amp;pA);
assert(pA);               // This assert will fire, as pA is now NULL
</code></pre>

<p>When you call Release, you pass in the pointer you hold to the object, and it NULLs it out so that after the call, your pointer is NULL.</p>

<p>(Release() can also ""delete this;"" so that it destroys itself at the same time)</p>
",4
1209026,1208961,1,"<p>Think about why the following won't do what you want:</p>

<pre><code>A *a = new A;
A *b = a;
a = NULL;
assert(b);
</code></pre>

<p>and you'll see why setting this to NULL won't work.</p>
",0
1209030,1208961,1,"<p>The 'this' pointer is simply the address of the instance of the object your code is in. Setting <code>this = null;</code> isn't allowed because it doesn't make sense. It would appear your looking for</p>

<pre><code>Class A
{
  public:
    ~A
   {
      // clean up A
   }
}

A * a = new A;
delete a;

assert(a);  //should assert here
</code></pre>

<p>This will free the instance from memory. However if you have any other references to a, those pointers will still be pointing where that instance was (not good!) and need to be set to null.</p>
",1
1145572,1145186,2,"<p>While it is more expensive, you should define what operations can be allowed for external code and implement them. If you do not want to offer those operations in your public/protected interface, the solution you have posted (declaring another class as a <code>friend</code> and using it as a proxy into your internal code) is a fine solution.</p>

<p>This is subjective, and probably an unwanted comment, but anyway... There is no such thing as a <em>good design</em> mechanism for exposing class internals.</p>

<p>&lt; irony>Just make everything public &lt; /irony></p>

<p>What you are doing is developing a complex mechanism to break your encapsulation. After you are done with it, all code can access your private members. You state that <em>only predicate functors</em> will have access to the members, but you cannot block non-predicate classes from <em>deriving</em> from the predicate type just to acquire access to the data.</p>

<p>One of the points of encapsulation is reducing dependencies: external code only depend on the public interface, you can always change your internal types and representation and external code will not break (external as <code>not class or friend</code> code). Now, after you have exposed (directly or indirectly) your internals, then those are now part of your public interface and must thus be frozen.</p>

<p>Another point of encapsulation is that you can guarantee invariants on the internal data. After external code have access to the internals, there is no way you can control any kind of invariant on your methods (say keeping the <code>max_size</code> field of a container to the size of the acquired memory) and your class can break due to others misuse.</p>

<p>There are reasons for friendship not being transitive nor inherited: when you declare a class to be a friend of your class, you can check the behavior of that class (and in most cases you are in full control of the friend class). You know that the code you are giving access to does not break your own code.</p>

<pre><code>class Widget
{
   friend class BackDoor; // assume that you have implemented it
};
class MaliciousClass1 // third class, malicious or not cannot break into Widget
{
};
class MaliciousClass2 : public BackDoor // You cannot block external code from deriving from BackDoor 
{
   // Can break into your widget, access and modify anything
};
</code></pre>

<p>The door is open for any and everyone to play with your private parts.</p>
",3
1788374,1788357,5,"<pre><code>class Human : public std::vector&lt;Human *&gt;
</code></pre>

<p>Not a good idea -- STL containers are typically not designed to be derived from. Think of containment rather than inheritance.</p>

<pre><code>void main()
</code></pre>

<p><code>main</code> returns an <code>int</code>. Always. </p>

<p>This looks like a straight-forward problem. Think of a tree-like structure. You may want to change the container you are using (i.e. <code>vector</code>) to something more suitable.</p>

<p>Be warned, your question smells a lot like homework, so there'd be few responses!</p>
",0
1788376,1788357,0,"<ol>
<li>Print the name and generation for the starting object</li>
<li>For each child object, print their name and generation.</li>
<li>For each child object (the same list of children as line 2), print their tree by starting at line 2 with the child object's children</li>
</ol>
",0
1788521,1788357,1,"<p>For the algorithm I think a Topological sort will fit, but you need a graph not a vector</p>
",0
1190653,1190603,1,"<p>You can even assign multibyte ""values"" that end up being up to 32-bit ints:</p>

<pre><code>enum t_f_fnf
{
    true = 'true',
    false = 'fals',
    file_not_found = 'fnf!'
};
</code></pre>

<p>(With a nod to the dailywtf. :) )</p>
",6
1190687,1190603,8,"<p>That is <strong>not</strong> a single-quoted string ¡ª it's a character literal. Using a character literal in an enum is essentially the same as assigning a <code>char</code> to an <code>int</code> ¡ª it's totally legal and can be quite useful in many situations.</p>
",1
1190621,1190603,9,"<p>It is definitely perfectly legal according to ISO C and C++ standards. And it is a fairly reasonable practice if those enum values are serialized to text (e.g. CSV) files as those characters. Otherwise, I don't see much point. I guess it could give some debugging benefits, but all good C/C++ debuggers I know can resolve enum values to corresponding symbols anyway. </p>
",0
1190622,1190603,2,"<p>Unless code somewhere expects Option_1 to be 'a', I don't see the benefit.</p>
",0
1190625,1190603,5,"<p>chars are just 1 byte ints, so why not?</p>
",4
1190632,1190603,2,"<p>Sometimes enums with explicit values are used where the actual value is important. If those values are ""ascii value of the letter a"" why shouldn't you tell the reader by assigning 'a'?</p>
",0
1190637,1190603,6,"<p>It looks ok to me, would you rather have:</p>

<pre><code>enum
{
  Option_1 = 97,
  Option_2 = 98
} ;
</code></pre>
",0
1190998,1190603,-1,"<p>Hiya, please consider this simple example I've made for you, 
as you can see it is legal to use enums this way. In my case, I use them as a sort of
internal constants for a class. Enjoy.</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

class VegetableBasket
{
    enum { Max_Potatoes = 2 };  // This is a legal usage...
    enum { Max_Tomatoes = 3 };  // In here the enums serve as class's internal constants
    public :
        // Constructors
        VegetableBasket() : tomatoes(0), potatoes(0) {}
        VegetableBasket(int t, int p) : tomatoes(t), potatoes(p) 
        { 
            if(tomatoes &gt; Max_Tomatoes) 
                tomatoes = Max_Tomatoes;
            if(potatoes &gt; Max_Potatoes)
                potatoes = Max_Potatoes;
        }
        // Accessors
        int getMaxPotatoes() const { return Max_Potatoes; }
        int getMaxTomatoes() const { return Max_Tomatoes; }
        int getPotatoes() const { return potatoes; }
        int getTomatoes() const { return tomatoes; }
    private :
        int tomatoes;
        int potatoes;
};


void main()
{
    VegetableBasket basket1(1, 1);
    VegetableBasket basket2(5, 6);

    cout &lt;&lt; ""The basket holds : "" &lt;&lt; basket1.getMaxPotatoes() 
         &lt;&lt; "" max potatoes, and "" &lt;&lt; basket1.getMaxTomatoes()
         &lt;&lt; "" max tomatoes"" &lt;&lt; endl;

    cout &lt;&lt; ""Basket 1 holds : "" &lt;&lt; basket1.getPotatoes()
         &lt;&lt; "" potatoes and ""    &lt;&lt; basket1.getTomatoes()
         &lt;&lt; "" tomatoes"" &lt;&lt; endl;

    cout &lt;&lt; ""Basket 2 holds : "" &lt;&lt; basket2.getPotatoes()
         &lt;&lt; "" potatoes and ""    &lt;&lt; basket2.getTomatoes()
         &lt;&lt; "" tomatoes"" &lt;&lt; endl;
}
</code></pre>
",1
1325609,1325607,2,"<p>You must use the double colon access operator.  This is the only valid way of accessing static members from a class name. </p>
",3
1325613,1325607,14,"<p>If you have an instance variable you may use dot operator to access static members if accessible.</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

class Test{
    public:
        static int no;
};

int Test::no;
int main(){
  cout &lt;&lt; ""\n"" &lt;&lt; Test::no;
  Test::no=100;
  Test a;
  cout &lt;&lt; ""\n"" &lt;&lt; a.no;
 return 0;
}
</code></pre>
",2
1325704,1325607,2,"<p>It's not necessarily the ""can you"" question (because the compiler will often let you off with warnings), but the ""should you"" question.</p>

<p>Static data members are not part of the object, and therefore should not be treated as such.</p>

<p>Accessing a static data member as a ""normal"" data member can make the code less readible too, since it may imply different semantics (though this is usually unlikely).</p>
",1
1500644,936025,2,"<p>The examples shown in the docs are extracted from the library's unit tests. Take a look at <code>libs/accumulators/test/weighted_p_square_cum_dist.cpp</code></p>
",0
960291,960218,2,"<p>It's not a tutorial per-se but the <a href=""http://www.parashift.com/c++-faq-lite/"" rel=""nofollow noreferrer"">C++ FAQ LITE</a> is an invaluable resource IMHO.</p>
",0
960867,960218,0,"<p>I second Rob Wells; ""Accelerated C++"" is an excellent book. It would be hard to do better. </p>

<p>I would like to add that pointers can be especially daunting coming from your background. One of the best explanations I have come across is here at the <a href=""http://cslibrary.stanford.edu/"" rel=""nofollow noreferrer"">Stanford CS web site</a>. They have several pdfs and even an animated video on the subject.</p>
",0
960221,960218,7,"<p><a href=""http://www.cplusplus.com/"" rel=""noreferrer"">www.cplusplus.com</a> is a great website with tons of documentation for experts and beginners.</p>

<p>Tutorials for beginners:</p>

<p><a href=""http://www.cplusplus.com/doc/tutorial/"" rel=""noreferrer"">http://www.cplusplus.com/doc/tutorial/</a></p>

<p>An additional website I heartily reccomend once you have a little more expertise is the <a href=""http://www.parashift.com/c++-faq-lite/"" rel=""noreferrer"">C++ FAQ Lite.</a></p>
",0
960225,960218,6,"<p>The text of a good book is online here: <a href=""http://www.mindview.net/Books/TICPP/ThinkingInCPP2e.html"" rel=""nofollow noreferrer"">Thinking in C++</a></p>
",4
960229,960218,3,"<p>G'day,</p>

<p>I know it isn't a website but I'd highly recommend working through the excellent book Accelerated C++ (<a href=""https://rads.stackoverflow.com/amzn/click/com/020170353X"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">sanitised Amazon link</a>) by Andy Koenig and Barbara Moo.</p>

<p>It'll start you off properly by approaching C++ as it's own language rather than C with OO bits ""bolted on"". And you get to work with STL right from the start.</p>

<p>Highly recommended.</p>

<p>HTH</p>

<p>cheers,</p>
",0
960285,960218,0,"<p>Aprt from the useful links given by <a href=""https://stackoverflow.com/questions/960218/i-need-a-good-website-to-learn-c/960221#960221"">@Doug T</a>. You can have a look at the advanced puzzles of c++ @ <a href=""http://www.gotw.ca/gotw/"" rel=""nofollow noreferrer"">http://www.gotw.ca/gotw/</a> ( of course after the basics)</p>
",2
911883,910064,2,"<p>The <code>io_service</code> object is an abstraction of the <code>select</code> function. Set up your sockets and then call the <code>io_service::run</code> member function from your main thread. The <code>io_service::run</code> function will block until all of the work associated with the <code>io_service</code> instance is completed. You can schedule more work in your asynchronous handlers.</p>

<p>You can also use <code>io_service::run_one</code>, <code>io_service::poll</code>, or <code>io_service::poll_one</code> in place of <code>io_service::run</code>.</p>
",0
1141438,1141408,2,"<p>The problem here is that the C++ input streams do not remove malformatted input that they encounter. In other words if you try to read in a number and the stream contains, for example the character 'x' (not a number), that character isn't removed from the input stream. Additionally, if I remember correctly, that will also put the input stream in an error state causing well-formatted input to also fail. Although there is a mechanism for testing the state of the input stream and removing malformattted input and clearing the error flags, I have personally found it simpler to always read into a string  (using "">>"" or ""getline"") and then to parse the string. In the case of a number, for example, you can use the ""strtol"" or ""strtoul"" functions.</p>
",2
1123264,1123215,2,"<p>I think the best solution is to take a vector of ints and let the constructor validate it against the template parameter 'rank'. </p>

<pre><code>NDimensionalArray matrix(std::vector&lt;int&gt; matrixDimensions) 
{
    if (matrixDimensions.size() != rank) 
    {
        throw SomeException();
    }

    ...
}
</code></pre>

<p>I don't think any compiler trick can be an alternative here. (Except perhps using macros, if you can think of something, although that wouldn't be a <em>compiler</em> trick strictly speaking.)</p>
",4
1123291,1123215,1,"<p>Not a direct answer, but check out the blitz library.</p>
",0
1123341,1123215,1,"<p>You could take a std::tr1::array. Hmm:</p>

<pre><code>#include &lt;array&gt;

template&lt; class valType, int rank &gt;
class NDimensionalArray
{
public:
   NDimensionalArray(const std::tr1::array&lt;rank&gt;&amp; dims);
   // ...
};

NDimensionalArray&lt;double,2&gt; foo({10,10});

NDimensionalArray&lt;double,2&gt; bar({10}); // second dimension would be 0

NDimensionalArray&lt;double,1&gt; baz({10,10}); // compile error?
</code></pre>

<p>I'm not actually sure if that works! I'll run it through comeau.</p>

<p><strong>Edited</strong> As per the comments, looks like this approach would look more like:</p>

<pre><code>std::tr1::array&lt;2&gt; dims = {10, 10};
NDimensionalArray&lt;double,2&gt; foo(dims);
</code></pre>
",4
1123353,1123215,1,"<p>There's no good way to do it in C++ as currently standardized. In C++0x, you'll be able to use template parameter packs to approximate (I think I've got the syntax right, but not sure about expansion in <code>requires</code>):</p>

<pre><code>template &lt;class ValType, int Rank&gt;
struct NDimensionalArray
{
    template &lt;class... Args&gt;
    requires std::SameType&lt;Args, ValType&gt;... &amp;&amp; std::True&lt;sizeof...(Args) == Rank&gt;
    NDimensionalArray(Args... values)
    {
        ...
    }
};
</code></pre>
",1
1123392,1123215,0,"<p>Boost has a <a href=""http://www.boost.org/doc/libs/1_39_0/libs/multi_array/doc/user.html#sec_introduction"" rel=""nofollow noreferrer"">multi-array</a> library that uses a custom object for constructing their multidimensional array. It's a really good way to do it; I suggest you study (or better yet, use) their code.</p>
",2
1123409,1123215,7,"<p>Okay, I've played with this for a while. Here's some template metaprogramming hackery that does something close to what you want. It lets you specify all dimensions inline, it doesn't do any dynamic memory allocation or other such things. In addition, with a good C++ compiler (I tested with VC++ <code>/O2</code> option), the code will be fully inlined, with no copies done (in fact, for me it inlined the whole NDimensionalArray constructor at the point of the call). It will typecheck completely at compile-time, and won't let you pass too few or too many dimensions. And it can be reused for indexers. Here goes:</p>

<pre><code>template&lt;class T, int N&gt;
class value_pack : private value_pack&lt;T, N-1&gt;
{
public:

    enum { size = N };

    value_pack(value_pack&lt;T, N-1&gt; head, const T&amp; tail)
        : value_pack&lt;T, N-1&gt;(head)
        , value(tail)
    {
    }

    value_pack&lt;T, N+1&gt; operator() (const T&amp; tail) const
    {
        return value_pack&lt;T, N+1&gt;(*this, tail);
    }

    template&lt;int I&gt;
    const T&amp; get() const
    {
        return this-&gt;value_pack&lt;T, I+1&gt;::value;
    }

protected:

    const T value;
};

template&lt;class T&gt;
struct value_pack&lt;T, 0&gt;
{
};

struct
{
    template &lt;class T&gt;
    value_pack&lt;T, 1&gt; operator() (const T&amp; tail) const
    {
        return value_pack&lt;T, 1&gt;(value_pack&lt;T, 0&gt;(), tail);
    }
} const values;


template &lt;class ValType, int Rank&gt;
struct NDimensionalArray
{
    NDimensionalArray(value_pack&lt;ValType, Rank&gt; values)
    {
        // ...
    }
};


int main()
{
    NDimensionalArray&lt;int, 3&gt; a(values(1)(2)(3));
}
</code></pre>
",1
909369,909343,1,"<p>You're mistaken in your assumptions. <code>std::find_if()</code> merely requires an iterator, not necessarily an STL iterator. As it happens, <code>double*</code> supports both * and ++, so it too is an iterator.</p>
",1
909616,909343,0,"<pre><code>#include &lt;boost/lambda/lambda.hpp\&gt;

using namespace boost::lambda;

static const double whateverValueYouWant(12.);

double *const tplR = (double*) malloc(sampleDim[0]*sizeof(double));
const size_t actualItemsRead = fread(tplR, sizeof(double), sampleDim[0], dfile);
printf(""tplR = %d\n"", actualItemsRead );

const double *begin = tplR;
const double *const end = tplR + actualItemsRead;
const double *const foundItem = std::find_if( begin, end, _1== whateverValueYouWant);

if( foundItem!=end )
{
     //value found
}
else
{
    //no such value
}
</code></pre>
",0
909403,909343,5,"<p>You can use find_if with the array like this:</p>

<pre><code>bool equals(int p)
{
    return p == 9;
}


int main(int argc,char *argv[])
{
    int a[10];

    for(int i = 0; i &lt; 10; ++i)
    {
        a[i] = i;
    }

    int* p = std::find_if(a, a+10, equals);
    cout&lt;&lt;*p;

    return 0;
}   
</code></pre>
",1
909416,909343,0,"<p>bool checkValue(double val);
std::find_if(tplR, tplR + sampleDim[0], checkValue);</p>
",0
1519642,1519635,1,"<p>You have to write a copy constructor.</p>

<p>What's happening is, that MyClass is copied by value
the pointer is shared between the copies.
Now when the objects are destroyed the
pointer is deleted multiplie times.</p>

<p>Like this:</p>

<pre><code>class MyClass 
{
MyClass(int x) : m_x(new SubClass(x)) {}
MyClass(const MyClass&amp; myclass) : m_x(new SubClass(*myclass.m_x)) {}
~MyClass() { delete m_x; }
private :
MySubClass * m_x;
};
</code></pre>

<p>Obviously SubClass needs a copy constructor, too.</p>
",1
1519649,1519635,5,"<p>There's a rule of thumb, called the ""<em>Rule of Three</em>"": Whenever you have either a destructor or an assignment operator or a copy constructor, it is very likely you will need all three of them. Your code is no exception to this rule. </p>

<p>Think of what happens when objects of your type are copied. This </p>

<pre><code>MyClass obj1;
MyClass obj2(obj1);
</code></pre>

<p>code will crash, too. </p>
",0
1519651,1519635,4,"<p><code>MyClass</code> has no copy constructor defined.  However, <code>std::pair</code> will need to make use of the copy constructor for <code>MyClass</code>.  Presumably it is using <code>MyClass</code>'s default copy constructor, which will give copy constructed objects copies of the pointer <code>m_x</code>.  And when they get destroyed, you'll be facing multiple deletions.</p>
",0
1520300,1519635,1,"<p>As everybody mentioned, classes need a working copy constructor in order to be stored in any standard container. However, in this case MySubClass disables copying. This pretty much leaves you two options: </p>

<p>1) MyClass should be non-copyable too, in which case you'll have to store (smart) pointers in the multimap.</p>

<p>2) Copied MyClass instances should share the MySubClass instance. To implement this, the simplest is to replace the pointer member with <code>boost::shared_ptr&lt;MySubClass&gt;</code> or <code>std::tr1::shared_ptr&lt;MySubClass&gt;</code>. Doing so relieves you from the task of implementing a destructor, copy constructor and assignment operator.</p>
",0
1233101,1233042,4,"<p>Do you mean how you would seperate that into header and cpp files?</p>

<p>If so in Player.h you'd do the following:</p>

<pre><code>#ifndef __PLAYER_H_
#define __PLAYER_H_

#include&lt;string&gt;
using namespace std;

class player
{
protected: // could be private
    string name;
    string type;
public:
    void getdata();
    void display();
};

#endif
</code></pre>

<p>in player.cpp:</p>

<pre><code>#include ""stdafx.h""
#include ""Player.h""
#include&lt;iostream&gt;

void player::getdata()
{
    cout&lt;&lt;""Enter the name of the Player : ""&lt;&lt;endl;
    cin&gt;&gt;name;
    cout&lt;&lt;""Enter the Game he play : ""&lt;&lt;endl;
    cin&gt;&gt;type;
}

void player::display()
{
    cout&lt;&lt;""The name of the Player is : ""&lt;&lt;name&lt;&lt;endl;
    cout&lt;&lt;""The game he will play is : ""&lt;&lt;type&lt;&lt;endl;
}
</code></pre>

<p>And then in main.cpp you'd do the following:</p>

<pre><code>#include ""stdafx.h""
#include ""player.h""

int main()
{
    player sachin;
    sachin.getdata();
    sachin.display();
    system(""pause"");
    return(0);
}
</code></pre>

<p>This would be the ideal way to split out everything into seperate header and cpp files :)</p>
",11
1233114,1233042,4,"<p>A typical separation into files in C++ would be as follows:</p>

<pre><code>// myapp.cpp
// ---------

#include ""player.h""
#include &lt;cstdlib&gt;
using std::system;

int main()
{
    player sachin;
    sachin.getdata();
    sachin.display();
    system(""pause"");
    return(0);
}

// player.h
// --------

// or #pragma once, since you're on MS.
#ifndef player_h
#define player_h

#include&lt;string&gt;

class player
{
public:
    std::string name;
    std::string type;
    void getdata();
    void display();
};
#endif

// player.cpp
// ----------

#include ""player.h""
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

void player::display()
{
    cout&lt;&lt;""The name of the Player is : ""&lt;&lt;name&lt;&lt;endl;
    cout&lt;&lt;""The game he will play is : ""&lt;&lt;type&lt;&lt;endl;
}
void player::getdata()
{
    cout&lt;&lt;""Enter the name of the Player : ""&lt;&lt;endl;
    cin&gt;&gt;name;
    cout&lt;&lt;""Enter the Game he play : ""&lt;&lt;endl;
    cin&gt;&gt;type;
}
</code></pre>

<p>There are a few other things that could be tidied up: you might want to put stdafx.h back in, and the strings in player don't need to be public.</p>

<p>Note also that I've not put ""using namespace std"" in the header file. Many people prefer not to do that, at least not at global scope, but if your header does it then that's forced on them if they use your class. It doesn't much matter either way when the files are just for you, but it matters quite a lot in a large project if headers are unexpectedly ""using"" things. It could cause someone problems where they don't realise that all the functions in std are visible, and call one by accident trying to call something else.</p>

<p>I've deliberately used all three options in the three files: <code>using namespace std;</code>, <code>using std::system;</code>, or specifying the namespace every time.</p>
",0
1233174,1233042,1,"<p>If you want to separate your classes you should use create two files; .h &amp; .cpp.</p>

<p>In the header file you place your definitions and declarations, and in the CPP file you implement your methods.</p>

<p>Player.h</p>

<pre><code>#ifndef __PLAYER_H_
#define __PLAYER_H_

#include &lt;string&gt;

class Player
{
public:
    Player();
    ~Player();

    // Methods
    void GetData();
    void Display();

private:
    std::string Name;
    std::string Type;
}

#endif
</code></pre>

<p>Player.cpp</p>

<pre><code>#include ""Player.h""

Player::Player(): Name(""""), 
                  Type("""")
{
}

Player::~Player(){}

void Player::GetData()
{
    std::cout &lt;&lt; ""Enter the name of the Player : "" &lt;&lt; std::endl;
    std::cin &gt;&gt; name;
    std::cout &lt;&lt; ""Enter the Game he play : "" &lt;&lt; std::endl;
    std::cin &gt;&gt; type;
}  

void Player::Display()
{
    std::cout &lt;&lt;""The name of the Player is : "" &lt;&lt; name &lt;&lt; std::endl;
    std::cout &lt;&lt;""The game he will play is : "" &lt;&lt; type &lt;&lt; std::endl;
}
</code></pre>

<p>Edit:</p>

<p>Class member variables should never be public; Write a set method if you have a need to modify a member variable.</p>
",1
1197750,1197566,8,"<p>As <a href=""https://stackoverflow.com/questions/1197566/is-it-ever-not-safe-to-throw-an-exception-in-a-constructor/1197577#1197577"">Spence mentioned</a>, throwing from a constructor (or allowing an exception to escape a constructor) risks leaking resources if the constructor is not written carefully to handle that case.</p>

<p>This is one important reason why using RAII objects (like smart pointers) should be favored - they'll automatically handle the cleanup in the face of exceptions.</p>

<p>If you have resources that require deleting or otherwise manually releasing, you need to make certain that they're cleaned up before the exception leaves.  This is not always as easy as it might sound (and certainly not as easy as letting an RAII object handle it automatically).</p>

<p>And don't forget, if you need to manually handle clean up for something that happens in the constructor's initialization list, you'll need to use the funky 'function-try-block' syntax:</p>

<pre><code>C::C(int ii, double id)
try
     : i(f(ii)), d(id)
{
     //constructor function body
}
catch (...)
{
     //handles exceptions thrown from the ctor-initializer
     //and from the constructor function body
}
</code></pre>

<p>Also, remember that exception safety is the main (only??) reason that the 'swap' idiom gained widespread favor - it's an easy way to ensure that copy constructors don't leak or corrupt objects in the face of exceptions.</p>

<p>So, the bottom line is that using exceptions to handle errors in constructors is fine, but it's not necessarily automatic.</p>
",1
1197811,1197566,5,"<p>When you throw an exception from a constructor a few things will happen.  </p>

<p>1) All fully constructed members will have thir destructors called.<br>
2) The Memory allocated for the object will be released.  </p>

<p>To help make things automatic you should not have RAW pointer in your class, one of the standard smart pointers will usually do the trick and the compiler optimization will reduce most of the overhead to practically nothing [or only the work you should have been doing manually anyway].</p>

<h3>Passing pointers to Functions</h3>

<p>The other thing that I would NOT do; is pass a value to a function as a pointer.<br>
The probelm here is that you are not indicating who owns the object. Without the implicit ownership information it is unclear (like all C functions) who is responcable for cleaning up the pointer.</p>

<pre><code>dostuff(P *p)
{
    // do something with P
}
</code></pre>

<p>You mention that p is stored in a que and used at some later point. This implies that you are passing ownership of the object to the function. So make this relationship explicit by using std::auto_ptr. By doing so the caller of dostuff() knows that he can not use the pointer after calling dostuff() becuase the act of calling the function will have actually transfered the pointer into the function (ie the callers local auto_ptr will contain a NULL pointer after the call to dostuff() ).</p>

<pre><code>void doStuff(std::auto_ptr&lt;P&gt; p)
{
    // do something with p
    //
    // Even if you do nothing with the RAW pointer you have taken the
    // pointer from the caller. If you do not use p then it will be auto
    // deleted.
}


int main()
{
    // This works fine.
    dostuff(std::auto_ptr&lt;P&gt;(new P));


    // This works just as well.
    std::auto_ptr&lt;P&gt;    value(new P);
    dostuff(value);

    // Here you are guranteed that value has a NULL pointer.
    // Because dostuff() took ownership (and physically took)
    // of the pointer so it could manage the lifespan.
}
</code></pre>

<h3>Storing pointers in a cointainer</h3>

<p>You mention that dostuff() is used to store a list of p objects for deferred processing.<br>
So this means you are sticking the objects into a container. Now the normal containers do not support std::auto_ptr. But boost does have support for containers of pointers (where the container takes ownership). Also these contairs understand auto_ptr and will automatically transfer ownership from the auto_ptr to the container.</p>

<pre><code>boost::ptr_list&lt;P&gt;   messages;
void doStuff(std::auto_ptr&lt;P&gt; p)
{
    messages.push_front(p);
}
</code></pre>

<p>Note when you access members of these containers it always returns a reference (not a pointer) to the contained object. This is indicating that the lifespan of the object is tied to the lifespan of the container and the reference is valid as long as the container is valid (unless you explicitly remove the object).</p>
",0
1197937,1197566,3,"<p>The previous answers have been excellent. I just want to add one thing, based on Martin York's and Michael Burr's answers.</p>

<p>Using the example constructor from Michael Burr, I've added an assignment in the constructor body:</p>

<pre><code>C::C(int ii, double id)
try
     : i(f(ii)), d(id)
{
     //constructor function body

     d = sqrt(d);

}
catch (...)
{
     //handles exceptions thrown from the ctor-initializer
     //and from the constructor function body
}
</code></pre>

<p>The question now is, <strong>when is <code>d</code> considered 'fully constructed'</strong>, so that its destructor will be invoked if an exception is thrown within the constructor (as in Martin's post)? The answer is: <strong>after the initializer</strong></p>

<pre><code> : i(f(ii)), d(id)
</code></pre>

<p>The point is your object's fields will <strong>always</strong> have their destructors invoked if an exception is thrown from the constructor <strong>body</strong>.  (This is true whether or not you've actually specified initializers for them.) Conversely, if an exception is thrown from another field's initializer, then destructors <strong>will</strong> be invoked for those fields whose initializers have already run (and <strong>only</strong> for those fields.)</p>

<p>This implies that the best practice is not to allow any field to reach the constructor body with an undestructable value (e.g., an undefined pointer.) That being the case, it's best to actually give your fields their real values through the initializers, rather than (say) first setting the pointers to NULL, and then giving them their 'real' values in the constructor body.</p>
",0
1197577,1197566,0,"<p>If you take a resource in a constructor, such as a socket etc, then this would be leaked if you threw an exception would it not?</p>

<p>But I guess this is the argument for doing no work in a constructor, lazy initializing your connections as you need them.</p>
",9
1197590,1197566,30,"<p>Throwing exceptions from a constructor is a <a href=""http://www.parashift.com/c++-faq-lite/exceptions.html#faq-17.2"" rel=""noreferrer"">good thing</a>. When something fails in a constructor, you have two options:</p>
<ul>
<li>Maintain a &quot;zombie&quot; state, where the class exists but does nothing, or</li>
<li>Throw an exception.</li>
</ul>
<p>And maintaining zombie classes can be quite a hassle, when the real answer should have been, &quot;this failed, now what?&quot;.</p>
<p>According to the Standard at 3.6.2.4:</p>
<blockquote>
<p>If construction or destruction of a non-local static object ends in throwing an uncaught exception, the result is to call terminate (18.6.3.3).</p>
</blockquote>
<p>Where terminate refers to <a href=""http://en.cppreference.com/w/cpp/error/terminate"" rel=""noreferrer""><code>std::terminate</code></a>.</p>
<hr />
<p>Concerning your example, no. This is because you aren't using <a href=""http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization"" rel=""noreferrer"">RAII concepts</a>. When an exception is thrown, the stack will be unwound, which means all objects get their destructor's called as the code gets to the closest corresponding <code>catch</code> clause.</p>
<p>A pointer doesn't have a destructor. Let's make a simple test case:</p>
<pre><code>#include &lt;string&gt;

int main(void)
{
    try
    {
        std::string str = &quot;Blah.&quot;;
        int *pi = new int;

        throw;

        delete pi; // cannot be reached
    }
    catch(...)
    {
    }
}
</code></pre>
<p>Here, <code>str</code> will allocate memory, and copy &quot;Blah.&quot; into it, and <code>pi</code> will be initialized to point to an integer in memory.</p>
<p>When an exception is thrown, stack-unwinding begins. It will first &quot;call&quot; the pointer's destructor (do nothing), then <code>str</code>'s destructor, which will free the memory that was allocated to it.</p>
<p>If you use RAII concepts, you'd use a smart pointer:</p>
<pre><code>#include &lt;memory&gt;
#include &lt;string&gt;

int main(void)
{
    try
    {
        std::string s = &quot;Blah.&quot;;
        std::auto_ptr&lt;int&gt; pi(new int);

        throw;

        // no need to manually delete.
    }
    catch(...)
    {
    }
}
</code></pre>
<p>Here, <code>pi</code>'s destructor will call <code>delete</code> and no memory will be leaked. This is why you should always wrap your pointers, and is the same reason we use <code>std::vector</code> rather than manually allocating, resizing, and freeing pointers. (Cleanliness and Safety)</p>
<h3>Edit</h3>
<p>I forgot to mention. You asked this:</p>
<blockquote>
<p>I think I want to put an autoptr around P and call release on the autoptr after dostuff to prevent a memory leak, would that be correct?</p>
</blockquote>
<p>I didn't state it explicitly, and only implied it above, but the answer is <strong>no</strong>. All you have to do is place it inside of <code>auto_ptr</code> and when the time comes, it will be deleted automatically. Releasing it manually defeats the purpose of placing it in a container in the first place.</p>
<p>I would also suggest you look at more advanced smart pointers, such as those in <a href=""http://www.boost.org/doc/libs/1_39_0/libs/smart_ptr/smart_ptr.htm"" rel=""noreferrer"">boost</a>. An extraordinarily popular one is <a href=""http://www.boost.org/doc/libs/1_39_0/libs/smart_ptr/shared_ptr.htm"" rel=""noreferrer""><code>shared_ptr</code></a>, which is <a href=""http://en.wikipedia.org/wiki/Reference_counting"" rel=""noreferrer"">reference counted</a>, making it suitable for storage in containers and being copied around. (Unlike <code>auto_ptr</code>. Do <em>not</em> use <code>auto_ptr</code> in containers!)</p>
",7
1389418,1312241,2,"<p>However, if you try the ternary operand without ""defining"" static consts, you get a linker error in GCC 4x:</p>

<p><a href=""http://gcc.gnu.org/bugzilla/show_bug.cgi?id=13795"" rel=""nofollow noreferrer"">http://gcc.gnu.org/bugzilla/show_bug.cgi?id=13795</a></p>

<p>So, although constructs like <code>int k = A::CONSTVAL;</code> are illegal in the current standard, they are supported. But the ternary operand is not. Some operators are more equal than others, if you get my drift :)</p>

<p>So much for ""lax"" rules. I suggest you write code conforming to the standard if you do not want surprises.</p>
",0
1312267,1312241,20,"<p>C++ compilers allow static const integers (and integers only) to have their value specified at the location they are declared.  This is because the variable is essentially not needed, and lives only in the code (it is typically compiled out).  </p>

<p>Other variable types (such as static const char*) cannot typically be defined where they are declared, and require a separate definition.</p>

<p>For a tiny bit more explanation, realize that accessing a global variable typically requires making an address reference in the lower-level code.  But your global variable is an integer whose size is this typically around the size of an address, and the compiler realizes it will never change, so why bother adding the pointer abstraction?</p>
",1
1312377,1312241,19,"<p>By really pedantic rules, yes, your code needs a definition for that static integer. 
But by practical rules, and what all compilers implement because that's how the rules of C++03 are intended - no, you don't need a definition. </p>

<p>The rules for such static constant integers are intended to allow you to omit the definition if the integer is used only in such situations where a value is immediately read, and if the static member can be used in constant expressions. </p>

<p>In your return statement, the value of the member is immediately read, so you can omit the definition of the static constant integer member if that's the only use of it. The following situation needs a definition, however:</p>

<pre><code>struct A {
    static const int a = 5;

    struct B {
       static const int b = a;
    };

 };

 int main() {
   int *p = &amp;A::B::b;
 }
</code></pre>

<p>No value is read here - but instead the address of it is taken. Therefore, the intent of the C++03 Standard is that you have to provide a definition for the member like the following in some implementation file. </p>

<pre><code>const int A::B::b;
</code></pre>

<p>Note that the <em>actual</em> rules appearing in the C++03 Standard says that a definition is not required only where the variable is used where a constant expression is <em>required</em>. That rule, however, if strictly applied, is too strict. It would only allow you to omit a definition for situation like array-dimensions - but would require a definition in cases like a return statement. The corresponding defect report is <a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#454"" rel=""noreferrer"">here</a>. </p>

<p>The wording of C++0x has been updated to include that defect report resolution, and to allow your code as written. </p>
",9
1312381,1312241,0,"<p>In general,  most (and recent) C++ compilers allow static const ints</p>

<p>You just lucky, perhaps not. Try older compiler, such as gcc 2.0 and it will vehemently punish you with-less-than-pretty error message.</p>
",0
1331325,1331318,47,"<p>In C and C++, the <code>&amp;&amp;</code> and <code>||</code> operators ""short-circuit"". That means that they only evaluate a parameter if required. If the first parameter to <code>&amp;&amp;</code> is false, or the first to <code>||</code> is true, the rest will not be evaluated.</p>

<p>The code you posted is safe, though I question why you'd include an empty <code>else</code> block.</p>
",4
1331332,1331318,-5,"<p>yes, if( (A) &amp;&amp; (B) ) will fail on the first clause, if (A) evaluates false.</p>

<p>this applies to any language btw, not just C derivatives. For threaded and parallel processing this is a different story ;)</p>
",10
1331333,1331318,12,"<p>You are asking about the <code>&amp;&amp;</code> operator, not the <code>if</code> statement.</p>

<p><code>&amp;&amp;</code> <a href=""http://en.wikipedia.org/wiki/Short-circuit_evaluation"" rel=""noreferrer"">short-circuits</a>, meaning that if while working it meets a condition which results in only one answer, it will stop working and use that answer.</p>

<p>So, <code>0 &amp;&amp; x</code> will execute <code>0</code>, then terminate because there is no way for the expression to evaluate non-zero regardless of what is the second parameter to <code>&amp;&amp;</code>.</p>
",0
1331336,1331318,3,"<p>Yes, it is called <a href=""http://en.wikipedia.org/wiki/Short-circuit_evaluation"" rel=""nofollow noreferrer"">Short-circuit Evaluation</a>.</p>

<p>If the validity of the boolean statement can be assured after part of the statement, the rest is not evaluated.</p>

<p>This is very important when some of the statements have side-effects.</p>
",0
1276349,1276339,2,"<p>Like with any operator, the function name is <code>operator@</code>, so:</p>

<pre><code>a.operator[]&lt;int&gt;(3);
</code></pre>
",0
1276350,1276339,2,"<p>You can use a.operator[]&lt;int&gt;(1);
But why do you want this?</p>
",0
1276358,1276339,6,"<p>This should work:</p>

<pre><code>class C
{
public:
    template &lt;class T&gt;
    T operator[](int n)
    {
        return T();
    }
};

void foo()
{
    C c;

    int x = c.operator[]&lt;int&gt;(0);
}
</code></pre>

<p>But it's of no real value because you'd always have to specify the type, and so it looks like a very ugly function call - the point of an operator overload is to look like an operator invocation.</p>
",4
1276367,1276339,1,"<p>This may not be an optimal solution, but you could directly call the operator as such:</p>

<pre><code>a.operator[](3);</code></pre>

<p>I tried this in g++ with the following test:</p>

<pre><code>class MyClass {
public:
   template&lt;class T&gt;
   T operator[](unsigned int) {
      // do something
      return T();
   }
};

int main(int argc, char* argv[]) {
   MyClass test;
   test.operator[]&lt;int&gt;(0);
   //test&lt;int&gt;[0]; // doesn't compile, as you mentioned
   return 0;
}</code></pre>
",1
1276380,1276339,1,"<p>If you need to define operator[] then probably define the template at the class level. Something like this:</p>

<pre><code>template&lt;class T&gt;
class C
{
public:
    T operator[](int n)
    {
        return T();
    }
};

int  main()
{
    C&lt;int&gt; c;

    int x = c[0];

    return 0;
}
</code></pre>
",1
1276689,1276339,0,"<p>I have a hard time coming up with an example where this would be needed (couldn't you just <em>overload</em> the operator instead?), but here's my thoughts anyway: </p>

<p>Since you cannot use the infix operator syntax with templatized operators, you might want to do the template instantiation <em>before</em> you call the operator. A proxy might be a way to do this. </p>

<pre><code>class some_class {
private:
  template&lt;class T&gt; class proxy {
    some_class* that_;
  public:
    proxy(some_class* that) : that_(that) {}
    T&amp; operator[](std::size_type idx) {return that-&gt;get&lt;T&gt;(idx);}
  };

  template&lt;class T&gt; class const_proxy {
    some_class* that_;
  public:
    proxy(const some_class* that) : that_(that) {}
    const T&amp; operator[](std::size_type idx) const {return that-&gt;get&lt;T&gt;(idx);}
  };

  template&lt; typename T &gt;       proxy&lt;T&gt; get_array()       {return proxy&lt;T&gt;(this);}
  template&lt; typename T &gt; const_proxy&lt;T&gt; get_array() const {return proxy&lt;T&gt;(this);}

  template&lt; typename T &gt;       T&amp; get(std::size_t idx)       {/* whatever */}
  template&lt; typename T &gt; const T&amp; get(std::size_t idx) const {/* whatever */}
};

// This is a lousy use case. 
// Did I already say I have a hard time imagining how to use this? 
template&lt; typename T &gt;
void f(some_class&amp; some_object, sid::size_t idx)
{
   T&amp; = some_object.get_array&lt;T&gt;()[idx];
}
</code></pre>
",0
1277862,1276339,4,"<p><a href=""http://www.boost.org/doc/libs/1_39_0/doc/html/program_options.html"" rel=""nofollow noreferrer"">Boost.Program_options</a> uses this neat syntax:</p>

<pre><code>int&amp; i = a[""option""].as&lt;int&gt;();
</code></pre>

<p>Which is achieved with something like this:</p>

<pre><code>class variable_value 
{
public:
   variable_value(const boost::any&amp; value) : m_value(value) {}

   template&lt;class T&gt;
   const T&amp; as() const {
       return boost::any_cast&lt;const T&amp;&gt;(m_value);
   }

   template&lt;class T&gt;
   T&amp; as() {
       return boost::any_cast&lt;T&amp;&gt;(m_value);
   }

private:
    boost::any m_value;
};

class variables_map 
{
public:
    const variable_value&amp; operator[](const std::string&amp; name) const
    {
        return m_variables[name];
    }

    variable_value&amp; operator[](const std::string&amp; name)
    {
        return m_variables[name];
    }

private:
    std::map&lt;std::string, variable_value&gt; m_variables;
};
</code></pre>

<p>You could adapt this idea to suit your own needs.</p>
",0
1322345,1322307,1,"<p>you can either use mutex or try to open the shared memory file and handle the exception.</p>
",2
1322363,1322307,2,"<p>The managed_shared_memory ctor will throw an interprocess_exception in case it fails to open the given shared memory (assuming you passed open_only to the ctor). You could use the error code in the exception to test whether the shared memory is available or not.</p>

<p>All means to check whether a process is running (by looking at the process tree, testing for magic log files or whatever) suffer from a race condition which occurs if the remote process is running, but it didn't yet manage to setup the shared memory.</p>

<p><b>Update:</b> If you <em>only</em> want to check whether a process is being executed by the operating system, then you need to walk the list of processes and consider each one. <a href=""http://msdn.microsoft.com/en-us/library/ms686701%28VS.85%29.aspx"" rel=""nofollow noreferrer"">Here</a> you can find an example how to do that.</p>

<p>A much easier, more portable, but less precise technique is to use lock files. Process A creates a magic 'lock file' in some location on startup, and deletes it as it terminates. Process B can then test for the existence of this file to determine whether Process A is running. A null-byte size file would be sufficient for this, but the file could also contain additional information which is helpful to Process B (such as the PID of Process A). However, there's a short time window at the very beginning of Process A at which no lock file exists - yet the process is running.</p>
",1
1273163,1273148,15,"<p>For the types you use, there will probably be no difference in performance. However for non-POD data (classes with constructors) the form:</p>

<pre><code>Test(int &amp;vara, char *&amp; varb) : a(vara), b(varb){}
</code></pre>

<p>will be the most efficient. This is because non-POD data will be initialised whther you provide an initialisation list or not. The other forms, which use assignment, will take the hit for initialisation, and then another hit for assignment.</p>
",3
1273165,1273148,1,"<p>method 3 is usually used if you have something like</p>

<pre><code>Test (int &amp;a, char &amp;b) 
{
    this-&gt;a = a;
    this-&gt;b = b;
}
</code></pre>

<p>in order to fully qualify that you're setting the class field a and b, it's basically the same as method 2.</p>
",0
1273166,1273148,4,"<p>Probably not a HUGE difference in terms of performance, but in method 1, you're constructing a and b using a copy constructor. In method 2, you're constructing a and b automatically, THEN using the assignment operator. That <em>could</em> be slower for more complex types than int and char*.</p>

<p>Method 3 is exactly the same thing as method 2.</p>
",0
1273175,1273148,3,"<p>The first way, called ""initialization lists"", is the best. It is required for reference attributes, and for standard attributes is more efficient.</p>

<p>The second way will invoke the standard constructors for all attributes, and then use the assignment operator on each assigned attribute. It is slower, and potentially will break entirely if an attribute type does not support assignment.</p>

<p>The third way is exactly the same as the second, but needlessly verbose. Prefixing attribute access with <code>this-&gt;</code> is poor style unless there is a local variable shadowing an attribute.</p>

<hr>

<p>Unrelated to the question, there's no need to use references for basic types. You're adding additional overhead for pointer dereferences, and since the values are being assigned to non-references <em>anyway</em>, there's no point to it.</p>
",2
1273179,1273148,3,"<p>There is absolutely no difference between Methods 2 and 3. Within a member function (including constructors and destructors) a member variable <code>x</code> is synonymous with <code>this-&gt;x</code>. The only time this makes a difference is if there is another variable named <code>x</code> in a nearer scope. For example:</p>

<pre><code>int Foo::memberFunc() {
  return x; // Returns member variable x. Same as return this-&gt;x.
}

int Foo::memberFunc(int x) {
  return x; // Returns the argument x. Need to say return this-&gt;x to return member x
}
</code></pre>

<p>Method 1 is normally the preferred way of initializing member variables because it makes it explicit that that is what you are doing. </p>

<p>In your case, it is also identical to methods 2 and 3, but in some cases it is not. In particular, if any of your member variables are constants, references, or objects without default constructors, then Method1 is the <em>only</em> way you can initialize them. </p>

<p>Another small difference of Method 1 is that if any of your member variables are objects, using Methods 2 or 3 they will be constructed with their default constructors first and then modified or assigned to int he constructor code, while with Method 1 you can create them with a constructor other than the default in the first place.</p>
",2
1273388,1273148,2,"<p>The first method (using initializer list) is the preferred way to initialize member variables of a C++ class. Its advantage is that it lets you choose which constructor to use for each member. The problem with the second method is that the default constrictors of the member fields will already be called before the body of the constructor is entered. This is also the only method of invoking a base class constructor, when the base class does not has a default constructor. The other two constructors are same, method 3 being the least preferred from a stylistic perspective. </p>
",0
1274084,1273148,1,"<p>They don't do the same thing.</p>

<p>Method 1 initializes the class members with the specified values.</p>

<p>Methods 2 and 3 first default-initializes the members (which for non-POD types means calling the default constructor), and <em>then</em> calls the assignment operator to assign a new value to them.</p>

<p>In other words, 2 and 3 will fail to compile if the class contains references, or if one of the members do not have a default constructor. It will also be slower for most non-POD types.</p>

<p>In other words, use the initializer list (method 1). That's what it's for. It is better from a correctness <em>as well as</em> a performance point of view.</p>
",0
1586912,1586907,4,"<p>std::stream doesn't set eof() until a read fails, so one fix is:</p>

<pre><code>while (file &gt;&gt; i, !file.eof()) cout &lt;&lt; i &lt;&lt; "" "";
</code></pre>
",2
1586952,1586907,6,"<p>Try:</p>

<pre><code>while(file &gt;&gt; i)
    cout &lt;&lt; i &lt;&lt; "" "";
</code></pre>
",0
958871,958865,5,"<p>What you may want to do is use the member initialisation syntax:</p>

<pre><code>class TakesObject {
public:
  TakesObject(ObjectWithState obj): obj_(obj) {
  }
private:
  ObjectWithState obj_;
};
</code></pre>

<p>In your posted code, the <code>TakesObject</code> constructor will first try to construct a new <code>ObjectWithState</code> with its <em>default</em> constructor, <em>then</em> call the assignment operator to copy the passed-in <code>obj</code> to <code>obj_</code>. The above example constructs the <code>obj_</code> directly using its copy constructor.</p>

<p>You will also need to define a copy constructor for your <code>ObjectWithState</code> class, too:</p>

<pre><code>class ObjectWithState {
public:
  ObjectWithState(int state) {
    state_ = state;
  }
  ObjectWithState(const ObjectWithState &amp;rhs) {
    state_ = rhs.state_;
  }
private:
  int state_;
};
</code></pre>

<p>If you omit all constructors from your class declaration, then the compiler supplies a default and a copy constructor for you. If you declare <em>any</em> constructors, then the compiler supplies <em>no</em> default or copy constructor, so you must implement your own.</p>
",4
958876,958865,1,"<p>You're getting this error because you're declaring a constructor. The compiler will provide the default constructor only if you don't declare a constructor in your class. Because you have declared a constructor, you don't get the default one. You have to explicitly declare a constructor with no parameters.</p>
",2
1408833,1408823,2,"<p>Just traverse the stream one element at a time and extract it.</p>

<pre><code>char ch;
while( new_num.get(ch) ) {
    std::cout &lt;&lt; ch;
}
</code></pre>
",0
1408834,1408823,11,"<p>Without using strings, you can work backwards. To get the 6, </p>

<ol>
<li>It's simply <code>306 % 10</code></li>
<li>Then divide by 10</li>
<li>Go back to 1 to get the next digit.</li>
</ol>

<p>This will print each digit backwards:</p>

<pre><code>while (num &gt; 0) {
    cout &lt;&lt; (num % 10) &lt;&lt; endl;
    num /= 10;
}
</code></pre>
",0
1408939,1408823,1,"<p>Charles's way is much straight forward. However, it is not uncommon to convert the number to string and do some string processing if we don't want struggle with the math:)</p>

<p>Here is the procedural we want to do :</p>

<pre><code>306 -&gt; ""306"" -&gt; ['3' ,'0', '6'] -&gt; [3,0,6]
</code></pre>

<p>Some language are very easy to do this (Ruby):</p>

<pre><code> &gt;&gt; 306.to_s.split("""").map {|c| c.to_i}
 =&gt; [3,0,6]
</code></pre>

<p>Some need more work but still very clear (C++) :</p>

<pre><code>    #include &lt;sstream&gt;
    #include &lt;iostream&gt;
    #include &lt;algorithm&gt;
    #include &lt;vector&gt;

  int to_digital(int c)
  {
   return c - '0';
  }

  void test_string_stream()
  {
     int a = 306;
     stringstream ss;
     ss &lt;&lt; a;
     string   s = ss.str();
     vector&lt;int&gt; digitals(s.size());
     transform(s.begin(),s.end(),digitals.begin(),to_digital);


  }
</code></pre>
",1
1408991,1408823,0,"<p>Loop string and collect values like </p>

<pre><code>int val = new_num[i]-'0';
</code></pre>
",0
1581791,1581763,0,"<p>The lexer will have to scan two characters less in the first version, so the compilation process is a little faster ;)</p>
",0
1581858,1581763,39,"<p>If <code>A</code> is a POD-type, then <code>new A</code> will allocate a new <code>A</code> object but leave it with an indeterminate value, otherwise <code>new A</code> will <em>default initialize</em> the new object.</p>

<p>In all cases <code>new A()</code> will <em>value initialize</em> the new <code>A</code> object.</p>

<p>This is obviously different behaviour for POD types but also affects non-POD, non-union class types without a used-declared constructor.</p>

<p>E.g.</p>

<pre><code>struct A
{
    int a;
    std::string s;
};
</code></pre>

<p><code>A</code> is a non-POD class type without a user-declared constructor. When an <code>A</code> is <em>default initialized</em> the implicitly defined constructor is called which calls the default constructor for <code>s</code> (a non-POD type), but <code>a</code> is not initialized.</p>

<p>When an <code>A</code> is <em>value initialized</em>, as it has no used-declared constructor, all of its members are <em>value initialized</em> which means that the default constructor for <code>s</code> is called and <code>a</code> is <em>zero initialized</em>.</p>

<p>ISO 14882:2003 references:</p>

<ul>
<li><p>5.3.4 [expr.new]/15: How objects allocated by a <code>new</code> expression are initialized depending on whether the initializer is omitted, a pair of parentheses or otherwise.</p></li>
<li><p>8.5 [dcl.init]/5: The meaning of <em>zero initialize</em>, <em>default initialize</em> and <em>value initialize</em>.</p></li>
<li><p>12.1 [class.ctor]/7,8: The form of a user-written constructor that matches the behaviour of an implicitly defined default constructor.</p></li>
<li><p>12.6.2 [class.base.init]/4: How bases and members which are not listed in a member initializer list of a constructor are initialized.</p></li>
</ul>
",3
1581907,1581763,-1,"<p>please see STL implementing code (e.g. allocator) then you'll understand.</p>
",0
1581767,1581763,0,"<p>It's exactly the same, also performance wise :)</p>
",1
1149940,1149856,1,"<p>You might want to take a look at <a href=""http://www.crystalspace3d.org/"" rel=""nofollow noreferrer"">http://www.crystalspace3d.org/</a> - I have to admit it was more of an exploratory matter for me, but it seemed like a pretty nice engine - with physics and scripting included. They have an project which shows the avatar walking in the spacestation-like building with very smooth camera effects.</p>

<p>OTOH: depending on how far you want to push this, you might find yourself recreating the SecondLife(tm)-like kind of environment. If that's a fair assumption, then you might take a look at OpenSimulator and the associated opensource viewer projects and see if this may be of interest to you - and work there with the existing team to develop the code further, rather than working on your own.</p>
",0
1149952,1149856,2,"<p>No engine is likely to do this for you. What they do is generally allow you to load and render 3d models. But combining them, the way you'd need to do to ""dress them"" is up to you. And creating them, or letting the user do so, is ultimately up to you. The engine might offer a number of tools to make the task easier (for example, rendering the model while the user is designing it), but a game engine is not a magic ""make a game"" box where you just have to press a button, and your custom game comes out.</p>
",0
1150277,1149856,1,"<p>If you good with C++, I suggest the <a href=""http://www.terathon.com/c4engine/index.php"" rel=""nofollow noreferrer"">C4 Engine</a>. From my experiences, existing game engines are either too rigid or just nothing more than a collection of libraries. </p>
",1
1150286,1149856,6,"<p>If you are good with C++ you should use Ogre, it's the best open-source engine, continuously been updated by it's creators, with a lot of tutorials and a very helpful community.</p>

<p><a href=""http://www.ogre3d.org/"" rel=""nofollow noreferrer"">http://www.ogre3d.org/</a></p>

<p>It's more of a GFX engine, but it has all the prerequisites you desire.</p>

<p>Good luck!</p>
",2
1150853,1149856,15,"<p>I also recommend Ogre. Ogre can do this, it provides everything needed in regards of mesh and animation support, but not as a drop-in solution. You have to write lots of code for this to be done.</p>

<p>For our project we implemented something like you do. The main character and any other character can be dressed with different weapons and armor and the visuals of the character avatar change accordingly.</p>

<p>As a start hint for how to go about this: In your modeling tool (Blender, Maya, 3ds max, etc.) you model your avatar and all its clothes you need and rig them to the same skeleton. Then export everything individually to Ogre's mesh format.</p>

<p>At runtime you can then attach the clothing meshes the user chooses to the skeleton instance so that they together form the avatar. This is not hard to do via Ogre-API, but for even easier access to this you can use <a href=""http://www.ogre3d.org/wiki/index.php/MeshMagick"" rel=""noreferrer"">MeshMagick</a> Ogre extension's meshmerge tool. It has been developed for exactly this purpose.</p>

<p>If you want to change other characteristics like facial features, this is possible too, as Ogre supports vertex pose animations out of the box, so you can prepare pathes for certain characteristics of the face and let the user change the face by sliders or somthing like this. (e.g like in Oblivion)</p>

<p>One thing to be aware regarding Ogre: It is a 3d graphics engine, not a game engine. So you can draw stuff to the screen with it and animate and light and in any way change the visuals, but it doesn't do input or physics or sound. For this you have to use other libs and integrate them. Several pre-bundled game engines based on Ogre are available though.</p>
",0
1150905,1149856,1,"<p>Ogre is a good way to go if you are just interested in getting something to show. As some have already stated here, Ogre is a rendering engine. There are lots of add-ons and functions to complete common tasks like Audio, Input and whatnot. This is perfectly fine if your just aiming at playing around or creating a prototype.</p>

<p>Should you want to start a long-term project that will be developed over a longer period of time (which would be pretty likely considering you probably being the only developer and games being complex applications), you should really start thinking about what it is that you want to do. Then, based on you're goals, look for several engines that can tackle your needs (there's always some API to accomplish XYZ). Then it's up to you how you manage your game and where you use existing libraries - you'd basically tie up your own engine according to your needs.</p>

<p>It get's a bit more difficult if you start looking for a real game engine in terms of ""engine for all my game-dev needs"". Check out the nice list of 3d game engines at devmasters (<a href=""http://www.devmaster.net/engines/"" rel=""nofollow noreferrer"">http://www.devmaster.net/engines/</a>), you'll find lots of alpha status game engines trying to accomplish this, although you should keep in mind that support and documentation usually isn't first class in those cases.</p>

<p>I personally never used it, but I evaluated the open source engine Delta3D (delta3d.org) for my project and was impressed by it's cool architecture. It encapsulates a whole bunch of other quality open source frameworks for stuff like graphics (OpenSceneGraph: openscenegraph.org) or physics (ODE: ode.org). That's probably as close as you'll get to a free and flexible game engine as far as I know. It was developed at an air force university, and due to it's academic background comes with lots of detailed documentation.</p>
",0
1150913,1149856,2,"<p>A couple of people have said <a href=""http://www.ogre3d.org/"" rel=""nofollow noreferrer"">Ogre3D</a>, I'll offer up <a href=""http://irrlicht.sourceforge.net/"" rel=""nofollow noreferrer"">Irrlicht</a> as an alternative.</p>
",0
1415524,1311242,5,"<p>I am still unable to find a library that supplies the necessary code, but I did find some code that does work:</p>

<p><a href=""http://svn.python.org/view/python/branches/py3k/Python/dtoa.c?view=markup"" rel=""noreferrer"">http://svn.python.org/view/python/branches/py3k/Python/dtoa.c?view=markup</a></p>

<p>By supplying a fairly small number of defines it's easy to abstract away the Python integration. This code does indeed meet all the properties I outline.</p>
",0
1311352,1311242,0,"<p>As stated by others. Floating-point numbers are not that accurate its an artifact on how they store the value.</p>

<p>What you are really looking for is a Decimal number representation.
Basically this uses an integer to store the number and has a specific accuracy after the decimal point.</p>

<p>A quick Google got this:
<a href=""http://www.codeproject.com/KB/mcpp/decimalclass.aspx"" rel=""nofollow noreferrer"">http://www.codeproject.com/KB/mcpp/decimalclass.aspx</a></p>
",4
1311293,1311242,0,"<p>Actually I think you'll find that 1.34 IS 1.3400000000000001.  Floating point numbers are not precise.  You can't get around this.  1.34f is 1.34000000333786011 for example.</p>
",1
1239603,1239557,2,"<p>What you need is a <a href=""http://msdn.microsoft.com/en-us/library/kf18ek11(VS.80).aspx"" rel=""nofollow noreferrer"">map</a>.</p>

<pre><code>std::map&lt;char, std::vector&lt;YourElementClass&gt; &gt; 
</code></pre>
",6
1239618,1239557,1,"<p>I think an <code>std::map&lt;char*, std::set&lt;Type&gt; &gt;</code> would satisfy your needs (where Type is whatever you want to store in your sets).</p>

<p>On a side note, it's generally a bad idea to implement your own version of STL containers.</p>
",0
1239814,1239557,1,"<p>You can use a vector of vectors in this case since your range of keys is limited:</p>

<pre><code>vector&lt;vector&lt;MyType&gt; &gt; container(128);
</code></pre>

<p>Now you can access the proper container by using the entered character as the key:</p>

<pre><code>MyType myTypeInstance;
char input = 'a';
container[input].push_back(myTypeInstance);
</code></pre>

<p>This should be faster than using a <a href=""http://www.sgi.com/tech/stl/Map.html"" rel=""nofollow noreferrer"">std::map</a> (i.e. <code>map&lt;char, MyType&gt;</code>), but requires allocation of every possible container up front. It also waste space with the non-printable characters in the range 0 to 31. The latter issue could be addressed by only allocate 96 values and subtracting 32 from the user input.</p>

<p>Also, depending on the complexity of the type in your inner container, it may be preferable to store pointers (or a smart pointer like <a href=""http://www.boost.org/doc/libs/1_39_0/libs/smart_ptr/shared_ptr.htm"" rel=""nofollow noreferrer"">boost::shared_ptr</a>) instead of storing by value.</p>

<pre><code>vector&lt;vector&lt;shared_ptr&lt;MyType&gt; &gt; &gt; container(96);
</code></pre>

<p>Note that if you do use raw pointers you must be sure to delete items as they are not reclaimed by the vector.</p>
",0
1127766,1127738,46,"<p>You need to instantiate an object in order to call its member functions. The member functions need an object to operate on; they can't just be used on their own. The <code>main()</code> function could, for example, look like this:</p>

<pre><code>int main()
{
   Name_pairs np;
   cout &lt;&lt; ""Enter names and ages. Use 0 to cancel.\n"";
   while(np.test())
   {
      np.read_names();
      np.read_ages();
   }
   np.print();
   keep_window_open();
}
</code></pre>
",0
1127772,1127738,37,"<p>If you want to call them like that, you should declare them static.</p>
",2
1127784,1127738,2,"<p>You are right - you declared a new use defined type (Name_pairs) and you need variable of that type to use it.</p>

<p>The code should go like this:</p>

<pre><code>Name_pairs np;
np.read_names()
</code></pre>
",0
1504220,1504205,30,"<p><code>main</code> is just <code>main</code> simply! a function:</p>

<pre><code>class EntranceClass
{
...
}; //&lt;-- note the semicolon

int main()
{

}
</code></pre>
",1
1504224,1504205,1,"<p>You are looking for <code>Constructor</code> of object?:)</p>

<p>Anyway try remove <code>static</code> ... </p>
",0
1504238,1504205,7,"<p>Have you maybe forgotten the semicolon after the closing paranthesis?</p>
",0
1504252,1504205,11,"<p>The error is referring to the use of <code>static</code> keyword before class definition - compiler expects a variable name after that (as in C++ there is no such thing as <code>static class</code>).</p>

<p>And if you want to use <code>static int EntranceMain::main(void)</code> as your program's entry point, then one way to do it is to tell that to your linker, i.e. give it a full, decorated name of that function. This is highly dependent on which compiler and linker you use, so you need to refer to their documentation. But using that will probably mean you need to include the startup code (e.g. CRT initialisation).</p>

<p>Note that this is not so standard-compliant, though.</p>
",5
1504351,1504205,1,"<p>This seems like horrible coding style to me to be putting your main into a class, but if you really wanted to do it I think the implementation would be more like so:</p>

<pre><code>class Foo{
public:
     int main(){ return 0; };
};

Foo bar;

int Foo::main(){
bar.main();
}
</code></pre>

<p>As I said though, this seems to be very bad coding style. You're better off building your class in a .hpp file then linking it into your program_main.cpp (via #include ""foo.hpp"") which has the int main(){ return 0; } function for you to call the class.</p>
",1
1504477,1504205,1,"<ul>
<li><p>In C++ you can have ""global"" functions, i. e. functions that are not members (""methods"" in Java lingo) of any class.</p></li>
<li><p>By default the entry point to a C++ program is a ""global"" <code>main()</code> function that in general looks like this:</p></li>
</ul>

<pre><code>
int main(int argc, char *argv[])
{
  // do stuff
}
</code></pre>

<p>The arguments to <code>main()</code> allow your program to take command line arguments.  They can be omitted like so
<pre><code>
int main()
{
 // do stuff
}
</pre></code></p>

<p>in which case your program does not take any arguments.  When a program exits normally, the convention is for <code>main()</code> to return 0.  A return value other than 0 is typically used to indicate an error.</p>

<ul>
<li><p>There is no notion of a static class in C++.  You can have static member functions and data members, or static global variables (different meaning of static inherited from C).</p></li>
<li><p>You need a semicolon after the class definition.</p></li>
</ul>
",1
1504541,1504205,9,"<p>According to the standard, you're not writing a true <code>main</code> function.</p>

<p>Section 3.6.1, paragraph 3:  ""The function <code>main</code> shall not be used (3.2) within a program.  The linkage (3.5) of <code>main</code> is implementation-defined.  A program that declares <code>main</code> to be <code>inline</code> or <code>static</code> is ill-formed.  The name <code>main</code> is not otherwise reserved.  [<em>Example:</em>  member function, classes, and enumerations can be called <code>main</code>, as can entities in other namespaces.]""</p>

<p>This means that, by declaring a member function <code>main</code>, you're just declaring a member function.  It has no special significance, and doesn't mean anything in the class can be called independently.  The program would mean entirely the same thing if you substituted <code>snicklefrazz</code> for that function name and all references.</p>

<p>Stylistically, <code>snicklefrazz</code> would be better, since it wouldn't lead to any possible conclusion with the standard <code>main</code> function.</p>

<p>Section 3.6.1, paragraph 1:  ""A program shall contain a global function called <code>main</code>, which is the designated start of the program.  It is implementation-defined whether a program in a freestanding environment is required to define a <code>main</code> function.""</p>

<p>This means that, unless you're writing in what the standard calls a freestanding environment (typically used in writing embedded systems), you need to define a <code>main</code> global function, and this is where the program starts.</p>

<p>In Java, a class can have a <code>main</code> method, which is where the program begins when the class is invoked.  This is not the case in C++, and there is no way to accomplish this directly.</p>

<p>(And, as others have mentioned, a <code>class</code> cannot be <code>static</code>, and a class definition ends with a semicolon.)</p>
",1
1506490,1504205,-1,"<p>One trick you can do is to create a class that is called something like ""BaseApp"" that is derived from, and then implement a virtual function that calls through to the real version.</p>

<pre><code>class BaseApp
{
public:
   virtual void   EntryPoint() = 0;
   static  BaseApp* GetApp() { return this; }
};
</code></pre>

<p>Then just derive a class from it, implement an EntryPoint(), and define your object.</p>

<pre><code>class SpecializedApp: public BaseApp
{
public:
   void EntryPoint() { ... }
};

SpecializedApp g_App;
</code></pre>

<p>Then, you have main() that calls through to it:</p>

<pre><code>void main()
{
   BaseApp::GetApp()-&gt;EntryPoint();
}
</code></pre>

<p>This is a way that you can have main be a type of generic startup routine that can call into different entry points depending on how things are linked in.  You could have a Win32 class or a standard C class on top of BaseApp.</p>
",1
1147997,1147995,6,"<p>yes, it is very common to return an enum type. </p>

<p>You will want to put your enum outside of the class though since the function wants to use it.  Or scope the function's enum return type with the class name (enum must be in a public part of the class definition). </p>

<pre><code>class myclass
{
public:
  enum myenum{ a, b, c, d};

  //....

  myenum function();

  //....
};

myClass::myenum function()
{
  //....
}
</code></pre>
",0
1147999,1147995,1,"<p>yes, definitely.</p>
",0
1148006,1147995,2,"<p>Just make sure the enum is in the <code>public</code> section of your class:</p>

<pre><code>class myclass
{
    public:
    enum myenum{POSITIVE, ZERO, NEGATIVE};
    myenum function(int n)
    {
        if (n &gt; 0) return POSITIVE;
        else if (n == 0) return ZERO;
        else return NEGATIVE;
    }
};

bool test(int n)
{
    myclass C;
    if (C.function(n) == myclass::POSITIVE)
        return true;
    else
        return n == -5;
}
</code></pre>
",0
1391658,1391641,0,"<p>What happens if you try dumping the content into an actual text file with something like </p>

<pre><code>cat /proc/cpuinfo &gt; cpuinfo.txt
</code></pre>

<p>and then reading that file ?</p>
",0
1391701,1391641,5,"<pre><code>for (int nRead = ::read(cpuFD, buf, bufSize); nRead != 0;) {
</code></pre>

<p>is wrong. You're using read as an initializer, so read is only being called once, <em>not</em> once per loop. After that, you're just looping forever printing it out (because nothing is changing nRead).</p>
",0
1619434,1619392,0,"<p>These are many different questions. My first suggestions would be to look for online source code for similar games. If you need help with the code please post it along with the question. </p>
",0
1619443,1619392,0,"<p>You will most likely need to have a bunch of ifs and loops going something like this:</p>

<pre><code>while(1){
  initYourLevel();
  while(levelNotOver){
    //do things
  }
}
</code></pre>

<p>Then it all depends what you're trying to do and your question is kind of blurry to me. Start looking at <a href=""http://www.gamedev.net/reference/start_here/"" rel=""nofollow noreferrer"">tutorials</a> to wrap your head around how people are doing things. There is a lot of sample code out there!</p>

<p>Hope that helps</p>
",0
1619473,1619392,5,"<p>Most gaming frameworks provide two methods you need to implement (both  of them are called in a loop):</p>

<ul>
<li>Update</li>
<li>Draw</li>
</ul>

<p>The <code>Update</code> is where you should put all that stuff, which should check for User input, state changes, intervalled actions etc. Examples would be Physics, ButtonPressed, etc. Nothing prevents you from working with events here (have a look at <a href=""http://www.boost.org/doc/libs/1_35_0/doc/html/signals/tutorial.html"" rel=""nofollow noreferrer"">BoostLibrary Signals</a>).</p>

<pre><code>void Game::update() {
   if(pushedButton) {
       this-&gt;cardsOnTable-&gt;add(this-&gt;hand-&gt;remove(0));
       this-&gt;activePlayer = nextPlayer();
   }
}
</code></pre>

<p>The <code>Draw</code> should just render the current, underlying state to the screen. So you have to make sure your underlying state/model is easy to access.</p>

<pre><code>void Game::render() {
  this-&gt;table-&gt;render();
  this-&gt;cardsOnTable-&gt;render();
  this-&gt;hand-&gt;render();
  // ...
  flipBuffers();
}
</code></pre>

<p>You can solve your Menu/SettingsMenu issue with <code>Scenes</code> and a <code>SceneManager</code> (which can be a Stack). So instead of putting the logic into the <code>Game</code> directly, you put it into <code>Scenes</code>. And you can push/pop scenes to/from the Manager. </p>

<pre><code>void Game::update() {
  this-&gt;sceneManager-&gt;activeScene-&gt;update();
}

void MenuScene::update() {
  if(settingsMenuItemSelected) {
    game-&gt;sceneManager-&gt;push(new SettingsMenuScene));
    // now the next time Game::update() is called
    // the active scene of the SceneManager will be
    // the settings menu. And once it is closed/cancelled
    // it will pop itself from the manager and we are back
    // in the regular menu
  }
}
</code></pre>

<p>If you want to start with more advanced stuff, you could try to store ""events"" into a huge list and fire all events when you enter the <code>Game::update</code> method - this is how VB makes sure that you can't modify controls from another thread than the UI thread - but I don't think that this is something you would do using C++.</p>
",0
1619476,1619392,2,"<p>In general you might want to look into a book about programming idioms and design patterns, which are already discussed in other questions here. Even if not directly related to games, they will help you.</p>

<p>Game-Engines are a nice example of state machines (state in-game, state in-settings and sub-states) - you can do it all with conditional branching etc., but to not lose your head if it gets bigger you need to abstract.<br>
There are different approaches to implementing state machines in c++, based on polymorphous classes (consult your favourite c++ pattern book), template-based (<a href=""http://www.boost.org/doc/libs/1_40_0/libs/statechart/doc/index.html"" rel=""nofollow noreferrer"">boost.statechart</a>), ...<br>
Whats common is, when using a central loop you forward events to some handler (representing states or substates) which will do what fits in the current situation. Need to change behaviour (e.g. from game to options)? Switch out the handlers.</p>

<p>You'll also want to wrap and abstract the current game-state - there is no need for explicit handling of e.g. cards in every place. Wrap things up in e.g. a card- or a player-manager which internally handles it.<br>
Also utilize the containers and algorithms C++ gives you for free, you could e.g. manage the cards or players in <code>std::map</code>s or <code>std::set</code>s. When you hit the limits of the standard library check out boost.</p>
",0
1574568,1574512,4,"<p>Why not to use two constructors?</p>

<pre><code>// constructor with one argument
ViewA(AbstractPresenter&lt;ModelA&gt; *presenter) : AbstractView&lt;ModelA&gt; (presenter)
{
}

// constructor without arguments
ViewA() : AbstractView&lt;ModelA&gt;(factory.GetFor&lt;ModelA&gt;(this))
{
}
</code></pre>

<p>By the way, <code>this</code> pointer is valid only within nonstatic member functions. It should not be used in the initializer list for a base class. The base-class constructors and class member constructors are called before this constructor. In effect, you've passed a pointer to an unconstructed object to another constructor. If those other constructors access any members or call member functions on this, the result will be undefined. You should not use the this pointer until all construction has completed. </p>
",2
1202906,1202883,6,"<p>Look at <a href=""http://www.cplusplus.com/reference/string/string/find_first_of/"" rel=""nofollow noreferrer"" title=""std::string::find_first_of"">std::string::find_first_of</a>. This allows you to easily ask a std::string object for the position of the next of any characters in another string object.</p>

<p>For example:</p>

<pre><code>string foo = ""This is foo"";
cout &lt;&lt; foo.find_first_of(""aeiou""); // outputs 2, the index of the 'i' in 'This'
cout &lt;&lt; foo.find_first_of(""aeiou"", 3); // outputs 5, the index of the 'i' in 'is'
</code></pre>

<p>Edit: whoops, wrong link</p>
",3
1204640,1202883,0,"<p>You can use <b>strtok</b> for this purpose. It is already implemented in STL libraries.</p>

<pre>
#include 
#include 

int main ()
{
  char str[] =""- This, a sample string."";
  char * pch;
  printf (""Splitting string \""%s\"" into tokens:\n"",str);
  pch = strtok (str,"" ,.-"");
  while (pch != NULL)
  {
    printf (""%s\n"",pch);
    pch = strtok (NULL, "" ,.-"");
  }
  return 0;
} 
</pre>
",0
1195679,1195656,5,"<p>Integers (and all other data) are not stored using ""binary notation"", they are stored as binary numbers. And no, there is no way for integers to retain their input format (which is what you are actually asking).</p>
",4
1784060,1783849,0,"<p>Not mentionned yet: virtual functions are instantiated for each include, so you can bloat your executable (I'm not sure whether this is true for all compilers).</p>

<p>There is an alternative:<br>
Do a lot of stuff in classes declared in your source-file.  1 example is the pimpl-idiom, but there are also people who are afraid to declare classes out of the header-file.  However, this makes sense for private classes.</p>
",2
1783890,1783849,17,"<p>Well - one problem is that typically implementations change much more often than class definitions - so for a large project you end up having to recompile the world for every small change.</p>
",6
1783905,1783849,24,"<p>Possible advantages of putting everything in header files:</p>

<ul>
<li>Less redundancy (which leads to easier changes, easier refactoring, etc.)</li>
<li>May give compiler/linker better opportunities for optimization</li>
<li>Often easier to incorporate into an existing project</li>
</ul>

<p>Possible disadvantages of putting everything in header files:</p>

<ul>
<li>Longer compile/link cycles</li>
<li>Loss of separation of interface and implementation</li>
<li>Could lead to hard-to-resolve circular dependencies</li>
<li>Lots of inlining could increase executable size</li>
<li>Prevents binary compatibility of shared libraries/DLLs</li>
<li>Upsets co-workers who prefer the traditional ways of using C++</li>
</ul>
",2
1783942,1783849,6,"<p>The main reason not to implement a class in the header file is: do the consumers of your class need to know its implementation details?  The answer is almost always no.  They just want to know what interface they can use to interact with the class.  Having the class implementation visible in the header makes it much more difficult to understand what this interface is.</p>

<p>Beyond considerations of compactness and separating interface from implementation, there are also commercial motivations.  If you develop a library to sell, you (probably) do not want to give away the implementation details of the library you are selling.</p>
",0
1784229,1783849,6,"<p>You're not repeating yourself. You only write the code <em>once</em> in <em>one</em> header. It is repeated by the preprocessor, but that's not your problem, and it's not a violation of DRY.</p>

<blockquote>
  <p>If it's right to do for templates, why not for normal classes</p>
</blockquote>

<p>It's not really that it's the <em>right</em> thing to do for templates. It's just the only one that really works in general.</p>

<p>Anyway, if you implement a class in a header, you get the following advantages and disadvantages:</p>

<ul>
<li>The full implementation is visible anywhere it is used, which makes it easy for the compiler to inline as necessary. </li>
<li>The same code will be parsed and compiled multiple times, leading to higher compile-times.</li>
<li>On the other hand, if everything is in headers, that may lead to fewer translation units, and so the compiler has to run fewer times. Ultimately, you might end up with a single translation unit, which just includes everything once, which can result in very fast compilations.</li>
</ul>

<p>And... that's it, really.</p>

<p>Most of my code tends to be in headers, but that's because most of my code is templates.</p>
",0
1785317,1783849,2,"<p>The main disadvantage (apart from the lengthy builds) is there is no clear separation of the interface and implementation.</p>

<p>Ideally, you should not need to see the implementation of an intuitive, and well documented interface.</p>
",1
1280611,1280586,3,"<p>A simple solution is to pick a room with less than 3 exits, and connect to it to a random room (watch out for double connections of course). Once there are no rooms with less than 3 exits, terminate. With only 20 or so rooms it doesn't really matter how slow your implementation is.</p>

<p>Edit: There's a chance that some part of the map will be ""cut off"" from the rest this way, or connected only by one corridor. It may help to start off with a ""long hallway"" and <em>then</em> apply the above algorithm, to be sure this can't occur.</p>
",8
1296773,1280586,0,"<p>You can do some pretty complicated algorithms for this. I made a <a href=""http://www.otcsw.com/maze.php"" rel=""nofollow noreferrer"">random maze generator</a> in Java that uses the Drunkard's Walk algorithm to accomplish this. Effectively, you iterate through every single grid location once, then as you create a room at that location you begin placing rooms at a random available adjacent location, and connect the two if they aren't already. Keep going until you can't make a new room adjacent to the previous location, then iterate to the next available grid space. This is a little bit complicated, but works well. The best way to understand it is to run that maze generator I linked you to, and watch the maze generation in action. You should understand it quickly.</p>

<p>Another solution is just to store every room in a 2D grid, corresponding to their actual locations. Then simply iterate through each grid space and randomly assign pointers to the adjacent rooms. Some will have 4 connections, some 3, 2, or 1 (have a minimum of 1). I would give each room a Room *north, Room *east, Room *south, Room *west variable group, and if any of them are nil that means there's a wall there.</p>
",0
1526820,1526792,3,"<p>Normally, separating out functions is a better, more common practice (and one of the main tasks during refactoring).  That being said, you can ""combine"" these simply by doing:</p>

<pre><code>int Triangle(GzRender *render, int numParts, GzToken *nameList,GzPointer *valueList)
{    
    if (on_screen) 
    {      
      //function code in here, working on ""pos"" instead of vertexList

      // return value
    }
    // return some other value here?
}
</code></pre>
",2
1526847,1526792,1,"<p>The first poster (Reed Copsey) is correct about the fact that it's generally better to keep the functions separate.</p>

<p>Have you considered using the <code>inline</code> directive?</p>

<p><a href=""http://www.codersource.net/cpp_tutorial_inline_functions.html"" rel=""nofollow noreferrer"">http://www.codersource.net/cpp_tutorial_inline_functions.html</a></p>

<p>Technically it's only a 'compiler hint' but you could try it. What it does is tell the compiler that you would like to include the body of the method denoted as inline in any other methods that call it. It's better from a maintenance standpoint, and should achieve what you are aiming for without the headaches of 'cut-and-paste' coding.</p>

<pre><code>int Triangle(GzRender *render, int numParts, GzToken *nameList,GzPointer *valueList)
{    
    if (on_screen) 
        {      
          return Position(render, pos);
        }
}



inline int Position(GzRender *render, GzCoord vertexList[3])
{
      //function code in here
}
</code></pre>
",1
1583568,1583547,0,"<p>Basically, you want to make a mouse-driven user interface.
This is very difficult to do from scratch, that's why Allegro has a built-in GUI system. If you don't like it, you'd better use a GUI library than doing it yourself. </p>

<p>I'd recommand <a href=""http://members.allegro.cc/miran/masking.html"" rel=""nofollow noreferrer"">MasKing</a>, it's an add-on for Allegro, to write graphical interfaces in C++.</p>
",0
1896617,1896597,1,"<p>The following code compiles fine for me on gcc 4.3.2.  (I defined the constructor to get it to link properly.)</p>

<pre><code>#include &lt;iostream&gt;

class Address 
{
 public:

    uint32_t addr;
    uint16_t port;

 public:
    Address() : addr(0), port(0) { }

    Address(uint32_t addr, uint16_t port);
    Address(const Address &amp; src);
    Address&amp; operator=(const Address &amp;src);
    bool isNull();

    friend  std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Address&amp; addr);
    friend  std::ostream&amp; operator&lt;&lt;( const Address&amp; addr, std::ostream&amp; os);
};

std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os, const Address&amp; addr)
{
 return os &lt;&lt; "" ( "" &lt;&lt; addr.addr &lt;&lt; "" : "" &lt;&lt; addr.port &lt;&lt; "" ) "";
}

int main()
{
 Address a;
 std::cout &lt;&lt; a &lt;&lt; std::endl;
}
</code></pre>

<p>This outputs:</p>

<pre><code> ( 0 : 0 ) 
</code></pre>

<p>See if this works for you, and if it does, just retrace your steps to see what you're doing differently.</p>
",0
1896627,1896597,0,"<p>Well, if I include</p>

<pre><code>#include &lt;cstdint&gt;
#include &lt;iostream&gt;
</code></pre>

<p>at the beginning of your code, I can compile it using <code>g++ -c -std=c++0x Account.cpp</code> (g++ 4.4.1).</p>
",0
1395727,1395601,3,"<blockquote>
  <p>Note how the built-in types have some
  quirks compared to classes: a Derived
  can be passed to function taking a
  Base (although it gets sliced), and an
  int can be passed to function taking a
  long, but you cannot pass an int&amp; to a
  function taking a long&amp;!!</p>
</blockquote>

<p>That's not a quirk of built-in vs. class types. It's a quirk of inheritance.</p>

<p>If you had classes A and B, and B had a conversion to A (either because A has a constructor taking B, or because B has a conversion operator to A), then they'd behave just like int and long in this respect - conversion can occur where a function takes a value, but not where it takes a non-const reference. In both cases the problem is that there is no object to which the necessary non-const reference can be taken: a long&amp; can't refer to an int, and an A&amp; can't refer to a B, and no non-const reference can refer to a temporary.</p>

<p>The reason the base/derived example doesn't encounter this problem because a non-const Base reference <em>can</em> refer to a Derived object. The fact that the types are user-defined is a necessary but not a sufficient condition for the reference to be legal. Convertible user-defined classes where there is no inheritance behave just like built-ins.</p>

<p>This comment is way too long for comments, so I've used an answer. It doesn't actually answer your question, though, other than to distinguish between:</p>

<ul>
<li>""Conversions"" where a reference to a derived class is passed to a function taking a reference to a base class.</li>
<li>Conversions where a user-defined or built-in conversion actually creates an object, such as from int to long.</li>
</ul>
",1
1395779,1395601,4,"<p>Unfortunately the answer to your question is hugely complex, occupying at least 9 pages in the ISO C++ standard (specifically: ~6 pages in ""3 Standard Conversions"" and ~3 pages in ""13.3.3.1 Implicit Conversion Sequences"").</p>

<p><strong>Brief summary:</strong> A conversion that does not require a cast is called an ""implicit conversion sequence"".  C++ has ""standard conversions"", which are conversions between fundamental types (such as <code>char</code> being promoted to <code>int</code>) and things such as array-to-pointer decay; there can be several of these in a row, hence the term ""sequences"".  C++ also permits user-defined conversions, which are defined by conversion functions and converting constructors.  The important thing to note is that <strong>an implicit conversion sequence can have <em>at most one</em> user-defined conversion</strong>, with optionally a sequence of standard conversions on either side -- C++ will never ""chain"" more than one user-defined conversion together without a cast.</p>

<p>(If anyone would like to flesh this post out with the full details, please go ahead...  But for me, that would just be too exhausting, sorry :-/)</p>
",1
1395780,1395601,5,"<p>C++ Standard gives the answer to your question in <strong>13.3.3.1  Implicit conversion sequences</strong>, but it too large to post it here. I recommend you to read at least that part of C++ Standard.</p>

<p>Hope <a href=""https://stackoverflow.com/questions/81656/where-do-i-find-the-current-x-standard#83763"">this</a> link will help you.</p>
",1
1149117,1149111,0,"<p>C-style enums are not terribly useful for this purpose, since there's no way to recover the original string name.  You could make some <code>switch</code>-based mechanism, but at that point you may as well just set up your own way of doing it all that works with your user I/O requirements without shoehorning.</p>
",4
1149132,1149111,0,"<p>One of the ways to handle this is to set up a map of strings to enum values.  Other possibilities include a dedicated function.</p>

<p>See this <a href=""https://stackoverflow.com/questions/726664/string-to-enum"">question</a> for some ideas.</p>

<p><a href=""https://stackoverflow.com/questions/201593/is-there-a-simple-script-to-convert-c-enum-to-string"">This question</a> has some ideas of how to generate code to convert enums to strings, but most of the examples will work in reverse as well.</p>
",0
1149154,1149111,1,"<p>Make Genre a class that wraps the enum type (GenreTypeEnum). Add the necessary operators, e.g. istream, ostream, equal operator, etc. </p>

<p>Inside the istream operator, you can read a std::string from the stream and then parse and convert the value to the associated GenreTypeEnum. </p>

<p>Something like this perhaps: </p>

<pre><code>    namespace GenreType { enum GenreTypeEnum { miscellaneous, fiction, non_fiction, children }; }

    class Genre
    {
      public:
        Genre() : genreType( GenreType::miscellaneous) {}
        ~Genre() {}

        void setType( std::string genreTypeString ){ // implement string-&gt; enum }
        std::string toString( void ) const { // convert genre back to string }

      private:

        GenreType::GenreTypeEnum genreType;

    };

    std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os, const Genre&amp; genre )
    {
        os &lt;&lt; genre.toString();
        return os;
    }

    std::istream&amp; operator&gt;&gt;( std::istream&amp; is, Genre&amp; genre )
    {
        std::string input;
        is &gt;&gt; input;

        genre.setType( input );
        return is;
    }
</code></pre>
",0
1151360,1151358,0,"<p>Yes. If you need to access private members, consider providing an appropriate public interface for them OR go for <code>friend</code> class. It is usually better to avoid it though. To handle a specific type, implement operator== with an instance of that type.</p>
",1
1151367,1151358,2,"<p>If you make operator friend or member of one class, it will be able to access its private members. To access privates of both, operator will have to be free standing friend of both. </p>

<p>That is a bit unwieldy, so consider making public interface for interesting things instead.</p>

<p>(suppressed all puns about accessing private parts of multiple entities)</p>

<p>Here is how you can make a very friendly operator, but again, this is not a good solution.</p>

<p>(didn't compile the code)</p>

<pre><code>class B;

class A
{
friend bool operator==(const A&amp;, const B&amp;);
private:
    int private_;
};

class B
{
friend bool operator==(const A&amp;, const B&amp;);
private:
    int private_;
};

bool operator==(const A&amp; a, const B&amp; b)
{
    return a.private_ == b.private_;
}   class B;
</code></pre>

<p>This is a better way -- just make public getters and use them in operator. </p>

<pre><code>class A
{
public: 
   int GetPrivate() const { return private_; }
private:
    int private_;
};

class B
{
public:
    int GetPrivate() const { return private_; }
private:
    int private_;
};

bool operator==(const A&amp; a, const B&amp; b)
{
    return a.GetPrivate() == b.GetPrivate();
}  
</code></pre>

<p>You also can make operator to be part of one of the classes, if you need privates from it alone.
Read up on operator overloading syntax for more.</p>
",2
1151372,1151358,0,"<p>You can, but you would need to make either 'bool operator==(A a, B a)' 'friend' of class A if you are using a free function or make class B 'friend' of class A if you implement the comparison operator as a class member function.</p>

<p>You can avoid the friendship requirement by providing a public accessor to the private member in class A </p>
",1
1151410,1151358,1,"<p>You don't specify the type of bookcheckout, so I can't be sure, but I think that your operator== will work without change.</p>

<p>For instance, if the code is:</p>

<pre><code>class Library
{

public:
    const Book &amp; operator[] (int i);
};

Library bookcheckout;
</code></pre>

<p>Then your if statement will call the operator== you have without a problem.</p>
",3
1303966,1303947,21,"<p>You can't return a reference to a local variable. Inside the <code>operator+()</code> function, you're creating a local variable called <code>tmp</code>. It will get destroyed as soon as the function exits. You can't return a reference to that variable, because it no longer exists when the calling function gets the return value.</p>

<p>Change your definition of the function to:</p>

<pre><code>const Int operator+(const Int&amp;) const;
</code></pre>

<p>It would build without warnings and work fine too.</p>
",1
1303968,1303947,10,"<p>What you try to do is to return a reference to a memory location that will be invalid the moment you return it.</p>

<p>The variable tmp will disappear when it goes out of scope (that is, when operator+ is finished). </p>

<p>Because your return type is Int&amp;, not the value of tmp is returned at ""return tmp"" but a reference to tmp. This is not correct because tmp will not exist anymore after the method is finished!!</p>

<p>Solution: Do not return as reference, but as Int</p>
",0
1434048,1433965,4,"<p>When you mess up <code>()</code> with <code>0</code>, this means you typed the code without even the most basic knowledge of what it means. (And that's true even if the code was in the book like this.) That means you understood too little to already have progressed that far. </p>

<p>Does the book really use <code>cout</code> and <code>endl</code> (rather than <code>std::cout</code> and <code>std::endl</code>) without even a note about it? And does it really fail to provide the necessary include directive for those two identifiers? And does it really define the <code>main()</code> function without a return type (<code>int main()</code>)? </p>

<p>If the answer to these questions is ""yes"", throw it away. Yes, I am very serious. Even if it really is famous (which I doubt, since I, being interested in C++, have never heard about it). If it gets this wrong, then it's famous crap at best. </p>

<p>In <a href=""https://stackoverflow.com/questions/1427280/1427737#1427737"">this answer</a> I just listed a few very good C++ books. </p>
",2
1433984,1433965,0,"<p>I don't know this book, but at least:</p>

<pre><code>main()
</code></pre>

<p>should become:</p>

<pre><code>int main()
</code></pre>

<hr>

<p>Also,</p>

<pre><code> // now the same as `Rational` methods.
 cout &lt;&lt; x.numerator0() &lt;&lt; ""/"" &lt;&lt; x.denominator0() &lt;&lt; endl;
</code></pre>
",0
1433994,1433965,9,"<pre><code>            int numerator0 const { return num; }
            int denominator0 const { return den; }
</code></pre>

<p>Notice the '0' (zero) character instead of parenthesis ( ).</p>

<pre><code>            int numerator() const { return num; }
            int denominator() const { return den; }
</code></pre>
",2
1210375,1210362,1,"<p>a Good book for templates - <a href=""http://books.google.co.in/books?id=EotSAwuBkJoC&amp;printsec=frontcover#v=onepage&amp;q=&amp;f=false"" rel=""nofollow noreferrer"">C++ Templates by David Vandevoorde, Nicolai M. Josuttis </a></p>
",1
1210378,1210362,2,"<p>The C++ Programming Language would give you the best overview of the language. It sounds like you have that but the section on object oriented programming is worthwhile. I'd probably spend more time learning about object oriented programming at this point than more specific C++ features.</p>

<p>A book like ""Code Complete"" might be a good choice for you.</p>
",4
1210379,1210362,5,"<p>If you haven't yet read Stroustrup's books, they are definitely a good read. There's nothing quite like reading about the language from the person who designed it.</p>

<p>Whenever I learn a new language, I always try to find the canonical reference material written by the language designer or somebody very close to them.</p>
",2
1210386,1210362,2,"<p>I feel like you can probably make more progress learning to program by tackling real programming problems, rather than reading another book.</p>

<p>I certainly don't discount the value of books as a programming resource but I do think there is no better way to learn a programming language than writing real code.  Given your financial constraints, you have the additional motivation that writing code is free.  </p>

<p>Concentrating on a particular part of the language or a pattern for programming might be interesting, but a specific problem to solve will give you context that, in my opinion, is a more powerful learning mechanism.</p>

<p>Of course, you can't write code in a vacuum.  You have already read <em>Accelerated C++</em> which will probably give you more than enough to get started writing code, but there are also a whole pile of resources on the net that will help (StackOverflow is a great place to start).</p>

<ul>
<li><a href=""https://stackoverflow.com/questions/948686/any-tutorials-for-win32-sdk-programming"">Tutorials for Win32</a></li>
<li><a href=""https://stackoverflow.com/questions/909323/what-are-good-online-resources-or-tutorials-to-learn-c"">Online C resources</a></li>
<li><a href=""https://stackoverflow.com/questions/299042/beginner-visual-c-6-tutorial"">VC6 Tutorial</a></li>
</ul>
",0
1210392,1210362,1,"<ul>
<li>Learn STL more and more, there is a
lot more to learn.</li>
<li>learn Boost. This would change how
you think about programming in C++.</li>
</ul>

<p>If you want to go very deep, read Stroustrup's papers. Select a paper now and then, print it, read it carefully. Stroustrup is an excellent writer. reading his papers would make you a superior C++ programmer for sure.</p>

<p>My favorite list is  :</p>

<ul>
<li><a href=""http://www.research.att.com/~bs/hopl2.pdf"" rel=""nofollow noreferrer"">A History of C++: 1979-1991</a>, <a href=""http://www.research.att.com/~bs/hopl-almost-final.pdf"" rel=""nofollow noreferrer"">A
History of C++: 1979-1991.</a> After
I read those papers I <strong>loved</strong> C++.</li>
<li><a href=""http://www.research.att.com/~bs/whatis.pdf"" rel=""nofollow noreferrer"">What is Object-Oriented
Programming?</a></li>
<li><a href=""http://www.research.att.com/~bs/oopsla.pdf"" rel=""nofollow noreferrer"">Why C++ isn't just an
Object-Oriented Programming
Language.</a></li>
<li><a href=""http://www.research.att.com/~bs/stack_cat.pdf"" rel=""nofollow noreferrer"">Sixteen Ways to Stack a Cat.</a>
This is a jewel that everyone ought
to read :)</li>
</ul>
",0
1210393,1210362,0,"<p>If you don't want to spend money, you should learn multi-threaded programming.  The basics are already in the books you have, and described in API documentation.  Try to actively create a program with many threads that communicate back and forth, and then multiply the number of threads to see if you've made a good design.</p>

<p>You'll want to read up on Semaphores, Mutexes, and Critical Sections.</p>

<p>I take three approaches to multi-threaded programming:</p>

<ol>
<li>Use a PostMessage style communication between threads</li>
<li>Pass thread-safe objects between threads through which data is stored and relayed</li>
<li>Initialize a thread on start-up, let it run on its own, and then retrieve the data at the end of the run</li>
</ol>

<p>If you're ready to spend money, I would recommend <a href=""https://rads.stackoverflow.com/amzn/click/com/0201633612"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">Design Patterns</a> as a good next-read. It's more generic, and you'll find some of the ideas make sense.</p>
",0
1210464,1210362,0,"<p>I think you started out with just the right book! For those who didn't know, this book starts with STL at the beginning and leaves pointers for the end. Most programmers learn C first, and consequently have a forever distorted view of what C++ can be.</p>

<p>It might be really interesting for you to now read 'The C Programming Lanugage' by Kernigan &amp; Richie at this point. This is probably a necessity if you want to understand the mindset behind most C/C++ code in the world today.</p>

<p>But more important than your next programming book is to find a medium-sized program you really <em>want</em> to write, and go after it. Use all kinds of reference materials for the project. Incorporate a <a href=""http://www.boost.org/"" rel=""nofollow noreferrer"">boost</a> library or two in your program.</p>
",0
1210493,1210362,3,"<p>In addition to reading Stroustrup's books (suggested by another answer here), I'd suggest his two FAQs as a great starting point:</p>

<ul>
<li><a href=""http://www.research.att.com/~bs/bs_faq.html"" rel=""nofollow noreferrer"">Bjarne Stroustrup's FAQ</a></li>
<li><a href=""http://www.research.att.com/~bs/bs_faq2.html"" rel=""nofollow noreferrer"">C++ Style and Technique FAQ</a></li>
</ul>

<p>They both link to further reading material.</p>

<p>These two, along with the <a href=""http://www.parashift.com/c++-faq-lite/"" rel=""nofollow noreferrer"">C++ FAQ Lite</a>, are required reading for new programmers at my workplace.</p>

<p>Once you're even a bit more comfortable, consider jumping in to the community: subscribe to something like the <a href=""http://www.boost.org/community/groups.html"" rel=""nofollow noreferrer"">boost mailinglists</a>, watch the blogs of big name figures like <a href=""http://herbsutter.wordpress.com/"" rel=""nofollow noreferrer"">Herb Sutter</a>, read Alexandrescu's <a href=""http://www.gotw.ca/gotw/"" rel=""nofollow noreferrer"">Guru of the Week</a> articles.  You may feel like you're in over your head (I still do often after many years of reading the lists) but you'll learn a ton, <em>especially</em> watching the language grow and evolve.  (And this stuff is free!)</p>

<p>You can get more understanding from watching how a language changes over time, and how people <em>actually</em> use it, than you can from a million hours of memorizing the standard.  (Not that shelling out a few bucks to have a copy of the ISO/IEC standard around is a bad idea, mind -- great for reference from time to time.)</p>

<p>As for books: </p>

<ul>
<li>after the Stroustrup books, </li>
<li>start with the <a href=""http://www.aristeia.com/books.html"" rel=""nofollow noreferrer"">Meyers</a> (""Effective"") books.</li>
<li>I'd also recommend <a href=""http://www.gotw.ca/publications/c++cs.htm"" rel=""nofollow noreferrer"">C++ Coding Standards</a> -- a great amount of work went into gathering the ""common sense"" of the users of the language in this book.</li>
<li>Then if you want to blow your mind you can look at <a href=""http://erdani.org/book/main.html"" rel=""nofollow noreferrer"">Modern C++ Design</a> or some of the fun template metaprogramming resources...</li>
</ul>

<p>Above all, just stay connected and interested.  Mailinglists, blogs, websites, academic papers, magazines, whatever -- choose what suits you best, don't expect to follow everything all the time, but keep your ears and eyes open; find aspects that interest you and follow them!</p>
",0
1210670,1210362,2,"<p>These are my favorite:</p>

<p>Effective C++ - Scott Meyers</p>

<p>C++ Standard Library Tutorial and Reference - Nicolai Josuttis</p>

<p>I might suggest a library card, or hanging out and reading Border's, to make sure the books are helpful for you.</p>
",0
1210709,1210362,0,"<p>If you are tight on cash, read <a href=""http://www.greenteapress.com/thinkcpp/"" rel=""nofollow noreferrer"">How to Think Like a Computer Scientist</a>. Also read the <a href=""http://www.parashift.com/c++-faq-lite/"" rel=""nofollow noreferrer"">FAQ lite</a>. </p>
",0
1594632,1594607,1,"<p>If the class X instance is const the const version is called, otherwise the non-const:</p>

<pre><code>void function1( X&amp; x )
{
    x[0]; // x is non-const, non-const version is called
    x[0] = ... // allright
}

void function2( const X&amp; x )
{
    x[0]; // x is const, const version is called
    x[0] = ... // illegal - won't compile
}
</code></pre>

<p>this is done to facilitate const-correctness.</p>
",0
1594637,1594607,0,"<p>The const one would be used if operator[] were invoked on a const X object; otherwise the non-const one.</p>

<pre><code>X x;
x[42] = 42; // ok

X x_const;
x_const[42] = 42; // error: cannot assign to const reference
</code></pre>
",0
1594642,1594607,0,"<p>The first one is called when the instance of the class is referred to as a non-const type.  The second is called when the type that refers to the instance is const.</p>

<p>For example:</p>

<pre><code>void check_array(X const&amp; x)
{
   // x[0] = 2;  // That would be a compile error.  
                 // And it's GOOD that we have such a check!
   return x[1] == 5; //calls non-const version
}

void mutate_array(X&amp; x)
{
   x[0] = 2; // calls non-const version
   if (x[1] == 5){  //calls non-const version anyway!
       X const&amp; const_ref = x;
       return const_ref[1] == 5;  //NOW it calls const version.
   }
}
</code></pre>

<p>The reasons to use it are:</p>

<ul>
<li>to force a check that we don't try to modify something, that shouldn't be modified (as in <code>check_array()</code> function)</li>
<li>to allow compiler to optimize code, knowing that certain values won't change in a block.</li>
</ul>
",0
1594645,1594607,-1,"<p>Using 2 versions offers additional ways for the compiler to optimize. No value can't be assigned to const int &amp;. The second operator is called whenever the statements allow it and since the operator is const, the compiler has additional possiblities for optimization. Whenever a result is assigned to the return value of that operator, the compiler selects the first version (which is not const).</p>

<p>For a more complete explanation - see Scott Meyers (More) Effective C++</p>
",1
1594646,1594607,5,"<pre><code>foo( X x )
{
  x[0];  // non-const indexer is called
}

bar ( const X x )
{
  x[0]; //const indexer is called
}
</code></pre>
",0
1789428,1789421,10,"<p>That is a memory leak. You have to delete memory you allocate manually.</p>
",0
1789431,1789421,5,"<p>You need to <code>delete A;</code></p>

<p>For regular objects setting the pointer to NULL does nothing but invalidating the pointer, the object is still around in memory, this is particularly true if you notice that you may have more than one pointer to the same object, changing one shouldn't affect the others.</p>
",1
1789432,1789421,3,"<p>On most modern OSs, the application's memory will be reclaimed at exiting the application. Meanwhile, you have a memory leak.</p>
",0
1789441,1789421,2,"<p>No, it will be lost to the process forever. You will have a memory leak. If you keep doing this, your program will eventually run out of memory!! To avoid this, <code>delete</code> the object when you no longer need it.</p>

<p>Often people will set the pointer to NULL after deleting it, so that other parts of the program can verify that the object has been deleted, and thereby avoid accessing or deleting it again.</p>
",1
1789444,1789421,32,"<p>This is a classic leak.
As you say, the memory remains allocated but nothing is referencing it, so it can never be reclaimed - until the process exits.</p>

<p>The memory should be deallocated with delete - but using a smart pointer (e.g. std::auto_ptr or boost::shared_ptr (or tr1::shared_ptr) to wrap the pointer is a much safer way of working with pointers.</p>

<p>Here's how you might rewrite your example using std::auto_ptr:</p>

<pre><code>std::auto_ptr a( new MyClass() );

/*...do something in the meantime...*/

a.reset();
</code></pre>

<p>(Instead of the call to reset() you could just let the auto_ptr instance go out of scope)</p>
",2
1789460,1789421,3,"<p>As per Phil Nash's comment, for every new, there is a corresponding delete, likewise, for every malloc, there is a corresponding free. If the corresponding delete/free is not there, you have a leak. </p>

<p>Hope this helps,
Best regards,
Tom.</p>
",0
1789531,1789421,2,"<p>C++ does't have garbage collector, like some other languages has (Java, C#, ...) so you must delete allocaled objects yourself.</p>
",0
1789545,1789421,25,"<p>Under most circumstances, that will cause a memory leak in your process. You have several options for managing memory in C++.</p>

<ol>
<li><p>Use a <code>delete</code> to manually free memory when you're done with it. This can be hard to get right, especially in the context of exception handling.</p></li>
<li><p>Use a smart pointer to manage memory for you (auto_ptr, shared_ptr, unique_ptr, etc.)</p></li>
<li><p>C++ does not come with a garbage collector, but nothing prevents you from using one (such as the <a href=""http://www.hpl.hp.com/personal/Hans_Boehm/gc/"" rel=""nofollow noreferrer"">Boehm GC</a>) if you want to go down that route.</p></li>
</ol>
",1
1790117,1789421,0,"<p>By assigning <code>NULL</code> to the pointer you will not free allocated memory. You should call deallocation function to free allocated memory. According to C++ Standard 5.3.4/8: ""If the allocated type is a non-array type, the allocation function¡¯s name is <code>operator new</code> and the deallocation function¡¯s name is <code>operator delete</code>"". I could suggest the following function to safely delete pointers (with assigning <code>NULL</code> to them):</p>

<pre><code>template&lt;typename T&gt;
inline void SafeDelete( T*&amp; p )
{
    // Check whether type is complete.
    // Deleting incomplete type will lead to undefined behavior
    // according to C++ Standard 5.3.5/5.
    typedef char type_must_be_complete[ sizeof(T)? 1: -1 ];
    (void) sizeof(type_must_be_complete);

    delete p;
    p = NULL;
}
</code></pre>
",4
1790475,1789421,1,"<p>Variables stored on the stack, are the local variables of each function, e.g. int big[10];
Variables stored on the heap,  are the variables which you initiated using explicit memory allocation routines such as malloc(), calloc(), new(), etc.</p>

<p>Variables stored on the stack have a lifetime that is equal to the lifetime of the current stack frame. In English, when the function returns, you can no longer assume that the variables hold what you expect them to hold. That's why its a classic mistake to return a variable that was declared local in a function.</p>
",0
1790762,1789421,5,"<pre><code>A = new MyClass();

{...do something in the meantime...}

A = NULL;
</code></pre>

<p>The way I keep track of it is that there are two separate objects. <em>Somewhere</em> on the heap, a <code>MyClass</code> instance is allocated by <code>new</code>. And on the stack, there is a pointer named <code>A</code>.</p>

<p><code>A</code> is just a pointer, there is nothing magical about out, and it doesn't have some special connection to the heap-allocated <code>MyClass</code> object. It just happens to point to that right now, but that can change.</p>

<p>And on the last line, that is exactly what happens. You change the pointer to point to something else. That doesn't affect other objects. It doesn't affect the object it used to point to, and it doesn't affect the object (if any) that it is set to point to now. Again, <code>A</code> is just a dumb raw pointer like any other. It might be NULL, or it might point to an object on the stack, or it might point to an object on the heap, or it might be uninitialized and point to random garbage. But that's all it does. It points, it doesn't in any way take ownership of, or modify, the object it points to.</p>
",0
1972746,1972735,11,"<p>There's <a href=""http://code.google.com/codejam/"" rel=""noreferrer"">Google Code Jam</a>, but only once a year; <a href=""http://www.topcoder.com/"" rel=""noreferrer"">TopCoder</a>, with many more contests; and others listed <a href=""http://www.tenouk.com/cpluspluscompetitioncontest.html"" rel=""noreferrer"">here</a>.</p>
",0
1972748,1972735,13,"<p>Contests won't help you with learning dark corners of a language. Most of them are about speed and you can only achieve speed if you trim down your usage of a language to a bare stable minimum. You don't want to spend hours trying to figure out why your clever templates could not be compiled, you don't want to write readable and understandable code as it slows you down, you don't want to test it, you just want to be done with it as quickly as possible.</p>

<p>If your goal is to learn a language, contests are utterly wrong way to do it.</p>

<p>Read sources of boost and STL, try to copy and modify some of the code from them, that is a good way.</p>
",3
1972749,1972735,6,"<p>There's little point in testing C++ skill level, as ultimately it would not be about thinking, but either be very simple, or be about knowing the little pitfalls in differences between compiler implementations, or pitfalls in the standard itself.</p>

<p>To test one's knowledge about C++, the easiest way is to get involved in some hardcore C++ project like <a href=""http://www.boost.org/"" rel=""nofollow noreferrer"">boost</a>, or <a href=""http://www.open-std.org/jtc1/sc22/wg21/"" rel=""nofollow noreferrer"">C++0x standard development</a>.</p>

<p>To test your skills and algorithmic knowledge in general, as a thinking programmer, you should try contests like the <a href=""http://icpc.baylor.edu/"" rel=""nofollow noreferrer"">ACM programming contest</a> or <a href=""http://www.topcoder.com/"" rel=""nofollow noreferrer"">TopCoder</a>.</p>
",2
1972751,1972735,8,"<p>There are some:</p>

<ol>
<li><p><a href=""http://www.topcoder.com/"" rel=""noreferrer"">Topcoder</a> probably is best for you. It has algorithmic programming contests very often, the competitors there are world class. It also has a general purpose component programming, e.g. designing/implementing a XML processing library etc. 
Topcoder awards money to the best few contestants. Best of the best, you can see others' source code!</p></li>
<li><p><a href=""http://spoj.pl"" rel=""noreferrer"">Sphere Online Judge.</a> and many others: acm.timurs.ru, acm.uva.es, acm.pku.edu.cn etc.
These are only for algorithmic skills training. You can have a lot of fun there :)</p></li>
</ol>
",0
1972777,1972735,1,"<p><a href=""http://uva.onlinejudge.org/"" rel=""nofollow noreferrer"">UVa Online Judge</a> has a lot of contests running throughout the year and they have a large userbase for nice competition. ""World Finals Warmup"" contests will be coming up in January. The site also has nearly 3 000 problems for you to solve, lots of fun and very challenging.</p>
",0
1972946,1972735,3,"<p>You can pass c++ test on <a href=""http://www.brainbench.com"" rel=""nofollow noreferrer"">brainbench.com</a>, for example. Some type of contest too...</p>
",0
1974022,1972735,1,"<p>I <a href=""http://code.google.com/p/tetris-challenge/"" rel=""nofollow noreferrer"">participated</a> in one of David Bolton's <a href=""http://cplus.about.com/od/programmingchallenges/Programming_Challenges.htm"" rel=""nofollow noreferrer"">program challenges</a> once. He posts a new one every month or so.</p>
",0
1974129,1972735,2,"<p>I wonder, that nobody mentioned <a href=""http://www.codechef.com"" rel=""nofollow noreferrer"">Codechef</a>. As others already stated, a coding competition might not be the optimal way to test your skill level, but Codechef is a slightly different case.</p>

<p>They offer monthly programming competitions with multiple assignments. You can enter in almost any language and you have 1 week of time. So there is no rush, but even then, the competitions will rather test your logical thinking and problem solving abilities, than your knowledge of the C++ language. (Though, one can learn much from reading the source code of other entries.)</p>

<p>However, I can only encourage <strong>everybody</strong> to enter at least once - programming is fun! =D</p>
",0
1974249,1972735,2,"<p>If you are only into C programming, there is always the <a href=""http://www.ioccc.org/"" rel=""nofollow noreferrer"">IOCCC</a></p>
",0
1975746,1972735,1,"<p>about.com's C/C++ section has a programming challenge that is ongoing. Here's the latest:
<a href=""http://cplus.about.com/od/programmingchallenges/a/challenge30.htm"" rel=""nofollow noreferrer"">http://cplus.about.com/od/programmingchallenges/a/challenge30.htm</a></p>
",0
1235294,1235286,1,"<p>First, you tag this as C++ and C. Which is it? C does not have a string class. If it is C++, please remove the C tag, it is misleading (they are not the same language!).</p>

<p>Edit: I misunderstood what you are trying to do. Your method should compile. You just have to remember to dereference the returned str to get the string.</p>

<p>I rarely deal with double indirection, but you have to do something like this to set the string:</p>

<pre><code>*(*str) = ""STR""; //or
*(str[i]) = ""STR"";
</code></pre>

<p>I don't know how you would use the address operator here, because it returns a reference and not a pointer.</p>

<p>to set the string in the str array. Your method is really weird. The problem is that the compiler doesn't know that you want to dereference a string, so it tries to dereference a char*.</p>

<p>I do not understand why you want to do it this way, though. It would be better to do this:</p>

<pre><code>std::string str[10];
std::string* GetStr() { return str; }
</code></pre>
",6
1319300,1319160,1,"<p>Doesn't the <code>codecvt</code> template take the state type as a parameter?  Can you just use a pointer type there instead?  I can't remember whether the various classes that use a <code>codecvt</code> place requirements on the state type.</p>

<p>Assuming that you can't just change the state type... on MSVC 2008, <code>mbstate_t</code> is <code>typedef</code>d as an <code>int</code>.  The standard only requires that <code>int</code> be larger than 16 bits and no larger than a long, so it's not 64-bit safe.  I guess you would need to store an index or key into some data structure instead of a pointer.</p>

<p>update:</p>

<p>The following compiles under VS2008, at least:</p>

<pre><code>std::wstring const in = L""input"";
size_t const buf_size = 256;
char* buf = new char[buf_size];
wchar_t const* char_next;
char * byte_next;
void* state = NULL;

typedef std::codecvt&lt;wchar_t, char, void*&gt; codecvt_t;
codecvt_t::result res =
    std::use_facet&lt;codecvt_t&gt;(std::locale()).out(
        state, in.c_str(), in.c_str() + in.length(),
        char_next, &amp;buf[0], &amp;buf[buf_size], byte_next);
</code></pre>
",1
1689346,1689195,4,"<p>Pff, too long standard quoting.</p>

<p>You can use another type as covariant if (a) it is a pointer/reference (b) it can be casted to the prior return type by mere addition of a constant known at compilation time (c) it is compliant to all constant-volatile qualifiers.</p>
",2
1689267,1689195,10,"<p>C++ Standard 2003. 10.3.5</p>

<blockquote>
  <p>The return type of an overriding
  function shall be either identical to
  the return type of the overridden
  function or <strong>covariant</strong> with the classes
  of the functions.  If a function D::f
  overrides a function B::f, the return
  types of the functions are covariant
  if they satisfy the following
  criteria:</p>
  
  <p>¡ª  both are pointers to classes or
  references to classes</p>
  
  <p>¡ª  the class in the return type of
  B::f is the same class as the class in
  the return type of D::f, or <strong>is an
  unambiguous and accessible direct or
  indirect base class of the class in
  the return type of D::f</strong></p>
  
  <p>¡ª  both pointers or references have
  the same cv-qualification and the
  class type in the return type of D::f
  has the same cv-qualification as or
  less cv-qualification than the class
  type in the return type of B::f.</p>
  
  <p>If the return type of D::f differs
  from the return type of B::f, the
  class type in the return type of D::f
  shall be complete at the point of
  declaration of D::f or shall be the
  class type D.  When the overriding
  function is called as the final
  overrider of the overridden function,
  its result is converted to the type
  returned by the (statically chosen)
  overridden function (5.2.2).</p>
</blockquote>

<p>Example:</p>

<pre><code>class B {};
class D : private B { friend class Derived; };
struct Base {
  virtual B*  vf4();
  virtual B*  vf5();
};
class A;
struct Derived : public Base {
  D* vf4();  // OK: returns pointer to derived class
  A* vf5();  // error: returns pointer to incomplete class
};
</code></pre>
",0
1795112,1795060,2,"<p>The crucial information missing is what kind of archive this is. Once you know that look for a library supporting this kind of archive. If it is no popular archive format and there is no library you need to find out what kind of encryption algorithm is used and how exactly it is applied, then use that information to decrypt the contents of the archive ""by hand"".</p>
",0
1241993,1241973,3,"<p>Add this to your print out:</p>

<pre><code>cout &lt;&lt; ""this: "" &lt;&lt; this &lt;&lt; endl;
cout &lt;&lt; ""WebCallback This: "" &lt;&lt; dynamic_cast&lt;WebCallback*&gt;(this) &lt;&lt; endl;
</code></pre>

<p>I bet this is what you are looking for.</p>
",3
1241998,1241973,8,"<p>This can happen with multiple inheritance, if your layout looks like this:</p>

<pre><code>class UnderlyingBase {
  char d[56];
};

class UnderlyingClass
    :public UnderlyingBase, 
     public WebCallback {

};
</code></pre>

<p>Then the layout can be like this, for each object involved. The last one is the complete object containing the first two ones as base-class sub-objects, and that you take the pointer of, and which will be converted to <code>WebCallback*</code>.</p>

<pre><code>[UnderlyingBase]
 &gt; char[56]: 56 bytes, offset 0x0

[WebCallback]
 &gt; unknown:  x bytes, offset 0x0

[UnderlyingClass]
 &gt; [UnderlyingBase]: 56 bytes (0x38 hex), offset 0x0
 &gt; [WebCallback]:    x  bytes, offset 0x38
</code></pre>

<p>Now since your vector contains <code>WebCallback*</code>, the compiler adjusts the pointer to point to the <code>WebCallback</code> sub-object, while when it would point to <code>UnderlyingClass</code> or <code>UnderlyingBase</code>, it would start 0x38 (56) bytes earlier. </p>
",3
1280256,1280229,4,"<p>Well, you don't go into a lot of detail about what you did, but I can give you an optimization that can be used, if you didn't think of it...</p>

<p>If you're using the straightforward method of trying to find factors of a number n, by using the mod operator, you don't need to check all the numbers &lt; n.  That obviously would take n comparisons...you can just go up to floor(sqrt(n)).  For each factor you find, just divide n by that number, and you'll get the conjugate value, and not need to find it manually.</p>

<p>For example: say n is 15.</p>

<p>We loop, and try 1 first.  Yep, the mod checks out, so it's a factor.  We divide n by the factor to get the conjugate value, so we do (15 / 1) = 15...so 15 is a factor.</p>

<p>We try 2 next.  Nope.  Then 3.  Yep, which also gives us (15 / 3) = 5.  </p>

<p>And we're done, because 4 is > floor(sqrt(n)).  Quick!</p>

<p>If you didn't think of it, that might be something you could leverage to improve your times...overall you go from O(n) to O(sqrt (n)) which is pretty good (though for numbers this small, constants may still weigh heavily.)</p>
",1
1280262,1280229,3,"<p>I was in a programming competition way back in school where there was some similar question with a run time limit.  the team that ""solved"" it did as follows:</p>

<p>1) solve it with a brute force slow method.<br>
2) write a program to just print out the answer (you found using the slow method), which will run sub second.</p>

<p>I thought this was bogus, but they won.</p>
",9
1280268,1280229,0,"<p>First, create table with two columns: Triangle_Number Count_of_Factors.</p>

<p>Second, derive from this a table with the same columns, but consisting only of the 320 rows of the lowest triangle number with a distinct number of factors.</p>

<p>Perform your speedy lookup to the second table.</p>
",1
1280278,1280229,2,"<p>see <a href=""http://www.research.att.com/~njas/sequences/A000217"" rel=""nofollow noreferrer"">Triangular numbers: a(n) = C(n+1,2) = n(n+1)/2 = 0+1+2+...+n. (Formerly M2535 N1002)</a></p>

<p>then pick the language you want implement it in, see <a href=""http://lostsouls.org/grimoire_diminishing_returns"" rel=""nofollow noreferrer"">this</a>:</p>

<blockquote>
  <p>""... <strong>Python</strong></p>

<pre><code>import math
def diminishing_returns(val, scale):
    if val &lt; 0:
        return -diminishing_returns(-val, scale)
    mult = val / float(scale)
    trinum = (math.sqrt(8.0 * mult + 1.0) - 1.0) / 2.0
    return trinum * scale
</code></pre>
  
  <p>...""</p>
</blockquote>
",0
1280398,1280229,0,"<p>Well, at least you got a good professor.  Performance is important.</p>

<p>Since you have a program that can do the job, you can precalculate all of the answers for 1 .. 320.</p>

<p>Store them in an array, then simply subscript into the array to get the answer.   That will be very fast.</p>
",0
1280407,1280229,11,"<p>Here's a hint:</p>

<p>The number of divisors according to the <a href=""http://en.wikipedia.org/wiki/Divisor_function"" rel=""noreferrer"">Divisor function</a> is the product of the power of each prime factor plus 1.  For example, let's consider the exponential prime representation of 28:</p>

<p>28 = 2<sup>2</sup> * 3<sup>0</sup> * 5<sup>0</sup> * 7<sup>1</sup> * 11<sup>0</sup>...</p>

<p>The product of each exponent plus one is: (2+1)*(0+1)*(0+1)*(1+1)*(0+1)... = 6, and sure enough, 28 has 6 divisors.</p>

<p>Now, consider that the <i>n</i><sup>th</sup> triangular number can be computed in closed form as <i>n</i>(<i>n</i>+1)/2.  We can multiply numbers written in the exponential prime form simply by adding up the exponents at each position.  Dividing by two just means decrementing the exponent on the two's place.</p>

<p>Do you see where I'm going with this?</p>
",5
1280298,1280229,0,"<p>If you solved the problem, you should be able to access <a href=""http://projecteuler.net/index.php?section=forum&amp;id=12"" rel=""nofollow noreferrer"">the thread on Project Euler in which people post their (some very efficient) solutions</a>.</p>

<p>If  you're going to copy and paste a problem, please cite <a href=""http://projecteuler.net/index.php?section=problems&amp;id=12"" rel=""nofollow noreferrer"">the source</a> (unless it was your teacher who stole it); and I second Wouter van Niferick's comment.</p>
",0
1280438,1280229,0,"<p>Compile with care, winner of worst code of the year :D</p>

<pre><code>#include &lt;iostream&gt;

bool isPrime( unsigned long long number ){

    if( number != 2 &amp;&amp; number  % 2 == 0 )
        return false;

    for( int i = 3;
        i &lt; static_cast&lt;unsigned long long&gt;
        ( sqrt(static_cast&lt;double&gt;(number)) + 1 )
        ; i += 2 ){

        if( number % i == 0 )
            return false;
    }

    return true;
}

unsigned int p;
unsigned long long primes[1024];

void initPrimes(){

    primes[0] = 2;
    primes[1] = 3;
    unsigned long long number = 5;

    for( unsigned int i = 2; i &lt; 1024; i++ ){

        while( !isPrime(number) )
            number += 2;

        primes[i] = number;
        number += 2;
    }

    return;
}


unsigned long long nextPrime(){

    unsigned int ret = p;

    p++;

    return primes[ret];
}

unsigned long long numOfDivs( unsigned long long number ){

    p = 0;
    std::vector&lt;unsigned long long&gt; v;
    unsigned long long prime = nextPrime(), divs = 1, i = 0;


    while( number &gt;= prime ){

        i = 0;

        while( number % prime == 0 ){
            number /= prime;
            i++;
        }

        if( i )
            v.push_back( i );

        prime = nextPrime();
    }

    for( unsigned n = 0; n &lt; v.size(); n++ )
        divs *= (v[n] + 1);

    return divs;
}

unsigned long long nextTriNumber(){

    static unsigned long long triNumber = 1, next = 2;

    unsigned long long retTri = triNumber;

    triNumber += next;
    next++;

    return retTri;
}

int main()
{
    initPrimes();

    unsigned long long n = nextTriNumber();
    unsigned long long divs = 500;

    while( numOfDivs(n) &lt;= divs )
    n = nextTriNumber();

    std::cout &lt;&lt; n;

    std::cin.get();
}
</code></pre>
",0
1250794,1250762,0,"<p>Your code doesn't compile as written, but after fixing the ""filename""/""fileName"" problem it seems to me that this particular part does what it is supposed to do. You should consider trying to clarify your question, and to explain what you expected the code to do and how that differs from what it actually does. It really is a bit unclear what you mean by ""not quite executing the functions""!</p>

<p>To test things like these, it is sometimes useful to change a line like</p>

<pre><code>delete_item(sec, third);
</code></pre>

<p>to</p>

<pre><code>cout &lt;&lt; ""delete_item("" &lt;&lt; sec &lt;&lt; "", "" &lt;&lt; third &lt;&lt; "")\n"";
</code></pre>
",1
1251464,1250762,0,"<p>You might want to change</p>

<pre><code>stringstream str(line);
istringstream ins;
ins.str(line);//get line
str &gt;&gt; first &gt;&gt; sec &gt;&gt; third &gt;&gt; fourth;
</code></pre>

<p>into</p>

<pre><code>istringstream ins(line);
ins &gt;&gt; first &gt;&gt; sec &gt;&gt; third &gt;&gt; fourth;
</code></pre>
",1
1402235,939567,0,"<p>The MSVC Windows compiler specific answer.  This is of course specific to the thread the object is in.  It's a pretty bad idea to pass any auto-stack item into any thread other than the one whos stack it is on so I'm not worried about that :)</p>

<p>bool __isOnStack(const void *ptr)<br>
{<br></p>

<ul>
<li><p>// FS:[0x04]     4   Win9x and NT    Top of
stack<br> // FS:[0x08]   4   Win9x and
NT   Current bottom of stack<br>
const char *sTop;<br>   const char
*sBot;<br>
   __asm {<br>
mov EAX, FS:[04h]<br>
         mov [sTop], EAX<br>
         mov EAX, FS:[08h]<br>
         mov [sBot], EAX<br></p>

<p>}<br>
   return( sTop > ((const char *)ptr) &amp;&amp; ((const char *)ptr) > sBot);<br></p></li>
</ul>

<p>}<br></p>
",0
1314539,1314526,4,"<p>AFAIK it's not a term that appears anywhere with an official definition.</p>

<p>Perhaps someone is talking about <a href=""http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern"" rel=""nofollow noreferrer"">simulated dynamic binding</a>?</p>

<p>Edit: a swift web search suggests that someone might have implemented their own dynamic polymorphism, so they perhaps have their own vtables. ""Pseudo-virtual"" functions would then be functions accessed through their mechanism, rather than actually being virtual functions as their C++ compiler understands them.</p>

<p>One reason to do this would be to implement <a href=""http://en.wikipedia.org/wiki/Multiple_dispatch"" rel=""nofollow noreferrer"">multi-dispatch</a>.</p>

<p>Do you have any context you can point us at?</p>
",1
1314540,1314526,0,"<p>A virtual function with a declaration.</p>

<pre><code>class Foo
{
    int* bar;

    Foo() : bar(0) { bar = new int; }
    virtual ~Foo() { delete bar; }
}
</code></pre>

<p>This has a pseudo-virtual destructor, since it does something in the declaration. Here is a pure virtual declaration:</p>

<pre><code>class Foo
{
    Foo() { }
    virtual ~Foo()=0;
}
</code></pre>

<p>At least, this is how I learned it.</p>
",3
1314552,1314526,1,"<p>I have heard the term to used to refer to multimethods (in C++ these are usually implemented using an array of function pointers where the selector offset determined by the code at runtime):</p>

<pre><code>(*multiMethod[ index ])()
</code></pre>

<p>The multiMethod array is just an array of function pointers.</p>
",0
1314559,1314526,2,"<p>I've never heard this term.  I'd guess they're either talking about the <a href=""http://www.gotw.ca/publications/mill18.htm"" rel=""nofollow noreferrer"">Non-Virtual Interface idiom (NVI)</a> or they're talking about building a dispatch table of function pointers which is how one might implement polymorphism/virtual functions in C (and in fact is how C++ compilers do it behind the scenes).</p>
",0
1277661,1277650,10,"<p>How would you construct the vtable? Theoretically you could have an infinite number of versions of your templated member and the compiler wouldn't know what they might be when it creates the vtable.</p>
",5
1277717,1277650,12,"<p>Short answer: Virtual functions are about not knowing who called whom until at run-time, when a function is picked from an already compiled set of candidate functions. Function templates, OTOH, are about creating an arbitrary number of different functions (using types which might not even have been known when the callee was written) at compile-time from the callers' sides. That just doesn't match. </p>

<p>Somewhat longer answer: Virtual functions are implemented using an additional indirection (the Programmer's General All-Purpose Cure), usually implemented as a table of function pointers (the so-called virtual function table, often abbreviated ""vtable""). If you're calling a virtual function, the run-time system will pick the right function from the table. If there were virtual function templates, the run-time system would have to find the address of an already compiled template instance with the exact template parameters. Since the class' designer cannot provide an arbitrary number of function template instances created from an unlimited set of possible arguments, this cannot work. </p>
",0
1278123,1277650,1,"<p>I think it's so that compilers can generate vtable offsets as constants (whereas references to non-virtual functions are fixups).</p>

<p>When you compile a call to a template function, the compiler usually just puts a note in the binary, effectively telling the linker ""please replace this note with a pointer to the correct function"". The static linker does something similar, and eventually the loader fills in the value once the code has been loaded into memory and its address is known. This is called a fixup, because the loader ""fixes up"" the code by filling in the numbers it needs. Note that to generate the fixup, the compiler doesn't need to know what other functions exist in the class, it just needs to know the munged name of the function it wants.</p>

<p>However with virtual functions, the compiler usually emits code saying ""get the vtable pointer out of the object, add 24 to it, load a function address, and call it"". In order to know that the particular virtual function you want is at offset 24, the compiler needs to know about all the virtual functions in the class, and what order they're going to appear in the vtable. As things stand, the compiler does know this, because all the virtual functions are listed right there in the class definition. But in order to generate a virtual call where there are templated virtual functions, the compiler would need to know at the point of the call, what instantiations there are of the function template. It can't possibly know this, because different compilation units might instantiate different versions of a function template. So it couldn't work out what offset to use in the vtable.</p>

<p>Now, I suspect that a compiler could support virtual function templates by emitting, instead of a constant vtable offset, an integer fixup. That is, a note saying ""please fill in the vtable offset of the virtual function with this munged name"". Then the static linker might fill in the actual value once it knows what instantiations are available (at the point where it removes duplicate template instantiations in different compilation units). But that would impose a serious burden of work on the linker to figure out vtable layouts, which currently the compiler does by itself. Templates were deliberately specified to make things easier on implementers, in the hope that they might actually appear in the wild some time before C++0x...</p>

<p>So, I speculate that some reasoning along these lines led the standards committee to conclude that virtual function templates, even if implementable at all, were too difficult to implement and therefore could not be included in the standard.</p>

<p>Note that there's a fair bit of speculation in the above even before I try to read the minds of the committee: I am not the writer of a C++ implementation, and nor do I play one on television.</p>
",0
1278328,1277650,4,"<p>The other answers have already mentionned that virtual functions are usually handled in C++ by having in the object a pointer (the <em>vptr</em>) to a table.  This table (<em>vtable</em>) contains pointer to the functions to use for the virtual members as well as some other things.</p>

<p>The other part of the explanation is that templates are handled in C++ by code expansion.  This allow explicit specialization.</p>

<p>Now, some languages mandate (Eiffel -- I think it is also the case of Java and C#, but my knowledge of them is not good enough to be authoritative) or allow (Ada) an shared handling of genericity, don't have explicit specialization, but would allow virtual template function, putting template in libraries and could reduce the code size.</p>

<p>You can get the effect of shared genericity by using a technique called type erasure.  This is doing manually what compilers for shared genericity language are doing (well, at least some of them, depending on the language, other implementation techniques could be possible).  Here is a (silly) example:</p>

<pre><code>#include &lt;string.h&gt;
#include &lt;iostream&gt;

#ifdef NOT_CPP
class C
{
public:
    virtual template&lt;typename T&gt; int getAnInt(T const&amp; v) {
        return getint(v);
    }
};
#else
class IntGetterBase
{
public:
    virtual int getTheInt() const = 0;
};

template&lt;typename T&gt;
class IntGetter: public IntGetterBase
{
public:
    IntGetter(T const&amp; value) : myValue(value) {}
    virtual int getTheInt() const
    {
        return getint(myValue);
    }
private:
    T const&amp; myValue;
};

template&lt;typename T&gt;
IntGetter&lt;T&gt; makeIntGetter(T const&amp; value)
{
    return IntGetter&lt;T&gt;(value);
}

class C
{
public:
    virtual int getAnInt(IntGetterBase const&amp; v)
    {
        return v.getTheInt();
    }
};
#endif

int getint(double d)
{
    return static_cast&lt;int&gt;(d);
}

int getint(char const* s)
{
    return strlen(s);
}

int main()
{
    C c;
    std::cout &lt;&lt; c.getAnInt(makeIntGetter(3.141)) + c.getAnInt(makeIntGetter(""foo"")) &lt;&lt; '\n';
    return 0;
}
</code></pre>
",0
1972070,1972058,6,"<p>Try the <a href=""http://www.cplusplus.com/reference/clibrary/cmath/fmod/"" rel=""nofollow noreferrer"">fmod</a> function.</p>
",5
1715160,1715143,4,"<p>If all the vectors are ordered then you just scan them each time checking the lowest number until you pass it on one of the other two. if you can't find it, you drop it, each time you check the lowest number you get.</p>

<p>Example:</p>

<p>T1 = first element (v1)
T2 = firest elemnt (v2)
T3 = first element (v3)</p>

<p>find out the loweset one between the 3
if there is no equals - drop it and get the next val, and try again.</p>

<p>if all the vectors has the numbers going up (ordered) you'll find all matches.</p>
",0
1715270,1715143,0,"<p>If the vectors are not ordered and it is not possible to sort them, you can use this (in-efficient) approach:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

typedef std::vector&lt;int&gt; IntVec;
typedef std::vector&lt;IntVec&gt; TwoDIntVec;

IntVec
intvec_union(const TwoDIntVec&amp; vec)
{
  IntVec result;
  size_t vec_size = vec.size();
  if (vec_size &lt; 3) return result;
  const IntVec&amp; vec1 = vec[0];
  size_t sz = vec1.size();
  for (size_t i=0; i&lt;sz; ++i)
    {
      bool found = true;
      int val = vec1[i];
      for (size_t j=1; j&lt;vec_size; ++j)
    {
      const IntVec&amp; v = vec[j];
      if (std::find(v.begin(), v.end(), val) == v.end())
        {
          found = false;
          break;
        }
    }
      if (found) result.push_back(val);
    }
  return result;
}

// test
int
main()
{
  IntVec Vector1, Vector2, Vector3;
  for(int i = 2; i &lt; 7; i++) Vector1.push_back(i); // Vector1 = {2, 3, 4, (5), (6)}
  for(int i = 3; i &lt; 8; i++) Vector2.push_back(i); // Vector2 = {3, 4, (5), (6), 7}
  for(int i = 5; i &lt; 10; i++) Vector3.push_back(i); // Vector3 = {(5), (6), 7, 8, 9}
  TwoDIntVec v;
  v.push_back(Vector1);
  v.push_back(Vector2);
  v.push_back(Vector3);
  IntVec result = intvec_union(v); // result = {5,6}
  return 0;
}
</code></pre>
",0
1715278,1715143,5,"<p>You have <code>set_intersection</code> in the standard algorithms library(vectors must be sorted):</p>

<pre><code>// This code does it for two vectors only

vector&lt;int&gt; a, b, r;

for(int i = 0; i &lt; 10; i++)
{
    a.push_back(i);
    b.push_back(i+5);
}

set_intersection(
    a.begin(), a.end(),
    b.begin(), b.end(),
    back_inserter(r));
</code></pre>
",0
1715298,1715143,2,"<p>For me the fastest solution is to build the set with elements from all vectors. Every time you inserts element that is not unique you increment his counter. Elements with counter equal numbers of vectors should be deleted.</p>

<p>However the simplest implementation is to make map (for most cases I think it is fast enough):</p>

<pre><code>// only pseudo code
map&lt;int,int&gt; elems;
for( vector&lt;int&gt;&amp; v : vectors )
    for( int i : v ) {
        map&lt;int,int&gt;::iterator itr = elems.find(i);
        if( itr == elems.end() )
             elems[i] = 1;
        else itr-&gt;second++;
    }

for( pair&lt;int,int&gt;&amp; p : elems )
    if( p.second == vectors.size() )
       erase_from_vectors( p.first );
</code></pre>

<p>If your vectors are really huge you may build multimap that in value contains vector::iterators. Then you can remove those elements from vectors without looking through them.</p>
",0
1716412,1715143,0,"<p>This seems to work, although it looks ugly:</p>

<pre><code>void intersection(std::vector&lt;std::vector&lt;int&gt;*&gt; valList, std::vector&lt;int&gt;&amp; intersectionList)
{
    if(valList.size() &lt; 2)
    {
        return;
    }

    std::vector&lt;std::vector&lt;int&gt;*&gt;::iterator iter = valList.begin();
    std::vector&lt;std::vector&lt;int&gt;*&gt;::iterator endIter = valList.end();

    for(; iter != endIter; ++iter)
    {
        std::vector&lt;int&gt;* pVec = *iter;
        std::sort(pVec-&gt;begin(), pVec-&gt;end());
    }

    iter = valList.begin();
    endIter = valList.end();

    std::vector&lt;int&gt;* pFirstVec = *iter;
    std::vector&lt;int&gt;* pSecondVec = *(iter + 1);

    iter = iter + 2;

    std::set_intersection(pFirstVec-&gt;begin(), pFirstVec-&gt;end(), pSecondVec-&gt;begin(), pSecondVec-&gt;end(), std::back_inserter(intersectionList));

    for(; iter != endIter; ++iter)
    {
        std::vector&lt;int&gt; temp;
        std::vector&lt;int&gt;* pVec = *iter;

        std::set_intersection(pVec-&gt;begin(), pVec-&gt;end(), intersectionList.begin(), intersectionList.end(), std::back_inserter(temp));

        intersectionList = temp;
        std::sort(intersectionList.begin(), intersectionList.end());
    }


}

int main()
{ 
    std::vector&lt;int&gt; Vector1, Vector2, Vector3, Vector4;
for(int i = 2; i &lt; 7; i++) Vector1.push_back(i); // Vector1 = {2, 3, 4, (5), (6)}
for(int i = 3; i &lt; 8; i++) Vector2.push_back(i); // Vector2 = {3, 4, (5), (6), 7}
for(int i = 5; i &lt; 10; i++) Vector3.push_back(i); // Vector3 = {(5), (6), 7, 8, 9}
for(int i = 6; i &lt; 12; i++) Vector4.push_back(i); // Vector3 = {(6),7,8,9,10,11}

std::vector&lt;int&gt; r;

std::vector&lt;std::vector&lt;int&gt;*&gt; v;
v.push_back(&amp;Vector1);
v.push_back(&amp;Vector2);
v.push_back(&amp;Vector3);
v.push_back(&amp;Vector4);

intersection(v,r);
    return 0;
}
</code></pre>
",0
1717427,1715143,0,"<p>Other answers seems to assume that the vectors are sorted or don't have repeated values (I think gba's answer fails in that case).
This one works in every cases and still try to be efficient. It removes all elements found in every vectors.</p>

<pre><code>template &lt;class C&gt;
struct is_in{
    const C &amp; c_;
    bool b_;
    is_in(C c, bool b = true) : c_(c), b_(b) {}
    bool operator() (typename C::value_type v){
        return b_ == (c_.find(v) != c_.end());
    }
};

int main() {
    set&lt;int&gt; s(v.front().begin(), v.front().end());
    typedef is_in&lt;set&lt;int&gt; &gt; is_in_set;

    vector&lt; vector&lt;int&gt; &gt;::iterator i;
    for(i = v.begin()+1; i != v.end(); ++i) {
        //s is the intersection of every vectors before i
        set&lt;int&gt; new_s;
        //copy in new_s all elements of *i unless they are not in s
        remove_copy_if(i-&gt;begin(), i-&gt;end(), insert_iterator&lt;set&lt;int&gt; &gt;(new_s, new_s.begin()),
                is_in_set(s, false));
        swap(s, new_s);
    }

    for(i = v.begin(); i != v.end(); ++i) {
        //erase all elements of *i which are in s
        i-&gt;erase(remove_if(i-&gt;begin(), i-&gt;end(),
                is_in_set(s)), i-&gt;end());
    }
    vector&lt;int&gt; res_vec(s.begin(), s.end());
}
</code></pre>
",0
1718479,1715143,0,"<p>This approach relies on having sorted input vectors, but after that will only do an linear walk through the current and next vectors to be compared, keeping the matching elements in the first vector. It doesn need to do a full search for each element. The algorithm is reasonably container neutral, requiring only forward iterators so will work with vectors, lists, singly linked lists, raw arrays, etc.</p>

<p>The essential building block for this algorithm is a function that removes elements from a sorted range that aren't in a second sorted range. I'm using the <code>std::remove</code> convention of swapping unwanted elements to the end of the range and returning an iterator pointing to start of the unwanted elements. It's O(n + m).</p>

<pre><code>template&lt;class Input1, class Input2&gt;
Input1 inplace_intersection(Input1 first1, Input1 last1, Input2 first2, Input2 last2)
{
    using std::swap;

    Input1 nextslot(first1);

    for( ; first1 != last1; ++first1 )
    {
        // Skip elements from the second range that are
        // smaller than the current element.
        while( first2 != last2 &amp;&amp; *first2 &lt; *first1 )
            ++first2;

        // Do we have a match? If so keep
        if( first2 != last2 &amp;&amp; !(*first1 &lt; *first2) )
        {
            if( first1 != nextslot )
                swap( *first1, *nextslot );

            ++nextslot;
        }
    }

    return nextslot;
}
</code></pre>

<p>With this building block you can operate on sorted vectors this.</p>

<pre><code>std::vector&lt;int&gt; initial;

// fill...

std::vector&lt;int&gt;::iterator first = initial.begin(), last = initial.end();

last = inplace_intersection( first, last, scnd.begin(), scnd.end() );

last = inplace_intersection( first, last, thrd.begin(), thrd.end() );

// etc...

initial.erase( last, erase.end() );
</code></pre>

<p>If your input vectors aren't sorted, then you can sort them in place if possible, or otherwise create sorted copies.</p>
",0
1577960,1577940,6,"<p>You cannot instantiate objects of the type_info class directly, because the class has only a private copy constructor. Since the list needs copy constructor...</p>

<p>If you really need it, use std::list&lt; type_info*>.</p>

<p>I don't know why you need this list, but I would think to an alternative design, not involving RTTI, if possible.</p>
",5
1578119,1577940,8,"<p>You can't create copies of 'type_info' objects. However, the result if 'typeid' is an Lvalue and the corresponding 'type_info' objects, once obtained, continue to live till the end of the program. For these reasons, you can safely store <em>pointers</em> to 'type_info' objects in your list. </p>
",0
1579958,1577940,1,"<p>From your comment to C?t?lin Piti?' answer, I understand that your goal is to write a function that returns a different ""Style"" type for different ""Page"" types. Does this have to be dynamic? If not, would something like this do what you want?</p>

<pre><code>template&lt;class PageT&gt;
struct StyleOf;

template&lt;&gt;
struct StyleOf&lt;PageA&gt;{
    typedef StyleA type;
};

template&lt;&gt;
struct StyleOf&lt;PageB&gt;{
    typedef StyleB type;
};

// etc...

template&lt;class PageT&gt;
typename StyleOf&lt;PageT&gt;::type
GetStyle(const PageT&amp;){
    return StyleOf&lt;PageT&gt;::type();
}
</code></pre>

<p>Or, with <a href=""http://www.boost.org/doc/libs/1_40_0/libs/mpl/doc/index.html"" rel=""nofollow noreferrer"">Boost.MPL</a>:</p>

<pre><code>using boost::mpl::map;
using boost::mpl::pair;

typedef map&lt;
    pair&lt;PageA, StyleA&gt;,
    pair&lt;PageB, StyleB&gt;,
    //etc.
&gt;
PageToStyle;
</code></pre>

<p>Getting the Style type from the Page type is:</p>

<pre><code>boost::mpl::at&lt;PageToStyle, Page&gt;::type;
</code></pre>
",0
1395509,1395506,181,"<p>It's the destructor, it destroys the instance, frees up memory, etc. etc.</p>

<p>Here's a description from ibm.com:</p>

<p><i>Destructors are usually used to deallocate memory and do other cleanup for a class object and its class members when the object is destroyed. A destructor is called for a class object when that object passes out of scope or is explicitly deleted.</i></p>

<p>See <a href=""https://www.ibm.com/support/knowledgecenter/en/ssw_ibm_i_74/rzarg/cplr380.htm"" rel=""noreferrer"">https://www.ibm.com/support/knowledgecenter/en/ssw_ibm_i_74/rzarg/cplr380.htm</a></p>
",0
1395512,1395506,6,"<p>This is a destructor. It's called when the object is destroyed (out of life scope or deleted).</p>

<p>To be clear, you have to use ~NameOfTheClass like for the constructor, other names are invalid.</p>
",1
1395515,1395506,10,"<p>It's a destructor. The function is guaranteed to be called when the object goes out of scope.</p>
",3
1395522,1395506,1,"<p>That would be the destructor(freeing up any dynamic memory)</p>
",0
1395523,1395506,4,"<p>It's the destructor. This method is called when the instance of your class is destroyed:</p>

<pre><code>Stack&lt;int&gt; *stack= new Stack&lt;int&gt;;
//do something
delete stack; //&lt;- destructor is called here;
</code></pre>
",0
1395600,1395506,92,"<p>As others have noted, in the instance you are asking about it is the destructor for <code>class Stack</code>. </p>

<p>But taking your question exactly as it appears in the title:</p>

<blockquote>
  <p>In c++ what does a tilde ¡°~¡± before a function name signify?</p>
</blockquote>

<p>there is another situation. In any context <em>except</em> immediately before the name of a class (which is the destructor context), <code>~</code> is the one's complement (or bitwise not) operator. To be sure it does not come up very often, but you can imagine a case like</p>

<pre><code>if (~getMask()) { ...
</code></pre>

<p>which looks similar, but has a very different meaning.</p>
",0
1499954,1499884,3,"<p><code>long int</code> isn't going to hold anywhere near 10,000 decimal digits.</p>

<blockquote>
  <p>?9,223,372,036,854,775,808 to +9,223,372,036,854,775,807</p>
</blockquote>
",4
1500006,1499884,4,"<p>Had to google your problem to understand what it was: <a href=""http://www.spoj.pl/problems/MUL/"" rel=""nofollow noreferrer"">here it is</a>, please be considerate of your readers :x</p>

<p>Your code cannot actually work: long int is not long enough (and this is implementation dependent anyway)</p>

<p>You will have to read the integers 'char' by 'char' and roll your own implementation of BigInts which is the difficulty of the problem here I surmise.</p>

<p>Furthermore, you will have to deal with overflow: the result of int x int might not fit into an int. Truth to be told, you should be prepared to have a result that might take up to 20.000 digits</p>
",2
1500037,1499884,0,"<p>It's not surprising that you can find 100s of test cases that your program will pass. </p>

<p>On most 32-bit compilers, <code>long int</code> (also written as <code>long</code>) is a 32-bit number. It can hold around 4 billion unique values (so that's a 10 digit number). So if you've only found 100 test cases that your program passes, you aren't really trying!</p>

<p>Did you try asking your program to multiply 100108810983456785767868356745567566892348745 by 29387345245742687609834756790356568098645?</p>
",4
1534610,1534600,41,"<p>A suffix is unnecessary in C++.  Any floating point value which lacks the 'f' suffix will be typed to the compiler type double by default.</p>

<p>Reference: <a href=""http://en.wikipedia.org/wiki/C_0x"" rel=""noreferrer"">http://en.wikipedia.org/wiki/C_0x</a></p>
",0
1582509,1582372,10,"<p>If I were you, I'd stick with multiplicative-additive operations in the packing/unpacking functions. Something like this</p>

<pre><code>unsigned long RGBA2DWORD(int iR, int iG, int iB, int iA)
{        
  return ((iA * 256 + iR) * 256 + iG) * 256 + iB;
}
</code></pre>

<p>with a symmetrical unpacking function</p>

<pre><code>RGBA DWORD2RGBA(unsigned long dwColor)
{        
  RGBA tmp; /* why did you declare it static??? */

  tmp.B = dwColor % 256; dwColor /= 256;
  tmp.G = dwColor % 256; dwColor /= 256;
  tmp.R = dwColor % 256; dwColor /= 256;
  tmp.A = dwColor % 256; /* dwColor /= 256; */

  return tmp;
}
</code></pre>

<p>Note that there's only one ""magic constant"" in the whole code. </p>

<p>Of course, if you have an external specification that is written in terms of bit patterns in the packed data, a version based on bit and shift opertions might be preferrable. Still</p>

<pre><code>unsigned long RGBA2DWORD(int iR, int iG, int iB, int iA)
{        
  return (((((iA &lt;&lt; 8) + iR) &lt;&lt; 8) + iG) &lt;&lt; 8) + iB;
}

RGBA DWORD2RGBA(unsigned long dwColor)
{        
  RGBA tmp; /* why did you declare it static??? */

  tmp.B = dwColor &amp; 0xFF; dwColor &gt;&gt;= 8;
  tmp.G = dwColor &amp; 0xFF; dwColor &gt;&gt;= 8;
  tmp.R = dwColor &amp; 0xFF; dwColor &gt;&gt;= 8;
  tmp.A = dwColor &amp; 0xFF; /* dwColor &gt;&gt;= 8; */

  return tmp;
}
</code></pre>

<p>has much less ""magic constants"".</p>

<p>Now you can wrap the repetivie actions/subexpressions in macros or, better, inline functions and arrive at very compact and readable packer/unpacker.</p>
",11
1582378,1582372,2,"<p>You can go the other way around like:</p>

<p>iA = rgb >> 24;
iR = (0x00FF0000 &amp; rgb) >> 16;
iG = (0x0000FF00 &amp; rgb) >> 8;
iB = (0x000000FF &amp; rgb);</p>
",6
1582389,1582372,3,"<p>If you don't mind using byte-size integers for RGBA, you can use a union. [<strong>edit</strong> This is a commonly used approach and you are unlikely to find a compiler that doesn't suport it, but strictly speaking (so I'm told) it's an illegal hack. The better approach in most circumstances is to do a mathematical or binary conversion, but I'll leave this half of my answer in place because it may help the reader to understand what people are doing when they see this type of code out in the real world]</p>

<pre>
union RGBA
{
    DWORD dword;
    unsigned char RGBA[4];
    struct RGBAstruct
    {
        unsigned char b;
        unsigned char g;
        unsigned char r;
        unsigned char a;
    }
};
</pre>

<p>Then you can access the green component as:</p>

<pre>
RGBA colour;
int green = (int) colour.RGBA[2];
</pre>

<p>or</p>

<pre>
int green = (int) colour.RGBAstruct.g;
</pre>

<p>and access the DWORD value as</p>

<pre>
DWORD value = colour.dword;
</pre>

<p>If you need the RGBA values to be int values, or wish to use a conversion approach, then you need to use bitwise operators.</p>

<p>You are encoding them <em>almost</em> correctly, but you need to use bitwise OR operator |, not logical OR || operator:</p>

<pre>
DWORD value = (iA &lt;&lt; 24) | (iR &lt;&lt; 16) | (iG &lt;&lt; 8) | iB;
</pre>

<p>To go in the reverse direction:</p>

<pre>
int iA = (value >> 24) & 0xff;
int iR = (value >> 16) & 0xff;
int iG = (value >> 8) & 0xff;
int iB = (value) & 0xff;
</pre>
",9
1898306,1898212,1,"<p>Assuming the binary data in your file is in little-endian order, I would do this the simple way:</p>

<pre><code>vector&lt;unsigned char&gt; a = ...;

std::vector&lt;unsigned short&gt; b;
b.reserve( a.size() / sizeof(unsigned short) );

for( std::vector&lt;unsigned char&gt;::const_iterator i=a.begin(); i!=a.end(); i+=2 )
{
    unsigned short shortValue = *(i+1);
    shortValue &lt;&lt;= 8;
    shortValue |= *i;
    b.push_back( shortValue );
}
</code></pre>

<p>If the data in your file is big-endian you will need to compose the short value the other way round. You should also guard against the number of entries in ""a"" not being a multiple of 2.</p>
",0
1898350,1898212,0,"<p>disclaimer: I don't have a compiler right now:</p>

<pre><code>vector&lt;unsigned char&gt; vec = getVector();
vector&lt;unsigned short&gt; sv(reinterpret_cast&lt;unsigned short*&gt;(&amp;vec[0]), 
                          reinterpret_cast&lt;unsigned short*&gt;(&amp;vec[vec.size()]));
</code></pre>
",4
1898220,1898212,4,"<pre><code>vector&lt;unsigned char&gt; a = ...;
vector&lt;unsigned short&gt; b(a.begin(), a.end());
</code></pre>

<p>But you want <code>valarray</code>s for simple data vectors.</p>
",1
1898390,1898212,6,"<p>If you just want to convert from one type to the other then use the standard constructor. As long as the iterators value type is auto convertible to the destination vectors value type the compiler will do the auto conversion between the two types. Just use the standard constructor</p>

<pre><code>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;

int main()
{
    std::vector&lt;unsigned char&gt;      a;
    a.push_back((unsigned char)12);
    a.push_back((unsigned char)13);
    a.push_back((unsigned char)14);

    std::vector&lt;unsigned short&gt;     b(a.begin(),a.end());

    // Print out the vector
    std::copy(b.begin(),b.end(),std::ostream_iterator&lt;unsigned short&gt;(std::cout,""\t""));
}

&gt; g++ t.cpp
&gt; ./a.out
12  13 14
</code></pre>

<p>If you actually want to convert two bytes into one then some work is required. But it depends if the input data is actually the same endianess as the machine you are on. If you know that it is the same endianess that you just need to cast the input type.</p>

<pre><code>#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;

int main()
{
    std::vector&lt;unsigned char&gt;      a;

    // Make sure that the size is correct.
    // ie. An Odd number indicates that something is not quite correct.
    //
    std::vector&lt;unsigned short&gt;     b(static_cast&lt;unsigned short*&gt;(&amp;a[0]),
                                      static_cast&lt;unsigned short*&gt;(&amp;a[a.size()]));

    // Print out the vector
    std::copy(b.begin(),b.end(),std::ostream_iterator&lt;unsigned short&gt;(std::cout,""\t""));
}
</code></pre>

<p>Alternatively if you actually need to combine two values into a single value where the endianess is not the same as the target architecture, you can write a special iterator. Something like this:</p>

<pre><code>#include &lt;Converter.h&gt;

int main()
{
    std::vector&lt;unsigned char&gt;      a;

    // Make sure that the size is correct.
    // ie. An Odd number indicates that something is not quite correct.
    //
    std::vector&lt;unsigned short&gt;     b(make_Converter(a.begin()),make_Converter(a.end()));

    // Print out the vector
    std::copy(b.begin(),b.end(),std::ostream_iterator&lt;unsigned short&gt;(std::cout,""\t""));
}
</code></pre>

<p>Converter.h</p>

<pre><code>#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;

template&lt;typename I&gt;
struct Converter
{
    I   iterator;

    typedef typename std::input_iterator_tag                    iterator_category;
    typedef typename std::iterator_traits&lt;I&gt;::value_type        value_type;
    typedef typename std::iterator_traits&lt;I&gt;::difference_type   difference_type;
    typedef typename std::iterator_traits&lt;I&gt;::pointer           pointer;
    typedef typename std::iterator_traits&lt;I&gt;::reference         reference;

    Converter(I iter)
        :iterator(iter)
    {}

    Converter&amp; operator++()
    {
        iterator++;
        return *this;
    }

    Converter operator++(int)
    {
        Converter   tmp(*this);
        this-&gt;operator++();

        return (tmp);
    }

    value_type operator*()
    {
        /*
         * The actual calculation done here will depend on the underlying hardware.
         */
        typename std::iterator_traits&lt;I&gt;::value_type val(*iterator);
        val &lt;&lt; 8;
        iterator++;
        val |= (*iterator);

        return val;
    }

    bool operator!=(Converter const&amp; rhs)
    {
        return iterator != rhs.iterator;
    }
};

template&lt;typename I&gt;
Converter&lt;I&gt; make_Converter(I iter)
{
    return Converter&lt;I&gt;(iter);
}
</code></pre>
",0
1898255,1898212,6,"<p>A generic approach (not bullet proof):</p>

<pre><code>#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;

typedef unsigned char u8;
typedef unsigned short u16;

u16 combine_two_bytes(u8 a, u8 b) {
    return a | (b &lt;&lt; 8);
}

template&lt;typename InIter, typename OutIter, typename InT, typename OutT&gt;
void combine_pairs(InIter in, InIter in_end, OutIter out, OutT (*func)(InT, InT)) {
    while(1) {
        if(in == in_end) {
            break;
        }

        InT &amp;left = *in++;

        if(in == in_end) {
            break;
        }

        InT &amp;right = *in++;

        *out++ = func(left, right);
    }
}

int main() {
    using namespace std;    // lazy

    u8 input[] = { 1, 2, 3, 4, 5, 6, 7, 8 };
    const size_t in_size = sizeof(input) / sizeof(*input);
    u16 output[in_size / 2];

    cout &lt;&lt; ""Original: "";
    copy(input, input + in_size, ostream_iterator&lt;int&gt;(cout, "" ""));
    cout &lt;&lt; endl;

    combine_pairs(input, input + in_size, output, combine_two_bytes);

    cout &lt;&lt; ""Transformed: "";
    copy(output, output + in_size / 2, ostream_iterator&lt;int&gt;(cout, "" ""));
    cout &lt;&lt; endl;

    return 0;
}
</code></pre>
",2
1599683,1599382,0,"<p>It maybe doesn't ""worth"", but it is sometimes different.  Consider these functions:</p>

<pre><code>int const* addr_ref    (int const&amp; i)  { return &amp;i; }
int const* addr_byvalue(int const  i)  { return &amp;i; }
</code></pre>

<p>They obviously return different values.  So sometimes it's useful.</p>

<p>In the meantime <em>you should stick to your coding convention</em>.  Most likely compiler's optimization within the function will discard unnecessary dereferences, and in the caller code it was using reference as well, so the performance is hardly an issue here.</p>
",0
1599737,1599382,0,"<p>If the functions are templated you have a harder time making the choice.  Should T be accepted by value or by const reference, when you don't know how big or expensive to copy T is?</p>

<p>In this case I would prefer passing by const reference.  If the size of T is less than or equal to the size of a reference, it's possible for the compiler to perform an optimisation: it simply passes the parameter by value anyway, because a const reference parameter promises not to modify the parameter, so the side effects are the same.  However, the compiler may also choose not to perform this optimisation, especially if it has trouble working out if there are any const_casts involved and such.</p>

<p>But for that reason, I would side with passing by const reference - it's possible, but not certain, that a clever compiler can choose the correct pass method for you, depending on the size of the type and the architecture.</p>
",3
1599391,1599382,6,"<p>Unless you need the ""call by reference"" semantics, i.e. you want to access the actual variable in the callee, you shouldn't use call by reference for simple types.</p>

<p>For a similar, more general discussion see: <a href=""https://stackoverflow.com/questions/1567138/const-t-arg-vs-t-arg"">""const T &amp;arg"" vs. ""T arg""</a></p>
",0
1599392,1599382,6,"<p>Do you also understand <a href=""http://en.wikipedia.org/wiki/Program_optimization#Quotes"" rel=""nofollow noreferrer"">premature optimization</a>? :)</p>

<p>Do what is clearest. If the function is going to return the value, it does not need a reference. A (human!) reader of the code might then wonder why a reference is being used, for no good reason.</p>

<p><strong>UPDATE:</strong> If you want the function to be called <code>increment()</code>, that (to me) implies it should change the passed-in value, and not return it. It sounds like a modify in place kind of operation. Then it might make sense to use a reference (or pointer), and remove the return value:</p>

<pre><code>void increment(int &amp;value)
{
  ++value;
}
</code></pre>

<p>If you're investigating what is <em>fastest</em>, I still think you're optimizing prematurely.</p>
",1
1992282,1991713,0,"<p>In embedded systems and life &amp; mission critical applications, the objective is to reduce the reliance on dynamic memory allocation.  Generally, dynamic memory is needed when the number of instances cannot be determined during run-time.  For example, dynamic memory is used when obtaining input from the user.  </p>

<p>When reading data from sensors and obtaining real-time data from other sources, dynamic memory is not used.  Many applications use a queue and retain only the current data.  </p>

<p>The embedded systems, when using dynamic memory allocation, will have some sort of memory reclamation algorithm, whether it be Garbage Collection (GC) or the memory is consolidated upon allocation.  If there is no memory available, many multi-thread and multi-tasking systems will either force garbage collection, deletion of unnecessary variables or wait for a duration and try the allocation again.</p>

<p>In the event that there is absolutely no available memory (and all efforts to reclaim memory have been exhausted) it is time to refer to the requirements spec and see what it says.</p>
",0
1991721,1991713,8,"<p>If you are writing this sort of software you ought to have a big book for the specification you are conforming to (FAA, NATO, FDA, whatever) of what you can and cannot do, and it will tell you.</p>

<p>In general, however; no, since the systems you describe are very hard to prove correct. Although in life critical software normally there has to be <strong>hardware</strong> responsible to restarting the software if an error condition is signalled (ie, a watchdog timer that the software has to reset evert 100ms to prevent a hardware reset)</p>
",9
1991722,1991713,0,"<p>Better avoid it. The smallest memory leak in your system will with time make your system crash. For example life critical system like car and air plane do not use dynamic allocation. </p>
",3
1991723,1991713,3,"<p>All the trading systems and other banking software I've ever worked on use dynamic allocation very heavily, and they are mission critical for the IBs that use them. I prefer to avoid working on life-critical systems, so can't speak for them.</p>
",0
1991739,1991713,0,"<p>I am new to c++;
but since everything is on memory; you are going to use it somehow.
so; why should a programmer avoid it?</p>

<p>PS:informative comments are appreciated. :)</p>
",3
1991825,1991713,4,"<p>One approach I've used when I can't completely avoid dynamic allocation in ""can't fail"" type applications is to allocate the buffers and other data structures I need only once, when the app first starts -- so they never need to be freed.  It's loops and frees/deletes that don't correspond with news/allocs that tend to cause problems...</p>

<p>When that's not enough, another trick I've used is to run with my own custom version of malloc and free, with code that takes special care to check for common error conditions, like freeing something that's already been freed, regularly verifying freelist pointer integrity, looking to see if total memory use is increasing over time, etc.</p>
",0
1991834,1991713,7,"<p>With critical software you want your system to have as deterministic behaviour as possible. </p>

<p>Dynamic memory, memory fragmentation, possible leaks, and in some corner cases (not too rare) misbehaviour of malloc will make it that much harder to gain 100% determinism.</p>

<p>That said, if part of your program (say an algorithm) requires dynamic allocation and you can <strong>prove</strong> that your memory allocation and de-allocation (free) will be deterministic (see valuable notes by RickNZ) then you're closer to having a deterministic system.</p>
",0
1992423,1991713,0,"<p>I thinks  it will be very hard to write any reasonably large system without dynamic memory allocation.</p>

<p>But the default memory management is a general memory manager with only very limited guarantees.<br>
If you have specific requirements then you should have written a specialized memory management library that conforms to the requirements that you need.</p>
",0
1991908,1991713,0,"<p>I feel you could definitely use dynamic memory allocation in mission critical apps, MC apps, need not necessarily be RT Apps, they just mean they are critical for business functioning. When dynamic memory allocation constructs are used, it always essential to have large stress tests, which can display memory leaks, when real customer environment is simulated, that way you would understand the impact of dynamic memory allocation, is it had one.</p>
",0
1307564,1307547,8,"<p>As you've said, pointer addresses may change when casting between virtual classes with multiple inheritance. However, in your case the static type is always the same: <code>ISink</code> so comparing two points of this static type is guaranteed to be safe, and yield reproducible results.</p>
",0
1307753,1307547,2,"<p>Offset adjustments are made in case of multiple inheritances. IFAIK, they must lead to pointers comparing equal and sortable with std::less&lt;> excepted if your object inherit several times from ISink while ISink is not a virtual base class in all cases.</p>
",0
1308418,1307547,1,"<p>In case of multiple inheritance the meaning of ""same object"" sometimes is not obvious.
For example, if ISink is present twice in the list of base classes and wasn't inherited with ""virtual"", such situation is possible:</p>

<pre><code>class A {};
class B:public A {};
class C:public A {};
class D:public B,public C {};
...
void f(A *a);
...
{
    D d;
    f(static_cast&lt;B*&gt;(&amp;d));
    f(static_cast&lt;C*&gt;(&amp;d));
}
</code></pre>

<p>In this case f will get two different addresses.
Whether is's same object or not probably depends on context.
If you want to treat them as the same object, dynamic_casting to void* may help - it castes to most derived class (something virtual in A is needed, of course)</p>
",0
1204538,1204521,15,"<p>Technically, this isn't part of C++. You can do variable length arrays in C99 (ISO/IEC 9899:1999) but they are not part of C++. As you've discovered, they are supported as an extension by some compilers.</p>
",0
1204544,1204521,15,"<p>G++ supports a C99 feature that allows dynamically sized arrays. It is not standard C++. G++ has the <code>-ansi</code> option that turns off some features that aren't in C++, but this isn't one of them. To make G++ reject that code, use the <code>-pedantic</code> option:</p>

<pre>
$ <b>g++ -pedantic junk.cpp</b>
junk.cpp: In function ¡®int main()¡¯:
junk.cpp:4: error: ISO C++ forbids variable-size array ¡®pz¡¯
</pre>
",0
1204547,1204521,10,"<p>If you want a dynamic array on the stack:</p>

<pre><code>void dynArray(int x)
{
    int *array = (int *)alloca(sizeof(*array)*x);

    // blah blah blah..
}
</code></pre>
",1
1204552,1204521,2,"<p>Practically speaking, if you want to make a dynamic array you should use std::vector, as in:</p>

<pre>
#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;vector&gt;

int main(int argc, char* argv[])
{
   int size;
   std::cin>>size;
   std::vector&lt;int&gt; array(size);
   // do stuff with array ...
   return 0; 
}
</pre>

<p>If you are just curious about the syntax, then what you are looking for is:</p>

<pre>
//...
int* array = new int[size];
// Do stuff with array ...
delete [] array;
//...
</pre>

<p>Neither of these are allocated with local storage. A dynamically sized array that is automatically allocated using local storage is not currently supported in standard C++, but is supported in the current C standard.</p>
",7
1204639,1204521,23,"<p>Here's your combination answer of all these other ones:</p>

<p>Your code right now is <strong>not</strong> standard C++. It <strong>is</strong> standard C99. This is because C99 allows you to declare arrays dynamically that way. To clarify, this is also standard C99:</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    int x = 0;

    scanf(""%d"", &amp;x);

    char pz[x]; 
}
</code></pre>

<p>This is <strong>not</strong> standard anything:</p>

<pre><code>#include &lt;iostream&gt;

int main()
{
    int x = 0;
    std::cin &gt;&gt; x;
    char pz[x]; 
}
</code></pre>

<p>It cannot be standard C++ because that required constant array sizes, and it cannot be standard C because C does not have <code>std::cin</code> (or namespaces, or classes, etc...)</p>

<p>To make it standard C++, do this:</p>

<pre><code>int main()
{
    const int x = 12; // x is 12 now and forever...
    char pz[x]; // ...therefore it can be used here
}
</code></pre>

<p>If you want a dynamic array, you <em>can</em> do this:</p>

<pre><code>#include &lt;iostream&gt;

int main()
{
    int x = 0;
    std::cin &gt;&gt; x;

    char *pz = new char[x];

    delete [] pz;
}
</code></pre>

<p>But you should do this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

int main()
{
    int x = 0;
    std::cin &gt;&gt; x;

    std::vector&lt;char&gt; pz(x);
}
</code></pre>
",0
1204725,1204521,7,"<p>Allocating arrays with variable length on the stack is a good idea, because it fast and doesn't fragment the memory. But C++ Standard unfortunately doesn't support it. You could do this by using template wrapper to <code>alloca</code> function. But using <code>alloca</code> is not really a standard conforming.</p>

<p>Standard way is to use std::vector with <strong>custom allocator</strong> if you want to avoid memory fragmentation and speedup memory allocations. Take a look on <a href=""http://www.boost.org/doc/libs/1_39_0/libs/pool/doc/index.html"" rel=""noreferrer"">boost::pool_alloc</a> for a good sample of fast allocator.</p>
",0
1578213,1578162,1,"<p>If you have input that is larger than unsigned long long, then they probably want you to implement custom functions for arbitrary-precision arithmetic (or the problem can be solved without using the large integers). If the input fits the largest native integer type, but your algorithm requires larger integer, it's most likely time to think about a different algorithm. :)</p>
",2
1578247,1578162,3,"<p>Does a line like this not concern you?</p>

<pre><code>b[c][0]='Y';b[c][1]='E';b[c][2]='S';b[c][3]='\0';
</code></pre>

<p>Would it not be simpler to write??</p>

<pre><code>strcpy(b[c], ""YES"");
</code></pre>
",8
1578251,1578162,3,"<p>You can do this question without summing all the candies.  Just calculate the remainder off each child's heap (which will be smaller than N).  This way, the number won't grow too large and overflow.</p>

<p>I won't write out a solution since this is a contest problem, but if you're stuck I can give some more hints.</p>
",0
1578265,1578162,4,"<p>Easy. Don't add up the number of candies. Instead, keep a count of kids, a count of candies per kid. (<code>CCK</code>), and a count of extra candies (<code>CEC</code>. When you read a new line, <code>CK += 1; CEC += newCandies; if (CEC &gt; CK) CCK += (CEC / CK); CEC %= CK;</code> </p>
",4
1578274,1578162,0,"<p>If you're reading in from cin, you can only read in values that will fit into some sort of integer variable.  It's possible that the sum would overflow.</p>

<p>However, you don't have to add the numbers up.  You can add the remainders (from dividing by N) up, and then see if the sum of the remainders is N.</p>
",0
1782081,1782035,0,"<p>I'm not sure what the standard says about this, but I don't see why it shouldn't work. It compiles fine on my gcc. Did you remember to instantiate the static object outside of the class declaration?</p>
",1
1782082,1782035,3,"<p>The following little program compiles and links using GCC 3.4.5 (MinGW):</p>

<pre><code>class Thing
{
public:
    Thing();
private:
    static const Thing THING;
};

Thing::Thing()
{}

// We must instantiate the static variable somewhere, like inside 'Thing.cpp'
const Thing Thing::THING = Thing();

int main(int argc, char* argv[])
{   
  return 0;
}
</code></pre>
",0
1782341,1782035,0,"<p>No. You can't.<br>
As S.C.Madsen and int3 already posted, you can declare static const in class scope for any type, as long as it is properly defined (in the cpp file) and initialized, But it can't be a compile time constant.<br>
Compile time constant is a constant you can use as template argument and as built in arrays' size. These constants may also be optimized better than run-time constants. Currently, AFAIK, only the built in numeric types may serve as compile time constants.<br>
The reason, BTW, is that this constant should be evaluated at compile time (similarly to literals).</p>
",0
1530542,1530531,4,"<p>Either you don't include necessary header files (<code>queue</code> and <code>utility</code>), or don't have <code>using namespace std</code> or both.</p>

<p>To overcome the first problem include the headers. To overcome the second one either add <code>using</code> or provide fully qualified names (<code>std::queue</code> and <code>std::pair</code>).</p>
",1
1527910,1527849,13,"<p>A dependent name is essentially a name that depends on a template argument.</p>

<p>When using templates there is a distinction between the point of definition of the template and the point of instantiation i.e. where you actually use the template. Names that depend on a template don't get bound until the point of instantiation whereas names that don't get bound at the point of definition.</p>

<p>A simple example would be:</p>

<pre><code>template&lt; class T &gt; int addInt( T x )
{
    return i + x.toInt();
}
</code></pre>

<p>where a declaration or definition of <code>i</code> would need to appear <em>before</em> the definition given above since <code>i</code> does not depend on the template argument <code>T</code> and is therefore bound at the point of definition. The definition of the <code>toInt</code> member of the as-yet-unknown-type <code>x</code> variable only has to appear before the <code>addInt</code> function is actually used somewhere as it is a dependent name ( technically the point of instantiation is taken as the nearest enclosing global or namespace scope just before the point of use and so it has to be available before that ).</p>
",5
1528010,1527849,19,"<p>Dependent names are characterized by a <strong>dependency</strong> on a template argument. Trivial example:</p>

<pre><code>#include &lt;vector&gt;

void NonDependent()
{
  //You can access the member size_type directly.
  //This is precisely specified as a vector of ints.

  typedef std::vector&lt;int&gt; IntVector;  
  IntVector::size_type i;

  /* ... */
}

template &lt;class T&gt;
void Dependent()
{

  //Now the vector depends on the type T. 
  //Need to use typename to access a dependent name.

  typedef std::vector&lt;T&gt; SomeVector;
  typename SomeVector::size_type i;

  /* ... */
}

int main()
{
  NonDependent();
  Dependent&lt;int&gt;();
  return 0;
}
</code></pre>

<p><strong>EDIT</strong>: As I mentioned in the comment below, this is an example of a peculiar situation regarding the use of dependent names which appears quite frequently. Sometimes the rules governing the use of dependent names are not what one might instinctively expect.</p>

<p>For instance, if you have a dependent class which derives from a depenent base, but within an scope in which a name from the base class apparently doesn't depent on the template, you might get a compiler error just like below.</p>

<pre><code>#include &lt;iostream&gt;

template &lt;class T&gt;
class Dependent
{
protected:
  T data;
};

template &lt;class T&gt;
class OtherDependent : public Dependent&lt;T&gt;
{
public:
  void printT()const
  { 
    std::cout &lt;&lt; ""T: "" &lt;&lt; data &lt;&lt; std::endl; //ERROR
  }
};

int main()
{
  OtherDependent&lt;int&gt; o;
  o.printT();
  return 0;
}
</code></pre>

<p>This error happens because the compiler will not lookup name <code>data</code> inside the base class template since it doesn't dependent on <code>T</code> and, consequently, it is not a depedent name. The ways to fix are using <code>this</code> or explicitly telling the dependent base class template:</p>

<pre><code>std::cout &lt;&lt; ""T: "" &lt;&lt; this-&gt;data &lt;&lt; std::endl; //Ok now.
std::cout &lt;&lt; ""T: "" &lt;&lt; Dependent&lt;T&gt;::data &lt;&lt; std::endl; //Ok now.
</code></pre>

<p>or placing <code>using</code> declaration:</p>

<pre><code>template &lt;class T&gt;
class OtherDependent : public Dependent&lt;T&gt;
{
    using Dependent&lt;T&gt;::data; //Ok now.
    ....
};
</code></pre>
",6
1310751,1310722,1,"<p><a href=""http://jonripley.com/windows/Software/bin2h/"" rel=""nofollow noreferrer"">http://jonripley.com/windows/Software/bin2h/</a></p>

<p><a href=""http://www.koders.com/python/fid7D3C25FE9FDE363F1574AFFB20DB0C0F1532BAE3.aspx?s=md5"" rel=""nofollow noreferrer"">http://www.koders.com/python/</a></p>

<p>or google ""bin2h"" for others.</p>
",2
1424535,1424510,72,"<p>There is no enlightened answer, it's just because it's not defined as valid syntax by the C++ language...  So it is so, by definition of the language.</p>

<p>If you do have an expression within then it is valid.  For example:</p>

<pre><code> ((0));//compiles
</code></pre>

<p>Even simpler put: because <code>(x)</code> is a valid C++ expression, while <code>()</code> is not. </p>

<p>To learn more about how languages are defined, and how compilers work, you should learn about <a href=""http://en.wikipedia.org/wiki/Formal_language_theory"" rel=""noreferrer"">Formal language theory</a> or more specifically <a href=""http://en.wikipedia.org/wiki/Context-free_grammar"" rel=""noreferrer"">Context Free Grammars (CFG)</a> and related material like finite state machines.  If you are interested in that though the wikipedia pages won't be enough, you'll have to get a book.</p>
",2
1424559,1424510,6,"<p>The innermost parens in your example would be an expression, and in C++ the grammar defines an <code>expression</code> to be an <code>assignment-expression</code> or another <code>expression</code> followed by a comma and another <code>assignment-expression</code> (Appendix A.4 - Grammar summary/Expressions).</p>

<p>The grammar further defines an <code>assignment-expression</code> as one of several other types of expression, none of which can be nothing (or only whitespace).</p>

<p>So the reason you can't have <code>A a(())</code> is simply because the grammar doesn't allow it.  However, I can't answer why the people who created C++ didn't allow this particular use of empty parens as some sort of special-case - I'd guess that they'd rather not put in such a special case if there was a reasonable alternative.</p>
",0
1537289,1537271,0,"<p>You don't, you only need the non const version in this example</p>
",3
1537292,1537271,4,"<p>The difference between the two functions is that an <code>element()</code> of a non-const vector is itself non-const, but if the entire vector is const, then each <code>element()</code> is also const.</p>

<p>i.e.</p>

<pre><code>int main() {
   std::vector&lt;A&gt; const cva = foo();
   ARef_t ar;
   A const&amp; a = element(ar, cva);
}
</code></pre>
",0
1537365,1537271,1,"<p>If you hold a const vector you can read the element values, but not change them.
If you hold a non-const vector, then you can actually change the element values.
In both cases you call the same function <em>name</em>, but a different function is invoked because of the overloading on const.</p>

<p>operator[] on the vector itself is implemented this way too.</p>

<p>In effect the non-const ""getter"" also acts as a ""setter""</p>
",0
1539266,1537271,0,"<p>Both function returns the element of respective vector sticking the behaviour of the elements of the vector.</p>

<p>i.e. if vector is const ==> its all elements are const ==> one cant't modify  its element and for that function with const return type and const argument is defined.
so it wont allow to modify the element of vector.</p>

<p>Exactly opposite is for non-const vector.One can modify the element of vector using its reference.</p>
",0
1299810,1299691,12,"<p>No.  12.8/9 says that the assignment operator for class X must be non-static, non-template with a parameter of type X, X&amp;, X const&amp;, X volatile&amp; or X const volatile&amp;.  And there is a note which emphasizes that the instantiation of a template doesn't suppress the implicit declaration.</p>
",3
1299779,1299691,4,"<p>Since <code>A&amp; operator=( B&amp; )</code> has not the signature of <code>A&amp; operator=( const A&amp; )</code>, this does nothing to the synthesized assignement operator.</p>

<p>Take a look at <a href=""http://codepad.org/C31MQd8q"" rel=""nofollow noreferrer"">this snippet at codepad.org</a> - as far as an example counts as proof.</p>

<p>Test driving Comeau with it also shows that <code>A&amp; operator=( const A&amp; )</code> is synthesized.</p>
",1
1783366,1783350,11,"<p>A copy constructor <em>might not</em> be invoked when you return <em>by value</em>. Some compilers use return value optimization feature.</p>

<blockquote>
  <p>Read about ""<strong>Return Value Optimization</strong>""</p>
</blockquote>
",6
1783390,1783350,2,"<p>When doing x = funct(); the compiler notices that it will be directly returned and thus avoids a useless construction. That's also why you will only get two destructor calls.</p>

<p>This is a example why sometimes working with ""copy"" isn't necessarily a lost of performances.</p>
",1
1783436,1783350,0,"<p>In your exampe the structure is small enough therefore it is passed through a register. The generated code is similar to <a href=""http://en.wikipedia.org/wiki/Return_value_optimization"" rel=""nofollow noreferrer"">Return value optimization</a>. Construct a more complicated example, and you'll see the behavior expected.</p>
",0
1783741,1783350,4,"<p>The part of the standard which tells you when compilers may elide copies is 12.8/15. It's always up to the compiler whether to do actually perform the elision. There are two legal situations, plus any combination of them:</p>

<ul>
<li><p>""in a return statement in a function with a class return type, when the expression is the name of a non-volatile automatic object with the same cv-unqualified type as the function return type""</p></li>
<li><p>""when a temporary class object that has not been bound to a reference would be copied to a class object with the same cv-unqualified type"".</p></li>
</ul>

<p>The former is usually referred to as the ""named return value optimization"", and it's what permits the output you're seeing in your example. The latter in effect turns copy-initialization into direct initialization, and could occur for instance if your code did <code>Example x = Example();</code>.</p>

<p>Other copy elisions are not permitted, except of course that the usual ""as-if"" rules apply. So if the copy constructor has tracing in, then the following code <em>must</em> call it:</p>

<pre><code>Example x;
Example y = x;
</code></pre>

<p>But if x were otherwise unused, and the cctor had no side-effects, then I think it could be optimized away, just like any other code that does nothing.</p>
",0
1985184,1783350,0,"<p>g++ v4.4.1 has an option to suppress ""elide"" optimizations:</p>

<pre>

tst@u32-karmic$  g++ <b>-fno-elide-constructors</b> Example.cpp -o Example

tst@u32-karmic$  ./Example 

Default constructor called.
Calling funct..
Default constructor called.

<b>Copy constructor called.</b>

Dtor invoked
Assignment operator called.

Dtor invoked

Dtor invoked
</pre>

<p>As you can see the copy constructor is now called!</p>
",0
723185,693652,0,"<p>I just wanted to add that when you use void after the parameters like function():void it is used to indicate that the function does not return a value.</p>
",0
693688,693652,9,"<p>A long time ago you did something like this in C (my pre-ISO C is rusty :) ):</p>

<pre><code>void foo(a, b)
   int a, 
   int b
{
}
</code></pre>

<p>while C++ was being created the name mangling required the types of the arguments, so for C++ it was changed to:</p>

<pre><code>void foo(int a, int b)
{
}
</code></pre>

<p>and this change was brought forward to C.</p>

<p>At this point, I believe to avoid breaking existing C code this:</p>

<pre><code>void foo() 
</code></pre>

<p>and this:</p>

<pre><code>void foo(void)
</code></pre>

<p>meant two very different things, <code>()</code> means <em>do not check for the argument number or type</em>, and <code>(void)</code> means <em>takes no arguments</em>.  For C++ <code>()</code> meaning <em>not to check anything</em> was not going to work so <code>()</code> and <code>(void)</code> mean the same thing in C++.</p>

<p>So, for C++ <code>()</code> and <code>(void)</code> were always the same thing.</p>

<p>At least that is how I remember it... :-)</p>
",0
693656,693652,0,"<p>afaik if you pass void into the constructor or any function as the argument it means that the function dosnt take any argument so example a and b are equal. but i am not sure if any of them change the function signature in any way or make it run faster etc.</p>
",0
693657,693652,43,"<p>The two are same, at least in C++. In C, providing an empty pair of parentheses typically means an unspecified parameter list (as opposed to an empty parameter list). C++ does not have this problem.</p>

<p><strong><em>How can a correct answer get downvoted so many times? Yet another SO bug?</em></strong></p>
",5
1506978,1506727,0,"<p>The expression</p>

<pre><code>AMethod()
</code></pre>

<p>creates and returns a class object, and the expression</p>

<pre><code>AMethod() = YourClass();
</code></pre>

<p>creates and assigns a second class object to the first object.</p>
",1
1506773,1506727,3,"<p><strong>EDIT1:</strong> I think I miss understood the question first time.</p>

<p>The standard says:
3.10 Lvalues and rvalues</p>

<blockquote>
  <p>The result of calling a function that
  does not return a reference is an
  rvalue. User defined operators are
  functions, and whether such operators
  expect or yield lvalues is determined
  by their parameter and return types.</p>
</blockquote>

<p>The standard says nothing in this paragraph, except that user-defined types and primitive types are the same. If the return of a function is not a reference, then it is not an l-value. There is however an interesting commentary on the same page:</p>

<blockquote>
  <p>47) Expressions such as invocations of
  constructors and of functions that
  return a class type refer to objects,
  and the implementation can invoke a
  member function upon such objects, but
  the expressions are not lvalues.</p>
</blockquote>

<p>So basically in your example:</p>

<pre><code>AMethod() = YourClass();
</code></pre>

<p>AMethod returns a user-defined type on which the function:</p>

<pre><code>AMethod().operator=(YourClass());
</code></pre>

<p>is executed. Still, it is not an l-value. In fact, you could have empty statements in C++, or statement that consist of an r-value only!:</p>

<pre><code>5;;; // correct C++ code!
</code></pre>

<hr>

<p><strong>EDIT2:</strong></p>

<p>Consider this example:</p>

<pre><code>if( &amp;(YourClass() + YourClass()) == &amp;YourClass() )
{
....
}
</code></pre>

<p>The expression <code>&amp;(YourClass() + YourClass())</code> must yield an l-value so the whole expression becomes correct. It compiles fine on VC but it gives this little warning:</p>

<pre><code>warning C4238: nonstandard extension used : class rvalue used as lvalue
</code></pre>

<p>Obviously the above line was wrong by C++ standards but VC just allows it!</p>

<hr>

<p>Because you asked it so. First, a fresh instance of <code>YourClass</code> is returned by <code>AMethod</code>. Then, it is assigned another fresh instance. Of course in C++ you can say what ever you want. So, to prevent the assignment statement, just return <code>const YourClass</code>. In this case, the object becomes ""<strong>readable</strong>"" only:</p>

<pre><code>const YourClass AMethod(){ return YourClass();}
</code></pre>

<p>This is the same in case you are overloading binary operators. For example, if you overload <code>operator+</code> for a class, then you can do with <code>const</code> or without it.</p>

<pre><code>// '+' operator is defined as a friend operator not a member.
friend YourClass operator+(const YourClass&amp; lhs, const YourClass&amp; rhs)
{
...
}
</code></pre>

<p>If you did it that way, you could have meaningless statement like the following:</p>

<pre><code>(a + b) = c;
</code></pre>

<p>Where the expression <code>(a + b)</code> is not useful because it represents only a value, not a variable we control, it produces a temp variable.</p>
",6
1506893,1506727,2,"<p><code>AMethod</code> returns an <em>rvalue</em>. In C++ you can call member functions, even modifying member functions, on an rvalue of <em>user-defined type</em>. And sometimes this is just what you want. </p>

<pre><code>os.get_disk_accessor(0).wipe(); // wipe() might not be a const member function
</code></pre>

<p>However, you can not invoke operations on rvalues of <em>built-in</em> types: </p>

<pre><code>int f();
f() = 5; // won't compile
++f();   // won't either
</code></pre>
",0
1509117,1506727,0,"<p>I think that 1'st version compiled because YourClass have a default constructor, destructor, copy constructor and <strong><em>assignment operator</em></strong> which called AMethod() = YourClass();.
int AMethod(){ return a;}
AMethod() = 5;
This code doesn't compile because there is not a rvalue.</p>
",0
1793293,1793257,9,"<p>Trying to give homework-friendly advice:</p>

<p>1) <a href=""http://easycalculation.com/statistics/learn-median.php"" rel=""nofollow noreferrer"">Make sure you know how to get a Median</a>.  Can you, in your head or on paper, figure it out?  Now, how do you write a program to do this for you?  <a href=""http://en.wikipedia.org/wiki/Flowchart"" rel=""nofollow noreferrer"">Make a flowchart</a>.</p>

<p>2) Write the program to do it.  A user gives your program 5 numbers, your program gives the median as an answer.</p>

<p>3) Make the program better. An even amount of numbers changes the method to get a median.  Change your program so that it will allow 6 numbers.</p>

<p>3b)  Make your program accept any amount of numbers.  (I added this, not in your post or in your book but should be super-easy to do if you've already done 2 and 3).</p>
",1
1793310,1793257,4,"<blockquote>
  <p>Can anyone explain it to me?</p>
</blockquote>

<ol>
<li><p>""Formulate the steps"" means, ""explain how to do it"". For example, imagine that you're explaining to me how to solve the problem, that I don't need to use a computer (that I'm trying to do it with pencil and paper), and that I don't know what a ""median"" is.</p></li>
<li><p>""Develop an application"" means, ""write software"". The software will need to: a) get five numbers from the user (and, possibly, ensure that the numbers are ""unique""); b) find the ""median"" (using the steps you've previously formulated in step 1); c) show (output) the median which it found.</p></li>
<li><p>You'll need to define what ""median"" means when there's an even number of inputs, and alter your program accordingly.</p></li>
</ol>
",0
1793341,1793257,2,"<p>I know no one asked for an answer using STL, but it could be useful for someone coming here later.</p>

<p>In C++ with STL there is a function called <code>nth_element</code>, which takes three arguments. It will sort a container just enough to get nth element in the right spot.</p>

<p>An example:</p>

<pre><code>int numbers[] = { 5, 4, 2, 1, 10 };
std::nth_element(numbers, numbers+2, numbers+5);
std::cout &lt;&lt; numbers[2] &lt;&lt; ""\n"";
</code></pre>
",5
1696963,1696949,0,"<p>You can use <code>typeid</code> to determine the derived class:</p>

<pre><code>struct Base
{
 virtual ~Base() {} 
};

struct Derived : public Base { };

int main()
{
 Base* b = new Derived();
 std::cout &lt;&lt; typeid(*b).name() &lt;&lt; std::endl;
}
</code></pre>

<p>This outputs: ""Derived"".</p>

<p>But, usually with polymorphism the point is that you shouldn't be concerned with this.  You simply call a base-class member function and the proper derived-class member function is called at runtime.</p>
",3
1696976,1696949,3,"<p>The purpose of inheritance / polymorphism is so you don't need to care which derived type you are dealing with.</p>

<p>In particular I think storing data, such as make of car, country of origin etc, encoded in a class hierarchy doesn't seem to be particularly beneficial. Does an AmericanCar do something fundamentally different from, say, a Japanese car (other than consuming more fuel, which again can be better stored in a data member)?</p>
",0
1696977,1696949,4,"<p>Well, what are you trying to do with it? Get the name or cost? You would have something like:</p>

<pre><code>class Car
{
public:
    virtual ~Car(void) {}

    virtual std::string location(void) const = 0;
    virtual std::string name(void) const = 0;
    virtual double cost(void) const = 0;
}

class AmericanCar
{
public:
    virtual ~AmericanCar(void) {}

    virtual std::string location(void) const
    {
        return ""America"";
    }
}

class Buick : public AmericanCar
{
public:
    virtual std::string name(void) const
    {
        return ""Buick"";
    }

    virtual double cost(void) const
    {
        return /* ... */;
    }
}

class Ford : public AmericanCar
{
public:
    virtual std::string name(void) const
    {
        return ""Ford"";
    }

    virtual double cost(void) const
    {
        return /* ... */;
    }
}
</code></pre>

<p>Now you can call these methods polymorphically.</p>

<p>This is somewhat strange, though. You don't need a different class to store names and cost like this:</p>

<pre><code>class Car
{
public:
    Car(const std::string&amp; pLocation,
        const std::string&amp; pName,
        double pCost) :
    mLocation(pLocation),
    mName(pName),
    mCost(pCost)
    {
    }

    const std::string&amp; location(void) const
    {
        return mLocation;
    }

    void location(const std::string&amp; pLocation)
    {
        mLocation = pLocation;
    }

    const std::string&amp; name(void) const
    {
        return mName;
    }

    void name(const std::string&amp; pName)
    {
        mName = pName;
    }

    const double cost(void) const
    {
        return mCost;
    }

    void cost(double pCost)
    {
        mCost = pCost;
    }

private:
    std::string mLocation;
    std::string mName;
    double mCost;
}

// make cars
std::vector&lt;Car&gt; cars;
cars.push_back(Car(""America"", ""Buick"", /* ... */));
</code></pre>
",0
1696980,1696949,0,"<p>Why do you need to know the derived class? Normally you would have virtual functions to take care of any behavior differences between the two derived classes.</p>

<p>The goal is that the code using the parent class shouldn't have to know the exact class it's working with. </p>
",0
1609385,1609372,20,"<p>You've describe a type called ""p"" which is a struct. There is yet no thing of type p around. Therefore your </p>

<pre><code>p-&gt;...
</code></pre>

<p>calls make no sense.</p>

<p>Try declaring</p>

<pre><code>p pInstance;
</code></pre>

<p>in your class and using it, ie:</p>

<pre><code>void setme()
{
    this-&gt;pInstance.grade=99;
    this-&gt;pInstance.name[25]='g';  //here is the problem
}
</code></pre>

<p>Note even with this your assignment to name[25] will fail as the allowed indices for that array are 0 up to 24 (totalling 25 elements).</p>
",0
1609388,1609372,6,"<p>isn't it  </p>

<pre><code>struct { ... } p; // variable of struct-type definition.
</code></pre>

<p>not  </p>

<pre><code>struct p { ... }; // type 'struct p' definition.
</code></pre>

<p>?</p>
",0
1609404,1609372,4,"<p>Place the struct definition outside of the class using a typedef.  By having the struct defined in your .cpp file it will not be visible outside of your class.</p>

<pre><code>#include &lt;iostream&gt;
typedef struct _foo
{
    int a;
} foo;

class bar
{
public:
  void setA(int newa);
  int getA();
private:
    foo myfoo;
};

void bar::setA(int newa)
{
   myfoo.a = newa;
}

int bar::getA()
{
   return myfoo.a;
}

using namespace std;
int main()
{
  bar mybar;
  mybar.setA(17);
  cout &lt;&lt; mybar.getA() &lt;&lt; endl;
  return 0;
}
</code></pre>
",0
1609406,1609372,14,"<p>You have two serious problems here</p>

<pre><code>struct p
{
char name[25];
int grade;
};
</code></pre>

<p>This defines a struct <strong>type</strong>, named p. I think what you wanted to do was</p>

<pre><code>struct
{
char name[25];
int grade;
} p;
</code></pre>

<p>This will declare a <strong>struct</strong>, named p, with the name and grade member variables.</p>

<p>Your second serious problem is that you assign:</p>

<pre><code>this-&gt;p::name[25]='g';  //here is the problem
</code></pre>

<p>This assigns 'g' to the 26th element of the array name. (arrays are 0-indexed)</p>
",0
1907233,1881200,2,"<p>You are safe unless the client object has two derivations of ostream without using virtual inheritance.</p>

<p>In short, that is the fault of the user -- they should not be multiply inheriting an interface class twice in two different ways.</p>

<p>Use the address and be done with it. In these cases, I take a pointer argument rather than a reference to make it explicit that I will store the address. It also prevents implicit conversions that might kick in if you decided to take a const reference.</p>

<pre><code>   class Log {
   public:
       void AddSink( ostream* Sink );
       void RemoveSink( ostream* Sink );
   };
</code></pre>

<p>You can create an RAII object that calls AddSink in the constructor, and RemoveSink in the destructor to make this pattern exception-safe.</p>
",0
1907307,1881200,0,"<p>In your previous question, <a href=""https://stackoverflow.com/questions/1307547/determine-object-identity-from-a-reference-to-a-superclass/1307564#1307564"">Konrad Rudolph posted an answe</a>r (that you did not accept but has the highest score), saying that everything should be fine if you use base class pointers, which you appear to do.</p>
",0
1482916,1482908,18,"<p><a href=""http://www.parashift.com/c++-faq-lite/exceptions.html#faq-17.3"" rel=""noreferrer"">The C++ rule is that you must never throw an exception from a destructor that is being called during the ""stack unwinding"" process of another exception.</a></p>

<p>You throw an exception in <code>A</code>'s destructor, which is something you are not supposed to do.</p>
",7
1482933,1482908,0,"<p>In section 15.2 of my draft standard it states:</p>

<blockquote>
  <p>3 The process of calling destructors
  for automatic objects constructed on
  the path from a try block to a
  throw-expression is called ¡°stack
  unwinding.¡± [ Note: If a destructor
  called during stack unwinding exits
  with an exception, std::terminate is
  called (15.5.1). So destructors should
  generally catch exceptions and not let
  them propagate out of the destructor.
  ¡ªend note ]</p>
</blockquote>

<p>They have defined <em>""stack unwinding""</em> broadly enough that it seems to cover this case, even if it is all happening within one function. I guess it's somewhat clear that implementations expect destructors not to try and propagate exceptions outward.</p>
",2
1482964,1482908,3,"<p>When you throw the original <code>E</code> temporary from the <code>try</code> block in <code>main</code>, the runtime implementation constructs an exception object of type <code>E</code> and searches for the first <code>catch</code> block that can handle the exception. In this case, this is the immediately following <code>catch (E&amp; e)</code> block.</p>

<p>When the implementation finds the correct <code>catch</code> to handle the exception, it then destroys all automatic variables which must go out of scope by moving out of the scope where the <code>throw</code> occurred to the scope in which the catch resides.</p>

<p>In this case the objects <code>a</code> and <code>b</code> which are local to the catch block go out of scope, so must be destroyed (in the reverse order that they were created). However, destroying <code>a</code> causes another exception to be thrown. Because the implementation already has an uncaught exception and has already chosen a catch handler for that exception which it is trying to reach, there is no mechanism to handle this new exception. The rule in this case is that <code>std::terminate</code>, and in your case your terminate handler, is called immediately.</p>

<p>You should note that your <code>my_terminate</code> function is not a conforming <code>terminate_handler</code>, as a <code>terminate_handler</code> must not <code>return</code> and must terminate the program execution (i.e. must not <code>throw</code> either). Yours returns implicitly.</p>
",0
1483027,1482908,1,"<p><strong>set_terminate</strong></p>
<p>function installs term_func as the function called by terminate. set_terminate is used with C++ exception handling and may be called at any point in your program before the exception is thrown. terminate calls abort by default. You can change this default by writing your own termination function and calling set_terminate with the name of your function as its argument. terminate calls the last function given as an argument to set_terminate. After performing any desired cleanup tasks,</p>
<p><strong>term_func should exit the program</strong>.</p>
<p><strong>If it does not exit (if it returns to its caller), abort is called</strong>.</p>
<p>my_terminate() should look like :</p>
<pre><code>void my_terminate() 
{
  cout &lt;&lt; &quot;Call to my_terminate&quot; &lt;&lt; endl;
  *
  *
  *
  exit(-1);

}
</code></pre>
",0
1483193,1482908,0,"<p>Here is the problem. Your A's destructor throws, which is a <strong>bad thing</strong>. Re-throwing exceptions, or throwing a new exception in an exception handler is kosher because the stack-unwinding is well-behaved. In that case, only <strong>one</strong> exception is alive at the current stack frame. When a destructor throws an exception during the stack unwinding process however, <strong>two</strong> exceptions are alive the same stack frame, i.e they unwind the stack on the same level. In your case, that's two E objects. So which one does one choose to follow? You cannot follow both, so the standard says that <strong><code>terminate()</code></strong> will be called. You can make the exception system use your custom terminate routine by passing one with <strong><code>std::set_terminate()</code></strong> from the header <strong><code>&lt;exception&gt;</code></strong>.</p>

<p>You seem to think that your <strong><code>std::terminate()</code></strong> handler can resume your program by returning, but that's undefined behavior.<br>
If you absolutely positively need to throw from a destructor and can't contain it with an exception handler inside the destructor itself, here is a workaround:</p>

<p>The function <strong><code>uncaught_exception()</code></strong> from the header <strong><code>&lt;exception&gt;</code></strong> returns true if an exception has been thrown, but not yet caught. If it returns true, that means that the process is in the middle of a stack unwinding, unwinding the stack and calling destructors until it finds a proper exception handler. Use the function inside destructors which throw, so that they <strong>only throw</strong> when a stack unwinding is not happening.</p>

<p><em>Here's an example on how to use</em> <strong><code>uncaught_exception()</code></strong> (Though, it's an extremely bad idea):</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;exception&gt;
#include &lt;stdexcept&gt;
#include &lt;sstream&gt;
#include &lt;cstdlib&gt;

void termhandler()
{
    std::cout &lt;&lt; ""Inside terminate()"" &lt;&lt; std::endl;
    abort();
}

class Foo
{
public:
    Foo(int val) : i(val){ std::cout &lt;&lt; ""Created Foo object "" &lt;&lt; i &lt;&lt; std::endl; }
    ~Foo()
    {
        if(std::uncaught_exception()){
            std::cout &lt;&lt; ""~Foo::Foo() object "" &lt;&lt; i &lt;&lt; "" : "" &lt;&lt; ""Stack unwinding in progress. Can't throw!"" &lt;&lt; std::endl;
        } else {
            std::cout &lt;&lt; ""~Foo::Foo() object "" &lt;&lt; i &lt;&lt; "" : "" &lt;&lt; ""Throwing test exception."" &lt;&lt; std::endl;
            std::ostringstream strm;
            strm &lt;&lt; i;
            std::runtime_error e(""Exception from ~Foo::Foo() object "" + strm.str());
            throw e;
        }
    }
    int i;
};

int main()
{
    try {
        std::set_terminate(termhandler);    
        Foo A(1);
        Foo B(2);
    } catch(std::exception&amp; e){
        std::cout &lt;&lt; ""Caught exception in main() : "" &lt;&lt; e.what() &lt;&lt; std::endl;
    }
}
</code></pre>

<p>Which gives the following output:</p>

<p>Created Foo object 1<br>
Created Foo object 2<br>
~Foo::Foo() object 2 : Throwing test exception.<br>
~Foo::Foo() object 1 : Stack unwinding in progress. Can't throw!<br>
Caught exception in main() : Exception from ~Foo::Foo() object 2<br></p>
",1
1516255,1516240,11,"<p><code>p[i]</code> gives you the value at <code>sizeof(base) * i</code> bytes after <code>p</code>. So <code>p[1]</code> won't give you the second element of <code>d</code>, it will give you the second half of the first element.</p>

<p>In other words: if you use a pointer to the base class to iterate over an array of the derived class, you'll get wrong results if the derived class has a bigger size than the base class because it will iterate in steps of <code>sizeof(baseclass)</code> bytes.</p>
",3
1516267,1516240,3,"<p>Think of the memory layout of d array.</p>

<p>d->0101010101</p>

<p>Where each pair of 01 correspond to one derived object.</p>

<p>Now let p point to it:</p>

<p>p->0101010101</p>

<p>Since the size of base objects is that of one int. That memory segment is considered to be 10 base objects: the first one with _bval 0, the second one with _bval 1,...etc.</p>
",1
1516270,1516240,1,"<p>Beside what sepp2k said, you didn't initialize <code>_bval</code> in the derived class constructor. You should initialize it using <code>base</code> constructor.</p>
",0
1516318,1516240,7,"<p>Short answer: In C++, arrays of values are never polymorphic, even if their content is, and cannot be treated so. That is, you cannot treat an <code>derived ad[N]</code> as if it was a <code>base ab[N]</code>. </p>

<p>Long answer: The reason for this is deeply buried in C's pointer arithmetic. If you have an <code>int* pi</code> and increment it <code>++pi</code>, it will not simply increment to the next memory address. If it did, it wouldn't point to the next <code>int</code> since this doesn't start at the next address. So instead <code>sizeof(int)</code> bytes are added to the pointer. (A concrete example might help: On architectures with 8bit <code>char</code> types - <code>char</code> being, by definition what C and C++ consider the architecture's byte size - and 32bit <code>int</code> types, <code>int</code> has the size of 4 bytes. Thus, <code>++pi</code> will add 4 to the pointers address, so that it points to the next <code>int</code>.) The same arithmetic applies to all other pointer operations. So, for example, with <code>int* pi2=pi+1</code>, <code>pi2</code> will point <code>sizeof(int)</code> bytes behind <code>pi</code>, although <code>pi2-pi</code> will yield 1. </p>

<p>So, presuming you understood the last paragraph, let's go back to arrays. If you have an array <code>derived ad[N]</code>, the address of <code>ad[1]</code> is <code>sizeof(derived)</code> bytes greater than the address of <code>ad[0]</code>. (That's disregarding alignment in order to not to further complicate the issue.) However, if you have a <code>base* pb</code> pointing to <code>ad[0]</code>, incrementing it will make it point <code>sizeof(base)</code> behind the address of the first element - which, if (as is the case in your example) <code>sizeof(base) &lt; sizeof(derived)</code>, is <em>not</em> the address of <code>ad[1]</code>, but somewhere in the middle of <code>ad[0]</code>. </p>

<p>The only thing you can do to treat the array content as if it was all base classes, is to iterate over the array using a <code>derived*</code> and cast this pointer to <code>base*</code> <em>within</em> the loop: </p>

<pre><code>derived d[5];
derived* begin = d; 
const derived* end = d + sizeof(d)/sizeof(d[0]); // points one beyond the last element
while(begin != end)
{
  base* pb = begin;
  cout&lt;&lt; pb-&gt;_bval;
  ++begin;
}
</code></pre>

<p>(Note that I've also changed your code to use C++' idiomatic begin/end iterators.) </p>
",0
1520079,1520022,2,"<p><a href=""http://notepad-plus.sourceforge.net/uk/about.php"" rel=""nofollow noreferrer"">Notepad++</a> for some definitions of ""simple"".</p>
",1
1520084,1520022,20,"<p>You might want to look at <a href=""http://www.gnu.org/software/zile/"" rel=""noreferrer"">Zile</a> or <a href=""http://www.bostic.com/vi/"" rel=""noreferrer"">nvi</a>.  Both are fairly simple; Zile is Emacs-like, and nvi is the Berkeley <code>vi</code>.  Another to look at would be <a href=""http://www.nano-editor.org/"" rel=""noreferrer"">Nano</a>, a simple text editor that is designed to be easy for new users.  I don't know how clean the code is on any of these, though.</p>

<p>I would also recommend reading <a href=""http://www.finseth.com/craft/"" rel=""noreferrer"">The Craft of Text Editing: Emacs for the Modern World</a>.  This book surveys many of the specific problems that have to be dealt with in writing a text editor along with approaches, strategies, and algorithms for solving them.  Its content should be relevant and useful even if your editor isn't going to look much like Emacs at all.</p>
",1
1520085,1520022,4,"<p>Get the vi.
There is a big lack of true editors like vi/vim ;)
I mean there is a plenty of editors like notepad/notepad++,
but few editors which have separate command/control mode.
So You could look at the vi sources to inspire yourself and introduce something revolutionary.</p>
",3
1520088,1520022,10,"<p>Well what you want to see sounds more like a tutorial than an actual application (I think applications like <a href=""http://notepad-plus.sourceforge.net/de/site.htm"" rel=""nofollow noreferrer"">Notepad++</a> will be a lot to dive into in the beginning). Since you don't mention any environment you want to program in, you could check out the <a href=""http://doc.qt.io/qt-5/qtwidgets-richtext-textedit-example.html"" rel=""nofollow noreferrer"">QT Text Editor</a> Demo. QT is a cross platform GUI Toolkit so you are not bound to a specific operating system but probably harder to setup then a Visual Studio environment in Windows.</p>

<p>For Windows only you might want to think about digging more into the .NET platform (e.g. C#) as suggested in <a href=""https://stackoverflow.com/questions/1433162/vc-win32-or-wpf-for-developing-a-text-editor"">this question</a>. It doesn't help learning C++ but it makes GUI development a hell of a lot easier.</p>
",1
1520096,1520022,4,"<p><a href=""http://notepad-plus.sourceforge.net/uk/site.htm"" rel=""nofollow noreferrer"">Notepad++</a> is an excellent open source editor written in C++.</p>
",0
1520100,1520022,1,"<p><a href=""http://sourceforge.net/projects/juffed/"" rel=""nofollow noreferrer"">JuffEd</a>. It is written in C++, cross platform due to usage of Qt and QScintilla. Notepad++ uses also Scintilla text editor component, but its limited only to Windows platform.</p>
",0
1520108,1520022,0,"<p>loot to the QT this is cross platform,HAVE RICHTEXT COMPONENT(widget).Writing first app in QT will give you actual knowledge.I recommend to learn QT by book</p>
",0
1520111,1520022,2,"<p>You may also check out <a href=""http://www.scintilla.org/"" rel=""nofollow noreferrer"">Scintilla</a> editing component.</p>
",0
1520145,1520022,1,"<p>What sort of text editor would you like to make?</p>

<p>First question is will this be GUI or Console based?</p>

<p>GUI based, do you want to make something like Notepad? And on what platform? If it's MS Windows based, might I recommend picking up on MFC? </p>

<p>If it's text based, there are many open source solutions you can get into. My recommendation is to look at the simplest of editors like ed or something.</p>
",0
1679054,1679044,16,"<p>Read as much as you can - differing perspectives are always valuable.</p>
",1
1679095,1679044,8,"<p>Frankly, Herb Sutter yanks a lot in the exception safety ever since the introduction of the idea in one of the journals of the pre-2000 age. The fact he used it a lot on replication and transactional systems makes sense, and unless you are a huge follower and interested in only the software of such 'safety' kind you will be bored to death. Meyers is far more practical and engaging. </p>

<p>Besides, if you want to move on, there are other books in the series, notably from the legends and not the writers for the sake of writing. Look up the bits from Nicolai Josuttis (<a href=""https://rads.stackoverflow.com/amzn/click/com/0201734842"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">C++ Templates: The Complete Guide</a>), Aleksey Gurtovoy (<a href=""https://rads.stackoverflow.com/amzn/click/com/0321227255"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">C++ Template Metaprogramming</a>) and more recently 'Daddy 2' Stepanov. In my opinion, they are more influential, knowledgable, practical and shaping than anything DDJ or exception safety induced writeups...</p>

<p>And of course, if you ever need to go back to basics (and there is always a reason to), one of the best possible books on the subject is by the daddy himself: The <a href=""https://rads.stackoverflow.com/amzn/click/com/0321563840"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">C++ Programming Language</a> (most underestimated and skimmed over book out there).</p>
",10
1679122,1679044,4,"<p>I like the C++ Coding Standard book because it's just that, a coding standard.</p>

<p>Effective C++ introduces important ideas, and was my first read too. C++ Coding Standards however is shaped like a coding standard, which any person programming should have. There are a number of other coding standards available, Sutter's one has the advantage of being concise and well explained (only 100 items very neatly classified).</p>

<p>I would take the time, if I were you, to read the C++ Coding Standards and the <a href=""http://www.gotw.ca/gotw/"" rel=""nofollow noreferrer"">Guru of the Week</a> entries before moving on to meta-template programming.</p>

<p>Meta-template programming is interesting. I loved Modern C++ Programming and its approaches. However it is less used in practice I think, strengthen the basics as much as you can, then you can always play around with 'new' ideas.</p>
",2
1679179,1679044,5,"<p>Read <a href=""https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list"">The Definitive C++ Book Guide and List</a>. ""Exceptional C++"" is on the list.</p>
",0
1679183,1679044,10,"<p>Yes, absolutely. Herb Sutter covers a lot of very important, but generally poorly understood areas of the language and provides lots of useful guidance for writing more robust code.</p>

<p>While it's true that much of the material originated on the gotw site, it is expanded and better organized in the books. If you can answer all of the problems correctly then you find that you are very rarely faced with code that you don't understand why it behaves like it does. You may also find yourself heading off many potential problems that you spot in code before they become real issues.</p>

<p>I got a lot more out of the Exceptional C++ books than I did out of Effective C++, but this is going to be a very personal thing.</p>
",1
1679524,1679044,1,"<p>I found both books interesting and useful. There are lot of common topics and you might already know them, but certainly it will help.</p>
",0
1680684,1679044,4,"<p>I would absolutely recommend the <em>Exceptional C++</em> books if you're looking to move into more advanced C++. My sense from reading both series is that the <em>Effective C++</em> books tell you how to write code that doesn't completely suck, and the <em>Exceptional C++</em> books tell you how to write code that's rock-solid and bulletproof. I was less taken with <em>Modern C++ Design</em>; if you want to get into serious template metaprogramming it's pretty much the definitive work, but I found it a little... out there for my taste, particularly where he builds this gloriously complicated template structure that'll bring tears to your eyes with its sheer beauty, and then mentions ""Oh yeah, this doesn't actually work on any compiler that's currently available"".</p>
",0
1244283,1244269,0,"<p>You should put it as a private member function. This is what they are for.</p>
",2
1244287,1244269,0,"<p>I'm not sure why making a private member function isn't the right answer, but if it isn't, make it a static stand-alone function in the same <code>.cpp</code> file as your member functions.</p>
",1
1244289,1244269,4,"<p>Make it a free function in an anonymous namespace in the cpp file that defines the functions that use it:</p>

<pre><code>namespace {
    int myHelperFunction(int size, Bar &amp;target) {
        ...
    }
}

int Foo::doTarget(Bar &amp;target) {
    return myHelperFunction(this-&gt;size, target);
}

template &lt;typename IT&gt;
int Foo::doTargets(IT first, IT last, int size) {
    size += this-&gt;size;
    int total = 0;
    while (first != last) {
        total += myHelperFunction(size, *first);
        ++first;
    }
    return total;
}
</code></pre>

<p>or whatever.</p>

<p>This is assuming a simple setup where your member functions are declared in one header file, and defined in one translation unit. If it's more complicated, you could either make it a private static member function of the class, and define it in one of the translation units containing member function definitions (or add a new one), or else just give it its own header since you're decomposing things a long way into files already.</p>
",0
1244291,1244269,0,"<p>If your C++ class is the only class whose members use this common functionality, I say place the method in the class that uses the functionality.  However,  If there is a chance that another class will have to do that same work, then you should move it into a helper class or library (something of that nature).</p>
",1
1244296,1244269,4,"<p>If the ""set of operations"" can be encapsulated in a function that is not inherently tied to the class in question then it probably should be a free function (perhaps in an appropriate namespace).</p>

<p>If it's somehow tied to the class but doesn't require a class instance it should probably be a <code>static</code> member function, probably a <code>private</code> function if it doesn't form part of the class interface.</p>
",0
1244316,1244269,3,"<p>If multiple member functions of your class share common code, you have to look at the code being shared to decide where it goes.</p>

<p>If the shared code can use just the public interface of the class (so it doesn't access private member variables, protected functions etc.), you should consider whether other classes might want to use the same code. If no other class can make use of the function, put the shared code into a global (free) function within an anonymous namespace in the .cpp file, like this:</p>

<pre><code>namespace {
  void mySharedCode() {
     // ...
  }
}

void MyClass::f() {
  doThis();
  mySharedCode();
}

void MyClass::g() {
  doThat();
  mySharedCode();
}
</code></pre>

<p>If the shared code cannot be implemented using just the public interface (maybe the code uses private member variables or something), make it a private member function of the class. However, if the shared code uses just a few (say, one or two or there) member variables of your class, you could change that so that the shared function gets those values passed as variables. I.e. use</p>

<pre><code>// GOOD: free function in .cpp file used
namespace {
  int multiply( int a, int b ) {
    return a * b;
  }
}
void MyClass::f() {
  return multiply( m_a, m_b ) + 3;
}
</code></pre>

<p>instead of</p>

<pre><code>// BAD: private member function used
void MyClass::multiply() {
  return m_a * m_b ;
}
void MyClass::f() {
  return multiply() + 3;
}
</code></pre>
",1
1594541,1594306,0,"<p>The idiomatic way to overload operators is the following.</p>

<pre><code>struct M {
   ...
   M &amp; operator+=(M const&amp; rhs) {
       loop * 2 to increment
       return this;
   }
};

M operator+(M lhs, M const&amp; rhs) {
    return lhs += rhs;
}
</code></pre>

<p>But have a look at Blitz++, newmat and boost solutions that eliminate temporary objects thanks to <em>Expression Templates</em> -- C++0x's rvalue references will simplify ET solution.</p>

<p>NB: You will prefer to implement op*= in terms of op* instead of the other way around.</p>
",1
1594318,1594306,1,"<p>From <a href=""http://www.parashift.com/c++-faq-lite/operator-overloading.html#faq-13.1"" rel=""nofollow noreferrer"">http://www.parashift.com/c++-faq-lite/operator-overloading.html#faq-13.1</a></p>

<blockquote>
  <p>The idea is to call functions using
  the syntax of C++ operators. Such
  functions can be defined to accept
  parameters of user-defined types,
  giving the operators user-defined
  meaning. For example:</p>

<pre><code>Matrix add(const Matrix&amp; x, const Matrix&amp; y);
Matrix operator+(const Matrix&amp; x, const Matrix&amp; y);
Matrix use_add(const Matrix&amp; a, const Matrix&amp; b, const Matrix&amp; c)
{
  return add(a,add(b,c));
}
Matrix use_plus(const Matrix&amp; a, const Matrix&amp; b, const Matrix&amp; c)
{
  return a + b + c;
}
</code></pre>
</blockquote>

<p>Also, <a href=""http://www.daniweb.com/forums/thread230114.html"" rel=""nofollow noreferrer"">this</a> forum thread from lansinwd discusses this in detail</p>
",1
1421678,1421668,38,"<p>This might be of some use: <a href=""http://joule.bu.edu/~hazen/progr/cppcen.html"" rel=""noreferrer"">C++ tutorial for C users</a>. </p>

<p>If you're looking for a book, check out ""C++ for C Programmers"" by Ira Pohl (<a href=""https://rads.stackoverflow.com/amzn/click/com/080533159X"" rel=""noreferrer"" rel=""nofollow noreferrer"">Amazon</a>).</p>
",13
1421695,1421668,2,"<p>This <a href=""https://stackoverflow.com/questions/1420685/c-good-habits-re-transitioning-to-c/1420743#1420743"">very recent SO question</a> asked by an inexperienced C programmer nevertheless has answers that are also relevant to experienced C programmers.</p>
",0
1421696,1421668,14,"<p>I found <a href=""http://www.mindview.net/Books/TICPP/ThinkingInCPP2e.html"" rel=""nofollow noreferrer"">Thinking in C++</a> very good when I was going from C to C++.</p>

<p>Link broken - can now be found <a href=""http://www.cs.ust.hk/~dekai/library/ECKEL_Bruce/"" rel=""nofollow noreferrer"">here</a></p>
",1
1421703,1421668,3,"<p><a href=""https://rads.stackoverflow.com/amzn/click/com/020170353X"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">Accelerated C++</a> is good too.</p>
",1
1421803,1421668,6,"<p>I'd like to suggest the <a href=""https://isocpp.org/faq"" rel=""nofollow noreferrer"">New C++ Super-FAQ</a> created by Bjarne Stroustrup, Herb Sutter, Andrei Alexandrescu, Pearson / Addison-Wesley Publishers and Marshall Cline (<a href=""http://www.parashift.com/c++-faq/"" rel=""nofollow noreferrer"">http://www.parashift.com/c++-faq/</a>).</p>
",0
1422029,1421668,5,"<p>If you can get hold of a 2nd edition of <a href=""http://www.aristeia.com"" rel=""nofollow noreferrer"">Scott Meyer's</a> ""Effective C++"", that should help, as it was written for former C developers. It lists 50 rules that you should follow which are easily to remember, thoroughly explained, and fun to read. (Scott's goal was to write the ""best 2nd C++ book"" one should read an I think he succeeded in that.) </p>

<p>The 3rd edition of the book was completely overhauled and targets developers coming from C#, Java etc. more than earlier editions. It might be good read nevertheless. </p>
",0
1422233,1421668,2,"<p>If you're already a good C programmer, you can probably jump right into the bible, Stroustrup's <em>The C++ Programming Language</em>.</p>
",0
1491759,1491753,1,"<p>Neither, exactly. The variable s is referring to a string object.</p>

<pre><code>#include &lt;string&gt;
using namespace std;

int main()
{
    string s = ""small""; //s is assigned a reference to a new string object containing ""small"" 
    s = ""bigger""; //s is modified using an overloaded operator
}
</code></pre>

<p>Edit, corrected some details and clarified point</p>

<p>See: <a href=""http://www.cplusplus.com/reference/string/string/"" rel=""nofollow noreferrer"">http://www.cplusplus.com/reference/string/string/</a> and in particular <a href=""http://www.cplusplus.com/reference/string/string/operator=/"" rel=""nofollow noreferrer"">http://www.cplusplus.com/reference/string/string/operator=/</a></p>

<p>The assignment results in the original content being dropped and the content of the right side of the operation being copied into the object. similar to doing s.assign(""bigger""), but assign has a broader range of acceptable parameters.</p>

<p>To get to your original question, the contents of the object s can have variable size. See <a href=""http://www.cplusplus.com/reference/string/string/resize/"" rel=""nofollow noreferrer"">http://www.cplusplus.com/reference/string/string/resize/</a> for more details on this.</p>
",6
1491781,1491753,3,"<p>It depends on what you mean by ""size"".</p>

<p>The static size of s (as returned by sizeof(s)) will be the same.</p>

<p>However, the size occupied on the heap will vary between the two cases.</p>

<p>What do you want to do with the information?</p>
",6
1491789,1491753,2,"<p>i'll say yes and no.
s will  be the same string instance but it's internal buffer (which is preallocated depending on your STL implementation) will contain a copy of the constant string you wanted to affect to it.
Should the constant string (or any other char* or string) have a bigger size than the internal preallocated buffer of s, s buffer will be reallocated depending on string buffer reallocation algorithm implemented in your STL implmentation.</p>
",0
1491817,1491753,2,"<p>This is going to lead to a dangerous discussion because the concept of ""size"" is not well defined in your question.</p>

<p>The size of a class s is known at compile time, it's simply the sum of the sizes of it's members + whatever extra information needs to be kept for classes (I'll admit I don't know all the details) The important  thing to get out of this, however is the sizeof(s) will NOT change between assignments.</p>

<p>HOWEVER, the memory footprint of s can change during runtime through the use of heap allocations. So as you assign the bigger string to s, it's memory footprint will increase because it will probably need more space allocated on the heap. You should probably try and specify what you want.</p>
",4
1491819,1491753,0,"<p>i would say this is string object , And it has capability to grow dynamically and vice-versa </p>
",0
1491833,1491753,1,"<p>The <code>std::string</code> variable never changes its size. It just refers to a different piece of memory with a different size and different data. </p>
",0
1491983,1491753,1,"<p>A variable is an object we refer to by a name. The ""physical"" size of an object -- sizeof(s) in this case -- doesn't change, ever. They type is still std::string and the size of a std::string is always constant. However, things like strings and vectors (and other containers for that matter) have a ""logical size"" that tells us how many elements of some type they store. A string ""logically"" stores characters. I say ""logically"" because a string object doesn't really contain the characters directly. Usually it has only a couple of pointers as ""physical members"". Since the string objects manages a dynamically allocated array of characters and provides proper copy semantics and convenient access to the characters we can thing of those characters as members (""logical members""). Since growing a string is a matter of reallocating memory and updating pointers we don't even need sizeof(s) to change.</p>
",0
1783472,1783465,0,"<p>Because the language grammar says so...</p>
",5
1783490,1783465,20,"<p>because you can optionally declare objects </p>

<pre><code>class Thing
{
    ...
}instanceOfThing;
</code></pre>

<p>for historical reasons</p>
",1
1783509,1783465,116,"<p>The full syntax is, essentially,</p>

<p>class NAME { constituents } instances ;</p>

<p>where ""constituents"" is the sequence of class elements and methods, and ""instances"" is a comma-separated list of instances of the class (i.e., objects).</p>

<p>Example:</p>

<pre><code>class FOO {
  int bar;
  int baz;
} waldo;
</code></pre>

<p>declares both the class FOO and an object waldo.</p>

<p>The instance sequence may be empty, in which case you would have just</p>

<pre><code>class FOO {
  int bar;
  int baz;
};
</code></pre>

<p>You have to put the semicolon there so the compiler will know whether you declared any instances or not.</p>

<p>This is a C compatibility thing.</p>
",2
1783543,1783465,3,"<p>Because it could be a definition of the next element. For example, taking it from C syntax: if you declare</p>

<p><code>
struct { 
 ...
}
main (int argc, char..
</code></p>

<p>then it assumes main returns a struct. If there was a semicolon, </p>

<p><code>
struct {
 ...
};
main (int argc, char..
</code></p>

<p>then <code>main</code> returns an int.</p>
",1
1783869,1783465,5,"<p>A good rule to help you remember where to put semicolons:</p>

<ul>
<li>If it's a definition, it needs a semicolon at the end.  Classes, structs and unions are all information for the compiler, so need a trailing ; to mark no declared instances.</li>
<li>If it contains code, it doesn't need a semicolon at the end.  If statements, for loops, while loops and functions contain code, so don't need a trailing ;.</li>
</ul>

<p>Namespaces also don't require a trailing semicolon, because they can contain a mix of both the above (so can contain code, so don't need a semicolon).</p>
",0
1502065,1501803,5,"<p>A few problems.  First, your characters are probably signed, which is why you get lots of FF's - if your character was 0x99, then it gets sign extended to 0xFFFFFF99 when printed.  Second, strlen (or dStrlen - what is that?) is bad because your input string may have nulls in it.  You need to pass around the string length explicitly.</p>

<pre><code>char *strToHex(unsigned char *str, int len){
  char *buffer = new char[len*2+1];
  char *pbuffer = buffer;
  for(int i = 0; i &lt; len ; ++i ){
    sprintf(pbuffer, ""%02X"", str[i]);
    pbuffer += 2;
  }
  return buffer;
}
</code></pre>
",1
1501806,1501803,10,"<p>I don't know if there is a lib in c++ for it, but the best way is to encode the bytes into base64. It's pretty trivial to write your own encoder, if there isn't a standard one around (but I suspect there will be).</p>
",1
1501832,1501803,0,"<p>There are various libraries you can use to do the conversion, such as:
<a href=""http://www.nuclex.org/downloads/developers/snippets/base64-encoder-and-decoder-in-cxx"" rel=""nofollow noreferrer"">http://www.nuclex.org/downloads/developers/snippets/base64-encoder-and-decoder-in-cxx</a>, but it does make the string bigger than the original, since it takes an 8 bit character and converts it to be a 7 bit character.</p>

<p>You will then need to decode it to be able to use it.</p>
",0
1587001,1586981,1,"<p>For starters you have to declare <code>x</code> before you can use it.</p>

<p>Also you can change</p>

<pre><code> int letter_count[26];

  // Initialization
  for(int i=0; i&lt;26; letter_count[i++]=0);
</code></pre>

<p>to just</p>

<pre><code>int letter_count[26] = {0};
</code></pre>
",2
1587004,1586981,1,"<p>don't use the word string as your variable name, you are including the string.h header which defines a class with the same name,</p>

<p>and yes,it would be better if you write a question with a specific problem</p>
",1
1587012,1586981,1,"<p>You don't have declared the <code>x</code> variable. It should be a <code>std::string</code>:</p>

<pre><code>string x;
</code></pre>

<p>After reading the input you declare a variable called <code>string</code> (with <code>char* string = x;</code>). If you leave out that line and just use <code>x</code> everywhere where you now use <code>string</code> your program compiles fine.</p>

<p>It also already very nearly does what I guess you intend it to do.</p>
",0
1587035,1586981,3,"<ul>
<li>Your code won't be able to compile. You used <code>x</code> in <code>cin &lt;&lt; x</code> before declaring it.</li>
<li>use <code>std::getline</code> to read a line.</li>
<li>Don't use std type name (string) as the variable name. (Thanks to bdonlan)</li>
<li><p>Don't use magical number (63,etc).</p>

<p>By combine above together, we have this. This is far from perfect , but it is improved. </p>

<pre><code>    cout &lt;&lt; ""Input a Sentence: "";
    string line;
    std::getline(std::cin , line);

int letter_count[26];

// Initialization
for(int i= 0; i&lt;26; i++)
{
    letter_count[i] = 0;
}

// Counting the number of letters
for(int i = 0; line[i] != '\0'; i++) {
    if(line[i] &gt;= 'a' &amp;&amp; line[i] &lt;= 'z'){
            letter_count[line[i]-'a']++;
    }else if (line[i] &gt;= 'A' &amp;&amp; line[i] &lt;= 'Z'){
            letter_count[line[i]-'A']++;
    }else if (line[i] == '.')
            break;
}

// Show the result
</code></pre></li>
</ul>
",1
1587860,1586981,0,"<p>The specific problem in your code is that you didn't declare the variable <code>x</code> before use. (And your declaration was weird. To declare a variable, put the type followed by the name, like <code>char* x</code>, optionally followed by an assignment to initialize it, <code>char* x = ""hello world""</code>. After the variable has been declared, the compiler will let you use it.</p>

<pre><code>#include &lt;iostream&gt; // include the header containing cout and cin
#include &lt;string&gt; // include the header containing the string class
// using namespace std; // don't do this. Prefix standard library names with the std namespace instead

int main()
{
  std::cout &lt;&lt; ""Input a Sentence: "";
  std::string x; // declare a variable named x, so we can use it afterwards - and use the C++ string class, not char*
  //std::cin &gt;&gt; x; // only reads a word into x. If we want a sentence, use getline instead:
  std::getline(cin, x);
  int letter_count[26] = {}; // automatically fills the array with zeros

  // Counting the number of letters
  for(std::string::iterator it = x.begin(); it != x.end(); ++it) { // might as well use iterators. That's what they're for. And then your code behaves better if the string actually contains a \0 character.
    if(*it &gt;= 'A' &amp;&amp; *it &lt;= 'Z'){ // never leave out the {}'s. It'll blow up on you later, when you modify the code
      letter_count[*it - 'A']++;
    }
    else if (*it &gt;= 'a' &amp;&amp; *it &lt;= 'z'){
      letter_count[*it-'a']++;
    }
    else if (*it == '.'){
      break;
    }
  }

  // Show the result

  for(int i=0; i &lt; 26; i++)
    if (letter_count[i] != 0)
      std::cout &lt;&lt; letter_count[i] &lt;&lt; "" ""&lt;&lt; static_cast&lt;char&gt;(i+97) &lt;&lt; std::endl; // prefer C++-style casts
  }
}
</code></pre>
",0
1588578,1588566,3,"<p>You should check the ""Additional include directories"" - the list should usually be the same for ""Debug"" and ""Release"".</p>
",0
1588580,1588566,6,"<p>It seems that you're using Visual Studio.</p>

<p>Check the include directories in project properties, for Release target. You set the proper include directories only for Debug target.</p>
",0
1522796,1522789,10,"<p>No, doing so can cause a lot of problems.  You should always copy C++ types by using the assignment operator or copy constructor.</p>

<p>Using a bitwise copy breaks any kind of resource management because at the end of the day you are left with 2 objects for which 1 constructor has run and 2 destructors will run.  </p>

<p>Consider as an example a ref counted pointer.  </p>

<pre><code>void foo() {
  RefPointer&lt;int&gt; p1(new int());
  RefPointer&lt;int&gt; p2;
  memcpy(&amp;p2,p1,sizeof(RefPointer&lt;int&gt;));
}
</code></pre>

<p>Now both p1 and p2 are holding onto the same data yet the internal ref counting mechanism has not been notified.  Both destructors will run thinking they are the sole owner of the data potentially causing the value to be destructed twice.  </p>
",1
1522798,1522789,0,"<p>It depends on the implementation of the C++ object you are trying to copy. In general the owner of the C++ object's memory is the object itself, so trying to ""move"" or ""copy"" it with something like memcopy_s is going behind its back which is going to get you in trouble more often than not.</p>

<p>Usually if a C++ object is intended to be copied or moved, there are APIs within the class itself that facilitate this.</p>
",0
1522802,1522789,17,"<p>If they're Plain Old Data (POD) types, then this should work.  Any class that has instances of other classes inside it will potentially fail, since you're copying them without invoking their copy constructors.  The most likely way it will fail is one of their destructors will free some memory, but you've duplicated pointers that point to it, so you then try to use it from one of your copied objects and get a segfault.  In short, don't do it unless it's a POD and you're sure it will always be a POD.</p>
",2
1522815,1522789,0,"<p>In general if your structure contains pointers, you can't memcpy it because the structure would most likely allocate new memory spaces and point to those. A memcpy can't handle that.</p>

<p>If however your class only has primitive, non-pointer types, you <em>should</em> be able to.</p>
",0
1522903,1522789,0,"<p>In addition to the problem of unbalanced resource management calls in the two instance you end up with after a memcopy (as @JaredPar and @rmeador pointed), if the object supports a notion of an instance ID doing a memcopy will leave you with two instances with the same ID. This can lead to all sorts of ""interesting"" problems to hunt later on, especially if your objects are mapped to a database.</p>
",0
1524031,1522789,1,"<p>If it is a single object, why not use assignment operator (I suppose the compiler-generated assignment operator could be implemented in terms of <code>memcpy</code> if that is so advantageous, and the compiler knows better whether your class is a POD.)</p>

<p>If you want to copy an array of objects, you can use std::copy. Depending on the implementation, this may end up using <code>memmove</code> (one more thing that you can mess up - the buffers may overlap; I don't know whether the nonstandard <code>memcpy_s</code> somehow checks for that) if the involved types allow that. Again, the decision is done by the compiler, which will get it right even if the types are modified.</p>
",0
1800888,1800864,2,"<p>You make them public if you want other classes to be able to use them. You make them protected if only the classes in your hierarchy need them and you want to keep from cluttering your program's namespace unnecessarily.</p>

<p>If it's a constant, it's pretty silly to make a read accessor for it. And a write accessor wouldn't work. So don't bother.</p>
",2
1800891,1800864,4,"<p>I think that they should be private or protected if they are irrelevant to the external interface. If you make them public, someone may use them. If you change the implementation and the constants go away... oops!</p>
",0
1698665,1698660,45,"<p>Since you're using C++, if you want <code>xc</code> and <code>yc</code> to change, you can use references:</p>

<pre><code>void trans(double x, double y, double theta, double&amp; m, double&amp; n)
{
    m=cos(theta)*x+sin(theta)*y;
    n=-sin(theta)*x+cos(theta)*y;
}

int main()
{
    // ... 
    // no special decoration required for xc and yc when using references
    trans(center_x, center_y, angle, xc, yc);
    // ...
}
</code></pre>

<p>Whereas if you were using C, you would have to pass explicit pointers or addresses, such as:</p>

<pre><code>void trans(double x, double y, double theta, double* m, double* n)
{
    *m=cos(theta)*x+sin(theta)*y;
    *n=-sin(theta)*x+cos(theta)*y;
}

int main()
{
    /* ... */
    /* have to use an ampersand to explicitly pass address */
    trans(center_x, center_y, angle, &amp;xc, &amp;yc);
    /* ... */
}
</code></pre>

<p>I would recommend checking out the <a href=""https://isocpp.org/wiki/faq/references"" rel=""noreferrer"">C++ FAQ Lite's entry on references</a> for some more information on how to use references properly.</p>
",1
1698666,1698660,1,"<p>You need to pass your variables by reference which means </p>

<pre><code>void trans(double x,double y,double theta,double &amp;m,double &amp;n) { ... }
</code></pre>
",0
1698714,1698660,10,"<p>Passing by reference is indeed a correct answer, however, C++ sort-of allows multi-values returns using <code>std::tuple</code> and (for two values) <code>std::pair</code>:</p>

<pre><code>#include &lt;cmath&gt;
#include &lt;tuple&gt;

using std::cos; using std::sin;
using std::make_tuple; using std::tuple;

tuple&lt;double, double&gt; trans(double x, double y, double theta)
{
    double m = cos(theta)*x + sin(theta)*y;
    double n = -sin(theta)*x + cos(theta)*y;
    return make_tuple(m, n);
}
</code></pre>

<p>This way, you don't have to use out-parameters at all.</p>

<p>On the caller side, you can use <code>std::tie</code> to unpack the tuple into other variables:</p>

<pre><code>using std::tie;

double xc, yc;
tie(xc, yc) = trans(1, 1, M_PI);
// Use xc and yc from here on
</code></pre>

<p>Hope this helps!</p>
",0
1700018,1698660,0,"<p>as said above, you need to pass by reference to return altered values of 'm' and 'n', but... consider passing everything by reference and using const for the params you don't want to be altered inside your function i.e.</p>

<pre><code>void trans(const double&amp; x, const double&amp; y,const double&amp; theta, double&amp; m,double&amp; n)
</code></pre>
",0
1477627,1477602,9,"<p>Alright, after considering the comments and doing a test on my own, the real answer :
You must use forward declaration, no more. :)</p>

<pre><code>#include &lt;cstdlib&gt;
#include &lt;iostream&gt;

class point_t;
class board_t;

/* Rest of the code stay the same */
</code></pre>
",4
1477640,1477602,0,"<pre><code>#include &lt;cstdlib&gt;
#include &lt;iostream&gt;

enum piece_t {BLACK, WHITE, EMPTY, WALL}; //wall is area out side of board (board array is 21x21 but only 19x19 is playable)
enum dir_t {ABOVE,BELOW,LEFT, RIGHT}; //shall i overload ! or - operatior? !LEFT==RIGHT?

class point_t;

struct nextPoint_t  //should be implimented with references, but need to practice pointer
{ 
  point_t* above;
  point_t* below;
  point_t* left;
  point_t* right;

};


class board_t;

class point_t
{
 private:
  piece_t mType; //what sort of point this is
  int mLiberties;
  nextPoint_t  mAdjacent; // points to adjacent points

  bool mLibertiesCounted; // keeps track of if liberties have been counted, for mCountLiberites() (sets), is reset by mUpdateLiberites(); 

  int mCountLiberties(); //counts this point's liberites, by calling count on mAdjacent points etc.
  void mSetPos(int xPos, int yPos, const board_&amp;t theBoard); //sets up mAdjacent to point to adjacent points,
  void mSetStructureLiberties(int numLibs); // Sets this squares liberites then calls this on all adjacent squares 


 public:
  point_t ();//  parameterless constructor, for arrays
  void mSetUp(int xPos, int yPos, const board_t&amp; theBoard);// sets up mType then calles setPos iFF not WALL type
  point_t (int xPos, int yPos, const board_t&amp; theBoard); //constructor, takes it's position in the grid as a parameter

  void mUpdateLiberties(); // calles countLiberties then, updates liberites on whole of connected structure, by operating pon all conencted points



};

class board_t 
{
 private:
  point_t mArray [21][21];


 public:
  board_t(); //constructor, sets up board by operating on the point_t's

};
</code></pre>
",0
1477645,1477602,2,"<p>if you write before your struct</p>

<pre><code>class point_t;
</code></pre>

<p>that should do the trick.</p>

<p>Although I am not quite sure why your organize your class like that. You already have an array mArray in your board so there is no real need to have pointers to adjacent points inside each point_t.</p>

<p>EDIT: as the other poster said before you need to use pointers.</p>
",2
1477668,1477602,1,"<p>Just add this above struct nextPoint_t</p>

<pre><code>enum piece_t {BLACK, WHITE, EMPTY, WALL};
enum dir_t {ABOVE,BELOW,LEFT, RIGHT}; 

class point_t;
class board_t;

struct nextPoint_t
{ 
  point_t* above;
  point_t* below;
  point_t* left;
  point_t* right;
};
</code></pre>

<p>And change any reference to a board_t to a board_t*</p>

<pre><code>void mSetUp(int xPos, int yPos, board_t* theBoard);
</code></pre>
",0
1477703,1477602,2,"<p>The forward references in your code seems to be to <code>board_t</code> and <code>point_t</code>, which is resolved by forward declaring them. </p>

<p>Since you reference <code>board_t</code> in member function declarations of <code>point_t</code>, you cannot define the member functions right away in <code>point_t</code>. Their definitions have to appear after <code>board_t</code> is defined. So you have to either move the definition of the functions into the <code>cpp</code> file, or you have to move their definition in the header <em>after</em> definition of <code>board_t</code> whichever suites you more. <code>point_t</code> is only used as a pointee type in <code>nextPoint_t</code>, so we don't have the same problem for it here:</p>

<pre><code>class point_t; // used by nextPoint_t
class board_t; // used by point_t

struct nextPoint_t  //should be implimented with references, but need to practice pointer
{ 
  point_t* above; // goes without problems - doesn't need definition of point_t
  point_t* below;
  point_t* left;
  point_t* right;
};

class point_t
{
 private:
  piece_t mType;
  int mLiberties;
  nextPoint_t  mAdjacent;
  bool mLibertiesCounted;

  int mCountLiberties();
  void mSetPos(int xPos, int yPos, board_t theBoard);
  void mSetStructureLiberties(int numLibs); 

 public:
  point_t ();
  void mSetUp(int xPos, int yPos, board_t theBoard);
  point_t (int xPos, int yPos, board_t theBoard);

  void mUpdateLiberties(); 
};

class board_t 
{
 private:
  point_t mArray [21][21];

 public:
  board_t();     
};
</code></pre>

<p>Definition at the end of the header looks like</p>

<pre><code>// define it either inline in the header, or non-inline in a cpp file
inline void point_t::mSetPos(int xPos, int yPos, board_t theBoard) {
  /* some work... */
}

// same for mSetUp...
</code></pre>

<p>Nonetheless i would recommend you to use const references to pass the board to <code>point_t</code>'s member functions, but this is <strong>not</strong> a requirement for your code to work. Declarations go fine with incomplete parameter types.</p>
",0
1700274,1700211,1,"<p>The C++ language by itself doesn't have any built-in support for colors. This is typically provided by the graphics libraries you use, which themselves are often dependent on your operating system, windowing environment, etc. For example, a C++ program running on Windows and using the base Win32 SDK will treat colors differently than a C++ program using the Carbon framework on OS X. It would be much easier to answer your question if you provided these details.</p>

<p>Having said all that, it's quite likely that whatever libraries you use represent colors in some form of RGB notation, where you have a structure with a separate value, often 0-255, for the red, green, and blue components of your color. One simple approach you could use to move gradually from Blue to Red would be to progressively reduce the blue value while simultaneously increasing the red value.</p>

<p>So, if you started with {R, G, B} = {0, 0, 255} (all blue), you could move in steps like this:</p>

<p>{10, 0, 245}
{20, 0, 235}
{30, 0, 225}
...
...
{255, 0, 0} (all red)</p>

<p>The actual function calls to set the color of your display/button/window/etc. will be part of your graphics library documentation. Good luck!</p>
",0
1700317,1700211,6,"<p>A simple linear alpha-blending function could look like this:</p>

<pre><code>float blend(float a, float b, float alpha)
{
  return (1.f - alpha) * a + alpha * b;
}
</code></pre>

<p>This will interpolate from <code>a</code> to <code>b</code> as <code>alpha></code> goes from 0 to 1.</p>

<p>If you were to use this for each of the red, green and blue components that make up a typical color value, you could get the desired effect:</p>

<pre><code>struct Color
{
  float r, g, b;
};

Color color_blend(const Color *a, const Color *b, float alpha)
{
  struct Color x;

  x.r = blend(a-&gt;r, b-&gt;r, alpha);
  x.g = blend(a-&gt;g, b-&gt;g, alpha);
  x.b = blend(a-&gt;b, b-&gt;b, alpha);

  return x;
}
</code></pre>

<p>This is a bit C-ish for brevity; feel free to reformulate and use classes of course.</p>
",0
1700321,1700211,5,"<p>Colours are usually specified as quantities of red, green and blue light.  For most purposes, 8-bit resolution in each colour component (red, green, or blue) is sufficient.</p>

<p>So you might have a colour struct like this:</p>

<pre><code>typedef unsigned char uint8;

struct Colour
{
    uint8 red;
    uint8 green;
    uint8 blue;

    Colour(uint8 r, uint8 g, uint8 b) : red(r), green(g), blue(b) {}
};
</code></pre>

<p>then you can make colours once you understand the RGB colour model.  For your example colours, this is pretty easy:</p>

<pre><code>Colour Red(255, 0, 0);
Colour Blue(0, 0, 255);
</code></pre>

<p>Let's say you want to change from blue to red over 100 steps (or 100 seconds, or whatever).  You simply increment each component from the source value to the target value, so in your case, blue to red would be:</p>

<ul>
<li>Red: 0 to 255 </li>
<li>Green: 0 to 0 </li>
<li>Blue: 255 to 0</li>
</ul>

<p>So the red component is faded up to full intensity as you move to red, and the blue component is faded down to zero.</p>

<p>Some simple code to do this:</p>

<pre><code>// Fade from blue to red
Colour Source(0, 0, 255);  // blue
Colour Target(255, 0, 0);  // red

Colour MyColour = Source;

const int NumSteps = 100;

for (int i = 0; i &lt;= NumSteps; i++)
{
  MyColour.red   = Source.red   + (((Target.red   - Source.red)   * i) / NumSteps);
  MyColour.green = Source.green + (((Target.green - Source.green) * i) / NumSteps);
  MyColour.blue  = Source.blue  + (((Target.blue  - Source.blue)  * i) / NumSteps);

  // Do something, like update the display
  DoSomethingWithColour(MyColour);
}
</code></pre>

<p>This will fade MyColour from blue to red.  Note that this will fade through the RGB colour space.</p>

<p>There are other colour spaces, such as HLS and HSV, and fading through those colour spaces will give different effects.  For example, halfway through the RGB fade above the colour will be RGB(128, 0, 128), which is purple.  If you fade through the HSV space, the hue component will fade from red to purple to blue, so in this case it is the same.  However, if you choose different colours, you may get different effects depending on which colour space you use.</p>
",2
1700357,1700211,3,"<p>I think to get the effect you want (I assume you want a colour gradient) you would get better results converting RGB to HSV, then interpolate between the start and end HSV values. The RGB representation is suited to how colours get displayed, but the HSV (Hue, Saturation, Value) representation is closer to how colours are perceived.  See the <a href=""http://en.wikipedia.org/wiki/HSL_and_HSV"" rel=""nofollow noreferrer"">wikipedia article</a> for the HSV &lt;-> RGB conversion formula.</p>
",0
1700486,1700211,1,"<p>Other posters have answered this question sufficiently for the general case of blending from one colour to the next. I just want to point out that the blue to red colourmap is interpreted wrong by most humans, by which I mean that depending on where you are on the colourmap the same difference in value between two neighbouring colours looks like a different difference (heh) to a human.
A colourmap that is almost as easy as the blue to red clourmap but is interpreted somewhat better by humans is the black -> red -> yellow -> white colourmap.
Use blending code from above examples to scale your values linearly over:</p>

<pre><code>RGB (0,0,0) (black, start of your scale)
RGB (255,0,0) (red, 1/3rd through your scale)
RGB (255,255,0) (yellow, 2/3rds through your scale)
RGB (255,255,255) (white, upper end of your scale)
</code></pre>

<p>This colourmap gets progressively brighter as you get to higher values, so the change in colour is more obvious, and it also allows for more steps (768 versus 256 in the blue-red map), so you can see and show more resolution.</p>
",0
1585032,1584907,7,"<p>To add to other answers, consider that any function exposed through a shared object or DLL (depending on platform) can be overridden at run-time.  Linux provides the <code>LD_PRELOAD</code> environment variable, which can specify a shared object to load after all others, which can be used to override arbitrary function definitions.  It's actually about the best way to provide a ""mock object"" for unit-testing purposes, since it is not really invasive.  However, unlike other forms of monkey-patching, be aware that a change like this is global.  You can't specify one particular call to be different, without impacting other calls.</p>
",0
1584933,1584907,1,"<p>As <a href=""http://en.wikipedia.org/wiki/Monkey_patch"" rel=""nofollow noreferrer"">monkey patching</a> refers to dynamically changing code, I can't imagine how this could be implemented in C++... </p>
",1
1585061,1584907,9,"<p>Not portably so, and due to the dangers for larger projects you better have good reason.</p>

<p><strong>The Preprocessor</strong> is probably the best candidate, due to it's ignorance of the language itself. It can be used to rename attributes, methods and other symbol names - but the replacement is global at least for a single #include or sequence of code. </p>

<p>I've used that before to beat ""library diamonds"" into submission - Library A and B both importing an OS library S, but in different ways so that some symbols of S would be identically named but different. (namespaces were out of the question, for they'd have much more far-reaching consequences). </p>

<p>Similary, you can replace symbol names with compatible-but-superior classes.
e.g. in VC, <code>#import</code> generates an import library that uses <code>_bstr_t</code> as type adapter. In one project I've successfully replaced these _bstr_t uses with a compatible-enough class that interoperated better with other code, just be <code>#define</code>'ing <code>_bstr_t</code> as my replacement class for the <code>#import</code>. </p>

<p><strong>Patching the Virtual Method Table</strong> - either replacing the entire VMT or individual methods - is somethign else I've come across. It requires good understanding of how your compiler implements VMTs. I wouldn't do that in a real life project, because it depends on  compiler internals, and you don't get any warning when thigns have changed. It's a fun exercise to learn about the implementation details of C++, though.  One application would be switching at runtime from an initializer/loader stub to a full - or even data-dependent - implementation. </p>

<p><strong>Generating code on the fly</strong> is common in certain scenarios, such as forwarding/filtering COM Interface calls or mapping OS Window Handles to library objects. I'm not sure if this is still ""monkey-patching"", as it isn't really toying with the language itself.</p>
",1
1584945,1584907,3,"<p>I suppose it depends what you want to do. If you've already linked your program, you're gonna have a hard time replacing anything (short of actually changing the instructions in memory, which might be a stretch as well). However, before this happens, there are options. If you have a dynamically linked program, you can alter the way the linker operates (e.g. LD_LIBRARY_PATH environment variable) and have it link something else than the intended library.</p>

<p>Have a look at valgrind for example, which replaces (among alot of other magic stuff it's dealing with) the standard memory allocation mechanisms.</p>
",0
1584971,1584907,4,"<p>Considering the ""guerilla third-party library use"" aspect of monkey-patching, C++ offers a number of facilities:</p>

<ul>
<li><code>const_cast</code> lets you work around zealous <code>const</code> declarations.</li>
<li><code>#define private public</code> prior to header inclusion lets you access private members.</li>
<li>subclassing and <code>use Parent::protected_field</code> lets you access protected members.</li>
<li>you can redefine a number of things at link time.</li>
</ul>

<p>If the third party content you're working around is provided already compiled, though, most of the things feasible in dynamic languages isn't as easy, and often isn't possible at all.</p>
",0
1602376,1602364,8,"<p>Please use <code>std::string</code>:</p>

<pre><code>#include &lt;string&gt;

std::string str;
std::getline(cin, str);
cout &lt;&lt; str;
</code></pre>

<p>I'm not sure what the exact problem in your case was, but <code>&gt;&gt;</code> only reads up to the first separator (which is whitespace); <code>getline</code> will read the entire line.</p>
",1
1602888,1602364,1,"<p>Just note that >> operator will read 1 word.  </p>

<pre><code>std::string   word;
std::cin &gt;&gt; word;  // reads one space seporated word.
                   // Ignores any initial space. Then read
                   // into 'word' all character upto (but not including)
                   // the first space character (the space is gone.

// Note. Space =&gt; White Space (' ', '\t', '\v'  etc...)
</code></pre>
",0
1603107,1602364,1,"<p>You're working at the wrong level of abstraction.  Also, there is no need to <code>seekp</code> to the end of the file before closing the file.</p>

<p>You want to read a string and write a string.  As Pavel Minaev has said, this is directly supported via <code>std::string</code> and <code>std::fstream</code>:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;

int main()
{
    std::ofstream out(""G:\\Test.txt"");

    if(!out) {
        std::cout &lt;&lt; ""Cannot open output file.\n"";
        return 1;
    }

    std::cout &lt;&lt; ""Enter Customer's data seperated by tab\n"";
    std::string buffer;
    std::getline(std::cin, buffer);
    out &lt;&lt; buffer;

    return 0;
}
</code></pre>

<p>If you want to write C, use C.  Otherwise, take advantage of the language you're using.</p>
",2
1585826,1585222,2,"<p>If you want to do this with ostreams, I think you'll need to use ""facets"".  This little-known part of C++ lets you control formatting pretty much however you like.</p>

<p>Here's a description of <code>num_put</code>, which is what formats the numbers in the way you don't like: <a href=""http://www.cplusplus.com/reference/std/locale/num_put/"" rel=""nofollow noreferrer"">http://www.cplusplus.com/reference/std/locale/num_put/</a></p>

<p>You'll need to ""imbue"" your ostream (literally <code>ostr.imbue()</code>) with a locale containing the facet you'll create to format numbers the way you want.</p>

<p>I suggest starting by writing a function to convert a number to a string using the formatting you want.  Once you have that, if you wish to go whole hog and do the locale &amp; facet stuff, you can (or maybe you'll decide it's too complex, which is what most people end up doing).</p>
",0
1615572,1615555,13,"<p>You need to specify a proper function signature for the function <code>divide</code>.  Specifically, the arguments to the function are missing their types:</p>

<pre><code>double divide(double x, double y)
{
    ...
}
</code></pre>

<p>You also need to create a scope for each block in an if statement:</p>

<pre><code>if (x &gt; y)
{
    ...
}
else
{
    ...
}
</code></pre>
",2
1615573,1615555,3,"<p>The braces in an if statement don't go around the else block.  You need a separate pair of braces there.  Try:</p>

<pre><code>    if (x &gt;= y){
        x=z ;
        z=y ;
        y=x ;
        return(x/y);
    }
    else {
        return(y/x);
    }
</code></pre>

<p>The second set of braces (around the one line of the code after the 'else' aren't strictly necessary; you can leave the braces off an if or an else if the block is only one line long.  But while you're new you probably shouldn't, as it's easy to make mistakes that way.</p>

<p>Also, you have not provided types for the <code>x</code> and <code>y</code> variables in your divide function.  You must specify types for them, just as you would for any other variable.  You've written</p>

<pre><code>    double x,y,z,a ;
</code></pre>

<p>...outside of the function, but that doesn't help; it defines <em>new</em> double variables named <code>x</code>, <code>y</code>, <code>z</code>,and <code>a</code>, completely independent of the ones in your function.</p>
",1
1615576,1615555,0,"<p>Corrected your braces in your if...else.  also need to define a type in your function's parameters.</p>

<pre><code>using namespace std;

        double x,y,z,a ;

double divide (double x, double y)
    {
        if (x &gt;= y){
            x=z ;
            z=y ;
            y=x ;
            return(x/y);
        }  
        else
        {
            return(y/x);
        }
    }

    int main()
{
    double x,y,z ;
   cout &lt;&lt; ""Enter x "" &lt;&lt;endl;
   cin &gt;&gt; x ;
   cout &lt;&lt; ""Enter y "" &lt;&lt;endl;
   cin &gt;&gt; y ;
   a = divide (x,y);
   cout &lt;&lt; a &lt;&lt;endl;

        system(""pause"");
    return 0;
}
</code></pre>
",0
1615608,1615555,0,"<pre><code>#include &lt;iostream&gt;

using namespace std;

// divides x/y
double divide (x,y)
{
    if(y != 0)
    { 
        /*{}  &lt;- this is called a scope.
        it is important to keep track of scopes.
        each function has it's own scope
        each loop or an if instruction can have it's own scope
        in case it does - all the instructions from the scope will be executed
        in case it doesn't - only the 1st instruction after the if/else/for/while etc. will be executed

        Here's another funny thing about scopes :
        {
            double x; // this variable exists ONLY within this scope
        }
        {
            // y doesn't exist here
            { 
                double y; // y exists here. it's local
            }
            // y doesn't exist here
        }
        */
        return x / y; 
    }
    else
        return 0;
}

int main()
{
    double x,y;
    cout &lt;&lt; ""Enter x "" &lt;&lt;endl;
    cin &gt;&gt; x ;
    cout &lt;&lt; ""Enter y "" &lt;&lt;endl;
    cin &gt;&gt; y ;
    double a = divide (x,y);
    cout &lt;&lt; a &lt;&lt;endl;
    cin;
    return 0;
}
</code></pre>
",1
1608987,1608954,2,"<p>Yes. It must be a boolean expression, can be anything inside of it.</p>

<p>The way this works is as follows:</p>

<pre><code>void mystery1( char *s1, const char *s2 )
{
   while ( *s1 != '\0' )  // NEW: Stop when encountering zero character, aka string end.
      s1++;

   // NEW: Now, s1 points to where first string ends

   for ( ; *s1 = *s2; s1++, s2++ )  
      // Assign currently pointed to character from s2 into s1, 
      // then move both pointers by 1
      // Stop when the value of the expression *s1=*s2 is false.
      // The value of an assignment operator is the value that was assigned,
      // so it will be the value of the character that was assigned (copied from s2 to s1).
      // Since it will become false when assigned is false, aka zero, aka end of string,
      // this means the loop will exit after copying end of string character from s2 to s1, ending the appended string

      ; // empty statement
   }
}
</code></pre>

<p>What this does is copy all characters from s2 onto the end of s1, basically appending s2 to s1.</p>

<p>Just to be clear, <code>\n</code> has nothing to do with this code.</p>
",3
1608998,1608954,5,"<pre><code>*s1 = *s2
</code></pre>

<p>Is an expression. Expressions in C/C++ evaluates to values, and in this case it returns the value assigned to <code>*s1</code>. When the <code>'\0'</code> is assigned to <code>*s1</code>, the expression evaluates to <code>0</code> which is <code>false</code> clearly.</p>
",3
1608999,1608954,0,"<p>That code has nothing to do with '\n'. The result of an assignment expression is the new value of the assigned-to variable, so when you assign '\0' to <code>*s1</code>, the result of that expression is '\0', which is treated as false. The loop runs through the point where the entire string is copied.</p>
",0
1609020,1608954,0,"<p>is the code like this, check the extra brackets I added ...:</p>

<pre><code>void mystery1( char *s1, const char *s2 )
{
  while ( *s1 != '\0' )
  {
    s1++; 
  }

  for ( ; *s1 = *s2; s1++, s2++ )
  {
    ; // empty statement
  }
}
</code></pre>

<p>so, first while checks the end of the string s1; and the for copy s2 at the end of s1.</p>
",1
1534746,1534713,2,"<p>Learning a language that has many different ways to solve the same problem, a wealth of undefined behavior, keywords that have multiple context-dependent meanings and an ambiguous grammar will never be fast.</p>

<p>Start with Scott Meyer's Effective C++.  </p>
",0
1534747,1534713,0,"<p>The ones I know for C++ are OGRE 3D for game development and online judges for practicing software development.</p>
",0
1534808,1534713,0,"<p>Several things to help you improve:</p>

<ul>
<li>Read lots of books (like the one Brad mentioned)</li>
<li>Read lots of code</li>
<li>Write lots of code</li>
<li>Be open to looking at a problem from
a new viewpoint</li>
</ul>
",1
1534847,1534713,0,"<ul>
<li><p>First, assess your self, either do a mockup test or something to know where you stand.</p></li>
<li><p>Take a course in advanced C++. Algorithms, data structures, networking, or any other class where they'll give you a huge project to work on and where you'll be graded on your code, and the knowledge of C++ is expected.</p></li>
<li><p>buy a Solved problems book for C++, I recommend ""how to program C++"" (The problems and solutions edition) by Deitel and Dietel. Some might not recommend D &amp; D but for your purposes, it's adequate.</p></li>
</ul>
",0
1534851,1534713,1,"<p>Spend some time studying the <a href=""http://www.parashift.com/c++-faq-lite/"" rel=""nofollow noreferrer"">C++ FAQ Lite</a> (or buy the book and read it).  Thinking about and understanding the answers there has helped me learn a lot about C++.</p>
",0
1535325,1534713,5,"<p><strong>1)</strong> Daily Read c++ , stl and related tagged question on stackoverflow , Try <strong>analyze</strong> the 
       problems , <strong>think</strong> of <strong>solution</strong> , and <strong>understand</strong> solution given by others</p>

<p><strong>2)</strong> :) <strong>Start working</strong> on C++ in you work , If you have good senior people who do a 
       strict <strong>code/design review</strong> and give valid comments , you will learn c++.</p>

<p><strong>3)</strong> Participate on <strong>open source projects</strong> , Download source and analyze it.</p>

<p><strong>4</strong> Regarding tool : Use source code analyzer like <a href=""http://www.coverity.com/"" rel=""noreferrer"">coverity</a> , Lean <strong>window debugging</strong> tools package or something equivalent in unix, </p>
",0
1534859,1534713,0,"<p>Thinking in C++ by Bruce Eckel</p>

<p>They are free downloads now: <a href=""http://www.mindview.net/Books/DownloadSites"" rel=""nofollow noreferrer"">http://www.mindview.net/Books/DownloadSites</a></p>

<p>A legendary book in my opinion. Eckel is a clear and concise author. </p>
",0
1534897,1534713,0,"<p>Go to Amazon, find some ""learning C++"" books with high ratings, read the reviews and see which ones best meet your needs, buy two or three, and work through them.</p>

<p>However, I'd be careful about ""C++ How to Program"" by Deitel and Deitel. Early editions were fantastic, but I find the sixth edition too bloated and wordy for pedagogical purposes, and next to useless as a reference. Maybe the seventh edition is better, but I couldn't say.</p>

<p>You might also be able to find some good online courses. MIT's OpenCourseWare site might have something useful.</p>

<p>But don't believe anybody if they promise you can start from knowing nothing and become a C++ guru in 21 days or something. I've been programming mainly in C++ for nineteen years and don't consider myself a guru yet.</p>
",0
1534906,1534713,3,"<p>Mark C++ as a favorite tag on stackoverflow, and read anything that was answered by litb.
Seriously.</p>
",0
1534970,1534713,0,"<p>As the shoe salesman said: Just Do It.</p>

<p>Simply put, just start coding and you'll soon find out what you need to know. You can read all the books in the world, but until you can apply knowledge it's worthless.</p>
",0
1915950,1915900,7,"<p>You start to worry about stack size when</p>

<ul>
<li>someone on your team cunningly invents a recursive function that goes on and on and on...</li>
<li>you create a thread factory and suddenly need a tenfold of the stack that you used to need (each thread needs a stack => the more threads you have, the less free space remains for a given stack size)</li>
</ul>
",0
1915961,1915900,3,"<p>my experience: 
when you use recursive functions, take care of the stack size!!</p>
",2
1916000,1915900,11,"<p>You care about it on a microcontroller, where you often have to specify stack space explicitly (or you get whatever's left over after RAM gets used for static allocation + any RAM program space).</p>
",0
1916004,1915900,13,"<blockquote>
  <p>When you are programming in a language that allows you to use automatic allocation for very large objects ...</p>
</blockquote>

<p>If I want to allocate a very large object, then instead of on the stack I might allocate it on the heap but wrapped in an <code>auto_ptr</code> (in which case it will be deallocated when it goes out of scope, just like a stack-resident object, but without worrying about stack size).</p>

<blockquote>
  <p>... when and how do you worry about stack size?</p>
</blockquote>

<p>I use the stack conservatively out of habit (e.g. any object bigger than about 512 bytes is allocated on the heap instead), and I know how big the stack is (e.g. about a megabyte by default), and therefore know that I don't need to worry about it.</p>

<blockquote>
  <p>Are there any rules of thumb for reasoning about stack size?</p>
</blockquote>

<ul>
<li>Very big objects can blow the stack</li>
<li>Very deep recursion can blow the stack</li>
<li>The default stack size might be too big (take too much total memory) if there are many threads and if you're running on a limited-memory embedded device, in which case you might want to use an O/S API or linker option to reduce the size of the stack per thread.</li>
</ul>
",0
1916010,1915900,2,"<p>Only time really is when you are threading and have to define it yourself, when you are doing recursion or when for some reason you are allocating to the stack. Otherwise the compiler takes care of making sure you have enough stack space.</p>

<p>CreateThread by default only allocates 0x100000 bytes for the stack.</p>
",5
1916075,1915900,1,"<p>In general, big allocations on the stack are bad for several reasons, not the least of which is that they can cause problems to remain well hidden for a long time.</p>

<p>The problem is that detecting stack overflow is not easy, and big allocations can subvert most of the commonly used methods.</p>

<p>If the processor has no memory management or memory protection unit, you have to be particularly careful. But event with some sort of MMU or MPU, the hardware can fail to detect a stack overflow. One common scheme, reserving a page below the stack to catch overflow, fails if the big stack object is bigger than a page. There just might be the stack of another thread sitting there and oops! you just created a very nasty, hard to find bug.</p>

<p>Unlimited recursion is usually easy to catch because the stack growth is usually small and will trigger the hardware protection.</p>
",0
1915929,1915900,4,"<p>I never worry about it. If there is a stack overflow, I will soon know about it. Also, in C++ it is actually very hard to create very large objects on the stack. About the only way of doing it is:</p>

<pre><code>struct S {
   char big[1000000];
};
</code></pre>

<p>but use of std::string or std::vector makes that problem go away.</p>
",5
1915931,1915900,3,"<p>Shouldn't you be avoiding using the stack for allocating large objects in the first place?  Use the heap, no?</p>
",0
1916833,1915900,2,"<p>I worry about stack size on embedded systems when call stack goes very deep and each function allocates variables (on the stack).  Generally, panic evolves when the system crashes unexpectedly due to variables changing on the stack (the stack overflows).</p>
",0
1917057,1915900,2,"<p>Played this game a lot on Symbian: when to use TBuf (a string with storage on the stack), and when to use HBufC (which allocate the string storage on the heap, like std::string, so you have to cope with Leave, and your function needs a means of failing).</p>

<p>At the time (maybe still, I'm not sure), Symbian threads had 4k of stack by default. To manipulate filenames, you need to count on using up to 512 bytes (256 characters).</p>

<p>As you can imagine, the received wisdom was ""never put a filename on the stack"". But actually, it turned out that you could get away with it a lot more often than you'd think. When we started running real programs (TM), such as games, we found that we needed way more than the default stack size anyway, and it wasn't due to filenames or other specific large objects, it was due to the complexity of the game code.</p>

<p>If using stack makes your code simpler, and as long as you're testing properly, and as long as you don't go completely overboard (don't have multiple levels of file-handling functions which <em>all</em> put a filename on the stack), then I'd say just try it. Especially if the function would need to be able to fail anyway, whether you're using stack or heap. If it goes wrong, you either double the stack size and be more careful in future, or you add another failure case to your function. Neither is the end of the world.</p>
",0
1916844,1915900,6,"<p>If you're writing for a tiny little embedded platform, you worry about it all the time, but you also know exactly how big it is, and probably have some useful tools available to find the high-water mark of the stack.</p>

<p>If you aren't, then don't worry until your program crashes :)
Unless you are allocating seriously huge objects (many tens of KB), then it is never going to be a problem.</p>

<p>Note, however, that objects on the stack are, by definition, temporary. Constructing (and possibly destructing) large objects frequently may cause you a performance problem - so if you have a large object it probably should be persistent and heap-based for reasons other than stack size.</p>
",0
1917112,1915900,2,"<p>You usually can't really have large objects on the stack. They almost always use the heap internally so even if they are 'on the stack' their data members are not. Even an object with tons of data members will usually be under 64 bytes on the stack, the rest on the heap. The stack usually only becomes an issue these days when you have lots of threads and lots of recursion.</p>
",0
1917143,1915900,3,"<blockquote>
  <p>When do you worry about stack size?</p>
</blockquote>

<p>Never.  </p>

<p>If you have stack size problems it means you're doing something else wrong and should fix that instead of worrying about stack size.<br>
For instace:</p>

<ul>
<li>Allocating unreasonably large structures on the stack - don't do it. allocate on the heap.</li>
<li>Having a ridiculously long recursion. I mean in the order of painting an image and iterating over the pixels using recursion. - find a better way to do it.</li>
</ul>
",0
1916483,1915900,1,"<p>When deciding whether to allocate objects on the stack vs. the heap, there are also perf issues to be taken into consideration. Allocation of memory on the stack is very fast - it just involves moving the stack pointer, whereas dynamic allocation/deallocation using new/delete or malloc/free is fairly expensive, especially in multithreaded code that doesn't have a heap per thread. If you have a function that is being called in a tight loop, you might well err on the side of putting larger objects on the stack, keeping all of the multithreading caveats mentioned in other answers in mind, even if that means having to increase stack space, which most linkers will allow you to do.</p>
",1
1919363,1915900,1,"<p>I don't. Worrying about this things whilst writing programming normal things is either a case of premature pessimization or premature optimization. It's pretty hard to blow things up on a modern computer anyway.</p>

<p>I once wrote a CSV parser and whilst playing around with trying to get the best performance I was allocating hundereds of thousands of 1K buffers on the stack. The performance was stellar but the RAM went up to about 1GB from memory from normal 30MB. This was due to each cell in the CSV file had a fixed size 1K buffer.</p>

<p>Like everyone is saying unless you are doing recursion you do not have to worry about it.</p>
",0
1921201,1915900,0,"<p>I have had problems running out of stack space when:</p>

<ul>
<li>A function accidentally calls itself</li>
<li>A function uses recursion to a deep level</li>
<li>A function allocates a large object on the stack, and there is a heap.</li>
<li>A function uses complicated templates and the compiler crashes</li>
</ul>

<p>Provided I:</p>

<ul>
<li>Allocate large objects on the heap (eg. using ""auto_ptr foo = new Foo"" instead of ""Foo foo"")</li>
<li>Use recursion judiciously.</li>
</ul>

<p>I don't normally have any problems, so unfortunately don't know what good defaults should be.</p>
",0
1920317,1915900,0,"<p>You worry about it when you write a callback that will be called from threads spawned by a runtime you don't control (for example, MS RPC runtime) with stack size at the discretion of that runtime. Somehow <a href=""https://stackoverflow.com/questions/1345478/how-to-detect-the-amount-of-stack-space-available-to-my-program"">like this</a>.</p>
",0
1802578,1802556,8,"<p>Are you sure it's not on two lines, like :</p>

<pre><code>#define TheVLM(x) VLM::Global()-&gt;x 
TheVLM(Run());
</code></pre>

<p>In that case, it's nothing specfic to C++, it is a standard use of Macro. The second line will generate the following call after macro substitution:</p>

<pre><code>VLM::Global()-&gt;Run();
</code></pre>
",1
1705834,1705813,1,"<p>Check whether <code>number</code> is equal to the first value from switch, if equal then output text, otherwise(else) check next number.</p>

<pre><code>if ( number == /*put here value to check*/ )
  // print some text
else
  // do something else
</code></pre>
",0
1705835,1705813,4,"<p>You replace switch statement with if-else</p>

<pre><code>if (number == 1)
{
}
else if (number == 2)
{
}
...
{
}
else
{
    // default here
}
</code></pre>
",1
1705837,1705813,0,"<p>Replace the case statement with an if statement:</p>

<pre><code>if (number == 1) {
    cout&lt;&lt;""My Favourite Subject is"";
} else if (number == 2) {
    cout&lt;&lt;""Fundamentals of Programming"";
} else if (number == 3) {
    cout&lt;&lt;""Exit"";
} else {
    cout&lt;&lt;""Invalid Data"";
} 
</code></pre>
",1
1705841,1705813,0,"<p><code>
if (number == 1) {<br>
cout &lt;&lt; ""blah1"";<br>
}<br>
else if (number == 2) {<br>
cout &lt;&lt; ""blah2"";<br>
}<br>
else if (number == 3) {<br>
cout &lt;&lt; ""blah3"";<br>
}<br>
else {
cout &lt;&lt; ""default"";<br>
}<br>
</code></p>
",0
1705871,1705813,1,"<p>This is my favorite, even though it is not what you asked for:</p>

<pre><code>string res =
  number==1 ? ""My Favourite Subject is"" :
  number==2 ? ""Fundamentals of Programming"" :
  number==3 ? ""Exit"" :
  number==4 ? ""Invalid Data"" :
  """";

cout&lt;&lt;res;
</code></pre>

<p>The good side here is that you don't have to constrain yourself to integer comparison. Instead of number==1 you can use any kind of complexComparisonReturningBoolean(number).</p>
",3
1705951,1705813,0,"<p>Try : <br />
<code>
    if (number &lt; 1 || number > 3) { <br />
        // <br />
    } else if (number == 1) {<br />
        // <br />
    } else if (number/2 == 1) {<br />
        // <br />
    } else if ((number - 1)/ 2 == 1) {<br />
        // <br />
    }<br />
</code>
This helps you get more math expertise than just checking for equality.</p>
",0
1706115,1705813,2,"<pre><code>//Hey this is fun!
int number;
cin&gt;&gt;number;

// ultra const!
static const char const * const table[] =
{
  ""Invalid Data"",
  ""My Favourite Subject is"",
  ""Fundamentals of Programming"",
  ""Exit""
};

cout&lt;&lt;table[number&amp;3];

//Who needs if statements!!?
</code></pre>
",0
1707857,1705813,1,"<p>Also just for fun:
Just use capital letters and semi-colon instead of colon. Ah, and don't forget to add an evil macro :)</p>

<pre><code>#define SWITCH(s) for(int switch_=s, b=1;b;b=0) {
#define CASE(n) } if ( switch_ == n ) {
#define DEFAULT }

int number;
cin&gt;&gt;number;

SWITCH(number)
{
    CASE(1);
        cout &lt;&lt; ""My Favourite Subject is"";
        break;
    CASE(2);
        cout &lt;&lt; ""Fundamentals of Programming"";
        break;
    CASE(3);
        cout &lt;&lt; ""Exit"";
        break;
    DEFAULT;
        cout &lt;&lt; ""Invalid Data"";
}
</code></pre>

<p>This kill the 'switch' and if 'for' loop are not allowed, it is also possible to use a BREAK macro, but it is even more evil.</p>
",4
1805631,1805575,4,"<p>You're almost there, you are just missing some curly braces, and you need to declare an array instead of a single string for the team names:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main(void)
{
 int leagueSize = 4;
 string teamNames[leagueSize];
 for (int i = 0; i &lt; leagueSize; i++) {
  cout &lt;&lt; ""Enter a team name:"" &lt;&lt; endl;
  cin &gt;&gt; teamNames[i];
 }

 cout &lt;&lt; endl;
 cout &lt;&lt; ""The following teams have been entered:"" &lt;&lt; endl;
 for (int i = 0; i &lt; leagueSize; i++) {
  cout &lt;&lt; ""Team "" &lt;&lt; (i + 1) &lt;&lt; "": "" &lt;&lt; teamNames[i] &lt;&lt; endl;
 }
}
</code></pre>
",0
1805717,1805575,2,"<p>A for controls structure (as well as if, else and while), executes the next single statement or block.  So in your example:</p>

<pre><code>for(int i = 0; i &lt; leagueSize; i++)
    cout &lt;&lt; ""Enter a Team Name""&lt;&lt;endl;
cin &gt;&gt; teamName;
</code></pre>

<p>Only the output statement is part of the for loop and the input statement happens only once after the entire loop is finished.</p>

<p>So, what you want to do is put your code in a block:</p>

<pre><code>for(int i = 0; i &lt; leagueSize; i++)
{
    cout &lt;&lt; ""Enter a Team Name""&lt;&lt;endl;
    cin &gt;&gt; teamName;
}
</code></pre>

<p>Many C and C++ coding styles recommend you always use a block even if you only have a single statement:</p>

<pre><code>for (...)
{
    one-statement;
}
</code></pre>
",0
1806112,1805575,0,"<p>Ok, so I've edited the code a bit, </p>

<p>The exact instructions say:
write a function to enter all the team names and set all the other variables </p>

<p>So its ok for me to do all that in one function isn't it?</p>

<p>This is the full function that I've come up with
void addTeam(T *T, char *teamName, int i)
{<br>
    str teamName[leagueSize];</p>

<pre><code>for(int i = 0; i &lt; leagueSize; i++)

{
cout &lt;&lt; ""Enter a Team Name""&lt;&lt;endl'
cin &gt;&gt; teamName[i]; 
}

cout &lt;&lt; endl;
cout &lt;&lt; ""The following teams have been entered:"" &lt;&lt; endl;
for (int i = 0; i &lt; leagueSize; i++) {
cout &lt;&lt; ""Team "" &lt;&lt; (i + 1) &lt;&lt; "": "" &lt;&lt; teamNames[i] &lt;&lt; endl;


T[i].name = teamName;
T[i].numPoints = 0;
T[i].numGoalsFor = 0;
T[i].numGoalsAgainst = 0;
T[i].numMatchesPlayed = 0;
T[i].numMatchesWon = 0;
T[i].numMatchesLost = 0;
T[i].numMatchesDrawn = 0;  
</code></pre>

<p>}</p>
",1
1807729,1807663,1,"<p>It seems boost library has a compatible version to be used with VC6 according to this <a href=""https://stackoverflow.com/questions/252492/whats-the-latest-version-of-boost-compatible-with-vc6"">question</a>. In that case you can use either <code>boost::iterator_facade</code> or <code>boost::iterator_adaptor</code> to easily write a <code>const_iterator</code> class. If you can't use boost, then the only option I see is to write a class derived from <code>std::iterator</code> and write all the required operator overloads.</p>
",0
1604583,1604487,1,"<p>Basically the underlying file system does not support that natively.<br>
So you need to do it manually.</p>

<ul>
<li>Open the file you want to modify in read mode.</li>
<li>Open a temporary file in write mode.</li>
<li>Copy from the read file into the write file.

<ul>
<li>Don't copy the line you want to delete.</li>
</ul></li>
<li>Close both files</li>
<li>Swap the files in the file system</li>
<li>Delete the old file.</li>
</ul>

<p>Looking at your code:<br>
You should not be doing this:</p>

<pre><code>while (!File.eof())
{
     getline(File,key,'\t');
     getline(File,description,'\n');
     Data[key] = description;
}
</code></pre>

<p>The last line in the file will not set the EOF correctly thus you will enter the loop again but the two getline() call will fail.</p>

<p>A couple of options:</p>

<pre><code>while (!File.eof())
{
     getline(File,key,'\t');
     getline(File,description,'\n');
     if(File) // Test to make sure both getline() calls worked
     {    Data[key] = description;
     }
}

// or more commonly put the gets in the condition

while (std::getline(File,line))
{
     key          = line.substr(0,line.find('\t'));
     description  = line.substr(line.find('\t')+1);
     Data[key]    = description;
}
</code></pre>
",0
1673110,1673066,0,"<p>Read each character individually, one by one.</p>

<p>If it's a digit (>= '0' &amp;&amp; &lt;= '9'), add one to the ""read digits"" counter and convert it to a number. If not, reset the ""read digits"" counter and continue to parse until you hit the end.</p>

<p>If you reset the counter when it has exactly two read digits, check if those two numbers add up to 9 and print them out in case they do.</p>

<p>Since you never need to store more than two numbers, you can have a static array that can hold these two digits.</p>
",1
1673121,1673066,0,"<p>Read this <a href=""http://www.cplusplus.com/doc/tutorial/files/"" rel=""nofollow noreferrer"">Input/Output with files</a></p>
",0
1673138,1673066,1,"<p>As you know C# and Java, how would you solve this problem in C# or Java? Start with that, and then you can modify that solution to fit with C++, the algorithm should be the same, and the syntax is more similar than you may think.</p>

<p>For instance, start with the following and implement the <code>OutputResult</code> function:</p>

<pre><code>class Test
{
    static void OutputResult(String contentsToParse)
    {
        // TODO: Implementation here.
    }

    static void Main()
    {
        String contentsOfTextBox = ""12 231 81 53 522 11 63"";
        OutputResult(contentsOfTextBox);
    }
}
</code></pre>
",0
1673522,1673066,1,"<p>This looks like a question about C++ operators.</p>

<ul>
<li>To read the integers from a string you could use the istringstream input operator: <strong>>></strong></li>
<li>To test if an integer has two digits you could use the built-in greater than <strong>></strong> and less than <strong>&lt;</strong> operators with the boolean and <strong>&amp;&amp;</strong> operator.</li>
<li>To separate the two digits you could use the built-in integer division <strong>/</strong> and modulus <strong>%</strong> operators.</li>
<li>To check the sum of the digits you could use the built-in addition <strong>+</strong> and equality <strong>==</strong> operators.</li>
</ul>
",1
1217219,1217173,8,"<p>You can also use a reference to a pointer int this case. Also, you may want to be aware of 2 other bugs which are in the original code (see my comments in the code snippet).</p>

<pre><code> void SetName( char *&amp; pszStr )
 {
     char* pTemp = new char[10];
     strcpy(pTemp,""Mark"");
     pszStr = pTemp;
 }

 int _tmain(int argc, _TCHAR* argv[])
 {
     char* pszName = NULL;
     SetName(pszName);

     // Don't need '*' in front of pszName.
     cout&lt;&lt; ""Name - "" &lt;&lt; pszName &lt;&lt; endl;

     // Needs '[]' to delete an array.
     delete[] pszName;
     return 0;
 }
</code></pre>
",1
1217177,1217173,55,"<p>Your pointer is being copied onto the stack, and you're assigning the stack pointer. You need to pass a pointer-to-pointer if you want to change the pointer:</p>

<pre><code>void SetName( char **pszStr )
{
    char* pTemp = new char[10];
    strcpy(pTemp,""Mark"");
    *pszStr = pTemp; // assign the address of the pointer to this char pointer
}

int _tmain(int argc, _TCHAR* argv[])
{
    char* pszName = NULL;
    SetName( &amp;pszName ); // pass the address of this pointer so it can change
    cout&lt;&lt;""Name - ""&lt;&lt;*pszName&lt;&lt;endl;
    delete pszName;
    return 0;
}
</code></pre>

<p>That will solve your problem. </p>

<hr>

<p>However, there are other problems here. Firstly, you are dereferencing your pointer before you print. This is incorrect, your pointer is a pointer to an array of characters, so you want to print out the entire array:</p>

<pre><code>cout&lt;&lt;""Name - ""&lt;&lt;pszName&lt;&lt;endl;
</code></pre>

<p>What you have now will just print the first character. <a href=""https://stackoverflow.com/questions/1217173/how-to-have-a-char-pointer-as-an-out-parameter-for-c-function/1217219#1217219"">Also</a>, you need to use <code>delete []</code> to delete an array:</p>

<pre><code>delete [] pszName;
</code></pre>

<hr>

<p>Bigger problems, though, are in your design.</p>

<p>That code is C, not C++, and even then it's not standard. Firstly, the function you're looking for is <code>main</code>:</p>

<pre><code>int main( int argc, char * argv[] )
</code></pre>

<p>Secondly, you should use <a href=""https://isocpp.org/wiki/faq/references"" rel=""noreferrer"">references</a> instead of pointers:</p>

<pre><code>void SetName(char *&amp; pszStr )
{
    char* pTemp = new char[10];
    strcpy(pTemp,""Mark"");
    pszStr = pTemp; // this works because pxzStr *is* the pointer in main
}

int main( int argc, char * argv[] )
{
    char* pszName = NULL;
    SetName( pszName ); // pass the pointer into the function, using a reference
    cout&lt;&lt;""Name - ""&lt;&lt;pszName&lt;&lt;endl;
    delete pszName;
    return 0;
}
</code></pre>

<p>Aside from that, it's usually better to just return things if you can:</p>

<pre><code>char *SetName(void)
{
    char* pTemp = new char[10];
    strcpy(pTemp,""Mark"");
    return pTemp;
}

int main( int argc, char * argv[] )
{
    char* pszName = NULL;
    pszName = SetName(); // assign the pointer
    cout&lt;&lt;""Name - ""&lt;&lt;pszName&lt;&lt;endl;
    delete pszName;
    return 0;
}
</code></pre>

<p>There is something that makes this all better. C++ has a <a href=""http://en.cppreference.com/w/cpp/string/basic_string"" rel=""noreferrer"">string class</a>:</p>

<pre><code>std::string SetName(void)
{
    return ""Mark"";
}

int main( int argc, char * argv[] )
{
    std::string name;

    name = SetName(); // assign the pointer

    cout&lt;&lt;""Name - ""&lt;&lt; name&lt;&lt;endl;

    // no need to manually delete
    return 0;
}
</code></pre>

<p>If course this can all be simplified, if you want:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

std::string get_name(void)
{
    return ""Mark"";
}

int main(void)
{
    std::cout &lt;&lt; ""Name - "" &lt;&lt; get_name() &lt;&lt; std::endl;        
}
</code></pre>

<p>You should work on your formatting to make things more readable. Spaces inbetween your operators helps:</p>

<pre><code>cout&lt;&lt;""Name - ""&lt;&lt;pszName&lt;&lt;endl;

cout &lt;&lt; ""Name - "" &lt;&lt; pszName &lt;&lt; endl;
</code></pre>

<p>Just like spaces in between English words helps, sodoesspacesbetweenyouroperators. :)</p>
",5
1217183,1217173,2,"<p>What you are writing is not C++, but C code that uses new instead of malloc, and delete instead of free. If you really want to write C++ code, start again. Read a book like <a href=""http://www.acceleratedcpp.com/"" rel=""nofollow noreferrer"">Accelerated C++</a>, which will teach you modern idiomatic C++.</p>
",2
1217185,1217173,4,"<p>Since you tagged as C++, why not pass in a std::string reference and fill it?</p>

<pre><code>void GetName(std::string &amp;strName)
{
    strName = ""Mark"";
}
</code></pre>

<p>Or simply return an std::string:</p>

<pre><code>std::string GetName2()
{
  return ""Mark"";
}
</code></pre>

<p>And call it like so</p>

<pre><code>std::string strName, strName2;
GetName(strName);
strName2 = GetName2();
assert(strName == ""Mark"");
assert(strName2 == ""Mark"");
//strName.c_str() returns the const char * pointer.
</code></pre>

<p>Then you don't have to worry about freeing any memory.</p>
",1
1696230,1696225,7,"<p>Undefined behavior because you are accessing a NULL pointer:</p>

<pre><code>A* a= NULL;
a-&gt;func(); // is not defined by the language
</code></pre>

<p>Note that even if <code>func()</code> didn't try to access a member variable, the behavior still is undefined. For example, the following code could run without errors, but it is not correct:</p>

<pre><code>   func()
   {
     cout&lt;&lt;""Inside A!! ""&lt;&lt;endl;
   }
</code></pre>

<hr>

<p><strong>EDIT:</strong> With my full respect, C++ doesn't suck!</p>

<p>What you need is a smart pointer, not a raw pointer. As my professor says always, if you don't know what you are doing in C/C++, it is better not to do it!</p>

<p>Use <code>boost::scoped_ptr</code>, and enjoy exception safety, automatic memory management, zero overhead and NULL checking:</p>

<pre><code>struct test
{
    int var;
    void fun()
    {
        std::cout &lt;&lt; var;
    }
};

int main()
{
    boost::scoped_ptr&lt;test&gt; p(NULL);
    p-&gt;fun(); // Assertion will fail, Happy debugging :)
}
</code></pre>
",12
1696249,1696225,12,"<p><strong>This is undefined behaviour. You must never call functions on a null pointer.</strong></p>

<p>With that out of the way, let's answer the question I think you're asking: <em>why do we get partway into the function anyway?</em></p>

<p>When you are invoking UB, the compiler is free to do anything, so it's allowed to emit code that works anyway. That's what happens on some (many?) systems in this particular case.</p>

<p>The reason that you're able to call the function on a null pointer successfully is that your compilers don't store the function ""in"" the object. Rather, the above code is interpreted somewhat like this:</p>

<pre><code>class A {
    int _dmember;
};

void A::func(A *this) {
    cout &lt;&lt; ""Inside A!!"" &lt;&lt; endl;
    cout &lt;&lt; this-&gt;_dmember &lt;&lt; endl;
}

int main() {
    A *a = ...;
    A::func(a);
}
</code></pre>

<p>So, you see there is nothing that actually prevents you from calling a function on a null pointer; it'll just invoke the body of the function, with the <code>this</code> pointer set to null. But as soon as the function tries to dereference the <code>this</code> pointer by accessing a field inside the class, the operating system steps in and kills your program for illegal memory access (called segmentation fault on Linux, access violation on Windows).</p>

<p><em>Nitpicker's corner</em>: Virtual functions are a different story.</p>
",5
1696252,1696225,0,"<p>Most compilers just pass the pointer to the class as the first parameter (The this pointer).  If you don't go on to de-reference the this pointer then you are not actually going to cause a crash.  Your this pointer, inside the functiom, will simply be NULL.</p>

<p>As AraK pointed out this is undefined behaviour so your mileage mat vary...</p>
",0
1696261,1696225,0,"<p>Aren't you supposed to allocate a memory for your pointer? I just wonder what is the intention to call a function of a NULL pointer? It's supposed to crash immediately. It doesn't crash on the line where you don't call to A member _dmember,but the moment you call it your function crashes cause the object is simply not allocated. _dmember points on undefined memory... That's why it crashes  </p>
",1
1696263,1696225,1,"<p>Dereferencing a null pointer is undefined behaviour.
Everything could happen, so don't do it.
You must check that the pointer is valid before dereferencig it. this pointer cannot be null so you wouldn't avoid the undefined behaviour.</p>
",0
1696668,1696225,0,"<p>Any pointer variable is supposed to point to some object.</p>

<p>Your declaration <code>A * a = NULL;</code>
does not point anywhere and so will not yield the results as it should.</p>

<p>You can however try this </p>

<pre><code>A * a = NULL;
A b;
a=&amp;b;
a-&gt;func();
</code></pre>

<p>this will yield the output.</p>
",0
1696272,1696225,0,"<p>Its a null pointer, you simply can't define what should happen if we call a function on it.</p>
",0
1696783,1696225,0,"<p>Since there are no virtual functions in your class, it's easier here to think about what C code would be generated to represent this type. Approximately:</p>

<pre><code>#include &lt;stdio.h&gt;


typedef struct
{
  int d_;
} A;


FILE* print_a_to(A* a, FILE* dest)
{
  return fprintf(dest, ""Inside A!! \n"") &lt; 0 ||
         fprintf(dest, ""%d"", a-&gt;d_) &lt; 0 ?
         NULL :
         dest;
}


int main(int argc, char* argv[])
{
  A* a = NULL;
  return NULL == print_a_to(a, stdout) ?
         -1 :
         0;
}
</code></pre>

<p>Look at the second line of function <code>print_a_to</code>; see the dereferencing of pointer <code>a</code>? Per the first line of function <code>main</code>, you're passing NULL as the value of pointer <code>a</code>. Dereferencing a null pointer here is equivalent to calling a member function on your class <em>that needs access to its member variables</em> through a null pointer.</p>
",0
1700835,1696225,0,"<p>if i was'nt clear, 
i am not trying to do deliberately below:</p>

<pre><code>A* a=NULL;    
a-&gt;f(); 
</code></pre>

<p>i wrote that code just to check why is it working , and ofcourse i was disappointed and my reason to be disapointed is that i debug very big program in Redhat-Linux , through log-files concept( meaning - Printing Entering,Exiting from functions to logs, including printing imporant values).
AND, on my way on the logs i hoped that if im on specific STACK of function calls i hoped at least the instances operating these functions are alive, but as i discovered and disapointed its not ought to be , which for me disapointement because it makes the debug through log files even more difficult. </p>
",0
1607036,1606969,0,"<p>my comments:</p>

<p>make creators to do the things, for example:</p>

<pre><code>template&lt;class t&gt;
struct creator_new { // a creator using new()/delete()
    static t *Create(void) 
    {
        return new t;
    }
    static void Destroy(t *p) 
    {
        delete p;
    }
};
</code></pre>

<p>you could extend the creator to check memory leak, or use memory pool to manage your objects etc. </p>
",1
1609131,1606969,2,"<p>No the checks are unnecessary.</p>

<p>Have a look at Alexandrescu's Loki's <a href=""http://loki-lib.cvs.sourceforge.net/loki-lib/loki/include/loki/SmallObj.h?view=markup"" rel=""nofollow noreferrer"">SmallObject allocator</a>, you just inherit from SmallObject and it does all the heavy lifting for you!</p>

<p>And do not forget to overload all versions of new and delete:</p>

<ul>
<li>simple version</li>
<li>array version</li>
<li>placement version</li>
</ul>

<p>Otherwise you might have some troubles.</p>
",3
1321758,1321735,4,"<p><a href=""http://www.eit.ihk-edu.dk/subjects/cpp/"" rel=""nofollow noreferrer"">This site</a> and <a href=""http://www.functionx.com/cpp/examples/index.htm"" rel=""nofollow noreferrer"">this site</a> may be worth looking for you.</p>
",0
1321766,1321735,2,"<p>You're right. Reading books is not likely to help unless you practice what you learn.</p>

<p>You didn't say what kind of examples you need, and obviously it's important to choose examples which mean something to you - that is, applications which you can see the value of.</p>

<p>Can you suggest some topics which interest you? Like business applications or games, scientific or otherwise?</p>
",4
1321770,1321735,4,"<p>If your books don't give you tasks to chew on, get better books. </p>

<p>Look at those mentioned <a href=""https://stackoverflow.com/questions/1231942/learning-c-without-an-ide/1232035#1232035"">here</a>. </p>
",1
1794118,1794111,0,"<p>you need <code>#include &lt;ctype&gt;</code> for tolower.</p>

<p>the functions getItemNumber and checkItemNumber are not defined by any C standard, you should ask the one from which you got the code where getItemNumber and checkItemNumber are defined.</p>
",5
1694869,1694785,2,"<p>The class Obstacle needs a virtual destructor.  Change the destructor definition to be:</p>

<pre><code>virtual ~Obstacle();
</code></pre>

<p>The definition of a destructor also creates the vtable for a class with virtual functions.  It also ensures that a delete of a derived class instance through a base class pointer does the right thing.</p>
",2
1694797,1694785,2,"<p>Apparently you are missing and object file or library.  The one which defines and declares the Obstacle object.</p>

<p>A good place to look for that is in the header files (*.h) files referenced in  Myworld as this will give you an idea of what cpp/libraries (typically with the same name) are underlying the objects used by Myworld.</p>

<p>Edit, given Lisa's reply:<br>
No, you do not need to add any *.hh files in the source code.  The problem is at link-time, not compile-time.<br>
Isn't there an Obstacle.cpp file somewhere?  This would need to be compiled and the corresponding .o files would need to be added to the last gcc line in the make.</p>

<p>Bingo!  Upon seeing Obstacle.hh<br>
These two virtual Methods are not pure virtual, and hence the compiler expects them to be defined somewhere, somehow.  And also the constructor and destructor are not defined. <br>
The easiest would probably be to write something like:<br></p>

<pre><code>class Obstacle{
public:
    // Obstacle();
    virtual bool collidesWith(double x,double y) = 0;  // = 0 makes them pure virtual
    virtual void writeMatlabDisplayCode(std::ostream &amp;fs) = 0;
    //~Obstacle();
};
</code></pre>

<p>Alternatively you could declare a small do-nothing constructor and destructor or you could make the destructor [pure] virtual to force the derived classes to implement a destructor...</p>
",4
1694895,1694785,5,"<p>You declare a non-abstract class <code>Obstacle</code>, but you don't implement all its member functions.</p>

<p>Better declare it as abstract class:</p>

<pre><code>class Obstacle{
public:
    Obstacle(){} // this is superfluous, you can (and should) remove it
    virtual bool collidesWith(double x,double y) = 0;
    virtual void writeMatlabDisplayCode(std::ostream &amp;fs) = 0;
    virtual ~Obstacle(){}
};
</code></pre>

<p>The reason is a heuristic you'll find in many C++ compilers - to avoid the needless creation of duplicate vtables and typeinfos for a class they are created when its first non-inline virtual member function (if it has one) is defined.</p>

<p>Your code foils this scheme: You include <code>Obstacle.hh</code> into some compilation unit, the compiler sees a class <code>Obstacle</code> that has <code>collidesWith</code> as first non-inline virtual member function, but it isn't defined in the current compilation unit, so the compiler thinks it can defer the creation of vtable and typeinfo for the class. Because there is no definition of <code>collidesWith</code>, they both end up missing when the program is linked.</p>
",0
1694802,1694785,0,"<p>It looks like you forgot to link in the object file that contains the definition of Obstacle. The programs compile correctly because they included the prototypes, but at link-time, there is no matching symbol for the prototypes.</p>
",3
818744,818736,0,"<p>As soon as you're trying to deal with <em>both</em> Windows and a UNIX system like Linux, life gets more complicated.</p>

<p>What are the service requirements you have to satisfy?  Can you control when client systems get upgraded?  How many systems will you need to support?  How much of a backward-compatibility requirement do you have.</p>
",1
818751,818736,3,"<ol>
<li><p>Yes, using libraries is good, but the idea of &quot;simply&quot; replacing a library with a new one may be unrealistic, as library APIs tend to change and apps often need to be updated to take advantage of, or even be compatible with, different versions of a library.  With a good amount of <a href=""http://en.wikipedia.org/wiki/Integration_testing"" rel=""nofollow noreferrer"">integration testing</a> though, you'll be able to 'support' a range of different versions of the library.  Or, if you control the library code yourself, you can make sure that changes to the library code never breaks the application.</p>
</li>
<li><p>In Windows DLLs are the direct equivalent to shared libraries (so) in Linux, and if you compile both in a common environment (either cross-compiling or using MingW in Windows) then the linker will just do it the same way.  Presuming, of course, that all the rest of your code is cross-platform and configures itself correctly for the target platform.</p>
<p>IMO, <a href=""http://en.wikipedia.org/wiki/DLL_hell"" rel=""nofollow noreferrer"">DLL hell</a> was really more of a problem in the old days when applications all installed their DLLs into a common directory like C:\WINDOWS\SYSTEM, which people don't really do anymore simply because it creates DLL hell.  You can place your shared libraries in a more appropriate place where it won't interfere with other non-aware apps, or - the simplest possible - just have them in the same directory as the executable that needs them.</p>
</li>
</ol>
",1
818777,818736,3,"<p>I'm not entirely convinced that separating out the executable portions of your program in any way simplifies upgrades.  It might, maybe, in some rare cases, make the update installer smaller, but the effort will be substantial, and certainly not worth it the one time you get it <em>wrong</em>.  Replace all executable code as one in most cases.</p>

<p>On the other hand, you want to be very careful about messing with anything your users might have changed.  Draw a bright line between the part of the application that is just code and the part that is user data.  Handle the user data with care.</p>
",2
818786,818736,2,"<p>If it is an application my first choice would be to ship a statically-linked single executable. I had the opportunity to work on a product that was shipped to 5 platforms (Win2K,WinXp, Linux, Solaris, Tru64-Unix), and believe me maintaining shared libraries or DLLs with large codebase is a hell of a task. 
Suppose this is a non-trivial application which involves use of 3rd Party GUI, Threads etc. Using C++, there is no real <em>one way</em> of doing it on all platforms. This means you will have to maintain different codebases for different platforms anyway. Then there are some wierd behaviours (bugs) of 3rd Party libraries on different platforms. All this will create a burden if application is shipped using different library versions i.e. different versions are to be attached to different platforms. I have seen people shipping libraries to all platforms when the fix is only for a particular platform just to avoid the versioning confusion. But it is not that simple, customer often has a different angle to how he/she wants to upgrade/patch which is also to be considered.</p>

<p>Ofcourse if the binary you are building is huge, then one can consider DLLs/shared-libraries. Even if that is the case, what i would suggest is to build your application in the form of layers like:-
Application-->GUI-->Platform-->Base-->Fundamental</p>

<p>So here some libraries can have common-code for all platforms. Only specific libraries like 'Platform' can be updated for specific behaviours. This will make you life a lot easier.</p>

<p>IMHO a DLL/shared-library option is viable when you are building a product that acts as a complete solution rather than just an application. In such a case different subsystems use common logic simultaneously within your product framework whose logic can then be shared in memory using DLLs/shared-libraries.</p>

<p>HTH,</p>
",2
818788,818736,0,"<p>To answer your question with a question, why are you making the application native if being portable is one of the key goals? </p>

<p>You could consider moving to a a virtual platform like Java or .Net/Mono. You can still write C++ libraries (shared libraries on linux, DLL's on windows) for anything that would be better as native code, but the bulk of your application will be genuinely portable. </p>
",2
1845880,1845869,1,"<p>Enum is not a class/struct, hence you can't define a conversion operator for it.</p>

<p>I would suggest writing a global-scope (within a namespace) function to make the proper conversions.</p>

<p>Something along the lines of:</p>

<pre><code>char convert (Month m) {
  switch (m) {
    case (jan): return 'j';
    case (feb): return 'f';
    default:    return 'x';
  }
}
</code></pre>
",3
1845924,1845869,0,"<p>You can't declare member functions for <code>enum date_state</code>, because it is an enum, but you could do so for <code>class Date</code>:</p>

<pre><code>class Date {
...
    enum date_state 
    {
        good, bad_day, bad_month, bad_year,
    } err_flag;

    operator char() {
        return err_flag;
    }
}
</code></pre>

<p>But would rather recommend using a normal member function instead, because a conversion operator might easily be used accidently.</p>
",0
484775,484758,0,"<p>Object methods have a hidden ""this"" argument.  If you pass the method to another class, what gets filled into the ""this"" argument?  You might be able to do it with static (Class) methods.</p>
",0
484777,484758,2,"<p>Function pointers (that is pointers to unbound functions) and pointers-to-methods (that is pointers to non-static functions bound to a class definition), are different in <code>c++</code>. This is because non-static methods have an implicit <code>this</code> argument which requires that they always be called in the context of a instance of their class.</p>

<p>You're trying to pass a method-pointer to a constructor that takes a function-pointer. Which won't work. </p>
",0
484778,484758,4,"<p>Yes, the type of <code>&amp;MainClass::myFunction</code> is a pointer-to-member type whereas <code>string(*)(int)</code> is a pointer-to-function type. They are not compatible as you have to use a reference or pointer to a class instance and use the .* or ->* operators to use a pointer-to-member, whereas a pointer to a function is not attached to a class and can be called directly.</p>
",0
484779,484758,8,"<p>your syntax is correct for a C style function pointer. Change it to this:</p>

<pre><code>Derived(string (MainClass::*funPtr)(int)) : strFunction(funPtr) {}
</code></pre>

<p>and</p>

<pre><code>string (MainClass::*strFunction)(int value);
</code></pre>

<p>remember to call <code>strFunction</code>, you will need an instance of a MainClass object. Often I find it useful to use typedefs.</p>

<pre><code>typedef string (MainClass::*func_t)(int);
func_t strFunction;
</code></pre>

<p>and</p>

<pre><code>Derived(func_t funPtr) : strFunction(funPtr) {}
</code></pre>
",5
484782,484758,4,"<p>You are trying to pass a pointer to a member function of the class MainClass, but the function expects a pointer to an ordinary, ie non-member, function. A good summary is <a href=""http://www.parashift.com/c++-faq-lite/pointers-to-members.html"" rel=""nofollow noreferrer"" title=""here"">here</a></p>

<p>The difference is important because member functions have a hidden extra parameter which tells the function which ""this"" pointer to apply the function to. So the pointer types aren't interchangeable.</p>
",0
484786,484758,0,"<p>As the compiler warning is indicating, member function pointers are completely different from regular function pointers.</p>
",0
484793,484758,5,"<p>You can learn more about the grave wickedness that is <a href=""http://www.codeproject.com/KB/cpp/FastDelegate.aspx"" rel=""nofollow noreferrer"">C++ member function pointer syntax here</a>.</p>
",0
484818,484758,2,"<p>Another syntax issue :</p>

<pre><code>
    // assign strFunction to the function pointer passed in
    Derived(string (*funPtr)(int)) : strFunction(funPtr);
</code></pre>

<p>replace for :</p>

<pre><code>
    // assign strFunction to the function pointer passed in
    Derived(string (*funPtr)(int)) : strFunction(funPtr) {};
</code></pre>
",0
484887,484758,1,"<p>You may want to look into using <a href=""http://msdn.microsoft.com/en-us/library/bb982702.aspx"" rel=""nofollow noreferrer"">std::tr1::bind</a> and <a href=""http://msdn.microsoft.com/en-us/library/bb982519.aspx"" rel=""nofollow noreferrer"">std::tr1::function</a> similar to this (untested) code: </p>

<pre><code>class Derived: public Base
{
  public:
    typedef std::tr1::function&lt;string(int)&gt; StringFunc;

    Derived(StringFunc);

  ...

  private:
    StringFunc strFunction;
}
</code></pre>

<p>and in MainClass constructor:</p>

<pre><code>myBase = new Derived(std::tr1::bind(&amp;MainClass::myFunction, *this, _1);
</code></pre>

<p>The bind function basically binds the member function to a particular object. Which takes care of the this pointer that is inserted by the compiler.</p>
",0
1115640,1115633,16,"<p><code>Using namespace ...</code> was not invented just for fun.</p>

<p>If you have a good reason to use it, then do so (and the frequent use of stuff from these namespaces is the exact good reason). Don't listen to fanatics who tell you everything they don't want to do for obscure reasons themselves is evil.</p>

<p>However, a good source for reasoning in these regards is C++ FAQ lite:
<a href=""http://www.parashift.com/c++-faq-lite/coding-standards.html#faq-27.5"" rel=""noreferrer"">http://www.parashift.com/c++-faq-lite/coding-standards.html#faq-27.5</a></p>

<p>I have read it and still decided to use it like you want to. Now you can make your own informed decision :-)</p>
",2
1115647,1115633,5,"<p>The fact that the code is cluttered with ::std:: prefixes is indeed annoying when reading the code.  However, you want to know what namespace a symbol was in as easily as possible...</p>

<p>Now isn't that the IDE's job?  </p>

<p>As long as my IDE doesn't support 'view short typenames', I'm leaning towards <code>using</code> declarations for commonly known symbols (i.e. the STL, boost, ...).  Readibility first!</p>
",7
1115649,1115633,16,"<p>I use <code>using namespace</code> only in C++ files, not in headers. Besides, using hole namespace not needed in most of times. For instance, you could write <code>using boost::shared_ptr</code> or <code>using std::tr1::shared_ptr</code> to easily switch between <code>shared_ptr</code> implementations.</p>

<p>Sample:</p>

<pre><code>#include &lt;iostream>

using std::cout;

int main()
{
    cout &lt;&lt; ""test"" &lt;&lt; std::endl;
    return 0;
}
</code></pre>
",5
1115695,1115633,7,"<p>My own rules are:</p>

<ul>
<li>in header files, all names are explicitly qualified e.g. <code>std::string</code>, <code>std::cout</code> etc. at their point of use</li>
<li>in source files, place using clauses for the commonly used names at the top of the file eg. using <code>std::string;</code></li>
<li>never use <code>using namespace xxxx;</code> in production code.</li>
</ul>
",0
1115939,1115633,4,"<p>One factor to keep in mind is that the <code>std</code> namespace is named this way to make it short. A <code>std::</code> prefix is only 5 characters, hardly the end of the world. That's unlike .NET's namespaces like <code>System.Collections.Generic</code>. It is designed to be easy to type.</p>

<p>For that reason, I usually just type out the <code>std</code> prefix. Boost isn't too bad either, so I usually type that out too.</p>

<p>I usually alias the sub-namespaces (<code>boost::filesystem</code> for example) to something shorter (<code>namespace fs = boost::filesystem</code> for example)</p>

<p>Using typedefs liberally helps too.
And if I need to reference a type often, I might just add a <code>using</code> for it.</p>

<p>But I generally try to avoid <code>using</code>'s in headers especially, and when I do use them, I prefer to put them at function scope to avoid polluting the actual namespace.</p>

<p>C++ offers a lot of tools that let you avoid having to specify the namespace, without polluting the global namespace.</p>
",2
1116675,1115633,1,"<p>In header files, yes. That is because using ""using std::name_of_std_member;"" or using ""using namespace std;"" in a header file will cause all other files which include that header file to see the symbol in the global scope, thus defeating the purpose of namespaces. In source files, however, it is perfectly ok to use ""using namespace std;"" to make the symbols of that namespace available with the ""std::"" prefix.</p>
",0
1385991,1385890,-2,"<p>If you don't want to use a package manager, then don't use a package manager.
apt is a great tool and is there to help, but you aren't required to use it.
On Ubuntu, you might want to just use dpkg instead of apt and so that none
of the dependencies will be automatically updated and avoid upgrading the
libraries that are causing problems.  Or, just install everything directly
from source.  If you go that route, install to  /usr/local or some
non-standard location.  (ie, do NOT configure --prefix=/usr &amp;&amp;
make &amp;&amp; make install.  Use the default /usr/local or $HOME for prefix.)</p>

<p>Note that doing this is a heinous kludge, and you have bigger problems.  If you 
are relying on libraries that are unstable, then you probably ought to consider
removing your dependency on those libraries.  Also, mixing usage of dpkg with
apt will cause maintenance headaches.  If you do that, only do it on your
developmental boxes (eg, not on production servers.)  Your primary concern
should be to get your package working correctly with the package management
system, and one part of this may involve fixing the packaging of all the
libraries you depend on.</p>
",4
1385911,1385890,4,"<p>One way to solve that problem is to staticaly link your libraries but that will increase your application size.</p>
",0
1147606,1147588,0,"<p>You can try to obfuscate your code - but you have little choice in C++03 asides from including template code in header files.</p>

<p>Vandevoorde does describe another technique in his book: Explicit instantiation  - but that entails having to explicitly instantiate all possible useful combinations.</p>

<p>But for the most comprehensive review of this topic read chapter 6 from C++ Templates: The Complete Guide.</p>

<p>Edit (in response to your comment): You have two options for writing generic code without using templates:<br>
  1)  Preprocessor - still requires header files<br>
  2)  using void* - yuk - incredibly unsafe</p>

<p>So no, i do not recommend not using templates for solving problems that templates were specifically designed (albeit somewhat flawed) for.</p>
",3
1147766,1147588,3,"<p>Prior to templates, type-agnostic C++ code had to be written using runtime polymorphism. But with templates as well, you can combine the two techniques.</p>

<p>For example, suppose you wanted to store values of any type, for later retrieval. Without templates, you'd have to do this:</p>

<pre><code>struct PrintableThing
{
    // declare abstract operations needed on the type
    virtual void print(std::ostream &amp;os) = 0;

    // polymorphic base class needs virtual destructor
    virtual ~PrintableThing() {}
};

class PrintableContainer
{
    PrintableThing *printableThing;

public:
    // various other secret stuff

    void store(PrintableThing *p);
};
</code></pre>

<p>The user of this library would have to write their own derived version of <code>PrintableThing</code> by hand to wrap around their own data and implement the <code>print</code> function on it.</p>

<p>But you can wrap a template-based layer around such a system:</p>

<pre><code>template &lt;T&gt;
struct PrintableType : PrintableThing
{
    T instance;

    virtual void print(std::ostream &amp;os)
        { os &lt;&lt; instance; }

    PrintableType(const T &amp;i)
        : instance(i) {}
};
</code></pre>

<p>And also add a method in the <em>header</em> of the library, in the declaration of the <code>PrintableContainer</code> class:</p>

<pre><code>template &lt;class T&gt;
void store(const T &amp;p)
{
    store(new PrintableType(p));
}
</code></pre>

<p>This acts as the bridge between templates and runtime polymorphism, compile-time binding to the <code>&lt;&lt;</code> operator to implement <code>print</code>, and to the copy-constructor also (and of course also forwarding to the nested instance's destructor).</p>

<p>In this way, you can write a library entirely based on runtime polymorphism, with the implementation capable of being hidden away in the source of the library, but with a little bit of template ""sugar"" added to make it convenient to use.</p>

<p>Whether this is worth the trouble will depend on your needs. It has a purely technical benefit in that runtime polymorphism is sometimes exactly what you need, in itself. On the downside, you will undoubtedly reduce the compiler's ability to inline effectively. On the upside, your compile times and binary code bloat may go down.</p>

<p>Examples are <code>std::tr1::function</code> and <code>boost::any</code>, which have a very clean, modern C++ template-based front end but work behind the scenes as runtime polymorphic containers.</p>
",0
1147940,1147588,0,"<p>One problem with templates is that they require compiled code. You never know how the end-user will specialize/instantiate your templates, so your dll-file would have to contain all possible template specializations in compiled form. This means that to export pair&lt;X,Y&gt; template you would have to force the compilication of pair&lt;int,float&gt;, pair&lt;int,string&gt;, pair&lt;string,HWND&gt; and so on... to infinity..</p>

<p>I guess more practical solution for you would be to un-template private/hidden code. You can create special internal functions that would only be compiled for single template specialization. In the following example internal_foo-function is never called from MyClass where A is not int.</p>

<pre><code>template&lt;class A&gt;
class MyClass
{
  int a;
  float b;
  A c;

  int foo(string param1);
  {
     ((MyClass&lt;int&gt;*)this)-&gt;internal_foo(param1);
  }
  int internal_foo(string param1);  // only called on MyClass&lt;int&gt; instances
};

template&lt;&gt;
__declspec(dllexport) int MyClass&lt;int&gt;::internal_foo(string param1)
{
  ... secret code ...
}
</code></pre>

<p>This of course is a hack. When using it you should be extra careful not to use member variable ""c"", because it's not always integer (even though internal_foo thinks that it is). And you can't even guard yourself with assertions. C++ allows you to shoot yourself in the foot, and gives you no indications about it until it's too late.</p>

<p>PS. I haven't tested this code so it might require some fine tuning. Not sure for example if __declspec(dllimport) is needed in order for compiler to find internal_foo function from dll-file...</p>
",0
1148787,1147588,0,"<p>With templates you cannot avoid shipping the code (unless your code only works with a fixed set of types, in which case you can explicitly instantiate). Where I work we have a library that must work on POD types (CORBA/DDS/HLA data definitions), so at the end we ship templates.</p>

<p>The templates delegate most of the code to non-templated code that is shipped in binary form. In some cases, work must be done directly in the types that were passed to the template, and cannot thus be delegated to non-templated code, so it is not a perfect solution, but it hides enough part of the code to make our CEO happy (the people in charge of the project would gladly provide all the code in templates).</p>

<p>As Neil points in a comment to the question, in the vast majority of cases there is nothing magical in the code that could not be rewritten by others.</p>
",1
1147961,1147588,1,"<p>I've got some news for you, buddy. Even with <code>export</code>, you'd still have to release all of your template code -- <code>export</code> just makes it that you don't have to put the definitions in a header file. You're totally stuck. The only technique you can use is split off some functions that are non-templates and put them into a different class. But that's ugly, and usually involves <code>void*</code> and placement <code>new</code> and <code>delete</code>. That's just the nature of the beast. </p>
",1
1685660,1685549,0,"<p>Variable s is local the function ==> it will get destroyed when function returns since
local variable have auto storage type and life time is limited to scope in which they are defined.</p>

<p>You can change storage type of variable s to static, static variables life time is whole program so you can return reference of it.</p>
",0
1685562,1685549,6,"<p>Your <code>s</code> variable is allocated on the stack, and then you are returning a pointer to it; however, when the function ends, <code>s</code> no longer exists and the pointer is no longer valid.  </p>

<p>You could either dynamically allocate <code>s</code> and return a reference/pointer to it, or you could return a copy of <code>s</code> rather than a reference.</p>

<p>In other words, you have a case of a <a href=""http://en.wikipedia.org/wiki/Dangling_pointer"" rel=""nofollow noreferrer"" title=""And that sounds like a personal problem."">dangling pointer</a>.</p>
",0
1497349,1497325,0,"<p>I would follow the error report.</p>
",0
1497354,1497325,3,"<p>In any case, your code doesn't make much sense in the following declaration.</p>

<pre><code>template&lt;typename T&gt; 
classA&lt;TEMP&gt;::strA classA&lt;TEMP&gt;::obj_str;
</code></pre>

<p>Because the <code>T</code> parameter is used nowhere in the declaration. I think you either wanted to write one of the following things:</p>

<pre><code>// definition of static member of template
template&lt;typename T&gt; 
typename classA&lt;T&gt;::strA classA&lt;T&gt;::obj_str;

// ... or declaration of static member specialization for `T=TEMP` of template
template&lt;&gt; 
classA&lt;TEMP&gt;::strA classA&lt;TEMP&gt;::obj_str;
</code></pre>

<p>I suspect it was the first one. For the compiler crash - that surely shouldn't happen in any case :)</p>

<hr>

<p><strong>Edit:</strong> The bug has already been fixed in 4.4.1 at least - i think there is no need for reporting anymore. </p>
",1
1713080,1713066,3,"<p><a href=""http://en.wikipedia.org/wiki/C%2B%2B0x"" rel=""nofollow noreferrer"">C++0x</a> will be compatible with both older C and older C++.</p>
",0
1713109,1713066,0,"<p><strong>Edited</strong></p>

<p><a href=""http://en.wikipedia.org/wiki/Managed_Extensions_for_C%2B%2B"" rel=""nofollow noreferrer"">Managed C++</a> and <a href=""http://en.wikipedia.org/wiki/C%2B%2B/CLI"" rel=""nofollow noreferrer"">C++.NET</a> is compatible with older C and C++. I dont know how compatible it is.</p>
",2
1713117,1713066,1,"<p>Are you asking if there is a new language, or something similar to C++ that maintains backwards compatibility?  For example, are you looking for something like C# that also supports C/C++ syntax?  If so, you might want to look at ""Managed C++"", which turns C++ into a language that runs on the CLR.  By running on the CLR, it can interact with other languages such as C#.  However, there are some things with managed C++ that might not make it an ideal language to work with. (Such as a few new keywords)</p>

<p>If you're talking about the ""soon to be released"" C++ (known as C++0x), it is supposed to maintain compatibility with older C++ code.  It should be very compatible with C language features, too.  (If you're talking about older C/C++ code being code developed in the mid to late 1990s, which uses C++ features like objects, static_casts and inheritance, but doesn't use items from the STL, it should be near 100% compatible)</p>
",0
1713118,1713066,0,"<p>I doubt that there are any alternative languages that are 100% (or even 90%) compatible with existing C++ code. C++ is one of the most-complex programming languages ever, so building a new language on top of that would tend to lead to a very complex language.</p>
",0
1713124,1713066,1,"<p>There are quite a few extensions of C++. For one, there's <a href=""http://en.wikipedia.org/wiki/Blocks_%28C_language_extension%29"" rel=""nofollow noreferrer"">Blocks</a> which are used in OSX 10.6's Grand Central Dispatch thread system. There's also <a href=""http://en.wikipedia.org/wiki/C%2B%2B0x"" rel=""nofollow noreferrer"">C++0x</a>, which is the name for the next update of the C++ standard. Many compilers also have their own extensions. <a href=""http://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Extensions.html"" rel=""nofollow noreferrer"">Here</a> are GCC's c++ extensions. C++ it's self is almost an extension of C. C code can usually be compiled with a C++ compiler with only a few changes, and C libraries can be used in C++.</p>
",0
1605426,1605400,13,"<p>In the first case <code>cmp</code>  is declared as a member function of the <code>class sample</code> and hence requires <code>this</code> pointer for calling it. Since the <code>this</code> pointer is not available compiler is complaining about it. You can make it work by declaring <code>cmp</code> as <code>static</code> function since static functions do not require this pointer for calling. In the second case, since cmp is declared as a stand-alone function again it will behave same as static function. In the third case (with overloaded operator), the sort algorithm will take care of calling the function for each object in the vector and hence it compiles.</p>
",0
1605443,1605400,6,"<p>Since <code>cmp</code> is not related to any particular instance of sample, make it a static member function.</p>
",0
1605489,1605400,6,"<p>The third approach which can be listed in your possibilities is using operator():</p>

<pre><code>bool operator() (const s&amp; a, const s&amp; b) const
{
    if (a.x == b.x)
        return a.y &lt; b.y;
    else
        return a.x &lt; b.x;
}

sort(vec.begin(), vec.end(), *this);
</code></pre>
",3
1606584,1605400,0,"<p>I think defining <code>cmp</code> outside the class is best, because you should only make a function a member function when you need it to access some private feature in the class, and logically it feels right for it to be there. <code>cmp</code> is just a utility function that provides your class <code>sample</code> with functionality for its implementation, but it doesn't actually need to access private members. Furthermore, it's probably not going to be invoked in the context of an object (its only operations work on its parameters; nothing on the <code>this</code> pointer), nor must it be invoked in the context of a class <code>sample::cmp</code>. While it may seem like a trivial point, giving functions or code in general unnecessary breadth of access can be the start of the source of many a software bug or design convolution.</p>

<p>The added benefit of doing the above is that your invocation of <code>std::sort</code> will work, which answers your question.</p>
",0
1790972,1790949,5,"<p>No, all three have external linkage. Member functions of a non-local class always have external linkage in C++. Moreover, <code>inline</code> has no effect on linkage, even if it is a non-member function.</p>

<p>Linkage has no effect on efficiency. Inlining might have, but it depends on too many variables.</p>
",8
1790985,1790949,0,"<p><code>inline</code> doesn't have ""linkage"" per say, it usually (though the compiler does not have to comply) just puts the code literally, uhh, inline.</p>

<p>You see internal linkage with anonymous namespaces and (standalone, not class) static functions, e.g.</p>

<pre><code>namespace
{
  void foo() { ... }
}
</code></pre>

<p>Or:</p>

<pre><code>static void foo() { ... }
</code></pre>

<p>Internal linkage means that the compiler can do some extra optimization (because it knows exactly how the function is being used) and doesn't have to create an exported symbol, which means less relocations on startup (meaning faster startups -- though modern linkers do lazy symbol resolution...)</p>
",3
1791023,1790949,-1,"<p>The second one has internal linkage since you declared it static. It can be referenced only in the same translation unit.</p>
",2
1791429,1790949,1,"<p>just to be clear.</p>

<pre><code>class fooClass
{
   inline void fooInline() { /*blah blah*/ }
   static void fooStatic() { /*blah blah*/ }
   void foo() { /*blah blah*/ }
};
</code></pre>

<p>As noted elsewhere.  <code>inline</code> has no affect on linkage.  Also <code>static</code> used as above in a method declaration/definition does not carry any linkage semantics.  <code>static</code> is unfortunately an over used as a keyword.  It effects linkage when used on global/namespace scope variables/functions.  It has a totally different meaning when applied to class methods.</p>

<p>As for your question they all have external linkage.  They all have the same performance when called.  The inline <strong>MIGHT</strong> have and advantage <strong>IF</strong> the other two function are defined in a cpp file instead of the class  <strong>AND</strong> the compiler decides it will be faster to inline calls to <code>fooInline</code>.  <code>fooInline</code> will have no advantage in the source file where <code>foo</code> and <code>fooStatic</code> are defined.</p>

<p>All of this sounds like premature optimization.  There are other problems worth tackling that will make your code much faster.</p>
",0
1981493,1981413,1,"<p>Because <code>typeid</code> has the flexibility to do lookups at runtime based on a pointer or reference to an object, it can't return a compile-time constant. Even when it looks like it could. <code>sizeof</code> has no such restrictions, as it always does its calculation at compile time.</p>
",3
1981435,1981413,2,"<p>Because typeid requires RTTI, i.e, typeid is performed at runtime and BOOST_STATIC_ASSERT is performed at compile time.</p>

<p>More information <a href=""http://www.cplusplus.com/reference/std/typeinfo/type_info/"" rel=""nofollow noreferrer"">here</a>.</p>
",4
1981474,1981413,0,"<p>It knows the type itself (in its own internal language) at compile time, but not its type id (which has clearly been created for runtime).</p>
",0
1981650,1981413,5,"<p>C++ can handle constant (compile-time) expressions of some types, but reference types are not among those types.  The result of a <code>typeid</code> expression is a reference to a <code>std::type_info</code> object.</p>

<p>Apparently for a while in 2008, the C++ standard committee had <code>typeid</code> expressions such as the ones in your example behaving as constant expressions, just like <code>sizeof</code>. However, according to <a href=""http://cxxpanel.org.uk/ballotcomment/251"" rel=""nofollow noreferrer"">this comment</a>, that change was ultimately reverted.</p>
",2
1982338,1981413,10,"<p>When you are dealing with types, you'd rather use simple metaprogramming techniques:</p>

<pre><code>#include &lt;type_traits&gt;

template &lt;class T&gt;
void Foo()
{
    static_assert((std::is_same&lt;T, int&gt;::value || std::is_same&lt;T, double&gt;::value));
}

int main()
{
    Foo&lt;int&gt;();
    Foo&lt;float&gt;();
}
</code></pre>

<p>where <code>is_same</code> could be implemented like this:</p>

<pre><code>template &lt;class A, class B&gt;
struct is_same
{
    static const bool value = false;
};

template &lt;class A&gt;
struct is_same&lt;A, A&gt;
{
    static const bool value = true;
};
</code></pre>

<p><code>typeid</code> probably isn't compile-time because it has to deal with runtime polymorphic objects, and that is where you'd rather use it (if at all). </p>
",1
1897905,1897860,2,"<p>Assuming you are talking about map files from MSVC compiler, check the documentation, it should be easy to parse line-by-line:</p>

<p><a href=""http://msdn.microsoft.com/en-us/library/k7xkk3e2%28VS.80%29.aspx"" rel=""nofollow noreferrer"">basic file format documentation</a></p>

<p>There is python code to parse map files programmatically, check this one:</p>

<p><a href=""http://www.language-binding.net/pygccxml/apidocs/binary_parsers.html"" rel=""nofollow noreferrer"">python map parser</a></p>
",0
1902525,1897860,2,"<p>The primary issue is that the format of map files varies with compiler vendors and there are too many compiler vendors out there for us to guess which one you are using.  BTW, there is no standard format for map files; as there is no requirement for one.  </p>

<p>I look at the layout of the map file and write my own search programs using <code>awk</code>, Perl, Java, C, or whatever is handy and quick (or a language I want to learn).</p>
",0
1412368,1411821,3,"<p>I can see only one reason for this: <code>B</code> has overloaded <code>operator*()</code> to return an <code>X</code>, but whoever wrote the code needed an <code>X*</code>. (Note that in your code, <code>X</code> is <code>A*</code>.) The typical case for this is smart pointers and iterators. </p>

<p>If the above isn't the case, maybe the code was written to be generic enough to deal with smart pointers/iterators. Or it used to use smart pointers and whoever changed it didn't bother changing <code>&amp;*</code>, too? Have you poked through its history to see when this was introduced and what the code looked then? </p>
",3
1411887,1411821,10,"<p>I've done similar things with iterators - dereference the iterator to get a reference, and then do the ""&amp;"" operator to get a pointer.</p>

<p>I don't see why it would be doing anything here though. If the type to the right of ""&amp;*"" is a pointer type it does nothing.</p>
",0
1412042,1411821,2,"<p>Consider the following sample;</p>

<pre><code>class A {
public:
    int f() { return 55; }
};

class B {
public:
    B( A* a ) : a(a) {}
    A*&amp; operator*() { return a; }

    A* a;
};

int main () {
    A* a = new A();
    B b = a;

    // &amp;* calls operator*, then gets address of A
    void** x = reinterpret_cast&lt;void**&gt;(&amp;*b);
    cout &lt;&lt; reinterpret_cast&lt;A*&gt;( *x )-&gt;f() &lt;&lt; endl; // prints 55

    void** x2 = reinterpret_cast&lt;void**&gt;( b );       // compile error
}
</code></pre>

<p>Your last edit of question leads to:</p>

<pre><code>A* a = new A();
A** b = &amp;a;

void** x = reinterpret_cast&lt;void**&gt;(&amp;*b);  // now this is equal to the following
void** x2 = reinterpret_cast&lt;void**&gt;( b ); // so using &amp;* make no sense
</code></pre>
",4
1691501,1691470,0,"<p>These aren't standard library functions, do you know where they come from - probably something in your environment/compiler.</p>

<p>You need to link with the libraries, in visual studio see properties->linker->input->additional dependencies, on uinx you will have to pass '-lnameoflibrary' to the compiler</p>
",0
1691512,1691470,5,"<p>Your code is referencing functions which it does not provide. (That's only a link error because those functions may well be provided by some other library you might be linking with.)</p>

<p>(without any code posted) You presumably have a separate header file which defines prototypes of getInput and displayInfo. Make sure that your definitions of getInput and displayInfo actually match those prototypes! Note that</p>

<pre><code>void getInput(std::string &amp;foo, double &amp;bar)
</code></pre>

<p>is different than</p>

<pre><code>void getInput(std::string foo, double bar)
</code></pre>

<p>and also, of course,</p>

<pre><code>void getInpoot(std::string &amp;foo, double &amp;bar)
</code></pre>
",0
1691686,1691470,1,"<p>In <code>main</code>,</p>

<pre><code>//call function to get input and calculate salary and taxes
void getInput(string dname, double dsalary, double dnetPay);

void calcFedTaxes(double Fsalary, double FwtRate, double FicaRate,
        double &amp; withholdingTax, double &amp; incomeTax); 

void calcnetPay(double &amp; netPay, double weeklySalary, double fwtTax,
        double ficaTax); 

void displayInfo (string dname, double dfwtTax, double dficaTax, 
        double dnetPay);
</code></pre>

<p>does not do what you think it does.</p>

<p>What you have done is given prototypes for functions.  This generates no code and does not call any functions.</p>

<p>You probably meant</p>

<pre><code>// call functions to get input and calculate salary and taxes
getInput(dname, dsalary, dnetPay);

double withholdingTax, incomeTax;
calcFedTaxes(dsalary, FWT_RATE, FICA_RATE, withholdingTax, incomeTax);
</code></pre>

<p>et cetera.  These functions that you are trying to call do not match the functions you have actually defined, which you must also fix.</p>
",3
1691728,1691470,3,"<p>Just from a casual glance, I notice two obvious mistakes.</p>

<p>The first is an argument mismatch between the prototype and definition of <code>getInput()</code></p>

<pre><code>void getInput(string &amp;, double &amp;) ;
void getInput(string iname , double isalary)
</code></pre>

<p>where the prototype is expecting references, but the definition is not.</p>

<p>The second one is a bit more obvious once you see it.  A simple typo where the function name is missing an ""a"" in the <code>displayInfo()</code> definition.</p>

<pre><code>void displyInfo(string dname, double dfwtTax,  double dficaTax, 
    double dnetPay)
</code></pre>
",0
1694257,1691470,1,"<p>In main(), you are only prototype functions, not calling them:</p>

<pre><code>//call function to get input and calculate salary and taxes 
void getInput(string dname, double dsalary, double dnetPay);
</code></pre>

<p>That defines a function, now you need to call it:</p>

<pre><code>getInput(dname, dsalary, dnetPay);
</code></pre>

<p>That said, your code is confusing.  Let's look at the three current references to getInput in your code:</p>

<pre><code>void getInput(string &amp;, double);
void getInput(string dname, double dsalary, double dnetPay);
void getInput(string iname, double isalary) { ... }
</code></pre>

<p>You have two prototypes, both of which have different signatures then your function definition.  Until you get that cleaned up, you are going to continue having trouble.</p>
",0
1691509,1691491,2,"<p>You have a problem called slicing: you lose the data from the derived classes if you copy to an vector containing base class instances.</p>

<p>You can use a vector of pointers to the base though:</p>

<pre><code>std::vector&lt;Obstacle*&gt; obsdata;
RECTANGLE r = new RECTANGLE;
// set properties
obsdata.push_back(r);
// use it later, e.g.:
obsdata[0]-&gt;writeMatlabDisplayCode(fs);
// clean up when you don't need obstacles anymore:
for(std::vector&lt;Obstacle*&gt;::iterator it = obsdata.begin(); it != obsdata.end(); ++it)
    delete *it;
</code></pre>

<p>You also should avoid trying to read in 5 numbers every time. Instead you could read in the obstacle description and then read as many numbers as the specific obstacle needs.</p>
",6
1691510,1691491,1,"<p>You can do it if you have a vector of pointers instead:</p>

<pre><code>vector&lt;Obstacle *&gt; obsdata;
</code></pre>

<p>and then you ""new"" your subsequent CIRCLE and RECTANGLE:</p>

<pre><code>    if(shape==""CIRCLE"") {
        CIRCLE *c = new CIRCLE;
        c-&gt;m_Xc=num1;
        c-&gt;m_Yc=num2;
        c-&gt;m_Radius=num3;       
        obsdata.push_back(c);
    }
</code></pre>

<p>etc..</p>
",4
1691513,1691491,0,"<p>The condition of your while loop is a problem.  Circle has 2 fewer entries than rectangle.  I suggest you read the shape, then depending on type read the rest of the data.  You know you can read 3 data points for circle and 5 for rectangle.</p>

<p>Some pseudo code</p>

<pre><code>while( fs &gt;&gt; shape )
{
  if( shape == ""CIRCLE"" )
  { 
        CIRCLE c;
        fs &gt;&gt; c.m_Xc;
        fs &gt;&gt; c.m_Yc;
        fs &gt;&gt; c.m_Radius;       
        obsdata.push_back(c);
   }

  if( shape == ""RECTANGLE"" )
  {
      RECTANGLE r;
      fs &gt;&gt; r.center_x;
      fs &gt;&gt; r.center_y;    
      fs &gt;&gt; r.width;
      fs &gt;&gt; r.height;
      fs &gt;&gt; r.angle;
      obsdata.push_back(r);
  }
}
</code></pre>

<p>As gf suggested in the comment, a good C++ book or tutorial on the standard library would be helpful.</p>
",6
1691558,1691491,1,"<p>You could try just reading the whole line at a time then tokenize the values...</p>

<pre><code>vector&lt;Obstacle*&gt; obsdata;

string line;
while(getline(fs, line)) {
    char *token = strtok(line.c_str(), "" "");
    string shape(token);

    vector&lt;double&gt; numbers;
    stringstream ss;
    while(token = strtok(NULL, "" "")) {
        double d;
        ss &lt;&lt; token;
        ss &gt;&gt; d;

        numbers.push_back(d);
    }

    if(shape == ""CIRCLE"") {
        CIRCLE *c = new CIRCLE();
        c-&gt;m_Xc=numbers[0];
        c-&gt;m_Yc=numbers[1];
        c-&gt;m_Radius=numbers[2];       
        obsdata.push_back(c);
    } else if(shape == ""RECTANGLE"") {
        RECTANGLE *r = new RECTANGLE();
        r-&gt;center_x=numbers[0];
        r-&gt;center_y=numbers[1];    
        r-&gt;width=numbers[2];
        r-&gt;height=numbers[3];
        r-&gt;angle=numbers[4];
        obsdata.push_back(r);
    }
}
</code></pre>

<p>I would delete this vector of pointers in your MyWorld destructor:</p>

<pre><code>~MyWorld() {
    // loop thanks to gf
    for(std::vector&lt;Obstacle*&gt;::iterator it = obsdata.begin(); it != obsdata.end(); ++it)
        delete *it;  
}
</code></pre>
",8
1692840,1691491,1,"<p>All of the advice here is good but I'd like to suggest two improvements:</p>

<ul>
<li>Managed your pointers (I'd pick <code>shared_ptr</code> but <code>ptr_vector</code> would also work)</li>
<li>Use an object factory</li>
</ul>

<p>This will make your solution more robust (and not leak memory) and more scalable (you remove the 'God' function that would become a compiler bottleneck as the number of Obstacles increases).</p>

<p>Your code may look something like:</p>

<pre><code>vector&lt;shared_ptr&lt;Obstacle&gt; &gt; obsdata; 

Myworld::readObstacles(std::istream &amp;fs)
{
    std::string shape;
    while(fs &gt;&gt; shape)
    {
        try
        {
            obsdata.push_back(shared_ptr&lt;Obstacle&gt;(m_ObstacleCreator.Create(shape, fs));
        }
        catch(ObstacleNotKnownException&amp; e)
        {
            // Error handling here
        }
    }
}
</code></pre>

<p>The only thing left is to populate <code>m_ObstacleCreator</code> with the knowledge of how to create the various objects based on the shape name and the istream.  An example:</p>

<pre><code>Obstacle * CreateCircleObstacle(istream &amp;fs)
{
    CIRCLE *c = new CIRCLE();
    fs &gt;&gt; c-&gt;m_Xc &gt;&gt; c-&gt;m_Yc &gt;&gt; c-&gt;m_Radius;
}

m_ObstacleCreator.Register(""CIRCLE"", &amp;CreateCircleObstacle);
</code></pre>

<p>You may also want to make <code>m_ObstacleCreator</code> a singleton (Object Factories are one of the few genuine uses for singletons IMO).</p>

<p>For an excellent description on the details of Object Factory implementations pick up a copy of Alexandrescu's Modern C++ Design and check out chapter eight.  </p>
",0
1917442,1917411,1,"<p>If only the first element is freed, you've leaked the rest of the array.</p>

<p>After several iterations of this, you run out of memory.</p>

<p>On the other hand, if it's undefined behaviour, the ""catastrophic end"" <em>could</em> instead be due to instantaneous death as winged demons spurt from your nasal cavities.</p>
",0
1917447,1917411,5,"<p>You will get <a href=""http://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer""><em>undefined behavior</em></a>.</p>
",0
1917461,1917411,4,"<p>It is undefined behavior.  </p>

<p>What this means is that the standard gurantees to the writers of the memory management library that certain pre-conditions exist (In this case that arrays will be deleted with delete []).</p>

<p>If you break these pre-conditions then the memory management library could fail in some way. How it fails will depend on how the library is implemented. But since C++ is designed for speed the result is probably not going to be nice. So usually this means that the internal memory management data structures are corrupted in some way. This will probably lead to some other part of your program sigfaulting.</p>

<p>If you build in debug mode (on some compilers) they will use a special version of the memory management library that is designed to be more robust. Thus in these situations you <strong>may</strong> not crash but the extra checks have been explicitly added to the library and as a result is slower. But you still can not gurantee correct behavior.</p>
",0
1706243,1706231,3,"<pre><code>strcpy(messageBuffer + 2, userName.c_str());
</code></pre>

<p>standard disclaimers about making sure you have enough memory apply</p>

<p>messageBuffer should be 3 characters bigger than the string (one for <code>\0</code>)</p>

<p>a bit of reference about the function <a href=""http://www.cplusplus.com/reference/clibrary/cstring/strcpy/"" rel=""nofollow noreferrer"">here</a></p>
",0
1706253,1706231,2,"<p>Yes, you can use strcpy, memcpy, memmove or std::copy to do this. Just pass the address of messageBuffer[2] as the destination. <code>strcpy( &amp;messageBuffer[2], userName.begin() );</code></p>
",0
1706255,1706231,4,"<p><a href=""http://www.cplusplus.com/reference/clibrary/cstring/strncpy/"" rel=""nofollow noreferrer"">strncpy</a> </p>

<p><strong>EDIT</strong>: See @jaif <a href=""https://stackoverflow.com/questions/1706231/is-there-a-better-way-of-copying-a-string-to-a-character-array-with-things-alread/1730295#1730295"">answer</a> for ""C++"" way.</p>
",2
1706256,1706231,1,"<p>Use <a href=""http://www.cplusplus.com/reference/clibrary/cstring/strncpy/"" rel=""nofollow noreferrer"">strncpy</a></p>
",0
1706260,1706231,0,"<p>What about using <a href=""http://www.cplusplus.com/reference/clibrary/cstring/strcpy/"" rel=""nofollow noreferrer"">strcpy</a> (or strncpy to prevent buffer overflows)?<br>
Make sure the length of messageBuffer allows copying userName and just<br> <code>strcpy(messageBuffer + 2, userName);</code></p>
",0
1706261,1706231,1,"<p>Use strncpy() for ANSI strings (char*), wcsncpy() for Unicode (wchar_t*) strings.</p>
",0
1706271,1706231,1,"<p>You have two options, the unsafe and the safe way.</p>

<p>Unsafe:</p>

<pre><code>// bad idea, string lengths are not checked and if src is longer than 
// memory available for dest, you will stomp over random memory
strcpy(dest, src);
</code></pre>

<p>Safer:</p>

<pre><code>// Much safer, you can specify how many characters to copy (lesser of src length and
// dest length - 1 and add a null terminator '\0' to dest if the string was truncated).
strncpy(dest, src, num_characters);
</code></pre>
",3
1706281,1706231,3,"<p>Use <code>strcpy</code> and check the buffer size by hand. </p>

<p><code>strncpy</code> is a little safer, but dangerous in other way. If the buffer is too small, <code>strncpy</code> does not terminate the string with <code>\0</code> which will cause an error somewhere else in the program.</p>

<p>If you want to use <code>strncpy</code>, then be sure to verify that the output is \0-terminated. Usually when people use <code>strncpy</code>, they forget to do this which is why I recommend <code>strcpy</code>. C and C++ programmers can usually spot the missing buffer size check when using <code>strcpy</code>.</p>
",0
1706339,1706231,2,"<p>If possible, use a std::vector with std::copy</p>

<pre><code>std::vector&lt;char&gt; messageBuffer;
messageBuffer.reserve(userName.size() + 2); // optional
messageBuffer.push_back(1);
messageBuffer.push_back(0);
std::copy(userName.begin(), userName.end(), std::back_inserter(messageBuffer));
theC_API(&amp;messageBuffer[0]);
</code></pre>

<p>Maybe not the fastest, but no chance of miscalculations.</p>
",2
1706353,1706231,0,"<p>Better way by using vector is</p>

<pre><code>std::vector&lt;char&gt; messageBuffer;
messageBuffer.resize(userName.size()+2);
strcpy(&amp;messageBuffer[0],usernamr.c_str());
std::copy(userName.begin(), userName.end(), std::back_inserter(messageBuffer));
theC_API(&amp;messageBuffer[0]);
</code></pre>
",2
1273746,1273687,4,"<p>You don't normally need it, and any tolerable editor will have enough assistance to keep things straight. <em>However</em>, the places I use it in C# are (and you'll see these in C++):</p>

<ul>
<li>Calling a generic method (template in C++), where the parameter types are implied and you want to make sure and call the one with an <code>unsigned long</code> type. This happens reasonably often, including this one recently:<br>
<code>Tuple&lt;ulong, ulong&gt; = Tuple.Create(someUlongVariable, 0UL);</code><br>
where without the <code>UL</code> it returns <code>Tuple&lt;ulong, int&gt;</code> and won't compile.</li>
<li>Implicit variable declarations using the <code>var</code> keyword in C# or the <code>auto</code> keyword coming to C++. This is less common for me because I only use <code>var</code> to shorten very long declarations, and <code>ulong</code> is the opposite.</li>
</ul>
",0
1273749,1273687,29,"<pre><code>void f(unsigned int x)
{
//
}

void f(int x)
{
//
}
...
f(3); // f(int x)
f(3u); // f(unsigned int x)
</code></pre>

<p>It is just another tool in C++; if you don't need it don't use it!</p>
",0
1273751,1273687,10,"<p>Some compiler may emit a warning I suppose.<br>
The author could be doing this to make sure the code has no warnings?</p>
",1
1273791,1273687,17,"<p>In the examples you provide it isn't needed. But suffixes are often used in expressions to prevent loss of precision. For example:</p>

<pre><code>unsigned long x = 5UL * ...
</code></pre>

<p>You may get a different answer if you left off the UL suffix, say if your system had 16-bit ints and 32-bit longs.</p>

<p>Here is another example inspired by Richard Corden's comments:</p>

<pre><code>unsigned long x = 1UL &lt;&lt; 17;
</code></pre>

<p>Again, you'd get a different answer if you had 16 or 32-bit integers if you left the suffix off.</p>

<p>The same type of problem will apply with 32 vs 64-bit ints and mixing long and long long in expressions.</p>
",2
1719728,1719281,7,"<p>An even simpler example, here's a macro I occasionally use when all other forms of debugging have failed:</p>

<pre><code>#define GOT_HERE std::cout &lt;&lt; ""At "" __FILE__ "":"" &lt;&lt; __LINE__ &lt;&lt; std::endl
</code></pre>

<p>Then when your code is mysteriously crashing and taking the device down with it, you can at least sprinkle this macro liberally into the source, in the hope that it will let you narrow down where the crash occurs (and after how many repeats). In practice you might not write to std::cout, but rather use the lowest-level, most reliable character output available on the platform.</p>
",0
1719750,1719281,4,"<p>Most of the answers so far have involved some sort of debugging code. Another use of <code>__LINE__</code> (and possibly <code>__FILE__</code>) is to enable a macro to generate a unique identifier each time it's called. This <a href=""http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html"" rel=""nofollow noreferrer"">implementation of coroutines in C</a> uses these macros to generate labels for a case statement, so it can jump to the last line you called <code>yield</code> from.</p>
",0
1719286,1719281,16,"<p>You can use <code>__LINE__</code>, along with <code>__FILE__</code>, to report where problems occur in the source code.</p>

<p>Consider, for example, the <code>assert()</code> macro - this wording from the C99 standard, but C++ is similar, except it does not mention <code>__func__</code>:</p>

<blockquote>
  <p>When it is executed, if expression (which shall have a scalar type) is false (that is,
  compares equal to 0), the assert macro writes information about the particular call that
  failed (including the text of the argument, the name of the source file, the source line
  number, and the name of the enclosing function ¡ª the latter are respectively the values of
  the preprocessing macros <code>__FILE__</code> and <code>__LINE__</code> and of the identifier
  <code>__func__</code>) on the standard error stream in an implementation-defined format.</p>
</blockquote>

<pre><code>#define assert(x) (void)(((x)==0)?_Assert(#x,__FILE__,__LINE__,__func__):0)
</code></pre>
",2
1719297,1719281,1,"<p>Just like this:</p>

<pre><code>$ cat line.cc
#include &lt;iostream&gt;

int main(void) {
  std::cout &lt;&lt; ""Hello, world from "" &lt;&lt; __LINE__ &lt;&lt; std::endl;
  return 0;
}
$ g++ -o line line.cc
$ ./line
Hello, world from 4
$
</code></pre>
",0
1719298,1719281,0,"<pre><code>if (something truly impossible has happened) {
   fprintf(stderr, ""Value of PI less than 3 detected at %s line %d\n"", __FILE__, __LINE__);
}
</code></pre>

<p>It's especially handy in CPP macros that detect intolerable conditions.</p>
",0
1719301,1719281,5,"<p>I wrote a wrapper for malloc:</p>

<pre>
#if DEBUG

#define malloc(s) debugging_malloc(s, __FILE__, __LINE__)
#define free(p) debugging_free(p)

// Also, calloc(), strdup(), realloc() should be wrapped.
#endif // DEBUG
</pre>

<p>Within the wrapper, allocations are tracked according to the file and line number at which they occur.  When the program exits, a utility functions outputs a list of any unfreed blocks.</p>

<p>If you are using gcc, it also gives you <code>__FUNCTION__</code>, which is really nice.  C99-compliant compilers also have <code>__func__</code>, just as handy.</p>
",0
1719310,1719281,0,"<p>It's really just for debugging/logging purposes.  I rarely use it because I tend to rely on debuggers like gdb more often.</p>

<p>But you could always use it when outputting debug information.</p>

<pre><code>void dosomething(Object* o)
{
  if (!o) {
    std::cerr &lt;&lt; __FILE__ &lt;&lt; "":"" &lt;&lt; __LINE__ &lt;&lt; "": o is NULL!\n"";
    abort();
  }
}
</code></pre>
",0
1719345,1719281,0,"<p>Just to vaguely quote  from the top of my head:</p>

<pre><code>#define assert(e)       ((e) ? (void)0 : printf(""Assertion failed %s, %s : %s"", #e, __FILE__, __LINE__))
</code></pre>
",1
1696174,1696086,17,"<p>Straightforward and simple, and independent of <code>sizeof(int)</code>:</p>

<pre><code>int NumDigits(int n) {
    int digits = 0;
    if (n &lt;= 0) {
        n = -n;
        ++digits;
    }
    while (n) {
        n /= 10;
        ++digits;
    }
    return digits;
}
</code></pre>
",13
1696092,1696086,12,"<pre><code>//Works for positive integers only
int DecimalLength(int n) {
    return floor(log10f(n) + 1);
}
</code></pre>
",6
1696094,1696086,8,"<p>One way is to (may not be most efficient) convert it to a string and find the length of the string. Like:</p>

<pre><code>int getDigits(int n)
{
    std::ostringstream stream;
    stream&lt;&lt;n;

    return stream.str().length();
}
</code></pre>
",2
1696100,1696086,3,"<pre><code>int NumDigits(int n)
{
  int digits = 0;

  if (n &lt; 0) {
    ++digits;
    do {
      ++digits;
      n /= 10;
    } while (n &lt; 0);
  }
  else {
    do {
      ++digits;
      n /= 10;
    } while (n &gt; 0);
  }

  return digits;
}
</code></pre>

<p>Edit:  Corrected edge case behavior for -2^31 (etc.)</p>
",5
1696101,1696086,10,"<p>The fastest way is probably a binary search...</p>

<pre><code>//assuming n is positive
if (n &lt; 10000)
    if (n &lt; 100)
        if (n &lt; 10)
            return 1;
        else
            return 2;
    else
        if (n &lt; 1000)
            return 3;
        else
            return 4;
 else
     //etc up to 1000000000
</code></pre>

<p>In this case it's about 3 comparisons regardless of input, which I suspect is much faster than a division loop or using doubles.</p>
",3
1696212,1696086,6,"<pre><code>numdigits = snprintf(NULL, 0, ""%d"", num);
</code></pre>
",1
1696388,1696086,7,"<p>To extend Arteluis' answer, you could use templates to generate the comparisons:</p>

<pre><code>template&lt;int BASE, int EXP&gt;
struct Power
{
    enum {RESULT = BASE * Power&lt;BASE, EXP - 1&gt;::RESULT};
};

template&lt;int BASE&gt;
struct Power&lt;BASE, 0&gt;
{
    enum {RESULT = 1};
};

template&lt;int LOW = 0, int HIGH = 8&gt;
struct NumDigits
{
    enum {MID = (LOW + HIGH + 1) / 2};

    inline static int calculate (int i)
    {
        if (i &lt; Power&lt;10, MID&gt;::RESULT)
            return NumDigits&lt;LOW, MID - 1&gt;::calculate (i);
        else
            return NumDigits&lt;MID, HIGH&gt;::calculate (i);
    }
};

template&lt;int LOW&gt;
struct NumDigits&lt;LOW, LOW&gt;
{
    inline static int calculate (int i)
    {
        return LOW + 1;
    }
};

int main (int argc, char* argv[])
{
    // Example call.
    std::cout &lt;&lt; NumDigits&lt;&gt;::calculate (1234567) &lt;&lt; std::endl;

    return 0;
}
</code></pre>
",4
1696516,1696086,0,"<p>My version of loop (works with 0, negative and positive values):</p>

<pre><code>int numDigits(int n)
{
   int digits = n&lt;0;  //count ""minus""
   do { digits++; } while (n/=10);
   return digits;
}
</code></pre>
",2
1696563,1696086,0,"<p>If you're using a version of C++ which include C99 maths functions (C++0x and some earlier compilers)</p>

<pre><code>static const double log10_2 = 3.32192809;

int count_digits ( int n )
{
    if ( n == 0 ) return 1;
    if ( n &lt; 0 ) return ilogb ( -(double)n ) / log10_2 + 2;
    return ilogb ( n ) / log10_2 + 1;
}
</code></pre>

<p>Whether ilogb is faster than a loop will depend on the architecture, but it's useful enough for this kind of problem to have been added to the standard.</p>
",0
1697272,1696086,3,"<p>Some very over-complicated solutions have been proposed, including the accepted one. </p>

<p>Consider:</p>

<pre><code>#include &lt;cmath&gt;
#include &lt;cstdlib&gt;

int NumDigits( int num )
{
    int digits = (int)log10( (double)abs(num) ) + 1 ;

    return num &gt;= 0 ? digits : digits + 1 ;
}
</code></pre>

<p>Note that it works for for INT_MIN + 1 ... INT_MAX, because abs(INT_MIN) == INT_MAX + 1 == INT_MIN (due to wrap-around), which in-turn is invalid input to log10(). It is possible to add code for that one case.</p>
",2
1698436,1696086,0,"<p>An optimization of the previous division methods. (BTW they all test if n!=0, but most of the time n>=10 seems enough and spare one division which was more expensive).</p>

<p>I simply use multiplication and it seems to make it much faster (almost 4x here), at least on the 1..100000000 range. I am a bit surprised by such difference, so maybe this triggered some special compiler optimization or I missed something.</p>

<p>The initial change was simple, but unfortunately I needed to take care of a new overflow problem. It makes it less nice, but on my test case, the 10^6 trick more than compensates the cost of the added check. Obviously it depends on input distribution and you can also tweak this 10^6 value.</p>

<p>PS: Of course, this kind of optimization is just for fun :)</p>

<pre><code>int NumDigits(int n) {
    int digits = 1;
    // reduce n to avoid overflow at the s*=10 step.
    // n/=10 was enough but we reuse this to optimize big numbers
    if (n &gt;= 1000000) {
        n /= 1000000;
        digits += 6; // because 1000000 = 10^6
    }
    int s = 10;
    while (s &lt;= n) {
        s *= 10;
        ++digits;
    }
    return digits;
}
</code></pre>
",0
1698731,1696086,1,"<p>Another implementation using STL binary search on a lookup table, which seems not bad (not too long and still faster than division methods). It also seem easy and efficient to adapt for type much bigger than int: will be faster than O(digits) methods and just needs multiplication (no division or log function for this hypothetical type). There is a requirement of a MAXVALUE, though. Unless you fill the table dynamically.</p>

<p>[edit: move the struct into the function]</p>

<pre><code>int NumDigits9(int n) {
    struct power10{
        vector&lt;int&gt; data;
        power10() { 
            for(int i=10; i &lt; MAX_INT/10; i *= 10) data.push_back(i);
        }
    };

    static const power10 p10;
    return 1 + upper_bound(p10.data.begin(), p10.data.end(), n) - p10.data.begin();
}
</code></pre>
",0
1806752,1806687,1,"<blockquote>
  <p>Ok I just re-compiled everything and it worked. I don't know what went wrong. Thanks for your suggestions.</p>
</blockquote>

<p>Check your dependencies. I bet something that should be depending on a header file isn't. When you did a clean build, the source code file that relied on that header file was brought up to date.</p>
",0
1806831,1806687,0,"<blockquote>
  <p>I just re-compiled everything and it
  worked</p>
</blockquote>

<p>So I assume the abstract base class was declared in one binary (for example, in one dll on windows) and the derived class was in another. In that case, if you don't recompile the binary containing the derived class, it's vtable will not be setup properly and the calls will start behaving weirdly and as @Strager said, you need to have the virtual destructor in the base class.</p>
",0
1709951,1709941,7,"<p>Non-static class members are always destroyed in the reverse order that they were constructed.</p>

<p>The order that members are constructed always matches the order that they are declared in the class definition. The order that members appear in a constructor's initalizer list has no effect on the order of their construction.</p>

<p>In your example <code>_c</code> is destroyed, then <code>_b</code> is destroyed, the reverse order of their declaration in the class.</p>
",3
1709972,1709941,6,"<p>They are destroyed (not deleted) in the reverse order that they were created.  It is this that also requires that regardless of how the constructor is written that all the members must be constructed in a consistent order.  If each constructor could define the order that the members were constructed, each class instance would have to carry around information on how it was constructed, in order to be able to destruct in reverse order.  By defining the order to always be the order that the members were declared in the class definition, the order of construction does not change from constructor to constructor.</p>

<p>In your example, first, memory is allocated for the full A class.  Next <code>_b</code> is constructed, then <code>_c</code> then <code>A</code>.  If A were to have a base class, that would be fully constructed before any of the above.  On deletion, the reverse occurs.  First <code>A</code>'s destructor is called, then <code>_c</code> is destructed, then <code>_b</code> (then any base classes are destructed).  Finally the memory for 'A' is freed.</p>
",3
1710106,1709941,0,"<p>class members constructors are always called in the order of their declaration, regardless the call order in the master class constructor.</p>

<p>in your case,</p>

<pre><code>A::A():  
_c(...),  
_b(...)  
{  
}
</code></pre>

<p>implies the same construction/destruction order than</p>

<pre><code>A::A():  
_b(...),
_c(...)  
{  
}
</code></pre>
",0
1802490,1802334,1,"<p>If encoded with utf-8, it is the same for both ascii and unicode as ascii is a subset of unicode. See the example in <a href=""http://www.faqs.org/rfcs/rfc2044.html"" rel=""nofollow noreferrer"">RFC 2044</a></p>
",0
1803108,1802334,0,"<p>A simple example below:</p>

<pre><code>        try
        {
            System.IO.TextWriter writeFile = new StreamWriter(""c:\\textwriter.txt"",false,Encoding.UTF7);
            writeFile.WriteLine(""example text here"");
            writeFile.Flush();
            writeFile.Close();
            writeFile = null;
        }
        catch (IOException ex)
        {
            MessageBox.Show(ex.ToString());
        }
</code></pre>
",5
1678529,1678519,19,"<p>Note: you are invoking undefined behavior (modifying a variable twice between sequence points)</p>
",4
1678535,1678519,0,"<p>I'm guessing that both pre-increment operators are running before the addition statement gets calculated. hence 24.  </p>

<p>All depends on how the compiler sees what you're doing, but I'm guessing that's what you're seeing.</p>
",1
1678540,1678519,-2,"<p>++i happens before calculating the whole expression and i++ happens after.
In the first example one of increments happen before calculating the value, so ""i"" becomes 21 and you get 21 + 21. In the last example both happen before, so ""i"" becomes 22 and you get 22 + 22.</p>
",0
1678542,1678519,0,"<p>i++ is post-increment, ++i is pre-increment.  i++ will increment i after the statement is completed.</p>

<p>To illustrate in your examples:</p>

<p>Example 1:</p>

<pre><code>k = 0
i = 10

i += 1
k = i + i  // 11 + 11
i += 1
</code></pre>

<p>Example 2:</p>

<pre><code>k = 0
i = 10

i += 1
i += 1
k = i + i  // 12 + 12
</code></pre>
",3
1678552,1678519,-1,"<p>++i will give result i=i+1. If i=10 then in  k = (++i)+(++i);
expression (++i) will give incremented value that means first increment will happen but in case of i++ the increment will be affected on i after the expression.</p>

<p>So i=10</p>

<p>k = (i++)  +   (++i);</p>

<pre><code> 10    11   12

 10    +  12=22  
</code></pre>

<p>k = (++i) + (++i);</p>

<pre><code> 11   11  12

  11   +  12=23
</code></pre>
",2
1678553,1678519,-1,"<p><code>++i</code> usually returns a reference to the variable itself so the second modification also affects the memory that holds the result from the first modification. (Post-increment <code>i++</code>, on the other hand, has to return a copy of the value in order to work properly.)</p>

<p>A typical definition of <code>++i</code> in C++ (using operator overloading) would be</p>

<pre><code>struct Foo{
  //...
  Foo const &amp; operator++(){ //this implements ++i
    //do something to increment
    return *this;
  }
  Foo operator++(int){ //this implements i++
    Foo old(*this);
    //do something to increment
    return old;
  }
};
</code></pre>
",2
1678557,1678519,4,"<p>This seemed really interesting, so I took a peek at the disassembly (MSVC++2008)</p>

<pre><code>     k = (++i)+(++i);
0122413C  mov         eax,dword ptr [i] 
0122413F  add         eax,1 
01224142  mov         dword ptr [i],eax 
01224145  mov         ecx,dword ptr [i] 
01224148  add         ecx,1 
0122414B  mov         dword ptr [i],ecx 
0122414E  mov         edx,dword ptr [i] 
01224151  add         edx,dword ptr [i] 
01224154  mov         dword ptr [k],edx 
</code></pre>

<p>As you can see, it increments <code>i</code> twice and then adds <code>i</code> to itself. The same thing happens if there are multiple instances of <code>(++i)</code>.</p>

<p>Anyway, since the Standard doesn't guarantee anything, modifying <code>i</code> more than once will lead to undefined behaviour.</p>
",0
1678567,1678519,-2,"<p>To determine this the following step is taking.</p>

<p>1). All of <code>++i</code> is determined.</p>

<p>2). The value of i is then used to each term that is <code>++i</code> and <code>i++</code>.</p>

<p>3). All of <code>i++</code> is determined.</p>

<p><b>First case:</b></p>

<pre><code>     int k=0;
     int i=10;
     k = (i++)+(++i);</code></pre>

<p>1) There is one of <code>++i</code> so at then end of this step i = 11 (once).</p>

<p>2) Now it become <code>k = (11)+(11);</code></p>

<p>3) There is one of <code>i++</code> so at then end of this step i = 12 (once).</p>

<p><b>Second case:</b></p>

<pre><code>     int k=0;
     int i=10;
     k = (++i)+(++i);</code></pre>

<p>1) There is one of <code>++i</code> so at then end of this step i = 12 (twice).</p>

<p>2) Now it become <code>k = (12)+(12);</code></p>

<p>3) There is one of <code>i++</code> so at then end of this step i = 12 (zero time).</p>

<p>I create a test code:</p>

<pre><code>#include &lt;stdio.h&gt;
int main(void) {
    int K=0;
    int I=10;
    K = (I++)+(++I);
    printf(""I: %d; K: %d\n"", I, K);

    K=0;
    I=10;
    K = (++I)+(++I);
    printf(""I: %d; K: %d\n"", I, K);
}</code></pre>

<p>When executed, the result is:</p>

<pre><code>I: 12; K: 22
I: 12; K: 24</code></pre>

<p>Hope this helps.</p>
",4
1678583,1678519,6,"<p>According to C++03 Standard 5/4 the behavior of the programs in question is undefined:</p>

<blockquote>
  <p>Except where noted, the order of evaluation of operands of individual operators and subexpressions of indi-
  vidual expressions, and the order in which side effects take place, is unspecified.
  53)
  Between the previous
  and next sequence point a scalar object shall have its stored value modified at most once by the evaluation
  of an expression.  Furthermore, the prior value shall be accessed only to determine the value to be stored.
  The requirements of this paragraph shall be met for each allowable ordering of the subexpressions of a full
  expression; otherwise the behavior is undefined.</p>
</blockquote>
",0
1679658,1678519,2,"<p>A variable never should be increased more than one time within one statement,  because the behaviour of the compiler isn't defined.</p>

<p>To avoid side effects, make two statements for your examples.</p>

<p>Example 1: k = i++; k += ++i;</p>

<p>Example 2: k = ++i; k += ++i;</p>

<p>If you do so, your code will work correctly.</p>
",0
1686460,1686439,1,"<p>Pure C++ has only one screen interface, in the  library. That's text-oriented. To do graphics, you need another OS-specific interface. So, you'd be looking at the API documentation for your OS.</p>

<p>BTW, the overlay graphics when you change the volume on your laptop are really special, IIRC. They're generated by your laptop itself, using System Management Mode - not the OS itself, and certainly not a program.</p>
",2
1687048,1686439,2,"<p>Under windows there are a few ways to do it.  You could use DirectDraw Overlays (If the system supports them).  Or you could create a <a href=""http://msdn.microsoft.com/en-us/library/ms997507.aspx"" rel=""nofollow noreferrer"">layered window</a> (WS_EX_LAYERED) and make everything but the bit you want to display transparent.</p>
",0
1894645,1894542,2,"<p>It is impossible to understand what exactly is implied by the question in ts current form. </p>

<p>If taken literally, the question has an obvious and immediate answer: the parent's version is called if the parent's implementation is the final overrider for the function in question, i.e. if the child provides no implementation of its own</p>

<pre><code>class parent {
public:
  virtual void foo() { /* whatever */ }
};

class child : parent {
public:
  void bar() {
    foo(); /* call the parent's implementation, as requested */
  }
};
</code></pre>

<p>So, here's your answer.</p>

<p>Of course, it's intuitively obvious to anyone that most likely that's not what was implied by the question. Quite likely it was implied that the child class overrides the parent's function. In that case there's another obvious answer: the parent's version will be called if the child uses a fully-qualified name of the function</p>

<pre><code>class parent {
public:
  virtual void foo() { /* whatever */ }
};

class child : parent {
public:
  virtual void foo() { /* whatever */ }
  void bar() {
    parent::foo(); /* call the parent's implementation, as requested */
  }
};
</code></pre>

<p>Another possible answer is that the object for which the function is called actually has <code>parent</code> type (since nowhere in the question it says that the child should call it for <code>this</code> object)</p>

<pre><code>class parent {
public:
  virtual void foo() { /* whatever */ }
};

class child : parent {
public:
  virtual void foo() { /* whatever */ }
  void bar() {
    parent p;
    p.foo(); /* call the parent's implementation, as requested */
  }
};
</code></pre>

<p>Again, it feels intuitively that this is not what the question is about. Most likely, the question was intended to be about virtual calls made from constructors and destructors</p>

<pre><code>class parent {
public:
  parent() { 
    foo(); /* always calls `parent::foo` */
  }
  virtual void foo() { /* whatever */ }
};

class child : parent {
public:
  child() : parent() /* `parent::parent` will call `parent::foo` */
    {}
  virtual void foo() { /* whatever */ }
};
</code></pre>

<p>However, for that the question is incorrectly worded. In the last example at the moment of the call, the child object does not exist yet. The memory for it is already allocated but its lifetime hasn't started yet. It is incorrect to say that the call to the virtual function is performed by the child object. It is performed by the parent object.</p>

<p>So, to resume the above: the question is so ambiguously and vaguely worded, that it doesn't make any sense in its current form.</p>
",0
1894546,1894542,0,"<p>If the child class' destructor has already been called, then the object is now of the parent's type, so the parent's virtual functions will be called.</p>
",10
1894686,1894542,1,"<ul>
<li>When the base class's scope is explicitly used ( <code>Base::f();</code> )</li>
<li>Inside the base class's constructor (because the derived object's constructor hasn't been entered yet)</li>
<li>Inside the base class's destructor (because the derived object has already been destructed)</li>
</ul>
",0
1894565,1894542,4,"<p>I think you need to post some code to clarify what you are asking, but (with the exception of the destructor) the base class function will not be called unless the child calls itt explicitly from its own function. For example, in:</p>

<pre><code>struct A {
    virtual ~A() {}
    virtual void f() {}
};

struct B : public A {
    virtual void f() {}
};

int main() {
    A * a = new B;
    a-&gt;f();
    delete a;
}
</code></pre>

<p>only B's virtual function f() is called. If you wanted A::f() to be called you would have to do so explicitly:</p>

<pre><code>struct B : public A {
    virtual f() { 
       A::f();    // explicit call
    }
};
</code></pre>

<p>Oh, and of course in the case when B does not declare the function  - in this case A::f() will always be called.</p>
",4
1894621,1894542,0,"<p>If this invocation is whithin a constructor, the dispatch will be static. Read this for more info: <a href=""http://cplusplus.co.il/2009/09/30/virtual-dispatching-within-a-constructor-or-a-destructor/"" rel=""nofollow noreferrer"">http://cplusplus.co.il/2009/09/30/virtual-dispatching-within-a-constructor-or-a-destructor/</a></p>

<p>Here's the example from the article I've linked to:</p>

<pre><code>struct A {
    A () { f(); }
    virtual void f () { }
};

struct B : A {
        B () :member(0) {}
        void f () { std::cout &lt;&lt; member; }
    private:
        int member;
};

int main () {
    B b;
    return 0;
}
</code></pre>

<p>The invoked f is A::f, despite the fact that it is virtual and called by an object of type B who has its own implementation.</p>
",4
1894755,1894542,0,"<p>Answer has already been provided, this may happen during construction: </p>

<p>It might also be a funny source of run-time errors, so pay special attention to constructors &amp; pure virtual methods calls in the base class ;)</p>

<p><a href=""http://support.microsoft.com/kb/125749"" rel=""nofollow noreferrer"">http://support.microsoft.com/kb/125749</a></p>

<pre><code>   class A;

   void fcn( A* );

   class A
   {
   public:
       virtual void f() = 0;
       A() { fcn( this ); }
   };

   class B : A
   {
       void f() { }
   };

   void fcn( A* p )
   {
       p-&gt;f();
   }

   // The declaration below invokes class B's constructor, which
   // first calls class A's constructor, which calls fcn. Then
   // fcn calls A::f, which is a pure virtual function, and
   // this causes the run-time error. B has not been constructed
   // at this point, so the B::f cannot be called. You would not
   // want it to be called because it could depend on something
   // in B that has not been initialized yet.

   B b;

   void main()
   {
   }
</code></pre>
",0
1281523,1208028,98,"<p><a href=""https://stackoverflow.com/questions/1208028/significance-of-a-inl-file-in-c/1208062#1208062"">Nick Meyer</a> is right: The compiler doesn't care about the extension of the file you're including, so things like "".h"", "".hpp"", "".hxx"", "".hh"", "".inl"", "".inc"", etc. are a simple convention, to make it clear what the files is supposed to contain.</p>

<p>The best example is the STL header files which have no extension whatsoever.</p>

<p>Usually, "".inl"" files do contain <i>inline</i> code (hence the "".inl"" extension).</p>

<p>Those files "".inl"" files are a necessity when you have a dependency cycle between <b>header</b> code.</p>

<p>For example:</p>

<pre><code>// A.hpp
struct A
{
    void doSomethingElse()
    {
       // Etc.
    }

    void doSomething(B &amp; b)
    {
       b.doSomethingElse() ;
    }
} ;
</code></pre>

<p>And:</p>

<pre><code>// B.hpp
struct B
{
    void doSomethingElse()
    {
       // Etc.
    }

    void doSomething(A &amp; a)
    {
       a.doSomethingElse() ;
    }
} ;
</code></pre>

<p>There's no way you'll have it compile, including using forward declaration.</p>

<p>The solution is then to break down definition and implementation into two kind of header files:</p>

<ul>
<li><code>hpp</code> for header declaration/definition</li>
<li><code>inl</code> for header implementation</li>
</ul>

<p>Which breaks down into the following example:</p>

<pre><code>// A.hpp

struct B ;

struct A
{
    void doSomethingElse() ;
    void doSomething(B &amp; b) ;
} ;
</code></pre>

<p>And:</p>

<pre><code>// A.inl
#include &lt;A.hpp&gt;
#include &lt;B.hpp&gt;

inline void A::doSomethingElse()
{
   // Etc.
}

inline void A::doSomething(B &amp; b)
{
   b.doSomethingElse() ;
}
</code></pre>

<p>And:</p>

<pre><code>// B.hpp

struct A ;

struct B
{
    void doSomethingElse() ;
    void doSomething(A &amp; a) ;
} ;
</code></pre>

<p>And:</p>

<pre><code>// B.INL
#include &lt;B.hpp&gt;
#include &lt;A.hpp&gt;

inline void B::doSomethingElse()
{
   // Etc.
}

inline void B::doSomething(A &amp; a)
{
   a.doSomethingElse() ;
}
</code></pre>

<p>This way, you can include whatever "".inl"" file you need in your own source, and it will work.</p>

<p>Again, the suffix names of included files are not really important, only their uses.</p>
",3
1208045,1208028,3,"<p>In my experience, .inl files are used to define inline functions.  When they're in an .inl file, the file can be included in a header to get inline functions and in a .c file to get regular function definitions.</p>

<p>This way the same source can more easily work with compilers that do not have inline function supportas well as compilers that do.</p>

<p>They're usually used with straight C code, not often with C++ code as all C++ compilers support inline functions.</p>
",2
1208057,1208028,1,"<p>I believe it's just a naming convention for a ""header"" file includes inline code.
it's so that .h files can contain definitions and .inl files contain inline code which is necessary for templates.</p>

<p>I don't belive there is anything more to it than an naming convention to make the purpose of the file clear</p>
",0
1208062,1208028,159,"<p><code>.inl</code> files are never mandatory and have no special significance to the compiler.  It's just a way of structuring your code that provides a hint to the humans that might read it.</p>

<p>I use <code>.inl</code> files in two cases:</p>

<ul>
<li>For definitions of inline functions.</li>
<li>For definitions of function templates.</li>
</ul>

<p>In both cases, I put the declarations of the functions in a header file, which is included by other files, then I <code>#include</code> the <code>.inl</code> file at the bottom of the header file.</p>

<p>I like it because it separates the interface from the implementation and makes the header file a little easier to read.  If you care about the implementation details, you can open the <code>.inl</code> file and read it.  If you don't, you don't have to.</p>
",5
1208943,1208028,33,"<p>Since nobody else has mentioned it:</p>

<p>The use of .inl files to store your inline functions can be useful for speeding up compiles. </p>

<p>If you only include the declarations (.h) where you need declarations, and only include inline implementations (.inl) where you need them ( i.e. probably only in .cpp and other .inl files, not .h's ), it can have a beneficial effect on your header dependencies. </p>

<p>This can be a significant win on larger projects with many interacting classes.</p>
",4
1698813,1698796,2,"<pre><code>ofstream savefile(""test.txt"");
</code></pre>

<p>is equivalent to:</p>

<pre><code>ofstream savefile;
savefile.open(""test.txt"", ios::out|ios::trunc);
</code></pre>

<p>That is, you're truncating the file as you open it.  So, move the initialization of <code>savefile</code> to happen <em>after</em> you're done with your <code>load</code> call (I'd suggest doing it as late as possible, because if you crash after that initialization and before you're done saving, the save file is corrupted -- normally one writes to a different file and only does the rename at the very end when everything is safe on disk).</p>
",0
1698820,1698796,3,"<p>Your files are being opened globally and never closed. Try:</p>

<pre><code>void load()
{
    ifstream loadfile(""test.txt"");
    string name;
    while(!loadfile.eof())
    {
        getline(loadfile,name);
        cout&lt;&lt;""name "" &lt;&lt; name&lt;&lt;""\n"";
    }
}
void save(User &amp;name)
{
    ofstream savefile(""test.txt"");
    savefile &lt;&lt; name.getName() &lt;&lt; endl;
}
</code></pre>
",3
1698824,1698796,1,"<p>In your first sample, you may be running afoul of OS file locking, preventing you from opening the same file for both read and write. Remember to always <a href=""http://www.cplusplus.com/reference/iostream/ios/fail/"" rel=""nofollow noreferrer"">check for failure</a> when opening a file.</p>

<p>In the second sample, you don't rewind the file pointer. Use <a href=""http://www.cplusplus.com/reference/iostream/ostream/seekg/"" rel=""nofollow noreferrer""><code>seekg</code></a> to reset the stream pointer before trying to read. Keep in mind that although there's a seperate <a href=""http://www.cplusplus.com/reference/iostream/ostream/seekg/"" rel=""nofollow noreferrer""><code>seekg</code></a> and <a href=""http://www.cplusplus.com/reference/iostream/ostream/seekp/"" rel=""nofollow noreferrer""><code>seekp</code></a>, in practice they may refer to the same pointer, so it's always best to seek before switching between read and write.</p>
",0
1698837,1698796,1,"<pre><code>void load(){
    ifstream loadfile(""test.txt"");
    string name;

    while(!loadfile.eof())
    {
        getline(loadfile,name);
        cout&lt;&lt;""name "" &lt;&lt; name&lt;&lt;""\n"";
    }
    loadfile.close(); // Call close() to free up resources again
}

void save(User &amp;name)
{   
    ofstream savefile(""test.txt"");
    savefile &lt;&lt; name.getName() &lt;&lt; endl;
    savefile.close(); // Call close() to free up resources again
}
</code></pre>

<p>From <a href=""http://www.cplusplus.com/doc/tutorial/files/"" rel=""nofollow noreferrer"">Cplusplus I/O</a>:
""Once this member function is called, the stream object can be used to open another file, and the file is available again to be opened by other processes.""</p>
",1
1849966,1849961,6,"<p>Declare the members as const.</p>
",7
1849967,1849961,12,"<p>Make all the member functions <code>const</code>. That's the only mechanism for the job, and it works just fine. If you also make them <code>private</code> you're completely covered.</p>

<p>If for some reason you feel compelled to mark them protected, then things are more complicated.</p>

<p>You will need to make the individual fields <code>const</code>, and that will in turn require you to initialize them via the member initialization list, or a <code>const_cast</code> of this in the constructor. Or maybe a mutable ctor, but I'm not sure there is such a thing.</p>
",11
1850073,1849961,1,"<p>As a suggestion, the methods should be suffixed with <code>const</code> since they won't change the members (data).  This may be redundant, but it gives notification to the users of this class.</p>

<p>
Derived classes can only change members of the parent's (superclass) if the access is marked as <code>protected</code> or <code>public</code> <b>and the members are not <code>const</code></b>.  However, there are heroic methods for altering data using pointers and casting, but the principle is not to modify <code>const</code> objects.
</p>
",0
1850111,1849961,2,"<p>You could simply declare the instance of the class that you are interested in keeping unchanged as const:</p>

<pre><code>const Person p( ""fred"" );
</code></pre>
",0
1850130,1849961,0,"<p>The way to do this is by declaring the method(s) as const, like this:</p>

<pre><code>void f () const;
</code></pre>

<p>However, it's important to note that members marked as mutable may still be changed - even through const methods. For more info about the mutable keyword you can read <a href=""http://cplusplus.co.il/2009/09/16/mutable-and-volatile/"" rel=""nofollow noreferrer"">this</a>.</p>
",0
1715211,1715183,1,"<p>Both look wrong.</p>

<p>Just because code compiles it doesn't mean it's valid.  I'm surprised that the first case is compiling, since it seems like <code>i</code> isn't defined in the else case.</p>

<p>edit: I'm wrong here, definitions in the <code>if</code> condition are valid for that whole <code>if</code> / <code>else</code> statement.</p>
",8
1715232,1715183,18,"<p>Section 6.4 of the C++ standard (draft n2914 of c++0x) has this to say about the format of <code>if</code> statements:</p>

<blockquote>
  <p>Selection statements choose one of several flows of control.<br>
  &nbsp;&nbsp;&nbsp;<code>selection-statement:</code><br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>if ( condition ) statement</code><br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>if ( condition ) statement else statement</code><br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>switch ( condition ) statement</code><br>
  &nbsp;&nbsp;&nbsp;<code>condition:</code><br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>expression</code><br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>type-specifier-seq attribute-specifieropt declarator = initializer-clause</code><br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>type-specifier-seq attribute-specifieropt declarator braced-init-list</code><br></p>
</blockquote>

<p>That bit at the end means a condition can be either an expression <em>or</em> a decalarator-type construct.</p>

<p>And the minute the parser hits that second parenthesis, it becomes an expression, so no declarations allowed, I'm afraid.</p>

<p>The snippet:</p>

<pre><code>if (int i = 2) { ... } else { ... }
</code></pre>

<p>is perfectly valid C++ in which the if section defines an integer <code>i</code> for the duration of the <code>if/else</code> and sets it to 2. It then uses that 2 as the input to the <code>if</code> (2 is always true, being non-zero).</p>

<p>The snippet <code>if((int i = 2))</code> is no different syntactically to <code>int x = (int i = 2;); if (x)</code> which is <em>not</em> valid C++.</p>
",0
1715233,1715183,5,"<p>Here is another variant of second snippet error:</p>

<pre><code>int main()
{
    int i = (int j = 0);
    return 0;
}
</code></pre>

<p>You can't declare variables inside ANY expression.
Second () inside for is the same case - you can declare variable i inside for() but not inside nested expression placed into ().</p>

<p>Hope I explained it in proper words, maybe more correct explanation exists. Actually both code fragments are odd.</p>
",0
1715284,1715183,10,"<p>Snippet A is fine - the <code>if</code> condition delares and initialises a variable that can be interpreted as a boolean. The variable is defined within the <code>if</code> and any <code>else</code> blocks.</p>

<p>Snippet B is wrong, because you can't put parentheses around a declaration - you can only put them round expressions. The following is also wrong for the same reason:</p>

<pre><code>int main()
{
    int i;       // OK
    (i = 2);     // OK

    (int x = 2); // compile error
}
</code></pre>
",3
1680507,1679988,3,"<p>Say you have a n x n rectangular area black and white (O and 1) pixels and you're looking for the biggest white rectangle in this area.</p>

<p>I would write something simple like below:</p>

<ul>
<li>first pass: create a set of 1 line segments for each pixel row.</li>
<li>second pass aggregate rectangles:

<ul>
<li>for each segment iterate on rows to find the largest rectangle containing it.</li>
<li>if you use another segment in the process mark it as used, not need to try it again</li>
<li>at any point keep only the largest rectangle found </li>
</ul></li>
</ul>

<p>That's only a first draft of a possible solution. It should be rewritten using a more formal algorithmic syntax and many details should be provided. Each step hides pitfalls to avoid if you want to be efficient. But it should not be too hard to code.</p>

<p>If I did not missed something, what I described above should basically be O(n4) in the worst case, with the first pass O(n2) used to find horizontal segments (could be quite fast with a very small loop) and the second pass probably much less thant O(n4) in practice (depends on segment size, really is nb_total_segment x nb_segment_per_line x nb_overlapping_segment).</p>

<p>That looks not bad to me. Can't see any obvious way to do it with better O complexity, (but of course there may be some way, O(n4) is not that good). </p>

<p>If you provide some details on input structure and expected result it may even be some fun to code.</p>
",0
1680584,1679988,2,"<p>What you ask for is known as <em>blob filtering</em> on the computer vision world.</p>

<ul>
<li><a href=""http://en.wikipedia.org/wiki/Blob_extraction"" rel=""nofollow noreferrer"">http://en.wikipedia.org/wiki/Blob_extraction</a></li>
<li><a href=""http://en.wikipedia.org/wiki/Connected_component_labeling"" rel=""nofollow noreferrer"">http://en.wikipedia.org/wiki/Connected_component_labeling</a></li>
<li><a href=""http://www.aforgenet.com/framework/features/blobs_processing.html"" rel=""nofollow noreferrer"">http://www.aforgenet.com/framework/features/blobs_processing.html</a></li>
</ul>
",1
1885872,1885849,25,"<p>Following is the quote from More Effective C++ book from Scott Meyers:</p>

<blockquote>
  <p>The new operator calls a function to
  perform the requisite memory
  allocation, and you can rewrite or
  overload that function to change its
  behavior. The name of the function the
  new operator calls to allocate memory
  is operator new.</p>
</blockquote>
",2
1885882,1885849,40,"<p>""operator new""</p>

<pre><code>class Foo
{
public:
        void* operator new( size_t );
}
</code></pre>

<p>""new operator"":</p>

<pre><code>Foo* foo = new Foo();
</code></pre>

<p>In this example, <code>new Foo()</code> calls <code>Foo::operator new()</code></p>

<p>In other words, ""new operator"" calls ""<code>operator new()</code>"" just like the + operator calls <code>operator +()</code></p>
",11
1885896,1885849,9,"<p>There's no difference between ""new operator"" and ""operator new"". Both refer to the same thing: the overloadable/replaceable <code>operator new</code> function that typically performs raw memory allocation for objects created by <em>new-expressions</em>.</p>

<p>Note also that <em>neither</em> term is present in the language specification (which is the defining source of the official terminology). </p>

<p>When you use <code>new</code> in your program to create an object, it is called <em>new-expression</em>. <em>New-expression</em> consists of keyword <code>new</code> and additional syntactic parts defined by the grammar. No part of this expression's syntax is ever referred to as an ""operator"".</p>

<p>The raw memory allocation function <code>operator new</code> is officially referred to as just ""<code>operator new</code> function"". Note that the words <code>operator</code> and <code>new</code> in this sequence are just two separate C++ language keywords. They don't form an English term ""operator new"". Nowhere in the language specification you'll find any references to ""operator new"" as an English term. Every time this is just a combination of two independent keywords that produce declaration syntax for a memory allocation function.</p>

<p>Again, in resume: formally in C++ there's no such English language terms as ""operator new"" or ""new operator"". The former sequence is present in the language specification as a mere combination of keywords, not as an English term. The latter is not present at all.</p>
",1
1885897,1885849,141,"<p>I usually try to phrase things differently to differentiate between the two a bit better, but it's a good question in any case.</p>

<p>Operator new is a function that allocates raw memory -- at least conceptually, it's not much different from <code>malloc()</code>. Though it's fairly unusual unless you're writing something like your own container, you can call operator new directly, like:</p>

<pre><code>char *x = static_cast&lt;char *&gt;(operator new(100));
</code></pre>

<p>It's also possible to overload operator new either globally, or for a specific class. IIRC, the signature is:</p>

<pre><code>void *operator new(size_t);
</code></pre>

<p>Of course,  if you overload an operator new (either global or for a class), you'll also want/need to overload the matching operator delete as well. For what it's worth, there's also a separate operator new[] that's used to allocate memory for arrays -- but you're almost certainly better off ignoring that whole mess completely.</p>

<p>The new operator is what you normally use to create an object from the free store:</p>

<pre><code>my_class *x = new my_class(0);
</code></pre>

<p>The difference between the two is that operator new <em>just</em> allocates raw memory, nothing else. The new operator starts by using operator new to allocate memory, but then it invokes the constructor for the right type of object, so the result is a real live object created in that memory. If that object contains any other objects (either embedded or as base classes) those constructors as invoked as well.</p>
",9
1885902,1885849,2,"<p><strong>The new operator</strong>:
C++ supports dynamic allocation of objects using the new operator. The new operator allocate memory for objects from a pool called the free store. The new operator calls the special function operator new.</p>

<p><strong>operator new</strong>:
If the request is for zero bytes of storage, operator new returns a pointer to a distinct object (that is, repeated calls to operator new return different pointers). If there is insufficient memory for the allocation request, operator new returns NULL or throws an exception.
The first argument to operator new must be of type size_t (a type defined in STDDEF.H), and the return type is always void *.</p>

<p>Here is a MSDN links for more details:</p>

<p><a href=""http://msdn.microsoft.com/en-us/library/t48aek43(VS.71).aspx"" rel=""nofollow noreferrer"">The operator new Function</a></p>

<p><a href=""http://msdn.microsoft.com/en-us/library/kftdy56f(VS.71).aspx"" rel=""nofollow noreferrer"">The new  Operator</a></p>
",1
1885861,1885849,8,"<p>When you create a new object the memory is <em>allocated</em> using <strong>operator new</strong> then the constructor is invoked to <em>initialise</em> the memory.  The <strong>new operator</strong> does both the allocation and the initialisation, where as the operator new only does the allocation.</p>
",0
1797404,1797287,0,"<p>Generally speaking - you need at least one vtable entry for each virtual function you inherit. If you have no virtual functions, you have no vtable.</p>
",0
1797464,1797287,2,"<p>First, vtable's are implementation specific.  In fact, nowhere in the standard is specified that vtable's must exist at all.</p>

<p>Anyway, in most usual cases, you would get one vtable pointer per base class with virtual functions.  And, as Yuval explained, nobody ""fills"" the vtable's when an object is constructed; you have one vtable per class with virtual functions, and objects just have pointers to their correct vtable (or vtable's, in case of multiple inheritance).  In your single-inheritance example, <code>test</code> would have a pointer to <code>A</code>'s vtable, assuming that <code>A</code> has at least one virtual function (inherited from <code>B</code> or newly declared in <code>A</code>).</p>
",4
1797324,1797287,0,"<p>Generally speaking, a subclass will have a vtable pointer to each of the multiple superclasses it inherits from (assuming, obviously, that each of those classes have at least one virtual function).</p>

<p>I'm not quite sure I understood your second question. When building an object, part of the construction process is setting the relevant vtable pointers, this is something that is done implicitly by the c++ compiler by static analysis of the inheritance hierarchy. None of the vtables <em>change</em>, they are merely pointed at.</p>
",0
1797542,1797287,0,"<p>When a class defines virtual functions, the compiler silently inserts a hidden vPtr data member for each supported interface.</p>

<p>The vPtr points to the correct vTable for the object.</p>

<p>The vTable contains a list of addresses which point to function implementations.</p>

<p>Here's an example of sorts.</p>

<pre><code>class Foo: public Bar, public Baz
{
  VTable* bar_vPtr;
  VTable* baz_vPtr;

  // Bar overrides/implementations
  void barOverride();

  // Baz overrides/implementations
  void bazOverride();
};

VTable:  
    &amp;barOverride() // address of implementation

VTable:  
    &amp;bazOverride() // address of implementation
</code></pre>
",0
1852765,1852752,7,"<p>Use a wide version of stringstream and the '&lt;&lt;' operator. The correct operator to perform the conversion for you should be defined. </p>

<p>If I am missing some subtlety here you could depend on boost and use <a href=""http://www.boost.org/doc/libs/1_41_0/libs/conversion/lexical_cast.htm"" rel=""nofollow noreferrer"">this</a>.</p>

<p>I'm still a fan of secure versions of sprintf and so is <a href=""http://www.amazon.co.uk/s/ref=nb_ss?url=search-alias%3Daps&amp;field-keywords=exceptional+c%2B%2B+style&amp;x=0&amp;y=0"" rel=""nofollow noreferrer"">Herb Sutter</a> :D.</p>
",6
1852784,1852752,4,"<p>If you are using windows you can always use wsprintf ie </p>

<pre><code>wsprintf( newStr, L""%s%d"", oldStr, yourInt );
</code></pre>

<p>I'm sure there will be some equivalent for non-windows ...</p>
",3
1852802,1852752,0,"<p>How about boost lexical_cast&lt;></p>

<pre><code>std::wstring  data;

data += boost::lexical_cast&lt;std::wstring&gt;(53);
data.c_str() // This is wchar_t*
</code></pre>
",0
1803102,1803079,8,"<p>If you don't initialize fields explicitly, the compiler will try to run the default constructor of them. If they don't have an accessible default constructor, your source code will fail to compile:</p>

<pre><code>class Field {
public:
    Field(int x) {}
};
class Test {
    Field f;
public: 
    Test() {  // compiler error here. `Field` doesn't have default constructor.
       f = Field(10); 
    } 
};
int main ( ) {
    Test t;
}
</code></pre>

<p>If they do have a default constructor, you're calling it unnecessarily as you're calling another constructor of the field in the body.</p>
",0
1803103,1803079,2,"<p>Because otherwise the objects default constructor is called and then the value is set.</p>

<p>This would call only the string constructor</p>

<pre><code>class Foo{
     std::string s;
     Foo() : s(""Hello World""){}
}
</code></pre>

<p>Where as this:</p>

<pre><code>class Foo{
     std::string s;
     Foo(){
         s = ""Hello World"";
     }
}
</code></pre>

<p>Would call the default string constructor and then set the value of the string to ""Hello World""</p>
",0
1803110,1803079,14,"<p>All members are initialised before entering the body of the constructor.  If you don't provide an initialiser in the init list, then they're default constructed.</p>

<p>In your first example the following happens:</p>

<ul>
<li><code>theRadius</code> is initialised to 1.0</li>
</ul>

<p>In your second example the following happens:</p>

<ul>
<li><code>theRadius</code> is initialised</li>
<li>1.0 is copied to <code>theRadius</code></li>
</ul>

<p>With simple types like ints and floats this won't matter much.  however if your members are objects with non-trivial constructors / copy constructors then it's a lot more efficient to use the initialisation list approach.</p>
",4
1803113,1803079,3,"<p>A constructor is <em>always</em> called for object attributes before entering the constructor's body.
If you don't specify a constructor yourself, the default one will be called, and <code>operator=</code> will be used later to change the value.</p>

<p>This may not be what you want.
In particular, you can't change the value of a <code>const</code> attribute inside the constructor body.
You have to use the init list.</p>
",0
1803128,1803079,1,"<p>As already said, for non-primitive types it makes a difference.</p>

<p>It's also the only way to initialise const member variables.</p>

<pre><code>class MyClass
{
 const int x;
public: 
 MyClass(int x)
 {
  this-&gt;x=x;
 }
};
</code></pre>

<p>This should not compile.</p>
",0
1803156,1803079,1,"<p>Like others have said, it's more efficient to use the first form for types with non-trivial construction.</p>

<p>In addition, the first form gives you the ability to catch any exceptions thrown in the constructor of the member object (or base class) that is being initialized by using the function form of a try/catch block. e.g:</p>

<pre><code>MyObject() : memberObject(...)
try {
  // my constructor
}
catch (...) {
  // catches exceptions in try block AND memberObject constructor
}
</code></pre>

<p>That's not missing a set of brackets. If you do put another set of brackets around the try/catch block it will not catch exceptions in the memberObject constructor, just the try block.</p>
",0
1803245,1803079,1,"<p>It is mainly used to initialize <strong>constants and reference</strong> variable since they can't be initialized in body of constructor.</p>
",0
1912064,1912047,1,"<p>Hangs can also be caused by waiting for external resources, mostly networking.  Though that usually times out after a while.  A hang may also be caused by the termination of a thread that handles something related to processing.  For example, if a UI thread dispatched a worker thread to do some work and the worker thread died, the program would appear to be hung.</p>
",0
1912069,1912047,1,"<p>A lot of the times Windows apps hang because something happens to their message loop processing. Since all of the program events come trough the message loop once that is compromised, the program becomes unresponsive.</p>

<p>You can read more about how message loop works here:</p>

<p><a href=""http://www.winprog.org/tutorial/message_loop.html"" rel=""nofollow noreferrer"">http://www.winprog.org/tutorial/message_loop.html</a></p>
",0
1912074,1912047,0,"<p>An important factor between hanging and crashing is the underlying operating system in relation to support provided for software and hardware exception handling and/or protection mechanism. For example, in the old DOS world, you could hang the entire system with an invalid memory access when operating in real mode (since 386 > DOS-extenders crashed with exceptions, at least the popular ones such as DOS4GW). </p>

<p>Most exceptional and wrong behavior of user-mode applications can be stopped with proper support from OS and runtime libraries, with the exception of deadlocks.</p>

<p>In kernel-mode code, the possibility of hanging is much higher, of course.</p>
",0
1912080,1912047,0,"<p>It looks like you've mostly answered your own question.</p>

<p>A few additional reasons I can think of for a crash:</p>

<ul>
<li>Illegal instruction.  For example, if you run SSE code on an old CPU.</li>
<li>Bad memory access is pretty vague.  There are sub-cases of this, such as un-aligned access of words on some CPUs, stack overflow, access to unmapped pages, writing to read-only pages, executing non-executable pages, concurrent access leading to broken invariants, to name a few...</li>
<li>On Linux your process can be killed (seemingly randomly) if the system is very low on memory.  (see this search for <a href=""http://www.google.com/search?q=oom+killer"" rel=""nofollow noreferrer"">""OOM killer""</a>)</li>
</ul>

<p>In addition to deadlocks, you have:</p>

<ul>
<li><a href=""http://www.google.com/search?q=livelock"" rel=""nofollow noreferrer"">""Livelocks"".</a></li>
<li>UI threads being blocked by some other action (some examples: I/O, pages being evicted to disk in low memory circumstances)</li>
<li>Other programmer errors, such as loops that never terminate in some condition that hasn't been tested.</li>
</ul>
",1
1912082,1912047,14,"<p><strong>Crashing</strong> is normally caused by an illegal instruction, e.g. accessing invalid memory, dividing by zero, etc.  Usually this manifests itself as a well-known exception which is handled by the operating system.</p>

<p><strong>Hanging</strong> can be broken up into 2 fairly high level categories:</p>

<ul>
<li><strong>Deadlock</strong>, usually caused by 2 threads competing for a resource, each requiring a resource held by the other thread to be released.  A common cause of this is acquiring multiple locks in inconsistent orders within multiple threads, leading to the common <a href=""https://stackoverflow.com/questions/1892619/threads-and-simple-dead-lock-cure/1892640#1892640"">ABBA deadlock pattern</a> (and no this has nothing to do with Swedish pop music).</li>
<li><strong>Livelock</strong>, which means that the code is still actively running, but you have reached a state that you cannot leave.  For example:

<ul>
<li>The state of 2 processes/threads keep changing, never reaching an end condition</li>
<li>A <em>while loop</em> where the exit condition will never be satisfied, or an <em>indefinite loop</em> (although this is stretching the definition of ""livelock"").</li>
</ul></li>
</ul>

<p><em>Update based on question comment</em></p>

<blockquote>
  <p>@Pop, Kristo: Am actually checking on
  a code that hangs but I see some
  problems on memory leak. But I'm not
  really sure if memory leak causes a
  program to hang. ¨C jasonline</p>
</blockquote>

<p>A memory leak can cause a program to crash, but this depends on various factors:</p>

<ul>
<li>Size of leak</li>
<li>Frequency of leak</li>
<li>Lifetime of application</li>
</ul>

<p>Memory leaks may result in 2 bad things - a continual increase in memory usage by the process, and memory fragmentation.  Both of these can result in failure to allocate memory down the line, if the OS cannot provide a contiguous block of memory.</p>

<p>In C++, if the <code>new</code> operator fails to allocate memory, a <code>std::bad_alloc</code> exception will be thrown.  This will most likely be caught by the OS, resulting in a crash (unless you have written a specific handler in your application for this exception, and are able to handle it more gracefully).</p>
",2
1912113,1912047,0,"<p>From your comment, it's possible that your memory leak is <em>related</em> to your hang, but not the <em>cause</em> of it.  That is, you may have something as simple as an infinite loop somewhere that grabs a bit more memory in each iteration.</p>
",0
1851482,1851468,20,"<p>CPUs are usually fastest when dealing with their ""native"" integer size. So even though a <code>short</code> may be smaller than an <code>int</code>, the <code>int</code> is probably closer to the native size of a register in your CPU, and therefore is likely to be the most efficient of the two.</p>

<p>In a typical 32-bit CPU architecture, to load a 32-bit value requires one bus cycle to load all the bits. Loading a 16-bit value requires one bus cycle to load the bits, <em>plus</em> throwing half of them away (this operation may still happen within one bus cycle).</p>
",9
1851510,1851468,0,"<p>The short type is very useful if you have a big array full of them and int is just way too big.</p>

<p>Given that the array is big enough, the memory saving will be important (instead of just using an array of ints).</p>

<p>Unicode arrays are also encoded in shorts (although other encode schemes exist).</p>

<p>On embedded devices, space still matters and short might be very beneficial.</p>

<p>Last but not least, some transmission protocols insists in using shorts, so you still need them there.</p>
",4
1851512,1851468,14,"<p>A 16-bit short makes sense if you're keeping <em>so many</em> in memory (in a large array, for example) that the 50% reduction in size adds up to an appreciable reduction in memory overhead. They are <em>not</em> faster than 32-bit integers on modern processors, as Greg correctly pointed out.</p>
",0
1853149,1851468,1,"<p>In embedded systems, the <code>short</code> and <code>unsigned short</code> data types are used for accessing items that require less bits than the native integer.</p>
<p>
For example, if my USB controller has 16 bit registers, and my processor has a native 32 bit integer, I would use an <code>unsigned short</code> to access the registers (provided that the <code>unsigned short</code> data type is 16-bits).
</p>
<p>
Most of the advice from experienced users (see news:comp.lang.c++.moderated) is to use the native integer size unless a smaller data type must be used.  The problem with using <code>short</code> to save memory is that the values may exceed the limits of <code>short</code>.  Also, this may be a performance hit on some 32-bit processors, as they have to fetch 32 bits near the 16-bit variable and eliminate the unwanted 16 bits.
</p>
<p>My advice is to work on the quality of your programs first, and only worry about optimization if it is warranted and you have extra time in your schedule.</p>
",1
1899116,1899105,3,"<p>That is because, when <code>B::func()</code> the memory allocated for the <code>x[]</code> is released hence if you try to access that memory location afterwards you will get garbage values. But when you do <code>char *x=""String""</code>, the memory for the string ""String"" is most probably allocated only once from the read-only section of your process memory. This address is guaranteed to remain valid until the execution of your program. In that case, if you try to access the pointer variable it will work correctly. BTW, as a side note, you need to declare a virtual base class destructor.</p>
",3
1899121,1899105,0,"<p>First off, figure out how to post code blocks. It's not hard, just indent them by four spaces.</p>

<p>Second, you should never return a pointer to a function-local variable. Because they're allocated on the stack, and all bets are off as regards to whether they're around after the function returns.</p>

<p>EDIT: This was written when the provided code was butchered and incomplete. My point doesn't apply to this particular case, but it's still important to know.</p>
",0
1899135,1899105,6,"<p>When you do something like:</p>

<pre><code>char *f(){ return ""static string""; }
</code></pre>

<p>You're returning the address of a string literal, but that string literal is <em>not</em> local to the function. Rather, it is statically allocated, so returning it gives well-defined results (i.e. the string continues to exist after the function exits, so it works).</p>

<p>When you (attempt to) return the address of an array of char like this:</p>

<pre><code>char *f() { 
   char x[] = ""automatically allocated space""; 
   return x; 
}
</code></pre>

<p>The compiler allocates space for <code>x</code> on the stack, then initializes it from a string literal to which you don't have direct access. What you're returning is the address of the memory in the stack, <em>not</em> the string literal itself -- so as soon as the function exits, that array ceases to exist, and you have no idea what else might be put at that address. Trying to use that address causes undefined behavior, which means anything can happen.</p>
",4
1899144,1899105,0,"<p>To try to be more precise: B::func() is returning a pointer to a hunk of memory that it used for a temporary array. There are absolutely no guarantees what is in that memory once the function returns. Either (1, simplest good practice ) the calling function can allocate memory and pass <em>in</em> a string buffer for the called function to use or (2) the called function needs to allocate a buffer and the calling function needs to later release it (but this requires a very disciplined approach by the developer of the calling function, and I'd never want to rely on that) or (3, probably really the best practice) the calling function can pass in some sort of smart pointer that will release its memory when it goes out of scope, and have the called function use that smart pointer to point to the memory it allocates.</p>
",0
1884199,1882070,1,"<p>If you want to know, dynamically, which functions are being used you could get the (vc++) compiler to insert callcap hooks and then use those to dump out usage information.</p>

<p>This could be a useful compliment to static analysis based approaches, since it will see every piece of code that is entered during execution (regardless of how execution arrives there). </p>

<p>See <a href=""http://msdn.microsoft.com/en-us/library/ms254291(VS.80).aspx"" rel=""nofollow noreferrer"">http://msdn.microsoft.com/en-us/library/ms254291(VS.80).aspx</a> for info on call profile hooks in visual studio.</p>
",0
1884830,1882070,10,"<p>Use <code>__declspec(deprecated)</code> in front of the function declaration you want to get rid of. That will throw up compile warnings if that function is actually used at compile time.</p>
",2
1884871,1882070,2,"<p>I'm pretty sure that mathematically, this can't be done in the general case. If you allow for recursion and function pointers (or first class functions) then you end up in a pretty simple reduction to the Halting Problem.</p>

<p>Granted, this be a case that you never have to deal with, but you should know abut it...</p>
",1
1882410,1882070,1,"<p>If your code is simple enough static analysis might work. However C++ is very context-sensitive :/. So I personally would not even try to look for a tool in the area. At least not until CLANG is fully compliant with C++ :D</p>

<p>I hope you have unit-tests, I would get visual studio to compile code which generates a runtime profile and then farm the function names's (with a scripting language) from the generated profile. If you have covered all of the use-cases (either manually or with unit-tests) in your application you should be able to identify the least used (or never-used) functions. Then you can use the mark-one eyeball to trim down the source-base.</p>

<p>There is nothing like doing It manually though :D </p>
",0
1882466,1882070,1,"<p>Visual Studio can generate call graphs, showing 'called-by' for each function.  Doxygen will do the same if you don't want to use Visual Studio.</p>

<p>However both these methods will fail to detect a function called through a pointer, but that should normally be easy to check manually.</p>
",3
1717360,1717312,1,"<p>Use the frameworks that are supported/recommended by the OS on the mobile device.</p>

<p>After that, if you get more than one answer to the above question, check to see which one features the features you want for your application.</p>

<p>After that, pick the one done in the programming language you are most used to.</p>

<p>Good luck.
M.</p>
",0
1720776,1717312,0,"<p>+1 Qt. Qt's framework is great. and it goes LGPL now.</p>
",0
1720799,1717312,0,"<p>It might be worth looking into <a href=""http://www.easygui.com/"" rel=""nofollow noreferrer"">easyGUI</a>. It it can be used with just about any OS and supports just about any device. The only downside is that it costs money.</p>
",0
1720818,1717312,0,"<p>What I really think you're saying is that you're porting Linux to a completely new device, e.g. one of these electric book things.</p>

<p>I'd suggest you port Android (which is Linux down deep so that part of porting is much the same) and use Java for your UI.</p>
",0
1896542,1896527,6,"<p>EDIT: Indeed the problem described here is not the only one, see the other answers for more complete solutions.</p>

<pre><code>upperCaseCount[int(oneLetter)- 65]++; //make the index match the count array
                     if (oneLetter &gt;= 'a' &amp;&amp; oneLetter &lt;='z') 
                                     { //decide if it is a lower letter
                           lowerCaseCount[int(oneLetter)- 65]++;
</code></pre>

<p>(At least) one of these two <code>65</code> is wrong. I would recommend <code>int('A')</code> and <code>int('a')</code> instead...</p>

<p>Note: this is probably not what explains your problem.</p>
",5
1896544,1896527,2,"<p>Your <code>if</code> concerning upper and lower case letters are incorrectly nested. You don't even look at lowercase letters if <code>oneLetter</code> is not uppercase. Those two <code>if</code>s should be at the same level.</p>

<p>That's the only error I can see.</p>

<p>I'd recommend either debugging, as gf suggests, or throwing in some print statements to verify your assumptions about what's happening (or not).</p>
",0
1896548,1896527,4,"<p>You just have your <code>if</code> statement scoping wrong here.  Each letter can be <em>either</em> uppercase or lowercase, but the way your <code>if</code> statements are scoped, you're only checking for lowercase if the letter is already uppercase, which of course is nonsensical.</p>

<p>You want something more like:</p>

<pre><code>for(unsigned n = 0; n &lt; lineBuffer.length(); ++n)
{
   oneLetter = char( lineBuffer[n] ); // get a letter
   if (oneLetter &gt;= 'A' &amp;&amp; oneLetter &lt;='Z') {
     upperCaseCount[int(oneLetter)- 'A']++;
   }
   else if (oneLetter &gt;= 'a' &amp;&amp; oneLetter &lt;='z') { 
     lowerCaseCount[int(oneLetter)- 'a']++;
   }
}
</code></pre>
",1
1896556,1896527,1,"<p>There could be other things wrong with this code, but one thing that stands out is that the if statement that counts the lower case letters is inside the if statement that counts the upper case statement. Your test file probably does not contain any upper case letters, and hence the output is a solid zero.</p>

<p>There should be two separate if statements, like: </p>

<pre><code>if (oneLetter &gt;= 'A' &amp;&amp; oneLetter &lt;='Z') 
{ //decide if it is a capital letter
  upperCaseCount[int(oneLetter)- 65]++; //make the index match the count array   
}//end

if (oneLetter &gt;= 'a' &amp;&amp; oneLetter &lt;='z') 
{ //decide if it is a lower letter
  lowerCaseCount[int(oneLetter)- 65]++; //make the index match the count array
}//end 
</code></pre>
",3
1896862,1896527,7,"<p>You've gotten some help with the problem you knew you had, now perhaps a bit with one you may not realize you have (yet):</p>

<pre><code>   while (!inMyStream.eof() )
   {
       //get a line of text
       getline (inMyStream, lineBuffer);
</code></pre>

<p>One thing you should learn right away is that as you've written it, this won't work correctly. What you normally want to do is:</p>

<pre><code>while (getline(inMyStream, lineBuffer)) {
    // .. the rest of the processing.
</code></pre>

<p>However, since you're only processing one character at a time, and ignoring everything but letters, it would probably be simpler to only <em>read</em> one character at a time:</p>

<pre><code>int ch;
while (inMyStream &gt;&gt; ch)
// process the character
</code></pre>

<p>Since nobody else has mentioned them, I'll also point out that instead of explicitly testing against 'a' and 'z' to find lowercase letters, and 'A' and 'Z' to find upper case, you'd be better off using <code>islower</code> and <code>isupper</code>, which are supplied in <code>&lt;ctype.h&gt;</code> (among a couple of other places):</p>

<pre><code>#include &lt;ctype.h&gt;

while (inMyStream &gt;&gt; ch)
    if (isupper((unsigned char)ch))
        ++upperCount[(unsigned char)ch-'A'];
    else if (islower((unsigned char)ch))
        ++lowerCount[(unsigned char)ch-'a'];
</code></pre>
",2
1897162,1896527,0,"<p>How about the printout at the end, where lower case letter counts are printed twice? This explains why it's ""zeroes all the way down"", because the original code <em>was</em> counting the upper case letters correctly wasn't it?</p>
",0
1695929,1695922,1,"<p>The message buffer is an array of char. Index 0 contains one char, so you cannot put 2 chars into one char. That would violate the rule that one bit contains one binary digit :-)</p>

<p>The correct solution is to do this:</p>

<blockquote>
  <p>messageBuffer[0]='0';</p>
  
  <p>messageBuffer[1]='1';</p>
</blockquote>

<p>or:</p>

<blockquote>
  <p>messageBuffer[1]='0';</p>
  
  <p>messageBuffer[0]='1';</p>
</blockquote>

<p>or</p>

<blockquote>
  <p>messageBuffer[0]=10;</p>
</blockquote>
",1
1695939,1695922,1,"<p>'10' is not a valid value, thus the overflow</p>

<p>either write 10 as in messageBuffer[0]=10 - if ten is the value you want to put it or do as Lars wrote.</p>
",1
1909944,1909787,2,"<p>I suggest you have a look at the <a href=""http://code.google.com/p/google-breakpad/"" rel=""nofollow noreferrer"">google-crashpad</a> project. They seem to have common a <a href=""http://code.google.com/p/google-breakpad/wiki/SymbolFiles"" rel=""nofollow noreferrer"">symbol file format</a> and corresponding tool to generate these files from platform specific symbol file formats.</p>

<p>AFAIK, Firefox project uses this library on the client side for crash reporting and on the server side, they employ this symbol file format for stack traces for the crash reports.</p>
",0
1538922,1538878,2,"<p>This sounds homework-ish, so I'll only give you an idea: </p>

<p>You need a mapping from each number to the corresponding set of letters. Then you generate the possible permutations for all the different letters corresponding to the respective digits. </p>

<p>For example, for the digit ""1"", the possible letters are 'A', 'B', and 'C', for the digit ""2"" they are 'D', 'E', and 'F'. so for the number ""12"" the possible permutations would be </p>

<pre><code>AD
AE
AF
BD
BE
BF
CD
CE
CF
</code></pre>

<p>Does this help? </p>
",1
1538928,1538878,-1,"<p>Pseudo code:</p>

<pre><code>main(char[] input) {
  for(int i = 0 .. 3) { letters[i] = letters(input[i]) };

  for(int i = 0 .. letters[0].length) {
    for(int j = 0 .. letters[1].length) {
      for(int k = 0 .. letters[2].length) {
        for(int l = 0 .. letters[3].length) {
          print(letters[0][i], letters[1][j], letters[2][k], letters[3][l]);
        }
      }
    }
  }
}

char[] letters(char digit) {
  switch (digit) {
    case '2' : {'a', 'b', 'c'};
    ..
    case '9' : {'w', 'x', 'y', 'z'};
  }
}
</code></pre>
",0
1538936,1538878,1,"<p>Every 4 digit sequence of vanity letters is a vanity letter followed by a 3-digit sequence of vanity letters. Does that give you an idea of how to break it down?</p>
",0
1539066,1538878,0,"<p>My C++ is a bit rusty, but this should get you pretty close.  The idea here is to use a combination of looping and recursion.  The recursion depth is equal to the length of the phone number, and each level of recursion generates the possible permutations for that and subsequent digits of the phone number.</p>

<p>The code itself is easy - understanding why it works is the hard part :)</p>

<pre><code>std::map&lt;char,std::string&gt; letters = new std::map&lt;char,std::string&gt;();
letters.put('1', ""ABC"");
letters.put('2', ""DEF"");
... etc ...

std::vector&lt;std::string&gt; all_permutations = new std::vector&lt;std::string&gt;();

void GeneratePermutations( std::string number, int digit, std::string vanity) {
   std::string letters_for_number = letters.get(number[digit - 1]);

   for( int i = 0; i &lt; letters_for_number.size(); i++ ) {
      vanity += letters_for_number[i];
      if ( digit &lt; number.length() ) {
         GeneratePermutations(number, digit + 1, vanity);
      } else {
         all_permutations.add(vanity);
      }
   }
}

void main() {
    GeneratePermutations(""1234"", 1, """");
}
</code></pre>
",2
1787242,1787222,2,"<p><code>string</code> uses <code>char</code>s which are only 8 bits. You need to use <a href=""http://msdn.microsoft.com/en-us/library/wt3s3k55%28VS.80%29.aspx"" rel=""nofollow noreferrer"">wstring</a> if you want to encode 16-bit characters.</p>
",0
1787269,1787222,1,"<p>Your string is probably UTF-8, where ""characters"" and ""bytes"" are not the same thing.  The <code>std::string</code> class assumes ""characters"" are one byte each, so the results are wrong.</p>

<p>Your options are to convert the string to UTF-16 and use a <code>wstring</code> instead, where you can (generally) assume that characters are all two bytes (a <code>wchar_t</code> or <code>short</code>) each, or you can use a library like <a href=""http://site.icu-project.org/"" rel=""nofollow noreferrer"">ICU</a> or <a href=""http://utfcpp.sourceforge.net/"" rel=""nofollow noreferrer"">UTF8-CPP</a> to operate on UTF-8 strings directly, doing things like ""get the 3rd character"" rather than ""get the 3rd byte"".</p>

<p>Or, if you want to go minimalist, you could just code up a (relatively) simple function to get the byte offset and length of a particular character by reusing the internals of one of the UTF-8 string-length functions from one of the libraries listed above or from google.  Basically you have to inspect each character and jump ahead 1-3 bytes to get to the start of the next character depending on what bits are set.</p>

<p>Here's one that could be easily translated from PHP:</p>

<pre><code>for($i = 0; $i &lt; strlen($str); $i++) {
    $value = ord($str[$i]);
    if($value &gt; 127) {
        if($value &gt;= 192 &amp;&amp; $value &lt;= 223)
            $i++;
        elseif($value &gt;= 224 &amp;&amp; $value &lt;= 239)
            $i = $i + 2;
        elseif($value &gt;= 240 &amp;&amp; $value &lt;= 247)
            $i = $i + 3;
        else
            die('Not a UTF-8 compatible string');
        }
    $count++;
} 
</code></pre>

<p><a href=""http://www.php.net/manual/en/function.strlen.php#25715"" rel=""nofollow noreferrer"">http://www.php.net/manual/en/function.strlen.php#25715</a></p>
",0
1787830,1787822,36,"<p>If they are linker errors, the most likely cause is probably non-inline functions defined in the header.  </p>

<p>If you have a non-inline function in a header that is included in more than one source file, it will be defined in each of those source files (""translation units""), thus the function will be defined more than once, hence the multiple definitions error.</p>
",4
1787837,1787822,1,"<p>If you're getting linker errors... are you sure you're not 1) actually defining a function twice in code or 2) trying to do something silly like <code>#include</code> a source file (as opposed to a header file)?</p>
",0
1787844,1787822,0,"<p>This can also be caused by using different versions of the cstd lib from other library's linked in.  Check under the c++/Code generation section and make sure all your projects are using the same settings.</p>
",0
1991023,1991019,10,"<p>You need to single-quote <code>char</code> literals.  You did this correctly for the first one but not the second:</p>

<pre><code>while (ans == 'y' || ans == ""Y"");
</code></pre>

<p>This should be:</p>

<pre><code>while (ans == 'y' || ans == 'Y');
</code></pre>

<p>Double quotes are for string (<code>const char[]</code>) literals.</p>
",2
1991025,1991019,1,"<p>You have double quotes instead of single ones on this line:</p>

<pre><code>while (ans == 'y' || ans == ""Y"");
</code></pre>
",0
1991027,1991019,1,"<p>The capital Y is contained in double quotes, which creates a <code>const char [2]</code> (Y followed by null). You probably ment:</p>

<pre><code>while (ans == 'y' || ans == 'Y');
</code></pre>
",0
1991049,1991019,-2,"<p>I dont know this is useful or not but it may be like following:</p>

<p>while ((ans == 'y') || (ans == 'Y'));</p>
",1
1801179,1801046,2,"<p>There's no definitive answer to your question; it's really a matter of taste, to be honest.  It sounds like using the <code>friend</code> keyword is fine here, if these two classes are logically coupled, especially if no other class will ever need access to the private member variables you're referring to.  Another option would be to make the input handling class a nested class inside the main class.  It will then automatically have access to the private member variables, and more strongly emphasize the logical coupling of the two classes.</p>

<p>But this is a subjective judgment call; whatever approach you think makes your code more readable, more accessible, and easier to maintain is the right answer.</p>
",3
1801094,1801046,0,"<p>It sounds to me like making the classes friends defeats the purpose of splitting up the one class that is ""too large.""  If you do that then you'll be dividing the class up into two, but they'll still be tightly coupled and just as inseparable as before.</p>

<p>One approach would be to write public methods that describe what you want to do in response to input.  For example, if your class represents a cursor that can move in four directions based on arrow key input, you'd write methods like ""MoveUp"" and ""MoveLeft"", and then call those methods outside of the class in response to input events.  In that case, it wouldn't be necessary to access the class's private cursor data.</p>
",0
1721576,1721562,0,"<p>Sounds like you're looking for an obfuscator for C++ code.</p>

<p>A quick googling provides these twos examples of such:</p>

<ul>
<li><a href=""http://freshmeat.net/projects/cxx-obfus"" rel=""nofollow noreferrer"">http://freshmeat.net/projects/cxx-obfus</a></li>
<li><a href=""http://www.stunnix.com/prod/cxxo/overview.shtml"" rel=""nofollow noreferrer"">http://www.stunnix.com/prod/cxxo/overview.shtml</a></li>
</ul>

<p>Others almost certainly exist as well.</p>
",0
1721586,1721562,0,"<p>Without good unit tests it's very hard to be sure that you get exactly the same results.</p>

<p>It's tempting to use simple text manipulation scripting tools (such as perl ) however thse don't understand the C++ syntax and so you get into confusions such literal strings versus variable names.</p>

<p>Hence seek out refactoring tools such as <a href=""http://www.ifs.hsr.ch/Projects/Projects/C_Refactoring"" rel=""nofollow noreferrer"">this</a></p>

<p>As has already been observed, if you want obfuscation then there are dedicated tools for that.</p>
",1
1721792,1721562,2,"<p><a href=""http://www.wholetomato.com/"" rel=""nofollow noreferrer"">Visual Assist X</a>, even tho it's not free software. Also assuming, you work with MS-IDE.</p>
",0
1723085,1721562,0,"<p>I like ad-hoc perl using regular expressions.  I've blogged a couple examples of such changes:</p>

<p><a href=""http://peeterjoot.wordpress.com/2009/09/02/regular-expression-driven-code-alteration/"" rel=""nofollow noreferrer"">http://peeterjoot.wordpress.com/2009/09/02/regular-expression-driven-code-alteration/</a></p>

<p><a href=""http://peeterjoot.wordpress.com/2009/08/06/dirty-perl-tricks-using-evaluations-in-a-replacement-expression/"" rel=""nofollow noreferrer"">http://peeterjoot.wordpress.com/2009/08/06/dirty-perl-tricks-using-evaluations-in-a-replacement-expression/</a></p>
",0
1914028,1913548,0,"<p>You may be interested in <a href=""https://rads.stackoverflow.com/amzn/click/com/0735611319"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">this book</a>. It explains how computers work, going from the lowest hardware level to a code.
Cannot recommend it enough!</p>

<p><a href=""http://ecx.images-amazon.com/images/I/31VTerGLfML._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA240_SH20_OU01_.jpg"" rel=""nofollow noreferrer"">http://ecx.images-amazon.com/images/I/31VTerGLfML._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA240_SH20_OU01_.jpg</a></p>
",0
1914925,1913548,1,"<p>You will need some assembly. This is becaused there are some privileged instructions that are needed for operating system design that will not be generated by a C/C++ compiler.</p>

<p>One example is when userside code want to make use of an operating system service (like interprocess communication) it needs to switch from user mode into kernel mode. This is normally done by issuing a Software Interrupt (SWI). A C++ will never create the SWI instruction.</p>

<p>Similarly, when writing an arbitrary precision integer arithmatic library, one will need to find of the value of the Carry Bit. There is no C/C++ operator that can do this for you. You will have to use assembler.</p>

<p>Incidentation, writing directly to a device register can and often is done in C. the volatile keyword is placed into the language specifically for registers whose values can change unexpectedly</p>
",1
1913556,1913548,0,"<p>Simply, yes you can.</p>
",5
1913558,1913548,11,"<p>Well ... Typically you will need at least some assembly at the very lowest levels, for machine-dependent initialization and so on.</p>

<p>So ""no"" strictly speaking, but that can really be a very small proportion, making the real answer ""yes"".</p>

<p><a href=""http://en.wikipedia.org/wiki/BeOS"" rel=""nofollow noreferrer"">BeOS</a> is an example of an operating system written in C++.</p>
",0
1913567,1913548,0,"<p>You can write all possible programs in C++. In fact, you can write most programs in most languages, especially if you exclude performance concerns. This concept is known as ""Turing completeness""</p>
",3
1913589,1913548,-1,"<p>You could program a complete OS in C++ if you were so inclined (and had a decade or so to spare....) since it does compile to machine code.</p>

<p>It's probably not a 'beginner' task though, and to be honest, plain old C would be a better choice for system level stuff (both the Windows and Linux kernels use C).</p>
",3
1913630,1913548,2,"<p>No you cannot. </p>

<p>You need low-level services which are not standardized within programming languages. For example, you need system port and DMA IO, that basically look different on all platforms. This is usually done by inline assembly code on the lowest level, though some C++ compilers will provide you with special keywords to access CPU features such as registers and special opcodes. For instance, in MS VC++ you have _EAX pseudo-variable to access the EAX CPU register.</p>
",3
1915690,1913548,1,"<p>Yes. C++ is <a href=""http://en.wikipedia.org/wiki/Turing_completeness"" rel=""nofollow noreferrer"">Turing Complete</a>... So is Excel, which a clever dude discovered while implementing <a href=""http://www.gamasutra.com/view/feature/3563/microsoft_excel_revolutionary_3d_.php"" rel=""nofollow noreferrer"">a realtime 3D engine</a>.</p>
",0
1971388,1971087,4,"<p>you can use <a href=""http://gmplib.org/"" rel=""noreferrer"">GNU Multiple Precision Arithmetic Library</a> for C++. </p>

<p>If you just want an easy way to multiply huge numbers( Integers ), here you are:</p>

<pre><code>#include&lt;iostream&gt;

#include&lt;string&gt;
#include&lt;sstream&gt;
#define SIZE 700

using namespace std;



class Bignum{

    int no[SIZE];   


    public:

        Bignum operator *(Bignum&amp; x){ // overload the * operator
        /*
            34 x 46
            -------
               204          // these values are stored in the
              136           // two dimensional array mat[][];
            -------
             1564   // this the value stored in ""Bignum ret""
        */                              
    Bignum ret;             
    int carry=0;
    int mat[2*SIZE+1][2*SIZE]={0};
    for(int i=SIZE-1;i&gt;=0;i--){
        for(int j=SIZE-1;j&gt;=0;j--){
            carry += no[i]*x.no[j];
            if(carry &lt; 10){
                mat[i][j-(SIZE-1-i)]=carry;
                carry=0;
            }
            else{
                mat[i][j-(SIZE-1-i)]=carry%10;
                carry=carry/10;
            }
        }
    }
    for(int i=1;i&lt;SIZE+1;i++){
        for(int j=SIZE-1;j&gt;=0;j--){
            carry += mat[i][j]+mat[i-1][j];

            if(carry &lt; 10){

                mat[i][j]=carry;

                carry=0;

            }

            else{

                mat[i][j]=carry%10;

                carry=carry/10;

            }
        }
    }
    for(int i=0;i&lt;SIZE;i++)
        ret.no[i]=mat[SIZE][i];
    return ret;
}

Bignum (){

    for(int i=0;i&lt;SIZE;i++)

        no[i]=0;

}


Bignum (string _no){

    for(int i=0;i&lt;SIZE;i++)

        no[i]=0;

    int index=SIZE-1;

    for(int i=_no.length()-1;i&gt;=0;i--,index--){

        no[index]=_no[i]-'0';

    }

}


void print(){

    int start=0;

    for(int i=0;i&lt;SIZE;i++)

    if(no[i]!=0){

        start=i;

        break;      // find the first non zero digit. store the index in start.

    }

    for(int i=start;i&lt;SIZE;i++) // print the number starting from start till the end of array.

        cout&lt;&lt;no[i];

    cout&lt;&lt;endl;

    return;

}
 };


 int main(){

Bignum n1(""100122354123451234516326245372363523632123458913760187501287519875019671647109857108740138475018937460298374610938765410938457109384571039846"");
Bignum n2(""92759375839475239085472390845783940752398636109570251809571085701287505712857018570198713984570329867103986475103984765109384675109386713984751098570932847510938247510398475130984571093846571394675137846510874510847513049875610384750183274501978365109387460374651873496710394867103984761098347609138746297561762234873519257610"");

Bignum n3 = n1*n2;
n3.print();

return 0;

  }
</code></pre>

<p>as you can see, it's multiply 2 huge integer :) ... (up to 700 digits)</p>
",0
1972251,1972231,0,"<p>You need to install something, not necessarily the framework. Some frameworks, like DirectX for example have a client installation. Some components are simple dll files that you can deliver with your software, creating an installation package. </p>
",2
1972264,1972231,3,"<p>It depends whether the library you are using is statically or dynamically linked. In the former case, it is part of the executable file that you distribute. In the latter case, it is an extra file (or set of files) with extensions such as .so or .dll, which you should distribute with your app.</p>
",0
1972269,1972231,0,"<p>Generally when using a framework there will be a framework redistributable (.NET, DirectX, etc) which can be bootstrapped into your installation to install the framework (or run by the end user as the first part of ""installing"" your app). </p>

<p>Many libraries simply need to be included with your code to function correctly, they themselves might have dependencies which need to be installed but these should be called out.</p>

<p>If in doubt, before you distribute your package run it on a fresh install of your target system (Linux, Windows, etc) and see if it complains about missing dependencies. Include those in your package and try again.</p>

<p>You can also look at installation systems (RPM, Apt, Windows Installer, etc) which can handle all of these tasks for you directly (or provide scripting languages to help you automate the job).</p>
",0
1972243,1972231,0,"<p>The end-user need to have the framework installed.</p>

<p>As you need to have .Net installed to run some Microsoft(and other companies) products. If your application is written in C++ using <a href=""http://www.gtk.org/"" rel=""nofollow noreferrer"">GTK</a> or <a href=""http://qt.nokia.com/"" rel=""nofollow noreferrer"">Qt</a>. You need to have they installed, but if you're on Linux using <a href=""http://www.kde.org/"" rel=""nofollow noreferrer"">KDE</a>, Qt is natively installed for default, the same for <a href=""http://www.gnome.org/"" rel=""nofollow noreferrer"">Gnome</a> and also the same of Cocoa on Mac and Cocoa-Touch on iPhone and iPod Touch.</p>

<p>I suggest you to have the installer of the framework used embedded on the installer of your application. As <a href=""http://www.gimp.org/"" rel=""nofollow noreferrer"">GIMP</a> and <a href=""http://xchat.org/"" rel=""nofollow noreferrer"">Xchat</a> do.</p>
",0
1972244,1972231,0,"<p>Yes, libraries must be bundled with your application/installed before hand, as they are the framework upon which your application relies. If you don't install the framework, your application will not work.</p>
",0
1918095,1918065,1,"<p>Are you just having trouble with the syntax?   It should be</p>

<pre><code>void ClassC::Function(B&amp; b)
{
    b.DoSomething();
}
</code></pre>

<p>to make <code>b</code> a reference of type <code>B</code>.</p>
",1
1918119,1918065,6,"<p>The way you are declaring the class is wrong:</p>

<pre><code>class A : public B // no more class keyword here
{

}; // note the semicolon

void ClassC::Function(const B &amp;b) // this is how you declare a parameter of type B&amp;
{
}
</code></pre>

<p>You simply need to pass the object of type <code>A</code> to the <code>Function</code>. It'll work.
It's good to declare the parameter as <code>const</code> if you want to take derived types too.
To pass the <code>this</code> instance, you'd simply call:</p>

<pre><code>classCObject.Function(*this);
</code></pre>
",0
1925531,1925518,0,"<pre><code>class A {
protected:
    void writeLogEntry(const std::string&amp; message);


    friend class C;
};
</code></pre>
",0
1925536,1925518,2,"<p>You can befriend class C with A.</p>

<pre><code>class A {
protected:
    friend class C;
    void writeLogEntry(const std::string&amp; message);
};
</code></pre>

<p>AFAIR, should work.</p>
",0
1925537,1925518,0,"<p>Other folks already answered, but I suggest you read <a href=""http://www.parashift.com/c++-faq-lite/friends.html"" rel=""nofollow noreferrer"">http://www.parashift.com/c++-faq-lite/friends.html</a> for more information about friends!</p>

<p>As a matter of fact, read the entire FAQ while you're at it!</p>
",0
1925571,1925518,0,"<p>I'd personally go with b). Make a public method in B to call A's writeLogEntry. But that's just me! :)
Also, you could use ""friend class C"" in the A class like the others said.</p>
",0
1925573,1925518,3,"<p>I think it's really up to you how to design your class hierarchy. If you are using inheritance and you don't mind the function being accessable from an instance of class <code>A</code> then there is no point to delegate <code>writeLogEntry</code>. Might as well make it public in the base class:</p>

<pre><code>class A {
public:
    void writeLogEntry(const std::string&amp; message);
};
</code></pre>

<p>If don't want to <code>writeLogEntry</code> being accessable from an instance of class <code>A</code> then you have delegate:</p>

<pre><code>class B : public A { 
    void writeLogEntry(const std::string&amp; message){ A::writeLogEntry(message); }
};
</code></pre>

<p>Do some research into <a href=""https://stackoverflow.com/search?q=inheritance+composition"">Inheritance vs. Composition</a>.  You might get a few ideas on how to structure your classes. Some people prefer to avoid inheritance as much as possible and in this case have class <code>B</code> own an instance of class <code>A</code> and delegate the relevant methods. IMHO there are genuine cases for when inheritance is appropriate, depends on the nature of your particular beast.</p>
",1
1925574,1925518,0,"<p>Apart from making class C a friend of class A, if writeLogEntry() is virtual in class A, and if it is overridden in class B with public access specifier,then it can be accessed from class C.</p>

<pre><code>class A
{
  protected:
  virtual void writeLogEntry() { cout &lt;&lt; ""A::mymethod"" &lt;&lt; endl; }
};
class B : public A
{
  public:
       virtual void writeLogEntry() { cout &lt;&lt; ""B::mymethod"" &lt;&lt; endl; }
};

class C 
{
 public:
  void writeLogEntry()
  {
     B b;
     b.writeLogEntry();
  }
};
</code></pre>
",0
1925589,1925518,0,"<p>I'd prefer declare writeLogEntry public in base class. Because it tends to be part of the accessible interface.</p>

<p>If it's declared in derived class, then the user of this method is tightly bound to the derived class. Usually, it's a better idea to rely on abstraction.</p>
",0
1695305,1695303,0,"<p>Yes, though those are generally called 'constants'.  See the article anon linked for a discussion of 'invariant' as it's generally used in object-oriented design.</p>
",0
1695306,1695303,1,"<p>Sure. This is a common idiom across several OO languages including Java.</p>
",2
1616533,1616525,0,"<p>If you store a pointer to an object, and that object is destroyed (e.g. goes out of scope), that pointer will not be null, but if you try to use it you will get undefined behavior.  So if one of the pointers in your vector points to a stack-allocated object, and that object goes out of scope, that pointer will become impossible to use safely.  In particular, there's no way to tell whether a pointer points to a valid object or not; you just have to write your program in such a way that pointers never ever <em>ever</em> point to destroyed objects.</p>

<p>To get around this, you can use new to allocate space for your object on the heap.  Then it won't be destroyed until you delete it.  However, this takes a little care to get right as you have to make sure that your object isn't destroyed too early (leaving another 'dangling pointer' problem like the one you have now) or too late (creating a memory leak).</p>

<p>To get around <em>that</em>, the common approach in C++ is to use what's called (with varying degrees of accuracy) a <em>smart</em> pointer.  If you're new to C++ you probably shouldn't worry about these yet, but if you're feeling ambitious (or frustrated with memory corruption bugs), check out <a href=""http://www.boost.org/doc/libs/1_40_0/libs/smart_ptr/shared_ptr.htm"" rel=""nofollow noreferrer"">shared_ptr</a> from the Boost library.</p>
",1
1616536,1616525,5,"<p>It depends on how you allocate the object.  If you allocate the object as an auto variable, (i.e. on the stack), then any pointer to that object will become invalid once the object goes out of scope, and so dereferencing the pointer will lead to undefined behavior.</p>

<p>For example:</p>

<pre><code>Object* pointer;

{
  Object myobject;
  pointer = &amp;myobject;
}

pointer-&gt;doSomething(); // &lt;--- INVALID! myobject is now out of scope
</code></pre>

<p>If, however, you allocate the object on the Heap, using the <code>new</code> operator, then the object will remain valid even after you exit the local scope.  However, remember that there is no automatic garbage collection in C++, and so you must remember to <code>delete</code> the object or you will have a memory leak.</p>
",0
1616539,1616525,0,"<p>If you have a local variable, such as an int counter, then it will be out of scope when you exit the function, but, unless you have a C++ with a garbage collector, then your pointer will be in scope, as you have some global vector that points to your object, as long as you did a <code>new</code> for the pointer.</p>

<p>I haven't seen a situation where I have done <code>new</code> and my memory was freed without me doing anything.</p>
",0
1616541,1616525,0,"<p>To check (in no particular order):</p>

<ul>
<li><p>Did you hit an exception during construction of member objects whose pointers you store?</p></li>
<li><p>Do you have a null-pointer in the container that you dereference?</p></li>
<li><p>Are you using the <code>vector</code> object after it goes out of scope? (Looks unlikely, but I still have to ask.)</p></li>
<li><p>Are you cleaning up properly?</p></li>
</ul>

<p>Here's a sample to help you along:</p>

<pre><code>void SomeClass::Erase(std::vector&lt;YourType*&gt; &amp;a)
{
   for( size_t i = 0; i &lt; a.size(); i++ ) delete a[i];
   a.clear();
}
</code></pre>
",0
1616618,1616525,1,"<p>So if I understand correctly you have described the following scenario:</p>

<pre><code>class MyClass
{
public:
  int a;
  SomeOtherClass b;
};

void Test()
{
   std::vector&lt;MyClass*&gt; b;
   for (int i=0; i &lt; 10; ++i)
   {
      MyClass b;
      v.push_back(&amp;b);
   }
   // now v holds 10 items pointers to strange and scary places. 
} 
</code></pre>

<p>This is definitely bad. 
There are two primary alternatives: </p>

<ol>
<li>allocate the objects on the heap using new.</li>
<li>make the vector hold instances of MyClass (i.e. <code>std::vector&lt;MyClass&gt;</code>)</li>
</ol>

<p>I generally prefer the second option when possible. This is because I don't have to worry about manually deallocating memory, the vector does it for me. It is also often more efficient. The only problem, is that I would have to be sure to create a copy constructor for MyClass. That means a constructor of the form <code>MyClass(const MyClass&amp; other) { ... }</code>.</p>
",1
1890604,1890555,5,"<p>Obfuscation doesn't <em>prevent</em>, merely discourage. A sufficiently skilled and determined attacker will always be able to circumvent whatever obfuscation you use, so what you need to know first is: What kind of people are you trying to thwart here?</p>
",1
1890912,1890555,3,"<p>The <a href=""http://shop.oreilly.com/product/9780596003944.do"" rel=""nofollow noreferrer"">Secure Programming Cookbook</a> (O'Reilly) has a whole chapter on Anti-Tampering (the actual book has the chapter, not sure what's available on the website).  Neat stuff.</p>
",0
1890702,1890555,6,"<p>One approach would be to put the code that does the license check into a separate DLL.  In the main application, load the DLL at runtime and calculate the checksum of the DLL itself.  The app stores the checksum that was calculated with the DLL was built.  If the checksums don't match, you have several options, show a wrong-version message - a bit obvious; Do not call the license check - less obvious but will be noticed when the attacker wonders why the license check doesn't get called; call a function with a similar name to the real license-check function.</p>

<p>Think of it as using <strong>Public Key Encryption</strong>.  Use a public key as part of the config and have a private key built into the app.  If they mess with the public key, the digital signature of the app will be compromised in a detectable way. </p>

<p>I agree with @camccann that it would help to understand the kind of attack you expect.  As a last resort, split the license-check into as many parts as is feasible to make it harder to bypass by changing a single branch point.  </p>

<p>[EDIT]</p>

<p>Another thought would be to use a <strong>State Machine</strong>.  See the command structure example in the top answer to <a href=""https://stackoverflow.com/questions/1647631/c-state-machine-design"">this question</a>.  Put the evaluation of the license check into the form of a hash lookup and a set of dummy function calls into an array along with the proper one.  The decision code that evaluates the license check into a table/hash lookup for the appropriate function will not look like your typical  </p>

<pre><code>if(){ pass;} else { fail; } 
</code></pre>

<p>construct.</p>

<p>Two benefits,<br>
  1) there isn't a boolean condition to bypass and<br>
  2) they can't do a simple JMP instruction without knowing the address/name of the function to pass control to.</p>

<p><a href=""https://stackoverflow.com/questions/1371460/state-machines-tutorials"">SO thread on a state machine turorial</a>.<br>
<a href=""https://stackoverflow.com/questions/133214/is-there-a-typical-state-machine-implementation-pattern"">SO thread on state machine implementations</a></p>
",3
1891137,1890555,3,"<p>You could cause a crash by sprinkling the check all over like:</p>

<pre><code>T* data = (T*) new char[sizeof(T) * (check() ? 1 : 0)]
array[i + 1 * (check() ? 0 : 42)].doStuff();
</code></pre>

<p>There's a nice article at Gamasutra about <a href=""https://www.gamasutra.com/view/feature/131439/keeping_the_pirates_at_bay.php"" rel=""nofollow noreferrer"">crack protection in Spyro</a> that does similar things, then goes further by making the game not crash, just work worse and worse. (You never hit enemies, you walk slower, certain critical objects disappear randomly etc etc.)</p>

<p>Fun read for all programmers, and perhaps useful to you.</p>
",0
1694669,1694665,18,"<p>The question isn't ""will the data be used throughout the program"", but rather ""if you make two objects of this class, do you want them to share this data?""  If yes, make it static.  If no, don't.</p>
",1
1694679,1694665,6,"<p>I would argue that in most cases, you should never use a local static variable, and instead use a static member variable. Then the question degenerates to if that variable should be shared among the class instances or not.</p>
",0
1694946,1694665,3,"<p>Declaring a local variable as static means your method now has state, separate from the object's state. It can lead to many mistakes when maintaining this code (such as copy constructor implementation, assignment, serialization) and when reading it (unclear method behavior).<br>
Avoid using static locals unless you have some good reason (the only one I can think of is single threaded singletone implementation).</p>
",0
1704903,1704892,9,"<p>Anyone who honestly thinks that you can arbitrarily define how many member variables a class should have has not written a lot of code or are extremely arrogant. I know it just a guideline, but honestly, if the class is well defined, conforms to the general OOP guidelines of single responsibility, and is easy to maintain, you should just spend your time solving real problems.</p>

<p>BTW, I realize that this is not an actual answer, so let the downvoting begin.  I just had to vent :)</p>

<p>EDIT:  Just did a little searching and found that this 'guideline' comes from the fact that humans have trouble remembering sequences of information with more than five or six discrete data points.  Well, that's nice, and it is something to remember (especially when designing user interfaces), but in practice you cannot design your code this way.  Do what makes sense and makes your life easier (maintenance considerations being part of that decision).</p>
",9
1704999,1704892,0,"<p>Aside from the fact that the number of variables shouldn't arbitrarily be set at a maximum number, I would argue that what is important is considering groups.</p>

<p>As such, I would consider static variables and non-static variables two separate groups (this is visually rendered in your code example as they are separated by a blank line). If they were all grouped together, then I'd think they count as one group.</p>

<p>I don't know however that this analysis has any value whatsoever, as I agree with Ed completely.</p>
",2
1705026,1704892,0,"<p>By the way, if you want a convenient means of grouping variables together in the IDE without having to actually put them into classes, MSVC supports the <a href=""http://msdn.microsoft.com/en-us/library/b6xkz944(VS.80).aspx"" rel=""nofollow noreferrer"">#pragma region</a> directive. That just lumps some lines of code together into regions that can be collapsed or expanded by clicking the little ""+"" icon to the left &mdash; it has no effect on the compiled result, it's just markup for the code editor.</p>
",0
1705033,1704892,0,"<p>I'm pretty sure constants shouldn't be counted. Most classes won't have many (any?), anyway. If your class does have a large number of constants, you probably ought to move them out into their own class, but one or two here and there aren't going to make any difference.</p>

<p>I know everybody is jumping in on the ""this is crazy"" side of this argument, so I'll just mention that I think it's not a totally unreasonable rule-of-thumb. In that respect, it's like the ""no function longer than a single screen-full in the editor"". Violating the rule just means you ought to take a careful look at the code and make sure it's not getting more-complex than necessary. </p>
",0
1705529,1705247,0,"<p>Use it as a constant inside the function:</p>

<pre><code>const int x = myMagicNumber; //Now document the magic.
</code></pre>
",0
1705259,1705247,5,"<p>Just move it up:</p>

<pre><code>void do_something(void)
{
    const float InitialVelocity = 5.0f;

    something = InitialVelocity;
    // etc.
}
</code></pre>
",3
1705260,1705247,3,"<blockquote>
  <p>Say you have a short member function
  that uses an object's velocity</p>
</blockquote>

<p>You said it, the constant has a name:</p>

<pre><code>const type object_velocity = ....;
</code></pre>

<p>Magic numbers are my enemies :)</p>
",0
1705264,1705247,1,"<p>I'd use a function-local named constant, at a minimum.  Usually I'd use an anonymous namespace named constant to make the value available throughout the source file, assuming that it might be useful later to other functions.</p>
",0
1705271,1705247,0,"<p>Use Eclipses refactoring functions to move the constant into a named variable of the method.  </p>
",0
1684845,1684815,4,"<p>At the file level, you can only define types (you've only written an assignment expression). So you need to change that to:</p>

<pre><code>SDL_Surface* foo::bar = 0;
</code></pre>
",2
1684858,1684815,0,"<p>It doesn't know what type SDL_Surface is. You need to define it or at least forward declare it.</p>
",1
1794462,1794271,4,"<p><code>T a[]</code> means you expect an array of <code>T</code> as the parameter type - but thats a C array, not a class type. Your class template <code>Array</code> is just that - a class template that only happens to provide convenience access to its contents via <code>operator[]()</code>.</p>

<p>To fix the first error change <code>Quicksort()</code>s signature to:</p>

<pre><code>template&lt;class T&gt;
void Quicksort(T&amp; a, int first, int last)
</code></pre>

<p>Then there is the problem that you use <code>T</code> for a local variable <code>pivot</code>. To do that generically with containers, it is more or less standard to provide a <code>typedef</code> named <code>value_type</code> for the contained types (the values) of the container:</p>

<pre><code>template&lt;class T&gt;
class Array 
{
public:
    typedef T value_type;
    // ...
};
</code></pre>

<p>With that convention you can declare <code>pivot</code> as follows:</p>

<pre><code>T::value_type pivot;
</code></pre>
",1
35524,35522,2,"<p>You will have to tell us the type of data you are given.</p>

<p>As per your last question: remember that an average can be calculated in real time by either storing the sum and the number of data points (two numbers), or the current average and the number of data points (again, two numbers).</p>

<p>For instance:</p>

<pre><code>class Averager {
    double avg;
    int n;
public:
    Averager() : avg(0), n(0) {}
    void addPoint(double v) {
        avg = (n * avg + v) / (n + 1);
        n++;
    }
    double average() const { return avg; }
};
</code></pre>
",0
36246,36114,2,"<p>Is num1 the variable you're having trouble with? This line:</p>

<pre><code>cin &gt;&gt; num1;
</code></pre>

<p>is setting num1 to the value input by the user. So the value calculated for it in the previous run through the loop is being overwritten each time by the new input.</p>
",0
36133,36114,1,"<p>I'm not sure I understand your question. In C any data that's not overwritten is carried over into the next iteration of the loop, and imagine that C++ works much the same way.</p>
",0
36155,36114,2,"<p>I'm not clear exactly what you're asking, but variables will maintain their value for each iteration of a loop, as long as they're declared outside of the loop itself. For example:</p>

<pre><code>int a = 0;

while(a &lt; 10)
{
    int b = 0;

    cout &lt;&lt; ""a: "" &lt;&lt; a &lt;&lt; "" b: "" &lt;&lt; b &lt;&lt; ""\n"";

    a++;
    b++;
}
</code></pre>

<p>In the above, the value output for b will always be 0, as it's declared inside the loop and is being reinitialized each time, whereas a will maintain its value and get incremented each iteration. If b were an object, rather than an int, its constructor and destructor would get called each iteration.</p>
",0
38252,36114,1,"<p>Do you understand how when you say ""num1"" you're referring to the same variable each time, and that each time you change num1 you replace the previous value?</p>
",0
1781817,1781802,3,"<p>That's continuation of reverse order of destructor invokation filosophy of C++. When stack-allocated objects are destroyed it is done in reverse order to facilitate RAII. Although that is not really necessary for array elements (they are all constructed with the default constructors and any order of construction/destruction would do) the same is done with them just for consistency.</p>
",1
1781819,1781802,-1,"<p>Perhaps the order in which the objects that make up the array are placed on the stack. Anyway, except curiosity, I can think of no reason to worry about the destruction order.</p>
",2
1781865,1781802,2,"<p>The information you're referring to in More Effective C++ applies to objects that contain a couple of other object, as in this case:</p>

<pre><code>class Foo {
  private:
     Bar bar_1;
     Bar bar_2;

  public:
     Foo() : bar_1(), bar_2() {}
};
</code></pre>

<p>In the above example, you'll have bar_1 constructed first, followed by bar_2. When an object of class Foo then gets destroyed, <code>bar_2</code> gets destroyed first, then <code>bar_1</code>. That is what Scott Meyers is referring to.</p>

<p>From the point of view of the class, an array of bars would be another object that the compiler needs to destroy, so the order of destruction affects when the array gets destructed in the context of the other objects in the class.</p>

<p>As to which order the elements of an array get destroyed, I wouldn't be too surprised if that is implementation dependent. You'll also have optimisation playing a role here (for example, a POD array can be destroyed just by freeing its memory, as can be an object that is solely composed of PODs). All of the above can affect the order in which the elements of an array will be destroyed.</p>

<p>I'd be interested to see why you do need to know the order in which the array elements are destroyed (apart from technical curiosity, which would be a valid reason IMHO). If it is because there are dependencies between the elements of the array, I think the data structure might need reviewing.</p>
",0
1781878,1781802,1,"<p>Any order would do, really. The two obvious choices are of course in order or in reverse order. However, in this case none of the compiler makers thought it would be worthwhile to leave this implementation-dependent. Hence, the choice was made to mandate the reverse order (as sharptooth stated, extending the usual LIFO behavior)</p>
",0
1782231,1781802,0,"<p>You don't cite which page in Meyer's book you are referring to, but I agree with Timo Geusch that the explanation sounds like it is referring to the that constructors and destructors are invoked according to the inheritance.</p>

<p>For an array of object instances, the order that objects are destroyed is the inverse of the order of construction.  This is easy to verify, as the following code shows. A class variable keeps track of the total number of instances created, and a data member for each object keeps track of its own number.  The constructor and destructor print a message, so when run we can see exactly what happens and when.</p>

<p>The test code prints out the count of objects from 0 to 9 when constructing, then from 9 down to 0 when destructing the instances.  (This was tested with <code>g++-4.2</code> on Mac OS X.)</p>

<pre><code>#include &lt;iostream&gt;

class MyClass
{
public:

    MyClass()
    {
        mCounter = kInstanceCount++;
        std::cout &lt;&lt; ""+++ MyClass() "" &lt;&lt; mCounter &lt;&lt; std::endl;
    }

    ~MyClass()
    {
        std::cout &lt;&lt; ""--- MyClass() "" &lt;&lt; mCounter &lt;&lt; std::endl;
    }

private:
    unsigned            mCounter;
    static unsigned     kInstanceCount;
};

unsigned MyClass::kInstanceCount = 0;

int main()
{
    MyClass arr[10];
    return 0;
}
</code></pre>

<p>You would need to check the C++ Standard, as I'm not 100% sure that this is not an implementation detail (as is often the case), in which case you don't want to rely on this behaviour.</p>

<p>Note also that it is not so common to create a stack-based array of actual object instances.  You are more likely to be using <code>std::vector</code>, or maybe using smart pointers to heap-allocated objects.</p>
",0
1617388,1617375,1,"<pre><code>b.SetData(2) ; // error
</code></pre>

<p>I don't see any problem in calling <code>SetData(2)</code>.</p>

<p>Where as if you call <code>b.SetData() ;</code> then there will be an error. When you define a method with same name in in derived class the base class methods with same name will be hidden in derived class.</p>

<p>You can make them visible in derived class by <code>using</code> keyword.</p>

<pre><code>class A{

 public :
     void SetData(){}   
};

class B : public A {

 public:

     using A::SetData;
     void SetData(int){}   
};



int main() 
{ 
B b;
b.SetData() ; // error
}
</code></pre>
",0
1617407,1617375,4,"<p>OMG, no error message.  -1 for you.</p>

<p>But let us use telepathy and guess your error message.  You're getting something like ""symbol not found"" because you try to call a function <code>B::SetData()</code> which doesn't have a body.  And it must have a body even if it does nothing and even if it's declared in parent class!  Try adding it into the body of your class</p>

<pre><code>class B : public A {
 public:
       void SetData(int)
       {  /* add body here */ };   
};
</code></pre>

<p><strong>or</strong> outside of it</p>

<pre><code>class B : public A {

 public:
       void SetData(int);   
};
void B::SetData(int)
{
  //write it here
}
</code></pre>
",0
1617507,1617375,0,"<p>What i guess you might be facing </p>

<p><strong>error: unresolved external symbol</strong></p>

<p>write code as suggested by Pavel Shved</p>
",0
243396,243242,1,"<p>Is it definitely possible? I honestly don't know, never having played much with pointer-to-member.</p>

<p>Suppose you were using non-POD types (I know you aren't, but the syntax would have to support it). Then pointer-to-member might have to encapsulate more than just an offset from the base pointer. There might be indirection as well, depending how multiple inheritance is implemented. With multiple levels of member indirection, this could get arbitrarily complicated, which is a lot to ask for a type that has to have fixed size.</p>

<p>Perhaps you need a vector of pairs, of types defined by:</p>

<pre><code>typedef Rectangle (StyleInfo::*StyleInfoMember);
typedef int (Rectangle::*RectangleMember);
</code></pre>

<p>Apply each in turn to get where you want to be. Of course this still doesn't let you build a vector of mappings from a StyleInfo to arbitrary members-of-members-of StyleInfo, since they wouldn't all go through Rectangle. For that you may need to open a can of functors...</p>
",1
243418,243242,0,"<p>size (as in <code>&amp;StyleInfo::size::width</code>) is not the name of a type.</p>

<p>try size->width or size.width instead, depending on how your 'AddStyleInfoMembers` knows about size at all.</p>
",0
243829,243242,2,"<p>Remember a pointer to a member is just used like a member.</p>

<pre><code> Obj x;

 int  y = (x.*)ptrMem;
</code></pre>

<p>But like normal members you can not access members of subclasses using the member access mechanism. So what you need to do is access it like you would access a member of the object (in your case via the size member).</p>

<pre><code>#include &lt;vector&gt;
#include &lt;iostream&gt;


struct Rectangle
{
    int width;
    int height;
};

struct StyleInfo
{
    Rectangle size;
};

typedef Rectangle   (StyleInfo::*StyleInfoMember);
typedef int         (Rectangle::*RectangleMember);

typedef std::pair&lt;StyleInfoMember,RectangleMember&gt;  Access;

void AddStyleInfoMembers(std::vector&lt;Access&gt;&amp; members)
{
    members.push_back(std::make_pair(&amp;StyleInfo::size,&amp;Rectangle::width));
    members.push_back(std::make_pair(&amp;StyleInfo::size,&amp;Rectangle::height));
}


int main()
{
    std::vector&lt;Access&gt;     data;
    AddStyleInfoMembers(data);

    StyleInfo       obj;
    obj.size.width  = 10;

    std::cout &lt;&lt; obj.*(data[0].first).*(data[0].second) &lt;&lt; std::endl;
}
</code></pre>

<p>This is not something I would recommend doing!<br></p>

<p>An alternative (that I recommend even less) is to find the byte offset from the beginning of the class and then just add this to the objects address. Obviously this will involve a lot of casting backwards and forwards so this looks even worse then the above.</p>
",0
1693153,1693134,3,"<p>Well, it sees the variable as <em>const qualified</em>, not as <em>a constant expression</em>.</p>
",0
1693160,1693134,16,"<p>The constant is external, so it is defined in another compilation unit (<code>.o</code> file). Therefore the compiler cannot determine the size of your array at compilation time; it is not known until link time what the value of the constant will be.</p>
",0
1693183,1693134,2,"<p>I believe the problem here is that if you declare your variable as extern, it is allowed to be in a different module (.o file) or even in a dynamic library (.dll/.so). This of course means, that the compiler might not be able to resolve the variable content at compile time thus refusing to use the value where a const is required.</p>

<p>My opinion is, that it is perfectly ok not to use extern here and declare it directly in the header file, as it is an int value anyway which will be inlined when used anywhere in the code. I usually use extern const only when working with strings, since I want to make sure that only one instance of the string is generated at runtime.</p>
",0
1693191,1693134,3,"<p>Since it's just an <code>int</code> I would remove the <code>extern</code> and make it a definition rather than a declaration. The reason I say this is that even though this approach places a separate instance of the integer in each source file that includes the header I would imagine that most compilers will optimise out its use. In fact it's impossible for the compiler to optimise out its use if you don't so it won't get optimised out from simple arithmetic expressions.</p>

<p>Since it's declared <code>const</code> it will have internal linkage and so you won't get any multiply-defined symbol problems by doing it this way.</p>
",2
1016516,1016463,2,"<p>You need to define it before you include any headers.<br>
Also note that if you are using precompiled headers,</p>

<pre><code>#define _HAS_ITERATOR_DEBUGGING 0
#include &lt;stdafx.h&gt;
</code></pre>

<p>(where stdafx.h is a precompiled header)</p>

<p>will <em>not</em> work.  The precompiled header must be the first thing in the file.</p>
",0
1016554,1016463,1,"<p>Sorry It was my mistake</p>

<p>I had to write this in preprocessor defnition 
__HAS __ITERATOR __DEBUGGING=0; __SECURE_SCL=0;</p>

<p>not </p>

<p>__HAS __ITERATOR __DEBUGGING 0; __SECURE _SCL 0;</p>
",0
1777860,1777855,3,"<p>Assuming your data structure is a list of (x,y) pairs, a simple printing function could be:</p>

<pre><code>for each row
    for each column in current row
        if the pair (col,row) exists in the list of (x,y) points
            print ""x""
        else
            print ""-""
    print newline
</code></pre>

<p>Since this has at least three nested loops, it's not the world's most efficient algorithm but it will be perfectly fast for any grid that you could reasonably print to the console. Improvements could be gained by pre-sorting the list of generated points and changing the searching algorithm, but you probably won't need to do that for now.</p>
",2
238742,238738,8,"<p>The observer pattern from the GOF is pretty much what you want.</p>

<p>In the book, it has C++ code for this...</p>

<p>Also, as always, Boost has stuff you can make use of as well</p>
",8
238757,238738,20,"<p>Take a look at the boost <a href=""http://www.boost.org/doc/libs/1_36_0/doc/html/signals.html"" rel=""noreferrer"">signal</a> library.  Combined with the <a href=""http://www.boost.org/doc/libs/1_36_0/doc/html/function.html"" rel=""noreferrer"">function</a> and <a href=""http://www.boost.org/doc/libs/1_36_0/libs/bind/bind.html"" rel=""noreferrer"">bind</a> libraries, you can do exactly what you are looking for.</p>
",0
238766,238738,12,"<p>I use <a href=""http://sigslot.sourceforge.net/"" rel=""noreferrer"">sigslot</a> for exactly this purpose.</p>
",2
238963,238738,7,"<p>There is a native Visual C++ <a href=""http://msdn.microsoft.com/en-us/library/6f01ek09.aspx"" rel=""noreferrer"">event system</a>.  It's mostly for COM, but it has native C++ support too.</p>

<p>From <a href=""http://msdn.microsoft.com/en-us/library/ee2k0a7d.aspx"" rel=""noreferrer"">here</a>:</p>

<pre><code>[event_source(native)]
class CSource {
public:
   __event void MyEvent(int nValue);
};

[event_receiver(native)]
class CReceiver {
public:
   void MyHandler1(int nValue) {
      printf_s(""MyHandler1 was called with value %d.\n"", nValue);
   }

   void MyHandler2(int nValue) {
      printf_s(""MyHandler2 was called with value %d.\n"", nValue);
   }

   void hookEvent(CSource* pSource) {
      __hook(&amp;CSource::MyEvent, pSource, &amp;CReceiver::MyHandler1);
      __hook(&amp;CSource::MyEvent, pSource, &amp;CReceiver::MyHandler2);
   }

   void unhookEvent(CSource* pSource) {
      __unhook(&amp;CSource::MyEvent, pSource, &amp;CReceiver::MyHandler1);
      __unhook(&amp;CSource::MyEvent, pSource, &amp;CReceiver::MyHandler2);
   }
};

int main() {
   CSource source;
   CReceiver receiver;

   receiver.hookEvent(&amp;source);
   __raise source.MyEvent(123);
   receiver.unhookEvent(&amp;source);
}
</code></pre>
",0
242488,238738,3,"<p>I use <a href=""http://libsigc.sourceforge.net/"" rel=""nofollow noreferrer"">libsigc++</a>. It's native for gtkmm.</p>

<p>A simple example losely adapted from the <a href=""https://developer.gnome.org/libsigc++-tutorial/stable/"" rel=""nofollow noreferrer"">tutorial</a>:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;sigc++/sigc++.h&gt;

using namespace std;

class AlienDetector {
public:
        void run ();
        sigc::signal&lt;void&gt; signal_detected;
};

void warn_people () {
        cout &lt;&lt; ""There are aliens in the carpark!"" &lt;&lt; endl;
}

void AlienDetector::run () {
        signal_detected.emit ();
}

int main () {
        AlienDetector mydetector;
        mydetector.signal_detected.connect (sigc::ptr_fun (warn_people));
        mydetector.run ();
}
</code></pre>

<p>It also provides a mechanism to connect member-functions of specific objects to signals using sigc::mem_fun instead of sigc::ptr_fun:</p>

<pre><code>sigc::mem_fun (someobject, &amp;SomeClass::some_method);
</code></pre>

<p>This pretty much provides anything that is possible with GLib-signals.</p>
",0
