8769211,8769177,7,"<p>C does not have a concept of modules, as such. It has the concept of ""translation unit"", which is (roughly) the <code>.c</code> file plus the contents of the headers it includes, directly or indirectly. The translation units get compiled independently, and then linked together into an executable program.</p>

<p>A translation unit gives a little bit of namespace management: you can define names of functions and variables as <code>static</code>, so that they're only visible inside the translation unit. This is much less helpful than, say, C++ classes, where name conflicts are easier to avoid.</p>

<p>Look at languages like, say, Python, for even better solutions for that.</p>
",1
11552955,213042,6,"<p>Similar to an earlier answer, this will handle positive and negative integer powers of a double nicely.</p>

<pre><code>double intpow(double a, int b)
{
  double r = 1.0;
  if (b &lt; 0)
  {
    a = 1.0 / a;
    b = -b;
  }
  while (b)
  {
    if (b &amp; 1)
      r *= a;
    a *= a;
    b &gt;&gt;= 1;
  }
  return r;
}
</code></pre>
",0
15550040,15549893,12,"<p>With the caveat in my comment, you could do it using a <a href=""http://en.wikipedia.org/wiki/Variadic_macro"">variadic macro</a>:</p>

<pre><code>#define PRINTF_FL(format, ...) \
    printf(format "" %s %d"", __VA_ARGS__, __FILE__, __LINE__)
</code></pre>
",2
15550065,15549893,4,"<p>to redefine the <code>printf</code> do not use <code>undef</code> just define the following <code>printf</code> macro in your header file</p>

<pre><code>#define printf(MESSAGE,args...) { \
  const char *A[] = {MESSAGE}; \
  printf(""%s %d"",__FILE__,__LINE__); fflush(stdout);\
  if(sizeof(A) &gt; 0) {\
    printf(""::""); \
    printf(*A,##args); \
  } else {\
    printf(""\n""); \
  }\
}
</code></pre>

<p>you can use your new <code>printf</code> macro in your code in this way</p>

<pre><code>printf(); // it will print only the file name and the line number
</code></pre>

<p>or in this way</p>

<pre><code>printf(""debug message any data %d\n"", 5);
</code></pre>
",2
15549985,15549893,8,"<p>Try this:</p>

<pre><code>#define debug(fmt, ...) printf(""%s:%d: "" fmt, __FILE__, __LINE__, __VA_ARGS__);
</code></pre>

<p>I used name <code>debug</code> instead of <code>printf</code>, because I don't think you should override standard functions. You could break something. </p>

<p>Use this like:</p>

<pre><code>debug(""This is debug no %d"", 5);
</code></pre>

<p>To get output similar to:</p>

<pre><code>program.c:12: this is debug no 5
</code></pre>

<p>(file: <code>program.c</code>, line: 12).</p>
",0
15550837,15549893,4,"<p>And here is my ""half penny"".</p>

<h2>Function name &amp; debug messages:</h2>

<pre><code>// debug mode, -DEBUG
#ifdef EBUG
    #define FNAME() fprintf(stderr, ""\n%s (%s, line %d)\n"", __func__, __FILE__, __LINE__)
    #define DBG(...) do{fprintf(stderr, ""%s (%s, line %d): "", __func__, __FILE__, __LINE__); \
                    fprintf(stderr, __VA_ARGS__);           \
                    fprintf(stderr, ""\n"");} while(0)
#else
    #define FNAME()  do{}while(0)
    #define DBG(...) do{}while(0)
#endif //EBUG
</code></pre>

<p>Use macro <code>FNAME()</code> to show just name of function &amp; file/line, <code>DBG(text)</code> to show printf-like debug message with info about function name &amp; file/line.</p>

<h2>And something that may be useful for coloured debug &amp; error/warning messages.</h2>

<h3>In header file:</h3>

<pre><code>extern int globErr;
#define ERR(...) do{globErr=errno; _WARN(__VA_ARGS__); exit(-1);}while(0)
#define WARN(...) do{globErr=errno; _WARN(__VA_ARGS__);}while(0)
#define WARNX(...) do{globErr=0; _WARN(__VA_ARGS__);}while(0)
// functions for color output in tty &amp; no-color in pipes
EXTERN int (*red)(const char *fmt, ...);
EXTERN int (*_WARN)(const char *fmt, ...);
EXTERN int (*green)(const char *fmt, ...);
</code></pre>

<h3>In C file:</h3>

<pre><code>int globErr = 0; // errno for WARN/ERR
// pointers to coloured output printf
int (*red)(const char *fmt, ...);
int (*green)(const char *fmt, ...);
int (*_WARN)(const char *fmt, ...);
/*
 * format red / green messages
 * name: r_pr_, g_pr_
 * @param fmt ... - printf-like format
 * @return number of printed symbols
 */
int r_pr_(const char *fmt, ...){
    va_list ar; int i;
    printf(RED);
    va_start(ar, fmt);
    i = vprintf(fmt, ar);
    va_end(ar);
    printf(OLDCOLOR);
    return i;
}
int g_pr_(const char *fmt, ...){
    va_list ar; int i;
    printf(GREEN);
    va_start(ar, fmt);
    i = vprintf(fmt, ar);
    va_end(ar);
    printf(OLDCOLOR);
    return i;
}
/*
 * print red error/warning messages (if output is a tty)
 * @param fmt ... - printf-like format
 * @return number of printed symbols
 */
int r_WARN(const char *fmt, ...){
    va_list ar; int i = 1;
    fprintf(stderr, RED);
    va_start(ar, fmt);
    if(globErr){
        errno = globErr;
        vwarn(fmt, ar);
        errno = 0;
        globErr = 0;
    }else
        i = vfprintf(stderr, fmt, ar);
    va_end(ar);
    i++;
    fprintf(stderr, OLDCOLOR ""\n"");
    return i;
}

const char stars[] = ""****************************************"";
/*
 * notty variants of coloured printf
 * name: s_WARN, r_pr_notty
 * @param fmt ... - printf-like format
 * @return number of printed symbols
 */
int s_WARN(const char *fmt, ...){
    va_list ar; int i;
    i = fprintf(stderr, ""\n%s\n"", stars);
    va_start(ar, fmt);
    if(globErr){
        errno = globErr;
        vwarn(fmt, ar);
        errno = 0;
        globErr = 0;
    }else
        i = +vfprintf(stderr, fmt, ar);
    va_end(ar);
    i += fprintf(stderr, ""\n%s\n"", stars);
    i += fprintf(stderr, ""\n"");
    return i;
}
int r_pr_notty(const char *fmt, ...){
    va_list ar; int i;
    i = printf(""\n%s\n"", stars);
    va_start(ar, fmt);
    i += vprintf(fmt, ar);
    va_end(ar);
    i += printf(""\n%s\n"", stars);
    return i;
}
</code></pre>

<h3>In main():</h3>

<pre><code>if(isatty(STDOUT_FILENO)){ // make color output in tty
    red = r_pr_; green = g_pr_;
}else{ // no colors in case of pipe
    red = r_pr_notty; green = printf;
}
if(isatty(STDERR_FILENO)) _WARN = r_WARN;
else _WARN = s_WARN;
</code></pre>

<p>After that you will be able to use coloured output in case running in terminal and non-coloured in case of pipe. Functions <code>red</code> and <code>green</code> are analogues of <code>printf</code> for coloured output. Function <code>_WARN</code> used in macros to show user message and string for <code>errno</code>: <code>ERR</code> for case of errors (ends with <code>exit</code>), <code>WARN</code> ¡ª analogue of <code>ERR</code> but without <code>exit</code> and <code>WARNX</code> to show messages without <code>errno</code>.</p>
",0
8739265,8739189,2,"<p>Look up the <code>strchr</code> and <code>strstr</code> functions. They've been made for this.</p>

<p>But CRLF is not one character, that's two characters. To locate that, search for '\n' and check the previous character.</p>
",0
8739269,8739189,4,"<p>CRLF is two characters: CR, and LF. You need to match them both individually, not together as you've done with <code>3338</code> (I think: where did you get that number?) Also, use the character constants: <code>'\0'</code>, <code>'\n'</code>, <code>'\r'</code>, it will make your code clearer.</p>

<pre><code>/*
  0x0a (ASCII newline)
  0x0d (ASCII carriage return)
  CRLF (0x0d0a)
*/

while(*search != '\0') {
    /* Seach for a newline */
    if(*search == '\n') {
        printf(""\nnewline Found\n"");
        search++;
    }

    /* Search for a CR or a CRLF */
    if(*search == '\r') {
        // OK, we found a CR, is it followed by a LF?
        if(*(search + 1) == '\n') {
            // Yes, it is, thus, it is a CRLF
            printf(""\nCRLF Found\n"");
            search += 2; // Note the 2! CRLF is 2 characters!
        }
        else {
            // No, just a lonely CR, forever alone.
            printf(""\nCarriage return found\n"");
            search++;
        }
    }
}
</code></pre>

<p>As another poster suggests, you can also use the <code>strchr</code> and <code>strstr</code> functions, and take the minimum valid result from them. (It'll be like 3 lines of code.)</p>
",3
8739855,8739189,1,"<p>I'd recommend to use <code>strstr()</code> and <strong>not</strong> to use <code>strchr()</code>, as the latter  is not multi-byte character save (per definition).</p>

<p>Also the two methods <code>strspn()</code>, <code>strcspn()</code> could help.</p>
",0
8739316,8739189,1,"<p>You could simply modify your code to:</p>

<pre><code>for(; *search != '\0'; search++) {
    /* Seach for a newline */
    if(*search == '\n') {
        printf(""\nnewline Found\n"");
    }
    /* Search for a CRLF */
    else if(*search == '\r' &amp;&amp; *(search + 1) == '\n') {
        printf(""\nCRLF Found\n"");
        search++; /* search will be incremented twice (bit hacky?) */
    }
}
</code></pre>

<p>Short-circuiting in the <code>if</code> statement will prevent <code>(search + 1)</code> being dereferenced if <code>*search</code> is not <code>'\r'</code>, so that won't cause you to go past the bounds of the string if <code>*search</code> turns out to be <code>'0'</code>.</p>

<p><code>*search == 3338</code> in your previous code example isn't going to work if <code>search</code> is a <code>char*</code>/<code>char[]</code>, since a <em>single</em> <code>char</code> can only represent 256 different values and CRLF is a sequence of 2 bytes (2 <code>char</code>s).</p>
",0
13716408,435834,0,"<p>digital signal processing, all Pure Data extensions are written in C, this can be done in other languages also but has had good success in C</p>
",0
16948097,16947467,4,"<p>Make sure that the file that calls <code>temp = foo(me -&gt; bar);</code> includes either the prototype or the full definition of the <code>uint8_t foo(uint16_t bar);</code> function before it is called, either via an <code>#include</code> directive, or by adding the prototype/definition earlier in the file.</p>

<p>Without an already-seen signature for the function, the compiler will assume the signature to be <code>int foo();</code> and generate code accordingly.</p>

<p>Using <code>gcc -W -Wall</code> to compile should generate warnings when implicit function signature assumptions are made.</p>
",0
12788983,579734,-3,"<p>What I would use is</p>

<pre><code>char *s = ""abcd"";
</code></pre>
",1
20202553,20202493,3,"<p>You can use <code>snprintf</code> and allocated buffer for this:</p>

<pre><code>#include &lt;limits.h&gt;

// ...

char filename[PATH_MAX];
snprintf(filename, sizeof(filename), ""hello-world-%d.txt"", pid);
</code></pre>

<p>About <code>PATH-MAX</code>: <a href=""https://stackoverflow.com/questions/9449241/where-is-path-max-defined-in-linux"">Where is PATH_MAX defined in Linux?</a> and <a href=""http://pubs.opengroup.org/onlinepubs/009695399/basedefs/limits.h.html"" rel=""nofollow noreferrer"">this link</a>.</p>
",3
20202530,20202493,2,"<p>You are looking for <a href=""http://linux.die.net/man/3/snprintf"" rel=""nofollow""><code>snprintf</code></a>, or perhaps more conveniently (but less portably) <a href=""http://linux.die.net/man/3/asprintf"" rel=""nofollow""><code>asprintf</code></a>.</p>
",0
11881521,11881464,3,"<p>You need: <code>while((dx_channels &lt; CHANNELS_PER_BOARD) &amp;&amp; (i &lt; number_fx_resources));</code>  </p>

<p>Note: <code>&amp;&amp;</code> instead of <code>||</code></p>
",0
9792193,9792162,29,"<p>The excess elements are just ignored.  There are two parts of <strong>6.7.8 Initialization</strong> that you care about.  First, from paragraph 17:</p>

<blockquote>
  <p>Each brace-enclosed initializer list has an associated current object. When no designations are present, subobjects of the current object are initialized in order according to the type of the current object: array elements in increasing subscript order, structure members in declaration order, and the first named member of a union.</p>
</blockquote>

<p>That one explains why you get 1, 7, and 9 - the current object gets set by those braces. Then as to why it doesn't care about the extras, from paragraph 20:</p>

<blockquote>
  <p>... only enough initializers from the list are taken to account for the elements or members of the subaggregate or the first member of the contained union; any remaining initializers are left to initialize the next element or member of the aggregate of which the current subaggregate or contained union is a part.</p>
</blockquote>
",9
18980579,2543338,-1,"<p>I've so liked all answers here! During trying them I've found something very short and nice with BOOST_PP_STRINGIZE macro from boost:</p>

<pre><code>//Define the enum you need
typedef enum
{
INTEGER = 0,
STRING  = 1,
BOOLEAN = 2,
}eValueType;

// Then in code use BOOST_PP_STRINGIZE, for example:
char* valueTypeStr = BOOST_PP_STRINGIZE(INTEGER);
</code></pre>
",1
8720406,8720292,0,"<p>Here it is, fixed and simplified:</p>

<pre><code>    static void extract_app_name(const char *all_arguments, char **app_name) {
        char *full_path, *app_end, *app_begin; //, *app_name_temp;
        size_t diff;

        if (all_arguments == NULL || app_name == NULL) {
            return;
        }

        full_path = (char*)all_arguments + sizeof(int);

        app_end = strcasestr(full_path, "".app"");
        if (app_end == NULL) {
            app_begin = strrchr(full_path, '/');
            if (app_begin != NULL)
                *app_name = strdup(app_begin+1);
            else
                *app_name = strdup(full_path);
        } else {
            app_begin = app_end;
            while (*(--app_begin) != '/') {}
            diff = app_end - app_begin;
            *app_name = malloc(diff);         
            strncpy(*app_name, app_begin+1, diff-1);
        }
    }
</code></pre>

<p>Note that your code has a memory leak. The caller to <code>extract_app_name</code> should free the string when it's done with it.</p>
",1
10025436,1476847,1,"<p>Because you declared x as 'static' that makes it a global variable.  Its just known only to the main() function in which it is declared.  By declaring YY outside of any function, you have made it global.  'static' also makes it a global, but known only to this file.</p>

<p>If you declared YY as just 'const int YY = 1024',  the compiler might treat it like a #define, but with a type. That depends on the compiler.</p>

<p>At this point 2 things might be wrong.</p>

<p>1: </p>

<p>All globals are initialized at runtime, before main() is called.</p>

<p>Since both x and YY are globals, they are both initialized then.</p>

<p>So, the runtime initialization of global x will have to allocate space according to the value in YY.  If the compiler is not treating YY like #define with a type, it has to make a compile-time judgement about runtime values. It may be assuming the largest possible value for an int, which really would be too big. (Or possibly negative since you left it signed.)</p>

<p>It may be interesting to see what happens if you only change YY to a short, preferably an unsigned short. Then its max would be 64K.</p>

<p>2:</p>

<p>The size of global space may be limited on your system.  You didn't specify the target platform and OS, but some have only so much.</p>

<p>Since you declared x as size YY, you have set it to take YY chars from global space. Every char in it would essentially be a global. If the global space on your system is limited, then 1024 chars of it may be too much.</p>

<p>If you declared x as a pointer to char, then it would take sizeof(char*) bytes. (4 bytes is the size of a pointer on most systems.)  With this, you would need to set the pointer to the address of properly malloc'd space.</p>

<p>By declaring x without 'static', it becomes a local variable and is only initialized once the owning function is executed. And its space is taken from the stack, not global space. (This can still be a problem for systems or threads with very limited stack.)  YY's value has long since been set by this point, so there is no problem.</p>

<p>Also:</p>

<p>I don't recall if there is any guarantee that globals are initialized in any order.  If not, then x could be initialized before YY.  If that happened then YY would just contain the random contents of RAM.</p>
",0
13410622,13365914,0,"<p>This is nothing new, not just your program many popular commercial softwares face this problem. </p>

<p>To start with check this <a href=""http://www.mathworks.in/support/solutions/en/data/1-A03NII/index.html?solution=1-A03NII"" rel=""nofollow"">MATLAB Article about slow fist time execution</a></p>

<p>In case of other programming language which runs on a Virtual Machine like C# or Java this is quite common. 
<a href=""http://en.wikipedia.org/wiki/Just-in-time_compilation#Startup_delay_and_optimizations"" rel=""nofollow"">http://en.wikipedia.org/wiki/Just-in-time_compilation#Startup_delay_and_optimizations</a></p>

<p>Caching is a good reason for that to happen in C but still 10x is quite a long duration..It might be also possible that you system was loading other resources after you restart.</p>

<p>You should run the program after say 10 minutes after restart for better results. All the startup application would be loaded by that time. (10 minutes ---- depends on the number of startup applications and the time it takes to start each of them)</p>
",0
13410470,13365914,3,"<p>You have to make hypothesis and confront them to reality. The first you can reasonably make is that it does smell a lot like a caching issue !</p>

<p>Ask yourself those questions :</p>

<ul>
<li>Does my data fits in free RAM (= is my file cached by the OS FS cache
?)</li>
<li>Does my data fits in CPU data cache ?</li>
<li><p>Does my data fits in HDD internal cache ?</p>

<ol>
<li><p>The most easy hypothesis to discard is the FS cache. Under linux, just issue <code>sync; echo 3 &gt; /proc/sys/vm/drop_caches</code> between each call to your program. The first will make sure the cached data will make it to the physical medium (hard drive), the second will drop the content of the filesystem cache from memory. </p></li>
<li><p>The 'physical medium' might be the HDD cache itself, so beware... Under linux you can disable this ""write-back"" cache with the command <code>hdparm -W 0 &lt;device&gt;</code>, for instance if you are working with drive <code>sda</code>, <code>hdparm -W 0 /dev/sda</code> will do the job. You might want to re-enable it after you are finished with your tests :)</p></li>
<li><p>Another hypothesis is the CPU cache, have a look at <a href=""https://stackoverflow.com/questions/1756825/cpu-cache-flush"">How can I do a CPU cache flush in x86 Windows?</a> and <a href=""https://stackoverflow.com/questions/3446138/how-to-clear-cpu-l1-and-l2-cache"">How to clear CPU L1 and L2 cache</a></p></li>
</ol></li>
</ul>

<p>Well, it may or may not be one of those, but it doesn't hurt trying :)</p>
",0
13471459,13365914,1,"<p><em>If</em> your program does network access then that could be the reason for the initial delay. Many network protocols need time to setup things. Some examples:</p>

<ul>
<li>DNS: if your program does <em>any</em> network access, chances are it needs to resolve a hostname to an IP address. The first time it would need at least a network round trip to populate a local cache. Following requests would be shorter.</li>
<li>Networked filesystems (NFS, CIFS and others): opening files can happen through the network.</li>
<li>Even some seemingly innocuous library functions can require network access: the users list for the host can be on a remote directory server.</li>
</ul>

<p>Appart from this you could use some low level tracing tool to see where the time is spent. On linux a basic tool is <code>strace -r</code>. There is probably some similar tool for other systems. Your compiler must also come with a profiler (i.e. <code>gprof</code> for GCC or maybe Valgrind).</p>
",0
13475128,13365914,0,"<p>This is because of compiler optimatization ,what it does is it caches the result for <code>Temoparal Locality</code> and the activation record is saved,time is also saved because the binding object donot have to be reloaded again during Linking Stage </p>
",0
11163723,11163684,0,"<p>Using the <strong>!</strong> operator will negate your expression:</p>

<pre><code>while(!((*i2s) &amp; (1&lt;&lt;19)))
    usleep(10);
</code></pre>
",0
11163727,11163684,3,"<pre><code>while(((*i2s) &amp; (1&lt;&lt;19)) == 0)
    usleep(10);
</code></pre>

<p>of course.</p>
",0
11163733,11163684,0,"<p>To do the opposite of something, use !</p>

<pre><code>while(!((*i2s) &amp; (1&lt;&lt;19)))
   usleep(10);
</code></pre>
",0
11163741,11163684,1,"<p><code>!</code> not operator reverses a condition:</p>

<pre><code>while(!((*i2s) &amp; (1 &lt;&lt; 19))) {
    usleep(10);
}
</code></pre>
",2
8785189,2046260,1,"<p>you need to find out first the day on 1st of january <br/>
and then print the dates.<br/>
GO to <a href=""https://sourceforge.net/projects/c-cpp-calender/"" rel=""nofollow"">https://sourceforge.net/projects/c-cpp-calender/</a> <br/></p>

<p>go through the code and you will understand it </p>
",0
17831344,6970802,2,"<p>If a and b are known to be non negative integers, the sequence (int) ((unsigned) a + (unsigned) b) will return indeed a negative number on overflow.</p>

<p>Lets assume a 4 bit (max positive integer is 7 and max unsigned integer is 15) system with the following values:</p>

<pre><code>a = 6

b = 4

a + b = 10 (overflow if performed with integers)
</code></pre>

<p>While if we do the addition using the unsigned conversion, we will have:</p>

<pre><code>int((unsigned)a + (unsigned)b) = (int) ((unsigned)(10)) = -6
</code></pre>

<p>To understand why, we can quickly check the binary addition:</p>

<pre><code>a = 0110 ; b = 0100 - first bit is the sign bit for signed int.

0110 +
0100
------
1010
</code></pre>

<p><code>For unsigned int, 1010 = 10</code>. While the same representation <code>in signed int means -6</code>.</p>

<p>So the <code>result</code> of the operation is indeed <code>&lt; 0</code>.</p>
",0
13428612,1677850,0,"<p>It's a fundamental memory manipulation error! </p>

<p>Never do so!</p>

<p>You allocate memory at pointer p and after that you just rewrite pointer at <code>p=q</code>. </p>

<p>Previous value of pointer you lost, <strong>p</strong> is a lost pointer!</p>

<p>You can never free the memory allocated above for pointer <strong>p</strong>! It's a lost memory block for <strong>p</strong>.</p>

<p>It's memory leak... Try to free it at line <code>free(p)</code> in real free memory allocated for pointer <strong>q</strong>, but  not for <strong>p</strong>!. </p>

<p>Next line <code>free(q)</code> is another try to free the same memory that was freed in previous line. That will be unpredictable behavior depending on the system it may be nothing special, and may be an error at program finish. </p>

<p>You must replace line <code>free(p)</code> before line <code>p=q</code>. </p>

<p><strong>And always before rewrite pointer with previously allocated memory free them! Consider it a strict rule!</strong>    </p>
",0
10751066,10751027,12,"<p>Because you are trying to get the size of a <em>pointer</em> to <code>struct token</code>. The size of a pointer doesn't depend on how the structure is actually defined.</p>

<p>Generally, you can even declare a variable of type <code>struct token*</code>, but you can't dereference it (e. g. access a member through the pointer).</p>
",2
10751108,10751027,9,"<p>To paraphrase the C standard, an incomplete type is a type that describes an
object but lacks information needed to determine its size. </p>

<p>void is another incomplete type. Unlike other incomplete types, void cannot
be completed.</p>

<p>This ""incomplete type"" is often used for kinds of handle: a library allows you to allocate a ""handle"" to something, work with it and dispose it again. All this happens encapsulated in the library. You as user have no idea what might happen inside.</p>

<p>Example:</p>

<p>lib.h:</p>

<pre><code>struct data * d_generate(void);
void d_set(struct data *, int);
int d_get(struct data *);
void d_free(struct data*);
</code></pre>

<p>lib.c:</p>

<pre><code>#include ""lib.h""
#include &lt;stdlib.h&gt;
struct data { int value; };
struct data * d_generate(void) {
    return malloc(sizeof(struct data))
}
void d_set(struct data * d, int v) {
    d -&gt; value = v;
}
int d_get(struct data * d) {
    return d-&gt;value;
}
void d_free(struct data* d) {
   free(d);
}
</code></pre>

<p>user.c:</p>

<pre><code>#include ""lib.h""
[...]
struct data * d = d_generate();
d_set(d, 42);
int v = d_get(d);
// but v = d-&gt;value; doesn't work here because of the incomplete definition.
d_free(d);
</code></pre>
",1
17803687,1345735,0,"<p>i think the problem is with reading the file,bcoz u r opening the file in binary(bit) orientation and reading in byte orientation.
so i think the problem is with the ""fgetc""
instead try with ""fread""</p>
",1
9151640,9151624,2,"<ol>
<li>There could very well be padding between the fields. On any modern system there will be. Try passing <code>strcat</code> a longer string.</li>
<li><code>return a[0]</code> is clearly a typo. It should read <code>return d.a[0]</code>.</li>
</ol>
",3
9151648,9151624,1,"<ol>
<li><p>Yes, there probably will be padding between <code>s</code> and <code>a</code> to align <code>a</code> with <code>int</code> alignment.</p></li>
<li><p>You need to change it to <code>return d.a[0];</code>, there is no variable named just <code>a</code>.</p></li>
</ol>

<p>Also realise that the bytes of <code>d.s</code> are not guaranteed to be initialised to <code>0</code> when you create it, and using it is undefined behaviour. So <code>strcat</code> could search for a NUL terminator and not find one and go into memory you don't own and cause a segfault. You should make <code>d.s</code> a C-string first before using <code>strcat</code>,</p>

<p>like this:</p>

<pre><code>struct x d;
d.s[0] = 0;
</code></pre>
",0
10783708,5145881,0,"<p>First,<code>it IS in the code the I wrote, so it never will be take off, right?</code> my answer is yes. I recommend you to have a look at the structure of ELF or runtime structure of executable. The position that the string literal stored is implementation dependent, in gcc, string literal is store in the <code>.rdata</code> segment. As the name implies, the <code>.rdata</code> is read-only. In your code </p>

<pre><code>   char *p
   p = string;
</code></pre>

<p>the pointer p now point to an address in a readonly segment, so even after the end of function call, that address is still valid. But if you try to return a pointer point to a local variable then it is dangerous and may cause hard-to-find bugs:</p>

<pre><code>int *func () {
    int localVal = 100;
    int *ptr = localVal;
    return p;
}
int val = func ();
printf (""%d\n"", val);
</code></pre>

<p>after the execution of <code>func</code>, as the stack space of <code>func</code> is retrieve by the c runtime, the memory address where <code>localVal</code> was stored will no longer guarantee to hold the original <code>localVal</code> value. It can be overidden by operation following the <code>func</code>.</p>

<p>Back to your question title</p>

<p>-</p>

<ol>
<li><code>string literal</code> have <code>static duration</code>.</li>
<li>As for ""And about constants like 1, 2.10, 'a'?""
my answer is NO, your can't get address of a integer literal using <code>&amp;1</code>. You may be confused by the name 'integer constant', but <code>1,2.10,'a'</code> is not right value ! They do not identify a memory place,thus, they don't have duration, a variable contain their value can have duration</li>
<li>compound literals, well, I am not sure about this.</li>
</ol>
",0
11558972,11558902,2,"<p>Most likely you are including the header file in more than one source file. The <code>#include</code> directive literally includes the contents of the header file into the source file, which means that all code in the header file will also be in the source file. This means that if two or more source file includes the same header file then the code in the header file will be duplicated.</p>
",1
11559032,11558902,2,"<p>The <code>= {0}</code> turns the line from a <em>declaration</em> into a <em>definition</em>.  You can have as many (compatible) declarations of a file-scope variable as you like, but at most one definition; by including the header in multiple source files you are causing multiple definitions to be generated.</p>
",0
11559117,11558902,1,"<p>You can prevent problems from multiple includes by wrapping the contents of your header files in #ifndef like this</p>

<pre><code>/* file1.h */
#ifndef INCLUDE_FILE1
#define INCLUDE_FILE1

/* contents here */

#endif
</code></pre>
",1
10117516,10117502,2,"<p>It's done so that you can use it inside a macro, while requiring the macro user to use a semicolon at the end, just like a regular statement.</p>

<p>In other words, whenever you want <em>multiple</em> statements inside a function-like macro <code>FOO(...)</code>, you wrap it with <code>do { ... } while (0)</code> so that the user of the macro can (and, in fact, <em>must</em>) call it as <code>FOO(x);</code>, instead of simply <code>FOO(x)</code> (whose lack of semicolon can be weird for both humans and computers).</p>
",2
10117540,10117502,0,"<p>You see such code mostly in Macros and they behave as if they were function
  #define Whatever do ..... while(0)</p>

<p>and you use it like
Whatever();</p>

<p>Ups I see this question  was answered here before
<a href=""https://stackoverflow.com/questions/257418/do-while-0-what-is-it-good-for"">do { ... } while (0) ¡ª what is it good for?</a></p>

<p>Corrected the link, thanks Rune.</p>
",1
13717387,13717359,1,"<pre><code>value |= *bufp++ &lt;&lt; shift;
</code></pre>

<p>is equivalent to</p>

<pre><code>value = value | (*bufp &lt;&lt; shift);
bufp++;
</code></pre>
",6
13717389,13717359,5,"<p>This is taking successive bytes from the buffer pointed to by <code>bufp</code>, and putting them into <code>value</code>.</p>

<p>The <code>value |= *bufp++ &lt;&lt; shift;</code> is taking the value at <code>bufp</code> (i.e., the <code>char</code> at the address <code>bufp</code> is pointing at) and ORing it with 8 bits of <code>value</code>. Then it's incrementing <code>bufp</code> to point go the next byte in the buffer. After that, it adds 8 to <code>shift</code> -- that's what determined <em>which</em> 8 bits of <code>value</code> the new bytes gets ORed. I.e., <code>shift</code> starts as 0, so in the first iteration, the first byte of <code>bufp</code> replaces the bottom 8 bits of <code>value</code> (replaces, because they're starting out as 0). In the next iterator, the next byte of <code>bufp</code> gets shifted left 8 bytes, to replace the next 8 bits of <code>value</code>, and so on for <code>len</code> bytes.</p>

<p>Aside: if <code>len</code> is greater than <code>sizeof(unsigned)</code>, this is going to write past the end of <code>value</code>, causing undefined behavior.</p>
",1
13717395,13717359,1,"<pre><code>value |= *bufp++ &lt;&lt; shift;
</code></pre>

<p>is equivalent to </p>

<pre><code>value =  value | (*bufp &lt;&lt; shift);
bufp++;
</code></pre>

<p>first value at bufp is shifted to the value in shift and the resultant is ORed <code>|</code> with <code>value</code> and then <code>bufp</code> is incremented.</p>

<p>At last value of shift is changed by <code>shift +=8</code> means <code>shift = shift + 8</code></p>

<p>So it takes all the bytes in the <code>bufp</code> because while loop won't terminate until <code>len</code> becomes <code>0</code>. </p>
",0
19218398,19218336,5,"<blockquote>
  <p>I know that linux kernel source is in pure c.</p>
</blockquote>

<p>It is most certainly not. The Linux kernal is infamous for the frequent use of non-standard extensions from the GCC compiler.</p>

<blockquote>
  <p>So I want to know how can I write simple Hello, World program in pure C without using printf api?</p>
</blockquote>

<p><code>printf</code> is just a wrapper around the OS API functions. Do you mean to ask how to write printf using only Linux API functions? Becase ""pure C"" is defined in the C standard ISO 9899, which has nothing to do with the Linux OS.</p>
",3
20409590,20405695,0,"<p>Diab's syntax analyzer don't parse ""..."" very well. I ran into this about a year ago and the only solution I found was using memset.</p>

<p>The way I did it was to memset everything to 0. I then defined a macro:</p>

<pre><code>#define USE_MEM(x) ~x;
</code></pre>

<p>I was dealing with bit manipulation so this works fine. I would not do this in bootcode though as inverse have big impact. In case of that, it's probably less expensive to figure out where the data is first used and apply initial value manually, e.g. add mem = 0xffffffff right before the value first being used.</p>

<p>I was using diab 5.2.1.0</p>
",0
13457694,13457616,9,"<p>You need a format in the line</p>

<pre><code>printf(process_string[i]);
</code></pre>

<p>i.e.</p>

<pre><code>printf(""%c"", process_string[i]);
</code></pre>
",4
13457718,13457616,1,"<p><code>printf()</code> expects, as first parameter, a <em>pointer to char</em>. What you are passing is a <em>char</em>, not a pointer to one.</p>

<p>Anyway, <code>printf()</code> is not the function to use here. Try <code>putc()</code>...</p>
",0
13457755,13457616,4,"<p>There are a couple of problems.</p>

<p>One is that you're not seeing any output from the <code>printf(""String is %s, and its length is %d"", ...)</code>. This is because standard output is line buffered by default, and you are not including a newline, so it never actually decides that there's a line ready to print. If you change the format string to add a <code>\n</code>, you will see the output from this command.</p>

<p>The second is that you are passing a <code>char</code> into the first argument of <code>printf()</code>, where it expects a <code>char *</code>. This causes it to crash, as it tries to interpret that character as a pointer. You want to pass something like <code>printf(process_string)</code> instead. However, it's generally a bad idea to pass a variable string directly into the first argument of <code>printf()</code>; instead, you should pass a format string that includes <code>%s</code>, and pass the string in as the corresponding argument: <code>printf(""%s\n"", process_string)</code>. Or, if you want to print it character by character, <code>printf(""%c"", process_string[i])</code>, followed by a <code>printf(""\n"")</code> to flush the buffer and actually see the output. Or if you're doing it character by character, <code>putchar(process_string[i])</code> will be simpler than <code>printf()</code>.</p>
",0
15802175,15802128,0,"<p>Could also try <code>strtol()</code> for what you want.  See: <a href=""https://stackoverflow.com/questions/3792663/atol-v-s-strtol"">atol() v/s. strtol()</a></p>
",1
15802237,15802128,1,"<p>If you want to use <code>sscanf()</code> for <em>validating digits-only</em> (and I don't recommend you do), your format is off. You must use only char-types for gathering the extracted data:</p>

<p>Try this:</p>

<pre><code>char message[] = ""123456"";
char buffer[128];

if (sscanf(message, ""%127[0-9]"",buffer) == 1)
    printf(""Success : %s\n"", buffer);
</code></pre>

<p>and play around with the range (change it to [2-9], for example) to assist in understanding how set-based extraction works. But again, you can only do them into a char-type buffer.</p>

<p>That said, use <a href=""http://en.cppreference.com/w/c/string/byte/strtol"" rel=""nofollow""><code>strtol()</code></a> or <a href=""http://en.cppreference.com/w/c/string/byte/atoi"" rel=""nofollow""><code>atoi()</code></a> (but only if you must) if you need the value, or if you just want to validate digit content, <code>isdigit()</code> may be a better fit. You decide.</p>
",2
19508684,2184631,0,"<p>The funciton strol you used is okay. But the pramenter is risk. The syntax of strol is </p>

<pre><code>`long int strtol (const char* str, char** endptr, int base);
</code></pre>

<p>with <strong>endptr</strong> is <strong>value that set by the function to the next character in str after the numerical value.</strong> You have to reset endptr pointer to NULL or the begining of str</p>

<pre><code>do 
{        
    printf(""&gt; "");
    scanf(""%s"", s);
    endptr = &amp;s[0];
    int val = strtol(s, &amp;endptr, 10);
}
</code></pre>
",0
8805471,8805452,1,"<p><code>newCar</code> needs to be allocated some memory before you can write to it.   </p>

<pre><code>Car* newCar = malloc(sizeof(Car));
</code></pre>

<p>Right now what you have is just an pointer which points to some random address in the memory and you attempting to write to that address, which results in <strong>Undefined Behavior</strong> and a seg fault.</p>
",0
8805480,8805452,3,"<p>You need to allocate memory for it.</p>

<pre><code>Car* newCar = malloc(sizeof(Car));
Car* oldCar = malloc(sizeof(Car));
...
free(oldCar);
free(newCar);
</code></pre>

<p>If you don't need to use the pointer elsewhere, you could use stack-allocation.</p>

<pre><code>Car newCar;
Car oldCar;
newCar.engineSize = 1500;
memcpy(&amp;newCar, &amp;oldCar, sizeof(newCar));
</code></pre>
",0
8805497,8805452,1,"<p>You haven't allocated any memory, so your <code>newCar</code> and <code>oldCar</code> stack variables have random values and point to some arbitrary memory locations that may not be mapped by the process.</p>
",0
8805502,8805452,1,"<p>As written, the code is using uninitialized pointers.  Both <code>newCar</code> and <code>oldCar</code> are pointers that could have any value, so the assignment and the memcpy result in an attempt to write to whatever address they happen to point to.  In reality, the compiler should warn about the use of an uninitialized variable; make sure you have warnings enabled.  </p>

<p>Another way is to allocate on the stack:</p>

<pre><code>Car newCar;
Car oldCar;
newCar.engineSize = 1500;
memcpy(&amp;newCar, &amp;oldCar, sizeof(Car)); 
</code></pre>

<p>Or malloc the memory:</p>

<pre><code>Car *newCar = malloc( sizeof(Car));
Car *oldCar = malloc( sizeof(Car));
newCar-&gt;engineSize = 1500;
memcpy(newCar, oldCar, sizeof(Car)); 
</code></pre>
",1
8805505,8805452,1,"<p>You need to allocate space for your <code>Car</code> instances. Try</p>

<pre><code>Car *newCar = (Car *)malloc(sizeof(Car);
Car *oldCar = (Car *)malloc(sizeof(Car);;
newCar-&gt;engineSize = 1500;
memcpy(newCar, oldCar, sizeof(Car)); 
</code></pre>
",0
8805536,8805452,3,"<p>A variable definition such as</p>

<pre><code>Car* newCar;
</code></pre>

<p>only gives you a <em>pointer</em> variable. All it can do is hold the address of something called a <code>Car</code>. The memory size of a <code>Car</code> is unknown here, but it can easily be thousands of times larger than what the mere <em>pointer</em> requires.</p>

<p>You need to allocate memory for the actual value before changing it, either through field assignment to e.g. <code>engineSize</code> or by calling <code>memcpy()</code>:</p>

<pre><code>newCar = malloc(sizeof *newCar);
memcpy(newCar, oldCar, sizeof *newCar);
</code></pre>

<p>Note that there's in general no need to use <code>memcpy()</code>, assuming this is a <code>struct</code> they are assignable:</p>

<pre><code>*newCar = *oldCar;
</code></pre>

<p>This reads cleaner, and has less chance of programmer error.</p>

<p>Also, note that the <code>engineSize</code> must be set after the copying is done, otherwise it will be overwritten when you copy:</p>

<pre><code>newCar = malloc(sizeof *newCar);
*newCar = *oldCar;
newCar-&gt;engineSize = 1500;
</code></pre>
",0
11093413,11093363,1,"<pre><code>char *x = ""0101"";
</code></pre>

<p>Does not equal 0xA or decimal 10.  Binary '1010' would, maybe that's what you meant?</p>

<p>Simple way to convert string-represented numbers is strtol, among many other functions like atoi.  strtol at least allows a radix to be supplied.</p>

<p><a href=""http://www.cplusplus.com/reference/clibrary/cstdlib/strtol"" rel=""nofollow"">http://www.cplusplus.com/reference/clibrary/cstdlib/strtol</a></p>

<p>Something like:</p>

<pre><code>unsigned long val = strtol(x, NULL, 2);
</code></pre>
",3
11093424,11093363,2,"<p>Why is the string in x in reversed order?</p>

<pre><code>char x[5] = {'1', '0', '1', '0' };
unsigned int result = 0;
int i = 0;
while(x[i] != 0)
{
    result = result * 2 + x[i]-'0';
}
</code></pre>
",1
11093432,11093363,2,"<p>It seems that the number is stored in reversed direction, which is not natural for human to read, but quite a natural way to represent number as the index refers to the power of 2 that should be applied.</p>

<p>There is no existing library to do the conversion for you, you need to write code to parse it yourself:</p>

<pre><code>int i = 0;
unsigned int result = 0;

while (x[i]) {
    result |= (x[i] == '1') &lt;&lt; i;
    i++;
}
</code></pre>
",4
9200709,9200688,4,"<p>The macro actually should not have the final ;. This is to get normal / more expected and helpful syntax errors around macro if something is wrong.</p>
",0
9200714,9200688,4,"<p>If you don't use the <code>do ...  while (0)</code> form in an <code>if-else</code> statement you will get an error:</p>

<pre><code>if (bla) CALL_FUNCS();
else statement;
</code></pre>

<p>would be preprocessed as:</p>

<pre><code>if (bla)
{
  func1(x);
  func2(x);
  func3(x);
};
else statement;
</code></pre>

<p>The semi-colon before the else statement is invalid.</p>

<p>Note (as pointed out by @arsenm) that you should not put the final <code>;</code> after the <code>do ...  while (0)</code> in the macro definition and you have to and use <code>\</code> after the lines in the definition:</p>

<pre><code>#define CALL_FUNCS(x)  \
do {                   \
  func1(x);            \
  func2(x);            \
  func3(x);            \
} while (0)
</code></pre>
",1
9200720,9200688,0,"<p>This is used to force the user to add a <code>;</code> after the macro invocation.</p>
",0
9200800,9200688,3,"<p>First, it should not have the trailing <code>;</code>. It should be:</p>

<pre><code>#define CALL_FUNCS(x)    do { func1(x); func2(x); func3(x); } while (0)
</code></pre>

<p>Anyway, the reason is as follows. Consider</p>

<pre><code>if(b)
     CALL_FUNCS(x);
else
     something_else(x);
</code></pre>

<p>This would expand to:</p>

<pre><code>if(b)
     { func1(x); func2(x); func3(x); };
else
     something_else(x);
</code></pre>

<p>Now we still have a trailling <code>;</code> and will get this error message:</p>

<pre><code>error: ¡®else¡¯ without a previous ¡®if¡¯
</code></pre>

<p>Note, if you keep the <code>;</code> in the macro, then you will have <em>two</em> trailing <code>;</code>s!</p>

<p>Macro expansion should 'look' like something that expects a semicolon on the end. You're not going to type <code>CALL_FUNCS(x)</code>, you're going to call <code>CALL_FUNCS(x);</code>. You can rely on <code>do.. while(0)</code> to slurp up the semicolon, but <code>{ }</code> will not do so.</p>
",0
15546641,15546531,6,"<p>See the manual pages (learn to Google for ""man WHATEVER"" when WHATEVER is a library function):</p>

<ul>
<li><a href=""http://linux.die.net/man/3/lroundf"" rel=""noreferrer""><code>lroundf()</code></a> - round to nearest integer, away from zero </li>
<li><a href=""http://linux.die.net/man/3/floor"" rel=""noreferrer""><code>floor()</code></a> - largest integral value not greater than argument </li>
<li><a href=""http://www.manpagez.com/man/3/nearbyintf/"" rel=""noreferrer""><code>nearbyintf()</code></a> - round to integral value in floating-point format</li>
</ul>
",2
11097653,11097626,6,"<p>Classic beginner mistake 1A: <code>getchar()</code> returns <code>int</code>, since <code>EOF</code> does not fit in a <code>char</code>.</p>

<p>I also think you have an indexing problem since if you find a tab, you will increase <code>i</code> in the space-insertion loop, then the <code>for</code> loop will increase <code>i</code> again, leaving weirdness in the string. This might lead to buffer overflow and the crash you're seeing.</p>

<p>Note that the space-insertion loop doesn't check <code>i</code> against <code>MAXLINE</code>.</p>
",1
11097782,11097626,2,"<p>The call to <code>printf</code></p>

<pre><code>printf(""%s"");
</code></pre>

<p>is a likely cause of a segfault. It will try to interpret some arbitrary data on the stack as a pointer to a 0-terminated <code>char</code> array.</p>

<p>A certain way to a segfault is the loop in case of a <code>'\t'</code>:</p>

<pre><code>if(c == '\t') {
    while((TABLENGTH - (i % TABLENGTH)) != 0) {
        line[i] = ' ';
        i++;
    }
    i--;
    continue;
}
</code></pre>

<p>Since <code>i &gt;= 0</code> and <code>TABLENGTH &gt; 0</code>, you always have <code>0 &lt;= (i % TABLENGTH) &lt; TABLENGTH</code>, so whenever you encounter a tab, you enter an infinite loop adding spaces to <code>line</code> beyond the allocated space and that will sooner or later cause a segfault when it tries to write spaces outside the process memory or into a read-only part of the memory. An easy, although not very elegant fix is changing the loop to</p>

<pre><code>if (c == '\t') {
    do {
        line[i] = ' ';
        ++i;
    }while(((TABLENGTH - (i % TABLENGTH)) % TABLENGTH) != 0);
    --i;
    continue;
}
</code></pre>

<p>a different fix could be using a separate counter or a <code>switch</code> with a fall-through. </p>
",2
12351325,12351233,5,"<p>I'll quote this from C++; I think it's the same for C:</p>

<p>The literal <code>-1</code> is always a <code>signed int</code>.</p>

<p>The literal <code>0xff</code> is a <code>signed int</code>, but <code>0xffffffff</code> is an <code>unsigned int</code>.</p>

<p>In comparisons of mixed signs, both operands are converted to unsigned, explaining all your results.</p>

<p>Here's the rule about the types of naked integral literals (i.e. without type suffix) from C++11, table 6:</p>

<ul>
<li><p>Decimal literals are of the smallest type among <code>int</code>, <code>long int</code> or <code>long long int</code>, whichever fits.</p></li>
<li><p>Hexadecimal literals are of the smallest type among <code>int</code>, <code>unsigned int</code>, <code>long int</code>, <code>unsigned long int</code>, <code>long long int</code>, <code>unsigned long long int</code>, whichever fits.</p></li>
</ul>

<p>To spell it out again:</p>

<ul>
<li><p>In your first comparison, both sides are converted to <code>unsigned int</code>, giving the value <code>0xFFFFFFFF</code>.</p></li>
<li><p>In the second comparison, both terms are signed integers, and the left term is <code>255</code> and the right term is <code>-1</code>.</p></li>
<li><p>In the third comparison, both terms are converted to <code>unsigned int</code>.</p></li>
</ul>

<hr>

<p>Observe that we never needed to worry about hardware implementations of signedness for this question. The only relevant platform-dependent value is the size of <code>int</code>, which we used when we asserted that <code>0xffffffff</code> does not fit into an <code>int</code> but <em>does</em> fit into an <code>unsigned int</code>.</p>
",0
12351358,12351233,0,"<p><code>0xffffffff</code> is equal to <code>-1</code> since the <code>int</code> type has only four bytes and the <a href=""http://en.wikipedia.org/wiki/Two%27s_complement"" rel=""nofollow"">two-complement</a> of <code>-1</code> is <code>0xffffffff</code> in memory (<code>-1 == (~1) + 1</code>). So the compiler has no way to tell <code>-1</code> and <code>0xffffffff</code> apart - there simply isn't room for that in memory.</p>

<p><code>0x000000ff</code> is equivalent to <code>255</code> which is bigger than <code>-1</code>, so the last two <code>if</code>s won't get executed.</p>

<p>What might be confusing you is this:</p>

<pre><code>char c = 0xff;
if( c == -1 ) {
     printf(""char 0xff is -1"");
}
</code></pre>

<p>In this case, I compare a <code>char</code> with an <code>int</code>, so the compiler will have to expand the 8-bit <code>char</code> type. Since <code>char</code> is signed, the sign (uppermost bit) will be preserved and you'll get <code>-1</code> (int).</p>

<p><a href=""http://codepad.org/hbybmSKP"" rel=""nofollow"">interactive demo on codepad</a></p>

<p>This is an example why you need to be careful when mixing signed/unsigned types and types of different widths.</p>
",1
12351483,12351233,0,"<p>First thing, the results you see have <em>nothing to do with the bit representation of signed integers</em>, although they do have to do with the size.</p>

<p>When converted to unsigned, the value <code>-1</code> is converted to the max value of the destination type. That's why <code>-1 == 0xffffffff</code>. The bit representation of <code>-1</code> doesn't affect anything.</p>

<p><code>0xff &lt; -1</code> is false because both values are signed <code>int</code>: 255 on the left and -1 on the right.</p>

<p>Finally, the reason -1 is converted to unsigned in the first comparison is that <code>0xffffffff</code> is too big for <code>int</code> <em>on your implementation</em> (and for that matter on most implementations). However, it does fit in an <code>unsigned int</code> (again on your implementation, and on most implementations other than those for 16 bit machines). In order to compare an unsigned int against a signed int, C converts the signed int to unsigned. This gives surprising results (including the surprise that -1 is somehow equal to a positive number), which is why most style guides tell you to avoid mixing signed and unsigned types. But it's too late to change the language.</p>
",0
19263826,19263738,2,"<p>function arguments are passed either in registers or on stack, depending on the ABI of your platform. If you don't specify the arguments, some random values (in the registers or on stack) would still be there from the view of the called function....</p>
",1
8731343,8731311,4,"<p>You should print a string with <code>%s</code>; <code>%c</code> will interpret the pointer as a <code>char</code>. (Strictly, I believe the result is undefined behavior.)</p>
",3
8731375,8731311,0,"<p>Use sscanf as scanf is deprecated.  You can also use sscanf for reading in strings as well, not just numbers.  Also, %c is for printing characters.</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;

struct person {
    int i;
    char name[100];
};

int main() {
    struct person p[2];

    clrscr();
    for(int i=0;i&lt;2;i++) {
        printf(""Enter i:\n"");
        sscanf(""%d"", &amp;p[i].i);

        printf(""Enter name:\n"");
        sscanf(""%s"", p[i].name);
    }
    for(int j=0;j&lt;2;j++) {
        printf(""ID: %d, Name: %s\n"", p[j].i,p[j].name);
    }
    getch();
    return 0;
}
</code></pre>
",1
8731386,8731311,3,"<p>Two things:</p>

<ol>
<li>You need to clear the input buffer to keep it from eating the newline.</li>
<li>Secondly, you need to change the format string to <code>%s</code>.</li>
</ol>

<p>Here's the corrected code:</p>

<pre><code>int main() {
    struct person p[2];

    for(int i=0;i&lt;2;i++) {
        printf(""Enter i:\n"");

        scanf(""%d"",&amp;p[i].i);

        //  Flush input buffer
        int ch;
        while ((ch = getchar()) != '\n' &amp;&amp; ch != EOF);


        printf(""Enter name:\n"");
        gets(p[i].name);
    }
    for(int j=0;j&lt;2;j++) {
        printf(""ID: %d, Name: %s\n"", p[j].i,p[j].name);
    }
    getch();
    return 0;
}
</code></pre>

<p><code>%c</code> expects a <code>char</code>, but you're trying to pass in a string. It's undefined behavior to have mismatching types.</p>

<p>Output:</p>

<pre><code>Enter i:
1
Enter name:
asdf
Enter i:
2
Enter name:
zxcv
ID: 1, Name: asdf
ID: 2, Name: zxcv
</code></pre>
",4
8731399,8731311,0,"<p>You should either use <code>%s</code> instead. Expression <code>p[j].name</code> is a <em>pointer</em> to an array of chars, so you can't print it with <code>%c</code>.</p>
",0
8731429,8731311,1,"<p>You probably need to clear the input buffer after typing in a number (you press return after the number, but you don't read that return)</p>

<p>You can read the input stream until you read a <code>\n</code> after calling <code>scanf</code>:</p>

<pre><code>while( ch = getchar() != '\n' &amp;&amp; ch != EOF);
</code></pre>
",0
20416449,20416422,4,"<p>Change <code>#define FILE *fptr</code> to <code>FILE *fptr</code>, like so:</p>

<pre><code>FILE* fptr ;

int main(int argc, char **argv)
{

   fptr = fopen(""TESTFILE.pdf"", ""wb"");
  // do stuffs . . . 
}
</code></pre>

<p><code>FILE</code> is not a user-defined macro, it is a type, like int, char. <code>fptr</code> is declared as a file pointer (FILE*).</p>
",3
10157278,8888419,2,"<p>SEEK_CUR starts from the current position. That is why your first seek works when you are at the beginning of the file. To always seek from the beginning you need to use SEEK_SET instead of SEEK_CUR.</p>

<pre><code>0   SEEK_SET    The beginning of the file
1   SEEK_CUR    The current position
2   SEEK_END    The end of the file
</code></pre>
",0
10763843,10763817,4,"<p>The issue is &quot;sequence points&quot;:</p>
<blockquote>
<p><a href=""http://www.angelikalanger.com/Articles/VSJ/SequencePoints/SequencePoints.html"" rel=""nofollow noreferrer"">http://www.angelikalanger.com/Articles/VSJ/SequencePoints/SequencePoints.html</a></p>
<p><strong>Problematic vs. Safe Expressions</strong></p>
<p>What is it that renders the
assignment x[i]=i++ + 1; a problematic one whereas the assignment
i=2; is harmless, in the sense that its result is well-defined and
predictable?  The crux is that in the expression x[i]=i++ + 1; there
are two accesses to variable i and one of the accesses, namely the
i++,  is a modifying access. Since the order of evaluation between
sequence points is not defined we do not know whether i will be
modified before it will be read or whether it will be read before the
modification. Hence the root of the problem is multiple access to a
variable between sequence points if one the accesses is a
modification.</p>
<p>Here is another example.  What will happen here if  i and j have
values 1 and 2 before the statement is executed?</p>
<pre><code>f(i++, j++, i+j); 
</code></pre>
<p>Which value will be passed to function f as the third argument?
Again, we don't know. It could be any of the following: 3, 4, or 5. It
depends on the order in which the function arguments are evaluated.<br />
The common misconception here is that the arguments would be evaluated
left to right. Or maybe right to left? In fact, there is no order
whatsoever mandated by the language definition.</p>
</blockquote>
",1
10763878,10763817,2,"<p>It's a mistake to think of ""precedence"" as ""done first"".</p>

<p>Consider the following code snippet:</p>

<pre><code>f() + g() + h()
</code></pre>

<p>Which has add operation has higher precedence, the one that sums the results of f() and g(), or the one that sums the results of that and h()?</p>

<p>It's a trick question, because there is no need to invoke ""precedence"" at all.  But there is still an order of operations, because function calls in C introduce ""sequence points"", which is how C allows you to determine ""what happens when"", as it were.</p>

<p>In your particular code, you have a comma operator¡ªwhich is quite different from the comma punctuator in function arguments¡ªin this part:</p>

<pre><code>jo = (rand() % 100), jo != 50
</code></pre>

<p>The comma operator introduces a sequence point (as does the function call to <code>rand</code>), so we know that <code>rand</code> runs and produces a value, then that value <code>% 100</code> is computed and assigned to <code>jo</code>, and finally <code>jo</code> is compared with <code>50</code>.</p>

<p>(There is a sequence point after the evaluation of the controlling expression in the <code>if</code> as well, and one at each statement-ending semicolon.)</p>
",4
10763881,10763817,3,"<p>Precedence does <em>not</em> control the order of execution.  Precedence only controls the grouping - that is, precedence says <em>what</em> the operands are for each operation, not <em>when</em> each operation happens.</p>

<p>In this example, the precedence of <code>%</code> is irrelevant due to the parentheses - these say that the operands of <code>%</code> are <code>rand()</code> and <code>100</code>.</p>

<p>The precedece of <code>,</code> being lower than that of <code>=</code> and <code>!=</code> tells us that the operands of <code>=</code> are <code>jo</code> and <code>(rand()%100)</code>, and that the operands of <code>!=</code> are <code>jo</code> and <code>50</code>.</p>

<p>The operands of <code>,</code> are then <code>jo = (rand() % 100)</code> and <code>jo != 50</code>.</p>

<p>The definition of the <code>,</code> operator says that the first operand is evaluated, then there is a sequence point, and then the second operand is evaluated.  So this case, <code>jo = (rand() % 100)</code> is fully evaluated, which stores the result of <code>rand() % 100</code> into <code>jo</code>; and then <code>jo != 50</code> is evaluated.  The value of the overall expression is the value of <code>jo != 50</code>.</p>
",0
10763884,10763817,3,"<p>Well, sequence points is the right answer. but let's translate from the textbook-ese.</p>

<p>The comma operator has a special property: it makes sure that what's on its left hand side is evaluated first.  So, when you get to the expression</p>

<pre><code> jo =(rand()%100), jo!=50
</code></pre>

<p><em>even though</em> the <code>!=</code> <em>binds</em> more tightly than ',', so that the expressiojn, fully parenthesized is</p>

<pre><code> (jo =(rand()%100)),(jo!=50)
</code></pre>

<p>the first part is <em>evaluated</em> first.</p>

<p>To remember this, you can pronouce or read the comma operator as ""and then"", so</p>

<pre><code> j0=(rand()%100)
</code></pre>

<p>""and then""</p>

<pre><code> jo!=50.
</code></pre>
",0
9792646,1838196,0,"<p>To come up with a solution to your problem, you must understand that in C a ""string"" is an array of characters terminated by '\0'. That should be enough to help you work through a proper solution.</p>
",0
10776316,10776295,6,"<p>You are trying to compare strings by the <code>==</code> operator, which is not doing what you expect it to do.</p>

<p>Instead you need to compare them by calling <code>strcmp()</code> (or better yet, <code>strncmp()</code>)</p>

<pre><code>if(strmcp(getProduct(product1), getProduct(productInput)) == 0){ 
</code></pre>

<p>The reason why comparing strings by <code>==</code> does not work properly is that <code>==</code> compares the pointers (basically, the memory location where the strings are stored), not the strings themselves</p>
",3
9168259,2105683,-1,"<p>My recommendation  to beginners in c programming is ""Let Us C"" by ""Yashwant Kanetkar""</p>
",1
8771113,8771088,27,"<p>You have confused yourself with misleading spacing.</p>

<pre><code>if (a = b || ++a == 2)
</code></pre>

<p>is the same as:</p>

<pre><code>if (a = (b || ((++a) == 2)))
</code></pre>

<p>This actually has undefined behavior. Although there is a sequence point between the evaluation of <code>b</code> and the evaluation of <code>((++a) == 2)</code>, there is no sequence point between the implied assignment to <code>a</code> and the other write to <code>a</code> due to the explicit <code>=</code> assignment.</p>
",3
8771147,8771088,2,"<p>Actually, assignment has the lowest operator precedence so your if statement is equivalent to:</p>

<pre><code>if ( a = ( b || ( ++a == 2 ) ) )
</code></pre>

<p>So you're assigning a to 1 but also incrementing it in the same expression.  I think that leads to undefined behavior, but the end result is that a is 1 in your compiler.</p>
",0
8773475,8771088,0,"<p>If you are using GCC or another compiler with similarly useful warnings, turning warnings on would give you a very large hint as to what's gone wrong here.  With <code>gcc -Wall</code>:</p>

<blockquote>
  <p>warning: suggest parentheses around assignment used as truth value</p>
</blockquote>

<p>To be precise: the compiler is interpreting the code as <code>if (a = (b || ++a == 2))</code>, and the warning is suggesting that you write it as <code>if ((a = (b || ++a == 2)))</code> to emphasize that the code is as intended, not a typo for the more common <code>if (a == (b || ++a == 2))</code>.</p>

<p>So the warning requires a bit of interpretation.  To get your desired effect, coincidentally enough you need to add parentheses around a <em>different</em> assignment used as a truth value, namely <code>(a = b)</code>.  Nonetheless the warning tells you that something is untoward about this particular line of code and that it deserves further scrutiny.</p>
",1
19494990,19494947,7,"<p>It is a way of commenting code out.  The condition will never be met (0 is never true) so the preprocessor will exclude the code from the compile.</p>

<p>It is typically used on bigger blocks of code that might have some embedded multi-line comments <code>/*  */</code> that cannot be commented out by enclosing them in another multi-line comment.</p>
",0
19494998,19494947,10,"<p>It's simply a way to use the preprocessor to comment out (prevent from compiling) a large block of code. It's pretty common.</p>

<p>It's better than using the actual comment syntax since it doesn't nest. If you have:</p>

<pre><code>int foo = 13; /* This won't be needed. */
</code></pre>

<p>you can't comment it out by doing:</p>

<pre><code>/*
int foo = 13; /* This won't be needed. */
*/
</code></pre>

<p>since the comment syntax doesn't nest, the above will not compile. Using the <code>#if 0</code> method goes around that limitation.</p>
",2
19495009,19494947,4,"<p>That is just to disable this code section like Multiline comment. It is better method which avoids nested comments.</p>
",0
19495177,19494947,1,"<p>From <a href=""http://www.cplusplus.com/doc/tutorial/preprocessor/"" rel=""nofollow"">preprocessor definition here</a></p>

<blockquote>
  <p>Preprocessor directives are lines included in the code of our programs that are not program statements but directives for the preprocessor. These lines are always preceded by a hash sign (#). The preprocessor is executed before the actual compilation of code begins, therefore the preprocessor digests all these directives before any code is generated by the statements.</p>
</blockquote>

<p>So, <code>#if 0</code> will be decided as <code>#if (false)</code> (losely saying), that means, do not enter the block and skip. A way of commenting out something.</p>
",0
16469908,2253166,1,"<p>I know: that is not exactly C, but I think that is an interesting answer:</p>

<pre><code>int reverse(int i) {
  int output;
  __asm__(
     ""nextbit:""
        ""rcll $1, %%eax;""
        ""rcrl $1, %%ebx;""
        ""loop nextbit;""
        : ""=b"" (output)
        : ""a"" (i), ""c"" (sizeof(i)*8) );
  return output;
}
</code></pre>

<p>The rcl opcode puts the shifted out bit in the carry flag, then rcr recovers that bit to another register in the reverse order.</p>
",0
13454554,13454158,3,"<p>it depends of your Cx (C89, C90, C99,...)</p>

<p>for function return values, prior to C99 it was explicitly speci?ed that if no function declaration was visible the translator provided one. These implicit declarations defaulted to a return type of int</p>

<p>Justification from <a href=""http://www.coding-guidelines.com/cbook/cbook1_0b.pdf"" rel=""nofollow"">C Standard</a> (6.2.5 page 506)</p>

<blockquote>
  <p>Prior to C90 there were no function prototypes. Developers expected to
  be able to interchange argu-ments that had signed and unsigned
  versions of the same integer type. Having to cast an argument, if the
  parameter type in the function de?nition had a different signedness,
  was seen as counter to C¡¯s easy-going type-checking system and a
  little intrusive. The introduction of prototypes did not completely do
  away with the issue of interchangeability of arguments. The ellipsis
  notation speci?es that nothing is known about the 1590 ellipsis
  supplies no information expected type of arguments. Similarly, for
  function return values, prior to C99 it was explicitly speci?ed that
  if no function declaration was visible the translator provided one.
  These implicit declarations defaulted to a return type of int . If the
  actual function happened to return the type unsigned int , such a
  default declaration might have returned an unexpected result. A lot of
  developers had a casual attitude toward function declarations. The
  rest of us have to live with the consequences of the Committee not
  wanting to break all the source code they wrote. The
  interchangeability of function return values is now a moot point,
  because C99 requires that a function declaration be visible at the
  point of call (a default declaration is no longer provided)</p>
</blockquote>
",0
13454233,13454158,8,"<p><strong>Turn up the warning level in your compiler</strong> and you should get 2 warnings,</p>

<p><code>display</code> not declared, <code>int</code> assumed </p>

<p>and</p>

<p><code>display</code> redeclared</p>

<p><strong>Edit:</strong></p>

<p>Older versions of C (pre C99) aren't really that bothered about return types or argument types. You could say it's part of the K&amp;R legacy. For instance, if you don't explicitly specify the argument types, the compiler won't check them at all. </p>

<p>C++ is stricter, which IMO is a good thing. I always provide declarations and always specify the argument lists when I code in C.</p>
",7
13454260,13454158,5,"<p>It's compiling because C uses a lot of defaults to be backwards compatible. In K&amp;R C, you couldn't specify function prototypes, so the compiler would just assume that you know what you're doing when you call a function.</p>

<p>Later (at least ANSI C, but maybe even in C99), C didn't really have a way to distinguish</p>

<pre><code>void display(void);
void display();
</code></pre>

<p>so the empty declaration must be accepted as well.</p>

<p>That's why you can call <code>display()</code> without defining it first.</p>

<p><code>printf()</code> is similar. You will get a linker error if you forget <code>-lc</code> but from the compiler's point of view, the code is ""good enough"".</p>

<p>That will change as soon as you enable all warnings that your compiler has to offer and it will fail with an error when you disable K&amp;C compatibility or enable strict ANSI checks.</p>

<p>Which is why ""C"" is often listed as ""you shoot yourself into the foot"" in ""<a href=""http://www.thealmightyguru.com/Humor/Docs/ShootYourselfInTheFoot.html"">How to Shoot Yourself In the Foot Using Any Programming Language</a>"" kind of lists.</p>
",2
13454290,13454158,0,"<p>When I compile with gcc, I get warnings about redeclaration of <code>display</code>, as you would expect.</p>

<p>Did you get warnings?</p>

<p>It might ""run"" because C doesn't mangle function names (like C++). So the linker looks for a symbol 'display' and finds one. The linker uses this address to run <code>display</code>. I would expect results to not be what you expect all the time.</p>
",0
13454332,13454158,1,"<p>It probably does (assume such declaration as you wrote), but as you are not passing parameters, it just works fine. It's the same like if you declare <code>int main()</code> where it should actually be <code>int  main(int argc, char *argv[])</code>.</p>

<p>So probably if you tried to pass some parameters (different from default ones) from <code>main</code> then use them in <code>display</code> it would fail.</p>

<p>BTW, for me it compiles, but generates warning:</p>

<pre><code>$ gcc z.c
z.c:8:6: warning: conflicting types for ¡®display¡¯ [enabled by default]
z.c:4:5: note: previous implicit declaration of ¡®display¡¯ was here
</code></pre>
",3
20522369,2396623,5,"<p>To replace all new line char with spaces, use: </p>

<pre><code>char *pch = strstr(myStr, ""\n"");
while(pch != NULL)
{
    strncpy(pch, "" "", 1);
    pch = strstr(myStr, ""\n"");
}
</code></pre>

<p>To remove first occurrence of new line char in string, use:  </p>

<pre><code>char *pch = strstr(myStr, ""\n"");
if(pch != NULL)
  strncpy(pch, ""\0"", 1);
</code></pre>
",1
13760840,13760747,0,"<p>C doesn't have dynamic look-up of structure members, of course.</p>

<p>The solution that will save the most keystrokes is probably to use a macro.</p>

<p>Also, there's no point in casting the pointer when converting from <code>void *</code>.</p>
",0
13763496,13760747,2,"<p>Assuming the items of the enum aren't given custom numbers, you can do a compact version of a switch-statement, by using function pointers.</p>

<pre><code>enum {
    TYPEA,
    TYPEB,
    TYPEC,
    TYPED,

    TYPE_N // number of enum items
} TYPE;


typedef void(*type_func_t)(void*);



static void TYPEA_specific (void* x) 
{
  struct A* y = x;

  // specific stuff related to TYPEA here

  do_something_with_next(y-&gt;next);
}

static void TYPEB_specific (void* x) 
{
  struct B* y = x;

  // specific stuff related to TYPEB here

  do_something_with_next(y-&gt;next);
}



static const type_func_t TYPE_HANDLER [TYPE_N] = 
{
  TYPEA_specific,
  TYPEB_specific
  ...
};


inline void foo (TYPE t, void* x)
{
  TYPE_HANDLER[t](x);
}
</code></pre>
",0
13763301,13760747,0,"<p>In each <code>case</code>, you can take the address of <code>next</code> with <code>&amp;y.next</code> and then either pass it to a function or transfer control to code that uses the pointer to do something with <code>next</code>. This presumes that <code>next</code> has the same type in each <code>struct</code>, although it may be in different locations.</p>

<p>Here are three examples:</p>

<pre><code>// Example 0:  Functional call.
switch(t)
{
    case TYPEA:
        MyFunction(&amp;(struct A *)x-&gt;next);
        break;
    case TYPEB:
        MyFunction(&amp;(struct B *)x-&gt;next);
        break;
}

// Example 1: Code after the switch.
TypeOfNext *next;
switch(t)
{
    case TYPEA:
        next = &amp;(struct A *)x-&gt;next;
        break;
    case TYPEB:
        next = &amp;(struct B *)x-&gt;next;
        break;
}
¡­ code that uses next¡­

// Example 2: Code in the switch, with goto.
switch(t)
{
    TypeOfNext *next;
    case TYPEA:
        next = &amp;(struct A *)x-&gt;next;
        goto common;
    case TYPEB:
        next = &amp;(struct B *)x-&gt;next;
    common:
        ¡­ code that uses next¡­
        break;
}
</code></pre>
",0
13765752,13760747,1,"<p>This solution uses a macro:</p>

<pre><code>#include &lt;stdio.h&gt;

#define POLYCAST_AB(etype, target, member) \
  *((etype) == TYPEA ? &amp;((struct A *)(target))-&gt;member :  \
    (etype) == TYPEB ? &amp;((struct B *)(target))-&gt;member : 0)

enum TYPE {
   TYPEA,
   TYPEB
};

struct A {
   int next;
} a = {42};

struct B {
   int i;
   int next;
} b = {43, 44};

static void foo(enum TYPE t, void *x) {
   POLYCAST_AB(t, x, next) += 100;  // &lt;-- most other answers can't do this
   printf(""next=%d\n"", POLYCAST_AB(t, x, next));
}

int main(void) {
   foo(TYPEA, &amp;a);   
   foo(TYPEB, &amp;b);   
   return 0;
}
</code></pre>

<p>If you don't need an lvalue, you can omit the extra <code>*</code> and <code>&amp;</code> in the macro definition (and also omit the assumption that the <code>next</code> all have the same type).</p>
",0
15869766,15869755,5,"<p><code>parent</code> is a pointer to a <code>struct cache</code>, while <code>M.C[0]</code> is a <code>struct cache</code>. You can use the <code>&amp;</code> operator to get a pointer to <code>M.C[0]</code> as so:</p>

<pre><code>M.C[0].S-&gt;parent = &amp;(M.C[0]);
</code></pre>
",0
15869768,15869755,3,"<p>You are passing the variable itself not its address. To pass its address, you need to use the address of (<code>&amp;</code>) operator :</p>

<pre><code>M.C[0].S-&gt;parent = &amp;(M.C[0]);
</code></pre>

<p>See <a href=""http://publib.boulder.ibm.com/infocenter/lnxpcomp/v8v101/index.jsp?topic=/com.ibm.xlcpp8l.doc/language/ref/addre.htm"" rel=""nofollow"">this</a> for more.</p>
",0
15816333,14686644,2,"<p>You will need to call <code>strtod</code> in the appropriate way, especially taking care of the second parameter. That parameter should be the address of a pointer to char, and this is set to point to the first character of the input string not processed by <code>strtod</code>. If you pass the pointer instead of the address of the pointer and that pointer is not initialised to something that happens to be writable memory (like <code>NULL</code>), you are likely to have a run-time error.</p>

<pre><code>int
main(int argc, char *argv[])
{
    char *endptr, *str;
    double val;

    if (argc &lt; 2) {
        fprintf(stderr, ""Usage: %s str [base]\n"", argv[0]);
        exit(EXIT_FAILURE);
    }

    str = argv[1];
    errno = 0;    

    val = strtod(str, &amp;endptr);

    if (errno != 0) {
        perror(""strtod"");
        exit(EXIT_FAILURE);
    }

    if (endptr == str) {
        fprintf(stderr, ""No digits were found\n"");
        exit(EXIT_FAILURE);
    }

    printf(""strtod() returned %f\n"", val);

    if (*endptr != '\0')        /* Not necessarily an error... */
        printf(""Further characters after number: %s\n"", endptr);

    exit(EXIT_SUCCESS);
}
</code></pre>
",1
13423705,13423673,5,"<blockquote>
  <p>Unless otherwise specified, static objects contain zero or null
  pointer values upon program startup. Automatically and dynamically
  allocated objects are initialized only if an initial value is
  explicitly specified; otherwise they initially have indeterminate
  values (typically, whatever bit pattern happens to be present in the
  storage, which might not even represent a valid value for that type).</p>
</blockquote>

<p>Reference : <a href=""http://en.wikipedia.org/wiki/C_%28programming_language%29"" rel=""noreferrer"">WikiPedia</a></p>
",2
13423732,13423673,15,"<p>The differentiation of the two (indeterminate values and trap representations) is fundamental. In one case you have no known value. In the other you have a known-invalid value. </p>

<p>Simplest example of an indeterminate value I can muster:</p>

<pre><code>int a;
int b = a;
</code></pre>

<p>There is no concept of determinate 'value' associated with <code>a</code>. It has <em>something</em> (as it is occupying memory) but the ""what"" it has is not defined, thus indeterminate. Overall, the concept is as simple as it sounds: Unless it has been <em>decided</em> what something is, it cannot be used in any evaluation (think r-value if it helps) with deterministic results.</p>

<p>The actual value depends on the language, compiler, and memory management policies. For instance, in most implementations of C, an uninitialized scope variable or the memory pointed to by the pointer returned by a call to malloc will contain whatever value happened to be stored at that address previously. On the other hand, most scripting languages will initialize variables to some default value (0, """", etc).</p>

<p>Regarding Trap Representation, it is essentially any value that is outside the restricted domain of the allowable values pertaining to the underlying formal definition. A hopefully non-confusing example follows. :</p>

<pre><code>enum FooBar { foo=0, bar=1 };
enum FooBar fb = (enum FooBar)2;
</code></pre>

<p>In general it is any bit pattern that falls within the space allowed by the underlying storage representation (in enums that is likely an <code>int</code>) but is NOT considered a valid ""value"" for the restricted domain of its formal definition. An <strong>outstanding</strong> description on trap representations and their roots can be found at <a href=""https://stackoverflow.com/questions/6725809/trap-representation"">this answer</a>. The above is just a representative of what a <em>very</em> simple known-invalid representation may appear as. In reality it is practiced in hardware for detection of values that trigger invalid-state. I think of them as ""panic"" values. Again, the above <em>code</em> is solely idealistic in demonstrating the concept of a ""value"" this is not ""valid"", but is, in fact, known.</p>
",16
12835129,12834947,2,"<p>You can do it in multiple steps:</p>

<ol>
<li>Find all embedded nul bytes</li>
<li>From this and the length you can calculate the length of a new string</li>
<li>Allocate a new string of the calculated length</li>
<li>Iterate over the binary string copying all non-nul characters, when reaching a nul character insert the special character sequence</li>
<li>Terminate new string</li>
<li>Call library function with new string</li>
<li>Free the new string</li>
</ol>
",2
12835412,12834947,1,"<p>The simple thing you can do is to just <code>replace</code> the <code>null byte</code>s up to the the length excluding the last null(string terminator). once you replaced the <code>nulls</code> then you can do what you want with the replaced string.</p>
",0
13485537,10776890,0,"<p>The simplest way I can think of going about this would be to loop through each letter of the alphabet and check if the letter is in the sentence(by looping through the sentence until the letter was found or you reach the end of the sentence).  If the letter is not in the sentence, add the number (corresponding to the missing letter) to your array.</p>

<p>here's the working function:</p>

<pre><code>int check(char *sentence, int missing[26]) 
{
  int missIndex = 0; //the index for the missing array;
  bool iWasFound; //was the letter found?  (used in the loops below)

  for(char i = 'A'; i &lt;= 'Z'; i++)
  {
    iWasFound = false;

    for(int j = 0; j &lt; 1024; j++)
    {
      if(toupper(sentence[j]) == i)
      {
        iWasFound = true;
        break;
      }
    }

    //if we did not find the letter, add the corresponding number to the missing array
    if(!iWasFound)
    {
      missing[missIndex] = (int)(i - 'A');
      cout &lt;&lt; (int)(i - 'A') &lt;&lt; "" | "" &lt;&lt; missing[missIndex] &lt;&lt; std::endl;
      missIndex++;
    }
  }

  if(missing[0] == -1)
  {
    return 1;
  }
  else
  {
    return 0;
  }
}
</code></pre>

<p>let me know if you need me to explain anything</p>
",0
10776917,10776890,0,"<p>Inside <code>check</code>, you can iterate through the string <code>sentence</code> and for each character you encounter, change <code>missing</code> to <code>1</code> for that character.</p>

<p>At the end, the missing characters will be marked with 0. If <code>missing</code> contains at least a <code>0</code>, you return <code>0</code>, otherwise <code>1</code>.</p>

<p>I'm not going to write the full code, but some hints to get you started:</p>

<p>1) You can mark the correct element using <code>currentCharacter - 'a'</code>. This will return you the index of character <code>currentCharacter</code>. </p>

<p>2) You can iterate through the string using</p>

<pre><code>char currentCharacter;
while( currentCharacter = *(sentence++) )
{
   //mark array here
}
</code></pre>
",0
10776922,10776890,1,"<p>Have you been taught about invariants?  I suggest you look for an invariant that generalizes these two special cases:</p>

<ul>
<li><p>If you have not looked at any part of the sentence, you must consider that all letters are missing.</p></li>
<li><p>If you have looked at all of the sentence, then as you have written, the <code>missing</code> data structure contains exactly those letters that are missing from the sentence.</p></li>
</ul>

<p>I also suggest you look up the ANSI C functions <code>isalpha</code> and <code>tolower</code>.</p>
",1
10777047,10776890,0,"<p>Just iterate through the input string marking which characters are in it, then check the ones that are missing:</p>

<pre><code>int main()
{
    char str[] = ""Some meaningful text"";

    int freq[256];
    int i;

    for ( i = 0; i &lt; 256; i ++) // clear frequency array
    {
        freq[i] = 0;
    }

    for (i = 0; str[i] != '\0'; i++) // parse input string
    {
        freq[str[i]]++;
    }

    for ( i = 0; i &lt; 256; i ++)
    {
        if (freq[i]==0 &amp;&amp; isalpha(i)) // find out which leters weren't typed
        {
            printf(""%c letter wasn't typed!\n"", (char)i);
        }
    }

    return 0;
}
</code></pre>
",4
10777673,10776890,1,"<p>An answer without doing your homework ...</p>

<pre><code>1) get the character
2) is it a "".""
   a) check if you have all and return result.
   b) continue
3) is it greater than/equal ""A"" but less than/equal ""Z"" ( this defines a range of characters )
   a) add it to list return to (1)
   b) continue
4) is it greater than/equal ""a"" but less than/equal ""z"" ( another range, could be combined with the first )
   a) add it to list return to (1)
   b) continue
5) is it a "" "" ( a space .. but could be another range, could be combined with the first )
  a) continue 
6) error not a correct character and exit
</code></pre>
",2
15821593,15821513,1,"<p>Most Unix or Linux systems you can login and issue the command</p>

<p>locate limits.h</p>

<p>and it will find a number of include files that list the ""limits"" for values used by the compiler.  Many of the limits files in the Linux kernel code are architecture specific, which is your especial interest</p>
",1
15823028,15821513,0,"<p>Frankly, portability is difficult to obtain 100%. I've been programming for 30 years and have never seen anything but simple programs that are 100% portable. Given the PC is ubiquitous, I don't think you should concern yourself with portability over functionality. Hence, all the references you find to ""implementation defined"".</p>

<p>In a perfect world, programs would be portable. In the real world, OS makers add features to compete with other OS makers and even themselves (Win 95, 98, 2000, XP, 7, Vista) (and Linux distros have differences). As a result, being portable -- IN MY EXPERIENCE -- means a trade-off you're not willing to make: too slow, too bulky, too much development time, too much testing, etc. If you seek portability, you need to ask why and is it worth it. Even if you decide to do so, you will find yourself adding compile-time options based on your environment and may end up with entire files that are specific and non-portable.</p>

<p>When I write code for an Atmel Mega16 I don't consider whether I'm going to port that code. In this case, you don't have the luxury of infinite CPU cycles and boundless memory to consider a portable solution -- we're trying to squeeze all the juice out of a little micro.</p>

<p>Likewise, it's often the case you need to optimize routines in assembler in order to gain back CPU cycles for more features. (Like a DSP running a DFT -- it's ok in C when you first ship it, but eventually you need to reduce that to ASM to get back a pile of CPU cycles for 23 more features your boss wants you to add by tomorrow morning. Portability be damned.)</p>

<p>So, yes, much is implementation specific. In the PC world you have a little more luxury, but if you're writing code that interfaces with hardware you're often forced to create non-portable code. I could go on and on about this, but I have a loop that needs optimizing...</p>
",0
15591113,15590830,0,"<p>There may be other problems but one thing that stood out immediately was that having pointers in a struct isn't good enough, you have to use malloc() for each one in your case.</p>

<p>And if you declare those big arrays inside your function they will be on the stack which will be eventually overwritten.</p>

<p>Use:</p>

<pre><code>struct quadpts{    //structure used to pass multiple values into roeFlux
    int n;  //The specific heat ratio
    double *x;
    int x_len;
    double *w;
    int w_len;
};
</code></pre>

<p>And inside the function:</p>

<pre><code>qpt-&gt;x = malloc(qpt-&gt;x_len * sizeof(double));
qpt-&gt;w  = malloc(qpt-&gt;w_len * sizeof(double));
</code></pre>

<p>And then fill your arrays.
Don't forget to free() them once you are done using them [outside your function].</p>

<p>Another mistake is that you should use malloc() with a struct pointer:</p>

<pre><code>Quadpts * qpt = (Quadpts*)malloc(sizeof(Quadpts));
</code></pre>

<p>You would also need 3 lines of code once you no longer need it to avoid memory leaks.</p>

<pre><code>free(qpt-&gt;x);
free(qpt-&gt;w);
free(qpt);
</code></pre>
",9
16431645,12535320,-1,"<pre><code>inline char HexToChar(char c)
{
    if ('0' &lt;= c &amp;&amp; c &lt;= '9')
    {
        return c - '0';
    }
    else if ('a' &lt;= c &amp;&amp; c &lt;= 'f')
    {
        return c + 10 - 'a';
    }
    else if ('A' &lt;= c &amp;&amp; c &lt;= 'F')
    {
        return c + 10 - 'A';
    }

    return -1;
}

size_t HexToBinrary( const char* hex, size_t length, char* binrary, size_t binrary_cap )
{
    if (length % 2 != 0 || binrary_cap &lt; length / 2)
    {
        return 0;
    }

    memset(binrary, 0, binrary_cap);
    size_t n = 0;
    for (size_t i = 0; i &lt; length; i += 2, ++n)
    {
        char high = HexToChar(hex[i]);
        if (high &lt; 0)
        {
            return 0;
        }

        char low = HexToChar(hex[i + 1]);
        if (low &lt; 0)
        {
            return 0;
        }

        binrary[n] = high &lt;&lt; 4 | low;
    }
    return n;
}
</code></pre>
",0
12834441,12834385,1,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

int main ()
{
  char path[] =""/aaa/bbb/ccc/file"";
  char *part1 = (char *)malloc (strlen(path));
  strcpy (part1, path);
  char *pos = strrchr (part1, '/');
  *pos = '\0';
  char *part2 = strdup (pos + 1);
  printf (""%s \n%s"", part1, part2 );

}
</code></pre>
",0
13729585,13729559,6,"<p>You are discarding the result returned by realloc.  You need to assign that value to <code>result</code>.  The typical usage looks like:</p>

<pre><code>if ((tmp = realloc(result, allocatedSize)) == NULL) {
      perror(""realloc"");
      /* more error handling here, including (usually) freeing result or exiting */
} else {
      result = tmp;
}
</code></pre>
",0
13729591,13729559,4,"<p><a href=""http://linux.die.net/man/3/realloc"" rel=""nofollow"">realloc</a> returns a pointer to the reallocated buffer and may free the original buffer.  This means that</p>

<pre><code>if (realloc(result, allocatedSize) == NULL)
</code></pre>

<p>is wrong as it effectively discards the buffer, leaving you using the old, now potentially freed buffer.  The problem you are seeing is not a buffer overflow as such; it is instead a crash caused by the undefined behaviour resulting from attempting to write to memory you no longer have allocated.</p>

<p>You can change your code to</p>

<pre><code>void* tmp = realloc(result, allocatedSize);
if (tmp != NULL)
    result = tmp;
else    
    perror(""realloc"");
</code></pre>
",4
13729805,13729559,0,"<p>realloc() return type is void* which is casted to requirement. And this pointer points to new memory of size allocatedSize. Ideally realloc does four operations,</p>

<ol>
<li>It creates new memory of size specified.</li>
<li>Copies contents from old memory to newer.</li>
<li>Frees the old memory</li>
<li>Returns address of new memory  </li>
</ol>
",0
13729988,13729559,0,"<p>Gotta love the <a href=""http://linux.die.net/man/3/realloc"" rel=""nofollow"">man pages</a>, all of lifes answers are there... the important ones anyway.</p>

<blockquote>
  <p><strong>Return Value</strong><br>
  The malloc() and calloc() functions return a pointer to the allocated memory that is suitably aligned for any kind of variable. On error, these functions return NULL. NULL may also be returned by a successful call to malloc() with a size of zero, or by a successful call to calloc() with nmemb or size equal to zero. 
  The free() function returns no value. </p>
  
  <p>The realloc() function returns a pointer to the newly allocated memory, which is suitably aligned for any kind of variable <strong>and may be different from ptr</strong>, or NULL if the request fails. If size was equal to 0, either NULL or a pointer suitable to be passed to free() is returned. If realloc() fails the original block is left untouched; it is not freed or moved. </p>
</blockquote>

<p>As you can see <code>malloc()</code>'s friend <code>realloc()</code> gets its only entry in the man page because of the highlighted part, the value returned from <code>realloc()</code> can be different from the reference to the memory that you pass in. This is an important note. </p>

<p>So in your code here:</p>

<pre><code>if (realloc(result, allocatedSize) == NULL) {
  perror(""realloc"");
}
</code></pre>

<p>You're disregarding the result you really care about. Checking for <code>NULL</code> is good, but you need to assign to some temporary variable and then check. 
<br>(note the reason to assign to a temporary variable is in the man page too, if the <code>realloc()</code> fails your <code>result</code> buffer will still be good as long as you don't overwrite it)</p>
",0
12876665,12876651,1,"<p>Your format string specifies 3 <code>float</code> values, but you're passing pointers to <code>int</code>. You should see a compiler warning about using different types.</p>

<p>If you want to read <code>float</code>, then use <code>float</code> variables to receive the data.</p>
",0
12876668,12876651,1,"<p>Use float variables instead of <code>int</code>s. In <code>fscanf</code> you are using <code>%f</code> but the variables are ints which invokes undefined behaviour.</p>
",0
12876686,12876651,1,"<p>You declared the variables as <code>int</code>,</p>

<pre><code>int xTemp = 0, xTot = 0;
int yTemp = 0, yTot = 0;
int zTemp = 0, zTot = 0;
</code></pre>

<p>but scan them as <code>float</code>s, so the values are the bit representation of the <code>float</code>s interpreted as <code>int</code> (although it is undefined behaviour, so anything else might happen too).</p>

<p>Furthermore, your loop control is wrong,</p>

<pre><code>while(!feof(file)) {

    if(fscanf(file, ""%f %f %f"", &amp;xTemp, &amp;yTemp, &amp;zTemp) != 3) {

        return -1;

    }
</code></pre>

<p>will always return <code>-1</code>. <code>feof(file)</code> will only become true <em>after</em> you tried to read data from past the end of the file, so the loop will run again after the last line has been read, and then the <code>fscanf</code> won't read three values anymore.</p>

<p>A better loop control would be</p>

<pre><code>while(fscanf(file, ""%f %f %f"", &amp;xTemp, &amp;yTemp, &amp;zTemp) == 3)
</code></pre>
",0
13480313,13478479,1,"<p>The following code uses nested loops.
The outer loop is endless; replace it by a loop of a length you need. The inner loop changes the string to the next one: ""aa"" to ba"", ""ba"" to ""ca"", ..., ""zz"" to ""aaa"", etc. It changes individual characters in the string instead of using <code>strcat</code>.</p>

<p>Note that the output looks a bit backward; i guess it's not too bad because it's not very important in which order to check all the guesses, as long as you check them all.</p>

<pre><code>char str[100] = """"; // initialize all characters to '\0'
char min = 'a';
char max = 'z';
for (;;)
{
    int i;
    int increase_length = 1; // a flag to detect transitions like ""zzz"" =&gt; ""aaaa""
    for (i = 0; str[i] != '\0'; ++i)
    {
        if (str[i]++ == max) // change to next character and check whether it was 'z'
        {
            str[i] = min;
        }
        else
        {
            increase_length = 0;
            break;
        }
    }
    if (increase_length)
        str[i] = min;
    puts(str);
}
</code></pre>
",0
18763128,4392665,0,"<pre><code>#define ZERO 48
#define NINE 57
#define MINUS 45
#define DECPNT 46

int strtoint_n(char* str, int n)
{
    int sign = 1;
    int place = 1;
    int ret = 0;

    int i;
    for (i = n-1; i &gt;= 0; i--, place *= 10)
    {
        int c = str[i];
        switch (c)
        {
            case MINUS:
                if (i == 0) sign = -1;
                else return -1;
                break;
            default:
                if (c &gt;= ZERO &amp;&amp; c &lt;= NINE) ret += (c - ZERO) * place;
                else return -1;
        }
    }

    return sign * ret;
}

float _float_fraction(char* str, int n)
{
    float place = 0.1f;
    float ret = 0.0f;

    int i;
    for (i = 0; i &lt; n; i++, place /= 10)
    {
        int c = str[i];
        ret += (c - ZERO) * place;
    }
    return ret;
}
float strtoflt(char* str)
{
    int n = 0;
    int sign = 1;
    int d = -1;
    int ret = 0;

    char* temp = str;
    while (*temp != '\0')
    {
        switch (*temp)
        {
            case MINUS:
                if (n == 0) sign = -1;
                else return -1;
                break;
            case DECPNT:
                if (d == -1) d = n;
                else return -1;
                break;
            default:
                if (*temp &lt; ZERO &amp;&amp; *temp &gt; NINE) return -1;
        }
        n++;
        temp++;
    }

    if (d == -1)
    {
        return (float)(strtoint_n(str, n));
    }
    else if (d == 0)
    {
        return _float_fraction((str+d+1), (n-d-1));
    }
    else if (sign == -1 &amp;&amp; d == 1)
    {
        return (-1)*_float_fraction((str+d+1), (n-d-1));
    }
    else if (sign == -1)
    {
        ret = strtoint_n(str+1, d-1);
        return (-1) * (ret + _float_fraction((str+d+1), (n-d-1)));
    }
    else
    {
        ret = strtoint_n(str, d);
        return ret + _float_fraction((str+d+1), (n-d-1));
    }
}
</code></pre>
",1
13485605,13485585,3,"<p>It looks like you want to make the first array size a variable run-time value (specified by <code>arrayLength</code>), while keeping the second size as fixed compile-time value (<code>3</code>). In that specific situation it is easy</p>

<pre><code>char (*myArray)[3];
int arrayLength;
...
/* compute arrayLength */
...
myArray = malloc(arrayLength * sizeof *myArray);
for (i = 0; i &lt; arrayLength; ++i) 
  strcpy(myArray[i], ""ab"");
...
free(myArray);
</code></pre>

<p>Things will get more complicated if you decide to make the second array size a run-time value as well.</p>

<p>P.S. <code>strncpy</code> is not supposed to serve as a ""safe"" version of <code>strcpy</code> (see <a href=""https://stackoverflow.com/a/2115015/187690"">https://stackoverflow.com/a/2115015/187690</a>, <a href=""https://stackoverflow.com/a/6987247/187690"">https://stackoverflow.com/a/6987247/187690</a>), so I used <code>strcpy</code> in my code. But you can stick with <code>strncpy</code> if you so desire.</p>
",2
17392962,17392763,4,"<p>The problem is that a pointer to an array is not compatible with a pointer to a pointer. They are different things. And it's a good thing too, because this is meant to catch errors like the one in your code. What you are doing is basically this:</p>

<pre><code>unsigned char szrecordid[28];
szrecordid = malloc(i * sizeof **value);
</code></pre>

<p>You should be able to see the problem; you're trying to assign a pointer to an array.</p>
",1
17392974,17392763,1,"<p>If I understand correctly, your problem is that you can't change the address of szrecordid:</p>

<pre><code>typedef struct _MY_STRUCT_TYPE {
    unsigned char   szrecordid[28];
}
</code></pre>

<p>And if you can't change the address of this variable it's because it's an array. Try using a char * instead or don't malloc and use <code>strcpy</code> instead.</p>

<p>By the way, please consider using <code>strcpy</code> and <code>strdup</code> when you can. Basically, your function is doing:</p>

<pre><code>strcpy(val, buffer);
printf(""\n chararr: %s :"", val);
*value = strdup(buffer);
printf(""%s"", value);
</code></pre>

<p>And you could also notice that the first strcpy is useless too. I don't understand the meaning of this intermediate char array.</p>
",4
17392991,17392763,1,"<p><code>szrecordid</code> is an array of unsigned characters, not a pointer, so when you taks its address (<code>&amp;myStructVar-&gt;szrecordid</code>) you get a pointer to an array (an <code>unsigned char (*)[28]</code>), and not a pointer to a pointer, which is what the function expects.</p>

<p>If you think about it, it makes perfect sense -- you can't move an array by simply changing its address, as its address (and size) is fixed at the time it is allocated (when you create whatever it is that <code>myStructVar</code> points at).  If you want to change that array, you need to change its contents by copying into into it, and that won't change the size, which is fixed at 28.</p>

<p>The obvious solution to your problem is make it a pointer instead of an array:</p>

<pre><code>typedef struct _MY_STRUCT_TYPE {
    unsigned char   *szrecordid;
}
</code></pre>
",1
13696187,13696123,1,"<p>Although I haven't personally loaded it onto an MCU and tested it, yes, that looks fine as long as <code>TXIF</code> does what it looks like.</p>

<p>You really should use <code>snprintf</code> or a larger buffer. This is one case where overflowing the integer (as in simply having too large a value, or any negative value) would cascade into buffer overflow.</p>
",6
13696190,13696123,1,"<p>If you want to send string of 5-9 characters:</p>

<pre><code>1 or 2 or 3 symbols - Duty_Cycle value,
1 symbol - % symbol,
1 symbol - space,
1 or 2 or 3 symbols - DAC_Output value,
1 symbol - \n symbol,
</code></pre>

<p>you are doing right.</p>
",0
13411338,13411125,7,"<p>You're using  Dev-C++, but strdup is not part of the C or C++ standard, it's a POSIX function. You need to define the proper (according to your IDE's documentation) preprocessor symbols in order for strdup to be declared by the header file ... this is necessary in order for the header file not to pollute the name space when included into conforming C or C++ source files.</p>

<p>For a simple portable alternative, consider</p>

<pre><code>char* mystrdup(const char* s)
{
    char* p = malloc(strlen(s)+1);
    if (p) strcpy(p, s);
    return p;
}
</code></pre>

<p>Or, if you know strdup is actually in the library, you can copy its declaration from string.h into your own source file or header ... or use the simpler declaration from the man page:</p>

<pre><code>char *strdup(const char *s);
</code></pre>
",2
13411154,13411125,6,"<p>That's not right. <code>strdup</code> returns <code>char *</code> already. Something else is wrong. Probably because you did not include the right header file that declares the true return type for this function.</p>

<pre><code>#include &lt;string.h&gt;
</code></pre>
",2
13411163,13411125,1,"<p>You're missing <code>#include &lt;string.h&gt;</code>.  In the absence of function signatures, strdup is assumed by the compiler to return an int, hence the warning.</p>
",0
13411174,13411125,1,"<p><code>man strdup</code></p>

<p>you will get following things</p>

<pre><code>#include&lt;string.h&gt;

char* strdup(const char * s);
</code></pre>

<p>so <code>strdup()</code> returns <code>char*</code> there shuld not be any problem
Actually in your case it takes implicit declaration of <code>strdup()</code> so by default return type is <code>int</code> hence you get this warning</p>

<p>Either <code>include&lt;string.h&gt;</code></p>

<p>or</p>

<p>give forward declaration <code>char* strdup(const char *);</code></p>

<p>Also don't forget to <code>free(s)</code> in last when all usage are done</p>
",6
9770890,9767686,0,"<p>A c learner newbie's try</p>

<pre><code>int number = 16;
if(16 == number&amp;(0x10))
    puts(""true"");
else
    puts(""false"");
</code></pre>
",1
9770964,9767686,0,"<p>Everybody is shifting to the right. I want to be original and shift to the left:</p>

<pre><code>#define INDEX 5

int number = 16;

if (number&lt;&lt;(sizeof(number)*8-INDEX-1)&lt;0)

  printf(""Bit #%d is set in %d.\n"", INDEX, number);
else    
  printf(""Bit #%d is NOT set in %d.\n"", INDEX, number);
</code></pre>

<p>This code is ugly and <strong>absolutely</strong> implementation dependent (the C standard says that the result is undefined). On x86 it works and it is somewhat more efficient because the MSB is always copied in the bit #7 (""sign"") of the flags register, which can be tested with a single <code>jns</code> instruction.</p>

<p>In other words, for INDEX 5, you have:</p>

<pre><code>[...]
shl $0x1F, %eax
test %eax, %eax
jns 8053635
[...]
</code></pre>

<p>The original solution of the OP is cleaner, and that's how production code should be like.</p>
",3
9771258,9767686,0,"<p>Any attempt to optimize that code falls under the category ""premature optimization"". If you understand how the compiler translates C to machine code, you would not attempt to optimize that code. I am guessing the interviewer lacked such knowledge.</p>

<p>If we dissect that code, this is what we get:</p>

<p><code>1&lt;&lt;5</code> is translated to the literal 32 at compile time. There is absolutely no difference in performance between writing <code>int mask = 1&lt;&lt;5;</code> and <code>int mask = 32;</code>, but the latter is far harder to understand.</p>

<p>Further,</p>

<ul>
<li><code>if ((number &amp; mask) == 0)</code> is completely equivalent to </li>
<li><code>if ((number &amp; 32) == 0)</code> is completely equivalent to </li>
<li><code>if ((number &amp; (1&lt;&lt;5)) == 0)</code></li>
</ul>

<p>There exists two cases: </p>

<ul>
<li>Either the compiler needs to find a memory location to store the mask. 
<ul>
<li>If the user declared a variable mask, the value will be stored there. </li>
<li>If the user didn't declare a variable, the value will be stored in an invisible temporary variable.</li>
<li>RAM consumption in the two above cases is completely equivalent.</li>
</ul></li>
<li>Or the compiler does not need to store the mask anywhere. It will optimize away the whole mask variable or numeric literal and bake them in with the rest of the program instruction.</li>
</ul>

<p>Which of these two that will be picked depends on whether <code>int number = 16;</code> is modified or not from the point of declaration to the if statement where the masking takes place.</p>

<p>And that's it. Any attempt to write the code differently than in your original example is <em>premature optimization</em> and <em>obfuscation</em> and will not result in any performance difference.</p>
",2
9774252,9767686,0,"<p>Forgive the following answer:</p>

<p>I used to work at a start-up, when the company decided not to pursue a candidate, they come up with a bogus reason to end the interview. Perhaps this was the poster's experience.</p>

<p>asking for kth bit may mean the least significant bit is the zeroth bit so that (number &amp; 1 &lt;&lt; 5) would not do. But that was not the issue. He asked for optimization. Sometime the reason you fail an interview has nothing to do with you. In that case it's their loss; there will always be another interview opportunity.</p>
",0
9822968,9767686,0,"<p>In one of the interviews, i gave the following answer, and he was satisfied, but a little change to the question was 'check if nth bit is set.</p>

<pre><code>int N = 16;
printf (""%d\n"", (N &gt;&gt; (n-1)) % 2); 
</code></pre>

<p>So, when making the answer generic, 
Not exactly sure which one (of below) is faster for this example.</p>

<pre><code>1&lt;&lt;(n-1) &amp; N (or)
N&gt;&gt;(n-1) % 2 (or)
N&gt;&gt;(n-1) &amp; 1
</code></pre>
",0
13433646,13433594,2,"<p>Use <code>96</code> in place of <code>97</code> problem solved</p>

<p>so when you wrap around then actually increase by 1 extra value
think of this;</p>

<pre><code>    ------------------------------------------
    a  |  b |  c |  d  | . . . x  |  y  |  z  |
    --------------------------------------------
    97 | 98 | 99 | 100 | . . .120 | 121 | 122 |
    -------------------------------------------
</code></pre>

<p>Try using 'a' , 'b' , .. .. .. ,'z' like this rather their actual values</p>

<p>using <code>' '</code>single quote inside char gives you integral value i.e. ASCII value </p>

<p>here is the code :</p>

<pre><code>char c;
for (int i = 0; i &lt; strlen(text); i++)
{   
    if (text[i] != ' ')
    {
       // printf(""\n%i\n"", key);

        c=text[i];    
        text[i] = text[i] + key;

        if(c &gt;='a' &amp;&amp; c &lt;='z' &amp;&amp; text[i] &gt;'z')
            text[i] = text[i] + 'a' -1 - 'z' ; 

        if(c &gt;='A' &amp;&amp; c &lt;= 'Z' &amp;&amp; text[i] &gt; 'Z')
            text[i] = text[i] + 'A' -1 - 'Z' ; 

    }
}
</code></pre>
",3
11515047,11515037,5,"<p>You're asking <code>printf()</code> to interpret that value as a signed integer, whose range is <code>-(2**31)</code> to <code>(2**31)-1</code>.  Basically, the high bit is a sign bit.  Read about <a href=""https://en.wikipedia.org/wiki/Two%27s_complement"" rel=""noreferrer"">two's complement</a>.</p>
",2
11515050,11515037,9,"<p>You're using the wrong format string. <code>%d</code> is a signed decimal int. You should use <code>%u</code>.</p>

<p><code>printf</code> has no knowledge of the types of variables you pass it. It's up to you to choose the right format strings.</p>
",0
11515056,11515037,0,"<p>Because %d represents a signed integer. With a signed integer, the high bit (32nd bit) is set when the integer is negative, or not as the case may be. In 0xFFFFFFFF the high bit is set, so when casting to a signed integer, the result is negative. To treat the high bit as part of the number itself, use an unsigned type</p>

<pre><code>%lu or %u 
</code></pre>
",0
9199048,9199001,5,"<p>You want <a href=""http://www.manpagez.com/man/3/basename/""><code>basename(3)</code></a>.</p>
",2
9199061,9199001,1,"<p>I'm sure there is a less roundabout way of doing this, but you could always search through the filepath (I assume it is stored as a char array?), get the position of the final '\', and then erase everything prior to that.</p>

<p>Edit: See R's comment.</p>
",3
9199094,9199001,3,"<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;libgen.h&gt;

int main(void)
{
    char * path = ""/homes/mk08/Desktop/lala.c"";
    char * tmp  = strdup(path);

    if(tmp) {
        printf(""%s\n"", basename(tmp));
        free(tmp);
    }

    return EXIT_SUCCESS;
}
</code></pre>

<p>This will output:</p>

<pre><code>lala.c
</code></pre>
",1
9199161,9199001,6,"<p>Here's a function to remove the path on POSIX-style (<code>/</code>-separated) pathnames:</p>

<pre><code>char *base_name(const char *pathname)
{
    char *lastsep = strrchr(pathname, '/');
    return lastsep ? lastsep+1 : pathname;
}
</code></pre>

<p>If you need to support legacy systems with odd path separators (like MacOS 9 or Windows), you might need to adapt the above to search for multiple possible separators. For example on Windows, both <code>/</code> and <code>\</code> are path separators and any mix of them can be used.</p>
",0
11522203,3933551,0,"<p>You've asked a good question. I suggest that you do two things to satisfy yourself that there is enough room to store a character:</p>

<p>1) Look at the documentation for getchar(), and you will see it returns an int, so there is enough room to store a character's value. It is good to understand the underpinnings of the declaration, but if you declare <code>char cTestChar = 'c';</code> there is enough room to store the value.</p>

<p>2) Generate an assembly listing when you compile. Visual C/C++ supports this as well as gcc. gcc uses the -Wa option to generate assembly output. The map will show the allocation of a character type.</p>
",0
16382490,16382136,1,"<p>Your two conditions are equivalent to:</p>

<pre><code>char notEndOfFile = (getchar() != EOF); // notEndOfFile is a boolean
if(!(inp = notEndOfFile))    // inp is now a boolean, not the character input
   break;                    // break if notEndOfFile is false
</code></pre>

<p>This terminates at the right time, but doesn't assign inp as desired.</p>

<p>and:</p>

<pre><code>inp = getchar();     // As desired
if(inp != EOF) break // break if inp is EOF
</code></pre>

<p>Terminates and assigns inp correctly.</p>
",0
16382161,16382136,11,"<p>What's happening is exactly what you're saying, <code>The precedence of != is higher than that of =</code>.</p>

<p>That means that <code>!=</code> <em>binds harder</em> than <code>=</code> and</p>

<pre><code>while(inp = getchar() != EOF) {
</code></pre>

<p>is equivalent to;</p>

<pre><code>while(inp = (getchar() != EOF)) {
</code></pre>

<p>That will set <code>inp</code> to the bool value of the comparison, not the character value you're looking for.</p>
",2
13755040,13754985,4,"<p>It's because you memcpy sizeof(nextLine) bytes, clobbering outside the memory you have allocated. Instead of sizeof(nextLine) you should use strlen(nextLine) and things should be fine.</p>

<p>Realloc errors like this generally indicate that the memory heap has been corrupted, which usually occurs because of out-of-bounds writes or reusing freed pointers.</p>

<p>Valgrind is your friend for problems like these.</p>
",1
9191805,9191721,1,"<p>You never reset <code>reverse</code> to 0 after you calculated the first, so you never detect any palindrome.</p>
",0
9191809,9191721,1,"<p>You're not resetting <code>reverse</code> inside the loop. So it's garbage after the first iteration.</p>

<p>Add <code>reverse = 0;</code> before the <code>while (temp!=0)</code> block.</p>
",0
9191848,9191721,0,"<p>You are multiplying by 0 right in the middle of your code, that'll be it.</p>
",2
9192075,9191721,0,"<p>Also you don't actually initialise <code>pelindromenum</code> to zero.</p>

<pre><code>unsigned long long int mul = 1, temp = 0, reverse = 0, pelindromenum;=0
</code></pre>
",0
8727883,8727771,3,"<p>Shouldn't run length encoding turn 2,0,0,0,3,0,0,9 into 2 1 0 3 3 1 2 0 9 1?</p>

<p>1) The first thing I see is wrong is that you aren't looking at the entire array. You're using &lt; to stop before 8, but also stopping at 7, so you only evaluate array items 0 - 6.</p>

<p>2) If ct stands for count it's never reset (ct=0 only on declaration). Also it's assignment is this: a[flag]= ct; which overwrites your original data. It basically tracks the value of i.</p>

<p>This is my version I've just put together:</p>

<pre><code>#define SZ 8

main()
{
    int a[SZ]={2,0,0,0,3,0,0,9};
    int i; //absolute position

    int runningCount = 1; //because we start at array index 1 and not zero

    for (i = 1; i &lt;= SZ; i++) {
        if (a[i - 1] == a[i]) //value same as one before it...
           runningCount++;
        else { // new value found. print last one, and the count of the last one.
            printf(""%d %d "", a[i - 1], runningCount);
            runningCount = 1; //reset for next loop
        }
    }

    return 0;
}
</code></pre>

<p>The output is <code>2 1 0 3 3 1 0 2 9 1</code></p>

<p>Ok based on the comment left below, your algorithm would actually look like this:</p>

<pre><code>#define SZ 8

main()
{
    int a[SZ]={2,0,0,0,3,0,0,9};
    int i; //absolute position

    int zero_count = 0; //target zeros specifically...

    for (i = 0; i &lt; SZ; i++) {
        if (a[i] == 0)
           zero_count++;
    }

    //now write it out in a bizarre, unparsable format again...

    for (i = 0; i &lt; SZ; i++) {

        if (a[i] != 0)           //write out all non zero values
            printf(""%d "", a[i]);

        if (i == 0) { //this says put the zero count after the first number was printed
           printf(""%d 0 "", zero_count); //inserting it into a strange place in the array
        }

    }

    return 0;
}
</code></pre>

<p>which outputs: <code>2 5 0 3 9</code></p>
",6
8727886,8727771,0,"<p>You need a &lt;= in your for loop:</p>

<pre><code>for(i=0;i&lt;=7;i++)
</code></pre>

<p>instead of</p>

<pre><code>for(i=0;i&lt; 7;i++)
</code></pre>

<p>Otherwise you miss the last element.</p>
",1
8728145,8727771,0,"<p>All you appear to be doing is (a) counting the number of times 0 occurs in the array, and (b) replacing the first occurrence of 0 with that count.  It's not clear how this is meant to be a useful encoding.</p>

<p>In any case, you're not getting your desired result, at least in part, because you're only modifying one element of the array.  I suspect what you want, or at least think you want, is to shift the non-zero elements of the array to the left as you encounter them.</p>

<p>What is the utility of compressing the array in the way you propose?  Is some other piece of code going to have to reconstruct the original, and if so how do you expect to do so from your desired result?</p>
",1
16419063,16418837,1,"<p>If you read the <a href=""http://www.opensource.apple.com/source/gcc/gcc-926/libio/iovfscanf.c"" rel=""nofollow"">source code for scanf</a> (actually, the internal function that operates <code>scanf</code>), you will see that a <code>%c</code> specifier will trigger execution of the <code>CT_CHAR</code> switch case, which does not call <code>ungetc</code> on the standard input. So you are right.</p>

<p>This applies to GNU libc only, but I expect other implementations to behave similarly.</p>
",0
8757516,8740195,0,"<p>I'm not a fan of this ""array of pointers to array"" to solve the multi dimension array paradigm. Always favored a single dimension array, at access the element with array[ row * cols + col]? No problems encapsulating everything in a class, and implementing a 'at' method.</p>

<p>If you insist on accessing the members of the array with this notation: Matrix[i][j], you can do a little C++ magic. @John solution tries to do it this way, but he requires the number of column to be known at compile time. With some C++ and overriding the operator[], you can get this completely:</p>

<pre><code>class Row
{
private:
    int* _p;

public:
    Row( int* p )                   { _p = p; }
    int&amp; operator[](int col)        { return _p[col]; }
};


class Matrix
{
private:
    int* _p;
    int _cols;

public:
    Matrix( int rows, int cols )  { _cols=cols; _p = (int*)malloc(rows*cols ); }
    Row operator[](int row)       { return _p + row*_cols; }
};
</code></pre>

<p>So now, you can use the Matrix object, for example to create a multiplication table:</p>

<pre><code>Matrix mtrx(rows, cols);
for( i=0; i&lt;rows; ++i ) {
    for( j=0; j&lt;rows; ++j ) {
        mtrx[i][j] = i*j;
    }
}
</code></pre>

<p>You should now that the optimizer is doing the right thing and there is no call function or any other kind of overhead. No constructor is called. As long as you don't move the Matrix between function, even the _cols variable isn't created. The statement <em>mtrx[i][j]</em> basically does mtrx[i*cols+j].</p>
",1
8740215,8740195,16,"<pre><code>int **array = malloc (nrows * sizeof(int *) + (nrows * (ncolumns * sizeof(int)));
</code></pre>

<p>This works because in C, arrays are just all the elements one after another as a bunch of bytes. There is no metadata or anything. malloc() does not know whether it is allocating for use as chars, ints or lines in an array.</p>

<p>Then, you have to initialize:</p>

<pre><code>int *offs = &amp;array[nrows]; /*  same as int *offs = array + nrows; */
for (i = 0; i &lt; nrows; i++, offs += ncolumns) {
    array[i] = offs;
}
</code></pre>
",10
8740309,8740195,1,"<p>You should be able to do this with (bit ugly with all the casting though):</p>

<pre><code>int** array;
size_t pitch, ptrs, i;   
char* base; 
pitch = rows * sizeof(int);
ptrs = sizeof(int*) * rows;
array = (int**)malloc((columns * pitch) + ptrs);
base = (char*)array + ptrs;
for(i = 0; i &lt; rows; i++)
{
    array[i] = (int*)(base + (pitch * i));
}
</code></pre>
",9
8740333,8740195,48,"<p>Just compute the total amount of memory needed for both <code>nrows</code> row-pointers, and the actual data, add it all up, and do a single call:</p>

<pre><code>int **array = malloc(nrows * sizeof *array + (nrows * (ncolumns * sizeof **array));
</code></pre>

<p>If you think this looks too complex, you can split it up and make it a bit self-documenting by naming the different terms of the size expression:</p>

<pre><code>int **array; /* Declare this first so we can use it with sizeof. */
const size_t row_pointers_bytes = nrows * sizeof *array;
const size_t row_elements_bytes = ncolumns * sizeof **array;
array = malloc(row_pointers_bytes + nrows * row_elements_bytes);
</code></pre>

<p>You then need to go through and initialize the row pointers so that each row's pointer points at the first element for that particular row:</p>

<pre><code>size_t i;
int * const data = array + nrows;
for(i = 0; i &lt; nrows; i++)
  array[i] = data + i * ncolumns;
</code></pre>

<p>Note that the resulting structure is subtly different from what you get if you do e.g. <code>int array[nrows][ncolumns]</code>, because we have explicit row pointers, meaning that for an array allocated like this, there's no real requirement that all rows have the same number of columns.</p>

<p>It also means that an access like <code>array[2][3]</code> does something distinct from a similar-looking access into an actual 2d array. In this case, the innermost access happens first, and <code>array[2]</code> reads out a pointer from the 3rd element in <code>array</code>. That pointer is then treatet as the base of a (column) array, into which we index to get the fourth element.</p>

<p>In contrast, for something like</p>

<pre><code>int array2[4][3];
</code></pre>

<p>which is a ""packed"" proper 2d array taking up just 12 integers' worth of space, an access like <code>array[3][2]</code> simply breaks down to adding an offset to the base address to get at the element.</p>
",16
8742251,8740195,11,"<p>Here's another approach.</p>

<p>If you know the number of columns at compile time, you can do something like this:</p>

<pre><code>#define COLS ... // integer value &gt; 0
...
size_t rows;
int (*arr)[COLS];
...              // get number of rows
arr = malloc(sizeof *arr * rows);
if (arr)
{
  size_t i, j;
  for (i = 0; i &lt; rows; i++)
    for (j = 0; j &lt; COLS; j++)
      arr[i][j] = ...;
}
</code></pre>

<p>If you're working in C99, you can use a pointer to a VLA:</p>

<pre><code>size_t rows, cols;
...               // get rows and cols
int (*arr)[cols] = malloc(sizeof *arr * rows);
if (arr)
{
  size_t i, j;
  for (i = 0; i &lt; rows; i++)
    for (j = 0; j &lt; cols; j++)
      arr[i][j] = ...;
}
</code></pre>
",0
13782922,4156585,28,"<p>There is a way to determine the size of a function. The command is:</p>

<pre><code> nm -S &lt;object_file_name&gt;
</code></pre>

<p>This will return the sizes of each function inside the object file. Consult the manual pages in the GNU using 'man nm' to gather more information on this.</p>
",1
14830834,3520461,1,"<p>Here is a little demo of using function pointers in ARDUINO. This example does not allow for concurrency. It perfectly transferable to normal C if make write the setup and loop inside main()<br>
Each state is a void() function. Each state function is responsible for reading input and setting output. When this is done the function should return immediately. It will be called again directly. The function is also responsible for state-transition by calling the leave function immediately before returning. Each state function should have a static long variable for timekeeping.<br>
A global variable state is set to point to the initial state in the setup routine. 
I wanted timekeeping in the different states so i implemented the state transitions by 2 functions: <br><br>
void enter(long *stateTime), this should be called the very first thing when entering the state functions. It activates the state if inactive end keeps time. <br><br>
void leave(void (*next)(), long *statetime), this changes the global state pointer and deactivates the current state.<br><br></p>

<pre><code>void (*state)();//function pointer for state machine
long prevMillis = 0;//timekeeper
const int LEDPIN = 13;
int counter1 = 0;

void enter(long *statetime){
  if(*statetime==-1){//check for passive state
    prevMillis = millis();//set timemark when entering state
  }//if(statetime==0)
  *statetime = millis()-prevMillis;//keep time
}//enter()

void leave(void (*next)(), long *statetime){
  *statetime=-1;//set state to passive
  state=next;//point to next state
}//leave()

void off500ms(){
  static long stateMillis;//timer for this state
  enter(&amp;stateMillis);//update timer
  digitalWrite(LEDPIN, LOW);
  if(stateMillis&gt;499){//check if time is up
    leave(on500ms, &amp;stateMillis);
  }//if(stateMillis&gt;499)
}//off500ms()

void off2s(){
  static long stateMillis;//timer for this state
  enter(&amp;stateMillis);//update timer
  digitalWrite(LEDPIN, LOW);
  if(stateMillis&gt;1999){//check if time is up
    leave(on500ms, &amp;stateMillis);
  }//if(stateMillis&gt;499)
}//off2s()

void on500ms(){
  static long stateMillis;//timer for this state
  enter(&amp;stateMillis);//update timer
  digitalWrite(LEDPIN, HIGH);
  if(stateMillis &gt;499){//time is up
    if(++counter1==6){//number of blinks
      leave(off2s, &amp;stateMillis);
      counter1=0;//reset counter
    }else{//if(++counter1==6)
      leave(off500ms, &amp;stateMillis);
    }//if(++counter1==6)
  }//if(stateMills&gt;499)
}//on500ms

void setup(){
  pinMode(LEDPIN, OUTPUT);
  state = on500ms;//set initial state
}/setup()

void loop(){
  state();//start FSM
}//loop  
</code></pre>
",0
13783205,3172075,0,"<p>You can try this:</p>

<pre><code>void strrev(char *in, char *out, int len){
    int i;

    for(i = 0; i &lt; len; i++){
        out[len - i - 1] = in[i];
    }
}
</code></pre>

<p>Note that it doesn't deal with the string terminator.</p>
",0
18731602,18731362,3,"<p>Let's start with the basics.  Compiling your code with GCC with the <code>-Wall</code> option:</p>

<pre><code>$ gcc fifo.c -o fifo -Wall
fifo.c: In function ¡®do_child¡¯:
fifo.c:33: warning: implicit declaration of function ¡®read¡¯
fifo.c:24: warning: unused variable ¡®i¡¯
fifo.c:23: warning: unused variable ¡®buffer¡¯
fifo.c: In function ¡®main¡¯:
fifo.c:48: warning: implicit declaration of function ¡®mkfifo¡¯
fifo.c:58: warning: implicit declaration of function ¡®fork¡¯
fifo.c:88: warning: implicit declaration of function ¡®write¡¯
fifo.c:42: warning: unused variable ¡®i¡¯
fifo.c:42: warning: unused variable ¡®ch¡¯
fifo.c:41: warning: unused variable ¡®buffer¡¯
fifo.c:92: warning: control reaches end of non-void function
</code></pre>

<p>Ignoring all of the unused variables problems, you need to include <code>&lt;unistd.h&gt;</code> and <code>&lt;sys/stat.h&gt;</code> to get proper declarations of <code>read</code>, <code>mkfifo</code>, <code>fork</code>, and <code>write</code>.  Compiling again:</p>

<pre><code>$ gcc fifo.c -o fifo -Wall -Wno-unused
fifo.c: In function ¡®do_child¡¯:
fifo.c:35: error: incompatible type for argument 2 of ¡®read¡¯
fifo.c: In function ¡®main¡¯:
fifo.c:94: warning: control reaches end of non-void function
</code></pre>

<p>You're passing a <code>student</code> instance as parameter 2 to <code>read</code>, but it expects a <code>void*</code> pointer.  You need to pass the <em>address</em> of the <code>student</code> instance as <code>&amp;child</code>.  Also, it would be good to explicitly return a value form <code>main()</code>, although that's not strictly necessary, since failing to return a value form <code>main()</code> implicitly returns 0 (but <em>only</em> for the <code>main()</code> function).</p>

<p>But even with those errors corrected, you still see the output of the parent process twice.  Why?  Because both the parent and the child processes are executing the code block below the switch statement.  The child process calls the <code>do_child()</code> function and never exits, so it returns and continues executing.</p>

<p>The simple fix to that is make sure to exit the child process, either at the end of <code>do_child()</code>, or immediately after the call returns, e.g.</p>
",5
20766446,3989790,2,"<pre><code>#include&lt;stdio.h&gt;
#define RESET 0
#define ON 1

main()
{
  int i,wnum=0,c,wc[50];
  int count=0,state;
  state=RESET;
  for(i=0;i&lt;50;++i)
    wc[i]=0;
  /*Populating the array with character counts of the typed words*/
  while((c=getchar())!=EOF)
    {
      if(c=='\n'||c=='\t'||c==' '||c=='""')
    {
      if(state!=RESET)
        state=RESET;
    }
      else if((c&gt;=65&amp;&amp;c&lt;=90)||(c&gt;=97&amp;&amp;c&lt;=122))
    {
      if(state==RESET)
        {
          count=RESET;
          ++wnum;
          state=ON;
        }
      ++count;
      wc[wnum-1]=count;
    }
    }
  c=RESET;

  /*Finding the character count of the longest word*/
  for(i=0;i&lt;wnum;++i)
    {
      if(c&lt;wc[i])
    c=wc[i];
    }

  /*Printing the Histogram Finally*/ 
 for(i=c;i&gt;0;--i)
    {
      for(count=0;count&lt;wnum;++count)
    {
      if(wc[count]-i&lt;0)
        printf(""  "");
      else printf(""x "");
    }
      printf(""\n"");
    }
}
</code></pre>

<p><strong>VERTICAL ORIENTATION:</strong> Using only the tools we learned so far in the book. And you can change the array size, wc[50]. I kept the code valid for 50 words.
Horizontal orientation should be quite simpler. I didn't try it though.</p>
",0
9159640,9159573,1,"<p><code>2**24-1</code> is <code>16777215</code> (here, I've used <code>**</code> for the exponentiation).</p>

<p><code>0xFFFFFF</code> is also <code>16777215</code>.</p>

<p>In other words, they are two ways of writing the same value.</p>

<p>When you <code>AND</code> something with <code>0xFFFFFF</code>, you are keeping the 24 least-significant bits, and setting the rest to zero.</p>
",1
9159644,9159573,2,"<p>Masking with <code>0xffffff</code> only makes sure that the value that is stored never is outside the 0..2^24-1 range. Anything but the lower 24 bits are discarded.</p>

<p>If you for example have the value <code>-1</code> and mask it, it will end up as the value <code>0xffffff</code>. The value has changed, but now it's inside the valid range.</p>
",0
9851689,9851672,5,"<p>It's because <code>histogram[c] = 0</code> writes past the <code>histogram</code> memory when <code>c = 50</code>. So essentially <code>histogram[50]</code> overwrites c and makes it 0.</p>

<p>This happens because arrays start from <code>0</code> in C. So <strong>the last valid index in a 50-element array is 49</strong>.</p>

<p>Technically, while interesting and exploitable you can't rely on this. It's a manifestation of undefined behavior. The memory could easily have another layout causing things to ""just work"" or do something funnier.</p>
",0
9851700,9851672,1,"<p><code>histogram</code> has 50 elements: from index 0 to index 49.<br>
You attempt to write to index 50. <strong>ALL BETS ARE OFF</strong></p>

<p>do</p>

<pre><code>while (c &lt; 50)
</code></pre>

<p>or, to avoid <em>magic constants</em></p>

<pre><code>while (c &lt; sizeof histogram / sizeof *histogram)
</code></pre>
",4
9851742,9851672,0,"<p>You are accessing elements 0 to 50 in histogram, which only contains elements 0 to 49 (C/C++ use zero-indexing, so the maximum element of an array will always be size-1).</p>

<p>To avoid errors like this, you could define the histogram size as a constant, and use that for all operations relating to the histogram array:</p>

<pre><code>#define HISTOGRAM_SIZE 50
</code></pre>

<p>Or (only works for C99 or C++, see below comment):</p>

<pre><code>const int HISTOGRAM_SIZE = 50;
</code></pre>

<p>Then:</p>

<pre><code>int histogram[HISTOGRAM_SIZE];
</code></pre>

<p>And:</p>

<pre><code>while(c&lt;HISTOGRAM_SIZE)
</code></pre>

<p>'#define' is a C-preprocessor statement, and will be processed  before compilation. To the compiler, it will just look as if you've written 50 everywhere where HISTOGRAM_SIZE is used, so you wont get any extra overhead.</p>

<p>'const int' gives you a similar solution, which in many cases will give the same result as with the define (I'm not 100% certain under which circumstances though, others are free to elaborate), but will also give you the added bonus of type-checking.</p>
",1
17799756,5574914,7,"<p><code>srand( (unsigned) time(NULL) * getpid());</code></p>

<p>yields a more diverse random set (on OSX 10.8), including on short cycle tests.</p>
",1
11844048,5459236,1,"<pre><code> #include &lt;time.h&gt;
 #include &lt;stdio.h&gt;

 int main(void)
  {
     // get the current time
     time_t now = time(0);
     struct tm* theTime = localtime(&amp;now);
     int t=(int)theTime;
     printf(""%d"",t);
     getch();
     return 0;
  }
</code></pre>

<p>it works</p>
",0
10746913,10746759,-2,"<p>Your compiler is helping you out by freeing the allocated memory (assuming that the optimized version of your code even gets around to doing the malloc) when it realizes that you aren't using it.  You might try printing out the value of the pointer (printf(""0x%x"", ptr);) - I suspect you'll be getting repeating values.  A more reliable check would write a known bitstring into memory, having already looked to see if the allocated memory already contains that string.  In other words, instead of writing i, write 0xdeadbeef0cabba6e over and over again, after checking to see if that bit pattern is already in the space you have allocated.</p>
",3
10746958,10746759,2,"<p>rss and %mem are both in terms of ""physical memory being used by the process at the moment"". It has plenty of opportunity to page stuff out. Try adding vsz. I bet that grows as you expect.</p>
",1
10746962,10746759,5,"<p>You probably built very optimized.</p>

<p>On most modern systems gcc knows that malloc returns a non-aliased pointer. That is to say, it will never return the same pointer twice and it will never return a pointer you have saved 'live' somewhere else.</p>

<p>I find this very very hard to imagine, but it is possible that malloc is being called once and its return value being used over and over.  The reasons being:</p>

<p>It knows your memory is a dead store. ie: you write to it, but it never gets read from. The pointer is known to not be aliased so it hasn't escaped to be read from somewhere else, and it isn't marked volatile.  Your for loop itself /could/ get thrown away.</p>

<p>At that point it could just use the same memory over and over.</p>

<p>Now here is why I find it hard to believe: Just how much does gcc know about malloc?  Malloc could have any kind of side effects like incrementing a global 'number of times called' to 'paints my room a random shade of blue'.   It seems really weird that it would drop the call and assume it to be side-effect-free.  Hell, 'malloc' could be implemented to return NULL every 100th call (maybe not quite to spec, but who is to say).</p>

<p>What it is NOT doing is freeing it on your behalf.   That goes beyond what it 'could' know and into the territory of 'doing things it's just not allowed to'.  You're allowed to leak memory, lame though it may be.</p>

<p>2 things would be useful here:
1) Compile environmenet: which os, compiler, and command line flags.</p>

<p>and 2) disassembly of the final binary.  (objdump or from the compiler)</p>
",1
10130069,10130041,5,"<p>If you need to call the calculator function more than once, then you only need to decide which function to call once, and then call it as many times as you need.</p>

<pre><code>if (something) {
    ptrFunc = Plus;
} else {
    ptrFunc = Minus;
}

c = ptrFunc(a, b);
z = ptrFunc(x, y);
</code></pre>
",0
10130082,10130041,4,"<p>He doesn't want you to <em>replace</em> it, he wants you to write one to choose the right operation:</p>

<pre><code>float (*ptrFunc)(float, float);
switch (something)
{ 
  case 1: 
    ptrFunc = Plus;
    break;

     .
     .
     .
}
</code></pre>
",0
10130109,10130041,2,"<p>Consider something like this:</p>

<pre><code>typedef float (*op)(float a, float b);

typedef struct { 
   char name;
   op implementation;
} operation;

operation ops[] = {
    { '+', Plus},
    { '-', Minus},
    { '*', Multiply},
    { '/', Divide}
};
</code></pre>

<p>As you read your input, you find the <code>ops[n].name</code> that matches the operator you got from the input, and call <code>ops[n].implementation</code>.</p>
",1
10750187,10750175,10,"<p>It means ""read at most 64 characters or stop when reaching a newline, whichever comes first"". It's specified by the standard so all standard libraries have to support it.</p>

<blockquote>
  <p>C11 7.21.6.2</p>
  
  <p><code>[</code> Matches a nonempty sequence of characters from a set of expected
  characters (the scanset).
  [...]
  The conversion specifier includes all subsequent characters in the
  format string, up to and including the matching right bracket (]).</p>
  
  <p>The characters between the brackets (the scanlist) compose the
  scanset, unless the character after the left bracket is a circumflex
  (^), in which case the scanset <strong>contains all characters that do not
  appear in the scanlist</strong> between the circumflex and the right bracket.</p>
</blockquote>

<p>As noted in the comments, a matching <code>]</code> is probably required to delimit the scanlist. <strong>An <code>s</code> specifier is not required</strong>.</p>
",7
20020790,20020081,0,"<p>Regarding: <em>Does anyone have any ideas of how I could determine the root notes of these chords fairly cheaply</em>...</p>

<p><strong><em>It looks as if the answers given</em></strong> have already satisfied the need, but I just wanted to offer another perspective, in the event you ever need to expand this to some general application...  </p>

<p><strong><em>An FFT (Fast Fourier Transform) or DFT (Discrete Fourier Transform)</em></strong> could also resolve a collection of frequencies (eg. a chord) into its fundamental frequencies, allowing you to select the root note, or any other component.  </p>

<p>There are many implementations, but I have found <strong><em><a href=""http://www.fftw.org/"" rel=""nofollow noreferrer"">this one</a></em></strong> particularly useful. It is open source.  There are many examples of how to use FFT/DFT, including <strong><em><a href=""https://stackoverflow.com/questions/4675457/how-to-generate-the-audio-spectrum-using-fft-in-c"">this one</a></em></strong>, and <strong><em><a href=""http://www.drdobbs.com/cpp/a-simple-and-efficient-fft-implementatio/199500857"" rel=""nofollow noreferrer"">this implementation disscussion</a></em></strong>.</p>
",3
13416111,13416025,3,"<p>Yes. Raw pointer is 32 bits of data (or 16 or 64 bits, depending on architecture), and does not contain anything else. Whether it's <code>int *</code>, <code>char *</code>, <code>struct sockaddr_in *</code> is just information for compiler, to know what is the number to actually add when incrementing, and for the type it's going to have when you dereference it.</p>
",0
13416112,13416025,13,"<p>It is indeed syntactic sugar. Consider the following code fragment:</p>

<pre><code>int t[2];
int a = t[1];
</code></pre>

<p>The second line is equivalent to:</p>

<pre><code>int a = *(t + 1); // pointer addition
</code></pre>

<p>which itself is equivalent to:</p>

<pre><code>int a = *(int*)((char*)t + 1 * sizeof(int)); // integer addition
</code></pre>

<p>After the compiler has checked the types it drops the casts and works only with addresses, lengths and integer addition.</p>
",4
13416120,13416025,18,"<p>You might be confused by compile time versus run time.</p>

<p>During compilation, <code>gcc</code> (or any C compiler) knows the type of a pointer, in particular knows the type of the data pointed by that pointer variable. So <code>gcc</code>can emit the right machine code. So an increment of a <code>int *</code> variable (on a 32 bits machine having 32 bits <code>int</code>) is translated to an increment of 4 (bytes), while an increment of a <code>char*</code> variable is translated to an increment of 1.</p>

<p>During runtime, the compiled executable (it does not care or need <code>gcc</code>) is only dealing with machine pointers, usually addresses of bytes (or of the start of some word).</p>

<p>Types (in <em>C</em> programs) are not known during runtime.</p>

<p><sup>Some other languages (Lisp, Python, Javascript, ....) require the types to be known at runtime. In recent C++ (but not C) some objects (those having virtual functions) may have <a href=""http://en.wikipedia.org/wiki/Run-time_type_information"" rel=""nofollow"">RTTI</a>.</sup></p>
",0
13416128,13416025,2,"<p>It's exactly as you say in the end - types in C are just a compile-time concept that tells to the compiler how to generate the code for the various operations you can perform on variables.</p>

<p>In the end pointers just boil down to the address they point to, the semantic information doesn't exist anymore once the code is compiled. </p>
",0
13416178,13416025,3,"<p>Your hypothesis is correct: to see how different kinds of pointer are handled, try running this program:</p>

<pre><code>int main()
{
    char * pc = 0;
    int * pi = 0;

    printf(""%p\n"", pc + 1);
    printf(""%p\n"", pi + 1);

    return 0;
}
</code></pre>

<p>You will note that adding one to a char* increased its numeric value by 1, while doing the same to the int* increased by 4 (which is the size of an int on my machine).</p>
",2
13416101,13416025,1,"<p>Incrementing an int* pointer is different from a incrementing char* solely because the pointer variable is declared as int*. You can cast an int* to char* and then it will increment with 1 byte.</p>

<p>So, yes, it is all just syntactic sugar. It makes some kinds of array processing easier and confuses void* users.</p>
",0
9138400,9138374,0,"<pre><code>result = strtok( str, delims );
while( result != NULL ) {
    printf( ""result is \""%s\""\n"", result );
    result = strtok( NULL, delims );
}
</code></pre>

<p>Set delims as your delimiter</p>
",0
9138401,9138374,0,"<p>You should use either <code>strtok</code> or <code>strtok_r</code>, both of which are described <a href=""http://pubs.opengroup.org/onlinepubs/009604599/functions/strtok.html"" rel=""nofollow"">here</a> (with examples).  I'd recommended to use <code>strtok_r</code>, since <code>strtok</code> is thread-unsafe, and you may add threads to your application in the future.</p>
",0
11843388,11843340,1,"<p>This is just casting of the return value of the function to <code>unsigned int</code>.</p>

<p>It is just like:</p>

<pre><code>pthread_t pthread_self_result;
pthread_self_result = pthread_self();
printf(""[Child]  child thread id: 0x%x\n"", (unsigned int)pthread_self_result);
</code></pre>
",2
11843392,11843340,1,"<p>The parentheses are casting the return value of <code>pthread_self</code> to <code>unsigned int</code>.  <code>pthread_self</code> returns <code>pthread_t</code>, which is an unspecified arithmetic type that is not appropriate for use with <code>printf</code>.</p>
",2
11843394,11843340,2,"<p>The return value of <code>pthread_self()</code> is a <code>pthread_t</code> (see <a href=""http://linux.die.net/man/3/pthread_self"" rel=""nofollow""><code>man pthread_self</code></a>). </p>

<p><code>(unsigned int) pthread_self()</code> is used to cast the return value of <code>pthread_self()</code> into an unsigned integer.</p>

<p>For more information about casting in C see <a href=""http://www.aui.ma/personal/~O.Iraqi/csc1401/casting.htm"" rel=""nofollow"">http://www.aui.ma/personal/~O.Iraqi/csc1401/casting.htm</a></p>
",1
11843406,11843340,1,"<p>This is what is called in C a ""type cast""
Here we cast the pthread_t type into an unsigned int to print it.
Please refer to your C language manual</p>
",1
13460095,13460072,2,"<p>What you are doing is not OK since <code>myFunction</code> doesn't change the value <code>myArray</code> holds in main; it merely changes its own copy.</p>

<p>Other than that, it's OK even if stylistically debatable.</p>
",0
13460115,13460072,3,"<p>Simple answer is no.</p>

<p>You are not passing back the pointer.</p>

<p>use</p>

<pre><code>int main(void) {
    double *myArray;
    ...
    myFunction(&amp;myArray);
    ...
    /* save myArray contents to file */
    ...
    free(myArray);
    ...
    return 0;
}

int myFunction(double **myArray) {
    int len=0;
    ...
    /* compute len */
    ...
    *myArray = malloc( sizeof(double) * len );
    if (NULL == *myArray) 
      exit(1);
    ...
</code></pre>

<p><strong>EDIT</strong></p>

<pre><code>    poputateThis = *myArray;

    /* populate poputateThis */
</code></pre>

<p><strong>END OF EDIT</strong></p>

<pre><code>    ...
    return 0;
</code></pre>

<p><strong>EDIT</strong></p>

<p>Should simplify thigs for your
    }</p>
",9
13460146,13460072,2,"<p>As a question of good design and practice (apart from syntax issues pointed out in other answers) this is okay as long as it is consistent with your code base's best practices and transparent.  Your function should be documented so that the caller knows it has to free and furthermore knows not to allocate its own memory.  Furthermore consider making an abstract data type such as:</p>

<pre><code>// myarray.h
   struct myarray_t;
   int myarray_init(myarray_t* array); //int for return code
   int myarray_cleanup(myarray_t* array); // will clean up
</code></pre>

<p><code>myarray_t</code> will hold a dynamic pointer that will be encapsulated from the calling function, although in the <code>init</code> and <code>cleanup</code> functions it will respectively allocate and deallocate.</p>
",5
13460184,13460072,1,"<p>What you want to do is fine, but your code doesn't do it -- <code>main</code> never gets to see the allocated memory. The parameter <code>myArray</code> of <code>myFunction</code> is initialized with the value passed in the function call, but modifying it thereafter doesn't modify the otherwise-unrelated variable of the same name in <code>main</code>.</p>

<p>It appears in your code snippet that <code>myFunction</code> always returns <code>0</code>. If so then the most obvious way to fix your code is to return <code>myArray</code> instead (and take no parameter). Then the call in <code>main</code> would look like <code>myArray = myFunction();</code>.</p>

<p>If <code>myFunction</code> in fact already uses its return value then you can pass in a <em>pointer</em> to <code>double*</code>, and write the address to the referand of that pointer. This is what Ed Heal's answer does. The <code>double **</code> parameter is often called an ""out-param"", since it's a pointer to a location that the function uses to store its output. In this case, the output is the address of the buffer.</p>

<p>An alternative would be to do something like this:</p>

<pre><code>size_t myFunction(double *myArray, size_t buf_len) {
    int len=0;
    ...
    /* compute len */
    ...
    if (buf_len &lt; len) {
        return len;
    }
    /* populate myArray */
    ...
    return len;
}
</code></pre>

<p>Then the callers have the freedom to allocate memory any way they like. Typical calling code might look like this:</p>

<pre><code>size_t len = myFunction(NULL, 0);
// warning -- watch the case where len == 0, if that is possible
double *myArray = malloc(len * sizeof(*myArray));
if (!myArray) exit(1);
myFunction(myArray, len);
...
free(myArray);
</code></pre>

<p>What you've gained is that the caller can allocate the memory from anywhere that's convenient. What you've lost is that the caller has to write more code.</p>

<p>For an example of how to use that freedom, a caller could write:</p>

<pre><code>#define SMALLSIZE 10;

void one_of_several_jobs() {
    // doesn't usually require much space, occasionally does
    double smallbuf[SMALLSIZE];
    double *buf = 0;

    size_t len = myFunction(smallbuf, SMALLSIZE);
    if (len &gt; SMALLSIZE) {
        double *buf = malloc(len * sizeof(*buf));
        if (!buf) {
            puts(""this job is too big, skipping it and moving to the next one"");
            return;
        }
    } else {
        buf = smallbuf;
    }

    // use buf and len for something
    ...

    if (buf != smallbuf) free(buf);
}
</code></pre>

<p>It's usually an unnecessary optimization to avoid a <code>malloc</code> in the common case where only a small buffer is needed -- this is only one example of why the caller might want a say in how the memory is allocated. A more pressing reason might be that your function is compiled into a different dll from the caller's function, perhaps using a different compiler, and the two don't use compatible implementations of <code>malloc/free</code>.</p>
",0
10139907,10139892,1,"<p>Multiple changes of variables without an intervening sequence point is undefined behaviour.</p>

<p>This means that there is no definition in the specification for what should happen. The compiler is allowed freely to do whatever it wants -- anything at all.</p>

<p>Sequence points are only present at <code>;</code>, <code>&amp;&amp;</code>, <code>||</code>, <code>?</code> and <code>:</code> in the ternary operator, and <code>,</code> (the comma operator, not to be confused with the comma separating arguments in a function call).</p>
",4
10139909,10139892,1,"<p>You are modifying the same variable more than once without an intervening sequence point, this is <strong>Undefined Behavior</strong>.<br>
An Undefined behavior simply means that there may or may not be any feasible explanation to the behavior of the program.</p>

<p>Good Read:<br>
<a href=""https://stackoverflow.com/questions/4176328/undefined-behavior-and-sequence-points"">Undefined behavior and sequence points</a></p>
",0
11821773,11821756,1,"<pre><code>pid_t getpid(void)
</code></pre>

<p>this means the function named <code>getpid</code> doesn't take any parameters (as the argument list contains only <code>void</code>) and returns a value of type <code>pid_t</code> (so you were correct with the type specifier).</p>

<p>Any basic book/tutorial on C would give you this information, I recommend you work through some of this on your own to get the basics down.</p>

<p>This SO question might be helpful: <a href=""https://stackoverflow.com/questions/562303/the-definitive-c-book-guide-and-list"">The Definitive C Book Guide and List</a></p>
",3
11821775,11821756,2,"<p>You're right that <code>pid_t</code> is a type identifier, but it's not a variable. <code>pid_t</code> is the return type of the function <code>getpid()</code>. </p>

<p>Every function in C has a return type. Functions are declared like this:<br />
<code>returntype functionName(arguments)</code></p>

<p>For example, <code>int main(int argc, const char * argv[])</code> returns an <code>int</code> and takes two arguments. </p>
",5
8737472,8737456,3,"<p>Well, no. When you complement 1, you go just invert the bits:</p>

<pre><code> 1  ==  0b00000001
~1  ==  0b11111110
</code></pre>

<p>And that's -2 in two's complement, which is the way your computer internally represents negative numbers. See <a href=""http://en.wikipedia.org/wiki/Two%27s_complement"" rel=""nofollow"">http://en.wikipedia.org/wiki/Two's_complement</a> but here are some examples:</p>

<pre><code>-1  ==  0b11111111
-2  ==  0b11111110
 ....
-128==  0b10000000
+127==  0b01111111
 ....
+2  ==  0b00000010
+1  ==  0b00000001
 0  ==  0b00000000
</code></pre>
",0
8737511,8737456,1,"<p>Whar do you mean ""when I complement 1 (~1),"" ?  There is what is called <em>Ones-complement</em>, and there is what is called <em>Twos-Complement</em>.  Twos-Complement is more common (it is used on most computers) as it allows negative numbers to be added and subtracted using the same algorithm as postive numbers.  </p>

<p>Twos-Complement is created by taking the binary representation of the postive number and switching every bit from 1 to 0 and from 0 to 1, and then adding one</p>

<pre><code> 5   0000 0101  
 4   0000 0100   
 3   0000 0011  
 2   0000 0010  
 1   0000 0001  
 0   0000 0000  
-1   1111 1111  
-2   1111 1110  
-3   1111 1101  
-4   1111 1100 
-5   1111 1011 
etc.
</code></pre>
",1
9216861,9216468,2,"<p>Something like this, not fully tested, may have limit problems. Only works if stack pointer decreases by PUSHING, so this is not portable across all hardware...</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define STK_CNT 65536

size_t STK_fill()
{
    volatile size_t i, cnt = 0;

    volatile u_int32_t fill[STK_CNT];

    for(i = 0; i &lt; STK_CNT; i++)
    {
        fill[i] = 0xDEADBEEFUL;
    }

    return cnt;
}

size_t STK_find()
{
    volatile size_t i, cnt = 0;

    volatile u_int32_t fill[STK_CNT];

    for(i = 0; i &lt; STK_CNT; i++)
    {
        if(fill[i] == 0xDEADBEEFUL)
        {
            cnt++;
        }else{
            break;
        }
    }

    return ((STK_CNT - cnt) * 4);
}

void victim(char *po_str, const char *pi_str)
{
    char str[1024];

    strcpy(str, ""stk_TEST_"");
    strcat(str, pi_str);
    strcat(str, ""_stk_TEST"");

    strcpy(po_str, str);
}

int main()
{
    int  temp;
    int  used;
    char str[4096] = {0};

    temp = (int)STK_fill();
    victim(str, ""STK_tst_STK_tst_STK_tst_STK_tst_STK_tst_STK_tst_STK_tst_STK"");
    used = (int)STK_find();

    printf(""VICTIM function used %d bytes of stack\n"", used);

    return 0;
}
</code></pre>
",4
9216590,9216468,0,"<p>I think your method is the most reliable way to do it.</p>

<p>An alternative might be to use the fact that modern OSes tend to grow the stack (i.e. commit memory to it) as needed. See <a href=""https://stackoverflow.com/questions/8203110/will-the-stack-of-a-c-program-ever-shrink"">Will the stack of a C program ever shrink?</a> Perhaps, having called this function, you could interrogate the OS about the amount of memory committed to the stack. This is, of course, OS-specific, might be architecture-specific, and on the whole is likely to be a lot more fiddly than the first approach.</p>
",1
11543552,4085372,8,"<p>To programmers just starting out, the concept of a ""stack"" or the ""heap"" might be a little confusing, especially if you have started programming in a higher level language like Ruby, Java, Python, etc.</p>

<p>Consider:</p>

<pre><code>char **get_me_some_strings() {
  char *ary[] = {""ABC"", ""BCD"", NULL};
  return ary;
}
</code></pre>

<p>The compiler will rightfully issue a complaint about trying to return address of a local variable, and you will most certainly get a segmentation fault trying to use the returned pointer. </p>

<p>and:</p>

<pre><code>char **get_me_some_strings() {
  char *ary[] = {""ABC"", ""BCD"", NULL};
  char **strings = ary;
  return strings;
}
</code></pre>

<p>will shut the compiler up, while still getting the same nasty segmentation fault.</p>

<p>To keep everyone but the zealots happy, you would do something a little more elaborate:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

char **get_me_some_strings() {
  char *ary[] = { ""ABC"", ""BCD"", NULL };
  char **strings = ary; // a pointer to a pointer, for easy iteration
  char **to_be_returned = malloc(sizeof(char*) * 3);
  int i = 0;
  while(*strings) {
    to_be_returned[i] = malloc( sizeof(char) * strlen( *strings ) );
    strcpy( to_be_returned[i++], *strings);
    strings++;
  }
  return to_be_returned;
}
</code></pre>

<p>now use it:</p>

<pre><code>void i_need_me_some_strings() {
  char **strings = get_me_some_strings();
  while(*strings) {
    printf(""a fine string that says: %s"", *strings);
    strings++;
  }
}
</code></pre>

<p>Just remember to free the allocated memory when you are done, cuz nobody will do it for you. That goes for all the pointers, not just the pointer to the pointers! (i think).</p>

<p>To make more sense of it all, you might also want to read this: <a href=""https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap"">What and where are the stack and heap?</a></p>
",2
17404095,17404024,2,"<p>You can do it indirectly through <code>const</code> pointers, at least:</p>

<pre><code>typedef struct  {
  int answer;
} state;

const state * state_init(void)
{
  static state st;

  st.answer = 42;  /* Pretend this has to be done at run-time. */

  return &amp;st;
}

int main(void)
{
  const state *st = state_init();
  printf(""the answer is %d, and it's constant\n"","" st-&gt;answer);
}
</code></pre>

<p>This way, all <code>main()</code> has is a <code>const</code> pointer to some <code>state</code> which it cannot modify.</p>
",0
17404100,17404024,0,"<p>The only way I can think of is if you read your value as a non constant and then call a function which take a constant value and pass your variable to it. Inside the function you make all the wished operations.</p>
",0
17404229,17404024,2,"<p>A constant global should work, yes?</p>

<pre><code>const int val = 3; // Set before main starts
                   // const, so it will never change.

int main(void)
{
    printf(""%d\n"", val);  // using val in code
}
</code></pre>

<hr>

<p>However, if the value isn't known at compile-time, you can set it at run-time this way:</p>

<pre><code>const int const* g_pVal;

int main(void)
{
    static const int val = initialize_value();

    g_pVal = &amp;val;

    printf(""%d\n"", *g_pVal);
}
</code></pre>
",2
10807835,10807807,1,"<p>Fix the logic of your while loop.  You update <code>minScore</code> before checking to see whether <code>examScore</code> is -999, so that's not good.</p>

<p>Also you should initialize variables like <code>examScore</code> before using them, and you should NOT do exact comparisons like <code>examScore != -999</code> with floats.  Either change to ints or do a more forgiving comparison like <code>examScore &lt; -998</code>.</p>
",1
10807858,10807807,0,"<p>The problem with that code is that when the user enters -999 it processes that as a test score. The loop needs to be restructured so that it breaks immediately after user input.</p>
",0
10807861,10807807,1,"<p>Consider the following program.  Will <code>do_stuff</code> be called?</p>

<pre><code>int foo;
while (foo != 5) {
   foo = 5;
   do_stuff();
}
</code></pre>

<p>Actually the behavior is undefined because <code>foo</code> is tested before it's initialized.  Your code has the same problem, with <code>examScore</code>.  Since this is homework, this is just a hint - how would you fix the simple program above?</p>
",0
10807879,10807807,0,"<p>Like everyone else said you do your check for <code>-999</code> after you process that score. Also I assume you should only update the <code>minScore</code> whenever the current exam is lower so you should have something like:</p>

<pre><code>if(maxScore &lt; examScore)
{
    maxScore = examScore;
}

if(minScore &gt; examScore)
{
   minScore = examScore;
}
</code></pre>

<p>Finally you should initialize all your variables before using them.</p>

<p>EDIT:</p>

<pre><code>while(...) 
   printf(""Enter an exam score (enter -999 to quit score input):\n"");
   scanf(""%f"", &amp;examScore);
   printf(""The score you've entered equates to : %.2f\n\n"", examScore);

   if(examScore &lt; 0 || examScore &gt; 100)
   {
       printf(""Exam Scores range from 0.0 - 100.0\n"");
       continue; //goes back to the top of the loop skipping everything else
   } 
   //At this point you know the score is valid so you can process it
   scoreCount++;

   if(maxScore &lt; examScore)
   {
       maxScore = examScore;
   }
   if(minScore &gt; examScore)
   {
      minScore = examScore;
   }
   sumScore += examScore;
   avgScore = sumScore / scoreCount;
}
</code></pre>

<p>If it's not in a loop or you don't want to use <code>continue</code> you can simply put everything else (all the processing stuff) in an <code>else</code> block after the validity check.</p>
",11
10809349,10807807,0,"<p>There's a logical error besides the values without <code>init</code> and compare tow float directly problems.
In your case 1 while loop, you need determine if the user input meet the terminate condition first, then to process it. Also the <code>minScore</code> need a comparison before assignment, just like what twain249 said.</p>
",0
18374515,5779686,0,"<p>Checkout:</p>

<p><a href=""http://www.raspberrypi.org/phpBB3/viewtopic.php?f=38&amp;t=52934"" rel=""nofollow"">http://www.raspberrypi.org/phpBB3/viewtopic.php?f=38&amp;t=52934</a></p>

<p>they use netcat to handle the socket/network stuff... </p>
",0
11811836,11811828,8,"<p>No. Variadic functions must have one or more named parameters.</p>

<p>Try it yourself, you'll see something like:</p>

<blockquote>
  <p>error: ISO C requires a named argument before '...'</p>
</blockquote>
",0
8732050,4988587,1,"<p>This is more than what you need. Go though the code and it will help you.</p>

<p><a href=""http://sourceforge.net/projects/c-cpp-calender/"" rel=""nofollow"">http://sourceforge.net/projects/c-cpp-calender/</a></p>
",0
19440100,19440061,0,"<p>This sounds like undefined behaviour.</p>

<p>You never initialise <code>phonebook.contacts_length</code>.  It could have any value.  When you go to add an entry, it's quite possible that the <code>realloc</code> call fails.  You don't check the return value, so you wouldn't know.</p>

<p>Bad juju.</p>
",4
11051485,11051346,0,"<p>I suppose if you had a 64 bit machine with a lot of swap space, you could just declare an array of size 10^13 and it may work.</p>

<p>But for a data set of this size it becomes important to consider carefully the nature of the problem.  Do you really need random access read and write operations for all 10^13 elements?  Is the array at all sparse?  Could you express this as a map/reduce problem?  If so, sequential access to 10^13 elements is much more practical than random access.</p>
",0
11051532,11051346,3,"<p>A <code>float</code> in C occupies 4 bytes (assuming IEEE floating point arithmetic, which is pretty close to universal nowadays). That means 10<sup>13</sup> elements are na?vely going to require  4&times;10<sup>13</sup> bytes of space. That's quite a bit (40 TB, a.k.a. quite a lot of disk for a desktop system, and rather more than most people can afford when it comes to RAM) so you need to find another approach.</p>

<p>Is the data sparse (i.e., mostly zeroes)? If it is, you can try using a hash table or tree to store only the values which are anything else; if your data is sufficiently sparse, that'll let you fit everything in. Also be aware that processing 10<sup>13</sup> elements will take a very long time. Even if you could process a billion items a second (very fast, even now) it would still take 10<sup>4</sup> seconds (several hours) and I'd be willing to bet that in any non-trivial situation you'll not be able to get anything near that speed. Can you find some way to make not just the data storage sparse but also the processing, so that you can leave that massive bulk of zeroes alone?</p>

<p>Of course, if the data is non-sparse then you're doomed. In that case, you might need to find a smaller, more tractable problem instead.</p>
",0
9809018,9808962,4,"<p>Your code seems to have been cut off. But your problem is with this logic:</p>

<pre><code>while (lastTime == (lastTime = something))
</code></pre>

<p>The test will always be true; you assign some value to lastTime, then compare it with itself.</p>
",1
9809070,9808962,0,"<p>This line won't work as you might expect (I've added the closing brackets cause they were missing above):</p>

<pre><code>while(lastTime == (lastTime = (double)clock() / (double)CLOCKS_PER_S))
</code></pre>

<p>Due to the brackets the right side of the comparison (the assignment) is evaluated first, essentially resulting in this:</p>

<pre><code>while(lastTime == lastTime)
</code></pre>

<p>Which essentially leads to <code>while(0 == 0)</code>, which is obviously <code>while(true)</code>.</p>

<p>You'll need at least a second variable to hold the previous value. Then just add an extra case for when <code>lastTime == 0</code> (i.e. the first time the loop is run).</p>

<hr>

<p>Also, as mentioned in a comment above, you shouldn't compare the value as it's not that easy for two double values to be exactly the same (esp. when calculated).</p>

<p>If you'd like to do some action every x milliseconds (or any other time), you should use a counter to add up the time passed:</p>

<pre><code>for(clock_t timeSkipped = 0, lastTick = clock() ; ; timeSkipped += clock() - lastTick, lastTick = clock()) {
    while(timeSkipped &gt; 0.5 * CLOCKS_PER_S) { // example: this will run the content of this loop at a fixed time step of once every half second
        timeSkipped -= 0.5 * CLOCKS_PER_S;
        printf(""Tick!"");
    }
</code></pre>

<p>}</p>
",0
8789479,8789444,1,"<p>No, they are not the same.</p>

<ul>
<li><code>int **p</code> is a pointer to a pointer to <code>int</code>.</li>
<li><code>int *p[1]</code> is an array (of length 1) of pointers to <code>int</code>.</li>
</ul>
",0
8789487,8789444,1,"<p>They are not same:</p>

<pre><code>int **p    
</code></pre>

<p>Is a pointer which points to another pointer whose type is <code>int *</code></p>

<p>while,   </p>

<pre><code>int *p[1]; 
</code></pre>

<p>Is an array of size <code>1</code> to the type <code>int *</code></p>
",0
8789498,8789444,1,"<p>They are different.</p>

<pre><code>int **p
</code></pre>

<p>means a pointer to a pointer to an int.</p>

<pre><code>int *p[1]
</code></pre>

<p>means an array containing one element, with that element being a pointer to an int.</p>

<p>The second form can be treated the same as the first in some situations, e.g. by passing it to a function.</p>
",0
8789523,8789444,7,"<p>Not quite.</p>

<pre><code>int **p;
</code></pre>

<p>declares a pointer <code>p</code>, which will be used to point at objects of type <code>int *</code>, ie, pointers to int.  It doesn't allocate any storage, or point <code>p</code> at anything in particular yet.</p>

<pre><code>int *p[1];
</code></pre>

<p>declares an array <code>p</code> of one pointer to int: <code>p</code>'s type can <em>decay</em> to <code>int **</code> when it's passed around, but unlike the first statement, <code>p</code> here has an initial value and some storage is set aside.</p>

<hr>

<p>Re. the edited question on access syntax: yes, <code>*p == p[0] == *(p+0)</code> for all pointers and arrays.</p>

<hr>

<p>Re. the comment asking about <code>sizeof</code>: it deals properly with arrays where it can see the declaration, so it gives the total storage size.</p>

<pre><code>void foo()
{
    int **ptr;
    int *array[10];

    sizeof(ptr);   // just the size of the pointer
    sizeof(array); // 10 * sizeof(int *)

    // popular idiom for getting count of elements in array:
    sizeof(array)/sizeof(array[0]);
}

// this would always discard the array size,
// because the argument always decays to a pointer
size_t my_sizeof(int *p) { return sizeof(p); }
</code></pre>
",0
8789558,8789444,4,"<p>To simplify things, you could factor out one level of pointers since it's not relevant to the question.</p>

<p>The question then becomes: what's the difference between <code>T* t</code> and <code>T t[1]</code>, where <code>T</code> is some type.</p>

<p>There are several differences, but the most obvious one has to do with memory management: the latter allocates memory for a single value of type <code>T</code>, whereas the the former does not (but it does allocate memory for the pointer).</p>
",3
8791595,8789444,2,"<p>They are not the same thing, although in many cases they can <em>appear</em> to behave the same way.</p>

<p>To make the discussion below flow better, I'm going to take the liberty of renaming your variables:</p>

<pre><code>int **pp;   // pointer to pointer
int *ap[1]; // array of pointer
</code></pre>

<p>If an expression of type ""N-element array of <code>T</code>"" appears in most contexts, it will be converted to an expression of type ""pointer to <code>T</code>"" whose value is the address of the first element in the array (the exceptions to this rule are when the array expression is an operand of either the <code>sizeof</code> or unary <code>&amp;</code> operators, or is a string literal being used to initialize another array in a declaration).</p>

<p>So, suppose you write something like</p>

<pre><code>foo(ap);
</code></pre>

<p>The expression <code>ap</code> has type ""1-element array of pointer to <code>int</code>"", but by the rule above it will be converted to an expression of type ""pointer to pointer to <code>int</code>""; thus, the function <code>foo</code> will receive an argument of type <code>int **</code>, not <code>int *[1]</code>.  </p>

<p>On the other side of the equation, subscripting is defined in terms of pointer arithmetic: <code>E1[E2]</code> is defined as <code>*(E1 + E2)</code> where one of the expressions is a pointer value and the other is an integral value.  Thus you can use a subscript operator on <code>pp</code> <em>as though</em> it were an array.  This is why we can treat dynamically-allocated buffers as though they were regular arrays:</p>

<pre><code>pp = malloc(sizeof *pp * N); // allocate N pointers to int (type of *pp == int *)
if (pp)
{
  size_t i;
  for (i = 0; i &lt; N; i++)
    pp[i] = ...;             // set pp[i] to point to some int value
}
</code></pre>

<p>Now for some major differences.  First of all, array expressions may not be the target of an assignment; for example, you can't write something like</p>

<pre><code>ap = some_new_pointer_value();
</code></pre>

<p>As mentioned above, array expressions will not be converted to pointer types if they are the operands of either the <code>sizeof</code> or unary <code>&amp;</code> operators.  Thus, <code>sizeof ap</code> tells you the number of bytes required to store a 1-element array of type <code>int *</code>, not a pointer to a pointer to <code>int</code>.  Similarly, the expression <code>&amp;ap</code> has type <code>int *(*)[1]</code> (pointer to 1-element array of pointer to <code>int</code>), rather than <code>int ***</code> (which would be the case for <code>&amp;pp</code>).  </p>
",6
8755181,3555108,1,"<p>You could read an entire line from a file if you want with:</p>

<pre><code>scanf(""%[^\n]\n"", line);
</code></pre>

<p>Now, you could use sscanf to get every word:</p>

<pre><code>sscanf(line, ""%s"", word);
line += strlen(word) + 1;
</code></pre>

<p>""line"" and ""word"" are char pointers.</p>

<p>Note how line is going towards to get to the next word.</p>
",1
8800613,8800591,1,"<p><code>malloc()</code> does not provide any such guarantees. It just allocates some memory according to its own memory management decisions and returns you a pointer to that. In fact, many implementations use extra memory right before the pointer returned for memory management metadata.</p>
",0
8800618,8800591,0,"<p>You have no guarantees whatsoever about the pattern of addresses <code>malloc</code> returns to you.</p>
",1
8800619,8800591,2,"<p>Its called alignment. Most CPUs have to align memory on some boundary, and its commonly 4 or 8. If you mis-align an address you will get a segfault or bus error.</p>
",0
8800628,8800591,5,"<p>How memory managed is entirely up to your operating system. It could allocate memory from all over the place, you can absolutely make no assumptions as to where the memory will be.</p>

<p>Most memory allocators also have some overhead, so even a simple 2-byte allocation might take up 8 bytes or more. Besides, addresses might need to be aligned for several reasons (like performance, and because some CPUs even crash when reading from unaligned addresses).</p>

<p>Bottom line - take the return value from malloc as it is, don't make any guesses or assumptions.</p>
",3
8800726,8800591,1,"<p><code>malloc()</code> gives you an abstraction on the underlying hardware, OS, drivers, etc. The memory allocation pattern may differ from machine to machine due to various parameters. </p>

<p>But the following are few things that always stays right about <code>malloc()</code> </p>

<ol>
<li>The <code>malloc()</code> function allocates <code>size</code> bytes and returns a pointer to the allocated memory. </li>
<li>The memory is not initialized. </li>
<li>If <code>size</code> is 0,then <code>malloc()</code> returns either <code>NULL</code>, or a unique pointer value that can later be successfully passed to <code>free()</code>.</li>
<li>The  <code>malloc()</code> returns a pointer to the allocated memory that is suitably aligned for any kind of variable. On error, it returns <code>NULL</code>.</li>
<li><code>NULL</code> may also be returned by a successful call to <code>malloc()</code> with a size of <code>zero</code></li>
</ol>

<p>On a side note, you can use <code>%p</code> format specifier for printing the pointers</p>

<p>I modified the program as follows</p>

<pre><code>#include &lt;stdlib.h&gt;

int main(void) {
    int i,*s;
    printf(""sizeof(int) = %zu \n"", sizeof(int));

    for(i=1;i&lt;=4;i++) {
        if ((s=malloc(sizeof(int))) == NULL) {
            printf(""unable to allocate memory \n"");
            return -1;
        }
        printf(""%p \n"",s);
     }

     return 0;
}
</code></pre>

<p>The output is as follows:</p>

<pre><code>$ ./a.out 
sizeof(int) = 4 
0x9d5a008 
0x9d5a018 
0x9d5a028 
0x9d5a038 
$ 
</code></pre>
",6
13450295,7631423,2,"<p>Well, Have you tried following ?</p>

<pre><code>void main(void) {
    system(""shutdown -P 0"");
}
</code></pre>

<p>To execute this program on Linux you must log in as <code>root</code>.</p>
",0
18936430,4869507,3,"<p>You could also just use <code>system(""pause"");</code></p>
",0
16387652,16387581,1,"<pre><code>int func(int x)
{
    if(x%5 == 0)
        return x/5;
    else
        return x/5 + 1;
}
</code></pre>
",0
16387659,16387581,-1,"<p>What about an array of structs along</p>

<pre><code>struct range {
    int lo, hi, result;
}
</code></pre>

<p>Ask the user for X, then allocate an array with X instances of this struct,</p>

<pre><code>#include &lt;stdlib.h&gt;
struct range *array = malloc (X * sizeof *array);
</code></pre>

<p>Now loop over X table rows asking for the lo, hi and result. The rest is left as an exercise...</p>
",0
16387685,16387581,2,"<pre><code>int f(int x, int X){
    return (x + (X-1))/X;
}
</code></pre>
",1
13764683,13764667,1,"<p>You can add the following expression:</p>

<pre><code> -""C++""
</code></pre>

<p>in your search string.</p>

<pre><code>-string
</code></pre>

<p>is used by google to filter out the unwanted pages. See <a href=""http://websearch.about.com/library/cheatsheet/blgooglecheatsheet.htm"" rel=""nofollow"">here</a> for other tips</p>
",2
13764690,13764667,2,"<p>Try</p>

<blockquote>
  <p>c udp networking library -""c++"" -""C#""</p>
</blockquote>
",1
13770649,13764667,0,"<p>You can help hint that you want C only by surrounding it in quotes like so:</p>

<pre><code>udp library ""C""
</code></pre>

<p>While this doesn't completely solve this nagging problem, it does HELP in SOME searches.</p>

<p>Usually, more C-specific results will be in the first page, and in some cases, where you usually only get  C++/C# stuff, you'll get one or two proper C results.</p>

<p>also notice that putting ""C"" at the beginning or the end doesn't always prioritize results the same way... (try both ;-)</p>
",0
15811785,15811631,2,"<p><code>buffer[]</code> is an array of <em>pointers</em>, in your <code>while</code> loop you are pointing each of them to your array <code>temp[]</code></p>

<pre><code>buffer[i]=temp; // assign the address of temp to buffer[i]
</code></pre>

<p>Then you're changing the <em>content</em> of your <code>temp[]</code> array, but the address is always the same. </p>

<p>If you want to <em>store</em> the data from <code>temp</code> into each position in <code>buffer[]</code> you need to allocate memory and copy the data over there. More like:</p>

<pre><code>buffer[i]=malloc(strlen(temp) + 1);
strcpy(buffer[i], temp);
</code></pre>
",3
20532602,4397439,0,"<p>I love this kind of problems :-) so here it is my answer.
As said by Frerich Raabe, this can be solved with a floodFill function. For example, <code>opencv</code> library would provide such a function off the shelf.</p>

<p>Please forgive me if in the following code you'll find traces of C++, in case they should be simple to be replaced.</p>

<pre><code>typedef struct Point {
   int x;
   int y;
} Point;

int areaOfBiggestContiguousRegion(int* mat,int nRows, int nCols) {
  int maxArea = 0;
  int currValue, queueSize, queueIndex;  
  int* aux;
  Point queue[1000]; //Stores the points I need to label
  Point newPoint, currentPoint;
  int x,y,x2,y2;
  //Code: allocate support array aux of same size of mat
  //Code: fill aux of zeros

  for (y = 0; y &lt; nRows; y++)
    for (x = 0; x &lt; nCols; x++)
      if (aux[y * nCols + x] == 0) {//I find a pixel not yet labeled, my seed for the next flood fill
        queueIndex = 0; //Contains the index to the next element in the queue
        queueSize = 0;

        currValue = mat[y * nCols + x]; //The ""color"" of the current spot
        aux[y * nCols + x] = 1;
        newPoint.x = x;
        newPoint.y = y;
        queue[queueSize] = newPoint;
        queueSize++; 

        while(queueIndex != queueSize) {
          currPoint = queue[queueIndex];
          queueIndex++;

          //Look left, right, up, down

          x2 = currPoint.x - 1;
          y2 = currPoint.y;
          //Some copy &amp; paste, sorry I have been too long on C++ to remember correctly about C functions
          if (x2 &gt;= 0 &amp;&amp; aux[y2 * nCols + x2] == 0 &amp;&amp; mat[y2 * nCols + x2] == currValue) {
            aux[y2 * nCols + x2] = 1;
            newPoint.x = x2;
            newPoint.y = y2;
            queue[queueSize] = newPoint;
            queueSize++; 
          }

          x2 = currPoint.x + 1;
          y2 = currPoint.y;
          //Some copy &amp; paste, sorry I have been too long on C++ to remember correctly about C functions
          if (x2 &lt; nCols &amp;&amp; aux[y2 * nCols + x2] == 0 &amp;&amp; mat[y2 * nCols + x2] == currValue) {
            aux[y2 * nCols + x2] = 1;
            newPoint.x = x2;
            newPoint.y = y2;
            queue[queueSize] = newPoint;
            queueSize++; 
          }

          x2 = currPoint.x;
          y2 = currPoint.y - 1;
          //Some copy &amp; paste, sorry I have been too long on C++ to remember correctly about C functions
          if (y2 &gt;= 0 &amp;&amp; aux[y2 * nCols + x2] == 0 &amp;&amp; mat[y2 * nCols + x2] == currValue) {
            aux[y2 * nCols + x2] = 1;
            newPoint.x = x2;
            newPoint.y = y2;
            queue[queueSize] = newPoint;
            queueSize++; 
          }

          x2 = currPoint.x;
          y2 = currPoint.y + 1;
          //Some copy &amp; paste, sorry I have been too long on C++ to remember correctly about C functions
          if (y2 &lt; nRows &amp;&amp; aux[y2 * nCols + x2] == 0 &amp;&amp; mat[y2 * nCols + x2] == currValue) {
            aux[y2 * nCols + x2] = 1;
            newPoint.x = x2;
            newPoint.y = y2;
            queue[queueSize] = newPoint;
            queueSize++; 
          }
        } //while

      if (queueSize &gt; maxArea)
        maxArea = queueSize; //If necessary we could store other details like currentValue
      }//if (aux...

return maxArea;
}
</code></pre>

<p>Note: In C++ using std containers and a constructor for <code>Point</code> it becomes much more compact</p>
",0
15855649,15855608,3,"<p>The intermediate value (before dividing by 9) overflows 64-bit integer. That is the reason why you don't get the expected result.</p>

<p>To be more precise, the maximum value of 64-bit integer is:</p>

<pre><code>18446744073709551615
</code></pre>

<p>Compared to the (smallest) intermediate value before division:</p>

<pre><code>161000000000000000001
</code></pre>

<p>This answer is assuming that <code>long</code> type in your code translate to a 64-bit integral type (the standard mandates that <code>long</code> type is at least 32-bit, so you might also get 32-bit integral type depending on the environment). Depending on the OS, computer architecture and the compiler, the upper limit of <code>long</code> type may vary.</p>
",2
8798952,8798929,3,"<p>It crashes because you meant on line 3:</p>

<pre><code>if (*ptr == NULL)
</code></pre>

<p>rather than</p>

<pre><code>if (**ptr == NULL)
</code></pre>

<p>You will also want to initialize the pointer to <code>NULL</code> on line 13, since you are checking against that with the above:</p>

<pre><code>int *ptr = NULL;
</code></pre>

<p>In C, variables are not automatically initialized to zero, unless allocated at static scope, which has other consequences depending on the context.</p>
",0
8798964,8798929,4,"<p>You have an extra dereference of <code>ptr</code> in the <code>NULL</code> check, and you are not initializing the pointer. The program should look like this after the fix:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void changer(int **ptr)
{
    if(*ptr==NULL) // Dereference once, not twice
    {
        *ptr=(int *)malloc(sizeof(int));
        **ptr=2;
    }
}

int main()
{
    int *ptr = 0; // Initialize the pointer
    clrscr();
    changer(&amp;ptr);
    printf(""%d"",*ptr);
    getch();
    return 0;
}
</code></pre>
",0
8798970,8798929,3,"<p>You haven't initialized <code>ptr</code> in <code>main()</code>, but you check whether what it points to is zero in <code>changer()</code>.</p>

<p>Use:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void changer(int **ptr)
{
    if (*ptr == NULL)
    {
        *ptr = (int *)malloc(sizeof(int));
        if (*ptr != NULL)
           **ptr = 2;
    }
}

int main(void)
{
    int *ptr = NULL;
    changer(&amp;ptr);
    printf(""%d\n"", *ptr);
    return 0;
}
</code></pre>
",0
15825231,15824932,1,"<p>I think you're looking for the <code>dladdr</code> function.</p>
",1
8804698,8804605,0,"<p>As Viruzzo pointed out in a comment, you cannot use pointer arithmetic on elements of a linked list. As the word ""linked"" implies, there are only pointers linking the items together, they're not required to be located at adjacent addresses.</p>

<p>The pointer arithmetic will simply decrease the pointer by a fixed number of bytes, it will not follow pointers. Your list, being singly-linked, doesn't even <em>have</em> previous-element pointers to follow.</p>
",0
8804744,8804605,0,"<p><code>curr = curr-10;</code> is wrong. It does not perform the operation that you think it does!</p>

<p>To print the contents of your linked list, you need to start from the <code>head</code> and go through each and every node until you hit <code>NULL</code> (assuming its not a circular list).</p>

<pre><code>void display()
{
        NODE * current = head;

        if (current == NULL) {
                printf(""Empty list \n"");
                return;
        }

        while(current != NULL) {
                printf(""%d "", current-&gt;data);
                current = current-&gt;next;
        }

        printf(""\n"");
        return;
}
</code></pre>

<p>And to add new node in the front, you can use the following code snippet.</p>

<pre><code>void addfront(int data)
{
        NODE *newnode = NULL;

        if ((newnode = malloc(sizeof(NODE))) != NULL) {
                newnode-&gt;data = data;
                newnode-&gt;next = NULL;   
        } else {
                printf(""Couldn't allocate space for new element \n"");
                return;
        }       

        if (head == NULL) {
                // empty list
                head = newnode; 
                tail = newnode;
        } else {
                newnode-&gt;next = head;
                head = newnode;
        }

        return;
}
</code></pre>

<p>To add new node at the rear, you can use the following code snippet.</p>

<pre><code>void addrear(int data)
{
        NODE * newnode = NULL;

        if ((newnode = (NODE *) malloc(sizeof(NODE))) != NULL) {
                newnode-&gt;data = data;
                newnode-&gt;next = NULL;
        } else {
                printf(""unalbe to allocate memory to the new element - %d \n"", data);
                return;
        }

        if (tail == NULL) {
                assert(head == NULL &amp;&amp; tail == NULL);
                head = tail = newnode;
        } else {
                tail-&gt;next = newnode;
                tail = newnode;
        }

        return;
}
</code></pre>

<p>All the above mentioned code snippet assumes, you have <code>head</code> and <code>tail</code> as global variables.</p>

<p>Hope this helps!</p>
",0
8804665,8804605,0,"<p>Your code <code>curr = curr-10</code> will not bring you back to the head of the linklist.</p>
",0
8804667,8804605,2,"<p>There are several problems.</p>

<p>First of all, the following insertion code isn't correct:</p>

<pre><code>      if(head!=NULL) head-&gt;next  = curr;
      head = curr;
</code></pre>

<p>Basically, the element pointed to by <code>head</code> is irrevocably lost.</p>

<p>Secondly, the behaviour of the following code is undefined:</p>

<pre><code>curr = curr-10;
</code></pre>

<p>You cannot move across several <code>malloc()</code>ed blocks using pointer arithmetic.</p>

<p>Once you fix the insertion logic, it will become possible to traverse the list like so:</p>

<pre><code>for (curr = head; curr != NULL; curr = curr-&gt;next) {
    ....
}
</code></pre>
",1
8804678,8804605,5,"<p>You cannot use pointer arithmetic on a linked list: the items are allocated separately (with malloc) and so they will not be necessarily adjacent in memory. That approach would only work with an array.</p>
",0
10791214,10791199,0,"<p>glib.  Hard to use if you're just-starting-off because you actually have to know how to get around in pointers.</p>

<p>It's reasonably standard for applications that want to use that sort of thing (excuse the wishy-washy opining).</p>

<p>An option I usually prefer is to wrap C++ STL with C APIs myself.  I don't know if there's a standard converter for this.  But this is because most developers I work with understand C++-to-C APIs (part of the corporate code landscape at my firm) and STL much better than glib, in which client code tends to be egregiously error prone.</p>
",1
15551013,15550966,7,"<p>The boolean || will short-circuit: if the first operand is <code>true</code>, the second will never be evaluated. In contrast, the bitwise | always evaluates both arguments.</p>
",2
15551024,15550966,10,"<p>What does ""support"" mean?</p>

<p>If it's a logical or that you mean, then of course you should always use <code>||</code> since that is the Boolean, logical, ""or"" operator.</p>

<p>It has the benefit of being able to short-circuit, but that won't matter much in code this simple.</p>

<p>I would consider it odd and weird (and due for correcting) if bitwise or was being used when the point is not to manipulate bits.</p>
",2
15551040,15550966,1,"<p>The bitwise or operator never short-circuits while the logical one does. That is if <code>bFoo</code> is true, <code>bBar</code> is never evaluated.</p>
",0
15551107,15550966,7,"<p>Other answers have already talked about short-circuiting (but that's not an issue in your particular code).  But here is one key difference.</p>

<p>If, for some reason, your input values are not in [0,1], then a bitwise OR will give you an answer that may also not be in [0,1].  Logical OR is <strong>guaranteed</strong> to give you 0 or 1.</p>

<p>For this reason, you should prefer logical OR.  Your intent is (presumably) to manipulate logical values, so using a non-logical operator is illogical.<sup>*</sup></p>

<p><hr>
<sub>* Pun definitely intended.</sub></p>
",0
15551233,15550966,2,"<p>In that particular case, no, there is no difference in the <em>result</em>:</p>

<pre><code>1 || 0 == 1
1 | 0  == 1
</code></pre>

<p>all the truth tables apply here.</p>

<p>If you're talking about how we <em>got</em> to the result then there <em>could</em> be a difference. With the <code>||</code> you have a short circuit mechanism:</p>

<pre><code>BOOLEAN bFooBar = (bFoo||bBar) // if bFoo is TRUE, we never look at bBar
                               // vs
BOOLEAN bFooBar = (bFoo|bBar)  // where we take into account both values
</code></pre>

<p>So the long and short of it is, yes you can use logical and bitwise operators <em>incorrectly</em> in some instances and get the same results, but why would you <strong><em>ever</em></strong> do that? If you know it's wrong, and you know that it can lead to bad, hard to find bugs, use the tools the language gaves you for the jobs they were meant to do.</p>
",0
15551241,15550966,1,"<blockquote>
  <p>Is there any functional difference between logical and bitwise
  operators in the following case?</p>
</blockquote>

<p>Yes, there is (lazy eval as others have pointed out).</p>

<blockquote>
  <p>Any reason to support one or the other?</p>
</blockquote>

<p>If somehow they were equivalent, the case for using logical operators would be to preserve the semantic intended by the type.  See also: <a href=""http://en.wikipedia.org/wiki/Principle_of_least_astonishment"" rel=""nofollow"">Principle of least astonishment</a>.</p>
",0
13744375,7721199,-1,"<p>You can also prefer the memcpy() function. </p>

<pre><code>void * memcpy ( void * destination, const void * source, size_t num );
</code></pre>

<p><code>destination</code>
Pointer to the destination array where the content is to be copied, type-casted to a pointer of type void*.</p>

<p><code>source</code>
Pointer to the source of data to be copied, type-casted to a pointer of type const void*.</p>

<p><code>num</code>
Number of bytes to copy.</p>

<p><code>size_t</code> is an unsigned integral type.</p>

<p>Copies the values of num bytes from the location pointed by source directly to the memory block pointed by destination.</p>

<p>The underlying type of the objects pointed by both the source and destination pointers are irrelevant for this function; The result is a binary copy of the data.</p>

<p>The function does not check for any terminating null character in source - it always copies exactly num bytes.</p>

<p>To avoid overflows, the size of the arrays pointed by both the destination and source parameters, shall be at least num bytes, and should not overlap (for overlapping memory blocks, memmove is a safer approach).</p>

<p>Sample Program</p>

<pre><code>/* memcpy example */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

struct {
  char name[40];
  int age;
} person, person_copy;

int main ()
{
  char myname[] = ""user613994"";

  /* using memcpy to copy string: */
  memcpy ( person.name, myname, strlen(myname)+1 );
  person.age = 46;

  /* using memcpy to copy structure: */
  memcpy ( &amp;person_copy, &amp;person, sizeof(person) );

  printf (""person_copy: %s, %d \n"", person_copy.name, person_copy.age );

  return 0;
}
</code></pre>
",1
10802742,10796933,1,"<p>I ran your code several times and Im getting nothing but correct output so i cant reproduce the problem.  I do think I know what the issues is.  try calling</p>

<pre><code>    flush(stdin);
</code></pre>

<p>before your call to input. </p>
",2
19323984,19323947,2,"<p><code>a = (int*) f;</code> makes explicit that you want to cast a <code>float*</code> pointer to an <code>int*</code> pointer. Without it, you'll receive an incompatible pointer types error.</p>
",2
19323985,19323947,3,"<h2>6.5.16.1 Simple assignment</h2>
<blockquote>
<p>the left operand has atomic, qualified, or unqualified pointer type, and (considering
the type the left operand would have after lvalue conversion) both operands are
pointers to qualified or unqualified versions of <strong>compatible types</strong>, and the type pointed
to by the left has all the qualifiers of the type pointed to by the right.</p>
</blockquote>
<p>So, <code>a = f</code> is a constraint violation and invokes undefined behavior.</p>
<p>In second case you are making <code>f</code> (by casting it)to be <strong>compatible</strong> to <code>a</code>'s type. It is legal to do a casting in C (not sure about other languages).<br />
But it should be noted that after casting <code>f</code> is still pointer to <code>float</code> and you have to cast it every time when you will assign it to <code>a</code>.</p>
",4
19324097,19323947,5,"<pre><code>float *f;
int *a;

a = f;
</code></pre>

<p>This assignment is erroneous (there is a C constraint violation), there is no implicit conversion between pointer types (except with <code>void *</code>). A compiler can refuse to compile a program with this assignment. </p>
",2
19324126,19323947,1,"<pre><code>a = f; //assignment
// is a constraint violation

a = (int *) f; //cast + assignment
</code></pre>

<p>Explicitly  casting float pointer to int pointer.simply hides compiler warnings or errors. 
but very well might crash when running as the sizes of what the program expects when dereferencing the pointer differs from reality.</p>
",3
19324216,19323947,2,"<p>Your code will compile (at least in my linux and gcc). But you will get a warning.
If you use <code>a = f;</code> and then use <code>a</code> somewhere in your code, you will get erroneous data, because a float is stored in a different format in memory. Even if you do the casting first you probably will get erroneous results, but the compiler sees your casting and assumes you know what you are doing.</p>
",7
19325025,19323947,4,"<p>Given:</p>

<pre><code>float *f;
int *a;
</code></pre>

<p>This:</p>

<pre><code>a = f;
</code></pre>

<p>is a <em>constraint violation</em>. It requires a <em>diagnostic</em> from any conforming compiler. After issuing the required diagnostic, it may or may not reject the program. (IMHO it should do so.) A conforming compiler may choose to accept it with a mere warning (which qualifies as a diagnostic), but once it does so the behavior of the program is undefined. Compilers that do this most commonly generate an implicit conversion from <code>float*</code> to <code>int*</code>, giving the same behavior as if there were a cast (an explicit conversion), but the standard does not require that.</p>

<p>Non-conforming compilers, of course are free to do anything they like.</p>

<p>Conclusion: Don't write code like that. Even if your compiler lets you get away with it, another compiler might not. If you want to convert from one pointer type to another, use a cast. Aside from validity issues, the cast makes it much clearer to the reader that something funny is going on. If your compiler gave you a warning, heed it. If it didn't, find out how to increase the warning levels on your compiler.</p>

<p>This:</p>

<pre><code>a = (int *) f;
</code></pre>

<p>takes the value of <code>f</code> (which is of type <code>float*</code>) and explicitly <em>converts</em> it to type <code>int*</code>, then assigns that <code>int*</code> value to <code>a</code>. (I'll assume that something between the declaration and the assignment has set <code>f</code> to some valid value.)</p>

<p>If <code>f</code> is a null pointer, the conversion is well defined, and yields a null pointer of type <code>int*</code>. The rules for converting a non-null object pointer to another pointer type are (quoting <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""nofollow"">N1570</a> 6.3.2.3p7):</p>

<blockquote>
  <p>A pointer to an object type may be converted to a pointer to a
  different object type. If the resulting pointer is not correctly
  aligned for the referenced type, the behavior is undefined.
  Otherwise, when converted back again, the result shall compare equal
  to the original pointer.</p>
</blockquote>

<p>This kind of conversion, assuming <code>int</code> and <code>float</code> are the same size and have similar alignment requirements, is likely intended to let you treat a <code>float</code> object as if it were an <code>int</code> object. This is called ""type-punning"". If <code>int</code> and <code>float</code> <em>aren't</em> the same size, or if they have different alignment requirements, this can easily blow up in your face, crashing your program (if you're lucky) or giving you garbage results (if you're not). (Yes, crashing the program is a <em>good</em> outcome; it lets you know there's a problem.)</p>

<p>If you really need to do that for some reason, it's better to define a <code>union</code> with <code>int</code> and <code>float</code> members, or to use <code>memcpy()</code> to copy the contents of a <code>float</code> object into an <code>int</code> object.</p>

<p>But it very rarely makes sense to do that kind of thing. If you want to examine the representation of a <code>float</code> object, it's better to treat it as an array of <code>unsigned char</code> something that the language standard explicitly permits.</p>
",6
13780280,13780247,1,"<p>You are, in fact, declaring <code>struct B</code> here, but you are not declaring a variable of that type.</p>

<p>This is a warning, but one you should fix.  Perhaps you meant:</p>

<pre><code>struct A
{   int a;
    struct B
    {
        int c;
    } c;
};
</code></pre>
",0
13780313,13780247,3,"<p>It's legal (but extremely bad style) to do:</p>

<pre><code>struct A {   
    int a;
    struct B {    
        int c;
    };
};
struct B B_instance;
struct A A_instance;
</code></pre>

<p>And the compiler doesn't know about the later variables that use the struct types, so it really should not error out.  </p>
",0
13780316,13780247,4,"<p>Because you can do this:</p>

<pre><code>struct A
{   int a;
    struct B
    {    int c;
    };
};

int main()
{
    struct A a = {1};
    struct B b = {2};

    return a.a + b.c;
}
</code></pre>

<p>Note:</p>

<ul>
<li>you need a semicolon after declaring <code>B</code>, which your code is missing</li>
<li>this isn't particularly <em>useful</em>, but I suppose it might serve some documentary purpose (ie,to suggest a relationship or grouping between types)</li>
<li>in C++, the second variable would have type <code>A::B</code>, but C doesn't have the same scoping rules (all structs just belong to the global struct namespace, in effect)</li>
</ul>

<hr>

<p>As to the motivation for allowing it ...</p>

<pre><code>struct Outer {
    struct {
        int b;
    } anon;
    /* this ^ anonymous struct can only be declared inside Outer,
       because there's no type name to declare anon with */

    struct Inner {
        int c;
    } named;
    /* this ^ struct could be declared outside, but why force it to be
       different than the anonymous one? */

    struct Related {
        double d;
    };
    /* oh no we have no member declared immediately ... should we force this
       declaration to be outside Outer now? */

    struct Inner * (*function_pointer)(struct Related *);
    /* no member but we are using it, now can it come back inside? */

    struct Related excuse;
    /* how about now? */
};
</code></pre>

<p>Once you've allowed nested type declarations like this, I doubt there's any particular motivation to require there be a member of that type right away.</p>
",6
13780859,13780247,3,"<p>Generally, a warning means the code likely does not do what you intended but is legal in the language. The compiler is saying, ¡°This is likely not what you really wanted to do, but I must allow you to do it because the language says it is allowed.¡± The compiler <strong>cannot</strong> give you an error for this code because the C standard permits it, so it must be allowed (unless you specifically ask for errors for such things, as by using GCC¡¯s -Werror option to turn warnings into errors).</p>

<p>The C standard does not attempt to define everything that makes sense in a program. For example, these things are legal in C:</p>

<pre><code>3;
if (x) then foo(); else foo();
x = 4*0;
</code></pre>

<p>The first statement has no side effects, and its return value is not used. But it is legal in C, since a statement may be just an expression. The second statement just calls <code>foo()</code>, so the <code>if</code> is pointless. In the third statement, multiplying by four is pointless.</p>

<p>It would be extremely difficult to write a C standard that prohibited all things that did not make sense. And it is certainly not worth the effort. So this is part of your answer: When the committee writing the C standard builds the language, do they want to spend a lot of time rewriting the technical specification to exclude things that do not make sense? Sometimes yes, if it seems valuable to avoid something that could cause serious bugs. But much of the time, it is just not worth their time and would complicate the specification unnecessarily.</p>

<p>However, compilers can recognize some of these things and warn you. This helps catch many typographical errors or other mistakes.</p>

<p>On the other hand, sometimes these constructions arise from unusual circumstances. For example, a program may have preprocessor statements that define <code>struct A</code> in different ways when building for different targets or different features. In some of those targets, it may be that the <code>struct B</code> member is not needed in <code>struct A</code>, so it is not declared, but the declaration of <code>struct B</code> (the type, not the object) remains present just because it was easier to write the preprocessor statements that way.</p>

<p>So the compiler needs to permit these things, to avoid interfering with programmers writing a wide variety of programs.</p>
",0
13735261,13735225,2,"<p>There is no way to lock in the <code>c</code> language. Operating systems might provide support for locking (without regard for the language), and libraries such as <code>pthreads</code> can take advantage of operating system services, however this is beside the language. (By contast, other languages have native locking built into them, such as through Java's <code>synchronized</code> keyword.)</p>
",3
13735295,13735225,4,"<p>Threads were only introduced into the ISO C standard with C11, a rather recent edition to the standard so not necessarily <em>widely</em> supported yet.</p>

<p>You need to look into <code>threads.h</code> and the <code>mtx_*</code> functions for an understanding of that.</p>

<p>Before then, <code>pthreads</code> was probably your best bet with its wide implementation although, not being standard C <sup>(a)</sup>, its support wasn't mandated.</p>

<p>For example, Windows has its own way of doing threading, using functions like <code>CreateThread</code>.</p>

<p>However, there are various third-party products such as <a href=""http://sourceware.org/pthreads-win32/"" rel=""nofollow"">pthreads-win32</a> that aim to give pthreads support to Windows, to assist in porting of applications from POSIX-compliant operating systems.</p>

<hr>

<p><sup>(a)</sup> It <em>is</em> a POSIX standard (part of IEEE 1003.1) so that may be good enough for some people.</p>
",0
13782967,4705725,2,"<p>Look where you save your source file, alway C++ Compilers generate two files, let say your source named ""hello.cpp""
These files should be in your source path:
hello.obj
hello.exe &lt;--your prgram to distribut</p>

<p>ALSO</p>

<p>I think you should use new free IDE/Compiler for better result such as:CodeBlocks at <a href=""http://www.codeblocks.org"" rel=""nofollow"">http://www.codeblocks.org</a></p>
",0
9774971,9774251,0,"<p>I work in Linux and GCC but I hope it will help: </p>

<p>for me it looks like you don't link it statically, so the main code requires to load libraries on runtime. Link it statically, if possible, or make the used library visible for your code (in Linux you could set <code>LD_LIBRARY_PATH</code>, in W. I have no idea)</p>
",0
9775882,9774251,1,"<p>If you try to compile just <code>DES_hash.c</code>, the linker will complain with</p>

<pre><code>In function main': C:DES_hash.c:42: undefined reference to DES'
</code></pre>

<p>which is only natural since <code>DES()</code> is defined in <code>DES.c</code>, and you are not including it in the linking process. Now, what you must do is, of course, compile like <code>gcc DES.c DES_hash.c</code>; however you've made a boo-boo: you have defined functions inside a header file (<code>DES_Utils.h</code>). What that means, is that those functions are defined whenever something includes <code>DES_Utils.h</code>, which is bad. In this particular case, some functions are defined in both <code>DES_hash.c</code> and <code>DES.c</code>, and the linker is confused, not knowing which one to link against.</p>

<p>The easiest way to solve your problem is to move the function definitions from <code>DES_Utils.h</code> to a new file <code>DES_Utils.c</code>, leaving only the declarations of a public interface in the header. Also, make sure the arrays you define in <code>DES.h</code> are either <code>static</code> to the header if needed in multiple <code>.c</code> files or defined in a single <code>.c</code> file.</p>
",0
9776353,9774251,1,"<p>Did a number of things to get it to compile. Some of these points are only to get rid of warnings. :</p>

<ol>
<li><p>Add \ to line 24 of DES.h #define IP_1(x) { \</p></li>
<li><p>In DES_Utils.h, line 228: Here sbox_indices are defined, and malloc'd but 
never freed NOR used.</p></li>
<li><p>Correct signature of main should/could be int main(void /* int argc, char *argv[] */), 
Inserted void as argument's are not used.</p></li>
<li><p>Add in main() parenteses around f = fopen() statement.<br />
<strike><strong>Here you should check for read bytes and not != 0.</strong> If file is mismatch in sizeof(unsigned long long) / CHAR_BIT you'd be working on ""tail"" from previous read.</strike> </p></li>
<li><p>DES_Utils.h: Added signatures of shared functions, moved rest to new file DES_Utils.c</p></li>
</ol>

<p>Modified DES_Utils.h: </p>

<pre><code>#ifndef GUARD_DES_Utils /* prevents errors when including twice */
#define GUARD_DES_Utils

//Definition of shared function !!
unsigned long long *DES(unsigned long long, unsigned long long);
void left_shift(int *, int, int);
int *concatenate_arrays(int *, int *, int);
char *bin_array_to_string(int *, int);

int *xor_arrays(int *, char *, int);
int *compute_sbox(int *, int);
int *xor_int_arrays(int *, int *, int);
void bin_array_to_hex(int *, int);

void ull_to_bin_array(unsigned long long, int *, int);

#endif
</code></pre>

<p>6) Moved </p>

<pre><code>#define NUM_LEFTSHIFTS 16
int LEFTSHIFT_SCHEDULE[NUM_LEFTSHIFTS] = {1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1};
</code></pre>

<p>from DES.h to DES.c</p>

<p>7) Moved </p>

<pre><code>#define SBOX_ROWS 4
#define SBOX_COLS 16
</code></pre>

<p>and all int SBOX_N's to DES_Utils.c</p>

<pre><code>int SBOX_1[SBOX_ROWS][SBOX_COLS] =  { ...
trough
int SBOX_8[SBOX_ROWS][SBOX_COLS] =  { ...
</code></pre>

<p>8) Compile:</p>

<p>Objects:</p>

<pre><code>gcc -c -o obj/DES_Hash.o src/DES_Hash.c -Wall -Wextra -pedantic -std=c99 -ggdb
gcc -c -o obj/DES_Utils.o src/DES_Utils.c -Wall -Wextra -pedantic -std=c99 -ggdb
gcc -c -o obj/DES.o src/DES.c -Wall -Wextra -pedantic -std=c99 -ggdb
</code></pre>

<p>Link:</p>

<pre><code>gcc -o ./bin/DES_Hash ./obj/DES_Hash.o ./obj/DES_Utils.o ./obj/DES.o -Wall -Wextra -pedantic -std=c99 -ggdb
</code></pre>

<p>9) function DES in DES.c does not return any value, but try to run anyway.</p>

<pre><code>73FB90EEDF18B09A
SIGSEGV
</code></pre>

<p>File structure after compile:</p>

<pre><code>.
©À©¤©¤ bin
©¦?? ©¸©¤©¤ DES_Hash
©À©¤©¤ obj
©¦?? ©À©¤©¤ DES_Hash.o
©¦?? ©À©¤©¤ DES.o
©¦?? ©¸©¤©¤ DES_Utils.o
©À©¤©¤ src
©¦?? ©À©¤©¤ DES.c
©¦?? ©À©¤©¤ DES.h
©¦?? ©À©¤©¤ DES_Hash.c
©¦?? ©À©¤©¤ DES_Utils.c
©¦?? ©¸©¤©¤ DES_Utils.h
©¸©¤©¤ test
    ©¸©¤©¤ input2.txt
</code></pre>

<p><strong>EDIT:</strong> Note to point 4. Consider using something like:</p>

<pre><code>#define BYTE_ULL  (sizeof(unsigned long long))

char buffer[BYTE_ULL + 1];
fread  BYTE_ULL bytes
buffer[BYTE_ULL] = '\0';
</code></pre>

<p>And check read bytes instead of != 0, or use as now but say == 1 instead.</p>

<p><strong>EDIT2:</strong> In DES_Utils.c (aprox line 136), bin_array_to_hex(): </p>

<p>Here byte 4 in hexB are never set, thus call to strtoull() in map_bin_to_hex() result in work on an unitialized value.</p>

<p>As mentioned in pt 9 and comment below, DES() does not return any value thus resulting in SIGSEGV in main() when trying to give C_i the value of Ekp_i, which never receives a pointer from DES().</p>

<p>There is only <em>one</em> free(), so valgrind gives a rather filled list (here is two frees as I added a dummy value of 1234 from DES() and frees that):</p>

<pre><code>==31352== Command: bin/DES_Hash
==31352== 
73FB90EEDF18B09A
74657374696E6720
8387236824869660448
1234
74657374696E63F2

==31352== 
==31352== HEAP SUMMARY:
==31352==     in use at exit: 48,417 bytes in 308 blocks
==31352==   total heap usage: 310 allocs, 2 frees, 48,777 bytes allocated
==31352== 
==31352== LEAK SUMMARY:
==31352==    definitely lost: 47,633 bytes in 292 blocks
==31352==    indirectly lost: 0 bytes in 0 blocks
==31352==      possibly lost: 0 bytes in 0 blocks
==31352==    still reachable: 784 bytes in 16 blocks
==31352==         suppressed: 0 bytes in 0 blocks
</code></pre>

<p>Use of valgrind with --leak-check=full gives all locations to fix.</p>
",2
9774335,9774251,1,"<p>You include <em>before</em> GUARD_DES_Utils.</p>

<pre><code>/* DES_Utils.h */
#include ""DES.h""
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#ifndef GUARD_DES_Utils /* prevents errors when including twice */
...
</code></pre>

<p>Move includes to body of incl. guards.</p>
",5
12322332,12321890,3,"<p>It appears that they are using an 8-bit microcontroller which doesn't do floating point calculations. They also state that fetching data from memory is more efficient when its done in bytes rather than shorts or ints. The code you show implements a fixed point multiplication with constants and values scaled to provide sufficient room on both sides of the binary point so that overflows don't occur and so that there is sufficient precision for their needs.</p>
",0
12322392,12321890,0,"<p>For some reason or another the programmer chose/had to do the computations on integers rather than on floating point values. So:</p>

<ol>
<li><p>He cannot operate on values that have too many significant digits below 1. If you try to store 6.6972*10^-13 as an integer you will get 0. So,6.6972*10^-13 gets multiplied by 2^48 to give 1885.094214... It's probably fine to cut the digits after the dot.</p></li>
<li><p>NOT</p></li>
</ol>
",3
11831442,11831122,0,"<p>Your code has two bugs. The first is that you are allocating memory on the stack. Whenever you declare a variable like this:</p>

<pre><code>int hello = 5;
char test;
Cat newCat;
</code></pre>

<p>You are allocating memory on the stack. This memory is freed as soon as the function returns. To make something more permanent, you need to manually allocate memory in the heap with the malloc function. This memory will remain valid until you release it at a later date by calling <code>free()</code>. Additionally, you need to use <code>strncpy()</code> to copy strings, you can not simply copy the pointer. </p>

<pre><code>Cat* createCat(char* name)
{
     Cat* newCat = malloc(sizeof(Cat));
     if(!newCat)
     {
            printf(""Error allocating memory for cat\n"");
            exit(-1);
     }
     //copy in the string, leave a null terminator on the string
     strncpy(newCat.name, name, 63);
     newCat.name[63] = '\0'; 
     return newCat;
}
</code></pre>
",1
11831186,11831122,7,"<p>Array decay to pointers when passed to functions. So:</p>

<pre><code>Cat createCat(char name[64]) {
</code></pre>

<p>is the same as:</p>

<pre><code>Cat createCat(char* name) {
</code></pre>

<p>and the line:</p>

<pre><code>newCat.name = name;
</code></pre>

<p>is attempting to assign a <code>char*</code> to a <code>char[]</code>, as the error states. As <a href=""https://stackoverflow.com/users/922184/mysticial"">Mystical</a> has already commented, you need to use <a href=""http://en.cppreference.com/w/c/string/byte/memcpy"" rel=""nofollow noreferrer""><code>memcpy()</code></a> or <a href=""http://en.cppreference.com/w/c/string/byte/strcpy"" rel=""nofollow noreferrer""><code>strcpy()</code></a> (or <a href=""http://en.cppreference.com/w/c/string/byte/strncpy"" rel=""nofollow noreferrer""><code>strncpy()</code></a>) to copy <code>name</code> to <code>newCat.name</code>. If you use <code>memcpy()</code> you <em>must</em> remember to null terminate <code>newCat.name</code>.</p>
",0
11831253,11831122,0,"<p>Yikes. You're returning an automatic (stack-based) variable from a function. That will die horribly when the stack frame is popped and the memory goes away. You need to dynamically allocate a <code>Cat</code> structure and copy the <code>name</code> data into it. Don't forget to call <code>free()</code> when you're done with the memory.  </p>

<pre><code>Cat *createCat(char name[64])
{
Cat *tmpCat;
tmpCat=malloc(sizeof(Cat));
strncpy(Cat.name,name,64); // &lt;- or 63 to make sure name is NULL-terminated
return tmpCat;
}
</code></pre>
",1
11506425,11505778,0,"<p>You can create a variable keeping a pointer to the <code>myfun()</code> function. This will allow you to effectively 'alias' the original function without introducing an additional one.</p>

<pre><code>int myfun(int a, int b)
{
    // ...
    return 0;
}

static int (*myfunwrap)(int, int) = &amp;myfun;

int otherfun(int a, int myfun)
{
    myfunwrap(a, myfun);
}
</code></pre>

<p>Of course, you can replace <code>myfunwrap</code> with any name you like.</p>
",0
11506444,11505778,0,"<p>The best idea would be to just chose a different name for your parameter. The second best is this one, I think:</p>

<pre><code>int otherfun(int a, int myfun)
{
 int myfun_tmp = myfun;
 // Here i need to call the function myfun as .. myfun(a,myfun)
 {
   extern int myfun(int, int);
   myfun(a, myfun_tmp);
 }
}
</code></pre>
",0
11505839,11505778,8,"<pre><code>int myfun(int a , int b)
{
return 0;
}

int myfun_helper(int a, int b) 
{
 return myfun(a,b);
}
int otherfun(int a, int myfun)
{
 /* the optimizer will most likely inline this! */
 return myfun_helper(a,myfun);
}
</code></pre>
",1
15841572,15841478,4,"<p><code>bigRandP</code> is a pointer to <code>unsigned int</code>.</p>

<p>You pointed it to an <code>unsigned char</code> object, then you <em>modified</em> the <code>unsigned int</code> object that <code>bigRandP</code> points to.</p>

<p>Apparently <code>smallRand</code> and <code>bigRandP</code> are stored close to each other in memory. By trying to modify <code>sizeof (unsigned int)</code> bytes of a 1-byte object, you clobbered part of the pointer object itself.</p>

<p>Bottom line: Your program's behavior is undefined.</p>

<p>Also, though this probably isn't related to the behavior you're seeing, the <code>%p</code> format requires a <code>void*</code> argument. If you want to print some other type of pointer, you should convert it to <code>void*</code>:</p>

<pre><code>printf(""%p %p %p\n"", (void*)&amp;nameSum, (void*)&amp;smallRand, (void*)bigRandP);
</code></pre>

<p>It's likely to ""work"" with or without the casts on systems where all pointers have the same representation, but the version with the casts is more correct on all systems.</p>
",0
19441408,19441396,5,"<p>You never update <code>count</code> and you keep writing the same data over and over again.  In this code:</p>

<pre><code>count = read(fdold, buffer, sizeof(buffer));
while (count &gt; 0)
    write(fdnew, buffer, count);
</code></pre>

<p>You read from the file descriptor once, pulling in <code>count</code> bytes, and while it's greater than <code>0</code> (which is presumably is), you keep writing the buffer out to the new file.  You never read any more data from the old file.  If you can see the file getting bigger and bigger, you might also be able to see (depending on how the content gets flushed to disk) the same content repeated over and over again.</p>

<p>What you actually need to be doing is something more like this:</p>

<pre><code>while there is data to read from the old file
  read it into a buffer
  while there is data in the buffer to write to the new file
    write data from the buffer into the new file
</code></pre>

<p>In slightly less pseudo-codish, but highly untested form, I think you'd be looking for something sort of like this:</p>

<pre><code>int count = 0;
int written;
while ( 0 &lt; (count = read(fdold, buffer, sizeof(buffer))) ) {
  written = 0;
  while ( count &gt; (written += write(fdnew, buffer+written, count-written))) );
}
</code></pre>

<p>The outer loop makes sure that you read until there's nothing left to read, and the inner while make sure that you call <code>write</code> until <code>written</code> is as big as <code>count</code>, that is, until you've written all the bytes that you read.  This is ¡°clever¡± code, but it's actually too clever;  you actually need to check whether <code>written</code> is <code>-1</code>, or else you'll start doing some strange things.</p>

<p>Something with more error checking, and hopefully more idiomatic, might be:</p>

<pre><code>  for ( int count_in = -1; count_in != 0; ) {
    if ( -1 == (count_in = read(fd, buf, bufsize))) {
      perror(""Problem reading from file"");
      exit(-1);
    }
    else { 
      for ( int count_out = 0, out = 0; count_out &lt; count_in; count_out += out ) {
        if ( -1 == (out = write(fd, buf+count_out, count_in-count_out)) ) {
          perror(""Problem writing to file"");
          exit(-1);
        }
      }
    }
  }
</code></pre>
",2
11831495,11831458,6,"<pre><code>Cat exampleCat = createCat(""Bob"");
</code></pre>

<p>You can't do a method call here. Initialize <code>exampleCat</code> somewhere else.</p>

<p>This is explained in the spec, section 6.7.8/4:</p>

<blockquote>
  <p>All the expressions in an initializer for an object that has static storage duration shall be constant expressions or string literals.</p>
</blockquote>
",2
11831564,11831458,0,"<p>Try instead:</p>

<pre><code>void createCat(Cat * kitty, char name[64]) {
  int i;

  for(i = 0; i &lt; 64; i += 1) {
    kitty-&gt;name[i] = name[i];
  }
}

Cat exampleCat;
createCat(&amp;exampleCat, ""Bob"");
</code></pre>
",2
11832274,11831458,2,"<p>You really don't need to write a function to initialize a struct. You can just use an initializer where you give values to each member (only one here).</p>

<pre><code>Cat exampleCat = {""Bob""};
</code></pre>

<p>Also note that if you instead had used C++, you would have the option of using a dynamic initializer, and the code would be ok.</p>
",0
8721241,8721189,23,"<p>You need a structure comparator function that matches the prototype of the function expected by <code>qsort()</code>, viz:</p>

<pre><code>int md_comparator(const void *v1, const void *v2)
{
    const mydata *p1 = (mydata *)v1;
    const mydata *p2 = (mydata *)v2;
    if (p1-&gt;id &lt; p2-&gt;id)
        return -1;
    else if (p1-&gt;id &gt; p2-&gt;id)
        return +1;
    else
        return 0;
}
</code></pre>

<p>If you ever get to a more complex sort criterion, this is still a good basis because you can add secondary criteria using the same skeleton:</p>

<pre><code>int md_comparator(const void *v1, const void *v2)
{
    const mydata *p1 = (mydata *)v1;
    const mydata *p2 = (mydata *)v2;
    if (p1-&gt;latitude &lt; p2-&gt;latitude)
        return -1;
    else if (p1-&gt;latitude &gt; p2-&gt;latitude)
        return +1;
    else if (p1-&gt;longitude &lt; p2-&gt;longitude)
        return -1;
    else if (p1-&gt;longitude &gt; p2-&gt;longitude)
        return +1;
    else
        return 0;
}
</code></pre>

<p>Clearly, this repeats for as many criteria as you need.  If you need to call a function (<code>strcmp()</code>?) to compare values, call it once but assign the return to a local variable and use that twice:</p>

<pre><code>int md_comparator(const void *v1, const void *v2)
{
    const mydata *p1 = (mydata *)v1;
    const mydata *p2 = (mydata *)v2;
    int rc;
    if (p1-&gt;latitude &lt; p2-&gt;latitude)
        return -1;
    else if (p1-&gt;latitude &gt; p2-&gt;latitude)
        return +1;
    else if (p1-&gt;longitude &lt; p2-&gt;longitude)
        return -1;
    else if (p1-&gt;longitude &gt; p2-&gt;longitude)
        return +1;
    else if ((rc = strcmp(p1-&gt;name_dyn, p2-&gt;name_dyn)) &lt; 0)
        return -1;
    else if (rc &gt; 0)
        return +1;
    else
        return 0;
}
</code></pre>

<p>Also, this template works when data members are unsigned integers, and it avoids overflow problems when comparing signed integers.  Note that the short cut you might sometimes see, namely variations on:</p>

<pre><code>int md_comparator(const void *v1, const void *v2)   /* BAD */
{                                                   /* BAD */
    const mydata *p1 = (mydata *)v1;                /* BAD */
    const mydata *p2 = (mydata *)v2;                /* BAD */
    return(p1-&gt;id - p2-&gt;id);                        /* BAD */
}                                                   /* BAD */
</code></pre>

<p>is bad if <code>id</code> is unsigned (the difference of two unsigned integers is never negative), and subject to overflow if the integers are signed and of large magnitude and opposite signs.</p>
",4
9158814,9158745,3,"<p>The source is being compiled for UNICODE. There are two available functions:</p>

<ul>
<li>FindFirstFileA (ANSI version)</li>
<li>FindFirstFileW (Wide character version)</li>
</ul>

<p>when building for UNICODE <code>FindFirstFile</code> is actually <code>FindFirstFileW</code>, otherwise <code>FindFirstFile</code> is <code>FindFirstFileA</code>.</p>

<p>The compiler is complaining that you are passing <code>char*</code> instead of a wide character buffer.</p>

<p>You need to do one of the following:</p>

<ul>
<li>to compile not for UNICODE</li>
<li>explicity call <code>FindFirstFileA()</code></li>
<li>use a wide character buffer</li>
</ul>

<p>Also, there are a few bugs in the code:</p>

<pre><code>sprintf(cd,""%s"",Path);
</code></pre>

<p>But <code>cd</code> is a <code>char*</code> and is never set to point to any allocated memory, similar problem for <code>schar</code> and <code>Buffer</code>. You need to determine the full length of the path that you need to construct, allocate memory and then construct the path (remember to <code>free()</code> the allocated buffer).</p>
",2
15865441,15865404,4,"<blockquote>
  <p>but to my surprise it happily soldiers on</p>
</blockquote>

<p>You have three nested loops. A newline would terminate one of the inner loops, while the outermost loop would happily carry on (until you've hit <kbd>Enter</kbd> <code>lim</code> times).</p>

<p>I can give you a hint: you probably shouldn't be using nested loops for this.</p>
",2
15866546,15865404,2,"<p>You have added loops that didn't exist in the original ... that's conceptually and logically wrong. The most obvious solution uses <code>break</code>:</p>

<pre><code>for (i = 0; i &lt; lim-1; ++i)
{
    c = getchar();
    if (c == '\n')
        break;
    if (c == EOF)
        break;

    s[i] = c;
}
</code></pre>

<p>Or if you're pretending that C doesn't have <code>break</code>, you can do something like this (this is not exactly equivalent because <code>i</code> doesn't have the same value if <code>'\n'</code> or <code>EOF</code> is encountered):</p>

<pre><code>for (i = 0; i &lt; lim-1;)
{
    c = getchar();
    if (c == '\n')
        i = lim-1;
    else if (c == EOF)
        i = lim-1;
    else
        s[i++] = c;
}
</code></pre>

<p>Or you can use the Pascal approach:</p>

<pre><code>#include &lt;stdbool.h&gt;
...
i = 0;
bool more = i &lt; lim-1;

while (more)
{
    c = getchar();
    if (c == '\n')
        more = false;
    else if (c == EOF)
        more = false;
    else
    {
        s[i++] = c;
        more = i &lt; lim-1;
    }
}
</code></pre>
",2
16395283,7656119,0,"<p>This will give you correct output.</p>

<pre><code>void occurrence(char str[100], char ch)
</code></pre>

<p>{
    int count=0,max = 0,i = 0;  </p>

<pre><code>while(str[i]!='\0')
{
    max = max + 1;

    if( str[i] == ch )
    {
    count = count + 1;
    }
    i++;
}
</code></pre>

<p>}</p>
",0
13468674,13468288,0,"<p>The last lines of your log suggest your application is crashing on startup.</p>

<blockquote>
  <p>First-chance exception at 0x007ff9ba in Automation.exe: <strong>0xC0000005: Access violation reading location 0x00000000.</strong> First-chance exception at 0x007ff82f in Automation.exe: 0xC0000005: Access violation reading location 0x00000000. The program '[400] Automation.exe: Native' has exited with code 1 (0x1).</p>
</blockquote>

<p>Set a breakpoint on main and then step through your code to see where it crashes. Under VS you should actually see a dialog when the exception is thrown. There you can click <code>Debug</code> to stop execution and see the stack trace.</p>
",1
10826282,10826264,2,"<p>You don't have a return value in fun() function, so the value returned is undefined.</p>
",0
10826294,10826264,1,"<p>It might be returning whatever's in the EAX register, which is probably unreliable without an explicit return value:</p>

<p><a href=""https://stackoverflow.com/a/4644913/375399"">https://stackoverflow.com/a/4644913/375399</a></p>
",0
10826321,10826264,-1,"<p>It depends on compiler.
That's my output, for your information</p>

<p>compiler: i686-apple-darwin11-llvm-gcc-4.2</p>

<pre><code>crap
return value of fun 0
</code></pre>
",0
11575324,11575174,1,"<pre><code>#include&lt;stdio.h&gt;
int main()
{
 unsigned char a[3];
 unsigned char b[3];
 unsigned char *l[2];

 a[0] = 0; a[1] = 1; a[2] = 2;
 b[0] = 3; b[1] = 4; b[2] = 5;

 l[0] = a; l[1] = b;
 if(strncmp(l[0], l[1], 3) != 0) {
   printf(""Compared not same"");
 }
 return 0;
}
</code></pre>
",1
11577632,11575174,0,"<p>Not sure about <em>storing arrays in an array</em>, but you should use <code>memcmp</code> instead of <code>strcmp</code> to compare arrays (because <code>strcmp</code> compares strings, and your arrays are not strings).</p>

<pre><code> unsigned char a[3];
 unsigned char b[3];
 unsigned char *l[2]; // note: corrected a few errors in this line
 int i = 0;

 a[0]=0;
 a[1]=1;
 a[2]=2;
 b[0]=3;
 b[1]=4;
 b[2]=5;

 l[0]=a;
 l[1]=b;
 if(memcmp(l[0],l[1], sizeof(a))==0) { // note: have to specify the length
   printf(""Compared same""); // note: reveresed the logic
 }
</code></pre>
",0
11575600,11575174,0,"<pre><code>int main()
{
    char a[3] = {1, 1, 2};
    char b[3] = {1, 4, 5};
    char *l[2]= {a, b};

    printf( (strncmp(l[0], l[1], 3)==0) ? ""Compared are equal"" : ""Compared are not equal"");

 return 0;
}
</code></pre>

<p>And note, that 0 is the end of the line, so as arrays of chars [0, 1, 2] and [0, 5, 5] are equal. Also, if you don't have a 0 in such array, it may cause an errors because it will be endless array and will try to get values from memory that is not for this array. You really should start with any good c/c++ book about basics of the language.</p>
",0
11575642,11575174,1,"<pre><code>#include&lt;stdio.h&gt;
int main()
{
  unsigned char a[3];
  unsigned char b[3];
  unsigned char *l[2];

  a[0] = '3'; a[1] = '4'; a[2] = '\0';
  b[0] = '3'; b[1] = '4'; b[2] = '\0';

  l[0] = a; l[1] = b;
  if(strcmp(l[0], l[1]) != 0) {
    printf(""Compared not same"");
  } else {
    printf(""Compared same"");
  }
  return 0;
}
</code></pre>
",0
11581796,11581759,3,"<p><code>%c</code> tells <code>printf</code> to interpret the <code>char</code> argument as a character code (most likely ASCII).  Use <code>%d</code> instead.</p>
",0
11581803,11581759,4,"<p>b is a pointer in itself, you have to dereference it to get the actual values:</p>

<pre><code>printf(""%d"", *b);
b++;
printf(""%d"", *b);
b++;
</code></pre>

<p>etc.</p>
",0
11581829,11581759,2,"<pre><code>#include&lt;stdio.h&gt;
int main(){
 char a[3];
 char *b=NULL;
 a[0]='0';
 a[1]='1';
 a[2]='2';
 b = a;
 printf(""%c"",*b);
 b++;
 printf(""%c"",*b);
 b++;
 printf(""%c"",*b);
 return 0;
}
</code></pre>
",0
14818369,10637027,0,"<p>I would probably do this:</p>

<pre><code>struct outer_init {
  struct inner_init {
    int c;
    int x;
  } i;
  int y;
};

struct outer_init *oi = malloc(sizeof *oi);
oi-&gt;y = find_y();
oi-&gt;i.c = find_c();
oi-&gt;i.x = find_x();

struct outer *o = (struct outer *)oi;
</code></pre>

<p>I am not completely sure that it is absolutely portable though.</p>
",0
10797302,10797168,1,"<p>The problem with using <code>scanf</code> is that it expects something, not an empty string. You solve this by using e.g. <code>fgets</code> instead of <code>scanf</code>:</p>

<pre><code>if (fgets(strings[n].str, sizeof(strings[n].str), stdin))
{
    /* You got a string, it will contain the newline! */
}
</code></pre>
",0
10797432,10797168,2,"<p>You shouldn't use strlen to find out if the input is empty.  As others have said, when you press ENTER you get one or two characters sent to you.  </p>

<p>You could instead check the first character in the string and see if it is <code>'\n'</code> or <code>'\r'</code></p>
",0
10797220,10797168,5,"<p>The enter key is not empty string, it is an ascii character or rather two characters a CR and LF (on Windows).</p>
",2
10797230,10797168,1,"<p><code>scanf</code> returns exactly what you've input... i.e. a crlf pair I'd imagine!</p>
",1
13751886,13751837,17,"<p>This is because the array subscript operator is commutative, i.e., this:</p>

<pre><code>const char *p = ""Hello"";
char x = p[0];
</code></pre>

<p>Is equivalent to</p>

<pre><code>const char *p = ""Hello"";
char x = 0[p];
</code></pre>

<p>Weird, huh?  In your case you are indexing into the third position of the string literal (which is an array) <code>""nsew""</code>.  </p>

<p><code>some_ptr[n]</code> is equivalent to <code>*(some_ptr + n)</code>, and since addition is commutative, it is also equivalent to <code>*(n + some_ptr)</code>. It then follows that <code>n[some_ptr]</code> is also an equivalent expression. </p>

<p>I wouldn't recommend using this ""feature"" however... seriously, don't do it.</p>
",8
13751936,13751837,8,"<p>Operator <code>[]</code> has the same semantics as pointer arithmetics. So <code>a[i]</code> is equivalent to <code>*(a + i)</code> which is equivalent to <code>*(i + a)</code> which is equivalent to <code>i[a]</code>:</p>

<p>So <code>direction[""nsew""]</code> == <code>""nsew""[direction]</code> == <code>""nsew""[3]</code> == <code>'w'</code></p>
",1
10138642,10138624,3,"<p>You should be using <code>strcmp</code> to compare strings.  Rather than this:</p>

<pre><code>if (ent-&gt;d_name == ""."")
</code></pre>

<p>you need this:</p>

<pre><code>if (strcmp(ent-&gt;d_name, ""."") == 0)
</code></pre>

<p>Your code is comparing the pointers directly, rather than comparing the content of the strings.</p>

<p>See <a href=""http://www.cplusplus.com/reference/clibrary/cstring/strcmp/"" rel=""nofollow"">the strcmp documentation</a> for more information.</p>
",0
10138644,10138624,1,"<p>You need to use <code>strcmp</code> to do the comparison.</p>
",0
10138666,10138624,0,"<p>string is not native c data-type, string is represented as collection of characters. So to compare string there are no operators rather function, <strong>strcmp()</strong> for more information.</p>
",0
12815324,5439895,0,"<p>That seems to be rather complicated code for finding the sequence when you can simply unroll a bubble sort (and, before anyone attacks the use of the bubble sort, you should be aware that it's perfectly acceptable in certain cases, such as where the data is already mostly sorted, or where the data set is small - in those cases, it can very often outperform other sorts):</p>

<pre><code>#include &lt;stdio.h&gt;

void orders_char(int c1, int c2, int c3) {
    int tmp;

    // Unrolled bubble sort for three elements.

    if (c1 &gt; c2) { tmp = c1; c1 = c2; c2 = tmp; }
    if (c2 &gt; c3) { tmp = c2; c2 = c3; c3 = tmp; }
    if (c1 &gt; c2) { tmp = c1; c1 = c2; c2 = tmp; }

    printf(""Ordered characters are: %c %c %c\n"", c1, c2, c3);
}

int main (void) {
    char c1, c2 ,c3;
    printf(""Please enter 3 capital letters with no spaces: \n"");
    scanf(""%c%c%c"", &amp;c1, &amp;c2, &amp;c3);
    orders_char(c1, c2, c3);
    return 0;
}
</code></pre>

<p>The function above simply moves the elements around to the correct order with the judicious use of three compares and zero to three swaps, then prints them out. You can swap them around within the function since they're only local variables in there and won't affect what was passed in from the caller.</p>

<p>If you comment out the prompt line (the <code>printf</code> in the <code>main()</code> function), and execute the following script, you can see that it works for all inputs:</p>

<pre><code>pax&gt; for i in abc acb bac bca cab cba ; do
...&gt;     echo $i | ./sort3
...&gt; done
Ordered characters are: a b c
Ordered characters are: a b c
Ordered characters are: a b c
Ordered characters are: a b c
Ordered characters are: a b c
Ordered characters are: a b c
</code></pre>
",0
18732120,18732095,1,"<p>Writing into the heap beyond a valid malloc'ed location results in undefined behavior. It may or may not result in a seg fault. Depends on what is in the heap location and how it is used by the rest of the program.</p>

<p>Your program may not fail at all. But it does corrupt the heap so eventually, if you program was longer you would see problems. Hard to find problems.</p>
",0
18732164,18732095,1,"<p>As you know, your program invokes <strong>undefined</strong> behaviour. <strong>Undefined</strong> doesn't mean ""guaranteed to segfault under all circumstances""; <strong>undefined</strong> means ""a conforming implementation of the C compiler can output a program which does anything"".</p>
",0
18732172,18732095,0,"<p>Don't try to <em>understand</em> undefined behaviour, the whole point of calling it undefined is to make it clear that <em>anything</em> can happen.</p>

<p>In fact, the most annoying aspect of UB is that it sometimes works. At least if it failed consistently, a whole class of bugs would never hit the field.</p>

<p>Trying to understand UB is like trying to understand cats (or some ex-girlfriends). You may <em>think</em> you've got it sorted but then they'll turn on you :-)</p>

<p>Rather than understand, you should simply avoid.</p>
",4
14735763,14735674,7,"<p>The description of <code>snprintf</code> in the C standard (C99, 7.19.6.5) says:</p>

<blockquote>
  <p>If copying takes place between objects that overlap, the behavior is unde?ned.</p>
</blockquote>

<p>This is what happens here since <code>str</code> is used as both the input and output.</p>

<p>The same restriction applies to <code>sprintf</code>. The fact that it happened to work for you is just an accident, as can happen with undefined behavior.</p>
",0
8736667,8736615,7,"<p>Since <code>pstTask</code> is a global variable, this line:</p>

<pre><code>psTask *pstTask;
</code></pre>

<p>is equivalent to this:</p>

<pre><code>psTask *pstTask = 0x00000000;
</code></pre>

<p>and since you never later change it to point anywhere else (e.g., to properly allocated memory), this line:</p>

<pre><code>    memset(&amp;(pstTask-&gt;stData), 0xFF, sizeof(pstTask-&gt;stData));
</code></pre>

<p>is equivalent to this:</p>

<pre><code>    memset(0x00000000, 0xFF, sizeof(pstTask-&gt;stData));
</code></pre>

<p>(since <code>stData</code> is the first element of the <code>psTask</code> structure, so has an offset of zero). This means that you're trying to write <code>0xFF</code> into memory location <code>0x00000000</code> (as well as the subsequent 47 bytes or so), rather than to memory that you actually have permission to write to (e.g. stack space, or space returned by <code>malloc</code>).</p>

<hr>

<p><strong>Update</strong> for updated question:</p>

<p>This bit:</p>

<pre><code>    pstTask = (psTask*)malloc(sizeof(psTask));
    pstTask = NULL;
</code></pre>

<p>allocates memory for a <code>psTask</code> and points <code>pstTask</code> at it &mdash; so far so good &mdash; but then it sets <code>pstTask</code> right back to <code>NULL</code> (i.e., not pointing anywhere valid). You need to remove that second line.</p>

<p>Also, after calling <code>malloc</code> you should always examine its return value; if it returns <code>NULL</code>, that means you're out of memory. So, you should write something like this:</p>

<pre><code>    pstTask = (psTask*)malloc(sizeof(psTask));
    if(pstTask == NULL)
    {
        fprintf(stderr, ""Out of memory.\n"");
        return 1;
    }
    printf(""\npstTask-&gt;stData = %u\n"",&amp;pstTask-&gt;stData);
</code></pre>

<p>(In this specific case, I'm sure that <code>malloc</code> will successfully return allocated memory, but you should really <em>always</em> check its return value.)</p>
",5
10025559,10025502,2,"<p><code>proc</code> is indirectly calling <code>fun</code> via a function pointer. The arguments that <code>fun</code> receives are again <code>6</code> and <code>6</code>, and the equality operator evaluates to an <code>int</code> with the value <code>1</code> because they are equal. If they were not equal, the <code>==</code> operator would yield <code>0</code>.</p>
",0
10025615,10025502,1,"<p>In main the first line</p>

<pre><code>printf(""%d\n"",proc(fun,6,6));
</code></pre>

<p>is calling proc which is taking argument a function pointer and two integer values. Function pointer pf is defined as <code>typedef int(*pf) (int,int);</code>
 This line <code>printf(""%d\n"",proc(fun,6,6));</code> will call the function defined as:</p>

<pre><code>int proc(pf p,int a,int b){
return ((*p)(a,b));
}
</code></pre>

<p>Now in this function pf holds the pointer to function fun. This will cause the function fun to be called which is returning whether the values of a and b are true or not. Since you have passed 6,6 as the arguments the result will be true and that is why you are getting as 1 as an Answer.</p>
",0
10025738,10025502,0,"<pre><code>int fun(int,int); 
</code></pre>

<p>function takes 2 int arguments and returns an int</p>

<pre><code>typedef int(*pf) (int,int); 
</code></pre>

<p>pf is a function pointer that store the address of address of a  function which takes two ints as its agrs and returns an int</p>

<pre><code>int proc(pf,int,int); 
</code></pre>

<p>proc is a function which takes 3 args first is a function pointer to a function like above and two integer args.</p>

<pre><code>proc(fun,6,6);
</code></pre>

<p>above statement calls fun with two args 6 and 6 and returns true if they are equal which is how the result is 1</p>
",0
16952633,16952606,7,"<p>Your problem is not with function prototyping (aka forward declaration).  You just can't return an array from a function in C.  Nor can you assign to an array variable.  You need to make a couple of changes to get things working.  One option:</p>

<ol>
<li>change <code>char cleanWord[30]</code> in <code>main</code> to be <code>char * cleanWord</code>.</li>
<li>change the signature of <code>clean</code> to <code>char *clean(char word[30])</code></li>
<li>use <code>malloc</code> to allocate a destnation buffer inside <code>clean</code></li>
<li>return a pointer to that new buffer</li>
<li>free the buffer in <code>main</code></li>
</ol>

<p>And another:</p>

<ol>
<li>change the signature of <code>clean</code> to <code>void clean(char word[30], char cleanWord[30])</code></li>
<li>operate on the passed-in pointer rather than a local array in <code>clean</code></li>
<li>change the call in <code>main</code> to be <code>clean(word, cleanWord)</code>.</li>
</ol>
",0
16952672,16952606,3,"<p>As Carl Norum said, you can't return an array.  Instead, what you tend to do is supply the output:</p>

<pre><code>void clean( const char word[30], char cleanWord[30] )
{
}
</code></pre>

<p>And you should remove the locally-scoped array from that function.</p>

<p>You will find that the function does not work correctly, because you only have one iterator <code>i</code>.  That means if a character is not an alpha, you will skip over a position in the output array.  You will need a second iterator that is incremented only when you add a character to <code>cleanWord</code>.</p>
",0
16952782,16952606,3,"<p>A couple of notes (was a bit late with writing up an answer, seems I've been beaten to them by the others )</p>

<ol>
<li><p>C cannot return local (stack) objects, if you want to return an array from a function you have to <code>malloc</code> it</p></li>
<li><p>Even if you declare an array argument as <code>(char arr[30])</code>, <code>(char* arr)</code> is just as valid as arrays decay to pointers when passed as arguments to functions. Also, you won't be able to get the size correctly of such arrays by using <code>sizeof</code>. Even though it's 30, on my machine it returns 4 for <code>word</code> in <code>clean</code>, which is the size of the pointer for it.</p></li>
<li><p>You are missing an include, <code>isalpha</code> is part of <code>ctype.h</code></p></li>
</ol>

<p>I've updated your code, hopefully I've guessed your intentions correctly:</p>

<pre><code>#include &lt;stdlib.h&gt; /* for malloc and free */
#include &lt;string.h&gt; /* for strlen */
#include &lt;ctype.h&gt;  /* for isalpha */
#include &lt;stdio.h&gt;  /* for printf */

/* Function declaration */
char* clean(char word[30]);

/* your 'main()' would now look like this: */
int main()
{
    char word[30] = ""hel1lo1"";

    char* cleanWord;

    cleanWord = clean(word);

    printf(""%s\n"", cleanWord);

    free(cleanWord);

    return 0;
}

/* Function definition */
char* clean(char word[30])
{
    char* cleanWord = malloc(30);   /* allocating dynamically an array of 30 chars, 
                                     * no need to use sizeof here as char is 
                                     * guaranteed to be 1 by the standard 
                                     */

    unsigned int i, j = 0; /* let's fix the problem with non-alpha chars already pointed out */

    for (i = 0; i &lt; (strlen(word)); i++)
        if (isalpha(word[i]))
            cleanWord[j++] = word[i]; 


    cleanWord[j] = '\0';

    return cleanWord; 
    /* return a pointer to the malloc`ed array, don't forget to free it after you're done with it */
}
</code></pre>
",0
11564584,11564187,0,"<ol>
<li><p>You should use below function to control the variable parameter.</p>

<pre><code>void va_start( va_list arg_ptr, prev_param );   
type va_arg( va_list arg_ptr, type );   
void va_end( va_list arg_ptr );  
</code></pre></li>
<li><p>Judge the format string. using switch () statement judge <code>%d</code>, <code>%c</code>, <code>%s</code> and so on</p></li>
</ol>
",0
11564612,11564187,2,"<p>The comment above points you in the right direction, but here is an example of how to prepend your tag (Hello).  </p>

<p>Notes:
I have used the <em>s</em> and <em>n</em> version of <em>printf</em> to format a new string that shouldn't overflow my temp buffer, and *MAX_MSG_SIZE* is assumed to be defined appropriately elsewhere.</p>

<pre><code>void printf2(const char *format, ...)
{

    char buffer[MAX_MSG_SIZE] = """";  


    va_list args;


    va_start(args,format);
    vsnprintf(buffer, MAX_MSG_SIZE, format, args);
    va_end(args);   

    printf(""Hello: %s\n"", buffer);
}
</code></pre>
",3
11568252,11564187,0,"<pre><code>void print_message(char *format, ...)
{
    printf(""%s"", ""Hello: "")
    va_list ptr;
    va_start(ptr, format);
    vprintf(format, ptr);
    va_end(ptr);
}
</code></pre>

<p>Note:</p>

<ol>
<li>printf(""%s"", ""Hello: "") is bit faster than printf(""Hello: "") (by
skipping scan of the format string phase)</li>
<li>printf(message); is REALLY bad idea. It crash when message has something like ""%s"".</li>
</ol>
",0
15802341,15802207,1,"<p>The crash is most likely here:</p>

<pre><code>repLetters[((letters1[i]) - 97)] +=1;
</code></pre>

<p>What if <code>letters1</code> doesn't contain 26 characters? You are now accessing an array out of bounds.</p>

<p>The only way to know for sure, is to run your program in a debugger (which you <em>always</em> should do when you have a crash).</p>
",2
18731727,18731714,3,"<pre><code>int *ptr1 = malloc ( 2 );
</code></pre>

<p>You are allocating 2 bytes for an <code>int</code>, which is normally at least 4 bytes in modern machine.</p>

<pre><code>*(ptr1+2) = 0xabcd;
</code></pre>

<p>Pointer arithmetic is only valid if they are pointing to elements of an array or one past it, otherwise it's undefined behavior, as it is here.</p>
",6
18731808,18731714,5,"<p><code>malloc</code> is required to give you the amount of bytes you requested (or NULL, obviously) but there is no rule against giving you <em>more.</em> It typically works on (for example) 16-byte (<code>0x10</code>) boundaries to efficiently allocate memory.</p>

<p>That's not to say you're allowed to <em>use</em> more than what you asked for, that's undefined behaviour (UB).</p>

<p>In other words, this is not allowed:</p>

<pre><code>int *ptr1 = malloc (2);
*(ptr1+3) = 0xbeee;
</code></pre>

<p>since an integer must be at least the size of a byte/character so there's no way two bytes can give you four integers.</p>

<p>So, even if your integers <em>were</em> two bytes long (and they're probably not nowadays), this statement is trying to set the <em>fourth</em> integer in that array to a value. Think of it this way (for four-byte integers):</p>

<pre><code>        +---------------+
ptr1 -&gt; | You can use   | \
        | these 2 bytes.|  \
         ---------------    *ptr1
        | But not these |  /
        | two.          | /
         ---------------
        |               | \
        |               |  \*(ptr1+1)
        |               |  /
        |               | /
        | Nor any of    | \
        | these         |  \*(ptr1+2)
        |               |  /
        |               | /
        |               | \
        |               |  \*(ptr1+3)
        |               |  /
        |               | /
        +---------------+
ptr2 -&gt; |               |
</code></pre>

<p>It's actually very unusual (and rather bad practice) to use magic numbers in code, a preferable solution would be:</p>

<pre><code>int *ptr1 = malloc (sizeof (*ptr1) * N);
</code></pre>

<p>to get an array of <code>N</code> elements of your given data type.</p>

<p>As to <em>why</em> you see certain things happening, it really doesn't matter. Once you get into UB territory, all bets are off. <em>Anything</em> can happen, from things working as expected to a naked singularity forming inside your CPU which end up swallowing the Earth.</p>

<p>Bottom line, don't do it :-)</p>
",1
18732189,18731767,0,"<blockquote>
  <h3>C11 J.5.7 Function pointer casts</h3>
  
  <p>1 A pointer to an object or to <code>void</code> may be cast to a pointer to a function, allowing data to be invoked as a function (6.5.4).</p>
  
  <p>2 A pointer to a function may be cast to a pointer to an object or to <code>void</code>, allowing a
  function to be inspected or modified (for example, by a debugger) (6.5.4).</p>
</blockquote>

<p>You are fine if you only cast the array name to a function pointer, but it's undefined behavior that you call it because it's not actually a function.</p>

<p>You can try storing actual function pointer addresses in the array and then cast it back to function pointer and call them. However, <code>unsigned char</code> still won't work because it's too small, use <code>uintptr_t</code> instead.</p>
",0
18732048,18731767,1,"<p>Since the pointer to the first element of the array is not a pointer to a function, you invoke undefined behaviour by calling a 'function' via the variable <code>function</code>.  When you invoke undefined behaviour, anything can happen.  A crash with an illegal instruction is perfectly legitimate; so is wiping all the data off your disk.</p>

<p>There is nothing that can be 'expected' according to the standards.  As hinted in the comments, what is likely to happen is that the bytes stored on the stack in the array <code>insn</code> (and in the rest of the stack, with the stack frame for <code>main()</code> and things like the argument list and the environment variables) will be treated as machine code.  Fortunately for you, one of the bytes is an invalid (or illegal) instruction, and the program stops.</p>
",0
9823381,9823212,2,"<p>Each function in C allows you to return a single value.</p>

<pre><code>int assign(......)
 ^
 |
output type
</code></pre>

<p>You do so by using the <code>return</code> keyword. A function that returns something, is like any other expression with the same type.</p>

<p>For example, if you have:</p>

<pre><code>int assign(void)
{
    return 10;
}
</code></pre>

<p>all of the following are valid:</p>

<pre><code>int a = assign();
int b = (assign()*20)-assign()/assign();
</code></pre>

<p>The reason why you might need to use pointers in arguments is to have more than a single output.</p>

<p>For example, take a function that goes over an array and returns the minimum and maximum:</p>

<pre><code>void minmax(int *array, int size, int *minimum, int *maximum)
{
    int i;
    int min_overall = INT_MAX;
    int max_overall = INT_MIN;
    /* error checking of course, to make sure parameters are not NULL */
    /* Fairly standard for: */
    for (i = 0; i &lt; size; ++i)
    {
        if (array[i] &lt; min_overall)
            min_overall = array[i];
        if (array[i] &gt; max_overall)
            max_overall = array[i];
    }
    /* Notice that you change where the pointers point to */
    /* not the pointers themselves: */
    *minimum = min_overall;
    *maximum = max_overall;
}
</code></pre>

<p>and in your <code>main</code>, you can use it like this:</p>

<pre><code>int arr[100];
int mini, maxi;
/* initialize array */
minmax(arr, 100, &amp;mini, &amp;maxi);
</code></pre>

<p><strong>Edit</strong>: Since you asked if there is any other way to do it, here is an example (although I absolutely do NOT recommend it for a usage like yours):</p>

<pre><code>struct assign_ret
{
    int return_value;
    int assigned_value;
};

struct assign_ret assign(void)
{
    assign_ret ret;
    ret.assigned_value = 10;
    ret.return_value = 0;
    return ret;
}
</code></pre>

<p>and in <code>main</code>:</p>

<pre><code>struct assign_ret result = assign();
if (result.return_value != 0)
    handle_error();
a = result.assigned_value;
</code></pre>

<p>The reason why I don't recommend this, is that <code>struct</code> is used to place data that are relevant together. Function error return value and its data output are not relevant.</p>
",0
19017674,19017625,1,"<p><code>strtok</code> changes the input string (which is why you can't use a const/read-only string as input).  Basically, at each break, it replaces the separator with <code>\0</code> to terminate it.</p>

<p>It also stores some state globally, which is how it knows where the next item starts.  </p>

<p>If you want to know where each word is, you need to keep track of each pointer returned from each <code>strtok</code> call.</p>
",1
19017675,19017625,0,"<p>From man strtok(), see the bold highlight.</p>

<p>The strtok() function is used to isolate sequential tokens in a null-ter-
     minated string, str.  These tokens are separated in the string by at
     least one of the characters in sep.  <strong>The first time that strtok() is
     called, str should be specified; subsequent calls, wishing to obtain fur-
     ther tokens from the same string, should pass a null pointer instead.</strong>
     The separator string, sep, must be supplied each time, and may change
     between calls.</p>

<p>So, it changes the string in place and it keeps a variable between calls.</p>
",0
19017683,19017625,2,"<p>what <code>strtok</code> does behind the scenes is put <code>\0</code> wherever the delimiter character is found. This is why you pass in <code>NULL</code> the subsequent times after the first call to <code>strtok</code> (it keeps track of its next starting positional state).</p>

<p>When you print out <code>str</code> it is still a pointer to the start of your original string to tokenize but the first delimiter is now a <code>\0</code>. <code>printf</code> only prints up to a <code>\0</code>.</p>
",2
18206370,5711268,0,"<p>Here is a nice easy way to pass dynamically allocated arrays to a function. </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void Function(int ***Array);

int main()
{
    int i, j, k, n=10;

    //Declare array, and allocate memory using malloc. ( Dimensions will be 10 x 10 x 10)
    int ***Array=(int***)malloc(n*sizeof(int**));
    for (i=0; i&lt;n; i++)
    {
        Array[i]=(int**)malloc(n*sizeof(int*));
        for (j=0; j&lt;n; j++)
        {
            Array[i][j]=(int*)malloc(n*sizeof(int));
        }
    }

    //Initialize array in a way that allows us to check it easily (i*j+k).
    for (i=0; i&lt;n; i++)
    {
        for (j=0; j&lt;n; j++)
        {
            for (k=0; k&lt;n; k++)
            {
                Array[i][j][k]=i*j+k;
            }
        }
    }
    //Check array is initialized correctly.
    printf(""%d\n"", Array[4][5][6]);

    //Pass array to Function.
    Function(Array);

    //Check that Function has correctly changed the element.
    printf(""%d\n"", Array[4][5][6]);

    return 0;
}

void Function(int ***Array)
{
    //Check that Function can access values correctly.
    printf(""%d\n"", Array[4][5][6]);
    //Change an element.
    Array[4][5][6]=1000;
}
</code></pre>

<p>I know this is not specific to your matrix multiplication, but it should demonstrate how to pass the array to the function. It is quite likely that your function would need to know the dimensions of the array, so pass those to it as well... <code>void Function(int ***Array, int n)</code> and call the function as <code>Function(Array, n);</code></p>
",0
10125740,10125664,1,"<p><strong>Hexadecimal and Octal are just different representations of the same underlying number format. ie binary</strong>. So no conversion is really happening in your example. Its just that you are interpreting/printing the same number in 2 different ways. And <code>printf</code> is indeed doing a good job in your example</p>

<pre><code>Enter the Hax number: FF
Octal equivalent of number is 377
</code></pre>

<p>The only other problematic thing I can see is <code>Void</code> main :)</p>
",1
10125758,10125664,1,"<p>other than your syntax errors this seems to be working, I just copied it. change </p>

<pre><code>Void main()
</code></pre>

<p>to</p>

<pre><code>int main() 
</code></pre>

<p>or</p>

<pre><code>//Since you are not using command line arguments this isn't necessary but valid
int main(int argc, char **argv)
</code></pre>

<p>and add a </p>

<pre><code>return 0; //not necessary but good practice
</code></pre>

<p>at the end of the method</p>

<p>EDIT:</p>

<p>also </p>

<pre><code>void main() 
</code></pre>

<p>will compile with many C compilers, but is invalid C (no current and prior standard sanctions it). Use <code>int</code> instead.</p>
",6
15560812,15560800,2,"<p><code>*q = *p</code> is the same thing as <code>q[0] = p[0]</code>. That's why printing <code>q[0]</code> works but printing <code>q[1]</code> doesn't. If you want to copy all the pointers you'll need either a <code>for</code> loop or <code>memcpy()</code>.</p>

<pre><code>memcpy(q, p, sizeof(p))
</code></pre>
",10
15561137,15560800,0,"<p>The problem here like Kevin mentioned is that what you have is an array of pointers... so in order to accomplish what you want you need to memcpy the pointers over into the other array. This is because (these are example values mind you :)</p>

<pre><code>p[0] = 0xaaa
p[1] = 0xbbb

*q == 0xaaa
</code></pre>

<p>so </p>

<pre><code>q[0] = 0xaaa
</code></pre>

<p>q[1] is junk</p>

<p>So you are not copying the array, only a single value :)
Hope this helps!</p>
",0
15561443,15560800,0,"<p>I understand what you want to do. You think you use "" *q = *p; "" to assign all pointers in p to q. But did you know that just assign p[0] to q[0], p and q are not pointers. They are just a array, you can't use this syntax to copy a whole array to another, but you can use memcpy or assign its elements one by one.</p>
",0
15561584,15560800,0,"<p>If I understand what you're trying to accomplish correctly, declare <code>q</code> as a double pointer <code>**q</code>, and assign it like this: <code>q = p</code>.</p>
",0
9790827,9790792,1,"<p>You didn't list an OS or an IDE but in Linux I have always used <code>grep</code>. I have yet to find an IDE that is good at tracking down typedefs especially since some are wrapped in macros. </p>
",0
11574328,11574283,4,"<p>Your variable <code>p</code> is an array, not a pointer. You can't re-assign an array to point somewhere else, so the line</p>

<pre><code>p = &amp;a;
</code></pre>

<p>is not valid.</p>

<p>Also, C indexes from 0 as you seem to know, so comparisons using index <code>[3]</code> for arrays of size 3 are not valid.</p>

<p>Further, in your comparison loop you're not actually using <code>i</code> to index, but instead always comparing using the invalid constant index <code>[3]</code>.</p>

<p>It's not very clear from your code (<code>q</code> is not used, for instance), but it <em>sounds</em> as if you want to do something like:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

unsigned char a[3];
unsigned char *p;

p = malloc(sizeof a);
if(p != NULL) /* If allocation succeeded, p is valid. */
{
  int i;

  memcpy(p, a, sizeof a);
  for(i = 0; i &lt; sizeof a; ++i)
  {
    if(p[i] == a[i])
      printf(""p[%d]:%d a[%d]:%d\n"", i, p[i], i, a[i]);
  }
  free(p);
}
</code></pre>

<p>Of course, this will always print all the numbers, since <code>memcpy()</code> will never fail to copy the memory. :)</p>
",0
11574849,11574283,1,"<p>Here You have declared the <strong>return type</strong> of main function as <strong>int</strong>, but you are not returning anything from it.
So <strong>return</strong> any <strong>integer</strong> value (like 1) or make the main function's return type <strong>void</strong>.</p>
",0
18898546,18898410,2,"<p>No,</p>

<pre><code>buffersRing[ringNum]+1 // refers to a pointer to an array element
</code></pre>

<p>is not the same as</p>

<pre><code>buffersRing[ringNum][1] // refers to the actual array element
</code></pre>

<p>The first one is the one you want.</p>
",0
10764283,10764210,4,"<p>I think the reason why you are getting ""random"" numbers is because you haven't initialized the <code>carry</code> variable. In the <code>for</code> loop, you are adding the un-initialized value of <code>carry</code> to the array which will cause undefined results.</p>
",0
14152105,14152080,1,"<p><code>string.h</code> already provides a <code>strcat</code> so just rename your function to something else.</p>
",0
14152112,14152080,1,"<p>There is already a <a href=""http://www.cprogramming.com/fod/strcat.html"" rel=""nofollow""><code>strcat</code></a> function defined in the <code>string.h</code> library, with the signature <code>char *strcat(char *Destination, char *Source);</code>. Your user-defined function conflicts with it. As C does not support overloading, you need to rename your function.</p>

<p>Before concatenating, you also have to declare your destination char array so that it has enough space to hold the concatenated string. If not, you will run over the array bound, which may cause strange problems. </p>

<p>Also, your strings should be null terminated, because the standard library relies on that to determine where the string ends. Without the null terminator, the <code>strlen</code> cannot figure out the string length (unless by accident the next memory location happens to have a NULL character - you should never rely on such accidents).</p>
",0
14152115,14152080,5,"<p>Your <code>strcat</code> doesn't have the <a href=""http://www.kernel.org/doc/man-pages/online/pages/man3/strcat.3.html"" rel=""noreferrer"">standard signature</a>:</p>

<pre><code>char *strcat(char *dest, const char *src);
</code></pre>

<p>You need to make it match if you want to include <code>string.h</code>.  Alternately, just give your implementation a different name (<code>my_strcat</code>, for example).</p>

<p>You probably also will want to null-terminate your test strings - those <code>strlen</code> calls are going to give you pretty interesting results otherwise.  In addition, to avoid writing past the end of your first string's allotted memory (and thereby causing undefined behaviour), make sure you give it enough space to fit the second string on the end.</p>
",0
14152119,14152080,1,"<p>Your function can't have that name since it is declared in string.h. Simply rename your function to myStrcat or something of that nature.</p>
",0
14152124,14152080,1,"<p>Replace <code>strcat</code> with <code>str_cat</code>, because your function name is conflicting with function already present in <code>string.h</code></p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

void main() {
  // string concatenation
  char str1[] = {'S', 'h'};
  char str2[] = {'X', 'y'};
  str_cat(str1, str2);
}

void str_cat(char str1[], char str2[]) {
  int index;
  int str1_length = strlen(str1);
  for(index=0; index&lt;strlen(str2); index++) {
    str1[index + str1_length] = str2[index];
  }
}
</code></pre>
",1
14152272,14152080,2,"<p>Aside from what others have said about the name conflict, you also don't have proper strings.</p>

<p>In C, strings end with a null-terminator (<code>\0</code>).</p>

<p>You've made your strings this way:</p>

<pre><code>char str1[] = {'S', 'h'};
</code></pre>

<p>So it only has two characters, S and h.</p>

<p>To make a string usable by functions such as <code>strlen</code>, it must have a null-terminator.<br>
I recommend:</p>

<pre><code>char str1[] = {'S', 'h', '\0'};
</code></pre>
",0
14152296,14152080,2,"<p>there is predefined function ""strcat"" in C language(in string.h) so when you are trying to call strcat then compiler seems conflict between that inbuild function and your defined function. So its better to rename your strcat function. </p>
",0
14154046,14152080,0,"<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

void mystrcat(char str1[], char str2[]);

void main() {
char str1[] = {'S', 'h' , '\0'};
char str2[] = {'X', 'y', '\0'};
mystrcat(str1, str2);
}

// string concatenation
void mystrcat(char str1[], char str2[]) {
int index;
int str1_length = strlen(str1);
for(index=0; index&lt;strlen(str2); index++) {
    str1[index + str1_length] = str2[index];
}
str1[index + str1_length] = '\0';
printf(""%s\n"",str1);
}
</code></pre>
",0
14153289,14152080,0,"<p>Just change your code as below:</p>

<pre><code> replace char str1[] = {'S', 'h'} by char str1[] = {'S', 'h', '\0'};
 replace char str2[] = {'X', 'y'} by char str2[] = {'X', 'y', '\0'};
</code></pre>
",0
14153484,14152080,2,"<p>There are many errors in your code. First, the strings str1 and str2 should be null terminated. You can correct that by changing their declarations to</p>

<pre><code>char str1[] = ""Sh"";
char str2[] = ""Xy"";
</code></pre>

<p>or to</p>

<pre><code>char str1[] = {'S', 'h', '\0'};
char str2[] = {'X', 'y', '\0'};
</code></pre>

<p>And secondly, <code>strcat</code> is a reserved name, so your main function doesn't call your version, but the version that is found at the header file <code>&lt;string.h&gt;</code>. You can correct this by either renaming your function, or by not including the header <code>string.h</code>. If you do the second one, you should also implement the function <code>strlen</code>, because it is found at <code>string.h</code>.</p>
",3
11861885,11861762,4,"<p>Your question literally boils down to-</p>

<blockquote>
  <p>Given a pointer, find the size of the memory block it is pointing to</p>
</blockquote>

<p>which is <em>impossible</em> and doesn't make sense as well. So to make this <em>hard</em> question simpler, you need to make some assumptions such as the pointer is a <code>char</code> pointer and <code>\0</code> would be treated as the <code>End-Of-Block</code> indicator. Then you can use functions like <code>strlen</code> etc</p>

<p>But in your given case none of this holds good and what you are doing ( using <code>MIN</code> ) seems OK and is as close you can get to what you want.</p>
",0
11862056,11861762,3,"<p>The concept which you are pointing to doesn't apply only to stack corruption. It is applied in general to avoid memory overflow. A memory overflow can lead to corruption of stack when used with stack variable, or heap when used with heap variable. Basically it leads to undefined behavior.</p>

<p>The best way to avoid this is to:</p>

<ol>
<li>To program correctly (i.e. with proper logic) as Kerrek SB correctly points out in his comment.</li>
<li>To use functions like strncpy instead of strcpy, strncat instead of strcat etc which will help in applying the same concept of safety which you have tried to apply here.</li>
</ol>

<p>The following two links about Secure Coding Guidelines and Practices might be of some help:</p>

<p><a href=""http://www.atsec.com/downloads/pdf/secure-coding-guidelines.pdf"" rel=""nofollow"">http://www.atsec.com/downloads/pdf/secure-coding-guidelines.pdf</a> <br>
<a href=""https://www.securecoding.cert.org/confluence/display/seccode/Top+10+Secure+Coding+Practices"" rel=""nofollow"">https://www.securecoding.cert.org/confluence/display/seccode/Top+10+Secure+Coding+Practices</a></p>
",1
9807096,9806746,0,"<p>None. What you probably mean for a start is <code>memset(a,0,sizeof(a));</code></p>

<p><code>a</code> is an array that is converted to a pointer in that context, no need to take the address. (The C FAQ has more information about arrays and pointers.)</p>

<p>Then for the rest of it you should revise your basic knowledge of C before you go further</p>

<pre><code>struct s{
 be b;
 int c;
 int d;
 int e;
}fe;


fe f;
</code></pre>

<p>Here the structure type is <code>struct s</code> and <code>fe</code> is a variable of that type. So the last line here makes no sense at all.</p>
",0
9806835,9806746,1,"<p><strong>Technique 3:</strong></p>

<pre><code>memset(&amp;a,0,sizeof(a));
f.b.ab = a;
f.b.ac = MAX;
</code></pre>

<p>because both <code>a</code> and <code>fb.b.ab</code> will have clear memories with only <strong>one</strong> <code>memset()</code> call. Any other kind of optimization you might been hoping for is insignificant.</p>
",10
9807274,9806746,1,"<p>None of the above. The best would be:</p>

<pre><code>int a[MAX] = { 0 };
fe f = { .b.ab = a, .b.ac = MAX };
</code></pre>
",2
12812752,12812712,3,"<p><code>memcpy</code> could be used implicitly by the compiler to perform ""long"" copying operations (like struct assignment). For example, in your code you are doing</p>

<pre><code>initrd_file_header_t header = file_headers[node-&gt;inode];
</code></pre>

<p>which looks like a good candidate for something that will actually be translated into an <code>memcpy</code> call.</p>

<p>Is there a reason you create a copy of that <code>initrd_file_header_t</code> object instead of accessing the original directly? I don't see you modify that object, so you could just do</p>

<pre><code>const initrd_file_header_t *header = &amp;file_headers[node-&gt;inode];
</code></pre>

<p>and access the fields as <code>header-&gt;length</code> etc. That probably will eliminate that implicit call to <code>memcpy</code>.</p>
",1
15561387,15561362,1,"<p>It depends if you are creating an instance of your structure on <code>heap</code> or <code>stack</code>. If you define a pointer to the object and allocate on the <code>heap</code> through <code>malloc</code>, then it depends on the available memory of your system.</p>

<p>If you define an instance of the object on the stack as <code>struct MyDocument mydoc;</code>, then this is bound to fail as your system will not have such a huge stack value.</p>

<p>It would recommended to declare <code>str</code> as a pointer i.e. <code>char *str</code> and allocate the memory for the same through <code>malloc</code>.</p>

<p>The structure definition could be redefined as</p>

<pre><code>struct MyDocument {
    DocID doc_id;
    unsigned int num_res;
    QueryID* query_ids;
    unsigned int size;
    char *str; // Modified the declaration
};
</code></pre>

<p>With this change, it doesn't matter if you create the object on <code>stack</code> or <code>heap</code>. If you are defining a <code>pointer</code> to the object, then you could allocate the object and <code>str</code> as shown in the example below</p>

<pre><code>struct MyDocument *myDoc; // Declare an object pointer

myDoc = malloc(sizeof(MyDocument)); // Allocate memory for the object
myDoc-&gt;str = malloc(sizeof(char) * MAX_DOC_LENGTH); // Allocates memory for str
</code></pre>

<p>Alternatively, you could define an object on the stack and allocate space for <code>str</code> only as </p>

<pre><code>struct MyDocument someDoc; // Declare an object

someDoc.str = malloc(sizeof(char) * MAX_DOC_LENGTH); // Allocates memory for str
</code></pre>
",13
15561392,15561362,1,"<p>Here your problem is associated with the size of the string str not with the number of variables declared inside the structure. There won't be any restrictions by the compiler, if any problem occurs it will be due to the memory capacity.  </p>
",1
15561435,15561362,1,"<p>4MB is a probably gonna be too big for the stack. Allocate your <code>str</code> on the <code>heap</code>. </p>

<pre><code>struct MyDocument {
DocID doc_id;
unsigned int num_res;
QueryID* query_ids;
unsigned int size;
char* str;
};
</code></pre>

<p>And when you allocate:</p>

<pre><code>struct MyDocument doc;
doc.str = malloc(MAX_DOC_LENGTH);
</code></pre>
",2
15561582,15561362,1,"<p><code>SIZE_MAX</code>, which is the maximum value of the <code>size_t</code> type, is the absolute maximum size (in C's bytes, which have <code>CHAR_BIT</code> bits in them, which is >= 8) of any single object in C.</p>
",2
11510370,6495854,-4,"<pre><code>import java.io.*;
public class EvenOdd {

    public static void main(String[] args) 
    {
        int b = 0xaaaaaaaa, c = 0x55555555;
        System.out.println(""enter number:"");
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String n="""";
        try {
            n = br.readLine();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        int num = Integer.parseInt(n);
        num = ((num&amp;b)&gt;&gt;1)|((num&amp;c)&lt;&lt;1);
        System.out.println(num);
    }
}
</code></pre>
",0
13735455,12355758,4,"<pre><code>#include &lt;stdio.h&gt;

int main()
{
  printf(""Hello World\n"");
  getchar();
  return 0;
}
</code></pre>
",5
9188719,9188673,3,"<p>May be I don;t understand the question, but why can't you do the following:</p>

<pre><code>assert(strlen(timestring) == 12);

char ss[3];
strncpy(ss, &amp;timestring[10], 2);
mytime.tm_sec = atoi(ss);

// same for others
</code></pre>

<p>UPD: No, stop right now. I forget about <code>strptime</code> (check man pages). It should help you</p>
",0
9188727,9188673,1,"<p>In C, one <code>char</code> is one byte, and a string is an array of <code>char</code>s. You need to take the <code>char</code>s at indices 0 and 1. Then you can convert the value into <code>int</code>s if necessary.</p>
",0
9188849,9188673,1,"<p>I¡¯m assuming this is <a href=""/questions/tagged/homework"" class=""post-tag"" title=""show questions tagged 'homework'"" rel=""tag"">homework</a>, so I won¡¯t give you the full answer.</p>

<p>Let's split this problem into bits.</p>

<p>1) Given a string, do you know how to extract a sub-string? <em>E.g.</em>, can you figure out how to accomplish this:</p>

<pre><code>char sample[] = ""DDMMYYHHMMSS"";
char *dd;
// code you need to figure out
printf(""%s"", dd); // should print ¡°DD¡±
</code></pre>

<p>Hint: Look up <code>strncpy()</code>.</p>

<p>2) Once you¡¯ve figured that out, do you know how to convert a string of digits to a number?  <em>E.g.</em>, can you accomplish this:</p>

<pre><code>char dd[] = ""32"";
int mday;
// code you need to figure out
printf(""%d"", mday); // should print ¡°32¡±
</code></pre>

<p>Hint: Look up <code>sscanf()</code> &amp; <code>atoi()</code>.</p>

<p>At this point, combining those two techniques should be straightforward.  By all means ask more if you need more help.</p>
",0
13723178,13723039,2,"<p>See <a href=""http://en.wikipedia.org/wiki/Data_structure_alignment#Data_structure_padding"" rel=""nofollow"">Data structure padding</a>. On most systems, the structure will be aligned &amp; internal member addresses will be aligned wrt their respective sizes, while malloc'ing itself.</p>

<p>If you manually create a memory pool &amp; use some section within that to store your struct object, then compiler will not guarantee you alignment, but if you use malloc to create the struct object, it is generally compiler's headache, to give you aligned addresses, with padding if required between struct elements.</p>
",4
13723378,13723039,1,"<p>If you get your data from a source where the pointer to the data isn't necessarily aligned, the only safe thing you can do is memcpy and hope that your complier isn't ""smart"" and pretends that the misaligned pointer is actually aligned and the memcpy can be optimized (there are several older versions of gcc that have this bug, requiring you to write a custom memcpy function that's not called memcpy). Depending on you architecture you can get away with improperly aligned access, but it will almost certainly be slower, sometimes even emulated through kernel traps.</p>

<p>A side anecdote: This is usually a problem in network stacks in operating systems where the odd size of the ethernet header makes the IP header unaligned and if the hardware doesn't have the ability to misalign the received packets (some DMA engines can only write data on 4 byte boundaries), this requires the whole headers (or the whole packet) to be copied once more in software.</p>
",0
13725476,13723039,1,"<p>No, it is not safe, unless you know the pointer has the alignment required for the structure.</p>

<p>Here are some ways to know the pointer has the necessary alignment:</p>

<ul>
<li>The pointer was originally a pointer to this structure type before it was converted to a pointer to char.</li>
<li>The pointer is a result of a memory allocation routine (such as <code>malloc</code>) that guarantees the address returned is suitably allocated for any use (which <code>malloc</code> does guarantee).</li>
<li>The pointer has been calculated from one of the above in a way that preserves the desired alignment.</li>
<li>You convert the pointer to a <code>uintptr_t</code> and test its alignment, provided this is supported by your C implementation.</li>
<li>Your C implementation (particularly the OS and processor) permits unaligned access to objects of the type in the structure.</li>
</ul>

<p>If you do not know the pointer has the necessary alignment, then you should not access the structure through a converted pointer. Instead, you can define a new structure and use <code>memcpy</code> to copy from the pointer-to-char into the new structure.</p>
",3
18906365,6304457,0,"<p>the formula for calculating fahrenheit to celcius is wrong.. instead is </p>

<pre><code>(¡ãF  -  32)  x  5/9 = ¡ãC
</code></pre>

<p>and aslo excercise is asking to convert f to kelvin so :
Fahrenheit To Kelvin:</p>

<pre><code>(5/9 * (Fahrenheit - 32) + 273 ).
</code></pre>

<p>anyway can someone help how to make this : The main() function should use a loop to allow the user to enter temperatures repeatedly, stopping when a q or other nonnumeric value is entered.
thnks</p>
",0
10107319,10107292,1,"<p>C is pass-by-value. There is no pass-by-reference.</p>
",5
10107325,10107292,19,"<p>You pass the address of the pointer:</p>

<pre><code>void set(char **buf)
{
    *buf = malloc(5*sizeof(char));
    // 1. don't assign the other string, copy it to the pointer, to avoid memory leaks, using string literal etc.
    // 2. you need to allocate a byte for the null terminator as well
    strcpy(*buf, ""test"");
}

char *str;
set(&amp;str);
puts(str);
</code></pre>
",7
10107330,10107292,5,"<p>You have to pass it as a pointer to the pointer:</p>

<pre><code>void set(char **buf)
{
    *buf = malloc(5 * sizeof(char));
    strcpy(*buf, ""test"");
}
</code></pre>

<p>Call it like this:</p>

<pre><code>char *str;
set(&amp;str);
puts(str);
free(str);
</code></pre>

<p>Note that I have changed the <code>malloc</code> call to allocate five characters, that's because you only allocate for the actual characters, but a string also contains a special terminator character and you need space for that as well.</p>

<p>I also use <code>strcpy</code> to copy the string to the allocated memory. That is because you are overwriting the pointer otherwise, meaning you loose the pointer you allocate and will have a memory leak.</p>

<p>You should also remember to <code>free</code> the pointer when you are done with it, or the memory will stay allocated until the program ends.</p>
",1
10107336,10107292,4,"<p>C does not support pass by reference. But you can pass a pointer to your pointer, and set that:</p>

<pre><code>void set(char **buf)
{
    *buf = malloc(5*sizeof(char)); //5, to make room for the 0 terminator
    strcpy(*buf,""test""); //copy the string into the allocated buffer.
}

char *str;
set(&amp;str);
puts(str);
</code></pre>
",3
10107338,10107292,3,"<p>You to pass a pointer to a pointer, <code>char**</code>: there are no references in C.</p>

<pre><code>void set(char** buf)
{
    *buf = malloc(5); /* 5, not 4: one for null terminator. */
    strcpy(buf, ""test"");
}
</code></pre>

<p>Note that:</p>

<pre><code>buf = ""test"";
</code></pre>

<p>does not copy <code>""test""</code> into <code>buf</code>, but points <code>buf</code> to the address of the string literal <code>""test""</code>. To copy use <code>strcpy()</code>.</p>

<p>Remember to <code>free()</code> returned buffer when no longer required:</p>

<pre><code>char* str;
set(&amp;str);
puts(str);
free(str);
</code></pre>
",1
10107372,10107292,0,"<p>C cannot not pass function arguments by reference, C always passes them by value.</p>

<p>From Kernighan &amp; Ritchie:</p>

<blockquote>
  <p>(K&amp;R 2nd, 1.8 Call by value) ""In C all function arguments are passed by ""value""""</p>
</blockquote>

<p>To modify a pointer to <code>T</code>, you can have a pointer to pointer to <code>T</code> as the function argument type.</p>
",4
19445041,8831323,0,"<p>Easy way to find Length of the given string</p>

<pre><code>int strLength(const char *_array)
  {
     int str_len=0;
        while(*(_array++))  
          str_len++;

        return str_len;
   }
</code></pre>
",0
9179811,9179729,6,"<p>You are reading numbers represented in plain text.</p>

<p><code>getw</code> reads a machine word (say 8 bytes on my 64-bit box for example), and when you write it out, it writes that out. This is not what you want.</p>

<p>Use <code>fscanf</code> instead of <code>getw</code> to read formatted values.</p>
",0
18280386,18275701,0,"<p>In C++, this is easy:</p>

<pre><code>char *fnc(parameter=default_value){
....
}
</code></pre>

<p>So, if you call to the function without parameters, the value of the function parameter will be the ""default_value"". If you call to the function with a parameter, the value of the function parameter will be the one in the function call. If you have more than 1 parameter, don't forget to put the parameter with a default value at the end of the parameter list!</p>

<p>BTW, sorry for my bad english and if I'm wrong, tell me, please. I'm a programming aprentice :-)</p>
",0
11158458,11158419,6,"<pre><code>while(n &gt; 1){
    factorial = n*factorial;
}
</code></pre>

<p>you missed <code>n--</code>;</p>
",1
11158472,11158419,1,"<p>You should decrement <code>n</code> in <code>factorial</code> function.</p>
",0
11158473,11158419,3,"<p>Your while loop:</p>

<pre><code>while(n&gt;1){
    factorial = n*factorial;
}
</code></pre>

<p>Will run forever. There is nothing in that loop that can change <code>n</code>, so if the loop is entered then we know <code>n</code> will always be greater than <code>1</code>. You should decrement <code>n</code> within your loop:</p>

<pre><code>while(n &gt; 1){
    factorial = n--*factorial;
}
</code></pre>

<p>If you aren't used to seeing decremenent like that you can also do it on a new line:</p>

<pre><code>while(n&gt;1){
    factorial = n*factorial;
    n--;
}
</code></pre>
",0
11158562,11158419,1,"<p>You have a wrong implementation of factorial method. </p>

<pre><code>int factorial(int n){
 int factorial = 1;
 while(n&gt;1){
     factorial = n*factorial;
     n--;
 }
 return factorial;
}
</code></pre>

<p>Your code simply didn't do anything with n variable and kept multiplying, without ever decreasing n value. Hope this helps</p>
",0
10747682,10747621,2,"<p><strong>You are missing a semi-colon.</strong></p>

<pre><code>void filecopy( FILE * a, FILE *b );  /* Put semi-colon on the end! */
</code></pre>

<p><hr>
This line:</p>

<pre><code>printf(""no open"".*argv);
</code></pre>

<p>Makes no sense.  What did you mean for it to do?</p>
",1
10747636,10747621,7,"<p>You're missing a semicolon at the end of this line:</p>

<pre><code>void filecopy( FILE * a, FILE *b )
</code></pre>

<p>This should be</p>

<pre><code>void filecopy( FILE * a, FILE *b );
</code></pre>

<p>Because this is a function prototype.</p>

<p>Also, this line is not legal C:</p>

<pre><code>printf(""no open"".*argv);
</code></pre>

<p>This should probably just be something like</p>

<pre><code>printf(""no open"");
</code></pre>

<p>Hope this helps!</p>
",0
10747643,10747621,2,"<p>The declaration needs to end with a semicolon</p>

<pre><code>void filecopy( FILE * a, FILE *b );
</code></pre>

<p>(That's the declaration inside the main function, not the function definition which comes later.)</p>
",0
10772547,10772529,4,"<p>Uh - no.</p>

<p>A struct can certainly <em>contain</em> a function pointer.  But the function you call wouldn't have any knowledge of the struct.  Unless you passed a pointer as a function argument, or made the struct global.</p>
",0
10772559,10772529,1,"<p>With my limited knowledge of programming, I don't think this is possible. Though the struct contains a function pointer, the address of the function assigned to it is different and I don't think there will be anyway for it to access it unless you pass it as an argument.</p>
",0
10772650,10772529,1,"<p>Well, two things, struct_name->number should have a value, and it either needs to be in the same scope as &amp;function_name or it needs to be explicitly passed. Two ways to do it: </p>

<p>/* Here is with a global calling struct */</p>

<pre><code>#include&lt;stdio.h&gt;

typedef struct struct_name {
    int number;
    void (*func)();
    } * struct_name_ptr;

struct struct_name newobject = { 0 }; 

void function_name() {
    printf(""%d"",struct_name);
}

void main() {

    struct struct_name_ptr newobject;

    newobject-&gt;func=&amp;function_name;
    newobject-&gt;func();
}
</code></pre>

<p>/* And one with a modified function_name */</p>

<pre><code>#include&lt;stdio.h&gt;

typedef struct struct_name {
    int number;
    void (*func)();
    } * struct_name_ptr;


void function_name(struct_name) {
    printf(""%d"",struct_name);
}

void main() {

    struct struct_name_ptr newobject;
    newobject.number = 0;

    newobject-&gt;func=&amp;function_name;
    newobject-&gt;func(newobject);
}
</code></pre>
",0
10772791,10772529,1,"<p>No, a pizza won't ever know what the pizza delivery guy, who delivered it, looks like. </p>

<p>A regular function is just an address in memory. It can be called using a function pointer like in this case. In any case: <strong>The function won't know how it was called. In particular it won't know that it was called using a function pointer that's part of (a piece of memory corresponding to) some struct.</strong></p>

<p>When using a language with classes like C++, member functions will have a hidden argument which is a pointer to the class instance. That's how member functions know about their data.</p>
",0
10773777,10772529,1,"<p>You can 'simulate' a simple OOP in plain C, for your example like:</p>

<pre><code>typedef struct {
int number;
void (*func)();
} class;

void function_name(class *this) {
  printf(""%d"",this-&gt;number);
}

#define CALL(c,f) c.f(&amp;c)

int main() {
  class object={12345,function_name};

  CALL(object,func); // voil¨¢
}
</code></pre>
",0
14818627,14818566,4,"<p><code>buffer+160</code> is not the value you are looking for.<br>
<code>buffer+160</code> is a a <strong><em>pointer</em></strong> to your <code>int</code>, not your <code>int</code> itself.</p>

<p>You must type-cast and de-reference the pointer to see the value you want.</p>

<pre><code>printf(""L5: %s %s %u\n"", buffer, buffer+80, *(uint32_t*)(buffer+160));
</code></pre>
",3
14818665,14818566,1,"<pre><code>printf(""L5: %s %s %u\n"", buffer, buffer+80, buffer+160);
</code></pre>

<p><code>buffer+160</code> is a pointer to <code>char</code>, so your are printing an <em>address</em>. </p>
",0
12847525,12847503,2,"<p>One thing that's done in C sometimes is to use a zero length array at the end of a struct and to allocate extra space for a variable number of elements. I'm not sure if zero length arrays are legal in C (they're not in C++) but it's commonly supported.</p>

<pre><code>struct something_box_t {
  uint32_t max_size;
  uint32_t used;
  somestruct_t data[];
};

something_box_t *box = malloc(sizeof(something_box_t) + N*sizeof(somestruct_t));
box.max_size = N;
box.used = 0;

box.data[0] = ...;
box.data[1] = ...;
</code></pre>

<p>Of course, if you can switch to C++ you won't have to hack together a solution on your own. You could just do <code>std::vector&lt;somestruct_t&gt; box;</code> and have a solution far easier to use, as performant if not more performant, and more reliable than what you're likely to write in C.</p>
",1
12847616,12847503,2,"<p>You can see this often done by <a href=""http://en.wikipedia.org/wiki/Linked_list"" rel=""nofollow noreferrer"">linked list</a> (in C, for example in kernel mode windows drivers), here's an <a href=""http://www.macs.hw.ac.uk/~rjp/Coursewww/Cwww/linklist.html"" rel=""nofollow noreferrer"">example</a> how to implement your own.</p>

<p>C++ offers you templates to make lists more flexible.</p>

<p>And C++ also offers you stl containers (like <code>std::vector</code>) but <a href=""https://stackoverflow.com/a/12847525/1149736"">bames53 already suggested that one</a>.</p>
",5
12855315,12855271,2,"<p>How va_list is defined is entirely up to your compiler, operating system and ABI. On some operating systems it can be defined by a struct or even a simple pointer to something, on others it is just internal compiler black magic that can't be expressed with a C struct.</p>
",1
12855537,12855271,-1,"<p>you can find all these on this </p>

<p><a href=""http://research.microsoft.com/en-us/um/redmond/projects/invisible/include/stdarg.h.htm"" rel=""nofollow"">http://research.microsoft.com/en-us/um/redmond/projects/invisible/include/stdarg.h.htm</a></p>

<p>There you can notice when the definitions of the va_list is changing according to the environment.</p>

<p>You can also find some information on follows.</p>

<p><a href=""http://www.cplusplus.com/reference/clibrary/cstdarg/va_list/"" rel=""nofollow"">http://www.cplusplus.com/reference/clibrary/cstdarg/va_list/</a></p>
",0
9138264,9138109,21,"<p><code>config.h</code> is normally generated by the <code>./configure</code> script to reflect the target system's characteristics. In your case, it's tied into the whole gnulib ""let's replace all the system's library functions with out own hacks"" mess, so a lot of what's in a gnulib project <code>config.h</code> is stuff that gnulib's portion of <code>configure</code> generated.</p>
",0
16913219,16913068,3,"<p>It looks like you are not guaranteed to have <code>NUMBER_OF_WORDS</code> entries in <code>uniqueWords</code> or <code>wordCount</code>, but you are printing out that many at the end. Whether or not that is responsible for the output you are seeing, it would be likely to produce such output if your input has less than <code>NUMBER_OF_WORDS</code> unique words.</p>
",1
12291054,12291001,6,"<p>It's a Gnu C extension. Basically it allows to specify elements in the initializer in any order.</p>

<p><a href=""http://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html"" rel=""nofollow"">http://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html</a></p>

<p>UPD: The standard (C99) way to do the same is <code>{ .field = value, .field2 = value2 }</code></p>
",2
11582162,11581824,1,"<p>You can go this way:</p>

<p>Store the index of the last free slot in a variable and then looking for the next one don't scan the bitmap from the beginning, but from this value.</p>

<p>If you need to free some slot, assign it to the last index.</p>

<p><code>std::vector&lt;bool&gt;</code> can be your bit array, so you will not need to deal with bits yourself (bool's are packed into ints internally).</p>

<p>You can introduce a <code>mip-mapped</code> structure:</p>

<pre><code>``std::vector&lt;bool&gt;`` Bitmap;
``std::vector&lt;bool&gt;`` Bitmap2; // half-sized
``std::vector&lt;bool&gt;`` Bitmap4; // 1/4
``std::vector&lt;bool&gt;`` Bitmap8; // 1/8
// etc
</code></pre>

<p>The <code>free</code> values in the upper-level arrays correspond to the situation where the lower level array have any free slots. You can use binary search to traverse this structure.</p>
",2
11582188,11581824,9,"<p>A million 32-bit integers require about 4MB of memory. So I'd say you keep a list of free slots. Whenever a car enters, you take an item off the list and assign that. Whenever a car leaves, you put the freed slot number into the list.</p>

<p>As you'd only ever be manipulating the end of the list (so this is in fact used as a <a href=""http://en.wikipedia.org/wiki/Stack_%28data_structure%29"" rel=""noreferrer"">stack</a> or <a href=""http://en.wikipedia.org/wiki/LIFO_%28computing%29"" rel=""noreferrer"">LIFO</a> structure), this gives you optimal O(1) performance both for finding a free slot and for returning a slot to free state. If you do this on a low level with a raw chunk of memory, you'll need a pointer indicating the current end of the list. Finding a slot decrements that pointer and returns its value. Returning a slot assigns to the pointer and increments it afterwards.</p>

<p>If you decide to add additional requirements later on, you could do some manipulation of your data, e.g. turn it into a <a href=""http://en.wikipedia.org/wiki/Heap_%28data_structure%29"" rel=""noreferrer"">heap</a>. With a big map of 0/1 bits, such extensions wouldn't be possible.</p>
",2
10646838,10646823,2,"<p><strong>l-values</strong> are entities whose address (<em>usually exceptions: register variables</em>)can be taken &amp; they reside in memory long enough to be referred to by an name.<br>
<strong>r-values</strong> are <strike>variables</strike> objects whose address cannot be taken &amp; they do not reside in memory long enough to be referred to by an name, they are nameless. Often also called as nameless temporary objects.  </p>

<p><strong><a href=""http://ideone.com/OsBUK"" rel=""nofollow"">Sample Program:</a></strong></p>

<pre><code>int returnanInteger()
{
    int i = 10;
    return i;
}

void doSomething(int i)
{
    //do something, right now we don't care
}
int main()
{
   int i = 20;
   doSomething(returnanInteger());

   return 0;
}
</code></pre>

<p>In above program <code>i</code> in <code>main()</code> is an <strong>l-value</strong> because its address can be taken and it can be referred by an name.<br>
While, in the statement:   </p>

<pre><code>doSomething(returnanInteger());
</code></pre>

<p>The value returned by <code>returnanInteger()</code> is an <strong>r-value</strong>, it's address cannot be taken and it does not remain in memory long enough to be referred by nay name.It is immediately copied to be passed as an argument to the function <code>doSomething()</code>.</p>
",6
10646917,10646823,0,"<p>In addition to what Als has already mentioned above (which is detailed enough), you might find the following links useful:</p>

<p><a href=""http://msdn.microsoft.com/en-us/library/bkbs2cds.aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/bkbs2cds.aspx</a></p>

<p><a href=""http://publib.boulder.ibm.com/infocenter/comphelp/v7v91/index.jsp?topic=/com.ibm.vacpp7a.doc/language/ref/clrc05lvalue.htm"" rel=""nofollow"">LValue&amp;RValue</a></p>

<p><a href=""http://www.techrepublic.com/article/distinguish-the-differences-between-r-values-and-l-values-in-c-/5383417"" rel=""nofollow"">C++ Based Link</a></p>
",0
10647048,10646823,0,"<p>All the values on the right side of = (""equal"" to sign in c programming) are rvalues.Like 
x = 23;
c = 'x';
int *ptr = &x;</p>

<p>here 23 , 'x' and '&amp;x"" are the rvalues
Correspondingly x , c and *ptr are the lvalues.They represent the variables or objects in the memory
You can never put the rvalues on the left side of = (""equal"" to sign in c programming)</p>

<p>See this link - <a href=""http://www.devx.com/tips/Tip/5696"" rel=""nofollow"">http://www.devx.com/tips/Tip/5696</a>  for more info.
rgds
Softy</p>
",0
10647708,10646823,0,"<p>A simplification would be to see lvalues as typed ""objects"" that have an explicit allocation in the program, either as variables, compound literals or through <code>malloc</code> or similar mechanisms. Depending on their type, lvalues can be modifiable or not (specified with <code>const</code> for the type), and you may be allowed to take the address of it or not (specified with <code>register</code> for the declaration of variables).</p>

<p>An rvalue is just a ""value"" that the program produces as an intermediate step in an evaluation, and for which the compiler may freely choose the particular representation that suits best. Rvalues may not be modified and their address can usually not be taken. (There are very special circumstance that allow to take it for array component evaluation.)</p>
",0
20397472,20396516,2,"<p>Depends on compiler. Most 64bit compilers use 32bit <code>int</code> and 64bit <code>long</code>.</p>

<p>32bit compilers usually was 32bit <code>int</code> and 32bit <code>long</code>.</p>

<p>16bit compilers usually was 16bit <code>int</code>, 32bit <code>long</code> and 16bit <code>short</code>.</p>

<p>None of these is guaranteed unless specific compiler's documentation says so. Standard only says that <code>sizeof(char) &lt;= sizeof(short) &lt;= sizeof(int) &lt;= sizeof(long) &lt;= sizeof(long long)</code>, and that <code>char</code> is 1 byte.</p>
",2
12325792,12325781,3,"<blockquote>
<pre><code>string[wordCount++] = (char *) malloc (strlen(buffer)+1); 
strcpy (string[wordCount], buffer);
</code></pre>
</blockquote>

<p>You're allocating to <code>string[wordCount]</code> and then you're incrementing <code>wordCount</code>. Then you proceed to <code>strcpy</code> to this new, unallocated element, which is illegal.</p>

<p>Increment <code>wordCount</code> <strong>after</strong> <code>strcpy</code> instead.</p>
",0
12328078,12325781,0,"<p>Another problem you should have is that if you read more than 20 lines, you will make an illegal memory access since you are declaring an array of char pointers with 20 positions:</p>

<p>char *string[20];</p>

<p>You should reconsider the loop:</p>

<p>while ((scanf(""%s"", buffer) != EOF))</p>
",0
12329052,12325781,0,"<p>You should ever check for an array-(index)-overflow like:</p>

<pre><code>int main() {

char *string[20];
char buffer[256];

int j, wordCount = 0;

    while (wordcount&lt;20 &amp;&amp; (scanf(""%255s"", buffer) == 1)) {  /* here */
        printf(""%s%d\n"", buffer, wordCount+1);
        strcpy( string[wordCount++] = malloc (strlen(buffer)+1, buffer ); 
    }

printf(""There are %d words.\n"", wordCount+1);

for (j = 0; j &lt; wordCount; j++)
{

    printf(""%s\n"", string[j]);
}
  return 0;
}
</code></pre>

<p>Note that scanf will ever breaks on all whitespaces and you clear the input-buffer after all scanf/fgets(stdin) actions.</p>
",0
14202220,14202201,0,"<p>You are assigning <em>dst</em> into <em>src</em>, instead of the other way around.</p>
",0
14202227,14202201,1,"<p>You overwrite the source string with the destination string. You probably want it the other way round:</p>

<pre><code>(*dst++ = *src++)
</code></pre>
",0
14202235,14202201,0,"<p>You seem to be copying <code>dest</code> to <code>src</code> ! Note that if you had used a more appropriate function prototype then the compiler would have caught this mistake:</p>

<pre><code>char * strcpy(char *dest, const char *src); // &lt;&lt;&lt; note the `const` !!!
</code></pre>

<p>You're also missing a <code>;</code> for your while loop.</p>
",0
14202237,14202201,8,"<p>In addition to copying in the wrong direction, you are missing a semicolon at the end of the <code>while</code> loop:</p>

<pre><code>char *strcpy_(char *dest, char *src) {
    char *orig = dest;
    while((*dest++ = *src++)!= '\0')
        ; // &lt;&lt;== Very important!!!
    return orig;
}
</code></pre>

<p>Without the semicolon, which represents an <em>empty statement</em>, you execute <code>return</code> after copying your first character, which is, of course, incorrect.</p>

<p>Finally, you can skip the check for zero in the header of the loop, like this:</p>

<pre><code>while(*dest++ = *src++)
    ;
</code></pre>
",1
12828594,12833269,2,"<p>Since i can't comment on this due to my low reputation i will add this answer and if have understood your problem you are probably passing a pointer to a function, and the problem is that you probably need a pointer to pointer instead of just a pointer.</p>

<p>in C when you pass values to a function you are passing them by value, not by reference, meaning that the function makes a local copy of that argument and it will work only with that local copy, the problem is that all the changes will affect only the local copy and when the function terminates all the changes will be lost if you will not handle this correctly.</p>
",1
12834069,12833269,1,"<p>You are returning a pointer to a global variable, and that pointer will always be the same even if you modify the global variable.</p>

<p>The solution is to either allocate a new object each time, or to not use pointers at all and return the structure directly and let the compiler handle copying of the structures internal values.</p>
",0
19799832,19799781,2,"<p>It's an <code>int</code>. So, most likely 4 bytes depending on your compiler / architecture.</p>

<p>Keep in mind you're not actually storing that value anywhere.</p>
",3
19799851,19799781,0,"<p>storage size is <code>sizeof (unsigned int)</code>; the memory required to store an <code>unsigned int</code> is not dependent on what value you assign it.  </p>

<p>In fact, you have not made any assignments. regardless, you still have a memory location that is precisely <code>sizeof(unsigned long)</code> (whether you use it or not :)  </p>
",0
19799879,19799781,0,"<p><code>var1</code> is a <code>short</code> (the <code>unsigned</code> doesn't change storage size), normally 2 bytes (but not guaranteed to be all systems). The literal <code>100</code> is an <code>int</code>, usually 4 bytes but again, not guaranteed. The product of a short and an int is an int, so it will use int storage size. You can force the compiler to interpret the literal <code>100</code> as a short by appending an 's':</p>

<pre><code>(var1 * 100s)
</code></pre>

<p>or an unsigned short by appending 'us':</p>

<pre><code>(var1 * 100us)
</code></pre>

<p>But this won't change the size of the output as all operations on shorts first involve a conversion to int.</p>

<p>If you want to know how many bytes anything takes up in a program, just use the builtin function/operator <code>sizeof</code> to find out:</p>

<pre><code>sizeof(var1 * 100); //calculates size of the expression in bytes
</code></pre>

<p>In your case, the value is temporary anyway and it's storage size shouldn't affect your program.</p>
",1
11539900,11539763,3,"<p>I'm only guessing here, but the problem is probably with the loop. You do not check for the string terminator, but print all of the array regardless of if the string has ended or not.</p>

<p>If you change the loop to this:</p>

<pre><code>for (; i &lt; 22 &amp;&amp; j[i] != '\0'; printf(""%c"", j[i++])) ;
</code></pre>

<p>You should get the expected output.</p>

<p>(Note: I also changed <code>21</code> to <code>22</code> which is the size of the array. You can of course do <code>i &lt;= 21</code> as that is the same.)</p>

<p><strong>Edit:</strong> Rereading the question after the comment from hmjd.</p>

<p>If the input as read by <code>scanf</code> contains a percentage (<code>'%'</code>) character the call to <code>sprintf</code> afterwards will try to parse it as a formatting code. If I test this program with the input <code>%d123</code>, then <code>k</code> will be <code>""%d""</code> as expected, but the resulting array <code>j</code> will be <code>""192795408\0long string""</code>.</p>
",5
8737912,8737835,0,"<p>The problem is (*labelname)++. You are incrementing the value that's pointed to by labelname and simultaneously assigning to it the value that's pointed to by currentline. If you want to increment the pointers, use *labelname++ and *currentline++</p>
",1
8738064,8737835,4,"<p>What I think you're trying to do is extract/copy all of the characters in a string up until a certain point (<code>':'</code> or NUL) and return that buffer. If that's the case, you're going to need to dynamically allocate memory for the new string (you can't return a local buffer allocated on the stack), and you should also take advantage of functions in <code>&lt;string.h&gt;</code> like <code>strchr</code> and <code>memcpy</code>.</p>

<p>Here's an alternative working example:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

char *extract_string(char *str, char delim)
{
   size_t len;
   char *new_str;
   char *delim_pos = strchr(str, delim);

   /* new string is the length from the start of the old string to the
    * delimiter, or if it doesn't exist, a copy of the whole string */
   if (delim_pos == NULL)
      return strdup(str);

   len = delim_pos - str;
   new_str = malloc(len + 1);
   memcpy(new_str, str, len);
   new_str[len] = '\0'; /* NUL terminate the new string */

   return new_str;
}

int main(void)
{
   char *extracted1 = extract_string(""some:string"", ':');
   char *extracted2 = extract_string(""no delimiter"", ':');

   puts(extracted1);
   puts(extracted2);

   /* free the dynamically allocated buffers */
   free(extracted1);
   free(extracted2);

   return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>some
no delimiter
</code></pre>

<p>If you don't want to make a copy when the delimiter isn't found, you could alternatively return <code>NULL</code>.</p>

<p>Alternatively, if you don't mind mangling your initial string, you could use <code>strtok</code> to extract tokens.</p>
",1
17786239,10586003,0,"<p>If you're using C with Win32, you can leverage its <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/ms680657%28v=vs.85%29.aspx"" rel=""nofollow"">Structured Exception Handling (SEH)</a> to simulate try/catch.</p>

<p>If you're using C in platforms that don't support <code>setjmp()</code> and <code>longjmp()</code>, have a look at this <a href=""http://www.pjsip.org/pjlib/docs/html/group__PJ__EXCEPT.htm"" rel=""nofollow"">Exception Handling</a> of pjsip library, it does provide its own implementation</p>
",0
15906086,10586003,-1,"<p>Perhaps not a major language (unfortunately), but in APL, theres the ?EA operation (stand for Execute Alternate).</p>

<p>Usage:
'Y' ?EA 'X'
where X and Y are either code snippets supplied as strings or function names.</p>

<p>If X runs into an error, Y (usually error-handling) will be executed instead.</p>
",1
15838332,15838249,5,"<p>The rules of C require that <code>unsigned char</code> operands be converted to <code>int</code> (except in perverse C implementations).</p>

<p>Once the operand is an <code>int</code>, it is signed, and the <code>~</code> operator may give you unexpected results, because the semantics for signed integers and their bit representations are not fully specified by C. The compiler is helpfully warning you about this.</p>

<p>You should use <code>antipattern = ~ (unsigned int) pattern;</code>. With <code>unsigned int</code>, you are guaranteed that the value is represented with simple binary.</p>
",5
16432692,9366264,5,"<ol>
<li>join() waits on a thread to complete it's execution. </li>
<li>You need to either detach() a thread or join() a thread for managing it.</li>
<li>join() also, cleans up the thread occupied resources. You will find join() called in the  destructor of an RAII class because of the same reason.</li>
</ol>
",0
20203576,20203496,6,"<p>Strlen counts characters until it reaches the NUL ('\0') character. Make sure your string contains this character, else strlen will count over the array bounds, case when the segmentation fault appears. C provides no checking for array bounds. </p>

<p>Also, check if the pointer you pass is valid (i.e. it is not null).</p>
",0
20203659,20203496,3,"<p>It looks like your arguments to <code>memcpy</code> are the wrong way around. The first argument is the <em>destination</em>, the second argument is the <em>source</em>. It looks like you want to copy the contents of <code>restP</code> into <code>str</code>.</p>

<pre><code>memcpy(str, restP, strlen(restP) + 1);
</code></pre>

<p>I've added one to the length of <code>restP</code> so that the null character is copied too (which isn't counted as part of <code>strlen</code>. You don't need to subtract one from <code>strlen</code> unless:</p>

<ol>
<li><p>You know <code>str</code> is long enough and it is initialised to zero so that any appropriately sized string that is copied into it will be terminated by a null character.</p></li>
<li><p>You don't want to copy the last character of the source string.</p></li>
</ol>
",0
18737162,18737084,3,"<p>You only declare 4 elements for <code>re</code> (<code>0</code> through <code>3</code> inclusive) but you use a 5th element when doing <code>re[4]</code>. You are invoking undefined behavior at that point. You need to define <code>re</code> as:</p>

<pre><code>char re[5];
</code></pre>
",0
18737175,18737084,0,"<p>You are accessing over the bounds of array <code>re</code>, by assigning value to <code>re[4]</code>. </p>

<p>As <em>Jim Buck</em> said, use <code>char re[5]</code>, or use index <code>3</code> as the last one for array <code>re</code>.</p>
",2
8724611,8724582,12,"<p>You need to realize that <code><a href=""http://linux.die.net/man/3/rand"" rel=""noreferrer"">rand()</a></code> is a <a href=""http://en.wikipedia.org/wiki/Pseudorandom_number_generator"" rel=""noreferrer"">pseudorandom number generator</a>, and it is specifically engineered to return the <em>same</em> sequence of numbers for a given <em>seed</em>. The seed is set with the <code>srand()</code> function.</p>

<pre><code>srand(0);
printf(""the first rand() with seed 0 is %d\n"", rand());
srand(1);
printf(""the first rand() with seed 1 is %d\n"", rand());
srand(0);
printf(""the first rand() with seed 0 is still %d\n"", rand());
</code></pre>

<p>So, the way to make it less predictable is generally to re-seed it from something a bit more random, or at least from something that is not the same every time you run the program:</p>

<p><code>srand(<a href=""http://linux.die.net/man/2/time"" rel=""noreferrer"">time</a>(NULL));</code></p>
",4
8724619,8724582,1,"<p>you should use <a href=""http://www.cplusplus.com/reference/clibrary/cstdlib/srand/"" rel=""nofollow"">srand()</a> to seed your random generator.</p>

<p>A common random seeding is <code>srand ( time(NULL) );</code></p>
",0
8724624,8724582,2,"<p>Yes, because you dind't ""initialize"" the rand().
Try to do something like that <code>srand (time(NULL)) ;</code></p>

<p>You have also to include <code>time.h</code></p>
",0
8724627,8724582,0,"<p>Call this once:</p>

<pre><code>srand (time(NULL));
</code></pre>

<p>to initialise before calling <code>rand()</code></p>
",0
8724629,8724582,5,"<p>Make sure to initialize / seed the random number generator:</p>

<pre><code>#include &lt;time.h&gt;

srand(time(NULL));
</code></pre>
",0
8724640,8724582,0,"<p>Random number generator must be initialized with random seed. See <code>srand()</code> function. Often it  initialized with time: <code>srand(time(NULL))</code>.</p>
",0
8724648,8724582,3,"<p>If you don't seed the pseudo random number generator, it is like if you called in the start of your program:</p>

<pre><code>srand(1);
</code></pre>

<p>You can call <code>srand</code> with an argument that depends on the time so that two successive calls
of your program would generate different numbers:</p>

<pre><code>srand(time(NULL));
</code></pre>
",0
13698087,13698060,5,"<pre><code>int m[10][20];
int (*pm)[20] = m; // [10] disappears, but [20] remains

int t[10][20][30];
int (*pt)[20][30] = m; // [10] disappears, but [20][30] remain
</code></pre>

<p>This is not a ""cast"" though. Cast is an explicit type conversion. In the above examples the conversion is implicit.</p>

<p>Not also that the pointer type remains dependent on all array dimensions except the very first one. It is not possible to have a completely ""dimensionless"" pointer type that would work in this context, i.e. an <code>int **</code> pointer will not work with a built-in 2D array. Neither will an <code>int ***</code> pointer with a built-in 3D array.</p>
",0
13698155,13698060,0,"<p>Yes ofcourse , You can have pointer to multidimentional array.</p>

<pre><code>int m[10][10];
int (*pm)[10] = m;
</code></pre>
",0
13698180,13698060,-2,"<p>How about this:</p>

<pre><code>    int k[100];
int* pk = k;
int m[10][10];
int **ptr = (int **) malloc(10 * sizeof(int*));
for(int i=0;i&lt;10;i++)
{
    ptr[i] = m[i];
}
</code></pre>
",0
20020503,20020447,3,"<pre><code>struct C someC;
struct A someA;
*(struct A*)&amp;(someC.a) = someA; 
</code></pre>

<p>The assignment above may fail (mistakenly write to <code>someC.c</code>) if the padding you describe is supported by compilers.</p>

<p><strong>EDITED:</strong> The example above relies on the compiler behavior when assigning structs. As I have known (an just checked) <code>gcc</code> copies as the struct is a flat region of memory, which is not member-wise.</p>

<p><strong>EDITED:</strong> Changed from ""would fail"" to ""may fail"" since it's not defined if the padding bits shall be copied, see item 6 of section 6.2.6.1 of ISO_IEC_9899_2011:</p>

<blockquote>
  <p>When a value is stored in an object of structure or union type, including in a member
  object, the bytes of the object representation that correspond to any padding bytes take
  unspeci?ed values.51)</p>
</blockquote>

<p>and footnote <code>51)</code>:</p>

<blockquote>
  <p>51) Thus, for example, structure assignment need not copy any padding bits.</p>
</blockquote>
",3
19576206,19576114,0,"<p>This is the same as converting binary number to decimal. Try this one:</p>

<pre><code>int res = 0;
for (i = 4; i &gt;= 1; i--) {
    res = res * 2 + DrawerFull[i]; // Assuming DrawerFull will contain only 1 or 0.
}
</code></pre>
",0
19576346,19576114,0,"<pre><code>char fullDrawers = 0;
for( char i = 0; i &lt; 4; ++i )
{
    if( IsDrawerFull )
        fullDrawers &amp;= 1;
    fullDrawers &lt;&lt;= 1;
}
</code></pre>
",0
12822732,12822611,4,"<p>See this answer how to <code>wait()</code> for child processes: <a href=""https://stackoverflow.com/questions/279729/how-to-wait-untill-all-child-processes-called-by-fork-complete?rq=1"">How to wait until all child processes called by fork() complete?</a></p>

<p>There is no way to wait for a grandchild; you need to implement the wait logic in each process. That way, each child will only exit after all it's children have exited (and that will then include all grandchildren recusively).</p>
",2
12822733,12822611,7,"<p>You can't. Either make your child process wait for its children and don't exit until they've all been waited for or fork all the children from the same process. </p>
",1
13443497,13443452,1,"<p>It's because the console window handles keyboard and editing keys itself.</p>

<p>You have to look into the Windows <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/ms682073%28v=vs.85%29.aspx"" rel=""nofollow"">console functions</a>, especially the <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/ms686033%28v=vs.85%29.aspx"" rel=""nofollow""><code>SetConsoleMode</code></a> function.</p>

<hr>

<p>To clear the <code>ENABLE_PROCESSED_INPUT</code> and <code>ENABLE_LINE_INPUT</code> flags:</p>

<pre><code>// Get the console handle for `stdin`
HANDLE hConsoleStdin = GetStdHandle(STD_INPUT_HANDLE);

// Get the current flags
DWORD flags;
if (GetConsoleFlags(hConsoleStdin, &amp;flags))
{
    // Now `flags` contain the current flags
    // Remove the flags we don't want there
    flags &amp;= ~(ENABLE_PROCESSED_INPUT | ENABLE_LINE_INPUT);

    // And finally set the new flags
    SetConsoleFlags(hConsoleStdin, flags);
}
</code></pre>

<p><strong>Note:</strong> The above code is <em>not</em> tested, as I don't have access to a Windows machine.</p>
",4
13443519,13443452,0,"<p>The problem actually is, your console does not pass the back-space to the program, but deletes the character from the input-buffer. As @JoachimPileborg said, see the use of SetConsoleMode and other functions. </p>
",0
13443666,13443452,0,"<p>The details of how to accomplish this in a Linux environment were <a href=""https://stackoverflow.com/questions/3167733/ignore-backspace-key-from-stdin"">answered here</a>.</p>
",0
14783075,14783010,0,"<p>So, you could write a function that takes a function pointer and a <code>void *</code> (or <code>char *</code>) to the data, and a data-size. </p>

<p>I certainly wouldn't use only macros to do this, but you may have a macro that doe something like:</p>

<pre><code> #define MAP(func, type, arr, size) map(func, sizeof(type), arr, size)
</code></pre>

<p>and <code>map</code> is the function I describe above. </p>
",2
14783172,14783010,1,"<p>For a template like this, there is a fairly straightforward translation to macros; the major syntactic wrinkle is that you can't return the result array, the variable to write it to has to be another parameter.</p>

<pre><code>#define map(func_, input_, output_, type_, n_) do { \
    output_ = xmalloc(sizeof(type_) * (n_));        \
    size_t i_;                                      \
    for (i_ = 0; i_ &lt; (n_); i_++)                   \
        output_[i_] = func_(input_[i_]);            \
  } while (0)
</code></pre>

<p>This is not as type-unsafe as it looks, provided you pay attention to your compiler warnings.  However, it is <em>not</em> particularly safe if any of the actual arguments to a use of this macro isn't a simple identifier.  Most importantly, <em>catastrophic</em> things will happen if any of the actual arguments has side effects.</p>

<p>This can be cured, as can the inability to return the result array, but only if you're willing to use GNU extensions...</p>

<pre><code>#define gnumap(func_, input_, type_, n_) ({                    \
    __typeof(func_)   func__   = (func_);                      \
    __typeof(input_)  input__  = (input_),                     \
                      output__ = xmalloc(sizeof(type_) * n__); \
    __typeof(n_)      n__      = (n_),                         \
                      i__;                                     \
    for (i__ = 0; i__ &lt; n__; i__++)                            \
        output__[i__] = func__(input__[i__]);                  \
    /* return */ output__;                                     \
  })
</code></pre>

<p>Would I do either of these in real life?  Probably not, but sometimes it really is the least bad available option.  Think of it as one step shy of rewriting that critical inner loop in assembly language.</p>

<p>(<code>xmalloc</code>, in case you're unfamiliar with it, is the conventional name for a user-written wrapper around <code>malloc</code> that either succeeds or crashes the entire program.  I use it here to dodge the question of how to cope with <code>malloc</code> failing.)</p>
",2
9148144,9148134,7,"<p><a href=""http://linux.die.net/man/2/read"" rel=""noreferrer""><code>read()</code></a> returns a value indicating the number of bytes that it read. The warning is indicating that the code is ignoring that. You should check the return value of <code>read()</code> to ensure it was successful otherwise you are assuming that <code>rtc_data</code> has been correctly populated and it may not have been.</p>
",0
9148150,9148134,5,"<p>You're not checking the return value of <code>read</code>, which is a bug just waiting to happen.</p>

<pre><code>ssize_t r = read(rtctimer-&gt;rtc_fd, &amp;rtc_data, sizeof( rtc_data ) );
if (r == -1) {
   // deal with failed read
} else if (r != sizeof(rtc_data)) {
   // you didn't read as much as you wanted to
...
</code></pre>

<p>If you don't check what read returns, chances are very high that your program will fail unexpectedly if a read error does occur, and it will be impossible to debug. (The second case might not apply in this specific example, or for some pipe reads.)</p>

<p>Always check the return value of library calls, especially I/O ones since they do fail in normal circumstances.</p>
",0
9148153,9148134,1,"<p>The line </p>

<pre><code>  read( rtctimer-&gt;rtc_fd, &amp;rtc_data, sizeof( rtc_data ) );
</code></pre>

<p>produces a result (return value of read()), you don't use it in any way, this will get you a warning. That's the purpose of <code>-Wunused-result</code>.</p>

<p>Ignoring the return value of read() usually is a very bad idea!</p>
",0
9182822,9182763,4,"<p>Because of historical reasons going back to the very first version of C, functions are assumed to have an implicit definition of <code>int function(int arg1, int arg2, int arg3, etc)</code>.</p>

<p>Edit: no, I was wrong about <code>int</code> for the arguments. Instead it passes whatever type the argument is. So it could be an <code>int</code> or a <code>double</code> or a <code>char*</code>. Without a prototype the compiler will pass whatever size the argument is and the function being called had better use the correct argument type to receive it.</p>

<p>For more details look up <code>K&amp;R C</code>.</p>
",0
9182835,9182763,86,"<p>It should be considered an error. But C is an ancient language, so it's only a warning.<br>
Compiling with <code>-Werror</code> (gcc) fixes this problem.<br></p>

<p>When C doesn't find a declaration, it assumes this implicit declaration: <code>int f();</code>, which means the function can receive whatever you give it, and returns an integer. If this happens to be close enough (and in case of <code>printf</code>, it is), then things can work. In some cases (e.g. the function actually returns a pointer, and pointers are larger than ints), it may cause real trouble.</p>

<p>Note that this was fixed in newer C standards (C99, C11). In these standards, this is an error. However, <code>gcc</code> doesn't implement these standards by default, so you still get the warning.</p>
",15
9182843,9182763,3,"<p>C is a very low-level language, so it permits you to create almost any legal object (.o) file that you can conceive of.  You should think of C as basically dressed-up assembly language.</p>

<p>In particular, C does not require functions to be declared before they are used.  If you call a function without declaring it, the use of the function becomes it's (implicit) declaration.  In a simple test I just ran, this is only a warning in the case of built-in library functions like printf (at least in GCC), but for random functions, it will compile just fine.</p>

<p>Of course, when you try to link, and it can't find foo, then you will get an error.</p>

<p>In the case of library functions like printf, some compilers contain built-in declarations for them so they can do some basic type checking, so when the implicit declaration (from the use) doesn't match the built-in declaration, you'll get a warning.</p>
",2
9182891,9182763,3,"<p>An implicitly declared function is one that has neither a prototype nor a definition, but is called somewhere in the code. Because of that, the compiler cannot verify that this is the intended usage of the function (whether the count and the type of the arguments match). Resolving the references to it is done after compilation, at link-time (as with all other global symbols), so technically it is not a problem to skip the prototype.</p>

<p>It is assumed that the programmer knows what he is doing and this is the premise under which the formal contract of providing a prototype is omitted.</p>

<p>Nasty bugs can happen if calling the function with arguments of a wrong type or count. The most likely manifestation of this is a corruption of the stack.</p>

<p>Nowadays this feature might seem as an obscure oddity, but in the old days it was a way to reduce the number of header files included, hence faster compilation.</p>
",2
9183081,9182763,21,"<p>Implicit declarations are not valid in C.</p>

<p>C99 removed this feature (present in C89).</p>

<p><code>gcc</code> chooses to only issue a warning by default with <code>-std=c99</code> but a compiler has the right to refuse to translate such a program.</p>
",1
12792078,12792044,0,"<p>You need to set <code>str_time.tm_wday</code> so that <code>strftime()</code> can convert it.</p>

<p>See <a href=""http://linux.die.net/man/3/localtime"" rel=""nofollow"">localtime(3)</a> and <a href=""http://linux.die.net/man/3/strftime"" rel=""nofollow"">strftime(3)</a> for examples.</p>
",0
12792091,12792044,3,"<p>Your <code>str_time</code> structure (if, as it seems to be, it's a local variable) has indeterminate values in its fields unless you <em>explicitly</em> set them. All <code>strftime</code> does is use the values it has, it doesn't first adjust values to conform other fields.</p>

<p>Since you're not setting <code>tm_wday</code>, it will stay with whatever it was originally (0 by the looks of it, since it's always Sunday).</p>

<p>If you <em>do</em> want to adjust fields based on other fields, you should look into <code>mktime()</code>.</p>

<p>From the standard (ISO C99):</p>

<blockquote>
  <p>The mktime function converts the broken-down time, expressed as local time, in the
  structure pointed to by timeptr into a calendar time value with the same encoding as
  that of the values returned by the time function.</p>
  
  <p>The original values of the tm_wday and tm_yday components of the structure are ignored, and the original values of the other components are not restricted to the ranges indicated above. </p>
  
  <p>On successful completion, the values of the tm_wday and tm_yday components of the structure are set appropriately, and the other components are set to represent the specified calendar time, but with their values forced to the ranges indicated above; the final value of tm_mday is not set until tm_mon and tm_year are determined.</p>
</blockquote>

<p>Your best bet is to use <code>time()</code> and <code>localtime()</code> to populate a <code>tm</code> structure, then change the fields you want to change before calling <code>mktime()</code>. That way, you're guaranteed that <em>all</em> fields will have sensible values.</p>

<p>The following program shows one way to do this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

int main (void) {
    char buffer[100];
    time_t now;
    struct tm *ts;

    // Get today in local time and output it.

    now = time (NULL);
    struct tm *ts = localtime (&amp;now);
    strftime (buffer, 100, ""%A, %d %B %Y"", ts);
    printf (""Now      = %s\n"", buffer);

    // Advance day-of-month and make new date.
    // Probably need to intelligently handle month rollover.

    ts-&gt;tm_mday++;
    mktime (ts);
    strftime (buffer, 100, ""%A, %d %B %Y"", ts);
    printf (""Tomorrow = %s\n"", buffer);

    return 0;
}
</code></pre>

<p>The output of that program is:</p>

<pre><code>Now      = Tuesday, 09 October 2012
Tomorrow = Wednesday, 10 October 2012
</code></pre>

<hr>

<p>For what it's worth, here's a complete program that uses that method to give you the day of the week for a given date (defaults to today).</p>

<p>You can change the year, month and day of month with the optional <code>-y</code>, <code>-m</code> and <code>-d</code> arguments in any order you want, and as many times as you want, though only the last for each type counts.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

static int makeError (char *argVal, char *errStr) {
    printf (""Error with argument '%s': %s\n"", argVal, errStr);
    printf (""Usage: dow [-y&lt;year&gt;] [-m&lt;month&gt;] [-d&lt;day&gt;]\n"");
    return 1;
}

int main (int argc, char *argv[]) {
    int idx, intVal;
    char chVal;
    char buff[100];
    time_t now = time (NULL);
    struct tm *nowStr = localtime (&amp;now);

    for (idx = 1; idx &lt; argc; idx++) {
        chVal = (*argv[idx] != '-') ? '\0' : *(argv[idx] + 1);
        if ((chVal != 'y') &amp;&amp; (chVal != 'm') &amp;&amp; (chVal != 'd'))
            return makeError (argv[idx], ""does not start with '-y/m/d'"");

        intVal = atoi (argv[idx] + 2);
        if (intVal &lt; 0)
            return makeError (argv[idx], ""suffix is negative"");
        sprintf (buff, ""%d"", intVal);
        if (strcmp (buff, argv[idx] + 2) != 0)
            return makeError (argv[idx], ""suffix is not numeric"");

        switch (chVal) {
            case 'y': nowStr-&gt;tm_year = intVal - 1900; break;
            case 'm': nowStr-&gt;tm_mon = intVal - 1; break;
            case 'd': nowStr-&gt;tm_mday = intVal; break;
        }
    }

    mktime (nowStr);
    strftime (buff, sizeof (buff), ""%A, %d %B %Y"", nowStr);
    printf (""%s\n"", buff);

    return 0;
}
</code></pre>

<p>A sample transcript:</p>

<pre><code>pax&gt; ./dow
Tuesday, 09 October 2012

pax&gt; ./dow -y2011
Sunday, 09 October 2011

pax&gt; ./dow -y2000 -m1 -d1
Saturday, 01 January 2000
</code></pre>
",1
12792098,12792044,1,"<p>The most probable explanation is that your <code>strftime</code> requires <code>tm_wday</code> to have a meaningful value if you're going to ask it to print the day of the week.</p>

<p>This is the simplest available way to avoid having to compute it yourself:</p>

<pre><code>struct tm tm;

memset(&amp;tm, 0, sizeof(struct tm));
tm.tm_mday = Cur_Day;
tm.tm_mon = Cur_Month - 1;
tm.tm_year = entries[i].Year_Start - 1900;
tm.tm_hour = 12;

(void) timegm(&amp;tm); /* fills in the rest of `tm` as a side effect */

/* now call strftime */
</code></pre>

<p>If you don't have <code>timegm</code> you MAY be able to get away with using <code>mktime</code> instead (the problems with doing this calculation in 'local' time are largely irrelevant if you only want to print the <em>date</em>).  DO NOT use the ""portable version of <code>timegm</code>"" described in the Linux manpage for <code>timegm</code>, it has portability gotchas waiting to bite on almost every line!</p>
",0
18625583,18625268,0,"<p>If the struct is declared static within a function, its visibility will be limited to that function. Example (without macros):</p>

<pre><code>struct hoppa {
        int i;
        };

void start(void)
{
static struct hoppa one = {1};
}

void use_it(void)
{
one.i = 2; //FAIL
}
</code></pre>
",3
18625598,18625268,4,"<p>You can't get at that struct from another piece of code because you have declared it inside a braced block.  C scope rules prohibit access to code outside that block.  That's true even if you get your macro to generate correct name: __counter_info_F instead of __counter_info_FOO.</p>

<p>This isn't a #define issue, by the way.  By the time C sees the code, all macro processing is done and the compiler only sees the tokens produced by the preprocessor.</p>

<p>Find a way to get the job done without macros...and THEN figure out a macro representation to ease the coding.  </p>

<p>One way would be to use macros that don't use the do loops to seal off those variables.  The problem now is to generate unique names.  Look carefully at those macros and you'll see that that's the problem that the one-time-loops were created to solve...duplicate names creating double definitions.  If you unwrap the macro generated code, you'll have to solve the duplicate name problem in another way...probably by adding macro arguments.</p>

<p>One thing, for the record: You don't need a compound statement like do or for to contain a plain block.  Just enclosing in braces is good enough.  You can take off the ""do"" at the beginning and the ""while (0);"" at the end, and get the same effect.</p>
",5
10162545,10162465,25,"<p>The problem is that itoa() isn't a standard function. </p>

<p>You should take a look at <a href=""http://www.strudel.org.uk/itoa/"">this link</a> which gives you some alternative implementations</p>
",3
10162623,10162465,5,"<p>An alternative that is commonly used in place of <code>itoa</code> is <code>sprintf</code>/<code>snprintf</code>. These are part of <code>stdio.h</code>.</p>
",0
12840277,12840224,-1,"<p>You need to read up on floating point precision. Hint: the numbers <code>double</code> implement are not like ""real"" real numbers, as used in math. There are limits, and 9<sup>32</sup> is a very large number, it's not certain that you can add it to another <code>double</code> and maintain precision.</p>
",2
12840286,12840224,0,"<p>Add the condition in the test in your <code>for</code> loop:</p>

<pre><code>for( i = 1; i &lt; INT_MAX; i++)  {
</code></pre>

<p><strong>Note 1:</strong> </p>

<p>You should probably stop way earlier: few compilers have an <code>int</code> (or <code>double</code>) type that is big enough for 9^32. I've replaced it with the maximum <code>int</code> value.</p>

<p><strong>Note 2:</strong> </p>

<p>The current condition <code>i &lt;= i+1</code> will cause the code to loop until <code>i</code> overflows. The overflow will result in undefined behaviour, although in most implementations <code>i</code> will wrap to a negative value causing the loop to terminate.</p>
",5
10188412,10188365,5,"<p>Yes, it will work, no problem, it's the same as:</p>

<pre><code>char arr[] = {0x01,0x00,0x5E};
memcmp(mac, arr, 3);
</code></pre>
",0
10188821,10188365,0,"<p>In this context, an array doesn't really differ in any regard from a pointer (keyword ""array-to-pointer decay"").</p>

<p>Since C lets you define temporary arrays in this fashion, you are allowed to use this notation to test a bunch of values that are known at compile time to be in your <code>mac</code> array.</p>
",0
10189117,10188365,3,"<p>Yes it is alright. To declare an array anonymously like this, is known as ""compound literals"". It is a feature that was introduced in the C language with the C99 standard and will work with all compilers that follow the standard. It will not work with non-standard compilers like Visual C++.</p>

<p>You should however consider to declare it as <code>const char</code>, which would be more correct and may also result in better optimizations, since <code>const</code> might make it easier for the compiler/linker to place the array in static ROM instead of the stack.</p>
",1
16450548,16450448,0,"<p>If I am reading this correctly, you ""return"" the value via this field:</p>

<pre><code>proc-&gt;has_waiting-&gt;ret_val
</code></pre>

<p>but you reference it via this field:</p>

<pre><code>proc-&gt;ret_val
</code></pre>

<p>You should be using the same reference in both places.</p>

<p>EDIT: How about simplifying this and making <code>ret_val</code> a <code>char *</code>?</p>
",3
16950464,16950136,0,"<p><code>strlen(MSG_PRFX_ALL)=3</code> and <code>memcpy</code> just copied only 3 letters without <code>\0</code>
add before printf
<code>formattedMsg[strlen(MSG_PRFX_ALL)]='\0'</code></p>
",0
16950472,16950136,0,"<p>Try adding this line after the last <code>printf</code>:</p>

<pre><code>fflush(stdout);
</code></pre>
",0
16953503,16950136,0,"<p>Replace</p>

<pre><code>memcpy(formattedMsg, MSG_PRFX_ALL, strlen(MSG_PRFX_ALL));
</code></pre>

<p>with</p>

<pre><code>strcpy(formattedMsg, MSG_PRFX_ALL);
</code></pre>
",0
16952873,16950136,1,"<p>Include a newline character in your last printf statement.</p>

<pre><code>    printf(""msg to all: %s\n"",formattedMsg);
</code></pre>

<p>This will clear the buffer.</p>
",0
10743367,10708433,3,"<p>The answer is: that code is making an unwarranted assumption, so it needs to be fixed.  What that code should have done is cast <code>RAND_MAX</code> to <code>(int)</code> on usage.</p>

<p>While it would make a bit more sense for compilers to define their <code>RAND_MAX</code> macros as signed, the standard carefully avoids requiring them to do so.  That makes it a portability bug for any code to blindly assume it to be signed.</p>
",2
11813265,8021829,0,"<p>I have recently updated <a href=""http://crashme.codeplex.com/"" rel=""nofollow"">http://crashme.codeplex.com/</a> source code to work on Mac OS X Lion with Xcode command line tools, with changes to make it more potent on 64-bit x64 architectures. But under Windows I would suggest using the native windows port instead of cygwin, using the pre-compiled windows installer msi file. You can report bugs/issues on the codeplex site.</p>
",0
10164011,10163996,2,"<p>Because you're printing *cp+1.</p>

<p>Here's what cp looked like before: </p>

<p>=test<br />
^^^^^^^^</p>

<p>and here's after </p>

<p>&nbsp;test<br />
^^^^^^^^</p>

<p>You only overwrote the first character.</p>
",0
10164016,10163996,3,"<p>Unlike some other languages, C doesn't know what string is, it only knows where it ends, so it prints from the pointer that you give it.</p>

<pre><code>    [=test\0]
1:   ^start here
          ^ end at \0
2:    ^start here
          ^ end at \0

    [\0test\0]
3:   ^start here, it's \0, so stop
4:     ^start here
           ^ end at \0
</code></pre>
",0
10164017,10163996,2,"<p>It is irrelevant whether you set <code>cp[0]</code> to '\0'. You are printing <code>cp+1</code> which is still ""test"".</p>
",0
10164026,10163996,2,"<p>Because you are only setting the first character of the string to <code>\0</code>. The rest of the memory is untouched. So printing from <code>*cp + 1</code> begins printing from <code>Test</code> and not from <code>\0Test</code>.</p>
",0
10164038,10163996,2,"<p>Setting a character to <code>\0</code> will terminate the string before it at this point since <code>\0</code> is the string end character in C.</p>

<p>Anything after it is not affected by it, so it is a great way to avoid allocating more memory when splitting a string since you can just replace the separator with <code>\0</code> and then use the original pointer to the beginning of the string to get the first part, and <code>sep + 1</code> to get the second part.</p>
",0
11510753,11510726,13,"<p><a href=""http://en.wikipedia.org/wiki/Comma_operator"" rel=""nofollow noreferrer"">The Comma Operator</a></p>

<p>The comma operator has lower precedence than assignment (it has a lower precedence than <em>any</em> operator for that matter), so if you remove the parentheses the assignment takes place first and the result of the second expression is discarded.  So...</p>

<pre><code>int a = 10, b = 20;
int x = (a,b); // x == 20
int y = a,b;   // y == 10
// equivalent (in terms of assignment) to
//int y = a;
</code></pre>

<p>Note that the third line will cause an error as it is interpreted as a re-declaration of <code>b</code>, i.e.:</p>

<pre><code>int y = a;
int b;
</code></pre>

<p>I missed this at first, but it makes sense.  It is no different than the initial declaration of <code>a</code> and <code>b</code>, and in this case the comma is not an operator, it is a separator.</p>
",3
18861349,18860755,0,"<p>To fix the issue, I did the following:</p>

<ol>
<li>Increased the buffer size as mentioned in the <a href=""https://stackoverflow.com/users/16406/chris-dodd"">Chris Dodd's</a> answer <a href=""https://stackoverflow.com/a/18860789/1033422"">here</a>.</li>
<li>While I was debugging, I noticed strlen(rc) to be much bigger than it should be, so I have NULL terminated the rc string before passing it to strcat.</li>
</ol>

<p>The code <em>seems</em> to be working ok now.</p>

<pre><code>// Read all available text from the connection
char *sslRead (connection *c)
{
    const int readSize = 1024;
    char *rc = NULL;
    int received, count = 0;
    char buffer[1025];         // increased buffer

    if (c)
    {
        while (1)
        {
            if (!rc)
                rc = malloc (readSize * sizeof(char) + 1);
            else
                rc = realloc (rc, (count + 1) * readSize * sizeof(char) + 1);

            received = SSL_read (c-&gt;sslHandle, buffer, readSize);

            if (received &gt; 0)
            {
                rc[count * readSize] = '\0';   // null terminate rc
                buffer[received] = '\0';
                strcat (rc, buffer);
            }

            if (received &lt; readSize)
                break;
            count++;
        }
    }
    return rc;
}
</code></pre>
",0
12796804,12796719,0,"<p>You can read a character from the input with</p>

<pre><code> char chr;
 scanf (""%c"", &amp;chr);
</code></pre>

<p>Reading escape sequences can be operating system specific.  On most you would have to tell the terminal driver to not process escape sequences into other actions (like input line editing) and instead pass the raw characters through.  Once that is set, then you can repeat the above sequence for each character.</p>
",0
14852137,14852107,1,"<p>You are passing msg as a pointer.</p>

<pre><code>int extract(uint8_t *msg) 
{
    msg = get_value();
    print(msg); // I am able to print the value here.
}
</code></pre>

<p>should be </p>

<pre><code>int extract(uint8_t *msg) 
{
    *msg = get_value();
    print(*msg);
}
</code></pre>
",3
14852163,14852107,0,"<p>msg = get_value() assigns a value to a pointer. You should use  *msg = get_value() to assign value to variable msg defined in main.</p>
",0
14852739,14852107,1,"<p>If you combine all the answers given, you might get something working. </p>

<p>There's a number of errors in your code and it is unclear what is returned by <code>get_value()</code> and what is the parameter required to <code>print()</code>. 
My guess is your <code>print()</code> function takes a pointer - that's why <code>print()</code> works in <code>extract()</code> - and you should also pass the msg pointer by reference for it to work in main. So you might need something like this (C code):</p>

<pre><code>int extract(uint8_t **msg) 
{
    (*msg) = get_value();
    print(*msg);
}


int main()
{
     uint8_t *msg;
     extract(&amp;msg);
     print(msg)
}
</code></pre>
",0
9154114,9154088,2,"<p>No, there's no generic way to save a NULL to a text file, you'd need to decide on some way of encoding it in your config file.</p>

<p>In this particular case it'd simplest to just have <code>if(!strlen(sub[4]))</code> as you suggest.</p>

<p>If you want to have a config file format that supports NULLs I suggest using a markup langue or encoding format such as <a href=""http://www.yaml.org/"" rel=""nofollow"">YAML</a>, <a href=""http://www.json.org/"" rel=""nofollow"">JSON</a>, <a href=""http://en.wikipedia.org/wiki/INI_file"" rel=""nofollow"">INI</a>, or maybe <a href=""http://code.google.com/p/protobuf/"" rel=""nofollow"">Protocol Buffers</a> that way you can use an existing library and avoid having to reinvent the wheel.</p>

<p>Since you're already Gnome lib the <a href=""http://developer.gnome.org/libgnome/stable/libgnome-gnome-config.html"" rel=""nofollow"">Gnome config library</a> would be a good bet.</p>
",5
9154123,9154088,5,"<p>Sounds like g_strsplit() is not known (declared), so the compiler is assuming the default return type of int.
I'd check your include files to make sure the one declaring g_strsplit() is included.</p>
",3
9154166,9154088,1,"<p><code>g_strsplit</code> function is not declared in your source file and an implicit declaration of the function is made by the compiler. The implicit declaration is this one:</p>

<pre><code>/* function that takes an unspecified number of parameters and retuns an int */
extern int g_strsplit();
</code></pre>

<p>To fix it, include the relevant headers for the <code>g_strsplit</code> function:</p>

<pre><code>#include &lt;glib.h&gt;
#include &lt;glib/gprintf.h&gt;
</code></pre>
",0
19974041,19973683,1,"<p>Private functions in <code>raw.c</code> should of course be declared <code>static</code> (and omitted from the public header). Then they're only visible and callable from the same ""compilation unit"", i.e. from within <code>raw.c</code>.</p>
",0
19974054,19973683,1,"<p>Only public method should be put into the <code>.h</code></p>

<p>Private method must be declared <code>static</code> at the top of the <code>.c</code> file.</p>

<p>If your module is using multi <code>.c</code> files, you should not put the function into the public <code>.h</code>. Instead you should create a second private <code>.h</code>, for example : <code>mymodule_p.h</code> instead of <code>mymodule.h</code>.  It is like a protected function</p>
",0
19974077,19973683,3,"<p>First things first: ""OO's private / public concepts"" are <strong>not</strong> ""access control"". Even if something is ""private"" it's still there, and can still be accessed. You have protected it against <em>accidential</em> access, but that is a far cry from ""securing"" it (from an ""authorization"" point of view). A determined and / or malicious client can still get at it, because ""security"" is not what those mechanics are for.</p>

<p>Once you understood that, you realize that all those ""visibility"" things - whether you declare something in a header, or make it public vs. private, or whatever - are basically aiming at <em>maintainability</em>: Reducing the amount of identifiers in the current scope, reducing the amount of functions and variables you have to <em>think</em> about in a given context.</p>

<p>Then, you say that your ""instinct is to only include this get_line() method in raw.h"". You realize that this is faulty wording? You can <em>declare</em> that function in a header file, you can <em>include</em> that header file, but you don't <em>include</em> a <em>function</em>.</p>

<p>So. You implement functions that belong together in a translation unit (main.c, raw.c). You <em>declare</em> functions that might be called from <em>outside</em> that translation unit in that translation unit's header file (raw.h). All functions <em>not</em> to be called from the outside, you define as <code>static</code> inside the translation unit itself, and don't declare them in a header at all.</p>

<p>As for emulating another language's concepts, don't. Do things the way they are done in the language you are currently using, or use a different language.</p>
",4
17850962,17850890,1,"<p>Your assumption that </p>

<blockquote>
  <p>""all the variables which are not initialized, will be initialized to 0
  by the compiler ""</p>
</blockquote>

<p>is not true. It is uninitialized, the memory for the variable is allocated but the content is uninitialized.</p>
",0
17851028,17850890,4,"<p>The .bss contains <strong>global</strong> and <strong>static</strong> uninitialized variables. In your example, the array will be placed on the stack.</p>
",0
17851031,17850890,0,"<p>In your example the array is declared on the <code>stack</code>.</p>

<p>Thus nothing goes on to <code>.bss</code> </p>
",0
17851066,17850890,0,"<blockquote>
  <p>all the variables which are not initialized, will be initialized to 0 by the compiler and stored in the .bss section.</p>
</blockquote>

<p>No, only global variables and static variables that are un-initialized will be initialized to 0.</p>
",0
17851074,17850890,2,"<p>You are confusing two things here. If you talk abouit <code>.bss</code> or <code>.data</code> section your are talking about local (as in your example) versus global/static variables. </p>

<p>Local variables, as in your example, are allocated on the stack. There is no <code>.bss/.data</code> involved. This data will be uninitalized and has a randome value, whatever happens to be the value on the stack.</p>

<p>For global/static uninitialized variables, they are initiliazed to 0 when the program starts.</p>
",1
17851305,17850890,1,"<p>Already was said in previous responses that in your example the numbers array will be stored on stack and not on .bss section and that only global and static variables will be initialized to 0 if they are numeric types or NULL for objects</p>

<p>The following example shows where different variables will be stored</p>

<pre><code>int abc = 1;                            ----&gt;   Initialized Read-Write Data
char *str;                              ----&gt;   BSS
const int i = 10;                       -----&gt;  Initialized Read-Only Data

main()
{
    int ii,a=1,b=2,c;                   -----&gt;  Local Variables on Stack

    char *ptr;
    ptr = malloc(4);                     ------&gt; Allocated Memory in Heap

     c= a+b;                             ------&gt; Text

}
</code></pre>

<p>Also there is nice description <a href=""http://csg.lbl.gov/pipermail/vxwexplo/2004-January/004166.html"" rel=""nofollow"">here</a> </p>
",0
13486714,13486647,3,"<p>You are declaring <code>mess</code> as:</p>

<pre><code>char mess[]="""";
</code></pre>

<p>which makes its size equal to <code>1</code>, to hold the NUL character. Next you are scanning your input in that array:</p>

<pre><code>scanf(""%s"", mess);
</code></pre>

<p>which will not work, as there is not enough space.</p>

<p>To fix this you need to declare <code>mess</code> with correct size: one more than the length of the maximum number of characters you intend to store in it.</p>
",1
13486728,13486647,3,"<p>I do believe that the problem is</p>

<pre><code>char mess[]="""";
</code></pre>

<p>There is no memory allocated for the string to be scanned into.</p>

<p>Replace it with</p>

<pre><code>char mess[MAX_LENGTH];
mess[0] = 0;
</code></pre>

<p>Also be aware that scanf as you use it does not limit the length of the input, see <a href=""https://stackoverflow.com/questions/1621394/how-to-prevent-scanf-causing-a-buffer-overflow-in-c"">How to prevent scanf causing a buffer overflow in C?</a></p>
",0
13486782,13486647,3,"<p>When I run the code under <code>valgrind</code> on Mac OS X, I get the output:</p>

<pre><code>$ valgrind excbadacc
==80786== Memcheck, a memory error detector
==80786== Copyright (C) 2002-2011, and GNU GPL'd, by Julian Seward et al.
==80786== Using Valgrind-3.7.0 and LibVEX; rerun with -h for copyright info
==80786== Command: excbadacc
==80786== 
write your mess to codify: 
absintheabelones
==80786== Invalid write of size 1
==80786==    at 0x100000D1B: codify (excbadacc.c:53)
==80786==  Address 0x100007210 is 0 bytes after a block of size 16 alloc'd
==80786==    at 0xB823: malloc (vg_replace_malloc.c:266)
==80786==    by 0x100000CC5: codify (excbadacc.c:45)
==80786== 
==80786== Invalid read of size 1
==80786==    at 0xC894: strlen (mc_replace_strmem.c:398)
==80786==    by 0x1748C2: __vfprintf (in /usr/lib/system/libsystem_c.dylib)
==80786==    by 0x17318D: vfprintf_l (in /usr/lib/system/libsystem_c.dylib)
==80786==    by 0x17C2CF: printf (in /usr/lib/system/libsystem_c.dylib)
==80786==    by 0x100000DFA: main (excbadacc.c:18)
==80786==  Address 0x100007210 is 0 bytes after a block of size 16 alloc'd
==80786==    at 0xB823: malloc (vg_replace_malloc.c:266)
==80786==    by 0x100000CC5: codify (excbadacc.c:45)
==80786== 
your codified message is: AQBRSKHDAQDPZSDB
==80786== 
==80786== HEAP SUMMARY:
==80786==     in use at exit: 10,330 bytes in 36 blocks
==80786==   total heap usage: 36 allocs, 0 frees, 10,330 bytes allocated
==80786== 
==80786== LEAK SUMMARY:
==80786==    definitely lost: 43 bytes in 2 blocks
==80786==    indirectly lost: 0 bytes in 0 blocks
==80786==      possibly lost: 0 bytes in 0 blocks
==80786==    still reachable: 10,287 bytes in 34 blocks
==80786==         suppressed: 0 bytes in 0 blocks
==80786== Rerun with --leak-check=full to see details of leaked memory
==80786== 
==80786== For counts of detected and suppressed errors, rerun with: -v
==80786== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 1 from 1)
$
</code></pre>

<p>One trouble is that you have an off-by-one error in <code>codify()</code> at:</p>

<pre><code>size_t len=strlen(mess);
char *code=malloc(sizeof(char)*len);
</code></pre>

<p>You need to add 1 to allocate enough space for the null too.</p>

<p>Warning: for one run, I entered 'potato' and got the 'codified' output POTATO; that's not a very good encryption.</p>
",2
12279820,12279735,0,"<p>What part is it that you don't understand?</p>

<p>The first expression is consists of two expressions: a pointer dereferencing, and an expression that evaluates into a pointer. <code>*(int *)</code> is the first part, it references the pointer that must follow, and <code>&amp;M[index]</code> simply means ""the address of the index:th element of the array M`.</p>

<p>In both your example, assuming <code>M</code> is an <code>int</code> array, the casts are completely unnecessary and should be removed. You could just as well use:</p>

<pre><code>int x = *(&amp;M[index]);
</code></pre>

<p>This form has the added benefit of making the two parts clearer; the first part is just the <code>*</code> operator outside the parenthesis, the second part is the code inside the parenthesis.</p>

<p>or</p>

<pre><code>int x = M[index];
</code></pre>

<p>The latter form is the one to prefer, it's clear and to the point.</p>
",1
12279843,12279735,1,"<p>The former interprets the bytes of the memory at <code>&amp;M[index]</code> as if an <code>int</code> is stored there and gives you that <code>int</code>.</p>

<p>The latter takes the numerical value of <code>M[index]</code> and converts it to an <code>int</code>.</p>

<p>If <code>M[index]</code> is of type <code>int</code>, there's no difference, obviously.</p>
",0
12279844,12279735,2,"<p>If the datatype of M is not int[], they may differ, take the case where you have an array of 2 (16 bit) shorts, 0x0123 and 0x4567. The memory layout (big endian) would/may be;</p>

<pre><code>0x01 0x23 0x45 0x67
</code></pre>

<p>In the latter case with M[0], you'd assign the short correctly to the integer since you'd read M[0] and convert it to an integer, 0x00000123</p>

<p>In the first case you'd take the address of M[0] and <em>assume that what's in memory there is an integer</em>, that'd with a 32 bit integer type give the result 0x01234567 (ie all 4 bytes would be read)</p>
",0
12279894,12279735,1,"<p>The second one casts the value to an int, which means that it converts it in a meaningful way (and will cause an error if a cast is not possible), the first one grabs sizeof(int) bytes from a location in memory and represents them as an int, even though this may not make any sense.</p>

<p>For example:</p>

<pre><code>double a[10];
a[5] = 281907.2389727;
int x = *(int*)&amp;a[5];
int y = (int)a[5];
printf(""%d %d"", x, y);
</code></pre>

<p>Will output (on my machine/compiler):</p>

<pre><code>-189447571 281907
</code></pre>

<p>Because the cast (int) will round down the double, while * (int * ) will pick up the first sizeof(int) bytes of the double, and ""pretend"" it's an integer - this of course doesn't give a meaningful result as they have different sizes and binary representations.</p>
",0
18415729,17133389,0,"<p>You have passed the variable <code>saveframe</code> as a pointer; to change the value outside the function, do this:</p>

<pre><code>*saveframe += savestride; 
</code></pre>

<p>instead. This way, your value will now be retained even after function exits.</p>
",1
13431569,13431560,6,"<pre><code> int square_root = sqrt(sum);
</code></pre>

<p>is equivalent in C to:</p>

<pre><code>int square_root = (int) sqrt(sum);
</code></pre>

<p>Now be aware that if the integral part of a <code>double</code> is not representable in an <code>int</code> the behavior is undefined (in both cases).</p>
",2
13431577,13431560,5,"<p>Functionally there is no difference, but an explicit cast will draw the reader's attention to the fact that there is truncation going on.</p>
",2
13431590,13431560,2,"<p>If the square root of your number is an integer, it doesn't affect. but if it's a real number (for example square root of 10) you'll get a truncated integer which may be inconvenient for your program.</p>
",0
8766341,8766285,3,"<p>The conversion function could probably be simplified and corrected to something like this:</p>

<pre><code>int ConvertRegisterDesc(const char * token, REG_NAME_PAIR RegisterTable[])
{
    for (int i = 1; i != 32; ++i)
    {
        if (strcasecmp(RegisterTable[i].reg_number, token) == 0 ||
            strcasecmp(RegisterTable[i].reg_name,   token) == 0   )
        {
            return i;
        }
    }

   printf(""Error with register name \n"");
   return 0;
}
</code></pre>

<p>Now <code>ConvertRegisterDesc(""foo"", RegisterTable)</code> returns the index of an entry whose name <strong>or</strong> value is (a case variant of) <code>""foo""</code>, and <code>0</code> if no such entry could be found.</p>
",1
8770886,8766285,0,"<p>You seem to be using the <code>&amp;</code> operator instead of <code>&amp;&amp;</code>.<br>
<code>&amp;</code> does bitwise and, not logical and. So for example:<br>
<code>0x01 &amp; 0x02 == 0</code> - because no bit is set on both<br>
<code>0x01 &amp;&amp; 0x02 == 1</code> - because both 0x01 and 0x02 evaluate to true.<br></p>
",0
10180750,10180607,0,"<p>Maybe you can add a library which have some functions to handle the struct, like a ""pseudo"" class,</p>

<pre><code>int initFunc(int (*pfunc)(int c,...));
</code></pre>

<p>This function will save the pointer into the struct, like a context in POO, in the struct you will use it like a ""map"" of all the function an you will call each one using an id.</p>

<p>which returns an id, and you save it in an array,
then another func say</p>

<pre><code>int call(int id,int p1,...);
</code></pre>

<p>where you say the function id and the parameters, sure you must now which function is each id</p>
",1
10180668,10180607,0,"<p>This is on the edge of my knowledge, but I believe that you need to make the functions variadic as well, due to incompatibilities in the ABI.</p>

<p>see: <a href=""http://en.wikipedia.org/wiki/Variadic_function#Variadic_functions_in_C.2C_Objective-C.2C_C.2B.2B.2C_and_D"" rel=""nofollow"">wikipedia's example</a></p>
",7
10181279,10180607,1,"<p>Calling a non-variadic function through a variadic function pointer leads to <strong>undefined behaviour</strong>.  For a start, recall that the arguments to variadic functions undergo the <em>default argument promotions</em> (<code>char</code>s are converted to <code>int</code>s, etc.), which will totally screw things up.</p>

<p>It's not clear how or why you intend to dynamically call a function with differing numbers of arguments.  But one solution could be to use a union:</p>

<pre><code>typedef struct {
    int num_args;
    union {
        void (*f1)(int);
        void (*f2)(int, int);
        void (*f3)(int, int, int);
    } func;
} magic;


...

magic m;
...
switch (m.num_args) {
case 1: m.func.f1(arg1); break;
case 2: m.func.f2(arg1, arg2); break;
case 3: m.func.f3(arg1, arg2, arg3); break;
default: assert(0);
}
</code></pre>

<p>A second solution would be to rewrite all of your functions as variadic.</p>
",2
9150405,9150397,12,"<p>It means that you shouldn't assume that <code>system</code> will always succeed. Your code becomes unreliable this way. Appropriate error handling should be in place.</p>
",0
9150412,9150397,0,"<p>It's not an error, it's a warning.</p>
<p>It's just saying you're not checking the return of the <code>system()</code> call.</p>
<blockquote>
<p><strong>Return Value</strong></p>
<p>The value returned when the argument passed is not NULL,
depends on the running environment specifications. In many systems, 0
is used to indicate that the command was successfully executed and
other values to indicate some sort of error. When the argument passed
is NULL, the function returns a nonzero value if the command processor
is available, and zero otherwise.</p>
</blockquote>
<p>You shouldn't assume the call was successful, and treat failure.</p>
",0
9150420,9150397,13,"<p>The warning means <code>You did not check the return value of system(...)</code>.
To avoid this warning, simply check the return value!</p>

<pre><code>int systemRet = system(commandLine);
if(systemRet == -1){
  // The system method failed
}
</code></pre>

<p>This is, as <code>system</code> is not guaranteed to succeed.</p>
",1
9150499,9150397,6,"<p>The library writers declared this function as <code>warn_unused_result</code>, because they feel it is important that you check whether the call succeeded.  One of your compiler flags told the compiler to check for this, so it's warning you about it.  The proper way to avoid the warning is to check the return value and handle errors appropriately (even if it's just printing an error message.  On a related note, you should check the return value of <code>snprintf</code> to ensure your buffer was big enough.</p>
",0
16948132,16948029,4,"<p>You want to tell your shell to interpret escape sequences correctly. If you're using Bash:</p>

<pre><code>$ ./a.out $'\1'
</code></pre>
",0
14820958,14820904,4,"<p>This:</p>

<pre><code>for (i = 1; i &lt; 5; i++) {
    nodePtr-&gt;nextPtr = malloc(sizeof(node)); 
    nodePtr-&gt;value = i;
}
</code></pre>

<p>allocates a node four times, then it always overwrites the same element, since you don't update <code>nodePtr</code>. It should be</p>

<pre><code>for (i = 1; i &lt; 5; i++) {
    nodePtr-&gt;nextPtr = malloc(sizeof(node)); 
    nodePtr-&gt;value = i;
    nodePtr = nodePtr-&gt;nextPtr;
}
</code></pre>

<p>instead (and not just in this particular case - look for this everywhere in your code and fix it, else you'll end up with all those more or less funny results of undefined behavior...).</p>

<p>Furthermore, in <code>printLinkedList()</code>,</p>

<pre><code>while(nodePtr-&gt;nextPtr != NULL)
</code></pre>

<p>should be</p>

<pre><code>while(nodePtr != NULL)
</code></pre>

<p>else you'll be dereferencing <code>NULL</code> upon the last iteration (and BANG!)</p>
",3
13752194,13751647,1,"<p>Try</p>

<pre><code>goto *(fiber-&gt;restore);
</code></pre>

<p>See</p>

<p><a href=""http://gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html"" rel=""nofollow"">http://gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html</a></p>

<p>Also, the stack depth does not matter for the function <em>code</em> address - only shared library relocations do (the page above also explains how to do that nicely).</p>
",0
15588205,15587890,1,"<p>If I've understood correctly the cleanup function is used for cleaning up invidual elements in the vector. (In C++ terms it would be the destructor for the element type.) So when ever you remove an element from the vector the cleanup function should be called for the element. It's probably defined something like this:</p>

<pre><code>typedef void (*CVectorCleanupElemFn)(void*);
</code></pre>

<p>So you would just store the function pointer in your struct</p>

<pre><code>typedef struct CVectorImplementation {
    // include your desired fields here
     int head;
     int tail;
     int numElements;
     int capacity;
     int elemSize;
     void* vector;
     CVectorCleanupElemFn cleanupFn;
} CVector;
</code></pre>

<p>And you would call it like this:</p>

<pre><code>(*cvector-&gt;cleanupFn)(pointerToTheElement)
</code></pre>

<p>edit:
In the CVectorDispose function the idea is correct but it's a bit buggy. You're storing a void pointer to the buffer so you need to convert it to <code>char*</code> to do arithmetic with it. And you need to take account the element size:</p>

<pre><code>(*cv-&gt;cleanupFn)((char*)cv-&gt;vector + index * cv-&gt;elemSize);
</code></pre>

<p>and your loop is one element too long, if tail is the index one past the last element. Should be</p>

<pre><code>while(index &lt; tail)
</code></pre>
",2
10761723,10761713,24,"<p>The <code>f</code> in <code>printf</code> stands for <strong>formatted</strong>, its used for printing with formatted output.</p>
",3
10761727,10761713,0,"<p>printf allows for formatting, while print doesnt. Also, print doesn't exist in C. I don't even know what printg is.</p>
",2
10761734,10761713,0,"<p>If I'm not mistaken, printf stands for ""Print formatted data to stdout"". </p>
",1
10762577,10761713,3,"<p>As others have noted, the <em>trailing</em> <code>f</code> indicates formatted output (or formatted input for functions in the <code>scanf</code> family).</p>

<p>However, I'll add that the distinction matters because it's important for callers to know that the string is expected to have format-specifier semantics.  For example, do not do this:</p>

<pre><code>char* s = get_some_user_input();
printf(s); // WRONG.  Instead use: printf(""%s"", s) or fputs(stdout, s)
</code></pre>

<p>If <code>s</code> happens to contain <code>%</code> characters, printing it directly with <code>printf</code> can cause it to access non-existent arguments, leading to undefined behavior (and this is a cause for some security vulnerabilities).  Keep this naming convention in mind if you ever define your own <code>printf</code>-like variadic functions.</p>
",0
8808182,8808145,0,"<p>Why are you using a while loop?  Do you want show_warning(); to be called once, or repeatedly?  If you answered once then you only need an if-statement.</p>
",0
8808184,8808145,0,"<p>Also what happens when no <code>scanf</code> succeeded? The variable <code>s</code> remains unchanged (and perhaps with an undefined value, if you did not initialize it). You should set it, or change the condition of the <code>while</code> !</p>

<p>And you really should learn to compile with warnings enabled and debugging information (i.e. <code>gcc -Wall -g</code> on Linux) and to use a debugger (e.g. <code>gdb</code> on Linux)</p>
",1
8808284,8808145,5,"<p>The problem is that the failed input operation doesn't extract any characters from the stream (and you'll keep reading the invalid input over and over), so you have to empty the input manually. For example:</p>

<pre><code>char buf[1000];

// ...

if(scanf(""%d"", &amp;s) != 1)
{
    puts(""Error, try again: "");
    fgets(buf, 1000, stdin);
}
</code></pre>

<p>As I suggested in the <a href=""https://stackoverflow.com/a/8808101/596781"">other question</a>, if you use <code>fgets</code> from the start to always read one line and process it later, you overcome this problem.</p>

<p>(The same philosophy is true in C++: read the whole line first so the input stream can move on, and process the line later to see if its valid.)</p>
",4
8808315,8808145,0,"<p>What makes you think it is looping until infinity?</p>

<p>You only get the warning message when you have not entered a number because it did not read a token.</p>

<p>Changing the &amp;&amp; to || though is a certain way to ensure it will run to infinity as your loop will never break then.</p>

<p>You might want an alternative message to prompt the user to enter data when they did enter a number but not 1 or 2?</p>
",0
8808378,8808145,0,"<p>I'm assuming you're having issues when a non-integer is input. This is because <code>scanf</code> leaves non-matching characters in the buffer, so subsequent calls are seeing the same input and looping.</p>

<p>What you need to do is if the <code>scanf</code> call returns any number other 1 is: read that character in using <code>scanf(""%c"",&amp;somechar)</code> so you can print it and tell the user that it isn't accepted. The non-accepted input will then have been removed so the next call to <code>scanf</code> will give you the next input rather than the one you saw on the previous iteration.</p>
",0
13707527,13707451,5,"<p>Yes, it is undefined behavior, according to section 6.5.7 paragraph 3</p>

<blockquote>
  <p>... If the value of the right operand is negative or is greater than or equal to the width of the promoted left operand, the behavior is undefined.</p>
</blockquote>
",5
13707529,13707451,3,"<pre><code>ISO c99 : 6.5.7 Bitwise shift operators
</code></pre>

<p><code>3<br>
The integer promotions are performed on each of the operands. The type of the result is
that of the promoted left operand. If the value of the right operand is negative or is
greater than or equal to the width of the promoted left operand, the behavior is undefined.</code></p>

<p><code>5<br>
The result of E1 &gt;&gt; E2 is E1 right-shifted E2 bit positions. If E1 has an unsigned type
or if E1 has a signed type and a nonnegative value, the value of the result is the integral
part of the quotient of E1 / 2E2. If E1 has a signed type and a negative value, the
resulting value is implementation-defined</code></p>

<p>You can see c-standard clarifies everything.</p>
",0
13476309,13476240,6,"<p>Try to compile it using tcc: <a href=""http://bellard.org/tcc/"" rel=""noreferrer"">http://bellard.org/tcc/</a> .</p>
",3
13476374,13476240,1,"<p>Which libraries do you use?
You don't need any libraries for reversing a file in C except the standard lib. Then your executable should be no larger than 2kb.</p>

<p>However if I compile:</p>

<pre><code>int main()
{
    return 0;
}
</code></pre>

<p>with MinGW, the size of the executable is equal to 48kb. But I haven't used any optimalization flags.</p>

<p>Edit: With the -s flag, it reduces to 7,5 kb.</p>
",0
13476402,13476240,3,"<pre><code>#include &lt;stdio.h&gt;
</code></pre>

<p>Let it be said by someone who implemented his own version of the stdio functions: They are quite big, and somewhat interdependent. Linking one of them links in several others automatically.</p>

<p>Since this is a one-time cost, and doesn't matter in the scope of big applications, most libraries don't bother much with optimizing this away.</p>

<p>That being said, compiling into a <em>dynamically</em> linking executable instead of a static one is usually the way to go. If you <em>have</em> to have a statically linked executable, you might want to look at one of the libraries optimized for embedded environments, as they are more focussed on small-size optimizations like this.</p>
",0
13476677,13476240,1,"<p>Check out <a href=""http://gcc.gnu.org/onlinedocs/gcc/Link-Options.html#Link-Options"" rel=""nofollow""><code>-s</code></a> gcc flag:</p>

<blockquote>
  <p>-s
      Remove all symbol table and relocation information from the executable.</p>
</blockquote>

<p>A test with small C program that I'm developing:</p>

<p>Without <code>-s</code>: <strong>120,2 Kib</strong> </p>

<p>With    <code>-s</code>: <strong>58,3  Kib</strong></p>

<p>By removing dead code from your executable:</p>

<p>By using <code>-fdata-sections -ffunction-sections</code> the compiler will put the unused function into separed section that by using <code>-Wl,--gc-sections</code> will be removed by the `link.</p>

<p>The file size now is: <strong>50,2 Kib</strong></p>

<p>By <code>-O2</code></p>

<p>do a lot of optimizations, but without increase file size, usually, unlike.</p>

<p>The file size now is: <strong>42,1 KiB</strong></p>

<p>gcc there is too some <code>-O*</code> to optimization in favor to file size.</p>
",0
10131664,10131624,4,"<p>Two choices:</p>

<ol>
<li><p>Use <code>#include &lt;itsmagic1c/filename.h&gt;</code></p></li>
<li><p>Use <code>#include &lt;filename.h&gt;</code> as before but add a <code>-I</code> switch.</p></li>
</ol>

<p>Boost etc use method 1. (which works well provided you have Boost installed in system locations as you would on  a reasonably standard Linux box with reasonable package management).</p>

<p>Method 2. is fine too, but more work on the build system, Makefiles, etc.</p>
",2
10131670,10131624,2,"<p>Usually, you would put your own headers in the same directory or in a subdirectory. Same-dir includes work with """". For bracket includes, if you use gcc, you can pass additional include directories with</p>

<pre><code>  -Irelativedir 
</code></pre>

<p>or</p>

<pre><code>  -I/usr/local/yourpath.
</code></pre>
",2
10159299,10159230,6,"<p>You can use <a href=""http://www.cplusplus.com/reference/clibrary/cstring/strchr/""><code>strchr</code></a> for that, and if the return is not null, you have found a bad character.</p>

<pre><code>char bad_chars[] = ""!@%^*~|"";
char invalid_found = FALSE;
int i;
for (i = 0; i &lt; strlen(bad_chars); ++i) {
    if (strchr(filename, bad_chars[i]) != NULL) {
        invalid_found = TRUE;
        break;
    }
}
if (invalid_found) {
    printf(""Invalid file name"");
}
</code></pre>
",3
10159312,10159230,2,"<p>You could try regex:</p>

<pre><code>#include &lt;stdlib.h&gt; 
#include &lt;string.h&gt;
#include &lt;regex.h&gt;

int main (void) {
    char fileName[100];
    int comp; 
    regex_t myregex; 

    // Compile the regular expression 
    comp = regcomp(&amp;myregex, ""^[a-zA-Z0-9.' '\[\]_-]+$"", REG_EXTENDED | REG_NOSUB) ;

    printf(""Enter a file name\n"");
    scanf(""%s"",fileName) ; 

    // Compare fileName to the regex 
    if (!regexec(&amp;myregex, fileName, 0 , 0 , 0)) {
        printf(""fileName %s is valid.\n"", fileName);  
    } else {
        printf(""fileName %s is invalid.\n"", fileName);
    }
    return 0;
}
</code></pre>
",2
10159376,10159230,0,"<p>This maybe a unique solution (I don't have enough info on your application, so I will post it anyway), but if you only want alphanumeric names, you can compare the integer value of a range of characters which would be a simple(r) if statement:</p>

<p>If you want to see if its a lower/upper case or a number: </p>

<p><strong>//pseudo</strong>
if(0-9, a-z, A-Z)continue;</p>

<p>else  reject;</p>

<pre><code>for(i=0;...;...){
    if((filename[i]==32)||(filename[i]&gt;47 &amp;&amp; filename[i]&lt;58 )||(filename[i]&gt;64 &amp;&amp; filename[i]&lt;91)||
    (filename[i]&gt;96 &amp;&amp; filename[i]&lt;123))
        continue;
else{
...//reject filename
}
</code></pre>

<p>Alternatively you can see if its a non-alphanumeric...</p>

<pre><code>for(i=0;...;...){
    if((filename[i]&lt;=47) || (filename[i]&lt;=64 &amp;&amp; filename[i]&gt;=58) ||
    (filename[i]&lt;=96 &amp;&amp; filename[i]&lt;=91) || (filename[i]&lt;=123)){
        reject;
    else{
        ...//nothing
    }
</code></pre>

<p><a href=""http://www.asciitable.com/"" rel=""nofollow"">http://www.asciitable.com/</a></p>
",5
8791009,8790977,11,"<p>That should be </p>

<pre><code>help(argv); 
</code></pre>

<p>and</p>

<pre><code>void help(const char **argv) {
    fprintf(stderr, ""Usage %s: [option]\n"", argv[0]);
}
</code></pre>

<p>Using a <code>char**</code> because you are passing an array of strings (aka pointers to char).</p>
",0
8791022,8790977,2,"<p>There's no need to dereference it. <code>[0]</code> is the same as <code>*argv</code>, which would be a <code>char</code>, when you want a <code>char*</code>.</p>

<pre><code>void help(const char *argv) {
    fprintf(stderr, ""Usage %s: [option]\n"", argv);
}
</code></pre>

<p>Alternatively, you may want to do it this way:</p>

<pre><code>help(argv); // don't dereference

//...

void help(const char **argv) {
    fprintf(stderr, ""Usage %s: [option]\n"", argv[0]);
}
</code></pre>
",0
8791024,8790977,1,"<p>start by changing </p>

<pre><code>void help(const char *argv);
</code></pre>

<p>to </p>

<pre><code>void help(const char *argv[]);
//or
void help(const char **argv);
</code></pre>

<p>next change</p>

<pre><code>void help(const char *argv) {
    fprintf(stderr, ""Usage %s: [option]\n"", argv[0]);
}
</code></pre>

<p>to
v</p>

<pre><code>oid help(const char **argv) { // or with []...
    fprintf(stderr, ""Usage %s: [option]\n"", argv[0]);
}
</code></pre>

<p>and call it like:</p>

<pre><code>help(argv);
</code></pre>
",0
8791079,8790977,1,"<p>Whenever you pass a variable in C, make sure you don't change the type of the variable, with the one exception that you can convert an array representation to a pointer representation.  So</p>

<pre><code>char *argv[]
</code></pre>

<p>should be received as</p>

<pre><code>char **argv
</code></pre>

<p>and then the passing is simply</p>

<pre><code>myfunc(argv);
</code></pre>
",0
14730143,14727243,1,"<p>This should help: <a href=""https://stackoverflow.com/questions/3463426/in-c-how-should-i-read-a-text-file-and-print-all-strings"">In C, how should I read a text file and print all strings</a></p>

<p>When using</p>

<pre><code> fwrite(buf, 1, nread, stdout);
</code></pre>

<p>The stdout is the output stream. You can use a file stream ( FILE * ) instead of stdout.</p>
",0
14727277,14727243,1,"<p>The <code>fread()</code> function only accepts <em>one</em> argument of type <code>FILE *</code>.</p>

<p>You're essentially overwriting the C library's internal file representation with data from the file.</p>

<p>See any <a href=""http://linux.die.net/man/3/fread"" rel=""nofollow"">basic reference</a> for the proper prototype for <code>fread()</code>. You need a buffer, something like:</p>

<pre><code>char buffer[1024];

fread(buffer, 1, sizeof buffer, fp);
</code></pre>

<p>Also, you must of course check the return value of <code>fread()</code>. Further, I would suggest using better names than <code>fd</code> and <code>fp</code>, they're pretty opaque.</p>
",1
8798071,8798063,-6,"<p>Sometimes in cases like these, it is helpful to call <a href=""http://linux.die.net/man/3/fflush"" rel=""nofollow""><code>fflush()</code></a> on <a href=""http://linux.die.net/man/3/stdin"" rel=""nofollow""><code>stdin</code></a> before reading from it:</p>

<pre><code>char name[40+1];
printf(""\n\tName: "");
fflush(stdin);
scanf(""%40s"", name);
</code></pre>

<p>Depending on the circumstances, there may be a newline in the input buffer that causes your first <a href=""http://www.cplusplus.com/reference/clibrary/cstdio/scanf/"" rel=""nofollow""><code>scanf</code></a> to get skipped (given no input).</p>

<p>Also note that you should specify the size of the buffer in <a href=""http://www.cplusplus.com/reference/clibrary/cstdio/scanf/"" rel=""nofollow""><code>scanf</code></a> as to avoid <a href=""http://en.wikipedia.org/wiki/Buffer_overflow"" rel=""nofollow"">buffer overflows</a>.</p>

<p>A format specifier for scanf looks like this:</p>

<pre><code>%[*][width][modifiers]type
</code></pre>

<blockquote>
  <blockquote>
    <p>width: Specifies the maximum number of characters to be read in the current reading operation</p>
  </blockquote>
</blockquote>

<p>Thus, the <code>%40s</code> specifies that only 40 characters may be read in to the string. Note that the buffer is 41 characters, leaving room for the NULL terminator.</p>

<p><strong>Edit</strong>: Some sources (like <a href=""http://faq.cprogramming.com/cgi-bin/smartfaq.cgi?answer=1052863818&amp;id=1043284351"" rel=""nofollow"">this</a> and <a href=""http://www.gidnetwork.com/b-57.html"" rel=""nofollow"">this</a>) say that you should avoid calling <code>fflush(stdin)</code> and it is incorrect. <em>However</em>, the <a href=""http://linux.die.net/man/3/fflush"" rel=""nofollow"">Linux man page</a> states:</p>

<blockquote>
  <blockquote>
    <p>For input streams, fflush() discards any buffered data that has been fetched from the underlying file, but has not been consumed by the application.</p>
    
    <p>Conforming to C89, C99, POSIX.1-2001, POSIX.1-2008.
    The standards do not specify the behavior for input streams. Most other implementations behave the same as Linux.</p>
  </blockquote>
</blockquote>

<p><strong>Additionally</strong>: <a href=""http://msdn.microsoft.com/en-us/library/9yky46tz%28v=VS.100%29.aspx"" rel=""nofollow"">MSDN</a> says nothing about calling <code>fflush(stdin)</code> other than the following:</p>

<blockquote>
  <blockquote>
    <p>If the stream is open for input, fflush clears the contents of the buffer.</p>
  </blockquote>
</blockquote>

<p>One would think that if calling <code>fflush(stdin)</code> was such a problem, one of the two largest sources of documentation on <code>fflush</code> would have mentioned this.</p>
",9
8798220,8798063,4,"<p>I know this question is already marked as answered, but as <code>fflush(stdin)</code> makes me cringe I wanted to post an alternative to clearing <code>stdin</code>:</p>

<pre><code>void clear_stdin(void)
{
   int c;
   do {
      c = fgetc(stdin);
   } while (c != '\n' &amp;&amp; c != EOF);
}
</code></pre>

<p>This will clear any <code>char</code>s up until a new line or until <code>EOF</code> is encountered. (You could just stick the body and condition of the <code>do..while</code> into the condition of a <code>while</code> loop, but I prefer to write it that way.)</p>

<p>It'd be useful to call that function for example after wanting to read in a single <code>char</code>, to prevent subsequent prompts from seeming to be skipped if the user enters more than 1 character.</p>

<p>Also consider using <code>fgets()</code> or providing a width specifier with <code>scanf()</code> in order to prevent overflows.</p>
",0
8798245,8798063,2,"<p>to replace fflush(stdin) in ""Jonathon Reinhart"" answer , i suggest this function, which is standard compliant : </p>

<pre><code>void clean_stdin(void)
{
    int c;

    do {
        c = getchar();
    } while (c != '\n' &amp;&amp; c != EOF);
}
</code></pre>
",2
8802990,8798063,0,"<p>The root of the problem is that the <code>""%c""</code> conversion specifier doesn't skip over whitespace.  Suppose you type ""Joe"" for the name; the input stream will contain the characters 'J', 'o', 'e', '\n'.  The first call to <code>scanf</code> looks for a string (<code>""%s""</code> conversion specifier); it will consume 'J', 'o', and 'e', and leave the '\n' in the input stream.  In response to the next prompt, you type a character like 'A', so the input stream now contains '\n', 'A', '\n'.  The next call to <code>scanf</code> looks for a single character; it will consume the first newline and return, leaving 'A' and '\n' in the input stream.  </p>

<p>Rather than flushing <code>stdin</code> (which is <em>not</em> a well-defined operation according to the language definition), it's better to avoid using the <code>""%c""</code> conversion specifier for interactive input; frankly, it's better to avoid using <code>scanf</code> for interactive input and use <code>fgets</code> instead.  </p>

<p>A quick and dirty solution would be to change the type of <code>type</code> from a simple <code>char</code> to an array of <code>char</code> and read it as a string:</p>

<pre><code>char type[2];
...
fgets(type, sizeof type, stdin);
</code></pre>

<p>This will skip over any newlines stuck in the input stream without having to flush anything.  Then you'd just use <code>type[0]</code> for your type value.  </p>

<p><strong>Edit</strong></p>

<p>If you don't want to change the type of <code>type</code>, you can do something like this:</p>

<pre><code>#include &lt;ctype.h&gt;
...
while ((type = fgetc(stdin)) &amp;&amp; isspace(type))
  ;
</code></pre>

<p>which will read individual characters from <code>stdin</code> until it sees a non-whitespace character.  </p>
",0
12318922,12318866,8,"<p>This comes from either one of those:</p>

<ul>
<li><code>.</code> or <code>./abc/</code> is not readable or traversable</li>
<li><code>./abc/p.txt</code> is not readable</li>
<li><code>./abc/p.txt</code> does not exist</li>
<li><code>./abc/p.txt</code> is a broken link</li>
</ul>

<p>Look at <code>errno</code> to know what's the real problem.</p>
",1
10749444,10749335,0,"<p>Local variables are stored in registers in most cases, because registers are pushed and poped from stack when you make function calls It looks like they are on stack.</p>

<p>There is actually no such tings as register variables because it is just some rarely used keyword in C  that tells compiler to try to put this in registers. I think that most compilers just ignore this keyword.</p>

<p>That why asked you more, because he was not sure if you deeply understand topic. Fact is that register variables are virtually on stack.</p>
",4
10749366,10749335,16,"<p>Because the storage area determines the <strong><em>scope</em></strong> and the <strong><em>lifetime</em></strong> of the variables.  </p>

<p>You choose a storage specification depending on your requirement, i.e:<br>
<strong><em>Lifetime:</em></strong> The duration you expect the particular variable needs to be alive and valid.<br>
<strong><em>Scope:</em></strong> The scope(areas) where you expect the variable to be accessible.</p>

<p>In short, each storage area provides a different functionality and you need various functionality hence different storage areas.</p>
",8
10749418,10749335,14,"<p>The C language does not define where any variables are stored, actually. It does, however, define three storage classes: static, automatic, and dynamic.</p>

<p>Static variables are created during program initialization (prior to <code>main()</code>) and remain in existence until program termination. File-scope ('global') and static variables fall under the category. While these commonly are stored in the data segment, the C standard does not require this to be the case, and in some cases (eg, C interpreters) they may be stored in other locations, such as the heap.</p>

<p>Automatic variables are local variables declared in a function body. They are created when or before program flow reaches their declaration, and destroyed when they go out of scope; new instances of these variables are created for recursive function invocations. A stack is a <em>convenient</em> way to implement these variables, but again, it is not required. You could implement automatics in the heap as well, if you chose, and they're commonly placed in registers as well. In many cases, an automatic variable will move between the stack and heap during its lifetime.</p>

<p>Note that the <code>register</code> annotation for automatic variables is a <em>hint</em> - the compiler is not obligated to do anything with it, and indeed many modern compilers ignore it completely.</p>

<p>Finally, dynamic objects (there is no such thing as a dynamic variable in C) refer to values created explicitly using <code>malloc</code>, <code>calloc</code> or other similar allocation functions. They come into existence when explicitly created, and are destroyed when explicitly freed. A heap is a convenient place to put these - or rather, one defines a heap based on the ability to do this style of allocation. But again, the compiler implementation is free to do whatever it wants. If the compiler can perform static analysis to determine the lifetime of a dynamic object, it might be able to move it to the data segment or stack (however, few C compilers do this sort of 'escape analysis').</p>

<p>The key takeaway here is that the C language standard only defines <em>how long</em> a given value is in existence for. And a minimum bound for this lifetime at that - it may remain longer than is required. Exactly how to place this in memory is a subject in which the language and library implementation is given significant freedom.</p>
",2
10749426,10749335,1,"<p>It is actually just an implementation detail that is convenient.</p>

<p>The compiler could, if he wanted to, generate local variables on the heap if he wishes.</p>

<p>It is just easier to create them on the stack since when leaving a function you can adjust the frame pointer with a simple add/subtract depending on the growth direction of the stack and so automatically free the used space for the next function. Creating locals on the heap however would mean more house-keeping work.</p>

<p>Another point is local variables must not be created on the stack, they can be stored and used just in a register if the compiler thinks that's more appropriate and has enough registers to do so.</p>
",0
12868204,12867397,0,"<p>The simplest approach is to use the <code>srand()</code> and <code>rand()</code> functions.</p>

<p><code>srand()</code> initializes the random number generator.  Typical usage is:</p>

<pre><code>srand(time(NULL));
</code></pre>

<p>which set a seed based on the current time. It's not <em>securely</em> random, but it avoids getting the same results every time you run the program (unless you run it twice in very quick succession).  You should call <code>srand()</code> only once during the execution of your program, before any calls to <code>rand()</code>.</p>

<p>The <code>rand()</code> function returns a random number in the range 0 to <code>RAND_MAX</code>; the value of <code>RAND_MAX</code> can vary from one system to another.  You can manipulate the result to get random numbers in a desired range; for example, <code>rand() % 2</code> gives you a random number with the value <code>0</code> or <code>1</code>.</p>

<p>Section 13 of the <a href=""http://www.c-faq.com"" rel=""nofollow"">comp.lang.c FAQ</a> covers this well.</p>

<p>Note that <code>rand()</code> typically doesn't generate very high-quality random numbers. For your purposes, that's probably ok. If it isn't, there are other system-specific ways to generate better random numbers.</p>
",0
8805800,8805770,2,"<p>I think you meant</p>

<pre><code>while(s!=1 &amp;&amp; s!=2)
</code></pre>
",0
8805809,8805770,6,"<p>Any number is either not equal to one <strong>or</strong> not equal to two: you can be certain of that :)</p>

<p>What you probably wanted to write was <code>&amp;&amp;</code>.</p>

<pre><code>while(s!=1 &amp;&amp; s!=2) {
}
</code></pre>
",0
8805811,8805770,1,"<p>Your <code>||</code> should be a <code>&amp;&amp;</code> in your <code>while</code> loop.</p>
",0
8805816,8805770,1,"<p>You need to change the || to &amp;&amp;.</p>
",0
8805822,8805770,1,"<p>Check your condition in while. Any variable can not have two values. So use &amp;&amp; instead of ||</p>
",0
8805824,8805770,1,"<pre><code>while(s!=1 || s!=2)
</code></pre>

<p>translates to:</p>

<pre><code>while(s is not 1 OR s is not 2)
</code></pre>

<p>So if <code>s</code> is <code>1</code>, it's not <code>2</code> ... which means you keep looping.</p>
",0
8805853,8805770,1,"<p>You need to change this:</p>

<pre><code>while(s!=1 || s!=2) {         helper();         scanf(""%d"", &amp;s);     } 
</code></pre>

<p>into this:</p>

<pre><code>while(s!=1 &amp;&amp; s!=2) {         helper();         scanf(""%d"", &amp;s);     } 
</code></pre>

<p>to work.</p>

<p>Keep coding!</p>
",0
8805863,8805770,1,"<p>Try changing the <code>||</code> to <code>&amp;&amp;</code>.</p>
",0
8725483,8725441,5,"<p>The <code>strcpy</code> in your code is wrong (it copies uninitialized data into unallocated memory). You probably want:</p>

<pre><code>newobj.name = malloc(strlen(name) + 1);
strcpy(newobj.name, name);
</code></pre>

<p>Or more simply, if you have <code>strdup</code>:</p>

<pre><code>newobj.name = strdup(name);
</code></pre>
",2
10798982,10798688,2,"<p>As others have already mentioned you are comparing the address of two functions (printf and scanf in this case) and since these functions cannot have the same address, the comparison fails making the program print ""hi"".</p>

<p>You can try the below code to understand it better</p>

<pre><code>int main(void)
{

   printf(""printf = %x\n"", printf);
   printf(""scanf = %x\n"", scanf);

   return 0;
}
</code></pre>
",0
10798727,10798688,3,"<p>Here you compare the adreses of the functions and as the functions are not the same, the equality does not hold. I do not see what confuses you.</p>
",1
10798728,10798688,1,"<p>Because the address of the function <code>printf</code> is not the same as the function <code>scanf</code>.</p>
",0
10798736,10798688,13,"<p>You aren't <strong>calling</strong> the functions and comparing the results, you are <strong>comparing the functions themselves</strong>, which boils down to comparing the addresses of the functions (function names will convert to function pointers in many contexts, this is one). What you wrote is equal to this:</p>

<pre><code>/* this is the correct signature for main by the way, not `void main()` */
int main(int argc, char **argv) {
    /* compare the address of printf to that of scanf */
    if (&amp;printf == &amp;scanf) {
        printf(""hello"");
    } else {
        printf(""hi"");
    }
}
</code></pre>

<p>Since <code>scanf</code> and <code>printf</code> are not the same function they live at a different address so the comparison fails and <code>hi</code> is printed.</p>
",1
10798785,10798688,3,"<p>You are not calling <code>printf</code> or <code>scanf</code> in the if statement. Rather, you are comparing the location of <code>scanf</code> and <code>printf</code> function in the memory, which are different (otherwise, they will run the same code, and have the same functionality).</p>

<p>You only get back the return value if you invoke the function. An invocation will look like <code>&lt;function_name&gt; ( &lt;arguments separated by commas&gt; )</code>.</p>
",0
13480829,13480781,3,"<blockquote>
  <p>The second operation is accoplished simply by reading the file.
  However I am drawing a blank on how to redirect the output from foo
  into myprogram with a pipe.</p>
</blockquote>

<p>When using a pipe redirection, the shell sets up the <code>stdout</code> of the process on the left to go to the <code>stdin</code> of the process on the right. Just read from <code>stdin</code> as you normally would and you're set.</p>
",0
13480898,13480781,0,"<p>You can do something like this:</p>

<pre><code>FILE* input;
//...
if (argc == 1) {
    input = stdin;
} else {
    input = fopen(argv[2] /* or whatever */, ""r"");
}
</code></pre>
",0
11525908,11525808,1,"<p>If you don't absolutely need to do the downloading inside your program, you could simply download the file using wget or curl and then pipe the output to STDIN of your program, from where you store the input in a variable. </p>

<p>This would allow you to use any file (from the web or not) as input.</p>
",0
16908790,16908577,0,"<p>The easiest solution I found was to use FIX_INT(x) described <a href=""http://paulbourke.net/dataformats/reading/"" rel=""nofollow"">here</a>.</p>
",0
16908976,16908577,3,"<p>For networking you want <code>htonl</code>, <code>htons</code> and their companions <code>ntohl</code> and <code>ntohs</code>, being host-to-network and network-to-host transforms for 32-bit and 16-bit integers.  These will be defined appropriately for the architecture you're on.  Thus on SPARC they'd be a no-op (a big-endian platform) and on x86 they are implemented as swaps.  They're from <code>&lt;arpa/inet.h&gt;</code> or <code>&lt;netinet/in.h&gt;</code></p>
",0
11118228,11118015,0,"<p>How about using <code>gettimeofday()</code> and checking the time before each <code>scanf</code> if time limit is exceeded you can break the loop and display message.</p>
",0
11118646,11118015,1,"<p>Your fundamental problem appears to be that scanf() does not return until the user has pressed Enter. So even if the timer has expired, nothing can happen until the user presses Enter.</p>

<p>In standard ANSI C, there is no real solution to this. You will need to make use of platform-specific functions.</p>

<p>One possibility on Windows would be to use the conio.h header file with functions like <a href=""http://msdn.microsoft.com/en-us/library/58w7c94c.aspx"" rel=""nofollow"">_kbhit()</a>. That allows you to test if a key has been pressed before you try to read it, so if no key has been pressed you can go on to check the timer. If a key has been pressed, you can read it with getc() without fear that getc() will just sit there waiting for the user to press a key. Keep adding keys read to a character array until you read a '\n' character. Then use sscanf() to convert the string into a number.</p>

<p>For the timer itself, you could just check the return value from the time() function.</p>

<p>This isn't the most efficient way to solve the problem, because when you write the code you'll find that the program is looping round testing _kbhit() again and again.</p>

<p>A more efficient solution on Windows would be to use overlapped I/O, but this is probably beyond the scope of what you are currently attempting.</p>
",0
11122509,11118015,0,"<p>You can use the signal to countdown and trigger the corresponding action.</p>

<pre><code>signal(SIGALRM,countdown);
setitimer(ITIMER_REAL,&amp;new_timeset,NULL);
</code></pre>

<p>countdown is the function you want to execute</p>
",0
14248911,14248895,10,"<p>Your PIPE_SIZE macro probably looks like this:</p>

<pre><code>#define PIPE_SIZE   100;
</code></pre>

<p>throw out the semi-colon (and add some parens if they aren't there).</p>
",4
12330325,12330170,6,"<p>Even though the two function arguments can be <em>consumed</em> in the same way, namely via <code>m[i][j]</code>, they're quite different:</p>

<ul>
<li><p><code>int m[M][N]</code> is an array of <code>M</code> arrays of <code>N</code> ints.</p></li>
<li><p><code>int **m</code> is a pointer to a pointer to an int.</p></li>
</ul>

<p>You cannot pass arrays as function arguments, so an ""array of <code>K</code> elements of type <code>T</code>"" decays to a ""poin&shy;ter-to-<code>T</code>"", pointing to the first element of the array. Thus it is permissible and equivalent to write the first form as <code>int m[][N]</code> in a function argument, since the value <code>M</code> is lost. However, the value <code>N</code> is <em>not</em> lost; it is part of the type!</p>

<p>So the following are admissible/erroneous for the first form:</p>

<pre><code>void f(int arr[M][N]);

int a[M][N];
int b[2*M][N];
int c[M][N + 1];

f(a);   // OK
f(b);   // OK; slowest extent is forgotten in the decay
//f(c); // Error! 'c' is not an array of {array of N ints}.
</code></pre>

<p>For the second form, the meaning is rather different:</p>

<pre><code>void g(int **p);

int a;
int * pa = &amp;a;

g(&amp;pa);          // fine, pointer to 'pa'

int arr[M][N];

// g(arr);  // Error, makes no sense
</code></pre>

<p>The expression <code>arr</code> designates the pointer to the first element of an array of arrays of <code>N</code> integers, i.e. its type is <code>int (*)[N]</code>. Dereferencing it gives an array of <code>N</code> integers, and <em>not</em> a pointer to an integer.</p>

<p>There is no way to convert the expression <code>arr</code> into a pointer to a pointer: If you said,</p>

<pre><code>int ** fool = (int**)arr;
</code></pre>

<p>then <code>*fool</code> would point to the first element of the first array (<code>arr[0]</code>), and <em>not to an <code>int</code> pointer</em>. So you cannot dereference the value further, because the value <em>is not a pointer</em>.</p>

<p>The only <em>correct</em> way to pass a two-dimensional array as a double pointer is to construct an intermediate helper array:</p>

<pre><code>int * helper[M];   // array of pointers

for (size_t i = 0; i != M; ++i)
{
    helper[i] = arr[i]; // implicit decay
}

g(helper);  // or ""g(&amp;helper[0])""
</code></pre>
",0
13754389,13754311,3,"<p>This has worked for me:</p>

<pre><code>void a()
{
}

void b()
{
}

void (*functions[2])();

int main()
{
    functions[0] = a;
    functions[1] = b;
    return 0;
}
</code></pre>
",5
13754431,13754311,4,"<pre><code>void (*functions[])() =
    {editProgramName,
     editProgramLength,
     editProgramCycles,
     editProgramNumberOfSets,
     editProgramEditSets,
     editProgramSave,
     editProgramCancel};
// now dispatch
functions[scroll.arrayFocusIndex]();
</code></pre>
",2
14865298,14865212,0,"<p>You could try passing the pointer to long variable and the size to your <code>doPrint</code> function as below</p>

<pre><code>doPrint((char *)(&amp;someLongVariable), sizeof(someLongvariable));

void doPrint(char *inpString, int size)
{
     write (STDOUT_FILENO, inpString, size);
}
</code></pre>
",1
14865332,14865212,0,"<p>Almost certainly you do not want to pass a <code>double</code> to this function.  It expects text to output which is the convention of <code>stdout</code>.</p>

<p>Almost certainly, you first need to represent the double's value in characters and pass that to the function.  This is a complex topic, and probably the point of the exercise.  Google for <a href=""https://www.google.com/#hl=en&amp;sugexp=les;&amp;gs_rn=3&amp;gs_ri=psy-ab&amp;gs_mss=convert%20float%20to%20as&amp;tok=o7gLcbJq5nSIhWArpUyxPQ&amp;cp=21&amp;gs_id=bu&amp;xhr=t&amp;q=convert+float+to+ascii&amp;es_nrs=true&amp;pf=p&amp;safe=off&amp;tbo=d&amp;output=search&amp;sclient=psy-ab&amp;oq=convert+float+to+asii&amp;gs_l=&amp;pbx=1&amp;bav=on.2,or.r_gc.r_pw.r_qf.&amp;bvm=bv.42452523,d.cGE&amp;fp=a04951e09a4959a8&amp;biw=1280&amp;bih=674"" rel=""nofollow"">""convert float to ascii""</a> for some ideas of what you have to do.</p>

<hr>

<p>Follow up:</p>

<p>If you are permitted to use <code>_ultoa_s</code>, then certainly you could call <a href=""http://linux.about.com/library/cmd/blcmdl3_fcvt.htm"" rel=""nofollow""><code>fcvt()</code> or <code>ecvt()</code></a>.</p>
",0
14865372,14865212,0,"<p>You didn't mention whether ""restricted"" means that the easy functions (printf and friends) aren't available on your (embedded?) platform, or that this is a restriction of the assignment.</p>

<p>Anyways, what you are doing won't work, ever.  You're passing in a binary variable (a long), it won't automagically get converted to a string.</p>

<p>Check out this function, found <a href=""http://code.google.com/p/my-itoa/"" rel=""nofollow"">here</a>, a compact itoa function.  Some tweaking required to make an ltoa out of it, but it's easy to see how it works.</p>

<pre><code>//return the length of result string. support only 10 radix for easy use and better performance
int my_itoa(int val, char* buf)
{
    const unsigned int radix = 10;

    char* p;
    unsigned int a;        //every digit
    int len;
    char* b;            //start of the digit char
    char temp;
    unsigned int u;

    p = buf;

    if (val &lt; 0)
    {
        *p++ = '-';
        val = 0 - val;
    }
    u = (unsigned int)val;

    b = p;

    do
    {
        a = u % radix;
        u /= radix;

        *p++ = a + '0';

    } while (u &gt; 0);

    len = (int)(p - buf);

    *p-- = 0;

    //swap
    do
    {
        temp = *p;
        *p = *b;
        *b = temp;
        --p;
        ++b;

    } while (b &lt; p);

    return len;
}
</code></pre>
",0
10826678,10826636,2,"<p>It means the buffer is only usable from where it comes in to scope (where it's defined) to the point where it goes out of scope, at the final <code>}</code>.</p>

<p>Any use of the buffer after that is undefined behaviour. The flushing of standard output would, by necessity, use that buffer, since that's where it's buffering the output characters.</p>

<p>Hence the problem - there's a possibility the memory area where the buffer was has been re-used before the flushing takes place (depending on how complex the C runtime environment shut-down code is).</p>

<p>Now it may seem to work okay, if it uses a part of the stack that's not used for anything else after <code>main</code> exits, but the fact that it <em>may</em> work in no way makes it a good idea.</p>

<p>Although that particular book you quote from is rather dated, this is <em>still</em> an issue even in the current C11 standard. In the sections detailing <code>setbuf</code> and <code>setvbuf</code>:</p>

<blockquote>
  <p>The buffer has to have a lifetime at least as great as the open stream, so the stream should be closed before a buffer that has automatic storage duration is deallocated upon block exit.</p>
</blockquote>
",0
10826767,10826636,2,"<p>You're allocating a buffer on the stack, and then calling <a href=""http://www.kernel.org/doc/man-pages/online/pages/man3/setbuf.3.html"" rel=""nofollow noreferrer""><code>setbuf</code></a> to say ""use this buffer for <code>stdout</code> from now on"".</p>

<p>Later, when <code>main</code> returns, its stack frame (including the memory for <code>buf</code>) is removed from the stack -- but <code>stdout</code> is still using memory at that address, because that's what you told it to do. The problem is, that memory could now be reused by somebody else -- your C runtime's shutdown code, an interrupt, whatever -- and the memory might well get overwritten with some other data before the C runtime gets around to flushing <code>stdout</code>'s buffer.</p>

<p>(Personally, I wouldn't use the terminology ""freed"" to refer to what happens to <code>buf</code> when <code>main</code> returns -- the word ""free"" usually refers to heap allocations, not stack allocations. But whatever you call it, when <code>main</code> returns, <code>buf</code> is memory that's no longer yours to give away.)</p>

<p>For a more vivid illustration of the problem, see <a href=""https://stackoverflow.com/a/6445794/87399"">Eric Lippert's answer</a> about using a local variable's memory outside its scope. It's the same problem as in your example.</p>
",0
9819787,9819750,1,"<p>Is your clipboard just for you application? If so you just need to mark an area of text and the <em>copy</em> it to memory for later retrieval with a <em>paste</em> command.</p>
",0
9827289,9819750,1,"<p>Ok, so lets assume your data structure is something like this:</p>

<pre><code>struct Textview {
    char *text;
    int startRange;
    int endRange;
};
</code></pre>

<p>So, when we add the cut function:</p>

<pre><code>char clipboard[1024]; // max of 1024 chars in the clipboard.

void cut(struct Textview *textview)
{
    // first we copy the text out (assuming you have 
    int nCpy = textview-&gt;endRange - textView-&gt;startRange &gt;= 1024 ? 1023 : textview-&gt;endRange - textview-&gt;startRange;
    strncpy(clipboard, textview-&gt;text + textview-&gt;startRange, nCpy);

    // next, we remove that section of the text
    memmove(textview-&gt;text + textview-&gt;startRange, textview-&gt;text + textview-&gt;endRange, strlen(textview-&gt;text + textview-&gt;endRange);        
}
</code></pre>

<p>And a copy function:</p>

<pre><code>void copy(struct Textview *textview)
{
      int nCpy = textview-&gt;endRange - textView-&gt;startRange &gt;= 1024 ? 1023 : textview-&gt;endRange - textview-&gt;startRange;
      strncpy(clipboard, textview-&gt;text + textview-&gt;startRange, nCpy);
}
</code></pre>

<p>And then the paste function.</p>

<pre><code>void paste(struct Textview *textview)
{
     // assuming we have enough space to paste the additional characters in.
     char *cpyText = strdup(textview-&gt;text); // if strdup isn't available, use malloc + strcpy.
     int cpyTextLen = strlen(cpyText);
     int clipboardLen = strlen(clipboard);
     memcpy(textview-&gt;text + textview-&gt;startRange, clipboard, clipboardLen);

     memcpy(textview-&gt;text + textview-&gt;startRange + clipboardLen, cpyText + textview-&gt;startRange + 1, cpyTextLen) - textView-&gt;startRange);

     textview-&gt;text[textView-&gt;startRange + clipboardLen + cpyTextLen + 1] = '\0';

     free(cpyText);
}
</code></pre>

<p>For undo-redo, you need a stack of the changes that were made.</p>
",0
8802913,8802873,2,"<p>Don't use = to assign a string. Allocate memory for it first, then copy.</p>
",0
8802944,8802873,1,"<p><code>char word[20];</code> is a single storage location: you're pointing each successive <code>dictionary[i]</code> to that same location, but overwriting it with a new value.
So, you just get an array of pointers to a chunk of memory (which you shouldn't really access after <code>createStrings</code> returns anyway, since it's local to that function).</p>

<p>Change</p>

<pre><code>dictionary[i] = word;
</code></pre>

<p>to</p>

<pre><code>dictionary[i] = strdup(word);
</code></pre>

<p>for the smallest possible change.</p>

<p>I can think of more improvements, but they probably belong on CodeReview, and this should be sufficient to make it work.</p>
",3
8802958,8802873,0,"<p>You have many problems in your code:</p>

<ul>
<li>You ask the user how many words they want to enter and then you put this many words into an array of unknown size. The user might have entered a number of words that is larger than the array.</li>
<li>You allow the user to enter any number of characters per word but your string can accept only 20.</li>
<li>You store the entered words in a local variable inside a function, and code outside this function attempts to access it after the function has returned and the stack space for this variable is no longer allocated.</li>
</ul>

<p>Any of these problems can cause your code to crash or allow a user to overwrite areas of memory they're not supposed to. You need to fix these problems.</p>

<p>As the other answerers have said, you need to use <code>strdup</code> or something to independantly store each string on the heap.</p>
",0
8725827,8725813,3,"<p>new is a keyword specific to C++ and C#, and cannot be used in C.</p>

<p>Memory on the heap in C is primarily allocated via the function <code>malloc</code> and freed using the function <code>free</code>.</p>

<p><code>calloc</code> is a version of <code>malloc</code> that also zeroes the memory before returning.</p>

<p><code>calloc</code> take two arguments, the number of array elements and the size of each array element.</p>

<p>eg.</p>

<pre><code>int i = 10;
int* p = calloc(i,sizeof(int));
</code></pre>

<p><a href=""http://www.cplusplus.com/reference/clibrary/cstdlib/calloc/"" rel=""nofollow"">http://www.cplusplus.com/reference/clibrary/cstdlib/calloc/</a></p>
",2
8725829,8725813,4,"<p>Try using <code>calloc</code> in <code>stdlib.h</code>:</p>

<pre><code>int *t = calloc(n, sizeof *t);
if (!t) {
    perror(""calloc"");
    return;
}
</code></pre>
",0
8725840,8725813,2,"<p>C doesn't have <code>new</code>, only C++.</p>

<p>Use calloc instead, found in <code>&lt;stdlib.h&gt;</code></p>

<pre><code>int *t = calloc(n, sizeof(int));
</code></pre>
",0
8724240,8724184,0,"<p>bin_search_print is missing a return after the printf.</p>

<pre><code>if (key == a[mid]) {
  printf(""%d"", key);
  return;
} else {
  if (key &lt; a[mid]) {
    high = mid - 1;
  } else {
    /* key &gt; a[mid] */
    low = mid + 1;
  }
}
</code></pre>

<p>Additional notes:
bin_search_print is declared as void and should not return a value.</p>

<p>Please use curly braces with your <code>if</code> statements!</p>

<p>Please turn on compiler warnings.</p>
",2
8724242,8724184,0,"<p>This is because you don't exit from the loop once you've found your key.</p>

<pre><code>while(low &lt;= high)
{
    mid=(low+high)/2;
    if(key==a[mid])
        printf (""%d"", key);   //&lt;-- okay found key, now look carefully at the logic
    else if(key&lt;a[mid])
        high=mid-1;
          else   /* key &gt;a[mid] */
        low=mid+1;
}
</code></pre>
",2
9199115,9199063,3,"<p>One issue is that <code>reverse</code> needs to be initialized:</p>

<pre><code>reverse = 0;
</code></pre>
",0
9199117,9199063,1,"<p>Check the initial value of <code>reverse</code> (hint: there isn't one). Right now it's starting with garbage in it.</p>
",0
9199122,9199063,4,"<p>Reverse is not initialized. This means there could be any value in that variable when you start touching it. Set it to 0 after you declare it and see what happens.</p>
",3
9199123,9199063,2,"<p>Hint: are the values of <code>digit</code> and <code>reverse</code> always what you expect they should be? Try printing them out every iteration, so you can see. Or, even better, learn to use your platform's debugger and just step through it.</p>

<hr>

<p>Spoiler: you'll probably get more out of solving it yourself, with the hint above.
But ... you didn't initialize <code>reverse</code> to zero before starting. That would be a good idea.</p>
",0
9199144,9199063,1,"<p>I would actually print the int to a string and reverse that through iterating through the string in reverse order. See sprintf for details.</p>
",0
9199274,9199063,0,"<p>I would scan the integer into a string, use the strlen function to determine its length, and then traverse it backwards.</p>
",0
16453480,16453457,6,"<p>One way to approach this problem would be to allocate a second string that is three times as large as <code>enteredCharStr</code> and copy the characters over one by one and when you see special character write the replaement instead. You want it to be three times as large since in the worst case you need to replace nearly all the characters.</p>
",4
16453484,16453457,0,"<p>You need to make a new string. Here's an example:</p>

<pre><code>char *str = ""abc$ddd"";
char *p = str;
char *buf = malloc(strlen(str)+1);
char *pbuf = buf;
while(*p) {
  if(*p != '$') *pbuf ++ = *p;
  p++;
}
</code></pre>

<p>It will copy from <code>str</code> to <code>buf</code> all non-<code>$</code>,byte per byte.</p>

<p>Note that in your case,you need to perform the right computation of size of new string.</p>
",0
16453486,16453457,0,"<p>A C 'string' is a fixed-size array of characters, and therefore there is no built-in notion of insertion.  You're effectively asking how to insert <code>n</code> characters into the middle of an array.</p>

<p>One strategy come to mind:</p>

<p>To insert a string of length <code>x</code> at position <code>i</code> of an array of length <code>n</code>:  </p>

<ul>
<li>Resize the array to size <code>n+x</code> (using something like <code>realloc</code>). </li>
<li>Shuffle every character beyond position <code>i</code> to position <code>i+x</code>.</li>
<li>Write your string into the <code>x</code> positions now freed by this shuffle operation. </li>
</ul>

<p>Alternatively, allocate a new array that is big enough to hold your target string (i.e., with all the substitutions applied), and then write your result into that by copying from the target array until you encounter a character you'd like to replace, then copy from the replacement string, then continue reading from the original source array.</p>
",0
16453599,16453457,0,"<p>I'm copying characters over one by one, and if I see a special character, (In this code only ""#"")
I copy in 3 characters, incrementing the index into the output buffer by 3.
You can also do something smarter to guess the buffer size, and perhaps loop over the entire operation, doubling the size of the buffer each time it overruns.</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

int main(int argc, char* argv[]){
    if (argc != 2) {
        exit(1);
    }
    char* input = argv[1];
    int bufferSize = 128;
    char* output = malloc(bufferSize);
    int outIndex = 0;
    int inIndex = 0;

    while(input[inIndex] != '\0'){
        switch (input[inIndex])
        {
            case '#':¡¤
                if(outIndex + 4 &gt; bufferSize){
                    // Overflow, retry or something.
                    exit(2);
                }
                output[outIndex]   = '%';
                output[outIndex+1] = '2';
                output[outIndex+2] = '3';
                outIndex = outIndex + 3;
                inIndex  = inIndex + 1;
                break;
            // Other cases
            default:
                if(outIndex + 2 &gt; bufferSize){
                    exit(2);
                }
                output[outIndex] = input[inIndex];
                outIndex = outIndex + 1;
                inIndex = inIndex + 1;
                break;
        }
    }
    output[outIndex] = '\0';

    printf(""%s\n"", output);
    return 0;
}
</code></pre>
",0
16460257,16453457,1,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int isspecial(int c){
    static char table[] = ""#%&amp;?=&lt;&gt;""; //add etc..
    return strchr(table, c) ? 1 : 0;
}

char *encode(const char *s){
    size_t capa = 1024;
    char *buff=malloc(capa*sizeof(char));
    size_t size = 0;
    for(;*s;++s){
        if(size + 3 &gt; capa){
            capa += 32;
            buff = realloc(buff, capa*sizeof(char));
        }
        if(isspecial(*s)){
            size+=sprintf(buff+size, ""%%%02x"", *s);
        } else {
            size+=sprintf(buff+size, ""%c"", *s);
        }
    }
    if(size == capa){
        buff=realloc(buff, (size+1)*sizeof(char));
    }
    buff[size++]='\0';

    return realloc(buff, size*sizeof(char));
}

int main(void){
    char *enteredCharStr = ""this=this&amp;that"";
    char *p = encode(enteredCharStr);
    printf(""%s\n"", p);
    free(p);
    return 0;
}
</code></pre>
",4
12879655,12879619,2,"<p>I suppose the obvious would be something like this:</p>

<pre><code>memset(test1.name, ' ', 16);

size_t len = min(16, strlen(user_input));

memcpy(test1.name, user_input, len);
</code></pre>

<p>If you want to zero-fill any excess space, that's quite a bit simpler:</p>

<pre><code>strncpy(test1.name, user_input, 16);
</code></pre>

<p>[The first time I've seen/heard somebody ask a question for which <code>strncpy</code> <em>could</em> actually be a correct answer.]</p>
",1
12879816,12879619,5,"<p>sprintf() can do it:</p>

<pre><code>sprintf(test1.name,""%-15s"",""John Doe"");
printf(""[%s] length of test1.name: %ld\n"",test1.name,strlen(test1.name));
sprintf(test1.name,""%-*s"",(int) sizeof(test1.name) - 1,""Jane Jones"");
printf(""[%s] length of test1.name: %ld\n"",test1.name,strlen(test1.name))
</code></pre>

<p>output:</p>

<pre><code>[John Doe       ] length of test1.name: 15
[Jane Jones     ] length of test1.name: 15
</code></pre>

<p>or</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int copy_with_pad(char *destination,const char *source, int dest_size, char pad_char)
{
   int pad_ctr = 0;
   if (dest_size &lt; 1 ) return -1;
   int source_length = strlen(source);
   int data_size = dest_size - 1;
   destination[data_size] = '\0';
   int i = 0;
   while (i &lt; data_size)
   {
      if ( i &gt;= source_length )
      {
         destination[i] = pad_char;
         pad_ctr++;
      }
      else
         destination[i] = source[i];
      i++;
   }
   return pad_ctr;
}


int main(void)
{
   struct test {
      char name[16];
   };
   struct test test1;
   int chars_padded = copy_with_pad(test1.name,""Hollywood Dan"",
                                    sizeof(test1.name),' ');
   printf(""%d padding chars added: [%s]\n"",chars_padded,test1.name);
   chars_padded = copy_with_pad(test1.name,""The Honorable Hollywood Dan Jr."",
                                 sizeof(test1.name),' ');
   printf(""%d padding chars added: [%s]\n"",chars_padded,test1.name);
   chars_padded = copy_with_pad(test1.name,"""",16,' ');
   printf(""%d padding chars added: [%s]\n"",chars_padded,test1.name);
}
</code></pre>

<p>output</p>

<pre><code>2 padding chars added: [Hollywood Dan  ]
0 padding chars added: [The Honorable H]
15 padding chars added: [               ]
</code></pre>
",1
12880550,12879619,0,"<pre><code>// first remember
// that  a character array of length 16 can only hold a string of 15
// chars because it needs the trailing zero
// this program puts in the user input (you should check that it is short enough to fit)
// then puts in the spaces, one at a time, then the terminating zero

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    char name [16];         // room for 15 chars plus a null terminator
    char word [] = ""hello""; // user input

    strcpy(name,word);      // copy user input to name
    int i;
    for (i = strlen(name); i &lt; (sizeof(name)-1); i++) {
        name[i] = ' ';      // pad with blanks
    }
    name[sizeof(name)-1] = 0; // string terminator

    printf(""name = \""%s\""\n"",name);
    return 0;
}
</code></pre>
",0
14826481,14826371,1,"<p>you are very closed, just a small difference</p>

<pre><code>FILE *f = fopen(""filename"", ""rb"");
long size = 0;

if (f == NULL)
 printf(""error""); //handle error
else
{
fseek(f, 0, SEEK_END);
size = ftell(f);
}
</code></pre>
",2
19572333,19572183,1,"<pre><code>  int main(void)
  {
      char* str1 = ""Hello"";
      char* str2 = ""World!"";
      // allocate one more byte for string terminate cher ('\n')
      int size = strlen(str1) + strlen(str2);
      char* str3 = (char*)malloc(size + 1);
      char* str_mod = str3;

      while( (*str_mod++ = *str1++) != '\0');
      str_mod--;
      while( (*str_mod++ = *str2++) != '\0');

      printf ( ""%s"", str3);
      free (str3);

      return 0;
  }
</code></pre>
",1
19572350,19572183,0,"<p>The constant strings are not modifyable. You are not modifying str3.
You need to </p>

<ol>
<li>get the length of str1 and str2.</li>
<li>malloc length of str1 + length str2 + 1 and assign to str3</li>
<li>You can use while loops if you like for the copy, or you can use strcpy and strcat to copy the strings to str3.</li>
</ol>

<p>Since you are trying to learn, I am trying not to write the code for you.</p>
",0
19572357,19572183,0,"<pre><code>int main (void){
    char* str1 = ""Hello"";
    char* str2 = ""World"";

    int size1 = strlen(str1);
    int size2 = strlen(str2);
    int i = 0;

    char* out = malloc(sizeof(char)*(size1+size2)+1);

    for (i = 0; i &lt; size1; i++){
        out[i] = str1[i];
    }
    for (i = 0; i &lt; size2; i++){
        out[i+size1] = str2[i];
    }
    out[strlen(out)-1] = \0;
    //out is a string.
    //dont forget to free when you are done.  free(out);

}
</code></pre>

<p>Its been a few months since i did C, but this would work.  my syntax might be slightly off.</p>
",1
19572221,19572183,6,"<pre><code>    while(*str1) str1++;
</code></pre>

<p>This advances <code>str1</code> until it points to the terminating zero byte at the end of the string constant.</p>

<pre><code>    while(*str1 = *str2++);
</code></pre>

<p>This modifies the terminating zero byte at the end of the string, but the string is a constant and so can't be modified.</p>

<p>If you want to assemble a string in memory, you need to allocate some space to do that in or use functions that do so. You could do:</p>

<pre><code>char *new_string = malloc(strlen(str1) + strlen(str2) + 1);
strcpy(new_string, str1);
strcat(new_string, str2);
</code></pre>

<p>The first line allocates enough space to hold <code>str1</code>'s contents, <code>str2</code>'s contents, and the terminating zero byte.</p>
",3
19574617,19572183,0,"<p>2nd attempt in question misses putting string terminating null to end of <code>str3</code>. So <code>puts</code> reads beyond end of data, prints garbage and may even crash if there is no 0 byte before reading invalid address. Add <code>*str3 ='\0';</code> after loops.</p>

<p>Additionally, you modify <code>str3</code> and lose start of string. Add one more variable, keep the pointer returned by <code>malloc</code>, and pass that to <code>puts</code>. Current code will start printing at the end of the new string.</p>

<p>Then when you have pointers to string literals, make them pointers to const char, because usually string literals are in read only memory area:</p>

<pre><code>const char* str1 = ""Hello"";
const char* str2 = ""World!"";
</code></pre>
",0
11169182,11168969,2,"<p>( I will explain how can you represent the picture if that is what are you asking )<br>From your picture I understand that you have 3 types of nodes and some rules:</p>

<ul>
<li>a) one for the number of rows and columns ( with 2 pointer )</li>
<li>b) one for the size of the matrix ( 2 pointers and the witdh and
height)</li>
<li>c) one with the value of an element that is not zero ( with 2
pointers, the colum value and the row value of the element and the
element)</li>
</ul>

<p>Rules:<br></p>

<ol>
<li>The b) element has a pointer to the first row element and first
column element</li>
<li>Each row element has a pointer to the next row element ( the last has a pointer
to the b) element )</li>
<li>Each colum element has a pointer to the next colum element and the last
has a pointer to the b) element </li>
<li>each row has the second pointer pointing the first c) element on their row</li>
<li>each colum has the second pointer pointing to the first c) element on their
colum</li>
<li>each element points to: the next c) element on their row and the next c) element on their column ( if there is no next element on the row just point to the row element, and if there is no next element on the column just point to the column element)</li>
</ol>

<p>For each rule if you can't apply you just skip it and leave that pointer null<br>
Hope it helped.
<br> You can create some custom <a href=""http://en.wikipedia.org/wiki/Linked_list"" rel=""nofollow"" >linked lists </a>  and just apply the rules<br>
<a href=""http://www.cprogramming.com/tutorial/c/lesson15.html"" rel=""nofollow""> Here </a> you have a simple tutorial</p>
",0
10827629,10827556,1,"<p>Most likely because it cannot find the executable. Either ensure your path is correct<sup>(a)</sup> or use the full path name:</p>

<pre><code>system (""c:\\windows\\system32\\bcdedit.exe"");
</code></pre>

<p>And, of course, this should go without saying: make sure you run it as an administrative user.</p>

<hr>

<p><sup>(a)</sup> You should be able to confirm this with something like:</p>

<pre><code>system (""path"");
</code></pre>
",3
17858721,10827556,2,"<p>It happens because when you run the <code>Command Prompt</code> via Start Menu or even the Execute window you are running the 64-bit <code>cmd</code> version, located at <code>C:\Windows\System32\cmd.exe</code>, however when call <code>cmd</code> from your c program it calls the 32-bit <code>cmd</code> version, located at <code>C:\Windows\SySWOW64\cmd.exe</code>. <strong>This happens because your C compiler generates a 32-bit application.</strong></p>

<p>According to MSDN:</p>

<blockquote>
  <p>The %windir%\System32 directory is reserved for 64-bit applications.
  Most DLL file names were not changed when 64-bit versions of the DLLs
  were created, so 32-bit versions of the DLLs are stored in a different
  directory. WOW64 hides this difference by using a file system
  redirector.</p>
  
  <p><strong>In most cases, whenever a 32-bit application attempts to access
  %windir%\System32, the access is redirected to %windir%\SysWOW64.</strong></p>
</blockquote>

<p>Source: <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa384187%28v=vs.85%29.aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/windows/desktop/aa384187%28v=vs.85%29.aspx</a></p>

<p>If you compare both <code>cmd</code>s you will realize that they are identical, what differs are the dll's.</p>

<p>The problem is that Windows x64 provides a 64-bit <code>bcdedit.exe</code> in the <code>System32</code> folder, but doesn't provide a 32-bit <code>bcdedit.exe</code> anywhere. <strong>So the 32-bit <code>cmd</code> can't run the 64-bit <code>bcdedit</code>, so it returns that this command is invalid.</strong></p>

<p><strong>Solution:</strong> You can both obtain a 32-bit <code>bcdedit</code> from a Windows x86 version or you can compile a 64-bit application.</p>
",0
10803408,10803316,0,"<p>Either use a fully qualified name for the file, or, with a bit more work, pass the commands from the C program to diskpart through an anonymous pipe using popen.</p>

<p>Example added:</p>

<pre><code>#include &lt;stdio.h&gt;

int main ( int argc, char *argv[] )
{
    char buffer[MAXBUF];
    FILE *fp = popen(""gzip -dc data.gz"",""r"");

    while (fgets(buffer,MAXBUF,fp)) {
        /* Process line of data, here just print it out¡­ */
        fputs(buffer,stdout);
    }

    printf (""Command exit status %d\n"", pclose(fp));
}
</code></pre>
",5
8747300,8747280,1,"<p>The cleanest way to fix this is by passing <code>data</code> as an additional argument to <code>add_student()</code>.</p>

<p>There are other errors, such as</p>

<ol>
<li>passing <code>5</code> as the value of <code>sequence</code> and then using it to index into <code>data</code>;</li>
<li>the use of <code>strcpy()</code> is incorrect as you haven't allocated memory for the <code>name</code> and <code>sex</code> fields;</li>
<li>the expressions <code>data[sequence].age[13]</code> and <code>data[sequence].class[2]</code> are not valid C.</li>
</ol>
",4
8747336,8747280,0,"<p><code>data</code> is in the scope of <code>main()</code>, and you're trying to use it in the scope of <code>add_student()</code>. You have two options:</p>

<ol>
<li>Put <code>data</code> in global scope, i.e. put its declaration outside of any functions.</li>
<li>Pass <code>data</code> into <code>add_student()</code> as a parameter.</li>
</ol>

<p>I generally prefer the latter, but there's use cases for both. Doing the first option will remove the need to pass along the length of the array, which you'd have to do if you passed it in as a parameter.</p>
",0
11100556,11100372,1,"<p>According your code, I think the problem is that you did not allocate memory for 'protein[]', and you should allocate memory for every index of protein to store your strings.Secondly, copying a string from one place to anther is not just a simple assignment like this:</p>

<p><code>protein[j]=*(result+i);</code></p>

<p>using <code>strncpy</code> to do that.All the above is my analysis of your problem.</p>
",10
11103819,11100372,0,"<p>Your code takes a line and stores it in the variable <code>result</code>.
You then assign protein to point into <code>result</code>.</p>

<p>The next iteration of your <code>for</code> loop overwrites <code>result</code> with the contents of the next line.</p>

<p>It is possible to declare a big chunk of memory statically, but it would probably be better to allocate memory dynamically, especially if you don't know the maximum size of the input file.</p>
",0
11162878,11100372,0,"<p>I have resolve the issues. Below is my code. Please suggest show can I make this code more generic.</p>

<pre><code>using namespace std;

int split(char* str, char splitstr[16][11]);

int main ()
{ 
  FILE *fp;
  char str[20] = {0}; 
  fp = fopen(""C:\\Cross Crystal Sheet.csv"", ""r"") ;

  char input[256];
  char s[619][15];
  string str2, str3;
  char result[16][11];
  int j=0;
  if (NULL != fp) 
       {
            while(fgets(str,sizeof(str),fp)!=NULL)
             {
                strcpy(input, str);
                int count = split(input, result);
                int tmp=count;

                for (int i=0; i&lt;count; i++) 
                   { 
                      str2 = result[i]; // ""generalities""
                      char * cstr;
                      cstr = new char [str2.size()+1];
                      strcpy (cstr, str2.c_str());
                      strcpy (s[j], cstr);
                      j++;
                   }

             }
       }

   char ss[10] ={0};
   printf(""Enter any main string to find \n"");
   scanf(""%10s"",ss);
 //  printf(""%d \n"",atoi(s[16]));

  int temp=0;
  for (int k=0;k&lt;j;k++)
  { 
       if (strncmp(s[k],ss,8)!=0)
         {
           temp=k; 
         }
       else
         {  
           int x=0;
           x=atoi(s[k-1]);
           if(x &gt;=1 &amp;&amp; x &lt;=95)
            {
               printf(""found at %d \n"",k);
                    for(k=k;k&lt;k+15;k++)
                        {
                          if (strncmp(s[k],""\n"",2)!=0)
                             {
                              printf(""%s \n"",s[k]);
                             }
                          else
                             {
                              return 0;
                             }
                       }
             }
             else

         {
                 continue;
             }
            }

         }
   }


int split(char* str, char splitstr[16][11])
{
   char* p;
   int i=0;
   char *string = strdup(str);
   p = strtok (string, "","");


   while(p!=NULL)
   {
       strcpy(splitstr[i++], p);
       p = strtok (NULL, "","");

       if( p ==NULL)
        {
         break;
        }
     unsigned charlength = strlen(p);
     if(charlength==1 ||charlength==2 )
        {
          break;
        }
   }
   return i;
}
=======
</code></pre>
",0
8792942,8792927,10,"<p>Change:</p>

<pre><code>char *filename;
</code></pre>

<p>To:</p>

<pre><code>char *filename = NULL;
</code></pre>

<p>Then your <code>NULL</code> tests will work.</p>

<p>When you don't initialize this pointer, its value is <strong>undefined</strong>.  That's why your tests were failing.  The compiler assumed that you didn't care what value it had.</p>
",3
8792960,8792927,0,"<p>You must initialize the pointer yourself, it doesn't have a guaranteed starting value otherwise.</p>

<pre><code>char *filename = NULL;
</code></pre>
",0
8793022,8792927,0,"<p>Whenever you declare (or define) a variable, initialize them to <code>0</code> or <code>NULL</code> (if pointers) and then check it against them!</p>

<p>For example, </p>

<pre><code>int i = 0;

.. 
if (!i) {

}
</code></pre>

<p>For pointers, </p>

<pre><code>int *p = NULL;

..
if (!p) {

}
</code></pre>
",0
8759092,8759008,4,"<p>I don't know how you manage to get 2, and why do you expect to see 4. There are 5 (five) elements in your array, thus getting array length and dividing it by the size of a single element yields five:</p>

<pre><code>$ cat test.c
#include &lt;stdio.h&gt;

int main ()
{
    int str_numbers[5] = {1,4,8,2,9};
    int total = sizeof(str_numbers)/sizeof(str_numbers[0]);
    printf (""%d\n"", total);
    return 0;
}

$ gcc -o test ./test.c 
$ ./test 
5
$ 
</code></pre>

<p>If you don't get the same result, you have an error in the code you are not showing. For example, you are printing it wrong. There are millions of ways to screw things up. Could be anything.</p>
",0
8759094,8759008,17,"<p>Wild guess: you aren't showing your code but you are in fact doing this for the parameter of a function in a 64 bit implementation with 32 bits int. sizeof(array) is the size of the array, sizeof(pointer) is the size of the pointer, not the size of the array to which the pointer may point. </p>

<pre><code>#include &lt;stdio.h&gt;

void f(int* str_numbers)
{
    int total = sizeof(str_numbers)/sizeof(str_numbers[0]);
    printf(""In f: %d\n"", total);
}

int main ()
{
    int str_numbers[5] = {1,4,8,2,9};
    int total = sizeof(str_numbers)/sizeof(str_numbers[0]);
    printf (""In main: %d\n"", total);
    f(str_numbers);
    return 0;
}
</code></pre>

<p>gives</p>

<pre><code>In main: 5
In f: 2
</code></pre>

<p>and it is what I expect on such implementation.</p>

<p>Edit: Using a syntax like <code>print_array(int arr[])</code> doesn't change the fact that arr is a pointer.  There could be a way in C99 to say it is an array, but I don't remember it and VLA have been made optional in C11, to put the standard in agreement with the practice.</p>
",3
9200312,9200257,3,"<blockquote>
  <p>I can't figure out how to determine the ""size"" of an arbitrary ""r1"".</p>
</blockquote>

<p>You cannot do that: the information about the size that you passed to <code>malloc</code> is irreversibly lost after the call. All you have at that point is a pointer to the chunk of at least 24 bytes of memory. If you need the size, you need to store it somewhere else - for example, in a separate variable that you carry around.</p>

<p>Two typical work-arounds to this issue include (1) storing a zero-terminated string in the allocated space, and using the length of that string as the proxy to the size of the allocated chunk, and (2) defining your own structure that contains both the size and the allocated pointer. Neither solution is ideal, but at least the choice is with you.</p>
",0
9200315,9200257,1,"<p>The type of <code>r1</code> is a char* (char pointer), so, like all pointers, its size is 4 (or 8, depending on your situation). No matter the size of the memory block you're allocating to it.</p>

<p>You can't retrieve the size of the allocated block from a pointer, so if you need the size later, you will have to remember the size yoursef (e.g. by storing it in a different variable).</p>
",0
9200321,9200257,1,"<p><code>r1</code> is a variable of <em>pointer</em> type, and its size is fixed and always the same (just like the size of <em>any</em> variable of a given type), which is no larger than (and usually equal to) <code>sizeof(void *)</code>. What you really want to know is the size of the array that's sitting at <code>*r1</code> (note the asterisk), and that is something <em>you cannot know</em>. You have to keep track of it yourself, typically like this:</p>

<pre><code>size_t const n = get_some_number();
foo * p = calloc(n, sizeof(foo));
</code></pre>

<p>Now you use the <strong>pair</strong> (<code>p</code>, <code>n</code>) to describe your dynamic array.</p>

<p>(Note that C99 and C11 have the notion of a <em>variable-length array</em>, in whose context <code>sizeof</code> does actually (sometimes) give you the actual array size, but that's a somewhat murky affair, and in any case it isn't what you asked for.)</p>
",0
9200322,9200257,1,"<p>When you allocate memory, you get back a pointer, which has a fixed size, so there's no way to get the size of the allocated memory with sizeof.</p>
",0
9200331,9200257,4,"<p>You may just pass the size as another parameter:</p>

<pre><code>void dec2bin(int dec, char * bin, size_t max_chars);
</code></pre>
",0
9200400,9200257,1,"<p>As others have said, if it's just a pointer, you won't be able to tell anything (unless it's zero-terminated, in which case you can just iterate until you hit an element equal to zero (not the character '0')).</p>

<p>However, if you set it up as follows, you can actually see the buffer size after calling <code>sizeof()</code>...  at least until you send it to a function, where the array decays to a plain <code>char*</code> pointer.</p>

<pre><code>void test( char* s )
{
   int i2 = sizeof( s ) / sizeof( char );
}

char c1[] = ""Testing!"";
int i1 = sizeof( c1 ) / sizeof( char ); // i1 is 9 (size of buffer)
test( c1 );                             // i2 is 4 (size of pointer)
</code></pre>
",0
19568727,19568534,1,"<p>The only easy way to do this is to use <code>snprintf</code> to print to a buffer that's long enough to hold the entire, exact value, then truncate it as a string. Something like:</p>

<pre><code>char buf[2*(DBL_MANT_DIG + DBL_MAX_EXP)];
snprintf(buf, sizeof buf, ""%.*f"", (int)sizeof buf, x);
char *p = strchr(buf, '.'); // beware locale-specific radix char, though!
p[2+1] = 0;
puts(buf);
</code></pre>
",4
19568957,19568534,3,"<p>i'd suggest shorter and faster approach:</p>

<pre><code>printf(""%.2f"", ((signed long)(fVal * 100) * 0.01f));
</code></pre>

<p>this way you won't overflow int, plus multiplication by 100 shouldn't influence the significand/mantissa itself, because the only thing that really is changing is exponent.</p>
",1
8800164,8800035,2,"<p>There is nothing called an <code>entry point</code> for a function. If you want to understand the flow of execution when a function is called, then you can put some <code>printf()</code> statements like as follows:</p>

<pre><code>#include &lt;stdio.h&gt;

void foo(void)
{
    printf(""Entering %s:%s:%d\n"", __FILE__, __func__, __LINE__);
    return;
}

int main(void)
{  
    printf(""Entering %s:%s:%d\n"", __FILE__, __func__, __LINE__);
    foo();
    return 0;
}
</code></pre>

<p>Or you can use <a href=""http://www.gnu.org/software/gdb/"" rel=""nofollow""><code>gdb</code></a> and set <code>breakpoints</code> in the beginning of each function to see the flow of execution! </p>
",0
8800467,8800035,0,"<p>Using <code>gdb</code> and <code>breakpoints</code> as suggested by Sangeeth Saravanaraj is actually the best method, but if you're intent on a runtime solution and would like an alternative to continually copy and pasting the same <code>printf</code> statement in every function you would like to track, you can use a <em>(possibly dangerous)</em> macro.</p>

<pre><code>#include &lt;stdio.h&gt;

#define trace_func(_func) printf(""Entering %s:%s:%d\n"", __FILE__, __func__, __LINE__); _func

void fooAgain(int myValue)
{
    printf(""This is fooAgain, with my value: %d.\n"", myValue);
}

void foo(void)
{
    printf(""Hello, I'm foo.\n"");
    trace_func(fooAgain(15));
}

int main(int argc, char** argv)
{
    trace_func(foo());
    return 0;
}
</code></pre>

<p>Returns:</p>

<pre><code>Entering *yourfilepath*/main.c:main:18
Hello, I'm foo.
Entering *yourfilepath*/main.c:foo:13
This is fooAgain, with my value: 15
</code></pre>

<p>If you want to be a terrible person and be able to leave the code in even when you build for release, you can do this (but don't, it is a horrible practice and wrong. I include it for the sake of completion).</p>

<p>Change the define statements to:</p>

<pre><code>#define TRACE_FUNCTIONS

#ifdef TRACE_FUNCTIONS
    #define trace_func(_func) printf(""Entering %s:%s:%d\n"", __FILE__, __func__, __LINE__); _func
#else
    #define trace_func(_func) _func
#endif
</code></pre>
",1
19215109,19215086,9,"<p>Change</p>

<pre><code>  struct lnode *myNode = malloc(sizeof(struct  lnode*));
</code></pre>

<p>to</p>

<pre><code>  struct lnode *myNode = malloc(sizeof(struct  lnode));
</code></pre>

<p>and</p>

<pre><code>  myNode-&gt;word = (char*)malloc((strlen(word))*sizeof(char));
</code></pre>

<p>to</p>

<pre><code>  myNode-&gt;word = (char*)malloc((strlen(word)+1)*sizeof(char));
</code></pre>

<p>Thank you for going through the effort to make the smallest test case you could.</p>
",11
10781139,10781090,0,"<p>You can think about <code>*</code> in C like this:</p>

<ul>
<li>with types (e.g., <code>int</code>) it means <strong>pointer</strong></li>
<li>with values (e.g., <code>x</code>) it means <strong>dereferencing</strong></li>
</ul>

<p>So:</p>

<ul>
<li><code>(int*)x</code> is a pointer to <code>int</code></li>
<li><code>*y</code> is a value from the memory addres pointed to by <code>y</code></li>
</ul>
",0
10781151,10781090,0,"<p>Same answer as others with a different explanation.
Try to interpret this -
int* ptr = (int*)x;
int y = *ptr;</p>
",0
10781111,10781090,0,"<p>You cast <code>x</code> to an integer pointer first and then you dereference it.</p>
",0
10781121,10781090,3,"<p>You can get there if you split it up, first:</p>

<pre><code>(int*)x
</code></pre>

<p>This casts <code>x</code> to an <code>int*</code>, pointer to an <code>int</code>. I assume in this case, <code>x</code> is an <code>int</code>, so the number in <code>x</code> gets interpreted as a pointer.</p>

<p>In the next step:</p>

<pre><code>*(int*)x
</code></pre>

<p><code>*</code> dereferences a pointer, in this case the just casted <code>int</code>. The result is an <code>int</code>.</p>

<p>In short: Interpret an <code>int</code> as a pointer and get the value it points to.</p>
",2
16433745,16433703,2,"<p>You don't use arrays, but pointers and allocate on the heap, and then reallocate when needed:</p>

<pre><code>/* Allocate space for ten strings */
char **temp = malloc(10 * sizeof(char *));

temp[0] = ""Hello 1"";
/* ... */
temp[9] = ""Hello 10"";

/* Reallocate so there's now space for 20 strings */
temp = realloc(temp, 20 * sizeof(char *));

/* And initialize the new entries */
temp[10] = ""Hello 11"";
</code></pre>

<hr>

<p>As for initialization, it depends on what the contents of the strings are. Either you make it point to an already existing string (either string literals like in my example above, or other strings), or you allocate space for the strings on the heap as well.</p>

<p>Maybe something like this:</p>

<pre><code>for (int i = 0; i &lt; 10; i++)
{
    char temp_string[10];

    /* Create strings in the form ""Hello 1"" to ""Hello 10"" */
    sprintf(temp_string, ""Hello %d"", i + 1);

    /* Duplicate the temporary string */
    temp[i] = strdup(temp_string);
}
</code></pre>

<p><strong>Note:</strong> If you use e.g. <code>strdup</code> or <code>malloc</code>/<code>calloc</code> to allocate the actual strings, you of course have to <code>free</code> them as well.</p>

<hr>

<p>After your updated question, I see a couple of problems with your code:</p>

<ul>
<li>The first is that when do the check <code>__index&gt;10</code> then you're already two indexes out of bounds for the array. The check should be <code>__index==9</code>.</li>
<li>Doing the change above will also solve your other problem, that you will continuously reallocate once the index goes to 11 or higher.</li>
<li>Since you use <code>new</code> for the actual strings in the array, you have to use <code>delete</code> when freeing the actual strings.</li>
<li><p>Since you use <code>new</code>, you are using C++, for which there are <strong>much</strong> better facilities to handle things like this:</p>

<pre><code>// Declare and open file
wifstream ifs(LogFileCharName);

std::vector&lt;std::string&gt; list;

std::wstring CurrentString;

while (std::getline(ifs, CurrentString))
{
    // Get the needed length of the destination string
    size_t length = wcstombs(nullptr, CurrentString.c_str(), 0);
    char* tmp = new char[length + 1];

    // Do the actual conversion
    wcstombs(tmp, CurrentString.c_str(), length + 1);

    // Add to list
    list.emplace_back(tmp);

    delete [] tmp;
}
</code></pre></li>
</ul>
",4
8749105,8749039,0,"<p>The problem is that even though <code>d</code> is a float, <code>count</code> and <code>count1</code> are <code>int</code>. You're therefore doing integer math when you say</p>

<pre><code>d=(count1/count*100);
</code></pre>

<p>Do this instead:</p>

<pre><code>d=((float)count1/count*100);
</code></pre>

<p>Casting <code>count1</code> to <code>float</code> <a href=""http://c-faq.com/~scs/cclass/int/sx4bb.html"" rel=""nofollow"">converts the division to floating point</a>.</p>
",0
8749136,8749039,2,"<p>The lines</p>

<pre><code>count = count++;
</code></pre>

<p>and</p>

<pre><code>count1 = count1++;
</code></pre>

<p>are undefined behaviour, so all bets are off. Even if it weren't undefined behaviour, it would not do what you want because <code>x++</code> returns the value of <code>x</code> before the increment.</p>

<p>Let that be simply <code>++count;</code> and <code>++count1;</code>.</p>
",1
12268358,12268327,3,"<p>You need to compile with <a href=""http://en.wikipedia.org/wiki/Large_file_support"" rel=""nofollow"">large file support</a>.  Alternatively, on some platforms you can use <a href=""http://www.gnu.org/software/libc/manual/html_node/Opening-Streams.html#index-fopen64-933"" rel=""nofollow""><code>fopen64</code></a>.</p>
",0
15817488,15817380,2,"<p><code>LONG_BIT</code> is not a thing in <strong>standard</strong> C.</p>

<p>For a portable approach, just do this:</p>

<pre><code>CHAR_BIT * sizeof(long)
</code></pre>
",7
15817539,15817380,0,"<p><a href=""http://www.cplusplus.com/reference/climits/"" rel=""nofollow"">http://www.cplusplus.com/reference/climits/</a></p>

<p>There is nothing as such <code>LONG_BIT</code> in <code>limits.h</code></p>
",2
15817719,15817380,2,"<p>Your issue is that you shouldn't be defining <code>__USE_XOPEN</code>.  If you take a look at <a href=""https://sourceware.org/git/?p=glibc.git;f=include/features.h;hb=glibc-2.30#l42"" rel=""nofollow noreferrer""><code>/usr/include/features.h</code></a> you will see it explicitly undefines it and then redefines these macros based on feature test macros.  You probably want to define <code>_XOPEN_SOURCE</code> instead, something like:</p>

<pre><code>gcc -D_XOPEN_SOURCE=700 -o longbit longbit.c
</code></pre>

<p>From <code>features.h</code>:</p>

<blockquote>
  <p>_XOPEN_SOURCE        Includes POSIX and XPG things.  Set to 500 if
                          Single Unix conformance is wanted, to 600 for the
                          sixth revision, to 700 for the seventh revision.<br>
  _XOPEN_SOURCE_EXTENDED XPG things and X/Open Unix
  extensions.</p>
</blockquote>

<p>Also, wrt directly including <code>xopen_lim.h</code>:</p>

<pre><code>/*
 * Never include this file directly; use &lt;limits.h&gt; instead.
 */
</code></pre>

<p>So, I wouldn't recommend directly including it. Also, see <a href=""http://man7.org/linux/man-pages/man7/feature_test_macros.7.html"" rel=""nofollow noreferrer""><code>man feature_test_macros</code></a> or <a href=""http://www.gnu.org/software/libc/manual/html_node/Feature-Test-Macros.html"" rel=""nofollow noreferrer""><code>info '(libc)Feature Test Macros'</code></a>.</p>
",0
15506889,15506773,5,"<p>You've got a very serious error:</p>

<pre><code>  char* result;
  ...
  sprintf(result, ""%d %d %d %d"", numLine, numWords, numChars, numBytes);
</code></pre>

<p>This is not allowed in C. You need to allocate sufficient memory for the string first. Declare <code>result</code> as a large enough static array, or use <code>malloc</code> if you've covered that in your course.</p>

<p>e.g.</p>

<pre><code>char buf[100];  // temporary buffer

sprintf(buf, ""%d %d %d %d"", numLine, numWords, numChars, numBytes);

char *result = malloc(strlen(buf) + 1);   // just enough for the string
strcpy(result, buf);                      // store the string

return result;
</code></pre>
",7
15506921,15506773,1,"<p>You also appear to be missing the <code>\t</code> for tab in your white space checker, and you're not correctly checking when you're in or out of a word. You can use the boolean type <code>bool</code> for this defined in <em>stdbool.h</em> for this.</p>
",0
15506977,15506773,1,"<p>Source code of wc unix command:</p>

<p><a href=""http://www.gnu.org/software/cflow/manual/html_node/Source-of-wc-command.html"" rel=""nofollow"">http://www.gnu.org/software/cflow/manual/html_node/Source-of-wc-command.html</a></p>

<p>All test cases handled.</p>
",0
15506819,15506773,1,"<p>1)  <strong>sizeof is wrong:</strong>  </p>

<p>Instead of <code>sizeof</code> operator you need to use <code>strlen()</code> in for loop, like: </p>

<pre><code>for (i = 0; i &lt; strlen(data); i++)
                ^ not sizeof
</code></pre>

<p><code>sizeof(data)</code> returns only size of data pointer address that is <code>4</code>. Because you are to read all char in <code>data[]</code> you need <code>strlen()</code> that will return length of <code>data[]</code> (or number of chars in <code>data[]</code>)  </p>

<p>2) <strong>memory error:</strong>   </p>

<p>Next Error I can notice there is no memory allocated for <code>result</code>. it declare like: </p>

<pre><code>char* result ;
</code></pre>

<p>and No memory allocate! and you are writing using <code>sprintf</code> that cause <strong>undefined behavior</strong> of your code</p>

<p>3) <strong>while(strstr(data,empty)>0)</strong> is wrong  </p>

<p><code>strstr()</code> search position of a string in to other you empty string is <code>NULL</code> , CHECK: 
<a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/strstr.html"" rel=""nofollow"">char *strstr(const char *s1, const char *s2);</a>   </p>

<p>you strstr() always returns <code>data</code>, Why are you calling this? I believe <em>you don't need</em> this <code>while()</code> loop.</p>

<p>I improved you code upto some extend as below, There was only three error as I mentioned above now corrected(<em>to understand read comments</em>), You basic algo is correct:  </p>

<pre><code>#define SIZE 256   // added size macro
char* wc(char* data)  
  char* result = malloc(SIZE*sizeof(char)); //(2) allocated memory for result 
  int numLine ;
  int numWords ;
  int numChars ;
  int i;
  int numBytes =strlen(data);
    numWords=1; 
                    // (3) remove while loop
    for (i = 0; i &lt; strlen(data); i++) {  //(1) change size
        if(data[i]=='\n'){
         numLine++;
     }
        if(data[i]==' ' ){
         numWords++;
     }
        if(data[i]!=' '){
         numChars++;
     }
    }
    sprintf(result, ""%d %d %d %d"", numLine, numWords, numChars, numBytes);
    return result;
 }

int main(){
    printf(""\nresult: %s\n"", wc(""q toei lxlckmc    \t \n ldklkjjls \n i \t nn ""));
    return 1;
}
</code></pre>

<p>Output: </p>

<pre><code>result: 2 14 28 41
</code></pre>
",4
15506821,15506773,2,"<p>What if you have this input?</p>

<pre><code>Two        Words.
</code></pre>

<p>You have to count the transitions between whitespace/non-whitespace, not just count spaces.</p>

<hr>

<p>Also, I'm pretty sure <code>strstr(data,NULL)</code> will not do anything useful. </p>
",2
11515570,11515462,4,"<p><code>#define something (54)</code> tells the C pre-processor to replace any text matching ""something"" with ""(54)"" before the code is actually compiled.</p>

<p>The reason you will often see the use of <code>( )</code> around a <code>#define</code> is that in some cases it prevents the replaced text from having adverse or undefined behavior when the <code>#defined</code> text is replaced into a larger expression. Such adverse effect might be the changing of operator precedence etc..</p>
",2
11515578,11515462,0,"<p>Probably it was written this way to make future changes easy; consider changing <code>54</code> to <code>1024*54</code> or <code>1024+54</code> -- with the parens, the change can be made directly without much further thought. If the change is made without the parens, then the precedence of operator evaluation matters <em>everywhere that <code>something</code> is used in the program</em>.</p>
",0
11515639,11515462,4,"<p>It is in general a good idea to put any #define statement inside parenthesis.  This is a good habit, and most daily programmers adhere to good habits.</p>

<p>For instance:</p>

<pre><code>#define TWO_PLUS_ONE    2 + 1
</code></pre>

<p>if I use it like this:</p>

<pre><code>3 * TWO_PLUS_ONE
</code></pre>

<p>I would expect to see the answer as 9, however due to operator precedence, the calculated answer would be 7.  There are dozens of corner cases you could find like this (see <a href=""http://www.gimpel.com/html/bugs.htm"" rel=""nofollow"">http://www.gimpel.com/html/bugs.htm</a>).  This is why C++ programmers scream, ""Macros are evil!"".  But we are C programmers, we are elite, we ain't scared.</p>

<p>The same example:</p>

<pre><code>#define TWO_PLUS_ONE    (2 + 1)
</code></pre>

<p>This will give the expected result in all situations.</p>

<p>Most programmers want their practices to apply in all situations, so it is easy to remember, easy to practice and easy to do.  So in the simple case of</p>

<pre><code>#define SOMETHING    (54)
</code></pre>

<p>Just do it.  It is a good idea.  Learn to be part of the team, they are trying to help you.  BTW, next they will say, ""it should really be (54u)""</p>
",0
11515486,11515462,0,"<p>""()"" are parenthesis and not [brackets].  It is essentially a no-op.  Any time where 54 would be valid, (54) would be valid, just like (50+4) would be valid, or (27*2) or any other expression. </p>

<p>Perhaps you can give us more information about this ""quality standards"" error you are seeing?  Perhaps someone doesn't like the parens since they are unnecessary.</p>
",1
11515491,11515462,1,"<p>The parentheses are superfluous.  I cannot imagine a scenario in which <code>(54)</code> would differ semantically from <code>54</code>.  Now, if I'm wrong... show me; I'll have learned something new.</p>
",8
11515494,11515462,1,"<p>Parenthesis in that case are ignored. It's the same as writing:</p>

<pre><code>#define something 54
</code></pre>

<p>They just help you like in math such as:</p>

<pre><code>#define something (54-2)/2
</code></pre>

<p>Is different from</p>

<pre><code>#define someotherthing 54-2/2
</code></pre>
",5
10163544,10160550,2,"<blockquote>
  <p>the program calculates the average geometric mean of negative elements in a 2x2 matrix</p>
</blockquote>

<p>It doesn't. First, usually the <a href=""http://en.wikipedia.org/wiki/Geometric_mean"" rel=""nofollow"">geometric mean applies only to positive numbers.</a> One can extend the definition in a somewhat meaningful way to negative numbers by saying the geometric mean of <code>k</code> negative numbers is the negative of the geometric mean of the absolute values, but what the geometric mean of a set containing both negative and positive numbers should be is unclear. Another meaningful way of extending the geometric mean would be an extension as a holomorphic function to its domain of holomorphy (which for <code>k &gt; 1</code> wouldn't be a subset of ?<sup>k</sup>). That would include the former extension as the value on one branch above ?<sub>&lt; 0</sub><sup>k</sup>.</p>

<p>Anyway a calculation of a geometric mean would include a <code>k</code>-th root in some form, which the given programme doesn't. Now let's look at the code.</p>

<pre><code>float geometricMean(float * arr, int rows, int cols){
    float neg_mul = 1;
    int neg_count = 0;
</code></pre>

<p>Initialisation of the product of negative array elements and their count.</p>

<pre><code>    float arr_elem;
    for (int i = 0; i &lt; rows; i++)
        for (int j = 0; j &lt; cols; j++)
</code></pre>

<p>The memory layout of the matrix is</p>

<pre><code>        --------------------------------------------
arr -&gt; | row 0 | row 1 | row 2 | ... | row (rows-1) |
        --------------------------------------------
</code></pre>

<p>So <code>row 0</code> occupies slots 0 to <code>cols - 1</code>, <code>row 1</code> occupies the slots <code>cols</code> to <code>2*cols - 1</code>, generally, <code>row k</code> occupies the slots <code>k*cols</code> to <code>(k+1)*cols - 1</code>. Thus <code>arr + i*cols + j</code> points to <code>col j</code> in <code>row i</code>.</p>

<pre><code>            if((arr_elem = *(arr + i * cols + j)) &lt; 0){
                neg_mul *= arr_elem;
                neg_count++;
            }
</code></pre>

<p>Read matrix element <code>a[i][j]</code> and if it is negative, multiply it to the product of all negative entries and count it. Note that due to the flat memory layout, one could simply loop <code>for(k = 0; k &lt; rows*cols; ++k)</code> and access <code>arr[k]</code> here.</p>

<pre><code>    if (neg_count == 0){
        last_geom_err = ""no negative elements in array"";
        return 0;
    }
</code></pre>

<p>If the array contains no negative elements at all, set the error message and return. A (geometric) mean of no numbers isn't meaningful at all.</p>

<pre><code>    if ((neg_count % 2 == 0) &amp;&amp; (neg_mul &lt; 0)){
        last_geom_err = ""a negative number under the square root of even degree"";
        return 0;
    }
</code></pre>

<p>If the number of negative entries is even and the product of negative entries is negative, set the error message and return.</p>

<p>Note that this is dead code. The product of an even number of negative numbers is always positive and the only caveat in floating point arithmetic (IEEE 754 conforming or sufficiently close to that; if it's totally broken, anything could happen) is underflow, the product may become 0 although mathematically it isn't. (Overflow isn't an issue here, the infinities compare to 0 and behave in multiplications as they should.)</p>

<pre><code>    last_geom_err = NULL;
    return pow(neg_mul, (float)neg_count);
}
</code></pre>

<p>Finally, set the error message to <code>NULL</code>, since no exceptional situation occurred and return</p>

<blockquote>
  <p>(product of negative entries)<sup>(number of negative entries)</sup>.</p>
</blockquote>

<p>For the geometric mean, the last line should resemble</p>

<pre><code>    return pow(neg_mul, 1.0/neg_count);
</code></pre>

<p>however, that would return a NaN if <code>neg_mul &lt; 0</code> since <code>pow</code> handles negative bases only for integer exponents, so</p>

<pre><code>if (neg_mul &lt; 0) {
    return -pow(-neg_mul, 1.0/neg_count);
} else {
    return pow(neg_mul, 1.0/neg_count);
}
</code></pre>
",0
20418107,20418007,1,"<p><a href=""http://www.cplusplus.com/reference/cstring/strcat/"" rel=""nofollow""><code>strcat()</code></a> expects second argument to be <code>const char *</code> (C string), while you're giving it a <code>char</code>.</p>

<p>You could convert your <code>char</code> into C string, i.e. create an array </p>

<pre><code>char append[] = { buffer[j], '\0' }` 
</code></pre>

<p>or append a single character each time and at the very end append null-byte:</p>

<pre><code>        bzero(message, BUFFSIZE);  // 1024 bytes
        strcpy(message, ""your_file|"");
        size_t len = strlen(message);

        for (j=0; j&lt;bytes_read; ++j) {
            fprintf(stdout, ""%c"", buffer[j]);
            message[len++] = buffer[j];
        }

        message[len] = '\0';

        fprintf(stdout, ""%s\n"", message);
</code></pre>
",0
8777678,8777652,8,"<p>You are trying to calculate the size of an array from a pointer to a dynamic array.</p>

<pre><code>sizeof a / sizeof a[0]
</code></pre>

<p>In C you simply cannot find out the length of an array if you only have a pointer to the array. The code you are using is appropriate if you have an <em>array</em>, but you don't have an array, you have a <em>pointer</em>.</p>

<p>So, if you had declared <code>a</code> like this</p>

<pre><code>int a[3];
</code></pre>

<p>or this</p>

<pre><code>int a[] = {0, 1, 2};
</code></pre>

<p>then <code>a</code> would be an <em>array</em> rather than a <em>pointer</em> and the <code>sizeof</code> code above would be applicable.</p>

<p>Fortunately you know how big the dynamic array is because you just created it. It has <code>n</code> elements. So you must write your call to <code>funcdosomthing</code> like this:</p>

<pre><code>funcdosomthing(a, n);
</code></pre>
",0
8777732,8777652,0,"<p>Why do you try to find the size when you already know the size?!</p>

<p>You should use <code>n</code> instead of calculating the size like <code>sizeof a / sizeof a[0]</code>. And more over, <code>sizeof(a)</code> will give your expected result iff <code>a</code> is an array. In this case, it is a <code>pointer-to-memory-which-can-store-n-integers</code>. </p>
",0
17082190,17082149,6,"<p>This is because you haven't <em>seeded</em> the random-number generator.</p>

<p>A common simple way to do this is to call:</p>

<pre><code>srand(time(NULL));
</code></pre>

<p><em>before</em> the first call to <code>rand()</code>.</p>

<p>This uses the <a href=""http://linux.die.net/man/3/srand""><code>srand()</code></a> (for ""seed random"", I guess) function, passing it a number (the current time) that is likely to be different every time you run the program.</p>

<p>Read the <a href=""https://en.wikipedia.org/wiki/Pseudorandom_number_generator"">wikipedia article on pseudorandom number generators</a> for more information on what goes under the hood. Randomness is hard.</p>
",1
17082203,17082149,3,"<p>This is because rand() starts generating pseudo random numbers using the same <a href=""https://en.wikipedia.org/wiki/Random_seed"" rel=""nofollow"">seed</a> every time you invoke the program.</p>

<p>call srand() once at the start of main() to initialize the seed to different values, e.g.</p>

<pre><code>srand(time(NULL));
</code></pre>

<p>(As time() have a resolution of seconds, you'll get the same random numbers if you invoke the program several times within the same second) Another alternative could be</p>

<pre><code>srand((int)getpid());
</code></pre>
",0
11510418,11510368,3,"<p><a href=""http://en.cppreference.com/w/c/string/byte/strtok"" rel=""nofollow""><code>strtok()</code></a> is probably the function you are looking for.</p>

<pre><code>char list[] = ""one,two,three,four"";
int ENTServerAmount = 8;
char **ENTServer;

char *tmp = strtok (str, "","");

int index = 0;
while (pch != NULL)
{
   ENTSever[index++] = tmp;
   tmp = strtok (NULL, "","");
}
</code></pre>
",2
20021268,20020927,1,"<p>""Control passes to the statement whose <code>case</code> constant-expression matches the value of <code>switch</code> ( expression ). [...] <strong>Execution</strong> of the statement body <strong>begins at the selected statement</strong> and proceeds until the end of the body or until a <code>break</code> statement transfers control out of the body."" (<a href=""http://msdn.microsoft.com/"" rel=""nofollow"">http://msdn.microsoft.com/</a>)</p>

<p>I don't think the first <code>switch</code> does anything... When I compiled it, <code>y</code> was 4, which means it only incremented it once.</p>
",1
20021184,20020927,1,"<p>The first switch block in the code doesn't do anything.</p>

<p>When switch statement expression is evaluated, the source code present until the occurrence of matching case label or default label, will be ignored. Hence it doesn't print statement ""Before case"" in the below program.</p>

<pre><code>int x = 2;
int y = 3;

    int main()
    {
        switch (x)
        {
            y++; 
             printf(""Before case"");
         case 2:
            printf(""In case 2"");
            break;
         }

       return 0;
    }
</code></pre>

<p>Output:</p>

<pre><code>In case 2
</code></pre>
",1
8724311,8724219,1,"<p>You're using &amp; in your printf statements, you shouldn't be. Scanf has it as it's writing so takes pointers.</p>
",1
8724315,8724219,1,"<p>Why are you using the operator <code>&amp;</code> to your <code>printf</code> arguments?</p>

<p><code>printf</code> doesn't take pointer arguments for <code>%f</code> conversion specification</p>

<pre><code>float b;
scanf(""%f"", &amp;b);
</code></pre>

<p>but</p>

<pre><code>float a = 42;
printf(""%f\n"", a);
</code></pre>
",0
8724384,8724219,1,"<pre><code>printf(""Media of the 2 numbers is %f"", &amp;media);
</code></pre>

<p>should be </p>

<pre><code>printf(""Media of the 2 numbers is %f"", media);
</code></pre>

<p>similarly for all other <code>printf()</code></p>

<p>Generally <code>goto</code> statements are considered harmful when they are called backwards! So please avoid them. The same functionality can be done by a <code>while(1)</code> for <code>for(;;)</code> loop with proper termination condition.</p>
",0
8726699,8724219,0,"<p>In your printf statement, you are using</p>

<pre><code>    printf(""Media of the 2 numbers is %f"", &amp;media);
</code></pre>

<p>&amp;media is the address of your variable media.
In scanf, we provide the address of the variable as parameter so that it stores the values at that address. But in printf, we provide the variable value and not the variable address. If you provide variable address then it would print the address and not the value.
So the correction should be</p>

<pre><code>   printf(""Media of the 2 numbers is %f"", media);
</code></pre>
",0
11098070,11097033,5,"<p>This code exploits the structure of the IEEE 754 format for floating point numbers. The structure itself was specifically designed for such operations in order to make comparison operations fast.</p>

<p>Each single-precision IEEE 754 number has three parts (in order from MSB to LSB):</p>

<ul>
<li>sign bit</li>
<li>exponent part (8 bits)</li>
<li>significand of the mantissa (23 bits)</li>
</ul>

<p><code>f1</code> is greater than <code>f2</code> if:</p>

<ul>
<li><code>f1</code> is positive and <code>f2</code> is negative</li>
<li><code>f1</code> and <code>f2</code> are both positive but <code>f1</code> has greater exponent than <code>f2</code></li>
<li><code>f1</code> and <code>f2</code> are both positive and have the same exponents but <code>f1</code> has larger significand than <code>f2</code></li>
<li>the opposite of the previous two if <code>f1</code> and <code>f2</code> are negative</li>
</ul>

<p>One could just compare both floating point numbers as integers if they were in <a href=""http://en.wikipedia.org/wiki/Two%27s_complement"" rel=""nofollow"">two's complement</a> representation. Unfortunately IEEE 754 doesn't use two's complement to represent negative numbers and that's why this code performs the conversion in order to be able to just compare the numbers as signed integers.</p>

<p>Here is a step by step commentary on what each line of code does:</p>

<pre><code>i1 = *(int*)f1; // reading float as integer
i2 = *(int*)f2; // reading float as integer
</code></pre>

<p>This one uses the fact that on most 32-bit systems <code>sizeof(int) == sizeof(float)</code> to read the floating point numbers into regular <em>signed</em> integer variables.</p>

<pre><code>t1 = i1 &gt;&gt; 31;
</code></pre>

<p>This one extracts the sign bit of <code>f1</code>. If <code>f1</code> is negative its MSB would be <code>1</code> and hence <code>i1</code> would be negative. Shifting it 31 bits to the right preserves the sign and hence if <code>i1</code> was negative <code>t1</code> would have all bits set to <code>1</code> (equal to -1). If <code>f1</code> was positive its sign bit would be <code>0</code> and in the end <code>t1</code> would equal <code>0</code>.</p>

<pre><code>i1 = (i1 ^ t1) + (t1 &amp; 0x80000001);
</code></pre>

<p>If the sign bit was <code>1</code> this line would perform conversion to two's complement representation if <code>f1</code> was negative.</p>

<p>Here is how it works: if <code>f1</code> was positive, then <code>t1</code> is <code>0</code> and <code>(i1 ^ t1)</code> would just be <code>i1</code> and <code>(t1 &amp; 0x80000001)</code> would be <code>0</code> and in the end <code>i1</code> would just retain its original value. If <code>f1</code> was negative then <code>t1</code> would have all bits set to <code>1</code> and the first expression on the RHS would be the bit inversion of <code>i1</code> and the second expression would equal <code>0x80000001</code>. This way <code>i1</code> would be converted to its bit inversion and <code>1</code> would be added. But this would lead to a positive number since the MSB would be cleared and that's why <code>0x80000000</code> is also added to keep the number negative.</p>

<pre><code>t2 = i2 &gt;&gt; 31;
i2 = (i2 ^ t2) + (t2 &amp; 0x80000001);
</code></pre>

<p>Perform the same as above for <code>f2</code>.</p>

<pre><code>return i1 &gt; i2;
</code></pre>

<p>Just compare the two resulting <em>signed</em> integers. Most CPUs have dedicated instructions to perform signed comparison in hardware.</p>
",0
11176925,11176905,2,"<p><s>I'm sure</s> It's possible that the <code>__LINE__</code> macro will come in handy.  There will be no scoping, but at least you'll be able to generate unique label names this way.</p>

<p>However, it's not immediately obvious that this will solve your problem either.  I'm going to be bold and state that it's not solvable, although <s>I'm sure</s> it's possible someone will come along and prove me wrong!</p>
",2
11179257,11176905,1,"<p>Your idea looks nice, the only thing I would miss is that your <code>break(c)</code> could be issued anywhere in the function. I'd add something like that to the two macros:</p>

<pre><code>#define CONTEXT(ID)                                     \
    if (0) { CTX_ID(ID): ; }                            \
    else for (register bool CTX_ID(ID ## ID) = true;    \
              CTX_ID(ID ## ID);                         \
              CTX_ID(ID ## ID) = false)

#define BREAK(ID)                \
    do {                         \
       CTX_ID(ID ## ID) = false; \
       goto CTX_ID(ID);          \
   } while (0)
</code></pre>

<p>This would lead to a syntax error if <code>BREAK(c)</code> would be used outside the depending block. To my experience such <code>for</code> variables as used here are easily optimized away by modern compilers.</p>
",2
12865817,12865775,1,"<p>You could use an enum.</p>

<pre><code>typedef enum TrafficDirection { INPUT = 0, OUTPUT = 1 } TrafficDirection;

restrictedFunction(TrafficDirection direction);
</code></pre>

<p>of course, this isn't perfect.  You can still pass any int to it as long as you use a cast.</p>

<pre><code>restrictedFunction((TrafficDirection) 4);
</code></pre>
",2
12865820,12865775,1,"<p>You don't get quite as much protection as you might like, but you can do:</p>

<pre><code>enum func_type { INPUT, OUTPUT };
void restrictedFunction( enum func_type parameter );
</code></pre>
",1
12865826,12865775,3,"<pre><code>typedef enum { INPUT = 0, OUTPUT = 1 } IO_Type;

void restrictedFunction(IO_Type parameter) { ... }
</code></pre>

<p>It doesn't absolutely force the use of the values (the compiler will let someone write <code>restrictedFunction(4)</code>), but it is about as good as you'll get.</p>

<p>If you truly want to force the correct type, then:</p>

<pre><code>typedef enum { INPUT = 0, OUTPUT = 1 } IO_Type;
typedef struct { IO_Type io_type } IO_Param;

void restrictedFunction(IO_Param parameter) { ... }
</code></pre>

<p>In C99 or later, you could call that with:</p>

<pre><code>restrictedFunction((IO_Param){ INPUT });
</code></pre>

<p>This is a compound literal, creating a structure on the fly.  It is not entirely clear that the structure type really buys you very much, but it will force the users to think a little and may improve the diagnostics from the compiler when they use it wrong (but they can probably use <code>restrictedFunction((IO_Param){ 4 });</code> still).</p>

<p>What this means is that your <code>restrictedFunction()</code> code should be ready to validate the argument:</p>

<pre><code>void restrictedFunction(IO_Type io_type)
{
    switch (io_type)
    {
    case INPUT:
        ...do input handling...
        break;
    case OUTPUT:
        ...do output handling...
        break;
    default:
        assert(io_type != INPUT &amp;&amp; io_type != OUTPUT);
        ...or other error handling...
        break;
    }
}
</code></pre>
",3
12866417,12865775,1,"<p>You can use a wrapper to validate the argument:</p>

<pre><code>#define restrictedFunction(x) do {                          \
   static_assert((x) == INPUT || (x) == OUTPUT);            \
   assert(!strcmp(#x, ""INPUT"") || !strcmp(#x, ""OUTPUT""));   \
   restrictedFunction(x);                                   \
} while(0)
</code></pre>

<p>Notes:</p>

<ul>
<li>This assumes <code>restrictedFunction()</code> returns a <code>void.</code> If it returns a value which you actually use, you'll need something like gcc's compound statement <a href=""http://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html"" rel=""nofollow noreferrer"">http://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html</a>. Or--better--you can use <code>BUILD_BUG_ON_ZERO</code> (see <a href=""https://stackoverflow.com/q/9229601/318716"">What is &quot;:-!!&quot; in C code?</a>), which I keep forgetting about, because it doesn't seem to work with C++.</li>
<li>The <code>do ... while(0)</code> is to ""swallow the semi-colon""; not really relevant here.</li>
<li><code>static_assert()</code> is a compile-time assert; there are many variants available. Here is a link to one, <a href=""https://stackoverflow.com/a/9059896/318716"">https://stackoverflow.com/a/9059896/318716</a>, if you don't have your own handy.</li>
<li><code>assert()</code> is the standard run-time assert.</li>
<li>With gcc 4.1.2, and my version of <code>static_assert(),</code> you can replace the run-time <code>assert()</code> with a compile-time assert when the two <code>!strcmp()</code>'s are replaced with <code>==</code>; see example below.  I haven't tested this with other compilers.</li>
<li><code>x</code> is only used <strong><em>once</em></strong> in the macro expansion, since the first four references are only used at compile-time.</li>
</ul>

<p>When your actually define your function, you'll have to add parentheses to disable the macro expansion, as in:</p>

<pre><code>void (restrictedFunction)(int x){ ... }
</code></pre>

<p>Also, if your code has a special case (whose code doesn't?) where you need to call <code>restrictedFunction()</code> with the argument <code>foo,</code> you'll need to write:</p>

<pre><code>  (restrictedFunction)(foo);
</code></pre>

<p>Here is a complete example, which puts a wrapper around the standard library function <code>exit()</code>:</p>

<pre><code>#include &lt;stdlib.h&gt;

#define CONCAT_TOKENS(a, b)     a ## b
#define EXPAND_THEN_CONCAT(a,b) CONCAT_TOKENS(a, b)
#define ASSERT(e)    enum{EXPAND_THEN_CONCAT(ASSERT_line_,__LINE__) = 1/!!(e)}
#define ASSERTM(e,m) enum{EXPAND_THEN_CONCAT(m##_ASSERT_line_,__LINE__)=1/!!(e)}

#define exit(x) do {                                                \
   ASSERTM((x) ==  EXIT_SUCCESS  || (x) ==  EXIT_FAILURE,  value);  \
   ASSERTM(#x  == ""EXIT_SUCCESS"" || #x  == ""EXIT_FAILURE"", symbol); \
   exit(x);                                                         \
} while(0)

int main(void) {
   exit(EXIT_SUCCESS); // good
   exit(EXIT_FAILURE); // good
   exit(0);  // bad
   exit(3);  // doubly bad
}
</code></pre>

<p>If I try to compile it, I get:</p>

<pre><code>gcc foo.c -o foo
foo.c: In function 'main':
foo.c:17: error: enumerator value for 'symbol_ASSERT_line_17' is not an integer constant
foo.c:18: warning: division by zero
foo.c:18: error: enumerator value for 'value_ASSERT_line_18' is not an integer constant
foo.c:18: error: enumerator value for 'symbol_ASSERT_line_18' is not an integer constant
</code></pre>
",0
10136153,10136088,3,"<p>The <em>scanf()</em> leaves the end-of-line character of the first line in the input stream which is then consumed by <em>gets()</em>. This is a common beginner's error often discussed here.</p>

<p>Recommendations: </p>

<ol>
<li>Do not mix <em>scanf()</em> routines with <em>gets()</em> routines.</li>
<li>Except for short test programs do not use <em>gets()</em> (instead use <em>fgets()</em>) because with <em>gets()</em> buffer overflows may occur.</li>
</ol>
",4
10136156,10136088,1,"<p>I'm sure what you're trying to do here, or what the problem is.  But ...</p>

<ol>
<li><p>As Greg Hewgill correctly said: NEVER use ""gets()"".  It's a buffer overflow waiting to happen.</p></li>
<li><p>You CAN use ""fgets()"" - and it could easily solve the problem.</p></li>
<li><p>While you're at it, why the ""scanf()"", followed by ""gets()"", followed by ""atoll()""?  Can any of these inputs be merged?  Or made more consistent?</p></li>
<li><p>Where are you checking for a valid conversion from ""atoll()""?  Why not just use ""sscanf()"" (and check the return value)?</p></li>
</ol>
",0
10136485,10136088,2,"<p>You can try adding the '\n' character when you are reading with scanf:</p>

<pre><code> scanf(""%lld\n"",&amp;t);
  for(i=1;i&lt;=t;i++)
  {
    gets(s);
    a=atoll(&amp;s[7]);
    printf(""%lld"",a);
  }
</code></pre>
",0
10136557,10136088,2,"<p>Why not:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
    long long i;
    long long t;
    char s[10000];

    if (fgets(s, sizeof(s), stdin) == 0)
        return 0;
    t = atoll(s);
    for (i = 1; i &lt;= t; i++)
    {
        if (fgets(s, sizeof(s), stdin) == 0)
            break;
        a = atoll(&amp;s[7]);
        printf(""%lld\n"", a);
    }
    return 0;
}
</code></pre>

<p>Amongst other merits, it doesn't:</p>

<ul>
<li>print stray zeroes,</li>
<li>include C++ code in a purportedly C program,</li>
<li>contain any stray (unused) variables,</li>
<li>use the dangerous <code>gets()</code> function.</li>
</ul>

<p>It is fair to note a couple of deficiencies:</p>

<ul>
<li>It would produce bogus output if a data line was not at least 8 characters long; it should check <code>strlen(s)</code> before calling <code>atoll(&amp;s[7])</code></li>
<li>We'll assume that 10K is longer than any single line it will be given to read so truncated lines won't be a problem, though JSON data sometimes seems to get encoded in files without any newlines and can be humongously long (Firefox bookmark lists or backups, for example, don't even contain a single newline).</li>
</ul>
",0
9174194,9174147,3,"<p>The first prints the difference between 2 <code>char</code>s:</p>

<p>The second prints the difference between 2 pointers.</p>

<p><code>*arr1</code> dereferences a <code>char*</code> and returns the first character, which is <code>'f'</code>.</p>

<p><code>ptr = &amp;arr1[2];</code> will make <code>ptr</code> point to <code>""dcba""</code>. It takes the address of the third character in <code>arr1</code>. <code>*ptr</code> returns <code>'d'</code>.</p>

<p>So the first <code>printf</code> returns the difference between characters <code>f</code> and <code>d</code> - which is <code>2</code>.</p>

<p>The second one is the difference between the two pointers. It's legal since they both point inside the same character array. It's the same as <code>arr1 - &amp;arr[2]</code> which will most likely be <code>-2</code>, since arrays are stored continuously in memory.</p>
",0
9174203,9174147,1,"<pre><code>printf(""%d\n"",*arr1 - *ptr);
</code></pre>

<p>This prints the result of the first character of <code>arr1</code> minus the first character of <code>ptr</code>. 
Here is clearer version that does the same thing: <code>printf(""%d\n"",arr1[0] - ptr[0]);</code></p>

<hr>

<pre><code>printf(""%d\n"",arr1 - ptr);
</code></pre>

<p>This prints the pointer difference between <code>arr1</code> and <code>ptr</code>, which is 2. </p>

<p>Essentially the property holds that: <code>(a[x] - a)</code> is equivalent to <code>x</code></p>
",1
9174607,9174147,0,"<p>Just add these two lines to your program for better understanding...</p>

<pre><code>printf(""\n%d AND %d... %c"",arr1, *arr1, *arr1);
printf(""\n%d AND %d... %c"",ptr, *ptr, ptr[0] ); //ptr[0] == *ptr
</code></pre>

<p>Hope this helps...</p>
",0
16920033,16917760,2,"<pre><code>void createListsHelper (adjList **result, vp graph, int *index) /* index stores an index in an array to create there next list */
{
    int i;
    if (graph)
    {
        result = realloc (result, sizeof (adjList *) * (*index + 2));
</code></pre>

<p>Since <code>result</code> is passed by value (<em>every</em> parameter is passed by value in C), this modification will not affect <code>result</code> in the calling function. This line</p>

<pre><code>createListsHelper (result, graph, index);
result[*index + 1] = NULL; /* &lt;&lt;&lt; */
</code></pre>

<p>invokes UB (because <code>result</code> is still pointing to an array of 1 <code>int</code>, and you are accessing the second element).</p>
",0
8723130,8722978,2,"<p>throw one array in a hash.  Look up the other array in the hash.  But that's not nlogn.. it's m+n.</p>
",0
8723010,8722978,3,"<p>You can take the smaller array and search each element in the bigger element with binary search</p>

<pre><code>for(int i = 0; i &lt; size1; i++) {     
  binarysearch(arr_small[i], arr_big);
}
</code></pre>

<p>binary search requires O(log n) time for each search. Total search time for all elements is O(nlogn)</p>

<p>If you dont remember binary search, refer the link: <a href=""http://en.literateprograms.org/Binary_search_(C"" rel=""nofollow"">http://en.literateprograms.org/Binary_search_(C</a>)</p>
",12
8723723,8722978,4,"<p>I'm hoping this is enough of a hint...</p>

<p>Once the arrays are sorted, just walk through the arrays 'side-by-side'.  Keep track of the 'current' element for each array (<code>X</code> and <code>Y</code>). You might do this using an index variable for each array or by using a pointer.  Personally, I'd find it easier to use pointers, but you or your friend may have a different preference.</p>

<p>For each pair of 'current' elements, if the elements match then print the value. Then consider what needs to be done, if anything, to move to the next element of each array (for the cases where the elements don't match as well as for the case where they do match). There are only three cases:</p>

<ol>
<li><code>x[cur_x] == y[cur_y]</code></li>
<li><code>x[cur_x] &lt;  y[cur_y]</code></li>
<li><code>y[cur_y] &lt;  x[cur_x]</code></li>
</ol>

<p>so it shouldn't be too difficult to determine what should be done in each case.</p>

<p>Sorting the arrays in an O(n log n) operation.  Walking through the arrays is an O(n) operation, so altogether it's an O(n) + O(n log n) operation, which reduces down to O(n log n). In other words, the overall time complexity of the  operation is determined by the sort operation.</p>

<p>Using a binary search will also work, but it might be a little more complicated - especially to properly handle duplicated elements in the arrays if that's a requirement (and depending on what 'properly' might mean according to the requirements).</p>
",4
8723077,8722978,1,"<p>This approach does not need the <code>X</code> and <code>Y</code> to be sorted.</p>

<p>Add the elements of <code>X</code> to a binary search tree (avoid duplicate entries, i.e. if <code>X[0] = 1</code> and <code>X[1] = 1</code> then don't add <code>X[1]</code>; just ignore it).</p>

<p>Then try to add the contents of <code>Y</code> to the same binary search tree and If you find the element already in there, then its identical. </p>

<p>The total time complexity boils down to the time complexity of adding element to BST which is <code>O(n log n)</code> but worst case would be <code>O(n)</code> if the tree is skewed (i.e. if the arrays are sorted). </p>

<hr>

<p>Here is the code for your reference!</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;limits.h&gt;

typedef struct node {
        int data;
        struct node *left;
        struct node *right;
} NODE;

NODE *root = NULL;

NODE * newnode (int data)
{
        NODE * n = NULL;
        if (n = (NODE *) malloc (sizeof (NODE))) {
                n-&gt;data = data;
                n-&gt;right = n-&gt;left = NULL;
        } else {
                printf(""%d - %d - unalbe to create new node \n"", __LINE__, data);
        }

        return n;
}

NODE * getnode(NODE * n, int data)
{
        if (n == NULL)
                return NULL;

        if (n-&gt;data == data)
                return n;

        if (data &lt; n-&gt;data)     {
                return getnode (n-&gt;left, data);
        }

        if (data &gt; n-&gt;data) {
                return getnode (n-&gt;right, data);
        }

        return NULL;
}

NODE * insert (NODE * node, int data, int *dup)
{
    NODE * n = NULL;

    if (node != NULL) {
        if (getnode(node, data) != NULL) {
            /* element already present in the tree..
               so set the dup and return the root */
            *dup = 1;
            return node;
        }
    }

    if (node == NULL) {
        n = newnode(data);
        return (n);
    }

    if (data &lt;= node-&gt;data)
        node-&gt;left = insert(node-&gt;left, data, dup);
    else
        node-&gt;right = insert(node-&gt;right, data, dup);

    return node;
}

NODE * deletetree(NODE * from)
{
    if (from != NULL) {
        deletetree(from-&gt;left);
        deletetree(from-&gt;right);
        //printf(""deleting %d \n"", from-&gt;data);
        free(from);
    }
    return NULL;
}

int main()
{
    int sum = 35;
    int X[] = {1,2,3,4,5,6,7,8,9,1,2,3,4,5};
    int Y[] = {1,2,8,9};
    int i, dup = 0;

    int xlen = sizeof(X)/sizeof(X[0]);
    int ylen = sizeof(Y)/sizeof(Y[0]);

    printf(""len of X is : %d \n"", xlen);
    printf(""len of Y is : %d \n"", ylen);

    NODE * root1 = NULL;

    for (i=0; i&lt;xlen; i++) {
        root = insert(root, X[i], &amp;dup);
    }

    for (i=0; i&lt;ylen; i++) {
        dup = 0;
        root = insert(root, Y[i], &amp;dup);
        if (dup == 1) {
            printf(""%d "", Y[i]);
        }
    }

    printf(""\n"");
    root = deletetree(root);

    return 0;
}
</code></pre>
",11
8732358,8732325,22,"<p>You shouldn't use the third one because its wrong. ""String"" takes 7 bytes, not 5.</p>

<p>The first one is a pointer (can be reassigned to a different address), the other two are declared as arrays, and cannot be reassigned to different memory locations (but their content may change, use <code>const</code> to avoid that).</p>
",12
8732380,8732325,48,"<p><a href=""http://www.lysator.liu.se/c/c-faq/c-2.html"" rel=""noreferrer"">This link</a> should satisfy your curiosity.</p>

<p>Basically (forgetting your third example which is bad), the different between 1 and 2 is that 1 allocates space for a pointer to the array.</p>

<p>But in the code, you can manipulate them as pointers all the same -- only thing, you cannot reallocate the second.</p>
",1
8732404,8732325,7,"<pre><code>char *p = ""String"";   means pointer to a string type variable.
</code></pre>

<p><code>char p3[5] = ""String""</code>;  means you are pre-defining the size of the array to consist of no more than 5 elements. Note that,for strings the null ""\0"" is also considered as an element.So,this statement would give an error since the number of elements is 7 so it should be:</p>

<pre><code>char p3[7]= ""String"";
</code></pre>
",0
8732449,8732325,48,"<p>Strings in C are represented as arrays of characters.</p>

<pre><code>char *p = ""String"";
</code></pre>

<p>You are declaring a pointer that points to a string stored some where in your program (modifying this string is undefined behavior) according to the C programming language 2 ed.</p>

<pre><code>char p2[] = ""String"";
</code></pre>

<p>You are declaring an array of char initialized with the string ""String"" leaving to the compiler the job to count the size of the array.</p>

<pre><code>char p3[5] = ""String"";
</code></pre>

<p>You are declaring an array of size 5 and initializing it with ""String"". This is an error be cause ""String"" don't fit in 5 elements.</p>

<p><code>char p3[7] = ""String"";</code> is the correct declaration ('\0' is the terminating character in c strings).</p>

<p><a href=""http://c-faq.com/~scs/cclass/notes/sx8.html"" rel=""noreferrer"">http://c-faq.com/~scs/cclass/notes/sx8.html</a></p>
",1
13470308,13470240,2,"<p>The Microsoft compilers only support C89 so declarations and code cannot be mixed. This is permitted in C++. When the source file has a <code>.c</code> extension it is treated as C source, when it has <code>.cpp</code> it is treated as C++. </p>

<p>To correct for C put all variable declarations at beginning of the scope in which they are to be used.</p>
",0
13470323,13470240,4,"<p>You have declarations after statements. In newer versions of C (like C99), you can have this but in older versions you cannot. Microsoft's C compiler is old. In C++ it's OK, which is why it builds.</p>
",0
13470406,13470240,2,"<p>As far as i know Visual studio 2008 is not completely c99 compliant.</p>

<p>In standards before <code>c99</code> you have to declare your variables in the beginning of the program. But in <code>c99</code> declaration of variables can be done anywhere in the function. </p>

<p>Also in c++ there is no such restriction. In Windows when you create a file with extension <code>.cpp</code> it is treated as a c++ file. Hence the same program works when compiled as cpp.</p>

<p>Solutions:</p>

<ol>
<li>Declare your variables right in the beginning of the function. Which
is a good practice as well! </li>
<li>Change your compiler ! (Look at <a href=""http://codepad.org/obDhdySQ"" rel=""nofollow""><strong>this</strong></a>. No compiler error !)</li>
</ol>
",0
13701692,13701610,0,"<p><code>typedef</code> is the keyword in <code>C</code>, which provides the programmer a tool to make an alias of own </p>

<p><code>data type</code> from the other types or existing built-in types.</p>

<p>This is how the language is and this is how it's implemented.</p>

<p><code>typedef &lt;given_type&gt; &lt;new_type&gt;</code>   </p>

<p>FYI : if you do </p>

<p><code>int a</code> it parsed by compiler and then it came to know that <code>a</code> is a variable of type <code>int</code>.
And accordingly memory is assigned and all.</p>

<p>Similarly whenever <code>typedef</code> keyword found then it assumes that the type just following it is the <code>old_type</code> and other new identifier is <code>new_type</code>.</p>

<p>EDIT : </p>

<p>ISO c99 : Storage-class specifiers</p>

<p><code>The typedef specifier is called a ¡®¡®storage-class specifier¡¯¡¯ for syntactic convenience
only.If, in a parameter declaration, an identifier can be treated either as a typedef name or as a parameter name, it shall be taken as a typedef name.A typedef declaration does not introduce a new type, only a synonym for the type so specified</code></p>
",3
13702594,13701610,0,"<p>How any compiler handles a <code>typedef</code> isn't specified; most likely the type information is saved as part of the symbol table entry for that name, and everywhere the type name is encountered in the source code, the equivalent type information is substituted during translation.</p>
",0
20645030,20644743,1,"<p>They are each better or more convenient at certain kinds of tasks:</p>

<ul>
<li><p><code>sscanf</code> allows you to concisely specify a fairly complex template for parsing values out of a line of text,  but it is very unforgiving. If your input text differs by even a character from your template, the scan will fail. For that reason, it's almost never the right tool to use for human-generated input, for example. It is most useful for scanning automatically generated output, e.g. server log lines.</p></li>
<li><p><code>strtok</code> is much more flexible, but also much more verbose: parsing a line with only a few fields may take many lines of code. It is also destructive: it actually modifies the string that is passed to it, so you may need to make a copy of the data before invoking <code>strtok</code>.</p></li>
</ul>
",0
20644909,20644743,1,"<p><code>sscanf</code> uses a very incomplete (though efficient to implement) regular expression syntax, so if you wanted to do something more complicated, you <strong>cannot</strong> use <code>sscanf</code>.  </p>

<p>That being said, <code>strtok</code> isn't re entrant so if you're using threading then you're out of luck.</p>

<p>But generally speaking, the one that ends up running faster for a particular circumstance and is more elegant is often considered to be the most idiomatic for that circumstance.</p>
",3
20644919,20644743,1,"<p><code>strtok</code> is a much simpler, low level function mostly used to tokenize strings that have an unknown element count.</p>

<p><code>NULL</code> is used  to tell strtok to continue scanning the string from the last position, saving you some pointer manipulation and probably (internally to strtok) some initialization.</p>

<p>There's also the matter of readability. looking at the code snippet, it takes some time to understand what's going on.</p>
",0
20644864,20644743,2,"<p>IMHO the <strong>best way is the most readable and understandable way.</strong> <code>sscanf</code> and <code>strtok</code> totally disqualify with your user/pw extraction from an URL.</p>

<p>Instead, look for the boundaries of the strings you are looking for (in an URL the slash, the at-sign, the colon, what have you) with <code>strchr</code> and <code>strrchr</code>, then memcpy from start to end to where you need the data and tack on a NUL. This also allows for appropriate error handling should the string have an unexpected format.</p>
",1
20644896,20644743,0,"<p>I myself created a small header file with a few definitions of functions that can help such as a char <code>**Split(src, sep)</code> function and a <code>int DoubleArrLen(char **arr)</code>,
If you can improve it in any way here is the small 1-hour work thing.</p>

<pre><code>#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;malloc.h&gt;
#include &lt;assert.h&gt;
char *substring(char *string, int position, int length) 
{
   char *pointer;
   int c;

   pointer = malloc(length+1);

   if (pointer == NULL)
   {
      printf(""Unable to allocate memory.\n"");
      exit(EXIT_FAILURE);
   }

   for (c = 0 ; c &lt; position -1 ; c++) 
      string++; 

   for (c = 0 ; c &lt; length ; c++)
   {
      *(pointer+c) = *string;      
      string++;   
   }

   *(pointer+c) = '\0';

   return pointer;
}

char **Split(char *a_str, const char a_delim)
{
    char **result    = 0;
    size_t count     = 0;
    char *tmp        = a_str;
    char *last_comma = 0;

    /* Count how many elements will be extracted. */
    while (*tmp)
    {
        if (a_delim == *tmp)
        {
            count++;
            last_comma = tmp;
        }
        tmp++;
    }
    /* Add space for trailing token. */
    count += last_comma &lt; (a_str + strlen(a_str) - 1);

    /* Add space for terminating null string so caller
       knows where the list of returned strings ends. */
    count++;
    result = malloc(sizeof(char *) * count);

    if (result)
    {
        char delim[2] = { a_delim, '\0' };  // Fix for inconsistent splitting
        size_t idx  = 0;
        char *token = strtok(a_str, delim);

        while (token)
        {
            assert(idx &lt; count);
            *(result + idx++) = strdup(token);
            token = strtok(0, delim);
        }
        assert(idx == count - 1);
        *(result + idx) = 0;
    }
    return result;
}
static int SplitLen(char **array)
{
    int i = 0;
    while (*array++ != 0)
        i++;
    return i;
}
int IndexOf(char *str, char *ch)
{
    int i;
    int cnt;
    int result = -1;
    if(strlen(str) &gt;= strlen(ch))
    {
        for(i = 0; i&lt;strlen(str); i++)
        {
            if(str[i] == ch[0])
            {
                result = i;
                for(cnt = 1; cnt &lt; strlen(ch); cnt++)
                {
                    if(str[i + cnt] != ch[cnt]) result = -1; break;
                }
            }
        }
    }
    return result;
}
int IndexOfChar(char *str, char ch)
{
    int result = -1;
    int i = 0;  
    for(;i&lt;strlen(str); i++)
    {
        if(str[i] == ch)
        {
            result = i; 
            break;
        }
    }
    return result;
}
</code></pre>

<p>A little explanation can be the functions:
the substring function extracts a part of a string.
the IndexOf() function searches for a string inside the source string.
Others should be self-explanatory.
This includes a Split function as I pointed out earlier, you can use that instead of strtok..</p>
",0
10763071,10763019,1,"<p>You need two nested loops to do it:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void) {
    int fila[4], i, j;
    srand(rand());
    for (i=0;i != 4; i++) {
        fila[i]=rand()%3+1;
    }
    for (i=0 ; i != 4 ; fila[i]--, i += (fila[i] == 0)) {
        for (j = i ; j != 4 ; j++) {
            printf(""[%d] "", fila[j]);
        }
        printf(""\n"");
    }
    return 0;
}
</code></pre>

<p>The outer loop iterates until you get to the end of <code>fila</code>; inner loop prints the remaining elements of <code>fila</code> starting at the index of <code>i</code>.</p>

<p>Note that you shouldn't be re-seeding <code>srand</code> in a loop - you do it only once before the loop.</p>

<p>Here is the <a href=""http://ideone.com/NG0NT"" rel=""nofollow"">link to this program on ideone</a>.</p>
",1
10763092,10763019,0,"<p>What you want looks like this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
  int arr[4];
  int i;
  for(i = 0; i &lt; 4; i++) {
    arr[i] = (rand() % 3) + 1;
  }
  for(i = 0; i &lt; 4; i++) {
    while(arr[i]) {
      int j;
      for(j = i; j &lt; 4; j++) {
        printf(""[%d]"", arr[j]);
      }
      printf(""\n"");
      arr[i]--;
    }
  }
  return 0;
}
</code></pre>

<p>Notice the nested loops. In particular, the inner for loop lets you print <code>j</code> entries of the matrix without having to copy/paste that code over again -- you get to eliminate lots of redundancy.</p>
",0
17088048,17087845,3,"<p>As the compiler states, you're discarding a qualifier (<code>const</code> in this case) from a pointer upon assignment.</p>

<p>This happens when you assign a <code>char *</code> the value of a <code>const char *</code>.</p>
",0
17088087,17087845,1,"<p>firsts, lasts,streets are array so operation like <code>firsts[rand() % firsts_count];</code> will return a value which is const char* in your case. </p>

<p>But you are trying to collect these values in x_first_name and x_last_name variables which are <code>char*</code>(pointer to char).so in assignment it is loosing its const nature.</p>
",1
14235189,14235170,2,"<p>The <code>char</code> type is something of an anomaly in that it is not the same as either <code>signed char</code> or <code>unsigned char</code> (unlike the other integer types - <code>short</code>, <code>int</code>, <code>long</code>, etc - which are implicitly signed unless explicitly declared <code>unsigned</code>). Whether <code>char</code> is actually signed or not is implementation-dependent, and some compilers even let you specify the signedness via a command line switch.</p>

<p>Bottom line: never assume that <code>char</code> is signed or unsigned - if you actually require a signed or unsigned 8 bit quantity then use <code>signed char</code> or <code>unsigned char</code> explicitly, or better still, use <code>int8_t</code> or <code>uint8_t</code> from <code>&lt;stdint.h&gt;</code>.</p>
",2
14235262,14235170,5,"<p>They are the same. Or rather, their underlying representation is the same (under the assumption that your compiler use two-complement form).</p>

<p>On the other hand, the values they represent are -1 and 255.</p>

<p>When you print them, they are <em>extended</em> to the data type <code>int</code>. <code>unsigned char</code> is zero-extended whereas a signed char is sign extended, which accounts for the differences you see.</p>

<p>The same extension occurs when you compare the two values. <code>a == b</code> don't compare the underlying representations, instead, it extends both values to <code>int</code> so it compares 255 with -1, which isn't equal.</p>

<p>Note that a plain <code>char</code> may be either signed or unsigned. In your environment, it is obviously signed.</p>
",10
14235402,14235170,2,"<p>A <code>signed int</code> is signed, an <code>unsigned int</code> is unsigned. If you use just <code>int</code>, it implies <code>signed int</code>. Same is true for <code>short</code>, <code>long</code> or <code>long long</code>. Yet it isn't true for <code>char</code>. A <code>signed char</code> is signed, an <code>unsigned char</code> is unsigned, but just <code>char</code> may be either signed or unsigned. The data type char is supposed to hold a ""character"", hence the name, so it's not ""really"" an integer type to hold an integer number to be used in calculations. Of course a character is in reality an integer of some kind but of which kind is implementation dependent (the C standard does not force any specific kind). So if you want to use the char type for integer values (also used in calculations), always use <code>signed char</code> or <code>unsigned char</code> explicitly and only use just <code>char</code> when you are really dealing with characters or when it makes absolutely no difference for your code if char is signed or unsigned.</p>

<p>The comparison fails because your implementation defines <code>char</code> to be in fact <code>signed char</code>, so you are comparing a <code>signed char</code> to an <code>unsigned char</code> in your final <code>if</code> statement. Whenever you are comparing two integers of different type, the compiler converts both values to the same type <a href=""http://en.wikipedia.org/wiki/Type_conversion"" rel=""nofollow"">according to the rules of the C standard</a> before it actually performs the comparison. In your case, this means the C compiler actually does tho following:</p>

<pre><code>if((int)a==(int)b) printf(""equal\n"");
    else printf(""not equal\n"");
}
</code></pre>

<p>And now it should be obvious why those two values don't match. <code>(int)a</code> has a value of <code>-1</code>, however <code>(int)b</code> has a value of <code>255</code>, and these two values are not equal.</p>

<p>According to the rules of <em>type promotion</em>, <code>char</code> (in your case signed) is promoted to <code>int</code> and <code>unsigned char</code> is also promoted to <code>int</code>. The ISO C 2011 standard says:</p>

<blockquote>
  <p>If an int can represent all values of the original type (as restricted
  by the width, for a bit-field), the value is converted to an int;
  otherwise, it is converted to an unsigned int. These are called the
  integer promotions.) All other types are unchanged by the integer
  promotions.</p>
  
  <p>The integer promotions preserve value including sign. As discussed
  earlier, whether a ¡®¡®plain¡¯¡¯ char is treated as signed is
  implementation-defined.</p>
</blockquote>
",5
14235554,14235170,0,"<p>While there is some ambiguity around a plain ""char"" (see <a href=""https://stackoverflow.com/q/2054939/1955371"">Is char signed or unsigned by default?</a>) that's not the only thing that's going on here I think.</p>

<p>A literal -1 is an integer, it won't (sizeof(int)>sizeof(char), for arguments sake) ""fit"" into a char.The two-complement bit pattern 0xffff (32 bit int for arguments sake) is truncated and copied here.</p>

<p>When you call printf() the parameters are promoted to integer type, a signed type is ""sign-extended"", but the unsigned ""b"" is not, and zero padded. When you use ""=="" with two distinct types a similar (but not necessarily identical) type conversion is performed (aka the ""usual arithmetic conversions"").</p>

<p>See also <a href=""https://stackoverflow.com/q/1255775/1955371"">Default argument promotions in C function calls</a> and <a href=""https://stackoverflow.com/q/2706588/1955371"">Signed and unsigned, and how bit extension works in C</a>.</p>
",0
9227175,9226989,5,"<p>You need to assign to <code>*q</code> in the <code>add()</code> function, not the local <code>p</code>:</p>

<pre><code>add(node **q)
{
     int num;
     printf(""Enter the number you want to add"");
     scanf(""%d"", &amp;num);
     if(*q == NULL)
     {
        *q = malloc(sizeof(node)); /* no need to cast return value. */

        /* Corrected if logic to not access failed malloc. */
        if(*q == NULL)
        {
            printf(""The malloc failed\n"");
        }
        else
        {
            *q-&gt;n=num;
            *q-&gt;ptr=NULL;
        }
     }
}
</code></pre>
",4
9228602,9226989,0,"<p>In addition to the issues addressed by hmjd's answer, you might want to consider a different program design. You have made function does three entirely different things: interaction with the user, allocation of memory and the actual algorithm. This program design was the actual culprit that caused the bug.</p>

<p>Instead, you might want to consider a more object-oriented approach:</p>

<pre><code>int prompt_user (void) // this function interacts with the user (""GUI"")
{
  int num;
  printf(""Enter the number you want to add"");
  scanf(""%d"", &amp;num);
  getchar(); // discard line feed character from stdin

  return num;
}

void init_node (node* new_node, int num)
{
  new_node-&gt;n = num;
  new_node-&gt;ptr = NULL;
}


// this code is the caller:
{
  node* q = NULL;

  ...

  int num = prompt_user();

  if(q == NULL)
  {
    q = malloc(sizeof(node));
    if(q == NULL)
    {
      // error handling
    }
  }  

  init_node(q, num);

  ...

  free(q);
}
</code></pre>
",0
14201788,14201679,1,"<p>C only defines arrays and allows elements of an array to be, in turn, arrays also. For an array of arrays, the first index selects an array element and the second index selects a value element in that array. To have their meaning reversed would create an illogical grammar.</p>

<p>Interpreting the first index as the row number and the second index as the column number to some 2D matrix data structure is just that, an interpretation.</p>

<p>Note that Fortran's (column-major) arrays aren't indexed by applying two individual index operators.</p>

<p>EDIT: To give an authoritative quote, the C standard says, in ¡ì6.5.2.1 (C99), after explaining how the result of subscripting a multidimensional array is an n-1-dimensional array</p>

<blockquote>
  <p><strong>It follows from this</strong> that arrays are stored in row-major order</p>
</blockquote>

<p>(emphasis mine)</p>
",2
14202003,14201679,8,"<p>Basing my answer on some of the comments to the question as well as some other answers (and some of my own reflections - but notably no knowledge whatsoever of the C language design process...), I believe this is a choice based on merely what the people making this decision (Ritchie?) needed themselves.</p>

<p>If you interpret the indices of a multidimensional array as matrix indices, it makes sense to have the first index as a row index and the second as a column index - i.e. a column-major structure. If your applications are going to be heavy on linear algebra or other matrix-heavy computations, it also makes sense to store these structures in a way that makes it efficient to traverse them one column at a time, since many algorithms do this. For this reason, programming languages such as Matlab and Fortran benefit from being column-major - it makes it easier to write efficient code with matrices and matrix algorithms in mind.</p>

<p>C, on the other hand, is much more general-purpose than e.g. Matlab or Fortran. If you're not going to use <code>int**</code> specifically for <em>matrices</em>, it doesn't really matter which index is which. And it seems natural that if <code>a</code> is an <code>int**</code>, then <code>a[2]</code> returns an <code>int*</code> and <code>a[2][1]</code> returns an <code>int</code> - you ""dig deeper"" into the multidimensional array. For efficiency, we now only care that if we pick out <code>a[2]</code> and want to iterate it, it should be cached efficiently. <em>It doesn't matter if you, the programmer, are associating <code>a[2]</code> with a matrix row or a matrix column - we're not working with matrices!</em></p>

<p>Thus, there is no strong case (that I can make out off the top of my head) for C to be column-major. At the time of implementing the first versions, it might just have been <em>easier</em> to make it row-major - perhaps because the underlying low-level language (assembler?) was already row-major - and that was that.</p>
",5
14202347,14201679,2,"<p>In C array elements are guaranteed to be contiguous memory elements, and a 2 dimensional array is an array of arrays, so say for an array <code>int a[10][20]</code>; <code>a[0]</code> is itself an array, and its elements must be contiguous. Equally <code>a[0]</code> is contiguous with <code>a[1]</code>.</p>
",0
9151222,9151208,3,"<p>You do not know where the middle is until you scan the whole line. But you can scan the entire line, and then print only the second half, like this:</p>

<pre><code>printf(""%s\n"", line+strlen(line)/2);
</code></pre>

<p>This is how the above code works: <code>strlen</code> determines the length of the entire string (21), then we divide it in half using integer division (10), add it to the pointer to the beginning of the line, and pass the result to <code>printf</code>.</p>
",0
9151226,9151208,1,"<p>First half:</p>

<pre><code>printf(""%.*s\n"", strlen(line) / 2, line);
</code></pre>

<p>or first half but modifying <code>line</code> array:</p>

<pre><code>line[strlen(line) / 2] = '\0';
printf(""%s\n"", line);
</code></pre>

<p>Second half:</p>

<pre><code>printf(""%s\n"", line + strlen(line) / 2);
</code></pre>
",1
9151234,9151208,3,"<p>You scan whole line into char array and then you take from this char array only characters that you need.</p>

<p>What you should be really looking for is: <a href=""https://stackoverflow.com/q/2695114/1168156"">Parsing a string</a></p>

<p>Check <a href=""http://www.cplusplus.com/reference/clibrary/cstring/strtok/"" rel=""nofollow noreferrer"">strtok</a> function.</p>

<p>Hope this helps.</p>
",0
9151236,9151208,0,"<p>strlen(line) should give you the length of the line, then you can use a char array of half that length, iterate over the original line that many times, and copy character by character?</p>

<p>Don't forget to end the new array with a '\0'. :) Hope that works?</p>
",0
9151246,9151208,1,"<p><code>line</code> is an array, so you can use pointer arithmetic: </p>

<pre><code>printf(""%s\n"", line + (strlen (line)/2));
</code></pre>

<p>You ""move"" the beginning point from which string is displayed.</p>
",1
10774997,10774874,2,"<p>With C99 you can have so-called compound literals as some kind of unnamed variables and designated initializers to ease the writing of initializers. Your structures are a bit complicate that I can capture their complete meaning on a first glance, but something analogous to that here should work.</p>

<pre><code>odb const*const head = 
 &amp;(odb const){
  .method = something,
  .next   = &amp;(odb const){
     .method = another,
     .next = 0,
  },
};
</code></pre>

<p>Sure that you would have to initialize the other pointer fields analogously with the correct data, but I hope you get the idea.</p>

<p>When used in file scope compound literals of the form <code>(typename){ initiliazers }</code> are allocated statically.</p>
",4
12333741,12333724,2,"<p>Seems like you should pass <code>&amp;image</code> instead of image.</p>
",1
12333792,12333724,1,"<p>You probably want slot->bitmap.buffer instead of slot->bitmap</p>

<p>slot->bitmap is an FT_Bitmap, a struct type, that also contains the bitmaps width, etc.</p>
",5
12333961,12333724,2,"<pre><code>void png_write_image(png_structp png_ptr, png_bytepp image);
typedef png_byte        FAR * FAR * png_bytepp;
typedef unsigned char png_byte;
</code></pre>

<p>So png_write_image is looking for a input of type <code>unsigned char far * far *</code>.</p>

<p><a href=""http://en.wikipedia.org/wiki/Far_pointer"" rel=""nofollow"">http://en.wikipedia.org/wiki/Far_pointer</a> if you are interested in what the far means.</p>

<p>Now if you look at your FT_GlyphSlot type you will find:</p>

<pre><code>typedef struct  FT_GlyphSlotRec_
  {
...
FT_Bitmap         bitmap;
...
}

typedef struct  FT_Bitmap_
{
  int             rows;
  int             width;
  int             pitch;
  unsigned char*  buffer;
  short           num_grays;
  char            pixel_mode;
  char            palette_mode;
  void*           palette;
} FT_Bitmap;
</code></pre>

<p></p>

<p>So to get the right type you would need <code>&amp;slot-&gt;bitmap.buffer</code>.</p>

<p>No cast should be necessary.</p>
",1
15564391,15564335,3,"<p>firstly enum values are constants and hence, they cannot be changed in code, later on.</p>

<p>Secondly, I don't know what you are trying to do.. </p>
",0
15564426,15564335,3,"<p>An <code>enum</code> is just a way to give names to some <code>constants</code>, for clarity reasons.</p>

<p>It can be useful because, contrary to <code>defines</code>, the names you set for your variables are (typically) not discarded by your compiler, hence you can see them while going through your program with a debugger.</p>

<p>If you want to regroup variables and set values to them, use <code>structures</code> instead.</p>
",0
15564472,15564335,1,"<p>Do you mean this, instead?</p>

<pre><code>typedef struct test{
    int a, b;
} test;
typedef struct abc{
    test Test;
} abc;

int main(){

    abc ab;
    ab.Test.a = 5;
    return 0;
}
</code></pre>
",0
9210774,9210710,0,"<p>It's allocating increasingly longer arrays as each element of the arr. so arr[0] points to a 0  size array, arr[2] points to an array of 2 ints and so on. </p>
",0
9210789,9210710,2,"<p>The command that you are talking about allocates a block of length that is sufficient to store <code>i</code> items of type <code>int</code>, and stores the result at the <code>i</code>-th position in the array of pointers called <code>arr</code>. The program creates a ""triangular"" <code>arr</code> array: its elements are arrays of different lengths, arranged in such an order that <code>arr[i]</code> can hold <code>i</code> elements.</p>

<p>By the way, this code is missing calls to <code>free</code> for the items it has allocated.</p>
",0
9210799,9210710,0,"<p><code>arr</code> is an array of pointers to <code>int</code>. Every element of it - <code>arr[x]</code> - is a pointer to <code>int</code>, so an array. It's an array of arrays of ints.</p>

<p>For each element of the array, you create an array with size of the current index.</p>

<p>Note though that your code is illegal, since when <code>i==0</code>, you will call <code>malloc(0)</code>.</p>

<p>Also, it's good practice not to cast the return type of <code>malloc</code>. </p>
",0
9210817,9210710,1,"<pre><code>int *ptr, *arr[MAX]
</code></pre>

<p>creates a pointer to int and an array with MAX elements of pointers to int.</p>

<pre><code>arr[i]=(int*)malloc(i*sizeof(int))
</code></pre>

<p>Allocates space for <code>i</code> ints for every int pointer.</p>
",0
9210842,9210710,1,"<p>At first <code>sizeof()</code> ""returns"" (it should be replaced with numeric value during compilation) the size of provided type. Means 4 for <code>int</code> (8 on 64b machines), 1 for <code>char</code> and so on.</p>

<p>Therefore <code>i*sizeof(int)</code> means size for i ints (<code>i = 4; sizeof( int) = 4;</code> than it's <code>16</code>).</p>

<p><code>malloc()</code> uses number of bytes to allocate as parameter, therefore <code>malloc(16)</code> allocate 16bytes, enough space for 4 4B integers.</p>

<p><code>(int*)</code> is just something like <em>C-hack</em> to have correct types (because you want to use those 16B as <code>int[4]</code> not as <code>void *</code>).</p>

<p>The whole code means to allocate space for i ints on i-th place of array (1 on first, 2 on second...). However I wander what will happen for 0, when you'll try to allocate 0 Bytes :)</p>
",0
8723922,8723876,1,"<p>This code should compile, unless you actually forgot to close your function with a trailing <code>}</code>.</p>

<p>One other issue could be the redeclaration of <code>i</code>. I've seen this on some compilers. Also, a note - in the for loop you don't need to redeclare <code>i</code>, you can use the existing declaration.</p>

<p>I'm also assuming you defined the function <code>print</code> yourself.</p>
",3
8723940,8723876,4,"<pre><code>for (int i = 0; ...
</code></pre>

<p>This syntax is C99, it is not allowed in previous standards. Since you've already declared <code>i</code>, you can just change that to:</p>

<pre><code>for (i = 0; ...
</code></pre>

<p>If you want a block-level <code>i</code> in there anyway (it will shadow the <code>i</code> that you defined earlier in your function), then use:</p>

<pre><code>int i;
for (i = 0; ...
</code></pre>

<p>or get a compiler that supports C99.</p>
",0
8723957,8723876,1,"<p>If you are strictly using C, you can't declare variables inside the <code>For loop</code> body as you are doing now. I have tried this using GCC and i got compile error.</p>

<pre><code>error: 'for' loop initial declaration used outside C99 mode
</code></pre>

<p>Also, you seem to be re-declaring <code>i</code>, and some compilers won't able to detect that as a new scope.</p>
",3
8723958,8723876,0,"<pre><code>void enticl(int arrA[], int arrA_size, int arrB[], int arrB_size)
{
    int i;
    int smaller;
    int *arr;

    if(arrA_size&gt;arrB_size)
    {
        smaller=arrB_size;
        arr = arrB;
    }
    else
    {
        smaller=arrA_size;
        arr = arrB;

    }

    for(i = 0; i &lt; smaller; i++) 
    {
        printf(""%d\n"", arr[i]);
    }
}
</code></pre>
",0
12878013,12877790,0,"<p>No, the input functions do not treat NUL differently than other characters. Since any which return an unknown number of characters use NUL termination, though, the easiest thing to do is to write your own, such as this:</p>

<pre><code>ssize_t myfgets(char *buffer, size_t buffSize, FILE *file) {
    ssize_t count = 0;
    int character;
    while(count &lt; buffSize &amp;&amp; (character = getc(file)) != EOF) {
        buffer[count] = character;
        ++count;
        if(character == '\n') break;
    }
    if(count == 0 &amp;&amp; character == EOF) return EOF;
    return count;
}
</code></pre>

<p>This function is like <code>fgets</code>, except that it returns the number of characters read and does not NUL terminate the string. If you want the string to be NUL-terminated, change the first condition in the while loop to <code>count &lt; buffSize-1</code> and add <code>buffer[count] = '\0';</code> just after the loop.</p>
",0
12878116,12877790,2,"<p>If what you're reading is actually text, then you're in somewhat of an awkward situation.  <code>fgets</code> will read NULs just fine, store them in the buffer, and soldier on.  Problem is, though, you've just read in what is no longer an NTBS (NUL-<em>terminated</em> byte string) as the C library typically expects, so most functions that expect a string will ignore everything after the first NUL.  And you really don't have a reliable way to get the length, since <code>fgets</code> doesn't return it to you and <code>strlen</code> expects a C string.  (You could conceivably zero out the buffer each time and look for the last non-NUL char in order to get the length, but for short strings in big buffers, that's kinda ugly.)</p>

<p>If you're dealing with binary, things are a lot simpler.  You just <code>fread</code> and <code>fwrite</code> the data, and all's well.  But if you want text with NULs in it, you're probably going to end up needing your own read-a-line function that returns the length.</p>
",0
12877831,12877790,1,"<p>If you open the file in ""TEXT"" mode, then you cannot read the file beyond the NULL character. However binary files can be open()ed, read() and close()d. Look up these functions and binary i/o. </p>

<p>Also, EOF character is set as the NULL character in a TEXT file. You can however query using fstat the size of the binary file, and read the binary data(which may include NULL character)</p>
",5
8762868,8762855,2,"<p>In your case, your probably just need:</p>

<pre><code>cc main.c AddStudent.c
</code></pre>

<p>The <em>right</em> thing to do is make a makefile.  Here's a (probably a bit naive) example:</p>

<pre><code>myapp: main.o AddStudent.o
  cc -o myapp main.o AddStudent.o

main.o: main.c AddStudent.h Headers.h
  cc -c -o main.o main.c

AddStudent.o: AddStudent.c AddStudent.h Headers.h
  cc -c -o AddStudent.o AddStudent.c
</code></pre>

<p>The best place to learn about <code>make</code> is the <a href=""http://www.gnu.org/software/make/manual/"" rel=""nofollow"">GNU Make Manual</a>.</p>

<p>Bonus note - if you're starting to learn C, you might want to check out <a href=""http://clang.llvm.org/"" rel=""nofollow"">clang</a>.  It gives <em>way</em> better error messages than gcc does, in addition to supporting C99 without special flags and being much faster at compiling.</p>
",7
12835117,12834779,1,"<p>Instead of having different <code>struct</code>s that represent a linked list a possible solution would be to have single linked list <code>struct</code> that has <code>void*</code> member for data. This would allow a single <code>add_node()</code> function with a slightly different signature.</p>

<p>For example:</p>

<pre><code>struct linked_node
{
    void* data;
    struct linked_node* next;
};

void add_node(struct linked_node** a_head, void* a_data)
{
    struct linked_node* new_node = malloc(sizeof(*new_node));
    new_node-&gt;data = a_data;
    new_node-&gt;next = 0;
    if (!*a_head)
    {
        *a_head = new_node;
    }
    else
    {
        /* ... */
    }
}
</code></pre>

<p>There is a danger with this approach, namely the correct interpretation the <code>data</code> member. However, with care this approach would meet your requirements.</p>

<p>Example use (error checking omitted):</p>

<pre><code>struct data_x { int i; char c; };
struct data_y { char* s; };

struct linked_node* list_x = 0;
struct data_x* dx = malloc(sizeof(*dx));
dx-&gt;i = 4;
dx-&gt;c = 'a';

add_node(&amp;list_x, dx);

if (list_x)
{
    struct data_x* x = list_x-&gt;data;
    printf(""x.i=%d x.c=%c\n"", x-&gt;i, x-&gt;c);
}

struct linked_node* list_y = 0;
struct data_y* dy = malloc(sizeof(*dy));
dy-&gt;s = ""hello"";

add_node(&amp;list_y, dy);

if (list_y)
{
    struct data_y* y = list_y-&gt;data;
    printf(""y.s=%s\n"", y-&gt;s);
}
</code></pre>

<p>See online demo <a href=""http://ideone.com/iZO8h"" rel=""nofollow"">http://ideone.com/iZO8h</a>.</p>
",1
12835210,12834779,0,"<p>Only way to do this is with a macro assuming your linking elements are called the same (<code>next</code> is present in all types you wish to pass there).</p>

<p>GNU style code ahead: <code>-std=gnu98</code> or above</p>

<pre><code>#define addnode( head, node ) ({\
    typeof(head) _head = (head);\
    typeof(node) _node = (node);\
    if( _head == NULL )\
    {\
        _head = _node;\
    }\
    else\
    {\
        while( _head -&gt; next ) _head = _head -&gt; next;\
        _head -&gt; next = _node;        \
    }\
    \
    _head;\
})
</code></pre>

<p>This is pretty bad programming style though</p>
",0
10823925,10823886,2,"<pre><code>     scanf(""%d,%e"", &amp;X, &amp;Y);
</code></pre>
",2
10824255,10823886,1,"<p>(apart from the scanf() with the double format string, which has been handled by others)</p>

<pre><code>if ((0 &lt; X &lt; 2000) &amp;&amp; (0 &lt; Y &lt; 2000)) {
</code></pre>

<p>That does not work this way is C. You could try:</p>

<pre><code>if (X &gt; 0 &amp;&amp; X &lt; 2000 &amp;&amp; Y &gt; 0 &amp;&amp; Y &lt; 2000) {
</code></pre>

<p>Also note that you don't need the extra parentheses.
The same for the other line</p>

<pre><code>if ((X &lt; Y) &amp;&amp; (X % 5 == 0)) {
</code></pre>

<p>Which could be:</p>

<pre><code>if (X &lt; Y &amp;&amp; X % 5 == 0) {
</code></pre>

<p>Sometimes the rules of precedence are not that bad at all...</p>
",0
10825031,10823886,0,"<p>I don't know if this is homework...</p>

<p>... but this example might help clarify a few things:</p>

<pre><code>#include &lt;stdio.h&gt;

int
main(int args, char *argv[])
{
    int new_balance, old_balance;
    float withdrawal;

    /* Get input */
    printf(""Enter your initial Balance and the Amount to be Withdrawn.\n"");
    printf(""Note the values should lie between 0 and 2000\n"");
    while (scanf(""%d %f"", &amp;old_balance, &amp;withdrawal) != 2) {
      printf (""please enter two valid floating point numbers\n"");
    }

    /* Validate input */
    if ( (old_balance &lt; 0.0) || (old_balance &gt; 2000.0) ) {
      printf (""error: balance(%d): must be between 0.0 and 2000.0\n"",
        old_balance);
      return 1;
    }
    if ( (withdrawal &lt; 0.0) || (withdrawal &gt; 2000.0) ) {
      printf (""error: withdrawal(%f): must be between 0.0 and 2000.0\n"",
        withdrawal);
      return 1;
    }

    /* Compute balance */
    new_balance = old_balance - withdrawal;

    /* Print results */
    printf (""Withdrawal: %f; old balance: %d, new balance: %d.\n"",
      withdrawal, old_balance, new_balance);

    return 0;
}
</code></pre>

<p>I'm not at all sure what the requirement was with the ""0.5"" stuff, so I left it out.  My guess is that you wanted to ""round up to the nearest dollar"".  In which case ""%"" is definitely <em>not</em> the way to do it.</p>

<p>The original program might have compiled - but it almost certainly wasn't ""correct"".</p>

<p>And the original program, as far as I could tell, should have run just about anywhere - I didn't see anything likely to cause an ""out of memory condition"".</p>

<p>'Hope that helps .. at least a little...</p>
",0
9177791,9177760,1,"<p>Yes, if there isn't enough memory, <code>malloc</code> returns <code>NULL</code>.</p>
",0
9177810,9177760,1,"<p><code>malloc</code> takes a parameter that defines the amount of memory required - and in your example it is enough memory to hold an array of 70 integers.</p>

<p>If it is unable to do so, it returns <code>null</code>.</p>
",0
9177821,9177760,0,"<p>You always have to tell malloc how much memory you require. It never knows by itself. </p>
",0
9177834,9177760,2,"<blockquote>
  <p>Does malloc know how much memory my program wants?</p>
</blockquote>

<p>You specify the amount of memory as malloc parameter, so that it knows how much memory to allocate</p>

<p>In your example it will allocate <code>sizeof(int)*70</code> bytes (on 32bit Windows 4*70=280 bytes, for example)</p>

<blockquote>
  <p>I know it returns a value of the memory it found but how does it know if its enough?</p>
</blockquote>

<p>It looks at your parameter and checks if OS has enough memory for you, if memory is not enough it returns NULL.</p>
",3
9177850,9177760,1,"<p>The parameter you give to <code>malloc</code> is the number of bytes you want for this particular piece of memory.</p>

<p>If you want a char array to store 4 chars, you have to do</p>

<pre><code>char *tab;
tab = malloc(sizeof(*tab) * 4);
</code></pre>

<p>This will take the size of <code>*tab</code> which is a char, times 4, and allocate this space in memory.<br>
<strong>You have to know yourself how much is enough</strong> for your program to work.</p>
",13
9177856,9177760,0,"<p>No, malloc does not know how much memory your program wants, you're the one who should know that, and you're telling malloc how much memory you need for that particular buffer. </p>

<p>However, this buffer is not the total memory allocated to your program, only the memory allocated to this particular variable. If there isn't enough memory in your system, malloc will return null.</p>

<p>Bottom line, there's no way for you to tell the operating system that your program will need a lot of memory, you need to allocate the memory for each buffer you need and then check whether it returned NULL to see whether there's enough memory in the system.</p>
",0
9186734,9177760,0,"<p>As others have said, you have to tell <code>malloc</code> how much memory you want.  Note that if you don't allocate enough memory initially, you can use <a href=""http://pubs.opengroup.org/onlinepubs/000095399/functions/realloc.html"" rel=""nofollow noreferrer""><code>realloc</code></a> to request more memory.</p>
<p>Here's an example.  Suppose you want to store a line of text (delimited by a newline) from an input stream, but you don't know how long the line is, so you don't know ahead of time how much memory to allocate.  You can read the input stream piecemeal into a smaller fixed-size buffer, and append that to a dynamic buffer that you can resize as necessary:</p>
<pre><code>#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

/**
 * Reads a line of text (delimited by a newline character) from an 
 * input stream into a dynamic buffer. 
 */
char *getNextLine(FILE *stream, size_t *lineSize)
{
  char inbuf[SIZE];  // fixed-size input buffer
  char *line = NULL; // points to our dynamic buffer
  char *newline = NULL;
  char *(*append)(char *, const char *) = strcpy;

  *lineSize = 0;

  /**
   * Read from the input stream until we see a newline character
   * or the read fails (EOF or error).
   */
  while (!newline &amp;&amp; fgets(inbuf, sizeof inbuf, stream))
  {
    /**
     * Resize the buffer to accomodate the string in the input buffer
     * (allocates the buffer the first time through).
     */
    char *tmp = realloc(line, *lineSize + strlen(inbuf) + 1);
    if (tmp)
    {
      /**
       * Check for a newline in the input buffer
       */
      newline = strchr(inbuf, '\n');

      /**
       * If present, overwrite the newline with a 0 (nul terminator
       * character).  If you want to keep the newline in the target
       * buffer, skip this step.
       */
      if (newline)
        *newline = 0;

      /**
       * Assign the temporary variable back to line and update the 
       * output buffer size.
       */
      line = tmp;
      *lineSize += strlen(inbuf) + 1;

      /**
       * Write the contents of the input buffer to the target buffer.
       * First time through the loop we'll use strcpy (called through
       * the append function pointer); on each successive iteration
       * we'll use strcat to append the contents of the input buffer
       * to the target buffer.
       */
      append(line, inbuf);
      append = strcat;
    }
    else
    {
      /**
       * The realloc function failed; at this point, we'll just return
       * what we have.
       */
      printf(&quot;Unable to extend buffer\n&quot;);
    }
  }

  if (!newline &amp;&amp; !feof(stream))
  {
    printf(&quot;Error on read!\n&quot;);
  }

  return line;
}
</code></pre>
<p>This code uses <code>realloc</code> instead of <code>malloc</code> for the initial allocation (calling <code>realloc</code> with NULL as the first argument is the same as calling <code>malloc</code>).</p>
<p>Note that we assign the result of <code>realloc</code> to a temporary variable.  If <code>realloc</code> fails (there isn't enough memory to satisfy the request) it will return NULL; if we assigned this to <code>line</code> we'd lose our pointer to any memory we've already allocated, causing a memory leak.</p>
<p>There's a little trickery with the <code>append</code> function pointer.  The first time through the loop we want to copy our input buffer to the target buffer, so we set <code>append</code> to point to <code>strcpy</code>.  After that, we want to append what's in the input buffer to the contents of the target buffer, so we set <code>append</code> to point to <code>strcat</code>.</p>
<p>Note that it's up to the caller to free the dynamic buffer when it's done with it.</p>
",0
8730191,8730167,4,"<p>You're trying to pass <code>deck</code>, which is an <em>array</em> of cards, to a function with a parameter of type <code>cards</code>. Those are two different types. You probably want to change the type of the parameter in the <code>print_deck</code> function. I'd also suggest renaming the <code>cards</code> type as it's only actually a single card.</p>
",4
8730196,8730167,1,"<p><code>deck</code> is an array of <code>cards</code>, while <code>print_deck()</code> expects to get a <code>cards</code> type, those are incompatible types.</p>

<p>You probably want to declare <code>print_deck()</code> as: <code>print_deck(cards deck[],int size)</code> [where size indicates how big is your array of cards]</p>
",0
8730202,8730167,0,"<p>Your function only has an interface to receive one single card and not an array. Use something like <code>print_deck(deck[0]);
</code></p>
",0
19872594,19872481,1,"<p>One primary issue is indeed whether the matrix is laid out in row-major or column-major format.  That is defined by the C standard; it is not something that is left up to compiler writers. The other primary issue is the size of the array; if it is small enough to fit in cache memory, then it isn't critical which mechanism you use, but if it is too big to fit in cache, then one mechanism is vastly quicker than the other.</p>

<p>Which is it?  Well, a quick search on Wikipedia for <a href=""http://en.wikipedia.org/wiki/Row-major_order"" rel=""nofollow"">Row-major Order</a> shows that C uses row-major order.</p>
",0
19872813,19872481,1,"<p>Im not actually sure the code will compile first of all, because the dimension needs to be included in the function parameter declaration for arrays for each dimension after the first.</p>

<p>Anyway, C is row major (meaning elements within rows are stored contiguously in memory, and actually for a multidimensional array in C the entire array is contiguous), so the first option might be faster, because the inner loop traverses over a row by iterating over the columns.</p>

<p>Lastly you need to know how big the arrays are and how big the L1 cache is on the CPU you're using. If the array can fit within the L1 cache then both options should run at the same speed, since no cache lines will get ejected before theyre finished being used.</p>
",1
9163530,9162867,4,"<p>I think your misunderstanding is thinking that BSS is ""permanently zero"" memory. It's just a section of the program load mapping that's <em>implicitly zero</em> and thus avoids having any physical storage on disk, but otherwise it's a standard private writable mapping, and takes on physical existence as soon as it's written to.</p>

<p>If you're thinking about it moving, perhaps you're confusing virtual and physical addresses. The virtual address of an object in C never changes, and the physical address is never visible to you and should never matter.</p>
",0
9162902,9162867,7,"<p>Where the global variables will be stored is implementation defined, the C standard does not define where it should be saved.<br>
The C Standard does not even mention Bss segment or Data segment it only defines the behavior such variables must show.</p>
",1
8743484,8743445,4,"<p>It isn't initialized. The memory cell your <code>x</code> occupies still has a value from earlier use. However, the value of <code>x</code> might be anything, so you can't rely on it.</p>
",0
8743502,8743445,1,"<p>Undefined means it could be anything, even 0. Another implementation may have a different or random value. There's no way to know, and you can't trust it to be the same on every execution either.</p>
",0
8743518,8743445,1,"<p>Some compilers will do default initializations for you, some won't. You shouldn't count on them. The line saying</p>

<pre><code>int x;
</code></pre>

<p>should say</p>

<pre><code>int x = 0;
</code></pre>

<p>if that's what you want. For some C compilers, it's possible that x is -23157263 at the point printf is called.</p>
",0
8743529,8743445,0,"<p>Because at the memory space where x is placed there is already a 0, but this is just ""luck"" there could be any number or symbol at that place.
So to be sure that always get the same result you should always initialize a variable.</p>
",0
8743576,8743445,6,"<p>For static and global variables it is 0; automatic variables are not initialized by default.</p>

<p>in the c language there is no default value for non static local variables. The variable holds whatever was in memory before it became a variable. It's best to always initialize a non static local variable before using it in the c language (or at least before comparing it to something else). Also It's best to assume that there is no default value because this varies from language to language, and hardware to hardware.</p>

<p>Read more: <a href=""http://wiki.answers.com/Q/What_is_the_default_value_of_integer_in_c#ixzz1iaij7hRK"" rel=""noreferrer"">http://wiki.answers.com/Q/What_is_the_default_value_of_integer_in_c#ixzz1iaij7hRK</a></p>
",0
8743630,8743445,1,"<p>The initial value of an <code>automatic</code> variable if not explicitly initialized is indeterminate.</p>

<p>Indeterminate means either unspecified (could be 0, or 42) or a trap representation. A trap means reading the uninitialized variable undefined behavior (for example, crash you program).</p>
",0
8743654,8743445,0,"<p>I recall that Visual Studio would (and perhaps still does) set auto variables to 0 or null in some cases when the code was compiled with debug flags.  Like others have said, you certainly should not count on any default values.</p>
",0
18102647,14579920,2,"<pre><code>int sign(int x) {    
    return (x&gt;&gt;31)|(!!x);
}  
</code></pre>
",4
9140138,9140050,0,"<p>You need to store the number of times you passed in the loop in <code>reverseInteger</code> and reuse this information when you loop in <code>printDigits</code> function.</p>

<p>Instead of reversing your integer in an <code>int</code>, you also can just store all the digits in the reverse order in an array and store in another integer variable the number of digits. Then you  can print the elements of array (the digits) element by element starting from the end.</p>
",0
9140142,9140050,0,"<p>Before reverting the number,do something like this:</p>

<pre><code>while(number%10 == 0)
{
  number /= 10;
}

...//invering code here
</code></pre>
",0
9140219,9140050,3,"<p>The maximum number of digits in an <code>int</code> is small so you could safely use recursion in this case:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void
print_digits(unsigned n) {
  div_t q = div(n, 10);
  if (q.quot &gt; 0) print_digits(q.quot);
  printf(""%d\n"", q.rem);
}

int main() {
  print_digits(50210);
  return 0;
}
</code></pre>

<h3><a href=""http://ideone.com/9typO"" rel=""nofollow"">Output</a></h3>

<pre><code>5
0
2
1
0
</code></pre>
",0
9141792,9140050,0,"<p>The problem is that <code>reverseInteger(1) == reverseInteger(10) == reverseInteger(100) == reverseInteger(1000) == ...</code> and hence, once you use this function (which returns an <code>int</code>) you've already lost the information you need.  One solution is to count the trailing zeros first, leading to something like this (assuming <code>userInt &gt; 0</code>):</p>

<pre><code>int numTrailingZeros = 0;
while(!(userInt % 10)) {
    ++numTrailingZeros;
    userInt /= 10;
}
revInt = reverseInteger(userInt);
printDigits(revInt);
while(numTrailingZeros) {
    printf(""0 \n"");
    --numTrailingZeros;
}
</code></pre>
",0
9841678,9840980,1,"<p>I think something like this is what you are aiming for, which will work with C89, C99, and beyond:</p>

<pre><code>int k;
int input[20][WIDTH][HEIGHT];  // where WIDTH and HEIGHT are 
                               // compile-time constants
...
for ( k=0; k&lt;20; k++ )
{   
  char fname[10];
  sprintf(fname, ""input_%d"", k);
  FILE *fr = fopen(fname, ""r"");
  if (fr)
  {     
    int i;    
    for (i=0; i&lt;WIDTH; i++ )
    {  
      int j;           
      for (j=0; j&lt;HEIGHT; j++ )
      {                 
        fscanf( fr, ""%d"", &amp;input[k][i][j] );             
      }           
    }
    fclose(fr);     
  } 
}
</code></pre>

<p>However, I'm making a number of assumptions about your intentions here, so this may not be what you really want.  </p>

<p><em>EDIT</em></p>

<p>Fixed some typos, got rid of <code>width</code> and <code>height</code> variables.</p>
",2
11098665,11098626,7,"<p>The numerical value is the ASCII value of the character.</p>

<p><code>'a'</code> is 97, <code>'0'</code> is 48. 97-48=49.</p>

<p>49, in turn, is the value of <code>'1'</code>, so that's what is printed.</p>
",5
11098692,11098626,2,"<p>c - '0' will subtract the character code of '0'(48) from c. If c represents a digit this will result in the numeric value corresponding to c(3 for the char '3' for instance).</p>

<p>Still in order to get this numeric value you should use the format specifier %d in printf instead of %c.</p>

<p>It does not make much sense to subtract '0' from 'a' but maybe it will have some application for a particular task.</p>
",0
11098699,11098626,6,"<p>Characters in C are nothing more than just an integer value. Their value is defined according to a <a href=""http://en.wikipedia.org/wiki/Character_encoding"" rel=""nofollow"">character encoding</a>. The <a href=""http://en.wikipedia.org/wiki/ASCII"" rel=""nofollow"">ASCII </a> encoding is very well-known and the one that applies to the question posted by the OP. Therefore '0' equals 48 and 'a' equals 97. By subtracting them you are just getting the difference between those characters in the ASCII table.</p>

<p>In this example (equivalent to yours):</p>

<pre><code>printf(""%c"",'a'-'0');
</code></pre>

<p>you get <code>1</code> since 97-48 = 49 which corresponds to ASCII character '1'.</p>

<p>If instead you were using (note the ""%d"" instead of ""%c""):</p>

<pre><code>printf(""%d"",'a'-'0');
</code></pre>

<p>Then this would print only the difference (49 in this case), and not the ASCII character associated to the difference.</p>
",2
11098716,11098626,8,"<p><code>c - '0'</code> only has a definite specific value when c is a digit ('0', '1', ..., or '9').</p>

<p>When <code>c</code> is <code>'0'</code>, <code>'0' - '0'</code> is <code>0</code> because they are equal
when <code>c</code> is <code>'1'</code>, <code>'1' - '0'</code> is <code>1</code> because <code>'1'</code> immediately follows <code>'0'</code> in any character set any C implementation choses to use.
The same for <code>'2'</code> and the other digits: <code>'9' - '0'</code> has a value of <code>9</code>.</p>

<p>And you really shouldn't print a value with the <code>""%c""</code> format specifier.</p>
",0
11098750,11098626,3,"<p>The behavior of your code is implementation dependent. It relies on the encoding of characters.</p>

<p>On my Linux machine, the <code>a</code> character is encoded in <a href=""http://en.wikipedia.org/wiki/Ascii"" rel=""nofollow"">ASCII</a> (and in UTF8) as the single byte <code>97</code> (decimal), i.e. <code>0x61</code>. Likewise the <code>0</code> character is encoded as <code>48</code> i.e. <code>0x30</code>.  The difference <code>'a' - '0'</code> is <code>97 - 48</code> that is <code>49</code> which happens to be the encoding of character <code>1</code></p>

<p>On some ancient <a href=""http://en.wikipedia.org/wiki/EBCDIC"" rel=""nofollow"">EBCDIC</a> machine (e.g. old IBM mainframes, or new ones running in some compatibility mode or operating system) encoding is different.</p>

<p>With <a href=""http://en.wikipedia.org/wiki/UTF8"" rel=""nofollow"">UTF8</a> (now very often used) many more characters exist (e.g. the C cedilla <code>?</code> for French spelling), and they usually are encoded in more than one byte! </p>
",0
11099026,11098626,1,"<p>Lets explain this little more by using integers instead of characters.</p>

<pre><code>char c = 97;
printf(""%d"", c - 48); 
</code></pre>

<p>This will of course print 49, but as we translate this to character with the ASCII table we get 1.</p>

<pre><code>char c = 97;
printf(""%c"", c-48);
</code></pre>

<p>This code now prints 1 because we use char datatype when we print and it translates the 49 value into the ASCII equivalent number 1. </p>

<p>To prove this we can try something like this.</p>

<pre><code>char a = 'a';
char b = 97;
if((a == b) &amp;&amp; ((a-'0') == (b-48))) { 
      printf(""%s"", ""true"");
}
</code></pre>

<p>First we see if a and b are equivalent and then we see if a-'0' is equivalent with b-48. Since both are true we print true.</p>
",0
9824757,9824641,2,"<p>Reading from a member of the union <strike>other than the one most recently written to</strike> outside the ""byte footprint"" of the member to which you have most recently written leads to <strike>undefined</strike> unspecified behavior. You should not be reading <code>i</code> until after you have written to it: Whatever you see there is non-portable junk.</p>

<p><strong>EDIT 1</strong> Edited in response to Cristoph's comment.</p>
",3
9824941,9824641,1,"<blockquote>
  <p>i think that 99 is the result that shows that the higher bits are not
  intialized.. am i correct?..</p>
</blockquote>

<p>Correct because you only assign to two bytes explicitly in your second example, so two bytes of the integer remain uninitialized. In the first example you assign <code>4</code> to <code>i</code>, which is an integer and shares a byte with <code>c</code>. However, If both union members are of same type, then assuming that both will be initialized is correct. Also, the space allocated for a union is the space taken by its largest member so assuming some of the bytes of <code>i</code> will change when you assign to <code>c[x]</code> would not be wrong.</p>

<p>The different values you may see for uninitialized bytes with different initialization methods, in different scopes and contexts are irrelevant, case specific and not defined. However, I cannot comment on 515 as it is not clear to me how you get that value.</p>
",1
9825087,9824641,1,"<p>Your assignment through the <code>char</code> could lead to undefined behavior if the new value happens to be a trap representation (rare) for the type <code>int</code>.</p>

<p>Your example with the <code>union</code> is <strong>not</strong> an initialization but only an assignment and thus it only changes exactly the bytes that you are accessing and the other stay with unspecific values. For unions it is always a good idea to do an initialization of the widest member something like</p>

<pre><code>union a ob = { .i = 0 };
</code></pre>

<p>Thereby you can guarantee that all bytes of your object are initialized by <code>0</code>.</p>
",4
9859043,9859023,4,"<p>That's what I get, and I agree it's guaranteed to be that.  There is a sequence point after evaluating the first operand (the condition) before going to the second or third operand.  So it goes like this:</p>

<pre><code>(a++ &gt;b++ )
</code></pre>

<p>evaluates to:</p>

<pre><code>0 &gt; 1
</code></pre>

<p>which is 0.</p>

<p>After that, <code>a</code> is 1 and <code>b</code> is 2.</p>

<p>Since it was false:</p>

<pre><code>b++ 
</code></pre>

<p>is evaluated.  The result is 2 (which is assigned to <code>c</code>), and afterwards <code>b</code> is 3.</p>

<p>If that's the exact code, your compiler is buggy.  It's not even a question of order.  Even if the third operand were evaluated before the first (which would be wrong), <code>b</code> should still be 3.</p>

<p>I am using GCC 4.6.3, but the result will be the same in all standards-compliant compilers.</p>
",0
9859048,9859023,2,"<p>It's defined behavior, there's a sequence point between the first operand of <code>?:</code> and second or third one.</p>

<p>So after evaluating <code>a++ &lt; b++</code>, a = 1 and b = 2. Then the third operand gets selected. Thus c gets assigned <code>b++</code>. So c = 2 and <em>then</em> b = 3.</p>

<p>The C11 standard says:</p>

<blockquote>
  <p>6.5.15  Conditional operator</p>
  
  <p>The ?rst operand is evaluated; there is a sequence point between its
  evaluation and the evaluation of the second or third operand
  (whichever is evaluated).</p>
</blockquote>
",1
9199018,9198985,9,"<p>Start with atoi() and atof(), measure the speed, decide if it's a problem - then look for a solution</p>

<p>edit - it's <em>almost</em> certain that the I/O will dominate any time spent doing the conversion. If the conversion time does matter (after you profile) then if you know the format ie. ints are always 4digits, floats always have 5 decimal places, you might be able to write a hand tuned routine that does better than the standard lib </p>
",0
9199040,9198985,2,"<p>You can just use </p>

<pre><code>atoi()
</code></pre>

<p>for ints and </p>

<pre><code>atof()
</code></pre>

<p>for floats.</p>
",0
9199618,9198985,1,"<p>For <code>int</code>, the obvious loop is probably the fastest.</p>

<p>For <code>float</code>, it's much more complicated. If you don't care if the result is right, a similarly trivial loop is also fine. If you need the exact result, you'll want to use <code>strtod</code> or <code>atof</code> or similar since rolling your own is extremely difficult.</p>
",0
9809366,9809197,1,"<p>scanf(""%d"" ...) will scan past white space (blank, tab, newline) to get to the number.</p>

<p>scanf(""%c"" ...) will read the next character. </p>

<p>You need to figure out a way to scan past white space. Have you looked at the definitions for the formats to scanf?</p>

<p><a href=""http://en.wikipedia.org/wiki/Scanf_format_string"" rel=""nofollow"">Wikipedia</a> seems quite helpful compared to normal man pages.</p>
",4
11573791,11573735,3,"<p>When <code>function1</code> calls <code>function2</code>, just pass in <code>x</code>, not <code>&amp;x</code>.</p>

<pre><code>function1(int *x)
{
  function2(x); /* not &amp;x */
}
</code></pre>

<p><code>&amp;x</code> will pass <code>function2</code> a pointer to a pointer to an <code>int</code>, but it is declared to only take a pointer to an <code>int</code>.</p>

<p>Other issues: <code>z</code> should be initialized, and the functions should either have forward declarations, are declared above <code>main</code>. <code>main</code> should be declared to return an <code>int</code>, and return <code>0</code> on success. And as noted in the other answer, your other functions also need return types.</p>

<pre><code>void function2(int *number)
{
   ++(*number);
}

void function1(int *x)
{
  function2(x);
}

int main()
{
  int z = 0;
  function1(&amp;z);
  return 0;
}
</code></pre>
",2
11574521,11574479,0,"<p>Of course there is. <a href=""http://caca.zoy.org/wiki/libcaca"" rel=""nofollow"">libcaca</a> is a widely supported text-based graphics library, maybe you can find it useful.</p>
",0
11574753,11574479,1,"<p>You can use <a href=""http://wiki.bash-hackers.org/scripting/terminalcodes"" rel=""nofollow"">VT100 escape codes</a> to add colour to your text output. Then you don't need any external library or program.</p>

<p>Example:</p>

<pre><code>printf(""This text is \x1b[31mred \x1b[32mgreen \x1b[0mnormal.\n"");
</code></pre>

<p><strong>Edit:</strong> Escape codes do not work in the Windows command prompt, instead you have to use functions such as <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/ms686047%28v=vs.85%29.aspx"" rel=""nofollow""><code>SetConsoleTextAttribute</code></a>.</p>

<p>Here is an example showing how to use it:</p>

<pre><code>#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;

int main()
{
    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);

    CONSOLE_SCREEN_BUFFER_INFO ConsoleInfo;
    GetConsoleScreenBufferInfo(hConsole, &amp;ConsoleInfo);
    int originalAttrs = ConsoleInfo.wAttributes;

    printf(""This text is "");
    SetConsoleTextAttribute(hConsole, FOREGROUND_RED);
    printf(""red "");
    SetConsoleTextAttribute(hConsole, FOREGROUND_GREEN);
    printf(""green "");
    SetConsoleTextAttribute(hConsole, originalAttrs);
    printf(""normal\n"");

    return 0;
}
</code></pre>
",3
9829569,9825536,1,"<p>If you're running on Linux, this information is sometimes listed in <code>/proc/cpuinfo</code> as <code>cache_alignment</code>. </p>

<p>You could also find this information indirectly by stepping through an array, adjusting your stride, and timing the loop. When accesses aren't block aligned you'll see the performance drop, so you can get a pretty good idea of what your block size is. Here's a quick and dirty version to basically do this, I think it'll give you a good idea:</p>

<pre><code>int main () {
    int i, STEP_SIZE = 8;
    int * a;
    struct timeval t1, t2;
    double el;

    a = (int*)malloc(1024*1024*64*sizeof(int));

    for (i = 0; i &lt; 1024*1024*64; i++)
        a[i] = 0;

    gettimeofday(&amp;t1, NULL);

    for (i = 0; i &lt; 1024*1024*64; i += STEP_SIZE)
        a[i] += 10;

    gettimeofday(&amp;t2, NULL);
    el = (t2.tv_sec - t1.tv_sec) * 1000.0;
    el += (t2.tv_usec - t1.tv_usec) / 1000.0;
    printf(""%d %3.2f\n"", STEP_SIZE, el);

    return 0;
}
</code></pre>

<p>Basically you would want to vary <code>STEP_SIZE</code></p>
",0
10826929,10826869,0,"<p>Sometimes, it's used to absorb some network jitter.
The reason you can watch a movie smoothly on Youtube is because that your browser first download some data into a buffer, and then play it.</p>
",0
10826934,10826869,4,"<p>From wikipedia:</p>

<blockquote>
  <p>a buffer is a region of a physical memory storage used to temporarily hold data while it is being moved from one place to another. </p>
</blockquote>

<p>With that being said, I feel there are a few concrete uses of buffers:</p>

<ul>
<li><p>Transforming an asynchronous data source into a synchronous data source:
This is a big one, and a lot of APIs are built with this mindset.  For example, imagine you're reading a  data source which is inherently prone to failure. Asynchronously you have a stream which can fail at certain times, but you can request the data be read again.  This handling of data is a very low level detail, and you wouldn't want programmers at a high level to have to worry about it.  The solution, write a low level handler which manages the stream and put data in a buffer once it's safely been read in.  For example, you see this use of a buffer in file systems, network protocols, etc...</p></li>
<li><p>Passing large amounts of data around:  If you want to share data between multiple people, you need a temporary place to store data to mediate it between people.</p></li>
<li><p>Copying things / doing destructive manipulations:  If you have a situation where you need to free one pointer and move something around in memory (for whatever reason), you can put the data in a temporary holding place.  One common case is where I'm doing something like destructively manipulating a string: I can't manipulate the original string, I need to make a copy of it, so I don't corrupt the pointer if other people are holding on to it.</p></li>
</ul>
",0
10826909,10826869,0,"<p>A buffer is just a chunk of data, how much you need and when you need it is task dependent. The most common operations involving buffers are File I/O and arrays.</p>
",0
9207230,9206925,1,"<pre><code>alpha[i] = 'A' + i++;
</code></pre>

<p>This is undefined behavior in C. Anything can happen when you do this, including crashes. Read <a href=""https://stackoverflow.com/questions/4176328/undefined-behavior-and-sequence-points"">this link</a>.</p>

<p>Generally I would advise you to replace your while loops with for loops, when the maximum number of iterations is already known. This makes the code easier to read and possibly faster as well.</p>

<p>Is there a reason you are using float for counter variables? That doesn't make sense.</p>

<p>'i = 30;' What is this supposed to mean? If your intention was to end the loop, use a break statement instead of some mysterious magic number. If your intention was something else, then your code isn't doing what you think it does.</p>

<p>You should include some error handling if the file was not found. fin = fopen(..) and then if(fin == NULL) handle errors. I would say this is the most likely cause of the crash.</p>
",1
9207284,9206925,1,"<p>Here are a few pointers besides the most important one of initializing <code>found[]</code>, which was mentioned in other comments.</p>

<p>the <code>alpha[]</code> array complicates things, and you don't need it.  See below for a modified file-read-loop that doesn't need the <code>alpha[]</code> array to count the letters in the file.</p>

<p>And strictly speaking, the expression you're using to initialize the <code>alpha[]</code> array:</p>

<pre><code>alpha[i] = 'A' + i++;
</code></pre>

<p>has undefined behavior because you modify <code>i</code> as well as use it as an index in two different parts of the expression. The good news is that since you don't need <code>alpha[]</code> you can get rid of its initialization entirely.</p>

<p>The way you're checking for <code>EOF</code> is incorrect - it'll result in you acting on the last character in the file twice (since the <code>fscanf()</code> call that results in an <code>EOF</code> will not change the value of <code>ch</code>).  <code>feof()</code> won't return true until <em>after</em> the read that occurs at the end of the file.  Change your <code>ch</code> variable to an <code>int</code> type, and modify the loop that reads the file to something like:</p>

<pre><code>// assumes that `ch` is declared as `int`

while ( (ch = fgetc(fin)) != EOF ) {
    if ( isalpha(ch) ) {
        count += 1;
        ch = toupper(ch);

        // the following line is technically non-portable, 
        //  but works for ASCII targets.
        // I assume this will work for you because the way you
        //  initialized the `alpha[]` array assumed that `A`..`Z`
        //  were consecutive.

        int index = ch - 'A';

        found[index] += 1;
    }
}
</code></pre>
",1
9207016,9206925,0,"<p>Check the definition of found[] in the caller function.  You're probably running out of bounds.</p>
",0
19888405,19888380,3,"<p>Don't use <code>gets()</code>, it's dangerous, use <code>fgets()</code> instead.</p>

<p><code>fgets()</code> returns a null pointer when end-of-file is encountered, or when a read error occurs.  And it returns a non-null pointer when read successfully. You can use this return value as the condition.</p>
",0
19888407,19888380,1,"<p>First of all, use <a href=""http://en.cppreference.com/w/c/io/fgets"" rel=""nofollow""><code>fgets</code></a> instead of <code>gets</code>. Secondly, if you read the linked reference of <code>fgets</code> you will know it returns a non-null pointer is everything is okay, and so you can use that as your loop condition.</p>
",0
19888411,19888380,0,"<p>may be like this</p>

<pre><code>while(1) {
 gets(arr);
 if(someExitCondition(arr))
  break;
 // do something with arr
}
</code></pre>

<p>ofcouse use fgets instead of gets</p>
",0
19888468,19888380,0,"<p>You can do as,</p>

<pre><code> while((fgets(arr, sizeof arr, stdin) != NULL))
 {  
     // do something with arr
 }
</code></pre>

<p>Since you are using <a href=""http://linux.die.net/man/3/fgets"" rel=""nofollow"">fgets()</a> for first time, its syntax is,</p>

<pre><code>char * fgets ( char * str, int num, FILE * stream );
</code></pre>

<ol>
<li><p><code>str</code> is <code>char *</code> where your input is stored.</p></li>
<li><p><code>num</code> is the maximum number of characters to read</p></li>
<li><p><code>stream</code> is a pointer to a<code>FILE</code> structure, that returned from fopen.
 stdin, stdout, and stderr as well. </p></li>
</ol>
",0
10103422,9962068,-1,"<p>well here i solution how to count words in file</p>

<pre><code>while(sc !=EOF)
{
sc=fgetc(at);    // at is file stream 

        if(isspace(sc)) sp=1;
        else if(sp) {
            ++words;
        sp=0;
        }
}
</code></pre>
",1
9858780,9858764,0,"<p>You could use <code>drand48</code>; for your information the latest C++11 standard has a powerful standard random library.</p>

<p>If you don't want to use <code>drand48</code>, you might code something like e.g. <code>((double) (rand() % 10000000)) * 1.0e-6</code> but I don't recommend that.</p>
",0
9858855,9858764,1,"<p>Try the following</p>

<pre><code>p = rand() / (double)RAND_MAX;
</code></pre>
",2
9858926,9858764,0,"<p>something like a Tausworthe-based PRNG would work well, <a href=""http://luajit.org/download.html"" rel=""nofollow"">LuaJIT2</a> (beta) has a very nice variant that correctly scales between [n..m] and [0..1], you can find it in the lib_math.c file in LuaJIT's source.</p>

<p>You can also have a look at the the RNG's use by R <a href=""http://svn.r-project.org/R/trunk/src/main/RNG.c"" rel=""nofollow"">here</a>.</p>
",0
9185659,9185239,0,"<p>In pseudo code, assuming items is sorted by date time, you can do this:</p>

<pre><code>last_printed_day = null

foreach item in items
    if item.day != last_printed_day
        print item.day
        last_printed_day = item.day
    end
    print item
end
</code></pre>

<p>You will probably want to keep track of which actual day was printed last, even if you print the day only formatted as the week day name. That way if you have a data set which has only data for Sundays, you'll still get ""Sunday"" printed at the start of each day.</p>
",0
9185702,9185239,0,"<p>I haven't really studied your code.<br>
What you want to do is check if the current day is the same as the previous one and, if it is do not print it.</p>

<p>Initialize the previous day to an invalid value</p>

<pre><code>char previousday[500] = ""invalid""; /* you might want to use less than 500 chars */
</code></pre>

<p>and in your loop keep checking</p>

<pre><code>if (strcmp(start_time, previousday) != 0) {
    // print, or add to buffer, start_time
    strcpy(previousday, start_time);
}
</code></pre>
",0
12303837,12303815,9,"<p>Because in C a <code>const</code> is not a true compile-time constant. It's just a read-only object. There's a <a href=""http://c-faq.com/ansi/constasconst.html"">C FAQ</a> about this very subject.</p>
",1
12303847,12303815,2,"<p>Constant variables are still not constant expressions. Constexprs (as referred to commonly) have to contain literals and compile-time constants only.</p>
",0
12303853,12303815,0,"<p>It is because you are using variable in you code.You can't use a variable in case statement.
Here  a is assumed as variable</p>

<blockquote>
  <p>The compiler is explicitly allowed to use an efficient binary tree or
  a jump table to evaluate case statements.</p>
  
  <p>For this reason, case statements are compile time constants.</p>
</blockquote>

<p>The C99 standard says this (and the C89 standard was very similar):</p>

<blockquote>
  <p>¡ì6.8.4.2 The switch statement</p>
  
  <p>Constraints</p>
  
  <p>?1 The controlling expression of a switch statement shall have integer
  type.</p>
  
  <p>[...]</p>
  
  <p>?3 The expression of each case label shall be an integer constant
  expression and no two of the case constant expressions in the same
  switch statement shall have the same value after conversion. There may
  be at most one default label in a switch statement.</p>
</blockquote>
",0
12303942,12303815,2,"<p>Reasons:</p>

<p>1.<code>const</code> cannot be used in a switch statement. You could use a <code>#define/enum</code> though. Refer <a href=""https://stackoverflow.com/questions/1674032/static-const-vs-define-in-c"">this link</a>.</p>

<p>2.There is no <code>break</code> for the second case.</p>

<p>3.There is no <code>default</code> case.</p>

<p>4.There should be a colon after <code>case</code>.</p>
",0
10170612,10170358,0,"<p>Functions will execute in the order in which they are called, rather than their order in a source file.</p>

<p>There is also no <code>main(){...}</code>, so the code won't do anything in its current state.</p>
",1
10170620,10170358,1,"<p>it makes sense to me
you are confusing your function names</p>

<p>getch != getchar
getint != getop</p>

<p>get some sleep</p>
",1
10171006,10170358,5,"<p>The getint() function only reads digits from the input. If it gets a character that is not a digit or a + - sign at the beginning it will call ungetch() to push the character back into the input buffer so it could be read by some other function call. getint() will go on returning 0 until you remove the non-digit character from the input buffer by calling getch() on your own.</p>
",3
10174165,10170358,1,"<p>If <code>getint()</code> fails (and thus use ungetch in the scenario you give), calling again <code>getint()</code> will fail again. You are expected to call another function which will consume the pending character and make something usefull from the data which can't be interpreted as an int.</p>
",0
18327473,18327455,7,"<p><code>i[""11""]</code> == <code>*(""11"" + i)</code> == <code>""11""[i]</code></p>
",0
18327513,18327455,1,"<p>when you do <code>i[""11""]</code> what you do is say to the compiler to take the value of <code>i</code> and add to it the value of <code>""11""</code> and take the value on the address that is the sum of them</p>
",0
12256736,12256727,3,"<p>There are no references in C(<em>your Q is tagged C only</em>) so you will have to use the pointer version.     </p>

<p>When you say pass an array to the function, what you essentially pass to the function is the pointer to its first element, both of the following two syntaxes mean one and the same thing to the compiler:</p>

<pre><code>void shuffle(int *p_deck); 
void shuffle(int deck[]);
</code></pre>
",0
12256737,12256727,0,"<p>C doesn't have references <sup>(a)</sup>, that's C++.</p>

<p>In C, arrays of <code>X</code> decay into a pointer to <code>X[0]</code> when passed to functions, so one way is to use:</p>

<pre><code>void shuffle (int *pDeck) {
    // use pDeck[something]
}
:
int deck[] = {0,1,2,3,4,5,6,7,8,9};
shuffle (deck);
</code></pre>

<p>I actually prefer that method to the <code>void shuffle (int pDeck[])</code> variant since the former makes it absolutely clear that you're now dealing with a pointer rather than an array.</p>

<p>The reason this is important is because you lose the size information when you do that, so you may want to pass that in as well:</p>

<pre><code>void shuffle (int *pDeck, size_t sz) {
    // use pDeck[0 thru sz-1]
}
:
int deck[] = {0,1,2,3,4,5,6,7,8,9};
shuffle (deck, sizeof (deck) / sizeof (*deck));
</code></pre>

<hr>

<p><sup>(a)</sup>: Although they are a <em>very</em> nice feature. I do hope that ISO considers them for the next C standard, since a large number of problems newcomers to the language have are involved with pointers, and references can hide the complexity of that very well.</p>
",3
12256743,12256727,0,"<p>Arrays decay into pointers when passed to functions, so there's no point in using an additional level of indirection here.</p>

<p>According to &sect;6.3.2.1 of the C99 standard,</p>

<blockquote>
  <p>Except when it is the operand of the <code>sizeof</code> operator or the unary <code>&amp;</code> operator, or is a
  string literal used to initialize an array, an expression that has type ""array of <em>type</em>"" is converted to an expression with type ""pointer to <em>type</em>"" that points to the initial element of the array object and is not an lvalue. If the array object has register storage class, the behavior is undefined.</p>
</blockquote>

<pre><code>void shuffle(int deck[]) {
  ...
}
</code></pre>

<p>Note that C does not support references, only pointers. You're probably thinking of C++.</p>
",0
12256766,12256727,0,"<p>You would have to use the pointer version, but because of the Right-Left Rule, I believe your:</p>

<p><code>int * deck[]</code> would actually be an array of int pointers, instead of an array of ints.</p>

<p><a href=""http://cseweb.ucsd.edu/~ricko/CSE131/rt_lt.rule.html"" rel=""nofollow"">http://cseweb.ucsd.edu/~ricko/CSE131/rt_lt.rule.html</a></p>

<p>You should just pass a reference to the first element in the array:</p>

<p><code>int * deck</code> but you may want to pass in the size of the array so you avoid going out of bounds.</p>
",0
12256770,12256727,0,"<p>Neither.</p>

<p>Since arrays can be passed by reference only, you don't need to do tricks, just pass a pointer and dereference it. (That syntax involving the &amp; in your 2nd function is not valid, anyway). So:</p>

<pre><code>void shuffle(int arr[])
{
    arr[0] = 1337;
}
</code></pre>

<p>or</p>

<pre><code>void shuffle(int *arr)
{
}
</code></pre>

<p>etc. And you can pass it like this:</p>

<pre><code>int deck[52];
shuffle(deck);
</code></pre>
",3
12256778,12256727,0,"<p>You can pass an array by reference in C++, if you specify the size of the array: </p>

<pre><code>void shuffle(int (&amp;deck)[52])
{
   deck[4] = 34;
}
</code></pre>

<p>If you don't know the size, or if you're limited to C, you need to use pointers.</p>

<p>The other (C++) option is to use a vector for the deck and pass a reference to the vector instead.</p>
",0
10103135,10103080,0,"<p><code>%s</code> format specifier is used for printing strings, you need to use <code>%c</code> specifier which prints a character to the screen.</p>
",0
10103110,10103080,4,"<p>You print only the character at that location, so change </p>

<pre><code>printf(""%s\n"", &amp;code[k]); 
</code></pre>

<p>to </p>

<pre><code>printf(""%c\n"", code[k]);
</code></pre>

<p>You should also check that the value you read into <code>k</code> is >= 0 &amp;&amp; &lt; 11 , otherwise you'll access the array outside its bounds.</p>
",9
10103183,10103080,0,"<p><code>printf(""%c\n"", code[k]);</code>  instead of <code>printf(""%s\n"", &amp;code[k]);</code></p>
",0
13704342,13704127,1,"<p>Why use <code>%s</code> when <code>text</code> is <code>char</code>. You dont need a string type in the function. Just a char would do. Change in the function : <code>void randAlph ()</code></p>

<pre><code>printf(""%s ,"",text);
</code></pre>

<p>to </p>

<pre><code>printf(""%c ,"", text);
</code></pre>
",0
13705061,13704127,2,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt; 
#include ""conio.h""
#include &lt;time.h&gt;


int genrandom(int,int);
void randAlph(void);
char letterize(int);

int main (void) {
//     char full[9];
//     char part_non[4];  
    srand(time(0));        

    int i;
    for (i=0;i&lt;50;++i) {
      randAlph();
    };

}

int genrandom(int mino,int maxo) {//changed function return type to int
    int val=mino+rand()/(RAND_MAX/(maxo-mino)+1); //Be careful when you are using '/' operator with integers
    return val;  //returning int here why set return type to long int?
}

void randAlph (){
  int val;
  char text;
  val=genrandom(0,26);
  //  return val;
  text=letterize(val);
  printf(""%c ,"",text);//Replace %s with %c

}

char letterize(int num) { //No bound checking on num eh?
  char letter='A'+num;
  return letter;
}
</code></pre>

<p>That's all I had to say. :)</p>
",4
13704169,13704127,4,"<p><code>printf(""%s ,"",text);</code> is wrong - it says that <code>text</code> is a nul-terminated array of chars.  Use</p>

<pre><code>printf(""%c ,"", text);
</code></pre>

<p>instead to print your single char.</p>
",2
13465366,13465299,4,"<p>The function could return either ¡ª your choice.  You've said you'll return a pointer; that's OK as long as you do.</p>

<p>When you write:</p>

<pre><code>static fruits_t *getFruitFromValue(char value)
{
    int i;
    for (i = 0; i &lt; sizeof(fruit_array)/sizeof(fruit_array[0]); i++){
        if (value == fruit_array[i].value){
            return fruit_array[i];
        }
    }
}
</code></pre>

<p>There are several problems:</p>

<ol>
<li><code>fruit_array[i]</code> is a structure, not a pointer.  Use <code>return &amp;fruit_array[i];</code>.</li>
<li>If the loop exits, you don't return a value from the function at all.</li>
</ol>

<p>Fixing those leads to:</p>

<pre><code>static fruits_t *getFruitFromValue(char value)
{
    int i;
    for (i = 0; i &lt; sizeof(fruit_array)/sizeof(fruit_array[0]); i++)
    {
        if (value == fruit_array[i].value)
            return &amp;fruit_array[i];
    }
    return NULL;
}
</code></pre>

<p>This is OK because the pointer you return is to static data that will outlive the function.  If you tried to return a pointer to non-static data, you would (probably) have a bug on your hands, unless you used dynamic memory allocation (via <code>malloc()</code> et al).</p>

<p>You could also return the structure; handling the error return becomes harder.  If you've got C99, you can use a 'compound literal':</p>

<pre><code>static fruits_t getFruitFromValue(char value)
{
    int i;
    for (i = 0; i &lt; sizeof(fruit_array)/sizeof(fruit_array[0]); i++)
    {
        if (value == fruit_array[i].value)
            return fruit_array[i];
    }
    return (fruits_t){ .key = """", .value = 0 };
}
</code></pre>
",4
13742361,13742300,1,"<pre><code>sample = malloc(length);
</code></pre>

<p>is the right one</p>

<p><code>char*</code> is a pointer, a pointer uses 4 bytes (say on a 32-bit platform)</p>

<p><code>char</code> is a char, a char uses 1 byte</p>
",1
13742370,13742300,1,"<pre><code>sample = malloc ( length * sizeof(char) );
</code></pre>

<p>First is the correct one if you want to allocate memory for <code>length</code> number of characters.</p>

<p><code>char*</code> is of type pointer which happens to be 4 bytes on your platform. So <code>sizeof(char*)</code> returns 4. </p>

<p>But <code>sizeof(char)</code> is always 1 and smae is guaranteed by the C standard.</p>
",0
13742380,13742300,6,"<p>Assuming the goal is to store a string of <code>length</code> characters, the correct allocation is:</p>

<pre><code>sample = malloc(length + 1);
</code></pre>

<p>Notes:</p>

<ol>
<li>Don't use <code>sizeof (char)</code>, since it's always 1 it doesn't add any value.</li>
<li>Remember the terminator, I assumed (based on name) that <code>length</code> is the length in visible characters of the string, i.e. the return of <code>strlen()</code> will be <code>length</code>.</li>
<li>I know you didn't, but it's worth pointing out that there should be no <a href=""https://stackoverflow.com/a/605858/28169"">cast of the return value from <code>malloc()</code></a>, either.</li>
</ol>

<p>The reason <code>char *</code> is larger is that it's a pointer type, and pointers are almost always larger than a single character. On many systems (such as yours, it seems) they are 32 bit, while characters are just 8 bits. The larger size is needed since the pointer needs to be able to represent any address in the machine's memory. On 64-bit computers, pointers are often 64 bits, i.e. 8 characters.</p>
",7
13742401,13742300,2,"<blockquote>
  <p>Why does char* take 4 bytes when char takes 1 byte?</p>
</blockquote>

<p>Because you are on a 32-bit systems, meaning that pointers take four bytes; <code>char*</code> is a pointer.</p>

<p><code>char</code> always takes exactly one byte, so you do not need to multiply by <code>sizeof(char)</code>:</p>

<pre><code>sample = malloc (length);
</code></pre>

<p>I am assuming that <code>length</code> is already padded for null termination.</p>
",0
13742433,13742300,1,"<p>In the given cases you are doing two different things:</p>

<p>In the first case : <code>sample = malloc ( length * sizeof(char) );</code></p>

<p>You are allocating <code>length</code> multiplied by the size of type <code>char</code> which is <strong>1 byte</strong></p>

<p>While in the second case :  <code>sample = malloc ( length * sizeof(char*) );</code></p>

<p>You are allocating <code>length</code> multiplied by the size of pointer to <code>char</code> which is <strong>4 byte</strong> 
on your machine.</p>

<p>Consider that while case 1 remains immutable, on the second case the size is variable.</p>
",0
13742771,13742300,1,"<p>In your case, you want to alloc an array of length characters. You will store in <code>sample</code> a pointer to an array of <code>length</code> times the size of what you point to. The <code>sizeof(char*)</code> is the size of a pointer to <code>char</code>. Not the size of a <code>char</code>.</p>

<p>A good practice is </p>

<pre><code>sample = malloc(length * sizeof(*sample));
</code></pre>

<p>Using that, you will reserve length time the size of what you want to point to. This gives you the ability to change the data type anytime, simply declaring sample to be another kind of data.</p>

<pre><code>int *sample;

sample = malloc(length * sizeof(*sample)); // length * 4


char *sample;

sample = malloc(length * sizeof(*sample)); // length * 1
</code></pre>
",0
13742793,13742300,1,"<p>Provided the <code>length</code> already accounts for the nul terminator, I would write either:</p>

<pre><code>sample = malloc(length);
</code></pre>

<p>or:</p>

<pre><code>sample = malloc(length * sizeof(*sample));
</code></pre>

<p><code>sizeof(char*)</code> is the size of the pointer, and it is completely irrelevant to the the size that the allocated buffer needs to be. So definitely don't use that.</p>

<p>My first snippet is IMO good enough for string-manipulation code. C programmers know that memory and string lengths in C are both measured in multiples of <code>sizeof(char)</code>. There's no real need to put a conversion factor in there that everybody knows is always <code>1</code>.</p>

<p>My second snippet is the One True Way to write allocations in general. So if you want all your allocations to look consistent, then string allocations should use it too. I can think of two possible reasons to make all your allocations look consistent (both fairly weak IMO, but not actually wrong):</p>

<ul>
<li>some people will find it easier to read them that way, only one visual pattern to recognise.</li>
<li>you might want to use the code in future as the basis for code that handles wide strings, and a consistent form would remind you to get the allocation right when the <code>length</code> is no longer measured in bytes but in wide chars. Using <code>sizeof(*sample)</code> as the consistent form means you don't need to change that line of code at all, assuming that you update the type of <code>sample</code> at the same time as the units in which <code>length</code> is measured.</li>
</ul>

<p>Other options include:</p>

<pre><code>sample = calloc(length, 1);
sample = calloc(length, sizeof(char));
sample = calloc(length, sizeof(*sample));
</code></pre>

<p>They're probably fairly pointless here, but as well as the trifling secondary effect of zeroing the memory, <code>calloc</code> has an interesting difference from <code>malloc</code> that it explicitly separates the number and size of <em>objects</em> that you're planning to use, whereas <code>malloc</code> just wants the total size.</p>
",0
13743181,13742300,0,"<p>For any type <code>T</code>, the usual form is</p>

<pre><code>T *p = malloc(N * sizeof *p);
</code></pre>

<p>or</p>

<pre><code>T *p;
...
p = malloc(N * sizeof *p);
</code></pre>

<p>where <code>N</code> is the number of elements of type <code>T</code> you wish to allocate.  The expression <code>*p</code> has type <code>T</code>, so <code>sizeof *p</code> is equivalent to <code>sizeof (T)</code>.  </p>

<p>Note that <code>sizeof</code> is an <em>operator</em> like <code>&amp;</code> or <code>*</code>, not a library function; parentheses are only necessary if the operand is a type name like <code>int</code> or <code>char *</code>.  </p>
",0
8766257,8766241,3,"<p>The largest number that can be represented with a Standard C basic type is</p>

<p><code>LDBL_MAX</code> </p>

<p>defined in <code>float.h</code> and of <code>long double</code> type.</p>

<p><code>LDBL_MAX</code> value is implementation defined but has to be greater or equal to <code>1e+37</code>.</p>

<p>When <code>long double</code> type is used to represent <code>IEEE 754-2008</code> quadruple precision type (<code>binary128</code>), <code>LDBL_MAX</code> value is around <code>1.189731e+4932</code></p>
",0
8766260,8766241,0,"<pre><code>            #ifdef __18CXX
        typedef signed char int8_t;                 // -128 -&gt; 127               // Char &amp; Signed Char
        typedef unsigned char uint8_t;              // 0 -&gt; 255                  // Unsigned Char
        typedef signed short int int16_t;           // -32768 -&gt; 32767           // Int
        typedef unsigned short int uint16_t;        // 0 -&gt; 65535                // Unsigned Int
        typedef signed short long int int24_t;      // -8388608 -&gt; 8388607       // Short Long
        typedef unsigned short long int uint24_t;   // 0 -&gt; 16777215             // Unsigned Short Long
        typedef signed long int int32_t;            // -2147483648 -&gt; 2147483647 // Long
        typedef unsigned long int uint32_t;         // 0 -&gt; 4294967295           // Unsigned Long
        #else
        #   include &lt;stdint.h&gt;
        #endif
</code></pre>
",2
8766262,8766241,0,"<p>In 64-bit systems, the 64-bit unsigned integer data type can handle numbers up to <code>2^64-1</code>. This is much larger than <code>10*100</code> which is <code>1000</code>. However, I presume you mean <code>10^100</code>, which is far larger than any native integer data type in any practical architecture. To manipulate such data types you must use a <code>big integer</code> or <code>BigInt</code> data type.</p>
",0
8766280,8766241,0,"<p>It depends on the precision and accuracy you want for numbers that big.</p>

<p>You can trawl through <code>&lt;limits.h&gt;</code> which should have all the relevant constants.</p>
",0
10772667,10772653,0,"<p>Uppercase letters come before lowercase letters in ASCII. The first letter of your second string is a lower-case 't' with an ASCII value of 116. 'Z' on the other hand has an ASCII value of 90, thus <code>'t' &gt; 'Z'</code></p>

<pre><code>ASCII(Z) == 90
ASCII(a) == 97
ASCII(t) == 116
</code></pre>
",2
10772671,10772653,3,"<p>Please turn on your compiler warnings, you're not returning anything from that function in the default case.</p>

<pre><code>return only_letters(string, index+1);
</code></pre>

<p>Other problem is that you've got your range inverted. Capital letters have lower ASCII values than lowercase ones.</p>

<p>And <code>main</code> must return <code>int</code>. Not <code>void</code>.</p>
",0
10772680,10772653,0,"<p>try:</p>

<pre><code>return only_letters(string, index+1); 
</code></pre>
",0
10772730,10772653,1,"<p>This line has problems too:</p>

<pre><code>if(string[index]&lt;'a'||string[index]&gt;'Z') return -1;
</code></pre>

<p>In the ASCII table, upper case letters come first, followed by several non-letter symbols, then the lower case letters. That line should look more like:</p>

<pre><code>char l = string[index];
if(!((l &gt;= 'A' &amp;&amp; l &lt;= 'Z') || (l &gt;= 'a' &amp;&amp; l &lt;= 'z'))) return -1
</code></pre>
",0
11492738,11492714,4,"<blockquote>
  <p>How was the first C compiler generated, since C compiler is written in C itself then how was the first source of C compiler generated?</p>
</blockquote>

<p><a href=""https://stackoverflow.com/questions/13537/bootstrapping-a-language"">Bootstrapping.</a></p>
",0
11175536,11175473,0,"<p>Your argument is</p>

<pre><code>int *ary[]
</code></pre>

<p>and in function arguments, array decay to pointers. So you basically have</p>

<pre><code>int** ary
</code></pre>

<p>You then set the pointer at index 0, <em>presumably</em> a valid index, to the value of a single variable.</p>

<pre><code>ary[0]=&amp;i;
</code></pre>

<p>Then your code prints</p>

<pre><code>ary[0][1]
</code></pre>

<p>which is basically</p>

<pre><code>( &amp;i )[1]
</code></pre>

<p>triggering <em>undefined behavior</em>, hence whatever result you get is a valid result.</p>
",2
11175537,11175473,3,"<p>In both code samples <code>ary[0]</code> is a pointer to a single integer. So when you do <code>array[0][1]</code> you're accessing that pointer out of bounds. So the behavior of both of your code samples is undefined.</p>

<p>The reason that you're getting the behavior you're seeing on your particular compiler is probably, that all the variables whose address you don't take are stored in registers and not in memory (or possibly they aren't stored at all because you never use them).</p>

<p>So in example 1 the only variables in memory are i and k. And in example 2 the only variables in memory are i and b. So in example 1 <code>k</code> is the variables that comes directly after <code>i</code> in memory and example 2 that variable is <code>b</code>.</p>
",0
15523470,15522401,1,"<p>This depends on how your <code>struct</code> is defined, whether or not you want your output to be human-readable, and whether or not the output file is meant to be read on a different architecture. </p>

<p>The <code>fwrite</code> solution that others have given will write the <em>binary representation</em> of the struct to the output file.  For example, given the code below:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
  struct foo {
    int x;
    char name1[10];
    char name2[10];
  } items[] = {{1,""one"",""ONE""}, {2,""two"",""TWO""}};

  FILE *output = fopen(""binio.dat"", ""w"");

  fwrite( items, sizeof items, 1, output );

  fclose( output );
  return 0;
}
</code></pre>

<p>if I display the contents of <code>binio.dat</code> to the console, I get the following:</p>

<pre>
john@marvin:~/Development/Prototypes/C/binio$ cat binio.dat
oneONEtwoTWOjohn@marvin:~/Development/Prototypes/C/binio$ 

john@marvin:~/Development/Prototypes/C/binio$ od -c binio.dat
0000000 001  \0  \0  \0   o   n   e  \0  \0  \0  \0  \0  \0  \0   O   N
0000020   E  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0
0000040  \0  \0  \0  \0 002  \0  \0  \0   t   w   o  \0  \0  \0  \0  \0
0000060  \0  \0   T   W   O  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0  \0
0000100  \0  \0  \0  \0  \0  \0  \0  \0
0000110
</pre>

<p>The integer values show up as garbage (not reproduced above) because they've been stored as the byte sequences 01, 00, 00, 00 and 02, 00, 00, 00 (x86 is little-endian), which are not printable characters.  Also note that all 10 characters of <code>name1</code> and all 20 characters of <code>name2</code> are written to the file, which may or may not be what you want.</p>

<p>The situation gets even more complicated if your struct contains pointers, because what gets stored to the file is the pointer value, not the thing being pointed to:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
  struct foo {
    int x;
    char *name1;
    char *name2;
  } items[] = {{1,""one"",""ONE""}, {2,""two"",""TWO""}};

  FILE *output = fopen(""binio.dat"", ""w"");

  fwrite( items, sizeof items, 1, output );

  fclose( output );
  return 0;
}
</code></pre>

<p>This time I get</p>

<pre>
john@marvin:~/Development/Prototypes/C/binio$ cat binio.dat
????????john@marvin:~/Development/Prototypes/C/binio$ 

john@marvin:~/Development/Prototypes/C/binio$ od -c binio.dat
0000000 001  \0  \0  \0 260 205 004  \b 264 205 004  \b 002  \0  \0  \0
0000020 270 205 004  \b 274 205 004  \b
0000030
</pre>

<p>Note that none of the strings appear in the file at all; if you read this file in with a different program, all it will see are (most likely) invalid addresses.  </p>

<p>If you want your output to be human-readable <em>and</em> you want to be able to read those values in on a different architecture, you almost have to go with formatted output, meaning you have to write each member separately:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
  struct foo {
    int x;
    char *name1;
    char *name2;
  } items[] = {{1,""one"",""ONE""}, {2,""two"",""TWO""}};

  FILE *output = fopen(""binio.dat"", ""w"");
  int i;
  for (i = 0; i &lt; sizeof items / sizeof items[0]; i++)
  {
    fprintf(output, ""%d %s %s\n"", items[i].x, items[i].name1, items[i].name2);
  }
  fclose( output );
  return 0;
}
</code></pre>

<pre>
john@marvin:~/Development/Prototypes/C/binio$ cat binio.dat
1 one ONE
2 two TWO
</pre>

<p>You can certainly wrap that operation in a function of your own, something like</p>

<pre><code>int printFoo( FILE *output, const struct foo item )
{
  return fprintf( output, ""%d %s %s\n"", item.x, item.name1, item.name2);
}
</code></pre>

<p>but in the end, that's about as simple as it gets.</p>

<p>The <code>fwrite</code> solution works great if you're not concerned about readability and portability, but you still have to be careful if you have any pointer members within the struct.  </p>
",0
15522483,15522401,4,"<p>C doesn't have ""instructions"".</p>

<p>You should be able to use a single function call, such as:</p>

<pre><code>fwrite(&amp;mystructure, sizeof mystructure, 1, myfile);
</code></pre>

<p>But this isn't without drawbacks:</p>

<ol>
<li>This makes the file-format depend on your current CPU and compiler, which is often a bad idea; it will make it very hard to preserve interoperability.</li>
<li>The write might partially succeed; you need to wrap it in a loop for that case.</li>
</ol>
",0
9831659,9831575,0,"<p>What you are looking for is a maximum-<a href=""http://en.wikipedia.org/wiki/Priority_queue"" rel=""nofollow"">priority-queue</a>, which is normally implemented using a <a href=""http://en.wikipedia.org/wiki/Heap_%28data_structure%29"" rel=""nofollow"">heap data structure</a>.</p>

<p>The priorities of elements in the queue would be <code>&lt;your key, insertion order&gt;</code>, with <code>your key</code> part having more priority over <code>insertion order</code>.</p>
",3
11516228,11515966,0,"<p>To convert a string into integer there are already available functions one such function is 
strtoul().</p>

<p>you can use standard strtoul() function to convert string into integer values.</p>
",0
11515983,11515966,2,"<p>If you know for a fact that the value is stored with the same endianness as the host OS architecture, you can just do:</p>

<pre><code>int value = *(int *)tmp;
</code></pre>

<p>However, you should <em>not</em> read the bytes in backwards order, as you do here -- that alters the endianness and will result in an incorrect value.  Try this:</p>

<pre><code>int value;
if (fread(&amp;value, sizeof(value), 1, fp) != 1) {
    /* Could not read, handle error. */
}

/* value is set, inspect it */
</code></pre>
",4
16381089,9045436,21,"<p>There is no difference between the two in how they are stored in memory and registers, there is no signed and unsigned version of int registers there is no signed info stored with the int, the difference only becomes relevant when you perform maths operations, there are signed and unsigned version of the maths ops built into the CPU and the signedness tell the compiler which version to use.</p>
",1
9784284,9764890,-1,"<p>Try the code below for dynamically deciding the array size and assigning the values:-</p>

<pre><code>int **arr;
int *greatest_each_lavel;
int n, i, j, temp;
printf (""enter the level.\n"");
scanf (""%d"", &amp;n);

if (n&lt;1)
{
  printf (""Wrong input.\n"");
  exit (1);
}
greatest_each_level = (int *) malloc (n * sizeof (int));
arr = (int **) malloc (n * sizeof (int *));
for (i=1; i&lt;=n; i++)
{
  arr[i] = (int *) malloc (i * sizeof (int));
}
// Populate the array members.
for (i=0; i&lt;n; i++)
{
  temp = 0;
  for (j=0; j&lt;=i; j++)
  {
    printf (""Enter the number  "");
    scanf (""%d"", &amp;arr[i][j]);
    if (arr[i][j] &gt; k)
    {
      temp = arr[i][j];
    }
  }
  greatest_each_level[i] = temp;
}

// To get the sum of greatest number at each level
int sum = 0;
for (i = 0; i &lt; n; i++)
  sum = sum + greatest_each_level[i];
printf (""Sum is : %d\n"", sum);

// When all task are done, dont forget to free the memory.
for (i=0; i&lt;n; i++)
{
  free (arr[i]);
}
free (arr);
free (greatest_each_level);
greatest_each_level = NULL;
arr = NULL;
</code></pre>
",0
17771107,17771082,10,"<p>It's just a way of accessing a memory-mapped register at a fixed address <code>0xF0250</code>. You can access individual bits of the registers via the <code>BIT</code> field of the union, or the whole 8 bit register via the <code>trmgr</code> field. The <code>#define</code> just gives you convenient access to the latter, so that you can write, e.g.</p>

<pre><code>TRMGR = 0x3f; // write 0x3f to timer manager register
</code></pre>

<p>Note the use of <code>volatile</code> - this is a common technique with memory-mapped I/O registers to ensure that reads/writes always occur as intended and are not optimised away (as they might be with normal memory locations).</p>
",2
18241415,9624931,5,"<p>The clue is that you receive <em>i</em>, <em>j</em> but <strong>it does not say that i &lt; j for all the cases</strong>, check for that condition in your code and remember to always print in order:</p>

<pre><code>&lt;i&gt;[space]&lt;j&gt;[space]&lt;count&gt;
</code></pre>
",0
10162842,10161184,2,"<p>Line 85 in the paste:</p>

<pre><code>fseek(*f,i,0);// set a position in file
</code></pre>

<p>as suspected by @unwind.</p>
",0
19258850,19258809,2,"<p>You're passing <code>&amp;intp</code> (a <code>float *</code>) to a parameter requiring a <code>double *</code>.  That causes undefined behaviour.  You need to use <code>modff</code>:</p>

<pre><code>fracp = modff(x,&amp;intp);
</code></pre>

<p>or make <code>intp</code> a <code>double</code> instead:</p>

<pre><code>double intp;
</code></pre>

<p>And you'll be fine.</p>

<p>You should turn on more warnings in your compiler.  For example, even with no special flags, clang gives:</p>

<pre><code>example.c:9:20: warning: incompatible pointer types passing 'float *' to
      parameter of type 'double *' [-Wincompatible-pointer-types]
    fracp = modf(x,&amp;intp);
                   ^~~~~
/usr/include/math.h:400:36: note: passing argument to parameter here
extern double modf(double, double *);
                                   ^
1 warning generated.
</code></pre>

<p>For your program.</p>

<p>Check out the <a href=""http://www.manpagez.com/man/3/modf/"" rel=""nofollow""><code>modf</code> and <code>modff</code> man page</a> to see where you went wrong.</p>
",0
16930691,16930674,5,"<p>It's a symbol defined using <code>#define</code>. Search through the code to find where it's defined. The actual return type of your function is <code>XnStatus</code>, while <code>XN_C_API</code> is likely defined to be a set of modifier. These are typically used to define exported symbols or other attributes for functions that have the particular attribute.</p>

<p>For example, in my code (a DLL project on Windows), I have this:</p>

<pre><code>#ifdef MGR_EXPORTS
    #define MGR_API __declspec(dllexport)
#else
    #define MGR_API __declspec(dllimport)
#endif

...

#define MGRAPI StatusCode __declspec(nothrow) WINAPI
</code></pre>

<p>All the public (exported) function declarations look like this:</p>

<pre><code>MGR_API MGRAPI MgrInit ()
</code></pre>

<p>The first symbol <code>MGR_API</code> is used to control how symbols are exported from the DLL; the other, <code>MGRAPI</code> helps declare all public functions with the same set of modifiers and the same return type (which is <code>StatusCode</code>).</p>

<p>If there's ever a need to update the declaration of all public functions in this project it's easy because only the defined symbols need to be changed and all functions take the change right away.</p>
",3
16930739,16930674,3,"<p>Is defined like this</p>

<pre><code>#define XN_C_API   XN_C_API_IMPORT
#define XN_C_API_IMPORT XN_API_IMPORT
#define XN_API_IMPORT   __declspec(dllimport)
</code></pre>

<p><code>__declspec(dllimport)</code> means that the function is imported from a DLL file.</p>
",1
10777608,10777566,2,"<p>The end goal is not completely clear to me, but you can specify an integer in hex format:</p>

<pre><code>uint32_t val = 0x11111111;
</code></pre>

<p>And as noted in the comments, the hex representation can be printed out with the <code>printf</code> family of functions using <code>%x</code> (or <code>%X</code>) as the format specifier. From what I can gather from the OP, that might be what you are looking for, but I'm not completely sure.  </p>

<p>Edit in response to the OP edit:  It's not completely clear what you mean by casting to <code>char*</code>.  If you mean you want to cast the address of <code>val</code> to char* (e.g., <code>char *ptr = (char*)&amp;val;</code>), then that should work fine and allow you to access the individual bytes.</p>
",6
11096824,11096730,2,"<blockquote>
  <p>He says they are ""both 4-byte figures""</p>
</blockquote>

<p>This may well be true on a particular platform, but neither is guaranteed to be the case in general.</p>

<blockquote>
  <p>But I don't get how you could do the same thing by casting it to an unsigned long* because the arithmetic will be in units of 4. What am I missing?</p>
</blockquote>

<p>He is not casting to <code>unsigned long*</code>, he is casting to <code>unsigned long</code>.</p>
",2
11096952,11096730,0,"<p>The statement may be true on that professor's particular machine on a particular Tuesday of last year, but in general, it's wrong. If <code>char *</code> and <code>unsigned long</code> could be treated the same, C wouldn't need two distinct types.</p>

<p>What the professor probably wanted to say is the following rule:</p>

<p>For a variable of any pointer type (except <code>void</code> pointers), the following holds: <code>p + 1 == (T*) (((char*)p) + sizeof(*p))</code> (where <code>T</code> is the type of <code>*p</code>), i.e. adding 1 to a pointer increases it by the size of the type that it points to.</p>

<p>Since <code>sizeof(char) == 1</code>, <code>x+1</code> will have the same value if <code>x</code> is of type <code>char *</code> or <code>unsigned long</code>, given that <code>sizeof(char *) == sizeof(unsigned long)</code>, which is not to assume unless ""you know what you're doing"".</p>

<p>Note that the actual representation might differ for various reasons, most notably since <code>unsigned long</code> may have padding bits anywhere in its representation.</p>
",1
9801259,9801210,5,"<p>In this expression <code>a-b</code>, integer promotions will apply which mean that <code>a</code> and <code>b</code> are likely to be promoted to <code>int</code> and the result of the expression will also be <code>int</code> which is why you get the warning when comparing against <code>8U</code> which has type <code>unsigned int</code>.</p>

<p>The promotion would only be to <code>unsinged int</code> rather than <code>int</code> if <code>int</code> couldn't hold all the values of <code>unsigned short</code> which would only happen on platforms where <code>int</code> was the same size as <code>short</code>.</p>

<p>When comparing against <code>(unsigned char)8U</code>, the <code>unsigned char</code> will also be promoted to <code>int</code> which is why the warning doesn't happen in this case.</p>
",2
9801281,9801210,0,"<p>(a-b) doesn't guarantee it's unsigned since b can be bigger than a.</p>

<p>That's why you are getting the warning</p>
",1
11538079,11537658,1,"<p>The problem here is that you are returning a pointer to a local variable, which is <em>undefined behavior</em>. When <code>build_up_sql</code> returns, the space on the stack for the local variables are reused.</p>

<p>The best solution is probably to add a parameter to <code>build_up_sql</code> that you use to put the string in. Something like:</p>

<pre><code>char *build_up_sql(char *inputName, char *inputMessage, char *outputSql)
{
    const char firstPartStatement[] = ""INSERT INTO User (name, msg) VALUES ("";
    const char endPartStatement[] = "");"";
    const char lightener[] = ""'"";

    strcpy(outputSql, firstPartStatement);
    strcat(outputSql,lightener);
    strcat(outputSql,inputName);
    strcat(outputSql,lightener);
    strcat(outputSql,"","");
    strcat(outputSql,lightener);
    strcat(outputSql,inputMessage);
    strcat(outputSql,lightener);
    strcat(outputSql,endPartStatement);

    return outputSql;
}

void create_input(sqlite3 *handler, char *inputName, char *inputMessage)
{
    char sql[1024];

    char *sqlstr = build_up_sql(inputName, inputMessage, sql);

    printf(""%s\n"", sqlstr);
    sqlite3_exec(handler, sqlstr, NULL, NULL, NULL);
}
</code></pre>
",3
18148245,18147911,0,"<p>Change </p>

<pre><code>while( scanf(""%d"",&amp;n) == 1)
    koaneeye();
</code></pre>

<p>to </p>

<pre><code>if( scanf(""%d"",&amp;n) == 1)
    koaneeye();
else
  while(n)
  {}
</code></pre>
",0
18148051,18147911,5,"<p>The printf statement is called one too many times.  You need to stop execution in the case that you didn't read data.  Since you are using recursion anyway, you don't need to loop:</p>

<pre><code>if( scanf(""%d"",&amp;n) != 1) return;
koaneeye();
</code></pre>
",0
18148065,18147911,1,"<p>The innermost call is terminated with an invalid input.</p>

<p>If you detect this, you refrain from calling <code>koaneeye()</code> again, but nevertheless you continue processing that data.</p>

<p>As well, I think an <code>if</code> is sufficient here, because the iteration is ""self-repeating"".</p>

<p>So you should do</p>

<pre><code>if (scanf(""%d"",&amp;n) == 1) {
    // Succeeded in reading a value - call next before us.
    koaneeye();
} else {
    return; // refrain from processing bogus input from above.
}

while(n)
...
</code></pre>
",0
10150589,10150507,1,"<p>How about <code>a ^ b ^ c</code>?</p>

<p>If only basic logic operators are allowed, you can use this</p>

<pre><code>((a &amp;&amp; b || !c) || (!a &amp;&amp; !b || !c)) &amp;&amp; (!a || !b || c) &amp;&amp; (a || b || c)
</code></pre>

<p>as dbaupp commented, just equivalent transformation.</p>
",3
10026686,10020954,-1,"<pre><code>#define Zero '0'
#define Nine '9'

void MyFNatoi(char *numArray, int *value) {

    int i;
    *value = 0;
    for (i = 0; i &lt; 10 &amp;&amp; numArray[i] != 0; i++) {
        if (numArray[i] &gt;= Zero &amp;&amp; numArray[i] &lt;= Nine) {
            *value = *value * 10 + (numArray[i] - Zero);
        }
    }

}
</code></pre>
",0
10110856,10110687,0,"<p>Change </p>

<pre><code>char lastName[100];
char firstName[100];
</code></pre>

<p>to </p>

<pre><code>char lastName[100][100];
char firstName[100][100];
</code></pre>

<p>Also while reading <code>empID[i]</code> don't use <code>%[^:]</code>, use <code>%d</code> instead.</p>
",2
10110792,10110687,1,"<p>Your argument parameters are wrong for the strings:</p>

<pre><code>fscanf(employeesTXT, ""%[^:]:%[^:]:%[^:]:%d:%lf\n"",
    &amp;empID[i], lastName[i], firstName[i], &amp;payGroup[i], &amp;hoursWorked[i])
</code></pre>

<p><code>lastName</code> and <code>firstName</code> are declared as an array of 100 <code>char</code>.  You want those to be strings so you need to define them to be an array of 100 ""buffers"".</p>

<p>Try changing the declarations to:</p>

<pre><code>char lastName[100][50]; /* 50 or whatever the max length you'd expect + 1 */
char firstName[100][50];
</code></pre>

<p>I believe that should work just like that.</p>

<p>You also have a different issue with <code>empID</code>, you're reading the value as a string and not an integer.  In the format, it should be <code>%d</code> for integers if these are indeed integers in your input.</p>
",4
10110795,10110687,-1,"<p>You need to have addresses as parameters for <code>fscanf</code>, this won't work as parameter as it is only a character:</p>

<pre><code>   lastName[i]
</code></pre>
",5
10111318,10110687,0,"<p>As pointed out, for the names you are assigning each new employees' information into an one dimensional array, thereby overwriting the previous employee's information (except the first character). This eventually leads to your error when you try to assign a long enough name to an index near the end of your array which causing it to write over the last index. You can use a two dimensional array as suggested for the names:</p>

<p><code>char lastname[number_of_employees][maximum_length_of_name];</code></p>

<p>and each lastname[i] will be a null terminated string. </p>

<p>But, this is what structures are made for. </p>

<pre><code>// Define it before main()
struct employee_type{
    int empID;
    char *lastname;
    char *firstname;
    int paygroup;
    double hoursworked;
}

// In main()
struct employee_type employees[100]; // Declare an array of employee_type structures.
</code></pre>
",1
10133283,10132459,4,"<p>You are missing the <code>break;</code> statements in the <code>switch(face)</code> after each <code>case:</code> block of code. Without the <code>break;</code> statements, your code will fall through to each of the next <code>case:</code>, which is not what you want.</p>
",1
10132613,10132459,3,"<p>I think you've got your directions wrong.   You should be starting at <code>maze[2][0]</code>, with facing '6'.  You want to advance to <code>maze[2][1]</code>, with facing still '6'.  But if you look at the <code>mazeTraversal</code> code for direction 6, you get this case:</p>

<pre><code>if(maze[y][x+1] == "".""){     
   maze[y][x+1] = ""x"";     
   face = 8;
 }
</code></pre>

<p>So you are setting the resulting direction incorrectly.<br>
One thing that might help keep it straight is to use an enumeration instead of random numeric codes:</p>

<pre><code>enum Facing {
   face_EAST,
   face_SOUTH,
   face_WEST, 
   face_NORTH } face = face_EAST;
</code></pre>

<p>I might even forget about compass directions and use directions specific to the problem.  That should help keep the direction straight in the code.</p>

<pre><code>enum Facing {
   face_Xplus,
   face_Yplus, 
   face_Xminus, 
   face_Yminus } face = face_Xplus;
</code></pre>
",1
11816139,11816121,1,"<p>The result of <code>i++</code> is not a lvalue and the standard requires the left operand of the assignment operator to be a lvalue.</p>

<p>Even if it was allowed your program would invoke undefined behavior as you are trying to modify the same object twice between two sequence points.</p>
",3
11816148,11816121,0,"<p>It indicates that <code>i++</code> is not assignable. It is like trying to assign to <code>1</code> (which <code>i++</code> will yield when <code>i</code> stored the value <code>1</code>). </p>

<p>Of course that makes no sense. You can compare it to trying to change the color ""red"", when you actually wanted to first paint your paper red and then blue. </p>
",0
11816169,11816121,0,"<p>It's saying left value required. You are doing an assignment left = right. i++ can't be a left because it's a right.
Remove the terseness and your line of code sort of becomes</p>

<p>i + 1 = i + 1, which is an equation not an assignment.</p>

<p>On top of that what are you actually trying to do?</p>
",0
10183901,10183670,1,"<p>you end up  incrementing <code>i</code> i.e <code>i++</code>  twice if <code>addr1[i] == addr2[i]</code> also the <code>else</code> block is a suspect i guess what you need is </p>

<pre><code>for(i=0; i&lt;4; i++) {
   if(addr1[i]!=addr2[i]) {;
     return 1;
   }
}
return 0;
</code></pre>
",0
9836055,9836021,0,"<p>You could use <a href=""http://man.cx/isdigit"" rel=""nofollow"">isnum</a> to check the individual strings, or just call <a href=""http://man.cx/strtol"" rel=""nofollow"">strtol</a>/atoi and check if errno was set to EINVAL.</p>

<p><a href=""http://linux.die.net/man/3/strtol"" rel=""nofollow"">http://linux.die.net/man/3/strtol</a></p>
",2
9836074,9836021,1,"<p>Have you tried Regular expressions.</p>

<p>While reading, check with a regex filter, then use conditional statement. If regex is satisfied (i.e. input is an integer). then complete the reading process, else move to next input.</p>
",3
9836936,9836021,0,"<p>My idea would be to proceed char-by-char to find each integer. Handle negative numbers (proceeded by a '-') with a negative flag.</p>

<pre><code>//pseudo-code
int negative = 0;
int curdigit = 0;
char c = '\0';
while((c = getchar())) //pseudo-function, get the next character from the stream (i.e fgetc)
{
    if (c &gt;= '0' &amp;&amp; c &lt;= '9')
    {
        curdigit = (c - '0');
        if (negative)
            curdigit *= -1; //can just do this bitwise, but im lazy.
        //do something with the current digit.
        negative = 0; //negative cannot persist for more than 1 iteration.
    }
    else if (c == '-')
    {
        negative = 1;
    }   
    else { negative = 0; }
}
</code></pre>
",0
9836501,9836021,1,"<p>Are the numbers all single-digit? In that case, you could read character by character with getc, use isdigit to see if it is a digit, and if so process it.</p>

<p>Can the numbers have more than one digit? In that case, you could use something similiar, but when you get to a digit, put it back in the stream with ungetc, and read the number with fscanf(..., ""%d"", ....).</p>

<p>I know that the usual advice is to read line by line with fgets and then parse the data from that line, and I agree that with input directly from the user this is probably the best way. But for reading a file like this I think it is overkill, and simpler solutions can, and often should, be used.</p>
",0
19576549,19576468,5,"<p><code>float</code> has less precision than <code>double</code>, which would be the default type used for floating point literals. Since <code>6.7</code> cannot be represented with a finite number of binary digits, the less precise <code>float</code> representation does not equal the <code>double</code> representation.</p>
",0
19576574,19576468,4,"<p><code>6.7</code> is a double, so when you say <code>a=6.7</code> you're truncating a double to a float.</p>

<p>Because floating point numbers are stored in base 2, not base 10, it's impossible to represent 6.7 with complete precision. So when being truncated to a float, you lose a bit of information in this case. The same does not happen with 8.5, because 8.5 CAN be stored with complete precision in base 2.</p>

<p>Then, when you compare (<code>a==6.7</code>), you're comparing the different representations, which - as explained above - are not equal.</p>
",0
19576578,19576468,4,"<p>Unsuffixed floating point literals are of type <code>double</code>, not of type <code>float</code>.</p>

<pre><code>6.7    /* double */
6.7f   /* float  */
</code></pre>
",0
19576607,19576468,3,"<p>Representation of floating point numbers in computers have limiting accuracy. You should never use simple <code>==</code> to compare two floating point numbers. Instead you can use </p>

<p><code>if(fabs(a-6.7) &lt; epsilon</code>) where <code>epsilon</code> is some small enough number but not smaller than the accuracy of the computer FP numbers representaiton (e.g. FP32 for <code>float</code> or FP64 for <code>double</code>).</p>

<p><strong>Edit</strong>: As pointed out in the discussion below, <em>never use</em> should be rephrased to <em>it is not advisable</em>. See the discussion for the details, may be of use for people who use floating point often in their programs. Also the section <em>Accuracy problems</em> at <a href=""http://en.wikipedia.org/wiki/Floating_point"" rel=""nofollow"">this link</a> may be important to keep in mind.</p>
",8
9865428,9865338,-1,"<p>I go through your code and one thing seems to be weird. If i understand clearly, each table correspond to a skater.</p>

<p>For each row you have a base, some score and a total score.
In your print function we can clearly see that:</p>

<p>skater[i].baseval[j] print the base val for skater i and row j</p>

<p>Then the score list is displayed with skater[i].score[j][k] where k is the score index in the array.</p>

<p>However when printing the total score you display skater[i].total_score which is a unique value. So it is normal that is the same for each row of the table for one given skater.</p>

<p>If you want a total score for each row, you just have to transform skater[i].total_score to an array then compute the total score and add it to the righ row (like you did for the base score)</p>

<p>Edit: changed wrong variable name</p>

<p>Regards</p>
",4
9827661,9827560,3,"<p>you can define your own comparator to sort <a href=""http://www.cplusplus.com/reference/clibrary/cstdlib/qsort/"" rel=""nofollow"">http://www.cplusplus.com/reference/clibrary/cstdlib/qsort/</a></p>

<p>So to sort integers you would use</p>

<pre><code>int intcomp(void *a, void *b){
  int *_a = (int *)a;
  int *_b = (int *)b;

  if(*_a &gt; *_b) return -1;
  if(*_a == *_b) return 0;
  return 1;
}
</code></pre>

<p>I think you can make your own comparator function from that.</p>
",2
9827704,9827560,3,"<p>There's an example in the man page of <code>qsort</code></p>

<pre><code>static int
cmp(const void *p1, const void *p2)
{
        int y1 = ((const struct dates*)p1)-&gt;year;
        int y2 = ((const struct dates*)p2)-&gt;year;

        if (y1 &lt; y2)
            return -1;
        else if (y1 &gt; y2)
            return 1;

        /* years must be equal, check months */
        ...
}
</code></pre>

<p>and then</p>

<pre><code>qsort(dates, total, sizeof(*dates), cmp);
</code></pre>
",1
9806592,9806555,2,"<p>It works if you press <code>CTRL+Z</code> and then enter. This triggers <code>EOF</code>.</p>

<p>If you want it to end when you press enter, use</p>

<pre><code>while( getchar() != '\n' )
</code></pre>
",0
9806626,9806555,0,"<p>try calling <code>your.exe &lt; your_input.file</code> or just press <code>Ctrl+Z</code> and then <code>Enter</code> to get <code>EOF</code></p>
",0
9806629,9806555,-2,"<p>because while getchar() is an infinite loop.</p>

<p>So you never exit the loop untile you kill the process.</p>
",2
9806644,9806555,1,"<p>Is your sample compiled with UNICODE=1? You have to compare against WEOF then.</p>
",0
20022142,9806555,1,"<p>You can use ^D to provide EOF signal to your program.
Many time ^Z doesn't works.</p>
",0
20630334,20630195,1,"<p>k is a number of dimensions. Variable axis will contain an axis along which the space will be divided.</p>
",0
20630625,20630195,1,"<p><code>k</code> is the dimension of the tree. You will have to repeatedly divide the set of points along each direction one by one.
Here <code>depth</code> represents the level of a tree. Now as you go down each level, you have to move to next axis, and when you are done with the last axis (i.e. kth dimension) you will start again from 1st dimension (or in this case, from (k-1) to 0th dimension). Hence the next axis is chosen as <code>depth mod k</code></p>
",0
11823089,11822206,0,"<p>In C, enum type is similar to signed integer data type. This is how you should use the <code>cvmx_fau_reg_64_t</code>:</p>

<pre><code>cvmx_fau_reg_64_t myRegister;

myRegister=CVMX_FAU_REG_64_START;

//Do something with the *myRegister* variable

myRegister=CVMX_FAU_REG_64_END;
</code></pre>
",0
9807240,9807168,3,"<p><a href=""http://www.gnu.org/software/libc/manual/html_node/Complex-Numbers.html"" rel=""nofollow"">C99 introduces support for complex numbers</a>.  Whether or not your compiler implements this feature I don't know.</p>
",0
9807410,9807168,2,"<p>In general, you cannot represent real numbers in C. There are an infinite number of real numbers, but C has only finite precision in its calculations. That said, ISOC99 has a data type to do operations on Complex numbers within those bounds. <a href=""http://www.gnu.org/software/libc/manual/html_node/Complex-Numbers.html"" rel=""nofollow"">http://www.gnu.org/software/libc/manual/html_node/Complex-Numbers.html</a></p>

<p>The C99 complex numbers are fairly limited- it really only provides a way to multiply by <code>i</code>. CMATH provides some excellent extensions with much more functionality than C99. <a href=""http://www.optivec.com/cmfuncs/"" rel=""nofollow"">http://www.optivec.com/cmfuncs/</a> </p>
",2
9807716,9807168,1,"<p>Section 7.3 in the <a href=""http://www.open-std.org/JTC1/sc22/wg14/www/docs/n1256.pdf"" rel=""nofollow"">C99 Standard</a> (or <a href=""http://www.open-std.org/JTC1/sc22/wg14/www/docs/n1570.pdf"" rel=""nofollow"">C11 Standard</a>) deals with complex numbers.</p>

<p>Example code</p>

<pre><code>#include &lt;complex.h&gt;
#include &lt;stdio.h&gt;

int main(void) {
    double A, b, c, D, e, f;
    complex double x;
    const complex double i = csqrt(-1);

    A = 1;
    b = 2;
    c = 3;
    D = 4;
    e = 5;
    f = 6;
    x = A * cexp(i * (b + c)) + D * cexp(i * (e + f));
    printf(""value is %f + %fi\n"", creal(x), cimag(x));
}
</code></pre>

<p>You can see the code running at ideone: <a href=""http://ideone.com/d7xD7"" rel=""nofollow"">http://ideone.com/d7xD7</a></p>

<p>The output is</p>

<pre>value is 0.301365 + -4.958885i</pre>
",0
11103658,11103620,3,"<p><strong>First, your <code>mystrlen</code> has an infinite loop.</strong></p>

<p>Fixed code:</p>

<pre><code>int mystrlen(const char *s)
{
    int len = 0;
    while (*s++ /* increment to next character every loop */ != '\0')
    {
        len++;
    }
    return len;
}
</code></pre>

<p>Also added <code>const</code> since you never change the data referred to by <code>*s</code></p>

<p><strong>Second, the assignment: <code>char arr=""Hi"";</code> is not valid.</strong></p>

<p>You are attempting to assign a <code>char[]</code> array to a <code>char</code> variable. The correct form would be <em>one</em> of the following:</p>

<pre><code>char arr[]=""Hi""; // array syntax
char *arr=""Hi"";  // pointer syntax
</code></pre>

<p>Given your invalid <code>arr</code> assignment, your runtime error is most likely caused by <code>mystrlen</code> attempting to incorrectly deference <code>arr</code>.</p>

<p><em>What compiler are you using? Most conforming compilers should have caught the second issue. If using GCC, add the <code>-Wall</code> flag to your makefile.</em></p>
",4
11103663,11103620,1,"<p>This:</p>

<pre><code>char arr=""Hi""; /* Should have caused compiler warning,
                  as is attempting to assign a char
                  to a char[3]. */
</code></pre>

<p>should be:</p>

<pre><code>char arr[] =""Hi"";
</code></pre>

<p>or:</p>

<pre><code>char* arr = ""Hi"";
</code></pre>
",0
10770166,10770149,5,"<p>Your matrices are too big for the stack on your machine.  Each of the arrays has 4 million integers, or roughly 16 MiB of storage; that is a very big stack requirement.</p>

<p>Either reduce their size or allocate them dynamically.</p>

<p>Or (as noted in the comments), make them into variables with 'static duration', either within <code>main</code> with the keyword <code>static</code> in front:</p>

<pre><code>int main(int argc, char *argv[])
{
    int row1, row2, col1, col2, i, j, cnt=0;
    static int mat1[2000][2000], mat2[2000][2000];
</code></pre>

<p>or as file scope variables defined outside <code>main()</code>, also with the keyword <code>static</code> in front:</p>

<pre><code>static int mat1[2000][2000], mat2[2000][2000];

int main(int argc, char *argv[])
{
    int row1, row2, col1, col2, i, j, cnt=0;
</code></pre>

<p>or as global variables defined outside <code>main()</code> without the keyword <code>static</code> (but only do this if you will have multiple source files that need to access them by name):</p>

<pre><code>int mat1[2000][2000], mat2[2000][2000];

int main(int argc, char *argv[])
{
    int row1, row2, col1, col2, i, j, cnt=0;
</code></pre>

<p>You could also (again, as noted in the comments) increase the stack size.  However, I respectfully suggest that is probably the least satisfactory solution.</p>

<blockquote>
  <p>How to dynamically allocate the size of an array?</p>
</blockquote>

<p>Fair question.  How often do you think you'll really need a pair of 4 million cell arrays, compared with how often will you be dealing with, say, under 100x100 arrays?  Also, are you on Windows (with MSVC and C89) or non-Windows (with C99 or later), or on Windows with GCC?</p>

<p>Also, have you learned about pointers yet?</p>

<p>On the whole, I think you should opt for smaller size arrays.  That is by far the simplest solution.  If you must have big arrays, go with statically allocated arrays.</p>

<p>If that won't work, we'll have to go through the pointers, but it isn't pretty.</p>
",3
11857176,11857148,3,"<p>That program works fine.  Please note that it is expecting some input before it prints anything; it counts the number of lines, words, and characters in the input.  So if you compiled the code into <code>example</code> and ran:</p>

<pre><code>echo this has four words | example
</code></pre>

<p>You would see as output:</p>

<pre><code>1 4 20
</code></pre>

<p>(That's 1 line, 4 words, 20 characters).</p>
",0
11857194,11857148,0,"<p>It works fine for me. It really shouldn't be outdated since the language hasn't changed much in quite some time. Some examples that exist on the internet and in books can be operating system specific. A classic example of this is <code>system(""PAUSE"");</code> which only works on Windows but can be converted to a sentinel loop that keeps asking if you want run it again or have a menu of options. I ran this example and hit ctrl-d and it outputted <code>5 3 14</code>. Below is my input. The last two are blank lines.</p>

<pre><code>bla
blah
2
</code></pre>

<p>I typically run programs like these by redirecting the input such as <code>./a.out &lt; a.in</code> on *nix</p>
",0
11857201,11857148,9,"<p>It works for me.</p>

<pre><code>$ gcc c.c -o c
$ echo hello world | ./c
1 2 12
$ 
</code></pre>

<p>The program reads text from standard input until it reached end-of-file. I suspect you just haven't signaled the end-of-file condition properly when reading from the keyboard. On Linux and other Unix-like systems, type <kbd>Ctrl-D</kbd> on a line by itself. On Windows, type <kbd>Ctrl-Z</kbd>.</p>

<p>If you launch the program from an IDE, it might run the program in a newly launched terminal window that closes when the program finishes; in that case, the window might disappear before you can see the output. If your IDE doesn't provide a way to override this misbehavior, you can either run it directly from a terminal window running a shell, or you can add a line such as:</p>

<pre><code>getchar();
</code></pre>

<p>to the end of the program, before the <code>return 0;</code>.  This causes it to read (and ignore) a character of input before terminating; you can type <kbd>Enter</kbd> after seeing the output.  Note that this kind of thing can make running your program more awkward when you execute it from a shell, so do this only if necessary.</p>

<p>""The C Programming Language"" by Kernighan and Ritchie, commonly referred to as K&amp;R, is an excellent C book; Ritchie, after all, largely invented the language, though it does tend to assume some existing programming knowledge. Be sure you have the second edition; the first describes an earlier version of the language. (There have been two new ISO C standards since K&amp;R2 was published, but they don't add anything that's critical for an introductory test.)</p>

<p>For a list of other C online tutorials and books, see questions 18.9 and 18.10 of the <a href=""http://www.c-faq.com"" rel=""noreferrer"">comp.lang.c FAQ</a>.</p>
",0
11857228,11857148,0,"<p>¡¶The C Programming Language¡· is a very good book for you, trust you friend.
The reason nothing you see, is that you not end your input.
In Unix like so, you can input <strong>Ctrl + D</strong>, to end of your input.
The program is Ok, I test it.</p>
",0
11857249,11857148,-2,"<p>The C programming language is a good book by Dennis Ritchie. However, if you are feeling unsatisfied by it, you can use another book:<br>
Let Us C-by Yashwant Kanetkar
After you finish of the book and you want to see how much of C you really know(that is, how much do you know about its syntax and its quirks), you can try this:<br>
Test Your C Skills-by Yashwant Kanetkar</p>
",0
11857328,11857148,2,"<p>So, your program probably just prints nothing, but does not give you a prompt until you hit Ctrl+C or something like that, right? It means that you never exit the while loop, which means your input doesn't have EOF in it. </p>

<p>That book is based on older architectures which may have different conventions for what constitutes an EOF. My advice on the book is to continue with it, keeping a flexible mind so that you can interpret the errors and work around them. Learning from books is great, but you won't really integrate it until you start playing around with it and debugging it yourself. For example, if I didn't know what was going on in this program, I might put a printf inside the while loop to get some feedback about the looping behavior. I might also experiment with changing EOF to something else (maybe -1, ., //). Imagine you are a small child just playing with things and you will probably learn a lot faster. That's my experience at least. </p>

<p>As for other books to learn from, I highly highly recommend the book ""Hacking, the Art of Exploitation"" by Jon Erickson. It does not require previous experience programming, and the second chapter is a very thorough introduction to C. I learned more about how computers really work from that one chapter of the book than in 3 semesters of computer programming courses at a private university. In a very clear but dense manner, it explains how to use the GNU debugger, how the compiler interprets the code you write, how the memory works (stack, bss, etc) and most importantly, it explains how to see other things in life as programs (law, biology, etc). Also the rest of the book will teach you a huge amount of useful information, if you have the perseverance to get thru it.  </p>

<p>Good luck and happy hacking!</p>
",0
11859948,11857148,4,"<p>K&amp;R has received a lot of ""bandwagon hype"" because of nostalgia and because it was written by Dennis Ritchie. And it is without doubt the most famous programming book ever written. Yet, in my opinion it is not a good book for beginners.</p>

<p>The main reason is that the book was written before good programming style was invented. Most examples are written in what most modern C programmers would find to be a rather messy coding style. What is good and bad coding style is certainly a subjective topic. But take your example. It could be rewritten as this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

/* count lines, words, and characters in input */

int main (void)
{
   int  ch;
   int  linefeeds_n = 0;
   int  words_n     = 0;
   int  chars_n     = 0;
   bool new_word    = true;


   while ((ch = getchar()) != EOF) 
   {
     if (ch == '\n')
     {
       new_word = true;       
       linefeeds_n++;
     }
     else if (ch == ' ' || ch == '\t')
     {
       new_word = true;
     }
     else if (new_word)
     {
       new_word = false;
       words_n++;
     }

     chars_n++;
   }

   printf(""%d %d %d\n"", 
          linefeeds_n, 
          words_n, 
          chars_n);

   return EXIT_SUCCESS;
}
</code></pre>

<p>I find the above style more readable and correct. Changes are:</p>

<ul>
<li>Sane variable names.</li>
<li>Readable variable declaration lists.</li>
<li>No mysterious state variable. Use bool type instead.</li>
<li>Always use {} for every statement to prevent numerous classic bugs.</li>
<li>No multiple check against '\n' (faster code).</li>
<li>Counter increment at the end of a while loop (common coding style).</li>
<li>Correct way to end main() as per C99.</li>
<li>Nitpick about main(), declared as void rather than empty parenthesis.</li>
</ul>

<p>They are no big changes, no major issues, but it all quickly piles up... </p>

<p>This code was also written using features from the latest C99/C11 standards, something you won't find in K&amp;R, since the book is also not up to date with the latest C standards.</p>

<p>Furthermore there are a few cases in K&amp;R where the book is just incorrect, or where it preaches blatantly dangerous practice. One perfect example of such is: typecasting the result of malloc. More examples with valid criticism of the book can be found in <a href=""http://c.learncodethehardway.org/book/learn-c-the-hard-waych55.html"" rel=""nofollow"">this article</a>.</p>

<p>As there are numerous bugs, errors and typos, so make sure to always have the <a href=""http://cm.bell-labs.com/cm/cs/cbook/2ediffs.html"" rel=""nofollow"">errata</a> within reach when reading K&amp;R.</p>
",2
10158612,10158603,3,"<p>You got <strong>undefined behavior</strong> in cases 3 and 4.</p>

<ul>
<li>Cases one and two are the same, as both pointing to the first element in the array.</li>
<li>Case 3 is undefined, as you give a pointer to pointer to char when expecting pointer to char.</li>
<li>Case 4 is undefined, as the pointer <code>d</code> is not initialized.</li>
</ul>

<p></p>
",4
10158627,10158603,2,"<p>3 works (on many platforms, and with a warning if you turn those on; technically it is undefined behavior) because you're abusing the pointer (treating <code>&amp;d</code>, which is of type <code>(char **)</code>, as <code>(char *)</code> and storing characters inside the memory intended for a pointer).  4 dies because the uninitialized pointer points to a random address.</p>
",0
10158855,10158603,0,"<p>The important question here is whether there is space in which to store the result.</p>

<pre><code>scanf(""%s"", &amp;c);
printf(""%s\n"", &amp;c);
</code></pre>

<p>Is there storage? Yes, the address you take is that of the first element of the array. The array exists, so you can put the result there.</p>

<pre><code>scanf(""%s"", c);
printf(""%s\n"", c);
</code></pre>

<p>Is there storage? Yes. Used like this, the array collapses into a pointer, which is passed same as above.</p>

<pre><code>scanf(""%s"", &amp;d);
printf(""%s\n"", &amp;d);
</code></pre>

<p>Is there storage? Yes. It's not of the appropriate type, (<code>char **</code>, should be <code>char *</code>), but it shouldn't be any different than casting a char into a pointer type and storing it in a variable declared as a pointer. (Other answers say this is undefined behavior. I don't think it is, casting a <code>char</code> or any other integer type to a <code>char *</code> or other pointer type is well-defined, if ill-advised; show me where the standard says this is undefined.)</p>

<pre><code>scanf(""%s"", d);
printf(""%s\n"", d);
</code></pre>

<p>Is there storage? Not that you've allocated. It could technically be the case that whatever happens to be in <code>d</code> points to a place in memory that won't segfault. Even if it does, it's not your memory and you could be overwriting something important, or it could change unexpectedly. You haven't told <code>d</code> where to find valid memory to point to, so you're playing pointer Russian roulette.</p>
",5
10158912,10158603,4,"<p>Repeating the code in the question:</p>

<pre><code>char c[10];
char* d;
</code></pre>

<p>1.</p>

<pre><code>scanf(""%s"", &amp;c);
printf(""%s\n"", &amp;c);
</code></pre>

<p>This is likely to work as expected, but in fact the behavior is undefined.</p>

<p><code>scanf</code> with a <code>""%s""</code> format requires an argument of type <code>char*</code>.  <code>&amp;c</code> is of type <code>char (*)[10]</code>, i.e., it's a pointer to a <code>char[10]</code> array.  It points to the same location in memory as the address of the 0th element of <code>c</code>, but it's of a different type.  The same thing happens with the <code>printf</code>: the <code>""%s""</code> format tells it to expect a <code>char*</code> argument, but you're passing it a <code>char(*)[10]</code> argument.</p>

<p>Since <code>scanf</code> is a variadic function, there's no required type checking for arguments other than the format string.  The compiler will (probably) happily pass the <code>char (*)[10]</code> value to <code>scanf</code>, assuming that it can handle it.  And it <em>probably</em> can, on an implementation where all pointers have the same size, representation, and argument-passing mechanism.  But, for example, a C compiler for an exotic architecture could easily make <code>char*</code> pointers bigger than pointers to larger types.  Imagine a CPU whose native address points to, say, a 64-bit word; a <code>char*</code> pointer might be composed of a word pointer plus a byte offset.</p>

<p>2.</p>

<pre><code>scanf(""%s"", c);
printf(""%s\n"", c);
</code></pre>

<p>This is better.  <code>c</code> is an array, but in this context an array expression ""decays"" to a pointer to the array's first element -- which is exactly what <code>scanf</code> with a <code>""%s""</code> format requires.  The same thing happens passing <code>c</code> to <code>printf</code>.  (But there are still some problems; I'll get to that after the other examples.</p>

<p>3.</p>

<pre><code>scanf(""%s"", &amp;d);
printf(""%s\n"", &amp;d);
</code></pre>

<p>Since <code>d</code> is a single <code>char*</code> argument, <code>&amp;d</code> is of type <code>char**</code>, and again, you're passing arguments of the wrong type.  If all pointers have the same representation (and the same argument-passing mechanism), and the input for the <code>scanf</code> is short enough, this might happen to ""work"".  It treats the <code>char*</code> object as if it were an array of <code>char</code>.   If <code>char*</code> is 4 bytes, and the input string is no more than 3 characters long, this will probably work -- as if you had used a <code>char[4]</code> and written the calls correctly.  But it's <em>extremely</em> poor practice to store character strings directly into a pointer object, and there's a huge risk of writing past the end of the object, with unpredictable results.  (Those unpredictable results include writing into memory that isn't being used for anything else, which could <em>appear</em> to work; such is the nature of undefined behavior.)</p>

<p>(The C standard gives special permission to treat any object as an array of characters, but in this case it's a very bad idea.)</p>

<p>4.</p>

<pre><code>scanf(""%s"", d);
printf(""%s\n"", d);
</code></pre>

<p>Here the types are all correct, but unless you've initialized <code>d</code> to point to a sufficiently large array of <code>char</code>, it's likely to fail spectacularly (or, worse, appear to work ""correctly"", which means you've got a subtle bug that will probably show up later).</p>

<p>And now we get to what I mentioned above about other problems.</p>

<p>For example 4, I mentioned that <code>d</code> needs to point to a ""sufficiently large"" array.  How large is ""sufficiently large""?  There's no answer to that.  <code>scanf(""%s"", ...)</code> reads a whitespace-delimited sequence of characters with no upper bound on its length.  If I run your program and hold down the <code>x</code> key, for example, I can provide an input string longer than any buffer you've provided, with unpredictable results (undefined behavior again).</p>

<p>The <code>scanf</code> function's <code>""%s""</code> format <em>cannot</em> be used safely (unless your program runs in an environment where you can control what will appear on the standard input stream).</p>

<p>One good way to read text input is to use <code>fgets</code> to read a line at a time, then use other functions to analyze the result.  <code>fgets</code> requires you to specify the maximum length of the input; if the actual input exceeds the limit, it's truncated and left to be read by later calls.  It's not quite as convenient as <code>scanf</code>, but it can be done safely.  (And <em>never</em> use the <code>gets</code> function; like <code>scanf(""%s"", ...)</code>, it cannot be used safely.)</p>

<p>Suggested reading:</p>

<p>Section 6 of the <a href=""http://c-faq.com/"" rel=""nofollow"">comp.lang.c FAQ</a> does an excellent job of explaining C arrays and pointers, and how they're related (and not related).  Section 12 discusses C standard I/O.</p>

<p>(I'm sorry this answer is so long; I didn't have time to make it shorter.)</p>
",0
9822590,9822292,1,"<p>Your main problem is that you allocate a node for the new value then overwrite it with the head of <em>both</em> lists and advance <em>both</em> pointers. That means you'll lose every second node.</p>

<p>In addition, concatenating two lists is not <em>really</em> a good fit for recursion since the search space doesn't reduce that fast (ideal candidates for recursion, like a binary chop or a multi-way tree traversal, throw away a large amount of the search space with each recursion call). You can do it iteratively with something like, (assuming sorted ascending, and using pseudo-code since it's homework):</p>

<pre><code>def union (link1, link2):
    set1 = link1, set2 = link2
    headnode = NULL, tailnode = NULL

    # Continue until both lists empty.

    while set1 is not NULL and set2 is not NULL:
        # Create new node and set next pointer to NULL.

        newnode = alloc_node()
        newnode-&gt;next = NULL

        # Select which set will provide the next node.

        if set1 is NULL:
            newnode-&gt;data = set2-&gt;data, set2 = set2-&gt;next
        else if set2 is NULL:
            newnode-&gt;data = set1-&gt;data, set1 = set1-&gt;next
        else if set2-&gt;data is less than set1-&gt;data:
            newnode-&gt;data = set2-&gt;data, set2 = set2-&gt;next
        else:
            newnode-&gt;data = set1-&gt;data, set1 = set1-&gt;next

        # Add to end of (possibly empty) list.

        if headnode is NULL:
            headnode = newnode, tailnode = newnode
        else:
            tailnode-&gt;next = newnode, tailnode = newnode

    return headnode
</code></pre>

<p>It basically works by doing one iteration per node added to your destination list, until both source lists are empty. If one of the source lists is empty, it selects the next node from the other list.</p>

<p>Otherwise, it selects the next node from the list whose current pointer has the lowest value.</p>
",0
9855485,9855462,4,"<p>Because the comma operator (<code>,</code>) has lower precedence than the assignment operator (<code>=</code>).  So your first example is equivalent to:</p>

<pre><code>(c=a),b;
</code></pre>

<p>See here: <a href=""http://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B#Operator_precedence"" rel=""nofollow"">http://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B#Operator_precedence</a>.</p>
",0
9855495,9855462,6,"<p>Your code:</p>

<pre><code>a=3;
b=5;
c=a,b;
d=(a,b);
</code></pre>

<p>is treated as if it was written:</p>

<pre><code>a=3;
b=5;
(c=a),b;
d=(a,b);
</code></pre>

<p>That's why <code>c == 3</code> and <code>d == 5</code>.</p>

<p>A good compiler might warn you about the line containing the assignment to <code>c</code>; the evaluation of <code>b</code> does nothing to the state of the computation.  Similarly for the evaluation of <code>a</code> in the expression for <code>d</code>.</p>

<hr>

<blockquote>
  <p>What about <code>d=(a,b)</code> &mdash; how does it display <code>d=5</code> in the output?</p>
</blockquote>

<p>The comma operator is the lowest priority of all operators in C.  It is also important to remember that the commas in the argument list of a function are <em>not</em> comma operators.</p>

<p>The behaviour of the comma operator exemplified by:</p>

<pre><code>x, y;
</code></pre>

<p>is to evaluate the expression <code>x</code> and discard the result, then evaluate the expression <code>y</code> (and the overall result is the value of <code>y</code>).  There is a sequence point at the comma operator; that's a refinement that doesn't matter to you now, but may do in the future.</p>

<p>In your expression:</p>

<pre><code>d = (a, b);
</code></pre>

<p>the expression <code>a</code> is evaluated (it's 3) and ignored; then the expression <code>b</code> is evaluated (it's 5), and that is used as the result of the comma operator expression, and therefore of the parenthesized expression, and therefore the value 5 is assigned to <code>d</code>.</p>

<p>In contrast, in your expression:</p>

<pre><code>c = a, b;
</code></pre>

<p>the LHS of the comma operator is <code>c = a</code>, so <code>a</code> is evaluated (it's 3) and assigned to <code>c</code>.  This is then thrown away, and <code>b</code> is evaluated.  The overall expression statement just assigns 3 to c, therefore.</p>

<p>You might well ask, ""Why is the comma operator useful?""</p>

<p>There are places where it is useful, such as the initialization and increment sections of a <code>for</code> loop:</p>

<pre><code>for (i = 0, s = p; *s != '\0'; i++, s++)
{
     ...
}
</code></pre>

<p>There are two comma operators there.  The first contains a pair of assignments; the second contains a pair of expressions with side-effects.</p>

<p>Another place where it is sometimes used (though I'd argue it is seldom good style), is:</p>

<pre><code>if (some_variable == A_VALUE)
    p = q++, r = z;
</code></pre>

<p>This 'saves' having to add braces around the condition body.  However, it is not good style to hide assignments like that.  The code should be (give or take the placement of braces, which is controversial):</p>

<pre><code>if (some_variable == A_VALUE)
{
    p = q++;
    r = z;
}
</code></pre>

<p>If you like Obfuscated C, there's the <a href=""http://ioccc.org/"" rel=""nofollow"">International Obfuscated C Code Contest</a>.</p>

<p>If you are writing macros, sometimes the comma operator can be a life-saver.</p>
",1
9855505,9855462,0,"<p>OK, I will doit</p>

<pre><code>c=a,b;
</code></pre>

<p>Means do:</p>

<pre><code>c=a;
b;

d=(a,b);
</code></pre>

<p>Mean do:
    a;
    b;
    assign the last ""result"" to d;</p>

<p>"","" comma separates two statements. The return of the last statement is the result of the combined statements</p>
",0
9855541,9855462,2,"<p>The question revolves mainly around the statements</p>

<pre><code>c=a,b;
d=(a,b);
</code></pre>

<p>The <code>=</code> operator has lower precendence than the <code>,</code> operator, so the first statement means:</p>

<pre><code>(c=a),b;
</code></pre>

<p>The <code>,</code> operator returns the value of the second operand, so the second statement means:</p>

<pre><code>a,(d=b);
</code></pre>
",0
9858182,9855462,0,"<p>ur output will be
  c=3 d=5;
to visualise the result u should know the associativity of {=}-assignment operator and {,}-comma operator. ->because assignment (=) takes precedence over comma (,) your first statement c=a,b is equivalent to</p>

<pre><code>(a=3),5;
</code></pre>

<p>expressions separated by commas are always evaluated left to right. So the value of an expression</p>

<p>(expr1, expr2 )</p>

<p>is always the value of the last expression. Thus, in your second statement d=(a,b) the result of the right-hand side is d=5...</p>
",0
10166213,10166157,6,"<p>The <code>for</code> loop in <code>MyFNatoi()</code> should be based on the length of <code>numArray</code> rather than the size of the array: use <code>strlen(numArray)</code> and not <code>10</code>.</p>

<p>Use <code>isdigit()</code> to determine if a character is a digit or not.</p>

<p>If all the characters were digits then assign <code>*value</code> to <code>atoi()</code>. Otherwise, set <code>*value</code> to <code>0</code>:</p>

<pre><code>void MyFNatoi(char *numArray, int *value)
{
    int i;
    const int len = strlen(numArray);

    for (i = 0; i &lt; len; i++)
    {
        /* #include &lt;ctype.h&gt; for 'isdigit()'. */
        if (!isdigit(numArray[i])) break;
    }
    /* #include &lt;stdlib.h&gt; for 'atoi()'. */
    *value = len == i ? atoi(numArray) : 0;
}
</code></pre>
",0
10166371,10166157,4,"<p>Don't set <code>*value</code> to 0 to indicate failure - 0 is a valid integer.  Use the return value instead, as you indicate in the body of the text.  Use the standard library rather than loop yourself.</p>

<pre><code>#include &lt;stdio.h&gt;

/* return true on success */
int MyFNatoi(const char *numArray, int *value)
{
    int n = 0;
    return sscanf(numArray, ""%d%n"", value, &amp;n) &gt; 0 /* integer was converted */
       &amp;&amp;  numArray[n] == '\0'; /* all input got consumed */
}
</code></pre>
",1
9832723,9832677,2,"<p>If you want to add 12 <em>bytes,</em> you need a data type that work on byte boundaries, like a <code>char *</code>. Now you may <em>think</em> you're doing that (<code>buffer1</code> decays to a <code>char *</code>) but, because a cast binds more tightly than an addition, <code>(int*)buffer1 + 12</code> actually means <code>((int*)buffer1) + 12</code> rather than <code>(int*)(buffer1 + 12)</code>.</p>

<p>And the problem with adding 12 to an <code>int *</code> is that it scales the addition. If your <code>int</code> is four bytes, adding 12 to it will actually add 48 bytes.</p>

<p>If you change the assignment line to:</p>

<pre><code>ret = (int*)(buffer1 + 12);
</code></pre>

<p>you will find that the addition happens to <code>buffer1</code> so will not be scaled, then the cast to an <code>int *</code> will operate on that value.</p>

<p>I should mention of course that <em>dereferencing</em> the resultant pointer is probably not a good idea since it will be beyond the bounds of the actual array.</p>

<p>I'll also suggest that <code>%p</code> is probably a better format string to use for pointers.</p>
",3
9832728,9832677,0,"<p>It should be:</p>

<pre><code>ret = (int*) (buffer1 + 12);
</code></pre>
",0
9832733,9832677,0,"<pre><code>ret = (int *)(buffer1 + 12);
</code></pre>

<p>should do the trick. An <code>int *</code> plus <code>something</code>, looks at that <code>something</code> added to the initial address as at <code>sizeof(int) * something</code> (standard pointer arithmetic).</p>
",0
14853912,14853373,2,"<p>So, there are three steps, I think you are wanting to do:</p>

<ol>
<li>Repeat the output when the time changes.</li>
<li>Go back to top of screen. </li>
<li>Not use every ounce of CPU power in the process. </li>
</ol>

<p>Step 1 involves adding a while-loop around the whole code. </p>

<p>Step 2 involves using the <a href=""http://msdn.microsoft.com/en-gb/library/windows/desktop/ms686025%28v=vs.85%29.aspx"" rel=""nofollow""><code>SetConsoleCursorPosition</code></a> functon. </p>

<p>Step 3 involves calling <code>Sleep(250)</code> or something like that [you don't want to sleep a whole second, but a long enough time that the code doesn't use up all the CPU just to check every millisecond if the time has changed). You should probably also check if the current time is the same as last time, and not print it then.</p>

<p>I personally would simplify all the output as well, by moving the <code>printf(""%i"", i);</code> (etc) out of the if/else - after all, it's the same both sides. In fact, I'd have a variable set to the colour, and then call both <code>SetConsoleTextAttribute</code> and <code>printf</code> after the if, just set the <code>colour = WHITE</code> or <code>colour = RED</code> in the if/else statements. </p>
",2
16445207,16445171,7,"<p>The line</p>

<pre><code>result_notabs = (char *)malloc(sizeof(char) * strlen(result)));
</code></pre>

<p>should be</p>

<pre><code>result_notabs = malloc(strlen(result) + 1);
</code></pre>

<p>to leave space for the null terminator at the end of <code>result</code>.  Without this, <code>ConvertToOneSpace</code> writes beyond the end of <code>result_notabs</code>.  This has undefined consequences which could include writing to memory used by other parts of your program.</p>

<p>Note that I made a couple of other changes to that line</p>

<ul>
<li>removed the cast from the return of <code>malloc</code>.  This isn't required in C and <a href=""http://c-faq.com/malloc/mallocnocast.html"" rel=""nofollow"">can mask bugs</a></li>
<li>removed the use of <code>sizeof(char)</code> since this is guaranteed to be 1</li>
</ul>

<p>You should also note the comment from Elchonon Edelson.</p>

<pre><code>char *aString[4096];
</code></pre>

<p>declares an array of 4096 <code>char</code> <em>pointers</em>.  Your code just needs an array of <code>char</code>s instead</p>

<pre><code>char aString[4096];
</code></pre>

<p>(This won't have caused your problem but its worth getting into the habit of using the correct type for strings)</p>
",5
16445348,16445171,0,"<p>Use  <code>result_notabs = (char *)malloc(sizeof(char) * (strlen(result)+1)));</code> instead of  <code>result_notabs = (char *)malloc(sizeof(char) * strlen(result)));</code>
Here extra 1 is added to string length for the terminating null charecter.</p>
",0
18986308,18986141,7,"<pre><code>   float x=1.1;                    
   while (x==1.1)
</code></pre>

<p>float and double variables are not capable of storing the exact value of 1.1, only a very close approximation. The exact value in a float and a double will be slightly different due to the difference in precision.</p>

<p>1.1 is a <em>double</em> value. You are storing 1.1 as a double into a float which will slightly alter the value. Then you compare it with the double value 1.1 so it will not quite be equal and so will never enter your condition.</p>

<p>For this to work you need to write 1.1f to ensure that you are working with the same data type everywhere. 
In addition I'm sure someone else will explain why comparing floating point values for exact equality is often a bad idea. </p>
",0
10158108,10158068,5,"<ul>
<li><p>You have not allocated enough space for the null terminator.</p></li>
<li><p>You don't add the null terminator to the end of your result.</p></li>
<li><p>Your source string doesn't actually contain quotes.</p></li>
</ul>
",4
10158113,10158068,1,"<p>In C strings are terminated by a null character, that means <code>'\0'</code>.</p>

<p>You didn't terminate string in <code>removeQuotes()</code>, this is the correct version:</p>

<pre><code>char* removeQuotes(char str[]) {
    int i = 1;
    int len = strlen(str) - 2;
    char * tmp = (char*) malloc (sizeof(char) * (len + 1));
    for (;i&lt;=len;++i ) {
        tmp[i-1] = str[i];
    }
    tmp[len] = '\0';
    return tmp;
}
</code></pre>

<p>Also, your string actually didn't contain quotes and you do not check if the string you pass to <code>removeQuotes</code> contain any quotes.</p>
",1
10158116,10158068,0,"<p>Keep a '\0' in temp string. otherwise it will not know that it is a string.</p>
",5
10158092,10158068,0,"<p>In your <code>removeQuotes</code> function you underallocate memory for the resulting string and write an extra character past the buffer.</p>

<p>The string <code>""Hello world""</code> doesn't actually contain any quotes. You'd have to declare it as <code>""\""Hello world\""""</code> to have the string you had in mind. In any case, the string resulting from your quote removal has the same number of characters as the input one. You lose the first character, because you never copy it, and the last one gets written past the buffer (and it would be written there, clobbering memory, even if it were a quote mark.</p>

<p>Why do you need to do this anyway? Do you believe that C strings are created with quote characters in the first and last positions of the character array?</p>
",0
9799375,9798906,0,"<p>Since it is homework I will only give you some hints on what you have going wrong. I hope this gets you back on the right track!  :)</p>

<ol>
<li><p>You mention that you are only reading in a limited number of lines. You should look to your loop condition, ""while(i &lt; MAX_SKATER &amp;&amp; fgets("", to see why it is only printing a few of your lines.</p></li>
<li><p>I will give you this one since you are just starting. In your sscanf call to read in the score line, every parameter must be passed as a pointer. The second variable you pass in to receive data isn't being passed correctly. Instead use ""&amp;skater[i].baseval"". The same goes for your player name sscanf.</p></li>
<li><p>You will need to call fgets again, likely in your ""for(k"" loop. As you have it, you are only attempting to read in your header line. Then you are re-using the same buffer data (a header line) when trying to parse a score line.</p></li>
<li><p>You will need to separate your sscanf in your ""for(j"" loop, resulting in a new sscanf in your ""for(k"" loop. You will have to read in the player number and baseval separate from the scores because you have a variable number of scores to read (COLUMN_SCORE).</p></li>
</ol>
",0
9811374,9811163,2,"<p>Change</p>

<pre><code>fwrite(buffer, sizeof(buffer), 1, handle);
</code></pre>

<p>into:</p>

<pre><code>fwrite(buffer, lSize, 1, handle);
</code></pre>
",1
9811290,9811163,1,"<p>If you are running this under windows, it could fail because of text mode output file. </p>

<p>Use <code>handle = fopen(filename, ""wb"");</code>. Are you sure you have no errors while opening the files? Also your way of getting file size isn't optimal and it's better to use <code>stat</code>-family functions. And if <code>malloc</code> will fail you'll get a ""Segmentation fault"".</p>

<p><code>fwrite</code> returns number of items written, or -1 on error. It sets <code>errno</code> so you can use <code>perror</code> or <code>strerror</code>.</p>

<p><strong>EDIT:</strong> <em>wildplasser</em>'s answer is the correct solution. Didn't notice this mistake.</p>
",0
10138815,10138789,4,"<p>Static stack arrays 'decay' into plain old pointers when passed as arguments into functions. What then happens, is using <code>sizeof</code> gets the size of the pointer, not the array. You'll need to pass the array size as another argument.</p>
",0
10138816,10138789,2,"<p>I suspect that your function signature looks like this:</p>

<pre><code>void codifyDHCPmessage(char[], message_t, size_t);
</code></pre>

<p>(or similar)</p>

<p>The problem is that <code>[]</code> in a function signature really means <code>*</code>, that is, <code>char[]</code> is really <code>char*</code>. In other words, the array argument decays to a pointer whose size is, unsurprisingly, 4.</p>

<p>As far as I know (but I could be wrong ¡­), C doesn¡¯t allow you to pass arrays into functions at all, it just supports pointers. That¡¯s why you need to pass the size as an explicit separate argument.</p>
",3
10138820,10138789,3,"<p>When an array is passed to a function, <strong>actually the pointer to it base address is passed</strong>. Now if you apply <code>sizeof</code> over it, it returns only 4, the sizeof a pointer on 32-bit systems. </p>

<p>If you really want the number of characters in <code>buffer</code>, you need to make sure it is null terminated before passing it and then in the called function, use something like <code>strlen</code> to calculate the size or you have to calculate the array size in the caller itself (where the array is defined and <code>sizeof</code> works fine on it)and then send it to the function to be called. </p>

<p>You are already sending the size of the array as an argument. <strong>But if want to the know the <em>actual</em> number of characters inside the array</strong>, then you can do something like this-</p>

<pre><code>int size=4384;
char buffer[size];
memset(buffer, 0, size);
</code></pre>

<p>And then call your <code>codifyDHCPmessage</code>.Finally, inside <code>decodifyDHCPmessage</code> you can do</p>

<pre><code>unsigned sz = strlen(buffer);
</code></pre>
",0
10138841,10138789,0,"<p>In C/C++ the buffer  argument is passed to a function as a pointer==> it retuns you the sizeof pointer in bytes - 4.</p>
",6
10141467,10141359,0,"<p>You better test for fscanf return value before printing result. I bet that in the last iteration of your loop, fscanf calls fail and you print the last returned results.</p>
",0
10141468,10141359,0,"<pre><code>FILE *fp ;
int mac;
char ip[15];

fp = fopen (""mac_ip.txt"", ""r"") ;
if (!fp) return;

while(1){
    if (fscanf(fp,""%i"",&amp;mac) &lt; 1) break;
    if (fscanf(fp,""%s"",ip) &lt; 1) break;

    printf(""MAC: %i\n"",mac);
    printf(""IP: %s\n"",ip);  
}
fclose (fp);
</code></pre>

<p>fscanf() returns the number of assignments it mad (or -1 on eof). By using the return value, you don't need the eof() function. BTW I don't think you can read a MAC address into an int. Maybe you need to read that into a string, too ?</p>

<p>Explanation: feof() does not do what the OP expects. <strong>feof() should only be inspected after one of the file operations failed.</strong> In most cases you don't need feof(). </p>
",0
10141419,10141359,6,"<p>Because after reading the last two values, you still haven't hit EOF. So the loop goes on. In the next pass of the loop, fscanf actually does not read the last line for the second time like it appears, the fscanfs fail, but the printfs print out the values from the previous pass of the loop.</p>
",0
10141423,10141359,2,"<p>After you have done the two reads on the twentieth line, you have got to the end of the file <em>but</em> the system doesn't know this. feof will only trigger when you try to get past the end of the file, not when you are exactly on it ...</p>

<p>Also, you may have a line-end (CR or CR-LF) on the 20th line which it will only get past with another attempted read.</p>

<p>The solution is to read the line in one go (there is a specific C command for this) and then parse that to get your data. If the whole-line read fails, then you've got to the end.</p>
",1
10141439,10141359,5,"<p><code>feof</code> does not ""know"" it's at the end of file until you try to read some more. Since <a href=""http://www.cplusplus.com/reference/clibrary/cstdio/fscanf/"" rel=""nofollow""><code>fscanf</code></a> tells you how many items it got, you can use this simple trick:</p>

<pre><code>for(;;){
    if (fscanf(fp,""%i%s"", &amp;mac, ip) != 2) break;
    printf(""MAC: %i\n"",mac);
    printf(""IP: %s\n"",ip);  
}
</code></pre>
",3
10141702,10141359,1,"<p>Your code resembles to the following example</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    char buffer[256];
    FILE * myfile;

    myfile = fopen(""some.txt"",""r"");

    while (!feof(myfile))
    {
        fgets(buffer,256,myfile);
        printf(""%s"",buffer);
    }

    fclose(myfile);

    return 0;
}
</code></pre>

<p>from</p>

<p><a href=""http://www.friedspace.com/feof.html"" rel=""nofollow"">http://www.friedspace.com/feof.html</a></p>
",0
9153622,9153561,3,"<pre><code>            int k;
            now = atof(temp);
            for(k = 0; k &lt; 7; ++k)
                temp[k] = -1;
            k[i].freq = now; //Problematic Line &lt;--
</code></pre>

<p><code>k</code> is redeclared in the first line of this code snippet: <code>int k;</code></p>

<p>It shadows your initial declaration of <code>k</code> object: <code>struct keyFreq k[25];</code>. To fix this, use two different names in the two variable declarations.</p>
",1
9153627,9153561,1,"<pre><code>    struct keyFreq k[25];
                int k;
                now = atof(temp);
                for(k = 0; k &lt; 7; ++k)
                    temp[k] = -1;
                k[i].freq = now; //Problematic Line &lt;--
</code></pre>

<p>The last k is not an array, it is the <code>int</code> you have just defined 4 lines previously.<br>
Objects of type <code>int</code> cannot be used as arrays.</p>

<p>I see you are using C99 (// comments, definitions and code intermixed), so try limiting the definition of the temporary k to the for loop</p>

<pre><code>    struct keyFreq k[25];
                now = atof(temp);
                for(int k = 0; k &lt; 7; ++k)
                    temp[k] = -1;
                k[i].freq = now; //Problematic Line &lt;--
</code></pre>
",3
9153652,9153561,0,"<p>The problem is this:</p>

<pre><code> int k;
</code></pre>

<p>Which hides the earlier definition of </p>

<pre><code> struct keyFreq k[25];
</code></pre>

<p>Change <code>int k;</code>to something else, or rename your original array.</p>

<p>In general, it's not good practice to use single letter variable names for variables that aren't iterators. Otherwise things like this might happen (and the code is harder to read).</p>
",0
9832815,9832793,1,"<p>Try:</p>

<pre><code>int arr [2][2] = { {1, 2} , {3, 4} };

printf(""%d "", **arr); 
</code></pre>

<p>You need two levels of dereferencing, as your array is two-dimensional.</p>
",2
9832826,9832793,1,"<p>If <code>a</code> is <code>int[][]</code> then <code>*a</code> is <code>int[]</code>. You need another level of redirection to access an array element. That is, <code>**a</code> is <code>int</code>.</p>
",0
9832829,9832793,4,"<p>You <em>can</em> dereference it, it is just that the result is not going to be what you'd expect: <code>*arr</code> is not an <code>int</code>, it's a <em>pointer to an <code>int</code></em> (OK, a one-dimensional array). If you want to see <code>1</code> printed, add another star:</p>

<pre><code>printf(""%d "", **arr);
</code></pre>
",1
9849211,9832793,0,"<p>Remember if we define a as int[][], then it means it is a two dimensional array and it can be dereferenced by **a. If array is one dimensional then we should use *a to dereference it...</p>

<p>Try it..</p>
",0
9177884,9177860,3,"<p>A <code>typedef</code> creates a new name. Thus these are completely equivalent:</p>

<pre><code>student *next;
struct student *next;
</code></pre>

<p>In your example the struct and the typedef have the same name. But it could be like this:</p>

<pre><code>struct something {
/* ... */
};

typedef struct something student;
</code></pre>

<p>The declaration of a typedef looks like the type it introduces.</p>

<hr>

<p>As a side side note, <a href=""http://c-faq.com/struct/impltypedef.html"" rel=""nofollow"">things are different in C++</a>.</p>
",3
9177898,9177860,0,"<p>In C, whenever using structs you have to use the keyword <code>struct</code>. By typedefing <code>typedef struct student student</code>, you're able to say <code>struct student</code> by simply saying <code>student</code>.</p>
",0
9177914,9177860,0,"<p>With a named structure, the keyword <code>struct</code> most usually be used to create instances of the structure and to reference the structure type at all.</p>

<p>The <code>typedef</code> allows you to virtually create an alias for <code>student</code> instead of having to use <code>struct student</code> constantly, thereby actually making it behave more like a built-in type.</p>
",0
9178102,9177860,1,"<p><code>typedef struct student student;</code></p>

<p>This create an alias for <code>struct student</code> with the name <code>student</code>.</p>

<p>Structure tags and type names live in two different namespaces in C (not true in C++), so it is allowed to use the same name for the alias and for the tag.</p>
",0
18943535,18943282,0,"<p>That's funny, I get -</p>

<pre><code>number of rows is 8
number of columns is 29
</code></pre>

<p>The problem is that thanks to using getc, you count the number of actual characters in the text file, when you read 255 for e.g., that's not really a single char with that value, it's 3 chars with the values 50 ('2'), 53 ('5') and 53 ('5'). You'll also count spaces here (which is probably why I got a different results than you did)</p>

<p>You should read them as integers (fscanf for e.g.), or parse them as such according to the acceptable delimiters (space and newlines in this case, I presume), and only then advance your counters accordingly. Alternatively, you can compact your files to a binary format and forget about all the hassle with spaces and newline, one byte per character. They won't be as readable though.</p>

<p>Also note that your code assumes a fixed column count per line, better be sure it's always the case</p>
",0
9182718,9182694,1,"<blockquote>
  <p><strong>what if there is no blank space or tab than what value will s[0] will intialize</strong></p>
</blockquote>

<p>The following loop will <em>continue executing</em> until <code>getch()</code> returns a character that's neither a space nor a tab:</p>

<pre><code>while((s[0] = c = getch()) == ' ' || c == '\t')
    ;
</code></pre>

<blockquote>
  <p><strong>what is the use of s[1]='\0'</strong></p>
</blockquote>

<p>It converts <code>s</code> into a <a href=""http://en.wikipedia.org/wiki/Null-terminated_string"" rel=""nofollow"">C string</a> of length 1, the only character of which has been read by <code>getch()</code>. The <code>'\0'</code> is the required NUL-terminator.</p>
",3
9182788,9182694,0,"<ol>
<li><p>If there is no space or tab, you're stuck with an infinite loop.</p></li>
<li><p>s[1]='\0' is a way of marking the end so functions like strlen()
know when to stop reading through c strings.  it's called ""Null-Terminating"" a string: <a href=""http://chortle.ccsu.edu/assemblytutorial/Chapter-20/ass20_2.html"" rel=""nofollow"">http://chortle.ccsu.edu/assemblytutorial/Chapter-20/ass20_2.html</a></p></li>
</ol>
",1
15534686,15081974,2,"<p>You can use Curse (ncurses) library for this, or take a look at my project: libtprint - a simple library to print tabled data, <a href=""https://github.com/wizzard/libtprint"" rel=""nofollow"">https://github.com/wizzard/libtprint</a></p>

<p>Hope it helps !</p>
",2
9855708,9855699,6,"<p>Your first scanf leaves a newline in the buffer. It's because <code>%d</code> ignores trailing blanks while <code>%c</code> doesn't. Use this cheap trick to make the second <code>scanf</code> eat the blanks:</p>

<pre><code>scanf("" %c"", &amp;answer);
       ^
</code></pre>

<p>The issue is common enough, you can read more about it in the <a href=""http://c-faq.com/stdio/gets_flush2.html"">C FAQ</a>.</p>
",2
9855823,9855699,0,"<p>You need a space before the <code>%c</code> in order to skip the newline that wasn't read when scanf stopped at the end of the number.</p>

<p>I have some unsolicited advice...</p>

<ol>
<li><p>Don't use <code>scanf(3)</code> directly, it's too hard to make it do what you want. It's usually better to use <code>fgets(3)</code> and then <code>sscanf(3)</code>.</p></li>
<li><p>Compile with warnings turned on. (On my Mac that means <code>cc -Wall ...</code>)</p></li>
</ol>

<p>And with warnings turned on, here your program with a few issues fixed:</p>

<pre><code>#include &lt;stdio.h&gt;
int main(void) {

    int nums[100], i;
    char answer;
    int count = 0;
    // double avg;

    for (i = 0; i &lt; 100; i++) {
        printf(""Enter number %d: "", i + 1);
        scanf("" %d"", &amp;nums[i]);
        printf(""Another? "");
        scanf("" %c"", &amp;answer);
        if (answer != 'y' &amp;&amp; answer != 'Y')
          break;
        count += nums[i];
    }
    return 0;
}
</code></pre>
",0
10148482,10148453,4,"<p>Most likely you never initialized <code>i</code> to zero before doing the <code>fscanf</code> loop.</p>
",1
18518227,18518123,0,"<p><code>!</code> is the boolean <em>not</em> operator. So if <code>&lt;expr&gt;</code> is true (i.e. non-zero), then <code>!(&lt;expr&gt;)</code> is false (zero), and vice versa.</p>
",0
18518147,18518123,2,"<p>that means the button is active on low better known as <code>active low</code></p>
",7
18518167,18518123,0,"<p>The ! operator yields 0 if its operand is nonzero and 1 if its operand is 0, and the if-statement executes its body if the condition is nonzero. So if <code>REG8(DataRegA) &amp; 0x80</code> evaluates to 0 (which would make the code in the if-statement's block not execute), the ! operator will reverse it and make it execute.</p>
",0
18518302,18518123,1,"<p>That code checks the state of the 7th bit in that register; if it's off, it executes the block of code.</p>

<ul>
<li><code>REG8(DataRegA)</code> presumably gets the value of some MCU register, which probably reflects the state of some input signal;</li>
<li><code>REG8(DataRegA) &amp; 0x80</code> performs a bitwise AND with <code>0x80</code>, which returns 0 if the seventh bit is not set, <code>0x80</code> otherwise;</li>
<li>the <code>!</code> is the logical negation operator; in <code>!(REG8(DataRegA) &amp; 0x80)</code> it negates the expression above, i.e. if it's 0 it becomes 1, if it's nonzero it becomes 0.</li>
</ul>

<p>Thus, the <code>if</code> body is executed only if the 7th bit in the register is not set.</p>
",0
11839815,11839712,4,"<p>for reading numbers from a line, you can :</p>

<pre><code>#include &lt;stdio.h&gt;

int main(){
    char buffer[1000];
    if (fgets(buffer, sizeof(buffer), stdin) != 0){
        int i,j,a;
        for(i=0; sscanf(buffer+i,""%d%n"",&amp;a,&amp;j)!=EOF; i+=j){
            while(a--&gt;0){
                printf(""*"");
            }
            printf(""\n"");
        }
    }
    return 0;
}
</code></pre>
",3
11839822,11839712,0,"<p>It's better to have a loop for this manner.<br>
While user has not entered <strong>""\n""</strong> your program should be able to consider them as integers. Of course you can add some other checks as well.<br>
<br>
Something like this:<br></p>

<pre><code>int number = 0;
char c = '';
while(c != '\n'){
    getch(c);
    scanf(""%d"", &amp;number);
    /*Do your star thing or add this number to an array for the later consideration*/
}
</code></pre>

<p><br>
This is not fully tested and you might have to have some changes.</p>
",0
11883707,11839712,0,"<pre><code>#include &lt;stdio.h&gt;

#define SIZE 8

int input_numbers(int numbers[]){
    int i=0,read_count;
    char ch;

    printf(""In: "");
    while(EOF!=(read_count=scanf(""%d%c"", &amp;numbers[i], &amp;ch))){
        if(read_count==2)
            ++i;
        if(i==SIZE){
            fprintf(stderr, ""Numeric number has reached the Max load.\n"");
            return i;
        }
        if(ch == '\n')
            break;
    }
    return i;
}

void output_numbers(int numbers[], int size){
    int i,j;
    printf(""Out:\n"");
    for(i=0;i&lt;size;++i){
        printf(""%d | "", numbers[i]);
        for(j=0;j&lt;numbers[i];++j){
            printf(""*"");
        }
        printf(""\n"");
    }
}

int main(void){
    int numbers[SIZE];
    int n;

    n=input_numbers(numbers);
    output_numbers(numbers, n);
    return 0;
}
</code></pre>
",0
9773843,9773683,0,"<p>Try checking the last character of input to see if its a <code>\n</code>. <code>ENTER</code> does not constitute <code>EOF</code>, it generally is a <code>\n</code> character.</p>
",0
9773858,9773683,3,"<p>One option is to swap the order of your conditions:</p>

<pre><code>while (counter &lt; SIZE &amp;&amp; scanf(""%d"", &amp;number) != EOF){
</code></pre>

<p>As the conditions are evalulated left-to-right, your program waits for new input (via <code>scanf(%d...</code>)) before it evaluates <code>counter &lt; SIZE</code>. This change would cause the program to immediately exit the while loop after the 5 is typed, BEFORE a user presses enter, as it evaluates <code>counter &lt; SIZE</code> after the 5 is processed. </p>

<p>(If you choose this option, you will also want to print an endline character before you begin to repeat the numbers, as the user will not have pressed enter before it begins printing)</p>

<hr>

<p>If you want the program to exit the loop when the user presses enter, you'll have to change your scanf. <code>scanf(%d...</code> reads a digit, and an endline character is <em>not</em> a digit.</p>
",0
9773933,9773683,1,"<p>Here's one approach off the top of my head (warning, untested):</p>

<pre><code>int number;
char nl = 0;

while (counter &lt; 5 &amp;&amp; scanf(""%d%c"", &amp;number, &amp;nl) != EOF)
{
   ...
   /**
    * If we picked up a newline, exit the loop.
    */
   if (nl == '\n')
     break;
}
</code></pre>
",0
9771804,9771758,1,"<p>Like this:</p>

<pre><code>system(""/bin/echo wibble wobble"");
</code></pre>

<p>But you almost certainly don't want to do that. When you try it and your system doesn't boot any more, next time edit inittab so that init runs your program rather than the other way round.</p>
",1
9771836,9771758,3,"<p>If you are a beginner, why are you <em>replacing the system's root bootup process</em>? That sounds like a rather dangerous thing to be doing. A bit like doing an <a href=""http://en.wikipedia.org/wiki/Shooting_an_apple_off_one%27s_child%27s_head"" rel=""nofollow"">apple shot</a> the first week of handling a rifle, or something. </p>

<p>That said, assuming your approach works, you need to format a string to contain the desired arguments, and then pass that string to  <code>system()</code>. Look at <code>snprintF()</code> for ideas on how to build a string easily.</p>
",1
9771897,9771758,1,"<p>Since system(3) is rather like calling a subroutine, you should use <code>fork()</code> to create a child process followed by a call to <code>execvp()</code>.</p>

<p>See <a href=""http://www.cs.uleth.ca/~holzmann/C/system/pipeforkexec.html"" rel=""nofollow"">Pipe, Fork, Exec and Related Topics</a></p>
",0
12283982,12283752,3,"<p>You can redirect the stdout or the stderr with something such as:</p>

<pre><code>stderr = freopen(""/dev/null"", ""w"", stderr );
</code></pre>

<p>and then you call smbc_opendir.</p>
",1
12284063,12283752,4,"<p>Try debug level 0, it shall log only critical errors: <code>smbc_init(auth_fn, 0)</code></p>
",3
10785290,10785267,1,"<p>You can make your variable a global, set it from the <code>initialization</code> method, and then just retrieve it inside the other methods.</p>

<p>You do this by declaring it <code>extern</code> and defining it in a single <code>.c</code> file.</p>
",0
10828422,10828181,2,"<p>Your array is stored in one continuous block of memory:</p>

<pre><code>index:      0       |       1       |      2       |      3        |      4
bytes: 0  1  2  3   |  4  5  6  7   |  8  9 10 11  |  12 13 14 15  | 16 17 18 19
values:    10       |      20       |      30      |     40        |      50
</code></pre>

<p>These questions will help you:<br>
<a href=""https://stackoverflow.com/q/6472662/1168156"">Address of first element in static declaration of array</a><br>
<a href=""https://stackoverflow.com/q/2126421/1168156"">How does this pointer arithmetic work?</a></p>
",0
9849376,9849287,1,"<p><strong>EDIT</strong></p>

<p>Ignore my original post, I am not thinking right on a Friday night. Your <code>while</code> loop test had a different problem as pointed out by Peter. However, you still need to check <code>temp != NULL</code> after the <code>malloc</code>.</p>
",6
9849455,9849287,2,"<pre><code>while ((ch = getchar()) != EOF) { // now you have your valid ch
  if (ch == '\n') break; // end-of-line is a quitter
}
</code></pre>

<p>EDITH says: abtract versus concret.
Okay, i go back one step and write your code in pseudocode</p>

<pre><code>while ((ch = getchar()) != EOF) {
  // this is a foreverloop until you hit end of file

  // now comes the state machine
  if (ch != NEWLINE) {
    // collect the string
    string.add(ch); // pseudocode
  } else {
    // do some accountings with the collected string
    list.add(string); // pseudocode
    string.print();
  }
}
</code></pre>
",3
16914601,16914330,1,"<p>When a program tries to access memory it has no privileges, the <code>Linux Kernel</code> interrupts the program by sending a signal called <code>SEGSEGV</code>. In your <code>fgets</code>, may be you are exceeding the memory you have allocated for your pointer by inputting too much text. Signals is one way the <code>Linux Kernel</code> communicates with the programs (processes in correct sense). It's kind of exception.</p>

<p>Since, you are dealing with files. It's worth checking if your file actually exists. May be you don't have privileges to read the file and hence getting the error.</p>

<p><code>/lib/i386-linux-gnu/libc.so.6</code> is a shared library on your <code>Linux</code> system in which <code>fgets</code> function resides and <code>0xb7d79a67</code> is (I guess) main memory address your program doesn't have privileges may be goes beyond the file length. </p>

<p>The <code>segmentation-fault(SEGSEGV)</code> can occur when you access protected memory areas, or the memory areas which are used by other programs and hence your program doesn't have any right to access.</p>

<p>Read these articles for better grasp:
      <a href=""http://www.cyberciti.biz/tips/segmentation-fault-on-linux-unix.html"" rel=""nofollow noreferrer"">Segmentation fault why?</a>, <a href=""http://www.cprogramming.com/debugging/segfaults.html"" rel=""nofollow noreferrer"">Debugging segmentation faults</a></p>
",1
10134839,10134805,0,"<p>Can you define 'rotate left' for a <code>signed int</code>?</p>

<p>I would simply cast <code>x</code> to an <code>unsigned int</code> and perform the rotation the way you have it right now.</p>

<p>On another note: does your code need to work on different architectures (not just 32-bit)? You may want to avoid hardcoding the <code>int</code> bitsize.</p>
",3
10134877,10134805,16,"<p>Current best practice for compiler-friendly rotates is <a href=""https://stackoverflow.com/questions/776508/circular-shift-rotate-operations-in-c"">this community-wiki Q&amp;A</a>.  The code from wikipedia doesn't produce very good asm with clang, or gcc older than 5.1.</p>

<p>There's a very good, detailed explanation of bit rotation a.k.a. circular shift on <a href=""http://en.wikipedia.org/wiki/Circular_shift"" rel=""noreferrer"">Wikipedia</a>.</p>

<p>Quoting from there:</p>

<pre><code>unsigned int _rotl(const unsigned int value, int shift) {
    if ((shift &amp;= sizeof(value)*8 - 1) == 0)
      return value;
    return (value &lt;&lt; shift) | (value &gt;&gt; (sizeof(value)*8 - shift));
}

unsigned int _rotr(const unsigned int value, int shift) {
    if ((shift &amp;= sizeof(value)*8 - 1) == 0)
      return value;
    return (value &gt;&gt; shift) | (value &lt;&lt; (sizeof(value)*8 - shift));
</code></pre>

<p>In your case, since you don't have access to the multiplication operator, you can replace <code>*8</code> with <code>&lt;&lt; 3</code>.</p>

<p><strong>EDIT</strong> You can also remove the <code>if</code> statements given your statement that you cannot use <code>if</code>.  That is an optimization, but you still get the correct value without it.</p>

<p>Note that, if you really intend to rotate bits on a <code>signed</code> integer, the interpretation of the rotated result will be platform dependent.  Specifically, it will depend on whether the platform uses <a href=""http://en.wikipedia.org/wiki/Two%27s_complement"" rel=""noreferrer"">Two's Complement</a> or <a href=""http://en.wikipedia.org/wiki/One%27s_complement"" rel=""noreferrer"">One's Complement</a>.  I can't think of an application where it is meaningful to rotate the bits of a signed integer.</p>
",11
10138570,10134805,4,"<pre><code>int rotateLeft(int x, int n) {
  return (x &lt;&lt; n) | (x &gt;&gt; (32 - n)) &amp; ~((-1 &gt;&gt; n) &lt;&lt; n);
}
</code></pre>

<p>UPDATE:(thanks a lot @George)</p>

<pre><code>int rotateLeft(int x, int n) {
  return (x &lt;&lt; n) | (x &gt;&gt; (32 - n)) &amp; ~(-1 &lt;&lt; n);
}
</code></pre>

<p>not use '-' version. </p>

<pre><code>int rotateLeft(int x, int n) {
    return (x &lt;&lt; n) | (x &gt;&gt; (0x1F &amp; (32 + ~n + 1))) &amp; ~(0xFFFFFFFF &lt;&lt; n);
}

//test program
int main(void){
    printf(""%x\n"",rotateLeft(0x87654321,4));
    printf(""%x\n"",rotateLeft(0x87654321,8));
    printf(""%x\n"",rotateLeft(0x80000000,1));
    printf(""%x\n"",rotateLeft(0x78123456,4));
    printf(""%x\n"",rotateLeft(0xFFFFFFFF,4));
    return 0;
}
/* result : GCC 4.4.3 and Microsoft(R) 32-bit C 16.00.40219.01
76543218
65432187
1
81234567
ffffffff
*/
</code></pre>
",7
12850580,12850513,0,"<p>Problem is that fflush(stdin) in function reiniciar() wasn't being read, because the function would return a value in previous lines.
So I moved it before the <code>return 1</code> in the <code>reiniciar</code> function and it solved it.</p>
",1
9814727,9814647,0,"<p>OK.. This looks like homework.. so I will point out a few things that are pretty obvious in the code above  </p>

<p>1) The condition you are checking for (link2->value == link2->value) is probably a typo. You might have meant link2->value == link1->value.<br>
2) You are iterating over every element in list 1 but NOT in list 2. So you are checking only if the first element in list 2 is found in list 1.   </p>

<p>I think this is sufficient.. for now.. :)</p>
",0
9814734,9814647,0,"<pre><code>if (link2-&gt;value == link2-&gt;value)
</code></pre>

<p>Should be </p>

<pre><code>if (link1-&gt;value == link2-&gt;value)
</code></pre>

<p>As pointed by gbulmer, you should also iterate over the second list and compare it to the first one.</p>
",0
9814746,9814647,0,"<p>You are close, in reality your method should look like this:</p>

<pre><code>struct Node *calcIntersection(struct Node *headA, struct Node *headB)
{
    struct Node *link1 = headA;

    while(link1 != NULL)
    {
        struct Node *link2 = headB;

        while (link2 != NULL)
        {
            if (link1-&gt;value == link2-&gt;value)
            {
              printf(""%d"", link1-&gt;value);
            }      

            link2 = link2-&gt;pNext;
        }

        link1 = link1-&gt;pNext;
    }

   return link1;
}
</code></pre>

<p>I'm not quite sure what you are returning there, but in most situations you will be returning NULL, I'm not quite sure if that's what you want however.</p>
",4
10146921,10146637,2,"<p>you repeatedly open filename <code>filelocation</code> but never close the file handle <code>f</code>. You would keep reading the first line over and over again and eventually run out of filehandles.</p>

<p>You can change filldata to take the file pointer  check the snippet below i have added 
some additional checks , you also need to check the <code>size of Data_point *a</code> is within the 
allocated range as you fill it up</p>

<pre><code>int filldata(struct Data_point *a, File *f) 


    if( fscanf(f, ""%ld%lf%d"", &amp;(a-&gt;sampleNumber), &amp;(a-&gt;value), &amp;(a-&gt;status)) == 3)
        return 1;   
    else
        return 0;
}

int fillAll(struct Data_point *a, const int data_point_size,const char *filelocation)// I will pass the struct array and the location of my file string
{

    FILE *f;
    if((f=fopen(filelocation,""r""))==NULL) {
        printf(""You cannot open"");
       return 0;
    }


    int index=0;
    while(index &lt; data_point_size &amp;&amp;  filldata(&amp;a[index]))  {
        index++;
    } 
    fclose(f);
    return (index != data_point_size);
 }
</code></pre>
",4
10147051,10146637,0,"<p>You are getting segmentation fault because of your while loop. It will never stop until the filldata returns 0. Before that happens, your program would have already crossed the array bounds when passing the &amp;a[index]. Also, i believe that there is no guarantee that filldata would return a 0 as when that happens as the program will first try to access that out of bound memory in fscanf() thus causing runtime error or taking a garbage value and considering it as a success.</p>

<p>Correct me if i am wrong.</p>
",0
14782973,14782919,2,"<p>It looks to me like you have things swapped. With fork/exec, you generally do the exec in the child process, and the waitpid in the parent process.</p>
",2
19806170,19806133,0,"<p><code>temp</code> is a copy of the contents of <code>data</code> placed on stack locally in your <code>reverse</code> function. In the strictest sense of the word, everything in C is pass-by-value. When we pass-by-value we are passing a copy of the variable to a function. <strong>It is copying the value of the array's address</strong>, into the function.</p>

<blockquote>
  <p>data = temp1; this works in reverse function, but does not work in main function. yes, that is default so once it comes outside the function it will not be present on stack</p>
</blockquote>

<p>That is not the only reason, <code>temp1</code> is a local array in reverse, you cannot access it outside your <code>reverse</code> function (since it is not global to be visible in <code>reverse</code>).</p>

<p>So there are 2 arrays</p>

<pre><code> +---+---+---+---+--+---+---+
 | I am megharaj from india |
 +---+---+---+---+--+---+---+ data1 in main
</code></pre>

<p>The above gets destroyed after execution of <code>main</code>.</p>

<pre><code> +---+---+---+---+--+---+---+
 | I am megharaj from india |
 +---+---+---+---+--+---+---+ temp1 in reverse
</code></pre>

<p>The above gets destroyed after execution of <code>reverse</code>.</p>
",0
19806345,19806133,0,"<p>You have 2 arrays, <code>Data1</code> and <code>Temp1</code>. and two pointers <code>Data</code> and <code>Temp</code>.<br>
Initially after entering the function, both <code>Data</code> and <code>Temp</code> points to the first element of <code>Data1</code>.<br>
Then you fill up <code>Temp1</code> using <code>Temp</code> as an index.<br>
Then you put <code>Data</code> to point to <code>Temp1</code>.<br>
Now, if you print <code>Data</code>, you are actually printing the elements of <code>Temp1</code>, So you see the reversed string.<br>
<strong>Notice, <code>Data1</code> is never changed in this process.</strong><br>
When you come out of the function, <code>Data</code>, <code>Temp</code> and <code>Temp1</code> does not exist as they are out of scope. <strong>But <code>Data1</code> still exist as its scope is function main()</strong>.<br>
<strong>After returning from the function, you are printing <code>Data1</code>, that is still holding initial values you set, it is never changed or destroyed</strong>. That's why, you don't see garbage value.</p>
",2
17823368,17823334,3,"<p>Use the <a href=""http://www.cplusplus.com/reference/cstdio/vsprintf/"" rel=""nofollow"">vsprintf</a> or <a href=""http://www.cplusplus.com/reference/cstdio/vsnprintf/"" rel=""nofollow"">vsnprintf</a> function.  Rather than taking a list of parameters it takes a va_list for its parameters.</p>

<p>You would call it as:</p>

<pre><code>vsnprintf(str, MAX_LINE_SIZE, listPointer);
</code></pre>
",0
17823388,17823334,1,"<p>Write variable argument functions in pairs:</p>

<pre><code>void ellipsis_function(const char *fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    valist_function(fmt, args);
    va_end(args);
}

void valist_function(const char *fmt, va_list args)
{
    vfprintf(stderr, fmt, args);
}
</code></pre>

<p>The first function should be very close to what I showed; there might be extra fixed arguments, and maybe a return value to capture, but otherwise it really is that simple.</p>

<p>The second function can do whatever you need, formatting data into strings with <code>vsnprintf()</code> et al, etc.</p>
",0
11115227,11115211,12,"<p>Nothing, <code>[]</code> is just syntactic sugar for a pointer.</p>

<p>Here's a simple test case to show that there's not even a difference in indexing:</p>

<pre><code>#include &lt;stdio.h&gt;

void fun1(int a[][3]) { printf(""%d\n"", a[2][2]); }
void fun2(int (*a)[3]){ printf(""%d\n"", a[2][2]); }

void main() {
  int a[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
  fun1(a);  // prints 9
  fun2(a);  // prints 9
}
</code></pre>
",0
11115257,11115211,3,"<p>Nothing, Both are same. Just for our convince purpose.</p>
",0
11115302,11115211,2,"<p>There is no difference between the above two. <strong>In C, when the array notation is used for a function parameter, it is automatically transformed into a pointer declaration</strong>.</p>
",0
13706922,13706890,1,"<p><code>for (i=0;(i=len);i++)</code></p>

<p><strong>Did you mean i &lt;= len</strong> ?</p>

<p><code>i=len</code> is an <code>assignment</code>, returns true if assignment succeeds.</p>

<p>So what happens is </p>

<p><em>i gets assigned the value of len, (which is successful) hence returns true.</em></p>

<p>Hence for loop condition gets satisfied.</p>

<p>What you need is</p>

<pre><code>           for (i=0;i&lt;=len;i++)
</code></pre>
",0
13706926,13706890,5,"<pre><code>for (i=0;(i=len);i++)
</code></pre>

<p>should be</p>

<pre><code>for (i=0;i&lt;=len;i++)
</code></pre>
",1
13706949,13706890,1,"<p>Your stuck in an infinite loop, the problem is with the <code>for</code> statement:</p>

<pre><code>for (i=0;(i=len);i++) {
</code></pre>

<p>You want <code>i&lt;=len</code>, not <code>i=len</code>. Your for loop right now is doing:</p>

<pre><code>i = 0, i = 8
if '\0' != '\0'
i++ (i = 9)
</code></pre>

<p>Then when it goes to ""check"" the condition it really just resets <code>i</code> to 8</p>
",0
13706971,13706890,2,"<p>Since you through the trouble to 0-terminate your array, just print it with:</p>

<pre><code>puts(word);
</code></pre>

<p>or</p>

<pre><code>printf(""%s\n"", word);
</code></pre>

<p>to get the line-feed.</p>

<p>No need to loop yourself and print one character at a time.</p>
",1
18943788,18943735,0,"<p>How about this:-</p>

<pre><code>#include &lt;stdio.h&gt;
void main()
{
FILE *fopen(), *fp;
char c;
int i=0,j=0;
char file[50][50];
fp = fopen(""abc.txt"",""r"");
c = getc(fp) ;
while (c!= EOF)
{
file[i][j]=c;

    j++;
    c = getc(fp);

    if(j==50){
    i++;
    j=0;
    }
}
fclose(fp);
}
</code></pre>
",3
18943899,18943735,2,"<p>Michael's comment is correct, I'd be surprised if that even compiles. You'll need to allocate your array dynamically, like so: </p>

<pre><code>char **array = malloc(sizeof(char *) * row)
</code></pre>

<p>And each row like: </p>

<p><code>array[c] = malloc(sizeof(char) * col)</code></p>

<p>You'll have to free each row and the array with free as well. </p>

<p>It also looks like you are trying read and store integer values. Keep in mind when you do get this working you'll still have to convert the character values if that is the case. </p>
",0
9800668,9800636,1,"<p>You'll have to learn/use some calculus in order to do this:</p>

<p><a href=""http://en.wikipedia.org/wiki/Natural_logarithm#Derivative.2C_Taylor_series"" rel=""nofollow"">http://en.wikipedia.org/wiki/Natural_logarithm#Derivative.2C_Taylor_series</a></p>

<p>Not very difficult to implement (unless you know ranges, I would say use a Maclaurin series, which, if memory serves correctly, should work well), but, little mistakes lead to big problems.</p>
",0
9801659,9800636,1,"<p>I would agree with Dhaivat that approximation via Taylor or Maclaurin series is the way to go should you need to implement natural logarithm yourself for an embedded system.</p>

<p>As to exponentiation, you might want to look here:
<a href=""https://stackoverflow.com/questions/101439/the-most-efficient-way-to-implement-an-integer-based-power-function-powint-int"">The most efficient way to implement an integer based power function pow(int, int)</a></p>

<p>Good luck,</p>
",0
9801895,9800636,0,"<p>The two usual solutions are Taylor series and lookup tables.</p>

<p>Choosing one over the other depends on two main aspects:</p>

<ul>
<li>maximum speed: lookup table wins</li>
<li>minimum memory: Taylor serie wins</li>
</ul>

<p>It is also guided by other aspects that impact the first two ones:</p>

<ul>
<li>range of input values</li>
<li>precision</li>
</ul>

<p>If precision can be loose, you may consider using a trick with floating point values: the exponent part of a value <em>x</em> actually is an approximation of <em>log2(x)</em>. Switching to/from <em>log2()</em> and <em>ln()</em> is easy if you know <em>ln(2)</em>.</p>
",0
12802198,12802185,12,"<p>This is a linker failure. You need to link with the math library, specify <code>-lm</code> at the end of your compiler command. From <a href=""http://linux.die.net/man/3/pow"" rel=""noreferrer"">man pow</a>:</p>

<blockquote>
  <p>Link with -lm. </p>
</blockquote>
",0
12802205,12802185,6,"<p>Math library is not part of libc. You need to link it:</p>

<pre><code>gcc file.c -lm -o file
</code></pre>
",0
12802239,12802185,0,"<p>The function <code>pow()</code> is defined in the math library. Your compiler by default is not linking your program with that library as a result of which the linker is unable the resolve the call to <code>pow()</code>. </p>

<p>To fix this you need to add <code>-lm</code> at the end of your compile/link line which links the math lib to your program.</p>
",0
12803932,12802185,0,"<p>I just ran the same program on my Turbo C and i got output as 341. Check whether your header files are in place in /include folder of your Turbo C folder. Make sure to check whether it contains a Math.h file.</p>
",0
10131286,10131198,4,"<p>You could get a random number between 0 and 100 and check what percentage range that falls in and assign the corresponding value to it.</p>

<p>For example:</p>

<pre><code>    0 - 5  : -1
    5 - 25 :  0
    25 - 31:  1
    31 - 48:  2
    48 - 50:  3
    50 - 75:  4
    75 - 87:  5
    87 - 100: 6
</code></pre>

<p><strong>EDIT:</strong></p>

<p>To implement this you would need one or two arrays, one that stores the percentage boundaries (meaning 5, 25, 31, 48, 50, 75, 87 in this case) and another array that stores the output values (if the outputs are completely random, here where they are sequential you wouldn't need a second array).<br>
Then you get call <code>rand() * 100.0 / RAND_MAX</code> to get a random float between 0 and 100 or <code>rand() % 100 + 1</code> for a random int between 0 and 100.</p>

<p>With this you can use a binary search method to find what percentage range this corresponds to in O(log n) time.  With the index you find the corresponding output (either via an array or a function)</p>
",1
10131290,10131198,0,"<p>I'm sure there are other, probably better, ways of doing this, but what comes to mind is this: Create an array containing appropriate copies of each number (-1 to 6) according to your percentages. Then randomly pick an element in the array.</p>
",1
10131311,10131198,1,"<p>Is this a homework assignment?  I'm going to assume not, for the sake of having faith in humanity ;)</p>

<p>So I mean, all your percentages should add up to 100 right?
You could generate a number between 0 and 100, and see which bracket it falls into.</p>

<p>i.e. If your percentages are [10,20,35,15,10,10] </p>

<p>Then the first bracket is ""&lt; 10"" so any number generated under 10 yeilds a 6</p>

<pre><code>x &lt; 10 --&gt; 6
10 &lt;= x &lt; (10+20) --&gt; 5
(10+20) &lt;= x &lt; (10+20+35) --&gt; 4
(10+20+35) &lt;= x &lt; (10+20+35+15) --&gt; 3
</code></pre>

<p>etc.  You'd want to generate a random float between 1 and 100 to satisfy precice percentages like 11.9 for instance.</p>
",1
10131314,10131198,0,"<p>I think the easiest way to do that is to consider the following analogy: </p>

<p>If you have a line [0,1], you can think that generating a number from 1 to 4 is equivalent to split the line in 4 segments, S_1 = [0,1/4], S_2 = [1/4,2/4], S_3 = [2/4,3/4], S_4 = [3/4,1]. That way, when you generate a number from [0,1], if it falls on the segment S_i, the generated number is i.</p>

<p>If you want to assign different probabilities to each number, say p_i, them you just have to divide the segment in different sizes, according with p_i.</p>

<p>For example, for 1 with p_1 = 0.1, 2 with p_2 = 0.4, 3 with p_3 = 0.2 and 4 with p_4 = 0.3 you can use the segments S_1 = [0,p_1], S_2 = [p_1,p_1+p_2], S_3 = [p_1+p_2,p_1+p_2+p_3] and S_4 = [p_1+p_2+p_3,p_1+p_2+p_3+p_4]</p>

<p>Then you generate a uniform random number on [0,1], and test whether it fell in S_i.</p>
",1
10131719,10131198,1,"<p>Make an array to have 100 elements, fill it with -1 to 6, depends on how much weight each needs. for example, if you need -1 to have 15% hit, you fill 15 elements with -1.
now generate a random number from 1 to 100, and simply look up the array, you get the actual results weighted.</p>
",2
12874579,12874499,2,"<p>First, your signal handler is not exactly async signal safe. In practice this is probably not a problem in your case, since I assume the main() is basically doing nothing while it is waiting for the signal. But it is definately not correct anyway.</p>

<p>As for why the program exits, not counting segfault:s in the signal handler due to invalid use of FILE* functions such as printf, sscanf etc, when the signal is received any system calls you are doing (or, well, most) will be interreupted with <code>EAGAIN</code>.</p>

<p>If you are using something like <code>sleep()</code> in main to wait for the signal to occur it will be interrupted. You are expected to restart it manually.</p>

<p>To avoid  this you probably want to use the significantly more portable <code>sigaction</code> interface instead of <code>signal</code>. If nothing else this allows you to indicate that you want system calls to be restarted.</p>

<p>The reason <code>that FILE *</code> functions (and most other functions that use global state such as <code>malloc</code> and <code>free</code>) is not allowed in signal handlers is that you might be in the middle of another operation on the same state when the signal arrives.</p>

<p>This can cause segfaults or other undefined operations.</p>

<p>The normal 'trick' to implement this is to have a self-pipe: The signal handler will write a byte to the pipe, and your main loop will see this (usually by waiting in <code>poll</code> or something similar) and then act on it.</p>

<p>If you absolutely want to do user interaction in the signal handler you have to use <code>write()</code> and <code>read()</code>, not the <code>FILE*</code> functions.</p>
",0
12874592,12874499,5,"<p>It depends on which standard you are adhering to, but Standard C doesn't allow you to do much more than modify a variable of type <code>volatile sig_atomic_t</code> or call <code>_Exit</code> (or <code>abort()</code> or <code>signal()</code>) from a signal handler.  POSIX is a lot more lenient.  Your code in your signal handler, replete with user interaction, is pushing beyond the limits of what even POSIX allows.  Normally, you want your signal handler function to be small and svelte.</p>

<p>Note that the signal handler function should be:</p>

<pre><code>void trata_sinal_int(int signum)
{
</code></pre>

<p>This allows you to compile without casts or compiler warnings about type mismatches.
The <code>signal()</code> function may reset the signal handler back to default behaviour when it is invoked; classically, it is necessary to reinstate the signal handler inside the signal handler:</p>

<pre><code>    signal(signum, trata_sinal_int);
</code></pre>

<p>So far, that's all pretty generic and semi-trivial.</p>

<p>When you type the <kbd>Control-C</kbd>, the system does go back to roughly where it was when the signal was originally received.  However, what happens next depends on where it was (one of the reasons you have to be so very careful inside the handler).  For example, if it was in the middle of manipulating the free list pointers inside <code>malloc()</code>, it would return there, but if you'd reinvoked <code>malloc()</code> inside the handler, all hell might be breaking loose.  If you were inside a system call, then your call may be interrupted (return with an error indication and <code>errno == EINTR</code>), or it may resume where it left off.  Otherwise, it should go back to where the calculation was running.</p>

<hr>

<p>Here's (a fixed up version of) your code built into a test rig.  The <code>pause()</code> function waits for a signal before returning.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;signal.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

static void trata_sinal_int(int signum)
{
    char op[2];

    signal(signum, trata_sinal_int);

    printf(""\nTerminate? (y/n)\n"");
    scanf(""%s"", op);

    if (op[0] == 'y')
    {
        printf(""Bye Bye\n"");
        exit(0);
    }
}

int main(void)
{
    signal(SIGINT, trata_sinal_int);
    for (int i = 0; i &lt; 3; i++)
    {
        printf(""Pausing\n"");
        pause();
        printf(""Continuing\n"");
    }
    printf(""Exiting\n"");
    return(0);
}
</code></pre>

<p>I should really point out that the <code>scanf()</code> is not very safe at all; a buffer of size 2 is an open invitation to buffer overflow.  I'm also not error checking system calls.</p>

<p>I tested on Mac OS X 10.7.5, a BSD derivative.  The chance are good that the resetting of <code>signal()</code> would be unnecessary on this platform, because BSD introduced 'reliable signals' a long time ago (pre-POSIX).</p>

<hr>

<h3>ISO/IEC 9899:2011 ¡ì7.14.1.1 The <code>signal</code> function</h3>

<blockquote>
  <p>?5 If the signal occurs other than as the result of calling the <code>abort</code> or <code>raise</code> function, the
  behavior is undefined if the signal handler refers to any object with static or thread
  storage duration that is not a lock-free atomic object other than by assigning a value to an
  object declared as <code>volatile sig_atomic_t</code>, or the signal handler calls any function
  in the standard library other than the <code>abort</code> function, the <code>_Exit</code> function, the
  <code>quick_exit</code> function, or the <code>signal</code> function with the first argument equal to the
  signal number corresponding to the signal that caused the invocation of the handler.
  Furthermore, if such a call to the <code>signal</code> function results in a <code>SIG_ERR</code> return, the
  value of errno is indeterminate.<sup>252)</sup></p>
  
  <p><sup>252)</sup> If any signal is generated by an asynchronous signal handler, the behavior is undefined.</p>
</blockquote>

<p>The references to <code>quick_exit()</code> are new in C2011; they were not present in C1999.</p>

<h3>POSIX 2008</h3>

<p>The section on <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_04"" rel=""nofollow"">Signal Concepts</a> goes through what is and is not allowed inside a signal handler under POSIX in considerable detail.</p>
",2
10132970,10132906,7,"<p>Since this looks like homework I'm not going to post code, but list the steps you need to perform:</p>

<ol>
<li>Cast <code>c</code> into a 32-bit number so you don't lose any bits while shifting</li>
<li>Next, shift <code>c</code> by the appropriate number of bits to the left (if <code>n==0</code> no shifting, if <code>n==1</code> shift by 8 etc.)</li>
<li>Create a 32-bit bitmask that will zero the lowest 8 bits of <code>x</code>, then shift this mask by the same amount as the last step</li>
<li>Perform bitwise AND of the shifted bitmask and <code>x</code> to zero out the appropriate bits of <code>x</code></li>
<li>Perform bitwise OR (or addition) of the shifted <code>c</code> value and <code>x</code> to replace the masked bits of the latter</li>
</ol>
",4
10134743,10132906,6,"<p>Ahh... You are almost there.</p>

<p>Just change</p>

<pre><code>return (mask &amp; x) | shift; 
</code></pre>

<p>to</p>

<pre><code>return (~mask &amp; x) | shift;
</code></pre>

<p>The <code>mask</code> should contain all ones except for the region to be masked and not vice versa.</p>

<p>I am using this simple code and it works fine in gcc</p>

<pre><code>#include&lt;stdio.h&gt;

int replaceByte(int x, int n, int c) 
{
    int shift = (c &lt;&lt; (8 * n));
    int mask = 0xff &lt;&lt; shift;
    return (~mask &amp; x) | shift;
}

int main ()
{

    printf(""%X"",replaceByte(0x80000000,0,0));

    return 0;
}
</code></pre>
",1
10180290,10179622,0,"<p>If your data is formatted this way: {0 /Data1/ , 0x00, 0, 0xFF} u can search the bracket at the end of the data line.</p>

<p>Example(not the full solition)</p>

<pre><code>char data[] = ""{0 /Data1/ , 0x00, 0, 0xFF},""

//find the back bracket position

int i=0;
while( i &lt; strlen(data) &amp;&amp; data[i]!='}')
 i++;

if(i&lt;strlen(data))
 bracketposition = i;
</code></pre>

<p>When you find the position of bracket rewind for word size (if it is not standart search for the whitespace) and read the value between this two positions (whitespace position and bracket position)</p>
",0
10181261,10179622,1,"<p><a href=""http://crasseux.com/books/ctutorial/sscanf.html"" rel=""nofollow"">sscanf()</a> should do the trick.</p>

<p>It uses a format string just like printf(), then reads the values into variables.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    unsigned int a, c, d, e;
    char b[101] = """";
    char filename[] = ""file.txt"";
    FILE *file = fopen(filename, ""r"");
    if (file != NULL) {
        char line[128];
        while (fgets(line, sizeof line, file) != NULL) {
            sscanf(line, ""{%d %100s , %x, %d, %x}"", &amp;a, b, &amp;c, &amp;d, &amp;e);
            printf(""%d %X\n"", d, e);
        }
        fclose(file);
    } else {
        perror(filename);
    }
    return 0;
}
</code></pre>
",2
11502535,11502407,1,"<p>There is not an error in it.Both program gives an output of 8 which is correct.</p>
",0
11502605,11502407,5,"<p>The conditional operator has higher precedence than the assignment operator. You need extra parentheses to have the desired precedence.</p>

<pre><code>k &lt; m? k = k + 1 : m = m + 1;
</code></pre>

<p>is evaluated as</p>

<pre><code>((k &lt; m) ? (k = k + 1) : m) = m + 1;
</code></pre>

<p>Add parentheses to have the correct precedence:</p>

<pre><code>(k &lt; m) ? (k = k + 1) : (m = m + 1);
</code></pre>
",3
10180926,10180701,0,"<p>You could use a dynamically allocated array, which you grow as you need more space.
See <a href=""https://stackoverflow.com/questions/4269756/array-with-variable-size-in-c"">Why does a large variable length array has a fixed value -1 even if assigned to in C?</a> for more help.</p>
",2
10181380,10180701,1,"<p>You are saving only the first char of string word1 into word2.</p>

<p>If you want store all 2nd columns you need to alloc a dynamic array of pointers to (char *) and then to each word/column alloc space to the word and copy with a strcpy because word1 is changing on each iteration of while so you can't save only the refence.</p>
",0
10183657,10180701,0,"<p>Try something like this:</p>

<pre><code>#define MAX_BUFFER_SIZE 256
/* ... */

char ** lines = malloc(MAX_BUFFER_SIZE + 1);
char ** p = lines;
char ** newbuf;
int len;
int bytesloaded = 0;  
int buf_size = MAX_BUFFER_SIZE;  
assert(lines != NULL);
//... loop etc.. 

if(i==2 ){
   len = strlen(word1);
   bytesloaded += len;

   if(bytesloaded &gt;= buf_size) /* Controls buffer size. For avoid buffer overflow/heap corruption/UB. */
   {
      buf_size += MAX_BUFFER_SIZE;
      newbuf = realloc(lines, buf_size);

      if(!newbuf)  /* return or break. */ 
      {  
        printf(""Allocation failed.\n"");
        free(lines);
        return 1;
      }

       lines = newbuf;
    }

    *p++ = word1; /* store the word in lines */
    printf(""%s\n"",word1);
}
</code></pre>

<p>Note: Don't forget to put the 0-terminator,<code>\0</code>, in array, after end of first loop.</p>

<p>I haven't tested this code,but I believe that it works.</p>

<p>It a simple example how to do: <a href=""http://en.wikipedia.org/wiki/C_dynamic_memory_allocation"" rel=""nofollow""><code>a dynamic memory allocation</code></a>,control the size of it,memory re-allocation and values storage.</p>
",0
11807661,10398133,0,"<p>The effect of this ptr++ will take place only after ';'
ptr++  is equivalent to ptr = ptr + 1; but this will done only
after semicolon of that statement.
ptr value will be arr[0] during the operation *(ptr++)+= 123;
but after that statement ptr will be equivalent to arr[1]</p>
",1
10116703,10116613,1,"<p>There are a bunch of type errors that will spill out with <code>-Wall</code> (as suggested by @user120115).</p>

<p>A few things that jump out right away:</p>

<ul>
<li>don't cast <code>malloc</code> (in C; don't even <em>use</em> <code>malloc</code> in C++ unless there's some good reason to avoid <code>new</code>)</li>
<li>any loop of the form <code>while (!feof(stream))</code> is probably wrong, because <code>feof</code> does not predict a future EOF, it tells you only why a previous read-attempt failed (e.g., why <code>getchar</code> returned <code>EOF</code>).  The point of <code>feof</code> is to distinguish between ""normal"" read failure due to end of file, and ""unusual"" (<code>ferror</code>) read failure due to Disk Drive Caught Fire or whatever.</li>
<li><code>InsertArtist</code> needs to modify a list, so it either has to return the new list, or take a pointer to the old pointer-to-list, but it does neither.  (But the various <code>findOrInsert</code> functions do!)</li>
</ul>

<p>I'm also with @sarnold on limiting the use of <code>typedef</code>, although this is admittedly a matter of taste.</p>
",0
10116707,10116613,1,"<p>As a start compile with, if you are using GCC, </p>

<blockquote>
  <p>gcc -Wall -Wextra -pedantic -o myprog myprog.c</p>
</blockquote>

<p>On my system I get:</p>

<pre><code>song.c: In function ¡®main¡¯:
song.c:75:16: warning: variable ¡®theArtist¡¯ set but not used [-Wunused-but-set-variable]
song.c:74:12: warning: variable ¡®track¡¯ set but not used [-Wunused-but-set-variable]
song.c:74:6 : warning: variable ¡®year¡¯ set but not used [-Wunused-but-set-variable]

song.c: In function ¡®findOrInsertArtist¡¯:
song.c:162:7: warning: assignment from incompatible pointer type [enabled by default]
song.c:163:2: warning: passing argument 1 of ¡®InsertArtist¡¯ from incompatible pointer type [enabled by default]
song.c:50:6 : note: expected ¡®struct artist *¡¯ but argument is of type ¡®struct artist **¡¯
song.c:166:8: warning: assignment from incompatible pointer type [enabled by default]
song.c:167:2: warning: return from incompatible pointer type [enabled by default]

song.c: In function ¡®initializenode¡¯:
song.c:197:1: warning: control reaches end of non-void function [-Wreturn-type]

song.c: In function ¡®main¡¯:
song.c:158:1: warning: control reaches end of non-void function [-Wreturn-type]
</code></pre>

<p>Take special heed to everything but -Wunused, then check if those unused variables should have been used and there is some fail to the logic of the code.</p>

<p>Then, when you manage to compile without warnings run the program with valgrind (if on windows I'm not sure; perhaps you can find something useful here: <a href=""https://stackoverflow.com/questions/413477/is-there-a-good-valgrind-substitute-for-windows"">is-there-a-good-valgrind-substitute-for-windows</a>)</p>

<hr>

<p>Edit:<br />
I notice you say you use Code::Blocks. I would recommend using an editor like Vim etc. + compiling on command line. Especially to begin with.</p>

<p>Even so; as mentioned in comment above, you can modify warning level by going to:</p>

<pre><code>""Settings"" &gt; ""Compiler and debugger ..."" &gt; [Compiler Flags]=&gt;[Warnings]
</code></pre>

<p>To get debug add <code>-ggdb</code> to <code>[Other options]</code>. If you only want to change this on a project base - you find the same options under:</p>

<pre><code>""Project"" &gt; ""Build options ...""
</code></pre>

<hr>

<p>When you have compiled with debug symbols you can run the program in debug mode.</p>

<p>Simple procedure:</p>

<ol>
<li><p>Right-click somewhere in your code where you want the execution to stop. Select ""Toggle Breakpoint"".</p></li>
<li><p><kbd>F8</kbd> starts the program in debug mode.</p></li>
<li><p>Then press <kbd>F7</kbd> to step line by line.</p></li>
<li><p>... (Basic keys are in ""Debug"" menu.)</p></li>
</ol>

<p>While running, you can also right-click a variable and select <em>Watch</em>, i.e. <em>""watch 'discTemp'""</em>. And, if not present, select ""Debug"" > ""Debugging windows"" > ""Watches"".</p>

<p>Now you will see the value etc. of the variable as you step trough the code.</p>

<p><code>gdb</code> can also be used on command line. <code>$ gdb -args ./my_prog arg arg</code></p>

<p>Valgrind, as mentioned before, is also a very useful tool. You will get information about bad behavior in your process. Even if the code compile without error or warning, it is not said that the program is sane.</p>

<p>Valgrind is also implemented in Code::Blocks, even better would perhaps be to say:</p>

<pre><code>$ valgrind ./my_prog arg arg ...
</code></pre>

<p>And as a last point: compile all the time. Write a few lines. Compile. Make one change compile. ...</p>

<hr>

<p>These are some hints on how to make the coding much less painful. Hope it helps.</p>

<hr>

<p>Beside the notes mentioned by other people here I also want to add:</p>

<ul>
<li><p>In your <code>menu</code> loop, you <strong><em>have to</em></strong> check if <code>scanf()</code> returns 1, (1 being successfully read elements, ""%d"" in your case) - and if not, empty buffer. As it is now anything but an integer would result in an infinite loop.</p></li>
<li><p>In <code>getNextLine()</code> you have a <code>while()</code> loop at the end that say <code>get character from file while character is not newline.</code> If file does not end in newline this is another infinite loop. Also read the comments by @sarnold and @torek regarding this function.</p></li>
</ul>

<hr>

<p>Ps: To add command line arguments in Code::Blocks you have to use:</p>

<blockquote>
  <p>""Project"" > ""Set program's arguments"" </p>
</blockquote>
",0
10819928,10819873,3,"<p><code>time()</code> returns type <code>time_t</code>, which is 64 bit on many platforms, while <code>""%d""</code> refers to <code>int</code> which is mostly 32bit.</p>
",0
10819935,10819873,2,"<p>The <code>%d</code> format specifier means that <code>printf</code> is expecting an <code>int</code> type.  But <code>time()</code> returns a <code>time_t</code>; if that's bigger than an <code>int</code>, then more stuff will be put on the stack than <code>printf</code> is expecting, essentially offsetting the position of all subsequent arguments (so the upper bytes of the time value are interpreted as the second argument, in your case).</p>

<p>(To confirm, you should compare <code>sizeof(int)</code> and <code>sizeof(time_t)</code>.)</p>

<p>For potential solutions, see the answers to e.g. this question: <a href=""https://stackoverflow.com/questions/2792551/what-primitive-data-type-is-time-t"">What primitive data type is time_t?</a>.</p>
",0
10819975,10819873,1,"<p>The result of <code>time()</code> (on Windows at least) is a 64-bit integer. You must use a format other than <code>%d</code> to print it. Try <code>%lld</code>.</p>

<p>It worked when the time was last because you got the lower 32 bits, since Intel is a little-endian processor.</p>
",0
12335620,12334215,2,"<pre><code>for (int i = 0; i &lt; 8; i++)
    array |= binary[i] &lt;&lt; i;
</code></pre>
",0
12334249,12334215,2,"<p>If I understand you right, something like this should work...</p>

<pre><code>int binary[8];
char array = 0;

int n = 8;
while (n) {
  array |= binary[--n];
  array &lt;&lt;= 1;
}
</code></pre>

<p>This should work in any C99-compliant environment where <code>CHAR_BIT</code> is at least <code>8</code>.</p>
",0
13715889,13715777,0,"<p>I don't think that there is such function even at windows.h,coca.h or unistd.h.
Most probably you write it yourself. Just make a </p>

<pre><code>struct myFile {
FILE *fh;
char *filename;
}
</code></pre>

<p>and hold such structures into array of <code>struct myFile</code> and in <code>MagicFunction(f,b)</code> walk on the array looking for the address equal to <code>f</code>.</p>
",0
13715788,13715777,2,"<p>There is no such standard function.</p>
",0
13715801,13715777,8,"<p>There is no such function. There may be no filename, or more than one filename that correspond with the <code>FILE *</code>. On Unix, a program can continue to have a reference to a file after it has been renamed or deleted, which could mean that you have a <code>FILE *</code> with no name. Or more hard links may be made to the file, which means a file can have multiple names; which one would you choose? To further confuse things, a file can be temporarily hidden, by mounting a filesystem over a directory containing that file. The file will still be on disk, at its original pathname, but the file will be inaccessible at that path because the mount is obscuring it.</p>

<p>It's also possible that the <code>FILE *</code> never corresponded to a file on the filesystem at all; while they usually do, you can create one from any file descriptor using <a href=""http://pubs.opengroup.org/onlinepubs/7908799/xsh/fdopen.html"" rel=""nofollow""><code>fdopen()</code></a>, and that file descriptor may be a pipe, socket, or other file-like object that has never had a path on the disk. In some versions of the C library, you can open a string stream (for instance, <a href=""http://www.gnu.org/software/libc/manual/html_node/String-Streams.html#String-Streams"" rel=""nofollow""><code>fmemopen()</code></a> in glibc), so the <code>FILE *</code> actually just corresponds to a memory buffer.</p>

<p>If you care about the name, it's best to just keep track of what it was named when you opened the file.</p>

<p>There are some hacky ways to approximate getting the filename; if you're just using this for debugging or informational purposes, then they may be sufficient. Most of these will require operating on the file descriptor rather than the <code>FILE *</code>, as the file descriptor is the lower level way of referring to a file. To get the file descriptor, run <a href=""http://www.gnu.org/software/libc/manual/html_node/Descriptors-and-Streams.html"" rel=""nofollow""><code>fileno()</code></a> on the <code>FILE *</code>, and remember to check for errors in case there is no file descriptor associated with that <code>FILE *</code>.</p>

<p>On Linux, you can do <a href=""http://www.kernel.org/doc/man-pages/online/pages/man2/readlink.2.html"" rel=""nofollow""><code>readlink()</code></a> on <a href=""http://www.kernel.org/doc/man-pages/online/pages/man5/proc.5.html"" rel=""nofollow""><code>""/proc/self/fd/fileno""</code></a> where <code>fileno</code> is the file descriptor. That will show you what filename the file had when the file was opened, or a string indicating what other kind of file descriptor it is, like a socket or inotify handle. FreeBSD and NetBSD have Linux emulation layers, which include emulation of Linux-style procfs; you may be able to do this on those if you mount a Linux-compatible procfs, though I don't have them available for testing.</p>

<p>On Mac OS X, you don't have <code>/proc/self/fd</code>. If you don't care about finding the original filename, but some other filename that refers to the file would work (such that you could pass it to another program), you can construct one: <code>/.vol/deviceid/inode</code>. For example, <code>/.vol/234881030/281363</code>. To get those values, run <a href=""https://developer.apple.com/library/mac/#documentation/Darwin/Reference/ManPages/man2/fstat.2.html"" rel=""nofollow""><code>fstat()</code></a> on the file descriptor, and use <code>st_dev</code> and <code>st_ino</code> on the resulting <code>struct stat</code>.</p>

<p>On Windows, files and the filesystem work quite differently than Unix. Apparently it's possible to map a file back to its name on Windows. As of Windows Vista, you can simply call <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa364962%28v=vs.85%29.aspx"" rel=""nofollow""><code>GetFinalPathNameByHandle()</code></a>. This takes a <code>HANDLE</code>; to get the <code>HANDLE</code> from the file descriptor, call <a href=""http://msdn.microsoft.com/en-us/library/ks2530z6.aspx"" rel=""nofollow""><code>_get_osfhandle()</code></a>. Prior to Windows Vista, you need to do a little more work, as described in <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa366789%28v=vs.85%29.aspx"" rel=""nofollow"">this article</a>. Note that on Windows <code>fileno()</code> is named <code>_fileno()</code>, though the former may work with a warning.</p>

<p>Going even further into hacky territory, there are a few more techniques that you could use. You could shell out to <a href=""http://people.freebsd.org/~abe/"" rel=""nofollow""><code>lsof</code></a>, or you could extract the code it uses to resolve pathnames. <code>lsof</code> actually looks directly in kernel memory, extracting information from the kernel's name cache. This has several limitations, outlined in <a href=""ftp://lsof.itap.purdue.edu/pub/tools/unix/lsof/FAQ"" rel=""nofollow"">the <code>lsof</code> FAQ</a>. And of course, you need root or equivalent privileges to do this, either directly or with an suid/sgid binary.</p>

<p>And finally, for a portable but slow solution for finding one or more filenames matching an open file, you could find the device and inode number using <code>fstat()</code> on the file descriptor, and then recursively traverse the filesystem <code>stat()</code>ing every file, until you find a file with matching device and inode number. Remember the caveats I mention above; you may find no matching files, more than one matching file, and even if you don't find any matching files, the file might still be there, but hidden by a mount point. And of course, there may be race conditions; something may rename the file in such a way that you never see it while traversing the hierarchy.</p>
",4
13715853,13715777,0,"<p>Do you <code>fopen()</code> yourself? If then, maintain <code>FILE *</code> to filename hash table yourself.</p>

<p>Otherwise, it's not possible in general.</p>
",0
15854278,9567432,0,"<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdbool.h&gt;

int main(void)
{
char c = '\0';
int nw = 0,nc = 0,nl = 0;

bool flag = true;
bool last = false,cur = false;

while(flag &amp;&amp; (c = getchar())) {

    if(c != EOF)
        ++nc;
    else
        flag = false;

    if(c == '\n') nl++;

    cur = (c == EOF || c == ' ' || c == '\t' || c == '\n')?false:true;

     if(last  &amp;&amp; !cur )
        ++nw;

    last = cur;
}


printf(""\nNo of chars : %d"",nc);
printf(""\nNo of lines : %d"",nl);
printf(""\nNo of words : %d"",nw);

return 0;
}
</code></pre>
",0
10165369,10164545,0,"<p>First, you're not asking a question anywhere - what do you want to know, really?</p>

<p>I can make an educated guess, but if that's wrong, I've wasted my time...</p>

<p>Provided that what you show us is correct, then, as you say, the functions use single values as positions. That means that the single values are actually vectors, so that k={kx, ky, kz} in 3 dimensions and k={k1, k2, ..., kn} in n dimensions. The '1' is the unity vector with all dimensions equal to 1.</p>

<p>To <strong>understand</strong> the functions you need to read up on linear algebra and vector analysis.</p>
",0
10166369,10165744,0,"<p>not looked into the entire code so  there may be other bugs but ith regard to the 'ls' issue you need to add the following to the parse code :</p>

<pre><code>      while (buff[j] != '\0' &amp;&amp; buff[j]  != '\n')
</code></pre>

<p>this ensures you don't add  'newline' to the command pointer at <code>*ptr1++ = (char) buff[j];</code></p>

<p>Note <a href=""http://www.cplusplus.com/reference/clibrary/cstdio/fgets/"" rel=""nofollow"">fgets</a> if it encounters new line would stop reading but would include it as part of the string.</p>
",0
10166904,10165744,2,"<ul>
<li>Your main program should include <code>myshell.h</code> like your parsing code does.</li>
<li>It would be helpful to have the missing functions (such as <code>countcmd()</code> and <code>countpipes()</code> &mdash; it isn't clear precisely what those do, though we can guess a bit from their names).</li>
<li>You should have include <code>&lt;unistd.h&gt;</code> in your main program.</li>
<li>You should have been getting warnings about undeclared functions (such as <code>fork()</code>), and you should be heeding and fixing those warnings.
<ul>
<li>If you were not getting those warnings, you need to add more warning options to your compilation.</li>
<li>If you use <code>gcc</code>, using <code>-Wall</code> is a good starting point.</li>
</ul></li>
</ul>

<p>With the warnings enabled, you get to see:</p>

<pre><code>shex.c:95: warning: passing argument 2 of ¡®execvp¡¯ from incompatible pointer type
shex.c:99: warning: ¡®return¡¯ with no value, in function returning non-void
</code></pre>

<ul>
<li>The latter is best handled via <code>return EXIT_FAILURE;</code> or <code>exit(EXIT_FAILURE);</code>.</li>
<li>The former is triggered by <code>execvp(""ls"", *argument);</code>.</li>
<li>It might be better to use a plural word (arguments?) for something that contains many arguments.</li>
<li>...Oh, I see, there is a global variable <code>arguments</code>.</li>
<li>You declare <code>char ***arguments;</code>.  <em>Ouch!</em>  I have used a triple pointer occasionally, but only very occasionally.  That's one too many levels of pointer most of the time, and especially for this exercise.</li>
<li>Then there's also a local variable <code>char *argument[2];</code>.</li>
<li>The correct call is, therefore, <code>execvp(""ls"", argument);</code>.</li>
</ul>

<p>I would immediately expand on the waiting code to at least print the information:</p>

<pre><code>    else
    {   
        int status;
        int corpse = waitpid(processid, &amp;status, WIFEXITED(status));
        printf(""Command exited: PID = %d; status = 0x%.4X\n"", corpse, status);
    } 
</code></pre>

<p>In your parsing code, the <code>case ';':</code> drops through into the <code>case ' ':</code>.  If that's intentional, document it (with a comment such as <code>/* DROP THROUGH */</code>); if not, insert the missing break.  Your <code>default:</code> case should probably have a break after it too.  It isn't quite crucial, but it is conventional and protects you from drop through if a new case needs to be handled.</p>

<p>The string of five variables declared at the end of <code>parse()</code> are superfluous; they're local variables that are never used (as the compiler tells you).</p>

<p>At the top of the <code>main()</code> you do:</p>

<pre><code>FILE *p;
p = fdopen(0, ""r"");  //opens FD 0 (Stdin) as a stream
</code></pre>

<p>This is not necessary; <code>stdin</code> is already open as a stream.</p>

<p>You read from <code>p</code> (aka <code>stdin</code>) with <code>fgets()</code>.  On the whole, this is good (better than <code>gets()</code>), but you need to be aware that <code>fgets()</code> includes a newline which <code>gets()</code> does not, and you need to check the return status (you might not read anything).  You should also use <code>sizeof()</code>:</p>

<pre><code>if (fgets(buff, sizeof(buff), stdin) == 0)
    ...error - read failed...
</code></pre>

<p>The memory allocation is extraordinarily complex.  For a fixed size input like <code>char buff[100];</code>, you can afford to use non-dynamic allocation.  There can't be more than about 50 arguments total, since they're blank separated.</p>

<p>Etc.</p>
",0
13437477,13437458,2,"<p>You are not using the return value of your recursive calls.</p>

<pre><code>   if(*str != ' ')
       rPrint(str+1, count);
   else
       rPrint(str+1, count - 1);
</code></pre>

<p>should be</p>

<pre><code>   if(*str != ' ')
       count = rPrint(str+1, count);
   else
       count = rPrint(str+1, count - 1);
</code></pre>
",0
13437478,13437458,1,"<p>When you recurse, you throw away the result.  Try</p>

<pre><code>count = rPrint(str+1, count);
</code></pre>

<p>etc.</p>

<p>More generally, as a debugging method you should learn to put <code>printf()</code> statements into your functions to print out what they're doing....</p>
",0
10181540,10181463,0,"<p>You didn't specify how long or what exactly is stored in <code>Data</code>.</p>

<p><code>char *</code> normally points to an array of characters. </p>

<p>You are probably getting a null-pointer because <code>char* Data</code> has not been initialized with any string of data whatsoever.</p>

<p><code>result = *Data;</code> will get you the first character, but you must first have data inside your <code>Data</code> variable to begin with</p>
",0
10181541,10181463,2,"<p>Your code is correct, but you need to check that ""Data"" may be null - which is why you're experiencing your null pointer assignment. Make sure you're using ""Data"" to iterate over your char array correctly.</p>
",1
10183320,10183279,9,"<p>your code in 'that' includes:</p>

<pre><code>if (aa == i);
//          ^
   printf(...);
</code></pre>

<p>[note the <code>;</code> at the end of the if condition]</p>

<p>Thus, if <code>aa == i</code> - an empty statement happens, and the print always occures, because it is out of the scope of the if statement.</p>

<p>To avoid this issue in the future, you might want to use explicit scoping<sup>1</sup> [using <code>{</code>, <code>}</code> after control flow statements] - at least during your first steps of programming the language.  </p>

<hr>

<p>1: spartan programmers will probably hate this statement</p>
",3
9854830,9854721,3,"<p>The solution to this program is to use the valgrind tool. </p>
",2
9857076,9854721,1,"<p>As bmargulies suggested, use Valgrind.
If you are on OS which does not support valgrind, I would suggest Purify, I don't believe there are any free solutions for non-Linux platforms.
If you can reproduce same issue on Windows, sprinkle your code with calls to _CrtCheckMemory, that will narrow down the problem - this isn't as good as Purify on Windows, but it's free.</p>
",3
10187572,10187509,1,"<p>The difference is that your <code>struct</code> is allocated dynamically in the first case and automatically in the second. That's a matter of personal preference, coding standards and opinion. Second way seems safer to me because its one less <code>free</code> to remember to do, but since you've got to <code>free</code> anyway - doesn't really matter all that much.</p>

<p>Note that in the second case the <code>struct</code> is copied into the return value. You seem to be dealing with the pointer in it well, but its a potential landmine right there.</p>
",1
10188277,10187509,1,"<p>i would go with the first. assume you have a descriptor'char name[100]' in your struct, your second would use 100byte of stackspace, which must be handled by the operating system, whereas the first memory my be handled by yourself (using a selfwritten garbage collector instead of the standard malloc) and you can move the handle to the object around as you please without having to take care of your limitied stack space.</p>
",1
10188754,10187509,2,"<p>You're talking about API. So it's crucial that <strong>it should be easy for your clients to use correctly and hard to use incorrectly</strong>.</p>

<p><strong>A small improve on option #2</strong></p>

<p>For example, if I'm the user of your second API:</p>

<pre><code>image imagecreate(int w, int h);
void imagefree(image *img);
</code></pre>

<p>I probably won't even notice the need to call <code>imagefree</code> because <code>imagecreate</code> returns an object, not a pointer to an object, while <code>imagefree</code> needs a pointer. I may think that <code>imagefree</code> is only a wrapper of <code>delete image</code> for a heap allocated object. So I won't use it for a ""stack"" object.</p>

<p>Therefore, this is better:</p>

<pre><code>image imagecreate(int w, int h);
void imagefree(image img);
</code></pre>

<p>While you have a heap-allocated member inside <code>image</code>, but you hide it in these APIs which is good. And they have consistent ""lookings"" which is better, and less error-prone.</p>

<p><strong>So what about option #1?</strong></p>

<p>As to your first option, is that even better? That depends (on individuals). As to me, I perfer option #1.</p>

<pre><code>image *imagecreate(int w, int h);
void imagefree(image *img);
</code></pre>

<p><em>Why?</em></p>

<p>Although we don't have a way to enforce the resource auto destruction by destructor like RAII in C++, usually more attention is paid for C programmers who see a ""pointer"" returned from an API(we are sensitive to pointers, aren't we? ;). It's much likely that they keep asking themselves: is it dynamicly allocated inside <code>imagecreate</code>? Do I need  deallocate it via some other API?</p>
",1
11557290,11557237,6,"<p>The problem is with the scope. Your variables (<code>fo</code> &amp; <code>ba</code>)  have local scope as they are declared within <code>main</code>.So, their visibility is restricted to within <code>main</code> function. Please make them global variables and it should work.</p>
",0
11557306,11557237,3,"<p>The error message indicates that the linker is unable to find <code>fo</code> and <code>ba</code>.  With the <code>extern</code> declaration you have told the compiler that the variables will exist in some other translation unit, but they don't.</p>

<p>You need to move the <code>struct foo fo;</code> and <code>struct bar ba;</code> outside of the <code>main()</code> function.  Right now, they are function local variables.  They need to be global variables for this to work.</p>
",1
10172783,10172425,0,"<p>Add this code then run it:</p>

<pre><code>tempchr=buffer[j];
if(tmpchr &lt; 97 || (tmpchr-97 &gt; 26))
{
  printf(""bug found"");
}
strcpy(&amp;huffmancode[0],code[tempchr-97]);
</code></pre>
",0
10172898,10172425,0,"<p>Here's one problem:</p>

<pre><code>fputc(length,output);
</code></pre>

<p>This will only write the lowest (least-significant) byte of <code>length</code> (which is an <code>int</code>) to the output file. It will write it in binary form, which seems very odd for a file opened with a <code>.txt</code> extension.</p>

<p>You probably want:</p>

<pre><code>fprintf(output, ""%d\n"", length);
</code></pre>
",0
10172912,10172425,2,"<p>You have commented that all characters in your file are just small letters so their code is >= 97. But it is possible that there is a new line at the end of the file (some editors will put it even if you didn't had a new line), which is causing the bug.</p>

<p>Note that unlike gets, fgets include the newline character in the buffer (see <a href=""http://www.cplusplus.com/reference/clibrary/cstdio/fgets/"" rel=""nofollow"">fgets</a>).</p>
",0
10770204,10769824,2,"<p><code>write()</code> takes a pointer to a buffer of data to write, not a character (which is essentially a number).</p>

<p>The answer is simple, instead of passing <code>c</code> to <code>write()</code>, pass the address of <code>c</code>, ie. <code>&amp;c</code>.</p>
",2
11115691,11115474,7,"<p><code>linkfloat</code> is an anachronism from the days of Turbo C when early Intel CPUs did not have hardware floating point support (1980s) and instead relied on software floating point libraries which needed to be linked into any executable that required floating point support. You do not need such anachronisms with any reasonably modern x86 CPU and C compiler (anything from the last 20 years or so). I suggest you ditch any bad/outdated text books or course material which still refers to such things (the books by Kanetkar which are still in use at some Indian colleges are particularly bad in this respect)</p>
",0
11586460,11586340,6,"<p>Because none of these pragmas are recognized by <a href=""http://gcc.gnu.org/onlinedocs/gcc/Pragmas.html"" rel=""noreferrer"">GCC</a>. In general, stay clear of pragmas if you're trying to write portable code, because they differ per compiler and even per platform within the same compiler family.</p>
",0
13772627,13772446,0,"<p>It isnt that it overflows, Ive tested it with this code.</p>

<pre><code>unsigned long long num = 18446612134627563776;
char c[100];
unsigned int i = 0;

do {
    //print here
    c[i++] = '0'+ (char)(num - (num/10)*10 );
} while ((num = num/10) != 0);

c[i] = '\0';
cout &lt;&lt; c &lt;&lt; endl;
</code></pre>

<p>The problem is that the compiler is probably trying to use 10 as an int, and is having problems converting.  After putting the casting in, it actually works.  Problem is that the algorithm is backwards as it will bring in the 6, then the 7, etc...  The output is as follows from the above code which is exactly the same as his with the exception of the casting.</p>

<p>This is actual code, and actual output.</p>

<pre><code>677365726431221664481
</code></pre>

<p>Hope this helps :-)</p>
",2
13772490,13772446,0,"<p>Why don't you use the modulo operator to compute the remainder of the division to obtain the last digit?</p>

<p>integer below</p>

<pre><code>do {
    c[i++] = (char)(((int)'0')+(num %10 ));
} while ((num = (num/10)) != 0);
</code></pre>
",5
13772577,13772446,2,"<p>Your code is fine.  The problem is that the type of <code>num</code> is signed (i.e. just <code>long long</code>).  Change it to (<code>unsigned long long</code>) and you should be good to go.</p>
",0
13772581,13772446,1,"<blockquote>
  <p><code>long long int</code>: 18446612134627563776</p>
</blockquote>

<p><code>long long int</code> is a signed type, usually 64 bits wide, with the maximal representable number</p>

<pre><code>2^63-1 = 9223372036854775807
</code></pre>

<p>Your value is larger than that, and overflows, probably to</p>

<pre><code>2^63 - 18446612134627563776 = -131939081987840
</code></pre>

<p>The printed values are</p>

<pre><code>2^64 + (-131939081987840)/(10^k)
</code></pre>

<p>Change the type to <code>unsigned long long</code> to get the expected results.</p>
",0
10742125,10742071,7,"<p>Unfortunately, after</p>

<pre><code>TCHAR* greeting = L""HELL\0O W\0ORLD!"";
</code></pre>

<p>the length of the string is lost. The runtime will only see</p>

<pre><code>greeting == L""HELL""; //HA!
</code></pre>

<p>You need to store the length of the string and manually shift the characters.</p>
",1
10743580,10742071,2,"<p>Something like this:</p>

<pre><code>TCHAR greeting[] = L""HELL\0O W\0ORLD!"";
TCHAR *writepos = greeting;
for (int i = 0; i &lt; sizeof(greeting) - 1; ++i) {
    if (greeting[i] != 0) {
        *writepos++ = greeting[i];
    }
}
*writepos = 0;

wprintf(L""%s\n"",greeting);
</code></pre>

<p>The important point is that you need to remove the nul characters when you still know the length of the data. We can easily get the size of a string literal (or in my code, a copy of a literal) using <code>sizeof</code>, and that includes the nul terminator. If the input is not really a string literal, but was read from somewhere, you need to know the size of the data read.</p>

<p>If you ever pass a pointer to the data without the length, then you're done for. You can't recover the length once you've lost it.</p>

<p>C has no standard function to remove particular characters from either a string or a buffer. C++ has <code>std::remove_copy_if</code>, but I expect that's no use to you.</p>
",0
11099618,11099572,0,"<p>You can use</p>

<pre><code>snprintf(new_filename, sizeof new_filename, ""%s.%d"", File_name, int_val);
</code></pre>
",0
11099673,11099572,0,"<p>For your problem with the file name, you can use e.g. <code>sprintf</code>:</p>

<pre><code>char full_file_name[256];
sprintf(full_file_name, ""%s.txt"", file_name);
</code></pre>

<p>This is not recommended without some validation of the entered file name of course.</p>

<p>For your other problem, from the documentation of <code>fopen</code>:</p>

<pre>
r+     Open for reading and writing.  The stream is positioned at the beginning
       of the file.

w+     Open for reading and writing.  The file is created if it does not exist,
       otherwise it  is  truncated.
       The stream is positioned at the beginning of the file.

a+     Open for reading and appending (writing at end of file).  The file is
       created if it does  not  exist.
       The  initial file position for reading is at the beginning of the file,
       but output is always appended to the end of the file.
</pre>
",1
11099743,11099572,0,"<p>for creating output file with the same name, simply save your output content into some string. Then, close the file and open it again with write mode(""w""). And then, write the content and close the file again.</p>
",1
11098354,11098298,0,"<p>in this case you can check this.Index == 1100 once then use a switch statement to test for the subindex</p>

<p>i.e. since you have a common check in all the conditions you can extract it:</p>

<pre><code>if (this.Index==1100){
  switch(this.Subindex){
    case 1:
      ...
    case 2:
      ...
    }
}
</code></pre>
",0
11098392,11098298,1,"<pre><code>if (this.Index==1100) {
  if (this.SubIndex==1)
    putValue(Com_stMECUErr, this.Data);
  if (this.SubIndex==2)
    putValue(B_sbbvk, this.Data);
  if (this.SubIndex==3)
    putValue(Com_bMSVIdle,this.Data);
  // haivng 100 more similar conditions
}
</code></pre>

<p>or something like</p>

<pre><code>if (this.Index==1100) {
  the_type_of_the_first_argument_of_putValue table1100[]= {
    Com_stMECUErr, // 1
    B_sbbvk,       // 2
    Com_bMSVIdle   // 3
    // haivng 100 more similar conditions
  };
  if (this.SubIndex&lt;=no_of_entries_in_table1100)
    putValue(table1100[this.SubIndex-1], this.Data);
  else
    printf(""value not found."");
}
</code></pre>
",0
11098394,11098298,3,"<p>You can get rid of some of the redundancy like this:</p>

<pre><code>if (this.Index == 1100)
{
    switch (this.SubIndex)
    {
        case 1:
            putValue(Com_stMECUErr, this.Data);
            break;
        case 2:
            putValue(B_sbbvk, this.Data);
            break;
        case 3:
            putValue(Com_bMSVIdle, this.Data);
            break;
        ...
        default:
            ...
            break;
    }
}
</code></pre>
",0
11098398,11098298,5,"<p>If the values are in a continuous range:</p>

<pre><code>yourtypehere subIndexValues[] = {whatever, Com_stMECUErr, B_sbbvk, Com_bMSVIdle};

if(this.Index==1100)
{
  putValue(subIndexValues[this.SubIndex],this.Data);
}
</code></pre>

<p>Or you can use a mixture of <code>if</code>s for the index, and <code>case</code>s/arrays for the specific ranges.</p>
",0
11098399,11098298,0,"<p>You can shorten the code using the switch statement and by moving one if statement up:</p>

<pre><code>if (this.Index == 1100) {
    switch(this.SubIndex) {
    case 1:
        putValue(Com_stMECUErr,this.Data);
        break;
    case 2:
        putValue(B_sbbvk,this.Data);
        break;
    case 3:
        putValue(Com_bMSVIdle,this.Data);
        break;
    default:
        break;
    }
}
</code></pre>
",0
11098425,11098298,0,"<p>Does each SubIndex map to a specific value?</p>

<p>In that case you could make a HashMap or someting similar which keeps track of the mappings. If you did that, whenever you have to check for the values you could do something like:</p>

<pre><code>if(this.Index == 1100){
    putValue(someMap.get(this.SubIndex), this.Data);
}
</code></pre>

<p>Doing it this way could save you a lot of code, especially if you have to check the mappings multiple times in different parts of your code. </p>
",0
11098558,11098298,2,"<p>If the SubIndex does not map to specific value, then use if or switch. </p>

<p>This is the if way.</p>

<pre><code>if(this.Index == 1100) {
    if (this.SubIndex==1) putValue(Com_stMECUErr, this.Data);
    if (this.SubIndex==2) putValue(B_sbbvk, this.Data);
    if (this.SubIndex==3) putValue(Com_bMSVIdle,this.Data);
    // 100's more if's 
} else { //if this.Index != 1100
}
</code></pre>

<p>This is the switch way.</p>

<pre><code>if(this.Index == 1100) {
    switch(this.SubIndex) {
        case 1: putValue(Com_stMECUErr, this.Data); break;
        case 2: putValue(B_sbbvk, this.Data); break;
        case 3: putValue(Com_bMSVIdle,this.Data); break;
        // 100's more cases
        default: break;
    }
    // 100's more if's 
} else { //if this.Index != 1100
}
</code></pre>

<p>If the SubIndex does map to specific value, then you can use array to do it the shortest way.</p>

<pre><code>YourDataType values[] = {
    whatever, 
    Com_stMECUErr, 
    B_sbbvk, 
    Com_bMSVIdle, 
    hundredsmore
}
if(this.Index == 1100) {
    putValue(values[this.SubIndex], this.Data);
}
</code></pre>
",0
12798456,12798375,5,"<p>For the limited 2-digit range you're using:</p>

<pre><code>assert(year &gt;= 0 &amp;&amp; year &lt; 100);
date[0] = (year / 10) * 16 + (year % 10);
</code></pre>

<p>etc.</p>

<p>You could express it as <code>((year / 10) &lt;&lt; 4) | (year % 10)</code> if that makes more sense to you.</p>
",0
12798507,12798375,6,"<p>You just have to retrieve each digit in decimal base en multiply it to its equivalent in hexadecinal.</p>

<pre><code>#include &lt;stdio.h&gt;

int hex(int v){
int total = 0;
int resultbase = 1;
while(v &gt; 0 ){
    total += resultbase * (v % 10);
    resultbase *= 16;
    v /= 10;
}

return total;
}

 int  main(){
printf (""12 =&gt; %x, 20 =&gt; %x\n"", hex(12), hex(20));
return 0;
</code></pre>

<p>}</p>
",0
11495924,10572559,0,"<p>The following sample is a main program, but could easily be a library function. It does not print anything but instead returns a value, in case it is turned into a library function.</p>

<p>To test this program -- I'm using Ubuntu 10.04 -- I simply <code>echo $?</code> when the program is complete, so see the error code. 0 is success, and non-zero is failure.</p>

<p>I added an fclose if the file open succeeded. It is bad practice to open a file and not close it. </p>

<p>I have included both a check of errno's and fp's value. I did check the C fopen documentation, and all you really need to check is fp's value for NULL or not. Hence, I used ||, instead of &amp;&amp;.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;

#define MIN_ARGS_SUPPLIED 2

int main(int argc, char *argv[])
{
    FILE *fp;
    int rc = 0;

    if(MIN_ARGS_SUPPLIED != argc)
    {
       printf(""Usage: file_detect file-name\n"");
       rc = -1;
    }
    else
    {
        errno = 0; /* errno is already declared by including errno.h */

        fp=fopen(argv[1],""r"");

        if(fp == NULL || errno == ENOENT)
        {
           rc = errno; 
        }
        else
        {
            fclose(fp);
        }
    }

    return rc;
}
</code></pre>
",1
13492038,13491912,2,"<p>This line looks suspicious:</p>

<pre><code>memcpy(&amp;rspr,pPkt,pPkt[0]-sizeof(rspr));  
</code></pre>

<p>The 3rd argument of <code>memcpy</code> is the number of bytes to copy, which can't exceed the size of <code>RESPONSE_R</code>. </p>

<p>Did you mean</p>

<pre><code>memcpy(&amp;rspr,pPkt,sizeof(rspr));  
</code></pre>

<p>?</p>

<p><strong>Update 2</strong></p>

<p>How about this solution, which doesn't require any <code>memcpy</code>?</p>

<pre><code>const RESPONSE_R* p_rspr = (const RESPONSE_R*)pPkt;

switch(p_rspr-&gt;cmd){
 case CMD_READ_ADDR:
   const uint8* addr = pPkt+sizeof(RESPONSE_R);
   //nevermind the cout, this is for debug only     
   cout &lt;&lt; ""ADDR: "" &lt;&lt; endl;    
   for (uint i = 0; i != p_rspr-&gt;len; ++i)            
     printf(""%02x"", addr[i]);
   break;
 default:
   break;
 }
</code></pre>
",6
13492105,13491912,2,"<p>Can you recheck the below statement.  </p>

<pre><code>RESPONSE_R rspr;
memcpy(&amp;rspr,pPkt,pPkt[0]-sizeof(rspr));    
</code></pre>

<p>Looks like you are trying to copy in an incorrect way.</p>
",0
17795136,17795112,1,"<p>You don't install header files.  </p>

<p>You can place them wherever you want.  In your install script, your conditional will just point to the appropriate files when taking the correct branch.  You can put any file path you want in these conditionals. </p>
",1
12862294,12862220,3,"<p><code>return</code> would work.</p>

<p>So would <code>index_x = 100, index_y = 100; break;</code></p>

<hr>

<p>Method A:</p>

<pre><code>Randomnumber() 
{
    int matrix[9][9], x, y;
    for (x=0;  x&lt;9;  ++x)
        for (y=0;  y&lt;9;  ++y)
        {
            matrix [x][y] = rand();
            if (some condition which means we're done)
                 x = 100, y = 100;
        }
}
</code></pre>

<p>Method B:</p>

<pre><code>Randomnumber() 
{
    int matrix[9][9], x, y;
    for (x=0;  x&lt;9;  ++x)
        for (y=0;  y&lt;9;  ++y)
        {
            matrix [x][y] = rand();
            if (some condition which means we're done)
                 return;
        }
}
</code></pre>
",1
12862422,12862220,1,"<p>you could change <code>Randomnumber()</code> to return a value:  maybe 1 for ""Interrupted""; 0 for success.</p>

<p>Then the loop in main becomes</p>

<pre><code> for (...) {
   if (Randomnumber() != 0) {break;}
   ...
 }
</code></pre>

<p>(note also that you need a <code>()</code> to actually call the function from main.
And it is good practice to declare your return types and arguments, even if they are just (void).  <em>Default return types are so 1978</em>)</p>
",0
18445533,18445396,11,"<p>In <code>%.*s</code>, the <code>.*</code> limits the number of bytes that will be written. If this were written with a numeral included, such as <code>%.34s</code>, then the numeral would be the limit. When an asterisk is used, the limit is taken from the corresponding argument to <code>printf</code>.</p>

<p>From C 2011 (N1570) 7.21.6.1 4, describing conversion specifications for <code>fprintf</code> <em>et al</em>:</p>

<blockquote>
  <p>An optional precision that gives ¡­ the maximum number of bytes to be written for <strong>s</strong> conversions. The precision takes the form of a period (<b>.</b>) followed either by an asterisk <b>*</b> (described later) or by an optional decimal integer; if only the period is specified, the precision is taken as zero.</p>
</blockquote>
",3
18445559,18445396,12,"<p>It specifies the ""Character String Maximum field width""</p>

<p>The precision within a string format specifies the maximum field width:</p>

<p><code>%2.6s</code></p>

<p>specifies a minimum width of 2 and a maximum width of 6 characters. If the string is greater than 6 characters, it will be truncated.</p>
",0
18445585,18445396,4,"<p>A printf format string allows specifying width and precision.</p>

<p>Width, such as <code>%25s</code>, tells <code>printf</code> to pad the string to the width of 25 characters, inserting spaces before the string. (If the string is wider than 25 characters, it is still printed in its entirety.)</p>

<p>A ""precision"" applied to a string format, such as <code>%.25s</code>, limits the length of the printed string to 25 characters. A string of 3 characters will be printed fully (with no padding), and a string of 30 characters will be missing its last five characters.</p>

<p><code>%.*s</code> avoids hardcoding the precision in the format, specifying it instead as an integer argument to <code>printf</code>, in your case <code>max</code>.</p>
",2
18445664,18445396,2,"<p>First of all, K&amp;R is the original implementation of C, which is different from the current specification. If you want specific information about K&amp;R C, then consult specific documentation.</p>

<p>From the current C standard:</p>

<blockquote>An optional precision that gives (...) the maximum number of bytes to be written for s conversions. The precision takes the form of a period (.) followed either by an asterisk * (described later) or by an optional decimal integer.</blockquote>

<p><a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""nofollow"">http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf</a></p>

<p>Similar documentation is available everywhere online for multiple standards or implementations:</p>

<ul>
<li>glibc
<a href=""http://www.gnu.org/software/libc/manual/html_node/Output-Conversion-Syntax.html#Output-Conversion-Syntax"" rel=""nofollow"">http://www.gnu.org/software/libc/manual/html_node/Output-Conversion-Syntax.html#Output-Conversion-Syntax</a></li>
<li>POSIX
<a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/fprintf.html"" rel=""nofollow"">http://pubs.opengroup.org/onlinepubs/9699919799/functions/fprintf.html</a></li>
<li>Microsoft C runtime
<a href=""http://msdn.microsoft.com/en-us/library/56e442dc.aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/56e442dc.aspx</a></li>
</ul>
",0
18448057,18445396,1,"<p>Dot has different meaning with different format strings . If you use a.b with %f , then b gives length . a gives number of decimal points . if you use a.b with %s , a will give minimum length of the string . whereas b gives maximum length of the string that will be printed .</p>
",0
20648683,20648610,2,"<p>I don't know anything about what <code>git_odb_backend</code> is (and neither does the compiler) so here's my advice.</p>

<p>The file <code>hiredis.c</code> needs to know the full declaration of <code>git_odb_backend</code> to allow you to declare it as a non-pointer member variable. This is because the compiler needs to know things about the <code>git_odb_backend</code> such as: What is its size? How do I construct it? It doesn't need to know the function implementations, just what the struct looks like.</p>

<p>So you need to find the header file that declares <code>git_odb_backed</code> and include that in 
<code>hiredis.c</code>. </p>

<p>Or, forward declare it and take a pointer:</p>

<pre><code>typedef struct git_odb_backend git_odb_backend;

typedef struct {
    git_odb_backend*parent;
    redisContext *db;
} hiredis_backend;
</code></pre>
",0
13442863,13442837,7,"<p><code>strcmp</code> returns 0 if the both strings are equals.</p>

<blockquote>
  <p><strong>C11 (n1570), ¡ì 7.24.4.2 The <code>strcmp</code> function</strong><br>
  The <code>strcmp</code> function returns an integer greater than, equal to, or less than zero,
  accordingly as the string pointed to by <code>s1</code> is greater than, equal to, or less than the string pointed to by <code>s2</code>.</p>
</blockquote>

<p>Some programmers used to call the following macro:</p>

<pre><code>#include &lt;string.h&gt;
#define cmp_strings(a, b) (strcmp(a, b) == 0)
</code></pre>
",0
13442880,13442837,0,"<p>According to <a href=""http://www.cplusplus.com/reference/clibrary/cstring/strcmp/"" rel=""nofollow"">the online C++ reference</a>, strcmp() returns zero if the strings are equal.  That being the case, your code would be saying, essentially, if the first argument is NOT ""start"", run services_start().</p>
",0
16399581,16399485,0,"<p>By making <code>++i</code> an lvalue, imagine that you can now do:</p>

<pre><code>int i=2;
++i = ++i;
</code></pre>

<p>Apart from nasal daemons, what would you like <code>i</code> to look like afterwards? 4? 3? </p>
",4
16399694,16399485,3,"<p><code>++i</code> is an <code>lvalue</code> only in <strong>C++</strong>, in <strong>C</strong> it's an <code>rvalue</code> (called <em>value of an expression</em> in the C standard) which cannot be assigned.</p>
",4
16399716,16399485,4,"<p>Neither <code>++i</code> nor <code>i++</code> are lvalues.</p>

<p>You might be thinking about <code>*x++</code> and <code>*++x</code> which are both lvalues (if x has a pointer type).</p>
",0
16399884,16399485,2,"<p>I thought that this question would be closed, and I only left a comment. What a big mistake;)</p>

<p>In C (the question's tag is <em>C</em>) ++i operator does ""return"" a value, but not the variable itself. Hence it's address can not be retrieved. In other words <code>++i</code> is not an lvalue. Neither is <code>i++</code>.</p>

<p>C++ is may be different from C in regard of certain constructs being l- and r-values.</p>

<p><a href=""http://eli.thegreenplace.net/2011/12/15/understanding-lvalues-and-rvalues-in-c-and-c/"" rel=""nofollow"">http://eli.thegreenplace.net/2011/12/15/understanding-lvalues-and-rvalues-in-c-and-c/</a></p>

<p>For C++ these two are lvalues.</p>

<p>This simple code:</p>

<pre><code>#include &lt;stdio.h&gt;

int main() {
  int i=0;
  ++i = 10;
  printf(""\n%d\n"", i);
  ++i = ++i;
  printf(""%d\n"", i);
}
</code></pre>

<p>Compiled with gcc will give:</p>

<pre><code>lvalue.c:3: error: invalid lvalue in assignment
lvalue.c:4: warning: incompatible implicit declaration of built-in function ¡®printf¡¯
lvalue.c:5: error: invalid lvalue in assignment
</code></pre>

<p>and for g++ compiles correctly and yelds:</p>

<pre><code>10
12
</code></pre>
",1
16400039,16399485,1,"<p>The (rather vague) formal definition from C11:</p>

<p>(emphasis in <strong>bold</strong> font was added by me)</p>

<blockquote>
  <p>6.3.2.1 Lvalues, arrays, and function designators</p>
  
  <p><strong>An lvalue is an expression</strong> (with an object type other than void) <strong>that potentially designates an object</strong> (64); if an lvalue does not designate an object when it is evaluated, the behavior is undefined. When an object is said to have a particular type, the type is  specified by the lvalue used to designate the object. A modifiable lvalue is an lvalue that does not have array type, does not have an incomplete type, does not have a const-qualified  type, and if it is a structure or union, does not have any member (including, recursively,  any member or element of all contained aggregates or unions) with a const-qualified type.</p>
</blockquote>

<p>Foot note (not normative) with further explanation:</p>

<blockquote>
  <p>64) The name ""lvalue"" comes originally from the assignment expression E1 = E2, in which the left operand E1 is required to be a (modifiable) lvalue. It is perhaps better considered as representing an object ""locator value"". What is sometimes called ""rvalue"" is in this International Standard described as the ""value of an expression"".</p>
</blockquote>

<p>So an lvalue must be something that ""potentially"" designates an object. Whatever ""potentially"" means is open for personal interpretation... </p>

<p>Despite the above foot note, the C standard lacks a formal definition of a rvalue. Ironically, the only place in the whole standard mentioning rvalue is that one foot note.</p>

<p>In your case, neither ++i nor i++ designates an actual object, so neither of them are lvalues. They are rather rvalues. </p>
",2
10761434,10761428,10,"<p>Since the 3-d array is a contiguous block of memory, you can view it as a 1-d array</p>

<pre><code>int i, *dummy2 = &amp;dummy[0][0][0];
for(i = 0; i &lt; 4*4*1024; ++i)
    dummy2[i] = 12;
</code></pre>
",10
10761663,10761428,5,"<p>The default initialization to all zeros is just that:</p>

<pre><code>unsigned dummy[4][4][1024] = { 0 };
</code></pre>

<p>If you want to initialize particular elements (and all others to zero) do this</p>

<pre><code>unsigned dummy[4][4][1024] = { { { 5 }, { 0, 4 } } };
</code></pre>

<p>and if your compiler knows C99 use designated initializers</p>

<pre><code>unsigned dummy[4][4][1024] = { [3] = { [2] = { [0] = 7 }, [1] = { [2] = 3, [1] = 4 } } };
</code></pre>

<p>and if you really insist to use all <code>12</code>, just repeat the <code>12</code> 16384 times :)</p>
",0
10761587,10761428,7,"<p>Come on guys - let's do it the simple way that always works:</p>

<pre><code>
for(int i = 0; i &lt 4; i++)
{
  for(int j = 0; j &lt 4; j++)
  {
    for(int k = 0; k &lt 1024; k++)
    {
      dummy[i][j][k] = 12;
    }
  }
}

</code></pre>
",3
11096943,11096915,1,"<p>You can do any kind of mumbo jombo magic play with the indexes as long as the effective value of index evaluates in such a way that you dreference the array in valid ranges.  </p>

<p>Your code does finally resolves to a valid index range i.e: <code>0</code> to <code>4</code> and so it is valid.</p>
",0
11096946,11096915,0,"<p>No, because:
Where are you define Nt?
<strong>Nt undeclared</strong></p>
",0
11096960,11096915,0,"<p>Assuming that by <code>Nt</code> you mean <code>N</code>, then yes, it should work.  </p>
",1
11096973,11096915,0,"<p>Well this looks like a valid format to print, but in the <code>for(d=-1;d &lt;= Nt;d++)</code> I think you meant N, which you have defined in macro</p>
",0
11097524,11096915,0,"<p>array almost started form [0] and end to the [n-1]
here use array int and declare d variable.
can u print array entered style then arr[0] start them.</p>

<p>for(d=0;d&lt;=array[5-1];d++)/<em>declare for loop</em>/</p>

<p>printf(""%d"",array[d];/*print the array in sequence */</p>
",1
11099158,11096915,1,"<p>First, I'll note in passing that the code as it stands will read outside the bounds of the array, since <code>d+1</code> will be <code>6</code> at the last iteration of the loop, while the highest valid array index is <code>4</code>. But this isn't the main problem with your code; as it stands, when <code>d = -1</code>, the condition <code>d &lt;= N</code> will actually evaluate to <code>false</code>, and thus the loop terminates at once without going through any iterations. The problem is that the result of the expression  <code>sizeof(array) / sizeof(array[0])</code> is of type <code>size_t</code>, which is an <em>unsigned</em> integer, while <code>d</code> is an <code>int</code>, i.e. a <em>signed</em> integer. Prior to the actual comparison, <code>d</code> is converted to a <code>size_t</code> (this is called <em>type promotion</em>), resulting in a <em>large positive integer</em>, and thus the expression <code>d &lt;= N</code> evaluates to false. See <a href=""http://c-faq.com/expr/preservingrules.html"" rel=""nofollow"">this</a> c-faq entry for more information. To really drive the point home, you may want to try the following code, and see if it works as expected:</p>

<pre><code>int d = -1;
printf(""%u\n"", d); 

size_t n = 5000;
if (d &gt; n) printf(""oops!\n"");
</code></pre>

<p>Fixing your code is fairly simple - for example, as others have suggested, rewriting the loop as </p>

<pre><code>for (d = 0; d &lt; N; d++) {
        printf(""%d\n"", array[d]);    
}
</code></pre>

<p>will work.</p>
",1
11099171,11096915,1,"<p>d ranges from -1 to 5 inclusive, so you access array[0] through array[6] ... or you would, except that the value of <code>sizeof</code> is of type <code>unsigned</code>, so -1 &lt;= N is false.</p>
",0
17864069,17862982,2,"<p>From the current C standard:</p>

<blockquote>
  <p>If the signal occurs other than as the result of calling the abort or
  raise function, the behavior is undefined if the signal handler refers
  to any object with static or thread storage duration that is not a
  lock-free atomic object other than by assigning a value to an object
  declared as volatile sig_atomic_t, or the signal handler calls any
  function in the standard library other than the abort function, the
  _Exit function, the quick_exit function, or the signal function with the first argument equal to the signal number corresponding to the
  signal that caused the invocation of the handler.</p>
</blockquote>

<p>you are using an object with static storage duration that is not in the list of allowed types (<code>buf</code>) and you use a function of the standard library that is not in the list of allowed functions (<code>longjmp</code>).</p>
",0
17866920,17862982,0,"<p>I think what you want is this.  </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;signal.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;

static int k;

void
handler(int s)
{
    k++;
}

int
main(int argc, char *argv[])
{
    int n = 0;

    signal(SIGINT, handler);

    while (1) {
        if (k &gt; n) { 
            printf(""handler got called %d\n"", k);
            n = k;
            if (k == 5) {
                break; /* break out after five control-c */
            }
        }
    }

    exit(0);
}
</code></pre>

<p>Try it out and let me know how it goes.</p>
",3
11819370,11819352,5,"<p>Don't use <code>scanf</code>. Use <code>fgets</code> to get a line of input as a <code>char*</code>, then you can pull individual digits out of the <code>char*</code> as characters, and convert them to <code>int</code> digits yourself. <code>scanf(""%d"", ...)</code> will cause problems if the user enters input that can't be parsed as a digit.</p>

<pre><code>char *inputLine = malloc(sizeof(char) * (MAX_DIGITS + 1);
fgets(inputLine, MAX_DIGITS, stdin); // or replace stdin with a FILE *
</code></pre>

<p><code>fgets</code> will consume the entire line of input up to the newline, or stop at the number of characters specified by argument 2.</p>

<p>If you want to continue reading digit-by-digit, then use <code>getchar()</code> to read individual characters, or <code>fgetc(FILE *)</code> to read individual characters from a file.</p>

<pre><code>char *inputLine = malloc(sizof(char) * (MAX_DIGITS + 1));
char ch = getchar();
int i = 0;
while ((ch != '\n') &amp;&amp; (ch != EOF) &amp;&amp; (i &lt; MAX_DIGITS))
{
    inputLine[i++] = ch;
    ch = getchar();
}
</code></pre>
",2
11819372,11819352,2,"<p><code>%d</code> reads an integer - if you want to read one character at a time, use <code>%c</code>, or alternately replace your <code>scanf()</code> call with <a href=""http://linux.die.net/man/3/getchar"" rel=""nofollow""><code>getchar(3)</code></a>.</p>
",2
11819450,11819352,0,"<p>Try this:</p>

<pre><code>char number[SIZE];
int nDigits = 0;

printf(""Write a number: "");
while ((number[nDigits] = getchar()) != '\n') nDigits++;

printf(""The number is: %s\n"", number);
</code></pre>

<p>Also, be aware that you might need to fill the <code>number</code> array / string with zeros.</p>
",0
10814625,10814580,1,"<p><code>scanf</code> returns you a value, which you don't check.</p>

<p>When used with <code>%d</code> specifier - it should parse an integer. Since you enter a non-integer value - <code>scanf</code> returns you an error code, and <code>choice</code> is unchanged</p>
",0
10814649,10814580,2,"<p>It looks like you are getting the numbers into Choice, and the chars into c.
but you are only using the Choice var in the switch, you are never checking the C var.</p>

<p>So essentially, if you hit a letter it is storing it in the C var, and then using the old value in Choice again.</p>
",1
10814717,10814580,2,"<p>Hmm, one of the things wrong in your codes is the:</p>

<pre><code>scanf(""%c"" , &amp;c);
</code></pre>

<p>because, the scanf function requires the user to press the enter key before it could store the character to its respective variable. <BR><BR></p>

<p><strong>So if the compiler reads the line:</strong> </p>

<pre><code>scanf(""%c"" , &amp;c);
</code></pre>

<p>it reads your input, PLUS, the ENTER.<BR>
Thus forcing the scanf function to store your input, PLUS, the ENTER, into your character variable.</p>

<p>It would be better if you would use getche() or getch() instead of using scanf() function, and please do not ever use:</p>

<pre><code>scanf(""%c"" , &amp;c);
</code></pre>

<p>because it would generate an error.</p>

<hr>

<p><strong>Sample of usage of getche() or getch() function:</strong></p>

<pre><code>c=getche(); //waits for a keypress and stores it on a variable
c=getch();  //waits for a keypress and stores it on a variable
</code></pre>

<p>the difference between the two is that the getche() displays your keypress while the getch() does not.</p>

<hr>

<p>Note: Do not forget to put</p>

<pre><code>#include&lt;conio.h&gt;
</code></pre>

<hr>

<p>Added info:
If you still want to go on using the scanf() function just make sure that you declare your favorite variable as:</p>

<pre><code>char c[20];
</code></pre>

<p>then you may use:</p>

<pre><code>scanf(""%s"", &amp;c);
</code></pre>

<p>but your variable, can only hold up to 19 characters, as how we declared on your character array.</p>

<p>And the summary is do not use:</p>

<pre><code>scanf(""%c"", &amp;c);
</code></pre>

<p>because, it can affect your other scanf() functions. :)</p>

<hr>

<p>SOLUTION(Spoiler Warning):</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;conio.h&gt;

typedef struct vehicle
{
    char name[100];
    char lice_no[25];
    int vehicle_type;
    char cmpny_name[100];
    int menu_year;
}record;

int main(void)
{
    int i; //removed choice from int
    FILE *fp1,*fp2;
    char oname[100];
    record det,det1;
    char choice; //made the variable choice a character
    int recsize;
    char c;

fp1 = fopen(""record.dat"" , ""r+"");
if(fp1 == NULL)
{
    fp1 = fopen(""record.dat"" , ""w+"");
    if(fp1 == NULL)
    {
        printf(""error in opening file : \n"");
        return -1;
    }
}
recsize = sizeof(det);

do
{
    printf(""\t\""enter the choice\""\n"");

    printf(""1 : adding the record\n"");
    printf(""2 : delete the record\n"");
    printf(""3 : editing the record\n"");
    printf(""4 : display the record\n"");
    printf(""5 : exit the program\n"");


    fflush(stdin);
    choice = getche(); // or getch()

    switch(choice) //changed the target character
    {
        case '1' : //changed the case from 1 to '1'
        {
                printf(""In this add logic\n"");
                break;
        }
        case '2' : //changed the case from 2 to '2'
        {
            printf(""In this case delete logic\n"");
            break;
        }
        case '3' : //changed the case from 3 to '3'
        {
            printf(""In this case edit logic\n"");
                            break;
        }
        case '4' : //changed the case from 4 to '4'
        {
            printf(""display logic\n"");
            break;
        }
        case '5' : //changed the case from 5 to '5'
        {
            printf(""exit logic\n"");
            break;
        }
        default :
        {
            printf(""\""Invalid option\""\n"");
            break;
        }
    }
}
while(1);
return 0;
}
</code></pre>

<hr>

<p>You can also use switch to compare characters. Just change the values</p>

<pre><code>case 1:
</code></pre>

<p>to</p>

<pre><code>case '1':
</code></pre>
",5
18709008,18708978,10,"<p>The direct analogue to what you're doing with <code>sprintf(3)</code> would be to use <a href=""http://linux.die.net/man/3/sscanf"" rel=""noreferrer""><code>sscanf(3)</code></a>:</p>

<pre><code>unsigned char *in;
uint64_t out;
sscanf(in, ""%"" SCNu64, &amp;out);
</code></pre>

<p>But probably <a href=""http://linux.die.net/man/3/strtoull"" rel=""noreferrer""><code>strtoull(3)</code></a> will be easier and better at error handling:</p>

<pre><code>out = strtoull(in, NULL, 0);
</code></pre>

<p>(This answer assumes <code>in</code> really points to something, analogous to how <code>out</code> has to point to something in your example code.)</p>
",0
10648257,10647793,0,"<p>You answer your question by yourself:</p>

<blockquote>
  <p>This is the case of default argument promotion where float variable is treated as double</p>
</blockquote>

<p>Of course, <code>%f</code> knows about this default argument promotion and only deals with <code>double</code>s, not with <code>float</code>s.</p>
",0
10647814,10647793,1,"<p>Huh? <code>%f</code> can ""know"" that a <code>float</code> passed as a vararg argument has been promoted to something bigger (<code>double</code>) and act accordingly, of course. The code for <code>%d</code> does not know that it should expect a promoted floating point value; it expects a (suitably promoted) <code>int</code>.</p>
",3
10647970,10647793,1,"<p>The <code>%f</code> format string takes a <code>double</code> value in the argument list, and prints it out. Since un-suffixed floating point literals are <code>double</code>s in C, and that doubles are not promoted or otherwise changed by default promotion rules, there is no magic at all happening with your second example.</p>

<p>Your first example is undefined behavior, anything could happen.</p>

<p>C99 ¡ì7.19.6.1 <em>The <code>fprintf</code> function</em></p>

<blockquote>
  <p>If there are insufficient arguments for the format, the behavior is
  undefined.</p>
  
  <p>[...]</p>
  
  <p>If any argument is
  not the correct type for the corresponding conversion specification, the behavior is
  undefined.</p>
</blockquote>
",0
10745610,10745578,5,"<p>You are accessing a position outside the array, there is no <code>A[6]</code>. That's undefined behavior, and anything could happen.</p>

<p>Note that <code>A[5]</code> is a well defined location (past the end of the array), so getting a pointer to it is legal but trying to access that pointer is not. However, getting a pointer to <code>A[6]</code> or any other greater index is completely undefined.</p>
",11
10745655,10745578,0,"<p>C doesn't do array bounds checking. For <code>int A[4]</code>, think of <code>A[5]</code> as like pointer arithmetic: <code>*(A + 5)</code>. </p>

<p>Even if <code>A</code> has only been declared with 5 elements (0-4), C will allow you to reference memory outside the declared bounds of your array, using <code>A</code>.</p>

<p>The result of this access is undefined. If you read <code>A[5]</code>, you might get garbage; if you write <code>A[5]</code>, i.e. <code>A[5] = 13</code>, you may corrupt another allocated block of memory.</p>

<p>The <a href=""http://en.wikipedia.org/wiki/Pointer_arithmetic#C_arrays"" rel=""nofollow"">wiki article</a> is a pretty good start for understanding this, but I recommend that you pick up a copy of <a href=""http://en.wikipedia.org/wiki/The_C_Programming_Language"" rel=""nofollow"">K&amp;R</a>, read it, and do all the exercises.</p>
",0
19321424,19321338,1,"<p>If it's in <a href=""http://linux.die.net/man/2/accept"" rel=""nofollow"">accept (2)</a> it's not hanging, it's waiting for an incoming connection.</p>
",1
12792769,12792724,3,"<p>Your <code>scanf()</code> is <em>not</em> messing up your <code>a[0]</code>, at least not in the way you seem to think, by somehow corrupting its storage area. This is very much an issue with mixing different &quot;methods&quot; of input.</p>
<p>What is actually happening with your<code>scanf/fgets</code> combo is that the <code>scanf</code> is getting the integer, but not reading the newline that you enter at the end of that number, so the first <code>fgets</code> picks that up.</p>
<p>The ISO standard states it thus (in the specified sequence):</p>
<blockquote>
<p>Input white-space characters (as specified by the isspace function) are skipped, unless the specification includes a [, c, or n specifier.</p>
<p>An input item is read from the stream, unless the specification includes an n specifier. An input item is defined as the longest sequence of input characters which does not exceed any specified field width and which is, or is a prefix of, a matching input sequence.</p>
<p>The first character, if any, after the input item remains unread.</p>
</blockquote>
<p>That first and last paragraph is important. The first means the leading whitespace is skipped, the last means that trailing whitespace is left in the input stream to be read later.</p>
<hr />
<p>However, I'll tell you what <em>may</em> mess it up (depending on the lengths of your input lines), it's the fact that you allocate 50 characters space for each <code>a[i]</code> then read up to 100 characters into it. Thats undefined behaviour right there.</p>
<hr />
<p>If you want a robust input solution that handles buffer sizes correctly, detects lines that are too long, throws away the remainders of those lines and so on, see <a href=""https://stackoverflow.com/questions/4023895/how-to-read-string-entered-by-user-in-c/4023921#4023921"">this answer</a>.</p>
<p>Alternatively, if you want to emulate line-based behaviour with the non-line-based <code>scanf</code> (and you're sure that your lines are always less than 100 bytes), you can change:</p>
<pre><code>scanf(&quot;%d&quot;, &amp;num);
</code></pre>
<p>into:</p>
<pre><code>char junk[100];
scanf (&quot;%d&quot;, &amp;num);
fgets (junk, sizeof (junk), stdin);
</code></pre>
<p>so that it grabs and throws away the rest of the line.</p>
<p>And you should ensure that the maximum-size argument to <code>fgets</code> matches the amount of memory available (such as by using <code>sizeof</code> in the above code).</p>
<p>One other thing, please don't complicate code by multiplying things by <code>sizeof(char)</code> - that value is <em>always</em> 1 as per the standard.</p>
",0
11566092,11566028,1,"<p>If I understand the question correctly, the solution boils down to finding the most significant bit of the input number. This is simply <a href=""http://en.wikipedia.org/wiki/Josephus_problem#k.3D2"" rel=""nofollow"">Josephus problem with k = 2</a>.</p>
",0
11566275,11566028,1,"<p>If you take a look at the indices of the removed objects in the binary positional notation, you'll find out that in the first step you remove all the numbers which have a 1 as the last digit. This leaves us with numbers of form xxxx0, where xxxx are all binary digits in some range. So you will have like <strong>001</strong> 0, <strong>010</strong> 0, <strong>011</strong> 0, <strong>100</strong> 0. It's obvious that the second step removes all the numbers that have the suffix 10 and you'll end up with <strong>01</strong> 00, <strong>10</strong> 00, <strong>11</strong> 00 etc.</p>

<p>Apparently the last number standing is the one having the most trailing zeroes.</p>
",1
11497429,11497350,0,"<p>In C, declaring a structure type with a tag does not declare the bare tag as a type (unlike C++).  You have to do:</p>

<pre><code>typedef struct DecompileTestApplication_MyAnotherProgram DecompileTestApplication_MyAnotherProgram;
</code></pre>

<p>And that does not fit on one line on SO without the horizonatal scroll-bar.</p>

<p>Alternatively, you have to prefix the tag with <code>struct</code> each time:</p>

<pre><code>void DecompileTestApplication_Program_Plan(struct DecompileTestApplication_MyAnotherProgram*);
</code></pre>

<hr>

<h2>Expanded answer</h2>

<p>As well as ensuring that the single word is an alias for the <code>struct</code> using <code>typedef</code>, 
you also have to ensure that there's only one <code>typedef</code> for each type.</p>

<p>As a side note, your names for your header guards are intruding on the namespace reserved for the implementation (that means, for the people who write the C compiler).  Don't do that.  Don't use names starting with an underscore in general, and especially not names starting with either two underscores or one underscore and a capital letter.</p>

<p>In context, that means:</p>

<h3>DecompileTestApplication_Program.h</h3>

<pre><code>#ifndef DecompileTestApplication_Program_header
#define DecompileTestApplication_Program_header
typedef struct DecompileTestApplication_MyAnotherProgram DecompileTestApplication_MyAnotherProgram;
typedef struct DecompileTestApplication_Program DecompileTestApplication_Program;
struct DecompileTestApplication_Program
{
    //Variables
    int ind;
    int a;
    int b;
    int __refs__;  // This is not safe either!
};
// Why is this function declared here and not in the other header?
void DecompileTestApplication_Program_Plan(DecompileTestApplication_MyAnotherProgram *prog);
#endif
</code></pre>

<h3>DecompileTestApplication_MyAnotherProgram.h</h3>

<pre><code>#ifndef DecompileTestApplication_MyAnotherProgram_header
#define DecompileTestApplication_MyAnotherProgram_header
#include ""DecompileTestApplication_Program.h""
struct DecompileTestApplication_MyAnotherProgram
{
    //Variables
    DecompileTestApplication_Program* program;
    int __refs__;  // Dangerous
};
#endif
</code></pre>

<p>Neither header self-evidently needed <code>&lt;stdio.h&gt;</code>.</p>
",6
11497452,11497350,0,"<p>This is C, not C++. Declaring/defining a struct doesn't create a new type name. So, either your function declaration in the first file should be</p>

<pre><code>void DecompileTestApplication_Program_Plan(struct DecompileTestApplication_MyAnotherProgram);
</code></pre>

<p>or yous should use a typedef:</p>

<pre><code>typedef struct DecompileTestApplication_MyAnotherProgram DecompileTestApplication_MyAnotherProgram;
</code></pre>

<p>In this case, you'll have to omit the <code>typedef</code> keyword in the second file, just leaving</p>

<pre><code>struct XXX.... {
};
</code></pre>
",4
10808490,10808469,3,"<p>Yes, you can change the counter and condition variables. They will just be evaluated with the next iteration of the loop.</p>
",0
10808491,10808469,7,"<p>It is not invalid to change a loop counter inside a loop in C.</p>

<p>However, it is probably confusing to future readers and that's a good reason <em>not</em> to do it.</p>
",0
10808493,10808469,1,"<p>Yes, in C/C++/C# You can change the counter etc. in the loop.</p>
",0
10808494,10808469,4,"<p>It depends on what you mean by ""screw things up"".</p>

<p>If you know what you are doing, you can change counter. The language has no restrictions on this.</p>
",0
10808504,10808469,4,"<p>Changing the counter variable in the loop is allowed, but be careful to know what you are doing to not create infinite loops by decreasing the variable when you shouldn't be.</p>

<p>Some algorithms actually benefit from this, but of course if you do this it makes your code less readable so make sure you comment what you are doing also.</p>
",0
10808599,10808469,12,"<p>Yes you can change the counter within a loop and it can sometimes be very useful.  For example in parsing command line arguments where there is an option flag followed by a value.  An example of this is shown below:</p>

<p>Enter the following command:</p>

<p><code>program -f filename -o option -p another_option</code></p>

<p>Code:</p>

<pre><code>#include &lt;string.h&gt;

int main(int argc, char** argv)
{

 char *filename, *option, *another_option;

 if(argc &gt; 1){
   for(int i=1; i&lt;argc; i++){
     if(strcmp(argv[i],""-f"")==0){
        filename = argv[++i];
     } else if(strcmp(argv[i],""-o"")==0){
       option = argv[++i];
     } else if(strcmp(argv[i],""-p"")==0){
       another_option = argv[++i];
     } else {
       printf(""Option \""%s\"" not recognized, skipping\n"",argv[i]);
       continue;
     }
   }
 } /* end if argc &gt; 1 */

 return 0;
}
</code></pre>

<p>The example program automatically increments the counter to access the correct command line string. There are of course ways to incorporate counters etc., but they would only make the code more cumbersome in this case.</p>

<p>As others have pointed out, this is where many people write bugs and one must be careful when incrementing counters within loops, particularly when the loop is conditional upon the counter value.</p>
",0
10808620,10808469,1,"<p>Like many other techniques, as long as you know what do you do, it's fine.</p>

<p>For example, this code:</p>

<pre><code>int i;
for (i=0;i&lt;5;i++)
  printf(""%d\n"",i--);
</code></pre>

<p>is an infinity loop, but this version of bubble sort:</p>

<pre><code>int *arr,n;
//allocate memory, assign values, and store the length of the array in n
int i;
for (i=0;i&lt;n-1;i++)
  if (arr[i]&gt;arr[i+1]) {
    int temp=arr[i];
    arr[i]=arr[i+1];
    arr[i+1]=temp;
    if (i) i-=2;
  }
</code></pre>

<p>is fine. (It's not exactly bubble sort. Instead of using nested loops, I go back in the array after swapping members in it)</p>
",0
10808885,10808469,2,"<p>Definiteley you can.But be careful not to make the loop disorder. Alter a conter in the loop happens a lot in do...while and while.</p>

<pre><code>do{
  counter++;
  some expressions;
}
while(counter &lt; SOMEVALUE);
</code></pre>
",0
17785900,17785867,4,"<p>Older versions of C allowed the return type to be omitted, defaulting it to <code>int</code>.</p>

<p>C99 no longer allows it, so if you compiled under C99 mode, it would fail.</p>
",0
17785956,17785867,0,"<p>You should declare a function not returning any value as returning <code>void</code>, and in any case the return type should be specified. Your compiler might allow you to compiler a function without return value specified (it will default to int, that is why that code might be/have been working), but a modern compiler will at least issue a warning.</p>

<p>Furthermore, as somebody else already noticed, also the input types are specified in an unusual way (without verifying, I would call it non-standard compliant)</p>
",4
11553580,11552960,1,"<p>If your code compiled without warnings, you are not making full use of your compiler.  It will help you if you ask it to do so.  Learn how to make it compile with warnings, and learn how to fix the problems it diagnoses.  I compiled the code below with one or the other of these commands:</p>

<pre><code>gcc -O3 -g -std=c99 -Wall -Wextra -m64 array-stuff.c -o array-stuff
gcc -O3 -g -std=c99 -Wall -Wextra -m32 array-stuff.c -o array-stuff
</code></pre>

<p>That's a good starting point for clean code with GCC.  Indeed, <code>-Wall</code> without <code>-Wextra</code> is pretty good too.</p>

<p>Here's an adaptation of your code (in a file <code>array-stuff.c</code>) ¡ª although most of it is different:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;inttypes.h&gt;

int main(void)
{ 
    // DC4M = Doesn't compile for me, because I compile with stringent warnings
    char ar[16] = { 'a', 'b', 'c', '\0' };  // Note explicit size
    printf(""%-18s  %s\n"", ""Code:"", ""char ar[16] = { 'a', 'b', 'c', '\0' };"");
    //printf(""argument: &amp;ar     %s\n"", &amp;ar);    // DC4M
    printf(""argument: &amp;ar[1]  %s\n"", &amp;ar[1]);

    printf(""%-18s  0x%"" PRIXPTR ""\n"", ""ar:"",       (uintptr_t)ar);
    printf(""%-18s  0x%"" PRIXPTR ""\n"", ""&amp;ar:"",      (uintptr_t)&amp;ar);
    printf(""%-18s  0x%"" PRIXPTR ""\n"", ""(ar+1):"",   (uintptr_t)(ar+1));
    printf(""%-18s  0x%"" PRIXPTR ""\n"", ""(&amp;ar+1):"",  (uintptr_t)(&amp;ar+1));
    printf(""%-18s  0x%"" PRIXPTR ""\n"", ""&amp;ar[1]:"",   (uintptr_t)(&amp;ar[1]));
    printf(""%-18s  0x%"" PRIXPTR ""\n"", ""&amp;(ar[1]):"", (uintptr_t)(&amp;(ar[1])));
    printf(""%-18s  0x%"" PRIXPTR ""\n"", ""(&amp;ar)[1]:"", (uintptr_t)((&amp;ar)[1]));

    printf(""%-18s  %zu\n"", ""sizeof(ar):"",       sizeof(ar));
    printf(""%-18s  %zu\n"", ""sizeof(&amp;ar):"",      sizeof(&amp;ar));
    printf(""%-18s  %zu\n"", ""sizeof(void*):"",    sizeof(void*));
    printf(""%-18s  %zu\n"", ""sizeof(ar[1]):"",    sizeof(ar[1]));
    printf(""%-18s  %zu\n"", ""sizeof(&amp;ar[1]):"",   sizeof(&amp;ar[1]));
    printf(""%-18s  %zu\n"", ""sizeof(&amp;(ar[1])):"", sizeof(&amp;(ar[1])));
    printf(""%-18s  %zu\n"", ""sizeof((&amp;ar)[1]):"", sizeof((&amp;ar)[1]));

    {
    char  a = 's';
    char *pa = &amp;a;
    printf(""%-18s  %s\n"", ""Code:"", ""char  a = 's';"");
    printf(""%-18s  %s\n"", ""Code:"", ""char *pa = &amp;a;"");
    //printf(""argument: &amp;pa   %c\n"", &amp;pa);    // DC4M
    printf(""%-18s  0x%"" PRIXPTR ""\n"", ""&amp;pa:"",  (uintptr_t)&amp;pa);
    printf(""%-18s  0x%"" PRIXPTR ""\n"", ""&amp;a:"",   (uintptr_t)&amp;a);
    printf(""%-18s  0x%"" PRIXPTR ""\n"", ""pa:"",   (uintptr_t)pa);
    }

    {
    char  *pa = &amp;ar[0];
    char **ppa = &amp;pa;
    //printf(""argument: &amp;pa   %s\n"", ppa);  // DC4M
    printf(""%-18s  %s\n"", ""Code:"", ""char  *pa = &amp;ar[0];"");
    printf(""%-18s  %s\n"", ""Code:"", ""char **ppa = &amp;pa;"");

    printf(""%-18s  0x%"" PRIXPTR ""\n"", ""&amp;pa:"",  (uintptr_t)&amp;pa);
    printf(""%-18s  0x%"" PRIXPTR ""\n"", ""ppa:"",  (uintptr_t)ppa);
    printf(""%-18s  0x%"" PRIXPTR ""\n"", ""*ppa:"", (uintptr_t)*ppa);
    printf(""%-18s  0x%"" PRIXPTR ""\n"", ""&amp;ppa:"", (uintptr_t)&amp;ppa);
    }

}
</code></pre>

<p>This is the output from a Mac OS X 10.7.4 machine with a 64-bit compilation:</p>

<pre><code>Code:               char ar[16] = { 'a', 'b', 'c', '
argument: &amp;ar[1]  bc
ar:                 0x7FFF6C9DE570
&amp;ar:                0x7FFF6C9DE570
(ar+1):             0x7FFF6C9DE571
(&amp;ar+1):            0x7FFF6C9DE580
&amp;ar[1]:             0x7FFF6C9DE571
&amp;(ar[1]):           0x7FFF6C9DE571
(&amp;ar)[1]:           0x7FFF6C9DE580
sizeof(ar):         16
sizeof(&amp;ar):        8
sizeof(void*):      8
sizeof(ar[1]):      1
sizeof(&amp;ar[1]):     8
sizeof(&amp;(ar[1])):   8
sizeof((&amp;ar)[1]):   16
Code:               char  a = 's';
Code:               char *pa = &amp;a;
&amp;pa:                0x7FFF6C9DE560
&amp;a:                 0x7FFF6C9DE56F
pa:                 0x7FFF6C9DE56F
Code:               char  *pa = &amp;ar[0];
Code:               char **ppa = &amp;pa;
&amp;pa:                0x7FFF6C9DE558
ppa:                0x7FFF6C9DE558
*ppa:               0x7FFF6C9DE570
&amp;ppa:               0x7FFF6C9DE550
</code></pre>

<p>And this is the output from a 32-bit compilation:</p>

<pre><code>Code:               char ar[16] = { 'a', 'b', 'c', '
argument: &amp;ar[1]  bc
ar:                 0xC008A670
&amp;ar:                0xC008A670
(ar+1):             0xC008A671
(&amp;ar+1):            0xC008A680
&amp;ar[1]:             0xC008A671
&amp;(ar[1]):           0xC008A671
(&amp;ar)[1]:           0xC008A680
sizeof(ar):         16
sizeof(&amp;ar):        4
sizeof(void*):      4
sizeof(ar[1]):      1
sizeof(&amp;ar[1]):     4
sizeof(&amp;(ar[1])):   4
sizeof((&amp;ar)[1]):   16
Code:               char  a = 's';
Code:               char *pa = &amp;a;
&amp;pa:                0xC008A668
&amp;a:                 0xC008A66F
pa:                 0xC008A66F
Code:               char  *pa = &amp;ar[0];
Code:               char **ppa = &amp;pa;
&amp;pa:                0xC008A664
ppa:                0xC008A664
*ppa:               0xC008A670
&amp;ppa:               0xC008A660
</code></pre>

<p>When you understand how the various numbers were arrived at, you will be well on your way to understanding things.</p>

<p>Note that <code>&amp;array[1]</code> is interpreted as <code>&amp;(array[1])</code>; it is different from <code>(&amp;array)[1]</code> in type and size.  The postfix operators such as array subscripting bind more tightly than the unary operators such as the address (<code>&amp;</code>) and indirection (<code>*</code>) operators.</p>
",0
11553150,11552960,2,"<blockquote>
  <p>Seems that <code>&amp;ar</code> is taken as a pointer to the first element instead of a
  pointer to ""ar"", which itself is a pointer to the pointer of the first
  element if I am not mistaken.</p>
</blockquote>

<p>You <em>are</em> mistaken.  <code>&amp;ar</code> is a pointer to the array <code>ar</code>, but the array <code>ar</code> is <em>not</em> a pointer of any sort (it's an array), so <code>&amp;ar</code> is not a pointer to a pointer.</p>

<p>An array is a contiguous sequence of objects - in the case of <code>ar</code>, it's a contiguous set of 4 <code>char</code>s.  <code>&amp;ar</code> is a pointer <em>to this set of 4 chars</em>, which necessarily means it points at the same place as <code>&amp;ar[0]</code>, a pointer to the first <code>char</code> in that set.  It has a different type, though: <code>&amp;ar</code> has type <code>char (*)[4]</code> which means ""pointer to array of 4 chars"" and <code>&amp;ar[0]</code> has type <code>char *</code>, which means ""pointer to char"".</p>

<p>The confusion arises because in almost all expressions, <code>ar</code> evaluates to a pointer to the first element of the array (the exceptions to this are when it's the operand of the unary <code>&amp;</code> operator or the <code>sizeof</code> operator).  This doesn't mean that <code>ar</code> <em>is</em> a pointer though - it's not - just that in most cases it evaluates to a pointer value.</p>
",4
11553174,11552960,1,"<p>The printf format %s means ¡°The corresponding argument is a pointer to char. Print the string at that location.¡± And a string, for this purpose, is a sequence of characters ending in a null character.</p>

<p>When you passed <code>&amp;ar</code> to printf, you passed the address of the 'a' (although the type is wrong; printf expects a pointer-to-char, and you passed a pointer-to-array-of-char, but they have the same address), and printf saw the string 'a', 'b', 'c', '\0', so it printed ""abc"". The same would have happened if you passed <code>ar</code> or <code>&amp;ar[0]</code>; those evaluate to the same address.</p>

<p>When you passed <code>&amp;ar[1]</code> to printf, you passed a pointer to where the 'b' is, and printf saw the string 'b', 'c', '\0', so it printed ""bc"".</p>

<p>If you want to pass just the single character at a location, use the %c format and pass a character (instead of a pointer to character). For example, if you use the %c format with <code>*ar</code>, 'a' will be printed, and, if you use %c with <code>*&amp;ar[1]</code>, 'b' will be printed.</p>

<blockquote>
  <p>Seems that &amp;ar is taken as a pointer to the first element instead of
  a pointer to ""ar"", which itself is a pointer to the first element if
  I am not mistaken.</p>
</blockquote>

<p>When used in an expression, <code>ar</code> acts as a pointer to the first element of the array, the same as <code>&amp;ar[0]</code>. <code>&amp;ar</code> and <code>ar</code> are the same address (the first character in the array is at the same address as the start of the array) although they have different types (pointer to array of char and pointer to char).</p>

<blockquote>
  <p>the output for %c isn't even a character</p>
</blockquote>

<p>It is a character, just not what you were expecting and perhaps not a normal character or a printable character. %c expect to be passed a character argument, but you passed it an address argument.</p>

<blockquote>
  <p>If so, how does the compiler verify that the identifier following ""&amp;""
  is in reference to an array, does it actually search for it in a list
  of arrays so for declared?</p>
</blockquote>

<p>The parsing is more complicated than that (essentially, the identifier is identified as a known array before the &amp; is considered, then the combined expression of the &amp; and the identifier is evaluated). However, the effect is that <code>&amp;ar</code> evaluates to the same address as the first element.</p>
",2
12340176,12340161,1,"<p>After the compiling all the NULL have been replaced by ((void *)0). 
The malloc just return ((void *)0) if there is no memory. </p>
",0
12340181,12340161,1,"<p>It returns (void*)0 which can be compared somewhere in your source code with a NULL, something like: </p>

<pre><code>   int *ptr;
   ptr = malloc(10 * sizeof(int));
   if(ptr == NULL) 
       //do something
</code></pre>

<p>The compiler replaces the <code>NULL</code> in the if expression not the <code>ptr</code></p>
",0
12340182,12340161,5,"<p>No, you have it wrong. Imagine the <code>malloc</code> function something like this:</p>

<pre><code>void *malloc(size_t n)
{
    /* magic */
    return NULL;
}
</code></pre>

<p>The compiler replaces <code>NULL</code> <strong>when that translation unit is compiled</strong>, i.e. when the standard library is compiled so no trace of <code>NULL</code> survives past the preprocessor phase. After that point, for what it's worth, malloc just returns numbers.</p>
",1
12340194,12340161,0,"<p>The expression <code>((void *)0)</code> is the same as plain <code>0</code>, it's just typecasted to the type <code>void *</code>. That's why you can use e.g. <code>if (!myPointer)</code> to check for a pointer not being <code>NULL</code>. As <code>NULL</code> is the same as palin <code>0</code>, it doesn't matter what <code>NULL</code> was defined to in <code>malloc</code>, as <code>NULL</code> <em>always</em> has to be <code>0</code>.</p>

<p>In older libraries, and still not uncommon, <code>NULL</code> used to be defined as plain <code>0</code>, and in C++ plain <code>0</code> is commonly used instead of <code>NULL</code>.</p>
",0
12340195,12340161,0,"<p>Recall the fact that <code>void*</code> can ""carry"" pointer of <strong><em>any type</em></strong>.</p>

<p>Examples:</p>

<pre><code>void *h;
int *p, **pp;

h = p;
h = pp;
</code></pre>

<p>so if malloc fails, it will return NULL, which is defined in C as (void*)0, as other answers pointed out.</p>
",0
12302627,12302596,2,"<blockquote>
<pre><code>fptr = fopen(FNAME name "".dat"", READ_BIN);
</code></pre>
</blockquote>

<p>You can only concatenate <strong>string literals</strong> like that, and <code>name</code> isn't a string literal. Use <code>sprintf</code> or <code>strcat</code> to build up your path.</p>

<pre><code>char path[LENGTH];
snprintf(path, sizeof(path), ""%s%s.dat"", FNAME, name);
</code></pre>
",0
12302631,12302596,3,"<p>You can't concatenate a string literal (the <code>FNAME</code> macro expansion) with a variable.</p>

<p>To concatenate strings involving variables, you need to do more work. Look up the <code>strcat()</code> function, or <code>snprintf()</code>. The latter is better.</p>
",0
12302641,12302596,4,"<pre><code>#define FNAME ? ? ? ? ""c:\\users\\mahmud\\desktop\\CDs\\
                                                        ^
You're missing the ending quotation mark here: ---------+
</code></pre>

<p>(Edit: it seems it was just a copy-paste typo.)</p>

<p>Add the missing quote and also fix this:</p>

<pre><code>fptr = fopen(FNAME name "".dat"", READ_BIN);
</code></pre>

<p>This only works for string literals, since the concatenation occurs at compile time. You want to write something like this:</p>

<pre><code>char fname[512];
snprintf(fname, sizeof(fname), ""%s%s.dat"", FNAME, name);
fptr = fopen(fname, READ_BIN);
</code></pre>
",0
11166870,11166833,9,"<p>You are calling CancelarPedido before you declared it. You need to reorder the code or add a forward declaration for CancelarPedido.</p>

<p>Without a declaration of CancelarPedido in scope, it defaults to int CancelarPedido(). You get the error message because lista is declared to be a pointer but CancelarPedido is declared to return an int.</p>
",5
10102489,9849763,0,"<p>Yes, I have an idea. My idea is that you go back and rethink the algorithm you've selected for determining that a day is Thursday. It's dead wrong :-)</p>

<p>Now, like a broken clock that's right twice a day, you may find input parameters that give you the correct answer but they'll be the exception rather than the rule.</p>

<p>If you want to figure out when next Thursday is from a given date, C provides date and time functions for exactly that purpose:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

static char *textday[] = {""Sun"", ""Mon"", ""Tue"", ""Wed"", ""Thu"", ""Fri"", ""Sat""};

int main (int argc, char *argv[]) {
    int year, month, day, today, thursday;
    struct tm *mytm;
    time_t mytime;

    // Get all arguments (minimal error checks).

    if (argc != 3) {
        printf (""Usage: next_thursday &lt;year&gt; &lt;month&gt;\n"");
        return -1;
    }
    year = atoi (argv[1]);
    month = atoi (argv[2]);

    // Do first fourteen days of the month.

    for (day = 1; day &lt;= 14; day++) {
</code></pre>

<p>Up until there, it's just getting parameters and starting the loop. The meat of the calculation is below, setting up a useful <code>struct tm</code> and then forcing our year, month and day into it. Then <code>mktime</code> will fill in the <code>tm_wday</code> (day of week) field for us and we can use that to figure out the number of days till Thursday.</p>

<pre><code>        // Make the tm structure based on date (and midday).

        mytime = time (0);
        mytm = localtime (&amp;mytime);
        mytm-&gt;tm_year = year - 1900;
        mytm-&gt;tm_mon = month - 1;
        mytm-&gt;tm_mday = day;
        mytm-&gt;tm_hour = 12;
        mytime = mktime (mytm);

        // Output filled in fields and days till next Thursday.

        today = mytm-&gt;tm_wday;
        thursday = (11 - today) % 7;
        if (thursday == 0)
            thursday = 7;
        printf (""%04d-%02d-%02d, weekday = %d (%s), days till Thu = %d\n"",
            mytm-&gt;tm_year + 1900, mytm-&gt;tm_mon + 1, mytm-&gt;tm_mday,
            today, textday[today], thursday);
    }

    return 0;
}
</code></pre>

<p>Note that the <code>thursday</code> calculation is a bit of modulus trickery - it's simply used to give us the number of days based on the following table:</p>

<pre><code> today   thursday
-------  --------
0 (sun)      4
1 (mon)      3
2 (tue)      2
3 (wed)      1
4 (thu)      7
5 (fri)      6
6 (sat)      5
</code></pre>

<p>If you want a more readable solution, you can use:</p>

<pre><code>if (today &lt; 4) thursday = 4 - today;
else           thursday = 11 - today;
</code></pre>

<p>This program outputs the following for <code>2011-03</code>:</p>

<pre><code>2011-03-01, weekday = 2 (Tue), days till Thu = 2
2011-03-02, weekday = 3 (Wed), days till Thu = 1
2011-03-03, weekday = 4 (Thu), days till Thu = 7
2011-03-04, weekday = 5 (Fri), days till Thu = 6
2011-03-05, weekday = 6 (Sat), days till Thu = 5
2011-03-06, weekday = 0 (Sun), days till Thu = 4
2011-03-07, weekday = 1 (Mon), days till Thu = 3
2011-03-08, weekday = 2 (Tue), days till Thu = 2
2011-03-09, weekday = 3 (Wed), days till Thu = 1
2011-03-10, weekday = 4 (Thu), days till Thu = 7
2011-03-11, weekday = 5 (Fri), days till Thu = 6
2011-03-12, weekday = 6 (Sat), days till Thu = 5
2011-03-13, weekday = 0 (Sun), days till Thu = 4
2011-03-14, weekday = 1 (Mon), days till Thu = 3
</code></pre>
",0
18461513,18459498,1,"<p>Assuming that you cannot use <code>qsort()</code> because one of your constraints is to write your own sorting algorithm, here goes.</p>

<p>What do you need to sort? An array of<code>job</code>.  </p>

<p>What is the key by which you need to sort? <code>job.prio</code>.</p>

<p>So how to sort? Any common selection, insertion, or (eek) bubble sort will do. (Though if you go down the bubble sort route, at least make it sexy and do a cocktail shaker sort.) Just compare two <code>job.prio</code>s, both are <code>int</code>s so that's not hard, and swap the places of their respective <code>job</code> structures in the array as needed. </p>

<p>Here is a selection sort algorithm that will work. You can find plenty of others on Google. </p>

<pre><code>void selectionSort (job* jobs, int size) {

    int smallest;
    job temp;

    for (int i = 0; i &lt; size - 1; i++) {
        smallest = i;
        for (int walk = i + 1; walk &lt;= size - 1; walk++) {
            if (jobs[walk].prio &lt; jobs[smallest].prio)
                smallest = walk;
        }  // end inner loop
        temp = jobs[i];
        jobs[i] = jobs[smallest];
        jobs[smallest] = temp;
    }   // end outer loop
    return;
}
</code></pre>

<p>Fairly simple; it's just like any old selection sort. But selection sort is boring. Try to do an insertion sort, now that the selection sort gives you the general idea of how to swap the elements in the array. </p>

<p>Note that there are other problems with your code, as folks have pointed out: you are allocating space for only one job in your array, but you need eight; you have undefined variables like <code>eerste</code>; you have <code>name</code> declared twice, once as a <code>char*</code> and once as an array of <code>char</code>. So there's plenty of cleanup, but hopefully you have enough idea now to be able to finish your assignment. </p>
",0
11538264,11538198,0,"<p>It's similar to the XOR trick, but swaps only a single bit at a time and only if this bit actually differs in <code>a</code> and <code>b</code>.</p>

<p><code>1&lt;&lt;i</code> has bit <code>i</code> set to 1 and all other bits 0.</p>

<p>Also, this does not swap two numbers <em>without using a temporary variable</em>. It uses the temporary <code>i</code>.</p>
",0
11538269,11538198,1,"<p>1 has one bit on the rightmost position set. <code>1&lt;&lt;i</code> has one bit on place <code>i</code> set. This program loops through each bit, and swaps them if they are different.</p>

<ul>
<li><code>a&amp;(1&lt;&lt;i)</code> tests if <code>a</code> has bit <code>i</code> set.</li>
<li><code>((a&amp;(1&lt;&lt;i))^(b&amp;(1&lt;&lt;i)))</code> tests if bit <code>i</code> in <code>a</code> and <code>b</code> are different.</li>
<li><code>a=a^(1&lt;&lt;i)</code> toggles bit <code>i</code>.</li>
</ul>
",0
11538399,11538198,2,"<p>It toggles each bit if only one is set.</p>

<p>c = a &amp; (1 &lt;&lt; i) = true if the ith bit of a is set</p>

<p>d = b &amp; (1 &lt;&lt; i) = true if the ith bit of b is set</p>

<pre><code>| c | d | Action          | c' | d' |
-------------------------------------
| 0 | 0 | Do nothing      | 0  | 0  |
| 0 | 1 | Toggle the bits | 1  | 0  |
| 1 | 0 | Toggle the bits | 0  | 1  |
| 1 | 1 | Do nothing      | 1  | 1  |
</code></pre>
",0
10178827,10178766,2,"<p>Your problem is that they are all pointing to the same pointer: <code>identifier</code>. (also <code>expression</code>). (Whereas the first 3 adds are pointing to separate <code>const char*</code>s statically initialised.)</p>

<p>To resolve this you need to dynamically allocate space for each new element you add (e.g. with <code>malloc</code>) and release them (e.g. with <code>free</code>) when you remove them.</p>

<p>e.g:</p>

<pre><code>void add(node** database, char* _identifier, char* _expression, int * size) {
   node* tmp = (node*) malloc (sizeof(node));
   tmp-&gt;identifier = (char *)malloc(strlen(_identifier));
   strcpy(tmp-&gt;identifier, _identifier);
   tmp-&gt;expression = (char *)malloc(strlen(_expression));
   strcpy(tmp-&gt;expression, _expression);
   tmp-&gt;next = *database;
   *database = tmp;
   (*size)++;
   printf(""Added: %s : %s\n"", _identifier, _expression); fflush(NULL);
}
</code></pre>

<p>You must ensure that these resources are correspondignly released at some point or you will have a memory leak.</p>
",1
10178861,10178766,2,"<p>Umm... Because you are storing pointers and not copies of the strings?</p>

<p>You are storing the address of 'identifier' and 'expression' in main each time, so all 3 items on your linked list are pointing to the same data.</p>
",1
11175965,11175657,2,"<p>It seems there are two things going on that need to be understood:</p>
<ul>
<li><code>printf()</code> conversion specifiers</li>
<li>Integral conversions</li>
</ul>
<p>And two more things that help make sense of your output:</p>
<ul>
<li>Argument promotion for variadic function arguments</li>
<li>Two's complement representation</li>
</ul>
<p>First, <code>printf()</code> is a variadic function. It doesn't know what the types of its arguments are (other than the format string), so you have to use conversion specifiers to tell it how to interpret the arguments.  These arguments are subject to the &quot;default argument promotions&quot; such that your 3-bit bit fields are being promoted to <code>int</code>s.</p>
<p>You are using conversions specifiers (<code>%d</code>, <code>%u</code>, and <code>%d</code>) that do not match the signedness of your data, so you will get undefined behavior that depends on how your data is actually represented in memory.</p>
<p>Second, the C11 standard states:</p>
<blockquote>
<p><strong>6.3.1.3</strong> <em>Signed and unsigned integers</em></p>
<ul>
<li><p>When a value with integer type is converted to another integer type other than _Bool, if the value can be represented by the new type, it is unchanged.</p>
</li>
<li><p>Otherwise, if the new type is unsigned, the value is converted by repeatedly adding or subtracting one more than the maximum value that can be represented in the new type until the value is in the range of the new type.</p>
</li>
<li><p>Otherwise, the new type is signed and the value cannot be represented in it; either the result is implementation-defined or an implementation-defined signal is raised.</p>
</li>
</ul>
</blockquote>
<p>(As far as I can tell, the details relevant here have been true at least since C89.)</p>
<p>This tells us a couple things about your code:</p>
<ul>
<li><p>When you assign <code>-1</code> to an <code>unsigned int</code>, <code>UINT_MAX + 1</code> is added to it, giving <code>UINT_MAX</code>, or <code>4294967295</code> for 32-bit integers.</p>
</li>
<li><p>When you try to assign <code>5</code> to a 3-bit signed bit field, the result is implementation-defined.</p>
</li>
</ul>
<p>So you've got both undefined and implementation-defined behavior, but we can still try to make sense of your output, just for fun.  I'm assuming 32-bit integers and <a href=""http://en.wikipedia.org/wiki/Two%27s_complement"" rel=""nofollow noreferrer"">two's complement</a> representation.</p>
<p>Your system represents the <code>4294967295</code> stored in <code>x</code> as <code>11111111 11111111 11111111 11111111</code>. When you told <code>printf()</code> that the argument you were passing it was signed, those same bits are interpreted as <code>-1</code>, which is the output you got.</p>
<p>For <code>s.c</code>, the implementation-defined behaviour you seem to have gotten is straightforward:
the three bits <code>101</code>representing <code>5</code> got stored as-is.  That means that with the correct conversion specifier, <code>printf()</code> should show <code>s.c</code> as <code>-3</code>.</p>
<p>Here are the values you've assigned:</p>
<pre><code>s.i = 101
s.c = 101
  x = 11111111 11111111 11111111 11111111
</code></pre>
<p>The 3-bit values are promoted to 32-bit by left-padding with <code>0</code> for the unsigned value and repeating the sign for the signed value:</p>
<pre><code>s.i = 00000000 00000000 00000000 00000101
s.c = 11111111 11111111 11111111 11111101
  x = 11111111 11111111 11111111 11111111
</code></pre>
<p>Which, when interpreted as signed, unsigned, and signed integers gives:</p>
<pre><code>s.i=5
s.c=4294967293
x=-1
</code></pre>
<p>The <code>x=-1</code> suggests to me that you are in fact using a two's complement representation (which was a pretty safe bet, anyway), and the output for <code>s.c</code> suggests that your <code>int</code>s are 32 bits wide.</p>
",9
11175728,11175657,4,"<p>The output depends on the signedness of the format character, not the signedness of the declaration. Think about it: printf can't know whether x was declared int or unsigned int, since no type information is passed in C. So it prints based on how you told it to print. %d is signed, so you get a signed value. With s.c, it's an int so it's signed, but you printed it with %u so it is treated as unsigned.</p>

<p>As for s.i, it is unsigned, so 5 can fit in its 3 bits, so it is passed to printf as 5 without sign extending it, so %d (or %u) prints it as 5.</p>
",6
11168025,11167997,8,"<p>The type of <code>a</code> is <code>int[2]</code>, not <code>int*</code>. Try again with</p>

<pre><code>extern int a[2];
</code></pre>

<hr>

<p>The C compiler <strong>cannot type-check across source files</strong>. Therefore, when you say <code>int* a</code>, the compiler will assume you're telling the truth, use pointer semantics, and will not issue any compiler error.</p>

<p>There are subtle difference between arrays and pointers. Let's assume a 32-bit system. Then the content of ""a"" will be distributed like this:</p>

<pre>
    a
0x100       0x104      0x108   ¡û address
    +-----------+----------+
    |         3 |        2 |   ¡û content
    +-----------+----------+
</pre>

<p>When <code>a</code> is an <strong>array</strong>,</p>

<ul>
<li>The value of the expression <code>a</code> is will be converted to the address of <code>a</code>. Therefore, when you print <code>a</code>, you will get its address, i.e. ""0x100"".</li>
<li>The operation <code>a[n]</code> in C is equivalent to <code>*(a + n)</code>, i.e. advance the address <code>a</code> by <code>n</code> units, and then dereference it to get the content. Therefore, <code>a[0]</code> is equivalent to <code>*0x100</code>, which returns the content at 0x100, i.e. ""3"".</li>
</ul>

<p>When <code>a</code> is a <strong>pointer</strong>,</p>

<ul>
<li>The ""value"" of <code>a</code> is the content at the provided address. In fact this is the norm, the array type is a special case. Therefore, when you print <code>a</code>, you will get the content at that address, i.e. ""3"".</li>
<li>The operation <code>a[n]</code> is still <code>*(a + n)</code>. Therefore, <code>a[0]</code> is equivalent to <code>*3</code>, which causes segmentation fault because the  address ""3"" is invalid.</li>
</ul>
",7
11168334,11167997,1,"<p>You have to use consistent types for objects declared across different translation units. </p>

<p>Given <code>int a[] = {2, 3};</code>, either of the declarations <code>extern int a[];</code> or <code>extern int a[2]</code>; would be compatible whereas <code>extern int *a;</code> would not as pointers and arrays are completely separate types.</p>

<p>The one thing special about arrays is the when the name of an array appears in any expression context other than as an operand to ""address of"" (unary <code>&amp;</code>) or <code>sizeof</code>, they are automatically converted to a pointer to their first element. This is what provides the syntax compatibility between arrays and pointers, but they are not the same type.</p>

<p>Consider these two functions for a commented example. Note that the expression <code>a</code> is converted to a pointer to its first element in the second (and technically third) <code>printf</code> of the first function, but not in the first <code>printf</code> where it is the operand to <code>&amp;</code>.</p>

<pre><code>#include &lt;stdio.h&gt;

void print_array_info(void)
{
    extern int a[];
    printf(""address of a:  %p\n"", (void*) &amp;a);   // prints address of a
    printf("" converted a:  %p\n"", (void*) a);    // prints address of a[0]
    printf(""value of a[0]: %x\n"", a[0]);         // prints value of a
}

void print_pointer_info(void) {
    extern int a[];
    int *b = a; // == &amp;a[0]

    printf(""address of b:  %p\n"", (void*) &amp;b);  // prints address of b
    printf(""  value of b:  %p\n"", (void*) b);   // prints value of b (== &amp;a[0])
    printf(""value of b[0]: %x\n"", b[0]);        // prints value of b[0] (== a[0])
}
</code></pre>

<p>Note that I use <code>%p</code> to print pointers and explicitly cast to <code>void*</code>.</p>
",0
11174401,11174348,0,"<p>Is <code>novo-&gt;n_pratos</code> always less than <code>TAM</code>? There could be a bounds error if it <code>n_pratos</code> exceeds <code>TAM</code>, because <code>TAM</code> has been defined as the array size.</p>
",0
11174416,11174348,3,"<p>Inside <code>verifica_prato()</code><br>
after the line <code>f = fopen(""menu.bin"", ""rb"")</code>  you should check whether the file opened successfully or not.<br>
 use  <code>if( f != NULL )</code></p>
",0
11175955,11174348,0,"<p>Shouldnt the signature of verifca_prato be int verifica_prato(struct prato) or the call should be verifica_prato(novo->prato[i]->id);</p>
",0
10137602,10137535,0,"<p>It <em>should</em> be in the same place as <code>dlpi_ether.h</code>, which your system is not complaining about.</p>
<p>It's not really a C question insomuch as it will very much depend on the environment you're working in rather than C itself. All we can say is that you don't have that header file.</p>
<p>If you're under a UNIX like OS, you can go looking for it with something like:</p>
<pre><code>find /usr/include -name 'dlpi*.h'
</code></pre>
<hr />
<p>It appears that those header files may well not be in Linux at all, based on <a href=""http://developers.sun.com/solaris/articles/solaris_linux_app.html"" rel=""nofollow noreferrer"">this link</a> from Oracle:</p>
<blockquote>
<p>The code to read raw Ethernet is quite different between the Solaris OS and Linux (libpcap can also be used to examine the differences with other systems, such as FreeBSD, HP-UX, and AIX).</p>
<p>The applicable code in libpcap is at pcap-linux.c and pcap-dlpi.c. The DLPI code is used for Solaris, HP-UX, AIX, and other operating systems. Linux provides a mechanism for reading raw socket packets via the standard socket calls. The Solaris OS uses the getmsg(2) and putmsg(2) calls to receive and send DLPI packets.</p>
</blockquote>
",1
13776448,13776244,1,"<p>Since you already use a pipe for communication, this should be easy.</p>

<p>Pipe reads block until there's data to read and if parent process is the writer and died, you get <code>EOF</code> immediately. If your parent process never closes it's write end, then you have a reliable way to detect death.</p>

<p>Pipe writes hit <code>SIGPIPE</code> and return <code>EPIPE</code> from the call if the signal is ignored when there are no readers.</p>

<p>In the child, select (if you can block) on the fd of pipe and kill the process at appropriate time. There is no <code>SIGCHLD</code> equivalent to parent dying.</p>

<p><code>man 7 pipe</code> for a good overview. Excerpt:</p>

<pre><code>If  all file descriptors referring to the write end of a pipe have been closed, then an attempt to read(2) from
the pipe will see end-of-file (read(2) will return 0).  If all file descriptors referring to the read end of  a
pipe have been closed, then a write(2) will cause a SIGPIPE signal to be generated for the calling process.  If
the calling process is ignoring this signal, then write(2) fails with the error  EPIPE.   An  application  that
uses  pipe(2)  and  fork(2) should use suitable close(2) calls to close unnecessary duplicate file descriptors;
this ensures that end-of-file and SIGPIPE/EPIPE are delivered when appropriate.
</code></pre>
",0
11115875,11115795,1,"<p>Try deleting the declaration of <code>ACE_configure_sdd</code> from <code>voltcon.c</code>. As it is already there in <code>mss_ace.h</code>.</p>

<p>It seems you are trying to call <code>ACE_configure_sdd</code> from <code>voltcon.c</code> but in <code>c</code> you can only call a function from inside of another function. </p>

<p>You can try doing this in <code>voltcon.c</code> :</p>

<pre><code>void func1()
{
ACE_configure_sdd(this_sdd_id, this_sdd_resolution, this_mode, this_sdd_update_method);
}
</code></pre>

<p>now func1 can be called from some other function in your code or main() itself.
Hope this helps.</p>
",0
11146670,11146507,2,"<p>This sequence is a <a href=""http://en.wikipedia.org/wiki/Buffer_overflow"" rel=""nofollow"">buffer overflow</a>. You have scribbled over unrelated memory with the contents of your string, so <em>anything</em> can happen after this point. (Buffer overflows used to the be the most widely and easily exploited security problems.)</p>

<pre><code>char schedtime[7];
strcpy(schedtime,""15:25:00"");
</code></pre>

<p>You need to make sure <code>schedtime</code> is long enough to hold the entire string, including the ascii <code>NUL</code> byte at the end. <code>schedtime[9]</code> will suffice.</p>

<p>This is an odd way to write an infinite loop:</p>

<pre><code>while(6!=9)
{
...
}
</code></pre>

<p>More idiomatic is <code>while (1)</code> or <code>for (;;)</code>. Stick with those, they make it far easier for others to read your code.</p>

<p>There are probably other mistakes in the details of your code, but there is a much larger fault in the <em>design</em> of the problem; you assume that running <code>sleep(1)</code> in an infinite loop and checking the string value of the time against a target time will eventually compare <em>true</em> -- this is an incorrect assumption. A process that goes to sleep for one second may be woken up <em>after</em> the appointed time has already passed -- your process may sleep right through the 1000 miliseconds when your condition could evaluate to <em>true</em>.</p>

<p>Far better would be to check the current time against the desired time, figure out how many seconds that is away, and <code>sleep()</code> for the entire duration. Unless your task is woken by a signal first, it'll be within a second of the desired time.</p>
",0
11146553,11146507,3,"<p>Some problems with the posted code:</p>

<ul>
<li><p>This running beyond the end of the array:</p>

<pre><code>strcpy(schedtime,""15:25:00"");
</code></pre>

<p>as <code>schedtime</code> is declared as a <code>char[7]</code>, needs to be <code>char[9]</code> (8 characters plus null terminator).</p></li>
<li><p>the first argument to <code>strtok()</code> is a <code>char*</code>, not a <code>char</code>:</p>

<pre><code>timetoken=strtok('\0',"" "");
</code></pre>

<p>You meant:</p>

<pre><code>timetoken=strtok(NULL,"" "");
</code></pre></li>
<li><p>there is no check that <code>timetoken</code> is not null or to ensure that it will fit into <code>currtime</code>:</p>

<pre><code>if(i==3)
{
    strcpy(currtime,timetoken);
}
</code></pre>

<p>passing a null pointer to <code>strcpy()</code> will most almost certainly result in a segmentation fault ( <a href=""http://ideone.com/bacOG"" rel=""nofollow"">http://ideone.com/bacOG</a> ).</p></li>
</ul>
",0
11146578,11146507,5,"<p>I am not sure what you're trying to do, but this is fishy:</p>

<pre><code>while(6!=9)
{
   /* ... */
}
/* ... more code ... */
</code></pre>

<p>6 will always not equal 9, so this is an infinite loop.  There's no way to break out of the loop, and so nothing in the ""more code"" section will execute.  This means that your <code>printf</code>s won't execute, nor will your <code>system</code> call.  You need some way out of this loop.</p>

<p>To make the code easier to read (<em>which should always be a top priority!</em>), I would suggest just writing</p>

<pre><code>while (true) {
    ...
}
</code></pre>

<p>to make it clearer that the loop is supposed to run until you explicitly <code>break</code> from it.</p>

<p>Another note: this code</p>

<pre><code>system(""C:\PROJECT X"");
</code></pre>

<p>Is incorrect, because C++ will interpret <code>\P</code> as an escape character.  To fix this, escape your slash:</p>

<pre><code>system(""C:\\PROJECT X"");
</code></pre>

<p>For another bug, look closely at this loop:</p>

<pre><code>   for(i=1;i&lt;5;i++)
   timetoken=strtok('\0',"" "");
   if(i==3)
   {
       strcpy(currtime,timetoken);
   }
</code></pre>

<p>C++ is interpreting this as</p>

<pre><code>   for(i=1;i&lt;5;i++) {
       timetoken=strtok('\0',"" "");
   }

   if(i==3)
   {
       strcpy(currtime,timetoken);
   }
</code></pre>

<p>From here it's clearer that this won't work, since the <code>if</code> statement is outside the loop.  Consequently, <code>i</code> is never 3.  You probably meant</p>

<pre><code>   for(i=1;i&lt;5;i++) {
       timetoken=strtok('\0',"" "");
       if(i==3)
       {
           strcpy(currtime,timetoken);
       }
   }
</code></pre>

<p>Making the effort to clean up your code formatting (indentation, whitespace, etc.) will help prevent this sort of error.  If you had declared <code>i</code> as local to the for loop, then you probably would have spotted this earlier.  For example, this code doesn't compile:</p>

<pre><code>   for(int i = 1; i &lt; 5; i++) {
       timetoken=strtok('\0',"" "");
   }

   if(i==3) // i is not in scope
   {
       strcpy(currtime,timetoken);
   }
</code></pre>

<p>As a general rule, defer declaring variables until you absolutely need them.  It makes the code easier to read (variables in use tend to be close to the code using them) and less buggy (as shown above).</p>

<p>Hope this helps you get started!</p>
",1
11146592,11146507,1,"<p>You are copying more data into <code>schedtime</code> than you allocated:</p>

<pre><code>strcpy(schedtime,""15:25:00"");
</code></pre>

<p>The string copied is 9 characters long, you have space for 7.  This might not be a problem in itself, but if the memory is arranged in a way that <code>localtimptr</code> is involved, the terminating null character will not be there when calling <code>printf()</code> with <code>scheduletime</code>, possibly touching memory that is not allocated for your process, thus ending in error</p>
",0
18605176,18605097,-1,"<p>You're correct that as soon as what it points to goes out of scope, it will point to garbage: this is a <em>dangling pointer</em>. You'll need to allocate some memory and perform a copy to fix this:</p>

<pre><code>add_string(my_struct* s, const char* c)
{
    size_t len = strlen(c);
    s-&gt;file = malloc(len + 1);
    strcpy(s-&gt;file, c);
}
</code></pre>

<p>Don't forget that you'll need to <code>free</code> it when you're done:</p>

<pre><code>void destroy_struct(my_struct* s)
{
    free(s-&gt;file);
    free(s);
}
</code></pre>
",0
18605184,18605097,1,"<p>It would be garbage if you were somehow using <code>char** stringy</code>, but <code>structObj-&gt;stringy = stringy</code> means ""you know the thing that <code>stringy</code> points to? Now <code>structObj-&gt;stringy</code> points to that"". Of course, it is still possible to unset the value which the pointer is pointing to, and at that point dereferencing will yield garbage.</p>

<p>Here's an example to make it clearer:</p>

<pre><code> #include&lt;stdio.h&gt;
 typedef struct mStruct {
  char* stringy;
 } myStruct;

 myStruct * structObj;

 void doSomething(char* stringy)
 {
      structObj-&gt;stringy = stringy;
 }

 int main(int argc, char* argv)
 {
      char* a = ""abc\n"";
      structObj = malloc(sizeof(myStruct));
      doSomething(a);
      a = ""qxr\n"";
      printf(structObj-&gt;stringy);
 }// prints ""abc\n""
</code></pre>
",2
18605199,18605097,0,"<p><code>myStruct</code> is type which you defined for your <code>struct myStruct</code> .that to you need to  create an object before using.</p>

<p>you need to do like this:  </p>

<pre><code>typedef struct myStruct {
  char *stringy;  
} myStruct_t; //user defined  data type  

 myStruct_t *obj;  

// you need to allocate memory dynamically.   
 obj= (myStruct_t *) malloc(sizeof(myStruct_t)); 
</code></pre>

<p><strong>usage:</strong></p>

<pre><code>scanf(""%s"",obj-&gt;stringy);

printf(""%s"",obj-&gt;stringy);
</code></pre>

<p><strong>in function:</strong></p>

<pre><code>  my_free(char *str)  //str is local string 
    {
     obj-&gt;stringy=str;
    }
</code></pre>

<hr>

<p>your can also try this code :</p>

<pre><code>typedef struct myStruct {
  char stringy[20]; //char *stringy  
} myStruct_t; //user defined  data type

myStruct_t obj; //object creation    
</code></pre>

<p><strong>usage:</strong></p>

<pre><code>scanf(""%s"",obj.stringy);

printf(""%s"",obj.stringy);
</code></pre>

<p><strong>in function:</strong>  </p>

<pre><code>   my_free(char *str)  //str is local string 
    {
       strcpy(obj.stringy,str);
    }
</code></pre>
",0
18605207,18605097,1,"<p>There is not any local variable declaration in your code.</p>

<p>You have to declare:  </p>

<pre><code>typedef struct myStruct {
  char* stringy
} myStruct;

free(char *stringy){
   myStruct *structObj;
   structObj-&gt;stringy = stringy;
}
</code></pre>

<p>Pay attention to the semicolon that I've added to the end of the typedef declaration.<br>
This was not not in your code.  </p>

<p>The object structObj is a struct whose type is myStruct.  </p>

<p>Now, your parameter stringy comes from another site, it is not lost.<br>
But the struct structObj will have duration only inside your ""free"" function.  </p>

<p><strong>EDIT</strong> </p>

<p>I have fixed an error: the right declaration has to be ""pointer to structObj"", which is done in this way:</p>

<pre><code>  myStruct *structObj;
</code></pre>

<p>Observe that now myStruct is a non-initialized pointer, so the following assignment is legal:</p>

<pre><code>  structObj-&gt;stringy = stringy;
</code></pre>

<p>but will not work.  </p>

<p>However I think this goes beyond the scope of the original question...  </p>
",0
18605125,18605097,1,"<p>If <code>stringy</code> is defined in callers of <code>free</code> function, as long as they keep the actual string in its place (where <code>stringy</code> points), no problem.</p>
",0
11492429,11492355,1,"<blockquote>
  <p>Doesnt <code>-&gt;</code> operator require lvalue?</p>
</blockquote>

<p>No.  See section 6.5.2.3 of the C99 standard:</p>

<blockquote>
  <p>The first operand of the <code>-&gt;</code> operator shall have type ¡®¡®pointer to qualified or unqualified
  structure¡¯¡¯ or ¡®¡®pointer to qualified or unqualified union¡¯¡¯, and the second operand shall
  name a member of the type pointed to.</p>
  
  <p>...</p>
  
  <p>A postfix expression followed by the <code>-&gt;</code> operator and an identifier designates a member
  of a structure or union object. The value is that of the named member of the object to
  which the first expression points, and is an lvalue.</p>
</blockquote>

<p>And that's all it says on the matter.</p>
",0
11492501,11492355,0,"<p>This could be a possible definition for the struct.</p>

<pre><code>#include &lt;stdio.h&gt;

struct fuzz {
        char *str;
        } stuff = {""Hi there!""} ;

struct fuzz *ptr = &amp;stuff;

int main()
{
char ch='@';

printf(""Before: p=%p, ch=%c\n"", (void*) ptr, ch);

ch = *ptr++-&gt;str;

printf(""After: p=%p, ch=%c\n"", (void*) ptr, ch);


return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>Before: p=0x601020, ch=@
After: p=0x601028, ch=H
</code></pre>

<p>And the output proves that the pointer expression is an lvalue. Modifyable, if str would not point to a string constant.</p>
",3
11512524,11512493,3,"<p>You are reassigning <code>handshake_part3</code> to be the constant string <code>""\r\n...""</code>; did you mean to <code>strcpy()</code> (preferably <code>strncpy()</code> or equivalent!) this in instead?</p>
",0
11512531,11512493,2,"<p>You're freeing a constant string.  The memory is leaking because after you call malloc, you assign the constant string (and the malloc'd memory is leaked).</p>
",0
11512533,11512493,1,"<pre><code>handshake_part3= malloc(400); 
handshake_part3=""\r\nWebSocket-Origin: http://localhost:9605\r\nWebSocket-Location: ws://localhost:9609/\r\n\r\n"";
</code></pre>

<p>You assign a string literal to <code>handshake_part3</code>, and then try to free it... This causes the mallocated buffer to leak, and your <code>free</code> to crash. You should <code>strcpy</code> that string literal to the allocated buffer, or avoid the allocation and the freeing.</p>
",1
11512578,11512493,0,"<p>Look at this code:</p>

<pre><code>final = malloc (60);
final = strcat(key,magic); 
</code></pre>

<p>what you do is you abandon the newly allocated <code>final</code> and override it with a <code>key</code>'s address. later on you delete it twice (once via <code>final</code> and than via <code>key</code>), which is not allowed.</p>

<p>That's the only thing I noticed at a glance but I have a feeling there may be more...</p>

<p><strong>Edit:</strong> And looking at other answers I can see there are indeed ""more""</p>
",4
12878696,12878673,2,"<p>You need a ""target"" in which to execute the gcc command. Like:</p>

<pre><code>CC = gcc
CFLAGS = -Wall -g

all:
    gcc -Wall -g 3.c -o 3 -lm

clean:
    rm -f 3
</code></pre>

<p>Then you can just replace parts of the ""all"" command, with your macros; CFLAGS, for example would probably have the ""-lm"".</p>

<p>It might help if you ran ""make -n"", that will tell you what make would do if it were to run.</p>
",2
12878701,12878673,2,"<p>Often you'll see library specific flags in a <code>LIBS</code> variable, e.g.:</p>

<pre><code>CC = gcc
CFLAGS = -Wall -g -I/some/include/directory
LIBS = -lm -L/some/library/directory

all:
    $(CC) $(CFLAGS) $(LIBS) 3.c -o 3
</code></pre>
",4
12878711,12878673,2,"<p>The variable you are looking for is called <code>LDLFAGS</code>. From <a href=""http://www.gnu.org/software/make/manual/make.html#Implicit-Variables"" rel=""nofollow"">¡ì10.3 of the GNU Make manual</a>:</p>

<blockquote>
  <p>LDFLAGS</p>
  
  <p>Extra flags to give to compilers when they are supposed to invoke the linker, ¡®ld¡¯.</p>
</blockquote>

<p>So, simply do:</p>

<pre><code>LDFLAGS += -lm
</code></pre>

<p>Hope it helps.</p>
",6
12878724,12878673,0,"<p>An extremely good tutorial:  <a href=""https://sites.google.com/site/michaelsafyan/software-engineering/how-to-write-a-makefile"" rel=""nofollow"">Make Tutorial: How-To Write A Makefile</a></p>

<p>and here is a good generic makefile I wrote:</p>

<p><a href=""http://pastebin.com/PCk0gNtE"" rel=""nofollow"">http://pastebin.com/PCk0gNtE</a></p>

<p>The part that would most interest you would be this section:</p>

<pre><code># C Preprocessor Flags
CPPFLAGS +=
# compiler flags
CFLAGS += -ansi -Wall -Wextra -pedantic-errors
# libraries to link to ( m == math )
program_LIBRARIES := m
# LDFLAGS is the variable to hold linker flags
LDFLAGS += $(foreach library,$(program_LIBRARIES),-l$(library))
</code></pre>
",0
12878800,12878673,0,"<p>GNU make defines a lot of default rules. For C compilation and linking, those rules are:</p>

<p>n.o is made automatically from n.c with a recipe of the form ¡®$(CC) $(CPPFLAGS) $(CFLAGS) -c¡¯.</p>

<p>n is made automatically from n.o by running the linker (usually called ld) via the C compiler. The precise recipe used is ¡®$(CC) $(LDFLAGS) n.o $(LOADLIBES) $(LDLIBS)¡¯.</p>

<p>So the way to add ""-lm"" option to the linker is by defining:</p>

<pre><code>LDLIBS = -lm
</code></pre>

<p>Then when you run make with your Makefile, you following commands will be run:</p>

<pre><code>gcc -Wall -g -c 3.c
gcc 3.o -o 3 -lm
</code></pre>

<p>(note that make will compile your C program in 2 steps, first creating the object file 3.o then linking the object file into the executable 3)</p>

<p>(see <a href=""http://www.gnu.org/software/make/manual/"" rel=""nofollow"">http://www.gnu.org/software/make/manual/</a> for the GNU make manual)</p>
",0
12858070,12858044,4,"<p>use <a href=""http://en.cppreference.com/w/cpp/string/byte/strcmp"" rel=""nofollow""><code>strcmp()</code></a>.</p>

<p>this function is available in <code>string.h</code></p>

<pre><code>Example:

printf( ""Enter your name: "" );
scanf( ""%s"", name );
if( strcmp( name, ""Mary"" ) == 0 )
  printf( ""Hello, Dr. Mary!\n"" );
</code></pre>
",0
12858078,12858044,1,"<p>You need to use <code>strcmp</code>. Or its more secure counterpart <code>strncmp</code>.</p>

<p>Something like this:</p>

<pre><code>if (!strncmp(id, ""0x01"", 10)) {
    // they're equal!
}
</code></pre>
",0
12858084,12858044,4,"<p>If this is C++, use a <code>std::string</code>. Otherwise, use <code>strcmp</code> to compare.</p>

<p><strong>C/C++ is not a language</strong>. Stop using both tags unless they're really necessary.</p>
",0
12858085,12858044,1,"<p>You <strong>can't</strong> compare strings with <code>==</code>.</p>

<p>Depending on your OS etc, you could use <code>std::string</code> or the C <code>strcmp()</code> funcs</p>

<p>DavidRF comments that you <strong>can</strong> compare strings with <code>==</code>, and he is 100% correct. </p>

<pre><code>printf(""%s\n"", ((char *)""hello"" == (char *)""hello"") ? ""yes"" : ""no"")
</code></pre>

<p>Using <code>==</code> is comparing the pointers. If the pointers are equal, then you know that the strings are equal. You can use that to short circuit the whole string compare (although it borders on trying to be smarter than the compiler - a good <code>strcmp</code> will already have this check in it).  If the pointers are not equal, then you don't know anything about the strings they point to (they could still be equal).</p>

<p>The specific <code>printf</code> sample above is really bad: I haven't read the C standard recently, but if memory serves correctly, putting literals into a table is compiler specific behavior. Worse still, I bet it depends on compiler options (optimization levels etc). The line may work in debug mode, then give a different result in release mode - which is never good.</p>
",2
12858087,12858044,3,"<p>Start using <code>std::string</code> and you will have no problem with such things:</p>

<pre><code>std::string id = someFunction();
if (id == ""0x01"") {
    id = ""0x00"";
}
</code></pre>
",0
12858088,12858044,0,"<p>You need to use the <code>strcmp()</code> function to compare strings:</p>

<pre><code>if (strcmp(id,""0x01"") ==0) {
   // match found.
</code></pre>
",0
12858100,12858044,0,"<p>If this is C you want the <a href=""http://www.cplusplus.com/reference/clibrary/cstring/strcmp/"" rel=""nofollow"">strcmp</a> function:</p>

<pre><code>if (!strcmp(id, ""0x01"")) {
    // Do the id == ""0x01"" code
}
else {
    // Do the id != ""0x01"" code
}
</code></pre>

<p><code>strcmp()</code> returns an integral value indicating the relationship between the strings:</p>

<ol>
<li>A zero value indicates that both strings are equal.</li>
<li>A value greater than zero indicates that the first character that does not match has a greater value in str1 (id) than in str2 (""0x01"")</li>
<li>And a value less than zero indicates the opposite.</li>
</ol>
",0
12824148,12824134,252,"<p>You need to link with the math library:</p>

<pre><code>gcc -o sphere sphere.c -lm
</code></pre>

<p>The error you are seeing: <code>error: ld returned 1 exit status</code> is from the linker <code>ld</code> (part of gcc that combines the object files) because it is unable to find where the function <code>pow</code> is defined.</p>

<p>Including <code>math.h</code> brings in the declaration of the various functions and not their definition. The def is present in the math library <code>libm.a</code>. You need to link your program with this library so that the calls to functions like pow() are resolved.</p>
",3
11821678,11821648,1,"<p>It's actually a confusing error message since you seem to be casting <em>away</em> from a pointer.</p>

<p>However, the error is basically complaining that the types are not compatible.</p>

<p>Assuming that you've actually passed an integer as a pointer (Gnome specifically forbids trying to store pointers in an integer type), you should probably be using the actual type conversion macros like <a href=""http://developer.gnome.org/glib/2.32/glib-Type-Conversion-Macros.html#GPOINTER-TO-INT%3aCAPS"" rel=""nofollow""><code>GPOINTER_TO_INT</code></a>?</p>

<p>If instead, that pointer is a pointer to an integer, you should be deferencing it rather than casting it, something like:</p>

<pre><code>gint dir = *((gint*)data);
</code></pre>

<p>The fact that it only happens on AMD64 is because that's the sort of platform where pointers and integers would be a different size, one 64-bit, the other 32-bit.</p>
",2
11821682,11821648,1,"<p>Probably, the sizeof gint and gpointer are not the same.
Are you sure you know what you are doing? Why are you using a pointer as an int?</p>

<p>If you are are sure that is right, then you need to use an integer the same size as a pointer, probably gint64 or glong instead of gint.</p>

<p>Also the glib maintainers have said ""Remember, YOU MAY NOT STORE POINTERS IN INTEGERS. THIS IS NOT PORTABLE IN ANY WAY SHAPE OR FORM."" So whatever you are trying to do - its being done wrong.</p>
",1
11821683,11821648,0,"<p>You should be using <code>GPOINTER_TO_INT</code>: <a href=""http://developer.gnome.org/glib/unstable/glib-Type-Conversion-Macros.html"" rel=""nofollow"">http://developer.gnome.org/glib/unstable/glib-Type-Conversion-Macros.html</a></p>

<p>When doing this, you must have stored the pointer as an int using its corresponding macro. You should be able to see if the pointer size and the int size are the same using <code>printf(""%d %d"",sizeof(gpointer),sizeof(int))</code></p>
",0
11825957,11821648,0,"<p>It likely means your pointers are 64 bits, while your ints are 32 bits. What do you expect a compiler to do when you assign 64 bits to a 32 bit type? I'd say ""scream at me with a warning!"" :-)</p>
",0
11558934,11558540,13,"<p>I think the timing problem has to do with the fact that console is <em>line buffered</em> by default. This means that every time you write a <code>'\n'</code> character to it, your entire output buffer is sent to the console, which is a rather costly operation. This is the price that you pay for the line to appear in the output immediately.</p>

<p>You can change this default behavior by changing the buffering strategy to <em>full buffering</em>. The consequence is that the output will be sent to console in chunks that are equal to the size of your buffer, but individual operations will complete faster.</p>

<p>Make this call before you first write to console:</p>

<pre><code>char buf[10000];
setvbuf(stdout, buf, _IOFBF, sizeof(buf));
</code></pre>

<p>The timing of individual writes should improve, but the output will not appear in the console immediately. This is not too useful for debugging, but the timing will improve. If you set up a thread that calls <code>fflush(stdout)</code> on regular time intervals, say, once every second, you should get a reasonable balance between the performance of individual writes and the delay between your program writing the output and the time when you can actually see it on the console.</p>
",4
11522047,11521452,0,"<pre>

// You should assume that Node has a Node* called next that
// points to the next item in a list
// Returns the head of the reversed list if successful, else NULL / 0
Node *reverse( Node *head )
{
    Node *prev = NULL;

    while( head != NULL )
    {
        // Save next since we will destroy it
        Node *next = head->next;

        // next and previous are now reversed
        head->next = prev;

        // Advance through the list
        prev = head;
        head = next;
    }
    return previous;
}
</pre>
",0
11521558,11521452,1,"<ol>
<li>Doesn't your loop guard insure that start is null?</li>
<li>If you aren't using start to identify the first element of the list, then the variable you ARE using is still pointing to what WAS the first element, which is now the last.</li>
</ol>
",0
11524623,11521452,0,"<p>c is a helper pointer.</p>

<pre><code>void reverselist()
{
    struct node *a, *b, *c;
    a=NULL;
    b=start;
    while(b!=NULL)
    {
        c=b-&gt;next
        b-&gt;next=a;
        a=b
        b=c
    }
    start=a;
}
</code></pre>
",0
11521753,11521452,0,"<p>I would have made a prepend function, and done the following:</p>

<pre><code>struct node* prepend(struct node* root, int value)
{
    struct node* new_root = malloc(sizeof(struct node));
    new_root-&gt;next = root;
    return new_root;
}

struct node* reverselist(struct node* inlist)
{
    struct node* outlist = NULL;

    while(inlist != NULL) {
        struct node* new_root = prepend(outlist, inlist-&gt;value);
        outlist = new_root;
        inlist = inlist-&gt;next;
    }

    return outlist;
}
</code></pre>

<p>Have not tested this, but guess you grasp the idea of it. Might be just your variable names, which don't describe anything, but I think this approach is cleaner, and easier to understand what actually happens.</p>

<p>EDIT:</p>

<p>Got a question why I don't do it inplace, so I'll answer it here:</p>

<ol>
<li>Can you do it inplace? Are you sure you don't wish to keep the
original list?</li>
<li>Do you need to do it inplace? Is the malloc to time consuming/is this a performance critical part of your code? Remember: premature optimization is the root of all evil.</li>
</ol>

<p>Thing is, this is a first implementation. It should work, and not be optimized. It should also have a test written before this implementation is even thought of, and you should keep this slow, un-optimized implementation until the test passes, and you have proved that it's to slow for your use!</p>

<p>When you have a passing unit test, and proven the implementation to be to slow, you should optimize the code, and make sure it still passes the test, without changing the test.</p>

<p>Also, is it necessary inplace operations which is the answer? What about allocating the memory before reverting it, this way you only have one allocation call, and should hopefully get a nice performance boost.</p>

<p>This way everyone is happy, you have a cleaner code and avoid the risk of having Uncle Bob showing up at your door with a shotgun.</p>
",6
11546425,11545713,0,"<p>Well, a real naive and basic answer would be that graph can be represented in C using data structures that contain their pointers to other such data structures. Graphs are really just doubly linked lists that can have multiple links from a single node. If you haven't digested linked lists and doubly linked lists, that'd be a good place to start.</p>

<p>So let's say you have a adjacency list, {a,b},{b,c},{d},{b,e}. First off, you parse that and make a list of all your unique items. (A regular linked list, array, whatever, it's just a temporary structure to help you. You could bypass that, do it on the fly, and probably reap a speedup, but this is simple.) Walking through that list, you generate a node for each item. For each node, you go through the adjacency list again and create an edge when it sees itself. This is a pointer inside the node pointing to another node.</p>

<p>In the end you have a regular list of all you nodes, so you don't lose that lone 'd' node hanging out by itself. You also have a graph of all your nodes so you know their relationship to each other.</p>

<p><strong>Search</strong><br>
Searching across graphs is a pretty basic idea. Start in a node, compare, move to one of it's neighbors and do it again. There are a lot of pitfalls though. Like getting into an endless loop and knowing when to stop.</p>

<p>You'll have to ask more specific questions if you want a better explanation than what you can find online already. </p>
",0
11546178,11545713,2,"<p>I assume that here graph is a collection of vertex and edges. For that you would need an array of pointer to structures. This is adjacency list representation of graph. These structures would having at least an value, which is node number and pointer to another structure. While inserting a new node to graph just go to appropriate index of array and push the node at beginning. This is O(1) time for insertion. My implementation might help you in understanding how it really works. If you are having good skills at C this wouldn't take much longer to understand the code.</p>

<pre><code>//  Graph implementation by adjacency list

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define MAX_SIZE 1000

typedef struct node{
    int number;
    struct node * next;
} Node;


//  U is starting node, V is ending node
void addNode (Node *G[], int U, int V, int is_directed)
{
    Node * newnode = (Node *)malloc(sizeof(Node));
    newnode-&gt;number = V;
    newnode-&gt;next = G[U];
    G[U] = newnode;

//  0 for directed, 1 for undirected
    if (is_directed)
    {
        Node * newnode = (Node *)malloc(sizeof(Node));
        newnode-&gt;number = U;
        newnode-&gt;next = G[V];
        G[V] = newnode;
    }
}

void printgraph(Node *G[], int num_nodes)
{
    int I;
    for (I=0; I&lt;=num_nodes; I++)
    {
        Node *dum = G[I];
        printf(""%d : "",I);
        while (dum != NULL)
        {
            printf(""%d, "",dum-&gt;number);
            dum =dum-&gt;next;
        }
        printf(""\n"");
    }

}



void dfs (Node *G[], int num_nodes, int start_node)
{
    int stack[MAX_SIZE];
    int color[num_nodes+1];
    memset (color, 0, sizeof(color));
    int top = -1;
    stack[top+1] = start_node;
    top++;
    while (top != -1)
    {
        int current = stack[top];
        printf(""%d  "",current);
        top--;
        Node *tmp = G[current];
        while (tmp != NULL)
        {
            if (color[tmp-&gt;number] == 0)
            {
                stack[top+1] = tmp-&gt;number;
                top++;
                color[tmp-&gt;number] = 1;
            }
            tmp = tmp-&gt;next;
        }
    }

}

void bfs (Node *G[], int num_nodes, int start_node)
{
    int queue[MAX_SIZE];
    int color[num_nodes+1];
    memset (color, 0, sizeof (color));
    int front=-1, rear=-1;
    queue[rear+1] = start_node;
    rear++;printf(""\n\n"");
    while (front != rear)
    {
        front++;
        int current = queue[front];
        printf(""%d  "",current);

        Node *tmp = G[current];
        while (tmp != NULL)
        {
            if (color[tmp-&gt;number] == 0)
            {
                queue[rear+1] = tmp-&gt;number;
                rear++;
                color[tmp-&gt;number] = 1;
            }
            tmp = tmp-&gt;next;
        }
    }

}  

int main(int argc, char **argv)
{
    int num_nodes;
    // For Demo take num_nodes = 4
    scanf(""%d"",&amp;num_nodes);
    Node *G[num_nodes+1];
    int I;
    for (I=0; I&lt;num_nodes+1 ;I++ )
        G[I] = NULL;

    addNode (G, 0, 2, 0);
    addNode (G, 0, 1, 0);
    addNode (G, 1, 3, 0);
    addNode (G, 2, 4, 0);
    addNode (G, 2, 1, 0);
    printgraph( G, num_nodes);
    printf(""DFS on graph\n"");
    dfs(G, num_nodes, 0);
    printf(""\n\nBFS on graph\n"");
    bfs(G, num_nodes, 0);

    return 0;
} 
</code></pre>
",2
12828361,12828278,0,"<p>Libraries compiled by different compilers (or different versions of the same compiler) might use different calling conventions and thus not have binary compatibility.  You might consider remaking the whole project with the new compiler if you haven't already to see if that fixes it.</p>
",5
12819450,12819391,3,"<p>Math functions are part of <code>libm</code>. Link them when you compile with <code>-lm</code>.</p>
",2
12819458,12819391,5,"<p>You need to <em>link</em> with the math library as well, it's not included by default.</p>

<p>Something like the following command:</p>

<pre><code>$ gcc 3.c -lm
</code></pre>

<p>Notice the <code>-lm</code> argument... It tells the linker to add a library (the <code>-l</code> part) and the name of the library (the <code>m</code> part).</p>
",8
12819497,12819391,0,"<p>You need to include <code>&lt;stdlib.h&gt;</code> for malloc and free.</p>

<p>For the math stuff to work you have to link it,
    <code>gcc 3.c -lm</code>
Where <code>-l</code> is the library flag and m is tell it to use the math library</p>

<p>Also you need to move the definition of prime to above main, things need to be declared in order.</p>

<p>Since you are just starting here are some other helpful flags for the compiler</p>

<p><code>-g</code> this will give better debugging when using valgrind or gdb. </p>

<p><code>-o</code> lets you define the compiled file name eg: <code>gcc 3.c -o 3</code> will create <code>./3</code> instead of <code>./a.out</code></p>
",0
12819513,12819391,1,"<p>3.c:52:26: warning: incompatible implicit declaration of built-in function ¡®malloc¡¯ [enabled by default]</p>

<p>Is caused by a missing include, malloc() is defined in stdlib.h so need to include that.</p>

<p>3.c:(.text+0x272): undefined reference to `pow' (and the rest)</p>

<p>Is caused by a missing link to libm. Most (if not all) methods in math.h are not in standard libc that always gets linked but in libm instead.</p>

<p>How to link differs between compiler, but for gcc (and many other unix compilers):</p>

<p>gcc 3.c -o 3 -lm</p>

<p>Where ""-lm"" tells gcc to link libm.</p>
",1
11557291,11557206,1,"<p>You declare an array of <em>pointers</em>:</p>

<pre><code>struct node *arr[MAX];
</code></pre>

<p>In your <code>createEmptyGraph()</code> method, you need to allocate each structure in the array first - instead you are setting simply the <em>pointer</em> to null..</p>

<pre><code>for(i=0;i&lt;n;i++)
{
    arr[i]=NULL;
}
</code></pre>

<p>The following won't work because you've not <em>allocated</em> each entry:</p>

<pre><code>for(i=0;i&lt;n;i++)
{
    arr[i]-&gt;data=d;
    arr[i]-&gt;next=NULL;
}
</code></pre>

<p>Allocate first (<code>malloc()</code>) and then you can set as above...</p>

<p>So, because of the fact that you've not allocated, the following will not work:</p>

<pre><code>n-&gt;next=arr[startVertex]; // this is okay, you've set it to NULL
arr[startVertex]-&gt;next=n; // ERROR: you are accessing a NULL pointer!
</code></pre>
",0
11557309,11557206,0,"<p>You cannot do this</p>

<pre><code> for(i=0;i&lt;n;i++) 
 {     
      arr[i]-&gt;data=d;     
      arr[i]-&gt;next=NULL; 
 }
</code></pre>

<p>because your array has not been initialised. The pointers in this array are uninitialised and dereferencing them is not a good idea. Either change the array to be an array of structs instead of struct pointers, or allocate memory to the pointers in your array. Dereferencing uninitialised or NULL pointers is asking for trouble.</p>
",0
11557325,11557206,0,"<pre><code>CreateEmptyGraph()
for(i=0;i&lt;n;i++)
{
    arr[i]-&gt;data=d;    // arr[i] is a pointer that must be initialized first.
    arr[i]-&gt;next=NULL; // arr[i] is a pointer that must be initialized first.
}
</code></pre>

<p>Since the array <em>arr</em> is an array of pointers you can't call <em>CreateEmptyGraph</em> without initializing <em>arr</em> otherwise you can get access violations.</p>
",0
11557355,11557206,0,"<p>There are several strange things going on in your code.</p>

<ul>
<li>You only have a <code>struct node</code>, no <code>struct edge</code>. As <code>node</code> only has a single <code>next</code> pointer, each node can only have zero or one outgoing edges in this model.</li>
<li><code>addNode</code> looks like it should add edges, but the name says otherwise.</li>
<li>As <code>arr</code> represents the nodes of your graph, if <code>addNode</code> really should add an edge, then why does it allocate a new node? And when it should add a node, why doesn't it add that to the array?</li>
</ul>

<p>As to why your code fails:</p>

<blockquote>
<pre><code>arr[startVertex]-&gt;next=n;
</code></pre>
</blockquote>

<p>This will fail, as all entries of <code>arr</code> are initialized to <code>NULL</code> and never changed from that. You can't use <code>-&gt;</code> to access members of a non-existant object.</p>
",0
11549063,11547875,0,"<pre><code>--- graph.c 2012-07-18 21:33:52.405175347 +0200
+++ graph2.c    2012-07-18 21:40:01.150704287 +0200
@@ -1,3 +1,4 @@
+
 #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;

@@ -11,9 +12,10 @@
 {
 // creating a new linked list which is to be added
 struct graphnode *tmp;
+tmp = malloc (sizeof *tmp);
 tmp-&gt;name=endNode;
 tmp-&gt;next=G[startNode];
-startNode=tmp;
+G[startNode] = tmp;
 }

 void printGraph(struct graphnode *G[], int numofnodes)
@@ -22,13 +24,11 @@
 for(i=0;i&lt;numofnodes;i++)
 {
     struct graphnode *tmp;
-    tmp=G[i];
     printf(""%d"",i);

-    while(tmp!=NULL)
+    for(tmp = G[i]; tmp; tmp = tmp-&gt;next)
     {
         printf(""%d"",tmp-&gt;name);
-        tmp=tmp-&gt;next;
     }
 }
 }
@@ -36,21 +36,24 @@
 int main(void)
 {
 int numofnodes;
+int i;
+struct graphnode **arrayOfVertices;
+
 printf(""Enter the number of nodes: "");
 scanf(""%d"",&amp;numofnodes);

 // Note that we have created depending upon the size inputted by the user
-struct graphnode *arrayOfVertices[numofnodes];
-int i;      // for iteration
+arrayOfVertices = malloc ( numofnodes * sizeof *arrayOfVertices);

 for(i=0;i&lt;numofnodes;i++)
 {
+    arrayOfVertices[i] = malloc (sizeof *arrayOfVertices[i] );
     arrayOfVertices[i]-&gt;name=i;
     arrayOfVertices[i]-&gt;next=NULL;
 }

 addNode(arrayOfVertices,0,1);
-addNode(aarrayOfVertices,0,2);
+addNode(arrayOfVertices,0,2);
 printGraph(arrayOfVertices,numofnodes);

 return 0;
</code></pre>

<p>Note: I've only spotted the obvious errors. I replaced the variable sized array by a dynamically allocated one.</p>
",0
12862229,12862197,2,"<p>This defines a type name for the function pointer. Using this, <code>__handler</code> is now a type alias for a pointer to a function that takes an <code>int</code> and returns <code>void</code>.</p>

<pre><code>void myFunction(int)
{
    // ...
}

int main(int argc, char **argv)
{
    __handler functionPtr = &amp;myFunction;

    // ...
}
</code></pre>
",0
14777310,14777283,0,"<p>That output doesn't come from YOUR program, it comes from the program that runs your program. Most likely ""Visual Studio"", but I expect some other types of IDE's may do similar things. </p>
",0
14777311,14777283,6,"<p>The message that you see is actually generated by the Visual Studio debugger. It's not really coming from your program.</p>

<p>If you would like to verify that your program is not actually displaying any message (nor waiting for a key press) just try running it from a windows command prompt. You may also try running the program in ""Release"" mode from withing Visual Studio. That will also confirm this.</p>

<p>The reason the debugger displays that information is just to help you understand what is going on with your program. </p>
",0
14777353,14777283,0,"<p>Can you post details of your execution environment? Seems like your process is being monitored for an exit code by another application (specialized shell perhaps) which is printing the ""Press any key to continue"" line</p>
",0
14777386,14777283,0,"<p>The <code>process exited with return value 0</code> certainly isn't coming from your code, rather a program in the middle of your input and the output.</p>

<p>I compiled this on the command line (Mac OSX) and was presented with the following output:</p>

<pre><code>James:Desktop iPhone$ gcc code.c 
James:Desktop iPhone$ ./a.out
# quit
successJames:Desktop iPhone$ 
</code></pre>

<p>Note that I didn't reach the  <code>system(""PAUSE"");</code> either</p>
",0
13755385,13755307,1,"<p>You can use <code>strtok()</code> to tokenize or split strings. Please refer the following link for an example: <a href=""http://www.cplusplus.com/reference/cstring/strtok/"" rel=""nofollow"">http://www.cplusplus.com/reference/cstring/strtok/</a></p>

<p>You can take array of character pointers and assign tokens to them.</p>

<p>Example:</p>

<pre><code>char *tokens[100];
int i = 0;
char *token = strtok(string, "" "");
while (token != NULL) {
    tokens[i] = token;
    token = strtok(NULL, "" "");
    i++;
}

printf(""Total Tokens: %d"", i);
</code></pre>
",0
13755401,13755307,0,"<p>Note the <code>%s</code> specifier strips whitespace. So you can write:</p>

<pre><code>    std::string s = ""A is the 1 letter"";
    typedef char Word[128];
    Word words[6];
    int wordsRead = sscanf(s.c_str(), ""%128s%128s%128s%128s%128s%128s"", words[0], words[1], words[2], words[3], words[4], words[5] );
    std::cout &lt;&lt; wordsRead &lt;&lt; "" words read"" &lt;&lt; std::endl;
    for(int i = 0;
        i != wordsRead;
        ++i)
        std::cout &lt;&lt; ""'"" &lt;&lt; words[i] &lt;&lt; ""'"" &lt;&lt; std::endl;
</code></pre>

<p>Note how this approach (unlike <code>strtok</code>), effectively requires an assumption about the maximim number of words to read, as well as their lengths.</p>
",0
13755415,13755307,0,"<p>I would recommend using <code>strtok()</code>. 
Here is the example from <a href=""http://www.cplusplus.com/reference/cstring/strtok/"" rel=""nofollow"">http://www.cplusplus.com/reference/cstring/strtok/</a></p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main ()
{
  char str[] =""- This, a sample string."";
  char * pch;
  printf (""Splitting string \""%s\"" into tokens:\n"",str);
  pch = strtok (str,"" ,.-"");
  while (pch != NULL)
  {
    printf (""%s\n"",pch);
    pch = strtok (NULL, "" ,.-"");
  }
  return 0;
}
</code></pre>

<p>Output will be:</p>

<p><code>Splitting string ""- This, a sample string."" into tokens:</code></p>

<p><code>This</code></p>

<p><code>a</code></p>

<p><code>sample</code></p>

<p><code>string</code></p>
",0
13755438,13755307,2,"<p>You shouldn't use <code>feof()</code> like that.  You should use <code>fgets()</code> or equivalent.  You probably need to use the little-known (but present in standard C89) conversion specifier <code>%n</code>.</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    char buffer[1024];

    while (fgets(buffer, sizeof(buffer), stdin) != 0)
    {
        char *str = buffer;
        char word[256];
        int  posn;
        while (sscanf(str, ""%255s%n"", word, &amp;posn) == 1)
        {
            printf(""Word: &lt;&lt;%s&gt;&gt;\n"", word);
            str += posn;
        }
    }
    return(0);
}
</code></pre>

<p>This reads a line, then uses <code>sscanf()</code> iteratively to fetch words from the line.  The <code>%n</code> format specifier doesn't count towards the successful conversions, hence the comparison with 1.  Note the use of <code>%255s</code> to prevent overflows in <code>word</code>. Note too that <code>sscanf()</code> could write a null after the 255 count specified in the conversion specification, hence the difference of one between the declaration of <code>char word[256];</code> and the conversion specifier <code>%255s</code>.</p>

<p>Clearly, it is up to you to decide what to do with each word as it is extracted; the code here simply prints it.</p>

<p>One advantage of this technique over any solution based on <code>strtok()</code> is that <code>sscanf()</code> does not modify the input string so if you need to report an error, you have the original input line to use in the error report.</p>

<hr>

<p>After editing the question, it seems that the punctuation like semi-colon is not wanted in a word; the code above would include punctuation as part of the word.  In that case, you have to think a bit harder about what to do.  The starting point might well be using and alphanumeric scan-set as the conversion specification in place of <code>%255s</code>:</p>

<pre><code>""%255[a-zA-Z_0-9]%n""
</code></pre>

<p>You probably then have to look at what's in the character at the start of the next component and skip it if it is not alphanumeric:</p>

<pre><code>if (!isalnum((unsigned char)*str))
{
    if (sscanf(str, ""%*[^a-zA-Z_0-9]%n"", &amp;posn) == 0)
        str += posn;
}
</code></pre>

<p>Leading to:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

int main(void)
{
    char buffer[1024];

    while (fgets(buffer, sizeof(buffer), stdin) != 0)
    {
        char *str = buffer;
        char word[256];
        int  posn;
        while (sscanf(str, ""%255[a-zA-Z_0-9]%n"", word, &amp;posn) == 1)
        {
            printf(""Word: &lt;&lt;%s&gt;&gt;\n"", word);
            str += posn;
            if (!isalnum((unsigned char)*str))
            {
                if (sscanf(str, ""%*[^a-zA-Z_0-9]%n"", &amp;posn) == 0)
                    str += posn;
            }
        }
    }
    return(0);
}
</code></pre>

<p>You'll need to consider the I18N and L10N aspects of the alphanumeric ranges chosen; what's available may depend on your implementation (POSIX doesn't specify support in <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/fscanf.html"" rel=""nofollow""><code>scanf()</code></a> scan-sets for the notations such as <code>[[:alnum:]]</code>, unfortunately).</p>
",0
12298322,12298162,0,"<p>Your code is way more complicated than it needs to be - you could simplify it to something like this:</p>

<pre><code>uint8_t voltage_string(char* buf, int32_t uVolt)
{
    const int32_t VOLT = 1000000;
    const int32_t MILLIVOLT = 1000;

    uint8_t n = 0;

    if (abs(uVolt) &gt;= VOLT)
    {
        n = sprintf(buf, ""%+.6f V"", uVolt / (double)VOLT);
    }
    else if (abs(uVolt) &gt;= MILLIVOLT)
    {
        n = sprintf(buf, ""%+.3f mV"", uVolt / (double)MILLIVOLT);
    }
    else
    {
        n = sprintf(buf, ""%+d ¦ÌV"", uVolt);
    }

    return n;
}
</code></pre>
",0
12300313,12298162,0,"<pre><code>uint8_t voltage_string(char* buf, int32_t uVolt) 
{     
    const int32_t VOLT = 1000000;     
    const int32_t MILLIVOLT = 1000;      
    int v=0,mv=0,uv=0;
    uint8_t n = 0;      
    v = uVolt/VOLT;
    mv = (uVolt % VOLT) / MILLIVOLT;
    uv = (uVolt % VOLT) % MILLIVOLT;
    n = sprintf(buf, ""%d.%03d%03d  V"", v,mv,uv); 
    return n; 
}
</code></pre>
",0
13464267,13464243,3,"<p>The main function has a return-type of int, as indicated in</p>

<pre><code>int main(void)
</code></pre>

<p>however your main function does not return anything, it closes after </p>

<pre><code>puts(strB);
</code></pre>

<p>Add </p>

<pre><code>return 0;
</code></pre>

<p>after that and it will work.</p>
",0
13464268,13464243,21,"<p>Just put <code>return 0</code> in your <code>main()</code>. Your function main returns an int (<code>int main(void)</code>) therefore you should add a return in the end of it.</p>

<p>Control reaches the end of a non-void function</p>

<pre><code>Problem: I received the following warning:
</code></pre>

<p><strong>warning</strong>: control reaches end of non-void function</p>

<p>Solution: This warning is similar to the warning described in Return with no value. If control reaches the end of a function and no return is encountered, GCC assumes a return with no return value. However, for this, the function requires a return value. At the end of the function, add a return statement that returns a suitable return value, even if control never reaches there.</p>

<p><a href=""http://publib.boulder.ibm.com/infocenter/tpfhelp/current/index.jsp?topic=/com.ibm.ztpf-ztpfdf.doc_put.cur/gtpm1/m1rhnvf.html"" rel=""noreferrer"">source</a></p>

<p><strong>Solution</strong>:</p>

<pre><code>int main(void)
{
    my_strcpy(strB, strA);
    puts(strB);
    return 0;
}
</code></pre>
",0
13464308,13464243,13,"<p>As an alternative to the obvious solution of adding a <code>return</code> statement to <code>main()</code>, you can use a C99 compiler (¡°gcc -std=c99¡± if you are using GCC).</p>

<p>In C99 it is legal for <code>main()</code> not to have a <code>return</code> statement, and then the final <code>}</code> implicitly returns 0.</p>

<pre><code>$ gcc -c -Wall t.c
t.c: In function ¡®main¡¯:
t.c:20: warning: control reaches end of non-void function
$ gcc -c -Wall -std=c99 t.c
$ 
</code></pre>

<hr>

<p>A note that purists would consider important: you should <strong>not</strong> fix the warning by declaring <code>main()</code> as returning type <code>void</code>.</p>
",0
15538755,15538711,7,"<p>Do you mean to write </p>

<pre><code>void read_student_p(struct student* student3)
                                  ^
{    


read_student_p(&amp;student1);
               ^
</code></pre>

<p>You need to pass a pointer to <code>read_student_p</code> if you want to modify the <code>struct</code> that you are passing. Currently it is passed by value, and the modifications are lost.</p>

<p>Considering the <code>_p</code> suffix, I expect that this was intended..</p>
",0
15538758,15538711,1,"<p>When you do this:</p>

<p><code>read_student_p(student1);</code></p>

<p>And the method looks like this:</p>

<pre><code>void read_student_p(struct student student3)
{    

  printf(""enter student name for second function: \n"");
  scanf(""%s"",&amp;student3.name);
  printf(""enter student marks for second function: \n"");
  scanf(""%f"",&amp;student3.marks);

 }
</code></pre>

<p>Structs in C are passed by value, not by reference.</p>

<p>So what read_student_p does is take a copy of the struct you pass in (student1), edit the copy, and then do nothing.</p>

<p>One solution would be to return the changed version of the struct. Another version would be to pass a pointer to a struct, and edit the struct via pointer (so that you're editing the same copy of the struct directly).</p>
",0
15538769,15538711,0,"<p>In the second function <code>read_student_p</code> you were calling by value, which is to say, you defined a new struct variable <code>tmp</code> in the function, and copied the value of <code>student1</code> to this tmp value. All the modifications that you've done were on tmp value, which wouldn't affect <code>student1</code>.</p>
",0
15515797,15515441,2,"<p>Variables within block scope whose name is same as the global scope hides the global identifier</p>

<p><a href=""http://busybox.net/~landley/c99-draft.html#6.2.1"" rel=""nofollow"">ISO C9899 in 6.2.1</a> says:</p>

<blockquote>
  <p>If an identi?er designates two different entities in the same name space, the scopes might overlap.  If so, the scope of one entity (the inner scope) will be a strict subset of the scope of the other entity (the outer scope). Within the inner scope, the identi?er designates the entity declared in the inner scope; the entity declared in the outer scope is hidden (and not visible) within the inner scope.</p>
</blockquote>

<p>So here the global <code>struct foo</code> is hidden totally(as if its not there) if you just refer to the typename inside the <code>main()</code>. </p>

<p>Suggestions : use different names or use variables with different names for these types or typedef the struct types.</p>

<p>Your <code>printf(""Size of struct foo is: %d\n"",sizeof(struct foo));</code> will give the size of only local struct foo(28 or 25 depends).</p>
",0
15520680,15515441,1,"<p>Standard C does not provide any way to refer to an identifier (either object name or type name) that is hidden by a local declaration.</p>

<p>In this case, you can see the size of the global <code>struct foo</code> by using the size of the object, <code>sizeof globe_foo</code>.</p>

<p>GCC (and compilers supporting its extensions) provides a way to refer to the type of an object, <code>__typeof__</code>. So, in GCC, you can refer to the type of <code>globe_foo</code> with <code>__typeof__(struct globe_foo)</code>.</p>

<p>Another option is to give the global type an alias, with <code>typedef</code>. If, at file scope, you declare <code>typedef struct foo foo_t;</code>, then the type <code>foo_t</code> will be visible inside a function even when <code>struct foo</code> is hidden.</p>

<p>When printing sizes (values of type <code>size_t</code>), you should use a <code>%zu</code> specification with <code>printf</code>, not <code>%d</code>.</p>
",0
19882513,19882482,1,"<p>You should write: <code>sscanf(""4711bar"", ""%d%s"", &amp;a, b);</code>
The <code>&amp;</code> makes <code>&amp;a</code> is <strong>a pointer</strong> to <code>a</code> and <code>sscanf</code> requires pointers.</p>

<p>The second example works, because <code>a</code> is an array. And array <code>a</code> of type <code>char[100]</code> is implictly converted to pointer of type <code>char *</code>  pointing to the array's first element (<code>a[0]</code>). So <code>a</code> is the same as <code>&amp;(a[0])</code></p>

<pre><code>int a;
char b[100];
sscanf(""4711bar"", ""%d%s"", &amp;a, b);
</code></pre>

<p>-</p>

<pre><code>char a[100];
sscanf(""foo"", ""%s"", a);
</code></pre>
",4
19882536,19882482,0,"<p>You should pass valid pointers to <code>sscanf</code>, <code>&amp;a</code> for integer and <code>b</code> for string:</p>

<pre><code>sscanf(""4711bar"", ""%d%s"", &amp;a, b);
                          ^
</code></pre>

<p>Moreover, your code is C-ish not C++. Using C++ it should looks something like:</p>

<pre><code>std::stringstream s;
s &lt;&lt; ""4711bar"";

int a;
std::string b;

s &gt;&gt; a &gt;&gt; b;
</code></pre>
",0
15818537,15818341,1,"<p>Try replacing <code>printf("""");</code> with <code>printf("" "");</code> </p>

<p>(difference is a space between the quotes)</p>
",0
15818543,15818341,4,"<p>The problem is with your <code>printf("""");</code> statement</p>

<p>make it <code>printf("" "");</code> by adding a space.</p>

<p>Your original <code>printf("""");</code> statement doesn't add any change to the format of your output.</p>

<p>Where as <code>printf("" "");</code> prints a white space with each iteration of the loop,</p>

<pre><code>for(k=num-2*i;k&gt;=0;k--) 
</code></pre>
",1
17796115,17796041,6,"<p>by using <code>%d</code> you treat your value as <code>signed</code> to proceed by <code>printf</code>. </p>

<p>you may use <code>%u</code> instead.</p>

<p><strong>added</strong></p>

<p>As  <em>Magn3s1um</em> pointed out you don't need to specify <code>signed</code> and <code>unsigned</code> for your particular task <code>printf</code> will make all job for you.</p>
",1
17796122,17796041,4,"<p>Output: </p>

<ol>
<li><p><strong>Note:</strong><br>
¡°In the expression <code>i &gt;&gt;= 1</code>, a negative value is shifted right. The C standard says this is an implementation-defined operation, and many implementations define it to be arithmetic shift. In an arithmetic shift, the most significant bit is unchanged (keeps MSB (signed bit) = <code>1</code>)"".</p>

<p>(you can read: <a href=""https://stackoverflow.com/questions/15729765/why-does-the-output-of-applied-on-a-negative-number-is-filled-with-ones-on-th/15730750#15730750"">Right shifting negative numbers in C</a> that <code>&gt;&gt;</code> is compiler dependent whether its singed or unsinfed shift, but probably in your case its doing an Arithmetic Shift.)</p>

<p>For this reason after code: </p>

<pre><code> i = ~0;  
 i &gt;&gt;= 1;
</code></pre>

<p><code>i</code> remains <code>~0</code>. that is in binary == <code>11111111111111111111111111111111</code>.</p>

<p>And because <code>~0</code> == <code>11111111111111111111111111111111</code> is == 2'c complement of <code>1</code>  that is <code>-1</code>.  </p>

<p>So when you prints with format string <code>%d</code> it print <code>-1</code>. You should use <code>%u</code> to print max unsigned value that is == <code>~0</code>.</p>

<p><strong>Important to note here:</strong> </p>

<blockquote>
  <p><a href=""https://is.muni.cz/www/408176/38744863/International_Standard_for_C.txt"" rel=""nofollow noreferrer""><strong>¡ì6.2.6.2 Language 45</strong></a>, ?ISO/IEC ISO/IEC 9899:201x</p>
  
  <p>(ones¡¯ complement).    Which of these applies is
  <code>implementation-de?ned</code>, as is whether the value with sign bit <code>1</code>    and
  all value bits zero (for the ?rst two), or with sign bit and all value
  bits 1 (for ones¡¯    complement), is a trap representation or a normal
  value. In the case of sign and    magnitude and ones¡¯ complement, if
  this representation is a normal value it is called a   negative zero.</p>
</blockquote>

<p>Your understanding  that : </p>

<p><code>~0 &gt;&gt; 1 == 011111111111111111111111111111111</code> is wrong! (it may be but not happening in your system, according to output)</p>

<p><code>~0 &gt;&gt; 1 == 111111111111111111111111111111111</code>, note MSB(signed bit)  is <code>1</code>.  </p>

<p>For unsigned shift, try following: </p>

<p><code>~0U &gt;&gt; 1 == 011111111111111111111111111111111</code> </p>

<p>Notice Suffix <strong><code>U</code></strong> for unsigned.  </p></li>
<li><p><strong>Second printf</strong>:<br>
Because <code>i</code> is  <code>-1</code>, So in second expression <code>-i - 1</code> ==  <code>- (-1) - 1</code> == <code>1 - 1</code> == <code>0</code> so output is zero : <code>0</code>.</p></li>
</ol>
",11
17796138,17796041,3,"<p>Your compiler implements >> as arithmetic shift. Therefore, the MSB keeps it value of 1 and the shift does nothing.</p>

<p>That is, ~0 >> 1 is still ~0 because the shift sign-extends.</p>

<p>See here: <a href=""https://stackoverflow.com/a/7632/1974021"">https://stackoverflow.com/a/7632/1974021</a></p>
",0
17796168,17796041,1,"<p>When you perform the bit shift on <code>i</code>, the compiler sees that <code>i</code> is a signed quantity, and performs an arithmetic right shift.  It seems like you want that line of code to perform a logical right shift.</p>

<p>Change the line</p>

<p><code>i &gt;&gt;= 1;</code></p>

<p>to</p>

<p><code>i = ((unsigned int)i) &gt;&gt; 1;</code></p>

<p>Then it works!</p>

<pre><code>Output:
Upper limit: 2147483647
Lower limit: -2147483648
</code></pre>
",0
17796207,17796041,3,"<p>You may be interested in constant in <a href=""http://www.cplusplus.com/reference/climits/"" rel=""nofollow"">limits.h</a> and <a href=""http://www.cplusplus.com/reference/cfloat/"" rel=""nofollow"">float.h</a> header files</p>

<p>From <code>limits.h</code>:</p>

<pre><code>+------------+------------------------------------------------------------------+--------------------------------+
| CHAR_BIT   | Number of bits in a char object (byte)                           | 8 or greater                   |
| SCHAR_MIN  | Minimum value for an object of type signed char                  | -127 (-2^7+1) or less          |
| SCHAR_MAX  | Maximum value for an object of type signed char                  | 127 (2^7-1) or greater         |
| UCHAR_MAX  | Maximum value for an object of type unsigned char                | 255 (2^8-1) or greater         |
| CHAR_MIN   | Minimum value for an object of type char                         | either SCHAR_MIN or 0          |
| CHAR_MAX   | Maximum value for an object of type char                         | either SCHAR_MAX or UCHAR_MAX  |
| MB_LEN_MAX | Maximum number of bytes in a multibyte character, for any locale | 1 or greater                   |
| SHRT_MIN   | Minimum value for an object of type short int                    | -32767 (-2^15+1) or less       |
| SHRT_MAX   | Maximum value for an object of type short int                    | 32767 (2^15-1) or greater      |
| USHRT_MAX  | Maximum value for an object of type unsigned short int           | 65535 (2^16-1) or greater      |
| INT_MIN    | Minimum value for an object of type int                          | -32767 (-2^15+1) or less       |
| INT_MAX    | Maximum value for an object of type int                          | 32767 (2^15-1) or greater      |
| UINT_MAX   | Maximum value for an object of type unsigned int                 | 65535 (2^16-1) or greater      |
| LONG_MIN   | Minimum value for an object of type long int                     | -2147483647 (-2^31+1) or less  |
| LONG_MAX   | Maximum value for an object of type long int                     | 2147483647 (2^31-1) or greater |
| ULONG_MAX  | Maximum value for an object of type unsigned long int            | 4294967295 (2^32-1) or greater |
+------------+------------------------------------------------------------------+--------------------------------+
</code></pre>
",1
11586019,11585953,1,"<p>You only allocate memory for two <code>(int*)</code> but you try to reference <code>choixGEN[0],choixGEN[1],choixGEN[2]</code> which is 3</p>
",0
11586022,11585953,4,"<p>On this line:</p>

<pre><code>    choixGEN=(int**) malloc (sizeof(int*)*2);
</code></pre>

<p>you are only allocating space for 2 <code>int*</code>s, but you access the 3rd element in the <code>for</code> loop.</p>
",0
11550215,11550154,1,"<p>Unlike <code>bsearch</code>, the third argument to <code>lfind</code> is a pointer.</p>

<pre><code> size_t nmemb = cv-&gt;logicalLength;
 found = lfind(key, (char *)(cv-&gt;elems) + (startIndex * cv-&gt;elemSize),
               &amp;nmemb, cv-&gt;elemSize, cmpfn);
</code></pre>
",2
14217360,14217332,1,"<p>If you're trying to use a bare type named <code>node</code>,  that's not right. No such type exists. You need to use either:</p>

<pre><code>struct node my_node;
</code></pre>

<p>or using the <code>typedef</code>:</p>

<pre><code>MyStructure my_node;
</code></pre>
",2
14217365,14217332,0,"<p>You need to add a semi-colon after the last } of the struct.</p>
",0
14217370,14217332,3,"

<pre><code>typedef struct node {
   int x;
   int y;
} MyStructure;
</code></pre>

<p>Same as:</p>

<pre><code>struct node {
   int x;
   int y;
};

typedef struct node MyStructure;
</code></pre>

<p>Example for a stack implementation</p>

<pre><code>//definitions
//C99 has #include &lt;stdbool.h&gt; for this
typedef short boolean;
#define true  1
#define false 0

//You may #define YOUR_APIENTRY APIENTRY (from a system header)
#define YOUR_APIENTRY
#define YOUR_APIENTRYP YOUR_APIENTRY*

//predeclarations
struct _Stack;
typedef struct _Stack Stack;

struct _StackImpl;
typedef struct _StackImpl StackImpl;

struct _Element;
typedef struct _Element Element;

//stack implementation function type definitions
typedef void    (YOUR_APIENTRYP pfnPush)     (Stack*, Element);
typedef Element (YOUR_APIENTRYP pfnPop)      (Stack*);
typedef Element (YOUR_APIENTRYP pfnPeek)     (Stack*);
typedef boolean (YOUR_APIENTRYP pfnIsEmpty)  (Stack*);
typedef boolean (YOUR_APIENTRYP pfnIsFull)   (Stack*);

//funct ptr table
struct _StackImpl{
    pfnPush     push;
    pfnPop      pop;
    pfnPeek     peek;
    pfnIsEmpty  isEmpty;
    pfnIsFull   isFull;
};

//stack
typedef struct _Stack{
    Element* elems; //any appropriate container
    size_t elemCount;
    //if you want to replace the implementation using
    //different func tables (polymorphic)
    //StackImpl* funcPtrs; 
} Stack;

//stack element
struct _Element{
    int value;
};

//default implementation /replace NULL's with actual function pointers)
StackImpl defaultStackImpl = 
{
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};

//function wrappers
void push(Stack* stack, Element elem)
{
    //if you use a polymorphic implementation
    //stack-&gt;funcPtrs-&gt;push(stack,elem);
    defaultStackImpl.push(stack,elem);
}
</code></pre>
",12
10137564,10137508,6,"<p>Very first c compiler was written in assembly language. Assembly language is written in binary language. And binary language is hardware language, it is directly executed by hardware.</p>

<p>I quote <a href=""https://stackoverflow.com/a/1653658/517491"">David Rabinowitz</a>:</p>

<blockquote>
  <p>Please read about <a href=""http://en.wikipedia.org/wiki/Bootstrapping_%28compilers%29"" rel=""nofollow noreferrer"">compiler bootstrapping</a> and the <a href=""http://en.wikipedia.org/wiki/History_of_compiler_writing"" rel=""nofollow noreferrer"">history of
  compiler writing</a></p>
  
  <p>The idea is to write a very simple compiler directly in machine code,
  use it to write a more sophisticated compiler, use the second one to
  build a third one and so on until you can have a full featured
  compiler.</p>
</blockquote>

<p>See the complete thread <a href=""https://stackoverflow.com/questions/1653649/how-was-the-first-compiler-written"">here</a>.</p>
",6
11887482,11885811,2,"<p>You'd be better to allocate the memory you need dynamically. You can have a struct that represents a single Lagrange polynomial (of any order), and then have an array of these, one for each order.</p>

<p>You could also store the order of the polynomial as a member of the struct if you wish. You should be able to factor out code that deals with these into functions that take a LagrangePolynomial*, determine the order, and do whatever computation is required.</p>

<p>The key benefit of all of this is that you don't need to have special code for each order, you can use the same code (and the same struct) for any size of polynomial.</p>

<p>Example below:</p>

<pre><code>struct LagrangePolynomial {
    float *x;
    float *y;
    float *z;
};
</code></pre>

<p>For p=2:</p>

<pre><code>LagrangePolynomial p;
p.x = malloc(sizeof(float)*2);
p.y = malloc(sizeof(float)*2);
p.z = malloc(sizeof(float)*2);
for (size_t i=0; i&lt;2; i++) {
    p.x[i] = ...;
    p.y[i] = ...;
    p.z[i] = ...;
}
</code></pre>

<p>When you've finished with the structure you can free all the memory you've allocated.</p>

<pre><code>free(p.x);
free(p.y);
free(p.z);
</code></pre>

<p>As mentioned before you can have an array of these.</p>

<pre><code>LagrangePolynomial ps[4];
for (size_t i=0; i&lt;4; i++) {
    p[i].x = malloc(sizeof(float)*2);
    p[i].y = malloc(sizeof(float)*2);
    p[i].z = malloc(sizeof(float)*2);
    for (size_t j=0; j&lt;2; j++) {
        p[i].x[j] = ...;
        p[i].y[j] = ...;
        p[i].z[j] = ...;
    }
}
</code></pre>
",2
10166853,10166771,2,"<p>Use <a href=""http://www.cplusplus.com/reference/clibrary/cstring/strstr/"" rel=""nofollow""><code>strstr()</code></a> to locate the <code>""XXXX""</code>:</p>

<pre><code>char string1[] = ""DDXXXX"";
char* xxxx_ptr = strstr(string1, ""XXXX"");
if (xxxx_ptr)
{
    /* Do something. */
}
</code></pre>
",0
10166828,10166771,1,"<p>If you know it is always at the end and of a fixed length, you can calculate its starting position by calculating the length of the string (<code>strlen()</code>) and subtracting the fixed length.</p>

<p>This assumes the substring is always part of the strings you examine</p>
",2
11557634,11557576,0,"<p>may be <code>tmp!=NULL</code> never happens ... ? </p>
",0
11557697,11557576,0,"<p>this could loop forever <code>for(tmp=arr[i];tmp!=NULL;tmp=tmp-&gt;next)</code> if arr[i] it's inside a cycle: keep a vector of visited to check and break on cycles, something like:</p>

<pre><code>node *visited[MAX];
int nVis = 0;
bool cycle = false;
for(tmp=arr[i];tmp!=NULL &amp;&amp; !cycle;tmp=tmp-&gt;next) {
  for (int j = 0; j &lt; nVis; ++j)
   if (visited[j] == tmp) {
     cycle = true;
     break;
   }
 visited[nVis++] = tmp;
 ...
}
</code></pre>
",0
11557727,11557576,0,"<pre><code>n-&gt;next=arr[startVertex];
arr[startVertex]-&gt;next=n;
</code></pre>

<p>this code make tmp!=NULL never happens</p>

<p>maybe like this:</p>

<pre><code>n-&gt;next=arr[startVertex]-&gt;next;
arr[startVertex]-&gt;next=n;
</code></pre>
",0
11889876,11889820,1,"<p><del><code>strcat</code> doesn't allocate new memory for you, you need to ensure that there's enough space <em>before</em> you call it. It looks like you ran out of room in that call to <code>strcat</code>, hence *WHAM*.</del></p>

<p>In the updated example, use some temporary variables to store the result of <code>strpbrk(posfind, ""&lt;"")</code> and the new malloc'ed memory, like so:</p>

<pre><code>char* temp = strpbrk(posfind, ""&lt;"");
char* newstring = NULL;
if (temp != NULL) {
    // You had a typo with the size, and also don't forget to add a spot for the
    // terminating null character
    newstring = malloc((strlen(temp) + strlen(posfind) + 1) * sizeof(char));
    newstring = strcpy(newstring, temp);
    newstring = strcat(newstring, posfind);
    posfind = newstring;
}
</code></pre>

<p>Of course, you should also be checking all of the return values and freeing up any allocated memory that we no longer use.</p>
",11
11889970,11889820,0,"<p><code>strpbrk(posfind,""&lt;"")</code> returns a null pointer, which you are passing to <code>strcat</code>.</p>
",0
15559750,15559688,2,"<p>First you make a pointer that points to a random address</p>

<pre><code>void *ptr;
</code></pre>

<p>Then you try to store a value of 12 to that random address causing undefined behavior because you haven't allocated any memory for <code>ptr</code></p>
",0
15559780,15559688,3,"<pre><code>void *ptr;
</code></pre>

<p>Where does <code>ptr</code> point to? My bet is, to the coffee shop down the street. Or maybe even some sort of wormhole!</p>

<pre><code>*(int*) ptr = 12;
</code></pre>

<p>So you cast a void pointer that points to who-knows-what to a pointer to int, and you then dereference that to assign it the integer 12. This will overwrite some random location in memory. If you're lucky, the program won't crash. If you're unlucky, your computer will explode.</p>

<p>So, to summarize and rephrase your question, you are asking us: ""<em>Uhm, I am dereferencing a pointer I haven't initialized and points to who-knows-where. Why does my program crash?</em>"" Do I have that right?</p>
",0
12790591,12790564,0,"<p>You're assigning a string to a single element of a string (a character).  Instead, you need to assign a character, using single quotes.  For instance, to put a space in front and at the end of the word, which is what you seem to be trying to do:</p>

<pre><code>eItem[k-1]=' ';
eItem[0]=' ';
</code></pre>

<p>But you can actually truncate the string at the beginning by making a separate character pointer point to the second character in the string, and truncate at the end by adding a NULL byte:</p>

<pre><code>eItem[k-1]='\0';
char * truncated_eItem = eItem + 1;
</code></pre>

<p>Remember, the <code>+1</code> means it points to an address <code>1 *  sizeof(char)</code> downstream in memory.</p>
",0
12790612,12790564,0,"<pre><code>eItem = eItem+1;
eItem[strlen(eItem)-1] = 0;
</code></pre>
",4
12791771,12790564,0,"<p>Marian,</p>

<p>Please go through the following implementation of the purpose. It should reasonably work.</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;

int main()
{
  const char *src_strings[]={""WADMIN"", ""WADMIN"", ""WADMIN"", ""WADMIN"", ""PALA"", ""PALA"", ""PALA"", ""PALA""}; //source array of char pointers
  char *dest_strings[8]; //Destination array of character pointers
  int string_count,length,cindex;

  printf(""Modified Strings\n"");
  printf(""================\n"");

  //Traverse through the strings in the source array
  for(string_count=0;string_count&lt;8; string_count++) 
  {
    //Compute the lenght and dynamically allocate the
    //required bytes for the destination array
    length=strlen(src_strings[string_count]);
    dest_strings[string_count]= (char*)malloc(sizeof(length-1));

    //Copy characters to destination array except first and last
    for(cindex=1; cindex&lt;length-1; cindex++)
    {
       *(dest_strings[string_count]+cindex-1)=*(src_strings[string_count]+cindex);
    }

    //Append null character
    *(dest_strings[string_count]+cindex)='\0';
    printf(""%s\n"",dest_strings[string_count]);

    //Free memory as it is not needed
    free(dest_strings[string_count]);

  }
  return 0;
}
</code></pre>

<h3>Sample Output</h3>

<pre><code>Modified Strings
================
ADMI
ADMI
ADMI
ADMI
AL
AL
AL
AL
</code></pre>
",0
11501284,11501016,1,"<p>In order for you to change the data that a pointer is pointing to you need to supply one more level of indirection</p>

<p>e.g. you write</p>

<pre><code>insertnode(root,data);
</code></pre>

<p>but root is set to NULL at start and cannot be changed inside insertnode the way you supply it to the function.</p>

<p>instead declare insertnode as</p>

<pre><code>insertnode(struct treenode **p,int d)
</code></pre>

<p>and call insertnode with</p>

<pre><code>insertnode(&amp;root, data);
</code></pre>
",0
11501065,11501016,6,"<p>The following are just compilation errors, so fix these and your program will compile.</p>

<p><strong>Problem #1</strong>:<br/>
You define your struct as:</p>

<pre><code>struct treenode
{
    /* Blah blah... */
} *root;  /* Mistake: should be root, not *root */
</code></pre>

<p>Instead, name it <code>root</code>, not <code>*root</code>.</p>

<p><br/>
<strong>Problem #2</strong>:<br/>
You're calling <code>insertnode()</code> wrong. Instead of this:</p>

<pre><code>insertnode((&amp;(p-&gt;lchild)),d);  /* Mistake: taking the address of the pointer */
</code></pre>

<p>You should call it like this:</p>

<pre><code>insertnode(p-&gt;lchild,d);
</code></pre>

<p><br/>
<strong>Problem #3</strong>:<br/>
You're defining <code>root</code> in <code>main()</code> wrong:</p>

<pre><code>root = NULL;  /* Mistake: root is implicitly declared as int */
</code></pre>

<p>What you should do instead is:</p>

<pre><code>struct treenode* root = NULL;
</code></pre>

<p><br/>
<strong>Problem #4</strong>:<br/></p>

<p>You have a typo in the declaration of <code>inorder()</code>:</p>

<pre><code>void inorder(struct treeode *p)  /* Typo: should be treenode and not treeode */
</code></pre>

<p>It should be:</p>

<pre><code>void inorder(struct treenode *p)
</code></pre>

<hr>

<p>The next set of problems is logical errors in the program:</p>

<p><strong>Problem #5</strong>:<br/>
in <code>insertnode()</code> you're always inserting a new value <code>d</code> into the left node. You should change either one of the recursive <code>insertnode(p-&gt;lchild, d);</code> calls to:</p>

<pre><code>insertnode(p-&gt;rchild, d);
</code></pre>

<p>Depending on how you want to organize your tree.</p>

<p><br/>
<strong>Problem #6</strong>:<br/>
Just like AndersK pointed out, the passed pointer <code>root</code> never changes after it is passed to <code>insertnode()</code>, so that's a major bug.</p>

<p>In your case double indirection pointers are necessary when you want to change the passed pointer itself (i.e. point it to another address), and not change the pointee itself.</p>

<p>You want to change <code>root</code> inside <code>insertnode()</code>, so add another level of indirection and pass the address of <code>root</code>, <em>i.e.</em> <code>&amp;root</code>, so that root can also be changed within the function.</p>

<p>Correspondingly, the declaration of <code>insertnode()</code> should be:</p>

<pre><code>insertnode(struct treenode** p, int d)
</code></pre>
",2
13743953,13743538,1,"<pre><code>typedef struct _Test{
   char* c;
}Test;


void method(void* test){
    Test *t;
    t = (Test*)test;
    t-&gt;c = ""omg"";
    printf(t-&gt;c); //WORKS
}

int main(){
Test t;
method(&amp;t);
printf(t.c);

return 0;}
</code></pre>
",0
13743576,13743538,11,"<p>You are changing the local object <code>t</code> inside <code>method()</code>, after copying <code>main()</code>'s object <code>t</code> into it. This doesn't change anything in <code>main()</code>'s object since you never copy in the other direction.</p>

<p>You should just access through the pointer and directly change the caller's object:</p>

<pre><code>((Test *) test)-&gt;c = ""omg"";
</code></pre>

<p>or, you can make it a bit clearer by using a local pointer of the proper type, which might be what you were trying to do:</p>

<pre><code>void method(void* test) {
    Test *t = test;
    t-&gt;c = ""omg"";
}
</code></pre>

<p>note that no cast is needed here, since <code>void *</code> automatically converts to <code>Test *</code> in C.</p>
",0
13743587,13743538,3,"<p>You are defining a <code>Test</code> object in your method (created on the stack), then you point the given pointer there. After the method returns, the stack-allocated <code>Test</code> is gone.</p>

<p>Rewrite: </p>

<pre><code>void method(void* test){
    Test *t;                     // defines a pointer to a Test object
    t = (Test*)test;             // casts the void pointer to a Test pointer
    t-&gt;c = ""omg"";                // assigns data to attribute
    printf(t-&gt;c); //WORKS
}
</code></pre>

<p>Of course, it can all be put in one line (excluding the <code>printf()</code>), removing the need for a stack-allocated <code>Test</code> pointer:</p>

<pre><code> void method(void* test){
        ((Test *)test)-&gt;c = ""omg"";
 }
</code></pre>
",0
13743623,13743538,1,"<p><code>t</code> in <code>method()</code>'s scope shadows <code>t</code> in <code>main()</code>'s, which never gets touched, thus containing undeterminable data when you call <code>printf()</code> with it.</p>
",0
15520863,15520752,1,"<p>The line </p>

<pre><code>ptr-&gt;arr[0] = ""calculator"";
</code></pre>

<p>is wrong, you cannot assign a string to a single character, that's what <code>ptr-&gt;arr[0]</code> represents.</p>

<pre><code>ptr-&gt;arr = ""calculator"";
</code></pre>

<p>would be wrong too, since you cannot assing a string to a char array in that way, you have to use <a href=""http://www.cplusplus.com/reference/cstring/strcpy/"" rel=""nofollow"">strcpy()</a>.</p>

<p><br><br></p>

<pre><code>printf(""Ptr zero contains a string %s\n"",ptr-&gt;arr[0]);
</code></pre>

<p>should also be</p>

<pre><code>printf(""Ptr zero contains a string %s\n"",ptr-&gt;arr);
</code></pre>

<p>since you are printing an array not a single char</p>
",0
15520918,15520752,1,"<p>Three problems in your code:</p>

<p>You must not cast return value from <code>malloc()</code> - </p>

<p>you are trying to assign a constant string to an indexed array - so it should be </p>

<p><code>strcpy(ptr-&gt;arr, ""calculator"");</code> and  <code>strcpy(var1-&gt;arr,""A"");</code></p>

<p>Also - there is a massive memory leak in your code. No call to <code>free()</code> anywhere.</p>
",0
15520797,15520752,4,"<p>The following is wrong:</p>

<pre><code>ptr-&gt;arr[0] = ""calculator"";
</code></pre>

<p>(BTW, your compiler should have warned you about this.)</p>

<p>You should use <code>strcpy()</code> instead.</p>

<p>The same goes for the other place where you're using a similar construct.</p>

<p>Finally, the <code>malloc()</code> in <code>foo_fun1()</code> is unnecessary. Not only you're overwriting the value of the function argument (why?), you are also leaking memory.</p>
",2
11871914,11871435,0,"<p>Well, you didn't describe your problem, but it looks like this part may cause issues.</p>

<pre><code>int getData(...) {
    ...
    fscanf(fpIn, ""%d %d %d %d %d %d %d"", hw1[i], hw2[i], hw3[i], hw4[i], hw5[i], hw6[i], hw7[i]);
    fscanf(fpIn, ""%d %d"", mid1[i], mid2[i]);
    fscanf(fpIn, ""%d %d"", final[i], extra[i]);
    ...
}
</code></pre>

<p>You are passing <code>int</code>s to <code>fscanf</code> which expects <code>int *</code>s. You did the right thing earlier with</p>

<pre><code>fscanf(fpIn, ""%d"", &amp;student[i]);
fscanf(fpIn, ""%c"", &amp;pass[i]);
</code></pre>
",0
11871734,11871435,2,"<p>I suggest you create an struct to encapsulate all the information of a student instead of having different arrays for each data you are storing.</p>

<pre><code>struct{ 
   int studentId;
   char pass;
   int hw[7]
   int mid[2];
   int final;
   int extra;
   float total;
} student;

 student mystudents[STDENTS];
</code></pre>

<p>Whatever your problem is, it will be easier to detect with more compact data structures that will ease also if must make any changes.</p>
",2
12834571,12834028,1,"<p>Here's a working example :</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

int main(int argc, char **argv) {
    struct tm t;
    time_t seconds;
    const char *expire = ""Sat, 10 Nov 2012 07:05:25 GMT"";
    strptime(expire, ""%a, %d %B %Y %H:%M:%S"", &amp;t);
    seconds = mktime(&amp;t);
    printf(""%lu\n"", seconds);
}
</code></pre>

<p>Note that your times must be in GMT time since strptime() ignores the time zone (at least on Linux). You may also need to set your locale to the same locale used for your input times.</p>
",2
12834182,12834028,0,"<p>If your implementation has it, you could use the <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/strptime.html"" rel=""nofollow""><code>strptime</code></a> function to convert that string to a <code>struct tm</code>, then <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/mktime.html"" rel=""nofollow""><code>mktime</code></a> to convert <em>that</em> to a <code>time_t</code> for easy comparison.</p>
",0
13704196,13704134,0,"<p>The problem is that you are using char type in declaration and using <code>%s</code> in scanf</p>

<p>These have to be changed to hold strings</p>

<pre><code> char firstName;
 char lastName;
 char middleName;
</code></pre>

<p>should be changed to </p>

<pre><code>char firstName[MAX]; //where MAX is any convenient high value.
char lastName[MAX];
char middleName[MAX];
</code></pre>
",0
13704158,13704134,1,"<p>There is your problem:</p>

<pre><code>    scanf(""%s%s%s%d%f"", &amp;firstName, &amp;lastName, &amp;middleName, &amp;age, &amp;height);
</code></pre>

<p>You scan in strings, but your variables are only chars:</p>

<pre><code>   char firstName;
   char lastName;
   char middleName;
</code></pre>
",0
13704176,13704134,1,"<p>I think you may want to provide a <em>buffer</em> for your data:</p>

<pre><code>char firstName[SOME_BIG_ENOUGH_SIZE];
</code></pre>

<p>rather than a single character:</p>

<pre><code>char firstName;
</code></pre>
",0
14864306,14864169,0,"<p>Stupid mistake..</p>

<p>I exceeded buffer's size:</p>

<pre><code>alignedSize [= buffer size] = 36
bytes allocated for buffer:   0-35
</code></pre>

<p>I'm changing (buffer+36) = <strong>buffer[36]</strong> which is beyond buffer's memory limit.</p>

<p>Fixed code:</p>

<pre><code>SetVal(_buffer + alignedSize - WORD_SIZE, END_VAL); 
</code></pre>
",0
14864799,14864169,3,"<p>The <code>SetVal()</code> function writes to 4 bytes to the location you have indicated as the end. That is:</p>

<pre><code>BufferInit(buffer, 37);

... Leads to ... 

SetVal(_buffer + alignedSize, END_VAL);

... which does ...

*(int*)_block = _size;
</code></pre>

<p><code>alignedSize</code> is 36 (37 &amp; ~3 = 36) [~3 = 0xFFFFFFFC]. 4 bytes at offset 36 writes to bytes 36, 37, 38 and 39. Since your buffer originally is 36 bytes long, it's outside of your buffer. Either change your buffer to be 40 bytes long, or change your 37 to be 33 [or a lower number]. </p>
",1
11850489,11850478,8,"<blockquote>
<pre><code>int a;
double b=sqrt(a);
scanf(""%i"", &amp;a);
</code></pre>
</blockquote>

<p>You're using the variable (<code>a</code>) before initializing it. The <code>scanf</code> should go before the <code>sqrt</code>.</p>
",2
11850602,11850478,3,"<p>To add something to the two good answers already written: you need to keep in mind that the primary sequence of instructions in C is linear - the instrction written first is executed first. If we were talking about math, it would be fine to say 'let b be the <strong>function</strong> sqrt(a), then find out what b(a) is'. You can actually do this in C by defining your own functions, but that's something else. NB: the computer doesn't do what you think you told it to do. It does what you told it to do.</p>
",0
11513459,11513413,5,"<blockquote>
  <p>Is there a way to find out if the members of struct were assigned values or not ?</p>
</blockquote>

<p>No. You would need to keep track of that yourself by a separate set of variables, or by initializing the values of the struct to values they normally cannot have(e.g. -1 , but in such a case, every piece of code would need to honor the convention of not using such special values doring normal usage)</p>
",0
13478415,13478331,1,"<p>This is incorrect</p>

<p><code>if(sqrt(pow(i,2)+ pow(j,2))== radius)</code></p>

<p>It's very rare that these two values will be <strong>exactly</strong> equal. Instead you should make a test to see if the two numbers are roughly equal. Like this for instance</p>

<p><code>if (fabs(sqrt(pow(i,2)+ pow(j,2)) - radius) &lt;= 0.001)</code></p>

<p>This tests if <code>sqrt(pow(i,2)+ pow(j,2))</code> and <code>radius</code> are within 0.001 of each other. You might need to change the value of 0.001 to something else. It depends on your co-ordinate system.</p>
",2
13478417,13478331,0,"<blockquote>
  <p>what is wrong in this code?</p>
</blockquote>

<p>Here you are:</p>

<pre><code>if (sqrt(pow(i, 2) + pow(j, 2)) == radius)
</code></pre>

<p>You should not compare floating-point numbers using <code>==</code>, it won't work as expected. You should check instead if it's <strong>close to</strong> the radius:</p>

<pre><code>if (sqrt(pow(i, 2) + pow(j, 2)) &gt;= radius * 0.95)
</code></pre>

<p>for example.</p>
",1
13478426,13478331,1,"<p>You should use <a href=""http://en.wikipedia.org/wiki/Midpoint_circle_algorithm"" rel=""nofollow"">Midpoint circle algorithm</a>.</p>

<p>Nice thing about it that it uses only integer arithmetic - so it is both fast and exact.</p>
",0
11514142,11514127,7,"<p>C doesn't have a boolean type (well, C99 and newer do, but there's nothing in your program that uses it).</p>

<p><code>!</code> is just a unary operator that turns <code>0</code> into <code>1</code> and anything else into <code>0</code>.  So in your case, since <code>i</code> is <code>2</code>, <code>!i</code> is <code>0</code>, and <code>!!i</code> is <code>1</code>.  <code>j</code> is <code>1</code>, so <code>!j</code> is <code>0</code>.  That leaves <code>!!i + !j</code> to be be <code>1 + 0</code>, and you're printing <code>1</code>.  Try out this example program to see it in action:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    int i = 2, j = 1;

    printf(""i = %d, j = %d\n"", i, j);
    printf(""!i = %d, !!i = %d\n"", !i, !!i);
    printf(""!j = %d\n"", !j);
    printf(""!!i + !j = %d + %d = %d\n"", !!i, !j, !!i + !j);
    return 0;
}
</code></pre>
",0
11514151,11514127,2,"<p><code>!x</code> is 0 if <code>x</code> is true (i.e. not equal to 0) or 1 if <code>x</code> is false (i.e. equal to 0). Since your example <code>i</code> is 2, <code>!i</code> will be 0 and thus <code>!!i</code> will be 1. Likewise <code>!j</code> will be 0. So the result of the expression will be <code>1 + 0 = 1</code>.</p>

<p>Note that there are no circumstances under which <code>0 + 0</code> (i.e. false + false) would equal 1.</p>
",0
11514167,11514127,0,"<p>Here's what the specification states about the <code>!</code> operator (C99 ¡ì6.5.3.3/5).  The terse last sentence is all that is really required to understand its behavior:</p>

<blockquote>
  <p>The result of the logical negation operator <code>!</code>is <code>0</code> if the value of its operand compares
  unequal to <code>0</code>, <code>1</code> if the value of its operand compares equal to <code>0</code>.</p>
  
  <p>The result has type <code>int</code>.</p>
  
  <p>The expression <code>!E</code> is equivalent to <code>(0==E)</code>.</p>
</blockquote>

<p>We can use the transformation from the third sentence to evaluate your expression, <code>!!i + !j</code>.  The transformation becomes:</p>

<pre><code>(0 == (0 == i)) + (0 == j)
</code></pre>

<p>and we can evaluate it as follows:</p>

<pre><code>(0 == (0 == 2)) + (0 == 1) // substitute the variable values
(0 == (0     )) + (0 == 1) // 0 == 2 is false, so it becomes 0
(0 == (0     )) + (0     ) // 0 == 1 is false, so it becomes 0
(1            ) + (0)      // 0 == 0 is true, so it becomes 1
 1                         // 1 + 0 is 1
</code></pre>
",0
11888107,11888082,3,"<p>First, make sure that the string you are working with is in modifiable memory<sup>1</sup>:</p>

<pre><code>char String_Buffer[] = ""Hi my name is &lt;&amp;1&gt; and i have &lt;&amp;2&gt; years old.""
</code></pre>

<p>then, cut your string at the position where you found <code>&lt;</code>:</p>

<pre><code>char* pos = strpbrk(String_buffer, ""&lt;"");
if(pos!=NULL)
{
    /* changing the '&lt;' you found to the null character you are actually
     * cutting the string in that place */
    *pos=0;
}
</code></pre>

<p>Printing <code>String_Buffer</code> will now output <code>Hi my name is</code>. If you don't want the final space, just move <code>pos</code> backward of one element (being careful not to go before the beginning of <code>String_Buffer</code>).</p>

<hr />

<ol>
<li>In your code you declared a <code>char</code> pointer and made it point to a string literal, which is non-modifiable (that's why you normally write <strong><em><code>const</code></em></strong> <code>char * str = ""asdasads"";</code>; in this case, instead, we are initializing a local <code>char</code> array, which we can change as much as we want.</li>
</ol>
",4
11888166,11888082,2,"<p>If you track <code>start</code> separately, you can ""cut out"" a section of the buffer:</p>

<pre><code>char *start = String_Buffer;
char *end = strpbrk(String_Buffer, ""&lt;"");

if (end) {
    /* found it, allocate enough space for it and NUL */
    char *match = malloc(end - start + 1);

    /* copy and NUL terminate */
    strncpy(match, start, end - start);
    match[end - start] = '\0';

    printf(""Previous tokens: %s\n"", match);
    free(match);
} else {
    /* no match */
}
</code></pre>

<p>To walk the buffer printing each token, you'll simply hoist this into a loop:</p>

<pre><code>char *start = String_Buffer, *end, *match;

while (start) {
    end = strpbrk(start, ""&lt;"");
    if (!end) {
        printf(""Last tokens: %s\n"", start);
        break;
    } else if (end - start) {
        match = malloc(end - start + 1);

        /* copy and NUL terminate */
        strncpy(match, start, end - start);
        match[end - start] = '\0';

        printf(""Tokens: %s\n"", match);
        free(match);

        end++; /* walk past &lt; */
    }

    /* Walk to &gt; */
    start = strpbrk(end, ""&gt;"");
    if (start) {
        match = malloc(start - end + 1); /* start &gt; end */
        strncpy(match, end, start - end);
        match[start - end] = '\0';

        printf(""Bracketed expression: %s\n"", match);
        free(match);
        start++; /* walk past &gt; */
    }
}
</code></pre>
",0
11514230,11514201,4,"<p>This is known as a <a href=""http://gcc.gnu.org/onlinedocs/cpp/Variadic-Macros.html"" rel=""nofollow"">Variadic macro</a>.</p>
",0
11517175,11514201,0,"<p>Don't use a macro to do that, use a <a href=""http://en.cppreference.com/w/cpp/utility/variadic/va_arg"" rel=""nofollow"">variadic <em>function</em></a>!</p>

<pre><code>void print_string( bool should_print, ... )
{
    if( should_print )
    {
        va_list argp;
        va_start( argp, should_print);
        char *string = va_arg(argp, char *);
        if( string) printf(""%s"", string );
        va_end( argp );

    }
}
</code></pre>

<p>But be very careful when using these sorts of things, because va_arg doesn't check if you really have a 2nd argument.</p>

<p>Also, to use a macro that accepts one or 2 arguments, use the GCC trick (at the very bottom of <a href=""http://gcc.gnu.org/onlinedocs/cpp/Variadic-Macros.html"" rel=""nofollow"">this page</a>):</p>

<pre><code>#define PRINT_STRING( should , args... ) print_string( should , ##args )
</code></pre>

<p>(note the spaces between the commas)</p>
",2
11517413,11514201,2,"<p>If your compiler supports <code>__VA_ARGS__</code>, you can do it like this:</p>

<pre><code>#include &lt;stdio.h&gt;

#define NUM_ARGS__(X, \
                      N64,N63,N62,N61,N60, \
  N59,N58,N57,N56,N55,N54,N53,N52,N51,N50, \
  N49,N48,N47,N46,N45,N44,N43,N42,N41,N40, \
  N39,N38,N37,N36,N35,N34,N33,N32,N31,N30, \
  N29,N28,N27,N26,N25,N24,N23,N22,N21,N20, \
  N19,N18,N17,N16,N15,N14,N13,N12,N11,N10, \
  N09,N08,N07,N06,N05,N04,N03,N02,N01,  N, ...) N

#define NUM_ARGS(...) \
  NUM_ARGS__(0, __VA_ARGS__, \
                 64,63,62,61,60, \
  59,58,57,56,55,54,53,52,51,50, \
  49,48,47,46,45,44,43,42,41,40, \
  39,38,37,36,35,34,33,32,31,30, \
  29,28,27,26,25,24,23,22,21,20, \
  19,18,17,16,15,14,13,12,11,10, \
   9, 8, 7, 6, 5, 4, 3, 2, 1, 0)

#define PRINT_STRING_1(var) \
  { if (!(var)) {} }

#define PRINT_STRING_2(var, ...) \
  { if (!(var)) test(__VA_ARGS__); }

#define PRINT_STRINGN__(N, ...) \
  PRINT_STRING_##N(__VA_ARGS__)

#define PRINT_STRINGN(N, ...) \
  PRINT_STRINGN__(N, __VA_ARGS__)

#define PRINT_STRING(...) \
  PRINT_STRINGN(NUM_ARGS(__VA_ARGS__), __VA_ARGS__) 

void test(char* var2) 
{ 
  printf(""%s\n"", var2); 
} 

int main(void)
{
  PRINT_STRING(1);
  PRINT_STRING(0, ""Hello, World!"");
  PRINT_STRING(1, ""You can't see me!"");
  return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>Hello, World!
</code></pre>
",2
11517488,11514201,2,"<p>To do something like that you'd have to implement a series of macros, something like this</p>

<pre><code>#include &lt;stdbool.h&gt;
#define PRINT_STRING0(X, Y) do { if (X &amp;&amp; Y) test(Y); } while(false) 
#define PRINT_STRING1(X, Y, ...) PRINT_STRING0(X, Y)
#define PRINT_STRING(...) PRINT_STRING1(__VA_ARGS__, 0, 0)
</code></pre>

<p>The last of them (user interface) adds a second or third argument of <code>0</code>. <code>PRINT_STRING1</code> then ignores all arguments that are more than <code>2</code>. And <code>PRINT_STRING0</code> then does the work.</p>

<p>Some more remarks:</p>

<ul>
<li>be careful that a macro like you want to program it here can be place syntactically just as any other statement. In the example here the <code>do { } while(false)</code> does that trick</li>
<li>since C99 has Boolean type and constants, these are <code>_Bool</code> or <code>bool</code> and <code>false</code> and <code>true</code></li>
</ul>
",1
16466126,16466051,3,"<p><code>%[^:]</code> will accept line endings.  If you want to skip putting leading whitespace into <code>word</code> try:</p>

<pre><code> "" %[^:]:%d""
</code></pre>
",0
16466129,16466051,1,"<p>add space at the beginning of your string format <code>"" %[^:]:%d""</code>. this will avoid the newline problems in the scanf</p>

<pre><code> while(fscanf(file, "" %[^:]:%d"", word, &amp;integer) != EOF)
</code></pre>
",0
16466155,16466051,1,"<p>Because when you use the *scanf() functions to read an integer, the following newline isn't consumed.</p>
",0
16466162,16466051,3,"<p>From <a href=""http://en.cppreference.com/w/c/io/fscanf"" rel=""nofollow""><code>fscanf()</code></a>:</p>

<blockquote>
  <p>All conversion specifiers other than [, c, and n consume and discard all leading whitespace characters before attempting to parse the input.</p>
</blockquote>

<p>and the <code>\n</code> will remain the input stream after <code>""%d""</code>.</p>

<p>To correct add a leading space to the format speicifer to skip whitespace:</p>

<pre><code>while(fscanf(file, "" %[^:]:%d"", word, &amp;integer) == 2)
{
}
</code></pre>

<p>Changed the <code>!= EOF</code> to <code>== 2</code> to prevent accepting lines of the format <code>""hello:""</code> or <code>""hello""</code>.</p>
",0
13736239,13736193,0,"<p>Probably should set max length and initialize the array multiples[] before trying to set it's elements...</p>

<p>e.g.</p>

<pre><code>int multiples[100] = { 0 };
</code></pre>

<p>You'll also want to stop setting elements when reaches count 100, i.e</p>

<pre><code>for(y = input_value_1;y &lt;= input_value_2 &amp;&amp; count &lt; 100; y++) {  }
</code></pre>
",0
13736246,13736193,0,"<p>There's one thing about your code that bothers me a little bit. </p>

<p>I don't know if the following line allocates your <code>multiples</code> array: (my c syntax is rusty)</p>

<pre><code>int multiples[] = {};
</code></pre>

<p>but, I'm pretty sure that that line doesn't give it an indefinite amount of memory. at the very least.</p>

<p>My intuition says that if you enter a large enough range, you'll get a segmentation fault very fast.</p>
",0
13736257,13736193,2,"<pre><code>int multiples[100]; 
</code></pre>

<p>should fix it. Also, i&lt; count at the display.</p>
",0
13736319,13736193,-1,"<p>The range from input_value_1 to input_value_2 maybe very large.
The multiples of 7 may exceeds your array size.
The better way should use vector for storing </p>

<pre><code>std::vector&lt;int&gt; multiples;
for(y = input_value_1;y &lt;= input_value_2; y++)
    if(y%7 == 0)
        multiples.push_back(y);
for(i=0; i&lt;=multiples.size(); i++)
    printf(""%i\n"", multiples[i]);
</code></pre>

<p>Or print it directly.</p>

<pre><code>    for(y = input_value_1;y &lt;= input_value_2; y++)
    {
        if(y%7 == 0)
            printf(""%d\n"", y);
    }
</code></pre>
",0
13736767,13736193,0,"<p>First, you should at least initialize multiples to certain size or even avoid using it.
Second, you have another bug in your code:</p>

<pre><code>for(i=0; i&lt;=count; i++)
    {
        printf(""%i\n"", multiples[i]);
    }
</code></pre>

<p>should be:</p>

<pre><code>for(i=0; i&lt;count; i++)
    {
        printf(""%i\n"", multiples[i]);
    }
</code></pre>
",0
12867853,12867810,2,"<p>You should look for overflow, print the value after each iteration.</p>

<p>Note that <code>rec(t);</code>  doesn't do anything as it doesn't use the returned value... you want <code>t = rec(t);</code>. </p>

<p><code>int</code> is definitely too short, try <code>long long</code>... if that's still overflowing, you need another data structure.. eg: GMP Library.</p>

<p>Note: using some ""proper"" language for the job might give you some insight to the range you have to support... e.g. with python:</p>

<pre><code>&gt;&gt;&gt; import math
&gt;&gt;&gt; math.factorial(100)
93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000L
</code></pre>
",0
12869883,12867810,4,"<p>Approximate factorial of 100 can be calculated using the <code>double</code> type. You can also use the <a href=""http://en.wikipedia.org/wiki/Stirling%27s_approximation"" rel=""nofollow"">Stirling's formula</a>, stating that</p>

<pre><code>n! ¡Ö sqrt(2*M_PI*n) * pow(n/exp(0),n)
</code></pre>

<p>If you plug in the numbers, you'll get n! ¡Ö 9*10<sup>157</sup>. That means your type needs to be able to hold 158 decimal digits or, equivalently, ~log<sub>2</sub>(9*10<sup>157</sup>) = 525 bits or 66 8-bit bytes.</p>

<p>No fundamental numeric type in C is big enough. The largest you are guaranteed to get is 64 bits (if you use <code>unsigned long long</code>).</p>

<p>So, if you want to calculate n! in C, you either need to construct long arithmetic multiplication by hand or use a special library that can do that for you.</p>

<p>For this relatively simple task you can actually implement long multiplication and use it to get the factorial value by repeated multiplication.</p>

<p>In the following program I've used an in-place multiplication algorithm, which modifies one of the multiplicands in the process and eventually replaces it with the product. The algorithm can be derived directly from the long multiplication known from school.</p>

<p>This program calculates factorials of integers from 1 up to and including 100:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;limits.h&gt;

typedef unsigned char uint8;
typedef unsigned short uint16;
#if UINT_MAX &gt;= 0xFFFFFFFF
typedef unsigned uint32;
#else
typedef unsigned long uint32;
#endif
typedef unsigned uint;

void MulInPlace(uint8* dst/* n bytes */,
                const uint8* src/* n bytes */,
                uint n)
{
  uint c1, c2;

  if (n &gt;= 0xFFFF) abort();

  for (c1 = n - 1; c1 != ~0u; c1--)
  {
    uint16 s = 0;
    uint32 p = 0; // p must be able to store ceil(log2(n))+2*8 bits

    for (c2 = c1; c2 != ~0u; c2--)
    {
      p += dst[c2] * src[c1 - c2];
    }

    dst[c1] = (uint8)(p &amp; 0xFF);

    for (c2 = c1 + 1; c2 &lt; n; c2++)
    {
      p &gt;&gt;= 8;
      s += dst[c2] + (uint8)(p &amp; 0xFF);
      dst[c2] = (uint8)(s &amp; 0xFF);
      s &gt;&gt;= 8;
    }
  }
}

int ByteDivInPlace(uint8* dst/* n bytes */,
                   uint   n,
                   uint8  divisor,
                   uint8* remainder)
{
  uint rem = 0;
  int nonzero = 0;

  while (n)
  {
    rem += dst[n - 1];
    nonzero |= (dst[n - 1] = rem / divisor);
    rem = (rem % divisor) &lt;&lt; 8;
    n--;
  }

  if (remainder != NULL)
    *remainder = (uint8)(rem &gt;&gt; 8);

  return nonzero; // 1 if the quotient is non-zero, 0 otherwise
}

void IncInPlace(uint8* dst/* n bytes */,
                uint n)
{
  uint c = 1;
  while (n-- &amp;&amp; c)
  {
    c += *dst;
    *dst++ = c &amp; 0xFF;
    c &gt;&gt;= 8;
  }
}

void DestroyingDecimalPrint(uint8* dst, uint n)
{
  uint8 r;
  if (ByteDivInPlace(dst, n, 10, &amp;r))
    DestroyingDecimalPrint(dst, n);
  printf(""%d"", r);
}

int main(void)
{
  int i;
  uint8 factorial[66];
  uint8 factor[sizeof(factorial)];
  uint8 tmp[sizeof(factorial)];

  // factor = 1
  memset(factor, 0, sizeof(factor));
  factor[0] = 1;

  // factorial = 1
  memcpy(factorial, factor, sizeof(factorial));

  for (i = 1; i &lt;= 100; i++)
  {
    // factorial *= factor
    MulInPlace(factorial, factor, sizeof(factorial));

    // tmp = factorial
    memcpy(tmp, factorial, sizeof(factorial));

    // print i and tmp
    printf(""%i! = "", i);
    DestroyingDecimalPrint(tmp, sizeof(tmp));
    printf(""\n"");

    // factor += 1
    IncInPlace(factor, sizeof(factor));
  }

  return 0;
}
</code></pre>

<p>Output (<a href=""http://ideone.com/7k1kg"" rel=""nofollow"">ideone</a>):</p>

<pre><code>1! = 1
2! = 2
3! = 6
4! = 24
5! = 120
6! = 720
7! = 5040
8! = 40320
9! = 362880
10! = 3628800
11! = 39916800
12! = 479001600
13! = 6227020800
14! = 87178291200
15! = 1307674368000
16! = 20922789888000
17! = 355687428096000
18! = 6402373705728000
19! = 121645100408832000
20! = 2432902008176640000
21! = 51090942171709440000
22! = 1124000727777607680000
23! = 25852016738884976640000
24! = 620448401733239439360000
25! = 15511210043330985984000000
26! = 403291461126605635584000000
27! = 10888869450418352160768000000
28! = 304888344611713860501504000000
29! = 8841761993739701954543616000000
30! = 265252859812191058636308480000000
31! = 8222838654177922817725562880000000
32! = 263130836933693530167218012160000000
33! = 8683317618811886495518194401280000000
34! = 295232799039604140847618609643520000000
35! = 10333147966386144929666651337523200000000
36! = 371993326789901217467999448150835200000000
37! = 13763753091226345046315979581580902400000000
38! = 523022617466601111760007224100074291200000000
39! = 20397882081197443358640281739902897356800000000
40! = 815915283247897734345611269596115894272000000000
41! = 33452526613163807108170062053440751665152000000000
42! = 1405006117752879898543142606244511569936384000000000
43! = 60415263063373835637355132068513997507264512000000000
44! = 2658271574788448768043625811014615890319638528000000000
45! = 119622220865480194561963161495657715064383733760000000000
46! = 5502622159812088949850305428800254892961651752960000000000
47! = 258623241511168180642964355153611979969197632389120000000000
48! = 12413915592536072670862289047373375038521486354677760000000000
49! = 608281864034267560872252163321295376887552831379210240000000000
50! = 30414093201713378043612608166064768844377641568960512000000000000
51! = 1551118753287382280224243016469303211063259720016986112000000000000
52! = 80658175170943878571660636856403766975289505440883277824000000000000
53! = 4274883284060025564298013753389399649690343788366813724672000000000000
54! = 230843697339241380472092742683027581083278564571807941132288000000000000
55! = 12696403353658275925965100847566516959580321051449436762275840000000000000
56! = 710998587804863451854045647463724949736497978881168458687447040000000000000
57! = 40526919504877216755680601905432322134980384796226602145184481280000000000000
58! = 2350561331282878571829474910515074683828862318181142924420699914240000000000000
59! = 138683118545689835737939019720389406345902876772687432540821294940160000000000000
60! = 8320987112741390144276341183223364380754172606361245952449277696409600000000000000
61! = 507580213877224798800856812176625227226004528988036003099405939480985600000000000000
62! = 31469973260387937525653122354950764088012280797258232192163168247821107200000000000000
63! = 1982608315404440064116146708361898137544773690227268628106279599612729753600000000000000
64! = 126886932185884164103433389335161480802865516174545192198801894375214704230400000000000000
65! = 8247650592082470666723170306785496252186258551345437492922123134388955774976000000000000000
66! = 544344939077443064003729240247842752644293064388798874532860126869671081148416000000000000000
67! = 36471110918188685288249859096605464427167635314049524593701628500267962436943872000000000000000
68! = 2480035542436830599600990418569171581047399201355367672371710738018221445712183296000000000000000
69! = 171122452428141311372468338881272839092270544893520369393648040923257279754140647424000000000000000
70! = 11978571669969891796072783721689098736458938142546425857555362864628009582789845319680000000000000000
71! = 850478588567862317521167644239926010288584608120796235886430763388588680378079017697280000000000000000
72! = 61234458376886086861524070385274672740778091784697328983823014963978384987221689274204160000000000000000
73! = 4470115461512684340891257138125051110076800700282905015819080092370422104067183317016903680000000000000000
74! = 330788544151938641225953028221253782145683251820934971170611926835411235700971565459250872320000000000000000
75! = 24809140811395398091946477116594033660926243886570122837795894512655842677572867409443815424000000000000000000
76! = 1885494701666050254987932260861146558230394535379329335672487982961844043495537923117729972224000000000000000000
77! = 145183092028285869634070784086308284983740379224208358846781574688061991349156420080065207861248000000000000000000
78! = 11324281178206297831457521158732046228731749579488251990048962825668835325234200766245086213177344000000000000000000
79! = 894618213078297528685144171539831652069808216779571907213868063227837990693501860533361810841010176000000000000000000
80! = 71569457046263802294811533723186532165584657342365752577109445058227039255480148842668944867280814080000000000000000000
81! = 5797126020747367985879734231578109105412357244731625958745865049716390179693892056256184534249745940480000000000000000000
82! = 475364333701284174842138206989404946643813294067993328617160934076743994734899148613007131808479167119360000000000000000000
83! = 39455239697206586511897471180120610571436503407643446275224357528369751562996629334879591940103770870906880000000000000000000
84! = 3314240134565353266999387579130131288000666286242049487118846032383059131291716864129885722968716753156177920000000000000000000
85! = 281710411438055027694947944226061159480056634330574206405101912752560026159795933451040286452340924018275123200000000000000000000
86! = 24227095383672732381765523203441259715284870552429381750838764496720162249742450276789464634901319465571660595200000000000000000000
87! = 2107757298379527717213600518699389595229783738061356212322972511214654115727593174080683423236414793504734471782400000000000000000000
88! = 185482642257398439114796845645546284380220968949399346684421580986889562184028199319100141244804501828416633516851200000000000000000000
89! = 16507955160908461081216919262453619309839666236496541854913520707833171034378509739399912570787600662729080382999756800000000000000000000
90! = 1485715964481761497309522733620825737885569961284688766942216863704985393094065876545992131370884059645617234469978112000000000000000000000
91! = 135200152767840296255166568759495142147586866476906677791741734597153670771559994765685283954750449427751168336768008192000000000000000000000
92! = 12438414054641307255475324325873553077577991715875414356840239582938137710983519518443046123837041347353107486982656753664000000000000000000000
93! = 1156772507081641574759205162306240436214753229576413535186142281213246807121467315215203289516844845303838996289387078090752000000000000000000000
94! = 108736615665674308027365285256786601004186803580182872307497374434045199869417927630229109214583415458560865651202385340530688000000000000000000000
95! = 10329978488239059262599702099394727095397746340117372869212250571234293987594703124871765375385424468563282236864226607350415360000000000000000000000
96! = 991677934870949689209571401541893801158183648651267795444376054838492222809091499987689476037000748982075094738965754305639874560000000000000000000000
97! = 96192759682482119853328425949563698712343813919172976158104477319333745612481875498805879175589072651261284189679678167647067832320000000000000000000000
98! = 9426890448883247745626185743057242473809693764078951663494238777294707070023223798882976159207729119823605850588608460429412647567360000000000000000000000
99! = 933262154439441526816992388562667004907159682643816214685929638952175999932299156089414639761565182862536979208272237582511852109168640000000000000000000000
100! = 93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000
</code></pre>
",0
11805492,11786238,1,"<p>Pipes are used to communicate between processes.  You can't <em>pipe</em> from one array to another.</p>

<p>If the <code>printf()</code> at the end of your code does what you want, then you simply want to use <strong><a href=""http://linux.die.net/man/3/sprintf"" rel=""nofollow""><code>sprintf()</code></a></strong> to put the result of the ""print"" in an array instead of sending it to <code>stdout</code>.</p>
",0
11832896,11832816,0,"<p>A float (on most systems) stores it's value in 32 bits, with those bits divided between sign, exponent and ""Significand"" (the main part of the value) this gives between 7 and 8 digits of decimal precision for most values, well short of the 12 digits you are looking at.</p>

<p>a double uses 64 bits and gives 15-16 digits of precision for most values.</p>

<p>You are getting odd values around the 7-9th digit because your compiler has to round the value to store it. Rounding methods are pretty much standard, so compilers will generally give the same rounded results.</p>

<p>Please note that C/C++ generally requires compilers to provide ""minimal"" sizes, however the values may be stored in larger storage, for instance in CPU Registers, so your milege will vary on low significance bits.</p>
",0
11832925,11832816,3,"<blockquote>
  <p>If it is garbage value then it should be different for different compilers but when i saw the output in my book and tried it practically they both are same results.</p>
</blockquote>

<p>There is a very good chance that your compiler and the book you are using both use the <a href=""http://en.wikipedia.org/wiki/IEEE_754-2008"" rel=""nofollow"">IEEE 754</a> standards for floating point numbers, and have similar mechansims for handling the values.  As such, they'll probably get the same answer, as will many other compilers and systems.</p>

<p>The main issue is in <a href=""http://floating-point-gui.de/formats/fp/"" rel=""nofollow"">how floating point values are stored</a> and function.  There isn't enough precision in a 32 bit float value to represent your 12 decimal places exactly, so you get a different output than what you entered.</p>
",0
11833000,11832816,1,"<p>Expect compilers to implement the IEEE  754 Standard for floating point numbers. For float ( binary32 bits) there are 23 bits for the digits and 1 for the sign. This gives you 7.x decimal digits.  So what you see is correct.  </p>

<p>If you need more precision use double which uses 52 bits for the digit and gives you 34 digits precision.</p>
",0
11833026,11832816,1,"<p>If you're using floating point, you might also find this an enlightening article, saving you from many surprises: <a href=""http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html"" rel=""nofollow"">What Every Computer Scientist Should Know About Floating-Point Arithmetic</a>.</p>

<p>Remember that, unlike in math, 10 times 0.1 is hardly ever 1.</p>
",0
11809461,11809275,2,"<p>The reason you need 2 <code>getchar()</code> is because</p>

<ol>
<li>the last <code>scanf()</code> call left the <kbd>ENTER</kbd> waiting in the buffer</li>
<li>the 1st <code>getchar()</code> ""ate"" that <kbd>ENTER</kbd></li>
<li>the 2nd <code>getchar()</code> waits for input.</li>
</ol>

<hr>

<p>To properly deal with user input, use <code>fgets()</code> and <code>sscanf()</code> instaed of the simpler <code>scanf()</code>. Define a buffer for these functions, for example</p>

<pre><code>char buffer[1000];
</code></pre>

<p>and then replace your <code>scanf()</code> calls with the pair</p>

<pre><code>fgets(buffer, sizeof buffer, stdin);
sscanf(buffer, ""%d"", &amp;n);
</code></pre>

<hr>

<p>In the future you might want to also check the return value of <code>sscanf()</code> to detect invalid inputs, like <kbd>foo42</kbd><kbd>ENTER</kbd></p>

<pre><code>if (sscanf(buffer, ""%d"", &amp;n) != 1) /* invalid input */;
</code></pre>

<hr>

<p>Edit (using <code>strtol()</code> rather than <code>sscanf()</code> is even better -- thanks to @Scooter)</p>

<pre><code>char buffer[1000];
char *err;
/* ... */
fgets(buffer, sizeof buffer, stdin); /* error checking ommited */
n = strtol(buffer, &amp;err, 10);
/* error checking ommited */
/* ... */
</code></pre>
",3
15504098,15503996,0,"<p>To get the length of a string in C you'd use <code>strlen</code> and pass the string.</p>

<pre><code>int len = strlen(array[0]);
</code></pre>
",0
15504165,15503996,5,"<p>This will probably do what you want, but it wasn't exactly what you asked for.</p>

<pre><code>#include &lt;stdio.h&gt;

char *strs[] = {
    ""foo"",
    ""bar"",
    ""bazy""
};

int main() {
    printf(""%d - %s\n"", strlen(strs[0]), strs[0]);
    printf(""%d - %s\n"", strlen(strs[1]), strs[1]);
    printf(""%d - %s\n"", strlen(strs[2]), strs[2]);
    return 0;
}
</code></pre>

<p><a href=""http://codepad.org/sRDGUzUx"" rel=""nofollow"">Output</a>:</p>

<pre><code>3 - foo
3 - bar
4 - bazy
</code></pre>

<p>Note that you only have a few possibilities for storing arrays of arrays. You can either do what this solution does (make an array of pointers to arrays), make a ""compressed"" list of arrays in a large array, or make an overly large 2-D array.</p>

<hr>

<p>The ""compressed"" array would take the format:</p>

<pre><code>char strs[] = ""foo\0bar\0bazy""; // array is {f,o,o,\0,b,a,r,\0,b,a,z,y,\0}
</code></pre>

<p>The problem with this format is that it's somewhat tricky to access anything after the first element, and usually involves searching linearly through the array. (or keeping a seperate table of addresses... rather like the first solution)</p>

<hr>

<p>The 2-D array requires that you specify all sizes, and looks like this:</p>

<pre><code>char strs[3][5] = {
   ""foo"",
   ""baz"",
   ""baxy""
};

int main() {
    printf(""%d - %s\n"", strlen(strs[0]), strs[0]);
    printf(""%d - %s\n"", strlen(strs[1]), strs[1]);
    printf(""%d - %s\n"", strlen(strs[2]), strs[2]);
    return 0;
}
</code></pre>

<p>This is probably laid out in memory like this:</p>

<pre><code>{f,o,o,\0,*,b,a,z,\0,*,b,a,x,y,\0} (the *'s could be anything, most dependent on your compiler)
</code></pre>

<p>Since the compiler knows that each string takes exactly 5 bytes, it can easily calculate the location of the later elements.</p>
",4
15504252,15503996,1,"<p>If you want an actual array, something like this:</p>

<pre><code>    char str[4][5];  // holds up to 4 characters in each
    strcpy(str[0], ""He"");
    strcpy(str[1], ""llo"");
    strcpy(str[2], "" Wor"");
    strcpy(str[3], ""ld"");
</code></pre>
",0
15504391,15503996,2,"<p>When declaring an array in C, you must declare its size unless you are simultaneously providing initializing values. This is because arrays are laid out sequentially in memory, and so the computer needs to know how much space to set aside.</p>

<p>Further, <code>char str [] = {....}</code> will declare an array of <em>characters</em>, not an array of <em>strings</em>. A string is an array of characters, so <code>str</code> is just a single string.</p>

<p>To create an array of strings, you need to do something like this:</p>

<pre><code>char strs[num_of_strings][max_length_of_strings+1];
strcpy(strs[0],""string1"");
strcpy(strs[1],""string2"");
...
</code></pre>

<p>There's a more in depth discussion of other options at <a href=""https://stackoverflow.com/questions/1088622/how-do-i-create-an-array-of-strings-in-c"">this question</a>.</p>

<p>If you're specifying <code>max_length_of_strings</code> but then copying from source strings that you can't guarantee are shorter than <code>max_length_of_strings</code>, you want to use <code>strncpy</code> instead of <code>strcpy</code>. In that case you also want to ensure that the resulting strings are null terminated, which you can do by looping</p>

<pre><code>strs[i][max_length_of_strings] = '\0';
</code></pre>

<p>To get the length of a null-terminated string, you use the function <code>strlen</code>.</p>

<p>As to the second part of your question, the above should make it clear how to create a higher-dimensional array. I'd provide more detail, but I'm not exactly sure what you want this array to do. When you say ""number of all chars in str"" do you mean the max length of the strings stored in your <code>strs</code> array?</p>

<p>If so, you don't need to worry about that. Programming your <code>strs</code> array like I explained it above will already give you this functionality: since strings are just arrays of <code>char</code>'s, you can index into strings in the same way that you index into <code>char</code>'s.</p>

<p>Let me know if any of the above isn't clear, and I'll try to explain it better.</p>
",0
12343063,12343027,5,"<p>No. <code>const</code> in C never means <em>constant</em> but it means ready-only.</p>

<p>This is the same for C90/C99/C11.</p>

<p>Note that in your example, you are using a variable length array. VLA have been introduced in C99 and the size of a VLA does not need to be a constant expression but still <code>n</code> is not a constant expression. </p>
",1
12343102,12343027,1,"<p>No, <code>const</code> does not make a constant like it does in C++.</p>

<p>On the other hand, C99 did add variable length arrays (VLAs), so for <code>auto</code> storage class, the size doesn't need to be a constant. This allows you to do things like:</p>

<pre><code>int f(int n) { 
    int array[n];
    // ...
}
</code></pre>

<p>So, you can't do <em>exactly</em> what you're asking for, but you can do something that's close enough to equivalent for <em>many</em> (perhaps most) circumstances.</p>
",0
12868599,12868562,1,"<pre><code>char *myInputString = NULL;
while (1) {
    /* read in myInputString from user input, and test... */
    if (strcmp(myInputString, ""foo"") == 0)
        break;
}

return EXIT_SUCCESS;
</code></pre>
",0
13482737,13482519,-1,"<p>Using <a href=""http://www.cplusplus.com/reference/clibrary/cstring/strstr/"" rel=""nofollow""><code>strstr()</code></a> inside a loop:</p>

<pre><code>int get_substr_count(const char * haystack, const char *needle)
{
    int count = 0;
    const char *tmp = haystack;
    while( tmp = strstr( tmp, needle)){
        printf( ""Position: %d\n"", (int)(tmp-haystack));
        ++count;
    }
    return count;
}
</code></pre>
",3
13482743,13482519,1,"<p>Your function will use <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/strstr.html"" rel=""nofollow""><code>strstr()</code></a> in a <code>while</code> loop to find the first match of <code>str2</code> in <code>str1</code>.  You can then print the offset of that match.  You'll continue the search at the first character after the match. You'll stop the loop when <code>strstr()</code> no longer finds a match (signalled by <code>strstr()</code> returning NULL).</p>

<p>If you needed non-overlapping, you'd want to know the length of <code>str2</code> and you'd start the next search at the matched character plus the length of <code>str2</code>.</p>
",2
12303587,12303459,1,"<p>I think you have an issue with your if statement, it should look like this</p>

<pre><code>if ( (d &lt;= b) &amp;&amp; (d == ( c / sizeof(a))))
</code></pre>

<p>you had an extra ( on the left side of the 'b'</p>
",0
12303514,12303459,4,"<p>Have you tried to compile it?</p>

<p>Your if statement needs one more ) . That or simplify it to:</p>

<pre><code>if ((d &lt;= b) &amp;&amp; (d == c / sizeof(a)))
</code></pre>

<p>Your printf statement should use ""%zu\n"" for C99, although <a href=""https://stackoverflow.com/questions/1546789/clean-code-to-printf-size-t-in-c-or-nearest-equivalent-of-c99s-z-in-c"">it's complicated</a>.</p>
",2
12303527,12303459,1,"<p>Try adding a newline to your <code>printf</code> statement:</p>

<pre><code>printf(""%d\n"", sizeof a);
</code></pre>

<p>Standard output is usually buffered, so output doesn't always show up on your console immediately unless there's a newline or you add a <code>fflush(stdout);</code> after the <code>printf</code> call.  </p>
",0
12303530,12303459,1,"<pre><code>((d &lt;= (b) &amp;&amp; (d == ( c / sizeof(a)))) 
</code></pre>

<p>Looks an extra <code>(</code> before the <code>b</code>.</p>

<pre><code>( (d &lt;= b) &amp;&amp; (d == (c/sizeof(a))))
</code></pre>
",2
12303556,12303459,2,"<p>One closing bracket is missing IMO. I opended up your if with vertical parantheses alignment technique.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int a ;
int b = 256 ;
int c = 16 ;
int d = 4 ;

int main() {

    if (
        (
         d &lt;= (b) &amp;&amp; (
                      d == (
                             c / sizeof(a)
                           )
                     )
        )
       //Here needs another closing parantheses
    {
        printf(""%d"",sizeof(a) );
    }
    return 0;

}
</code></pre>

<p>Actually you can sefely remove some parantheses here in your snippet.</p>
",0
12303564,12303459,1,"<p>You have forgotten closing one paranthesis in line 11 you have opened six and closed five.</p>
",0
12272829,12272672,1,"<pre>
// this is really bad
udpdata.rules[0].myname = ""lalla\0"" ; 

// do this instead. You want the literal string in your field.
memcpy(udpdata.rules[0].myname, ""lalla\0"", 6);

....

// This is wrong.  arr is already a pointer.
memcpy (&arr , &udpdata, sizeof(udpdata));

// do this instead
mempcy (arr, &udpdata, sizeof(udpdate));

</pre>

<p>Concerning printing, I don't know how big ints are on your machine but if they are 4 bytes then</p>

<p><code>printf(""%.7s"", &amp;arr[1+4]);</code></p>

<p>I'm not sure why you want to convert everything to a char array if you wanted to print out the content.  Just use the struct and a <strong>for</strong> loop.  Anyway I think you may want to read up on C arrays.</p>
",0
12272916,12272672,3,"<p><code>memcpy</code> does not allocate any memory. In your <code>memcpy</code> call, the memory for the destination <code>arr</code> was allocated when the variable <code>arr</code> was defined (<code>char arr[400]</code>).</p>

<p>There's a problem there, which is that you haven't allocated enough room. You copy <code>sizeof(updata)</code> bytes into <code>arr</code>, which is probably 1+4+7*256=1797 (this may vary depending on <code>sizeof(int)</code> and on whether <code>__packed__</code> actually leaves out all unused bytes on your platform). If you really need <code>arr</code> (you probably don't), make it at least <code>sizeof(updata)</code> large. Defining it with <code>char arr[sizeof(updata)]</code> is fine.</p>

<p>If the layout of the structure is defined by some external format, you should use a fixed-size type instead of <code>int</code> (which is 2 or 4 bytes depending on the platform, and could be other sizes but you're unlikely to encounter them).</p>

<p>If the layout of the structure is defined by some external binary format and you want to print out the 1797 bytes in this format, use <code>fwrite</code>.</p>

<pre><code>fwrite(updata, sizeof(updata), 1, stdout);
</code></pre>

<p>If you want to have a human representation of the data, use <code>printf</code> with appropriate format specifications.</p>

<pre><code>printf(""ip='%c' udp=%d\n"", updata.ip, updata.ip);
for (i = 0; i &lt; sizeof(updata.rules)/sizeof(updata.rules[0]); i++) {
    puts(updata.rules[i].myname);
}
</code></pre>

<p>Despite the name, <code>char</code> is in fact the type of bytes. There is no separate type for characters in C. A character constant like <code>'a'</code> is in fact an integer value (97 on almost all systems, as per <a href=""http://en.wikipedia.org/wiki/ASCII"" rel=""nofollow"">ASCII</a>). It's things like writing it with <code>putchar</code> or <code>printf(""%c"", ¡­)</code> that make the byte interpreted as a character.</p>

<p>If your compiler is not signaling an error when you mix up a <em>pointer</em> (such as <code>char*</code>) with an integer, on the other hand, turn up the warning level. With Gcc, use at least <code>gcc -O -Wall</code>.</p>

<hr>

<p>After actually compiling your code, I see the main error (you should have copy-pasted the error message from the compiler in your question):</p>

<pre><code>udpdata.rules[0].myname = ""lalla\0"" ;
</code></pre>

<p><code>udpdata.rules[0].myname</code> is an array of bytes. You can't assign to an array in C. You need to copy the elements one by one. Since this is an array of <code>char</code>, and you want to copy a string into it, you can use <code>strcpy</code> to copy all the bytes of the string. For a bunch of bytes in general, you would use <code>memcpy</code>.</p>

<pre><code>strcpy(udpdata.rules[0].myname, ""lalla"");
</code></pre>

<p>(Note that <code>""lalla\0""</code> is equivalent to <code>""lalla""</code>, all string literals are zero-terminated in C.1) Since <code>strcpy</code> does not perform any size verification, you must make sure that the string (including its final null character) fits in the memory that you've allocated for the targets. You can use other functions such as <code>strncat</code> or <code>strlcpy</code> if you want to specify a maximum size.</p>

<p>1 <sub> There's one exception (and only this exception) where <code>""lalla""</code> won't be zero-terminated: when initializing an array of 5 bytes, e.g. <code>char bytes[5] = ""lalla""</code>. If the array size is at least 6 or unspecified, there will be a terminating zero byte. </sub>  </p>
",0
12272923,12272672,1,"<p><em>With respect to the code , how do we print out the character array in the structure transrules ?</em></p>

<pre><code>/* incorrect -&gt; udpdata.rules[0].myname = ""lalla\0"" ; */
strcpy(udpdata.rules[0].myname,""lalla"") ;
printf(""%s\n"",udpdata.rules[0].myname);
</code></pre>

<p><em>As the array defined is of type char why does arr [1] still accept an integer value with memcpy ?</em></p>

<p>memcpy doesn't know or care about what the underlying datatypes might be where it is copying to. It takes void pointers and copies the value in one or more byte to one or more other bytes:</p>

<pre><code>void * memcpy ( void * destination, const void * source, size_t num );
</code></pre>
",0
12811645,12811586,1,"<p>I'm pretty sure that warning is conservative, i.e. it won't be given unless the compiler is sure it is unreachable code.</p>
",0
12811650,12811586,2,"<p>I just found following link:</p>

<p><a href=""http://old.nabble.com/gcc--Wunreachable-code-option-td31698329.html"" rel=""nofollow"">http://old.nabble.com/gcc--Wunreachable-code-option-td31698329.html</a></p>

<p>That option has been removed because it is unstable.
Check the mailing thread for details</p>
",1
12811956,12811586,12,"<p>Read the code, understand it, and if the code marked unreachable really is unreachable and it isn't unreachable because of a logic error, then you can just remove it. If you haven't read the code and understood it, then it isn't safe to modify it no matter what the compiler says.</p>
",0
13756376,13756012,0,"<p>This is kind of a long shot, but what if read() is returning early because otherwise it would have to wait for incoming data? The fastest data to read is none at all :)</p>

<p>It would mess up the timings, but have you tried doing this loop whilst error checking? Or implement the loop via a recv() which should block unless you have asked it not to?</p>

<p>Hopefully this helps.</p>
",0
12820841,12820152,0,"<p>As Joachim Pileborg said, you should not pass a pointer to pointer. </p>

<p>just do : </p>

<p><code>pthread_create(thread_id, NULL, worker_start, ready);</code></p>

<p>And don't forget to use the keyword STRUCT : </p>

<pre><code>typedef struct t_type {
 char* a; char* b; int c; int d; FILE *e;
} t;
</code></pre>
",0
12820222,12820152,0,"<p>One issue is that fileds a and b are pointers to a char and do not allocate memory for the characters.</p>

<p>Either just point them at the strings</p>

<pre><code>ready-&gt;a =  ss1;
ready-&gt;b =  ss2;
</code></pre>

<p>or duplicate the strings</p>

<pre><code>ready-&gt;a = strdup( ss1 );
ready-&gt;b = strdup( ss2 );
</code></pre>

<p>Another issue is as per @JoachimPileborg's answer</p>
",0
12820228,12820152,2,"<p>When you're passing the pointer to the thread, you pass it as a pointer to  pointer (due to you using the address-of operator <code>&amp;</code>). You don't need to do that, and in the thread function you don't treat it as a pointer-to-pointer but just plain pointer.</p>

<p>Remove the ampersand (<code>&amp;</code>) when creating the thread and things should work much better.</p>
",2
12820247,12820152,0,"<p>Where do <code>ready-&gt;a</code> and <code>ready-&gt;b</code> point to? Looks like your writing via uninitialized pointers.</p>
",1
12279728,12279690,3,"<p>The string literal is put ""somewhere"" in memory, such that it is available when the program starts.</p>

<p>The variable <code>charPtr</code> is allocated (typically on the stack), and typically using 32 bits on a 32-bit platform, or 64 bits on a 64-bit platform. In your case, since you state that <code>sizeof (char *)  is 4, the pointer will need</code>4 * CHAR_BIT` bits, which is 32 bits on almost all modern computers with byte-addressable memory.</p>

<p>The pointer is initialized to point at the first byte of the string.</p>
",0
12279737,12279690,2,"<blockquote>
  <p>Is 7 bytes of memory allocated and the pointer is allocated to the
  first byte? </p>
</blockquote>

<p>In fact, not really. Somewhere in <em>readonly</em> part of memory, there is allocated 7 chars, containing <code>""see me\0""</code>, and this variable points to it.</p>

<p>Difference would be, if you write </p>

<pre><code>char charPtr[]=""see me"";
</code></pre>

<p>In this case, <em>on stack</em> will be allocated 7char (+ some padding) long array, where the text ""see me"" will be copied.</p>

<blockquote>
  <p>how is the memory allocated?</p>
</blockquote>

<p>It is allocated by OS when starting the application.</p>
",0
12279738,12279690,6,"<p><em><strong><code>charPtr</code> is a pointer</em></strong> to an <strong><em>string literal ""see me""</em></strong> which resides somewhere in implementation defined memory region. This string literal <strong>should not</strong> be modified and any attempt to do so leaves you with an <strong>Undefined Behavior</strong>. </p>

<blockquote>
  <p><strong>I know the <code>sizeof(char*)</code> is <code>4</code> bytes and how does it matter here and what does it influence in allocation of memory?</strong>     </p>
</blockquote>

<p>Since <code>charPtr</code> is a pointer you cannot use <code>sizeof()</code> to determine the length of the string literal. If you do so, What you get is the memory occupied by the pointer and not by the string. You will need to use <code>strlen()</code> if you need to get the length of the string.</p>

<pre><code>         +-----+     +---+---+---+---+---+---+----
charPtr: |  *======&gt; | s | e | e |   | m | e |\0 |
         +-----+     +---+---+---+---+---+---+---- 
</code></pre>
",8
12279754,12279690,2,"<p>The <code>""see me""</code> is a string literal and will exist for the lifetime of the program. Memory is not allocated on the stack and memory is not allocated on the heap for string literals. The string literal will be compiled into the binary, into a read-only region.</p>

<p>There is 8 characters in the string literal <code>""see me""</code>: the 7 characters that you see plus an implicit null terminator.</p>

<p>The initialisation:</p>

<pre><code>char* charPtr=""see me"";
</code></pre>

<p>gives <code>charPtr</code> the address of the string literal. Modifying a string literal is undefined behaviour.</p>

<p>See section <em>6.4.5 String literals</em> of the C99 standard for more detailed information.</p>

<hr>

<p>Note that:</p>

<pre><code>printf(""%d"", charPtr);
</code></pre>

<p>is technically undefined behaviour as <code>%d</code> expects an <code>int</code> argument but <code>charPtr</code> is a <code>char*</code>: use <code>%p</code> instead.</p>
",2
12279774,12279690,1,"<p>Normally the statement uses a const pointer.</p>

<pre><code>const char* charPtr = ""see me"";
</code></pre>

<p>""see me"" is allocated in read-only memory. <code>charPtr</code> contains the address of the 's'. The string is terminated by the null char.</p>
",0
12279986,12279690,0,"<p><code>char*</code> is just like normal pointer pointing first index of string .</p>
",0
13483707,13483669,4,"<p>Try -lsundials_cvode instead - delete the 'lib' and '.a' parts</p>

<p>Note that LD_LOAD_PATH is for locating dynamic libraries at run-time, not during compilation.</p>

<p>Edit:</p>

<pre><code>I just tried that. The change addresses the cannot find library error but 
now I am faced with many ""undefined reference to"" errors. Does this mean 
the linking of the library files has failed somehow? How do I correct this? 
</code></pre>

<p>It means that there are other symbols that need to be resolved that are not in the library you linked.  Note that you need to change both libraries (you have two on the command line).  Also perhaps they are in the wrong order.</p>
",5
18517475,18517407,10,"<p>In:</p>

<pre><code>void show_unsigned(short x) {
    show_bytes((byte_pointer) &amp;x, sizeof(unsigned));
}
</code></pre>

<p>You declared the argument <code>short x</code> which is smaller than <code>int x</code> so you ignored some of the <code>00</code> and your print function is displaying adjacent garbage.</p>
",5
18517559,18517407,1,"<p>what you are doing doesn't make any sense, particularly with the type conversions that you have occurring. Someone else already pointed out my point about the conversion to short</p>

<p>Rather than writing an absurd number of functions try doing this</p>

<pre><code>void show_bytes( void *start, unsigned int len ) {
    unsigned char* ptr = (unsigned char *) start;
    unsigned int i = 0;
    for ( i = 0; i &lt; len; ++i, ++ptr ) {
        printf( "" %.2x"", ptr[0] );
    }
}
</code></pre>

<p>Instead of calling as you had been just call it like:<br>
<code>show_bytes( (void *)&amp;x, sizeof(x));</code></p>

<p>And if thats too much typing make a macro out of that. now it works for any type you come up with.</p>
",0
18517574,18517407,1,"<p>You're reading <code>sizeof(unsigned)</code> bytes in a <code>short</code>. <code>short</code> isn't guaranteed to be the same size as <code>unsigned</code>, hence, when reading the bytes next to your short, garbage data is read.</p>

<p>To fix this, either pass your argument as an <code>unsigned</code>, or when using sizeof, use <code>sizeof(short)</code>.</p>
",0
10806553,10805875,4,"<p>You can't do that in C. That's one of the reasons why C++ introduces <em>namespaces</em>.</p>

<p>The only thing you can do is use a non-conflicting name for your own functions.</p>
",3
10806569,10805875,1,"<p>This is not a standard thing to do, and I'm pretty sure that if you can do it at all, you will have to read the manual for your linker.  And if you try to port this, you will need to read the manual for each linker for each platform to which you try to port this.</p>

<p>The more usual way to do things is to write your own functions with your own names.  If you need to hook functionality in a standard library, you would get the source for that library and build your own version.</p>
",1
12298670,12298503,1,"<p>If <code>sizeof(tcpstuct)</code> is the size of one ""thingy"", and <code>tcprules</code> is the number of ""thingies"", then there should be no need for any casts.</p>

<p><code>C</code> automatically converts between different integer types, so whatever type your expression <code>sizeof(tcpstuct) * tcprules</code> has, should be converted to <code>WORD32</code> (whatever that is, but assuming it's an integer type).</p>

<p>It's likely that the bug in your code is elsewhere, and very unlikely that this expression causes a segfault in any of the versions you've posted. Maybe the segfault is in the function you call.</p>
",0
12299882,12298503,1,"<p>I do not see any potential crash in your statements. The segfault must be somewhere else.</p>
",0
12837480,12837211,2,"<p>The result of pointer arithmetic is not exactly the result of their address arithmetic. The output should be <code>((address of ptr) - (address of p)) / (sizeof(pointed_type))</code>
For example:</p>

<pre><code>int a[] = {0,1,2,3,4};
int *p=a;
int *p2 = p+1;
printf(""%d"",p2-p)     // will print 1
</code></pre>
",0
12837512,12837211,0,"<p>I modified it a little to be certain. The point here is that subtracting pointer returns the number of units i.e. address / size of pointer, not plain difference of address locations.</p>

<pre><code>   printf(""ptr before %p\n"", ptr);
   ptr++;
   printf(""ptr after %p and p %p\n"", ptr, p);
   printf(""%ld %ld %d\n"",ptr-p,*ptr-a,**ptr);
</code></pre>

<p>On my 64 bit machine, the printed addresses are 8 locations apart with just a single ++. On a 32 bit machine this would be 4. But still the arithmetic difference would return 1.</p>
",0
11894397,11894103,2,"<p>Add end-of-lines to your <code>printf</code>.  Like so:</p>

<pre><code>printf(""honor\n"");
</code></pre>

<p>Your shell prompt might overwrite the output if you work in command line. </p>
",0
11894790,11894103,1,"<p>First you have a gap. a state that is not covered in the if conditions. What if the user entered exactly 75, 80 and 60? If I were you I'd use "">="" instead of "">"" and ""&lt;="" instead of ""&lt;"". also if x is &lt; 75 is not covered at all.</p>

<p>You might try to put this statement before the ""if"" conditions to see what is it exactly you are getting from <code>scanf()</code>.</p>

<pre><code>printf(""My inputs are %d, %d and %d\n"",x ,y ,z);
</code></pre>

<p>Once you are sure of your inputs. Then check your conditions. I think there might be a problem with that line (as mentioned earlier x&lt;75 is not covered at all) :</p>

<pre><code>else if (( x &gt; 75) &amp;&amp; ( y &lt; 80) &amp;&amp; (z &lt; 60));
</code></pre>

<p>Maybe what you really need is </p>

<pre><code>(x&lt;=75)
</code></pre>

<p>Either way, an example run of your program will be helpful :-)</p>
",0
12294416,12294129,0,"<p>First of all, you really need to adopt a sane indention style, this code is very hard to read.
The problem with your code is that you read an array of user input into a local array ""chr"", then return the address of that array to main, instead of a character. main() does not expect an address, it expects a character. And regardless of that, the array ""chr"" is invalid once you have left the function anyhow.</p>

<p>Your printing for loop is also incorrect and doesn't make any sense. You keep printing all characters, over and over, each time you receive a new one. </p>

<p>There might be other issues with the hardware or MCU, I just fixed the most obvious software bugs.</p>

<pre><code>#include &lt;reg51.h&gt;
#include ""_LCD_R8C.c""

#define INPUT_LENGTH 11


int main()
{
  char input[INPUT_LENGTH];  /* The input from the serial port */
  int  input_pos  = 0;       /* Current position to write in the input buffer */

  lcd_init();
  lcd_clear();

  SCON = 0x50;
  TMOD = 0x20;                /* timer 1, mode 2, 8-bit reload */
  TH1  = 0xFD;                /* reload value for 2400 baud */
  TR1  = 1;
  TI   = 1;
  RI   = 1;

  while(1)
  {
    /* read the next character from the serial port */
    if(input_pos &lt; INPUT_LENGTH)    /* check for buffer overflow */        
    {
      input[input_pos] = getCharacter();
      lcd_print_b(input[input_post]);  /* only makes sense to print each character once */
      input_pos++;
    }
 }


 char getCharacter (void)
 {
   char chr          /* variable to hold the new character */

   while (RI != 1) 
     ;

   chr = SBUF;
   RI = 0;

   return(chr);
 }
</code></pre>
",7
13493872,13493820,8,"<p>Well, to answer directly the question that you asked, you would do it like this:</p>

<pre><code>int combined = year*10000 + month*100 + day;
</code></pre>

<p>But your approach is quite possibly not the best solution to your actual problem.</p>
",1
13493877,13493820,3,"<p>An easy way uses the string format to do this.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

snprintf(buffer, sizeof buffer, ""%04d%02d%02d"", year, month, day);
int result = atoi(buffer);
</code></pre>

<p>It is not efficient, but could be robust.</p>
",1
15818266,15818253,2,"<p>The type of variable <code>a</code> that you have is incorrect: it should be <code>char (*a)[20]</code> (yes, with parentheses).</p>

<p>This line is also incorrect:</p>

<pre><code>a[0]=""abcd"";
</code></pre>

<p>you cannot assign C strings like that, because <code>a[0]</code> is not a pointer: it is an array of 20 characters, so you need to use <code>strcpy</code> instead:</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
int main()
{
    char (*a)[20]=calloc(20, sizeof(char[20]));
    strcpy(a[0], ""abcd"");
    strcpy(a[1], ""wxyz"");
    printf(""%s\n"",a[0]);
    printf(""%s\n"",a[1]);
    return 0;
}
</code></pre>

<p>See the corrected program running <a href=""http://ideone.com/xHx3Di"" rel=""nofollow"">here</a>.</p>

<p>Note: Unlike C++, C does not require type casting of <code>void</code> pointers. It is typical for C programs to omit the cast of results returned from <code>malloc</code>, <code>calloc</code>, and <code>realloc</code>, because the type is already known from the type of the variable being assigned.</p>
",17
13484765,13484734,2,"<p>Your code is not valid here:</p>

<pre><code>strcpy(&amp;t-&gt;value.s, ""test"");
// value.s is a single char, not a string that you can store
// an arbitrary number of characters into.
//
</code></pre>

<p>You either need to give <code>s</code> some space</p>

<pre><code>struct teststruct
{
    char type;
    union {
        char s[10]; // length depends on your specific needs
        int i;
        float f;
    } value;
};
</code></pre>

<p>OR
make s a pointer and dynamically allocate as required</p>

<pre><code>struct teststruct
{
    char type;
    union {
        char *s;
        int i;
        float f;
    } value;
};
// instead of strcpy(&amp;t-&gt;value.s, ""test""); use t-&gt;value.s = strdup(""test"")
// don't forget to free the space when you are done.
</code></pre>
",2
12325659,12324954,0,"<p>C socket programming depends on the platform you are developing for. Is it Windows? UNIX? Before implementing any advanced code such as an authentication procedure you should train with simple socket programs. For UNIX (Linux, specifically) systems you can find some socket theory and examples <a href=""http://www.linuxhowtos.org/C_C++/socket.htm"" rel=""nofollow"">here</a>.</p>
",0
13736655,13736632,4,"<p>Your second <code>printf()</code> should take a <code>""%p\n""</code> format, and strictly a cast:</p>

<pre><code>printf(""%p\n"", (void *)&amp;y);
</code></pre>

<p>The number of machines where the cast actually changes anything is rather limited.</p>
",2
13736696,13736632,-1,"<p>The code seems to compile without warning or error on Visual Studio 2012.</p>

<pre><code>    #include &lt;stdio.h&gt;
    #include &lt;stdlib.h&gt;

    int _tmain(int argc, _TCHAR* argv[])
    {
        int* y = 0;
        printf(""%p\n"",y);
        printf(""%x"",&amp;y);
        y = (int*)malloc(sizeof(int));
        printf(""%p\n"", y);
        printf(""%x"",  &amp;y);

        return 0;
    }
</code></pre>

<p>The only recommendation is that you initialize y when you declare it.</p>
",1
15874464,15874424,4,"<p>Scanning stops on encountering invalid input. Therefore, in your code the value of <code>num</code> will remain unchanged.</p>

<p>To detect whether this is what happened you need to examine the return value of <code>scanf</code>. To quote  <code>man scanf</code>:</p>

<blockquote>
  <p>RETURN VALUES</p>
  
  <p>These functions return the number of input items assigned.  This can
  be  fewer than provided for, or even zero, in the event of a matching
  failure.  Zero indicates that, although there was input available,
  no conversions were assigned; <strong>typically this is due to an invalid
  input character,  such as an alphabetic character for a `%d'
  conversion</strong>.  The value EOF is  returned if an input failure occurs
  before any conversion such as an end-of-file occurs.  If an error or
  end-of-file occurs after conversion has  begun, the number of
  conversions which were successfully completed is  returned.</p>
</blockquote>
",0
14189110,14188269,1,"<p>This is fundamental and so there are many potential applications, but here's a specific industrial example:</p>

<p>Suppose you're sending a bunch of command and/or status info between devices.  To avoid wasting bandwidth (particularly if you're using a slower type of connection such an old 9-pin serial connection, which are still used on industrial devices), you very well may ""pack"" and ""unpack"" the data.  In the case of two-state signals, this means that each byte can hold up to eight independent statuses.  To get the status of bit 6, you could do something like this:</p>

<pre><code>status = (dataByte &amp; 0x40) &gt;&gt; 6;
</code></pre>

<p>In the above line, 0x40 is a bitmask that results in all bits being zero except for bit 6.  The shift right by 6 converts the resulting value--0x40 or 0x00--to 1 or 0.</p>

<p>Take a look at this brief section for standard, related examples:  <a href=""http://en.wikipedia.org/wiki/Bit_manipulation#Bit_manipulation_in_the_C_programming_language"" rel=""nofollow"">Bit Manipulation in C</a></p>
",0
18210864,18210406,0,"<p>You cannot check for both of your conditions in <code>scanf</code>. I would suggest reading whole input into a string, look for special characters. Once this test passes, try re-processing it into a string via <a href=""http://en.cppreference.com/w/c/io/fscanf"" rel=""nofollow""><code>sscanf</code></a>.
To search for special characters there is a <a href=""http://en.cppreference.com/w/c/string/byte/strpbrk"" rel=""nofollow""><code>strpbrk</code></a> defined in <code>string.h</code></p>

<pre><code>char* specials = ""%@!"";
char* buffer[SOME_SIZE];
double value;
int err;

scanf(""%s"", buffer);
if( strpbrk(buffer, specials) ) return SPECIAL_FOUND;
err = sscanf(buffer, ""%f"", &amp;value);
if(err &lt;= 0) return NOT_VALID_INPUT; //NOTE: there should probably be not EOF case

// process your value
</code></pre>

<p>Note: I did not check the code it's a rough idea to play with.</p>
",2
18210952,18210406,0,"<p>You can check the return value from <code>scanf()</code>. If you look at <a href=""http://www.cplusplus.com/reference/cstdio/scanf/"" rel=""nofollow noreferrer"">this page</a> :</p>
<blockquote>
<p><strong>Return value</strong></p>
<p>On success, the function returns the number of items of the argument list successfully filled. <strong>This count can match the expected number of items or be less (even zero) due to a matching failure, a reading error, or the reach of the end-of-file</strong>.</p>
</blockquote>
<p>So something like :</p>
<pre><code>if ( scanf( &quot;%f&quot;, &amp;num ) &lt;= 0 )
{
    // Stop the execution
}
// Continue
</code></pre>
<p>will do what you want.</p>
",0
18211344,18210406,3,"<p><code>scanf</code> is not your friend, here.  Even if you check the result to
ensure that you read one whole argument successfully, that doesn't
really guarantee that the input is valid in a meaningful sense.</p>

<p>Given input like:</p>

<pre><code>1!!!1!oneone!
</code></pre>

<p>the <code>%f</code> parsing will stop (but succeed) after reading the first <code>1</code>,
and leave the read pointer at the following <code>!</code>.  This may not be what
you consider ""valid input"".</p>

<p>In that case, try:</p>

<pre><code>if (scanf(""%f%c"", &amp;f, &amp;c) == 2 &amp;&amp; isspace(c))
    /* success */
</code></pre>

<p>This will, however, accept things like:</p>

<pre><code>1 oneoneonespace!bang
</code></pre>

<p>If anything on the same line is to be considered garbage, then it gets
difficult, because <code>scanf</code> doesn't distinguish between spaces and
newlines.  Perhaps try something like this:</p>

<pre><code>char buffer[1024];
if (fgets(buffer, sizeof(buffer), stdin) != NULL)
{
    if (sscanf(buffer, ""%f %c"", &amp;f, &amp;c) == 1)
        /* success */
}
</code></pre>
",0
18497871,18497845,6,"<p>You're mismatching parameters and print formats.  The default argument promotions cause your <code>char</code> parameter (<code>c[i]</code>) to be promoted to <code>int</code>, which sign extends (apparently your <code>char</code> is a signed type).  Then you told <code>printf</code> to interpret that argument as <code>unsigned int</code> by using the <code>%x</code> format.  Boom - undefined behaviour.</p>

<p>Use:</p>

<pre><code>printf(""%02x "", (unsigned int)(unsigned char)c[i]);
</code></pre>

<p>Instead.</p>
",9
18497919,18497845,0,"<p><code>char</code> is, by default, signed on your system. Moving an int into it makes your compiler think you want to use the highest bit as sign bit on operations that needs to be cast to an int. And printing it as a hex number is one.</p>

<p>Make the char pointer <code>c</code> an <code>unsigned char *</code> and the problem will go away.</p>

<p>If Carl is right with his comment (I'm going to check), use this fail-safe method instead:</p>

<pre><code>printf(""%02x "", c[i] &amp; 0xff);
</code></pre>
",6
12831512,12831486,12,"<p>You can't <em>run</em> a <code>.c</code> file just by using <code>./ex1.c</code>; you have to <em>compile</em> it into a runnable program first.</p>

<p>Assuming you have a Linux/OS X machine, use <code>gcc -Wall ex1.c -o ex1</code> to compile it (or, more simply, <code>make ex1</code>). Then you can <code>./ex1</code> to run the program.</p>
",1
11836920,11836894,6,"<p>XOR is a lousy way to swap variables.  Just declare a temporary and use assignments.</p>

<p>The XOR trick:</p>

<pre><code>x = x ^ y;
y = y ^ x;
x = x ^ y;
</code></pre>

<p>fails if <code>x</code> and <code>y</code> are the same location in memory; it will then set the value to 0.</p>

<p>I haven't analyzed your code in detail, but I'll bet that this:</p>

<pre><code>a[i]=a[i] ^ a[min];
a[min]= a[min] ^ a[i];
a[i]= a[i] ^ a[min];
</code></pre>

<p>is failing when <code>i == min</code>.</p>

<p>...</p>

<p>Confirmed, I tried running the program with an added <code>printf</code> statement, and with the specified input it does the swap with <code>i == min</code> at least once.</p>
",5
11838312,11836894,0,"<p>When two pointers designate the same memory location, the program will fail. And this is called memory aliasing. </p>
",0
15891896,15891875,3,"<p>You need to add a newline after the command, like <code>echo</code> does:</p>

<pre><code>fprintf(fp, ""2=120\n"");
</code></pre>

<p>Presumably, the servo's driver waits until it sees a newline before acting on a command.</p>
",0
15891897,15891875,0,"<p>the program has no problem, I run the following code</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
    FILE *fp;
    fp = fopen(""/home/syler/servoblaster"", ""w"");
    if (fp == NULL) {
        printf(""Error opening file\n"");
        exit(0); 
    }   
    fprintf(fp, ""2=120"");
    fclose(fp);
    fflush(fp); 
    return 0;
}
</code></pre>

<p>the result is</p>

<pre><code>cat /home/syler/servoblaster
2=120 
</code></pre>

<p>so, there must be the ""servoblaster"" kernel driver module problem.</p>
",1
13454602,13454105,5,"<p>This changed between C89 and C99.</p>

<p>C89 has (6.5.4.3):</p>

<blockquote>
  <p>A parameter type list specifies the types of, and may declare
  identifiers for, the parameters of the function.  [...] The
  special case of <code>void</code> as the only item in the list specifies that the
  function has no parameters.</p>
</blockquote>

<p>In C99 this is changed to (6.7.5.3p10; 6.7.6.3p10 in C11):</p>

<blockquote>
  <p>The special case of an unnamed parameter of type <code>void</code> as the only item in the list specifies that the function has no parameters.</p>
</blockquote>

<p>This is occasionally taken to mean that in C89, only the literal token <code>void</code> (after preprocessing) is acceptable when declaring a 0-parameter function, while in C99 a typedef is allowed.  However, this is not the intent of the standard according to <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_157.html"" rel=""nofollow noreferrer"">defect report 157</a>:</p>

<blockquote>
  <p>Subclause 6.7.1 makes clear that it is a single parameter having the type <code>void</code> (as opposed to use of the <code>void</code> keyword) that indicates that a function takes no parameters. 
  For clarity, Subclause 6.5.4.3 should be rephrased to emphasize that it is the type <code>void</code>, not the keyword <code>void</code> that matters. </p>
</blockquote>

<p>For C++, <a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#577"" rel=""nofollow noreferrer"">defect 577</a> brings C++ into conformance with C99; the resolution is not present in C++11 but is present in post-standard draft n3376 so can be assumed to be present in the next version of the standard, and likely in the first TC to C++11.  The typedef to <code>void</code> cannot be dependent on a template parameter for obvious reasons.  The question <a href=""https://stackoverflow.com/questions/9742135/g-error-anonymous-has-incomplete-type"">G++ error: ¡®&lt;anonymous&gt;¡¯ has incomplete type</a> discusses this issue with g++ and indicates that g++ will likely continue to reject the code for the time being.</p>
",0
12286743,12286691,3,"<p>Can you? Yes, most compilers don't forcibly prevent it. </p>

<p>Should you? No, (almost) never, it's (usually) a horrible idea. All sorts of things may break, and as with most preprocessor nonsense, it's going to be very difficult to debug.</p>

<p>Therefore, can you <em>legally</em>? No.</p>

<p>In the same fashion, you <em>can</em> have macros or variables that start with <code>__</code> or add things to the <code>std::</code> namespace or all sorts of other Very Bad Things. However, most rules like this have Very Good Reasons (conflicts related to keywords or name resolution, mostly). While it may be physically possible, there are few (if any) times you <em>need to</em> and fewer still when you <em>should</em>.</p>
",1
12286753,12286691,2,"<p>In C standard, it is not allowed.</p>

<blockquote>
  <p><strong>C11, ¡ì 6.4.1 Keywords</strong></p>
  
  <p>[...]</p>
  
  <p>The above tokens (case sensitive) are reserved (in translation phases
  7 and 8) for use as keywords, and shall not be used otherwise.</p>
</blockquote>
",4
12286780,12286691,1,"<p>There are several aspects in this issue:</p>

<ul>
<li>If you will redefine keywords, in 95% of compilers this will work fine regardless of what is written in the standards primarily because this was working in old compilers;</li>
<li>You can never be sure that this will work in the next version of your compiler;</li>
<li>You should avoid this from the practical stand point. The code will be more difficult to read and understand.</li>
</ul>

<p>The bottom line: Do you really need this? What will you get?</p>

<p>p.s. I saw several times that <code>try</code>-<code>catch</code> were redefined in various headers.</p>
",1
12346047,12345990,0,"<p>I think the following line needs change:</p>

<pre><code>pens+=pow(2,i);
</code></pre>

<p>It should be:</p>

<pre><code>pens = pens + (pens * 2)
</code></pre>

<p>The logic is that if you start with 1 penny on day 1, then it will be something like this</p>

<p>Day 1 :  1 + (1 * 2) = 3 <br>
Day 2 :  3 + (3 * 2) = 9 <br>
Day 3 :  9 + (9 * 2) = 27 <br>
and so on..</p>

<p>I hope this is the logic which you are expecting. By doing pow(2,i), you are just adding square of the day count to your total money each day which does't seem to be the expected logic based on your question.</p>
",1
12346052,12345990,0,"<p>Don't compute the power each time! Just keep track of a running count and double it every day.</p>

<p>Here's the core of the algorithm you need for <code>total_days</code> number of days:</p>

<pre><code>typedef unsigned long long int my_uint;

my_uint initial_payment = 1;
my_uint total_pennies = 0;

for (my_uint day_payment = initial_payment, day = 0; days != total_days; ++day)
{
    total_pennies += day_payment;
    day_payment *= 2;
}

// now have total_pennies
</code></pre>

<hr>

<p>Of course you could notice that 1&nbsp;+&nbsp;<em>q</em>&nbsp;+&nbsp;<em>q</em><sup>2</sup>&nbsp;+&nbsp;<em>q</em><sup>3</sup>&nbsp;+&nbsp;...&nbsp;+&nbsp;<em>q</em><sup><em>N</em>&nbsp;&minus;&nbsp;1</sup> is the same as (<em>q</em><sup><em>N</em></sup>&nbsp;&minus;&nbsp;1) / (<em>q</em>&nbsp;&minus;&nbsp;1) and thus compute the answer in one single step (e.g. for <em>q</em> = 2 in your case and <em>N</em> number of days).</p>
",0
12346058,12345990,0,"<p>This is the code you are looking at:</p>

<pre><code>total = 0;
for (int i = 1; i &lt;= days; i++) {
     total += pens;
     pens = pens*2;
}
printf(""You'll have $%d\n"", total);
</code></pre>
",10
12346071,12345990,5,"<p>Well, let's translate what you have to do into pseudocode:</p>

<pre><code>var daily_amount = 0.01
var total = daily_amount

iteration_over_days:
    daily_amount *= 2
    total += daily_amount
</code></pre>

<p>From there, all you need to do is translate to C.</p>

<p>Enjoy!</p>

<p>Instead of using the <code>long</code> datatype, you can also start at 1 and then at the end divide by 100: $0.01 -> $1</p>
",8
11110952,11110912,0,"<p>You can try using a <a href=""http://www.cplusplus.com/doc/tutorial/other_data_types/"" rel=""nofollow"">union</a></p>

<p>For example:</p>

<pre><code>union example {
    char var[40];
    char buffer[40];
} e1;

strcpy(e1.var, ""ABC"");

printf(""%s is same as %s"", e1.var, e1.buffer);
</code></pre>
",1
11110954,11110912,3,"<p>Not in any practical way in C, and you don't really want to anyway.  Tying your program logic to the names of your variables is a horrible idea.  Typically I see people attempt this when what they really need is some sort of collection type (and array, a map, whatever).</p>

<p>How about filling us in on the problem you are trying to solve with this?</p>

<p>Per your comment:</p>

<blockquote>
  <p>I need to have dynamic debug messages, I have a file which contain each function variables that I want to print.</p>
</blockquote>

<p>Use stringification in a macro:</p>

<pre><code>#define str(s) #s

int main() {
    int bar;
    str(bar) /* replaced by ""bar"" */
}
</code></pre>
",4
11110959,11110912,1,"<p>Not without significant boiler plate code. Variable names are eliminated at compile-time.</p>

<p>In theory, you <em>could</em> store a map from variable names to a pointer to a variable.</p>
",0
11110965,11110912,1,"<p>No, you can't. If you want indirect access, then declare a pointer and assign <code>var</code> to it.</p>

<pre><code>char *forVar = var;

// Now you can access/modify via [] operator.
</code></pre>
",0
11111967,11110912,0,"<p>So basically you want to log some variables when they are written to/read from/passed to functions etc? </p>

<p>Doing this with compiled C is difficult, as mentioned, especially if you are optimising your executable (-0n on the compile statement), in which case some of the variables can disappear completely, or get re-used by other variables.</p>

<p><strong>Using GDB</strong></p>

<p>Having said that, I know gdb can log variable access and that sort of stuff. If you were to write a python script (see <a href=""http://sourceware.org/gdb/onlinedocs/gdb/Python.html"" rel=""nofollow noreferrer"">http://sourceware.org/gdb/onlinedocs/gdb/Python.html</a>), you should be able to write a script to log variable content.</p>

<p>See this question for more: <a href=""https://stackoverflow.com/questions/6517423/do-specific-action-when-certain-breakpoint-hits-in-gdb"">Do specific action when certain breakpoint hits in gdb</a></p>

<p><strong>On demand only, using pre-compiler scripting</strong></p>

<p>Alternatively, if you just wanted to do it on demand, you'd be better off using a pre-processing script to add in custom macro's or similar, using a csv file as input:</p>

<pre><code>for each line in CSV:
  read variable_name, file_name, variable_type
  find all occurrences of variable_name in file_name
  for each occurrence
    insert printf(....)
</code></pre>

<p><strong>On demand only, using macros</strong></p>

<p>Good luck. There isn't a nice way to do it, because you'd generally need some sort of lookup, and you'd need a way of selectively outputting variables to your print function. In some cases you could do something like:</p>

<pre><code>static char _LOGGED_VAR_001 = 'z';
static char _LOGGED_VAR_002 = 'z';

#define cMyVar           _LOGGED_VAR_001
#define LOG_ALL_VARS()   printf(""Vals: %c, %c"", _LOGGED_VAR_001, _LOGGED_VAR_002)


void myFunc()
{
   char cMyVar; // Gets macro'd to _LOGGED_VAR_001 with LOCAL scope
   cMyVar = 'a'; // LOCAL scope _LOGGED_VAR_001 becomes 'a'
   LOG_ALL_VARS(); // At this point you print out the LOCAL _LOGGED_VAR_001 
                   // and the global _LOGGED_VAR_002
}
</code></pre>

<p>You would get <code>Vals: a, z</code></p>

<p>This is pretty ugly, would only work for variables with local scope, messes round with memory consumption, could be error prone and is generally a <em>bad idea</em>.</p>

<p><strong>On demand, heap/stack dump</strong></p>

<p>If you have enough storage, you could dump all your memory on demand to a file. This probably wouldn't be very portable, depending on how it was done. I'm not sure how to do it though, in a reliable manner.</p>

<p><strong>Recommendation</strong></p>

<p>Use GDB for design-time diagnostics. It's what it's designed for :)</p>

<p>For (e.g.) analysing released code (automated bug reports), a full dump and then analysis at will might be relevant. </p>
",0
12800609,12800584,8,"<p>There is your problem:</p>

<pre><code> printf(""%d\n"", a);
</code></pre>

<p>should be</p>

<pre><code> printf(""%s\n"", a);
</code></pre>
",0
12786419,12786266,0,"<p>You should use <strong>strcmp</strong> instead of ""<strong>!=</strong>"" check the content of the cChoose whether equal ""p"" or not.</p>

<p>cChoose is a pointer which points to the start position of the array in memory. It is definitely not equal to the ""p"" start position in memory, so you get the infinite loop in your program.</p>
",0
12786285,12786266,3,"<pre><code>int cChoose;
...
    cChoose = getchar();
} while( cChoose != 'p' &amp;&amp; cChoose != EOF );
</code></pre>

<p>You seem to like using scanf, probably because it handles whitespace for you.  Instead, try:</p>

<pre><code>int cChoose;
...
    do cChoose = getchar(); while( isspace( cChoose ));
} while( cChoose != 'p' &amp;&amp; cChoose != EOF );
</code></pre>

<p>(Although that's a strange way to write it and is really just another example of using do/while.  It would normally be written:</p>

<pre><code>int cChoose;
...
    while( isspace( cChoose = getchar()))
        ;
} while( cChoose != 'p' &amp;&amp; cChoose != EOF );
</code></pre>
",2
12786286,12786266,1,"<p>The method you should use to compare two strings in C is <code>strcmp</code> as in</p>

<pre><code>while ( strcmp( cChoose, ""p"" ) )
</code></pre>

<p><code>strcmp</code> returns 0 (false) if the strings are identical, or a non-zero value if they differ.</p>

<p>Your statement</p>

<pre><code>while ( cChoose != ""p"" )
</code></pre>

<p>compares the locations of two pointers in memory, one of which, <code>cChoose</code> points to data on the stack and <code>""p""</code> which points to static data. They will never be equal.</p>
",0
12787088,12786266,0,"<p>The statement :</p>

<pre><code>strcmp ( cChoose, ""p"" )
</code></pre>

<p>must be used which returns zero if two strings are equal.
Moreover, if you are using cChoose as a string you must use two characters as the length of cChoose because string is always terminated by a null character - '\0'. So, use :</p>

<pre><code>char cChoose[2];
</code></pre>

<p>EDIT:</p>

<p>The getchar() before the scanf() takes the initial 'p', thus nothing happens first time. Whereas the second time, the getchar() first recieves the '\n' left in the first line and scanf reads the ""p"" properly.
Remove the getchar() and your code would work fine.</p>
",6
13483610,13483526,1,"<p>One mistake is:</p>

<pre><code>int * a,b,c,d,e,f,g,h,i;
*a=137;
*b=80;
*c=78;
</code></pre>

<p>as only <code>a</code> is an <code>int*</code>, the rest of the variables are of type <code>int</code>. To correct either declare on one line (which is more readable and makes this mistake less likely) or place a <code>*</code> before each variable name.</p>

<p>Another mistake (not a compiler error) is the use of <code>buff</code>, which is an unitialised pointer when it is used:</p>

<pre><code>unsigned char* buff;
/* snip ... */
fread(buff,2,1,fd);
</code></pre>

<p>A possible fix is:</p>

<pre><code>unsigned char buff[2]; /* As 2 bytes appears to be required size. */
</code></pre>
",2
13483701,13483526,0,"<p>In addition to hmjd's answer you should consider that an array of a type can be indexed. You don't have to dereference only the first item.</p>

<p>So you can say <code>buff[i]</code> (if, say, declared as <code>unsigned char buff[1024];</code>), where <code>i</code> is a <code>size_t</code> or <code>int</code> that you increment while you go.</p>

<p>In general it makes more sense to - as your initial idea seems to have been - read chunks of data and then only read the next chunk if you run into the end of the first chunk while you are still detecting whether it's a PNG file or not.</p>

<p>So basically you read through the <code>hiberfil.sys</code> until you hit the end of the file in a loop. Within this loop you keep track of a single chunk and perhaps the preceding chunk. Could be done as a ring buffer for example. Then you run the detection code over that chunk (separate function, passing the chunk by reference) and - for example - return the offset into the chunk from your detection function. This way you also know the offset into the <code>hiberfil.sys</code> in case you need this and can then extract the PNG file.</p>

<p>Perhaps also read <a href=""http://home.earthlink.net/~momotuk/pointers.pdf"" rel=""nofollow"">this</a>.</p>
",0
13782861,13782846,7,"<pre><code>char *s;
double val;

s = printn(val);
</code></pre>

<p>At this point, no declaration of <code>printn</code> is in scope. So the compiler, using the old C89 rules, assumes an implcit declaration of <code>printn</code> returning an <code>int</code>.</p>

<p>Declare all functions before you use them.</p>

<pre><code>char *printn(double n);
char *s;
double val;
// ..
s = printn(val);
</code></pre>

<p>That would work.</p>

<pre><code>char *printn(n)
double n;
{
</code></pre>

<p>Please use the modern syntax,</p>

<pre><code>char * printn(double n)
{
    // implementation
</code></pre>
",1
17796936,17796859,1,"<p>The struct rounded to 32-bit (4-byte) chunks.  If you'd added 3 more chars, it would be the same size.</p>
",0
20098420,20098213,0,"<p>It's freed, but data still remains after calling free, so you just accessing deleted data by printing list after delete. (which you mustn't do actually)
Also, if you want to set 'liste' pointer to NULL inside free-function, you should pass pointer to a pointer. The following code in unmokli is useless:</p>

<pre><code>free(lst); // Already freed in a loop before
lst = NULL; // Takes effect only inside this function
</code></pre>
",0
20098342,20098213,1,"<p>When you do</p>

<pre><code>lst = NULL;
</code></pre>

<p>in the function <code>unmokli</code> you are only making <em>the local copy</em> <code>lst</code> <code>NULL</code>. Remember that arguments are passed by value, i.e. they are copied. You need to pass <code>lst</code> by reference, which can be done by passing a pointer (to the pointer):</p>

<pre><code>void unmokli(ListEle **lst)
{
    ...
    *lst = NULL;
    ...
}
</code></pre>

<p>You then call this by using the address-of operator:</p>

<pre><code>unmokli(&amp;liste);
</code></pre>
",3
20098354,20098213,0,"<p>Either pass reference of <code>liste</code> to <code>unmokli()</code> or take return parameter from it as you have done in <code>mokli()</code>.</p>

<p>In your case, its getting freed, but variable <code>liste</code> in <code>main()</code> is not set to <code>NULL</code> and still references old memory. This is may cause you crash.</p>

<p>Update your code as</p>

<pre><code>void unmokli(ListEle **lst_ref)
{   
    ListEle *lst = *lst_ref;

    ...
    //your code freeing list

   //set to null after freeing
   *lst_ref = NULL;
}
</code></pre>

<p>From <code>main()</code> call it as</p>

<pre><code>unmokli(&amp;liste);
</code></pre>
",0
20098773,20098213,0,"<p>Typically, I would free (&amp; NULL assign) the linked list as below:</p>

<pre><code>void unmokli(ListEle **lst)
{
    ListEle* nxt;
    if(lst==NULL) return;
    // printList(*lst); // not required by the free-list logic as such...
    while(*lst)
    {
        nxt=(*lst)-&gt;next;
        // printList(*lst); // not required by the free-list logic as such... You can test free code with this.
        free(*lst);
        *lst=nxt;
    }
}

//usage
unmokli(&amp;list_head);
</code></pre>
",0
14226936,14224802,0,"<p>Your function definition should be like</p>

<pre><code>void foo (myStruct *StructArrayAddress, int index)
{
     myStruct x;
     x.a = 1;
     x.b = 2;
     strncpy(x.c, ""Test"", 9);

     /* Now copy this struct to the array of structs at index specified by second argument */

     memcpy((StructArrayAddress + index), &amp;x, sizeof(myStruct));


}
</code></pre>
",3
11174884,11174766,1,"<p>You are assigning the pointer  to structure <code>d</code>  when you do <code>novo-&gt;prato[i]  = d</code> ,
 so each time you make a change to <code>d</code> it would be reflected at <code>novo-&gt;prato[i]</code> since all values in prato array is pointing to the same address i.e. <code>d</code>.</p>

<p>I'm not exactly sure what you intend to do but one way could be  to malloc <code>d</code> every time in loop before asking the user for input. Remember you also need to look into 'freeing' the memory <code>prato[i]</code> eventually.</p>
",0
12286593,12286565,0,"<p>A pointer to structure points to a <em>structure</em>, so the adress of an element still available.</p>

<pre><code>f(&amp;ptrudp-&gt;rules[n]);
</code></pre>
",0
12286600,12286565,5,"<blockquote>
  <p>Is it possible to print the address of the rule[0] or as a matter of
  fact any i.e rule[n]</p>
</blockquote>

<p>Yes, it's possible:</p>

<pre><code>printf(""%p\n"", (void *) &amp;ptrudp-&gt;rules[i]); /* Cast required by %p. */
</code></pre>

<p>The same way you can pass a pointer to <code>rules[i]</code> to your function.</p>
",0
12286756,12286565,0,"<p>Yes. You access it as you would normally do with any other array, just grab it from the structure using the <code>-&gt;</code> operator:</p>

<pre><code>transrules *addr = &amp;ptrudp-&gt;rules[n];
</code></pre>
",0
13776805,13776321,0,"<p>Basically as is written here: <a href=""https://stackoverflow.com/a/1897232/1430586"">https://stackoverflow.com/a/1897232/1430586</a>
you need to add this after the printf:</p>

<pre><code>fflush(stdout);
</code></pre>

<p>This is only required for Eclipse, if you were to run the executable file directly it would probably work without this.</p>

<p>Another thing i can think of, if the program terminates as soon as you run it</p>
",0
18446726,18446693,0,"<p>It's a C source file, it is not supposed to be run like this, you have to compile it first.</p>

<p>This would do:</p>

<pre><code>make ex1 # Implicit rule which in turn will perform cc -o ex1 ex1.c
./ex1
</code></pre>
",4
18446733,18446693,14,"<p>You need to compile it first, probably by doing <code>gcc -o ex1 ex1.c</code>.<br>
After compiling it, you will have an executable called <code>ex1</code>, which you can run by doing <code>./ex1</code>.
If you receive another <code>permission denied</code> error, you can make it executable by doing <code>chmod +x ex1</code>.</p>
",2
18446743,18446693,2,"<p>You can't just run a file with C code. You'll have to first compile it. If you have a <code>gcc</code> compiler available, that's going to be:</p>

<pre><code>gcc -o ex1 ex.c
./ex1
</code></pre>
",0
12259781,12259689,1,"<p>Macrofunctions cannot perform typecheck. If you want to operate on operands of a specified type (and force compilers warnings if the arguments have incompatible type), you have to use a function (maybe <code>inline</code> if you think about performances).</p>

<p>Your method is pleasing, but braced-groups with expressions are a gcc extension (not standard), so a standard compiler can't evaluate your macrofunction as an expression, which have a certain value. </p>

<p>Besides, you have a space after your <code>\</code> character, which cause syntax error.</p>

<pre><code>/* GCC-compatible */
#define min(t, x, y) ({ \
    t __tmp1 = (x); \
    t __tmp2 = (y); \
    __tmp1 &lt; __tmp2 ? __tmp1 : __tmp2; \
})
</code></pre>
",0
12260024,12259689,2,"<p>If you're using <a href=""http://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html#Statement-Exprs"" rel=""nofollow"">gcc statement expressions</a>, then you can also use the gcc <a href=""http://gcc.gnu.org/onlinedocs/gcc/Typeof.html#Typeof"" rel=""nofollow"">extension keyword <code>typeof</code></a> (or <code>__typeof__</code>):</p>

<pre><code>      #define min(x,y)  ( {                                \ 
              typeof(x) __tmp1 = (x);                      \
              typeof(y) __tmp2 = (y);                      \
              __tmp1 &lt; __tmp2 ? __tmp1 : __tmp2; } )
</code></pre>

<p>C11 introduces type-generic expressions using the <code>_Generic</code> keyword:</p>

<pre><code>int min_int(int x, int y) { return x &lt; y ? x : y; }
long min_long(long x, long y) { return x &lt; y ? x : y; }
#define min(x,y) _Generic((x + y),                        \
                          int: min_int,                   \
                          long: min_long)(x, y)
</code></pre>

<p>Given that you're willing to write the type in the macro invocation, you could use:</p>

<pre><code>int min_int(int x, int y) { return x &lt; y ? x : y; }
long min_long(long x, long y) { return x &lt; y ? x : y; }
#define min(type,x,y) min_ ## type(x, y)
</code></pre>

<p>This is the only syntax that is valid in legacy versions of C.</p>
",4
12260448,12259689,3,"<p>Of course your macro can be independent of type specifier, this is one of the things that makes macros so powerful. You can either:</p>

<ol>
<li>Pass the variable name and the type and let the macro deal with the type.</li>
<li>Pass the variable name <em>without</em> the type and assume that the macro performs legal operations on that variable, regardless of the type.</li>
</ol>

<p>Your actual problem is that in the first form you expect your macro to return an expression, but inside it you declare variables and what-not. I believe that because of that, you put the curly braces in the macro, and now it expands to: <code>({ bla bla })</code>, which would give you the following error message in ISO C99:</p>

<blockquote>
  <p><code>ISO C forbids braced-groups within expressions</code></p>
</blockquote>

<p>Unfortunately, in ISO C99 you can't both have an expression AND declare temporary variables inside it. This is what functions are made for.</p>

<p>So either use the second form that you described, that is pass the ""result"" variable to the macro:</p>

<pre><code>#define min(type_, x_, y_, result_)                    \
    do {                                               \
        type_ __tmp1 = (x_);                           \
        type_ __tmp2 = (y_);                           \
        result_ = (__tmp1 &lt; __tmp2 ? __tmp1 : __tmp2); \
    } while(0)
</code></pre>

<p>or use an inline function instead.</p>

<p>P.S:<br/>
Also, <a href=""https://stackoverflow.com/questions/154136/why-are-there-sometimes-meaningless-do-while-and-if-else-statements-in-c-c-mac"">this</a> and <a href=""https://stackoverflow.com/questions/1067226/c-multi-line-macro-do-while0-vs-scope-block"">this</a> are worth reading for good practices when writing C macros.</p>
",6
12268603,12259689,0,"<p>Since all solutions seem to require specifying type, you might as well call a specific macro to do the comparison. You can also generalize to just two macros and use the largest type for each of signed/unsigned:</p>

<pre><code>#define smin(x_, y_, result_)                     \
  do {                                            \
    int64_t __tmp1 = (x_);                        \
    int64_t __tmp2 = (y_);                        \
    result_ = __tmp1 &lt; __tmp2 ? __tmp1 : __tmp2;  \
  } while(0)
#define umin(x_, y_, result_)                     \
  do {                                            \
    uint64_t __tmp1 = (x_);                       \
    uint64_t __tmp2 = (y_);                       \
    result_ = __tmp1 &lt; __tmp2 ? __tmp1 : __tmp2;  \
  } while(0)
</code></pre>

<p>Be sure to only compare types of the same signage.</p>
",1
11491293,11491281,1,"<p><code>outname</code> is a string literal and string literals are not modifiable. Modifying a string literal is undefined behavior.</p>
",0
11491307,11491281,1,"<p>At least two errors:</p>

<pre><code>char tab[2] = {""12""};
</code></pre>

<p>You'd better use <code>tab[3]</code> or even better <code>tab[]</code> -- you need one extra char for the terminating NUL character.</p>

<p>Also,</p>

<pre><code>char *outname = ""etc..."";
</code></pre>

<p>creates a constant string in the data segment of the executable -- it can't be overwritten, since <code>strcat</code> is using its first parameter to concatenate the two strings. So when <code>strcat()</code> tries to do so, it segfaults. Use</p>

<pre><code>char outname[50]; // something big enough
strcpy(outname, ""/home/dir"");
</code></pre>

<p>instead.</p>
",3
11491309,11491281,0,"<p><strong>outname</strong> is <strong>Const pointer</strong> so once you have entered some thing in it, you <strong>can't modify</strong> it. </p>

<p>However if you want to copy things in it, make a char array of the size equal to tab[] array because here the size of string to be copied is known. Most of the time char pointers like OUTNAME are used when you are taking input from a user once and you don't know how long that input will be.</p>
",0
12347435,12347397,3,"<p>That's undefined behavior; there is no object behind that pointer -- the result could be anything. Undefined behavior can <em>appear</em> to work, or it can fail in very mysterious ways.</p>

<p>You could approach it like this:</p>

<pre><code>thing th;
thing* s = &amp;th;
...now 's' points to a 'thing' -- specifically, 'th'.
</code></pre>
",0
18416748,18416733,9,"<p>It is possible to change it but the behavior is undefined, as its mentioned in the standard!</p>

<p>Its in c11 under 6.7.3</p>

<blockquote>
  <p>If an attempt is made to modify an object defined with a const-qualified type through use of an lvalue with non-const-qualified type, the behavior is undefined. If an attempt is made to refer to an object defined with a volatile-qualified type through use of an lvalue with non-volatile-qualified type, the behavior is undefined.</p>
</blockquote>
",1
18416757,18416733,3,"<pre><code>int * const p=&amp;x;
</code></pre>

<p>This is not a valid program. <code>&amp;x</code> is of type <code>const int *</code> but you are assigning the pointer value to an object of type <code>int * const</code>: the compiler has to issue a warning and is allowed to stop compilation.</p>
",0
13473734,13473693,7,"<p>It's because <code>scanf</code> will leave a <code>'\n'</code> (endline) symbol in the input buffer. This symbol will be consumed by <code>getchar</code> at the first iteration of this <code>while(1)</code> loop.</p>
",1
13473767,13473693,4,"<p><code>getchar()</code> leaves a newline character in the input buffer which is read by the subsequent scanf().</p>

<p>You can use solve this by using a leading space in the scanf:</p>

<pre><code>scanf("" %c ..."", &amp;c,..);
</code></pre>

<p>which tells the scanf to ignore all whitespace characters. Or use another <code>getchar()</code> right after the first getchar() to consume the newline.</p>
",2
13486603,13486561,4,"<p>Because you aren't assigning the result of your left shift to anything.  The shift operators aren't like <code>++</code> and <code>--</code> they don't automatically update their argument.</p>

<p>Change your shift lines to </p>

<pre><code>l = l &lt;&lt; 8;
</code></pre>
",0
20655709,20655579,1,"<pre><code>int main()
{
 char *p = ""12345"";
     // or with non string data. -&gt; char p[5] = { 0x00, 0x56, 0x2C, 0x7a, 0x88 };
 int i;

 for(i = 0; i &lt; 5; i++)
     printf(""%02x "", p[i]);

 printf(""\n"");

 return 0;
}
</code></pre>
",0
20655908,20655579,0,"<p>Use</p>

<pre><code>for (i=0; i&lt;sizeof(my_array);i++)
    printf(""%hhx"", (unsigned char) my_array[i])
</code></pre>

<p>where 'hh' means unsigned char, and 'x' means hexadecimal, in '%hhx' expression.</p>

<p>source:
<a href=""http://www.cplusplus.com/reference/cstdio/printf/"" rel=""nofollow"">http://www.cplusplus.com/reference/cstdio/printf/</a></p>
",0
13444627,13444617,3,"<p>Wowwww I keep figuring out the answers after I post the question. I simply put a '*' before the totalinput variable in the journal function and it called properly...</p>
",1
13444722,13444617,0,"<p>Call your function with by reference pointer</p>
",0
18461292,18461067,2,"<p>Try this:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    int c, blank, tab, lines;
    int till = 0;
    blank = tab = lines = 0;
    while(till == 0)
    {
        c = getchar();
        switch(c)
        {
        case ' ' :
            blank++;
            break;
        case '\t' :
            tab++;
                    break;
        case '\n' :
            lines++;
            break;
        case EOF :
            till = 1;
            break;
        }
    }
    printf(""Blanks :%d Tab :%d Lines :%d\n"", blank, tab, lines);

    return 0;
}
</code></pre>
",0
18461139,18461067,10,"<p>You have one small mistake in the EOF case - you need to change:</p>

<pre><code>case 'EOF':
</code></pre>

<p>to:</p>

<pre><code>case EOF:
</code></pre>

<p>After that change the code should compile and run, but in order for it to run correctly you will need to add a <code>break;</code> line at the end of each case.</p>
",0
18461159,18461067,1,"<p>You are using 'EOF' to represent End of file. The actual representation is EOF constant</p>

<pre><code>case EOF : /* warning: multi-character character constant [-Wmultichar] */
  till = 1;
}
</code></pre>

<p>its defined in stdio.h</p>
",0
18461160,18461067,2,"<p>Change:</p>

<pre><code>case 'EOF':
</code></pre>

<p>to:</p>

<pre><code>case EOF:
</code></pre>

<p>And add <code>break;</code> after each case.</p>
",0
18461171,18461067,0,"<p>There is no character symbol <code>'EOF'</code>. In standard C library the <code>EOF</code> is a predefined constant. It's value varies between systems. So, in your case, you should change <code>EOF</code> comparison part to something like this:</p>

<pre><code>...
case EOF:
        till = 1;
}
</code></pre>
",0
18461225,18461067,1,"<p>You could also do the following thing:</p>

<pre><code>while ((c = getchar()) != EOF)
{
    switch (c)
    {
        /* case ' ', '\t', '\n' */
    }
}
</code></pre>

<p><code>EOF</code> is a macro definition of type <code>int</code>.</p>
",0
19447013,19446888,20,"<p>I think the OP is not confused about the ternary operator its a different problem.</p>

<p>From the C99 standard, section 6.3.1.8 (""Usual arithmetic conversions""):</p>

<blockquote>
  <p>if the operand that has unsigned integer type has rank greater or
  equal to the rank of the type of the other operand, then the operand
  with signed integer type is converted to the type of the operand with
  unsigned integer type.</p>
</blockquote>

<p><code>unsigned int</code> and <code>int</code> has the same rank, so it's equivalent to:</p>

<pre><code>(a + (unsigned int)b &gt; 6)
</code></pre>

<p>To fix it, you need to explicitly cast in the other direction, i.e.:</p>

<pre><code>((int)a + b &gt; 6)
</code></pre>

<p>So this is the reason the output <strong>will be</strong> <code>&gt;6</code> and <strong>NOT</strong> <code>&lt;=6</code></p>
",0
19447016,19446888,9,"<p>The other two answer accurately describe Ternary operator, but I think this is more relevant to the question</p>

<p>The output is <code>&gt;6</code> because <code>(a + b)</code> <strong>casts <code>b</code> to unsigned int as well</strong>. </p>

<p>EDIT:</p>

<p>See Acme's suggestion for fixing this problem. Essentially <strong>casting <code>a</code> as an <code>int</code></strong> will fix this</p>
",0
19447035,19446888,5,"<p>the simple form of you code is as follow:</p>

<pre><code>if(a + (unsigned int)b &gt; 6)
{
    puts(""&gt;6"")
}
else
{
    puts(""&lt;=6"");
}
</code></pre>

<p>Output will be :</p>

<pre><code>&gt;6 as (a + (unsigned int)b &gt; 6)
</code></pre>
",0
19447077,19446888,5,"<p>Because <code>4294967282&gt;6</code> is true you will get <code>&gt;6</code> as output. <code>4294967282</code> is coming from assigning <code>-14</code> to a <code>unsigned int</code>. <code>(a+b)</code> will be converted as <code>2^32 - 14</code>.
`</p>
",0
14199339,14199250,6,"<p>If you want to test the N<sup>th</sup> bit of a byte (N = 0..7 for normal 8-bit bytes), you can use:</p>

<pre><code>if (byte &amp; (1 &lt;&lt; N))
    ...Nth bit is set...
</code></pre>

<p>The test condition simply checks whether the expression is 0 (false) or non-zero (true).  You could make that explicit with:</p>

<pre><code>if ((byte &amp; (1 &lt;&lt; N)) != 0)
    ...Nth bit is set...
</code></pre>

<p>You can set the N<sup>th</sup> bit with:</p>

<pre><code>byte |= 1 &lt;&lt; N;
</code></pre>

<p>You can reset (zero) the N<sup>th</sup> bit with:</p>

<pre><code>byte &amp;= ~(1 &lt;&lt; N);
</code></pre>

<p>You can flip or toggle the N<sup>th</sup> bit with:</p>

<pre><code>byte ^= (1 &lt;&lt; N);
</code></pre>

<p>Although I've used the name <code>byte</code> throughout, you can do this with any bit of any of the integer types as long as your shift is in the correct range.</p>
",0
14199423,14199250,1,"<p>It works like this:</p>

<p>First to note is the value 0 is false in C test, and any other value is considered true.</p>

<p>Then, to test if a certain bit is set or not, use tests like the following(one of the set of macros I made a few years ago)</p>

<p><code>#define IS_SET(number, position) (number &amp; (1 &lt;&lt; position))</code></p>

<p>then you can use it like this:</p>

<p><code>if(IS_SET(15,2)){ }</code>. Note however, that the bit count starts from right most bit and moves towards left, counting from <code>0</code> for the right most bit. </p>

<p>The following is how the macro actually works(and note, this works for all integer types, 8 bit, 16 bit, 32 bit etc)
The number <code>15</code> in bitwise is <code>0x0F = 0000 0000 0000 0000 0000 00000 1111 1111</code> on a 32 bit machine.</p>

<p>Left shifting <code>1</code> 2 times, yeilds <code>0000 0000 0000 0000 0000 0000 0000 0100</code></p>

<p>ANDing the two numbers yeilds:</p>

<pre><code>0000 0000 0000 0000 0000 0000 1111 1111
0000 0000 0000 0000 0000 0000 0000 0100 &amp;
------------------------------------------
0000 0000 0000 0000 0000 0000 0000 0100 (which is not 0, hence true)
------------------------------------------
</code></pre>

<p>This way you can test for any position in the bit sequence to be set or cleared.</p>
",4
13398232,13398205,1,"<p>The pinconf array stores ulong (unsigned long).</p>

<p>With <code>volatile ulong *pinconf;</code> you define a pointer to a ulong. It points to the first element of the array. It is volatile, meaning it may be changed by an outside ""event"" and won't be cached. It workes linke any array in C.</p>

<p>In this case, it is mapped to a file/device with a file descriptor fd.</p>
",0
13398268,13398205,2,"<p>pinconf is a memory mapped file/device. Looking at your linked code, fd is a descriptor for the newly opened /dev/mem. So whatever you write into the pinconf array is actually writing direct to /dev/mem at whatever offset you use in the array. I'm assuming this is how this code is ""talking"" to the GPIO hardware. Without the memory map for the GPIO device it's hard to know what happens at the addresses that are being written to.</p>

<p>See what /<a href=""http://linux.die.net/man/4/mem"" rel=""nofollow"">dev/mem</a> is.</p>

<p>And read up about memory mapped i/o, which is what this is doing (sort of), see: <a href=""http://www.kernel.org/doc/htmldocs/uio-howto.html#userspace_driver"" rel=""nofollow"">http://www.kernel.org/doc/htmldocs/uio-howto.html#userspace_driver</a></p>
",0
13398357,13398205,2,"<p>Based on the title of your question, I think you¡¯re confused about the hex notation in accessing the array.</p>

<p>hex is just another way of writing numbers, don't let it throw you too much. I could write:</p>

<pre><code>int a = 0xA;
</code></pre>

<p>or</p>

<pre><code>int a = 10;
</code></pre>

<p>And they mean the same thing. So in this case:</p>

<pre><code>pinconf[0x2168/4] = 0x001C001C;
</code></pre>

<p>Is just:</p>

<pre><code>pinconf[8552/4] = 1835036;
</code></pre>

<p>The latter is actually more confusing because pinconf is storing an address which are typically written in hex using 4 (or 8) bytes, hence the <code>00</code> proceeding the rest of the number (<code>1C001C</code>)</p>
",0
13419881,13398205,2,"<p>I'm the original blog/code author, here's what I meant:</p>

<p>To answer your main point, pinconf[0x2168/4] refers to the address 0x48002168. The pinconf array starts at the address 0x48000000. It's been defined as a ulong [1], which on ARM processors is 4 bytes. I know I want to access the address pinconf+0x2168. To convert the address 0x2168 into an index in pinconf I need to divide by 4.</p>

<hr>

<p>Walking through the code from the start:</p>

<pre><code>volatile ulong *pinconf;
</code></pre>

<p>pinconf is defined as a ulong (32bit int) pointer. It's defined as volatile, this means that something outside of our code may change its value. It tells the compiler that every time we use that value we need to read it from memory, this stops the compiler doing clever optimisations that may screw things up.</p>

<pre><code>pinconf = (ulong*) mmap(NULL, 0x10000, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0x48000000);
</code></pre>

<p>This sets pinconf to point to the address 0x48000000. Normally you could do something like:</p>

<pre><code>pinconf = (ulong*) 0x48000000;
</code></pre>

<p>To make pinconf point to an address, but this won't work. 0x48000000 is a protected address, it's only accessible by the kernel. The mmap magic gives you a way to access the address from userspace.</p>

<pre><code>pinconf[0x2168/4] = 0x001C001C;
</code></pre>

<p>We've covered this already, but this is writing a value to the address: 0x48000000+0x2168. The value 0x48002168 comes from the OMAP3 datasheets, and is used to do memory mapped IO with the GPIO system. We divide by 4 to convert the address 0x2168 to an index in pinconf.</p>

<p>[1] I should probably have used a uint32_t to be honest.</p>
",0
13447182,13447088,0,"<p>Please <em>don't</em> increment <code>fp</code>.  It does not do what you think it does.</p>

<p>If you want to do this with minimal help from existing C functions, simply search through your line for a space (okay, I used <code>isspace</code> and <code>atoi</code> here):</p>

<pre><code>int pos = 0;
while( line[pos] != 0 &amp;&amp; !isspace(line[pos]) ) pos++;
if( line[pos] != 0 ) {
    line[pos++] = 0;
    value[count] = atoi( &amp;line[pos] );
    printf( ""Key: '%s' / Value: %d\n"", line, value[count] );
}
</code></pre>

<p>Or you could use <code>sscanf</code>...</p>

<pre><code>int nread = sscanf( line, ""%*s %d"", &amp;value[count] );
</code></pre>

<p>Or:</p>

<pre><code>char key[100];
int nread = sscanf( line, ""%s %d"", key, &amp;value[count] );
</code></pre>
",0
13447264,13447088,0,"<pre><code>void function()
 {
    int count=0,value[4],length=0;

    FILE *fp;

    fp = fopen(""file.txt"",""r"");

    if (fp == NULL)
    {
      fprintf(stderr, ""Can't open file !\n"");
      exit(1);  
    }

     char line[100];
        for (count = 0; count &lt; 4; count++)
        {      
            if (fgets(line,sizeof(line),fp)==NULL)
                break;

          else 
            {  
              sscanf(line,""%*s %d"",&amp;value[count]);
            }
      } 
</code></pre>

<p>I have modify the code ,you can try it.</p>
",2
15573713,15572625,0,"<p>Another method is to try calling opendir() on the d_name and seeing if it returns null:</p>

<pre><code>int isDir(struct dirent *ent)
{
    if (ent &amp;&amp; strcmp(ent-&gt;d_name, ""."") &amp;&amp; strcmp(ent-&gt;d_name, "".."")) // don't include pwd and parent dir
    {
        DIR *isDir = opendir(ent-&gt;d_name);
        if (isDir)
            return 1;
    }
    return 0;
}
</code></pre>
",2
15572626,15572625,2,"<p>That's what <code>S_ISREG()</code> and <code>S_ISDIR()</code> are for when used together with <code>stat(2)</code>. See its man page for details.</p>

<p>If you can live with not being completely POSIX compliant, you can use <code>DT_REG()</code> and <code>DT_DIR()</code> to check for directoryness versus regularness, respectively. This is mentioned in the man page for <code>readdir(3)</code>.</p>
",6
12814822,12814649,1,"<p>For windows:</p>

<blockquote>
  <p>Because the SetKeyboardState function alters the input state of the calling thread and not the global input state of the system, an application cannot use SetKeyboardState to set the NUM LOCK, CAPS LOCK, or SCROLL LOCK (or the Japanese KANA) indicator lights on the keyboard. These can be set or cleared using SendInput to simulate keystrokes.</p>
</blockquote>

<p>See <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/ms646314%28v=vs.85%29.aspx"" rel=""nofollow"">Windows API ref</a></p>
",0
12814902,12814649,2,"<p>For Linux, this would be helpful</p>

<p><a href=""http://linux.die.net/man/1/setleds"" rel=""nofollow"">setleds</a></p>

<p>A more comprehensive internals and several command line utilities description</p>

<p><a href=""http://www.tldp.org/HOWTO/pdf/Keyboard-and-Console-HOWTO.pdf"" rel=""nofollow"">Keyboard and console - HowTo.pdf</a></p>
",0
19379682,19379512,0,"<p>Using a debugger:</p>

<pre><code>Starting program: /home/david/demo 
Enter number of test cases
2
10

Program received signal SIGFPE, Arithmetic exception.
0x000000000040076d in main () at demo.c:26
26              if (num % num1 == 0)
(gdb) p num1
$1 = 0
(gdb) 
</code></pre>

<p>As you can see, the value of <code>num1</code> is 0, division by 0</p>
",0
19379638,19379512,1,"<pre><code>    while (num1 &gt; 0)
    {
        n = num1 % 10;
        num1 = num1 / 10;
        if (n == 3 || n == 5 || n == 6)
            count++;
    }
    if (num % num1 == 0)
</code></pre>

<p>You rolling loop unless num1 becomes 0, then dividing by zero. Division by zero is guaranteed SIGFPE (at least on x86 and amd64). Despite name, it have nothing to do with floating point numbers.</p>
",2
19379646,19379512,0,"<p>Print the value of num1 before % operation, it gets 0 and then you exception of division by 0</p>
",0
13472858,13472830,1,"<pre><code>*(s1++); /* go to the end of string1*/
</code></pre>

<p>That increments the <code>char**</code>, and the dereference operation does nothing there. You want to increment the pointed-to <code>char*</code>, so you'd need</p>

<pre><code>(*s1)++;
</code></pre>

<p>(similar for <code>s2</code>.)</p>

<p>However, you probably don't really want to change the pointer in the caller, so you should use a temporary variable</p>

<pre><code>char *temp = *s1;
</code></pre>

<p>and increment that to find the end of the first string, or, better pass a <code>char*</code> in the first place.</p>

<p>And of course, you should only call it with pointers to actual 0-terminated strings.</p>
",3
13472859,13472830,1,"<p>Your code has an <strong>Undefined Behavior</strong>.<br>
You are writing to a pointer which does not point to valid memory. <code>str</code> does not point to any valid memory it points to <code>NULL</code>.</p>

<p>It is your responsibility that <code>str</code> points to a valid and large enough memory to hold the contents you are copying to it, if not the result is an Undefined Behavior and a non-standard conforming program which means anything behavior is possible.</p>
",0
13472883,13472830,2,"<p>Your function assumes that <code>s2</code> can be appended at the end of <code>s1</code>. So <code>s1</code> should be big enough to accommodate <code>s2</code>.</p>

<p>You are passing <code>s1</code> as NULL and de-referencing a NULL pointer, which is undefined behavior.</p>

<p>Also there is really no need to pass the address of a character pointer in your case.</p>
",2
13473120,13472830,1,"<p>This is what I have. </p>

<pre><code>  char * strcat (char *dest, const char *src)
{
    char *dp;
    char *sp = (char *)src;

    if ((dest != NULL) &amp;&amp; (src != NULL))
    {
        dp = &amp;dest[strlen(dest)];

        while (*sp != '\0')
        {
            *dp++ = *sp++;
        }
        *dp = '\0';
    }
    return dest;
}
</code></pre>
",2
13780261,13780218,0,"<p>Try this:</p>

<pre><code>do {

   /* Read from input and store it in data */

} while( !isdigit(data) || !( data &gt; 1 &amp;&amp; data &lt; 25 ) );
</code></pre>
",1
16453543,16453487,1,"<p>Depending on the kind of sort you'll implement, you'll likely want random access to the elements in your collection.  With that in mind, an array is indeed a better choice.</p>

<p>I'll go ahead and guess this is a school/learning project (or else you'd be using pre-existing sort functions, wouldn't you), so the sorting algorithm you choose will have an impact on this decision.</p>

<p>Typically, the fastest sort is quicksort (or mergesort), which benefits from random access (therefore arrays).  Your idea about swapping is good too.  Usually you want to sort in place and avoid allocating extra memory.</p>
",1
16453550,16453487,10,"<p>It depends heavily on your sorting algorithm and what you are sorting.  The cost of traversing a linked list is certainly higher than indexing an element in an array.  However, if your sorting algorithm involves shifting elements, this can be done in constant time in a linked list (whereas in an array it must be done element by element, copying each one).  Swapping elements in a linked list is also constant time (just change the pointers), whereas in an array it will be copying elements (maybe also constant time, depending on your data).</p>

<p>For a set of integers you want to sort using quicksort, it's probably faster to use an array; for a set of large structures you want to sort using selection sort, a linked list will be faster.</p>

<p>Then, there is the question of how you access elements.  If your intention in sorting was to access the elements later on by binary search, you'd definitely want to use an array (as binary search is usually slower than linear search on linked lists, unless the linked list is something like a balanced B-tree).</p>
",1
16453580,16453487,-1,"<p>I wouldn't necessarily recommend this method (depends on what you are doing) but you can sort as you go with a linked-list tree if you know the sorting criteria.</p>

<p>Say it is numbers:</p>

<pre><code>struct treeNode {
  struct treeNode* greater;
  struct treeNode* lesser;
  int myValue;
};
</code></pre>

<p>It is probably the most difficult to create an algorithm for (you will have to push nodes when certain intermediate values occur)... Depends how much you like to use recursion and helper functions.</p>
",8
15892918,15886876,3,"<p>Are you working on linux or windows? Based on that, there are alternatives that can be used.
If you are working on windows, a function should be familiar to you : kbhit()? Though it is now deprecated, the working knowledge of it could be useful :)
Assuming that you are working on linux, have you tried NCurses?</p>

<p>Taken from [Here]: (<a href=""http://www.linuxmisc.com/9-unix-programmer/d5b30f8d1faf8d82.htm"" rel=""nofollow"">http://www.linuxmisc.com/9-unix-programmer/d5b30f8d1faf8d82.htm</a>)</p>

<p>The problem is three-fold: </p>

<ol>
<li>You have to check if data is available without blocking. A simple
'read' or fgets' or whatever will block your process until data is
available -- you don't want that.  </li>
<li>You have to bypass any buffering
because otherwise you would have to   check both the buffer and the
device. </li>
<li>You need to coerce the terminal driver to give you data as
it's   available rather than accumulating the whole thing into a
line.</li>
</ol>

<p>From the same page: </p>

<p>That said, I present the following awkward, hastily-written, 
uncommented code, which may be instructive or may not ( edited in part by me, was missing parenthesis and not indented)</p>

<pre><code>#include &lt;stdio.h&gt; 
#include &lt;termios.h&gt; 
#include &lt;unistd.h&gt; 
#include &lt;sys/time.h&gt; 
#include &lt;sys/types.h&gt; 

static struct termios orig_term; 
void u_cleanup(void) 
{ 
    tcsetattr(0, TCSANOW, &amp;orig_term); 
}
int u_kbhit(void) 
{ 
    struct termios t; 
    int ret; 
    fd_set rfd; 
    struct timeval to; 
    static int first_hit=0; 
    if(first_hit==0) 
    { 
        if(tcgetattr(0, &amp;t)!=0) exit(0); 
        orig_term=t; 
        cfmakeraw(&amp;t); 
        if(tcsetattr(0, TCSANOW, &amp;t)!=0) exit(0); 
        atexit(u_cleanup); 
        first_hit=1; 
    } 

    FD_ZERO(&amp;rfd); 
    FD_SET(0, &amp;rfd); 
    to.tv_sec=0; 
    to.tv_usec=0; 
    if(select(1, &amp;rfd, NULL, NULL, &amp;to)==1) return 1; 
    return 0; 
}
int u_getchar(void) 
{ 
    int ret; 
    fd_set rfc; 
    unsigned char buf; 
    if(read(0, &amp;buf, 1)!=1) ret=0; 
    else ret=buf; 
    return ret; 
}

int main(void) 
{ 
    while(1) 
    { 
        if(u_kbhit()) 
        { 
            int key=u_getchar(); 
            printf(""hit: %d\r\n"", key); 
            if(key==3) 
            { 
                printf(""you hit control-c\r\n""); 
                exit(0);                         
            }         
        } 
        usleep(100); 
    }
    return 0; // inaccessible code, to prevent compiler warning
 }
</code></pre>
",0
16454138,16453992,3,"<p>You need to make sure to allocate some space for the results.  It appears from your example that type, type2, and type3 are all null.  You need to point them at some storage on the heap or stack, like:</p>

<p>char type[64];</p>

<p>however be wary of buffer overflow here.  See <a href=""https://stackoverflow.com/questions/1621394/how-to-prevent-scanf-causing-a-buffer-overflow-in-c"">this other question</a> for advice on how to avoid that.</p>
",0
16454199,16453992,0,"<p>Change the <code>fscanf()</code> statement to this.It works.But make sure <code>file</code> is of type <code>FILE*</code>.Else if it is a string,you have to use <code>sscanf()</code>:</p>

<pre><code>fscanf(file, ""%[^|]%*c%[^|]%*c%s"", type, type2, type3);

//sscanf(file, ""%[^|]%*c%[^|]%*c%s"", type, type2, type3);


//Demo for the sscanf() case


#include&lt;stdio.h&gt;

int main()
{
char *file=""fruit|apple|lemon"",type[10],type2[10],type3[10];

sscanf(file, ""%[^|]%*c%[^|]%*c%s"", type, type2, type3);
printf(""%s,%s,%s"",type,type2,type3);
}
</code></pre>

<p><strong>Output</strong> <code>fruit,apple,lemon</code></p>
",0
16454541,16454339,0,"<p>if you want to put the string read by the <code>fscanf()</code> starting from the element 1 of your array then you can use the following code:</p>

<pre><code>fscanf(file2, ""%18s"", string+1);
</code></pre>

<p><code>string</code> is an array object and not a pointer so you could not use the operation <code>string++</code> 
for an array object. because this is equivalent to :</p>

<pre><code>string = string + 1;
</code></pre>

<p>Here you are assigning to the array object a new value which is not allowed in C.</p>

<p>What you can do to access to your string array from the element 1 is to use <code>string + 1</code> (without assigning it to the string array). <code>string + 1</code> return a pointer to  the element 1 of your <code>string</code> array</p>
",0
12261163,12261110,3,"<p>It works as expected for me:</p>

<pre><code>calloc successful
realloc successful
*** glibc detected *** double free or corruption
</code></pre>

<p>The code looks fine, assuming the double free was intentional. Don't call <code>free(ptr)</code> since you've already released it by reallocating it.</p>
",0
12261249,12261110,1,"<p>This works for me when I compile it.
You have one bug though which is that you are calling ""free(ptr)"" when the memory pointed to by ptr is no longer valid as you realloced it. It maybe the same as retval though too in which case you are freeing it twice.</p>
",0
12844811,12844778,1,"<p>It is starting from the left, and multiplying by 10 for each successive digit it encounters as it moves to the right.</p>

<p>Take the string ""234"" for example:</p>

<ol>
<li>On the first iteration, take the 2. Multiply the 0 (<code>*pn</code>) by 10, add 2, you get 2.</li>
<li>On the second iteration, take the 3. Multiply the 2 (<code>*pn</code>) by 10, add 3, you get 23.</li>
<li>On the third iteration, take the 4. Multiply the 23 (<code>*pn</code>) by 10, add 4, you get 234.</li>
</ol>
",1
12844840,12844778,1,"<p>The function is reading one digit at a time, starting from the left. So if it's reading, say, <code>12</code>, then first it gets <code>c == '1'</code> and <code>*pn == 0</code>, it adds <code>1</code> to <code>*pn</code> and now <code>*pn</code> is <code>1</code>. For each successive digit, it multiplies the existing value by ten (<code>*pn</code> is now <code>10</code>) and adds the digit (<code>*pn</code> is now <code>12</code>). This way it reads one digit at a time and ends up with the correct integer.</p>
",0
12844857,12844778,2,"<p>any number in the decimal notation can be expressed as a polynomial in <code>10</code></p>

<pre><code>234 = 2*10^2 + 3*10 + 4
</code></pre>

<p>reading from the left and multiplying by <code>10</code> assures each digit ends up multiplying the correct power of <code>10</code>. It's just an application of Horners rule, really.</p>
",1
13431821,13431798,1,"<pre><code>quicksort(x,first,j-1);
</code></pre>

<p>If you take a look at your <code>quicksort</code> function declaration, you'll see it has 4 and not 3 parameters. The last parameter is a pointer to a comparison function.</p>

<p>You should call it like this:</p>

<pre><code>quicksort(x, first, j-1, comp_on_price);
</code></pre>
",3
13431858,13431798,1,"<p>your function</p>

<pre><code>void quicksort(int x[10],int first, int last,int(*comp_on_price)(const void *, const void     *))
</code></pre>

<p>has 4 input parameter and the last one is a pointer to a function. you can remove it because you did not use it this function</p>
",0
13485402,13485039,2,"<p>As a guess I'd say the fault is outside the function.  The function ends by printing </p>

<pre><code> printf(""\nend"");
</code></pre>

<p>Notice there is no trailing '\n', so the ""end"" will not be flushed until later. Hence you do not see it in the output.  Meanwhile you continue and run into a fault.</p>

<p>Edit:</p>

<pre><code>i think you are right. Could you elaborate on how the flush would 
process with the trailing \n?
</code></pre>

<p>The <code>printf</code> function buffers what you send to <code>stdout</code> and flushes it (ie sends it to the terminal) when it encounters a newline '\n' (in what you give it).  To force it to flush without adding a newline character, you can use <code>fflush(stdout);</code>.</p>
",2
12858305,12858094,0,"<p>The pass by reference is internally changed to followings as follows</p>

<pre><code>Status initstack(sqstack &amp;s)
{
    s.base=(char *)malloc(stackinitsize*sizeof(char));   
    if(!s.base) exit(OVERFLOW);

    s.top=s.base;  
    s.stacksize=stackinitsize;

    return OK; 
</code></pre>

<p>}</p>

<p>to</p>

<pre><code>Status initstack(sqstack *s)
{
    (*s).base=(char *)malloc(stackinitsize*sizeof(char));   
    if(!(*s).base) exit(OVERFLOW);

    (*s).top=(*s).base;  
    (*s).stacksize=stackinitsize;

    return OK; 
}
</code></pre>

<p>but this is in case of C++,in c there is no concept of pass by reference so use the pointer notation as follows.</p>

<pre><code>Status initstack(sqstack * s)
{
    s-&gt;base=(char *)malloc(stackinitsize*sizeof(char));   
    if(!s-&gt;base) exit(OVERFLOW);

    s-&gt;top=s-&gt;base; 

    s-&gt;stacksize=stackinitsize;
    return OK; 
}
</code></pre>
",1
12858131,12858094,6,"<p>You appear to be using passing by reference which is a C++ feature, not C.</p>

<p>You cannot use <code>&amp;</code> in declaration in C, when you want to declare that a pointer is passed you use <code>*</code> (same goes for the <code>push</code> function):</p>

<pre><code>Status initstack(sqstack * s)
{
    s-&gt;base=(char *)malloc(stackinitsize*sizeof(char));   
    if(!s-&gt;base) exit(OVERFLOW);
    s-&gt;top=s-&gt;base;  
    s-&gt;stacksize=stackinitsize;
    return OK; 
}
</code></pre>

<p>Note, however, that unlike C++ pass-by-reference, you cannot change the argument passed to the function outside of the function by assignment to <code>s</code>, only to dereference it. </p>
",1
13433682,13433630,2,"<p>Most compilers will increment j twice before performing the addition and attributing the value to y, that is why the result in your case is 14.</p>

<p>The C standard doesn't specify the order of evaluation of that expression, though, so on another compiler the result could be 13 indeed. </p>

<p>In other words, this is undefined behavior and should be not be used other than in obfuscation contests and puzzles.</p>
",2
13785202,13722871,0,"<p>I'm not really familiar with your particular application so I don't really know what happens when you call ""write"" and ""read"" in your device's library. However, from a pure C/C++ point of view I noticed a couple of things that may or may not require attention. As I understood it you wanted to write 4 bytes of data to the first 4 bytes of memory via the SPI bus. In your write loop there are a couple of things I saw.</p>

<p>First, you loop 4 times and write 4 bytes each time. That is 16 total. Also, I don't see where ""address"" comes into play at all when you write. I noticed that the array of ""value"" you are passing the address of a uint* array. The write function takes a void* and you are essentially passing in a void***. This means you definitely are not writing the bytes that are in the value array you declared.</p>

<p>So the way I see it you can write 4 bytes, one byte at a time or 4 bytes at once like this.</p>

<pre><code>   int i;
   uint8 value[4] = { 0xAC, 0x53, 0xAA, 0x55 };
   uint8 address = 0;

   // Writing 4 bytes METHOD 1
   for (i = 0; i &lt; 4; ++i)
   {
      write(fd, &amp;(value[i]), 1);
   }

   // Writing 4 bytes METHOD 2
   write(fd, value, 4);
</code></pre>

<p>And you can print the second byte from your buffer like this.</p>

<pre><code>   uint8 buffer[20];
   read(fd, buffer, sizeof(buffer));
   printf(""%2X\n"", buffer[1]);  
</code></pre>

<p>I have worked with some microcontrollers and have not used file descriptors before to read/write on an SPI bus. So I hope this helps.</p>
",0
12876441,12876166,9,"<p>The null character <code>'\0'</code> and the newline character <code>'\n'</code> are two different character values, just as <code>'x'</code> and <code>'y'</code> are two different character values.</p>

<p>The null character, whose value is 0, is used to mark the end of a <em>string</em>, which is defined by the C standard as ""a contiguous sequence of characters terminated by and including the first null character."" For example, the <code>strlen()</code> function, which returns the length of a string, works by scanning through the sequence of characters until it finds the terminating null character.</p>

<p>The newline character, <code>'\n'</code>, is used to denote the end of a line in a text file. <em>Strings</em> exist in memory while your program is running, and <em>lines</em> exist in a text file external to your program. You can read the contents of a line (in a text file) into a string (in memory); depending on how you read it, the resulting string may or may not include the terminating <code>'\n'</code>.  Null characters do not normally occur in text files.</p>

<p>Note carefully that <code>NULL</code> is (a macro that expands to) a <em>null pointer constant</em>. Other than the fact that both a null pointer and a null character can be expressed as <code>0</code>, they have very little to do with each other. Please do not use the term <code>NULL</code> to refer to the null character.</p>

<p>One minor thing: in C, a character constant such as <code>'x'</code>, <code>'\0'</code>, or <code>'\n'</code> is actually of type <code>int</code>, not of type <code>char</code>. (C++ differs in this.) But they're almost always used to denote values of type <code>char</code>. For example, this:</p>

<pre><code>char c;
...
c = '\0';
</code></pre>

<p>will store a null character value in <code>c</code>, the <code>int</code> value is implicitly converted from <code>int</code> to <code>char</code>. In most cases, you don't have to worry about this.</p>

<p><code>char</code> and <code>int</code> are both integer types, and you can freely convert between them. The reasons for character constants being of type <code>int</code> are historical.</p>

<p>Also, I see you're using old-style (K&amp;R) function definitions. Way back in 1989, the ANSI standard added a new way to define functions using <em>prototypes</em> (you actually use some in your code) -- and there have been two new versions of the C standard since then. Old-style function definitions are obsolescent, and should be avoided. This:</p>

<pre><code>int func(x, y)
int x;
char *y;
{
    /* ... */
}
</code></pre>

<p>is an old-style definition. This:</p>

<pre><code>int func(int x, char *y)
{
    /* ... */
}
</code></pre>

<p>is a definition that uses a prototype, and it's preferred. For one thing, it lets the compiler check that a call passes the correct number and types of arguments.</p>

<p>You'll probably have more questions after this. I strongly suggest you take a look at the <a href=""http://www.c-faq.com/"" rel=""noreferrer"">comp.lang.c FAQ</a>; it will probably answer most of them.</p>
",5
12876167,12876166,3,"<p>Program #2 and #3 there are syntactical errors.</p>

<p><code>'\n'</code> with Hex value <code>0x0a</code> is often used to format text files o/p on screen just for readability. </p>

<p>'\0' with Hex value <code>0x00</code> is string delimiter. Although NULL has numeric value <code>0x0000</code> it's of type <code>void*</code>.</p>
",4
12876168,12876166,0,"<p>Conceptually both are characters, which means internally they're ascii encoded. </p>

<p>'\0' is integer 0
and '\n' is integer 10.</p>

<p>The programs have errors!</p>
",3
13460108,13459932,0,"<pre><code>#include &lt; stdio.h &gt;

typedef struct
{
  int re;// real part  
  int im;//imaginary part
} complex;

void add(complex a, complex b, complex * c)
{
  c-&gt;re = a.re + b.re;
  c-&gt;im = a.im + b.im;
}

void multiply(complex a, complex b, complex * c)
{
  c-&gt;re = a.re * b.re - a.im * b.im;
  c-&gt;im = a.re * b.im + a.im * b.re;
}

main()
{
  complex x, y, z;
  char Opr[2];

  printf(""  Input first operand. \n"");
  scanf(""%d %d"", &amp;x.re, &amp;x.im);
  printf(""  Input second operand. \n"");
  scanf(""%d %d"", &amp;y.re, &amp;y.im);
  printf(""  Select operator.(+/x) \n"");
  scanf(""%1s"", Opr);

  switch(Opr[0]){
    case '+':
          add(x, y, &amp;z); 
          break;
    case 'x':
          multiply(x, y, &amp;z);
          break;
    default:
      printf(""Bad operator selection.\n"");
      break;
  }
  printf(""[%d + (%d)i]"", x.re,x.im);
  printf("" %s "", Opr);
  printf(""[%d + (%d)i] = "", y.re, y.im);
  printf(""%d +(%d)i\n"", z.re, z.im);
}
</code></pre>
",0
13460114,13459932,0,"<p>You can do it easily.
As you have mentioned your function signature you should try this:</p>

<pre><code>complex_t read_complex(void)
{
    complex_t c;
    float a,b;
    printf(""Enter real and imaginary values of complex :"");
    scanf(""%f"",&amp;a);
    scanf(""%f"",&amp;b);
    c.real=a;
    c.imag=b;
    return c;
}

int main()
{
complex_t cobj;
cobj=read_complex(void);
printf(""real  : %f  imag : %f"",cobj.real,cobj.imag);
return 0;
}
</code></pre>
",0
12812410,12812330,2,"<p>In POSIX.1-2001 (e.g. Linux), <code>man 3 basename</code> gives:</p>

<blockquote>
  <blockquote>
    <p>The  functions dirname() and basename() break a null-terminated pathname string into directory and filename components. In the usual case,  ... basename() returns the component following the final '/'.  Trailing '/' characters are not counted as part of the pathname.</p>
  </blockquote>
</blockquote>
",3
12812629,12812330,0,"<p>As joseph mentioned, you can use basename().</p>

<p>Hope the following program helps a bit. </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;libgen.h&gt;
#include &lt;string.h&gt;

int main ( int argc, char **  argv)
{
  char *path = ""/Users/lionnew/cpgm"";
  printf (""%s\n"", basename (path));

  /* If you have an index */

  int index =15;
  int len = strlen(path);
  char * dest = malloc(len+1);
  dest[len] = '\0';

  strcpy (dest, (path+index));
  printf (""\n Destination String %s "", dest);

}
</code></pre>

<p>NOTE: Make sure your index value is not geater than the string len to avoid segmentation fault. </p>

<p>Hope this helps to some extend. ;)</p>
",0
12812729,12812330,0,"<p>If you have the index you can do it quite easily.</p>

<pre><code>char * src = ""YOUR STRING"";
char * dst; // destination
dst = (char *) malloc( sizeof(char) * 20);
dst = (char *)memcpy(dst, &amp;src[THE_INDEX_YOU_KNOW], strlen(src)-THE_INDEX_YOU_KNOW);
dst[len-start]='\0';
</code></pre>
",0
19375368,19375324,6,"<pre><code>char * strcpy ( char * destination, const char * source );
</code></pre>

<p><a href=""http://en.cppreference.com/w/c/string/byte/strcpy"" rel=""nofollow""><code>strcpy</code></a> manipulates strings of characters, which in C are represented with <a href=""http://en.cppreference.com/w/c/string/byte"" rel=""nofollow"">a null-terminated array of <code>char</code></a>, which has the type <code>char[]</code> or <code>char*</code>.</p>

<p>However, in your code :</p>

<pre><code>struct albums
{
    char* title[MAX];
    ...
    char* singerName[MAX];
    ...
};
</code></pre>

<p><code>char* []</code> means an array of <code>char*</code>, which is an array of pointer to <code>char</code>. <code>albums.title</code> and <code>albums.singerName</code> are thus not strings, but arrays of pointers. You should change it to <code>char title[MAX]</code> in order to have strings.</p>
",2
19375369,19375324,3,"<p>You are defining array of pointers to char and  not array of chars. 
use instead. </p>

<pre><code>char name[MAX];
</code></pre>
",0
19375406,19375324,0,"<p>A note of importent, you main question had alreaddy been answered by zakinster and SioulSeuguh</p>

<p>use  strncpy instead of strcpy </p>

<p>strcpy depends on trailing \0. if this is not there, you got problems with buffer overflow. </p>
",3
19375424,19375324,0,"<p>You declared arrays of pointers. Get rid of the pointers:</p>

<pre><code>struct albums
{
    char title[MAX];
    int year;
    char singerName[MAX];
    songs *bas;
    songs *current;
    struct albums *next;
};
</code></pre>
",0
13771505,13771434,5,"<p><code>nn *= 10.</code> will multiply <code>nn</code> by <code>10</code></p>

<p><code>nn = *10.</code> will try to dereference <code>10.</code>, which is invalid (being a double), like the error says.</p>

<p>Regarding indirection , the first search engine <a href=""http://msdn.microsoft.com/en-us/library/fw63e3c3%28v=vs.80%29.aspx"" rel=""noreferrer"">hit</a> says:</p>

<p>The unary indirection operator (*) dereferences a pointer; that is, it converts a pointer value to an l-value. The operand of the indirection operator must be a pointer to a type. The result of the indirection expression is the type from which the pointer type is derived</p>

<p>In your case, the operand in <code>10.</code>, a double.</p>
",1
13773444,13773431,3,"<p>Well, why did you use the ancient-style function declaration</p>

<pre><code>char *printb(fmt,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
{
</code></pre>

<p>?</p>

<p>This declaration declares all arguments as <code>int</code>s. Your attempts to pass a <code>char *</code> pointers to this function will only lead to disaster. Moreover, you are not supplying all parameters in your <code>printb</code> calls, which is another disaster.</p>

<p>It looks like you are attempting to implement a function with variable number of arguments. Specifically for that the language supports <code>...</code> parameter declaration. Read about variadic functions and <code>va_list</code>. </p>

<p>Your function would be implemented along the lines of</p>

<pre><code>char *printb(const char *fmt, ...)
{
   static char string[256];
   va_list va;

   va_start(va, fmt);
   vsprintf(string, fmt, va);
   va_end(va);

   return string;
}
</code></pre>

<p>or better</p>

<pre><code>   ...
   vsnprintf(string, sizeof string, fmt, va);
   ...
</code></pre>

<p>Although the idea of returning a pointer to an internal static buffer is also flawed.</p>

<p>Meanwhile, trying to ""emulate"" variadic arguments by your method is hopeless. It won't work.</p>
",1
16919090,16919025,5,"<p><code>\u</code> is used with an id (hexadecimal code) to represent a unicode character, for example<code>\u20AC</code> is the code for <em></em>. It cannot be on its own.</p>
",1
16919135,16919025,1,"<p>'\u' means a unicode character and it is written wrong in your code, the correct format is, for example:</p>

<p>'\u2006'</p>

<p>\u should be followed by 4 digits representing the character.</p>
",3
16919282,16919025,1,"<p>To expand a little on some of the other answers: when you use an escape sequence, it's treated as ONE character. <code>\n</code> is one character, despite being two keystrokes to type.</p>

<p>Subsequently, <code>\u1234</code> is ONE character to the computer's perspective. <code>\u</code> has no meaning: you've given it half a character code.</p>

<p>As to how you fix this, this depends on what you want to do. If you're trying to catch just one particular unicode character, change your switch statement to <code>case '\u1234':</code> where 1234 is the hex representation of your character's codepoint. </p>

<p>If, instead, you want to deal with characters not representable in ASCII differently, then you may want something similar to:</p>

<pre><code>if(ch &lt; 128)
{
// Check for \n, \t and space here
}
else
{
// Unicode or ANSI codepage
}
</code></pre>
",0
13700512,13700021,1,"<p>Did you mean something like this ?</p>

<pre><code>void doSomethingWithStruct(void* structptr,int ssize,int cnt, int offset,void* val,int vsize)
{
   int i;
   for(i=0;i&lt;cnt;i++)
   {
      //perhaps add bool as a function parameter to check if mem should be allocated ?
      memcpy( ((uint8_t*)structptr)+i*ssize+offset, val,vsize);
   }
}

//usage
typedef struct{
    char ip[IP_LEN+1];
    char netmask[IP_LEN+1];
} ipAndNetmaskStruct; 
static ipAndNetmaskStruct source[1024];
char data[IP_LEN+1];

doSomethingWithStruct(source,sizeof(ipAndNetmaskStruct),1024,/*if it was netmask it would have been sizeof(char)*(IP_LEN+1)*/0,data,IP_LEN+1);
</code></pre>

<p>EDIT:
you could use <code>offsetof</code> to get the offset of the member - defined in the ""stddef.h"", and in the spirit of that you could also use <code>#define sizeof_member(s,m) sizeof(((s *)0)-&gt;m)</code></p>

<p>example:</p>

<pre><code>#define doSomethingWithStruct(srcptr,type,member,val) doSomethingWithStruct(srcptr,sizeof(type),sizeof(srcptr)/sizeof(type),offsetof(type,member),val,sizeof_member(type,member))
</code></pre>
",2
12830296,12829778,2,"<p>It is a bad idea to have the same name for a function and a variable.</p>

<p>You need to:</p>

<ul>
<li>Change <code>%if</code> to <code>%lf</code></li>
<li>Remove <code>char getGrade;</code></li>
<li>When calling the function, it should be <code>getGrade(testValue)</code></li>
<li>Change the function <code>char getGrade(double value)</code> to:</li>
</ul>

<pre class=""lang-c prettyprint-override""><code>char getGrades(double value)    
{    
  if(value&gt;=90)    
    return 'A';    
  else if(value&gt;=80)    
    return 'B';    
  else if(value&gt;=70)    
    return 'C';    
  else if(value&gt;=60)    
    return 'D';    
  return 'F';    
}
</code></pre>
",3
12829808,12829778,0,"<p>getGrade needs an argument getGrade(50) for example</p>
",0
12829813,12829778,2,"<p><code>%if</code> Should be <code>%lf</code></p>

<p>You have not called the <code>getGrade</code> function</p>

<p>You have two identifiers with the same name.</p>

<p>Remove the <code>char getGrade;</code> declaration and just call the <code>getGrade</code> function.</p>
",7
16452918,16452878,6,"<p>An <code>#include</code> statement may appear on any line. It is most often used to include entire declarations. However, it can be used to insert any text.</p>

<p>It may be that <code>test.h</code> contains a list of names to be declared inside the <code>enum</code>. It may also contain preprocessor statements, such as macro definitions or <code>#if ¡­ #endif</code> statements.</p>

<p>You would have to show the contents of <code>test.h</code> for further help understanding it.</p>
",0
16452927,16452878,2,"<p><code>#include</code> and <code>#define</code> are <strong>pre processor directives</strong> not actual code.</p>

<p>You can put them anywhere (except as part of a literal string) - some compilers are more fussy than others (i.e. the # has to be in column 0).</p>

<p>The Preprocessor expands these out as required, and that is what the compiler sees. As to what it means in your case, depends on the content of test.h</p>

<p>There is normally a compiler option to see your code with all the preprocessor stuff expanded (used to be -e or -E on gcc I think)</p>
",0
16452940,16452878,0,"<p>Pre-processor statements can occur anywhere and are simple textual substitutions. Whether or not the processed code is valid C code is checked by the compiler, not the pre-processor.</p>

<p>Depending on your compiler you can review the changes done by the pre-processor.</p>

<p>For gcc, this would be the <code>-E</code> flag, so by compiling your source code with</p>

<pre><code>gcc -E in.c 
</code></pre>

<p>you can see which changes code is contained in the enum declaration after inserting <code>test.h</code> and
processing it.</p>
",0
16453106,16452878,2,"<p>The #include directive causes the contents of the included file to be placed exactly at the point of the #include directive. The resulting code is what it is once that expansion has taken place, and can be any valid language construct.</p>

<p>If the included file contains:</p>

<pre><code>enum_a,
enum_b,
enum_c,
</code></pre>

<p>Then after inclusion, your code would look like:</p>

<pre><code>typedef enum {
    enum_a,
    enum_b,
    enum_c,
    enum1,
    enum2,
    ¡­
} test_enum;
</code></pre>

<p>Which is a valid construct.</p>

<p>A #include directive can appear anywhere. <a href=""https://stackoverflow.com/questions/16389126/can-the-pre-processor-directives-like-include-be-placed-only-at-the-top-of-the/16389524#16389524"">See this</a>.</p>
",0
15513494,15513465,0,"<p>Yes -- read a larger buffer (e.g., at least a few kilobytes) full of data. When the user calls getchar, return a char from the buffer unless it's empty. If it is empty, refill the buffer first, then return a char.</p>
",2
11837563,11837553,0,"<p>That's because you need to use a format specifier corresponding to the integer you passed. The most common is <code>%d</code>. Try replacing the <code>%n</code> with a <code>%d</code>.</p>

<p><a href=""http://www.cplusplus.com/reference/clibrary/cstdio/printf/"" rel=""nofollow"">Here's a more in depth explanation of all the format codes</a></p>
",1
11837568,11837553,1,"<p>A signed integer uses <code>%d</code> (or <code>%i</code>).</p>

<p>See also <code>man 3 printf</code> (on Unix-like systems) for the whole list of modifiers.</p>
",0
11837709,11837553,0,"<p>As the other answers indicated, you normally print an <code>int</code> with the <code>%d</code> conversion specification, or optionally with the <code>%i</code> conversion specification.  You can also use <code>%o</code>, <code>%x</code> or <code>%X</code> (and <code>%u</code>), though technically there's a signed-to-unsigned conversion implied by doing so.</p>

<p>Note that <code>%n</code> is a valid conversion specification for <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/printf.html"" rel=""nofollow noreferrer""><code>printf()</code></a> et al.  However, unlike all the other conversion specifications, the <code>%n</code> conversion specification is an output operation that takes a pointer to an <code>int</code> and it is used to find out how many characters have been written up to that point in the format string.  Therefore, you could use:</p>

<pre><code>int n = GetInt();
int c;

printf(""%d%n\n"", n, &amp;c);
printf(""%d characters in number %d\n"", c, n);
</code></pre>

<p>Note, too, that there is almost never any need for a space before a newline.</p>

<p>The <a href=""https://stackoverflow.com/questions/372980/do-you-use-the-tr-24731-safe-functions"">TR24731-1</a> (or ISO/IEC 9899:2011 Annex K, Bounds Checking Interfaces) defines <code>printf_s()</code> et al, and explicitly outlaws the <code>%n</code> conversion specification because it often leads to problems precisely because it is an output parameter rather than an input parameter.</p>
",0
20416792,20416682,1,"<p>if there are multiple break conditions &amp; if it not possible to use switch then generally programmers use do while<br/> </p>

<pre><code>do
{
   if (some  cond)
   {
     // do some job
      break;
   }
   else if (some cond)
   {
      // do some thing break
   }

   // similarly
}
while(false);
</code></pre>

<p>objective is to jump out of the loop after executing one or few conditions in do expression</p>
",2
20416690,20416682,5,"<p>It's a way to implement <code>GOTO</code>  without explicitly using it.</p>

<p>Generally speaking, I believe C put <code>if</code> statements so that you can program in a <a href=""http://en.wikipedia.org/wiki/Structured_programming"" rel=""nofollow"">structured programming</a> paradigm.</p>

<p>That Wikipedia article notes a deviation from the paradigm would be early exit, which would be a use case for the <code>do while (false)</code>.  However, the suggested pseudocode to handle <a href=""http://en.wikipedia.org/wiki/Structured_programming#Early_exit"" rel=""nofollow"">early exit</a> still has a not-always-<code>false</code> condition in the <code>while</code> loop.</p>

<p>For the example of processing a file with errors, it notes that somebody might write it like this:</p>

<pre><code>// open file
while (/* reading not finished */)
{
    // read some data;
    if (/* error */)
    {
        // stop the subprogram and inform rest of the program about the error;
        // use of break here would skip the ""process read data"" step
    }
    // process read data;
}
// finish the subprogram;
</code></pre>
",3
20417446,20416682,1,"<p>A decent analogy for this strategy is returning from a function; if this code were in a function, that ""break"" would be a ""return false""; however, that's not possible here, since one cannot simply break out of an arbitrary code scope in C/C++.</p>

<p>Doing the ""break"" trick <em>prevents</em> nonsensical if-nesting as more and more sanity-check and failure conditions build up.  Yes, there are always more ways to do things, but often this strategy mirrors the normal thought-processes and workflow of functions, and people are often very familiar with that workflow.</p>

<p>It may even be the case that a function was moved <em>into</em> another area of code (perhaps because it was so specialized that it would never be reused), and it wasn't worth the effort to refactor the ""return""-driven logic.</p>

<p>For example, this may be a more meaningful demonstration of the strategy.  I've included a less trivial setup to demonstrate why you might see this:</p>

<pre><code>intenseStructure = allocate_memory_and_other_expensive_things();
do {
    if( ! some_test_of( variable1 ) ) {
        some_log( ""Unexpected value for variable1."" );
        break;
    }

    variable2 = some_thing_involving( variable1 );
    if( ! some_test_of( variable2 ) ) {
        some_log( ""Unexpected value for variable2."" );
        break;
    }

    something();
} while(false);
delete intenseStructure;
</code></pre>

<p>Here, let's assume that we can't meaningfully test ""variable1"" until we've set up ""intenseStructure"", and the same goes for ""variable2"" (which needs ""variable1"").  The ""do...while(false)"" strategy mirrors a function-based approach:</p>

<pre><code>bool do_something( Intense* intenseStructure ) {
    if( ! some_test_of( variable1 ) ) {
        some_log( ""Unexpected value for variable1."" );
        return false;
    }

    variable2 = some_thing_involving( variable1 );
    if( ! some_test_of( variable2 ) ) {
        some_log( ""Unexpected value for variable2."" );
        return false;
    }

    something();
    return true;
}

intenseStructure = allocate_memory_and_other_expensive_things();
do_something( intenseStructure );
delete intenseStructure;
</code></pre>

<p>Here is an example of a more ""traditional"" if-oriented way.  As you can see, it is a bit more confusing, while behaving equivalently.  The nesting of the if-statements can become very troublesome and confusing after a while, and code maintenance can become quite difficult:</p>

<pre><code>intenseStructure = allocate_memory_and_other_expensive_things();
if( ! some_test_of( variable1 ) ) {
    some_log( ""Unexpected value for variable1."" );
} else {
    variable2 = some_thing_involving( variable1 );
    if( ! some_test_of( variable2 ) ) {
        some_log( ""Unexpected value for variable2."" );
    } else {
        something();
    }
}
delete intenseStructure;
</code></pre>
",2
17384789,17384246,0,"<p>In <code>scanf(""%c"",&amp;YN)</code> place a space before conversion specifier<code>%c</code> like <code>scanf("" %c"",&amp;YN)</code> to eat up newline character(<code>\n</code>) </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

int is_correct(void) 
{
   char YN ;
   printf( ""Y or N : "" ) ;
   scanf("" %c"",&amp;YN);
   YN = toupper( YN );

   return  YN == 'Y' ? 1 :  YN == 'N' ? 0 : is_correct() ;
}     

int main()
{ 
    printf(""%d"",is_correct());
    return 0;
}
</code></pre>

<p>I have tested it. Working fine if you type only one character(excluding <code>\n</code>)!<br>
In a more efficient way you can do like this; store first character into <code>char ch</code> and then use a loop <code>while((YN = getchar()) != '\n')</code> to eat up all other characters including <code>\n</code>. Ex: If you type <code>ynabcd</code>, first character <code>y</code> will be stored in <code>ch</code> as <code>Y</code> and rest will be eat up by <code>while(</code> loop.   </p>

<pre><code>int is_correct(void) 
{
   char YN ;
   printf( ""Y or N : "" ) ;
   scanf(""%c"",&amp;YN);
   char ch = toupper( YN );
   while((YN = getchar()) != '\n')
    ; 
   return  ch == 'Y' ? 1 :  ch == 'N' ? 0 : is_correct() ;
}   
</code></pre>
",4
17384668,17384246,1,"<p>The <code>%c</code> conversion does not read the newline character that you must type after your single-character answer.</p>

<p>In general, <code>scanf()</code> causes far more problems than it's worth.  Try using <a href=""http://linux.die.net/man/3/getline"" rel=""nofollow""><code>getline()</code></a> to read a string from <code>stdin</code> into a string, and then use <a href=""http://linux.die.net/man/3/sscanf"" rel=""nofollow""><code>sscanf()</code></a> to extract a character from the string.</p>

<p>Among other things, <code>getline()</code> allows you to specify the maximum input length, so you can easily avoid overflowing a string buffer.</p>
",6
13424364,13424265,30,"<p>if you have a <em>null terminated</em> string that you wish to convert to double use <code>atof</code>:</p>

<pre><code>const char *str = ""3.14"";
double x = atof(str);
printf(""%f\n"", x); //prints 3.140000
</code></pre>

<p>If you have a single character, casting should work:</p>

<pre><code>char c = 'a'; //97 in ASCII
double x = (double)c; 
printf(""%f\n"", x); //prints 97.000000
</code></pre>

<p>If the character is zero then it print zeros of course:</p>

<pre><code>char c = '\0';
double x = (double)c; 
printf(""%f\n"", x); //prints 0.000000
</code></pre>

<p>Note: <code>atof</code> and similar functions don't detect overflows and return zero on error, so there's no way to know if it failed (not sure if it sets <code>errno</code>), see also Keith's comments about <em>undefined behaviour</em> for certain values, so the point is you should use <code>strtol</code> for converting from strings to <code>int</code> and <code>strtod</code> for converting to <code>double</code> those have much better error handling:</p>

<pre><code>const char *str = ""3.14"";
double x = strtod(str, NULL);
</code></pre>
",8
13424831,13424265,5,"<p>To answer the question you asked:</p>

<pre><code>#include &lt;stdio.h&gt;
int main(void) {
    char c = 42;
    // double d = (double)c; The cast is not needed here, because ...
    double d = c;    // ... the conversion is done implicitly.
    printf(""c = %d\n"", c);
    printf(""d = %f\n"", d);
    return 0;
}
</code></pre>

<p><code>char</code> is an integer type; its range is typically either <code>-128</code> to <code>+127</code> or <code>0</code> to <code>+255</code>. It's most commonly used to store character values like <code>'x'</code>, but it can also be used to store small integers.</p>

<p>But I suspect you really want to know how to convert a character <em>string</em>, like <code>""1234.5""</code>, to type <code>double</code> with the numeric value <code>1234.5</code>.  There are several ways to do this.  </p>

<p>The <code>atof()</code> function takes a <code>char*</code> that points to a string, and returns a <code>double</code> value;  <code>atof(""1234.5"")</code> returns <code>1234.5</code>. But it does no real error handing; if the argument is too big, or isn't a number, it can behave badly. (I'm not sure of the details of that, but I believe its behavior is undefined in some cases.)</p>

<p>The <code>strtod()</code> function does the same thing and is much more robust, but it's more complex to use. Consult your system's documentation (<code>man strtod</code> if you're on a Unix-like system).</p>

<p>And as Coodey said in a comment, you need to make your question more precise. An example with actual code would have made it easier to figure out just what you're asking.</p>
",0
13460974,13460934,2,"<p>You should likely allocate some memory for that pointer before passing it off to a function that fills what it points <em>to</em> (which in this case, is NULL).</p>

<p>Example:</p>

<pre><code>char *str = malloc(128);
if (str)
{
   str_cpy(&amp;str, ""String"");
   free(str);
   str = NULL;
}
</code></pre>

<p>I advise not doing this without also providing target-buffer size information (i.e. if you're writing your own, then boundary-check the target buffer, otherwise your version has the same security flaws as <code>strcpy()</code> which are bad enough as it is).</p>

<p>Note: Unless you're planning on changing the address held by the pointer passed as the target, you need not use a double pointer either. The double pointer usage you have prevents the traditional <code>strcpy()</code> usage pattern of:</p>

<pre><code>char str[128];
str_cpy(&amp;str, ""Hello""); // error. 
</code></pre>

<p>An array address cannot be passed as a pointer-to-pointer, so your code cannot fill a static array without an intermediate pointer:</p>

<pre><code>char str[128];
char *p = str;
str_cpy(&amp;p, ""Hello"");  //ok. passing address of pointer.
</code></pre>

<p>If this is not intentional (and I don't see why it could be unless you have ideas of internally emulating <code>strdup()</code> on a NULL pointer passage) You should address this.</p>
",0
13460991,13460934,8,"<p>No, it's not okay. Why? Because <code>str</code> is a <code>NULL</code> pointer. It's pointing to nothing. When you try to write values into it, where will they go? It's not pointing to any allocated memory!</p>

<p>You first have to allocate memory for <code>str</code>. You can do:</p>

<pre><code>char *str = malloc(strlen(""String"") + 1); // + 1 for the '\0' character at the end of C-style strings
</code></pre>

<p>Or you can do:</p>

<pre><code>char str[256]; // make str large enough to hold 256 chars. Note that this is not as safe as the above version!
</code></pre>

<p>Also, <code>destination</code> should be a single pointer, not a double pointer. Well, it's not technically wrong to use a double pointer, it's just unnecessary.</p>

<p>Optionally, you can allocate the memory in the <code>str_cpy</code> function, like so:</p>

<pre><code>void str_cpy(char **destination, const char *source) {
    *destination = malloc(strlen(source) + 1);
    // ... continue as normal
</code></pre>
",3
13461000,13460934,3,"<p>I don't see any need to pass a pointer-to-pointer:</p>

<pre><code>void str_cpy(char *dst, const char *src) {
   while (*src != '\0') {
      *dst++ = *src++; 
   }
   *dst = '\0';
}
</code></pre>

<p>And you need to allocate memory for <code>dst</code> before passing:</p>

<pre><code>const char *src = ""String"";
char *str = malloc(strlen(src)+1); //plus one for null byte
str_cpy(dst, src);
</code></pre>
",0
13461074,13460934,4,"<p>For simplicity's sake, this can be done in one line in a function.</p>

<pre><code>void mystrcpy(char *dest, const char *src) {
  while (*dest++ = *src++);
}
</code></pre>

<p>This being said, you do need to allocate memory for <code>dest</code> beforehand using <code>malloc</code> or just simply by having a character array like <code>char dest[256]</code>.</p>
",2
13422785,13422523,1,"<p>The length parameter <code>n</code> includes one character for null as well. So, if you input length for <code>n</code> 4 then you can only input 3 characters, for example <code>abc</code> because the 4th is for the null.</p>

<p>So you should change the declaration accordingly:</p>

<p>Change:</p>

<pre><code> char input[n];
</code></pre>

<p>to:</p>

<pre><code> char input[n+1];
</code></pre>

<p>Note that variable length arrays are allowed only since C99.</p>
",0
13422546,13422523,1,"<pre><code>char input[n];
scanf(""%s"", &amp;input);
</code></pre>

<p>should be</p>

<pre><code>char input[n+1];
scanf(""%s"", input);
</code></pre>

<p><code>input</code> is equivalent to <code>&amp;input[0]</code></p>

<p>You should also exit the for loop in <code>userEnter</code> when you encounter the nul character that ends the user-entered string.  e.g. with something like</p>

<pre><code>char* p = input;
while (*p != '\0') {
    *pattern = (*p) - 'a';
    p++;
    pattern++;
}
</code></pre>

<p>As KingsIndian points out, you also need to increase the size of your <code>input</code> buffer.  At present, you overflow that buffer and overwrite the loop counter <code>i</code>;</p>
",2
15528940,15528737,0,"<p>As said: You are returning a local variable allocated on the stack. The variable ceases to exist the second you return. However the stack is not cleared, hence the behavior. </p>

<p>You need to allocate <code>g</code> on the heap. For that do:</p>

<pre><code>void gxxx(char* xxx){

    //do sone stuff to xxx 
    return;
}

char *g = malloc(/*some size*/);
gxxx(g);
free(g);
</code></pre>
",0
15528971,15528737,0,"<p>The first: <code>xxx</code> is a local array of the <code>gxxx()</code> function. If you're trying to copy the string to this array after function exit, it causes <strong>undefined behavior</strong>.</p>

<p>The second: as I can see you are doing <code>strcpy(g,""oldstring"");</code> before printing the result. What did you expected?</p>
",0
13425552,13425477,3,"<blockquote>
  <p>Is there some sort of standard or 'convention' on this?</p>
</blockquote>

<p>Yes: define <code>NDEBUG</code> in production code. It's the ISO C standard way of doing this and only adds a few milliseconds to your compile cycle (or saves some compared to not defining <code>NDEBUG</code>, as you're including it anyway) because the compiler/preprocessor has to scan through <code>&lt;assert.h&gt;</code> to find out it has to remove things from your code. It doesn't bloat your executable or add any other kind of runtime overhead, unless you do crazy things in a <code>#ifndef NDEBUG</code> block.</p>
",1
13425803,13425477,0,"<p>Here is how I do this.  Discussion below the code.</p>

<p>In some .h file:</p>

<pre><code>#define PASS ((void)0)

extern void hook(void);
extern void asserthook(void);

#ifdef DEBUG
#define ENABLE_ASSERTS
#endif // DEBUG

#ifdef ENABLE_ASSERTS
#define AssertMesg(expr, mesg) \
    do { \
        if (!(expr)) \
        { \
            asserthook(); \
            fprintf(streamErr, \
                    ""%s(%d): assertion failed: "", __FILE__, __LINE__); \
            fprintf(streamErr, ""%s\n"", mesg); \
            fflush(streamErr); \
            Exit(10); \
        } \
    } while (0)
#define Assert(expr)  AssertMesg(expr, """")

#else // !ENABLE_ASSERTS

#define AssertMesg(expr, mesg)  PASS
#define Assert(expr)  PASS

#endif // !ENABLE_ASSERTS
</code></pre>

<p>And in some .c file:</p>

<pre><code>void hook(void)
{
    PASS;
}

void asserthook(void)
{
    hook();
}
</code></pre>

<p>First of all, my asserts always call <code>asserthook()</code> which calls <code>hook()</code>.  These functions are just places to set a breakpoint; I also have <code>errhook()</code> that is called for an error.  Usually I just set a breakpoint on <code>hook()</code> itself, and then anytime my code is taken down by an assert, I have the debugger stopped right on the error with the stack backtrace in just the spot I need.</p>

<p>When you are trying to make a multiline macro that will act like a C statement, the usual way to do it is to put it in curly braces and then wrap those braces in <code>do</code> / <code>while (0)</code>.  That's a loop that executes a single time, so it's really not a loop.  But wrapping it like that means it is a statement and when you put a semi-colon on the line to terminate the statement, it's actually correct.  Thus code like this will compile without errors and do the right thing:</p>

<pre><code>if (error)
    AssertMesg(0, ""we have an error here"");
else
    printf(""We don't have an error after all.\n"");
</code></pre>

<p>If you didn't do the silly <code>do</code> / <code>while (0)</code> wrapper, and just had the curly braces, the above code won't work!  First, the compiler would wonder why you have a <code>;</code> right after a curly brace and before an <code>else</code>; second, the <code>else</code> would associate with the hidden <code>if</code> inside the <code>AssertMesg()</code> macro, and the <code>printf()</code> would never be called.  You could fix the latter problem with explicit curly braces but it is clearly better to set up your macro so that it works in all situations, and that is what the <code>do</code> / <code>while (0)</code> does for you.</p>

<p><code>(void)0</code> is my preferred do-nothing statement.  You could just use <code>do {} while (0)</code> if you prefer, or anything else that has no side-effects and doesn't use any variables.</p>

<p>The worst thing about the <code>do</code> / <code>while (0)</code> trick is that you sometimes see error messages that are complaining about a <code>do</code> loop, and since it's hidden inside macros you need to remember what is really going on.  But it's the best way I know to make multiline macros work correctly.</p>

<p>When possible, you should use static inline functions rather than macros.  But macros are completely portable to even sucky lame C compilers, and you need to use a macro for an assert so you can have <code>__FILE__</code> and <code>__LINE__</code> expanded properly.</p>

<p>(You could write a varargs function that does the actual assert, and then just make a macro that expands to a single call to that function, as long as varargs work correctly on all the compilers you use.  I think I could do that now, but I already have the multiline macro solution working and I haven't touched it in a long time.)</p>
",0
14206777,14206753,4,"<p>Nothing wrong here.  If you were to run this program on a file that contained the backspace character, it would properly convert it.   For terminal input, the program will not receive the backspace as it is managed by the input routines.</p>
",0
14207415,14206753,5,"<p>This is because the Operating System is handling terminal IO, and processes the characters from the keyboard before your program gets to see them.</p>

<p>If you are on a Unix/Linux system, you could wrap the execution of your program like this:</p>

<pre><code>$ stty -icanon -echo; ./a.out; stty icanon echo
</code></pre>

<p>This will disable the terminal driver from processing the input in some specific ways: icanon enables the handling of of things like backspace processing, while echo causes the characters you type to be printed. Since your program echos the characters itself, you can turn echo off. The only problem with this is that -icanon also stops EOF processing, so you will need to add an extra condition to get out of the loop:</p>

<pre><code>#include &lt;stdio.h&gt;

#define CTRL(x) (x &amp; 0x1f)

main()
{
    int c;

    while((c = getchar()) != EOF &amp;&amp; c != CTRL('d')) {
...
</code></pre>

<p>It is also a good idea while testing programs like this to run them in a separate window, so you can kill the entire session quickly and easily if you end up in a strange terminal mode!</p>
",0
16451906,16451664,2,"<p>Given the declaration for <code>register_ptr</code>, the lines:</p>

<pre><code>          *register_ptr[i] = *(int*)register_ptr[j];
        }
        else
        {
          *register_ptr[i] = *(int*)(atoi(arg2));
</code></pre>

<p>are both wrong (one harmlessly, one less harmlessly).  The first doesn't need the cast; you could perfectly well write:</p>

<pre><code>          *register_ptr[i] = *register_ptr[j];
</code></pre>

<p>The second really doesn't need any casting either, but it doesn't need the level of indirection either:</p>

<pre><code>          *register_ptr[i] = atoi(arg2);
</code></pre>

<p>This assigns the integer returned by <code>atoi(arg2)</code> to the memory pointed at by <code>register_ptr[i]</code>, which is presumably one of <code>REGA</code>, <code>REGB</code>, <code>REGC</code> or <code>REGX</code>.  As written, you are treating the value in <code>arg2</code> as an address in your simulator's memory space and reading the value that's there, with all sorts of (probably) unwanted consequences (such as core dumps).</p>
",5
11897340,11897323,2,"<p>The backslash is used for escaping <code>\</code> use <code>fprintf(fp, ""%d \n"", i);</code></p>
",0
13454403,13454139,1,"<p>1.</p>

<pre><code>mergesort(N,0,,N-1, comp_on_price);
            ^
          Extra , in there...
</code></pre>

<ol>
<li><p>void mergesort(int a[],int low, int high, int(*compar)(const void *, const void *)) 
                ^         ^        ^             ^
             array        int      int          function pointer</p></li>
</ol>

<p>Your call:</p>

<pre><code> mergesort(N,0,,N-1, comp_on_price);
           ^ ^   ^         ^
          int int int     function name, 
                           a function point is an address of your function
</code></pre>
",0
14202733,14202655,1,"<p>One bug is here:</p>

<pre><code>for (i=0; i&lt;(strlen(str)-1); i+sum) {
                             ^^^^^
</code></pre>

<p>Did you mean to write <code>i += sum</code>?</p>

<p>Another bug is due to the double increment in:</p>

<pre><code>        for (j=i; str[j]==str[j++]; j++ ) sum++;
                              ^^^   ^^^
</code></pre>
",0
14202774,14202655,1,"<p>One thing I see right off the bat is that you're incrementing <code>j</code> twice in each iteration. Perhaps you meant <code>str[j] == str[j+1]</code> as the condition. But, even if you do that, in that nested loop you can still reach territory out of your array's bounds. You need to make sure that not only the above condition is true, but <em>also</em> that <code>str[j]</code> is still within valid range.</p>

<p>Later on, you say</p>

<pre><code>str_out[k]=sum+48;
str_out[k++]=str[i];
</code></pre>

<p>That's definitely not what you want. What you want is probably <code>str_out[k++]</code> in both assignments, otherwise the second assignment cancels out the first.</p>

<p>Then again, if <code>sum</code> is equal to <code>1</code>, you don't save the count of repetitions, only the character. I doubt that's what you want, because the code that would decode the resulting array will not be able to distinguish between count and value. So, you probably want to use the <code>if</code> body for both cases (non-conditionally).</p>

<p>Also, as mentioned in another answer, the first loop will continue forever, because you're not incrementing <code>i</code> in the step part of the outer <code>for</code> loop.</p>
",0
13416786,13416698,2,"<p>I suppose <code>ciphered_text</code> is a <code>char[N]</code> or a <code>char*</code>?</p>

<p>The likely cause of failure is then that</p>

<pre><code>(int)(ciphered_text[arrayelement]) + shiftkey;
</code></pre>

<p>is larger than 127, and when that is stored in a <code>char</code> (<code>ciphered_element[arrayelement]</code>), it is converted to a negative value. (Note: conversion of out-of-range values to <code>char</code> is implementation-defined if <code>char</code> is signed.)</p>

<p>The easiest fix would be to change the type to <code>unsigned char</code>.</p>
",3
17780268,17780228,7,"<p><code>y = x++ &lt;= 5;</code>  ==> <code>y = (x++ &lt;= 5);</code>  ==> first compare <code>x</code> with <code>5</code> to check whether <code>x</code>  is small then or equals to <code>5</code> or not. Result of <code>(x++ &lt;= 5)</code> is either <code>1</code>, <code>0</code> assigned to <code>y</code>, </p>

<p>As <code>x</code> becomes > <code>5</code>, <code>(x++ &lt;= 5)</code> becomes <code>0</code> so <code>y = 0</code> and condition <code>false</code> and loop break, </p>
",2
17780302,17780228,1,"<p>Initialize your variables:</p>

<pre><code>int x = 1; int y = 1; 
</code></pre>

<p>There are <code>3</code> statements for the <code>for loop</code>: -1.  Initialize, 2.  Condition, 3. Iteration:increment/decrement<br>
In your case, you did not provide the initialize condition, however, you have the part of condition and incrementation. I do not think your for loop is used in the correct way.  </p>

<p>You should swap the part of incrementation with your body like this:</p>

<pre><code>for(; y; y = x++ &lt;= 5;)
   printf(""%d %d\n"", x, y)
</code></pre>

<p>First, you check whether the condition is true or not, <code>y</code> is true or not. Then, you print <code>x</code> and <code>y</code> out. Then, the part of incrementation is executed, <code>x++ &lt;= 5</code> or not. The result is assigned to <code>y</code>. It does so until your condition is false, <code>y</code> == <code>false</code>.</p>

<p><strong>NOTE:</strong> For the good programming, you should enclose your body with a curly braces. </p>
",1
17780347,17780228,1,"<p>Basically the for syntax is:
for(StartCondition; Test; PostLoopOperation) DoWhileTestPasses;</p>

<p>In this case:</p>

<pre><code>StartCondition == None
Test == (y != 0)
PostLoopOperation == do some printing 
DoWhileTestPasses == set y to zero if x &gt; 5 otherwise to non-zero THEN increment x.
</code></pre>

<p>Which is all rather bad practice because it is confusing.</p>

<p>Would be better written as:</p>

<pre><code>int x=0;
int y=0;
for(y=0; y = (x &lt;= 6); x++)
{
    printff(""%d %d\n"",x,y);
}
return(0);
</code></pre>
",3
17780352,17780228,0,"<p>similar to this</p>

<pre><code>   int x = 1;
   for( int y = 1; y!=0 ; )
   {
       if (x++ &lt;= 5)
       {
          y = 1;
       } 
       else
       {
          y = 0;
       }
       printf(""%d %d\n"",x,y);
   }
</code></pre>
",0
17780353,17780228,1,"<p>In <code>y = x++ &lt;= 5;</code>, <code>y</code> stores the value that is output by the condition <code>x++ &lt;= 5</code> (here <code>x++</code> is post increment). If the condition is true then <code>y = 1</code> else <code>y = 0</code>.</p>

<pre><code>for( ; y ; printf(""%d %d\n"",x,y))
</code></pre>

<p>In the for loop you are printing the values of <code>x</code> and <code>y</code> after executing the for loop body.</p>
",0
17780358,17780228,0,"<p>Perhaps this slightly transformed (but functionally equal) code will help:</p>

<pre><code>int x = 1;
int y = 1;
while (y) {
   y = (x &lt;= 5);
   x = x + 1;
   printf(""%d %d\n"", x, y)
}
</code></pre>
",0
12340901,12340858,1,"<p>Depending on what platform you are on, <code>sizeof(int *)</code> could be 4 or 8 (or other).  Also, your compiler has the freedom to add unused padding bytes to the struct if it wants to.</p>
",0
12340907,12340858,0,"<p>This is due to padding and memory alignment. Refer to <a href=""http://www.geeksforgeeks.org/archives/9705"" rel=""nofollow"">this link</a> for further explanations.</p>
",0
12340910,12340858,4,"<blockquote>
  <p>Why sizeof is 16?Is it 12?(int+int point=4+8);</p>
</blockquote>

<p>Since the pointer is 8 bytes wide on your machine, the compiler felt obliged to align it to an 8 byte boundary, for performance reasons. On some architectures it may not even be strictly a performance problem: unaligned access to certain types can be outright illegal.</p>

<p>In other words the compiler is allowed to add padding everywhere, <strong>except before the first element of the structure</strong>.</p>
",4
12340923,12340858,0,"<p>Memory aligment is at work. Things need to be aligned.</p>
",0
13762221,13758965,0,"<p>You aren't giving us all the code. I suppose <code>NumPerm</code> and <code>NumVar</code> are reset to 0 between the loops.</p>

<p>By the way, there is another problem here:</p>

<pre><code>        AntLastVekt[NumPerm]=AntAktuell;
</code></pre>

<p>Unless all ""Perms"" comes before all the ""Vars"", this should be AntLastVekt[NumPerm+NumVar].  Otherwise if you have a sequence Perm/Var/Perm, the second Perm will overwrite AntLastVekt[1].</p>

<p>However, this is not the cause of the problem because AntLastVekt is unused in the second loop.</p>

<p>The bug is in the second loop, even though the OS does not detect it until you free the arrays.  To prove this, comment out all the code in the middle.  You can use <code>valgrind</code> to debug it.</p>
",1
13774519,13772655,1,"<p>The code is fairly old (2007 for the latest modifications).  Of itself, that need not be a problem.</p>

<p>The 'struct timezone' problem with <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/gettimeofday.html"" rel=""nofollow""><code>gettimeofday()</code></a> is fixed by including <code>#include &lt;sys/time.h&gt;</code> per POSIX.</p>

<p>The problems with <code>pam_get_item()</code> etc not being declared are fixed by commenting out the <code>#ifdef sun</code> and <code>#endif</code> protection around <code>#include &lt;security/pam_appl.h&gt;</code>.</p>

<pre><code>pam_radius_auth.c:886:24: warning: passing 'int *' to parameter of type 'socklen_t *' (aka 'unsigned int *') converts
      between pointers to integer types with different sign [-Wpointer-sign]
                                     0, &amp;saremote, &amp;salen)) &lt; 0) {
                                                   ^~~~~~
/usr/include/sys/socket.h:615:25: note: passing argument to parameter here
                socklen_t * __restrict) __DARWIN_ALIAS_C(recvfrom);
</code></pre>

<p>That can be fixed by changing:</p>

<pre><code>int salen, total_length;
</code></pre>

<p>to:</p>

<pre><code>int total_length;
socklen_t salen;
</code></pre>

<p>The problem:</p>

<pre><code>pam_radius_auth.c:1104:12: warning: incompatible pointer types assigning to 'const char *' from
      'const char **'dereference with * [-Wincompatible-pointer-types]
      user = userinfo;
</code></pre>

<p>That can be fixed by changing the line to:</p>

<pre><code>user = *userinfo;
</code></pre>

<p>The problem:</p>

<pre><code>md5.c:176:27: warning: 'memset' call operates on objects of type 'struct MD5Context' while the size is based on a
      different type 'struct MD5Context *' [-Wsizeof-pointer-memaccess]
    memset(ctx, 0, sizeof(ctx));        /* In case it's sensitive */
           ~~~            ^~~
md5.c:176:27: note: did you mean to dereference the argument to 'sizeof' (and multiply it by the number of elements)?
    memset(ctx, 0, sizeof(ctx));        /* In case it's sensitive */
</code></pre>

<p>can be fixed by changing the line to:</p>

<pre><code>    memset(ctx, 0, sizeof(*ctx));        /* In case it's sensitive */
</code></pre>

<p>(and that's an impressive warning!)</p>

<p>With those changes in place:</p>

<pre><code>$ make
cc -Wall -fPIC -c pam_radius_auth.c -o pam_radius_auth.o
cc -Wall -fPIC   -c -o md5.o md5.c
ld -Bshareable pam_radius_auth.o md5.o -lpam -o pam_radius_auth.so
ld: unknown option: -Bshareable
make: *** [pam_radius_auth.so] Error 1
$
</code></pre>

<p>The makefile notes that more modern versions of GCC support <code>-shared</code> (but guesses that <code>ld -Bshareable</code> works most places).  So, let's try:</p>

<pre><code>$ cc -shared -o pam_radius_auth.so *.o -lpam
$
</code></pre>

<hr>

<h3>Patch</h3>

<pre><code>--- pam_radius-1.3.17/Makefile  2007-03-25 21:22:11.000000000 -0700
+++ pam_radius-1.3.17.fixed/Makefile    2012-12-07 20:26:17.000000000 -0800
@@ -55,7 +55,8 @@
 #  gcc -shared pam_radius_auth.o md5.o -lpam -lc -o pam_radius_auth.so
 #
 pam_radius_auth.so: pam_radius_auth.o md5.o
-   ld -Bshareable pam_radius_auth.o md5.o -lpam -o pam_radius_auth.so
+   gcc -shared pam_radius_auth.o md5.o -lpam -lc -o pam_radius_auth.so
+#  ld -Bshareable pam_radius_auth.o md5.o -lpam -o pam_radius_auth.so

 ######################################################################
 #
--- pam_radius-1.3.17/md5.c 2007-03-25 21:21:07.000000000 -0700
+++ pam_radius-1.3.17.fixed/md5.c   2012-12-07 20:11:17.000000000 -0800
@@ -173,7 +173,8 @@
     MD5Transform(ctx-&gt;buf, (uint32_t *) ctx-&gt;in);
     byteReverse((unsigned char *) ctx-&gt;buf, 4);
     memcpy(digest, ctx-&gt;buf, 16);
-    memset(ctx, 0, sizeof(ctx));   /* In case it's sensitive */
+    //memset(ctx, 0, sizeof(ctx)); /* In case it's sensitive */
+    memset(ctx, 0, sizeof(*ctx));  /* In case it's sensitive */
 }

 #ifndef ASM_MD5
--- pam_radius-1.3.17/pam_radius_auth.c 2007-03-26 02:36:13.000000000 -0700
+++ pam_radius-1.3.17.fixed/pam_radius_auth.c   2012-12-07 20:13:21.000000000 -0800
@@ -57,9 +57,9 @@
 #include &lt;limits.h&gt;
 #include &lt;errno.h&gt;

-#ifdef sun
+//#ifdef sun
 #include &lt;security/pam_appl.h&gt;
-#endif
+//#endif
 #include &lt;security/pam_modules.h&gt;

 #include ""pam_radius_auth.h""
@@ -766,7 +766,9 @@
 talk_radius(radius_conf_t *conf, AUTH_HDR *request, AUTH_HDR *response,
             char *password, char *old_password, int tries)
 {
-  int salen, total_length;
+  //int salen, total_length;
+  socklen_t salen;
+  int total_length;
   fd_set set;
   struct timeval tv;
   time_t now, end;
@@ -1099,7 +1101,7 @@
     DPRINT(LOG_DEBUG, ""Got PAM_RUSER name %s"", userinfo);

     if (!strcmp(""root"", user)) {
-      user = userinfo;
+      user = *userinfo;
       DPRINT(LOG_DEBUG, ""Username now %s from ruser"", user);
     } else {
       DPRINT(LOG_DEBUG, ""Skipping ruser for non-root auth"");
--- pam_radius-1.3.17/pam_radius_auth.h 2007-03-25 22:35:31.000000000 -0700
+++ pam_radius-1.3.17.fixed/pam_radius_auth.h   2012-12-07 20:07:34.000000000 -0800
@@ -15,6 +15,7 @@
 #include &lt;stdarg.h&gt;
 #include &lt;utmp.h&gt;
 #include &lt;time.h&gt;
+#include &lt;sys/time.h&gt;
 #include &lt;netinet/in.h&gt;
 #include &lt;netdb.h&gt;
 #include &lt;fcntl.h&gt;
</code></pre>

<hr>

<p>Save patch as <code>pam_radius.patch</code>.  Extract source into sub-directory <code>pam_radius-1.3.17</code>.  Apply patch using:</p>

<pre><code>$ cd pam_radius-1.3.17
$ patch -p1 --dry-run -i ../pam_radius.patch --verbose
Hmm...  Looks like a unified diff to me...
The text leading up to this was:
--------------------------
|--- pam_radius-1.3.17/Makefile 2007-03-25 21:22:11.000000000 -0700
|+++ pam_radius-1.3.17.fixed/Makefile   2012-12-07 20:26:17.000000000 -0800
--------------------------
Patching file Makefile using Plan A...
Hunk #1 succeeded at 55.
Hmm...  The next patch looks like a unified diff to me...
The text leading up to this was:
--------------------------
|--- pam_radius-1.3.17/md5.c    2007-03-25 21:21:07.000000000 -0700
|+++ pam_radius-1.3.17.fixed/md5.c  2012-12-07 20:11:17.000000000 -0800
--------------------------
Patching file md5.c using Plan A...
Hunk #1 succeeded at 173.
Hmm...  The next patch looks like a unified diff to me...
The text leading up to this was:
--------------------------
|--- pam_radius-1.3.17/pam_radius_auth.c    2007-03-26 02:36:13.000000000 -0700
|+++ pam_radius-1.3.17.fixed/pam_radius_auth.c  2012-12-07 20:13:21.000000000 -0800
--------------------------
Patching file pam_radius_auth.c using Plan A...
Hunk #1 succeeded at 57.
Hunk #2 succeeded at 766.
Hunk #3 succeeded at 1101.
Hmm...  The next patch looks like a unified diff to me...
The text leading up to this was:
--------------------------
|--- pam_radius-1.3.17/pam_radius_auth.h    2007-03-25 22:35:31.000000000 -0700
|+++ pam_radius-1.3.17.fixed/pam_radius_auth.h  2012-12-07 20:07:34.000000000 -0800
--------------------------
Patching file pam_radius_auth.h using Plan A...
Hunk #1 succeeded at 15.
done
$
</code></pre>

<p>That's a dry-run; remove that option to actually apply the patch.</p>

<p>Tested on Mac OS X 10.7.5 using:</p>

<pre><code>$ cc --version
Apple clang version 4.1 (tags/Apple/clang-421.11.65) (based on LLVM 3.1svn)
Target: x86_64-apple-darwin11.4.2
Thread model: posix
$
</code></pre>

<p>When compiled with GCC 4.7.1, I get one residual warning:</p>

<pre><code>$ make CC=gcc
gcc -Wall -fPIC -c pam_radius_auth.c -o pam_radius_auth.o
pam_radius_auth.c: In function ¡®pam_private_session¡¯:
pam_radius_auth.c:1290:7: warning: variable ¡®ctrl¡¯ set but not used [-Wunused-but-set-variable]
gcc -Wall -fPIC   -c -o md5.o md5.c
gcc -shared pam_radius_auth.o md5.o -lpam -lc -o pam_radius_auth.so
$ gcc --version
gcc (GCC) 4.7.1
Copyright (C) 2012 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
$
</code></pre>

<h3>Warning</h3>

<p>I only got the code to compile; I did not test it!</p>
",0
13774213,13774164,1,"<p>This line:</p>

<pre><code>fscanf(file, ""%[^,]%*c %i%*c %i%*c"", &amp;name, &amp;num1, &amp;num2);
</code></pre>

<p>should be</p>

<pre><code>sscanf(namecopy, ""%[^,]%*c %i%*c %i%*c"", &amp;name, &amp;num1, &amp;num2);
</code></pre>
",2
13440245,13438941,1,"<p>I recommend you do make three ""Random Access Files"" (because they are more organized), but first:</p>

<ul>
<li>You need to format each file with the structure It will use, in the first file the structure [1] You just need one member the name (char array), in the second structure [2] you need three members the name (char array) and 2 values (I suppose two integers), and the third stricture is the same as the second so you can re-utilize it.</li>
</ul>

<p>[1]</p>

<pre><code>/* Struct for the first file. */
typedef {
    char name[4];
} file1_t;
</code></pre>

<p>[2]</p>

<pre><code>/* Struct for the second file. */
typedef {
    char name[4];
    int value1, value2;
} file2_t;
</code></pre>

<ul>
<li><p>To create those files you will have to use a code like this (Supposing that the file is opened in ""wb"" mode, but not created):</p>

<pre><code>/* This is an incomplete example (I can't make your whole Homework)*/

void file2Creator( FILE *fPtr )
{
    int i; // Counter to create the file.
    file2_t data = { """", 0, 0 }; // A blank example to format the file.

    /* You will create 9 consecutive records*/
    for( i = 1; i &lt;= 9; i++ ){
        fwrite( &amp;data, sizeof( file2_t ), 1, fPtr );
    }

    fclose( fPtr ); // You can close the file here or later however you need.  
}
</code></pre></li>
<li><p>After that you have to fill the blank spaces you made (I suppose the file is opened):</p>

<pre><code>void fillFile2( FILE *fPtr)
{
    int position;
    file2_t data = { """", 0, 0 };


    printf( ""Enter the position to fill (1-9) 0 to finish:\n?"" );
    scanf( ""%d"", &amp;position );

    while( position != 0 ){
        printf( ""Enter the name, and the two other values (integers):\n?"" );
        fscanf( stdin, ""%s%d%d"", data.name, data.value1, data.value2 );

        /* You have to seek the pointer. */
        fseek( fPtr, ( position - 1 ) * sizeof( file2_t ), SEEK_SET );
        fwrite( &amp;data, sizeof( file2_t ), 1, fPtr );
        printf( ""Enter a new position (1-9) 0 to finish:\n?"" );
        scanf( ""%d"", &amp;position );
    }

    fclose( fPtr ); //You can close the file or not, depends in what you need.
}
</code></pre></li>
<li><p>Now i imagine that you have the file1, file 2 and file 3 formatted, and the file 1 and 2 are filled, and you want to fill the file 3 how to do it? Simple.</p>

<pre><code>/* 3 pointers to each file */
void fillFile3( FILE *f1Ptr, FILE *f2Ptr, FILE *f3Ptr )
{
    int i, j, k, number;
    char word[ 4 ];
    file1_t data1 = { """" };
    file2_t data2, data3 = { """", 0, 0 };

    k = 1;

    /* I suppose that files are opened with their correctly FILE pointers. */
    for( i = 1; i &lt;= 5; i++ ){

        /* I locate in the ""i"" position of the file1. */
        fseek( f1Ptr, ( i - 1 ) * sizeof( file1_t ), SEEK_SET );

        /* I read the slot. */
        fread( &amp;data1, sizeof( file1_t ), 1, f1Ptr );

        /*Now we compare the file2 until we find the correct value, if it is organized we can jump some slots if not compare with all.*/
        for( j = 1; j &lt;= 9, j++ ){
            fseek( f2Ptr, ( j - 1 ) * sizeof( file2_t ), SEEK_SET );
            fread( &amp;data2, sizeof( file2_t ), 1, f2Ptr );

            /* We compare the strings, If they are equal we paste the value in file 3*/
            if( strcmp( data1.name, data2.name ) == 0 ){

               /*file 3 is of type of the file 2*/
               fseek( f3Ptr, ( k - 1 ) * sizeof( file2_t ), SEEK_SET );
               fwrite( &amp;data2, sizeof( file2_t ), 1, f3Ptr );
               k++;
               break;
            }
        }
    }
    fclose( f1Ptr );
    fclose( f2Ptr );
    fclose( f3Ptr );
}
</code></pre></li>
</ul>
",0
13463469,13438941,0,"<p>I am tring to do this program but it just wont run.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    FILE *fp1 ,*fp2;
    char ca , cb;
    int i,j,x,s;
    char A[i][j],B[i][j];
    char file1[1024], file2[1024];

    printf( ""Enter file1: "", file1 );
    gets( file1 );
    printf( ""Enter file2: "",file2 );
    gets( file2 );
    fp1=fopen( file1, ""r"");

    if ( fp1 == NULL ){
        printf(""Cannot open %s for reading \n"", file1 );
        exit(1);
    }

    while ( ( fgets( file1, sizeof file1, stdin ) ) != EOF ){
        for(i=0;i&lt;2500;i++){
            for(j=0;j&lt;5;j++){
                fscanf(fp1,""%s"",&amp;A[i][j]);
            }
        }
    }

    fp2 = fopen( file2, ""r"");

    if ( fp2 == NULL ){
        printf(""Cannot open %s for reading \n"", file2 );
        exit( 1 );
    }

    while ( fgets ( file2, sizeof file2, stdin) != EOF){
        for( i = 0; i &lt; 2500; i++ ){
            for( j = 0; j &lt; 5; j++ ){
                fscanf(fp2,""%s"",&amp;B[i][j]);
            }
        }
    }
    /*Here it was a ; without any sense (after the if)*/
    if( strcmp( A[i][j], B[i][j] ) ) == 0;
    {
        printf( ""%s /n %s  "", strcmp( A[i][j], B[i][j] ) );
    }

    fclose(fp1);
    fclose(fp2);

    return 0;
}
</code></pre>

<p>the compiler shows syntax error befor ""=="" token ( 8th line from bottom at strcmp function). Any help ??</p>
",0
13463644,13438941,0,"<p>You added a  semicolon after the if, and forgot a parenthesis.</p>

<pre><code>if( strcmp( A[i][j], B[i][j] ) == 0 ){
        printf( ""%s /n %s  "", strcmp( A[i][j], B[i][j] ) );
}
</code></pre>
",1
14784261,14784231,1,"<p>printf works on <code>stdout</code> which is a FILE*. The read() and write() calls work directly on file descriptors.</p>

<p>A FILE* is usually buffered, meaning the stuff you printf resides in a buffer in your program until it is flushed. While write() sends the data directly to the operating system, without any buffering in your application.</p>

<p>So flush the FILE* buffer to make output appear:</p>

<pre><code>int main(int argc, char** argv)
{
  char val[70];
  int x=3;
  printf(""Hello"");
  fflush(stdout);
</code></pre>

<p>And if stdout is your terminal, it is usually auto flushed when you write a newline, e.g.   <code>printf(""Hello\n"");</code></p>
",0
14784277,14784231,1,"<p>What you are saying is not what happens. Your main function will immediately return 0. Here is an example debugging in:</p>

<pre><code>(gdb) break main
Breakpoint 1 at 0x40074b: file ./test.cpp, line 6.
(gdb) run
Starting program: /tmp/test 

Breakpoint 1, main (argc=1, argv=0x7fffffffe528) at ./test.cpp:6
6       int x=3;
Missing separate debuginfos, use: debuginfo-install glibc-2.16-28.fc18.x86_64 libgcc-4.7.2-8.fc18.x86_64 libstdc++-4.7.2-8.fc18.x86_64
(gdb) next
7       if(x&gt;5)
(gdb) 
19  }
(gdb) 
0x00007ffff7744a05 in __libc_start_main () from /lib64/libc.so.6
(gdb) 
Single stepping until exit from function __libc_start_main,
which has no line number information.
[Inferior 1 (process 4962) exited normally]
(gdb) 
</code></pre>

<p>In fact, with optimizations enabled, the whole <code>if</code> check with its body is eliminated as a dead code, resulting in a nice main function like this:</p>

<pre><code>int main()
{
    return 0;
}
</code></pre>

<p>Which is confirmed by looking at the binary code (<code>objdump -CD -M intel</code>):</p>

<pre><code>00000000004004c0 &lt;main&gt;:
  4004c0:       31 c0                   xor    eax,eax
  4004c2:       c3                      ret    
  4004c3:       90                      nop
</code></pre>

<p>Perhaps it is a good time for you to learn how to debug your code. Start by reading some <a href=""http://www.gnu.org/software/gdb/documentation/"" rel=""nofollow"">GDB documentation</a>.</p>

<p>Good Luck!</p>
",0
13464204,13464139,1,"<p>Replace</p>

<pre><code>if (option == '1')
</code></pre>

<p>with</p>

<pre><code>if (option == '1' &amp;&amp; totalinput &lt; MAX)
</code></pre>

<p>And option 1 is disabled when the maximum number has been reached.</p>

<p>You might want to add the check earlier as well, so you do not <code>printf()</code> option 1 if it has been disabled.</p>

<p><strong>Note</strong>: You have both <code>i</code> and <code>totalinput</code>. I think it would be better (more understandable) if you remove <code>i</code> and only use <code>totalinput</code>. (as <code>totalinputs</code> is more descriptive than <code>i</code>)</p>
",6
13419237,13419150,2,"<p><code>clock_t</code> is not a <code>float</code>, but an integer type, most probably a <code>long</code>.</p>

<p>So you might use <code>%ld</code> to <code>printf()</code> it.</p>

<hr>

<p>Also <code>clock()</code> does not return seconds, but CPU ticks. So to get seconds the value returned by <code>clock()</code> shall be devided by the system constant <code>CLOCKS_PER_SEC</code>.</p>
",2
13419250,13419150,0,"<p>phil you did in the right way (maybe you should also divide by CLOCKS_PER_SEC)</p>

<pre><code>   float time = (float)(end_time-start_time)/(float)CLOCKS_PER_SEC;
   printf(""The running time is %f"", time);
</code></pre>

<p>and don't forget to cast as ""float"" because if you have as result 0.5 it will be rounded down to 0.0 because of integer division.</p>

<p>After that how much time takes you program to execute? because as far as I know, clock has a capability of measuring time of few milliseconds, so if you program takes less time than few milliseconds, it is likely to not detect this time (clock is very good for measuring times of several seconds with relatively good precision)</p>
",4
14203112,14203084,6,"<p>It is a function that receives a <code>void*</code>. This may be used to pass any kind of pointer in C.</p>

<p>A good example is the <a href=""http://www.kernel.org/doc/man-pages/online/pages/man3/pthread_create.3.html"" rel=""nofollow""><code>pthread_create</code></a> function, and the pthread start routine.</p>

<p>Note, however, that if no return type is specified, it defaults to return an <code>int</code>, which it does not in your example.</p>
",3
14203115,14203084,2,"<p>A <code>void *</code> is a pointer to <em>any</em> data, i.e. to data of an unknown or unspecified type.</p>
",0
14203117,14203084,2,"<p><code>param</code> is a void pointer means pointer to any data type . You may call generic type pointer.</p>

<p>e.g.</p>

<pre><code>func(void *param)
{
// body 
}
</code></pre>

<p>call like this :</p>

<pre><code>char* cptr;
int* iptr;
float* fptr;

func(cptr);
func(iptr);
func(fptr);
</code></pre>
",0
14203127,14203084,0,"<p>It means the param of type void* (reference to a void), which is the size of a memory location . You can reference any memory location with this, which in practice anything. </p>
",0
14203613,14203084,1,"<p><code>param</code> has type <code>void *</code>, which in C serves as a ""generic"" pointer type; any object pointer type can be converted to <code>void *</code> and vice versa without need for an explicit cast (some implementations allow function pointer types to be converted to <code>void *</code>, but that's not universal and not guaranteed by the language standard).</p>

<p>Note that a <code>void</code> pointer may not be dereferenced, so you can't do something like <code>x = *param</code> in the body of the function.  You'd have to convert the pointer to a different type such as <code>int *</code> or <code>double *</code> or whatever to get what it points to.  And that depends on what <code>function</code> is supposed to do with it.  </p>
",0
20632569,20632446,2,"<p>I feel that the code you posted is quite incomplete, so I'm mostly guessing here...</p>

<p>In your function <code>processXML</code> what happens if the condition is not met?</p>

<pre><code>void processXML(char *start, char *stop, GTree* t)
{
    tic *ti ; 
    if (triP != NULL &amp;&amp; (key = g_tree_lookup (t, triP))!= NULL )
        ti = (ticP)key;
    //or else???
    fillFields(ti);
}
</code></pre>

<p>What happens is that <code>ti</code> is left uninitialized, and so any use of it will result in Undefined behavior. You are lucky and you are getting an <em>out of bounds</em> error.</p>

<p>What you probably want is:</p>

<pre><code>void processXML(char *start, char *stop, GTree* t)
{
    //where is key declared, BTW???
    if (triP != NULL &amp;&amp; (key = g_tree_lookup (t, triP))!= NULL )
    {
        tic *ti = (ticP)key;
        fillFields(ti);
    }
    // or else do nothing
}
</code></pre>

<p>That's why I always recommend to declare variables nearest to their use. This way <code>ti</code> is never uninitialized, and so your original mistake is impossible.</p>
",6
13469155,13468972,3,"<p>A probable cause is the size argument passed to <a href=""http://en.cppreference.com/w/c/algorithm/qsort"" rel=""nofollow""><code>qsort()</code></a>. From the linked reference page for <code>qsort()</code>:</p>

<blockquote>
  <p><strong>size</strong> - size of each element in the array in bytes</p>
</blockquote>

<p>Therefore the size argument should be <code>1</code>, which is guaranteed to be <code>sizeof(char)</code>, and not <code>sizeof(char*)</code> which is likely to be <code>4</code> or <code>8</code>. The posted code incorrectly informs <code>qsort()</code> that <code>word</code> is pointing to an array of <code>4</code> (or <code>8</code>) times larger than the actual array and <code>qsort()</code> will access memory it is not supposed to. Change to:</p>

<pre><code>qsort(word,strlen(word), 1, charCompare);
</code></pre>

<p>Another possible cause is buffer overrun caused by this line:</p>

<pre><code>strncpy(&amp;a.sorted[i],word,sizeof(word));
</code></pre>

<p><code>i</code> is being incremented on every iteration of the <code>while</code> loop but <code>sizeof(word)</code> is always being written. The values of <code>SIZE</code> and <code>BUFSIZ</code> are not posted but even if they were equal the <code>strncpy()</code> will write beyond the bounds of <code>a.sorted</code> after the first iteration.</p>

<p>Other points:</p>

<ul>
<li><a href=""http://en.cppreference.com/w/c/io/fgets"" rel=""nofollow""><code>fgets()</code></a> is not guaranteed to read the new-line character so check return value of <code>strchr()</code> before dereferencing it.</li>
<li><a href=""http://en.cppreference.com/w/c/string/byte/tolower"" rel=""nofollow""><code>tolower()</code></a> returns the lowercase character, it does not change its argument.</li>
<li>why read into a temporary buffer (<code>word</code>) and copy? Just read directly into the <code>struct</code> members.</li>
</ul>
",6
13421547,13421501,4,"<p><code>atoi</code> is a function that gives you no means to analyze error conditions. On top of that, it produces undefined behavior in overflow situations. Don't ever use <code>atoi</code> (or <code>atof</code> or anything from <code>ato...</code> group) in real-life programs. It is practically useless.</p>

<p>To perform string-to-number conversions use <code>strtol</code> (and other functions from <code>strto...</code> group).</p>

<p>Now, what is inside your <code>num</code> at the moment you call your <code>atoi</code>? Is your <code>num</code> properly zero-terminated?</p>
",6
19380307,19380217,4,"<p>The function <code>getclip()</code> returns an <code>int</code>, and <code>fprintf</code> expects pointer to char. It is trying to access an invalid memory position: you're returning a <code>HANDLE</code> as <code>int</code> and then <code>fprintf</code> interprets that as a memory address to read characters from. </p>

<p>Please look at your compiler errors and warnings and fix your code.</p>
",1
14173291,14173274,4,"<pre><code>dir[k].weight=atol(strtok(NULL,"",""));
dir[k].height=atol(strtok(NULL,""\n""));
</code></pre>

<p><a href=""http://linux.die.net/man/3/atol"" rel=""nofollow"">atol</a> reads a <code>long</code>. You probably wanted <a href=""http://linux.die.net/man/3/atof"" rel=""nofollow"">atof</a>.</p>
",0
14173293,14173274,3,"<pre><code>dir[k].weight=atol(strtok(NULL,"",""));
dir[k].height=atol(strtok(NULL,""\n""));
</code></pre>

<p>You are using a function that converts to integers, so that doesn't know how to handle fractional parts. Use <code>strtof</code> instead, that even allows for error checking, in contrast to the <code>ato*</code> functions.</p>
",0
14173322,14173274,1,"<p>Here:</p>

<pre><code>dir[k].weight=atol(strtok(NULL,"",""));
dir[k].height=atol(strtok(NULL,""\n""));
</code></pre>

<p>You are reading values as long</p>
",0
13433956,13433915,6,"<p>In the line</p>

<pre><code>srchbuff[i] = '\0';
</code></pre>

<p>you write one byte beyond the end of srchbuff.</p>

<p>The memory <code>srch</code> points to, is not initialized. So anything might happen.</p>

<p><code>cur</code> is also not initialized. This means <code>cur</code> points anywhere and so does <code>cur-&gt;name</code>.</p>
",5
13433979,13433915,1,"<p>Besides using uninitialised memory in <code>srch</code>, you have no condition to stop the loop at the end of the list. You should modify it to something like this:</p>

<pre><code>while (cur != NULL &amp;&amp; strcmp(cur-&gt;name, srch) != 0){
   cur = cur-&gt;next;
}
</code></pre>

<p>Otherwise at the end of the list, <code>cur</code> would become <code>NULL</code> and null pointer dereference would occur at <code>cur-&gt;name</code> on the next iteration.</p>
",0
13491683,13491444,1,"<p>Although the time_t structure returned by time() is most likely a number of seconds, you should not be performing maths on it.  Instead use difftime()</p>

<pre><code>double difftime ( time_t time2, time_t time1 );
</code></pre>

<p>Calculates the difference in seconds between time1 and time2.</p>

<p>You do not need to call <code>main()</code> from within <code>main()</code> and I'm not sure why you would think that is a good idea.</p>

<p>Also, <code>getchar()</code> will wait for a key to be pressed, so it won't be counting time in the background.</p>
",0
13492320,13491444,2,"<p>Use <code>select()</code> function to set a timeout for your scanf</p>

<p>The following code is an example of how use it.</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/time.h&gt;

int main(void)
{
    int x;
    fd_set          set;
    struct          timeval timeout = {0};

    FD_ZERO(&amp;set);


   while(1)
   {
        timeout.tv_sec = 30;
        FD_SET(fileno( stdin ), &amp;set);
        printf (""enter a number:"");
        fflush (stdout);
        if (select(FD_SETSIZE, &amp;set, NULL, NULL, &amp;timeout))
        {

           scanf(""%d"", &amp;x);
           printf(""The number you put is %d\r\n"",x);

        }
        else
        {
                printf(""\r\nTimeout: Stop reading\r\n"");
                break;
        }
    }
}
</code></pre>
",7
13491843,13491444,0,"<p>This task is usually done using threads. In one thread <code>getchar</code> is called which blocks the thread execution, another thread does <code>sleep()</code> and then kills the first thread.</p>

<p>Another way to do this is to use non-blocking <code>read()</code> from the standard input using <code>pselect (2)</code>, but it's more tricky and does not suit small applications well. </p>

<p>Though a solution with <code>pthreads</code> in unix-style is quite verbose:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;time.h&gt;
#include &lt;pthread.h&gt;

struct read_int {
    int success;
    int value;
    struct timespec timeout;
};

void* read_thread(void *arg) {
    struct read_int *s = arg;
    printf(""Enter a number: "");
    scanf(""%d"", &amp;s-&gt;value);
    s-&gt;success = 1;
    return NULL;
}

#define CHECK_RET(ret, func) \
    if (ret) { fprintf(stderr, func""() == %d\n"", ret); return ret; }

int main() {
    pthread_t rthr;
    pthread_attr_t thr_attr;

    struct read_int s = { 0 };
    int ret;

    ret = clock_gettime(CLOCK_REALTIME, &amp;s.timeout);
    if (ret == -1) { fprintf(stderr, ""clock_gettime() == %d\n"", ret);  return ret; }

    s.timeout.tv_sec += 5;

    ret = pthread_attr_init(&amp;thr_attr);
    CHECK_RET(ret, ""pthread_attr_init"");

    ret = pthread_create(&amp;rthr, &amp;thr_attr, read_thread, &amp;s);
    CHECK_RET(ret, ""pthread_create"");

    ret = pthread_attr_destroy(&amp;thr_attr);
    CHECK_RET(ret, ""pthread_attr_destroy"");

    pthread_timedjoin_np(rthr, NULL, &amp;s.timeout);

    if (s.success) {
        printf(""\ngot value %d\n"", s.value);
    } else {
        pthread_cancel(rthr);
        printf(""\nTimed out, exiting...\n\n"");
    }
}
</code></pre>
",0
14203444,14203321,2,"<p>You see undefined behavior: <code>sizeof(list)</code> is probably 4 or 8 bytes, depending on the architecture, so <code>memset</code> with zeros does not go past the forth byte. You are reading from the third 32-bit <em>word</em>, which came from <code>malloc</code> and has not been initialized by the <code>memset</code> yet. Moreover, you are allocating 12 bytes (<code>size/8.0</code> gets converted to <code>int</code>; it never makes sense to pass a <code>float</code> or a <code>double</code> to <code>malloc</code>, because you cannot allocate fractional bytes) so accessing the 98-th bit goes past the allocated area.</p>

<p>You should fix these undefined behaviors: allocate enough memory by using</p>

<pre><code>// count needs to be a multiple of sizeof(int)
// The math gets pretty ugly here, but it should work:
int count = sizeof(int)*(size+(8*sizeof(int))-1)/(8*sizeof(int));
int * list = malloc(count);
</code></pre>

<p>Then initialize the data to zero by using the proper size:</p>

<pre><code>memset(list, 0, count);
</code></pre>
",2
14203482,14203321,0,"<p>You're writing in memory you do not own, that has an undefined behavior.</p>

<p>Firstly, you're allocating only 12 bytes here:</p>

<pre><code>int* list = malloc(size / 8.0);
</code></pre>

<p>You should do this (just giving you the idea, I don't know how many bytes you really want to allocate..):</p>

<pre><code>int* list = malloc((size / 8.0) * sizeof(*list));
</code></pre>

<p>Secondly, you are memsetting only 4 bytes (if you're on 32bits system) here:</p>

<pre><code>memset(list, 0, sizeof list);
</code></pre>

<p>You should do this:</p>

<pre><code>memset(list, 0, (size / 8.0) * sizeof(*list));
</code></pre>

<p>Finally, the only reason your call to <code>fopen()</code> changes things, is because <code>fopen()</code> allocates memory.</p>

<p>Good luck.</p>
",0
13443268,13443175,1,"<p>Allocate a 2 dimensional character array dynamically for krajina.</p>

<p>Refer this question:
<a href=""https://stackoverflow.com/questions/13304278/multi-dimensional-array-allocation"">2 Dimensional Memory Allocation</a></p>

<p>EDIT: Elaboration:</p>

<p>Alright. You said you can count the number of countries. Say you store that in a variable called <code>count</code> ok?</p>

<p>Now you need to allocate a 2D character array with <code>count</code> number of rows and 31 columns right? You do this as follows.</p>

<pre><code>int i = 0;
int **country = NULL;

if (!(country = calloc(count, sizeof(*country)))) //allocate rows
    return (0);
for (i = 0; i &lt; count; i++)
{
    country[i] = calloc(31, sizeof(*(country[i]))); //allocate columns
}
</code></pre>

<p>Now you have the <code>country</code> variable which you can use normally like how you would use a 2d char array (like youve used in your code)</p>
",7
13776617,13776588,2,"<p>In C you don't. Give them a different name, it's confusing and a bad practice anyway.</p>
",0
13776627,13776588,4,"<p><s>In C there's no way.</s> actually, introducing an extra scope and with an <code>extern</code> declaration you can, see @Potatoswatter's answer. </p>

<p>In C++ you can look up identifiers in the global namespace using <code>::</code> (as in <code>::m=15</code>), which, by the way, is the same operator used to access members of ""regular"" namespaces (<code>std::cout</code>, ...). </p>

<p>Also, it's <code>int main()</code>. </p>
",0
13776635,13776588,0,"<p>same name is bad practice anyway until m is redefined you are accessing the global variable any way</p>

<pre><code> int m=20 ;  
 void main()  
 { 
   print m // 20 would be printed here .
  // max you can do 
   int m=30;  
 }
</code></pre>
",0
13776701,13776588,5,"<p>In C, you can. Of course this is just trivia, you should never do so in real life.</p>

<p>Declaring something <code>extern</code> can be done anywhere, and always links the declared variable to the global of that name.</p>

<pre><code>#include &lt;stdio.h&gt;

int i = 3;

int main( int argc, char **argv ) {
    int i = 6;

    printf( ""%d\n"", i );
    { // need to introduce a new scope
        extern int i; // shadowing is allowed here.

        printf( ""%d\n"", i );
    }
    return 0;
}
</code></pre>

<p>In C++, the global is always available as <code>::i</code>.</p>
",2
18766813,18766767,2,"<p>This line <code>gets(&amp;str[i][1000]);</code> should be </p>

<pre><code> gets(str[i]);
</code></pre>

<p>But since <code>gets()</code> is deprecated you should really use</p>

<pre><code>fgets (str[i], 1000, stdin);
</code></pre>

<p><br>
A similar error appears on this line <code>ptr=strtok(&amp;str[i][1000],"" "");</code></p>
",4
18766907,18766767,2,"<p>You are corrupting the stack by passing &amp;str[2][1000](3rd iteration of loop) to gets/strtok, which actually points to str[3] which is out of array bounds. You should simply pass str[i] or &amp;str[i][0] to gets/strtok.</p>
",0
18766877,18766767,1,"<p>This:</p>

<pre><code>gets(&amp;str[i][1000]);
</code></pre>

<p>is very wrong, it gives <code>gets()</code> a pointer to the last character of each line, where (for the last line) there is no more space.</p>

<p>It should be:</p>

<pre><code>if(fgets(str[i], sizeof str[i], stdin) == NULL)
{
  fprintf(stderr, ""**Failed to read line %d\n"", i);
  exit(1);
}
</code></pre>

<p>Note that <a href=""http://linux.die.net/man/3/fgets"" rel=""nofollow""><code>fgets()</code></a> is much safer, you should avoid using <code>gets()</code>. You should also <em>check the return value</em> to make sure it succeeded.</p>
",1
14230104,14230019,0,"<p>No, it's not a particularly good idea. It means that any experienced C programmer reading your code has to find out what <code>EQ</code> and <code>AND</code> mean before he can read your code.</p>

<p>Sure, <code>==</code> can be error-prone, but IMHO the best solution to that problem is to (a) turn on warnings in your compiler, and (b) <em>be careful</em>.</p>

<p>(The standard header <code>&lt;iso646.h&gt;</code> provides a macro <code>and</code> that expands to <code>&amp;&amp;</code>, but it doesn't provide a macro for <code>==</code>. The point of <code>&lt;iso646.h&gt;</code> was to support systems on which certain characters are difficult to use due to old national variant character sets, not to provide more readable alternatives.)</p>
",0
14230108,14230019,0,"<p>Actually, I don't think there is a problem here. Any modern compiler will issue a warning if something fishy will be detected. </p>
",0
14230123,14230019,1,"<p>that's a bad idea
the best thing to do is compile with all warning flags activated (-Wall) and make sure that you can compile your code without warnings</p>

<p>and TDD. It's more about practices that the syntax</p>

<p>I would recommend the book ""Code Complete""</p>
",3
14230144,14230019,3,"<p>Personally I prefer not to touch the very fundamental syntax of the language, like creating macros to replace C keywords or operators.</p>

<p>In this case it is pretty simple, and may not alter much the readability, but other programmers (if you are not the only one maintaining the code) seeing those macros may be tempted to create other macros for something else they <em>think</em> is ambiguous or error prone.</p>

<p>So I would not endorse macros at the keywords / operators level in C.<br>
But you may use some compiler options to show when there is an ambiguity, like</p>

<pre><code>  gcc -Wall prog.c -o prog
</code></pre>

<p>having <code>Wall</code> enabling all warnings (you can refine the warnings with gcc). This depends upon the compiler you are using.</p>

<p>For instance</p>

<pre><code>  int a=1,b=2;
  if (a = b) { ... }
</code></pre>

<p>would give a warning having gcc as compiler with the <code>-Wall</code> option.</p>
",0
14230221,14230019,1,"<p>To attempt to re-define the C language is always a very bad idea. To replace operators through macros will make the code unreadable to other C programmers.</p>

<p>Regarding &amp;&amp; accidentally turning into &amp;, I doubt it is an issue, at least I have never encountered that problem. There is already alternative logical operators in standard C, you should use those if anything.</p>

<blockquote>
  <p>The header <code>&lt;iso646.h&gt;</code> defines the following eleven macros (on the
  left) that expand to the corresponding tokens (on the right):</p>
</blockquote>

<pre><code>and     &amp;&amp;
and_eq  &amp;=
bitand  &amp;
bitor   |
compl   ~
not     !
not_eq  !=
or      ||
or_eq   |=
xor     ^
xor_eq  ^=
</code></pre>

<p>The idea of == being dangerous is a terribly old-fashioned idea. In the 80s, confused programmers invented obscure rules like ""always put the literal in front of the variable when doing comparison"", i.e <code>if (0 == var)</code>.</p>

<p>The correct way to avoid bugs related to this is to avoid assignment inside conditions. Once you have adopted that as good coding style, dodging such bugs is easy. To spot them has been a non-issue since the release of Turbo C in 1990. Since then, pretty much every single compiler has been able to warn for ""possibly incorrect assignment"" when you made an assignment inside an if statement.</p>

<p>In modern programming, all professional programmers use static analyser tools to spot all kinds of compile time bugs. If your compiler for some reason is unable to spot this bug, then the static analyser certainly will.</p>

<p>So to answer your question: yes it is clutter and makes the code more error-prone and less readable.</p>
",2
15820545,15820458,0,"<p>You could perform the check like this instead of using isdigit(). </p>

<pre><code>if( arg &amp;&amp; arg[0] &gt;= '1' &amp;&amp; arg[0] &lt;= '9' ) { // only accept '1' through '9'
</code></pre>

<p>The characters from '0' to '9' are always in adjacent order in C, so this check does what you need.</p>
",0
17081590,17081526,7,"<p>The <code>switch</code> statement is just a jump into the middle of a <code>for</code> loop (at <code>case</code> label 2).  Then the code executes the <code>for</code> loop.  Pretty much equivalent to:</p>

<pre><code>#include &lt;stdio.h&gt;

int main() {
    int i=5;

    goto label_2;

    for (  i=0; i&lt;10; i++ ) {
        printf(""A i=%d\n"",i);
      label_2:
        printf(""B i*i=%d\n"",i*i);
    };

  label_3:
    printf(""done"");

    return 0;
}
</code></pre>

<p>That's all there is to it.</p>
",3
17081617,17081526,1,"<pre><code>        for (  i=0; i&lt;10; i++ ) {
    case 1:
        printf(""A i=%d\n"",i);
    case 2:
        printf(""B i*i=%d\n"",i*i);
        };
</code></pre>

<p>So case 2 is inside the for loop, hence the repetition in the outputs. With a case you need to put in a break or it executes every case after the one it switches to.</p>

<pre><code>switch(2)
case 1: //blah
case 2: //blah
case 3: //blah
</code></pre>

<p>For this example above the code in cases 2 and 3 are ran whereas normally you write:</p>

<pre><code>switch(2)
case 1: //blah
    break;
case 2: //blah
    break;
case 3: //blah
    break;
</code></pre>

<p>In which case only case 2 is ran</p>
",2
14154111,14154074,0,"<p>You can¡¯t, because exec* functions replace the code of your program with the one passed as argument. Just use a fork (and a knife).</p>
",0
14154117,14154074,0,"<p>You don't need to ""switch"", after creating a child you have <em>two</em>  threads of execution happening in parallel (at least logically speaking).</p>

<p>If the child exits, the parent should continue with the code after the <code>wait()</code>, assuming that really is a valid call to the <code><a href=""http://linux.die.net/man/2/wait"" rel=""nofollow"">wait()</a></code> function.</p>
",1
13490561,13490471,6,"<p>What's wrong with this:</p>

<pre><code>struct test t;

memcpy(string, test-&gt;data, 19);
</code></pre>

<p>? Hint, <code>test</code> is a <em>type</em>.</p>

<p>EDIT: as to the real answer, see this question: <a href=""https://stackoverflow.com/questions/627364/zero-length-arrays-vs-pointers"">zero length arrays vs. pointers</a> (or similar questions on SO)</p>
",1
13490695,13490471,0,"<p>Array can't have <code>0</code> size .</p>

<p>Here is the Standard:</p>

<p>ISO 9899:2011 6.7.6.2:</p>

<pre><code>   If the expression is a constant expression, it shall have a value
   greater than zero
</code></pre>

<p>And second </p>

<p>use this:</p>

<pre><code>memcpy(string,t-&gt;data,19); instead of what you have used.
</code></pre>
",1
17385882,17385861,2,"<pre><code>sscanf(start, ""%d"", &amp;field, &amp;n)
</code></pre>

<p>You have too many arguments for your function call.</p>
",5
17385918,17385861,0,"<pre><code>while(sscanf(start, ""%d"", &amp;field, &amp;n)
</code></pre>

<p>It's been a while since I've done C but I don't think <code>n</code> is filled in as the length of the chars.</p>

<p>Do fscanf straight from your file and check the return to see if it got anything.</p>
",0
17385927,17385861,0,"<p>Your 'access violation' is no doubt coming from the fact that your variable 'n' is not getting initialized. Your sscanf(start, ""%d"", &amp;field, &amp;n) has, probably, not enough format specifiers so only the variable 'field' is getting set from that sscanf. This sscanf is not touching variable n so it is still uninitialized.</p>

<p>When you then add this uninitialized 'n' to your pointer 'start', you end up with an invalid address, and ultimately your access violation error.</p>
",1
18650136,18650101,1,"<p>Don't do this:</p>

<pre><code>int some_fun (int sts) {
    printf("" sts = %d"", ERRMAP( sts ));
    return (ERRMAP( sts ));
}
</code></pre>

<p>Someday if ERRMAP is modified to have a side-effect you'll get different results between what's printed and returned.</p>

<p>Also doing the calculation once is a good idea. This is best whether ERRMAP is a function or a macro: <code>int i = ERRMAP( sts );</code> </p>
",0
18650425,18650101,1,"<p>Presumably <code>A_ABS</code> is also a function like macro! The basic trick is to work it out in your head into pseudo machine code - lets say that <code>A_ABS</code> has a similar complexity and doesn't call any more things - then I would put each of them at about 20 op codes making a total of 40 - using them and assigning to a value then using that value twice would be 42 - while ""calling"" twice would be 80 so you work it out.</p>

<p><strong>BTW</strong> - you should only even think about doing this sort of macro, (i.e. function like), if you have tried using a function and your profiler has said it is one of the main reasons that your code is either too big or too slow.  The reasons:</p>

<ol>
<li>Errors in macros are hard for the compiler to report the location of - you have 5 lines of up to 80 characters but any compiler errors will just be reported where you ""call"" the code.</li>
<li>You are defeating type checking which is one of the major benefits of C/C++</li>
<li>Debugging other than as machine code is impossible as you can not
step through a macro.</li>
<li>It is a maintenance nightmare.</li>
<li>Compiler optimisers will often not do well on it.</li>
<li>Code checkers can not work well on macros</li>
<li>MISRA and other compilence checkers will fail your code.</li>
<li>It is usually unnecessary!</li>
</ol>
",0
18650214,18650101,3,"<p>Please don't worry about ""most efficient"" without having first done some sort of measurement that it matters.  Also ""efficient"" can mean many different things.  Efficient in terms of execution time?  Code size?  Memory usage?  ""Efficient"" is not a synonym for ""fastest"".</p>

<p>Rather than worrying about which is fastest, think about which way is clearest.  The most expensive time is programmer time.</p>
",4
18761991,18761908,6,"<p><code>getline()</code> function is already declared in <code>stdio.h</code> header file.if you want to redefine it in your file.  just modify as  <code>my_getline()</code>  </p>

<p>In this for loop you need to use <code>getchar()</code> not <code>getline()</code></p>

<pre><code>for(i=0; i&lt;lim-1 &amp;&amp; (c=getline())!='*' &amp;&amp; c!='\n'; i++)   

for(i=0; i&lt;lim-1 &amp;&amp; (c=getchar())!='*' &amp;&amp; c!='\n'; i++)  
</code></pre>

<p>You need to use pointer in your function  to get the input into line.other wise s is become local to the function.</p>

<pre><code>int my_getline(char *, int); //declaration   

int my_getline(char *s, int lim) //defination
{
//....
}
</code></pre>

<p>function call is same   </p>

<pre><code>len= my_getline(line, MAXLINE)
</code></pre>

<p>Finally use some conditional mechanism to get out of while loop in the main.  </p>
",1
18761962,18761908,3,"<p>The function <code>getline</code> is already declared in <code>stdio.h</code>. Rename your function to something else.</p>
",1
18761969,18761908,3,"<p><code>getline</code> is a function of the C standard library defined in <code>stdio.h</code>. The compiler want to use that version instead of yours.</p>

<p>Rename your function, for instance into <code>my_getline</code> and you should be fine.</p>
",1
18761977,18761908,1,"<p>Change the function name, getline exists already</p>
",0
14176663,14176620,3,"<p>You need to be careful with <code>char</code>; it's automatically promoted to <code>int</code> in a variadic function.  You will need to pass <code>int</code> as the second arg to <code>va_arg</code>.</p>
",1
14176703,14176620,1,"<p>When I compile your example (after fixing va_arg(pa, char)), the compiler (gcc 4.6) tells me</p>

<blockquote>
  <p>a.c: In function 'a_simple_func_with_variable_argument':<br>
  a.c:8:14: warning: 'char' is promoted to 'int' when passed through '...' [enabled by default]<br>
  a.c:8:14: note: (so you should pass 'int' not 'char' to 'va_arg')<br>
  a.c:8:14: note: if this code is reached, the program will abort  </p>
</blockquote>

<p>So no surprise here.</p>
",1
14780784,14779923,1,"<p>Looks like the line:</p>

<pre><code>bzero(st_arr[j],sizeof(st_arr));
</code></pre>

<p>Is a buffer overflow that tromps the stack, clearing part of the 'lines' buffer.</p>

<p>Not to mention the memory leaks done by having bzero erase these allocations in st_arr:</p>

<pre><code>st_arr[p]=malloc(strlen(token)+1);
</code></pre>

<p>Another bug is that you are null padding between each string read from file, then you strtok from the first string:</p>

<pre><code> char *token=strtok(lines,"" "");
</code></pre>

<p>This will only tokenize up to the first null, and thus miss all subsequent strings. You might have meant:</p>

<pre><code> char *token=strtok(lines[j],"" "");
</code></pre>
",0
20644487,20644404,0,"<p>The only change in your repeated code is the <code>table[i][0]=counter;</code> line.
Change the hard coded index value to a function parameter and write a function that contains the common code.</p>

<pre><code>void blammy(int blammyIndex)
{
    // assumes you make counter, s, remain, f available as needed.

    for (i=0; i&lt;1296; i++)
    {
        for (j=0; j&lt;1296; j++)
        {
            counter = 0;
            s[0]=0;
            s[4]=0;

            if (remain[j][0]!=-1)
            {
                feed(poss[i], remain[j], f);
                if (f[0]==s[0] &amp;&amp; f[4]==s[4])
                {
                    counter++;
                }
            }
            table[i][blammyIndex]=counter;
        }
    }
}
</code></pre>
",1
20645510,20644404,0,"<p>okay so let's say taking from a previous question i had similar to this one i understand that this code will help. in a case where i have as seen above on my first code where i have {0,0}{0,1}{0,2}{0,3}{0,4}{2,0}.... do i need to put it in a while loop for example? because i can't have this: {2,3} or {3,1} or {4,0}.
don't know if i'm clear please let me know and I appreciate all answers </p>

<pre><code>for (i=0; i&lt;1296; i++)
  {
       for (int k=0; k&lt;15; ++k)
   {
    s[0]=0;
    s[4]=k;
    for (j=0; j&lt;1296; j++)
    {
        counter = 0;
        if (remain[j][0]!=-1)
        {
            feed(poss[i], remain[j], f);
            if (f[0]==s[0] &amp;&amp; f[4]==s[4])
            {
                counter++;
            }
        }
        table[i][k]=counter;
      }
   }
}
</code></pre>

<p>I'm posting the answer as a question because last time i edited the question to a different way and people were not happy</p>
",0
14188800,14188781,3,"<pre><code>  if((write(fh, buffer, sizeof(buffer))) &gt;= 0){
</code></pre>

<p>You need to pass in the length of the buffer to your function.  sizeof(buffer) will return
the size of a char* data type (4 (32-bit)or 8 (64-bit) bytes).  </p>
",0
14188805,14188781,1,"<p>You really don't want to define your own <code>write()</code> because it will alias the system call C wrapper that is also called write.</p>

<p>Plus, if the buffer has a string in it, you will want to write exactly its length.</p>

<pre><code>void mywrite(char *buffer, char *target) {
. . .
    write(fh, buffer, strlen(buffer))
</code></pre>
",2
14188817,14188781,1,"<p>a) Your own function name is write</p>

<p>b) Use strlen instead of sizeof for last parameter of write.</p>

<p>So </p>

<p>a) Change your function name to something else other than write.</p>

<p>b) Instead of sizeof, use strlen.</p>
",0
13732839,13732821,1,"<p>You keep reusing the same pointer over and over. Try something like:</p>

<pre><code>filenames[i] = strdup(token);
</code></pre>

<p>You should also remember to <code>free(filenames[i])</code> when you're done with them.</p>

<hr>

<p>If you don't have <code>strdup</code> you can roll your own or just use:</p>

<pre><code>filenames[i] = malloc(strlen(token) + 1);    /* XXX check malloc return. */
strcpy(filenames[i], token);
</code></pre>
",1
17835486,17835281,2,"<p>You want to be able to dereference a chain starting with <code>e1</code> getting to <code>p</code> eventually.</p>

<p>Here is how you do that:</p>

<pre><code>printf(""%d\n"",*((*(e1-&gt;testpp))-&gt;p));
</code></pre>
",1
15584599,15584589,0,"<p>You need an</p>

<pre><code>#include &lt;stdlib.h&gt;
</code></pre>

<p>before you use <code>malloc</code>. You apparently declared the function wrong in your source. Never declare C standard library functions. Just include the headers that declare them. </p>
",0
15584606,15584589,0,"<blockquote>
  <p>Could you please tell me if the above statement is proper?</p>
</blockquote>

<p>No, it isn't: you're casting the return value of <code>malloc()</code> and you're missing the <code>&lt;stdlib.h&gt;</code> header.</p>
",0
15584617,15584589,1,"<p>In order to use <code>malloc</code> you will need to include <code>&lt;stdlib.h&gt;</code>. Additionally, allocate memory like </p>

<pre><code>node_t x = malloc(sizeof node_t);
</code></pre>

<p>You must not assign memory to stack-variables, but only to pointers. And never cast back to the allocated type, as <code>malloc</code> returns <code>void*</code> and this need not be casted explicitly.</p>
",0
15586178,15584589,0,"<p>You're getting the warning because you don't have a declaration for <code>malloc</code> in scope; you need to include the <code>stdlib.h</code> header file:</p>

<pre><code>#include &lt;stdlib.h&gt;
</code></pre>

<p>You should also drop the cast.  It isn't necessary, and under other compilers will suppress a diagnostic that you're trying to assign an <code>int</code> value to a pointer type.  </p>

<p><em>Please</em> do not hide pointers behind typedefs.  It's almost always a bad idea.  </p>
",0
13776426,13776383,0,"<p>Try adding call <code>setlinebuf(fdw1)</code> - this should help.</p>

<p>This call forces flushing buffer after newline. Also you can use <code>setvbuf()</code> with parameter <code>_IOLBF</code> to get the same effect or with <code>_IONBF</code> to disable buffering completely.</p>
",1
13448667,13448638,1,"<p>The content of var1 and var2 are undefined. Thus, they can contain any valid value (depending on many external factors).</p>

<p>It is pure luck that only the second var seams to be random. Try it on another day, after a reboot or after launching a few other programms and I bet the first var will have changed.</p>
",6
13448692,13448638,0,"<p>It's called local variables . Any local variables have <code>auto</code> storage specifier and these are located on stack in C.</p>

<p>Since you havn't initilaized these varaibles , so it will take any value called <code>garbage value</code> or <code>indeterminate value</code> (Language standard doesn't imposes any requirements that it must have specific value ) so you are getting any random value.</p>

<p>It's purely coincedence that you are getting same value for <code>var1</code> but not for <code>var2</code>.
But on any other system it might give different values or even on your system may after sometime.
So,Using uninitialized variables is <code>undefined behaviour</code> </p>
",0
13448703,13448638,0,"<p>In C, </p>

<p>If the variables are declared as Global or static, then they are automatically initialised to zero. But, if they are declared as local , then the values for those variables are indeterminate i.e .., depends on the compiler. (Some garbage value)</p>
",0
13448719,13448638,3,"<p>Your <em>C</em> program is compiled to some executable program. Notice that if you compile on Linux using <code>gcc -Wall</code>, you'll get warnings about uninitialized variables.</p>

<p>The <code>var1</code> and <code>var2</code> variables get compiled into using some stack slots, or some registers. These contain some apparently random number, which your program prints. (that number is not really random, it is just unpredictable garbage).</p>

<p>The <em>C</em> language does not mandate the implicit initialization of variables (in contrast with e.g. Java).</p>

<p>In practice, in <em>C</em> I strongly suggest to <strong>always explicitly initialize local variables</strong> (often, the compiler may be smart enough to even avoid emitting useless initialization).</p>

<p>What you observe is called <a href=""http://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow"">undefined behavior</a>.</p>

<p>You'll probably observe a different output for <code>var1</code> if you compiled with a different compiler, or with different optimization flags, or with a different environment (probably typing <code>export SOMEVAR=something</code> before running again your program could change the output for <code>var1</code>, or running your program with a lot of program arguments, etc...).</p>

<p>You could (on Linux) compile with <code>gcc -fverbose-asm -S</code> and add various optimization flags (e.g. <code>-O1</code> or <code>-O2</code> ...) your source code <code>yoursource.c</code> and look inside the generated <code>yoursource.s</code> assembler code with some editor.</p>
",0
13448722,13448638,2,"<p>In C, when you declare variables, that reserves some space for them on the stack. The stack is how C keeps track of which arguments are passed to which function, where variables are stored if you declare them statically within function, where return values are stored, and so on. Each time you call a function, it pushes values on the stack; that is, it writes those values to the next available space on the stack, and updates the stack pointer to account for this. When a function returns, it decrements the stack pointer, to point to where it pointed in the previous function call.</p>

<p>If you declare a variable, but you don't initialize it, you simply get whatever value was in there before. If another function has been called, you may get the arguments passed in to that function; or you might get the return address for the function you are returning to.</p>

<p>In the case that you present, you are showing the <code>main()</code> function, with no other functions called. However, in the process of loading your program, the dynamic linker has probably called several functions within your process space. So the values that you are seeing are probably left over from that.</p>

<p>You cannot depend on what these values are, however. They could be anything; they could be initialized to 0, they could be random data, they could be any sort of internal data.</p>
",0
13407973,13407879,1,"<p>I guess you use a type like char so an easy solution to not overflow is to do</p>

<pre><code>int tmp_ciphered = (my_char + shift) % 0xff;
char ciphered = (char)(tmp_ciphered);
</code></pre>

<p>thenyou turn and do not overflow, this is a ring</p>
",0
13407976,13407879,1,"<p>This duplicates (almost exactly) <a href=""https://stackoverflow.com/questions/12761720/c-simple-ceasar-cipher-algorithm/12761815#12761815"">c++ simple Caesar cipher algorithm</a>.   </p>

<p>Note that I don't agree with the accepted answer on that post.   Basically you have to map the characters back into the range using something like ((c-'a'+shift) % 26) + 'a'.   However that assumes your characters are in 'a'..'z'.  Might be safer to use c >= 'a' &amp;&amp; c &lt;= 'z' instead of islower as I'm not sure how locale will play into on non-English systems.  Similar for isupper and the other range.   Finally, you need an else clause to handle when the char is not in either range.  </p>
",3
13412404,13407879,1,"<p>The only truly portable way to do this involves building a lookup table for the input domain, and manually building the chars based on non-linear-assumptions. </p>

<p>Even for the restricted domain of <code>['a'..'z','A'..'Z']</code>, assuming 'A'..'Z' is contiguous is <strong>not</strong> defined by the language standard, and is provably not always the case. For any naysayers that think otherwise, I direct you to ordinal positions of characters in the chart <a href=""http://en.wikipedia.org/wiki/EBCDIC"" rel=""nofollow"">at this link</a>, paying close attention to the dead-zones in the middle of the assumed sequences. If you think ""Nobody uses EBCDIC anymore"", let me assure you both AS/400 and OS/390 are alive and well (and probably processing your US taxes right now, as the IRS is one of IBM's biggest customers).</p>

<p>In fact, the C standard is pretty explicit about this:</p>

<blockquote>
  <p><strong>C99-5.2.1.3</strong> In both the source and execution basic character sets, the value of each character after 0 in the above list of decimal digits shall be one greater than the value of the previous.</p>
</blockquote>

<p>Nowhere is there even a mention of defined ordering or even <em>implied</em> ordering on any other part of the character sets. In fact, <code>'0'..'9'</code> has one other unique attribute: they are the only characters guaranteed to be unaffected by locale changes.</p>

<p>So rather than assume a linear continuation exists for characters while thumbing our noses at the suspicious silence of the standard, let us define our own, <strong>hard</strong> map. I'lll not inline the code here like I normally do; if you're still with me you're genuinely interested in knowing and will likely read and critique the code below. But I will describe in summary how it works:</p>

<ol>
<li>Static-declare two alphabets, double in length (A..ZA..Z,a..za..z).</li>
<li>Declare two arrays (encrypt and decrypt) large enough to hold <code>(1&lt;&lt;CHAR_BIT)</code> entries.</li>
<li>Fully initialize both arrays with values corresponding to their indexes. Ex: <code>a[0]=0</code>,<code>a[1]=1</code>,...</li>
<li>Fill each location in the encrypt-array that is part of our alphabets from (1) with the proper value corresponding to the shift width Ex. <code>a['a'] = 'g'</code> for a ROT5.</li>
<li>Mirror (4) by working backward from the tail of the alphabet applying the opposite shift direction. Ex: `a['g'] = 'a'; </li>
</ol>

<p>You can now use the encryption array as a simple table to translate input text to cipher text:</p>

<pre><code>enc-char = encrypt[ dec-char ];
dec-char = decrypt[ enc-char ];
</code></pre>

<p>If you think it seems like a ton of work just to get source-level platform independence, you're absolutely right. But you would be <em>amazed</em> at the #ifdef #endif <strong>hell</strong> that people try to pass off as ""multi-platform"". The core goal of platform-independent code is to not only define <strong>common</strong> source, but define <em>behavior</em> as well. No matter what the platform, the concepts above will work. (and not a #ifdef in sight). </p>

<p>Thanks for taking the time to read this fiasco. Such a seemingly simple problem...</p>

<hr>

<p><strong>Sample main.cpp</strong></p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;limits.h&gt;
#include &lt;string.h&gt;

// global tables for encoding. must call init_tables() before using
static char xlat_enc[1 &lt;&lt; CHAR_BIT];
static char xlat_dec[1 &lt;&lt; CHAR_BIT];

void init_tables(unsigned shift)
{
    // our rotation alphabets
    static char ucase[] = ""ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ"";
    static char lcase[] = ""abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz"";
    int i=0;

    // ensure shift is below our maximum shift
    shift %= 26;

    // prime our table
    for (;i&lt;(1 &lt;&lt; CHAR_BIT);i++)
        xlat_enc[i] = xlat_dec[i] = i;

    // apply shift to our xlat tables, both enc and dec.
    for (i=0;i&lt;(sizeof(ucase)+1)/2;i++)
    {
        xlat_enc[ lcase[i] ] = lcase[i+shift];
        xlat_enc[ ucase[i] ] = ucase[i+shift];
        xlat_dec[ lcase[sizeof(lcase) - i - 1] ] = lcase[sizeof(lcase) - i - 1 - shift];
        xlat_dec[ ucase[sizeof(ucase) - i - 1] ] = ucase[sizeof(ucase) - i - 1 - shift];
    }
}


// main entrypoint
int main(int argc, char *argv[])
{
    // using a shift of 13 for our sample
    const int shift = 13;

    // initialize the tables
    init_tables(shift);

    // now  drop the messsage to the console
    char plain[] = ""The quick brown fox jumps over the lazy dog."";
    char *p = plain;
    for (;*p; fputc(xlat_enc[*p++], stdout));
    fputc('\n', stdout);

    char cipher[] = ""Gur dhvpx oebja sbk whzcf bire gur ynml qbt."";
    p = cipher;
    for (;*p; fputc(xlat_dec[*p++], stdout));
    fputc('\n', stdout);

    return EXIT_SUCCESS;
}
</code></pre>

<p><strong>Output</strong></p>

<pre><code>Gur dhvpx oebja sbk whzcf bire gur ynml qbt.
The quick brown fox jumps over the lazy dog.
</code></pre>
",0
13440751,13407879,0,"<p>You can implement it literally:</p>

<p>""if they are shifted out of range"":</p>

<pre><code>if (ciphered_text[arrayelement] &gt; 'z')
</code></pre>

<p>""make them go round in a circle and stop overflow"":</p>

<pre><code>ciphered_text[arrayelement] -= 26;
</code></pre>

<p>In your context:</p>

<pre><code>if (plain_text[arrayelement] &gt;= 'a' &amp;&amp; plain_text[arrayelement] &lt;= 'z')
{
    ciphered_text[arrayelement] = (int)(plain_text[arrayelement] + shiftkey);
    if (ciphered_text[arrayelement] &gt; 'z')
        ciphered_text[arrayelement] -= 26;
}
</code></pre>

<p>(assuming you work with English text in ACSII encoding, and <code>shiftkey</code> is in the range 1...25, like it should be)</p>
",0
13791856,13791816,4,"<p>You can't copy a string like this:</p>

<pre><code>newItem-&gt;m_To=(char*)malloc(sizeof(to));
strcpy(newItem-&gt;m_To,to);
</code></pre>

<p>The value of <code>sizeof(to)</code> will be the number of bytes occupied by a pointer (4 or 8).</p>

<p>You should either do this:</p>

<pre><code>newItem-&gt;m_To = malloc(strlen(to) + 1);
strcpy(newItem-&gt;m_To,to);
</code></pre>

<p>Or use the library function <code>strdup</code>, which does essentially the same thing.</p>

<pre><code>newItem-&gt;m_To = strdup(to);
</code></pre>

<p>Note that I also removed the cast to <code>(char*)</code> from the <code>malloc</code> call.  You should also remove the cast in your other <code>malloc</code> call.  If this is straight C, that is...</p>

<hr>

<blockquote>
  <p><strong>Dipstick</strong> said: Correct but possibly incomplete. Isn't the malloc of newItem also just allocating the size of the pointer.</p>
</blockquote>

<p>You should allocate your structure like this:</p>

<pre><code>TITEM *newItem = malloc(sizeof(TITEM));
</code></pre>
",3
13431463,13431425,4,"<h3>Errors:</h3>
<p><code>strlen</code> returns the length <em>excluding</em> the nul terminator, so all of your sizes that you allocate are too small.</p>
<p>In the case where <code>if (strlen(*strDst) != length)</code> is false, (that is, the lengths are equal) you leak the old buffer.</p>
<p><code>realloc</code> and <code>malloc</code> can both fail, you should be able to write code to cope with that.</p>
<p>The correct way to use <code>realloc</code> is:</p>
<pre><code>char *newbuf = realloc(oldbuf, newsize);
if (newbuf == NULL) {
    // handle the error somehow, and note that oldbuf is still allocated
} else {
    oldbuf = newbuf;
}
</code></pre>
<p>&quot;Handle the error somehow&quot; might require deciding what to do, depending on what the documentation of your two functions says they do on failure. If it doesn't say then it should.</p>
<p>(Picky) <code>int</code> is not guaranteed to be a large enough type to hold the length of a string. Use <code>size_t</code> (unless maybe you've been strictly forbidden from using unsigned types, in which case there's <code>ssize_t</code>).</p>
<h3>Things you can improve:</h3>
<p>There's no need to use <code>strTmp</code> the way you do, you could free the string immediately instead of at the end of the function. [Edit: yes there is a need, there seems to be a requirement that <code>copyString</code> but not <code>concatString</code> should permit overlap of source and destination. Personally I'd still write it slightly differently.]</p>
<p>In <code>if (strTmp != NULL) free (strTmp );</code> the test is redundant since it is valid to call <code>free</code> with a null pointer, and doing so has no effect.</p>
<p>You do <code>*strDst= malloc (length);</code> in both cases in <code>copyString</code>.</p>
<p><code>main</code> leaks memory since it never frees <code>str</code>.</p>
<p><code>main</code> should return <code>int</code>, not <code>void</code>.</p>
<h3>Here's how I might write them:</h3>
<p>Since you can't change the calling code to make it check for error, you have to either <code>abort()</code> or else write <em>something</em> there that it can call <code>puts</code> on. Since the <code>main</code> function was written on the assumption that the calls cannot fail, <code>abort()</code> is probably the least bad solution.</p>
<p>It would probably be better for the caller if the functions return a value indicating success or failure, but we're constrained by the existing calling code. To be honest that's not a totally unrealistic situation to be programming for...</p>
<pre><code>void concatString (char **strDst, const char *cat) {
    size_t dstlen = *strDst ? strlen(*strDst) : 0;
    char *buf = realloc(*strDst, dstlen + strlen(cat) + 1);
    if (!buf) {
        abort();
    }
    strcpy(buf + dstlen, cat);
    *strDst = buf;
}

void copyString (char **strDst, const char *strSrc) {
    char *buf = malloc(strlen(strSrc) + 1);
    if (!buf) {
        abort();
    }
    strcpy(buf, strSrc);
    free(*strDst);
    *strDst = buf;
}
</code></pre>
",8
13431521,13431425,0,"<p>Besides of what <em>Steve Jessop</em> mentions in his answer, no errors in your sources but missing:</p>

<ul>
<li>validation of input parameters</li>
<li>return errors through error value (for example as integer return code of the function, instead of <code>void</code></li>
</ul>
",8
14214041,14210945,1,"<p>So, I see a number of problems with your method. Perhaps the biggest problem is that you have three loops:</p>

<pre><code>for(i=0  ;i&lt;N;i++){
for(k=i+1;k&lt;N;k++){
for(l=k+1;l&lt;N;l++){
</code></pre>

<p>And each loop begins where the other ends. But, in general, you may need to look at smaller nodes in order to find loops. For instance, if you have the following graph:</p>

<pre><code>1 2 3
3 1 2
</code></pre>

<p>you can verify that your approach will not work. So we know right away that we need to expand the range of the loops.</p>

<p>Also, you have a lot of variables floating around. Sometimes (but not always), that's an indication that the program is needlessly complex. Often times, considerably complicated problems can be solved without too many intermediate variables.</p>

<p>Your <code>x</code> and <code>y</code> variables were obviously unnecessary because you were using them as simple intermediates, so I cut them.</p>

<p>You used two file pointer variables, but really only needed one. I cut out the second one.</p>

<p>I also moved the <code>fclose</code> statements closer to where you read in the files, so that they would be open for the shortest possible time, which is a polite way to read a file.</p>

<p>Your <code>valueA</code>, <code>valueB</code>, and <code>count</code> variables immediately struck me as being questionable. Especially this bit:</p>

<pre><code>valueA=0;
valueB=0;     

valueA=A[i];
valueB=B[i];
</code></pre>

<p>You give them values, and then immediately change the values.</p>

<p>But a deeper look at the code shows that you're using <code>valueA</code> and <code>valueB</code> to keep track of which <code>A</code> and <code>B</code> you're looking at. And you use <code>count</code> to keep track of how deep you are in the loops. <em>But each of these is inherent in the structure of the code!</em></p>

<p>So I cut all that out and widened the loop range, as discussed above, resulting in this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define N 9

int main () {
  int A[N], B[N];
  FILE *fp;

  if ((fp = fopen (""file1.dat"", ""r"")) == NULL) {
    printf (""Error opening file 1\n"");
    exit (EXIT_FAILURE);
  }
  for (i = 0; i &lt; N; i++)
    fscanf (fp, ""%d"", &amp;A[i]);
  fclose (fp);

  if ((fp = fopen (""file2.dat"", ""r"")) == NULL) {
    printf (""Error opening file 2\n"");
    exit (EXIT_FAILURE);
  }
  for (i = 0; i &lt; N; i++)
    fscanf (fp, ""%d"", &amp;B[i]);
  fclose (fp);

  for(int i=0; i&lt;N; i++)
    for(int j=0; j&lt;N; j++)
      for(int k=0; k&lt;N; k++)
        if(B[i]==A[j] &amp;&amp; B[j]==A[k] &amp;&amp; B[k]==A[i])
          printf(""%d,%d,%d\n"",A[i],A[j],A[k]);

  return 0;
}
</code></pre>

<p>It will find each triad-loop three times, which is unfortunate, but it will find all the loops. There are slightly more complicated algorithms which would find loops once or find them more efficiently, but this algorithm most closely matches your original code, so it may be the most useful for you now.</p>
",1
20418237,20418111,3,"<p><code>stack_pop()</code> returns a reference to the data carried by the former head of the stack, the head being pop off the stack by this call to <code>stack_pop()</code>.</p>

<p>As <code>data</code> is defined to be a pointer <code>(void *)</code> this operation <strong>copies</strong> its value to <code>x</code>:</p>

<pre><code>void * x = elem-&gt;data;
</code></pre>

<p>so freeing <code>elem</code> (and its member <code>data</code> with it) <strong>afterwards</strong> is perfectly alright. Note, that only the <strong>reference</strong> (<code>data</code>) to the payload it <code>free()</code>ed, not the referred payload itself (what <code>data</code> pointed to). </p>

<p>Also please note that <code>stack_pop()</code> <strong>misses to check whether <code>head</code> is <code>NULL</code></strong>. Do not call it after the last element had been popped off the stack.</p>
",2
20418389,20418111,0,"<p>Notice that probably you are using <code>void*</code> in the element to allow any type of data to be stored in this stack. So, your ""<code>pointer</code>"" might not necessarily be a pointer (you may have to cast the return of <code>stack_pop()</code>).</p>

<p>Additionally, when you free a pointer, you are only freeing that piece of allocated memory, regardless of the other pointers that memory may contain in its struct. That is, when you <code>free()</code> a pointer, free is not ""recursive"", it will not <code>free()</code> the memory that <code>void* data</code> inside Elem points to.</p>
",1
13489599,13489529,0,"<p>You have a prototype for a function called <code>printStd</code>, but no body:</p>

<pre><code>void printStd(Student *std);
</code></pre>

<p>There is a body for a <code>printSt</code> function. Was that supposed to be <code>printStd</code>?</p>
",0
13489617,13489529,1,"<p>void printStd(Student *std) -> This is what you have declared.</p>

<p>void printSt(Student *std) -> This is the function name you wrote</p>

<p>""unresolved external symbol ""void __cdecl printStd"" The compiler is telling you it can't find any function named printStd which you have decalred.</p>
",1
13775783,13775703,0,"<p>To address your issues:</p>

<p>In general the way would keep multiple bits of information (Name, numbers, address etc) is by including them in the node struct, something like:</p>

<pre><code>struct node
{
   int data;
   char name[50];
   char phone[20];
   struct node *link;
} *head=NULL;
</code></pre>

<p>This is a list of contacts, each node has the contact details, the list contains multiple contacts.</p>

<p>To print such a list out one would iterate through the list and print each node, specifically:</p>

<ol>
<li>Start with the head</li>
<li>if the current node is null then we're at the end so exit</li>
<li>print of the content of the current node</li>
<li>set the current node to the next node (i.e. current->link)</li>
<li>go back to step 2</li>
</ol>
",1
13785194,13775703,0,"<p>you can use this also</p>

<pre>
   typedef struct contact
    {
     int data;
    char name[40];
    char add[90];
    }book;
    stuct node
    {
    book b;
    struct node*link;
    }*head=NULL;
</pre>
",0
15576506,15576324,4,"<p>If you just say <code>char * str</code> the memory for the array will not be allocated, only the memory for the pointer itself. You will need to allocate the memory for the string manually, probably on the heap, and probably free it manually too.</p>

<p>""You can't change a string in C"" is wrong. You cannot change a string constant, and string constants are allocated in something like <code>.rodata</code> (a readonly section). The functions code, like any other code, sits in something like <code>.text</code>.</p>
",0
15576516,15576324,4,"<p>If you put a definition <code>char *str;</code> inside a function, then it's an automatic variable of type ""pointer-to-<code>char</code>"".</p>

<p>It's located on the stack, and that part of the stack becomes unused when the function returns (the compiler handles this for you by emitting code to move the stack pointer as necessary). In theory the existence of a stack is purely an implementation detail, in practice C always has a call stack, almost all implementations manage that more or less the same way, and however it is actually managed, the memory in which automatic variables is stored is liable to be referred to as ""the stack"".</p>

<p>If you put a definition <code>char *str;</code> outside any function, then it's a global variable with static storage duration.</p>

<p>It is stored in a read-write data segment, and becomes unused when the program exits (probably the OS handles this for you, although it could in principle be code emitted by the compiler). Since it is zero-initialized (and assuming an architecture on which a null pointer is represented by all bits zero) yes, it can go in the bss segment, which is specifically for zero-initialized read-write objects with static storage duration. Again, the details of how objects of static duration are stored is up to the implementation but again, this is how its generally done.</p>

<p>None of this has anything to do with string literals being unmodifiable, because you haven't defined a string (let alone used a string literal). You've defined a pointer, which could point to a string but does not (yet) do so.</p>
",0
15576617,15576324,2,"<p>In C, all local variables will be put on the stack. The variable <code>str</code> is a character pointer. It contains a memory address. On the stack will only be this pointer called <code>str</code>.</p>

<pre><code>char * str;
</code></pre>

<p>This allocates memory with the size of a pointer (4 or 8 bytes on 32/64 bit) <strong>on the stack</strong>.</p>

<pre><code>str = malloc(1024);
</code></pre>

<p><code>malloc</code> allocates 1024 bytes <strong>on the heap</strong> and returns a pointer to the first byte of that memory area. This pointer is saved in <code>str</code> which is located on the stack.</p>

<p>Your variable <code>str</code> will be free'd when the function (in which <code>str</code> is a local variable) returns.</p>

<p>The memory area <code>str</code> is pointing to will not be free'd automatically. You need to do this manually with <code>free(str)</code>.</p>

<p>Strings can be modified! But not constant literals:</p>

<pre><code>char string[4] = ""foo"";
string[0] = 'F'; //will work

char * stringconst = ""foo"";
stringconst[0] = 'F'; // this will segfault
</code></pre>

<p>The above will not work, because ""foo"" will be placed (hopefully) in readonly memory areas.</p>
",0
15576632,15576324,2,"<p>I think you've confused pointers and what they point to. Take this:</p>

<pre><code>char *str = ""Hello"";
</code></pre>

<p>If that's declared at file scope, then <code>str</code> is a pointer allocated statically. The string it points to is entirely separate. You can have <code>str</code> point to anything.</p>

<p>If instead it's declared in a function, then <code>str</code> is a pointer allocated on the stack. Again, the literal is separate.</p>

<p>In fact, if you have these two lines:</p>

<pre><code>char *str1 = ""Hello"";
char *str2 = ""Hello"";
</code></pre>

<p>The compiler is free to have each pointing to the same address in memory.</p>

<p>The string literal is statically allocated regardless of the pointers, and it is placed (in general) in the initialised read-only data segment.</p>

<p>Also bear in mind that all concepts of heap, stack and segments are purely associated with the implementation, not the language.</p>
",0
15577054,15576324,1,"<p>Just two links I found while reading the answers to a similar question. These might help you understand the matter a bit better.</p>

<p><a href=""http://www.geeksforgeeks.org/memory-layout-of-c-program/"" rel=""nofollow"">Memory Layout of C Programs</a> and <a href=""http://www.geeksforgeeks.org/storage-for-strings-in-c/"" rel=""nofollow"">Storage for Strings in C</a></p>
",0
13468063,13468033,-1,"<pre><code>does this mean that p is pointing to 1000 address location?
</code></pre>

<p>yes. But this 1000 address may belong to some other processes address.In this case, You illegally accessing the memory of another process's address space. This may results in segmentation fault.  </p>
",4
13468072,13468033,4,"<blockquote>
  <p>does this mean that p is pointing to 1000 address location?</p>
</blockquote>

<p>Yes.</p>

<blockquote>
  <p>what if I do *p=22</p>
</blockquote>

<p>It's invoking undefined behavior - your program will most likely crash with a segfault.</p>

<p>Note that in modern OSes, addresses are virtual - you can't overwrite an other process' adress space like this, but you can attempt writing to an invalid memory location in your own process' address space.</p>

<blockquote>
  <p>how q-p=250?</p>
</blockquote>

<p>Because pointer arithmetic works like this (in order to be compatible with array indexing). The difference of two pointers is the difference of their value divided by <code>sizeof(*ptr)</code>. Similarly, adding <code>n</code> to a pointer <code>ptr</code> of type <code>T</code> results in a numeric value <code>ptr + n * sizeof(T)</code>.</p>

<p><a href=""http://www.cs.umd.edu/class/sum2003/cmsc311/Notes/BitOp/pointer.html"" rel=""nofollow"">Read this on pointers.</a></p>

<blockquote>
  <p>does this mean the addresses used by compiler are integers?</p>
</blockquote>

<p>That ""used by compiler"" part is not even necessary. Addresses <em>are</em> integers, it's just an abstraction in C that we have nice pointers to ease our life. If you were coding in assembly, you would just treat them as unsigned integers.</p>

<p>By the way, writing</p>

<pre><code>printf(""%u:%d"", p, i);
</code></pre>

<p>is also undefined behavior - the <code>%u</code> format specifier expects an <code>unsigned int</code>, and not a pointer. To print a pointer, use <code>%p</code>:</p>

<pre><code>printf(""%p:%d"", (void *)p, i);
</code></pre>
",4
13468081,13468033,1,"<p>Yes, with <code>*p=22</code> you write to 1000 address.</p>

<p><code>q-p</code> is 250 because size of int is 4 so it's 2000-1000/4=250</p>
",0
13468093,13468033,0,"<ol>
<li><p>Yes, <code>p</code> is pointing to virtual address 1000.  If you use <code>*p = 22;</code>, you are likely to get a segmentation fault; quite often, the whole first 1024 bytes are invalid for reading or writing.  It can't affect another program assuming you have virtual memory; each program has its own virtual address space.</p></li>
<li><p>The value of <code>q - p</code> is the number of units of <code>sizeof(*p)</code> or <code>sizeof(*q)</code> or <code>sizeof(int)</code> between the two addresses.</p></li>
</ol>
",0
13468142,13468033,0,"<p>Casting arbitrary integers to pointers is undefined behavior. Anything can happen including nothing, a segmentation fault or silently overwriting other processes' memory (unlikely in the modern virtual memory models).</p>

<p>But we used to use absolute addresses like this back in the real mode DOS days to access interrupt tables and BIOS variables :)</p>

<p>About <code>q-p == 250</code>, it's the result of semantics of pointer arithmetic. Apparently <code>sizeof int</code> is 4 in your system. So when you add 1 to an int pointer it actually gets incremented by 4 so it points to the next <code>int</code> not the next byte. This behavior helps with array access.</p>
",0
13468192,13468033,1,"<p>The meaning of <code>p = (int *) 1000</code> is implementation-defined. But yes, in a typical implementation it will make <code>p</code> to point to address <code>1000</code>.</p>

<p>Doing <code>*p = 22</code> afterwards will indeed attempt to store <code>22</code> at address <code>1000</code>. However, in general case this attempt will lead to undefined behavior, since you are not allowed to just write data to arbitrary memory locations. You have to allocate memory in one way or another in order to be able to use it. In your example you didn't make any effort to allocate anything at address <code>1000</code>. This means that most likely your program will simply crash, because it attempted to write data to a memory region that was not properly allocated. (Additionally, on many platforms in order to access data through pointers these pointers must point to properly <em>aligned</em> locations.)</p>

<p>Even if you somehow succeed succeed in writing your <code>22</code> at address <code>1000</code>, it does not mean that it will in any way affect ""other programs"". On some old platforms it would (like DOS, fro one example). But modern platforms implement independent virtual memory for each running program (process). This means that each running process has its own separate address <code>1000</code> and it cannot see the other program's address <code>1000</code>. </p>
",0
17779586,17779570,58,"<p>You must use <code>%ld</code> to print a <code>long int</code>, and <code>%lld</code> to print a <code>long long int</code>.</p>

<p>Note that only <code>long long int</code> is guaranteed to be large enough to store the result of that calculation (or, indeed, the input values you're using).</p>

<p>You will also need to ensure that you use your compiler in a C99-compatible mode (for example, using the <code>-std=gnu99</code> option to gcc).  This is because the <code>long long int</code> type was not introduced until C99; and although many compilers implement <code>long long int</code> in C90 mode as an extension, the constant <code>2147483648</code> may have a type of <code>unsigned int</code> or <code>unsigned long</code> in C90.  If this is the case in your implementation, then the value of <code>-2147483648</code> will also have unsigned type and will therefore be positive, and the overall result will be not what you expect.</p>
",8
17779612,17779570,3,"<p>Use <code>printf(""%ld"",a);</code></p>

<p>Have a look at <a href=""http://www.cplusplus.com/reference/cstdio/printf/"" rel=""nofollow"">format specifiers</a> for printf</p>
",0
19956786,19956712,2,"<p>The typedef is for a pointer type.</p>

<p><code>lptr</code> is the type <code>struct Node*</code></p>
",0
19956800,19956712,3,"<p>Although it is common to have two <code>typedef</code>s - one for the <code>struct</code> to avoid the tag, and one for the <code>struct</code> pointer to avoid the asterisk, like this</p>

<pre><code>typedef struct Node{
    void *data;
    int pos;
    struct Node *prev;
    struct Node *next;
} Node;
typedef Node* lptr;
</code></pre>

<p>if the authors want to avoid writing an asterisk after <code>lptr</code> or <code>Node</code>, they could certainly <code>typedef</code> a pointer to <code>struct Node</code>.</p>
",0
19956808,19956712,1,"<p>Because the definition (the typedef) is to a pointer type. Removing it makes lptr of type Node, * makes it a <em>pointer</em> to a Node.</p>
",0
17086805,17086743,4,"<p>You use a library, such as <a href=""http://sourceforge.net/projects/libcsv/"" rel=""nofollow"">libcsv</a>.</p>
",0
14183482,14183289,0,"<p><em>I want the system to update the quanity in stock in the products.dat file</em></p>

<p>But you are only opening products.dat for read access <code>pfp=fopen(""products.dat"", ""rb"");</code>.</p>

<p>Your <code>fwrite</code> statement is to <code>ofp</code>, which is opened to a different file: <code>ofp=fopen(""orders.dat"",""ab"");</code></p>

<p>The variable <code>ofp</code> is not declared, so at least one line of your code is missing, otherwise it would not compile.  Update:  for some reason <code>ofp</code> it has been made global, but why?  Nevertheless that should not affect the functionality (assuming a single thread).</p>

<p>Edit:  to write and write to a file, open it with mode ""r+b"".  You need to find the product whose stock you wish to update, and then <em>move the current file position backwards</em>;</p>

<pre><code>fseek(pfp, -sizeof(product), SEEK_CUR);
</code></pre>

<p>then <code>fwrite</code> the new product record.  Note the - sign on the sizeof: we are moving the current file position to the start of the record we just read.</p>
",3
15882130,15881934,0,"<p>Looks like <code>wrd-&gt;length</code> does not include the terminating <code>'\0'</code>.</p>

<p>Fix 1, allocate <code>word_temp</code> like this:</p>

<pre><code>char *word_temp = malloc( wrd-&gt;length + 1 );
</code></pre>

<p>Fix 2, include the '\0' by modifying you length count loop:</p>

<pre><code>int i = 0;
while(input[i++] != '\0') {}
</code></pre>

<p>This will increase <code>i</code> one more time than code in the question, which is easy to see if you consider case of <code>input</code> being empty.</p>

<p>Note that you need to do either fix 1 or fix 2, not both. Choose which ever works with rest of your code.</p>

<hr>

<p>You probably have a second issue with this line:</p>

<pre><code>wrd-&gt;letters = input;
</code></pre>

<p>It does not copy input, it copies the pointer. If you change contents of <code>input</code>, contents of <code>wrd-&gt;letters</code> changes too, because they point to same memory location. Also if <code>input</code> is a local char array, then once it goes out of scope, <code>wrd-&gt;letters</code> becomes a dangling pointer, which will be overwritten by other data, and modifying it after that will result in memory corruption.</p>

<p>Possible fix (depending on rest of your code) is to use <a href=""http://linux.die.net/man/3/strdup"" rel=""nofollow""><code>strdup</code></a>:</p>

<pre><code>wrd-&gt;letters = strdup(input);
</code></pre>

<p>Remember that it is now allocated from heap, so when done, you must remember to do</p>

<pre><code>free(wrd-&gt;letters);
</code></pre>

<hr>

<p>About <code>wrd</code> being 0x21, that indicates either memory corruption, or that you actually have two separate <code>wrd</code> variables, and one one is left uninitialized.</p>

<p>For example, maybe <code>wrd</code> is a function parameter <code>struct word *wrd</code>, in which case you only modify the local value in function, it does not get passed back to the caller. To modify the pointer of caller, you need to have pointer to pointer: <code>struct word **wrd</code> and then do <code>(*wrd) = malloc...</code> and <code>(*wrd)-&gt;letters...</code> etc.</p>
",5
14814481,14813016,1,"<p>Like Joachim said, your problem is that you're always using NULL as a root node:</p>

<pre><code>    struct node* root=NULL;
    root=sub_insert(key, root, table);
</code></pre>

<p>I'm guessing, but it seems like you want to use table.head as the starting node:</p>

<pre><code>    root=sub_insert(key, table.head, table);
</code></pre>

<p>Dunno whether table is a pointer or not, so I just used dot notation. </p>

<p>In any case, you absolutely need a valid root node before you traverse with sub_insert(), otherwise all your new nodes will just dangle in memory.</p>
",0
14231588,14231489,1,"<pre><code>char* username[30]; //is array of char pointers.

//Allocate memory for these pointers using calloc(). so no need of memset().  

memset(username,0x00,30);//can be removed.

scanf(""%s"",&amp;username);//It should be scanf(""%s"",username[i]);
</code></pre>

<p>@perreal, Sample added.</p>

<pre><code>#define SIZE 100 //100 chars...
char* username[30]; 
int i;

for(i = 0; i &lt; 30; i++)
{
   username[i] = calloc(SIZE, sizeof(char)); //Add Fail checks if needed.
   scanf(""%s"",username[i]);
}
</code></pre>

<p>so with the above code, you can get 30 strings. If you need only one string with 30 char then </p>

<pre><code>char username[30];
memset(username,0x00,30);
scanf(""%s"",username);
</code></pre>

<p>is enough.</p>
",0
14232369,14231489,0,"<pre><code>char *username[30]
</code></pre>

<p>This is an array of pointers to characters..</p>

<p>go for <code>char username[30]</code></p>
",0
14231784,14231489,1,"<p>with </p>

<pre><code>memset(username,0x00,30);  
</code></pre>

<p>you are initializing the first 30 bytes of your array of pointers and not the whole array</p>

<pre><code>memset(username,0, sizeof(username));
</code></pre>

<p>would set everything to 0 although a simple loop is clearer for the reader (IMHO)</p>

<pre><code>for (int i = 0; i &lt; 30; username[i++] = NULL) {;}
</code></pre>

<p>don't do this:</p>

<pre><code>scanf(""%s"",&amp;username);
</code></pre>

<p>scanf doesn't magically allocate anything -- ""username"" is an array of pointers and  are NULL pointers, how should scanf know how to allocate memory etc? Instead do a loop, let user enter a string, allocate memory for that string (+1), copy the string to the allocated memory and assign it to ""username[i]"".</p>
",0
14231787,14231489,1,"<p>What you PROBABLY want is:</p>

<pre><code>int i;
char* username[30];
for(i = 0; i &lt; 30; i++)
{
     username[i] = calloc(100, sizeof(char));  // or whatever size your string is.
     scanf(""%s"",username[i]);
}
... Code using usernames ...
for(i = 0; i &lt; 30; i++)
{
    free(username[i]);
}
</code></pre>

<p>But personally, I'd probably go for:</p>

<pre><code>int i;
char username[30][100];
for(i = 0; i &lt; 30; i++)
{
     scanf(""%s"",username[i]);
}
</code></pre>

<p>Saves on having to free the pointers later. </p>

<p>That will read 30 strings into your username array. </p>

<p>If you want to just read one username:</p>

<pre><code>char username[30] = {0};    // Same as memset, but shorter to write!
scanf(""%s"", username);
</code></pre>

<p>Although as others have suggested, scanf() is't the best function to read ""user generated input"" - it's fine for data that your program has already ""checked"" (that is, it contains no ""funny stuff"", fits in the length provided, etc) and written to a file [using fscanf()]. For user input, use <code>fgets()</code> to read a line of text, and then work through it in whatever way is suitable to get the actual data out of the string. </p>

<p>For example, if some username has more than 100 characters [or thirty in the last example], the string will overflow, and nothing good will ever come from that [and in really bad cases, you won't notice until MUCH later, which makes it hard to debug - if you are lucky, it crashes immediately].</p>
",2
14232068,14231489,1,"<pre><code>char* username[30];
memset(username,0x00,30);
scanf(""%s"",&amp;username);
</code></pre>

<p>the above your code will get crash , because you are trying to input into pointer for which memory is not allocated. so first you allocate memory for the pointers and then you read into that memory location.</p>
",0
14231525,14231489,2,"<p><code>char *username[30]</code> is an array of <em>pointers</em>, not characters. So your code is very wrong (as in <em>not</em> safe). To get an array of characters you need:</p>

<pre><code>char username[30];
</code></pre>
",0
14215909,14215440,2,"<p><code>scanf</code> is a poor choice for getting lines out of an input stream. While you can do it quite easily:</p>

<pre><code>buf[SIZE];
scanf (""%[^\n]\n"", buf);
</code></pre>

<p>You will be at the risk of being subject to a buffer overflow error/attack.</p>

<p>The better way is to read 'SIZE' characters at a time using <code>fgets</code>, and copying the data into a dynamically allocated buffer that you can resize upon filling it up:</p>

<pre><code>buf[SIZE];
do {
  fgets (buf, SIZE, stdin);
  /* Handle copying to dynamic buffer and resize over here */
} while (/*check we haven't reached eol*/);
</code></pre>
",1
14150087,14150063,1,"<p>You forgot a dereference and got the precedence of <code>*</code> vs. <code>[]</code> wrong:</p>

<pre><code>populate_items(char ***items) {
        int i;
        *items = (char **) malloc(sizeof(char*) * 3);
        for (i=0; i&lt;3; i++)
                *(*items+i) = (char *) malloc(sizeof(char) * 10);
        (*items)[0] = ""1234567890"";
        (*items)[1] = ""2345678901"";
        (*items)[2] = ""3456789012"";
}
</code></pre>

<p>Note, however, that the assignments</p>

<pre><code>(*items)[0] = ""1234567890"";
</code></pre>

<p>etc. lose the only handle to the just allocated memory.</p>
",8
14154328,14150063,-1,"<p>you can use as below</p>

<pre><code> #include ""stdafx.h""
 #include &lt;stdlib.h&gt;
 #include &lt;stdio.h&gt;


 char*** populate_items(char ***items) 
 {
      int i;
      items = (char ***) malloc(sizeof(char*) * 3);
      for (i=0; i&lt;3; i++)
            *(items + i) = (char **) malloc(sizeof(char) * 10);
      **(items + 0) = ""1234567890"";
      **(items + 1) = ""2345678901"";
      **(items + 2) = ""3456789012"";
      return items;
 }

 int main(int argv, char *argc) 
 {
      char **items;
      int i;
      char *** res = populate_items(&amp;items);
      for(i=0; i&lt;3; i++)
            printf(""%s\n"", **(res + i));
      return 0;
 }
</code></pre>
",0
18899896,18899778,1,"<pre><code>dprintf(x/y);
</code></pre>

<p>expands to</p>

<pre><code>printf(""x/y"" ""=%d\n"", x/y);
</code></pre>

<p>which is evaluated as:</p>

<pre><code>printf(""x/y"" ""=%d\n"", 7 / 3);
</code></pre>

<p>now since x and y are integers, the result of x/y is 2 (an integer)</p>

<p>so the output is <code>x/y=2</code></p>

<p>Note the c preprocessor # directive replaces #expr with ""expr"".</p>

<p>Note also the c compiler will simply concatenate adjacent string literals into one string, i.e. <code>printf(""Hello "" ""World\n"");</code> is equivalent to <code>printf(""Hello World\n"");</code></p>

<p>see <a href=""http://gcc.gnu.org/onlinedocs/cpp/Stringification.html#Stringification"" rel=""nofollow"">http://gcc.gnu.org/onlinedocs/cpp/Stringification.html#Stringification</a> for more details.</p>
",0
18899909,18899778,5,"<p>In a macro the <code>#</code> <a href=""http://gcc.gnu.org/onlinedocs/cpp/Stringification.html"" rel=""nofollow"">stringifies</a> the operands so <code>#expr</code> will take the arguments and turn them into a string and since adjacent string literals are concatenated it will be then be concatenated to <code>""=%d\n""</code> so you end up with:</p>

<pre><code>printf( ""x/y"" ""=%d\n"",expr)
</code></pre>

<p>which will become:</p>

<pre><code>printf( ""x/y=%d\n"",expr)
</code></pre>

<p>For complete sake from the draft <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf"" rel=""nofollow"">C99 draft standard</a> section <code>6.10.3.2</code> <em>The # operator</em> paragraph <em>2</em> covers the <code>#</code> it is rather long and hard to read so I won't quote it but section <code>5.1.1.2</code> <em>Translation phases</em> paragraph <em>6</em> says:</p>

<blockquote>
  <p>Adjacent string literal tokens are concatenated</p>
</blockquote>
",0
14171537,14171478,-1,"<p>It's way easier like this:</p>

<pre><code>#include &lt;math.h&gt;
bool isValidId(int *id)
{
    return (int)log10(*id) == 6;
}
</code></pre>
",4
14171564,14171478,0,"<p>I've not done C for eons however try something like this</p>

<pre><code>bool isValidId(int* id)
{
    char str[15];
    sprintf(str, ""%d"", id)
    if(strlen(str) != 6)
    {
        return false;
    }

    return true;
}
</code></pre>
",2
14171587,14171478,9,"<pre><code>return *id &gt;= 100000 &amp;&amp; *id &lt; 1000000;
</code></pre>

<p>I think this may be a good solution, both easy to read and efficient.</p>

<p>There is no need to acquire its length if you just want to judge if it is a valid id</p>

<p>Program crashes because the parameter of isValidId is pointer to int, not int, so</p>

<pre><code>validID = isValidId(c.id);
</code></pre>

<p>should be </p>

<pre><code>validID = isValidId(&amp;c.id);
</code></pre>
",2
14171590,14171478,1,"<p>First of all, I don't see any reason to pass a pointer to <code>isValidId</code> function. You can pass an integer and calculate the number of digits.</p>

<pre><code>bool isValidId(int id) {
    // count digits here
}
</code></pre>

<p>Now there are at least two ways to calculate the number of digits. First one is to use <code>log10</code>. The number of digits in a 10-base integer n is <code>(int)(log10(n) + 1)</code>. You will need to import <code>math.h</code> to use <code>log10</code>. You may check whether <code>n &lt;= 0</code> before calling <code>log10</code>.</p>

<p>The second way is to loop through <code>n</code>.</p>

<pre><code>int count = 0;

while (n &gt; 0) {
    count++;
    n /= 10;
}
</code></pre>
",0
14172557,14171478,1,"<ol>
<li><p>You've declared <code>isValidId</code> to take a pointer to an <code>int</code>, but you're passing it a plain <code>int</code>; in this case, there's no reason to use a pointer, so you'd be better off changing <code>isValidId</code> to use a regular <code>int</code>.  </p></li>
<li><p><strong>NEVER NEVER NEVER NEVER NEVER USE GETS -- IT <em>WILL</em> INTRODUCE A POINT OF FAILURE/MAJOR SECURITY HOLE IN YOUR CODE</strong>.  Use <code>fgets(input, sizeof input, stdin)</code> instead.  </p></li>
<li><p>How is <code>input</code> declared?  Is it large enough to hold as many digits as <code>int</code> will allow, plus a sign, plus a 0 terminator?</p></li>
<li><p><code>log10</code> returns a <code>double</code>, not an <code>int</code>.  To properly count digits with <code>log10</code>, you will need to write something like  <code>(int)floor(log10(id)) + 1</code>.</p></li>
</ol>

<p>You can simplify your <code>isValidId</code> function a little:</p>

<pre><code>bool isValidId(int id)
{
  return (int) floor(log10(id)) + 1 == 6;
}
</code></pre>

<p>The Boolean data type is a latecomer to the C language (introduced in C99), so a lot of us older types tend to avoid using Boolean constants in our code.  </p>
",0
18630261,18630185,3,"<p>This line :</p>

<pre><code> extern int tmp ;
</code></pre>

<p>says look for the tmp variable definition elsewhere , which means look for the variable definition in other <a href=""https://www.google.co.in/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;ved=0CC0QFjAA&amp;url=http%3A%2F%2Fen.wikipedia.org%2Fwiki%2FTranslation_unit_(programming)&amp;ei=LjYoUtz9M8bmrAetv4D4DQ&amp;usg=AFQjCNHG_aBKdo9Q36MnyT4zMoEFU93zTw&amp;sig2=vr5xeo83HuuQl3uvoAa_fg&amp;bvm=bv.51773540,d.bmk"" rel=""nofollow"">translation unit</a> in the entire program.</p>

<p>when you define int tmp in main it is local to that function, i.e it doesn't have any <a href=""http://en.cppreference.com/w/cpp/language/storage_duration"" rel=""nofollow"">external linkage</a>.</p>

<p><strong>Disclaimer-</strong> There are seriously many posts on SO regarding this like the one with link provided in the comments above . No, matter how much I add to this it will end up being a repetition. however , you have a good answer below by Jonathan leffler too.</p>
",2
18630285,18630185,1,"<p>Extern is redeclaration
, so it doesn't crate variable, but only tells compiler that real declaration is somewhere else.
You can use it in one source file to refer to variable declaration in another file, or in the same file to express that you use previously declared global variable.</p>

<p>So when you declare global variable</p>

<pre><code>int a=5;
</code></pre>

<p>and use in function in the same source file, you can add extern int a; in the body of a function to clearly tell that it uses global variable but declaration is not here.</p>

<pre><code>type func(arguments){
extern int a;
.
.
.
</code></pre>

<p>And when int a=5 is in another source file you place</p>

<pre><code> extern int a; 
</code></pre>

<p>in source file you actually want to use global variable a declared in previous source file.</p>
",0
18630302,18630185,0,"<p>This is about linkage. When you declare a variable <code>extern</code> you give it external linking, saying it's defined with global linkage somewhere else.</p>

<p>In your function you're defining a variable called tmp, but it doesn't have global linkage, it's a local variable. You'd have to define it outside of any function to give it global linkage.</p>

<p>There's also static linkage, which means a variable is global but only to the current compilation unit (source file).</p>
",0
18630307,18630185,0,"<p>Using the <code>extern</code> keyword you only declare the symbol <code>tmp</code>. Which means the symbols is defined somewhere else and will be resolved at link time.<br/>
So if you do not provide a compiled object defining the symbol, the linker gives you some kind of ""unresolved symbol"" error.</p>

<p>See the following question for more details on <a href=""https://stackoverflow.com/questions/4769599/declaration-or-definition-in-c"">Declaration or Definition in C</a></p>
",0
18630319,18630185,7,"<p>No; <code>extern int tmp;</code> means ""somewhere else there is a definition of the variable <code>tmp</code>""; this is a declaration ¡ª you can reference <code>tmp</code> but it is not defined.  Further, when you write <code>extern int tmp;</code> outside a function, it means that the variable will be defined outside a function ¡ª it is a global variable which may be defined elsewhere in the current source file or in another source file.  (The rules for <code>extern int tmp;</code> written inside a function are moderately complex; let's not go there now!)</p>

<p>Your local variable <code>int tmp = 50;</code> in the function is unrelated to the global variable <code>tmp</code> declared outside.  The local variable hides the global variable inside the braces.  (The local variable is also unused.)  The <code>printf()</code> statement, though, references the global variable; the local variable is not in scope for the <code>printf()</code>.</p>

<p>Because you do not define the global variable (for example, by adding <code>int tmp = -2;</code> at the bottom of the file), your program fails to link and will continue to do so until you either define the variable in this source file or link in another source file where the variable is defined.</p>
",4
18240985,18239634,1,"<p>Add a global constant int pointer.</p>

<p>OP: How to copy local variable to global variable if both have the same array names in C without using a third variable?<br>
I cheated and am not using a third variable but a constant.  (did I sneak through the door?)</p>

<p>OP: without first assigning the value of the global variable to some temporary variable (using extern) and then assigning the temporary variable to the global variable?<br>
Appears to pass that test - no temporary variable used.</p>

<p>OP: some way in C to do it (without using temporary variables (or pointers in case of arrays))?<br>
Well it not using a temporary, as globals are permanent.  And its not using a pointer via an array.  It <em>is</em> using a pointer.</p>

<pre><code>int myVariable = 50;
int *const myVariableAddress = &amp;myVariable;

void myFunction() {
    // Could be here instead with 
    // static int *const myVariableAddress = &amp;myVariable;
    {
    int myVariable;
    *myVariableAddress = myVariable /*local*/;
    }
}
</code></pre>
",0
13696202,13696141,0,"<p>Going to assume you mean the 's' and 'T' in format_perms. According to the <a href=""http://netbsd.gw.com/cgi-bin/man-cgi?chmod++NetBSD-current"" rel=""nofollow noreferrer"">chmod manpage</a>:</p>
<blockquote>
<p>4000    Set-user-ID-on-execution</p>
<p>2000    set-group-ID-on-execution</p>
<p>1000    sTicky bit, see <a href=""http://netbsd.gw.com/cgi-bin/man-cgi?chmod+2+NetBSD-current"" rel=""nofollow noreferrer"">chmod(2)</a></p>
</blockquote>
<p>Emphasis, mine.</p>
",2
13737146,13736948,2,"<p>You should not be using <code>strcpy()</code> in this code. The API <a href=""http://www.cplusplus.com/reference/cstring/strtok/"" rel=""nofollow""><code>strtok()</code></a> will return you a pointer to the delimited token discovered <em>within the original source buffer after terminating at the discovered delimiter</em>. Therefore, you're using  <code>strcpy()</code> where you should not be. </p>

<p>Your <code>events[]</code> array has <em>pointers</em> returned from <code>strtok()</code>. Just throw out the first two pointers and move the others down:</p>

<pre><code>for(i=2;i&lt;length;i++)
    event[i-2] = event[i];
length -= min(length, 2);
</code></pre>

<p>Note: the <code>min()</code> is required to ensure your length, signed or unsigned, never wraps below zero (if signed) or UINT_MAX (if unsigned) in the event <code>length</code> is undersized on entry.</p>
",0
15531238,15530335,6,"<p>You should <code>extern</code> you variable.</p>

<p><code>.h</code> file:</p>

<pre><code>#ifndef HDR_H
#define HDR_H

typedef struct 
{
    int  kind;  /* it has a constant value 0x01*/
} tcp_opt_nop;

extern const tcp_opt_nop  opt_nop;

#endif
</code></pre>

<p><code>.c</code> file:</p>

<pre><code>#include ""hdr.h""

const tcp_opt_nop opt_nop = {0x01};
</code></pre>

<p>main file:</p>

<pre><code>#include ""hdr.h""

int main()
{
    printf(""%i\n"", opt_nop.kind);
    // ...
}
</code></pre>
",3
15530777,15530335,-3,"<p>yes, you can define. See the following code.</p>

<pre><code>#include&lt;stdio.h&gt;
typedef struct temp
{
    int a;
} temp;
const temp test={5};
int main()
{
    printf(""%d"",test.a);
    return 0;
}
</code></pre>
",7
14244280,14244266,5,"<p>With the use of <a href=""http://www.kernel.org/doc/man-pages/online/pages/man3/malloc.3.html"" rel=""nofollow""><code>malloc(3)</code></a> and <a href=""http://www.kernel.org/doc/man-pages/online/pages/man3/free.3.html"" rel=""nofollow""><code>free(3)</code></a> to do dynamic memory management.  It's still done today.</p>

<pre><code>void f(int n)
{
  int *nInts = malloc(n * sizeof(int));

  /* do stuff with 'nInts' */

  free(nInts);
}
</code></pre>
",12
14244400,14244266,0,"<p>I think you are referring to <a href=""http://c-faq.com/struct/structhack.html"" rel=""nofollow"">this</a>.</p>

<p>As said there, it's not really sure if it's legal or portable. That said I have seen code like this but never written it myself.</p>
",0
13750861,13750802,2,"<p>In the first block, the <code>while</code> loop operates on a <code>Snodeptr</code> instance.  In the second block you're operating on a <code>Snodeptr*</code>.</p>
",2
13750866,13750802,3,"<p><code>Snodeptr *s</code> and <code>Snodeptr p</code> are different types, and therefore behave differently</p>

<p>try <code>(*s)-&gt;next</code></p>
",2
13750874,13750802,1,"<p>In the second code, you are using <code>s-&gt;next != NULL</code>, s is pointer.</p>

<p>In the first code, you are using <code>p-&gt;next != NULL</code>, p is not pointer</p>
",0
13750977,13750802,1,"<p>I expect this (slightly modified version of your second snippet) should compile:</p>

<pre><code>int memberStudents(struct studentType x, Snodeptr students, Snodeptr *s) {
    while ((*s)-&gt;next != NULL) {
        if (strcmp(x.sid, (*s)-&gt;student.sid) == 0)
            return 1;

            (*s) = (*s)-&gt;next;
    }
    return 0;
}
</code></pre>
",4
13757141,13756962,1,"<p>Using algebra and the <code>e</code> function definition, <code>|e(n) - e(n+1)| &lt; x</code> can be simplified to <code>(1/n!) &lt; x</code>, which can be expanded to <code>(1/1) * (1/2) * (1/3) * ... * (1/n) &lt; x</code>.</p>

<pre><code>int minN(double x) {
    double sum = 1;
    int n;
    for(n = 0; sum &gt;= x; n++) {
       sum *= 1/(n+1);
    }
    return n;
}
</code></pre>
",6
15535574,15535521,3,"<p>Except in a few exceptions, in C an array name is converted to a pointer to the first element of the array. <code>linearA</code> is an array 30 of <code>float</code> and in the expression:</p>

<pre><code>A[0] = linearA;
</code></pre>

<p>it is converted to a pointer to <code>float</code>.</p>

<p><code>A</code> is an array 6 of pointer to <code>float</code>. The element of <code>A</code> are of type pointer to <code>float</code>. So <code>A[0]</code> is a pointer to <code>float</code> and not a pointer to an array.</p>

<p>And <code>A[i][j]</code> in C is equivalent to <code>*(A[i] + j)</code> so <code>A[i][j]</code> is a <code>float</code> (dereferencing a pointer to <code>float</code> yields a <code>float</code>).</p>
",2
15535652,15535521,1,"<p><code>A[0]</code> is a pointer to the 1st element of <code>linearA</code>. Since <code>linearA</code> is a contiguous array, this pointer actually allows to access any of the <code>linearA</code> 30 elements by adding an appropriate offset. However in this piece of code you emulate a 2D array by pointing to different offsets in the <code>linearA</code> array. The result is 2D-like array addressing: <code>A[n]</code> brings you to the location (i.e. offset in the <code>linearA</code>) of your n-th row and <code>A[n][m]</code> brings you to the m-th element inside this row.</p>
",2
15535777,15535521,1,"<p>It's because this line sets up an array of 6 pointers to <code>float</code>:</p>

<pre><code>float *A[6];
</code></pre>

<p>And this line sets the first of those pointers to the <em>first element</em> of the 30.</p>

<pre><code>A[0] = linearA; 
</code></pre>

<p>Therefore each element of A points to a subsection of the original array. You have to assign them though - they'll initially point to random addresses.</p>

<p>The first one is the initial address (<code>&amp;linearA[0]</code>) and the next five are the following ones. These are accessible as <code>A[0][0]</code> to <code>A[0][5]</code>. Because of the way arrays correspond to pointers, you can keep going up, so long as you don't exceed the 30th.</p>

<p>But you can assign <code>A[n]</code> to any part of the array you like. As long as it's part of the original array, it will point that member, and the next 5 (or however many you want).</p>

<p>For example, by pointing <code>A[1]</code> to <code>&amp;linearA[6]</code>, you would effectively be setting up a two dimensional array (it would resemble one, but not behave as one).</p>
",0
15535875,15535521,1,"<blockquote>
  <p>My question is why A[0] is a pointer only to five elements and not to
  ALL of linearA, since the name of an array is a pointer to its first
  member.</p>
</blockquote>

<p>you setup <code>A[0]</code> to point to <code>linearA</code> which is the first float in the array, <code>A[0]</code> is a pointer and thus doesn't know anything about what it points to part from an address. So <code>A[0]</code> is not a pointer to only five elements it points to where the array starts and has no concept of where the array ends.</p>

<blockquote>
  <p>And A[1] = linearA + 5; is 6 elements in a row -- for the same reason?
  Isn't A[1] supposed to be a pointer to the 6th member of linearA?</p>
</blockquote>

<p>yes <code>A[1]</code> points to the sixth element but as said before its a starting address.</p>
",0
15536474,15535521,1,"<p>The example you posted shows a somewhat esoteric technique called <a href=""https://en.wikipedia.org/wiki/Iliffe_vector"" rel=""nofollow"">Iliffe vector</a>, which is one possible way to implement <em>jagged arrays</em> in C. A jagged array is a matrix in which each row has a different length.</p>

<p>Since arrays are one-dimensional in C, you are creating a single array <code>linearA</code> containing all the elements, which is interpreted as a sequence of rows, each of a different size. The pointer array <code>A</code> contains pointers to the first element of each row that allow you to access elements using row and column indices.</p>

<p>The code displays several interesting features of C pointers and arrays:</p>

<pre><code>linearA + 5
</code></pre>

<p>Pointer arithmetic: adding an integer to a pointer (or array) gives you a pointer pointing <em>n</em> elements after the original pointer.</p>

<pre><code>A[3][2] = 3.66;
</code></pre>

<p>This nice syntax allows you to think of this structure as a two-dimensional matrix.</p>

<p>Also, and this is probably the main point of the example, <em>pointers and arrays are interchangeable</em>. Here, <code>A[3]</code> is a pointer to float, since <code>A</code> was defined as an array of pointers to floats; appending <code>[2]</code> gives us the element 2 places after the one pointed by the original pointer. This is similar to the pointer arithmetic above, only in this case the pointer is dereferenced. Actually, array access is defined in terms of pointers so <code>X[5]</code> is equivalent to <code>*(X+5)</code>.</p>

<pre><code>A[3][-3]
</code></pre>

<p>This shows that there is nothing stopping you from accessing an element outside of a given row. In this case, you are accessing the element 3 places <em>before</em> the one pointed by <code>A[3]</code>. This is something that is rarely needed, and it only works in this case because you built the matrix to have contiguous elements. Usually, accessing elements outside the allocated range of an array will crash your program.</p>

<p>Finally, to answer your question:</p>

<blockquote>
  <p>And <code>A[1] = linearA + 5;</code> is 6 elements in a row -- for the same reason? Isn't <code>A[1]</code> supposed to be a pointer to the 6th member of <code>linearA</code>?</p>
</blockquote>

<p>As pointers and arrays are interchangeable, <code>A[1]</code> is <em>both</em> a pointer to the sixth element in <code>linearA</code> <em>and</em> an array starting from the sixth element in <code>linearA</code>. There is nothing in the language saying that the latter is 6 elements long, you have to implement that logic in your code.</p>
",0
14824616,14824552,2,"<p>The C programming language and libraries don't have a print screen per se.  They send output to streams.  In the case of the <code>printf</code> function, for example, there is a default output stream called stdout, which echoes to your terminal, so the following two calls are equivalent:</p>

<pre><code> printf( ""hi!\n"" );
 fprintf( stdout, ""hi!\n"" );
</code></pre>

<p>A line of output to a stream is delimited by a newline character (<code>\n</code>).  (But since you're on windows, you may need to end your lines with <code>\r\n</code>, especially if you redirect your output to a text file sometimes.  See <a href=""http://en.wikipedia.org/wiki/Newline"" rel=""nofollow"">here</a>.)</p>

<p>So I think your question is really about how to control the number of characters your terminal will print before automatically wrapping to the next line (or truncating).  (And maybe how your terminal will deal with tabs?)  This will depend on what hardware, os, and shell you are running, but <a href=""http://en.wikipedia.org/wiki/Termcap"" rel=""nofollow"">Termcap</a> is probably where you want to start if you're using a unix style shell.  If you're using a windows <code>CMD.EXE</code> window, there are some settings you can access through the ""Layout"" tab of the ""Properties menu"", which is accessible via the window menu icon in the upper left hand corner of the menu bar; this will let you set your screen buffer width and thus control whether long lines will wrap or result in a horizontal scroll bar.</p>
",4
14186781,14186763,4,"<p>The single quote marks denote a <code>char</code> literal. Usually that means a single character. Multi-character literals are permitted, but the standard says that their meaning is implementation defined. It would seem that your implementation regards <code>'stop'</code> as being invalid due to having too many characters.</p>

<p>In any case, I'm fairly sure you were not intending to write a multi-character literal. Looking at the snippet of code I think you mean to read the input into a string and use <code>strcmp</code> to test for equality with the string <code>""stop""</code>.</p>
",2
14186798,14186763,1,"<p>Apart from the syntax error ('' instead of """"), you probably wanted to compare strings:</p>

<pre><code>while (strcmp(buf2, ""stop"") != 0) ...
</code></pre>
",0
14155328,14155162,3,"<p>I don't think you want to use float for quite a few of those fields. Unless you're prepared to accept rounding errors in your trade number, Utc sec (seconds), utc nano (presumably nanoseconds)</p>

<p>In which case, you'll need to change the type of these fields to match and use a different scanf string to indicate you are reading (possibly long or long long) integers.</p>

<p>Also, you appear to be using global variables for all this, which isn't a good idea.</p>
",1
14155619,14155162,2,"<p>Apparently you have an unusual printf implementation. It's supposed to work <a href=""http://www.manpagez.com/man/3/printf/"" rel=""nofollow"">like this</a>, but apparently it's not.</p>

<p><code>%f</code> should be the right thing for float or double types. You should only get exponents with <code>%g</code> or <code>%e</code>. Incidentally, <code>%lf</code> should be the same as <code>%f</code>.</p>

<p>You could try adding precision modifiers:</p>

<pre><code>printf(""%100.20f"", utc_sec);
</code></pre>

<p>That example should give a minimum field width of 100 characters, and a maximum precision of 20 digits. Those figures are totally bonkers, of course, but maybe you'll find a trick that works.</p>

<p>If you don't have sub-second accuracy though, there's really no need for floating point types; integers will give greater range, and, if you don't plan to do math on it, a string will give better range still.</p>
",0
14235282,14235183,5,"<p>Because if <code>c</code> is <code>EOF</code>, the <code>while</code> loop terminates (or won't even start, if it is already <code>EOF</code> on the first character typed). The condition for running another iteration of the loop is that <code>c</code> is <strong>NOT</strong> <code>EOF</code>.</p>
",0
14235327,14235183,5,"<p>To display the value of EOF</p>

<pre><code>#include &lt;stdio.h&gt;
int main()
{
   printf(""EOF on my system is %d\n"", EOF);
   return 0;
}
</code></pre>

<p>EOF is defined in stdio.h normally as -1</p>
",0
14235493,14235183,-2,"<p>in your program you are reading character from std input as c = getchar();</p>

<p>this way you can get ascii value of key pressed, Which will never be equal to EOF.</p>

<p>because EOF is End of File.</p>

<p>better you try to open any existing file and read from the file, so when it reached End Of File(EOF), it will quit the while loop.</p>

<p>well the answer in the book is:</p>

<pre><code>int main()
{
  printf(""Press a key\n\n"");
  printf(""The expression getchar() != EOF evaluates to %d\n"", getchar() != EOF);
}
</code></pre>

<p>try to understand the program, it gets a key, which will not be equal to EOF so it should always print ""The expression getchar() != EOF evaluates to 0"".</p>

<p>hope it helps.......</p>
",1
14231641,14231004,2,"<h2>code review</h2>

<p>initialize <strong>all</strong> variables when declaring them</p>

<pre><code>void load(struct player *main)
{
    int bad = 0;
    struct player *act = NULL, *prev =  NULL;    
    FILE *plik = NULL;
    char a = '\0';
</code></pre>

<p>don¡ät use ""l"" as a constant it is difficult to distinguish between l and 1 depending on what font used. </p>

<pre><code>    char text[l] = {0};                 // l=15;


    if((plik = fopen(""savings.txt"", ""r"")) == NULL)
    {
        printf(""No savings\n"");
        return;
    }
</code></pre>

<p>prefer doing sizeof(text) instead of using ""l"" here</p>

<pre><code>    if(fgets(text, sizeof(text), plik) == NULL)

    printf(""\nType the name of the file you want to load (with .txt) \n"");
    do
    {
        // here if user puts his elbow on the keyb it crashes the 
        // program use fgets(buffer,sizeof(buffer),stdin) instead.
        gets(text); 
</code></pre>

<p>Never hide a variablename in another scope, use a new variable name</p>

<pre><code>        char *mytext = malloc(30); // in C don¡ät cast malloc 
</code></pre>

<p>Below you are doing strcat on ""text"" however you just malloc:ed it so there could be anything in the buffer, you should clear the buffer before doing strcat() or use strcpy(_s) / or maybe it was just a typo?</p>

<pre><code>        strcat(text, "".txt"");
</code></pre>

<p>A string in C is a sequence of characters, %s says to printf to expect the address of a string of characters ending with \0 but with <code>*text</code> you are giving a character value to it, that will not end well.</p>

<pre><code>        printf(""%s"", *text);
</code></pre>

<p>it is good to have use {} when you can, not just sometimes</p>

<pre><code>        if((plik = fopen(text, ""r"")) == NULL)
        {
            printf(""There is no such file, type once again \n"");
            bad=1;
        }
        else bad=0;  
    }while(bad);
</code></pre>

<p>check that ""main"" points to something proper before using it.</p>

<pre><code>    if ( main != NULL )
    {
      act = main-&gt;next;
      while(act != NULL)
      {
        prev = act;
        act = act-&gt;next;
        free(prev);
      }
    ...
</code></pre>

<p>here i would suggest you read in the data using fgets() instead and parse the data using sscanf() the way you do it is fragile.</p>

<pre><code>    nr_of_players = 0;
    act = main;
    while(fscanf(plik, ""%s"", act-&gt;name)!=0)
    {
        fscanf(plik, ""%s"", biez-&gt;surname);
        fscanf(plik, ""%d"", &amp;biez-&gt;date_y);
        fscanf(plik, ""%d"", &amp;biez-&gt;date_m);
        fscanf(plik, ""%d"", &amp;biez-&gt;date_d);
        fscanf(plik, ""%s"", biez-&gt;position);
        fscanf(plik, ""%c"", &amp;a);
        fscanf(plik, ""%d"", &amp;biez-&gt;nr_cart);
        fscanf(plik, ""%d"", &amp;biez-&gt;salary);
        fscanf(plik, ""%d"", &amp;biez-&gt;matches);
        act-&gt;id = ++nr_of_players;
</code></pre>

<p>this is unusual, normally you allocate when you find something to put in instead of allocating for the case there may be more to put in.</p>

<pre><code>        act-&gt;next = malloc(sizeof(struct player));
        prev = act;
        act = act-&gt;next;
    }
</code></pre>
",1
14231072,14231004,1,"<p>You are doing:</p>

<pre><code>char *text = (char*) malloc(30);
while (getchar()!='\n')
  continue;
strcat(text, "".txt"");
printf(""%s"", *text);
</code></pre>

<p>The last printf should be:</p>

<pre><code>printf(""%s"", text);
</code></pre>
",0
14231214,14231004,0,"<pre><code>char text[l];                 // l=15;
 .... deleted a bunch of lines ....
do
{
gets(text);         // here program stops, no matter if the name is right or not
char *text = (char*) malloc(30);
while (getchar()!='\n')
  continue;
strcat(text, "".txt"");
</code></pre>

<p>Note that <code>text[l]</code> is used for <code>gets()</code> - and gets is a BAD function to use, as it doesn't prevent overwriting the end of the input buffer AT ALL. It will just crash (or do something else unexpected). </p>

<p>Instead of <code>gets()</code>, use <code>fgets(stdin, ...)</code>. </p>

<p>The code als doesn't make sense. </p>

<p>Why are you allocating a new variable called <code>text</code> that shadows the <code>text</code> you just read something into</p>

<p>If you want a 30 byte string, just create the string with 30 bytes in the first place, rather than 15. </p>

<p>Also, please, please, please don't use variables/constants called <code>l</code> or <code>O</code> - unless you are entering the ""obfuscated C competiton"". They look far too much like the digits One and Zero.</p>
",0
14231216,14231004,0,"<p><code>char *text = (char*) malloc(30);</code></p>

<p>why are you named it <code>text</code>, try some another name, you have already declared <code>text</code> at the start of function.</p>

<p><code>char text[l];</code></p>
",0
14243999,14243969,5,"<p><code>p</code> is a <code>char*</code> so you need to assign a pointer to it but <code>exp[i]</code> returns a single <code>char</code> element from an array.  Try </p>

<pre><code>p = &amp;exp[i];
</code></pre>

<p>or</p>

<pre><code>p = (exp + i);
</code></pre>

<p>instead.</p>
",0
14244100,14243969,0,"<p>do correct the line to correspond to the following <code>p=&amp;(exp[i]);</code> this means that you are assigning the pointer of exp[i] to p.</p>
",0
14244688,14243969,0,"<p>You need take the address-of instead of and then pass to <code>p</code>, that's a pointer. In other words,you are assign  <code>char</code> to a <code>char* returned from value at</code>i<code>index in</code>exp` array. </p>

<p>Try this: <code>p = &amp;exp[i];</code></p>
",0
20021828,20021544,1,"<p>Suggest to use a rotator object like:</p>

<pre><code>typedef struct
{
  int *values;
  int mod;
  int size; //if you want to generalize the rubiks..
}rotator;

void rotate(rotator *rotator)
{
  rotator-&gt;mod = (rotator-&gt;mod + 1) % rotator-&gt;size;
}

void print_rotator(rotator *rotator)
{
  int index;
  fprintf(stdout, ""["");
  for(index = 0; index &lt; rotator-&gt;size; ++index)
  {
    fprintf(stdout, ""%d,"", rotator-&gt;values[(index + rotator-&gt;mod) % rotator-&gt;size]);
  }
  fprintf(stdout, ""]\n"");
}
</code></pre>

<p>Then you can have a think about how to build this into a n-ary cube..</p>
",0
14244319,14243959,8,"<p>Old-style function <em>declarations</em>, in particular, don't allow for compile-time checking of calls.</p>

<p>For example:</p>

<pre><code>int func(x, y)
char *x;
double y;
{
     /* ... */
}
</code></pre>

<p>...</p>

<pre><code>func(10, 20);
</code></pre>

<p>When the compiler sees the call, it doesn't know the types of the parameters of the function <code>func</code>, so it can't diagnose the error.</p>

<p>By contrast:</p>

<pre><code>int better_func(char *x, double y) {
    /* ... */
}
</code></pre>

<p>...</p>

<pre><code>better_func(10, 20);
</code></pre>

<p>will result in a compiler error message (or at least a warning).</p>

<p>Another improvement: prototypes make it possible to have functions with parameters of type <code>float</code>, and of integer types narrower than <code>int</code> (the 3 <code>char</code> types and the two <code>short</code> types). Without a prototype, <code>float</code> is promoted to <code>double</code>, and narrow integer types are promoted to <code>int</code> or to <code>unsigned int</code>. With a prototype, a <code>float</code> argument is passed as a <code>float</code> (unless the function is variadic, like <code>printf</code>, in which case the old rules apply to the variadic arguments).</p>

<p>The <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/C99RationaleV5.10.pdf"" rel=""nofollow"">C Rationale</a> document discusses this in section 6.7.5.3, probably better than I have:</p>

<blockquote>
  <p>The function prototype mechanism is one of the most useful additions 
  to the C language. The feature, of course, has precedent in many of
  the Algol-derived languages of the past 25 years.  The particular form
  adopted in the Standard is based in large part upon C++.</p>
  
  <p>Function prototypes provide a powerful translation-time error 
  detection capability. In traditional C practice without prototypes, it
  is extremely difficult for the translator to detect errors (wrong
  number or type of arguments) in calls to functions declared in another
  source file.  Detection of such errors has occurred either at runtime
  or through the use of auxiliary software tools.</p>
  
  <p>In function calls not in the scope of a function prototype, integer
  arguments have the <em>integer promotions</em> applied and <strong>float</strong>
  arguments are widened to <strong>double</strong>. It is not possible in such a call
  to pass an unconverted <strong>char</strong> or <strong>float</strong> argument. Function
  prototypes give the programmer explicit control over the function
  argument type conversions, so that the often inappropriate and
  sometimes inefficient default widening rules for arguments can be
  suppressed by the implementation.</p>
</blockquote>

<p>There's more; go read it.</p>
",5
14244716,14243959,3,"<p>A non-defining function <em>declaration</em> in K&amp;R looks as follows</p>

<pre><code>int foo();
</code></pre>

<p>and introduces a function that accepts <em>unspecified</em> number of arguments. The problem with such declaration style is obvious: it specifies neither the number of parameters nor their types. There's no way for the compiler to check the correctness of the call with respect to the number of arguments or their types at the point of the call. There's no way for the compiler to perform the argument type conversion or issue and error message in situations when argument type does not match the expected parameter type.</p>

<p>A function declaration, which is used as a part of function <em>definition</em> in K&amp;R looks as follows</p>

<pre><code>int foo(a, b) 
int a;
char b;
{ ...
</code></pre>

<p>It specifies the number of parameters, but still does not specify their types. Moreover, even though the number of parameters appears to be exposed by this declaration, it still formally declares <code>foo</code> the same way as <code>int foo();</code> does, meaning that calling it as <code>foo(1, 2, 3, 4, 5)</code> still does not constitute a constraint violation.</p>

<p>The new style, i.e. declaration with prototype is better for obvious reasons: it exposes both the number and the types of parameters. It forces the compiler to check the validity of the call (with regard to the number and the types of parameters). And it allows the compiler to perform implicit type conversions from argument types to parameter types.</p>

<p>There are other, less obvious benefits provided by prototype declarations. Since the number and types of function parameters are known precisely to both the caller and the function itself, it is possible to choose the most efficient method of passing the arguments (the calling convention) at the point of the call without seeing the function definition. Without that information K&amp;R implementations were forced to follow a single pre-determined ""one size fits all"" calling convention for all functions.</p>
",0
15511997,15511654,0,"<p>Two things here need addressing.</p>

<p>The loop condition is wrong by one-:</p>

<pre><code>for(i = 0; i &lt; 16; i++) {
</code></pre>

<p>The logic needs reversing-:</p>

<pre><code>if(rem == 0)
    binaryNumber[i]='0';
else
    binaryNumber[i]='1';
</code></pre>
",0
15511762,15511654,2,"<p>I will not give you direct answer, because it is homework, I will point where to search for. Take a close look at what you do after you get a remainder. Try to print it right where you get it and analyze what you see.</p>

<p>Unrelated but also wrong <code>for(i = 0; i &lt;= 16; i++)</code>, will eventually write to 17th element, which is nonexistent.</p>
",2
16442836,16442803,5,"<p><code>top_number</code> and <code>bottom_number</code> are declared as <code>float</code> but you try to print them as <code>int</code> (the <code>%d</code> format specifier tells <code>printf</code> to interpret an argument as type <code>int</code>).  <code>int</code> and <code>float</code> have different sizes and bit representations so this doesn't work.</p>

<p>There are a number of options to fix this.  You could change them to <code>int</code></p>

<pre><code>int top_number;
int bottom_number;
</code></pre>

<p>or change the format specifiers in your final <code>printf</code> to <code>%f</code></p>

<pre><code>printf (""The Slope is %f/%f"", top_number, bottom_number);
</code></pre>

<p>or cast the values in your <code>printf</code></p>

<pre><code>printf (""The Slope is %d/%d"", (int)top_number, (int)bottom_number);
</code></pre>

<p>Note that there is no benefit in using <code>float</code> unless you may need to represent a fraction.  This isn't possible here as you're subtracting two <code>int</code>s.  A calculation of the slope (<code>top_number/bottom_number</code>) should however be treated as <code>float</code>.</p>

<p>Finally, as hmjd earlier mentioned, you should really check the return value from <code>scanf</code> to make sure you have actually read an <code>int</code> after each call</p>

<pre><code>while (scanf(""%d"", &amp;one_y) != 1);
// repeat this pattern for each scanf call
</code></pre>
",0
16442955,16442803,1,"<p>You are using printf to display floats using the integer placeholder %d. You need to use %f to display floats.</p>

<p>But...why do you need floats here? You are subtracting integers, so your answers will be integers. Change the type of top_number and bottom_number to int.</p>

<p>Still won't be perfect as your displayed ""fraction"" won't be reduced to it's minimal form, but that's another project, right?</p>
",0
15882576,15882531,1,"<p>Any modern desktop operating system would reclaim the resources when the process exits. There will be no memory leak.</p>
",0
15882590,15882531,4,"<p>Memory won't be freed by your program or libc, but will be freed by the operating system on all modern operating systems.  They assign memory to specific processes and clean up the memory when the process terminates.</p>
",1
15882594,15882531,1,"<p>It depends on what OS you are using. Obviously, any modern desktop OS is designed to clear after you when your program exits, if necessary.</p>
",0
15882597,15882531,1,"<p>If you look at the C standard, it's implementation specific so you can't be sure about that.</p>

<p>But most OS will free the memory once a process is terminated, but it may not be the case on some smaller/simpler platforms.</p>
",0
15882598,15882531,1,"<p>That is not a c question.  How the heap is implemented depends on compiler and what the os does after a program exits.  To my knowledge all modern os free memory resources when a program exits. This may not be true on some embedded systems or drivers. </p>
",2
15882720,15882531,15,"<p>The answer is, most often.</p>

<p>Freeing the heap is responsiblity of the OS. While most OS (especially mainstream OS) frees the heap upon exit, it is not necessarily true of say embedded system OS.</p>

<p>When you call for memory to be allocated on the heap, a system call is made to the kernel space of the OS to provide this memory. This memory is mapped to your process structure, which is maintained by the OS. When your program exits, the OS goes through a clean up routing, closing all file descriptors, and marks this memory free for allocation to other processes (among other things).</p>

<p>Some of these answers are incorrect in saying that it is compiler dependant. The compiler does not say 'hey free all this memory on program exit'. That wouldn't make sense, what happens if the OS unexpectedly terminates the program then? No, the compiler is responsible for generating <em>system calls</em> whenever memory allocation/deallocation is explicitly requested for the heap.</p>
",1
15822721,15822660,10,"<p>Modified from <a href=""http://www.cplusplus.com/reference/cstring/strtok/"" rel=""nofollow noreferrer"">cplusplus</a> <code>strtok</code> example:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
int main ()
{
    char str[] =""1,2,3,4,5"";
    char *pt;
    pt = strtok (str,"","");
    while (pt != NULL) {
        int a = atoi(pt);
        printf(""%d\n"", a);
        pt = strtok (NULL, "","");
    }
    return 0;
}
</code></pre>
",9
15822830,15822660,0,"<p>I don't know the functions mentioned in the comments above but to do what you want in the way you are asking I would try this or something similar. </p>

<pre><code>char *strings = ""1,5,95,255"";
char number;
int i = 0; 
int value = 1;

printf (""value%d = "", value);
value++; 

while (strings[i] != NULL) {
   number = string[i];
   i++;
   if (number == ',') 
       printf(""\nvalue%d = "",value++);
   else 
       printf(""%s"",&amp;number);
} 
</code></pre>
",0
15823143,15822660,0,"<p>If you don't have a modifiable string, I would use <code>strchr</code>. Search for the next <code>,</code> and then scan like that</p>

<pre><code>#define MAX_LENGTH_OF_NUMBER 9
char *string = ""1,5,95,255"";
char *comma;
char *position;
// number has 9 digits plus \0
char number[MAX_LENGTH_OF_NUMBER + 1];

comma = strchr (string, ',');
position = string;
while (comma) {
    int i = 0;

    while (position &lt; comma &amp;&amp; i &lt;= MAX_LENGTH_OF_NUMBER) {
        number[i] = *position;
        i++;
        position++;
    }

    // Add a NULL to the end of the string
    number[i] = '\0';
    printf(""Value is %d\n"", atoi (number));

    // Position is now the comma, skip it past
    position++;
    comma = strchr (position, ',');
}

// Now there's no more commas in the string so the final value is simply the rest of the string
printf(""Value is %d\n"", atoi (position)l
</code></pre>
",0
18793463,18449586,1,"<p>There is a flaw in your logic. </p>

<p>Consider the case where the input array is {2,4,1,8}</p>

<p>The answer for this should be 2, since the collections {1,2} and {4,8} can be formed. However, your code will output 1 for this case (it will pair 2 with 4, and be able to create only one collection).</p>

<p>I have solved this problem by sorting the array, then for each element, check whether two times that element exists or not. If yes, mark it as used and increment the count of collections.</p>

<p>(pseudo-code):
<code></p>

<pre><code>sort(array)
count = 0;
for(i=0;i&lt;size;i++){
  if(used[i]) continue; //used elements should not be re-considered
  for(j=i+1;j&lt;size;j++){
     if(array[j]==2*array[i] &amp;&amp; !used[j]){
        used[j] = true;.
        count++;
     }
  }
}
</code></pre>

<p></code>
The variable <i>count</i> will now have the maximum possible number of collections.</p>

<p>Note that searching for 2*array[i] in the array can also be implemented by binary search, but that would be unnecessary since the array is really small (size &lt;=100)</p>

<p>Here's my <a href=""https://github.com/akhiluanandh/SPOJ/blob/master/IITKWPCO.cpp"" rel=""nofollow""> C++ code  </a> for the problem. ( I have used the c++ standard library for sorting, you may use any sorting algorithm of your choice ).</p>

<p>Hope this helps.
Cheers.</p>
",0
15891862,15891842,0,"<p>I don't see rootNode even assignated, residing in the static space it therefore holds the nullptr constant. You are dereferencing it with the -> operator, so it cannot be done.
First make it point to some object !</p>
",4
15891864,15891842,0,"<p>Dereferencing a NULL pointer will result in a segmentation fault.</p>

<p>One can only assume that <code>rootNode</code> is NULL, since it will enter the code block when you change the condition to <code>if(rootNode == NULL)</code>. One would further assume this is because it was never assigned.</p>

<p>Furthermore, you <em>clearly</em> never set <code>theNode</code> to point to anything, so the line <code>theNode-&gt;status</code> will attempt to dereference <code>theNode</code>, which points to...who knows what.</p>

<p>Solution: <em>Assign values to your variables</em>.</p>

<p>See also: <a href=""http://en.wikipedia.org/wiki/Segmentation_fault"" rel=""nofollow"">http://en.wikipedia.org/wiki/Segmentation_fault</a></p>
",2
15891887,15891842,1,"<blockquote>
  <p>...and declaring theNode and rootNode as <code>NULL</code> does not help.</p>
</blockquote>

<p>Dereferencing <code>NULL</code> (usually) <em>will</em> result in a segfault. You've got to set them to something more useful (like an allocated structure) before you go off modifying them!</p>
",2
14748281,14748191,0,"<p>Assuming you've loaded the WAV data into memory, all you need to do is:</p>

<ol>
<li>Open the two output files (using <code>fopen()</code>).</li>
<li>Loop over the sample data, and for each sample:
<ul>
<li>Put the left channel's value in the first file</li>
<li>Put the right channel's value in the second file</li>
</ul></li>
<li>Close the files.</li>
</ol>
",0
14748286,14748191,3,"<p>Use a file format spec such as <a href=""https://ccrma.stanford.edu/courses/422/projects/WaveFormat/"" rel=""nofollow"">this one</a> to see how to read the file header, determining sample rate, bit rate etc.</p>

<pre><code>The canonical WAVE format starts with the RIFF header:

0         4   ChunkID          Contains the letters ""RIFF"" in ASCII form
                               (0x52494646 big-endian form).
4         4   ChunkSize        36 + SubChunk2Size, or more precisely:
                               4 + (8 + SubChunk1Size) + (8 + SubChunk2Size)
                               This is the size of the rest of the chunk 
                               following this number.  This is the size of the 
                               entire file in bytes minus 8 bytes for the
                               two fields not included in this count:
                               ChunkID and ChunkSize.
8         4   Format           Contains the letters ""WAVE""
                               (0x57415645 big-endian form).

The ""WAVE"" format consists of two subchunks: ""fmt "" and ""data"":
The ""fmt "" subchunk describes the sound data's format:

12        4   Subchunk1ID      Contains the letters ""fmt ""
                               (0x666d7420 big-endian form).
16        4   Subchunk1Size    16 for PCM.  This is the size of the
                               rest of the Subchunk which follows this number.
20        2   AudioFormat      PCM = 1 (i.e. Linear quantization)
                               Values other than 1 indicate some 
                               form of compression.
22        2   NumChannels      Mono = 1, Stereo = 2, etc.
24        4   SampleRate       8000, 44100, etc.
28        4   ByteRate         == SampleRate * NumChannels * BitsPerSample/8
32        2   BlockAlign       == NumChannels * BitsPerSample/8
                               The number of bytes for one sample including
                               all channels. I wonder what happens when
                               this number isn't an integer?
34        2   BitsPerSample    8 bits = 8, 16 bits = 16, etc.
          2   ExtraParamSize   if PCM, then doesn't exist
          X   ExtraParams      space for extra parameters

The ""data"" subchunk contains the size of the data and the actual sound:

36        4   Subchunk2ID      Contains the letters ""data""
                               (0x64617461 big-endian form).
40        4   Subchunk2Size    == NumSamples * NumChannels * BitsPerSample/8
                               This is the number of bytes in the data.
                               You can also think of this as the size
                               of the read of the subchunk following this 
                               number.
44        *   Data             The actual sound data.
</code></pre>

<p>After that, you'll find raw pcm data, interleaved like</p>

<pre><code>[sample 1      ][sample 2      ]
[s1,ch1][s1,ch2][s2,ch1][s2,ch2]
</code></pre>

<p>You could open a text file per sample in write, binary mode, then loop over the audio data, reading the bytes for a single sample/channel then using <code>fprintf</code> or <code>fwrite</code> to write them to the correct file.</p>
",3
14748347,14748191,1,"<p>The sampling frequency is irrelevant for this, but the size per sample (typically 8 or 16 bit per channel per sample) decides which pointer-size you need to use, so here the example of 8 bit per channel:</p>

<pre><code>char* reader = begin; // interleaved
char* left = malloc(numsamples); // de-interleaved
char* right = malloc(numsamples);
while(reader&lt;end) {
    *left = *reader;
    ++left;
    ++reader;
    *right = *reader;
    ++right;
    ++reader;
}
</code></pre>

<p>To do the same for 2 channel 16 bit interleaved audio you just declare all 3 buffers as <code>short*</code> and instead <code>malloc(numsamples*2)</code></p>
",2
15852564,15852556,4,"<p>The <code>if</code> condition is fine. The problem is the <code>scanf()</code> format, which should be </p>

<pre><code>scanf(""%c"",&amp;op);
</code></pre>

<p>(<code>%i</code> reads an integer whereas <code>%c</code> reads a <code>char</code>.)</p>
",4
15852566,15852556,0,"<pre><code>scanf(""%i"", &amp;op);
</code></pre>

<p>You are expecting an integer. So, when you write a character and press <code>&lt;Enter&gt;</code>, <code>scanf</code> fails (you can check its return value to see it):</p>

<pre><code>if (scanf(""%i"", &amp;op) != 1)
{
    /* Treat the error. */
}
</code></pre>

<p>Use rather <code>%c</code> format in <code>scanf</code> to read characters:</p>

<pre><code>scanf(""%c"", &amp;op);
</code></pre>
",0
15854206,15852556,0,"<p>Your problem is with wrong format specifier</p>

<pre><code>//In scanf instead of 
scanf(""%i"",&amp;op);
// you have to provide 
scanf(""%c"",&amp;op);

%i use for reading integer whereas %c use for reading char.
</code></pre>
",0
16415534,16415464,8,"<p>To start with, the variable <code>fNum</code> doesn't <em>point</em> to anything. It's the actual value.</p>

<p>And a floating point number is <em>not</em> the same as an integer. The bit-patterns in memory are <em>very</em> different for a floating point number.</p>
",4
16415550,16415464,0,"<p><code>fNum</code> contains <a href=""http://en.wikipedia.org/wiki/Floating_point"" rel=""nofollow"">floating point</a> binary presentation of <code>12.3</code>. So when your print the content of the <code>fNum</code> memory as integer you will get the translation this binary set as decimal value</p>
",0
19215786,19215738,2,"<p>The compiler is right, your replace_with_lowest_byte_in_x() expects two <code>unsigned char *</code>, but you pass two <code>int</code>s to it. Yes, the <code>int</code>s can be regarded as memory address, but it's dangerous, so there is a warning. <code>&amp;variable</code> gives you the address of variable.</p>
",0
19215795,19215738,3,"<p>The function expects two pointers but you're passing integer(-constant)s. What you probably want is to put the numbers in their own variables and pass the addresses of those to the function: (in <code>main</code>):</p>

<pre><code>int a = 12345, b = 54321;

replace_with_lowest_byte_in_x(&amp;a, &amp;b);
</code></pre>

<p>Note that you're still passing incompatible pointers.</p>
",1
14752070,14752012,2,"<p>You're trying to add an address to a pointer, that's not a valid operation.</p>

<p>You probably meant:</p>

<pre><code>*total += pA[i];
</code></pre>

<p>Your use of <code>&amp;pA</code> seems very confused, as does the re-assignment of the pointers <code>min</code> and <code>max</code>. </p>

<p>If you have a pointer to a value (like <code>double *min</code>), then <code>*min</code> is how you access (read or write) the value being pointed at.</p>
",0
14752129,14752012,5,"<p>It seems like you're getting some of the types confused there. In your example you're setting the <em>pointers</em> to a new value, not the value of said pointers.</p>

<p>The first would have to be:</p>

<pre><code>*total += pA[i];
</code></pre>

<p>While the second should be:</p>

<pre><code>*avg = (*total / lines);
</code></pre>

<p>In fact, you probably want to use floating point division on the second error there (some compilers are notorious for using integer divison in unexpected places):</p>

<pre><code>*avg = (*total / (double)lines);
</code></pre>

<p>You'll still be getting errors if you do it like that, however. For example <code>&amp;pA[i] &gt; ...</code> will result in a pointer comparison, i.e. the <em>address</em> of the pointers will be compared. Most likely not what you want.</p>
",3
14752148,14752012,1,"<p>There is no ""pass by reference"" in C language unlike C++. You should dereference each pointer in your code if you want work with variables values. Now you work with variables addresses.</p>
",1
14754102,14753648,0,"<p>I have just tested your code and it works. The only difference i made is stdin in fscanf and have included max,min,avg and lines.<br><br></p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;


void MinMaxAvg(double *pA, double *min, double *max, double *avg, int lines)
{
    double total = 0;

    for (int i=0; i&lt;lines; i++)
    {
    if ( i==0)
    {
        *min = pA[0];
        *max = pA[0];
    }
    else
    {
        if (pA[i] &lt; *min)
        {
        *min = pA[i];
        }

        if (pA[i] &gt; *max)
        {
        *max = pA[i];
        }
    }

    total += pA[i];

    }

    *avg = (total / (double)lines);

return;
}



int main(int argc, char** argv)
{
    double *pA = NULL;

    int lines = 3;

    double min,max,avg;

    pA = (double *)malloc(lines*sizeof(double));

    //Fills Array

    for (int i=0; i&lt;lines; i++)
    {
        fscanf(stdin, ""%lf"", &amp;pA[i]);
    }

     MinMaxAvg( pA, &amp;min, &amp;max, &amp;avg,  lines);


    for (int i=0; i&lt;lines; i++)
    {
        printf(""%lf \n"", pA[i]);
    }

    printf( ""min: %f  max: %f  avg: %f"" , min , max , avg );
}
</code></pre>
",1
14754296,14753648,3,"<p>You counted number of lines in the file into local variable ""lines"" in function ReadData(), but this does not mean that it is passed back to main.
The ""lines"" variable value which is passed to MinMaxAvg() is zero.</p>
",3
14754432,14753648,-1,"<p>Based on what you have in your questions, if you are populating pA in a function I suspect you are not changing the contents of pA, which may be the issues.  It may be helpful/useful to see the routine you are using to populate pA. </p>

<p>C functions call by value if so you are just passing in a pointer (just pA), to change the value of the pointer, you need to pass the address of the pointer (pointer to a pointer if you will).  Then you need to deference once it to set the pointer (to the pointer) and then deference it twice to set the values in allocated memory/array.</p>

<p>So the calling to the function is </p>

<pre><code>void init(File *fpin, double **pA, int lines)
{
  /* Deference once to set the pointer to the pitner */
  *pA = (double *)malloc(lines*sizeof(double));

  for (int i=0; i&lt;lines; i++)
  {
     /* deference twice to set the the element of the pointer to the pointer */
     fscanf(fpIn, ""%lf"", &amp;(**pA)[i]);
  }
}
</code></pre>

<p>and then in calling the routine, you need to pass in the address of pA.   </p>

<pre><code>init(fpIn,&amp;pA,lines);
</code></pre>

<p>Here is a link which might help explain pointers to pointers:
<a href=""http://www.thegeekstuff.com/2012/01/advanced-c-pointers/"" rel=""nofollow"">http://www.thegeekstuff.com/2012/01/advanced-c-pointers/</a></p>

<p>It has been a long time since I have done pointers to pointers, but if you use the above, you may have to make some minor changes.</p>

<p>As larsmans is hinting, I like his suggestion of changing the routine to return the pointer to the memory you allocated and place that value in pA. </p>

<pre><code>double* init(File *fpin, int lines)
{
  double *local = (double *)malloc(lines*sizeof(double));

  //Fills Array

  for (int i=0; i&lt;lines; i++)
  {
    fscanf(fpIn, ""%lf"", &amp;local[i]);
  }

  return(local);
</code></pre>

<p>}</p>

<p>and then in the calling to init</p>

<pre><code>pA = init(fpIn,lines);
</code></pre>

<p>Depending upon what you are trying to accomplish, this may be easier to understand and not quite as complex.</p>
",0
15802224,15802164,2,"<p>The C core language provides no means to re-interpret literals in any way other than what the standard provides for.</p>

<p>C++11, on the other hand, introduces user-defined literals, by which you could meaningfully write</p>

<pre><code>negbyte operator """" _nb(unsigned long long);

negbyte val = 0xff_nb;
</code></pre>
",1
15882585,15882520,1,"<p>From your question, it is clear that <code>item_temp</code> is pointing to location <code>0xc</code> and de-referencing <code>next</code> is causing the code to access an invalid address and hence, the segmentation fault.</p>

<p><code>item_temp = table-&gt;buckets[code]-&gt;head;</code> is evaluating to <code>0xc</code>. </p>
",1
19259917,19259434,1,"<blockquote>
  <p>am I allowed to access the member of the structure without creating
  struct object</p>
</blockquote>

<p>You have already allocated space for the struct object. There is not a further step to create a struct object. You can write to this object and read from fields that you have written to previously.</p>

<p>Regarding the second question, it looks like you are overwriting the value here, within <code>postfixToTree</code>:</p>

<pre><code>*root = popNode(&amp;X);
</code></pre>

<p><code>root</code> is <code>&amp;csPtr-&gt;nodeArray[0]</code> in the calling code, and so <code>*root</code> is <code>csPtr-&gt;nodeArray[0]</code>, hence it is overwritten.</p>

<p>Without understanding the whole of the code, I can't say why you've written it this way. But I suspect you are returning a pointer to locally allocated memory. Within <code>postfixToTree</code> you define</p>

<pre><code>struct command nodeCmd[255] = { 0 };
</code></pre>

<p>Later you assign a pointer to a member of this array:</p>

<pre><code>newNode[j] = &amp;nodeCmd[j];
</code></pre>

<p>And enter it onto your local data structure <code>X</code> (using a <code>pushNode</code> function we don't see):</p>

<pre><code>pushNode(&amp;X,newNode[k]);
</code></pre>

<p><code>popNode(&amp;X)</code> presumably retrieves one of these entries from <code>X</code>. <em>But pointers to local data in functions are not valid after the function returns.</em></p>
",3
18829923,18829873,2,"<p>A few pointers:</p>

<ol>
<li>Don't use <code>feof()</code>, it's never needed for code like this.</li>
<li>Read a full line at once, with <code>fgets()</code>.</li>
<li>Then parse the line, using e.g. <code>sscanf()</code>.</li>
<li><em>Check the return values</em> from I/O functions, they can fail (for instance at end of file).</li>
</ol>
",0
18830220,18829873,2,"<p><strong>UPDATED</strong> to allow reading of variable number of lines</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void) {
  int value1, value2, value3, i;
  char *col1, *col2;
  char lineBuf[100];
  FILE* file;

  file = fopen(""scanme.txt"",""r"");

  fgets(lineBuf, 100, file);
  sscanf(lineBuf, ""%d"", &amp;value1);
  fgets(lineBuf, 100, file);
  sscanf(lineBuf, ""%d"", &amp;value2);
  fgets(lineBuf, 100, file);
  sscanf(lineBuf, ""%d"", &amp;value3);

  // create space for the character columns - add one for terminating '\0'
  col1 = calloc(value3 + 1, 1);
  col2 = calloc(value3 + 1, 1);

  for(i = 0; i &lt; value3; i++) {
    fgets(lineBuf, 100, file);
    sscanf(lineBuf, ""%c,%c"", &amp;col1[i], &amp;col2[i]);
  }
  fclose(file);

  printf(""first three values: %d, %d, %d\n"", value1, value2, value3);
  printf(""columns:\n"");
  for (i = 0; i &lt; value3; i++) {
    printf(""%c  %c\n"", col1[i], col2[i]);
  }

  // another way of printing the columns:
    printf(""col1: %s\ncol2: %s\n"", col1, col2);
}
</code></pre>

<p>I performed none of the usual error checking etc - this is just to demonstrate how to read things in. This produced the expected output with the test file you had. I hope you can take it from here.</p>
",4
14249505,14249478,0,"<p><code>&amp;array[0][0]</code> is an int pointer. </p>

<p>A pointer can't be converted to a two-dimensional array. For this reason, you need to pass it like <code>f(array, 16)</code>. Basically you're passing an <code>int*</code> and that is incompatible with an <code>int[][4]</code>.</p>

<p>It's worth pointing out that this is valid for one dimensional arrays (though it's unnecessary and potentially confusing):</p>

<pre><code>void g(int x[]) {}
int arr[4];
g(arr); //valid of course
g(&amp;arr[0]); //also valid
</code></pre>

<p><a href=""https://stackoverflow.com/a/12813676/567864"">This</a> explains why it's different with multi-dimensional arrays.</p>
",3
14782296,14781981,0,"<p>you would want to allocate an array of pointers first with an initial size say 10:</p>

<pre><code>int size = 10;
char **inputFile= malloc(sizeof*inputFile*size);
</code></pre>

<p>Then for each word you read you allocate more memory for it and insert it into the array: </p>

<pre><code>char line[100];
fscanf(file, ""%s"", line);
inputFile[index++] = strdup(line);
</code></pre>

<p>Now check if you need more words then you realloc the array:</p>

<pre><code>if (index==size) {
   size += 10;
   inputFile = realloc(inputFile, sizeof*inputFile*size);
}
</code></pre>

<p>So you end up with something like this:</p>

<pre><code>[0]-&gt;""alex""
[1]-&gt;""john""
[2]-&gt;""jane""
[3]-&gt;""smith""
</code></pre>

<p>When you're done you need to loop over the array and free each string and then free the array, this part is left as an exercise :)</p>
",5
14782988,14781981,0,"<p>You can try the following or just study how it's done. It works fine on my linux machine. Let me know if you have any questions.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

const int INITIAL_MAX_LINES = 2;
const int MAX_LINES_INC = 2;

const int INITIAL_MAX_LINE_LENGTH = 2;
const int MAX_LINE_LENGTH_INC = 2;

int main (int argc, char *argv[])
{
  int nlines = 0, i;
  FILE *fp = fopen(argv[1], ""r"");
  char **inputFile, *buffer;
  int max_lines, c, buflen, bufpos, end_of_line;

  if (argc &lt; 2) {
    printf(""No enough arguments.\n"");
    return -1;
  }

  max_lines = INITIAL_MAX_LINES;

  inputFile = (char **) malloc(max_lines * sizeof(char*));
  if (fp==0) {
    fprintf(stderr, ""Cannot open file!\n"");
    return -1;
  }
  else{
    /* Start with a buffer. */
    bufpos = 0;
    buflen = INITIAL_MAX_LINE_LENGTH;
    buffer = (char *) malloc(buflen * sizeof(char *));

    c = 0;
    while (c != EOF) {

      end_of_line = 0;

      c = fgetc(fp);

      if (c == EOF || c == '\n' || c == '\r') {
        end_of_line = 1;
       /* Discard this character. */
      }
      else {
        /* Put this character in the buffer. */
        /* But check if we have enough memory first! */
        /* Leave room for the null character at the end. */
        if (bufpos &gt;= buflen - 1) {
          buflen += MAX_LINE_LENGTH_INC;
          buffer = (char *) realloc(buffer, buflen * sizeof(char));
        }
        buffer[bufpos] = c;
        bufpos++;
      }

      if (end_of_line) {
        /* Remember this line and get a new buffer. */
        /* Check if we need more memory. */
        if (nlines &gt;= max_lines) {
          max_lines += MAX_LINES_INC;
          inputFile = (char **) realloc(inputFile, max_lines * sizeof(char*));
        }

        /* Null terminate the buffer.*/
        buffer[bufpos++] = 0;

        inputFile[nlines] = buffer;
        nlines++;

        bufpos = 0;
        buflen = INITIAL_MAX_LINE_LENGTH;
        buffer = (char *) malloc(buflen * sizeof(char *));
      }
    }
  }

  printf(""%d lines\n"", nlines);
  for (i=0; i&lt;nlines; i++) {
    printf(""%s\n"", inputFile[i]);
  }
}
</code></pre>
",0
14730865,14730651,-1,"<p>Something like that should work... (But describe what you mean by recursive...)</p>

<pre><code> int ascending_check (int* in_tab, int tab_size)
{
   int i=0;
   int previous_value = INT_MIN //in limits.h

   for (i=0;i&lt;tab_size; i++)
   {
      if(previous_value &gt;= in_tab[i])
      {
          return i;
      }
   }

   return -1; //Ascending tab.
}
</code></pre>

<p>Next time, please give us more information on what you tried :)</p>
",4
14730930,14730651,1,"<p>To design a recursive function, a good idea is to use tail-recursion (which will be turn to iterative with a good compiler).</p>

<pre><code>int CheckAscendingOrder (const int *array, int size, int idx, int prec)
{
  int res;

  if (idx &gt;= size)
  {
    res = -1;
  }
  else if (array[idx] &lt; prec)
  {
    res = idx;
  }
  else
  {
    res = CheckAscendingOrder (array, size, idx + 1, array[idx]);
  }

  return res;
}
</code></pre>
",6
14731206,14730651,0,"<pre><code>int ArrayAscending(int a[], int n)
{
static int i=0;
if(i==n) return 1;
return (a[i]&lt;a[i+++1] &amp;&amp; ArrayAscending(a, n));
}
</code></pre>

<p>Returns 0 -- if the array is not in ascending order.<br>
Returns 1 -- if the array is in ascending order.</p>
",0
14732019,14730651,3,"<p>Recursive func that</p>

<ul>
<li>returns -1 if array is in ascending order</li>
<li>returns the index of the first item that fails (means &lt; a[i-1])</li>
<li>takes only the two parameters</li>
</ul>

<p>Algo</p>

<pre><code>int recur(int *a, int n) {
  static int i=0;
  if (i &gt;= n-1) return -1;
  if (a[i] &gt; a[i+1]) return i+1;
  return i++, recur(a, n);
}
</code></pre>

<p>Edit from comment: function that can be called several times (not reentrant)</p>

<pre><code>int recur(int *a, int n) {
  static int i=0;
  if (i &gt;= n-1 || a[i] &gt; a[i+1]) {
    int ret = (i &gt;= n-1 ? -1 : i+1);
    i = 0;
    return ret;
  }
  return i++, recur(a, n);
}
</code></pre>
",3
15844596,15844447,0,"<p>Here's a solution:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main()
{
    FILE * ifp = fopen(""file.txt"",""r""); //Open the input file
    int cars = 5, i , j; // Initialized cars and counters i and j
    char *view=""VIEW"", *bid=""BID"", *CLOSE=""CLOSE"";
    int CAR[10], START_BID[10], MIN_INCREASE[10];

    for (i = 0; i &lt; cars; i++) 
    {
        fscanf(ifp, ""%d %d"", &amp;START_BID[i],&amp;MIN_INCREASE[i]);
    }

    for (i = 0; i &lt; cars; i++) 
    {
        printf(""%d %d\n"", START_BID[i], MIN_INCREASE[i]);
    }
    fclose(ifp);
    return 0;
}
</code></pre>
",0
15844643,15844447,0,"<p>From your question, to read the data, the first loop has to be modified as thus</p>

<pre><code> for (i = 0; i &lt; cars; i++) {
     fscanf(ifp, ""%d"", &amp;START_BID[i]);
     fscanf(ifp, ""%d"", &amp;MIN_INCREASE[i]);
 }
</code></pre>

<p>and to print the data as separate arrays</p>

<pre><code>printf(""\nStarting Bids:\t"");
for (i = 0; i &lt; cars; i++) {
    printf(""%d\t"", START_BID[i]);
}

printf(""\nMinimum Increase:\t"");
for (i = 0; i &lt; cars; i++) {
  printf(""%d\t"", MIN_INCREASE[i]);
}

printf(""\n"");
</code></pre>

<p>With this the output console would look like</p>

<pre><code>Starting Bids:  50      250     5       500     300
Minimum Increase:       40      140     6       50      200
</code></pre>
",0
15846161,15846098,2,"<p>The pointers you pass to scanf() are incorrect.</p>

<p>Change:</p>

<pre><code>   scanf(""%d"", k);
</code></pre>

<p>to              </p>

<pre><code>   scanf(""%d"", &amp;k);
</code></pre>

<p>and change:</p>

<pre><code>scanf(""%s"", &amp;choice1); // 
</code></pre>

<p>to </p>

<pre><code> scanf(""%s"", choice1); // 
</code></pre>

<p>in two places.</p>
",5
13406777,13406647,2,"<pre><code>char *buffer = malloc(sizeof(buf));
</code></pre>

<p>sizeof means ""size of buf's type"", ie the size of a pointer to char; you probably want</p>

<pre><code>malloc(strlen(buf) + 1); /* 1 for trailing '\0' */
</code></pre>

<p>Then you are mistaking the value of the bytes for their conversion to string:
""256"" is byte '2' followed by byte '5' and '6' -- '2' is not equals to 2, '5' is not equals to 5 etc.
The 256 you are talking about is 00000001 00000000 instead (try dumping the bytes to stdout and you'll see).</p>

<p>Also, recordType should be of type uint16_t, not unsigned -- you're never too paranoid.</p>

<p>EDIT: atoi takes a pointer to char, as in</p>

<pre><code>atoi(""123"")
</code></pre>

<p>not a pointer to int!</p>
",0
13406758,13406657,3,"<p>Check your caller of <code>f1()</code> and make sure your parameter is <strong>valid</strong>.</p>

<p>This will work:</p>

<pre><code>struct node *you = malloc(sizeof(struct node));
if (you)
{
    f1(you);
    free(you);
} 
</code></pre>

<p>As will this:</p>

<pre><code>struct node me;
f1(&amp;me);
</code></pre>

<p><strong>This will NOT work</strong></p>

<pre><code>struct node *me;
int f1(me);
</code></pre>
",2
13407308,13406657,0,"<p>Some observations to note:</p>

<ol>
<li><p><code>sizeof(char)</code> is one by definition.</p></li>
<li><p>Recommended way of calling <code>malloc</code> is one that avoids casts as well as gets sizeof to infer the type from the pointer being allocated.  (See below)</p></li>
<li><p>Avoid using names such as <code>new</code> for your identifiers (to the extent possible).</p></li>
<li><p>Remember to <code>free</code> the <code>string</code> member within <code>node</code> when you are done.</p></li>
</ol>

<p>To elaborate #2, see below --</p>

<pre><code>struct MyType *foo;
foo = malloc( n * sizeof *foo ); /* allocate n elements where n &gt; 0 */
</code></pre>

<p>For some reason, if you chose foo to be of some other type, the <code>malloc</code> call is one less line for you to worry about.  Also, should you forget to include stdlib.h, the compiler will let you know about it.</p>
",0
14832594,14827742,1,"<p>libbmp is a very good choice.</p>

<p><a href=""http://code.google.com/p/libbmp/"" rel=""nofollow"">http://code.google.com/p/libbmp/</a></p>
",0
14827674,14827665,2,"<p>Because the standard mandates that this is true.</p>

<p>¡ì6.7.8.10 of the C99 standard says:</p>

<blockquote>
  <p>If an object that has automatic storage duration is not initialized explicitly, its value is indeterminate. If an object that has static storage duration is not initialized explicitly, then:</p>
  
  <p>¡ª if it has pointer type, it is initialized to a null pointer;</p>
  
  <p>¡ª if it has arithmetic type, it is initialized to (positive or unsigned) zero;</p>
  
  <p>¡ª if it is an aggregate, every member is initialized (recursively) according to these rules;</p>
  
  <p>¡ª if it is a union, the first named member is initialized (recursively) according to these rules.</p>
</blockquote>
",1
14827711,14827665,2,"<p>Initializing to 0 makes sense - it makes things more predictable. The question should perhaps be ""why are stack variables <strong>not</strong> initialized?""</p>

<p>The answer to this may be performance - initializing stack variables needs to be done whenever entering the function, which may waste time if the initialization isn't actually needed. Static variables are initialized when loading the program, so it doesn't cost much.</p>
",0
14827859,14827665,1,"<p>Because they are the only variable storage class that can be initialised without incurring a runtime performance penalty.</p>

<p>Automatic storage class variables (the default) are not initialised because they might not be used.  Static variables <em>inside</em> a function are not guarenteed to be initialised until the function is called the first time. </p>

<p>Zero is a sensible general default initialiser for several reasons: on a char array it produces an empty string, it starts an array index count, and produces a NULL pointer, etc.  </p>

<p>Personally I always explicitly initialise statics, even to zero.  This is partly documentary, in other words ""I really do want zero, don't change it"".  </p>
",0
14820767,14820680,1,"<p>Don't forget the <code>\0</code> character at the end of <code>s3</code>!</p>

<pre><code>char s3[s3len+1];
......

s3[s3len] = 0; // \0 character
</code></pre>
",1
14820809,14820680,3,"<p>A problem is, because <code>s3</code> is a local variable in <code>append</code>, the memory for <code>s3</code> is allocated in <code>append</code> and then freed when it goes out of scope (when the function ends), regardless of whether or not you return a pointer to it.</p>

<p>What you should do is pass <code>s3</code> as a <code>char *</code> or <code>char[]</code> as a parameter to the function.</p>

<p>Like this: (changing <code>append</code> should be easy enough)</p>

<pre><code>// yes the +1 to be able to null-terminate the string is needed,
//   or just make it much bigger
char s3[strlen(str1) + strlen(str2) + 1];
append(str1, str2, s3);
printf(""The output is %s\n"", s3);
</code></pre>

<p>Also remember to add a <code>0</code> as the last character of <code>s3</code> in <code>append</code> as ogzd suggested (null-terminate the string).</p>

<p>Alternatives:</p>

<ul>
<li><p>(C++) Return <code>std::string</code> (a bit slower because the memory is copied)</p></li>
<li><p>Do a <code>malloc</code> (C/C++) or <code>new</code> (C++) in <code>append</code> to allocate the memory for <code>s3</code>. This is a dangerous practice since the memory must be <code>free</code>'d or <code>delete</code>'d respectively.</p></li>
</ul>

<p>With <code>malloc</code>, literally the only thing you'll need to change is the definition of <code>s3</code> in your function, to:</p>

<pre><code>char *s3 = malloc(s3len+1);
</code></pre>

<p>Normally you'd say:</p>

<pre><code>type *s3 = malloc(sizeof(type)*len);
</code></pre>

<p>But <code>char</code> is 1 byte, so <code>sizeof(char) = 1</code>.</p>
",5
14820985,14820680,1,"<p>instead of return the local variable s3</p>

<p>return an allocated copy of it :</p>

<pre><code>return strdup(s3);
</code></pre>

<p>just make sure you free the memory returned once you are done with it.</p>

<p>also make sure you 0 terminate your strings, this is essential in C since that is the only thing that distinguishes a string from an array. functions that take a string argument assume an ending 0 is in the character sequence.</p>
",3
14742864,14741782,3,"<blockquote>
  <p>generic c/c++ implementations for commonly used data structures in any serious piece of software""</p>
</blockquote>

<p>Here, <em>generic</em> and <em>c/c++</em> are just distinct adjectives listed in front of <em>implementations of data structures</em>; could equivalently have said ""c/c++ generic implementations..."" or ""generic implementation in c/c++"" etc..  Data structures such as lists and binary trees are commonly used for arbitrary data types like <code>int</code>, <code>double</code> and user-defined structures.  Implementations that allow the data structure code to be reused for arbitrary types are called ""generic"" implementations.</p>

<p>In C, examples are the standard library's binary search and quick sort functions, which accept data without understanding the content of the memory, as well as pointers to functions to call to perform meaningful interpretation of the data.  See <a href=""http://www.cplusplus.com/reference/cstdlib/qsort/"" rel=""nofollow"">http://www.cplusplus.com/reference/cstdlib/qsort/</a> and <a href=""http://www.cplusplus.com/reference/cstdlib/bsearch/"" rel=""nofollow"">http://www.cplusplus.com/reference/cstdlib/bsearch/</a></p>

<p>In C++, templates provide better support for generic data structures, with the Standard Library hosting generic vectors, lists, (binary tree associative) maps, double-ended queues, stacks, more recently hash tables termed unordered_maps etc..</p>
",0
14833790,14833741,2,"<p><code>strcVar</code> is a (local) array name, you can't assign a pointer to it. You probably wanted:</p>

<pre><code> strc* strcVar;
 ... /* and  later */
 strcVar[0].info = 1;
</code></pre>

<p>Maybe you wanted an array of pointers to <code>struct strc</code>, then the answer by Vaughn Cato will help.</p>
",0
14833791,14833741,2,"<p>This line is wrong and unnecessary:</p>

<pre><code>strcVar = malloc(sizeof(strc) * 5);
</code></pre>

<p>instead you might use:</p>

<pre><code>{
  int i=0;
  for (;i!=5; ++i) {
    strcVar[i] = malloc(sizeof(strc));
  }
}
</code></pre>
",0
14833802,14833741,2,"<p>You cannot assign an array from <code>malloc</code> - it's one or the other. If you declared an array of five pointers, the memory for them is allocated already. If you must use <code>malloc</code>, use a pointer to pointer instead of an array. Otherwise, allocate the individual items with <code>malloc</code>, not the array:</p>

<pre><code>strc* strcVar[5];
strcVar[0] = malloc(sizeof(strc));
</code></pre>
",1
14833855,14833741,1,"<p><strong>fix code:</strong></p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
void main()
{
    typedef struct
    {
        int info;
        struct strc* next_ptr;
    }strc;
    strc* strcVar;
    strcVar = malloc(sizeof(strc) * 5);
    strcVar[0].info = 1;
    printf("" All is well "");
}
</code></pre>
",0
14833865,14833741,2,"<p>Change</p>

<pre><code> strc* strcVar[5];
</code></pre>

<p>to</p>

<pre><code> strc* strcVar;
 strcVar = malloc(sizeof(strc) * 5);
 strcVar[0].info = 1;
</code></pre>

<p><strong>OR</strong></p>

<p>Change</p>

<pre><code>strc* strcVar[5];
strcVar = malloc(sizeof(strc) * 5);
strcVar[0]-&gt;info = 1;
</code></pre>

<p>to</p>

<pre><code>strc strcVar[5];
strcVar[0].info = 1;
</code></pre>
",2
14836112,14833741,0,"<p>In any array the base address is a const pointer. You cannot change it. </p>

<p>Suppose if you have int a[5];</p>

<p>Here a is the base pointer to the whole array and you are not allowed to change it. </p>

<p>This applies to all the arrays. </p>
",0
13758531,13758423,1,"<p>At least given the normal lengths of lines, if I were doing this I'd <em>probably</em> do it recursively. In pseudo code it would be something like:</p>

<pre><code>function reverse_words:
  read a word
  if end of line return
  call reverse_words
  print word that was read
  return
end function
</code></pre>

<p>Alternatively, read an entire line, then use roughly the procedure above to process it.</p>

<p>With a little care and judicious use of the standard library, this is only barely more complex than the pseudo-code.</p>
",0
13758721,13758423,0,"<p>So, it looks like what you have will indeed reverse words. There are alternate ways of doing this, but this probably works just as well. Based on what you are asking I assume that you ultimately want to reverse the words contained in files whose names are passed in on the command line. If this is correct, I would take the logic in your main function out and put it in a separate function called something like reversewords(), and pass your pointer to it. I would then loop through your arguments and handle each, calling your reversewords function as necessary. I see in your question that you also want to reverse lines of input that the user might type. For that I would add extra code after all the command line parsing is done. This would consist of a loop that repeatedly calls gets() and passes that resulting pointer to your reversewords function. I hope that helps.</p>
",0
13759371,13758423,0,"<p>To read input from user, change <code>char buf[] = ""the world will go on forever"";</code> to:</p>

<pre><code>char buf[123];
printf(""Please enter a bunch of words: "");
fgets(buf, sizeof buf, stdin);
</code></pre>

<p>Then code to remove traling newline, which fgets doesn't strip, if any, in case you want only spaces:</p>

<pre><code>int endInd = strlen(buf)-1;
if (buf[endInd] == '\n') buf[endInd] = 0;
/* else user typed longer line than sizeof buf, extra chars are left unread */
</code></pre>

<p>For reference, first google hit for ""man fgets"": <a href=""http://www.manpagez.com/man/3/fgets/"" rel=""nofollow"">http://www.manpagez.com/man/3/fgets/</a></p>

<p>Note about that, since it is also man page of <code>gets</code>. <em>Never</em> use <code>gets</code>, there is no way to prevent user from giving you buffer overflow.</p>

<p>Alternate answer: or did you mean, read command line args and print them in reverse order? Try this:</p>

<pre><code>for (int ind = argc-1; ind &gt;=1; --ind) {
    // use conditional operator to print space after all args except the one printed last
    printf(""%s%s"", argv[ind], (ind == 1 ? """" : "" "") );
}
</code></pre>
",0
14855655,14855476,5,"<p>Here's a more concise and bugfree (I believe) implementation, that doesn't even invoke undefined behavior:</p>

<pre><code>unsigned mul(unsigned a, unsigned b)
{
    unsigned acc = 0;
    while (b) {
        if (b &amp; 1) acc += a;
        b &gt;&gt;= 1;
        a &lt;&lt;= 1;
    }
    return acc;
}
</code></pre>

<p>Your code had several flaws:</p>

<ol>
<li>readability, length, etc...</li>
<li><code>if ((num &amp; times) == 0) return 0;</code> -> this would return 0 for numbers of which don't share at least one common power of two in their binary representation, i. e. <code>4 * 8 = 0</code>.</li>
<li>Shifting in the sign bit is undefined behavior in C - you need to use unsigned integers for this task.</li>
</ol>
",4
14856032,14855476,0,"<p>If you want a signed integer variant, this would work:</p>

<pre><code>int mul(int a, int b)
{
    sign = (a ^ b) &gt;&gt; (sizeof(a) * CHAR_BIT - 1);
    if (a &gt; 0)
        a = -a;
    if (b &gt; 0)
        b = -b;
    int acc = 0;
    while (b) {
        if (b &amp; 1) acc += a;
        b &gt;&gt;= 1;
        a &lt;&lt;= 1;
    }
    if (sign) acc = -acc;
    return acc;
}
</code></pre>

<p>[Credit to H2CO3's implementation in another post for most of the algorithm]</p>
",6
14829511,14813008,2,"<p>Such questions always deserve counter questions to clarify requirements, if only to demonstrate your thinking and analytical skills and even creativity - that is what the interview should be about.  </p>

<p>For example in the absence of any specification that the ""number"" in question is necessarily an integer, you might propose the following:</p>

<pre><code>int nextPow2( double x )
{
    return (int)pow( 2, ceil(log10(x) / log10(2))) ;
}
</code></pre>

<p>But if you did you might also express concern about the applicability of such a solution to an embedded system with possibly no floating-point unit.</p>
",0
14832657,14832632,4,"<p>You'll get a lot more here: <a href=""http://graphics.stanford.edu/~seander/bithacks.html"" rel=""nofollow"">Bit Twiddling Hacks</a></p>
",0
14832664,14832632,3,"<p>Treat one of the inputs as a bitmask. For each bit in it that is set, you want to add the other input, shifted that many spaces left, to your result. This assumes unsigned inputs: non-2's-complement signed inputs require special treatment of the sign bit.</p>

<p>I think I can safely predict that this will be less efficient than the CPU's built-in multiply operation.</p>
",0
14850923,14850889,8,"<p>You are using the <a href=""http://en.wikipedia.org/wiki/Comma_operator"" rel=""nofollow"">comma operator</a>:</p>

<blockquote>
  <p>In the C and C++ programming languages, the comma operator (represented by the token ,) is a binary operator that evaluates its first operand and discards the result, and then evaluates the second operand and returns this value (and type).</p>
</blockquote>

<p>Note that this is not the same as the comma that separates function arguments.</p>

<pre><code>a = 1, 2, 3;
     ^  ^
     |  |
  comma operators

a = foo(1, 2, 3);
         ^  ^
         |  |
      separators
</code></pre>

<p>For your code this means that all that happens is that the expressions <code>4</code>, <code>5</code> and <code>90</code> are evaluated one by one, and the result of this is the result of the last expression, i.e. <code>90</code>.</p>

<p>The parentheses are just parentheses, they don't affect the result in any way.</p>

<pre><code>const int j = (4, 5, 90);
</code></pre>

<p>Is the same as:</p>

<pre><code>const int j = 4, 5, 90;
</code></pre>

<p>Or, for that matter:</p>

<pre><code>const int j = (4), (5), (90);
</code></pre>

<p>As is noted on the Wikipedia page I linked to, and should be obvious from the above, the comma operator is very rarely useful. It can be tricked into service for various obscure purposes (see <a href=""http://mindtribe.com/2011/07/forgotten-c-the-comma-operator/"" rel=""nofollow"">this page for examples</a>) but doing obscure things is rarely a win.</p>
",7
15581713,15581663,0,"<p><code>name</code> and <code>grade</code> are arrays - the address of the variable is implicit for an array. So the address operator should not be used for these variables.</p>

<pre><code>fscanf(ifp, ""%s"", name);
fscanf(ifp, ""%f"", grade);
</code></pre>
",0
15581731,15581663,1,"<p>This is your main problem:</p>

<pre><code>    printf( ""%f\n"", grade);
</code></pre>

<p>You're trying to print a pointer as a float. You want <code>grade[0]</code>.</p>

<p>In this line:</p>

<pre><code>    fscanf(ifp, ""%f"", &amp;grade);
</code></pre>

<p>This will work, but it's not correct. It should be <code>&amp;grade[0]</code> or just plain <code>grade</code>.</p>

<p>Of course in your final version, you'll need to adjust the array subscripts. You'll also need to allocate more arrays for the name - you currently can only store one.</p>

<p>To read in the data you will need to change the program a lot. You could declare <code>grade</code> as <code>grade[10][8]</code> (assuming a maximum of 10 participants), and store each of the 8 integers in the array. A loop like this would process it:</p>

<pre><code>   for (i = 0; i &lt; participants; i++) {
      fscanf(ifp, ""%s"", name);             // read the name (you need to fix this)
      for (j = 0; j &lt; 8; j++) {
        fscanf(ifp, ""%d"", &amp;grade[i][j]);   // store each number
      }
   }
</code></pre>
",7
13446888,13446797,2,"<p>You forgot a <code>;</code> in the <code>a</code> struct.</p>

<p>When declaring a variable of type <code>a</code> inside the <code>b</code> structure, you're doing it wrong. It should be:</p>

<pre><code>struct b {
    struct a b1;
    int b2;
};
</code></pre>

<p>I'll just declare it as a struct type, and not a pointer to a struct, so you don't have to allocate memory.</p>

<p>And if you're really trying to compile this code, you surely need an entry point:</p>

<pre><code>int main(void)
{
    struct b data;
    printf(""The value of a1 is %d\n"", data.b1.a1);
    return 0;
}
</code></pre>

<p>And as you can see, I declared a <code>b</code> struct inside <code>main</code>, named <code>data</code>. Now you can just access its members, and the members of its members, just by using <code>.</code>. And if it was a pointer (and it is correctly allocated), then you can use <code>-&gt;</code> instead of <code>.</code>.</p>

<p>Another thing I noticed is that you misspelled <code>%d</code> in the <a href=""http://www.cplusplus.com/reference/clibrary/cstdio/printf/"" rel=""nofollow""><code>printf</code></a> call.</p>

<p>And you also need to include the standard I/O header to use <code>printf</code>:</p>

<pre><code>#include &lt;stdio.h&gt;
</code></pre>

<p>I really hope this code is just a poorly and fast written piece of code, because it is in no way compilable without a <em>major</em> modification.</p>
",0
13468113,13468068,6,"<p>Pack the biggest items at the start of the structure.  Pack smaller items towards the end.</p>

<pre><code>struct optimal_packing
{
     double d;
     int    i[4];
     short  j[3];
     char   s[24];
};
</code></pre>

<p>To be slightly more accurate, it is the items with the most stringent alignment requirements that need to come earliest (which tend to be pointers and <code>double</code> or perhaps <code>long double</code>), and those with less stringent alignment requirements at the end (<code>short</code> and <code>char</code>).  You can still end up with tail padding if the total length of the components adds up to, say 35 bytes, but one of the types requires an 8-byte alignment; there'd be 5 bytes of padding.</p>
",10
13468473,13468068,2,"<p>The only completely portable and reliable way to avoid structure padding is not to use real members in your <code>struct</code> at all. Use a single <code>char</code> array member, and define macros that access its contents:</p>

<pre><code>struct paddingless {
    // char *p;
    // double d;
    // char c;

#define OFFSET_P 0
#define OFFSET_D (OFFSET_P + sizeof(char *))
#define OFFSET_C (OFFSET_D + sizeof(double))    
#define OFFSET_END (OFFSET_C + sizeof(char))    

    char data[OFFSET_END];
};
</code></pre>

<p>Portable getters and setters would look like this:</p>

<pre><code>inline double paddingless_get_d(const struct paddingless *o) {
    double val;
    memcpy(&amp;val, o-&gt;data + OFFSET_D, sizeof(val));
    return val;
}
inline void paddingless_set_d(struct paddingless *o, double val) {
    memcpy(o-&gt;data + OFFSET_D, &amp;val, sizeof(val));
}
</code></pre>

<p>If you know that your architecture accepts unaligned access, you can get away with a setter being defined with a cast:</p>

<pre><code>#define paddingless_get_d(o) (*(double *) ((o)-&gt;data + OFFSET_D))
#define paddingless_set_d(o, val) (*(double *) ((o)-&gt;data + OFFSET_D) = (val))
</code></pre>

<p>This is non-portable, but potentially faster than the alternative. And it works on a <strike>vax</strike> x86...</p>
",2
13468522,13468068,0,"<p>There are some things to consider. First of all, the compiler adds padding for a reason: it tries to make the optimal, working machine code for its designated platform. So normally padding is a good thing. Except for the cases where you want to define data communications protocols, hardware register mappings and similar, where the number of bytes simply must match a certain specification.</p>

<p>There is really no standard way to avoid padding. The best you can achieve is a compile time assert giving an error if the struct size doesn't match the sum of all its individual members. When the assert fails, you go and change the compiler settings to block padding. Preferably: </p>

<p><code>static_assert(sizeof(mystruct) == (sizeof(mystruct.x) + sizeof(mystruct.y) +...));</code></p>

<p>If static_assert isn't available in your C compiler (you'd need a C11 compliant one), then use some ""ct_assert"" macro, you can find plenty on this site.</p>

<p>However, this doesn't solve the problem in a portable manner, you would be dependent on compiler settings. The only truly portable way to solve the problem is something like this:</p>

<pre><code>void mystruct_copy_from (uint8_t* raw_data, const mystruct_t* ms)
{
  memcpy(raw_data, &amp;ms-&gt;x, sizeof(ms-&gt;x));
  raw_data += sizeof(ms-&gt;x);

  memcpy(raw_data, &amp;ms-&gt;y, sizeof(ms-&gt;y));
  raw_data += sizeof(ms-&gt;y);

  // ... and so on
}


uint8_t protocol [EXPECTED_STRUCT_SIZE];
mystruct_copy_from (protocol, &amp;mystruct);

send(protocol); // some data communication interface without padding
</code></pre>
",0
15516947,15516843,0,"<pre><code>void AddEnd(List * item, List * head)
{
     List * node;
     node = (List *)malloc(sizeof(List));
     printf(""Enter x and y: "");
     scanf(""%d %d"", &amp;node-&gt;x, &amp;node-&gt;y);
   if(head == NULL)
   {
      head=node;
      head-&gt;next=NULL;
     // head-&gt;x=item-&gt;x;
     // head-&gt;y=item-&gt;y; you don'tneed this as you have it in node.
   } 
  else
  {
     node-&gt;next = head-&gt;next;
     head-&gt;next = node;
    // node-&gt;x=item-&gt;x;
    // node-&gt;y=item-&gt;y;
  }
}
</code></pre>
",4
15517756,15516843,2,"<p>The code you have written is a complete mess. I'am not sure why you need to use the variable<code>item</code> there. Find the modified code below and try executing it. In the main function you are declaring a pointer to the head of the list, setting it to <code>NULL</code> and then you are sending the<code>NULL</code> value to the <code>AddEnd</code> function as a parameter. That will not work. you need to send the <code>&amp;head</code> to the function as a parameter so that the changes are reflected back to the calling function.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct Data
{
    int x;
    int y;
    struct Data * next;   
}List;

void AddEnd(List * item, List ** head);
void Show(List * head);

int main(void)
{
    int choice;
    List item;
    List * head;
    List * temp;
    head = NULL;
    while(printf(""q - quit - Enter 1 add end, 2 show: ""), scanf(""%d"", &amp;choice))
    {
        switch(choice)
        {
            case 1:
                AddEnd(&amp;item, &amp;head);
                break;
            case 2:
              //  printf(""X = %d y= %d\n"", item.x, item.y);               /*prints 1 2*/
              //  printf(""x = %d y = %d\n"", head-&gt;x, head-&gt;y);            /*crash of program...should print 1 2*/
                Show(head);
                break;
            default:
                printf(""TRY AGAIN\n"");
                break;           
        }
    }
    temp = head;
    while(temp)
    {
        free(temp);
        temp = head-&gt;next;
        head = temp-&gt;next;
    }
    return 0;
}

void AddEnd(List * item, List ** head)
{
    List * node,*first,*second;
    node = (List *)malloc(sizeof(List));
    printf(""Enter x and y: "");
    scanf(""%d %d"", &amp;node-&gt;x, &amp;node-&gt;y);
    if(*head == NULL)
    {
        node-&gt;next = NULL;
        *head = node;
       // * item = **head;

    }
    else
    {
        for(first=*head;first!=NULL;first=first-&gt;next)//traverse to the end of the list
            second=first;
        node-&gt;next = NULL;
        second-&gt;next=node;
    }
}

void Show(List * head)
{
    List * node;
    node = head;
    while(node)
    {
        printf(""x = %d y = %d\n"", node-&gt;x, node-&gt;y);
        node = node-&gt;next;
    }
}
</code></pre>
",1
15517896,15516843,1,"<p>the problem is this</p>

<p><code>AddEnd(List * item,List* head)</code></p>

<p>here when you call AddEnd like so</p>

<p><code>head = null;</code>
<code>addEnd(&amp;item,head);</code></p>

<p>the malloc'd address is copied to the local variable <code>head</code> in AddEnd and not the local variable <code>head</code> of <code>main()</code>. head in main() is unchanged. </p>

<p>solution:</p>

<p>change AddEnd as so
<code>AddEnd(List * item,List ** head)</code> and change the code also similarily in AddEnd.</p>

<p>call <code>AddEnd(&amp;item,&amp;head);</code></p>
",1
13486450,13486389,3,"<pre><code>char word[SIZE];
...
fwrite(&amp;a,1,sizeof(word),anagramsFile);
</code></pre>

<p><code>sizeof(word)</code> returns the full size of the buffer, so you're writing the full length of the buffer each time. You'll want to use <code>strlen()</code> or similar to only write the part of the buffer you're actually using.</p>
",0
15851569,15686928,1,"<p>Build a state machine like this:</p>

<p>C#
    bool OnceMore = true;</p>

<pre><code>string ProcessState = ""Start""
while(OnceMore)
{
   OnceMore = False;
   switch(ProcessState)
   {
      case ""Start"" :
      {
     // do something
     ProcessState = ""Check"";
         OnceMore = True;
     break;
      }
      case ""Check"" :
      {
         // do check
         if( Check == ""Ok"")
         {
            ProcessState = ""Close"";
         }
         else // try again
         {
            ProcessState = ""Start"";
         }
         OnceMore = True;
         break;
      }
      case ""Close"" :
      {
         // do what you need to return to the caller
         break;
      }
   }
}
return
</code></pre>
",0
18939156,18938961,0,"<p>add strdup and strtok can work on a copy of the string.  The split() call is more generic than the other spliter() examples, but does the same thing with strtok on a duplicate.</p>

<pre><code>char **
split(char **result, char *w, const char *src, const char *delim)
{
    int i=0;
    char *p;
    strcpy(w,src);
    for(p=strtok(w, delim) ; p!=NULL; p=strtok('\0', delim) )
    {
        result[i++]=p;
        result[i]=NULL;
    }
    return result;
}

void display(String *p)
{
   char *result[24]={NULL};
   char *w=strdup(p-&gt;c);
   char **s=split(result, w, p-&gt;, ""\t \n"");  split on \n \t and space as delimiters
   for( ; *s!=NULL; s++)
      printf(""%s\n"", *s);
   free(w);
}
</code></pre>
",0
18939031,18938961,0,"<p>You're looking for <code>strtok</code>, check out <code>man 3 strtok</code>, or <a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/strtok.html"" rel=""nofollow"">here</a> if you're not on *nix.</p>

<p>You would use it like this: (Assuming that you can write the <code>add_string</code> code yourself.)</p>

<pre><code>String ** spliter(String *s)
{
   if(s == NULL)
     return NULL;

    String **return_strings = NULL;
    char *delim = "" \n"";
    char *string = strtok(s, delim);
    int i = 0;


    for(i = 0; add_string(return_strings, string, i) != -1; i++) {
        string = strtok(NULL, delim);
    }

    return strings;
}
</code></pre>

<p>Note that if you need to save the original string (<code>strtok</code> modifies the string it works on), you'll need to call <code>strdup</code> on the original string, then operate on the copy.</p>

<p>EDIT: OP said he was having trouble thinking about the pointers. With the above code sample, <code>add_string</code> only has to worry about dealing with a string of characters, as opposed to an array of pointers to pointers to characters. So it might look something like this:</p>

<pre><code>int add_string(String **strings, char *s, int len)
{
    if(s == NULL)
        return -1;

    String *current_string = NULL;
    strings = realloc(strings, sizeof(String) * (len + 1));
    current_string = strings[len];

    /* fill out struct fields here */
}
</code></pre>
",0
18939033,18938961,0,"<pre><code>#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;


int main()
{
    string test = ""aa aa bbc cccd"";
    vector&lt;string&gt; strvec;
    string strtemp;

    string::size_type pos1, pos2;
    pos2 = test.find(' ');
    pos1 = 0;        
    while (string::npos != pos2)
    {
            strvec.push_back(test.substr(pos1, pos2 - pos1));

            pos1 = pos2 + 1;
            pos2 = test.find(' ', pos1);
    }
    strvec.push_back(test.substr(pos1));

    vector&lt;string&gt;::iterator iter1 = strvec.begin(), iter2 = strvec.end();
    while (iter1 != iter2)
    {
            cout &lt;&lt; *iter1 &lt;&lt; endl;
            ++iter1;
    } 

    return 0;

}
</code></pre>
",0
18939056,18938961,0,"<p>here is a exemple :</p>

<pre><code>String ** spliter(String *s)                                                                                                                                                                                        
{
  int  i;
  int j;
  char *p1;
  char *p2;
  char *p3;

  i = 0;
  j = 0;
  if(s == NULL)
    return NULL;
  p1 = malloc(sizeof(*p1) * strlen(s));
  p2 = malloc(sizeof(*p2) * strlen(s));
  p3 = malloc(sizeof(*p3) * strlen(s));
  while (s[i] != ' ')
    {
      p1[j++] = s[i];
      i++;
    }
  i++;
  j = 0;
  while (s[i] != ' ')
    {
      p2[j++] = s[i];
      i++;
    }
  i++;
  j = 0;
  while (s[i] != '\0')
    {
      p3[j++] = s[i];
      i++;
    }
  printf(""%s\n"", p1);
  printf(""%s\n"", p2);
  printf(""%s\n"", p3);
}
</code></pre>
",0
18939064,18938961,0,"<p>Have you looked at strtok? It should be possible to do this using strtok.</p>
",0
15586732,15586682,0,"<p>This is a system problem not C. In general, your hosting system provide buffering to inputs, so when you press a key, it is not delivered at that time to your program, it is buffered until some condition occurs (basically, an end-of-line is pressed).</p>

<p>Under Windows there is different calls you should make to get a keypress.</p>

<p>Under Unix, you should put your tty in non-canonical mode (there is a set of magic calls to <code>tcgetattr</code> and <code>tcsetattr</code>).</p>

<p>See that <a href=""https://stackoverflow.com/questions/9222231/how-can-i-read-the-terminal-input-on-a-tty-device-before-a-newline-arrives/9222520#9222520"">one for example</a></p>
",0
15586740,15586682,2,"<p>Since you use <code>system(""cls"");</code>, this is probably on dos / Windows command prompt. You can try to see if <a href=""http://en.wikipedia.org/wiki/Conio.h"" rel=""nofollow"">conio.h</a> is supported by your compiler.</p>

<p>If it is, <a href=""http://msdn.microsoft.com/en-us/library/58w7c94c%28v=vs.71%29.aspx"" rel=""nofollow""><code>kbhit()</code> or <code>_kbhit()</code></a> (link to MSDN, you should check docs of your compiler's libraries for most accurate reference) seems to be what you need to use.</p>
",0
15586750,15586682,3,"<p>This should help <a href=""http://msdn.microsoft.com/en-us/library/58w7c94c%28v=vs.80%29.aspx"" rel=""nofollow""><code>_kbhit</code></a> and it's important to use <code>_getch()</code> after it.</p>

<pre><code>#include &lt;conio.h&gt;

//...

int key;
while (1)
{
    if (_kbhit())
    {
        key = _getch();

        if (key == 'a')
            printf(""You pressed 'a'\n"");
        else if (key == 'd')
            printf(""You pressed 'd'\n"");
    }
}
</code></pre>
",1
18945130,18945064,2,"<p>Measuring performance can be tricky on modern processors because for example many of them have a variable clock speed.</p>

<p>This means that they're normally going slow because no CPU is needed and they can use less energy and generate less heat that way.</p>

<p>When you require an heavy computation the OS detects that now there is work for the CPU and can increase the clock speed (and heat and current) to get the results faster.</p>

<p>To avoid this specific problem you should measure clock cycles used by your computation instead of cpu time (or worse wall clock time). A good profiler should give you this option (I'm using <a href=""http://oprofile.sourceforge.net/"" rel=""nofollow"">oprofile</a>).</p>
",0
15570777,15570622,8,"<p>The character for the minus sign on line 13 isn't a minus sign at all, but a hyphen (I think that's what it's called).</p>

<pre><code> sp = sieve + (number ¨C 3)/2;
</code></pre>

<p>should be</p>

<pre><code> sp = sieve + (number - 3)/2;
</code></pre>

<p>When I changed that character the code compiles.</p>
",4
13790280,13789831,1,"<p>You can put the ""constant"" data in an array, including pointers.</p>

<pre><code>thenode thenodes[] =
/* 0 */ {{ NULL, ""Does it have a tail?"", thenodes+1,thenodes+2}
/* 1 */ ,{ ""a pangolin"", NULL,NULL,NULL}
/* 2 */ ,{ NULL, ""Is it flat, round and edible?"", thenodes+3 , thenodes+4 }
/* 3 */ ,{""a pizza"",NULL, NULL, NULL}
/* 4 */ ,{ ""pete"", NULL,NULL,NULL}
        };

void nodePrint(struct node *ptr){

if (!ptr) return;
    printf(""{"" );
if (ptr-&gt;objectname == NULL) {
    printf(""Object : [NOTHING]"" );
    printf(""Question : %s"", ptr-&gt;question);
    printf(""Yes : "" ); nodePrint(ptr-&gt;yes_ptr);
    printf(""No : ""); nodePrint(ptr-&gt;no_ptr);

    }else {
    printf(""Object : %s"", ptr-&gt;objectname);
    printf(""Question : [NOTHING]"");
    }
    printf(""}"" );
}

int main(int argc, char **argv){
struct node *ptr = thenodes;

nodePrint(ptr);

return 0;
}
</code></pre>
",0
13789948,13789831,1,"<p>You might consider implementing your tree as an array! This scheme will take up more memory (array size of <code>2^n</code> rather than a set of pointers of size <code>n</code>), however, I suspect coding the tree itself will become simpler. You could refactor it into an actual ""tree"" structure later.</p>

<p>You can find plenty of places on the internet describing how to do this. But say you have a tree like this:</p>

<pre><code>    A
   / \
  B   C
 / \
D   E
</code></pre>

<p>Your array representing the tree would look like this:</p>

<p>tree = [A, B, C, D, E]</p>

<p>For each node in position <code>n</code> of the array, the left child would be located in position <code>(2n + 1)</code> and the right child would be in <code>(2n + 2)</code>.</p>

<p>So, given your tree - that you have presumably already created, perhaps by hand - you would know exactly where in the array to place each node (<code>tree[n] = struct node</code>) and you would easily be able to traverse it. You could even have a file where each line is a ""node"" of the tree, and the line number is the same as the array position.</p>

<p>Best of luck!</p>
",0
13790014,13789831,1,"<p>I think I understand what you want to achieve, but:
this</p>

<pre><code>typedef struct node thenode;
</code></pre>

<p>defines user type, which means, you are not declaring a variable of type struct node, but you are declaring new type which IS struct node.</p>

<p>this</p>

<pre><code>thenode *objectname = NULL;
</code></pre>

<p>does not set inner variable objectname of thenode to NULL, this declares a new pointer to variable of type thenode which you previously defined.</p>

<p>this</p>

<pre><code>struct node *ptr = &amp;thenode;
</code></pre>

<p>declares a new pointer to node and assigns the address of !type! thenode to it. (I sincerely hope that this is not compilable).</p>

<p>I recomend looking at some tutorial describing dynamic memory allocation in C. It should look like this:</p>

<pre><code>typedef struct {
   ...
}
thenode;

int main () {
   thenode *node;
   ...
   if ((node = malloc(sizeof(thenode))) == NULL) fail_somehow();
   ...
   node-&gt;something = something;
   ...
   free(node);
   ...
}
</code></pre>
",0
14727619,14727585,2,"<p>You get a NULL from <code>fgets</code> when it reaches EOF. From the keyboard, that's suually signalled with CTRL-Z (DOS/Windows and I think MacOS before X) or CTRL-D (Linux/Unix/MacOS X). </p>
",2
19327853,19327790,2,"<p>Here are three ways to read an entire file into a contiguous buffer:</p>

<ol>
<li><p>Figure out the file length, then <code>fread()</code> the whole file.  You can figure out the length with <code>fseek()</code> and <code>ftell()</code>, or you can use <code>fstat()</code> on POSIX systems.  This will not work on sockets or pipes, it only works on regular files.</p></li>
<li><p>Read the file into a buffer which you dynamically expand as you read data using <code>fread()</code>.  Typical implementations start with a ""reasonable"" buffer size and double it each time space is exhausted.  This works on any kind of file.</p></li>
<li><p>On POSIX, use <code>fstat()</code> to get the file and then <code>mmap()</code> to put the entire file in your address space.  This only works on regular files.</p></li>
</ol>
",2
15559432,15559415,5,"<p>This going beyond the bounds of the array <code>Q</code>, causing undefined behaviour:</p>

<pre><code>Q[1][i] = InitHeight(g,dx,Cx[i]);
Q[2][i] = InitMom(g,dx,Cx[i]);
</code></pre>

<p>must be <code>Q[0]</code> and <code>Q[1]</code> as <code>Q</code> is defined as:</p>

<pre><code>double Q[2][101];
</code></pre>

<p>The other indexing in your code indicates you are aware that array indexes are zero-based and run from <code>0</code> to <code>N - 1</code> where <code>N</code> is the number of elements in the array.</p>
",0
15559434,15559415,6,"<p>You're indexing into <code>Q</code> incorrectly.  Array indices in C start at 0, not 1.  So you should have</p>

<pre><code>double g=1;
double dx=0.1;
for(int i=0; i&lt;101; i++){
  Q[0][i] = InitHeight(g,dx,Cx[i]); /* Used to be Q[1][i] */
  Q[1][i] = InitMom(g,dx,Cx[i]); /* Used to be Q[2][i] */
  y[i] = plainTopo(Cx[i]);
}
</code></pre>

<p>As for why <code>Cx</code> gets changed, accessing an out-of-bounds item in an array causes undefined behavior, which means that the C compiler can do anything it feels like.  Your particular compiler generates assignments into <code>Cx</code>.  Technically, this is because of the way arrays are laid out on the stack, but the compiler is <em>not</em> required to do the same thing that your compiler does, and can instead choose to cause your program to crash (this is the best case, because it helps you find the bug), write over top of other data (this is what you are seeing), or delete all your files (no compiler I know of actually does this).  Really, the compiler has <em>complete freedom</em> to cause as much havoc as it feels like whenever undefined behavior occurs, and one such situation is when you access an out-of-bounds array index.</p>
",1
15559452,15559415,1,"<pre><code>double g=1;
double dx=0.1;
for(int i=0; i&lt;101; i++){
  Q[1][i] = InitHeight(g,dx,Cx[i]);
  Q[2][i] = InitMom(g,dx,Cx[i]);
  y[i] = plainTopo(Cx[i]);
}
</code></pre>

<p>You do not have a Q[2][i] available, so it's probably overwriting into your Cx array</p>

<p>I think what you meant was</p>

<pre><code>Q[0][i] = InitHeight(g,dx,Cx[i]);
Q[1][i] = InitMom(g,dx,Cx[i]);
</code></pre>
",0
15559453,15559415,1,"<pre><code>double Q[2][101];
:
Q[2][i] = InitMom(g,dx,Cx[i]);
</code></pre>

<p>Your corruption is happening because the legal indexes for Q do <em>not</em> include <code>Q[2][...]</code>.</p>

<p>You seem to know this since you iterate <code>i</code> from 0 to 100 inclusive, for the <code>Cx[101]</code> array so it appears to be just a temporary mistake - it's the same rule for <em>all</em> dimensions of an array.</p>
",0
14857313,14857201,0,"<p>First of all your <code>counter</code> variable is unguarded - u have a possible race condition when doing <code>counter++</code>. Use a mutex;</p>

<p>As for doing N threads - using an array of threads/semaphores is IMO acceptable, I have code which utilizes that design and it works well.</p>
",0
14857637,14857201,0,"<p>1.No it is not correct. Doing increments like <code>counter++;</code> will cause race condition and it won't increment the counter properly. You'd want to surround it with a critical section.</p>

<p>2.</p>

<pre><code>static pthread_mutex_t cs_mutex = PTHREAD_MUTEX_INITIALIZER;
static sem_t t_sem;

void *thread(void *vargp)
{
    static int counter=0;
    pthread_mutex_lock( &amp;cs_mutex );
    counter++;
    pthread_mutex_unlock( &amp;cs_mutex );

    if( counter == NO_THREADS )
        sem_post( &amp;t_sem );

    sem_wait( &amp;t_sem );
    sem_post( &amp;t_sem );
}
int main( int argc, char *argv[] ){

    pthread_t tids[NO_THREADS];
    sem_init( &amp;t_sem, 0, 0 );

    for( i=0; i&lt;NO_THREADS; i++ ){
        pthread_create(&amp;tids[i], NULL, thread, NULL);
    }

    for( i=0; i&lt;NO_THREADS; i++ ){
        pthread_join(&amp;tids[i], NULL);
    }
    pause();
    return 0;
}
</code></pre>
",2
18796180,18795807,3,"<p>Hint: When running your code, you will reach a call like this from the second line of recursive call to sorthelper.</p>

<pre><code>sorthelper([0, 1, 5, 8, 7], 3, 4)
</code></pre>

<p>It doesn't do anything although it should sort the 8 and the 7. Think why and fix it ;)</p>
",0
18796183,18795807,2,"<p>In your sorthelper() function, you are skipping the case when the array has only two elements. Please make the following change:</p>

<pre><code>if (ind2 - ind1 &lt;= 1) 
</code></pre>

<p>to</p>

<pre><code>if (ind2 - ind1 &lt; 1)
</code></pre>

<p>Without this change, a test case consisting of even two element array would give you an error: (8,7)!</p>
",0
18796200,18795807,1,"<p>Two problems.</p>

<ol>
<li>You assume that if ind2 - ind1 == 1, the elements are already sorted. This is not true. This is why the [8, 7] partition doesn't end up sorted.</li>
<li>When partitioning, you're setting up the lower partition to go from the start of the range to the pivot element (w-1). It should go to the last element BEFORE the pivot (w-2).</li>
</ol>
",2
13760939,13760844,4,"<p>You could use the values of macros such as <code>UINT_MAX</code> to determine the size of the underlying type.</p>
",0
13760954,13760844,1,"<p>You can use <code>UINT_MAX</code> - it can give you a clue about the size of integer.</p>

<pre><code>#if (UINT_MAX &lt;= 65536)
    typedef long MyLong;
#else
    typedef short MyLong;
#endif
</code></pre>
",0
13760971,13760844,5,"<p>It's not the preprocessor's job to evaluate <code>sizeof</code>, that's done by the compiler which is a later stage in the process. Evaluating <code>sizeof</code> needs deep C knowledge that the preprocessor simply doesn't have.</p>

<p>You could (in theory) consider the preprocessor as a separate step, that does <em>text only</em> transforms, in effect converting ""foo.c"" to ""foo-preprocessed.c"". The latter file won't have any <code>#include</code> or <code>#if</code>s left, they're all evaluated and replaced by the preprocessor. The actual compiler never sees them.</p>

<p>You should consider using <code>&lt;stdint.h&gt;</code> and the known-precision types (<code>uint16_t</code> and friends).</p>
",4
13761876,13760844,0,"<p>New-enough GCC (I think 4.3) has predefined identifiers like <code>__SIZEOF_LONG__</code>, but it is simpler to just use the constants in <code>limits.h</code> as suggested by others.</p>
",0
13762751,13760844,0,"<p>Although I and the C preprocessor are sworn enemies, we sometimes need each other ;). So I would propose:</p>

<pre><code>#if SIZEOF_MYINT == 2
#   define MYLONG_T long
#elif SIZEOF_MYINT == 4
#   define MYLONG_T short
#endif

typedef MYLONG_T MyLong;
</code></pre>

<p>Somewhere else (in a global config header file) you have your architecture dependent</p>

<pre><code>#define SIZEOF_MYINT 2
</code></pre>
",0
15828178,15828071,3,"<p>Your I/O is scary, you probably should load all of the image into memory <em>before</em> starting the processing.</p>

<p>Most scaling algorithms will require 2D access for neighboring pixels; scaling one scanline at a time makes it impossible to filter properly and will give poor results.</p>

<p>Also, of course you must modify the bitmap file's header and emit a properly adjusted header after the scaling.</p>
",0
15492475,15492130,2,"<p>Your own program , modified to show how using  <code>[][]</code> , can help reduce confusion instead of using <code>*[]</code></p>

<pre><code>#include&lt;stdio.h&gt; 
#include&lt;string.h&gt;
int main()
{
unsigned char newPrompt[10]=""# "";
unsigned char au1CLIPromptStrings [5][30] =
{
 """",
 ""Login: "",
 ""Password: "",
  "" 0123456789012345678901234"",
  "" 0123456789012345678901234"",
};

printf(""a1 = %s and a2 = %s\n"",au1CLIPromptStrings[3],au1CLIPromptStrings[4]);

strcpy(au1CLIPromptStrings[3],""# \0"");
strcpy(au1CLIPromptStrings[4],""# \0"");

printf(""a1 = %s and a2 = %s\n"",au1CLIPromptStrings[3],au1CLIPromptStrings[4]);

strncpy(au1CLIPromptStrings[3],newPrompt,strlen(au1CLIPromptStrings[3])) ;
strncpy(au1CLIPromptStrings[4],newPrompt,strlen(au1CLIPromptStrings[4])) ;
}
</code></pre>
",0
20761524,20761495,2,"<p>You can't declare a function inside a function in C. This means that you can't declare  function(s) inside <code>main</code>. Compile your code with <code>-pedantic</code> flag and you will see this warning for sure;  </p>

<pre><code>[Warning] ISO C forbids nested functions [-Wpedantic]  
</code></pre>

<p>I compiled this code   </p>

<pre><code>#include &lt;stdio.h&gt;

void void print(int *);

int main()
{
    int a[2] = {1,3};

    void print(int *a)
    {
         printf(""%d"", *a);
    }
    print(a);
    return 0;
}  
</code></pre>

<p>and getting the warning  </p>

<pre><code> [Warning] ISO C forbids nested functions [-Wpedantic]  
</code></pre>
",3
20761554,20761495,4,"<p>Actually, if you declare a function inside a function, the inner function is just visible to the outer function and NOT in <code>global</code> scope. So, the variables declared by you and the inner function [to be appropriate, the code block] is having same scope. Hence, no issues accessing the variable.</p>

<p>Check this one</p>

<h1>code</h1>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int innerfunc();

int main()
{

        int outer = 5;
        int innerfunc()
        {
                printf(""outer is %d\n"", outer);
        }
        innerfunc();
        return 0;
}
</code></pre>

<h1>output</h1>

<pre><code>[sourav@infba01383 so_overflow]# ./a.out 
outer is 5
[sourav@infba01383 so_overflow]#
</code></pre>
",10
20761566,20761495,0,"<p>Nested function (annonymouse functions) are not a part of the c standard library, there is an extension which can be used.</p>

<p>You may declare global variables and use them throughout your programs also.</p>

<hr>

<p>Sourav is correct actually, you may declare the function but its scope is limited to main</p>
",0
20762526,20761495,1,"<p><strong>First of all, as most answers have mentioned, it is a gcc extension; not part of standard C.<br>
Below answer is strictly confined to gcc.</strong></p>

<p>gcc does treat them as any other function.  </p>

<p>e.g. Check below code:<br>
(I took liberty to extend your code as below:)</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef int operation(int num1, int num2); // for function pointer...

operation* getOperation(char oper)
{
    int a=10;
    int add(int x, int y){return x+y+a;}
    int sub(int x, int y){return x-y+a;}
    int nop(int x, int y){return a;}

    if(oper=='+')return add;
    if(oper=='-')return sub;
    return nop;
}

int main()
{
    operation *my_op;

    my_op=getOperation('+');
    printf(""%d\n"",my_op(5,3));

    my_op=getOperation('-');
    printf(""%d\n"",my_op(5,3));

    return 0;

}
</code></pre>

<p>If you compile it with <code>gcc -S</code> &amp; check the assembly code generated, it would show that</p>

<ol>
<li><p>The functions - <code>getOperation</code> &amp; <code>main</code> - are converted to assembly, without any name change. Thus these can be called from any function (in this or even from other file).</p>

<pre><code>e.g.
.globl  getOperation /*This line will be missing in case of static functions.*/
.type   getOperation, @function
</code></pre></li>
<li><p>The functions - <code>add</code>, <code>sub</code>, <code>nop</code> - are converted to assembly with some unique random suffix.</p>

<pre><code>e.g.
/*No .globl line is printed here.*/
.type   add.2685, @function
</code></pre></li>
</ol>

<p>Since the names are changed, you cannot call them from other functions. Only the 'parent function' (<code>getOperation</code> in this case) has the information of the function name. (Check for <code>c variable scope</code> for more details.)</p>

<p>However, you can use them in other functions, using function pointers, as shown in code above.</p>

<p>Regarding the local variables in <code>getOperation</code> (<code>a</code> for example): They are accessed from <code>add</code>/<code>sub</code>/<code>nop</code> using <code>rbp</code> register.<br>
HINT: Compile a small code having 'local functions' with <code>gcc -S</code>, to understand what's exactly going on.. :-)</p>
",0
13755666,13755571,0,"<p>There are multiple approaches that you can take.  If you were just starting out, you could just arithmetically calculate the number of bits in the field.  So, for instance:</p>

<pre><code>if (value %2 &gt;= 1)
{
    // you know that the value has a `1` as the lest significant digit. 
    // if that's one of the digits you're looking for, you can do something like count++ here
}
else
{
    // least significant digit is a '0'
}
</code></pre>

<p>and then</p>

<pre><code>if (value % 4 &gt;=2)
{
    // you know that the second least significant digit is `1`
    // etc.
}
</code></pre>

<p>If you do it that way, you'll probably want to work those into a loop of some sort.</p>

<p>Now, a better way to do it is using <strong>bitwise anding</strong>, like this:</p>

<pre><code>if (value &amp; 8 != 0)
    // here you know that the fourth least significant digit (the one representing 8) is 1.
    // do a Google search on bitwise anding to get more information.
</code></pre>
",1
13755737,13755571,2,"<p>There's an awful lot of reading between the lines going on here.  However, if <code>getField(7, 1, 0)</code> returns 3 and you need <code>getFieldSignExtended(15, 2, 0)</code> to return <code>-3</code> and <code>getFieldSignExtended(3, 2, 0)</code> to return <code>+3</code>, then this might be what you're after.</p>

<p>The concept is that you treat an n-bit field from bits hi:lo of the original value as a 2's complement number. If the first bit of the n bits is a 1, then you want the n-bit field treated as a negative number. If the first bit of the 3-bit field is a 0, then you want it treated as a positive number.</p>

<pre><code>#include &lt;assert.h&gt;
#include &lt;limits.h&gt;
#include &lt;stdio.h&gt;

extern int getFieldSignExtended(int value, int hi, int lo);

enum { INT_BITS = CHAR_BIT * sizeof(int) };

int getFieldSignExtended(int value, int hi, int lo)
{
    assert(lo &gt;= 0);
    assert(hi &gt; lo);
    assert(hi &lt; INT_BITS - 1);
    int bits = (value &gt;&gt; lo) &amp; ((1 &lt;&lt; (hi - lo + 1)) - 1);
    if (bits &amp; (1 &lt;&lt; (hi - lo)))
        return(bits | (~0U &lt;&lt; (hi - lo)));
    else
        return(bits);
}
</code></pre>

<p>The 3 assertions are straight-forward; the only controversial one is that the code refuses to deal with bit 31.  If you invoked it with hi = 31 and lo = 0, then the shift (hi - lo + 1) is too big and the behaviour is undefined.  You also run into the implementation-defined behaviour of right shifting a negative number.  It would be possible to fix these issues by taking an unsigned integer argument and not doing the <code>&amp;</code> operation if <code>hi - lo + 1 == INT_BITS</code>.  Fixing the issues is left as an exercise for the reader.</p>

<p>The assignment to <code>bits</code> shifts the value right, and masks it with the correct number of bits.  The <code>(1 &lt;&lt; (hi - lo + 1)) - 1</code> shifts 1 left by one more than than the number of bits in the field, then subtracts one to generate a string of binary 1's for each bit position in the field.  For example, for hi = 2, lo = 0, this shifts 1 left 3 places, yields binary 1000; subtracting 1 gives 0111, so the correct 3 bits are selected. So, <code>bits</code> contains the appropriate set of bits for the n-bit integer.</p>

<p>The <code>if</code> test checks whether the most significant bit of the n-bit integer is set. If the sign bit isn't set, we simply return the value <code>bits</code>.  If the sign bit is set, then we have a tricky calculation to perform ¡ª one that was (very) wrong in the first draft of this answer.  Suppose we have a field of 3 bits = 101. As a 3-bit 2's complement number, that represents -3.  We need to extend that to the left with all 1's to generate the full-size <code>-1</code>.  The value of <code>~0</code> is all bits 1; when that's shifted left by <code>hi - lo</code> bits, it leaves a series of zeros for the non-sign-bits of the value.  It would also work if you shifted left by <code>hi - lo + 1</code>, but there's extra computation needed for the <code>+ 1</code> that isn't necessary.</p>

<p>I used this test harness to satisfy myself that the code was working correctly.  The systematic test output is rigorous (on smallish numbers).  It ensures that the calculated value matches the expected value.  The 'exhaustive' test isn't really exhaustive; it only tests one value, and it is more for observing problems (such as that using hi = 31 and lo = 0 gives an erroneous answer of 0 on my machine) and patterns.</p>

<pre><code>static const struct
{
    int  value;
    int  hi;
    int  lo;
    int  wanted;
} tests[] =
{
    {   0x0F,  1,  0,   -1 },
    {   0x0F,  2,  0,   -1 },
    {   0x0F,  2,  1,   -1 },
    {   0x0F,  3,  1,   -1 },
    {   0x0F,  4,  2,   +3 },
    {   0x0F,  5,  0,  +15 },
    {   0x0F,  5,  1,   +7 },
    {   0x0F,  5,  2,   +3 },
    {   0x0F,  5,  3,   +1 },
    {   0x0F,  5,  4,    0 },
    {   0x03,  2,  0,   +3 },
    {   0xF3,  2,  0,   +3 },
    {   0xF3,  3,  0,   +3 },
    {   0xF3,  4,  0,  -13 },
    {   0xF3,  5,  0,  -13 },
    {   0xF3,  6,  0,  -13 },
    {   0xF3,  7,  0,  -13 },
    {   0xF3,  7,  1,   -7 },
    {   0xF3,  7,  2,   -4 },
    {   0xF3,  7,  3,   -2 },
    {   0xF3,  7,  4,   -1 },
    {   0xF3,  8,  0, 0xF3 },
};
enum { NUM_TESTS = sizeof(tests) / sizeof(tests[0]) };
static const char s_pass[] = ""== PASS =="";
static const char s_fail[] = ""!! FAIL !!"";

static void systematic_test(void)
{
    int fail = 0;
    for (int i = 0; i &lt; NUM_TESTS; i++)
    {
        char const *pf = s_fail;
        int actual = getFieldSignExtended(tests[i].value, tests[i].hi, tests[i].lo);
        if (actual == tests[i].wanted)
            pf = s_pass;
        else
            fail++;
        printf(""%s GFSX(%+4d = 0x%.4X, %d, %d) = %+4d = 0x%.8X (wanted %+4d = 0x%.8X)\n"",
               pf, tests[i].value, tests[i].value, tests[i].hi, tests[i].lo, actual, actual,
               tests[i].wanted, tests[i].wanted);
    }
    printf(""%s\n"", (fail == 0) ? s_pass : s_fail);
}

static void exhaustive_test(void)
{
    int value = 0x5FA03CE7;
    for (int i = 1; i &lt; INT_BITS - 1; i++)
    {
        for (int j = 0; j &lt; i; j++)
        {
            int actual = getFieldSignExtended(value, i, j);
            printf(""%11sGFSX(%d = 0x%X, %2d, %2d) = %+10d = 0x%.8X\n"", """",
                    value, value, i, j, actual, actual);
        }
    }
}

int main(void)
{
    int result1 = getFieldSignExtended(15, 2, 0);
    int result2 = getFieldSignExtended( 3, 2, 0);
    printf(""GFSX(15, 2, 0) = %+d = 0x%.8X\n"", result1, result1);
    printf(""GFSX( 3, 2, 0) = %+d = 0x%.8X\n"", result2, result2);

    printf(""\nSystematic test\n"");
    systematic_test();

    printf(""\nExhaustive test\n"");
    exhaustive_test();

    return(0);
}
</code></pre>

<p>This is the output of the test code before the exhaustive test, plus a small selection of the output from the exhaustive test:</p>

<pre><code>GFSX(15, 2, 0) = -1 = 0xFFFFFFFF
GFSX( 3, 2, 0) = +3 = 0x00000003

Systematic test
== PASS == GFSX( +15 = 0x000F, 1, 0) =   -1 = 0xFFFFFFFF (wanted   -1 = 0xFFFFFFFF)
== PASS == GFSX( +15 = 0x000F, 2, 0) =   -1 = 0xFFFFFFFF (wanted   -1 = 0xFFFFFFFF)
== PASS == GFSX( +15 = 0x000F, 2, 1) =   -1 = 0xFFFFFFFF (wanted   -1 = 0xFFFFFFFF)
== PASS == GFSX( +15 = 0x000F, 3, 1) =   -1 = 0xFFFFFFFF (wanted   -1 = 0xFFFFFFFF)
== PASS == GFSX( +15 = 0x000F, 4, 2) =   +3 = 0x00000003 (wanted   +3 = 0x00000003)
== PASS == GFSX( +15 = 0x000F, 5, 0) =  +15 = 0x0000000F (wanted  +15 = 0x0000000F)
== PASS == GFSX( +15 = 0x000F, 5, 1) =   +7 = 0x00000007 (wanted   +7 = 0x00000007)
== PASS == GFSX( +15 = 0x000F, 5, 2) =   +3 = 0x00000003 (wanted   +3 = 0x00000003)
== PASS == GFSX( +15 = 0x000F, 5, 3) =   +1 = 0x00000001 (wanted   +1 = 0x00000001)
== PASS == GFSX( +15 = 0x000F, 5, 4) =   +0 = 0x00000000 (wanted   +0 = 0x00000000)
== PASS == GFSX(  +3 = 0x0003, 2, 0) =   +3 = 0x00000003 (wanted   +3 = 0x00000003)
== PASS == GFSX(+243 = 0x00F3, 2, 0) =   +3 = 0x00000003 (wanted   +3 = 0x00000003)
== PASS == GFSX(+243 = 0x00F3, 3, 0) =   +3 = 0x00000003 (wanted   +3 = 0x00000003)
== PASS == GFSX(+243 = 0x00F3, 4, 0) =  -13 = 0xFFFFFFF3 (wanted  -13 = 0xFFFFFFF3)
== PASS == GFSX(+243 = 0x00F3, 5, 0) =  -13 = 0xFFFFFFF3 (wanted  -13 = 0xFFFFFFF3)
== PASS == GFSX(+243 = 0x00F3, 6, 0) =  -13 = 0xFFFFFFF3 (wanted  -13 = 0xFFFFFFF3)
== PASS == GFSX(+243 = 0x00F3, 7, 0) =  -13 = 0xFFFFFFF3 (wanted  -13 = 0xFFFFFFF3)
== PASS == GFSX(+243 = 0x00F3, 7, 1) =   -7 = 0xFFFFFFF9 (wanted   -7 = 0xFFFFFFF9)
== PASS == GFSX(+243 = 0x00F3, 7, 2) =   -4 = 0xFFFFFFFC (wanted   -4 = 0xFFFFFFFC)
== PASS == GFSX(+243 = 0x00F3, 7, 3) =   -2 = 0xFFFFFFFE (wanted   -2 = 0xFFFFFFFE)
== PASS == GFSX(+243 = 0x00F3, 7, 4) =   -1 = 0xFFFFFFFF (wanted   -1 = 0xFFFFFFFF)
== PASS == GFSX(+243 = 0x00F3, 8, 0) = +243 = 0x000000F3 (wanted +243 = 0x000000F3)
== PASS ==

Exhaustive test
       GFSX(1604336871 = 0x5FA03CE7,  1,  0) =         -1 = 0xFFFFFFFF
       GFSX(1604336871 = 0x5FA03CE7,  2,  0) =         -1 = 0xFFFFFFFF
       GFSX(1604336871 = 0x5FA03CE7,  2,  1) =         -1 = 0xFFFFFFFF
       GFSX(1604336871 = 0x5FA03CE7,  3,  0) =         +7 = 0x00000007
       GFSX(1604336871 = 0x5FA03CE7,  3,  1) =         +3 = 0x00000003
       GFSX(1604336871 = 0x5FA03CE7,  3,  2) =         +1 = 0x00000001
       GFSX(1604336871 = 0x5FA03CE7,  4,  0) =         +7 = 0x00000007
       GFSX(1604336871 = 0x5FA03CE7,  4,  1) =         +3 = 0x00000003
       GFSX(1604336871 = 0x5FA03CE7,  4,  2) =         +1 = 0x00000001
       GFSX(1604336871 = 0x5FA03CE7,  4,  3) =         +0 = 0x00000000
       GFSX(1604336871 = 0x5FA03CE7,  5,  0) =        -25 = 0xFFFFFFE7
       GFSX(1604336871 = 0x5FA03CE7,  5,  1) =        -13 = 0xFFFFFFF3
       GFSX(1604336871 = 0x5FA03CE7,  5,  2) =         -7 = 0xFFFFFFF9
       GFSX(1604336871 = 0x5FA03CE7,  5,  3) =         -4 = 0xFFFFFFFC
       GFSX(1604336871 = 0x5FA03CE7,  5,  4) =         -2 = 0xFFFFFFFE
       GFSX(1604336871 = 0x5FA03CE7,  6,  0) =        -25 = 0xFFFFFFE7
       GFSX(1604336871 = 0x5FA03CE7,  6,  1) =        -13 = 0xFFFFFFF3
       GFSX(1604336871 = 0x5FA03CE7,  6,  2) =         -7 = 0xFFFFFFF9
       GFSX(1604336871 = 0x5FA03CE7,  6,  3) =         -4 = 0xFFFFFFFC
       GFSX(1604336871 = 0x5FA03CE7,  6,  4) =         -2 = 0xFFFFFFFE
       GFSX(1604336871 = 0x5FA03CE7,  6,  5) =         -1 = 0xFFFFFFFF
...
       GFSX(1604336871 = 0x5FA03CE7, 29, 28) =         +1 = 0x00000001
       GFSX(1604336871 = 0x5FA03CE7, 30,  0) = -543146777 = 0xDFA03CE7
       GFSX(1604336871 = 0x5FA03CE7, 30,  1) = -271573389 = 0xEFD01E73
       GFSX(1604336871 = 0x5FA03CE7, 30,  2) = -135786695 = 0xF7E80F39
       GFSX(1604336871 = 0x5FA03CE7, 30,  3) =  -67893348 = 0xFBF4079C
       GFSX(1604336871 = 0x5FA03CE7, 30,  4) =  -33946674 = 0xFDFA03CE
       GFSX(1604336871 = 0x5FA03CE7, 30,  5) =  -16973337 = 0xFEFD01E7
       GFSX(1604336871 = 0x5FA03CE7, 30,  6) =   -8486669 = 0xFF7E80F3
       GFSX(1604336871 = 0x5FA03CE7, 30,  7) =   -4243335 = 0xFFBF4079
       GFSX(1604336871 = 0x5FA03CE7, 30,  8) =   -2121668 = 0xFFDFA03C
       GFSX(1604336871 = 0x5FA03CE7, 30,  9) =   -1060834 = 0xFFEFD01E
       GFSX(1604336871 = 0x5FA03CE7, 30, 10) =    -530417 = 0xFFF7E80F
       GFSX(1604336871 = 0x5FA03CE7, 30, 11) =    -265209 = 0xFFFBF407
       GFSX(1604336871 = 0x5FA03CE7, 30, 12) =    -132605 = 0xFFFDFA03
       GFSX(1604336871 = 0x5FA03CE7, 30, 13) =     -66303 = 0xFFFEFD01
       GFSX(1604336871 = 0x5FA03CE7, 30, 14) =     -33152 = 0xFFFF7E80
       GFSX(1604336871 = 0x5FA03CE7, 30, 15) =     -16576 = 0xFFFFBF40
       GFSX(1604336871 = 0x5FA03CE7, 30, 16) =      -8288 = 0xFFFFDFA0
       GFSX(1604336871 = 0x5FA03CE7, 30, 17) =      -4144 = 0xFFFFEFD0
       GFSX(1604336871 = 0x5FA03CE7, 30, 18) =      -2072 = 0xFFFFF7E8
       GFSX(1604336871 = 0x5FA03CE7, 30, 19) =      -1036 = 0xFFFFFBF4
       GFSX(1604336871 = 0x5FA03CE7, 30, 20) =       -518 = 0xFFFFFDFA
       GFSX(1604336871 = 0x5FA03CE7, 30, 21) =       -259 = 0xFFFFFEFD
       GFSX(1604336871 = 0x5FA03CE7, 30, 22) =       -130 = 0xFFFFFF7E
       GFSX(1604336871 = 0x5FA03CE7, 30, 23) =        -65 = 0xFFFFFFBF
       GFSX(1604336871 = 0x5FA03CE7, 30, 24) =        -33 = 0xFFFFFFDF
       GFSX(1604336871 = 0x5FA03CE7, 30, 25) =        -17 = 0xFFFFFFEF
       GFSX(1604336871 = 0x5FA03CE7, 30, 26) =         -9 = 0xFFFFFFF7
       GFSX(1604336871 = 0x5FA03CE7, 30, 27) =         -5 = 0xFFFFFFFB
       GFSX(1604336871 = 0x5FA03CE7, 30, 28) =         -3 = 0xFFFFFFFD
       GFSX(1604336871 = 0x5FA03CE7, 30, 29) =         -2 = 0xFFFFFFFE
</code></pre>
",0
13779584,13779487,2,"<pre><code>enum { MAXLINE = 1024 };

void readFile(FILE *file)
{
    char line[MAXLINE];
    while (fgets(line, sizeof(line), file) != 0)
    {
        char *str = line;
        int j;
        int pos;
        while (sscanf(str, ""%1d%n"", &amp;j, &amp;pos) == 1)
        {
            printf(""%d\n"", j);
            str += pos;
        }
    }
}
</code></pre>

<p>The <code>%1d</code> part of the format reads a single digit (but also skips blanks).  The <code>%n</code> is in C89 and reports the position where the scan is in the string; it is not counted as a conversion (hence the comparison with 1).</p>
",4
13779571,13779487,1,"<p>Strings in C are NULL-terminated. This means, if you give a pointer to a function expecting a string, everything from this memory location up to the first NULL-byte is considered part of the string.</p>

<p>Having said that, you need to treat each character separately. First you need to check whether the character actually is a number. As suggested by Jonathan Leffler, the C standard guarantees that '0'..'9' are a consecutive range in the charset:</p>

<blockquote>
  <p>ISO/IEC 9899:2011 ¡ì5.2.1 Character sets: <em>In both the source and execution basic character sets, the value of each character after 0 in the above list of decimal digits shall be one greater than the value of the previous.</em></p>
</blockquote>

<p>Hence, the following is a correct solution:</p>

<pre><code>for (j = 0; j &lt; 9; j++) {
   char c = line[j];
   if ('0' &lt;= c || c &lt;= '9')
       printf(""%d \n"", c - '0');
}
</code></pre>

<p>Instead of <code>c - '0'</code> you can also use <code>atoi</code>, but then you need to turn your char into a string again (this needs to go inside the if):</p>

<pre><code>char[2] s = "" ""; // "" "" only serves as a placeholder.
s[0] = c;
int a = atoi(s);
</code></pre>
",3
14777352,14777303,1,"<p>I stepped through <code>write(2)</code> with gdb to get an idea of how the system call ABI works.</p>

<p>Anyway, no libc at all. Note that without special tricks, the cc(1) compiler/linker front-end will still link you with libc, but you won't be using it for anything. The C runtime start-up code will make some libc calls, but this program won't.</p>

<pre><code>void mywrite(int fd, const void *b, int c) {
  asm(""movl $1, %eax"");
  asm(""syscall"");
}

int main(void) { const char *s = ""Hello world.\n""; return mywrite(1, s, 13), 0; }
</code></pre>
",5
15866158,15865601,0,"<pre><code>while (scanf(""%c"", &amp;code[0]) == 1)
{   scanf(""%s"", &amp;code[1]);
    ...
</code></pre>
",3
15866267,15865601,4,"<pre><code>while (scanf(""%s"", code) == 1)
{
    // no need for second scanf call
    ...
</code></pre>
",2
15866345,15865601,0,"<p>Using <code>scanf</code> at all is a bad idea for this particular problem.</p>

<pre><code>while(scanf(""%c"", &amp;code[0])!=EOF)
</code></pre>

<p>This <code>scanf</code> call reads a single character. Just use <code>getchar()</code>.</p>

<pre><code>scanf(""%s"", code);

for(i=0; i&lt;strlen(code); i++)
{
    decrypt message one char at a time
}
</code></pre>

<p>The <code>scanf</code> call can read arbitrarily many characters (after skipping whitespace; are you sure you want to skip whitespace?). That means that if there are too many characters to be read from <code>stdin</code>, you have a buffer overflow, one that you can't avoid unless you have complete control over what appears on <code>stdin</code>.</p>

<p>You then loop over the <code>code</code> array, calling <code>strlen()</code> for each character you process. Since <code>strlen()</code> generally has to scan from the beginning of the array to the terminating <code>'\0'</code>, this is inefficient. <em>If</em> you need to traverse the characters of a string, either call <code>strlen()</code> once and save the value, or look for the terminating <code>'\0'</code> character.</p>

<p>But you're just processing one character at a time, so just <em>read</em> one character at a time:</p>

<pre><code>while ((c = getchar()) != EOF) {
    /* process a character */
}
</code></pre>

<p>Don't worry about reading one character at a time being inefficient; buffering will take care of that.</p>
",0
15890164,15890146,4,"<p>C is case-sensitive. In your function, there is no <code>PlayerTurn</code> declared, but you seem to have declared <code>playerTurn</code>. Simply correcting the upper-case P to lower-case will work, assuming that this is actually the variable that you want to refer to. :)</p>
",0
19870340,19870314,2,"<p>Don't use <code>atof()</code>: <code>atof()</code> doesn't have a useful error indication. Use <code>strtod()</code> instead.</p>
",6
19870459,19870314,-1,"<p>Usually easiest solutions are hard to spot:</p>

<pre><code>if ( memcmp(buffer,""0.0\n"",4) == 0 )
{
    // zero - can call atof
}
else
{
    // whatever
}
</code></pre>

<p>Of course it may be your requirement that zero is actually represented this way and not with any other pattern. After all sane people write 0.0 not -0.000 etc ;-)</p>
",0
14248364,14248274,4,"<pre><code>for(i=0; i&lt;N-1; i++) {
    //looking for the position of B[i] in A
    j=-1;
    while ( A[++j] != B[i] ) {}

    //now A[j] is B[i]

    for (k= 0 ; k &lt; j; k++) {
        //is the next in B in a previous position in A ?
        if (B[i+1] == A[k]) {
            count++;
            break;
        }
    }
}
</code></pre>

<p>And also, here's another solution</p>

<pre><code>int pos1, pos2;
for(i=0; i&lt;N-1; i++) {
    pos2=-1;
    for(j=-1; j&lt;N &amp;&amp; pos1 != -1 &amp;&amp; pos2 != -1; j++) { //will stop if both are found
       if (pos1 == -1 &amp;&amp; B[i]==A[j]) pos1 = j; //found the position of a num
       if (B[i+1]==A[j]) pos2 = j; //found the position of the next num
       if (pos2 &lt; pos1) {
          count++;
       }
    }
    pos1 = pos2; //useful for next loop..
}
</code></pre>
",3
14248530,14248274,1,"<p>The key here is ""two <em>consecutive</em> numbers in the first file"".</p>

<p>There is no need to do an O(N^2) loop.  In fact, you can use a dynamic programming approach utilizing the following criteria:</p>

<ul>
<li><p>The numbers are distinct</p></li>
<li><p>For any set of <code>N</code> numbers, the number values are <code>0..N-1</code> (this is my assumption)</p></li>
<li><p>For any two consecutive numbers <code>A</code> and <code>B</code> in the first file, order is preserved in the second file if you have already encountered <code>A</code> at the time you encounter <code>B</code>.</p></li>
</ul>

<p>Note my assumption about values.  If that assumption is false, then you may as well use the O(N^2)-ish answer that is currently accepted (although you could build a tree to index values and the worst-case becomes O(N.log(N)).</p>

<p>If you can index the values directly, then this problem becomes linear.</p>
",5
14248631,14248274,0,"<p>The number of inversions between two arrays of length N is ...</p>

<p>if N is 1, the number of inversions is 0<br>
otherwise, it is the number of inversions between the last N-1 elements of the first array and the second array excluding the first element of the first array plus the position of the first element of the first array in the second array</p>

<p>Hooray for recursion :)</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

static int find(int a, int *b, size_t n) {
  size_t k = 0;
  while (k &lt; n) {
    if (b[k] == a) return k;
    k++;
  }
  return -1;
}

int ninversions(int *a, int *b, size_t n) {
  if (n == 1) return 0;
  size_t pos = find(*a, b, n);
  if (pos == (size_t)-1) exit(EXIT_FAILURE);
  int *newb = malloc((n - 1) * sizeof *newb);
  memcpy(newb, b, pos * sizeof *b);
  memcpy(newb + pos, b + pos + 1, (n - pos - 1) * sizeof *b);
  int retval = pos + ninversions(a + 1, newb, n - 1);
  free(newb);
  return retval;
}
</code></pre>
",0
15883780,15883743,3,"<p>You're comparing to the wrong thing. Try:</p>

<pre><code>ch != '\n'
      ^  ^
</code></pre>

<p>Also, as spotted in other answers, you're using <code>len</code> without initializing it.</p>

<p>Finally, you do realize <code>fgets</code> can do that as well. You could rewrite the thing to:</p>

<pre><code>if (fgets(txt, sizeof txt, fp))
    ...
</code></pre>
",0
15883805,15883743,1,"<p><code>len</code> is not initialised so you're probably attempting to write way beyond the end of <code>txt</code>.  The fix is simple - initialise it to <code>0</code> on declaration</p>

<pre><code>int len = 0;
</code></pre>

<p>In addition to the error pointed out by cnicutar, you should also check the return value from <code>fopen</code> before using <code>fp</code>.</p>
",6
15883817,15883743,3,"<p>1) <code>len</code> is not initiated</p>

<pre><code>int len=0;
</code></pre>

<p>2) From <a href=""http://cplusplus.com/reference/cstdio/fgetc/"" rel=""nofollow"">fgetc()</a> page:</p>

<pre><code>int fgetc ( FILE * stream );
</code></pre>

<p>so  the <code>fgetc()</code> return <code>int</code> and not <code>char</code> so you have to define <code>ch</code> as <code>int</code></p>

<pre><code>int ch;
</code></pre>

<p>3) In addition of the <strong><em>cnicutar</em></strong> remark, the <code>while</code> condition should be checked with the <code>&amp;&amp;</code> and not with <code>||</code>:</p>

<pre><code>while(ch != EOF &amp;&amp; ch!='\n')
</code></pre>

<p>4) You have to add null terminator charachter at the end of your <code>txt</code> buffer after finishing reading from file.</p>

<p>Add this line after the <code>while</code> loop</p>

<pre><code>txt[len]='\0';
</code></pre>

<hr>

<p><strong>BTW</strong> you can read the first line with <code>fscanf()</code> it's more easier. Just use the following code</p>

<pre><code>fscanf(fp, ""%29[^\n]"", txt);
</code></pre>

<p>The <code>""%[^\n]""</code> means that <code>fscanf</code> will read all characters from <code>fp</code> except the <code>'\n'</code> charachter and it will stop reading if it gets this charachter. So the  <code>fscanf</code> will read all characters from <code>fp</code> till it find <code>'\n'</code> character and save them into the buffer <code>txt</code> with null terminator charchter at the end.</p>

<p>The <code>""%29[^\n]""</code> means that <code>fscanf</code> will read all characters from <code>fp</code> till it find <code>'\n'</code> character or till it reach 29 readed charchters and save them into the buffer <code>txt</code> with null terminator charchter at the end.</p>
",5
15883979,15883743,0,"<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

void main()
{
  FILE *fp;
  char ch;
  char txt[30];
  int len = 0;
  fp=fopen(""~/hello.txt"",""r"");
  if(!fp) {
    printf(""Cannot open file!\n"");
    return;
  }
  ch=fgetc(fp);
  while(ch != EOF &amp;&amp; ch!= '\n' &amp;&amp; len &lt; 30)
  {
    txt[len] = ch;
    len++;
    ch=fgetc(fp);
  }
  txt[len] = 0;
  puts(txt);
}
</code></pre>
",0
16932192,16932066,8,"<p>The comma operator returns the result of its second operand, and the <code>||</code> operator will short circuit.  So what happens in this case is:</p>

<ol>
<li><p><code>++a</code> is evaluated, <code>a</code> is now <code>6</code>.</p></li>
<li><p>Since the result of (1) was non-zero, the right side of the <code>&amp;&amp;</code> is evaluated.  That means <code>++b</code>, so <code>b</code> becomes <code>11</code>.</p></li>
<li><p>(1) and (2) are the left side of a comma operator, so the result of the <code>&amp;&amp;</code> is discarded.  (it's <code>1</code>, if that matters to you).</p></li>
<li><p>The <code>++a</code> on the right side of the first <code>,</code> is evaluated.  <code>a</code> is now <code>7</code>.</p></li>
<li><p>the assignment to <code>t</code> takes place - <code>t</code> is now <code>7</code>, the result of the first comma operator.</p></li>
<li><p>All of that was the left side of another comma operator, so the result (<code>7</code>) is discarded.  Next <code>++a</code> is evaluated.  <code>a</code> is now <code>8</code>.</p></li>
<li><p>Since <code>a</code> is not 0, the <code>||</code> short circuits, and the <code>++c</code> isn't evaluated. <code>c</code> stays <code>15</code>.</p></li>
</ol>

<p>Results: <code>t</code> is <code>7</code>, <code>a</code> is <code>8</code>, <code>b</code> is <code>11</code>, and <code>c</code> is <code>15</code>.  The <code>printf</code> statement outputs:</p>

<pre><code>7  8  11 15
</code></pre>

<p>Overall, this code would be easier to understand if you just wrote:</p>

<pre><code>++a;
++b;
t = ++a;
++a;
</code></pre>

<p>Which has precisely the same behaviour.</p>
",2
16932321,16932066,6,"<p>Execution -> </p>

<pre><code>  t = (++a &amp;&amp; ++b, ++a), ++a || ++c;  // () Priority
      ^
  t = (++a &amp;&amp; ++b, ++a), ++a || ++c;  // ++a -&gt; a = 6
        ^
  t = ( 6 &amp;&amp; ++b, ++a), ++a || ++c;   // ++b -&gt; b = 11
               ^
  t = ( 6 &amp;&amp; 11 , ++a), ++a || ++c;   // 6 &amp;&amp; 11 -&gt; 1
           ^          
  t = ( 1 , ++a), ++a || ++c;         // ++a -&gt; a = 7
            ^          
  t = ( 1 , 7), ++a || ++c;          // (1,7) -&gt; 7 ... Comma operator has less priority 
          ^          
  t = 7, ++a || ++c;                //  (t = 7), ++a || ++c; ...Assigned value to t... Comma operator has less priority 
    ^
  ++a || ++c;                       // ++a -&gt; a = 8
   ^          
  8 || ++c;                        //  8 || ++c -&gt; 1 ...as 1 || exp -&gt; 1...Logical OR skip next part if 1st exp is true  
    ^
</code></pre>

<p>Finally -> </p>

<pre><code>t = 7
a = 8
b = 11
c = 15 
</code></pre>
",2
16932453,16932066,0,"<pre><code>int t, a = 5, b = 10, c = 15;
</code></pre>

<p>In C (and C++) the comma operator evaluates it's first operand, discards it and evaluates it's second operand and returns it.</p>

<p><code>++a &amp;&amp; ++b</code>  is first evaluated, a is now 6, b is now 11.</p>

<p><code>(++a &amp;&amp; ++b, ++a)</code> now the second operand to the right of the comma (<code>++a</code>) is evaluated, a is now 7. Also at this point t is assigned to the value 7. <strong><em>This is because the assignment operator has a higher precedence than the comma operator</em></strong>.</p>

<p>(++a &amp;&amp; ++b, ++a), ++a<code>now the second operand to the right of</code>(++a &amp;&amp; ++b, ++a)<code>is evaluated. The third</code>++a` gives a's value as 8.</p>

<p>The logical <code>||</code> operator evaluates it's first operand and if it is <code>true</code> it does not evaluate the second operand. The first operand <code>(++a &amp;&amp; ++b, ++a), ++a</code> is non-zero (true) and therefore the ++c is not evaluated. c's value remains at 15. </p>
",0
15886378,15886279,3,"<p>here:</p>

<pre><code> fscanf(fp,""%29[^\n]"",pwd);  
</code></pre>

<p>You're telling <code>fscanf()</code> to read up until it sees a newline, then to stop. Here:</p>

<pre><code> fscanf(fp,""%c"",&amp;status);
</code></pre>

<p>You're telling <code>fscanf()</code> to read the next character (which is the newline). Then here:</p>

<pre><code>printf(""\n Status : %c pwd: %s"",status,pwd);
</code></pre>

<p>It prints the newline as a character (so you can't see it, it's just a blank line)</p>

<p>You need to consume that newline if you want to read it like this with fscanf().</p>

<p>One option would be to just do something like:</p>

<pre><code>fscanf(fp,""%29[^\n]"",pwd); 
fgetc(fp);
fscanf(fp,""%c"",&amp;status);
</code></pre>

<p>Another resolution would be to add a space before the <code>%c</code> to tell <code>fscanf()</code> to ignore white space characters:</p>

<pre><code>fscanf(fp,""%29[^\n]"",pwd); 
fscanf(fp,"" %c"",&amp;status);
</code></pre>
",0
15886388,15886279,1,"<p>The first <code>fscanf</code> is putting the newline back, and so the second <code>fscanf</code> is just reading the newline, not the character you want. You can get around this by putting a space before the <code>%c</code>, e.g.</p>

<pre><code>fscanf(fp,"" %c"",&amp;status);
</code></pre>
",0
15541180,15541116,1,"<p>The <code>getline</code> function will let you store a string into <code>cmd</code>.</p>

<p>Then, you can compare your string with <code>strcmp</code></p>

<pre><code>if ((strcmp(cmd, ""0"") == 0) || (strcmp(cmd, ""zero"") == 0)) {
    circle();
} else if ((strcmp(cmd, ""1"") == 0) || (strcmp(cmd, ""one"") == 0)) {
    sphere();
}
</code></pre>
",2
15541292,15541116,0,"<blockquote>
  <p>I just want to allow for string or integer input</p>
</blockquote>

<p>The best way is to use regular expression to verify input</p>

<pre><code>    #include &lt;regex.h&gt;

    regex_t checkInteger;
    regex_t checkFloat;

    bool isInteger = false;
    bool isFloat = false

    int reti;
    char input[100];

    // read input from user

    regcomp(&amp;checkInteger, ""^[1-9][0-9]*$"", 0);
    regcomp(&amp;checkFloat, ""^[1-9][0-9]*\.[0-9]+$"", 0);

    isInteger = !regexec(&amp;checkInteger, input, 0, NULL, 0);
    isFloat = !regexec(&amp;checkFloat, input, 0, NULL, 0);

    if (isInteger)
    {
            // input is integer
    }
    else if (isFloat)
    {
            // input is float
    }

    regfree(&amp;checkInteger);
    regfree(&amp;checkFloat);
</code></pre>
",0
15541300,15541116,0,"<p>Change your <code>checkInput</code> function like this</p>

<pre><code>int checkInput(char* input) {
  int i = 0;
  while (i &lt; strlen(input))
    input[i] = tolower(input[i]);

  if ((strcmp(input, ""0"") == 0) || (strcmp(input, ""zero"") == 0)) {
    return 0;
  } else if ((strcmp(input, ""1"") == 0) || (strcmp(input, ""one"") == 0)) {
    return 1;
  }
  return 4;  // Quit Option
}
</code></pre>

<p>And in your <code>main</code> call like this</p>

<pre><code>switch (checkInput(cmd)) {

    case 0:
        circle();
    break;

    case 1:
        sphere();
    break;
}
</code></pre>

<p>You are accepting a string into variable <code>cmd</code>. declare it as a character array like this <code>char cmd[10];</code></p>
",4
15541303,15541116,0,"<p>solution1:
 as String</p>

<pre><code>case ""0"":
</code></pre>

<p>as Integer </p>

<pre><code>int cmd; // declare cmd as atring




printf(""Select your choice!: "");
    scanf(""%d"", &amp;cmd); 

switch (cmd) {

            case 0:
                circle();
----
</code></pre>
",0
15541362,15541116,0,"<p>Read the input into a NUL-terminated string, <code>cmd</code>, then</p>

<pre><code>switch (((strcmp(cmd, ""0"") == 0) || (strcmp(cmd, ""zero"") == 0)) +
        ((strcmp(cmd, ""1"") == 0) || (strcmp(cmd, ""one"") == 0)) * 2)
{
case 1:
  circle();
  break;
case 2:
  sphere();
  break;
default:
  // handle the error
  break;
}
</code></pre>
",0
14731302,14731033,0,"<p>The others have answered your question, but to make it easier for you, you can also introduce scope which makes it easier to read and write for programmers:</p>

<pre><code>// the braces introduce scope, and make it easier to read and find your bugs.
case 2:
{ 
  if (0 == num)
  {
    printf(""Twenty"");
  }
  else 
  {
    printf("" And Twenty"");
  }
} break;
</code></pre>
",4
14731076,14731033,4,"<pre><code>if (num==0)
</code></pre>

<p>and not</p>

<pre><code>if (num=0)
</code></pre>
",2
14731100,14731033,5,"<pre><code>if (num=0)
</code></pre>

<p>You missed an <code>=</code> sign which causes this to be an assignment <code>if(num=0)</code> is the same as <code>if(0)</code> and thus will always be false. It should be</p>

<pre><code>if (num==0)
</code></pre>

<p>or better yet:</p>

<pre><code>if(0 == num)
</code></pre>

<p>which will prevent a mistake like this by throwing an error.</p>

<hr>

<p><strong>edit:</strong><br>
You say that doesn't fix the problem, then there's something else wrong. Here's an example code where it does work:</p>

<pre><code>int i = 2;
int j = 0;

switch(i)
{
    case 0:
       printf(""it's 0\n"");
       break;
    case 1:
       printf(""it's 1\n"");
       break;
    case 2:
       printf(""it's 2\n"");
       if(0 == j)
           printf(""j is 0\n"");
       else
           printf(""hit the else\n"");
       break;
    default:
       printf(""The default\n"");
}
</code></pre>

<p>This code is a proof of concept for what you're trying to do. It prints ""it's 2"" followed by ""j is 0"" because that works. If your code isn't working still you're doing something else you're not showing us, or your variables are not set how you think. Check your variables, print them before entering the switch.</p>
",7
14735828,14735131,2,"<p>There's the minor issue of the double fopen, that should be cut down to one.</p>

<p>Your file probably has a format something like this:</p>

<pre><code>15
The quick
brown
</code></pre>

<p>The problem is that your logic is something like the following:</p>

<pre><code>/* Opens a file stream for the .txt file to be read in */
ptr_file = fopen(""hollo_man.txt"", ""r"");
if (/*the file was opened correctly */) {

        Read 'width' from the first word of the file;
        Create a buffer exactly 'width'+1 in size;

        while(get_a_character != EOF) {
            increment_total_character_count;
            if(character_is_newline)
                increment_newline_count;
                insert a '\0' in the output buffer;
                reset the index we're inserting into the output buffer
                prevCharacterIsSpace = false;
            if(character_is_space)
                if(previous_character_NOT_a_space)
                    put_character_in_output_buffer;
                    increment_word_counter;
                    prevCharacterIsSpace = true;
            else
                prevCharacterIsSpace = true;
                put_character_in_output_buffer;
                increment_nw (never used)
        }


        needed_spaces = (width - nc) % lw;
        printf("" %s"", outputbuf);
</code></pre>

<p>If the input file has the format above, with the width appearing on it's own line, what the character stream you are reading looks like this:</p>

<pre><code>'15' (read as a unit with the %i)
'\n'
'T'
'h'
...
'w'
'n'
'\n'
</code></pre>

<p>Your character-reading-loop sees a newline as the very first character. It inserts a null into the output buffer, sets prevCharacterIsSpace to false, and then continues. If your file format does match what I have above, you probably want to fix this by ""eating"" the '\n' right after reading in 'width'.</p>

<p>Note that the <a href=""http://www.cplusplus.com/reference/cctype/isspace/"" rel=""nofollow"">isspace</a> function returns true for newlines, so now the newline is put into the next slot of the output buffer, and the word counter is incremented (if you uncommented that printf at the bottom of the program, you should see that effect). The fix is probably just to make the <code>if (isspace(c))</code> into <code>else if (isspace(c))</code></p>

<p>Another problem is that you're copying each seperate line from the file into the same buffer. So there is no way that you can display any more than the last line of the input. You probably need to put your printing code inside the <code>if (c == '\n') {</code> block. This will allow you to print each line as you read it.</p>

<p>None of the code here handles printing right-justified text, but a simple solution for that would be a small loop:</p>

<pre><code>for (i = 0; i &lt; (width - buff_offset); i++)
    printf("" "");
</code></pre>

<p>inserted directly before you print your output.</p>
",1
14735438,14735131,2,"<p>first of all don't call <code>fopen(""hollo_man.txt"", ""r"")</code> twice, check the pointer in your <code>if</code>.</p>

<p>then you should read the file in word by word:</p>

<pre><code>char words[1024];
char * next_word = words;
while(fscanf(ptr_file, ""%s"", next_word) {
</code></pre>

<p>count their length</p>

<pre><code>size_t word_length = strlen(next_word);
next_word += word_length + 1;
</code></pre>

<p>and when you have reached the necessary width print them:</p>

<pre><code>total_length +=  word_length;
if (total_length &gt; maxColumns) {
     size_t extra_spaces = total_length - word_length - 2;
</code></pre>

<p>Does this help?</p>

<p>Here is a complete solution:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void justify(FILE* in, FILE * out, int columns) {
    char words[1024];
    char * next_word = words;

    ssize_t total_length = 0;
    size_t num_words = 0;

    while (fscanf(in, ""%s"", next_word) == 1) {
        size_t word_length = strlen(next_word);
        next_word += word_length + 1;
        num_words++;
        total_length += word_length;

        if (total_length + num_words &gt; columns) {

            size_t spaces_needed = columns - (total_length - word_length);

            int minspoaces = 1;
            if (num_words &gt; 2) // avoids nasty floating point exception if no two words fit on a line
                minspoaces = spaces_needed / (num_words - 2);


            char * word_print = words;

            size_t chars_printed = fprintf(out, ""%s"",word_print);
            word_print += strlen(word_print) + 1;
            size_t spaces_printed = 0;
            ssize_t words_to_print = num_words - 2;

            fflush(out);

            while (words_to_print &gt; 0) {
                int spaces_to_print = minspoaces;
                if (((spaces_needed - spaces_printed) % words_to_print) * 2 &gt;= words_to_print) // spreads spaces out along the line
                    spaces_to_print++;
                spaces_printed += spaces_to_print;
                words_to_print--;
                chars_printed += fprintf(out, ""%*c%s"", spaces_to_print, ' ', word_print);
                word_print += strlen(word_print) + 1;
                fflush(out);
            }
            fprintf(out, ""\n"");

            memmove(words, word_print, (total_length = strlen(word_print)) + 1);
            num_words = 1;
            next_word = words + total_length + 1;
        }

    }

    char * word_print = words;
    while (word_print != next_word) {
        word_print += fprintf(out, ""%s "", word_print);
    }

    fprintf(out, ""\n"");
}

int main(int argc, char ** argv) {

    int columns = atoi(argv[1]);

    FILE * in = stdin;

    if (argc &gt;= 3 &amp;&amp; argv[2]) {
        in = fopen(argv[2], ""r"");
        if (!in) {
            perror(""fopen"");
            return -1;
        }
    }

    justify(in, stdout, columns);

}
</code></pre>
",2
15847675,15847472,3,"<p>You should re-write you if you forgot to add parenthesis () </p>

<blockquote>
  <p>if( data=recvfrom(sd, file_buffer, sizeof(file_buffer), 0, (struct sockaddr *) &amp;server,    &amp;server_length)&lt;0 )</p>
</blockquote>

<p><strong>Reason:</strong><br>
Precedence of <code>&lt;</code> is higher then <code>=</code> So in your if() first  <code>&lt;</code> performed then <code>=</code>
and this cause assigns <code>data</code> either <code>0</code> when data read successfully  and <code>1</code> when <code>recvfrom()</code> returns <code>-1</code> on error.<br>
look @ <a href=""http://www.difranco.net/compsci/C_Operator_Precedence_Table.htm"" rel=""nofollow"">C Operator Precedence Table</a></p>

<p>You code is equipment to on successfully read : </p>

<pre><code>if(data = 1 &lt; 0)
</code></pre>

<p>and on  <code>recvfrom()</code> fail its like: </p>

<pre><code>if(data = -1 &lt; 0) 
</code></pre>

<p><strong>Mistake</strong>?  Actually you forgot () parenthesis (or if you don't know you shold add.)  like:  </p>

<blockquote>
  <p>if( (data=recvfrom(sd, file_buffer, sizeof(file_buffer), 0, (struct sockaddr *) &amp;server,    &amp;server_length)) &lt;0 )</p>
</blockquote>

<p>see I added () like: </p>

<pre><code>if( (data = recvfrom() ) &lt; 0) 
    ^                  ^  added in your code 
</code></pre>

<p><strong>Edit</strong>: </p>

<p><strong>Second error</strong>: ""buffer is not <code>\0</code> terminated""   </p>

<p>The function <a href=""http://publib.boulder.ibm.com/infocenter/tpfhelp/current/index.jsp?topic=/com.ibm.ztpf-ztpfdf.doc_put.cur/gtpc2/cpp_recvfrom.html"" rel=""nofollow"">recvfrom()</a> if successful worked, returns the length, in bytes, of the message or datagram. And if an end-of-file condition is received or the connection is closed, <code>0</code> is returned.</p>

<p>the thing to be notice is <em>it doesn't puts <code>'\0'</code> symbol to terminate buffer.</em> and you are using <code>'%s'</code> to print <code>file_buffer[]</code>'s content which excepts null terminated string that also cause Undefined Behavior at run time (and you may get unusual symbols on console if not getting segmentation-fault).  </p>

<p>You should always read less then one of <code>sizeof(file_buffer)</code> and put null <code>\0</code> explicitly, if you wants to use your file buffer as string. </p>

<p>I can suggest you do like:  </p>

<pre><code>no_Of_bytes =recvfrom( 
                sd, 
                file_buffer, 
                sizeof(file_buffer) - 1, 
                0,
                (struct sockaddr *) &amp;server, 
                &amp;server_length
            );
file_buffer[no_Of_bytes] = '\0';
</code></pre>

<p>Now your <code>file_buffer</code> is null terminated you can use with <code>%s</code>, but be sure you are not making mistakes in other part of code.  </p>
",2
14222824,14222744,0,"<p>If you wanted to round towards zero, this would be be perfectly enough</p>

<pre><code>double myDouble = - 3.14;
short s = myDouble;
</code></pre>

<p>If you want to round towards negative infinity, then just add <code>floor</code></p>

<pre><code>double myDouble = - 3.14;
short s = floor(myDouble);
</code></pre>

<p>In either case there's no need for an explicit cast from <code>double</code> to <code>short</code>, but it might be a good idea to keep it just to keep compilers from issuing warnings.</p>

<p>And, of course, it is your responsibility to make sure that the original value is in range of <code>short</code>.</p>

<p>If this somehow ""doesn't work"" (whatever that means) when it should, then the compiler you use must be broken.</p>
",1
15903823,15338417,1,"<p>How do you represent arbitrary precision integers? </p>

<p>I mean what type are you actually using?</p>

<p>Can you please show us your code?</p>

<p>If you feel really lazy you can clone this project i've made few months ago:
<a href=""https://github.com/nomadster/ESP"" rel=""nofollow"">https://github.com/nomadster/ESP</a></p>

<p>Edit:</p>

<p>By further reading your post i suppose by this statement</p>

<p>""this happens because when i rounded one of this ""zeros"", (0,50009 for examples), they became ""one""""</p>

<p>that you are still unaware of the fact that fft multiplication only works when the roundoff error is smaller than 0.5.
So it seems to me (if and only if i've correctly interpreted your cryptic message) that you are using a floating point type that doesn't have the required precision.</p>
",0
17863788,17863721,-1,"<p>You are moving the number before it is checked.  That's why you are missing it.  I suggest sorting them first and then check for duplicates later (current == prev).  Maybe other techniques would work too.</p>
",0
17863876,17863721,3,"<p>When you spot the duplicate, you need to 'remove' it.  You should probably move the last item in the list to the current spot (<code>a[j]</code>) and then decrement <code>dim</code>.</p>

<p>You'll need to consider how the possibly modified dimension is returned to the calling code, but then you also have an issue with how does other code get at the array that's local to the function.</p>
",0
15846454,15846415,0,"<p>You can open the file in one function and pass it as argument to other functions. For example, for the pre-open file handle stdin, you could use it as:</p>

<pre><code>char mystring [100];
fgets (mystring , 100 , pFile)
</code></pre>
",0
15846460,15846415,1,"<p>Just pass the file name as an argument to <code>main</code> function, it maybe what you want.
You might use <code>int main(int argc, char* argv[])</code>, an example:</p>

<pre><code>int main(int argc, char* argv[])
{
    FILE*  fp;
    if (argc == 1)
        printf(""usage : a.out filename\n"");
    else
    {
        if (fp = fopen(*++argv, ""r"") != NULL)
        {
            /*your code here*/
        }
    }
    return 0;
}
</code></pre>
",2
15861742,15861614,0,"<p>Use fgets to parse the file contents in a single array of chars, then <code>strtok()</code> that for each number. <br/>Each number you store in a double with the coresponding function. Check <a href=""https://stackoverflow.com/questions/10075294/converting-string-to-a-double-variable-in-c"">this</a> out to see how you can do that.</p>
",0
15861800,15861614,2,"<p>You can use <code>fgets</code> to get the line, then use <code>sscanf</code> to extract the data needed:</p>

<pre><code>double d1, d6;
int i2, i3, i4, i8;
long long ll7;

sscanf(input, ""%lf %d %d %d %*s %*s %*s %lf %lld %d"", &amp;d1, &amp;i2, &amp;i3, &amp;i4, &amp;d6, &amp;ll7, &amp;i8);
</code></pre>
",0
15861995,15861614,2,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int readFile (FILE* fp){
    char buff[4096];

    while(NULL!=fgets(buff, sizeof(buff), fp)){
        char *number, *check;
        for(number=buff;NULL!=(number=strtok(number,"" \t\n""));number=NULL){
            //separate string by strtok, isNumber check by strtod 
            strtod(number, &amp;check);
            if(*check=='\0'){
                printf(""%s\n"",number);
            }
        }
    }

    return 0;
}

int main(){
    readFile(stdin);

    return 0;
}
</code></pre>
",2
14168935,14168680,0,"<p><code>printf(""%d"", &amp;QuantityInStock);</code></p>

<p>Why are using <code>&amp;</code> while printing <code>QuantityInStock</code> value, it will print the address of <code>QuantityInStock</code> variable not its value..</p>

<p><code>printf(""%d"", QuantityInStock);</code></p>

<p>I think this is not the answer of your problem, problem is some where else..Please share the error you are getting..</p>
",1
15531895,15531869,2,"<p>Try <a href=""http://www.acm.uiuc.edu/webmonkeys/book/c_guide/2.12.html#printf"" rel=""nofollow""><code>printf</code></a> :</p>

<pre><code>int i=0;
for (; i&lt;20; i++)
  printf(""0x%.2x "", pkt[i]);
printf(""\n"");
</code></pre>
",1
15531947,15531869,0,"<p>The following code is sufficient,</p>

<pre><code>int i=0;
u_char  * ptr=pkt;
for (; i&lt;20; i++)
  printf(""%x "", ptr++);
printf(""\n"");
</code></pre>
",0
15575552,15575443,2,"<p>The initialization looks like it would not crash.  But the code immediately following it looks suspect.  The array has not been initialized (well ... it is initialized, but it is initialized to NULL), yet the following code accesses it:</p>

<pre><code>th = pTheta-&gt;the_array[0];
</code></pre>
",1
19877701,19877592,1,"<p>I don't know where <code>ltrunc()</code> comes from, but
you can set the size of a shared memory object with <code>ftruncate()</code>:</p>

<pre><code>if (ftruncate(fd, B_SIZE) == -1) {
    // Handle error
}
</code></pre>

<p>(from <a href=""http://pubs.opengroup.org/onlinepubs/009695299/functions/shm_open.html"" rel=""nofollow"">http://pubs.opengroup.org/onlinepubs/009695299/functions/shm_open.html</a>).</p>
",0
19877714,19877592,1,"<p><code>ltrunc</code> is not a standard function. It seems defined in <a href=""http://www.users.pjwstk.edu.pl/~jms/qnx/help/watcom/clibref/qnx/ltrunc.html"" rel=""nofollow"">QNX</a> Platform using qcc as the compiler, which truncates a file at given position. Probably POSIX provides the <code>truncate()</code> and <code>ftruncate()</code> functions for the job. </p>
",0
15555924,15555783,3,"<p><strong>If your <em>problem area</em> is here:</strong></p>

<pre><code>char *person [10] = { '\0' };
char *movie [10] = { '\0' };
char *rating [10] = { '\0' };
</code></pre>

<p>It should be changed to this:</p>

<pre><code>char person [10] = { '\0' };
char movie [10] = { '\0' };
char rating [10] = { '\0' };
</code></pre>

<p>You want an array of characters.  Not an array of pointers.</p>

<p><strong>If your problem area is here:</strong></p>

<pre><code>long int per = atoi(person[10]);
long int mov = atoi(movie[10]);
long int rat = atoi(rating[10]);
</code></pre>

<p>It should be changed to this:</p>

<pre><code>long int per = atoi(person);
long int mov = atoi(movie);
long int rat = atoi(rating);
</code></pre>

<p><code>person</code> is (now) an array of characters - which is what <code>atoi</code> expects.</p>

<p><code>person[10]</code> is (now) a single character, illegally read from past-the-end of your array.</p>

<p><strong>If your problem area is here:</strong></p>

<pre><code>return (similarity);
printf(""\n Similarity is %i\n"", similarity);
</code></pre>

<p>It should be changed to this:</p>

<pre><code>printf(""\n Similarity is %i\n"", similarity);
return (similarity);
</code></pre>

<p>No further code in a function is executed after a <code>return</code>.</p>
",3
15845810,15845809,5,"<p>You are not doing anything wrong. What is wrong is your expectations. </p>

<p>a is the lowest possible possible number that it can generate, but the highest it can generate is not n... n is the range size, so the highest number it can generate is a+n. It is important not just to copy the algorithm and code, but understand why it works. Let's take a look:</p>

<pre><code>return 1000 + ( rand( ) % 1112 );
</code></pre>

<p>What is the range of rand()? Any number between 0 and RAND_MAX (which is a very large number.</p>

<p>What is the range of ( rand() % 1112)? First, look up the modulo operation. What are the possible remainders when you divide positive integers by 1112? It could be 0 (for example, 0/1112), or as high as 1111 1111/1112 has a remainder of 1111) but after that it loops back (1112/1112 has remainder 0, 1113/1112 has a remainder of 1, and so on).</p>

<p>Now, what is the range of 1000 + (any number from 0 to 1111)?</p>
",2
16472134,16472133,5,"<p>This isn't a general solution, but for the stdio functions, look at the ones that start with the letter <code>v</code>, such as <a href=""http://www.cplusplus.com/reference/cstdio/vfprintf/"" rel=""noreferrer""><code>vfprintf</code></a>. They take a <code>va_list</code> as their last parameter, instead of the <code>...</code>. </p>

<pre><code>void my_printf(CtrlT1 c1, Ctrl c2, char* fmt, ...) {
    /* Do stuff with c1 &amp; c2 */
    va_list ap;
    va_start (ap, fmt);
    vfprintf (log, fmt, ap);
    va_end (ap);
}
</code></pre>
",1
18603835,18602691,0,"<p>Learn to write in psuedo-code, this problem appears to be something like:</p>

<pre><code>L1 = length of string1
L2 = length of string2
P  = position in string2 where string1 is inserted

perform edit checks to see that P &lt; L2 and L1 &gt; 0 and L2 &gt; 0
// any other checks??

string3 = allocated new storage for a length of L1 + L2;

for (idx = 0 to idx &lt; POS)
   copy char from string2[idx] to string3[idx]

for (idx = POS to idx &lt; POS + L1
   copy char from string1[idx - POS] to string3[idx]


for (idx = POS + L1 to idx &lt; L1 + L2
   copy char from string2[POS - L1] to string3[idx]

print string3 to debug results
</code></pre>

<p>Not sure if this is the assignment, but modify psuedo-code to correctly reflect the assignment and then write the c code.</p>

<p>Notice, that this psuedo-code is NOT c code, but it can be easily translated into C code.</p>
",0
18603986,18602691,1,"<p>It is just an idea how you can accomplish it with only arrays. It is up to you what you are going to use. Happy studying!</p>

<pre><code>  #include &lt;stdio.h&gt;

  int main(int argc, char ** argv ){

  char s1[] = ""WWW"";
  char s2[] = ""HelloEverybody"";

  printf(""String S1 is: %s\n"", s1);
  printf(""String S2 is: %s\n"", s2);

  int i, j, pos = 3;
  char comb[17];

  for(i = 0; s2[i] != 0; ++i){
  //printf(""Char is: %c\n"", s2[i]);

  if ( i != pos ) {
     comb[i] = s2[i];
  } else {
     for (j = 0; s1[j] != 0; ++j){
        comb[i+pos+j] = s2[pos+j];
        //printf(""Pos + j is: %c\n"", s2[pos+j]);
        comb[pos+j] = s1[j];
     }
     i = 2*pos + j;
     //printf(""Pos + j =%i\n"", i);
     break;
  }

 }

 int t;
 for (t =i; s2[t-pos] !=0; ++t) {
      comb[t] = s2[t-pos];
  }

 printf(""Combined string is %s\n"", comb);

 return 0;

}  
</code></pre>
",0
15801474,15783619,0,"<p>You can use the <code>continue;</code> command as above answers show.
Or try to apply the same logic you with the <code>goto loop1;</code> command, having it above the <code>for</code> loop for <code>k</code></p>
",0
14222220,14222161,3,"<p>The first mistake is here: <code>a = malloc(sizeof(int)*n);</code>. </p>

<p>You have to use <code>int*</code> type instead:
<code>a = malloc(sizeof(int*)*n);</code></p>
",0
14222229,14222161,5,"<p>You need an ampersand in <code>fscanf</code>:</p>

<pre><code>fscanf(fp, ""%d"", &amp;a[i][j]);
                 ^
</code></pre>

<p>A second problem that could catch you is that you're using the wrong <code>sizeof</code> in the first <code>malloc</code>. You want <code>sizeof(int *)</code> instead of <code>sizeof(int)</code>. A simple rule to avoid such issues is to just use:</p>

<pre><code>a = malloc(n * sizeof *a);
</code></pre>
",1
14247830,14247768,2,"<p>In c an assignment operation returns the rvalue which is the value on the right side of the equal sign.  So in this instance c=getchar() returns whatever the character was or EOF.</p>
",1
14247839,14247768,5,"<p>The crucial point is that <code>c</code> must be an <code>int</code>:</p>

<pre><code>int c;

while ((c = getchar()) != EOF) { char read_value = c; /* ... */ }
</code></pre>

<p>It is assumed that an <code>int</code> can hold more values than a <code>char</code>, or at least more values that the system's narrow multibyte encoding uses*, and <code>getchar</code> returns a special constant <code>EOF</code> when there it failed to read more data. Otherwise, it is guaranteed that you can convert <code>c</code> to a <code>char</code> and obtain the value of the character that was read.</p>

<p>It is a common mistake to declare <code>c</code> itself as a <code>char</code>, in which case the loop might never terminate, since you might not be able to capture the special value <code>EOF</code>, or otherwise there would be a perfectly valid character which would be indistinguishable from <code>(char)EOF</code>.</p>

<p><sub>*) For example, it would be perfectly fine if both a <code>char</code> and an <code>int</code> were 32 bits wide on a given platform, as long as, say, the narrow stream could only return units with values in the range [-128, 128), and you could use <code>-200</code> as <code>EOF</code>.</sub></p>
",4
14247901,14247768,1,"<p>Your question was:</p>

<blockquote>
  <p>But what is: <code>((c = getchar()) != EOF)</code> returens ?</p>
</blockquote>

<p>The expression <code>((c = getchar()) != EOF)</code> is a logical (or ""Boolean"") expression - it is either ""true"" or ""false"". Specifically, it tests to see whether something is not equal to the constant ""EOF"".</p>

<p>The ""something"" is the expression <code>(c = getchar())</code>. This is an assignment; it calls the <code>getchar()</code> function and assigns the return value to the variable <code>c</code>. The value of an assignment is the value assigned; therefore, the expression as a whole is causing the following to happen:</p>

<ol>
<li><code>getchar()</code> is called</li>
<li>Its return value is assigned to <code>c</code></li>
<li>That value is then compared to the constant <code>EOF</code></li>
<li>If the value is not equal to <code>EOF</code> then the <code>while</code> statement continues to operate.</li>
</ol>
",1
15862040,15861987,0,"<p>On each line, read (and discard) four characters with <code>getc</code>, then use <code>fscanf</code> to read a number with 4 digits.</p>

<p>I would have simply passed the file through <code>sed</code> first though:</p>

<pre><code>sed 's/^[0-9]{4}\([0-9]{4}\)$/\1/' &lt;file | your_c_program.out
</code></pre>

<p>As a bonus, using <code>sed</code> in this way validates that each line has indeed exactly 8 digits on it.</p>

<p>EDIT: using <code>fseek</code> instead of <code>getc</code> is a better idea indeed</p>
",0
15862125,15861987,0,"<p>This program read the last four numbers on each line (assuming each line has 8) and places it in the variable nr:</p>

<pre><code>int main(void) {
char buff[8];
int nr;
FILE *theFile=fopen(""/home/mppl/Desktop/file"",""r"");

 while(fscanf(theFile,""%s\n"",buff)!=EOF){
    nr= atoi(&amp;buff[4]);
    printf(""nr=%d\n"",nr);

 }

}
</code></pre>

<p>This one might not be the most secure, or most efficient way of doing this but it's simple indeed.</p>
",0
15862278,15861987,1,"<p>Following technique in C can be useful to read a file like I have shown below, Is this what you wants? </p>

<p>while EOF not reach:  </p>

<ul>
<li>first read 4 chars in first buffer, and unused </li>
<li>read number in a line, using <code>fscanf()</code>, <code>%d</code></li>
<li>read <code>\n</code></li>
<li>print number</li>
</ul>

<p>The file is like: </p>

<pre><code>$ cat file
12345678
98765432
45678324
98653223
</code></pre>

<p>And code is (read comments):</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
int main(){
    FILE* fp = fopen(""file"",""r"");
    char first[5];
    int second;
    while(!feof(fp)){          //  While EOF loop runs   
     fgets(first, 5, fp);      //  read first 4 chars in a line
     fscanf(fp,""%d"",&amp;second);  //  Read next 4 digits in 
     fgetc(fp);                //  read \n
     printf(""%d\n"",second);
    }
    return EXIT_SUCCESS;
}
</code></pre>

<p>it runs like:</p>

<pre><code>:~$ ./a.out 
5678
5432
8324
3223
</code></pre>
",6
15862312,15861987,3,"<p>A simple way to do this is to read a line with <code>fgets</code> in a loop and then just run something like this:</p>

<pre><code>sscanf(buf, ""%*4d%4d"", &amp;a);
</code></pre>

<p>This will ignore the first four digits, and copy the last four digits into integer <code>a</code>.</p>

<p>There's obviously no error checking there (it'll only work if there are 8 digits per line), but it's quick and easy. You could check that the return of <code>scanf</code> is 1, which will be the case for a successful 4 digit number read.</p>

<p><strong>Edit</strong> (by @Grijesh Chauhan)</p>

<p>Sample code:</p>

<pre><code>int main(){
    FILE* fp = fopen(""file"",""r"");
    char buf[128];
    int a;
    while(!feof(fp)){             // while end of file comes
      fgets(buf, 127, fp);         //read complete line in a buffer 
      sscanf(buf, ""%*4d%4d"", &amp;a);  //scanf from buffer, last 4 digits
      printf(""%d\n"",a);         
    }
    return EXIT_SUCCESS;
}
</code></pre>

<p>and it executes: </p>

<pre><code>$ gcc y.c -Wall -o y
$ ./y
5678
5432
8324
3223
</code></pre>

<p>for a file: </p>

<pre><code>$ cat file
12345678
98765432
45678324
98653223
</code></pre>
",3
15862352,15861987,0,"<p>It is an interesting question, and I am not a C expert. I just leave my solution.<br> 
Although I am using ""getline"" function in the codes below, I will vote for ""sscanf"".
But ""sscanf"" is often used for taking out particular elements from a string(like numbers divided by slash, backslash or dot), @Toesmash 's question is to read from specific position, which is nothing to do with the content. You got to consider if such a simple task is worth it.<br>So maybe ""getline"" is simple and good enough. That's my thought.</p>

<pre><code>int main()
{
    FILE * fp;
    char * line = NULL;
    size_t len = 0;
    ssize_t read;

    if ((fp = fopen(""sample.txt"", ""r"")) == NULL )
    {
        /* do your error process */
    }

    while((read = getline(&amp;line, &amp;len, fp)) != -1)
    {
        /* you see here offset is 5, if you want the last 4 characters */
        printf(""%s"", (line + (read - 5)));
    }

    return 0;
}
</code></pre>

<p>The good thing is, you got everything you need, the pointer to head, the length, etc.<br>
The bad thing is, I read the whole line, which is maybe unnecessary :)</p>
",0
19321290,19321260,3,"<p>You want to get rid of:</p>

<pre><code>printf(""%c"", text[49]);
</code></pre>

<p>as you have no idea what's at that memory location if the string is less than 49 <code>char</code>s long.</p>
",0
19321327,19321260,8,"<pre><code>char text[50]='\0';
</code></pre>

<p>is not valid.  You could skip initialising <code>text</code> and just declare it</p>

<pre><code>char text[50];
</code></pre>

<p>or you could initialise its first element</p>

<pre><code>char text[50]={'\0'};
</code></pre>

<p>You're also missing an include of <code>stdio.h</code> and should really check that your <code>scanf</code> call read a string and could give it a max length for the string</p>

<pre><code>if (scanf(""%49s"", text) == 1)
</code></pre>
",4
19321554,19321260,1,"<pre><code>int main ()
{
char text[50]={'1','2','3','4'};
printf(""%c"", text[1]);
printf(""%c"",text[0]);
getch();
return 0;
}
</code></pre>

<p>do like this..</p>
",0
19321665,19321260,2,"<p>There is a difference of single quotes and double quotes in C.</p>

<ul>
<li>double quotes means string</li>
<li>single quotes means character </li>
</ul>

<p>Line 3 will not compile because the compiler wants you to assign a string to the array of characters.</p>

<p>You can do</p>

<pre><code>char text[50]=""\0"";
</code></pre>

<p>which in effect fills all the 50 bytes with zeros.</p>

<p>You could also do </p>

<pre><code>char text[50]=""bla"";
</code></pre>

<p>which fills the first 3 bytes with ""bla"" and the rest with zeros. At least my compiler does it like that.</p>

<p>You could also do nothing because you anyway fill it with user input just the next statement.</p>

<pre><code>char text[50];
scanf (""%s"", text);
</code></pre>

<p>But then you have a problem. Because the very next statement will give you random output if the user has entered a string with less than 49 characters. But if you initialize, well then you output the zero byte, which is also quite useless.</p>

<p>The main point however is to learn the different behaviour of C when dealing with an array of characters.</p>
",5
15881203,15881091,5,"<ol>
<li>You do not assign values inside a struct definition</li>
<li>Assuming you are working in a hosted environment (running on a system with an OS), <code>main()</code> should have the standard form (<code>int main(void)</code>) and return an <code>int</code> value</li>
<li>In example one, you didn't assign any memory to your pointer <code>s</code></li>
<li>You have a memory leak in your second example where you didn't free the memory in <code>obj</code></li>
<li>You didn't assign any memory in your second example to <code>pName</code> within <code>struct Foo</code></li>
<li><a href=""http://whatis.techtarget.com/definition/core-dump"" rel=""nofollow"">Core dump</a> means something went very wrong.</li>
</ol>
",8
15881216,15881091,1,"<p>A pointer is declared for the structure, but the pointer is never initialized, no structure is never created.  <code>s</code> is pointing to some random memory space, from whic you attempt to read.</p>

<p>In the second case, you have a pointer <code>pName</code> which has never been allocated memory.  It is also pointing to a random memory space.  You are string copying from the string literal and writing a random memory location.</p>
",0
15881310,15881091,0,"<p>In example 1 you declared a pointer but you have not initialized it. Therefore the pointer points to an unknown location.</p>

<p>In example 2 obj->pname for the same reason points to An Unknown portion of the memory (it was not initialized) and therefore trying to acess it inside strcpy will crash the program.</p>

<p>What you should have done: you should have allocated some memory for the pointers to make them point to memory that belongs to you and not some random (illegal?) portion of memory</p>
",0
15888694,15888672,3,"<p>This usually indicates that the description of the mentioned struct has not yet been encountered, and so you are trying to create a variable of a type the compiler doesn't yet know about.  Likely you are missing a header:</p>

<pre><code>#include &lt;sys/timeb.h&gt;
</code></pre>
",6
20653342,20653194,1,"<p>You code is correct, but you miss an } to close your main function.</p>

<p>You have to declare the specification of your functions out of main function.</p>

<p>es: </p>

<pre><code>/* Forward declarations */
void a();
float b();

/* Main */ 
int main() {
  ...
}

/* Function's specifications */
void a() {
  ...
}

float b() {
   ...
}
</code></pre>
",0
14234278,14234202,0,"<pre><code>scanf(""%s"",&amp;Customerid);
</code></pre>

<p>If <code>CustomerId</code> is <code>int</code> <code>%s</code> expects <code>char *</code></p>
",0
14235117,14234202,1,"<p><strong>Point 1:</strong></p>

<pre><code>scanf(""%s"",&amp;Customerid);
</code></pre>

<p>In above statement, <code>%s</code> is expecting <code>char *</code> but you are passing it the address of <code>char *</code> means <code>char **</code>, so your statement should be..</p>

<pre><code>scanf(""%s"", Customerid);
</code></pre>

<p><strong>Point 2:</strong></p>

<p>use <code>feof</code> before <code>fread</code>, after <code>fread</code>, <code>feof</code> will return <code>1</code> it your case, So statement should be..</p>

<pre><code>while(!feof(ofp) &amp;&amp; fread(&amp;o,sizeof(o),1,ofp)==1)
</code></pre>

<p><strong>Point 3:</strong></p>

<p>Use <code>Break;</code> inside <code>if</code> block as @acraig5075 mentioned..</p>
",0
14234605,14234202,1,"<p>First of all, using <strong>feof()</strong> and <strong>fseek()</strong> upon the same <strong>FILE*</strong> seems not right, as stated by the documentation:</p>

<blockquote>
  <p>[...] A successful call to the  fseek()  function  clears  the
         end-of-file  indicator  for  the  stream  and undoes any effects of the
         ungetc(3) function on the same stream. [...]</p>
</blockquote>

<p>Second to this you should check if you just rode the first entry in the file by something like:</p>

<pre><code>[...]
else
        {
            if(fseek(ofp, -2*sizeof(order), SEEK_CUR) == sizeof(order))
                break; // End the while if we rode ALL the records
        }
[...]
</code></pre>

<p>Anyway I'm really failing to discover why in the world this, as you did say, prints the first and not the last entry...</p>
",0
14234657,14234202,1,"<p>Your code is right, you're just failing to break out of the while loop on the first successfull find. It then continues to find and print all previous orders as well. </p>

<pre><code>if(strcmp(Customerid,o.CustomerID)== 0)
{
  ... // printing
  break; 
}
</code></pre>
",2
18171478,18171442,5,"<p>Another Difference lies when you increment  the pointer, each pointer increment by its corresponding element type.</p>

<pre><code>char *str1;
int *str2;
if you will look at the size of both the pointers lets assume
str1=4 bytes,str2=4 bytes

str1++ will increment by 1 byte but str2++ will increment 4 byte.
Reason: The ++ operator increments the pointer by the size of the pointed type.
</code></pre>
",0
18171654,18171442,1,"<p>The type of a pointer determines what assumption the compiler makes about the size and layout of the pointed-to data. In your example:</p>

<pre><code>char *p3=&amp;a
</code></pre>

<p><code>&amp;a</code> is assumed to hold a <code>char</code> value, and thus be one byte long. This is of course not true, since an <code>int</code> is at least two bytes long (and is usually four bytes long). Now the reason why you still get the value 100 out of it, is because you're most probably running this code on an Intel-compatible CPU, where the bytes are stored in little-endian format. In this format, the least significant bytes are stored first, not last. A four-byte integer with the value 100 is stored like this (hexadecimal notation):</p>

<pre><code>0x64 0x00 0x00 0x00
</code></pre>

<p><code>p3</code> points at the first byte of this sequence. Therefore, the memory pointed to by <code>p3</code> contains a byte with the value 100. If you were to use a value with this layout:</p>

<pre><code>0x00 0x64 0x00 0x00
</code></pre>

<p>Which is 25600:</p>

<pre><code>int a=25600;
</code></pre>

<p>then the value you'll get for <code>*p3</code> is 0, since only the first byte is taken into account.</p>

<p>In addition to that, the value of <code>*(p3+1)</code> is 100, since incrementing a <code>char</code> pointer by one will result in a pointer to the next byte (which has the value 100). This is different from <code>*(p1+1)</code>, which would give you a memory address that that lies four bytes after <code>p1</code>.</p>
",0
18171490,18171442,2,"<p>As pointer, there's basically no difference. The difference is when dereferencing the pointers and assigning values.</p>

<p>Type char is a byte wide type. This means, it can store 8 bits of information. So type char can store numbers from -127 to 126.</p>

<p>Type int is a 4-byte wide type, so it can store 32 bits of information. You can apply the same concept, to see the maximum and minimum values you can store.</p>

<p>You can learn more <a href=""https://en.wikipedia.org/wiki/Integer_%28computer_science%29"" rel=""nofollow"">here</a></p>
",2
15839067,15839037,1,"<p>You did it correctly in your <code>main()</code> function with the variable <code>i</code>, but when you moved it to a function you forgot a symbol. You need to pass the address of <code>j</code> to <code>fscanf()</code>:</p>

<pre><code>fscanf( file, ""%d;%s\n"", &amp;j, a[j] );
</code></pre>
",0
15839139,15839037,1,"<p>First you have to add the <code>&amp;</code> to <code>j</code> in this line</p>

<pre><code>fscanf( file, ""%d;%s\n"", j, a[j] );
</code></pre>

<p>it should be</p>

<pre><code>fscanf( file, ""%d;%s\n"", &amp;j, a[j] );
</code></pre>

<p>also the input array of the function should not contain asterisk <code>*</code></p>

<pre><code>int reader(char b[20], char a[100][100], int *i){
</code></pre>
",1
19432734,19432513,2,"<p>With that function, if your search string sits around 512 byte boundaries in the file, it won't match because you only check inside 512 byte blocks.</p>

<p>To fix this issue, you can load the whole file into memory instead. This also has an advantage on performance if you decide to search multiple times, as you won't have to do I/O every time.</p>

<p>This should work to read a file into memory:</p>

<pre><code>fseek (infile, 0 , SEEK_END);
int filesize = ftell (infile);
rewind (infile);

char *whole_file = malloc(filesize+1);
if (!(filesize == fread(whole_file, filesize, 1, infile))) {
    // ERROR
}
whole_file[filesize] = '\0';
</code></pre>
",10
15542962,15542186,0,"<p>You mixed up your closing <code>}</code>. As a consequence, you only move on to the next edge if the color is <code>WHITE</code>, and stay on the same edge in an infinite loop if the color of <code>u</code> is non-<code>WHITE</code>. The correct form should look like this:</p>

<pre><code>bfs(int s){
  // ¡­
  while (isempty()!=1){
    u=dequeue();
    // ¡­
    while(e!=NULL) {       
      v=e-&gt;vertexIndex;
      if (graph[v].colour==WHITE){
        graph[v].colour=GRAY;
        graph[v].d=graph[u].d+1;
        graph[v].pre=u;

        enqueue(v);
      } // end if WHITE
      e=e-&gt;edgePtr; // update e for all colours!
    } // end loop over all edges e
    graph[u].colour=BLACK;
  } // end loop while queue is not empty
} // end function
</code></pre>
",0
15543503,15543455,1,"<p>Since <code>I</code> is a 2D matrix of structs (and not pointers to structs), there shouldn't be an inner loop.</p>

<p>You also need to do <code>free(I)</code> at the end.</p>

<p>Basically, how you deallocate memory should be a mirror image of how you've allocated it. You have a single <code>malloc()</code> followed by a 1D loop of <code>malloc()</code>s. The mirror image is a 1D loop of <code>free()</code> followed by a single <code>free()</code> at the end.</p>
",0
15852449,15852353,1,"<p>You need to have enough ""scale"" between the runtime and the resolution of your timer code to get accurate and measurable results.  The simplest solution is to iterate hundreds (or thousands) of times over the small piece of code being tested.  </p>

<p>There are possible cache effects of any approach though, so be sure that you're measuring what you actually think you are.</p>
",0
14845869,14845851,4,"<pre><code>while (ta = 'Y')
</code></pre>

<p>should be <code>while (ta == 'Y')</code></p>

<p>so should your if statements be == not =</p>
",3
15569383,15568657,3,"<p>Nobody yet has explained <em>why</em> what you are doing is incorrect, apart from saying that it is ""wrong"".</p>

<p>A string in C is just a bunch of consecutive characters in memory, where the last character in the string has a value of zero.  You can store a string in a <code>char</code> array, or you can point to somewhere in memory by using a <code>char</code> pointer (<code>char*</code>).</p>

<p>When you input a decimal number, you are reading individual characters that happen to be in the range <code>'0'</code> through to <code>'9'</code>, maybe prefixed by an optional <code>'-'</code>.  You read these as a string, and if you want to treat them as integers you need to convert them to an integer data type (instead of a series of <code>char</code> values).</p>

<p>That's where something like <code>atoi</code> helps, although it is no longer fashionable.  You should use <code>strtol</code>.  [There is a whole family of these functions for dealing with <code>unsigned</code>, <code>long long</code>, or combinations thereof, as well as <code>double</code> and <code>float</code> types].</p>

<p>That tackles roughly half of your question.  Now, you are using <code>strcmp</code> and expecting it to work.  There are a couple of things wrong with what you are doing.  The major error is that you can't treat an integer as a string.  If you really want to use string comparison, you have to convert the integer to a string.  That means you do the reverse of what <code>strtol</code> does.</p>

<p>That's a bigger discussion, and in your case it is not the correct way so I won't go into it.  But I'd like to point out that, all things being equal, you are sending the wrong types to <code>strcmp</code>.  It expects two <code>char*</code> pointers (<code>const char *</code>, really).  What you have done is dereferenced your <code>input</code> pointer to a <code>char</code> for the first element, and then pass an <code>int</code> for the second.</p>

<pre><code>strcmp(*input,i[0])
</code></pre>

<p>A pointer is basically just a number.  It gives the memory address of some data.  In this case, the data is expected to be <code>char</code> type (single bytes).  The <code>strcmp</code> function is expecting valid memory addresses (stuff that's actually in your stack or heap).  But what you give it is <code>*input</code> (the value of the first character in your input string) and <code>i[0]</code> (the number <code>1</code>).</p>

<p>Those compiler warnings were telling you something quite important, you know! =)</p>

<p>So, just for completeness (although others have answered this already), you should forget the string comparisons (and make a mental note to learn more about strings in C), and do this:</p>

<pre><code>int value = strtol( input, NULL, 10 );

if( value == i[0] )
   printf(""1 chosen"");
if( value == i[1] )
   printf(""2 chosen"");
</code></pre>

<p>There are other ways to go about this.  I could talk about how to convert single-digit numbers from a string, but I think I have already ranted for long enough.  Hope this is of some help.</p>
",0
15568722,15568657,0,"<p>You need to compare the input string vs. some known strings.  But you're comparing the first character vs. some ints.  <code>strcmp()</code> will do what you need if you pass it the right arguments: two strings.</p>
",0
15568771,15568657,0,"<p>here you are trying to compare a string to an integer using strcmp:</p>

<pre><code>if(strcmp(*input,i[0]) == 0)
</code></pre>

<p>that won't work.</p>

<p>you could do that way:</p>

<pre><code>const char *numbers[2] = {""1"", ""2""};
char input[3];
printf(""Select option:"");
fgets(input,3,stdin);

if(strcmp(*input, numbers[0]) == 0)
    printf(""1 chosen"");
if(strcmp(*input, numbers[1]) == 0)
    printf(""2 chosen"");
</code></pre>

<p>where you compare two strings, instead of comparing a number to a string</p>

<p>or you could convert the input string to an int using sscanf or atoi</p>

<pre><code>int i[2] = {1,2};
char input[3];
int num;

printf(""Select option:"");
fgets(input,3,stdin);

sscanf(input, ""%d"", &amp;num);

if(num == i[0])
   printf(""1 chosen"");
else if(num == i[1]) 
   printf(""2 chosen"");
</code></pre>

<p>i didn't compile them though, maybe there's sth which i am missing but that's the general idea</p>
",1
15568823,15568657,1,"<p>Apart from the various methods listed as answers to your qn.</p>

<p>Why don't you take the user input as int??</p>

<pre><code>#include&lt;stdio.h&gt;

int main()
{

int i[2] = {1,2};
int input;
    printf(""Select option:"");
    scanf(""%d"",&amp;input);

    if(input==i[0])
       printf(""1 chosen"");
    if(input==i[1])
       printf(""2 chosen"");

return 0;

}
</code></pre>
",0
15568880,15568657,0,"<p>Use <code>atoi</code>. it will convert your string to integer</p>

<pre><code> int i[2] = {1,2};
    char input[3];
    printf(""Select option:"");
    fgets(input,3,stdin);

    if(atoi(input)==i[0]))
       printf(""1 chosen"");
    if(atoi(input)==i[1]))
       printf(""2 chosen"");
</code></pre>
",1
15568905,15568657,1,"<p>You must use scanf instead of fgets:</p>

<pre><code>int input;
printf(""Select option:"");
scanf(""%d"", &amp;input);
if (input == i[0])
</code></pre>

<p>etcetera.</p>

<p>See <a href=""http://en.wikibooks.org/wiki/C_Programming/Simple_input_and_output#Input_using_scanf.28.29"" rel=""nofollow"">http://en.wikibooks.org/wiki/C_Programming/Simple_input_and_output#Input_using_scanf.28.29</a></p>
",0
15568954,15568657,0,"<p>Better convert input char to int using atoi function.</p>

<p><a href=""http://www.cplusplus.com/reference/cstdlib/atoi/"" rel=""nofollow"">http://www.cplusplus.com/reference/cstdlib/atoi/</a></p>

<pre><code>int i[2] = {1,2};
char input[3];
int opt=0;
printf(""Select option:"");
fgets(input,3,stdin);
opt = atoi(input); 
if(opt== i[0])
   printf(""1 chosen"");
if(opt == i[1])
   printf(""2 chosen"");
</code></pre>
",0
15867754,15867612,0,"<pre><code>   while((c=getchar())!=EOF)
   {
      if(c &gt;='0' &amp;&amp; c &lt;='9' )
      {
         i = atoi(&amp;c);
         array[array_counter] = i;
         array_counter++;
      }
   }
</code></pre>

<p>This is wrong. You need to put the chars into a buffer, null-terminate it, and then call <code>atoi</code> on the buffer. Or you can use <code>scanf</code> instead of your own loop;</p>

<pre><code>printf (""%d"", array[array_counter]);
</code></pre>

<p>You want ""%d\n"", otherwise the numbers will be smooshed together.</p>

<blockquote>
  <p>the judge says it's wrong answer</p>
</blockquote>

<p>You would know it's the wrong answer if you did some testing before submitting it ... check that the numbers that you're putting into the array have the right values, then check that the output looks right.</p>
",0
15867980,15867612,0,"<p>I found several mistakes in you code so here is the working code with explanations in as comments (see man page of <a href=""http://linux.die.net/man/3/qsort"" rel=""nofollow"">qsort</a>)</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

//first time using qsort function.
int array[1024];
int array_counter=0;

int compare (const void * num1, const void * num2)
{
   return (*(int*)num1 - *(int*)num2);
}

int main ()
{
   int i;
   char c;
   // use '0' terminated string  for passing it to atoi as this is what it is expecting
   // not only a pointer to char
   char buf[2];
   buf[1] = '\0'; // terminate the string with a '0' since you want only to have digits in your buffer
   // you may use something else (scanf for example) to read number of more than one digit)
   while((c=getchar())!=EOF)
   {
      if(c &gt;='0' &amp;&amp; c &lt;='9' )
      {
         // put the char in buf
         buf[0] = c;
         // pass that buf to atoi (even if &amp;c is satisfiying the signature of atoi it is not null terminated)
         i = atoi(buf);
         array[array_counter] = i;
         array_counter++;
      }
   }

   // arguments passed to qsort were wrong (second and third)
   // first is the array (or where the sorting should start)
   // second is the size of one element in the array thus sizof(int)
   // third is the number of the array elements to be sorted
   // the compare function
   qsort(array, sizeof(int), array_counter, compare);

   int counter;
   for(counter = 0; counter &lt; array_counter; counter++)
   {
       // use counter to access array elements not array_counter, array_counter ist the index of the next free element and is always 0
       printf (""%d "", array[counter]);
   }
   return 0;
}
</code></pre>

<p>Sample text file <code>digits.txt</code></p>

<pre><code>2 1 6 4 
</code></pre>

<p>execute command</p>

<pre><code>out.exe &lt; digits.txt
</code></pre>

<p>output</p>

<pre><code>1 2 4 6
</code></pre>
",0
20415064,20414823,1,"<p><code>COPYFILE_MOVE</code> is a flag constant. It doesn't belong in a string. To actually transfer the file's data, you'll also need to set the <code>COPYFILE_DATA</code> flag.</p>

<p>Also, you can leave out the <code>state</code> parameter. <s>(You didn't bother to initialize it anyway.)</s> Just pass <code>NULL</code> instead.</p>

<p>This should work:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;copyfile.h&gt;

int main() {
  int success;
  const char* from = ""hello.text"";
  const char* to = ""/toGo/hello.txt"";
  copyfile_flags_t flags = COPYFILE_MOVE | COPYFILE_DATA;
  success = copyfile(from, to, NULL, flags);
  printf (""%d\n"", success);
  return 0;
}
</code></pre>
",5
16408315,16408258,5,"<p>you did not put <code>break;</code> <em>after</em> each nested switch block.</p>
",1
16408326,16408258,1,"<p>You are missing a <code>break</code> statement at the end of your case block for 'j' and 'n'.</p>

<pre><code>switch(mo[0]){
case 'j':
    switch(mo[2]){
    case 'n':
        switch(mo[1]){
        case 'a':
            m = 1;
            break;
        case 'u':
            m=6;
            break;
        }
        break;
    case 'l':
        m=7;
        break;
    }
    break;
case 'f':
    m=2;
    break;
</code></pre>
",0
16408365,16408258,2,"<p>Consider</p>

<pre><code>const char *months = ""JAN,FEB,MAR,APR,MAY,JUN,JUL,AUG,SEP,OCT,NOV,DEC,"";

const char *find = ""MAY"";

const char *foundAt = strstr(months, find);
if (foundAt != NULL)
{
    if (foundAt[3] == ',')
    {
        printf(""This is month number %d\n"", ((foundAt - months) / 4) + 1);
    }
    else
    {
        /* Not a valid month */
    }
}
else
{
    /* Not a valid month */
}
</code></pre>

<p>Uppercase your input, and you should be able to find valid months by searching the array.
If you found something then look at 3 past that position.  If it is a comma, then what you found is valid.
Calculate the difference between the point found, and the start of the months.  Divide that by 4 to give you a unique number 0 .. N.  Add 1, to get a better looking month number (jan = 1 and so on).</p>

<p>This is a bit easier to read and use than the switch approach.</p>
",1
16408537,16408258,1,"<p>If you don't <em>need</em> to use a switch statement, a quick and easy solution would be as follows. Let's say you have the month value you want to convert thus:</p>

<pre><code>const char* month = ""JUN"";
</code></pre>

<p>The conversion can be done using:</p>

<pre><code>const char* MONTHS = ""JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC"";
int monthNo = ( strstr( MONTHS, month ) - MONTHS ) / 3;
</code></pre>

<p>After this <code>monthNo</code> would equal 5 (i.e months being numbered 0-11) so just add 1 if you need it to be six.</p>
",0
16408558,16408258,1,"<pre><code>short int mesnum(char *mes){
    if((strcmp(mes,""Jan"")==0))
        return 1;
    if((strcmp(mes,""Feb"")==0))
        return 2;
    if((strcmp(mes,""Mar"")==0))
        return 3;
    if((strcmp(mes,""Apr"")==0))
        return 4;
    if((strcmp(mes,""May"")==0))
        return 5;
    if((strcmp(mes,""Jun"")==0))
        return 6;
    if((strcmp(mes,""Jul"")==0))
        return 7;
    if((strcmp(mes,""Aug"")==0))
        return 8;
    if((strcmp(mes,""Sep"")==0))
        return 9;
    if((strcmp(mes,""Oct"")==0))
        return 10;
    if((strcmp(mes,""Nov"")==0))
        return 11;
    if((strcmp(mes,""Dec"")==0))
        return 12;
    return 99;
}
</code></pre>

<p></p>

<pre><code>char* nummes(short int num){
    if(num==1)
        return ""Jan"";
    if(num==2)
        return ""Feb"";
    if(num==3)
        return ""Mar"";
    if(num==4)
        return ""Apr"";
    if(num==5)
        return ""May"";
    if(num==6)
        return ""Jun"";
    if(num==7)
        return ""Jul"";
    if(num==8)
        return ""Aug"";
    if(num==9)
        return ""Sep"";
    if(num==10)
        return ""Oct"";
    if(num==11)
        return ""Nov"";
    if(num==12)
        return ""Dec"";
    return ""???"";
}
</code></pre>
",5
16408806,16408258,0,"<p>@Elazar already have pointed out where's your mistake. It's just  Another way to do:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int monthn(const char *);

int main()
{
  printf(""JAN:%d,jan:%d\n"",monthn(""JAN""),monthn(""jan""));
  return 0;
}

int monthn(const char *name)
{
  const char *months[] = { ""JAN"",""FEB"",""MAR"",""APR"",""MAY"",""JUN"",""JUL"",""AUG"",""SEP"",""OCT"",""NOV"",""DEC"" };
  int i = 0;
  for(i = 0; i &lt; sizeof(months)/sizeof(months[0]); i++) 
    {
      if(strcmp(months[i], name) == 0) 
      return i;
  }
  return -1;
}
</code></pre>

<p>This output:</p>

<pre><code>JAN:0,jan:-1
</code></pre>
",0
19321636,19321600,1,"<p>According to <a href=""http://linux.die.net/man/3/strerror_r"" rel=""nofollow"">http://linux.die.net/man/3/strerror_r</a>, <code>strerror_r</code> can either return a <code>char *</code> or <code>int</code>.  The <code>char *</code> version says it's GNU-specific, so if you're using GNU, maybe that's the problem.</p>
",3
19321649,19321600,2,"<p>Adding</p>

<pre><code>Include &lt;errno.h&gt;
</code></pre>

<p>Should solve the problem</p>

<hr>

<p>Note that the other reason for this error <a href=""http://linux.die.net/man/3/strerror_r"" rel=""nofollow"">According to docs</a> might be that,</p>

<p>it returns <strong>int on XSI-compliant system</strong> and returns <strong>char* on GNU specific system</strong>.</p>
",0
19321713,19321600,2,"<p>This is because by default the GNU version of strerror_r() is used, which has the following signature:</p>

<pre><code>char *strerror_r(int errnum, char *buf, size_t buflen);
</code></pre>

<p>You can try to undefine the <code>_GNU_SOURCE</code> macro in order to get the standard version of this routine. Something like:</p>

<pre><code>#undef _GNU_SOURCE
#include &lt;string.h&gt;
</code></pre>

<p>It might be a good idea to isolate that into its own header file (like <code>xsi_strerror_r.h</code>) so that you can include it only where needed. Or even a wrapper function around strerror_r() so that undefining <code>_GNU_SOURCE</code> will have no other unintended effects. For example:</p>

<pre><code>#ifndef XSI_STRERROR_R
#define XSI_STRERROR_R

#undef _GNU_SOURCE
#include &lt;string.h&gt;

int xsi_strerror_r(int errnum, char *buf, size_t buflen);

#endif
</code></pre>

<p>The above would be a header file (xsi_strerror_r.h). You then provide a simple implementation for xsi_strerror_r() in its own source file:</p>

<pre><code>#include ""xsi_strerror_r.h""
int xsi_strerror_r(int errnum, char *buf, size_t buflen)
{
    return strerror_r(errnum, buf, buflen);
}
</code></pre>

<p>And then you only use xsi_strerror_r() in the rest of your code.</p>
",3
17773152,17772340,0,"<p>Basically you have a set of commands, <code>READ</code>, <code>WRITE</code>, <code>RESET</code> etc. which your program has to recognize and accordingly perform some actions. </p>

<p>You'll need to parse the input by reading each of its parts one by one and depending on user input execute the commands.</p>

<p>Here is a basic set up for doing it:</p>

<pre><code>#include&lt;stdio.h&gt; 
#include&lt;stdlib.h&gt; 
#include&lt;string.h&gt; 


void clear_stdin()
{
    int c;
    while((c = fgetc(stdin)) != '\n' &amp;&amp; c != EOF)
        ;
}

int main(int argc, char** argv)  
{ 
    char buf[64];
    char reg[10];
    unsigned int val = 0;
    int r = 0;

    do{
        printf(""\nEnter a command: "");
        scanf(""%s"", buf);
        if(strcmp(buf, ""WRITE"") == 0) {
            scanf(""%s"", buf); // read away ""REGISTER""
            scanf(""%s"", reg); // read name of REGISTER
            r = scanf(""%x"", &amp;val);
            if(r == 1) {
                printf(""write %i to register %s\n"", val, reg);
            } else {
                scanf(""%s"", buf);
                printf(""input is not valid: %s\n"", buf);
            }
        } else if(strcmp(buf, ""READ"") == 0) {
            // TODO
        } else if(strcmp(buf, ""RESET"") == 0) {
            // TODO
        } else if(strcmp(buf, ""exit"") == 0) {
            break;
        } else {
            printf(""Unknown command: %s\n"", buf);
        }
        clear_stdin();
    } while(1);

    printf(""Bye!\n"");

    return 0;  
} 
</code></pre>

<p><strong>Sample input</strong> </p>

<pre><code>WRITE REGISTER A 0xFF
</code></pre>

<p><strong>Output</strong></p>

<pre><code>write 255 to register A
</code></pre>

<p>You may use <code>scanf(""%s"", buf);</code> and pass <code>buf</code> to <a href=""http://linux.die.net/man/3/strtol"" rel=""nofollow"">strtol</a> instead of <code>scanf(""%x"", &amp;val)</code> for converting a hex number from string to long.</p>
",2
17773305,17772340,3,"<p>I suggest avoiding <code>scanf()</code> at all costs, and using <code>strtok()</code> or similar:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

#define MAXSIZE 1000

int main(void) {
    char buffer[MAXSIZE];
    char * token;
    int n = 1;

    puts(""Enter your command:"");
    if ( fgets(buffer, MAXSIZE, stdin) == NULL ) {
        fputs(""Error getting input"", stderr);
        return EXIT_FAILURE;
    }

    token = strtok(buffer, "" "");
    while ( token ) {
        printf(""Token %d is %s\n"", n++, token);
        token = strtok(NULL, "" "");
    }

    return EXIT_SUCCESS;
}
</code></pre>

<p>Obviously you'll want to process the individual tokens in some way, or store them for later processing. You can <code>strcmp()</code> the individual tokens to check whether you have a 'WRITE', or a 'REGISTER', or whatever, and then turn the last one into a number with <code>strtol()</code>.</p>

<p>Here's a full working example, a simple left-to-right parse is often not appropriate, but it'll demonstrate a working technique (EDIT: added some better error handling):</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

#define MAXSIZE 1000

static long register_a = 0;
static long register_b = 0;
static const char * token_delims = "" \r\n\t"";

static void inst_write(void);
static void inst_write_register(void);
static void inst_write_register_n(long * p_register);
static void error_quit(const char * msg);

int main(void) {
    char buffer[MAXSIZE];
    char * token;

    /* Get input */

    puts(""Enter your command:"");
    if ( fgets(buffer, MAXSIZE, stdin) == NULL ) {
        error_quit(""couldn't get input"");
    }

    /* Tokenize and parse first token */

    token = strtok(buffer, token_delims);
    if ( token == NULL ) {
        error_quit(""no instruction specified"");
    }
    else if ( strcmp(token, ""WRITE"") == 0 ) {
        inst_write();
    }
    else if ( strcmp(token, ""READ"") == 0 ) {

        /* Check for other instructions like this */
    }
    else {
        error_quit(""unrecognized instruction"");
    }

    /* Output register contents */

    printf(""Register A contains: %ld\n"", register_a);
    printf(""Register B contains: %ld\n"", register_b);

    return EXIT_SUCCESS;
}

/* Processes a WRITE instruction */

void inst_write(void) {
    char * token = strtok(NULL, token_delims);

    if ( token == NULL ) {
        error_quit(""missing WRITE operand"");
    }
    else if ( strcmp(token, ""REGISTER"") == 0 ) {
        inst_write_register();
    }
    else if ( strcmp(token, ""MEMLOC"") == 0 ) {

        /* Check for other things to which to write */

    }
    else {
        error_quit(""unrecognized WRITE operand"");
    }
}

/* Processes a WRITE REGISTER instruction */

void inst_write_register(void) {
    char * token = strtok(NULL, token_delims);

    if ( token == NULL ) {
        error_quit(""missing WRITE REGISTER operand"");
    }
    else if ( strcmp(token, ""A"") == 0 ) {
        inst_write_register_n(&amp;register_a);
    }
    else if ( strcmp(token, ""B"") == 0 ) {

        /* Check for other registers to which to write */

        inst_write_register_n(&amp;register_b);
    }
    else {
        error_quit(""unrecognized register"");
    }
}

/* Processes the operand of a WRITE REGISTER [X] instruction, and
 * stores it in the appropriate register.
 *
 * Arguments:
 *   p_register -- pointer to the register in which to store
 */

void inst_write_register_n(long * p_register) {
    char * token = strtok(NULL, token_delims);

    if ( token == NULL ) {
        error_quit(""missing WRITE REGISTER [X] operand"");
    }
    else {
        char * endptr;
        long n = strtol(token, &amp;endptr, 16);

        if ( endptr == token ) {
            error_quit(""WRITE REGISTER [X] operand should be a hex integer"");
        }
        else {
            *p_register = n;
        }
    }
}

/* General error handler, prints the supplied message and exit()s */

void error_quit(const char * msg) {
    fprintf(stderr, ""Error: %s\n"", msg);
    exit(EXIT_FAILURE);
}
</code></pre>
",7
17824652,17824479,3,"<p>When the program enters a <code>switch</code> statement, it will try to match the controlling expression with each <code>case</code> and execute the code after <code>case</code> if it matches, execute the code after <code>default</code> if none matches. If it reaches a <code>break</code>, the program will exit the whole <code>switch</code> statement.</p>

<p>In your code, every <code>case</code> and <code>default</code> is followed by <code>break</code>, so the code at the end of <code>switch</code> will never be executed. </p>

<p>Your code is a little messy, maybe this is clearer: in this example, the two <code>printf</code> will never be executed no matter what value <code>key</code> holds.</p>

<pre><code>#include &lt;stdio.h&gt;
int main (void)
{
    char key = 'c';// key can be any character
    switch(key)
    {
        printf(""something\n""); // will never execute
        case 'a':
            break;
        case 'b':
            break;
        default:
            break;
        printf(""something\n""); // will never execute
    }
    return 0;
}
</code></pre>
",0
15870622,15870494,1,"<p><code>&lt;fstream.h&gt;</code> and <code>&lt;iostream.h&gt;</code> don't exist in C. They're old-style C++ headers. Don't use them if you're using C.</p>

<p>All you need is the <code>fscanf</code> function, part of <code>&lt;stdio.h&gt;</code>. Something like:</p>

<pre><code>fscanf(fp, ""%llu"", &amp;amt);
</code></pre>

<p>The <code>%u</code> formatter (or any other number-reading formatter) will eat any line ends, tabs, spaces, and other whitespace that precedes the number.</p>
",6
15867795,15867712,1,"<p>Here's a solution:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

void H(float *suma, int k)
{
    int i,j;
    char str[200]  = """";
    for(j=0; j&lt;k; j++)
    {
        sprintf(str, ""%.2f"", suma[j]);

        for(i=0;i&lt;strlen(str);i++)
        {
            printf(""%c"", str[i]);
        }
        printf(""\n"");
    }
}

int main ()
{
    float b[]={123.432,213.432,12.2,31.3,13.4};
    H(b,5);
    system(""pause"");
    return 0;
}
</code></pre>
",1
15867809,15867712,1,"<p>If you want to print the list of all array numbers in their string format here is the solution (I have assumed k is the length of float array):</p>

<pre><code>void H(float *suma, int k){
    int i=0, j;
    char str[200]  = """";

    for(j=0;j&lt;k;j++){
        sprintf(str, ""%.2f"", *(suma+j));
        for(i=0;str[i]!='\0';i++) {
            printf(""%c\n"", str[i]);
        }
    }
}
</code></pre>

<p>You can use strcat() to concatenate strings if you want all of them in a single string.</p>
",2
15869055,15868989,3,"<p>In your <em>if</em> statement you are comparing a <em>char</em> (I am supposing that pom is a char) with an <em>int</em>.The ASCII code of '1' is the integer numer 49, and not 1. You can do:</p>

<pre><code>if (pom[j] == (x + 48))
</code></pre>

<p>An alternative way is to declare:</p>

<pre><code>char X = '0';
</code></pre>

<p>Read the <a href=""http://www.asciitable.com/"" rel=""nofollow"">ASCII table</a></p>
",4
15835375,15835300,6,"<ol>
<li><p>Your array size is <code>8</code>, but you access index <code>8</code>, which is one past the end of your array. Count the number of elements if you don't understand...</p></li>
<li><p>You call <code>free</code> on the assigned string constants. Don't do this. Only <code>free</code> what you <code>malloc</code>, which is just <code>array</code>, not <code>array[0]</code> to <code>array[8]</code>.</p></li>
</ol>
",0
15835449,15835300,0,"<p>When you put a literal string in C++ like <code>""test0""</code>, it is actually stored in a special memory location where it cannot be modified. In the line</p>

<pre><code>(*array)[0] = ""test0"";
</code></pre>

<p>you're pointing your <code>char*</code> to that memory location, which is alright to do. However, later, when you call <code>free(array[i]);</code>, you are attempting to free the same memory, which is a no-no. In general, only use <code>free()</code> if you have previously used <code>malloc()</code> on the same variable.</p>

<p>Also, as others have said, you need to allocate an array of size 9, since you're using 9 elements.</p>
",0
14825198,14805968,1,"<p>When a program is running if you press Ctrl-c a signal is sent to abort the program and the program is aborted. However, if you want to use Ctrl-c as an input but not abort the program write one signal handler which catches the signal when you press Ctrl-c and perform the action you wanted to. </p>
",0
16421199,16420050,1,"<blockquote>
  <p>Though it can be applied to any matrix with non-zero elements on the diagonals, convergence is only guaranteed if the matrix is either diagonally dominant, or symmetric and positive definite.</p>
</blockquote>

<p>as it is stated <a href=""http://en.wikipedia.org/wiki/Gauss%E2%80%93Seidel_method"" rel=""nofollow"">in the wikipedia article</a>.</p>

<p>Your example matrix isn't, so it mustn't come as a too big surprise that the method doesn't converge.</p>

<p>If you reorder the equations, move the first equation last (then the coefficient matrix becomes diagonally dominant), it quickly converges to the approximate solution</p>

<pre><code>x[0]=0.500006
x[1]=0.333334
x[2]=0.250001
</code></pre>

<p>(the exact solution is <code>(1/2, 1/3, 1/4)</code>).</p>

<p>What happens is:</p>

<ol>
<li><p>round:</p>

<ul>
<li>first, <code>x[0]</code> gets a negative value (<code>-0.972/1.876</code>),</li>
<li>next, the sum for the second row becomes negative, and <code>x[1]</code> gets a too large value,</li>
<li>then, to compensate for the too large value of <code>x[1]</code>, <code>x[2]</code> gets a negative value too.</li>
</ul></li>
<li><p>round:</p>

<ul>
<li>the sum <code>x[1]*a[0][1] + x[2]*a[0][2]</code> is positive, since both <code>x[2]</code> and <code>a[0][2]</code> are negative, and <code>x[1]</code> and <code>a[0][1]</code> are positive. Thus <code>x[0]</code> gets an even smaller negative value than in the first round,</li>
<li>then <code>x[0]*a[1][0] + x[2]*a[1][2]</code> is negative, and the value of <code>x[1]</code> becomes larger to compensate,</li>
<li>then the value of <code>x[2]</code> becomes a smaller negative value to compensate</li>
</ul></li>
<li><p>and further rounds: see round 2.</p></li>
</ol>

<p>After some time, you get infinities and NaNs.</p>
",2
15868066,15867700,1,"<p>Your function pointer typedefs all take/return <code>TElem</code> types, which means <code>void *</code>.  You're declaring functions that take/return <code>transaction *</code> types.  That makes the function pointers you make from those functions incompatible with the typedefs you created:</p>

<pre><code>      transaction *(*)(transaction *) != TElem (*)(TElem)
int (*)(transaction *, transaction *) != int (*)(TElem, TElem)
              void (*)(transaction *) != void (*)(TElem)
</code></pre>

<p>You may be getting confused because in C, conversions between <code>void *</code> and other pointer types are implicit.  However, conversions between function pointer types, one of which takes <code>void *</code> parameters and one that doesn't, are not.</p>

<p>To fix it, you need to rewrite <code>cpyT</code>, <code>delT</code>, and <code>cmpTrans</code> to use the matching signatures:</p>

<pre><code>TElem cpyT(TElem t);
void delT(TElem t);
int cmpTrans(TElem s1, TElem s2);
</code></pre>

<p>Alternatively you can force things through by typecasting when you call <code>create</code>:</p>

<pre><code>repo-&gt;TList = create((CmpFun)cmpTrans, (CpyFun)cpyT, (DelFun)delT);
</code></pre>
",0
16452526,16452101,1,"<p>Since you want to support floating point numbers, make <code>avg</code> a <code>float</code>, get the input string with <code>fgets</code>, and parse it with <code>sscanf</code>:</p>

<pre><code>#import &lt;stdio.h&gt;
#define MAXBUFFER 64

//... 

float value;
char input[MAXBUFFER];

fgets(input, sizeof(input), stdin);

if (sscanf(input, ""+ %f"", &amp;value) == 1) avg += value;
if (sscanf(input, ""* %f"", &amp;value) == 1) avg *= value;

//...
</code></pre>
",1
17098450,17098436,7,"<p>You're currently returning a single <code>char</code>, not a pointer to a row.  Take off the <code>[0]</code>:</p>

<pre><code>char *front(struct queue *pq)
{
    return pq-&gt;itens[pq-&gt;front+1];
}
</code></pre>
",1
17098465,17098436,5,"<p>You are accessing the char and not using its address. Use:</p>

<pre><code>&amp;(pq-&gt;itens[pq-&gt;front+1][0])
</code></pre>

<p>Note that the outer parens are optional.</p>
",4
16388129,16388082,1,"<p>well knowing format and offsets should be trivial to get data out and place them in the structs using fread() so that you get binary data out of the file </p>

<p>then you need some sort of library if you want to play what you got out, but if you want to play sound I advice you to use a well tested codec library like libavcodec</p>

<p>P.S. you of course need to open the file first with fopen()</p>
",0
16388705,16388082,1,"<p>Your question seems to be ""I have a file format, how can I write a dissector for it in C"". Given that you've stated that you don't know how to use <code>fread()</code>, my advice would be to look for a library that does it for you, such as libavcodec as mentioned by Filippo Savi. Otherwise, the question is too broad to be a fit for this site.</p>

<p>Writing a function to read in a file of known format is basically a lot of slog work. You have the file, which is a stream of bytes, you have the documentation, indicating, from the first byte on, exactly what you'll find, and how many bytes each thing holds. The work, then, involves reading everything in, one chunk at a time, and putting it into the appropriate place in your in-memory structure. (Or, if you really know what you're doing and are only interested in subsections, you can often use the knowledge of structure to read sizes and indexes, and then jump straight to some item in the middle that you want.)</p>

<p>The <a href=""http://pubs.opengroup.org/onlinepubs/009696899/functions/fread.html"" rel=""nofollow"">fread()</a> function can be used to read things in one object at a time, or to read in a large chunk of data and process that in memory. The <code>fread()</code> function call looks like this: <code>fread(ptr, size, count, in)</code>, so if you had a file handle named <code>input</code>, obtained by calling, for example, <code>FILE *input = fopen(""input.wav"", ""rb"");</code>, and you have a buffer called <code>ptr</code>, obtained, for example, by <code>char *ptr = malloc(4096);</code>, you could read the first three 4-byte elements of the file (which, according to the document you linked, are a signature, a size calculation, and another signature,) by calling <code>fread(ptr, 4, 3, input)</code>. (You could also achieve the same goal by calling <code>fread(ptr, 12, 1, input);</code>, or <code>fread(ptr, 1, 12, input);</code>.)</p>

<p>This example <em>might</em> be enough to get you started, but if it isn't, then your question is ""how do I do general file I/O and/or data manipulation in C"", which I don't intend to try to answer. Sorry.</p>
",1
20403466,20394255,4,"<p>To print a <code>char</code>, use:</p>

<pre><code>fputc(c, stream)
</code></pre>

<p>(If the stream is <code>stdout</code>, you can use <code>putchar(c)</code>.)</p>

<p>To print an <code>int</code>:</p>

<ul>
<li>If the <code>int</code> is negative, print ¡°-¡±.</li>
<li>Calculate the individual digits of the integer. This can be done either by calculating the digits from least significant to most significant and saving them in a buffer to be printed in reverse order or by figuring out where the most significant digit is and then calculating the digits from most significant to least significant. You can use a remainder operation, such as <code>x % 10</code>, to calculate the least significant digit of a number, and you can use division, such as <code>x / 10</code>, to remove that digit.</li>
<li>One caveat is that, if the original number is negative, you have to be careful about calculating its digits. The <code>%</code> operator will return negative values. Some people attempt to deal with this by negating the integer if it is negative. However, if the number is the least possible <code>int</code>, this may overflow. E.g., in many C implementations, the least <code>int</code> value is -2,147,483,648, but it cannot be negated because the greatest <code>int</code> is 2,147,483,647.</li>
<li>Any digit in numeric form (0 to 10) can be converted to a character (¡°0¡± to ¡°9¡±) by adding <code>'0'</code>, such as <code>int d = x % 10; char c = d + '0';</code>. The C standard guarantees that this produces the appropriate character in <code>c</code>.</li>
<li>After you obtain the characters from the digits, print them.</li>
</ul>

<p>To print a <code>float</code> or <code>double</code>:</p>

<ul>
<li>Doing this completely correctly is hard, although it is a solved problem. The classic reference for it is <a href=""http://ampl.com/REFS/rounding.pdf"" rel=""nofollow""><i>Correctly Rounded Binary-Decimal and Decimal-Binary Conversions</i> by David M. Gay</a>.</li>
<li>If you just want a simple implementation suitable for a learning exercise, then you can format a floating-point value much as you would an integer: Calculate the digits individually. You also need to decide whether to print a fixed-point notation or a scientific notation (or other).</li>
<li>To print a fixed-point notation, print the integer part of the value as above, for integer types. Then print a ¡°.¡± and some digits for the fractional part of the value.</li>
<li>To print a scientific notation, calculate the value of the exponent part (e.g., to express 12345789 as ¡°1.23456789e7¡±, the exponent is 7, for 10<sup>7</sup>. Divide the value by 10 raised to the power of that exponent and print the resulting value as a fixed-point number (so, in this example, you print ¡°1.23456789¡±), then print ¡°e¡±, the print the exponent part.</li>
<li>Floating-point rounding errors will occur in the above, making it suitable only for a learning exercise, not for use in a quality product.</li>
</ul>

<p>The above should suffice to get you started. It is not complete code, obviously.</p>
",1
14745699,14745496,2,"<p>This is a bad question, probably belongs on Math site anyway.  But here's a thought for you:</p>

<p>First 100! = 100 * 99!</p>

<p>99! = 99 * 98! and so forth until
1! = 1, and 0! = 1.</p>

<p>You want to know how many trailing 0's are in N! (at least that is how I understand the question).</p>

<p>Think of how many are in 10!</p>

<pre><code>10! = 3628800
</code></pre>

<p>so there are two.  The reason why is because only 2*5 = a number with a trailing 0 along with 10.  So we have a total of 2.  (5*4 has a trailing 0 but 4 is a multiple of 2, and besides, we only get to multiply individual numbers once)</p>

<p>It is a good bet, then, that 20! has 4 (it does).</p>

<p>It's now your job to prove (or disprove) that this pattern will hold, and then come up with a way to code it.</p>
",2
14745749,14745496,3,"<p>The number of trailing zeros in n! is the number of factors of 5 in the sequence 1, 2, ..., n. This is because a trailing zeros is the number of factors of 10 in the result, and 10 has a prime factorisation of 5 x 2. There's always more factors of 2 than 5, so the number of 5's gives the result.</p>

<p>The number of factors of 5 is... <code>[n/5] + [n/25] + ... + [n/(5^k)] + ...</code> where <code>[ ]</code> means round down (<em>floor</em>).</p>

<p>What should the code look like to compute this? Something like this perhaps.</p>

<pre><code>int trailing_factorial_zeros(int n) {
    int result = 0;
    int m5 = 5;
    while (n &gt;= m5) {
        result += n / m5;
        m5 *= 5;
    }
    return result;
}
</code></pre>
",0
18171313,18171288,1,"<p>But every machine has its own <a href=""http://en.wikipedia.org/wiki/Instruction_set"" rel=""nofollow"">instruction set</a></p>
",6
18171316,18171288,2,"<blockquote>
  <p>Doesn't each architecture essentially go through the most basic commands in the same way?</p>
</blockquote>

<p>For the most part. But those basic commands are <a href=""http://en.wikipedia.org/wiki/Instruction_set"" rel=""nofollow"">represented</a> or <a href=""http://en.wikipedia.org/wiki/Application_binary_interface"" rel=""nofollow"">implemented</a> differently. The C compiler is responsible for making sure that the correct representations and implementations are used.</p>
",1
18171319,18171288,2,"<p>Yes, but all these loads and jumps etc. look different on different platforms. Each CPU family has its own command set.</p>

<p>On a higher level, if we have the same hardware but different OSes (such as Linux/Windows), we have different libraries, different executable file formats and so on.</p>

<p>All these are things which must be obeyed by the compiler and the linker.</p>
",0
18171324,18171288,11,"<ol>
<li>Different CPUs have different instruction architectures (e.g., x86 vs ARM).
<ul>
<li>Early Macs used the Motorola 68k architecture; later ones used PowerPC; and still later ones used x86. During each of these transitions, developers had to ship their executables as <a href=""http://en.wikipedia.org/wiki/Fat_binary"" rel=""nofollow"">fat binaries</a>, which would contain object code for both architectures.</li>
</ul></li>
<li>Current x86 CPUs have 32-bit and 64-bit modes.
<ul>
<li>This is why you have 32-bit and 64-bit versions of Windows, Ubuntu, etc.</li>
</ul></li>
<li>Different operating systems provide different system calls, libraries, etc.
<ul>
<li>Different OS <em>versions</em> can provide different system calls, libraries, etc. also (although OS vendors do aim to be backward compatible as much as possible).</li>
</ul></li>
<li>Even on the same operating system, the calling convention is not guaranteed to be the same between different compilers.
<ul>
<li>Even on the same OS, different executable file formats may be in use. For example, on many Unix systems, a.out used to be the format used, but most eventually switched to ELF. During the transition period, libraries had to be provided in both formats.</li>
</ul></li>
</ol>
",0
18171480,18171288,0,"<p>Each try to abstract some features, like every language do, needs to be tuned to the concrete architecture, or create a virtual machine (for each architecture) that can run it.</p>
",0
16457921,16455024,3,"<p>Assume you are using a device with a framebuffer (and have root access):
(taken from this answer: <a href=""https://stackoverflow.com/questions/4996777/paint-pixels-to-screen-via-linux-framebuffer"">Paint Pixels to Screen via Linux FrameBuffer</a>)</p>

<p>Also, as mentioned above, what graphics library you are using will make a lot of difference as this code will only tell you what the framebuffer is set to and not what the GUI code is using. So might not be useful at all. If you are not using X or any other graphics library, then you will probably need to be using the framebuffer, and you can see the rest of the answer for how to do that. (I strongly suggest you use DirectFB this will save you implementing a LOT of code).</p>

<p>Also, you could also use the gl drivers that turn up on most devices (inc. embedded ones) so this will also effect how you do what you require. </p>

<p>Are you using a SOC? Does the manufacturer have there own driver layer? That may work completely different and would probably come with it's own API to handle this.</p>

<p>But anyway, I hope this helps.</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;linux/fb.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/ioctl.h&gt;

int main()
{
    int fbfd = 0;
    struct fb_var_screeninfo vinfo;
    struct fb_fix_screeninfo finfo;
    long int screensize = 0;
    char *fbp = 0;
    int x = 0, y = 0;
    long int location = 0;

    // Open the file for reading and writing
    fbfd = open(""/dev/fb0"", O_RDWR);
    if (fbfd == -1) {
        perror(""Error: cannot open framebuffer device"");
        exit(1);
    }
    printf(""The framebuffer device was opened successfully.\n"");

    // Get fixed screen information
    if (ioctl(fbfd, FBIOGET_FSCREENINFO, &amp;finfo) == -1) {
        perror(""Error reading fixed information"");
        exit(2);
    }

    // Get variable screen information
    if (ioctl(fbfd, FBIOGET_VSCREENINFO, &amp;vinfo) == -1) {
        perror(""Error reading variable information"");
        exit(3);
    }

    printf(""%dx%d, %dbpp\n"", vinfo.xres, vinfo.yres, vinfo.bits_per_pixel);

    // Figure out the size of the screen in bytes
    //
    close(fbfd);
}   
</code></pre>
",0
19372248,19372223,2,"<p>This is (almost) the simplest C/C++ program. (It works for both languages.) It does nothing other than return 0, which signifies successful execution.</p>

<p>It should read </p>

<pre><code>int main(int argc, char **argv)
</code></pre>
",4
15823555,15823502,6,"<pre><code>scanf(""%d"", &amp;missionCode);
</code></pre>

<p>leaves the newline in the buffer, so</p>

<pre><code>scanf(""%[^\n]s"", desc);
</code></pre>

<p>immediately finds one and stops. You can add a space</p>

<pre><code>scanf("" %[^\n]s"", desc);
</code></pre>

<p>to the format to skip initial whitespace.</p>
",2
16397193,16397146,1,"<pre><code>list_second[size] = = list_first[size];
</code></pre>

<p>is undefined behaviour as the allowed indices to <code>list_second</code> and <code>list_first</code> are <code>0</code> to <code>size - 1</code>. So using <code>size</code> as index you try to address the array element behind the last element.</p>

<p>To copy all array members use:</p>

<pre><code>for (size_t sizeCnt = 0; sizeCnt &lt; size, ++ sizeCnt)
{
  list_second[sizeCnt] = list_first[sizeCnt]; 
}
</code></pre>

<p>As a note: To access array elements, as well as to address memory the preferred integer type is <code>size_t</code>, which is defined to be an <code>unsigned</code> type to be wide enough to access the platforms address space.</p>
",0
16397199,16397146,3,"<p>Use <code>memcpy()</code> to copy the arrays:</p>

<pre><code>memcpy(list_second, list_first, sizeof(list_first));
</code></pre>

<p>The current assignment attempt is incorrect as it is accessing beyond the bounds of the array (arrays have zero based indexes, so valid indexes run from <code>0</code> to <code>size - 1</code>) causing undefined behaviour:</p>

<pre><code>list_second[size] = list_first[size];
</code></pre>

<p>Even if it was not, it would only copy one of the elements and is the reason garbage is printed because <code>list_second</code> is uninitialized.</p>
",0
16397287,16397146,0,"<p>change <code>list_second[size] = list_first[size];</code> to <code>memcpy(list_second,list_first,sizeof(list_first));</code> you need to copy an array of structure, not a element. also <code>array[3]</code> means an array of 3 elements. So 2 is the maximum index allowed. <code>array[3]</code> is invalid</p>
",1
16438341,16437747,1,"<p>Well, looking your code, I think there si lot of problems. You probably should read a C/C++ manual before to try programming a 2D simulation.</p>

<ul>
<li>""else if"" must always be part of a ""if"" statment.</li>
<li>Avoid implicit casting, even if in this case is safe: int aa=a; //a is a char</li>
<li>""printf"" and ""scanf"" are C library, for C++ its better to use streams like cout and cin.</li>
<li>Avoid recursion if not necesary: recursion may cause memory problems.</li>
<li>""scanf"" with ""%f"" is for float, in your case, you must use ""%u"" that mean unsigned integer.</li>
</ul>

<p>So your code refactorized in C probably look:</p>

<pre><code>unsigned int getAntNumber()
{
    unsigned int result=0;
    printf(""APLIKASI SIMULASI ANIMASI SEMUT\n\n"");
    printf(""Silahkan inputkan jumlah semut antara 1 - 50 : "");
    while (1!=scanf(""%u"",&amp;input) || input &lt;1 || input &gt;50)
    {
        printf(""---------------------------------------------------\n"");
        printf(""Maaf, jumlah inputan anda tidak berada dalam range.\n"");
        printf(""Silahkan inputkan jumlah semut antara 1 - 50 : "");
    }
    return result;
}
</code></pre>

<p>Edit to allow multiple input tests:</p>

<pre><code>unsigned int getAntNumber()
{
    unsigned int result=0;
    int mustEnd=1; /*C, unlike C++ does not allow bool*/
    printf(""APLIKASI SIMULASI ANIMASI SEMUT\n\n"");
    printf(""Silahkan inputkan jumlah semut antara 1 - 50 : "");
    while ( mustEnd != 0)
    {
        if (1!=scanf(""%u"",&amp;input)) /* Caution, this test must be the first one!*/
        {
            /*Input is not an unsigned integer*/
            printf(""---------------------------------------------------\n"");
            printf(""Maaf, jumlah inputan anda tidak berada dalam range.\n"");
            printf(""Silahkan inputkan jumlah semut antara 1 - 50 : "");
        }
        else if (input &lt;1 || input &gt;50)
        {
            /*Input is out of range*/
            printf(""---------------------------------------------------\n"");
            printf(""Maaf, jumlah inputan anda tidak berada dalam range.\n"");
            printf(""Silahkan inputkan jumlah semut antara 1 - 50 : "");
        }
        /*You may add easily more tests here*/
        else
        {
            mustEnd=true;
        }
    }
    return result;
}
</code></pre>
",2
16438352,16437747,0,"<p>1st problem.</p>

<p>as far as c++ is concerned  </p>

<p>this is wrong</p>

<pre><code>if(input &gt; 50 || input &lt; 1){
    ulang();
}

char a = 'a';    //cant declare between if and else if
int aa=a;
else if(input == aa){
    ulang();
}
</code></pre>

<p>but this can be done</p>

<pre><code>if(input &gt; 50 || input &lt; 1){
    ulang();
}

char a = 'a';
int aa=a;
if(input == aa){  //no else if but only if. But i don't know if this serves the purpose
    ulang();
}
</code></pre>

<p>2nd problem</p>

<pre><code>scanf(""%f"",&amp;input);
</code></pre>

<p>this line is a very obscure to us. if <code>input</code> is a global(file scope) variable of type float then its ok but since you want to input <code>chars</code> you need to have </p>

<pre><code>scanf(""%c"",&amp;blah); 
</code></pre>

<p>because you cant input characters through <code>%f</code> specifier. if you give characters but have <code>%f</code> <code>scanf</code> will fail.</p>

<p>3rd problem : actually i hope you have included <code>&lt;cstdio&gt;</code>. moreover dont use <code>scanf</code> and <code>printf</code>. they belong to the other beast C.</p>
",0
20202216,20202169,4,"<p>No, there are no implicit <code>#include</code> directives.</p>

<p>What you're probably running into is that, prior to the 1999 ISO C standard, C permitted functions to be called with no visible declaration. The compiler would assume that the called function returns <code>int</code> and takes arguments compatible with the (promoted) arguments passed in the call.</p>

<p>gcc by default supports the 1990 ISO C standard plus GNU-specific extensions.</p>

<p>If you compile with something like <code>gcc -std=c99 -pedantic</code>, you'll get warnings about calls to functions with no visible declarations. (Use <code>-std=gnu99</code> if you need GNU-specific extensions as well.)</p>

<p>Calling undeclared functions was a bad idea even before the 1999 standard. You should correct your code so there's a visible declaration (probably via a <code>#include</code> for the appropriate header) for each function you call or otherwise refer to.</p>

<p>Your original question asked about <code>toUppercase</code>, which is not a standard function; it may or may not be defined somewhere else.</p>

<p>Your revised question uses <code>toupper</code>, which is a standard C function declared in <code>&lt;ctype.h&gt;</code> and defined in the standard C library.</p>

<p>It's not surprising that you can get away with calling <code>toupper</code> with no visible declaration -- but you should still add</p>

<pre><code>#include &lt;ctype.h&gt;
</code></pre>

<p>to the top of your source file.</p>

<p>Before you do that, try compiling with <code>gcc -std=c99</code>; you should get a warning.</p>

<p>One more thing: It's important to keep in mind that <em>headers</em> and <em>libraries</em> are two different things.</p>

<p><em>Headers</em>, like <code>&lt;stdio.h&gt;</code> and <code>&lt;stdlib.h&gt;</code> are generally text files containing just <em>declarations</em> of functions and other entities specified by the C standard library.</p>

<p><em>Libraries</em>, which have system-specific names like, for example, <code>libc.so</code>, contain the actual executable code that <em>implements</em> those functions.</p>

<p>Headers are handled by the compiler; libraries are handled by the linker.</p>

<p>There are generally no default headers; every header you use has to be explicitly <code>#include</code>d, either directly or indirectly. <code>libc.so</code> (or whatever it's called) is typically linked by default; you don't have to specify it. (Though for the functions declared in <code>&lt;math.h&gt;</code>, you often have to specify <code>-lm</code> to link the corresponding library.)</p>
",12
16437211,16437158,3,"<p>You need to initialize the random seed to a value representing the current time (calling time) to generate a different value:</p>

<pre><code>/* initialize random seed: */
  srand (time(NULL));
</code></pre>
",0
16437214,16437158,4,"<p>You don't need to shuffle, it's easier to <a href=""http://en.wikipedia.org/wiki/Random_seed"" rel=""nofollow"">seed the random generator</a>.</p>

<p>In C, this is typically done by calling <a href=""http://linux.die.net/man/3/sran"" rel=""nofollow""><code>srand()</code></a> with the current time, like so:</p>

<pre><code>srand(time(NULL));
</code></pre>

<p>Note that there is no logical connection between the random number generator and the time of day; it's just a convenient way of getting a number that is reasonably likely to be different every time you run the program. You can also seed the generator from some different source, if you have one handy.</p>

<p>Also note that your array of random numbers can contain duplicates, unless you add code to filter them out which can be ... annoying.</p>
",0
16437238,16437158,0,"<p><a href=""http://c-faq.com/lib/rand.html"" rel=""nofollow"">See This</a></p>

<p>Hope it helps</p>

<p>Otherwise you could try seeding the rand with the current time.</p>
",1
15849714,15846762,15,"<p>At first glance, it looks like <code>struct timeval</code> contains a time split into two parts:</p>

<ul>
<li><code>tv_usec</code> - microseconds, ideally should always be under 1000000, but greater values seem to be allowed as suggested by the code</li>
<li><code>tv_sec</code> - seconds (the number of multiples of 1000000)</li>
</ul>

<p>and the time in microseconds is <code>tv_usec</code> + <code>tv_sec</code> * 1000000.</p>

<p>Conversely, one would expect this to be true:</p>

<ul>
<li><code>tv_sec</code> = time in microseconds / 1000000</li>
<li><code>tv_usec</code> = time in microseconds % 1000000.</li>
</ul>

<p>The function appears to calculate the time difference between <code>*x</code> and <code>*y</code> (logically, <code>*x</code> - <code>*y</code>) and store it in another <code>struct timeval</code>, <code>*result</code>.</p>

<p>A simple test program gives us some hints:</p>

<pre><code>#include &lt;stdio.h&gt;

struct timeval
{
  long tv_sec;
  long tv_usec;
};

int timeval_subtract(struct timeval *result, struct timeval *x, struct timeval *y)
{  
  // preserve *y
  struct timeval yy = *y;
  y = &amp;yy;

  /* Perform the carry for the later subtraction by updating y. */  
  if (x-&gt;tv_usec &lt; y-&gt;tv_usec) {  
    int nsec = (y-&gt;tv_usec - x-&gt;tv_usec) / 1000000 + 1;  
    y-&gt;tv_usec -= 1000000 * nsec;  
    y-&gt;tv_sec += nsec;  
  }  
  if (x-&gt;tv_usec - y-&gt;tv_usec &gt; 1000000) {  
    int nsec = (y-&gt;tv_usec - x-&gt;tv_usec) / 1000000;  
    y-&gt;tv_usec += 1000000 * nsec;  
    y-&gt;tv_sec -= nsec;  
  }  

  /* Compute the time remaining to wait.
     tv_usec is certainly positive. */  
  result-&gt;tv_sec = x-&gt;tv_sec - y-&gt;tv_sec;  
  result-&gt;tv_usec = x-&gt;tv_usec - y-&gt;tv_usec;  

  /* Return 1 if result is negative. */  
  return x-&gt;tv_sec &lt; y-&gt;tv_sec;  
}

struct timeval testData00 = { 0, 0 };
struct timeval testData01 = { 0, 1 };

int main(void)
{
  struct timeval diff;
  int res;

  res = timeval_subtract(&amp;diff, &amp;testData00, &amp;testData00);
  printf(""%d %ld:%ld\n"", res, diff.tv_sec, diff.tv_usec);

  res = timeval_subtract(&amp;diff, &amp;testData01, &amp;testData01);
  printf(""%d %ld:%ld\n"", res, diff.tv_sec, diff.tv_usec);

  res = timeval_subtract(&amp;diff, &amp;testData01, &amp;testData00);
  printf(""%d %ld:%ld\n"", res, diff.tv_sec, diff.tv_usec);

  res = timeval_subtract(&amp;diff, &amp;testData00, &amp;testData01);
  printf(""%d %ld:%ld\n"", res, diff.tv_sec, diff.tv_usec);

  return 0;
}
</code></pre>

<p>Output (<a href=""http://ideone.com/aZzQsv"" rel=""noreferrer"">ideone</a>):</p>

<pre><code>0 0:0
0 0:0
0 0:1
1 -1:999999
</code></pre>

<p>From the last test result it appears that the function returns (-1):999999 instead of -(0:1). Both values represent the same negative time (or time difference) in microseconds:</p>

<ul>
<li>-1 * 1000000 + 999999 = -1</li>
<li>-(0 * 1000000 + 1) = -1</li>
</ul>

<p>So, how does it really work?</p>

<p>If <code>x-&gt;tv_usec</code> >= <code>y-&gt;tv_usec</code> then only the second <code>if</code> could probably<sup>*</sup> execute:</p>

<pre><code>  if (x-&gt;tv_usec - y-&gt;tv_usec &gt; 1000000) {  
    int nsec = (y-&gt;tv_usec - x-&gt;tv_usec) / 1000000;  
    y-&gt;tv_usec += 1000000 * nsec;  
    y-&gt;tv_sec -= nsec;  
  }  
</code></pre>

<p>This <code>if</code> checks if the difference in the microseconds parts alone is greater than 1 second. If it is, it subtracts the whole seconds of this difference from <code>y-&gt;tv_usec</code> (as microseconds) and adds it to <code>y-&gt;tv_sec</code> (as seconds). This simply redistributes the time in <code>*y</code> without really changing it. You could rewrite this <code>if</code> equivalently like this to see it more clearly:</p>

<pre><code>  if (x-&gt;tv_usec - y-&gt;tv_usec &gt; 1000000) {  
    int nsec = (x-&gt;tv_usec - y-&gt;tv_usec) / 1000000;  
    y-&gt;tv_usec -= 1000000 * nsec;  
    y-&gt;tv_sec += nsec;  
  }  
</code></pre>

<p>One important thing to note here is that when the input <code>*x</code> and <code>*y</code> have their <code>tv_usec</code> in the range from 0 to 999999 inclusive, the body of this <code>if</code> does not execute (hence, <em>probably</em><sup>*</sup> is actually <em>never</em> when <code>x-&gt;tv_usec</code> >= <code>y-&gt;tv_usec</code> and when <code>tv_usecs</code> are in the range from 0 to 999999).</p>

<p>The net effect of this <code>if</code> is not readily clear now.</p>

<p>However, one interesting thing can be seen here. If we call this function with <code>*x</code> = 0:1000001 and <code>*y</code> = 0:0, the result is going to be wrong: <a href=""http://ideone.com/WJDfAk"" rel=""noreferrer"">difference = (-1):2000001 (instead of 1:1) and the return value of the function = 1 (instead of 0)</a>. This suggests that the function isn't really suited for <code>tv_usec &gt; 1000000</code> and even for <code>tv_usec &gt; 999999</code>. And because of this behavior I'm going to claim that the function isn't suited for negative <code>tv_usec</code> in the inputs either. I'm just going to ignore those cases in the face of this behavior. It looks wrong enough already.</p>

<p>Let's look at the first <code>if</code>.</p>

<pre><code>  /* Perform the carry for the later subtraction by updating y. */  
  if (x-&gt;tv_usec &lt; y-&gt;tv_usec) {  
    int nsec = (y-&gt;tv_usec - x-&gt;tv_usec) / 1000000 + 1;  
    y-&gt;tv_usec -= 1000000 * nsec;  
    y-&gt;tv_sec += nsec;  
  }  
</code></pre>

<p>As the comment and the code suggests, when <code>x-&gt;tv_usec</code> &lt; <code>y-&gt;tv_usec</code> we need to take care of the ""carry"" between the ""digits"" as if we were adding and not subtracting. But it's OK, we'll see it.</p>

<p>Let's go back to school for a moment.</p>

<p>How do you do 37 - 12?</p>

<p>You do it like this:</p>

<pre><code>7 - 2 = 5
3 - 1 = 2
</code></pre>

<p>And so 37 - 12 = 25.</p>

<p>Now, how do you do 57 - 38?</p>

<p>You do it like this:</p>

<pre><code>10/*because 7 &lt; 8*/ + 7 - 8 = 9
5 - 3 - 1/*borrow, because of the above*/ = 1
</code></pre>

<p>And so 57 - 38 = 19. See?</p>

<p>And the check:</p>

<pre><code>  if (x-&gt;tv_usec &lt; y-&gt;tv_usec) {  
</code></pre>

<p>checks whether or not we need to take care of this borrowing.</p>

<p>So, what's happening here? Let's look again:</p>

<pre><code>  if (x-&gt;tv_usec &lt; y-&gt;tv_usec) {  
    int nsec = (y-&gt;tv_usec - x-&gt;tv_usec) / 1000000 + 1;  
    y-&gt;tv_usec -= 1000000 * nsec;  
    y-&gt;tv_sec += nsec;  
  }  
</code></pre>

<p>If <code>y-&gt;tv_usec</code> > <code>x-&gt;tv_usec</code>, it calculates the difference between the two in whole seconds and just like the other <code>if</code> it adds these whole seconds to <code>y-&gt;tv_sec</code> and subtracts them from <code>y-&gt;tv_usec</code>, simply redistributing the time in <code>*y</code>, without changing it.</p>

<p>The extra one (<code>+ 1</code>) that ends up added to <code>y-&gt;tv_sec</code> here will be subtracted from <code>x-&gt;tv_sec</code> at the end of the function (<code>result-&gt;tv_sec = x-&gt;tv_sec - y-&gt;tv_sec;</code>) and thus this 1 functions as the borrow I just reminded you of in the 57 - 38 = 19 example.</p>

<p>What else is happening here besides the borrow itself and some time redistribution?</p>

<p>Like I said earlier, I'm just going to ignore negative <code>tv_usecs</code> and greater than 999999 as likely handled incorrectly.</p>

<p>With this I take <code>(y-&gt;tv_usec - x-&gt;tv_usec) / 1000000</code> to be 0 and I am left only with truly meaningful values of <code>tv_usecs</code> (0 to 999999 inclusive).</p>

<p>So, if the <code>if's</code> condition is true, I basically subtract 1000000 from <code>y-&gt;tv_usec</code> and add 1 (the borrow) to <code>y-&gt;tv_sec</code>.</p>

<p>This is the same thing we had in 57 - 38 = 19:</p>

<pre><code>10/*because 7 &lt; 8*/ + 7 - 8 = 9
5 - 3 - 1/*borrow, because of the above*/ = 1
</code></pre>

<p>Similarly to this 10, 1000000 is going to be added later in here: <code>result-&gt;tv_usec = x-&gt;tv_usec - y-&gt;tv_usec;</code></p>

<p>And this first <code>if</code> is the meat of the function.</p>

<p>If I had to write a function with similar behavior, I'd require the input times to be non-negative and the microsecond parts to be no greater than 999999 and I'd write just this:</p>

<pre><code>int timeval_subtract(struct timeval *result, struct timeval *x, struct timeval *y)
{
  result-&gt;tv_sec = x-&gt;tv_sec - y-&gt;tv_sec;

  if ((result-&gt;tv_usec = x-&gt;tv_usec - y-&gt;tv_usec) &lt; 0)
  {
    result-&gt;tv_usec += 1000000;
    result-&gt;tv_sec--; // borrow
  }

  return result-&gt;tv_sec &lt; 0;
}
</code></pre>

<p>If for some odd reason I wanted to support <code>tv_usec</code> > 999999 in the inputs, I'd first move the excess from <code>tv_usec</code> to <code>tv_sec</code> and then do the above, something like this:</p>

<pre><code>int timeval_subtract(struct timeval *result, struct timeval *x, struct timeval *y)
{
  struct timeval xx = *x;
  struct timeval yy = *y;
  x = &amp;xx; y = &amp;yy;

  if (x-&gt;tv_usec &gt; 999999)
  {
    x-&gt;tv_sec += x-&gt;tv_usec / 1000000;
    x-&gt;tv_usec %= 1000000;
  }

  if (y-&gt;tv_usec &gt; 999999)
  {
    y-&gt;tv_sec += y-&gt;tv_usec / 1000000;
    y-&gt;tv_usec %= 1000000;
  }

  result-&gt;tv_sec = x-&gt;tv_sec - y-&gt;tv_sec;

  if ((result-&gt;tv_usec = x-&gt;tv_usec - y-&gt;tv_usec) &lt; 0)
  {
    result-&gt;tv_usec += 1000000;
    result-&gt;tv_sec--; // borrow
  }

  return result-&gt;tv_sec &lt; 0;
}
</code></pre>

<p>Here, the intent is clear and the code is easy to understand.</p>
",4
15868216,15868175,-1,"<p>for question one: you should make the request and after the $.ajax call, do what you wanna to. cause at tha time ajax will be loading(since it's async).</p>

<p>Something like this:</p>

<p>function foo(){
   $.ajax(url, data, callback);
   DoYourStuff();
}</p>

<p>question two: you should use fflush(stdin); to clean the buffer.
Maybe the '\n' key was hold and when you used getchar it was released.</p>
",5
14832211,14832139,4,"<p>Most operating systems have a way to ""set an alarm"" or ""set a timer"", which will call a function of yours at a given time in the future. In linux, you'd use <code>alarm</code>, in Windows you'd use <code>SetTimer</code>. </p>

<p>These functions have restrictions on what you can do in the function that gets called, and you almost certainly will end up with something that has multiple threads in the end anyway - although the thread may not be calling <code>sleep</code>, but some <code>wait_for_event</code> or similar function instead. </p>

<p>Edit: However, using a thread with a thread that contains:</p>

<pre><code>while(1) 
{
   sleep(required_time); 
   function(); 
}
</code></pre>

<p>The problem is solved in a very straight forward way to solve the problem, and makes it very easy to handle. </p>
",1
14832246,14832139,1,"<p>A naive solution would be something like this:</p>

<pre><code>/* Infinite loop */
time_t start_time = time(NULL);
for (;;)
{
    time_t now = time(NULL);

    time_t diff = now - start_time;

    if ((diff % 10) == 0)
    {
        /* Ten seconds has passed */
    }

    if ((diff % 20) == 0)
    {
        /* Twenty seconds has passed */
    }
}
</code></pre>

<p>You might want a flag that tells if the function has been called, or it will be called several times during the single second <code>(diff % 10) == 0</code> is true.</p>
",7
14832264,14832139,1,"<p>Try this:</p>

<pre><code>while(true) {
   if(System.getNanotime % 20 == 0) {
      myFunction();
   } 
}
</code></pre>

<p>This is in Java-Syntax, i didn't program c since more than 5 years, but maybe it helps you :)</p>
",0
14832272,14832139,0,"<p>Simple:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main(int argc, const char** argv)
{
    while(1)
    {
        usleep(20000) ;
        printf(""tick!\n"") ;
    }
}
</code></pre>

<p>Note that usleep() will of course block :)</p>
",3
14832379,14832139,4,"<p>Use <code>libevent</code>, in my opinion, is the cleaner solution because, in the meantime, you can do other operations (even other timed functions)</p>

<p>look at this simple and self explaining example that print out Hello every 3 seconds:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;event.h&gt;

void say_hello(int fd, short event, void *arg)
{
  printf(""Hello\n"");
}

int main(int argc, const char* argv[])
{
  struct event ev;
  struct timeval tv;

  tv.tv_sec = 3;
  tv.tv_usec = 0;

  event_init();
  evtimer_set(&amp;ev, say_hello, NULL);
  evtimer_add(&amp;ev, &amp;tv);
  event_dispatch();

  return 0;
}
</code></pre>
",5
17092474,17092424,13,"<p>If it were not an embedded system, you would probably be correct: I would bet that the programmers were unclear on the concept of the static, and must have meant to write this:</p>

<pre><code>static int foo = 0;
static int bar = 0;
static int baz = 0;
</code></pre>

<p>However, in an embedded system they could have used <code>static</code> to avoid allocating the variables in the automatic storage (i.e. on the stack). This could save a few CPU cycles, because the address of the static variable would be ""baked into"" the binary code of the compiled method.</p>
",4
17092508,17092424,2,"<p>In this context the static memory is allocated only once.  The problem with this code is the initialization.  If it's being reset at every execution, these variables should exist on the stack.</p>
",0
17094902,17092424,0,"<p>Implementing the function as it is, undermines the <code>static</code> benefits. The main 2 reasons for using <code>static</code> are:</p>

<ol>
<li>Having a variable that maintains it's value between calls to the same function</li>
<li>Avoid allocating memory on the stack</li>
</ol>

<p>@dasblinkenlight answer's pertains to the 2nd option, however there is nobody in embedded programming who would waste unrecoverable memory in order to save 24 bytes (assuming that <code>int</code> is 32 bytes on your architecture) on the stack. The reason is that the compiler is going to manipulate the stack pointer coming in to the function regardless, and therefore there is nothing to be save (in terms of cycles) from not having it push the SP another 24 bytes.</p>

<p>Keeping that in mind, we are left with the option that the user wanted to maintain some information regarding <code>foo</code>, <code>bar</code> and <code>baz</code> between calls. If this is also not the case, what you are looking at is bad programming.</p>
",2
17097044,17092424,0,"<p>static benefits.  are:</p>

<p>Having a variable that maintains it's value between calls to the same function
Avoid allocating memory on the stack</p>
",0
17809329,17809086,2,"<pre><code>int *check(register int i,register int j)
{
int *p=i;
int *q=j;
if(i &gt;= 45)
return (p);
else
return (q);
}
</code></pre>

<p>While <code>register</code> storage class specifier is allowed on parameter declaration, parameters <code>i</code> and <code>j</code> have <code>int</code> type while <code>p</code> and <code>q</code> are of type <code>int *</code>. This makes the declaration of <code>p</code> and <code>q</code> invalid.</p>

<p>You cannot just change this to:</p>

<pre><code>int *p=&amp;i;
int *q=&amp;j;
</code></pre>

<p>as the <code>&amp;</code> operator does not allow you to have an operand of <code>register</code> storage class.</p>

<p>You cannot also also change the parameter declaration from <code>register int i</code>  and <code>register int j</code> to <code>int i</code> and <code>int j</code> and then return the address of <code>i</code> and <code>j</code> object as their lifetime ends at the exit of the function.</p>

<p>In your case you should just not use pointers: use <code>int</code> parameters and an <code>int</code> return value.</p>
",5
17809355,17809086,1,"<p>In my machine with GCC 4.7.3 on Ubuntu 13.04, the output is </p>

<pre><code>$gcc test.c
test.c: In function ¡®main¡¯:
test.c:7:3: warning: incompatible implicit declaration of built-in function ¡®printf¡¯ [enabled by default]
test.c:7:3: warning: format ¡®%d¡¯ expects argument of type ¡®int¡¯, but argument 2 has type ¡®int *¡¯ [-Wformat]
test.c: In function ¡®check¡¯:
test.c:13:12: warning: initialization makes pointer from integer without a cast [enabled by default]
test.c:14:12: warning: initialization makes pointer from integer without a cast [enabled by default]
$./a.out
20
</code></pre>

<p>It accepts the program with a lot of warnings. And there is not a single word says ""storage class"". so I wonder what version of GCC you are using?</p>

<p>The first two warnings can be fixed by <code>#include &lt;stdio.h&gt;</code> and change <code>%d</code> in the printf function call to <code>%p</code>. Let's ignore those for now and focus on the rest two. Depends on what you want to do, you can have different options to eliminate them. </p>

<p>If you want to return the address of <code>i</code> or <code>j</code> as a stack based variable (which is unusual because it is invalid after return to the caller), you can do </p>

<pre><code>int *check( int i, int j)
{   
    int *p = &amp;i;
    int *q = &amp;j;
    ...
</code></pre>

<p>You cannot obtain the address of a register variable, so you have to remove them. In this case, with your <code>main</code> function your program will print something like <code>0x7fffc83021f8</code> in my machine. That is the pointer value to the variable <code>j</code>, although it is not valid at the time we prints it, as long as you do not attempt to dereference it everything is OK.</p>

<p>If this is not what you want, you probably want to force the integer <code>i</code> or <code>j</code> to represent a pointer, then you need to do</p>

<pre><code> int *check(register int i,register int j)
 {
    int *p=(int *)i;
    int *q=(int *)j;
    if(i &gt;= 45)
        return (p);
    else
        return (q);
 }
</code></pre>

<p>Note in this case the use of register keyword is OK although it may have very limited effect. Also this would still warn you when you compile the code in some machine (especially 64 bit GCC).</p>

<p>Although strange, but this code have some sense: usually an integer that too close to zero is not a valid pointer.</p>

<p>So what this code does is: it returns <code>i</code>'s value as a pointer if it's a valid pointer(value  greater than 45), or return <code>j</code>s value. The result in this case is <code>0x14</code> (remember we need to replace <code>%d</code> to <code>%p</code>, so the output is in hexadecimal).</p>

<p><em>EDIT</em></p>

<p>After look at your <code>main</code> function I believe what is wanted here would be</p>

<pre><code> int check(register int i,register int j)
 {
    int p=i;
    int q=j;
    if(i &gt;= 45)
        return (p);
    else
        return (q);
 }
</code></pre>

<p>But anyway this code can be simplified as</p>

<pre><code> int check(register int i,register int j)
 {
    if(i &gt;= 45)
        return i;
    else
        return j;
 }
</code></pre>

<p>or even</p>

<pre><code> int check(register int i,register int j)
 {
    return i&gt;=45 ? i : j;
 }
</code></pre>

<p>in these cases the <code>main</code> function should be</p>

<pre><code>int main()
{
    int c;
    c = check(10, 20);
    printf(""%d\n"", c);
    return 0;
}
</code></pre>

<p>Note since the data type of <code>c</code> is now <code>int</code> so the <code>%p</code> for <code>printf</code> is restored back to <code>%d</code>. The output is the same of the original code: <code>20</code>.</p>
",3
17809129,17809086,5,"<pre><code>int *check(register int i,register int j)
{   
    int *p=i;
    int *q=j;
</code></pre>

<p>Type mismatch of <code>p</code> <code>q</code> and <code>i</code> <code>j</code>. Perhaps what you want is :</p>

<pre><code>int *check(int i, int j)
{   
    int *p=&amp;i;
    int *q=&amp;j;
</code></pre>

<p>Correction: Note that <code>register</code> cannot be used with <code>&amp;</code>. Besides, the keyword <code>register</code> has little usage because the compiler usually ignores it and does the optimization itself.</p>
",5
17809154,17809086,2,"<p><strong>First</strong> type mismatch: </p>

<pre><code>int *p=i;
int *q=j;
</code></pre>

<p><strong>Second</strong> side note <code>&amp;</code> not applied/valid  on register variables.</p>

<p>From: <a href=""https://stackoverflow.com/questions/17559774/address-of-register-variable-in-c-and-c"">address of register variable in C and C++</a>    </p>

<p>In C, you cannot take the address of a variable with <code>register</code> storage. Cf. C11 6.7.1/6:</p>

<blockquote>
  <p>A declaration of an identifier for an object with storage-class specifier <code>register</code>
  suggests that access to the object be as fast as possible. The extent to which such
  suggestions are effective is implementation-defined.</p>
</blockquote>

<p><strong>third:</strong> Returning address of local object is Undefined behavior (and parameters of functions counts in local variables). Don't return address of that there life is till function returns. </p>

<p><strong>Suggestion:</strong></p>

<p>To return address, you need to do dynamic allocation and return address of that. for example: </p>

<pre><code>int *check(int i,int j){
    int *p= malloc(sizeof (int));
    int *q= malloc(sizeof (int));
    *p = i;
    *q = j; 
    if(i &gt;= 45){
      free(q);
      return (p);
    }
    else{
      free(p);
      return (q);
   }
}
</code></pre>

<p>Note returned  address is not of <code>i</code>, <code>j</code>, but its address of dynamically allocated memory. Don't forget to call <code>free(a)</code> in <code>main()</code>. </p>
",4
17825456,17809086,0,"<p>OK now I see what you are asking.</p>

<p>If you have a function prototype declaration like this:</p>

<pre><code>int *check(register int, register int);
</code></pre>

<p>As soon as the compiler sees this, it can enforce a rule that no code will attempt to obtain the address of the parameters. It is up to the compiler to consider a consistent way to generate code for function calls through out the program based on this fact. This may or may not be the same as</p>

<pre><code>int *check(int, int);
</code></pre>

<p>Which performs the default treatment of parameters (but again the compiler will ensure it is consistent through out the program).</p>

<p>But consider the following:</p>

<pre><code>int *check(auto int, auto int);
</code></pre>

<p>The compiler do not know weather the address of the parameter is going to be used or not unless it sees the actual implementation. So it cannot assume anything. The programmer obviously want some optimization, but the compiler do not have any further information to do so. </p>

<p>So it does not make sense to specify a parameter to be <code>auto</code>. </p>

<p>What if use <code>auto</code> for parameters of function definition? Again this makes little sense. The compiler can have a strategy that if there is no attempt to obtain the parameter address then treat it as <code>register</code> other use stack for it. But for parameters that do not use <code>auto</code> the rule would be the same. So it does not gives the compiler any further information.</p>

<p>Other storage classes are even makes no sense for parameters in function definition. It is not possible to pass a parameter through static data area or the heap (you can only pass pointers - which actually in the stack or registers).</p>
",0
19889383,19889374,3,"<p><code>scanf(""%d"",&amp;d);</code> to <code>scanf(""%d"",&amp;i);</code> will solve the problem.</p>
",2
14864277,14864202,2,"<p>Well, unmanaged / native programs can pose security risks and probably your antivirus marked this as such. Antiviruses use heuristics - so the algorithms are aproximate, they tend to work on a ""best effort"" idea, and in case of antiviruses ""false positives"" like your sample is preferable to missing actual viruses.  </p>

<p>Another possibility is the way you compiled your program, there are a lot of compiler optimization and some are related to security - so your program randomizes certain parts of the memory etc. Maybe the antivirus looks at how a C program is compiled and yours has no security flags turned on? Hmm...</p>
",4
14864289,14864202,1,"<p>About Generic Detections</p>

<p>Unlike more traditional detections (also known as signatures or single-file detections) a Generic Detection does not identify a unique or individual malicious program. Instead, a Generic Detection looks for broadly applicable code or behavior characteristics that indicate a file as potentially malicious, so that a single Generic Detection can efficiently identify dozens, or even hundreds of malware.</p>

<p>This is a false positive. These sometimes occur in every antivirus product because of the complexity of present-day malware and file compression/protection utilities that are used on both malware and legitimate software.</p>
",1
19874874,19874803,1,"<p><code>letter</code> is of type <code>char</code> which means reading into <code>letter</code> using <code>scanf</code> should be passing by address i.e <code>scanf(""%c"", &amp;letter);</code></p>
",0
19874886,19874803,3,"<p>In C89, variable declarations should be in the beginning of a block. The limit has been removed in C99.</p>

<p>According to your error code, you are using Visual Studio, which doesn't support C99 yet.</p>

<p>So, you should put declarations in the beginning of the function block.</p>

<pre><code>int main(){
    char letter;
    float num1, num2;
    printf(""Choose your calculation operation:7n/tA:Addition/n/tB:Subtraction/n/tC:Multiplacation/n/tD:Division/n/t"");
</code></pre>

<p>One more thing, by <code>/n</code> and <code>/t</code>, you probably mean <code>\n</code> and <code>\t</code>.</p>
",1
16380041,16379943,1,"<p>You know that you can use a pointer as an array? And from that follows that you can use a pointer-to-pointer as an array-of-arrays. And you need two of these, one for each group.</p>

<p>Something like this:</p>

<pre><code>int **arrays[2];  /* Array of two pointer-to-pointers */
</code></pre>

<p>After you read the first two numbers you can then allocate the second-level array:</p>

<pre><code>arrays[0] = malloc(sizeof(int *) * first_number);  /* Allocate for first group */
</code></pre>

<p>Then after you read each line of a group you can then allocate the second level:</p>

<pre><code>arrays[0][i] = malloc(sizeof(int) * size_from_line);
</code></pre>

<p>And finally put into the numbers into the suitable sub-array:</p>

<pre><code>arrays[0][i][j] = some_number;
</code></pre>

<p>Hopefully this should give enough information to implement it.</p>

<p><strong>Note:</strong> If you need to reload this data, don't forget to <code>free</code> all allocated data.</p>
",0
16383000,16379943,1,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int **readGroup(FILE *fp, int rows){
    int **gp, counter = 0;

    gp=malloc(rows*sizeof(int*));
    for(counter = 0; counter &lt; rows ; ++counter){
        int i,data,size;

        fscanf(fp, "" %d"", &amp;size);//size of trailing
        gp[counter] = malloc((size+1)*sizeof(int));//+1 for size
        gp[counter][0] = size;//store size to top
        for(i=1;i&lt;=size;++i){
            fscanf(fp, "" %d"", &amp;data);
            gp[counter][i] = data;
        }
    }
    return gp;
}

int main(void){
    FILE *fp;
    int L,C;
    int **group[2];

    fp = fopen(""data.txt"", ""r"");

    fscanf(fp, "" %d"", &amp;L);
    fscanf(fp, "" %d"", &amp;C);

    group[0] = readGroup(fp, L);
    group[1] = readGroup(fp, C);

    fclose(fp);
    {// check print
        int gp,r,i,size;
        int rows[] = {L, C};
        for(gp=0;gp&lt;2;++gp){
            for(r=0;r&lt;rows[gp];++r){
                int size = group[gp][r][0];
                for(i=1;i&lt;=size;++i)
                    printf(""%d "", group[gp][r][i]);
                printf(""\n"");
            }
            printf(""\n"");
        }
    }
    //deallocate 
    return 0;
}
</code></pre>
",0
15828221,15828115,0,"<blockquote>
  <p>if((k==2)&amp;&amp;(k==1))</p>
</blockquote>

<p>There is no way in todays computers that k can be 2 <strong>and</strong> 1 at the same time. Maybe you meant to say if k is 2 <strong>OR</strong> k is 1 ?</p>
",0
15828235,15828115,0,"<p>You need to reset <code>k</code> back to 0 in your outer loop</p>

<pre><code>printf(""\n\nThe divisors of number :%d are \n"",a);
k = 0;
</code></pre>

<p>(And, as others have pointed out, you need an <code>||</code> operator rather than <code>&amp;&amp;</code> for the final test)</p>
",1
16399523,16398907,2,"<p>So here's my comment as an answer: search for the first digit in each argument. If it's found, replace that argument with a symbol- and number-less copy of the nth arg, else replace it with a symbol- and number-less copy of itself. C99 implementation:</p>

<pre><code>int main(int argc, char *argv[])
{
    char *copies[argc - 1];

    for (int i = 1; i &lt; argc; i++) {
        size_t p = strcspn(argv[i], ""0123456789"");
        int n = argv[i][p] ? argv[i][p] - '0' : i;
        if (n == 0) n = 10;
        char *copyee = argv[n];

        size_t l = strlen(copyee);
        copies[i - 1] = malloc(l + 1);
        char *copy = copies[i - 1];
        for (; *copyee; copyee++) {
            if (isalpha(*copyee)) {
                *copy++ = *copyee;
            }
        }
        *copy = 0;
    }

    for (int i = 0; i &lt; argc - 1; i++) {
        printf(""%s "", copies[i]);
        free(copies[i]);
    }

    printf(""\n"");
    return 0;
}
</code></pre>
",5
16399575,16398907,0,"<pre><code>#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

typedef struct inputcmd {
    char *cmd;
    int index;
}inputcmd;



int main (int argc, char *argv[]){

    struct inputcmd icmd[10] = {0};
    char *newargv[10];
    int i;
    char *p, *s;
    if(argc!=11) {printf(""You should input 10 commands\n""); return;}
    for (i=1; i&lt;11; i++)
    {
        icmd[i-1].cmd = calloc(strlen(argv[i])+1, sizeof(char));
        p=argv[i]; s=icmd[i-1].cmd;
        while(*p) {
            if(isalpha(*p))
                *s++=*p;
            else if ((*p&gt;='0' &amp;&amp; *p&lt;='9') &amp;&amp; icmd[i-1].index==0) {
                if (*p=='0') icmd[i-1].index = 10;
                else icmd[i-1].index = *p - '0';
            }
            p++;
        }
    }
    for (i=0; i&lt;10; i++) {
        if (icmd[i].index) newargv[i] = strdup(icmd[icmd[i].index - 1].cmd);
        else  newargv[i] = strdup(icmd[i].cmd);
    }
    for (i=0; i&lt;10; i++) {
        free(icmd[i].cmd);
    }

    for (i=0; i&lt;10; i++) {
        printf(""%s "",newargv[i]);
    }
    printf(""\n"");
}
</code></pre>

<p><strong>Execution 1</strong>:</p>

<pre><code>$ ./test sda 789 io90 poi 4kl24PP +df_1JK MN BV XC __5555
sda MN XC poi poi sda MN BV XC klPP
</code></pre>

<p><strong>Execution 2</strong>:</p>

<pre><code>$ ./test a2b c2d e2f g2h i2j k2l l2m n2n o2p q2r
cd cd cd cd cd cd cd cd cd cd
</code></pre>
",1
16399598,16398907,0,"<p>H2CO3's is a bit smaller than mine, but here's another quick implementation of your question.</p>

<pre><code>#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main(int argc, char **argv) {
    char **original = argv + 1;
    char *messages[10] = {0};

    if (argc != 11) {
        printf(""We expect 10 arguments.\n"");
        return -1;
    }

    // Allocate space for the copied data.
    for (int i=0; i&lt;10; ++i)
        messages[i] = calloc(sizeof(char), strlen(original[i]) + 1);

    // Let's parse out the parts of the mutable array that we don't want to keep.
    // So kill everything but letters
    for (int i=0; i&lt;10; ++i) {
        int head = 0;
        int tail = 0;

        while (original[i][tail] != '\0') {
            if (isalpha(original[i][tail])) {
                messages[i][head] = original[i][tail];
                head++; tail++;
            } else {
                tail++;
            }
        }
    }

    // Now, let's parse each message, and see what we are supposed to print.
    for (int i=0; i&lt;10; ++i) {
        char *pos = strpbrk(original[i], ""0123456789"");

        if (pos == NULL) {
            printf(""%s "", messages[i]);

        } else {
            int index = *pos - '0';
            if (index == 0)
                index = 10;
            printf(""%s "", messages[index - 1]);
        }
    }

    for (int i=0; i&lt;10; ++i)
        free(messages[i]);

    printf(""\n"");
}
</code></pre>
",3
15852648,15852616,1,"<p>Here is how you can do it:</p>

<pre><code>char mystr[100];
if ( fgets (mystr, 100 , stdin) != NULL ) {
    puts (mystring);
}
</code></pre>

<p>You need to <code>#include &lt;stdio.h&gt;</code> in order for this to compile.</p>

<p>The first pointer must point to a memory block of enough size to fit the number of characters passed in the second pointer.</p>
",1
19508026,19508009,2,"<p>It is <em>never</em>, <strong>ever</strong> okay to over-run the bounds of an array in C. (Or any language really).</p>

<p>If 10 is really passed to that function, that is certainly a bug.  While there are better ways of doing it, that function should at least verify that <code>pos</code> is within the bounds of <code>line</code> before attempting to use it as an index.</p>
",0
19508049,19508009,3,"<p>If <code>pos</code> is indeed <code>10</code> then it would be an out of bounds access and accessing an array out of bounds is <a href=""http://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow"">undefined behavior</a> and therefore anything can happen even a program that appears to work properly at the time, the results are unreliable. The draft C99 standard <code>Annex J.2</code> <em>undefined behavior</em> contains the follows bullet:</p>

<blockquote>
  <p>An array subscript is out of range, even if an object is apparently accessible with the
  given subscript (as in the lvalue expression a[1][7] given the declaration int
  a[4][5]) (6.5.6). </p>
</blockquote>

<p>I don't have a copy of <em>K&amp;R</em> handy but the <a href=""http://cm.bell-labs.com/cm/cs/cbook/2ediffs.html"" rel=""nofollow"">errata</a> does not list anything for this problem. My best guess is the condition should <code>&lt;</code> instead of <code>&gt;=</code>.</p>
",0
19508053,19508009,2,"<p>Code above is fine as long as <code>pos == 9</code>  when its passed to that function . If <code>pos ==10</code> when its passed then its undefined behaviour and .. you are correct , it should be avoided.</p>

<p>However it may or may not give segmentation fault .</p>
",0
15869301,15869272,1,"<p>For one thing, each for loop could be a function that you pass variables to.</p>

<p>Remember DRY.  Don't Repeat Yourself.</p>

<p>I don't know C but the below should be in a function and you pass in decrypted4 and 26 and return the result.</p>

<pre><code>   for (i = 0; data[i] != '\0'; i++)
   {
      convert = data[i] - 'A';
      convert = (convert + 4);
      shiftingLetter = convert % 26;
      decrypted4[i] = 'A' + shiftingLetter;
   }
</code></pre>
",1
15869345,15869272,1,"<p>Here it is:</p>

<pre><code>   int i, j, convert, shiftingLetter;
   char decryptedArr[25][42];

   //Try all possible shifts from 1-25 and store each in an array
   for (j = 0; j &lt; 25; j++)
   for (i = 0; data[i] != '\0'; i++) 
   {
      convert = data[i] - 'A';  //convert letters to equal 0-26 ex:A=0,B=1,C=2,etc
      convert = (convert + i + 1);    //add shift
      shiftingLetter = convert % 26;    //cycle around
      decryptedArr[j][i] = 'A' + shiftingLetter;  //store new letter in array
   }
   decryptedArr[j][i] = '\0';
</code></pre>
",4
16405251,16405182,6,"<p>A <code>100030</code>x<code>100030</code> array of 32-bit ints requires 40GB of RAM. Does your process have access to this much memory?</p>

<p>In all probability, the second <code>malloc</code> is failing. However, your code ignores the failure and carries on regardless.</p>
",0
19206434,19206368,1,"<p>This code, assuming the file (or some other input) has been opened, will continue to get character by character until it finds a newline (\n) or an end of file (eof).</p>

<p>fflush will just clear the stream for an open file.</p>
",0
19206446,19206368,5,"<pre><code>while((c = getchar()) != '\n' &amp;&amp; c != EOF);
</code></pre>

<p>This reads input characters until it reaches either the end of the line (i.e., <code>getchar()</code> returned <code>'\n</code>) or end-of-file or an error condition (i.e., <code>getchar()</code> returned <code>EOF</code>).</p>

<p>If <code>stdin</code> is reading from the keyboard, it discards input until you press Enter.</p>

<p>Leaving off the <code>EOF</code> check could give you an infinite loop if there's an input error, or if you trigger an end-of-file condition (on Unix, by typing <kbd>Ctrl-D</kbd> twice).</p>

<p>This could be useful, for example, after using <code>scanf()</code> to read an integer. If you execute <code>scanf(""%d"", &amp;num);</code> and type <code>123</code>, it will read those 3 digits (and store the value <code>123</code> in <code>n</code>), but leave everything after that waiting to be read. The above line can be used to skip the rest of the input line.</p>

<p>(An alternative, likely a better one, is to read whole lines using <code>fgets()</code> and parse them using <code>sscanf()</code>.)</p>

<p>This is <em>not</em> equivalent to <code>fflush(stdin)</code>. A far as the C standard is concerned, calling <code>fflush</code> on an input stream has undefined behavior.</p>

<p>Some implementations do define the behavior of <code>fflush(stdin)</code>. On systems that use GNU libc, for example (most Linux system):</p>

<blockquote>
  <p>For input streams, <code>fflush()</code> discards any buffered data  that  has 
  been fetched  from  the underlying file, but has not been consumed by
  the application.</p>
</blockquote>

<p>That's not the same as discarding input up to the end of the line. And using it makes your code non-portable.</p>
",0
16912246,16912102,1,"<p>To add to what Ben said: you would solve the emptying the list problem using a copy of <code>p</code>, like this:</p>

<pre><code>struct dsnode *q = p;
while (q != 0)
{
    printf(""%2d "", q-&gt;data);
    q = q-&gt;next;
}
</code></pre>
",0
16912169,16912102,2,"<p>Your code is incomplete, but if <code>p</code> is global then <code>dis()</code> displays <em>and empties</em> the list by modifying <code>p</code>.</p>
",1
17096168,17057330,0,"<p>Other people have already pointed out the bugs in your program, but your question was ""why I am getting the carat-letter combos"", and the answer to that is that the caret-letter combinations are your terminal's representation of various non-printing characters that you are attempting to print (due to the aforementioned bugs).</p>
",3
17077561,17077517,6,"<blockquote>
  <p>I just need a faster method.</p>
</blockquote>

<p>Faster than a compare? No way. Compare will just generate a highly-optimized machine instruction. Don't see how you improve on that.</p>

<p>But, here are some intellectual curiosities for your enjoyment.</p>

<p>Here's one way:</p>

<pre><code>double max = 0.5 * (a + b + fabs(a - b));
</code></pre>

<p>Proof:</p>

<pre><code>a &gt;= b =&gt; a - b &gt;= 0 
       =&gt; |a - b| = a - b 
       =&gt; a + b + |a - b| = a + b + a - b = 2a 
       =&gt; 0.5 * (a + b + |a - b|) = a

a &lt; b =&gt; a - b &lt; 0 
      =&gt; |a - b| = b - a 
      =&gt; a + b + |a - b| = a + b + b - a = 2b 
      =&gt; 0.5 * (a + b + |a - b|) = b
</code></pre>

<p>Note this suffers a weakness: it's can overflow.</p>

<p>Here's another:</p>

<pre><code>double difference = a - b;
double sign = ((int)difference)&gt;&gt;63) &amp; 1;
double max = a - difference * sign;
</code></pre>

<p>It's obvious what the intuition is here. We want to compute the sign of the difference (without using a compare), and use that sign to compute the max.</p>

<p>Proof:</p>

<pre><code>a &gt; b =&gt; a - b &gt;= 0
      =&gt; difference &gt;= 0
      =&gt; sign = 0
      =&gt; max = a - difference * sign = a - (a - b) * 0 = a
      =&gt; max = a

a &lt; b =&gt; a - b &lt; 0
      =&gt; difference &lt; 0
      =&gt; sign = 1
      =&gt; max = a - difference * sign = a - (a - b) * 1 = a - a + b = b
      =&gt; max = b
</code></pre>

<p>Beware, 0 has two possible signs from +0d and -0d, but it doesn't matter! This too, can overflow, though.</p>
",8
17077742,17077517,3,"<p>All modern floating point units on 32 or 64 bit CPUs can produce (at least) one add result per clock cycle, with a latency of a few clock cycles.  A floating point compare has the same performance as a floating point add. Therefore, you cannot speed up a floating point compare by using a combination of other floating point instructions, and using an integer compare fails in the case of NaNs. </p>

<p>If your compiler knows about conditional moves like <code>FCMOVcc</code> on x86, you can get the maximum of two floating point values without using a slow branch instruction.</p>
",1
20627357,20627111,1,"<p>This might almost be what you want:</p>

<pre><code>static gint x,y ;

static void temp1(param..){

  /* TODO what you needed */

  values get changed here for x,y;
}

static void temp2 ( param .......){
  /* accessing the x,y */
}
</code></pre>

<p>x and y are globally accessible, <em>but only within the file,</em> just like your static procedures. I think this is as close as you can get to what you want.</p>
",2
20627886,20627111,0,"<pre><code>static int getInnerStatic(int* _x, int* _y, int ignore);

static void temp1(param..){
    static int x,y ;

    ////////////////
    if (getInnerStatic(&amp;x,&amp;y,1))
        return;
    ////////////////

    #TODO what you needed

    values get changed here for x,y;
}



static int getInnerStatic(int* _x, int* _y, int ignore){
    static int innerInvok = 0;
    static int x, y;

    if (innerInvok == 1){
        x = *_x;
        y = *_y;
        return innerInvok;//1
    }

    if (ignore)
        return innerInvok;//0

    innerInvok = 1;
    temp1(/*anything as param...*/);
    innerInvok = 0;

    *_x = x;
    *_y = y;

    return innerInvok;//0
}

//get static x y :
static void temp2 ( param .......){
    int getX, getY;

    getInnerStatic(&amp;getX, &amp;getY, 0); // &lt;- accessing the x,y
}
</code></pre>
",0
20627748,20627111,0,"<p>You need to understand these 2 things:</p>

<pre><code>Scope
</code></pre>

<p>and </p>

<pre><code>Lifetime
</code></pre>

<p>the scope of your static variables is only <code>inside the function they are declared</code>. they cannot be accessed outside.</p>

<p>but the <code>lifetime of your variables is throughout your program</code>, that is they will retain the values until the program is running.</p>

<p>So maybe you would like to declare your variables outside of your function. so instead of</p>

<pre><code>static void temp1(param..){
        static gint x,y ;

        #TODO what you needed

        values get changed here for x,y;
   }
</code></pre>

<p>you can have</p>

<pre><code> static gint x,y ;
static void temp1(param..){
               #TODO what you needed

        values get changed here for x,y;
   }
</code></pre>

<p>The exact use case you have, i think it would not be possible without changing the second function's arguments.</p>
",0
20628156,20627111,0,"<p>Here is an example of what you are trying to do:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

static void temp1() {
    static int x,y ;
    x = 5;
    y = 8;
}

static void temp2 (){
    cout &lt;&lt; temp1::x &lt;&lt; endl;
}

int main() {
    temp2()
    return 0;
}
</code></pre>

<p><strong>Error message</strong></p>

<pre><code>error: ¡®temp1¡¯ is not a class or namespace
</code></pre>

<p>Note the error that occurs when you try to access x in temp1 by using the scope resolution operator <code>::</code>. Here is how to solve this</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

namespace temp {
    class temp1 {
    public:
        static int x,y;
    };
    int temp1::x = 5;
    int temp1::y = 7;
}

static void temp2 (){
    cout &lt;&lt; temp::temp1::x &lt;&lt; endl;
}

int main() {
    temp2();
    return 0;
}
</code></pre>

<p>Note the namespace is not necessary, but I used it to keep related data together</p>
",0
20628738,20627111,0,"<p>You cant do that with your existing code you need to modify your code to make x and y as static instance variables so that you can access them in all the static methods.</p>
",0
17391403,17391375,6,"<p>To concatenate string in C use <a href=""http://www.cplusplus.com/reference/cstdio/snprintf/"" rel=""nofollow"">snprintf</a></p>

<p>In C strings are representing as a array of chars. Their name is pointer to their first element. Every operation should be done using functions. In other case you simply make pointer arithmetic. So it your example you try to launch function from address that probably doesn't even exist in system.</p>

<p><strong>Do not use <code>strcat</code>! It is dangerous</strong> If you really need simple function to call use <a href=""http://linux.die.net/man/3/strlcat"" rel=""nofollow""><code>strlcat</code></a></p>

<p>For more information you need <a href=""http://www.joelonsoftware.com/articles/fog0000000319.html"" rel=""nofollow"">back to basics</a></p>
",6
17391411,17391375,0,"<p>There is no operator overloading in <code>c</code>. You have to create enough buffer and then use library function <code>strcat</code>.</p>
",2
17391431,17391375,3,"<p>Probably you want to build your command string with a function like <code>snprintf</code>: you have the ability to insert in your string various types (not only strings) and you are safeguarded against buffer overflows (check its return value!).</p>

<pre><code>char buffer[256];
if(snprintf(buffer, sizeof(buffer), ""command %s other stuff %s"", param1, param3)&gt;=sizeof(buffer))
{
   /* the buffer isn't big enough */
}
else
    system(buffer);
</code></pre>
",3
19571496,19571361,1,"<p>Problem is below:-</p>

<pre><code>*aaa = 10;
</code></pre>

<p><code>aaa</code> is a pointer, you can only perform the above after allocating memory to <code>aaa</code> like:</p>

<pre><code>aaa = malloc(sizeof(int)) ;
</code></pre>
",3
19571511,19571361,1,"<pre><code>int *aaa;
*aaa = 10;
</code></pre>

<p>You have defined a pointer to integer, but you have not defined any integer which <code>aaa</code> can point. At this point <code>aaa</code> contains some garbage address, so when you do <code>*aaa = 10</code> you are trying to write at that garbage location. As a result you are getting segmentation fault. </p>

<p>To fix this you need to define an integer like this:</p>

<pre><code>int aaaValue;
int *aaa = &amp;aaaValue;
*aaa = 10;
</code></pre>
",0
19571537,19571361,1,"<p>int *aaa; is not initialised i.e aaa is pointing to some garbage address (may be out of your programe segment) and you are modifying this adders   *aaa = 10;</p>

<p>Don't you need forward ddeclaration to compile this code?</p>
",0
15860424,15860336,0,"<p>Indeed you can't use <code>##</code> like this.</p>

<p>This could work, although very awkward yet:</p>

<pre><code>#define ARG(i) ((i==0)?arg0:(i==1)?arg1:(i==2)?arg2:(i==3)?arg3:(i==4)?arg4:(i==5)?arg5:(i==6)?arg6:(i==7)?arg7:(i==8)?arg8:(i==9)?arg9:0)
</code></pre>
",4
15860537,15860336,2,"<p>I recommend you to use arrays instead of macro in this case. It's much cleaner and don't have a lot of conditions evaluated at runtime;</p>

<pre><code>char **args[10] = { &amp;arg0, &amp;arg1, &amp;arg2, &amp;arg3, &amp;arg4, &amp;arg5, &amp;arg6, &amp;arg7, &amp;arg8, &amp;arg9 };

for( i = 0; i &lt; 10; i++ ) {
    strcpy( argv[i], *args[i] );
}
</code></pre>
",2
15860563,15860336,0,"<p>use BOOST </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;boost/preprocessor.hpp&gt;


#define GEN_DEC(x, i, name) char* BOOST_PP_CAT(name, i);
#define GEN_FUNC(x, i, name) strcpy(argv[i], BOOST_PP_CAT(name, i));

int main(int argc, char* argv[]){
BOOST_PP_REPEAT(10,GEN_DEC,arg)
BOOST_PP_REPEAT(10,GEN_FUNC,arg)

   return 0;
}
</code></pre>

<p>command line
<code>&gt;gcc -I c:\boost_1_48_0 test.c</code></p>

<p>check 
<code>&gt;gcc -I c:\boost_1_48_0 test.c -E</code></p>

<p>output sample</p>

<pre><code>int main(int argc, char* argv[]){
char* arg0; char* arg1; char* arg2; char* arg3; char* arg4; char* arg5; char* ar
g6; char* arg7; char* arg8; char* arg9;
strcpy(argv[0], arg0); strcpy(argv[1], arg1); strcpy(argv[2], arg2); strcpy(argv
[3], arg3); strcpy(argv[4], arg4); strcpy(argv[5], arg5); strcpy(argv[6], arg6);
 strcpy(argv[7], arg7); strcpy(argv[8], arg8); strcpy(argv[9], arg9);

   return 0;
}
</code></pre>
",0
15860361,15860336,2,"<p>Instead of simplifying your sequence of calls to <code>strcpy</code> you should rather convert you variables <code>arg0</code>, <code>arg1</code>, ..., <code>arg9</code> to an array. If you do it, you will be able to do the whole thing in a simple loop.</p>
",1
16927520,16927434,8,"<p>Which way the stack grows has nothing to do with whether the machine is big- or little-endian.  All four combinations are possible, but the overwhelming majority of <em>both</em> big- and little-endian machines have a stack that grows from high to low addresses.</p>

<p>The direction the stack grows in is just a convention, although one that might be baked into the hardware to some extent.  New architectures tend to make the stack grow downward just because that's the most common convention and therefore some programs don't handle the other possibility correctly.  It was originally popular because it avoided having to decide how much space to allocate to the stack (this was on machines with less than 32K of RAM).</p>

<p>Logical vs physical addressing is yet another unrelated property.  Assuming by ""logical"" you mean ""virtual"", the stack grows -- whichever way it grows -- in the virtual address space if virtual memory is engaged, and in the physical address space if it isn't.  Some CPUs let you turn virtual memory off (e.g. x86), some don't (e.g. Alpha).</p>
",6
16929667,16927434,0,"<p>As already answered there is no relation between endianess and memory layout.
There is good info for memory layout of a program here.
<a href=""http://www.inf.udec.cl/~leo/teoX.pdf"" rel=""nofollow"">http://www.inf.udec.cl/~leo/teoX.pdf</a></p>

<p>You can find all about endianess in wiki.
<a href=""https://www.princeton.edu/~achaney/tmve/wiki100k/docs/Endianness.html"" rel=""nofollow"">https://www.princeton.edu/~achaney/tmve/wiki100k/docs/Endianness.html</a></p>
",1
16956283,16956180,1,"<p>Having a <code>static</code> variable at the file scope makes it invisible to the linker at linking time. The compiler doesn't issue a directive that a symbol (named correspondingly to the variable) should be visible to the linker.</p>

<p>Regarding the second question, <code>extern int a</code> is just a declaration. It doesn't reserve any space for that variable, but merely informs the compiler that such a variable exists somewhere. When the unit is later linked, the reference to that variable is resolved by the linker.</p>
",0
16956287,16956180,2,"<ol>
<li><p>Static variables get assigned an address and a size in the memory, but they do not get advertized. So if I have a <code>static int a;</code> in one file and try to refer to it with <code>extern int a;</code> from another file, the &quot;link end&quot; cannot be found, so it just doesn't work.</p>
<p>In order to make <code>extern</code> work, there has to be &quot;something&quot; which advertizes <code>a</code> as available, what <code>static</code> does not do.</p>
</li>
<li><p>No, they don't belong to different processes. They are linked together into one executable file which then gets executed. Different processes normally cannot acces each other's memory.</p>
</li>
</ol>
",0
16956336,16956180,12,"<p>First of all, different processes have different address spaces, as you said. So, unless you share them explicitly (shared memory or the like) they do not share any memory.</p>

<p>About the global static vs. global non-static variables, the difference is called <em>linkage</em>: non-static global variables have <em>external linkage</em>, meaning that they have a name for the linker, and so one compilation unit (.c file) can access the variable defined in another.</p>

<p>A static global variable, however, has internal linkage, and so, although it may be in the same memory block than the former, it has no name for the linker, and so it cannot be used from any other compilation unit than its own.</p>
",0
16390508,16362648,1,"<pre><code>int x;
x = ¡­; // This is okay.
{
    const int y = x; // Make a copy of x.
    {
        const int x = y; // Make a const copy of x that hides the original.
        /*  The compiler should produce a diagnostic if you
            attempt to modify x here.
        */
    }
}
</code></pre>

<p>Or, if you do not want the indenting to change:</p>

<pre><code>int x;
x = ¡­;
{ const int y = x; { const int x = y;
¡­; // x is const here.
} }
</code></pre>
",0
16455199,16455083,0,"<p>if you are using gcc and on linux
thy this method</p>

<p>Read the souce code and write it to a .c file,</p>

<p>using 
<code>system(""gcc file.c"");
system(""./a.out"");</code>
do compilation and execution</p>
",0
16455209,16455083,0,"<p>Can you use bash?</p>

<pre><code>~$ ./progExe &lt; inputFile.txt &gt; newProgram.c &amp;&amp; gcc newProgram.c -Wall &amp;&amp; ./a.out
</code></pre>
",0
16455214,16455083,0,"<pre><code>1 : execute your program
2 : take string from user according to your requirement
3 : create a new file
4 : write string in to file
5 : save file as .java extension
6 : compile the new file
</code></pre>
",0
16388994,16388901,0,"<p>Since the compiler always pads a type to a multiple of 4 bytes (char = 1 byte), your buffers could use that space without any extra cost. And you need it for the terminating <code>'\0'</code> character anyways. What about shortening the definitions, btw?</p>

<pre><code>typedef enum { Blues, HipHop, Jazz, Country, Electronic, Rock, Other} Genre;

typedef struct {
  char title[16];
  double length;
  Genre genre;
}
Song;

typedef struct { 
  char title[21];
  char artist[31];
  Song songs[4];
  int noOfSongs;
}
Album;
</code></pre>

<p>You may of course write <code>typedef struct album { ... } Album;</code> if you need the name <code>struct album</code> too, but I don't see any reason for this in your case. Here are the functions:</p>

<pre><code>void getAlbum(Album *aPtr) {
  printf(""Album: "");
  scanf(""%20s"", aPtr-&gt;title);
  printf(""Artist: "");
  scanf(""%30s"", aPtr-&gt;artist);
  int no = -1;
  while(no &lt; 0 || no &gt; 4) {
    printf(""Tracks: "");
    scanf(""%d"", no);
  }
  aPtr-&gt;noOfSongs = no;
  for(int i = 0; i &lt; no; ++i) getSong(&amp;aPtr-&gt;songs + i);
}

void getSong(Song *sPtr) {
  printf(""Song: "");
  scanf(""%15s"", sPtr-&gt;title);
  double len = -1;
  while(len &lt; 0 || len &gt; 100) {
    printf(""Length: "");
    scanf(""%f"", len);
  }
  char genre[16];
  int genreNo = -1;
  while(genreNo == -1) {
    printf(""Genre: "");
    scanf(""%15s"", genre);
    if(strcmp(genre, ""Blues"") == 0) genreNo = 0;
    else if(strcmp(genre, ""Hip Hop"") == 0) genreNo = 1;
    ...
    else genreNo = 6;
  }
  sPtr-&gt;genre = (Genre)genreNo;
}

void printAlbum(Album *aPtr) {
  printf(""Album: %s\nArtist: %s\n"", aPtr-&gt;title, aPtr-&gt;artist);
  for(int i = 0; i &lt; aPtr-&gt;noOfSongs; ++i) printSong(&amp;aPtr-&gt;songs + i);
}

void printSong(Song *sPtr) {
  printf(""\tSong: %s\n\tLength: %.2f\n\tGenre: "", sPtr-&gt;title, sPtr-&gt;length);
  switch(sPtr-&gt;genre) {
    case Blues: printf(""Blues\n""); break;
    case HipHop: printf(""Hip Hop\n""); break;
    ...
    default:  printf(""Other\n""); break;
  }
}
</code></pre>
",1
16389001,16388901,0,"<p>Implementing a function is actually rather simple. You already got the protoype, so you'll only have to add brackets to have a basic function:</p>

<pre><code>void getAlbum(Album *aPtr) {

}
</code></pre>

<p>Of course, this won't do anything yet, so let's start with a simple prompt:</p>

<pre><code>void getAlbum(Album *aPtr) {
    printf(""Enter the album name: "");
}
</code></pre>

<p>This will now display the text, but it won't ask for the actual text. To do this there are again several different approaches. I'll be using <code>scanf()</code> here, although that one should only be used for testing purposes and (possibly) internal tools, because it can be rather tricky and error prone to use (e.g. if garbage is entered).</p>

<pre><code>void getAlbum(Album *aPtr) {
    printf(""Enter the album name: "");
    scanf(""%19s"", aPtr-&gt;title); // read up to 19 characters as a (s)tring; the 20th will be the terminator ('\0')
}
</code></pre>

<p>There you go. Just expand this to read all the values required. Same for the <code>getSong()</code> function.</p>

<p>Printing everything will then be rather similar, just passing the members as the parameters of a <code>printf()</code> rather than <code>scanf()</code>.</p>
",1
16436867,16435742,0,"<p>Please do the following changes</p>

<ol>
<li><p><code>#include&lt;unistd.h&gt; //for usleep(1);</code></p></li>
<li><p><code>for(t=0 ; t &lt; num_thread; t++)<br>
{<br>
//pass the value of t insted of address<br>
ret = pthread_create(&amp;tid[t], NULL, thread_work, (void *)t);<br>
usleep(1); //sleep is required to maintain the order of thread start;<br>
}</code></p></li>
<li><p><code>int n = (int )t; //insted of int n = *((int *)t);</code>, if you pass address of t in pthread_create, by the time the thread get schedule the value of t will be changed by main thread.</p></li>
<li><p>lock the semaphore, <code>sem_wait(&amp;my_sem)</code> before thread creation loop and unlock (<code>sem_post(&amp;my_sem)</code>) it after thread creation loop in <code>main()</code>.</p></li>
</ol>
",0
16401457,16400565,3,"<p>It's likely inspired by the syntax of Ada's null statement:</p>

<pre><code>while condition loop
    null;
end loop;
</code></pre>

<p>Ada uses the <code>null</code> keyword both for the null pointer constant and for the null statement (and a few other things).</p>

<p>It does have some advantages over C's null statement, which is just a semicolon. In particular, it's much more explicit. A fairly common error in C code is to insert an accidental null statement by adding a semicolon, particularly among inexperienced C programmers who haven't yet worked out where semicolons are necessary and where they aren't:</p>

<pre><code>while (condition);
{
    /* statements */
}
</code></pre>

<p>Without the semicolon, the statements are controlled by the while loop. With it, the body of the while loop is empty, and the loop is likely be infinite if the condition has no side effects.</p>

<p>On the other hand, if you really want a null statement, using just a semicolon can leave the reader wondering if something was unintentionally left out.</p>

<p>In C, <code>NULL</code> is a macro that expands to an implementation-defined null pointer constant. The author is using it here:</p>

<pre><code>while(*pchTo++ = *pchFrom++)
    NULL;
</code></pre>

<p>as a kind of null statement -- which actually works, because an expression followed by a semicolon is a <em>statement expression</em> in which the statement is evaluated for its side effects. Since it has no side effects, it does nothing; it acts just like a real null statement:</p>

<pre><code>while(*pchTo++ = *pchFrom++)
    ;
</code></pre>

<p>Another equivalent form:</p>

<pre><code>while(*pchTo++ = *pchFrom++)
    42;
</code></pre>

<p>In my opinion, this is well intended but a bad idea. It's easily recognizable to those few of us who happen to be familiar with both C and Ada, but most experienced C programmers will look at it and wonder what the heck that null pointer constant is doing there.</p>

<p>It's not <em>quite</em> as bad as defining a set of macros to make C look like another language's syntax:</p>

<pre><code>#define IF if (
#define THEN )
#define BEGIN {
#define END }
#define ELSE } else {
</code></pre>

<p>but it's in the same spirit.</p>

<p>My advice: Don't do this kind of thing. If you want your C code to be easily understandable <em>by readers who know C</em>, write idiomatic C code; don't invent clever tricks to make it look like something else. Null statements can be confusing, leading the reader to wonder if something was left out accidentally. The best solution that, IMHO, is to use a comment:</p>

<pre><code>while(*pchTo++ = *pchFrom++) {
    /* empty body */
}
</code></pre>
",1
16400612,16400565,3,"<p>That loop copies a string.  The <code>NULL</code> is just there to provide a loop body.</p>
",2
16400616,16400565,6,"<p>The author could have written an entirely empty <code>while</code> loop just like you can write a body-less <code>for</code> loop. That would have looked like:</p>

<pre><code>while (*pchTo++ = *pchFrom++);

/* or */

while (*pchTo++ = *pchFrom++)
    ;
</code></pre>

<p>Both of which might look confusing for some people so they added the NULL to give it a body and make it less confusing.</p>

<p><strong>Edit</strong></p>

<p>Note you can do the same with a for loop:</p>

<pre><code>for (head = list-&gt;head; head-&gt;next; head = head-&gt;next);
/* or */
for (head = list-&gt;head; head-&gt;next; head = head-&gt;next)
    ;
/* or */
for (head = list-&gt;head; head-&gt;next; head = head-&gt;next)
    NULL;
</code></pre>

<p>And all that will do is traverse a list by going to the next element while the next element is not <code>NULL</code></p>
",3
16400890,16400565,2,"<p>This construct provides a good way to place a breakpoint when working with a debugger. Some IDEs did not let me place a breakpoint on a loop and I had loops with empty bodies. If you have a statement in your loop body, it is easier to place a breakpoint on it, even if that statement is useless.</p>

<p>Otherwise, as it has already been said, it should do exactly the same thing than a body with an an empty body.</p>
",0
16408150,16404878,0,"<p>To remove the problem with the '\r' character that Bug Catcher suggested just run your file through dos2unix. Should fix the problem.</p>
",0
16404896,16404878,5,"<p>There might be a carriage return (\r) character in your file which causes prompt to get erased as cursor is positioned to start of line.</p>
",1
18295987,18295810,2,"<p>To test your thesis remove the <code>continue</code> statement and add the <code>} else {</code> branch with a closing end bracket.</p>

<p>If your code works then you know that the continue is skipping over some required logic.  You can duplicate that missing logic back to the <code>true</code> portion of the if and reinstate the <code>continue</code> statement.</p>
",2
18295858,18295810,1,"<p>Your<code>word</code> <strong>never</strong> changes once you choose to skip. You reach <code>continue;</code> and go right back to the top of the loop, replicating the same word and eventually encountering the same logic.</p>

<p>The code that actually advances <code>word</code> to your next token (the <code>strtok()</code> logic) is at the bottom of your loop; nowhere near the <code>continue</code> that is sending you back to the top. I think you need that logic replicated before the <code>continue;</code> <em>after</em> you've decided you need to skip and advance to the next token.</p>

<p>In fact, as I look at it now, there is no reason to have it down there either. <code>word</code> is only used to populate <code>c[i]</code> with a duplicate and is never used anywhere else (that i can see, anyway), so you could in-theory just advance it immediately after making your dupe, thereby having only one snippet of that code in your loop.</p>
",3
18297463,18295810,0,"<p>Not actually an answer, but a redesign:</p>

<pre><code>#include &lt;cstring&gt;
#include &lt;array&gt;
#include &lt;iostream&gt;

class BoyerMooreSearch
{
    public:
    typedef std::size_t size_type;

    private:
    static const size_type SkipTableSize = (std::size_t((unsigned char)(-1))) + 1;
    static const size_type Threshold = 5;
    typedef std::array&lt;std::size_t, SkipTableSize&gt; SkipTable;

    public:
    BoyerMooreSearch(const char* substr, size_type substrlen)
    :   m_substr(substr), m_substrlen(substrlen)
    {
        m_skip.fill(m_substrlen);
        size_type n = m_substrlen - 1;
        const char* s = m_substr + 1;
        while(n) m_skip[*s++] = n--;
    }

    BoyerMooreSearch(const char* substr)
    :   BoyerMooreSearch(substr, std::strlen(substr))
    {}

    BoyerMooreSearch(const std::string&amp; substr)
    :   BoyerMooreSearch(substr.c_str(), substr.size())
    {}

    // No copy
    BoyerMooreSearch(const BoyerMooreSearch&amp;) = delete;
    BoyerMooreSearch&amp; operator = (const BoyerMooreSearch&amp;) = delete;

    private:
    inline bool test_size(size_type strlen) const {
        return (m_substrlen &amp;&amp; m_substrlen &lt; strlen);
    }

    inline bool brute(size_type strlen) const {
        return m_substrlen &lt; Threshold || strlen - m_substrlen &lt;= m_substrlen;
    }

    public:
    const char* find(const char* str, const size_type strlen) const
    {
        if( ! test_size(strlen)) return 0;
        else {
            const char* end = str + strlen - m_substrlen;

            if( ! brute(strlen)) {

                // Boyer-Moore
                // ===========

                while(str &lt;= end) {
                    if(std::strncmp(str, m_substr, m_substrlen) == 0) return str;
                    str += m_skip[*(str + m_substrlen)];
                }
            }
            else {

                // Brute search
                // ============

                while(str &lt;= end) {
                    if(std::strcmp(str, m_substr) == 0) return str;
                    ++str;
                }
            }
            return 0;
        }
    }

    const char* find(const char* str) const {
        return find(str, std::strlen(str));
    }

    const char* find(const std::string str) const {
        return find(str.c_str(), str.size());
    }

    size_type count(const char* str, const size_type strlen) const
    {
        size_type result = 0;
        if(test_size(strlen))  {
            const char* end = str + strlen - m_substrlen;
            if( ! brute(strlen)) {

                // Boyer-Moore
                // ===========

                while(str &lt;= end) {
                    if(std::strncmp(str, m_substr, m_substrlen) == 0) {
                        ++result;
                        str += m_substrlen;
                    }
                    else str += m_skip[*(str + m_substrlen)];
                }
            }
            else {

                // Brute search
                // ============

                while(str &lt;= end) {
                if(std::strncmp(str, m_substr, m_substrlen) == 0) {
                    ++result;
                    str += m_substrlen;
                }
                else ++str;

                }
            }
        }
        return result;
    }

    size_type count(const char* str) const  {
        return count(str, std::strlen(str));
    }

    size_type count(const std::string str) const {
        return count(str.c_str(), str.size());
    }

    private:
    const char* m_substr;
    const size_type m_substrlen;;
    SkipTable m_skip;
};

int main()
{
    BoyerMooreSearch bms(""Hello"");
    const char* str = ""Hello World and Hello People"";
    std::cout &lt;&lt; ""Count: "" &lt;&lt; bms.count(str) &lt;&lt; std::endl;
    return 0;
}
</code></pre>
",0
17403124,17402870,8,"<p>Fairly simple: use two loops, one for counting up and one for counting down. Print literal <code>""0""</code> between the two.</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    for (int i = 0; i &lt; 10; i++) {
        for (int j = 10 - i; j &lt; 10; j++)
            printf(""%d"", j);

        printf(""0"");

        for (int j = 9; j &gt;= 10 - i; j--)
            printf(""%d"", j);

        printf(""\n"");
    }

    return 0;
}
</code></pre>
",4
17403144,17402870,0,"<p>Modified Code: 
Check your errors:</p>

<pre><code># include&lt;stdio.h&gt;
# include&lt;conio.h&gt;

int main()
{
// clrscr();
 int i,j,x,z,k,f=1;

 for ( i=10;i&gt;=1;i--,f++)
 {
     k=i;                    // K=i should be outside of loop.
     for(j=1;j&lt;=f;j++,k++)
     {

         if(k!=10)
         {
             printf(""%d"",k);
         }

         if(k==10)
         {
        printf(""0"");
         }
}
     z=9;                    //z=9 should be outside loop.
     for(x=1;x&lt;f;x++,z--)
     {
         printf(""%d"",z);
     }

printf(""\n"");

}
//getch();
return 0;
}
</code></pre>

<p>You are defining k=i inside the for loop(loop which has j) so every time k gets value of i and thus it always get value of i and prints that value and your another condition(if(k==10)) will never be true because every time k takes value of i and i is less than 10 after first iteration of loop and z=9 inside loop so every time loop is executed it is taking value z=9 so it is printing wrong value.</p>
",0
17403225,17402870,2,"<p>Like H2CO3's, but since we're only printing single digits why not use <code>putchar()</code>:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
  int i, j;

  for(i = 0; i &lt; 10; ++i)
  {
    // Left half.
    for(j = 0; j &lt; i; ++j)
      putchar('9' - i + j + 1);
    // Center zero.
    putchar('0');
    // Right half.
    for(j = 0; j &lt; i; ++j)
      putchar('9' - i + j + 1);
    putchar('\n');
  }
  return EXIT_SUCCESS;
}
</code></pre>
",1
17403229,17402870,0,"<p>Here's a C# version:</p>

<pre><code>static void DrawNumberTriangle()
{
    for (int line = 10; line &gt;=1; line--)
    {
        for (int number = line; number &lt; 10; number++)
        {
            System.Console.Write(number);
        }
        System.Console.Write(""0"");
        for (int number = 9; number &gt; line - 1; number--)
        {
            System.Console.Write(number);
        }

        System.Console.WriteLine();
    }
}
</code></pre>

<p>I'd suggest renaming your i,j,x,z,k,f variables to ones that have meaning like the one's I used. This helps making your code easier to follow.</p>
",0
17403978,17402870,0,"<pre><code>#include &lt;stdio.h&gt;

void print(int i){
    if(i == 10){
        putchar('0');
        return ;
    } else {
        printf(""%d"", i);
        print(i+1);
        printf(""%d"", i);
    }
}

int main(void){
    int i;
    for(i = 10; i&gt;0; --i){
        print(i);
        putchar('\n');
    }
    return 0;
}
</code></pre>
",0
17403258,17402870,0,"<p>Rather than output the mid 0 using printf, why not print it using the loops itself.
The following short and simple code can be used:</p>

<pre><code>int main()
{
    int m = 10, n, p;
    while(m &gt;= 1)
    {
        for(n = m; n &lt;= 10; n++)
            printf(""%d"", n % 10);
        for(p = n - 2; p &gt;= m; p--)
            printf(""%d"", p );
        printf(""\n"");
        m--;
    }
    return 1;
}
</code></pre>
",0
17403388,17402870,0,"<p>For high throughput (though of questionable merit in terms of clarity):</p>

<pre><code>#include &lt;stdio.h&gt;

int main() {
    char const digits[] = ""1234567890"";
    char const rdigits[] = ""9876543210"";

    for (int i = 0; i &lt; 30; ++i) {
        int k = i % 10;
        fputs(digits + 9 - k, stdout);
        for (int j = 9; j &lt; i; j += 10) fputs(digits, stdout);
        for (int j = 9; j &lt; i; j += 10) fputs(rdigits, stdout);
        fwrite(rdigits, 1, k, stdout);
        fputs(""\n"", stdout);
    }
}
</code></pre>
",0
16908890,16908760,-1,"<p>I think you should be change the code, for correct the output mass</p>

<pre><code> while (counter&lt;MAXIUM &amp;&amp; fscanf(foo, ""%s"", foo)!= EOF){ 

   /* the  strlen(foo) + 1 for store '\0' */
   final + counter = (char*)malloc((strlen(foo) + 1)*sizeof(foo)); 
   /* to copy the ""foo"" content  to final + n */
   strcpy(final + counter, foo, strlen(foo));
   /* each time should clear the foo array */
   memset(foo, 0, 81);

   counter++;
 }
</code></pre>
",5
16908901,16908760,1,"<p>Change</p>

<pre><code>while (counter&lt;MAXIUM &amp;&amp; fscanf(foo, ""%s"", foo)!= EOF){
  *final = (char*)malloc(strlen(foo)*sizeof(foo)); 
  *(final + counter ) = foo + counter;
....
 for(counter=0; i&lt;MAXIMUM; counter++) printf(""%s"",final[counter])
</code></pre>

<p>to</p>

<pre><code>// Also recommend that the first thing you do is fill your `final[]` with NULL, 0
for (int j=0; j&lt;MAXIUM; j++) final[j] = 0;

// changed fscanf to fgets.  Less issues with dropping whitespace.
while ((counter&lt;MAXIUM) &amp;&amp; (fgets(foo, sizeof(foo), stdin)!= EOF)){ 
  final[counter] = (char*)malloc(strlen(foo)+1);  // some say (char*) cast is undesirable, bit allowed.
  strcpy(final[counter], foo);
  // eliminate *(final + counter ) = foo + counter;  
...
for(i=0; i&lt;counter; i++) printf(""%s"",final[i]);  // The fgets() will preserve the EOL 
</code></pre>
",1
20647121,20646756,1,"<p>Your char arrays <strong>a</strong> and <strong>b</strong> can hold only up to <strong>1002</strong> digits, while the problem statement says ""at most <strong>10000</strong> decimal digits each"".</p>
",1
19505585,19505537,2,"<p>Remove <code>&amp;</code> from aal of your <code>printf</code>'s argument.  </p>

<pre><code> printf(""You have a BMI of %f, and your weight status is underweight\n"" &amp;bmi);  
                                                                        ^
                                                                        |
                                                                  Remove this &amp;  
</code></pre>

<p>It should be  </p>

<pre><code>  printf(""You have a BMI of %f, and your weight status is underweight\n"", bmi);  
</code></pre>

<p>Also never use <code>%lf</code> specifier for <code>double</code> in <code>printf</code> (in <code>scanf</code> you have to use) instead use <code>%f</code>.  </p>
",0
19505838,19505537,1,"<p>In the printf statement don't use  &amp;bmi, use simple bmi.
It should work</p>
",0
12873527,12873516,1,"<pre><code> printf(""Largest is: %d \n"", largest(args, length));
</code></pre>

<p>just remove the '[]', because args is a pointer and that's what the function is expecting.</p>
",0
12873532,12873516,1,"<p>You probably just want the pointer of the array, so pass in <code>largest(args, length)</code> instead.</p>
",0
12873535,12873516,1,"<p>You can't pass an array like that. You have to pass the pointer to the array (first item):</p>

<pre><code>printf(""Largest is: %d \n"", largest(args, length));
</code></pre>
",0
12873544,12873516,5,"<p>because you need to place an integer between the operator square brakets, or otherwise don't specify the square brackets : </p>

<pre><code>printf(""Largest is: %d \n"", largest(&amp;args[0], length));
</code></pre>

<p>or </p>

<pre><code>printf(""Largest is: %d \n"", largest(args, length));
</code></pre>

<p>Keep in mind that <code>args[0]</code> is the same as <code>*(args + 0)</code> but <code>args[]</code> will give an error because it needs a number to sum ... </p>
",0
19504834,19504505,0,"<p>Sometimes you want to provide no arguments, and use stdin, sometimes you want to open a file.  Here is what you want to do,</p>

<pre><code>int main(int argc, char *argv[])
{
    FILE *Q = stdin; //use stdin unless you provide a filename
    if( (argc&gt;1 ) &amp;&amp; strcmp(argv[1],""-"") ) { //allow ""-"" as alias for stdin
        if( !(Q = fopen(argv[1],""r"")) ) {
            printf(""Error, cannot open %s\n"",argv[1]);
            exit(1);
        }
    }
    //read from Q here
}
</code></pre>
",0
19504559,19504505,4,"<p><code>argv[1]</code> points to the first parameter of your binary (without it's name), so in case of <code>./w &lt; data1</code> it is missing. You're trying to access the ""illegal"" memory, so you get a segfault.</p>

<p>The mark <code>&lt;</code> is a bash feature, it is not passed to C.</p>

<p>If you want to use such a redirection, just read from standard input and don't care about the file/argv. It means ""take file data1 and pass it to descriptor 0, that is standard input"".</p>

<p>You can use <code>scanf</code> or <code>read(0, ...)</code> to use the file's content.</p>
",0
19504565,19504505,2,"<p>When using <code>./w &lt; data1</code>, then you don't need to open a file. Just read from <code>stdin</code>.</p>
",0
19504585,19504505,0,"<p>The second command you issue redirects the files' contents to the standard input of your program. This means two things, first of all that you will need to read data from stdin (scanf) and that the argv[1] will be undefined.</p>

<p>So to answer your question, you are trying to open an undefined value which translates to a pointer which in turn causes your crash </p>
",0
19504614,19504505,0,"<p>When your program starts with redirection the file is already opened. You can read it from the stream called 'stdin'. You're using a pointer to something that doesn't exist (argv[1]) in that case so that's why it fails.</p>

<p>Many of the C functions default to using stdin so you will not have to specify the file to read from.</p>
",0
19504629,19504505,2,"<p>The reason your first command works is because you are providing an argument to your program (in your case, the filename) and your program uses that argument to open the file.</p>

<p>When you are using a redirect, you are redirecting stdin and stdout (which are accessed with functions like gets and printf) to the file, so you don't have to open any files in the program at all.</p>
",0
19504667,19504505,0,"<p>You should initialize your <code>FILE*</code> variable like this:</p>

<pre><code>FILE *Q; 
if (argc &gt;= 2) {
    // at least one argument given, try to open it as file
    Q = fopen(argv[1],""r"");
    // let's add error checking while we're at it!
    if (!Q) {
        perror(""fopen"");
        return 1; // note: this only works if this code is in main function
    }
} else {
    Q = stdin;
}
</code></pre>

<p>Now Q is either the file given as command line parameter, or it is <code>stdin</code>, meaning standard input.</p>
",0
17082664,17082604,15,"<p>When using <a href=""http://msdn.microsoft.com/en-us/library/w40768et%28v=vs.110%29.aspx""><code>scanf_s</code></a>, for the <code>%c</code> format string you must specify how many characters you wish to read:</p>

<pre><code>scanf_s(""%d%c%d"", &amp;num1, &amp;oper, 1, &amp;num2);
</code></pre>

<p>The <a href=""http://msdn.microsoft.com/en-us/library/w40768et%28v=vs.110%29.aspx"">documentation</a> describes the requirement:</p>

<blockquote>
  <p>Unlike scanf and wscanf, scanf_s and wscanf_s require the buffer size to be specified for all input parameters of type c, C, s, S, or string control sets that are enclosed in []. The buffer size in characters is passed as an additional parameter immediately following the pointer to the buffer or variable.</p>
</blockquote>
",6
16917884,16917671,1,"<p>sequence point is the magic word here. and</p>

<pre><code>ptr-&gt;i = Change(&amp;ptr);
</code></pre>

<p>is the position. (by whom will ptr be changed? by the Assignment or by the function via the call by reference)</p>
",2
17386252,17386232,3,"<p>It seems you have to change <code>()</code></p>

<pre><code>if( IS_CHAR_IN_ANY_POLICE_VEHICLE(GetPlayerPed) &amp;&amp; IS_BUTTON_JUST_PRESSED(0,DPAD_DOWN) ){
</code></pre>

<p>or more readable</p>

<pre><code>if( 
    IS_CHAR_IN_ANY_POLICE_VEHICLE(GetPlayerPed) 
    &amp;&amp; IS_BUTTON_JUST_PRESSED(0,DPAD_DOWN) 
){
</code></pre>

<p><strong>edit:</strong></p>

<p>error in line 80 - correct line:</p>

<pre><code>WARP_CHAR_INTO_CAR(GetPlayerPed,PoliceV);
</code></pre>

<p><strong>edit:</strong></p>

<p>Wait, I see another problem in line 81 - closing <code>}</code> - correct line:</p>

<pre><code>} else {
</code></pre>

<p><strong>edit:</strong></p>

<p>I think you have to much closing <code>}</code>. I think you can delete first <code>}</code> below <code>TERMINATE_THIS_SCRIPT();</code>. But first try to compile it before you delete this <code>}</code>.</p>

<p><strong>by the way:</strong> learn <code>C</code> harder because some problems are so elementary that it is shame to ask for help.</p>
",3
17386259,17386232,3,"<p>You have mismatched parentheses</p>

<p>You effectively have</p>

<pre><code> if (a) &amp;&amp; (b)
</code></pre>

<p>instead of</p>

<pre><code> if (a &amp;&amp; b)
</code></pre>

<p>Change this:</p>

<pre><code>        if(IS_CHAR_IN_ANY_POLICE_VEHICLE(GetPlayerPed)) &amp;&amp; (IS_BUTTON_JUST_PRESSED(0,DPAD_DOWN)){ //If you are in a police car and press dpad down
</code></pre>

<p>to this:</p>

<pre><code>        if (IS_CHAR_IN_ANY_POLICE_VEHICLE(GetPlayerPed) &amp;&amp; IS_BUTTON_JUST_PRESSED(0,DPAD_DOWN)) { //If you are in a police car and press dpad down
</code></pre>
",0
17386266,17386232,0,"<p>You are missing a ( and ) on that line of code.</p>

<pre><code>if((IS_CHAR_IN_ANY_POLICE_VEHICLE(GetPlayerPed)) &amp;&amp; (IS_BUTTON_JUST_PRESSED(0,DPAD_DOWN))){
</code></pre>
",0
15498974,15498852,5,"<p>You don't do anything with <code>aptr</code> in the <code>fill_in</code> function. Instead, you fill the local <code>arr</code> array. Do this instead:</p>

<pre><code>for (i = 0; i &lt; m; i++)
{
    for (j = 0; j &lt; n; j++)
        aptr[i * n + j] = 1;
}
</code></pre>

<p>Furthermore, this:</p>

<pre><code>aPtr = &amp;array[L][C];
</code></pre>

<p>needs to ne</p>

<pre><code>aPtr = &amp;array[0][0];
</code></pre>

<p>You want a pointer to the first element of your array.</p>

<p>Also, instead of <code>counter &lt;= max - 1</code>, use the more concise and conventional <code>counter &lt; max</code> notation.</p>
",2
15499059,15498852,1,"<p>This is wrong</p>

<pre><code>int * aPtr;
aPtr = &amp;array[L][C];
</code></pre>

<p>You are assigning a pointer to a position out of array bounds. The array is defined from 0-2 on both lines and columns, and you are assigning position (3,3) to the pointer.</p>

<p>Besides this, you are doing nothing with the pointer you pass as argument to the fill_in function.</p>
",0
15532627,15532403,0,"<p>Here <code>struct node</code> is a type like <code>int</code></p>

<p>and Hence </p>

<pre><code>struct node {
  int data;
  struct node *next;
}NodeVar;
</code></pre>

<p>means you are declaring a single variable Node of struct node.</p>

<p>like <code>int intVar;</code></p>

<p>typedef is to make your code understandable.</p>

<p>so that when you use </p>

<pre><code>typedef struct node Node;
</code></pre>

<p>you can use the same declaration as </p>

<pre><code>Node NodeVar;
</code></pre>
",0
15532793,15532403,0,"<p>Consider this code:</p>

<pre><code>#include &lt;stdio.h&gt;

typedef struct {
   int data;
   struct node *next;
} Node;

int main()
{
   Node a, b = {10, NULL};
   a.next = &amp;b;

   printf(""%d\n"", a.next-&gt;data);
}
</code></pre>

<p>This won't compile. The compiler has no idea what a <code>struct node</code> is, other than it exists. So you might change the definition in the struct to <code>Node *next;</code>. The typedef isn't in scope before it's declared, so it still won't compile. The simple answer is to do as he said, use the <code>node</code> tag after <code>struct</code>, and it works fine.</p>
",0
15532800,15532403,10,"<blockquote>
  <p>Does it have something to do with the fact that if you don't include a lower case <code>node</code> then when the compiler is evaluating the code it will not be able to understand what is meant by ""<code>struct node *next</code>""?</p>
</blockquote>

<p>Yes.</p>

<p>The <code>node</code> in <code>struct node</code> is the <em>tag</em> of the struct type. If you give the struct a tag, you can refer to that type from the moment on the tag is complete, so in</p>

<pre><code>typedef struct node {
  int data;
  struct node *next;
} Node;
</code></pre>

<p>the <code>struct node *next;</code> declares a member <code>next</code> that is a pointer to the struct type being defined. The typedef name <code>Node</code> is not available before the <code>;</code> ending the definition is reached.</p>

<p>If you omit the tag, you cannot refer to the type being defined in any way before the <code>typedef</code> is complete, so in</p>

<pre><code>typedef struct {
  int data;
  struct node *next;
} Node;
</code></pre>

<p>the line <code>struct node *next;</code> declares a new, unrelated, incomplete <code>struct</code> type with the tag <code>node</code> that <code>next</code> points to.</p>

<p>That's valid, but nothing about <code>struct node</code> is known (unless it is defined somewhere else), so you can't use the <code>next</code> pointer without casting it to a pointer to a complete type everywhere (not quite everywhere, <code>Node foo; foo.next = malloc(12);</code> etc. would still work).</p>
",1
15532501,15532403,16,"<p>Take a look at this declaration:</p>

<pre><code>struct node {
  int data;
  struct node *next;
};

typedef struct node Node;
</code></pre>

<p>This can be combined into a single statement (simplifying a declaration):</p>

<pre><code>typedef struct node {
  int data;
  struct node *next;
} Node;
</code></pre>
",1
15532536,15532403,1,"<p>He is defining a <em>temporary</em> name for the node because he is using a well know technique to avoid writing <code>struct node</code> on the declaration of each struct object.</p>

<p>If he would just do:</p>

<pre><code>struct node {
  int data;
  struct node *next;
};
</code></pre>

<p>you would have had to use:</p>

<pre><code>struct node* node;
</code></pre>

<p>to declare a new node. And to avoid that you would have to define later:</p>

<pre><code>typedef struct node Node;
</code></pre>

<p>in order to be able to declare objects like the following:</p>

<pre><code>Node* node;
</code></pre>

<p>In the end:</p>

<pre><code>typedef struct node {
  int data;
  struct node *next;
} Node;
</code></pre>

<p>Is just a shortcut for <code>struct node { ... };</code> in addition to <code>typedef struct node Node;</code>.</p>
",0
15533840,15532403,0,"<p>The lower case 'node' is a structure type... i.e. a struct node { stuff } is a node structure containing stuff.</p>

<p>On the other hand, the upper case ""Node"" is a completely new data type which refers to a 'struct node'</p>

<p>Generally (though in C++ I think you can), you cannot pass around a ""node"" in a C program... for example as an argument to a function. Rather, you would have to pass a 'struct node' as your argument...</p>

<pre><code>// this will throw a syntax error because ""node"" is not a data type, 
// it's a structure type.

void myFunc( node* arg ); 

// while this will not because we're telling the compiler we're 
// passing a struct of node

void myFunc( struct node* arg ); 

// On the other hand, you *can* use the typedef shorthand to declare 
// passing a pointer to a custom data type that has been defined 
// as 'struct node'

void myFunc( Node* arg );
</code></pre>
",0
15543758,15543697,0,"<p>The way <em>I</em> would do it would probably be to use <a href=""http://en.cppreference.com/w/c/io/fgets"" rel=""nofollow""><code>fgets</code></a> to get the whole line, then parse it manually doing something like:</p>

<ol>
<li>Read the initial integer. This can easily be done with e.g. <a href=""http://en.cppreference.com/w/c/string/byte/strtoul"" rel=""nofollow""><code>strtoul</code></a>.</li>
<li>Read the characters while they are not digits (using <a href=""http://en.cppreference.com/w/c/string/byte/isdigit"" rel=""nofollow""><code>isdigit</code></a>).</li>
<li>Do <code>strtoul</code> in a loop until you have all numbers.</li>
</ol>
",0
15803052,15802872,7,"<p>to understand it you need to know that when you write </p>

<pre><code>double d[2];
double *p = d;
p = p + 1;      p is now pointing to the next double i.e. &amp;d[1] 
</code></pre>

<p>in memory <code>p</code> has moved <code>sizeof(double)</code> bytes forward</p>

<p>if you treat p as a character pointer you can get the number of bytes that the offset has changed instead:</p>

<pre><code>double d[2];
double *p = d;
char* start = (char*)p; 
p = p + 1;
char* end = (char*)p;
</code></pre>

<p>now <code>end-start</code> gives the offset in bytes (characters) IOW <code>sizeof(double)</code>.</p>
",3
15818743,15802872,1,"<p>In C, <code>sizeof char</code> is (by definition) 1. They cast to <code>char *</code> to be able to subtract pointers to get the size of the object pointed at.</p>

<p>This will mostly work, but AFAIU willy-nilly ""pointing to the next object"" if it isn't in an array is not always guaranteed to work right. Besides, the size of an object with the requited padding in an array isn't necessarilily the size of the object.</p>

<p>Bletcherous. Just use <code>sizeof</code>.
`</p>
",1
17773005,17772684,0,"<p>This is the standard way to delete a node in a linked list, in-place. Hopefully this should work for you:</p>

<pre><code>int list_remove(struct list_t *list, char *key) {
  node_t *node = list-&gt;head;
  node_t *prev = NULL;   //to keep track of the previous node
  int i;
  for(i=0; i&lt;list-&gt;size; i++) {
    if(strcmp(node-&gt;element-&gt;key, key)==0) {
      if(node == list-&gt;head) {   //if 1st node has to be deleted
        if(list-&gt;size == 1)    //if there's only one node in list
          list-&gt;head = NULL;
        else
          list-&gt;head = node-&gt;next;
        list-&gt;size--;
        return 0;
      }
      prev-&gt;next = node-&gt;next;
      return 0;
    } else {
      prev = node;
      node=node-&gt;next;
    }
  }
  return -1;
}
</code></pre>
",0
17773177,17772684,0,"<p>Look,</p>

<p>you don't have to create a new list for this, it's not efficient at all!</p>

<p>First, you have to check if the element is the first one!</p>

<p>If you want to deleate the i'th chain, go to the (i-1) element and connect it with the (i+1) and then free the i'th element.</p>
",0
19972005,19971886,0,"<p>An Underscore is seen a normal letter/Character</p>

<p><a href=""http://msdn.microsoft.com/en-us/library/e7f8y25b%28v=vs.110%29.aspx"" rel=""nofollow"">MSDN Desciption of identifiers</a></p>

<p>Besides that there are often some Coding guidelines that restrict you in the use of the underscore, e.g. in a constructor the parameters are named _name where the name of the class variable is name.</p>
",0
19972006,19971886,5,"<p><strong>Rules for writing identifier</strong></p>

<ol>
<li><p>An identifier can be composed of letters (both uppercase and lowercase letters), digits and underscore '_' only.</p></li>
<li><p>The first letter of identifier should be either a letter or an underscore. But, it is discouraged to start an identifier name with an underscore though it is legal. It is because, identifier that starts with underscore can conflict with system names. In such cases, compiler will complain about it. Some system names that start with underscore are _fileno, _iob, _wfopen etc.</p></li>
<li><p>There is no rule for the length of an identifier. However, the first 31 characters of an identifier are discriminated by the compiler. So, the first 31 letters of two identifiers in a program should be different.</p></li>
</ol>

<p>Ex:</p>

<pre><code>    int identifier;
    int _identifier;
    int new_identifier;
</code></pre>
",5
19972251,19971886,7,"<p>Yes, underscores may appear everywhere in an identifier, <code>_a</code>, <code>_0_</code> or even <code>_</code> are all valid identifiers. But there are a rules which of these you may use in your code and which are reserved for the ""implementation"" (= compiler and OS).</p>

<ul>
<li><p>identifiers starting with an <code>_</code> and a then a capital letter are reserved everywhere, you are not supposed to use them yourself. They can be used freely by the compiler or may be used by future language extensions, e.g this is why the official Boolean type in C is named <code>_Bool</code>.</p></li>
<li><p>identifiers starting with an <code>_</code> and a then a lower case letter are reserved at file scope, so your are not allowed to name a function or global variable <code>_toto</code> or something alike. These could conflict with names of library functions, e.g.</p></li>
<li><p>identifiers with more than one <code>_</code> in a row are reserved by C++ for name mangling. If you ever think of writing code in C that is callable from C++ you shouldn't use these.</p></li>
<li><p>identifiers ending with <code>_t</code> are reserved by POSIX for types. If you want to avoid future portability issues on new systems, avoid these, too.</p></li>
</ul>

<p>There are a lot of other rules for reserved names, I only listed those that I remembered concerning <code>_</code>.</p>
",0
19972642,19971886,5,"<p>Yes, underscores can be used as identifiers. Here's an example: <a href=""http://en.wikipedia.org/wiki/International_Obfuscated_C_Code_Contest"" rel=""nofollow noreferrer"">The IOCCC winner of 1988</a></p>

<pre><code>#define _ -F&lt;00||--F-OO--;
int F=00,OO=00;main(){F_OO();printf(""%1.3f\n"",4.*-F/OO/OO);}F_OO()
{
            _-_-_-_
       _-_-_-_-_-_-_-_-_
    _-_-_-_-_-_-_-_-_-_-_-_
  _-_-_-_-_-_-_-_-_-_-_-_-_-_
 _-_-_-_-_-_-_-_-_-_-_-_-_-_-_
 _-_-_-_-_-_-_-_-_-_-_-_-_-_-_
_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_
_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_
_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_
_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_
 _-_-_-_-_-_-_-_-_-_-_-_-_-_-_
 _-_-_-_-_-_-_-_-_-_-_-_-_-_-_
  _-_-_-_-_-_-_-_-_-_-_-_-_-_
    _-_-_-_-_-_-_-_-_-_-_-_
        _-_-_-_-_-_-_-_
            _-_-_-_
}
</code></pre>

<p>As to <em>why</em> an underscore is allowed anywhere in an identifier, the answer is: the standard describes the syntax of an identifier to be comprised of at least one <em>nondigit</em>, followed by zero or more <em>digit or nondigit</em> chars<br/>
It also defines <em>nondigits</em> as being either one of the following chars:</p>

<blockquote>
  <p>_ a b c d e f g h i j k l m n o p q r s t u v w x y z<br/>
  A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</p>
</blockquote>

<p>and digits are:</p>

<blockquote>
  <p>0 1 2 3 4 5 6 7 8 9</p>
</blockquote>

<p>So following this rule, <code>_____</code> is as valid an identifier as <code>my_identifier</code> or <code>_000000AAFF___</code><Br/>
But be aware that there is such a thing as reserved identifiers, and <a href=""https://stackoverflow.com/a/228797/1230836"">these, too, are described in the standard</a>.<br/>
To answer the <em>why</em> question once again: because the standard said so ;-P</p>
",2
15844994,15844963,2,"<p>It probably crashes because here:</p>

<pre><code>for(i = 0; i&lt;SIZE; i++)
{
    deck[i] = i;
    i++;
};
</code></pre>

<p>you increment i twice.
Remove the <code>i++</code> line:</p>

<pre><code>for(i = 0; i&lt;SIZE; i++)
{
    deck[i] = i;
};
</code></pre>

<p>Also, here:</p>

<pre><code>void draw(int deck[SIZE])
{
     int i; 
     int hand[i];
</code></pre>

<p>the line <code>int hand[i]</code> will probably fail because i is not a constant (it's not initialized also).</p>
",2
15845072,15844963,0,"<p>Some notes:</p>

<pre><code>void draw(int deck[SIZE])
{
    int i; 
    int hand[i];

    for(i = 0; i &lt; 5; i++)
    {
        cards(hand[i]);
        putchar('\n');
    }
}
</code></pre>

<p><code>i</code> is not initialized by default, and will contain whatever was in that memory address before, then you create an array of this random length -- do you mean to do this?</p>

<p>Then you pass hand[0], hand[1], ..., hand[4] to cards even though they're undefined.</p>

<p>This could cause a crash.</p>

<p>Maybe you want something like:</p>

<pre><code>void draw(int deck[SIZE])
{
    int numCards = 5;
    int i; 
    int hand[numCards];
    int card;
    for(i = 0; i &lt; numCards; i++)
    {
        card = deck[i];     /* Draw a card */
        hand[i] = card;     /* Store it in a ""hand"" array (even though you dont use it) */
        cards(card);        /* Display info about the card */
    }
}
</code></pre>

<hr>

<p>Here you print out what the integer value of every card would be, regardless of how your deck is sorted.</p>

<pre><code>void cards(hand)
{
    int i; 

    char suits[4][9] = 
    {
        ""Hearts"",
        ""Diamonds"",
        ""Clubs"",
        ""Spades""};

    for(i=0; i&lt;SIZE; i++)
    {       
        if(i%13 == 0 || i%13 == 10 || i%13 == 11 || i%13 == 12)
            printf(""%s "", facecheck(i%13) );
        else 
            printf(""%d "", i%13+1);
        printf(""of %s \n"", suits[i/13]);
    }

}
</code></pre>

<p>I don't think you mean to do this.  I think you mean something like</p>

<pre><code>void cards(int card)
{
    char suits[4][9] = 
    {
        ""Hearts"",
        ""Diamonds"",
        ""Clubs"",
        ""Spades""};


    if(card%13 == 0 || card%13 == 10 || card%13 == 11 || card%13 == 12)
        printf(""%s "", facecheck(card%13) );
    else 
        printf(""%d "", card%13+1);
    printf(""of %s \n"", suits[card/13]);
}
</code></pre>

<p>Since you're already calling this function on each card, no reason to loop through anything.</p>
",2
15854089,15844963,0,"<pre><code>for(i = 0; i&lt;SIZE; i++)
{
    deck[i] = i;
    i++;
};
</code></pre>

<p>the error of semicolon in for-loop?</p>

<pre><code>for(i = 0; i&lt;SIZE; i++)
{
    deck[i] = i;
    i++; //one of the answer stated to remove this sentence
}
</code></pre>
",0
19562643,19562600,10,"<p>Just use a bitmask:</p>

<pre><code>int val = value &amp; 0x1F;
</code></pre>

<p>Explanation:    </p>

<pre><code>  1 1100 1001 ---&gt; your value
  0 0001 1111 ---&gt; the bitmask
       1    F ---&gt; hexadecimal equivalent of the bitmask
  -----------
&amp; 0 0000 1001 ---&gt; value &amp; bitmask
</code></pre>

<p>The binary &amp; (AND) operation has the following truth table:</p>

<pre><code>©°©¤©¤©¤©¤©¤¨i©¤©¤©¤©Ð©¤©¤©¤©´
©¦ A&amp;B ¨U 0 ©¦ 1 ©¦
¨b¨T¨T¨T¨T¨T¨p¨T¨T¨T¨n¨T¨T¨T¨e
©¦  0  ¨U 0 ©¦ 0 ©¦
©À©¤©¤©¤©¤©¤¨o©¤©¤©¤©à©¤©¤©¤©È
©¦  1  ¨U 0 ©¦ 1 ©¦
©¸©¤©¤©¤©¤©¤¨l©¤©¤©¤©Ø©¤©¤©¤©¼
</code></pre>

<p>Only bits which are 1 in the value and the bitmask become 1 in the result.
This effectively allows you to control which bits you want to keep from the value.</p>
",0
19562645,19562600,11,"<p>You can get just the last 5 bits by masking:</p>

<pre><code>x = x &amp; 0x1f;
</code></pre>

<p>If you want to <em>process</em> each of these bits then you can test them individually in a loop, e.g.</p>

<pre><code>for (i = 0; i &lt; 5; ++i)
{
    if (x &amp; (1 &lt;&lt; i))  // if bit i is set
    {
        // do something for bit i = 1
    }
    else
    {
        // do something else for bit i = 0
    }
}
</code></pre>

<p>(Note: no need to mask first in this case.)</p>
",2
19562646,19562600,1,"<p>The answer is <code>number &amp; 31</code>.</p>

<p><code>31</code> = <code>11111</code> in binary</p>
",0
17850132,17850075,0,"<p>The <code>||</code> is a short circuit operator if the first operand evaluates to true it doesn't execute further.</p>

<p>So <code>var2</code> becomes 1 ( <em>Since var2 is initially 6 and the operation evaluates to true</em>) and no increment happens so <code>var1</code> remains 4.</p>
",0
17850138,17850075,6,"<p>It's called ""precedence"", not ""priority"". <strong>And precedence is not the same as order of evaluation.</strong></p>

<p>Since the <code>||</code> and <code>&amp;&amp;</code> operators <a href=""http://en.wikipedia.org/wiki/Short-circuit_evaluation"" rel=""noreferrer"">short-circuit</a>, and var2 is considered true (since 6 is non-zero), neither the post-increment operation nor the function call is evaluated.</p>
",2
17850154,17850075,0,"<p><code>||</code> is short-cut, so in the statement:</p>

<pre><code>var2=var2||var1++&amp;&amp;printf(""computer world"");
</code></pre>

<p>Since <code>var</code> has a value of <code>6</code>, which evaluates as true, the latter expression <code>var1++&amp;&amp;printf(""computer world"");</code> will not be executed.</p>
",0
17850173,17850075,1,"<p>The <strong>||</strong> operator checks if the first value is <strong>true</strong>. If it is true then it won't evaluate the second part of the logical expression and hence the printf statement has not output the text .This is called as short circuit operation.</p>

<p>The below code gives the expected result</p>

<pre><code>#include&lt;stdio.h&gt;

int main()
{
     int  var1=4,var2=0;
     var2=var2||var1++&amp;&amp;printf(""computer world"");
     printf(""%d%d"",var1,var2); 
     getch(); //remove getch if you are working on gcc 
}
</code></pre>
",4
17850195,17850075,1,"<p><code>var2||var1++&amp;&amp;printf(""computer world"")</code> will be evaluated to :</p>

<pre><code>var2||(  var1++&amp;&amp;printf(""computer world"")   )
</code></pre>

<p>so since var2 is not zero, all the part after <code>||</code> will be ignored.</p>

<p>so the result is true. which is 1 and it will be assigned to var2.</p>
",0
17850445,17850075,0,"<p>for fun:</p>

<pre><code>#include""stdio.h""                                                                                                                                                          
   main()
   {
        int  var1=4,var2=6;
        var2=printf(""step1"")&amp;&amp;var2||printf(""step2"")||var1++&amp;&amp;printf(""step3"");
        printf(""%d%d\n"",var1,var2); 
        var2=printf(""step1"")&amp;&amp;var2&amp;&amp;printf(""step2"")||var1++&amp;&amp;printf(""step3"");
        printf(""%d%d\n"",var1,var2); 
        var2=printf(""step1"")&amp;&amp;var2&amp;&amp;printf(""step2"")&amp;&amp;var1++&amp;&amp;printf(""step3"");
       printf(""%d%d\n"",var1,var2);
      // getch();
  }
</code></pre>

<p>Result is :</p>

<p>step141</p>

<p>step1step241</p>

<p>step1step2step351</p>
",0
15851878,15851699,-1,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
void load(int *n, int *x, int **arr)
{   
    int i = 0;
    *arr = (int*) malloc(*n * sizeof(int));
    if(!*arr) {
        perror(""Can not allocate memory!"");
        return;
    }
    for(i = *n; i &gt;= 0; i--)
    {
        scanf(""%d"", *arr + i);
    }
    return;
}

int main()
{
    int n = 0, x = 0;
    int *arr;
    int i;

    /* You probably need to initialize n */
    n = 5;
    load(&amp;n, &amp;x, &amp;arr);

    for(i = n; i &gt;= 0; i--)
    {
        printf(""%d - %d\n"", i, arr[i]);
    }
    return EXIT_SUCCESS;
}
</code></pre>
",2
15851729,15851699,1,"<pre><code>arr = (int**)malloc(sizeof(int*)*(*n));
</code></pre>

<p>doesn't change anything in main, it only overwrites the copy of the pointer (address of <code>arr</code> in <code>main</code>) that <code>load</code> receives.</p>

<p>What the function should do is change <code>arr</code> in <code>main</code>, for that, you have to dereference the argument,</p>

<pre><code>*arr = (int*)malloc(sizeof(int)*(*n)); // cast for C++ compiler left in
</code></pre>

<p>to change the value of <code>arr</code> in <code>main</code>. (The object that the argument <code>arr</code> of <code>load</code> points to, that is <code>arr</code> in <code>main</code>, needs to be changed, hence you need to modify <code>*arr</code> in <code>load</code>.)</p>

<p>The scans should then be</p>

<pre><code>scanf(""%d"", &amp;(*arr)[i]);
</code></pre>

<p>or (equivalent)</p>

<pre><code>scanf(""%d"", *arr + i);
</code></pre>
",5
15852876,15852853,1,"<p>The error message you are quoting is incomplete. It's missing an asterisk after <code>double</code>: the type of <code>*(arr + i)</code> is <code>double*</code> rather than <code>double</code>, and you can't convert <code>int</code> or <code>double</code> to <code>double*</code>.</p>

<p>Presumably you mean</p>

<pre><code>        *(*arr + i) = rand();
</code></pre>

<p>or</p>

<pre><code>        (*arr)[i] = rand();
</code></pre>
",2
15852912,15852853,0,"<p><code>*(arr + i) = rand();</code> -> <code>(*arr)[i] = rand();</code></p>
",0
15854217,15854182,2,"<pre><code>if (rand() / (RAND_MAX + 1.) &lt; .3) {
   /* good soil */
} else {
   /* poor soil */
}
</code></pre>

<p>Here, <code>rand() / (RAND_MAX + 1.)</code> produces a pseudo-random number uniformly distributed on <code>[0, 1)</code>. We compare this number to <code>.3</code> to get good soil 30% of the time.</p>
",1
17791544,17791480,2,"<p>Well for a start you have some mismatched parentheses here:</p>

<pre><code> rt1 = (-b + sqrt(discrim)/(2.0*a);
 rt2 = (-b - sqrt(discrim)/(2.0*a);
</code></pre>

<p>You need to change these lines to:</p>

<pre><code> rt1 = (-b + sqrt(discrim))/(2.0*a);
 rt2 = (-b - sqrt(discrim))/(2.0*a);
                        ^^^^
</code></pre>

<p>Your compiler probably gave you error messages for these lines, e.g.</p>

<pre><code>foo.c:25: error: expected ¡®)¡¯ before ¡®;¡¯ token
</code></pre>

<p>Looking at the error message carefully and studying line 25 would have told you that you were missing a closing parenthesis.</p>
",0
17791546,17791480,1,"<pre><code>  rt1 = (-b + sqrt(discrim)/(2.0*a);
  rt2 = (-b - sqrt(discrim)/(2.0*a);
                          ^
</code></pre>

<p>You are missing the right closing parentheses.</p>
",0
17791606,17791480,2,"<p>You missed some parenthesis here:</p>

<pre><code>rt1 = (-b + sqrt(discrim)/(2.0*a);
rt2 = (-b - sqrt(discrim)/(2.0*a);
</code></pre>

<p>It should look like this:</p>

<pre><code>rt1 = (-b + sqrt(discrim))/(2.0*a);
rt2 = (-b - sqrt(discrim))/(2.0*a);
</code></pre>

<p>You may take a look to compiler warnings. My one (g++) prints something like this:</p>

<pre><code>file.c:24:36: error: expected ¡®)¡¯ before ¡®;¡¯ token
</code></pre>

<p>24 is a line number where you should check for an error and 36 is a column number in this line.</p>
",2
17791726,17791480,1,"<p>If you are coding in gcc use the below code and link with math library </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main()
{
 float a, b, c, rt1= 0, rt2=0, discrim;
 //clrscr();
 printf(""Welcome to the Quadratic Equation Solver!"");
 //getch();
 printf(""\nYour quadratic formula should be of the form a(x*x)+bx+c = 0"");
 printf(""\nPlease enter a\'s value:"");
 scanf(""%f"", &amp;a);
 printf(""Great! Now enter b\'s value:"");
 scanf(""%f"", &amp;b);
 printf(""One more to go! Enter c\'s value:"");
 scanf(""%f"", &amp;c);
 discrim = b*b - 4*a*c;
 if (discrim &lt; 0)
  printf(""\nThe roots are imaginary."");
 else
 {
  rt1 = (-b + sqrt(discrim))/(2.0*a);
  rt2 = (-b - sqrt(discrim))/(2.0*a);
  printf(""\nThe roots have been calculated."");
  // getch();
  printf(""\nThe roots are:\nRoot 1:%f\nRoot 2:%f"",rt1, rt2);
  // getch();
  printf(""\nThank you!"");
  //getch();
 }
}
</code></pre>

<p>and compile this way </p>

<pre><code>gcc example.c -o example -lm
</code></pre>
",3
17795737,17795722,9,"<p>Those letters modify the literal <code>1</code> and make it of type <code>unsigned long long</code>.</p>

<p>This is covered in C99 (ISO/IEC 9899) ¡ì6.4.4.1 Integer constants:</p>

<blockquote>
<pre><code>integer-suffix:
unsigned-suffix long-suffixopt
unsigned-suffix long-long-suffix
long-suffix unsigned-suffixopt
long-long-suffix unsigned-suffixopt
unsigned-suffix: one of
u U
long-suffix: one of
l L
long-long-suffix: one of
ll LL
</code></pre>
</blockquote>
",3
17795744,17795722,19,"<p>Suffix <code>ULL</code> to an integer represents type specifier. It means </p>

<pre><code>unsigned long long
</code></pre>

<p>You may also like to read <a href=""https://stackoverflow.com/a/17287767/2455888"">this</a> and <a href=""https://stackoverflow.com/q/17287957/2455888"">this one</a> for more detail.</p>
",0
17795756,17795722,5,"<p>It's a way to signal to the compiler that the value must be considered as a <code>unsigned long long</code>.</p>
",0
15876485,15876419,0,"<p>How about:</p>

<pre><code>char color[20];

printf(""Input first color band&gt; "");
scanf(""%19s"", color);

if (!strcmp(color, ""red""))
    first = 2.0;
else if (...)
</code></pre>

<p>Obviously the next step is to make a function:</p>

<pre><code>double color2number(const char *name)
</code></pre>
",2
15876688,15876419,0,"<p>This should do the job:</p>

<pre><code>#include &lt;stdio.h&gt;



int color2nr(char* color){
if(color==""red"")
   return red;
else if(color==""orange"")
   return orange;
...  
}
</code></pre>

<p>Do the same thing all the other colors...</p>

<pre><code>main(void)
{
double first;
double second;
double third;
double fourth;
double total_resist;
double black, brown, red = 2, orange, yellow, green, blue, violet, gray, white;

black=0;
brown=1;
red = 2;
orange = 3;
yellow = 4;
green = 5;
blue = 6;
violet = 7;
gray = 8;
white = 9;

char[10] buf;
printf(""Input first color band&gt; "");
scanf(""%s"", buf);
double first=color2nr(buf);

printf(""Input second color band&gt; "");
scanf(""%s"", buf);
double second=color2nr(buf);


total_resist = first + second;// + second + third + fourth;


printf(""\nTotal resist is %.lf\n"", total_resist);



return(0);
}
</code></pre>
",0
15877158,15876419,0,"<pre><code>1) try using **enum**  
</code></pre>

<p>eg :<br>
    <code>typedef enum {black,brown,red...}colorcodes;</code>  </p>

<p>declare variables as so..  </p>

<pre><code>colorcodes FstColor, SndColor;

2) `scanf(""%s\n"",FstColorStr)` and not `scanf(""%lf"",bSndColorStr);`

3)  if(strcmp(FstColorStr,""red"")) FstColor = red and so on for all other colors.

4) tot_resist = FstColor * pow(10,SndColor); //include math.h
</code></pre>
",0
16419046,16418940,6,"<p>As other stated in their answers, with <code>d = -1</code> it does not print anything as in:</p>

<pre><code>d &lt;= TOTAL_ELEMENTS
</code></pre>

<p><code>d</code> is converted to an unsigned integer type (<code>TOTAL_ELEMENTS</code> is of type <code>size_t</code> because of <code>sizeof</code>). After conversion <code>d</code> value becomes a huge unsigned integer and the comparison with  <code>TOTAL_ELEMENTS</code> value fails. </p>

<p>Then:</p>

<p><code>printf(""%d\n"",array[d+1]);</code></p>

<p>will overflow your array as the last element of your array is at index <code>TOTAL_ELEMENTS - 1</code> and you access your array up to <code>TOTAL_ELEMENTS + 1</code>.</p>

<p>To display your array elements just use the regular form starting from index <code>0</code>:</p>

<pre><code>int i;

for (i = 0; i &lt; TOTAL_ELEMENTS; i++)
{
    printf(""%d\n"", array[i]);
}
</code></pre>
",3
16419137,16418940,-1,"<p>try casting TOTAL_ELEMENTS to int</p>

<pre><code>for(d=-1;d &lt;= (int)(TOTAL_ELEMENTS);d++)
</code></pre>
",3
16419294,16418940,3,"<p>You need to understand ""Conversion rules for comparision between signed and unsigned types"". In the example, <code>for(d=-1;d &lt;= (TOTAL_ELEMENTS);d++)</code>, here d is signed int, and <code>TOTAL_ELEMENTS</code> is unsigned, and <code>d &lt;= TOTAL_ELEMENTS</code> converts d to unsigned. Unsigned -1 is huge number which is not <code>&lt; TOTAL_ELEMENTS</code>, so the loop never gets executed. Typecast as shown below. It will work.</p>

<pre><code>for(d=-1;d &lt;= (int)(TOTAL_ELEMENTS);d++)
</code></pre>
",2
17834899,17834771,0,"<p>What you are trying to achieve is <a href=""http://en.wikipedia.org/wiki/Serialization"" rel=""nofollow"">serialization</a> or <a href=""http://en.wikipedia.org/wiki/Marshalling_%28computer_science%29"" rel=""nofollow"">marshalling</a> and is commonly done when sending data across a network connection, which has the added complexity of needing to be cross-platform in many cases.</p>

<p>These days I think you should consider using <a href=""https://developers.google.com/protocol-buffers/"" rel=""nofollow"">Google Protocol Buffers</a> to achieve this, as it will do most of the heavy lifting for you.</p>

<p>An iOS or OSX-specific solution could also be <a href=""http://developer.apple.com/library/mac/#documentation/cocoa/Conceptual/CoreData/cdProgrammingGuide.html"" rel=""nofollow"">Core Data</a>.</p>

<p>Fundamentally those pointers are meaningless within the file and are relevant only to your process during a single invocation.</p>
",0
17838458,17834771,0,"<p>you can try this code:  </p>

<pre><code> #include ""stdio.h""

    struct Address {
        int id;
        int var;
        char *name;
    };

    struct Link {
        int link_var;
        struct Address *addr;
    };

    int main(int argc, char *argv[])
    {
        FILE *file = fopen(""test.dat"", ""w"");
        int i = 0;

        //struct Link *link = malloc(sizeof(struct Link) + (sizeof(struct Address)*10) + (10*10));//B2 + 10B1 +100
        struct Link *link = malloc(sizeof(struct Link));
        struct Address addr_container[10];

        for(i = 0; i &lt; 10; i++) {

            char temp_name[10];
            memset(temp_name, '\0', 10);

            temp_name[0] = 'A';

            struct Address addr_proto = {.id = i, .var = 10, .name = temp_name};

            addr_container[i] = addr_proto;
        }

        struct Link link_proto = {.link_var = 2, .addr = addr_container};

        memcpy(link, &amp;link_proto,sizeof(struct Link));// sizeof(struct Link) + (sizeof(struct Address)*10) + (10*10));

        printf(""%s\n"", link-&gt;addr[4].name);

        fprintf(file,""link_var : %d\n"",(link-&gt;link_var));
        for(i = 0; i&lt; 10; ++i)
        {
             fprintf(file,""Adress id is      :%d\n"",(link-&gt;addr[i].id));
             fprintf(file,""Adress var is     :%d\n"",(link-&gt;addr[i].var));
             fprintf(file,""Adress name is    :%s\n\n"",(link-&gt;addr[i].name));
        }
        fclose(file);
        free(link);

        return 0;
    }
</code></pre>

<p>The <strong>fwrite()</strong> write in <strong>binary</strong>,and the memory of all data <strong>is not continuous</strong>!</p>
",0
17842350,17834771,2,"<p>To ""externalize"" a memory object/data structure, e.g. when sending an object over a network to another process or writing to a file, one needs to format or convert the memory object into a portable representation.  Pointers only have meaning within a context of a process.</p>

<p>One usually ends up encoding a memory object into a portable buffer when sending or writing and decoding a portable buffer into a memory object when receiving or reading.</p>

<p>Almost all unix/linux/bsd systems have External Data Representation, XDR, library routines as part of libc. Do 'man xdr' for more info.</p>

<p>xdr is well suited if you are working with C language.</p>
",0
17793833,17793819,4,"<pre><code>int main(){
 int response
             ^
</code></pre>

<p>missing semicolon here.</p>
",0
17793836,17793819,3,"<pre><code>    int response
</code></pre>

<p>A declaration ends with a semicolon: <code>;</code>.</p>

<p>Besides, there is a lack of coherent <a href=""http://en.wikipedia.org/wiki/Indent_style"" rel=""nofollow"">indentation</a> and <code>delay</code> doesn't belong to C standard (not declared in <code>&lt;stdio.h&gt;</code>).</p>
",2
17865444,17865394,4,"<p>It is much more involved to get a web-resource than to read a file from disk, but you can absolutely do it, for example by using a library such as <a href=""http://curl.haxx.se/libcurl/c/"" rel=""nofollow"">libcurl</a>.</p>

<hr>

<p>An alternative strategy is to make components and tie them together with <code>bash</code> or other scripting. Your C program could for example read from standard input, and you could make a <code>bash</code> script something like this:</p>

<pre><code>curl http://www.ndbc.noaa.gov/data/realtime2/SPLL1.txt | ./the_program
</code></pre>

<p>This way, you could keep your core C program simpler.</p>
",7
20651117,20648793,3,"<p>This example uses <code>access</code> to replace your use of <code>fopen</code> to test the file permissions. </p>

<pre><code>void listDir(char *name, FILE *fp)
{
    DIR *dir;
    struct dirent *entry;

    if (!(dir = opendir(name)))
        return;

    if (!(entry = readdir(dir)))
        return;

    do
    {
        char readString[50]  = {0};
        char writeString[50] = {0};
        char path[1024];
        char filetype;

        snprintf(path, sizeof(path)-1, ""%s/%s"", name, entry-&gt;d_name);

        if (strcmp(entry-&gt;d_name, ""."") == 0 || strcmp(entry-&gt;d_name, "".."") == 0)
            continue;

        if (access(path, R_OK) == 0)
            strcpy(readString, ""Readable"");
        else
            strcpy(readString, ""Not Readable"");

        if (access(path, W_OK) == 0)
            strcpy(writeString, ""Writable"");
        else
            strcpy(writeString, ""Not Writable"");

        switch (entry-&gt;d_type)
        {
            case  DT_UNKNOWN: filetype = '?'; break;
            case  DT_FIFO:    filetype = 'P'; break;
            case  DT_CHR:     filetype = 'C'; break;
            case  DT_DIR:     filetype = 'D'; break;
            case  DT_BLK:     filetype = 'B'; break;
            case  DT_REG:     filetype = 'F'; break;
            case  DT_LNK:     filetype = 'L'; break;
            case  DT_SOCK:    filetype = 'S'; break;
            case  DT_WHT:     filetype = 'W'; break;
            default:          filetype = '?'; break;
        }

        fprintf(fp,""[%c]%s - %s,%s\n"", filetype, path, readString, writeString);

        if (entry-&gt;d_type == DT_DIR)
           listDir(path, fp);

    } while ((entry = readdir(dir)));

    closedir(dir);
}
</code></pre>
",2
18481589,18481566,8,"<p>This won't work since you're trying to use <code>i</code> in two very different ways in the same scope.</p>

<p>The name <code>i</code> can't refer to <em>both</em>  some <code>extern</code> data that someone else is defining, <em>and</em>  a local variable.</p>

<p>If you just want to assign to the external variable, don't re-declare it:</p>

<pre><code>extern int i;

i = 20;
</code></pre>
",2
18481601,18481566,3,"<p>You are mistakenly re declaring <code>i</code></p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
int main()
{
    extern int i;
    i=20;     //Simply assign the value here. why redeclare with `int`
    printf(""%d"",i);
}
</code></pre>
",0
18481605,18481566,3,"<p>You've already declared <code>i</code> as an <code>int</code> in </p>

<pre><code>extern int i;
</code></pre>

<p>And then you go ahead and declare it again with </p>

<pre><code>int i=20;
</code></pre>

<p>Try doing this instead</p>

<pre><code>extern int i;
i=20;
</code></pre>
",0
18481612,18481566,1,"<p>you have declared <code>i</code> twice which resulted in redefinition error</p>
",0
18481889,18481566,1,"<pre><code>int i;
</code></pre>

<p>Here variable i is declared and memory is allocated for it but not initialized.</p>

<pre><code>extern int i;
</code></pre>

<p>Whenever extern is used, the variable is just declared and memory will not be allocated for it. In order to access it you have to redeclare same variable externally.
Here extern refers to that, you will be defining the value of that variable(i) outside the program(external source). In your case, you do it inside so it will not work as you expected. It can be either defined outside main program or by external programs.</p>

<p>Try this:</p>

<pre><code>#include&lt;stdio.h&gt;
int main()
{
   extern int i; //Declared but memory not allocated
   printf(""%d"",i);
 return 0;
 }
int i=20; //Allocated memory for i and initialized to 20 outside the prog
</code></pre>

<p>Output:</p>

<pre><code>20
</code></pre>

<p>Global extern variables can also be initialized directly, where as local extern variables cannot be.</p>

<pre><code>#include&lt;stdio.h&gt;
extern int i=10; //Declared, Memory allocated and defined.
int main()
{
    extern int j; //Declared but memory not allocated
    printf(""%d --&gt; %d"",i,j);
return 0;
}
int j=20; //Memory Allocated and value defined externally.
</code></pre>

<p>Output:</p>

<pre><code>10 --&gt; 20
</code></pre>

<p>You can also refer to this <a href=""http://www.geeksforgeeks.org/understanding-extern-keyword-in-c/"" rel=""nofollow"">link</a> to know more about it.</p>
",0
18982369,18982311,3,"<p>You have to declare array of strings, not <code>char</code> array.</p>

<pre><code>char const * names[] = {""Sam"", ""Michael"", ""Greg"", ""Phil""};
</code></pre>

<p>Or if you want mutable array:</p>

<pre><code>char names[][MAX_NAME_LEN] = {""Sam"", ""Michael"", ""Greg"", ""Phil""};
</code></pre>
",4
18387164,18386848,0,"<p><code>-(1&lt;&lt;7)</code> is not <code>0xffffff80</code>. <code>1&lt;&lt;7</code> is 1 times 2 to the 7th power, i.e. 128. So <code>-(1&lt;&lt;7)</code> is -128. The most likely explanation for why you're seeing it as <code>0xffffff80</code> is that you're invoking undefined behavior by passing it to <code>printf</code> for use with the <code>%x</code> format specifier. <code>%x</code> takes an <code>unsigned int</code> argument (and can also take a signed <code>int</code> as long as the value is non-negative) but the argument you're passing has type <code>int</code> and is negative. Therefore, undefined behavior results.</p>
",6
18386903,18386848,0,"<p>The minus operator (is implementation defined but most likely to) is going to perform a two's complement on its argument (128 decimal in this case). 2's complement is: subtract 1 and invert all the bits.</p>
",0
18386951,18386848,0,"<p>The significant bits are filled with 1 because they represent the sign and repeating them won't affect the value. For a positive number, <strong>10</strong> and <strong>010</strong> and <strong>0000010</strong> are all equal. And since a  most significant bit of <strong>1</strong> represents negative, putting as many 1s as much as you want in front of a negative number don't affect the magnitude. You can check this fact using 2s complement arithmetic. </p>
",1
18387389,18386848,0,"<p>The answer is very simple and results from the way how negavie numbers are save in computer's memory.</p>

<p>I guess it is obvious for you what 1 &lt;&lt; 7 means. It equals to 128. Your ""-"" sign just means you want to change te sign of the result so the final result is -128.</p>

<p>But why did you get someting different? Here is the answer:</p>

<p>Generally there a two types of variables: signed and unsigned.
Both types are saved in momory which actually doesn't know which type is begin used. It is just up to programmer to know what kind of number is stored.</p>

<p>When you declare a variable as unsigned, it can store values from 0 to n, where n is the maximum value for a certain type of variable. </p>

<p>When you use signed one, you can store there a value from defined negative value, up to some defined positive value.</p>

<p>When unsigned variable is used, it is very simple to calculate is value.
Please consider a simple example of 8 bit (1  byte) unsigned variable:</p>

<p>the minimum value is 0 as I said before, and the maximum is 255 when all of 8 bits are set.</p>

<p>For the signed type of variable a special format is being used:
numbers from 0 to 127 are being saved the same way as for unsigned type. And the value of 127 is the maximum for a 8 bit variable. The minimum value is -128 and is stored as 0b10000000 or 0x80. Next one is -127 and is saved as 0b10000001 or 0x81 and so on. The biggest, negative number is -1 and is saved as 0b11111111 or 0xFF.</p>

<p>So if you have a byte value 0xff it can be both: 255 (when unsigned) or -1 (when signed).
The notation used here for signed types of variables is called U2 - please read about this.</p>

<p>In your particular case it looks like you have a signed (-128) value which was read as unsigned one. In your case a 32 bit (4 bytes) variable (probably (unsigned) int) was used so it looks a little bit different (the result is longer), but you may see some similarity: the last two digits for -128 in U2 system will always be 0x80 no matter how many bits are being used to store the value.</p>
",1
18388195,18386848,2,"<p>First of all, thank-you for this question.  It is usually a good idea to code a test program to illustrate something you are not sure about and then try different things to figure out the details.</p>

<p>Comments, like that is UB, are usually not accurate.  In this case what happens is very predictable and reasonable and is exactly what an experienced programmer should expect.</p>

<p>I ran the following code on Eclipse/Microsoft C compiler:</p>

<pre><code>#include &lt;stdio.h&gt;
main()
{
    int i;
    unsigned int j;

    i = -(1&lt;&lt;7);
    printf(""%i\n"", i);
    printf(""%08x\n"", i);

    j = -(1&lt;&lt;7);
    printf(""%u\n"", j);
    printf(""%08x\n"", j);
}
</code></pre>

<p>And got the following output:</p>

<pre><code>-128
ffffff80
4294967168
ffffff80
</code></pre>

<p>These are expected, because: (1 &lt;&lt; 7) equals 128 and -(128) is -128.  The <code>printf</code> of the contents of i produced exactly the value of -128 in binary form.</p>

<p>The way to see this is to take the 2's complement of ffffff80 = 0000007f + 1 = 00000080 which is 128 in binary.  Thus, you can see that taking the 2's complement of a number is how we take the negative of an integer.</p>

<p>The really big number is the unsigned value of the same contents.</p>

<p>Whenever possible write-up a little bit of code to examine how stuff works!</p>
",2
18200346,18200316,0,"<p><strong>Problems</strong></p>

<ol>
<li><p>only one byte memory available for <code>name</code> field. use like <code>char name[100]</code></p></li>
<li><p>use <code>strcpy()</code> instead of <code>b1.name = ""John""</code>;</p></li>
</ol>
",0
18200363,18200316,0,"<p>You clearly want a string variable in your <code>struct</code>, but you declared it as <code>char name;</code> (a <em>single</em> character).</p>

<p>Instead, use a <code>char</code> pointer (<code>const char *name</code>), or a <code>char</code> array (<code>char name[100]</code>). In the latter case, you will have to use <code>strcpy(b1.name, ""John"")</code>.</p>
",0
18200520,18200316,0,"<p>The problem is that you have declared <code>name</code> as a <code>char</code>. That means <code>name</code> will hold only a single <code>char</code>, not an entire string.</p>

<p>You can statically allocate <code>name</code> as an array of <code>char</code>:</p>

<pre><code>char name [25]  // or whatever length you think is appropriate
                // remember to leave room for the NUL character
</code></pre>

<p>Then you will need to use <code>strcpy()</code> to copy the actual name into the structure. </p>

<p>Alternatively, you can declare <code>name</code> as a pointer to char:</p>

<pre><code>char* name;
</code></pre>

<p>In this case, you can set the pointer to a string literal:</p>

<pre><code>name = ""John"";
</code></pre>

<p>But in most real life situations, this is not an option, as you will be reading the name in from a file or standard input. So you will need to read it into a buffer, set the pointer to dynamically allocated memory on the heap (the string length of the buffer + 1 for the <code>NUL</code>), and then use <code>strcpy()</code>. </p>
",0
18200602,18200316,0,"<p>You have to do some tweaks to your code in order to make it work.</p>

<pre><code>char name;  // only one byte is allocated.
</code></pre>

<p>Define char array to store strings in C.</p>

<pre><code>char name[20]; //stores 20 characters
char *name; //Pointer variable. string size can vary at runtime.
</code></pre>

<p>Once you have created a object for your structure than you can feed data only using that object.</p>

<p>(i.e) object.element=something;</p>

<pre><code>b1 = {""John"", 12.00, 18}; // Not possible
</code></pre>

<p>The above initialization is possible only while defining objects.</p>

<pre><code>struct book b1={""John"", 12.00, 18}; //Possible
</code></pre>

<p>If  <strong>char *name</strong> is defined inside struct, you can do the following. </p>

<pre><code>struct book b1;
b1.name=""John"";   // Possible
b1.price=12.00;   // Possible
b1.pages=18;      // Possible
</code></pre>

<p>If you use char array <strong>char name[20]</strong> then you can do the following.</p>

<pre><code>struct book b1;
strcpy(b1.name,""John"");  // Possible
b1.price=12.00;     // Possible
b1.pages=18;       // Possible
</code></pre>
",2
17850934,17850851,7,"<p>Because  postfix operators have higher precedence than prefix operators, so the expression <code>++i++</code> is equivalent to  <code>++(i++)</code>, that is equivalent to  <code>++( i + 1)</code>. The compiler gives l-value error because you are applying <code>++</code> on an expression <code>(i++)</code> that is <em>not</em> a modifiable lvalue, so not a valid expression in <a href=""/questions/tagged/c"" class=""post-tag"" title=""show questions tagged &#39;c&#39;"" rel=""tag"">c</a> according to increment operator definition.</p>
<p>According to Dennis M. Ritchie's book: <a href=""http://zanasi.chem.unisa.it/download/C.pdf"" rel=""nofollow noreferrer"">&quot;The C Programming Language&quot;</a>:</p>
<blockquote>
<h3>2.8 Increment and Decrement Operators</h3>
<p>(page 44)</p>
<p>The increment and decrement operators can only be applied to variables; an expression like <code>(i + j)++</code> is illegal. The operand must be a <code>modifiable lvalue</code> of arithmetic or pointer type.</p>
</blockquote>
<p><strong>Related:</strong> An interesting bug one may like to know about in gcc 4.4.5 is that expression <code>j = ++(i | i);</code> compiles that should produce l-value error. Read: <a href=""https://stackoverflow.com/questions/14860189/j-i-i-and-j-i-i-should-an-error-lvalue""><code>j = ++(i | i);</code> and <code>j = ++(i &amp; i);</code> should an error: lvalue?</a></p>
<p>Additionally, modifying same variable more then once in an expression without an intervening <a href=""http://en.wikipedia.org/wiki/Sequence_point"" rel=""nofollow noreferrer"">sequence point</a> causes which is <a href=""http://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behavior</a> in <a href=""/questions/tagged/c"" class=""post-tag"" title=""show questions tagged &#39;c&#39;"" rel=""tag"">c</a> and <a href=""/questions/tagged/c%2b%2b"" class=""post-tag"" title=""show questions tagged &#39;c++&#39;"" rel=""tag"">c++</a>. To understand read <a href=""https://stackoverflow.com/questions/949433/could-anyone-explain-these-undefined-behaviors-i-i-i-i-i-etc"">Explain these undefined behaviors in <code>i = i++ + ++i;</code></a>.</p>
",6
17851050,17850851,0,"<p>this line:</p>

<pre><code>printf(""%d"",++i++)
</code></pre>

<p>==></p>

<pre><code>printf(""%d"",(++i)++)
</code></pre>

<p>And </p>

<p>==></p>

<pre><code> printf(""%d"",(++i)); &amp;(++i)++ ==&gt; (++i) = (++i) +1;
</code></pre>

<p>See you use (++i) as a left value.</p>
",0
17851052,17850851,0,"<p>This is because you are doing increment to a constant..</p>

<p>In your case </p>

<pre><code>++i =&gt; 6
++i++ =&gt; 6++ //this is not possible. Gives lvalue error
++i+10 =&gt; 6+10 =&gt; 16 //this is possible
</code></pre>

<p>So doing ++i++ is not good.  <strong>Post increment/decrement, pre increment/decrement possible only on variables</strong>. At runtime your statement will become a constant so it gives lvalue error here.</p>

<pre><code>++i =&gt; 6 =&gt; i=6;
i++ =&gt; 6 =&gt; i=7;
printf(""%d"",i); //7
</code></pre>
",0
17851099,17850851,0,"<p>The expression <code>++i++</code> is evaluated as <code>++(i++)</code> which is illegal in C as the postfix increment returns a value and prefix incrementing on a that <em>value</em> makes no sense. </p>

<p>What you have is somewhat equivalent to: <code>++(5)</code> which is obviously illegal as you can apply prefix increment on something that's not a l-value.</p>
",0
17851106,17850851,1,"<p>Generally, you should not be doing this, as it obscures the code.<br>
The reason you're getting the error is that the post-increment has precedent and thus returns an r-value, i.e. <code>++i++ == ++(i++)</code> which cannot be incremented.</p>

<p>However, you <em>can</em> use <code>(++i)++</code> since the pre-increment (apparently, on VS2010) returns <code>i</code> itself, an l-value which <em>can</em> be post-incremented.</p>
",5
18255674,18255383,-1,"<p>Simply write a function like this:</p>

<pre><code>char * combineargv(int argc, char * * argv)
{
    int totalsize = 0;
    for (int i = 0; i &lt; argc; i++)
    {
       totalsize += strlen(argv[i]);
    }
    // Provides space for ' ' after each argument and a '\0' terminator.
    char *ret = malloc(totalsize + argc + 1);
    if (NULL == ret)
    {
        // Memory allocation error.
    }
    for (int i = 0; i &lt; argc; i++)
    {
        strcat(ret, argv[i]);
        strcat(ret, "" "");
    }
    return ret;
}
</code></pre>

<p>This will simply combine all of them, placing spaces between args</p>

<p><em>Update:</em> I have modified the original to eliminate the buffer overflow issue.</p>
",10
18255825,18255383,0,"<p>It depends on the platform.</p>

<p>In Windows, you can use <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/ms683156%28v=vs.85%29.aspx"" rel=""nofollow""><code>GetCommandLine()</code></a>.</p>
",0
18255472,18255383,2,"<p>What you can do is to loop over argv and build a string with <code>strcat</code></p>

<pre><code>char* CommandLine = 0;
unsigned int CommandLineLength = 0;
unsigned int i = 0;

for (i = 0; i &lt; argc; i++) {
    CommandLineLength += strlen(argv[i]) + 3; // Add one extra space and 2 quotes
}

CommandLine = (char*) malloc(CommandLineLength + 1);
*CommandLine = '\0';

// Todo: Check if allocation was successfull...

for (i = 0; i &lt; argc; i++) {
    int HasSpace = strchr(argv[i], ' ') != NULL;
    if (HasSpace) {
        strcat(CommandLine, ""\"""");
    }
    strcat(CommandLine, argv[i]);
    if (HasSpace) {
        strcat(CommandLine, ""\"""");
    }
    strcat(CommandLine, "" "");
}
// Do something with CommandLine ...
free(CommandLine);
</code></pre>
",16
18677200,18677083,0,"<p>The value is just 'HELL' interpreted as an <code>int</code> (usually 4 bytes).</p>

<p>If you try this:</p>

<pre><code>#include &lt;stdio.h&gt;

int main (void)
{
    union {
        int x;
        char c[4];
    } u;
    int i;

    u.x = 'HELL';
    printf(""%d\n"", u.x);
    for(i=0; i&lt;4; i++) {
        printf(""'%c' %x\n"", u.c[i], u.c[i]);
    }
    return 0;
}
</code></pre>

<p>You'll get:</p>

<pre><code>1212501068
'L' 4c
'L' 4c
'E' 45
'H' 48
</code></pre>
",8
18677121,18677083,13,"<p><code>1212501068</code> in hex is <code>0x48454c4c</code>.</p>

<ul>
<li><code>0x48</code> is the ASCII code for <code>H</code>.</li>
<li><code>0x45</code> is the ASCII code for <code>E</code>.</li>
<li><code>0x4c</code> is the ASCII code for <code>L</code>.</li>
<li><code>0x4c</code> is the ASCII code for <code>L</code>.</li>
</ul>

<p>Note that this behaviour is implementation-defined and therefore not portable. A good compiler would issue a warning:</p>

<pre><code>$ gcc test.c
test.c: In function 'main':
test.c:4:11: warning: multi-character character constant [-Wmultichar]
</code></pre>
",2
18677277,18677083,3,"<p>Others have explained what happened. As for the explanation, I quote from C99 draft standard (N1256):</p>

<blockquote>
  <h3>6.4.4.4 Character constants</h3>
  
  <p>[...]</p>
  
  <p>An integer character constant has type <code>int</code>. The value of an integer character constant containing a single character that maps to a single-byte execution character is the numerical value of the representation of the mapped character interpreted as an integer. <strong><em>The value of an integer character constant containing more than one character (e.g.,'ab'), or containing a character or escape sequence that does not map to a single-byte execution character, is implementation-defined.</em></strong> If an integer character constant contains a single character or escape sequence, its value is the one that results when an object with type char whose value is that of the single character or escape sequence is converted to type int.</p>
</blockquote>

<p>The emphasis on the relevant sentence is mine.</p>
",0
18677129,18677083,9,"<p>In C, single quotes are used to denote characters, which are represented in memory by numbers. When you place multiple characters in single quotes, the compiler combines them in a single value however it wants, as long as it documents the process.</p>

<p>Looking at your number, 1212501068 is 0x48454C4C. If you decompose this number into bytes, you get <code>48</code> or 'H', <code>45</code> or 'E' and twice <code>4C</code> or 'L'</p>
",1
18677133,18677083,3,"<p>The output of 1212501068 as hex is: <code>0x48 0x45 0x4C 0x4C</code></p>

<p>Look it up in an <a href=""http://www.asciitable.com/"" rel=""nofollow noreferrer"">ASCII table</a>, and you'll see those are the code for <code>HELL</code>.</p>

<p><strong>BTW:</strong> single-quotes around a multi-char value are not standardized.<br>
The exact interpretation of single-quotes around multiple characters is Implementation-Defined.  But it is very common that it either comes out as a Big-Endian or Little-Endian integer. (Technically, the implementation could interpret it <em>any way it chooses</em>, including a random value).</p>

<p>In otherwords, depending on the platform, I would not be surprised to see it come out as:<br><code>0x4C 0x4C 0x45 0x48</code>, or <code>1280066888</code></p>

<p>And over on <a href=""https://stackoverflow.com/questions/4165131/c-c-switch-for-non-integers/18592322#18592322""><strong>this question</strong></a>, and also on <a href=""http://www.terathon.com/wiki/index.php/Simple_Actions_-_%27Hello_World%27_redux"" rel=""nofollow noreferrer""><strong>this site</strong></a> you can see practical uses of this behavior.</p>
",4
18677137,18677083,1,"<p>Line:</p>

<pre><code>int x = 'HELL';
</code></pre>

<p>save to memory hex values of 'HELL' and it is 0x48454c4c == 1212501068.</p>
",4
17864164,17864110,2,"<p>You are using a variable before initializing its value:</p>

<pre><code>while (ch != '\n') {
</code></pre>

<p>Anything could happen since the initial value of <code>ch</code> is not known.  However, the odds are high (255 out of 256 chances) that the expression is initially true.  After it has entered the loop once, all is well.</p>

<p>For the loop to work as expected, do not store <code>\n</code> in the buffer.  Since <code>s2</code> does not contain <code>\n</code>, <code>strcmp()</code> will never match as long the the newline is stored in there.</p>
",1
18980567,18980437,1,"<p>It is possible when memory is not protected, like in a small embedded system.
An Arduino with its AVR processor is an example where you can do that.</p>

<pre><code>#define MEMORY_SIZE 1024 // 1 KB

char* lastBytePtr = (char*)(MEMORY_SIZE-1);
char lastByteValue = *lastBytePtr;
</code></pre>
",0
18980513,18980437,0,"<p>It is generally not possible. Modern operating systems have mappings between application memory and physical memory. It is possible to do it if you write a kernel (system) function, but then you need to specify which operating system you are using.</p>
",0
18982102,18980437,1,"<p>No, since the language C does not specify the underlying memory architecture.</p>

<p>On select OS/architecture you may in an OS dependent or creative fashion.</p>
",0
18128685,18128582,0,"<p>You are reading in byte values in ascii. You need to either use a library function like <code>strtol</code> to convert to actual values.</p>

<p>Although I think there is a typo in your question - I doubt <code>0</code> is coming out as <code>53</code>, that's ascii for <code>3</code></p>

<p>If you know it is a digit, you can do</p>

<pre><code>x-='0';
</code></pre>

<p>to get the value.</p>
",4
19213392,19213379,3,"<p>Sure:</p>

<pre><code>node x[4] = { {0, NULL}, {1, NULL}, {2, NULL}, {3, NULL} };
</code></pre>

<p>Even this should be fine:</p>

<pre><code>node y[4] = { {0, y + 1}, {1, y + 2}, {2, y + 3}, {3, NULL} };
</code></pre>
",7
16374696,16374675,2,"<p>In this line</p>

<pre><code>n = i/j;
</code></pre>

<p>you are performing integer division. So, for example, let's say that <code>i</code> is 3 and <code>j</code> is 5, then you perform <code>3/5</code> which equals <code>0</code>. </p>

<p>But I think you are looking to perform <code>3.0/5.0</code> and hoping for the answer <code>0.6</code>. So you need to perform floating point division. You can force that by casting one of the operands to a float.</p>

<pre><code>n = (float)i/j;
</code></pre>

<hr>

<p>In the question you wrote <code>Int</code> rather than <code>int</code>. I assumed that was a transcription error when asking the question. But perhaps your real code looks like that. In which case, you'll need to change it to <code>int</code> to get it to compile.</p>

<p>The other possible problem you have is that the program expects arguments to be passed on the command line. Are you passing two arguments to your program? In other words you need to execute your program like this:</p>

<pre><code>program.exe firstword secondword
</code></pre>

<p>If you are not passing arguments then you will encounter runtime errors when attempting to access non-existent arguments in <code>argv[]</code>. At the very least you should add a check to the program to ensure that <code>argc==3</code>. </p>

<p>If you want to read the input from <code>stdin</code>, rather than passing command line arguments, use <code>scanf</code>.</p>
",7
16374777,16374675,1,"<p>I think this is a conceptual error. Your program (probably) runs fine when called like this:</p>

<pre><code>myapp word1 word2
</code></pre>

<p>But I think you expect it to work like this:</p>

<pre><code>myapp
Insert first word:
&gt; word1
Insert second word:
&gt; word2
</code></pre>

<p>But that's not what <code>argv</code> is about. You should look into <a href=""http://en.cppreference.com/w/c/io/fscanf"" rel=""nofollow""><code>scanf</code></a></p>

<p>Specifically, the error in the second case is because <code>argv[1]</code> is NULL, so <code>argv[1][i]</code> is a bad memory access.</p>
",0
16386282,16386241,3,"<p>Changing the <code>priceperitem</code> to <code>int</code> will give different result due to integer division. </p>

<p>Change <code>discount=quantity*priceperitem*10/100;</code></p>

<p>To <code>discount=quantity*priceperitem*10/100f;</code></p>
",2
16386292,16386241,0,"<p>If it changes from and int to a float it won't take into account decimal places, perhaps this is your change in answer due to integer division change</p>
",1
16439510,16439250,1,"<pre><code>clock_gettime(CLOCK_REALTIME, &amp;t2[0]);    //Critical Section Start  
generate_str(n);
str_sort(n);
check_sort();
clock_gettime(CLOCK_REALTIME, &amp;t2[1]);
</code></pre>

<p>Could be that the three methods execute so fast that the system clock doesn't progress. You could try and get a higher solution by changing <code>CLOCK_REALTIME</code> to <code>CLOCK_THREAD_CPUTIME_ID</code> or <code>CLOCK_PROCESS_CPUTIME_ID</code>.</p>
",0
19576028,19575647,0,"<p>There are several problems:</p>

<ul>
<li><code>float *array[MAX];</code> is a pointer to an array of floats. You should
use either an array of floats or a pointer. Since you are using
<code>malloc</code>, you can use a pointer like this: <code>float *array;</code></li>
<li>Do not call malloc for each float, but call it once for the entire array</li>
<li>If you define <code>MEAN</code> and <code>SD</code> as pointers, you will have to use
<code>malloc</code> on them. It is better to declare them as float only and use
their addresses (via <code>&amp;MEAN</code> and <code>&amp;SD</code>).</li>
<li>You <code>sum</code> variable should be a <code>float</code>, and you should initialize it
to <code>0</code>. You should also set it to <code>0</code> before calculating <code>stdev</code>.</li>
<li>Remember that <code>argv[0]</code> contains the name of your program, so
you should ignore it.</li>
<li>Also remember to call <code>free</code> on anything you allocate with <code>malloc</code>
when you are done with it.</li>
</ul>

<p>A modified version of your code:</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;math.h&gt;
#include&lt;string.h&gt;

void calc(float*, int, float*, float*);

int main( int argc, char* argv[] ) {
    float *array;
    float MEAN;
    float SD;
    int array_size, i;
    array_size = argc-1;
    array = (float *) malloc( array_size*sizeof(float));
    for( i = 0; i &lt; array_size ; ++i ) {
        array[i] = atof(argv[i+1]);
    }
    calc(array, array_size, &amp;MEAN, &amp;SD);
    free (array);
    return 0;
}

void calc(float* arr , int arr_size, float* mean, float* stdev) {
    float sum=0;
    int i;
    for ( i = 0; i &lt; arr_size ; ++i ) {
        sum += arr[i];
    }
    *mean = sum / arr_size;
    printf(""%.2f "", *mean);
    sum=0;
    for ( i = 0; i &lt; arr_size ; ++i ) {
        sum += pow((arr[i]-*mean), 2);
    }
    *stdev = sqrt((sum/arr_size));
    printf(""%.2f"", *stdev);
}
</code></pre>
",1
19576192,19575647,0,"<p>You have several problems,</p>

<ul>
<li>check that you have at least one argument</li>
<li>you declared array as an array of pointers to float, either use <code>array[]</code>, or <code>*array</code></li>
<li>your array need only be allocated once</li>
<li>allocate an array of number of <code>samples*sizeof(float)</code>, once, before loop</li>
<li>store values read into <code>array[ndx]</code> locations (atof is fine)</li>
<li>argv starts at program name, store into <code>array[n]</code> the value converted from <code>argv[n+1]</code></li>
<li>MEAN and SD need space, you declared pointers, change to value, and pass address (&amp;)</li>
</ul>

<p>Here is the revised main(),</p>

<pre><code>int main( int argc, char* argv[] )
{
    //float array[MAX];
    float *array;
    float MEAN;
    float SD;
    int array_size, ndx;

    if(!(argc&gt;0)) { printf(""please give 1 or more arguments\n""); exit(1); }

    array_size = argc-1; //don't count the program name
    array = (float*) malloc(array_size*(sizeof(float)));
    for( ndx = 1; ndx&lt;argc ; ++ndx )
    {
        array[ndx-1] = atof(argv[ndx]);
        printf(""[%d] %f\n"",ndx-1,array[ndx-1]);
    }

    calc(array, array_size, &amp;MEAN, &amp;SD);
    free(array); array=NULL; //always clean up after yourself
    return 0;
}
</code></pre>

<p>Your statistics calculations need work, but this at least compiles and runs,</p>

<ul>
<li>you need to link against libmath (see below),</li>
<li>your sum was not initialized, before either loop,</li>
<li>pow and sqrt return double - read about C math functions and passing double,</li>
<li>your array_size needs to be set carefully</li>
</ul>

<p>Here,</p>

<pre><code>void calc(float arr[] , int arr_size, float* _mean, float* _stdev)
{
    double sum, mean, stddev;
    int i;

    sum=0.0;
    for ( i = 0; i &lt; arr_size ; ++i )
    {
        sum += arr[i];
        //printf(""[%d] %f\n"",i,arr[i]);
    }
    printf(""sum %f\n"",sum);
    *_mean = mean = sum / arr_size;
    printf(""mean %f\n"",mean);
    printf(""%.2f\n"", *_mean);

    sum=0.0;
    for ( i = 0; i &lt; arr_size ; ++i )
    {
        sum += pow((arr[i]-mean), 2);
        //printf(""[%d] %f\n"",i,arr[i]);
    }
    printf(""sum^2 %f\n"",sum);
    *_stdev = stddev = sqrt((sum/arr_size));
    printf(""stddev %f\n"",stddev);
    printf(""%.2f\n"", *_stdev);
}
</code></pre>

<p>Oh, you want to link to libmath,</p>

<pre><code>cc stddev.c -lm -o stddev
</code></pre>

<p>And when running it,</p>

<pre><code>$ ./stddev 1 2 3 4 5
[0] 1.000000
[1] 2.000000
[2] 3.000000
[3] 4.000000
[4] 5.000000
sum 15.000000
mean 3.000000
3.00
sum^2 10.000000
stddev 1.414214
1.41
</code></pre>

<p><em>Also, you need to free the memory you malloc'ed (array).  This is good habit, though not needed for this tiny program.</em></p>
",0
19575722,19575647,0,"<p>You are allocating and accessing <code>array</code> wrongly. Should be like this:</p>

<pre><code>for( i = 0; i &lt; argc ; ++i )
{
    array = malloc( argc * sizeof(*array));
    array[i] = atof(argv[i]);
}
</code></pre>

<p>Also inside <code>calc()</code> function change <code>*arr[i]</code> to <code>arr[i]</code> everywhere.</p>
",0
19575735,19575647,0,"<p>This is definitely wrong :</p>

<pre><code>*array = (float *) malloc( argc*(sizeof(float)));
</code></pre>

<p>You are allocating an array of floats after declaring the array. This does not make sense. Then you are dereferencing the values wrongly. In addition, in your code your are trying to   transform the name of the program (<code>argv[0]</code>) to an int type. </p>

<p>This may be what you wanted to do :</p>

<pre><code>float * array = NULL;  

array = malloc( (argc-1)*(sizeof(float))); 

for (i=1; i&lt;argc; ++i)
    array[i]=atof(argv[i]); 
</code></pre>

<p>This code reserves a memory location in the heap of size <code>(argc-1)*float</code>, and  initialises it with the values specified as command line parameters. A check should be inserted when <code>argc</code> is 1. </p>
",0
18247375,18247163,0,"<p>Ok so what strstr does is if string2 is located somewhere in string1, it returns a pointer in string1 to where the first occurrence of string2 is located.  This pointer is a char pointer.  Meaning it's memory allocation is sizeof(char).  </p>

<p>I'm assuming you don't quite understand pointers so i'll give you a quick tutorial.  So what a pointer is, is basically a variable that contains the location in memory of something else.  It essentially points to somewhere else in memory.  This case, you have line1 located somewhere on your computer in memory, say computer address 0-29.  What chp does is just store where in that address range of 0-29 line2 starts.  So if your line1 is ""hello there people"" and line2 is there.  then chp will be pointing to address 6, which is where ""there"" starts in line1.  It's only a pointer though, it does not contain the whole memory.  Only line1 contains the whole memory for the string.  Pointers only ever point to a location in memory, and aren't the memory variables themselves.  Does this help?</p>
",3
18247530,18247163,0,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main()
{
    char line1[30];
    char line2;                 // here is a char  not char []
    char *chp;
    puts(""Enter line1:"");
    fgets(line1,30,stdin);      // use fgets
    puts(""Enter Line2"");
    line2 = fgetc(stdin);
    chp=strchr(line1,line2);
    if(chp)
        printf(""%s String is present in Given String"",chp);
    else
        printf(""%s String is not present in Given String"",line2);
    return 0;
}
</code></pre>
",0
18247230,18247163,1,"<p>The strstr function searches within the string pointed to by s1 for the string pointed to by s2. <strong>It returns a pointer to the first occurrence in s1 of s2.</strong></p>

<p>Therefore it stores only <strong>one memory location,</strong> the pointer to where the line2 is found in line1, otherwise null..</p>
",0
18247261,18247163,1,"<p>Let's say that a user runs your program and enters strings like this:</p>

<pre><code> Enter line1:
 StackOverflow
 Enter line2:
 Over
</code></pre>

<p>gets() will write the string ""StackOverflow.com"" into the line1 array, and the string ""Over"" into the line2 array.</p>

<p>Let's imagine (just for the sake of discussion) that the line1 array is located in memory at address 0x1000.  A memory dump (showing each byte's address in memory, followed by the character that is stored there) might look like this:</p>

<pre><code>0x1000   S
0x1001   t
0x1002   a
0x1003   c
0x1004   k
0x1005   O
0x1006   v
0x1007   e
0x1008   r
0x1009   f
0x100A   l
0x100B   o
0x100C   w
0x100D   \0  (i.e. the NUL terminator byte that indicates the end of the string)
[and the remaining 16 bytes of the array are undefined garbage, so we'll ignore them]
</code></pre>

<p>What strstr() is going to do in this case is look for the first instance of the substring ""Over"" in the above array, and return a pointer to first char of that substring if it finds it.  So in this case, strstr() would return the value 0x1005, since that is the memory location of the ""O"" character in ""Over"".</p>

<p>If the first string did not contain the second string, strstr() would return NULL instead.</p>
",0
18295414,18295095,0,"<p>See the output of ""man scanf"". </p>

<pre><code>   d      Matches  an  optionally signed decimal integer; the next pointer
          must be a pointer to int.
</code></pre>

<p>...</p>

<pre><code>   i      Matches an optionally signed integer; the next pointer must be a
          pointer  to  int.   The  integer is read in base 16 if it begins
          with 0x or 0X, in base 8 if it begins with 0,  and  in  base  10
          otherwise.   Only  characters  that  correspond  to the base are
          used.
</code></pre>

<p>That means: %d just read an signed decimal integer. %i read an signed integer, decimal/oct/hex depends on your input. It begins with 0x or 0X is hex, begins 0 is oct, others are decimal.</p>
",0
18388153,18388039,3,"<p>You do not have to divide the commands into separate <code>char</code> arrays - all you need is replacing <code>#</code>s with <code>\0</code>s within the array of characters that you received, and save the positions of the ""breaks"" in the string. Here is an illustration:</p>

<pre><code>Index:  0   1   2   3   4   5   6   7   8   9  10  11  12
       --- --- --- --- --- --- --- --- --- --- --- --- ---
Char:  '1' '0' '0' '#' '2' '0' '0' '#' '3' '0' '0' '#' \0
</code></pre>

<p>replace this with</p>

<pre><code>Index:  0   1   2   3   4   5   6   7   8   9  10  11  12
       --- --- --- --- --- --- --- --- --- --- --- --- ---
Char:  '1' '0' '0'  \0 '2' '0' '0' \0  '3' '0' '0' \0  \0
</code></pre>

<p>and store pointers to <code>&amp;str[0]</code>, <code>&amp;str[4]</code>, and <code>&amp;str[8]</code> as pointers to your individual commands.</p>

<pre><code>char[] str = ""100#200#300#"";
char *p1 = str;
char *p2 = strchr(p1, '#');
// Replace the first '#'
*p2++ = '\0';
// Replace the second '#'
char *p3 = strchr(p2, '#');
*p3++ = '\0';
// Replace the third '#'
*strchr(p3, '#') = '\0';
printf(""One='%s' Two='%s' Three='%s'\n"", p1, p2, p3);
</code></pre>

<p>This is only a demo: in production code you would need to check the return values of <code>strchr</code> before making assignments.</p>
",4
18388096,18388039,0,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main ()
{
  char string[] =""100#100#100"";
  char * commands;

  commands= strtok (str,""#"");
  while (commands!= NULL)
  {
    printf (""%s\n"",commands);
    commands = strtok(NULL, ""#"");

  }
  return 0;
}
</code></pre>
",7
18388309,18388039,0,"<p>Use this implementation. </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main ()
{
    char string[] =""100#100#100"";
    char * commands;

    commands= strtok (string,""#"");
    printf(""%s\n"", commands);   // &lt;=== this is the first token 

    while (commands!= NULL) {
      commands= strtok (NULL,""#""); // &lt;=== this will give further tokens 
                                   // Note - you need to call strtok again 
                                   // Note2 - you need to call with parameter NULL 
                                   //         for further tokens  
      printf (""%s\n"",commands);
    }


   return 0;
}
</code></pre>
",0
17772439,17772417,1,"<p>You could process each character one by one, and increment a counter that you print before the character when you encounter a carriage return (<code>\n</code>).</p>

<p>In pseudo-code:</p>

<pre><code>lineNumber = 1;
Open the file
While ((c = read a character) is not EOF)
    If (c is \n)
        Print ""lineNumber"", then increment it
    Print c
End while
Close the file
</code></pre>
",0
18863931,18863919,1,"<p>Your <code>printf</code> call might be being buffered which means it might not actually be printed until the buffer fills up or a newline is encountered.</p>

<p>Try adding a newline to the end of your string or call <code>fprintf(stderr, ...)</code> instead (which isn't buffered).</p>
",0
18864048,18863919,1,"<p>Your program is infinite looping the first time through the loop.</p>

<p>When i = 0 this loop never ends:</p>

<pre><code>for(j=2;(i*j)&lt;n;j++)
</code></pre>
",0
17805036,17804966,3,"<pre><code>#include &lt;stdio.h&gt;
int main()
{
    printf(""sun, mon, tue, wed, thru, fri, sat\n"");
    return 0;
}
</code></pre>

<p>Is that what you were trying to do?</p>
",4
17805439,17804966,2,"<p>enum is used as an userdefined datatype. you can create your own datatype using following syntax. enum can be used to setup collection of named integer constants. </p>

<pre><code>enum datatype_name {val1,val2,val3,...,valN};
</code></pre>

<p>By default enum value will be generated from 0. Here,</p>

<pre><code>val1=0; //val1 is a named constant holding value 0
val2=1; //val2 is a named constant holding value 1
valN=N-1; //valN is a named constant holding value N-1
</code></pre>

<p>check the following code for default enum  behaviour.</p>

<pre><code>#include&lt;stdio.h&gt;
//Define user defined data type. Here days is the datatype. sun,mon,...,sat are named constants.
enum days{sun,mon,tue,wed,thu,fri,sat}; 
int main()
{
   printf(""%d"",wed); //wed is a named constant with default value 3
   return 0;
}
Output: 3
</code></pre>

<p>Initializing custom value for enum.</p>

<pre><code>#include&lt;stdio.h&gt;
enum days{sum=100,mon=200,tue=300,wed=400,thu=500,fri=600,sat=700};
int main()
{
   printf(""%d"",wed); //wed is a named constant with user defined value 400
   return 0;
}
Output: 400
</code></pre>

<p>You can create a enumeration for boolean.</p>

<pre><code>enum boolean{ false,true};
int main()
{
   printf(""false=%d"",false); //false is constant that holds default value 0
   printf(""\ntrue=%d"",true); //true is constant that holds default value 1
   return 0;
}
Output: 
  false=0
  true=1
</code></pre>
",2
16927134,16927097,5,"<p>Double-Or is ""Shortcutting"" - it won't evaluate the rest of the expression if the first part is true.
Use a single-or to increment it whatever happens.</p>

<p>This can be useful sometimes. It speeds up execution, because if the first part is true, you <strong>know</strong> the result of the <code>or</code> must be true!</p>

<p>Note that this is the same (in reverse) for <code>&amp;&amp;</code>: If the first part of &amp;&amp; is false, then the second part is ignored, as you know the result will be false.</p>
",0
16927138,16927097,8,"<p>Because it doesn't need to be evaluated.</p>

<pre><code>checkbit = i &lt; j || ++j &lt; k;
</code></pre>

<p><code>i &lt; j</code> will yield <code>true</code>, so no matter what the second part of the expression yields, the value of <code>checkbit</code> will be <code>true</code>. Thus, it doesn't even bother evaluating it.</p>

<hr>

<p>Just for kicks:</p>

<pre><code>checkbit = i &gt; j &amp;&amp; ++j &lt; k;
</code></pre>

<p>In this case, the second expression will not be evaluated because <code>false &amp;&amp; (expr)</code> is <code>false</code>.</p>
",0
16927174,16927097,0,"<p>When using || operator, and the first condition evaluates to true, it ignores the rest unlike the &amp;&amp; operator</p>

<pre><code> checkbit = i &lt; j || ++j &lt; k; //since i &lt; j is true, it skips over ++j &lt; k
</code></pre>
",0
16927204,16927097,3,"<p>And it's perhaps worth mentioning that this behavior, <a href=""http://en.wikipedia.org/wiki/Short-circuit_evaluation"" rel=""nofollow"">short-circuit evaluation</a>, is in the C standard:</p>

<blockquote>
  <p>6.5.14 Logical OR operator
  Syntax</p>
  
  <p>1 logical-OR-expression:
  logical-AND-expression
  logical-OR-expression || logical-AND-expression</p>
  
  <p>Constraints</p>
  
  <p>2 Each of the operands shall have scalar type.</p>
  
  <p>Semantics</p>
  
  <p>3 The || operator shall yield 1 if either of its operands compare unequal to 0; otherwise, it
  yields 0. The result has type int.
  4 Unlike the bitwise | operator, the || operator guarantees left-to-right evaluation; there is
  a sequence point after the evaluation of the ?rst operand. <strong>If the ?rst operand compares
  unequal to 0, the second operand is not evaluated.</strong></p>
</blockquote>

<p>(emphasis mine)</p>
",0
17769959,17769948,60,"<p>The expression <code>set &gt;&gt;= 1;</code> means <code>set = set &gt;&gt; 1;</code> that is right shift bits of <code>set</code> by <code>1</code> (self assigned form of <code>&gt;&gt;</code> bitwise right shift operator check <a href=""http://msdn.microsoft.com/en-us/library/f96c63ed(v=vs.80).aspx"" rel=""noreferrer"">Bitwise Shift Operators</a>). </p>

<p>Suppose if <code>set</code> is:</p>

<pre><code>BIT NUMBER    31   n=27        m=17                 0
              ¨    ¨           ¨                    ¨
set =         0000 1111 1111 1110 0000 0000 0000 0000
</code></pre>

<p>Then after <code>set &gt;&gt; = 1;</code> variable <code>set</code> becomes:</p>

<pre><code>BIT NUMBER    31   n=26        m=16                 0
              ¨     ¨           ¨                   ¨
set =         0000 0111 1111 1111 0000 0000 0000 0000
</code></pre>

<p>Notice the bits number shifted.</p>

<p>Note a interesting point: Because <code>set</code> is <code>unsigned long</code> so this <code>&gt;&gt;</code> operation should be <a href=""http://en.wikipedia.org/wiki/Logical_shift"" rel=""noreferrer"">logical shift</a>( <a href=""https://stackoverflow.com/questions/2429479/how-do-i-perform-an-unsigned-right-shift-in-java-in-c-c"">unsigned shift</a>) a logical shift does not preserve a number's sign bit.</p>

<p>Additionally,  because you are shifting all bits to right (towards lower significant number) so one right shift is = divide number by two. </p>

<p><a href=""http://codepad.org/XtD7IYyI"" rel=""noreferrer"">check this code</a> (just to demonstrate last point): </p>

<pre><code>int main(){
 unsigned long set = 268304384UL;
 set &gt;&gt;= 1;
 printf("" set :%lu \n"", set);
 set = 268304384UL;
 set /= 2;
 printf("" set :%lu \n"", set);
 return 1; 
}
</code></pre>

<p>And output: </p>

<pre><code> set :134152192 
 set :134152192
</code></pre>

<p>(note: its doesn't means <code>&gt;&gt;</code> and <code>/</code> are both same)</p>

<p>Similarly you have operator <code>&lt;&lt;=</code> for left shift, check other available <a href=""http://en.wikipedia.org/wiki/Operators_in_C_and_C++#Bitwise_operators"" rel=""noreferrer"">Bitwise operators</a> and <a href=""http://en.wikipedia.org/wiki/Operators_in_C_and_C++#Compound_assignment_operators"" rel=""noreferrer"">Compound assignment operators</a>, also check section: <a href=""http://www.xcprod.com/titan/XCSB-DOC/"" rel=""noreferrer"">bit expressions</a> and difference between: <a href=""http://en.wikipedia.org/wiki/Arithmetic_shift"" rel=""noreferrer"">signed/arithmetic shift and unsigned shift</a>. </p>
",0
17769966,17769948,17,"<p>This ""right-shift""s the value by one bit. If you move all the bits of an integer to the right by 1 then you effectively ""divide by 2"" because binary is a base-2 numbering system.</p>

<p>Imagine you have the number 12 in binary:</p>

<pre><code>1100 = 12 in binary
 110 =  6 in binary (1100 right-shifted)
</code></pre>

<p>Just like if you moved all of the digits in a base-10 number right by one you would be dividing by 10.</p>
",0
17769968,17769948,4,"<p>This shifts bit to the right by 1 which is equivalent to division by 2. For more information on bit shifting, refer to <a href=""http://msdn.microsoft.com/en-us/library/f96c63ed(v=vs.80).aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/f96c63ed(v=vs.80).aspx</a></p>
",0
17769988,17769948,1,"<p>The above command performs right shift by one bit .Refer bit wise operations in c from this link <a href=""http://www.cprogramming.com/tutorial/bitwise_operators.html"" rel=""nofollow"">http://www.cprogramming.com/tutorial/bitwise_operators.html</a></p>
",0
17769991,17769948,6,"<p>Every binary operator can be combined with <code>=</code>. In all cases</p>

<pre><code>dest op= expression
</code></pre>

<p>is equivalent to</p>

<pre><code>dest = dest op expression
</code></pre>

<p>(except if <code>dest</code> has any side effects, they only take place once).</p>

<p>So this means that</p>

<pre><code>set&gt;&gt;=1;
</code></pre>

<p>is equivalent to:</p>

<pre><code>set = set &gt;&gt; 1;
</code></pre>

<p>Since <code>&gt;&gt;</code> is the binary right-shift operator, it means to shift the value in <code>set</code> right by 1 bit.</p>
",0
18650568,18650449,4,"<p>The problem you see has nothing to do with CUDA. The problems are your arrays a, b, c. They are allocated on the stack. They have a size of <code>288 x 288 x siezof(int) x 3</code> what leads to 972kB (<code>sizeof(int) = 4 byte</code>). So I asume your hitting the standard maximum stack size, which lies, as far as I know, arround 1MB. </p>

<p>Try to allocate your arrays dynamically on the heap</p>

<pre><code>int* a = (int*) malloc(width * width * sizeof(int));
</code></pre>

<p>and free the memory at the end </p>

<pre><code>free(a);
</code></pre>
",0
18867766,18867657,2,"<p>If you want to skip over whitespace, like the ending newline, then add a leading space before the format code:</p>

<pre><code>printf(""enter c: "");
i = scanf("" %s"", c);

printf(""enter c: "");
j = scanf("" %s"", d);
</code></pre>

<p>This will make <code>scanf</code> skip all whitespace.</p>

<p>Also, if you want to read a number, why not read it as a number using e.g. the <code>""%d""</code> format code? If you want it as a string, then use e.g. <code>snprintf</code> to convert it after scanning.</p>
",8
18868073,18867657,1,"<p>Try this:</p>

<pre><code>#include&lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    char *c = malloc(10);
    char *d = malloc(10);

    int i = 0;

    printf(""enter c:"");
    int x = EOF;
    while (( x = getchar()) != '\n' &amp;&amp; x != EOF) {
        if (i &gt;= 10) {
            break;
        }
        if (x &gt;= 97 &amp;&amp; x &lt;= 122) {
            c[i++]=(char)x;
        }
    }
    printf(""\nenter d:"");
    x = EOF;
    i = 0;
    while (( x = getchar()) != '\n' &amp;&amp; x != EOF) {
        if (i &gt;= 10) {
            break;
        }
        if (x &gt;= 48 &amp;&amp; x &lt;= 57) {
            d[i++]=(char)x;
        }
    }
    printf(""\nc : %s\n"",c);
    printf(""\nd : %s\n"",d);
    return 1;
 }
</code></pre>
",0
18675584,18675101,4,"<p>Use integer type <code>long long</code>.<br>
It is good for at least the range -9223372036854775807 &lt;= x &lt;= +9223372036854775807.</p>

<pre><code>#include &lt;stdio.h&gt;
int main(int argc, char *argv[]) {
  long long big = 600851475143;
  printf(""%lld\n"", big);  // prints 600851475143
  return 0;
}
</code></pre>

<hr>

<p>Alternatively, one could use <code>int64_t</code> or <code>uint64_t</code> - 64-bit types.</p>

<hr>

<p>The range mentioned above is the <em>minimal</em> range specified in C11 5.2.4.2.1.</p>
",0
18763185,18763051,0,"<p>If the scanf encounters error, it implies that the parsing error is still present even if you call the scanf again i.e it parses the older user input again and does not take the new user input.</p>

<p>AFAIK, it is not possible to use scanf to find the errors in parsing integer. Use other appropriate functions like scanf(""%s"")/fgets() followed by strtol.</p>

<pre><code>while (1)
{
    char input[128], *endptr;
    int value;
    scanf(""%s"", input);
    value = strtol(input, &amp;endptr, 10);
    if (endptr != input)
    {
        break;
    }
    printf(""input again\n"");
}
</code></pre>
",0
18763210,18763051,1,"<p>You have a problem in that if you enter a non-numeric value, then the it will not be removed from the input buffer and will stay there forever while you try to scan for numbers.</p>

<p>Instead read the line separately, and then try to get the number from that line. Something like this:</p>

<pre><code>for (;;)
{
    printf(""Enter a number: "");

    /* Get a line of input from the user */
    char line[128];
    if (fgets(line, sizeof(line), stdin) == NULL)
    {
        /* Error reading */
        perror(""fgets"");
        break;
    }

    /* The `fgets` function leaves the newline in the string */
    /* Remove it by overwriting it with the string terminator */
    line[strlen(line) - 1] = '\0';

    /* Convert to a number */
    char *endptr = NULL;
    n = strtol(line, &amp;endptr, 10);

    /* Check if a valid number was entered */
    if (endptr == line)
        printf(""Not a valid number, please enter again\n"");
    else if (endptr &lt; (line + strlen(line)))
        printf(""Line begins with a number, but then there is garbage\n"");
    else
        break;  /* We got a valid number */
}
</code></pre>

<hr>

<p>If you don't care about possible garbage, you could use <code>sscanf</code> instead, and simplify this as</p>

<pre><code>for (;;)
{
    printf(""Enter a number: "");

    /* Get a line of input from the user */
    char line[128];
    if (fgets(line, sizeof(line), stdin) == NULL)
    {
        /* Error reading */
        perror(""fgets"");
        break;
    }

    /* Try to get number as an unsigned short */
    if (sscanf(line, "" %hu"", &amp;n) == 1)
        break;

    printf(""Illegal number\n"");
}
</code></pre>
",0
18763279,18763051,1,"<p>Refactored your code  </p>

<pre><code>#include &lt;stdio.h&gt;

    int main(void)
    {
    int n;
    char t;
    do
    {
    printf(""Enter a number between 0 and 32767: "");
    scanf(""%d"", &amp;n);
    }
    while( (n &lt; 0) || (n &gt; 32767)) ; //check the range of the input.if not there in this range then re read input.
    printf(""In octal, your number is: %o \n"", n); //print octal of input with %o format specifier.
    return 0;
    }
</code></pre>
",0
18763292,18763051,0,"<p>All you need is this :</p>

<pre><code>do
{
   printf(""Enter a number between 0 and 32767: "");

   if(scanf(""%d"", &amp;n) == 1 &amp;&amp; ((n &gt; 0) &amp;&amp; (n &lt; 32767)) )
     status = success;
   else
     while((t=getchar()) !='\n' &amp;&amp; t !=EOF) ; //Eat the trailing newline
}while (status == fail);
</code></pre>

<p>See <strong><a href=""http://ideone.com/mhoyuD"" rel=""nofollow"">HERE</a></strong></p>
",0
18764725,18763051,0,"<p>There are just two little errors in your code. </p>

<p>First, </p>

<pre><code>if(scanf(""%d%c"", &amp;n, &amp;t) != 2 )
  status = success;
</code></pre>

<p>should be</p>

<pre><code>if(scanf(""%d%c"", &amp;n, &amp;t) == 2 )
  status = success;
</code></pre>

<p>That's why it accepted non-integers. The other thing is that you must flush <code>stdin</code> if there was an error in order for <code>scanf</code> to read something new:</p>

<pre><code>if(scanf(""%d%c"", &amp;n, &amp;t) == 2 )
  status = success;
else
  fflush(stdin);
</code></pre>

<p>Put this into your program and it works.</p>

<p><em>Edit:</em> As Grijesh points out, <code>fflush(stdin)</code> should not be used so you have to do something more intelligent regarding the repeated <code>scanf</code>. Others have given some possibilities, but I leave this answer as it points out your original logic fault.</p>
",0
18832043,18831964,6,"<p>This line is only scanning for 1 integer (<code>%i</code> with a <code>2</code> format, indicating only take 2 digits.):</p>

<pre><code>scanf(""%2i"", &amp;ui1, &amp;ui2);
</code></pre>

<p>But it seems you expected to receive two integers.<br>
This will leave the second argument, <code>ui2</code>, uninitialized.<br>
(It should fill <code>ui1</code> successfully, at least)</p>

<p>Try instead:</p>

<pre><code>scanf(""%i %i"",  &amp;ui1, &amp;ui2);
</code></pre>
",1
18832062,18831964,1,"<p>You need to reset the ""sum"", because otherwise the while loop will be true FOREVER.
Second the input scanf is simply wrong.</p>

<p>Here the correct code</p>

<pre><code>#include &lt;stdio.h&gt;
int main()
{
    int ui1;
    int ui2;
    puts(""Please enter two numbers:"");
    scanf(""%d %d"", &amp;ui1, &amp;ui2);
    int sum;
    sum = ui1+ui2;
    while(sum &gt; 4) { printf(""Whats up !"");
    sum=0;}
    return 0;
}
</code></pre>
",5
18832112,18831964,1,"<p><strong>Actually while is a loop stmt not a conditional checker</strong> </p>

<p><strong>if you want conditional checker  use if...else series , switch etc</strong></p>

<p><strong>Note:</strong> <em>in your code loop starts if (sum > 5) and never ends (infinate ""Whats up !"")</em></p>

<pre><code>sum = ui1+ui2;
while(sum &gt; 5)  ///loop starts if (sum &gt; 5) and never ends (infinate ""Whats up !"")
{ 
     printf(""Whats up !""); // (infinate ""Whats up !"")
}

  if(sum &gt; 5)

  {

  //greater stuff
  }

   else

{

   //lower stuff
}
</code></pre>

<p><strong>See Tutorial Here</strong> <a href=""http://www.mochima.com/tutorials/conditionals.html"" rel=""nofollow"">conditionals Stmts</a></p>
",0
18833221,18831964,2,"<p>Try including the scanf statement into the loop, it will no longer be an infinite loop... (also need to dereference the integers, see EDIT)</p>

<pre><code>#include &lt;stdio.h&gt;
int main()
{
    int ui1;
    int ui2;
    puts(""Please enter two numbers:\n"");
    //scanf(""%2i"", &amp;ui1, &amp;ui2);
    int sum = 10;//(so that it will enter the loop at least once)
    //sum = ui1+ui2;
    while(sum &gt; 4) 
    { 
        printf(""enter number 1:\n"");
        scanf(""%i"", &amp;ui1); //EDIT &amp;
        printf(""enter number 2:\n"");
        scanf(""%i"", &amp;ui2); //EDIT &amp;
        sum = ui1+ui2;        
    }
    printf(""result is:  %d\n"", sum);
    getchar();//so you can see the result;
    getchar();
    return 0;
}
</code></pre>
",1
18834129,18831964,0,"<p>I'm not sure that i got what you want to do... but if you simply want to check the sum of the two integers using the while statement, you can put a break inside the while loop and everything will work :)</p>

<pre><code>#include &lt;stdio.h&gt;
int main()
{
    int ui1;
    int ui2;
    puts(""Please enter two numbers:"");
    scanf(""%2i"", &amp;ui1, &amp;ui2);
    int sum;
    sum = ui1+ui2;
    while(sum &gt; 5) { 
         printf(""Whats up !"");
         break;
    }
    return 0;
}
</code></pre>

<p>As others told you, using a if is the best solution</p>
",0
18833253,18831933,4,"<p>I noted this in general-comment, and I'll amplify it here. This is wrong, and wiil result in <strong>undefined behavior</strong>:</p>

<pre><code>for(i=0; i&lt;rows ; i++ )
    for( j=0 ; j&lt;cols ; j++); // &lt;&lt;== this is wrong.
{
    temp=arr[i][j];
    arr[i][j]=arr[i][cols-1];
    arr[i][cols-1]=temp;
}
</code></pre>

<p>That trailing semi-colon is outright wrong. With it, the code literally becomes this:</p>

<pre><code>// A useless nested for loop that runs `i` to `rows` and `j to `cols`
for(i=0; i&lt;rows ; i++ )
    for( j=0 ; j&lt;cols ; j++);

// Now `i=rows` and `j=cols`. then you do this
temp=arr[i][j];
arr[i][j]=arr[i][cols-1];
arr[i][cols-1]=temp;
</code></pre>

<p>You're accessing memory you don't own, as <code>arr</code> is only indexible to <code>[rows-1][cols-1]</code> Anything outside that is undefined behavior.</p>

<p><strong>Correction</strong></p>

<pre><code>for(i=0; i&lt;rows ; i++ )
    for( j=0 ; j&lt;cols ; j++) // note: no semi-colon.
    {
        temp=arr[i][j];
        arr[i][j]=arr[i][cols-1];
        arr[i][cols-1]=temp;
    }
</code></pre>

<p>Fix your code by removing that semi-colon, and at least that part of your problem is addressed. I cannot speak for other issues. </p>

<p>Finally, <strong>enable your compiler warnings to pedantic levels.</strong> Any reasonable compiler configured with properly heightened warnings would catch this issue.</p>
",0
18833527,18831933,2,"<p>The error has been already pointed out in another answer, but let me give you another piece of good advice: <strong>do not use pointers-to-pointers to represent multidimensional arrays.</strong></p>

<p>Also, <strong><a href=""https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc/605858#605858"">do NOT cast the return value of <code>malloc()</code></a>.</strong></p>

<p>This is what you should do (should have done):</p>

<pre><code>int (*mat)[width] = malloc(height * sizeof(*mat));
</code></pre>
",0
18707304,18707098,2,"<p>This isn't your problem, but please avoid the structure in your comparator.  Try this instead:</p>

<pre><code>int organCompare(organT* organ, int x, int y)
{
    if (organ[x].dateAdded.year &lt; organ[y].dateAdded.year)
        return x;
    else if (organ[x].dateAdded.year &gt; organ[y].dateAdded.year)
        return y;
    else if (organ[x].dateAdded.month &lt; organ[y].dateAdded.month)
        return x;
    else if (organ[x].dateAdded.month &lt; organ[y].dateAdded.month)
        return y;
    else if (organ[x].dateAdded.day &lt; organ[y].dateAdded.day)
        return x;
    else if (organ[x].dateAdded.day &gt; organ[y].dateAdded.day)
        return y;
    else if (organ[x].timeAdded.hour &lt; organ[y].timeAdded.hour)
        return x;
    else if (organ[x].timeAdded.hour &gt; organ[y].timeAdded.hour)
        return y;
    else if (organ[x].timeAdded.minute &lt; organ[y].timeAdded.minute)
        return x;
    else
        return y;
}
</code></pre>
",1
18707424,18707098,1,"<p>The compiler complains because you are using functions that you haven't explicitly defined via a function prototype. I left my C reference at work, so I can't find the exact paragraph, but the compiler will guess at a functions prototype and that's causing the ""conflicting types"" warning or error you are seeing. From memory, C assumes functions to return an <code>int</code> if you don't specify anything.</p>

<p>That's my best guess. If David Schwartz's fix works, I'd be very certain that it was the cause.</p>
",1
18707184,18707098,2,"<p>Add these three lines before <code>int main()</code>:</p>

<pre><code> #include &lt;string.h&gt;
 void scanOrgans(int x, organT* organ);  
 void scanDonors(int x, organT* donors );
 int organCompare(organT* organ, int x, int y);
</code></pre>
",2
18707211,18707098,2,"<p>When using <code>scanf</code> with a <code>char *</code> you generally don't need <code>&amp;</code>, since you already have a pointer. So change:</p>

<pre><code>    scanf(""%s"",&amp;organ[i].name);
    scanf(""%s"",&amp;organ[i].organname);
    scanf(""%s"",&amp;organ[i].bloodtype);
</code></pre>

<p>to:</p>

<pre><code>    scanf(""%s"",organ[i].name);
    scanf(""%s"",organ[i].organname);
    scanf(""%s"",organ[i].bloodtype);
</code></pre>

<p>Also, not a bug as such, but in C you should never cast the result of malloc, so change e.g.</p>

<pre><code>donors = (organT *)malloc(numberOfDonors*sizeof(organT));
</code></pre>

<p>to:</p>

<pre><code>donors = malloc(numberOfDonors*sizeof(organT));
</code></pre>
",2
18200673,18200561,0,"<p>You should read about <a href=""http://gcc.gnu.org/onlinedocs/cpp/"" rel=""nofollow"">Preprocessor directives</a> in C.</p>

<p>Here we are creating a macro, which gets replaced during compile time with the value which we used to define the macro with.</p>

<p>For eg:</p>

<p>We can use </p>

<pre><code>Assert(&lt;some condition or expression&gt;)
</code></pre>

<p>through out your code instead of</p>

<pre><code> if(&lt;some condition or expression&gt;)
 {
    putStr(""Err\n"");
 }
</code></pre>

<p>During compile time, compiler replaces all this Assert with the actual condition. </p>
",0
18736126,18736080,1,"<p>You can't, at least not without seriously dirty hacks. You should know how much you allocated, and you shouldn't care about the memory you didn't allocate.</p>
",0
18799778,18799754,2,"<p>That's the expected output (to <code>stderr</code>, not <code>stdout</code>).</p>
",1
18799866,18799754,4,"<p>The C standard doesn't specify exactly what the compiler should output, only that the tokens after <code>#error</code> must be included in the output. The output you get is &quot;conforming&quot;. Different compilers can do different things.</p>
<p>For instance, <code>clang</code> has a different format, but it is conforming too:</p>
<pre><code>$ cat t.c
#error hello
$ clang -c t.c
t.c:1:2: error: hello
#error hello
 ^
1 error generated.
</code></pre>
<p>The error is printed as you want it, with extra context.</p>
<p>Reference: C11 draft, ¡ì6.10.5 <em>Error directive</em></p>
<blockquote>
<p>A preprocessing directive of the form</p>
<pre><code># error pp-tokensopt new-line
</code></pre>
<p>causes the implementation to produce a diagnostic message that includes the specified
sequence of preprocessing tokens.</p>
</blockquote>
",0
19325640,19325240,18,"<h2>Normal Declarations (Not Function Parameters)</h2>
<p><code>char **p;</code> declares a pointer to a pointer to <code>char</code>. It reserves space for the pointer. It does not reserve any space for the pointed-to pointers or any <code>char</code>.</p>
<p><code>char *p[N];</code> declares an array of <em>N</em> pointers to <code>char</code>. It reserves space for <em>N</em> pointers. It does not reserve any space for any <code>char</code>. <code>N</code> must be provided explicitly or, in a definition with initializers, implicitly by letting the compiler count the initializers.</p>
<p><code>char p[M][N];</code> declares an array of <em>M</em> arrays of <em>N</em> <code>char</code>. It reserves space for <em>M</em>?<i>N</i> <code>char</code>. There are no pointers involved. <code>N</code> must be provided explicitly. <code>M</code> must be provided explicitly or, in a definition with initializers, implicitly by letting the compiler count the initializers.</p>
<h2>Declarations in Function Parameters</h2>
<p><code>char **p</code> declares a pointer to a pointer to <code>char</code>. When the function is called, space is provided for that pointer (typically on a stack or in a processor register). No space is reserved for the pointed-to-pointers or any <code>char</code>.</p>
<p><code>char *p[N]</code> is adjusted to be <code>char **p</code>, so it is the same as above. The value of <code>N</code> is ignored, and <code>N</code> may be absent. (Some compilers may evaluate <code>N</code>, so, if it is an expression with side effects, such as <code>printf(&quot;Hello, world.\n&quot;)</code>, these effects may occur when the function is called. The C standard is unclear on this.)</p>
<p><code>char p[M][N]</code> is adjusted to be <code>char (*p)[N]</code>, so it is a pointer to an array of <em>N</em> <code>char</code>. The value of <code>M</code> is ignored, and <code>M</code> may be absent. <code>N</code> must be provided. When the function is called, space is provided for the pointer (typically on a stack or in a processor register). No space is reserved for the array of <em>N</em> <code>char</code>.</p>
<h2>argv</h2>
<p><code>argv</code> is created by the special software that calls <code>main</code>. It is filled with data that the software obtains from the ¡°environment¡±. You are allowed to modify the <code>char</code> data in it.</p>
<p>In your definition <code>char *p = &quot;some string&quot;;</code>, you are not permitted to modify the data that <code>p</code> points to because the C standard says that characters in a string literal may not be modified. (Technically, what it says is that it does not define the behavior if you try.) In this definition, <code>p</code> is not an array; it is a pointer to the first <code>char</code> in an array, and those <code>char</code> are inside a string literal, and you are not permitted to modify the contents of a string literal.</p>
<p>In your definition <code>char p[] = &quot;some string&quot;;</code>, you may modify the contents of <code>p</code>. They are not a string literal. In this case, the string literal effectively does not exist at run-time; it is only something used to specify how the array <code>p</code> is initialized. Once <code>p</code> is initialized, you may modify it.</p>
<p>The data set up for <code>argv</code> is set up in a way that allows you to modify it (because the C standard specifies this).</p>
",2
19325337,19325240,0,"<ul>
<li><code>a</code> in <code>char* a</code> is pointer to array of chars, <code>a</code> can be modified.</li>
<li><code>b</code> in <code>char b[]</code> is array of chars.  <code>b</code> cannot be modified.</li>
</ul>

<p>They are sort of compatible -  <code>b</code> can automatically <em>decay</em> to <code>a</code> in assignments and expressions, but not other way around.</p>

<p>When you use <code>char** p</code>, <code>char* p[]</code> and <code>char p[][]</code> it is very similar situation, just more levels of indirection.</p>
",3
20638242,20638117,1,"<p>You didn't initialize your <code>ch</code> and counter variable. So they can be of any surprising values.
So it is not bizarre for you to get result 4194872.</p>

<p>Another critical error you make is that your program never actually get to count the occurrence of the word ""correspondence"". In your program, the variable str can only represent one alphabet, but not the word. So when you use <code>str == ch</code> to test if the word ""correspondence"" exist, you are actually testing if the <strong>letter</strong> equal to <code>c</code>.(And that is only true if you have correctly initialized your <code>str</code> variable. For clarity, it is better to declare <code>str</code> as a <code>char</code> type instead of type <code>int</code>).</p>

<p>The correct way to compare between <em>words</em> is to compare their letters one by one. If any letter doesn't fit, then return false.</p>

<p>Read this code to understand the comparing process.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char **argv)
{

    FILE * file = fopen(""file.txt"",""r"");
    if(file == NULL) {printf(""File not open""); return -1;}
    char* str =""correspondence""; //Declare str as an array and initiate it with your word
    char input[50];  //Declare an char array long enough to hold ordinary words
    int i;
    int count = 0;
    while(fscanf(file,""%s"",input) != EOF)
    {
            for(i = 0;i &lt; strlen(str) &amp;&amp; i &lt; strlen(input) ;++ i)
            {
                    if(input[i] != str[i])  break;
                    else  i++;
            }
            if(i &gt;= strlen(str) &amp;&amp; strlen(str) == strlen(input))
            count++;
            memset(input,0,sizeof(input));
    }

    printf(""word count = %d"",count);

    return 0;
}
</code></pre>
",4
20638255,20638117,1,"<p>You need to initialize ch before comparing.</p>
",1
19802753,19802685,0,"<p>Your program is most probably taking <strong>too long</strong> to execute. Try smaller numbers as Jerry hinted to validate your program. </p>

<p>You might want to look at this post: <strong><a href=""https://stackoverflow.com/questions/10564153/prime-factorization-for-big-numbers"">Prime factorization for big numbers</a></strong> for better algorithms.</p>
",0
18306352,18306237,2,"<p>Let's see... a function pointer <code>p</code> that takes <code>void</code> as an argument can be declared like so:</p>

<pre><code>void (*p)(void);
</code></pre>

<p>One that returns an array of pointers to integers might look like:</p>

<pre><code> int** (*p)(void);
</code></pre>

<p>or, following the definition of ""array"" more strictly (this one is less likely in practice) -- note that as Amir has pointed out, functions in C cannot actually return arrays, but can return a pointer to an array (of 100 int pointers) like so:</p>

<pre><code>int* (*(*p)(void))[100];
</code></pre>

<p>And an array of seven such beasts can be expressed as:</p>

<pre><code>int* (*(*ptrs[7])(void))[100];
</code></pre>

<p>The <code>void</code> can of course be dropped, leaving us with:</p>

<pre><code>int* (*(*ptrs[7])())[100];
</code></pre>

<p>This can be confirmed with the excellent <a href=""http://cdecl.ridiculousfish.com/?q=int%2a+%28%2a%28%2aptrs%5B7%5D%29%28%29%29%5B100%5D%3B"" rel=""nofollow"">cdecl tool</a>.</p>
",3
18306268,18306237,1,"<pre><code>typedef int* (*pt2Function)(void * data);
pt2Function funcArr1[10] = {NULL};
</code></pre>

<p><br>
I don't think that it is possible to return an array, you should create a pionter to it </p>
",4
19787330,19787165,0,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

extern char **seasons;

int main(){
  int i = 0;
  while(seasons[i] != NULL){
    printf(seasons[i]);
    i++;
  }
  return 0;
}
</code></pre>
",0
19787345,19787165,0,"<p>If <code>arr</code> is your array and you want to stop at that index <code>i</code> were <code>arr</code> contains <code>NULL</code>, the standard <code>for</code> loop would look like this:</p>

<pre><code>for (i = 0; arr[i]; i++)
   dostuff(arr[i]);
</code></pre>
",0
19787888,19787165,0,"<p>Here's 3 variants:</p>

<pre><code>extern char **seasons;
size_t i;
for(i = 0; seasons[i]; i++) {
   do_something(seasons[i]);
}
</code></pre>

<p>or</p>

<pre><code>extern char **seasons;
char **i;
for(i = seasons; *i ; i++) {
   do_something(*i);
}
</code></pre>

<p>or </p>

<pre><code>extern char **seasons;
char **i = seasons;
while(*i) {
   do_something(*i);
   i++;
}
</code></pre>
",0
19787818,19787165,3,"<p>Assuming your array look like this :</p>

<pre><code>const char *data[] = {""This"", ""is"", ""an"", ""array"", ""of"", ""strings"", NULL};
</code></pre>

<p>You can iterate through it like this :</p>

<pre><code>const char** seasons = data;
int i;
for(i = 0; seasons[i] != NULL; ++i) {
    printf(""%s "", seasons[i]);
}
</code></pre>
",0
18148218,18148160,0,"<p>You're doing this:</p>

<pre><code> if(i &gt; n) {
     printf(""postion you wanted to insert"");
     scanf(""%d"", &amp;n);
 }
</code></pre>

<p>But <code>i</code> is uninitialized.</p>

<p>Try this:</p>

<pre><code> #include &lt;stdio.h&gt;
 #include &lt;conio.h&gt;

 int main(){
     int arr[100] = {10, 5, 46, 2, 100, 97};
     int n, max, i = 7;
     n = 0;

     clrscr();
     if(i &gt; n){
     printf(""postion you wanted to insert"");
     scanf(""%d"", &amp;n);
     }

     printf(""Value for position: \n"");
     scanf(""%d"", &amp;max);

     for(i=7; i&gt;n-1; i--){
     arr[i+1] = arr[i];
     arr[n] = max;
     }

     printf(""Array after insertion: \n"");
     for(i = 0; i &lt; 7; i++){
     printf(""%d\t"", arr[i]);
     }

     getch();
 }
</code></pre>

<p>But you don't need this condition <code>if(i &gt; n)</code>.</p>
",0
18148228,18148160,2,"<p>You have not assigned any value to the int i, so the compiler will assign garbage value to the variable i, hence you are not getting your output.</p>

<p>You need to do something like this</p>

<pre><code>void main()
{
 int n,val,i;
 int arr[100] = {10,20,30,40,50};
 printf(""enter the position where you want to insert the new element \n"");
 scanf(""%d"",&amp;n);
 print(""Enter the value you want to insert"");
 scanf(""%d"",&amp;val);

 for(i=5,i&gt;=n,i--)
  {
   arr[i+1]=arr[i];
   }
arr[n]=max;
/*then print your array*/
getch();
}
</code></pre>
",4
18148278,18148160,0,"<p>You don't need to <code>if</code> statement :</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;

int main() {
    int arr[100] = {10, 5, 46, 2, 100, 97};
    int n, max, i;
    n = 0;

    clrscr();
    // no need for if statement here
    printf(""postion you wanted to insert"");
    scanf(""%d"", &amp;n);

    printf(""Value for position: \n"");
    scanf(""%d"", &amp;max);

    for(i=6; i&gt;n-1; i--) {
        arr[i+1] = arr[i];
        arr[i] = max;
    }

    printf(""Array after insertion: \n"");
    for(i = 0; i &lt; 7; i++) {
        printf(""%d\t"", arr[i]);
    }

    getch();
}
</code></pre>

<p>The <code>if</code> statement uses <code>i</code>, which you have not initialized.  Since you want to ask for a position from the user, you don't need the <code>if</code> statement.</p>

<p>You also need to fix your <code>for</code> loop (<code>i</code> starts with 6, and you need to do <code>arr[i] = max</code> instead of <code>arr[n] = max</code>).</p>
",1
18148320,18148160,0,"<p>change</p>

<pre><code>for(i=7; i&gt;n-1; i--) {
    arr[i+1] = arr[i];
    arr[n] = max;
}
</code></pre>

<p>to</p>

<pre><code>for(i=7; i&gt;n-1; i--)
    arr[i+1] = arr[i];
arr[n] = max;
</code></pre>
",0
18148334,18148160,0,"<p>Fix:</p>

<pre><code>for(i=5; i&gt;=n-1; i--) { //Start from end of array till n-1
arr[i+1] = arr[i]; 
 }
arr[n-1] = max; // Make room for new element &amp; insert at last
</code></pre>
",0
18148349,18148160,0,"<p>This should work:</p>

<pre><code>int main ()
{
    int arr[100] = {10, 5, 46, 2, 100, 97};
    int n = 6; //Number of elements in arr
    int pos = 0;
    int value = 0;
    clrscr();

    printf(""postion you wanted to insert"");
    scanf(""%d"", &amp;pos);

    printf(""Value for position: \n"");
    scanf(""%d"", &amp;value);

    int i;
    for (i = n ; i &gt; pos ; --i)
        arr[i] = arr[i - 1];
    arr[pos] = value;
    ++n;

    printf(""New array:\n"");
    for (i = 0 ; i &lt; 0 ; ++i)
         printf(""%d "", arr[i]);

    getch ();
 }
</code></pre>
",0
18148354,18148160,1,"<p>Your loop to move the items after the index you want to insert (that is, the first loop) is wrong. You start the array with six entries (index <code>0</code> to <code>5</code>. But then you start looping with index <code>7</code>, meaning you will move <code>arr[7]</code> to <code>arr[8]</code>.</p>

<p>But that's just the <em>start</em> of the problems with that loop. You <em>then</em> set <code>arr[n]</code> to the value you want to insert, in each loop. So that when you want to move the original value of <code>arr[n]</code> that value have already been overwritten many times. </p>
",0
19509496,19509420,2,"<p>Here is how : ( put this after <code>accept</code> ):</p>

<pre><code>char clntName[INET_ADDRSTRLEN];
FILE *output;

if(inet_ntop(AF_INET,&amp;client_address.sin_addr.s_addr,clntName,sizeof(clntName))!=NULL){
   output = fopen(""output.txt"",""a+"");  
   fprintf(output,""%s%c%d"",clntName,'/',ntohs(client_address.sin_port));  
   fclose(output);
} else {
   printf(""Unable to get address\n""); // i just fixed this to printf .. i had it as print before
}
</code></pre>
",4
19509832,19509420,3,"<p><a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/getnameinfo.html"" rel=""nofollow""><code>getnameinfo()</code></a> is more new-style.</p>

<p>You use it like</p>

<pre><code>char clntName[INET6_ADDRSTRLEN];
char portName[6]; // I wonder if there is no appropriate constant...

if(getnameinfo(&amp;client_address,sizeof client_address,clntName,sizeof(clntName),NULL,0,NI_NUMERICHOST|NI_NUMERICSERV|NI_NUMERICSCOPE)==0){
   printf(""Client = %s/%s\n"",clntName,portName);
} else {
   printf(""Unable to get address\n"");
}
</code></pre>

<p>Once you have done so, you won't have any difficulties mixing IPv4 and IPv6 calls.</p>
",4
19802681,19802636,1,"<p>C++ doesn't allow string or arrays in switch instructions, that might be the problem.</p>

<p>Plus you're assigning tempt to 0.</p>
",3
19802684,19802636,0,"<p>There are several errors in your code.</p>

<p><code>void legal(char string);</code> returns a void, but you attempt to assign it here:</p>

<pre><code>temp = legal(string);
</code></pre>

<p><code>legal</code> takes a char, but you try to pass a <code>char []</code> to it.</p>

<p>You <code>return 0;</code> in legal.</p>
",0
19802804,19802636,0,"<p>The problem is that the variable <code>string</code> is an array, while <code>legal</code> only accepts single char values. You can fix this by accepting a pointer or an array or some combination there-of and only checking the first digit if that is what you want.</p>

<p>Your corrected code would look like this:</p>

<pre><code>void legal(char *string);
</code></pre>

<p>and then inside the legal function, you can reference the first character as <code>*string</code>.</p>
",0
19802718,19802636,1,"<p>I see you have mistaken a <code>char *</code> with a <code>char</code>. </p>

<p>Instead, you must loop through the string, character by character and figure out with a flag if the word is legal or not..</p>

<p>here is how I would do it, not tested code ahead:</p>

<pre><code>void rev(char *);
void legal(char *string);

int main()
{

     char string[50];
     int temp;
     printf(""Enter any string:"");
     scanf("" %s"",&amp;string);
     //printf(""Before reversing the string %s\t"",string);

     rev(string);
     printf(""\nReverse String is %s"",string);
     temp = legal(string);

     printf(""\nLegal? %d"",temp);

return 0;
}

int legal(char *string)
{   
    char *ch = string;
    int flag = 0;
    while(*ch != '\0'){
     switch(*ch)
     {
    case 'A':
    case 'E':
    case 'I':
    case 'O':
    case 'U':
    case 'Y':
    case 'a':
    case 'e':
    case 'i':
    case 'o':
    case 'u':
    case 'y':
      flag = 1;
    break;
    default:    
      //nothing  
    break;
    }
   }
   if(flag == 1){
      printf(""word is legal!"");
   }else{
      printf(""word is illegal!"");
   }
    return flag;    
}
</code></pre>
",5
20508827,20508343,3,"<p>In most cases these two statements behave the same, with two exceptions. One exception is when applying the &amp; operator. When you apply &amp; to an array(e.g. a[]), you got the address of the whole array. This value is identical to the address of the first element of the array, so &amp;a == a (their types are different tough). You can try a simple example here: <a href=""http://ideone.com/96w3oa"" rel=""nofollow noreferrer"">http://ideone.com/96w3oa</a></p>

<p>Ok. Now we can see why you got a segmentation fault. Because &amp;a is equal to a, your string[0] actually does an extra deference. The correct way would be:</p>

<pre><code>printf(""%s"", string);
</code></pre>

<p>or</p>

<pre><code>printf(""%s"", (&amp;string)[0]);
</code></pre>

<p>if you use</p>

<pre><code>char a[] = ""blahblah"";
</code></pre>

<p>For more information regarding the difference between the two statements you tried, please refer to this post (especially the post by John Bode): <a href=""https://stackoverflow.com/questions/1704407/what-is-the-difference-between-char-s-and-char-s-in-c"">What is the difference between char s[] and char *s?</a>.</p>

<p>Here is also a very good explanation:
<a href=""http://publications.gbdirect.co.uk/c_book/chapter5/arrays_and_address_of.html"" rel=""nofollow noreferrer"">http://publications.gbdirect.co.uk/c_book/chapter5/arrays_and_address_of.html</a></p>
",0
19376340,19376264,4,"<p>The size of a pointer for a 32 bit binary  will generally be 4 bytes. If you compile your code as a 64 bit binary, the size of the pointer should be 8 bytes. It is sufficently large to address the available memory.</p>

<p>You can check the size of a pointer variable of any type like this</p>

<pre><code>printf(""%zu\n"", sizeof(int *));
</code></pre>

<p>It seems like you are confused between the size of <code>char</code> and <code>char *</code>. <code>char</code> stores a character variable and its size is one byte. You can check it:</p>

<pre><code>printf(""%zu\n"", sizeof(char));
</code></pre>

<p>However, <code>char *</code> is a pointer to a <code>char</code> and its size will generally be 4 bytes in a 32 bit environment</p>

<pre><code>printf(""%zu\n"", sizeof(char *));
</code></pre>
",7
19960901,19960819,1,"<p>When you use <a href=""http://msdn.microsoft.com/en-us/library/teas0593%28v=vs.110%29.aspx"" rel=""nofollow""><code>#define</code></a>, you are not creating variables per se. Rather, every spot at which the token <code>rows</code> or <code>cols</code> is used, <code>10</code> and <code>20</code> (respectively) will be <em>textually substituted</em>. Therefore, it makes no sense to ""reassign <code>rows</code> or <code>cols</code>"", since it would be similar to trying to assign a value to <code>10</code> or <code>20</code>. If you need such a reassignment capability, use regular variables instead.</p>
",2
19435701,19435685,6,"<p>Move the <code>srand(time(NULL));</code> outside the <code>while</code> loop.</p>

<p><code>time(NULL)</code> returns the <code>time_t</code> struct, which is being converted into the <code>unsigned int</code> (prototype: <code>void srand( unsigned seed );</code>), storing total number of seconds since the Epoch: 00:00:00 Coordinated Universal Time (UTC), Thursday, 1 January 1970.</p>

<p>And the loop executes as fast, so each <code>srand(time(NULL))</code> being evaluated in the same second.</p>
",0
20762753,20762742,2,"<p>That for loop is a classic idiom for a non-terminating loop. It's what you use when you want a loop that never terminates, or whose termination is controlled by control flow statements inside the loop. The latter is the case here.</p>

<pre><code>for(;;)
</code></pre>

<p>All parts of the <code>for</code> loop are empty. They key to understanding why it is a non-terminating loop is the empty controlling expression in the <code>for</code> statement. </p>

<p>The standard (<strong>6.8.5.3 The for statement</strong>) says, with my emphasis:</p>

<blockquote>
  <p>The statement</p>

<pre><code>for ( clause-1 ; expression-2 ; expression-3 ) statement
</code></pre>
  
  <p>behaves as follows: The expression expression-2 is the controlling
  expression that is evaluated before each execution of the loop body.
  The expression expression-3 is evaluated as a void expression after
  each execution of the loop body. If clause-1 is a declaration, the
  scope of any identifiers it declares is the remainder of the
  declaration and the entire loop, including the other two expressions;
  it is reached in the order of execution before the first evaluation of
  the controlling expression. If clause-1 is an expression, it is
  evaluated as a void expression before the first evaluation of the
  controlling expression.158)</p>
  
  <p>Both clause-1 and expression-3 can be omitted. <strong>An omitted
  expression-2 is replaced by a nonzero constant</strong>.</p>
</blockquote>

<p>And this means that your loop will never terminate due to the controlling expression part of the <code>for</code> statement.</p>
",0
20762766,20762742,2,"<pre><code>for(;;)
</code></pre>

<p>is a <code>for</code> loop which performs no initialisation, has no exit condition and performs no post-action.</p>

<p>It will loop forever unless code inside the loop contains a condition that can result in <code>break</code> being called.</p>

<p>Your loop is equivalent to</p>

<pre><code>int i,j;
for(i=1, j=1 ;i&lt;=5 ;i+=j) {
    j+=i;
    printf(""%d\n"",j);
}
</code></pre>
",2
20762786,20762742,2,"<p><code>for(;;)</code> is equivalent to <code>while(true)</code> (or <code>while(1)</code> in old-school C), both of whose terminations are only controlled by the statements inside them.</p>

<hr>

<p><strong>Edit</strong>:
To rehash a couple of old jokes (borrowed from <a href=""https://stackoverflow.com/questions/1401159/for-or-while-true-which-is-the-correct-c-sharp-infinite-loop/1401207#1401207"">here</a>):</p>

<ol>
<li>Don't use <code>for (;;) {}</code> ¡ª it makes the statement cry.</li>
<li>Unless, of course, you <code>#define EVER ;;</code>.</li>
</ol>
",6
19564582,19564445,3,"<p>The expression <code>psswrd[NULL]</code> doesn't do anything by itself. It's just the same as writing <code>psswrd[0]</code>. If you enable warnings you should get a warning about this, and maybe one because <code>NULL</code> may be a pointer and you use that as an index.</p>

<p>If you want to clear it, then use e.g. <a href=""http://en.cppreference.com/w/c/string/byte/memset"" rel=""nofollow""><code>memset</code></a>:</p>

<pre><code>memset(psswrd, 0, sizeof(psswrd));
</code></pre>
",1
19569553,19569454,2,"<p>It depends on the platform you are working on.  On windows (as an example) you would need to add a handler for the keyboard event message.  Then when that message is sent to your window you would have code to perform the shutdown.</p>

<p>Many development platforms make this easier for you by hiding the messages behind an event model.</p>

<p>Prior to windows you needed to hook into the interrupt stack (using a command called ""TSR"" for terminate and stay resident) of the keyboard driver.  Then when a keyboard event was called your code could run.</p>
",3
18861616,18861583,2,"<p>At first I thought this was the problem:</p>

<p><code>char *words=malloc(sizeof(char))</code> is allocating 1 byte (sizeof 1 char).  You probably meant <code>char *words = malloc(strlen(ptr-&gt;words)+1);</code> - You probably want to null check the ptr and it's member just to be safe.</p>

<p>Then I saw the <code>realloc</code>. Your realloc is always 1 char short. When i = 0 you allocate 1 byte then hit the loop, increment <code>i</code> and put a char 1 past the end of the realloced array (at index 1)</p>

<p>Also your <code>strcpy</code> in main is has not allocated any memory in the holder.</p>
",6
18861726,18861583,0,"<p>In these two lines,</p>

<pre><code>structptr-&gt;words=malloc(strlen(argv[1]));
strcpy(structptr-&gt;words, argv[1]);
</code></pre>

<p>need to add one to the size to hold the nul-terminator. <code>strlen(argv[1])</code> should be <code>strlen(argv[1])+1</code>.</p>

<p>I think the same thing is happening in the loop, and it should be larger by 1. And <code>sizeof(char)</code> is always 1 by definition, so:</p>

<pre><code> ...
 words=realloc(words,i+2);
}
words=realloc(words,i+2); // one more time to make room for the '\0'
words[strlen(ptr-&gt;words)]='\0';
</code></pre>
",0
18861826,18861583,0,"<p>FYI: Your description talks about <code>structptr</code> but your code uses <code>struct StructHolder</code> and <code>Holder</code>.</p>

<p>This code is a disaster:</p>

<pre><code>char *GetCharacters(Holder *ptr){
    int i=0;
    char *words=malloc(sizeof(char));
    for(i;i&lt;strlen(ptr-&gt;words);i++){
        words[i]=ptr-&gt;words[i];
        words=realloc(words,sizeof(char)+i);
    }
    words[strlen(ptr-&gt;words)]='\0';
    return words;
}
</code></pre>

<p>It should be:</p>

<pre><code>char *GetCharacters(const Holder *ptr)
{
    char *words = malloc(strlen(ptr-&gt;words) + 1);
    if (words != 0)
        strcpy(words, ptr-&gt;words);
    return words;
}
</code></pre>

<p>Or even:</p>

<pre><code>char *GetCharacters(const Holder *ptr)
{
    return strdup(ptr-&gt;words);
}
</code></pre>

<p>And all of those accept that passing the structure type makes sense; there's no obvious reason why you don't just pass the <code>const char *words</code> instead.</p>

<p>Dissecting the 'disaster' (and ignoring the argument type):</p>

<pre><code>char *GetCharacters(Holder *ptr){
    int i=0;
</code></pre>

<p>OK so far, though you're not going to change the structure so it could be a <code>const Holder *ptr</code> argument.</p>

<pre><code>    char *words=malloc(sizeof(char));
</code></pre>

<p>Allocating one byte is expensive ¡ª more costly than calling <code>strlen()</code>.  This is not a good start, though of itself, it is not wrong.  You do not, however, check that the memory allocation succeeded.  That is a mistake.</p>

<pre><code>    for(i;i&lt;strlen(ptr-&gt;words);i++){
</code></pre>

<p>The <code>i;</code> first term is plain weird.  You could write <code>for (i = 0; ...</code> (and possibly omit the initializer in the definition of <code>i</code>, or you could write <code>for (int i = 0; ...</code>.</p>

<p>Using <code>strlen()</code> repeatedly in a loop like that is bad news too.  You should be using:</p>

<pre><code>    int len = strlen(ptr-&gt;words);
    for (i = 0; i &lt; len; i++)
</code></pre>

<p>Next:</p>

<pre><code>        words[i]=ptr-&gt;words[i];
</code></pre>

<p>This assignment is not a problem.</p>

<pre><code>        words=realloc(words,sizeof(char)+i);
</code></pre>

<p>This <code>realloc()</code> assignment is a problem.  If you get back a null pointer, you've lost the only reference to the previously allocated memory.  You need, therefore, to save the return value separately, test it, and only assign if successful:</p>

<pre><code>        void *space = realloc(words, i + 2);  // When i = 0, allocate 2 bytes.
        if (space == 0)
            break;
        words = space;
</code></pre>

<p>This would be better/safer.  It isn't completely clean; it might be better to replace <code>break;</code> with <code>{ free(words); return 0; }</code> to do an early exit.  But this whole business of allocating one byte at a time is not the right way to do it.  You should work out how much space to allocate, then allocate it all at once.</p>

<pre><code>    }
    words[strlen(ptr-&gt;words)]='\0';
</code></pre>

<p>You could avoid recalculating the length by using <code>i</code> instead of <code>strlen(ptr-&gt;words)</code>.  This would have the side benefit of being correct if the <code>if (space == 0) break;</code> was executed.</p>

<pre><code>    return words;
}
</code></pre>

<p>The rest of this function is OK.</p>

<p>I haven't spent time analyzing <code>main()</code>; it is not, however, problem-free.</p>
",0
18863173,18863113,0,"<p>You haven't initialized <code>i</code> variable, so it's garbage. Also, the condition should be <code>while ((c = getchar()) != EOF)</code>.</p>
",3
18863195,18863113,1,"<p>I find that this program works:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(int argc, char** argv)
{
  int  c, i = 0, j;

  int a[4];
  while((c = getchar()) != EOF &amp;&amp; i &lt; 4)
  {
    a[i++] = c;
  }

  for(j = 0; j &lt; 4; j++)
  {
    printf(""%c"", a[j]);
  }
  printf(""\n"");  // Be nice to non-windows users :)

  return 0;
}
</code></pre>

<p>There are a couple of changes from your original program.  Initialisation of <code>i</code>, putting a limit on the number of characters read, outputting only 4 characters (<code>j &lt; 4</code>) and fixing a bit of your syntax (missing brackets and <code>int main(int argc, char** argv)</code>).  Oh, and <code>(c = getchar()) != EOF</code> since your first want to store your character and then do the comparison.</p>

<p>I also changed <code>%d</code> to <code>%c</code> so that the characters are printed, you could change this back if you want, it depends what you actually want the program to produce.</p>
",1
18863200,18863113,1,"<ol>
<li>Initialize <code>i</code> to 0.</li>
<li><p>In your code:</p>

<pre><code>c = (getchar() != EOF)
</code></pre>

<p>means c is a boolean value rather than the char you get from input. Change it to:</p>

<pre><code>(c = getchar()) != EOF
</code></pre></li>
</ol>
",3
18863280,18863113,1,"<p>Why read char by char? Just read the line.</p>

<pre><code>char line[50];
fgets(line, sizeof(line), fp);
// line now contains ""1001\n"". You can chop off the \n with the following line:
line[strlen(line)-1] = '\0';
</code></pre>
",0
18940060,18939914,2,"<p>(1) Change variable c to an int so it recognizes EOF.</p>

<p>(2) Don't increment i before your printf or you will be printing junk. </p>

<p>Not sure what you are trying to accomplish with the echo thing.</p>
",7
18944200,18943181,1,"<p>OP is not returning a value from function nor copying data as needed.</p>

<pre><code>// Function return value of `void` needs to be `void *`.
// `length` should be of type size_t
// The former length of `p` needs to be passed.
// Potential NULL pointers need testing.
void updateSize(void* p,int length) {
  // Missing data copy.
  // Allocate new memory and copy before freeing old
  free(p);
  // Returned value from malloc needs saving.
  // No reason for 'sizeof()'
  malloc(sizeof(p) * length);
}

// Recommend
void *updateSize2(void* p, size_t OldLength, size_t NewLength) {
  void *p2 = malloc(NewLength);
  if (p &amp;&amp; p2) {
    memcpy(p2, p, OldLength &lt; NewLength ? OldLength : NewLength);
  }
  if (p2 || (NewLength == 0)) {
    free(p);  // Note A
  }
  return p2;
}
</code></pre>

<hr>

<p>Note A: There is an interesting issue when <code>NewLength == 0</code>.  Some <code>malloc(0)</code> implementations return NULL, others return a pointer to ""no data"".  In the former, a NULL pointer does not <em>always</em> imply a failed <code>malloc()</code>.  Now as @sharth rightly points out that <code>free(p)</code> should only be called on memory allocation failure, the <code>if()</code> used here is conditional on <code>NewLength</code>.</p>
",2
19868783,19868729,3,"<p>Your first malloc is no good. You want to allocate space for <code>dim</code> pointers of type <code>char*</code>. So you need:</p>

<pre><code>board = malloc(dim*sizeof(char*));
</code></pre>

<p>And then the compilation error. That's because <code>&amp;board</code> is the address of <code>board</code>. Since <code>board</code> has type <code>char**</code>, then <code>&amp;board</code> has type <code>char***</code>. Which is what the compiler said. You need to pass <code>board</code> rather than <code>&amp;board</code>.</p>

<pre><code>printBoard(board, dim);
</code></pre>
",0
19868798,19868729,0,"<p><code>&amp;varname</code> gives you a pointer to that variable. <code>&amp;board</code>, where board is an <code>int**</code>, gives you a pointer to an <code>int**</code>; in other words, and <code>int***</code>.</p>
",0
19869657,19868729,0,"<p>You have defined your board space to be of type char, but what happens when your needs change?  You should probably provide a struct or typedef, then changes are a little easier to make, should your needs/requirements change.</p>

<pre><code>typedef char boardspace;
</code></pre>

<p>You could just allocate a single array, of dimension rowsize x columsize, and then use a forumla to find the board position by calculating position = row*columsize+column,</p>

<pre><code>boardspace* BoardNew(int dim)
{
    int i;
    if (dim&lt;4) dim=4;
    //allocate as single array, dim x dim
    boardspace* newboard = malloc(sizeof(boardspace)*dim*dim);
    return newboard;
}
void BoardPrint (boardspace* board, int dimension);
</code></pre>

<p>Using this approach, you would convert a location pair (row,column) into an array location using a formula/function,</p>

<pre><code>int boardposition(int dim, int row, int col)
{
    return row*dim + col;
}
</code></pre>

<p>Or, you can allocate an array of rows, each containing a pointer to the array of columns.  But that means you need to check the result of multiple mallocs, and the error handling becomes more difficult,</p>

<pre><code>//or,
boardspace** BoardNew(int dim)
{
    int i;
    int error=0;
    //allocate as array of rows of pointers to columns
    boardspace** rows = malloc(sizeof(boardspace*)*dim);
    for (i = 0; i &lt; dim; i++)
    {
        if( !( rows[i] = malloc(sizeof(boardspace))) ) error++;
    }
    if( error ) {
        for (i = 0; i &lt; dim; i++)
        {
            free(rows[i]);
        }
        free(rows);
    }
    return rows;
}
void BoardPrint (boardspace** board, int dimension);
</code></pre>

<p>The above choices drive everything else.</p>

<p>You could recognize that you may need more than just a single character for board location (perhaps a content list, and lots of other stuff).  Here you have the same choices for one-dimension vs. two-dimension board allocation, but you also have a board containment structure, which can store both the board, and the dimensions.</p>

<pre><code>typedef struct space_s
{
    char space;
} SpaceObj;
typedef struct board_s
{
    int dim;
    SpaceObj* board;
} BoardObj;
</code></pre>

<p>Allocate a board in one dimension, using the aforementioned board position formula,</p>

<pre><code>BoardObj* BoardNew(int dim)
{
    if (dim&lt;4) dim=4;
    BoardObj* bp = malloc(sizeof(BoardObj));
    if(!bp) return NULL;
    bp-&gt;dim = dim;
    SpaceObj* sp = malloc(sizeof(SpaceObj)*dim*dim);
    if(!bp) { free(bp); return NULL; }
    return sp;
}
void BoardPrint (BoardObj* board);
</code></pre>

<p>Note that by storing dimension in the board structure, you do not have to carry that value around,</p>

<pre><code>int boardposition(BoardObj* board, int row, int col)
{
    return row*(board-&gt;dim) + col;
}
</code></pre>

<p>Or you can use the two-dimension approach, but for the board structure,</p>

<pre><code>//or,
typedef struct board_s
{
    int dim;
    SpaceObj** rows;
} BoardObj;
BoardObj* BoardNew(int dim)
{
    int i;
    int error=0;
    if (dim&lt;4) dim=4;
    BoardObj* bp = malloc(sizeof(BoardObj));
    if(!bp) return NULL;
    bp-&gt;dim = dim;
    SpaceObj** rows;
    if( !(rows = malloc(sizeof(SpaceObj*)*dim)) ) { free(bp); return NULL; }
    bp-&gt;rows = rows;
    for (i = 0; i &lt; dim; i++)
    {
        bp-&gt;rows[i] = rows[i] = malloc(dim);
    }
    if(error) {
        for (i = 0; i &lt; dim; i++)
        {
            free(rows[i]);
        }
        free(rows);
        free(bp);
    }
    return bp;
}
void BoardPrint (BoardObj* board);
</code></pre>

<p>And you need to allocate, and pass around your board in different ways, here they are illustrated,</p>

<pre><code>main()
{
    int dim = 8;
    //and then you have one of these to manipulate,
    boardspace* board = BoardNew(dim);
    boardspace** board = BoardNew(dim);
    BoardObj* board = BoardNew(dim);
    BoardObj* board = BoardNew(dim);

    //which can be addressed in the appropriate way,
    BoardPrint(board, dim);
    BoardPrint(board, dim);
    BoardPrint(board);
    BoardPrint(board);

}
</code></pre>
",0
18938874,18938844,3,"<p>When you pipe data from one program to another it's as if you typed the output of the first into the second.  In this case the file name can be read from stdin, and one way to read it is with the <code>fgets</code> function.</p>
",0
18938885,18938844,0,"<p>You're trying to read from stdin, which means you could use <code>fread</code> (<code>man 3 fread</code> on *nix, <a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/fread.html"" rel=""nofollow"">here</a> if you aren't.) to read from it.</p>

<p><code>stdin</code> is just a name for a standard file-descriptor, so you can read from it like any other file.</p>
",0
19874985,19874800,1,"<p>SirDarius gave a nice explanation about code.</p>

<p>You said </p>

<blockquote>
  <p>barely understand what they are useful for</p>
</blockquote>

<p>In fact , you can consider , that structs are a kind of ""data saver"" where you can store DIFFERENT or MULTIPLE types of data .</p>

<p>For example , using arrays , you can not store both x and y coordinates at a cell (Multiple types of Data).</p>

<p>Moreover , if you want to store a Student's School Info , you may want to store , his unique ID (integer) ,his name (string) , his grade (integer) and the average of each lesson (float) (Different Data). Using structs you can easily store them that way :</p>

<pre><code>struct Student {
int ID;
char * name;
int grade;
float average;
}
</code></pre>

<p>Hope that helped to understand ,the reason why structs are really useful :)</p>
",0
19874846,19874800,3,"<p>If you need to create an array of 5 points, first you have to define what a point is.</p>

<p>For example:</p>

<pre><code>struct Point {
    int x;
    int y;
};
</code></pre>

<p>Then you have to define an array of 5 points:</p>

<pre><code>struct Point array_of_points[5];
</code></pre>

<p>And you can use it like this:</p>

<pre><code>array_of_points[0].x = 20;
array_of_points[0].y = 10;
// etc...
array_of_points[4].x = 3;
array_of_points[4].y = 8;
</code></pre>
",6
19875408,19874800,0,"<p>Braces are missing as below when computing the average,</p>

<pre><code>obs.avgX = (arr[0].y + arr[1].y + arr[2].y + arr[3].y + arr[4].y) / 5;
</code></pre>

<p>Also to print a double type variable you should be using <code>%f</code> as the format specifier rather than <code>%d</code>.</p>
",4
18939929,18939918,2,"<p>Your first <code>else</code> has no <code>if</code> for it. This one</p>

<pre><code>    //Quit for selection 4
    else if (user_selection = 4) {
</code></pre>

<p>Also, as @Yu Hao noted in the comments, equality comparison operator in C++ is <code>==</code>, not <code>=</code>.</p>

<p>The idea behind the preceding <code>for</code> cycles also escapes me. Do you actually understand what <code>for</code> statement does? I strongly suspect that you don't. </p>

<p>If you add a <code>}</code> before that <code>else</code>, it should properly balance <code>if</code>'s and <code>else</code>'s in your code, but it still won't make those <code>for</code>'s do anything meaningful.</p>
",1
18939940,18939918,0,"<p>This is the structure of the code you have provided:</p>

<pre><code>if (...) {
    for (...) {
        ...
    }
    // there is no if preceding else on the next line
    else if (...) {
        ...
    }
// missing }, scope of the first if is not closed properly
else {
    ...
}
</code></pre>

<p>Also this line:</p>

<pre><code>for (user_selection = 1; user_selection&lt;=1; user_selection++) {
</code></pre>

<p>makes the loop completely useless, i.e. it is the same like there would be no loop, just another scope:</p>

<pre><code>{
</code></pre>
",0
18939950,18939918,0,"<p>You're missing a closing brace ""}"" for the if just before the else if and the ""Quit for selection 4"" comment.</p>
",0
18939964,18939918,0,"<p>use <code>switch</code> case instead for user selection</p>

<pre><code>switch(user_selection)
{
 case 1:
 //do something i.e. make donation
 case 2:
 //do something
 .
 .
 .
 default:
}
</code></pre>

<p><b>EDIT</b>: Try the following code. The only thing I have added is a <code>}</code> which you missed and '&amp;' sign before <code>%d</code> and <code>%f</code>.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

main ()
{
        //variables
        int user_selection, count_donate=0, count_invest=0;
        float balance_of_fund, donate_amt, invest_amt;

        //input
        printf(""Welcome!\n"");
        printf(""What is the initial balance of the fund?\n"");
        scanf(""%f"",&amp;balance_of_fund);

        //provide user with options
        printf(""What would you like to do?\n 1 - Make a donation\n 2 - Make an investment\n 3 -Print balance of fund\n 4 - Quit\n"");


        //work with user selectiom
        scanf (""%d"",&amp;user_selection);

        if (user_selection &gt; 0 &amp;&amp; user_selection &lt; 4)
        {

                    //ask for donation amount
                    for (user_selection = 1; user_selection&lt;=1; user_selection++)
                    {
                                printf(""How much would you like to donate?\n"");
                                scanf(""%f"",&amp;donate_amt);
                                balance_of_fund = balance_of_fund + donate_amt;
                                count_donate++;
                    }

                //ask for investment amount
                    for(user_selection = 2; user_selection&lt;=2; user_selection++)
                    {
                                printf(""How much would you like to invest?\n"");
                                scanf (""%f"",&amp;invest_amt);
                                balance_of_fund = balance_of_fund - invest_amt;
                                count_invest++;
                    }

                    //print out final balance for selection 3
                    for (user_selection = 3; user_selection&lt;=3; user_selection++)
                    {
                                printf(""The final balance is $%.2f."", balance_of_fund);
                                printf(""There were %d donations and %d investments."",count_donate,count_invest);
                    }
        }
   //Quit for selection 4
        else if (user_selection == 4)
        {
                printf(""The final balance is $%.2f."",balance_of_fund);
        }
        else
        {
                    printf(""Please make a valid selection"");
        }
        return 0;
</code></pre>

<p>}</p>
",2
19964350,19940969,1,"<pre><code>#include &lt;stdio.h&gt;

typedef long Value;

#define SCN_Value ""ld""
#define PRI_Value ""ld""

static int num_digits(Value number)
{
    Value n0 = number;
    int r = 0;
    int ndigits = 0;
    while (number != 0)
    {
        ndigits++;
        if (number % 10 == 0 &amp;&amp; r++ == 0)
            fprintf(stderr, ""Number %"" PRI_Value "" should not have any zero digits\n"", n0);
        number /= 10;
    }
    return ndigits++;
}

static Value prompt_for(char const *tag)
{
    Value number = -1;
    while (printf(""%s = "", tag) &gt; 0 &amp;&amp;
           scanf(""%"" SCN_Value, &amp;number) == 1 &amp;&amp;
           number &lt;= 0)
    {
        printf(""Number (%"" PRI_Value "") must be greater than 0.\n"", number);
    }
    return number;
}

int main(void)
{
    Value num1, num2;

    printf(""Enter two numbers to test if the second is a circular\n"");
    printf(""transformation of the first.\n"");
    printf(""**NOTE**\nThe numbers cannot have 0 as one of their digits.\n"");

    if ((num1 = prompt_for(""a"")) &lt; 0)
        return 1;
    int digits1 = num_digits(num1);

    if ((num2 = prompt_for(""b"")) &lt; 0)
        return 1;

    while (digits1 != num_digits(num2))
    {
        printf(""The two numbers must have the same number of digits.\n"");
        if ((num2 = prompt_for(""b"")) &lt; 0)
            return 1;
    }

    Value pow_10 = 1;
    for (int i = 1; i &lt; digits1; i++)
        pow_10 *= 10;

    Value temp = num2;
    for (int i = 1; i &lt;= digits1; i++)
    {
        if (temp == num1)
        {
            printf(""%"" PRI_Value "" is a circular transformation of %"" PRI_Value ""\n"", num2, num1);
            return 0;
        }
        int last_digit = temp % 10;
        temp /= 10;
        temp = temp + last_digit * pow_10;
        printf(""rotation = %"" PRI_Value ""\n"", temp);
    }
    printf(""%"" PRI_Value "" is not a circular transformation of %"" PRI_Value ""\n"", num2, num1);
    return 0;
}
</code></pre>
",2
20185951,20185891,3,"<p>Your code is equivalent to.</p>

<pre><code>void strcpy2(char *s, char *t) {

       while (*t) {
         *s = *t;
          s++;
          t++;
         }
        *s = *t;
     }
</code></pre>

<p>When the char that t points to is '\0', the while loop will terminate.<br>
Until then, it will copy the char that t is pointing to to the char that s is pointing to, then increment s and t to point to the next char in their arrays.</p>
",0
20185904,20185891,2,"<p>strings in c are followed by <code>'\0'</code> character. This should be the terminating condition for source string. This may be like:</p>

<pre><code>void strcpy2(char *s, char *t)
{
  while (*s !='\0')
    {
       *(t) = *(s);
       s++;
       t++;
    }
    *t = '\0';
}
</code></pre>

<p><p> Note: suffecient memory should be allocated for <code>t</code>, otherwise you'll get segmentation fault.</p>
",0
20185913,20185891,6,"<p>It stops because <code>*s</code> evaluates to 0. </p>

<p>That is, the last character copied was <code>\0</code> (the string terminator).</p>

<p>Evaluating to 0 is the way a boolean false is represented in C, so the loop exits when this happens.</p>
",0
20185916,20185891,1,"<p>In C, end of string is marked with NULL terminator, <code>\0</code>, i.e. with value = 0.</p>

<p>In C, any non-zero value is considered as true &amp; 0 is false.</p>

<p>When end of string is reached, the while loop sees a <code>0</code> in condition &amp; thus, exits.</p>
",0
19965972,19965953,4,"<pre><code>if(argc == 2);
</code></pre>

<p>is equivalent to</p>

<pre><code>if(argc == 2)
    ;
</code></pre>

<p>You need to remove the <code>;</code> to have the block after this be executed conditionally</p>

<pre><code>if(argc == 2)
//           ^ no trailing ; now
{
    sscanf(argv[1], ""%lf"", &amp;a); // now only executed if argc == 2
</code></pre>
",0
19972196,19972154,7,"<p>There is no sequence point between the assignments in</p>

<pre><code>*pa ^= *pb ^= *pa ^= *pb;
</code></pre>

<p>So the behaviour is not defined.</p>

<p>Neither is there a sequence point between the assignments in</p>

<pre><code>a ^= b ^= a ^= b;
</code></pre>

<p>So the behaviour of that line is also undefined. If that happened to work then you were (un)lucky.</p>
",3
19972199,19972154,3,"<p>You need an intervening sequence point. Otherwise, this is undefined behavior.</p>
",0
19972361,19972154,1,"<p>Before answering your question I would like to introduce:</p>
<h2><a href=""http://en.wikipedia.org/wiki/Sequence_point"" rel=""nofollow noreferrer"">Sequence point</a>:</h2>
<blockquote>
<p>A sequence point is a point in time at which the dust has settled and all side effects which have been seen so far are guaranteed to be complete.</p>
</blockquote>
<h2>The Standard states that:</h2>
<blockquote>
<p>Between the previous and next sequence point an object shall have its <strong>stored value modified at most once</strong> by the evaluation of an expression. Furthermore, the prior value shall be accessed only to determine the value to be stored.</p>
</blockquote>
<p>Now, your problem is that, in the expressions</p>
<pre><code>a ^= b ^= a ^= b;  
</code></pre>
<p>and</p>
<pre><code> *pa ^= *pb ^= *pa ^= *pb;  
</code></pre>
<p>There is only one sequence point <code>;</code> (at the end of expressions) and you are modifying <code>a</code> <strong>twice</strong> in first expression and <code>*pa</code> in second expression between two sequence point (previous <code>;</code> and the <code>;</code> at the end of these expressions here) which causes the behavior of program <strong>undefined</strong>.</p>
<p>Further reading: <a href=""http://www.c-faq.com/expr/seqpoints.html"" rel=""nofollow noreferrer"">comp.lang.c FAQ list ¡¤ Question 3.8</a>.</p>
",0
19973878,19973679,0,"<p>Try putting a <code>getch()</code> before the <code>return 0</code> statement. Don't forget to <code>#include &lt;conio.h&gt;</code>.<br/><br/>
What is happening is that the program displays the result and closes immediately.</p>

<p><strong>EDIT:</strong><br/>
Assuming you are on windows</p>
",3
19974812,19973679,1,"<p>As Shubham suggested, try putting something at the end of the program that prevents the windows command line interface from closing instantly.</p>

<p>A <a href=""http://en.cppreference.com/w/c/io/getchar"" rel=""nofollow""><code>getchar()</code></a> from <code>stdio.h</code> is more appropriate than <code>getch()</code> from conio, because it's in the standard library.</p>

<p>If you run the program from a command line interface and not by double clicking the icon or hitting the run-button in the IDE your program runs fine without the <code>getchar()</code>, as you would expect.</p>

<p>You can also check if your IDE supports an option to leave the command line interface open after the program has terminated.</p>

<p>Another option is setting a breakpoint on the last line of your <code>main()</code> function.</p>
",0
19975679,19973679,0,"<p>you have include one more header file like   <strong>conio.h</strong> . you may aware of this one....sorry to remember you this basic header file for output window.......then before your <strong>return 0;</strong> line just write  <strong>getch();</strong></p>

<p>Sample like:</p>

<pre><code>#include &lt;stdio.h&gt; 
#include &lt;conio.h&gt;
</code></pre>

<p>int main()</p>

<pre><code>{ 

  /* your code to check conditions for which number is greater among these numbers  */

  getch();

 return 0;

}
</code></pre>
",1
15555533,1054802,0,"<pre><code>Here is the Ans to find Kth smallest element from an array:

#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;
#include&lt;iostream&gt;
using namespace std;
int Nthmin=0,j=0,i;
int GetNthSmall(int numbers[],int NoOfElements,int Nthsmall);
int main()
{
    int size;
    cout&lt;&lt;""Enter Size of array\n"";
    cin&gt;&gt;size;
    int *arr=(int*)malloc(sizeof(int)*size);
    cout&lt;&lt;""\nEnter array elements\n"";
    for(i=0;i&lt;size;i++)
        cin&gt;&gt;*(arr+i);
    cout&lt;&lt;""\n"";
    for(i=0;i&lt;size;i++)
        cout&lt;&lt;*(arr+i)&lt;&lt;"" "";
    cout&lt;&lt;""\n"";
    int n=sizeof(arr)/sizeof(int);
    int result=GetNthSmall(arr,size,3);
    printf(""Result = %d"",result);
    getch();
    return 0;
}

int GetNthSmall(int numbers[],int NoOfElements,int Nthsmall)
{
    int min=numbers[0];
    while(j&lt;Nthsmall)
    {
        Nthmin=numbers[0];
        for(i=1;i&lt;NoOfElements;i++)
        {
            if(j==0)
            {
                if(numbers[i]&lt;min)
                {
                    min=numbers[i];
                }
                Nthmin=min;
            }
            else
            {
                if(numbers[i]&lt;Nthmin &amp;&amp; numbers[i]&gt;min)
                    Nthmin=numbers[i];
            }
        }
        min=Nthmin;
        j++;
    }
    return Nthmin;
}
</code></pre>
",0
18829476,18829288,5,"<p>Referring the invalid writes/reads logged by Valgrind:</p>

<p>You allocate 1 byte and set <code>size</code> to <code>20</code>:</p>

<pre><code>char *word, c, *keyWord = (char*)malloc(sizeof(char));
...
int size = 20;
</code></pre>

<p>This should somehow be linked, for example like this:</p>

<pre><code>int size = 20;
char *word, c, *keyWord = malloc(size * sizeof(*keyWord));
</code></pre>

<hr>

<p>Also it seems you are missing to allocate room for the ""string""'s <code>0</code>-terminator. In C ""strings"" are character array which have their last valid character indicated by a following <code>NUL</code> character.</p>

<p>So you always need to allocate <strong>one more</strong> then the maximum number of characters the ""string"" shall be able to hold.</p>

<hr>

<p>Btw: In C there is no need to cast <code>malloc/calloc/realloc</code>, nor is it recommended: <a href=""https://stackoverflow.com/a/605858/694576"">https://stackoverflow.com/a/605858/694576</a></p>
",0
18768027,18767976,5,"<p><code>sprintf</code> prints <em>into</em> a string an returns the number of characters so printed.  The first argument to the <code>sprintf</code> call should be the string to print into:</p>

<pre><code>char buffer[30];
int n = sprintf(buffer, ""%1.10f"", modeTimeTotal/num_tests);
printf(""Printed %d characters.  String is '%s'\n"", n, buffer);
</code></pre>

<p>You're getting the warning you are because you're trying to shoehorn the <code>modeTimeTotal/num_tests</code> into the format string argument to <code>sprintf</code>.</p>
",0
18768033,18767976,0,"<p>sprintf() returns the number of characters printed (not including the NUL terminator byte).</p>

<p>You should use it like this:</p>

<pre><code>char buf[512];
sprintf(buf, ""%30s%1.10f"", """", modeTimeTotal/num_tests);
printf(""%s\n"", buf);
</code></pre>
",1
20204955,20204826,2,"<pre><code> while(scanf(""%d"",&amp;num != EOF))
</code></pre>

<p>This looks like misplaced parentheses -- it might compile, but almost certainly isn't
what you intended.  Try this instead:</p>

<pre><code> while(scanf(""%d"",&amp;num) == 1)
</code></pre>

<p><code>scanf</code> returns the number of fields successfully converted, so for your problem
you need to compare the return value to 1, instead of EOF.</p>
",2
18255542,18255394,5,"<p>Firstly, your scanf is wrong. it needs to be passed by reference:</p>

<pre><code>scanf(""%d"", &amp;x);
</code></pre>

<p>Secondly, you should set x to something other than 0 before scanf'ing it, just in case. The way it is written, you have no exit condition in your loop.</p>

<p>You could try using gdb and stepping it line by line if you want to get right into it.</p>

<p>Hope this helps</p>
",1
20096773,20096535,3,"<p>You can use a couple of arrays in one struct in a following way: </p>

<pre class=""lang-js prettyprint-override""><code>typedef struct 
{
    int x[10];
    int y[10];
} coords;


coords c;

printf(""Enter a couple of X coordinates: "");
scanf(""%d"", &amp;c.x[0]);
scanf(""%d"", &amp;c.x[1]);

printf(""Enter a couple of Y coordinates: "");
scanf(""%d"", &amp;c.y[0]);
scanf(""%d"", &amp;c.y[1]);
</code></pre>

<p>Note that in <code>scanf()</code> you should pass pointers to array elements and not elements.</p>

<p>Also you can do it using <strong>one</strong> 2-D array (X_COOR and Y_COOR can be removed):</p>

<pre class=""lang-js prettyprint-override""><code>#define X_COOR 0
#define Y_COOR 1
typedef struct 
{
    int coords[2][10];
} coords;    

coords c;

printf(""Enter a couple of X coordinates: "");
scanf(""%d"", &amp;c.coords[X_COOR][0]);
scanf(""%d"", &amp;c.coords[X_COOR][1]);

printf(""Enter a couple of Y coordinates: "");
scanf(""%d"", &amp;c.coords[Y_COOR][0]);
scanf(""%d"", &amp;c.coords[Y_COOR][1]);
</code></pre>
",4
20096819,20096535,0,"<p>You code is fine except you have to place <code>&amp;</code> operator before the argument of each <code>scanf</code>.  </p>

<pre><code>scanf(""%d"", &amp;x.arr[0]);  
</code></pre>

<p>For Y co-ordinates you should have to define another array inside your structure.  </p>
",0
20097204,20096535,0,"<p>Create another struct for array element:</p>

<pre><code>typedef struct 
{
    int x;
    int y;
} coord;

typedef struct 
{
    coord arr[10];
} coords;
</code></pre>

<p>Usage:</p>

<pre><code>scanf(""%d"", &amp;x.arr[0].x);
</code></pre>
",0
20097221,20096535,1,"<p>A nicer solution is of course to do an array of struct, since the core thing you're interested in (a coordinate expressed as a pair of values) can be modelled well as a struct:</p>

<pre><code>typedef struct {
  int x, y;
} coordinate;
</code></pre>

<p>then you can declare an array easily enough:</p>

<pre><code>coordinate my_coords[100];
</code></pre>
",0
20633121,20632867,0,"<p>This is the case of ¡®¡®divide-by-zero¡¯¡¯ floating point exception. You should consider this case in your program to avoid it.</p>
",0
20632916,20632867,2,"<p>You will get a <code>nan</code> if you divide a zero by zero in this case if <code>white</code> is 0. You can't divide zero by zero because the result is not a number(that's what <code>nan</code> stands for). To avoid that add special handling for the case when <code>white</code> is 0.</p>
",15
20632917,20632867,2,"<p>You are dividing by zero. What result did you expect?</p>

<p>Your code is pretty strange to begin with, why scan floats if yuo expect them to be in the 8-bit range of 0..255?</p>

<p>You need to protect against the division by checking if the value is 0 before doing the divide. When it is 0, you need to substitute whatever value makes the most sense, probably zero for all of the CMY components. The black (K) will become 1 if <code>white</code> is 0, which is what you want.</p>
",2
20632976,20632867,1,"<p>In your code, <code>white</code> is 0, and you are trying to divide by <code>Zero/Zero</code>. <code>nan</code> stands for <code>Not A Number</code>. You will get this when you try to divide by zero.</p>

<pre><code>white=max(r/255,g/255,b/255);//will return 0 if you enter r = 0.0,g = 0.0,b = 0.0
</code></pre>

<p>So, <code>white</code> will be having <code>0.0</code>;</p>

<pre><code>cyan=(white-r/255)/white; // here you are doing 0.0/0.0 (white = 0.0, r = 0.0)
</code></pre>
",1
20104061,20103833,0,"<p>I think your approach is wrong. As I have understood from your explanation, the string must start with ""XYZ1"" and after this you may have no matter how many 1 (just 1, not other characters). So, it would be very simple to check for the first part using <code>strncmp</code>, and then check if remaining characters are all 1. </p>

<pre><code>c=fgetc(input);
if(strncmp(c, ""XYZ1"", 4) == 0){
    //check if remaining characters are 1
}else{
    //the string does not match
}
</code></pre>

<p>Also, while(!feof(input)) is discouraged: <a href=""https://stackoverflow.com/questions/5431941/while-feof-file-is-always-wrong"">Why is ¡°while ( !feof (file) )¡± always wrong?</a></p>
",0
20104017,20103833,0,"<pre><code>while(1)
</code></pre>

<p>This is your problem.</p>

<p>Within this <code>while</code> loop, you have a <code>switch</code> statement full of <code>break;</code>s.  These <code>break;</code>s will only get you out of the <code>switch</code> and will not get you out of the <code>while</code> loop.  You have no way of getting out of this loop.</p>

<p>I have no earthly idea of what exactly the program is supposed to do (and I just spent 5 minutes fixing the formatting), so I can't currently make a recommended fix, but this is the problem.</p>

<hr>

<p>Per @woolstar's comment, the inner <code>while</code> loop is unnecessary.  The <code>while(!feof(input))</code>  can take care of repeatedly calling the switch statement.  You will probably need to move the <code>int state = 1;</code> outside of this outer <code>while</code> loop however.</p>
",1
18254530,18254463,2,"<p>Use <code>abs()</code> function for absolute values. Include <code>stdlib.h</code> header for this.<br>
Some other corrections:  </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
     int i,n;
     int v[100];
     printf (""Please write n:"");
     scanf(""%d"",&amp;n);
     for (i=0;i&lt;n;i++)
     {
            printf( ""Write the element %d\n"",i);
            scanf(""%d"", &amp;v[i]);
     }
     for (i=0;i&lt;n-1;i++)
     {
            if(abs(v[i])==abs(v[i+1]))
                printf(""|v[%d]|=|v[%d]|\n"",i,i+1);
     }
     return 0;
}
</code></pre>
",5
18254582,18254463,0,"<p>You need to us the <strong>abs()</strong> function.   You need to make sure you have <strong>brackets</strong> set up right.  You also need to be careful when looping through arrays (you may go <strong>out of bounds</strong>).  </p>

<p>Here is something that can help:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    int i,j,n;
    int v[100];
    printf (""Please write n: "");
    scanf(""%d"",&amp;n);
    for (i=0;i&lt;n;i++)
    {
        printf( ""Write the element %d \n"",i);
        scanf(""%d"", &amp;v[i]);
    }
    for (i=1;i&lt;n;i++)
    {
        if(abs(v[i-1])==abs(v[i]))
        {
            printf(""Elements at positions %d and %j \n"",i-1, i);            
            printf(""Elements are %d and %d \n"",v[i-1], v[i]);
        }  
    }
    for (j=1;j&lt;n;j++)
    {
        if(abs(v[j-1])==abs(v[j]))
        {
            printf(""Elements at positions %d and %j \n"",j-1, j);
            printf(""Elements are %d and %j \n"",v[j-1], v[j]);
        }
    }

    return 0;
}
</code></pre>
",4
18254604,18254463,0,"<p>you can't use the ""|x|"" for absolute value. just for <code>or</code> statement and bitwise.</p>

<p>in order to do absolute you need to write the code yourself or use <code>abs</code> function</p>

<p>on top of that you have a bunch of synex errors</p>

<ul>
<li>No main function</li>
<li><code>printf(""Elements are %d',v[i]"");</code> isn't right, u meant to do <code>printf(""Elements are %d"",v[i]);</code></li>
</ul>

<p>some suggestions:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

main()
{
    int i,j,n;
    int v[100];
    printf(""Please write n:"");
    scanf(""%d\n"",&amp;n);
    for (i=0;i&lt;n,i++)
    {
       printf(""Write the element %d"",i);
       scanf(""%d\n"", &amp;v[i]);
    }

    for (i=0;i&lt;n-1;i++)
    {
     if(abs(v[i])==abs(V[i+1]))
        printf(""Elements %d and %d are absolute equal"", v[i], v[i+1]);
    }
}
</code></pre>
",4
20750572,20749351,0,"<p>If you write p = (int(*)[10][2])a; it won't give you any errors, may be a warning. You are thinking that p will be converted to pointer to a 3-D array, which is wrong. Try this statement after assigning a to p.</p>

<pre><code>printf(""addresses %u   %u"",p,p+1);
</code></pre>

<p>According to you, output should be something similar to this(lets say) ""addresses 9990000 99940000"", because you are thinking p is pointing to 3-D array. However you will get similar to ""addresses 9990000 9990004"", proving that p is a pointer to an integer.</p>
",0
19213515,19213457,2,"<p>There is no comparison operator for structs in <code>C</code>. You have to define your own comparison function and use it in place of <code>==</code>. Try something like this:</p>

<pre><code>bool equalPoints(const struct Point p1, const struct Point p2) {
    return (p1.x == p2.x) &amp;&amp; (p1.y == p2.y);
}

if (equalPoints(endPoint, pointOnHull)) { /* then code here */ }
</code></pre>

<p>or if your structure is more complex (though, this is probably not the case):</p>

<pre><code>bool equalPoints(const struct Point *p1, const struct Point *p2) {
    /* 
     * In case your structure is more complex here goes
     * more complex comparison code
     */
    return (p1-&gt;x == p2-&gt;x) &amp;&amp; (p1-&gt;y == p2-&gt;y);
}

if (equalPoints(&amp;endPoint, &amp;pointOnHull) { /* then code here */ }
</code></pre>

<p>the latter won't copy whole <code>Point</code> structure to pass it to <code>equalPoints</code>, but will pass pointer (reference type) instead. <code>const</code> is important because it won't let you accidentally modify points when you only want to compare them.</p>
",2
20182089,20182029,3,"<p>I would probably write the essential parts of this into a separate function, but here are the basics:<br>
<strong><em>Using Windows</em></strong> (per WinAPI reference in post)...</p>

<pre><code>#include &lt;ansi_c.h&gt;
#include &lt;windows.h&gt;


int main(void)
{
  char filename[ MAX_PATH ];
  char newLocation[]=""C:\\enterstartupdirhere"";//put actual path here (i.e. don't use as is)
  BOOL stats=0;
  DWORD size = GetModuleFileNameA( NULL, filename, MAX_PATH );
  if (size)
    CopyFile(filename, newLocation, stats);
  else
   printf(""Could not find EXE file name.\n"");
  return 0;
}
</code></pre>
",0
19214561,19214505,3,"<p>One problem is this line:</p>

<pre><code>int ad(int a, int b, int n)
</code></pre>

<p>Change it to:</p>

<pre><code>float ad(int a, int b, int n)
</code></pre>

<p>This line and a similar one above it confuses me:</p>

<pre><code>    q2=0;
    q2=q2+(z/3)*(2*f2);
</code></pre>

<p>Why set it to zero then set it to a value.  I expect it should be set to zero before the while loop.</p>
",1
19214581,19214505,3,"<p>you declared your function as to return int, but you are returning a float,
the result is:
the float you are returning gets truncated, and you only get int.</p>

<p>I'm guessing all your integrals had a value between 0 and 1, so the function returned just 0</p>

<p>just change <code>int ad(int a, int b, int n)</code> to <code>float  ad(int a, int b, int n)</code></p>

<p><strong>EDIT</strong>: 
<code>z=(b-a)/n;</code> all a, b and n are ints, you won't get the fractional part in this division.
try <code>z=(b-a)/(n * 1.0);</code> just to cast one of the opreands to float so you get the fractional part as well</p>
",2
20636191,20635753,0,"<p>The program works for me in your scenario IF I initialize the variable <code>stp</code> to 0. If think you can eliminate it altogether and use <code>valid</code> instead. This doesn't solve the buffer overflow for more than 50 characters, but I think this is not a concern for your scope of the problem.</p>

<p><strong>Edit:</strong> the code that solves all the problems (... except the number of characters overflowed)</p>

<p>Here's the <code>fgets</code> solution as suggested by Joachim Pileborg  (notice <code>dataTest[i] &gt;= '0'</code> and the elimination of the newline character):</p>

<pre><code>int valid, length, i;
char dataTest[50+3]; // 3: '\n','\0' + one more to test 50 characters overflow

do {

valid = 1;

printf(""\nPlease enter the packet data (maximum of 50 numbers): "");
fgets(dataTest, sizeof(dataTest), stdin);

length = strlen(dataTest);
--length;   //  remove last '\n'

if (length &lt;= 50) {
    for(i=0;i&lt;length &amp;&amp; valid;i++) { 

        if ( (dataTest[i] &gt;= '0' &amp;&amp; dataTest[i] &lt;= '9')) {

            valid=1; //set the valid variable equal to 1

        } else {

            printf(""\nData must contain only numbers, '%c' is not a number.Please try again. \n"", dataTest[i]);

           valid=0; //set the valid variable to equal 0

        }

    }
} else {
    printf(""\nData should have no more than 50 numbers"");
    valid = 0;
}

} while(valid!=1);
</code></pre>
",6
20648927,20635753,0,"<p>I think this sentence while(getchar()!='\n'); make you feel confused, you can get rid of it.</p>

<p>And the for loop should be </p>

<pre><code>for(i=0;i&lt;=length-1 &amp;&amp; stp!=1;i++) { 
    if ( dataTest[i] &gt;= '0' &amp;&amp; dataTest[i] &lt;= '9' ) {
        valid=1; 
    } else {
        printf(""\nData must contain only numbers, '%c' is not a number.Please try again. \n"", dataTest[i]);
        stp = 1;
        valid=0; 
    }
}
</code></pre>
",0
20192634,20192373,1,"<p>in general as you increase the optimization levels, you're asking the compiler to work harder, so compilation time is longer.  The execution time should be shorter, because that's the entire purpose of optimizing your code.</p>

<p>Naturally, your binary will be different based on how the compiler optimizes the code.</p>

<p>Optimizations may include:</p>

<ul>
<li>inlining code</li>
<li>removing temporary variables</li>
<li>simplifying expressions</li>
<li>and much more</li>
</ul>

<p>each of these can affect the code that is generated.</p>
",0
20193250,20192373,0,"<p>As I understand the question it is about why size optimized code is slower than speed optimized code or unoptimized code.</p>

<p>Many optimization techniques like inlining functions or unrolling loops gain speed by increasing code size.</p>

<p>When optimizing with -os all optimizations of -02 are applied that do not increase code size.
More details you find here:
<a href=""http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html"" rel=""nofollow"">http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html</a></p>
",0
19439535,19439493,3,"<p>Your <code>main</code> is wrong. Should be <code>int main(int argc, char **argv)</code>.
Then instead of</p>

<pre><code>    char *f1 = argv1[1];// taking filename1 from args
    char *f2 = argv2[1];// taking filename2 from args
    char *f3 = argv3[1];// taking filename2 from args
</code></pre>

<p>something like </p>

<pre><code>    char *f1 = argv[1];// taking filename1 from args
    char *f2 = argv[2];// taking filename2 from args
    char *f3 = argv[3];// taking filename2 from args
</code></pre>

<p>but before these lines you should check <code>argc</code> for correct number of arguments.
You probably meant <code>fp3 = fopen(f3,""w"");</code> instead of <code>fp3 = fopen(f2,""w"");</code>.</p>
",1
19441610,19441556,4,"<p><code>array</code> and <code>&amp;array</code> both yield a pointer to the same address, but with different types.  The former is equivalent in most situations to <code>&amp;array[0]</code>, a <code>char *</code> in your case.  <code>&amp;array</code>, however, is the address of the array itself, which has type <code>char (*)[10]</code> in your example.</p>
",4
19441635,19441556,1,"<p>array and &amp;array are not the same... even if they have same address location in it.</p>

<p>array here being char array, it points to a single char, and if you increment it increases by 1 char size.</p>

<p>but &amp;array points to the entire array and if increments it increases by the array size.</p>

<p>scanf function expects for the array.. not &amp;array</p>
",0
18360804,18360686,0,"<p>You can't with the standard facilities. The input functions block until you receive input and only then can you execute code again. So you have two options:</p>

<ol>
<li><p>Take the time before you wait for input. When you've received input, take the time again, and if the user took too long, reject the answer.</p></li>
<li><p>Use a different input system. For example, you can do it using Boost.Asio, although it's not exactly trivial.</p></li>
</ol>

<p><a href=""https://github.com/rtsuk/liaw2013/wiki/5.3-how-to-time-the-user"" rel=""nofollow"">https://github.com/rtsuk/liaw2013/wiki/5.3-how-to-time-the-user</a></p>
",8
18361244,18360686,2,"<p>Assuming a sufficiently POSIX-like system, you can use <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/alarm.html"" rel=""nofollow""><code>alarm()</code></a> with either 
<a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/signal.html"" rel=""nofollow""><code>signal()</code></a> or (better) 
<a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/sigaction.html"" rel=""nofollow""><code>sigaction()</code></a>.  In outline:</p>

<pre><code>static volatile sig_atomic_t alarmed = 0;

static void alarm_handler(int signum)
{
    signal(signum, alarm_handler);  // Uses signum ¡ª probably not strictly necessary
    alarmed = 1;
}

...

signal(SIGALRM, alarm_handler);
alarm(2*60);

if ((nbytes = read(line, sizeof(line), STDIN_FILENO)) &gt; 0)
{
    ...process normal answer...
}
else if (nbytes == 0)
    ...process EOF...
else if (errno == EINTR)
    ...check whether alarm went off ¡ª alarm_handler should set a flag...
else
    ...something broke ¡ª report error...
</code></pre>

<p>Given that you're probably using Standard I/O, you change the <code>read()</code> to <code>fgets()</code> and check for EOF with <code>feof()</code> and you can assume that you got an error without troubling <code>ferror()</code> and do the <code>errno</code> check.  You might prefer to set <code>errno</code> to 0 before calling the I/O function; it isn't strictly necessary, though.</p>

<p>You can cancel the alarm call at any point you wish by calling <code>alarm(0);</code>.</p>

<hr>

<p>I went digging in a program of mine called <code>timeout</code> which runs another command and waits for it to finish ¡ª but times it out if it doesn't finish quickly enough.  There are some notes that might help you in the comments:</p>

<pre><code>/*
** On MacOS X, the signal() function is implemented using sigaction()
** and includes SA_RESTART in the options, so that when the alarm times
** out, the signal catcher is called but wait() resumes, which is
** not what's wanted.  Hence, upgrade to use sigaction() directly (when
** available; assume it is available by default) without the SA_RESTART.
*/
static void set_interruptible_alarm_handler(void (*handler)(int))
{
#ifdef NO_SIGACTION
    /* Unlikely to be necessary on modern POSIX systems */
    signal(SIGALRM, catcher);
#else
    struct sigaction act;

    if (sigemptyset(&amp;act.sa_mask) != 0)
        err_syserr(""sigemptyset failed: "");
    act.sa_handler = handler;
    act.sa_flags = 0;
    if (sigaction(SIGALRM, &amp;act, 0) != 0)
        err_syserr(""failed to set signal handler\n"");
#endif /* NO_SIGACTION */
}
</code></pre>

<p>Using <code>sigaction()</code> is more verbose than <code>signal()</code>, but the control is better.</p>
",1
18361470,18360686,0,"<p>As you've said that you're using Turbo C, you can use <code>kbhit()</code>.<br>
<em><a href=""http://www.ousob.com/ng/turboc/ng35980.php"" rel=""nofollow"">Documentation Here</a></em></p>

<p>Its a non-portable function, but in Turbo C world, it will return a recently pressed key, or zero.</p>

<p>So you can put it in a loop that checks the current time, and if a key is hit.</p>
",0
19270649,19270420,4,"<blockquote>
  <p>... but when i input ¡°total¡± it doesn't start.Where is the mistake?</p>
</blockquote>

<p>Without commenting about the other problems, the reason that it doesn't start is that it goes into an infinite loop because you say:</p>

<pre><code>while(count&lt;total);
</code></pre>

<p>Remove the trailing <code>;</code>.</p>
",1
19270497,19270420,1,"<p><code>scanf()</code> is blocking call reading input from <code>stdin</code> until <code>EOL</code> is read. This means you have to start the program, type the desired number of primes and press enter, to end the input.</p>

<p>EDIT:
Some clarifications:</p>

<p><code>stdin</code> is standart input. By default it's keyboard input.</p>

<p><code>EOL</code> means end of line. It's a character marking end of line.</p>

<p>Blocking call means, that the program stops until the the call is finished. Functions for input are generally speaking blocking. Very simply put, the program is removed from processor, no instructions are executed, until the call is finished, unblocking the program.</p>
",0
19270855,19270420,0,"<p>The problem isn't with <code>scanf()</code> or <code>enter</code> as some suggested - this could be easily seen by <code>fflush</code>ing the output after the first <code>printf</code>.</p>

<p>I found the source for your code, and you forgot a little important <code>break</code> which does all the difference:</p>

<pre><code>while(count&lt;total)
{
    trial+=2;
    for(size_t i=0;i&lt;count;i++)
        if(!(found=(trial % *(primes+i))))
            break;  // &lt;-------------------- HERE.
        if(found)
            *(primes+count++)=trial;
}
</code></pre>

<p>Also, as suggested, there should be no trailing semicolon after the <code>while</code> clause-opening.</p>
",1
19270570,19270420,0,"<p>Just press ""Enter"" button to force your ""scanf"" to return its read value </p>
",0
18903255,18903159,0,"<p>Not exactly sure what you mean. Something like this?</p>

<pre><code>void clean(char** dirtyPointer)
{
    int i = 0, j = 0;
    char* dirty = *dirtyPointer;
    ...
</code></pre>
",1
18904431,18903159,0,"<p>Depending on what do you want to do, firs, note this in your main</p>

<pre><code>tab = (char**)realloc(tab, sizeof(char*));
</code></pre>

<p>So you are reallocation your 10 pointer array into an array of pointers of size 1. Doesn't seem correct(realloc changes the memory allocated of the given pointer into the supplied size, if you supply more, like length* sizeof ... you'll increase the array size, of you don't you just loose all the data.</p>

<p>Now if you want to apply the ""clean"" function to an array of strings (char *), then you should include the current max size of the array. I would suggest you this, faster.</p>

<pre><code>void clean_All(char ** strings, int size) 
{
     int i;

     if (strings == NULL)
         return;

     for(i = 0; i &lt; size; i++) {
         if (strings[i] == NULL)
             return; 
         clean(strings[i]);
     }

     return;
}
</code></pre>
",1
19502316,19502246,1,"<p>Use:</p>

<pre><code>ptr_file =fopen(""num.txt"",""rb"");

while(fread(buf, 1, 10, ptr_file) != 10) {
}
</code></pre>

<p>But, if you need to do this quick - I recommend open file by mmap(), and use quick custom atou() over the mmapped buffer.</p>
",0
19502322,19502246,1,"<p>Assuming you don't want to store them as integer, so can have same approach, to fill the 10 digits in <code>buf</code> as C strings (null terminated)</p>

<pre><code>while ( fgets(buf, 11, ptr_file) !=NULL )
   printf(""%s\n"",buf);
</code></pre>
",1
19502864,19502246,1,"<p>Since all chunks of data are 10 byte, be sure to start by reading 10 byes at a time.<br>
As data could be >= power(2,32), use type <code>unsigned long long</code> or <code>uint64_t</code> for subsequent numeric processing.</p>

<pre><code>inf = fopen(""num.txt"", ""rb"");  // Open in binary
#define ChunkSize (10)
char buf[ChunkSize + 1];         // Extra for \0
buf[ChunkSize] = '\0';
int result;
while((result = fread(buf, ChunkSize, 1, inf)) == 1) {
  unsigned long long x;
  char *endptr;
  x = strtoull(buf, 10, &amp;endptr);
  if (endptr != &amp;buf[ChunkSize]) {
    break;  // Syntax error
  }
  // Do something with x or buf;
}
if (result == 0) {
  ; // handle I/O error
}
</code></pre>
",0
20534106,20533759,0,"<p>Do the following:
1. Revise on structures
2. Get rid of <code>GOTO</code> in your code (its a bad programming standard)
3. proper code indentation</p>

<p>Go through the code below</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    struct info
    {
        char name[15];
        char surname[15];
        char gender[15];
        char education[15];

    } sem;

    FILE *fp=NULL;
    int i, a;
    char tmp[256] = {0x0};

    while(1)
    {
        printf(""Enter the value\n"");
        scanf(""%d"", &amp;a);

        if((fp = fopen(""info.txt"", ""r"")) != NULL)
        {

            switch(a)       // assuming your code is just an snippet and actual code has more than 2 conditions
            {               // use if-else if just 2 condition checks

                case 0:
                        exit(0);        // quit the program

                case 1: 

                    for(i=0;!feof(fp);i++)
                    {
                        fscanf(fp, ""%s %s %s %s"", sem.name, sem.surname, sem.gender, sem.education);
                        printf(""%s, %s, %s, %s\n"",sem.name,sem.surname,sem.gender,sem.education);
                    }   

                    break;

                case 2:

                    while (fgets(tmp, sizeof(tmp), fp) != NULL)
                    {
                        if (strstr(tmp, ""bachelors""))
                        {
                            /* Code works fine until this part */
                            fprintf(fp, ""\n%s %s %s %s"", sem.name, sem.surname, sem.gender, sem.education);                         
                        }   
                    }

                    break;

                default:    printf(""Default statement"");                                        
            }

            fclose(fp);

        }
    }
}
</code></pre>
",1
20533020,20532696,1,"<p>What output do you actually get? You say it doesn't want to print out the correct lines, but does that mean it prints all lines, no lines, some but not others?</p>

<p>Looking at your program, I would hazard a guess that every line is being printed out. You need braces around <code>if(strstr(tmp,""bachelors""))</code> if you want more than one statement in the body of the <code>if</code>.</p>

<p>EDIT:</p>

<p>In addition to your braces problem, you are attempting to use <code>fprintf</code> to print back to <code>fp</code>, which was opened in read mode (using the <code>r</code> flag). You need to use read/update mode (<code>r+</code>) if you want to modify info.txt. However, this is probably not the way you want to do this. </p>

<p>Firstly, you stated you wanted to ""printf"" the data, which means printing to standard out. If so then you should use <code>printf</code> instead of <code>fprintf</code>. On the other hand it would seem likely that what you want to do is to read lines from one text file and print data out to another file. In that case you probably want two files.</p>

<p>Even with the above modifications, you will be printing the same data to file each time, since the sem struct is not being updated at all.</p>

<p>Finally, your <code>fprintf</code> format string expects six inputs and you only have four (and an erroneous trailing <code>,</code>). Why?</p>
",1
20533194,20532696,1,"<p>printf/fprintf procedures use internal buffers to avoid calling the syscall ""write"" everytime.
I would say that you should add a '\n' character at the end of your string to actually force flushing the buffers writing the test. Moreover your token ""bachelors"" has to be in the 256 first characters of your file.<br> 
Second question depends on how your file is formatted, and you are the only one who knows that.</p>
",0
19439537,19439525,1,"<p>try this <code>scanf(""%s"", path);</code> instead because I think <code>path</code> is an array and a pointer to an array is the array name itself ( array == &amp;array  )</p>
",0
19439542,19439525,10,"<p>An array is already a pointer-like object (as dreamlax points out). You don't need the <code>&amp;</code> operator, since declaring </p>

<pre><code>char path[64];
</code></pre>

<p>is equivalent to setting <code>path</code> to a pointer to a 64-byte region of memory.</p>
",1
19439601,19439525,5,"<p>The <code>%s</code> format specifier requires you to supply a <code>char *</code>, which is a pointer to <code>char</code>.  You are passing <code>&amp;path</code>, which is a pointer to an array.  You can just pass <code>path</code> by itself, which will evaluate to a pointer to the first element of the array (the same as <code>&amp;path[0]</code>).</p>
",0
18900712,18900663,2,"<p>When you are making a prototype then it means that you want to call it elsewhere which is not the case for <code>main</code> function.</p>

<p>From the <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf"" rel=""nofollow"">docs</a>:-</p>

<blockquote>
  <p>5.1.2.2.1 Program startup</p>
  
  <p>1 The function called at program startup is named main. The
  implementation declares no prototype for this function. It shall be
  defined with a return type of int and with no parameters:</p>
  
  <p>int main(void) { /* ... */ } </p>
  
  <p>or with two parameters (referred to here as argc and argv, though any
  names may be used, as they are local to the function in which they are
  declared):</p>
  
  <p>int main(int argc, char <code>*argv[]</code>) { /* ... */ } </p>
  
  <p>or equivalent;9) or in some other implementation-defined manner.</p>
</blockquote>
",2
18900733,18900663,1,"<p><code>declaration or prototype</code> is not require for <code>main</code> function</p>

<p>functions other than <code>main</code> requires <strong>declaration and 
definition</strong></p>

<pre><code>int sum(int,int); //declaration
int sum(int a,int b) //definition
{
//body
}
</code></pre>
",0
18900757,18900663,1,"<p>You left out the rest of the quote from that section of the standard, I am going to quote the C99 draft standard which says:</p>

<blockquote>
  <p>or with two parameters (referred to here as argc and argv, though any names may be
  used, as they are local to the function in which they are declared):</p>
</blockquote>

<pre><code>int main(int argc, char *argv[]) { /* ... */ }
</code></pre>

<blockquote>
  <p>or equivalent;9) or in some other implementation-defined manner.</p>
</blockquote>

<p>The <code>shall be defined</code> is the quote is the important part, it says it must follow one of these two signatures or if available some implementation specific signature which would be defined by the compiler implementor.</p>

<p>If I attempt to build this in the latest version of <code>clang</code> I see the following errors:</p>

<pre><code>error: second parameter of 'main' (argument array) must be of type 'char **'
  int main(int a, int b, int c){}
error: third parameter of 'main' (environment) must be of type 'char **'
</code></pre>
",2
18900764,18900663,4,"<p>All it means is that <code>main</code> is not declared in advance.  There's no line like</p>

<pre><code>int main(int argc, char*argv[]);
</code></pre>

<p>and that means that when you define the function, you can pretend it takes any arguments and returns any type you like without getting a compiler error.</p>

<p>Of course, <code>main</code> is called by the operating system, so it will expect your definition to match whatever convention it uses for passing parameters.  In practice, except on embedded systems, your definiton for main has to match the above.</p>
",0
18865564,18865469,0,"<p>Try with compiler optimization levels like <strong>-O2, -O3</strong>. It should help you :)</p>

<p>Note:</p>

<p>For GCC family of  compilers try <strong>-O2 or -O3</strong></p>

<p>For MSVC try <strong>/O2 or /O3</strong></p>
",0
18865517,18865469,0,"<p>Well, the compiler can assume anything there. Integer overflow is Undefined Behavior. If you'd written <code>while (i==0)</code> 6.8.5.6  would apply.</p>
",0
20418708,20417913,0,"<p>Your input file has the wrong format. I mean, first you want to read the number of students, and then in your loop, you want to get ID, name and grades. But your input file has no student number line at first, instead it has ""ID, NAME, GRADE"" line. Changing your grades.txt file like this will solve the problem:</p>

<pre><code>3
2442
Kapowski, Kelly
87 99 100 87 88 -99
1254
Slater, A.C.
90 100 -99
8742
Morris, Zack
77 65 50 80 66 -99
</code></pre>
",1
20418836,20417913,0,"<p>You'll probably zero in on the problem in no time if you check the return value from the scanf calls. <code>scanf</code> returns the number of successfully converted items, so it should be</p>

<pre><code>if (scanf (""%s"", ...) == 1) {
    /* OK */
} else {
    /* Problem. */
}
...
if (fscanf (input_file, ""%lf"", &amp;value) == 1) {
    /* OK */
} else {
    /* Problem. */
}
</code></pre>
",0
20414803,20414501,0,"<p>From your comment, you issue is how to parse the Boolean expression out of the parenthesis.  </p>

<p>From your post assume the following classes of ""tokens"":  </p>

<ul>
<li>Parenthesis</li>
<li>Operators</li>
<li>Identifiers  </li>
</ul>

<p><strong>Operators</strong><br>
Operators are one or more symbol characters associated with identifiers.  The result of evaluating the symbols yields a Boolean result.  </p>

<p>Some <em>Boolean</em> operators from the C and C++ languages:  </p>

<pre><code>==, !=, &lt;, &lt;=, &gt;, &gt;=,  
&amp;&amp;, ||  
</code></pre>

<p><strong>Identifiers</strong><br>
From your post, identifiers can be numbers or ""variable names"".<br>
Examples:  <code>49, myVar, ketchup96</code>  </p>

<p><strong>Parenthesis</strong><br>
The foundation of your assignment is identifying and matching the parenthesis pairs, open and close.  The other part is identifying valid Boolean expressions.  </p>

<p><strong>The parsing tree</strong><br>
A common data structure for parsing is a binary tree.  A parent node is an operator and its two children are the identifiers.  The parenthesis determine how the parent and children are related, which is the exercise  of your assignment.  </p>

<p>Using pen/pencil and paper, write a simple Boolean expression, such as: <code>4 &lt; 5</code>.<br>
Read the identifier: 4, create node and put into tree.
Read the operator and create node.  Operator becomes parent, the identifier becomes the left child:  </p>

<pre><code>   &lt;
 /
4
</code></pre>

<p>Read in next identifier, create node, add as right child of operator:  </p>

<pre><code>  &lt;
 / \
4   5  
</code></pre>

<p>Write down the steps.
Take another expression follow the same steps.  </p>

<p>Now add in a 2nd expression and parenthesis.<br>
<em>How would you change your algorithm (steps) to handle parenthesis and another expression?</em>  </p>

<p>Keep refining your algorithm.<br>
Finally, code your algorithm.<br>
Test your code.  </p>

<p><strong>ADT</strong><br>
Search the web for ""ADT tutorial"" and also <strong>talk with your instructor</strong> about the ADT.  </p>

<p><strong>Parsing strings</strong><br>
Search the web and StackOverflow for ""C++ parse input tokens"".</p>
",0
20415406,20414501,0,"<p>You are making the problem harder than it needs to be.</p>

<pre><code>x&lt;=1
((x&gt;0) &amp;&amp; (x&lt;10))
(!x || !y)
</code></pre>

<p>These expressions only allow parenthesis, not brackets or braces.  So, there's no need to keep a stack recording which of parenthesis, brackets and braces has been encountered when... just keep a number recording the current depth of nesting.</p>

<p>I recommend that you use recursion to validate your input.  Specifically... scan from left to right considering whether the expression is legal so far, and if you reach ""("" at a place where it's legal then recursively call your validation function passing the address of the next character... it should return when it's consumed the matching "")"" and let you continue validating the rest of the expression on the basis that the ""()"" yielded a boolean value.</p>
",0
18985776,18985488,0,"<p>Here is the code that does the job for you:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;assert.h&gt;
#include &lt;string.h&gt;

#define SIZE        1024

int main(int argc, char* argv[])
{
    char *infile = ""Text.txt"";
    char ptrBuffer[SIZE];
    int fd = open(infile, O_RDONLY); /* read only */
    assert(fd &gt; -1);
    int n;
    while((n = read(fd, ptrBuffer, SIZE)) &gt; 0){ /*loops that reads the file                                until it returns empty */
        printf(""%s"", ptrBuffer);
        memset(ptrBuffer, 0, SIZE);
    }

    return 0;
}
</code></pre>

<p>You can read file name as parameter.</p>
",2
18985820,18985488,0,"<p>Even if <code>ptr</code> is a string, you need to use <code>printf(""%s"", ptr);</code>, not <code>printf(ptr);</code></p>

<p>However, after you call</p>

<pre><code>read(fd, ptr, SIZE)
</code></pre>

<p><code>ptr</code> is rarely a string (strings need to be null-terminated). You need to use a loop and choose the format you need. For example:</p>

<pre><code>for (int i = 0; i &lt; n; i++)
    printf(""%02X "", *ptr);
</code></pre>
",0
18986208,18985488,1,"<p>The data read into <code>ptr</code> may contain <code>\0</code> bytes, format specifiers and is not necessarily <code>\0</code> terminated.  All good reasons not to use <code>printf(ptr)</code>.  Instead:</p>

<pre><code>// char n;
ssize_t n;
while((n = read(fd, ptr, SIZE)) &gt; 0) { 
  ssize_t i;
  for (i = 0; i &lt; n; i++) {
    printf("" %02hhX"", ptr[i]);
    // On older compilers use --&gt; printf("" %02X"", (unsigned) ptr[i]);
  }
}
</code></pre>
",0
19501095,19494517,1,"<p>Read the file in character by character, and keep track of the current character and the previous. character. When the previous character is <code>/</code> and the current one is <code>*</code> stop copying the previous character to output, and don't start until the characters are <code>*</code> and <code>/</code>.</p>

<p>Or use a regular expression. There are probably C libraries for that, although <code>sed</code> will probably do it with a minimum of effort.</p>
",0
20183805,20183783,1,"<p>In your strlenx function, you are never incrementing your pointer <code>s</code>. Your for loop should be:</p>

<pre><code>for(n =0; *s != '\0'; s++)
    n++;
</code></pre>
",0
19968301,19968087,0,"<p>You use the wrong variable in the <code>k</code> loop:</p>

<pre><code>  for(k=i+1; i &lt; r; i++)
</code></pre>

<p>You should be comparing and incrementing <code>k</code>, not <code>i</code>.</p>

<p>The code could be a little tidier, too:</p>

<pre><code>for( j = 0; j &lt; c; j++ )
{
    fail = 0;
    for( i = 0; i &lt; r &amp;&amp; !fail; i++ )
    {
        for( k = i+1; k &lt; r; k++ )
        {
           if( array[i][j] == array[k][j] )
           {
              fail=1;
              break;
           }
        }
    }

    if( !fail ) column++;
}
</code></pre>
",5
19968710,19968087,0,"<p>you said that the program is running correctly but the result is wrong. I think the fault is in this row:
    for (i=0;i i &lt; r; i++)
it must be like this:
    for (i=0;i i &lt; r-1; i++)
to avoid comparing the column with itself in the last iteration.</p>
",0
19970735,19969975,1,"<p>I'm not sure if I'm understanding your question, but I have an idea that can help you to identify repeated symbols.</p>

<p>using a ""map"" can solve this problem, for example: let's suppose that we are working with uppercase characters only, so we can use an integer array to simulate the mapping, if an element in your map is bigger than one, then that element is repeated in your string.</p>

<p>here is my code in C++ that obtain that map:</p>

<pre><code>string str;
int myMap[26]; //an element for each uppercase character
memset(myMap, 0, sizeof myMap); // initialize each element to zero
cin&gt;&gt;str;
for(int i=0; i&lt;str.length(); i++)
{
    //(str[i]-'A') will map each character to an integer
    // A -&gt; 0, B -&gt; 1, C -&gt; 2, etc.
    myMap[(int)(str[i]-'A')]++;
}
//print solution:
for(int i=0; i&lt;26; i++)
{
    if(myMap[i] &gt; 1)
    {
        cout&lt;&lt;(char)(i+'A')&lt;&lt;"" is repeated!""&lt;&lt;endl;
    }
}
</code></pre>

<p>for your example, the output will be:</p>

<pre><code>A is repeated!
C is repeated!
F is repeated!
</code></pre>
",0
20654279,20653718,1,"<p>because the offset of the file stream always be 0, so you read</p>
",0
20654030,20653718,1,"<p>try this</p>

<pre><code>while(fscanf(fp, "" %512[^\n]"", szLine)==1)
{
   puts(szLine);
   getchar();
}
</code></pre>
",1
20655097,20653718,1,"<p>you can change your program like this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main()
{
   char szLine[512+1]={0};
   FILE *fp=fopen(""log.txt"", ""r"");
   while(!feof(fp))
   {
      fgets(szLine,512,fp);
      puts(szLine);
      getchar();
   }
   return 0;
}
</code></pre>
",0
20655206,20653718,1,"<p>""%512[^\n]"" does not read the endline character. The remaining part of the file starts with \n and fscanf fails to read the line(it return 0 instead of 1). You need to read the endline character !</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main()
{
    int bla;
    char szLine[512+1]={0};
    FILE *fp=fopen(""log.txt"", ""r"");
    while(!feof(fp))
    {
        bla= fscanf(fp, ""%512[^\n]"", szLine);
        if(bla==1){
            printf(""%d\n"",bla);
            puts(szLine);
            getchar();
            fgetc(fp);
        }
    }
    return 0;
}
</code></pre>

<p>Using getline() may be a more reliable solution.</p>

<pre><code> getline(&amp;szLine,&amp;size,fp);
</code></pre>

<p>Bye,</p>

<p>Francis</p>
",0
17816233,17816205,1,"<p>The <code>printf()</code> function returns the number of characters that it prints on console. </p>

<p>For example after the following printf call, <code>num_chars</code> will have the value <code>10</code> as string <code>""Hi haccks\n""</code>   consistes of 10 non-nul characters that will be print on screen.</p>

<pre><code>num_chars = printf(""Hi haccks\n"");
//                  ^^^^^^^^^ ^ 
//                  12345678910    
</code></pre>

<p><strong>Note</strong>: <code>\n</code> is single 10<sup>th</sup> char. So in above code returned value from printf assigned to <code>num_chars</code> variable.</p>

<p>In your code, in the given statement, inner <code>printf()</code> prints the values and then return number of chars that value printed by outer printf  as shown below:  </p>

<pre><code>// 1              2            3
printf(""%d\n"", printf(""%d"", printf(""%d"",i))); // Here i = 56
         ^              ^            ^    
   print: 1       print: 2         print: 56 
   returns: 1     returns: 1       returns: 2
//    3             2               1        &lt;--Order of printf called 
</code></pre>

<p>So it outputs 5621</p>
",0
17816240,17816205,9,"<p>From the <code>printf</code> <a href=""http://linux.die.net/man/3/printf"">man page</a></p>

<blockquote>
  <p>Return value</p>
  
  <p>Upon successful return, these functions return the number of
  characters printed (excluding the null byte used to end output to
  strings).</p>
</blockquote>

<p><code>56</code> is printed for the inner <code>printf</code>
<br>2 characters were printed so the argument to the next <code>%d</code> format specifier is <code>2</code>
<br>1 character was printed by the middle <code>printf</code> so the argument to the outer <code>%d</code> format specifier is <code>1</code>
<br>Only the outer <code>printf</code> includes a newline so the preceding calls output one after another on the same line, giving <code>5621\n</code>.</p>
",0
17816242,17816205,22,"<p><code>printf</code> returns the amount of characters it has printed.</p>

<p>So first the most inner <code>printf</code> gets called with 56, printing <code>56</code>. Then it returns the amount of characters it has printed (2) to the middle <code>printf</code>, printing <code>2</code>. Then finally the amount of characters printed (1) gets passed into the outer <code>printf</code>, which then gets printed to procude <code>5621</code>.</p>
",0
17816273,17816205,6,"<p><code>printf()</code> returns the number of characters printed:</p>

<p><code>printf(""%d"",i)</code> outputs the value <code>56</code>.<br>
<code>printf(""%d"",printf(""%d"",i))</code> outputs <code>56</code> and then <code>2</code>, the number of characters in <code>56</code>.<br>
<code>printf(""%d\n"",printf(""%d"",printf(""%d"",i)))</code> outputs <code>56</code>, then <code>2</code>, then the number of characters in <code>2</code>, which is <code>1</code>.</p>
",0
17816337,17816205,6,"<p>It's equivalent to</p>

<pre><code>#include &lt;stdio.h&gt;

main()
{
    int n, i = 56;
    n = printf(""%d"",i);
    n = printf(""%d"", n);
    n = printf(""%d\n"", n);
}
</code></pre>

<p>printf returns the number of characters written.</p>
",0
18629274,18629043,2,"<p>If you have a C program running in an untrusted environment then there is no way to be sure someone is not providing a fraudulent clock.  To ensure the clock is ""reasonable"" you would have to contact an external source which you are capable of authenticating (e.g., via SSL/TLS) and read the time from there and see if it differs greatly from what is reported by system calls.  And as @caf noted, even that provides zero guarantees.</p>
",1
18629222,18629043,2,"<p>getting THE exact timestamp is a science in itself. You can get the exact timestamp of your computer, or you can call a webservice, that sends you the timestamp of the atomic clock (to which you have to compute and adjust the running times of the IP-packets), or you can do a hardware-solution an attach a GPS-Module, which is fairliy accurate.</p>
",0
18900854,18900815,4,"<p>Looks like you want this value:</p>

<pre><code>part5 + (part4 &lt;&lt; 12) + (part3 &lt;&lt; 14) + (part2 &lt;&lt; 26) + (part1 &lt;&lt; 28)
</code></pre>

<p>(Make sure all five variables are of type <code>uint32_t</code> or some such.)</p>
",0
18900859,18900815,5,"<p>You just use shifting, as you suggested:</p>

<pre><code>uint32_t x = (part1 &lt;&lt; 28)
           | (part2 &lt;&lt; 26)
           | (part3 &lt;&lt; 14)
           | (part4 &lt;&lt; 12)
           | (part5);
</code></pre>
",0
18905560,18900815,5,"<p>This is typical bit-shifting/bit-masking stuff.  Here's how you set the initial value:</p>

<pre><code>uint32_t value = ((part1 &amp; 0xF) &lt;&lt; 28)
                 | ((part2 &amp; 0x3) &lt;&lt; 26)
                 | ((part3 &amp; 0xFFF) &lt;&lt; 14)
                 | ((part4 &amp; 0x3) &lt;&lt; 12)
                 | (part5 &amp; 0xFFF);
</code></pre>

<p>Each line uses a bitwise-AND <code>(&amp;)</code> to clear the upper bits of each part so it doesn't overflow its allocated bit-width within the final value.  For example, if part4 was 0xFF and you forgot the <code>&amp; 0x3</code> then the upper 6 bits of part4 (0xFC) would spill into the region for part3.  Then the part is shifted <code>(&lt;&lt;)</code> to its final location and bitwise-OR'd <code>(|)</code> with the rest of the parts.</p>

<p>Some developers accomplish the same thing via bitfields but I don't recommend that approach due to potential portability issues.</p>

<p>Most (all?) of the other answers here so far have forgotten the bitwise-AND portion of the solution.  Their answers will result in bugs if the part values ever exceed the specified bit width.</p>

<p>If you want to update a particular portion of the value, you'll need some more bit-masking via bitwise-AND and bitwise-OR.  For example, to update part4 you'd do this:</p>

<pre><code>value &amp;= ~(0x3 &lt;&lt; 12);  /* Clear the part4 region */
value |= (part4 &amp; 0x3) &lt;&lt; 12;    /* Set the part4 region to the new value */
</code></pre>

<p>That first line is a little tricky if you're new to bitwork in C.  It says take 0x3 and shift it by 12 (result = 0x00003000), perform a bitwise-complement (result = 0xFFFFCFFF), and set value equal to itself bitwise-AND'd with that result.  That's how you clear the part4 region of the value... because you're bitwise-AND'ing that region with zero the result is that region is now zero.</p>

<p>The second line sets the zeroed part4 region to the new value, just like we did above when setting the initial value.</p>
",0
17838530,17838460,5,"<p>If the macros are left as invalid function-like macros, they are not getting expanded at all because you did not call it with parentheses. So X is never replaced with anything by the pre-processor, and is the reason for the <code>Undefined symbol 'X'</code> in your sample code.</p>

<p>If you wanted this to be expanded you would have to call it with parentheses like this:</p>

<pre><code>printf(""%d"",4*X()+2);
</code></pre>

<p>This though would just error out when pre-processed as <code>4+Y</code> and <code>X+3</code> are not valid macro parameter names.</p>

<p>If your answer is corrected somewhat so that those defines are proper defines, and not function-like macros, ie:</p>

<pre><code>#define X (4+Y)
#define Y (X+3)
</code></pre>

<p>You have a circular reference between the defines...</p>

<p>X -> Y -> X... etc.</p>

<p>Since it will only expand the macro once, it is getting expanded to</p>

<pre><code>printf(""%d"",4*(4+(X+3))+2);
</code></pre>

<p>This explains why X is the undefined symbol in this use case.</p>
",5
17838531,17838460,1,"<p>You miss spaces</p>

<pre><code>#define X (4+Y)
#define Y (X+3)
</code></pre>
",4
17838561,17838460,6,"<p>It is because the macro expects and argument since its defined with parentheses.
You would need to define it as</p>

<p><code>#define X 4+Y</code> and <code>#define Y X+3</code>. Then you would run into another trouble because of cyclic definition in macros.</p>

<p>To be even more correct, as Drew suggested; when the example would be compilable when defining macros one usually puts the parentheses around expression to ensure expected operator precedence.</p>

<p>So your best shot would be:</p>

<pre><code>#define X (4+Y)
#define Y (X+3)
</code></pre>

<p>Very close to your initial example, just a space character between name of a macro and its definition. <strong>However, it is still impossible to properly expand the macro due to the cyclic reference.</strong></p>

<p><strong>How to check what happened:</strong></p>

<p>You can use <code>gcc -E</code>, which outputs a pre-processed file. It generates lots of output so  I used <code>tail</code>. I also used <code>2&gt;err</code> to redirect error stream to a file, so the output is clear.</p>

<pre><code>luk32:~/projects/tests$ gcc -E ./cyclic_macro_with_no_spaces.c 2&gt; err | tail -n 6

int main()
{
  printf(""%d"",4*X+2);
  return 0;
}


luk32:~/projects/tests$ gcc -E ./cyclic_macro.c 2&gt; err | tail -n 6

int main()
{
  printf(""%d"",4*(4+(X+3))+2);
  return 0;
}
</code></pre>

<p>In 1st example the <code>X</code> did not expand at all. While in the latter both macros got expanded, although only one. Giving the same output that Geoffrey presented in his answer.</p>

<p>Whether no space is a typo or not there is an <code>undefined symbol 'X'</code>. For different reason that are possible to trace by analyzing <code>err</code> files.</p>
",2
18862125,18862105,3,"<p>It's been a while, but that ""for"" statement needs to be wrapped in a function, doesn't it?  Don't think you can do procedural statements at the file block level.</p>
",0
18862154,18862105,11,"<p>The code needs to be inside a function.  If this code is the only code in the program, the function is called ""main"".  In its (almost) simplest form:</p>

<pre><code>int main() {
    ... your code
}
</code></pre>
",5
19882358,19882322,1,"<p>You forgot about the parens. This:</p>

<pre><code>else
    printf(""%*s- %s\n"", level*2, """", entry-&gt;d_name);
    fprintf(log,""%*s- %s\n"", level*2, """", entry-&gt;d_name);
</code></pre>

<p>should be</p>

<pre><code>else {
    printf(""%*s- %s\n"", level*2, """", entry-&gt;d_name);
    fprintf(log,""%*s- %s\n"", level*2, """", entry-&gt;d_name);
}
</code></pre>

<p>Also, don't open and close the file every time you see a file. Open it once for writing (<code>""w""</code>)and pass it to the function. Don't open the file for appending in the function, take the <code>fopen</code> out of the function.</p>
",7
19797685,19797599,2,"<p>This line almost certainly does not do what you intend.</p>

<pre><code>in[s1+1]='\0';
</code></pre>

<p>This will insert the string termination character <code>\0</code> at position <code>s1+1</code>, but because you have <code>s1++</code> in your loop, by the time this line is reached <code>s1</code> is already at the end of the string. Try replacing it with</p>

<pre><code>in[s1] = '\0';
</code></pre>

<p>The <code>out</code> variable has the same problem, you just can't see it in the output because by sheer luck the extra character it's outputting is a space.</p>

<p>There is always danger in duplicating code. I would strongly recommend writing a separate <code>strip_spaces</code> routine and calling it twice rather than writing the same code twice.</p>

<pre><code>#include &lt;stdio.h&gt;

void strip_spaces(char *str) {
  int ii = 0, jj = 0;
  while (str[ii]) {
    str[jj] = str[ii];
    if (str[ii++] != ' ')
      ++jj;
  }
  str[jj] = 0;
}

int check_anagrams(char *in,char *out) {
  strip_spaces(in);
  printf(""After cutting s1: %s\n"",in);
  strip_spaces(out);
  printf(""After cutting s2: %s\n"",out);
}

int main()
{
  char in[100]=""I like rambo"";
  char out[100]=""rambo like I"";
  int ans;
  ans = check_anagrams(in,out);
}
</code></pre>
",3
18676278,18676263,4,"<pre><code>if(x = 1)
</code></pre>

<p><code>=</code> is assignment. You need <code>==</code> operator instead. You are doing correct in other <code>if</code> conditions though.</p>

<p>Also, the logic of calculating prime numbers is inefficient. You can break the loop once the count is greater than 2.</p>

<pre><code>if (b % x == 0)
{
    count = count + 1;
    if (count &gt; 2)
    {
       // This ensures you are returning correct value later.
       break;
    }
}
</code></pre>

<p>Have a look at this algorithm: <a href=""http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes"" rel=""nofollow"">Sieve of Eratosthenes</a></p>
",0
18676324,18676263,0,"<p>This answer is correct.</p>

<p>For removing such kind of mistakes use it like</p>

<pre><code>if(1=x)
</code></pre>

<p>using this approach you can avoid such behavior.</p>

<p>Here I am just approaching to avoid typo mistakes.</p>
",3
19217711,19217679,0,"<p>its working well .....</p>

<p>Set after each <code>case:</code>  <code>countNumber=0;</code></p>

<p>or try</p>

<pre><code>if(dotNumber &gt; 0)
            {
countNumber=0;
/*REST */
}
</code></pre>

<p><strong>otherwise   case 1:  case 2: will not work if i try 2 times after giving  dotNumber  a higher value at first and lower at last</strong></p>

<p><strong>EDIT:</strong>
The C library function void isdigit(int c) checks if the passed character is a decimal digit character.</p>

<pre><code> if( isdigit(variableHere) )
   {
      //is a digit
   }
</code></pre>

<p><strong>Sample  o/p</strong></p>

<pre><code>please make a number selection
Please select a choice:
[1] While loop...
[2] Do-While loop...
[3] For loop...
[4] Exit program...

1

Please input a number for the amount of dots you wish to see 4
....
Press any key to continue . . .
</code></pre>
",4
18799219,18784086,0,"<pre><code>here is a modified program, any feedback??

#include &lt;time.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;

typedef struct mystruct{
char name[30];
char designation[20];
char empid[8];
float basic;
float days_absent;
float days_present;
float gross_salary;
float pf;
float allowance;
float net;
int counter;
int clerk_counter;
int operator_counter;
int salesman_counter;
int helper_counter;
char *next;
}mystruct;

char *p;


void enter_details_of_employee();
void display();
void get_time();

void main()
{
do
{
int k, choice;
printf(""Enter 1 to enter employee details and 2 to display salary\n"");
scanf(""%d"", &amp;k);

if(k == 1)
{
p = (mystruct*)malloc(sizeOf(mystruct));
enter_details_of_employee();
}
else if(k == 2)
{
display();
get_time();
}
else
{
choice = 0;
printf(""invalid choice, press 1 to continue\n"");
}
}
while choice == 1;
}

void enter_details_of_employee ()
{
if(p-&gt;mystruct.counter!=12)
{
int proceed = 1;

do
{
printf(""\n enter details of employees\n"");

printf(""enter employee name\n"");
scanf(""%u"", &amp;p-&gt;mystruct.name);

printf(""enter employee id\n"");
scanf(""%u"", &amp;p.empid);

printf(""enter your choice for employee designation\n 1.clerk \n 2.computer operator\n 3. salesman\n 4.helper\n"");
scanf(""%d"", &amp;choice);

if (choice == 1)
{
if(p-&gt;mystruct.clerk_counter == 2)
        {
            printf(""sorry, you have already entered the details of all clerks\n"");
        }

            else

        {
            p-&gt;mystruct.designation = ""clerk"";
            p-&gt;mystruct.basic = 8000.00;
            printf(""enter no of days absent\n"");
            scanf(""%u"", &amp;p-&gt;mystruct.days_absent);
            p-&gt;mystruct.days_present = p-&gt;mystruct.working_days - p-&gt;mystruct.days_absent;
            p-&gt;mystruct.gross_salary = p-&gt;mystruct.basic - ((p-&gt;mystruct.days_absent / p-&gt;mystruct.working_days) * p-&gt;mystruct.basic);
            p-&gt;mystruct.pf = p-&gt;mystruct.gross_salary*0.1;
            p-&gt;mystruct.allowance = p-&gt;mystruct.gross_salary*0.55;
            p-&gt;mystruct.net = (p-&gt;mystruct.gross - p-&gt;mystruct.pf) + p-&gt;mystruct.allowance;
            p-&gt;mystruct.clerk_counter++;
            p-&gt;mystruct.counter++;
        }



    }
    else if (choice == 2)
    {
            if(p-&gt;mystruct.operator_counter == 1)
        {
            printf(""sorry, you have already entered the details of all computer operators\n"");
        }

            else

        {
            p-&gt;mystruct.designation = ""computer operator"";
            p-&gt;mystruct.basic = 9000;
            printf(""enter no of days absent\n);
            scanf(""%u"", &amp;p-&gt;mystruct.days_absent);
            p-&gt;mystruct.days_present = p-&gt;mystruct.working_days - p-&gt;mystruct.days_absent;
            p-&gt;mystruct.gross_salary = p-&gt;mystruct.basic - ((p-&gt;mystruct.days_absent / p-&gt;mystruct.working_days) * p-&gt;mystruct.basic);
            p-&gt;mystruct.pf = p-&gt;mystruct.gross_salary*0.12;
            p-&gt;mystruct.allowance = p-&gt;mystruct.gross_salary*0.75;
            p-&gt;mystruct.net = (p-&gt;mystruct.gross - p-&gt;mystruct.pf) + p-&gt;mystruct.allowance;
            p-&gt;mystruct.operator_counter++;
            p-&gt;mystruct.counter++;      
        }


    }

    else if (choice == 3)
    {
            if(p-&gt;mystruct.salesman_counter == 6)
        {
            printf(""sorry, you have already entered the details of all salesman\n"");
        }

            else

        {
            p-&gt;mystruct.designation = ""salesman"";
            p-&gt;mystruct.basic = 10000;
            printf(""enter no of days absent\n"");
            scanf(""%u"", &amp;p-&gt;mystruct.days_absent);
            p-&gt;mystruct.days_present = p-&gt;mystruct.working_days - p-&gt;mystruct.days_absent;
            p-&gt;mystruct.gross_salary = p-&gt;mystruct.basic - ((p-&gt;mystruct.days_absent / p-&gt;mystruct.working_days) * p-&gt;mystruct.basic);
            p-&gt;mystruct.pf = p-&gt;mystruct.gross_salary*0.15;
            p-&gt;mystruct.allowance = p-&gt;mystruct.gross_salary*0.95;
            p-&gt;mystruct.net = (p-&gt;mystruct.gross - p-&gt;mystruct.pf) + p-&gt;mystruct.allowance;
            p-&gt;mystruct.salesman_counter++;
            p-&gt;mystruct.oounter++;      
        }


    }

else if (choice == 4)
    {
            if(p.-&gt;mystruct.salesman_counter == 3)
        {
            printf(""sorry, you have already entered the details of all helpers\n"");
        }

            else

        {
            p-&gt;mystruct.designation = ""helper"";
            p-&gt;mystruct.basic = 6500;
            printf(""enter no of days absent\n);
            scanf(""%u"", &amp;p-&gt;mystruct.days_absent);
            p-&gt;mystruct.days_present = p-&gt;mystruct.working_days - p-&gt;mystruct.days_absent;
            p-&gt;mystruct.gross_salary = p-&gt;mystruct.basic - ((p-&gt;mystruct.days_absent / p-&gt;mystruct.working_days) * p-&gt;mystruct.basic);
            p-&gt;mystruct.pf = p-&gt;mystruct.gross_salary*0.08;
            p-&gt;mystruct.allowance = p-&gt;mystruct.gross_salary*0.45;
            p-&gt;mystruct.net = (p-&gt;mystruct.gross - p-&gt;mystruct.pf) + p-&gt;mystruct.allowance;
            p-&gt;mystruct.helper_counter++;
            p-&gt;mystruct.counter++;      
        }


}

else
    {
printf(""invalid choice, press 1 to continue\n"");
scanf(""%d"", &amp;proceed);
    }
        while (proceed);
    }
    }
    else 
    {
    printf(""data entry complete"");
    }
    }


}
void get_time()
{
time_t t = time(NULL);
struct tm tm = *localtime(&amp;t);

printf(""now: %d-%d-%d %d:%d:%d\n"", tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);
}

void display()
{
printf(""SALARY SLIP OF EMPLOYEES "";
printf(""---------------------------------------------------------------------------------------------------"");
printf(""empid\t name\t days_absent\t days_present\t gross_salary\t   PF\t allowance\t net"");
printf(""---------------------------------------------------------------------------------------------------"");
while(p.next!=NULL);
{
print(p.mystruct);
}
}
</code></pre>
",0
19798676,19798622,0,"<p>The file opening can fail and yet you do a jpeg_stdio_dest call</p>

<p>bracket problem?</p>

<pre><code>if ((outfile = fopen(filename, ""wb+"")) == NULL) {
    fprintf(stderr, ""can't open %s\n"", filename);
    exit(1);
}
else
{
    printf(""File successfully opened\n"");
    jpeg_stdio_dest(&amp;cinfo, outfile);
}
</code></pre>
",4
17806997,17806949,0,"<p>it's called Database. you can save all your records into a file(any kind you want) and you need to read that file when application start and build your data set.</p>

<p>for example:</p>

<p>if you have a record for each account containing <code>name</code>, <code>id</code>, <code>balance</code>, then you can save before closing to a normal .txt, say ""C:\tmp\DB.txt"" file all the records as ,,* string for each record.</p>

<p>upon entering the application you'll check if a file ""C:\tmp\DB.txt"" exist and if so read it and build the data accordingly.</p>

<p>back to your question. it is possible to just minimize the program when pressing the close button in winforms for windows and in other ways for other languages. It might be possible to do it in c, though i doubt it. anyway it makes no sense, because the user can still kill the process despite your efforts and thus make it not worthwhile to do it</p>
",3
17809396,17806949,1,"<p>If you only want <strong>to minimize the console window</strong> you have to:</p>

<ol>
<li><code>#include &lt;Windows.h&gt;</code></li>
<li><p>Use the block below:</p>

<pre><code>/* the following code minimizes the console window */
{
    char szTitle[256];    
    HWND hConsole = NULL;    

    memset(szTitle, 0, sizeof(szTitle));

    /* get the console window's title */
    GetConsoleTitle((LPWSTR)szTitle, 256);

    /* get the HWND windows handle of the console window by looking up for 
       windows with szTitle as title*/
    hConsole = FindWindow(NULL, (LPWSTR)szTitle );

    /* ""show"" it as minimzed */
    ShowWindow(hConsole, SW_MINIMIZE);
}
</code></pre></li>
</ol>

<p>Hope it helps!</p>
",0
19876567,19876095,2,"<p>strtod is for converting string(char array) to double. If the input is not a valid or if the input is valid ZERO or if the input is white spaces then the function returns ZERO.  </p>
",2
19876629,19876095,0,"<p>You have everything you need in the man:</p>
<blockquote>
<p><strong>NAME</strong></p>
<pre><code>   strtod, strtof, strtold - convert ASCII string to floating-point
   number
</code></pre>
<p><strong>SYNOPSIS</strong></p>
<pre><code>   #include &lt;stdlib.h&gt;

   double strtod(const char *nptr, char **endptr);
</code></pre>
<p><strong>DESCRIPTION</strong></p>
<pre><code>  The strtod(), strtof(), and strtold() functions convert the ini©\
  tial portion of the string pointed to by nptr to double, float,
  and long double representation, respectively.
</code></pre>
<p><strong>RETURN VALUE</strong></p>
<pre><code>   These functions return the converted value, if any.

   If endptr is not NULL, a pointer to the character after the last
   character used in the conversion is stored in the location ref©\
   erenced by endptr.

   If no conversion is performed, zero is returned and the value of
   nptr is stored in the location referenced by endptr.
</code></pre>
</blockquote>
<p>I found this last sentence particularly interesting.</p>
",0
19876671,19876095,3,"<p><code>strtod()</code> has a second argument that is a pointer to a char pointer. If it isn't <code>NULL</code> it will write to that pointer the address in the string where it stopped converting because the rest is not a valid floating point number representation.</p>

<p>If the whole string converted correctly then obviously that pointer will point to the end of the string. The conversion should look like this, with out of range check thrown in for good measure:</p>

<pre><code>char *endptr;
double result;

errno = 0;
result = strtod(string, &amp;endptr);
if (errno == ERANGE) {
    /* value out of range */
}
if (*endptr != 0) {
    /* incomplete conversion */
}
</code></pre>
",0
19877407,19876095,0,"<p>This may be obvious, but you're not checking <code>argc</code> to ensure that you have a parameter to parse. You should be doing something like this:</p>

<pre><code>int main (int argc, char* argv[]) {
    if (argc &lt; 2) {
        exit(EX_USAGE);
    }
    double arg1 = strtod(argv[1], NULL);
    if (arg1==0 &amp;&amp; strcmp(argv[1], ""0"")!=0) {
        exit(EX_USAGE);
    }
    /* some code */
}
</code></pre>
",0
18826683,18825812,0,"<p>You may want to know about memory layout of C executable for gcc. I think this will help a bit. <a href=""http://www.geeksforgeeks.org/memory-layout-of-c-program/"" rel=""nofollow"">Memory layout in C</a></p>
",1
18826749,18825812,0,"<p>These are all purely implementation details; there's no guarantee that you even <em>have</em> a data segment, nor is there a guarantee that all function parameters are passed via the stack (they may be passed via registers).</p>

<p>This is determined by the processor architecture (x86, SPARC, MIPS, PA-RISC, Power) and to some extent by the operating system, so you would want to start with developer's guides for the architecture you're interested in, such as <a href=""http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html"" rel=""nofollow"">Intel</a>.</p>
",0
18826858,18825812,0,"<p>Compiler documentation. Also a good breakdown on how everything works behind the curtain is any book on x86 Assembly. Some compilers allow inline assembly in their C code, so you can try to rewrite some C code in assembly to see if you can match what the compiler is doing. It should provide you with working knowledge of the stack, alignments etc.</p>
",0
20091414,20091356,0,"<p>You probably have to read the value as a string, and then use e.g. <a href=""http://en.cppreference.com/w/c/string/byte/strtol"" rel=""nofollow""><code>strtol</code></a> to convert it to an integer with error checking.</p>

<p>Can be done like this:</p>

<pre><code>char str[64];

scanf(""%63s"", str);

char *endptr;
int value = (int) strtol(str, &amp;endptr, 10);

if (endptr == str)
    printf(""Not a valid integer\n"");
else if (*endptr != '\0')
    printf(""Valid number, but followed by non-numeric data\n"");
else
    printf(""A valid number: %d\n"", value);
</code></pre>

<p>Your case with <code>453F</code> as input would cause the second string to be printed in the above code.</p>
",0
20091462,20091356,0,"<p>Well, that's how <code>scanf</code> works - it will match what it can and it will leave that <code>F</code> in the input buffer.</p>

<p>Other way would be to read string value (using <code>%s</code> format specifier) which will accept all characters, and then you can use <code>strtof</code> (you can find many examples how to use it) to convert it to the float with error checking.</p>
",0
20091497,20091356,0,"<p>You can read as a string and check (char by char) the ascii value to be in the right range (48-57).</p>
",0
19258816,19258622,0,"<p>As we recommended in your <a href=""https://stackoverflow.com/questions/19244314/adding-a-history-feature-to-my-simple-shell/19244444#19244444"">previous post</a>:</p>

<blockquote>
  <p>How about a <code>linked list</code> where you additionally store the length, first
  and last item of the list? The items being the commands from your
  inputBuffer.</p>
</blockquote>
",2
19207676,19207458,5,"<p>You cannot assign arrays in C. You have two options to achieve the effect you want: Either use the <code>memcpy()</code> function (it's in the standard library, just <code>#include &lt;string.h&gt;</code>), or code the copy yourself:</p>

<pre><code>for(long i = sizeof(tmp)/sizeof(tmp[0]); i--; ) tmp[i] = text[i];
</code></pre>

<p>Note that I calculated the amount of data to copy instead of just hardcoding 256, in order to prevent future bugs when you want to change the size of the involved arrays. Generally speaking, fixed limits should be avoided at nearly all costs.</p>

<p>Edit: For a third way to copy an array see Aarons comment.</p>

<hr>

<p>Background information:</p>

<p>You might wonder at the text of your error message, that it reports a type mismatch where you tried to assign two variables of the same type. The reason is that array identifiers decay to a pointer to the first element of the array in almost all contexts. This is why, the right side of your assignment decayed to a <code>char*</code> while the left side remained of type <code>char[256]</code>.</p>
",2
19207637,19207458,1,"<p>This Line</p>

<pre><code> tmp=text; is wrong.   
</code></pre>

<p>You are trying to change the base address of an array(tmp) which is a constant pointer.It means base address of an array can't be changed.That is why it is throwing this error.
And the warning are there because you are trying to assign a string in a character place.
This line</p>

<pre><code>   iarray[num] = ""0""; 
</code></pre>

<p>""0"" is a string.Try to make it '0'.Now it is a character.Hence there will be 
no warning.</p>

<pre><code>    iarray[0] = """"; //Same reason
</code></pre>
",0
19208011,19207458,1,"<p><code>char switch_middle(char iarray[256]) {</code></p>

<p>should be</p>

<p><code>char * switch_middle(char iarray[256]) {</code></p>

<p>and you should return the array at the end:</p>

<pre><code>char * switch_middle(char iarray[256]) {
    int num=((2^a_index-1)-1)/2+1; // Nummer der Zahlen pro ebene |-1|/2|+1 -&gt; Index des mittleren Buchstaben
    if(num&gt;=0) {
        iarray[num]='0';
    } else {
        iarray[0]='\0';
    }
    return iarray;
}
</code></pre>

<p>=====</p>

<p>On a side note, C arrays have some strange features.  For example, they are ignored in the parameter list of a function.  <code>char * switch_middle(char iarray[256]) {</code> is fully equivalent to <code>char * switch_middle(char * iarray) {</code>, and the latter is more readable.</p>

<p>This is weird, see example <a href=""http://ideone.com/O041vs"" rel=""nofollow"">here on ideone</a>.</p>

<p>In fact, the number inside the brackets is ignored entirely - you can change it from 256 to any other number and the program will not change behaviour!  This rule applies only to the parameters to functions.   In local variables, the number does mean something.</p>

<p>This means that you can't really pass an array to a function directly like that.  Yes, the outside function can send an array, but the receiving function won't see it as an array.  Frankly, I think this is a bad design in C.  I believe that compilers should give a warning if <code>[]</code> appears in parameter lists like this.</p>
",0
19208222,19208181,4,"<p>Since your cache is a 2D array, it's <code>int**</code>. To set it in a function, pass <code>int***</code>, not <code>int**</code>. Otherwise, changes to <code>cache</code> made inside <code>initCache</code> have no effect on the value of <code>c</code> from <code>main()</code>.</p>

<pre><code>void initCache(int ***cache, int s, int E) {
    int i, j;
    /* allocate memory to cache */
    *cache = (int **)malloc(s * sizeof(int *)); //set 
    for (i = 0; i &lt; s; i++) {
        (*cache)[i] = (int *)malloc(E * sizeof(int)); //int
        for(j = 0; j &lt; E; j++){
            (*cache)[i][j]  = i + j;   
            printf(""%d\n"", (*cache)[i][j]);
        }
    }
}
</code></pre>

<p>Now you can call it like this:</p>

<pre><code>initCache (&amp;c, 2, 2);
</code></pre>
",0
19208240,19208181,3,"<p>You changed a local variable, which won't effect the local variable <code>c</code> in main.</p>

<p>If you want to allocate in the function, why pass a variable? Return it from the function.</p>

<pre><code>int **c = initCache(2, 2);
</code></pre>
",0
19208243,19208181,1,"<p>You could use a <code>return</code>, or else a <code>***</code> as suggested by others.  I'll describe the <code>return</code> method here.</p>

<p><code>initCache</code> is creating and initializing a suitable array, but it is not returning it.  <code>cache</code> is a local variable pointing to the data.  There are two ways to make this information available to the calling function.  Either <code>return</code> it, or pass in an <code>int***</code> and use that to record the pointer value.</p>

<p>I suggest this:</p>

<pre><code>int** initCache(int **cache, int s, int E){
   ....
   return cache;
}


main()
{
   int **c;
   c = initCache (2, 2);
   printf(""%d\n"", c[1][1]);   &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; here
}
</code></pre>

<p>====</p>

<p>Finally, it's very important to get in the habit of checking for errors.  For example, <code>malloc</code> will return <code>NULL</code> if it has run out of memory.  Also, you might accidentally as for a negative amount of memory (if <code>s</code> is negative).  Therefore I would do:</p>

<pre><code>cache = (int **)malloc(s * sizeof(int *));
assert(cache);
</code></pre>

<p>This will end the program if the malloc fails, and tell you what line has failed.  Some people (including me!) would disapprove slightly of using <code>assert</code> like this.  But we'd all agree it's better than having no error checking whatsoever!</p>

<p>You might need to <code>#include &lt;assert.h&gt;</code> to make this work.</p>
",0
20104591,20104347,1,"<p>There is still lots of room for improvement with this, but this answer is specifically for minimizing code repetition.</p>

<p>With that said, you could use arrays:</p>

<pre><code>/*P1 process variables*/
static int c[3];
static int targetc[3];
static int cf[3];
static void (*ctrigger[3])(void);

p1startingfunction()
{
    int a, i;
    for (i = 0; i &lt; 3; i++) {
        if (cf[i] == 1) {
            c[i]++;
            if (c[i] == targetc[i]) {

                /* counter reached do something */
                ctrigger[i]();                    
            }
        }
    } 
}
</code></pre>

<p>Or you could use a struct that looks something like:</p>

<pre><code>struct counter {
    int c;
    int target;
    int f;
    void (*trigger)(void);
};
</code></pre>

<p>And then create an array of structs.</p>

<pre><code>struct counter counters[3];
</code></pre>
",0
19867788,19867628,0,"<p>I'm not sure I understand your question, but do you simply want a function to initialize your structure from a bunch of arguments and to call calculate_XX automatically? If so, take a look at this:</p>

<pre><code>typedef struct stats stats;

stats *your_function(int your_arguments) {

    stats *mystruct = malloc(sizeof(stats));
    if(!mystruct)
        // Initialisation failed, do something.

    mystruct-&gt;whatever_field = your_arguments;
    // ...
    mystruct-&gt;BA = calculate_BA(arguments_for_this);
    // ...
    return mystruct;
}
</code></pre>
",4
19868067,19867628,0,"<p>This is not intended to be a complete answer, but specifically addressing your question above <em>for the function definition part, if i need to do addition for singles+doubles</em>:  </p>

<pre><code>int singles_plus_doubles(struct stats temp)
{
   return temp.singles+temp.doubles;
}
</code></pre>

<p>You are really free to declare and use many variations of the data within your structure.  Typically, writing such a specific function as this one is not done, rather a pointer to a struct would be passed into a worker function, the members would be used to provide values, or to receive values, then returned to the calling function with new information.  I really think taking a look at @ChuckCottrill's answer (<strong><em><a href=""https://stackoverflow.com/a/19868117/645128"">in this same post</a></em></strong>) would be worth your while.</p>
",0
19868117,19867628,2,"<p>You basically want a constructor</p>

<p>define your type,</p>

<pre><code>typedef struct stats
{
    //char playername[100]; //you probably want a place to record player names...
    int singles;
    int doubles;
    int triples;
    int home_runs;
    int walks;
    int be; //base on error
    int Ko; //strikeout
    int go; //groundout
    int fo; //flyout
    int sc; //sacrifice out
    int rbi;  //runs batted in, reflects scoring, sacrifices, etc
    int at_bats;
    //calculated
    int hits;
    float BA;
    float OBP;
    float PWR;
    float HR_ratio;
    int TB;
    int SA;
} StatObj;
</code></pre>

<p>Now you need something to create/initialize a StatObj.  Some languages call this a constructor,</p>

<pre><code>StatObj* StatNew() //maybe pass playername?
{
    StatObj* so = malloc(sizeof(StatObj));
    //recorded
    so-&gt;singles = 0;
    so-&gt;doubles = 0;
    so-&gt;triples = 0;
    so-&gt;homeruns = 0;
    so-&gt;walks   = 0;
    so-&gt;at_bats = 0;
    so-&gt;be      = 0; //base on error
    so-&gt;ko      = 0; //strikeout
    so-&gt;go      = 0; //groundout
    so-&gt;fo      = 0; //flyout
    so-&gt;sc      = 0; //sacrificeout
    so-&gt;rbi     = 0; //runs batted in, reflects scoring, sacrifices, etc
    //calculated
    so-&gt;hits    = 0;
    so-&gt;BA      = 0.0;
    so-&gt;PWR     = 0.0;
    so-&gt;OBP     = 0.0;
    so-&gt;HR_ratio = 0.0;
    so-&gt;TB      = 0;
    so-&gt;SA      = 0;
    //what about walks, HBP (hit by pitch), BoE (base on error) OBP (on base pct)?
    return so;
}
</code></pre>

<p>You will need a function to (re)calculate your stats.</p>

<pre><code>void calculate(StatObj* sta)
{
    int hits, onbase;
    float power;
    if(!sta) return;
    hits = sta-&gt;singles + sta-&gt;doubles + sta-&gt;triples + sta-&gt;homeruns;
    onbase = hits + sta-&gt;walks + sta-&gt;be;
    power = (sta-&gt;singles + 2*sta-&gt;doubles + 3*sta-&gt;triples + 4*sta-&gt;homeruns)
    //what about sacrifices?
    //calculate other stats as you define them
    sta-&gt;hits = hits;
    sta-&gt;BA = (hits*1.0)/(sta-&gt;at_bats*1.0);
    sta-&gt;OBP = (onbase*1.0)/(sta-&gt;at_bats*1.0);
    sta-&gt;PWR = (power*1.0)/(sta-&gt;at_bats*1.0);
    HR_ratio = (sta-&gt;homeruns*1.0)/(sta-&gt;at_bats*1.0);
    //sta-&gt;TB;
    //sta-&gt;SA;
}

int StatPrint(StatObj* sta)
{
    if(!sta) return;
    /* printing the output using arrays */
    printf(""%6d"",sta-&gt;hits);
    printf(""BA\t\t\t\t%6.4f"", sta-&gt;BA);
    printf(""OBP\t\t\t\t%6.4f"", sta-&gt;OBP);
    printf(""TB\t\t\t%6f"", sta-&gt;TB);
    printf(""PWR\t\t\t\t%6.4f"",sta-&gt;PWR);
    printf(""HR%\t\t\t\t%6.4f"",sta-&gt;HR_ratio);
    printf(""SA\t\t\t\t%6.4f"", sta-&gt;SA);
    printf(""\n"");
    //et cetera
}
</code></pre>

<p>You will want a function to record each atbat, and the result.  You can pass the result of each atbat as a symbol/value, which then updates your raw statistics.  Then you can have a function to (re)calculate your stats.  Here is the record_atbat function,</p>

<pre><code>// 1 single, 2 double, 3 triple, 4 homerun
// x strikeout, k strikeout, e error, w walk
// f - flyout, g - groundout, s - sacrifice, ...
// do you want to record double play? triple play?
void record_atbat( StatObj* sta, int ab, int result, int rbi )
{
    if(!sta) return;
    sta-&gt;at_bats++;
    sta-&gt;rbi += rbi;
    switch(result)
    {
    case 1: case '1':
        sta-&gt;singles++;
        break;
    case 2: case '2':
        sta-&gt;doubles++;
        break;
    case 3: case '3':
        sta-&gt;triples++;
        break;
    case 4: case '4':
        sta-&gt;homeruns++;
        break;
    case 'w':
        sta-&gt;walks++;
        break;
    case 'e':
        sta-&gt;be++;
        break;
    // k/x=strikeout, f=flyout, g=groundout, s=sacrifice, ...
    case 'k': case 'x':
        sta-&gt;ko++;
        break;
    case 'f':
        sta-&gt;fo++;
        break;
    case 'g':
        sta-&gt;go++;
        break;
    case 's':
        sta-&gt;sc++;
        break;
    //base on error, affects on-base percentage
    default:
        break;
    }
    calculate(sta); //keep stats current
}
</code></pre>

<p>You will need to create at least one StatObj instance,</p>

<pre><code>int main()
{
    int i, hits;

    StatObj* sta = StatNew();  //you could create an array of these, one per player
    //StatObj* players[100];   //you probably want to record a bunch of players...

    record_atbat( sta, 1, 0 ); //single
    record_atbat( sta, 'k', 0 ); //strikeout
    record_atbat( sta, 2, 1 ); //double
    record_atbat( sta, 'w', 0 ); //walk
    record_atbat( sta, 'k', 0 ); //strikeout

    hits_number=calculate_hits_number(sta);
    /* calling function  */
    calculate(sta);

    StatPrint(sta);

    return (0);
}
</code></pre>

<p>You will want functions to serialize (write to file), and deserialize (read from file).</p>
",2
19439271,19439249,2,"<p>Becuase you have not allowed for the null terminator on the string.</p>

<p>Ok, some more detail.  You have not made it clear what you're trying to do, so let's assume you want to write 5 char bytes.  The problem is that when you read back your 5 chars you read them back into a char array (fine) then try to print that array with no null terminator - not fine.</p>

<p>So either read them back into a new array and set </p>

<pre><code>newarray[5]=0;
</code></pre>

<p>or print it out safe in the knowledge that you have 5 chars</p>

<pre><code>printf(""%5.5s"",array);
</code></pre>

<p>(something like that anyway)</p>
",10
19439379,19439249,1,"<p><em>printf(""%s\n"", arr2)</em> interprets <em>arr2</em> as a pointer to a string, not as a char array.
Since your char array does not end with a zero terminator, <em>printf</em> happily prints whatever is stored in the memory locations following the char array.</p>

<p>This code snippet should work:</p>

<pre><code>char arr2[5+1];
fread(arr2, sizeof(arr2) - 1, 1, binfile);
arr2[sizeof(arr2) - 1] = '\0';
printf(""%s\n"", arr2);
</code></pre>
",0
19508546,19508530,3,"<p>You are incrementing <code>tries</code> twice: once in the <code>for</code> definition, and also later in the body of the loop. </p>

<p>Remove the extra <code>tries++</code> statements.</p>
",0
19508552,19508530,0,"<p>You increment tries inside the code, as well as in the for statement.  Strip out the tries++ statements in the if-blocks.</p>
",0
19508571,19508530,0,"<p>You're incrementing the variable <code>tries</code> multiple times during loop execution,
once every turn and everytime you didn't guess your secret right</p>
",0
19508579,19508530,0,"<ol>
<li>for loop already increments tries .. you don't need to do tries++ inside if statements</li>
<li>you don't need the || condition in for loop as you are already doing the check in if statements</li>
</ol>

<p>here is the fixed code:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

int main ()
{
  int iSecret, iGuess;
  srand ( time(NULL) );
  iSecret = rand() % 20 + 1;
  int tries = 0;

  printf(""\nWelcome to the number guessing game!\nFor each game, you have at most 3 chances to guess a secret number from 1 to 20.\n"");


  for (tries = 0; tries &lt; 3 ; tries++) {

      printf (""Please, enter a number between 1 and 20!   "");
      scanf (""%d"", &amp;iGuess);

      if(iGuess == iSecret){
      printf (""\nCongratulations! You won!"");
      return 0;
      }

        else if (iGuess &gt; iSecret){
        printf (""\nYour guess was too high.\n"");
        }

        else if (iGuess &lt; iSecret){
            printf (""\nYour guess was too low.\n"");
                  }

  }
  printf (""\nYou have reached your third trials. The correct number is %d.\n"", iSecret);

  return 0;
  }
</code></pre>

<p><strong>Output:</strong></p>

<pre><code>$ ./test

Welcome to the number guessing game!
For each game, you have at most 3 chances to guess a secret number from 1 to 20.
Please, enter a number between 1 and 20!   2

Your guess was too low.
Please, enter a number between 1 and 20!   3

Your guess was too low.
Please, enter a number between 1 and 20!   4

Your guess was too low.

You have reached your third trials. The correct number is 10.
</code></pre>
",0
19508585,19508530,0,"<p>in addition to incrementing tries too many times, the code is overly complicated, you can simplify the logic like</p>

<pre><code>int main ()
{
  int iSecret, iGuess;
  srand ( time(NULL) );
  iSecret = rand() % 20 + 1;
  int tries = 0;

  printf(""\nWelcome to the number guessing game!\nFor each game, you have at most 3 chances to guess a secret number from 1 to 20.\n"");


  for (tries = 0; tries &lt; 3; tries++) {
      printf (""Please, enter a number between 1 and 20!   "");
      scanf (""%d"", &amp;iGuess);

      if(iGuess == iSecret) {
        printf (""\nCongratulations! You won!"");
        return 0;
      }

      printf ( ""\nYour guess was too %s.\n"", iGuess&gt;iSecret?""high"":""low"");

  }
  printf (""\nYou have reached your third trials. The correct number is %d.\n"", iSecret);
  return 0;
  }
</code></pre>
",0
18944688,18944617,0,"<p>You are not getting any error because the compiler does not check the type nor the existence of the external variable.
It is in the linking phase that the linker searches in the object files for a reference to a symbol named <code>x</code> (or <code>y</code>).</p>
",3
19508728,19508478,1,"<p>tl;dr ""The outputs equal a value that's basically random"" <em>because</em></p>

<ol>
<li><code>printf</code> is being used incorrectly; and</li>
<li><code>per-&gt;name = name</code> is incorrect.</li>
</ol>

<h3>Fixing printing</h3>

<p>The <code>&amp;someVariable</code> makes sense when using <code>scanf</code>/<code>fgets</code>/etc as these functions must <em>modify</em> a variable (in C this is done by passing a pointer to said variable); however, one <em>should not</em> pass a pointer to a variable when using <code>printf</code>: just pass the value!</p>

<p>Also, <em>use</em> the data that has been read (here is is available via the supplied <code>per</code> parameter). Using new local unassigned variables (even without <code>&amp;someVariable</code>) will lead to unpredictable output.</p>

<pre><code>void show_person(struct Person* per)
{
    // Also note use of %s, not %c - refer to the printf documentation.
    printf(""The person's name is %s\n"", per-&gt;name);
    printf(""Their age is %d\n"", per-&gt;age);
    // ..
</code></pre>

<h3>Fixing reading</h3>

<p>Now, there is another crucial flaw in <code>fill_person</code> (does it even compile?). This because one does not ""copy"" strings in C with <code>x = y</code> as that merely assigns a value, possibly a character pointer. Either use <code>strcpy</code> or, better, <code>fgets</code> directly into the <code>per-&gt;name</code> character array.</p>

<pre><code>void fill_person(struct Person* per)
{
    printf(""Enter a name.\n"");
    fgets(per-&gt;name, 100, stdin);
    // While the following intermediate variables could also be eliminated
    // using them won't affect the semantics of the code.
    // ..
</code></pre>

<p>I hope the sample stubs above and notes get you on your way!</p>
",0
19508487,19508478,1,"<p>Check your <code>printf</code> statements in <code>show_person</code> ¡ª at the minute they're passing the wrong kind of variable after each string, and the values they're passing are unrelated to the <code>struct</code> you pass in.</p>

<p>The stuff around your <code>fgets</code> also won't work the way you expect. E.g. <code>char string1[100], string2[100]; string2 = string1;</code> doesn't copy the contents of string1 to string 2.</p>
",4
19508506,19508478,1,"<p>Its because you aren't using the 'per' variable you pass the show_person function. You are basically creating new variables in that function, and then displaying them. You need to use per-> and drop the declaration of the variables in the function. </p>
",0
19508507,19508478,0,"<p>Because the struct in C doesn't have attributed like ""protected"" or ""private"" in C++/java and pointer *this in c++,so you can change the value of member in struct in function. I think you should write the function show_person like code bellow:</p>

<pre><code>void show_person(struct Person* per)
{
printf(""The person's name is %c\n"",per.name );

int age;
printf(""Their age is %d\n"",per.age);

int gpa;
printf(""Their GPA is %f"", per.gpa);
}
</code></pre>

<p>When you use &amp;variable, it's means the addresss of variable in memory, not its value. You should write your funciton like that</p>

<p><code>printf(""The person's name is %c\n"",name );</code></p>
",2
19508516,19508478,1,"<p>The <code>name</code> and other variables that you're printing are uninitialized local variables. You want to print the name from the Person object instead.</p>
",0
19508540,19508478,1,"<p>This is better, you don't need to use those local variables, you can read directly into your struct:</p>

<pre><code>void fill_person(struct Person* per)
{
  printf(""Enter a name.\n"");
  fgets(per-&gt;name, 100, stdin);

  printf(""Enter an age. \n"");
  scanf(""%d"" ,&amp;per-&gt;age);

  printf(""Enter a GPA. \n"");
  scanf(""%f"",&amp;per-&gt;gpa);
}
</code></pre>

<p>Check Tommy's answer for the problem with your other function.</p>
",0
18248576,18248528,0,"<p>You have defined z to be integer. While doing ""x+y"", the addition does happen on double size but when assigning it performs implicit conversion and truncate the result to fit in size of z.</p>
",0
18248604,18248528,4,"<p>No, <code>sizeof z</code> will always be <code>sizeof(int)</code></p>

<p>When you do:</p>

<pre><code>int z = x+y;
</code></pre>

<p>The value of <code>x</code> will be converted to <code>double</code> since <code>y</code> is double, but this won't change <code>x</code>. And the result of <code>x+y</code>(type <code>double</code>) will be converted to <code>int</code>, and assigned to <code>z</code>.</p>
",5
18248653,18248528,0,"<p>Since you <em>declared</em> z being <em>int</em> it' ll be <em>int</em>. And every possible conversion will be from whatever type to int: </p>

<pre><code>  int z = whatever (legal) formula you put here; 
  sizeof(z); /* &lt;- 4 */
</code></pre>

<p>on the contrary <em>temporal</em> value of x + y is double which is finally converted to int</p>

<pre><code>  int x = 5;
  double y = 6;
  int z = x+y; /* x + y = 11.0 since y = 6.0; which is converted to 11*/
</code></pre>
",2
18248723,18248528,0,"<p><strong>Read the comments</strong> which describe your code behavior:</p>

<pre><code>#include &lt;stdio.h&gt;

int main (void) {

int x = 5;
double y = 6;
int z = x+y; // 5 (int, 4 bytes) + 6 (double, 8 bytes)
             // converting `int` to `double` when adding them ()
             // 5.0 (double, 8 bytes) + 6.0 (double, 8 bytes)
             // 11.0 (double, 8 bytes)
             // But! `z` is of type `int`, so it will not convert to `double`
             // Then 11.0 converts to 11 because `z`... is of type `int`! 
            /// read ""Double-precision floating-point format"" and you'll see why.
             // So,  z = 11 (`z` is of type `int`, so it's size is *4* bytes )
             // Here is your 4 bytes instead of 8! ;)

printf(""size of z = %d bytes"",sizeof(z));
return 0;
</code></pre>

<p>}</p>
",6
19793942,19793873,0,"<p>In <code>main</code>, inside your while loop just add:</p>

<pre><code>player = !player;
</code></pre>

<p>Which will toggle <code>player</code> between 0 and 1.</p>
",1
19794510,19793873,1,"<p><strong>Bug a and c:</strong></p>

<p>Your <code>check_move</code> function is wrong, you should only test if the position played is eaten or not, the status of the  other positions are not relevant:</p>

<pre><code>int check_move(int pos[])
{
    if(pos[0] &lt; 1 || pos[0] &gt; height  ||  pos[1] &lt; 1 || pos[1] &gt; width)
    {
        printf(""Your move must be inside the matrix!\n"");
        return 0;
    }

    if(matrix[ pos[0] - 1 ][ pos[1] - 1 ] != 'O' ) {
        printf(""Already eaten!\n"");
        return 0; 
    }

    return 1;
}
</code></pre>

<p><strong>Bug b:</strong></p>

<p>You get the error message twice because you're calling <code>check_move</code> twice in your main:</p>

<pre><code>check_move(position);
while(check_move(position) != 1)
</code></pre>

<p>Just remove the useless first call to <code>check_move()</code>.</p>

<p><strong>Question a:</strong></p>

<p>You can switch between players by updating the variable <code>player</code> inside your main :</p>

<pre><code>player = (player + 1) % maxNumberOfPlayer;
</code></pre>

<p>This will go from <code>0</code> to <code>maxNumberOfPlayer - 1</code>, so you may use <code>printf(""Player %d, make your move: "", player + 1);</code> for a more user-friendly output. Also, if <code>maxNumberOfPlayer = 2</code>, <code>player = (player + 1) % 2;</code> is equivalent to <code>player = !player</code>.</p>
",4
19791361,19790453,0,"<p>I would suggest you to fix names of variables temp1,2. It complicates a lot understanding of the code.<br>
In the while() loop there is pred and temp variables which have the same value. Then why not just remove one of them?<br>Right after the while() loop there is a check for value - but while() loop has already checked item temp for this condition while looping through the items. So this check is wrong.<br>Now you already know that item ""temp"" is less than key, but next item, if it is not NULL is greater. So you have to check if it is NULL or not. <br>If it is NULL then you have to add new item to the end of the list.<br>If it is not NULL then you have to add item right after current item ""temp"" and before ""temp->next"" because ""temp->next"" is already greater than current item ""temp"" and new item. 
<br><br>Below a code for using in case of if statement then header is not NULL (with some variables renamed for clearness):</p>

<pre><code>{   
    assert(head != NULL); // head not NULL already
    newItem = (struct node*) malloc(sizeof(struct node));
    newItem-&gt;data =  key;
    currItem = head;

    while(currItem-&gt;next!=NULL &amp;&amp; currItem-&gt;next-&gt;data &lt; key){
        currItem = currItem-&gt;next;}

    if(currItem-&gt;next == NULL){ // append new item to the end of list
        currItem-&gt;next = newItem;
    }               
    else{ // insert somewhere in the middle (next item key is greater than current key)
        newItem-&gt;next = curr-&gt;next;
        currItem-&gt;next = newItem;
    }           
}
</code></pre>
",0
19791365,19790453,0,"<p>The insert in the middle code (last if-statement in the posted code example) should work better like this:</p>

<pre><code>    if (temp-&gt;data &lt; key) {
        // Insert in the middle
        temp-&gt;next = temp2;
        temp2-&gt;prev = temp;
        temp2-&gt;next = pred-&gt;next-&gt;next;
        temp2-&gt;next-&gt;prev = temp2;       // Added
    } else {     
        // Insert last                   // Changed entire block
        temp2-&gt;prev= temp;     
        temp-&gt;next = temp2; 
        temp2-&gt;next = null;
    }           
</code></pre>
",0
19791415,19790453,0,"<p>For a doubly linked list maintaining a <code>tail</code> would be symmetrict.
Without that, I would do it thus.</p>

<p>The entire insert:</p>

<pre><code>struct node* prev = NULL;
struct node* ptr;
for (ptr = head; ptr != NULL &amp;&amp; key &lt; ptr-&gt;data; ptr = ptr-&gt;next) {
    prev = ptr;
}

struct node* baby = (struct node *) malloc(sizeof(struct node));
baby-&gt;data = key;
baby-&gt;prev = prev;
baby-&gt;next = ptr;
if (prev != null) {
    prev-&gt;next = baby; // Link in from previous
}
if (ptr != null) {
    ptr-&gt;prev = baby; // Link in from next
}
if (head == NULL) {
    head = baby;
}
</code></pre>
",0
19261184,19261171,7,"<p>You get the warning because the expression gets calculated, and then the result is dropped. This is related to the ""reaching the end of the function without returning a value"" error: adding <code>return</code> in front of the expression will fix both:</p>

<pre><code>char change(const char c) {
    return (c &gt;= 'A') &amp;&amp; (c &lt;= 'M') ? 
        (c+'N'-'A') :  ((c &gt;= 'N') &amp;&amp; (c &lt;= 'Z') ? 
             (c-('N'-'A')) : ((c &gt;='a') &amp;&amp; (c &lt;= 'm') ? 
                 (c+'n'-'a') : ((c &gt;= 'n') &amp;&amp; (c &lt;= 'z') ? 
                     (c-('n'-'a')) : c )));
}
</code></pre>
",0
20094633,20094586,6,"<p>That's why using <code>gets</code> is an <em>evil thing</em>. Use <code>fgets</code> instead.</p>
<p><em><code>malloc</code> has nothing to do with it</em>.</p>
<h2><a href=""http://beej.us/guide/bgc/output/html/multipage/gets.html"" rel=""nofollow noreferrer"">Don't use gets()</a>.</h2>
<blockquote>
<p>Admittedly, rationale would be useful, yes? For one thing, <strong><code>gets()</code> doesn't allow you to specify the length of the buffer to store the string in. This would allow people to keep entering data past the end of your buffer</strong>, and believe me, this would be Bad News.</p>
</blockquote>
<h2><a href=""http://faq.cprogramming.com/cgi-bin/smartfaq.cgi?answer=1049157810&amp;id=1043284351"" rel=""nofollow noreferrer"">Detailed explanation</a>:</h2>
<p>First, let's look at the prototype for this function:</p>
<pre><code>#include &lt;stdio.h&gt;
char *gets(char *s);
</code></pre>
<p>You can see that the one and only parameter is a <code>char</code> pointer. So then, if we make an array like this:</p>
<pre><code>char buf[100];
</code></pre>
<p>we could pass it to <code>gets()</code> like so:</p>
<pre><code>gets(buf)
</code></pre>
<p>So far, so good. Or so it seems... but really our problem has already begun. <code>gets()</code> has only received the name of the array (a pointer), <strong>it does not know how big the array is</strong>, and it is impossible to determine this from the pointer alone. When the user enters their text, <code>gets()</code> will read all available data into the array, this will be fine if the user is sensible and enters less than 99 bytes. However, if they enter more than 99, <code>gets()</code> <strong>will not stop writing at the end of the array</strong>. Instead, it continues writing past the end and into memory it doesn't own.</p>
<ol>
<li><p>This problem may manifest itself in a number of ways:</p>
</li>
<li><p>No visible affect what-so-ever</p>
</li>
<li><p>Immediate program termination (a crash)</p>
</li>
<li><p>Termination at a later point in the programs life time (maybe 1 second later, maybe 15 days later)</p>
</li>
<li><p>Termination of another, unrelated program</p>
</li>
<li><p>Incorrect program behavior and/or calculation
... and the list goes on. This is the problem with <strong>&quot;buffer overflow&quot;</strong> bugs, you just can't tell when and how they'll bite you.</p>
</li>
</ol>
",1
20094647,20094586,2,"<p>You just got an undefined behavior. (<a href=""http://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow"">More information here</a>)</p>

<p>Use fgets and not gets !</p>
",0
20094814,20094586,1,"<p>The malloc will reserve 10 bytes (in your case assuming the char have 1 byte) and will return the start point of the reserved area.<br>
You do a <code>gets</code>, so it get the text you typed and write using your pointer.
Windows/Mac os x/ Unix (Advances OS'S) have protected memory.
That means, when you do a malloc/new the OS reserve that memory area for your program. IF another program tries to write in that area an segmentation fault happens because you wrote on an area that you should not write.</p>

<p>You reserved 10 bytes.
IF the byte 11, 12, 13, 14 are not yet reserved for another program it will not crash, if it is your program will access an protected area and crash.</p>
",2
20096439,20094586,2,"<p><code>malloc</code> reserves memory for your use. The rules are that you are permitted to use memory allocated this way and in other ways (as by defining automatic or static objects) and you are not permitted to use memory not allocated for your use.</p>

<p><strong>However, <code>malloc</code> and the operating system do not completely enforce these rules.</strong> The obligation to obey them belongs to you, not to <code>malloc</code> or the operating system.</p>

<p>General-purpose operating systems have memory protection that prevents one process from reading or altering the memory of another process without permission. It does not prevent one process from reading or altering its own memory in improper ways. When you access bytes that you are not supposed to, there is no mechanism that always prevents this. The memory is there, and you <strong>can</strong> access it, but you <strong>should not</strong>.</p>

<p><code>gets</code> is a badly designed routine, because it will write any amount of memory if the input line is long enough. This means you have no way to prevent it from writing more memory than you have allocated. You should use <code>fgets</code> instead. It has a parameter that limits the amount of memory it may write.</p>

<p>General-purpose operating systems allocate memory in chunks known as pages. The size of a page might be 4096 bytes. When <code>malloc</code> allocates memory for you, the smallest size it can get from the operating system is one page. When you ask for ten bytes, <code>malloc</code> will get a page, if necessary, select ten bytes in it, keep records that a small portion of the page has been allocated but the rest is available for other use, and return a pointer to the ten bytes to you. When you do further allocations, <code>malloc</code> might allocate additional bytes from the same page.</p>

<p>When you overrun the bytes that have been allocated to you, you are violating the rules. If no other part of your process is using those bytes, you might get away with this violation. But you might alter data that <code>malloc</code> is using to keep track of allocations, you might alter data that is part of a separate allocation of memory, or you might, if you go far enough, alter data that is in a separate page completely and is in use by a completely different part of your program.</p>

<p>A general-purpose operating system does provide some protection against improper use of memory within your process. If you attempt to access pages that are not mapped in your virtual address space or you attempt to modify pages that are marked read-only, a fault will be triggered, and your process will be interrupted. However, this protection only applies at a page level, and it does not protect against you incorrectly using the memory that is allocated to your process.</p>
",0
20102396,20094586,0,"<p>OP: ... number of characters are more than 10 bytes. How this is possible?<br>
A: Writing outside allocated memory as done by <code>gets()</code> is undefined behavior - UB.  UB ranges from working just as you want to crash-and-burn.</p>

<p>The <strong>real issue is</strong> not the regrettable use of <code>gets()</code>, but the <strong>idea that C language should prevent memory access mis-use</strong>.  C does not prevent it.  The code should prevent it.  C is not a language with lots of behind-the-scenes protection.  If writing to <code>ptr[10]</code> is bad, don't do it.  Don't call functions that might do it such as <code>gets()</code>.  Like many aspects of life - practice safe computing.</p>

<p>C gives you lots of rope to do all sorts of things including enough rope to hang yourself.</p>
",0
19507157,19507123,1,"<p>You need to add an input within your while.  In other words, instead of:</p>

<pre><code>   while (player_num != player_input)    {
     printf(""You Have to wait your turn.\nPlayer number?\n"");
   }
</code></pre>

<p>try this:</p>

<pre><code>while (player_num != player_input)    {
   printf(""You Have to wait your turn.\nPlayer number?\n"");
   scanf(""%d"", &amp;player_input);
}
</code></pre>
",0
19507483,19507123,1,"<p>First, <strong><code>srand</code></strong> needs to be invoked only once and at the start of the program. </p>

<p>Second, <strong><code>scanf</code></strong> was moved inside the second while loop to force user to enter the correct player number or keep asking until he/she gets it right. </p>

<p>The following code fixes all of the above. Please read the comments in the code to see the reasons for the changes:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;malloc.h&gt;

int main(void) { 

 int player_num = 0; int number = 0; int player_input = 0;
 int guess = 0; char input; char str[15] = {0}; // size was increased to compensate for pass pass input
 int Player_1 = 1;
 int Player_2 = 2; int Pass_1 = 3; int Pass_2 = 3; int i = 1;
 int player_turn = 0; int turn = 0; int alternate=0;
 int player1Flag=0,player2Flag=0;

 int lastPlayer=0;

 srand(time(NULL));  
 player_num = 1 + rand() % 2; /* Random number is generated */
 lastPlayer = player_num;
 number = 0 + rand() % 100; /* Random number is generated */

  while(number != guess) {

      while (player_num != player_input)    {
           printf(""\nIt's player's %d turn\n"", player_num);
           printf(""Player Number?\n"");
           scanf(""%d"", &amp;player_input);
           getchar();// to get rid of \n after the input

           if(player_input!=player_num){
               printf(""You Have to wait your turn.\n"");
           }

      }

      if (Player_1 != player_num) Player_2 = player_num;


      printf(""Enter Your Guess, 0 - 100 or Pass: "");

      scanf(""%s"",str);

     if (strcmp(str, ""pass"") == 0){
        if (player_num == Player_1){
            player1Flag = player1Flag+1; // flag to detect if last input was a pass

            if(player1Flag&gt;1){
                printf(""Dude you passed in your last attempt .. dont be a pus*y\nEnter a guess : "");
                scanf(""%s"",&amp;str);
                guess = atoi(str);
                if(guess &lt; number){ /* if the guess is lower, output: the guess is too low */
                   printf(""Your guess was to low.\n "");
                }else if(guess &gt; number){ /* if the guess is higher, output: the guess is too high */
                   printf(""Your guess was to high.\n "");
                }else{ /* if the guess is equal to the random number: Success!! */
                   printf(""Yes!! you got it!\n"");
                }
                player1Flag = 0; // reset the pass flag = 1 as this pass isn't counted
            }else{
                Pass_2 = Pass_2 -1;
                if(Pass_2&lt;0){
                    printf(""You have already passed Thrice\nEnter a guess: "");
                    scanf(""%s"",&amp;str);
                    guess = atoi(str);
                    if(guess &lt; number){ /* if the guess is lower, output: the guess is too low */
                       printf(""Your guess was to low.\n "");
                    }else if(guess &gt; number){ /* if the guess is higher, output: the guess is too high */
                       printf(""Your guess was to high.\n "");
                    }else{ /* if the guess is equal to the random number: Success!! */
                       printf(""Yes!! you got it!\n"");
                    }
                }else{
                    printf(""Player 1 has %d more 'Pass' left!\n"", Pass_2);
                }
            }
        }   
        else{

            player2Flag = player2Flag + 1;

            if(player2Flag&gt;1){
                printf(""Dude you passed in your last attempt .. dont be a pus*y\nEnter a guess : "");
                scanf(""%s"",&amp;str);
                guess = atoi(str);
                if(guess &lt; number){ /* if the guess is lower, output: the guess is too low */
                   printf(""Your guess was to low.\n "");
                }else if(guess &gt; number){ /* if the guess is higher, output: the guess is too high */
                   printf(""Your guess was to high.\n "");
                }else{ /* if the guess is equal to the random number: Success!! */
                   printf(""Yes!! you got it!\n"");
                }
                player2Flag=0;// reset the player2Flag = 1 as this pass isn't counted
            }else{
                Pass_1 = Pass_1 -1;
                if(Pass_2&lt;0){
                    printf(""You have already passed Thrice\nEnter a guess: "");
                    scanf(""%s"",&amp;str);
                    guess = atoi(str);
                    if(guess &lt; number){ /* if the guess is lower, output: the guess is too low */
                       printf(""Your guess was to low.\n "");
                    }else if(guess &gt; number){ /* if the guess is higher, output: the guess is too high */
                       printf(""Your guess was to high.\n "");
                    }else{ /* if the guess is equal to the random number: Success!! */
                       printf(""Yes!! you got it!\n"");
                    }
                }else{
                    printf(""Player 2 has %d more 'Pass' left!\n"", Pass_2);
                }
            }
        }   

     }else {

        if (player_num == Player_1){
            player1Flag = 0;//reset pass flag as this player enetered a guess
        }else{
            player2Flag = 0;
        }

        guess = atoi(str);
            if(guess &lt; number){ /* if the guess is lower, output: the guess is too low */
                printf(""Your guess was to low.\n "");

            }else if(guess &gt; number){ /* if the guess is higher, output: the guess is too high */
                printf(""Your guess was to high.\n "");

            }else{ /* if the guess is equal to the random number: Success!! */
                printf(""Yes!! you got it!\n"");

             }
      }

      if(lastPlayer==1){
          player_num = 2;
          lastPlayer = 2;
      }else if(lastPlayer==2){
            player_num = 1;
            lastPlayer = 1;
      }

  }   

  return 0;

}
</code></pre>
",8
19385632,19385388,1,"<p><code>#define</code> is old, and simply textual replacement processed by preprocessor. For example when you do <code>#define PI 3.14</code>, preprocessor simply replaces all occurance of <code>PI</code> by the number literal 3.14</p>

<p><code>const</code> is newer, and compiler dependent. It could be evaluated at compile time, or at runtime. It also provides scope.</p>

<p>I personally use <code>#define</code> because it is guarrentee to be evaluated at compile time, and it has other flexible uses.</p>
",0
19961037,19960968,1,"<p>You're never going to be able to get those numbers output in a realistic amount of time for comparison.</p>

<p>The problem is the process of streaming to the console is a more expensive operation, so this isn't a very effective method for performance comparison.</p>

<p>The best I can suggest is to measure the system time before and after and output the differences from before and after after the code is finished executing.</p>
",2
19577246,19577067,1,"<p>To skip 1 line in the input file:</p>

<pre><code>fscanf(f, ""%*[^\n]\n"");
</code></pre>

<p>To read 1 number from the file:</p>

<pre><code>int number;
fscanf(f, ""%d"", &amp;number);
</code></pre>

<p>To compare a number with 5:</p>

<pre><code>if (number &lt; 5)
{
    ...
}
</code></pre>

<p>P.S. The site <a href=""http://www.cplusplus.com"" rel=""nofollow"">http://www.cplusplus.com</a> has some examples for the basic stuff you need. That site is dedicated to C++ but at your level there so little difference between C and C++, you can use the examples for your work (if you understand them).</p>

<p>Example: <a href=""http://www.cplusplus.com/reference/cstdio/fscanf/?kw=fscanf"" rel=""nofollow"">fscanf</a> (at the bottom of the page)</p>
",0
19577247,19577067,1,"<pre><code>#include &lt;stdio.h&gt;

#define LINE_MAX 1024

int main() {
    int line_count = 7;
    int fd = open('file', r);
    int smaller_than_five = 0, bigger_than_five = 0;
    int number;

    while (line_count != 0) {
        fgets(input_line, LINE_MAX, fd);
        line_count--;
    }
    while(sscanf(input_line, ""%d"", &amp;number) != EOF) {
        if (number &gt; 5) bigger_than_five++;
        else if (number &lt; 5) smaller_than_five++;
    }

    /*
     * Now you have:
     *  smaller_than_five which is the count of numbers smaller than five
     *  bigger_than_five which is the count of numbers bigger than five
     */
     return 0;
}
</code></pre>

<p>This works when the numbers are on seventh line. If they are on the last (but could be second or 51st), you'll have to change the first <code>while</code> to read while you have not reached the end.</p>
",0
19445790,19445483,0,"<pre><code>While read a line from a file you can invoke the following function:

 if( fgets (str, 60, fp)!=NULL ) {

                            puts(str);
                            token = strtok(str,"" "");
                            while(token != NULL)
                            {
                                    printf(""%s\n"",token);
                                    token = strtok(NULL,"" "");
                            }
                    }
</code></pre>
",0
19445866,19445483,0,"<p>Impleted with <code>strtok()</code></p>

<pre><code>char *p;
char temp[256];

while(fgets(temp,256,fp) != NULL){
  p = strtok (temp,"" "");
  while (p != NULL)
  {
    printf (""%s\n"",p);
    p = strtok (NULL, "" "");
  }
}
</code></pre>

<p>If you see <code>man strtok</code> You will found   </p>

<p><strong>BUGS</strong></p>

<blockquote>
  <p>Be cautious when using these functions.  If you do use them, note that:
         * These functions modify their first argument.</p>
</blockquote>

<pre><code>   * These functions cannot be used on constant strings.

   * The identity of the delimiting character is lost.

   * The strtok() function uses a static buffer while parsing, so it's not thread safe.  Use strtok_r() if this matters to you.
</code></pre>

<p>Try to make changes with <code>strtok_r()</code></p>
",0
20510390,20510299,0,"<p>Please read <a href=""http://www.cplusplus.com/reference/cstdio/gets/"" rel=""nofollow"">description of function gets()</a>!
This function reads string from stdin. It returns NULL if found end of line or end of file before any characters.</p>
",1
20020645,20020491,0,"<p>check !feof(stdin) right at the end of the loop. It will be true after you have read the last value, so in this case the last value is not stored</p>
",1
20020656,20020491,1,"<p>It is the <code>if (feof(stdin)) break;</code> that does the damage. You should only break on EOF if you do not get <code>1</code> from <code>scanf()</code>.  In your example, the system knows it has reached EOF, but it also successfully converted a value, and it told you so by returning <code>1</code> from <code>scanf()</code>, but you went ahead and ignored the successfully converted value because EOF was also detected.</p>

<p>You should probably use:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    int field[100];
    int count = 0;
    int n;

    for (int i = 0; i &lt; 100; i++)
    {
        int number;
        if ((n = scanf(""%d"", &amp;number)) != 1)
            break;
        printf(""-- %d: %d (%d)\n"", i, number, n);
        field[i] = number;
        count++;
    }

    if (n == 0)
    {
        printf(""Wrong input.\n"");
        return 1;
    }
    else if (ferror(stdin))
    {
        printf(""I/O error on stdin\n"");
        return 1;
    }
    else if (feof(stdin) &amp;&amp; count == 0)
    {
        printf(""Empty input.\n"");
        return 1;
    }

    printf(""Count: %d\n"", count);
    for (int j = 0; j &lt; count; j++)
        printf(""%d: %d\n"", j, field[j]);
    return 0;
}
</code></pre>
",5
20021606,20020491,0,"<p>After successfully reading the last number via <code>scanf (""%d""...</code>,  calling <code>feof()</code> may return true <em>or</em> false, depending on if additional white space, like <code>\n</code> follows the number.  Thus <code>feof()</code> is not a definitive test to stop looping.  Simpler code is possible.</p>

<p>In general, avoid using <code>fscanf()</code> and <code>feof()</code> in the same parsing routine.  Instead use the return value from <code>fscanf()</code> to know when EOF occurred.</p>

<pre><code> while ((retval = fscanf(...)) == expected value) {
   // The happy path
   do_stuff();
 }
 if (retval == EOF) {
   Deal_with_EOF_or_IOerror();
 }
 else {
   Deal_with_unexpected_number_of_parameters_scanned();
 }
</code></pre>
",0
19794425,19783986,0,"<p>Change return type to <code>unsigned long long</code> to insure you have a large enough integer.</p>

<p>Change <code>p</code> type to an unsigned type.</p>

<p>Print value with leading zeros.</p>

<pre><code>unsigned long long conver_bcd(const char *p, size_t length) {
  const unsigned char *up = (const unsigned char*) p;
  unsigned long long convert =0;
  while (length--) {
    convert = convert * 100 + (*up &gt;&gt; 4) * 10 + (*up &amp; 15);
    ++up;
    }
  return convert;
}

const char *p =  ""\x00\x91\x12\x34\x56\x78\x90"";
size_t length = 7;
printf( ""%0*llu\n"", (int) (length*2), conver_bcd(p, length));
// 00911234567890
</code></pre>
",2
19795124,19794940,2,"<p><a href=""http://en.wikipedia.org/wiki/Sorting_algorithm"" rel=""nofollow"">http://en.wikipedia.org/wiki/Sorting_algorithm</a></p>

<p>This will give you various sorting algorithms, and when you select most of the algorithms wikipedia will have some pseudo code for that algorithm.  It's a really good exercise to translate pseudo code into the native language that you're writing it in (in this case C); I still do it when I'm learning a new language since implementing sorting algorithms usually gives you a good handle on the basics of that language.</p>

<p>From a more mothering/lecturing point, you won't have an easier time in your later classes if all you end up doing is getting your code from other people, you need to solve it yourself, plain and simple.</p>

<p>From the list of one's you have done quick and merge sort are probably the hardest, if you have those written (and actually wrote them) the rest should be fairly easy.</p>
",5
20183738,20183687,1,"<p>This does not work with <code>fgets</code> because it keeps the trailing <code>\n</code> with the string; <code>gets</code> does not do that. </p>

<p>From the <a href=""http://www.cplusplus.com/reference/cstdio/fgets/"" rel=""nofollow"">documentation</a>:</p>

<blockquote>
  <p>A newline character makes fgets stop reading, but it is considered a valid character by the function and included in the string copied to str.</p>
</blockquote>

<p>To fix this, adjust the length to account for the trailing <code>\n</code> mark: go to the end of the string, and move back until you see a non-<code>\n</code> character.</p>
",1
20203551,20202910,0,"<p>To answer the direct question, you can usually force a hardware reset on this kind of processor by letting the watchdog expire:</p>

<ul>
<li>If it's already configured to cause a reset, then just spin in a for(;;) {} loop until it expires</li>
<li>If the watchdog is not yet configured, then configure it to cause a reset with a minimum timeout and then spin.</li>
</ul>

<p>A watchdog reset is usually a pretty close approximation of a normal power-up hardware reset.</p>

<p>All that said, I would strongly recommend that you chase-down the problem with the RTC and don't distract yourself with some horrible reset hack.  </p>

<p>Start by trying to get away from using whatever craptastic code ST have provided in the form of an 'API' - this kind of code tends to be written by interns with terrible hangovers, and is worth looking at for examples, but rarely good enough to actually be properly useful.  Trying to use it without understanding it is almost always just a painful way of delaying the moment when you have to open the datasheet/userguide for the chip and get to grips with how it works.</p>

<p>You don't say exactly what processor you're using, but page 559 of this may be useful:</p>

<p><a href=""http://www.st.com/web/en/resource/technical/document/reference_manual/CD00225773.pdf"" rel=""nofollow"">http://www.st.com/web/en/resource/technical/document/reference_manual/CD00225773.pdf</a></p>

<p>Be absolutely clear that you've done each step of the process as there is some stuff about initialising the calendar which looks quite fiddly.</p>
",0
20204172,20202910,2,"<p>The AIRCR register (address 0x0xE000ED0C) has a SYSRESETREQ bit (0x0004).  Setting this bit resets the processor.</p>

<p>See:
Application interrupt and reset control register (SCB_AIRCR)
PM0056
Programming manual
STM32F10xxx/20xxx/21xxx/L1xxxx
Cortex-M3 programming manual</p>
",0
19876430,19876243,0,"<p>A static const needs to be initialized at compile time, you put a function call there. Advanced compilers such as gcc can compute something like this at compile time anyway and will just warn about the illegal construct instead of erroring out. Yours apparently is not capable of this.</p>

<p>The other thing is that <code>gamma()</code> is not a standard libmath function, they are some Unix non-standard thing you would find on BSDs and Linux but not (going by your path names) on your Windows. It is deprecated anyway and there are <code>tgamma()</code> and <code>lgamma()</code> which are standardized in C99.</p>
",0
19876371,19876243,0,"<p>The two error messages are quite clear.</p>

<p>The first one says that you cannot initialize a variable with a non-constant value.</p>

<p>while <code>log(M_PI)</code> is indeed constant, the compiler cannot treat it as such, because it doesn't know if the function <code>log()</code> always returns the same result. It does, but the compiler must assume it doesn't, hence ""non-constant"".</p>

<p>The second one says that the function <code>gamma</code> you try to call here is not defined.</p>

<p>Hence, it assumes it is an <code>extern int gamma()</code>. As it is unclear where this function is declared, you should at least include the appropriate header file containing its prototype.</p>
",0
19876400,19876243,0,"<p>This line is the cause of your first error:</p>

<pre><code>const double log_pi = log(M_PI);
</code></pre>

<p>The expression <code>log(M_PI)</code> is not constant and cannot be used in the initialization.  Either use the following instead, or move the definition inside your <code>main</code> function and remove the <code>const</code>:</p>

<pre><code>const double log_pi = 1.1447298858494002;
</code></pre>

<p>The second error is because the compiler cannot find the function <code>gamma</code>.  It seems that it is not defined in your <code>math.h</code>.  If you're not getting linker errors, I suggest that you add:</p>

<pre><code>double gamma (double);
</code></pre>

<p>The right thing to do would be to find the proper header file to include.  <a href=""https://stackoverflow.com/questions/18116376/what-is-the-definition-for-gammadouble-x-and-why-is-it-different-on-two-gcc-ve"">This question</a> could shed some light.</p>
",0
19876407,19876243,0,"<p><code>log(M_PI)</code> is not a constant expression, its a constant qualified object which is not constants in C language terminology. For this you need to declare a named constant you should use either <code>#define</code> or <code>enum</code>, but not <code>const</code> qualifier. <strong>Variables of <code>const double</code> type are not constants in C</strong>.  </p>

<pre><code>#define log_pi log(M_PI)
</code></pre>
",0
19889631,19889600,1,"<p>String is a not a type in C. You should probably use <code>char *</code> or <code>const char *</code>. 
Change the line which causes the error to : </p>

<pre><code>typedef const char * ERROR;
</code></pre>
",0
18976423,18976403,3,"<p>You can't read <code>Q</code> into an integer variable. Read the input into a character one.</p>
",0
18976852,18976403,0,"<p>Problem is that your <code>scanf</code> reads a string <strong>and</strong> converts it to integer immediately (thats what <code>%d</code> does).</p>

<p>You need to first read only a string (with <code>%s</code> or similar) to a buffer and then check that it is not <code>'Q'</code>. After that you can do the conversion to integer with <code>sscanf</code>.</p>

<p>See <a href=""http://en.cppreference.com/w/c/io/fscanf"" rel=""nofollow"">http://en.cppreference.com/w/c/io/fscanf</a></p>

<p><strong>Edit:</strong> Also, your code completely ignores the quit status.</p>
",0
19888691,19888676,0,"<p><code>%c</code> is used to read characters</p>

<p><code>%d</code> is for integers</p>

<p>When you write </p>

<pre><code>scanf(""%d"",&amp;i)
</code></pre>

<p>if i is declared as integer then if you try to print the value of i then it will print integer.</p>

<p>And when you write</p>

<pre><code>scanf(""%c"",&amp;i)
</code></pre>

<p>if i is declared as character then if you try to print the value of i then it will print charcter.</p>

<p>Also check <strong><a href=""http://www.cplusplus.com/reference/cstdio/scanf/"" rel=""nofollow"">scanf:-</a></strong></p>

<blockquote>
  <p><strong>Format specifiers:</strong> A sequence formed by an initial percentage sign (%)
  indicates a format specifier, which is used to specify the type and
  format of the data to be retrieved from the stream and stored into the
  locations pointed by the additional arguments.</p>
  
  <p><strong>Return Value</strong></p>
  
  <p>On success, the function returns the number of items of the argument
  list successfully filled. This count can match the expected number of
  items or be less (even zero) due to a matching failure, a reading
  error, or the reach of the end-of-file.</p>
  
  <p>If a reading error happens or the end-of-file is reached while
  reading, the proper indicator is set (feof or ferror). And, if either
  happens before any data could be successfully read, EOF is returned.</p>
  
  <p>If an encoding error happens interpreting wide characters, the
  function sets errno to EILSEQ.</p>
</blockquote>
",2
19888708,19888676,0,"<p>If you look at the <a href=""http://www.cplusplus.com/reference/cstdio/scanf/"" rel=""nofollow noreferrer"">function signature</a> of <code>scanf()</code>, it returns an <code>int</code>, which you can use to check whether the scan operation was successful or if it failed:</p>
<blockquote>
<p>On success, the function returns the number of items of the argument list successfully filled. This count can match the expected number of items or be less (even zero) due to a matching failure, a reading error, or the reach of the end-of-file.</p>
<p>If a reading error happens or the end-of-file is reached while reading, the proper indicator is set (feof or ferror). And, if either happens before any data could be successfully read, EOF is returned.</p>
<p>If an encoding error happens interpreting wide characters, the function sets errno to EILSEQ.</p>
</blockquote>
",0
19888728,19888676,0,"<p><code>scanf() reads charcters from</code>stdin<code>, and then converts the characters into data types specified by formats.</code> ?</p>

<p>Man page on <a href=""http://linux.die.net/man/3/scanf"" rel=""nofollow"">scanf</a> clearly answers this,</p>

<pre><code>The scanf() family of functions scans input according to format as described 
below. This format may contain conversion specifications; the results from such
conversions, if any, are stored in the locations pointed to by the pointer 
arguments that follow format. Each pointer argument must be of a type that is 
appropriate for the value returned by the corresponding conversion specification. 
</code></pre>
",0
19889031,19888676,0,"<p>You are wondering infrastructure details of your communication with the program in a prompt(cmd, terminal etc.) environment i guess. When you write the code like:</p>

<pre><code>int x;
scanf(""%d"", &amp;x);
</code></pre>

<p>and compile and run, program stops and waits for the <code>scanf</code> line to be entered anything to the underlined environment such as <code>cmd</code> or <code>terminal</code>. When you or your user start entering anything from the keyboard, program does nothing maybe buffering. But when you press enter,
program tries to get the characters(up to the whitespace) and convert them to desired variable type that is integer, because you said so in the <code>scanf</code> function parameter. This mentioned conversion happens implicitly. If you wrote:</p>

<pre><code>char str[20];
scanf(""%s"", str);
</code></pre>

<p>and enter some keys from the keyboard, then the underlined behavior of the conversion would be different.
For summary, logic is simple:
if you define varible <strong>int</strong>, then the program tries to convert to <strong>int</strong>; if you define <strong>float</strong>, program tries to convert to <strong>float</strong>. But all entered keys come from the character sequence and this is called <em>string</em>. I recommend you to read the usage of <a href=""http://www.cplusplus.com/reference/cstdio/scanf/"" rel=""nofollow"">scanf</a>
and let it go.</p>
",0
19888815,19888676,0,"<blockquote>
  <p>Scanning stops when an input character does not match such a format character. Scanning also stops when an input conversion cannot be made</p>
</blockquote>

<p><a href=""http://www.linuxmanpages.com/man3/scanf.3.php"" rel=""nofollow"">http://www.linuxmanpages.com/man3/scanf.3.php</a></p>
",0
19795561,19795505,3,"<p>The compiler doesn't necessarily handle this automatically. In C, this is handled in console output via <strong>format specifiers.</strong></p>

<pre><code>printf(""This is a char:%c\n"", 'c');
printf(""This is an int:%d\n"", 3);
</code></pre>

<p>If you provide the wrong data type as the argument corresponding to the format specifier in your format string, you will get compiler warnings:</p>

<pre><code>printf(""This is a char:%c\n"", 1); // WARNING: Implicit conversion from (int) to (char) (due to implicit down-cast)
</code></pre>

<p>You may not get such a compiler warning depending on the verbosity level if you provide an argument that is smaller than what was expected, ie:</p>

<pre><code>printf(""This is an int:%d\n"", 'b'); // Implicit up-cast
</code></pre>

<p>So, in short, the format specifier lets the compiler know how to represent the data when it comes to printing it to the console, and will also do type-checking between the format specifiers and the corresponding arguments if there is a mismatch.</p>

<p>Finally, if your compiler is C99 compliant, printf will convert an integer to its character-literal equivalent if you have a type-mismatch:</p>

<pre><code>printf(""This is a char:%c\n"", 99); // Prints the 'c' character literal
</code></pre>

<p>You can find the character/number mappings here:</p>

<p><a href=""http://www.asciitable.com/"" rel=""nofollow"">http://www.asciitable.com/</a></p>
",1
19795593,19795505,1,"<p>you give format to <code>printf()</code></p>

<p>if you use:</p>

<pre><code>char c = 'c';
printf(""%c \n"", c); //result is the character 'c'.
printf(""%d \n"", c); //result is 99, the ASCII value of character 'c'.
</code></pre>

<p>but note never to use format %d for char in scanf, this may destroy your stack. </p>

<pre><code>scanf(""%d \n"", &amp;c); //NEVER do this.
</code></pre>
",2
19795596,19795505,2,"<p><strong>According</strong> to ""<a href=""http://en.wikipedia.org/wiki/The_C_Programming_Language"" rel=""nofollow"">The C Programming Language</a>"", 2nd Edition,<br>
<em>Section A4.2</em> ""Meaning of Identifiers"" : ""Basic Types"", Page 195</p>

<blockquote>
  <p>Objects declared as characters (<code>char</code>) are large enough to store any member of the execution character set. If a genuine character from that set is stored in a <code>char</code> object, its value is equivalent to the integer code for the character, and is non-negative.</p>
</blockquote>

<p>and therefore, the following works (if the <a href=""http://en.wikipedia.org/wiki/Category%3aCharacter_sets"" rel=""nofollow"">character set</a> is <a href=""http://en.wikipedia.org/wiki/ASCII"" rel=""nofollow"">ASCII</a>, i.e. The following example is for <a href=""http://en.wikipedia.org/wiki/ASCII"" rel=""nofollow"">ASCII</a>)</p>

<pre><code>int n = 65; //is equal to 'A' in ASCII
char c = 'A'; //is equal to 65 in ASCII
printf(""%c %d"", n, c); //should print ""A 65"" despite the ""wrong"" order
</code></pre>

<p><strong>According</strong> to Page 244, ""Standard Library"", ""Formatted Output"", ""<code>printf</code> functions""<br>
For the '%c' format specifier, printf does the following: convert <code>int</code> to <code>unsigned char</code></p>

<blockquote>
  <p><code>int</code>; single character, after conversion to <code>unsigned char</code>.</p>
</blockquote>
",2
20404438,20404360,3,"<p>The type cannot be ""fetched from it's declaration"". There is nothing magical about <code>scanf()</code>, it's just a function. A function in C cannot access meta information about variables.</p>

<p>This is why, in general, function arguments are declared including their type. For variable-argument functions such as <code>scanf()</code>, the first argument is not optional and it is used to describe the number and type of the other arguments in some fashion chosen by the function itself.</p>
",0
20404441,20404360,2,"<p>You clearly need to read some book on C programming to get better understanding of the core concepts. Unlike some other languages, C doesn't have I/O mechanism baked into the language. <code>scanf()</code> is just a library function and as such, this function has no way to automagically know the type of the variable it is supposed to fill.</p>
",0
20404776,20404360,2,"<p>You know that variables in C can be of different types: </p>

<ul>
<li>int: Integer</li>
<li>char: Character</li>
<li>float: Floating point number.</li>
<li>...</li>
</ul>

<p>Unlike other languages, variable types cannot be implicitly inferred at compilation time in C. That is why you always declare the type of your variables ( Example: int a or char c).</p>

<p>Because scanf is just a function in C, and because functions in C should take parameters of a specific type, people who coded C decided to use the following format:</p>

<pre><code>     scanf(""%d"", &amp;var) ; // for integers
     scanf(""%c"", &amp;var); //for chars
     scanf(""%f"", &amp;var); //for double and floats.
</code></pre>

<p>using %d or %c does not waste memory or whatsoever. you can think about it as a flag that specifies the type of the input variable.</p>

<p>Could the developers of C do it without %d, %c...etc? Yes they could, but then, they have to handle all possible exceptions that might arise from sending the wrong type.</p>

<p>Suppose the developers of C used just the following format</p>

<pre><code>    scanf(&amp;var);
</code></pre>

<p>That is surly very concise, but then you will have to use the same syntax to send chars/int/double...etc, and then the function scanf has to figure out a way to decide about the type of the variable that was sent. Remember what I told you before? variable types CANNOT be implicitly inferred at compilation time, and thus, this task will be almost impossible.</p>

<p>They could however use a different scanf function for every type. For example:</p>

<pre><code>    scanfInt(&amp;var);     //for integers.
    scanfFloat(&amp;var);   //for floats.
    ...
    ...
</code></pre>

<p>That would work perfectly, but it makes less sense to replicate the same code of scanf and use different functions just because the type is different.</p>

<p>So what is the solution? ==> Use the same function name ( scanf ), and then add a parameter (%d, %f, %c..) that will be used internally as a flag by C to know the parameter type.</p>

<p>I hope now you have a better understanding of the use of %d, %f....</p>
",0
20404498,20404360,2,"<p>Because <code>%d</code> will simply specify what the type of <code>var</code> is, there is no memory wastage. <code>scanf(&amp;var)</code> would not work because the function is not designed to accept arguments that way.</p>
",0
20405919,20404360,2,"<p>There are two major points you are missing here. </p>

<p>First, we humans sitting at the keyboard will write something like:</p>

<pre><code>char var = '0';
</code></pre>

<p>And we know that the ""type"" of this variable is <code>char</code> and we probably intend to store a character there. Once the compiler gets a hold of this it removes these ""human"" elements all that is left is at some memory location there is 1 byte reserved, further references to places in the code where we wrote ""var"" will interact with this memory location. That is all the compiler knows, there is no understanding of the intended variable ""type"".</p>

<p>Second, the format specificers do so much more than just indicate a simple type. Look at any page explaining <a href=""http://linux.die.net/man/3/scanf"" rel=""nofollow""><code>scanf()</code></a> and you'll see a long list, take special note of things like scan sets, negated scan sets, and expected input lengths. </p>

<p>Let's say I want the user to enter just a single digit, 0-9, well I don't have to just <em>assume</em> they will do as I ask, I can help ensure they will by using the format specifiers in scanf():</p>

<pre><code>int var = 0;
print(""enter 1 digit (0-9):\n"");
scanf(""%1d"", &amp;var);
</code></pre>

<p>Now, no matter how many digits they enter, I'll only have stored the first one. </p>

<p>What if you have a string that you want to read from the user, and you want to read everything up until you hit a new line character (read over spaces). We'll there are a number of options for this, but scanf can do it too. The ""standard"" to read a string is:</p>

<pre><code>scanf(""%s"",some_string);
</code></pre>

<p>But that will stop at any whitespace character, so you wouldn't want <code>scanf()</code> to make an assumption in this case, you'd want to be able to use a specific negated scanset:</p>

<pre><code>scanf(""%[^\n]"",some_string);
</code></pre>
",0
19975246,19975163,3,"<p>Then fun thing is, the picture most likely already is in binary.</p>

<p>As for the sending, it's no difference than any other socket communication. On the server you read X bytes from the file, and send X bytes to the client. On the client you read X bytes from the server, and write X bytes to a file (or buffer if you want the data in memory only).</p>
",1
19888654,19888629,3,"<p>Assuming that <code>argv</code> is the same as what is passed to <code>main</code>, your function declaration is incorrect: it needs to be</p>

<pre><code>void function(char *argv[]) {
    ... //              ¡ü¡ü
}
</code></pre>

<p>Now you can treat <code>argv</code> as an array of arrays of characters, with two subscript operators.</p>

<p>Of course since you are not using any part of <code>argv</code> beyond the first character of the first parameter, you might as well accept a single <code>char</code>, and let the caller decide which `char it's going to be:</p>

<pre><code>void function(char x) {
    ...
}
...
int main(int argc, char *argv[]) {
    ... // Check argc...
    function(argv[1][0]);
}
</code></pre>
",2
16448040,16448019,3,"<p>Sure, use some kind of terminal control library to disable character echo and then print whatever you like.  Possibilities:</p>

<ul>
<li><a href=""http://en.wikipedia.org/wiki/POSIX_terminal_interface"" rel=""nofollow"">termio</a></li>
<li><a href=""http://en.wikipedia.org/wiki/Curses_%28programming_library%29"" rel=""nofollow"">curses</a></li>
<li><a href=""http://en.wikipedia.org/wiki/Ncurses"" rel=""nofollow"">ncurses</a></li>
</ul>
",2
16448078,16448019,4,"<p>Assuming POSIX:</p>

<pre><code>struct termios t;
tcgetattr(STDIN_FILENO, &amp;t);
t.c_lflag &amp;= ~ECHO;
tcsetattr(STDIN_FILENO, TCSAFLUSH, &amp;t);
</code></pre>

<p>Then no user input will be echoed. Set back the <code>ECHO</code> flag if you want to undo this.</p>
",0
16448105,16448019,1,"<p>You didn't say which platform or compiler, but see <a href=""https://stackoverflow.com/questions/558009/ansi-c-no-echo-keyboard-input"">ANSI C No-echo keyboard input</a>.  Maybe getch() or kbhit() or getpass(), depending on environment.</p>
",0
20103459,20103303,1,"<pre><code>int8u nibble1 = 0xF;
int8u nibble2 = 0x1;
int8u nibble3 = 0x3;
int16u combined;

combined = (nibble1 &lt;&lt; 8) | (nibble2) | (nibble3 &lt;&lt; 4);
</code></pre>
",8
20185780,20185529,1,"<p>This question is I think too broad, though I am trying to give you an idea, what you need and what your approach should be.
<p>You need two endpoints one on your iPhone and the other in your led device. In the led device you need a program running on a micro-controller which will receive and send packets via wifi adapter and will be able to process those packets accordingly.<p>
On the other end the iOS app would create a socket (or some other communication endpoint) and send some packet using some protocal e.g. TCP.
<p> You may get a general tutorial on socket <a href=""http://www.raywenderlich.com/3932/how-to-create-a-socket-based-iphone-app-and-server"" rel=""nofollow"">here</a>. But keep in mind that this tutorial uses iPhone as client, but in your case it will be a server.</p>
",0
20652851,20652595,4,"<p>You cannot do that without some ""pain"", since C is statically typed language. The compiler needs to know the types of variables in order to generate the proper instructions. Most CPU:s have distinct instructions for adding 8-bit integers, 32-bit integers, floats, and so on.</p>

<p>That said, you can certainly improve on the interface: I would use variable arguments to make the prototype:</p>

<pre><code>typedef enum {
  TYPE_BIT = 0,
  TYPE_CHAR,
  TYPE_UNSIGNED_CHAR,
  TYPE_INT,
  TYPE_UNSIGNED_INT,
  TYPE_SHORT_INT,
  TYPE_UNSIGNED_SHORT_INT,
  TYPE_LONG,
  TYPE_UNSIGNED_LONG,
  TYPE_FLOAT,
} Type;

void addition(Type type, void *result, ...);
</code></pre>

<p>This expects to be called with four arguments, the two latter of which should have the type indicated by the <code>type</code> argument. The result is stored at <code>result</code>, which should be a pointer to the same type as the arguments.</p>

<p>Not sure how to represent single-bit values, probably as <code>unsigned char</code> but it's kind of pointless: single bits is not a type that you can do arithmetic with in C so you're just going to end up doing the add with more bits, then masking some of them off. You also can't have a pointer to a single bit in memory on most machines.</p>
",0
20653749,20652595,0,"<p>The idiomatic C approach to this problem is to use macros to eliminate code duplication as much as possible. The rest will unfortunately have to be done manually. For example:</p>

<pre><code>enum typecode {
  TC_INT = 3,
  TC_FLOAT = 9,
  /* ... */
};

void addition(enum typecode type_data_1_uc, void *value_data_1_ptr, 
              enum typecode type_data_2_uc, void *value_data_2_ptr, 
              enum typecode type_result_uc, void *value_result_ptr)
{
#define DO_ADD(tc1, tc2, tcret, type1, type2, typeret) do {        \
  if (type_data_1_uc == tc1 &amp;&amp; type_data_2_uc == tc2               \
      &amp;&amp; type_result_uc == tcret) {                                \
    *(typeret *)value_result_ptr =                                 \
       *(type1 *)(value_data_1_ptr) + *(type2 *)(value_data_2_ptr) \
    return;                                                        \
  } while (0)

  /* INT + INT = INT */
  DO_ADD(TC_INT, TC_INT, TC_INT, int, int, int);
  /* FLOAT + FLOAT = FLOAT */
  DO_ADD(TC_FLOAT, TC_FLOAT, TC_FLOAT, float, float, float);
  /* UCHAR + INT = INT */
  DO_ADD(TC_UCHAR, TC_INT, TC_INT, unsigned char, int, int);
  /* ... */

#undef DO_ADD

  /* none matched: abort() or set an error code, as appropriate */
}
</code></pre>
",2
20201496,20201478,3,"<p>This is because compound statement   </p>

<pre><code>{
    printf(""You are old enough to vote.\n"");
}  
</code></pre>

<p>never get executed.  Remove <code>return 0;</code> after <code>if</code> statement.  </p>

<pre><code>if(age &gt;= ageToVote)
{
    printf(""You are old enough to vote.\n"");
}
</code></pre>
",3
20201520,20201478,1,"<p>Correct code:</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{ 
    int age = 18;
    int ageToVote = 18;

    if(age &gt;= ageToVote)
    {
        printf(""You are old enough to vote.\n"");
    }

    return 0;
}
</code></pre>
",0
20201525,20201478,0,"<p>That amounts to:</p>

<pre><code>if(18 &gt;= 18)
    return 0;
</code></pre>

<p>Of <em>course</em> <code>18 &gt;= 18</code>, so of <em>course</em> it returns immediately.</p>

<blockquote>
  <p>I have been told that the above code should give me the output of: You are old enough to vote.</p>
</blockquote>

<p>Whoever told you that was incorrect. The <code>return</code> keyword causes the function to exit immediately.</p>
",0
20201528,20201478,0,"<p>return 0; must be the last statement in your method.</p>

<p>If you put return 0; after IF and before {} you'execute that and so you'll ignore the remains statement.</p>
",0
20196177,20196141,7,"<p>Your <code>change</code> function is wrong:</p>

<pre><code>void change(char* a, char* b)
{
    char temp = *a;
    *a = *b;
    *b = temp;
}
</code></pre>

<p>First make a temporary variable - copy it in a temp variable, then swap the value. This line is UB:</p>

<pre><code>*a = b;
*b = a;
</code></pre>

<p>You are trying to store a pointer's value in a char.</p>
",2
20196213,20196141,0,"<p>Yes, your first assignment overwrites the value that is needed in the second one.</p>

<p>The solution is to use some temporary storage to hold the one of the variable values during the swap:</p>

<pre><code>void change(char *a, char *b)
{
  const char old_a = *a;
  *a = *b;
  *b = old_a;
}
</code></pre>

<p>There is also a trick you can do to go around this (using bitwise XOR), but it's scary so ignore it at this point.</p>
",0
19214874,19213906,0,"<p>Are you missing a <code>printf</code> to see what your intermediate results are?  That might help you get an idea as to what is going on internally.</p>

<p>But I don't really understand what you're trying to solve.  Do you want the result: <code>2*3*4*5*6*7*8*9*10*11*12*13*14*15*16*17*18*19*20</code>?</p>

<p>Because I think that's what you are currently computing.  However, you'll overflow before you get there and iterating to that point will take you a while.</p>

<p>If instead you're trying to find the smallest number that is divisible by every number less than or equal to 20, then you may want to revisit your update of <code>num /= j</code>.</p>
",0
18939777,18939757,2,"<p>The line <code>message ( message ());</code> calls <code>message()</code> and then passes its return value to another call to <code>message()</code>. This will not work, since, as the error message states, you can't pass a <code>void</code> result to another function (since it isn't actually a result at all). Stop what you are doing, and think about what you actually want the code to do.</p>
",1
18939781,18939757,0,"<p><code>message</code> doesn't return a value. You can't use it in an expression like:</p>

<pre><code>message ( message ());
</code></pre>
",0
18939932,18939757,-1,"<p>In addition, you define the function ""void message()"" cannot accept any parameter. </p>
",2
18940251,18939757,0,"<p>The line    <code>message ( message ())</code>   is wrong. Because you defined the    <code>message()</code>   as a void function, so you can<code>t pass any parameters to message().</code> And for a void function you should ended it by line of return. So I think you program should be :  </p>

<pre><code>#include&lt;stdio.h&gt;
    void  message() ;
    int main()
    {
        message ();
        return 0;
    }
    void message()
    {
        printf(""it is small"");
        return;
    }
</code></pre>
",0
20417074,20416972,3,"<p>When called as <code>fun(9)</code>, the code shown does print <code>**3**39</code>.</p>

<ul>
<li>The first call has <code>n == 9</code>.</li>
<li>Consequently, if calls <code>fun(3)</code>, then <code>fun(3)</code> again, and then prints <code>9</code>.</li>
<li>The first of the two calls <code>fun(3)</code> calls <code>fun(1)</code>, which prints a <code>*</code>, then calls <code>fun(1)</code> again and prints another <code>*</code>, and then prints <code>3</code>.</li>
<li>The second of the two calls does the same.</li>
</ul>
",0
20417108,20416972,2,"<p>Your output should be 
* * 3 * * 3 9</p>

<p><img src=""https://i.stack.imgur.com/iSPBx.jpg"" alt=""recursion""></p>
",0
20417295,20416972,1,"<p>If you can't see how it works, then do it by hand and fill in the values instead of the variable name:</p>

<p>Pass 1:</p>

<pre><code>void fun(9){             // first pass n=9
  if(9&lt;=1) printf(""*"");  // nope, that's not true
  else{
    fun(9/3);            // call the function again with n = 9/3 = 3
</code></pre>

<p>Pass 2:</p>

<pre><code>void fun(3){             // second pass n=3
  if(3&lt;=1) printf(""*"");  // nope, that's not true
  else{
    fun(3/3);            // call the function again with n = 3/3 = 1
</code></pre>

<p>Pass 3:</p>

<pre><code>void fun(1){             // third pass n=1
  if(1&lt;=1) printf(""*"");  // yes! so print first *
  else{                  // this function is only an if and an else, we hit the if
                         // so it just drops out now
</code></pre>

<p>So pass #3 and we hit the lowest level of the recursive call, now Pass 2 will continue execution where it left off:</p>

<p>Pass 2b:</p>

<pre><code>void fun(3){             // second pass n=3       (did this already)
  if(3&lt;=1) printf(""*"");  // nope, that's not true (did this already)
  else{
    fun(3/3);            // call the function with n = 1 (did this already)
    fun(3/3);            // next recursive call, again with n = 1
</code></pre>

<p>Now this will repeat the ""pass #3"" code, again printing a second *, then it will return and continue execution where it left off:</p>

<p>Pass 2c:</p>

<pre><code>void fun(3){             // second pass n=3       (did this already)
  if(3&lt;=1) printf(""*"");  // nope, that's not true (did this already)
  else{
    fun(3/3);            // call the function with n = 1 (did this already)
    fun(3/3);            // call again with n = 1 (did this already)
    printf(""%d"", 3);     // print 3
</code></pre>

<p>At this point the output is: <code>**3</code> Pass #2 is now complete so we go all the way back up and resume Pass #1 where it left off:</p>

<p>Pass 1b:</p>

<pre><code>void fun(9){             // first pass n=9        (did this already)
  if(9&lt;=1) printf(""*"");  // nope, that's not true (did this already)
  else{
    fun(9/3);            // call the function again with n = 3 (did this already)
    fun(9/3);            // now call the function again with n = 9/3 = 3
</code></pre>

<p>From here you can see that we're going to repeat the Pass 2 logic producing another <code>**3</code> then we'll return to Pass1 a final time to print the <code>9</code></p>

<p>A final output of: <code>**3**39</code></p>
",0
20512088,20512022,0,"<p>I believe it is CRC-32 (based on documentation), you can use the following Stack Overflow thread to see how to calculate CRC-32 in <code>C</code>: <a href=""https://stackoverflow.com/questions/2587766/how-is-a-crc32-checksum-calculated"">How is a CRC32 checksum calculated?</a></p>
",2
20756839,20512022,1,"<p>ADLER-32 checksum is the algorithm used for calculating CRC in PQDIF files.
The code is available at wikipedia.</p>
",0
20514489,20514430,1,"<p>That code is undefined, there is no answer since you don't specify the value of <code>n</code> and as the code is written there's no chance for <code>n</code> to <em>have</em> a well-defined value when the loop runs.</p>
",1
20514495,20514430,1,"<p><code>n</code> is never initialised, so technically the behaviour is <em>undefined</em> as you're using an uninitialised variable in <code>while (j&lt;=n)</code>.</p>

<p>If you want to set <code>n</code> to the largest possible integer value, use</p>

<p><code>n = INT_MAX</code></p>

<p>Which is defined in the standard include file <code>&lt;limits.h&gt;</code></p>

<p><strong>But</strong>, that will result in integer overflow due to <code>j=j*2</code> happening after the <code>j&lt;=n</code> check. One way round this would be to define <code>n = INT_MAX / 2</code>. Better still use a <code>do / while</code> loop rather than <code>while</code> and perform the check at the end.</p>
",2
20514532,20514430,-1,"<p>yes code will end you are not initializing <code>n</code>. First initialize it then calculte</p>
",0
20515466,20514430,0,"<p>Assuming that you initialized the variable <code>n</code> with a proper value, as you know you are going to <code>pow(2,i)&lt;=n</code> which means <code>i&lt;=log{2}n</code> (just inverting the function).
<code>log{base 2}n = log n/log2</code> for the well known logarithmic property. 
Now the calculation is exact when <code>i</code> is real but in this case <code>i</code> is an integer you won't get exactly that number so the correct index will be in the approximation of <code>[floor(logn/log2);floor(logn/log2)+1]</code> which will be the loop required for for <code>pow(2,i)&lt;=n&lt;pow(2,i+1)</code></p>

<p>Let's do a simple example:</p>

<pre><code>n=11; ln(n)/ln(2)=2.39/0.69=3.46
floor(3.46) = 3
floor(3.46)+1 = 4
i=1 i&lt;=n: true: i*=2
i=2 i&lt;=n: true: i*=2
i=4 i&lt;=n: true: i*=2
i=8 i&lt;=n: true: i*=2
i=16 i&lt;=n: false=&gt; don't loop
</code></pre>

<p>which is exactly <code>four</code></p>
",1
20521204,20521168,0,"<p>You can't write </p>

<pre><code>a*1.8-32=a;
</code></pre>

<p>in C. the compiler tells you that the ""lvalue"" (left value) of an assignment needs to be actually assignable.</p>

<p>What you probably meant is</p>

<pre><code>a = a * 1.8 - 32;
</code></pre>
",0
20641317,20641064,1,"<p>You cannot do without checking EOF. Otherwise it will wait for another input. Suppose you want to take input while there is a file containing input. So easiest way is the first one, checking that if you are in the 'End of File'. Now, what <code>scanf</code> returns. It will return the input it has taken successfully. If it can scan one integer like <code>scanf(""%d"",&amp;a)</code>, it will return 1. <code>scanf(""%d%d%d%d%d%d"",&amp;a,&amp;a,&amp;a,&amp;a,&amp;a,&amp;a)</code> this will return 6. So by <code>==</code> you are checking if it is taking correct amount of input every time. So if the amount is not correct you can exit or break like <code>if(scanf(""%d"",&amp;a)!=1) break</code>.</p>

<p>Your <code>while(scanf(""%d"",&amp;a) == 2)</code> is wrong, it should be <code>while(scanf(""%d"",&amp;a) == 1)</code></p>

<p><code>while(scanf(""%d"",&amp;a)+1)</code> is it Ok? I don't think so... <code>while(scanf(""%d"",&amp;a)-1)</code> may be ok.</p>

<p>Hope this is clear.</p>
",0
20641318,20641064,2,"<p>The best way is non of them.</p>

<p>The last is wrong as it assumes <code>EOF</code> is -1, which is not necessarily true. The second is wrong because <code>scanf</code> can never return <code>2</code> with that format string. The first one has a shot, but is not that good either.</p>

<p>If you loop <code>while(scanf(""%d"",&amp;a) != EOF)</code>, then the loop terminates at end of file (or file-read errors). However, if for non-file-error reasons <code>scanf</code> fails, you do not detect it. One such error is meeting input that is not convertible by <code>%d</code>, such as a letter in the alphabet.</p>

<p><code>scanf</code> returns the number of items it successfully reads. In other words, if you have <code>N</code> of <code>%...</code>s (excluding <code>%*...</code>s), then <code>scanf</code> should return <code>N</code>, otherwise there's an error. This error could be bad input, file read error or end of file.</p>

<p>So the safest way of checking if <code>scanf</code> succeeded is checking if it could read as many items as you asked it to.  In your case, this is:</p>

<pre><code>while (scanf(""%d"",&amp;a) == 1)
</code></pre>
",0
20644737,20641064,0,"<p><code>scanf()</code> will return 0 (bad input),1 (good), or EOF (no more input).  Handle accordingly.</p>

<pre><code>int result;
while ((result = scanf(""%d"",&amp;a)) == 1) {
  Handle_int(a);
}
if (result == 0) {
  Handle_BadData();  // Maybe someone typed non-numeric text
}
else if (result == EOF) {
  Handle_EOForIOError();
}
else {
  ; // This should never happen -else condition not needed
}
</code></pre>

<p>Do not assume <code>EOF</code> is -1, but it is negative.</p>
",0
19447253,19447150,1,"<p>It stops where it encounters where you give space in input. </p>

<p><em>So if you entered 
Hello World scanf will display ascii values of characters in Hello only</em>.</p>

<p><strong>Solution:</strong> use <code>fgets</code></p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

int main()
{

char str[100];
int i=0;

printf(""Enter any string: "");
fgets(str, sizeof(str), stdin);

printf(""ASCII values of each characters of given string: "");
while(str[i])
     printf(""%d "",str[i++]);


return 0;
}
</code></pre>
",2
19447294,19447150,1,"<p>First; indent your code correctly (on Linux you could use the <a href=""http://www.gnu.org/software/indent/"" rel=""nofollow"">GNU indent</a> utility, or <a href=""http://astyle.sourceforge.net/"" rel=""nofollow"">astyle</a>).</p>

<p>Compile it with all warnings and debugging info (e.g. <code>gcc -Wall -g</code>). Learn how to use the debugger (<code>gdb</code>) to run it step by step.</p>

<p>Then, your <code>scanf(""%s"", str);</code> is dangerous (should at least be <code>scanf(""%99s"", str);</code>, see <a href=""http://man7.org/linux/man-pages/man3/scanf.3.html"" rel=""nofollow"">scanf(3)</a>) ! You could get crashes or <a href=""http://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow"">undefined behavior</a> if the user enters a very long ""word"" of 200 characters (e.g. 200 times the digit <code>0</code>). Alos notice that <code>%s</code> reads up to a space or blank-like character. I believe it is good habit to zero a buffer before reading it. So replace your <code>scanf</code> with </p>

<pre><code> memset (str, 0, sizeof(str));
 fgets (str, sizeof(str), stdin);
</code></pre>

<p>At last, you are not flushing the <a href=""http://en.wikipedia.org/wiki/Buffer_%28computer_science%29"" rel=""nofollow"">buffered</a> <code>stdout</code> output (see <a href=""http://man7.org/linux/man-pages/man3/stdio.3.html"" rel=""nofollow"">stdio(3)</a>, <a href=""http://man7.org/linux/man-pages/man3/setvbuf.3.html"" rel=""nofollow"">setvbuf(3)</a>, <a href=""http://man7.org/linux/man-pages/man3/fflush.3.html"" rel=""nofollow"">fflush(3)</a>, etc...). Try perhaps</p>

<pre><code>while(str[i])
  printf(""%d "",str[i++]);
putchar('\n');
fflush(stdout);
</code></pre>

<p>The last call to <code>fflush</code> is useless here, but it is a good habit (or else end <em>every</em> <code>printf</code> format string with a newline <code>\n</code> since <em><code>stdout</code></em> is often but not always line-buffered!)</p>
",3
19447297,19447150,0,"<p><code>scanf</code> stops reading if there is a space in the input string. You can either uses fgets or do the follwing:</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

int main()
{

   char str[100];
   int i=0;

   printf(""Enter any string: "");
   str[i] = getchar();

   while(str[i]!='\n'){
        str[i+1] = getchar();
        i++;
   } 

   str[i] = '\0';
   printf(""%s\n"",str);

   i=0;
   printf(""ASCII values of each characters of given string: "");

   while(str[i]!='\0'){
        printf(""%d "",str[i++]);
   }

   return 0;
}
</code></pre>

<p><strong>EDIT:</strong></p>

<p>To find average of the string a asked by you in comments:</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

int main()
{

     char str[100];

   int sum=0;
   int average=0;
       int i=0;

    printf(""Enter any string: "");
    str[i] = getchar();

    while(str[i]!='\n'){
        str[i+1] = getchar();
         i++;
    } 

    str[i] = '\0';
    printf(""%s\n"",str);

    i=0;
    printf(""ASCII values of each characters of given string: "");

    while(str[i]!='\0'){
       sum = sum + str[i];
       printf(""%d "",str[i++]);
    }

// To calculate average

   average = sum/(i-1);

   printf(""\nAverage = %d\n"",average);

       return 0;
}
</code></pre>
",5
19798318,19798199,0,"<p>The error message you provided is:</p>

<pre><code>USB4_FIFOBufferRector extern int _stidcall USB4_ReadFIFOBufferStrut(short iDeviceNo, long *plSize, USB$_FIFOBufferRecord *pCBR, unsigned long ulReadTimeout);
</code></pre>

<p>I believe this line has multiple typos.  This could be sloppy typing, or it could be the source of your errors:</p>

<ul>
<li>USB4_FIFOBufferRector  (USB4_FIFOBufferRecord??)</li>
<li>_stidcall (_stdcall??)</li>
<li>USB$_FIFOBufferRecord (USB4_FIFOBufferRecord??)</li>
<li>USB4_ReadFIFOBufferStrut (USB4_ReadFIFOBufferStruct??)</li>
</ul>
",0
19798977,19798199,0,"<p><em><strong>Not the first time a vendor's header file had some minor errors,...</em></strong></p>

<p>The error message:  </p>

<p>*<strong>...\USB4.h:222:79: error:unknown type name 'USB4_FIFOBufferRector' extern int _stidcall USB4_ReadFIFOBufferStrut(short iDeviceNo, long *plSize, USB$_FIFOBufferRecord <em>pCBR, unsigned long ulReadTimeout);</em></strong>  </p>

<p>Line 222, column 79 occurs at a reference to the struct <code>USB4_FIFOBufferRecord</code>, defined on line 149 of the same file as:    </p>

<pre><code>struct USB4_FIFOBufferRecord
{
    unsigned char Header[6];
    unsigned char Input;
    unsigned char EStop;
    unsigned long Time;
    unsigned long Count[4];
    unsigned char Status[4];
    unsigned short ADC[4];
};    
</code></pre>

<p><em><strong>The problem is</em></strong> that this struct is defined, but the stuct keyword is not included in the prototype on line 222.</p>

<p><em><strong>To fix it</em></strong>, In the line:  </p>

<pre><code>extern int _stdcall USB4_ReadFIFOBufferStruct(short iDeviceNo, long *plSize, USB4_FIFOBufferRecord *pCBR, unsigned long ulReadTimeout);   
</code></pre>

<p>try inserting the keyword word <code>struct</code> in front of <code>USB4_FIFOBufferRecord</code>.  Like this:  </p>

<pre><code>extern int _stdcall USB4_ReadFIFOBufferStruct(short iDeviceNo, long *plSize, struct USB4_FIFOBufferRecord *pCBR, unsigned long ulReadTimeout);   
</code></pre>

<p><em><strong>OR</em></strong>  </p>

<p>On line 149, modify the struct definition.  try this instead:  </p>

<pre><code>typedef struct
    {
        unsigned char Header[6];
        unsigned char Input;
        unsigned char EStop;
        unsigned long Time;
        unsigned long Count[4];
        unsigned char Status[4];
        unsigned short ADC[4];
    } USB4_FIFOBufferRecord;    
</code></pre>

<p>That will cause  USB4_FIFOBufferRecord to be a new variable of type ""struct  USB4_FIFOBufferRecord"".  With that, you can just leave the prototype the way it is.    </p>

<p><em><strong>Either will work</em></strong>, (Your choice.)</p>
",0
19799026,19798199,0,"<p>USB4_FIFOBufferRecord is declared on line 149 as <code>struct USB4_FIFOBufferRecord{...};</code>. In C, if a parameters type is a struct, then that parameter must have the <code>struct</code> keyword before the type declaration.  So, on line 222, you need to declare the <code>USB4_FIFOBufferRecord *pCBR</code> as <code>struct USB4_FIFOBufferRecord *pCBR</code>.</p>

<p>So, the line needs to be</p>

<pre><code>extern int _stdcall USB4_ReadFIFOBufferStruct(short iDeviceNo, long *plSize, struct USB4_FIFOBufferRecord *pCBR, unsigned long ulReadTimeout);
</code></pre>
",0
20640723,20640689,1,"<p>It sounds like you're using C1, C2, C3, C4 as ""new"" values, and C1_0, C2_0, C3_0, C4_0 as ""previous iteration"" values. In that case, you can just use the following:</p>

<pre><code>for (x=start; x&lt;=end; x+=h){
    C1_0 = C1;
    C2_0 = C2;
    C3_0 = C3;
    C4_0 = C4;
    C1 = C1_0 + h * F1(C2_0);
    C2 = C2_0 + h * F2(C1_0,C3_0);
    C3 = C3_0 + h * F3(C4_0);
    C4 = C4_0 + h * F4(C1_0,C3_0);
}
</code></pre>
",0
19568826,19568631,1,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include &lt;dos.h&gt;

void main()
{
    int wait = 10000;

    clrscr();
    printf(""Press Any Key or Wait for 10 Seconds to Continue\n"");

    while(!kbhit() &amp;&amp; wait &gt; 0)
    {
        delay(100);
        wait -= 100;
    }
}
</code></pre>
",4
19881860,19881809,0,"<ol>
<li><code>contestants</code> is an array of type integers which contains values <code>{1, 2, 3}</code>. </li>
<li><code>choice</code> is a pointer of type <code>int</code> pointing to valid memory location of <code>contestants</code>.</li>
<li>Each element in array <code>contestants</code> are accessed as <code>contestants[i]</code>, where <code>i</code> is index of array starting from <code>0</code>. <code>contestants[0] = 2;</code> is what assigning value <code>2</code> to index location <code>0</code>.   </li>
<li><code>contestants[2] = *choice;</code> - choice is a pointer, <code>*choice</code> is called dereferencing pointer to get the value pointing by pointer <code>choice</code> which is <code>2</code>. </li>
</ol>

<p>Typical memory layout is as follows,</p>

<pre><code>              contestants[] 
choice           0      1     2 
+-----+       +-------------------+
|0x100|------&gt;|  1   |  2   |  3  |              
|     |       |      |      |     |
+-----+       +-------------------+
            0x100  0x104  0x108  
</code></pre>
",0
19881902,19881809,2,"<pre><code>int contestants[] = {1, 2, 3};
</code></pre>

<p><code>contestants</code> is an array of integrs, indexed starting at <code>0</code>, with values <code>contestants[0] == 1</code>, <code>contestants[1] == 2</code> and <code>`contestants[2] = 3</code>.</p>

<pre><code>int *choice = contestants;
</code></pre>

<p><code>choice</code> is an integer pointer, assigned here to the address of the <code>contestants</code> array, which is the address of the first element of the <code>contestants</code> array. Therefore, <code>*choice</code> will give you the same result as <code>contestants[0]</code>.</p>

<pre><code>contestants[0] = 2;
</code></pre>

<p>This assigns <code>2</code> to <code>contestants[0]</code>. Now <code>contestants[0] == 2</code> and, therefore, <code>*choice == 2</code>. The <code>contestants</code> array now looks like <code>{2, 2, 3}</code>.</p>

<pre><code>contestants[1] = contestants[2];
</code></pre>

<p>Assigns the value <code>2</code> to <code>contestants[1]</code>. Now the <code>contestants</code> array looks like <code>{2, 3, 3}</code>.</p>

<pre><code>contestants[2] = *choice;
</code></pre>

<p>Assigns <code>*choice</code> which is still the same as <code>contestants[0]</code> to <code>contestants[2]</code>. So the <code>contestants</code> array looks like <code>{2, 3, 2}</code>.</p>

<pre><code>printf(""I'm going to pick contestant number %i\n"", contestants[2]); return 0;
</code></pre>

<p>Prints <code>contestants[2]</code>, which is <code>2</code> as you observed.</p>
",1
19884246,19884214,3,"<p>Your problem is on this line:</p>

<pre><code>scanf(""%i"", entry);
</code></pre>

<p>Which should be: </p>

<pre><code>scanf(""%i"", &amp;entry);
</code></pre>

<p>You need to pass in the address of the integer variable that will store the scanned value.  Since
entry was never initialized, it is just filled with garbage/whatever is in memory and not the entered value.  See this <a href=""http://www.cplusplus.com/reference/cstdio/scanf/"" rel=""nofollow"">reference</a>, which states,</p>

<pre><code>  ""Depending on the format string, the function may expect a sequence of additional arguments,     
  each containing a pointer to allocated storage where the interpretation of the extracted 
  characters is stored with the appropriate type""
</code></pre>
",2
19884256,19884214,0,"<p>You provide a way to leave if the entered number is too big:  </p>

<pre><code>while(i&lt;HIGHEST){  
</code></pre>

<p>But nothing to leave if it is less than 0;  Try this:  </p>

<pre><code>while((i&lt;HIGHEST)&amp;&amp;(i&gt;=0)){  
</code></pre>

<p>Additionally, @OldProgrammer is correct, your <code>scanf()</code> should be as he has pointed out.</p>
",2
20204492,20204062,1,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

int main(void){
    char prose[ ] =
        ""Hope is the thing with white feathers\n""
        ""That perches in the soul.\n""
        ""And sings the tne without the words\n""
        ""And never stops at all."";
    int len, spc;
    char *p = prose;
    for(len=spc=0;*p;++p){
        ++len;
        if(isspace(*p))//if(' ' == *p)
            ++spc;
    }
    printf(""length : %d\t spaces : %d\n"", len, spc);
    //length : 123     spaces : 23
    return 0;
}
</code></pre>
",1
20104843,20104407,0,"<p>You can do this as  </p>

<pre><code>#include&lt;stdio.h&gt;

int main()
{
    char infix[] = ""123+354*87/156="";
    char *p = infix;
    while(1)
    {
        if(*p == '\0')
            break;
        if(*p == '+' || *p == '*' ||*p == '/' ||*p == '=' || *p == '-')
        {
            printf("" "");
        }
        else
            printf(""%c"", *p);
        p++;

    }
    printf(""\n"");
    return 0;
}  
</code></pre>

<p>Output:  </p>

<pre><code>123 354 87 156
</code></pre>
",0
20190620,20190415,0,"<h2>Dynamic Array</h2>
<pre><code>int *Array;
Array= malloc (sizeof(int) * Size);
</code></pre>
",8
20190552,20190415,0,"<p>The original C standard (ANSI 1989/ISO 1990) required that a compiler successfully translate at least one program containing at least one example of a set of environmental limits. One of those limits was being able to create an object of at least 32,767 bytes.</p>

<p>This minimum limit was raised in the 1999 update to the C standard to be at least 65,535 bytes.</p>

<p>No C implementation is required to provide for objects greater than that size, which means that they don't need to allow for an array of ints greater than </p>

<pre><code>(int)(65535 / sizeof(int)).
</code></pre>

<p>In very practical terms, on modern computers, it is not possible to say in advance how large an array can be created. It can depend on things like the amount of physical memory installed in the computer, the amount of virtual memory provided by the OS, the number of other tasks, drivers, and programs already running and how much memory that are using. So your program may be able to use more or less memory running today than it could use yesterday or it will be able to use tomorrow.</p>

<p>Many platforms place their strictest limits on automatic objects, that is those defined inside of a function without the use of the 'static' keyword. On some platforms you can create larger arrays if they are static or by dynamic allocation.</p>
",0
20190582,20190415,4,"<p>The problem is that you are storing the array in global section, C doesn't give any guarantee about the maximum  size of global section it can support, this is a function  of OS, arch compiler.<br>
So instead of creating a global array, create a global C pointer, allocated a large chunk  using malloc. Now memory is saved in the heap which is much bigger and can grow at runtime. </p>
",3
20192322,20190415,1,"<p>Your array will land in <a href=""http://en.wikipedia.org/wiki/.bss"" rel=""nofollow noreferrer"">BSS section</a> for static vars. It will not be part of an image but program loader will allocate required space and fill it with zeros before your program starts 'real' execution. You can even control this process if using embedded compiler and fill your static data with anything you like. This array may occupy 2GB or your RAM and yet your exe file may be few kilobytes. I've just managed to use over 2GB array this way and my exe was 34KB. I can believe a compiler may warn you when you approach maybe 2<sup>31</sup>-1 elements (if your int is 32bit) but static arrays with 2m elements are not a problem nowadays (unless it is embedded system but I bet it is not).</p>
<p>The problem might be that your bubble sort has 2 nested loops (as all bubble sorts) so trying to sort this array - having 2m elements - causes the program to loop <em><strong>2*10<sup>12</sup></strong></em> times (<a href=""http://en.wikipedia.org/wiki/Arithmetic_progression"" rel=""nofollow noreferrer"">arithmetic sequence</a>):</p>
<blockquote>
<p>inner loop:</p>
<p>1: 1999999 times</p>
<p>2: 1999998 times</p>
<p>...</p>
<p>2000000: 1 time</p>
</blockquote>
<p>So you must swap elements</p>
<blockquote>
<p>2000000 * (1999999+1) / 2 = (4 / 2) * 1000000<sup>2</sup> = 2*10<sup>12</sup> times</p>
</blockquote>
<p>(correct me if I am wrong above)</p>
<p>Your program simply remains too long in sort routine and you are not even aware of that. What you see it just last rand number printed and program not responding. Even on my really fast PC with 200K array it took around 1minute to sort it this way.</p>
<p>It is not related to your os, compiler, heaps etc. Your program is just stuck as your loop executes <em><strong>2*10<sup>12</sup></strong></em> times if you have 2m elements.</p>
<p>To verify my words print &quot;sort started&quot; before sorting and &quot;sort finished&quot; after that. I bet the last thing you'll see is &quot;sort started&quot;. In addition you may print current <strong>x</strong> value before your inner loop in bubble_sort - you'll see that it is working.</p>
",2
20521352,20521289,2,"<pre><code>signed char y=-1;
</code></pre>

<p>-1 is generally stored in <code>2's</code> complement form, but <code>y</code> is interpreted as positive. So <code>y</code> becomes a very large value, which is always greater than <code>x</code>.</p>

<hr>

<p>Even if it's stored is sign+magnitude form, It is still a very large value, if treated as positive. And 1's complement complement of -1 is also greater than 1, if interpreted as positive value.</p>
",4
20521354,20521289,3,"<p>The default type for a ""naked"" <code>unsigned</code> is <code>unsigned int</code>.</p>

<p>The comparison works thanks to C's arithmetic promotions, which will convert both arguments to <code>&gt;</code> to a suitable type before doing the comparison.</p>
",1
20521532,20521289,0,"<p>This is related to the storage mechanism of the system. </p>

<p>Please check the following code where the o/p is shown in hex [direct storage format], for sake of simplicity.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
        unsigned int ua = 1;
        signed int sa = -1;
        if (ua&gt;sa)
                printf(""ua&gt;sa\n"");
        else
                printf(""sa&gt;ua\n"");

        printf(""unsigned = 0x%x\t signed = 0x%x\n"", ua, sa);

        return 0;
}
</code></pre>

<p>output:</p>

<pre><code>[sourav@localhost Practice]# ./a.out 
sa&gt;ua
unsigned = 0x1   signed = 0xffffffff
[sourav@localhost Practice]#
</code></pre>

<p>Hope this helps.</p>
",0
12855883,12855825,1,"<p>Nope its just excessive casting.  There is no need to cast it to an int.  It doesn't hurt however.</p>

<p>Edit: Its worth noting that it may be done like that so the type of v can be changed to something else or it may have once been another data type and after it was converted to an int the cast was never removed.</p>
",0
12855955,12855825,0,"<p>It isn't. The Standard does not define the representation of integers, and therefore it's impossible to guarantee exactly what the result of that will be portably. The only way to get the sign of an integer is to do a comparison.</p>
",0
12856068,12855825,1,"<p>It should be quite portable because when you convert <code>int</code> to <code>unsigned int</code> (via a cast), you receive a value that is 2's complement bit representation of the value of the original <code>int</code>, with the most significant bit being the sign bit.</p>

<p><strong>UPDATE</strong>: A more detailed explanation...</p>

<p>I'm assuming there are no padding bits in <code>int</code> and <code>unsigned int</code> and all bits in the two types are utilized to represent integer values. It's a reasonable assumption for the modern hardware. Padding bits are a thing of the past, from where we're still carrying them around in the current and recent C standards for the purpose of backward compatibility (i.e. to be able to run code on old machines).</p>

<p>With that assumption, if <code>int</code> and <code>unsigned int</code> have <code>N</code> bits in them (<code>N</code> = <code>CHAR_BIT * sizeof(int)</code>), then per the C standard we have 3 options to represent <code>int</code>, which is a signed type:</p>

<ol>
<li>sign-and-magnitude representation, allowing values from -(2<sup>N-1</sup>-1) to 2<sup>N-1</sup>-1</li>
<li>one's complement representation, also allowing values from -(2<sup>N-1</sup>-1) to 2<sup>N-1</sup>-1</li>
<li>two's complement representation, allowing values from -2<sup>N-1</sup> to 2<sup>N-1</sup>-1 or, possibly, from -(2<sup>N-1</sup>-1) to 2<sup>N-1</sup>-1</li>
</ol>

<p>The sign-and-magnitude and one's complement representations are also a thing of the past, but let's not throw them out just yet.</p>

<p>When we convert <code>int</code> to <code>unsigned int</code>, the rule is that a non-negative value <code>v</code> (>=0) doesn't change, while a negative value <code>v</code> (&lt;0) changes to the positive value of 2<sup>N</sup>+<code>v</code>, hence <code>(unsigned int)-1</code>=<code>UINT_MAX</code>.</p>

<p>Therefore, <code>(unsigned int)v</code> for a non-negative <code>v</code> will always be in the range from 0 to 2<sup>N-1</sup>-1 and the most significant bit of <code>(unsigned int)v</code> will be 0.</p>

<p>Now, for a negative <code>v</code> in the range from to -2<sup>N-1</sup> to -1 (this range is a superset of the negative ranges for the three possible representations of <code>int</code>), <code>(unsigned int)v</code> will be in the range from  2<sup>N</sup>+(-2<sup>N-1</sup>) to 2<sup>N</sup>+(-1), simplifying which we arrive at the range from 2<sup>N-1</sup> to 2<sup>N</sup>-1. Clearly, the most significant bit of this value will always be 1.</p>

<p>If you look carefully at all this math, you will see that the value of <code>(unsigned)v</code> looks exactly the same in binary as <code>v</code> in 2's complement representation:</p>

<p>...<br>
<code>v</code> = -2: <code>(unsigned)v</code> = 2<sup>N</sup> - 2 = 111...110<sub>2</sub><br>
<code>v</code> = -1: <code>(unsigned)v</code> = 2<sup>N</sup> - 1 = 111...111<sub>2</sub><br>
<code>v</code> =  0: <code>(unsigned)v</code> =                 0 = 000...000<sub>2</sub><br>
<code>v</code> =  1: <code>(unsigned)v</code> =                 1 = 000...001<sub>2</sub><br>
...</p>

<p>So, there, the most significant bit of the value <code>(unsigned)v</code> is going to be 0 for <code>v</code>>=0 and 1 for <code>v</code>&lt;0.</p>

<p>Now, let's get back to the sign-and-magnitude and one's complement representations. These two representations may allow two zeroes, a <code>+0</code> and a <code>-0</code>. But arithmetic computations do not visibly distinguish between <code>+0</code> and <code>-0</code>, it's still a <code>0</code>, whether you add it, subtract it, multiply it or compare it. You, as an observer, normally wouldn't see <code>+0</code> or <code>-0</code> or any difference from having one or the other.</p>

<p>Trying to observe and distinguish <code>+0</code> and <code>-0</code> is generally pointless and you should not normally expect or rely on the presence of two zeroes if you want to make your code portable.</p>

<p><code>(unsigned int)v</code> won't tell you the difference between <code>v=+0</code> and <code>v=-0</code>, in both cases <code>(unsigned int)v</code> will be equivalent to <code>0u</code>.</p>

<p>So, with this method you won't be able to tell whether internally <code>v</code> is a <code>-0</code> or a <code>+0</code>, you won't extract v's sign bit this way for <code>v=-0</code>.</p>

<p>But again, you gain nothing of practical value from differentiating between the two zeroes and you don't want this differentiation in portable code.</p>

<p>So, with this I dare to declare the method for sign extraction presented in the question quite/very/pretty-much/etc portable in practice.</p>

<p>This method is an overkill, though. And <code>(int)v</code> in the original code is unnecessary as <code>v</code> is already an <code>int</code>.</p>

<p>This should be more than enough and easy to comprehend:</p>

<pre><code>int sign = -(v &lt; 0);
</code></pre>
",5
12856334,12855825,4,"<p>It's not strictly portable, since it is theoretically possible that <code>int</code> and/or <code>unsigned int</code> have padding bits.</p>

<p>In a hypothetical implementation where <code>unsigned int</code> has padding bits, shifting right by <code>sizeof(int)*CHAR_BIT - 1</code> would produce undefined behaviour since then</p>

<pre><code>sizeof(int)*CHAR_BIT - 1 &gt;= WIDTH
</code></pre>

<p>But for all implementations where <code>unsigned int</code> has no padding bits - and as far as I know that means all existing implementations - the code</p>

<pre><code>int v;
int sign; // the sign of v ;
sign = -(int)((unsigned int)((int)v) &gt;&gt; (sizeof(int) * CHAR_BIT - 1));
</code></pre>

<p>must set <code>sign</code> to <code>-1</code> if <code>v &lt; 0</code> and to 0 if <code>v &gt;= 0</code>. (Note - thanks to <a href=""https://stackoverflow.com/users/822669/sander-de-dycker"">Sander De Dycker</a> for pointing it out - that if <code>int</code> has a negative zero, that would also produce <code>sign = 0</code>, since <code>-0 == 0</code>. If the implementation supports negative zeros and the sign for a negative zero should be <code>-1</code>, neither this shifting, nor the comparison <code>v &lt; 0</code> would produce that, a direct inspection of the object representation would be required.)</p>

<p>The cast to <code>int</code> before the cast to <code>unsigned int</code> before the shift is entirely superfluous and does nothing.</p>

<p>It is - disregarding the hypothetical padding bits problem - portable because the conversion to unsigned integer types and the representation of unsigned integer types is prescribed by the standard.</p>

<p>Conversion to an unsigned integer type is reduction modulo <code>2^WIDTH</code>, where <code>WIDTH</code> is the number of value bits in the type, so that the result lies in the range 0 to <code>2^WIDTH - 1</code> inclusive.</p>

<p>Since without padding bits in <code>unsigned int</code> the size of the range of <code>int</code> cannot be larger than that of <code>unsigned int</code>, and the standard mandates (6.2.6.2) that signed integers are represented in one of</p>

<ul>
<li>sign and magnitude</li>
<li>ones' complement</li>
<li>two's complement</li>
</ul>

<p>the smallest possible representable <code>int</code> value is <code>-2^(WIDTH-1)</code>. So a negative <code>int</code> of value <code>-k</code> is converted to <code>2^WIDTH - k &gt;= 2^(WIDTH-1)</code> and thus has the most significant bit set.</p>

<p>A non-negative <code>int</code> value, on the other hand cannot be larger than <code>2^(WIDTH-1) - 1</code> and hence its value will be preserved by the conversion and the most significant bit will not be set.</p>

<p>So when the result of the conversion is shifted by <code>WIDTH - 1</code> bits to the right (again, we assume no padding bits in <code>unsigned int</code>, hence <code>WIDTH == sizeof(int)*CHAR_BIT</code>), it will produce a 0 if the <code>int</code> value was non-negative, and a <code>1</code> if it was negative.</p>
",6
15539216,15539147,1,"<p>If the macro is going to used in other files besides that single one, I would advise against doing this.  If someone else is going to read the code - they'll have to navigate to another file to find what the macro is defined as.  </p>

<p><code>#define</code> is usually meant to replace text literals or constants that you will be using everywhere like 'true' or 'false'.  In this case, if someone uses this and ""status"" is not being defined or instantiated, it'll throw an error.</p>

<p>Personally, I would just call it a function and name it appropriately as to what it's doing.  Just have a function that returns 0 if false, or 1 if true would make it's usage clearer, and if someone else modifies the code less prone to ill-use.  </p>

<p>If the project is large enough, you might forget what the #define is in six months, so think ahead and save yourself some pain.</p>
",0
15539274,15539147,1,"<p>Test positive</p>

<pre><code>#define DO_MODIFY_RTP
#ifdef DO_MODIFY_RTP // 
if(modify_rtp_media_stream(channel-&gt;ipm) == FALSE) {
        status = FALSE;
    }
#endif 
</code></pre>

<p>Test negative</p>

<pre><code>#define DO_MODIFY_RTP
#ifndef DO_MODIFY_RTP // 
if(modify_rtp_media_stream(channel-&gt;ipm) == FALSE) {
        status = FALSE;
    }
#endif 
</code></pre>
",0
15539339,15539147,1,"<p>The method you propose is not standard at all. I had to look closely to notice the macros were different, because in that configuration they are usually the same.</p>

<p>This is more common:    </p>

<pre><code>#define DO_MODIFY_RTP
#ifdef DO_MODIFY_RTP
    if(modify_rtp_media_stream(channel-&gt;ipm) == FALSE) {
        status = FALSE;
    }
#endif
</code></pre>

<p>or</p>

<pre><code>#undef DO_MODIFY_RTP
#ifdef DO_MODIFY_RTP
    if(modify_rtp_media_stream(channel-&gt;ipm) == FALSE) {
        status = FALSE;
    }
#endif
</code></pre>
",0
15539343,15539147,3,"<p>Usually, you don't want to have to modify the source code, so you'd probably do something like this:</p>

<pre><code>#undef MODIFY_RTP
#if defined(DO_NOT_MODIFY_RTP)
#define MODIFY_RTP 0
#else
#define MODIFY_RTP 1
#endif

if (MODIFY_RTP)
{
    if (modify_rtp_media_stream(channel-&gt;ipm) == FALSE)
        status = FALSE;
}
</code></pre>

<p>On the compiler command line you can have <code>-DDO_NOT_MODIFY_RTP</code>, or in a configuration header you can write <code>#define DO_NOT_MODIFY_RTP</code>, and the RTP stream will not be changed.  By omitting the definition of the <code>DO_NOT_MODIFY_RTP</code> macro, the function will be called and the RTP stream could be modified.</p>

<p>Or you can invert the condition so that the default is not to modify the stream:</p>

<pre><code>#if defined(DO_MODIFY_RTP)
#define MODIFY_RTP 1
#else
#define MODIFY_RTP 0
#endif
</code></pre>

<p>The big advantage of the code shown is that it is always compiled ¡ª but the optimizer will eliminate the call to <code>modify_rtp_media_stream()</code> if MODIFY_RTP is 0.  This means that the compiler checks the syntax of the statement, so it doesn't get out of date as the code around it changes.  Debug code tends to decay if it is not compiled as the code around it changes but the compiler doesn't notify you of the problems because the preprocessor removed the code so that the compiler proper doesn't see it.</p>
",2
12274720,12274601,1,"<p><em><strong>1) I am just wondering should I test for the FALSE or the TRUE conditions first. What is
normally better. I know it doesn't make much difference, but I am just wondering what other engineers do? In the example below I am
checking for a FALSE first.</em></strong></p>

<p>Syntactically it doesn't make much of a difference, programming wise again doesnt really matter in general. However, for a specific usecase  it can affect the performance. Lets consider an example, If you are playing a media file and this condition is to check whether its a media frame or header. Here you know that you will have 100s of media frame following a header hence you would want to check for media frame then header. As checking for header would mean 100 redundant checks == 100 redundant CPU instructions [may be even more]. its always better to code depending on your usecase unless you are writing a general thing.</p>

<p><em><strong>2) I always like to do some defensive programming. So I always if I can explicitly check each condition. for example rather than do if() - else. I would do if() - else if(). In the example below the condition can either be TRUE or FALSE. However, I always like to check the else condition to make sure that it is TRUE. Is there any real point to this?</em></strong></p>

<p>Defensive programming has its own pro and cons. In the above mentioned scenario the compiler will do necessary optimizations for you.</p>

<p>You might want to have a look here
<a href=""http://www.eventhelix.com/realtimemantra/basics/optimizingcandcppcode.htm#"" rel=""nofollow"">http://www.eventhelix.com/realtimemantra/basics/optimizingcandcppcode.htm#</a></p>

<p>Cheers..
Happy Learning</p>
",0
12274722,12274601,1,"<p>1) it doesn't matter which condition you check first because the compiler will optimize the code for you.</p>

<p>2) if <code>status</code> only can have two values (<code>TRUE/FALSE</code>) then having an <code>else if</code> seems a bit confusing to the average reader. if on the other hand <code>status</code> could have other values then a third else part would be good with an <code>assert()</code>. in general adding asserts is a good habit to add to your defensive toolbox to catch erroneous assumptions.</p>
",0
12274724,12274601,1,"<p>First off, don't do this for boolean values:</p>

<pre><code>if (something == TRUE)
if (something == FALSE)
</code></pre>

<p>These should rather be something like:</p>

<pre><code>if (something)
if (!something)
</code></pre>

<p>Boolean values should also be intelligently named so that the <code>if</code> statements read naturally, such as <code>if (isFinished)</code> or <code>while (stillSomeMoreToGo)</code>. <code>status</code> is <em>not</em> a good name for a boolean unless it's meant to indicate that something has a status and, even then, I'd use <code>hasStatus</code> or something similar.</p>

<p>In any case, something can be true in C even if it isn't equal to your <code>TRUE</code> value. <code>TRUE</code> will be, by necessity, <em>one</em> value whereas C defines something as true if it's non-zero (2<sup>32</sup>-1 <em>different</em> possible values though of course that depends on your <code>int</code> specification).</p>

<p>Testing explicitly for true or false is a bad idea since all that does is generate <em>another</em> boolean, and where do you stop?</p>

<pre><code>if ((event-&gt;status == TRUE) == TRUE) ...
if (((event-&gt;status == TRUE) == TRUE) == TRUE) ...
if ((((event-&gt;status == TRUE) == TRUE) == TRUE) == TRUE) ...
if (((((event-&gt;status == TRUE) == TRUE) == TRUE) == TRUE) == TRUE) ...
</code></pre>

<hr>

<p>In terms of your specific questions, for (1), it probably won't make one bit of difference from a performance point of view. However, sometimes it can affect code readability. Choose the method that gives you the ""prettiest"" code, and let the compiler sort out the best way to convert your source into native form.</p>

<p>The <em>first</em> thing I optimise for is readability, since that's the thing that prevents most problems down the track. Once you profile the readable code and work out there's a performance problem, <em>then</em> you can think about ways to improve.</p>

<p>But I'll give you this advice for free: the most impressive improvements can usually be made at the macro level (things like algorithm selection and data structure choices), rather than at the micro level (testing for true or false, counting down instead of up in loops and so on).</p>

<p>For an example of readability, I tend to do short ones first (where the block inside the <code>if</code> is relatively concise). I also tend to do early returns first as well since they often reduce indentation. In other words, something like:</p>

<pre><code>def fn (x):
    if (x &lt; MIN_X_ALLOWED):
        return -1

    # Now carry on, knowing that x &gt;= MIN_X_ALLOWED.
</code></pre>

<hr>

<p>For (2), no, there's no real point to this. You have explicitly decided that a boolean is needed and that only has two possible cases. You're defending against an impossibility.</p>

<p>If it were an integer, and only the values <code>2</code>, <code>3</code>, <code>5</code>, <code>7</code> and <code>11</code> were allowed, that would be different since you'd want to defend against (for example) the value <code>10</code>.</p>
",0
12274817,12274601,2,"<ol>
<li><p>I am just wondering should I test for the FALSE or the TRUE conditions first. What is normally better. I know it doesn't make much difference, but I am just wondering what other engineers do? In the example below I am checking for a FALSE first.</p>

<p>Do a profiling on your conditions. If you have some data show that 20% cases goes to False and 80% cases goes to true, put the true branch at first branch. This may help to improve the performance in some cases.  </p></li>
<li><p>I always like to do some defensive programming. So I always if I can explicitly check each condition. For example rather than do if() - else. I would do if() - else if(). In the example below the condition can either be TRUE or FALSE. However, I always like to check the else condition to make sure that it is TRUE. Is there any real point to this?</p>

<p>Unless you are worrying about the event->status may be damaged by some trick issue, in most cases, I think we just use if (!event->status) else style </p></li>
</ol>
",0
19374586,1073606,10,"<p>I know this is an old post but for anyone that is searching for something similar I recommend looking at.
<a href=""http://en.wikipedia.org/wiki/Triangle_wave"" rel=""noreferrer"">http://en.wikipedia.org/wiki/Triangle_wave</a></p>

<p>The last formula y(x)=(2a/¦Ð)arcsin(sin((2¦Ð/p)*x))</p>

<p>or.</p>

<pre><code>(2 * amplitudeConstant / Math.PI) * Math.Asin(Math.Sin(2 * (Math.PI / periodConstant) * Convert.ToDouble(variableX)))
</code></pre>
",3
19382728,7707190,0,"<p>I don't know why this was voted down, it's a good question that exposes a confusing behaviour of C.</p>

<p>The confusion comes because normally when you define an array a real pointer is created:</p>

<pre><code>char data[100];
printf(""%p\n"", data);    // print a pointer to the first element of data[]
printf(""%p\n"", &amp;data);   // print a pointer to a pointer to the first element of data[]
</code></pre>

<p>So on a typical 32 bit desktop system 4 bytes are allocated for <code>data</code>, which is a pointer to 100 chars. <code>Data</code>, the pointer, itself exists somewhere in memory.</p>

<p>When you create an array in a struct no pointer is allocated. Instead the compiler converts references to <code>packet.data</code> into a pointer at runtime but does not allocate any memory for storing it. Rather it just uses <code>&amp;packet + offsetof(data)</code>.</p>

<p>Personally I would prefer the syntax to be consistent and require an ampersand, with packet.data generating some kind of compile time error.</p>
",4
18982823,18982652,0,"<p>This:</p>

<pre><code>#define MY_REGISTER_1 (*(volatile uint8_t *)(0x1B))
</code></pre>

<p>Yields <em>a copy</em> of the value in the (mem mapped) register.  So this:</p>

<pre><code>set_bit_low(MY_REGISTER_1, 3);
</code></pre>

<p>Would pass that copy to <code>set_bit_low()</code>.  You can then set the bits <em>in the copy</em> (which would be local to the function).  If you want to set bits of the value <em>in the register</em>, then you have to pass the address itself:</p>

<pre><code>#define MY_REGISTER_1_ADDR 0x1b
</code></pre>

<p>Make sense?</p>
",0
18983038,18982652,0,"<p>Many answers already mentioned that passing <code>MY_REGISTER_1</code> the way you defined it to a function would result in a copy of it to be sent. However, the actual solution often used in microcontrollers is different than what the other answers suggest.</p>

<p>Usually, the registers <em>are</em> defined the way you defined them, i.e.</p>

<pre><code>#define MY_REGISTER_1 (*(volatile uint8_t *)(0x1B))
#define MY_REGISTER_2 (*(volatile uint8_t *)(0x18))
</code></pre>

<p>is ok. However, you should take care not to pass them to a function if you expect them to be changed by that function. The cleanest way to perform bit manipulation of such registers is through macros. For example:</p>

<pre><code>#define SET_BIT_LOW(reg, n) (reg) &amp;= (uint8_t)~(1 &lt;&lt; (n))
#define SET_BIT_HIGH(reg, n) (reg) |= (uint8_t)(1 &lt;&lt; (n))
</code></pre>

<p>This not only correctly manipulates the actual register, but also has the added benefit that you avoid a function call. If these were functions, <code>n</code> wouldn't be known and therefore the shift and not operations would have to be done either way as well as a (relatively) costly function call. With macros, the compiler could already calculate the right-hand-side expressions if <code>n</code> is a constant and replace the line with 1 or 2 instructions.</p>
",7
18982847,18982652,1,"<p>The following should be the correct way to declare your function:</p>

<pre><code>void set_bit_low(uint8_t *, uint8_t);
</code></pre>
",0
18982848,18982652,2,"<p>Let's start with your definitions:</p>

<pre><code>#define MY_REGISTER_1 (*(volatile uint8_t *)(0x1B))
</code></pre>

<p>dereferences the octet at address <code>0x1b</code>, so it represents the <em>content</em> of your memory mapped register, rather than its location. It would be preferable to have a macro with the location of your register(s):</p>

<pre><code>#define REGISTER_1 ((volatile uint8_t *) (0x1B)) /* Substitute _1 for some meaningful name */
</code></pre>

<p>which you can then dereference at will, and you can declare your function as follows:</p>

<pre><code>void set_bit_low(volatile uint8_t *register, uint8_t bitpos);

/* Use like this: */
set_bit_low(REGISTER_1, 3);
</code></pre>
",4
18982902,18982652,1,"<p>No. You want to alter the content of the memory location. So, you must pass it as pointer.</p>

<p>The function header should like</p>

<pre><code>void set_bit_low(uint8_t *, uint8_t);
</code></pre>

<p>The function shoul like</p>

<pre><code>void set_bit_low(uint8_t *my_reg, uint8_t bit_location)
{
   // do your bit manupulation here by assigning to *my_reg.
}
</code></pre>
",0
17410134,17410008,1,"<p>Your code works but you print the character twice:</p>

<pre><code>printf(""Value is : %c \n"",test);
printf(""%c \n"",ch);
</code></pre>

<p>I've tried myself:</p>

<pre><code>Value is : a 
a 
Value is : b 
b 
Value is : c 
c 
Value is : d 
d 
</code></pre>

<p>By the way, you should not use a global variable but return the key instead...</p>
",7
12345716,12345427,1,"<pre>`*channel++`</pre>

<p>Interpretation:
1) *channel i.e, value at address stored in channel is worked upon.
2) after semi - colon address of channel is incremented.</p>

<p>above are steps of post increment.</p>

<p>Hence, </p>

<pre>

    for(i=0;i

<p>""CAN"" simply mean if channel is already at position 0 (zero)</p>



    channel[0].hw_value =xyz;
    channel++;

</pre>
",2
12346528,12345427,0,"<p>The operator precedence rules of C say that postfix operators have higher precedence than unary operators. Therefore the expression is equivalent to</p>

<p><code>*(channel++)</code></p>

<p>First it takes note that the pointer channel needs incrementing by 1 unit. Due to the nature of the postfix increment, this change doesn't take place until after the operand itself has been evaluated. </p>

<p>Next it takes the contents of the operand, which is still channel. It does something with the contents, then once that is done, the pointer gets incremented.</p>

<p>Now, to be picky, this code relies on undefined behavior, since the variable channel is modified twice without a sequence point in between. Strictly speaking the code is free to go haywire, but in practice all compilers implement this code in a deterministic way.</p>
",2
13446866,13446772,1,"<p>Both your functions (<code>sort</code> and <code>merge</code>, that is) make an implicit assumption that the right end of the interval being sorted/merged is included in the range being sorted. This is unusual: a more typical approach is to include the left side of the interval, but exclude the right side. For example, the call of <code>sort</code> may look like this:</p>

<pre><code>#define MAX 100
...
int list[MAX];
...
void sort(0, MAX, myComparator);
</code></pre>

<p>This will not work with your implementation: it expects a call that looks like this:</p>

<pre><code>void sort(0, MAX-1 /* &lt;&lt;== Here */, myComparator);
</code></pre>

<p>Please check the way that you call <code>sort</code>; passing an inclusive right interval should fix the problem.</p>
",0
10643465,10641967,2,"<p>Do you really want to define a type as either integer or floating-point? They're both numeric, but their behavior is so different in many ways that writing code that works correctly in either case is going to be difficult.</p>

<p>In many cases, you can convert to a type that's wide enough to cover the ranges of both possible types.  A simple example:</p>

<pre><code>#include &lt;stdio.h&gt;

#ifdef BLA_BLA
typedef int num_type;
#else
typedef long num_type;
#endif

int main(void) {
    num_type x = 42;
    printf(""x = %ld\n"", (long)x);
    return 0;
}
</code></pre>

<p>More generally, you can convert to <code>intmax_t</code> or <code>uintmax_t</code>, defined in <code>&lt;stdint.h&gt;</code> or <code>&lt;inttypes.h&gt;</code>, using <code>""%jd""</code> or <code>""%ju""</code>, respectively.</p>

<p>You can <em>almost</em> do the same thing by converting everything to <code>long double</code>, but that can lose precision for large integer values.</p>
",0
10643549,10641967,0,"<p>If it were me, I wouldn't pass a <code>typeA</code> argument to <code>printf</code> directly; I'd create another function that returned a string representation of a <code>typeA</code> value, and pass that string to <code>printf</code> (or whatever other function needed to display it).  </p>

<pre><code>char *formatTypeA(typeA val, char *buf, size_t len)
{
  #ifdef BLA_BLA
  #define FORMATCHAR d
  #else
  #define FORMATCHAR f
  #endif

  char formatStr[SIZE]; // where SIZE is large enough to handle the longest
                        // possible size_t value plus ""%"" plus the format
                        // character plus the 0 terminator
  sprintf(formatStr, ""%%%zu"" FORMATCHAR, len - 1); 
  sprintf(buf, formatStr, val);
  return buf;
}

int main(void)
{
  typeA foo;
  char output[10];
  ...
  printf(""foo = %s\n"", formatTypeA(foo, output, sizeof output));
  ...
}
</code></pre>

<p>There's probably a better way to do that.</p>

<p><strong>EDIT</strong></p>

<p>This is one of the reasons I tend not to use typedefs very often, btw; if the representation matters (such as in this case), then you really don't want to hide that information from whoever's using it.</p>
",0
10643347,10641967,-1,"<p>Yet another alternative - define a short helper function so you don't have to sprinkle ifdefs everywhere throughout your code:</p>

<pre><code>#ifdef BLA_BLA
typedef int typeA
#else
typedef double typeA
#endif

inline void print_typeA(const typeA val) {
#ifdef BLA_BLA 
  printf(""%d"" , val); 
#else
  printf(""%e"" , val);
#endif
}

somefunc()
{ typeA xyz;

  print_typeA(xyz);
}
</code></pre>
",2
11168980,11168692,1,"<p>Try this!!!</p>

<pre><code> #include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void) {
    char *token;
    char text[] = ""Hello atm adsl"";
    char *arr[] = {""atm"", ""f/r"", ""pc"",""adsl""}; // If found I would like to replace them with Atm, F/R,PC,ADSL

    char textTmp[500] ="""";

    token = strtok (text, "" ""); // catch single words
    while(token != NULL) {

        printf(""%s\n"", token);
        if (strncmp(token, arr[0], strlen(arr[0])) == 0) {
            token[0] = 'A';
        }else if (strncmp(token, arr[1], strlen(arr[1])) == 0) {
            token[0] = 'F';
            token[1] = '/';
            token[2] = 'R';
        } else if (strncmp(token, arr[2], strlen(arr[2]))== 0) {
            token[0] = 'P';
            token[1] = 'C';
        } else if (strncmp(token, arr[3], strlen(arr[3]))== 0) {
            token[0] = 'A';
            token[1] = 'D';
            token[2] = 'S';
            token[3] = 'L';
        }
        strncat(textTmp, token, strlen(token));
        strncat(textTmp, "" "", 1);
        token = strtok (NULL, "" "");
    }

    textTmp[strlen(textTmp)-1] = '\0';

    strncpy(text, textTmp, strlen(textTmp));
    printf(""%s\n"", text);


    return 0;



}
</code></pre>
",6
11168740,11168692,0,"<ol>
<li><p>In C, switch can only be used with integer cases - hence the error.</p></li>
<li><p>Your assignment <code>str=arr[j]</code> is invalid, because you assign a <code>const char*</code> to a <code>char *</code>. C does not copy by value on assignment... If you want to copy over the value from <code>const char*</code> and then <em>make changes to it</em>, then you need to <code>malloc</code> your own memory and <code>strcpy</code> to there.</p></li>
</ol>
",0
11168744,11168692,1,"<p><code>C cannot do switch with string.</code></p>

<p>This may answer your question: <a href=""https://stackoverflow.com/questions/4014827/best-way-to-switch-on-a-string-in-c"">best way to switch on a string in C</a></p>
",0
13454098,13454036,4,"<p>You can ""clear"" memory by using <code>memset</code>, and setting all the bytes in the memory block to <code>0</code>.  So for instance:</p>

<pre><code>#define MEMORY_BLOCK 10

//allocate memory
unsigned char* s = malloc(MEMORY_BLOCK);

//... do stuff

//clear memory
memset(s, 0, MEMORY_BLOCK);
</code></pre>
",0
13454119,13454036,9,"<p>Be careful!</p>

<p><code>malloc(sizeof(2*5))</code> is the same as <code>malloc(sizeof(int))</code> and allocates just 4 bytes on a 32 bit system. If you want to allocate 10 bytes use <code>malloc(2 * 5)</code>.</p>

<hr>

<p>You can clear the memory allocated by <code>malloc()</code> with <code>memset(s, 0, 10)</code> or <code>memset(s, 0, sizeof(int))</code>, just in case this was really what you intended.</p>

<p>See <a href=""http://linux.die.net/man/3/memset"" rel=""noreferrer"">man memset</a>.</p>

<hr>

<p>Another way to clear the memory is using <a href=""http://linux.die.net/man/3/calloc"" rel=""noreferrer""><code>calloc</code></a> instead of malloc. This allocates the memory as malloc does, but sets the memory to zero as well.</p>
",0
13454133,13454036,3,"<p>A couple of observations:</p>

<ul>
<li>You don't need to cast the return value of <code>malloc()</code> in C.</li>
<li>Your <code>malloc()</code> argument looks wrong; note that <code>sizeof</code> is an operator, not a function. It will evaluate to the size of the type of its argument: 2 * 5 has type <code>int</code>, so the value will probably be 4. Note that this is the same for all integer expressions: <code>sizeof 1</code> is the same as <code>sizeof 100000000</code>.</li>
</ul>

<p>Your question is very unclear, it's not easy to understand why you feel you have to ""clear"" the string area. Memory is memory, it will hold what you last wrote to it, there's no need to ""clear"" it between writes. In fact, a ""clear"" is just a write of some specific value.</p>
",0
8810949,3473765,1,"<p>No strcpy or C99 compund literal is needed. The example in pure ANSI C:</p>

<pre><code>typedef struct{
   char a[6];
} point;

int main()
{
   point p;
   *(point*)p.a = *(point*)""onetwo"";
   fwrite(p.a,6,1,stdout);fflush(stdout);
   return 0;
}
</code></pre>
",0
20412033,20412005,0,"<p>Your function </p>

<pre><code>int insertNewElementAtEndWithValue(list_element element, int value)
</code></pre>

<p>is accepting a list_element object, meaning, a copy of the head of your list, what you want to pass is a pointer, so:</p>

<pre><code>int insertNewElementAtEndWithValue(list_element *element, int value)
</code></pre>

<p>and this way you add the value to the actual list and not a copy of it.</p>

<p>You need to learn to use pointers, and use a debugger to check where your data stays.</p>
",3
13778848,13778829,0,"<p>It is <em>log<sub>2</sub> n</em>, that is the number of binary bits (or the rank of the highest 1 bit) in the binary representation of n</p>

<p>And you made a typo, you probably mean</p>

<pre><code> for(i=n,j=0 ; i&gt;0 ;  (i/=2), (j+=i));
</code></pre>

<p>So you start with <code>i==n</code> then you halve it till 0 is reached (hence the <em>log<sub>2</sub> n</em> number of loops).</p>
",3
13778896,13778829,1,"<p>This is a sum of geometric series with <em>log<sub>2</sub>n</em> elements. The sum depends on your <code>n</code>, but in any case it's bounded by<code>2n</code>. Theory is here: <a href=""http://en.wikipedia.org/wiki/Geometric_progression"" rel=""nofollow"">http://en.wikipedia.org/wiki/Geometric_progression</a></p>
",1
18101384,3845590,0,"<p>If you are using Windows, the Windows-versions making beep very different ways. Some of them enable that and working fine, but some windows versions don't. In some windows, it works just that case, if you have an internal motherboard speaker. But some other windows, it works fine without internal motherboard speaker, directly from sound-card (that would be nice!). </p>

<p>If you are lucky, and using the appropriate windows-version, beep/Beep/printf(""\a"") will work (on internal speaker (if you have), or best case via soundcard). But if you are using an other windows version, it will not work. If in your computer it's okay, your friend's / family member's pc will silent, and he/she will think that you wrote a bad program :-D but not.</p>

<p>My advice, that you should use a library for audio. It's simple, cross-platform, and it will be working always all times all computers etc. For example, Allegro_v4, Allegro_v5, SDL (Simple DirectMedia Layer), or something like that. These librarys works fine with OpenGL / DirectX, and with these librarys, you can load images, play videos, and things like that. Native OpenGL / GLUT / DirectX can't do things like that. </p>
",0
13469739,13469327,1,"<p>Try this:</p>

<pre><code>while(*original)
  original++;
while(*add)
{
  *original = *add;
  add++;
  original++;
}
*original = '\0';
</code></pre>

<p>It may be helpful.</p>
",0
13469361,13469327,2,"<p>The idiomatic way is </p>

<pre><code>while (*dst++ = *src++);
</code></pre>
",6
13469365,13469327,2,"<p>Some observations:</p>

<ol>
<li>You're not copying the termination, leaving a non-terminated string in <code>dst</code>. This is the cause of the actual problems.</li>
<li>This: <code>if(dst == '\0'||src == '\0')</code> is weird, if the intent was comparing against <code>NULL</code> you should do so more directly and not use character literals.</li>
<li>The <code>src</code> argument should be <code>const char *</code> since it's read-only. Using <code>const</code> for pointers that are ""input"" arguments is a very good idea, since it communicates intent right there in the prototype. It also helps avoid mistakingly writing to the wrong string.</li>
<li>You can't have a function beginning with <code>str</code>, that ""namespace"" is reserved for the standard library.</li>
</ol>
",3
13469825,13469327,1,"<p>There are pretty much errors in your code:</p>

<ol>
<li><code>if (dst == '\0' || src == '\0')</code> what you are trying by checking this. First of all this is not clear condition - you should use <code>if (dst == NULL || src == NULL)</code> or <code>if (*dst == '\0' || *src == '\0')</code> to be more accurate and make this more clear. Second even if this condition would be right (<code>if (*dst == '\0' || *src == '\0')</code>) you are not achieving what concatenation should. At least if <code>*src == '\0'</code> you should probably return original string - dst.</li>
<li>You should probably check if dst is long enough to store your new string or you should allocate new buffer inside function big enough to hold both dst and src (<code>malloc (strlen(dst) + strlen(src) + 1</code>) - note extra <code>+1</code> for holding terminating '/0' character)</li>
<li>You are not terminating your result string.</li>
</ol>

<p>And the answer for your questions: segmentation fault is probably because your dst is NOT long enough to hold both src and dst. You can use hint in point 2. to modify your code or you can declare bigger buffer outside function that will have size at least <code>(strlen(dst) + strlen(src) + 1</code>.
Another reason could be calling this function with constant string e.g char <code>*str = ""string"";</code>. In this case most probably string is constant and you are not allowed to modify it (in most operating system this will be located in non-modifiable part of program and you will have only pointer to this location).</p>
",0
13469587,13469327,1,"<p>Possible crash causes:</p>

<p>1) may be the length of your <code>dst</code> is not enougth to support concatunation of <code>src</code> and <code>dst</code>.</p>

<p>2) may be you have called your function with input char pointers which they are not pointed to allocated memory (staic or dynamic)</p>

<p>3) may be your input dst char pointer is pointing to a constant string.</p>

<p>another remark you have to finish your <code>dst</code> string with <code>'\0'</code> after the second <code>while</code></p>

<pre><code> while (*src != '\0')
        *dst++ = *src++;
 *dst='\0';
</code></pre>
",0
13470995,13469327,0,"<p>Your code is correct , see below for explanation !</p>

<p>I think you are using char * for the src and dst string in the caller.</p>

<p>Using an array declaration there will help, since your program is crashing at</p>

<pre><code>*dst++ = *src++;
</code></pre>

<p>because dst and src point to strings which are constants and cannot be modified.</p>

<p>In the following code I have just added main, and your function is unchanged !</p>

<pre><code>#include&lt;stdio.h&gt;

char *strconcat(char *dst, char *src)
{
    char *fdst;
    fdst = dst;
    if (dst == '\0' || src == '\0')
        return fdst;

    while (*dst != '\0')
        dst++;
    while (*src != '\0')
        *dst++ = *src++;

    return fdst;
}

void main()
{
 char dest[10] = ""one"" ;
 char src[10] = ""two"" ;

printf(""\n%s "" , strconcat( dest , src ) ) ;
}
</code></pre>

<p>Although you need to change the if statement to</p>

<pre><code> if (*dst == '\0' || *src == '\0')
            return fdst;
</code></pre>
",0
13487297,13469327,1,"<p>Multiple problems here:</p>

<p><strong>PROBLEM - I</strong></p>

<p>The memory allocated with malloc </p>

<pre><code>    fdst = (char *) malloc(dst_len + src_len + 1);
</code></pre>

<p>is lost as some lines later you are doing this:</p>

<pre><code>    fdst = dst;
</code></pre>

<p>replacing the address returned by malloc in 'fdst' with the address of the target string..!! Hope you fix it on your own, its darn simple.</p>

<p><strong>PROBLEM - II</strong></p>

<p>After fixing that above problem, you'll have to fix this:</p>

<pre><code>while(*dst)
{
   dst++;
   fdst++;
}
</code></pre>

<p>don't only increment, you'll also have to copy your characters from <code>dst</code> to <code>fdst</code> as this will be your concatenated string.</p>

<p><strong>PROBLEM - III</strong></p>

<p>finally, you are doing this in the end..!!</p>

<pre><code>return fdst;
</code></pre>

<p>you realize the mistake there right? Hope you can take care of that [ Hint: save the starting address and return it in the end, not the incremented pointer ;) ]</p>

<p>Note: Not an optimised solution but, fixes your code.</p>
",0
14219596,14219572,0,"<p>To go back from the 1D index to a 2D one, just divide and take the remainder.</p>

<pre><code>twoDrow = index / COLUMNS;
twoDCol = index % COLUMNS;
</code></pre>
",0
14219615,14219572,3,"<p>It is simple:</p>

<pre><code>row = index / NumCol;
col = index % NumCol
</code></pre>
",0
10645314,10645273,1,"<p>Here's a links that may help you:
<a href=""http://www.parashift.com/c++-faq-lite/mixing-c-and-cpp.html"" rel=""nofollow"">How to mix C and C++</a></p>
",1
10645316,10645273,1,"<p>You can link to a C++ library from C only when the C++ library has been designed to be used from C. Specifically, the functions the library provides need to be exported with <code>extern ""C"" {}</code> block to avoid name mangling, and the interface should be designed in a way to be usable from plain C (i.e. no classes or member functions, only functionless structs and plain functions).</p>

<p>It is worth mentioning that you can compile your C code with a C++ compiler, and it will for the most part be OK. This lets you pretend that your C code is a C++ code, and freely mix in functionality provided through C++ - specific interfaces.</p>
",0
11814574,11814561,2,"<p>Because <code>val</code> is an int; when you assign it <code>54.23</code> it'll be truncated to 54. And 54 != 54.23.</p>

<p>Even if it was a float, you couldn't expect them to be equal. <a href=""http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html"" rel=""nofollow"">Here's why.</a></p>
",2
11814687,11814561,5,"<h2>Never test floats/doubles for equality with <code>==</code></h2>

<p>Here's a version of your code which actually displays the values in question:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    char str[10] = ""54.23"";
    float val = 54.23;

    printf(""atof(str) = %.15f\n"", atof(str));
    printf(""      val = %.15f\n"", val);

    return 0;
}
</code></pre>

<p>When you run it you see this:</p>

<pre><code>$ gcc -Wall atof.c
$ ./a.out 
atof(str) = 54.229999999999997
      val = 54.229999542236328
$
</code></pre>

<p>The values are close, within the expected accuracy of a single precision float, but they are not identical. Also, as others have noted, <code>atof</code> returns a <code>double</code>, so you are comparing the value of a <code>float</code> promoted to a <code>double</code> with a full precision <code>double</code> as returned by <code>atof</code>.</p>

<p>As always with this type of question, read <a href=""http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html"" rel=""nofollow"">this</a> before proceding any further with floating point arithmetic in your code. The ""take home message"" is that you should never compare floats or doubles with <code>==</code> - always compare the absolute difference with an appropriate tolerance value.</p>
",1
11814701,11814561,0,"<p>You almost never want to check equality with floating point numbers, because teensy differences will be read as unequal.  There are other problems, too.  For example, even if you use double precision, for instance, the decimal number ""0.1"" is represented as ""0.10000000000000001"".  </p>

<p>In this case, your ""val"" variable is a double precision literal, which is cast to a float.  The result probably won't be accurate perfectly.  Secondly, your string literal needs to convert from base ten to a base 2 double.  So, to compare the atof value to your literal, atof converts a base ten string to a base two double, while ""val"" was converted from a base ten literal to a base two double to a base two float, and then <em>upcast back</em> to a base two double to do the comparison.</p>

<p>Point of fact, I'm not going to pin down <em>exactly</em> where that lost precision went.  Do as Paul's code might suggest and compare the values to within a <em>tolerance</em>.</p>
",1
11857414,11814561,1,"<pre><code>double atof(char *str);\\it return double not a float
</code></pre>

<p>This comparison is between a float and a double.As you compare between two different types you may get some unexpected output.because every data type having different memory representation as well as different access mechanism.</p>

<p>float represent in memory in different form as compare to double .</p>

<p>you can learn more about this in wikipedia also</p>

<p><a href=""http://en.wikipedia.org/wiki/Floating_point#Internal_representation"" rel=""nofollow"">http://en.wikipedia.org/wiki/Floating_point#Internal_representation</a></p>

<p>Again you should include the header file </p>

<pre><code>#include &lt;stdlib.h&gt; \\prototype of atof() present in this header.
</code></pre>

<p>if you not provide the proper prototype before use of the function then </p>

<p>return type of function by default int .So I think the return result is definitely different as you expected. </p>
",0
10822732,10822651,3,"<p>You either declare it with maximum size possible and acceptable for your case, or use <a href=""http://www.kernel.org/doc/man-pages/online/pages/man3/malloc.3.html"" rel=""nofollow""><code>malloc(3)</code></a> to ask the runtime to dynamically allocate exact amount of memory for you (then release that memory with <a href=""http://www.kernel.org/doc/man-pages/online/pages/man3/malloc.3.html"" rel=""nofollow""><code>free(3)</code></a> when done).</p>
",1
13710758,13710650,1,"<p>Your parent has the <code>while</code> loop. The child does the following:</p>

<pre><code>signal(SIGUSR1, childHandler);
printf(""child"");
</code></pre>

<p>And then exits.</p>

<p>If it does receive <code>SIGUSR</code> before the exit, this will also be executed</p>

<pre><code>printf(""child called"");
signal(SIGUSR1, childHandler);
</code></pre>

<p>Therefore you have a <a href=""http://en.wikipedia.org/wiki/Race_condition"" rel=""nofollow"">race condition</a> as the number of <em>child called</em> is printed.</p>

<p>Just put a <code>while (1) {}</code> after the <code>printf(""child"");</code></p>
",14
9148263,9148258,10,"<p>It's possible because the compiler doesn't need to know anything about the structure if it only deals with a pointer to it.</p>

<p>This is a commonly used technique and is usually called an &ldquo;opaque pointer&rdquo;.</p>
",6
9148453,9148258,0,"<p>Look into the below link</p>

<p><a href=""http://cboard.cprogramming.com/cplusplus-programming/100298-opaque-pointer.html"" rel=""nofollow"">http://cboard.cprogramming.com/cplusplus-programming/100298-opaque-pointer.html</a></p>
",0
12812827,12812812,15,"<p>Use <code>%u</code> as the printf format string.</p>
",0
12812832,12812812,3,"<p>You should use <code>&lt;stdint.h&gt;</code> and <code>&lt;limits.h&gt;</code> then <code>INT_MAX</code> or whatever limit is appropriate for your type.</p>
",0
12812843,12812812,4,"<p>Use <em><code>%u</code></em> as the format string to print <code>unsigned int</code>, <code>%lu</code> for <code>unsigned long</code>, and <code>%hu</code> for <code>unsigned short</code>.</p>
",0
12812850,12812812,16,"<p>The <code>%d</code> format treats its argument as a <em>signed</em> <code>int</code>.  Use <code>%u</code> instead.</p>

<p>But a better way to get the maximum value of type <code>unsigned int</code> is to use the <code>UINT_MAX</code> macro. You'll need</p>

<pre><code>#include &lt;limits.h&gt;
</code></pre>

<p>to make it visible.</p>

<p>You can also compute the maximum value of an unsigned type by converting the value -1 to the type.</p>

<pre><code>#include &lt;limits.h&gt;
#include &lt;stdio.h&gt;
int main(void) {
    unsigned int max = -1;
    printf(""UINT_MAX = %u = 0x%x\n"", UINT_MAX, UINT_MAX);
    printf(""max      = %u = 0x%x\n"", max, max);
    return 0;
}
</code></pre>

<p>Note that the <code>UINT_MAX</code> isn't <em>necessarily</em> <code>0xffffffff</code>. It is if <code>unsigned int</code> happens to be 32 bits, but it could be as small as 16 bits; it's 64 bits on a few systems.</p>
",0
12812854,12812812,6,"<p>There is the macro defined in <code>&lt;limits.h&gt;</code>: <code>UINT_MAX</code>.</p>
",0
8770786,8770137,0,"<p>If initializing with zeros is OK for you, then C's default <code>= { 0 };</code> initialization is OK.<br></p>

<p>If you want something more complicated, I suggest not initializing, but setting in code.<br>
Just write a function that sets what you want, and call it. It will be more simple, readable and reliable that anything you can do with initialization.<br></p>

<p>Your macros, try as you may to make them nice, seem like bad practice to me.</p>
",0
8770258,8770137,4,"<p>Just use the ""universal zero initializer"": <code>&lt;type&gt; &lt;identifier&gt; = {0};</code></p>

<pre><code>int i = {0};
double x = {0};
char *pname = {0};
char name[100] = {0};
struct tm moment = {0};
struct foo__ one = {0};
struct foobar__ two = {0};
</code></pre>
",0
8776564,8776547,3,"<p>It's probably better to do it this way:</p>

<pre><code>#define MAX(a, b) ((a) &gt; (b) ? (a) : (b))
#define MAX3(a, b, c) MAX(a, MAX(b, c))
</code></pre>

<p>Or better still, use an inline function rather than resorting to old skool preprocesser abuse:</p>

<pre><code>inline int max3(int a, int, int c) { return max(a, max(b, c)); }
</code></pre>

<p>It's a lot more robust than a macro and just as efficient.</p>
",2
8776569,8776547,6,"<p>Having an expression-like macro with statements inside is not possible in standard C99 language (because in C99 statements and expressions are deeply different, both syntactically and semantically).</p>

<p>However, GCC (and some other compilers with extensions inspired by GCC, e.g. clang) provides a nice extension for that : <a href=""http://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html#Statement-Exprs"" rel=""nofollow"">statement expressions</a> (the documentation gives an example related to your question). With that extension you could code something like</p>

<pre><code> #define MAX3(A,B,C) ({ int a=(A); int b=(B); int c=(C); int m; \
     if (a&gt;b) m=a; else m=b;                                    \
     if (c&gt;m) m=c;                                              \
     m; }) /* bad macro */
</code></pre>

<p>however that still won't work if you use that macro like e.g. </p>

<pre><code> int badex(int x, int y) { 
    int a= x+y; int m= x*y; int d=x-y; 
    return MAX3(a,m,d);
 }
</code></pre>

<p>I hope you see why it won't work (name clashes e.g. between the <code>a</code> inside <code>badex</code> and the <code>a</code> inside <code>MAX3</code> macro). So you need a way to have unique names at every invocation of your macro. Again, GCC provides a nice extension for that, the <a href=""http://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html#Common-Predefined-Macros"" rel=""nofollow""><code>__COUNTER__</code></a> macro (expanded to a unique number, counting) used with <a href=""http://gcc.gnu.org/onlinedocs/cpp/Concatenation.html#Concatenation"" rel=""nofollow"">concatenation</a> in the preprocessor.</p>

<p>Then you'll code something like</p>

<pre><code> #define MAX3(A,B,C) MAX3_COUNTED((A),(B),(C),__COUNTER__)
 #define MAX3_COUNTED(A,B,C,N)  ({                          \
    int a_##N=(A); int b_##N=(B); int c_##N=(C);            \
    int m_##N;                                              \
    if (a_##N&gt;b_##N) m_##N = a_##N; else m_#N = b_##N;      \
    if (c_##N&gt;m_##N) m_##N=c_##N;                           \
  m_##N; }) /* better example */
</code></pre>

<p>Then the first invocation of our macro e.g. <code>MAX3(i++,j++,k++)</code> might expand to <code>MAX3_COUNTED((i++),(j++),(k++),1)</code> which gets expanded into something using <code>a_1</code> <code>b_1</code> ... and the second  invocation, e.g. <code>MAX3(a,m,d)</code> expanded as <code>MAX3_COUNTED((a),(m),(d),2)</code> would use <code>a_2</code> <code>b_2</code>  etc so is better. </p>

<p>And of course, defining a <code>static inline max3(int a, int b, int c)</code> function is cleaner (in particular because of side effects: your <code>MAX3</code> macro gives naughty effects and results with a call like <code>MAX3(i++,j++,k++)</code> etc)</p>

<p>The general lesson about this is that you should when possible avoid macro (preferring inline functions), and when you absolutely need macros take care about name clashes and expansions.</p>

<p>Using GCC invoked as <code>gcc -C -E</code> shows you the preprocessed form of your program.</p>
",8
15835827,15835761,1,"<p>Remove the space from the macro definition:</p>

<pre><code>#define NUM_FROM_DENSE_MAT(PTR, II, JJ, RROW) ((PTR[JJ * RROW + II]))
                         ^^
</code></pre>

<p>Your code was defining a parameterless macro called <code>NUM_FROM_DENSE_MAT</code>.</p>
",0
12785117,12785097,5,"<p>When you crate an array with 5 members, they get indexed 0-4, if you try to acces 5, you're out of bounds</p>
",0
12785124,12785097,1,"<p>An array of 5 elements has indices <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, and <code>4</code>. The index <code>5</code> is out of bounds. In general an array of N elements has valid indices from <code>0</code> to <code>N-1</code> inclusive.</p>
",0
12785163,12785097,2,"<p>Arrays in C are zero based.</p>

<pre><code>my_struct-&gt;pad[0]; // the first pad
my_struct-&gt;pad[4]; // the fifth pad
</code></pre>

<p>The warning means that you are trying to access an element outside the array. An index of <code>5</code> means the sixths element and the array only has 5 elements.</p>
",0
12785442,12785097,9,"<p>Structure field <code>pad</code> was defined as ""array of 5 <code>uint32_t</code>"". You must differ variable definition from using the variable. So since <code>pad</code> is defined, <code>pad[5]</code> means ""get the fifth (counting from 0) element of <code>pad</code> array"". But there is no such element in <code>pad</code> array, because the highest index available for this array is 4.</p>

<p>Also, it seems that you want to return pointer to the first element of this array, not the fifth element. So you must rewrite your function this way:<br></p>

<pre><code>uint32_t * get_pad_5( a_structure * my_struct)
{
    return my_struct-&gt;pad;
}
</code></pre>
",3
13750317,13750247,1,"<p>A bi-dimensionnal array is not evaluated as a pointer to pointer, so you need to use an array of a pointer to array in your prototype:</p>

<pre><code>void print_data(float data[4][6]);
void print_data(float (*data)[6]);
</code></pre>
",3
13750325,13750247,9,"<pre><code>void print_data(float **data, int I, int J)
</code></pre>

<p>expects an array of pointers to (the first element of arrays of) <code>float</code>.</p>

<p>But when you pass</p>

<pre><code>float data[4][6];
</code></pre>

<p>you pass a pointer to <code>float[6]</code>.</p>

<p>So in <code>print_data</code>, an access to</p>

<pre><code>data[i]
</code></pre>

<p>reads <code>sizeof(float*)</code> bytes at an offset of <code>i * sizeof(float*)</code> bytes after what address <code>data</code> holds, and interprets these bytes as a <code>float*</code> that it then dereferences (after adding a suitable offset) in <code>data[i][j]</code>.</p>

<p>So when you pass your 2D array, some <code>float</code> values are interpreted as pointers and then followed. That often leads to a segmentation fault.</p>

<p>You can either declare</p>

<pre><code>void print_data(float (*data)[6], int I, int J)
</code></pre>

<p>and pass your 2D array, or you need to pass an array of pointers,</p>

<pre><code>float *rows[4];
for(i = 0; i &lt; 4; ++i) {
    rows[i] = &amp;data[i][0];
}
</code></pre>

<p>and pass <code>rows</code>. Or, the third possibility is to pass and expect a flat array</p>

<pre><code>void initialize_data(float* data, int I, int J) {
    for(i = 0; i &lt; I; ++i) {
        for(j = 0; j &lt; J; ++j) {
            data[i*J + j] = whatever;
        }
    }
}
</code></pre>

<p>and pass <code>&amp;data[0][0]</code> from <code>main</code>.</p>
",3
17777646,17777641,9,"<p>It breaks because the array <code>states</code> is empty. Make it the size of <code>argc</code> (that's allowed in C99) to fix the problem:</p>

<pre><code>char *states[argc];
</code></pre>

<p>The reason for this is as follows: <code>char *states[] = {};</code> makes an array of zero elements, so any dereference <code>states[i]</code> is undefined behavior.</p>
",3
17777781,17777641,0,"<p>You need to allocate memory for the character array. If argc is the number of characters you want to store:</p>

<pre><code>char *states[argc];
</code></pre>

<p>Works. Or if you want to dynamically expand it you can use the heap, keep a counter variable and add the following in your loop:</p>

<pre><code>states = (char *) realloc(sizeStates + sizeof(char));
sizeStates++;
</code></pre>

<p>To make room for the next character before you assign it. </p>
",1
13784409,13784099,0,"<p>The lack of a ; on line 3 is going to cause problems to start with.</p>

<p>You're passing a character instead of a character pointer on line 2.</p>

<p>And on my mac, once you fix those problems, you get a bus error on line 3 because you're trying to change read-only memory.</p>

<p>char *string =strdup(""aaaa"");</p>

<p>and now it works.</p>

<p>Also, as stated in question comments, instead of strdup, you may want to use</p>

<p>char string[] = ""aaaa"";</p>
",0
10154914,10154892,6,"<p>You overriden the <code>t</code> buffer, and reached the <code>str</code> buffer, where the rest of the input, and the null terminator was set. And <code>puts</code> prints only until the null terminator.</p>

<p>Pretty much looks like that:</p>

<pre><code>[ t (20)             ][str(100)                                 ]
 55555555555555555555  5555555555555\0
</code></pre>

<p>Note that although <code>t</code> is declared as <code>char[20]</code>, when you print it you get the full input (longer than 20), since <code>puts</code> stops at the null terminator (again).</p>

<p>BTW, this is a buffer overflow, not a stackoverflow, but stack overflow is possible on this codeas well.</p>
",0
10154934,10154892,1,"<p>As Binyamin said it is caused by the overflow you trigger because of the input string being too long. However it is a bit random thing - sometimes the two memory allocations will happen just next to each other and the string will extend to the neighbouring variables, sometimes it might not happen.</p>

<p>I advise you to place guard conditions for such kind of overflows.</p>

<p>If you see in the <code>gets</code> <a href=""http://www.cplusplus.com/reference/clibrary/cstdio/gets/"" rel=""nofollow"">documentation</a>:</p>

<blockquote>
  <p>Notice that gets does not behave exactly as fgets does with stdin as
  argument: First, the ending newline character is not included with
  gets while with fgets it is. And second, gets does not let you specify
  a limit on how many characters are to be read, so you must be careful
  with the size of the array pointed by str to avoid buffer overflows.</p>
</blockquote>

<p>In your case if you do not know the size apriory maybe it is better idea to use <code>fgets</code> as it is more secure (though a bit slower).</p>
",4
10154939,10154892,1,"<p>When you enter a string of more than 20 <code>5</code>s, it overruns the buffer that was allocated to <code>t</code> and extends into the buffer that was allocated to <code>str</code>.</p>

<p>Then it displays the contents of <code>str</code>, which is the string you entered, starting at the 21st character.</p>

<p>Finally, it displays the contents of <code>t</code>, but since that string doesn't end with a null character, it continues displaying memory (which is the buffer assiged to <code>str</code>) until it encounters the null character after all the <code>5</code>s.</p>
",0
10155202,10154892,0,"<p>In order to avoid those allocation overlapping issues you can try this alternative, so that the allocation takes place at runtime if I'm not wrong:</p>

<pre><code>    #include &lt;iostream&gt;

    int main(void)
    {
      char *str;
      char *t;
      str = new char(100);
      str = (char*)""88888888888888"";
      t = new char(20);
      std::cin &gt;&gt; t;
      puts(str);
      puts(t);
      return 0;
    }
</code></pre>
",0
13465174,13465132,1,"<p>As is the common advice, code it the way that's easiest to read.  Change from that way only if profiling shows it's a bottleneck.</p>

<p>Unless you intend to return a big struct, which might require copying, the difference is tiny.  Even in the big struct case, if the compiler is clever, the two can turn out to be essentially equivalent when you look at generated code.</p>

<p>Most compilers use a register to return values that fit in a register, and this is very fast. So for such values I can't imagine a case where using a pointer to return value is an advantage.</p>

<p>Finally, it is a common C convention to return an error code as the function value.  So it's also common to use pointers to memory to return values in this case.  APIs that use this convention tend to be uniform and consequently easy to use.</p>

<p>Very simple example:</p>

<pre><code>struct list_s {
   int size;
   struct element_s *array;
}

int initialize_list(struct list_s *list, int size)
{
   int err_code = 0;

   // do the intialization of *list, setting err_code if something goes wrong
   list-&gt;array = malloc(size * sizeof(struct element_s));
   if (list-&gt;array)
     list-&gt;size = size;
   else {
     size = 0;
     err_code = ERR_OUT_OF_MEMORY;
   }

   return err_code;
}
</code></pre>
",0
14863485,14863465,4,"<p>In this context <code>sizeof</code> doesn't do what you want - it yields the size of the pointer, not the size of the string. Use <code>strlen</code> instead.</p>

<blockquote>
  <p>but access to the stdlib is restricted</p>
</blockquote>

<p>You can roll your own using a <code>while</code> and a counter. Untested:</p>

<pre><code>size_t my_strlen(const char *s)
{
    size_t len = 0;
    while (*s++)
        len++;

    return len;
}
</code></pre>

<p>or the slightly more efficient version:</p>

<pre><code>size_t my_strlen(const char* s)
{
   const char *end = s;
   while (*end++) {};
   return end-s-1;
}
</code></pre>

<p>The above works because the pointer is advanced to the last position in the string and then the size is the difference between the last pointer location and the first pointer location, minus 1 of course to handle the null-terminating character.</p>
",4
14863486,14863465,0,"<p>The problem is your <code>sizeof</code>. You need to pass in the size explicitly or use <code>strlen</code>. It is taking the size of the pointer. <code>strlen</code> only works on null-terminated strings though.</p>
",0
14863488,14863465,0,"<p>The problem is the <code>sizeof</code> a pointer variable is the length of the pointer variable.  You want <code>strlen(s)</code> to discover how many characters are at the pointer.</p>
",0
14863491,14863465,0,"<p>You don't want <code>sizeof(s)</code>. The number of characters you want to print is the length of the string, not the size of the pointer to the first character in the string.</p>
",0
14863497,14863465,0,"<p><code>s</code> is a pointer, not an array, so you're only printing the first <code>sizeof(char *)</code> bytes (it happens to be 8 in this case - you're probably using a 64-bit system).</p>

<p>You have to find the length of the string using <code>strlen()</code>:</p>

<pre><code>write (STDOUT_FILENO, s, strlen(s));
</code></pre>

<p>You should also read <a href=""http://c-faq.com/aryptr/aryptr2.html"" rel=""nofollow"">this document</a>.</p>
",0
14863499,14863465,0,"<p><code>write (STDOUT_FILENO, s, strlen(s));</code> assuming your string is null-terminated. </p>
",0
8805175,8393815,1,"<p>Chmod traditionally takes numerical values in octal, so if you want to enable all access rights, you use 0777 (decimal value 511). You're passing in 777 and parsing it as a decimal value with atoi, so you end up with octal value 1411, which is probably an error because it's greater than 0777. At best, it's not at all the permissions you meant to set.</p>
",0
8760335,8760288,1,"<p>The first <code>malloc</code> should be:</p>

<pre><code>pstField-&gt;field = malloc(l * sizeof(int*));
</code></pre>

<p>Your array is <code>int**</code>, so the first level of allocation is an <code>int*</code>.</p>

<p><strong>Edit</strong>: Well, I've tested your code and it does not crash for me. The problem might be somewhere else.</p>
",7
8760434,8760288,2,"<p>You should think a little bit about the structures and what you are storing.</p>

<p>For the game of life you need to know the state of the cell on the board which is indicated by and integer so your struct should become:</p>

<pre><code>struct game_field  {
   int length;
   int *field;
};
</code></pre>

<p>And once you know the dimensions of the field you should allocate it once:</p>

<pre><code>struct game_field *gf = calloc(1, sizeof(struct game_field));
gf-&gt;length = &lt;blah&gt;;
gf-&gt;field = malloc(gf-&gt;length*gf-&gt;length*sizeof(int));
</code></pre>

<p>This way you have an array of integers that you can use as your board.</p>
",10
8761370,8760288,0,"<p>Here's a modification of your code that allocates the field in one block, but still lets you use array brackets for both dimensions:</p>

<pre><code>struct game_field {
  int   length;
  int **field;
};

static struct game_field *new_game_field(unsigned int len)
{
  struct game_field *pstField;
  pstField = malloc(sizeof(struct game_field));
  pstField-&gt;length = len;

  /* allocate enough space for all the row pointers + the row contents */
  pstField-&gt;field = malloc((len * sizeof(int *)) + (len * len * sizeof(int)));

  /* point the row pointers (at the start of the block) at the row contents
   * (further into the block). */
  for (int i = 0; i &lt; len; i++)
    pstField-&gt;field[i] = (int *)(&amp;field[len]) + (i * len);

  return pstField;
}
</code></pre>

<p>This way you can free the field in one shot:</p>

<pre><code>void free_game_field(struct game_field *gf)
{
  free(gf-&gt;field);
  free(gf);
}
</code></pre>

<p>And you can keep the bracket notation to access the elements:</p>

<pre><code>int row7col3 = gf-&gt;field[7][3];
</code></pre>

<p>Note that what you have (here as well as in your original code) is not exactly a two-dimensional array, but an array of pointers to arrays of integers 
(there is a difference, but the <code>arr[x][y]</code> notation can work for either one).</p>
",0
11494348,11494341,9,"<p>It's not a matter of style; that code won't compile without the <code>(struct Foo)</code>.  It's not a cast, it's part of the syntax for a C99 feature known as a <em>compound literal</em>.</p>
",1
12797833,12797818,4,"<p>Include only headers, you need. And no others.</p>

<hr>

<p>Including additional headers, that are not necessary, may/will produce unnecessary larger exe/lib. You don't need that.  </p>

<p>Also, this could be misleading for somebody - don't include code, that you don't need.</p>

<p>It could cause name conflicts, for example - if you include headers, containing functions, with the same name. You don't need this, too.</p>

<p><code>C</code> does not have <code>namespace</code>s, so you don't need to include names, you will not use. You may want to use them for other things.</p>

<p>If you need a header in several modules - include it. Otherwise:</p>

<ul>
<li>if it's not included indirectly, you'll have compiler errors.</li>
<li>if it IS included indirectly, this could cause some troubles for the developers, who will maintain/support your code</li>
</ul>
",1
9810953,9810932,1,"<p>Your code causes undefined behaviour.  Anything can happen.</p>

<p>From the spec, section <strong>J.2 Undefined Behaviour</strong>:</p>

<blockquote>
  <p>There are insufficient arguments for the format in a call to one of the formatted input/output functions, or an argument does not have an appropriate type (7.19.6.1, 7.19.6.2, 7.24.2.1, 7.24.2.2).</p>
</blockquote>

<p>So you could also check out the referenced sections for more information.  In your case, the relevant bits are <strong>7.9.16.1 The <code>fprintf</code> function</strong>, paragraph 9:</p>

<blockquote>
  <p>If a conversion specification is invalid, the behavior is undefined. If any argument is not the correct type for the corresponding conversion specification, the behavior is undefined.</p>
</blockquote>

<p>and <strong>7.19.6.3 The <code>printf</code> function:</strong></p>

<blockquote>
  <p>The <strong><code>printf</code></strong> function is equivalent to <strong><code>fprintf</code></strong> with the argument <strong><code>stdout</code></strong> interposed before the arguments to <strong><code>printf</code></strong>.</p>
</blockquote>
",0
9810959,9810932,3,"<p><code>printf</code> is not type safe so using a incorrect format descriptor results in <strong>Undefined Behavior</strong>.</p>

<p>An Undefined Behavior means that any observable behavior is possible because the code is not abiding the rules laid out by the standard.</p>
",1
9810991,9810932,0,"<p>The <code>""%d""</code> format requires an <code>int</code> argument. Passing a <code>float</code> argument (which promotes to <code>double</code>) results in undefined behavior.</p>

<p>What's <em>probably</em> happening is that <code>printf</code> is taking the wrong number of bytes from the stack, but your time is better spent fixing the code than figuring out why bad code misbehaves in a particular way.</p>

<p>And <code>void main()</code> is wrong; use <code>int main(void)</code>. If some textbook told you that <code>void main()</code> is correct, the author doesn't know the language well enough to be writing about it.</p>
",0
9811091,9810932,0,"<p>The details will vary based on the machine and compiler, but assume that a float is 4 bytes, a double is 8 bytes, and an int is 4 bytes.</p>

<p>You put three floats on the stack which are promoted to 8 bytes for a total of 24 bytes. Then your format string pulls various number of bytes off the stack. So</p>

<ul>
<li>%f, %d, %g will pull 8, 4, 8 bytes</li>
<li>%f, %g, %d will pull 8, 8, 4 bytes</li>
<li>%g, %f, %d will pull 8, 8, 4 bytes</li>
<li>%g, %d, %f will pull 8, 4, 8 bytes</li>
<li>%d, %g, %f will pull 4, 8, 8 bytes</li>
<li>%d, %f, %g will pull 4, 8, 8 bytes</li>
</ul>

<p>The type in vararg area of a printf must match the type expected by the conversion operator.</p>
",4
9202335,9202302,2,"<p>In C++ <code>this</code> is a keyword used as a pointer to the current object inside class member functions.</p>

<p>You have to use some other name that is not reserved by the language.</p>

<p>Or, if this is actually C code, not include C++ headers like <code>&lt;cstdarg&gt;</code> and rename the files from <code>.cc</code> to <code>.c</code>.</p>

<p>Choose your language!</p>
",0
9202347,9202302,4,"<p>You are compiling C source code as C++.  C and C++ are different languages.</p>

<p>Rename your file to <code>solution.c</code> and NOT <code>solution.cc</code>, and make sure to compile with a C compiler (e.g., <code>gcc</code> and NOT <code>g++</code>)</p>

<p><strong>Edit:</strong> Actually, it looks like the source code is neither C nor C++.  Pick one and stick with it.  It is almost C, you would need to change <code>#include &lt;cstdarg&gt;</code> to <code>#include &lt;stdarg.h&gt;</code> and you would need to add <code>#include &lt;stdbool.h&gt;</code> for the <code>bool</code> type.  You will also need to change <code>YES</code> and <code>NO</code> to <code>true</code> and <code>false</code>.</p>

<p>The <code>bool</code> type might not be available if you use Microsoft's MSC compiler, which uses an outdated version of C.</p>
",0
9202357,9202302,1,"<p>You can't use <code>this</code> as a variable name in C++.  It's a language keyword.  If you want to compile a C program, don't use a C++ compiler.</p>
",0
8793562,8793479,2,"<p>Assuming you have only one word (fruit) in one line (and &lt; 80 characters long) in the <code>dictionary.txt</code>, the following should work!</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    char words_array[80];
    FILE *dictionary;
    dictionary = fopen(""dictionary.txt"", ""r"");
    while (fscanf (dictionary, ""%s"", words_array) == 1) {
        printf(""%s \n"", words_array);
    }

    return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>$ gcc fsca.c 
$ ./a.out 
apple 
orange 
bananna 
$ cat fsca.c 
</code></pre>

<hr>

<p>Adding an alternative answer as per request from the OP author.</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    char word1[80], word2[80], word3[80];
    FILE *dictionary;
    dictionary = fopen(""dictionary.txt"", ""r"");
    fscanf(dictionary, ""%s"", word1);
    fscanf(dictionary, ""%s"", word2);
    fscanf(dictionary, ""%s"", word3);
    printf(""%s %s %s\n"", word1, word2, word3);

    return 0;
}
</code></pre>

<p>Output </p>

<pre><code>$ gcc fsca.c 
$ ./a.out 
apple orange bananna
$ 
</code></pre>
",3
8793576,8793479,1,"<p>Your variable <code>words_array</code> has space for 80 characters. You're mistakenly thinking you have 80 words.  The printf line to print the first word is:</p>

<pre><code>printf(""The content of words_array is: %s\n"", words_array);
</code></pre>

<p>If you want to print all the lines/words, you'll need to wrap this in a reader of the lines of the file:</p>

<pre><code>while (fscanf (dictionary, ""%s"", words_array)) {
        printf(""%s \n"", words_array);
    }
</code></pre>

<p>read the man page for fscanf to see why.</p>

<p>[edit]<br></p>

<p>instead of the while  loop:</p>

<pre><code>char words_array[3][80];
for (int i = 0; i &lt; 3; i++)
   fscanf(dictionary, ""%s"", words_array[i]);
</code></pre>

<p>[/edit]<br></p>
",1
8793585,8793479,1,"<p>char words_array[80] is merely a character array - NOT an array of strings. </p>

<p>So when you try to print out words_array[0] and so on, they are characters and hence a mismatch with %s. </p>

<p>Also you would want to use feof for reading till the end of file. Just use fscanf till end of file is reached, read a string and print it out. </p>
",4
9141761,9141750,11,"<blockquote>
  <p>Why have buffers? First, it is less time-consuming to transmit several
  characters as a block than to send them one by one</p>
</blockquote>

<p>Let's say I'm your boss. I really like waffles but the store is 20 minutes away, and you have to run through zombie-infested badlands. So from time to time I send you to buy ONE. Wouldn't it be better if you could just buy ten at a time ?</p>
",6
9859249,9859224,1,"<p>You are calculating the middle number in a wrong way, for example, if we put the values that you gave (254 34 199)in your calculation:</p>

<pre><code>int mid = imax(imax(254, 34), imin(34, 199));
</code></pre>

<p>we get:</p>

<pre><code>int mid = imax(254, 34);
</code></pre>

<p>which is:</p>

<pre><code>int mid = 254;
</code></pre>

<p>instead of 199.</p>
",5
9859276,9859224,0,"<p>The problem has already been pointed out by Binyamin. Here's a pointer to an alternative, probably better solution: <a href=""http://en.wikipedia.org/wiki/Bubble_sort"" rel=""nofollow"">bubble sort</a>. The case for three integers won't require any loops at all.</p>
",4
9858744,9856463,-1,"<p>Since what you need is the smallest and the largest of three numbers, you can create two functions, one that returns the smallest value and one that returns the largest value; then you print the results.</p>

<p>Note:  It is a good idea to compartmentalize your code.  Have small functions to do one little task at a time. You will find that it is easier to create code in this way and other people will appreciate that when they have to read your program.</p>

<pre><code>#include &lt;stdio.h&gt;

int smallestVal(int val1, int val2, int val3);
int largestVal(int val1, int val2, int val3);

int main()
{
 //Assuming these are your numbers:
 int first=7;
 int second=4;
 int third=5;

 int smallest=0;  //These are what you aiming for
 int largest=0;

 smallest = smallestVal(first, second, third);
 largest = largestVal(first, second, third);

 printf(""smallest=%d  largest=%d\n"", smallest, largest);
 return 0;
}

int smallestVal(int val1, int val2, int val3)
{
 int smallest = val1;

 if (val2 &lt;= smallest)
 smallest = val2;

 if(val3 &lt;= smallest)
 smallest = val3;

 //continue adding more if... you need so.
 //but remember to add more arguments to your function.

 return smallest;
}

int largestVal(int val1, int val2, int val3)
{
    int largest = val1;

    if(val2 &gt;=largest)
    largest = val2;

    if(val3 &gt;= largest)
    largest = val3;

    //continue adding more if... you need so.
    //but remember to add more arguments to your function.

    return largest;
}
</code></pre>
",3
17085283,17085189,3,"<p>just keep on calling strtok</p>

<pre><code>char* name = strtok(str, ""|"");
char* surname = strtok(NULL, ""|"");
...
</code></pre>
",0
17085298,17085189,6,"<p>If the format is constant, you can use <code>sscanf()</code>:</p>

<pre><code>char fname[32], lname[32], city[32], zip[16], country[8];

if(sscanf(str, ""%31[^|]|%31[^|]|%31[^|]|%15[^|]%7s"",
               fname, lname, city, zip, country) == 5)
{
}
</code></pre>

<p>This uses the <code>%[]</code> character set format specifier to grab ""everything except a vertical bar"". The width is included to prevent buffer overruns.</p>
",1
17085306,17085189,2,"<p>You can use sscanf with that (it can scan strings up to a given delimiter)</p>

<pre><code>int n; 
char fname[128]= """", lname[128]= """", city[128]= """", zipcode[128]= """", country[128]= """";
n= sscanf str(""%127[^|]|%127[^|]|%127[^|]|%127[^|]|%127s"", fname, lname, city, zipcode, country); 
if (n==5) {  // five fields scanned

}
</code></pre>
",0
17085360,17085189,3,"<p><code>strtok</code> returns a pointer to the token; pass NULL as the first argument to retrieve successive tokens:</p>

<pre><code>#define FIELD_LENGTH 20
#define NUM_FIELDS    5
...
char target[NUM_FIELDS][FIELD_LENGTH];
int field = 0;
...
while ( get_next_string( str )) // where get_next_string retrieves your next
{                                // delimited string
  char *token = strtok( str, ""|"" );
  while ( token )
  {
    strcpy( target[i++], token );
    token = strtok( NULL, ""|"" );
  }
}
</code></pre>

<p><strong>Edit</strong></p>

<p>To address Golgauth's comment, there are some important things to remember about using <code>strtok</code>:</p>

<ul>
<li>It modifies the input string by replacing each occurrence of the delimiter with a 0, meaning it cannot be used on a string literal.  If you want to preserve the original string, you will have to make a copy to pass to <code>strtok</code>;</li>
<li>It uses a single, static buffer to store the string it's modifying, making it <em>non-reentrant</em> - if multiple threads make calls to <code>strtok</code> to tokenize different strings, they'll wind up stepping on each other (this is known as a race condition, where the behavior of the program depends on which thread gets access to something first).  Also, you can't nest calls to strtok (that is, get a token, then split it into subtokens, then get the next token); </li>
</ul>

<p>The online 2011 standard mentions a safer (and IINM re-entrant) alternative, <code>strtok_s</code>, as part of Annex K (Bounds-checking interfaces); some implementations also provide a <code>strtok_r</code>function which is re-entrant.  </p>
",2
17085384,17085189,12,"<pre><code>    char fname[32], lname[32], city[32], zip[32], country[32];

    strcpy(fname, strtok(str , ""|""));
    strcpy(lname, strtok(NULL, ""|""));
    strcpy(city , strtok(NULL, ""|""));
    strcpy(zip , strtok(NULL, ""|""));
    strcpy(country, strtok(NULL, ""|""));

    printf(""%s\n"", fname);
    printf(""%s\n"", lname);
    printf(""%s\n"", city);
    printf(""%s\n"", zip);
    printf(""%s\n"", country);
</code></pre>
",3
9185773,9185753,2,"<p>Your memory allocation is wrong it should be like this:</p>

<pre><code>str=(char*)malloc(sizeof(char)*count_of_chars);
</code></pre>

<p>Remember to set a value for <code>count_of_chars</code>.</p>
",5
9185861,9185753,2,"<p>Two problems.  First of all, you need to declare your <code>person</code> function above your main one.  So:</p>

<pre><code>void person();
void main() {
    ...
}

void person() {
    ...
}
</code></pre>

<p>Should work fine.  Second of all, the way you are using malloc, you are only going to get one <code>char *</code> of memory.  You need to do:</p>

<pre><code>str=(char*)malloc(sizeof(char)*stringLength);
</code></pre>

<p>where <code>stringLength</code> is the maximum amount of characters you want in your string.</p>
",4
10125686,10125542,3,"<blockquote>
  <p>is it just for ease of reading?</p>
</blockquote>

<p>No, it can also save you a lot of time compiling; when you change one source file, you only recompile that file, then relink, instead of recompiling everything. But the main point is dividing a program into a set of well-separated modules that are easier to understand and maintain than a single monolithic ""blob"".</p>

<p>For starters, try to adhere to Rob Pike's rule that <a href=""http://www.lysator.liu.se/c/pikestyle.html"" rel=""nofollow"">""data dominates""</a>: design your program around a bunch of data structures (<code>struct</code>'s, usually) with operations on them. Put all the operations that belong to a single data structure into a separate module. Make all functions <code>static</code> that need not be called by functions outside the module.</p>
",0
10125643,10125542,1,"<p>Well, I am not an expert, but I always try to think in entities larger that a function. If I have a group of functions which logically belongs together, I put it into a separate file. Usually, if the functionality is similar, and someone wants one of such functions, he would probably need some other functions from this group as well.</p>

<p>The need to split up the single file comes from the same reason why you are using different folders for your files: people want to have some logical organization on the numerous functions, so that they don't need to grep the huge single source file for finding the needed one. This way you can forget about the irrelevant parts of the program when you are thinking about/developing some fixed part of it.</p>

<p>One more reason for splitting could be that you can <em>hide</em> some internal function from the rest of the code by not mentioning it in the header. This way explicitly separate the inner functions (which are needed only inside the <code>.c</code> file) from the functions interesting to the outer ""universe"" of your program.</p>

<p>Some more higher-level languages have even extended the notion of ""function belonging together"" into ""functions working on the same thing, presented as one entity"" -- and called that a <em>class</em>.</p>

<p>Another historical reason for splitting is separate compilation feature. If your compiler is slow (this is often the case with C++, for example), splitting the code into several files means that if you modify only one location, the chances are high that only one file needs to be recompiled to pick up the changes. As the modern C compilers are not so slow in comparison to the typical processor speed, this may be not an issue for you.</p>
",0
10125766,10125542,2,"<p>Easy of reading is one point of breaking up files, but another is that when you build a project containing multiple files (header and source files) a good build system will only rebuild the files that have been modified thereby shortening build-times.</p>

<p>As for <em>how</em> to break up a monolithic file into multiple files, there are many ways to go. Speaking for me, I would try to group functionality, so for example all input handling is put in one source file, output in another, and functions that are used by many different function in a third source file. I would do the same with structures/constants/macros, group related structures/etc. in separate header files. I would also mark functions used only in a single source file as <code>static</code>, so they can't be used from other source files by mistake.</p>
",0
10125801,10125542,9,"<p>Well, that's exactly what you want : split your code in several libraries !</p>

<p>Let's take an example, in one file you have : </p>

<pre><code>#include &lt;stdio.h&gt;

int something() {
    return 42;
}

int bar() {
    return something();
}

void foo(int i) {
    printf(""do something with %d\n"", i);
}

int main() {
    foo(bar());
    return 0;
}
</code></pre>

<p>you can split this up to :</p>

<p>mylib.h:</p>

<pre><code>#ifndef __MYLIB_H__
#define __MYLIB_H__

#include &lt;stdio.h&gt;

int bar();
void foo();

#endif
</code></pre>

<p><em>N.B.: the preprocessor code above is called a ""guard"" which is used to not run twice this header file, so you can call the same include at several places, and have no compilation error</em></p>

<p>mylib.c:</p>

<pre><code>#include &lt;mylib.h&gt;

int something() {
    return 42;
}

int bar() {
    return something();
}

void foo(int i) {
    printf(""do something with %d\n"", i);
}
</code></pre>

<p>myprog.c:</p>

<pre><code>#include &lt;mylib.h&gt;
int main() {
    foo(bar());
    return 0;
}
</code></pre>

<p>to compile it you do :</p>

<pre><code>gcc -c mylib.c -I./
gcc -o myprog myprog.c -I./ mylib.o
</code></pre>

<p>now the advantages ?</p>

<ol>
<li>it enables you to split logically your code, and then find the
code unit faster</li>
<li>it enables you to split your compilation, and
recompile only what you need when you modified something (which is what the Makefile does for you)</li>
<li>it enables you to expose some functions and hide others (like the
""something()"" in the example above), and it helps documenting your APIs for people that will read your code (like your teacher) ;)</li>
</ol>
",2
10126130,10125542,2,"<p>Just to give you an idea.</p>

<p>create a file called print.c, put this inside:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

void print_on_stdout(const char *msg) {
   if (msg) fprintf(stdout, ""%s\n"", msg);
}
void print_on_stderr(const char *msg) {
   if (msg) fprintf(stderr, ""%s\n"", msg);
}
</code></pre>

<p>create a file called print.h, put this inside:</p>

<pre><code>void print_on_stdout(const char *msg);
void print_on_stderr(const char *msg);
</code></pre>

<p>create a file called main.c, put this inside:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include ""print.h""

int main() {
    print_on_stdout(""test on stdout"");
    print_on_stderr(""test on stderr"");

    return 0;
}
</code></pre>

<p>Now, for each C file, compile with:</p>

<pre><code>gcc -Wall -O2 -o print.o -c print.c
gcc -Wall -O2 -o main.o -c main.c
</code></pre>

<p>Then link compiled files to generate an executable:</p>

<pre><code>gcc -Wall -O2 -o test print.o main.o
</code></pre>

<p>Run ./test and enjoy.</p>
",3
10126869,10125542,4,"<blockquote>
  <p>is it just for ease of reading?</p>
</blockquote>

<p>The <em>main</em> reasons are </p>

<ul>
<li><p><strong>Maintainability:</strong> In large, monolithic programs like what you describe, there's a risk that changing code in one part of the file can have unintended effects somewhere else.  Back at my first job, we were tasked with speeding up code that drove a 3D graphical display.  It was a single, monolithic, 5000+-line <code>main</code> function (not that big in the grand scheme of things, but big enough to be a headache), and <em>every change we made</em> broke an execution path somewhere else.  This was badly written code all the way around (<code>goto</code>s galore, literally hundreds of separate variables with incredibly informative names like <code>nv001x</code>, program structure that read like old-school BASIC, micro-optimizations that didn't do anything but make the code that much harder to read, brittle as hell) but keeping it all in one file made the bad situation worse.  We eventually gave up and told the customer we'd either have to rewrite the whole thing from scratch, or they'd have to buy faster hardware.  They wound up buying faster hardware.  </p></li>
<li><p><strong>Reusability:</strong> There's no point in writing the same code over and over again.  If you come up with a generally useful bit of code (like, say, an XML parsing library, or a generic container), keep it in its own separately compiled source files, and simply link it in when necessary.</p></li>
<li><p><strong>Testability:</strong> Breaking functions out into their own separate modules allows you to test those functions in isolation from the rest of the code; you can verify each individual function more easily.  </p></li>
<li><p><strong>Buildability:</strong> Okay, so ""buildability"" isn't a real word, but rebuilding an entire system from scratch every time you change one or two lines can be time consuming.  I've worked on <em>very</em> large systems where complete builds could take upwards of several hours.  By breaking up your code, you limit the amount of code that has to be rebuilt.  Not to mention that any compiler is going to have <em>some</em> limits on the size of the file it can handle.  That graphical driver I mentioned above?  The first thing we tried to do to speed it up was to compile it with optimizations turned on (starting with O1).  The compiler ate up all available memory, then it ate all the available swap until the kernel panicked and brought down the entire system.  We <em>literally could not build</em> that code with any optimization turned on (this was back in the days when 128 MB was a <em>lot</em> of very expensive memory).  Had that code been broken up into multiple files (hell, just multiple <em>functions</em> within the same file), we wouldn't have had that problem.</p></li>
<li><p><strong>Parallel Development:</strong> There isn't an ""ability"" word for this, but by breaking source up into multiple files and modules, you can parallelize development.  I work on one file, you work on another, someone else works on a third, etc.  We don't risk stepping on each other's code that way.  </p></li>
</ul>
",0
17085296,17085185,1,"<p><code>int *c</code> stores the address of an integer variable but not an integer value. That's why you get an error/warning.</p>

<p><code>char *c={'q','w'}</code> is an invalid initialization in c. Because, pointers can point to a block of allocated memory. But there is no memory allocated for <code>{'q','w'}</code> itself in this way. </p>

<p>If you want you can use </p>

<pre><code>          `char *c=(char[]){'q','w'}`
</code></pre>

<p>Because, in this way no invalid initialization is done since <code>{'q','w'}</code> type converted into <code>char[]</code> which can be pointed by <code>c</code>.</p>

<blockquote>
  <p>Agree with your answer about char *c ,but by assigning char *c=""jay""
  here also I am defining an array as c={'j','a','y','\0'} so whats the
  basic difference between both these except a '\0'</p>
</blockquote>

<p>Since, the type of <code>{'w','q'}</code> is not resolved to <code>char[]</code>, when you use <code>char *p={'q','w'};</code>. But when you use <code>char *p=""hello""</code>, the type of <code>string literal</code> is resolved to be <code>char array</code>. That's how <code>C language</code> defines <code>string literals</code> they are stream of characters but not stream of <code>int</code> s or anything else.</p>

<p>When compiled, every such string literals are stored in static storage location and are perfectly a <code>char array</code> and hence can be pointed by <code>c</code> which is of type <code>char *</code>. But this is not the case with those array <code>{}</code> syntax.Because, {'q','w'} can be an integer array also with out first converting it to char[], how is it eligible for assignment for something that is <code>char *</code>? For example, <code>int p[]={'1','2'}</code> compiles fine. Because pointer arithmetic for is affected by their type which is affected by the <code>type</code>s <code>size</code>.<code>{'1','2'}</code> takes <code>2*sizeof(int)</code> if it is an <code>int</code> array and <code>2*sizeof(char)</code> if it is a <code>char</code> array.</p>
",3
17085590,17085185,2,"<pre><code>char *c={'q','w'};
</code></pre>

<p>doesn't work because <code>c</code> isn't an array, and you can't use array initializer syntax on a non-array object.</p>

<pre><code>char *c=123;
</code></pre>

<p>doesn't work because you're attempting to convert an integer value (<code>123</code>) to a pointer without a cast; note that</p>

<pre><code>char *c = (char *) 123;
</code></pre>

<p>would ""work"" in the sense that the initialization would succeed, although <code>123</code> is most likely <em>not</em> a valid memory address.</p>

<pre><code>char *c = ""jayesh"";
</code></pre>

<p>works because string literals like <code>""jayesh""</code> are array expressions, and under most circumstances an array expression will be converted to a pointer expression, and the expression's value will be the address of the first element of the array.  The exceptions to this rule are when the array expression is the operand of the <code>sizeof</code> or unary <code>&amp;</code> operators, or is a string literal being used to initialize another array in a declaration. </p>

<p>So what's happening is that the address of the first character (<code>'j'</code>) is being assigned to <code>c</code>.  </p>

<p>If your declaration had been</p>

<pre><code>char c[] = ""jayesh"";
</code></pre>

<p>then <code>c</code> would be created as a 7-element array of <code>char</code>, and the *contents * of the string literal would be copied to it.  </p>
",0
17085632,17085185,0,"<p>Most pointers to the type used to determine the char array. And to be precise, the array - this is a pointer / offset. When you create a variable <code>char *ch</code> this is equivalent to <code>char ch[]</code>but you can not define a variable. You must specify a fixed size for the array. <code>char ch[256]</code> and this is the C string. Suppose you have created a variable and write string <code>char ch[256] = ""qwerty"";</code> You can refer to any character. <code>ch[2]</code>(they return ""e""). In this case ch - is a pointer to the start of array. And <code>ch[2]</code> sets the offset to the 2 bytes size of char.</p>
",1
11501914,11501810,1,"<pre><code>if((strcmp(*(src_ip[j],ip[idx]) == 0) &amp;&amp; (strcmp(*(dest_ip[j]),ip[idx]) == 0))
                     ^^
</code></pre>

<p>You can't have both <code>*(src_ip[j])</code> and <code>*(dest_ip[j])</code> equal to <code>ip[idx]</code>. What you meant to use was the <code>||</code> operator instead of <code>&amp;&amp;</code>. (By the way, there's a missing <code>)</code> where I marked above)</p>

<p>Also your <code>while(idx)</code> doesn't make sense. Are you controlling the loop with the <code>for</code> above, or the <code>while</code> below? If with the <code>while</code>, then you'll get an infinite loop if the condition is true since you are never changing it inside the loop.</p>
",2
18983232,18973029,1,"<p>Q: Is there any simple way to make the program actually work in 64-bit numbers like I wanted it to?<br>
A: Use <code>int64_t</code> and <code>""%"" SCNx64</code>.</p>

<p>If you:<br>
want 32-bit integers, use type <code>int32_t</code>.<br>
want 64-bit integers, use type <code>int64_t</code>.<br>
use <code>int</code>, the range is at <em>least</em> <code>-32767</code> to <code>+32767</code>.<br>
use <code>long</code>, the range is at <em>least</em> <code>-2147483647</code> to <code>+2147483647</code>.<br>
use <code>long long</code>, the range is at <em>least</em> <code>-9223372036854775807</code> to <code>+9223372036854775807</code>.  </p>

<p>With <code>scanf()</code> use the matching format specifier:  </p>

<pre><code>int               ""%d""  
long              ""%ld""  
long long         ""%lld""  
int32_t           ""%"" SCNx32  
int64_t           ""%"" SCNx64  
</code></pre>
",0
11105148,11105070,3,"<p>The first, <code>*ptr++;</code>, increments the pointer and evaluates to the value the pointer pointed to before the increment.</p>

<p>The second, <code>++*ptr;</code>, dereferences the pointer and increments the pointed to value, its value is the incremented value.</p>

<p>The third, <code>(*ptr)++</code>, dereferences the pointer and increments the pointed-to value, its value is the pointed-to value before the increment.</p>

<p>Consider e.g. <code>int arr[4] = { 1, 2, 3, 4 };</code> and <code>ptr = &amp;arr[1];</code>.</p>

<ul>
<li>After <code>int val = *ptr++;</code>, the pointer <code>ptr</code> points to <code>arr[2]</code> and <code>val</code> is 2.</li>
<li>After <code>int val = ++*ptr;</code>, the pointer <code>ptr</code> still points to <code>arr[1]</code>, <code>arr[1]</code> is incremented, so now its value is 3, and so is <code>val</code>.</li>
<li>After <code>int val = (*ptr)++;</code>, the pointer still points to <code>arr[1]</code>, <code>arr[1]</code> is incremented, so its value is now 3, but <code>val</code> has the old value of <code>arr[1]</code>, 2.</li>
</ul>
",0
11105227,11105070,1,"<p>The first one will is equivalent to <code>*(ptr++)</code> which will will return a temporary pointer with it's current value and then increment ptr.</p>

<p>The second one will increment the value pointed to by <code>ptr</code> (assuming it is a type with <code>++</code> defined) and return the incremented value</p>

<p>The third one will return the current value pointed to by <code>ptr</code> and then increment <code>ptr</code></p>

<p>Ex.</p>

<pre><code>int a = 0;
int * ptr = &amp;a;
int b = *ptr++;
</code></pre>

<p>a = 0, b = 0, but <code>ptr</code> will point to nonsense.</p>

<pre><code>int a = 0;
int * ptr = &amp;a;
int b = ++*ptr;
</code></pre>

<p>a = 1, b = 1</p>

<pre><code>int a = 0;
int * ptr = &amp;a;
int b = (*ptr)++;
</code></pre>

<p>a = 1, b = 0</p>
",1
9780959,9780930,-1,"<p>Silly, subtle error.  Use ""printf (""%lf"", gross)"" in both places and I'll bet the problem goes away :)</p>
",3
9780965,9780930,4,"<p>The most likely problem is that you have not declared <code>calcGross</code> prior to using it, in which case the compiler would assume default return type (<code>int</code>). Try placing the <code>calcGross()</code> definition before using it.</p>
",0
9780986,9780930,4,"<p>The problem is that you haven't given a declaration or prototype for the <code>calcgross()</code> function before it's being called in your first example.</p>

<p>Without having seen a declaration/prototype for the function the C compiler will assume that it's returning an <code>int</code>, not <code>double</code>, so things go terribly wrong.</p>

<p>Place the following line somewhere before you call the function (ideally in a header that you include):</p>

<pre><code>double calcGross(double rate, double hours);
</code></pre>

<p>Using the <code>-Wall</code> compiler option would give you the following warning about this:</p>

<pre><code>test.c:73:5: warning: implicit declaration of function 'calcGross' [-Wimplicit-function-declaration]
</code></pre>
",1
10153590,10153443,0,"<p>I think you got a problem in your <code>canwin()</code> function, as I understand it, you want the A.I. to test if it can make a winning move. But looking at the function</p>

<pre><code>int canwin(void)
{
    int rownumber,colnumber;
    for(rownumber=0;rownumber&lt;3;rownumber++)
    {
        for(colnumber=0;colnumber&lt;3;colnumber++)
        {
            board[rownumber][colnumber]='X'; // &lt;--- Problem here
            if(checkwin('X')==1)
            {
                return 1;
            }
            board[rownumber][colnumber]=' ';
        }
    }
    return 0;
}
</code></pre>

<p>You are actually overwriting current position of your board with an <code>'X'</code>, without checking if there already was a symbol there before! So you are essentially overwriting your board with <code>'X'</code>es, checking if the X-player won and if not ""resetting"" to empty space <code>' '</code>!</p>

<p>You can fix this by inserting a check before your write like this:</p>

<pre><code>if (board[rownumber][colnumber] == ' ')
{
    board[rownumber][colnumber]='X';
    ...
</code></pre>
",4
9848804,9848781,2,"<p>This line:</p>

<pre><code>     string[j] = entered;
</code></pre>

<p>does not copy characters from <code>entered</code> to <code>string[j]</code>; rather, it sets <code>string[j]</code> to point to the memory location of the <code>entered</code> array.</p>

<p>You need to allocate memory for the strings in your <code>string</code> array, by writing (e.g.):</p>

<pre><code>char string[5][11];
</code></pre>

<p>instead of</p>

<pre><code>char *string[5];
</code></pre>

<p>and then you need to copy characters from <code>entered</code> from <code>string[j]</code> by writing (e.g.):</p>

<pre><code>     strcmp(string[j], entered);
</code></pre>
",0
10135154,10135107,0,"<p>struct Data_point *a is your function arugument and you are passing data which is a array. So basically you are trying to acess members from a array which is not a struct.</p>

<p>May be </p>

<pre><code>for( int i=0; i&lt;10;++i)
    filldata(data[i],.....)
</code></pre>

<p>and </p>

<pre><code>int filldata( struct Data_point a,...) //as you are using a.
</code></pre>
",2
10135159,10135107,1,"<p>One problem is that the <code>filldata()</code> is taking a pointer argument.  So you use <code>-&gt;</code> to address members not ""."".  So <code>a.sampleNumber</code> should be <code>a-&gt;sampleNumber</code> for example.</p>

<p>Another issue is that <code>filldata()</code> is reading in a single struct, but you are passing it the pointer to the top of the array, which is synonymous with <code>&amp;(data[0])</code>.  So this function will just overwrite that first element if you call it repeatedly (which you didn't).  If you call it in a loop you will need to pass it in pointers to the individual array members:</p>

<p><code>for(int i = 0; i &lt; 10; ++i){
  filldata(&amp;(data[i]), ""/home/alexchan/IntrotoC/rec11/dataPoints.txt"");
}</code></p>

<p>You could actually use <code>data + i</code> as the first arg instead of <code>&amp;(data[i])</code> but I like the latter as I find it more readable.</p>
",9
10135516,10135107,0,"<p>fscanf requires a pointer-to-data for each passed argument. Use the <code>AddressOf</code> operator <code>&amp;</code> to get a reference to each struct member:</p>

<pre><code>int filldata(const char *filelocation, struct Data_point *a, int nElements)
{
    int n = 0;
    FILE *f = fopen(filelocation, ""r"");
    if(f)
    {
        while (fscanf(f, ""(%ld,%lf,%d)"", &amp;(a[n].sampleNumber), &amp;(a[n].value), &amp;(a[n].status)) == 3 &amp;&amp; n &lt; nElements)
             n++;
        fclose(f);
    } 
    else { printf(""Unable to open '%s'\n"", filelocation); }
    return n;
}
</code></pre>

<p>Now, this function is slightly different to yours. You need to tell it how long the array you're passing in as the ""a"" parameter is. It will return the number of successfully filled entries.</p>

<p>i.e</p>

<pre><code>int main(int argc, char **argv)
{
    struct Data_point data[10];
    int n = filldata(""C:\\Users\\254288b\\temp.txt"", data, sizeof(data) / sizeof(struct Data_point));
    printf(""%d Data_point's were filled successfully.\n\n"", n);
    for(int i = 0; i &lt; n; i++)
    {
        printf(""Sample Number: %ld\n"", data[i].sampleNumber);
        printf(""Value: %lf\n"", data[i].value);
        printf(""Status: %d\n"", data[i].status);
        printf(""----------------------------\n"");
    }
    return 0;
}
</code></pre>

<p>Do note, my pattern for fscanf expects your file to be like:</p>

<p><code>(100,1.1,10)(200,2.2,20)(300,3.3,30)(400,4.4,40)</code></p>

<p>Each set is enclosed in parenthesis.</p>
",0
10148270,10148186,5,"<p>@cnicutar is pretty close, but you apparently only want to start reading at something other than white-space, and want to stop reading a single word when you get to whitespace, so for you scanset, you probably want something more like:</p>

<pre><code>while(scanf("" %49[^ \t.\n]%*c"", i)) {
</code></pre>

<p>In this, the initial space skips across any leading white space. The scan-set then reads until it gets to a space, tab, new-line or period. The %*c then reads (but throws away) the next character (normally the one that stopped the scan).</p>

<p>This can, however, throw away a character when/if you reach the end of the buffer, so you may want to use %c, and supply a character to read into instead. That will let you recover from a single word longer than the buffer you supplied.</p>
",0
10148208,10148186,-1,"<p>The easiest way to do this is with <a href=""http://westes.github.io/flex/manual/"" rel=""nofollow noreferrer"">flex</a>. Otherwise you are repeating a bunch of difficult, complex work, and are likely to make mistakes.</p>

<p>Also, read <a href=""http://shop.oreilly.com/product/9781565920002.do"" rel=""nofollow noreferrer"">lex and yacc, 2nd edition</a>. </p>
",3
10148220,10148186,4,"<p>How about:</p>

<pre><code>scanf(""%49[ ^\n.]"", str)
</code></pre>

<p>Or something like that.</p>
",4
10149051,10148186,2,"<p>Ditch <code>scanf</code> altogether and go with <code>fgets</code>:</p>

<pre><code>while (fgets(i, sizeof i, stdin))
{
  printf(""you've written: %s\n"", i);
}
</code></pre>

<p>with the following caveats:</p>

<ol>
<li><p>If there's room in the target buffer, <code>fgets</code> will store the trailing newline as part of the input;</p></li>
<li><p>If you want to stop reading on finding a <code>.</code>, you'll have to add some logic to look for it in the input string, such as the following:</p></li>
</ol>

<pre><code>
    int foundDot = 0;
    while (fgets(i, sizeof i, stdin) && !foundDot)
    { 
      char *dot = strchr(i, '.');
      char *newline = strchr(i, '\n');

      if (dot != NULL)
      {
        foundDot = 1;
        *dot = 0; // overwrite the '.' character with the 0 terminator
      }

      if (newline != NULL)
      {
        *newline = 0; // overwrite newline character with 0 terminator
      }

      /**
       * Assuming you don't want to print a blank line if you find a dot
       * all by itself. 
       */
      if (strlen(i) > 0) 
        printf(""you've written: %s\n"", i);
    }</code></pre>
",0
10118006,10117977,6,"<p>After the preprocessor is done, your code looks like:</p>

<pre><code>double eval(double p[], double x, int 5)
</code></pre>

<p>So there's still the missing <code>;</code> at the end of that line, and that <code>5</code> makes no sense there.</p>

<p>Don't define such short macro names, and don't have formal parameter names that are also <code>#define</code>. Make sure you only use <code>N</code> in all your code where the global constant is meant.</p>

<p>Also, to pass the <code>p</code> array as a parameter, just say <code>p</code>, not <code>p[]</code>.</p>
",0
10118010,10117977,1,"<pre><code>#define N 5

double eval(double p[], double x, int N)
</code></pre>

<p>Since you #defined N to be 5, the above will look like this after preprocessing:</p>

<pre><code>double eval(double p[], double x, int 5)
</code></pre>

<p>Obviously that's wrong. Also function declarations need to be terminated with a semicolon.</p>
",4
11492626,11492576,1,"<pre><code>++a[""Gyantonic""]
</code></pre>

<p>means that you are trying to increment the a-th (hence, the 1-st, which is not the first but the <em>second</em>, C strings beginning at 0) character of ""Gyantonic"".</p>

<p>And since ""Gyantonic"" is a read only constant string, none of its character may be incremented, and you get a segmentation fault.</p>

<p>In gcc with warnings enabled you get:</p>

<pre><code> warning: increment of read-only location ¡®""Gyantonic""[a]¡¯ [enabled by default]
</code></pre>

<p>The intended output is apparently ""z"" (the ""y"" in Gyantonic incremented by 1). To do this you should write:</p>

<pre><code>    char string[] = ""Gyantonic"";
    const int a=1;
    printf(""%c"", ++a[string]);
</code></pre>

<p>Note that this is not the same as writing</p>

<pre><code>    char *string = ""Gyantonic"";
</code></pre>

<p>The first version creates an array and initializes (COPIES) in this writeable array the existing, readonly string ""Gyantonic"". The second version creates a <em>pointer</em>, a <em>label</em> to the existing, readonly string ""Gyantonic"".</p>

<p>Writing to the writeable copy string[] is allowed; writing to the readonly pointed by *string will segfault.</p>
",0
11492631,11492576,7,"<pre><code> ++a[""Gyantonic""]
</code></pre>

<p>is equivalent to:</p>

<pre><code>++(a[""Gyantonic""])
</code></pre>

<p>which is equivalent to </p>

<pre><code>++(""Gyantonic""[a])
</code></pre>

<p>equivalent to</p>

<pre><code>++(""Gyantonic""[1])
</code></pre>

<p><code>""Gyantonic""[1]</code> yields <code>'y'</code> and the <code>++</code> increments the <code>'y'</code> stored in the string literal and yields the result. But <code>""Gyantonic""</code> is a string literal and string literals cannot be modified. This is why you get the segmentation fault.</p>
",0
11492594,11492576,1,"<p>In C, the expression <code>x[y]</code> is exactly equal to <code>*(x+y)</code>.  Since addition is commutative, that means you can also write it as <code>y[x]</code>, which is <code>*(y+x)</code>, the same thing.</p>
",2
10132790,10132706,1,"<p>I don't understand how your function works. Try this instead:</p>

<pre><code>int getByte(int x, int n)
{
     return (x &gt;&gt; (8 * n)) &amp; 0xFF;
}
</code></pre>
",0
10132793,10132706,14,"<p>Your shifting doesn't make any sense - first, you shift left by (24 - 8n) bits, then you shift back right by 8n bits. Why? Also, it's wrong. If n is 0, you shift x left by 24 bits and return that value. Try pen and paper to see that this is entirely wrong.</p>

<p>The correct approach would be to do:</p>

<pre><code>int getByte(int x, int n) {
  return (x &gt;&gt; 8*n) &amp; 0xFF;
}
</code></pre>
",2
10132997,10132706,7,"<p>Unless i am totally mistaken, your code is mathematically incorrect.</p>

<pre><code>getByte(0x000000ff, 0) {
    24 - 8 * n = 24;
    8 * n = 0;
    0x000000ff &lt;&lt; 24 = 0xff000000;
    0xff000000 &gt;&gt; 0 = 0xff000000;
    return 0xff000000; // should return 0xff
}
</code></pre>

<p>Not being allowed to use operators <code>-</code> and especially <code>*</code> is a problem (can't do <code>* 8</code>). I came up with this:</p>

<pre><code>uint8_t getByte (uint32_t x, int n) {
    switch (n) {
        case 0:
            return x &amp; 0xff;
        case 1:
            return (x &gt;&gt; 8) &amp; 0xff;
        case 2:
            return (x &gt;&gt; 16) &amp; 0xff;
        case 3:
            return x &gt;&gt; 24;
    }
}
</code></pre>

<p>Not exactly beautiful, but it conforms to the problem description: 6 operators, all of them legal.</p>

<p>EDIT: Just had a (pretty obvious) idea for how to avoid <code>* 8</code></p>

<pre><code>uint8_t getByte (uint32_t x, int n) {
    return (x &gt;&gt; (n &lt;&lt; 3)) &amp; 0xff;
}
</code></pre>
",3
10164930,10164907,3,"<p>By elimination, it's likely <code>compileTerm</code> returns <code>void</code>.</p>
<h3>EDIT</h3>
<p>You added <code>compileTerm</code> but now <code>compileFactor</code> is missing.</p>
",8
11811987,11811975,8,"<p>Trying to apply <code>static</code> to an argument doesn't make much sense, so the standard doesn't allow it (¡ì6.7.5.3/2: ""The only storage-class specifier that shall occur in a parameter declaration is <code>register</code>."")</p>
",4
11811993,11811975,12,"<p>The static keyword means that a variable may have only and exactly one instance in its scope, and that instance is invisible out of its scope. Neither of these requirements make sense for a function argument: it may be called multiple times, at a different memory address, and as it's meant for communication, it has to be visible to the outer world.</p>
",10
11860144,11859627,6,"<blockquote>
  <p>what difference does it make if we write b=5 or *(&amp;b)=5?</p>
</blockquote>

<p>The second one gets a pointer to <code>b</code> and then dereferences that pointer, storing 5 into the obtained pointer.</p>

<p>However, your question seems to be ignoring the <em>real</em> question: why it works in the second case but not the first. And that has to do with expressions in C and how they're dealt with.</p>

<p>The result of the <code>?:</code> operator is a value; specifically, it is an <em>rvalue</em>. Loosely defined, an rvalue is a value that can't go on the left-hand side of an assignment. They are so named because they're values that go on the right-hand side of an assignment. For example, the expression ""5"" is an rvalue expression. You can't do <code>5 = 40;</code> that's nonsense.</p>

<p>A named variable is an lvalue. You can put an lvalue on the left-hand side of an equation. The expression <code>a</code> is an lvalue expression (assuming that <code>a</code> is a variable name that is in scope).</p>

<p>However, the expression <code>(a + b)</code> is an <em>rvalue expression</em>, not an lvalue. And with good reason; you can no more do <code>(a + b) = 30;</code> than you could <code>(5 + 10) = 30;</code>.</p>

<p>The result of the <code>?:</code> operator is an rvalue expression, just as with the <code>+</code> operator above. This explains why <code>(a?b:c) = 5;</code> doesn't work; you're trying to assign a value to an rvalue expression. That's illegal.</p>

<p>Now, let's look at the second case. We know that <code>?:</code> results in an rvalue expression. Now, that explains what the classification of the expression is, but what about the <em>type</em> of the expression's result? Well, assuming that <code>b</code> and <code>c</code> are both <code>int</code>s, the <em>type</em> of <code>(a?b:c)</code> is also <code>int</code>.</p>

<p>However, when you do <code>(a?&amp;b:&amp;c)</code>, the type of this expression is <em><code>int*</code></em>, not <code>int</code>. It is a <em>pointer</em> to an integer. It's an rvalue expression of type ""pointer to <code>int</code>."" It will return either the address of <code>b</code>, or the address of <code>c</code>.</p>

<p>When you have an <code>int*</code>, and you dereference it with the <code>*</code> operator, what do you get? You get an <strong><em>lvalue expression</em></strong> of type <code>int</code>. Since <code>(a?&amp;b:&amp;c)</code> is an rvalue expression of type <code>int*</code>, if you dereference it, you will get an lvalue expression of type <code>int</code>. This lvalue will refer to either <code>b</code> or <code>c</code>, depending on the contents of <code>a</code>.</p>

<p>To put it simply, it works exactly like this:</p>

<pre><code>int *ptr = NULL;
if(a)
  ptr = &amp;b;
else
  ptr = &amp;c;

*ptr = 5;
</code></pre>

<p>You get a pointer, which could point to any particular memory location, then you store something in the location being pointed to. It's that simple.</p>
",1
11155680,11155625,6,"<p>The reason is that the code tries to read all the input until the end of file. If this program was reading from a file, it would know when it ended, but since it's reading from console, you have to explicitly tell it that the input is over. On Linux you do this by pressing <code>^D</code> (Ctrl+D), on Windows <code>^Z</code> (Ctrl+Z).</p>

<p>Note that it has to be done at the start of a new line, i.e. after pressing <code>Enter</code>, you press <code>^D</code> (<code>^Z</code> on Win).</p>

<blockquote>
  <p>I am reading PrenticeHall. The Ansi C Programming Language - 2nd
  Ed.Kernighan,Ritchie.</p>
</blockquote>

<p>That's a very good book you're reading. It's that good, I guess, it contains the answer to your question.</p>
",0
11155685,11155625,5,"<p>Both of your programs work, you just need to enter <code>EOF</code> as I indicated in the first comment below your question. That is <code>^D</code> (Control-D) under Linux and <code>^Z</code> (Control-Z) under Windows.</p>

<p>Notice both conditions in the loop are looking for <code>EOF</code> not  or some other input to terminate. Once you provide this input the loop is terminated and your count is displayed.</p>
",0
11155705,11155625,3,"<p>You should stop the input taping `EOF' character (Ctrl+D on GNU/Linux).</p>
",0
11155746,11155625,2,"<p>My compiler (GCC 4.4) quibbles over the code you have posted.  This eliminates the quibbling:</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    int nc;
    for (nc = 0; getchar() != EOF; ++nc)
        ;
    printf(""%d\n"", nc);
    return 0;
}
</code></pre>

<p>Other answers are right, though:  you must end your keyboard input with Ctrl-D or -Z.</p>

<p>I am not sure why Kernighan and Ritchie have used the <code>double</code> in this context, incidentally.</p>
",0
12337882,12337836,2,"<p>Change the function prototype to accept an <code>int*</code></p>

<pre><code>void pointer_shift(int *a, int n) 
</code></pre>

<p>and then access array elements like this</p>

<pre><code>*(a+1) = 4;
</code></pre>

<p>which is the same as</p>

<pre><code>a[1] = 4;
</code></pre>

<p>you can still call it the same way using the array variable since arrays decay to a pointer to their first element when passed as a parameter to a function</p>
",0
12337916,12337836,-1,"<p>Your first function is already pointer-based. When you define a function parameter of type <code>int[]</code>, the compiler treats it the same as if you defined a pointer type <code>int*</code>. So the function can be passed either a pointer or an array (which will be automatically cast to a pointer).</p>

<p>If you change the function prototype to accept <code>int *a</code> instead of <code>int a[]</code>, the function will work exactly the same.</p>

<p>Your second function doesn't work because it expects an array of pointers to int, which isn't what you want.</p>
",0
12337946,12337836,0,"<pre><code>int main(void) {
    printf(""Begin execution of testing Problem 1\n"");
    int a1[] = {100, 101, 102};
    int *array_of_pointers[3];
    int i;

   array_of_pointers[0]= &amp;a1[0];
   array_of_pointers[1]= &amp;a1[1];
   array_of_pointers[2]= &amp;a1[2];

   for(i = 0; i&lt;3;i++)
       printf(""Before Shift: "" ""%d %p\n "", a1[i], array_of_pointers[i]);

/*
  same as passing a1, the address of the array is
  the same value as the value of the array, just a different type
*/
   pointer_shift(array_of_pointers, 3);
   printf(""After Shift, note that array_of_pointers has not shifted:\n"");
   for(i = 0; i&lt;3;i++)
       printf(""After Shift In Main: "" ""%d %p\n"", a1[i], array_of_pointers[i]);
   return 0;
}
</code></pre>

<p>pointer_shift
expects an array of pointers, not an array of int.
the ""shift"" here is not in the array, but rather in the values of what 
the elements in the array are pointing to, 
the values of the elements of the array remain the same!</p>
",0
12337865,12337836,3,"<p>Change your pointer based function like this:</p>

<pre><code>void pointer_shift(int *a, int n) {
   int i;
   for (i = 0; i != n - 1; i++) {
      *(a+i) = *(a+i+1);
   }
}
</code></pre>

<p>What you are receiving is an array of pointers whereas you pass an array from <code>main</code>. Since an array decays into pointer, calling <code>shift(a1, 3)</code> is sufficient here. </p>
",0
15581072,15581037,1,"<pre><code>a = b = c;
</code></pre>

<p>is same as</p>

<pre><code>a = (b = c);
</code></pre>

<p>which is valid in your two examples. </p>

<p><em>But such cast can overflow, which would be UB, is it right?</em></p>

<p>There is no cast, but an implicit conversion from one type to another. 
When converting a value of type <code>unsigned int</code> to <code>int</code>, if the <code>unsigned int</code> value is not representable in an <code>int</code>, the result of the conversion is either implementation-defined or a implementation-defined behavior signal is raised. Strictly speaking this is still not an overflow and this is not undefined behavior.</p>
",6
18796809,18796794,2,"<p>test2 is actually a terminated string so one more char for this '\0' so the size is 4. </p>

<pre><code> test2[] = { 'a', 'b', 'c', '\0' };
</code></pre>
",0
18796844,18796794,2,"<p>String literals are arrays that have an implicit additional, final element with value zero. That's the convention used by various <code>str</code>-functions (e.g. in <code>&lt;string.h&gt;</code> to tell then end of a string even if you only give them a pointer to the beginning.</p>

<p>Colloquially, we say that ""C strings are null-terminated"", even though C doesn't really have strings - just arrays of characters with some conventions. (The conventions are rather brittle, as you just demonstrated yourself: You can pass both <code>test1</code> and <code>test2</code> to a string function, with varying levels of disastrous results.)</p>
",1
11141044,11140935,2,"<p><code>i</code> will always be <code>&gt;=0</code>because it is declared as <code>unsigned</code> and thus interpreted as an unsigned integer.
So your first test will always be false.</p>

<p>Your call <code>foo(bar)</code> actually converts an <code>int</code> into an <code>unsigned int</code>. This may be what confuses you. And ""conversion"" does not actually change the bytes/bits value of your integer, it is just a matter of formal typing and interpretation.</p>

<p>See this <a href=""https://stackoverflow.com/questions/11123014/what-is-the-deal-with-assigning-an-unsigned-variable-to-a-signed-value/11123205#11123205"">answer</a> for examples of signed/unsigned conversions.</p>

<p>Here is a simple example (the exact output depends on the number of bytes of an <code>unsigned int</code>on your system, for me it is 4 bytes).</p>

<p>Code:</p>

<pre><code>printf(""%u\n"", (unsigned int) -2);
</code></pre>

<p>Output:</p>

<pre><code>4294967294
</code></pre>
",0
11140971,11140935,13,"<p>An unsigned int cannot be less than 0 by definition. So, to more directly answer your question, you're right in thinking that this makes no sense. It is not a meaningful security item either unless you encounter something like a loop that accidently decrements a signed int past 0 and then casts it as an unsigned int for use as an index into an array and therefore indexes memory outside of the array.</p>
",1
11106776,11106739,0,"<p>The meaning of the <code>main</code> function is part of the language specification.<br>
The compiler has special code to handle it.</p>
",0
11106788,11106739,1,"<p>Generally, the operating system defines an entry point (on Unix, it's genrally the <code>start</code> function), which is automatically called by the operating system (in particular, the loader). Your C compiler is supplied with a minimal runtime setup (again, on Unix, it's most likely called <code>crt0.o</code>), which is a precompiled object file, that sets up the C library internals then calls your main() function. So the compiler has nothing to do with it; it's crt0.o and the operating system that does the job.</p>
",0
11106812,11106739,0,"<p>When a copiler generates an application there are two main parts to the code:</p>

<ol>
<li>The OS glue code</li>
<li>The application that was written by the programmer (including main)</li>
</ol>

<p>The generated application when run executes the OS glue code then calls the function main. Thus when the compiler is generating the code for the application if it can not find the function main will fail to compile. If it finds it then it knows its address and thus how to call it.</p>

<p>There is nothing else really special about main (apart from the compiler looks for it).</p>
",0
11106841,11106739,1,"<p>It's defined in neither. <code>main</code> is not actually a keyword in C - it's just a regular function.</p>

<p>The standard C library includes a function, which sets up the initial environment (collects <code>argc</code>, <code>argv</code> and so on) and calls your <code>main</code> function.</p>

<p>The linker then puts the location of that function in the object file as the entry point.</p>

<p>You can see <code>glibc</code>'s entry point here:
<a href=""http://fossies.org/dox/glibc-2.15/dl-init_8c_source.html"" rel=""nofollow"">http://fossies.org/dox/glibc-2.15/dl-init_8c_source.html</a></p>
",0
11106929,11106739,0,"<p><code>Call stack</code> stores the information of active subroutines of a computer program.Since, Main() function is already defined  by compiler.So,it should be stored in a datastructure similar to call stack.please look at this link 
     <a href=""http://en.wikipedia.org/wiki/Call_stack"" rel=""nofollow"">http://en.wikipedia.org/wiki/Call_stack</a>
Hope this helps.</p>
",0
11107011,11106739,0,"<p>C allows two different types of execution environments: <em>Freestanding</em> and <em>Hosted</em>. Refer 
5.1.2/1:</p>

<blockquote>
  <p>Two execution environments are defined: freestanding and hosted. In both cases,
  program startup occurs when a designated C function is called by the execution
  environment.</p>
</blockquote>

<p>However:</p>

<blockquote>
  <p>The manner and timing of such initialization are
  otherwise unspecified. Program termination returns control to the execution
  environment.</p>
</blockquote>

<p>In a freestanding environment (think of embedded systems) as per 5.1.2.1/1:</p>

<blockquote>
  <p>In a freestanding environment (in which C program execution may take place without any
  benefit of an operating system), the name and type of the function called at program
  startup are implementation-defined.</p>
</blockquote>

<p>Most (desktop) common systems belong to the <em>hosted</em> category i.e. one where there is a host or OS which provides a context for the program to run. In such environments (see 5.1.2.2.1/1):</p>

<blockquote>
  <p>The function called at program startup is named main. </p>
</blockquote>

<p><code>main</code> is not a keyword (i.e. not in the set defined by 6.4.1). Think of it as a binding contract for C programs to run and be run from a system which has a host (OS). Thus it is both the vendors' responsibility to allow bootstrapping code to look for this particular function and the programmers responsibility to provide a suitable definition.</p>
",0
11107376,11106739,0,"<blockquote>
  <p>in c where is the main function defined, is it defined in compiler or
  in header files</p>
</blockquote>

<p>(disclaimer: windows tinted description)</p>

<p>The function <code>main</code> is part of the C standard and is generally the starting point in the program and needs no special header. The name ""main"" hasn't really a significance for the operating system, instead the linker will setup main as the starting point of the program by default but the name could in fact be any other function in the program. </p>

<p>The linker has the option of specifying another entry point in the program, it is just the starting point where the program starts executing but whether it is called main, _tmain or WinMain doesn't matter - from the point of view of the operating system.</p>
",0
12279968,12279889,1,"<pre><code>printf(""Gross:\n"",Grosspay);
</code></pre>

<p>You are missing a placeholder for the variable in that string. When you use printf to output variable values, the first string must include placeholders where the following variables are inserted.</p>

<pre><code>printf(""Gross: %f\n"",Grosspay);
</code></pre>

<p>The %f will be replaced with the value of Grosspay.</p>
",0
12279974,12279889,2,"<p>It's computed but not printed, because you're missing <code>%f</code> in the format string in <code>printf</code>.</p>
",0
12280030,12279889,3,"<p>This program actually computes the value but does not print it.
Change,</p>

<pre><code>scanf(""%d"",&amp;Hoursworked);

Grosspay=Hoursworked*150;
printf(""Gross: \n"",Grosspay);
Tax=Grosspay*0.1f;
printf(""TAX:\n"",Tax);


Netpay=Grosspay-Tax;
printf(""NET PAY: \n"",Netpay);
</code></pre>

<p>to</p>

<pre><code>scanf(""%f"",&amp;Hoursworked); //Houseworked is declared float

Grosspay=Hoursworked*150;
printf(""Gross: **%f**\n"",Grosspay); //you have to specify what type to print
Tax=Grosspay*0.1f;
printf(""TAX:**%f**\n"",Tax);


Netpay=Grosspay-Tax;
printf(""NET PAY: **%f**\n"",Netpay);
</code></pre>

<p>change the full code accordingly and you should get the result..:) </p>
",2
18798158,18798130,1,"<pre><code>int a=1,b=1,c=0,i;
for(i=0;i&lt;b;i++)
    {
        c=c+a;
    }
printf(""\n result=%d"",c);
</code></pre>
",0
18798160,18798130,2,"<pre><code>int a=1,b=1,c=0,i;

a=a+a; ==&gt;c=c+a ;    

printf(""\n result=%d"",c);
</code></pre>
",0
18798166,18798130,4,"<p>You are actually exponentially doubling <code>a</code> with your loop.</p>

<p>Say <code>b = 3</code> and <code>a = 5</code>, for example. Then the loop will run three times.</p>

<p>Unrolling the loop would yield:</p>

<pre><code>a = 5; /* initial value of a */

/* now run a=a+a; three times */
a = 5 + 5 = 10;
a = 10 + 10 = 20;
a = 20 + 20 = 40;
</code></pre>

<p>So you won't get 15, but you will get 40.</p>

<p>Instead, make a new variable, like <code>sum = 0</code>, and then add the value of <code>a</code> onto <code>sum</code>, like this:</p>

<pre><code>sum = 0;
for (i=0; i&lt;b; i++)
    sum += a;
</code></pre>

<p>By the way, the <code>+=</code> operator is a great operator which simply adds the value on the right side of itself onto the variable that is on its left side. It's so much nicer and less ugly than the misleading equation <code>a = a + a</code>, which doesn't even make mathematical sense unless <code>a = 0</code>.</p>
",1
18798173,18798130,2,"<p>Multiply using shifts and adds.  O(log(b)).  Watch for overflow.</p>

<p>I recommend this method over a <code>for (t = 0; t &lt; b; t++)</code>.  Imagine if you were using 64-bit math, the <code>for</code> loop would take a long time, even on a computer.  OP doubling method of <code>a=a+a</code> was on track, but incomplete.</p>

<pre><code>unsigned a;
unsigned b;
unsigned product = 0;
scanf(""%u%u"", &amp;a, &amp;b);
while (b &gt; 0) {
  if (b &amp; 1) {
    unsigned OldProduct = product;
    product += a;
    if (product &lt; OldProduct) {
      printf(""\nOverflow\n""); 
      break;
    }
  b &gt;&gt;= 1;  // Halve b
  a += a;  // Double a - avoid using multiplication
}
printf(""\nProduct = %u\n"", product); 
</code></pre>
",3
18936378,18936360,10,"<p>Change this:</p>

<pre><code>printf(""%d and %d"", &amp;hi, &amp;hello);
</code></pre>

<p>to this:</p>

<pre><code>printf(""%d and %d"", hi, hello);
</code></pre>

<p>You want to print the <em>values</em> of the variables, not their addresses.</p>

<p>And if you did want to print their addresses, you'd need to use <code>%p</code> and convert the addresses to <code>void*</code>:</p>

<pre><code>printf(""address of hi is %p\n"", (void*)&amp;hi);
</code></pre>

<p>(You may have been confused by the fact that <code>scanf</code> requires addresses for the values it reads.)</p>

<p>You say that you get the correct behavior if you ""define the variables hi and hello seperately as integers"". I don't know what you mean; if you use <code>&amp;hi</code> and <code>&amp;hello</code> in your <code>printf</code> call, you're always going to get weird values.</p>
",1
18936474,18936360,1,"<p>It is giving right answer...</p>

<p><code>&amp;</code> is used to specify address...</p>

<p>As two variables can't have same address it will show different for every variable</p>

<p>If you want a value to be printed don't specify &amp; in printing.</p>

<p>for eg</p>

<pre><code>printf(""%d"",hi);    // will give you 1

printf(""%d"",&amp;hi);   // Will always gives you different number every time on every machine

// It is showing address where the actual value of the variable hi is stored.. 
</code></pre>
",0
18936439,18936360,1,"<p>You are printing not the value of the variables, but the addresses by using ""&amp;"" before hi and hello. <br> 
To print the values you must write this: <br>
   <code> printf(""%d and %d"", hi, hello); </code></p>
",0
11550376,11549969,2,"<p>Your problem might be:</p>

<pre><code>while(scanf(""%d"",&amp;coins)&gt;0)
</code></pre>

<p>This returns number of chars. You are not checking the value of coins here, but the length of the input string.</p>
",0
11553513,11553445,3,"<p>You cannot use the value of a variable until you set it to some value. You never initialize <code>input</code> to point to anything and then you pass its value to <code>read</code>, reading data to no place in particular.</p>

<p>The second parameter to <code>read</code> tells <code>read</code> where to store the data. It must point to some space that you have allocated to store one or more characters, which your code never does.</p>

<p>Change <code>input</code> to be a <code>char</code>, not a <code>char *</code>. That will allocate space to store ono character. Then pass the <em>address</em> of <code>input</code> to <code>read</code>.</p>
",0
11899543,11899510,1,"<p>Logic fault, You are comparing against zero and want an output of -1 !!!</p>

<pre><code> if (top == NULL) {
         printf(""%d popped\n"", top);    
     return;  
   } 
</code></pre>

<p>Should be</p>

<pre><code>  if (top == NULL) {
         printf(""%d popped\n"",-1);    
     return;  
   } 
</code></pre>
",1
11899545,11899510,1,"<p>Because NULL is the null pointer (i.e a pointer to nothing) and usually has the value of 0.</p>

<p>Just change the line </p>

<pre><code>printf(""%d popped\n"", top);
</code></pre>

<p>to</p>

<pre><code>printf(""-1 popped\n"");
</code></pre>
",0
11899625,11899510,0,"<p>I think this fits your intent better:</p>

<pre><code>void pop(void) {
    int n;
    if (top == NULL) {
        // empty: magic sentinel value
        n = -1;
    } else {
        n = top-&gt;item;
        // not empty: update the stack
        struct node *temp = top;
        top = top-&gt;prev;
        free(temp);
    }
    printf(""%d popped\n"", n);
    return;
}
</code></pre>

<hr>

<p>As Ed and Anon correctly point out, you can fix the original bug by explicitly printing <code>-1</code>.  However, making your logic less fragile in the first place (and incidentally fixing this specific bug) seems like a bigger win to me.</p>
",0
11863217,11863172,0,"<p>The above code will assign 0 to the pointer, not the content.</p>

<p>To initialize the content, use memset:</p>

<pre><code>memset(p, 0x00, 8);
</code></pre>

<p>or dereference the pointer:</p>

<pre><code>for(i=0;i&lt;8;i++)
    p[i]=0;
</code></pre>
",1
11863227,11863172,5,"<p>No. You simply assign 0 to the pointer itself (so you lose it and leak memory). Use this:</p>

<p>(Edit: as Jim Balter pointed out, it's easy to handle non-8 bit chars:)</p>

<pre><code>int main()
{
    unsigned n = (128 + CHAR_BIT - 1) / CHAR_BIT;
    unsigned char *p = malloc(n);

    for(i = 0; i &lt; n; i++)
    p[i] = 0;
}
</code></pre>

<p>But this is reinventing the wheel. Why not use the standard function <code>memset()</code>?</p>

<pre><code>int main()
{
    unsigned n = (128 + CHAR_BIT - 1) / CHAR_BIT;
    unsigned char *p = malloc(n);

    memset(p, 0, n);
}
</code></pre>
",15
11863231,11863172,1,"<p>You can simply use a <code>memset</code> routine to nullify as many bytes as you nned. It will look like this:</p>

<pre><code>uint8_t* p= (uint8_t*)malloc(16);
memset(p, 0, 16);
</code></pre>

<p>Please note, if you want 128 bits (which is 16 bytes) you need to replace 8 to 16.</p>

<p><strong>Updated:</strong></p>

<p>Since sizes of integer types are system dependent, using <code>uint8_t</code> typedef makes you confident the type you are working with is really 8 bits long. This typedef (as well as the ones for other integer types of fixed size) can be found in <code>stdint.h</code>. If using this header is not possible, you can create these typedefs yourself e.g. <code>typedef unsigned char   uint8_t</code> is true for most of the systems.</p>

<p>If the code is later ported to a system with different integer sizes, you don't have to worry about the problems with size incompatibility - all you need is simply changing <code>(u)intX_t</code> (u - for unsigned, X - number of bits) typedefs.</p>
",4
11863237,11863172,2,"<p>Wow, there's just so much to pick apart on that...</p>

<p>1) you allocate 8 bytes, which is 64 bits</p>

<p>2) you iterate to 128, which would cause a buffer overflow, except that:</p>

<p>3) in your loop you only ever set the first byte allocated to 0</p>

<p>there are two ways to do this:</p>

<pre><code>p = malloc(128/8);
for (i = 0; i &lt; (128/8); i++)
    p[i] = 0;
</code></pre>

<p>or you can just use the memset(3) function, provided in all POSIX operating systems.</p>
",2
11863300,11863172,1,"<p>int sometimes allocates 4 bytes depending on the platform. so use char instead:</p>

<pre><code>char* p= (char*)malloc(16);
for(i=0;i&lt;16;i++)
    p[i]=0;
</code></pre>
",1
11863338,11863172,2,"<p>Instead of allocating and clearing it, <code>calloc()</code> would be better I think. </p>

<pre><code>int* p= (int*)malloc(8);
</code></pre>

<p>You allocated 8 bytes i.e 8*8 = 64 bits only. </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int main()
{

int i = 0;
char *p = calloc(16, sizeof(char));

//for Testing
for(i = 0; i &lt; 16; i++)
  printf(""%d\t"", *p++);

return 0;
}
</code></pre>
",0
11865055,11863172,0,"<p>Use <code>calloc( )</code> to allocate and zero.</p>
",0
12847752,12845133,1,"<p>Your function <code>f</code> (you should perhaps choose a more descriptive name) seems to be meant to return the count of numbers not exceeding <code>m</code> that are divisible by any of the primes in the array <code>factors</code>, from the index <code>start</code> onwards.</p>

<pre><code>int f(int *factors, int start, int nf, int m) //nf=no. of factors, start=0, m=M
{
    if(start == nf-1) 
        return (m / factors[start]);

    return (m / factors[start]) + f(factors, (start + 1), nf, m)
              - ((f(factors, (start + 1), nf, m)) / factors[start]);
}
</code></pre>

<p>Obviously, with only one prime <code>p</code>, the count is <code>m / p</code>. So far, so good. Now, the idea of the other part is that the count of numbers not exceeding <code>m</code> that are divisible by <code>p</code> or one of the later primes is</p>

<pre><code>count_multiples_of_p + count_multiples_of_other - count_multiples_of_p_and_other
</code></pre>

<p>which so far is correct. But your implementation supposes</p>

<pre><code>count_multiples_of_p_and_other = count_multiples_of_other / p
</code></pre>

<p>which is only asymptotically correct. Consider for example the three primes <code>[2, 3, 5]</code> and <code>m = 20</code>.</p>

<p>Your function returns</p>

<pre><code>F([2,3,5], 20) = 20/2 + F([3,5], 20) - F([3,5], 20)/2
    -- F([3,5], 20) = 20/3 + 20/5 - (20/5)/3 = 6 + 4 - 1 = 9
               = 10 + 9 - (9/2) = 10 + 9 - 4 = 15
</code></pre>

<p>But if you count, there are six numbers <code>&lt;= 20</code> not divisible by any of the three primes, <code>1, 7, 11, 13, 17, 19</code>, so only 14 that are multiples of any of the three.</p>

<p>The correct way to account for the multiples of <code>p</code> and any of the later primes is to count the multiples of any of the later primes not exceeding <code>m/p</code>, because if <code>k</code> is a multiple of <code>p</code> as well as at least one of the later primes, then <code>k/p</code> is a multiple of one of the later primes that doesn't exceed <code>m/p</code>.</p>

<p>So the fix to your function consists simply of moving a parenthesis (well, two, since you have so many),</p>

<pre><code>int f(int *factors, int start, int nf, int m) //nf=no. of factors, start=0, m=M
{
    if(start == nf-1) 
        return (m / factors[start]);

    return (m / factors[start]) + f(factors, (start + 1), nf, m)
              - ((f(factors, (start + 1), nf, m /* )) */ / factors[start]) ));
    //                                          ^^^^^^^^                   ^^
}
</code></pre>

<p>(and you have several superfluous pairs of parentheses, you might consider removing some of them).</p>
",1
12274911,12274777,1,"<p>&amp;str+2  gives atually address but here in printf statement we are using %s so it's giving output a garbage value and for str+2 the output will be llworld</p>

<p>check this link for output compile several times and see what's the output we are getting</p>

<p><a href=""http://codepad.org/vODzmZj3"" rel=""nofollow"">http://codepad.org/vODzmZj3</a></p>
",0
12274916,12274777,0,"<p>str + 2 is the pointer to string's 3rd symbol, &amp;str + 2 is the pointer to pointer to string plus 2</p>
",0
12275229,12274777,1,"<p>If nothing else, <code>&amp;str</code> (and thus <code>&amp;str+2</code>) has the wrong type to pass to <code>printf</code> for the <code>%s</code> specifier. It requires <code>char *</code> (pointer to <code>char</code>), and <code>&amp;str</code> has type <code>char (*)[25]</code> (pointer to array of 25 <code>char</code>s). Passing the wrong type to <code>printf</code> invokes undefined behavior.</p>

<p>Moreover, <code>&amp;str</code> points to an array of length 1 (its elements are arrays of <code>char</code> of length 25, and there is only one of them), so <code>&amp;str+2</code> is out-of-bounds pointer arithmetic and thus undefined behavior.</p>
",0
12274797,12274777,2,"<p><code>&amp;</code> gets the address of that variable, not the value that the variable points to. However, with an array of chars, the value will be the start of that array (first slot).</p>

<p><code>&amp;str+2</code> gets the memory location of <code>str</code> and adds <code>2</code>.</p>

<p><code>str+2</code> gets the memory location of the start and adds 2 bytes (<code>char</code> = 1 byte, look into pointer arithmetic).</p>
",2
12274826,12274777,0,"<p><code>&amp;str</code> print the address of vailabel like '9' or in hex '0x009'</p>

<p><code>str+2</code> will print <code>lloworld</code> , here +2 is as increment value</p>
",0
12274832,12274777,3,"<p>when you have an array: <code>str[xxx]</code>
<code>str</code> give you the memory address of the beginning of the array so <code>str+2</code> would point to <code>""lloworld""</code>.
<code>&amp;str</code> gives you <em>the address where str is stored</em>. So by printing &amp;str+2 you an have unexpected behaviors.</p>
",0
12275738,12274777,-2,"<p>You can try the following code for a reference!</p>

<pre><code>#include&lt;stdio.h&gt;
int main()
{      
    char str1[11] = ""1111111111"";
    char str2[11] = ""2222222222"";  
    char str[11]  = ""helloworld"";
    char str3[11] = ""3333333333"";
    char str4[11] = ""4444444444"";

   printf(""%s %s\n"", &amp;str-2,str+2);
   return 0;
}
</code></pre>
",0
15864704,15864677,2,"<p>This is a logical <code>OR</code> operation. It evaluates to 1 if at least one of <code>main</code> is not a <code>NULL</code> pointer or <code>c</code> is nonzero; otherwise, it yields 0. Since <code>main()</code> is an existing function, a pointer to it is not <code>NULL</code>, and also <code>5</code> is not zero, so this code will print <code>1</code>.</p>
",1
15864709,15864677,3,"<p>When it appears on its own without parentheses, <code>main</code> is a <a href=""http://c-faq.com/decl/ptrfuncinit.html"" rel=""nofollow"">pointer to function</a> (effectively, the address of <code>main()</code>).</p>

<p>Thus</p>

<pre><code>main || c
</code></pre>

<p>is equivalent to</p>

<pre><code>(main != NULL) || (c != 0)
</code></pre>

<p>which always evaluates to true (i.e. <code>1</code>).</p>
",0
15864712,15864677,0,"<p><code>main||c</code> is a logical <code>OR</code> which will test the function pointer of <code>main</code> which is non-NULL and <code>c</code> which has some non-zero value. Since both of them aren't <code>zero</code> or <code>NULL</code>, it will always print <code>1</code> as this is the output of logical <code>OR</code>.</p>
",0
15864725,15864677,0,"<p>You should compile it with the <code>-Wall</code> option to gcc (to get almost all warnings, with <code>-Wextra</code> you'll get even more). With <code>gcc-4.8</code> I'm getting</p>

<pre><code>% gcc-4.8 -Wall atiq.c -o atiq
atiq.c:1:1: warning: return type defaults to 'int' [-Wreturn-type]
 main()
 ^
atiq.c: In function 'main':
atiq.c:4:1: warning: implicit declaration of function 'printf' [-Wimplicit-function-declaration]
 printf(""%d"", main||c);
 ^
atiq.c:4:1: warning: incompatible implicit declaration of built-in function 'printf' [enabled by default]
atiq.c:4:14: warning: the address of 'main' will always evaluate as 'true' [-Waddress]
 printf(""%d"", main||c);
              ^
atiq.c:5:1: warning: control reaches end of non-void function [-Wreturn-type]
 }
 ^
</code></pre>

<p>I think the warning are clear enough. And you see that <code>main</code> has always a non-null address, so <code>main||c</code> is always true.</p>

<p>And your code is missing a <code>#include &lt;stdio.h&gt;</code></p>
",0
19803882,19803462,2,"<p>Two parts to this:</p>

<ol>
<li><p>Efficiency.  On a modern processor, there are no efficiency gains to declaring types shorter than <code>int</code> in most places, such as function parameters and local variables.  Maybe <code>char</code> or <code>unsigned char</code> parameters would be useful if you are writing for a small microcontroller.</p></li>
<li><p>Correctness.  All integer types (including <code>char</code>) will first get promoted to <code>int</code>, unless they don't fit, in which case they get promoted to <code>unsigned int</code>, unless they don't fit.  Then the ""usual arithmetic conversions"" promote both types in most operations to the same type.</p></li>
</ol>

<p>Here's an example:</p>

<pre><code>char c;
long long x;
return c * x;
</code></pre>

<p>In this case, the result is:</p>

<pre><code>return ((long long) c) * x;
</code></pre>

<p>(Unless, perhaps, <code>sizeof(long long) == 1</code>, <code>CHAR_BIT == 64</code>, and <code>char</code> is unsigned by default.  But that is a downright pathological case.)</p>

<h2>Recommendation</h2>

<p>Use <code>int</code> instead of <code>short</code>.</p>

<pre><code>int integer_conversion(long long int integer, char *str, int str_size, int radix)
{
    // don't bother with ""short""
    int i = 1;
    long long int radix_place = 1;

    if(str == NULL) return -1;
    if(str_size &lt;= 0) return -2;
</code></pre>
",0
12786099,12786053,8,"<blockquote>
  <p>However, I'm failing to see what would cause that in the code I've written.</p>
</blockquote>

<p>Me too, because I don't think you have posted the relevant code.  Regardless, I think this is probably your problem:</p>

<pre><code>i = (int)test_bit(bitmap, pos-1);
</code></pre>

<p>Please show us the signature for <code>test_bit</code>.  I'm guessing it returns <code>void</code> or you have forward declared it somewhere and accidentally wrote:</p>

<pre><code>void test_bit(char*, int);
</code></pre>

<p>Since the function returns <code>void</code> (i.e., nothing) you cannot then proceed to cast the return value (which is nothing) to an <code>int</code> as you are doing, it makes no sense and is illegal.</p>

<p>EDIT: You have verified in the comments that <code>test_bit</code> is in fact declared to return <code>void</code>, so that's your problem.  </p>
",0
12786132,12786053,0,"<p>Since test_bit is void, you may not use its return (as in <code>i = (int)test_bit(bitmap, pos-1);</code>) -- there <em>is</em> no return value.</p>
",0
12786235,12786053,0,"<p>You wrote</p>

<pre><code> i = (int)test_bit(bitmap, pos-1);
</code></pre>

<p>Why have a cast?</p>

<p>Seems a bit stupid when the the function is</p>

<pre><code>void test_bit(char * bitmap, int pos)
{
    int bit;

    bit = bitmap[pos/8] &amp; (1&lt;&lt;(pos%8));
    printf(""%d\n"", &amp;bit);
}
</code></pre>

<p>How the hell can you convert void into a integer?</p>
",1
12811801,12811711,0,"<p>If you want the numbers <i>separated</i> by spaces then you shouldn't be asking for spaces after the last number. I would get rid of all the spaces in your scanf format; they aren't necessary.</p>

<p>Also, it's a good idea to put <code>fflush(stdout)</code> between the printf and scanf calls, otherwise there is no guarantee that the user will see the print output before scanf tries to read.</p>
",0
12811892,12811711,0,"<p>A space (<code></code>) in the scanf format tells scanf to read and discard whitespace characters (spaces, tabs, and newlines) until it gets a non-whitespace character and leave that non-whitespace character on the input (so its the next character read).  Since your format string ends with a space, that's what scanf will do after it reads the 10 integers you asked it for.</p>

<p>If you get rid of that space, then scanf will return as soon as its read the 10th number and wont try to read anything after it, so you won't have to type another line (with something besides whitespace on it) to get the program to continue.</p>

<p>Since a <code>%d</code> specifier also skips any whitespace on the input before a number that it reads, all the rest of the spaces in the scanf format are redundant (and unneeded), but they don't actually cause any harm -- they just slow down the call by a miniscule unmeasurable amount. </p>
",0
12811912,12811711,0,"<p>Please remember when you add %5d in scanf it means you are asking the user to input each integer to have 5 digits</p>

<p>eg:
11111 22222 33333 44444 55555 66666 77777 88888 99999 12345</p>

<p>and if you don't want to restrict the user to 5 digits simply replace %5d to %d.... 
even
eg:
1 2 3 12345 1223 123 122 333 444 11 22 </p>
",2
12821436,12820256,3,"<p>The <code>msg_iovlen</code> field contains the number of elements in the <em>iov</em> array, not its size in bytes.</p>

<p>The system interpreted the following uninitialized memory as <em>iov</em> elements, ended up with a packet that is larger than the socket buffer space available, and thus refused to send the data.</p>
",0
12821498,12820256,2,"<p>Okay, so in your code I found this:</p>

<pre><code>mh.msg_iovlen = sizeof(iov);
</code></pre>

<p>Which sets the <code>msg_iovlen</code> member to the size of <code>struct iovec</code>. But the documentation says this about this field:</p>

<blockquote>
  <p>size_t        msg_iovlen;     /* # elements in msg_iov */</p>
</blockquote>

<p>So your code is wrong, it tells <code>sendmsg()</code> that it's going to send way more elements than you actually initialize.</p>
",0
12821557,12820256,4,"<p>As others have pointed out, iovlen should be 1. But also, you want to zero out mh before initializing some of its fields since you're probably sending in garbage in the uninitialized fields and the syscall gets confused. Also, it doesn't really make sense to set msg_name and msg_namelen since you're connected and can't change your mind about where to send the data anyway.</p>

<p>This is what works for me in your client code:</p>

<pre><code>/* The message header contains parameters for sendmsg.    */
memset(&amp;mh, 0, sizeof(mh));                                                                                                                                                                                                                                                                          
mh.msg_iov = iov;
mh.msg_iovlen = 1;

printf(""mh structure initialized \n"");
</code></pre>
",3
12830798,12830570,0,"<p>This</p>

<pre><code>finput=fopen(arguments[counter], ""r"");
</code></pre>

<p>Will only fail if you do not supply correct filenames (e.g. if there are non-ASCII characters in the names or the names do not include the correct path, <code>fopen()</code> opens files in the current directory if no path is specified in the file name).</p>

<p>This</p>

<pre><code>output_filename=(char*)malloc(sizeof(arguments[counter]));
</code></pre>

<p>most likely does not allocate enough space for a name because <code>arguments[counter]</code> is a pointer, and <code>sizeof()</code> of a pointer is not the same as <code>strlen(that_same_pointer) + 1</code>.</p>

<p>This</p>

<pre><code>output_filename=output_file_prefix;
</code></pre>

<p>loses the just allocated memory because you are reassigning the pointer <code>output_filename</code> to point to some other place, <code>output_file_prefix</code> (<code>""output_""</code>).</p>

<p>After the above this</p>

<pre><code>strcat(output_filename, arguments[counter]);
</code></pre>

<p>is likely going to crash your program because this is going to attempt to overwrite a string literal (<code>""output_""</code>), doing which causes undefined behavior per the C standard.</p>

<p>You have to allocate enough cumulative space for the strings that you want to concatenate and you have to concatenate them in the allocated space.</p>

<p>To save you even more trouble, here's another problem:</p>

<pre><code>finput=fopen(arguments[counter], ""r"");
...
while(!feof(finput))
</code></pre>

<p><code>feof()</code> only works after at least one read from a file. This has been <a href=""https://stackoverflow.com/questions/5431941/while-feof-file-is-always-wrong"">asked ans answered</a> multiple times.</p>
",4
12830826,12830570,0,"<p>Try changing</p>

<pre><code>for(counter=1; counter&lt;n; ++n)
{
</code></pre>

<p>to </p>

<pre><code>for(counter=1; counter&lt;n; ++counter)
</code></pre>

<p>It appears the code loops infinitely, therefore it would exhaust the possible elements in your argument array causing a NULL pointer to be returned.</p>
",5
12830865,12830570,2,"<p>The error you are getting, ""No such file or directory"" indicates that the file name you're trying to open doesn't exist.</p>

<p>In this case, it's probably because the program's current working directory is not the same as the directory containing the executable file.</p>
",3
19373769,19373657,2,"<p>Reflection doesn't work in C, as far i Know, So you cannot dynamically convert string to function calls, using their names.</p>

<p>However, you can use function pointers to do it.</p>

<pre><code>#include &lt;stdio.h&gt;

int f1()
{
   printf(""f1() \n"");
   return 0;
}

int f2()
{
   printf(""f2() \n"");
   return 0;
}

int f3()
{
   printf(""f3() \n"");
   return 0;
}

int main(int argc, char *argv[])
{
   int (*p[3])() = {
      f1,
      f2,
      f3
   };

   for (int i=0; i&lt;3; i++) {
      (*p[i]) ();
   }

   return 0;
}
</code></pre>
",6
19374210,19373657,0,"<p>If you you are looking for a function to convert function name string to the address, try dlsym()</p>

<p><a href=""http://man7.org/linux/man-pages/man3/dlsym.3.html"" rel=""nofollow"">http://man7.org/linux/man-pages/man3/dlsym.3.html</a></p>
",0
13446249,13446174,2,"<p>To test all pairs of account numbers to see which are equal, use</p>

<pre><code>for (i = 0; i &lt; MAX; i++) {
    for (j = i; j &lt; MAX; j++) { // note: starts from i, not 0
        if(accounts[i] == accounts[j]) {
            ...
        }
    }
}
</code></pre>

<p>However, you can't merge the two account numbers into one array element and just delete the other array element, since you've already defined <code>accounts</code> to have the fixed size <code>MAX</code> and arrays allocated in this way cannot be dynamically reallocated.  In your example, you may wish to set the 5th index of all the arrays to some dummy value, like -1.  Then, when you read from the array, you can pass over all elements with this dummy value.</p>
",2
13446310,13446174,0,"<p>Here's a simple iteration in two arrays, comparing every value:</p>

<pre><code>int i, j;

for (i = 0; i &lt; MAX; ++i)
{
    for (j = 0; j &lt; MAX; ++j)
    {
         if (array_one[i] == array_two[j])
         {
              // do stuff ...
         }
     }
 }
</code></pre>
",2
13446319,13446174,0,"<p>You should probably read up on structs:</p>

<pre><code>typedef struct record
{
    const char* name;
    double amount;    /* fixed point, 3 decimals? */
    char deb_cred;    /* 'd' or 'c' (prefer to use `signed char` for a direct sign? */
} record_t;
</code></pre>

<p>So instead of </p>

<pre><code>#define MAX 15

const char* accounts [MAX] = { ""John Mayor"", ""Paula Bean"", ""Gary S."", ""John Mayor"" }; 
double amount        [MAX] = { 100.00      , 200.00      , 300.00   , 400.00       }; 
char debitorcredit   [MAX] = { 'd'         , 'd'         , 'c'      , 'c'          }; 
</code></pre>

<p>Where simple functions would get implemented rather complex:</p>

<pre><code>double get_balance_arrays(const char* name)
{
    double total = 0;
    int i;
    for(i=0; i&lt;MAX &amp;&amp; accounts[i]; ++i)
    {
        if(0 == strcmp(accounts[i], name))
            switch(debitorcredit[i])
            {
                case 'c': total += amount[i]; break;
                case 'd': total -= amount[i]; break;
                default:
                    puts(""Invalid transaction"");
                    exit(255);
            }
    }
    return total;
}
</code></pre>

<p>You'd write</p>

<pre><code>record_t transactions[MAX] =
{
    { ""John Mayor"", 100.00, 'd' },
    { ""Paula Bean"", 200.00, 'd' },
    { ""Gary S.""   , 300.00, 'c' },
    { ""John Mayor"", 400.00, 'c' },
    { 0 } /* sentinel */
};
</code></pre>

<p>Now simple functions get implemented much more conveniently:</p>

<pre><code>double get_balance_struct(const char* name)
{
    double total = 0;
    record_t* tx;
    for (tx = transactions; tx-&gt;name; ++tx)
    {
        if (0 == strcmp(tx-&gt;name, name)) /* NOTE string comparison! */
        switch(tx-&gt;deb_cred)
        {
            case 'c': total += tx-&gt;amount; break;
            case 'd': total -= tx-&gt;amount; break;
                default:
                    puts(""Invalid transaction"");
                    exit(255);
        }
    }
    return total;
}
</code></pre>

<p>Test:</p>

<pre><code>int main(int argc, const char *argv[])
{
    printf(""Balance: %0.02f\n"", get_balance_struct(""John Mayor""));
    printf(""Balance: %0.02f\n"", get_balance_arrays(""John Mayor""));
    return 0;
}
</code></pre>

<p>Prints:</p>

<pre><code>Balance: 300.00
Balance: 300.00
</code></pre>
",2
13446368,13446174,1,"<p>The easiest thing, I think, is to sort the arrays by account number.  This would be best achieved by rearranging your data into structures and then using <code>qsort</code>.</p>

<pre><code>struct account_entry {
    int account_num;
    int amount;        // assuming int
    char debit_credit;
};
</code></pre>

<p>Then you would have a single array:</p>

<pre><code>struct account_entry acc[MAX];
for( i = 0; i &lt; MAX; i++ ) {
    acc[i].account_num = accounts[i];
    acc[i].amount = amount[i];
    acc[i].debit_credit = debit_or_credit[i];
}
</code></pre>

<p>And sort it:</p>

<pre><code>int compare_entry( const void* a, const void* b )
{
    const struct account_entry *aa = (const account_entry*)a;
    const struct account_entry *bb = (const account_entry*)b;
    if( aa-&gt;account_num &lt; bb-&gt;account_num ) return -1;
    if( aa-&gt;account_num &gt; bb-&gt;account_num ) return 1;
    return 0;  // No need to do second-tier sorting if accounts are equal.
}

qsort( acc, MAX, sizeof(struct account_entry), compare_entry );
</code></pre>

<p>Now you just run through the array and consolidate.  Easiest to consolidate into a new array.</p>

<pre><code>struct account_entry consolidated[MAX];
int c = 0, i;
consolidated[0] = acc[0];

for( i = 1; i &lt; MAX; i++ ) {
    if( acc[i].account_num != consolidated[c].account_num ) {
        c++;
        consolidated[c] = acc[i];
    } else {
        // Add the amounts and work out whether it's debit or credit...  Do
        // not increment c.  Dunno why you don't drop this field altogether
        // and allow negative values, but nevermind.  As such, I won't put
        // code for it in here.
    }
}
</code></pre>
",4
17795592,17795578,0,"<p>Not equal.  </p>

<p>1 != 2</p>

<p>1 == 1</p>

<p>2 != 1</p>

<p>3 != 5</p>
",1
17795600,17795578,0,"<p>!= means not equal to.</p>

<p>ex: c-a is not equal to 0.</p>
",0
17795609,17795578,0,"<p><code>a != b</code> means that a is not equal to b. It's the same as <code>!(a == b)</code>.</p>
",0
17795615,17795578,3,"<p>It means: if <code>c</code> is not equal to <code>a</code>, then if <code>d</code> and <code>b</code> are also not equal, goto (jump to) the line with the label ""trap"".</p>

<p>The <code>!=</code>, just means not equal. It is the complement of the <code>==</code> operator.</p>
",0
17795629,17795578,0,"<p>Here's an english translation of the code...</p>

<p>if c minus a is not equal to 0 AND d minus b is not equal to 0 then goto trap</p>
",0
14219119,14219045,2,"<p>It will clear tokens which is an array of 100 pointers, not the memory pointed to by those pointers.</p>
",0
14219128,14219045,3,"<p>It is valid, but not very useful since the result of setting a bunch of pointers to all-bits-zero is not well defined. There's no guarantee that a <code>NULL</code> pointer looks (in memory) as ""all bits zero"", so it's bad practice.</p>

<p>And no, this is not filling ""random"" memory, it's filling exactly the memory occupied by the <code>tokens</code> array.</p>
",0
14219131,14219045,1,"<p>I would re-write the memset bit as:</p>

<pre><code>memset(tokens, 0, sizeof(tokens));  
</code></pre>

<p>Because what you do is actually assign zero to all the pointers in the array. Otherwise the code is valid, but I am not sure it does what you expect.</p>
",0
14219134,14219045,1,"<p>It is valid code (well except that <code>n</code> is undefined in the example).</p>

<p><code>memset</code> like this <em>is</em> initializing. You're zeroing out the whole <code>tokens</code> variable. It is not a random location. It is not mandatory in your example, either.</p>

<p>Also, take note that <code>strtok</code> does <em>not</em> return a copy of the token, but rather modifies <code>tempVar</code> and returns pointers to its elements. If <code>tempVar</code> goes out of scope, the memory locations pointed by the <code>tokens</code> elements will become dangling pointers, and dereferencing them will invoke undefined behavior.</p>
",0
15879781,15879761,0,"<p>Probably the string passed is not null terminated, or you're acessing an invalid ¨ªndex on argv</p>
",0
15879788,15879761,14,"<p>The second argument to <a href=""http://linux.die.net/man/3/fopen""><code>fopen()</code></a> should be a string, not a <code>char</code>:</p>

<pre><code>FILE *src = fopen(argv[1], ""r"");
</code></pre>

<p>Note the double quotes.</p>

<p>It is always a good idea to switch on compiler warnings and to keep an eye on them. My compiler picks up on the incorrect argument:</p>

<pre><code>test.c:4:1: warning: passing argument 2 of 'fopen' makes pointer from integer without a cast [enabled by default]
In file included from test.c:1:0:
/usr/include/stdio.h:250:7: note: expected 'const char *' but argument is of type 'int'
</code></pre>
",5
15882175,15879761,0,"<p>instead of </p>

<pre><code>FILE *src = fopen(argv[1], 'r');
</code></pre>

<p>you need to write </p>

<pre><code>FILE *src = fopen(argv[1], ""r"");
</code></pre>
",0
14865858,14865811,0,"<p>What you need to do is to first define what array of files you will be using.</p>

<p>So when you declare FILE *files[14], you need to actually specify what each of those files are.</p>

<p>You should first declare a set of strings instead with the specific filenames, and loop over them.</p>

<p>Also, your for loops are wrong, it should be </p>

<pre><code>for(i = 0; i &lt; 14; i++) {
...
}
</code></pre>

<p>You need to start indexing at 0, and stop indexing at 13.</p>
",0
14865874,14865811,1,"<p>You're only supplying one name, so instead of trying to open 15 files, you're trying to open one file 15 times. Unless you specify a sharing mode, that will fail (at least with most compilers on Windows, which seems to be what you're using).</p>

<p>My guess is you want to open 15 different files though, in which case you need to specify 15 different file names. One possibility for doing that is to synthesize names that include the index. Since you appear to be using C (despite the <code>c++</code> tag) I'll stick to C for the moment.</p>

<pre><code>int i;
FILE *f[15];

for (i=0; i&lt;15; i++) {
    char name[32];

    sprintf(name, ""File%d.txt"", i);
    f[i] = fopen(name, ""w"");
}
</code></pre>
",1
14826771,14826763,7,"<p>You haven't allocated any memory for your pointer to point at.</p>

<pre><code>char array[MAX_LEN + 1];

char *ptr = array;

strncpy(ptr, ""Cadence"", MAX_LEN);
ptr[MAX_LEN] = '\0';

printf( ""%s\n"", ptr);
</code></pre>

<p>Please note that <code>strncpy()</code> <em>can be</em> a safer way to copy strings, since we specify the maximum number of characters to copy, which makes it harder to overrun the string and 'scribble' memory.</p>

<p><strong>Update</strong> in response to comments: I've altered the above code to use a slightly safer pattern. You might also want to investigate <code>strlcpy()</code> (non-standard library).</p>
",4
14834994,14826763,1,"<p>When you declare <code>char *ptr;</code>, you allocate memory for a pointer to a char. But if you want to put a string inside the char, it will make an overflow.</p>

<p>Therefore, you have to allocate memory for your string :</p>

<p>char str[1024]; // which is the maximum string lenth that you will be able to put in str.</p>

<p>Furthemore, don't forget the null terminator (<code>\0</code>) that terminate every string and has the size of one char</p>
",0
15892333,15892244,0,"<p>You have an infinite loop in your code,</p>

<p>your code given below is wrong,</p>

<pre><code>   while(playerNumber != playerInput)
   {

       printf(""You Have to wait your turn.\nPlayer number?\n"");

   }
</code></pre>

<p>It should be,</p>

<pre><code>   if(playerNumber != playerInput)
   {

       printf(""You Have to wait your turn.\nPlayer number?\n"");

   }
</code></pre>
",1
15892390,15892244,1,"<p>First of all, you should use consistent indentation.  That will make it easier to read your code.  </p>

<p>Second, you should use newlines and whitespace to group like-lines together.  Think of writing code like writing prose, and newlines as ways to separate paragraphs.  You don't double-space almost anything, because it wastes space and is harder to read (people aren't used to it) so don't double-space your code.</p>

<p>Third, your use of the playerA and playerB variables is an OK concept, but there are better ways to do it.  The typical convention in C/C++ is to use a #define for magic numbers, with all caps - <code>#define PLAYER_A 1</code>.  Following this convention will make your code more readable.  Also, since your players are ""1"" and ""2"" it is more readable to use <code> #define PLAYER1 1</code> or PLAYER_1.</p>

<p>You use the variable ""i"" but the convention for using variables named i, j, k, m, or n is as loop counters that are incremented either at the top of the loop or at the bottom of the loop.  Incrementing the loop counter in the middle of the loop makes it much easier for the counter to get lost.  Move the increment to the top or the bottom.</p>

<p>Do the work by hand to see what your variables are as the program executes.  Your teacher has done this in class.  Just write down each variable and write its value next to it, then change the variables as they will change while the program executes.  This technique will help you fix other difficult bugs in the future, rather than me giving you the answer.</p>
",0
19317313,19317295,18,"<p><code>%</code> is an integer operator - use <a href=""http://linux.die.net/man/3/fmod"" rel=""noreferrer"">fmod</a> or <a href=""http://linux.die.net/man/3/fmod"" rel=""noreferrer"">fmodf</a> for doubles or floats.</p>

<p>Alternatively if you expect your float to represent integer values then convert it to an <code>int</code> first, e.g.:</p>

<pre><code>if ((int)someFloat % 2 == 1) // if f is an odd integer value
{
    ...
}
</code></pre>
",5
19317320,19317295,3,"<p>The modulus operator only works on integers. For floating point values use <a href=""http://msdn.microsoft.com/en-us/library/20dckbeh.aspx"" rel=""nofollow""><code>fmod</code></a> or <code>fmodf</code>.</p>
",1
19317393,19317295,2,"<p><em><strong></em>%</strong> this only works with integers use fmod for floating point or double values**</p>

<pre><code>double fmod(double x, double y)


x -- This is the floating point value with the division numerator i.e. x.

y -- This is the floating point value with the division denominator i.e. y.
</code></pre>
",0
16390447,16390406,0,"<p>The reason it fails is because you make the following sequence of code:</p>

<pre><code>while(){
    if(){
       ...
       p_vymaz=p_akt;
       ...
       free((void*)p_vymaz);
    }
    p_akt=p_akt-&gt;p_dalsi;
}
</code></pre>

<p>You have freed p_akt by assigning p_vymaz to p_akt and then freeing p_vymaz. As such, <code>p_akt-&gt;p_dalsi</code> is no longer valid.</p>
",0
16390456,16390406,0,"<p>I really hope this is not a real project. You have a <a href=""http://en.wikipedia.org/wiki/Buffer_overflow"" rel=""nofollow"">buffer overflow</a> hanging there, waiting to happen.</p>

<p>Since this is a homework, I'd tell you to use a debugger, like @Mitch Wheat suggested. But also keep in mind that if you write code in your mother tangue, which is not english, it will be very hard for The People From The Internet to follow it and help.</p>

<p>Luckily some will, like @Marc Claesen here.</p>
",0
15497482,15497208,1,"<p><code>inspace</code> is essentially a variable to indicate you are or are not in the ""just seen a space"" state. You enter this state after seeing a space, and you exit this state when you see a non-space. You print your input only if you're not in the <code>inspace</code> state, thus you do not print multiple adjacent spaces.</p>

<p><em>I managed to create a program that completes this task but it was using only the variable c that I created, thus I understand its purpose.</em>
In your program, if the input is ""hello       world"", is that its exact output? The program you posted will output ""hello world"" (compressing the multiple spaces between the words down to one).</p>
",1
15497511,15497208,2,"<p>The objective of this code is copy text  and if there is more then one spaces <code>' '</code> consecutive print only one space. </p>

<p>Variable <code>inspace</code> is used to keep track of whether  last time printed char was scape or non-space.<br>
if <code>inspace</code> is zero means a char was printed that was not space. and<br>
if <code>inspace</code> is one means a last time space was printed.  </p>

<p>So if <code>inspace</code> is zero  next time scape can be printed on reading a scape, and if <code>inspace</code> is one then next consecutive scape found so not to print space.    </p>

<p>See <code>C</code> is current char read. (<em>read comments</em>)</p>

<pre><code>  if(c == ' ')  // currently space read
    {
      if(inspace == 0) // last time non-space printed, So space can be print
      {
        inspace = 1;   // printing space so switch inspace 1
        putchar(c);   // print space
      }
    }
</code></pre>

<p>Next <code>if</code>  </p>

<pre><code>if(c != ' ') // A char not space read, its to to print unconditionally  
{
  inspace = 0;  // remember that non-scape print
  putchar(c);
}
</code></pre>
",0
15503132,15503096,10,"<p>Use the <code>*</code> format specifier to pass the width as argument. Something like this should work:</p>

<pre><code>sprintf( Formatted, ""%0*d"", MACR, Number );
</code></pre>

<p>But please use a constant not a MACRO. </p>
",0
15503151,15503096,0,"<pre><code>#define MAKE_TEXT(x) #x
sprintf( Formatted, ""%0""MAKE_TEXT(MACR)""d"", Number );
</code></pre>
",7
15503171,15503096,2,"<p>The simplest solution is just to specify the length with
a <code>'*'</code>, and pass the macro as an argument:</p>

<pre><code>sprintf( formatted, ""%0*d"", MACR, number );
</code></pre>

<p>Alternatively, you can concatenate strings, something like:</p>

<pre><code>sprintf( formatted, ""%0"" STRINGIZE(MACR) ""d"", number );
</code></pre>

<p>using the usual STRINGIZE macro: </p>

<pre><code>#define STRINGIZE_HELPER(x) # x
#define STIRNGIZE(x) STRINGIZE_HELPER(x)
</code></pre>

<p>(Of course, the easiest and safest solution is just to forget about <code>sprintf</code>, and use <code>std::ostringstream</code>.)</p>
",1
15503172,15503096,1,"<p>There are two ways to solve this:</p>

<ol>
<li><p>Have the complete format in the macro:</p>

<pre><code>#define MACR  ""%06d""

sprintf(Formatted, MACR, Number);
</code></pre></li>
<li><p>Use the <code>*</code> width specifier:</p>

<pre><code>#define MACR 6

sprintf(Formatted, ""%0*d"", MACR, Number);
</code></pre></li>
</ol>
",0
19444079,19443812,1,"<p>In C, this code from the question will not compile:</p>

<pre><code>(currIndex == 0) ? return 1 : currIndex--;
</code></pre>

<p>The <code>return</code> statement is not an expression that can be embedded into the ternary operator like that.</p>

<p>You could write:</p>

<pre><code>return (currIndex == 0) ? 1 : currIndex--;
</code></pre>

<p>though the decrement only makes any sense if <code>currIndex</code> is a global variable (defined outside a function; it might be local to the file or global to the whole program).</p>
",4
19443891,19443812,3,"<p>If, as you say, you return a value anyway, then yes that's not going to be a problem, besides the problem that you actually can't do it that way (<code>return</code> is not allowed there). To solve it, <em>and</em> make the code easier to follow, you can do this instead:</p>

<pre><code>if (curindex == 0)
    return 1;

--curindex;

/* Rest of code */
</code></pre>

<p>There's no need for an <code>else</code> in this case, as the <code>else</code> part is the decrement <em>and</em> the rest of the code, which you won't do if you <code>return</code> from the function.</p>
",7
19443903,19443812,1,"<p>Why would you use ternary operator here? <code>currIndex</code> seems to be a local variable, you won't lose anything if you decrement it even when you return:</p>

<pre><code>if (!currIndex--)
    return 1;
</code></pre>
",0
15562075,15551609,0,"<p>I would use <code>fgets()</code> to get a whole line from the text file and put it into a string and use <code>sscanf()</code> to extract your values.</p>

<pre><code>/* count tell you how many of the % fields were matched,
and you need to make sure all three were found to avoid blank lines*/
</code></pre>

<p>The <a href=""http://linux.die.net/man/3/scanf"" rel=""nofollow"">scanf man page</a> states in part:</p>

<p><strong>Return Value</strong></p>

<p>These functions return the number of input items successfully matched and assigned, which can be fewer than provided for, or even zero in the event of an early matching failure.</p>

<p>The value EOF is returned if the end of input is reached before either the first successful conversion or a matching failure occurs. EOF is also returned if a read error occurs, in which case the error indicator for the stream (see ferror(3)) is set, and errno is set indicate the error. </p>

<p>You could check for <code>line[0] == '\n'</code> to avoid blank lines.</p>

<p>Hope that helps.</p>
",0
15539223,15539206,2,"<p><code>abbreviation</code> is a character, not a string.  You want <code>printf(""%c\n"", head-&gt;abbreviation);</code>.</p>
",0
15539273,15539206,3,"<p>You are creating a node that head->next points to, then insert the values there. You never set any values in the head node itself.</p>
",0
15539704,15539206,0,"<p>To add to <a href=""https://stackoverflow.com/a/15539273/1383051"">UncleO's answer</a>, before calling <code>insert()</code> in your <code>main()</code>, set <code>head-&gt;abbreviation</code> and <code>head-&gt;number</code> to desired values and initialize <code>head-&gt;next</code> to NULL.</p>
",0
15539727,15539206,0,"<p>Please try this code.</p>

<pre><code>#include &lt;stdio.h&gt;&gt;
#include &lt;stdlib.h&gt;
struct Node
{
    char abbreviation;
    double number;
    struct Node *next;
};
void insert(char abbreviation, double number, struct Node *head) {
struct Node *current = head;
while(current-&gt;next != NULL)
{
    current = current-&gt;next;
}

struct Node *ptr = (struct Node*)malloc(sizeof(struct Node));
ptr-&gt;abbreviation = abbreviation;
ptr-&gt;number = number;
if(head-&gt;next==NULL)
{
    head=current=ptr;
}
else
{
    current-&gt;next = ptr;
}
return;
}

int main(int argc, char* argv[]) 
{
struct Node *head = (struct Node*)malloc(sizeof(struct Node));
insert('n',456,head);
printf(""%s\n"", head-&gt;abbreviation);
}
</code></pre>
",0
15541772,15539206,0,"<p>See the changes here :</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct Node
{
char abbreviation;
double number;
struct Node *next;
};

void insert(char abbreviation, double number, struct Node *head) {
struct Node *current = head;
while(current-&gt;next != NULL)
{
current = current-&gt;next;
}

struct Node *ptr = (struct Node*)malloc(sizeof(struct Node));
ptr-&gt;abbreviation = abbreviation;
ptr-&gt;number = number;
current-&gt;next = ptr;

return;
}

int main(int argc, char* argv[]) {
struct Node *head = (struct Node*)malloc(sizeof(struct Node));
insert('n',456,head);
insert('m',453,head);
printf(""%c\n"", head-&gt;next-&gt;abbreviation);
printf(""%c\n"", head-&gt;next-&gt;next-&gt;abbreviation);
}
</code></pre>
",0
15844731,15844703,0,"<p>You should change</p>

<pre><code>for (int x = 0; x &lt; sort; x++) 
</code></pre>

<p>to</p>

<pre><code>for (int x = 0; x &lt; sort.length; x++)
</code></pre>

<p>instead. And</p>

<pre><code>String[] sort = new String[listNames];
</code></pre>

<p>to</p>

<pre><code>String[] sort = new String[listNames.length];
</code></pre>

<p>Also , <code>JOptionPane.showMessageDialog()</code> should be used in this way:</p>

<pre><code>JOptionPane.showMessageDialog(null,"" Tutor LAST NAME and FIRST NAME Listed in Alphabetically Order""+(x+1)+ "" "" + ""For example: 'Smith, John'"");
</code></pre>
",7
15844772,15844703,1,"<p>In the following three code blocks I'll first write your line and then what it should be:</p>

<pre><code>String[] sort = new String[listNames];
String[] sort = new String[listNames.length];
                                    ^^^^^^^
</code></pre>

<hr>

<pre><code>for (int x = 0; x &lt; sort; x++) {
for (int x = 0; x &lt; sort.length; x++) {
                        ^^^^^^^
</code></pre>

<hr>

<pre><code>sort[x] = JOptionPane.showMessageDialog("" Tutor LAST NAME and FIRST NAME Listed in Alphabetically Order""+(x+1)+ "" "" + ""For example: 'Smith, John'"");
sort[x] = JOptionPane.showMessageDialog(null, "" Tutor LAST NAME and FIRST NAME Listed in Alphabetically Order""+(x+1)+ "" "" + ""For example: 'Smith, John'"");
                                        ^^^^^
</code></pre>

<p>Assuming you really want to create a new array prior to sorting it, your method should be:</p>

<pre><code>public static String[] sortNames(String[] listNames) {
    String[] copy = Arrays.copyOf(listNames, listNames.length);
    Arrays.sort(copy);
    return copy;
}
</code></pre>

<p>If it has to be a method, but you don't have to create a second array, you could do this:</p>

<pre><code>public static void sortNames(String[] listNames) {
    Arrays.sort(listNames);
}
</code></pre>
",0
15851147,15851097,0,"<p>You are passing address of two int and one pointer(third argument), you should receive   first  two arguments in pointer(one <code>*</code>) to int and third argument in pointer to pointer(two <code>**</code>) of int: </p>

<pre><code>void load(int* n, int* x, int **arr){
//           ^       ^ one*     ^ two **
    *n = 10;
    *x = 9;
}
</code></pre>

<p>In load function you can assign values to <code>*n</code> and <code>*x</code> because both points to valid memory addresses  but you <strong>can't do <code>**arr = 10</code></strong> simply because <code>arr</code> doesn't points to any memory (<em>points to NULL</em>) so first you have to first allocate memory for <code>*arr</code>, do like: </p>

<pre><code>void load(int* n, int* x, int **arr){
    *n = 10;
    *x = 9;
    *arr = malloc(sizeof(int));
    **arr = 10;
}
</code></pre>

<blockquote>
  <p><strong>Is this documentation useful in C coding, and is it a good practice?</strong> </p>
</blockquote>

<p>Yes</p>

<p>but Sometimes I documents my function arguments  like in following ways: </p>

<pre><code>void load(int n,     // is  a Foo
         int x,      // is a  Bar
         int **arr){ // do some thing 
    // something
}
</code></pre>

<p>A reference: <a href=""https://softwareengineering.stackexchange.com/questions/40666/help-finding-good-documentation-for-c-c"">for document practice</a> </p>

<p><strong>Edit</strong> As you are commenting, do like below I am writing, it will not give any error/because of <code>malloc()</code>.  </p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
void load(int* n, int* x, int **arr){
    *n = 10;
    *x = 9;
    *arr = malloc(sizeof(int));
    **arr = 10;
    printf(""\n Enter Three numbers: "");
    scanf(""%d%d%d"",n,x,*arr);
}
int main(){
    int n = 0, x = 0;
    int *arr = NULL;    
    load(&amp;n, &amp;x, &amp;arr);
    printf(""%d %d %d\n"", n, x, *arr);
    free(arr);
    return EXIT_SUCCESS;
}
</code></pre>

<p>Compile and run like: </p>

<pre><code>~$ gcc ss.c -Wall
:~$ ./a.out 

 Enter Three numbers: 12 13 -3
12 13 -3
</code></pre>

<p>As Commented by OP: </p>

<blockquote>
  <p>""Invalid convertion from void* to int*"" when I change this to <em>arr = malloc(sizeof(int)</em>(*n)); </p>
</blockquote>

<p><a href=""http://wiki.answers.com/Q/What_is_SYNTAX_of_malloc_and_calloc_in_C_language"" rel=""nofollow noreferrer"">syntax of malloc():</a> </p>

<pre><code>void *malloc(size_t size);  
</code></pre>

<p>malloc() returns <code>void*</code> and <code>*arr</code> type is <code>int*</code> that is the reason compiler messages because of different types : <code>""Invalid convertion from void* to int*""</code> </p>

<p>But I avoid casting when malloc(), since: <a href=""https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc/605858#605858"">Do I cast the result of malloc?</a> (<em>read Unwind's answer</em>)</p>
",4
16384462,16384162,3,"<p>This is a duplicate of a few questions on SO, but here goes.</p>

<h2>Maximal Munch</h2>

<p>The C parser will try to grab as many characters as it can to split your program into tokens. In <code>++i+++i+++i;</code> the parser splits the string into:</p>

<ol>
<li>++</li>
<li>i</li>
<li>++</li>
<li>+</li>
<li>i</li>
<li>++</li>
<li>+</li>
<li>i</li>
<li>;</li>
</ol>

<p>It then sees that preincrement (token 1) and postincrement (token 3) are both applied to the first <code>i</code> (token 2), and reports an error.  The parser does not backtrack and reparse the string to use <code>+</code> for token 3 and <code>++</code> for token 4. If the compiler had the license to do this, a malicious program could take arbitrarily-long time to parse.</p>

<h2>Multiple Side-Effects</h2>

<p><code>C</code> and its family of languages defines a <em>sequence point</em> as a point in a statement's execution where all variables have definite values. It is undefined behavior to have more than one side-effect  occur to a variable between sequence points.  Simplify your example a bit. What could this code do? I have changed a preincrement to a predecrement so I can talk about them easier.</p>

<pre><code>int j = ++i + --i;
</code></pre>

<ol>
<li>Increment <code>i</code>.</li>
<li>Use the incremented value for the first summand.</li>
<li>Decrement <code>i</code>.</li>
<li>Use the decremented value for the second summand.</li>
<li>Add the two values and assign to <code>j</code>.</li>
</ol>

<p>However, the C standard does not fix the order of these effects except that step 1 must precede step 2, step 3 must precede step 4, and step 5 must be last. What your compiler does  need not be what another compiler does, and it need not be consistent, even in the same program.  As the joke in the Jargon File goes:</p>

<blockquote>
  <p>nasal demons, n.</p>
  
  <p>Recognized shorthand on the Usenet group comp.std.c for any unexpected behavior of a C
  compiler on encountering an undefined construct. During a discussion on that group in early
  1992, a regular remarked ¡°When the compiler encounters [a given undefined construct] it is
  legal for it to make demons fly out of your nose¡± (the implication is that the compiler may
  choose any arbitrarily bizarre way to interpret the code without violating the ANSI C
  standard). Someone else followed up with a reference to ¡°nasal demons¡±, which quickly
  became established. The original post is web-accessible at <a href=""http://groups.google.com/groups?hl=en&amp;selm=10195%40ksr.com"" rel=""nofollow"">http://groups.google.com/groups?hl=en&amp;selm=10195%40ksr.com</a>.</p>
</blockquote>
",0
16370469,16370363,6,"<p>The problem is that you're forgetting to increment the actual overall character. For each line, you need to add characters until you get to the value that you should start at for the next line. Thankfully, this is pretty easy to do:</p>

<pre><code>    ...
    max += 2;
    c = (c - 'A' + max / 2 + 1) % 26 + 'A'; // Add this line
}
</code></pre>
",2
16410351,16410340,2,"<p><code>#pragma pack</code> is supported by most compilers that I know of. This can allow the programmer to specify their desired padding method for structs.</p>

<p><a href=""http://msdn.microsoft.com/en-us/library/2e70t5y1%28v=vs.80%29.aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/2e70t5y1%28v=vs.80%29.aspx</a></p>

<p><a href=""http://gcc.gnu.org/onlinedocs/gcc/Structure_002dPacking-Pragmas.html"" rel=""nofollow"">http://gcc.gnu.org/onlinedocs/gcc/Structure_002dPacking-Pragmas.html</a></p>

<p><a href=""http://clang.llvm.org/docs/UsersManual.html#microsoft-extensions"" rel=""nofollow"">http://clang.llvm.org/docs/UsersManual.html#microsoft-extensions</a></p>
",6
16410364,16410340,6,"<p>Yes, you cannot send the binary data of a structure between platforms and expect it to look the same on the other side.  </p>

<p>The way you solve it is you create a marshaller/demarshaller for your construct and pass it through on the way out of one system, and on the way in to the other system.  This lets the compiler take care of the buffering for you on each system.</p>

<p>Each side knows how to take the data, as you've specified it will be sent, and deal with it for the local platform.</p>

<p>Platforms such as java handle this for you by creating serialization mechanisms for your classes.  In C, you'll need to do this for yourself.  How you do it depends on how you want to send your data.  You could serialize to binary, XML, or anything else.</p>
",0
16410419,16410340,0,"<p>It will only be affected if the code you have compiled for some other architecture uses a different padding scheme.</p>

<p>To help alleviate problems, I recommend that you pack structures with no padding.  Where padding is required, use place-holders in (eg <code>char reserved[2]</code>).  Also, don't use bitfields!!  They are not portable.</p>

<p>You should also be aware of other architecture-related problems.  Specifically endianness, and datatype sizes.  If you need better portability, you may want to serialise and de-serialise a byte stream instead of casting it as a <code>struct</code>.</p>
",0
16430388,16410340,0,"<p>You can use #pragma pack(1) before the struct declaration and #pragma pack() before to disable  architecture based packing; this will solve half of the problem 'cause some data types are architecture based too, to solve the second half I usually use specific data type like int_16 for 16 bits integers, u_int_32 for 32 bits integers and so on.</p>

<p>Take a look at <a href=""http://freebsd.active-venture.com/FreeBSD-srctree/newsrc/netinet/ip_icmp.h.html"" rel=""nofollow"">http://freebsd.active-venture.com/FreeBSD-srctree/newsrc/netinet/ip_icmp.h.html</a> ; this include describe some architecture independent network data packets.</p>
",0
16443843,16443780,4,"<p>Daniel is right: <a href=""http://ideone.com/kgbo1C#view_edit_box"" rel=""nofollow"">http://ideone.com/kgbo1C#view_edit_box</a></p>

<p>Change</p>

<pre><code>test=substring(i,j,*s);
</code></pre>

<p>to</p>

<pre><code>test=substring(i,j,s);  
</code></pre>

<p>Also, you need to forward declare substring:</p>

<pre><code>char *substring(int i,int j,char *ch);

int main // ...
</code></pre>
",1
16444099,16443780,4,"<p>Lazy notes in comments.</p>

<pre><code>#include &lt;stdio.h&gt;
// for malloc
#include &lt;stdlib.h&gt;

// you need the prototype
char *substring(int i,int j,char *ch);


int main(void /* std compliance */)
{
  int i=0,j=2;
  char s[]=""String"";
  char *test;
  // s points to the first char, S
  // *s ""is"" the first char, S
  test=substring(i,j,s); // so s only is ok
  // if test == NULL, failed, give up
  printf(""%s"",test);
  free(test); // you should free it
  return 0;
}


char *substring(int i,int j,char *ch)
{
  int k=0;
  // avoid calc same things several time
  int n = j-i+1; 
  char *ch1;
  // you can omit casting - and sizeof(char) := 1
  ch1=malloc(n*sizeof(char));
  // if (!ch1) error...; return NULL;

  // any kind of check missing:
  // are i, j ok? 
  // is n &gt; 0... ch[i] is ""inside"" the string?...
  while(k&lt;n)
    {   
      ch1[k]=ch[i];
      i++;k++;
    }   

  return ch1;
}
</code></pre>
",0
16444218,16443780,8,"<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
char *substring(int i,int j,char *ch)
{
    int n,k=0;
    char *ch1;
    ch1=(char*)malloc((j-i+1)*1);
    n=j-i+1;

    while(k&lt;n)
    {
        ch1[k]=ch[i];
        i++;k++;
    }

    return (char *)ch1;
}

int main()
{
    int i=0,j=2;
    char s[]=""String"";
    char *test;

    test=substring(i,j,s);
    printf(""%s"",test);
    free(test); //free the test 
    return 0;
}
</code></pre>

<p>This will compile fine without any warning</p>

<ol>
<li><code>#include stdlib.h</code> </li>
<li>pass <code>test=substring(i,j,s)</code>; </li>
<li>remove <code>m</code> as it is unused </li>
<li>either declare <code>char substring(int i,int j,char *ch)</code> or define it before main   </li>
</ol>
",2
19962839,19946208,0,"<p>Bruce,</p>

<p>In your data file, you need a blank line between the number and list of names because of the first fgets() at the beginning of read_names() consumes the second line.
Because the program skipped the second line, it could read only 8 names and the last line read was a blank line, which caused strtok to return a null and the next strcpy tried to read from address 0, which is, of course, a segmentation fault.
And in my machine, the fault happened before printing ""loop ends"".</p>

<p>You need to check the return values of function calls (strtok in this case) for possible errors. Otherwise you will be wasting a lot of time debugging like this.</p>
",0
20091280,20090974,1,"<p>Just an idea. What size is your <code>int</code>? Check it by printing out <code>sizeof(int)</code>.</p>

<p>You make assumption that your <code>int</code> is 32 bit, but if it is 16-bit you overflow <code>t</code> and what happens then is implementation defined, so every machine may work this out differently, and yours did something that made <code>e&lt;t</code> while mine didn't.</p>
",2
20091440,20090974,1,"<p>You could be encountering <em>implementation-defined</em> behaviour. This means that your code is legal but that each implementation (i.e. each compiler) may perform in different ways. Here are the relevant excerpts from the C specification:</p>
<blockquote>
<h3>Section 6.7.8 paragraph 11</h3>
<p>The initializer for a scalar shall be a single expression, optionally enclosed in braces. The initial value of the object is that of the expression (after conversion); the same type constraints and conversions as for simple assignment apply, taking the type of the scalar to be the unqualified version of its declared type.</p>
<h3>Section 6.3.1.3 paragraph 3</h3>
<p>Otherwise, the new type is signed and the value cannot be represented in it; either the result is implementation-defined or an implementation-defined signal is raised.</p>
</blockquote>
<p>If, in your implementation, <code>int</code> is 32-bit, then <code>0xffffffff</code> is too large to fit into a 32-bit int (which can hold up to 2,147,483,647, but <code>0xffffffff</code> = 4,294,967,295).</p>
",6
20091387,20090974,1,"<p>There are two alternatives:</p>

<ul>
<li><p><code>sizeof(int) &gt; 4</code></p>

<p>(43239 &lt; 4294967295) == true</p></li>
<li><p><code>sizeof(int) == 2</code>, where this particular implementation defined behavior occurs</p>

<p>( -22297 &lt; -1) == true</p></li>
</ul>
",0
20516372,20516319,1,"<p>It depends by the compiler. However in C there are no default values for variables unlike Java or other languages so you can't have any expectation from what there are in your variables.</p>
",1
20516515,20516319,2,"<p>If you do not initialize your <code>struct mq_attr</code>, but supply it when you do <code>mq_open</code>, the variables will have unspecified content. Meaning the mq_attr could have random values. </p>

<p>So</p>

<pre><code>struct mq_attr attr; //Will be uninitialized -&gt; bad thing
q = mq_open(""/mqtest"",O_RDWR|O_CREAT,0660,&amp;attr);
</code></pre>

<p>As always, in C, you need to initialize variables before using them.</p>

<p>You can pass NULL for the attribute to mq_open() to get the system defaults though.</p>

<p>You can learn the system defaults yourself. They're system dependent, and defaults might be tunable via sysctls, resource limits or similar.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;mqueue.h&gt;


int main(int argc, char *argv[])
{
    struct mq_attr attr;
    /*
    struct rlimit limit;
    if(getrlimit(RLIMIT_MSGQUEUE,&amp;limit) == -1) {
        perror(""getrlimit"");
        return 1;
    }
    printf(""RLIMIT_MSGQUEUE cur = %ld,max = %ld\n"",(long)limit.rlim_cur,(long)limit.rlim_max);
    */

    mqd_t q = mq_open(""/mqtest"",O_RDWR|O_CREAT,0660,NULL);
    if(q == -1) {
        perror(""mq_open"");
        return 1;
    }
    if (mq_getattr(q, &amp;attr) == -1) {
        perror(""mq_getattr"");
        return 1;
    }
    printf(""mq_flags %ld\n"",  attr.mq_flags);
    printf(""mq_maxmsg %ld\n"", attr.mq_maxmsg);
    printf(""mq_msgsize %ld\n"",attr.mq_msgsize);
    printf(""mq_curmsgs %ld\n"",attr.mq_curmsgs);
    mq_close(q);
    mq_unlink(""/mqtest"");
    return 0;
}
</code></pre>

<p>The commented out part can give you the rlimit for the max bytes in a queue on linux, set with e.g. the ulimit command.</p>
",0
17091810,17091746,8,"<p>Your <code>fprintf</code> call has 8 format specifiers but passes 9 further arguments to fill these.</p>

<p>The 8th format specifier is <code>%d</code>; the argument corresponding to this is <code>Item[i]-&gt;Name</code>.  The warning is telling you that <code>Item[i]-&gt;Name</code> is a string so can't (shouldn't) be converted to a signed integer.</p>

<p>I presume <code>Item[i]-&gt;Price</code> has type <code>int</code>; you then either need to add an extra <code>%s</code> to your format string (anywhere before the <code>%d</code>) or remove one of the string arguments.</p>
",4
17387432,17384713,0,"<p>The exercise states:</p>

<pre><code>Output ""Yes"" if Vova is right and ""No"" otherwise.
</code></pre>

<p>Your program prints <code>Enter number</code>, which the exercise does not ask for. Try to remove that.</p>

<p>Also, for your own and our sanity, I strongly recommend you format your program better. Finding errors is much easier in a beautiful, well-formatted program. For tips on how to make your code more readable and clean, you can head over to <a href=""https://codereview.stackexchange.com/"">CodeReview.SE</a>.</p>
",0
17405229,17405186,5,"<p>Well <code>a</code> is the name of the array which you cannot increment. It is illegal to change the address of the array.</p>

<p>So define a pointer to <code>a</code> and then increment </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;

 int main()
 {
     int i;
     char a[]=""Hello"";
     char *ptr = a;
     while(*ptr!='\0')
     {
         printf(""%c"",*ptr);
         // a++ here would be illegal
         ptr++;
     }
     getch();
     return 0;
 }
</code></pre>

<p><code>NOTE:</code></p>

<p>In fact, arrays in C are non-modifiable <code>lvalues</code>. There are no
  operations in C that can modify the array itself (only individual
  elements can be modifiable).</p>
",0
17405260,17405186,2,"<p>In your code, <code>a</code> is a name of an array, you can't modify it like <code>a++</code>. Use a pointer like this:</p>

<pre><code>char *p = ""Hello"";
while(*p++)
{
     printf(""%c"",*p);
}
</code></pre>
",0
17405418,17405186,1,"<p>Three problems:</p>

<ol>
<li><code>char a[]={""Hello""};</code> is illegal. <code>{""Hello""}</code> can only initialize <code>char* a[]</code>. You probably want <code>char a[]=""Hello"";</code></li>
<li><code>while(a!='\0')</code> - you probably meant <code>*a != '\0'</code>. <code>a</code> is the array itself.</li>
<li><code>a++;</code> - an array cannot be incremented. you should increment a pointer pointing to it.</li>
</ol>
",0
17406978,17405186,0,"<p>You can also try it using a for loop:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void) {
   char a[] = ""Hello"";
   char *p;

   for(p = a; *p != '\0'; p++) {
      printf(""%c"", *p);
   }

   return 0;
}
</code></pre>
",0
19212564,19212537,6,"<p>You forgot to enclose the while block in curly braces:</p>

<pre><code>while (fgets(str, MAXCHAR, fp) != NULL) {
    number = (int)strtol(str, NULL, 0);
    printf(""%d\n"", number);
}
</code></pre>

<p>Your code is equivalent to </p>

<pre><code>while (fgets(str, MAXCHAR, fp) != NULL) {
    number = (int)strtol(str, NULL, 0);
}
printf(""%d\n"", number);
</code></pre>

<p>which explains why you get only one line of output.</p>
",6
17775062,17774820,2,"<p>inside your outer while you should reset ""j"" to zero.</p>

<p>if ""k"" bekomes 1, you do not increment ""i"" any more. if you run squeeze() a second time, you do not initialize ""k"" again.</p>

<p>never use global variables (or module local variables) like ""k"". This makes your code thread-unsafe.</p>
",2
17776714,17774820,1,"<p><em>high five</em> -- I'm reading that chapter, too. I think I've read it about 4 times, anyway I really need to learn by doing, I forget all the content within a few hours. That's why I've nearly finished all the exercises in that chapter - chapter 3 next!</p>

<p>Here's my solution -- the squeeze function is not compatible with the getline function (the <code>/0'</code> are forcing <code>printf</code> to not print to std out.</p>

<p>Compile on <code>gcc 4.7.2</code> with</p>

<p><code>gcc -Wall -std=c99 -pedantic squeeze.c</code></p>

<pre><code>#include &lt;stdio.h&gt;
#define LIM 100

void squeeze(char[], char[]);
int ggetline(char[], int);

int main()
{
    //the getline function is buggy; it would produce null strings.
    char line1[LIM] = ""hello"";
    char line2[LIM] = ""hello2"";
    squeeze(line1, line2);
    printf(""%s %s\n"", line1, line2);

return 0;

}


/* getline: reads line into s, returns length */
int ggetline(char s[], int lim)
{
    int c, i;

    for (i = 0; i &lt; lim-1 &amp;&amp; (c = getchar()) != EOF &amp;&amp; c!='\n'; ++i)
        s[i] = c;
    if (c == '\n') {
        s[i] = c;
        ++i;
    }
    s[i] = '\0';
    return i;
}

void squeeze(char s1[], char s2[])
{
    int j, l, i, k;

    for (i = 0; s2[i] != '\0'; i++) {
        for (k = l = 0; s2[j] != '\0'; j++) {
            if (s1[j] != s2[i])
                s1[k++] = s1[j];
        }
        s2[k] = '\0';

    }
}
</code></pre>

<p>Good luck! </p>
",1
17864476,17864363,8,"<ul>
<li><code>printf</code> is a pointer to the <code>printf</code> function - thus it's ultimately an integer of some sort. </li>
<li><code>!</code> is unary NOT, meaning it returns <code>0</code> if the operand is true, and <code>1</code> is the operand is false. Since <code>printf</code> is true (non-zero, because the function is defined), the subexpression so far is <code>0</code>.</li>
<li><code>~</code> is bitwise complement. It flips all the bits of the binary number it is given. Since it is given <code>0</code>, this will return <code>0xffffffff</code>.</li>
<li>That result is then stored into <code>x</code> and printed out in hexadecimal. </li>
</ul>

<p>On a 64-bit machine you might instead get <code>0xffffffffffffffff</code>, though I'm not entirely certain.</p>
",4
17860354,17860147,5,"<p>This can work:  </p>

<pre><code>snprintf(sendbuf, sizeof(sendbuf), ""%.1fabc%d"", count, i);
</code></pre>
",5
17860384,17860147,1,"<p>Add a byte to the output array.  The first element needs 3 characters (bytes) not one.</p>

<pre><code>sprintf(sendBuffer,""%0.1f"",count);
sendBuffer[3] = 'a';
....
</code></pre>
",3
17860944,17860147,8,"<p>I see the answers you're getting answer the problem, but don't give an explanation, and from the looks of it, you could use a good explanation, so here's what's happening:</p>

<h3>Types in C</h3>

<p>You need to understand that different types (<code>int</code>, <code>char</code>, <code>float</code>, <code>double</code>) take up different sizes in memory.  In C, a <code>char</code> is always considered to take up a single byte, and is in the range of -127 to 128.  (<code>unsigned char</code> goes from 0 to 255.)  <code>int</code>s take up 4 bytes, and their range is from -2M to 2M - 1.  <code>float</code> and <code>double</code> take 4 and 8 bytes respectively, and have a huge range, but limited precision.  (For more information, just search for ""c type ranges"", and you'll find lots of information, including these links on Stack Overflow, which also give you good explanations: <a href=""https://stackoverflow.com/questions/944224/definition-of-range-of-a-data-type"">Definition of range of a data type</a>, <a href=""https://stackoverflow.com/questions/14815180/guarantateed-minimum-size-range-of-c-data-types"">Guarantateed minimum size/range of C data types</a>).</p>

<p>Also, you know enough ascii to know to add 48 to a digit to get the char version, but make sure you have an ascii table nearby.  Conveniently, you can find one at <a href=""http://www.asciitable.com"" rel=""nofollow noreferrer"">http://www.asciitable.com</a>.</p>

<p>You also have to understand that the compiler will do its best to convert from one to another, though in some cases, such as casting a <code>float</code> to an <code>int</code>, if you don't do it explicitly, your compiler should at least issue a warning.</p>

<p>Strings don't exist as a type in C.  Instead, you print into an array.  Other answers tell you how to do that.  What their code is doing is printing the values you want into a character array, which is all you need.</p>

<h3>What your code is doing</h3>

<p>Now, let's see what your current code is doing:</p>

<p>First of all, a quick sidebar: when you're doing a <code>for</code> loop, it's best to put the increment in the loop itself, so:</p>

<pre><code>for(count=1.5;count&lt;=2.5;count=count+0.5)
{
  for(i=0;i&lt;=15;i=i+5)
</code></pre>

<p>would be more standardized.</p>

<p>Now, your first line is <code>sendBuffer[0]=count+48;</code>.  Here's what happens:</p>

<ol>
<li>You're taking count, which starts at 1.5, and adding 48, so the first number is 49.5.</li>
<li>The compiler will automatically change a <code>float</code> to an <code>int</code>, though it should give you a warning about it.  It does so by truncating the value, changing 49.5 to 45.  </li>
<li>It then changes <code>(int)49</code> to <code>(char)49</code> which is the same value, but takes up one byte instead of 4.  Ascii 49 is '1', so this happens to be the number you wanted.</li>
<li>The compiler does <em>not</em> do anything with the rest of the float.  It never sets sendBuffer[1] or [2] for this value.</li>
</ol>

<p>Your next 3 lines hard code the second, third and fourth characters of the string to <code>abc</code>.  Even if your first line had set the full float value into <code>sendBuffer</code>, this would overwrite it.</p>

<p>Your final line takes i, which will be 0, 5, 10 and 15, and adds it to 48.  This is just like the first step, without the truncation from <code>float</code>.  So first it looks up ascii 48, which is '0', then ascii 53, which is '5'.  When <code>i</code> is 10, it now takes the int 58 and converts it to a character (again, changing it from 4 bytes to 1 byte).  Printing ascii 58 results in ':', and printing ascii 63 results in '?'.  And that's how your output ended up the way it did.</p>

<h3>Possible solutions</h3>

<p>Finally, a few words on the solution you were given:</p>

<p>Since all you're doing is outputting the result, you don't need <code>sendBuffer</code> nor <code>snprintf</code>.  Simply using</p>

<pre><code>printf(""%.1fabc%d\n"", count, i);
</code></pre>

<p>would have sufficed.</p>

<p>It's instructive to think about what the printf family of functions does, though.  Though it's less efficient, let's use a few <code>snprintf</code>s to see what it's doing:</p>

<pre><code>int index = 0;
index = snprintf(&amp;sendbuf[index], sizeof(sendbuf) - index, ""%.1f"", count);
index += snprintf(&amp;sendbuf[index], sizeof(sendbuf) - index, ""abc"");
index += snprintf(&amp;sendbuf[index], sizeof(sendbuf) - index, ""%d"", i);
sendbuf[index++] = '\n';
sendbuf[index] = '\0';
</code></pre>

<p>What this does is what <code>*printf</code> does when you pass it multiple arguments: keep track of how much you've written and use that to tell where you're writing the next parts.</p>

<p>If you don't know it, the <code>a += b</code> syntax is shorthand for <code>a = a + b</code>.  <code>a++</code> means ""give me the value of a, then increment it.""</p>

<p>So the second line of my code will print out the float value into sendbuf, starting at the 0 position.  <code>*printf</code> always returns the number of characters printed, so in this example, it will always print 3 characters, and I set <code>index</code> to 3.</p>

<p>The next line writes the string abc into sendbuf, starting at position 3, and the line after that prints the value of <code>i</code> into position 6.  Finally, I add the \n for the new line, and the last line is the null terminator.  I don't put <code>index++</code> because I don't care about index any more, so don't need to bother incrementing it.  I put <code>\0</code> (as did you above) instead of 0, simply because <code>\0</code> reminds the programmer that we're dealing with a char array, not an integer array.</p>

<p>Again, all these lines aren't necessary, but since some of the issue seemed to be understanding what <code>printf</code> does, I thought it would be helpful.</p>
",2
20519464,20519396,-1,"<p>Typecast the 'number' assignment and try like this,</p>

<pre><code>int x = 2;
int *pointer2 = &amp;x;
int number = (int)&amp;x;
</code></pre>

<p>This will work.</p>
",0
20519473,20519396,7,"<p><code>number</code> is an <code>int</code>, initialized with the address of <code>x</code> (makes <code>int</code> from address ""without cast"" - the warning tells you, that this is probably not what you want) - if you increment it, it will be incremented by one.</p>

<p><code>pointer2</code> is a pointer to <code>int</code> (initialized with the same address of <code>x</code>), incrementing it increments by <strong>size</strong> of <code>int</code> (this behaviour is called ""pointer arithmetics"").</p>
",0
20519523,20519396,0,"<p>The compiler doesn't convert number from int to pointer. The warning says <em>""make integer from pointer""</em>, not <em>""make pointer from integer""</em>, so <code>number</code> is still an <code>int</code>. It's the pointer (the address of <code>x</code>) which has been ""converted"" to a plain integer.</p>
",0
20519573,20519396,1,"<p>The warning is because of this assignment:</p>

<pre><code>int number = &amp;x;
</code></pre>

<p>You are assigning an <code>int*</code> to an <code>int</code>, which is nothing you should do. Either (1) assign the value of the <code>x</code> to <code>number</code>, or (2) change <code>number</code>'s type to <code>int*</code> (link <code>pointer2</code>) and assign the address of <code>x</code>.</p>

<p>Or (3) if you really want to assign the address of <code>x</code> to <code>number</code> use a typecast.</p>

<pre><code>// (1)
int number = x; // Assign value of x.
// (2)
int* number = &amp;x; // Assign address of x.
// (3)
int number = (int)&amp;x; // Assign address of x and cast to int.
</code></pre>

<hr>

<p>Your second question has to do with pointer arithmetic.</p>

<p>Your <code>number</code> variable is an <code>int</code>, which means if you increment it (<code>+ 1</code>) it is literally incremented by 1.</p>

<p>Your <code>pointer2</code> variable is an <code>int*</code>, which means if you increment it it is incremented by the size of an <code>int*</code> (4 byte on 32 bit systems, 8 byte on 64 bit systems).</p>

<p>This is done, so that you can iterate over pointer arrays by simply incrementing the pointer.</p>

<p>There are two reasons the compiler emits a warning:</p>

<p>1) The type mismatch is not handled implicitly by the compiler, because the standard says so. And this in return is since converting from a pointer type to another type has a rare use case. Most of the time assignments like this are made accidentally and the author simply messed up the level of indirection (the number of <code>*</code>).</p>

<p>2) Another reason why the standard prohibits this, is that <code>int</code> is 4 bytes (in most implementations) and <code>int*</code> can be either 4 or 8 bytes depending on the platform compiled for.</p>
",4
20522016,20519396,0,"<p>You get the warning because it's not guaranteed that the <code>int</code> type can hold a pointer value (for example, you're on a system where <code>int</code> is 16 bits but pointer values are 32 bits); if you add a cast, you tell the compiler that you know what you're doing (even if you don't):</p>

<pre><code>int number = (int) &amp;x;
</code></pre>

<p>This tells the compiler that yes, you really want to take the address of <code>x</code> and treat it as an ordinary integer.  Just be aware that the value that gets stored to <code>number</code> may be truncated.  </p>

<p>Nor is it guaranteed that all pointer types have the same size and representation; IOW, a pointer to <code>int</code> may be a different size than a pointer to <code>char</code>, which may be a different size from a pointer to a <code>struct</code>.  On most modern desktop and server architectures they are the same, but there are still some oddball architectures out there where they're not.  </p>

<p>As for why you got different results on the additions...</p>

<p>Adding 1 to a pointer gives the address of the next <em>object</em> of the pointed-to type; IOW, if you have a pointer to <code>int</code>, adding 1 will give you the address of the next available <code>int</code>, which is <code>sizeof (int)</code> bytes from the current address.  If you have a pointer to a 10-element array of <code>int</code>, adding 1 will give you the address of the next 10-element array of <code>int</code>, which is <code>10 * sizeof (int)</code> bytes from the current address.  </p>

<p>This is how array indexing works. The expression <code>a[i]</code> is interpreted as <code>*(a + i)</code>; that is, compute the address of the <code>i</code>'th <em>element</em> following <code>a</code>, and dereference the result.    </p>
",0
18864585,18864362,1,"<p>One problem is the outer loop:</p>

<pre><code>while (y == 512)
{
    ...lots of code...
    y = fread(&amp;block, sizeof(block), 1, fp);
    ...some code...
}
</code></pre>

<p>The <code>fread()</code> sets <code>y</code> to <code>0</code> or <code>1</code>, so it is no longer 512, so the loop terminates.</p>

<p>I think there is also a problem with the <code>if (x == 0)</code> followed by <code>x = 1;</code>, but I'm not sure I understand the logic behind that part of the code.  Certainly, <code>x</code> is not reset to zero after the first file is read ¡ª if that matters.</p>

<hr>

<p>This extracts files 000..050 from the sample data, and <code>file</code> describes them all as one of these three types:</p>

<ul>
<li>JPEG image data, EXIF standard</li>
<li>JPEG image data, JFIF standard 1.01</li>
<li>JPEG image data, JFIF standard 1.02</li>
</ul>

<h3>Working code</h3>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;

typedef uint8_t BYTE;

#define BLOCKSIZE 512

static inline int is_jpeg_file_header(const BYTE *block)
{
    if (block[0] == 0xff &amp;&amp; block[1] == 0xd8 &amp;&amp; block[2] == 0xff &amp;&amp;
            (block[3] == 0xe0 || block[3] == 0xe1))
        return 1;
    return 0;
}

int main(void)
{
    BYTE block[BLOCKSIZE];
    const char file[] = ""card.raw"";

    FILE* fp = fopen(file, ""r"");
    if (fp == NULL)
    {
        fprintf(stderr, ""Error opening file %s for reading\n"", file);
        return 1;
    }

    int num = 0;

    while (fread(&amp;block, sizeof(block), 1, fp) == 1)
    {
        if (is_jpeg_file_header(block))
        {
            char filename[20];
            snprintf(filename, sizeof(filename), ""%03d_output.jpg"", num);
            FILE* outfile = fopen(filename, ""a"");
            if (outfile == 0)
            {
                fprintf(stderr, ""Error opening file %s for writing\n"", filename);
                return 1;
            }
            printf(""%s\n"", filename);

            fwrite(&amp;block, sizeof(block), 1, outfile);
            while (fread(&amp;block, sizeof(block), 1 , fp) == 1 &amp;&amp;
                    !is_jpeg_file_header(block))
            {
                fwrite(&amp;block, sizeof(block), 1, outfile);
            }
            fclose(outfile);
            num++;
            fseek(fp, -BLOCKSIZE, SEEK_CUR);
        }
    }

    fclose(fp);

    return 0;
}
</code></pre>

<p>This uses the fact that we're reading a disk image to seek back one block when you read the header of the next file.  It is simpler than continuing the code.</p>

<p>The first 11 recovered images are all displayable in a web browser.</p>
",5
19018011,19016720,0,"<p>Lets assume OP wants an array of <code>struct MemBlock</code> when done</p>

<p>C pseudo code (error handling omitted)</p>

<pre><code>struct MemBlock {
  unsigned long address;   // Data is obviously hexadecimal
  char ReadorWrite;
};

FILE *inf = fopen(filename, ""rt"");  // Use ""rt""
size_t line = 0;
char buffer[1+1+16+2+100]; // big enough for expected letter and number + change
while (fgets(buf, sizeof buf, inf) != NULL) line++;
frewind(inf);
struct MemBlock *Array = calloc(line, sizeof *Array);
for (size_t i = 0; i&lt; line; i++) {
  if (fgets(buf, sizeof buf, inf) != NULL)) handle error
  if (2 !=sscanf(""%c%lx"", &amp;Array[i].ReadorWrite, &amp;Array[i].address)) handle error
}
fclose(inf);
// Use Array[] with length `line`.
...
free(Array)
</code></pre>

<hr>

<p>I like the one-pass link list idea, but wanted to offer another POV.</p>
",0
19018137,19016720,0,"<p>There are two many method like <code>sscanf()</code> or use <code>strchr()</code> or in c++, something like <a href=""http://www.boost.org/doc/libs/1_54_0/libs/filesystem/example/tut3.cpp"" rel=""nofollow"">http://www.boost.org/doc/libs/1_54_0/libs/filesystem/example/tut3.cpp</a> </p>
",0
19019818,19019744,0,"<p>You can use <a href=""http://en.cppreference.com/w/c/string/byte/strcmp"" rel=""nofollow"">strcmp()</a> or <a href=""http://en.cppreference.com/w/c/string/byte/strncmp"" rel=""nofollow"">strncmp()</a> ,to compare input with ""end""</p>

<pre><code>fgets(input,MAX_SIZE,stdin);
if(strncmp(input,""end"",3)==0)
{
//you have reached the end of the day
}
</code></pre>
",1
19264047,19264007,1,"<p>What you are doing is Undefined Behavior.</p>

<pre><code>char * strcpy ( char * destination, const char * source )
</code></pre>

<p><a href=""http://en.cppreference.com/w/c/string/byte/strcpy"" rel=""nofollow"">strcpy</a> expects a destination which can be modified. You are passing a <code>char **</code> which is causing the problem since you have not allocated any memory for it to write to.</p>

<p>This is what (perhaps) you were trying:</p>

<pre><code>  char* key = malloc(sizeof(char)*7); // 7 because it can Hold World with a Nul character

  strcpy(key, ""Hello"");
  strcpy((key+1), ""World"");

  printf(""%s"", key);
</code></pre>
",2
19264073,19264007,0,"<p>You must allocate memory to before you do <code>strcpy()</code>, if you want to skip allocating memory try <code>strdup()</code>.</p>

<p>To simplify, not sure you really want <code>char **key</code>, doing with <code>char *key</code></p>

<pre><code>char* key = malloc(sizeof(char) * 100); //allocate to store 100 chars
strcpy(key, ""Hello"");
strcpy(key + strlen(key), ""World"");
//or strcat(key, ""World"");
</code></pre>

<blockquote>
  <p>the second strcpy has no error, while the first strcpy has a segmentation fault</p>
</blockquote>

<p>How do you know 2nd one does not have error when it never executed because of segmentation fault?</p>
",0
19264079,19264007,0,"<p>No memory has been allocated for <code>key</code>.  You can allocate memory using <code>malloc</code> before the first <code>strcpy</code>.</p>

<pre><code>*key = malloc(32 * sizeof(char));     // pick a size of buffer
</code></pre>

<p>I suspect the second call will also cause a segfault.  It's (probably) going to be writing into unallocated space.  </p>
",1
19264092,19264007,1,"<p>It is not clear in your code whether you are allocating any buffer for key. I believe that's why you are getting SEG fault.</p>
",0
19379394,19379353,9,"<p><code>#define</code>-d names have no types. They just define textual replacements.</p>

<p>What the compiler is seeing is the preprocessed form. If using GCC, try <code>gcc -C -E  somesource.c</code> and have a look at the (preprocessed) output.</p>

<p><sup>In the 1980s the preprocessor was a separate program.</sup></p>

<p>Read about the <a href=""http://gcc.gnu.org/onlinedocs/cpp/"" rel=""nofollow"">cpp</a> preprocessor, and <a href=""http://en.wikipedia.org/wiki/Preprocessor"" rel=""nofollow"">preprocessor</a> and <a href=""http://en.wikipedia.org/wiki/C_preprocessor"" rel=""nofollow"">C preprocessor</a> wikipages.</p>

<p>You could even define ill-defined names like</p>

<pre><code>#define BAD @*?$ some crap $?
</code></pre>

<p>And even more scary you can define things which are syntactically incomplete like</p>

<pre><code>#define BADTASTE 2 +
</code></pre>

<p>and later code <code>BADTASTE 3</code></p>

<p>Actually, you want to use parenthesis when defining macros. If you have</p>

<pre><code>#define BADPROD(x,y) x*y
</code></pre>

<p>then <code>BADPROD(2+3,4+5)</code> is expanded to <code>2+3*4+5</code> which the compiler understands like <code>2+ (3*4) +5</code>; you really want</p>

<pre><code>#define BETTERPROD(x,y) ((x)*(y))
</code></pre>

<p>So that <code>BETTERPROD(2+3,4+5)</code> is expanded to <code>((2+3)*(4+5))</code></p>

<p>Avoid side-effects in macro arguments, e.g. <code>BETTERPROD(j++,j--)</code></p>

<p>In general, use macros with care and have them stay simple.</p>
",0
19379435,19379353,3,"<p><code>#define STRING VALUE</code></p>

<p>is just an instruction for the pre-processor to replace the STRING with VALUE
afterwards the compiler will take control and will check the types</p>
",0
19379439,19379353,1,"<p>It doesn't.  The <code>#define</code> statements are processed before the compiler starts its work.  Basically the pre-processor does a search and replace for what you wrote and replaces it, for instance, all instances of <code>INTEGER_EXAMPLE</code> are replaced with the string <code>2</code>.  </p>

<p>It is up to the compiler to decide the type of that <code>2</code> based on where it's used:</p>

<pre><code>int x = INTEGER_EXAMPLE; // 2 is an integer
char y = INTEGER_EXAMPLE; // 2 is a char
</code></pre>
",0
19379462,19379353,3,"<p>Regarding these defines, it doesn't, the expanded macros doesn't have a type. The pre-processor which processes the #define is just replacing text within the source code</p>

<p>When you use these defines somewhere, e.g.</p>

<pre><code>int i = INTEGER_EXAMPLE;
</code></pre>

<p>This will expand to</p>

<pre><code>int i = 2;
</code></pre>

<p>Here the literal 2 (which in this context is an int) is assigned to an int.</p>

<p>You could also do:</p>

<pre><code>char c = INTEGER_EXAMPLE;
</code></pre>

<p>Here too, the literal 2 is an int, and it is assigned to a char. 2 is within the limits of a char though, so all is ok.</p>

<p>You could even do:</p>

<pre><code>int INTEGER_EXAMPLE = 2;
</code></pre>

<p>This would expand to </p>

<pre><code>int 2 = 2;
</code></pre>

<p>Which isn't valid C.</p>
",0
19379466,19379353,1,"<p>Preprocessor cannot know the type of the macro definition. Preprocessor will just replace all occurrence of 'CHAR_EXAMPLE' with '2'. I would use cast:  </p>

<pre><code>#define CHAR_EXAMPLE ((char)2)
</code></pre>
",0
19379467,19379353,2,"<p>It doesn't, this is the preprocessor.  The type of the constant is dependent on the context in which it is used.  For instance:</p>

<pre><code>#define INT_EXAMPLE 257

char foo = INT_EXAMPLE;
</code></pre>

<p>will attempt to assign 257 in a char context which should generate a warning unless <code>char</code> has more than 8 bits on your computer.</p>
",0
19379495,19379353,2,"<p><code>#</code>Defines are nothing but literal replacements of values. You might want to use </p>

<pre><code>static const
</code></pre>

<p>As it respects scope and is type-safe. Try this:</p>

<pre><code>#define main no_main

int main()  // gets replaced as no_main by preprocessor
{
    return 0;
}
</code></pre>

<p>Should give you linking errors. Or you could try and fool your teacher by this</p>

<pre><code>#define I_Have_No_Main_Function main //--&gt; Put this in header file 1.h

#include""1.h""

int I_Have_No_Main_Function()
{
    return 0;
}
</code></pre>
",0
19324999,19324906,1,"<p>You pass the file name in using the argv[] array that is declared when you create main. Because fopen in C takes a char, or char array you can then open the file specified through the command line. For all the information you should need regarding this use the site I link.</p>

<p><a href=""http://www.cprogramming.com/tutorial/c/lesson14.html"" rel=""nofollow"">http://www.cprogramming.com/tutorial/c/lesson14.html</a></p>
",0
19325233,19324906,0,"<p>From command line you can pass file to write some thing and file which will be reversed</p>

<pre><code>Your program looks like  

int main(int argc,char *argv[] )
{
//...
return 0;
}    
</code></pre>

<p>compile </p>

<pre><code>  gcc program.c -o out
</code></pre>

<p>You need to pass files like this </p>

<pre><code> ./out file_to_write file_to_write_in_reverse 
</code></pre>

<p>------------------------------------------------------------or---------------------------------------------------------------------</p>

<p>In Your Program</p>

<p>use <code>fgets()</code> and read file name of file_to_write</p>

<p>You can create a file.</p>

<pre><code> fopen()+ w+ mode
</code></pre>

<p>Write data, for example write string into file</p>

<pre><code>`fprintf()` or `fputs()` 
</code></pre>

<p>use <code>fgets()</code> and read another file name of file_to_write_in_reverse </p>

<p>create file_to_write_in_reverse</p>

<pre><code>fopen()+ w mode
</code></pre>

<p>and now Use <code>fseek()</code>, <code>fgetc()</code> and <code>fputc()</code></p>
",3
19969149,19968895,0,"<p>Not sure if this is what you want but you can double <code>\n</code> characters like this:</p>

<pre><code>if(ch==EOF)
    break;
else 
    putc(ch,fp2);

if(ch=='\n')
    putc(ch,fp2);
</code></pre>
",0
19969175,19968895,0,"<p>I suggest you try this:</p>

<pre><code>while(1)
{
   ch = fgetc(fp1);

   if (ch == '\n')
      putc(ch,fp2);

   if(ch==EOF)
      break;
   else
      putc(ch,fp2);
}
</code></pre>
",0
19802249,19802210,1,"<p>Its because of these:</p>

<pre><code>scanf (""%d"", &amp;pickedDoor);// reads \n after the last input
scanf(""%d"", &amp;option);     // reads \n after the last input

**option != hostDoor; // completely useless  .. get rid of it**
</code></pre>

<p>I would suggest putting a <code>getchar()</code> after each <code>scanf</code> to get rid of the \n character</p>

<p><strong>so something like this:</strong></p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

int main (void)
{
    int pickedDoor, remainingDoor, hostDoor, winningDoor, option, games = 0, wins = 0;
    char collect; //variable to collect any extra input like \n
    float frequency = 0;
    srand (time(NULL));

  while (1)
    {
        printf (""Pick one of the three doors infront of you, which do you want?\n"");

        scanf (""%d"", &amp;pickedDoor);
        collect = getchar();  // get rid of the \n from the input stream
        printf(""collect = %c\n"",collect);
        if(collect!='\n'){    // is it actually a \n or did you take in something else
           putchar(collect);  // if it isn't \n put it back
        }

        if (pickedDoor &gt; 3 || pickedDoor &lt;= 0)
        {
            break;
        }

        winningDoor = rand() % 3 + 1;


        do
        {
            hostDoor = rand() % 3 + 1;
        } while (hostDoor == pickedDoor || hostDoor == winningDoor);

        do
        {
            remainingDoor = rand() % 3+1;
        } while (remainingDoor == pickedDoor || remainingDoor == hostDoor);

        printf(""Do you want to switch doors? Please enter in the door you want:\n"");
        scanf(""%d"", &amp;option);
        collect = getchar();  // get rid of the \n from the input stream
        printf(""collect = %c\n"",collect);
        if(collect!='\n'){    // is it actually a \n or did you take in something else
           putchar(collect);  // if it isn't \n put it back
        }

        if (option &gt; 3 || option &lt;= 0 )
        {
            return 0;
        }

        if (option == winningDoor)
        {
            printf(""You Won!\n"");
            wins++;
        }

        else if (option == remainingDoor)
        {
            printf(""YOU LOSE!\n"");
        }

        games++;
    }
    frequency = ((float) wins / games) *100;
    printf (""The number of games that you won is %d\n"", wins);
    printf (""The frequency of winning is %.0f%%\n"", frequency);

    return 0;
}
</code></pre>

<p>Another more efficient way would be to use <code>fgets</code> or to have error checks on <code>scanf()</code> itself </p>
",7
19802525,19802210,1,"<p>To simulate correctly, OP needs to show the host door.</p>

<pre><code>do {
  printf(""Do you want to switch doors? Please enter in the door you want:\n"");
  scanf(""%d"", &amp;option);
  if (option &gt; 3 || option &lt;= 0 ) {
    return 0;
    }
  } while (option == hostDoor);

// instead of 
#if 0
printf(""Do you want to switch doors? Please enter in the door you want:\n"");
scanf(""%d"", &amp;option);
if (option &gt; 3 || option &lt;= 0 ) { return 0; }
#endif
</code></pre>

<hr>

<p>To deal with OP "" it should tell me if i have won or lost."" problem, change</p>

<pre><code>else if (option == remainingDoor)
</code></pre>

<p>to</p>

<pre><code>else
</code></pre>

<hr>

<p>Your <code>scanf(""%d"", &amp;option)</code> is OK.  I prefer the <code>fgets()/sscanf()</code> combo and its alway useful to check the result of <code>scanf()</code> family, but that is not your issue here.</p>
",5
19802783,19802210,0,"<p><code>srand and rand</code> belongs to <code>stdlib</code> header file</p>

<pre><code>#include&lt;stdlib.h&gt; // include this header file 

 option != hostDoor; // this statement does not do anything
</code></pre>

<p>and your <code>else if (option == remainingDoor)</code> should be  <code>else { printf(""you lose"");}</code></p>
",0
19504144,19504062,0,"<p>Your first error is that function <code>getStats</code> does not always return a value.</p>

<p>Indeed, when I look at the function, I don't see any <code>return</code> statement anywhere in the function.</p>

<p>When I look at the prototype, I see:</p>

<pre><code>int getStats(...
</code></pre>

<p>indicating that it is <em>supposed</em> to return an <code>int</code>.</p>

<p>You should either change the function so that it returns an <code>int</code>, or change the declaration of the function to be <code>void</code>, indicating that it is not supposed to return a value.</p>
",0
19504151,19504062,1,"<p>Warning #1: Your getStats function can exit in two places, but only the first place actually returns a value. it should be some more like:</p>

<pre><code>function getStats() {
  if (...) {
     return foo;
  }
  ....
  return baz; &lt;--missing this
}
</code></pre>

<p>Warning #2: You declare <code>bodyMassIndex</code> at the start of the function, but then pass it into <code>printWeightStatus</code> without ever having assigned a value to it:</p>

<p>Warning #3: Ditto, you declare statsFP, but pass it into a function without every initializing it, and THEN initialize it within getStats</p>
",0
19968903,19968794,4,"<p>Returning from <code>main</code> is equivalent to calling <a href=""http://linux.die.net/man/3/exit"" rel=""nofollow""><code>exit</code></a>, which does a bunch of cleanup operations (such as flushing open <code>FILE</code> objects and running <a href=""http://linux.die.net/man/3/atexit"" rel=""nofollow""><code>atexit</code></a> procedures) and then calls <a href=""http://linux.die.net/man/2/_exit"" rel=""nofollow""><code>_exit</code></a>, which is the system call that actually terminates a process.  So when you call <code>_exit</code> directly, you skip all of those cleanup operations.</p>

<p>You are using <a href=""http://linux.die.net/man/2/vfork"" rel=""nofollow""><code>vfork</code></a>.  It is incorrect (formally, it ""provokes undefined behavior"") to do <em>anything</em> on the child side of a <code>vfork</code> except call <code>_exit</code> or <a href=""http://linux.die.net/man/2/execve"" rel=""nofollow""><code>execve</code></a>.  Returning from <code>main</code> counts as doing something else (namely, calling <code>exit</code>).  It is not at all surprising, therefore, that your program crashes.</p>

<p><strong>EDIT:</strong> As far as the relevant specifications are concerned, modifying the variables <code>g_a</code> and <code>l_b</code> on the child side of the <code>vfork</code> is <em>also</em> forbidden, in the same dire terms (""undefined behavior"" in the strong sense, i.e. ""allowed to cause your program to crash"").  <em>However,</em> in all extant implementations I am aware of, catastrophe only strikes if the child does anything to cause memory (including stack frames) to be allocated or deallocated.  Modifying variables that were allocated by the parent, but visible to the child (whether local or global) is unpredictable in a much more bounded manner:</p>

<ol>
<li>If <code>vfork</code> is just another name for <code>fork</code>, nothing the child does will be visible in the parent;</li>
<li>But if <code>vfork</code> has its special behavior of delaying allocation of the new address space until <code>execve</code>, then modifications by the child <em>to variables resident in memory</em> will be visible in the parent after the parent resumes execution.  (Variables resident in registers may or may not get reset when the kernel restores the parent's execution context, depending on how full a context switch that does.)</li>
</ol>

<p>And, if you know your OS is type 2, you can get away with using this to your advantage, e.g. to pass <code>errno</code> back to the parent after <code>execve</code> fails, which is significantly harder with plain <code>fork</code> (because the exit status is too narrow).  It is, however, something you are getting away with rather than something you are entitled to do; in particular it is a source of future portability headaches.</p>
",0
19877159,19877127,2,"<p>This line</p>

<pre><code>obs.avgX = (arr[0].x + arr[1].x + arr[2].x + arr[3].x + arr[4].x) / 5;
</code></pre>

<p>is doing integer arithmetic</p>

<p>You need to force it to use floating point numbers</p>

<p>i.e.</p>

<pre><code>obs.avgX = (float)(arr[0].x + arr[1].x + arr[2].x + arr[3].x + arr[4].x) / 5.0f;
</code></pre>
",10
19877175,19877127,0,"<pre><code> obs.avgX = (arr[0].x + arr[1].x + arr[2].x + arr[3].x + arr[4].x) / 5; should be 

 obs.avgX = (float) (arr[0].x + arr[1].x + arr[2].x + arr[3].x + arr[4].x) / 5
</code></pre>
",2
20022655,20022479,1,"<p>Like all things in computer science, you're given a (relatively) large problem to solve, and the solution requires you to break it into smaller problems until each is solvable... then you do that. Here, you've got two problems (assign upper case at the beginning of each word, and count words) but they're closely related, reducing your work.</p>

<p>Your primary problem is to identify where a word starts (and, naturally, ends); once you can do that, your problems are mostly trivial.</p>

<p>You can probably (within the boundary of your problem) assume that the <code>prose</code> string starts with a word, so you've now only got to identify where words end/resume.</p>

<p>If you <code>#include &lt;ctype.h&gt;</code> you have some help: <code>isalpha(c)</code> indicates if a character (technically an int, but realistically a character) is alphabetic. There are many other character classification functions in there but <code>isalpha()</code> <em>may</em> be all you need.</p>

<p>I assume you know how to iterate through your <code>prose</code> string, but in case you dont:</p>

<pre><code>char *p = prose;
while (*p != '\0') {
    ...
    ++p;
}
</code></pre>

<p>that's one (of many) ways; as you go through that loop, <code>p</code> will point to the next character. I.e., <code>*p</code> will be the next character.</p>

<p>Now, going through the string, you can use <code>isalpha(*p)</code> to detect if you're looking at an alhpabetic character or not. Combined with whatever you looked at the previous time through the loop, you can decide if you're at a word break... of this <code>isalpha()</code> and the previous one are the same, you've either just started a new word or just ended a word. If you're just starting a word, you can increase your word count and also capitalize this word (by changing the character, such as with <code>*p = toupper(*p);</code> (the <code>toupper()</code> function is also declared in <code>&lt;ctype.h&gt;</code>)</p>
",0
20023594,20022479,-1,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

void Cap(char *string);
int count(char *string);

int main(void){
    char prose[ ] =
        ""Ping! King Alfred opened the oven door\n""
        ""To reveal nine perfect cakes.\n""
        ""Oh, what a difference to history\n""
        ""A kitchen timer makes."";

    printf(""before:\n%s\n"", prose);
    Cap(&amp;prose[0]);
    printf(""after:\n%s\n"", prose);
    printf(""count of word : %d\n"", count(&amp;prose[0]));

    return 0;
}

char *NextWordTop(char *string){
    static char *p = NULL;
    char *ret;

    if(string)
        p = string;
    else if(!p)
        return NULL;

    while(isspace(*p))++p;
    if(*p){
        ret = p;
        while(!isspace(*p))++p;
    } else
        ret = p = NULL;

    return ret;
}

void Cap(char *str){
    char *p;
    for(p=NextWordTop(str); p ; p=NextWordTop(NULL))
        *p = toupper(*p);
}

int count(char *str){
    int c = 0;
    char *p;
    for(p=NextWordTop(str); p ; p=NextWordTop(NULL))
        ++c;
    return c;
}
</code></pre>
",0
20631614,20631560,5,"<p>Why would you do this? What's the point?</p>

<p>If you can assume the machine uses <a href=""http://en.wikipedia.org/wiki/Two%27s_complement"" rel=""nofollow noreferrer"">two's complement</a> then you can of course apply it manually. The algorithm is ... pretty simple:</p>

<ul>
<li>Invert all bits</li>
<li>Add one</li>
</ul>

<p>So:</p>

<pre><code>int negate(int x)
{
  return ~x + 1;
}
</code></pre>

<p>Of course, if you want to be really obscure you can do the bit-inversion with XOR, and hardcode for a particular integer size:</p>

<pre><code>int negate2(int x)
{
  return (x ^ 0xffffffff) + 1;
}
</code></pre>

<p>I guess using tilde to calculate a portable XOR constant is okay too, but silly:</p>

<pre><code>int negate3(int x)
{
  return (x ^ ~0) + 1;
}
</code></pre>
",8
15869990,15869931,9,"<p>C has a variety of integer types: <code>char</code> (at least 8 bits), <code>short</code> (at least 16 bits), <code>int</code> (at least 16 bits), <code>long</code> (at least 32 bits). There are <code>unsigned</code> varieties of those. If you assign a value that is too large to a plain type, the results are undefined (you should never do that, the compiler may assume you never do, and not check at all). In the <code>unsigned</code> case, they ""wrap around"". But note that the sizes are <strong>not guaranteed</strong>, just their minimal sizes. There have been machines in which all were 32 bits wide.</p>
",2
15870074,15869931,10,"<p>On the platform used in the question, the type <code>char</code> seems to be 1 byte (8 bits) size and is a signed type with 1 sign bit and 7 value bits (and using 2's complement arithmetic).  It stores values from -128 to 127. So, this is what's happening to <code>x</code> and <code>y</code>:</p>

<pre><code>x = 200 =&gt; x takes value -56
y = 100 =&gt; y takes value 100
x = x+y =&gt; x takes value 44
y = x-y =&gt; y takes value -56
x = x-y =&gt; x takes value 100
</code></pre>
",3
10826155,10826142,2,"<p>Your code does not allocate any memory (except that of the <code>FILE</code> struct) so you do not have any leak that depends on the file size.</p>

<p>However, you <em>do</em> leak some memory because you forgot to <code>fclose(fp);</code> after being done accessing the file.</p>

<p>As a suggestion, in case you are on linux, use <code>valgrind --leak-check=full ./yourapp</code> - assuming that your program is compiled with debugging symbols (the <code>-g</code> switch in gcc) you will get a detailed leak report showing exactly if/where your program leaks memory.</p>
",2
10826226,10826142,2,"<p>This is perfectly normal. Making memory free takes effort. This effort is totally wasted because as soon as the memory is needed, the system just has to remove it from the free pool. It's much more efficient to directly transition the memory from one use to another. So the system is being smart rather than stupid.</p>

<p>It's not like if you use half as much memory today you can use twice as much tomorrow. So there is no benefit to making memory free.</p>

<p>When you go to read lines from the file, the operating system reads in entire blocks from the file. It tries to keep those blocks in memory, if possible, because that allows it to avoid having to read from the disk in the future. If it has no better use to put the memory to, it keeps those file blocks in memory. That both saves it the effort of having to make the memory free just to make the memory used again and it speeds up any future accesses to that same block of the file.</p>

<p>There is no benefit to making this memory free. It just takes effort on the part of the OS to make it free, effort on the part of the OS to make it used again in the future, and the OS loses the opportunity to avoid disk reads. So making the memory free would be complete stupidity.</p>
",7
10826329,10826142,1,"<p>its because your using </p>

<pre><code>    fgets(buffer, int size, file);
</code></pre>

<p>which will only stop reading if you hit EOF.  Theres 2 ways of fixing it, either use</p>

<pre><code>    while(fgets(buffer, size, file) != EOF){};
</code></pre>

<p>or</p>

<pre><code>    while(fread(buffer, sizeof(char), nmem, file) &lt; 1024){};
</code></pre>

<p>I recommend using the latter, for some reason I tend to run into issues using fgets, and you have more control of what your doing with fread.</p>
",8
9818855,9818807,-1,"<pre><code>for (unsigned char *p = YOUR_STRING, *q = p; ((*q = *p));) {
        if (*q++ == ' ') {
                while (*++p == ' ');
        } else {
                p++;
        }
}
</code></pre>

<p>Less obscure alternative:</p>

<pre><code>unsigned char *p = YOUR_STRING;
unsigned char *q;
/* zap to the first occurrence */
while (*p &amp;&amp; *p++ != ' ');
/* copy from here */
q = --p;
while ((*q = *p)) {
        if (*q++ == ' ') {
                while (*++p == ' ');
        } else {
                p++;
        }
}
</code></pre>
",14
9818923,9818807,0,"<p>You can use <a href=""http://pubs.opengroup.org/onlinepubs/007904975/functions/strchr.html"" rel=""nofollow"">strchr</a> function to search for a space in a string and then follow it up with a logic to replace all the spaces following it. You need to repeat this for another patch of spaces till the string ends.</p>
",0
9819040,9818807,2,"<p>If it is the case that there is a single occurrence of two consecutive spaces in the string then a possibility would be to use <code>strstr()</code> and <code>memmove()</code>:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main()
{
    char s[] = ""a string with two  spaces"";
    char* two_spaces_ptr = strstr(s, ""  "");
    printf(""[%s]\n"", s);
    if (two_spaces_ptr)
    {
        memmove(two_spaces_ptr + 1,
                two_spaces_ptr + 2,
                strlen(two_spaces_ptr + 2) + 1); /* +1 to copy the NULL. */

    }
    printf(""[%s]\n"", s);

    return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>[a string with two  spaces]
[a string with two spaces]
</code></pre>

<p>The C standard for <code>memmove()</code> states:</p>

<blockquote>
  <p>The memmove function copies n characters from the object pointed to by s2 into the
  object pointed to by s1. Copying takes place as if the n characters from the object
  pointed to by s2 are first copied into a temporary array of n characters that does not
  overlap the objects pointed to by s1 and s2, and then the n characters from the
  temporary array are copied into the object pointed to by s1.</p>
</blockquote>

<p>EDIT:</p>

<p>Updated answer to use <code>memmove()</code>, instead of <code>strcpy()</code> that resulted in undefined behaviour.</p>
",7
9819049,9818807,0,"<p>You can write over your own string:</p>

<pre><code>char *ys = YOUR_STRING;
char *n = ys;
while (*ys)
{
  *n = *ys;
  if (*ys == ' ')
    while (*ys == ' ')
      ys++;
  else
    ys++;
  n++;
}
</code></pre>

<p>Or you can create a new string:</p>

<pre><code>char *ys = YOUR_STRING;
char *n = malloc(sizeof(*n) * strlen(ys));
int i = 0;

while (*ys)
{
  n[i++] = *ys;
  if (*ys == ' ')
    while (*ys == ' ')
      ys++;
  else
    ys++;
}
// use n
</code></pre>
",1
9819076,9818807,-1,"<p>If you're sure there can be only two spaces consecutive at max, you can do something like:
</p>

<pre><code>int main ()
{
    char *str=""This  is a  wonderful world. Let's  have a   good  time here."";
    int len=strlen(str);
    char *result = (char*)malloc(len);
    int j=0;
    for(int i=0;i&lt;len;i++) {
        if(str[i]==' ' &amp;&amp; str[i-1]==' ') {
            i++;
        }
        result[j++]=str[i];
    }
    result[j]='\0';
    printf(""%s\n"", result);
  return 0;
}
</code></pre>
",4
19377946,19377533,2,"<p>The problem here is that p is defined in <code>main()</code> to be</p>

<pre><code>struct node *p;
</code></pre>

<p>Now when you pass it to <code>addatbeg()</code>, you want the address that is stored at p to be changed because it will point to another node that has been added at the beginning of the list. However, when you use a definition like </p>

<pre><code>addatbeg(struct node *,int num)
</code></pre>

<p>p is actually passed by value. In order to modify the <code>p</code> in main, you need to pass its address</p>

<pre><code>addatbeg(struct node **,int num)
</code></pre>

<p>In <code>addafter</code>, you don't pass the address of <code>p</code> because you don't want your head pointer to change.</p>

<p>You can compare the situation to a simpler case. When you pass an integer by value you use <code>foo(int)</code>, however when you want to modify the original integer you pass its address like <code>foo(int *)</code>. The same thing is going on here with an extra level of dereferencing.</p>
",0
19377955,19377533,1,"<p>you need  <code>**</code> as need the value contained by head pointer, which would contain the address to first node of the linked list. You are passing  the address of a address so you need a double pointer</p>
",0
18731691,18731645,2,"<p>To @Cornstalks' point: <code>INT_MIN</code> is <code>0x80000000</code>, and <code>(int)-1</code> is <code>0xFFFFFFFF</code> in 2's complement (on a 32-bit system, anyway).</p>

<p>This allows the instruction set to do things in signed arithmetic like:</p>

<pre><code>1 + -2 = -1
</code></pre>

<p>becomes (as signed <code>short</code>s, for brevity)</p>

<pre><code>0x0001 + 0xFFFE = 0xFFFF
</code></pre>

<p>... then:</p>

<pre><code>1 + -1 = 0
</code></pre>

<p>is represented internally with overflow as </p>

<pre><code>0x0001 + 0xFFFF = 0x0000
</code></pre>

<p>Also to @Cornstalks' point: the internal representation (as well as overflow addition) is an implementation detail. C implementations (and instruction sets) need not represent integers in 2's complement, so providing hex values for signed integer types may tie you to a subset of C implementations.</p>
",1
18731953,18731645,1,"<p><code>fun3</code> will attempt to print the value 0x94949494.  This is greater than the max 4-byte integer value of 0x7FFFFFFF, so it will ""overflow"" and (on virtually every computer made today) produce (if I did my arithmetic correctly) the negative number -0x6B6B6B6C, which is -1802201964.</p>

<p><code>fun1</code> and <code>fun2</code> should print the ""expected"" positive results.</p>
",0
18731802,18731645,2,"<p><strong>EDIT (Corrections)</strong> (I missed the point. My answer is right for constants, but the question contains parameters of functions, then what happens here is overflow of signed integer objects and, as correctly pointed out @Cornstalks in his comment, this is undefined behaviour). 
<strong>/EDIT</strong></p>

<p>In <code>fun1()</code> you are using <code>printf()</code> in a wrong way.<br>
You wrote <code>""%d""</code> to accept an <code>int</code>, but this is not true if your number is greater that <code>MAX_INT</code>.  </p>

<p>You have to check the value of <code>MAX_INT</code> in your system.<br>
If you write an integer constant <strong>in hexadecimal format</strong>, the standard C (ISO C99 or C11) tries to put the value in the first type that the constant can fit, by following this order:  </p>

<blockquote>
  <p>int, unsigned int, long int, unsigned long int, long long int,
  unsigned long long int.</p>
</blockquote>

<p>Thus, if you have a constant greater that <code>MAX_INT</code> (the max. value in the range of <code>int</code>), your constant (if positive) has type <code>unsigned int</code>, but the directive <code>%d</code> expected a <code>signed int</code> value. Thus, it will be shown some negative number.  </p>

<p>Worst, if your constant is a value greater than <code>UMAX_INT</code> (the max. value in the range of <code>unsigned int</code>) then the type of the constant will be the first of <code>long int, unsigned long int, long long int</code>, with precision strictly bigger than of <code>unsigned int</code>.<br>
This implies that <code>%d</code> becomes a wrong directive.  </p>

<p>If you cannot be completely sure about how big will be your values, you could do a cast to the biggest integer type:  </p>

<pre><code>  printf(""%lld"", (long long int) 0x33333333333);
</code></pre>

<p>The directive <code>%lld</code> stands for <code>long long int</code>.<br>
If you are interested always in positive values, you have to use <code>%llu</code> and cast to <code>unsigned long long int</code>:  </p>

<pre><code>  printf(""%llu"", (unsigned long long int) 0x33333333333);
</code></pre>

<p>In this way, you avoids any ""funny"" numbers, as much as, you show big numbers without loosing any precision.  </p>

<p><strong>Remark:</strong> The constants <code>INT_MAX</code>, <code>UINT_MAX</code>, and the like, are in <a href=""http://www.cplusplus.com/reference/climits/"" rel=""nofollow"">limits.h</a>.  </p>

<p><strong>Important:</strong> The automatic sequence of casts is only valid for octal and hexadecimal constants. For decimal constants there is another rule:  </p>

<blockquote>
  <p>int, long int, long long int.  </p>
</blockquote>
",1
18604060,18604035,1,"<p>It's always platform and implementation dependent. Sometimes some types are the same size on one implementation and not on another. 
Welcome to step one in developing carefully. </p>
",0
18604078,18604035,0,"<p>Signed and unsigned ints are the same size. The upper bit is the sign bit. </p>

<p>int is signed by default.</p>

<p>shorts are typically 2 bytes, int's are typically 4. longs are usually 4 or 8.
All of these are platform dependent and you should use sizeof() to discover them.</p>
",0
18604084,18604035,0,"<p>Most systems today, including those Intel ones, use <a href=""http://en.wikipedia.org/wiki/Two%27s_complement"" rel=""nofollow"">two's complement</a> for representing signed integers.
Therefore usually you get <code>sizeof(unsigned int) == sizeof(signed int)</code>.</p>

<p>The number of bits for a certain type is only loosely defined by the specification and therefore mostly compiler/platform dependent. Sometimes an int might be 16bit, other times 32bits. Read the documentation of your compiler for more information (e.g. <a href=""http://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Integer-Types"" rel=""nofollow"">gcc</a>), and keep that in mind when writing portable code.</p>
",0
18604181,18604035,1,"<p>Signed and unsigned values have the same size. In the signed form the most significant bit is the sign, while in the unsigned form the extra bit allow the type to hold greater values. For example a signed type of 32 bits can hold a value in -(2^31) to 2^31 - 1 and an unsigned type of 32 bits can hold a value of 0 to 2^32 - 1.</p>

<p>The size of each type is system dependent. If you need a variable to be of an expecific size, you can use the types from <a href=""http://pubs.opengroup.org/onlinepubs/009695399/basedefs/stdint.h.html"" rel=""nofollow"">stdint.h</a>, so int32_t will always have 32 bits, for example.</p>
",0
14205215,14205200,4,"<blockquote>
  <p>Any ideas of how I can do that</p>
</blockquote>

<p>Ignore <code>SIGINT</code> using a SIG_IGN disposition or catch it in a do-nothing handler. In some implementations there's even a <code>sigignore</code> function.</p>

<p>Anyways, you should be fine with:</p>

<pre><code>signal(SIGINT, SIG_IGN);
</code></pre>

<p><code>SIG_IGN</code> is sppecified in C11-7.14 so it's as portable as it gets.</p>
",0
14205226,14205200,8,"<p>When you press Ctrl-C while a program is running, what happens underneath is that your process receives a signal called SIGINT, the default action when a process receives this signal is to terminate itself.<br>
So your goal should be to modify this behavior:<br>
Use the function <code>signal</code> to catch the signal sent to your process when ctrl-c </p>

<p>you should go with something like this:</p>

<pre><code>signal(SIGINT, handler_function);//handler_function is a void returning function that takes one int paramter, you can do nothing there if you just want to prevent your process from terminating.
</code></pre>

<p><br>
P.S Here's the <a href=""http://linux.die.net/man/2/signal"" rel=""noreferrer"">man page</a> for further information :D <br>
P.P.S If you're not familier with what a signal is, please refer to <a href=""http://en.wikipedia.org/wiki/Signal_%28computing%29"" rel=""noreferrer"">this wikipedia page</a> if you find something confusing there, let us know.</p>
",0
11152960,11152894,1,"<p>What you need is <a href=""http://pubs.opengroup.org/onlinepubs/009695399/basedefs/limits.h.html"" rel=""nofollow""><code>#include &lt;limits.h&gt;</code></a></p>
",0
11152965,11152894,3,"<p>Check <a href=""http://www.cplusplus.com/reference/clibrary/climits/"" rel=""nofollow"">this</a>. Generally when you have a question regarding C or C++ try to first look it up at this site, it's a great reference.</p>
",0
11152932,11152894,6,"<p><code>limits.h</code> defines a few values that represent the limits (or bounds) of types. In your case, <code>INT_MIN</code> and <code>INT_MAX</code> would be a portable way to find out the minimum and maximum values an <code>int</code> can hold.</p>

<p><a href=""http://en.wikibooks.org/wiki/C_Programming/C_Reference/limits.h"" rel=""noreferrer"">http://en.wikibooks.org/wiki/C_Programming/C_Reference/limits.h</a></p>
",1
11152933,11152894,4,"<p>The header <code>limits.h</code> has a constant <code>UINT_MAX</code>, which is the value you want.</p>

<p>The reason you saw <code>-1</code> is just that <code>%ld</code> is the wrong printf format for <code>unsigned long</code>. Use <code>%lu</code>.</p>

<p>C isn't really geared for generic programming, but the most recent standard C11 does provide macros that do different things according to the type of the argument (""type-generic expressions"").</p>

<p>I've never used them, but I expect you could write a macro <code>NUMERIC_LIMITS_MAX</code> to hide the mapping <code>int -&gt; INT_MAX</code>, <code>unsigned char -&gt; UCHAR_MAX</code>, etc. The resulting code would not (yet) be very portable, since there aren't many partial implementations of C11, let alone complete ones.</p>

<p>That said, for unsigned types you can always get the max value as <code>(unsigned long)(-1)</code> and so on. The signed types are a bit awkward, because the standard gives implementations freedom to do a lot of strange things. In practice, <code>INT_MAX</code> is equal to <code>(((unsigned int)(-1)) / 2) + 1</code>. In theory, <code>int</code> is allowed to have more padding bits than <code>unsigned int</code>, in which case <code>INT_MAX</code> is smaller.</p>
",3
11153426,11152894,0,"<p>Solution to get the max of int in running time:</p>

<pre><code>int main ( )
{
    unsigned int y = (unsigned int)(~0)&gt;&gt;1;
    printf (""max of int is %u\r\n"",y);
    return 1;
}
</code></pre>

<p><strong>explaination:</strong></p>

<p><code>y = ~0</code> set y with the opposite in binary of 0. If our system is 32 bits so 0 will be represent in binary with (0000...0)(32) and its opposite in binary is (1111...1)(32).</p>

<p><code>y&gt;&gt;1</code> shift the y with 1 bit so the value of y will be (0111..1)(31) which is the max of int</p>
",2
11153432,11152894,0,"<p>Just print -1</p>

<pre><code>#include ""stdint.h""

printf(""Byte :%u, Short :%hu,  Int :%u, Long Long :%llu\n"",
             (uint8_t)-1, (uint16_t)-1, (uint32_t)-1, (uint64_t)-1);
</code></pre>

<p>The Output is:</p>

<blockquote>
  <p>Byte :255, Short :65535,  Int :4294967295, Long Long
  :18446744073709551615</p>
</blockquote>

<p>I am on linux...</p>
",1
9176577,9176555,1,"<p>First up, this is wrong because of precedence.</p>

<blockquote>
<pre><code>while((c=getchar()!=EOF))
                       ^
</code></pre>
</blockquote>

<p>Instead of storing the character, you will continuously store the comparison between the character and <code>EOF</code>. So you will continuously store a long line of <code>1</code>.</p>

<p>Try this:</p>

<pre><code>while((c=getchar())!=EOF)
                  ^
</code></pre>

<p>Second <code>getc</code> and <code>getchar</code> return <code>int</code>. <a href=""http://c-faq.com/stdio/getcharc.html"" rel=""nofollow"">So <strong><code>ch</code> should be <code>int</code></strong>, not <code>char</code></a>. Using a <code>char</code> could mean the loop will never terminate on some systems. </p>
",2
9176638,9176555,0,"<p>The line:</p>

<pre><code>fopen(""input.txt"",""r"");
</code></pre>

<p>Is obviously wrong. Seems you want:</p>

<pre><code>fp = fopen(""input.txt"",""r"");
</code></pre>

<p>Instead.</p>
",2
12869733,12869720,9,"<p>That error message is telling you exactly what's happening - there is an implicit declaration of <code>regre</code> because you don't define it until after <code>main()</code>.  Just add a forward declaration:</p>

<pre><code>double regre();
</code></pre>

<p>Before <code>main()</code>, or just move the whole function up there.</p>
",2
12870472,12869720,2,"<pre><code>previous implicit declaration of `regre` was here
</code></pre>

<p>If a function is unknown, then compiler considers it as <code>int functionname()</code> by default. In your case <code>int regre()</code> will be declared here. </p>

<pre><code>conflicting types for 'regre' 
</code></pre>

<p>When your actual function <code>double regre()</code> is noticed, this conflict error occurs. To solve this issue, double regre() function should be declared before it's actual use.  </p>

<pre><code>#include&lt;stdio.h&gt;
double regre(); //Forward Declaration
int main(){
    double returning;
    returning = regre();
    printf(""%f"", returning);
    return 0;
}
double regre(){
    double re = 14.35;
    return re;
}
</code></pre>

<p>For more info on Forward Declaration, refer the following link.</p>

<p><a href=""http://en.wikipedia.org/wiki/Forward_declaration"" rel=""nofollow"">http://en.wikipedia.org/wiki/Forward_declaration</a></p>
",0
9785321,9784884,1,"<p>No, there is no way to do this automatically in C. The standard preprocessor is not competent enough to do the transformations. </p>

<p>There is also now way for a function to find out that it was called like <code>a-&gt;func(10)</code>. Inside the function it is just <code>func(10)</code>.</p>

<p>When Bjarne Stroustrup started designing C++, he wrote a special preprocessor/compiler <a href=""http://en.wikipedia.org/wiki/Cfront"" rel=""nofollow"">Cfront</a> for this.</p>

<p>In reality, C++ doesn't really store pointers to (non-virtual) functions. It just transforms <code>a-&gt;set(10)</code> to something like <code>struct_Obj_set(a, 10)</code> while compiling the code.</p>
",0
9785334,9784884,3,"<p>Just another way of writing:</p>

<pre><code>#define member(FUNC, ...) FUNC(this_, ## __VA_ARGS__)
int reader(struct Obj *_this) {
  member(read, a, b, c);
  member(getch);
  return 0;
}
</code></pre>

<p>This can be used for implementing interfaces, inheritance and many C++ features, which were implemented like this in C with Classes times. In Linux kernel, file operations are implemented like this. File structure stores pointers to functions, so that each file system can store it's own system call handlers that operate on/with the data in the structure. </p>
",0
10180815,10180771,0,"<p>You don't check if the <code>FILE</code> is NULL. It may not be opened for a several reasons.</p>
",0
10180838,10180771,0,"<p>The code looks fine, so my guess is that the program is not run in the same working directory as the file.  Try placing the file in, say, <code>/tmp/test.txt</code> and use absolute path in <code>fopen</code>.</p>
",0
10180968,10180771,1,"<p>try this after <code>fopen()</code> call:</p>

<pre><code>if(in == NULL){
    printf(""Can't read teste.txt because: %s.\n"", strerror(errno));
    return 1;
 }
</code></pre>

<p>and add the headers: </p>

<pre><code>#include &lt;errno.h&gt;
#include &lt;string.h&gt;
</code></pre>
",0
15843689,15843667,7,"<p><code>--</code> is a post-decrement operator as you are using it and only takes effect after <code>myFunc</code> is called with the value of <code>n</code>, so you will be calling <code>myFunc</code> with the same value over and over again.</p>

<p>Using it as a pre-decrement operator would fix your particular use case: <code>myFunc(--n)</code> would have a similar effect to putting <code>n=n-1</code> on the line before.</p>
",0
15843691,15843667,3,"<p>Because the decrement is performed <em>after</em> the call. Not before.</p>

<p>If you do <code>myFunc(--n);</code> instead, it will work</p>
",0
15843697,15843667,4,"<p>n-- calls the postfix operation, which means the value of n gets passed into myFunc. After that, n's value is decremented by one.
Call myFunc(--n).</p>
",0
15843698,15843667,3,"<p><code>n--</code> decrements <code>n</code> <em>after</em> <code>n</code> is passed to <code>myFunc()</code>, so <code>myFunc</code> is receiving the same <code>n</code> value every time it is called.</p>
",0
15844073,15843667,0,"<p>N-- is a <code>postfix</code> operator. This means that it will increment the variable you are using it on after the value is used. As an example, in the expression <code>x * y--</code>, the compiler will return <code>x * y</code>, and then decrement y.</p>
",0
15844078,15843667,1,"<p>n-- and --n are different.
You should look up C operators and sequence points for the explanation.
Basically, n-- means 'use n and decrement it at the next sequence point',
whereas --n means 'decrement n first and then use it'..</p>
",0
9148829,9148819,3,"<p>It actually prints out the <em>characters</em> <code>'1'</code>, <code>'2'</code>, <code>'4'</code> etc.</p>

<p>The numeric value of <code>c|mask</code> gets interpreted as an <a href=""http://www.asciitable.com/"" rel=""nofollow"">ASCII code</a>. The ASCII code of <code>'0'</code> is 48.</p>

<p>To make the code a little clearer, you could change</p>

<pre><code>char c=48;
</code></pre>

<p>to</p>

<pre><code>char c='0';
</code></pre>

<p>The two forms are equivalent.</p>
",2
9148832,9148819,7,"<p>If you use <code>%c</code>, c prints the corresponding ASCII key for the integer value.</p>

<p>Binary of 48 is 110000.
Binary of 1 is 000001.</p>

<p>You <code>or</code> them, <code>110000 | 000001</code> gives <code>110001</code> which is equivalent to <code>49 in decimal base 10</code>.</p>

<p>According to the <a href=""http://web.cs.mun.ca/~michael/c/ascii-table.html"" rel=""noreferrer"">ASCII table</a>, corresponding ascii values for 49, 50, 51, etc are '1', '2', '3', etc.</p>
",2
11150364,11150205,1,"<p>The trouble appears to be in the line:</p>

<pre><code>fscanf(fptr,""%d"",&amp;(cotp-&gt;TPDU_size)); 
</code></pre>

<p>Your TPCU_size is <code>unsigned char TPDU_size;</code> which is only 1 byte (assuming this to be the size of 'char') in size, but you are trying put 4 bytes (assuming that to be the size of 'int') into it during fscanf, thereby potentially overwriting the memory around it.</p>
",5
11150429,11150205,0,"<p>While there is some information missing, some of what you have shown is clearly wrong and is likely to be involved in the problem.  For instance:</p>

<pre><code>int Fill_TPKT(FILE *fptr,unsigned char *buf)
  {
   fseek(fptr,14,SEEK_SET);
   fscanf(fptr,""%d"",buf+0);

   fseek(fptr,15,SEEK_CUR); 
   fscanf(fptr,""%d"",buf+1);
</code></pre>

<p>If each call to <code>fscanf</code> works, each will fill in one <code>int</code>, but <code>buf</code> points to a sequence of <code>unsigned char</code>s.  Unless you have very large <code>char</code>s and <code>sizeof(int) == 1</code> this is obviously wrong.</p>

<p>The same mistake is repeated at many other points, e.g., in <code>Fill_COTP</code>, <code>fscanf</code> with a <code>%d</code> directive is used to fill in <code>temp</code>, which has type <code>unsigned short</code> rather than <code>int</code>.</p>

<p>You could change the directives (<code>%hhd</code> will fill in a single <code>char</code> and <code>%hd</code> will fill in a single <code>short</code>; <code>%hhu</code> and <code>%hu</code> will fill in <code>unsigned char</code> and <code>unsigned short</code>).  However, simply calling <code>fscanf</code> like this, without any error checking, is not very robust.  If the contents of the input stream are not convert-able to the target type, the call will fail (<code>fscanf</code> will return either EOF or a short count, depending on the kind of failure, ""input"" vs ""matching"", and the point of the failure).  You might want a little intermediate function that does appropriate error checking, perhaps scanning into an <code>int</code> after all and then range-checking the value for instance.</p>
",1
10133390,10133201,1,"<p>Start by writing a program which reads a line of text (make it easy by assuming the line is left than 1000 characters) and writes it back out. </p>

<p>Once you have that working, look for a text string (e.g ""foo"") within the line, and replace it with a similar number of easy to see characters (e.g. replace foo with XXX).</p>

<p>Then take it from their.</p>
",0
10140361,10133201,1,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

long GetFileSize(FILE *fp){
    long fsize = 0;

    fseek(fp,0,SEEK_END);
    fsize = ftell(fp); 
    fseek(fp,0,SEEK_SET);//reset stream position!!

    return fsize;
}

int main(int argc, char **argv){
    char *file, *sword, *rword, *buff, *wp,*bp;
    int len;
    long fsize;
    FILE *inpFile;

    if(argc != 4){
        fprintf(stderr, ""Usage:rep filePath originalWord replaceWord\n"");
        exit(EXIT_FAILURE);
    }
    file  = argv[1];
    sword = argv[2];
    rword = argv[3];
    if(NULL==(inpFile=fopen(file, ""rb""))){
        perror(""Can't open file"");
        exit(EXIT_FAILURE);
    }
    fsize = GetFileSize(inpFile);
    buff=(char*)malloc(sizeof(char)*fsize+1);
    fread(buff, sizeof(char), fsize, inpFile);//file all read into buff
    fclose(inpFile);
    buff[fsize]='\0';
    bp=buff;
    len = strlen(sword);
    while(NULL!=(wp=strstr(bp, sword))){
        while(bp != wp)
            putchar(*bp++);
        printf(""%s"",rword);
        bp+=len;
    }
    if(bp) printf(""%s"", bp);
    free(buff);
    return 0;
}
</code></pre>
",1
18652916,18604114,0,"<p>This piece of the code works well. Post if there is still any problem.</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
char* get_request_type(char *buffer) {
        char *p; 
        printf(""----%s\n"",buffer);
        p = strtok(buffer, ""|"");
        //fprintf(""%s---&gt;"",p);  
        return p;
}

int main()
{
        char buffer[30] = ""test|something"";
        fprintf(stdout, ""buffer: %s\n"", buffer);  //&lt;-- looks great but needs parsing
        char* request_type = get_request_type(buffer);  //&lt;-- No error here
        fprintf(stdout, ""request_type: %s\n"", request_type);
        return 0;
}
</code></pre>
",0
18653157,18604114,2,"<p>You didn't include <code>string.h</code>, so the compiler will assume that <code>strtok</code> is defined as:</p>

<pre><code>int strtok();
</code></pre>

<p>returns <code>int</code> and takes unknown number of arguments, it's call <em>implicit function declaration</em>. The solution is just to include <code>string.h</code> where <code>strtok</code> is declared.</p>
",0
8779787,8617889,20,"<p>The C language has a basic flaw: it is impossible to return arrays from functions.
There are many workarounds for this; i'll describe three.</p>

<h2>Replace by a pointer to an array</h2>

<p>Return a pointer instead of an array itself. This leads to another problem in C: when a function returns a pointer to something, it should usually allocate the something dynamically. You should not forget to deallocate this later (when the array is not needed anymore).</p>

<pre><code>typedef int (*pointer_to_array)[6][6];

pointer_to_array workaround1()
{
    pointer_to_array result = malloc(sizeof(*result));
    (*result)[0][0] = 0;
    (*result)[1][0] = 0;
    (*result)[2][0] = 0;
    (*result)[3][0] = 0;
    (*result)[4][0] = 0;
    (*result)[5][0] = 0;
    return result;
}
</code></pre>

<h2>Replace by a pointer to int</h2>

<p>A 2-D array appears just as a sequence of numbers in memory, so you can replace it by a pointer to first element. You clearly stated that you want to return an array, but your example code returns a pointer to int, so maybe you can change the rest of your code accordingly.</p>

<pre><code>int *workaround2()
{
    int temp[6][6] = {{0}}; // initializes a temporary array to zeros
    int *result = malloc(sizeof(int) * 6 * 6); // allocates a one-dimensional array
    memcpy(result, temp, sizeof(int) * 6 * 6); // copies stuff
    return result; // cannot return an array but can return a pointer!
}
</code></pre>

<h2>Wrap with a structure</h2>

<p>It sounds silly, but functions can return structures even though they cannot return arrays! Even if the returned structure contains an array.</p>

<pre><code>struct array_inside
{
    int array[6][6];
};

struct array_inside workaround3()
{
    struct array_inside result = {{{0}}};
    return result;
}
</code></pre>
",2
16377920,16377810,2,"<p><code>fread</code> tries to fill an internal buffer.  Depending on the implementation, you may be able to stop or limit it by setting the buffering mode (in particular, setting <code>_IONBF</code>, see <code>setbuf</code>, should work for all implementations).  The general rule, though, is to avoid mixing counted I/O on sockets with stdio at all¡ªto use raw <code>read</code> calls.</p>

<p>Also, while it's not biting you here, a <code>!feof(stream)</code> test is almost always wrong: people mean this to be predictive (EOF is about to occur), but <code>feof</code> is only ""post-dictive"": after a read operation fails (<code>getc</code> or <code>fgetc</code> returns <code>EOF</code>), the <code>feof</code> and <code>ferror</code> indicators allow you to discover why the previous failure occurred.</p>
",0
10167726,10167714,28,"<p>You need to link with the math library.  With gcc, this would mean passing <code>-lm</code> during linking.</p>

<p>The reason it doesn't complain when you use <code>2</code> as the exponent value is because the compiler is optimizing the <code>pow</code> call out.</p>
",4
10167906,10167749,4,"<p>Not currently - since you can't change the compiler options. From the <a href=""http://codepad.org/about"" rel=""nofollow"">about page</a>, these are the compiler options currently in use for C:</p>

<blockquote>
  <p>-O -fmessage-length=0 -fno-merge-constants -fstrict-aliasing -fstack-protector-all</p>
</blockquote>

<p>However, you could always ask them to include <code>-lm</code>:</p>

<blockquote>
  <p>codepad was written (and still is being written!) by Steven Hazel. Please contact me at sah@codepad.org if you have any problems or feature requests. </p>
</blockquote>

<p>Also, as a commenter points out, It looks like the compiler at <a href=""http://ideone.com/"" rel=""nofollow"">ideone.com</a> links with the math library.</p>
",0
11104575,11102424,7,"<p>You should go over each digit, starting with the least significant one, double it and add the carry from the previous one, store the result modulo 10 as the new digit value and if the result is more than 9, set the carry to 1 otherwise set it to 0 (or just perform integer division of the result by 10): </p>

<pre><code>carry = 0
for i = 0 to MAX_DIGITS-1:
   tmp = 2 * digits[i] + carry
   digits[i] = tmp % 10
   carry = tmp / 10
</code></pre>

<p>(this is pseudocode - translate it to C for your own use)</p>

<hr>

<p>Just as a side note, computing <code>2^1000</code> is extremly easy in binary - it is just <code>1</code> followed by 1000 <code>0</code>. Converting the result to decimal representation is a bit tricky but an efficient binary to BCD conversion methods exist. But I would still recommend that you use the GNU MP library instead. It only takes 6 lines to compute 2^1000 using GNU MP (the <code>#define</code> line and all whitespace lines are not counted):</p>

<pre><code>#include &lt;gmp.h&gt;

#define MAX_DIGITS 302

mpz_t bignum;
char str[MAX_DIGITS+2];

mpz_init2(bignum, 1001);
mpz_ui_pow_ui(bignum, 2, 1000);  // set the integer object to 2^1000
mpz_get_str(str, 10, bignum);    // convert to base 10
</code></pre>

<p>Note that <code>2^1000</code> is 1001 binary digits and about 302 (equal to 1001*log(2)) decimal digits. Add two characters for a possible sign character and a <code>NULL</code> terminator character as requried by <code>mpz_get_str()</code>.</p>

<p>Now you only have to go over the resulting digits in <code>str</code>, convert them to integers and sum them all up.</p>
",0
11110687,11102424,1,"<pre><code>#include &lt;stdio.h&gt;

void mul2(int *n){
    int c = 0, v;
    while(*n&gt;=0){
        v  = c + *n * 2;
        c  = v / 10;
        *n++ = v % 10;
    }
    if(c) *n++ = c;//1
    *n = -1;//stopper
}

int sum(int *n){
    int sum=0;
    while(*n&gt;=0)
        sum += *n++;
    return sum;
}

int main(void){
    int arr[1000] = {1, -1};//need 302 + 1, -1 is stoper
    int i;
    for(i=0;i&lt;1000;i++)
        mul2(arr);
    printf(""%d\n"", sum(arr));
    return 0;
}
</code></pre>
",0
11114312,11102424,0,"<pre><code>    //Finally I did it.


    #include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
//2 ^ 1000
int main()
{
   int array[1000] = { 0 };
   array[0] = 1;
   int i, j, cnt, div, carry, temp, sum;
   for(i = 0, cnt = 1; i &lt; 1000; i++)
   {
       div = carry = 0;
       for(j = 0; j &lt; 1000; j++)
       {
           if(carry != 0)
           {
               array[j] = (array[j] * 2) + carry;
               div = array[j] % 10;
               temp = array[j] / 10;
               array[j] = div ;//+ carry;
               carry = temp;
               //array[j] = (array[j] * 2) + 1;
               //carry = 0;
           }
           else
           {
               array[j] = array[j] * 2;
               if (array[j] &gt; 9)
               {
                   div = array[j] % 10;
                   carry = array[j] / 10;
                   array[j] = div;
               }
           }

       }

   }
   sum = temp = 0;
   printf(""The value of 2 ^ 1000 is : "");
for(i = 999; i &gt;= 0; i--)
{
    if(array[i] || (temp))
    {
        temp++;
        sum = sum + array[i];
        printf(""%d"", array[i]);
    }

}
   printf(""\nThe sum is : %d \n"", sum);
   printf(""\nThe number of digits are : %d \n"", temp);
    return 0;
}
</code></pre>
",0
11155295,11154957,2,"<p>In C (unlike C++), the initializer for any object with <em>static storage duration</em> - including function statics - must be constant expressions. In your example <code>a</code> is not a constant expression so the initialization is not valid.</p>

<p>C99 6.7.8 / 4:</p>

<blockquote>
  <p>All the expressions in an initializer for an object that has static storage duration shall be constant expressions or string literals.</p>
</blockquote>
",0
11155314,11154957,3,"<p>Apart from the other reasons stated in other answers here, please see the below statement in the Standard.</p>

<p>The <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf"" rel=""nofollow"">C Standard</a> says this in Point-4 (Section 6.7.8 Initialization):</p>

<pre><code>All the expressions in an initializer for an object that has static storage duration
shall be constant expressions or string literals.
</code></pre>

<p>Additionally, as to what is a constant expression, it says in Section 6.6 Constant Expressions as below:</p>

<pre><code>A constant expression can be evaluated during translation rather than runtime, and
accordingly may be used in any place that a constant may be.
</code></pre>
",0
11155442,11154957,0,"<p>Following from Als's answer ...</p>

<pre><code>// This is really crappy code but demonstrates the problem another way ....
#include &lt;stdio.h&gt;
int main(int argc, char *argv[])
{
static int b = argc ; // how can the compiler know 
                      // what to assign at compile time?

return 0;
}
</code></pre>
",0
11155260,11154957,1,"<p>Static variable is always global in the sense it is not on any thread's stack, and it is not important if its declaration is inside a function or not.</p>

<p>So the initialization of the global variable <code>b</code> is performed during program start-up, before any function (including <code>main</code>) gets called, i.e. no <code>a</code> exists at that time, because <code>a</code> is local variable which gets its memory place on stack after the function (here <code>main</code>) is called.</p>

<p>Hence you really cannot expect the compiler to accept it.</p>
",2
10184147,10184128,3,"<p><code>*temp</code> doesn't get the value of <code>heaparray[index1]</code>, it gets its address.</p>
",3
10184348,10184128,5,"<p>You need to copy the actual value of <code>h-&gt;heaparray[index1]</code> (not its address) into <code>temp</code> and then later copy that value into <code>h-&gt;heaparray[index2]</code>, like so:</p>

<pre><code>void swap(pQueue *h, int index1, int index2) {
  student temp = h-&gt;heaparray[index1];
  h-&gt;heaparray[index1] = h-&gt;heaparray[index2];
  h-&gt;heaparray[index2] = temp;    
}
</code></pre>
",0
19262976,19262851,4,"<p>What's happening here is that the right-hand-side of the argument is <em>first</em> extended from 16 to 32 bits, and the conversion to the left-hand-side type only happens at assignment. This means that if the right-hand-side is signed, then it will be sign-extended when it's converted to 32 bits, and likewise if it's unsigned then it will just be zero-padded.</p>

<p>If you're careful with your casts then there shouldn't be any problem¡ªbut unless you're doing something super performance-intensive then the extra couple of bitwise operations shouldn't hurt anything.</p>

<p>On another note, if you're doing anything where you're assuming certain bit-widths for different integer types, you should really be explicit and use the types defined in <a href=""http://en.wikipedia.org/wiki/Stdint.h#stdint.h"" rel=""nofollow"">stdint.h</a>. I just recently got bit by this while porting (someone else's) code from *nix to Windows, as the Visual C++ compiler uses a different convention for integer sizes (LLP64) than that on any other x64 or power-7 compiler I've used (LP64). In short, if you want 32 bits, you're better off saying it explicitly with a type like <code>uint32_t</code>.</p>

<hr>

<blockquote>
  <p>So this will always hold when such conversion happens in C? defined by C standard? ¨C  Jun</p>
</blockquote>

<p>Yes, it should always hold. Relevant quotes (with links) from the C99 standard: <a href=""http://port70.net/~nsz/c/c99/n1256.html#6.3.1.1"" rel=""nofollow"">""The integer promotions preserve value including sign.""</a> When handling usual arithmetic type conversions: <a href=""http://port70.net/~nsz/c/c99/n1256.html#6.3.1.8"" rel=""nofollow"">""... the integer promotions are performed on both operands. Then the following rules are applied to the promoted operands...""</a></p>
",2
19263180,19262851,0,"<p>This is an unsigned short representation of the number 65535:</p>

<pre><code>unsigned short a = 0xFFFF;
</code></pre>

<p>This is a signed short representation of the number -1:</p>

<pre><code>signed short b = 0xFFFF;
</code></pre>

<p>Simple promotion from unsigned short to unsigned int, so u16tou32 is a unsigned int representation of the number 65535:</p>

<pre><code>unsigned int u16tou32 = a;
</code></pre>

<p>b (value of -1) is promoted to int.  Thus its hex representation would be 0xFFFFFFFF.  It is then cast to unsigned, so is a representation of the number 4294967295:</p>

<pre><code>unsigned int s16tou32 = b;
</code></pre>

<p>Promotion from unsigned short to unsigned int has value 65535.  It is then case to signed int, which will also be a representation of the number 65535:</p>

<pre><code>signed int u16tos32 = a;
</code></pre>

<p>Simple promotion of signed short to signed int, so s16tos32 is also a representation of the number -1:</p>

<pre><code>signed int s16tos32 = b;
</code></pre>
",0
19263405,19262851,4,"<p>As stated in the question, assume 16-bit <code>short</code> and 32-bit <code>int</code>.</p>

<pre><code>unsigned short a = 0xFFFF;
</code></pre>

<p>This initializes <code>a</code> to <code>0xFFFF</code>, or <code>65535</code>.  The expression <code>0xFFFF</code> is of type <code>int</code>; it's implicitly converted to <code>unsigned short</code>, and the value is preserved.</p>

<pre><code>signed short b = 0xFFFF;
</code></pre>

<p>This is a little more complicated. Again, <code>0xFFFF</code> is of type <code>int</code>. It's implicitly converted to <code>signed short</code> -- but since the value is outside the range of <code>signed short</code> the conversion cannot preserve the value.</p>

<p>Conversion of an integer to a signed integer type, when the value can't be represented, yields an implementation-defined value. In principle, the value of <code>b</code> could be anything between <code>-32768</code> and <code>+32767</code> inclusive. In practice, it will almost certainly be <code>-1</code>. I'll assume for the rest of this that the value is <code>-1</code>.</p>

<pre><code>unsigned int u16tou32 = a;
</code></pre>

<p>The value of <code>a</code> is <code>0xFFFF</code>, which is converted from <code>unsigned short</code> to <code>unsigned int</code>. The conversion preserves the value.</p>

<pre><code>unsigned int s16tou32 = b;
</code></pre>

<p>The value of <code>b</code> is <code>-1</code>. It's converted to <code>unsigned int</code>, which clearly cannot store a value of <code>-1</code>. Conversion of an integer to an unsigned integer type (unlike conversion to a signed type) is defined by the language; the result is reduced modulo <code>MAX + 1</code>, where <code>MAX</code> is the maximum value of the unsigned type. In this case, the value stored in <code>s16tou32</code> is <code>UINT_MAX - 1</code>, or <code>0xFFFFFFFF</code>.</p>

<pre><code>signed int u16tos32 = a;
</code></pre>

<p>The value of <code>a</code>, <code>0xFFFF</code>, is converted to <code>signed int</code>. The value is preserved.</p>

<pre><code>signed int s16tos32 = b;
</code></pre>

<p>The value of <code>b</code>, <code>-1</code>, is converted to <code>signed int</code>. The value is preserved.</p>

<p>So the stored values are:</p>

<pre><code>a == 0xFFFF (65535)
b == -1     (not guaranteed, but very likely)
u16tou32 == 0xFFFF (65535)
s16tou32 == 0xFFFFFFFF (4294967295)
u16tos32 == 0xFFFF (65535)
s16tos32 == -1
</code></pre>

<p>To summarize the integer conversion rules:</p>

<p>If the target type can represent the value, the value is preserved.</p>

<p>Otherwise, if the target type is unsigned, the value is reduced modulo <code>MAX+1</code>, which is equivalent to discarding all but the low-order N bits. Another way to describe this is that the value <code>MAX+1</code> is repeatedly added to or subtracted from the value until you get a result that's in the range (this is actually how the C standard describes it). Compilers don't actually generate code to do this repeated addition or subtraction; they just have to get the right result.</p>

<p>Otherwise, the target type is signed and cannot represent the value; the conversion yields an implementation-defined value. In almost all implementations, the result discards all but the low-order N bits using a two's-complement representation. (C99 added a rule for this case, permitting an implementation-defined signal to be raised instead. I don't know of any compiler that does this.)</p>
",1
19263119,19262851,7,"<p>Anytime an integer type is being converted to a different integer type it falls through a deterministic pachinko machine of rules as dictated by the standard and on one occasion, the implementation.</p>
<p>The general overview on value-qualification:</p>
<p><strong>C99 6.3.1.1-p2</strong></p>
<blockquote>
<p>If an int can represent all values of the original type (as restricted by the width, for a bit-field), the value is converted to an int; otherwise, it is converted to an <strong>unsigned int</strong>. These are called the integer promotions. All other types are unchanged by the integer promotions.</p>
</blockquote>
<p>That said, lets look at your conversions. The <code>signed-short</code> to <code>unsigned int</code> is covered by the following, since the <em>value</em> being converted falls outside the <code>unsigned int</code> domain:</p>
<p><strong>C99 6.3.1.3-p2</strong></p>
<blockquote>
<p>Otherwise, if the new type is unsigned, the value is converted by repeatedly adding or subtracting one more than the maximum value that can be represented in the new type until the value is in the range of the new type.</p>
</blockquote>
<p>Which basically means &quot;add UINT_MAX+1&quot;. On your machine, UINT_MAX is 4294967295, therefore, this becomes</p>
<pre><code>-1 + 4294967295 + 1 = 4294967295
</code></pre>
<p>Regarding your <code>unsigned short</code> to <code>signed int</code> conversion, that is covered by the regular value-quaified promotion. Specifically:</p>
<p><strong>C99 6.3.1.3-p1</strong></p>
<blockquote>
<p>When a value with integer type is converted to another integer type other than _Bool, if the value can be represented by the new type, it is unchanged.</p>
</blockquote>
<p>In other words, because the value of your <code>unsigned short</code> falls within the coverable domain of <code>signed int</code>, there is nothing special done and the value is simply saved.</p>
<p>And finally, as mentioned in general-comment above, something special happens to your declaration of <code>b</code></p>
<pre><code>signed short b = 0xFFFF;
</code></pre>
<p>The 0xFFFF in this case is a signed integer. The decimal value is 65535. However, that value is <em>not</em> representable by a <code>signed short</code> so yet-another conversion happens, one that perhaps you weren't aware of:</p>
<p><strong>C99 6.3.1.3-p3</strong></p>
<blockquote>
<p>Otherwise, the new type is signed and the value cannot be represented in it; either the result is implementation-defined or an implementation-defined signal is raised.</p>
</blockquote>
<p>In other words, your implementation <em>chose</em> to store it as <code>(-1)</code>, but you cannot rely on that on a different implementation.</p>
",1
9170669,9170643,4,"<p>Arrays are passed to functions as pointers, so the 8 bytes you are seeing is really the size of a pointer (assuming you're on 64-bit) and not the size of the original array. There is no way to retrieve the actual size of the pointed-to array, so you'll have to pass it separately to the function.</p>
",2
9170705,9170643,1,"<p>There is no way to know a size of an array once it was passed as a parameter to a function. You need to pass the number of the elements in the array.</p>

<pre><code>short int write_frames(xmp_frame frame_array[], int num_frames,FILE *outfp)
{
    for(int i=0; i &lt; num_frames; i++)
        // write frame_array[i]
}
</code></pre>
",0
8736110,8735760,1,"<p>Your used last and head uninitialized, so  head->next and friends would segfault. In fact you don't need them at all and you don't need your if branches - just replace hashtable[key] by new_node after setting new_node->next to hashtable[key]</p>

<pre><code>void build_hashtbl(){

    int i = 0;
    int k = 0;
    int key = 0;

    char sElement[WLEN+1] = {0};

    for (i = 0; i &lt;SLEN; i = i+WLEN){ //for every 5 char, find they hashtable index key
        key = hashfunc(string+i);

        for (k = 0; k &lt;WLEN; k++){ //create a new string, sElement from the 5 letter word
            sElement[k] = string[i+k];
        }

        struct Node *new_node;
        new_node = (struct Node *) malloc ( sizeof (struct Node) );
        strcpy(new_node-&gt;s, sElement); //put the new 5 letter word string into the node
        new_node-&gt;next=hashtable[key];
        new_node-&gt;sindex=i;
        hashtable[key]=new_node;

    }
}
</code></pre>

<p>Works for me.</p>

<p>Edit: Also needs <code>#include &lt;stdlib.h&gt;</code> (at least here)</p>
",6
12863853,12863495,0,"<p>What about using <code>strncat</code>?</p>

<p>See a working example on codepad: <a href=""http://codepad.org/xdwhH0ss"" rel=""nofollow"">http://codepad.org/xdwhH0ss</a></p>
",1
12863522,12863495,0,"<p>I'm not an expert on C, but I don't believe constants should be changed once they are defined.</p>
",1
12863558,12863495,5,"<p>No matter what you do, you need to convert the number to a string, otherwise you can't create a string containing both numbers.</p>

<p>You can actually combine both the concatenation and the int-to-string conversion in one function call: <code>sprintf</code>:</p>

<pre><code>char output[16];
sprintf(output, ""P%d"", input);
</code></pre>
",6
12863578,12863495,0,"<p>You cannot assign more than one character value to a <code>char</code>. For doing that you would have to take a string. Maybe like this.</p>

<pre><code>int append(int input)
{
  const char P = 'P';

 //This where I want to append 1 to P to create ""P1""
char app[2] ;  //extend that for your no. of digits
app[0] = P '
app[1] = (char) input  ;
}
</code></pre>

<p>This is for one digit. You can allocate dynamic memory for big integers and do the same in a loop.</p>
",2
12864139,12863495,0,"<p>I would convert the number to a string (assuming you have access to a function called <code>itoa</code> in this example and concatenate it to the character. If you don't have access to <code>itoa</code> you could <code>sprintf</code> instead.</p>

<p>itoa method:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

char *foo(const char ch, const int i)
{
    char *num, *ret;
    int c = i;

    if(c &lt;= 0) c++;
    if(c == 0) c++;
    while(c != 0)
    {
        c++;
        c /= 10;
    }
    c += 1;
    if(!(num = malloc(c)))
    {
        fputs(""Memory allocation failed."", stderr);
        exit(1);
    }
    if(!(ret = malloc(c + 1)))
    {
        fputs(""Memory allocation failed."", stderr);
        free(num);
        exit(1);
    } 
    itoa(i, num, 10);
    ret[0] = ch;
    ret[1] = 0x00;
    strcat(ret, num);
    free(num);
    return ret;
}

int main(void)
{
    char *result;

    if(!(result = foo('C', 20))) exit(1);
    puts(result);
    free(result);
    return 0;
 }
</code></pre>

<p>sprintf method:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

char *foo(const char ch, const int i)
{
    char *num, *ret;
    int c = i;

    if(c &lt;= 0) c++;
    if(c == 0) c++;
    while(c != 0)
    {
        c++;
        c /= 10;
    }
    c += 1;
    if(!(num = malloc(c)))
    {
        fputs(""Memory allocation failed."", stderr);
        exit(1);
    }
    if(!(ret = malloc(c + 1)))
    {
        fputs(""Memory allocation failed."", stderr);
        free(num);
        exit(1);
    } 
    sprintf(num, ""%d"", i);
    ret[0] = ch;
    ret[1] = 0x00;
    strcat(ret, num);
    free(num);
    return ret;
}

int main(void)
{
    char *result;

    if(!(result = foo('C', 20))) exit(1);
    puts(result);
    free(result);
    return 0;
 }
</code></pre>

<p>I compiled and tested both of these and they seem to work quite nicely. Good luck.</p>
",0
12863585,12863495,0,"<p>Not sure if you can add something to a const chat (since its a const). </p>

<p>But why not:</p>

<pre><code>char p[3];
sprintf(p, ""P%d"",input);
</code></pre>
",0
8778221,8778127,1,"<p>The first line of the response is the status line, and is very easy to parse. It consists of the protocol version followed by a numeric status code and its associated textual phrase (""OK"", ""Not Found"" etc).</p>

<p>For example:</p>

<pre><code>HTTP/1.1 200 OK
</code></pre>

<p>The exact syntax and the list of valid codes is documented in <a href=""http://www.ietf.org/rfc/rfc2616.txt"" rel=""nofollow"">RFC 2616</a> (section 6.1).</p>
",0
8778942,8778127,2,"<p>You should use <a href=""http://curl.haxx.se/libcurl/c/"" rel=""nofollow"">libcurl</a> to perform the HTTP request.</p>

<p>And the function <a href=""http://curl.haxx.se/libcurl/c/curl_easy_getinfo.html"" rel=""nofollow"">curl_easy_getinfo</a> to get the HTTP code.</p>
",0
17800462,17800410,3,"<p>Yes, C allows casting to anonymous structures. Here is a quick demo:</p>

<pre><code>struct xxx {
    int a;
};
...
// Declare a ""real""struct, and assign its field
struct xxx x;
x.a = 123;
// Cast a pointer of 'x' to void*
void *y = &amp;x;
// Access a field of 'x' by casting to an anonymous struct
int b = ((struct {int a;}*)y)-&gt;a;
printf(""%d\n"", b); // Prints 123
</code></pre>

<p><a href=""http://ideone.com/DgyW18"" rel=""nofollow"">Demo on ideone</a>.</p>
",2
10169185,10169143,3,"<pre><code>char * p_divs = divs; //what does divs do
char tmp;
while(tmp = *p_divs++)
    if (tmp == c) return 1
</code></pre>

<p><code>divs</code> is a pointer to a char array (certainly a string). <code>p_divs</code> just points to the same string and within the while loop a single character is extraced and written to <code>tmp</code>, and then the pointer is incremented meaning that the next character will be extraced on the next iterator. If <code>tmp</code> matches <code>c</code> the function returns.</p>

<p><strong>Edit:</strong> You should learn more about pointers, have a look at <a href=""https://stackoverflow.com/questions/394767/pointer-arithmetic"">Pointer Arithmetic</a>.</p>
",0
10170099,10169143,4,"<p>Here, inDiv can be called to search for the character <code>c</code> in the string <code>divs</code>, for example:</p>

<pre><code>inDiv('x', ""is there an x character in here somewhere?') will return 1
inDiv('x', ""ahhh... not this time') will return 0
</code></pre>

<p>Working through it:</p>

<pre><code>int inDiv(char c, char * divs)
{
    char * p_divs = divs;    // remember which character we're considering
    char tmp;
    while(tmp = *p_divs++)   // copy that character into tmp, and move p_divs to the next character
                             // but if tmp is then 0/false, break out of the while loop
         if (tmp == c) return 1;  // if tmp is the character we're searching for, return ""1"" meaning found
    return 0;   // must be here because tmp == 0 indicating end-of-string - return ""0"" meaning not-found
}
</code></pre>

<p>We can infer things about <code>reverse</code> by looking at the call site:</p>

<pre><code>int main()
{
    char source[MAS_SIZE], dest[MAS_SIZE], divs[MAS_SIZE];
    printf(""String          : "");
    gets(source);
    printf(""Dividers        : "");
    gets(divs);
    reverse(source, dest, divs);
    printf(""Reversed string : %s"", dest);
</code></pre>

<p>We can see <code>gets()</code> called to read from standard input into character arrays <code>source</code> and <code>divs</code> -> those inputs are then provided to <code>reverse()</code>.  The way <code>dest</code> is printed, it's clearly meant to be a destination for the reversal of the string in <code>source</code>.  At this stage, there's no insight into the relevance of <code>divs</code>.</p>

<p>Let's look at the source...</p>

<pre><code>void reverse(char * source, char * dest, char * divs)
{
    *dest = '\0'; //what does this pointer do?
    int source_len = strlen(source); //what is source
    if (source_len == 0) return;
    char* p_source = source + source_len - 1;
    char* p_dest = dest;
    while(p_source &gt;= source)
    {
        while((p_source &gt;= source) &amp;&amp; (inDiv(*p_source, divs))) p_source--;
</code></pre>

<p>Here, <code>*dest = '\0'</code> writes a NUL character into the character array <code>dest</code> - that's the normal sentinel value encoding the end-of-string position - putting it in at the first character <code>*dest</code> implies we want the destination to be cleared out.  We know <code>source</code> is the textual input that we'll be reversing - <code>strlen()</code> will set <code>source_len</code> to the number of characters therein.  If there are no characters, then <code>return</code> as there's no work to do and the output is already terminated with NUL.  Otherwise, a new pointer <code>p_source</code> is created and initialised to <code>source + source_len - 1</code> -> that means it's pointing at the <em>last</em> non-NUL character in source.  <code>p_dest</code> points at the NUL character at the start of the destination buffer.</p>

<p>Then the loop says: <code>while (p_source &gt;= source)</code> - for this to do anything <code>p_source</code> must initially be <code>&gt;= source</code> - that makes sense as <code>p_source</code> points at the last character and <code>source</code> is the first character address in the buffer; the comparison implies we'll be moving one or both towards the other until they would cross over - doing some work each time.  Which brings us to:</p>

<pre><code>while((p_source &gt;= source) &amp;&amp; (inDiv(*p_source, divs))) p_source--;
</code></pre>

<p>This is the same test we've just seen - but this time we're only moving <code>p_source</code> backwards towards the start of the string while <code>inDiv(*p_source, divs)</code> is also true... that means that the character at <code>*p_source</code> is one of the characters in the <code>divs</code> string.  What it means is basically: move backwards until you've gone past the start of the string (though this test has undefined behaviour as Michael Burr points out in comments, and really might not work if the string happens to be allocated at address 0 - even if relative to some specific data segment, as the pointer could go from 0 to something like FFFFFFFF hex without ever seeming to be less than 0) or until you find a character that's not one of the ""divider"" characters.</p>

<p>Here we get some real insight into what the code's doing... dividing the input into ""words"" separated by any of a set of characters in the <code>divs</code> input, then writing them in reverse order with space delimiters into the destination buffer.  That's getting ahead of ourselves a bit - but let's track it through:</p>

<p>The next line is...</p>

<pre><code>if (p_source &lt; source) break;
</code></pre>

<p>...which means if the loop exited having backed past the front of the source string, then break out of all the loops (looking ahead, we see the code just puts a new NUL on the end of the already-generated output and returns - but is that what we'd expect? - if we'd been backing through the ""hello"" in ""hello world"" then we'd hit the start of the string and terminate the loop without copying that last ""hello"" word to the output!  The output will always be all the words in the input - except the first word - reversed - that's not the behaviour described by the author).</p>

<p>Otherwise:</p>

<pre><code>char* w_end = p_source;  // remember where the non-divider character ""word"" ends

// move backwards until there are no more characters (p_source &lt; source) or you find a non-divider character
while((p_source &gt;= source) &amp;&amp; (!inDiv(*p_source, divs))) p_source--;

// either way that loop exited, the ""word"" begins at p_source + 1
char * w_beg = p_source + 1;

// append the word between w_beg and w_end to the destination buffer
for(char* p = w_beg; p &lt;= w_end; p++) *p_dest++ = *p;

// also add a space...
*p_dest++ = ' ';
</code></pre>

<p>This keeps happening for each ""word"" in the input, then the final line adds a NUL terminator to the destination.</p>

<pre><code>*p_dest = '\0';
</code></pre>

<p>Now, you said:</p>

<blockquote>
  <p>according [to] the writer it writes a string of hello world then there is a function in it that also reverses the string to world hello</p>
</blockquote>

<p>Well, given inputs ""hello world"" and divider characters including a space (but none of the other characters in the input), then the output would be ""hello world "" (note the space at the end).</p>

<p>For what it's worth - this code isn't that bad... it's pretty normal for C handling of ASCIIZ buffers, though the assumptions about the length of the input are dangerous and it's missing that first word....</p>

<p>** How to fix the undefined behaviour **</p>

<p>Regarding the undefined behaviour - the smallest change to address that is to change the loops so they terminate when at the start of the buffer, and have the next line explicitly check why it terminated and work out what behaviour is required.  That will be a bit ugly, but isn't rocket science....</p>
",2
10171831,10169143,1,"<p>As I pointed out in the comments, I don't think C is really the ideal tool for this task (given a choice, I'd use C++ without a second thought).</p>

<p>However, I suppose if I'm going to talk about how horrible the code is, the counter-comment really was right: I should post something better. Contrary to the comment in question, however, I don't think this represents a compromise in elegance, concision, or performance. </p>

<p>The only part that might be open to real argument is elegance, but think this is enough simpler and more straightforward that there's little real question in that respect. It's clearly more concise -- using roughly the same formatting convention as the original, my rev_words is 14 lines long instead of 17. As most people would format them, mine is 17 lines and his is 21.</p>

<p>For performance, I'd expect the two to be <em>about</em> equivalent under most circumstances. Mine avoids running off the beginning of the array, which saves a tiny bit of time. The original contains an early exit, which will save a tiny bit of time on reversing an empty string. I'd consider both insignificant though.</p>

<p>I think one more point is far more important though: I'm reasonably certain mine doesn't use/invoke/depend upon undefined behavior like the original does. I suppose some people might consider that justified if it provided a <em>huge</em> advantage in another area, but given that it's roughly tied or inferior in the other areas, I can't imagine who anybody would consider it (even close to) justified in this case.</p>

<pre><code>#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

#include &lt;stdio.h&gt;

int contains(char const *input, char val) {
    while (*input != val &amp;&amp; *input != '\0')
        ++input;
    return *input == val;
}

void rev_words(char *dest, size_t max_len, char const *input, char const *delims) {
    char const *end = input + strlen(input);
    char const *start;
    char const *pos;

    do {
        for (; end&gt;input &amp;&amp; contains(delims, end[-1]); --end);
        for (start=end; start&gt;input &amp;&amp; !contains(delims,start[-1]); --start);
        for (pos=start; pos&lt;end &amp;&amp; max_len&gt;1; --max_len) 
            *dest++=*pos++;
        if (max_len &gt; 1) { --max_len; *dest++ = ' '; }
        end=start;
    } while (max_len &gt; 1 &amp;&amp; start &gt; input);
    *dest++ = '\0';
}

int main(){ 
    char reversed[100];

    rev_words(reversed, sizeof(reversed), ""This is an\tinput\nstring with\tseveral words in\n     it."", "" \t\n."");
    printf(""%s\n"", reversed);
    return 0;
}
</code></pre>

<p>Edit: The:</p>

<pre><code>if (max_len &gt; 1) { --max_len; *dest++ = ' '; }
</code></pre>

<p>should really be:</p>

<pre><code>if (max_len &gt; 1 &amp;&amp; end-start &gt; 0) { --max_len; *dest++ = ' '; }
</code></pre>

<p>If you want to allow for max_len &lt; 1, you can change:</p>

<pre><code>*dest++ = '\0';
</code></pre>

<p>to:</p>

<pre><code>if (max_len &gt; 0) *dest++ = '\0';
</code></pre>

<p>If the buffer length could somehow be set by via input from a (possibly hostile) user, that would probably be worthwhile. For many purposes it's sufficient to simply require a positive buffer size.</p>
",4
9216606,9216543,0,"<p>For switch case doubt, a case like <code>case 1:</code> works like a normal c label. You don't have to do anything to write a ""block"" of statements. It just continues to execute until the <code>swtich</code> block is over or a <code>break</code> statement is encountered. Even other cases on the way will be ignored.</p>

<p>so you can write you switch case like this:</p>

<pre><code>case 1:
   printf(""Blah Blah"");
   printf(""Blah Blah Blah"");
   break; //This is important. Signifies end of block, not the braces!
</code></pre>

<p>There is no syntax that is meant for single statement separately. It all follows a pattern, once you get on hold to it, you will no longer have such doubts. I didn't get your <code>if...else</code> doubt, but I think it is similar. Think of it as how compiler would parse it and make meaning out of it, you will see things getting clear automatically.</p>
",0
9216612,9216543,0,"<p>An <code>if</code> can not have more than one <code>else</code>.  However you can put a new <code>if</code> in the <code>else</code> case:</p>

<pre><code>if (var == 0)
{
    doZero();
} 
else
{
   if (var &gt; 10)
   {
       doTooBig();
   }
   else
   {
        doDefault();
   }
}
</code></pre>

<p>And people usually remove the brackets after the first else, so that it reads like this:</p>

<pre><code>if (var == 0)
{
    doZero();
} 
else if (var &gt; 10)
{
    doTooBig();
}
else
{
     doDefault();
}
</code></pre>
",0
9216615,9216543,0,"<pre><code>switch (i){
   case 1:
     state1;
     state2;
     state3;
     break;
}
</code></pre>

<p>Switch statements start executing code when you hit the matching case and then goes until it sees a break statement. This means if you forget the break the code will keep running through all of your cases until the end of the switch statement.</p>

<p><a href=""http://www.cprogramming.com/tutorial/lesson5.html"" rel=""nofollow"">http://www.cprogramming.com/tutorial/lesson5.html</a></p>
",0
9216618,9216543,0,"<ol>
<li><p>No, there can be only one <code>else</code> per <code>if</code>.  Since an <code>else if</code> is a new <code>if</code>, it can have a new <code>else</code> - you can have as many <code>else if</code>s as you want.</p></li>
<li><p>No, you can put any condition in any <code>if</code> statement:</p>

<pre><code>if (foo)
  ...
else if (bar)
  ...
</code></pre></li>
<li><p>Yes, any expression can be used in an <code>if</code> statement.</p></li>
<li><p>You can use as many statements as you like.  Both of your examples are fine, but the second one creates a new block - you could declare variables inside it, for example.</p></li>
</ol>
",0
9216621,9216543,0,"<p>Actually the else if doesn't exists!<br>
Writing this:</p>

<pre><code>if(...) {

}
else if(...) {    // can test any condition, no need to use the same var.

}
else if(...) {

}
else if(...) {

}
else {

}
</code></pre>

<p>Is equivalent to (and understood by the compiler as):</p>

<pre><code>if(...) {

}
else {
    if(...) {    // can test any condition, no need to use the same var.

    }
    else {
        if(...) {

        }
        else {
            if(...) {

            }
            else {

            }
        }
    }
}
</code></pre>

<p>The reason why we write it like the first snippet is obvious: it's much more clear and readable.<br>
Regarding your question about the switch statement, writing or not the parentheses doesn't make any difference.</p>
",0
9216632,9216543,4,"<h2>if, else, ""else if""</h2>

<p>An <code>if</code> can have zero or one associated <code>else</code> clauses. Examples:</p>

<pre><code>if (X)
    printf(""if\n"");
</code></pre>

<p>or </p>

<pre><code>if (X)
    printf(""if\n"");
else
    printf(""else\n"");
</code></pre>

<p>These take only a <strong>single statement</strong>. If you want to use multiple statements (and some people say it's better to do this even if you only have one statement per <code>if</code>/<code>else</code>), you have to use curly braces, like this:</p>

<pre><code>if (X) {
    printf(""if\n"");
} else {
    printf(""else\n"");
}
</code></pre>

<p>You can also nest <code>if</code>s:</p>

<pre><code>if (X)
    printf(""X\n"");
else
    if (Y)
        printf(""Y\n"");
    else
        printf(""something else\n"");
</code></pre>

<p>This is usually written in a more readable way, though:</p>

<pre><code>if (X)
    printf(""X\n"");
else if (Y)
    printf(""Y\n"");
else
    printf(""something else\n"");
</code></pre>

<p>You see, the <code>else if</code> is nothing special, it's just another form of laying out a nested <code>if</code>.</p>

<p>Again, if you want more than one statement in there, you need to use curly braces:</p>

<pre><code>if (X) {
    printf(""X\n"");
    printf(""X2\n"");
} else if (Y) {
    printf(""Y\n"");
    printf(""Y2\n"");
} else {
    printf(""something else\n"");
    printf(""yet another print\n"");
}
</code></pre>

<h2>switch/case</h2>

<p>As for <code>switch</code> statements, there you don't need curly braces. Note however that ""cases fall through"" which means that in this example all four <code>printf</code>s are actually executed:</p>

<pre><code>switch (1) {
  case 1:
    printf(""I will be printed!\n"");
    printf(""Me too!\n"");
  case 2:
    printf(""And me also! (although I probably shouldn't)\n"");
  case 3:
    printf(""Me as well!\n"");
}
</code></pre>

<p>If you don't want this (which is usually the case), you have to use an explicit <code>break</code> after the code in each <code>case</code>:</p>

<pre><code>switch (1) {
  case 1:
    printf(""I will be printed!\n"");
    printf(""Me too!\n"");
    break;
  case 2:
    printf(""I won't :(\n"");
    break;
  case 3:
    printf(""D'oh!\n"");
    break;
}
</code></pre>

<h2>Blocks</h2>

<p>By the way, the curly braces rule can be generalized: At every place where a single statement is allowed, you can also use something like <code>{ ... }</code>, which is called a <strong>block</strong>. The advantage of using blocks is that you can</p>

<ol>
<li>Use multiple statements where only one would be allowed otherwise (e.g. in an <code>if</code>)</li>
<li>Declare variables at the beginning of every block! Thus, you can do something like the following <code>case 3: { int x = 3; printf(""%d\n"", x); }</code>.</li>
</ol>
",0
13405380,13405347,5,"<blockquote>
  <p>If x==1 will the output be</p>
</blockquote>

<pre><code> apple
 banana
</code></pre>

<p>Yes, it will. Labels (either <code>goto</code> or <code>switch</code> labels) fall through.</p>
",0
11512947,11512918,0,"<p>Have <code>check</code> take a parameter which is the number. Then have a counter in the main loop of your program that starts at some value, and is decremented every time check is called.</p>

<p>I'm assuming that you are doing something more complex than what your current <code>check</code> function does because obviously it doesn't do anything in the provided form. If you provide more information, we would be able to give you a more thorough and applicable solution.</p>
",7
11513040,11512918,1,"<p>Quick and dirty way:</p>

<pre><code>while(true)
{
    check();
    sleep(5);
}


int values[1];
int check(void)
{
    if (values[0] &gt; 0)
       values[0]--;
}
</code></pre>
",3
11513048,11512918,1,"<p>If you have access to the system time, you can store the initial time the call was made, and then every time you query its value, check against the system time to determine the correct adjusted value, and a little snippet to set the value, like such:</p>

<pre><code>// initialize
int check = 142;
unsigned long long time = getMillis();

int get_value(void)
{
    unsigned long long time_factor = ((getMillis() - time) / (unsigned long long) 5);
    if (time_factor &gt; (unsigned long long) check)
        return 0;
    else
        return check - time_factor;
}

void set_value(int v)
{
    check = v;
    time = getMillis();
}
</code></pre>

<p>Note that I don't know off the top of my head how to get the system time in c (though I bet you'd need <code>#include &lt;time.h&gt;</code>) so I made up a function called getMillis() which returns the system time as an unsigned long long (should be a 64 bit unsigned integer).  The implementation is up to the reader.</p>

<p>It's also worth mentioning that you will experience a wraparound error after about 600 million years.</p>
",0
11513068,11512918,0,"<pre><code>void check() {
  static int array[] = {142}; // why are you using an array here?
  (*array)--;
}

int main() {
  while(true)
  {
    check();
    usleep(5000); // approximate
  }
  return 0;
}
</code></pre>
",0
9196983,9196960,7,"<p>Use strcmp and a real string, not a multi character constant.</p>

<pre><code>strcmp(argv[2], ""squared"") == 0
</code></pre>
",7
9196986,9196960,2,"<p>You can use <code>strcmp</code> for that:</p>

<pre><code>if(strcmp(argv[2], ""squared"") == 0)  /* returns true if argv[2] is ""squared"" */
</code></pre>
",0
9197001,9196960,3,"<p>Try strcmp(3). 
In your case, you would have to use <code>strcmp(argv[2], ""squared"");</code>
Check out <a href=""http://linux.die.net/man/3/strcmp"" rel=""nofollow"" title=""strcmp(3)"">this</a> manual page for more info. </p>
",0
9197023,9196960,1,"<p><em>strcmp()</em>/*strncmp()* is the way to go. And make sure your strings are null-terminated ;)</p>
",0
9197052,9196960,1,"<p>Single quotes in C are only used for single characters, not strings. So you'd write 'a' for the a character, but ""hello world"" for a string.</p>

<p>There is a difference between 'a' and ""a"" incidentally - ""a"" has a zero-terminator on the end, so it's actually a two-character string. That's important because you have to remember that char arrays need to be one character longer than the string you're storing in the them.</p>

<p>To compare strings, use strcmp, like this:</p>

<pre><code>if (strcmp(argv[2], ""squared"") == 0)
{
    //they are equal
}
</code></pre>
",0
17388032,17387987,3,"<p>The postfix increments or decrements are operators that perform the increment or decrement after the use of the variable, such that if you wish to use a integer value to print out and add it at the same time you would use postfix.</p>

<pre><code>int i = 0;
printf(""%d"",i++);
//prints out 0
</code></pre>

<p>Prefix increment/decrement however works in the opposite manner such that it performs the increment/decrement prior to the use of the variable, such that if you wish to increment/decrement a variable before printing it out, you would use prefix</p>

<pre><code>int i = 0;
printf(""%d"",++i);
//prints out 1
</code></pre>
",0
17388056,17387987,1,"<p>try to understand how post fix increment works. </p>

<p>f(i++) is equivalent to the operation 'call f on the current value of i, then increment i'</p>

<p>For example, when you use i++ twice, and initial value of <code>i = 1</code>, <code>a(i++) = b(i++)</code> means, <code>a(1)=b(2)</code> and the value of i after the operation is <code>i=3</code>.</p>

<p>If you want to eliminate one variable in what you are trying to do, you have to make sure you use increment only once. Do it like, <code>a(i)=(b(i); i++</code> </p>
",3
17388168,17387987,1,"<p>The problem you have is not related to how the postfix operator works, but rather to what you intend to do in the code line which gives you a problem.</p>

<p>As asked in the comments, what is the meaning of the line as you wrote it initially?</p>

<pre><code>longestStr[i++] = tmpStr[i++];
</code></pre>

<p>Because the C standard does not specify it, this line can be interpreted in several ways:</p>

<pre><code>longestStr[i] = tmpStr[i+1];
i += 2;
</code></pre>

<p>or </p>

<pre><code>longestStr[i+1] = tmpStr[i];
i += 2;
</code></pre>

<p>or </p>

<pre><code>longestStr[i] = tmpStr[i];
i += 2;
</code></pre>

<p>In every case, you end up with a counter incremented twice, which will mess up your algorithm.</p>

<p>The correct way is to increment the counter in a separate line, or use the working solution (you are providing), which should be compiled down to the same code with any decent compiler.</p>

<p>Note that you should probably check for the counter not going beyond the maximum allowed line size <code>MAXLINE</code> (unless the problem states that this cannot happen with the input, but even in that case, it would be helpful for situations like yours, where the code wrongly increment the counter twice).</p>
",4
17388349,17387987,0,"<p>Whereas the postfix increment operator evaluates the original value, it is understandable to think the actual incrementating doesn't happen until sometime down the road.  However this is not the case.  You should conceptualize postfix as if the incrementing is happening while the original value is being returned.</p>

<p>The bigger issue though is that your statement increments i twice.  This means i will increase by two with each iteration of your loop. Futhermore your index values will be off by one from each other, That's because if a variable changes during one part of statement evaluation, those changes become instantly visible to parts of the statement which have not yet evaluated.</p>
",0
18479649,18479619,3,"<p><code>printf(""%d\n"", buf);</code> output the address of <code>buf</code> instead of the return value.</p>
",4
18479665,18479619,3,"<pre><code>printf(""%d\n"", buf);
</code></pre>

<p>This prints address of <code>buf</code> as its pointer variable.</p>

<p>If you really want to print its address use <code>%p</code> instead of <code>%d</code>.</p>

<p>If you want to print string use <code>%s</code>, but make sure your buffer read from file is null terminated.</p>
",0
18479717,18479619,1,"<p>In the memory, all the data is stored in 1's and 0's. Its up to you how you interpret the data.</p>

<pre><code>If you want the data to be printed as integer, use %d.
If you are printing a address , use %p.
If you want the data to be printed as char, use %c.
If you want the data to be printed as string, use %s.
</code></pre>

<p>In your example, use</p>

<pre><code>printf(""%d\n"", buf);
</code></pre>

<p>to get the proper output.</p>
",0
19972755,19972720,7,"<p>If you divide it by 4096, that is merely a shift right by 12 bits. That means that the last 12 bits are lost:</p>

<pre><code>0x7fffffffffffffff becomes
0x7ffffffffffff
</code></pre>

<p>If you multiply back, you shift left by 12, so the missing bits are filled with 0.</p>
",7
19972788,19972720,0,"<p>Its simple maths...</p>

<p><code>1024 * 4 * 0x7ffffffffffff = 0x7ffffffffffff000</code></p>
",0
19973496,19972720,1,"<pre><code>echo ""((15/4)*4)"" | bc
</code></pre>

<p>the result is not 15</p>
",0
19975133,19972720,1,"<p>Both integer division and integer multiplication work exactly only as long as the result fits within the confines of the type. If it doesn't you get all sorts of truncation etc.</p>

<p>Let's get a simpler version, a char variable [0-255]</p>

<pre><code>  unsigned char a = 12;
  unsigned char b = a/4;
</code></pre>

<p>Since 12/4 = 3 exactly, and 3 is an integer in range between 0 and 255, <code>b</code> is 3. Multiply that by 4, and you get your 12 back.</p>

<pre><code>  unsigned char a = 11;
  unsigned char b = a/2;
</code></pre>

<p>11/2 is 5.5 but integers can't store the fractional part. In this case b is <code>5</code> and the 0.5 part is irrecoverably lost. Multiply the <code>b</code> by 2 and you get <code>10</code>, not <code>11</code>. </p>

<p>Note, it's truncation, not rounding.</p>

<pre><code>  unsigned char a = 100;
  unsigned char b = a/15;
</code></pre>

<p>100/15 is 6.66(6) - which rounded to nearest integer would be closer to 7. Thing is, we're truncating, not rounding, so (int) 6.6666666666 is 6.  The fractional part is forever lost. Now multiply b*15 and you get 90. It's rather far off - it's the cost of using integers instead of floats.</p>

<p>Even worse things happen in overflow. </p>

<pre><code>  unsigned char a = 150;
  unsigned char b = a*2;  //300 with top bit truncated becomes 44
  unsigned char c = b/2;  // 44/2 = 22
</code></pre>

<p>but that's a subject for a different question.</p>
",0
9818800,9818772,1,"<p>You need to close <code>fpOut</code> file handle using <a href=""http://www.cplusplus.com/reference/clibrary/cstdio/fclose/"" rel=""nofollow""><code>fclose</code></a>. Otherwise the content might not be written to disk before your program finishes. </p>

<p>Hints:</p>

<ol>
<li>Do you have permission to write to <code>""output.txt""</code></li>
<li>Have you tried using <code>fpOut = stdout;</code> just to check that the output is printed on the console.</li>
</ol>

<hr>

<h2>Output:</h2>

<p><em>On my system, running your code with your input.</em></p>

<pre><code>NAME:      LAB#6      EMAIL: 

EVENT: MEN SHORT PROGRAM
CHIEF ACCOUNTANT: 

SKATER: LUSHENKO Evgeni


[BASE]                   [SCORE]                        [TOTAL]
---------------------------------------------------------------
13.00     1   1   1   1   1   1   1   1   1   1   1   1   10.17
 7.50     2   2   2   2   2   2   2   2   2   2   2   2   10.17
 6.00     3   3   3   3   3   3   3   3   3   3   3   3   10.17
 2.30     4   4   4   4   4   4   4   4   4   4   4   4   10.17
 3.40     5   5   5   5   5   5   5   5   5   5   5   5   10.17
 2.10     6   6   6   6   6   6   6   6   6   6   6   6   10.17
 3.10     7   7   7   7   7   7   7   7   7   7   7   7   10.17
 3.50     8   8   8   8   8   8   8   8   8   8   8   8   10.17
---------------------------------------------------------------
Total Base: 40.90                  Total Technical Score: 63.82


SKATER: EIR Johnny


[BASE]                   [SCORE]                        [TOTAL]
---------------------------------------------------------------
 7.50     1   1   1   1   1   1   1   1   1   1   1   1    6.33
10.00     2   2   2   2   2   2   2   2   2   2   2   2    6.33
 3.00     3   3   3   3   3   3   3   3   3   3   3   3    6.33
 3.10     4   4   4   4   4   4   4   4   4   4   4   4    6.33
 5.50     5   5   5   5   5   5   5   5   5   5   5   5    6.33
 1.30     6   6   6   6   6   6   6   6   6   6   6   6    6.33
 3.10     7   7   7   7   7   7   7   7   7   7   7   7    6.33
 3.00     8   8   8   8   8   8   8   8   8   8   8   8    6.33
---------------------------------------------------------------
Total Base: 36.50                  Total Technical Score: 54.83


SKATER: YSACEK Evan 


[BASE]                   [SCORE]                        [TOTAL]
---------------------------------------------------------------
 7.50     1   1   1   1   1   1   1   1   1   1   1   1   10.17
10.00     2   2   2   2   2   2   2   2   2   2   2   2   10.17
 3.00     3   3   3   3   3   3   3   3   3   3   3   3   10.17
 3.10     4   4   4   4   4   4   4   4   4   4   4   4   10.17
 1.70     5   5   5   5   5   5   5   5   5   5   5   5   10.17
 2.10     6   6   6   6   6   6   6   6   6   6   6   6   10.17
 3.10     7   7   7   7   7   7   7   7   7   7   7   7   10.17
 3.50     8   8   8   8   8   8   8   8   8   8   8   8   10.17
---------------------------------------------------------------
Total Base: 34.00                  Total Technical Score: 53.58


SKATER: AVOIE Matthew 


[BASE]                   [SCORE]                        [TOTAL]
---------------------------------------------------------------
 3.00     1   1   1   1   1   1   1   1   1   1   1   1    6.33
 7.50     2   2   2   2   2   2   2   2   2   2   2   2    6.33
 9.50     3   3   3   3   3   3   3   3   3   3   3   3    6.33
 3.10     4   4   4   4   4   4   4   4   4   4   4   4    6.33
 1.90     5   5   5   5   5   5   5   5   5   5   5   5    6.33
 2.10     6   6   6   6   6   6   6   6   6   6   6   6    6.33
 3.10     7   7   7   7   7   7   7   7   7   7   7   7    6.33
 3.00     8   8   8   8   8   8   8   8   8   8   8   8    6.33
---------------------------------------------------------------
Total Base: 33.20                  Total Technical Score: 50.28
</code></pre>
",4
9820647,9818772,1,"<p>I am guessing your problem stems from the misunderstanding of working of <a href=""http://www.cplusplus.com/reference/clibrary/cstdio/sscanf/"" rel=""nofollow""><code>sscanf</code></a>. When you use <code>sscanf</code> the buffer pointer which it is reading is <em>not moved further</em> i.e. multiply calls will read the same buffer the same way. In your function <code>getData</code> the following piece of code:  </p>

<pre><code>        for(k = 0; k &lt; MAX_ELEM; k++)
        {                       
                if(fgets(buffer, sizeof(buffer)-1, fpIn) != NULL)
            {                    
                        sscanf(buffer,""%d %f"", &amp;skater[i].elements, &amp;skater[i].baseval[k]);
                        for(j = 0; j &lt; SCORE; j++)
                        {
                                sscanf(buffer,""%d"", &amp;skater[i].score[k][j]);
                        }
                }
        } 
</code></pre>

<p>the value read in <code>skater[i].elements</code> is stored in all of <code>skater[i].score[k][j]</code> values as the <code>skater[i].elements</code> will be the first <code>int</code> read (assuming that the call is successful). You could choose to read all the elements in a single <code>sscanf</code> call something on these (inelegant) lines:  </p>

<pre><code>    for (k = 0; k &lt; MAX_ELEM; k++) {
        if (fgets(buffer, sizeof(buffer) - 1, fpIn) != NULL) 
        {
            sscanf(buffer, ""%d %f %d %d %d %d %d %d %d %d %d %d %d %d"",
                &amp;skater[i].elements,
                &amp;skater[i].baseval[k],
                &amp;skater[i].score[k][0],
                &amp;skater[i].score[k][1],
                &amp;skater[i].score[k][2],
                &amp;skater[i].score[k][3],
                &amp;skater[i].score[k][4],
                &amp;skater[i].score[k][5],
                &amp;skater[i].score[k][6],
                &amp;skater[i].score[k][7],
                &amp;skater[i].score[k][8],
                &amp;skater[i].score[k][9],
                &amp;skater[i].score[k][10],
                &amp;skater[i].score[k][11]
                );
        }
    }
</code></pre>

<p>Or you could also look into <a href=""http://www.cplusplus.com/reference/clibrary/cstdio/fscanf/"" rel=""nofollow""><code>fscanf</code></a> for reading from file.<br>
Side note: In <code>printData</code> you should exit if <code>fopen</code> fails. And you can use <a href=""http://www.cplusplus.com/reference/clibrary/cstdio/perror/"" rel=""nofollow""><code>perror</code></a> for more meaning error messages when <code>fopen</code> fails.<br>
Hope this helps!</p>
",0
9841624,9841559,2,"<p><code>%</code> has higher precedence than <code>+</code>, so your expression isn't same as</p>

<pre><code>arc4random() % ((126-'!'+1)) + '!'),
</code></pre>

<p>but it's the same as</p>

<pre><code>(arc4random() % (126-'!'+1)) + '!'
</code></pre>

<p>First version can return values lower than 33, while second one can't.</p>
",0
9841625,9841559,4,"<p>this is evaluated based on operator precedence like this:</p>

<pre><code>(arc4random() % (126-'!'+1)) + '!';
</code></pre>
",0
9841628,9841559,32,"<p>You interpreted it wrong: the <code>%</code> operator has a higher precedence than <code>+</code>.</p>

<p>So, in effect, you have:</p>

<pre><code>int charaCode = (arc4random() % (126-'!'+1))+'!';
</code></pre>

<p>which clips the function result to <code>0..93</code> and shifts it so that it starts with <code>'!'</code>.</p>

<p>So the effective range of what you get is <code>33..126</code> (which is the range of all visible ASCII characters from <code>!</code> to <code>~</code>).</p>
",3
9841645,9841559,1,"<p>that is not the whole expression <code>i % j + 1</code> is <code>(i%j)+1</code> so that is <code>(arc4random() % (126-'!'+1)) + '!'</code></p>

<p>Doh! I should just post answers ROFL :-)</p>
",0
9841647,9841559,1,"<p>I believe they are just trying to limit the result to printable characters. Basically it is limiting the range of random numbers to everything between the character ""!"" and ""~"". </p>
",1
11546198,10073772,1,"<p>More information on what the guy above me just said can be found here. This page gives you an overview of how to suppress or enable different kinds of warnings in your code:</p>

<p><a href=""http://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html"" rel=""nofollow"">http://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html</a></p>

<p>Also another tip. You wrote a couple while loops in your code with this syntax:</p>

<pre><code>while (1==1)
{
    ...
}
</code></pre>

<p>this will do the same thing</p>

<pre><code>while(1) 
{

}
</code></pre>

<p>Here's why: A while loop, an if statement, else statement, and an else if statement will
all perform the code beneath them if the code inside the parenthesis is true. Since 1 in C is true and 0 is false, my while loop above works the same as yours. </p>
",0
9847602,9847031,0,"<p>This may be another possbility:</p>

<p>I think it is your placement of your <code>srand</code></p>

<p>When I post this </p>

<pre><code>#include &lt;stdlib.h&gt; 
#include &lt;time.h&gt; 
#include &lt;stdio.h&gt; 
main() 
{ 
    int i;
    for(i=0;i&lt;4;i++){ 
        srand(time(NULL)); 
        printf(""%f\n"",(double)rand()/(double)RAND_MAX); 
    }
    return(0);
}
</code></pre>

<p>I get this result</p>

<pre><code>0.314774
0.314774
0.314774
0.314774
</code></pre>

<p>But when I move the <code>srand</code> outside of the loop I get different random numers</p>

<pre><code>#include &lt;stdlib.h&gt; 
#include &lt;time.h&gt; 
#include &lt;stdio.h&gt; 
main() 
{ 
    int i;
    srand(time(NULL));
    for(i=0;i&lt;4;i++){  
        printf(""%f\n"",(double)rand()/(double)RAND_MAX); 
    }
    return(0);
}
</code></pre>

<p>I get these results</p>

<pre><code>0.154158
0.832643
0.529257
0.529633
</code></pre>
",0
9847146,9847031,-3,"<p>If you see it with <code>time(NULL)</code> I believe it will always be close to each other because time is slowly incrementing.  You'll see your random number change slightly with the passing of time.</p>

<p><s>Try this:</p>

<pre><code>(double)srand(time(NULL))/(double)RAND_MAX.
</code></pre>

<p></s></p>

<p><em>--------EDIT--------</em></p>

<p>Looks like my original assumption was wrong.  I ran this an get very different random numbers without reseeding.</p>

<pre><code>#include &lt;stdio.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;time.h&gt;  

int main(void)
{
  int i, p;

  srand(time(NULL));

  for(p=0;p&lt;10;p++){  
     i = rand();

     printf (""Your random number is %d\n"", i);  

  }
  return(0);
}
</code></pre>
",13
10024440,10024376,4,"<p>Here's your problem:</p>

<pre><code>struct memcache_buffer{
    char keys[MAX_KEYS], values[MAX_KEYS]
}

snprintf(buffer-&gt;keys[0],KEY_SIZE,""%s"",key);
                     ^^^
snprintf(buffer-&gt;values[0],VALUE_SIZE,""%s"",value);
                       ^^^
</code></pre>

<p>Drop the <code>[0]</code> or <code>snprintf</code> will try to dereference some bogus value.</p>
",15
17823762,17823672,4,"<p>It's a completely different problem to the one you think you have. What's happening is that you never initialize <code>result</code>, so this:</p>

<p><code>network = result-&gt;b.essid;</code></p>

<p>is just going to give you garbage, and this:</p>

<p><code>result = result-&gt;next;</code></p>

<p>will likely give you an infinite loop. </p>

<p>You should probably turn up the warning level on your compiler, and/or look into tools like splint and Valgrind.</p>
",6
17844317,17823672,3,"<p>Just to formalize things...</p>

<p>You're incrementing k inside the for loop as well as in the for declaration.  Outputting every other character and actually reading past the bounds of network[] too. (You said you were very tired... that'll do it!)</p>

<p>Another thing, you're using the strnlen function, but without specifying the max length.  I <strong>strongly</strong> suggest always compiling with -Wall -Wextra and possibly -Wunused to show problems.  Be extra nit picky and use -Werror too, fix the warnings and errors shown, you'll write better code and build better habits.</p>

<p>Another another thing, if you can use the strlen (or strnlen) function to determine the length, your loop is redundant. A simple: (as you originally pointed out)</p>

<pre><code>printf(""Network ESSID: %s\n"", result-&gt;b.essid);
</code></pre>

<p>Would suffice.</p>

<p>essid is probably defined in the struct as either <em>'char essid[xx];'</em>, or (better) <em>'char* essid;'</em>, which implies it's <em>already</em> a char string.  (a 'char string' in C is <strong>NOT</strong> stored the same way as a 'String string' in C++)</p>

<p>{Grin} If you <em>really</em> want to write it like that:</p>

<pre><code>while (result != NULL) {
    char *network = result-&gt;b.essid;
    /* string length is unsigned */
    size_t size = strlen(network);
    /* so we need an unsigned index to compare */
    unsigned int k;
    /* initial part of output */
    printf(""Network ESSID: "");
    for (k = 0; k &lt;= size; ++k) {
        /* printf is overkill for a single char */
        putchar(network[k]));
    }
    /* terminating CR/LF/CRLF, printf overkill again */
    puts(NULL);
    result = result-&gt;next;
}
</code></pre>

<p>And the short version:</p>

<pre><code>while (result != NULL) {
    printf(""Network ESSID: %s\n"", result-&gt;b.essid);
    result = result-&gt;next;
}
</code></pre>

<p>Best wishes on your code!</p>
",0
18943028,18942719,3,"<p>You never change j, it always remains 0, so you're writing every position a[i][0]. atoi(line); will convert the first number in the line only. That's why your program is only storing the first column.</p>

<p>A possible approach to fix this would be something like:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void) {
    int  i=0,totalNums,totalNum,j=0;
    size_t count;
    int numbers[100][100];
    char *line = malloc(100);

    FILE *file;  /* declare a FILE pointer  */
    file = fopen(""g.txt"", ""r"");  /* open a text file for reading */

    while(getline(&amp;line, &amp;count, file)!=-1) {
        for (; count &gt; 0; count--, j++)
            sscanf(line, ""%d"", &amp;numbers[i][j]);
        i++;
    }

    totalNums = i;
    totalNum = j;
    for (i=0 ; i&lt;totalNums ; i++) {
      for (j=0 ; j&lt;totalNum ; j++) {
        printf(""\n%d"",  numbers[i][j]);
      }
    }
    fclose(file);
    return 0;
}
</code></pre>

<p>That code will read the entire line, and then parse it number by number until no more numbers are there.</p>

<p>I didn't really understand if input is supposed to be integers or doubles, note that you declare a 2D array of doubles but then you call atoi(). The code I posted assumes it's integers, but then make sure to change your array to a 2D array of ints (or if they really are doubles, change the format string in sscanf).</p>
",11
18943224,18942719,1,"<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

using namespace std;

int main(void)
{
  FILE * fp;
  char * line = NULL;
  size_t len = 0;
  ssize_t read;

  const char *s = "" "";
  char *token = NULL;

  int i = 0;
  double arr[200];
  int j;

  fp = fopen(""g.txt"", ""r"");
  if (fp == NULL)
  {
    printf(""Error opening"");
    exit(EXIT_FAILURE);
  }

  while ((read=getline(&amp;line, &amp;len, fp)) != -1)
  {
     token = strtok(line, s);

     while(token != NULL)
     {
       arr[i] = atoi(token);
       printf(""%f\n"", arr[i]);
       token=strtok(NULL,s);
       i++;
     }
  }

  exit(EXIT_SUCCESS);
  return 0;
}
</code></pre>

<p><code>getline</code> will read file line by line and <code>strtok</code> will split entries based on space and will store seperately entries in array. Also single dimensional array is enough to store values.</p>
",6
10773023,10772906,0,"<p>You have two exit conditions. You either run off the end of the string, in which case your condtion of ascending characters is met and you return the length of the string, or you find a character that fails your ascending test, in which case you return -1.</p>

<p>Not returning the value from the call to the recursive function may work on some implementations of the compiler but with a different compiler or different optimisation flags, it may well not work so you should keep the return in your code.</p>
",0
10772933,10772906,7,"<p>Yes, you absolutely <em>need</em> the return. Note that C language rules are a bit lax about this issue, and if you hadn't used the return value, it would be fine without it. However, you use the return value, so you need the return statement.</p>

<p>What you see is probably caused by the implementation detail that function on some architectures return (integral values) by setting a well known register to that value (eax on i386). Therefore, if the bottommost recursive call does <code>return</code> and set this register, and the calls in-between don't stomp on that register, you see that it sort of works. However, you mustn't rely on that.</p>

<p>Note that good compilers will recognize this is a tail-recursive call and compile both variant basically the same way.</p>
",1
10773049,10772906,1,"<p>First of all, <code>main()</code> returns an int (actually, a type compatible with int).</p>

<p>Second, you should format your code more. Whitespace is your friend, as are line breaks. It was hard to tell whether the code without return was actually correct because most of it ran offscreen.</p>

<p>Third, you should always work with all [reasonable] warnings enabled. Doing so would have caught the missing return condition, as well as the <code>void main()</code>.</p>

<p>As for the answer, @jpalecek has done a great job providing it. I would only like to add that undefined behavior is a beast. If you rely on it, a ""working"" program may stop doing so just because you decided to compile it again, played some music while running it, or the phase of the moon changed.</p>

<p>All I could find in the [99] standard was <strong>¡ì6.9.1 clause 12</strong>:</p>

<blockquote>
  <p>If the } that terminates a function is reached, and the value of the
  function call is used by the caller, the behavior is unde?ned.</p>
</blockquote>
",2
10778131,10778058,3,"<p>On Unix and its variants, the standard system call to remove a file is <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/unlink.html"" rel=""nofollow""><code>unlink()</code></a>.  To prevent data deletion, you would have to ensure that every call to that system call, anywhere in any program run by the system, does whatever alternative trickery you want.  That is hard to do at the program level; you'd have to provide a modified C library, and you'd still find some people have worked their way around even that (they wrote some assembler, for example).  So, you might do it by modifying the behaviour of the <code>unlink()</code> system call in the kernel, but that's hard and non-portable too.</p>

<p>On Windows, the same comment applies to <code>unlink()</code>, but the chances are high that there are a number of other interfaces that also provide a mechanism for deleting a file.  The same arguments apply, but you'd have to trap more system calls, etc.</p>

<p>Finally, if you need any further nails in the coffin, the <code>unlink()</code> system call isn't the only way to destroy data.  You can open a file and truncate it, and then close it.  The file exists, but the data doesn't.  You can open a file and modify it; the file exists, but the original data is lost.</p>

<p>So, I think you are in for a difficult time.</p>

<p>You asked in first a comment and then a revision to the question:</p>

<blockquote>
  <p>[If] the attacker had already physical access to the machine, the anti-deletion by using dependent OS API will not work (for example, by using a very fast booting OS like Backtrack 5).</p>
</blockquote>

<p>I responded:</p>

<ul>
<li>If the attacker can boot to a different OS, the game is over &mdash; you can't stop the other OS from deleting the files in your current OS.</li>
</ul>

<p>Old and ugly the words may be, but they are fundamentally true.  The OS is in charge of the raw hardware.  If the attacker gets to choose what is in charge of the hardware, the attacker wins.</p>

<p>See also:</p>

<ul>
<li><p><a href=""http://technet.microsoft.com/library/cc722487.aspx"" rel=""nofollow"">The Ten Immutable Laws of Software Security</a></p>

<ol>
<li>Law #1: If a bad guy can persuade you to run his program on your computer, it's not your computer anymore</li>
<li>Law #2: If a bad guy can alter the operating system on your computer, it's not your computer anymore</li>
<li>Law #3: If a bad guy has unrestricted physical access to your computer, it's not your computer anymore</li>
<li>Law #4: If you allow a bad guy to upload programs to your website, it's not your website any more</li>
<li>Law #5: Weak passwords trump strong security</li>
<li>Law #6: A computer is only as secure as the administrator is trustworthy</li>
<li>Law #7: Encrypted data is only as secure as the decryption key</li>
<li>Law #8: An out of date virus scanner is only marginally better than no virus scanner at all</li>
<li>Law #9: Absolute anonymity isn't practical, in real life or on the Web</li>
<li>Law #10: Technology is not a panacea </li>
</ol></li>
</ul>
",0
10778183,10778058,1,"<blockquote>
  <p>The reason why I do to ask is that, I anticipate if someday the attacker had already physical access to the machine, the anti-deletion by using dependent OS API will not work (for example, by using a very fast booting OS like Backtrack 5).</p>
</blockquote>

<p>Sorry, it an attacker can boot a different operating system there's nothing you can do, because any anti-deletion code you may have written won't be running.</p>

<p>This unless you manage to intercept and patch somehow the calls to the ATA/SCSI controller and insert this patch before the BIOS gives control to the OS, but I don't think that's even possible; on the other hand, physical access = root access, the attacker could as well grab a screwdriver, open the case, connect the disk to another computer and do whatever he wants with it.</p>
",0
10778081,10778058,0,"<p>Sorry, basically IO <em>is</em> operating system. It's the most important operating system's job to provide IO. And the C standard defines so little about it that it's gotta be different, especially when it comes to such an obscure thing as undeleting files.</p>

<p>You might find some library which hides the OS-specific things behind a nice API, but it's still OS dependent on how it performs that action.</p>
",4
11150916,11150883,7,"<p>C allows you to call functions without first defining the prototypes.  (C++ does not do this.)  An implicit prototype for <code>printf</code> will be defined as follows:</p>

<pre><code>int printf();
</code></pre>

<p>Coincidentally, the calling conventions for this implicit prototype matched the actual calling conventions for <code>printf</code> on your platform.</p>

<p>In general, you cannot count on this working, and there are a large number of cases where it won't work.  I recommend enabling compiler warnings to detect implicit prototype declarations so you can fix them (by including the correct header).</p>

<p><strong>Footnote:</strong> <code>#include</code> does not import libraries, it merely pastes files into your source code at compile time.  The <code>&lt;stdio.h&gt;</code> header contains (directly or indirectly) certain prototypes, but the library has to be linked in separately.  Since <code>printf</code> is usually in a library that is linked to programs by default, you usually don't have to do anything to use <code>printf</code>.</p>
",2
11150922,11150883,4,"<p>The <code>#include</code> preprocessor directive does not <em>import</em> any library; there is no such notion of <em>import</em> in the definition of the <em>C</em> language.</p>

<p>You just happen to call a function named <code>printf</code> and the standard <em>C</em> library (e.g. <code>libc.so</code> on Linux, I don't know how Windows call it) happens to be linked in by default. Since you call a function by a name known to that library, it gets linked, and is being called at runtime.</p>

<p>However, you should enable all warnings in you compiler, and it would warn that you call an undeclared function.</p>
",0
12784676,12784650,1,"<p><code>strcat</code> is expecting a null-terminated string, but <code>char pass[50]</code> hasn't been initialized. Set <code>pass[0] = '\0'</code> to get a valid C string.</p>
",1
12784690,12784650,2,"<p>You are declaring your <code>pass</code> variable but you are not initializing it. When you concatinate onto its end, you're assuming initially its end is its start, but you need to make that be the case.</p>

<p>More importantly, take a look at your <code>temp</code> variable. You've declared it to be a <code>char *</code>, but you've initialized it to be a <code>char</code> (instead of pointing to a char), and then in <code>strcat()</code> you treat it like a pointer again -- but it's not pointing anywhere valid (causing your crash).</p>
",1
10102578,10102416,2,"<p>Do not print the histogram immediately with printf. Instead, figure out where all the data points will be before you do the printing. This way, you won't have to check every your data time you print a character AND the second array won't have to be within the histogram's painted region.</p>
",0
14838707,14838694,0,"<p>No, the scope of your <code>counter</code> variables is limited to the block where they have been declared. Note that it is pretty common to use for example the same name <code>i</code> for a loop variable in different functions.</p>
",0
14838708,14838694,4,"<p>There is nothing wrong with identically named variables declared in different functions.  Their scope is the function itself. If that were an issue it would make programming a lot more of a PITA.  We'd run out of loop variable names very quickly.</p>
",1
14838724,14838694,0,"<p>No. Conceptually, functions enclose different tasks/scopes. There may be a need for two similarly named local variable since its functionality may be the same. It's not a technical nor a conceptual problem. It's fine.</p>
",0
14838727,14838694,0,"<p>you can use the same name for local variables since their scope is limited to the block..</p>
",0
14838840,14838694,0,"<p>As others have said, it's not a problem.</p>

<p>Using names that makes sense for what the code does is the best way to make sure other people understand your code. If you have a bunch of functions that do something similar (e.g. operates on the same data fetched via some common function), it is definitely a good idea to name that variable the same way in all the functions. That way, someone who knows how one of the functions work, will be able to understand what is going on with the same thing in the next function, etc. </p>
",0
11170333,11170275,1,"<p>If they stay the same, then I don't see any problem defining these paths in a ""<code>.h</code>"" header file included in all the various .c files that reference the paths.  But every computer this thing will be running on may have different paths (""<code>Tests</code>"" instead of ""<code>test</code>""), so this is super risky programming and probably only safe if you're running it on a single machine or a set of machines that you control directly.</p>

<p>If the paths will <em>change</em>, then you need to create a storage place for these paths (e.g. static character array, etc.) and then have methods to allow these to be fetched and possibly reset dynamically (e.g. instead of writing output files to ""<code>results</code>"", maybe the user wants to change things to write files to ""<code>/tmp</code>"").  Totally depends on what you are doing in your code and what the tools you're writing will be doing.</p>
",1
11170347,11170275,1,"<blockquote>
  <p>I stored them as strings in an header file which I included in every project's file but someone discouraged from doing this. Are they right?</p>
</blockquote>

<p>Yes, they are absolutely right: ""baking in"" installation-specific strings with paths in a file system into a compiled code is not a good decision, because you must recompile simply to change locations of some key files. This limits the flexibility of other members of your team to run your tests, and may prevent your tests from being ran automatically in an automated testing environment.</p>

<p>A better solution would use a plain text configuration file with the locations of the key directories, and functions that read that file and produce correct locations at run-time.</p>

<p>Alternatively, you could provide locations of key directories as command-line parameters to your program. This way, users who run your program would be able to set correct locations without recompiling.</p>
",4
10742453,10740001,0,"<p>How do you define a pointer function? If you mean to say ""pointer to a function"", it's clearly not that. Instead it is returning a void pointer. The advantage of using void pointer is that it is generic in nature and can be converted to the pointer of our requirement.</p>
",0
18304668,10473060,0,"<p>Just some thoughts about above comments,</p>

<p>@pg190 you say "" it really only needs to be divisible by the primes between 1 and 20, i.e. 2, 3, 5, 7, 11, 13, 17, 19."" 
take 9699690, does not devide by all value from 1-20.</p>

<p>So this might be a good solution,</p>

<p>Given the number set [1-20]</p>

<p>The Least Common Multiple can be computed as follows.</p>

<p>Ex. For numbers 2,6,9</p>

<p>Express them in prime multiplications 
2   2</p>

<p>6   2 3</p>

<p>9   3 3</p>

<p>LCM = multiple of highest power of each prime number.
    = 2*3^2 = 18</p>

<p>This can be done to the problem in hand by expressing each number as prime multiplication
and then do this math.</p>
",0
10746672,10746450,5,"<p>you can also do it with a function like this.</p>

<pre><code>unsigned int foo(const char * s) {
 unsigned int result = 0;
 int c ;
 if ('0' == *s &amp;&amp; 'x' == *(s+1)) { s+=2;
  while (*s) {
   result = result &lt;&lt; 4;
   if (c=(*s-'0'),(c&gt;=0 &amp;&amp; c &lt;=9)) result|=c;
   else if (c=(*s-'A'),(c&gt;=0 &amp;&amp; c &lt;=5)) result|=(c+10);
   else if (c=(*s-'a'),(c&gt;=0 &amp;&amp; c &lt;=5)) result|=(c+10);
   else break;
   ++s;
  }
 }
 return result;
}
</code></pre>

<p>example:</p>

<pre><code> printf(""%08x\n"",foo(""0xff""));
</code></pre>
",0
10746471,10746450,2,"<pre><code>const char *str = ""0xFF"";
uint32_t value;
if (1 == sscanf(str, ""0x%""SCNx32, &amp;value)) {
    // value now contains the value in the string--decimal 255, in this case.
}
</code></pre>
",2
10747006,10746450,5,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;

int main(void) {
    const char *hexValue = ""0xFF"";
    char *p;
    uint32_t uv=0;
    uv=strtoul(hexValue, &amp;p, 16);
    printf(""%u\n"", uv);
    return 0;
}
</code></pre>
",0
10743666,10743619,5,"<p>Maybe your ""long double"" is actually the same as a double (8 bytes), and if you're on a 32bit processor the alignment is 4-byte.</p>

<p>4+4+4+4+8 = 24</p>

<p>What is <code>sizeof(long double)</code>?</p>

<p><strong>EDIT:</strong></p>

<p>I used GCC's <code>__builtin_offset_of()</code> and <code>__alignof__</code> to investigate.  The actual answer that explains the size of the struct is:</p>

<p>4+4+4+4+12 = 28</p>

<p><code>sizeof(long double)</code> is 12.</p>

<p>No padding is necessary because <code>__alignof__(long double)</code> is 4 and.  Interestingly, <code>__alignof__(double)</code> is 8.</p>
",5
10744254,10743619,1,"<p>On a 64 bit system sizes are
char - 1 byte(its not 4 bytes)
int - 4 bytes
long double - 12 bytes</p>

<p>so total is 1+4+4+4+12+padding = 28 bytes!!</p>
",1
10744477,10743619,1,"<p>According to <a href=""http://en.wikipedia.org/wiki/Data_structure_alignment"" rel=""nofollow"">this</a>, long doubles in gcc 32-bit mode (using <code>gcc -m32</code> or with a gcc that was built to produce 32-bit output, regardless of what your platform actually is) are only 4-byte aligned. Might be good to consult the gcc manual to verify that, though.</p>
",0
10745097,10743619,0,"<p>That seems right to me.  A field immediately following p would be 4-byte aligned, so there's no need for padding at the end of the structure.</p>

<p>4+4+4+4+12=28</p>

<p>On my system, the output is 32, but on my system, sizeof(long double) is 16. (x86_64, LLVM3).</p>
",0
10745112,10743619,0,"<p>The 28 <code>sizeof</code> output is of course correct = 1 byte for char, 3 bytes padding, 3 x 4 int and 12 bytes for long double (96 bits size but 80 bit precision), which makes in total 28 bytes.</p>

<p>Remember that even tho you compile on x86-64 machine, you probably compile for x86-32 machine using mingw32 and that makes a difference.</p>

<p>Mingw32 uses 4 byte allignement for <code>long double</code>. </p>
",0
10746677,10746622,0,"<p>Read up on <a href=""http://en.wikipedia.org/wiki/Row-major_order"" rel=""nofollow"">Row Major Order</a></p>

<p>Yeah, that didn't help at all, I was thinking C was column major for a second there I think. (forgetting what all the stuff meant)</p>
",0
10746731,10746622,1,"<p>Multidimentional arrays in c do not make use of pointers. Although a pointer-to-pointer-to-pointer access might look similar, The actual data may not be contiguous, and there is overhead to store all the addresses. Access of multidimentional arrays in C is a form of syntactic sugar:</p>

<pre><code>char a[5][7][9]
a[d][h][w]  &lt;&lt;==&gt;&gt;  ((char*)a)[((9*7*d)+(9*h)+w] 
</code></pre>

<p>C arrays all share the property that they decay(or automatically turn into pointers to the first element in the array). As a result, </p>

<pre><code>a[1]  (char[7][9])    --decay--&gt;   ((*char)[5][9]) pointer to char array
&amp;a[1] ((*char)[5][9])  no decay
</code></pre>

<p>The two are equivalent, because in the later you explicitly ""decay"" the pointer, whereas it happens automatically in the first.</p>
",4
10746745,10746622,1,"<p>Your assumptions would be true if you had dynamic arrays (i.e. allocated with <code>malloc</code>/<code>calloc</code>).</p>

<p>Static arrays, however, are allocated as contiguous chunk of memory and are simply pointer to the first element. When you write <code>A[X][Y][Z]</code> it is basically equivalent to <code>*(A + X*YSIZE*ZSIZE + Y*SIZE + Z)</code>, not to <code>*(*(*(A+X) + Y) + Z)</code>. This allows for somewhat faster access to the data (you do not need to access intermediate pointers), but requires all the data to be allocated in one chunk and be of regular sizes.</p>

<p><a href=""http://c-faq.com/aryptr/pass2dary.html"" rel=""nofollow"">Here</a> is more info regarding non-interchangeability of static vs. dynamic arrays in C. </p>
",0
10746756,10746622,1,"<p>The variable A is 5 * 2 * 3 ints, allocated together as a block. (I.e., 30 ints).</p>

<p>There are no pointers involved in the declaration `int A[5][2][3];' - the only space set aside is to hold the 30 int values.</p>

<p>When you write an expression using A and subscripts, because you have said there are 3 dimensions, you must provide all 3 in order to specify which int value you are accessing or altering. If you use fewer than 3 subscripts, you are only partially specifying what you are accessing; the convention is that such a reference is taken as a request for the address of the relevant part of the overall space.</p>
",3
10746863,10746622,4,"<p>To properly answer your question, read up on row-major order, which is how multidimensional arrays are stored in C. The <a href=""http://en.wikipedia.org/wiki/Row-major_order"" rel=""nofollow noreferrer"">Wikipedia article</a> is a little too terse, but one of these might be more clear:</p>

<p><a href=""http://webster.cs.ucr.edu/AoA/Windows/HTML/Arraysa2.html"" rel=""nofollow noreferrer"">http://webster.cs.ucr.edu/AoA/Windows/HTML/Arraysa2.html</a>
<a href=""http://archive.gamedev.net/archive/reference/articles/article1697.html"" rel=""nofollow noreferrer"">http://archive.gamedev.net/archive/reference/articles/article1697.html</a>
<a href=""http://www.ibiblio.org/pub/languages/fortran/append-c.html"" rel=""nofollow noreferrer"">http://www.ibiblio.org/pub/languages/fortran/append-c.html</a></p>

<p>There's <a href=""https://stackoverflow.com/questions/7784758/c-c-multidimensional-array-internals"">this SO question</a> also.</p>

<hr>

<p>In direct answer to your points, assuming that you know how row-major storage works:</p>

<p><code>int A[5][2][3]</code> declares a contiguous region of memory that is 5*2*3 ints long: five arrays of two arrays of three ints each. The arrays are stored next to each other in linear memory, so that </p>

<pre><code>&amp;A[0][0][0] == A
&amp;A[0][0][1] == A+1
&amp;A[0][1][0] == A+(1*3)
&amp;A[3][1][2] == A+(3*(2*3))+(1*3)+2
</code></pre>

<p><code>A[1]</code> is technically not a pointer but an array. It's an <code>int [2][3]</code> array. But I find that much less clear to think about than considering <code>A[5][2][3]</code> is a flat region of memory, thirty ints long. </p>

<pre><code>A[0][0][0] is the first integer in that region. 
A[0][0][1] is the second integer. 
A[0][0][2] is the third integer. 
A[0][1][0] is the fourth integer in this flat region. 
A[0][1][1] is the fifth integer. 
And so on until A[1][0][0] is the eleventh integer. 
</code></pre>

<p>Therefore the address of <code>A[1][0][0]</code> is ten integers past <code>A[0][0][0]</code>; <em>ie</em>, <code>&amp;A[1][0][0] - &amp;A[0][0][0] == 10</code>.  Because the C language is very loose about the difference between arrays and pointers, <code>A[1]</code> gets interpreted as if it were an address when you use it in an expression, even though it really means ""the first element in an array of five arrays of two arrays of three integers"" which is in turn ""an array of two arrays of three integers.""</p>

<p>The upshot is that <code>A[1]</code> doesn't <em>store</em> a pointer, it <em>is</em> a pointer. Every memory address from <code>&amp;A[0][0][0]</code> to <code>&amp;A[5][2][3]-1</code> stores an integer in your multidimensional array.</p>

<p>What you're thinking of in points (2) and (3) are <em><a href=""http://archive.gamedev.net/archive/reference/articles/article1697.html#ch8"" rel=""nofollow noreferrer"">arrays of pointers to arrays</a></em>, which are something different. </p>

<p>This is a lot easier to explain with pictures, which is why you should find a proper textbook or article on C arrays. </p>

<p>In general, when learning about pointers and arrays in C, I recommend that you temporarily forget about the language itself and pretend that you are Dennis Ritchie inventing C on a PDP-11 computer with 56kb of flat RAM. Get a big sheet of graph paper, number its cells consecutively, pretend that it represents your RAM and each cell is one byte, and <a href=""https://stackoverflow.com/questions/7062853/c-pointer-assignment/7062888#7062888"">you can work through your pointer math with pencil and paper</a>. </p>

<p>C was invented in that environment and understanding its origins will make the modern langauge much more sensible.</p>

<p>As a side note, when I tried to write this answer, Stack Overflow's markup language repeatedly changed and screwed up the indexes in my array examples above. So if you see any numbers there that seem out of range for their arrays, it's a mistake introduced by the editor.</p>
",4
10747709,10746622,0,"<p>It might be a little weird, but here's my explanation. Imagine you have six distinct people numbered from 1 to 6, and they are lined up accordingly from 1 to 6. If you told that this team (the six people) is divided into two groups, where the first three (1-3) are in group A, and the rest (4-6) are in group B.</p>

<p>[1 2 3] [4 5 6]</p>

<p>Then, if I tell you who is the first one in the TEAM? You would say the first one! But if I ask you who is the first member in GROUP A of THE TEAM? It is the same, the first person!</p>

<p>Also, if I tell you who is the fourth member in the team? You would say the fourth! Then, what if I ask you who is the first member in GROUP B of THE TEAM? It is the same, the fourth one.</p>

<hr>

<p>The same story happens to you; A[1] is a pointer to <strong>beginning</strong> of the big array (The Team), where A[1][0] tells to point to the the <strong>beginning</strong> of the <strong>first inner array</strong> (THE FIRST GROUP) inside the big array (A[1]), which is identical! Then you say, &amp;A[1][0][0], which is like going to ask the <strong>first member</strong> of the <strong>first inner array</strong> which resides in the big array, what is your number? Then, he will replay the same.</p>

<p>What differs is the <strong>type</strong> of the pointers and how they are interpreted, but their <strong>values are identical</strong>. This because arrays stores elements in contiguous way. </p>
",0
12338633,12338617,3,"<p>It depends on the compiler, and probably also the options you give to the compiler when building.</p>

<p>Packing the fields tightly might decrease access performance while gaining storage efficiency, which is why it can change if you e.g. tell the compiler to optimize for speed.</p>

<p>The bitfields can never occupy less than <code>CHAR_BITS</code> bits in memory, since otherwise each <code>struct</code> instance's starting address wouldn't fall on an exact <code>char</code> address, which it must do.</p>

<p>So the first example:</p>

<pre><code>struct employee
{
    char name[20];
    int married :1;
};
</code></pre>

<p>will probably mean <code>sizeof (struct employee)</code> occupies 24 bytes, assuming <code>sizeof (int)</code> is 4 on your system. This would mean that if you added more bitfield members after <code>married</code>, the size wouldn't change until you had added 31 bits of fields.</p>
",2
12338651,12338617,5,"<blockquote>
  <p>How many does married take in memory?</p>
</blockquote>

<p><code>int : 1</code> takes one bit of memory in a storage unit of <code>sizeof(int)</code>. Note, that because <code>int</code> is signed and the bitfield has only one bit, such a bitfield can take only two values: -1 and 0.</p>
",1
12338715,12338617,1,"<p>Choose whichever is easiest to read, and which captures the intention of your coding most accurately. This micro-optimisation talk is completely out of place. It might become important if ever you are in a performance critical innner- inner- loop, but then other techniques impinge like your algorithm, the cache performance of your CPU, loop unrolling, loop pipelining &amp;c.</p>

<p>Just to re-iterate: code for the person who is going to read your code.</p>

<p>You might even like to consider something like:</p>

<pre><code>struct employee
{
    char name[31];
    bool married;
    enum manager_t manager;
    ...
};
</code></pre>

<p>Here the compiler will warn you if you try to assign a <code>bool</code> (say) to an <code>employee::manager</code>.</p>
",0
12339043,12338617,2,"<p>When you use <code>int flage</code> for storing information regarding married manager and children, it MAY <strong>take 2 bytes of memory</strong> for one object, and every time you have <strong>to access</strong> a particular information <strong>you have to perform bitwise operations</strong> on the <code>flage</code> variable. This will thus require some processing.</p>

<p>By using a bitfield, like <code>int married:1;</code> (you better use <code>unsigned int</code>), that means it MAY take just <strong>1 byte of memory</strong>, therefore you MAY save memory (supposing your struct is not padded). As a bonus, you can <strong>access its bits directly</strong>.</p>

<p>So it should be better approach regarding memory and processing.</p>
",6
12258757,12258402,3,"<p>The console device associated with stdin is normally line buffered, so scanf() does not return until a complete line is available.  However the %d conversion specifier only consumes digit characters leaving the <em>newline</em> (and any non digit characters you might type) in the buffer, so the next scanf call returns immediately but does not perform a conversion.</p>

<p>You would also have a problem if you never entered any digit characters and just pressed ""Enter"".</p>

<p>You should do two things:</p>

<ol>
<li>Check the return value of scanf() to check for a valid conversion.</li>
<li>Flush the line buffer of all remaining characters up-to and including the <em>newline</em>.</li>
</ol>

<p>For example:</p>

<pre><code>int scanf_check ;

...

// Accept valid input
do
{
    scanf_check = scanf(""%d"",&amp;c1);

} while( scanf_check != 0 )

while( getchar() != '\n' ) { /* do nothing */ } // Flush the line
</code></pre>

<p>When using %c a slightly different idiom is required; the conversion check is unnecessary since all characters can be read with %c, however if teh input id ""empty"", there will still be a newline, so:</p>

<pre><code>scanf(""%c"", &amp;op);
while( op != '\n' &amp;&amp; getchar() != '\n' ) { /* do nothing */ } // Flush the line
</code></pre>

<p>If op is already <em>newline</em>, short-circuit evaluation of &amp;&amp; will occur and getchar() will not be called, otherwise getchar() is called as before until the end of the input is found.</p>
",0
12258621,12258402,3,"<p>After the first <code>scanf()</code>, there's a newline character left in input buffer which is consumed by the next <code>scanf</code>. So, it doesn't wait for input. </p>

<p>Use <code>getchar()</code> after the 1st call to scanf to consume the newline character. </p>
",1
12258641,12258402,4,"<p>scanf is probably the least user friendly way ever of getting input from users. It works OK (more or less) for fixed format files, but for interactive input I would not touch it with a bargepole.</p>

<p>The first scanf to read the number terminates on the first non-digit and leaves that for the next scanf to read. The first non digit is the newline you very probably entered.</p>

<p>And so that's what you get for op.</p>

<p>Your best bet is probably to use getline to read an entire line of user input on that and use sscanf on that (or strtoul if you want to validate the input a bit).</p>
",0
12798228,12798177,1,"<p>Add forward declacation of <code>node</code>:</p>

<pre><code>struct node;
typedef struct{
  struct node *next;
  struct node *last;
} doubleLink;
</code></pre>

<p>As you use pointers, you don't need to have this type completely defined before the definition of <code>doubleLink</code>.</p>
",0
11103035,11102812,0,"<p>I don't think you can use strok.  You'll need to write your own substring function, but something like this would work:</p>

<pre><code>int position = 0;
int i = 0;

for (int i = 0; i &lt; lengthOfColumnWidths; i++) {
    if (columnWidths[i] &lt;= 0) {
        # Error, column width must be greater than 0.
    }

    char* columnVal = substring(lineOfText, position, position + columnWidths[i]);
    # store columnVal in some final array, e.g. finalArray[i] = columnVal

    position = position + columnWidths[i];
}
</code></pre>

<p>columnWidths is an array of integers where the ith value is width of the ith column.  So for you it'd be:</p>

<pre><code>[4, 5, 1, 2, 2, 1, 4, etc...]
</code></pre>
",5
11103332,11102812,0,"<p>You can use simply sscanf like</p>

<pre><code>char a[100],b[100],c[100],d[100],e[100],f[100],g[100],h[100];
sscanf(""ABCD 1234 EFG56H1.223.445.66 J"",""%s%s%2s%*1s%2s%1s%4s%4s%4s"",a,b,c,d,e,f,g,h);
</code></pre>
",0
11569786,11569217,3,"<p>At the line level you should after single read of a pixel do <code>n</code> writes of it. This is done by adding another inner loop. That copied pixel resides at <code>triple</code> var during the operation.</p>

<p>At the file level you should repeatedly process single line, reading and writing it multiple times. </p>

<p>If your input file is on the disk, it should support rewinding. So you can read the line, write it (duplicating pixels inside, as shown above), then rewind the file to the start of the line, read the line again, write it, etc. </p>

<p>Try to store the file position with <code>ftell</code> before reading the line, and rewind the file position to this point with <code>fseek</code> each time you need to process it.</p>
",1
11810539,11810525,1,"<p>That is because you are checking for a value past the end of the array boundary, testing memory with an indeterminate value.</p>

<p>Your array is defined as</p>

<pre><code>unsigned int input[1000];
</code></pre>

<p>The statement</p>

<pre><code>if(input[j]==1)
</code></pre>

<p>when j is 10001 tests memory <em>way</em> past the end of the array boundary.  The value of that memory is undefined and in reality depends on many factors.  It is very improbable that the value of that memory address will be 1 (in fact, if memory is truly randomly initialized, the chance is 1 in 2^32).</p>
",1
11811336,11810525,0,"<p>I will answer your question based your comment to Eric J's answer:</p>

<pre><code>J.no u got it wrong by i/p 10001 i mean for input[0]=1,input[1]=0 and so on... so it only occupies 5 array spaces
</code></pre>

<p>The gist of the answer is that the first input you are entering as 1 which causes the condition to succeed first time. Later on in each iteration, you keep changing the values of  your input array which causes subsequent iterations to enter into the condition. </p>

<p>As you mentioned your input is </p>

<pre><code>input[0] = 1
input[1] = 0
input[2] = 0
input[3] = 0
input[4] = 1
</code></pre>

<p>Now, see the behavior in the below code:</p>

<pre><code>for(j=0;j&lt; build;j++)
{
    if(input[j]==1) /* First for input[0], this condition succeeds */
    {
         if(j==0)
         {
            input[j+1]=1; /* This line changes input[1] to 1, so next time in the loop the condition if(input[j] == 1 will succeed */
            printf(""fddf"");
         }
         else if(j==(build-1)) /* This condition will cause input[4] to be set to 1 and will cause if(input[j] == 1) to succeed for the last iteration of the loop */
         {
           input[j-1]=1;

           printf(""Gfgf"");
         }
        else /** This condition will cause input[2] &amp; input[3] to be set to 1 and will again cause if(input[j] == 1) to succeed in successive loop iterations **/
        {
           input[j+1]=1;
           input[j-1]=1;
           printf(""awGfgf"");
        }
    }
  }
</code></pre>
",0
11538424,11538336,5,"<pre><code>while(scanf(""%d"",&amp;coins))
</code></pre>

<p>If you send CTRL+Z to your programme, <code>scanf</code> returns <code>EOF</code>, which is a negative number and not 0, so the contition evaluates to true and you're in an infinite loop. Test</p>

<pre><code>while(scanf(""%d"",&amp;coins) &gt; 0)
</code></pre>
",1
19323913,19323806,1,"<pre><code>unsigned int a = *(unsigned int*)str;
</code></pre>

<p>This initialization is not correct and invokes undefined behavior. It violates C aliasing rules an potentially violates processor alignment.</p>
",0
19323920,19323806,1,"<p>Both are correct in a way:</p>

<ul>
<li><p>Your first solution copies in native byte order (i.e. the byte order the CPU uses) and thus may give different results depending on the type of CPU.</p></li>
<li><p>Your second solution copies in big endian byte order (i.e. most significant byte at lowest address) no matter what the CPU uses. It will yield the same value on all types of CPUs. </p></li>
</ul>

<p>What is correct depends on how the original data (array of char) is meant to be interpreted.<br>
E.g. Java code (class files) always use big endian byte order (no matter what the CPU is using). So if you want to read <code>int</code>s from a Java class file you have to use the second way. In other cases you might want to use the CPU dependent way (I think Matlab writes <code>int</code>s in native byte order into files, c.f. <a href=""https://stackoverflow.com/questions/7738225/how-to-read-binary-file-created-by-c-matlab-using-java/7744937#7744937"">this question</a>).</p>
",4
19323921,19323806,15,"<p>It's an <a href=""http://en.wikipedia.org/wiki/Endianness"" rel=""noreferrer"">endianness</a> issue. When you interpret the <code>char*</code> as an <code>int*</code> the first byte of the string becomes the least significant byte of the integer (because you ran this code on x86 which is little endian), while with the manual conversion the first byte becomes the most significant.</p>

<p>To put this into pictures, this is the source array:</p>

<pre><code>   a      b      c      \0
+------+------+------+------+
| 0x61 | 0x62 | 0x63 | 0x00 |  &lt;---- bytes in memory
+------+------+------+------+
</code></pre>

<p>When these bytes are interpreted as an integer in a little endian architecture the result is <code>0x00636261</code>, which is decimal 6513249. On the other hand, placing each byte manually yields <code>0x61626300</code> -- decimal 1633837824.</p>

<p>Of course treating a <code>char*</code> as an <code>int*</code> is undefined behavior, so the difference is not important in practice because you are not really allowed to use the first conversion. There is however a way to achieve the same result, which is called <a href=""https://stackoverflow.com/questions/11639947/is-type-punning-through-a-union-unspecified-in-c99-and-has-it-become-specified"">type punning</a>:</p>

<pre><code>union {
    char str[4];
    unsigned int ui;
} u;

strcpy(u.str, ""abc"");
printf(""%u\n"", u.ui);
</code></pre>
",1
19323962,19323806,1,"<p>You said you want to copy byte-by-byte.</p>

<p>That means the the line <code>unsigned int a = *(unsigned int*)str;</code> is not allowed.  However, what you're doing is a fairly common way of reading an array as a different type (such as when you're reading a stream from disk. </p>

<p>It just needs some tweaking:</p>

<pre><code> char * str =""abc"";
int i;
unsigned a;
char * c = (char * )&amp;a;
for(i = 0; i &lt; sizeof(unsigned); i++){
   c[i] = str[i];
}
printf(""%d\n"", a);
</code></pre>

<p>Bear in mind, the data you're reading may not share the same endianness as the machine you're reading from.  This might help:</p>

<pre><code>void 
changeEndian32(void * data)
{
    uint8_t * cp = (uint8_t *) data;
    union 
    {
        uint32_t word;
        uint8_t bytes[4];
    }temp;

    temp.bytes[0] = cp[3];
    temp.bytes[1] = cp[2];
    temp.bytes[2] = cp[1];
    temp.bytes[3] = cp[0];
    *((uint32_t *)data) = temp.word;
}
</code></pre>
",2
19324001,19323806,6,"<p>Neither of the first two is correct.</p>

<p>The first violates aliasing rules and may fail because the address of <code>str</code> is not properly aligned for an <code>unsigned int</code>. To reinterpret the bytes of a string as an <code>unsigned int</code> with the host system byte order, you may copy it with <code>memcpy</code>:</p>

<pre><code>unsigned int a; memcpy(&amp;a, &amp;str, sizeof a);
</code></pre>

<p>(Presuming the size of an <code>unsigned int</code> and the size of <code>str</code> are the same.)</p>

<p>The second may fail with integer overflow because <code>str[0]</code> is promoted to an <code>int</code>, so <code>str[0]&lt;&lt;24</code> has type <code>int</code>, but the value required by the shift may be larger than is representable in an <code>int</code>. To remedy this, use:</p>

<pre><code>unsigned int b = (unsigned int) str[0] &lt;&lt; 24 | ¡­;
</code></pre>

<p>This second method interprets the bytes from <code>str</code> in big-endian order, regardless of the order of bytes in an <code>unsigned int</code> in the host system.</p>
",0
11516337,11516303,0,"<p>Put in a print() (or run in the debugger) and see if the ""for()"" loop is really terminating where you think it is :)</p>

<p>You absolutely need to change your code to check for:</p>

<ol>
<li><p>Error in ""fopen()""</p></li>
<li><p>Error in ""fscanf()""</p></li>
</ol>
",0
11516350,11516303,-2,"<p><code>fscanf</code> returns the number of of items successfully read, I think you want to test if <code>number == 0</code> to break from the loop.</p>
",3
11516361,11516303,2,"<p>fscanf can return EOF (-1?) if the input is bad - lets assume that isn't your problem.
What is stopping x reading all of the numbers? Looks like you mean to stop the loop when number == 0.</p>
",0
12331361,12331328,5,"<p>The inner <code>printf</code> outputs 3 then 4 spaces and returns the number of characters, which is 7, and the outer <code>printf</code> is printing that result.</p>
",0
12331370,12331328,9,"<p><code>printf(""%*c"", n, c)</code> prints the character <code>c</code>, <code>n</code> times. So the code prints 3 spaces followed by 4 spaces, and <code>printf</code> returns the number of characters printed, which is obviously 3 + 4, completing the problem.</p>
",1
18431627,18422002,0,"<p>What I actually went with was the following:</p>

<p>I created a base Vector2D class, with the following layout:</p>

<pre><code>struct Vector2D_Base;
typedef struct Vector2D_Base{
    M_double (*Vector2D_Get_X)(struct Vector2D_Base* vec);
    M_double (*Vector2D_Get_Y)(struct Vector2D_Base* vec);
} Vector2D;
</code></pre>

<p>As you can see, this allows the generic vector functions to call these to get the derived classes' x and y values converted to doubles, which prevents the generic function from having to worry about difference between sizes of types like char and float. Then each derived class:</p>

<pre><code>#define DEFINE_VECTOR2D(type, name)\
typedef struct{\
Vector2D_Base vec_base;\
type x, y;\
} Vector2D##name\
</code></pre>
",0
11853128,11853078,3,"<blockquote>
<pre><code>printf(""&gt;=85:%d, morethan85"");
                           ^
</code></pre>
</blockquote>

<p>You're printing plain strings. Try this instead:</p>

<pre><code>printf(""&gt;=85:%d"", morethan85);
               ^
</code></pre>

<hr>

<p>Also, strictly speaking, passing fewer arguments than required by the format string is undefined behavior.</p>
",1
11853222,11853078,0,"<p>Whoah. Lots of stuff to comment here.</p>

<ol>
<li><p>First of all, ""true"" is not valid C. You can define a macro or constant named TRUE and set it to ""1"" - or simply use 1.</p></li>
<li><p>If you are looping through something until it breaks, use while() and not for().</p></li>
<li><p>Finally, the reason your code isn't working is because you have you have added the quote symbol after the name of your variables in your printf() functions.</p></li>
</ol>

<p>Here is a working version of your code:</p>

<pre><code>#include &lt;stdio.h&gt;

int main() {
    int mark;
    int morethan85 = 0;
    int between60and84 = 0;
    int lessthan60 = 0;

    while (1) {
        scanf(""%d"", &amp;mark);
        if (mark != 0) {
            if (mark &gt;= 85)
                morethan85 ++;
            else if (mark &lt; 85 &amp;&amp; mark &gt;= 60)
                between60and84 ++;
            else
                lessthan60 ++;
        } else
            break;
    }

    printf(""&gt;=85:%d\n"", morethan85);
    printf(""60-84:%d\n"", between60and84);
    printf(""&lt;60:%d\n"", lessthan60);

}
</code></pre>
",3
11847589,11847558,2,"<p>You need to update your <code>index</code> inside the <code>if</code>-statement.</p>

<pre><code>if (abs(array[i]) &lt; absmallest)
    absmallest = array[i];
index = i;
</code></pre>

<p>should be</p>

<pre><code>if (abs(array[i]) &lt; absmallest)
{
    absmallest = array[i];
    index = i;
}
</code></pre>

<p>Otherwise, you update your <code>index</code> on each loop.</p>

<hr>

<p><strong>EDIT:</strong> As @amit noted, you also need to store the absolute value, not the real one. In other words</p>

<pre><code>absmallest = array[i];
</code></pre>

<p>should be</p>

<pre><code>absmallest = abs( array[i] );
</code></pre>

<p>And the same for the initialization of <code>absmallest</code></p>

<pre><code>absmallest = abs( array[0] );
</code></pre>
",2
11847607,11847558,0,"<p>In this loop:</p>

<pre><code>for (i = 0; i &lt; 10; i++) {
    if (abs(array[i]) &lt; absmallest)
        absmallest = array[i];
    index = i;
}
</code></pre>

<p>You set the variable <code>index</code> <em>every</em> time. Which means that when the loop if over <code>index</code> will be the index to the last element.</p>

<p>Also, you should probably initialize <code>absmallest</code> to <code>abs(array[0])</code> instead.</p>
",0
11847621,11847558,3,"<p>two issues:</p>

<p><strong>(1)</strong></p>

<pre><code>    if (abs(array[i]) &lt; absmallest)
        absmallest = array[i];
    index = i;
</code></pre>

<p>The <code>index = i</code> is out of the scope of the if statement - so it happens every iteration, and does not depends on the result of your condition.</p>

<p><strong>(2)</strong> 
<br><code>absmallest = array[0];</code> should be with <code>abs()</code> as well (what happens if <code>array[0] = -5</code>)?
Same goes for the assignment of <code>abssmallest</code> in the for loop (<code>absmallest = array[i];</code> should be <code>absmallest = abs(array[i]);</code>)</p>
",2
11847670,11847558,0,"<pre><code>if (abs(array[i]) &lt; absmallest)
    absmallest = array[i];
index = i;
</code></pre>

<p>should become</p>

<pre><code>if (abs(array[i]) &lt; absmallest) {
    absmallest = array[i];
    index = i;
}
</code></pre>
",0
11847727,11847558,0,"<pre><code>for (i = 0; i &lt; 10; i++) {
     if (abs(array[i]) &lt; absmallest)
         absmallest = array[index = i];
}
</code></pre>
",0
11868907,11868826,0,"<p>use:</p>

<pre><code>int values[static or dynamic allocation dependent]
for (i=0;i&lt;n;i++){
  printf(""Enter number:"");
  scanf(%d, value[i]);
}
</code></pre>

<p>instead of just hardcoding the values for the values array.</p>

<p>Make sure you either dynamically declare the array, or statically make it large enough to accept the number of integers you want, 1,000,000 but thats a ton of memory. No one's going to take that much time to enter that many numbers manually. Probably safe with declaring it at 30 tops.</p>

<p>Or if you're planning to use the ""define elements"" part, you only need to declare the values array to be 6. </p>
",0
11895201,11894454,0,"<p>Edit your init function:</p>

<pre><code>/*init()*/
Student* init(char* name)
{
    Student* currentp = (Student*)malloc(sizeof(Student));
    /* Allocate memory also for the student name */
    currentp-&gt;name = (char *)malloc(strlen(name) * sizeof(char));
    if (!currentp)
    {
        printf(""pointer allocation problem..Ending the program...\n"");
        exit(0);
    }
    //currentp-&gt;name = name;
    strncpy(currentp-&gt;name, name, strlen(name));
    currentp-&gt;nextp = NULL;
    currentp-&gt;scoreHeadp = NULL;

   return currentp;
}
</code></pre>
",0
11894543,11894454,1,"<p>You are using the same <code>char Name[30];</code> for every student.</p>
",7
13405576,13405475,9,"<p>Remember that strings in C are ended by the <strong>null terminator</strong> character, written as <code>\0</code>. If you have a well-formed string stored in your pointer variable, you can therefore determine the length by searching for this character:</p>

<pre><code>char *x = ""hello""; // automatically appends a null terminator
int len = 0;
while (x[len] != '\0') {
    len++;
}
</code></pre>

<p>If your variables are uninitialized or otherwise not well-formed (e.g., by being <code>NULL</code>) you obviously cannot take this approach; however, most functions are generally written under the assumption that the strings <em>are</em> well-formed, because this leads to faster code.</p>

<p>If you wish to initialize a pointer, you have three options: <code>NULL</code>, a valid address (e.g., <code>char *x = &amp;someCharVar</code>), or a string constant (e.g., <code>char *x = ""hello""</code>). Note that if you use a string constant, it is <strong>illegal</strong> for you to write into that pointer unless you re-assign to it with the address of a non-constant string.</p>

<pre><code>// Get enough space for 24 characters plus null terminator
char *myString = (char*) malloc(25 * sizeof(char));
strcpy(myString, ""some text""); // fill the new memory
fgets(myString, 25, stdin); // fill with keyboard input
</code></pre>

<p>Note that <code>sizeof(char)</code> is unnecessary here, since a <code>char</code> is always defined to be exactly 1 byte. However, it's a good habit to get into for when you're using other data types, and it helps make your code self-documenting by making your intentions very clear.</p>
",3
13406216,13405475,3,"<p>If you're initializing an array of <code>char</code> with a string literal, you don't need to specify the size:</p>

<pre><code>char str[] = ""This is a test"";
</code></pre>

<p>This will create <code>str</code> as a 15-element array of <code>char</code> (the size is taken from the length of the initiliazer, including the 0 terminator) and copy the contents of the string literal to it.  </p>

<p>A string literal is an <em>array expression</em> of type ""N-element array of <code>char</code>"" (<code>const char</code> in C++).  Except when it is being used to initialize an array in a declaration (such as above) or is the operand of the <code>sizeof</code> or unary <code>&amp;</code> operators, an expression of type ""array of <code>T</code>"" will be converted to an expression of type ""pointer to <code>T</code>"", and the value of the expression will be the address of the first element of the array.  </p>

<p>If you write</p>

<pre><code>const char *str = ""This is a test"";
</code></pre>

<p>the expression ""This is a test"" is converted from type ""15-element array of <code>char</code>"" to ""pointer to <code>char</code>"", and the value of the expression is the address of the first character, which is written to the variable <code>str</code>.  </p>

<p>The behavior on attempting to modify the contents of a string literal is <em>undefined</em>; some platforms store string literals in read-only memory, some do not.  Some map multiple occurrences of the same string literal to a single instance, others don't.  It's best to always treat a string literal as unmodifiable, which is why I declared <code>str</code> as <code>const char *</code> instead of just <code>char *</code>.</p>

<p>To get the <em>length</em> of a string, use <code>strlen</code>:</p>

<pre><code>char str[] = ""This is a test""; // or const char *str = ""This is a test"";
size_t len = strlen(str);      // or strlen(""This is a test"");
</code></pre>

<p>This will return the number of characters in the string up to (but not including) the 0 terminator; <code>strlen(""This is a test"")</code> will return 14.  </p>

<p>To get the size of the buffer containing the string, you would use the <code>sizeof</code> operator:</p>

<pre><code>char str[] = ""This is a test"";
size_t len = sizeof str;       // or sizeof ""This is a test""
</code></pre>

<p>Note that this <em>won't</em> give you the size of the buffer if you declared <code>str</code> as a pointer, such as</p>

<pre><code>const char *str = ""This is a test"";
</code></pre>

<p>In that case, <code>sizeof str;</code> only gives you the size of a <code>char *</code>, not the string it points to.  </p>
",0
12869098,12869081,3,"<p>And you should refer to the correct member in the struct:</p>

<pre><code>if (table[0].func == NO_FUNC)
</code></pre>
",1
12869120,12869081,2,"<p><code>table[0]</code> is of an unnamed <code>struct</code> type, and <code>NO_FUNC</code> has type <code>int (*)(int)</code>.  These two types can't be compared.</p>

<p>Instead, you could use:</p>

<pre><code>if (table[0].func == NO_FUNC)
</code></pre>
",0
12258268,12258215,3,"<p>The line <code>if(fahr = celsius)</code> doesn't do what you think. It <em>assigns</em> <code>celsius</code> to <code>fahr</code> and checks whether the result is non-zero.</p>

<p>What you meant is:</p>

<pre><code>if (fahr == celsius)
//      ^^^^
</code></pre>

<p>This will compare the two values for equality.</p>

<hr>

<p>As a completely unrelated point of accuracy, you should write the conversion like this:</p>

<pre><code>int celsius = (5 * (fahr - 32)) / 9;
</code></pre>

<p>This will not require any expensive conversion to floating point or rounding errors on the conversion back to integer, and it will delay the division as long as possible. Note of course that your Celsius value will only be approximate to the nearest integer towards zero.</p>
",5
12258277,12258215,0,"<p>This is assignment</p>

<pre><code>if(fahr = celsius)
</code></pre>

<p>this is comparison</p>

<pre><code>if(fahr == celsius)
</code></pre>
",0
12784680,12784642,2,"<p>You should not overwrite a constant with user input. Replace <code>char str[] = """"</code> with <code>char * str = malloc(&lt;enough bytes for any possible input)</code> or even learn about safer APIs.</p>
",0
12784735,12784642,6,"<p>The array <code>str</code> can only hold a single <code>char</code> given its initialisation. The call to <code>scanf()</code> will be overwriting the bounds the <code>str</code> causing undefined behaviour, in this case corrupting the stack. You need to decide how large the <code>str</code> array should be and limit the number of characters read to prevent buffer overrun.</p>

<p>To use <code>scanf()</code> you specify the maximum number of characters to read:</p>

<pre><code>char str[1024];
if (1 == scanf(""%1023[^\n]"", str)) /* Check return value to ensure */
{                                  /* 'str' populated.             */
}                                  /* Specify one less than 'str'  */
                                   /* size to leave space for null.*/
</code></pre>

<p>You could also use <a href=""http://en.cppreference.com/w/c/io/fgets"" rel=""noreferrer""><code>fgets()</code></a> but would need to remove the new-line character afterwards.</p>
",0
12784748,12784642,1,"<p>You're only allocating one byte to store the input.  The line</p>

<pre><code>char str[] = """";
</code></pre>

<p>Allocates zero bytes for the string contents and one byte for its null terminator.  Instead, do something like</p>

<pre><code>char str[100];
</code></pre>

<p>Or whatever the maximum input length will be.</p>
",0
17820153,17820018,2,"<p>Multiple things are wrong:</p>

<pre><code>unsigned char**** buff
</code></pre>

<p><strong>What is this, if not wrong?</strong> (Well, OK, not technically, but stylistically anyway...)</p>

<pre><code>(SQLCHAR*)malloc(256);
</code></pre>

<p>isn't any better either, since <a href=""https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc/605858#605858"">you must not cast the return value of <code>malloc()</code> in C</a>.</p>

<p>The third mistake is that you don't have a 3D array. You have a pointer-to-pointer-to-pointer. Ewww. Ugly. Why not allocate a true 3D array instead?</p>

<pre><code>size_t xsize, ysize, zsize; // initialize these!
unsigned char (*arr)[ysize][zsize] = malloc(sizeof(*arr) * xsize);
</code></pre>

<p>Then all you need to do in order to free it is:</p>

<pre><code>free(arr);
</code></pre>

<p><strong>Honestly, isn't this way better?</strong></p>
",8
17820184,17820018,1,"<p>Your code looks pretty buggy. For starters you are calling <code>someFunction(&amp;buff1, &amp;r, &amp;c)</code> while that function expects <code>int</code>s and not <code>int *</code>s. Later you dereference nR and nC and they aren't pointers.</p>

<p>I guess you should be getting some nasty warnings when compiling.</p>
",0
17822560,17820018,2,"<p>I try you code in this way,and it works good:</p>

<pre><code>#include ""stdio.h""
#include ""stdlib.h""

int  someFunction (unsigned char**** buff, int *nR, int *nC)
{
  int i,j;
  *buff = (unsigned char ***)malloc(*nR * sizeof(char**));
  for(i = 0; i &lt; *nR; ++i)
  {
    (*buff)[i] = (unsigned char**)malloc(*nC * sizeof(char**));
    for(j = 0; j &lt; *nC; ++j)
    {
      (*buff)[i][j] = (unsigned char*)malloc(256);

      (*buff)[i][j][0] ='1';
    }
  }
}


int main()
{
unsigned char ***buff1;
int r = 3, c= 2,i,j;
someFunction(&amp;buff1, &amp;r, &amp;c);
for( i = 0; i &lt; r; ++i)
{
  for(j = 0; j &lt; c; ++j)
  {
        printf(""        %c"",buff1[i][j][0]);
    free(buff1[i][j]);
  }
  free(buff1[i]);
}
free(buff1);
}
</code></pre>

<p>So, maybe the mistake is not happening in the code you are showing to us.</p>
",0
12876785,12876761,1,"<p>You can't use a format string like this: <code>strcmp(buf,""adc %d %d"")</code> to test for a certain kind of input. Your <code>strcmp</code> will only signal string equality if the use inputs literally: <code>""adc %d %d""</code>, <em>not</em> <code>adc</code> followed by two integers.</p>

<p>You'll need to parse the input string manually, by tokenizing around whitespace characters, checking the first token with <code>strcmp</code> against e.g. <code>adc</code>, then parsing the numbers separately.</p>

<p>I don't notice any <code>case</code> statements in your <code>switch</code>. It looks like you can just remove the <code>switch</code>, since you're not using <code>choice</code> anywhere.</p>

<p>Also, don't use <code>gets</code>, use <code>fgets</code> instead.</p>
",3
12837110,12837063,1,"<p>Actually if the code is long then it's not good programming practice as that code will not be as readable.</p>

<p>so it's better to use if else syntax to make your code readable</p>
",0
12837131,12837063,1,"<p>It makes no sense to be concerned about the size of the sources at the point of sacrificing readability, especially since sources are extremely small compared to almost any kind of other data that our computers usually process/store (e.g. the bzipped sourced of the Whole Firefox are 85 MB - smaller than any medium-length video). Also, omitting a newline won't change the compilation times of a millisecond.</p>

<p>So, if you prefer one-line <code>if</code>s for your own stylistic reasons it's fine (although it's often frowned upon), but for saving a few bytes it makes no sense at all.</p>
",6
12874454,12874257,2,"<p>This happens when your program has been <code>kill -9</code>'d from some other program or script.</p>

<p>One common mysterious process killer is the Linux <a href=""http://linux-mm.org/OOM_Killer"" rel=""nofollow"">out-of-memory (OOM) killer</a>. Under Linux when a program allocates too much memory you won't get a NULL back from <code>malloc()</code>, or an exception from the <code>new</code> operator. Instead your program will likely be <code>kill -9</code>'d by the kernel.</p>

<h3>OOM Killer</h3>

<p>Linux has a strange (but sensible) policy whereby it allows processes to allocate as much memory as they want, even if there's not enough memory to satisfy the requests. This is because many programs will optimistically allocate huge gobs of memory but not actually <em>use</em> all of that memory. Linux allows programs to allocate whatever they want, and only when they try to access that memory does Linux check that the memory exists.</p>

<p>If it doesn't, the kernel's in a bind because it has told the program that memory was available (i.e. <code>malloc()</code> returned a valid pointer earlier) and now it's been caught in a lie. There's no good way to signal an error to the program that oops, I made a mistake, I should have returned NULL earlier.</p>

<p>This is where the OOM killer kicks in. The OOM killer is like an airline that's overbooked a flight and now has to convince paying customers not to take that flight. I know you paid, but maybe somebody would be so kind as to take a later flight?</p>

<p>The kernel can't satisfy the memory request, so what can it do? It can say ""sorry, I lied"" and kill the current program. Or it can kill other programs to free up memory until there's enough free for the current program. The OOM killer tries to make the best of a bad situation. It tries to figure out what the best programs to kill are so as to minimize the damage. If there's some newly-started program that's chewing up huge gobs of memory, that's who it will kill. Which makes sense. There's a good chance that program has a bug in it causing it to allocate way too much memory.</p>

<p>Or consider another possibility: your program is totally innocent, but some <em>other</em> program is misbehaving and the OOM killer has decided to kill <em>yours</em>.</p>

<p>I have no idea if this is what's happening. But when I hear ""my program is being killed for no reason"" I think <a href=""http://linux-mm.org/OOM_Killer"" rel=""nofollow"">OOM killer</a>, because I've been burned by this bastard before.</p>
",1
12874493,12874257,0,"<p>""Killed"" is the message printed when your program received <code>SIGKILL</code>. <code>SIGKILL</code> is not catchable or maskable, meaning that it is guaranteed to kill your program (<code>SIGKILL</code> usually is signal 9, leading to the common idiom <code>kill -9 &lt;pid&gt;</code> to kill a process).</p>

<p>If you're not triggering <code>kill -9</code> somewhere, then the likely culprit is the OOM killer. @JohnKugelman gives a good overview of the killer.</p>

<p>You can determine if the OOM killer killed your process by looking in <code>/var/log/messages</code>:</p>

<pre><code>grep -i 'killed process' /var/log/messages
</code></pre>
",0
15869638,15869618,3,"<p>To compare it as a string, try:</p>

<pre><code>if (strcmp(argv[2], ""N"") != 0 &amp;&amp; strcmp(argv[2], ""A"") != 0)
// can be reduced to:
if (strcmp(argv[2], ""N"") &amp;&amp; strcmp(argv[2], ""A""))
</code></pre>

<p>Or you can also compare it as a single character:</p>

<pre><code>if (argv[2][0] != 'N' &amp;&amp; argv[2][0] != 'A')
</code></pre>

<p>But that's probably not as versatile.</p>
",4
12798632,12798611,15,"<p>Use <code>0xff</code> as your mask to remove all but 8 bits of a number:</p>

<pre><code>unsigned int number = 0xABCDEF
unsigned int ef = number &amp; 0xff;
unsigned int cd = (number&gt;&gt;8) &amp; 0xff;
unsigned int ab = (number&gt;&gt;16) &amp; 0xff;
</code></pre>
",0
12798639,12798611,0,"<p>The mask to use would be <code>0xFF</code>, not <code>0x11</code>. Apart of this, you are right.</p>
",0
12798662,12798611,4,"<pre><code>unsigned int number = 0xABCDEF
unsigned int ef = number &amp; 0xff;
unsigned int cd = (number &gt;&gt; 8) &amp; 0xff;
unsigned int ab = (number &gt;&gt; 16) &amp; 0xff;
</code></pre>

<p>Instead of the bitwise and (<code>&amp;</code>) operation, you might intead want <code>ef</code>, <code>cd</code>, <code>ab</code> to be <code>unsigned char</code> types, depending on the rest of your code and how you're working with these variables. In which case you cast to <code>unsigned char</code>:</p>

<pre><code>unsigned int number = 0xABCDEF
unsigned char ef = (unsigned char) number;
unsigned char cd = (unsigned char) (number &gt;&gt; 8);
unsigned char ab = (unsigned char) (number &gt;&gt; 16);
</code></pre>
",0
13768208,13768151,1,"<p>What gave you the idea that scanf would fill in a character argument with EOF? </p>

<p>The scanf function hit EOF and it fails to do the conversion and it returns. The value of ch is whatever random value was on the stack when you declared the variable.</p>
",0
13768214,13768151,1,"<p>EOF is intended to be distinguishable from any value that could be contained in the file being read.</p>

<p>As such, when you're reading from a file, and might receive an EOF, you should <em>not</em> use a <code>char</code> to hold that value. You should use an <code>int</code>, and only convert the result to <code>char</code> <em>after</em> you've verified that what you received was <em>not</em> an EOF. To get correct results, try something like this:</p>

<pre><code>int char;
ch = getchar();
printf(""%d"", ch);
</code></pre>

<p>For your second example, when you read data with <code>scanf</code>, you find out how much (if any) data is read by checking its return value. If it encountered the end of a file, it will simply stop trying to convert input, and you'll find out how many fields were successfully converted by checking its return value. It won't try to convert EOF into a variable.</p>
",0
13768226,13768151,2,"<p>You haven't checked the return value from scanf. I'll bet it was zero: no patterns matched.</p>

<p>The value ""126"" is the uninitialized value of <code>ch</code>.</p>

<hr>

<p>Edit: on closer inspection of <a href=""http://www.manpagez.com/man/3/scanf/"" rel=""nofollow"">the man page</a> the return value should be <code>EOF</code>. Note that that's the <em>return</em> value, not the value written to <code>ch</code>.</p>
",4
13768233,13768151,1,"<p>You should check the return code of scanf, it should return EOF. In this case your char is not affected, and because uninitialized might be 126</p>
",0
13494567,13494445,1,"<p>Let's say we have mat4_t type and mat4_add function defined.</p>

<pre><code>typedef ... mat4_t;
</code></pre>

<p>With ""by copy"" approach will look like this:</p>

<pre><code>mat4_t mat4_add(mat4_t m1, mat4_t m2);
mat4_t m1, m2, m3;
m3 = mat4_add(m1, m2);
</code></pre>

<p>Function mat4_add takes 2 arguments and returns new matrix (by copy).</p>

<p>With ""by reference"" it would be:</p>

<pre><code>void mat4_add(mat4_t *sum, const mat4_t *m1, const mat4_t *m2);
mat4_t m1, m2, m3;
mat4_add(&amp;m3, &amp;m1, &amp;m2);
</code></pre>

<p>Function receives pointers to both source matrices (m1, m2) and pointer to memory where it should store matrices sum.</p>

<hr>

<p>With first approach:
Both m1 and m2 are copied to the function stack, thus stack grows by 2*sizeof(mat4_t) and matrices data is copied. Later, function stack grows by another sizeof(mat4_t) to store calculation result. That result is copied once again with return statement when value is assigned from function return value.</p>

<p>On the other hand with pointers ""by reference"", coping is not necessary. That approach is faster (don't need copies) and more memory efficient.</p>

<p>Also, there is no such thing like copy by reference in C. Everything is passed by value.
<a href=""https://stackoverflow.com/questions/12953496/what-happens-during-pass-by-reference-in-c/12953708#12953708"">what happens during pass by reference in C?</a> </p>
",0
15841735,15841696,1,"<p>The format specifier <code>%s</code> tells <code>printf</code> to expect a pointer to a null-terminated char array. Which is what <code>name</code> and <code>ptr</code> are.</p>

<p><code>*name</code> and <code>*ptr</code> are not. If you dereference them, you'll get back a single <code>char</code>, which is basically lying to <code>printf</code> - resulting in undefined behavior.</p>
",0
15841740,15841696,24,"<p>When you print <strong>string</strong> we need starting address of string. </p>

<pre><code>printf(""%s\n"", ptr);
                ^ address with %s   
</code></pre>

<p>it prints chars till <code>\0</code> nul encounter.</p>

<p>Whereas to print <strong>chat</strong> int .. we need <strong>value variable</strong>: </p>

<pre><code>printf(""%c\n"", *ptr);
               ^ * with %c print first char
</code></pre>

<p>Where as in <strong><code>scanf()</code> a string</strong> you always need to give address: </p>

<pre><code>scanf(""%s"", ptr);
            ^ string address
</code></pre>

<p>Also for int <strong><code>scanf()</code> a char</strong> </p>

<pre><code>scanf(""%c"", ptr);
            ^ read at first location char address 
</code></pre>

<p><strong>Note:</strong> <code>Scanf()</code> need address with <code>%c</code> to store a scanned value in memory. </p>

<p>Be <em>careful</em> your <code>ptr</code> <em>points to a constant string so you can't use in scanf</em>.</p>

<blockquote>
  <p>Why <strong>Segmentation fault</strong> with following code ?  </p>

<pre><code>    printf(""%s\n"", *ptr);
</code></pre>
</blockquote>

<p>When you do like this, because of  <code>%s</code> printf interprets <code>*ptr</code> as an address, but it's actually not an address and if you treat it as address it points to some location that is read protected for your program(process) So it causes a segmentation fault.</p>

<p>Your <code>ptr</code> via <code>name</code> points to some constant string  in memory (""Jordan"") as in below diagram: </p>

<pre><code>name 2002
©°©¤©¤©¤©¤©¤©Ð©¤©¤©¤©¤©¤©Ð©¤©¤©¤©¤©¤©Ð©¤©¤©¤©¤©¤©Ð©¤©¤©¤©¤©¤©Ð©¤©¤©¤©¤©¤©Ð©¤©¤©¤©¤©¤©Ð©¤©¤©¤©¤©¤©Ð©¤©¤©¤©¤©¤©Ð©¤©¤©¤©¤©¤©´
©¦ 'J' ©¦ 'o' ©¦ 'r' ©¦ 'd' ©¦ 'a' ©¦ 'n' ©¦'\0' ©¦ ........
©¸©¤©¤©¤©¤©¤©Ø©¤©¤©¤©¤©¤©Ø©¤©¤©¤©¤©¤©Ø©¤©¤©¤©¤©¤©Ø©¤©¤©¤©¤©¤©Ø©¤©¤©¤©¤©¤©Ø©¤©¤©¤©¤©¤©Ø©¤©¤©¤©¤©¤©Ø©¤©¤©¤©¤©¤©Ø©¤©¤©¤©¤©¤©¼
  ^
  |
 ptr = name 

 ==&gt; ptr = 2002
     *ptr = 'J'
</code></pre>

<p>In <code>printf(""%s\n"", *ptr);</code> the <code>*ptr = 'J'</code> and ASCII  value of char 'J' is <code>74</code> but <code>74</code> address is not under your process control and you are trying to read from that memory location and its a  memory violation and segmentation fault occurs. </p>

<p>If you compile you code containing <code>printf(""%s\n"", *ptr);</code> then with proper option say <code>-Wall</code> with <code>GCC</code> you will get a warning like below: </p>

<p><code>warning: format ¡®%s¡¯ expects argument of type ¡®char *¡¯, but argument 2 has type ¡®int¡¯</code></p>

<p>Says <code>%s</code> need (expects ) an address of type <code>char*</code> but you are putting value </p>

<p>notice: </p>

<pre><code>printf(""%s\n"",   *ptr);
        ^          ^ argument-2
        argument-1 
</code></pre>
",0
15841743,15841696,7,"<p>This is because the <code>%s</code> format specifier in the format string you pass to <code>printf</code> means that the corresponding argument should be a string, not a single character. And in C, a string is a pointer to the beginning of a block of characters that has a null character (byte with a value of 0) at the end.</p>

<p>Basically, this works because you're doing exactly what you're supposed to in order to print a string.</p>
",0
15841753,15841696,0,"<p><code>*ptr</code> is essentially a reference to a single <code>char</code>, not to the string of <code>char</code>'s. due to this <code>char *</code> and <code>char[]</code> are essentially the same thing</p>
",0
15841761,15841696,2,"<p>The <code>%s</code> formatter to printf expects a ""string"", which is really a pointer to a null-terminated array of characters.</p>

<p>That is to say, printf <em>expects</em> you to pass the pointer to it.  When you dereference the pointer, it's taking the letter J, whose value in ascii is 74 (decimal), and tries treating that as a pointer to an array.  That's an area of memory that's inaccessible, so you get the segmentation violation.</p>
",0
15841775,15841696,0,"<p>When you declare char <em>prt = name thats where you are dereferencing it.  the ""</em>"" here isn't part of the variable just a way to show you want what that variable points to.  If you were to put the *prt again in your printf you are doing it twice.  name is an array of characters and *ptr is a dereferenced pointer to those characters.</p>

<p>Hope that explaination helps :-)</p>
",0
15514087,15514068,1,"<p>Think carefully about your buffer. What happens to the buffer when the function call ends? It goes away.</p>

<p>This means that for 1023 out of 1024 calls, your buffer is unitialized and your offsets are pointing into nonsensical data.</p>

<hr>

<p>Basically you need a global variable for the buffer too:</p>

<pre><code>static char buf[BUF_SIZE];
static size_t bufCur = 0;
static size_t bufEnd = 0;

int mygetchar(void)
{
    // ...
}
</code></pre>

<p>(Note that the static is pretty much pointless when your code is all in one file. If you were to pull your mygetchar into a header and implementation file though, you would want to use a static global so as to keep it from being linkable from outside of the same compilation unit.)</p>

<p>(Fun fact: the <code>0</code>s for <code>bufCur</code> and <code>bufEnd</code> actually can be left implicit. For clarity, I would put them, but the <a href=""https://stackoverflow.com/a/60707/567864"">standard dictates</a> that they are to be zero-initialized.</p>

<hr>

<p>As  Jonathan Leffler pointed out, unless you plan on using the buffer elsewhere (and I don't know where that would be), there's no need for a global. You can just use a static variable inside of the function:</p>

<pre><code>void mygetchar(void)
{
    static buf[BUF_SIZE];
    static size_t bufCur = 0;
    static size_t bufEnd = 0;
    // ...
}
</code></pre>
",5
19215239,19215224,1,"<p>The <code>=</code> evaluates to whatever it sets the variable to, so if you do something like<br>
<code>var = 0</code><br>
This evaluates to 0 and if it was in a while loop would break out.  </p>

<p>Also remember <code>NULL</code> is just 0 (though it's not guaranteed) so something returning <code>NULL</code> will have the same effect to break out of a loop. Generally it's a bad idea to use an <code>=</code> as a condition and good compilers will warn you about it.</p>
",10
19215271,19215224,0,"<p>Null is supposed to be zero unless otherwise specified on your system/compiler.  Therefore, the loop terminates.</p>
",0
19215279,19215224,3,"<p>The syntax says:</p>

<pre><code>while (expression) { ... }
</code></pre>

<p>and <code>expression</code> can be a lot.
It can be:</p>

<ul>
<li>a constant: <code>while (1) { ... }</code></li>
<li>the result of a comparison: <code>while (a &lt; b) { ... }</code></li>
<li>some boolean construct: : <code>while (a &lt; b &amp;&amp; c &lt; d ) { ... }</code></li>
<li>the resulting expression from an assignment: <code>while (*dst++ = *src++) {;}</code></li>
<li>and the assignment can also involve function calls: <code>while((ch = getc()) != EOF) { ... }</code> </li>
<li>a plain variable: <code>while(i) ( ...)</code></li>
<li>an expression based on the evaluation of a plain variable  : <code>while (i--) { ... }</code> (even with side effects!)</li>
<li>a pointer expression: : <code>while (*++argv) { ... }</code></li>
</ul>

<p>Now, in the case of an integer expression, the expression is checked for <em>not equal to zero</em>. For pointer expressions, it is checked against <em>not equal to NULL</em>. That's all.</p>

<p>The crux of this is that in C, <strong>even an assignment is an expression</strong>, so you can write:</p>

<pre><code>a = b = c;
</code></pre>

<p>or even:
    a = b = c = d;</p>

<p>But, since an assignment is also an expression, you could even write:</p>

<pre><code>while ( a = b = c = d) { ... }
</code></pre>
",1
18415559,18415547,1,"<p>Try this:</p>

<pre><code>char resp[] = ""123456789"";

void getValue(char **im)
{
   *im = resp;
   printf(""\n%s\n"",*im);
}
</code></pre>

<p>You need to pass a <em>pointer to a pointer</em> as your program argument.</p>
",1
18415580,18415547,2,"<p>C passes parameters by value. Whatever change you ale to the <code>im</code> will be lost when the function exits. If you want to preserve the change. Pass the address of the pointer. Then you can change the pointer at the address you pass.</p>
",2
18415585,18415547,3,"<p>You can not assign with <code>=</code>, use <code>strcpy</code> instead:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

char resp[] = ""123456789"";
void getValue(char *im)
{
   im = strcpy(im, resp);
   printf(""\n%s\n"",im);
}

int main(int argc, char *argv[])
{
    char imei[11] = {0};
    getValue(imei);
    printf(""\nIMEI: %s\n"",imei);
    return 0;
}
</code></pre>

<p>That's because <code>imei</code> is an array[11] (not just a pointer to), if you want to assign via <code>=</code> you can:</p>

<pre><code>#include &lt;stdio.h&gt;

char resp[] = ""123456789"";
void getValue(char **im)
{
   *im = resp;
   printf(""\n%s\n"",*im);
}

int main(int argc, char *argv[])
{
    char *imei; /* Not an array but a pointer */
    getValue(&amp;imei);
    printf(""\nIMEI: %s\n"",imei);
    return 0;
}
</code></pre>
",3
19962098,19961312,1,"<p>Answer to 3rd question <code>the assignment of argv[optind] to optstr throws: warning ?</code> is as follows,</p>

<pre><code>char *optstr; 
*optstr = argv[optind]; // Wrong if LHS is a string rather a char
</code></pre>

<p><br></p>

<pre><code>optstr = argv[optind]; // Correct one
</code></pre>

<p>Here, <code>optstr</code> is a pointer to character which can store a single char or a string. 
Also <code>*optstr</code> refers to <code>char</code> and RHS <code>argv[optind]</code> is a string refers to a pointer. Hence the warning. </p>
",0
14237522,14237464,1,"<p><code>counter</code> is not initiated to 0 before the  <code>while</code> loop</p>

<p>And use</p>

<pre><code>string=realloc(string,size*sizeof(char*));
</code></pre>

<p>instead of</p>

<pre><code>string=realloc(string,size*sizeof(char**));
</code></pre>

<p>Could you describe in detail what you intend to do because in your code you are allocating array of pointers and then you allocate memory for each pointer in the array and then you remove the almost of the array with  <code>realloc(string,2*sizeof(char**));</code> this will remove almost the array and keep only the first 2 pointers. so with this you are loosing pointers to allocated memory so you could not free them any more:</p>
",0
14237549,14237464,0,"<ol>
<li><p>Counter should be set to zero before the while cycle. It is not set to zero by default.</p></li>
<li><p>The cycle in the for look should exclude <code>counter</code>:</p>

<p><code>for(i=0; i&lt;counter; i++) printf(""\n%s"",string[i]);</code></p></li>
<li><p>Free all dynamically allocated memory by calling <code>free</code>.</p></li>
</ol>
",0
17797979,17797964,7,"<ol>
<li><p>Short-circuit evaluation is required by the standard. </p></li>
<li><p>It's always <code>a</code> first. You can't change that in your program.</p></li>
</ol>

<p>Reference: <strong>6.5.13 Logical AND operator</strong>, paragraph 4:</p>

<blockquote>
  <p>Unlike the bitwise binary <strong><code>&amp;</code></strong> operator, the <strong><code>&amp;&amp;</code></strong> operator guarantees left-to-right evaluation; if the second operand is evaluated, there is a sequence point between the evaluations of the first and second operands. If the first operand compares equal to 0, the second operand is not evaluated.</p>
</blockquote>
",0
13428891,13428858,2,"<p>The problem is that the arguments to the <code>deal</code> function is <em>local</em>, meaning when you change their value in the function, the variables used when calling the function will not be changed. You need to pass those arguments <em>by reference</em>:</p>

<pre><code>void deal(card x[DECK_SIZE], card **head_d, card **current_d, card **head_p, card **current_p);
</code></pre>

<p>The do e.g.</p>

<pre><code>*head_p=temp_p;
</code></pre>

<p>in the function to set the variables.</p>

<p>Call as</p>

<pre><code>deal(deck, &amp;head_d, &amp;current_d, &amp;head_p, &amp;current_p);
</code></pre>
",5
13428896,13428858,0,"<p>You have uninitialized pointer variable <code>head_p</code> in your <code>main</code> function. Yet you are attempting to read data supposedly pointed by <code>head_p</code>. Of course, you will get segfault.</p>
",1
14817697,14817634,3,"<p><code>scanf</code> reads formatted inputs. When you tape a number, you tape the digits, and then, you press <code>&lt;Enter&gt;</code>. So there is a remaining <code>\n</code> in <code>stdin</code>, which is read in the next <code>scanf</code>. The same applies if you press <code>&lt;Enter&gt;</code> between the characters. </p>

<p>A solution is to consume the characters in the standard input stream after each input, as follow:</p>

<pre><code>#include &lt;stdio.h&gt;

void
clean_stdin (void)
{
  int c;

  while ((c = getchar ()) != '\n' &amp;&amp; c != EOF)
    ;
}
</code></pre>

<p>Another idea is to use <code>fgets</code> to get human inputs. <code>scanf</code> is not suitable for such readings.</p>
",0
14819102,14817634,0,"<p>Most of the time <code>scanf</code> reads formatted input.  For most <code>%</code> formats, scanf will first read and discard any whitespace and then parse the item specified.  So with <code>scanf(""%d"", ...</code> it will accept inputs with initial spaces (or even extra newlines!) with no problems.</p>

<p>One of the exceptions, however, is <code>%c</code>.  With <code>%c</code>, scanf reads the very next character, whatever it may be.  If that next character is a space or newline, that is what you get.</p>

<p>Depending on what exactly you want, you may be able to just use a blank space in your format string:</p>

<pre><code>scanf("" %c"",&amp;revstring[inc]);
</code></pre>

<p>The space causes <code>scanf</code> to skip any whitespace in the input, giving you the next non-whitespace character read.  However, this will make it impossible to enter a string with spaces in it (the spaces will be ignored).  Alternately, you could do <code>scanf("" "");</code> before the loop to skip whitespace once, or <code>scanf(""%*[^\n]""); scanf(""%*c"");</code> to skip everything up to the next newline, and then skip the newline.</p>
",0
13487795,13487195,0,"<p><code>fwrite(&amp;a,1,strlen(word)+1,anagramsFile);</code> should have been <code>fwrite(a.sorted,1,strlen(a.sorted)+1,anagramsFile);</code> I assume the declaration of sorted as <code>char sorted[SOME_LEN];</code></p>
",5
13471782,13471292,0,"<p>I think that you want a <code>do - while</code> iterative loop, so I will give an alternative answer.</p>

<blockquote>
  <p>How to find next multiple of B that is not less than A?</p>
</blockquote>

<p>Obviously this code is slower than David's. </p>

<pre><code>int main ( void ){

    int a, b, c;
    long int result;

    scanf(""%d %d"", &amp;a, &amp;b);
    c = 0;

    do {
        result = b * c;
        c++;
    } while ( result &lt; a );

    printf( "" The number is: %d \n"", result );
}
</code></pre>
",0
13471438,13471292,2,"<p>The question (now) asks for:</p>

<blockquote>
  <p>The next multiple of b that is not less than a?</p>
</blockquote>

<p>Using your notation of <code>a</code> and <code>b</code>, you can write it directly like this:</p>

<pre><code>int NextMultipleUp(int a, int b)
{
    int r = a % b;
    if (r == 0)
        return a;
    else
        return a + b - r;
}
</code></pre>

<hr>

<p>The question originally asked for </p>

<blockquote>
  <p>The next multiple of a that is not greater than b</p>
</blockquote>

<p>And for that the answer is</p>

<pre><code>int NextMultipleDown(int a, int b)
{
    return b - b % a;
}
</code></pre>

<p>This was the answer for which the original comments applied to.</p>
",6
13472068,13471292,1,"<pre><code>return (((a-1) / b )+1) * b;
</code></pre>

<p>Always returns a multiple of b.  Increment the integer dividend to get a multiple that is larger than the original a - subtract one from the original, because we want 'not less than' rather than 'greater than' a</p>
",0
13471741,13471292,0,"<pre><code>int nextMultiple(int a,int b)
{
  if(a%b == 0) return a;
  return a+(b-(a%b));
}
</code></pre>

<p>so if a=15 b=6</p>

<p>the ans is </p>

<pre><code>=15+(6-(15%6))
=15+(6-(3))
=15+3
=18
</code></pre>
",5
13487981,13487891,0,"<p>Try to add flush after <code>printf</code>:</p>

<pre><code>printf(""%s"", Packet);
fflush(stdout);
</code></pre>

<p><code>printf</code> use <code>stdout</code>, which is line buffered. So <code>printf</code> texts can be partly flushed (printed) if there is no <code>'\n'</code> in the end of the string.</p>

<p>In your case unflushed text is flushed when you type the newline.</p>
",1
13488670,13487891,2,"<p>This:</p>

<pre><code>Packet = (char*)realloc(NULL, 1);
memset(Packet, 0, sizeof(Packet));
</code></pre>

<p>causes undefined behavior. It allocates a single byte (why would you ever do this?) and then clears <code>sizeof(Packet)</code> bytes, which on most typical systems today is either 4 or 8 bytes. Thus, it writes outside the allocated memory. Note that <code>sizeof</code> cannot track dynamic allocations, so this whole pattern is wrong.</p>

<p>Also, please note that dynamic memory allocation can <em>fail</em>; you must check the return value of every call to <code>realloc()</code> before relying on the returned pointer being valid. If it's <code>NULL</code>, you can't access through it.</p>

<p>Further, just like with <code>malloc()</code>, <a href=""https://stackoverflow.com/a/605858/28169"">please don't cast the return value of <code>realloc()</code></a> in C.</p>
",4
13492152,13487891,0,"<p>Stdout is line buffered and characters in the stdout stream are saved until a newline is output or input is read from any stream attached to a terminal device, or if the stream buffer gets full. 
so you may either put the '\n' character in your printf like printf(""%s\n"",Packet); or just disable the stdout buffering using setbuf(stdout, NULL); for printf to print the complete string</p>
",0
15556735,15556518,1,"<p>If you want the <code>vertices</code> to be accessible by all of the functions in the file, then move its declaration outside of the <code>main()</code> function (i.e., give it global scope) and only <em>initialize</em> it inside of the <code>main()</code> function:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

typedef struct {
    double x;
    double y;
    double z;
} variable;

static variable *vertices = NULL;

int load_file() {
    FILE *fp1 ;
    fp1 = fopen( ""file"",""r"");
    if (fp1==NULL){
        printf(""File couldn't be opened or read!"");
        return 1;
    }

    int j = 0;
    while(fscanf(fp1, ""%lf %lf %lf "", &amp;vertices[j].x, &amp;vertices[j].y, &amp;vertices[j].z ) == 3 ){
        j++;
    }
    fclose(fp1);
    return 0;
}

int main (void){
    vertices = (variable*) malloc( 5000 * sizeof (variable) ) ;
    load_file();
    free(vertices);
    return 0;
}
</code></pre>

<p>If you want the <code>vertices</code> pointer to accessible across all files in your program, then give it external linkage by removing the <code>static</code> keyword from its declaration.</p>
",2
15556782,15556518,3,"<p>The problem is that you're declaring ""vertices"" inside main which makes its scope local to main and load_file() can't see it.</p>

<p>Change the declaration of load_file() as follows...</p>

<pre><code>void load_file( variable* vertices )
{
    /// blah blah
}
</code></pre>

<p>and then in main, pass your vertices variable in to it...</p>

<pre><code>int main (void)
{   
    variable *vertices = malloc( 5000 * sizeof (variable) ) ; 
    load_file( vertices );
    free(vertices);
    return 0;
}
</code></pre>

<p>EDIT: I would recommend against just making vertices a global variable... that means that anything can access it and/or modify it... even unintentionally. It's almost always wiser to pass arguments in and out of the functions that need them rather than to just make them globally available to the world... scope is your friend.</p>
",2
15590847,15590727,8,"<p>What @Mysticial saying is correct. Union elements share memory space. and two variables in union have same start address. following is my example program and its output may help you to understand. </p>

<pre><code>#include&lt;stdio.h&gt;
union u{
 int x;
 int y;
};
union u a;
int main(){
    printf(""\n %p %p\n"",&amp;a.x, &amp;a.y);
    return 1;
}
</code></pre>

<p>Output: </p>

<pre><code>~$ ./a.out 

0x601030 0x601030
</code></pre>

<p>Additionally, as @Alon idea, in C++ you have one more kind of variable called reference variable is alias of other variable. you can create like: (you question is taged C, In C you don't have reference variables)  see below: </p>

<pre><code>int a = 10;
int &amp;b = a; 

+----+----+
|   10    |  &lt;--- a = b
+----+----+  
  2002         
</code></pre>

<p>if you print <code>&amp;a</code> and <code>&amp;b</code> then you will get <code>2002</code> same. </p>
",6
15590923,15590727,8,"<p>The precise thing you asked for cannot be done using only the standard facilities of the language, but some compilers have extensions that permit it.  For instance, with GCC this might do what you want (<a href=""http://gcc.gnu.org/onlinedocs/gcc-4.7.2/gcc/Asm-Labels.html"" rel=""noreferrer"">documentation here</a>).</p>

<pre><code>#define ASMNAME(x) ASMNAME_(__USER_LABEL_PREFIX__, #x)
#define ASMNAME_(x,y) ASMNAME__(x, y)
#define ASMNAME__(x,y) __asm__(#x y)
int x;
extern int y ASMNAME(x);

int main(void)
{
    return !(&amp;x == &amp;y); /* will exit successfully */
}
</code></pre>

<p>Note well what effect this has, though: in the object file, there is only one variable, and its name is <code>x</code>.  <code>y</code> has only been declared as another name for it in the source code.  This may or may not be good enough depending on what you're trying to do.</p>

<p>Note also that the two variables are treated as <em>distinct</em> for optimization purposes.  For instance:</p>

<pre><code>#define ASMNAME(x) ASMNAME_(__USER_LABEL_PREFIX__, #x)
#define ASMNAME_(x,y) ASMNAME__(x, y)
#define ASMNAME__(x,y) __asm__(#x y)
int x;
extern int y ASMNAME(x);

#include &lt;stdio.h&gt;

int main(void)
{
   int a, b;
   x = 1;
   a = x;
   y = 2;
   b = x;
   printf(""a=%d b=%d x=%d y=%d\n"", a, b, x, y); 
   return 0;
}
</code></pre>

<p>may well print</p>

<pre><code>a=1 b=1 x=1 y=2
</code></pre>

<p>because the store to <code>y</code> is not considered to affect the value of <code>x</code>.</p>
",4
15590771,15590727,4,"<p>There is no way to do what you want in pure C, when you declare variables (and do something that will read/write their addresses [so that the compiler can't decide to treat them as registers]) they are allocated room in memory. You can't have 2 variables occupy the same space without cpp's glorified references or a union, you can have one variable and a number of pointers to it though:</p>

<pre><code>type1 var1;
type2 * var2 = &amp;var1;
</code></pre>

<p>But ultimately when I want to treat a piece of memory as different types I usually just do:</p>

<pre><code>void * var = &amp;something;
</code></pre>

<p>And then just use it like:</p>

<pre><code>*(int*)var
</code></pre>
",0
15590789,15590727,1,"<pre><code>int *p=NULL;  
    *p=value1; , 
</code></pre>

<p>print it   <code>*p=value2;</code> , use it</p>
",4
19867851,19867801,0,"<p>In <strong>C++</strong>, if you need a associative container, which you can access by a string containing the IP, you can use the <a href=""http://www.cplusplus.com/reference/map/map/"" rel=""nofollow"">map container</a>, of type <code>map&lt; string, float ></code> (of course if you store the IP's using strings)</p>

<p>Then you can access the elements just by doing <code>yourMapName[IPaddress]</code>.</p>

<p>If you need to do it in <strong>C</strong>, you need to do a <code>struct</code> containing the IP address (if it's pure C, you'll probably use <code>char*</code>, and an <code>unsigned int</code>. Then you'll need to do an array of those structures and a function which searches the array for a structure with a given <code>char*</code> and adds to the int, or adds a new entry in the array.</p>

<p>If you need to make the structure array flexible (because you don't know how many IP's will be connecting), you'll need to learn how to use the <code>malloc</code> and <code>free</code> C functions.</p>

<p>So if you're not stuck with pure C - it's way more straightforward to do it in C++. Just a hint, it's your choice.</p>
",0
19868235,19867801,2,"<p>In C you can use chained nodes with pointers, also known as queues, lists or stacks (depending on how its structured). I have a code that might just work for you:</p>

<pre><code>struct _ip_map_node {
    struct _ip_map_node* next;
    unsigned long ip;
    unsigned long transfered;
    unsigned long time;
};
typedef struct _ip_map_node ip_map_node;

ip_map_node* update_or_create_ip_map_node(ip_map_node** queue, unsigned long ip, unsigned long transfered) {
    ip_map_node* node = *queue;
    while (node) {
        if (node-&gt;ip == ip) {
            node-&gt;transfered += transfered;
            return node;
        }
        node = node-&gt;next;
    }
    node = malloc(sizeof(ip_map_node));
    node-&gt;next = *queue;
    *queue = node;

    node-&gt;ip = ip;
    node-&gt;transfered = transfered;
    node-&gt;time = time(NULL);

    return node;
}

void remove_ip_map_node(ip_map_node** queue, unsigned long ip) {
    ip_map_node* last = NULL;
    ip_map_node* curr = *queue;
    while (curr) {
        if (curr-&gt;ip == ip) {
            if (last)
                last-&gt;next = curr-&gt;next;
            else
                *queue = curr-&gt;next;

            free(curr);
            break;
        }
        last = curr;
        curr = curr-&gt;next;
    }
}

ip_map_node* my_ip_map = NULL;
</code></pre>

<p>I made some changes to best fit your purpose and didn't check if it compile, if you have trouble figuring it out I can assist you.</p>

<p>This is basically how you use it: You have a list of IPs named <code>my_ip_map</code>, its empty by default.</p>

<p>You can create elements in it or update it by using:</p>

<pre><code>ip_map_node* node = update_or_create_ip_map_node(&amp;my_ip_map, dest.sin_addr.s_addr, data_size);
</code></pre>

<p>Where <code>data_size</code> is the number of bytes being transfered to that IP at that moment. It will automatically sum to the amount that was previously sent to the same IP.</p>

<p>This <code>node</code> then has the properties:</p>

<pre><code>node-&gt;ip; // The IP in numeric format, use inet_ntoa() to transform it
node-&gt;transfered; // The amount that was transfered to that IP so far
node-&gt;time; // the time(NULL) when the first packet was sent to this IP
</code></pre>

<p>You now can get the transfer speed using <code>node-&gt;transfered / (time(NULL) - node-&gt;time)</code> -- be careful because a division by zero will crash.</p>

<p>If you want to reset this node every a couple seconds you can use:</p>

<pre><code>node-&gt;transfered = 0;
node-&gt;time = time(NULL);
</code></pre>

<p>Or remove it with:</p>

<pre><code>remove_ip_map_node(&amp;my_ip_map, dest.sin_addr);
</code></pre>

<p>And to run all IPs in the list you can use for instance:</p>

<pre><code>ip_map_node* node = my_ip_map;
while(node) {
    printf(""%s, %d\n"", inet_ntoa(*(struct in_addr *)&amp;node-&gt;ip), node-&gt;transfered);
    node = node-&gt;next;
}
</code></pre>

<p>For performance reasons, its structured as a stack (elements added last appear first).</p>
",4
19878369,19867801,0,"<p>Don't implement this yourself, use one of the vast amount of libraries available for C. An example with glib:</p>

<pre><code>#include &lt;glib.h&gt;
#include &lt;stdio.h&gt;

unsigned lookup(GHashTable *dict, const char *key)
{
    return GPOINTER_TO_UINT(g_hash_table_lookup(dict, key));
}

void accumulate(GHashTable *dict, char *key, unsigned increment)
{
    unsigned value;

    value = lookup(dict, key);
    g_hash_table_insert(dict, key, GUINT_TO_POINTER(value + increment));
}

int main(void)
{
    GHashTable *ip;

    ip = g_hash_table_new(g_str_hash, g_str_equal);
    accumulate(ip, ""10.1.1.1"", 0);
    accumulate(ip, ""10.10.10.10"", 2);
    accumulate(ip, ""10.1.1.1"", 2);
    accumulate(ip, ""10.1.1.1"", 3);
    accumulate(ip, ""10.2.2.2"", 10);

    printf(""%u\n"", lookup(ip, ""10.1.1.1""));
    printf(""%u\n"", lookup(ip, ""10.10.10.10""));
    printf(""%u\n"", lookup(ip, ""10.2.2.2""));

    g_hash_table_unref(ip);

    return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>$ ./hash 
5
2
10
</code></pre>

<p><a href=""https://developer.gnome.org/glib/2.38/glib-Hash-Tables.html"" rel=""nofollow"">https://developer.gnome.org/glib/2.38/glib-Hash-Tables.html</a></p>
",1
14842015,14841995,2,"<p>It's an algorithm to count the number of bits set to one without branching. It is described here:</p>

<p><a href=""http://graphics.stanford.edu/~seander/bithacks.html"" rel=""nofollow"">http://graphics.stanford.edu/~seander/bithacks.html</a></p>
",0
14159521,14159491,29,"<p>You must have pasted some nicely-formated text from a website, but the compiler wants plain text. The problem is with your <code>¡°</code> and <code>¡±</code> characters. Replace them with ordinary quotes, <code>""</code>, and you should be fine. </p>
",0
14159525,14159491,5,"<p>Your quotes for the filename are the wrong ones. This line</p>

<pre><code>FILE *fdir=fopen(¡°q2.txt¡±,""r"");
</code></pre>

<p>Needs to be</p>

<pre><code>FILE *fdir=fopen(""q2.txt"",""r"");
</code></pre>
",0
14159162,14159150,3,"<p>Call <code>close</code> on the socket 10 seconds after you <code>accept</code> it.</p>
",0
14159199,14159150,2,"<p>Just call <a href=""http://linux.die.net/man/2/shutdown"" rel=""nofollow"">shutdown</a> and <a href=""http://linux.die.net/man/2/close"" rel=""nofollow"">close</a> on the accepted socket file descriptor, providing you're talking about vanilla Berkely sockets in a UNIX of some kind.</p>

<p>You'll have to manage the time out in whatever way is appropriate to the architecture of your application. You'll have to run a timer <em>somewhere</em>, there is no way to automatically get the O/S to time out an active connection.</p>
",5
15881160,15880967,3,"<p>The problem is that in <code>resize</code> you create a completely new <code>HT</code> structure. But in <code>add</code> you don't pass this back up the call-chain, so in <code>main</code> you still have your <em>old</em> <code>HT</code> structure.</p>

<p>And as an extra side-note, you never <code>free</code> anything so you have lots of memory leaks.</p>

<hr>

<p>In <code>main</code> you create a new table. Lets call this table 1. Later when it's getting full you're creating a <em>new</em> table, lets call this 2. This new table is returned by <code>resize</code> and used in <code>add</code>. But when <code>add</code> returns the <code>main</code> function still has a pointer to table 1.</p>

<p>So when <code>add</code> is called next time, the <code>main</code> function passes table 1, which is too small so <code>resize</code> is called and creates yet <em>another</em> table, 3, that is used only locally in <code>add</code>. And so on and so on...</p>
",9
17411707,17411652,6,"<p>Use the modulo operator:</p>

<pre><code>if ((cardNo - 1) % 13 == 0)
</code></pre>
",2
14181911,14181897,5,"<p>Try to change </p>

<pre><code>operation == ""*""
</code></pre>

<p>to </p>

<pre><code>operation == '*'
</code></pre>

<p>This could be your issue since a string literal (""*"" with the double quotes) is a <code>const char *</code> (the pointer) while <code>operation</code> is a <code>char</code> (the integer). There is your warning.</p>

<p>It is good you are fixing this because if you ignore it, you will get wildly wrong behaviour( pretty much always false) since you are comparing a character with a pointer to a string with a character, and not two characters as you would expect.</p>

<p>p.s - another error (not compiler but possible runtime) as pointed out by @WhozCraig, your printf has 2 specifiers(<code>%2f</code>) but just 1 variable. This is gonna result in undefined behavior at best.</p>

<p>Fix as :</p>

<pre><code>printf("" the answer is %2f"", a[0] * a[1]);
</code></pre>
",1
14181932,14181897,2,"<p>You should change <code>operation == ""*""</code> with <code>operation == '*'</code> because <strong>single quotes</strong> are for <em>characters</em> and <strong>double quotes</strong> for <em>strings</em> and obviously, you are checking for character equality.</p>
",0
14182938,14182837,0,"<p>From the title it seems you are attempting to rely on the atomic nature of pointer operations.
please take a look at <a href=""https://stackoverflow.com/questions/879077/is-changing-a-pointer-considered-an-atomic-action-in-c"">Is changing a pointer considered an atomic action in C?</a>.</p>

<p>also - trying to detect invalid memory access is really bad. what if you get a pointer to a valid, but incorrect, address.</p>

<p>I would go with more conventional synchronization mechanisms. </p>
",3
14228476,14228365,1,"<p>You are trying to compare a string with a character. Instead of using getchar try to get the string. </p>

<pre><code>char str[100], line[500];
</code></pre>

<p>1) Read a line using fgets.</p>

<pre><code>fgets(line,100, stdin)
</code></pre>

<p>2) Use sscanf to obtain the string.</p>

<pre><code>sscanf(line,""%s"", str);
</code></pre>

<p>3) use strcmp to compare string.</p>

<pre><code>if(strcmp(str,""nir"") == 0) 
    printf(""You entered nir "");
</code></pre>
",0
14228493,14228365,1,"<p>The question is a little too confused for me to answer it all at once, so let's begin at the beginning.  To begin, <code>'nir'</code> (if it compiles at all) is a very strange way to write a single integer, whereas I think that you meant <code>""nir""</code>, a string of text.  However, <code>(c == ""nir"")</code> does not compile, does it?  [This presumably is why you have tried <code>(c == 'nir')</code> as a random shot, isn't it, though it means nothing sensible in C.]</p>

<p>In the context in which you use it, the <code>""nir""</code> is an <em>address.</em>  Now, you probably don't know what this means yet -- nor will you until you have gained several weeks' more experience in C.  What you can use today is the standard library's <code>strcmp()</code> function, presented by <em>string.h.</em>  I would recommend that you look that up and go from there.</p>

<p>And don't type <code>'nir'</code> again, incidentally!  It means nothing sensible in C.  The single quotes are for a single character like <code>'n'</code>, and stand for the character's integral ASCII value.</p>
",0
14229755,14228365,0,"<pre><code>main()
{
char c;


int i = 0;
do
{
     c = getchar();
     switch(i)
     {
         case 0: 
               if(c == 'n')
               {
                 i++;
               }
                break;
         case 1: 
               if(c == 'i')
               {
                 i++;
               }
               else
               {
                  i = 0; 
                }
                break;
         case 2: 
               if(c == 'r')
               {
                 printf (""you typed nir"");
               }
               i = 0; 
               break;
      }
 }while (c != EOF);
 }
</code></pre>

<p>Try this code</p>
",0
14785120,14785083,4,"<p>Most desktop applications are programmed using a style called <a href=""http://en.wikipedia.org/wiki/Event-driven_programming"" rel=""nofollow"">event-driven programming</a>.  In this setup, the program usually looks (at a very high level) like this:</p>

<pre><code>while (true) {
    wait for an event to occur.
    react to that event.
}
</code></pre>

<p>These ""events"" tend to be things like mouse clicks, keyboard events, window resizings, etc.  Typically, event-driven programs set up windows and attach pieces of code to them so that when an event occurs, the given piece of code can run.  Each piece of code that's attached tends to look exactly like what you've seen - it executes from the top to the bottom in a normal fashion.  The fact that different events can happen in different orders just means that they run when the user asks them to.</p>

<p>Every language and framework has their own way of handling events, so I'd recommend consulting the documentation for your favorite language / system for more details.</p>

<p>Hope this helps!</p>
",3
14842766,14842720,0,"<p>Just wrap the code in :</p>

<pre><code>while( upper &gt; lower ) { 
...
}
</code></pre>

<p>(And initialize <code>upper</code> and <code>lower</code> appropriately so the loop is entered.)</p>
",1
14842796,14842720,1,"<p>I really hate your <code>for</code> loop.  But that's an aside.</p>

<p>Just set <code>total</code> to zero inside the loop...  You should do that anyway.  At the moment it's uninitialised.</p>

<p>You should exit the loop when <code>lower == upper</code> without doing the calculation.  See previous note on my thoughts about your <code>for</code> loop.</p>

<p>Maybe something like this:</p>

<pre><code>printf(""Enter lower and upper integer limits: "");
fflush(stdout);

while ( 2 == scanf(""%d %d"", &amp;lower, &amp;upper) &amp;&amp; lower &lt; upper )
{
    total = 0;

    // Do calculation and output result...

    printf(""Enter the next set of limits: "");
    fflush(stdout);
}

printf(""Done\n"");
</code></pre>
",7
14843785,14842720,1,"<pre><code>int index, lower, upper, square, total, input;
while(1)
{
    total = 0;
    printf(""Enter lower and upper integer limits: "");
    fflush(stdout);
    input = scanf(""%d %d"", &amp;lower, &amp;upper); 
    if(input != 2) continue;
    if(upper &lt;= lower) break;
    for (index = lower; index &lt;= upper; index++)
    {
        square = index * index;
        total += square;
    }
    printf(""The sums of the squares from %d to %d is %d\n"", lower , upper, total );
}
printf(""Done\n"");
</code></pre>
",2
11816519,11816504,3,"<p>It's for suppressing <code>unused argument: mdata</code> compiler warnings. Rather bad practice, by the way.</p>
",6
16928391,16928352,3,"<p>Two problems:</p>

<ul>
<li><p>No space for terminating null character in <code>outword</code>. Needs to be:</p>

<pre><code>char outword[strlen(lword) + strlen(rword) + 1];
                                         /*^^^*/
</code></pre></li>
<li><p>This is <a href=""http://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow"">undefined behaviour</a> as <code>i</code> is being modified twice in the same statement:</p>

<pre><code>outstr[i++] = lstr[i++];

/* Change to: */

while (lstr[i] != '\0')
{
    outstr[i] = lstr[i];
    ++i;
}
</code></pre></li>
</ul>

<p>With these two changes the program produces a new concatenated string (<a href=""http://ideone.com/9QbU0q"" rel=""nofollow"">http://ideone.com/9QbU0q</a>).</p>
",1
16928398,16928352,3,"<p>Every string in C needs to end with a null character, which won't be visible. It does however need to be accounted for in the size of the memory you allocate.</p>
",0
16928406,16928352,-1,"<p>When copying <code>lstr</code> to <code>outstr</code> you're incrementing your index twice. Use <code>outstr[i] = lstr[i++]</code></p>
",3
15834992,15834941,2,"<p>C doesn't have built-in ""dynamic"" arrays like those of many higher-level languages.</p>

<p>You must allocate the needed storage yourself using <code>malloc()</code>, then copy the desired data element by element into the new array.</p>

<p>Also I can't quite understand the desired operations that you describe ... ""Join elements of <code>value</code> whose value of <code>id</code> are the same"" doesn't make sense.</p>

<p>Do you want to compute the <a href=""http://en.wikipedia.org/wiki/Intersection_%28set_theory%29"" rel=""nofollow"">intersection</a> of the arrays? But they're clearly not sets, so that doesn't sound right either.</p>
",2
15836052,15834941,1,"<p>The following will do what you want:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main(){
  int i,v;
  int ID_SIZE=7;
  int value[]={0,1,2,3,1,4, 7};
  int id[]=   {1,1,3,3,2,2,10};

  //Discover largest and smallest ids in order to allocate memory
  int min=0,max=0,length;
  for(i=1;i&lt;ID_SIZE;++i){
    if(id[i]&lt;id[min]) min=i;
    if(id[i]&gt;id[max]) max=i;
  }
  //Replace ids with values
  min=id[min];
  max=id[max];
  length=max-min+1;

  int **unions;
  int *append;
  append=(int *)calloc(length,sizeof(int));

  for(i=0;i&lt;length;++i)
    append[i]=-1;    //Initial insertion point for each id is at 0

  //Create 2D array unions[IDS HERE][VALUES HERE]
  unions=(int **)calloc(length,sizeof(int*));
  for(i=0;i&lt;length;++i)
    unions[i]=(int *)calloc(ID_SIZE,sizeof(int));

  //Join arrays
  for(i=0;i&lt;ID_SIZE;++i){
    printf(""Inserting %d into %d at %d\n"",value[i],id[i],append[id[i]-min]+1);
    unions[id[i]-min][++append[id[i]-min]]=value[i];
  }

  for(i=0;i&lt;length;++i){
    if(append[i]&gt;=0){
      printf(""Id %d has: "",i+min);
      for(v=0;v&lt;=append[id[i]-min];++v)
        printf(""%d "",unions[i][v]);
      printf(""\n"");
    }
  }

  return 0;
}
</code></pre>

<p>It creates two dynamic arrays.</p>

<p>One array, called <code>append</code> keeps track of how many values have been found for each id.</p>

<p>The other array, called <code>unions</code> stores the result of the computation.</p>

<p>In the case of the input I define in the program, the following is returned:</p>

<pre><code>Inserting 0 into 1 at 0
Inserting 1 into 1 at 1
Inserting 2 into 3 at 0
Inserting 3 into 3 at 1
Inserting 1 into 2 at 0
Inserting 4 into 2 at 1
Inserting 7 into 10 at 0
Id 1 has: 0 1 
Id 2 has: 1 4 
Id 3 has: 2 3 
Id 10 has: 7 
</code></pre>
",0
14860508,14860422,1,"<p>You're stuck here:</p>

<pre><code>while (i == 0)
{
  if (yesorno = 'Y')
  {
     gets( input );
     humanToss = humanTurn();
     printf(""Do you wish to throw again? [Y or N]"");
     ta = getchar();

  }
  if(yesorno == 'N')
  {
     i++;
  }
}
</code></pre>

<p>You have your <code>yesorno</code> value from previous input; then you receive new input, but variable <code>yesorno</code> is the same - you just set variable <code>ta</code>
So <code>yesorno</code> is always <code>'Y'</code>, <code>i</code> is always 0 and you're in infinite while-loop.</p>

<p><b>edit</b>
and you're assigning <code>yesorno</code> in your if, as second commenter said. but anyway, if you'll write <code>==</code> instead of <code>=</code>, you'll still be in infinite loop.</p>
",0
14860514,14860422,4,"<p>change your program as </p>

<pre><code>if (yesorno == 'Y')
</code></pre>

<p>You are assigning instead of checking for yes.</p>
",0
14865462,14860422,0,"<p>There is a <strong>VERY</strong> big difference between these two lines.<br>
Can you spot it?</p>

<pre><code>if (yesorno = 'Y')
if (yesorno == 'N')
</code></pre>

<p>Also, because you are checking the value of <code>yesorno</code>, you should ask yourself:<br>
<em>""Where am I setting this value?  How am I setting the value?""</em></p>
",0
15534733,15152187,0,"<p>you can specify the length of the string in fprintf arguments. You can also take a look at my project: libtprint - a simple library to print tabled data, <a href=""https://github.com/wizzard/libtprint"" rel=""nofollow"">https://github.com/wizzard/libtprint</a> . There I use various tricks to justify strings.</p>

<p>Hope it helps !</p>
",0
14830442,14827944,0,"<p>Post fix operator -- has higher precedence than unary operator *. You need to take care of that. Have you overlooked it? Please look into the precedence table in the following link</p>

<p><a href=""https://stackoverflow.com/questions/4204973/shortcut-to-remember-the-order-of-evaluation-and-precedence-of-operators-in-c"">Shortcut to remember the Order of Evaluation and Precedence of Operators in C</a></p>
",0
14831009,14827944,0,"<p>Thanks for posting the rest of the code</p>

<p>I have taken a look, first i would recommend you activate all warnings your compiler can show <code>-Wall</code> etc.</p>

<p>Now, the actual thoughts: </p>

<p>In your middle nested for-loop you check <code>target = **ptr; target &gt; 0</code>. This means that your code will only work as long as there are no 0's in your arrays! Instead of trying to 0-terminate you could instead pass the number of entries as an argument (in addition to the pointer to the array).</p>

<p>About the triple-nested for-loop etc:
The code suggests you just want to sort the rows independently (ie <em>not</em> one row by the order given in another), so the first thing you should do is make a function which sorts a single array, if you have that then you can call it on the individual arrays.</p>

<p><strong>EDIT</strong>: to your comment, ok make sure you remove main()'s call to bubble() otherwise you cannot really tell which of the sort-functions (bubble vs insert) did what.</p>

<p>Now with warnings enabled (-Wall etc., depending on compiler), you would see this:</p>

<pre><code>a.c: In function 'fillTable':
a.c:138:33: error: unused parameter 'row' [-Werror=unused-parameter]
a.c: In function 'insert':
a.c:175:4: error: value computed is not used [-Werror=unused-value]
a.c:160:30: error: unused parameter 'row' [-Werror=unused-parameter]
</code></pre>

<p>For example the one in line 175 tells what Kranthi Kumar mentioned in his answer. To be clear: <code>*walk--</code> does not do anything, try <code>--*walk</code>. The unused parameter warnings show that maybe something was forgotten. Also, when you fixed these, there may appear additional errors that also need fixing.</p>

<p><strong>EDIT 2</strong>: what i mentioned for the other sort-function is true for insert() too: you are using <code>while(*walk &gt;= 0...</code>, which means that your function will only work on arrays that:</p>

<ul>
<li>contain no negative values</li>
<li>have a negative value at index <strong>(-1)</strong>  this is broken!</li>
</ul>

<p>Good luck!</p>
",1
14721969,14721933,4,"<p>Move this line</p>

<pre><code>grossPay = wage*hours;
</code></pre>

<p>after</p>

<pre><code>scanf (""%f"",&amp;hours);
</code></pre>

<p>You should try to calculate <code>grossPay</code> after user inputs <code>wage</code> &amp; <code>hours</code>. By default during declaration <code>wage</code> and <code>hours</code> will be initialized to default value i.e. <code>0.0</code> and hence you are getting <code>grossPay</code> zero.</p>
",0
14721980,14721933,0,"<p>you are assigning grosspay to wage&amp;hours before even assigning any value to wage and hours. Do it after the last scanf inside the first for loop.</p>
",0
14721983,14721933,0,"<p>you are calculating it before giving information so try it </p>

<pre><code>printf (""--------------------------------\n"");

grossPay = wage*hours;

printf (""%06i     %.02f      %.01f   %f\n\n"", number, wage, hours,grossPay);
</code></pre>
",0
15846689,15846675,0,"<p><code>MIN_BID</code> has array type. You'll have to pick a slot.</p>

<pre><code>MIN_BID[0] = ...
</code></pre>
",0
15846691,15846675,5,"<p><code>MIN_BID</code> is an array of floats, yet you're trying to assign just a single <code>float</code> to it.  It looks like what you want is <code>MIN_BID[k-1] = CUR_BID[k-1] + MIN_BID[k-1];</code>.</p>
",0
15582457,15582285,0,"<p>To store the data in the requested format, you would require a 2D array to store your values. Since the number of participants is not known apriori, you would have to dynamically allocate the required space and free it up later. Please find a reworked version of your code as below</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() 
{
    FILE * ifp = fopen(""input.txt"",""r"");
    FILE * ofp = fopen (""output.txt"", ""w"");
    int participants = 0, i , j;
    char **name; // Changed the name to a 2D array
    int **grade; // Changed the grade to a 2D array
    char *curname; // Temp pointer to current name
    int  *curgrade; // Temp pointer to current array of grades



    fscanf(ifp, ""%d"", &amp;participants);

    // Allocate memory
    name = malloc((sizeof(char *) * participants)); // Allocate pointers to hold strings for the number of participants
    grade = malloc((sizeof(int *) * participants)); // Allocate pointers to hold grades for the number of participants

    for(i = 0; i &lt; participants; i++) {
        name[i] = malloc((sizeof(char) * 10)); //Assumption: Name doesn't exceed 10 characters
        grade[i] = malloc((sizeof(int) * 8)); // Assumption: Only 8 grades
   }

    for (i = 0; i &lt; participants; i++) { /* Fixed: index i should start from 0 */
        curname = name[i]; // Get pointer to current name
        curgrade = &amp;grade[i][0]; // Get pointer to array of current grades
        fscanf(ifp, ""%s"", curname); // Read name into current name pointer
        for (j = 0; j &lt; 8; j++) {
            fscanf(ifp, ""%d"", &amp;curgrade[j]); // Read grades into current array
        }
    }


    printf(""%d\n"", participants);
    for(i = 0; i &lt; participants; i++) {
        printf(""%s\n"", name[i]);
    }
    for(i = 0; i &lt; participants; i++) {
        curgrade = &amp;grade[i][0];
        for (j = 0; j &lt; 8; j++) {
            printf(""%d\n"", curgrade[j]);
        }
    }

    fclose(ifp);
    fclose(ofp);

    for(i = 0; i &lt; participants; i++) {
        free(name[i]); // Free the array of individual names
        free(grade[i]); // Free the array of grades for every participant
    }

    free(grade); // Free the grades pointer
    free(name); // Free the names pointer

return 0;
</code></pre>

<p>}</p>
",0
15582303,15582285,0,"<p>Use <code>strtok</code> to generate tokens from the file, splitting on newline and space, then check if each string is a number, by trying to parse it, using <code>itoa</code> or something alike that, if parseable add to numbers otherwise to names.</p>
",1
19495892,19495776,2,"<p>The practice of escaping the newlines at the end of a line is indeed to mark the continuation of the statement onto the next line. Apparently that was needed in the old C compilers There is only one place that I'm sure it is still needed and that is in macro definitions of functions, something that is generally frowned upon in C++.</p>

<blockquote>
  <p>A continued line is a line which ends with a backslash, . The
  backslash is removed and the following line is joined with the current
  one. No space is inserted, so you may split a line anywhere, even in
  the middle of a word. (It is generally more readable to split lines
  only at white space.)</p>
  
  <p>The trailing backslash on a continued line is commonly referred to as
  a backslash-newline.</p>
  
  <p>If there is white space between a backslash and the end of a line,
  that is still a continued line. However, as this is usually the result
  of an editing mistake, and many compilers will not accept it as a
  continued line, GCC will warn you about it.</p>
</blockquote>

<p><a href=""http://gcc.gnu.org/onlinedocs/gcc-3.2/cpp/Initial-processing.html"" rel=""nofollow"">Reference</a></p>
",0
19495812,19495776,12,"<p>A backslash at the end of a line tells the compiler to ignore the new-line character.</p>

<p>It is a way of formatting lines to be readable for humans without interrupting the source text. E.g., if you have a long string enclosed in quotation marks, you can use a backslash to continue the string on a new line without inserting a new-line character in the string.</p>

<p>(This was more useful before the C standard added the property that adjacent strings, such as <code>""abc"" ""def""</code>, are concatenated. Now you can put strings on consecutive lines, and they will be concatenated. Prior to that, you had to use the backslash to do it.)</p>

<p>Nowadays the most common use of the backslash is, as <a href=""https://stackoverflow.com/users/1362735/heretolearn"">heretolearn</a> points out, to continue preprocessor macro definitions. Unlike regular C statements, preprocessor statements must be on a single line. However, some preprocessor macro definitions are quite long. To format them (somewhat) nicely, a definition is spread over multiple physical lines, but the backslash makes them into one line for the compiler (including the preprocessor).</p>

<p>A backslash followed by a new-line character are <strong>completely</strong> removed from the source text by the compiler, unlike a new-line character by itself. So the source text:</p>

<pre><code>abc\
def
</code></pre>

<p>is equivalent to the single identifier <code>abcdef</code>, not <code>abc def</code>. You can use it in the middle of any operator or other language construction except trigraph sequences (trigraph sequences, such as <code>??=</code>, are converted to replacement characters, such as <code>#</code>, before the backslash-new-line processing):</p>

<pre><code>MyStructureVariable-\
&gt;MemberName

IncrementMe+\
+
</code></pre>

<p>However, do not do that. Use it reasonably.</p>
",4
14846745,14846629,0,"<p>When you do this:</p>

<pre><code>Strings[pos]=str;
</code></pre>

<p>It merely sets that array element to the buffer pointed to by 'str'. It does not copy the string. The 'str' buffer never changes, so your entire array ends up pointing to the same buffer.</p>

<p>Rather, at that line you need to copy the string. If you can't use malloc, then your Strings array needs to have buffers at each array element (aka 2 dimensional array). Maybe declare it something like:</p>

<pre><code>char Strings[5][5];
</code></pre>

<p>Then instead of using your strcpy to copy to 'str', copy the string to 'Strings[pos]';</p>
",10
18386493,18386268,1,"<p>Well that's what the answer you've accepted explicitly does and it's a quite good idea because somehow you have to determine how many columns a specific lines contains. 
Another diea would be to let a special value in every row determine the end (like the <code>'\0'</code> in strings). To have it like that you can change the code as follows:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int getColCount(FILE *fin){
    long fpos = ftell(fin);
    int count = 0;
    char buff[BUFSIZ];
    while(fgets(buff, sizeof(buff), fin)){
        char *p;
        for(p=strtok(buff, "" \t\n"");p;p=strtok(NULL, "" \t\n""))
            ++count;
        if(count)break;
    }
    fseek(fin, fpos, SEEK_SET);
    return count;
}

int main(void){
    FILE *fp;
    int *key1[2];

    if((fp = fopen(""/Users/doc/test.txt"", ""rt"")) == NULL){
        printf(""\nCannot open file"");
        exit(1);
    }

    for(int i = 0; i &lt; 2; ++i){
        int size = getColCount(fp);
        // size+1 is still necessary, the additional element is now needed for the delimiting value instead of the number of elements
        key1[i] = malloc((size+1)*sizeof(int));
        /* CHANGE: don't store size in col 0
        if(key1[i]){
            key1[i][0] = size;//length store top of row
        } else {
            fprintf(stderr, ""It was not possible to secure the memory.\n"");
            exit(2);
        }
        now we just do: */ 
        if(!key1[i]){
            fprintf(stderr, ""It was not possible to secure the memory.\n"");
            exit(2);
        }
        /* CHANGE: we start with index 0 */
        //for(int j = 1; j &lt;= size ;++j){
        for(int j = 0; j &lt; size ;++j){
            fscanf(fp, ""%d"", &amp;key1[i][j]); 
        }
        /* CHANGE: we add a final value to determine the end of the row */
        key[i][size] = -1;   // choose a value that cannot occur in your data
    }
    fclose(fp);
    {//check print and dealocate
        for(int i = 0; i &lt; 2 ; ++i){
            for(int j = 1; j &lt;= key1[i][0]; ++j)
                printf(""%d "", key1[i][j]);
            printf(""\n"");
            free(key1[i]);
        }
    }
    return 0;
}
</code></pre>
",5
15537173,15537135,0,"<p>The first struct is called <code>struct Nodetag</code>, the second struct is called <code>struct NODE</code>.</p>

<p>In the first instance, a typedef has been defined that ""aliases"" <code>NODE</code> for <code>struct Nodetag</code>, but it doesn't change the name of the structure. What it does do is let you type, for example, <code>NODE*</code> rather than <code>struct Nodetag*</code>. It's shorthand, nothing more.</p>
",4
15537197,15537135,0,"<p>Structure tags and types live in different namespaces. You can have a <code>struct node</code> and also a type <code>node</code>. Structure tags must be used with the <code>struct</code> specifier/prefix to distinguish them. When you do:</p>

<pre><code>typedef struct Nodetag {
int dataNum;
struct Nodetag* nextNode;
} NODE;
</code></pre>

<p>You are defining a new type and also defining a structure tag but you don't really need to define a type it is just for convenience. Within the structure definition, since the compiler does not know about the type until it reads the <code>} NODE;</code> part, you have to use the structure tags to refer to the structure you are defining.</p>
",0
15537202,15537135,6,"<p>You can optionally give a structure a tag, as in <code>struct Nodetag</code> or <code>struct NODE</code>. These tags (and union tags, and enum tags) are in a separate namespace from ordinary identifiers.</p>

<p>The <code>typedef</code> version creates an alias for <code>struct Nodetag</code>:</p>

<pre><code>typedef struct Nodetag { ... } NODE;
</code></pre>

<p>Now <code>NODE</code> is a type name in the ordinary identifiers name space that is a synonym or alias for <code>struct Nodetag</code>.</p>

<p>Note that you can also write:</p>

<pre><code>typedef struct Nodetag NODE;

struct Nodetag
{
    int   dataNum;
    NODE *nextNode;
};
</code></pre>

<p>The first line says 'there exists a structure type with the tag <code>Nodetag</code> and <code>NODE</code> is an alias for this type'.  The second block says '<code>struct Nodetag</code> consists of these items', listing a <code>NODE *</code> as one of the members.</p>

<hr>

<h3>C and C++ are two different languages</h3>

<p>Note that this question is tagged C, and you are getting straight C answers (which is good).  However, if you have encountered C++, you'd find that:</p>

<pre><code>struct Nodetag
{
    int      dataNum;
    Nodetag *nextNode;
};
</code></pre>

<p>is valid C++ and generates a type name <code>Nodetag</code> in the ordinary identifiers name space (as well as the tag <code>Nodetag</code> in the (structure) tags namespace. This is not valid in C.  You may get confused if you end up using a C++ compiler to compile C code, though.</p>
",0
15537233,15537135,3,"<p>This:</p>

<pre><code>struct Nodetag {
    /* ... */
};
</code></pre>

<p>creates a type named <code>struct Nodetag</code>. Similarly, this:</p>

<pre><code>struct NODE {
    /* ... */
};
</code></pre>

<p>creates a type named <code>struct NODE</code>.</p>

<p>In either case, you can wrap that declaration with a <code>typedef</code> declaration, creating a second name for the same type:</p>

<pre><code>typedef struct S {
    /* ... */
} T;
</code></pre>

<p>This lets you refer to the type either as <code>struct S</code> or as <code>T</code>. (You can't call it just <code>S</code> -- though you could if you were programming in C++ rather than C.)</p>

<p>An equivalent way to write the above is:</p>

<pre><code>struct S {
    /* ... */
};
typedef struct S T;
</code></pre>

<p>Note that struct tags and typedef names are in different namespaces (not in the C++ sense of the word ""namespaces""), since a struct tag can only follow the keyword <code>struct</code>.  So there's no need for them to be distinct.</p>

<pre><code>typedef struct Node {
    /* ... */
} Node;
</code></pre>

<p>Now you can refer to the type either as <code>struct Node</code> or just as <code>Node</code>.</p>

<p>There's no great advantage in adding a typedef like this; if you like, you can omit it and just refer to the type as <code>struct Node</code>. (But a lot of C programmers like being able to use a one-word name for a type, and a typedef is the only good way to do that (a <code>#define</code> is another way to do it, but not a good way.)</p>

<p>It's also possible to omit the tag name, and just use the typedef:</p>

<pre><code>typedef struct {
    /* ... */
} Node;
</code></pre>

<p>This gives you an <em>anonymous</em> struct type, and then immediately creates the name <code>Node</code> that refers to it. But with this approach, the struct can't contain a pointer to itself, since the name <code>Node</code> doesn't become visible until after the end of the struct definition.</p>
",2
19883361,19883195,0,"<p>Figured it out, if you set myScales to 0.0/0.0 to get a NaN(presumably?) number, and check myScales == myScales followed by the rest, and set myScales back to 0.0/0.0 it should work!</p>
",0
15515164,15514350,-1,"<p>Use <code>sigaction()</code> system call and handle alarm signal in starting only. 
Use ISR function to reset the alarm for every action when you want.</p>
",0
15514381,15514350,9,"<p>You can just set the new alarm and the old one will be cancelled:</p>
<pre><code>alarm (5);
</code></pre>
<p>From the <a href=""http://linux.die.net/man/2/alarm"" rel=""noreferrer"">Linux <code>alarm</code> man page</a>, slightly paraphrased):</p>
<blockquote>
<p><code>alarm()</code> arranges for a <code>SIGALRM</code> signal to be delivered to the calling process in a specified number of seconds.</p>
<p>If the specified number of seconds is zero, no new alarm is scheduled.</p>
<p>In any event any previously set alarm is canceled.</p>
</blockquote>
<p>As noted, any <em>current</em> alarm is cancelled by a call to <code>alarm()</code> before anything else. A new one won't be created if the argument to <code>alarm()</code> is zero.</p>
<p>So <code>alarm(0)</code> will cancel any currently active alarm, while <code>alarm(5)</code> will either create a new alarm of, or reset a currently active alarm to, 5 seconds.</p>
",0
15514383,15514350,4,"<p>To cancel an outstanding <code>alarm()</code>, use <code>alarm(0)</code>.  Its return value tells you how much time was unused from the last call to <code>alarm()</code>.  You can then freely set a new alarm, of course.</p>
",0
15827322,15827264,3,"<p>You need to seek back to the start of the file before reading:</p>

<pre><code>int main()
{
    FILE* fp=NULL;
    char buff[100];
    fp=fopen(""myfile.txt"",""r"");
    if(fp==NULL)
    {
        printf(""Couldn't Open the File!!!\n"");
        exit(1);                     // &lt;&lt;&lt; handle fopen failure
    }
    fseek(fp, 0, SEEK_END);
    size_t file_size = ftell(fp);
    fseek(fp, 0, SEEK_SET);          // &lt;&lt;&lt; seek to start of file
    fread(buff,file_size,1,fp);
    printf(""Data Read [%s]"",buff);
    fclose(fp);
    return 0;
}
</code></pre>
",1
15827335,15827264,4,"<p>You forgot to reset the file pointer to start after doing this.</p>

<pre><code>fseek(fp, 0, SEEK_END);
</code></pre>

<p>Do this after finding size (<code>file_size</code>).</p>

<pre><code>rewind (fp);
</code></pre>
",2
15827361,15827264,0,"<p>Try it....</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void handle_line(char *line) {
printf(""%s"", line);
}

int main(int argc, char *argv[]) {
int size = 1024, pos;
int c;
char *buffer = (char *)malloc(size);

FILE *f = fopen(""myfile.txt"", ""r"");
if(f) {
  do { // read all lines in file
    pos = 0;
    do{ // read one line
      c = fgetc(f);
      if(c != EOF) buffer[pos++] = (char)c;
      if(pos &gt;= size - 1) { // increase buffer length - leave room for 0
        size *=2;
        buffer = (char*)realloc(buffer, size);
      }
    }while(c != EOF &amp;&amp; c != '\n');
    buffer[pos] = 0;
    // line is now in buffer
    handle_line(buffer);
  } while(c != EOF); 
  fclose(f);           
}
free(buffer);
return 0;
</code></pre>

<p>}</p>
",1
15828106,15827264,0,"<pre><code>    #include ""stdafx.h""
    #include &lt;stdio.h&gt;
    #include &lt;string.h&gt;
    #include &lt;fstream&gt;

    int main()
    {
        FILE* fp=NULL;
        char *buff;                     //change array to pointer
        fp=fopen(""myfile.txt"",""r"");
        if(fp==NULL)
        {
            printf(""Couldn't Open the File!!!\n"");
        }
        fseek(fp, 0, SEEK_END);
        size_t file_size = ftell(fp);
        buff = malloc(file_size);      //allocating memory needed for reading file data
        fseek(fp,0,SEEK_SET);          //changing fp to point start of file data
        fread(buff,file_size,1,fp);
        printf(""Data Read [%s]"",buff);
        fclose(fp);
        return 0;
    }
</code></pre>
",0
15833697,15827264,0,"<p>having a buffer of 100 bytes to read a file is not a better idea as since the file size may be more than 100 bytes.</p>

<p>A better file io can be done by doing a fgets on the file, if its not a type of metadata that you wanted to read using the fread.</p>

<p>fgets in a while loop can be used to check whether its reached EOF or a feof call can be used to check the EOF.</p>

<p>a sample code listing of fgets can be like this:</p>

<pre><code> while (fgets(buf, len, fp)) {
      printf(""%s"", buf);
 }
</code></pre>

<p>or a sample that is used with fgets can be like this:</p>

<pre><code> while (fread(buf, len, 1, fp) &gt;= 0) {
       printf(""%s\n"", buf);
 }
</code></pre>
",0
15509615,15508479,0,"<p>If you had declared (or allocated) your variables correctly, the line you've given would work as expected.</p>

<p>In this code:</p>

<pre><code>    int int1, int2;
    char char1;
    char *string1;

    fscanf(stdin, ""%d %c %s %d"", &amp;int1, &amp;char1, string1, &amp;int2);
</code></pre>

<p>As <code>string1</code> is uninitialised here this is undefined behaviour. With Linux/glibc, if <code>string1</code> happens to contain <code>0</code> (NULL), it causes <code>scanf</code> to stop processing the format string, and this would produce the same results as you've given. On other systems it might work, it might crash.</p>

<p>This will work as expected:</p>

<pre><code>    int int1, int2;
    char char1;
    char string1[20];

    fscanf(stdin, ""%d %c %19s %d"", &amp;int1, &amp;char1, string1, &amp;int2);
</code></pre>
",2
15509746,15508479,0,"<pre><code>fscanf(stdin, ""%d\n %c\n %s\n %d\n"", &amp;int1, &amp;char1, string1, &amp;int2)
</code></pre>

<p>\n - depends on your platform, in some of them instead of \n should be \n\carriege return<br>
So, if explain briefly - you can provide in the ""parameter string"" symbols which will be excluded from stream, and their order matters.<br>
As you said that you wan`t to place tokens on a new line each then place symbols for a new line in you parameter string</p>
",4
15815268,15815202,2,"<p>You're not using <code>printf()</code> correctly.</p>

<p>It doesn't magically handle formatting any arguments: you must <em>tell it</em> what arguments you're sending, and where you want their values to go, using format specifiers (starting with <code>%</code>).</p>

<p>You need:</p>

<pre><code>printf(""The new ID is %d\n"", data1.ID);
printf(""The name input is '%s'\n"", data1.Name);
</code></pre>

<p>Also note that <code>ID</code> shouldn't be <code>int *</code>, it needs to store an actual integer so it should be <code>int</code> only.</p>
",0
15815465,15815202,2,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt; /* for malloc and free */

struct data 
{
    /*int* ID; why a pointer? */
    int ID;
    char *Name;
};

/* void main() Noooo */
int main(void)
{
    struct data data1;
    struct data *data1Ptr; /* unused */

    data1Ptr = &amp;data1;
    printf(""New ID:\n"");
    scanf(""%d"", &amp;data1.ID); /* scanf expects a pointer */
    printf(""Name:\n"");
    /* you have to reserve mem for name before */
    data1.Name = malloc(100);
    /* check result of malloc here */
    scanf(""%s"",data1.Name);
    /*printf(""The new ID is \n"",data1.ID); You forget %d */
    printf(""The new ID is %d\n"",data1.ID);
    /* printf(""The name input is \n"",data1.Name); You forget %s */
    printf(""The name input is %s\n"",data1.Name);
    free(data1.Name);
    return 0;
}
</code></pre>

<p>Note: If you declare Name as <code>char Name[100]</code> inside <code>struct data</code> there is no need to <code>malloc</code></p>
",0
15815753,15815202,1,"<p>You seem to have a number of issues here. First you chose to make <code>Name</code> and <code>ID</code> pointers in your struct. That means you need to dynamically allocate memory to both before you start using them:</p>

<pre><code>struct data data1;
data1.ID = malloc(sizeof(int));
data1.Name = malloc(50); // so arbitrary amount big enough for a name.
</code></pre>

<p>I'm not sure why you chose to make <code>ID</code> a pointer, it doesn't have to be in this example and it would probably be easier to understand if it wasn't; so consider changing that.</p>

<p>Now <a href=""http://linux.die.net/man/3/scanf"" rel=""nofollow""><code>scanf()</code></a> takes a format string, and a number of pointers to each type being read. In your case you're just reading an int and a string, so what you have:</p>

<pre><code>scanf(""%d"",data1.ID);
scanf(""%s"",data1.Name);
</code></pre>

<p>is fine, keep in mind if you choose to change <code>ID</code> to a <code>int</code> instead of a pointer you'll need to pass the address of it: <code>scanf(""%s"",&amp;data1.ID);</code></p>

<p><a href=""http://linux.die.net/man/3/printf"" rel=""nofollow""><code>printf()</code></a> takes a format string, and the data in the format to be printed. In you case:</p>

<pre><code>printf(""The new ID is \n"",&amp;data1.ID);  // you're giving the address of the int
printf(""The name input is \n"",&amp;data1.Name); // and the address of the string
</code></pre>

<p>but you didn't provide any format... and you don't want to send the address of your pointers, that doesn't make sense. </p>

<pre><code>printf(""The new ID is %d\n"",*data1.ID);  // %d for an int, and * to dereference
printf(""The name input is %s\n"",data1.Name); // %s for a string
</code></pre>

<p>What you wanted to do was use <code>%d</code> and <code>%s</code> for the int and string accordingly (just like with <code>scanf()</code>) but then since <code>ID</code> is a pointer, you need to dereference it before passing it to <code>printf()</code>. There is no ""string"" type in C, so when you tell <code>printf()</code> to expect a string, it just wants a <code>char *</code> which is what <code>data1.Name</code> already is.</p>
",0
15565833,15565790,1,"<hr>

<p>if you cannot change the prototype of <code>fun()</code> then make it a macro ;-)</p>

<pre><code>#define fun() (a = 15)

int main(void)
{
  int a=5;
  fun();
  printf(""%d"",a);
  return 0;
}
</code></pre>
",4
15565884,15565790,2,"<p>Your question is just tagged <code>[c]</code>. <strong>What you are asking cannot be done using correct, portable C, unless either <code>a</code> or <code>fun()</code> are defined differently.</strong></p>

<p>If this question is about stack smashing attacks, it is unanswerable without:</p>

<ul>
<li>knowing that this is what the question is about;</li>
<li>knowing full details of the target hardware architecture and the OS.</li>
</ul>
",0
15566036,15565790,5,"<p>Warning - horrific hack incoming:</p>

<pre><code>void fun()
{
    int b;
    int *a = &amp;b;
    while(*a != 5)
    {
        a++;
    }
    *a = 15;
}
</code></pre>

<p>This searches the stack for the value we expect for the variable we want to modify, on the assumption that it will have the same alignment as a locally declared int. It also assumes that the variable will in fact be in the stack (it could be optimised away), and that we won't find any other location with the relevant number in. These are, naturally, dangerous assumptions. If the assumptions prove incorrect, bad things will likely happen. I am not responsible for any injury, loss of limb, or death that results in using a hack like this.</p>

<p>Alternatively, and somewhat safer:</p>

<pre><code>void fun()
{
    printf(""1"");
}
</code></pre>
",6
15566047,15565790,0,"<pre><code>#include &lt;stdio.h&gt;
void fun();

int main(void)
{
  int a=5;
  fun();
  printf(""%d"", a); 
  return 0;
}

void fun() {
  int p[1];
  p[11] = 15; 
  printf(""%d\n"", p[11]);
}
</code></pre>
",3
17411764,17411716,3,"<p>You should define your format string like the following:</p>

<pre><code>fprintf(fp, ""%*s"", SIZE, s);  // Right aligned string
fprintf(fp, ""%-*s"", SIZE, s); // Left aligned string
</code></pre>

<p>From the <code>printf</code> man page:</p>

<blockquote>
  <p><strong>The precision</strong><br>
  Instead of a decimal digit string one may write <code>""*""</code> to specify that the precision is given in the next argument</p>
</blockquote>
",4
15853089,15852936,1,"<p>You don't need to change the original string, you just need to print out extra newlines when necessary:</p>

<pre><code>void wrap(char *str, int len, int linelen) {
    int i;
    for (i = 0; i &lt; len; ++i) {
        printf(""%c"", str[i]);
        if (i &gt; 0 &amp;&amp; i % linelen == 0) {
            printf(""\n"");
        }
    }
}
</code></pre>

<p>If your original string might have newlines in it, you can keep track of the current line's length so that the next line is wrapped correctly:</p>

<pre><code>void wrap(char *str, int len, int linelen) {
    int i, currlen;
    for (i = 0, currlen = 0; i &lt; len; ++i, ++currlen) {
        printf(""%c"", str[i]);
        if (str[i] == '\n') {
            currlen = 0;
        }
        if (currlen &gt; 0 &amp;&amp; currlen % linelen == 0) {
            printf(""\n"");
        }
    }
}
</code></pre>
",0
15853100,15852936,2,"<p>Stolen from this post: <a href=""https://stackoverflow.com/questions/7780809/is-it-possible-to-print-out-only-a-certain-section-of-a-c-string-without-making"">Is it possible to print out only a certain section of a C-string, without making a separate substring?</a></p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void) {

    char *str = ""helo world"";
    int total_len = strlen(str);
    int single_len = 3;
    for (int i = 0; i &lt; total_len; i += single_len) {
        /* print at most first three characters (safe) */
        printf(""%.*s\n"", single_len, str + i);
    }

    return 0;
}
</code></pre>
",0
15853157,15852936,1,"<p>Your program seems to want to break up <code>tok</code> into multiple <code>linelen</code> bytes, but you don't seem to care about what character you are replacing to achieve that. This makes your <code>wrap</code> routine drop information that was in the original input. You then call <code>strtok</code> to print one token at a time, but the damage is already done.</p>

<p>Instead, I believe you should restructure your code so that <code>strtok</code> is used to find a token, and you compute whether printing the current token will put you over your <code>linelen</code> or not. If  it will, you print a newline, print the token, and compute your current running line length as just the length of the token you just printed. Each token you print on the same line will increment the running line length.</p>

<pre><code>void wrap(char *tok, int linelen)
{
  int len = 0;
  char *ss = tok;
  char *token = strtok(ss, "" \t\n"");
  while (token) {
    int tokenlen = strlen(token);
    if (len &amp;&amp; (len + tokenlen + 1 &gt; linelen)) {
      puts("""");
      len = 0;
    }
    if (tokenlen) {
      printf(""%s%s"", len ? "" "" : """", token);
      len += 1 + tokenlen;
    }
    token = strtok(0, "" \t\n"");
  }
  if (len) puts("""");
}
</code></pre>

<p>Your original implementation does not take into account how to treat tab characters. If you add all linear whitespace characters to the <code>strtok</code> delimiters, then all tabs will be treated like a token separator, and will be dropped when the input is wrapped. Correctly dealing with tabs will complicate your running line length calculation, since a tab character will cause the line length to jump to the next tab stop.</p>
",0
15860943,15860684,0,"<p>Verbatim from <code>man tmpnam</code>:</p>

<blockquote>
  <p>Never use this function.  Use mkstemp(3) or tmpfile(3) instead.</p>
</blockquote>

<hr>

<p>Anyway, as you asked for it:</p>

<p>The name generated by <code>tmpnam()</code> consists of a file name of maximum <code>L_tmpnam</code> lenght <strong>prefixed</strong> with a directory of name <code>P_tmpdir</code>.</p>

<p>So the buffer to by passed to <code>tmpnam()</code> is best declared (if C99):</p>

<pre><code>char pathname[strlen(P_tmpdir) + 1 + L_tmpnam + 1] = """"; /* +1 for dir delimiting `/` and +1 for zero-termination */
</code></pre>

<p>If non C99 you might go for this:</p>

<pre><code>size_t sizeTmpName = strlen(P_tmpdir) + 1 + L_tmpnam + 1;
char * pathname = calloc(sizeTmpName, sizeof (*pathname));
if (NULL == pathname)
  perror(""calloc() for 'pathname'"");
</code></pre>

<p>Then call <code>tmpnam()</code> like this:</p>

<pre><code>if (NULL == tmpnam(pathname))
  fprintf(stderr, ""tmpnam(): a unique name cannot be generated.\n"");
else
  printf(""unique name: %s\n"", pathname);

... /* do soemthing */

/* if on non C99 and calloc(() was called: */
free(pathname);
</code></pre>
",3
15862299,15862245,1,"<p><code>kule</code> is local to function <code>main</code>, so you cannot use it in <code>coz</code>. If you want to use it there, do either of the following:</p>

<ol>
<li><p>(Not recommended:) Declare <code>kule</code> outside of <code>main</code>, and make sure to assign a valid value to it before you call <code>coz</code>:</p>

<pre><code>platform *kule;  // removed from `main` to global scope

void coz(¡­) { ¡­ }

int main() {
    kule = ¡­;
    coz(¡­);
    ¡­
}
</code></pre></li>
<li><p>(<strong>Recommended:</strong>) Pass it to <code>coz</code> as an argument (via an additional parameter):</p>

<pre><code>void coz(int disk, int* kaynak, int* yardimci, int* hedef, platform *kule) { ¡­ }
                                                      // ^^^^^^^^^^^^^^^^
int main() {                                          // additional parameter
    platform *kule = ¡­;
    coz(¡­, kule);
    ¡­
}
</code></pre></li>
</ol>
",0
15862304,15862245,0,"<p>You need to pass your <code>kule</code> to <code>coz()</code>:</p>

<pre><code>void coz(int disk, int* kaynak, int* yardimci, int* hedef, platform* kule) {
    if (disk &gt; 0) {
        printf(""Kaynak:\t%d -&gt; Hedef\t%d\n"", kaynak, hedef);
        disk_tasi(kule, disk);
        kuleleri_ekrana_yaz(*kule);
    }
}

int main() {
    platform *kule;
    kule = (platform*) malloc(sizeof(platform));
    disk_no_ata(kule);
    kuleleri_ekrana_yaz(*kule);
    coz(disk, kaynak, yardimci, hedef, kule);
    return 0;
}
</code></pre>
",0
15902240,15902180,1,"<p>You cannot expect text in the file if you use fwrite and write binary data with it. Use fprintf instead or ofstream (C++).</p>
",0
15902290,15902180,0,"<p>You're just writing the array as a binary chunk of data out into the file.</p>

<p>If you want to output the elements of the array you will need something like <code>fprintf(fp, ""%d"", nums[i]);</code> in a loop.</p>
",2
15902587,15902180,1,"<p><code>fwrite</code> will just call <code>fputc</code> which outputs the specified byte to the specified file. When you open this file in your text editor, it will interpret that data as ASCII codes. You can check the actual contents of the file using a command like <a href=""http://unixhelp.ed.ac.uk/CGI/man-cgi?od"" rel=""nofollow"">od</a> (for Linux) or <a href=""http://en.wikipedia.org/wiki/Debug_%28command%29"" rel=""nofollow"">Debug</a> (for Windows) to display various representations of the data in that file.</p>

<p>If you want the actual integer to appear as a character in your text editor, use <code>fprintf</code>:</p>

<pre><code>int i;
for(i = 0; i &lt; size; i++) {
    if(fprintf(fp, ""%d "", nums1[i]) &lt; 0) {
        /* An error occurred */
    }
}
</code></pre>

<p><code>fprintf</code> will work like you expected because it <em>converts</em> the argument (i.e. <code>nums1[i]</code>) to the format specified as the second argument.</p>

<p>For example, consider</p>

<p><code>fprintf(stdout, ""%d"", 1);</code></p>

<p>Here, <code>fprintf</code> will take the number 1 and convert it to its ASCII equivalent (ASCII code is 49 in decimal) and output that ASCII code to stdout.</p>
",4
18210801,18210613,2,"<p>You could benefit from better naming conventions. Here you check if the <em>current</em> node has not been visited yet, and it has, so you never enter the ""then"" branch:</p>

<pre><code>if(TestEsisteArcoMatrice(grafo, i, j) &amp;&amp; !nodi_visitati[i])
</code></pre>

<p>(i should be j)</p>

<p>There could be other mistakes, I haven't read the whole thing.</p>
",0
18210806,18210613,2,"<p>This looks strange:</p>

<pre><code>            nodi_visitati[i] = true;
            for (j=NumNodi-1; j&gt;=0; j--)
                 if(TestEsisteArcoMatrice(grafo, i, j) &amp;&amp; !nodi_visitati[i])
</code></pre>

<p>should probably be</p>

<pre><code>                 if(TestEsisteArcoMatrice(grafo, i, j) &amp;&amp; !nodi_visitati[j])
</code></pre>
",0
16955417,16955172,0,"<p>If you do not want to use pass-by-reference, you can use pass-by-value which you are using in your code. It only needs to be implemented properly. You can change your ""void question"" to return a value by changing the void to ""int"" and issuing a return statement before the end of question function. Check code below:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define OPENWINDOW ""\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n""

int question()

{
        printf(""What Would You Like To Do?\n"");
        printf(""\t1.Add A Reminder\n\t2.View Reminders\n\t3.Manage Current Reminders\n\t4.Settings\n"");
        scanf(""%i"", &amp;option);
        return i;
}

void navigate(int option)
{
    switch(option)
    {
        case 1:
        printf(OPENWINDOW);
        break;
        case 2:
        printf(OPENWINDOW);
        break;
        case 3:
        printf(OPENWINDOW);
        break;
        case 4:
        printf(OPENWINDOW);
        break;
        default :
        printf(""sorry"");
        question(option);
    }
}

int main()
{
int option;
option = question(option);
navigate(option);

return 0;
}
</code></pre>
",0
16955219,16955172,1,"<p>You need to pass <code>option</code> as pass-by-reference. Pass the address of option to question() and update there.</p>

<p>Refer the modified code.</p>

<pre><code>void question(int *option)
{
        printf(""What Would You Like To Do?\n"");
        printf(""\t1.Add A Reminder\n\t2.View Reminders\n\t3.Manage Current Reminders\n\t4.Settings\n"");
        scanf(""%i"", option);
}
</code></pre>

<p>call the question() as,</p>

<pre><code>question(&amp;option);
</code></pre>
",0
16955228,16955172,0,"<p>You are passing the variable <code>option</code> by value <code>question(option)</code></p>

<p>You should pass <code>option</code> varible by reference</p>

<pre><code>void question(int *option)
{
        printf(""What Would You Like To Do?\n"");
        printf(""\t1.Add A Reminder\n\t2.View Reminders\n\t3.Manage Current Reminders\n\t4.Settings\n"");
        scanf(""%i"", option);

}

void navigate(int *option)
{
    switch(*option)
    {
        case 1:
        printf(OPENWINDOW);
        break;
        case 2:
        printf(OPENWINDOW);
        break;
        case 3:
        printf(OPENWINDOW);
        break;
        case 4:
        printf(OPENWINDOW);
        break;
        default :
        printf(""sorry"");
        question(option);

}

int main()
{
     int option;    

     question(&amp;option);
     navigate(&amp;option);    

     return 0;
}
</code></pre>

<p>For more information regarding this have a look at this link <a href=""https://stackoverflow.com/questions/2278700/difference-between-call-by-reference-and-call-by-value"">Difference between call by reference and call by value</a></p>
",0
16955234,16955172,0,"<p>You are passing ""option"" as call by value. Hence whatever you pass to question(). Would be lost. </p>

<p>Either, you return ""option"" from    question() and pass this to navigate().</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define OPENWINDOW ""\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n""

int question()
{       int option;
        printf(""What Would You Like To Do?\n"");
        printf(""\t1.Add A Reminder\n\t2.View Reminders\n\t3.Manage Current Reminders\n\t4.Settings\n"");
        scanf(""%i"", &amp;option);
        return option;

}

void navigate(int option)
{
    switch(option)
    {
        case 1:
        printf(OPENWINDOW);
        break;
        case 2:
        printf(OPENWINDOW);
        break;
        case 3:
        printf(OPENWINDOW);
        break;
        case 4:
        printf(OPENWINDOW);
        break;
        default :
        printf(""sorry"");
        question(option);


    }
}

int main()
{
int option;

option = question();
navigate(option);

return 0;
}
~
</code></pre>
",0
16955261,16955172,2,"<p>Arguments are passed by value, not reference. So, your ""option"" arg is going to ""disappear"" soon after the function ends.</p>

<p>If you pass the ""reference"" to the var then you can use it to fill the caller variable. The following code and example fixes it.</p>

<pre><code>void question(int *option)
{
        printf(""What Would You Like To Do?\n"");
        printf(""\t1.Add A Reminder\n\t2.View Reminders\n\t3.Manage Current Reminders\n\t4.Settings\n"");
        scanf(""%i"", option);
}
</code></pre>

<p>Then you call it like this:</p>

<pre><code>int option;
question(&amp;option);
// now you can use option...
</code></pre>

<p>Since function can return values, you could also:</p>

<pre><code>int question(void)
{
        int option;
        printf(""What Would You Like To Do?\n"");
        printf(""\t1.Add A Reminder\n\t2.View Reminders\n\t3.Manage Current Reminders\n\t4.Settings\n"");
        scanf(""%i"", &amp;option);
        return option;
}

// ...
int option = question();
// ...
</code></pre>

<p>The navigate and main using reference (pointers):</p>

<pre><code>void navigate(int *option)
{
    switch(*option)
    {
        case 1:
          printf(OPENWINDOW);
          break;
        case 2:
          printf(OPENWINDOW);
          break;
        case 3:
          printf(OPENWINDOW);
          break;
        case 4:
          printf(OPENWINDOW);
          break;
        default:
          printf(""sorry"");
          question(option);    
    }
}

int main(void)
{
     int option;    

     question(&amp;option);
     navigate(&amp;option);    

     return 0;
}
</code></pre>
",8
16955271,16955172,0,"<p>You need to either pass pointer of <code>option</code> to <code>question</code> or return it from the function <code>question</code>.</p>

<p>In your case value of <code>option</code> in <code>main()</code> is not changing when you read it in <code>question()</code>. Update your code as </p>

<pre><code>int question()

{
        int option;

        printf(""What Would You Like To Do?\n"");
        printf(""\t1.Add A Reminder\n\t2.View Reminders\n\t3.Manage Current Reminders\n\t4.Settings\n"");
        scanf(""%i"", &amp;option);
        return option;
}

int main()
{
    int option;
    option = question(option);
    navigate(option);
    return 0;
}
</code></pre>
",0
18681370,18681308,1,"<p>You are declaring a to have an uninitialized variable size <code>x</code>. Either assign some value to x ,declare a to have fixed value, or use dynamic memory allocation allocating the memory for a(e.g. with malloc) after you have read the value of <code>x</code>,</p>
",0
18681396,18681308,3,"<p>The problem with your code is here:</p>

<pre><code>int x, y, z, a[x],
</code></pre>

<p>When you declare an array, the size of the array has to be known, either at compile time or (for variable-length arrays, introduced in C99) at runtime. <code>a[x]</code> is not a valid declaration, because you are declaring the array before the value of <code>x</code> is determined.</p>

<p>You can use the following for C99 or later:</p>

<pre><code>int x, y, z, p = -1, q;
scanf (""%d"", &amp;x);
int a[x];
</code></pre>

<p>If you are using a pre-C99 compiler, then you need to figure out what the largest number of input integers you want your code to handle, and set the array to that. Then you can prompt the user for how many integers the user wants to enter, and store that in a different variable. After validating that value (to make sure it is not larger than the size of your array), you can use that variable to read the integers in a loop. </p>
",0
18681422,18681308,2,"<p>Your one problem is initialization of <code>p = -1</code>. This would mean that the check <code>if (a[y] &lt;= p)</code> would accept smaller values for <code>p</code> only if they are smaller than <code>1</code>. So, if you pass a set of values like <code>23 45 3 10</code>, then you would still get a minimum value of <code>-1</code>. One way to avoid this is to minimize it with the first input value.</p>
",0
17407907,17407838,1,"<p>You take your pointer, and you point it to the address of 4.  The first member of your struct (x), will reside here, so if you print the memory address of x, you're oging to get your intial starting place (4).  When you try and print y, it starts at 8 because its an int (and x  starts and 4 and goes to 8.)  Same with z (starts at 12, ends at 16, and y starts at 8, and ends at 12).</p>

<p>While there is no struct there, you're casting the memory there to your struct, so your pointer arithmetic will follow your structure's memory layout. </p>
",0
17407920,17407838,3,"<pre><code>mytype* p = (mytype*)4;
</code></pre>

<p>declares a pointer to type <code>mytype</code> at address <code>0x04</code>.</p>

<pre><code>void* pp = &amp;(p-&gt;x);
printf(""%d\n"",(int)pp);
</code></pre>

<p>shows that the address of <code>mytype-&gt;x</code> is the same as the address of <code>mytype</code>.</p>

<p>Repeating for <code>p-&gt;y</code> and <code>p-&gt;z</code> show that <code>sizeof(int)==4</code> on your platform and the compiler has inserted no padding between the members of <code>mytype</code></p>

<p>The offsets between <code>x</code>, <code>y</code> and <code>z</code> could change if you run the code on different platforms.</p>

<p>Note also that I think</p>

<pre><code>printf(""%d\n"",(int)pp);
</code></pre>

<p>relies on undefined behaviour as there is no guarantee that <code>sizeof(void*) == sizeof(int)</code></p>

<pre><code>printf(""%p\n"",pp);
</code></pre>

<p>should be safer.</p>
",0
18767508,18767458,1,"<p>Use whichever is most readable in your particular circumstances.</p>

<p>Worry about efficiency only when you have measured that you have a performance problem.</p>

<p>In all likelihood, the compiler will generate the same code.</p>
",0
18767515,18767458,4,"<p>Compilers are generally smart enough to optimize both into same instructions. It is better idea to use ternary operator without assuming compiler optimization.</p>
",0
18767516,18767458,5,"<p>If you look at the disassembly of both approaches, they're generally the same on any modern compiler I know of. The ternary operator is just a compact form of writing the same thing.</p>

<p>Here's an example using gcc 4.2.1 on Mac OS X:</p>

<p>With if/else:</p>

<pre><code>int x = 1;
int y = 2;
int z;

if (x &lt; y)
{
    z = 3;
}
else
{
    z = 4;
}
</code></pre>

<p>With the ternary operator:</p>

<pre><code>int x = 1;
int y = 2;
int z = (x &lt;  y) ? 3 : 4;
</code></pre>

<p>If you run gcc -S test.c on both of these, you get this assembly for the if/else version: </p>

<pre><code>    movl    $1, -16(%rbp)
    movl    $2, -20(%rbp)
    movl    -16(%rbp), %eax
    movl    -20(%rbp), %ecx
    cmpl    %ecx, %eax
    jge LBB1_2
    movl    $3, -12(%rbp)
    jmp LBB1_3
LBB1_2:
    movl    $4, -12(%rbp)
</code></pre>

<p>and this for the ternary operator version:</p>

<pre><code>    movl    $1, -12(%rbp)
    movl    $2, -16(%rbp)
    movl    -12(%rbp), %eax
    movl    -16(%rbp), %ecx
    cmpl    %ecx, %eax
    jge LBB1_2
    movl    $3, -20(%rbp)
    jmp LBB1_3
LBB1_2:
    movl    $4, -20(%rbp)
</code></pre>

<p>The register offsets are different, but functionally, the code does the same thing. It adds two literals to two different registers, then compares and jumps based on the result of the comparison.</p>
",1
18767545,18767458,2,"<p>On any modern compiler there is generally no difference between those two. </p>

<p>Therefore it is only a question of readabilty and maintainability of your code.</p>
",0
18767578,18767458,2,"<p>The only ""advantage"" is that you can use the ternary operator in an expression (eg. function arguments), making for terser code. using an <code>if</code>, you'd duplicate the full expression.</p>
",0
17773417,17773403,7,"<p>You can only use <code>%</code> operator with integer operands. Use <code>fmod</code> function (declared in <code>math.h</code>) for floating point operands.</p>
",4
17773448,17773403,2,"<p>The operands of the operator <code>%</code> have to be integral (i.e. <code>int</code>, <code>byte</code>, ...). You will have to cast the <code>float</code>s first:</p>

<pre><code>c = ((int)a) % ((int) b);
</code></pre>
",0
17773665,17773403,0,"<p>The concept of ""remainder"" is only applicable to integer division. i.e. division that required to generate integer quotient. </p>

<p>In <code>older</code> languages the <code>%</code> operator was just defined as <code>integer modular division</code>.  Quite a few early C compilers didn't support <code>floating point</code> at all. It was added on later, and most primitive operations supported in the language, but everything else left to the <code>standard library.</code> </p>

<p>For floating point numbers, a new operation is required that would generate integer quotient for floating point operands.</p>

<p>Core C language does not support such operation, but it is provided as a standard library <code>fmod</code> function, as well as <code>remainder</code> function in C99.</p>
",0
18141637,18141598,3,"<p>You have to write</p>

<pre><code>double timestamp = *( (double*)(&amp;t.lsb));
</code></pre>

<p>You should use something like</p>

<pre><code>struct __attribute__((__packed__)) pts_t {
    ...
};
</code></pre>

<p>to make sure that your struct is packed (though I can't see why any compiler would pad something after the lsb in this case).</p>

<p>...</p>

<p>Actually depending whether your platform is big- or littleendian you might have to switch lsb and msb or do something like this:</p>

<pre><code>double timestamp;
double* p_timestamp = &amp;timestamp;
*((uint32_t*)p_timestamp) = t.msb;
*( ((uint32_t*)p_timestamp) + 1) = t.lsb;
</code></pre>
",3
18141759,18141598,3,"<p>The initial thought would be to write the following:</p>

<pre><code>double timestamp = *( ( double * ) &amp;( t.lsb ) );
</code></pre>

<p>To step through this (assuming you are in a 32-bit environment):</p>

<ol>
<li>You are getting the address of the identifier <code>t.lsb</code> because you need to find the memory address of the first byte in your structure. Note, you can alternatively do <code>&amp;t</code>.</li>
<li>You are then casting that memory address to be a pointer to a double (8 bytes).</li>
<li>You are lastly dereferencing that pointer and storing all 8 bytes in the 8 byte block of memory that the identifier <code>timestamp</code> uses.</li>
</ol>

<p><strong>Remark:</strong> </p>

<ol>
<li>You will need to consider little/big endianness.</li>
<li>You are assuming that both the structure and double are aligned properly (as mentioned below).</li>
<li>This is not portable, you are assuming that a double is 8 bytes.</li>
</ol>

<p>Now, the three points in the remark blurb are a lot to worry about. It becomes a big pain when porting this code accross multiple platforms. As mentioned below, using C <code>unions</code> is a much better and correct solution that is portable.</p>

<p>It would be written as follows with C <code>unions</code>:</p>

<pre><code>double timestamp = ( union { double d; struct pts_t pts; } ) { t } .d;
</code></pre>
",6
18155362,18141598,0,"<p>You have:</p>

<pre><code>struct pts_t 
{
    uint32_t lsb;
    uint32_t msb;
};
</code></pre>

<p>This:</p>

<pre><code>pts_t t; 
double timestamp = t;
</code></pre>

<p>is perfectly ""safe"", in the sense that it won't compile so it can't do any harm. You haven't defined a type <code>pts_t</code>; you've defined a type <code>struct pts_t</code>.</p>

<p>This:</p>

<pre><code>struct pts_t t;
double timestamp = t;
</code></pre>

<p>also won't compile, because you can't convert (either explicitly, with a cast, or implicitly, with an assignment) a value of a struct type to an object of numeric type.</p>

<p>I humbly suggest that you would have saved some time if you'd tried that before posting.</p>

<p>Probably the most straightforward approach is to use <code>memcpy()</code>:</p>

<pre><code>#include &lt;assert.h&gt;
#include &lt;string.h&gt;
/* ... */
struct pts_t t = { some_lsb_value, some_msbZ_value };
double timestamp;
assert(sizeof t == sizeof timestamp);
memcpy(&amp;timestamp, &amp;t, sizeof timestamp);
</code></pre>

<p>By using <code>memcpy()</code> rather than pointer casts, you avoid any risk of misaligned memory access; depending on the system, your struct might require either more or less strict alignment than a <code>double</code>.</p>

<p>There's also no guarantee that your struct is the same size as a <code>double</code>. The struct is almost certainly 64 bits, and <code>double</code> is <em>probably</em> 64 bits, but neither is actually guaranteed, and it doesn't hurt to make your assumptions explicit.</p>

<p>That leaves open the question of whether the values you've stored in <code>t.lsb</code> and <code>t.msb</code>, when taken together, make up a representation for a valid <code>double</code> value, particularly for the value you want.  The language says very little about how floating-point types are represented. In particular, endianness can and does vary across different systems. It's up to you to make sure that reinterpreting the representation in this way actually makes sense -- and your code is likely to be non-portable.</p>
",0
17401198,17400975,0,"<p>The problem is most likely your use of <code>isupper</code> as index. It's not guaranteed to return <code>1</code> for true values, just that it will return ""true"" (which may be any non-zero value).</p>

<p>You can solve this by using the ternary expression:</p>

<pre><code>alpha[isupper(str[i]) ? 1 : 0][...]
</code></pre>
",0
17401199,17400975,4,"<p>Your code is correct except for one detail, which might be confusing for a newbie.</p>

<p>It is ok to assume that the function <code>isupper()</code> returns a boolean value 1 or 0, but if you check the documentation it says <em>A value different from zero (i.e., true) if indeed c is an uppercase alphabetic letter. Zero (i.e., false) otherwise.</em>
This and the fact that <code>isupper()</code> is returning an int and not a _Bool is causing the problem.</p>

<p><code>int isupper ( int c );</code></p>

<p>When returning true <code>isupper()</code> might return any non_zero value. In my case it returns <code>8</code> ( a specific bit-field ). Probably the same in yours.</p>

<p>All you have to do is cast the return of <code>isupper()</code> to <code>_Bool</code></p>

<pre><code>printf(""%d   %d"" ,(_Bool)isupper('A') , ((int)(tolower(str[i])-'a')+c)%26 ) ;
</code></pre>
",6
17401249,17400975,0,"<p>In the first iteration of your loop, you are trying to write to <code>alpha[256][6]</code>, (<code>isupper</code> does not always return <code>0</code> or <code>1</code>)</p>

<blockquote>
  <p>isupper returns: A value different from zero (i.e., true) if indeed c is an
  uppercase alphabetic letter. Zero (i.e., false) otherwise.</p>
</blockquote>

<p><code>alpha[isupper(str[i]) != 0][...]</code> will do the trick</p>

<p>Also note that you should always cast the argument you pass to
isupper(), isalnum(), etc. to unsigned char</p>
",0
17856715,17856694,5,"<p>Did you mean:</p>

<pre><code>printf(""%c\n"", argv[2][1]);
</code></pre>

<p><code>argv</code> is declared <code>char* argv[]</code>, so <code>argv[2][1]</code> is of type <code>char</code>, use <code>%c</code> in <code>printf</code> to print.</p>

<p>If you run <code>program_name hello world</code>, you will print <code>o</code> which is the second character of the second argument.</p>
",0
17856740,17856694,3,"<p>You need to understand that argv is a pointer to pointer to char.</p>

<p>so argv[2] is a pointer to char, and 
argv[2][1] is a character.</p>

<p>To print a char, you need to use the <code>%c</code> conversion specifier in <code>printf</code> rather than <code>%</code>s.</p>
",0
17782919,17782581,0,"<p>As the first part of the question already has been solved I'm just adding for the row/col/diag sum bit which you can do like this:</p>

<pre><code>int sum_row1 = (num1 + num2 + num3 + num4);
int sum_row2 = (num5 + num6 + num7 + num8);

int sum_col1 = (num1 + num5 + num9 + num13);
int sum_col2 = (num2 + num6 + num10 + num14);
</code></pre>

<p>Do this after you've read the digits and add to the printf statement at appropriate places.</p>

<p>I didn't include the diagonal as I'm not sure what you want, but I guess you see the general idea.</p>
",0
17782801,17782581,0,"<p><strong>Use something like this</strong></p>

<pre><code>printf ( ""%d %d %d %d\n%d %d %d %d\n%d %d %d %d\n%d %d %d %d"",num1,num2, num3, num4, num5, num6, num7, num8, num9, num10, num11, num12, num13, num14, num15, num16);
</code></pre>

<p>You are using <code>\t</code> which is used for horizontal spacing,
Use <code>\n</code> instead,it will take you to the next line...
output for 1 digit no's will be like this</p>

<pre><code>5 6 7 8
8 9 0 1
1 2 3 4
</code></pre>

<p>Now use this and extend it for than 1 digit inputs...
Hope it helps!!</p>
",2
17782822,17782581,0,"<p>i've compile and run the program using <a href=""http://www.compileonline.com/compile_c_online.php"" rel=""nofollow noreferrer"">this site</a> with some little changes and got this:
<img src=""https://i.stack.imgur.com/CB721.png"" alt=""enter image description here""></p>

<p>working just fine</p>

<p>the only change i've done is</p>

<pre><code>printf ( ""\n%d %d %d %d\n%d %d %d %d\n%d %d %d %d\n%d %d %d %d"",num1,num2, num3, num4, num5, num6, num7, num8, num9, num10, num11, num12, num13, num14, num15, num16);
</code></pre>
",1
17782856,17782581,0,"<p>I compiled and run your application and it does not show any ""num"" before of a number. In fact, I cannot understand how you get that output if you are only printing number with %d.  </p>

<p>I would just substitute the <em>\t</em> (tab space) with <em>\n</em> ( new line).  It should work as you expect.</p>
",3
18461382,18460730,0,"<p>On your program you need to suppress all magic number (cf: <a href=""http://en.wikipedia.org/wiki/Magic_number_%28programming%29"" rel=""nofollow"">http://en.wikipedia.org/wiki/Magic_number_%28programming%29</a>)</p>

<p>Also, i optimize a bit your code as following:</p>

<pre><code>    #include &lt;stdio.h&gt;
    #include &lt;string.h&gt;

    #define FIRST_DAY  ""1st""
    #define SECOND_DAY ""2nd""
    #define THIRD_DAY  ""3rd""
    #define N_DAY      ""th""

    #define ONLY_ONE_SENTENCE 0
    #define LAST_DAY          1
    #define NUMBER_OF_DAYS    12

    #define BUFFER_SIZE       5

    #define FIRST_ANNOUNCE ""\tOn the %s day of Christmas my true love sent to me\n\n""

    const char *sentences[] = {
        ""\t\tA Partridge in a Pear Tree\n\n"", 
        ""\t\tAnd A Partridge in a Pear Tree\n\n"", 
        ""\t\tTwo Turtle Doves\n\n"", 
        ""\t\tThree French Hens\n\n"", 
        ""\t\tFour Calling Birds \n\n"", 
        ""\t\tFive Golden Rings\n\n"", 
        ""\t\tSix Geese a Laying\n\n"", 
        ""\t\tSeven Swans a Swimming\n\n"", 
        ""\t\tEight Maids a Milking\n\n"", 
        ""\t\tNine Ladies Dancing\n\n"", 
        ""\t\tTen Lords a Leaping\n\n"", 
        ""\t\tEleven Pipers Piping\n\n"", 
        ""\t\tTwelve Drummers Drumming\n\n""};

    void print12DaysOfChristmas();

    int main() { // Main Function
        print12DaysOfChristmas();
        return 0;
    }


    void print12DaysOfChristmas() {
        int days, counter, num, index;
        char buffer[BUFFER_SIZE];
        char *day;

        printf(""\n\t\t* * * TWELVE DAYS OF CHRISTMAS * * *\n"");
        printf(""\t\t_____________________________________\n\n\n"");

        for (counter=1; counter &lt;= NUMBER_OF_DAYS; counter++) {
            switch (counter) {
                case 1:
                    day=FIRST_DAY;
                    break;
                case 2:
                    day=SECOND_DAY;
                    break;
                case 3:
                    day=THIRD_DAY;
                    break;
                default:
                    snprintf(buffer, BUFFER_SIZE,""%d"",counter);
                    day=strcat(buffer, N_DAY);
                    break;
                }

            printf(FIRST_ANNOUNCE, day);

            for (index=counter; index &gt; 0; index--) {
                // If there is only one sentence 
                if (counter == LAST_DAY) {
                    printf(sentences[ONLY_ONE_SENTENCE]);
                } else {
                    printf(sentences[index]);
                }
            }
        }

        getchar();
    }
</code></pre>
",0
18182793,18182741,2,"<p>This is because you are allowed to omit the <code>{}</code> providing the the if block or else block have only one statement.</p>

<p>Thus the C people have call this idiom a if single statement.</p>
",4
18182805,18182741,3,"<p>Both <code>if</code> and <code>else</code> will only find the next statement, including a block.</p>

<p>First, a block is a statement:</p>

<p>C11 6.8 Statements and blocks</p>

<blockquote>
  <p>A block allows a set of declarations and statements to be grouped into one syntactic unit.
  The initializers of objects that have automatic storage duration, and the variable length
  array declarators of ordinary identifiers with block scope, are evaluated and the values are stored in the objects (including storing an indeterminate value in objects without an
  initializer) each time the declaration is reached in the order of execution, as if it were a statement, and within each declaration in the order that declarators appear.</p>
</blockquote>

<p>Now Let's see how C defines a selection statement(i.e, <code>if</code>&amp;<code>else</code> and <code>switch</code> statement) using the concept of block:</p>

<p>C11 6.8.4 Selection statements</p>

<blockquote>
  <p>A selection statement is a block whose scope is a strict subset of the scope of its
  enclosing block. Each associated sub statement is also a block whose scope is a strict
  subset of the scope of the selection statement.</p>
</blockquote>
",0
18182823,18182741,4,"<p>The semicolon terminates the statement processed in the <code>if()</code> clause, not the <code>if</code> it self. If you use braces it looks like this:</p>

<pre><code> if(1)
 {
     do_true_branch();   &lt;== ';' terminates the statement
 }
 else
 {
     do_false_branch();   &lt;== ';' terminates the statement
 }
</code></pre>

<p>If you only have one statement, you can ommit the braces, but the ';' is still needed for the statement.</p>
",0
18182828,18182741,-5,"<p>If you start with C just try to forget that it is possible and choose:</p>

<pre><code>if (exp) {
  doX; 
} else {
  doY;
}
</code></pre>

<p>just to avoid a lot of errors in your future.</p>

<hr>

<p>People ask: <strong>Why does this answer the question?</strong></p>

<p>It answers it in a way that an awful lot of errors show up because the answer seems to be that obvious to most C programmers. Folowing errors are not of <em>theoretical</em> nature.</p>

<pre><code>if(exp) dox; doy;
</code></pre>

<p>or</p>

<pre><code>if(exp)
  dox;
  doy;
</code></pre>

<p>or </p>

<pre><code>if(exp) dox;
  doy;
</code></pre>

<p>code. Thats not theretically. So I advice myself to insert {} as often as my brain allows me to, just to avoid those kind of errors. It is just to hard to find them later on.</p>
",2
18182928,18182741,0,"<pre><code>if(condition)
{
...
...
}
</code></pre>

<p>can be placed where ever a statement like 
    int x = 5;
can be placed. else can not appear without an if. So together it is called a single statement.</p>
",0
18182956,18182741,0,"<p>In this <a href=""http://msdn.microsoft.com/en-us/library/fh88ctk1.aspx"" rel=""nofollow"">documentation</a> you can find the answer. The <code>if</code> is the <em>selection statement</em> which takes a statement or compound statement as its body. Or two if you also use the <code>else</code> part.</p>

<p>When you supply a <a href=""http://msdn.microsoft.com/en-us/library/ce4b8s02.aspx"" rel=""nofollow"">compound statement</a> (in the curly braces), you don't need an extra semicolon.</p>
",0
18182866,18182741,6,"<p>In C, there are statements that contain other statements -- such statements are not terminated by a semicolon. An <code>if</code> statement is a <em>selection statement</em> that can <em>contain</em> one or two statements (that may in turn be <em>compound statements</em> -- curly brace blocks containing any number of statements), while itself being a single statement. An <code>if</code> statement is considered a single statement because it can be placed wherever a statement can occur.</p>

<p>Consider expressions: <code>1</code> is an expression, but so is <code>1+1</code> and so is <code>(1+(1+1)*(1-1))/1*(1%1)</code> ... that's one expression, containing other expressions. </p>

<p>Or think of a political division. For instance, the United States is a political division, but it contains states, which are political divisions, and states contain counties which contain cities ... all political divisions.</p>

<p>Edit: In regard to a question you asked in a comment ... there is no ""else statement"". Rather, an <code>if</code> statement has an optional else part:</p>

<pre><code>if (condition) statement1 [else statement2]
</code></pre>

<p>The semicolons in your example terminate the inner statements; no semicolon is required to end the <code>if</code> statement as a whole. For example,</p>

<pre><code>if (exp)
{ do1(); do2(); do3(); }    // statement1
else
{ do4(); do5(); }           // statement2
// no semicolon ending if statement
</code></pre>

<p>Here, statement1 and statement2 are blocks, which aren't terminated by semicolons, just as the <code>if</code> statement as a whole isn't terminated by a semicolon.</p>

<p>Edit in response to the question below:
The <em>exact</em> definition of a single statement is given in the C standard and is quite complex because it entails nearly the entire C grammar ... I'm trying to give a more conceptual overview. A statement is an executable component of the program that does not have a value (as opposed to expressions, which do have a value). Generally, statements are either non-compound statements that end in a semicolon, such as</p>

<pre><code>x = 5;
</code></pre>

<p>or</p>

<pre><code>return;
</code></pre>

<p>... or they are compounded statements that do not end in a semicolon, although they may appear to if their last component does, e.g.,</p>

<pre><code>while (1)
    do_something();
</code></pre>

<p>or</p>

<pre><code>while (1) {
    do_something();
}
</code></pre>

<p>Clearly, neither of those semicolons ends the while statement, they end the inner statements.</p>
",2
18675475,18675457,3,"<p>This is called ""undefined behavior"", which means that program can do just about anything.</p>

<p>What is actually happening in this case is that both variables and function parameters are put on the stack.  Since you aren't passing the parameter that printf is expecting, it ends up pulling something else off the stack, which is your <code>b</code> variable.</p>

<p>But because it is undefined behavior, if you had a different compiler, a different CPU, or even different compile options, such as a higher optimization level, you could get very different results.</p>
",4
18675482,18675457,5,"<p>The 11 is on the stack because of the <code>b</code> variable, and your <code>printf()</code> function is looking on the stack for a value on the stack because that's where variables get passed.</p>

<p>If you add a <code>c=47</code>, you'll probably get 47.  But this is undefined behavior.</p>
",2
18261819,18261707,0,"<p>The problem lies within your nested loops. You are implementing a swap but not considering all of the elements in the array. To fix this, change the following:</p>

<pre><code>for ( i = 0 ; i &lt; n; i++ ) {
  for ( j = 1; j &lt; n; j++ ) {
</code></pre>

<p>... to:</p>

<pre><code>for ( i = 0 ; i &lt; n; i++ ) {
  for ( j = 0; j &lt; n; j++ ) {
</code></pre>

<p>... and these two loops will sort your array in O(n^2) time. You can do better if you implement other sorting algorithms (and do so properly), I would suggest optimizing your code. Consider this implementation of a bubble sort:</p>

<pre><code>bool swapped;

do {
  swapped = false;

  for ( int i = 0; i &lt; ( n - 1 ); i++ ) {
    if ( a[ i ] &gt; a[ i + 1 ] ) {
      int const temp = a[ i ];

      a[ i ] = a[ i + 1 ];
      a[ i + 1 ] = temp;

      swapped = true;
    }
  }
} while ( swapped == true );
</code></pre>
",0
18261931,18261707,4,"<p>Please be more organized with your code!</p>

<p>Here is a neater-looking version of it:</p>

<pre><code>#include &lt;stdio.h&gt;

void swap(int* a, int* b)
{
    int t = *a;
    *a = *b;
    *b = t;
}

void selectionSort(int a[], int n)
{
    int i, j;
    for (i = 0; i &lt; n; i++)
        for (j = i + 1; j &lt; n; j++)
            if (a[i] &gt; a[j])
                swap(&amp;a[i], &amp;a[j]);
}

main()
{
    int n;
    printf(""Enter the number of elements: "");
    scanf(""%d"", &amp;n);

    int a[n], i;
    printf(""Enter the array:\n"");
    for (i = 0; i &lt; n; i++) scanf(""%d"", &amp;a[i]);

    selectionSort(a, n);

    printf(""The array looks like this:\n"");
    for (i = 0; i &lt; n; i++) printf(""%d "", a[i]);
}
</code></pre>
",0
18261941,18261707,0,"<pre><code>for(i=0;i&lt;n;i++)
{
  for(j=0;j&lt;n;j++)
  {
   if (j != i){
    if(a[i]&gt;a[j])
    {
      p=a[j];
      a[j]=a[i];
      a[i]=p;
    }
   }
  }
</code></pre>
",0
18261980,18261707,0,"<p>if you are familiar with the concept of recursion then I would recommand you the quicksort algorithm , here's how it works :</p>

<pre><code>int qsort(int arr[] ,int lenght)
{
        int pivot , i = 0 , l = lenght - 1;
        const int MIN = 0 , MAX = l;
        if(lenght &lt; 2)
                return;
        srand(time(NULL));
        pivot = arr[(rand() % (MAX - MIN + 1)) + MIN];
        while(i &lt; l)
        {
                while(arr[i] &lt; pivot)
                        i++;
                while(arr[l] &gt; pivot)
                        l--;
                swap(arr , i , l);
        }
        qsort(arr , i);
        qsort(&amp;arr[i + 1] , lenght - 1 - i);
}       
int swap(int arr[] , int elem1 , int elem2)
{
        int temp;
        temp = arr[elem1];
        arr[elem1] = arr[elem2];
        arr[elem2] = temp;
}
</code></pre>

<p>but be careful because this only works if every element of the given array is unique .</p>
",0
18261983,18261707,0,"<p>Just a rectification in your code!  </p>

<p>According to comparision condition <code>(a[i] &gt; a[j])</code>, your code perform swapping if inner loop's <code>j</code> indexed elements are smaller then outer loop's <code>i</code> indexed element in array. And you start your inner loop from <code>j = 1</code> so it doesn't checks and short 0<sup>th</sup> indexed element So <code>a[0]</code> remains unsorted. </p>

<pre><code>  if(a[i] &gt; a[j])

  when i = 0           

  if(a[0] &gt; a[j]) == never true as a[0] is smallest element and j start with 1
</code></pre>

<p>You just need to start inner loop from <code>j = 0</code> to make it work correctly.  </p>

<pre><code> for(j = 0; j &lt; n; j++)
  //     ^ its 0 not 1  
</code></pre>

<p>And here your code working: @<a href=""http://codepad.org/XJyPUJT6"" rel=""nofollow"">codepade</a></p>

<p><strong>Note</strong> as you starts with <code>j = 0</code> then </p>

<pre><code>  if(a[i] &gt; a[0]) becomes true when i &gt; 0 
</code></pre>
",1
18262683,18261707,1,"<p>Simply change your inner ""for"" loop as follows:</p>

<pre><code>      for(j=1;j&lt;(n-i) ;j++)
      {
        if(a[j-1]&lt;a[j])
        {
          p=a[j-1];
          a[j-1]=a[j];
          a[j]=p;
        }
</code></pre>

<p>This allows you to traverse your entire array ""n"" times as needed to bump the greater number between two consecutive array elements down 1 until the entire list is sorted.  So using your example of 1, 2, 3, 4 ,5 with n = 5, the ""snap shots"" of the array after the inner for loop is executed are [51234], [54123], [54312] , [54321] at which point i=4 so the for loop test fails and your array is sorted . . . Hope this helps </p>
",0
18262695,18261707,0,"<p>Switching to initializing <code>j</code> to <code>i+1</code> is sufficient to fix the program.  In addition, the code as written will sort an <em>ascending</em>, not <em>descending</em> order.</p>

<p>The code is attempting to perform a <a href=""https://en.wikipedia.org/wiki/Selection_sort"" rel=""nofollow"">selection sort</a>.  The principle at work here is that we select the minimum element from the array, put it in the <code>0</code>th slot, then select the minimum of the <em>remainder</em>.  The algorithm as implemented is selecting the minimum from the <em>entire</em> list, which means that elements that were already correctly placed are being removed and put back in the wrong location.</p>
",2
20759231,20759206,2,"<p>Your code that allocates the structure is fine and does exactly what you want.</p>

<p>The code that looks for zeros is not fine. Since it reads past the allocated memory it results in <a href=""http://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow"">undefined behaviour</a>.</p>

<p>In other words, you cannot check whether a particular address has been <code>calloc()</code>ed by reading it and comparing the result to zero.</p>

<p>Once you fix the undefined behaviour, you'll be left with a memory leak: you need to <code>free()</code> each element of <code>matrix</code> before <code>free()</code>ing <code>matrix</code> itself.</p>
",2
20761578,20759206,0,"<p>You have allocated memory for a stair like pattern successfully, but while traversing, you are not following that.</p>

<p>Instead of </p>

<pre><code>for (int i = 0; i &lt; n; ++i)
{   
    for (int j = 0; j &lt;n; ++j)
    {
    ...
</code></pre>

<p>you have to do </p>

<pre><code>for (int i = 0; i &lt; n; ++i)
{   
    for (int j = 0; j &lt;i+1; ++j)
    {
</code></pre>

<p>If you go beyond <code>i+1</code> in the inner loop, you may get a <code>segmentation fault</code> as you have not allocated memory for that.</p>
",0
20646163,20646061,4,"<p>Multiple reasons. You're only allocating room for 30 characters, so a <code>strlen</code> will never return a result <code>&gt; 30</code> in your case. You're also only reading max 30 chars in your <code>fgets</code> call.</p>

<p>A possible fix is to allocate more space to begin with and use <code>strlen</code>. Another solution is to keep the limited allocation, and use a loop to read individual characters from <code>stdin</code> - if you don't reach a newline character in time, you just break out and return.</p>

<p>On POSIX systems, <code>getline</code> provides a neat solution. It reads a whole line, and it returns the length. Only thing to remember is that <code>getline</code> allocates memory on the heap, so you need to free it when you're done.</p>

<p>Something along the lines of:</p>

<pre><code>char *filename = NULL;
size_t linecap = 0; // These initial values tells getline to allocate as much space as needed
ssize_t linelen = getline(&amp;filename, &amp;linecap, stdin);
if (linelen &lt; 0)
    ...
if (linelen &gt; 30)
    // Treat as error or whatever

free(filename);
</code></pre>

<p>(shameless borrowing from the man page)</p>
",3
20646795,20646061,0,"<pre><code>    char fileName[30+2];//+1 for '\n', +1 for '\0'
    int i;
    int length = 0;

    printf(""Please enter a file name (Maxium 30 characters): "");
    fgets(fileName, sizeof(fileName), stdin);

    if(fileName[0] == '\n'){
        return;
    }
    length = strlen(fileName);
    if(fileName[length-1]!='\n'){
        return;
    }
</code></pre>
",9
18385669,18385169,1,"<p>You have an old version of the mp123 library, according to the release notes it was added in 26.0.26
<a href=""https://github.com/gypified/libmpg123/blob/master/NEWS.libmpg123"" rel=""nofollow"">https://github.com/gypified/libmpg123/blob/master/NEWS.libmpg123</a></p>

<blockquote>
  <p>26.0.26
  - Added mpg123_encsize().
  - Added flag MPG123_SKIP_ID3V2.</p>
</blockquote>
",0
18626749,18626725,0,"<p>Your error is here </p>

<pre><code>int maxSoFar, i = 0
</code></pre>

<p>You never declared maxSoFar so it's using garbage data. </p>

<p>Initialize it to 0, and you should be good.</p>
",0
18626751,18626725,1,"<p><code>maxSoFar</code> is having some arbitrary data, so you need to initialize it first</p>

<pre><code>int maxSoFar = 0, i = 0;
     ^^Initialize to zero
</code></pre>
",4
18626766,18626725,0,"<p>It gives you a garbage value because you never initialize <code>maxSoFar</code>. This means that it will have the value of whatever was left in memory at that point.</p>
",0
18626995,18626725,0,"<p>You main issue is that <code>maxSoFar</code> is a local(automatic) variable and is therefore if it is not initialized it will have an indeterminate value, so the results of this program are also indeterminate. The fix would be to properly initialize <code>maxSoFar</code>, probably to the first element of <code>array</code>.</p>

<p>For completeness sake, the relevant section of the C99 draft standard is <code>6.7.8</code> <em>Initialization paragraph 10</em> which says:</p>

<blockquote>
  <p>If an object that has automatic storage duration is not initialized explicitly, its value is
  indeterminate.[...]</p>
</blockquote>
",0
20022619,20020867,1,"<p>If one is reading from a file to do string processing (a text file), insure the file is opened in <em>text</em> mode.  </p>

<p>Files opened in text mode on systems that use something other than <code>""\n""</code> to indicate the end-of-line like <code>""\r\n""</code> or <code>""\n\r""</code> or <code>""\r</code> will transform that into  <code>""\n""</code>.  Other processing may happen too concerning Byte-order-marks (BOM or end-of-file characters (^Z).</p>

<pre><code>FILE *fp;
fp = fopen(""fielanme"", ""r""); 
</code></pre>

<p>OTOH, if open wants to open the file in binary, be prepared for variant line endings.</p>

<pre><code>FILE *fp;
fp = fopen(""fielanme"", ""rb""); 
</code></pre>
",0
18606051,18605949,0,"<p>Read in character by character and convert that to a numeral using the while loop in Jonathan's answer. Every time you read a numeral, simply multiple your current sum by 10, and add the number. That way by the time you read the last numeral and add it in, you'll have the correct number.</p>
",0
18605989,18605949,1,"<p>Your code :  </p>

<pre><code>#include &lt;stdio.h&gt; 
#include&lt;ctype.h&gt;
int main() {
    int c;//getchar() returns integer
    int x;

    printf(""Num here: "");

    x=0;    
    //As @Jonathan Leffler  suggested ,  
    //usage of while loop like this is very helpful the moment you press Enter loop breaks.  

    while (isdigit(c = getchar())) //isdigit is a function from ctype.h checks for Entered character is digit or not
        x = x*10 + c - 48; //here '0'==48   
    printf(""%d"",x);  
    }
</code></pre>

<p>when you enter 42  </p>

<pre><code>loop rotates two times for c==4 and c==2
c==4 
x=0*10+'4'-48 //here '4'==52 ==&gt;  x=0+52-48  ==&gt;x=4
c==2
x=4*10+'2'-48 //here '2'==50 ==&gt; x=40+50-48 ==&gt;x=42  
</code></pre>

<p>to add ones digits to tens and then hundreds ...  if you want to add digits in input number use this below while loop  </p>

<pre><code>int sum=0,num;
//read num
while(num&gt;0)
{
sum=sum+num%10; //get the last digit and add to sum
num=num/10; //reduce last digit of num
}  
</code></pre>
",0
18606005,18605949,8,"<p>Normally, you'd use:</p>

<pre><code>int c;  // Because getchar() returns an int, not a char
int x = 0;

while ((c = getchar()) != EOF)
{
    if (isdigit(c))
        x = x * 10 + (c - '0');
    else
        ...
}
</code></pre>

<p>This reads a character each time it reaches the top of the loop.  You get the loop to go back by running into the brace at the end of the loop (or, occasionally, by using a <code>continue</code> statement). You might exit the loop with a <code>break</code>, for example if you read some character that can't be part of a number.</p>

<p>If the user types <code>42</code> (followed by <kbd>Enter</kbd>), then you first read <code>c == '4'</code> and then <code>c == '2'</code> and then you read newline <code>'\n'</code>.  For every digit from <code>'0'</code> to <code>'9'</code>, <code>digit - '0'</code> yields the number corresponding to the digit.  The newline can't be part of the number, so you either put it back with <code>ungetc(c, stdin)</code> or break the loop when you've read it.</p>

<p>Beware of overflow if the user types 43219876543 where you expected just 42 (and <code>int</code> is a 32-bit quantity).</p>

<p>You could write the loop condition as:</p>

<pre><code>while ((c = getchar()) != EOF &amp;&amp; isdigit(c))
</code></pre>

<p>or even:</p>

<pre><code>while (isdigit(c = getchar()))
</code></pre>

<p>I'd be extremely reluctant to actually put the latter into production code but it is, in theory, safe.</p>

<hr>

<blockquote>
  <p>How could I treat each number individually so that I can use the entirety of the numbers later on? So that if the user types <code>10 20 30</code>, I can multiply <code>10</code> by <code>20</code>, then (<code>10*20</code>) by <code>30</code>?</p>
</blockquote>

<p>Wheels within wheels ¡ª or loops within loops. You'll need to specify your criteria a bit. If the user types <code>1</code> you want the answer <code>1</code>; if they type <code>1 2</code>, you want <code>2</code>; if they type <code>1 2 3</code>, you want <code>6</code>; and so on (where these are all the numbers on a single line of input). You'll need an outer loop that skips over blanks and tabs, then uses the inner loop to read a number, and then multiplies the current product (initial value <code>1</code>) by the new number, and after the outer loop, you'll print the product. This will print <code>1</code> for an empty line; maybe that doesn't matter (and maybe it does).</p>

<p>Here's some code that approximates what is appropriate:</p>

<pre><code>#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;

int main(void)
{
    int c;
    while ((c = getchar()) != EOF &amp;&amp; c != '\n')
    {
        int product = 1;
        while (c != EOF &amp;&amp; c != '\n')
        {
            while (isspace(c))
                c = getchar();
            int number = 0;
            while (isdigit(c))
            {
                number = number * 10 + (c - '0');
                c = getchar();
            }
            printf(""Number:  %d\n"", number);
            product *= number;
        }
        printf(""Product: %d\n"", product);
    }
    return 0;
}
</code></pre>

<p>I also tried a version with a slightly different 'skip' loop:</p>

<pre><code>            while (c != EOF &amp;&amp; c != '\n' &amp;&amp; !isdigit(c))
                c = getchar();
</code></pre>

<p>Both work OK on sane inputs.  Empty lines are treated as end of input; lines containing blanks are not.  If you input <code>1a2b3c</code> with the second condition, you will get the output <code>0</code>; with the first, you get an infinite loop.  There is no overflow protection; don't try doing factorial 20 and expect the correct answer (with 32-bit <code>int</code>).  Tweak to your heart's content.</p>
",11
18606238,18605949,0,"<p>Sometimes the way we think a problem should be solved, can be solved in a different method when all of the languages capabilities are considered.</p>

<pre><code>#include &lt;stdio.h&gt;
int main() {
    int x;

    printf(""Num here: "");
    scanf(""%d"", x);

}
</code></pre>

<p>implements the same functionality as your program.</p>
",0
18980422,18979865,3,"<p>Linguistically the phrase <code>unary-operator: one of &amp; * + - ~ !</code> means that they are unary operators, but not necessarily the only unary operators. If the phrase is instead interpreted mathematically one might think they are the only unary operators.</p>

<p>The title of the chapter is ""Unary Operators"" which indicates that the first interpretation is the correct one. <code>++</code>, <code>--</code>, casts, and <code>sizeof</code> are also unary operators.</p>
",2
18861365,18861255,1,"<p>Add *strP = '\0' after the last while loop to terminate the string.</p>

<p>Also, (*quoP != NULL) should be (*quoP != '\0') .  The type of NULL is pointer, the type of *quoP is character.  Your program will still work, but it's misleading.</p>

<p>Also might want to include ctype.h</p>

<p>Good luck with the rest of your project.</p>
",0
18861391,18861255,0,"<p>The first loop doesn't work fine.  If it encounters unhandled punctuation (such as <code>&amp;</code>), it will skip right over and leave junk there.</p>

<p>You do not null-terminate the string either, as others have pointed out in the comments.  You would do better to copy the string first (with <code>strncpy</code>) and then stamp characters with <code>*</code> as you deem appropriate.  That means you only have one loop, and it'll be a lot simpler:</p>

<pre><code>strncpy( strArr, quote, sizeof(strArr) );
for( char *s = strArr; !strchr("".!?"", *s); s++ )
{
    if( isalpha(*s) ) *s = '*';
}
</code></pre>

<p>Also, <code>NULL</code> is a pointer.  Null-termination is an unfortunate name for this.  You can write the value <code>0</code> or <code>'\0'</code>, but not <code>NULL</code>.</p>
",0
18900050,18899904,3,"<p>First, many of your secondary <code>if</code> statements are using the assignment operator <code>=</code> and not the comparison <code>==</code>.</p>

<p>Second, where is <code>i</code> supposed to be set initially?  If your goal is for <code>x</code> to be the value from the array, just set it: <code>x = dec[day1]</code></p>
",1
18976737,18976670,0,"<p><a href=""http://man7.org/linux/man-pages/man3/strtol.3.html"" rel=""nofollow"">strtol</a> and <a href=""http://www.cplusplus.com/reference/cstdlib/atoi/"" rel=""nofollow"">atoi</a> takes the address of a char array (<code>char*</code> then) as input for conversion (an integer can be coded on multiple chars).
The correct way to use it :</p>

<pre><code>a[k] = atoi (&amp;str1[k]);
a[k] = strtol(&amp;str1[k],NULL,16);
</code></pre>
",0
18976743,18976670,0,"<p>Those functions take string arguments, not individual chars.</p>

<p>If you want the value of an individual character, it is fairly simple:</p>

<pre><code> a[k] = str1[k] - '0';
</code></pre>

<p>If <code>str[k]</code> is the digit '7', the integer value of <code>a[k]</code> will be 7.</p>

<p>This uses the value of the '0' character, presuming that the execution character set gives '0' - '9' consecutive values.  This is a safe assumption since it is dictated by (e.g.) 5.2.1.3 of the ISO C99 draft:</p>

<blockquote>
  <p>In both the source and execution basic character sets, the value of
  each character after 0 in the above list of decimal digits shall be
  one greater than the value of the previous.</p>
</blockquote>

<p>I.e., if '0' == 48, then '1' == 49, etc.</p>

<hr>

<p>If you just want the value of an integer that <em>begins</em> in a string at <code>str[k]</code>, use the address of operator:</p>

<pre><code>a[k] = strtol(&amp;str1[k],NULL,16);
</code></pre>

<hr>

<p>If you need to work with hexadecimal digits, you could assume that your execution character set also encodes 'a' to 'f' sequentially, which is a pretty safe assumption (ASCII and unicode and every other common encoding do this); you could then use a function that tests the range of the value and assigns based on that (if between '0' and '9', subtract '0', if between 'a' and 'f', subtract 'a').  But if you are really really paranoid, you could create a look-up table:</p>

<pre><code>char hexDigitLookup[256];  // The normal range of a char.
memset(hexDigitLookup, -1, 256);
hexDigitLookup['0'] = 0;
hexDigitLookup['1'] = 1;
hexDigitLookup['2'] = 2;
hexDigitLookup['3'] = 3;
hexDigitLookup['4'] = 4;
hexDigitLookup['5'] = 5;
hexDigitLookup['6'] = 6;
hexDigitLookup['7'] = 7;
hexDigitLookup['8'] = 8;
hexDigitLookup['9'] = 9;
hexDigitLookup['a'] = 10;
hexDigitLookup['b'] = 11;
hexDigitLookup['c'] = 12;
hexDigitLookup['d'] = 13;
hexDigitLookup['e'] = 14;
hexDigitLookup['f'] = 15;     
</code></pre>

<p>So, <code>a[k] = hexDigitLookup[str1[k]]</code> will yield the correct value if <code>str[k]</code> is a hexadecimal digit, and -1 otherwise, regardless of how the execution character set is laid out.  You should first check that <code>str[k]</code> is not &lt; 0, of course, which it could be when parsing e.g. unicode.  You could instead cast to <code>(unsigned char)</code>.</p>
",5
18976774,18976670,0,"<p><code>atoi</code> expects a string, so any variant of <code>char*</code>, try this one :</p>

<pre><code>a[k] = atoi (str1+k);
</code></pre>
",0
18981771,18981654,0,"<p><code>man 3 printf</code> (or <a href=""http://linux.die.net/man/3/printf"" rel=""nofollow"">this</a>) will give you the format codes for all integer types.  You'll see that you're using the wrong ones for most of your results, e.g. you're using <code>""%li""</code> for an <code>int</code>, instead of <code>""%d""</code>.  Also, the result of substracting the minimum value from the maximum value is generally not representable in the same integer data type and needs casting.</p>
",2
18982097,18981654,1,"<p>You have several problems:</p>

<p>Use <code>d</code> for signed integers.</p>

<p>Use <code>u</code> for unsigned integers.</p>

<p><code>char</code> and <code>short</code> are promoted to <code>int</code>. Don't add <code>ll</code> or <code>l</code> to them.</p>

<p>Add <code>l</code> with <code>long</code> types, not <code>ll</code>.</p>

<p><strong>Edit:</strong></p>

<p>To clarify:</p>

<pre><code>int == %d
unsigned int == %u
long == %ld
unsigned long == %lu
</code></pre>

<p>Also you cannot represent range of signed integer with the same data type, you need to use bigger type. <code>INT_MAX-INT_MIN</code> won't work. It needs to be <code>(long)INT_MAX-(long)INT_MIN</code> and you need to use <code>%ld</code> to display it. And even that won't work if <code>sizeof int == sizeof long</code>.</p>
",6
18982990,18981654,0,"<p>Change:</p>

<pre><code>fprintf(fp,""int    %li    %li    %lu\n\n"",(INT_MIN,INT_MAX,INT_MAX-INT_MIN));
</code></pre>

<p>to:</p>

<pre><code>fprintf(fp,""int    %li    %li    %lu\n\n"", INT_MIN,INT_MAX,INT_MAX-INT_MIN);
</code></pre>

<p>Funny bug. Your compiler should have caught it and given you warning that the number of arguments to <code>printf</code> is wrong. Do you compile with warning enabled? If not, you should. And definitely not ignore the warnings. </p>
",1
19564070,19558370,0,"<p>Arrays are always passed as reference. You need to pass address of array to actual parameters and accept it using pointer in formal parameter. Below code should work for you.</p>

<pre><code>void sample(int *b)     //pointer will store address of array.
{

     int i;
     for(i=0;i&lt;3;i++)
         printf(""elements of a array are%d\n"",b[i]);
}        

int main()
{
    int count =3;
    int a[count];
    int i;
    for(i=0;i&lt;count;i++)
{
    a[i]=4;
}

for(i=0;i&lt;count;i++)
{
    printf(""array has %d\n"",a[i]);
}
sample(a);    //Name of array is address to 1st element of the array.

}
</code></pre>
",0
19565481,19558370,0,"<p>To pass a complete array to a function you need to pass its base address i.e.&amp;a[0] and its length. You can use the following code:</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;
void sample(int *m,int n)
{
 int j;
 printf(""\nElements of array are:"");
 for(j=0;j&lt;n;j++)
 printf(""\n%d"",*m);
}
int main()
{
int a[3];
int i;
for(i=0;i&lt;3;i++);
{
   a[i]=4;
}
printf(""\nArray has:"");
for(i=0;i&lt;3;i++)
{
    printf(""\n%d"",a[i]);
 }
sample(&amp;a[0],3)
getch();
return 0;
}
</code></pre>
",0
19265659,19265459,2,"<p>I'm going to interpret your question as ""This problem seems overwhelmingly big, although I know lots of pieces I can't get any traction, I just don't know how to start.""</p>

<p>And such a paralysing feeling is not uncommon when faced with large tasks, whether programming or not. One major trick is to decompose the problem into smaller bits, and write some of the bits. Once you get started things may become less intimidating.</p>

<p>Here I would start by printing the answer. You might say ""but we don't know the answer yet"" and I say ""just pretend""</p>

<pre><code> int base = 10;

 char * resultMantissa = ""34567"";
 int resultExponent = -1;
</code></pre>

<p>Now how would you print the required 3456.7 ?</p>

<p>Then work backwards, if you have some input mantissa and exponent, how would you compute the result. Then how do you get the input? Work step by step. </p>
",0
19266573,19266523,1,"<p>Consider using a string for <code>rea_type</code> as it will be more robust to bad input than a single char, i.e. change:</p>

<pre><code>char rea_type;
</code></pre>

<p>to:</p>

<pre><code>char rea_type[20];
</code></pre>

<p>and:</p>

<pre><code>  scanf(""%c"",&amp;rea_type);
</code></pre>

<p>to:</p>

<pre><code>  scanf(""%s"", rea_type);
</code></pre>

<p><br></p>

<hr>

<p>Also note that you should ideally change both:</p>

<pre><code>  scanf(""%s"",&amp;c_Digit);
</code></pre>

<p>and:</p>

<pre><code>  scanf(""%s"",&amp;premis_numb);
</code></pre>

<p>to:</p>

<pre><code>  scanf(""%s"", c_Digit);
</code></pre>

<p>and:</p>

<pre><code>  scanf(""%s"", premis_numb);
</code></pre>

<p>You don't need to take the address of a string, as it's already effectively a pointer. It doesn't matter in this particular case but it's a good habit to get into as when the strings really are pointers (rather than arrays).</p>
",5
19266688,19266523,0,"<p><em>You don't need to pass a reference of char[]</em>.  premin_num &amp; c_Digit are the starting address of the char[]. Do like this</p>

<pre><code> scanf(""%s"",premis_numb);
 scanf(""%s"",c_Digit);
</code></pre>

<p>One possible reason your compiler is skipping input in <code>rea_type</code> scanf is because there was a newline entered by the user, <code>so if there's a stray newline in the input stream (from a previous entry, for example) the scanf call will consume it immediately &amp; skip taking input.</code></p>

<p><strong>Solution:</strong></p>

<p><em><strong>provide space before</em></strong> <code>%c</code></p>

<pre><code>scanf("" %s"",&amp;rea_type);
</code></pre>
",0
19266714,19266523,0,"<p>It doesn't skip reading the character, it reads the <em>newline</em> left in the input buffer after the last <code>scanf</code>.</p>

<p>This is simple to fix, by telling <code>scanf</code> to skip leading whitespace:</p>

<pre><code>scanf("" %c"", &amp;rea_type);
</code></pre>

<p>Notice the space before the formatting code.</p>
",2
19435905,19435767,0,"<p>you should write different components differently, check samples:</p>

<pre><code>fwrite(Data-&gt;stringcomponent, strlen(Data-&gt;stringcomponent)+1, 1, binaryfile); // writes 1 string
fwrite(&amp;Data-&gt;doublecomponent, sizeof(double), 1, binaryfile); // writes 1 double
fwrite(&amp;Data-&gt;intcomponent, sizeof(int), 1, binaryfile); // writes 1 int
</code></pre>

<p>so, instead of single fprintf you will have multiple fwrites for different data, note different kinds of length calculations (strlen+1 or sizeof) and whether you have to add <code>&amp;</code> or not</p>
",4
19435909,19435767,2,"<p>you'd want to do something like : </p>

<pre><code>fwrite (Data , sizeof(ListDataType), 1, fileHandle);
</code></pre>

<p>this will write sizeof(ListDataType) bytes starting from wherever Data points.  If your Data object has any pointers in it - you'd need to define a new struct, copy the values to that and then write the new struct.</p>

<p>if you cannot define a max length for the dynamic string then you could define a struct that includes the string length - write the struct, then the string - that way you'll know how many bytes to read back.   Either way a struct is the nicest way to read and write to a bin file.</p>

<p>Ok - an edit with examples ...</p>

<p>if you define your component structure like :</p>

<pre><code>    typedef struct Component_Struct
    {
        int int1;
        int int2;
        double double1;
        double double2;
        double double3;
        double double4;
        int nameLen;
        char* name;
    }
    COMPONENT, *LPCOMPONENT;
</code></pre>

<p>Note the extra nameLen - fill this value when you assign the values to the structure.</p>

<p>then in your write function : </p>

<pre><code>      FILE * pFile;
      pFile = fopen (""myfile.bin"", ""wb"");

      do
      {
          fwrite(Data-&gt;Component, sizeof(COMPONENT)-sizeof(char*), 1, pFile)
          fwrite(Data-&gt;Component.name, sizeof(char), Data-&gt;Component.nameLen, pFile)
        Data = Data-&gt;nextPtr;
      }
      while(Data !=NULL);


      fclose (pFile);
</code></pre>
",5
19436115,19435767,2,"<p>Since you have one item of variable length data (a dynamically allocated string pointer) you have to decide how you want to manage it in a binary file. You can set aside a fixed length of space for the name within the structure in your output. Or you can write a zero-terminated string and manage it that way. I'll choose the second case since it is more in line with the dynamic string.</p>

<p>This is a bit verbose since the nature of the structure hasn't been given in the problem statement. So the following will work with structure elements in arbitrary order.</p>

<pre><code>void WriteBinaryFile(ListDataType *Data, int numEl)
{
    FILE *bin_file;

    char name[50];

    printf(""\n\nWhat would you like to call the binary file in which the data will be stored?\n""
    printf(""NB remember to add \"".txt\"" after your chosen name!!!\nENTER NAME NOW&gt;&gt;"");
    scanf(""%s"", name);

    bin_file = fopen(name, ""wb+"");

    do
    {
        //NOTE: include terminating zero in the string output; assumes single-byte chars
        fwrite(Data-&gt;component.name, strlen(Data-&gt;component.name)+1, 1, bin_file);
        fwrite(&amp;Data-&gt;component.int1, sizeof(Data-&gt;component.int1), 1, bin_file);
        fwrite(&amp;Data-&gt;component.int2, sizeof(Data-&gt;component.int2), 1, bin_file);
        fwrite(&amp;Data-&gt;component.double1, sizeof(Data-&gt;component.double1), 1, bin_file);
        fwrite(&amp;Data-&gt;component.double2, sizeof(Data-&gt;component.double2), 1, bin_file);
        fwrite(&amp;Data-&gt;component.double3, sizeof(Data-&gt;component.double3), 1, bin_file);
        fwrite(&amp;Data-&gt;component.double4, sizeof(Data-&gt;component.double4), 1, bin_file);
        Data = Data-&gt;nextPtr;
    } while(Data != NULL);

    fclose(bin_file);
}
</code></pre>

<p>If a program needs to read it back, it would start by reading in a name and read characters until it finds a <code>0</code>. Then it would read the other elements per their data types. That process would be repeated for each structure written. This isn't necessarily portable, though. You have to be careful about size of int times, etc.</p>
",0
19570903,19570649,0,"<p>Two things: first you copy pasted ""root1"" twice so you will lose the ""plus"" value and root2 will be zero. Second, for the benefits of others, the problem is most probably at compile time and the googled answer is there:</p>

<p><a href=""http://www.cs.cf.ac.uk/Dave/C/node17.html"" rel=""nofollow"">http://www.cs.cf.ac.uk/Dave/C/node17.html</a></p>

<p>And you should test for imaginary values:</p>

<pre><code>    if(b*b-4*a*c &lt; 0){
      printf(""error: complex solution unsupported, see http://en.wikipedia.org/wiki/Square_root\n"");
      exit(1);
    }
</code></pre>
",0
19570916,19570649,0,"<p>You have a copy-paste bug here:</p>

<pre><code>root1=(-b+sqrt(b*b-4*a*c))/(2*a);
root1=(-b-sqrt(b*b-4*a*c))/(2*a);
</code></pre>

<p>should be:</p>

<pre><code>root1=(-b+sqrt(b*b-4*a*c))/(2*a);
root2=(-b-sqrt(b*b-4*a*c))/(2*a);
</code></pre>

<p>Also you may need to link with the math library, e.g.</p>

<pre><code>$ gcc -Wall foo.c -o foo -lm
</code></pre>
",0
19875553,19875531,-1,"<p>The reason for your wrong answer is because you have kept the datatype as int which has max value of 32767 change it to unsigned long int as your ans calculates to 2400612</p>
",2
19875667,19875531,1,"<p>Your problem is the pointer. I am assuming you initialised the struct as follows.</p>

<pre><code>numbers *numbers;
</code></pre>

<p>However if you use it in the main where you declare it don't use a pointer. There are also a few errors in your printf call, you are printing the memory address of y and z instead of the value like you did for the x value.</p>

<p>Use something like this.</p>

<pre><code>#include &lt;stdio.h&gt;

typedef struct number
{
    int x;
    int y;
    int z;
    unsigned int final;
} number;

int main()
{
  number numbers;

  scanf(""%d %d %d"", &amp;numbers.x, &amp;numbers.y, &amp;numbers.z);
  printf(""input: %d,%d,%d\n"",numbers.x, numbers.y, numbers.z);
  numbers.final=(numbers.x)*4000 + (numbers.y)*50 + (numbers.z);
  printf(""final: %d\n"",numbers.final);

  return 0;
}
</code></pre>

<p>Right and if you used malloc it looks like this.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct number
{
    int x;
    int y;
    int z;
    unsigned int final;
} number;

int main()
{
  number *numbers = malloc(1 * sizeof(number));

  scanf(""%d %d %d"", &amp;numbers-&gt;x, &amp;numbers-&gt;y, &amp;numbers-&gt;z);
  printf(""input: %d,%d,%d\n"",numbers-&gt;x, numbers-&gt;y, numbers-&gt;z);
  numbers-&gt;final=(numbers-&gt;x)*4000 + (numbers-&gt;y)*50 + (numbers-&gt;z);
  printf(""final: %d\n"",numbers-&gt;final);

  free(numbers);

  return 0;
}
</code></pre>

<p>Running example <a href=""http://ideone.com/ibFArb"" rel=""nofollow"">here</a></p>
",7
20094292,20094260,2,"<p>If you have a variable <code>x</code> with a value known to fit into one byte, you can split it into two <a href=""http://en.wikipedia.org/wiki/Nibble"" rel=""nofollow"">nibble</a>s like this:</p>

<pre><code>x_lo = x &amp; 0xf;
x_hi = (x &gt;&gt; 4) &amp; 0xf;
</code></pre>

<p>To combine two <a href=""http://en.wikipedia.org/wiki/Nibble"" rel=""nofollow"">nibble</a>s <code>y_lo</code> and <code>y_hi</code> into one byte you shift and or:</p>

<pre><code>y = y_lo | (y_hi &lt;&lt; 4);
</code></pre>
",5
20094530,20094260,1,"<p>If you aren't too familiar with logical operators, I suggest to introduce two little helper functions to encapsulate this stuff:</p>

<pre><code>void split_nibbles( unsigned char ch, unsigned char *higherOrder, unsighed char *lowerOrder )
{
  *higherOrder = ch &gt;&gt; 4;
  *lowerOrder = ch &amp; 0x0f;
}

 unsigned char merge_nibbles( unsigned char higherOrder, unsigned char lowerOrder )
 {
   return (higherOrder &lt;&lt; 4) | (lowerOrder &amp; 0x0f);
 }
</code></pre>

<p>You can then write</p>

<pre><code>unsigned char bytes[] = { 0xf8, 0xff, 0xff };

unsigned char u, v, w, x, y, z;
split_nibbles( bytes[0], &amp;u, &amp;v );
split_nibbles( bytes[1], &amp;w, &amp;x );
split_nibbles( bytes[2], &amp;y, &amp;z );

bytes[0] = merge_nibbles( x, u );
bytes[1] = merge_nibbles( v, y );
bytes[2] = merge_nibbles( z, w );
</code></pre>

<p>...which is very close to your description. :-)</p>
",2
19969479,19969385,2,"<p>You may have a fundamental design question to deal with.  The data coming in is faster than the rate you can deal with it.  If this is provably a short term situation then moving the do_something to one or more threads and creating a processing queue may be enough.  Make sure you have sufficient buffer space to handle your ""provable"" backlog though. However, if this is a sustained situation then moving to another thread or creating a huge processing queue will not be sufficient (although it is still needed).  In that case, you need to either</p>

<ol>
<li>Slow down/pause the incoming torrent using flow control</li>
<li>Make the accumulated do_something occur faster than things can possibly come in</li>
</ol>

<p>It is unlikely the latter is possible so flow control is likely needed.  Note that in some specific situations, a third solution of dropping packets is available.  This often occurs in the design of monitoring systems (for example).</p>
",1
20198356,20198251,1,"<p>Your error is the fact that your <code>array</code> is of type <code>int</code>.  If you want some other type, you'll have to have an array of that type.</p>
",0
20198394,20198251,0,"<p>The format specifier %d tells scanf to expect an integer. See e.g. <a href=""http://www.cplusplus.com/reference/cstdio/scanf/?kw=scanf"" rel=""nofollow"">here</a>.</p>
",0
20198338,20198251,1,"<p>What do you expect it to do if a non-integer is used as the input? It doesn't seem like it's an error skipping non-integer input, but the correct behavior. If you want it to keep working, you need to handle that error by checking what the user inputs. If the input is not what the program expects, it's up to the coder to resolve that or you'll get unexpected behavior.</p>
",0
20198439,20198251,1,"<p>You need to check if <code>scanf()</code> fails.  If it does, because invalid data was entered, you have to flush the <code>stdin</code> buffer and repeat the <code>scanf()</code> again.</p>
",0
20098151,20098050,3,"<p><code>fputs</code> does not automatically add a newline to the output (in contrast with <code>puts</code> which does). </p>
",0
20098163,20098050,12,"<p><code>gets</code> (which shall not be used and has actually been removed from the most recent C standards) does not save the <code>\n</code> in its buffer (while <code>fgets</code> does).</p>

<p>And <code>fputs</code>, unlike <code>puts</code>, does not automatically insert one at the end of the string it writes. So by adding a <code>fputs(""\n"", fp);</code> (or <code>fputc('\n', fp)</code>) after outputting each typed line, you insert the missing newline in the file.</p>
",0
20102249,20102098,2,"<p>You never initialized <code>sum</code>:</p>

<pre><code>double sum = 0, val;
</code></pre>

<p>Right now, you're using it in your calculation with an uninitialized value, and hence getting some garbage results.</p>
",2
20102263,20102098,1,"<p>First initialize <code>sum</code> and then use it. Otherwise it will invoke <strong>undefined behavior</strong>.</p>
",0
20531326,20531291,2,"<p>You have opened the file in <code>append</code> mode, so there will be nothing to read. Also we don't know the file format, but the assumptions made in your code don't seem to match with writing the structures out to file...</p>

<p>Also: </p>

<ul>
<li><code>fp</code> will never become <code>NULL</code> once you are in the while loop, so the file will never be closed.</li>
<li>You are trying to write entire structures to the file inside the loop (as you are reading it)</li>
<li>What are <code>education1</code> and <code>eductaion1</code> ? You should probably paste your real code.</li>
</ul>
",0
20651103,20651062,1,"<p>You need to dereference the pointers in printf. Right now you're printing the pointer values (i.e. addresses) of s_ptr, m_ptr, and h_ptr.</p>

<p><code>printf(""Time is in ss:mm:hh =  %u:%u:%u\n"", *s_ptr, *m_ptr, *h_ptr);</code></p>

<p>(This is, of course, assuming your other internal time generating functions are working as intended)</p>
",2
19444707,19444583,3,"<p>In the <code>increment_at</code> function you check that you don't increment areas outside the game plan. As it is you only check two sides (<code>x &lt; 0 || y &lt; 0</code>). You also need to check the other two sides (<code>x &gt;= width || y &gt;= height</code>). </p>
",2
