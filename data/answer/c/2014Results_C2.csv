28450515,373142,5,"<p>Not about the compilation time, but about the build time:</p>

<ul>
<li><p>Use <strong>ccache</strong> if you have to rebuild the same files when you are working
on your buildfiles</p></li>
<li><p>Use <strong>ninja-build</strong> instead of make. I am currently compiling a project
with ~100 source files and everything is cached by ccache. make needs
5 minutes, ninja less than 1.</p></li>
</ul>

<p>You can generate your ninja files from cmake with <code>-GNinja</code>.</p>
",0
23589312,832810,-1,"<p>With all due respect, 5 out of 6 points you've mentioned are standard C++ jargon.  That's not ""game programming"" it's naive use of buzz words.  My recommendation would be this;  learn your math...trig especially.  Then get some datasheets and learn about modern graphics hardware platforms...not touchy feely C# bullony words..learn assembler programming.</p>

<p>At the end of the day, to be a game programmer you have to be able to do math.  That's it</p>
",1
28432543,3902011,2,"<p>I would rather use:</p>

<pre><code>size_t size = 10; //or any other size
std::string buff(size, 0); //or: std::string buff(size, '\0');
</code></pre>

<p>Now if you must use the char* buff, then you can use:</p>

<pre><code>&amp;buff[0]
</code></pre>

<p>When you need to use const char* then you can use:</p>

<pre><code>buff.c_str()
</code></pre>

<p>The big advantage is that you don't need to deallocate the memory, stl take care of this for you.
The next advantage is that you can use all of the stl string functions</p>
",0
27682432,544842,9,"<p>As of C++11 you can use a templated type alias</p>

<pre><code>template &lt;typename T&gt;
using MyArray = std::vector&lt;T&gt;;
</code></pre>

<p>If you want to be more generic you can use a variadic template (which would allow for allocators in the case of vector without having to be specific)</p>

<pre><code>template &lt;typename... Ts&gt;
using MyArray = std::vector&lt;Ts...&gt;;
</code></pre>
",0
21784644,1413486,0,"<p>Maybe a bit late, but since <em>StackExchange</em> has <em>Code Review</em>, it worth the answer:</p>

<blockquote>
  <p>Code Review Stack Exchange is a question and answer site for peer
  programmer code reviews. It's 100% free, no registration required.</p>
</blockquote>

<p>Here is the link: <a href=""https://codereview.stackexchange.com/"" title=""Code Review Stack Exchange"">Code Review Stack Exchange</a></p>
",0
28219145,722822,9,"<p>It can be initialized directly in the header file, in c++11 or gnu++11:</p>

<pre><code>int myInt = 1;
</code></pre>

<p>See this article ""<a href=""https://web.archive.org/web/20160316174223/https://blogs.oracle.com/pcarlini/entry/c_11_tidbits_non_static"" rel=""nofollow noreferrer"">C++11 Tidbits: Non-static Data Member Initializers</a>""</p>
",0
29241150,1810348,0,"<p>I am not sure if you are trying to associate a unique number to each book or just if you are keeping track of total number of Book objects constructed so far. If former is the case then you should declare a member variable saying bookNumber in Book class, and in getBooksNumber() you should return the value assigned to the bookNumber variable. Better if you make getBooksNumber() as constant function and if you invoke this function with constant object. </p>

<p>If later is the case where you are keeping track of total number of Book object constructed so far, then you should have a static data member to keep track of it and you can make getBooksNumber() static as well, and can invoke getBooksNumber() without the object of call.</p>
",0
23581728,728068,4,"<p>If you are using:</p>

<pre><code>tstart = clock();

// ...do something...

tend = clock();
</code></pre>

<p>Then you will need the following to get time in seconds:</p>

<pre><code>time = (tend - tstart) / (double) CLOCKS_PER_SEC;
</code></pre>
",0
24638326,798046,1,"<p>you could also do something like this:</p>

<pre><code>//This code will ask the user for an input, set the decimal precision to the hundredths place,  and add 4.63 to the inputted variable

int banana;
cin &gt;&gt; banana;
cout &lt;&lt; setprecision(2) &lt;&lt; fixed &lt;&lt; banana + 4.63; 
</code></pre>
",0
21713911,877523,10,"<p>Adding to the knowledge base, I got the same error for </p>

<pre><code>if(class_iter-&gt;num == *int_iter)
</code></pre>

<p>Even though the IDE gave me the correct members for class_iter. Obviously, the problem is that <code>""anything""::iterator</code> doesn't have a member called <code>num</code> so I need to dereference it. Which doesn't work like this:</p>

<pre><code>if(*class_iter-&gt;num == *int_iter)
</code></pre>

<p>...apparently. I eventually solved it with this:</p>

<pre><code>if((*class_iter)-&gt;num == *int_iter)
</code></pre>

<p>I hope this helps someone who runs across this question the way I did.</p>
",0
24354817,1826159,-1,"<p>single line solution for swapping two values in c language.</p>

<pre><code>a=(b=(a=a+b,a-b),a-b);
</code></pre>
",1
32444720,2085639,2,"<p>I decided to test <a href=""https://stackoverflow.com/a/2085777"">JPvdMerwe's claim</a> that C stdio is faster than C++ IO streams.  (Spoiler: yes, but not necessarily by much.)  To do this, I used the following test programs:</p>

<h3>Common wrapper code, omitted from programs below:</h3>



<pre class=""lang-c++ prettyprint-override""><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
int main (void) {
  // program code goes here
}
</code></pre>

<h3>Program 1: normal synchronized C++ IO streams</h3>

<pre class=""lang-c++ prettyprint-override""><code>for (int j = 0; j &lt; ROWS; j++) {
  for (int i = 0; i &lt; COLS; i++) {
    std::cout &lt;&lt; (i-j) &lt;&lt; ""\t"";
  }
  std::cout &lt;&lt; ""\n"";
}
</code></pre>

<h3>Program 2: unsynchronized C++ IO streams</h3>

<p>Same as program 1, except with <code>std::cout.sync_with_stdio(false);</code> prepended.</p>

<h3>Program 3: C stdio printf()</h3>

<pre class=""lang-c++ prettyprint-override""><code>for (int j = 0; j &lt; ROWS; j++) {
  for (int i = 0; i &lt; COLS; i++) {
    printf(""%d\t"", i-j);
  }
  printf(""\n"");
}
</code></pre>

<hr>

<p>All programs were compiled with GCC 4.8.4 on Ubuntu Linux, using the following command:</p>



<pre class=""lang-bash prettyprint-override""><code>g++ -Wall -ansi -pedantic -DROWS=10000 -DCOLS=1000 prog.cpp -o prog
</code></pre>

<p>and timed using the command:</p>

<pre class=""lang-bash prettyprint-override""><code>time ./prog &gt; /dev/null
</code></pre>

<p>Here are the results of the test on my laptop (measured in wall clock time):</p>

<ul>
<li>Program 1 (synchronized C++ IO): <strong>3.350s</strong> (= 100%)</li>
<li>Program 2 (unsynchronized C++ IO): <strong>3.072s</strong> (= 92%)</li>
<li>Program 3 (C stdio): <strong>2.592s</strong> (= 77%)</li>
</ul>

<p>I also ran the same test with <code>g++ -O2</code> to test the effect of optimization, and got the following results:</p>

<ul>
<li>Program 1 (synchronized C++ IO) with <code>-O2</code>: <strong>3.118s</strong> (= 100%)</li>
<li>Program 2 (unsynchronized C++ IO) with <code>-O2</code>: <strong>2.943s</strong> (= 94%)</li>
<li>Program 3 (C stdio) with <code>-O2</code>: <strong>2.734s</strong> (= 88%)</li>
</ul>

<p>(The last line is not a fluke; program 3 consistently runs slower for me with <code>-O2</code> than without it!)</p>

<p>Thus, my conclusion is that, based on this test, C stdio is indeed about 10% to 25% faster for this task than (synchronized) C++ IO.  Using unsynchronized C++ IO saves about 5% to 10% over synchronized IO, but is still slower than stdio.</p>

<hr>

<p>Ps. I tried a few other variations, too:</p>

<ul>
<li><p>Using <code>std::endl</code> instead of <code>""\n""</code> is, as expected, slightly slower, but the difference is less than 5% for the parameter values given above.  However, printing more but shorter output lines (e.g. <code>-DROWS=1000000 -DCOLS=10</code>) makes <code>std::endl</code> more than 30% slower than <code>""\n""</code>.</p></li>
<li><p>Piping the output to a normal file instead of <code>/dev/null</code> slows down all the programs by about 0.2s, but makes no qualitative difference to the results.</p></li>
<li><p>Increasing the line count by a factor of 10 also yields no surprises; the programs all take about 10 times longer to run, as expected.</p></li>
<li><p>Prepending <code>std::cout.sync_with_stdio(false);</code> to program 3 has no noticeable effect.</p></li>
<li><p>Using <code>(double)(i-j)</code> (and <code>""%g\t""</code> for <code>printf()</code>) slows down all three programs a lot!  Notably, program 3 is still fastest, taking only 9.3s where programs 1 and 2 each took a bit over 14s, a speedup of nearly 40%!  (And yes, I checked, the outputs are identical.)  Using <code>-O2</code> makes no significant difference either.</p></li>
</ul>
",0
21318186,1449324,-5,"<p>Just use the <code>system(""pause"");</code> command.  </p>

<p>All the other answers over complicate the issue. </p>
",0
28445980,1471031,0,"<p>You can make such function, but it wouldn't operate strings. You would have to send variable name. Such a function would try to add 0 to the variable. If it doesn't exists, an error would occur, so you might want to try to make exception handling with <code>try...throw...catch</code> . But because I'm on the phone, I don't know if this wouldn't throw an error anyways when trying to send non-existing variable to the function...</p>
",0
29482290,3845353,-1,"<p>In VS 2012, you will encounter error C4700 if you don't initialize the bool variable: <code>uninitialized local variable 'temp' used</code></p>

<p>However, in VS 2005 it will allow you to build, but during runtime you will encounter this error: <code>Run-Time Check Failure #3 - The variable 'a' is being used without being defined.</code></p>
",0
27178484,1107705,0,"<p>Here's one reason you shouldn't use it: it's going to piss off most anti-virus programs running on Windows if you're passing the program over to another machine because it's a security threat. Even if your program only consists of a simple <code>cout &lt;&lt; ""hello world\n""; system(""pause"");</code>
It's resource heavy and the program gets access to the cmd command, which anti viruses see as a threat.</p>
",0
32428688,2032361,0,"<p>I think that we always define/declare the destructor of any class as virtual especially in an inheritance tree. Then we can say that almost all classes in an inheritance tree are polymorphic.</p>
",0
34258716,3248255,2,"<p>Because according to the C standard, the offset of a field within a class or struct is required to be a compile-time constant. This also applies to when accessing base class fields.</p>

<p>Your example wouldn't work with virtual getters either, as the override requires the same type signature. If that was necessary, your virtual getter would have to return at algebraic type and the receiving code would have to check at run-time if it was of the expected type.</p>
",0
31169961,2354138,0,"<p>If dealing with DLLs and Service EXEs like COM/DCOM or any other ATL project, you can also use this line of code to print out diagnostic messages in the form of <code>MessageBox</code> windows as an alternative to printing messages to the console:</p>

<p><code>MessageBox(NULL, L""Com Object Function Called"", L""COMServer"", MB_OK | MB_SETFOREGROUND);</code></p>

<p>Example cases where I have used this include the <code>_tWinmain</code> function, as well as constructors and destructors to keep track of instances. </p>
",0
26135300,2210837,0,"<p>there used to be an adventure (i.e. text based game) writing language called ALPS and I remember coding a version of this, plus tcp and rudimentary multi user handler, as my first C/C++ project (initially the former, eventually the latter). Project was neatly bite-sized ""modules"" with definitive yardstick and fun end-result: I used it to make a quaint MUD with my mighty 32K BBC Micro. Coding a C/C++ ALPS ended up teaching me the lingos in literally a week - to a decent working standard (far from expert mind you).</p>
",2
26127812,5708259,2,"<p>Having your file(<em>translation unit</em>) not end in a newline is <a href=""http://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow"">undefined behavior</a> which means the behavior of your program becomes unpredictable. Although in C++11 this changes and the pre-processor will behave as if a new-line was there.</p>

<p>It is interesting to note why this is an issue, we can from the draft pre C++11 standard that including a file via <code>include</code> has the following effect from section <code>16.2</code> <em>Source file inclusion</em> which says:</p>

<blockquote>
  <p>A preprocessing directive of the form</p>

<pre><code> # include "" q-char-sequence"" new-line
</code></pre>
  
  <p>causes the replacement of that directive by the entire contents of the
  source file identified by the specifie sequence between the ""
  delimiters.</p>
</blockquote>

<p>so if the included files does not end in a newline how should we deal with the combined last line of the included file and the subsequent line in the source code? There are several obvious issues, for example if the last line in the included file ends:</p>

<ul>
<li>in a comment</li>
<li>in a continuation</li>
<li>in a macro definition</li>
</ul>

<p>it will alter the way the source file using the include will be interpreted which is not a desirable feature. This is also covered in the <a href=""http://c0x.coding-guidelines.com/5.1.1.2.pdf"" rel=""nofollow"">The New C Standard</a>(<em>C also has the same rule</em>) and it says:</p>

<blockquote>
  <p>What should the behavior be if the last line of an included file did
  not end in a new-line? Should the characters at the start of the line
  following the
  #include directive be considered to be part of any preceding preprocessing token (from the last line of the included file)? Or
  perhaps source files should be treated as containing an implicit new-line at their end.
  This requirement simplifies the situation by rendering the behavior
  undefined</p>
</blockquote>

<p>For completeness sake, pre C++11 the draft standard section <code>2.1</code> <em>Phases of translation</em> says (<em>emphasis mine going forward</em>):</p>

<blockquote>
  <p>[...]If a source file that is not empty <strong>does not end in a new-line
  character</strong>, or ends in a new-line character immediately preceded by a
  backslash character, the <strong>behavior is undefined</strong>.</p>
</blockquote>

<p>and the <a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf"" rel=""nofollow"">C++11 draft standard</a> says:</p>

<blockquote>
  <p>[...]A source file that is not empty and that does not end in a
  new-line character, or that ends in a new-line character immediately
  preceded by a backslash character before any such splicing takes
  place, <strong>shall be processed as if an additional new-line character were
  appended to the file.</strong></p>
</blockquote>
",1
26248046,2505328,1,"<p>This one will explain you more than if I use plain words. Try compiling it with any compiler you want :) But note, it's UB according to standards!</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

class Armor
{
public:
    void set(int data)
    {
        cout &lt;&lt; ""set(""&lt;&lt;data&lt;&lt;"")\n"";
        if(!this)
        {
            cout &lt;&lt; ""I am called on NULL object! I prefer to not crash!\n"";
            return;
        }
        this-&gt;data = data;  //dereference it here
    }
    void get()
    {
        if(this) cout &lt;&lt; ""data = "" &lt;&lt; data &lt;&lt; ""\n"";
        else cout &lt;&lt; ""Trying to dereference null pointer detected!\n"";
    }
    int data;
};

int main()
{
   cout &lt;&lt; ""Hello World"" &lt;&lt; endl; 
   Armor a;
   a.set(100);
   a.get();


   Armor* ptr1 = &amp;a;
   Armor* ptr2 = 0;

   ptr1-&gt;set(111);
   ptr2-&gt;set(222);

   ptr1-&gt;get();
   ptr2-&gt;get();

   return 0;
}
</code></pre>

<p>Then read about __thiscall - and all comments above.</p>

<pre><code>Hello World
set(100)
data = 100
set(111)
set(222)
I am called on NULL object! I prefer to not crash!
data = 111
Trying to dereference null pointer detected!
</code></pre>
",9
22428119,2745105,3,"<p>String literals have <strong>static storage class</strong> (they exist for the duration of the program) and may or may not be shared if the same string literal is referenced from multiple locations in a program. The effect of modifying a string literal is undefined; thus, you should always declare a pointer to a string literal as const char *.</p>
",0
21027938,6404079,0,"<p>how about using stoi(). I am sure that it must be fast enough to satisfy your needs.</p>
",0
22480055,2884814,0,"<p>All the answer above doesn't answer the question but are giving some workaround. The answer to the above question is <a href=""http://www.stroustrup.com/bs_faq2.html#virtual-ctor"" rel=""nofollow"">http://www.stroustrup.com/bs_faq2.html#virtual-ctor</a> straight from the language author itself. In short it says you need complete information to construct an object, hence virtual constructor doesn't exist in C++.</p>
",0
32993501,4060601,3,"<pre><code>#include&lt;iostream&gt;
#include&lt;conio.h&gt;
#include&lt;windows.h&gt;
using namespace std;

int main()
{

    Beep(1568, 200);
    Beep(1568, 200);
    Beep(1568, 200);
    Beep(1245, 1000);
    Beep(1397, 200);
    Beep(1397, 200);
    Beep(1397, 200);
    Beep(1175, 1000);

cout&lt;&lt;endl;
_getch()

return 0
}
</code></pre>
",0
21316259,5655142,0,"<p>If you already have the string, you can use this function:</p>

<pre><code>bool isNumber( const string&amp; s )
{
  bool hitDecimal=0;
  for( char c : s )
  {
    if( c=='.' &amp;&amp; !hitDecimal ) // 2 '.' in string mean invalid
      hitDecimal=1; // first hit here, we forgive and skip
    else if( !isdigit( c ) ) 
      return 0 ; // not ., not 
  }
  return 1 ;
}
</code></pre>
",0
29189464,3444997,1,"<p>The answer above helped me to get a <em>""solution""</em> for the question at hand. It is probably not the most elegant, but seems to work. Obviously you can get a bit more creative on the return type. Booleon does not suffice here. I think a native API would be good.</p>

<pre><code>typedef VOID (NTAPI* TRtlGetNtVersionNumbers)(LPDWORD pdwMajorVersion, LPDWORD pdwMinorVersion, LPDWORD pdwBuildNumber);

bool IsRunningCompatMode()
{
    TRtlGetNtVersionNumbers RtlGetNtVersionNumbers = (TRtlGetNtVersionNumbers)GetProcAddress(GetModuleHandleA(""ntdll.dll""), ""RtlGetNtVersionNumbers"");

    assert(RtlGetNtVersionNumbers);

    if(RtlGetNtVersionNumbers)
    {
        OSVERSIONINFO osInfo = {0};
        osInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        GetVersionEx(&amp;osInfo);

        DWORD dwMajorVersion;
        DWORD dwMinorVersion;
        DWORD dwBuildNumber;

        RtlGetNtVersionNumbers(&amp;dwMajorVersion, &amp;dwMinorVersion, &amp;dwBuildNumber);

        dwBuildNumber &amp;= 0x0000FFFF;

        if(osInfo.dwBuildNumber != dwBuildNumber)
        {
            return true;
        }
    }
    return false;
};
</code></pre>
",0
22432900,3862378,9,"<p>In the simplest definition, generic programming is a style of computer programming in which algorithms are written in terms of to-be-specified-later types that are then instantiated when needed for specific types provided as parameters.</p>
",2
29443285,3263873,0,"<p>Volatile keyword is used to inform the compiler not to predict/assume/believe/presume the value of the particular variable which has been declared as volatile. </p>

<p>This variable can change by internal and external sources, so you can definitely change it.</p>

<p>const volatile int k=5; &lt;==== This could not be change by your program but can change by external sources, const makes its read only, only for compiler or programmer</p>

<p>Source : - <a href=""http://www.firmcodes.com/volatile-keyword-in-c-and-embedded-system/"" rel=""nofollow"">Volatile variable in C</a></p>
",0
25711101,3985760,1,"<p>I encountered a similar problem on empty base class problem and found the explanation.</p>

<p>ISO/IEC 14882:2003
10-5</p>

<blockquote>
  <p>A base class subobject may be of zero size (clause 9); however, two
  subobjects that have the same class type and that belong to the same
  most derived object must not be allocated at the same address (5.10).</p>
</blockquote>

<p>this means if object of Y has two subobjects of X, then both X MUST have different address(they must be 2 different objects with different address).</p>

<p>BTW, empty base class doesn't have to be 0 sized(it says MAY BE) until C++11, which claims it as required, more reference:
<a href=""http://en.cppreference.com/w/cpp/language/ebo"" rel=""nofollow"">http://en.cppreference.com/w/cpp/language/ebo</a></p>
",0
25660876,4429881,-1,"<p><img src=""https://i.stack.imgur.com/ab880.jpg"" alt=""enter image description here""></p>

<pre><code> #include&lt;iostream.h&gt;
 #include&lt;conio.h&gt;
 void main()
 {
 clrscr();
 char a[30];
 cout&lt;&lt;""enter any string "";
 cin.get(a,30);
 char b[30];
 for(int i=0;a[i]!='\0';i++)
 {
 if(a[i]!='!' &amp;&amp; a[i]!='#'&amp;&amp; a[i]!='@' &amp;&amp; a[i]!='$' &amp;&amp; a[i]!='%' &amp;&amp; a[i]!='^' &amp;&amp; a[i]!='&amp;'    &amp;&amp; a[i]!='*' &amp;&amp; a[i]!='?')
 {
 b[i]=a[i];
 cout&lt;&lt;b[i];
 } }
 getch();
  }
</code></pre>
",0
24591791,7984955,1,"<p>Declaring 'size_t i' for me work well.</p>
",0
32449206,4523178,5,"<pre><code>ostream &amp; operator&lt;&lt;(ostream &amp; os, stack&lt;double&gt; my_stack) //function header
{
    while(!my_stack.empty()) //body
    {
        os &lt;&lt; my_stack.top() &lt;&lt; "" "";
        my_stack.pop();
    }
    return os; // end of function
}


/*
using this simple overloaded operator function, you're able to print out all the components of a stack by doing a simple cout &lt;&lt; your_stack_name;*/
</code></pre>
",3
22508210,4428824,0,"<p>The uncaught C++ exception can also be thrown while the global/static objects of your dll are created/allocated/initialized (which is part of DllMain). So there is a good chance that somewhere in the code a valid throw statement is responsible for this behaviour (rather than some compiler/architecture/platform bug; maybe its just a define that is x64 specific?).</p>

<p>To find that nasty little *#!!:</p>

<ul>
<li>Compile all your code with debug information (/DEBUG)</li>
<li>Turn on the Symbol Server (Debug/Options/Debugging/Symbols/Symbol file (.pdb) locations: [x] Microsoft Symbol Servers)</li>
<li>Turn on all Break on Exceptions (Debug/Exceptions.../ Tick all [] in the ""Thrown"" column)</li>
<li>Start Debugging and you will eventually find the correct place.</li>
</ul>

<p>Due to the missing enforced ""throws"" statement like e.g. in Java (in c++ its optional and pretty useless; see <a href=""https://stackoverflow.com/questions/1055387/throw-keyword-in-functions-signature-c"">Throw keyword in function&#39;s signature</a> ), the try/catch/throw system is hardly usable to create robust and maintainable code; its almost like hiding random gotos everywhere.</p>
",0
22866926,6052131,5,"<p>Acordingly to <a href=""http://msdn.microsoft.com/en-us/library/windows/apps/hh755792.aspx"" rel=""noreferrer"">MSDN</a> an interface has these characteristics:</p>

<ul>
<li>An interface class (or struct) must be declared within a namespace
and may have public or private accessibility. Only public interfaces
are emitted to metadata.</li>
<li>The members of an interface can include properties, methods, and
events.</li>
<li>All interface members are implicitly public and virtual.</li>
<li>Fields and static members are not permitted.</li>
<li>Types that are used as properties, method parameters, or return
values can only be Windows Runtime types; this includes the
fundamental types and enum class types.</li>
</ul>

<p>So I would response to your question with </p>

<blockquote>
  <p><strong>NO</strong> if you want an interface</p>
</blockquote>

<p>and </p>

<blockquote>
  <p><strong>Yes</strong> if you just use abstract classes, but as the others say, make them private and use public getters and setters</p>
</blockquote>
",0
29483458,6464404,0,"<p>The dynamic binding is using vpointer and vtable. However, the dynamic binding only applies to function pointer. There is no mechanism to dynamic bind argument.</p>

<p>Thus, the default argument is determined statically at compiler time. In this case, it is statically determined by bp type, which is a pointer to Base class. Thus data = 10 is passed as function argument, while the function pointer is pointing to Derived class member function: D::print. Essentially, it calls D::print(10).</p>

<p>The following code snippet and the resulting outputs clearly demonstrate the point: even though it calls the Derived call member function Derived::resize(int), it passes the Base class default argument: size=0.</p>

<p>virtual void Derived::resize(int) size 0</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
using namespace std;

#define pr_dbgc(fmt,args...) \
    printf(""%d %s "" fmt ""\n"",__LINE__,__PRETTY_FUNCTION__, ##args);

class Base {
   public:
       virtual void resize(int size=0){
           pr_dbgc(""size %d"",size);
       }
};

class Derived : public Base {
   public:
       void resize(int size=3){
           pr_dbgc(""size %d"",size);
       }
};

int main()
{   
    Base * base_p = new Base;
    Derived * derived_p = new Derived;

    base_p-&gt;resize();           /* calling base member function   
                                   resize with default
                                   argument value --- size 0 */
    derived_p-&gt;resize();        /* calling derived member      
                                   function resize with default 
                                   argument default --- size 3 */

    base_p = derived_p;         /* dynamic binding using vpointer 
                                   and vtable */
                                /* however, this dynamic binding only
                                   applied to function pointer. 
                                   There is no mechanism to dynamic 
                                   binding argument. */
                                /* So, the default argument is determined
                                   statically by base_p type,
                                   which is pointer to base class. Thus
                                   size = 0 is passed as function 
                                   argument */

    base_p-&gt;resize();           /* polymorphism: calling derived class   
                                   member function 
                                   however with base member function  
                                   default value 0 --- size 0 */

     return 0;
}


 #if 0
 The following shows the outputs:
 17 virtual void Base::resize(int) size 0
 24 virtual void Derived::resize(int) size 3
 24 virtual void Derived::resize(int) size 0
 #endif
</code></pre>
",0
21043991,5678932,2,"<p>My version that handles exponents too:</p>

<pre><code>template&lt;class It&gt;
double mystrtod(It &amp;s, It const end)
{
    static double const pow10[] = { 1E-323, 1E-322, 1E-321, 1E-320, 1E-319, 1E-318, 1E-317, 1E-316, 1E-315, 1E-314, 1E-313, 1E-312, 1E-311, 1E-310, 1E-309, 1E-308, 1E-307, 1E-306, 1E-305, 1E-304, 1E-303, 1E-302, 1E-301, 1E-300, 1E-299, 1E-298, 1E-297, 1E-296, 1E-295, 1E-294, 1E-293, 1E-292, 1E-291, 1E-290, 1E-289, 1E-288, 1E-287, 1E-286, 1E-285, 1E-284, 1E-283, 1E-282, 1E-281, 1E-280, 1E-279, 1E-278, 1E-277, 1E-276, 1E-275, 1E-274, 1E-273, 1E-272, 1E-271, 1E-270, 1E-269, 1E-268, 1E-267, 1E-266, 1E-265, 1E-264, 1E-263, 1E-262, 1E-261, 1E-260, 1E-259, 1E-258, 1E-257, 1E-256, 1E-255, 1E-254, 1E-253, 1E-252, 1E-251, 1E-250, 1E-249, 1E-248, 1E-247, 1E-246, 1E-245, 1E-244, 1E-243, 1E-242, 1E-241, 1E-240, 1E-239, 1E-238, 1E-237, 1E-236, 1E-235, 1E-234, 1E-233, 1E-232, 1E-231, 1E-230, 1E-229, 1E-228, 1E-227, 1E-226, 1E-225, 1E-224, 1E-223, 1E-222, 1E-221, 1E-220, 1E-219, 1E-218, 1E-217, 1E-216, 1E-215, 1E-214, 1E-213, 1E-212, 1E-211, 1E-210, 1E-209, 1E-208, 1E-207, 1E-206, 1E-205, 1E-204, 1E-203, 1E-202, 1E-201, 1E-200, 1E-199, 1E-198, 1E-197, 1E-196, 1E-195, 1E-194, 1E-193, 1E-192, 1E-191, 1E-190, 1E-189, 1E-188, 1E-187, 1E-186, 1E-185, 1E-184, 1E-183, 1E-182, 1E-181, 1E-180, 1E-179, 1E-178, 1E-177, 1E-176, 1E-175, 1E-174, 1E-173, 1E-172, 1E-171, 1E-170, 1E-169, 1E-168, 1E-167, 1E-166, 1E-165, 1E-164, 1E-163, 1E-162, 1E-161, 1E-160, 1E-159, 1E-158, 1E-157, 1E-156, 1E-155, 1E-154, 1E-153, 1E-152, 1E-151, 1E-150, 1E-149, 1E-148, 1E-147, 1E-146, 1E-145, 1E-144, 1E-143, 1E-142, 1E-141, 1E-140, 1E-139, 1E-138, 1E-137, 1E-136, 1E-135, 1E-134, 1E-133, 1E-132, 1E-131, 1E-130, 1E-129, 1E-128, 1E-127, 1E-126, 1E-125, 1E-124, 1E-123, 1E-122, 1E-121, 1E-120, 1E-119, 1E-118, 1E-117, 1E-116, 1E-115, 1E-114, 1E-113, 1E-112, 1E-111, 1E-110, 1E-109, 1E-108, 1E-107, 1E-106, 1E-105, 1E-104, 1E-103, 1E-102, 1E-101, 1E-100, 1E-099, 1E-098, 1E-097, 1E-096, 1E-095, 1E-094, 1E-093, 1E-092, 1E-091, 1E-090, 1E-089, 1E-088, 1E-087, 1E-086, 1E-085, 1E-084, 1E-083, 1E-082, 1E-081, 1E-080, 1E-079, 1E-078, 1E-077, 1E-076, 1E-075, 1E-074, 1E-073, 1E-072, 1E-071, 1E-070, 1E-069, 1E-068, 1E-067, 1E-066, 1E-065, 1E-064, 1E-063, 1E-062, 1E-061, 1E-060, 1E-059, 1E-058, 1E-057, 1E-056, 1E-055, 1E-054, 1E-053, 1E-052, 1E-051, 1E-050, 1E-049, 1E-048, 1E-047, 1E-046, 1E-045, 1E-044, 1E-043, 1E-042, 1E-041, 1E-040, 1E-039, 1E-038, 1E-037, 1E-036, 1E-035, 1E-034, 1E-033, 1E-032, 1E-031, 1E-030, 1E-029, 1E-028, 1E-027, 1E-026, 1E-025, 1E-024, 1E-023, 1E-022, 1E-021, 1E-020, 1E-019, 1E-018, 1E-017, 1E-016, 1E-015, 1E-014, 1E-013, 1E-012, 1E-011, 1E-010, 1E-009, 1E-008, 1E-007, 1E-006, 1E-005, 1E-004, 1E-003, 1E-002, 1E-001, 1E+000, 1E+001, 1E+002, 1E+003, 1E+004, 1E+005, 1E+006, 1E+007, 1E+008, 1E+009, 1E+010, 1E+011, 1E+012, 1E+013, 1E+014, 1E+015, 1E+016, 1E+017, 1E+018, 1E+019, 1E+020, 1E+021, 1E+022, 1E+023, 1E+024, 1E+025, 1E+026, 1E+027, 1E+028, 1E+029, 1E+030, 1E+031, 1E+032, 1E+033, 1E+034, 1E+035, 1E+036, 1E+037, 1E+038, 1E+039, 1E+040, 1E+041, 1E+042, 1E+043, 1E+044, 1E+045, 1E+046, 1E+047, 1E+048, 1E+049, 1E+050, 1E+051, 1E+052, 1E+053, 1E+054, 1E+055, 1E+056, 1E+057, 1E+058, 1E+059, 1E+060, 1E+061, 1E+062, 1E+063, 1E+064, 1E+065, 1E+066, 1E+067, 1E+068, 1E+069, 1E+070, 1E+071, 1E+072, 1E+073, 1E+074, 1E+075, 1E+076, 1E+077, 1E+078, 1E+079, 1E+080, 1E+081, 1E+082, 1E+083, 1E+084, 1E+085, 1E+086, 1E+087, 1E+088, 1E+089, 1E+090, 1E+091, 1E+092, 1E+093, 1E+094, 1E+095, 1E+096, 1E+097, 1E+098, 1E+099, 1E+100, 1E+101, 1E+102, 1E+103, 1E+104, 1E+105, 1E+106, 1E+107, 1E+108, 1E+109, 1E+110, 1E+111, 1E+112, 1E+113, 1E+114, 1E+115, 1E+116, 1E+117, 1E+118, 1E+119, 1E+120, 1E+121, 1E+122, 1E+123, 1E+124, 1E+125, 1E+126, 1E+127, 1E+128, 1E+129, 1E+130, 1E+131, 1E+132, 1E+133, 1E+134, 1E+135, 1E+136, 1E+137, 1E+138, 1E+139, 1E+140, 1E+141, 1E+142, 1E+143, 1E+144, 1E+145, 1E+146, 1E+147, 1E+148, 1E+149, 1E+150, 1E+151, 1E+152, 1E+153, 1E+154, 1E+155, 1E+156, 1E+157, 1E+158, 1E+159, 1E+160, 1E+161, 1E+162, 1E+163, 1E+164, 1E+165, 1E+166, 1E+167, 1E+168, 1E+169, 1E+170, 1E+171, 1E+172, 1E+173, 1E+174, 1E+175, 1E+176, 1E+177, 1E+178, 1E+179, 1E+180, 1E+181, 1E+182, 1E+183, 1E+184, 1E+185, 1E+186, 1E+187, 1E+188, 1E+189, 1E+190, 1E+191, 1E+192, 1E+193, 1E+194, 1E+195, 1E+196, 1E+197, 1E+198, 1E+199, 1E+200, 1E+201, 1E+202, 1E+203, 1E+204, 1E+205, 1E+206, 1E+207, 1E+208, 1E+209, 1E+210, 1E+211, 1E+212, 1E+213, 1E+214, 1E+215, 1E+216, 1E+217, 1E+218, 1E+219, 1E+220, 1E+221, 1E+222, 1E+223, 1E+224, 1E+225, 1E+226, 1E+227, 1E+228, 1E+229, 1E+230, 1E+231, 1E+232, 1E+233, 1E+234, 1E+235, 1E+236, 1E+237, 1E+238, 1E+239, 1E+240, 1E+241, 1E+242, 1E+243, 1E+244, 1E+245, 1E+246, 1E+247, 1E+248, 1E+249, 1E+250, 1E+251, 1E+252, 1E+253, 1E+254, 1E+255, 1E+256, 1E+257, 1E+258, 1E+259, 1E+260, 1E+261, 1E+262, 1E+263, 1E+264, 1E+265, 1E+266, 1E+267, 1E+268, 1E+269, 1E+270, 1E+271, 1E+272, 1E+273, 1E+274, 1E+275, 1E+276, 1E+277, 1E+278, 1E+279, 1E+280, 1E+281, 1E+282, 1E+283, 1E+284, 1E+285, 1E+286, 1E+287, 1E+288, 1E+289, 1E+290, 1E+291, 1E+292, 1E+293, 1E+294, 1E+295, 1E+296, 1E+297, 1E+298, 1E+299, 1E+300, 1E+301, 1E+302, 1E+303, 1E+304, 1E+305, 1E+306, 1E+307, 1E+308 };
    long long b = 0, e1 = 0, e2 = 0;
    bool is_exp = false;
    do
    {
        bool negate = s != end &amp;&amp; *s == '-';
        if (s != end &amp;&amp; (*s == '-' || *s == '+')) { ++s; }
        bool decimal = false;
        long long &amp;r = is_exp ? e2 : b;
        while (s != end &amp;&amp; (*s == '.' || '0' &lt;= *s &amp;&amp; *s &lt;= '9'))
        {
            if (*s != '.')
            {
                e1 -= decimal;
                char const digit = *s - '0';
                if (static_cast&lt;unsigned long long&gt;(r) &lt; static_cast&lt;unsigned long long&gt;(r) * 10 + static_cast&lt;unsigned char&gt;(digit))
                {
                    r *= 10;
                    r += digit;
                }
            }
            else { decimal = true; }
            ++s;
        }
        r = negate ? -r : +r;
    } while ((is_exp = !is_exp, is_exp) &amp;&amp; s != end &amp;&amp; ((*s | ('e' ^ 'E')) == 'e') &amp;&amp; (++s, is_exp));
    double const result = b * pow10[323 + (e1 + e2)];
    return result;
}
</code></pre>
",0
25515402,5179564,0,"<p>Add the g++ path in $PATH   export PATH=$PATH:g++Path</p>
",0
28227309,6873138,0,"<p>If we are speaking of MSVC, I think the simplest way with no other harm than the fact of calling a private method itself is the great __asm:</p>

<pre><code>class A
{
private:
    void TestA () {};
};

A a;
__asm
{
    // MSVC assumes (this) to be in the ecx.
    // We cannot use mov since (a) is located on the stack
    // (i.e. [ebp + ...] or [esp - ...])
    lea     ecx, [a]
    call    A::TestA
}
</code></pre>
",1
23070740,7922112,3,"<p>One method I have found is to use the overloaded "">>"" operator with lambda expressions. The following code demonstrates this. You have to know to use operator "">>"" instead of ""->"", this is because the compiler I use will not allow the operator ""->"" to be overloaded. Also because the operator "">>"" has lower precedence than the ""->"" you have to use parentheses to force to compiler to evaluate the equation in the correct order.</p>

<p>In the end it becomes a matter of style, maintainability, reliability and cleanness of the code you are trying to produce. One would argue defining the ""SubtractValue"" method with two arguments creates more efficient code, but others would argue the overloaded method is more maintainable. In the end it is left to the architects and developers to determine what is important to their project. I am just providing a possible solution to the issue.</p>

<pre><code>#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;tchar.h&gt;

// Some plain demo class that cannot be changed.
class DemoClass
{
public:
    int GetValue() { return _value; }
    int SetValue(int ivalue) { _value = ivalue; return _value; }
    DemoClass *AddValue(int iadd) { this-&gt;_value += iadd; return this; }

private:
    int _value = 0;
};

// Define Lambda expression type that takes and returns a reference to the object.
typedef std::function&lt;DemoClass *(DemoClass *obj)&gt; DemoClassExtension;

// Overload the ""&gt;&gt;"" operator because we cannot overload ""-&gt;"" to execute the extension.
DemoClass* operator&gt;&gt;(DemoClass *pobj, DemoClassExtension &amp;method)
{
    return method(pobj);
}

// Typical extensions.

// Subtract value ""isub"".
DemoClassExtension SubtractValue(int isub)
{
    return [=](DemoClass *pobj) {
        pobj-&gt;AddValue(-isub);
        return pobj;
    };
}

// Multiply value ""imult"".
DemoClassExtension MultiplyValue(int imult)
{
    return [=](DemoClass *pobj) {
        pobj-&gt;SetValue(pobj-&gt;GetValue() * imult);
        return pobj;
    };
}

int _tmain(int argc, _TCHAR* argv[])
{
    DemoClass *pDemoObject = new DemoClass();
    int value = (pDemoObject-&gt;AddValue(14) &gt;&gt; SubtractValue(4) &gt;&gt; MultiplyValue(2))-&gt;GetValue();
    std::cout &lt;&lt; ""Value is "" &lt;&lt; value;
    return 0;
}
</code></pre>

<p>The above code output is ""Value is 20"".</p>
",0
34224049,10507893,2,"<p>Using</p>

<ul>
<li>an environment variable <code>%ZLIB_DIR%</code> for the path to zlib-1.2.8, </li>
<li><code>%LIBZIP_DIR%</code> for the path to libzip-1.0.1</li>
<li>VS 2015 Express Edition, and</li>
<li>the file <code>%LIBZIP_DIR%/lib/zip_source_filep.c</code> patched according to <a href=""http://hg.nih.at/libzip/rev/80457805a1e7"" rel=""nofollow noreferrer"">http://hg.nih.at/libzip/rev/80457805a1e7</a> ,</li>
</ul>

<p>the process for building zlib and libzip becomes this:</p>

<p><br/></p>

<h3>Building zlib</h3>

<pre><code>&gt; cd /d %ZLIB_DIR% &amp;&amp; md build &amp; cd build
&gt; cmake .. -G""Visual Studio 14 2015 Win64""- DCMAKE_INSTALL_PREFIX=""%ZLIB_DIR%""
&gt; msbuild /P:Configuration=Debug INSTALL.vcxproj
&gt; msbuild /P:Configuration=Release INSTALL.vcxproj
</code></pre>

<p><br/></p>

<h3>Building libzip</h3>

<pre><code>&gt; cd /d %LIBZIP_DIR% &amp;&amp; md build &amp; cd build
&gt; cmake .. -G""Visual Studio 14 2015 Win64"" -DCMAKE_PREFIX_PATH=""%ZLIB_DIR%""
&gt; msbuild /P:Configuration=Debug ALL_BUILD.vcxproj
&gt; msbuild /P:Configuration=Release ALL_BUILD.vcxproj
</code></pre>

<p><br/>
Done!</p>

<p>(So you see, <a href=""https://stackoverflow.com/questions/10507893/libzip-with-visual-studio-2010#comment32632229_12239625"">@MikeLischke</a>, CMake does indeed work out-of-the-box sometimes...)</p>
",2
22425418,8215137,1,"<p>To elaborate on the previous answer, C and C++ assume that strings are terminated with a null (\0), so functions like printf() will expect that; but DragonFireSDK's NetSend doesn't always use this convention, and it assumes you're going to look at the value in the length variable. The above code simply forces the null to be in place for printf()'s benefit.</p>

<p>That may not be the safest solution. You don't know that the block of memory that NetSend is sending to the callback is something you can safely write to, even if you then restore the original value when you're done, as is done above. The most bulletproof approach would be to copy the string to somewhere else like a local variable only to the length specified, if you have to use printf(); or, better yet, just use the data where it is but only read it, if you don't need to go to printf().  For instance, here's a clumsy but safe version:</p>

<pre><code>char *cp;
for (cp = response; cp-response &lt; length; cp++) {
  printf(""%c"",*cp);
}
printf(""\n"");
</code></pre>

<p>However, this is probably being paranoid. I doubt this or any other version of DragonFireSDK is likely to use a buffer you can't safely write to.</p>
",0
31259487,7084139,3,"<p>Maxim quotes Stroustrup's glossary:</p>
<blockquote>
<p>fat interface - an interface with more member functions and friends than are logically necessary. TC++PL 24.4.3</p>
</blockquote>
<p>Maxim provides no explanation, and other existing answers to this question <strong>mis</strong>interpret the above - or sans the Stroustrup quote the term itself - as meaning an interface with an arguably excessive number of members.  <em>It's not.</em></p>
<p>It's actually <em><strong>not about the number of members</strong></em>, but <em><strong>whether the members make sense for all the implementations</strong></em>.</p>
<p>That subtle aspect that doesn't come through very clearly in Stroustrup's glossary, but at least in the old version of TC++PL I have - is clear where the term's used in the text.  Once you understand the difference, the glossary entry is clearly consistent with it, but <em>&quot;more member functions and friends than are logically necessary&quot;</em> is a test that should be applied from the perspective of each of the implementations of a logical interface.  (My understanding's also <a href=""https://en.wikipedia.org/wiki/Interface_bloat"" rel=""nofollow noreferrer"">supported by Wikipedia</a>, for whatever that's worth ;-o.)</p>
<p>Specifically when you have an interface over several implementations, and some of the interface actions are only meaningful for some of the implementations, then you have a fat interface in which you can ask the active implementation to do something that it has no hope of doing, and you have to <em><strong>complicate the interface with some &quot;not supported&quot; discovery or reporting</strong></em>, which soon adds up to make it <em><strong>harder to write reliable client code</strong></em>.</p>
<p>For example, if you have a <code>Shape</code> base class and derived <code>Circle</code> and <code>Square</code> classes, and contemplate adding a <code>double get_radius() const</code> member: you could do so and have it <code>throw</code> or return some sentinel value like <code>NaN</code> or <code>-1</code> if called on a <code>Square</code> - you'd then have a fat interface.</p>
<hr/>
<p><a href=""https://en.wikipedia.org/wiki/Robert_C._Martin"" rel=""nofollow noreferrer"">&quot;Uncle Bob&quot;</a> puts a different emphasis on it below (boldfacing mine) in the context of the <a href=""https://en.wikipedia.org/wiki/Interface_segregation_principle"" rel=""nofollow noreferrer"">Interface Segregation Principle (ISP)</a> (a <a href=""https://en.wikipedia.org/wiki/SOLID"" rel=""nofollow noreferrer"">SOLID</a> principle that says to avoid fat interfaces):</p>
<blockquote>
<p>[ISP] deals with the disadvantages of ¡°fat¡± interfaces. Classes that have ¡°fat¡± interfaces are classes whose <strong>interfaces are not cohesive</strong>. In other words, the <strong>interfaces of the class can be broken up into groups of member functions. Each group serves a different set of clients. Thus some clients use one group of member functions, and other clients use the other groups</strong>.</p>
</blockquote>
<p>This implies you could have e.g. virtual functions that all derived classes do implementation with non-noop behaviours, but still consider the interface &quot;fat&quot; if typically any given client using that interface would only be interested in one group of its functions.  For example: if a string class provided regexp functions and 95% of client code never used any of those, and especially if the 5% that did didn't tend to use the non-regexp string functions, then you should probably separate the regexp functionality from the normal textual string functionality.  In that case though, there's a clear distinction in member function functionality that forms 2 groups, and when you were writing your code you'd have a clear idea whether you wanted regexp functionality or normal text-handling functionality.  With the actual <code>std::string</code> class, although it has a lot of functions I'd argue that there's no clear grouping of functions where it would be weird to evolve a need to use some functions (e.g. <code>begin</code>/<code>end</code>) after having initially needed only say <code>insert</code>/<code>erase</code>.  I don't personally consider the interface &quot;fat&quot;, even though it's huge.</p>
<hr/>
<p>Of course, such an evocative term will have been picked up by other people to mean whatever they think it should mean, so it's no surprise that the web contains examples of the simpler larger-than-necessary-interface usage, as evidenced by the link in relaxxx's answer, but I suspect that's more people guessing at a meaning than &quot;educated&quot; about prior usage in Computing Science literature....</p>
",0
23811274,16587828,1,"<p>I was getting similar linking errors. My error was saying:</p>

<pre><code>/usr/local/lib/libglfw3.a(x11_init.c.o): In function `initExtensions':
x11_init.c:(.text+0x16d3): undefined reference to `XIQueryVersion'
/usr/local/lib/libglfw3.a(x11_window.c.o): In function `createWindow':
x11_window.c:(.text+0x6de): undefined reference to `XISelectEvents'
</code></pre>

<p>But since I wanted <strong>Cmake linking flags</strong> for the required linking libs, it took me a while to do so.  Required external libs, to compile glfw based program, are: </p>

<pre><code>Requires.private:  x11 xrandr xi xxf86vm gl
</code></pre>

<p><a href=""https://stackoverflow.com/questions/21685903/glfw3-undefined-reference-to-xrr"">This</a> thread shows how to find these libs needed to compile glfw based program.</p>

<p>Since, I spent 2-3 hours looking for Cmake linking flags for the above additional linking libs. I think it's worth mentioning here to help others. </p>

<p>Mainly for the error I have mentioned above, I just needed a cmake linking flag for <code>xi</code> only, but for completeness sake I am mentioning for all of them, i.e. <code>x11 xrandr xi xxf86vm</code>. Here is the snippet from my <code>CMakeLists.txt</code> file:</p>

<pre><code>include_directories(
    ./src
    ${X11_xf86vmode_INCLUDE_PATH}
    ${X11_Xrandr_INCLUDE_PATH}
    ${X11_Xinput_INCLUDE_PATH}
)

    target_link_libraries(
        ${GLFW_LIBRARIES}
        ${X11_LIBRARIES}
        ${X11_Xxf86vm_LIB}
        ${X11_Xrandr_LIB}
        ${X11_Xinput_LIB}
    )
</code></pre>

<p>I extracted these flags from this <a href=""https://github.com/fogleman/Craft/blob/master/deps/glfw/CMakeLists.txt"" rel=""nofollow noreferrer"">link</a>.
Hope, it will save time for others. Enjoy!</p>
",0
22431184,11925961,0,"<p>Even if one could somehow undefine the keyword <code>int</code>, that would do nothing to prevent usage of that type, since there are many cases where the compiler will end up using that type.  Beyond the obvious cases of integer literals, there are some more subtle cases involving integer promotion.  For example, if <code>int</code> happens to be 64 bits, operations between two variables of type <code>uint32_t</code> will be performed using type <code>int</code> rather than <code>uint32_t</code>.  As nice as it would be to be able to specify that some variables represent <em>numbers</em> (which should be eagerly promoted when practical) while others represent members of a wrapping <em>algebraic ring</em> (which should not be promoted), I know of no facility to do such a thing.  Consequently, <code>int</code> is unavoidable.</p>
",0
32970562,6417817,17,"<p>For those who like boost:</p>

<p>Use boost::filesystem::path::stem. It returns the filename without the last extension. So ./myFiles/foo.bar.foobar becomes foo.bar. So when you <em>know</em> you are dealing with only one extension you could do the follwing:</p>

<pre><code>boost::filesystem::path path(""./myFiles/fileWithOneExt.myExt"");
std::string fileNameWithoutExtension = path.stem().string();
</code></pre>

<p>When you have to deal with multiple extensions you might do the following:</p>

<pre><code>boost::filesystem::path path(""./myFiles/fileWithMultiExt.myExt.my2ndExt.my3rdExt"");
while(!path.extension().empty())
{
    path = path.stem();
}

std::string fileNameWithoutExtensions = path.stem().string();
</code></pre>

<p>(taken from here: <a href=""http://www.boost.org/doc/libs/1_53_0/libs/filesystem/doc/reference.html#path-decomposition"" rel=""noreferrer"">http://www.boost.org/doc/libs/1_53_0/libs/filesystem/doc/reference.html#path-decomposition</a> found in the stem section)</p>

<p>BTW works with rooted paths, too.</p>
",0
29510156,6417817,1,"<p>In case someone just wants a simple solution for windows:</p>

<p>Use <code>PathCchRemoveExtension</code> -><a href=""https://msdn.microsoft.com/en-us/library/hh707091%28v=vs.85%29.aspx"" rel=""nofollow"">MSDN</a></p>

<p>... or <code>PathRemoveExtension</code> (deprecated!) -><a href=""https://msdn.microsoft.com/en-us/library/bb773746%28v=vs.85%29.aspx"" rel=""nofollow"">MSDN</a></p>
",0
22866070,8394428,0,"<p>I posted on the my Italian blog a post where I explain a way to emulate the property construct of the CBuilder in the C++ standard.  Just as reference here I report a class declaration called CPanel using the CBuilder syntax for property definition:</p>

<pre><code>class CPanel
{
private:
  int m_Width;  // Private member for Width property
  int m_Height; // Private member for Height property

protected:
  void __fastcall SetWidth(int AValue); // Set the Width property
  int __fastcall GetWidth();            // Get the Width property

  void __fastcall SetHeight(int AValue);// Set the Height property
  int  __fastcall GetHeight();          // Get the Height property

public:
  CPanel()
  {
  }
  __property int Width  = {read=GetWidth,  write=SetWidth};
  __property int Height = {read=GetHeight, write=SetHeight};
}
</code></pre>

<p>As you see the the syntax is very simple, you can define the private members  m_Height and m_Width, the protected setter and getter methods and finally you can define your properties using the special keyword called __property. The following code shows you how to use the properties in your main function:</p>

<pre><code>int main()
{
    CPanel Panel;
    Panel.Width   = 10;
    Panel.Height  = 10;
    int TmpWidth  = Panel.Width;
    int TmpHeight = Panel.Height;
}
</code></pre>

<p>We can emulate the same syntax defining a template class for our generic property, the following code shows a definition of a template class for this purpose:</p>

<pre><code>template&lt;typename owner_t,
         typename prop_t,
         void (owner_t::*setter)(prop_t),
         prop_t (owner_t::*getter)()&gt;
class CProperty
{
public:
  // Constructor
  CProperty(owner_t* owner){m_owner = owner;}

  // op = overloading
  void operator=(prop_t value)
  {   
    return (m_owner-&gt;*setter)(value);
  }
  // op type overloading
  operator prop_t()
  {   
    return (m_owner-&gt;*getter)();
  }
private:
  prop_t* m_owner;
}
</code></pre>

<p>Thanks the above template we can redefine our CPanel class using the standard c++ language:</p>

<pre><code>class CPanel
{
private:
  int m_Width;  // Private member for Width property
  int m_Height; // Private member for Height property

protected:
  void SetWidth(int AValue); // Set the Width property  
  int  GetWidth();           // Get the Width property

  void SetHeight(int AValue);// Set the Height property
  int  GetHeight();          // Get the Height property

public:
  CPanel()
  :Width(this), Height(this)
  {
  }

  CProperty&lt;CPanel, int, SetWidth,  GetWidth&gt;  Width;
  CProperty&lt;CPanel, int, SetHeight, GetHeight&gt; Height;
}
</code></pre>

<p>As you can see the syntax is very similar, but now it is standard. You can use the new CPanel class like previous main function:</p>

<pre><code>int main()
{
    CPanel Panel;
    Panel.Width   = 10;
    Panel.Height  = 10;
    int TmpWidth  = Panel.Width;
    int TmpHeight = Panel.Height;
}
</code></pre>

<p>Here is a <a href=""http://www.cbuilderblog.com/una-classe-template-alternativa-a-__property/"" rel=""nofollow"">link</a> to the full post (in Italian language)</p>
",0
24371810,17453609,0,"<p>As you do, I was looking through the gcc man pages and there is handy warning for this exact issue: </p>

<pre><code>-Woverloaded-virtual
</code></pre>

<p>it returned</p>

<pre><code>test.cpp:17:14: warning: ¡®virtual void Logger::log(std::string)¡¯ was hidden [-Woverloaded-virtual]
     void log( string message )
          ^
test.cpp:34:22: warning:   by ¡®virtual void SpecialLogger_IF::log(std::string, std::string)¡¯ [-Woverloaded-virtual]
     virtual void log( string message, string extra ) = 0;
                  ^
</code></pre>

<p>on the above code. </p>

<p>Al</p>
",0
26195715,7871854,0,"<p>Can also be caused if/when cannot allocate memory for a dependent exception object which would be thrown. (I imagine this is rare. But is possible reason the app would terminate abnormally.)</p>
",0
22862005,12637779,12,"<p>You can use <code>sprintf</code> for this purpose:</p>

<pre><code>const char output[256];
const WCHAR* wc = L""Hellow World"" ;
sprintf(output, ""%ws"", wc );
</code></pre>
",1
21771102,11516657,11,"<p>You can just initialize via a constructor:</p>
<pre><code>struct address {
  address() : city(&quot;Hamilton&quot;), prov(&quot;Ontario&quot;) {}
  int street_no;
  char *street_name;
  char *city;
  char *prov;
  char *postal_code;
};
</code></pre>
",1
29505267,8403468,16,"<p>Also you can add <strong><code>#include&lt;vector&gt;</code></strong> in the header. When two of the above solutions don't work.</p>
",2
28521862,11904519,12,"<p>If you're compiling with RTTI (-frtti), make sure your dependent libraries are also compiled with it, and not -fno-rtti. Otherwise you will get the typeinfo error when you subclass a class compiled with -fno-rtti  or use dynamic_cast.</p>
",0
25516380,9150538,5,"<p>I really like the macro approach of @Lol4t0.</p>

<p>I extended it to be able to convert an enum from a string too:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

// http://stackoverflow.com/questions/236129/how-to-split-a-string-in-c
std::vector&lt;std::string&gt; split(const std::string &amp;text, char sep) {
    std::vector&lt;std::string&gt; tokens;
    int start = 0, end = 0;
    while ((end = text.find(sep, start)) != std::string::npos) {
        tokens.push_back(text.substr(start, end - start));
        start = end + 1;
    }
    tokens.push_back(text.substr(start));
    return tokens;
}

#define ENUM(name, ...)\
    enum name\
    {\
        __VA_ARGS__\
    };\
    static const int name##Size = (sizeof((int[]){__VA_ARGS__})/sizeof(int));\
    static const vector&lt;string&gt; name##ToStringMap = split(#__VA_ARGS__, ',');\
    const string name##ToString(const name value)\
    {\
        return name##ToStringMap.at(value);\
    };\
    map&lt;string, name&gt; name##ToFromStringMap(...)\
    {\
        map&lt;string, name&gt; m;\
        name args[name##Size] = { __VA_ARGS__ };\
        \
        int i;\
        for(i = 0; i &lt; name##Size; ++i)\
        {\
            m[name##ToString(args[i])] = args[i];\
        }\
        return m;\
    };\
    static map&lt;string, name&gt; name##FromStringMap = name##ToFromStringMap(__VA_ARGS__);\
    const name name##FromString(const string value, const name defaultValue)\
    {\
        if(name##FromStringMap.count(value) == 0)\
        {\
            return defaultValue;\
        }\
        return name##FromStringMap[value];\
    };
</code></pre>

<p>Usage:</p>

<pre><code>ENUM(MyEnum, Value1, Value2)

void main()
{
    string valueName = MyEnumToString(MyEnum::Value2);
    MyEnum value = MyEnumFromString(valueName, MyEnum::Value1);
}
</code></pre>

<p>I am not a C++ expert, so let me know what you think or how to do better.</p>
",0
27121699,11181251,0,"<p>Use some like that</p>

<pre><code>int value = 0x1234;
char * temp = new char[100];
sprintf(temp, ""0x%x"", value);
std::string target(temp);
delete[] temp;
</code></pre>
",0
32432969,8848870,6,"<p>It could be done also by using a simple index based for loop clubbed with <code>std::advance</code> to reach to a particular map element. OpenMP 2.0 supports index based for loops very well.</p>

<pre><code>#pragma omp parallel for
    for(int i = 0; i &lt; dat.size(); i++) {
        auto datIt = dat.begin();
        advance(datIt, i);
        //construct the distance matrix using iterator datIt
    }
</code></pre>

<p>In each thread the iterator <code>datIt</code> will point to a map item and can be used to perform operations on it.</p>
",0
31903406,8493019,-2,"<pre><code>#include &lt;iostream.h&gt;

int main() {
    int a;
    int b;
    int sum;

    std::cout &lt;&lt; ""Enter two numbers"" &lt;&lt; std::endl;

    std::cout &lt;&lt; ""Enter the value of a"" &lt;&lt; std::endl;
    std::cin &gt;&gt; a;

    std:: cout &lt;&lt; ""Enter the value of b"" &lt;&lt; std::endl;
    std::cin &gt;&gt; b;

    sum = a + b;
    std::cout &lt;&lt; sum &lt;&lt; std::endl;

    return 0;
}
</code></pre>
",0
28251973,9670033,0,"<p>Try this
SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_PATH | SHCNF_FLUSHNOWAIT, ""Path"", NULL);
where ""Path"" is the folder you want to update.</p>
",0
32956772,9948093,1,"<p>just do it as a double or use a template and let the compiler figure it out. </p>

<p>If your int = 1
Then double = 1.0</p>

<p>They are the same number and double will help with the precision. </p>

<p>Just have it return a double. It uses more memory, but it's local scope so who cares?</p>
",0
23827127,9966663,0,"<p>Using char or unsigned char as 1 byte integer type is not always that straightforward... Sometimes you just need the type to be number type, not character type. One such example is here: <a href=""https://stackoverflow.com/questions/13804591/1-byte-integer-data-type"">1 byte integer data type</a>
Other is when you have function overloaded for arguments of several different types.</p>
",0
32448528,11857150,1,"<p>All the hints that were contributed above are correct to sequential programs, I mean, programs without threads. Using threads things change. 
First of all, by default parameters to std::thread are functions and functions parameters. Probably you were studying the book ""C++ concurrency in action"", and the author shows an interesting example:</p>

<pre><code>void do_some_work(); 
thread my_thread(do_some_work); //thread receives the function address
</code></pre>

<p>Suppose this function: </p>

<p>void do_other_job(int k);
In the body of the code, you should do: </p>

<pre><code>k=3; 
thread my_thread2(do_other_job, k); 
</code></pre>

<p>in order to spawn another thread.   </p>

<p>So, using threads the compiler interprets f ( in <strong>std::thread my_thread(f);</strong>) by default as a function instead of a class. To change that you have to initiate an operator() to warn the compiler you are working with a class. 
An alternative code could be: </p>

<pre><code>class background_task{
public: 
background_task(){
 do_sth(); 
 do_sth_else(); 
 }
void operator()(){} 
}; 
background_task f; 
thread mythread10(f);
</code></pre>

<p>Eventually, it's not correct, using threads, feeding the operator, so this code doesn't work: </p>

<pre><code>void operator()(int x){
do_sth(); 
cout&lt;&lt;""x = ""&lt;&lt;x&lt;&lt;endl;
}
</code></pre>

<p>It happens because all the code inside the brackets are read-only, and cannot be changed during the run-time. If you aim to insert a variable in the constructor, it must be put in the thread initialization. So: </p>

<pre><code>class backg{
public: 
backg(int i){
   do_sth(i); 
   }
void operator()(){}
}; 
int main(){
thread mythread{ backg(12) }; //using c++11
return 0; 
}
</code></pre>

<p>Will run without mistakes, and will perform the function do_sth(12) in the thread spawned. </p>

<p>I hope I have helped. </p>
",0
24092908,9953105,1,"<p>I had the same problem, I've been researching and troubleshooting for 3 weeks.  But what I found was this:  Under 'execute' click 'clean'.  This worked for me.</p>
",0
23079381,10573320,0,"<p>I met exactly the same problem and solved it like this:
Open the Makefile and change the first line from</p>

<p>CPPFLAGS = -O2 -Wall</p>

<p>to</p>

<p>CPPFLAGS = -O -Wall</p>

<p>Then ""make clean"" and ""make"", it works for me. So I guess it is because param 
""-O2"" does more optimization than expected.</p>
",0
32399592,13788722,5,"<p>It is possible to have macros that are defined only in a files scope by using <code>#undef</code>. E.g. :</p>

<pre><code>#define MACRO 1

int a = MACRO;

#undef MACRO

int b = MACRO; // ERROR
</code></pre>

<p>However, this does not work across files unless you rely on the order of includes, which would be bad.</p>

<p>If you want to use macros defined in a <code>macro.h</code> in sources, you could have a second <code>unmacro.h</code> and include that at the end of the source:</p>

<pre><code> // foo.cpp
 // other includes
 #include ""macro.h""
 // no other includes!

 // contents of the source

 #include ""unmacro.h""
</code></pre>

<p>However, I would not recommended it because it is error-prone. Better reconsider if you need to use macros at all. In modern C++ their valid uses are extremely rare.</p>
",0
26808745,13056366,3,"<p>@AndreyT gives an excellent answer that I will expand on with a little practical advice.</p>

<p>I tend to use unions in order to get easy access to a bitmap value without the tedious and ugly bitwise and's/bitwise or's.  I think this is a fairly common practice.</p>

<p>One technique I have used for a while to make the process even easier is if I am working with a bitmap of less than 32bits I declare it as an unnamed <em>struct</em> inside a <em>union</em> along with a companion <em>DWORD</em> data-member.  For example:</p>

<pre><code>union UNICODECONTROL{
    DWORD           dwAccessor;
    struct{
        unsigned unicode_01 : 1;
        unsigned unicode_02 : 1;
        unsigned unicode_03 : 1;
        unsigned unicode_04 : 1;
        unsigned unicode_05 : 1;
        unsigned unicode_06 : 1;
        unsigned unicode_07 : 1;
        unsigned unicode_08 : 1;
        unsigned unicode_09 : 1;
        unsigned unicode_10 : 1;
    };  
};
</code></pre>

<p>With that in place it will work like an 'accessor' function.  If you want to set the values you can do so in one go by assigning a number with the appropriate bitmap to this 'accessor'.  You want to zero them all - also a piece of cake.  It especially works VERY well with the windows registry.  In order to store the value of the union bitmap all you need to do is just write the <em>DWORD</em> to the registry!  Retrieving it later for re-initialization is equally simple.</p>

<p>A <em>DWORD</em> is one of the native types of the registry and you do not need to mess around static-casting or writing manual conversion functions.  If you have a longer bitmap than 32bits you can declare a 64Bit sized-integer and it would work in just the same way generally - and equally well with the registry as a <em>QUADWORD</em> is also a native type.</p>

<p>Where this bears directly on what @AndreyT mentions - if you want convenient initialization of a class data-member in my union-bitmap/<em>DWORD</em> format, all you have to do is - as in the example - make sure the 'accessor' is the first value declared in the union.  Then you can mem-list it directly with the new C++11 '{}' scheme.  No need for weird union-constructors at all!</p>

<p>A caveat.  Where the separate bitmap bits live 'inside' the accessor DWORD will depend on the alignment setting for your structures.  This is set at the compiler level or with the <code>__declspec(align(#))</code> statement in MSVC++ and similar syntax in other compilers.</p>

<p>Finally, an update learned while trying these ideas out in several different scenarios recently.  Despite the fact C++11 explicitly says it is legal to initialize a union by its first variable as described above, MSVC++ seems to ignore this standard - or '<em>not implement</em>' it as the compiler error output states.  Therefore if you are using the Microsoft compiler you will have to implement a messy constructor for your union if you want to initialize it.  A shame, but presumably compliance to the C++11 standard will improve in further service packs to VS2013 and with the next 2014 iteration of the entire IDE. </p>
",0
21184855,11379433,3,"<p>They are forbidden, but a workaround is to use a stack allocator, for example:</p>

<p><a href=""http://howardhinnant.github.io/stack_alloc.html"" rel=""nofollow"">http://howardhinnant.github.io/stack_alloc.html</a></p>

<p>You can use the stack allocator with a <code>::std::vector</code> (or with some other container, or just directly) and you've got yourself a <code>VLA</code>.</p>
",0
25448885,11677769,1,"<p>I think any canonical answer (w.r.t. the bounty notes) would involve some distinct phases in the solution:</p>

<ul>
<li>Error checking for valid input
<ul>
<li>Length check and</li>
<li>Data content check</li>
</ul></li>
<li>Element conversion</li>
<li>Output creation</li>
</ul>

<p>Given the usefulness of such conversions, the solution should probably include some flexibility w.r.t. the types being used and the locale required.</p>

<p>From the outset, given the date of the request for a ""more canonical answer"" (circa August 2014) liberal use of C++11 will be applied.</p>

<p>An annotated version of the code, with types corresponding to the OP:</p>

<pre><code>std::vector&lt;std::uint8_t&gt; convert(std::string const&amp; src)
{
  // error check on the length
  if ((src.length() % 2) != 0) {
    throw std::invalid_argument(""conversion error: input is not even length"");
  }

  auto ishex = [] (decltype(*src.begin()) c) {
    return std::isxdigit(c, std::locale()); };

  // error check on the data contents
  if (!std::all_of(std::begin(src), std::end(src), ishex)) {
    throw std::invalid_argument(""conversion error: input values are not not all xdigits"");
  }

  // allocate the result, initialised to 0 and size it to the correct length
  std::vector&lt;std::uint8_t&gt; result(src.length() / 2, 0);

  // run the actual conversion    
  auto str = src.begin(); // track the location in the string
  std::for_each(result.begin(), result.end(), [&amp;str](decltype(*result.begin())&amp; element) {
    element = static_cast&lt;std::uint8_t&gt;(std::stoul(std::string(str, str + 2), nullptr, 16));
    std::advance(str, 2); // next two elements
  });

  return result;
}
</code></pre>

<p>The template version of the code adds flexibility;</p>

<pre><code>template &lt;typename Int /*= std::uint8_t*/,
  typename Char = char,
  typename Traits = std::char_traits&lt;Char&gt;,
  typename Allocate = std::allocator&lt;Char&gt;,
  typename Locale = std::locale&gt;
std::vector&lt;Int&gt; basic_convert(std::basic_string&lt;Char, Traits, Allocate&gt; const&amp; src, Locale locale = Locale())
{
  using string_type = std::basic_string&lt;Char, Traits, Allocate&gt;;

  auto ishex = [&amp;locale] (decltype(*src.begin()) c) {
      return std::isxdigit(c, locale); };

  if ((src.length() % 2) != 0) {
    throw std::invalid_argument(""conversion error: input is not even length"");
  }

  if (!std::all_of(std::begin(src), std::end(src), ishex)) {
    throw std::invalid_argument(""conversion error: input values are not not all xdigits"");
  }

  std::vector&lt;Int&gt; result(src.length() / 2, 0);

  auto str = std::begin(src);
  std::for_each(std::begin(result), std::end(result), [&amp;str](decltype(*std::begin(result))&amp; element) {
    element = static_cast&lt;Int&gt;(std::stoul(string_type(str, str + 2), nullptr, 16));
    std::advance(str, 2);
  });

  return result;
}
</code></pre>

<p>The <code>convert()</code> function can then be based on the <code>basic_convert()</code> as follows:</p>

<pre><code>std::vector&lt;std::uint8_t&gt; convert(std::string const&amp; src)
{
  return basic_convert&lt;std::uint8_t&gt;(src, std::locale());
}
</code></pre>

<p><a href=""http://coliru.stacked-crooked.com/a/eb2dd1bb518373f5"" rel=""nofollow"" title=""Live sample"">Live sample</a>.</p>
",0
34247610,7881487,1,"<p>g++ supports zero size arrays, you can use one of:</p>

<pre><code>struct Empty1 {
  int dummy[0];
};
</code></pre>

<p>or</p>

<pre><code>struct Empty2 {
  int dummy[];
};
</code></pre>

<p>It generates warning, only if the '-pedantic' flags is used.</p>
",1
34201858,11713842,3,"<p>You are more than likely missing <strong>$(IncludePath)</strong> within Properties->VC++ Directories->Include Directories. Adding this should make iostream and others visible again. You probably deleted it by mistake while setting up your program.</p>
",0
26192495,12867695,0,"<p>For Efficiency try this 
Its java version but you can try the same logic for C. </p>

<pre><code>    boolean prime;
    int iCount = 0;
    int jCount = 0;
    for(i = 2; i &lt;= 100; i++)
    {
        iCount +=  1;

      prime = true;
      int squared = (int) (Math.sqrt(i));

      for(j = 2; j &lt; squared; j++){
          jCount += 1;

        if(i%j == 0) prime = false;
      }
      if(prime) System.out.print(i+"" "");
    }
</code></pre>
",0
22118625,13484943,0,"<p>Here is preorder routine that prints a general tree graph in a compact way:</p>

<pre><code>        void preOrder(Node* nd, bool newLine=false,int indent=0)
        {
                if(nd != NULL) {    
                        if (newLine &amp;&amp; indent) {
                                std::cout &lt;&lt; ""\n"" &lt;&lt; std::setw(indent) &lt;&lt; ' '
                        }  else if(newLine)
                                std::cout &lt;&lt; ""\n"";
                        cout&lt;&lt; nd-&gt;_c;
                        vector&lt;Node *&gt; &amp;edges=nd-&gt;getEdges();
                        int eSize=edges.size();
                        bool nwLine=false;
                        for(int i=0; i&lt;eSize; i++) {
                                preOrder(edges[i],nwLine,indent+1);
                                nwLine=true;
                        }
                }
        }

int printGraph()
{
     preOrder(root,true);
}
</code></pre>
",0
29179316,13207417,0,"<pre><code>#include &lt;stdio.h&gt; 
#include &lt;cmath&gt;

bool BePrime(unsigned int N){
    if(N == 2) return true;

    for(int i = 2; i &lt;= int(sqrt(N)); i++) {
        if(N%i == 0) return false;
    }
    return true;
}

main(){
    int a;
    while(scanf(""%d"",&amp;a)){
        if(BePrime(a)) {
            printf(""%d is Prime\n"", a);
            continue;
        }
        printf(""%d is not Prime\n"", a);
    }

}
</code></pre>
",0
28312037,14516915,3,"<p>you could read and write to a seperately like others.
But if you want to write into the same one, you could try with this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;

using namespace std;

int main() {

    double data[size of your data];

    std::ifstream input(""file.txt"");

    for (int i = 0; i &lt; size of your data; i++) {
        input &gt;&gt; data[i];
        std::cout&lt;&lt; data[i]&lt;&lt;std::endl;
        }

}
</code></pre>
",1
25698744,15489597,1,"<p>This problem appeared to me when I added .c file instead of .cpp
so check the name of the files as well</p>
",0
27551993,13861389,1,"<p>Just got this compiled with the gnu compiler 4.9.x. With newer versions of the compiler, there are more steps needed to compile libaws. </p>

<p>Here's what I had to do:</p>

<p>1) Add the following line to the header files in libaws-0.9.2/include/libaws/*.h, after all of the other include statements:</p>

<pre><code>#include &lt;stdint.h&gt;
</code></pre>

<p>2) Add the following line to libaws-0.9.2/include/libaws/aws.h, after all of the other include statements:</p>

<pre><code>#include &lt;getopt.h&gt;
</code></pre>

<p>3) If you're using a recent version of the Gnu C++ compiler, you'll need to modify the CMAKE files to add some flags to the compiler, so that the older C++ syntax used in libaws doesn't throw compiler errors. </p>

<p>Add this line to CMakeCompiler.txt, after all of the other CMAKE_CXX_FLAGS commands, around line 82 (which should be a blank line):</p>

<pre><code>SET(CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS} -fpermissive -Wignored-qualifiers"")
</code></pre>

<p>FYI: If you're using the Gnu C compiler, you may need a similar line for the C sections, at the end of the other CMAKE commands. Something like this at the end of the file might work, but I haven't tried it:</p>

<pre><code>SET(CMAKE_C_FLAGS ""${CMAKE_C_FLAGS} -fpermissive -Wignored-qualifiers"")
</code></pre>

<p>Once those are done, here are the steps to compile:</p>

<pre><code>cd libaws-0.9.2
mkdir libawsbuild
cd libawsbuild
cmake ..
make
</code></pre>

<p>When this is successful, you also may need to copy config.h from libawsbuild/include to libaws-0.9.2/include/libaws in order for the compiler to find config.h in the place it expects, when you compile whatever code you're writing to actually use libaws. (Although that may just have been the way my personal makefile was configured. Don't quote me on that.)</p>
",0
33519150,15234021,0,"<pre><code>#include &lt;iostream&gt;

using namespace std;

int main()
{
    string password;
    int pCounter = 0;
    cout &lt;&lt; ""Enter Password here: "";
    getline(cin, password);
    while(pCounter &lt;= 4){
        if(password != ""winner""){
            cout &lt;&lt; ""Count: "" &lt;&lt; pCounter &lt;&lt; endl;
            cout &lt;&lt; ""Try again..wrong entry.."" &lt;&lt; endl;
            cout &lt;&lt; ""Enter Password here: "";
            getline(cin, password);
            ++pCounter;
                if((password != ""winner"") &amp;&amp; (pCounter == 4)){
                    cout &lt;&lt; ""The End..No more tries!!"" &lt;&lt; endl;
                    break;
                }
        }

        else{
            cout &lt;&lt; ""Welcome In Bro"" &lt;&lt; endl;
            break;
        }
    }
    return 0;
}
</code></pre>
",1
29498337,15629198,0,"<p>Since your friend declaration doesn't have the <code>inline</code> specifier, this is obviously a bug in MSVC compiler. You can suppress the warning with a compiler option or a pragma:</p>

<pre><code>#pragma warning(disable: 4396)
</code></pre>
",0
30710005,17902766,0,"<p>What you are trying is that was normally called serialization.</p>

<p>The idea is to write class instances ( all data contained ) and an ID which can be the address of the instance because this is a very well unique id. Your serialization library takes care that only one instance is written ( as only one data set is needed ) and all later writes of this instance are done only by writing the pointer.</p>

<p>Reading back is quite simple as well. You serialization library knows that it needs a instance of a class, generate a new one with the content as written before if not already done with the unique id ( maybe the pointer/address as mentioned before ). After that every try to get a ""read pointer"" results in setting the pointer the actual value of the new generated instance.</p>

<p>Have a look for serializer pattern or a concrete implementation like boost::serialize  <a href=""http://www.boost.org/doc/libs/1_58_0/libs/serialization/doc/index.html"" rel=""nofollow"">http://www.boost.org/doc/libs/1_58_0/libs/serialization/doc/index.html</a></p>
",0
25701728,17946772,2,"<p>I had a same problem and this fixed it:</p>

<p>You should add:</p>

<p><code>C:\Program Files (x86)\Microsoft SDKs\Windows\v7.1A\Lib\x64</code>    <em>for 64 bit system</em></p>

<p><code>C:\Program Files (x86)\Microsoft SDKs\Windows\v7.1A\Lib</code>        <em>for 32 bit system</em> </p>

<p>in <code>Property Manager</code>><code>Linker</code>><code>General</code>><code>Additional Library Directories</code> </p>
",0
33826354,17482057,0,"<p>Do you have a typo in your .h? I once came across this error when i had the method properly called in my main, but with a typo in the .h/.cpp (a ""g"" vs a ""q"" in the method name, which made it kinda difficult to spot). 
It falls under the ""copy/paste error"" category.</p>
",0
29199659,17398959,0,"<p>The reason is the same as 
int a = 1000000000;
long long b = a * 100000000; would give error. When compilers multiplies these numbers it evaluates it as ints, since a and literal 1000000000 are ints, and since 10^18 is much more large than the upper bound of int, it will give error.
In your case we have s.length() - 3, as s.length() is unsigned int, it cant be negative, and since s.length() - 3 is evaluated as unsigned int, and its value is -1, it gives error here too.</p>
",0
22438767,18006748,9,"<p>Well the following code works well for fast output using <strong>putchar_unlocked()</strong>.<br></p>

<pre><code>  #define pc(x) putchar_unlocked(x);
    inline void writeInt (int n)
    {
        int N = n, rev, count = 0;
        rev = N;
        if (N == 0) { pc('0'); pc('\n'); return ;}
        while ((rev % 10) == 0) { count++; rev /= 10;} //obtain the count of the number of 0s
        rev = 0;
        while (N != 0) { rev = (rev&lt;&lt;3) + (rev&lt;&lt;1) + N % 10; N /= 10;}  //store reverse of N in rev
        while (rev != 0) { pc(rev % 10 + '0'); rev /= 10;}
        while (count--) pc('0');
    }
</code></pre>

<p>Normally Printf is quite fast for outputs,however for writing Integer or Long Outputs,the below function is a tad bit faster.<br> Here we use the putchar_unlocked() method for outputting a character which is similar thread-unsafe version of putchar() and is faster.</p>

<p><a href=""http://bufferedbyteswriter.blogspot.in/2013/03/fast-inputoutput-in-c.html"">See Link.</a></p>
",3
