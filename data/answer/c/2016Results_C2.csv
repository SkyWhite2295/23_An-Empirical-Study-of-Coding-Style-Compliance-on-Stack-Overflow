43934760,1294649,5,"<p>I know this is an old post but the quality of the present posted answers is depressing...</p>

<p>These are the issues to consider:</p>

<ul>
<li>Implicit integer promotion of shorts (or other small integer types) will result in an operand of type <code>int</code> which is signed. This will happen regardless of the signedness of the small integer type. Integer promotion happens in the shift operations and in the bitwise OR.</li>
<li>In case of the shift operators, the resulting type is that of the promoted left operand. In case of bitwise OR, the resulting type is obtained from ""the usual arithmetic conversions"".</li>
<li>Left-shifting a negative number results in undefined behavior. Right-shifting a negative number results in implementation-defined behavior (logical vs arithmetic shift). Therefore signed numbers should not be used together with bit shifts in 99% of all use-cases.</li>
<li>Unions, arrays and similar are poor solutions since they make the code endianess-dependent. In addition, type punning through unions is also not well-defined behavior in C++ (unlike C). Pointer-based solutions are bad since they will end up violating ""the strict aliasing rule"".</li>
</ul>

<p>A proper solution will therefore:</p>

<ul>
<li>Use operands with types that are guaranteed to be unsigned and will not be implicitly promoted.</li>
<li>Use bit-shifts, since these are endianess-independent.</li>
<li>Not use some non-portable hogwash solution with unions or pointers. There is absolutely nothing gained from such solutions except non-portability. Such solutions are however likely to invoke one or several cases of undefined behavior.</li>
</ul>

<p>It will look like this:</p>

<pre><code>int32_t  i32 = (int32_t)( (uint32_t)s1&lt;&lt;16 | (uint32_t)s2 );
</code></pre>

<p>Any other solution is highly questionable and at best non-portable.</p>
",2
37113458,2008398,5,"<p>EDITED (3jun2020)
This trick works IN ALL C COMPILERS. For Visual C++:</p>

<pre><code>struct X {
    int a,b;
    int c[10];
};
int _tmain(int argc, _TCHAR* argv[])
{
    int dummy;

    switch (dummy) {
    case sizeof(X):
    case sizeof(X):
        break;
    }
    return 0;
}
</code></pre>

<blockquote>
  <p>------ Build started: Project: cpptest, Configuration: Debug Win32 ------ cpptest.cpp c:\work\cpptest\cpptest\cpptest.cpp(29): error C2196: case value '48' already used ========== Build: 0 succeeded, 1
  failed, 0 up-to-date, 0 skipped ==========</p>
</blockquote>

<p>For other compilers that only print ""duplicate case value"", see my answer to this question:
<a href=""https://stackoverflow.com/questions/20979565/how-can-i-print-the-result-of-sizeof-at-compile-time-in-c"">How can I print the result of sizeof() at compile time in C?</a></p>
",5
40762790,3674456,1,"<p>The compiler is right, according to ISO C++ <a href=""http://eel.is/c++draft/expr.unary.op#3"" rel=""nofollow noreferrer"">&sect; 5.3.1.3</a>:</p>

<blockquote>
  <p>The result of the unary &amp; operator is a pointer to its operand. The
  operand shall be an lvalue or a qualified-id.</p>
</blockquote>

<p>In other words, you can take an address of anything that <em>has a name</em>.</p>

<p>Values returned from functions <strong><em>by-value</em></strong> have no name and are often returned via a <em>register</em>. So there is no ""<em>address</em>"" to speak of as the value is not residing in memory!</p>

<p>One could argue that the compiler could be smarter, detect this and store the value on the stack for the duration of the expression in which the address is used. But that is error-prone (you can ""leak"" a pointer to outside the expression), and would clearly be an <em>extension</em> of the standard (i.e. not guaranteed to be compatible). So MSVC simply prohibits it.</p>

<p>Entertainingly, the compiler <a href=""http://en.cppreference.com/w/cpp/language/reference_initialization"" rel=""nofollow noreferrer""><em>is</em> that smart</a> when it comes to a <em>reference</em> to an rvalue. But there is no such functionality for a <em>pointer</em> to an rvalue.</p>

<p><strong>To answer your question</strong>: try to minimize taking addresses of stuff; taking an address of a variable prevents the optimizer from putting it into a register.
But if you have to, return a reference instead:</p>

<pre><code>class a {
private:
    int dummy;
public:
    int get_dummy() const {
        return dummy;
    }
    int&amp; get_dummy() {
        return dummy;
    }
};

int main()
{
    a aa;

    int* me = &amp;(aa.get_dummy());
}
</code></pre>

<p>Note that having a <code>const get_dummy()</code> is not strictly needed, but will help the optimizer in rvalue contexts.</p>
",0
44705478,5340928,7,"<p>No need for a separate class to manage the hierarchy. A nice solution can be found in <em>C++ Concurrency in Action</em>, by Anthony Williams (<a href=""https://www.manning.com/books/c-plus-plus-concurrency-in-action"" rel=""nofollow noreferrer"">ISBN 9781933988771</a>):</p>

<pre><code>#include &lt;mutex&gt;
#include &lt;stdexcept&gt;

class hierarchical_mutex
{
    std::mutex internal_mutex;
    unsigned long const hierarchy_value;
    unsigned long previous_hierarchy_value;
    static thread_local unsigned long this_thread_hierarchy_value;

    void check_for_hierarchy_violation()
    {
        if(this_thread_hierarchy_value &lt;= hierarchy_value)
        {
            throw std::logic_error(""mutex hierarchy violated"");
        }
    }
    void update_hierarchy_value()
    {
        previous_hierarchy_value=this_thread_hierarchy_value;
        this_thread_hierarchy_value=hierarchy_value;
    }
public:
    explicit hierarchical_mutex(unsigned long value):
        hierarchy_value(value),
        previous_hierarchy_value(0)
    {}
    void lock()
    {
        check_for_hierarchy_violation();
        internal_mutex.lock();
        update_hierarchy_value();
    }
    void unlock()
    {
        this_thread_hierarchy_value=previous_hierarchy_value;
        internal_mutex.unlock();
    }
    bool try_lock()
    {
        check_for_hierarchy_violation();
        if(!internal_mutex.try_lock())
            return false;
        update_hierarchy_value();
        return true;
    }
};
thread_local unsigned long
    hierarchical_mutex::this_thread_hierarchy_value(ULONG_MAX);       

int main()
{
    hierarchical_mutex m1(42);
    hierarchical_mutex m2(2000);
}
</code></pre>
",0
46094689,877523,4,"<p>I ran into a case where I got that error message and had</p>

<pre><code>Foo foo(Bar());
</code></pre>

<p>and was basically trying to pass in a temporary Bar object to the Foo constructor. Turns out the compiler was translating this to</p>

<pre><code>Foo foo(Bar(*)());
</code></pre>

<p>that is, a function declaration whose name is foo that returns a Foo that takes in an argument -- a function pointer returning a Bar with 0 arguments. When passing in temporaries like this, better to use <code>Bar{}</code> instead of <code>Bar()</code> to eliminate ambiguity.</p>
",0
46619381,1826159,0,"<p>The best answer would be to use XOR and to use it in one line would be cool. </p>

<pre><code>    (x ^= y), (y ^= x), (x ^= y);
</code></pre>

<p>x,y are variables and the comma between them introduces the sequence points so it does not become compiler dependent. Cheers!</p>
",0
34916379,1826159,1,"<p>Consider <code>a=10</code>, <code>b=15</code>:</p>

<blockquote>
  <p>Using Addition and Subtraction</p>
</blockquote>

<pre><code>a = a + b //a=25
b = a - b //b=10
a = a - b //a=15
</code></pre>

<blockquote>
  <p>Using Division and multiplication</p>
</blockquote>

<pre><code>a = a * b //a=150
b = a / b //b=10
a = a / b //a=15
</code></pre>
",2
39681575,879535,22,"<p>Bjarne Stroustrup, the creator of C++, says in his book <em>The C++ Programming Language 4th edition</em>, 23.2.1 Defining a Template:</p>

<blockquote>
  <p>There are people who make semantic distinctions between the terms <em>class template</em> and <em>template class</em>. I don't; that would be too subtle: please consider those terms interchangeable. Similarly, I consider <em>function template</em> interchangeable with <em>template function</em>.</p>
</blockquote>
",0
37963536,5803953,3,"<p>A static constructor is used to initialize static data of a class. C++ doesn't have static constructor. But a static constructor can be emulated by using a friend class or nested class as below.</p>

<pre><code>class ClassStatic{
private:
    static char *str;
public:
    char* get_str() { return str; }
    void set_str(char *s) { str = s; }
    // A nested class, which used as static constructor
    static class ClassInit{
    public:
        ClassInit(int size){ 
            // Static constructor definition
            str = new char[size];
            str = ""How are you?"";
        }
    } initializer;
};

// Static variable creation
char* ClassStatic::str; 
// Static constructor call
ClassStatic::ClassInit ClassStatic::initializer(20);

int main() {
    ClassStatic a;
    ClassStatic b;
    std::cout &lt;&lt; ""String in a: "" &lt;&lt; a.get_str() &lt;&lt; std::endl;
    std::cout &lt;&lt; ""String in b: "" &lt;&lt; b.get_str() &lt;&lt; std::endl;
    a.set_str(""I am fine"");
    std::cout &lt;&lt; ""String in a: "" &lt;&lt; a.get_str() &lt;&lt; std::endl;
    std::cout &lt;&lt; ""String in b: "" &lt;&lt; b.get_str() &lt;&lt; std::endl;
    std::cin.ignore();
}
</code></pre>

<p>Output:</p>

<pre><code>String in a: How are you?
String in b: How are you?
String in a: I am fine
String in b: I am fine
</code></pre>
",0
39676888,11387370,-1,"<p>You can try to use <code>std::stringstream</code> and <code>atoi()</code>:</p>

<pre><code>#include &lt;sstream&gt;
#include &lt;stdlib.h&gt;
unsigned long int a = ...;
std::stringstream ss;
ss &lt;&lt; a;
std::string str = ss.str();
int i = atoi(str.c_str());
</code></pre>
",0
42496803,1751346,5,"<p>Wanted to share this C++14 modern, generic solution. Originally demonstrated <a href=""https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/"" rel=""noreferrer"">here</a>.</p>

<pre><code>template&lt;class T&gt; 
auto as_unsigned(T t) 
{ 
    return std::make_unsigned_t&lt;T&gt;(t); 
}
</code></pre>

<p>Which may be used as follows:</p>

<pre><code>auto sx = int32_t{ 55 };
auto ux = as_unsigned(sx);
</code></pre>

<p>You can see it in action <a href=""http://ideone.com/PzM5o2"" rel=""noreferrer"">here</a>.</p>
",1
47982837,2890722,1,"<p>This is a very old question, but since there's no definitive answer yet: C++11's raw string literals seem to do the job.</p>

<p>This compiles nicely on GCC 4.8:</p>

<pre><code>#include &lt;string&gt;

std::string data = R""(
    ... &lt;1.4 MB of base85-encoded string&gt; ...
)"";
</code></pre>

<p>As said in other posts in this thread, this is definitely not the preferred way of handling large amounts of data.</p>
",0
44357149,2781899,0,"<pre><code>#define itertype(v) typeof((v).begin())
itertype(cars) it = cars.find(name);
return it != cars.end();
</code></pre>
",2
47465645,2314066,0,"<p>Some coders prefer to only have a single exit/return from their functions. The use of a dummy do { .... } while(false); allows you to ""break out"" of the dummy loop once you've finished and still have a single return. </p>

<p>I'm a java coder, so my example would be something like</p>

<pre><code>import java.util.Arrays;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class p45
{
    static List&lt;String&gt; cakeNames = Arrays.asList(""schwarzwald torte"", ""princess"", ""icecream"");
    static Set&lt;Integer&gt; forbidden = Stream.of(0, 2).collect(Collectors.toSet());

    public static  void main(String[] argv)
    {
        for (int i = 0; i &lt; 4; i++)
        {
            System.out.println(String.format(""cake(%d)=\""%s\"""", i, describeCake(i)));
        }
    }


    static String describeCake(int typeOfCake)
    {
        String result = ""unknown"";
        do {
            // ensure type of cake is valid
            if (typeOfCake &lt; 0 || typeOfCake &gt;= cakeNames.size()) break;

            if (forbidden.contains(typeOfCake)) {
                result = ""not for you!!"";
                break;
            }

            result = cakeNames.get(typeOfCake);
        } while (false);
        return result;
    }
}
</code></pre>
",0
37032316,1753189,2,"<p>Agree with the above. Also, if you see this, preprocess the app and look at the .i
Search for the ""offending"" name. Then look back up. You'll often see the ""}"" w/o "";"" on a class in the first non-with space above. Finding the problem is often harder than knowing what it is.</p>
",1
48033350,9215210,4,"<pre><code>//Array declaration
bool arr[10];

//To initialize all the elements to true

memset(arr,1,sizeof(arr));
</code></pre>

<p>Similarly, you can initialize all the elements to false, by replacing 1 with 0.</p>
",0
48014475,3057789,0,"<p>The reason for this restriction is enforcement of access control across different classes that share a common base.</p>

<p>This is reinforced by notes in <a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#385"" rel=""nofollow noreferrer"">Core Language Defects Report defect #385</a>, the relevant part copied here for reference:</p>

<blockquote>
  <p>[...] the reason we have this rule is that <code>C</code>'s use of inherited protected members might be different from their use in a sibling class, say <code>D</code>. Thus members and friends of <code>C</code> can only use <code>B::p</code> in a manner consistent with <code>C</code>'s usage, i.e., in <code>C</code> or derived-from-<code>C</code> objects.</p>
</blockquote>

<p>As an example of something this rule prevents:</p>

<pre><code>class B {
protected:
    void p() { };
};

class C : public B {
public:
    typedef void (B::*fn_t)();
    fn_t get_p() {
        return &amp;B::p; // compilation error here, B::p is protected
    }
};

class D : public B { };

int main() {
    C c;
    C::fn_t pbp = c.get_p();
    B * pb = new D();
    (pb-&gt;*pbp)();
}
</code></pre>

<p>The protected status of <code>D::p</code> is something we want the compiler to enforce, but if the above compiled that would not be the case.</p>
",0
44359475,4533652,11,"<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;

int main()
{
  std::istringstream iss { ""Cpp|is|fun"" };

  std::string s;
  while ( std::getline( iss, s, '|' ) )
    std::cout &lt;&lt; s &lt;&lt; std::endl;

  return 0;
}
</code></pre>

<p><a href=""http://ideone.com/sMGPk4"" rel=""noreferrer"">Demo</a></p>
",0
46132942,6469849,0,"<p><strong>100% Certain you correctly included Guards but still getting redefinition error?</strong></p>

<p><strong>For Visual Studio:</strong>
I was really frustrated because I was correctly included guards,
only to find out the problem was visual studio. If you have added the file
to your project, the compiler will add the file twice even if you have
include guards around your implementation file and header file.</p>

<p>If you don't use visual studio exclusively, and say... use code::blocks sometimes, you might want to only #include the file when you detect the absence of the visual studio environment.</p>

<pre><code>DebugUtil.h :
----------------------
#ifndef _WIN32
#include ""DebugUtil.c""
#endif
----------------------
</code></pre>

<p>If you are okay with including stdio.h,
you can be a little less hackish about it:</p>

<pre><code>DebugUtil.h :
----------------------
#include &lt;stdio.h&gt;
#ifdef _MSC_VER
#include ""DebugUtil.c""
#endif
----------------------
</code></pre>

<p>Reference:
Predefined Macros, Visual Studio:
<a href=""https://msdn.microsoft.com/en-us/library/b0084kay.aspx"" rel=""nofollow noreferrer"">https://msdn.microsoft.com/en-us/library/b0084kay.aspx</a></p>
",0
36327567,8046357,13,"<p>This method is efficient and should work with output strings as well:</p>

<pre><code>ostringstream report_string;

if (report_string.tellp() == 0) {
    // do something
}
</code></pre>
",4
36511178,5806305,0,"<p>Ofc you can call it from an object instance , see this code :</p>

<pre><code> #include &lt;iostream&gt;
class foo{
      public :
      int foo_var;
      foo(){
            std::cout&lt;&lt;""foo_var = ""&lt;&lt;foo_var&lt;&lt;std::endl;
            }
      };
int main()
{
    foo * f = new foo();
    // set foo_var
    f-&gt;foo_var = 10;
    // call constructor by passing object instanse
    foo * f1 = new(f) foo;
    std::cout&lt;&lt;(f==f1)&lt;&lt;std::endl;
    system(""pause"");
    return 0;
}
</code></pre>

<p>the second output is ""foo_var = 10"" so it is working . the third output is ""true"" then (f==f1) that mean the constructor does not allocate new memory (the operator new does , but we passed a pointer to it so he wont alloc an other) 
there you are a really usefull practice : </p>

<pre><code>#include &lt;iostream&gt;
template &lt;class t&gt;
class smart_pointer{
      t * p; // the real normal pointer
      public :
      smart_pointer()
      {
          p = (t*) malloc(sizeof(t)); // allocate memory 
          try{ 
          new (p) t; // call the constructor 
          } catch (...)  // if it throws any exception
          {
                  free(p); // free p , dont use delete , because it will
                  // call the destroctor calling the destructor will cause 
                  // freeing a not allocated memory that causes a crash
                  throw; // throw the exception what ever it was
          }

      }
      ~smart_pointer(){delete p;}
      t operator = (t val) // assigment operator
      {
               *p = val;
               return val;
      }
      operator t(){ // type casting operator , usually for std::cout
               return *p;
               }
      };
int main()
{
    smart_pointer&lt;int&gt; x;
    x = 10;
    std::cout&lt;&lt;x&lt;&lt;std::endl;
    system(""pause"");
    return 0;
}
</code></pre>

<p>it is recommended  to read ""effective c++"" , ""more effective c++"" , ""effective modern c++"" books</p>
",0
35203160,3521914,1,"<p>The garbage is introduced if you </p>

<ol>
<li>assign a string</li>
<li>then assign an int or float</li>
<li>then a string again</li>
</ol>

<p>string manages memory somewhere else. This information is most likely some pointer. This pointer is garbaged when assigning the int. Assigning a new string should destroy the old string, which is not possible.</p>

<p>The second step should destroy the string, but does not know, if there has been a string.</p>

<p>They obviously have found a solution for this problem in the meantime. </p>
",2
35290214,4781852,9,"<pre><code>#include &lt;ctime&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;

// Converts UTC time string to a time_t value.
std::time_t getEpochTime(const std::wstring&amp; dateTime)
{
   // Let's consider we are getting all the input in
   // this format: '2014-07-25T20:17:22Z' (T denotes
   // start of Time part, Z denotes UTC zone).
   // A better approach would be to pass in the format as well.
   static const std::wstring dateTimeFormat{ L""%Y-%m-%dT%H:%M:%SZ"" };

   // Create a stream which we will use to parse the string,
   // which we provide to constructor of stream to fill the buffer.
   std::wistringstream ss{ dateTime };

   // Create a tm object to store the parsed date and time.
   std::tm dt;

   // Now we read from buffer using get_time manipulator
   // and formatting the input appropriately.
   ss &gt;&gt; std::get_time(&amp;dt, dateTimeFormat.c_str());

   // Convert the tm structure to time_t value and return.
   return std::mktime(&amp;dt);
}
</code></pre>
",1
34971745,3246803,1,"<p>It is generally expected that modules of code such as <code>.cpp</code> files are compiled once and linked to in multiple projects, to avoid unnecessary repetitive compilation of logic. For example, <code>g++ -o class.cpp</code> would produce <code>class.o</code> which you could then link from multiple projects to using <code>g++ main.cpp class.o</code>.</p>

<p>We could use <code>#include</code> as our linker, as you seem to be implying, but that would just be silly when we know how to link properly using our compiler with less keystrokes and less wasteful repetition of compilation, rather than our code with more keystrokes and more wasteful repetition of compilation...</p>

<p>The header files are still required to be included into each of the multiple projects, however, because this provides the interface for each module. Without these headers the compiler wouldn't know about any of the symbols introduced by the <code>.o</code> files.</p>

<p>It is important to realise that the header files are what introduce the definitions of symbols for those modules; once that is realised then it makes sense that multiple inclusions could cause redefinitions of symbols (which causes errors), so we use include guards to prevent such redefinitions.</p>
",0
37699122,3207018,10,"<p><code>register</code> is deprecated in C++11. It is unused and reserved in C++17.</p>

<p>Source: <a href=""http://en.cppreference.com/w/cpp/keyword/register"" rel=""nofollow noreferrer"">http://en.cppreference.com/w/cpp/keyword/register</a></p>
",0
34945494,3387557,0,"<pre><code>struct  ABC{
    int a;
    float b;
    char c;
};
int main(){
    struct ABC *ptr=(struct ABC *)0;
    ptr++;
    printf(""Size of structure is: %d"",*ptr);
    return 0;
}
</code></pre>

<p>This is an alternate way to find size of <code>struct</code> without using <code>sizeof</code>.</p>
",1
35218721,4715831,2,"<p>Pointing to define doing what they where invented for as a failure is - well blaming a knife for cutting. </p>

<p>If you dont not properly Name your defines with UPPERCASE_NAMES you will have troubles, but you will have those troubles anyway in C if you can not self-discipline your working style.</p>

<p>You can not use const to generate dynamically rearranging systems, so its not suited for any embedded Application that is tailored pre-compile to usage.Const can only be assigned pre-evaluation constants, so not even other const Expressions.</p>

<p>Just because a Tool doese not bow to the OO-Paradigm its does not suddenly become useless. Const is not equal replacement regarding functionality.</p>
",0
42585959,4112519,-1,"<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;cstddef&gt;
#include&lt;map&gt;

using std::cout;
using std::cin;
using std::string;
using std::endl;
using std::vector;
using std::map;

int main() {

    cout &lt;&lt; ""Please enter a string: "" &lt;&lt; endl;
    string str;
    getline(cin, str, '\n');

    size_t str_len = str.size();
    cout &lt;&lt; endl &lt;&lt; endl;

    size_t i = 0, j = 0;
    bool pop = false;

    map&lt;string, int&gt; myMap;

    for (size_t k = 0; k &lt; str_len-1; k++) {
        if (((k == 0) &amp;&amp; isalpha(str[0])) || (!(isalpha(str[k-1])) &amp;&amp; isalpha(str[k])))
            i = k;
        if ( isalpha(str[k]) &amp;&amp; !(isalpha(str[k+1])) ) {
            j = k;
            pop = true;
        }
        if ( (k == str_len-2) &amp;&amp; isalpha(str[k+1]) ) {
            j = k+1;
            pop = true;
        }

        if ( (i &lt;= j) &amp;&amp; pop ) {
            string tmp = str.substr(i, j-i+1);
            cout &lt;&lt; tmp &lt;&lt; '\t';
            myMap[tmp]++;
            pop = false;
        }
    }
    cout &lt;&lt; endl &lt;&lt; endl;

    map&lt;string, int&gt;::iterator itr, end = myMap.end();
    for (itr = myMap.begin(); itr != end; itr++)
        cout &lt;&lt; itr-&gt;first &lt;&lt; ""\t - - - - - \t"" &lt;&lt; itr-&gt;second &lt;&lt; endl;

    cout &lt;&lt; endl;

    return 0;
}
</code></pre>
",1
35252979,12278523,5,"<p><code>epsilon()</code> is only the difference between <code>1.0</code> and the next value representable after <code>1.0</code>, the real min.  The library function <code>std::nextafter</code> can be used to scale the equality precision test for numbers of any magnitude.</p>

<p>For example using <code>std::nextafter</code> to test <code>double</code> equality, by testing that b is both &lt;= next number lower than a &amp;&amp; >= next number higher than a:</p>

<pre><code>bool nearly_equal(double a, double b)
{
  return std::nextafter(a, std::numeric_limits&lt;double&gt;::lowest()) &lt;= b
    &amp;&amp; std::nextafter(a, std::numeric_limits&lt;double&gt;::max()) &gt;= b;
}
</code></pre>

<p>This of course, would only be <code>true</code> if the bit patterns for a &amp; b are the same.  So it is an inefficient way of doing the (incorrect) naive direct a == b comparrison, therefore :</p>

<p>To test two <code>double</code> for equality within some factor scaled to the representable difference, you might use:</p>

<pre><code>bool nearly_equal(double a, double b, int factor /* a factor of epsilon */)
{
  double min_a = a - (a - std::nextafter(a, std::numeric_limits&lt;double&gt;::lowest())) * factor;
  double max_a = a + (std::nextafter(a, std::numeric_limits&lt;double&gt;::max()) - a) * factor;

  return min_a &lt;= b &amp;&amp; max_a &gt;= b;
}
</code></pre>

<p>Of course working with floating point, analysis of the calculation precision would be required to determine how representation errors build up, to determine the correct minimum factor.</p>
",7
36305108,4324169,3,"<p>If you are looking for small but powerful project I recomend you <a href=""https://github.com/DGLE-HQ/DGLE"" rel=""nofollow"">DGLE</a> - minimalistic, cross-platform, multi-render(OpenGL, DirectX) graphic engine with plugin based architectire wrtitten in modern C++. Unlike similar projects it only takes about 20-30 files. Also developers regularly updates sources to accomodate C++11/14/17...</p>
",0
40777365,4261589,0,"<p>Based on icecrime's answer I wrote this function</p>

<pre><code>std::vector&lt;int&gt; intToDigits(int num_)
{
    std::vector&lt;int&gt; ret;
    string iStr = to_string(num_);

    for (int i = iStr.size() - 1; i &gt;= 0; --i)
    {
        int units = pow(10, i);
        int digit = num_ / units % 10;
        ret.push_back(digit);
    }   

    return ret;
}
</code></pre>
",0
48038561,4523178,0,"<p>I've found solution which should work with all implementations (IMO) of std::stack, but unfortunately the stack must use std::vector instead of queue.</p>

<pre><code>template&lt;typename T&gt;
void printStack(const std::stack&lt;T, std::vector&lt;T&gt;&gt;&amp; s)
{
    typedef typename std::stack&lt;T&gt;::const_reference EntryTypeRef;
    typedef std::remove_reference_t&lt;EntryTypeRef&gt; EntryType;

    for(size_t i=0; i &lt; s.size(); ++i)
    {
        EntryType* e = &amp;s.top();
        cout &lt;&lt; *(e-i) &lt;&lt; endl;
    }
}
</code></pre>

<p>std::vector is dynamic array, so we can use pointer arytmetics.</p>

<p>The marked answer to the question assumes, that the stack has field named 'c', I have another solution which would work with std::stack implementation which has container as first field, but its name does not matter:</p>

<pre><code>template&lt;typename T&gt;
void printStack(const std::stack&lt;T&gt;&amp; s)
{
    typedef typename std::stack&lt;T&gt;::container_type Container;

    const auto containerPtr = reinterpret_cast&lt;const Container*&gt;(&amp;s);

    for(auto e : *containerPtr)
        cout &lt;&lt; e &lt;&lt; endl;
}
</code></pre>
",0
39007394,4523178,2,"<p>Posting b/c I found this useful for debugging.  Pop from original into a temp and then pop from temp back into original:</p>

<pre><code>template &lt;typename T&gt;
void dump_stack(std::stack&lt;T&gt;&amp; stack) {
  std::stack&lt;T&gt; temp;
  while (!stack.empty()) {
    T top = stack.top(); stack.pop();
    std::cout &lt;&lt; top &lt;&lt; "" "";
    temp.push(top);
  }
  while (!temp.empty()) {
    T top = temp.top(); temp.pop();
    stack.push(top);
  }
}
</code></pre>
",0
46131376,4159936,0,"<p>use <code>std::is_base_of</code> from <code>&lt;type_traits&gt;</code> and <code>static_assert</code> to check at compile time</p>
",0
45211983,4337068,0,"<p>The .h files contain just the function declarations. The source containing the definitions is already compiled, so when you include a header, the linker looks for the function definitions in the libraries that you have linked. Most of the libraries are open source, some of them are just specifications that anyone can implement for example OpenGL, and the standard library is a specification, too. The same goes for the C++ language. Then programmers use the specifications to write implementations (GCC, VC++).</p>

<p>Here you can download the source code of STL C++ <a href=""https://www.sgi.com/tech/stl/download.html"" rel=""nofollow noreferrer"">https://www.sgi.com/tech/stl/download.html</a></p>
",0
47614981,5072845,3,"<p>Another place bracket scoping makes sense is inside macros.  For example, you could define a macro that declares variables of potentially the same name as variables inside the code block into which the macro is placed.</p>
",0
47614981,5072845,3,"<p>Another place bracket scoping makes sense is inside macros.  For example, you could define a macro that declares variables of potentially the same name as variables inside the code block into which the macro is placed.</p>
",0
46963010,6938219,8,"<p>I can't believe no one posted this yet... a solution that actually looks like C++ and isn't UB for breaking aliasing rules:</p>

<pre><code>#include &lt;algorithm&gt; // std::all_of
#include &lt;cstddef&gt;   // std::size_t

// You might only need this
bool
memory_is_all_zeroes(unsigned char const* const begin,
                     std::size_t          const bytes)
{
    return std::all_of( begin, begin + bytes,
                        [](unsigned char const byte) { return byte == 0; } );
}

// but here's this as a bonus
template&lt;typename T_Element, std::size_t T_count&gt;
bool
array_is_all_zeroes( T_Element const (&amp; array)[T_count] )
{
    auto const begin = reinterpret_cast&lt;unsigned char const*&gt;(array);
    auto const bytes = T_count * sizeof(T_Element);

    return memory_is_all_zeroes(begin, bytes);
}

int
main()
{
    int const blah[1000]{0};

    return !array_is_all_zeroes(blah);
}
</code></pre>

<p>This might not satisfy some people's assumptions about efficiency (which are just that, assumptions, until profiled), but I think being valid and idiomatic code are much in its favour.</p>
",0
43936613,4992926,0,"<p>This method leverages the <code>scanf</code> parser and works also in plain C:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int validateUUID(const char *candidate)
{
    int tmp;
    const char *s = candidate;
    while (*s)
        if (isspace(*s++))
            return 0;
    return s - candidate == 36
        &amp;&amp; sscanf(candidate, ""%4x%4x-%4x-%4x-%4x-%4x%4x%4x%c"",
        &amp;tmp, &amp;tmp, &amp;tmp, &amp;tmp, &amp;tmp, &amp;tmp, &amp;tmp, &amp;tmp, &amp;tmp) == 8;
}
</code></pre>

<p>Test with e.g.:</p>

<pre><code>int main(int argc, char *argv[])
{
    if (argc &gt; 1)
        puts(validateUUID(argv[1]) ? ""OK"" : ""Invalid"");
}
</code></pre>
",0
47534105,5882872,-1,"<p>You can use the getline function in c++</p>

<pre><code>#include&lt;iostream&gt;
using namespace std;
int main()
{
    char msg[100];
    cin.getline(msg,100);
    return 0;
}
</code></pre>
",0
34899230,5872415,0,"<p>If you want to sort two vectors simultaneously, you should rather create a std::vector (say c) of std::pair. <strong>First component must be the one which is to be sorted normally and second must be the one to be sorted accordingly.</strong></p>

<pre><code>std::vector&lt;std::pair&lt;double, T&gt;&gt; c;
std::sort(c.begin(), c.end());
</code></pre>

<p>Hope this helps.</p>
",0
47614824,9935027,0,"<p>Including:</p>

<pre><code>int main()
{ //code 
  return 0;
}
</code></pre>

<p>will help you. This problem usually occurs to those who are learning from book in which they usually don't use main function after a few chapters.</p>
",0
47614824,9935027,0,"<p>Including:</p>

<pre><code>int main()
{ //code 
  return 0;
}
</code></pre>

<p>will help you. This problem usually occurs to those who are learning from book in which they usually don't use main function after a few chapters.</p>
",0
41201127,15537817,16,"<p>I know it's been a while but I had similar needs and came up with this solution, hope it helps someone:</p>

<pre><code>#include &lt;functional&gt;

template&lt;typename Func, typename... Args&gt;
struct nest {
    std::function&lt;void()&gt; callBack;

    void setup(Func func1, Args... args) {
        callBack = [func1, args...]()
        {
            (func1)(args...);
        };
    }

    unsigned process() {
        callBack();
        return 0;
    }
};

template&lt;typename Func, typename... Args&gt;
void handleFunc(Func func, Args&amp;&amp;... args) {
    nest&lt;Func, Args...&gt; myNest;
    myNest.setup(func, args...);
}
</code></pre>
",5
38504880,10150468,29,"<p>Here is a short code snippet for shadowing cin/cout useful for programming contests:</p>

<pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int main() {
    ifstream cin(""input.txt"");
    ofstream cout(""output.txt"");

    int a, b;   
    cin &gt;&gt; a &gt;&gt; b;
    cout &lt;&lt; a + b &lt;&lt; endl;
}
</code></pre>

<p>This gives additional benefit that plain fstreams are faster than synced stdio streams.
But this works only for the scope of single function.</p>

<p>Global cin/cout redirect can be written as:</p>

<pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

void func() {
    int a, b;
    std::cin &gt;&gt; a &gt;&gt; b;
    std::cout &lt;&lt; a + b &lt;&lt; endl;
}

int main() {
    ifstream cin(""input.txt"");
    ofstream cout(""output.txt"");

    // optional performance optimizations    
    ios_base::sync_with_stdio(false);
    std::cin.tie(0);

    std::cin.rdbuf(cin.rdbuf());
    std::cout.rdbuf(cout.rdbuf());

    func();
}
</code></pre>

<p>Note that <code>ios_base::sync_with_stdio</code> also resets <code>std::cin.rdbuf</code>. So the order matters.</p>

<p>See also <a href=""https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull"">Significance of ios_base::sync_with_stdio(false); cin.tie(NULL);</a></p>

<p>Std io streams can also be easily shadowed for the scope of single file, which is useful for competitive programming:</p>

<pre><code>#include &lt;bits/stdc++.h&gt;

using std::endl;

std::ifstream cin(""input.txt"");
std::ofstream cout(""output.txt"");

int a, b;

void read() {
    cin &gt;&gt; a &gt;&gt; b;
}

void write() {
    cout &lt;&lt; a + b &lt;&lt; endl;
}

int main() {
    read();
    write();
}
</code></pre>

<p>But in this case we have to pick <code>std</code> declarations one by one and avoid <a href=""https://stackoverflow.com/questions/1265039/using-std-namespace""><code>using namespace std;</code></a> as it would give ambiguity error:</p>

<pre><code>error: reference to 'cin' is ambiguous
     cin &gt;&gt; a &gt;&gt; b;
     ^
note: candidates are: 
std::ifstream cin
    ifstream cin(""input.txt"");
             ^
    In file test.cpp
std::istream std::cin
    extern istream cin;  /// Linked to standard input
                   ^
</code></pre>

<p>See also <a href=""https://stackoverflow.com/questions/41590/how-do-you-properly-use-namespaces-in-c"">How do you properly use namespaces in C++?</a>, <a href=""https://stackoverflow.com/questions/1452721/why-is-using-namespace-std-considered-bad-practice"">Why is &quot;using namespace std&quot; considered bad practice?</a> and <a href=""https://stackoverflow.com/questions/3871474/how-to-resolve-a-name-collision-between-a-c-namespace-and-a-global-function"">How to resolve a name collision between a C++ namespace and a global function?</a></p>
",0
36573549,7340925,-1,"<p>I think you still need to be careful. I have a case where g++-4.9 with C++11 and complicated Eigen types does not respect this (it deletes data in the returned temporary even though its lifetime is supposed to be extended). Hence, even though it might be legal it should be flagged as dodgy unless there is a really good reason for it.</p>

<p>Also, given C++11 MUST allocate the temporary at the call site if returned by value its usefulness is perhaps less than it used to be if you are using the latest standard.</p>
",0
43975648,8462895,1,"<p>You can do something like this too: </p>

<pre><code>MyClass *myVar[num];

for(int i = 0; i &lt; num; i += 1)
{
    myVar[i] = new MyClass(0, 0);
}
</code></pre>
",0
44375695,12637779,4,"<p>My code for Linux</p>

<pre><code>// Debian GNU/Linux 8 ""Jessie"" (amd64)

#include &lt;locale.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

// Use wcstombs(3) to convert Unicode-string (wchar_t *) to UTF-8 (char *)
// http://man7.org/linux/man-pages/man3/wcstombs.3.html

int f(const wchar_t *wcs) {
        setlocale(LC_ALL,""ru_RU.UTF-8"");
        printf(""Sizeof wchar_t: %d\n"", sizeof(wchar_t));
        // on Windows, UTF-16 is internal Unicode encoding (UCS2 before WinXP)
        // on Linux, UCS4 is internal Unicode encoding
        for (int i = 0; wcs[i] &gt; 0; i++) printf(""%2d %08X\n"",i,wcs[i]);
        char s[256];
        size_t len = wcstombs(s,wcs,sizeof(s));
        if (len &gt; 0) {
                s[len] = '\0';
                printf(""mbs: %s\n"",s);
                for (int i = 0; i &lt; len; i++)
                        printf(""%2d %02X\n"",i,(unsigned char)s[i]);
                printf(""Size of mbs, in bytes: %d\n"",len);
                return 0;
        }
        else return -1;
}

int main() {
        f(L""妤把我志快找""); // 6 symbols
        return 0;
}
</code></pre>

<p>How to build</p>

<pre><code>#!/bin/sh
NAME=`basename $0 .sh`
CC=/usr/bin/g++-4.9
INCS=""-I.""
LIBS=""-L.""
$CC ${NAME}.c -o _${NAME} $INCS $LIBS
</code></pre>

<p>Output</p>

<pre><code>$ ./_test 
Sizeof wchar_t: 4
 0 0000041F
 1 00000440
 2 00000438
 3 00000432
 4 00000435
 5 00000442
mbs: 妤把我志快找
 0 D0
 1 9F
 2 D1
 3 80
 4 D0
 5 B8
 6 D0
 7 B2
 8 D0
 9 B5
10 D1
11 82
Size of mbs, in bytes: 12
</code></pre>
",0
37077201,9812411,18,"<p>Also you can declare of this forms:</p>

<pre><code>// first form
typedef vector&lt;int&gt; v1d;
typedef vector&lt;v1d&gt; v2d;
typedef vector&lt;v2d&gt; v3d;
v3d v(5, v2d(3, v1d(2, 4)));

// second form
vector&lt;vector&lt;vector&lt;int&gt; &gt; &gt; v = vector&lt;vector&lt;vector&lt;int&gt; &gt; &gt;( 5, vector&lt;vector&lt;int&gt; &gt;(3, vector&lt;int&gt;(2, 4)))
</code></pre>
",0
34914075,9278672,0,"<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;

using namespace std;

int main()
{
    double a = 0.0;
    vector&lt;double&gt; double_vec;

    int iterator = 0;
    double temp_smallest = 0;
    double temp_largest = 0;
    int count = 0;

    while (cin &gt;&gt; a)
    {
        // add i to the vector;
        double_vec.push_back(a);

        for (int i = 0; i &lt; count; i++)
        {
            if (double_vec[i] &gt; temp_largest)
            {
                temp_largest = double_vec[i];
            }

            else if (double_vec[i] &lt; temp_smallest)
            {
                temp_smallest = double_vec[i];
            }
        }

        if (temp_smallest &gt; a)
            cout &lt;&lt; ""smallest so far"" &lt;&lt; endl;
        else if (temp_largest &lt; a)
            cout &lt;&lt; ""largest so far"";
        count++;
    }

    system(""PAUSE"");

    return 0;
}
</code></pre>

<p>Chapter 4 does discuss vectors, there are a few modifications that can be added to perform tests on all values. This program works for <strong>most, but not all</strong> values.</p>
",1
40531655,11508228,1,"<p>I used the mingw32 compiler, when using g++ 4.8 it works fine. It seems to be a compiler error. (thanks to grizzly)</p>
",0
39670193,16381025,0,"<p>it's so important to make difference between deleting a single dim array and multi-dim allocated on the heap:</p>

<pre><code>#include &lt;iostream&gt;
using std::cout;
using std::endl;

int main()
{

    int*** ptrInt = new int**[3];

    for(int i(0); i &lt; 3; i++)
        ptrInt[i] = new int*[3];

    for(int i = 0; i &lt; 3; i++)
    {
        for(int j(0); j &lt; 3; j++)
            ptrInt[i][j] = new int[3];
    }


    for(int i = 0; i &lt; 3; i++)
    {
        for(int j(0); j &lt; 3; j++)
            for(int k(0); k &lt; 3; k++)
                ptrInt[i][j][k] = k;
    }

    for(int i = 0; i &lt; 3; i++)
    {
        for(int j(0); j &lt; 3; j++)
            for(int k(0); k &lt; 3; k++)
                cout &lt;&lt; ""ptrInt["" &lt;&lt; i &lt;&lt; ""]["" &lt;&lt; j &lt;&lt; ""]["" &lt;&lt; k &lt;&lt; ""]: "" &lt;&lt; ptrInt[i][j][k] &lt;&lt; endl;
    }

    // now freeing memory:

    for(int i = 0; i &lt; 3; i++)
    {
        for(int j(0); j &lt; 3; j++)
            delete[] ptrInt[i][j];
        delete[] ptrInt[i];
    }
    delete[] ptrInt;


    cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; endl;
    return 0;
}
</code></pre>
",0
34988371,12884766,0,"<p>To get the sum of all numbers divisible by two in the set [1,num] by using an iterative approach, you can loop through all numbers in that range, starting from num until you reach 2, and add the number of the current iteration to the total sum, if this is divisible by two.</p>

<p>Please note that you have to assign zero to evenSum2 before starting the loop, otherwise the result will not be the same of <em>formulaEvenSum()</em>.</p>

<pre><code>void loopEvenSum(int num, int&amp; evenSum2)
{
    assert(num &gt; 0);
    evenSum2 = 0;
    for (int i=num; i&gt;=2; --i) {
        if (0 == (i % 2)) {
            evenSum2 += i;
        }
    }
}
</code></pre>

<p>To get the same result by using a recursive approach, instead of passing by reference the variable that will hold the sum, i suggest you to return the sum at each call; otherwise you'll need to hold a counter of the current recursion or, even worse, you'll need to set the sum to zero in the caller before starting the recursion.</p>

<pre><code>int recursiveEventSum(int num)
{
    assert(num &gt; 0);
    if (num == 1) {
        return 0;
    } else {
        return ((num % 2) ? 0 : num) + recursiveEventSum(num-1);
    }
}
</code></pre>

<p>Please note that, since you get an even number only if you subtract two (not one) from an even number, you could do optimisation by iterating only on those numbers, plus eventually, the first iteration if num was odd.</p>
",0
47704957,13347466,0,"<p>i just edit few things  and it's work `if (myfile.is_open())</p>

<pre><code>{

            while(getline(myfile, line)){


                line_record::iterator existing = lines.find(line);

                if(existing != lines.end())
                {
                    existing-&gt;second = (-1);




                }
                else
                {

                    lines.insert(make_pair(line,line_number));
                    ++line_number;
                    cout&lt;&lt;line&lt;&lt;endl;

                    count++;
                }



            }

            cout &lt;&lt; ""its -- &gt; ""&lt;&lt;count &lt;&lt;"" record""&lt;&lt; endl;




    myfile.close();

}
</code></pre>

<p>`</p>
",0
43729788,14906323,0,"<p>This is how to do it pretty.</p>

<pre><code>template&lt;class It&gt;
struct range_t {
  It b; It e;

  It begin() const { return b; }
  It end() const { return e; }
};

template&lt;class It&gt;
range_t&lt;It&gt; range(It s, It f) {
  return {s,f};
}
</code></pre>

<p><code>range( start, finish )</code> is a helper that lets you create a range that can be <code>for(:)</code> iterated over.</p>

<pre><code>template&lt;class C&gt;
auto backwards(C&amp;&amp; c) {
  using std::rbegin; using std::rend;
  return range( rbegin(c), rend(c) );
}
</code></pre>

<p><code>backwards(container)</code> returns a range that iterates over the container backwards.</p>

<p>Once we have written the above library code, all the heavy lifting is done.  The remaining code reads almost as pretty as <a href=""/questions/tagged/python"" class=""post-tag"" title=""show questions tagged &#39;python&#39;"" rel=""tag"">python</a>:</p>

<pre><code>int main() {
  std::cout &lt;&lt; ""Enter some text (blank line to finish):\n"";
  std::string line;
  std::vector&lt;std::string&gt; lines;
  while (std::getline(std::cin, line))
    lines.push_back(line);
  for (auto&amp;&amp; line:backwards(lines))
    std::cout &lt;&lt; line &lt;&lt; ""\n"";
}
</code></pre>

<p>We get lines, buffer them, then print them backwards.</p>

<p><a href=""https://ideone.com/Q0pPjG"" rel=""nofollow noreferrer"">Live example</a>.</p>

<p>The goal here is to make the main program logic as clear as possible.  The <code>backwards</code> and <code>range</code> boilerplate just serves that need.</p>
",0
43729363,14906323,0,"<pre><code>#include&lt;iostream&gt;
using namespace std;

int main(){
    char str[100][100];
    for(int i =0; i &lt; 10 ; i++) {
        cin.getline(str[i],100);
    }
    for(int i = 9 ; i &gt;=0 ; i--) {
        cout&lt;&lt;str[i]&lt;&lt;endl;
    }
}
</code></pre>
",0
46070617,13606185,0,"<p>I have been in this situation a few times.
That is,
I designed a class that due to unacceptable performance requirements, it was basically immutable.
Immutable in the sense that its instance can defined at construction and never modified. 
In effect, all its member function were <code>const</code>.
(Well, there is a side question as it is whether it can be assignable still, but let's go on).</p>

<p>It would be nice to be able to force the use to declare the instances <code>const</code> to make the intent more evident.</p>

<p>I don't think C++ supports this without adding a level of indirection, that is to access the object through a const pointer and disabling direct construction. (Or even better a <code>unique_ptr</code>).</p>

<pre><code>struct A{ // this class is immutable, so in princple `A a` and `A const a` should behave the same
    int f() const{return 5;}
    private:
    A(){}
    public:
    template&lt;class... Args&gt;
    static A const* make_const(Args&amp;&amp;... args){return new A(std::forward&lt;Args&gt;(args)...);}
};

int main(){
    std::unique_ptr&lt;A const&gt; a(A::make_const());
    std::cout &lt;&lt; a-&gt;f() &lt;&lt; std::endl;
}
</code></pre>

<p>Note that the following doesn't compile, as intended:</p>

<pre><code>A a; // doesn't compile because the constructors are private
</code></pre>

<p>nor does</p>

<pre><code>std::unique&lt;A&gt; a(A::make_const()); // make creates pointers to const, so this doesn't compile.
</code></pre>

<p>Only the following compiles, and effectively you are mandating <code>const</code>:</p>

<pre><code>std::unique_ptr&lt;A const&gt; a(A::make());
</code></pre>

<p>One can make it better by using <code>std::indirect</code> <a href=""http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0201r1.pdf"" rel=""nofollow noreferrer"">http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0201r1.pdf</a> and in the future overloading <code>operator.</code> will also help.</p>

<p>Of course a much cheaper alternative is to give the name of the class have <code>const</code> in the name like <code>struct A_const{...</code> or <code>struct cA{...</code> to hint that only <code>const</code> makes sense. 
(Perhaps, If you decide to have mutating members later, you can inherit from this, <code>struct A : A_const{...</code>).</p>
",0
34957766,15531258,1,"<p>If your vector contains at least one element:</p>

<pre><code>std::equal(vecSamples.begin() + 1, vecSamples.end(), vecSamples.begin())
</code></pre>
",0
42466126,18041615,0,"<p>@JamesKanze</p>

<p>So something like this to exit the while loop?</p>

<pre><code>string str = ""foo"";
while (str == ""foo""){
    getline(cin, str);
}
str = ""foo"";
</code></pre>
",0
42495674,17504973,0,"<h2>Here is one additional way:</h2>
<p>Assuming <code>first</code> and <code>last</code> are iterators to container's <code>begin()</code> and <code>end()</code>, then:</p>
<pre><code>Iterator middle = first;
std::advance( middle, std::distance( first, last ) / 2 ); 
</code></pre>
",0
46046610,17280203,0,"<p>Try using ""long int"" instead of ""int"". </p>
",2
39251427,16626520,1,"<p>had the same issue. try to read the filestream binary:</p>

<pre><code>    czytaj.open(""test_file.txt"",ios::binary);
</code></pre>

<p>it helped for me</p>
",0
