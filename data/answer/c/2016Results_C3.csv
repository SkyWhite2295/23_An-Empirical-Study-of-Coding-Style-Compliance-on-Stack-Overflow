41195454,496448,19,"<p>Many years later, I discover this question. After reading every answer and comment, I thought I could clarify a few details... This could be useful for people who get here through Google search.</p>
<p>The question is specifically about using <code>extern</code> functions, so I will ignore the use of <code>extern</code> with global variables.</p>
<p>Let's define 3 function prototypes:</p>
<pre><code>// --------------------------------------
// Filename: &quot;my_project.H&quot;
extern int function_1(void);
static int function_2(void);
       int function_3(void);
</code></pre>
<p>The header file can be used by the main source code as follows:</p>
<pre><code>// --------------------------------------
// Filename: &quot;my_project.C&quot;
#include &quot;my_project.H&quot;

void main(void) {
    int v1 = function_1();
    int v2 = function_2();
    int v3 = function_3();
}

int function_2(void) return 1234;
</code></pre>
<p>In order to compile and link, we must define <code>function_2</code> in the same source code file where we call that function. The two other functions could be defined in different source code <code>*.C</code> or they may be located in any binary file (<code>*.OBJ</code>, <code>*.LIB</code>, <code>*.DLL</code>), for which we may not have the source code.</p>
<p>Let's include again the header <code>my_project.H</code> in a different <code>*.C</code> file to understand better the difference. In the same project, we add the following file:</p>
<pre><code>// --------------------------------------
// Filename: &quot;my_big_project_splitted.C&quot;
#include &quot;my_project.H&quot;

void old_main_test(void){
    int v1 = function_1();
    int v2 = function_2();
    int v3 = function_3();
}

int function_2(void) return 5678;

int function_1(void) return 12;

int function_3(void) return 34;
</code></pre>
<p>Important features to notice:</p>
<ul>
<li><p>When a function is defined as <code>static</code> in a header file, the compiler/linker must find an instance of a function with that name in each module which uses that include file.</p>
</li>
<li><p>A function which is part of the C library can be replaced in only one module by redefining a prototype with <code>static</code> only in that module. For example, replace any call to <code>malloc</code> and <code>free</code> to add memory leak detection feature.</p>
</li>
<li><p>The specifier <code>extern</code> is not really needed for functions. When <code>static</code> is not found, a function is always assumed to be <code>extern</code>.</p>
</li>
<li><p>However, <code>extern</code> is not the default for variables. Normally, any header file that defines variables to be visible across many modules needs to use <code>extern</code>. The only exception would be if a header file is guaranteed to be included from one and only one module.</p>
<p>Many project managers would then require that such variable be placed at the beginning of the module, not inside any header file. Some large projects, such as the video game emulator &quot;Mame&quot; even require that such variables appears only above the first function using them.</p>
</li>
</ul>
",2
47515419,47515228,4,"<p><code>res</code> will be no higher than <code>write</code>'s third argument, so all you have to do is constrain the 3rd argument of <code>write</code> to be no larger than the largest positive value that <code>res</code> (<code>ssize_t</code>) can store.</p>

<p>In other words, replace</p>

<pre><code>ssize_t res = write(fd, char_buf, size);
</code></pre>

<p>with</p>

<pre><code>size_t block_size = SSIZE_MAX;
if (block_size &gt; size)
   block_size = size;

ssize_t res = write(fd, char_buf, block_size);
</code></pre>

<p>You get:</p>

<pre><code>static void
write_buf_to_disk(int fd, void *buf, __u64 size) {
    const char* char_buf = buf;
    size_t block_size = SSIZE_MAX;
    while (size &gt; 0) {
        if (block_size &gt; size)
            block_size = size;

        ssize_t res = write(fd, char_buf, block_size);
        if (res == -1) {
            if (errno == EINTR)
                continue;

            err(EXIT_FAILURE, ""write"");
        }

        char_buf += res;
        size     -= res;
    }
}
</code></pre>
",13
47515755,47515228,1,"<p>The C11 standard says (7.19):</p>

<blockquote>
  <p>The types used for <code>size_t</code> and <code>ptrdiff_t</code> should not have an integer conversion rank
  greater than that of <code>signed long int</code> unless the implementation supports objects
  large enough to make this necessary.</p>
</blockquote>

<p>So <code>size_t</code> and <code>ssize_t</code> are unlikely to be 512 bits, unless you run on a 512-bit processor. </p>

<p>Right now you are extremely likely <strong>not</strong> to need more than 64 bits for any memory or disk size. That limits the amount of data you can have in a <code>write</code> statement.</p>
",0
47515326,47515228,2,"<p>In</p>

<pre><code>ssize_t res = write(fd, buf, size);
</code></pre>

<p>even if <code>ssize_t</code> would be 512 bits wide, as you suggested, the compiler promotes the result of <code>write</code> (64 bits) to that size. So the comparison would still work.</p>

<p>In</p>

<pre><code>written += res;
</code></pre>

<p>the compiler would give you a warning, but 64 bits to count the number of bytes written is really gigantic (~10<sup>19</sup> bytes max). So you're unlikely to miss any write even though the addition is from a 512 bits to a 64 bits.</p>

<p>You could also assign the size to a <code>ssize_t</code> at the beginning of the function</p>

<pre><code>write_buf_to_disk(int fd, void *buf, __u64 size64) { 
   ssize_t size = size64;
</code></pre>

<p>that would make the rest of the body in line with the system functions.</p>
",2
48032151,48032133,1,"<p>If you define a non-static global variable, it's still global. Even if it's not declared in a header file, it can still be declared in another <a href=""https://en.wikipedia.org/wiki/Translation_unit_(programming)"" rel=""nofollow noreferrer"">translation unit</a>.</p>
",2
48032595,48032133,1,"<p>When a variable is extern (the default), the object file generated by this compilation unit will carry a named reference to its location. Whenever another object file is linked with the first and refers to the same named variable but does not provide its own definition, the linker will replace all instances of its use of that variable with its location. The CPU deals with memory locations during execution not variable names. This is why it being omitted in the header does not matter; later when you link the object files created from your .c source files, only then are global references resolved.</p>

<p>Static (outside of functions) is useful in that a single library/program can have multiple globally accessible variables under the same name. This prevents name collisions between modules which may both use a variable name for different purposes but make sense in their own contexts to use a variable name which just happens to be the same. As long as the variable is only needed in the current compilation unit, then you should make it static.</p>
",1
48033257,48032133,1,"<blockquote>
  <p>What I don't get is the meaning of static. I know it limits the scope
  of a variable to the compilation unit, but isn't it enough not to
  declare a variable in the header file to hide it?</p>
</blockquote>

<p>That would not prevent the variable being declared and therefore becoming accessible. It is the difference between security and obscurity.  By declaring it <code>static</code> it cannot be accessed externally <em>by name</em>, by simply not declaring it in a header you are only preventing access to those who do not know its name and data type.  A more likely scenario is that your object code or library is used elsewhere and you get an accidental name clash - such bugs are often difficult to fathom.</p>

<hr>

<blockquote>
  <p>I assumed that the static variable and the not-static variable would
  behave differently. Specifically, <code>internal_static_variable</code> would
  <em>not</em> be shared by the files including it (one instance for <code>main.c</code> and one for <code>main2.c</code>), but since I change its value from <code>main.c</code> and
  I get the changed valued in <code>main2.c</code>, there seems not to be any
  difference between the two.</p>
</blockquote>

<p>Your code does <em>not</em> modify <code>internal_static_variable</code> in main.c; it modifies it <em>only</em> in ext.c.  ext.c happens to expose <code>internal_static_variable</code> through an accessor function, which in your example provides minimal protection, but as a single point of write access, provides a number of advantages over direct access to the variable, such as:</p>

<ul>
<li><p>It is possible to include code in the accessory to handle invalid input, by asserting, returning an error value, aborting, ignoring the value and <em>not</em> modifying the variable, or coercing to a valid value for example.  Such code might also be conditionally compiled so that it only performs checking in a debug build.</p></li>
<li><p>The accessor function provides a single point in the code to place a debugger breakpoint to trap all write accesses.</p></li>
</ul>
",4
48034138,48032133,4,"<h1>Scope and Linkage</h1>

<p>Identifiers have two properties that are relevant here: <strong>scope</strong> and <strong>linkage</strong>.</p>

<p><strong>Scope</strong> is where an identifier is visible. You apparently already know that scope is limited to the file an identifier is declared in, and it may be further limited to a block or a function (or a function prototype) depending on where the identifier is declared and the keywords (such as <code>static</code> or <code>extern</code>) used when declaring it.</p>

<p><strong>Linkage</strong> is a way of making different declarations of an identifier refer to the same object. There are three types of linkage: <strong>external</strong>, <strong>internal</strong>, and <strong>none</strong>.</p>

<p>If an identifier has <strong>internal</strong> linkage, it is not linked with identifiers in other translation units. An object called <code>foo</code> in one translation unit<sup>1</sup> cannot be accessed by name in another translation unit.<sup>2</sup></p>

<p>If an identifier has <strong>external</strong> linkage, it can be accessed in another translation unit by declaring an identifier with the same name and also with external linkage. When the program is linked together, identifiers with external linkage are resolved by the linker so that they refer to the same storage.</p>

<h1>Problems With External Linkage</h1>

<p>You can omit <code>static</code> and leave your identifiers with external linkage. As long as you are the only person writing your program, you can avoid problems. But this is not tidy; it leaves some things dangling, which can cause problems.</p>

<p>If you are writing routines to be used in other programs, leaving private identifiers with external linkage can be a problem, especially if they have simple, common names. A person who is using your routines in their own code might use the same name coincidentally, and then your two identifiers would be linked to the same object even though you need them to be different.</p>

<p>This can also occur intentionally. If you write a popular software package and leave private names with external linkage, some users of the package may explore what names are present and try to use them. This can result in people creating software which makes use of things in your software that were supposed to be private. Then you cannot develop new versions of the software that change the private parts without breaking existing software. That becomes a business problem. You may need to implement new algorithms inside the software package, but you do not want to break the existing source code of your customers. Declaring the names with <code>static</code> originally could avoid that.</p>

<h1>How Declarations Affect Linkage</h1>

<p>When an identifier is declared with <code>static</code> at file scope, it has internal linkage. Beyond that, the rules for which linkage an identifier has are a bit complicated, due in part to history of how the C language developed:</p>

<ul>
<li><p>Declaring an identifier with <code>extern</code> gives it external linkage if no prior declaration is visible.</p></li>
<li><p>If there is a visible prior declaration, <code>extern</code> leaves the identifier with the same linkage as in the previous declaration.</p></li>
<li><p>A declaration of a function or an object at file scope without <code>extern</code> or <code>static</code> gives the identifier external linkage.</p></li>
<li><p>A declaration of an object at block scope without <code>extern</code> has no linkage, even if <code>static</code> is used.</p></li>
<li><p>Function parameters have no linkage.</p></li>
<li><p>Identifiers of things that are not objects or functions (such as type definitions) have no linkage.</p></li>
</ul>

<p>Within one translation unit, each declaration of an identifier with internal linkage denotes the same object or function. Each declaration of an identifier with <strong>no linkage</strong> denotes a unique entity. (This paragraph is a direct quote from C 2011 [N1570] 6.2.2, and the other information in this answer comes from there too.)</p>

<h1>Footnotes</h1>

<p><sup>1</sup> A translation unit is the combined source code resulting from all <code>#include</code> directives. I use the technical term ¡°translation unit¡± rather than ¡°source file¡± because an object called <code>foo</code> in one source file could be accessed in another source file by using the <code>#include</code> directive.</p>

<p><sup>2</sup> An object with internal linkage can still be accessed in another translation unit by using a pointer, if you pass its address from one function to another.</p>
",0
48022027,48020778,3,"<p>As alk already commented, you need to declare the functions and global variables in the header file <code>static</code>.</p>

<p>The <code>static</code> keyword means the object (function or variable) has <em>internal linkage</em>; that it is only visible in the current compilation unit, and it will not be included in any symbol tables.</p>

<p>It is also a good idea to use include guards, so that if you have another header file that includes your header, and the C source file includes both your header file and that other header file, your header file only gets included once. (The lines with <code>FOOLIB_H</code> comprise the include guard in the below example.)</p>

<p>Consider the following trivial fixed-size stack example, <strong>foolib.h</strong>:</p>

<pre><code>#ifndef   FOOLIB_H
#define   FOOLIB_H

#include &lt;stdlib.h&gt;

#define   STACK_MAX  256

static size_t  stack_size = 0;
static double  stack_item[STACK_MAX];

static inline int  stack_push(const double  item)
{
    if (stack_size &lt; STACK_MAX) {
        stack_item[stack_size++] = item;
        return 0;
    } else
        return -1;
}

static inline double  stack_pop(const double  empty)
{
    if (stack_size &gt; 0)
        return stack_item[--stack_size];
    else
        return empty;
}

#endif /* FOOLIB_H */
</code></pre>

<p>Each compilation unit (each source file you compile separately) that includes the above (<code>#include ""foolib.h""</code>), gets their own local private stack they can use via <code>stack_push()</code> and <code>stack_pop()</code>.</p>

<p>The reason for marking the functions <code>static inline</code> rather than just <code>static</code> is that the former tells the compiler that it is okay to omit the function altogether, if it is not used. In particular, if you compile code with <code>gcc -Wall</code>, gcc warns if a <code>static</code> function is not used, but does not warn if a <code>static inline</code> function is not used. Other than that, there is not much practical difference.</p>
",0
34930219,3784263,7,"<p>In your question, you stated that you want to convert a user input of 175 to
<code>00000000 00000000 00000000 10101111</code>, which is <em>big endian</em> byte ordering, also known as <em>network byte order</em>.</p>
<p>A mostly portable way to convert your unsigned integer to a big endian unsigned char array, as you suggested from that &quot;175&quot; example you gave, would be to use C's <code>htonl()</code> function (defined in the header <code>&lt;arpa/inet.h&gt;</code> on Linux systems) to convert your unsigned int to big endian byte order, then use <code>memcpy()</code> (defined in the header <code>&lt;string.h&gt;</code> for C, <code>&lt;cstring&gt;</code> for C++) to copy the bytes into your char (or unsigned char) array.</p>
<p>The <a href=""http://linux.die.net/man/3/htonl"" rel=""nofollow noreferrer""><code>htonl()</code></a> function takes in an unsigned 32-bit integer as an argument (in contrast to <code>htons()</code>, which takes in an unsigned 16-bit integer) and converts it to network byte order from the host byte order (hence the acronym, Host TO Network Long, versus Host TO Network Short for <code>htons</code>), returning the result as an unsigned 32-bit integer. The purpose of this family of functions is to ensure that all network communications occur in big endian byte order, so that all machines can communicate with each other over a socket without byte order issues. (As an aside, for big-endian machines, the <code>htonl()</code>, <code>htons()</code>, <code>ntohl()</code> and <code>ntohs()</code> functions are generally compiled to just be a 'no op', because the bytes do not need to be flipped around before they are sent over or received from a socket since they're already in the proper byte order)</p>
<p>Here's the code:</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;string.h&gt;

int main() {
    unsigned int number = 175;

    unsigned int number2 = htonl(number);
    char numberStr[4];
    memcpy(numberStr, &amp;number2, 4);

    printf(&quot;%x %x %x %x\n&quot;, numberStr[0], numberStr[1], numberStr[2], numberStr[3]);

    return 0;
}
</code></pre>
<p>Note that, as caf said, you have to print the characters as <strong>unsigned</strong> characters using printf's <code>%x</code> format specifier.</p>
<p>The above code prints <code>0 0 0 af</code> on my machine (an x86_64 machine, which uses little endian byte ordering), which is hex for 175.</p>
",0
45662728,45662701,4,"<p>You probably want a function pointer (as a function doesn't really make sense in this context):</p>

<pre><code>int (*h)() = f;
</code></pre>
",0
45662760,45662701,1,"<p>No. Function declarations can't have an initializer.
If you want to ensure type compatibility, you can use a function <code>typedef</code>.</p>

<pre><code>typedef int f_tp(void);
f_tp f, h; //check f and h for compatibility with int (*)(void)
int f(){}  //?

//will get an error here because h was declared f_tp h == int h(void);
void h()
{
}
</code></pre>
",0
48044298,48044293,5,"<p>That's because you are trying to change to a string literal which are <em>non-modifiable</em>. That's why you get the error. It's <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behavior</a>.</p>
<ul>
<li><p>Either allocate dynamically allocated memory and pass pointer to it Or -</p>
</li>
<li><p>simply pass a char array which is not string literal.</p>
</li>
</ul>
<p><em>Make sure the passed string is big enough to hold the result.(along with <code>'\0'</code>)</em> It is not mandatory. You can have a char array without terminating <code>NUL</code> but then you can't use it in standard string function which expects <code>NUL</code> terminated char array.</p>
<p>Solution is to use something like</p>
<pre><code>char *result = malloc(10);
// check the return value of malloc.
// if result is not NULL pass it.
</code></pre>
<p>or</p>
<pre><code>char result[10];
</code></pre>
<p>Also don't forget to put the <code>'\0'</code> (For the reason stated above).</p>
<h3>Even if string literal was mutable..</h3>
<p>Well then also it would get you segmentation fault trying to access the array index out of bound.</p>
<p><code>char *str = &quot;&quot;</code> is basically pointing to a single element array which conatins <code>\0</code>  and that array is basically decayed into pointer to the first element of the array namely a <code>char</code> and being assigned to <code>str</code>. So you have only <code>1</code> element there and you <em>can't</em> put <code>3</code> characters with <code>\0</code> there.</p>
<p><sup><strong>Segmentation fault</strong> meaning you are accessing some memory which you shouldn't.</sup></p>
",0
48044305,48044293,4,"<p>In C, string literals shall not be modified. Any attempt to modify a string literal will result in undefined behavior. Instead of a string literal you can have an array of char of size <code>times</code>.  </p>

<p>Change   </p>

<pre><code>char *result = """";  
</code></pre>

<p>to </p>

<pre><code>char result[3];
</code></pre>
",0
45704933,45704896,2,"<p><code>conditional-expression</code>, <code>assignment-expression</code>, and <code>constant-expression</code> are nonterminals in the grammar. Their names should not be taken to imply that a <code>conditional-expression</code> has to actually involve a conditional operator, or that an <code>assignment-expression</code> has to involve an assignment; they are named for their positions in the precedence hierarchy.</p>

<p>In particular, <code>constant-expression</code> expands to <code>conditional-expression</code> because constant-ness is not a grammatical notion. It's not the grammar's job to exclude non-constants where a constant is required; that job is handled in other parts of a compiler. The grammar will allow any <code>conditional-expression</code> where a constant is required.</p>
",4
45709047,45704896,0,"<p>Chapter 6.5 is very poorly written and is hard to understand. The key is this:</p>

<p>C11 6.5/3</p>

<blockquote>
  <p>The grouping of operators and operands is indicated by the syntax.</p>
</blockquote>

<p>Meaning that operator precedence is actually not specified explicitly anywhere in the standard! Instead we are supposed to look at the syntax for each operator and figure it out. </p>

<p>All operators build a chain of operator precedence, so for each sub chapter of 6.5, the previous group of operators is mentioned just to indicate that it has higher precedence.</p>

<p>Starting from the top we have <code>primary-expression</code> (6.5.1) with the highest precedence. In the next group, postfix operators, the previous group will be mentioned to show that it has higher precedence:</p>

<pre><code>postfix-expression:
  primary-expression
  postfix-expression [ expression ]
  ...
</code></pre>

<p>This doesn't mean that primary expression is a postfix expression, but rather that the syntax for a postfix expression is <code>primary-expression postfix-expression ...</code></p>

<p>It goes on like this throughout the whole chapter 6.5. It might sound royally stupid and that's just because it <em>is</em> royally stupid.</p>

<p>Note 85) tries to provide a bit of help:</p>

<blockquote>
  <p>The syntax specifies the precedence of operators in the evaluation of an expression, which is the same
  as the order of the major subclauses of this subclause, highest precedence first.</p>
</blockquote>
",1
42616248,42616232,7,"<p><code>next</code> is a <code>struct node *</code>, which is just a pointer, not a <code>struct node</code>, so there's no actual circular definition. The details of a struct aren't required to figure out how to make a pointer to it.</p>

<p>To address your addenda:</p>

<ol>
<li>Although that's more or less accurate and will probably work, it's not guaranteed by the standard, and you shouldn't do it.</li>
<li>Again, <code>struct node</code> and <code>struct node *</code> are entirely different types. A <code>struct node *</code> doesn't contain any other objects.</li>
</ol>
",0
42625503,42616232,1,"<p>Let me answer your questions in order:</p>

<blockquote>
  <p>But how does C compiler resolve the circular definition issue?</p>
</blockquote>

<p><code>struct node *next;</code> is not a circular definition, <code>struct node</code> is an incomplete type, <code>next</code> is defined as a member with type <code>struct node *</code>, which is just a pointer.</p>

<blockquote>
  <p>Or does that issue really exist?</p>
</blockquote>

<p>No, not really an issue. As a matter of fact, you could have members defined as pointers to any undefined structure.</p>

<blockquote>
  <p>Or, on a 32-bit machine, can I somewhat treat <code>struct node *next</code> member just as a member of 32-bit unsigned integer type?</p>
</blockquote>

<p>You should not make any assumptions on the actual size, offset or alignment of structure members. A <em>32-bit machine</em> could have pointers sizes that are not 32 bits, it does not matter as long as you use them as pointers, not integers.</p>

<blockquote>
  <p>The reason I think of circular definition is, when compiler encounters something like <code>next-&gt;data</code> or <code>next-&gt;next</code>, it has to know the exact offset of each member to add to the <code>next</code> pointer to get the correct location of each member.</p>
</blockquote>

<p>That's correct, but by the time the compiler parses such code, the structure definition is complete and it can determine the offset of the <code>data</code> and <code>next</code> members.</p>

<blockquote>
  <p>And how does the compiler calculate the <code>sizeof(struct node)</code>?</p>
</blockquote>

<p>After parsing the structure definition, the compiler has all the information needed to compute the size of structure instances. For such a computation, all pointers to structures and/or unions are assumed to have the same size.</p>

<blockquote>
  <p>Well, I think the critical concept to understand this seemingly circular issue is, a pointer's size is not relevant to what type it points to. And the size is fixed on a specific machine. A pointer's type is only meaningful at compile-time for the compiler to generate instructions for pointer calculation.</p>
</blockquote>

<p>A pointer size <strong>is</strong> relevant to the type it points to, and on some architectures, different pointer types may have different sizes. Yet the C Standard specifies some constraints:</p>

<ul>
<li>All pointer types can be converted to <code>void *</code> and back.</li>
<li>Pointers to all structures and unions have the same size.</li>
</ul>

<p>On most modern architectures, and specifically on Posix compliant systems, all standard pointers types have the same size.</p>
",3
37293046,11075850,-1,"<p>I've had this question quite a few times and from what I've found my favorite solution is to just iterate through the pointer until <code>null</code>.  <code>sizeof</code> stops working as soon as you start using functions and passing the arrays around.  </p>

<p>Here's a paradigm I've used time and time again in my assignments and it's been really helpful.  The exact same thing can be used for getting the length of a <code>cstring</code> or iterating through its characters.</p>

<pre><code>char* argv_custom[] = {""--debug"", ""--verbose"", ""--test"", ""--ultimate""};
char **temp = argv_custom;
int size = 0;
while (*temp) {
    ++size;
    ++temp;
}
</code></pre>

<p>This is not preferred over using <code>sizeof</code>, however it's an alternative when you want to loop through it.</p>
",0
35244655,2425167,2,"<p>In addition to return an exit code to parent process - </p>

<p>In UNIX, an important aspect that I think has been left out is, that exit() at first calls (in reverse order) all those functions, which were registered by atexit() call.</p>

<p>Please refer to SUSv4 for details.</p>
",0
45704894,45704799,1,"<p>This statement is best illustrated with a simple example:</p>

<pre><code>static struct {
    int id;
    int count;
} items[20];

int *midCount = &amp;items[10].count;
</code></pre>

<p>Above, <code>midCount</code> is an address constant pointing to <code>count</code> field of <code>items</code> struct at index ten. The address-of operator is applied to the result of member access and array subscript operators in order to obtain the address. However, <code>int</code> object at the said address is <em>not</em> accessed, in accordance with the specification.</p>

<p>Here is an expression that accesses the object at the same location as the address-of expression above:</p>

<pre><code>int count = items[10].count;
</code></pre>

<blockquote>
  <p>Why shouldn't the value of an object accessed by using those operators?</p>
</blockquote>

<p>Because it is not required to compute the address constant. The compiler can compute the offset of <code>count</code> inside <code>items</code> array, and apply this offset during the loading, when <code>items</code> is bound to memory, without reading or writing the location itself. This is similar to the behavior of <code>sizeof</code> operator, which does not evaluate its expressions:</p>

<pre><code>size_t sz = sizeof(items[10].count); // No memory access
</code></pre>
",0
45704905,45704799,1,"<p>I think the restriction on accessing the value is not during runtime but during translation. One is not allowed to dereference a constant expression pointer in a constant expression.</p>

<p>For instance</p>

<pre><code>// global scope
int a = 0;
int *b = (a++ , &amp;a);
</code></pre>

<p>We do not want the compiler to keep track of the state of <code>a</code> while building the initial value of <code>b</code>.</p>

<p>Also the actual value at that address might not be known to the compiler because it might be defined in another translation unit with some constant initializer.</p>
",1
45705165,45704799,2,"<p>It is saying that an expression forming an address constant is not allowed to depend on the value of an object.</p>

<p>This is analogous to a simpler case:</p>

<pre><code>// at file scope
int x = 10;        // OK, 10 is an integer constant expression
int y = x;         // Error, x is the value of an object
</code></pre>

<p>For the address constant case, it is reminding us that the computation of the address constant should not read the value of an object in forming that computation, e.g.:</p>

<pre><code>int a[5];                // OK
int *p = &amp;a[1];          // OK
int *q = &amp;a[1] + a[0];   // Error, uses value of a[0]
</code></pre>
",3
46626989,2114377,3,"<p>You can use snprintf to get a substring of a char array with precision. Here is a file example called ""substring.c"":</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    const char source[] = ""This is a string array"";
    char dest[17];

    // get first 16 characters using precision
    snprintf(dest, sizeof(dest), ""%.16s"", source);

    // print substring
    puts(dest);
} // end main
</code></pre>

<p>Output:</p>

<blockquote>
  <p>This is a string</p>
</blockquote>

<p>Note:</p>

<p>For further information see printf man page.</p>
",1
42475866,2114377,0,"<p>I think it's easy way... but I don't know how I can pass the result variable directly then I create a local char array as temp and return it.</p>

<pre><code>char* substr(char *buff, uint8_t start,uint8_t len, char* substr)
{
    strncpy(substr, buff+start, len);
    substr[len] = 0;
    return substr;
}
</code></pre>
",0
45681455,45681431,4,"<p>No, it means that if you assign an instance of a <code>struct</code> like the one in your example to another <code>struct</code> you are effectively assigning arrays.</p>

<pre><code>struct Array {
    int array[3];
};

struct Array A;
struct Array B = {{0, 1, 2}}; // by Chris Dodd
// This is valid!
A = B;
</code></pre>
",6
42519728,1437241,-1,"<p>hi i think it's becoz in a stream -1 is not one but two characters and the ascii for neither of them is -1 or whatever is used for EOF</p>
",0
44349197,44349162,1,"<p>Your error comes from not including the pthread library (assuming you are compiling this for a posix compliant system, if you are on windows pthreads are unlikely to work). </p>

<p>See were the pthread library is installed in your machine and include it in the command line.</p>
",13
44349197,44349162,1,"<p>Your error comes from not including the pthread library (assuming you are compiling this for a posix compliant system, if you are on windows pthreads are unlikely to work). </p>

<p>See were the pthread library is installed in your machine and include it in the command line.</p>
",13
38404174,2346754,0,"<p>If you're using Linux, use gdb</p>

<p>$<code>gdb a.out</code></p>

<p>(gdb) <code>list</code></p>
",1
47989091,5693274,0,"<p>Here is a slightly modified example, compiled with gcc 7.2.1 on x86-64:</p>

<pre><code>#include &lt;string.h&gt;
static int temp;
extern volatile int hardware_reg;
int foo (int x)
{
    hardware_reg = 0;
    memcpy(&amp;temp, &amp;x, sizeof(int));
    hardware_reg = 1;
    return temp;
}
</code></pre>

<p>gcc knows that the <code>memcpy()</code> is the same as an assignment, and knows that <code>temp</code> is not accessed anywhere else, so <code>temp</code> and the <code>memcpy()</code> disappear completely from the generated code:</p>

<pre><code>foo:
    movl    $0, hardware_reg(%rip)
    movl    %edi, %eax
    movl    $1, hardware_reg(%rip)
    ret
</code></pre>
",0
47516608,12733105,1,"<p>Here is my function </p>

<pre><code>char *fileName = ""input-1.txt"";
countOfLinesFromFile(fileName);

void countOfLinesFromFile(char *filename){
FILE* myfile = fopen(filename, ""r"");
int ch, number_of_lines = 0;
do
{
    ch = fgetc(myfile);
    if(ch == '\n')
        number_of_lines++;
}
while (ch != EOF);
if(ch != '\n' &amp;&amp; number_of_lines != 0)
    number_of_lines++;
fclose(myfile);
printf(""number of lines in  %s   = %d"",filename, number_of_lines);
</code></pre>

<p>}</p>
",0
34967955,4885143,1,"<p>Most likely the '?' is the ternary operator. Its grammar is:</p>

<pre><code>RESULT = (COND) ? (STATEMEN IF TRUE) : (STATEMENT IF FALSE)
</code></pre>

<p>It is a nice shorthand for the typical if-else statement:</p>

<pre><code>if (COND) {
    RESULT = (STATEMENT IF TRUE);
} else {
    RESULT = (STATEMENT IF FALSE);
</code></pre>

<p>as it can usually fit on one line and can improve readability.</p>

<p>Some answers here refer to a trigraph, which is relevant to the C preprocessor. Take a look at this really dumb program, <code>trigraphs.c</code>:</p>

<pre><code># /* preprocessor will remove single hash symbols and this comment */
int main()
{
    char *t = ""??="";
    char *p = ""??/"""";
    char *s = ""??'"";
    ??(, ??), ??! ??&lt;, ??&gt;, ??-
    return 0;
}
</code></pre>

<p>invoking only the c preprocessor by running <code>gcc -E -trigraphs trigraph.c</code> the output is</p>

<pre><code>int main()
{
 char *t = ""#""
 char *p = ""\"""";
 char *s = ""^"";
 [, ], | {, }, ~
 return 0;
}
</code></pre>

<p>Hopefully that clarifies a little bit what a trigraphs are, and what a '?' ""means"" in C.</p>
",0
42564670,2396623,0,"<p>A bit more complete version:</p>

<pre><code>char* end = line + strlen(line) - 1 ;          // end of line                                                                                                      
while( (end &gt; line) &amp;&amp; isspace(*end) ) end--;  // right trim space                                                                                              
*(end+1) = '\0';                               // terminate string
</code></pre>

<p>(Note: Putting a null char into it makes string readers stop reading at that point but the memory footprint of line is the same. The characters to the right of the '\0' <em>are still there</em>.    </p>
",0
45680398,4023643,4,"<p>use <code>fflush(stdin);</code> function before the second <code>scanf();</code>. It will flush the ENTER key generated after first scanf();.
Actually, your second scanf() is taking the ENTER as its input and since scanf terminates after getting an ENTER, it is not taking anything else by your side.</p>
",0
38857590,4392665,1,"<p>This is my solution for <code>atof</code> function.</p>

<pre><code>#include&lt;stdio.h&gt;
float my_a2f(char *);

main() {
  char ch[20];
  float i;
  printf(""\n enter the number as a string\n"");
  scanf(""%[^\n]"", ch);
  i = my_a2f(ch);
  printf("" string =%s , float =%g \n"", ch, i);
}

float my_a2f(char *p) {
  // here i took another two   variables for counting the number of digits in mantissa
  int i, num = 0, num2 = 0, pnt_seen = 0, x = 0, y = 1; 
  float f1, f2, f3;
  for (i = 0; p[i]; i++)
    if (p[i] == '.') {
      pnt_seen = i;
      break;
    }
  for (i = 0; p[i]; i++) {
    if (i &lt; pnt_seen) num = num * 10 + (p[i] - 48);
    else if (i == pnt_seen) continue;
    else {
      num2 = num2 * 10 + (p[i] - 48);
      ++x;
    }
  }
  // it takes 10 if it has 1 digit ,100 if it has 2 digits in mantissa
  for (i = 1; i &lt;= x; i++) 
    y = y * 10;
  f2 = num2 / (float) y;
  f3 = num + f2;
  return f3;
}
</code></pre>
",3
44699843,3305735,0,"<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

int main(void)
{
 int c, flag=0;

   while((c=getchar()) != EOF){

      if(c == ' '){
         if(flag == 0){
            flag=1;
            putchar(c);
        }
    }else{
        flag=0;
        putchar(c);
     }

   }

  return 0;

}
</code></pre>

<p>I hope this will help.</p>
",0
43960585,3305735,0,"<p>This is a solution using only the techniques described so far in <a href=""http://alvand.basu.ac.ir/%7Edezfoulian/files/Programming/Prentice%20Hall%20-%20The%20C%20Programming%20Language-%20Brian%20W.%20Kernighan,%20Dennis%20M.%20Ritchie,%202nd%20ed.,%20ISBN%20.pdf"" rel=""nofollow noreferrer"">K&amp;R's C</a>. In addition to using a variable to achieve a <a href=""https://youtu.be/hJIST1cEf6A"" rel=""nofollow noreferrer"">finite state change</a> for distinguishing the first blank space from successive blank spaces, I've also added a variable to count blank spaces along with a print statement to verify the total number. This helped me to wrap my head around <code>getchar()</code> and <code>putchar()</code> a little better - as well as the scope of the while loop within main().</p>

<pre><code>// Exercise 1-9. Write a program to copy its input to its output, replacing
//               each string of one or more blanks by a single blank.

#include &lt;stdio.h&gt;

int main(void)
{
    int blank_state;
    int c;
    int blank_count;

    printf(""Replace one or more blanks with a single blank.\n"");
    printf(""Use ctrl+d to insert an EOF after typing ENTER.\n\n"");

    blank_state = 0;
    blank_count = 0;
    while ( (c = getchar()) != EOF )
    {
        if (c == ' ')
        {
            ++blank_count;
            if (blank_state == 0)
            {
                blank_state = 1;
                putchar(c);
            }
        }
        if (c != ' ')
        {
            blank_state = 0;
            putchar(c);
        }
    }

    printf(""Total number of blanks: %d\n"", blank_count);

    return 0;
}
</code></pre>
",0
36735671,3305735,1,"<p>First declare two variables character and last_character as integers.when you have not reach the end of the file( while(character=getchar() != EOF ) do this;
1. If character != ' ' then
      print character
      last_character = character
2. If character == ' '
     if last_character ==' '
     last character = character
   else print character </p>
",0
40542254,2871160,-1,"<p>Begin with solving basic level logical questions, and while solving always follow the best approach and best practices.</p>

<p>You can refer and try solving these fundamental question : <a href=""http://tutorialsschool.com/c-programming/c-programs/index.php"" rel=""nofollow noreferrer"">C programs</a></p>

<p>Also try solving questions of : <a href=""https://projecteuler.net/"" rel=""nofollow noreferrer"">Project Eulers </a></p>
",0
44232205,3520461,-1,"<p>State transtion code can be utilize either by array or switch case. Written under if else directive.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int entry_state(void);
int foo_state(void);
int bar_state(void);
int exit_state(void);

enum state_codes lookup_transitions(enum state_codes, enum ret_codes);

/* array and enum below must be in sync! */
int (* state[])(void) = { entry_state, foo_state, bar_state, exit_state};
enum state_codes { entry, foo, bar, end};

enum ret_codes { ok, fail, repeat};
struct transition {
    enum state_codes src_state;
    enum ret_codes   ret_code;
    enum state_codes dst_state;
};
/* transitions from end state aren't needed */
struct transition state_transitions[] = {
    {entry, ok,     foo},
    {entry, fail,   end},
    {foo,   ok,     bar},
    {foo,   fail,   end},
    {foo,   repeat, foo},
    {bar,   ok,     end},
    {bar,   fail,   end},
    {bar,   repeat, foo}};

int main(int argc, char *argv[]) {
    enum state_codes cur_state = entry;
    enum ret_codes rc;
    int (* state_fun)(void);

    for (;;) {
        state_fun = state[cur_state];
        rc = state_fun();
        if (end == cur_state)
            break;
        cur_state = lookup_transitions(cur_state, rc);
    }

    return EXIT_SUCCESS;
}

/*
 * lookup_transition() function has time complexity of class O(n).
 * We can optimize it.
 * */
enum state_codes
lookup_transitions(enum state_codes cur_state, enum ret_codes rc)
{
#if 0
    switch (cur_state) {
        case entry:
            cur_state = ((rc == ok) ? (foo) : (end));
            break;
        case foo:
            cur_state = ((rc == ok) ? (bar) : ((rc == fail) ? (end) : (foo)));
            break;
        default:
            cur_state = ((rc == ok) ? (end) : ((rc == fail) ? (end) : (foo)));
            break;
    }

    return cur_state;
#else
    char arr_size = (sizeof(state_transitions) / sizeof(state_transitions[0])); /* This can be shifted to main function to avoid redundant job. */
    char count;

    for (count = 0; count &lt; arr_size; count++) {
        if ((state_transitions[count].src_state == cur_state) &amp;&amp; (state_transitions[count].ret_code == rc)) {
            return (state_transitions[count].dst_state);
        }
    }
#endif
}

int entry_state(void)
{
    int st;
    enum ret_codes rc;

    printf(""YOU ARE IN ENTRY STATE.\nEnter 0/1: "");

    scanf(""%d"", &amp;st);

    rc = ((st == 1) ? (fail) : (ok));
    return rc;
}

int foo_state(void)
{
    int st;
    enum ret_codes rc;

    printf(""YOU ARE IN FOO STATE.\nEnter 0/1/2: "");

    scanf(""%d"", &amp;st);

    rc = ((st == 0) ? (ok) : ((st == 2) ? (repeat) : (fail)));
    return rc;
}

int bar_state(void)
{
    int st;
    enum ret_codes rc;

    printf(""YOU ARE IN BAR STATE.\nEnter 0/1/2: "");

    scanf(""%d"", &amp;st);

    rc = ((st == 0) ? (ok) : ((st == 2) ? (repeat) : (fail)));
    return rc;
}

int exit_state(void)
{
    printf(""YOU ARE IN EXIT STATE.\n"");

    exit(EXIT_SUCCESS);
}
</code></pre>
",4
42549038,7634337,-1,"<p>There is one more way: by passing size of array along with name of array.</p>

<pre><code>int third(int[], int ); 

main() {
   int size, i;
   scanf(""%d"", &amp;size);
   int a[size];
   printf(""\nArray elemts"");
   for(i = 0; i &lt; size; i++)
       scanf(""%d"",&amp;a[i]);
   third(a,size);
}
int third(int array[], int size) {
    /* Array elements can be accessed inside without using pointers */
} 
</code></pre>
",0
46042467,4210689,6,"<h3><code>qsort_r()</code> and <code>qsort_s()</code></h3>

<p>There are functions called <code>qsort_r()</code> or <code>qsort_s()</code> available in some implementations that do what you want ¡ª take a pointer to extra data that is passed to the comparator functions.</p>

<p>The BSD variant implementations (including macOS or Mac OS X) provide a version of <code>qsort_r()</code>, and so does the GNU C library.  Unfortunately, the two variants have different signatures.  That doesn't stop them being useful, but it does mean that the same source code cannot be used on the two platforms, and further that you have to make sure you understand which variant of <code>qsort_r()</code> is available on any machine where you try to use it.</p>

<p>Similarly, Microsoft provides a version of <code>qsort_s()</code> and the C11 standard defines a version of <code>qsort_s()</code> (as an optional function in Annex K, based on TR-24731), but the two differ in the signature again.  Maybe it is fortunate that the Annex K functions are not widely implemented.</p>

<h3>BSD <code>qsort_r()</code></h3>

<pre><code>void qsort_r(void *base, size_t nel, size_t width, void *thunk,
             int (*compar)(void *, const void *, const void *));
</code></pre>

<h3>GNU C library <code>qsort_r()</code></h3>

<pre><code>void qsort_r(void *base, size_t nmemb, size_t size,
             int (*compar)(const void *, const void *, void *),
             void *arg);
</code></pre>

<p>Note that in BSD, the 'thunk' is equivalent to 'arg' in GNU, but these arguments appear in different places in the calling sequence to the <code>qsort_r()</code> function (before and after the comparator function pointer).  Further, note that the 'thunk' is passed as argument 1 to the BSD comparator functions, but the 'arg' is passed as argument 3 to the GNU comparator functions.</p>

<p>Mnemonic for <code>qsort_r</code>: the context data is specified in relation to the comparator in the calling sequence in the same relation as the context is passed to the comparators in relation to the two values being compared. Context before pointer to comparator means context before values in call to comparator; context after pointer to comparator means context after values in call to comparator.</p>

<h3>Annex K <code>qsort_s()</code></h3>

<pre><code>errno_t qsort_s(void *base, rsize_t nmemb, rsize_t size,
               int (*compar)(const void *x, const void *y, void *context),
               void *context);
</code></pre>

<p>The Annex K <code>qsort_s()</code> is unique in returning a value; all the other variants do not return any value.  Otherwise, for most practical purposes, it matches the GNU <code>qsort_r()</code> function.</p>

<h3>Microsoft <a href=""https://msdn.microsoft.com/en-us/library/4xc60xas.aspx"" rel=""noreferrer""><code>qsort_s()</code></a></h3>

<pre><code>void qsort_s(void *base, size_t num, size_t width,
             int (__cdecl *compare )(void *, const void *, const void *),
             void * context);
</code></pre>

<p>The <code>rsize_t</code> and <code>size_t</code> distinction is not very important when comparing the Annex K and Microsoft variants of <code>qsort_s()</code>, but in the Annex K <code>qsort_s()</code>, the context is passed as argument 3 to the comparator, but in the Microsoft <code>qsort_s()</code>, the context is passed as argument 1 to the comparator.</p>

<h2>Summary</h2>

<p>Functions called <code>qsort_r()</code> or <code>qsort_s()</code> provide the required functionality.  However, you must check the platform specification for which function is present, and for the correct calling sequence for the arguments to the sorting function, <em>and</em> the correct calling sequence for the arguments to the comparators.</p>

<p>Nominally, you should check for the return type of the function too, but few programs would consider checking it, mainly because most variants of <code>qsort()</code> return no value.</p>
",0
34967670,9521140,1,"<p>According to <em>ISO-9899</em> the result of relation, logical and equality operators has type <code>int</code>. <code>true</code> and <code>false</code> from <code>stdbool.h</code> are also integers. If you want to spare memory - use bit-fields.</p>
",0
45288985,5242524,1,"<p>Similar implementation to Ahmad Sirojuddin but slightly different semantics. From a security perspective, any time a function writes into a string buffer, the function should really ""know"" the size of the buffer and refuse to write past the end of it. I would guess its a part of the reason you can't find itoa anymore.</p>

<p>Also, the following implementation avoids performing the module/devide operation twice.</p>

<pre><code>char *u32todec( uint32_t    value,
                char        *buf,
                int         size)
{
    if(size &gt; 1){
        int i=size-1, offset, bytes;
        buf[i--]='\0';
        do{
            buf[i--]=(value % 10)+'0';
            value = value/10;
        }while((value &gt; 0) &amp;&amp; (i&gt;=0));
        offset=i+1;
        if(offset &gt; 0){
            bytes=size-i-1;
            for(i=0;i&lt;bytes;i++)
                buf[i]=buf[i+offset];
        }
        return buf;
    }else
        return NULL;
}
</code></pre>

<p>The following code both tests the above code and demonstrates its correctness:</p>

<pre><code>int main(void)
{
    uint64_t acc;
    uint32_t inc;
    char buf[16];
    size_t bufsize;
    for(acc=0, inc=7; acc&lt;0x100000000; acc+=inc){
        printf(""%u: "", (uint32_t)acc);
        for(bufsize=17; bufsize&gt;0; bufsize/=2){
            if(NULL != u32todec((uint32_t)acc, buf, bufsize))
                printf(""%s "", buf);
        }
        printf(""\n"");
        if(acc/inc &gt; 9)
            inc*=7;
    }
    return 0;
}
</code></pre>
",0
37766262,4869507,1,"<p>Good job I remembered about DOS Batch files.
Don't need Getchar() at all.
Just write the batch file to change directory (cd) to the folder where the program resides.
type the name of the exe program and on the next line type pause.
example:</p>

<pre><code>cd\
</code></pre>

<p>wallpaper_calculator.exe
pause</p>
",0
45759368,45759181,4,"<p>There are comments that help a person identify how the preprocessor expanded the various #include &lt;...> macros and other items.</p>

<p>Reading these lines provides the equivalent of reading the logging messages of the preprocessor as it encounters the macros and expands them.</p>

<pre><code># 1 ""sample.c""
</code></pre>

<p>Start on line one of the input ""sample.c""</p>

<pre><code># 1 ""&lt;built-in&gt;""
</code></pre>

<p>Process the built-in c pre-procssor directive (must be an implementation detail), but is presented as a fake ""file"".</p>

<pre><code># 1 ""&lt;command-line&gt;""
</code></pre>

<p>Process the command line directive (again implementation detail), presented as a fake ""file"".</p>

<pre><code># 1 ""/usr/include/stdc-predef.h"" 1 3 4
</code></pre>

<p>Include (at line 1) the stdc-predef.h file, it's the start of the file, suppress warnings permitted for system header files, assure that the symbols are treated like C symbols.</p>

<pre><code># 1 ""&lt;command-line&gt;"" 2
</code></pre>

<p>Return from the command line ""fake"" file.</p>

<pre><code># 1 ""sample.c""
</code></pre>

<p>Back in sample.c.</p>

<pre><code># 1 ""/usr/include/stdio.h"" 1 3 4
</code></pre>

<p>Now starting with file ""stdio.h"", suppress permitted system warnings, treat symbols in the file a C symbols.</p>

<pre><code># 27 ""/usr/include/stdio.h"" 3 4
</code></pre>

<p>And so on...</p>

<p><a href=""https://gcc.gnu.org/onlinedocs/cpp/Preprocessor-Output.html"" rel=""nofollow noreferrer"">The documentation is here.</a></p>
",2
42633943,42633921,1,"<p>Pass a pointer to a pointer:</p>

<pre><code>void somefunc(char **pcountry) {
  *pcountry = ""GERMANY"";
}
</code></pre>

<p>and call it</p>

<pre><code>somefunc(&amp;country);
</code></pre>
",8
40766065,5109512,1,"<p>Use <code>getchar()</code> or <code>sscanf()</code> whichever comforts more.</p>

<p>Like</p>

<pre><code>char ch;

ch = getchar();
</code></pre>

<p>This is simple. also if you want to use <code>scanf(""%c"",&amp;ch);</code> then,
just remove the <code>\n</code> from your previous <code>printf()</code> statement.</p>
",0
36306382,7590254,2,"<p>I have seen xmalloc while working on IBM AIX.
xmalloc is a kernel service provided by AIX.</p>
<p>Nothing can explain a function better than the function's man page in my opinion. So I am pasting the below details from the man page</p>
<blockquote>
<p>Purpose: Allocates memory.</p>
<p>Syntax:</p>
<p>caddr_t xmalloc ( size,  align,  heap)</p>
<p>Parameters:</p>
<p>size:     Specifies the number of bytes to allocate.</p>
<p>align:    Specifies the alignment characteristics for the allocated
memory.</p>
<p>heap :    Specifies the address of the heap from which the memory is to
be           allocated.</p>
<p>Description:</p>
<p>The xmalloc kernel service allocates an area of memory out of the heap
specified by the heap parameter. This area is the number of bytes in
length specified by the size parameter and is aligned on the byte
boundary specified by the align parameter. The align parameter is
actually the log base 2 of the desired address boundary. For example,
an align value of 4 requests that the allocated area be aligned on a
2^4 (16) byte boundary.</p>
<p>There are multiple heaps provided by the kernel for use by kernel
extensions. Two primary kernel heaps are kernel_heap and pinned_heap.
Kernel extensions should use the kernel_heap value when allocating
memory that is not pinned, and should use the pinned_heap value when
allocating memory that should always be pinned or pinned for long
periods of time. When allocating from the pinned_heap heap, the
xmalloc kernel service will pin the memory before a successful return.
The pin and unpin kernel services should be used to pin and unpin
memory from the kernel_heap heap when the memory should only be pinned
for a limited amount of time. Memory from the kernel_heap heap must be
unpinned before freeing it. Memory from the pinned_heap heap should
not be unpinned.</p>
</blockquote>
<p>If one is interested in knowing more about this function can visit the following link:
<a href=""http://www.ibm.com/support/knowledgecenter/ssw_aix_61/com.ibm.aix.ktechrf1/xmalloc.htm"" rel=""nofollow noreferrer"">IBM AIX Support</a></p>
",0
36302867,36302746,7,"<p>You can do it with the macro concatenation operator and function-like macros:</p>

<pre><code>#define NAMESPACE(name) project_name_ ## name

void NAMESPACE(func_name)(void)
{
    ...
}
</code></pre>
",0
36302883,36302746,2,"<p>You can do that with the macro <a href=""https://gcc.gnu.org/onlinedocs/cpp/Concatenation.html"" rel=""nofollow"">concatenation</a></p>

<pre><code>#define NAMESPACE(function) project_name ## function

void NAMESPACE(func_name)()
{
}
</code></pre>
",0
37758147,5695992,0,"<p>The version below works for me. I'm not sure if it is bad design though:</p>

<pre><code>while(source[i] != '\0' &amp;&amp; (i&lt;= (MAXLINE-1)))
{
dest[i]=source[i];
++i;
}
</code></pre>
",0
41943143,7180293,-2,"<p>@Nikolay Khilyuk offers the best solution except. </p>

<p>1) Go back to using char *, there is absolutely no good reason for using const.</p>

<p>2) This code is not portable and is likely to fail on none POSIX systems where the / is not the file system delimiter depending on the compiler implementation. For some windows compilers you might want to test for '\' instead of '/'. You might even test for the system and set the delimiter based on the results.</p>

<p>The function name is long but descriptive, no problem there. There is no way to ever be sure that a function will return a filename, you can only be sure that it can if the function is coded correctly, which you achieved. Though if someone uses it on a string that is not a path obviously it will fail. I would have probably named it basename, as it would convey to many programmers what its purpose was. That is just my preference though based on my bias your name is fine. As far as the length of the string this function will handle and why anyone thought that would be a point? You will unlikely deal with a path name longer than what this function can handle on an ANSI C compiler. As size_t is defined as a unsigned long int which has a range of 0 to 4,294,967,295.</p>

<p>I proofed your function with the following.</p>

<pre><code>    #include &lt;stdio.h&gt;
    #include &lt;string.h&gt;

    char* getFileNameFromPath(char* path);

    int main(int argc, char *argv[])
    {
        char *fn;

        fn = getFileNameFromPath(argv[0]);
        printf(""%s\n"", fn);
        return 0;
    }

    char* getFileNameFromPath(char* path)
    {
       for(size_t i = strlen(path) - 1; i; i--)  
       {
            if (path[i] == '/')
            {
                return &amp;path[i+1];
            }
        }
        return path;
    }
</code></pre>

<p>Worked great, though Daniel Kamil Kozar did find a 1 off error that I corrected above. The error would only show with a malformed absolute path but still the function should be able to handle bogus input. Do not listen to everyone that critiques you. Some people just like to have an opinion, even when it is not worth anything.</p>

<p>I do not like the strstr() solution as it will fail if filename is the same as a directory name in the path and yes that can and does happen especially on a POSIX system where executable files often do not have an extension, at least the first time which will mean you have to do multiple tests and searching the delimiter with strstr() is even more cumbersome as there is no way of knowing how many delimiters there might be. If you are wondering why a person would want the basename of an executable think busybox, egrep, fgrep etc...</p>

<p><s>strrchar() would be cumbersome to implement as it searches for characters not strings so I do not find it nearly as viable or succinct as this solution.</s> I stand corrected by Rad Lexus this would not be as cumbersome as I thought as strrchar() has the side effect of returning the index of the string beyond the character found.   </p>

<p>Take Care</p>
",16
43934602,8713470,-2,"<p>There are portable ways of specifying functions that can be executed ""after"" main is executed. </p>

<ol>
<li><p><a href=""http://en.cppreference.com/w/c/program/atexit"" rel=""nofollow noreferrer""><code>atexit()</code></a></p></li>
<li><p><a href=""http://en.cppreference.com/w/c/program/at_quick_exit"" rel=""nofollow noreferrer""><code>at_quick_exit()</code></a></p></li>
</ol>

<p>Further, follow <a href=""http://en.cppreference.com/w/cpp/language/initialization"" rel=""nofollow noreferrer"">this</a> link and about various types of initialization in C++ - that may be useful for you to execute code before main() is called.</p>
",1
43738849,12221396,0,"<p>Let's start with <code>*p += 1</code></p>

<p>I will try to answer this from a bit of a different angle... Step 1 Let's look at the operators and the operands: In this case it is one operand (the pointer p), and we have two operators, in this case * for dereferencing and += 1 for increment. Step 2 which has the higher precedence * has higher precedence over += </p>

<hr>

<p><code>*P++</code>
This one is a bit trickier... maybe even wicked
Again we have one operand (p the pointer) and two operators, only now the * for dereference and ++ post increment are of the same precedence. (In some tables the ++ in a post is a higher precedence.)</p>

<p>Step 1 Let's look at the operators and the operands: In this case it is the operand, and you have two operators, in this case * for dereferencing and ++ for increment. Step 2 which has the higher precedence? ++ has higher precedence over * Note: even if they have the SAME precedence they associate right to left, again, the ++ is before *
Step 3 (the tricky part...) Where is ++ ? it is to the right side of the operand, which means <strong>POST Increment</strong> In this case, the compiler take a 'mental note' to perform the increment <strong>AFTER</strong> it is done with all the other operators... 
What after means? It means that it will only apply the increment as the very very very last step before the next ';' so it will be done with all other operators that are on the same 'line' 
note: if it was *++p then it will do it BEFORE any other operator on the same line so in this case, it is as equivalent to taking two of the processor's register, one will hold the value of the dereferenced *p and the other will hold the value of the incremented p++, the reason in this case there are two, is the POST activity... This is where in this case it is tricky, and it looks like a contradiction. One would expect the ++ to take precedence over the *, which it does, only that the POST means that it will be applied only after ALL other operands, BEFORE the next ';' token...</p>

<p>Like I said, the tricky part is that any increment that is to the right of an operand will be set aside, and will be applied as the LAST operation before it moves on to the next line...</p>
",0
45097669,5907790,0,"<p><a href=""http://www.pythontutor.com/c.html"" rel=""nofollow noreferrer"">C Tutor - Visualize C code execution to learn C online</a></p>

<p>Is a great tool for visualizing the workflow of your C/C++ code - as well as a number of other languages.  To my knowledge you cannot enter any command line arguments, but that's the only limitation I can think of.  The benefits are that it is free, web based, and very intuitive.</p>
",0
37351225,37350939,0,"<p>Maybe the author wants to be able to use that member as array I.e. pass to functions expecting arrays, pass by address instead of value...</p>
",0
37351139,37350939,0,"<p>It seems the author of the structure is going to use the array of undefined size. That is the structure can have a variable size depending on how many elements the last data member of the structure, the array, will have. </p>

<p>The last data member also could be declared as a flexible array.</p>
",0
37351044,37350939,0,"<p>Because this denotes an ""array of pointers to zend_ast"" instead of a ""pointer to (an array) of zend_ast"". Another, IMHO more readable way to write something with the same effect (though semantically not <em>exactly</em> the same) would be <code>zend_ast **child</code>.</p>
",0
37351299,37350939,0,"<p>The author apparently intends for the last element to be a variably-sized array of 'pointers-to-_zend_ast'. In a scheme such as this it's common to use a NULL value in the last pointer in the array as the 'end-of-array' marker. The other alternative would be to define <code>child</code> as <code>zend_ast **</code> which would then point to an entirely separate block of memory. This latter arrangement is a bit more complex and error-prone as both blocks of memory (the <code>struct _zend_ast</code> block and the <code>child</code> block) have to be released when freeing memory.</p>

<p>Best of luck.</p>
",0
37351844,37350939,4,"<p>This is an example of the <em><code>struct</code> hack</em>, where you can define a variable-length array member without actually using a variable-length array<sup>1</sup>.</p>

<p>This is probably best shown with an example.  Assume the <code>struct</code> type</p>

<pre><code>struct foo {
  int x;
  int arr[1];
};
</code></pre>

<p>If I allocate a struct instance like so:</p>

<pre><code>struct foo f;
</code></pre>

<p>I get enough space for <code>x</code> and a 1-element array of <code>int</code>:</p>

<pre><code>     +---+
  x: |   |
     +---+
arr: |   | arr[0]
     +---+
</code></pre>

<p>Not terribly useful.  </p>

<p>However, if I allocate space for the struct like this:</p>

<pre><code>struct foo *p = malloc( sizeof *p + (4 * sizeof( int ));
</code></pre>

<p>I get something like this:</p>

<pre><code>     +---+
  x: |   |
     +---+
arr: |   | arr[0]
     +---+
     |   | arr[1]
     +---+ 
     |   | arr[2]
     +---+
     |   | arr[3]
     +---+ 
     |   | arr[4]
     +---+
</code></pre>

<p>I've allocated enough space for all the members of the struct, plus space for an additional 4 integers.  This extra space follows <code>arr</code>, meaning I've effectively created <code>p-&gt;arr</code> as a <em>5</em>-element array of <code>int</code>.  It's as though I had defined the struct as</p>

<pre><code>struct foo {
  int x;
  int arr[5];
};
</code></pre>

<p>This is distinct from a technique like</p>

<pre><code>struct bar {
  int x;
  int *arr;
};

struct bar *p = malloc( sizeof *p );
if ( p )
{
  p-&gt;arr = malloc( sizeof *p-&gt;arr * 5 );
}
</code></pre>

<p>which gives me something like this:</p>

<pre><code>     +---+
  x: |   |
     +---+
arr: |   | ---------+ 
     +---+          |
      ...           |
     +---+          |
     |   | arr[0] &lt;-+
     +---+
     |   | arr[1]
     +---+
     |   | arr[2]
     +---+
     |   | arr[3]
     +---+ 
     |   | arr[4]
     +---+
</code></pre>

<p>The memory for <code>arr</code> is not part of the <code>struct</code> instance itself; each instance of <code>struct bar</code> is the same size.<br>
<hr>
<sup></p>

<ol>
<li>Which is handy, since VLAs may not be members of `struct` types.
</ol>

<p></sup></p>
",0
36275897,36274902,2,"<p>In portable C, it's easiest to use <code>snprintf</code> to calculate the size of the array required, and then <code>sprintf</code> for the actual conversion. For example:</p>

<pre><code>char buffer[snprintf(NULL, 0, ""%d"", x) + 1];
sprintf(buffer, ""%d"", x);
</code></pre>

<p>It's worthwhile noting that this won't work prior to C99, and there's also a neater alternative which works prior to C99 and is <em>type-generic for all integers</em>. That's described in <a href=""https://stackoverflow.com/a/36274949/1989425"">another answer to this question using the multiplication trick</a>, however I noticed the trick proposed there isn't strictly portable either. In environments where <code>CHAR_BIT</code> isn't 8 (for example, some DSPs use 16- or 32- bit bytes), you'll need to change the multiplier.</p>

<p>I presented <a href=""https://stackoverflow.com/a/16975453/1989425"">a similar trick in response to a different question</a>. That code used <code>CHAR_BIT</code> to ensure portability, even when <code>CHAR_BIT</code> changes. It's presented as a macro, and so it's internally documenting; it tells you what the high-level description is, which a multiplication alone can't do.</p>

<pre><code>#include &lt;limits.h&gt;
#include &lt;stddef.h&gt;
#include &lt;stdio.h&gt;

#define digit_count(num) (1                                /* sign            */ \
                        + sizeof (num) * CHAR_BIT / 3      /* digits          */ \
                        + (sizeof (num) * CHAR_BIT % 3 &gt; 0)/* remaining digit */ \
                        + 1)                               /* NUL terminator  */

int main(void) {
    short short_number = -32767;
    int int_number = 32767;
    char short_buffer[digit_count(short_number)] = { 0 };
    char int_buffer[digit_count(int_number)];
    sprintf(short_buffer, ""%d"", short_number);
    sprintf(int_buffer, ""%d"", int_number);
}
</code></pre>
",3
46029593,46029580,5,"<p>What happens in this line</p>

<pre><code>#define stb_sb_free(a) ((a) ? free(stb__sbraw(a)),0 : 0)
</code></pre>

<p>is, if <code>a</code> corrsponseds to <code>true</code>, first <code>free(stb__sbraw(a))</code> will be executed, then <code>0</code> will be returned due to <code>,0</code>.</p>

<p>In general, all expressions which they're separated by comma will be evaluated, but the result has the type and value of the rightmost expression. </p>
",0
43749039,6684411,-2,"<p><code>main()</code> ?</p>

<p>which data type is?</p>

<p>you need select the data type:</p>

<pre><code>int main() {
   return 0
}
</code></pre>

<p><code>printf</code> is void funcion...</p>

<p>Code correctly:</p>

<pre><code>#include &lt;stdio.h&gt;

char char1;     /* first character */
char char2;     /* second character */
char char3;     /* third character */

int main() {
    char1 = 'A';
    char2 = 'B';
    char3 = 'C';
    printf(""%c%c%c reversed is %c%c%c\n"",
    char1, char2, char3,
    char3, char2, char1);
    return 0;
}
</code></pre>
",1
43749039,6684411,-2,"<p><code>main()</code> ?</p>

<p>which data type is?</p>

<p>you need select the data type:</p>

<pre><code>int main() {
   return 0
}
</code></pre>

<p><code>printf</code> is void funcion...</p>

<p>Code correctly:</p>

<pre><code>#include &lt;stdio.h&gt;

char char1;     /* first character */
char char2;     /* second character */
char char3;     /* third character */

int main() {
    char1 = 'A';
    char2 = 'B';
    char3 = 'C';
    printf(""%c%c%c reversed is %c%c%c\n"",
    char1, char2, char3,
    char3, char2, char1);
    return 0;
}
</code></pre>
",1
40542677,40542556,4,"<p>You try and use <code>a</code> before validating whether the input is valid. This could lead to unexpected behavior. You need to validate your input, something like:</p>

<pre><code>if (scanf(""%lf %lf"", &amp;a, &amp;b) != 2) {
    // handle bad input
}
</code></pre>
",0
38194453,7271939,2,"<p>Actually it depends on what you need, if you just want to disable the warning of compiler, you can just ignore the return value of the function by the force conversion  or you can just handle it, the meaning of the <code>scanf</code> function is the count of user input.</p>

<p>==== update ====</p>

<p>You can use</p>

<p><code>(void) scanf(""%d"",&amp;t);</code> </p>

<p>to ignore the return value of <code>scanf</code></p>
",8
34910008,34908845,1,"<p>@FUZxxl is right, the signature of the function is given as:</p>

<pre><code>int _mm_cmpestri (
   __m128i a, 
   int la,
   __m128i b,
   int lb, 
   const int mode
);
</code></pre>

<p>So, you need to dereference a and b as:</p>

<pre><code>idx=_mm_cmpestri (*a, 16, *b, 1, _SIDD_UBYTE_OPS |_SIDD_CMP_EQUAL_ANY|_SIDD_LEAST_SIGNIFICANT);
</code></pre>
",2
35234413,35234285,1,"<p>To convert <code>my_first_reg[0]</code> the ASCII character to its numeric value:</p>

<pre><code>unsigned char value = my_first_reg[0] - '0';
</code></pre>

<p>This works because digits in the ASCII table are sequential:</p>

<pre>
    '0' = 0x30 = 48
    '1' = 0x31 = 49
    '2' = 0x32 = 50
    '3' = 0x33 = 51
    '4' = 0x34 = 52
    ...
    '9' = 0x39 = 57
</pre>

<hr>

<p>The above is for converting one character.  If you have a longer string, consider using <a href=""http://linux.die.net/man/3/atoi"" rel=""nofollow""><code>atoi()</code></a>, <a href=""http://linux.die.net/man/3/strtol"" rel=""nofollow""><code>strtol()</code></a>, <a href=""http://linux.die.net/man/3/sscanf"" rel=""nofollow""><code>sscanf()</code></a>, or something similar.</p>
",1
38287512,38287455,5,"<p>The <code>sizeof</code> operator always yields a result of type <code>size_t</code>  (which is an implementation-defined unsigned integral type).</p>

<p>However, a <code>size_t</code> can be converted to other integral types, as happens in the initialisation of <code>charSize</code>  (i.e. <code>sizeof</code> yields a <code>size_t</code>, and that is converted to an <code>int</code> to initialise <code>charSize</code>).</p>

<p>Such conversions, and their limitations (e.g. what is well-defined or not if the result being converted cannot be stored in the resultant type) are described by the standard.</p>

<p>The statement</p>

<pre><code>printf(""char: %lu\n"", sizeof(c));    // Here it is an unsigned long
</code></pre>

<p>formally has undefined behaviour since <code>sizeof</code> is not required to produce a result of type <code>unsigned long</code>, and <code>printf()</code> exhibits undefined behaviour if a value being output is not of the type specified in the format string.   It is true that <code>size_t</code> and <code>unsigned long</code> are equivalent on some implementations (i.e. compilers) and that statement will behave appropriately then.   However, there are other implementations for which <code>size_t</code> and <code>unsigned long</code> are different types.</p>
",0
35218583,35218154,1,"<p>One of the easiest ways to handle the hex string conversion is using <code>strtoul</code> with its ability to read/convert <code>base-16</code>. <code>strtoul</code> can be used along with a pointer to step through the input string providing conversion of each value found, and then simply moving the pointer to the beginning of the next value. Given your input, <code>strchr</code> is used to locate each <code>'x'</code> and then to convert the 2-characters that follow.</p>

<p>To aid in this process you can write a simple function that will provide all the error checking and validation of the conversions. Something like the following works well:</p>

<pre><code>/** string to unsigned long with error checking */
unsigned long xstrtoul (char *p, char **ep, int base)
{
    errno = 0;

    unsigned long tmp = strtoul (p, ep, base);

    /* Check for various possible errors */
    if ((errno == ERANGE &amp;&amp; (tmp == ULONG_MAX)) ||
        (errno != 0 &amp;&amp; tmp == 0)) {
        perror (""strtoul"");
        exit (EXIT_FAILURE);
    }

    if (*ep == p) {
        fprintf (stderr, ""No digits were found\n"");
        exit (EXIT_FAILURE);
    }

    return tmp;
}
</code></pre>

<p>You need only minimal code to apply the function to all lines in your data file. For example:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt; /* for strtol               */
#include &lt;string.h&gt; /* for strchr               */
#include &lt;limits.h&gt; /* for INT_MIN/INT_MAX      */
#include &lt;errno.h&gt;  /* for errno                */

#define MAXL 256

unsigned long xstrtoul (char *p, char **ep, int base);

int main (int argc, char **argv)
{
    FILE *fp = argc &gt; 1 ? fopen (argv[1], ""r"") : stdin;
    char line[MAXL] = {0};
    unsigned values[MAXL] = {0};
    int base = argc &gt; 2 ? atoi (argv[2]) : 16;
    size_t i, idx = 0;

    if (!fp) { /* validate file open */
        fprintf (stderr, ""error: file open failen '%s'.\n"", argv[1]);
        return 1;
    }

    /* read each line in file (up to MAXL chars per-line) */
    while (fgets (line, MAXL, fp)) {

        char *p = line;
        char *ep = p;
        char digits[3] = {0};
        errno = 0;

        /* convert each string of digits into number */
        while (errno == 0) {

            /* skip any non-digit characters */
            if (!(p = strchr (p, 'x'))) break;
            strncpy (digits, ++p, 2);
            digits[2] = 0;  /* nul-terminate */

            /* convert string to number */
            values[idx++] = (unsigned)xstrtoul (digits, &amp;ep, base);

            if (errno || idx == MAXL) {   /* check for error */
                fprintf (stderr, ""warning: MAXL values reached.\n"");
                break;
            }
            p += 2;
        }
    }
    if (fp != stdin) fclose (fp);

    /* print results */
    for (i = 0; i &lt; idx; i++)
        printf ("" values[%2zu] : 0x%02x\n"", i, values[i]);

    return 0;
}

/** string to unsigned long with error checking */
unsigned long xstrtoul (char *p, char **ep, int base)
{
    errno = 0;

    unsigned long tmp = strtoul (p, ep, base);

    /* Check for various possible errors */
    if ((errno == ERANGE &amp;&amp; (tmp == ULONG_MAX)) ||
        (errno != 0 &amp;&amp; tmp == 0)) {
        perror (""strtoul"");
        exit (EXIT_FAILURE);
    }

    if (*ep == p) {
        fprintf (stderr, ""No digits were found\n"");
        exit (EXIT_FAILURE);
    }

    return tmp;
}
</code></pre>

<p><strong>Input Files</strong></p>

<pre><code>$ cat dat/hex3.txt
0x020x000x000x000x000x000x680x000x000x000x020x000x000x000x000x00
</code></pre>

<p><strong>Use/Output</strong></p>

<pre><code>$ ./bin/fgets_xstrtoul_simple dat/hex3.txt
 values[ 0] : 0x02
 values[ 1] : 0x00
 values[ 2] : 0x00
 values[ 3] : 0x00
 values[ 4] : 0x00
 values[ 5] : 0x00
 values[ 6] : 0x68
 values[ 7] : 0x00
 values[ 8] : 0x00
 values[ 9] : 0x00
 values[10] : 0x02
 values[11] : 0x00
 values[12] : 0x00
 values[13] : 0x00
 values[14] : 0x00
 values[15] : 0x00
</code></pre>

<p>Look it over and let me know if you have any questions.</p>
",0
35218261,35218154,4,"<p>The <a href=""http://en.cppreference.com/w/c/io/fscanf"" rel=""nofollow""><code>scanf</code> function (and family)</a> is <em>greedy</em> when it reads its data, meaning the <code>""%x""</code> format will read the leading zero from the <em>next</em> number as a final zero in the current number.</p>

<p>In the example you show, the first number it reads will be <code>0x020</code> and not <code>0x02</code>.</p>

<p>This can easily be solved by telling <code>sscanf</code> to only read four characters:</p>

<pre><code>sscanf(hex+used, ""%4x"", &amp;licensebin[i])
</code></pre>

<p>After you added the comment about <code>licensebin[i]</code> being an <code>unsigned char</code>, the correct format should actually be</p>

<pre><code>sscanf(hex+used, ""%4hhx"", &amp;licensebin[i])
</code></pre>

<p>The prefix <code>""hh""</code> tells <code>sscanf</code> that the argument is actually a pointer to an <code>unsigned char</code>. You <em>still</em> need to tell <code>sscanf</code> to read only max four characters, as it's still greedy.</p>
",3
35218273,35218154,1,"<p>Maybe change this:</p>

<pre><code>while ((sscanf(hex+used, ""%x"", &amp;licensebin[i]))==1)
{
</code></pre>

<p>To this:</p>

<pre><code>unsigned int n;
while ((sscanf(hex+used, ""0x%2x"", &amp;n)==1)
{    
    licensebin[i] = (unsigned char)n;
</code></pre>

<p>(Thanks to everyone reminding me of the type scanf expects when matching %x.)</p>

<p>This is intended to match the literal '0x' in your input and to limit the number of hex digits read to 2.</p>

<p>Alternatively change:</p>

<pre><code>used = 0;
while ((sscanf(hex+used, ""%x"", &amp;licensebin[i]))==1)
</code></pre>

<p>To:</p>

<pre><code>used = 2;
unsigned int n;
while ((sscanf(hex+used, ""%2x"", &amp;n)==1)
{    
    licensebin[i] = (unsigned char)n;
</code></pre>

<p>All this assumes the licensebin is something like:</p>

<pre><code>char *hex = ""0x020x000x000x000x000x000x680x000x000x000x020x000x000x000x000x00"";
</code></pre>

<p>That is you literally have a '0' character, 'x' character etc. If your data is binary, you need a totally different approach.</p>
",2
35218462,35218154,1,"<p>I tried the below and it worked. Probably you need to define license as int when using %x instead of unsigned char:</p>

<pre><code>#include &lt;stdio.h&gt;

int main() {

    int license[20];
    char* hex = ""0x020x000x000x000x000x000x680x000x000x000x020x000x000x000x000x00"";
    int used = 0;
    int i = 0;
    while((sscanf(hex+used,""%x"",&amp;license[i]))==1)
    {
        printf(""%x"",license[i]);
        i++;
        used += 4;
    }

}
</code></pre>
",1
36486974,36479183,0,"<p>The solutions the other guys proposed are very nice and probably the shortest to write and remain understandable. Another straight forward approach would be something like this</p>

<pre><code>int bitCountLinear(long int n) {
    int len = sizeof(long int)*8;
    for (int i = 0; i &lt; len; ++i) 
        if ((1UL&lt;&lt;i) &gt; (unsigned long int)n) 
            return i;
    return len; 
}
</code></pre>

<p>The rest might get a bit extreme but I gave it a try so I'll share it.
I suspected that there might be arguably faster methods of doing this. eg Using binary search (even though a length of 64bits is extremely small). So I gave it a quick try for you and for the fun of it.</p>

<pre><code>union long_ing_family {
    unsigned long int uli;
    long int li;
};

int bitCountLogN(long int num) {
    union long_ing_family lif;
    lif.li = num;
    unsigned long int n = lif.uli;
    int res;
    int len = sizeof(long int)*8-1;
    int max = len;
    int min = 0;

    if (n == 0) return 0;
    do {
        res = (min + max) / 2;
        if (n &lt; 1UL&lt;&lt;res)
            max = res - 1;
        else if (n &gt;= (1UL&lt;&lt;(res+1)))
            min = res + 1;
        else
            return res+1;
    } while (min &lt; max);

    return min+1;   // or max+1
}
</code></pre>

<p>I then timed both to see if they have any interesting differences...</p>

<pre><code>#include &lt;stdio.h&gt;

#define REPS 10000000

int bitCountLinear(long int n);
int bitCountLogN(long int num);
unsigned long int timestamp_start(void);
unsigned long int timestamp_stop(void);
union long_ing_family;

int main(void) {

    long int n;
    long int begin, end;
    long int begin_Lin, end_Lin;
    long int begin_Log, end_Log;

    begin_Lin = 0;
    end_Lin = 0;
    begin_Log = 0;
    end_Log = 0;

    for (int i = 0; i &lt; REPS; ++i) {
        begin_Lin += timestamp_start();
        bitCountLinear(i);
        end_Lin += timestamp_stop();
    }
    printf(""Linear: %lu\n"", (end_Lin-begin_Lin)/REPS);

    for (int i = 0; i &lt; REPS; ++i) {
        begin_Log += timestamp_start();
        bitCountLogN(i);
        end_Log += timestamp_stop();
    }
    printf(""Log(n): %lu\n"", (end_Log-begin_Log)/REPS);

}

unsigned long int timestamp_start(void) {
    unsigned int cycles_low;
    unsigned int cycles_high;
    asm volatile (""CPUID\n\t""
        ""RDTSCP\n\t""
        ""mov %%edx, %0\n\t""
        ""mov %%eax, %1\n\t"": ""=r"" (cycles_high), ""=r"" (cycles_low)::""%rax"", ""%rbx"", ""%rcx"", ""%rdx"");
    return ((unsigned long int)cycles_high &lt;&lt; 32) | cycles_low;
}

unsigned long int timestamp_stop(void) {
    unsigned int cycles_low;
    unsigned int cycles_high;
    asm volatile (""RDTSCP\n\t""
        ""mov %%edx, %0\n\t""
        ""mov %%eax, %1\n\t""
        ""CPUID\n\t"": ""=r"" (cycles_high), ""=r"" (cycles_low)::""%rax"", ""%rbx"", ""%rcx"", ""%rdx"");
    return ((unsigned long int)cycles_high &lt;&lt; 32) | cycles_low;
}
</code></pre>

<p>...and not surprisingly they didn't.
On my machine I'll get numbers like
Linear: 228
Log(n): 224
Which are not considered to be different assuming a lot of background noise.</p>

<p>Edit:
I realized that I only tested the fastest solutions for the Linear approach so changing the function inputs to</p>

<pre><code>bitCountLinear(0xFFFFFFFFFFFFFFFF-i);
</code></pre>

<p>and</p>

<pre><code>bitCountLogN(0xFFFFFFFFFFFFFFFF-i);
</code></pre>

<p>On my machine I'll get numbers like
Linear: 415
Log(n): 269
Which is clearly a win for the Log(n) method. I didn't expect to see a difference here.</p>
",0
35249936,35249731,2,"<p>You can use the full version (""%s %d""). sscanf will return the number of variables assigned. From <a href=""http://www.cplusplus.com/reference/cstdio/sscanf/"" rel=""nofollow"">http://www.cplusplus.com/reference/cstdio/sscanf/</a></p>

<blockquote>
  <p>On success, the function returns the number of items in the argument list successfully filled. This count can match the expected number of items or be less (even zero) in the case of a matching failure.</p>
</blockquote>

<p>So if you only have ""cost apple"" as an input, sscanf would return 1 and populate <code>product</code>. Whereas with ""cost apple, 3"" it would return 2 and populate <code>product</code> and <code>value</code>.</p>

<p>You have a few problems with your code too. First, the first argument to sscanf should be the string to read from. Not the format string. Second, the format string needs to be a string, use double quotes (""). Third, don't escape the comma, that's not a valid escape sequence.</p>

<p>You can't have that comma in the format string anyway. The <code>%s</code> specifier reads characters until the first whitespace character it sees. So an input string of <code>""cost apple, 3""</code> would need a format specifier of <code>""cost %s %d""</code>. You would then have to get the substring without the comma in order to get the actual product name.</p>
",0
35249944,35249731,4,"<p>The <code>sscanf</code> will fail due to another reasons, and once it is fixed, it won't fail for ', 3' not appearing on the string.</p>

<p>I suggest you should get return value from <code>sscanf</code>, and then use it for determining how many data are read.</p>

<pre><code>#include &lt;stdio.h&gt;

void test(const char *data) {
    char product[100];
    int value;
    int ssret;

    ssret = sscanf(data, ""cost %99[^,], %d"", product, &amp;value);
    switch(ssret) {
        case 1:
            printf(""product = %s\n"", product);
            break;
        case 2:
            printf(""product = %s, value = %d\n"", product, value);
            break;
        default:
            puts(""sscanf() failed to read"");
            break;
    }
}

int main(void) {
    test(""cost apple"");
    test(""cost apple, 3"");
    return 0;
}
</code></pre>
",0
35249976,35249731,1,"<p>First of, the prototype of <a href=""http://www.cplusplus.com/reference/cstdio/sscanf/"" rel=""nofollow""><code>sscanf()</code></a> is <code>int sscanf ( const char * s, const char * format, ...);</code></p>

<p>So try this:</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
        char product[100] = {0};
        int value = 0;

        sscanf(""cost apple"", ""cost %[^,\n], %d"", product, &amp;value);
        printf(""cost %s, %d\n"", product, value);

        sscanf(""cost apple, 3"", ""cost %[^,\n], %d"", product, &amp;value);
        printf(""cost %s, %d\n"", product, value);

        return 0;
}
</code></pre>

<p>The <code>%[^,\n]</code> in <code>sscanf()</code> match every <code>char</code> besides <code>,</code> and <code>\n</code>. The <code></code> before <code>%d</code> is used to discard all whitespace characters.</p>

<p>Also, using <code>&amp;product</code> will cause undefined behavior, so just write <code>product</code> instead.</p>

<h1>EDIT</h1>

<p>It's always a good habit to check the return value of <code>sscanf()</code>. Although you will code will compile and run successfully without doing this, it will tell you which information is useful and which is not.</p>
",2
42569961,42569928,0,"<p>Instead of stopping when you reach <code>1</code>, stop when you reach <code>from</code>.</p>

<pre><code>int calculateSum(from, to) {
    if (to == from) {
        return from;
    } else {
        return to + calculateSum(from, to-1);
    }
}
</code></pre>
",0
42569969,42569928,0,"<p>change 1 to from:</p>

<pre><code>int calculateSum(int from,int to) {
    int res;
    if (to== from) {
        return (from);
    }
    else {
        res = to+ calculateSum(from,to - 1);
    }
    return (res);
}
</code></pre>
",0
42569972,42569928,1,"<p>At the moment, you are hard-coding <code>1</code> as the terminating point of the recursion.</p>

<p>What you need is to be able to use a <em>different</em> value for that, and the following pseudo-code shows how to do it:</p>

<pre><code>def calculateSum(number, limit):
    if number &lt;= limit:
        return limit
    return number + calculateSum(number - 1, limit)
</code></pre>

<p>For efficiency, if you break the rules and provide a limit higher than the starting number, you just get back the number. You <em>could</em> catch that and return zero but I'll leave that as an exercise if you're interested.</p>

<p>It should be relatively easy for you to turn that into real code, using your own <code>calculateSum</code> as a baseline.</p>

<hr>

<p>I should mention that this is a spectacularly bad use case for recursion. In general, recursion should be used when the solution search space reduces quickly (such as a binary search halving it with each recursive level). Unless your environment does tail call optimisation, you're likely to run out of stack space fairly quickly.</p>
",1
42569986,42569928,-1,"<p>You can use ternary operator.</p>

<pre class=""lang-c prettyprint-override""><code>int calculateSum(int from, int to) {
    return from == to ? from : from + calculateSum(from + 1, to);
}
</code></pre>
",0
42570029,42569928,3,"<pre><code>int calculateSum(int fromNum, int toNum) {
    int res;
    if (fromNum == toNum) {
        return (fromNum);
    }
    else {
        res = fromNum + calculateSum((fromNum + 1), toNum);
    }
    return (res);
}
</code></pre>
",0
42569961,42569928,0,"<p>Instead of stopping when you reach <code>1</code>, stop when you reach <code>from</code>.</p>

<pre><code>int calculateSum(from, to) {
    if (to == from) {
        return from;
    } else {
        return to + calculateSum(from, to-1);
    }
}
</code></pre>
",0
42569969,42569928,0,"<p>change 1 to from:</p>

<pre><code>int calculateSum(int from,int to) {
    int res;
    if (to== from) {
        return (from);
    }
    else {
        res = to+ calculateSum(from,to - 1);
    }
    return (res);
}
</code></pre>
",0
42569972,42569928,1,"<p>At the moment, you are hard-coding <code>1</code> as the terminating point of the recursion.</p>

<p>What you need is to be able to use a <em>different</em> value for that, and the following pseudo-code shows how to do it:</p>

<pre><code>def calculateSum(number, limit):
    if number &lt;= limit:
        return limit
    return number + calculateSum(number - 1, limit)
</code></pre>

<p>For efficiency, if you break the rules and provide a limit higher than the starting number, you just get back the number. You <em>could</em> catch that and return zero but I'll leave that as an exercise if you're interested.</p>

<p>It should be relatively easy for you to turn that into real code, using your own <code>calculateSum</code> as a baseline.</p>

<hr>

<p>I should mention that this is a spectacularly bad use case for recursion. In general, recursion should be used when the solution search space reduces quickly (such as a binary search halving it with each recursive level). Unless your environment does tail call optimisation, you're likely to run out of stack space fairly quickly.</p>
",1
42569986,42569928,-1,"<p>You can use ternary operator.</p>

<pre class=""lang-c prettyprint-override""><code>int calculateSum(int from, int to) {
    return from == to ? from : from + calculateSum(from + 1, to);
}
</code></pre>
",0
42570029,42569928,3,"<pre><code>int calculateSum(int fromNum, int toNum) {
    int res;
    if (fromNum == toNum) {
        return (fromNum);
    }
    else {
        res = fromNum + calculateSum((fromNum + 1), toNum);
    }
    return (res);
}
</code></pre>
",0
45112907,45112705,3,"<p>You are correct that the loop is run twice for the first index.</p>

<p>However, this is not a <em>bug</em>, because assignment is an idempotent operation, so multiple assignments for a given index, will have no further effect or side effects. The function will always work the same, even if the first index is repeated twice.</p>

<p>Performancewise, the difference should be negligible, since it would only be one extra assignment per function call. (Because of idempotence it may also be simply optimized away by the compiler).</p>

<hr>

<p>That being said, for clarity and in case the <code>for</code> loop body ever was changed to no longer be indempotent (for instance by adding a <code>printf</code> statement), I would personally use prefix increment:</p>

<pre><code>for (index = prime * multiplier; index &lt; ARRAY_SIZE; index = prime * ++multiplier)
</code></pre>
",1
34978487,34978046,0,"<p>The general rule here is to trust your compiler to do something fast. You can always disassemble the code and check that the compiler is doing something sane. It's important to realise that a good compiler knows <strong>a lot</strong> about the machine, often more than you or me.</p>

<p>Also let's assume you have a good reason for needing to ""count cycles"".</p>

<p>For your example code I agree that the x86 ""idiv"" instruction is the obvious choice. Let's see what my compiler (MS visual C 2013) will do if I just write out the most naive code I can</p>

<pre><code>struct divresult {
    int quot;
    int rem;
};

struct divresult divrem(int num, int den)
{
    return (struct divresult) { num / den, num % den };
}

int main()
{
    struct divresult res = divrem(5, 2);
    printf(""%d, %d"", res.quot, res.rem);
}
</code></pre>

<p>And the compiler gives us:</p>

<pre><code>    struct divresult res = divrem(5, 2);
    printf(""%d, %d"", res.quot, res.rem);
01121000  push        1 
01121002  push        2
01121004  push        1123018h  
01121009  call        dword ptr ds:[1122090h] ;;; this is printf()
</code></pre>

<p>Wow, I was outsmarted by the compiler. Visual C knows how division works so it just precalculated the result and inserted constants. It didn't even bother to include my function in the final code. We have to read in the integers from console to force it to actually do the calculation:</p>

<pre><code>int main()
{
    int num, den;
    scanf(""%d, %d"", &amp;num, &amp;den);
    struct divresult res = divrem(num, den);
    printf(""%d, %d"", res.quot, res.rem);
}
</code></pre>

<p>Now we get:</p>

<pre><code>    struct divresult res = divrem(num, den);
01071023  mov         eax,dword ptr [num]  
01071026  cdq  
01071027  idiv        eax,dword ptr [den]  
    printf(""%d, %d"", res.quot, res.rem);
0107102A  push        edx  
0107102B  push        eax  
0107102C  push        1073020h  
01071031  call        dword ptr ds:[1072090h] ;;; printf()
</code></pre>

<p>So you see, the compiler (or this compiler at least) already does what you want, or something even more clever.</p>

<p>From this we learn to trust the compiler and only second-guess it when we <strong>know</strong> it isn't doing a good enough job already.</p>
",0
34987517,34978046,1,"<p>Since you're writing to the arrays in-place (replacing numerator and denominator with quotient and remainder) you should store the results to temporary variables before writing to the arrays.</p>

<pre><code>void foo (unsigned *num, unsigned *den, int n) {
    int i;
    for(i=0;i&lt;n;i++) {
        unsigned q = num[i]/den[i], r = num[i]%den[i];   
        num[i] = q, den[i] = r;
    }
}
</code></pre>

<p>produces this main loop assembly</p>

<pre><code>.L5:
        movl    (%rdi,%rcx,4), %eax
        xorl    %edx, %edx
        divl    (%rsi,%rcx,4)
        movl    %eax, (%rdi,%rcx,4)
        movl    %edx, (%rsi,%rcx,4)
        addq    $1, %rcx
        cmpl    %ecx, %r8d
        jg      .L5
</code></pre>

<p>There are some more complicated cases where it helps to save the quotient and remainder when they are first used.  For example in testing for primes by trial division you often see a loop like this</p>

<pre><code>for (p = 3; p &lt;= n/p; p += 2)
    if (!(n % p)) return 0;
</code></pre>

<p>It turns out that <a href=""https://stackoverflow.com/questions/22556599/conditional-tests-in-primality-by-trial-division"">GCC does not use the remainder from the first division</a> and therefore it does the division instruction twice which is unnecessary.  To fix this you can save the remainder when the first division is done like this:</p>

<pre><code>for (p = 3, q=n/p, r=n%p; p &lt;= q; p += 2, q = n/p, r=n%p)
    if (!r) return 0;
</code></pre>

<p>This speeds up the result by a factor of two.  </p>

<p>So in general GCC does a good job particularly if you save the quotient and remainder when they are first calculated.</p>
",0
46046925,17184511,0,"<pre><code>void delete_last(){    
    struct node *ptr=start;
    while(ptr-&gt;next-&gt;next!=NULL){
        ptr=ptr-&gt;next;
    }
    ptr-&gt;next=NULL;
    free(ptr-&gt;next);    
}
</code></pre>
",1
40537869,16314468,2,"<p>as stated by others, the fgets() will read the newline(\n) character and store it in your array.</p>

<p>after every call to fgets() I always use strcspn() to search the array/pointer to find the newline character and replace it with the null character.</p>

<pre><code>char str2[100];
printf(""\nEnter a string: "");
fgets (str2, sizeof(str2), stdin);

//new line of code to replace '\n' with '\0'
str2[strcspn(str2, ""\n"")] = '\0';

printf(""\n%d"",strlen(str2));
</code></pre>
",0
36226306,14902456,-1,"<pre><code>// wenn countValue ein Objekt zur¨¹ckgibt

static int* count=0;  if(count==0)count=countValue();
</code></pre>
",2
36254563,20028952,0,"<p>constant is a compile time concept , but there is one exception that is for pointers , since c-string = char * so there will be possible to know if a char* is read-only at runtime : </p>

<pre><code>#include &lt;iostream&gt;
#include &lt;typeinfo&gt;
int main()
{
    char * str1;
    const char *  str2 = ""str2"";
    std::cout&lt;&lt;""char * : ""&lt;&lt;typeid(str1).name()&lt;&lt;""\n"";
    std::cout&lt;&lt;""const char * : ""&lt;&lt;typeid(str2).name()&lt;&lt;""\n"";
    system(""pause"");
}
</code></pre>

<p>the output is :</p>

<pre><code>char * : Pc
const char * : PKc
Appuyez sur une touche pour continuer... // press any key to continue
</code></pre>
",6
37195527,8011700,9,"<p>There is a single <a href=""https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets#BMI1_.28Bit_Manipulation_Instruction_Set_1.29"" rel=""noreferrer"">BEXTR (Bit field extract (with register))</a> x86 instruction on Intel and AMD CPUs and <a href=""https://stackoverflow.com/q/8366625/4279""><code>UBFX</code></a> on ARM. There are intrinsic functions such as <a href=""https://software.intel.com/en-us/node/514039"" rel=""noreferrer""><code>_bextr_u32()</code></a> (link requires sign-in) that allow to invoke this instruction explicitly.</p>

<p>They implement <code>(source &gt;&gt; offset) &amp; ((1 &lt;&lt; n) - 1)</code> C code: get <code>n</code> continuous bits from <code>source</code> starting at the <code>offset</code> bit. Here's a complete function definition that handles edge cases:</p>

<pre><code>#include &lt;limits.h&gt;

unsigned getbits(unsigned value, unsigned offset, unsigned n)
{
  const unsigned max_n = CHAR_BIT * sizeof(unsigned);
  if (offset &gt;= max_n)
    return 0; /* value is padded with infinite zeros on the left */
  value &gt;&gt;= offset; /* drop offset bits */
  if (n &gt;= max_n)
    return value; /* all  bits requested */
  const unsigned mask = (1u &lt;&lt; n) - 1; /* n '1's */
  return value &amp; mask;
}
</code></pre>

<p>For example, to get <code>3</code> bits from <code>2273</code> (<code>0b100011100001</code>) starting at <code>5</code>-th bit, call <code>getbits(2273, 5, 3)</code>¡ªit extracts 7 (<code>0b111</code>).</p>

<blockquote>
  <p>For example, say I want the first 17 bits of the 32-bit value; what is it that I should do?</p>
</blockquote>

<pre><code>unsigned first_bits = value &amp; ((1u &lt;&lt; 17) - 1); // &amp; 0x1ffff
</code></pre>

<p>Assuming <code>CHAR_BIT * sizeof(unsigned)</code> is 32 on your system.</p>

<blockquote>
  <p>I presume I am supposed to use the modulus operator and I tried it and was able to get the last 8 bits and last 16 bits</p>
</blockquote>

<pre><code>unsigned last8bitsvalue  = value &amp; ((1u &lt;&lt;  8) - 1); // &amp; 0xff
unsigned last16bitsvalue = value &amp; ((1u &lt;&lt; 16) - 1); // &amp; 0xffff
</code></pre>

<p>If the offset is always zero as in all your examples in the question then you don't need the more general <code>getbits()</code>. There is a special cpu instruction BLSMSK that helps to <a href=""https://stackoverflow.com/q/12416639/4279"">compute the mask <code>((1 &lt;&lt; n) - 1)</code></a>.</p>
",0
46648676,8584577,3,"<p>This is the easiest function to use, I don't want others to struggle for a long time before getting something similar to this -</p>

<pre><code>char get_bits(char a, char no_of_bits)
{
    return a &amp; ((no_of_bits &lt;&lt; 1) - 1);
}
char a = 0x37;
char b = get_bits(a, 2);
</code></pre>

<p>Hope it helps someone in future</p>
",0
45714163,45713899,3,"<p>It is not the truth. The code is exactly the same. Have checked with 4 popular compilers:</p>

<p>examples gcc x86-64</p>

<p>-O0</p>

<pre><code>if(i)
    cmp     DWORD PTR [rbp-4], 0
    je      .L3

if(0 != i)
    cmp     DWORD PTR [rbp-4], 0
    je      .L7
</code></pre>

<p>-O3</p>

<pre><code>if(i) ....
    test    rax, rax
    lea     ebx, [rdx+1]
    jne     .L13
    mov     ebx, edx
    jmp     .L3

if(0 != i) ...
    test    rax, rax
    lea     ebx, [rdx+1]
    jne     .L15
    mov     ebx, edx
    jmp     .L6
</code></pre>

<p>PS I hate this ridiculous form <code>0 != i</code> instead of <code>i != 0</code></p>

<p>PS2 maybe somewhere in the universe exist C compilers generating different code for those conditions but <code>i</code> is an exact equivalent of <code>i != 0</code> so it quite difficult to imagine, but everything is possible.</p>
",3
45714688,45713899,0,"<p>This is just wrong, but your method is flawed. You should make sure your program does only <strong>one</strong> of the tests at a time and you should make sure that the loop <strong>needs</strong> to execute. Here's a modified version that corrects these methodic issues:</p>

<pre><code>#include &lt;sys/time.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int test1(void)
{
    int j = 0;
    int i;
    for(i = 0; i &lt; 0xFFFFFF; i++)
    {
        int x = rand();
        if(x)
        {
            j++;
        }
    }
    return j;
}

int test2(void)
{
    int j = 0;
    int i;
    for(i = 0; i &lt; 0xFFFFFF; i++)
    {
        int x = rand();
        if(0 != x)
        {
            j++;
        }
    }
    return j;
}

int main(int argc, char **argv)
{
    int which = 0;
    if (argc&gt;1) which = atoi(argv[1]);
    srand(1);

    struct timeval lBefore,lAfter,lResult;

    timerclear(&amp;lBefore);
    timerclear(&amp;lAfter);
    gettimeofday(&amp;lBefore,NULL);

    int j = which ? test2() : test1();

    gettimeofday(&amp;lAfter,NULL);
    timersub(&amp;lAfter,&amp;lBefore,&amp;lResult);
    printf(""[%d]%ld:%ld\n"",j,lResult.tv_sec,lResult.tv_usec);   
}
</code></pre>

<p>Results on the website you linked:</p>

<pre class=""lang-none prettyprint-override""><code>sh-4.2$ main 0
[16777215]0:199145
sh-4.2$ main 0
[16777215]0:211709
sh-4.2$ main 0
[16777215]0:193211
sh-4.2$ main 0
[16777215]0:184544
sh-4.2$ main 0
[16777215]0:196465
sh-4.2$ main 1
[16777215]0:202904
sh-4.2$ main 1
[16777215]0:206235
sh-4.2$ main 1
[16777215]0:183214
sh-4.2$ main 1
[16777215]0:203317
sh-4.2$ main 1
[16777215]0:207389
</code></pre>

<p>So you see there's no difference at all.</p>
",0
43752827,43752563,2,"<p><code>suseconds_t</code> is a signed integer type that can fit the number of microseconds in a second. The type is <code>suseconds_t</code>, not anything else. The whole point of those ""obscure"" types is to make you use them instead of thinking ""oh, I'll just use int because that's what I always use"" and then your program becomes non-portable on some other machine or some time in the future.</p>

<p>Your slightly condescending tone in ""C libraries love to..."" is quite misguided. This is not some obscure library doing some obscure little funny thing. This is <a href=""http://pubs.opengroup.org/onlinepubs/009695399/basedefs/sys/types.h.html#tag_13_67"" rel=""nofollow noreferrer"">POSIX</a>. </p>
",3
43753010,43752563,0,"<p>Most of the time you should code so that the underlying type is irrelevant.
That's the idea of portable, future-proofing code. On a different platform or in an upgrade types may change and existing code should just pick that up.</p>

<p>There are potential flaws though. For a scalar type like <code>susecond</code> as provided you may need to output it and the library should provide a <code>PRI</code>-style macro for output and a <code>SCN</code>-style macro for reading. See <code>&lt;inttypes.h&gt;</code>.
Otherwise you eventually have to come to concrete types.
These macros (or equivalent) are rarely defined (in my experience) and you have to deal with the implementation type at some point...</p>

<p>Also where not using generics (which are newish in C) and without C++ overloading you can hit trouble when passing values into other functions.
You call a function taking an <code>int</code> and then the library or platform changes and the underlying type of <code>susecond</code> is <code>long</code> and boom you've introduced a quiet truncation error! Always enable all your warnings!</p>

<p>Your IDE might let you hover over and look up the underlying type on the boundaries where you need it. But where possible just declare types to be <code>susecond</code> and let the compiler worry about it.</p>

<p>The reason it's done in this case is because (I guess) on 16-bit platforms <code>int</code> might not do for a value up to 999,999 (microseconds...) and this needs to be <code>long</code> but on 32-bit platforms where <code>int</code> is likely to be 32-bt it's fine.</p>

<p>16-bit? Are you sure Granddad? The library is not new and may well be portable to embedded systems where 16-bit is a perfectly reasonable thing to encounter.</p>
",2
43752827,43752563,2,"<p><code>suseconds_t</code> is a signed integer type that can fit the number of microseconds in a second. The type is <code>suseconds_t</code>, not anything else. The whole point of those ""obscure"" types is to make you use them instead of thinking ""oh, I'll just use int because that's what I always use"" and then your program becomes non-portable on some other machine or some time in the future.</p>

<p>Your slightly condescending tone in ""C libraries love to..."" is quite misguided. This is not some obscure library doing some obscure little funny thing. This is <a href=""http://pubs.opengroup.org/onlinepubs/009695399/basedefs/sys/types.h.html#tag_13_67"" rel=""nofollow noreferrer"">POSIX</a>. </p>
",3
43753010,43752563,0,"<p>Most of the time you should code so that the underlying type is irrelevant.
That's the idea of portable, future-proofing code. On a different platform or in an upgrade types may change and existing code should just pick that up.</p>

<p>There are potential flaws though. For a scalar type like <code>susecond</code> as provided you may need to output it and the library should provide a <code>PRI</code>-style macro for output and a <code>SCN</code>-style macro for reading. See <code>&lt;inttypes.h&gt;</code>.
Otherwise you eventually have to come to concrete types.
These macros (or equivalent) are rarely defined (in my experience) and you have to deal with the implementation type at some point...</p>

<p>Also where not using generics (which are newish in C) and without C++ overloading you can hit trouble when passing values into other functions.
You call a function taking an <code>int</code> and then the library or platform changes and the underlying type of <code>susecond</code> is <code>long</code> and boom you've introduced a quiet truncation error! Always enable all your warnings!</p>

<p>Your IDE might let you hover over and look up the underlying type on the boundaries where you need it. But where possible just declare types to be <code>susecond</code> and let the compiler worry about it.</p>

<p>The reason it's done in this case is because (I guess) on 16-bit platforms <code>int</code> might not do for a value up to 999,999 (microseconds...) and this needs to be <code>long</code> but on 32-bit platforms where <code>int</code> is likely to be 32-bt it's fine.</p>

<p>16-bit? Are you sure Granddad? The library is not new and may well be portable to embedded systems where 16-bit is a perfectly reasonable thing to encounter.</p>
",2
38998123,38997919,4,"<p>Standards reserves prefixes with an underscore<sup>1</sup>.</p>

<hr>

<p><sup>1</sup> (Quoted from: <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""nofollow"">ISO/IEC 9899:201x</a> 7.1.3 Reserved identifiers 1)<br>
All identifiers that begin with an underscore and either an uppercase letter or another
underscore are always reserved for any use.<br>
All identifiers that begin with an underscore are always reserved for use as identifiers
with file scope in both the ordinary and tag name spaces.</p>
",2
38998129,38997919,2,"<p>It is not safe. Depending on architecture your code may require some relocations even for <code>static</code> objects. As result their names must be visible to linker as well as names of CRT symbols. And this may cause clashes.</p>
",0
42624741,14494309,0,"<p>Try this piece of code..
It works as desired on a GCC compiler with C99 standards..</p>

<pre><code>#include&lt;stdio.h&gt;
int main()
{
int s[100];
printf(""Enter multiple line strings\n"");
scanf(""%[^\r]s"",s);
printf(""Enterd String is\n"");
printf(""%s\n"",s);
return 0;
}
</code></pre>
",0
41684236,41684109,1,"<p>Yes, there are a few mistakes in here.</p>

<p>This will allocate a buffer of 4 or 8 bytes depending on the word size of your computer. 'sizeof' is a compile time directive that gives you the size of the underlying type.</p>

<blockquote>
  <p>char tmp[sizeof(_log)];</p>
</blockquote>

<p>So do this instead (where 100 is just a big enough number to hold the result):</p>

<blockquote>
  <p>char tmp[100];</p>
</blockquote>

<p>Next using a char for 'a' will not be able to hold the EOF value. Use int.</p>

<blockquote>
  <p>int a;</p>
</blockquote>

<p>By fixing the definition of 'a' your loop is now not infinite, but it will eventually write the constant EOF to the file, which will be some garbled character. Change it like so:</p>

<blockquote>
  <p>while ((a = fgetc(fp1)) != EOF) {
    fputc(a, fp2);
  }</p>
</blockquote>

<p>So in the end you should have:</p>

<pre><code>char tmp[100];

sprintf(tmp, ""custom-%ld.log"", (long int)lf-&gt;time);

FILE *fp1, *fp2;
int a;

fp1 = _log;

fp2 = fopen(tmp, ""a"");
if (fp2 != NULL) {
    while ((a = fgetc(fp1)) != EOF) {
        fputc(a, fp2);
    }

    fflush(fp1);
    fclose(fp2);
}

fflush(_log);
</code></pre>
",1
41684151,41684109,0,"<p>You are writing <code>EOF</code> to file <em>before</em> checking it with</p>

<pre><code>do {
    a = fgetc(fp1);
    fputc(a, fp2);
} while (a != EOF);
</code></pre>

<p>You could try</p>

<pre><code>int a;                          // make sure you have the correct type
while((a = fgetc(fp1)) != EOF)
    fputc(a, fp2);
}
</code></pre>

<p><code>EOF</code> is not (except some legacy formats) part of the file. It is an indicator returned by file reading functions.</p>

<p>Note that <code>fflush(fp1);</code> is undefined behaviour when <code>fp1</code> is opened for input.</p>

<p>You say <code>""custom-%ld.log""</code> does not already exist yet you open it with </p>

<pre><code>fp2 = fopen(tmp, ""a"");
</code></pre>

<p>Which would append, if you forgot to delete a previous version. To make sure it is a new file, open with </p>

<pre><code>fp2 = fopen(tmp, ""w"");
</code></pre>
",2
45091602,45091601,3,"<p><a href=""https://stackoverflow.com/questions/39290019/is-if-defined-macro-equivalent-to-ifdef-macro"">This SO answer on - Is #if defined MACRO equivalent to #ifdef MACRO?</a> explains it wonderfully.</p>

<p>Instead of using <code>#ifdef</code>, use <code>#if defined(...)</code>. Since <code>defined(...)</code> will evaluate to a 0 or 1, it'll behave as a normal <code>#if</code></p>

<p>Code would look like the following:</p>

<pre><code>#if defined(MACRO_1) &amp;&amp; defined(MACRO_2)
...
#endif
</code></pre>
",1
40983765,40983463,1,"<p>Rather than using the return value of <code>strtok</code> immediately, save it in a pointer and test it first.</p>

<p>From the man page:</p>

<blockquote>
  <p>The <code>strtok()</code> and <code>strtok_r()</code> functions return  a  pointer  to  the 
  next
         token, or <code>NULL</code> if there are no more tokens.</p>
</blockquote>

<p>So when <code>strtok</code> returns NULL, you know you're at the end of the string.</p>

<pre><code>char* myStr = ""a,b,c"", *p;
char item_a[2];
char item_b[2];
char item_c[2];
p = strtok( myStr, "","");
if (p) {
    strcpy(item_a, p);
    p = strtok( NULL, "","");
    if (p) {
        strcpy(item_b, p);
        p = strtok( NULL, "","");
        if (p) {
            strcpy(item_c, p);
        }
    }
}
</code></pre>

<p>Also, make sure you have enough space in your destination string for each token.  The reason you got a segfault is because your arrays weren't big enough.  You need enough for the length of the string plus one more for the null byte which terminates the string.</p>
",5
40984168,40983463,0,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

int main(void) {
    char *myStr = ""a,b,c"";//unknown size string.
    size_t len = strlen(myStr);//check size
    char *copyStr = malloc(len + 1);
    strcpy(copyStr, myStr);

    char *items = malloc((len+1)/ 2);
    size_t n = 0;

    char *itemp = strtok(copyStr, "","");
    while(itemp != NULL){
        items[n++] = *itemp;
        itemp = strtok(NULL, "","");
    }
    //check print
    for(size_t i = 0; i &lt; n; ++i){
        printf(""%c\n"", items[i]);
    }
    free(copyStr);
    free(items);
    return 0;
}
</code></pre>
",0
36358700,35047816,0,"<p>At the link you provided they say</p>

<blockquote>
  <p>The <em>uc_link</em> member is used to determine the context that shall be
  resumed when the context being modified by <em>makecontext</em>() returns.</p>
</blockquote>

<p>Since your program doesn't resume (execute) any context <strong>modified by <em>makecontext</em>()</strong>, the above does not apply and the program ends without resuming any context.</p>

<p>To achieve what you want, you have to define some function like</p>

<pre><code>    void main_context()
    {
        // do everything you yet wanted to do in main()
        puts(""finished main"");
    }
</code></pre>

<p>and replace the</p>

<pre><code>    return 0;
</code></pre>

<p>with</p>

<pre><code>    char st0[8192];
    ctx[0].uc_stack.ss_sp = st0;
    ctx[0].uc_stack.ss_size = sizeof st0;
    makecontext(&amp;ctx[0], main_context, 0);
    return -setcontext(&amp;ctx[0]);
</code></pre>
",0
44702949,44702645,1,"<p>Most compilers will do constant propagation. You need to turn up the optimisation level high. The only way to be sure however is to examine the assembly code, or to explicitly write the code out with the constants folded in, which is ugly and hard to maintain. C++ allows you to specify a scalar as a template.</p>
",0
44703659,44702645,3,"<p>You may use a define like:</p>

<pre><code>#define F(i,n)  void func_##i() { printf(""%d\n"",n); }

#include &lt;stdio.h&gt;

F(1,641)
F(2,31)
...

int main() {
    func_1();
    func_2();
}
</code></pre>

<p>It is possible to obtain the same effect from a list of constant but it is much much more tricky. See <a href=""https://stackoverflow.com/questions/12447557/can-we-have-recursive-macros"">recursive macro</a>.</p>
",0
48022857,48022809,5,"<pre><code>A[i][j][k] == (int*)malloc(sizeof(int)*P);
</code></pre>

<p>And then you try to access it</p>

<pre><code>if(!A[i][j][k])
</code></pre>

<p>Giving you segmentation fault.</p>

<p>This worked for <code>3</code> dimension? Nope. Maybe because you didn't have this loop then.</p>

<p>Correction will be </p>

<pre><code>A[i][j][k] = malloc(sizeof(int)*P);
</code></pre>

<p>You don't need that casting - it's redundant.</p>

<p>Also all these 4 mallocs can be much cleaner and hasslefree if you do this</p>

<pre><code>int ****A = malloc(sizeof *A * M);
</code></pre>

<p>and</p>

<pre><code>A[i] = malloc(sizeof *A[i] * N);
</code></pre>

<p>Also compile your code like this </p>

<pre><code>gcc -Wall -Werror progname.c
</code></pre>

<p>This will throw an warning making you aware of this equality - equal problem.</p>

<p>Illustration code:-</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define M 2
#define N 3
#define O 4
#define P 5

int main(void)
{
    int ****A = malloc(sizeof*A*M);


    if(!A)
    {
        perror("" *** Out of Memory"");
        exit(EXIT_FAILURE);
    }
    for(size_t i = 0; i &lt; M; i++)
    {
        A[i] = malloc(sizeof *A[i]*N);
        if(!A[i])
        {
            perror("" *** Out of Memory"");
            exit(EXIT_FAILURE);
        }
        for(size_t j = 0; j &lt; N; j++)
        {
            A[i][j] = malloc(sizeof(int*)*O);
            if(!A[i][j])
            {
                perror("" *** Out of Memory"");
                exit(EXIT_FAILURE);
            }
            for(size_t k = 0; k &lt; O; k++)
            {
                A[i][j][k] = malloc(sizeof *A[i][j][k]*P);
                if(!A[i][j][k])
                {
                    perror("" *** Out of Memory"");
                    exit(EXIT_FAILURE);
                }
                printf(""Allocation: A[i][j][k] at %p, A[i][j]: %p, A[i]: %p, A: %p\n"", (void*)A[i][j][k], (void*)A[i][j], (void*)A[i], (void*)A);
            }
        }
    }
    return 0;
}
</code></pre>
",5
46638182,15102992,11,"<p>From <strong><code>/usr/include/stdio.h</code></strong>,</p>

<pre><code>/* Standard streams.  */
extern struct _IO_FILE *stdin;          /* Standard input stream.  */
extern struct _IO_FILE *stdout;         /* Standard output stream.  */
extern struct _IO_FILE *stderr;         /* Standard error output stream.  */
/* C89/C99 say they're macros.  Make them happy.  */
#define stdin stdin
#define stdout stdout
#define stderr stderr
</code></pre>

<p>From <strong><code>/usr/include/unistd.h</code></strong></p>

<pre><code>/* Standard file descriptors.  */
#define STDIN_FILENO    0       /* Standard input.  */
#define STDOUT_FILENO   1       /* Standard output.  */
#define STDERR_FILENO   2       /* Standard error output.  */
</code></pre>

<p>Ex, <code>stdin</code> (<strong><code>_IO_FILE</code></strong> defined in <code>/usr/include/libio.h</code>) is a structure data. <code>STDIN_FILENO</code> is a macro constant, which points to a file descriptor used by kernel.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

void
stdin_VS_STDIN_FILENO(void)
{
    printf(""stdin-&gt;_flags = %hd\n"", stdin-&gt;_flags);
    printf(""STDIN_FILENO  : %d\n"", STDIN_FILENO);
}

int
main(void)
{
    stdin_VS_STDIN_FILENO();
    return 0;
}
</code></pre>
",0
41910205,41907459,1,"<p>Simple to some, but not so for others...</p>

<p><code>stdin</code> is a default Input Stream and thus in code can be directly accessed by using the <code>stdin</code> variable. So when one see's, and I have on a few occasions now:</p>

<pre><code>FILE *fid;
fid = stdin;
</code></pre>

<p>The <code>stdin</code> stream has been redirected: ""Somewhere"" if this stream is not the default. Normally on most machines, the default is the Keyboard.</p>

<p>On line: 301 <code>fid = fopen(vocab_file,""r"");</code> the vocab file becomes the stream data source, which is returned by the <code>fopen</code> function. The file is read and processed.</p>

<p>On line: 304 the stream is closed: <code>fclose(fid);</code></p>

<p>On line: 329 <code>fid = stdin;</code> <code>stdin</code> is assigned as the input stream for <code>fid</code>.</p>

<p>From there, there is no sign of Stream Change, but there is assignment to <code>str</code>, this is from one of the text files, and the method: <code>get_word</code> assigns <code>str</code> from the corpora...</p>

<p>The command line input is the answer: <strong><em>-overflow-file tempoverflow &lt; corpus.txt > cooccurrences.bin</em></strong></p>

<pre><code>./cooccur -verbose 2 -symmetric 0 -window-size 10 -vocab-file vocab.txt -memory 8.0 -overflow-file tempoverflow &lt; corpus.txt &gt; cooccurrences.bin
</code></pre>

<p>Using : <a href=""http://www.cplusplus.com/reference/cstdio/stdin/"" rel=""nofollow noreferrer"">cplusplus.com</a></p>

<blockquote>
  <p>Standard input stream</p>
  
  <p>The standard input stream is the default source of data for
  applications. In most systems, it is usually directed by default to
  the keyboard.</p>
  
  <p>stdin can be used as an argument for any function that expects an
  input stream (FILE*) as one of its parameters, like fgets or fscanf.</p>
  
  <p>Although it is commonly assumed that the source of data for stdin is
  going to be a keyboard, this may not be the case even in regular
  console systems, since stdin can generally be redirected on most
  operating systems at the time of invoking the application. For
  example, many systems, among them DOS/Windows and most UNIX shells,
  support the following command syntax:</p>
  
  <p>myapplication &lt; example.txt </p>
  
  <p>to use the content of the file example.txt as the primary source of
  data for myapplication instead of the console keyboard.</p>
  
  <p>It is also possible to redirect stdin to some other source of data
  from within a program by using the freopen function.</p>
  
  <p>If stdin is known to not refer to an interactive device, the stream
  is fully buffered. Otherwise, it is library-dependent whether the
  stream is line buffered or not buffered by default (see setvbuf).</p>
</blockquote>

<p>So there you go, the <code>stdin</code> stream is redirected by the command line argument: <code>-overflow-file tempoverflow &lt; corpus.txt</code></p>

<p>As a result: <code>corpus.txt</code> is the redirected data source of the <code>stdin</code> Stream!</p>

<p>Also worth noting, <code>cooccurrences.bin</code> is the redirected data source of the <code>stdout</code> Stream - vial Line: 232 <code>fout = stdout;</code> and written to on line: 270 <code>fwrite(&amp;old, sizeof(CREC), 1, fout);</code></p>

<p>For more information on: ""<a href=""http://sc.tamu.edu/help/general/unix/redirection.html"" rel=""nofollow noreferrer"">Standard Input and Output Redirection</a>""</p>

<p>NOTE: If you want to run this code up, remember to set the Console App to 64 Bit - It wont allocate Memory other wise!</p>
",4
36223975,36223261,-1,"<p>NULL represent that the pointer isnt pointing to any address, NULL is a macro for (void *)0</p>

<p>so you can use (char *)0, it would still point to nothing and it'll be easier to explain the code</p>
",6
36224457,36223261,1,"<p>A <a href=""http://port70.net/~nsz/c/c11/n1570.html#6.3.2.3p3"" rel=""nofollow""><em>null pointer</em></a> is strictly speaking no valid address encoding:</p>

<blockquote>
  <p>An integer constant expression with the value 0, or such an expression cast to type void *, is called a null pointer constant.66) If a null pointer constant is converted to a pointer type, the resulting pointer, called a null pointer, is guaranteed to compare unequal to a pointer to any object or function.</p>
</blockquote>

<p>Thus I try to avoid the phrase ""address 0"" when it comes to <em>null pointers</em>, because this is the encoding and a null pointer need not have all bits zero. An architecture could - for instance - use an unused bit in the pointer variables to tag it as invalid. For comparision e.g. bitops would be used instead of compare.</p>

<p>The most common encoding is ""all bits zero"", though so I will mostly  concentrate on this. This encoding is used because most CPUs have special (and shorter/faster) instructions to store a bit value of <code>0x0</code> into a memory cell and compare with/test for <code>0x0</code>. Using a special bitpattern also makes comparing two pointers straight forward, using a single compare. The version with setting a dedicated bit would require additional instructions.</p>

<p>Also a value which is at the edge of the address range avoids gaps. This is true for ""all bits 1"", too, but with less CPU support and address-width dependency.</p>

<hr>

<p>Note that most architectures very well do have a valid <strong>physical</strong> address <code>0</code>, so there is in fact a problem with this encoding for a <em>null pointer</em> without address translation. Luckily this is typically a special address and not used by normal application code. With virtual memory addressing, it is quite easy just to make address <code>0x0</code> invalid, so this is out of discussion.</p>

<p>On some systems, address <code>0x0</code> is used for code (PC-boot code/BIOS, embedded systems) or data-accesses (RAM/peripheral hardware registers). Strictly speaking you cannot convert the <em>integer-constant</em> <code>0</code> to a pointer without invoking the implicit conversion to a null pointer. So, if your system does not use the <code>0x0</code> encoding, there is a problem accessing address <code>0x0</code> with standard C syntax only. (FYI: this is one reason other languages use a special keyword for a <em>null pointer constant</em>, e.g pascal <code>NIL</code>, Python <code>None</code>, C++ <code>nullptr</code>.)</p>

<p>The conversion of an integer to a pointer is implementation defined anyway, as is the <em>null pointer</em> encoding. Thus the conversion of a <code>0</code> to a pointer is well in-line with the common copy-only integer->pointer encoding without modification of the representation.</p>

<p>A problem arises when dereferencing such a pointer. Dereferencing a <em>null pointer</em> is undefined behaviour (UB). As both encodings are identical, there is no way for the CPU to detect if this is a valid access or a <em>null pointer</em> dereferencing. Even worse: the compiler is free to exploit this UB and generate arbitrary code (or none at all) if it detects something like <code>char c = *((char *)0);</code>.</p>

<p>For a true variable (i.e. not <code>const</code> qualified) pointer, this is normally not much of a problem, as that would require dynamic code analysis and in C no code for runtime-checks is generated by the compiler, but for the constant expression above, it <strong>could</strong> very well cause problems.</p>
",0
36225104,36223261,0,"<p>Short answer: Whether you say</p>

<pre><code>char *p1 = NULL;
</code></pre>

<p>or</p>

<pre><code>char *p2 = (char *)0;
</code></pre>

<p>or</p>

<pre><code>char *p3 = 0;
</code></pre>

<p>they are all pretty much equivalent.  They're all legal, they'll all work, they'll all initialize the pointer variables to null pointer values.  The differences between them have to do with style, not correctness.</p>

<p>Whoever wrote the code you saw may just have had a different notion about what constitutes good style.</p>

<p>(Now, if you're dealing with pointers of type other than <code>char *</code>, using <code>(char *)0</code> would be poor, and should at least generate warnings, and under suitably obscure circumstances might actually cause problems.)</p>
",0
36223512,36223261,0,"<p>A null pointer is a special pointer value that is known not to point anywhere. What this means that no other valid pointer, to any other variable or array cell or anything else, will ever compare equal to a null pointer.</p>

<p>The most straightforward way to get a null pointer in your program is by using the predefined constant NULL, which is defined for you by several standard header files, including , , and . To initialize a pointer to a null pointer, you might use code like</p>

<pre><code>#include &lt;stdio.h&gt;

int *ip = NULL;
</code></pre>

<p>and to test it for a null pointer before inspecting the value pointed to you might use code like</p>

<pre><code>if(ip != NULL)
    printf(""%d\n"", *ip);
</code></pre>

<p>It is also possible to refer to the null pointer by using a constant 0, and you will see some code that sets null pointers by simply doing</p>

<pre><code>char *ip = 0;
</code></pre>
",1
45729917,45729828,0,"<p>You're converting to a 32-bit floating point which may not have the precision to handle that many digits.</p>
",1
42474928,13900854,0,"<p>I'll state my case of which I am still uncertain: I thought my problem was with ""fopen"", but after trying every single solution, I ran into the extension problem, which I'm facing in Windows 10. It appears that Windows puts "".txt"" automatically but, if you put "".txt"" as extension, the name becomes "".txt.txt"" at the end. So I left the file name with no extension, and put ""file.txt"" as argument of ""fopen"", and that was the only way it has worked for me. </p>
",0
36222367,36222315,4,"<p><code>-&gt;</code> has a higher precedence than that of <code>*</code>(indirection), so</p>

<pre><code>*param -&gt; a = 6;
</code></pre>

<p>should be</p>

<pre><code>(*param)-&gt;a = 6;
</code></pre>
",0
36222375,36222315,4,"<p>The arrow <code>-&gt;</code> operator binds more tightly than the <code>*</code> does.  You need:</p>

<pre><code>(*param)-&gt;a = 6;
</code></pre>

<p>Don't put spaces around <code>-&gt;</code> or <code>.</code>; they bind very tightly.  Spaces mark you as a neophyte.</p>
",0
46953002,9732672,1,"<p>You can get the first 2 digits of any number by using the flowing :</p>

<p><code>INT(X*10^(-INT(LOG(X))+1))</code></p>

<p>for Example :</p>

<ul>
<li><p><code>X = 0.005432</code> then <code>Log(X) = -2.265</code> and <code>Int(Log(x)) = -3</code>  . So, <code>10^(-int(log(x))+1) = 10^4 = 10000</code>. Finally , <code>int(X * 10000 ) = 54</code> which are the first 2 digits.</p></li>
<li><p><code>X = 3.45</code> then <code>Log(X) =0.53</code> and <code>Int(Log(x)) = 0 So, 10^(-int(log(x))+1) = 10^1 = 10</code>. Finally, <code>int(X * 10 ) = 34</code> which are the first 2 digits.</p></li>
<li><p><code>X = 3543.45</code>then <code>Log(X) =3.459</code> and <code>Int(Log(x)) = 3</code>  So, <code>10^(-int(log(x))+1) = 10^-2 = 0.01</code>. Finally , <code>int(X * 10 ) = 35</code> which are the first 2 digits.</p></li>
</ul>
",0
34935667,34931430,-1,"<p>The reason your function fails is you do not break from the loop once you find a match.  So the replacement can take place twice, effectively cancelling itself.</p>

<p>You can fix and simplify the function this way:</p>

<pre><code>char *useless_device(const char *device) {
    int i;
    const char *useless[] = { ""dsnoop"", ""hw"" };

    for (i = 0; i &lt; ARRAY_SIZE(useless); i++) {
        int len = strlen(useless[i]);
        if (strncmp(device, useless[i], len) == 0 &amp;&amp;
            (!device[len] || device[len] == ':')) {
            return g_strconcat(useless[i ^ 1], device + len, NULL);
        }
    }
    return NULL;
}
</code></pre>

<p>This would also work with an array with multiple pairs of names to swap.</p>
",0
37832905,37831498,-2,"<p>according to this link 
<a href=""https://stackoverflow.com/questions/19209141/how-do-i-execute-a-shell-built-in-command-with-a-c-function"">How do I execute a Shell built-in command with a C function?</a></p>

<p>use execl(""sh"", ""sh"", ""-c"", command, NULL) instead of system</p>
",0
37835413,37831498,0,"<p>I can't reproduce your issue because your code does not compile. This is a working version of your program with annotations of changes (and with <code>testdir</code> replacing <code>/etc/config</code>):</p>

<pre><code>#include &lt;limits.h&gt; /* for PATH_MAX and LINE_MAX */
#include &lt;stdio.h&gt;  /* header include was missing */
#include &lt;stdlib.h&gt; /* header include was missing */
#include &lt;time.h&gt;   /* header include was missing */

#include &lt;dirent.h&gt;   /* header include was missing */
#include &lt;sys/stat.h&gt; /* header include was missing */

int check_file_dir(char *name)
{
    int i = 0;
    char command[LINE_MAX];  /* standard max command line length */
    /* path was wrong below */
    sprintf(command, ""ls %s &amp;&gt; /dev/null"", name);
    printf(""====&gt; command =%s \n"", command);
    i = system(command);
    return i;
}

void get_file_info()
{
    char name[PATH_MAX]; /* standard max path length */
    struct dirent *d_file;
    struct stat attr;
    char path[PATH_MAX]; /* standard max path length */
    char s_now[sizeof ""AAAA-MM-JJTHH:MM:SS.000Z""];
    DIR *dir;            /* declaration was missing */
    int FILE_NUMBER = 0; /* declaration was missing */

    if ((dir = opendir(""testdir"")) == NULL)
        return; /* no point to go on */

    while ((d_file = readdir(dir)) != NULL) {
        if (d_file-&gt;d_name[0] == '.')
            continue;
        sprintf(path, ""testdir/%s"", d_file-&gt;d_name);
        stat(path, &amp;attr);
        strftime(s_now, sizeof s_now, ""%Y-%m-%dT%H:%M:%S.000Z"",
                 localtime(&amp;attr.st_mtime)); /* not used? */
        ++FILE_NUMBER; /* assuming this is what you meant to do */
    }
    closedir(dir); /* was called even if !opendir() */

    int j;
    for (j = 0; j &lt; FILE_NUMBER; j++) {
        sprintf(name, ""testdir/file%d"", j);
        if (check_file_dir(name) != 0)
            printf(""file doesn't exist \n"");
    }
}

int main(void) /* int and (void) */
{
    get_file_info();
    get_file_info();
    return 0; /* was missing */
}
</code></pre>
",0
34918312,34918274,2,"<p>You are reading uninitialized pointer(s) which is <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow""><em>undefined behaviour</em></a>.</p>

<p>You only have <code>i</code> number of strings <em>after</em> the loop, <em>not</em> <code>NUMBER_OF_STRINGS</code> strings.</p>

<p>You can store the total number of strings in another variable after the loop and use it when you print it.</p>

<pre><code> for (char *p = strtok(str,"" ""); p != NULL; p = strtok(NULL, "" ""))
    {
    ....
    }

   size_t num = i;

    for(i = 0 ; i &lt; num ; i++){
        if(strs[i] != NULL)
            printf(""%s\n"",strs[i]);
    }
</code></pre>
",0
34918352,34918274,1,"<p>Change</p>

<pre><code>for(i = 0 ; i &lt; NUMBER_OF_STRINGS ; i++){
    if(strs[i] != NULL)
        printf(""%s\n"",strs[i]);
}
</code></pre>

<p>to</p>

<pre><code>int j;
for(j = 0 ; j &lt; i ; j++){
        printf(""%s\n"",strs[j]);
}
</code></pre>

<p>In your code you are always read all values of array of pointer, but some positions are not inited. That is <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow"">UB</a>.</p>

<p>Another solution could be to add </p>

<pre><code>memset(strs, 0, NUMBER_OF_STRINGS);
</code></pre>

<p>after array declaration to init the whole array to <code>NULL</code>. In this case you could leave the final loop as you coded it.</p>
",0
34967280,34967147,4,"<p>One other way without ""losing"" size_t (size_t <em>is</em> the correct type for array indexes) is to return the index value in the pointer and <em>return code</em> as a boolean:</p>

<pre><code>    bool 
    lin_search(...., size_t *index) {
        bool found = false;

        for (size_t i = idxlow; i &lt; idxhigh; i++)  {
            if (pxa[i] &lt;= x &amp;&amp; pxa[i+1] &gt; x) {
               found = true;
               *index = i;
               break;
            }
        }

    return found;
}
</code></pre>

<p>and you can call:</p>

<pre><code>size_t index;

if ( lin_search(...., &amp;index) ) {
  /* use 'index' */
 }
</code></pre>

<p>This way, you don't have to compromise with using something other than <code>size_t</code> and the function return type still says whether the index is found.</p>
",3
34967214,34967147,1,"<p>Situations like this are not unheard of.  Take for example the definition of <code>fgetc</code>, which reads characters:</p>

<blockquote>
<pre><code>int fgetc(FILE *stream);
</code></pre>
  
  <p>fgetc() reads the next character from  stream  and  returns  it  as 
  an unsigned char cast to an int, or EOF on end of file or error.</p>
</blockquote>

<p>This function returns a value that can be cast to <code>unsigned char</code> on success, and it return <code>EOF</code> (typically -1) on failure.</p>

<p>Another example is <code>ftell</code>, which reports the current offset in a file:</p>

<blockquote>
<pre><code>long ftell(FILE *stream);
</code></pre>
  
  <p>Upon successful completion, ... ftell() returns the current
         offset.   Otherwise,  -1  is  returned and errno is set to indicate the
         error.</p>
</blockquote>

<p>File offsets are always non-negative, so returning a negative value is how errors are reported.</p>

<p>So I think changing the return type to <code>long</code> would be acceptable for a case like this.  </p>
",0
36350807,36350585,1,"<p>You need a converter function.</p>

<pre><code>/* Input: a Unicode code point, ""ucs2"". 

   Output: UTF-8 characters in buffer ""utf8"". 

   Return value: the number of bytes written into ""utf8"", or a
   negative number if there was an error.

   This adds a zero byte to the end of the string. It assumes that the
   buffer ""utf8"" has at least four bytes of space to write to. */

int ucs2_to_utf8 (int ucs2, unsigned char * utf8)
{
    if (ucs2 &lt; 0x80) {
        utf8[0] = ucs2;
        utf8[1] = '\0';
        return 1;
    }
    if (ucs2 &gt;= 0x80  &amp;&amp; ucs2 &lt; 0x800) {
        utf8[0] = (ucs2 &gt;&gt; 6)   | 0xC0;
        utf8[1] = (ucs2 &amp; 0x3F) | 0x80;
        utf8[2] = '\0';
        return 2;
    }
    if (ucs2 &gt;= 0x800 &amp;&amp; ucs2 &lt; 0xFFFF) {
    if (ucs2 &gt;= 0xD800 &amp;&amp; ucs2 &lt;= 0xDFFF) {
        /* Ill-formed. */
        return UNICODE_SURROGATE_PAIR;
    }
        utf8[0] = ((ucs2 &gt;&gt; 12)       ) | 0xE0;
        utf8[1] = ((ucs2 &gt;&gt; 6 ) &amp; 0x3F) | 0x80;
        utf8[2] = ((ucs2      ) &amp; 0x3F) | 0x80;
        utf8[3] = '\0';
        return 3;
    }
    if (ucs2 &gt;= 0x10000 &amp;&amp; ucs2 &lt; 0x10FFFF) {
    /* http://tidy.sourceforge.net/cgi-bin/lxr/source/src/utf8.c#L380 */
    utf8[0] = 0xF0 | (ucs2 &gt;&gt; 18);
    utf8[1] = 0x80 | ((ucs2 &gt;&gt; 12) &amp; 0x3F);
    utf8[2] = 0x80 | ((ucs2 &gt;&gt; 6) &amp; 0x3F);
    utf8[3] = 0x80 | ((ucs2 &amp; 0x3F));
        utf8[4] = '\0';
        return 4;
    }
    return UNICODE_BAD_INPUT;
}
</code></pre>

<p><a href=""http://www.lemoda.net/c/ucs2-to-utf8/"" rel=""nofollow"">Refer to this page</a></p>
",0
37912625,37912580,2,"<p>This is a predefined macro in gcc (a GNU C extension); see <a href=""https://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html"" rel=""nofollow"">https://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html</a>.</p>

<p>As for why this is legal: The standard reserves all names starting with two underscores (and all names starting with an underscore followed by an uppercase letter) for use by the implementation, so gcc could predefine <code>__whatever</code> and still follow the standard.</p>
",6
47531901,14901919,0,"<p>The following seems a little tricky:</p>

<pre><code>if (...)

        printf(""I'm conditional\n"");
</code></pre>

<p>I guess the C preprocessor takes care of empty lines, so this statement is fine. Very bad practice of course.</p>
",1
38615210,38615106,0,"<pre><code>s2 = *(extended*)&amp;s1;
</code></pre>

<p>This has undefined behaviour, the object at <code>&amp;s1</code> is not of the correct type to be accessed through a pointer of type <code>extended*</code>.</p>

<pre><code>memcpy(&amp;s3, &amp;s1, sizeof(s3));
</code></pre>

<p>This also has undefined behaviour, because you read <code>sizeof(extended)</code> bytes from an object that is only <code>sizeof(base)</code> bytes long.</p>

<p>If you think about it, it obviously won't work as you expect. When you copy an <code>extended</code> structure the compiler reads three words (i.e. <code>sizeof(extended)</code>) from the source, and copies those three words to the destination. It doesn't copy less than three words and leave the last word unchanged. You told it to read <code>sizeof(extended)</code> bytes from the address <code>&amp;s1</code> so that's exactly what it does. And the last member gets set to a garbage value, because you read it from a memory location that isn't part of <code>s1</code> and contains some garbage value.</p>

<p>Why do you expect the compiler to copy <code>sizeof(base)</code> bytes if you tell it to copy <code>sizeof(extended)</code> bytes? If you don't want it to copy more bytes then don't tell it to copy more bytes!</p>
",2
38615607,38615106,0,"<p>when you copy from one memory location to another using pointer casts you are basically 'taking matters into your own hands'</p>

<p>These statements:</p>

<pre><code>s2 = *(extended*)&amp;s1;
s1 = *(base*)&amp;s2;
</code></pre>

<p>Are equivalent to these:</p>

<pre><code>memcpy(&amp;s2, &amp;s1, sizeof(extended));
memcpy(&amp;s1, &amp;s2, sizeof(base));
</code></pre>

<p>I think it is clear why copying from <strong>base* source</strong> to <strong>extended* dest</strong> will overwrite only part of the data and the other way around can have disastrous consequences (you have an out of bounds memory access and might overwrite important data).</p>
",0
47462004,47461925,1,"<p>You already found out what's wrong with your solution. The idea you present is bad, what if the string contains something like <code>01</code>? This is two characters, but still smaller than 10.</p>

<p>There are several possibilities to do better, I can think of two approaches immediately:</p>

<ul>
<li><p>instead of <code>atoi()</code>, use <code>strtol()</code> (you should anyways). <code>strtol()</code> has a parameter <code>endptr</code> -- pass it the address of a <code>char *</code> pointer, then this pointer will point to the first character that <em>wasn't</em> converted. To use this, you must probably rewrite your loop to use pointers. Here's an example:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;

char str[512] = ""2 15 42 7 11"";

int main(void)
{
    for (const char *c = str; *c;)
    {
        if (!isspace(*c))
        {
            char *endptr;
            long num = strtol(c, &amp;endptr, 10);
            if (endptr == c) exit(1);   // nothing was converted, just error out here
            printf(""%ld\n"", num);
            c = endptr;
        }
        else
        {
            ++c;
        }
    }
}
</code></pre></li>
<li><p>Even simpler, if it doesn't matter to destroy your input string in the course, use <code>strtok()</code> (see <a href=""https://linux.die.net/man/3/strtok"" rel=""nofollow noreferrer"">the manpage</a> for how it works) to <em>split</em> your strings at the whitespace, like <code>strtok(str, "" \t\n"")</code> in the first iteration and <code>strtok(0, "" \t\n"")</code> in the subsequent iterations. Then you can just convert the parts you get from <code>strtok()</code>.</p></li>
</ul>
",4
40960644,40960584,1,"<p>You are using the typedef while defining the type. At the place you use the type alias, the compiler don't know it so replace with:</p>

<pre><code>struct SENSOR_CLASS *this;
</code></pre>

<p>or you can make a forward declaration of your type, like:</p>

<pre><code>typedef struct SENSOR_CLASS SENSOR_OBJECT;

struct SENSOR_CLASS {
    SENSOR_OBJECT *this;
};
</code></pre>
",1
40960717,40960584,2,"<p>You have a mention of <code>SENSOR_OBJECT</code> before <code>SENSOR_OBJECT</code> is actually defined:</p>

<pre><code>   void (*configure_time_base)(alt_u32, SENSOR_OBJECT*); // &lt;--- mentioned here
   SENSOR_OBJECT* this;                                  // &lt;--- mentioned here
}SENSOR_OBJECT;                                          // &lt;--- defined here
</code></pre>

<p>This is not allowed.</p>

<p>The easiest way out is to separate the typedef and the struct definition:</p>

<pre><code>typedef struct SENSOR_CLASS SENSOR_OBJECT;
struct SENSOR_CLASS { ...
</code></pre>

<p>The <code>Initializer element is not constant</code> error tells you you cannot initialize a field with a thing which is not a constant expression. In order to fix this, write a function that allocates a <code>SENSOR_OBJECT</code> and assigns (<em>not</em> initializes) its fields from the function parameters. This would be your implementation of a <em>constructor</em>.</p>

<p>On a tangentially related note, it doesn't make much sense to keep a <code>this</code> pointer in each object. In order to access <code>this</code>, you would have to know the address of the object, but that address always equals <code>this</code>.</p>

<p>On a less related note, keeping function pointers in the struct is somewhat a waste of memory. Consider keeping them in a separate <code>vtable</code> object (one per class) and having a pointer to that <code>vtable</code> in each instance of the class.</p>
",0
38196329,38196030,2,"<p>Of course there are alternatives. First of all the body of the macro is not that huge. Compare:</p>

<pre><code>x=y=++z;
</code></pre>

<p>with </p>

<pre><code>bulk_updater;
</code></pre>

<p>The macro doesn't even save your precious fingers or disk space. Whether the former or latter is more readable is up to you (personally I prefer the former as it's clear what the statement does and it is more compact).</p>

<p>You could also create a function that does what you want, but then you would have to send parameters to do it:</p>

<pre><code>void bulk_updater(int* x, int* y, int *z) {
    *x = *y = ++*z;
}

...

bulk_updater(&amp;x, &amp;y, &amp;z);
</code></pre>

<p>This even more doesn't save your fingers or disk space. As always, which is better is a matter of opinion.</p>

<p>A more compact version of the function can be achieved by putting <code>x</code>, <code>y</code> and <code>z</code> in a struct:</p>

<pre><code>struct xyz {
    int x;
    int y;
    int z;
};

void bulk_update(struct xyz* p)
{
    p-&gt;x = p-&gt;y = ++p-&gt;z;
}

...

struct xyz xyz;

bulk_update(&amp;xyz);    
</code></pre>

<p>Even though it may seem clumsy, it may be justifiable if you have more meaningful operations on the <code>xyz</code> triple.</p>

<p>By the way it's normally recommended that you use upper case for macro names (so that one knows it's a macro). And if you want it to work as a statement you should use <code>do { ... } while(0)</code> instead, that way it will only be valid with a semi-colon after and a semi-colon after will not make it two statements (as your solution does):</p>

<pre><code>#define BULK_UPDATER do { x=y=++z; } while(0)
</code></pre>
",0
38200005,38196030,1,"<p>Let say you want to use a function to do the update, but you do not want the runtime overhead that a function introduces(since you are doing a small operation inside the function)</p>

<p>So use <a href=""https://stackoverflow.com/questions/3215171/function-like-macro-definition-in-c"">macro functions</a>. For this case,</p>

<pre><code>#include&lt;stdio.h&gt;

#define BULK_UPDATER(a,b,c) a = b = ++c
int main(void)
{
  int x,y,z; //defined
  x=y=z=100;
  BULK_UPDATER(x,y,z);
  printf(""x : %d y : %d z : %d\n"",x,y,z);

  BULK_UPDATER(x,y,z);
  printf(""x : %d y : %d z : %d\n"",x,y,z);

  int x1,y1,z1 = 45;
  BULK_UPDATER(x1,y1,z1);
  printf(""x1 : %d y1 : %d z1 : %d\n"",x1,y1,z1);
return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>x : 101 y : 101 z : 101
x : 102 y : 102 z : 102
x : 46 y : 46 z : 46
</code></pre>
",0
40778465,40777741,0,"<p>The complete spiel for the example (from ISO/IEC 9899:2011) is:</p>

<blockquote>
  <p>EXAMPLE 3 The following obscure constructions</p>

<pre><code>typedef signed int t;
typedef int plain;
struct tag {
    unsigned t:4;
    const t:5;
    plain r:5;
};
</code></pre>
  
  <p>declare a typedef name <code>t</code> with type <code>signed int</code>, a typedef name <code>plain</code> with type <code>int</code>, and a structure
  with three bit-field members, one named <code>t</code> that contains values in the range [0, 15], an unnamed const-qualified
  bit-field which (if it could be accessed) would contain values in either the range [?15, +15] or
  [?16, +15], and one named <code>r</code> that contains values in one of the ranges [0, 31], [?15, +15], or [?16, +15].
  (The choice of range is implementation-defined.) The first two bit-field declarations differ in that
  <code>unsigned</code> is a type specifier (which forces <code>t</code> to be the name of a structure member), while <code>const</code> is a
  type qualifier (which modifies <code>t</code> which is still visible as a typedef name). If these declarations are followed
  in an inner scope by</p>

<pre><code>t f(t (t));
long t;
</code></pre>
  
  <p>then a function <code>f</code> is declared with type ¡®¡®function returning <code>signed int</code> with one unnamed parameter
  with type pointer to function returning <code>signed int</code> with one unnamed parameter with type <code>signed int</code>¡¯¡¯, and an identifier <code>t</code> with type <code>long int</code>.</p>
</blockquote>

<p>Note that the field identified by <code>const t:5;</code> is anonymous and therefore cannot be accessed (the standard mentions that with the 'if it could be accessed' comment, and the statement that it is an 'unnamed const-qualified bit-field').  The field named <code>t</code> is not const-qualified; it can be modified.</p>

<p>And the <code>const</code> field is part of the structure <code>struct tag</code> and does not affect anything outside that structure type.</p>

<p>Both your example programs should compile ¡ª it is just as well that GCC and Clang do compile them.</p>

<p>Note, too, that the example is marked 'obscure constructions'.  Anyone actually writing code like that for production should be ¡­ shunned until they repent of their evil ways.</p>
",3
37761572,37761516,4,"<p>You never enter to the loop because of results is 0</p>

<pre><code> while((br1 &gt; 0) &amp;&amp; (br2 &gt; 0) &amp;&amp; results)
</code></pre>
",4
38195845,18497845,-1,"<p>I where doing this for a while and i realize, you can see the exe image in a process, use a debuger, the code is all right, but i cant for the moment to pass this machine code to assembler, but well, with a pointer all is possible   </p>

<pre><code>include stdio.h

include windows.h

int main ()

{

int i=0;

char * p = (char *)0x400000;

for(int i = 0; i &lt; 20; i++)

{

    printf(""%p %02x \n"",p+i, (unsigned int)(unsigned char)*(p+i));
}

}
</code></pre>
",1
36255438,36255057,2,"<p>For this type of replacement (where the length of the string to replace and the string to replace it with are different lengths), you will generally want to read from one file, and write the altered data to a different file.</p>

<p>You can read the file in line-by-line, and then use <a href=""http://pubs.opengroup.org/onlinepubs/7908799/xsh/fscanf.html"" rel=""nofollow""><code>sscanf()</code></a> to determine whether the line needs replacing.</p>

<p>For example:</p>

<pre><code>#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

int main()
{
    FILE *input = fopen(""in.txt"", ""r"");
    FILE *output = fopen(""out.txt"", ""w"");

    char target[] = ""C45"";
    char replacement[] = ""X4534"";
    char lineBuffer[100];

    while (fgets(lineBuffer, sizeof lineBuffer, input) != NULL)
    {
        char procedure[10];

        if (sscanf(lineBuffer, ""The procedure at %9s"", procedure) == 1)
        {
            if (strcmp(procedure, target) == 0)
            {
                // if we get here, then the line matched the format we're
                // looking for and we can therefore write our replacement
                // line instead.
                fprintf(output, ""The procedure at %s is incomplete\n"", replacement);
                continue;
            }
        }

        // if we get to this point, then the line didn't match the format
        // or the procedure didn't match the one we're looking for, so we
        // just output the line as it is.
        fputs(lineBuffer, output);
    }

    fclose(input);
    fclose(output);
}
</code></pre>

<p>The code above should give you some idea of what's involved. Once you have <code>out.txt</code> saved, you can move it over the top of <code>in.txt</code> using the standard C function <a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/rename.html"" rel=""nofollow""><code>rename()</code></a>, e.g.:</p>

<pre><code>rename(""out.txt"", ""in.txt"");
</code></pre>
",2
36558382,36558324,1,"<p>TL;DR</p>

<p>The <code>sizeof</code> isn't doing what you're expecting. Try using <code>strlen</code> instead.</p>

<hr>

<p>You're only getting 4 characters copied because <code>sizeof(char*[N])</code> for any <em>N</em> is just going to be the size of a pointer. On your platform, a pointer must be 4 bytes (32 bits).</p>

<p>I think you actually mean to pass the base-address of the array into the function, but in that case your types aren't quite right. Your compiler should be warning you about this. You should remove the <code>*</code> from your last 2 argument types:</p>

<pre><code>static void func1(int argc, char *argv[], char UserID[30], char Psw[30])
</code></pre>

<p>That should get rid of the warning, and it should actually make <code>sizeof</code> behave correctly as well (since <code>sizeof(char[30])</code> is 30). However, it's very easy to make mistakes with <code>sizeof</code> since the behavior with a <code>char*</code> and <code>char[]</code> are different... I'd prefer using <code>strlen</code> (or <code>strnlen</code> if you want to avoid possible buffer overflows) here instead, which will simply tell you how many non-null characters you have.</p>

<p>Using <code>strnlen</code> rather than <code>sizeof</code> would also help to tip you off that your parameter types are wrong, since it will complain that you're trying to pass a <code>char**</code> to a function that expects a <code>char*</code>.</p>
",2
36558447,36558324,3,"<p>I guess your pointer has a size of 4 Byte. therefore you only read 4 chars. </p>
",0
36558542,36558324,-1,"<p>Solution</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
void func1(int argc, char *argv[], char *UserID, char *Psw)
{
   strncpy(UserID, argv[1], strlen(argv[1]));
   strncpy(Psw, argv[2], strlen(argv[2]));
printf(""DATA: %s \n"",UserID);
printf(""DATA1: %s \n"",Psw);
}

int main(int argc, char *argv[])
{
   char UserID[30];
   char Psw[30];
        printf(""argv1 %ld \n"",strlen(argv[1]));
        printf(""argv2 %ld \n"",strlen(argv[2]));
   func1(argc, argv, UserID, Psw);
}
</code></pre>
",2
36558732,36558324,1,"<p>Pass the array size to the function</p>

<pre><code>static void func1(int argc, char *argv[], char *UserID, size_t UserIDSize, 
    char *Psw, size_t PswSize)
{
   if (argc&gt; 1) strncpy(UserID, argv[1], UserIDSize);  
   if (argc&gt; 2) strncpy(Psw, argv[2], PswSize);  
} 

int main(int argc, char *argv[])
{
   char UserID[30] = {0};     
   char Psw[30] = {0};
   func1(argc, argv, UserID, sizeof UserID, Psw, sizeof Psw);
}
</code></pre>

<p>To insure the destination arrays are null character terminated, suggest <code>strncat()</code> --> ""A terminating null character is always appended to the result.""  <code>strncpy()</code> has too many problems, it does not always result in an array with a null character.</p>

<pre><code>static void func1(int argc, char *argv[], char *UserID, size_t UserIDSize, 
    char *Psw, size_t PswSize) {
   UserId[0] = '\0';
   // if (argc&gt; 1) strncat(UserID, argv[1], UserIDSize);  
   if (argc&gt; 1) strncat(UserID, argv[1], UserIDSize - 1);  
   Psw[0] = '\0';
   // if (argc&gt; 2) strncat(Psw, argv[2], PswSize);  
   if (argc&gt; 2) strncat(Psw, argv[2], PswSize - 1);  
} 
</code></pre>

<p>[Edit]</p>

<p>Corrected code - off by 1</p>
",0
37155429,37155089,3,"<p>Reading of such constructs is much easier if you replace parts of the declaration that can be replaced, with a substitute name. Let's say <code>f</code> is <code>table()</code>, which is a function taking unspecified number of arguments, and <code>t</code> is the type <code>int*</code>. </p>

<p>Then the declaration becomes:</p>

<pre><code>t(*f)[30];
</code></pre>

<p>which is obviously a pointer to an array of 30 elements of <code>t</code>.</p>

<p>Replace <code>f</code>, and we get a function taking unspecified number of arguments, and returning a pointer to an array of 30 elements of t:</p>

<pre><code>t(*table())[30];
</code></pre>

<p>Replace <code>t</code> and we get a function taking unspecified number of arguments, and returning a pointer to an array of 30 elements of pointer to int:</p>

<pre><code>int*(*table())[30];
</code></pre>
",0
37155436,37155089,5,"<p>You can decode this from the inside out:</p>

<pre><code>int *(*table())[30];
</code></pre>

<p>The innermost binding is<code>table()</code>, which is a function with unspecified arguments.  The next level is <code>*table()</code>, so <code>table</code> is returning a pointer to something.  The next level is <code>(*table())[30]</code>, so it's returning a pointer to a 30-length array of something.  The next level is <code>*(table())[30]</code>, so it's returning a pointer to a 30-length array of pointers to something.  The final level adds the type specifier, <code>int *(*table())[30]</code>.</p>

<p>So <code>table</code> is a function (with unspecified arguments) that returns a pointer to a 30-length array of pointers to <code>int</code>.</p>
",2
37155878,37155089,0,"<p>Above declaration can be understood by the <strong>Clockwise/Spiral</strong> rule.  </p>

<p><a href=""https://i.stack.imgur.com/gIJg1.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/gIJg1.jpg"" alt=""enter image description here""></a></p>

<p>Following describes how to parse the declaration using the rule:</p>

<blockquote>
  <p>1) <strong><em>table</em></strong> is a function with unspecified arguments.</p>
  
  <p>2) The <strong><em>table()</em></strong> function returns a <strong>pointer</strong>.</p>
  
  <p>3) The <strong>pointer</strong> returned by <em>table()</em> function points to an array of <strong>30</strong> elements.</p>
  
  <p>4) Each element is of type <strong><em>integer pointers</em></strong> i.e., each element is pointing to an integer.</p>
</blockquote>

<p>More about the rule is well explained in this link : <a href=""http://c-faq.com/decl/spiral.anderson.html"" rel=""nofollow noreferrer"">The ``Clockwise/Spiral Rule''</a></p>
",0
37156121,37155089,0,"<p>The identifier <em>table</em> is a function which returns a pointer to an array of 30 integer pointers. As a complement to learning the so called <a href=""http://c-faq.com/decl/spiral.anderson.html"" rel=""nofollow"">clockwise/spiral rule</a>, you can use a site like <a href=""http://cdecl.org/"" rel=""nofollow"">http://cdecl.org/</a> to find out.</p>

<p>If I was able to rewrite the code I would split the declaration into a type declaration and a function declaration. That way it will be easier to understand the program text. Also I would call the result type <em>Table</em> and choose a more specific name for the function, which most likely returns a special kind of table, say a <em>Foo</em> table. If possible I would also avoid the empty parameter list and use the keyword <em>void</em> to specify that the function takes no parameters:</p>

<pre><code>typedef int *(*Table)[30];

Table FooTable(void);
</code></pre>
",0
37155681,37155089,0,"<p>The line:</p>
<pre><code>int *(*table())[30];
</code></pre>
<p>declares that &quot;table is a function returning a pointer to an array of 30 pointers to int.&quot;</p>
<p>There are myriad good articles on how to read C type declarations. <a href=""http://unixwiz.net/techtips/reading-cdecl.html"" rel=""nofollow noreferrer"">Here is one of them.</a></p>
<p>To summarize:</p>
<p><strong>The rules:</strong></p>
<ol>
<li>There is a type name on the left. Call that $typename.</li>
<li>There is an identifier somewhere towards the right, possibly surrounded by <code>[]</code> and <code>()</code> and <code>*</code>. Call that $identifier.</li>
</ol>
<p>Your declaration will be templated like: <code>$identifier</code> is a ... <code>$typename</code>.</p>
<ol start=""3"">
<li><p>Start with &quot;$identifier is a(n)&quot;.</p>
</li>
<li><p>If you can go right, by consuming a <code>[...]</code> or a <code>(...)</code>, then add that to your declaration. The <code>[...]</code> is a (possibly-empty) array declaration, written &quot;array (of ...)&quot;; while the <code>(...)</code> is a (possibly-empty) function declaration, written &quot;function returning&quot; or &quot;function taking (...) returning&quot;.</p>
</li>
<li><p>If you cannot go right, because you reach a semicolon, or comma, or a closing parenthesis, then you must go left. Go left, consuming either the $typename if you are at the end of the process, or consuming a pointer declaration (<code>*</code>, written &quot;pointer(s) to&quot;) or consuming an opening parenthesis. After consuming any of these, except the $typename, try to go right again.</p>
<p>Remember: Go right if you can, go left if you must.</p>
</li>
</ol>
<p><strong>Your question, revisited</strong></p>
<p>With that in mind, let's look again:</p>
<pre><code>int *(*table())[30];
</code></pre>
<p>Step by step:</p>
<ol>
<li><p>$typename = &quot;int&quot;</p>
</li>
<li><p>$identifier = &quot;table&quot;;</p>
</li>
<li><p>Start with &quot;$identifier is a(n)&quot;: &quot;table is a(n)&quot; <code>${typename} *(*${declaration}())[30];</code></p>
</li>
<li><p>Go right: &quot;... function returning&quot; <code>${typename} *(* ${declaration} )[30];</code></p>
</li>
<li><p>Go right: fails, because of <code>)</code></p>
</li>
<li><p>Go left: &quot;... pointer(s) to&quot; <code>${typename} * ${declaration} [30];</code></p>
</li>
<li><p>Go right: &quot;... an array of 30&quot; <code>${typename} * ${declaration};</code></p>
</li>
<li><p>Go right: fails, because of <code>;</code>  <code>${typename} * ${declaration}</code></p>
</li>
<li><p>Go left: &quot;... pointer(s) to&quot; <code>${typename} ${declaration}</code></p>
</li>
<li><p>Go right: fails.</p>
</li>
<li><p>Go left: &quot;int&quot;</p>
</li>
</ol>
<p>Write that all in order, and you get:</p>
<blockquote>
<p>table is a(n) function returning pointer(s) to an array of 30 pointer(s) to int</p>
</blockquote>
<p>Clean up the sentence by removing (s) where not needed, and replacing single pointer with &quot;a pointer&quot;:</p>
<blockquote>
<p>table is a function returning a pointer to an array of 30 pointers to int.</p>
</blockquote>
",0
35231246,35231110,2,"<pre><code>#include &lt;stdio.h&gt;

void function(int** num)
{
    **num = 30;
}

int main(int argc, char**argv)
{
    int n = 10;
    int* ptr = &amp;n;
    int** ptr2ptr = &amp;ptr;
    function(ptr2ptr);
    printf(""%d\n"",n);
    return 0;
}
</code></pre>
",1
35231265,35231110,2,"<p>You have to use the good input type for function : int**.</p>

<p>If you add some gcc flags like -pedantic, you will see that you made some mistakes on types.</p>

<p>A working version of your program is:</p>

<pre><code>#include &lt;stdio.h&gt;

void function(int** num);

int main(int argc, char**argv) {
    int n = 10;
    int* ptr = &amp;n;
    int** ptr2ptr = &amp;ptr;
    function(ptr2ptr);
    printf(""%d"",n);
    return 0;
}

void function(int** num)
{
    **num = 30;
}
</code></pre>

<p>Note that you don't need a double pointer to do what you want, a simple one is enough.</p>
",0
35231327,35231110,3,"<p>You're both passing a triple pointer using <code>&amp;ptr2ptr</code> instead of <code>*ptr2ptr</code> AND your function takes a pointer and not a pointer to a pointer (<code>int *</code> instead of <code>int **</code>).</p>

<p>Another way to look at it is that <code>&amp;ptr2ptr</code> takes the address of the pointer and it doesn't de-reference it. What you wanted was:</p>

<pre><code>function(*ptr2ptr);
</code></pre>

<p>But to allow you to see more into the mistake, I took the longer route - you can look at this updated code and read through the comments for more info.</p>

<p>Remember, in C: ""usage == declaration""</p>

<p>meaning that <code>*</code> in a declaration creates a pointer and <code>*</code> in usage dereferences (uses) a pointer.</p>

<p><code>&amp;</code> will return the address of the object.</p>

<p>Here's some code to show the difference:</p>

<pre><code>int main(int argc, char **argv) {
    int n = 10;
    int *ptr = &amp;n; // this is a pointer to an int
    int **ptr2ptr = &amp;ptr; // this is a pointer to the pointer
    // &amp;ptr2ptr is a triple pointer - so we use the double pointer instead.
    function(ptr2ptr);
    // we could have used the original function using:
    // function(*ptr2ptr);
    printf(""%d"", n);
    return 0;
}

// `int *num ` in your function prototype
// is referencing a pointer to a pointer,
// but it expects a double pointer - updated:
void function(int **num) {
    // *num dereferences the first layer
    // **num references the actual number.
    **num = 30;
    // or:
    // *num = &amp;30; // will fail to compile, unless 30 was a variable
}
</code></pre>
",2
35231341,35231110,2,"<p>Let me comment your code for you and explain what is going on:</p>

<pre><code>int main(int argc, char **argv) {

    int n = 10; //declaring variable n type int

    //declaring variable ptr type int * setting it to address of n
    int *ptr = &amp;n;  

    //declaring variable ptr2ptr as int** and setting it to address of ptr
    int **ptr2ptr = &amp;ptr;

    //now you are trying to take the address of ptr2ptr, which is the address of an int**
    //this gives you an int***, you are passing this in function with undesirable behaviour
    function(&amp;ptr2ptr);
    printf(""%d"", n);
    return 0;
}

void function(int *num) //take in a parameter of type int*
{
    *num = 30; //dereference it and put value 30 in it
}
</code></pre>

<p>Instead of calling <code>function(&amp;ptr2ptr)</code> you should call <code>function(*ptr2ptr)</code> or even better <code>function(ptr)</code></p>
",0
35231382,35231110,2,"<p>Let's look closely at each line of your code:</p>

<pre><code>int main(int argc, char **argv) {
    int n = 10;
</code></pre>

<p><code>n</code> is declared as an <code>int</code>.</p>

<pre><code>    int *ptr = &amp;n;
</code></pre>

<p><code>ptr</code> is declared as a pointer-to-int and assigned the address of <code>n</code>.</p>

<pre><code>    int **ptr2ptr = &amp;ptr;
</code></pre>

<p><code>ptr2ptr</code> is declared as a pointer-to-pointer-to-int and assigned the address of <code>ptr</code>. This is what I assume you are calling a ""double pointer"".</p>

<pre><code>    function(&amp;ptr2ptr);
</code></pre>

<p>Now you send the address of <code>ptr2ptr</code> to <code>function()</code>. Note that value you are attempting passed to <code>function()</code> is a pointer-to-pointer-to-pointer-to-int (i.e. a ""triple pointer"").</p>

<pre><code>    printf(""%d"", n);
    return 0;
}

void function(int *num) {
</code></pre>

<p><code>function()</code> is declared to take a <code>pointer-to-int</code>. This means that the function call in <code>main()</code> should cause a compiler error since the argument types do not match the parameter types.</p>

<pre><code>    *num = 30; 
}
</code></pre>

<p>As I described above, your code should not compile. You are passing a <strong>triple</strong> pointer (<code>int***</code>) to a function which accepts only a single pointer (<code>int*</code>).  You have at least 3 possible fixes:</p>

<ol>
<li><p>Declare <code>function()</code> to take a triple pointer:</p>

<pre><code>void function(int*** num) {
    ***num = 30; 
}
</code></pre></li>
<li><p>Declare <code>function()</code> to take a double pointer:</p>

<pre><code>void function(int **num) { 
    **num = 30; 
}
</code></pre>

<p>and change the function call in main to</p>

<pre><code>function(ptr2ptr);
</code></pre></li>
<li><p>Both of these seem completely unnecessary since you are only trying to change the value of a single <code>int</code>. This means you can do all of what you want with a single pointer:</p>

<pre><code>void function(int *num) { 
    *num = 30; 
}
</code></pre>

<p>Now you can call this function with either</p>

<pre><code>function(ptr);
</code></pre>

<p>or</p>

<pre><code>function(&amp;num);
</code></pre></li>
</ol>
",0
35231130,35231110,6,"<p>You are actually passing a triply indirected integer to function <code>function</code>. <code>&amp;ptr2ptr</code> is the address of a pointer to a pointer to an integer. You did not define nor declare <code>function</code> before calling it from <code>main</code>.  It is incorrect in C99, but supported in ANSI C and implicitly declares <code>function</code> to take any number of arguments of any types and returning <code>int</code>.  You should move the definition of <code>function</code> before <code>main</code> and change it to:</p>

<pre><code>void function(int ***num) {
    ***num = 30; 
}
</code></pre>
",1
35231160,35231110,2,"<p>Since you are updating the value pointed by the pointer passed to the function,  no need to pass pointer to pointer (you are passing actually pointer to pointer to pointer).<br>
Function <code>function</code> expects <code>int *</code> type, therefore just pass <code>ptr</code>. You have to change the function call  </p>

<pre><code>function(&amp;ptr2ptr);  
</code></pre>

<p>to  </p>

<pre><code>function(ptr);  
</code></pre>

<p>Beside this you should have to include function prototype for function <code>function</code> or define it before <code>main</code>.</p>
",0
35232450,35231110,2,"<p>Your function <code>void function(int *num)</code> takes 1 argument,and that is a pointer to <code>int</code>,so when you call it,you should supply it with the address of an integer,not with address of pointer to <code>int</code>,nor address of address of pointer to <code>int</code>.</p>

<pre><code>int main(int argc, char **argv) {
    int n = 10;
    int *ptr = &amp;n;
    int **ptr2ptr = &amp;ptr;
    function(&amp;n);
    // function(ptr)  /* this also works */
    printf(""%d"", n);
    return 0;
}

void function(int *num) {
    *num = 30; 
}
</code></pre>
",0
37244689,25736603,0,"<p>Like Jonathan pointed out, it's a problem with operator precedence. <code>[]</code> has precedence over <code>*</code>, so it was being processed as an <em>array of int pointers</em> rather than a <em>pointer to an array of ints</em>.  </p>

<p>Another possible solution that would avoid using pointers to pointers entirely would be for the function <code>test()</code> to return the memory address with the allocated memory instead of receiving <code>foo</code> as an argument.  </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int* test() {
    int *bar = malloc(2 * sizeof(int));
    bar[0] = 4;
    bar[1] = 3;

    return bar;
}

int main() {
    int *foo = test();

    printf(""foo[0]: %d\n"", foo[0]);
    printf(""foo[1]: %d\n"", foo[1]);

    free(foo);
    return 0;
}
</code></pre>
",0
47966275,29582097,0,"<p>Not an expert but a hypothesis from experience:</p>

<p>If you initialize an array as a <code>static int myArray[1000]</code>, then C allocates new memory filled with 1000 zeros for the duration of the program. Initializing with <code>int myArray[1000]</code> just sets aside 1000 registers, some of which may contain old values from a previous use of the register.</p>
",0
41192442,15436060,1,"<p>In answering this question I wanted a function that was simple, thread friendly, did not return a char* (which is often tedious to manage), thread-safe and could stand on its own feet. I have an aversion to functions that return char* or pointers that must be managed.</p>

<p>The function below does not call malloc.</p>

<p>The function takes no parameters and returns a timestamp. I think it works well.</p>

<pre><code>struct Timestamp {
    time_t seconds;
    long milliseconds;
    char timestring[32];
};


struct Timestamp getTimestamp()
{
char   timebuffer[32]     = {0};
struct timeval  tv        = {0};
struct tm      *tmval     = NULL;
struct tm       gmtval    = {0};
struct timespec curtime   = {0};

struct Timestamp timestamp;

int i = 0;

// Get current time
clock_gettime(CLOCK_REALTIME, &amp;curtime);


// Set the fields
timestamp.seconds      = curtime.tv_sec;
timestamp.milliseconds = round(curtime.tv_nsec/1.0e6);

if((tmval = gmtime_r(&amp;timestamp.seconds, &amp;gmtval)) != NULL)
{
    // Build the first part of the time
    strftime(timebuffer, sizeof timebuffer, ""%Y-%m-%d %H:%M:%S"", &amp;gmtval);

    // Add the milliseconds part and build the time string
    snprintf(timestamp.timestring, sizeof timestamp.timestring, ""%s.%03ld"", timebuffer, timestamp.milliseconds); 
}

return timestamp;
}

int main()
{
    char   timebuffer[64]     = {0};
    int i = 0;
    struct timespec sleeptime = {0, 5000000L};

    struct Timestamp timestamp;

    for (i=0; i &lt; 20; i++)
    {
        timestamp = getTimestamp();
        printf(""Time is: %s \n"", timestamp.timestring);
        nanosleep(&amp;sleeptime, NULL);
    }

    return 0;
}
</code></pre>
",0
37293721,37293578,0,"<p><a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/malloc.html"" rel=""nofollow"">http://pubs.opengroup.org/onlinepubs/009695399/functions/malloc.html</a>
You can find many of such definitions. You should try to google it first :)</p>
",0
37293854,37293578,2,"<p>I recommend you to check the GNU C library: glibc.</p>

<p><a href=""http://www.gnu.org/software/libc/download.html"" rel=""nofollow"">http://www.gnu.org/software/libc/download.html</a></p>

<p>You can read the code there. In the <code>malloc</code> folder.</p>
",0
37293905,37293578,1,"<p><a href=""https://stackoverflow.com/questions/6485586/code-for-malloc-and-free"">Code for malloc and free</a></p>

<p><a href=""https://code.woboq.org/userspace/glibc/malloc/malloc.c.html"" rel=""nofollow noreferrer"">https://code.woboq.org/userspace/glibc/malloc/malloc.c.html</a></p>

<p><a href=""https://fossies.org/dox/glibc-2.23/malloc_8c_source.html"" rel=""nofollow noreferrer"">https://fossies.org/dox/glibc-2.23/malloc_8c_source.html</a></p>

<p>Above are link for code of malloc.</p>
",0
37296619,37293578,1,"<p><code>malloc()</code> is defined in Standard Library, as far as all unix flavors are concerned, and probably more, since Standard Library belongs to the C library. Whichever system has a C library and C API implemented, one could at least expect it to have a malloc. </p>

<p>Here are few more (beside above mentioned  GNU) links with source code:</p>

<p><a href=""http://cvsweb.netbsd.org/bsdweb.cgi/src/lib/libc/stdlib/malloc.c"" rel=""nofollow noreferrer"">NET BSD malloc</a><BR>
<a href=""http://opensource.apple.com//source/Libc/Libc-594.1.4/gen/malloc.c"" rel=""nofollow noreferrer"">OSX malloc</a></p>

<p>Some legacy unix systems (IRIX for example), beside having Standard Library <code>malloc()</code> also used to have a <em>fast</em> <code>libmalloc</code> implementation.<BR><BR>
Please, also take a look at this <a href=""https://stackoverflow.com/questions/6485586/code-for-malloc-and-free"">SO post</a>.</p>
",0
38504967,38504840,5,"<p>As stdlib.h has an include guard, there is no point in including it twice. Probably the mistake was caused by merging two files, both dependant on stdlib.h.</p>
",4
38505183,38504840,1,"<p>The only scenario it can make a difference is when one of the includes is <em>undefining</em> some symbols (including the include guards) from the previous includes. Consider 2 files:<br>
<strong>1.h:</strong></p>

<pre><code>#define A 1
</code></pre>

<p><strong>2.h</strong>:</p>

<pre><code>#undef A
</code></pre>

<p>Now, the following sequence:</p>

<pre><code>#include ""1.h""
#include ""2.h""

int B = A;
</code></pre>

<p>will produce an error, as <code>A</code> is undefined.</p>

<p>The following sequence will be just fine:</p>

<pre><code>#include ""1.h""
#include ""2.h""
#include ""1.h""

int B = A;
</code></pre>

<p>Now, if <code>1.h</code> has the include guards:</p>

<p><strong>1.h:</strong></p>

<pre><code>#ifndef GUARD_1
#define GUARD_1
#define A 1
#endif
</code></pre>

<p>The <strong>2.h</strong> can do:</p>

<pre><code>#undef GUARD_1
#undef A
</code></pre>

<p>and cause the same effect.  </p>

<p>Now to <code>stdlib.h</code>. You can compose something like this in your <strong>x.h</strong> header:</p>

<pre><code>#undef _STDLIB_H   // Kill the include guard of stdlib.h
#undef NULL        // Undefine some important symbol from stdlib.h
</code></pre>

<p>Now, this sequence:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include ""x.h""
</code></pre>

<p>will have <code>NULL</code> undefined</p>

<p>And this:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include ""x.h""
#include &lt;stdlib.h&gt;
</code></pre>

<p>will have it defined.</p>
",0
38505156,38504840,2,"<p>There's no reason to include a particular header file twice.  If the file has proper include guards, the second inclusion will have no effect.  If it does not have include guards, you'll likely get a slew of errors for multiple definitions for typedefs, among others.</p>

<p>In the case of system headers, they almost always have include guards.  The contents of stdlib.h might look something like this:</p>

<pre><code>#ifndef _STDLIB_H
#define _STDLIB_H   1
...
// type definitions, #defines, declarations, etc.
...
#endif /* stdlib.h  */
</code></pre>

<p>The first time stdlib.h is included, the <code>#ifndef</code> will evaluate to true, <code>_STDLIB_H</code> is defined, and the remaining contents are inserted into the file being compiled.  The second time stdlib.h is included, the <code>#ifndef</code> will evaluate to false since <code>_STDLIB_H</code> is defined and the contents of the file between the <code>#ifndef</code> and <code>#endif</code> will not be inserted again.</p>

<p>Most UNIX/Linux systems do this.  In contrast, Microsoft is known for not managing its OS specific include files properly.  If you included them in the wrong order you'll end up with lots of errors.</p>
",0
38505202,38504840,3,"<p>There is no harm in including a standard header more than once, although it is totally unnecessary.</p>

<p>The <a href=""http://port70.net/~nsz/c/c11/n1570.html#7.1.2p4"" rel=""nofollow"">C standard says</a> the following about this:</p>

<blockquote>
  <p>Standard headers may be included in any order; each may be included
  more than once in a given scope, with no effect different from being
  included only once, except that the effect of including <code>&lt;assert.h&gt;</code>
  depends on the definition of <code>NDEBUG</code>.</p>
</blockquote>
",0
38509161,38504840,0,"<p>Though not directly applicable to <code>&lt;stdlib.h&gt;</code>, a reason for including a user-defined header file twice: Testing if including the header file twice incurs a problem.</p>

<p>Example: Consider a pair of files <code>foo.h</code> and <code>foo.c</code> declaring and implementing a bunch of <code>foo_</code> functions, defines, types, etc.</p>

<p>File <code>foo.c</code></p>

<pre><code>#include ""foo.h""
#include ""foo.h""

rest of foo.c code ...
</code></pre>

<p>A 2nd calling of an include file should not cause a problem and <code>foo.c</code> tests that.<br>
OTOH,  <code>foo.c</code> did not test if including a header file only once is OK.</p>
",0
42539721,42471659,1,"<p>here is one version of the program that works correctly</p>

<p>Notice the proper timing of the 'line number' at the beginning of a line, including the first line and no extra line number output after the last line</p>

<p>Notice the usage of the high level I/O rather than the low level <code>read()</code> and <code>write()</code></p>

<p>Notice the checking for missing command line parameter</p>

<p>Notice the usage statement to stderr when command line parameter missing</p>

<p>Notice the error checking and proper error message to stderr when <code>fopen()</code> fails</p>

<p>Notice that each indent level is consistent and 4 spaces wide</p>

<p>Notice the usage of a variable 'priorCh' to track when the line number needs to be output.</p>

<p>Notice the proper referencing of the <code>main()</code> parameters <code>argc</code> and <code>argv[]</code></p>

<pre><code>#include &lt;stdio.h&gt;   // printf(), fopen(), fclose(), fgetc(), putc(), perror()
#include &lt;stdlib.h&gt;  // exit(), EXIT_FAILURE





int main(int argc, char *argv[])
{

    int      i = 0;       // line counter
    int      ch;
    int      priorCh = '\0';

    FILE*    reader= NULL;  // init to an invalid value

    if( 1 == argc )
    {
        fprintf( stderr, ""USAGE: %s &lt;inputFileName&gt; \n"", argv[0] );
        exit( EXIT_FAILURE );
    }

    // implied else, correct number of command line parameters


    reader = fopen(argv[1], ""r"");
    if( NULL == reader )
    {
        perror( ""fopen for input file failed"" );
        exit( EXIT_FAILURE );
    }

    // implied else, open successful

    i++;
    printf( ""%d "", i );

    while( (ch = fgetc( reader ) ) != EOF )
    {
        if( '\n' == priorCh )
        {
            i++;
            printf( ""%d "", i );
        }
        putc( ch, stdout );
        priorCh = ch;
    } // end while

    fclose(reader);
    return 1;
} // end function: main
</code></pre>

<p>Here is the output, when using the above file as the input</p>

<pre><code>1 #include &lt;stdio.h&gt;   // printf(), fopen(), fclose(), fgetc(), putc(), perror()
2 #include &lt;stdlib.h&gt;  // exit(), EXIT_FAILURE
3 
4 
5 
6 
7 
8 int main(int argc, char *argv[])
9 {
10 
11     int      i = 0;       // line counter
12     int      ch;
13     int      priorCh = '\0';
14 
15     FILE*    reader= NULL;  // init to an invalid value
16 
17     if( 1 == argc )
18     {
19         fprintf( stderr, ""USAGE: %s &lt;inputFileName&gt; \n"", argv[0] );
20         exit( EXIT_FAILURE );
21     }
22 
23     // implied else, correct number of command line parameters
24 
25 
26     reader = fopen(argv[1], ""r"");
27     if( NULL == reader )
28     {
29         perror( ""fopen for input file failed"" );
30         exit( EXIT_FAILURE );
31     }
32 
33     // implied else, open successful
34 
35     i++;
36     printf( ""%d "", i );
37 
38     while( (ch = fgetc( reader ) ) != EOF )
39     {
40         if( '\n' == priorCh )
41         {
42             i++;
43             printf( ""%d "", i );
44         }
45         putc( ch, stdout );
46         priorCh = ch;
47     } // end while
48 
49     fclose(reader);
50     return 1;
51 } // end function: main
</code></pre>
",5
47567172,47567139,2,"<p>Technically, yes, it's ok. static functions are only visible in the same compilation unit.</p>

<p>Practically, no, it's not ok. It makes your code hard to read and if I had to maintain your code later I'd hate you for it. Either because the functions do different things or because they diverge over time because someone fixed a bug in one of them and forgot the other.</p>
",3
47567563,47567139,1,"<p>A static inline function does not need a declaration to be included in the header file.</p>

<p>You can have the declaration in the .c file where it is used.</p>

<p>e.g. <code>a.c</code> </p>

<pre><code>static inline void asdf(int a);

....
static inline void asdf(int a)
{
   ....
}
</code></pre>

<p>In such a case the two different functions can be used in two files.</p>
",0
34887537,34887157,2,"<p>You can only <code>free</code> a pointer that was returned by <code>malloc</code>.</p>

<p>You are doing</p>

<pre><code>free(curr-&gt;value);
</code></pre>

<p>when <code>curr-&gt;value</code> happens to point to the string literal <code>""hello""</code>, which was not allocated by <code>malloc</code>.</p>

<p>You could fix it by either:</p>

<ul>
<li>Allocating the value with <code>malloc</code> (or another function that uses <code>malloc</code>, such as <code>strdup</code>)</li>
<li>Not <code>free</code>ing the value. (But if you have some values that need to be <code>free</code>d and some that don't, your program needs to remember which ones to <code>free</code>)</li>
</ul>
",0
42658557,42658477,-1,"<p>Use <code>uint32_t</code>. If these are unix epoch times, this will be sufficient for storing timestamps that are no <a href=""https://en.wikipedia.org/wiki/Year_2038_problem"" rel=""nofollow noreferrer"">further</a> than the year 2105.</p>
",0
42658980,42658477,1,"<p>If memory space optimization if your goal (at the expense of slower access, and time limited to 2106), then you should define your struct as <code>packed</code> to suppress padding:</p>

<pre><code>typedef struct __attribute__((__packed__)) ERROR_LOG_EVENT {
    uint32_t time;
    uint32_t count;
    int32_t error_type;
} ERROR_LOG_EVENT;
</code></pre>

<p>Then assign it like that:
<code>ERROR_LOG_EVENT.time = &lt;time_t&gt; &amp; 0xFFFFFFFF;</code></p>
",2
42658989,42658477,0,"<p>Adapt your code to properly handle a 64-bit timestamp. Specifically, write something that looks like</p>

<pre><code>typedef struct  ERROR_LOG_EVENT
{
    int64_t time;
    uint32_t count;
    int32_t error_type;
} ERROR_LOG_EVENT;
</code></pre>

<p>And force your 32-bit code to use this code. Don't try to store time intervals using 32-bit integers. That's always going to be a bad idea, and that's before you hit the problem of ""oh, the design requirements changed, we actually want to save nanoseconds, not seconds"".</p>
",0
35197607,35197332,1,"<hr>

<p>from scanf statement : </p>

<pre><code>scanf(""%f %d\n"",&amp;sal, &amp;month);
</code></pre>

<p>Remove <code>'\n'</code>, it will work.</p>
",0
35197703,35197332,0,"<p>Try it without the newline in the scanf(), then it should work.</p>

<pre><code>scanf(""%f %d"",&amp;sal, &amp;month);
</code></pre>
",0
35244843,35244547,2,"<p>Since you mention line breaks, I assume your data is text. Here is one way, when you know the line lengths. <code>fgets</code> reads the <code>newline</code> too, but that is easily ignored. Instead of trying to use <code>feof</code> I simply check the return value from <code>fgets</code>.</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void) {
    char str[16];
    int i;
    while(fgets(str, sizeof str, stdin) != NULL) {  // reads newline too
        i = 0;
        while (str[i] &gt;= ' ') {                     // shortcut to testing newline and nul
            printf(""%d "", str[i]);                  // print char value
            i++;
        }
        printf (""\n"");
        str[i] = '\0';                              // truncate the array
    }
    return 0;
}
</code></pre>

<p>Program session (ended by Ctrl-Z in Windows console, Ctrl-D in Linux)</p>

<pre><code>qwertyuiop
113 119 101 114 116 121 117 105 111 112
asdfghjkl;
97 115 100 102 103 104 106 107 108 59
zxcvbnm,./
122 120 99 118 98 110 109 44 46 47
^Z
</code></pre>
",0
41934525,41931772,2,"<p>If you can use <code>NULL</code> as delimiter in the list, you don't need to duplicate the strings, just use an array of pointers to string.</p>

<pre><code>*arrStrings[] = {""a"", ""be"", ""|"", ""cgg"", ""dss"", ""|"", ""mmd"", ""ddd"", """"};
</code></pre>

<p>is transformed into</p>

<pre><code>*arr       [] = {""a"", ""be"", NULL, ""cgg"", ""dss"", NULL, ""mmd"", ""ddd"", NULL};
</code></pre>

<p>Once you have filled the array you can use an array of pointers to pointer to string to create the list:</p>

<pre><code>*arr       [] = {""a"", ""be"", NULL, ""cgg"", ""dss"", NULL, ""mmd"", ""ddd"", NULL};
**ptr      [] = { ^                 ^                   ^               };
</code></pre>

<hr>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main(void)
{
    /* The array */
    char *arrStrings[] = {""a"", ""be"", ""|"", ""cgg"", ""dss"", ""|"", ""mmd"", ""ddd"", """"};
    /* Elements of the array */
    size_t sz = sizeof(arrStrings) / sizeof(arrStrings[0]);
    /* Loop */
    size_t i, n = 0;
    /* Create an array (VLA) of n pointers */
    char *arr[sz];

    /* Count the number of delimiters and fill array */
    for (i = 0; i &lt; sz; i++) {
        /* If we found a delimiter assign NULL */
        if (strcmp(arrStrings[i], ""|"") == 0) {
            arr[i] = NULL;
            n++;
        } else
        /* If we found an empty string assign NULL */
        if (arrStrings[i][0] == '\0') {
            arr[i] = NULL;
        } else {
            arr[i] = arrStrings[i];
        }
    }
    /* Create an array (VLA) of n delimiters pointers to pointer */
    char **ptr[n + 1];
    ptr[0] = &amp;arr[0];
    for (i = n = 0; i &lt; sz - 1; i++) {
        /* For each NULL string push address of array + 1 into ptr */
        if (arr[i] == NULL) {
            ptr[++n] = &amp;arr[i + 1];
        }
    }
    /* For each pointer to pointer loop and print until NULL */
    char **str;
    for (i = 0; i &lt;= n; i++) {
        str = ptr[i];
        printf(""%zu)\n"", i);
        while (*str != NULL) {
            printf(""\t%s\n"", *str);
            str++;
        } 
    }
    return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>0)
    a
    be
1)
    cgg
    dss
2)
    mmd
    ddd
</code></pre>
",0
41934974,41931772,0,"<p>The first thing you have to know is that an array of strings is a pointer to a fixed number of further pointers to characters</p>

<pre><code>arrString --&gt; |_|_|_| ... |_|
               | | |       |
               V V V       V
               a b |       \0
                 e
</code></pre>

<p>therefore you cannot simply update the ""|"" element with ""\0"" and manage the string as it would be the ""strtok"" function for example. Rather, you have to allocate three new ""char**"" array to maintain the three ""char*"" sequences, and use them to create the list as you prefer.</p>

<p>In case you want to avoid the allocation of new memory space, then you have to implement customized facilities, in order to parse the ""char**"" array according to its formatting. In this way you can really have three pointers to three different positions in ""arrString"", which define the first sub-string that belongs to the interested array. The final element ""|"" or ""\0"" will indicate no further elements belong to it. However, as I already said, this requires you implement ad-hoc functions, which avoid to alter the array.</p>
",0
41940973,15883743,0,"<p>This program may help you to solve your problem.</p>

<pre><code>     #include&lt;stdio.h&gt;

     int main()
     {
       FILE *fp;
       int ch;
       char txt[300];
       int len=0;
       fp=fopen(""tenlines.txt"",""r"");

       do{
           ch=fgetc(fp);
           txt[len]=ch;
           len++;
         } while(ch!=EOF &amp;&amp; ch!='\n');
     fclose(fp);
     puts(txt);

     return 0;
    }
</code></pre>
",0
34963032,34962945,4,"<p>The faster way to create initalize a file with zeroes (alias \0 null bytes) is using <code>truncate()/ftruncate()</code>. See <a href=""http://man7.org/linux/man-pages/man2/truncate.2.html"" rel=""nofollow"">man page here</a></p>
",0
34963065,34962945,4,"<p>You are counting up to <code>0xffffffff</code>, which is equal to 4,294,967,295. You want to count up to <code>0x80000000</code> for exactly 2 GB of data.</p>
",0
35255842,35253707,0,"<p>To get a <code>3</code>, you can write:</p>

<pre><code>#include &lt;stdio.h&gt;

int main () {
        int numberOfChars = 0;

        do {
                while(getchar() != '\n')
                        numberOfChars++;
        } while(getchar() != EOF &amp;&amp; numberOfChars++);

        printf(""Number of chars = %d\n"", numberOfChars);

        return 0;
}
</code></pre>

<p>Then press <kbd>Ctrl</kbd> + <kbd>D</kbd> to exit the nested loop.</p>

<p>In fact, your program is correct. It gave you <code>6</code> because you've entered 6 characters: <code>1</code>, <code>\n</code>, <code>2</code>, <code>\n</code>, <code>3</code>, <code>\n</code>.</p>
",5
35257799,35253707,0,"<p>Create a file, then run the cygwin od program, followed by a run of the example C program :</p>

<pre><code>od -x &lt; testfile
a.out &lt; testfile
</code></pre>

<p>Then you can see what &amp; how many characters you had exactly in the file and avoid surprises.</p>

<p>As a debugging aid, if I suspected something was wrong, I'd add something like :</p>

<pre><code>int c; for(numberOfChars = 0; (c = getchar()) != EOF; numberOfChars++) 
    printf( ""\0x%x"", c);
</code></pre>

<p>To understand the processing my code was doing.</p>
",0
39665877,39665757,1,"<p>The error means the code is trying to access (either read or write) memory location 0x10 (16).  This is certainly an access based on a NULL pointer.</p>

<p>That could happen if <code>malloc()</code> fails.  It can also occur if you use the prev or next field values before assigning them to a successful <code>malloc</code> result.</p>
",2
42488459,42488299,5,"<p>As so often, I found the problem shortly after summarizing everything for StackOverflow. The issue is that I didn't properly initialize the <code>struct tm</code>. If I change the corresponding line of code to</p>

<pre><code>struct tm querytime = { 0 };
querytime.tm_isdst  = -1; // See comment below
</code></pre>

<p>then the issue goes away:</p>

<pre><code>gcc test.c &amp;&amp; ./a.out 
1488150019 - Feb 27 00:00:19 - Mon Feb 27 00:00:19 2017

1488150019 - Feb 27 00:00:19 - Mon Feb 27 00:00:19 2017

1488150019 - Feb 27 00:00:19 - Mon Feb 27 00:00:19 2017
</code></pre>

<p>I will leave this here for future reference.</p>

<p>Note that initializing all quantities with <code>0</code> turned out to cause problems with daylight saving time (DST). According to ISO/IEC 9899:TC3, <code>tm_isdst</code>, should be initialized with a negative value as <code>tm_isdst = 0</code> translates into <code>DST = No</code> instead of the intended <code>DST = Unknown</code>.</p>
",2
36290125,36290084,4,"<pre><code>for (*i2 = 0; *i2&lt;10; i2++)
</code></pre>

<p>should be</p>

<pre><code>for (*i2 = 0; *i2&lt;10; (*i2)++)
</code></pre>

<hr>

<p><strong>NOTE:</strong> 
Use the standard definition of <code>main()</code></p>

<pre><code>int main(void) //if no command line arguments.
</code></pre>
",0
36290194,36290084,5,"<p>A big problem is your <code>for</code> loop:</p>

<pre><code>for (*i2 = 0; *i2&lt;10; i2++)
</code></pre>

<p><code>i2++</code> increments the value of the <em>pointer</em> (making it point to something other than <code>i</code>), not the thing being <em>pointed to</em>.  You need to change that line to</p>

<pre><code>for (*i2 = 0; *i2&lt;10; (*i2)++)
</code></pre>

<p>The parentheses around <code>*i2</code> are necessary, because the postfix <code>++</code> operator has higher precedence than the unary <code>*</code> operator.  <code>*i2++</code> would be parsed as <code>*(i2++)</code>, which is not what you want. </p>
",0
36291218,36290084,2,"<p>You asked a second question when you edited your original question (that edit has now been reversed so the actual question has disappeared).</p>

<p>Basically you asked why the printf statement was not returning the expected value.
At that time you had this code:</p>

<pre><code>for (*i2 = 0; *i2&lt;10; (*i2)++)
{
    if (*i2&gt;4)
    {
        *z2 = *i2;
        *b2++;
            break;
    }
}
printf(""%d%c\n"", b2, ch[z]);
</code></pre>

<p>b2 is a pointer ... int *b2;<br>
Now you assign a value to b2 ... b2 = &b;<br>
So now b2 contains the address b and your printf statement prints this address (albeit in integer format '%d' rather than as a pointer %p)</p>

<p>To get the value held in 'b' which is 'pointed to by 'b2', you need to dereference ... *b2</p>

<p>But ... note that you have changed the pointer *b2 with this statement  ... *b2++<br>
That statement changed the value of the pointer, not the value of b which it originally pointed to and now *b2 will be undefined.   </p>

<p>Change *b2++ to (*b2)++ and change printf b2 to printf *b2<br>
and the result is b + 1 which will be 1 as b was originally set to 0.</p>
",1
45745857,45745757,3,"<p>Statement <code>fwrite(buffer, 1, BUF_SIZE, fp)</code> will write <code>BUF_SIZE</code> bytes, regardless of the actual content of the buffer and regardless if it contains a <code>'\0'</code> considered as ""string termination"".
So the only way is to tell <code>fwrite</code> the correct number of elements to write; and this can be easily calculated through pointer arithmetics:</p>

<pre><code>fwrite(buffer, 1, pos-buffer, fp)
</code></pre>

<p>Of course, you'll have to check if <code>pos != NULL</code> and so on; but I think this is straight forward.</p>
",0
44646103,19199473,1,"<p>For absolute performance ie. Minimum comparisons and assignments.</p>

<p>The comments at each level show the candidate values for <em>min</em> and <em>max</em>. The idea is to reduce the sets at each level until there is only one item for each set. This can be done with <em>4</em> comparisons and <em>2</em> assignments only.</p>

<pre><code>        // min = a b c d
        // max = a b c d
        if (a &lt;= b)
        {
            // min = a c d
            // max = b c d
            if ( c &lt;= d){
                // min = a c
                // max = b d
                min = a &lt;= c ? a : c;
                max = b &gt; d ? b : d;
            }else{
                // min = a d
                // max = b c
                min = a &lt;= d ? a : d;
                max = b &gt; c ? b : c;
            }
        }
        else
        {
            // min = b c d
            // max = a c d
            if ( c &lt;= d){
                // min = b c
                // max = a d
                min = b &lt; c ? b : c;
                max = a &gt; d ? a : d;
            }else{
                // min = b d
                // max = a c
                min = b &lt; d ? b : d;
                max = a &gt; c ? a : c;
            }
        }
</code></pre>
",1
37700956,19199473,0,"<pre><code> Please have at the following    

 private int GetLargerValue(int num1, int num2, int num3, int num4)
            {
                int largeValue = 0;
                if (num1 &gt; num2)
                {
                    if (num1 &gt; num3)
                        largeValue = (num1 &gt; num4) ? num1 : num4;
                    else
                        largeValue = (num3 &gt; num4) ? num3 : num4;

                }
                else if (num2 &gt; num3)
                    largeValue = (num2 &gt; num4) ? num2 : num4;
                else
                    largeValue = (num3 &gt; num4) ? num3 : num4;

                return largeValue;
            }
</code></pre>
",0
36258130,36257204,1,"<p>In this program</p>

<pre><code>int main() {
    char* test = malloc(5);
    *test = ""testc"";
    printf(""Test=%c"",test[4]);
}
</code></pre>

<p>you allocated memory </p>

<pre><code>    char* test = malloc(5);
</code></pre>

<p>As result the pointer <code>test</code> points to the allocated memory.</p>

<p>When you tried to reasign the prointer</p>

<pre><code>*test = ""testc"";
</code></pre>

<p>However you used a wrong syntax.</p>

<p>Expression <code>*test</code> has type <code>char</code> and in this statement you tried to assign the first character of the memory pointed to by <code>test</code> with the address of the string literal.</p>

<p>But if you wrote the expression correctly as</p>

<pre><code>test = ""testc"";
</code></pre>

<p>there was a memory leak because the address of the allocated memory is lost in this case and the memory can not be free.</p>

<p>And moreover if the pointer must to point to a string then you need to allocate 6 characters to provide the terminating zero also would be stored in the allocated memory.</p>

<p>What you need is the following</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main( void ) 
{
    char *test = malloc( 6 );

    strcpy( test, ""testc"" );
    printf( ""Test=%c\n"",test[4] );

    free( test );
}
</code></pre>

<p>or you could just write </p>

<pre><code>#include &lt;stdio.h&gt;

int main( void ) 
{
    char *test = ""testc"";

    printf( ""Test=%c\n"",test[4] );
}
</code></pre>
",0
36257234,36257204,1,"<p>In your case,</p>

<pre><code> *test = ""testc"";
</code></pre>

<p>is very wrong. You are trying to put a pointer into a <code>char</code> variable. Enable warnings in your compiler and it will scream.</p>

<p>What you should do is, <strong>either</strong></p>

<ul>
<li>Don't malloc, and assign the string literal to the pointer directly.</li>
<li>Use <code>malloc()</code> and then <code>strcpy()</code> the string literal into the memory pointed by the pointer.</li>
<li>Don't <code>malloc()</code>, don't <code>strcpy()</code>, use <code>strdup()</code> and store the result in the pointer.</li>
</ul>

<p>The catch(es) is (are)</p>

<ul>
<li>First case, the string literal will be non-modifiable.</li>
<li>Later two cases, you need to <code>free()</code> the allocated memory.</li>
<li>The last way is a bit <em>non-standard</em>, strictly speaking.</li>
</ul>
",1
40543486,40541338,3,"<p>I would use <code>typedef</code> and use 3 h-files to separate the common data structure from <code>A</code> and <code>B</code>. Something like:</p>

<p>MyNode.h:</p>

<pre><code>#ifndef MyNode_H
#define MyNode_H

typedef struct Node
{
  void *data;
  struct Node *next;
} Node;

#endif
</code></pre>

<p>A.h:</p>

<pre><code>#ifndef A_H
#define A_H

#include ""MyNode.h""

typedef Node A;

/* Declare functions for implementing a linked list using type A */

#endif
</code></pre>

<p>B.h:</p>

<pre><code>#ifndef B_H
#define B_H

#include ""MyNode.h""

typedef Node B;

/* Declare functions for implementing a stack using type B */

#endif
</code></pre>

<p>Main.c:</p>

<pre><code>#include &lt;stdio.h&gt;
#include ""A.h""
#include ""B.h""

int main(void) {
  /* Here A and B can be used as types, example: */
  A list = {NULL, NULL};
  B stack = {NULL, NULL};


  return 0;
}
</code></pre>
",0
47998580,47998504,23,"<p>Whoever created the test didn't properly encode their HTML. What they wanted that line to look like is:</p>

<pre><code>return &amp;num;
</code></pre>

<p>They put that directly into the HTML of the test page, forgetting that <code>&amp;XXX;</code> is how HTML entities are entered. <code>&amp;num;</code> is the entity for the <code>#</code> character. They should have written:</p>

<pre><code>return &amp;amp;num;
</code></pre>

<p><code>&amp;amp;</code> is the entity for the <code>&amp;</code> character.</p>
",3
47998655,47998504,0,"<p>The function func() returns a pointer that points to the variable num. But num is an auto variable inside the function func(). It's stored in stack and its lifetime is only the lifetime of the function itself. So if you try to access that pointer in the main() it will be segmentation fault cz num doesn't exist anymore and hence pointer doesn't really point to anything.</p>

<p>Edit:</p>

<p>Hash - # is used for defining macros and header files.  return # -->  it just seems to be typo in the question. So only error is the segmentation fault due to pointer.</p>
",2
44738708,44737964,2,"<p>Microsoft compilers will not look in the cpp folder when using the #include &lt;&gt; form. </p>

<p>Change your include statement to the correct form for including a 'local' header.</p>

<pre><code>#include ""structmember.h""
</code></pre>
",2
34987260,34986567,6,"<p><code>&amp;arr</code> takes the address of the array, it is an <em>array pointer</em> (not to be confused with pointer to 1st element). It has type <code>int(*)[3]</code>. </p>

<p>Then you do pointer arithmetic on this array pointer. Since it points at an array of 3 integers, <code>&amp;arr + 1</code> will mean ""plus the size of one whole array"" and you end up pointing just past the declared array, which doesn't make any sense.</p>

<p>Then you take the contents of the array pointer with <code>*</code>. You will then get the array itself again. When you an array in an expression, it decays into a pointer to its first element, <code>int*</code>. Which is not compatible with <code>int</code>, hence the error.</p>

<p>I'm guessing you were probably trying to do either <code>&amp;arr[0] + 1</code> or <code>arr + 1</code>, which both mean the same thing.</p>
",2
34987330,34986567,1,"<p><code>arr</code> has the type of <code>int (*)[3]</code>, other than <code>int *</code>, although in most cases, array names decay into pointers to first elements, that is <code>&amp;arr[0]</code> in your second case, and this is exactly why your <code>value2</code> is output normally.</p>

<p>However, when <code>arr</code> is the argument of the <code>&amp;</code> operator, it doesn't decay. As a result, <code>&amp;arr+1</code> has the equivalent value as <code>&amp;arr[0]+3</code>. This is because <code>sizeof &amp;arr</code> is equal to <code>sizeof (int (*)[3])</code>, which yields 3. Consequently, when trying to output <code>value1</code>, your are actually accessing <code>&amp;arr[3]</code>, whose type is <code>int *</code>. It's <code>&amp;arr[3]</code>, not <code>arr[3]</code>, because when you dereference something has the type of <code>int (*)[3]</code>, it decays to a pointer.</p>

<p>So as you can see, the warning is indeed trying to save you from a potential error.</p>

<p>See also: <a href=""https://stackoverflow.com/q/17752978/5399734"">Exception to array not decaying into a pointer?</a></p>
",0
37449471,37449439,1,"<pre><code>typedef struct{
    char *val;
} STRING;

int cmp(const STRING *a)
{
    return strcmp(a-&gt;val, ""a string"");
}
</code></pre>

<p>You need <code>strcmp</code> for string comparison. == compares addresses.</p>
",2
37449499,37449439,4,"<p>You need to use strcmp. To keep with returning 1 if equal:</p>

<pre><code>int func (STRING* compare){
  if ( strcmp(compare, ""a string"" ) == 0) 
    return 1;
  return 0;
}
</code></pre>
",0
37449556,37449439,2,"<p>When dealing with <code>struct</code> in C, since you don't have object oriented features, it's good to encapsulate the behavior or operations on such <code>struct</code> inside methods.</p>

<p>Since your <code>STRING</code> type contains a pointer that I guess should be owned by the instance then you could provide 3 methods to manage allocation, decallocation and comparison of <code>STRING</code> objects, for example:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdbool.h&gt;

typedef struct {
    char* val;
} STRING;

STRING string_alloc(const char* val) {
    STRING string;
    string.val = malloc(strlen(val)+1);
    strcpy(string.val, val);
    return string;
}

void string_free(STRING* string) {
    free(string-&gt;val);
}

bool string_compare(const STRING* str1, const STRING* str2) {
    return strcmp(str1-&gt;val, str2-&gt;val) == 0;
}

int main(void) {
    STRING string = string_alloc(""foo"");
    STRING string2 = string_alloc(""foo"");

    printf(""Are equal: %s\n"", string_compare(&amp;string, &amp;string2) ? ""true"" : ""false"");

    string_free(&amp;string);
    string_free(&amp;string2);

    return 0;
}
</code></pre>

<p>In this way you are able to encapsulate the comparison behavior inside a method and alter it if you need to alter the structure of the <code>struct</code>  (eg adding fields, removing fields) without touching anything else of the code.</p>
",0
41918656,41918268,2,"<p>There are multiple problems in your code:</p>

<ul>
<li><p>You do not check if <code>fopen()</code> successfully opened the files.</p></li>
<li><p>You do not prevent potential buffer overflow when concatenating strings to compute the permissions file.</p></li>
<li><p>You should pass the array sizes to <code>fscanf</code> to prevent potential buffer overflows.</p></li>
<li><p>You should output meaningful and informative error messages, with the cause of failure, using <code>strerror(errno)</code>.</p></li>
<li><p>The loop to copy the permission file is incorrect: <a href=""https://stackoverflow.com/questions/5431941/why-is-while-feof-file-always-wrong"">Why is ¡°while ( !feof (file) )¡± always wrong?</a></p></li>
<li><p>You remove the duplicate file even if you failed to rename it but managed to remove the original file: both files may be lost.  Conversely, if the rename operation succeeded, removing the duplicate file is redundant.</p></li>
</ul>

<p>Here is how you could improve the code:</p>

<pre><code>#include &lt;errno.h&gt;
#include &lt;string.h&gt;

boolean delete_user(char user_name[256]) {  //only for Admin
    boolean status = FALSE; // the function return value
    User_Data *ud = NULL;
    boolean found_user = FALSE;
    FILE *new_file = NULL;
    FILE *fp = NULL;
    char user_name_to_copy[256];
    char password_to_copy[256];
    char old_file_name[256];

    ud = find_user(user_name);
    if (ud == NULL) {
        printf(""User '%s' was not found!\n"", user_name);
        return FALSE;
    }
    if (!strcmp(ud-&gt;permission_type, ""Admin"")) {
        printf(""Cannot delete user '%s', user has admin status.\n"", user_name);
        return FALSE;
    }
    // the user to delete was found 
    new_file = fopen(""duplicate.txt"", ""wt"");
    if (new_file == NULL) {
        printf(""Cannot open file 'duplicate.txt': %s\n""
               strerror(errno));
        return FALSE;
    }
    // the name of the file is in plural and ends with .txt
    snprintf(old_file_name, sizeof old_file_name, ""%ss.txt"", ud-&gt;permission_type);
    fp = fopen(old_file_name, ""rt"");
    if (fp == NULL) {
        printf(""Cannot open user file '%s': %s\n""
               old_file_name, strerror(errno));
        return FALSE;
    }
    // copy all the users except the user to delete the new file 
    while (fscanf(fp, ""%255s %255s\n"", user_name_to_copy, password_to_copy) == 2) {
        if (strcmp(user_name_to_copy, user_name)) {
            fprintf(new_file, ""%s %s\n"", user_name_to_copy, password_to_copy);
        }
    }
    fclose(fp);
    fclose(new_file);
    if (remove(old_file_name)) {
        printf(""Error removing file '%s': %s\n"",
               old_file_name, strerror(errno));
        remove(""duplicate.txt"");
        return FALSE;
    }
    if (rename(""duplicate.txt"", old_file_name)) {
        printf(""Error renaming file 'duplicate.txt' to '%s': %s\n"",
                old_file_name, strerror(errno));
        // keep duplicate.txt
        return FALSE;
    }
    // duplicates.txt was successfully renamed, no need to remove it.
    return TRUE;
}
</code></pre>

<p>Notes:</p>

<ul>
<li>You create the temporary file in the current directory, which might reside on a different drive from the permissions file.  <code>rename()</code> may fail to move the duplicate file from the current directory to that directory.  Running the code with proper diagnostics should if this is the reason for failure.</li>
</ul>
",4
41918681,41918268,1,"<pre><code>    printf("" %d "", remove(old_file_name));
    rename(""duplicate.txt"", old_file_name);
    remove(""duplicate.txt"");
</code></pre>

<p>This code is mostly redundant. <strike>There's no need to remove <code>old_file_name</code>, <code>rename</code> will blow over it.</strike> (Turns out this is a POSIX thing, the C standard does not guarantee it). There's no need to remove <code>duplicate.txt</code>, it's been renamed.</p>

<pre><code>    if( remove(old_file_name) != 0 ) {
        fprintf( stderr, ""Could not remove %s: %s"", old_file_name, strerror(errno) );
    }

    if( rename(""duplicate.txt"", old_file_name) != 0 ) {
        fprintf( stderr, ""Could not rename %s to %s: %s"", ""duplicate.txt"", old_file_name, strerror(errno) );
    }
</code></pre>

<p>You need to do this checking <strong><em>every file operation</em></strong>. That includes <code>fopen</code> and <code>fscanf</code>.</p>

<p>Also, you might have the files backwards. It's <code>rename( old, new )</code> but it really looks like you wrote <code>rename( new, old )</code>. If you don't have them reversed, consider variable names that make the code easier to understand.</p>

<hr>

<pre><code>    fp = fopen(old_file_name, ""rt"");
    while (!feof(fp)) {
        //copy all the users except the user to delete the new file 
        fscanf(fp, ""%s %s\n"", user_name_to_copy, password_to_copy);
        if (strcmp(user_name_to_copy, user_name)) {
            fprintf(new_file, ""%s %s\n"", user_name_to_copy, password_to_copy);
        }
    }
</code></pre>

<p>This code is problematic. As mentioned, it fails to check whether <code>fopen</code> and <code>fscanf</code> succeed. Using <code>fscanf</code> is a problem, if it fails to match it doesn't advance the file pointer. You can read the same line over and over again, failing each time. In general, <a href=""http://c-faq.com/stdio/scanfprobs.html"" rel=""nofollow noreferrer"">avoid <code>fscanf</code> and <code>scanf</code></a>.</p>

<p>Instead, read the whole line with <code>fgets</code> and parse it with <code>sscanf</code>. Be sure to check whether <code>sscanf</code> succeeded, else you'll print gibberish. Note that <code>sscanf</code> has bounds on how big a string it will read to protect against buffer overflow.</p>

<pre><code>    FILE *fp = open_file(old_file_name, ""rt"");
    char line[1024];
    while (fgets(line, 1024, fp)) {
        //copy all the users except the user to delete the new file 
        if( sscanf(fp, ""%255s %255s\n"", user_name_to_copy, password_to_copy) != 2 ) {
            fprintf(stderr, ""Couldn't understand line '%s'\n"", line);
            continue;
        }
        if (strcmp(user_name_to_copy, user_name)) {
            fprintf(new_file, ""%s %s\n"", user_name_to_copy, password_to_copy);
        }
    }
    fclose(fp);
</code></pre>

<p>Since checking whether a file opened or not gets redundant, I recommend writing a little function to do that.</p>

<pre><code>FILE *open_file(char *filename, char *mode) {
    FILE *fp = fopen(filename, mode);
    if( fp == NULL ) {
        fprintf(
            stderr, ""Could not open '%s' for '%s': %s\n"",
            filename, mode, strerror(errno)
        );
        exit(1);
    }

    return fp;
}
</code></pre>
",3
45739483,45739260,3,"<blockquote>
  <p>When to use <code>intptr_t</code>, <code>size_t</code> data type?</p>
</blockquote>

<p><code>size_t</code> is always available - it is part of the C language.  It is some <em>unsigned</em> type useful for indexing arrays and performing size  calculations.  It is the best width integer for indexing as it is never too narrow nor excessively wide.  </p>

<p>Code can use <code>printf(""%zu\n"", some_size_t);</code> to print. </p>

<p><code>(u)intptr_t</code> are optionally yet commonly implemented.  They are part of the C standard library.  They are integer types capable of round-tripping object pointers  <code>object *</code> --> <code>void *</code>  --> <code>intptr_t</code>  --> <code>void *</code> --> <code>object *</code> with a resultant pointer that equates to the original.  </p>

<p>Code can use <code>printf( ""%"" PRIdPTR ""\n"", some_intptr_t);</code> to print.</p>

<hr>

<blockquote>
  <p>Can we use %z instead of PRIdPTR when trying to print intptr_t?</p>
</blockquote>

<p>This does not make for portable code.  Aside from the difference in sign-ness, it is reasonable to encounter implementations that differ in integer width, with <code>intptr_t</code> likely be wider or as wide as <code>size_t</code>.</p>
",2
45739494,45739260,3,"<p>First, you <em>shouldn't care</em> how many bits a type has (at least, in general). Use the types for their <em>intended purpose</em> and your code will be fine and portable.</p>

<p>Use <code>size_t</code> for anything related to the size of an object. This includes e.g. indexing of an array.</p>

<p>Usages for <code>intptr_t</code> are very rare, but use them whenever you need to store the value of a pointer in a <em>signed integer</em>. Often, an <em>unsigned integer</em> is a better choice, then you can use <code>uintptr_t</code>. Most of the time, you don't need to store pointers in integers and can just use ..... a pointer type.</p>

<p>For printing, <code>%z</code> is not a conversion specifier. <code>z</code> is a length modifier suitable for the size of a <code>size_t</code>. As <code>size_t</code> is unsigned, you need <code>%zu</code>. Also note that the <code>PRIdPTR</code> macro expands to something you should concatenate with <code>%</code> to make it a complete conversion specifier. It only contains the type specifier and necessary length modifier.</p>

<p>Of course, if you <strong>know</strong> that <code>uintptr_t</code> is the same type as <code>size_t</code>, printing it with <code>%zu</code> will succeed. But it's still wrong, there is no guarantee these types will be the same on all platforms.</p>
",4
45739411,45739260,3,"<p>You should use <code>intptr_t</code> if you want to store a pointer in an integral type. Historically people often used <code>int</code> for this, but this isn¡¯t good practice because often a pointer is larger than an <code>int</code> so you lose information; an <code>intptr_t</code> or <code>uintptr_t</code> is guaranteed to be able to hold a pointer. You should use a <code>size_t</code> if you want the size or number of elements of some type; this is the result of <code>sizeof</code>, and is usually what you use to index sequential container types like arrays or <code>std::vector</code>s. Usually, they will be the same type under the hood (except for signedness), but this is not guaranteed on platforms with, e.g., <a href=""https://en.wikipedia.org/wiki/Memory_segmentation"" rel=""nofollow noreferrer"">segmented memory</a>, where a type can only take up a fraction of the available memory.</p>

<p>You rarely actually want to store a pointer in an integral type; you are usually much better off leaving it as a pointer, so you probably don¡¯t want to use <code>intptr_t</code> or <code>uintptr_t</code> very much. However, you often want to know the size of things, or index arrays or standard containers, so you should use <code>size_t</code> relatively often.</p>
",0
47691810,47673342,0,"<p>I solved it by creating three files. </p>

<p>One with the xml until the opening of the tag in which the data should reside.
The second with the generated junk data.
The third with the close tag of the bulk data en the rest of the xml.</p>

<p>Like so: </p>

<pre><code>   // Open two files to be merged
   FILE *fp1 = fopen(""person1.xml"", ""r"");
   FILE *fp2 = fopen(""randomdata.txt"", ""r"");
   FILE *fp3 = fopen(""person3.xml"", ""r"");


   // Open file to store the result
   FILE *fp4 = fopen(""personf.xml"", ""w"");
   char c;

   if (fp1 == NULL || fp2 == NULL || fp3 == NULL || fp4 == NULL)
   {
         puts("" --- Could not open files"");
         exit(0);
   }

   // Copy contents of first file1
   while ((c = fgetc(fp1)) != EOF)
      fputc(c, fp4);

   printf("" --- Done copying file 1\n"");
   // Copy contents of first file2
   while ((c = fgetc(fp2)) != EOF)
      fputc(c, fp4);

   printf("" --- Done copying file 2\n"");

   // Copy contents of first file3
   while ((c = fgetc(fp3)) != EOF)
      fputc(c, fp4);

   printf("" --- Done copying file 3\n"");

   printf(""Merged files\n"");

   fclose(fp1);
   fclose(fp2);
   fclose(fp3);
   fclose(fp4);
   return 0;
</code></pre>
",0
42495343,42494702,1,"<p><code>extern int x = 9;</code> means the same as <code>int x = 9;</code>.  The <code>extern</code> keyword has no effect for a definition that already has external linkage and an initializer.</p>

<p><code>int x;</code> is called a <em>tentative definition</em>.   </p>

<p>This is described well by C11 6.9.2/2:</p>

<blockquote>
  <p>A declaration of an identifier for an object that has file scope without an initializer, and
  without a storage-class specifier or with the storage-class specifier static, constitutes a
  tentative definition. If a translation unit contains one or more tentative definitions for an
  identifier, and the translation unit contains no external definition for that identifier, then
  the behavior is exactly as if the translation unit contains a file scope declaration of that
  identifier, with the composite type as of the end of the translation unit, with an initializer
  equal to 0.</p>
</blockquote>

<p>This translation unit <em>does</em> contain an external definition for <code>x</code>, so the tentative definition has no effect.  It doesn't matter whether the external definition is before or after the tentative definition.</p>

<p>""external definition"" means a non-tentative definition at file scope -- not to be confused with <code>extern</code> or ""external linkage"", although in your example <code>x</code> does happen to have external linkage.</p>

<p>So your code is exactly the same as:</p>

<pre><code>int x = 9;
</code></pre>
",6
38199458,38199420,5,"<p>You will need to flush the output to stdout:</p>

<pre><code>fflush(stdout);
</code></pre>

<p><a href=""https://bytes.com/topic/c/answers/629409-fflush-stdout"" rel=""noreferrer"">https://bytes.com/topic/c/answers/629409-fflush-stdout</a> is a similar question</p>

<p><code>printf</code> will typically do this for you if you have a newline (as you've found) but not if you don't.</p>
",0
38988007,38987902,3,"<p>In order to store array elements you need to use <code>scanf(""%d"", &amp;arr[i]);</code> instead of 
<code>scanf(""%d"", arr[i]);</code></p>

<p><code>&amp;</code> in <code>C</code> is used to refer to address of a variable. So,by using <code>&amp;arr[i]</code> you are telling your program to store the input variable at <code>ith</code> index of array  <code>arr[]</code>.</p>

<p>So the correct code will be  </p>

<pre><code>int *arr;
int sizeOfArr = 0;

printf(""Enter size of arr.\n"");
scanf(""%d"", &amp;sizeOfArr);

arr = malloc(sizeOfArr * sizeof(int));

for (int i = 0; i &lt; sizeOfArr; i++) {

    scanf(""%d"", &amp;arr[i]); //notice the diff here

}
</code></pre>
",0
39648065,39647772,0,"<p>Joachim Pileborg already used the comments to hint at the errors you made, let me be less subtle:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
// Cesar cipher
int main(int argc, char **argv)
{
  FILE *fp1 = NULL;
  // we need an int to check for EOF
  int ch;

  fp1 = fopen(""Hello.txt"", ""r+"");
  if (fp1 == NULL) {
    fprintf(stderr, ""fp1 NULL!\n"");
    exit(EXIT_FAILURE);
  }

  while (1) {
    // get character (fgetc returns an int)
    ch = fgetc(fp1);
    if (ch == EOF) {
      printf(""End of File\n"");
      break;
    } else {
      // Set file-pointer back to the position of 
      // the character just read (it is a bit more
      // complicated internally and works only for one)
      ungetc(ch, fp1);
      // do decryption
      if (argc == 2 &amp;&amp; *argv[1] == 'd') {
        ch = ch - 3;
      }
      // do encrytion (default)
      else if (argc == 1 || (argc == 2 &amp;&amp; *argv[1] == 'e')) {
        ch = ch + 3;
      }
      // print character (fputc takes an int)
      fputc(ch, fp1);
    }
  }
  fclose(fp1);
  exit(EXIT_SUCCESS);
}
</code></pre>
",0
35290009,20388064,2,"<p>You Just need to add  <code>include &lt;unistd.h&gt;</code></p>
",0
37450160,37450108,5,"<p>It's really simple. There is no default argument in <a href=""/questions/tagged/c"" class=""post-tag"" title=""show questions tagged &#39;c&#39;"" rel=""tag"">c</a>, the code is invalid. You can always use <a href=""/questions/tagged/c%2b%2b"" class=""post-tag"" title=""show questions tagged &#39;c++&#39;"" rel=""tag"">c++</a> which has default arguments and are very useful. But in <a href=""/questions/tagged/c"" class=""post-tag"" title=""show questions tagged &#39;c&#39;"" rel=""tag"">c</a> there is no way to achieve that.</p>
",0
37450442,37450108,5,"<p>C doesn't support default arguments, though you can sometimes hack something like them using the preprocessor:</p>

<pre><code>void func(int a, int b);
#define TWO_ARGS(A, B, ...)  A, B
#define func(...) func(TWO_ARGS(__VA_ARGS__, 1))

func(1, 2);  /* calls func(1, 2); */
func(1);     /* calls func(1, 1); */
</code></pre>
",0
39624169,39624015,1,"<p><em>Associative Arrays</em>, also called <em>Maps</em> or <em>Hashed Maps</em> or <em>Red-Black-Trees</em> would be the right solution for large amounts. Google 'std:map' for more details (that is C++, but you can use the concept, of course you have to implement it yourself)</p>

<p>For small amounts (maybe up to 20 or 30), a simple loop through is even faster, as there is no hashing overhead.</p>
",0
39624219,39624015,1,"<p>In the above example, domain of values is 8 bit so you can have an array of 256 values for that. Similarly if you a set of thousand values, you can simply have an array of that size. Although, this approach will be rough on memory, but it will give O(1) time complexity.</p>

<p>If the domain and range of values is unknown, then a hashtable/hashmap can be implemented. Although, that would be hard to implement but it will give O(1) time complexity.</p>

<p>Iteration would be easy to implement, but O(n) time complexity would be there.</p>
",5
39626735,39624015,0,"<p>With only 3 possible input values mapping to 3 consecutive values.</p>

<pre><code>int getIndexFromWeirdValue(int x) {
  static const int x[3] = {0xFE, 0x84, 0x35};
  static const int y[3] = {0,1,2};
  return (x==x[0])*y[0] + (x==x[1])*y[1] + (x==x[2])*y[2];
}
</code></pre>

<p>Other methods exist that perform in a similar non-branching fashion.</p>

<p>Using 4-byte math to map 1 byte to 1 byte and <code>x[]</code> are distinct, always an answer of the form below can be made - fast if <code>int</code> division is fast  YMMV.  C0, C1, C2, D based on mapping.  If mapping is constant, these values can be determined at compile time.</p>

<pre><code>y = (((C0*x + C1)*x + C2)/D + y[0];
</code></pre>
",0
34935947,34935907,3,"<p>You cannot use:</p>

<pre><code>for (i = 0; i &lt; sizeof(vars_array); i++)
{
    vars_array[i] = nnn;
}
</code></pre>

<p>However, if you are willing to store an array of pointers, you can use:</p>

<pre><code>int* vars_array[] = {&amp;var1, &amp;var2, &amp;var3};
for (i = 0; i &lt; sizeof(vars_array)/sizeof(vars_array[0]); i++)
{
    *vars_array[i] = nnn;
}
</code></pre>
",2
34936498,34935907,1,"<p>Of course you can. You would need a union:</p>

<pre><code>union {
 struct {
  int var1, var2, var3;
 };
 int vars_array[3];
}name;
</code></pre>

<p>Although this way you should prefix your variable instances with 'name.'. You can't omit it and export the identifiers in the enclosing space (as unnamed structure and union members) for some reason.</p>

<p>Your code for accessing array elements (which directly map to your variables - eventually?) should look like this: </p>

<pre><code>for (i = 0; i &lt; sizeof(name.vars_array) / sizeof(int); i++)
{
    name.vars_array[i] = nnn;
}
</code></pre>
",1
34936071,34935907,0,"<p>No, you can't do this.  (Note: you might be able to pull it off with some sort of horrid memory map, don't do it).  You generally want to avoid dynamically referencing variables by name <em>even if the language allows it</em>.  It makes understanding the code very difficult.  What you want instead is an array or <a href=""https://en.wikipedia.org/wiki/Hash_table"" rel=""nofollow"">hash table</a> to store and retrieve data in pairs.</p>

<p>If the variables are simply numbered <code>var1</code>, <code>var2</code>, <code>var3</code>... then instead of using individual variables, put the values in an array.</p>

<pre><code>int vars[] = { 23, 42, 99 };
for( int i = 0; i &lt; 3; i++ ) {
    printf(""vars%d: %d\n"", i, vars[i]);
}
</code></pre>

<p>If the variable names are not numbers, or the numbers are not contiguous, then the general idea is to use a hash table.  This is like an array, but instead of using numbers of the index it uses strings.  Lookup is fast, but it inherently has no order.</p>

<p>C doesn't have hashes built in, so you'll have to use a library like <a href=""https://developer.gnome.org/glib/stable/glib-Hash-Tables.html"" rel=""nofollow"">Gnome Lib</a>.</p>

<pre><code>#include &lt;glib.h&gt;
#include &lt;stdio.h&gt;

int main() {
    /* Init a hash table to take strings for keys */
    GHashTable *vars = g_hash_table_new(g_str_hash, g_str_equal);

    /* For maximum flexibility, GHashTable expects the keys and
       values to be void pointers, but you can safely store
       integers by casting them */
    g_hash_table_insert(vars, ""this"", (gpointer)23);
    g_hash_table_insert(vars, ""that"", (gpointer)42);
    g_hash_table_insert(vars, ""whatever"", (gpointer)99);

    /* And casting the ""pointer"" back to an integer */
    printf(""'this' is %d\n"", (int)g_hash_table_lookup(vars, ""this""));

    g_hash_table_unref(vars);

    return 0;
}
</code></pre>

<p><a href=""http://www.ibm.com/developerworks/linux/tutorials/l-glib/index.html"" rel=""nofollow"">Here's a good tutorial on using Gnome Lib</a>.</p>
",1
43208884,43208622,2,"<ul>
<li>When <code>array</code> is used in an expression, it ""decays"" to a pointer of the first element. </li>
<li>The first element of a 2D array <code>int[2][3]</code> is a 1D array <code>int[3]</code>. </li>
<li>Therefore the expression <code>array+1</code> gives a pointer to such a 1D array. </li>
<li>The expression <code>array+1</code> has type <code>int(*)[3]</code>, an array pointer to an array of 3 integers.</li>
<li>When you do <code>+ 1</code> on any pointer, pointer arithmetic is invoked and you get ""plus one pointed-at object"", rather than ""plus one byte/address"".</li>
<li>Thus <code>array+1</code> gives the second array of type <code>int[3]</code> in your 2D array.</li>
</ul>

<hr>

<ul>
<li><code>&amp;array</code> is different, it gives a pointer to the address of the array itself. A pointer to a 2D array, type <code>int(*)[2][3]</code>. </li>
<li>If you do <code>&amp;array + 1</code> you therefore do pointer arithmetic on objects that are 2D arrays and end up pointing ""one 2D array outside the allocated array"", which probably isn't meaningful.</li>
</ul>
",7
37906797,37906722,1,"<p>if S_ISLNK is defined:</p>

<pre><code>S_ISLNK(file_info.st_mode) 
</code></pre>

<p>Otherwise</p>

<pre><code>if ((file_info.st_mode &amp; S_IFMT) == S_IFLNK)
</code></pre>

<p>So in your example:</p>

<pre><code>if (lstat(file-&gt;full_path, &amp;file_info) == 0)
   printf(((file_info.st_mode &amp; S_IFMT) == S_IFLNK)  ? ""l"" : """");
else
   printf(""Could not get file stat info\n"");
</code></pre>

<p>Note that if lstat doesnt return 0, it wont have any valid info in the file_info structure.</p>
",0
34958217,34958189,2,"<pre><code>char* input;
scanf(""%s"",&amp;input);
printf(""%s\n"",input);
</code></pre>

<p>Let's take it line by line.</p>

<ol>
<li>Okay, so <code>input</code> is a <code>char *</code>.</li>
<li>But we read a string into it.</li>
</ol>

<p>So we have enough space for a pointer to a character, but then we try to store however many characters are input there. So if more characters are input than the number used to store a pointer to a character, we crash.</p>

<p>If you want to store a string, you need to allocate space for a string, like you do in your second example that gives no error. Just change the middle line to <code>scanf(""%s"",input);</code>. You want <code>input</code> to decay to a pointer to its contents.</p>
",1
46027062,462345,0,"<pre><code>long long t1;             //signed
unsigned long long t2;    //unsigned

printf(""%lld"",t1);
printf(""%llu"",t2);
</code></pre>
",0
45062190,9081136,0,"<p>Your construction works in C++, where a const int will be treated as a compile-time constant (""constant expression""), and hence available for use as a compile-time array size.</p>

<p>(This aspect was one of B. Stroustrup's design goals for C++, to eliminate the need for compile-time macros if possible)</p>

<p>However in C, your definition of ""num_fields"" effectively declares a read-only memory location with your preset value, and hence is not under C rules a ""constant expression"" valid at compile time, and hence may not be used as an array size at the outermost 'program' scope.</p>
",0
41906064,41906044,1,"<p>There are no built-in strings in C, let alone string operators. Null-terminated string literals is where string support ends at the language level; everything else is done in the standard library.</p>

<p>Operator <code>+</code> adds number 10 to the value of the <em>pointer</em>, to which your string literal is converted. This produces a pointer to the middle of the string, which is what gets printed once <code>%s</code> format specifier is applied.</p>

<p>Essentially, this expression</p>

<pre><code>""The value set for struct a "" + book.a
</code></pre>

<p>does the same thing as this code:</p>

<pre><code>char prtStr[] = ""The value set for struct a "";
char *ptrMid = &amp;ptrStr[book.a];
printf(""%s"", ptrMid);
</code></pre>

<p>If you want to print <code>10</code> after the string, use <code>%d</code>, like this:</p>

<pre><code>printf(""The value set for struct a %d"", book.a);
</code></pre>
",2
41906066,41906044,1,"<p>The string <code>""The value set for struct a ""</code> is represented as a pointer to the memory that holds a null-terminated array of characters. By adding <code>book.a</code> (10) to it, you referred to the tenth element of the buffer, which is <code>""s""</code>. What you need is:</p>

<pre><code>printf(""The value set for struct a %d"", book.a);
</code></pre>
",0
41906076,41906044,2,"<p>A string constant in some contexts decays into a pointer to the first element, which is what is happening here.  When you then add an integer value to a pointer it increments the pointer by that many (in the case of a <code>char *</code>) bytes.</p>

<p>Since <code>book.a</code> is 10, you're adding 10 to the value of the pointer.  So you now have a pointer to the 10th element in the string.  That's what <code>printf</code> receives, and that's where it starts printing from.</p>



<pre><code>""The value set for struct a""
          ^--- 10th character
</code></pre>
",0
39676066,39675648,2,"<p>First, let's ignore the 2D array aspect.  It's not quite relevant to a fundamental misunderstanding that you have about arrays and pointers, and it adds extra complication.</p>

<p>With <code>var1</code>, you're basically attempting to declare a global variable:</p>

<pre><code>int x[];
</code></pre>

<p>which isn't legal.  Based on your comments, you seem to be under the mistaken impression that this declares a pointer, but it instead declares an array of unspecified size.  As a global variable, the compiler must be able to allocate memory for this array, but that isn't possible without knowing its size.</p>

<p>Note that this would be different if such a declaration were used for a function parameter:</p>

<pre><code>void foo(int x[]);
</code></pre>

<p><a href=""http://www.c-faq.com/aryptr/aryptrparam.html"" rel=""nofollow""><em>When used as function parameters</em>, <code>int x[]</code> and <code>int* x</code> are interchangeable.</a> The function does not allocate any space for the array; the array must have been allocated already, and the function instead takes a pointer to that array (or more precisely, to the array's first element).</p>

<p>Pointers and arrays are not the same thing.  Arrays <em>decay</em> into pointers in <em>certain contexts</em>, and function parameters allow using either syntax, but they are otherwise distinct.</p>

<hr>

<p>Based on what you're trying to do in <code>check_func</code>:</p>

<pre><code>var1 = &amp;var2[0][0];
</code></pre>

<p>you probably want to declare <code>var1</code> simply as:</p>

<pre><code>int* var1;
</code></pre>

<ol>
<li><code>var2</code> is a 2D array of <code>int</code>.</li>
<li>Therefore <code>var2[0][0]</code> is of type <code>int</code>.</li>
<li>Therefore <code>&amp;var2[0][0]</code> is of type <code>int*</code>.</li>
<li>Therefore <code>var1</code> should be of type <code>int*</code> to match.</li>
</ol>
",2
44359623,19405254,0,"<p>If you want to take the fgets input and input all of it into an array of arrays or string array how could you do that. I have tried different things but get seg faults</p>
",0
48018465,48018419,3,"<p>You can clear the high 8 bits with:</p>

<pre><code>value &amp;= 0x00FFFFFF;
</code></pre>

<p>Note that the 00 is not actually needed, it's just there for clarity. And if you want to set all of the high 8 bits:</p>

<pre><code>value |= 0xFF000000;
</code></pre>
",1
48018559,48018419,1,"<p>If you want to clear those bits and set them to zero:</p>

<pre><code>parameters &amp;= 0x00ffffff;    // (mask for bits [0, 24)
</code></pre>

<p>Alternatively let's say you have a mask for those upper 8-bits:</p>

<pre><code>enum {bitmask = 0xff000000}; // (mask for bits [24, 32)
</code></pre>

<p>You can likewise clear those upper 8-bits (bits <code>[24, 32)</code> or <code>[24, 31]</code>) using the complement of the mask:</p>

<pre><code>parameters &amp;= ~bitmask; // (~0xff000000 == 0x00ffffff)
</code></pre>

<p>Using a bitwise complement might seem wasteful here if you can avoid it but typically optimizers are more than smart enough to eliminate it if <code>bitmask</code> is known at compile-time. If you want to set bits in the range, <code>[24, 32)</code> to <code>some_value</code> then:</p>

<pre><code>parameters &amp;= ~bitmask;           // clear bits [24, 32)
parameters |= (some_value &lt;&lt; 24); // shift some_value to occupy
                                  // bits [24, 32) and combine the
                                  // bits.
</code></pre>

<p>Note that <code>some_value</code> should have a range that fits in 8-bits. We're basically left-shifting those 8 bits to occupy bits <code>[24, 32)</code>. Then the <code>bitwise or</code> combines the bits which, after clearing those upper 8 bits, has the effect of setting them to that value. Then you can pull the value back out again using:</p>

<pre><code>some_value = (parameter &gt;&gt; 24);
</code></pre>

<p>You don't actually need to do a <code>bitwise and</code> here with <code>0xff</code> if you can guarantee that <code>parameter</code> is 32-bit or that any bits beyond bit 32 will not be used/set. Otherwise:</p>

<pre><code>some_value = (parameter &gt;&gt; 24) &amp; 0xff;
</code></pre>

<p>Or if you have that bitmask handy:</p>

<pre><code>some_value = (parameter &amp; bitmask) &gt;&gt; 24;
</code></pre>

<p>Often it can be handy to define both a mask and shift value, like so:</p>

<pre><code>enum
{
     shift = 24,
     bitmask = 0xff000000, // mask for bits [24, 32)
};
</code></pre>

<p>Then you can generalize this to:</p>

<pre><code>// fetching some value:
some_value = (parameter &amp; bitmask) &gt;&gt; shift;

// setting some value:
parameter = (parameter &amp; ~bitmask) | (some_value &lt;&lt; shift);
</code></pre>

<p>And that works regardless as long as you set the bitmask and shift value. If you want to set bits in the range: <code>[8, 24)</code> (16-bits) then we simply do:</p>

<pre><code>enum
{
     shift = 8,
     bitmask = 0x00ffff00, // mask for bits [8, 24)
};
</code></pre>

<p>And the code above should work just fine.</p>
",0
41173518,41173499,8,"<p>From the <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf"" rel=""nofollow noreferrer"">C specification</a>, section 6.7.2:</p>

<blockquote>
  <p>¡ª unsigned, or unsigned int</p>
</blockquote>

<p>Meaning that <code>unsigned</code>, when not specified the type, shall default to  <code>unsigned int</code>. So writing <code>unsigned a</code> is the same as <code>unsigned int a</code>.</p>
",2
34970355,34970331,3,"<p>The problem here is that when you enter an operator, you enter the operator <em>and</em> press the <kbd>Enter</kbd> key, and that <kbd>Enter</kbd> key adds a newline in the input buffer which you will read but not handle.</p>
",0
34971164,34970331,-1,"<pre><code>fflush(stdin);
</code></pre>

<p>When you received a input from <code>ch=getchar()</code>, you input one character and press enter, newline character is added in the input buffer too.</p>

<p>Try to use <code>fflush(stdin)</code> or <code>while(getchar()!='\n');</code></p>
",2
39687813,39687668,2,"<p>You need to extract the parts of <code>schedule</code> into the right structure, not just <code>int</code>.</p>

<p>Also timestr is not quite long enough so some of your other variables might be  being overwritten by <code>interpretTime</code> </p>
",3
39377240,39377184,3,"<p>By using the <code>%u</code> specifier you tell <code>sscanf</code> that you want to read an <code>an unsigned int</code> in decimal format (base 10). If you want hex input (base 16) you must use the <code>%x</code> specifier. Further you need to specify the correct integer size. For <code>unsigned char</code> you will need <code>hh</code> as length modifier. Using the wrong length modifier is a cause of undefined behaviour.</p>

<p>So you should try the <code>%hhx</code> specifier. Something like:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void){
    unsigned char Data = 0xff;

    char argv1[20] = ""0x40"";

    sscanf(argv1, ""0x%hhx"", &amp;Data);

    printf(""data is %u\n"", Data);

    return 0;

}
</code></pre>

<blockquote>
  <p>Output: data is 64</p>
</blockquote>

<p>For <code>unsigned short</code> in hex you should use <code>%hx</code></p>
",6
39377270,39377184,2,"<p>The <code>unsigned char</code> specificier for C99 and later is <code>%hhx</code></p>
",0
47477975,47477932,-1,"<p>You can do it this way:</p>

<pre><code>int main()
{
   if(!f()){
     return 0;
   }else{
     g()
   }
}
</code></pre>
",3
47478018,47477932,2,"<p>You can exit from the application like below:</p>

<pre><code>int main()
{
  if (f())//if statement does not require `}` if it has only one statement. Here it is only `exit(1)` statement.
    exit(1);// error exit, you can use return 1; as well. Because here f() returns 1
  g();
  exit(0);  // correct execution exit. You can use return 0; as well.
}
</code></pre>

<p>Now you can check the exit status like below:-</p>

<p>UNIX/LINUX
<code>echo $?</code></p>

<p>WINDOWS
<code>echo %ERRORLEVEL%</code></p>
",5
47491385,47477932,0,"<pre><code>int f();
int g();

int main()
{
  int value;
   if(!f()){

 return 0;
 }else{
 value= g();
    } 

 return value;
 }

int f()
 {

   if(stat=='correct'){
    // In case of success
   return 1;
  }
   else{ // In case of fail
    return 0;}
  } 

  int g()
 {
    if(stat=='correct'){
    // In case of success
   return 1;
  }
    else{ // In case of fail
    return 0;}
  }
</code></pre>
",0
41666335,41665900,2,"<p>Most current operating systems do not allow bit access to files. Files are read via system calls (<code>read()</code>...) or Standard library functions (<code>getc()</code>, <code>fread()</code>...) on a byte by byte basis.</p>

<p>In order to manipulate the contents as bits, you need to know how these bits are stored (packed) into the file bytes.</p>

<p>Sometimes bits are packed into the low order bits first, sometimes into the high order bits first, sometimes this packing in done on a word basis, which adds an extra layer of complexity as words can be stored in least significant byte first (aka little endian format) or in most significant byte first (aka big endian format).</p>

<p>A common approach is to keep a one byte buffer along with a count of unread bits:</p>

<pre><code>typedef struct bitreader {
    FILE *stream;
    int bits;
    unsigned char buffer;
} bitreader;

bitreader *bitopen(const char *filename) {
    bitreader *bp = calloc(sizeof(*bp));
    if (bp) {
        bp-&gt;stream = fopen(filename, ""rb"");  // open in binary mode
        if (bp-&gt;stream == NULL) {
            free(bp);
            bp = NULL;
        }
    }
    return bp;
}

void bitclose(bitreader *bp) {
    fclose(bp-&gt;stream);
    free(bp);
}

/* simplistic method to read bits packed with most significant bit first */
long long int bitread(bitreader *bp, int count) {
    long long int val = 0;
    while (count &gt; 0) {
        if (bp-&gt;bits == 0) {
            int c = getc(bp-&gt;stream);
            if (c == EOF)
                return EOF;
            bp-&gt;buffer = c;
            bp-&gt;bits = 8;
        }
        val &lt;&lt;= 1;
        val |= (bp-&gt;buffer &gt;&gt; 7) &amp; 1;
        bp-&gt;buffer &lt;&lt;= 1;
        bp-&gt;bits--;
        count--;
    }
    return val;
}
</code></pre>
",1
42657136,42656880,3,"<p>Yes, you can include an .y file into a .c file. And you can simply have only one file. That's possible and no infringement of the standard.</p>

<p>The reason for having two files per ""module"" is, that you can distinguish between public parts in the .h file and private parts in the .c file. This allows the developer to restrict publications to what is needed. All other parts of the source code is kept private. This is called <a href=""https://en.wikipedia.org/wiki/Information_hiding"" rel=""nofollow noreferrer"">information hiding</a> and a important part of software architecture. You can google for that.</p>

<p>So, it is likely that you have declarations in the .c file. But this declarations are private. The <em>shall not</em> be read by others.</p>

<p>Beside this, the .c file can be compiled and deployed in compiled form. Therefor you do not have any .c file to include.</p>
",0
42657009,42656880,2,"<p>.c files include function implementations, not just declarations. While that may seem innocuous, if you included them, it can be extremely difficult to find if you accidentally included an implementation twice. Including a declaration twice is fine, as long as they're the same. But including an implementation twice is a compiler error that's hard to find.</p>

<p>Moreover, most compilation is done with a build file that has a list of source files somewhere. It's much easier to navigate a central list of source files in one place, than in the include directives from a series of files.</p>

<p>All this is to say that to include .h files, rather than .c files, decreases the likelihood of errors, and makes debugging easier.</p>
",7
37830408,18617483,0,"<p>You really don't need to check for each step which is greater (a or b).</p>

<p>Use following function to calculate gcd of two numbers.</p>

<pre><code>int gcd(int a ,int b){
    if(a % b == 0)
        return b;
    return gcd(b,a%b);
}
</code></pre>

<p>That's it. </p>
",0
35191788,35191745,2,"<p>You want function <a href=""http://www.cplusplus.com/reference/cstdio/fread/"" rel=""nofollow"">fread</a>:</p>

<pre><code>int byteStart = 100;
int byteEnd   = 200;
line = malloc(byteEnd-byteStart);            // Allocate enough space for your data.
fseek(file_ptr, byteStart, SEEK_SET);        // Go to your starting point
fread(line, 1, byteEnd-byteStart, file_ptr); // Read until your ending point.
</code></pre>
",1
35192256,35191745,2,"<p>First you need to find the byte position of the start of a line at the 1/4, 1/2, and 3/4 points. To do that: </p>

<ul>
<li><code>fseek</code> to the approximate position (e.g <code>fseek(filesize/4)</code>)</li>
<li>call <code>fgets</code> to read up to the next newline</li>
<li>call <code>ftell</code> to determine the offset</li>
</ul>

<p>The offset returned is the end of one quarter and the beginning of the next. </p>

<p>To read one quarter of the file:</p>

<ul>
<li><code>fseek</code> to the beginning of the quarter</li>
<li>call <code>fgets</code> to read a line</li>
<li>call <code>ftell</code> to see if you've reached the end of the quarter</li>
</ul>
",0
44710019,44709953,2,"<p>You probably wanted this:</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
  FILE *f;
  char buff[1000];

  f=fopen(""h900_28Mar09.txt"", ""r"");

  if (f == NULL)
  {
    printf(""Can't open file\n"");
    return 1;
  }

  while (fgets(buff, 35, f) != NULL)
  {
    printf(""%s\n"",buff);
  }

  fclose(f);
}
</code></pre>

<p>This program just opens the file <code>h900_28Mar09.txt</code> and reads and display it line by line.</p>

<p>Alternative way:</p>

<pre><code>...
char buff[1000], infile[] = ""h900_28Mar09.txt"";

f = fopen(infile,""r"");
...
</code></pre>
",2
41673295,19520008,-2,"<pre><code>****************************************************************
*              Simple Array Palindrome Program                 *                               
****************************************************************/
#include &lt;iostream&gt;
using namespace std;
int main (){
int arr_size;
int flag=0;
/*****************************************
 *             Array Size                *
 *****************************************/

cout&lt;&lt;""Enter The Array Size: \n-&gt;arr["";
cin&gt;&gt;arr_size;cout&lt;&lt;"" ]"";
int arr[arr_size];
/*****************************************
 *             User_Input                *
 *****************************************/


for(int i=0;i&lt;arr_size;i++){
cout&lt;&lt;""Enter Value For Arr[ ""&lt;&lt;i&lt;&lt;"" ]  -&gt; ""; 
cin&gt;&gt;arr[i];
} 
/*****************************************
 *           Palindrome_Check            *
 *****************************************/


for(int k=0,j=arr_size-1;k&lt;arr_size &amp;&amp; j&gt;-1;k++)
{

if(arr[i]==arr[j];
{
flag++;
}

}
/*****************************************
 *             Flag Check                *
 *****************************************/


if(flag==arr_size) {
cout&lt;&lt;""Array Is Palindrome: "";
}
else
{
cout&lt;&lt;""Array Is Not Palindrome: "";
}


}
</code></pre>
",2
37291862,37291681,1,"<p>It happened because of the Relational Operators in your <code>printf</code> statement.</p>

<p>Operator <code>==</code> and operator <code>!=</code></p>

<p>Since <code>(0 == 0)</code> holds true so, it gives a value <code>1</code> </p>

<p>whereas, <code>(0 != 0)</code> doesn't hold true so, gives a value <code>0</code> .</p>
",0
37291888,37291681,106,"<blockquote>
  <p>Does the C standard explicitly indicate the truth values of <code>true</code> and <code>false</code> as <code>0</code> and <code>1</code> respectively?  </p>
</blockquote>

<p>The C standard defines <code>true</code> and <code>false</code> as macros in <code>stdbool.h</code> which expand to <code>1</code> and <code>0</code> respectively.  </p>

<p>C11-¡ì7.18:  </p>

<blockquote>
  <p>The remaining three macros are suitable for use in <code>#if</code> preprocessing directives. They are  </p>

<pre><code>true
</code></pre>
  
  <p>which expands to the integer constant <code>1</code>,  </p>

<pre><code>false
</code></pre>
  
  <p>which expands to the integer constant <code>0</code> [...]    </p>
</blockquote>

<p>For the operators <code>==</code> and <code>!=</code> , standard says</p>

<p>C11-¡ì6.5.9/3:</p>

<blockquote>
  <p>The <code>==</code> (equal to) and <code>!=</code> (not equal to) operators are analogous to the relational operators except for their lower precedence.<sup>108)</sup> Each of the operators yields <code>1</code> if the specified relation is true and <code>0</code> if it is false. The result has type <code>int</code>. For any pair of operands, exactly one of the relations is true.  </p>
</blockquote>
",8
37292153,37291681,55,"<p>It is not explicitly indicated in C11. All <strong>language-level operations</strong> will return 1 as truthy (and accept any nonzero including NaN as true).</p>

<ul>
<li>If you concern about <code>_Bool</code>, then true must be 1 because the standard only require it to hold 0 and 1. (¡ì6.2.5/2). </li>
<li>Also in <code>&lt;stdbool.h&gt;</code> the macro <code>true</code> expands to <code>1</code> (¡ì7.18/3)</li>
<li><code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code> and <code>&gt;=</code> return 0 or 1 (¡ì6.5.8/6, ¡ì6.5.9/3).</li>
<li><code>!</code>, <code>&amp;&amp;</code> and <code>||</code> return 0 or 1 (¡ì6.5.3.3/5, ¡ì6.5.13/3, ¡ì6.5.14/3)</li>
<li><code>defined</code> expands to 0 or 1 (¡ì6.10.1/1)</li>
</ul>

<p>But all <strong>standard library functions</strong> e.g. <code>islower</code> just say ""nonzero"" for truthy (e.g. ¡ì7.4.1/1, ¡ì7.17.5.1/3, ¡ì7.30.2.1/1, ¡ì7.30.2.2.1/4).</p>

<hr>

<blockquote>
  <p><strong>¡ì6.2.5/2</strong>: An object declared as type <code>_Bool</code> is large enough to store the values 0 and 1.</p>
  
  <p><strong>¡ì6.5.5.3/5</strong>: The result of the logical negation operator <code>!</code> is 0 if the value of its operand compares unequal to 0, 1 if the value of its operand compares equal to 0. ¡­</p>
  
  <p><strong>¡ì6.5.8/6</strong>: Each of the operators <code>&lt;</code> (less than), <code>&gt;</code> (greater than), <code>&lt;=</code> (less than or equal to), and <code>&gt;=</code> (greater than or equal to) shall yield 1 if the specified relation is true and 0 if it is false.<sup>107) ¡­</p>
  
  <p><strong>¡ì6.5.9/3</strong>: The <code>==</code> (equal to) and <code>!=</code> (not equal to) operators are analogous to the relational operators except for their lower precedence.108)</sup> Each of the operators yields 1 if the specified relation is true and 0 if it is false. ¡­</p>
  
  <p><strong>¡ì6.5.13/3</strong>: The <code>&amp;&amp;</code> operator shall yield 1 if both of its operands compare unequal to 0; ¡­</p>
  
  <p><strong>¡ì6.5.14/3</strong>: The <code>||</code> operator shall yield 1 if either of its operands compare unequal to 0; ¡­</p>
  
  <p><strong>¡ì6.10.1/1</strong>: ¡­ it may contain unary operator expressions of the form ¡ª <code>defined identifier</code> ¡ª or ¡ª <code>defined ( identifier )</code> ¡ª which evaluate to 1 if ¡­ </p>
  
  <p><strong>¡ì7.4.1 (Character classification functions)/1</strong>: The functions in this subclause return nonzero (true) if and only if ¡­</p>
  
  <p><strong>¡ì7.18/3</strong>: The remaining three macros are suitable for use in <code>#if</code> preprocessing directives. They are ¡ª <code>true</code> ¡ª which expands to the integer constant 1, ¡­</p>
  
  <p><strong>¡ì7.17.5.1/3</strong>: The <code>atomic_is_lock_free</code> generic function returns nonzero (true) if and only if the object¡¯s operations are lock-free. ¡­</p>
  
  <p><strong>¡ì7.30.2.1 (Wide character classification functions)/1</strong>: The functions in this subclause return nonzero (true) if and only if ¡­</p>
  
  <p><strong>¡ì7.30.2.2.1/4</strong>: The <code>iswctype</code> function returns nonzero (true) if and only if ¡­</p>
</blockquote>
",0
37292332,37291681,11,"<p>You are mixing up a lot of different things: control statements, operators and boolean types. Each have their own rules.</p>

<p>Control statements work like for example the <code>if</code> statement, C11 6.4.8.1:</p>

<blockquote>
  <p>In both forms, the first substatement is executed if the expression
  compares unequal to 0.</p>
</blockquote>

<p><code>while</code>, <code>for</code> etc have the same rule. This has nothing to do with ""true"" or ""false"".</p>

<p>As for operators that are supposedly yielding a boolean result, they are actually yielding an <code>int</code> with value 1 or 0. For example the equality operators, C11 6.5.9:</p>

<blockquote>
  <p>Each of the operators yields 1 if the specified relation is true and 0
  if it is false</p>
</blockquote>

<p>All of the above is because C did not have a boolean type until the year 1999, and even when it did get one, the above rules weren't changed. So unlike most other programming languages where statements and operators yield a boolean type (like C++ and Java), they just yield an <code>int</code>, with a value zero or not zero. For example, <code>sizeof(1==1)</code> will give 4 in C but 1 in C++.</p>

<p>The actual boolean type in C is named <code>_Bool</code> and requires a modern compiler. The header <code>stdbool.h</code> defines macros <code>bool</code>, <code>true</code> and <code>false</code>, that expand to <code>_Bool</code>, <code>1</code> and <code>0</code> respectively (for compatibility with C++).</p>

<hr>

<p>It is however considered good programming practice to treat control statements and operators as if they actually required/yielded a boolean type. Certain coding standards like MISRA-C recommend such practice. That is:</p>

<p><code>if(ptr == NULL)</code> instead of <code>if(ptr)</code>. </p>

<p><code>if((data &amp; mask) != 0)</code> instead of <code>if(data &amp; mask)</code>.</p>

<p>The aim of such style is to increase type safety with the aid of static analysis tools, which in turn reduces bugs. Arguably, this style is only meaningful if you do use static analysers. Though in some cases it leads to more readable, self-documenting code, for example </p>

<pre><code>if(c == '\0') 
</code></pre>

<p>Good, the intent is clear, the code is self-documenting.</p>

<p>versus</p>

<pre><code>if(c) 
</code></pre>

<p>Bad. Could mean anything, and we have to go look for the type of <code>c</code> to understand the code. Is it an integer, a pointer or a character?</p>
",6
37292097,37291681,23,"<p>There are two areas of the standard you need to be aware with when dealing with Boolean values (by which I mean true/false values rather than the specific C <code>bool/_Bool</code> type) in C.</p>
<p>The first has to do with the <em>result</em> of expressions and can be found in various portions of <code>C11 6.5 Expressions</code> (relational and equality operators, for example) . The bottom line is that, whenever a Boolean value is generated by an expression, it ...</p>
<blockquote>
<p>... yields 1 if the specified relation is true and 0 if it is false. The result has type int.</p>
</blockquote>
<p>So, yes, the result of any Boolean-generating expression will be one for true, or zero for false. This matches what you will find in <code>stdbool.h</code> where the standard macros <code>true</code> and <code>false</code> are defined the same way.</p>
<p>Keep in mind however that, following the robustness principle of &quot;be conservative in what you send, liberal in what you accept&quot;, the interpretation of <em>integers</em> in the Boolean context is somewhat more relaxed.</p>
<p>Again, from various parts of <code>6.5</code>, you'll see language like:</p>
<blockquote>
<p>The <code>||</code> operator shall yield 1 if either of its operands <em>compare unequal to 0; otherwise, it yields 0.</em> The result has type int.</p>
</blockquote>
<p>From that (and other parts), it's obvious that zero is considered false and <em>any</em> other value is true.</p>
<hr />
<p>As an aside, the language specifying what value are used for Boolean generation and interpretation also appear back in C99 and C89 so they've been around for quite some time. Even K&amp;R (ANSI-C second edition <em>and</em> the first edition) specified that, with text segments such as:</p>
<blockquote>
<p>Relational expressions like <code>i &gt; j</code> and logical expressions connected by <code>&amp;&amp;</code> and <code>||</code> are defined to have value <code>1</code> if true, and <code>0</code> if false.</p>
<p>In the test part of <code>if</code>, <code>while</code>, <code>for</code>, etc, &quot;true&quot; just means &quot;non-zero&quot;.</p>
<p>The <code>&amp;&amp;</code> operator ... returns 1 if both its operands compare unequal to zero, 0 otherwise.</p>
<p>The <code>||</code> operator ... returns 1 if either its operands compare unequal to zero, and 0 otherwise.</p>
</blockquote>
<p>The macros in <code>stdbool.h</code> appear back in C99 as well, but not in C89 or K&amp;R since that header file did not exist at that point.</p>
",9
43729930,43728777,1,"<p>You can't include files like that in C. In C ""#include"" means a simple file insertion and is done on preprocessor level (like everything that starts with #), so it obviously can not depend on anything runtime(like value of turn)</p>

<p>However, it's not a big deal because you can still use functions from all 3 files simultaneously in many ways. The way that most system work is that they add preprocessor mechanic to names to operate them. 
Read this: <a href=""https://stackoverflow.com/questions/4396140/why-doesnt-ansi-c-have-namespaces"">Why doesn&#39;t ANSI C have namespaces?</a></p>

<p>The quick fix I see on preprocessor level is to simply use preprocessor to trick names, which works like a simple find and replace:</p>

<pre><code>#include ""AI_A.cpp""
#define decideAction AI_AdecideAction
...
#include ""AI_B.cpp""
#define decideAction AI_BdecideAction
</code></pre>

<p>Also, don't forget the headers(if any) and watch out for all conflicts, and it will work.</p>
",0
35273049,35272652,4,"<p>It depends on the C library you're using. Glibc, for example, supports custom streams through <a href=""https://www.gnu.org/software/libc/manual/html_node/Streams-and-Cookies.html#index-fopencookie"" rel=""nofollow"">fopencookie</a> (<a href=""https://www.gnu.org/software/libc/manual/html_node/Custom-Streams.html#Custom-Streams"" rel=""nofollow"">further documentation here</a>). FreeBSD  (and probably other BSDs as well, including OS X) have <a href=""https://www.freebsd.org/cgi/man.cgi?query=funopen&amp;sektion=3&amp;apropos=0&amp;manpath=FreeBSD+10.2-RELEASE+and+Ports"" rel=""nofollow"">funopen</a>. It doesn't look like Microsoft's C library supports such a feature.</p>
",1
42473889,23115462,1,"<p>A <strong>construct</strong> is simply a concept implementation mechanism used by a given programming language - the language's syntax.</p>

<p>In your case, the concept here is a loop and its construct is the manner in which it is implemented by the C programming language.</p>

<p>Programming languages provide constructs for various programming concepts that define how these programming concepts are implemented in that language.</p>

<blockquote>
  <p>Does the word 'construct' have an relation to an object 'constructor' in other languages?</p>
</blockquote>

<p>The two terms are different, a constructor is used in Object Oriented Languages such as java, it is not available in the C programming language.</p>
",0
35213074,35213005,1,"<p>The first concern is to make sure that the two strings both have enough space to be swapped.</p>

<p>You can see the problem with trying to swap <code>""Hello""</code> with <code>""ThisIsAVeryLongStringThatWillNotFitInTheSpaceOfHello""</code>; there just isn't enough space in the first buffer to hold the second buffer.</p>

<p>Assuming there is enough space, you just need to swap every character, one-by-one until the entire strings are swapped.</p>

<pre><code>void swapStrings(char string1[], char string2[])
{
    char temp;
    do
    {
        temp = *string1;
        *string1 = *string2;
        *string2 = temp;
    } while(*string1++ &amp;&amp; *string2++);

    // At this point, the shorter string is done swapping.
    // But we need to finish swapping the longer string:

    if (*string1)
    {
        while (*string2++ = *string1++) ; 
    }
    if (*string2)
    {
        while (*string1++ = *string2++) ; 
    }
}
</code></pre>

<p><strong><em>Note</em></strong> contrary to the answer by <code>cdonts</code>, no third buffer needs to be allocated or managed.  The memory requirement is much smaller because there is only a single byte needed for swapping the strings.</p>
",0
35213117,35213005,1,"<p>In C you can't copy strings using the assignment operator, so you'll probably want something like this.</p>

<pre><code>size_t length = strlen(string1) + 1;
char *tempString = malloc(length);
strncpy(tempString, string1, length);
free(tempString);
</code></pre>

<p>(Assuming both strings have enough space to be swapped as @abelenky said.)</p>

<p>Hope it helps!</p>
",0
40557506,40557434,0,"<p>It appears that you have not allocated memory to store the commands. You have only allocated an array of pointers, so your behavior is actually undefined. The fix is to allocate memory and initialize it.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

int main(){
    char* inputLine = (char*)malloc(80);
    char* commands[80];
    char* input;
    int i;
    int numCommands = 0;
    fgets(inputLine, 80, stdin);
    input = strtok(inputLine, "" \n"");
    for (i=0; input != NULL; i++) {
        numCommands++;
        commands[i] = malloc(strlen(input) + 1);
        strncpy(commands[i], input, strlen(input));
        input = strtok(NULL, "" \n"");
    }

    for (i = 0; i &lt; numCommands; i++) {
        puts(commands[i]);
    }
}
</code></pre>
",8
40558276,40557434,0,"<p>So here is another solution of reading stdin and putting it into an arrary of tokens split by whitespaces:</p>

<pre><code>int main(void)
{
        char *line = NULL, *buf = NULL;
        size_t len = 0;
        size_t bufpos = 0, buflen = 0;
        ssize_t bytes = 0;
        char *p;
        char **command = NULL;
        size_t count = 0;
        int k;

        while((bytes = getline(&amp;line, &amp;len, stdin)) != -1)  {
                fprintf(stderr, ""buf:%p, bufpos:%lu, buflen: %lu\n"", buf, bufpos, buflen);
                buflen += bytes;
                buf = realloc(buf, buflen);
                strncpy(buf+bufpos, line, bytes);
                *(buf+bufpos+bytes-1) = ' '; /* change \n at the end to a space */
                bufpos = buflen;
        }

        free(line);

        if(buflen == 0) {
                exit(EXIT_FAILURE);
        }

        if(buf[buflen-1] == ' ')
                buf[buflen-1] = 0;

        command = malloc(sizeof(char *)); /* at least one command is there */

        /* mark all the commands */
        command[0] = buf;
        count = 1;
        for(p = buf; *p != 0; p++) {
                int delimit = 0;

                /* eatup consecutive whitespaces */
                while(isspace(*p)) {
                        delimit = 1;
                        *p = 0;
                        p++;
                        if(!*p || !isspace(*p))
                                break;
                }

                if(delimit) {
                        command = realloc(command, (1+count)*sizeof(char *));
                        command[count] = p;

                        count++;
                }
        }

        for (k = 0; k &lt; count; k++) {
                fprintf(stdout, ""%d : %s\n"", k, command[k]);
        }

        free(command);
        free(buf);

        return 0;
}
</code></pre>

<p>~  </p>

<p>A few things to note:</p>

<ol>
<li><p>This uses <code>getline</code>, which is a very safe way to read strings dynamically.</p></li>
<li><p>The <code>command</code> array is an array of pointers that points into various spots of <code>buf</code> array which contains everything that's read in. Which means that you're not reallocating strings all over the place.  You can now pass <code>buf</code> to <code>strtok</code> or, do what I did in the <code>for</code> loop that allocates and assigns commands. </p></li>
<li><p>This has more control on how you delimit the commmands</p></li>
<li><p>You can make this into a reenterant function.</p></li>
</ol>
",0
41946394,41946294,4,"<blockquote>
  <p>But that head pointer is allocated in heap!</p>
</blockquote>

<p>Not exactly, the memory portion to which the pointer points to is what is in heap. The pointer itself is stored in your function stack.</p>

<p>In the drawing, only <code>head</code> is shown in stack space, but the pointers <code>second</code> and <code>third</code> are also in the stack. The pointers here referring to the variable that holds an address. The address pointed by these variables is what is in heap.</p>

<p>Since <code>head-&gt;next</code> is assigned to <code>second</code>, you have two pointers to the same thing. And so forth with <code>third</code>. Note that <code>head-&gt;next</code> is a pointer stored in heap, and points to another heap memory address. It is the same as <code>second</code>, which is a pointer stored in stack with its address pointing to a heap memory location (again, the same as <code>head-&gt;next</code>). So another way to make a list is to allocate only the first (<code>head</code>) and use its <code>next</code> pointer to allocate the following element storing the address there directly. The drawback compared to what was used (with a direct pointer to the second and third elements) is that you lose this direct address. You'd need to visit the first and the second to find the address of the third.</p>
",0
34979380,34979114,0,"<p>If you have a two-dimensional array like this</p>

<pre><code>int a[M][N];
</code></pre>

<p>then in expressions arrays are implicitly converted to pointers to their first element.</p>

<p>So this expression</p>

<pre><code>a
</code></pre>

<p>has type <code>int ( * )[N]</code> and points to the first ""row"" (element) of the two-dimensional array.</p>

<p>Expression</p>

<pre><code>a + i
</code></pre>

<p>where i some intager in the range <code>0 - M - 1</code> point to i-th row of the array</p>

<p>Expression</p>

<pre><code>*( i + i )
</code></pre>

<p>gives the row that is i-th element of the array.</p>

<p>You can write for example</p>

<pre><code>printf( ""%zu\n"", sizeof( a[i] ) );
</code></pre>

<p>and the statement outputs a value that is equal to <code>N * sizeof( int )</code></p>

<p>On the other hand if this expression</p>

<pre><code>*( i + i )
</code></pre>

<p>is used in other context then as an operand of the <code>sizeof</code> operator then it in turn (as it is an array) is converted to pointer to its first element.</p>

<p>Thus expression</p>

<pre><code>*( i + i )
</code></pre>

<p>is implicitly converted to pointer of type <code>int *</code> that points to the first element of the i-th row of the original array.</p>

<p>Expression</p>

<pre><code>*( i + i ) + j
</code></pre>

<p>points to th j-th element of the i-th row of the array</p>

<p>As result expression</p>

<pre><code>*( *( i + i ) + j )
</code></pre>

<p>is equivalent to </p>

<pre><code>a[i][j]
</code></pre>

<p>If you dynamically allocated a two dimensional array the following way</p>

<pre><code>int ( *a )[N] = malloc( sizeof( int[N][M] );
</code></pre>

<p>then you at once got the pointer of the same type and having the same value as  the expression shown above for the two-dimensional array</p>

<pre><code>a
</code></pre>

<p>So when you have initially a pointer then the step that implicitly converts a two-dimensional array to a pointer is simply skipped. But the net result will be the same.</p>

<p>If you allocated dynamically an array of pointers the following way</p>

<pre><code>int **a = malloc( M * sizeof( int * ) );
for ( size_t i = 0; i &lt; M; i++ ) a[i] = malloc( N * sizeof( int ) );
</code></pre>

<p>then <code>a</code> points to the first element of the dynamically alllocated first array.</p>

<pre><code>a + i
</code></pre>

<p>gives the pointer to the i-th element of the array.</p>

<p>Expression</p>

<pre><code>*( a + i )
</code></pre>

<p>gives the value stored in this element. This value is the address of the i-th allocated array in the loop aboth. It has type <code>int *</code>.</p>

<p>So</p>

<pre><code>*( a + i ) + j
</code></pre>

<p>gives the pointer to the j-th element and at last</p>

<pre><code>*( *( a + i ) + j )
</code></pre>

<p>is the unteger value stored in this element.</p>
",0
34979135,34979114,0,"<blockquote>
  <p>Why does it work to access a dynamically allocated 2D array element with a[i][j]?  </p>
</blockquote>

<p>That's because pointer arithmetic and array indexing are same. Theexpression  </p>

<pre><code>array[i][j]  
</code></pre>

<p>is equivalent to <code>*(*(array + i) + j))</code>. In this expression <code>array</code> converts to pointer to its first element and hence becomes of type <code>int(*)[6]</code>, i.e. pointer to an array of 6 <code>int</code>. Adding <code>i</code> to <code>array</code> will increment it to <code>i*sizeof(int[i])</code> bytes. Therefore, saying <code>array[i][j]</code> is translated to <code>*(((int *)array)+i*6+j)</code> is wrong.<br>
So, dereferencing <code>array + i</code> will give an array of 6 <code>int</code> which further will decay to pointer to its first element <code>array[i][0]</code> having type <code>int *</code>. Therefore, <code>array[i][j]</code> is equivalent to  <code>*(&amp;array[i][0] + j))</code> </p>

<p>When array is allocated dynamically  </p>

<pre><code>int **array =  malloc(sizeof(int*)*10);  
for(int i =0; i &lt; 10; i++)
    array[i] = malloc(sizeof(int)*6);  
</code></pre>

<p>then its element can also be accessed using <code>array[i][j]</code>. This expression is also equivalent to <code>*(*(array + i) + j))</code>. But, the difference here is <code>array</code> is of type <code>int **</code> and adding <code>i</code> to it will increment it by <code>i*sizeof(int*)</code>. Dereferencing <code>array + i</code> will give <code>array[i]</code> which is of type <code>int *</code> and hence <code>array[i][j]</code> is equivalent to  <code>*(&amp;array[i][0] + j))</code>.     </p>

<p>That said, in both cases <code>array + i</code> increment it to its next element (which can either be of type <code>int[6]</code> or <code>int *</code>) and finally arithmetic is between <code>int *</code> (<code>&amp;array[i][j]</code>) and <code>int</code> (<code>j</code>).</p>
",0
40753344,40753170,3,"<ol>
<li>You can not change a string literal.</li>
<li>Character display with <code>printf</code>. E.g <code>printf(""%c"", character);</code>, not &amp;character</li>
</ol>

<p>try this.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void print_reverse_str(char *str){
    if (*str){
        print_reverse_str(str+1);
        printf(""%c"", *str);
    }
}

int main(){
    print_reverse_str(""My string"");
    printf(""\n"");
    print_reverse_str(""!ti tog uoy ,siht daer nac uoy fI"");
    printf(""\n"");
}
</code></pre>
",1
44355182,44355040,2,"<p>You have the following:</p>

<pre><code>char somecharvariable;
char outfile[7];
int fileNo = 0;
sprintf(outfile, ""%03d.jpg"", fileNo);
</code></pre>

<p>Oops. The string null terminator wrote over fileno. outfile should be length 8. If you allow fileNo to exceed 999 your code will crash anyway.</p>

<p>Putting the static flag on fileNo does not fix the problem. It merely relocates the problem to some other variable.</p>
",2
42500331,42498427,1,"<p>The function calls go on stack (their activation records), in this case the two functions foo and bar are identical in terms of parameters, return type and the local variables within each function. So the first call puts something on the stack and once done its activation record is popped out but not cleaned (compiler does not generate code to clean things up). Now the second function call essentially ends up using the same memory location and therefore gets the value from a previous call using same memory area. The values that are not initialized in a function are considered undefined. In the foo and bar case we got to the same value due to similar signature of two functions and same type and location of the variable. Try adding two integers or integer and a float in one function and reverse the order in next and you'll see the effects. Of course when you call the optimizer it might place things on register and as a result you may get undefined values when the compiler sees no scope for optimization as in case of foo.</p>
",0
42508256,42498427,2,"<p>Yes, the value 42 is a garbage. Here is the explanation for it:</p>

<p>Every function in stack, starts similar to this order</p>

<ol>
<li>Parameters of the function</li>
<li>Return value of the function</li>
<li>EBP( Which stores previous frame pointer)</li>
<li>Exception handler frame</li>
<li>Local variables</li>
<li>Buffer</li>
<li>callee save register</li>
</ol>

<p>In the above example, <code>main()</code> is called and follows the procedure as above. </p>

<p>Then it encounters the <code>bar()</code> follows 1,2,3,4 steps mentioned and then stores the local variable <code>a=42</code> in the memory(5) then 6,7 are followed then it will come out of the memory.  </p>

<p>Then it encounters the <code>foo()</code> follows 1,2,3,4 steps as same in the memory location that <code>bar()</code> had. And you declared a local variable called <code>a</code> which will point to same memory location that <code>bar()</code> holding the local variable <code>a=42</code>. So it is giving the same value 42 when you are printing, which is actually a garbage value.</p>

<p>To validate this, try this example: This prints 7</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void foo() {
    int b;
    printf(""%d\n"",b);
}

void zoo() {
  int dummy = 7;
}
void bar(){
    int a1=3;
}

int main(){
    bar();
    zoo();
    foo();
    return 0;
}
</code></pre>

<p>Ref: <a href=""http://www.tenouk.com/Bufferoverflowc/Bufferoverflow2a.html"" rel=""nofollow noreferrer"">Doc</a></p>
",0
42542015,42541987,11,"<p><code>a</code> is expanded, not evaluated as <code>a</code>. So you get:</p>

<pre><code>4+5*4+5 
</code></pre>

<p>and with operator priorities; you get <code>4 + 20 + 5 =&gt; 29</code></p>

<p>better way (with extra outside parenthesis for protecting against outside operators too thanks to Thomas comment):</p>

<pre><code>#define fun(a) ((a)*(a))
</code></pre>

<p>but all parenthesis of the world still don't protect against <code>i++</code>, function calls (with side effects, preferably)... so argument reusing in macros is always a problem (there's no syntax to declare &amp; assign a temp variable either). Prefer inlined functions in that case.</p>
",5
37451970,37451319,1,"<p>You don't have to do anything special.  Your code works, as long as you know how to demonstrate that it works.  Here's a mildly extended version of it:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

static void createFile(void)
{
    char command[100];
    sprintf(command, ""dd if=/dev/zero of=file.data bs=8 count=32"");  // Typo fixed!
    system(command);
}

static void writeFile(int position, char *data)
{
    FILE *file = fopen(""file.data"", ""r+"");
    fseek(file, position, SEEK_SET);
    fwrite(data, strlen(data), 1, file);
    fclose(file);
}

int main(void)
{
    createFile();
    system(""odx file.data"");
    writeFile(2, ""012"");
    system(""odx file.data"");
    return 0;
}
</code></pre>

<p>The <code>odx</code> command is a hex dump program; you could use <code>od -c</code> or <code>xxd -g1</code> instead.</p>

<p>The sample output is:</p>

<pre><code>32+0 records in
32+0 records out
256 bytes transferred in 0.000109 secs (2349544 bytes/sec)
0x0000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
* (15)
0x0100:
0x0000: 00 00 30 31 32 00 00 00 00 00 00 00 00 00 00 00   ..012...........
0x0010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
* (14)
0x0100:
</code></pre>

<p>The first three lines are from <code>dd</code>.  I'm not convinced that using <code>dd</code> is necessary, but it does no great harm.  The next three lines indicate that the first 16 bytes in the file are all zero bytes, and that this pattern repeats for 15 more lines, and then you reach EOF at offset 0x100 (256<sub>10</sub>).  The next four lines show that there are 2 null bytes, then the three digits <code>012</code>, then all null bytes to the end of file.</p>
",0
36591697,36591516,2,"<p>First you need to initialize <code>total</code> to <code>0</code>.</p>

<p>Also, since you will be able to add more than once you need to add the value to <code>total</code> instead of overwriting the value.</p>

<p>After the <code>while</code>-loop you need to add logic for calculating the tax.</p>

<p>Since this is clearly homework I will not initially supply the actual code. 
Try it yourself first!</p>
",3
44714555,44714413,2,"<p>If your file may sometimes contain lines comprising only 3 parts, then the last entry of your <code>tokens</code>-array remains uninitialized. If you then access it, e.g. as in <code>printf(""[%s][%s][%s][%s]\n"", ...</code>, then you invoke undefined behaviour, often leading to something like ""segmentation fault"", or something else.</p>

<p>So I'd do two things:</p>

<p>First, make sure that your <code>tokens</code> array is initialized blank (i.e. with NULL). This can easily be achieved through <code>calloc</code> instead of <code>malloc</code>, e.g. <code>char **tokens = malloc(MAX_PARTS,sizeof(char *))</code>.</p>

<p>Second, make sure that you do not print <code>NULL</code>-pointers. E.g., write a loop like <code>for(char *s = tokens; s; s++) printf(""%s\n"",s)</code>.</p>

<p>BTW: Rethink if it is actually necessary to allocate memory for the tokens of each line separately. Probably you pass a ""pre-malloced"" array to <code>tokenize</code>, which then fills it up again and again. Note that in this case you somehow have to clear the array before each call.</p>
",1
37635633,37635535,13,"<p>The C standard (N1570) defines <em>digraphs</em>:</p>

<blockquote>
  <p><strong>6.4.6 Punctuators</strong><br>....</p>
  
  <p><strong>3</strong> &nbsp;&nbsp;In all aspects of the language, the six tokens</p>
  
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>&lt;:</code> <code>:&gt;</code> <code>&lt;%</code> <code>%&gt;</code> <code>%:</code> <code>%:%:</code></p>
  
  <p>&nbsp;&nbsp;behave, respectively, the same as the six tokens <sup>79)</sup></p>
  
  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>[</code> <code>]</code> <code>{</code> <code>}</code> <code>#</code> <code>##</code></p>
  
  <p>except for their spelling.<sup>80)</sup></p>
  
  <hr>
  
  <p>79) These tokens are sometimes called ¡®¡®digraphs¡¯¡¯.</p>
  
  <p>80) Thus <code>[</code> and <code>&lt;:</code> behave differently when ¡®¡®stringized¡¯¡¯ (see 6.10.3.2), but can otherwise be freely interchanged.</p>
</blockquote>

<p>As a side note, C++ standard elaborates on the term:</p>

<blockquote>
  <p>The term ¡°digraph¡± (token consisting of two characters) is not
  perfectly descriptive, since one of the alternative preprocessing-tokens is <code>%:%:</code> and of course several primary tokens contain two
  characters. Nonetheless, those alternative tokens that aren¡¯t lexical keywords are colloquially known as ¡°digraphs¡±.</p>
</blockquote>

<p>According to <a href=""https://en.wikipedia.org/wiki/Digraphs_and_trigraphs#C"" rel=""noreferrer"">Digraphs and trigraphs</a>:</p>

<blockquote>
  <p>In 1994 a normative amendment to the C standard, included in C99, supplied digraphs as more readable alternatives to five of the trigraphs. ....</p>
  
  <p>Unlike trigraphs, digraphs are handled during tokenization, and any digraph must always represent a full token by itself, or compose the token <code>%:%:</code> replacing the preprocessor concatenation token <code>##</code>. If a digraph sequence occurs inside another token, for example a quoted string, or a character constant, it will not be replaced.</p>
</blockquote>
",1
37635907,37635535,7,"<p>Searching the C99 Appendix A grammar, we have...</p>

<h2>punctuators</h2>

<p>Already covered by <a href=""https://stackoverflow.com/a/37635633/14660"">@AlexD</a>.</p>

<h2>conditional-expression (aka ternary)</h2>

<pre><code>logical-OR-expression ? expression : conditional-expression
</code></pre>

<h2>struct-declarator (aka struct bit-fields)</h2>

<pre><code>declarator[optional] : constant-expression
</code></pre>

<h2>labeled-statement (most often used in switch statements)</h2>

<pre><code>identifier : statement
case constant-expression : statement
default : statement
</code></pre>

<p>And that's it.</p>
",0
37635968,37635535,6,"<p>In addition to the cases already mentioned, the <code>:</code> character may legally appear in (references are to the <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""noreferrer"">N1570</a> draft of the C11 standard, syntax in 6.10p1):</p>

<ul>
<li><p>The <em>h-char-sequence</em> of a <code>#include</code> directive:<br>
<code>#include &lt;foo:bar.h&gt;</code><br>
(6.10.2p2)</p></li>
<li><p>The <em>q-char-sequence</em> of a <code>#include</code> or <code>#line</code> directive:<br>
<code>#include ""foo:bar.h""</code><br>
This is not syntactically a string literal (6.10.2p3)</p></li>
<li><p>The <em>replacement-list</em> of a macro definition:<br>
<code>#define COLON :</code></p></li>
<li><p>A <em>non-directive</em> (which, in spite of the name, is actually a preprocessor directive:<br>
<code># :</code><br>
Yes, I believe this is valid, though gcc and clang reject it.</p></li>
<li><p>A <code>#error</code> directive:<br>
<code>#error foo : bar</code></p></li>
<li><p>A <code>#pragma</code> directive:
<code>#pragma foo : bar</code></p></li>
</ul>

<p>None of these are likely to occur in real code (though I suppose a <code>#include</code> directive for Windows-specific code might refer to <code>""C:\dir\blah.h""</code>).</p>
",0
47962319,47962305,7,"<p>Yes, and yes, both.</p>

<p>For a global variable (declared at file scope), the compiler <em>reserves</em> memory in the executable image. So this is compile-time.</p>

<p>For an automatic variable (declared in a function), the compiler <em>adds instructions</em> to allocate the variable on the stack. So this is run-time</p>

<pre><code>int a;        // file scope

int f(void)
{
    int b;    // function scope
    ...
</code></pre>

<p>Notes:</p>

<ul>
<li><p>The compiler has one (one set of) instructions to allocate all local variables of a function in one time. Generally, there is not overhead per variable (there can be exceptions I don't discuss now). These instructions are executed every time the function is called.</p></li>
<li><p>The compiler <em>does not allocate storage for your strings</em>. This is an error beginners often make. Consider:</p>

<pre><code>char *s;         // a pointer to a strings
scanf(""%s"", s);  // no, the compiler will not allocate storage for the string to read.
</code></pre></li>
</ul>
",5
47962362,47962305,0,"<p>There's a third kind of memory which is allocated dynamically by using <code>malloc()</code> and friends.</p>

<p>This memory is taken from the so called heap. While automatic variables (you have in functions) is taken from the so called stack.</p>

<p>Then, if you're having a variable with an initializer (e.g. <code>int i = 5;</code>) that never changes value, a compiler may figure that out and not allocate memory at all. Instead it would just use <code>5</code> wherever you use that variable in your code.</p>
",0
47962367,47962305,0,"<p>It depends on the kind of variable/object.</p>

<p>Globally and statically allocated variables are known at compile time and their offsets in the <a href=""https://en.wikipedia.org/wiki/Data_segment"" rel=""nofollow noreferrer"">data segment</a> are <em>baked</em> into the program. So in a way, they got <em>allocated</em> at compile time.</p>

<p>Variables local to function scope are allocated on the <a href=""https://en.wikipedia.org/wiki/Call_stack"" rel=""nofollow noreferrer"">stack.</a> You could say that the compiler <em>knew</em> about them and the kind of storage their needed but obviously they got <em>allocated</em> (in the sense of came into existence) at run time, during a function call.</p>

<p>Another interesting object is the heap allocated object, which can be created with malloc/calloc in C and new or related mechanisms in C++. They are allocated at run time in the heap section.</p>
",0
47489408,47489385,1,"<p>initialize <code>n</code> first and then declare <code>numArr[n]</code></p>

<p>Modify your code as </p>

<pre><code>int n,i,total = 0;
printf(""How many numbers do you want to print? =&gt; "");
scanf(""%d"",&amp;n);
int numArr[n];
</code></pre>

<p>then scan the array.</p>
",0
41178838,41178717,0,"<p><strong>Undefined behavior</strong>.</p>

<blockquote>
  <p>printf() does not change the contents of the variables you pass to it,
  so you simply pass the values of the variables.</p>
</blockquote>

<p>You can read about <strong>format specifiers for printf</strong> from the manual. Format specifier mismatch in printf leads to <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">Undefined behavior</a>.</p>
",0
41178884,41178717,3,"<p><code>Printf</code> will try to read as many variables as you specify in the format string. In this case, it's reading the next 4 or 8 bytes off the stack and interpreting it as an integer or pointer, because you told it there would be an integer or pointer there.</p>

<p>Whatever happened to be there is what you are seeing. It's entirely possible that it's some bytes left by a process that previously executed in that memory space.</p>

<p>As others point out the behavior is technically undefined by the language, you could write your compiler to implement this case in any number of ways, including crashing. It just happens that the most straightforward thing to do is to trust the format string and keep reading, and usually there's enough space mapped for the stack for this to return <em>something</em>.</p>
",0
41919184,41918116,0,"<p>Quote from gcc document:</p>

<blockquote>
  <p>It makes a difference where in the command you write this option; the
  linker searches and processes libraries and object files in the order
  they are specified. Thus, ¡®foo.o -lz bar.o¡¯ searches library ¡®z¡¯ after
  file foo.o but before bar.o. If bar.o refers to functions in ¡®z¡¯,
  those functions may not be loaded.</p>
</blockquote>

<p>So, in your situation, static library A must appear before curl static library(B) like -lA -lB, otherwise library B will ignore by the compiler.</p>
",0
47556090,47555212,0,"<p>Doing everything within the nested <code>for</code> loops is an interesting problem.</p>

<p>The only small challenge was to calculate the <em>columns</em> sums as well, since, the way the loops are written, it seems at first an <em>array[dimension]</em> would be necessary.</p>

<p>However a small trick is of help. This line to get a row value </p>

<pre><code>int rownum = *(mat + i * dimension + j);
</code></pre>

<p>Might also be used to get the col value, by inverting <code>i</code> and <code>j</code></p>

<pre><code>int colnum = *(mat + j * dimension + i);
</code></pre>

<p>Allowing to sum the columns as well at the same place (a matrix being a square!)</p>

<pre><code>void printmatrix(int *mat, int dimension) {

    int i, j;
    int magic=1;              // default to ""is magic""
    int d1=0,d2=0,refcount=0; // diag1, diag2

    for (i = 0 ; i &lt; dimension; i++) {
        int rowcount = 0;
        int colcount = 0;
        for (j = 0; j &lt; dimension; j++) {
            int num = *(mat + i * dimension + j);
            rowcount += num;                   // row sum 
            if (i == j) d1 += num;             // diag1 sum
            if (i == dimension-j-1) d2 += num; // diag2 sum
            // row to col ...
            colcount += *(mat + j * dimension + i); // col sum
        }
        if (!i) refcount = rowcount;   // first rowcount is reference
        else if (refcount != rowcount) magic = 0;
        if (refcount != colcount) magic = 0;
    }
    if (d1 != refcount || d2 != refcount) magic = 0;
    printf(""Is Magic: %s\n"", magic ? ""Yes"":""No"");
}
</code></pre>
",1
47556525,47555212,0,"<ol>
<li><p>Your code is buggy, as you start with <code>ismagicsquaere = 0</code>. But even if you start with <code>ismagicsquaere = 1</code>, it is still buggy, because in the iteration <code>i = 0</code>, the variable <code>rowscount</code> remains zero, so that the following comparison will always lead to setting <code>ismagicsquaere = 0</code>, which is not what you want.</p></li>
<li><p>If you are aiming at speed, you should whenever possible avoid any if clause within a loop, in particular within the inner loop.</p></li>
<li><p>Since you have a printf in your inner loop, I wouldn't care about speed at all, as this I/O operation will by far dominate the runtime.</p></li>
<li><p>If your aim really was a fast magic square check, you would have not only to remove the printf calls but return the function as soon as the first check fails.</p></li>
</ol>

<p>Here is my suggested code, including checks for the two diagonals. Since I assume that you need the printing to be included, I left the printf calls and did not add early returning:</p>

<pre><code>void printmatrix(const int *mat, int dimension) {
    int i, j;
    int ismagicsquare = 1;
    int diagonal1 = 0, diagonal2 = 0;

    for (i = 0; i &lt; dimension; i++) {
        diagonal1 += mat[i * dimension + i];
        diagonal2 += mat[i * dimension + dimension - 1 - i];
    }

    if (diagonal1 != diagonal2) {
        ismagicsquare = 0;
    }

    for (i = 0; i &lt; dimension; i++) {
        int rowscount = 0;
        int colscount = 0;

        for (j = 0; j &lt; dimension; j++) {
            rowscount += mat[i * dimension + j];
            colscount += mat[j * dimension + i];

            printf(""%d\t"", mat[i * dimension + j]);
        }

        if (rowscount != diagonal1 || colscount != diagonal1) {
            ismagicsquare = 0;
        }

        printf(""\n\n"");
    }

    printf(""ismagicsquare = %i\n"", ismagicsquare);
}
</code></pre>

<p>Note that with regard to memory accesses and cache optimization, it should be fastest to do in place checking of the row sums as shown, but within the same two nested loops increment per-column sums and evaluate them at the end. This way the very cache-unfriendly memory access mat[j * dimension + i] would be completely removed. However, this kind of optimization only makes sense when designing a pure check function without printf calls.</p>
",0
47555888,47555212,0,"<p>Apparently you have to iterate through the matrix 3 times, with 3 separate loops. I see no way around this. </p>

<p>The ""naive"" implementation:</p>

<ul>
<li>Sum the first row and store this result in a variable to henceforth use for comparisons.</li>
<li>Sum the rest of the rows in a loop and compare against the variable. If any sums are unequal, return false from the function.</li>
<li>Second loop, check the columns, compare against the same variable, if any unequal, return false.</li>
<li>Third loops, check the diagonal, compare against the same variable, if any unequal, return false.</li>
</ul>

<p>This algorithm is however potentially ineffective because it is very branch-intensive. What you can do to manually optimize it is to reduce the number of branches.</p>

<p>One possibly faster implementation:</p>

<ul>
<li>Sum all rows, store results in a result array. This is cache-friendly and will mean that the array ends up in data cache.</li>
<li>Do the same with columns and diagonals. </li>
<li><p>Make sure that your 3 sum arrays are allocated adjacently in memory by placing them in a struct. This is cache-friendly. Preferably something like this:</p>

<pre><code>typedef union
{
  struct
  {
    unsigned int row_sum[3];
    unsigned int col_sum[3];
    unsigned int dia_sum[2];
  };
  unsigned int sum [3+3+2];
} sum_t;  

_Static_assert(sizeof(sum_t) == sizeof(unsigned int[3+3+2]), 
               ""Sorry, weird systems are not supported."");
</code></pre></li>
<li><p>After done summing, go through the above <code>sum</code> array and compare every item against the first.</p></li>
</ul>

<p>This may or may not improve performance. You have to benchmark it on the specific system.</p>
",1
47557532,47555212,0,"<p>I've written the following code with the purpose to write (a day) a code that elaborates magic squares.</p>

<p>It stores all rows, columns and diagonals sums into a matrix. The purpose of this matrix ( <code>sum[][]</code> ) shall be to understand where the magic square is not correct.</p>

<p>The main calls the function <code>checkAndComputeSums()</code>that calculates all sums and returns 1 if the data into  the magic square are correct and 0 if are not correct.</p>

<p>Here the code:</p>

<pre><code>#include &lt;stdio.h&gt;

#define DIMS 3
#define COLS DIMS
#define ROWS DIMS

int checkAndComputeSums(int *s , int *ms, int dim);

enum STYPE {
    SUMROW,
    SUMCOL,
    SUMDIAG,

    //-------------------

    SUMCNT
};

int msqr[COLS][ROWS] = {
    { 8,       1,       6},

    { 3,       5,       7},

    { 4,       9,       2}
};

int sum[DIMS][SUMCNT];

const char * label[SUMCNT] = {
    ""ROWS"",""COLS"",""DIAG""
};

int checkAndComputeSums(int *s , int *ms, int dim)
{
    int i,j,ok=1;

    /* The sum are cleared */
    for(i=0;i&lt;dim;i++) {
        for(j=0;j&lt;SUMCNT;j++) {
            s[i*SUMCNT+j] =0;
        }
    }

    for(i=0;i&lt;dim;i++) {
        for(j=0;j&lt;dim;j++) {
            s[i*SUMCNT+SUMROW]+=ms[i*dim+j];
            s[i*SUMCNT+SUMCOL]+=ms[j*dim+i];

            if (i==j)
                s[SUMDIAG]+=ms[i*dim+j];

            if (i==dim - j - 1)
                s[SUMDIAG+SUMCNT]+=ms[i*dim+j];

        }

        if (s[i*SUMCNT+SUMROW]!=s[SUMROW] || s[i*SUMCNT+SUMCOL]!=s[SUMROW])
            ok=0;
    }

    if (s[SUMDIAG]!=s[SUMROW] || s[SUMDIAG+SUMCNT]!=s[SUMROW])
        ok=0;

    return ok;
}

int main(void)
{
    int i,j;

    i=checkAndComputeSums(sum[0],msqr[0],DIMS);
    printf(""The check was %s\n"",(!i)?""KO"":""OK"");

    for (j=SUMROW;j&lt;SUMCNT;j++) {
        printf(""%s: "",label[j]);
        for(i=0;i&lt;DIMS-((j==SUMDIAG)?1:0);i++) {
            printf(""%d "",sum[i][j]);
        }
        puts("""");
    }
    return 0;
}
</code></pre>
",0
41654145,41654073,2,"<p>For option. You actually can fill your <code>table</code> with spaces, modify it and then print</p>

<pre><code>char table[24][80]; // char is better

memset(table, ' ', sizeof(table[0][0]) * 24 * 80); // Fill table with spaces

table[10][10] = 'J'; // Your first custom char
table[20][20] = '0'; // Another custom char

for(j=0; j&lt;24; ++j) {
    for(i=0; i&lt;80; ++i) {
        printf(""%c"",table[j][i]); // You forget write ""%c"" to print char
        //putchar(table[j][i]) // This will also work
    }
    printf(""\n"");
}
</code></pre>
",6
41654212,41654073,4,"<p>If you want to represent a grid of characters, then you should use data type <code>char</code> instead of <code>int</code> and character constants (e.g. <code>'1'</code>) instead of integer constants (e.g. <code>1</code>). The main issue, however, is that statement <code>printf("" "",table[j][i]);</code> always prints a space as you missed the format specifier in the format string (e.g. <code>""%d""</code> for integers, or <code>""%c""</code> for character data type).
I do not know how your grid shall look like exactly, but maybe the following fragment helps:</p>

<pre><code>void create_area(void){
  char table[24][80];
  int i,j;
  int xvalue=10,yvalue=10;

  for(j=0; j&lt;24; j++){
    for(i=0; i&lt;80; i++){
        table[j][i] = '1';
    }
  }

  table[10][10] = '0';

  for(j=0; j&lt;24; j++){
    for(i=0; i&lt;80; i++){
        printf(""%c"",table[j][i]);
    }
    printf(""\n"");
  }
  ...
</code></pre>
",3
41654439,41654073,4,"<p>I agree with the other answers here, but let me provide another perspective.</p>

<p>You should separate <em>data</em> from <em>presentation</em>. Here the array is your data (it could also be <code>bool table[24][80]</code>, because in the Game of Life each cell is described by 1 bit). The code that displays your data should examine each data element (see whether it's 0 or 1) and output 1 <code>char</code>. For that, you can use <code>putchar</code>:</p>

<pre><code>putchar(table[j][i] ? 'x' : ' ')
</code></pre>

<p>or <code>printf</code>:</p>

<pre><code>printf(""%c"", table[j][i] ? 'x' : ' ')
</code></pre>

<p>It's good to separate data from presentation because this makes it easier for you to change (improve) each of them separately. For example, if you decide to replace <code>x</code> by <code>*</code> in your visualization, the corresponding code is in one place. If you decide to optimize your storage by allocating 1 byte per cell (and not 1 <code>int</code> per cell) - the change is also relatively localized.</p>
",0
41654224,41654073,1,"<p>See this description for <a href=""https://www.tutorialspoint.com/c_standard_library/c_function_printf.htm"" rel=""nofollow noreferrer"">printf</a>. In C the <code>char</code>acter is just a some integer number, so you should specify a format to output it like a character <code>%c</code> or like an integer (decimal) <code>%d</code>.</p>

<pre><code>   for(j=0; j&lt;24; j++) {

        for(i=0; i&lt;80; i++){

            if (table[j][i] == 1) { // it's a code of some character that fills your array (As I saw in commented block you used 1)
                printf("" "");
            } else {
                printf(""%c"",table[j][i]);
            }
        }

        printf(""\n"");
    }
</code></pre>

<p>P.S. For profi, I know it's not an optimal code but it will be easy for him to understand.</p>
",0
41654702,41654073,1,"<p>You can use the <code>%hhu</code> scan code for printing <code>unsigned char</code>. This means there is no need to change your <code>int table</code> data type.</p>

<pre><code>printf(""%hhu"", table[j][i]); % table[j][i] contains integers
</code></pre>

<p>Hint: the <code>unsigned char</code> range is <code>0 - 255</code> and the numbers which are not placed in this range will not displayed as you may expect. </p>
",0
47961786,47961755,3,"<p>The line <code>extern int b;</code>, which you have at the end of 9.c, should be at the beginning of 10.c.  This tells the compiler that the declaration of b is in another module.  See <a href=""https://stackoverflow.com/questions/496448/how-to-correctly-use-the-extern-keyword-in-c"">How to correctly use the extern keyword in C</a>.</p>

<p><strong>Updated</strong>
In reply to your comment, and also to the comments above:  When the others say this error is from the compiler, not the linker, they are referring specifically to the ""compile"" phase of the build process.  In this phase, each source file is processed independently.  So the fact that you have declared <code>b</code> in 9.c doesn't help the compiler recognize it in 10.c.  If you want to delay resolution of this identifier to the linking phase, you need an <code>extern</code> declaration of the variable <strong>in 10.c</strong> because that's where the declaration is missing.</p>

<p>Having the <code>extern</code> declaration in 9.c is pointless, since the actual declaration occurs earlier in the same file.</p>

<p>I suspect you are thinking of <code>extern</code> as if it means ""export"", i.e. a command to tell the compiler to remember that <code>b</code> is declared in 9.c so that it can resolve references to it in other files.  That's not what it means.  It is a command to tell the compiler that this variable is defined externally to the current source file; so you include it in each source file where a variable declared elsewhere is referenced.  (Or more typically, it is used in a header file that is included in such source files, such as <code>stdio.h</code>.)</p>
",5
35218119,24465925,0,"<p><strong>Explanation:</strong></p>

<p><strong>Step 1:</strong>  <code>int a = 300, b, c;</code> here variable <code>a</code> is initialized to <code>'300'</code>, variable <code>b</code> and <code>c</code> are declared, but not initialized.<br><br>
<strong>Step 2:</strong> <code>if(a &gt;= 400)</code> means <code>if(300 &gt;= 400)</code>. Hence this condition will be failed.<br><br>
<strong>Step 3:</strong> <code>c = 200;</code> here variable <code>c</code> is initialized to <code>'200'</code>.<br><br>
<strong>Step 4:</strong> <code>printf(""%d, %d, %d\n"", a, b, c);</code> It prints <code>""300, garbage value, 200""</code>. because variable <code>b</code> is not initialized.</p>
",0
43924112,43923772,0,"<p>Use <code>memcpy()</code> to copy from <code>buffer</code> to <code>message</code>, and then add the null terminator to it so you can call <code>write_to_log()</code>.</p>

<pre><code>while(nwrite != -1 &amp;&amp; (nread = read(read_from_socket,buffer,BUFFER_SIZE)) &gt; 0){
    total = 0;
    memcpy(message, buffer, nread);
    message[nread] = '\n';
    message[nread+1] = '\0';
    write_to_log(message);
    do{
        // Append to message buffer
        if((nwrite = write(write_to_socket,buffer+total,nread-total)) == -1){
            // TODO: Convert the byte into an ASCii character and append to the message
            // strcat(message,&amp;nwrite);
            break;
        }
        total += nwrite;
        // Keep reading from the buffer until it is done
    }while(total &lt; nread);
}  
</code></pre>

<p>I'm assuming that <code>BUFFER_SIZE</code> is less than <code>253</code>, so there will always be enough room.  You should probably declare it so that it's always large enough:</p>

<pre><code>char message[BUFFER_SIZE + 2];
</code></pre>
",1
40957609,40957172,1,"<p>Everything is not fine here. Your program has multiple issues:</p>

<ul>
<li>You do not define <code>c</code>, <code>fp1</code>, <code>fp2</code>, <code>fn</code>...</li>
<li>You use <code>scanf()</code> in an unsafe way.</li>
<li>You dont check for <code>EOF</code> when reading from <code>stdin</code>.</li>
<li>You store the <code>.</code> into <code>temp.txt</code></li>
<li>Also check <a href=""https://stackoverflow.com/questions/5431941/why-is-while-feof-file-always-wrong"">Why is ¡°while ( !feof (file) )¡± always wrong?</a></li>
<li>Using a single character <code>.</code> as the final mark has side effects: you will not be able to use that character in the file, that's a strong limitation. You should at least only consider <code>.</code> at the start of a line.</li>
</ul>

<p>Here is an improved version:</p>

<pre><code>int Create(void) {
    FILE *fp1, *fp2;
    char fn[1024];
    int last = '\n', c;

    fp1 = fopen(""temp.txt"", ""w+"");
    if (fp1 == NULL) {
        printf(""Cannot create file temp.txt\n"");
        return -1;
    }
    printf(""\n\tEnter the text and press '.' to save\n\n"");
    while ((c = getchar()) != EOF &amp;&amp; (c != '.' || last != '\n')) {
        fputc(c, fp1);
        last = c;
    }
    for (;;) {
        printf(""\n\tEnter then new filename: "");
        if (scanf("" %1023[^\n]%*c"", fn) != 1) {
            printf(""input error\n"");
            fclose(fp1);
            return -2;
        }
        fp2 = fopen(fn, ""w"");
        if (fp2 == NULL) {
            printf(""Cannot create output file %s\n"", fn);
        } else {
            break;
        }
    }
    rewind(fp1);
    while ((c = getc(fp1)) {
        putc(c, fp2);
    }
    fclose(fp2);
    fclose(fp1);
    return 0;
}
</code></pre>

<p>If you wish to write an interactive editor, you need to set the terminal in raw mode with <code>stty()</code> and use a library such as <code>ncurses</code> to handle full screen output and cursor key input.  You can also assume the terminal supports ANSI escape sequences and hard code input and output accordingly.</p>

<p>Such a project is quite an endeavor. I strongly suggest you look at existing open source editors, read the source code and learn how they handle various tasks. I personally co-authored an Emacs clone called <code>qemacs</code> (for Quick Emacs). You can read about it and get the source code from <a href=""http://qemacs.org"" rel=""nofollow noreferrer"">http://qemacs.org</a>, but it is a large project to tackle for a beginner.</p>
",4
40957239,40957172,1,"<p>The standard C99 or <a href=""https://en.wikipedia.org/wiki/C11_%28C_standard_revision%29"" rel=""nofollow noreferrer"">C11</a> (read the <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""nofollow noreferrer"">n1570</a> draft specification) does not know about keyboards or buttons. You probably need some operating system related library.</p>

<p>Assuming your OS is POSIX (e.g. Linux), you want to know more about <a href=""https://en.wikipedia.org/wiki/Computer_terminal"" rel=""nofollow noreferrer"">terminals</a> and ttys (so read the <a href=""http://www.linusakesson.net/programming/tty/"" rel=""nofollow noreferrer"">tty demystified</a> page); then you should use a library like <a href=""https://www.gnu.org/software/ncurses/"" rel=""nofollow noreferrer"">ncurses</a> (but then don't use any <code>&lt;stdio.h&gt;</code> function for terminal I/O).</p>

<p>Or you want some <a href=""https://en.wikipedia.org/wiki/Graphical_user_interface"" rel=""nofollow noreferrer"">graphical user interface</a>, then better use some <a href=""https://en.wikipedia.org/wiki/Graphics_library"" rel=""nofollow noreferrer"">graphics library</a> or <a href=""https://en.wikipedia.org/wiki/Widget_toolkit"" rel=""nofollow noreferrer"">toolkit</a> (such as <a href=""http://gtk.org/"" rel=""nofollow noreferrer"">GTK</a>, <a href=""http://libsdl.org/"" rel=""nofollow noreferrer"">SDL</a>, <a href=""http://qt.io/"" rel=""nofollow noreferrer"">Qt</a> etc....).</p>

<p>You will need many months (or years) of work to make a text editor. So study the source code of existing <a href=""https://en.wikipedia.org/wiki/Free_software"" rel=""nofollow noreferrer"">free software</a> editors for inspiration.</p>
",0
41217707,41217665,0,"<p>Comma Operator in <code>C</code> has Lowest Precedence i.e it is having lowest priority so it is evaluated at last.<br>
Comma operator returns the value of the rightmost operand when multiple comma operators are used inside an expression.</p>
",0
41217735,41217665,1,"<p>The comma operator in C is a sequence point which means that the expressions separated by the comma are executed from left to right. The value of the whole expression is the value of the rightmost expression, in your case 5, which gets assigned to the variable p.</p>
",1
47960550,25386385,0,"<p>Not just <code>int main()</code> but one can skip writing <code>main()</code> entirely.</p>

<p><code>main()</code> is the entry point of a c program, this is a universal fact but actually when we dive deep, it becomes clear, that <code>main()</code> is called by another function called <code>_start()</code> which is actually the very first function called at the abstract level.</p>

<pre><code>#include &lt;stdio.h&gt;
extern void _exit(register int);

int _start(){

printf(¡°Hello World\n¡±);

_exit(0);

}
</code></pre>
",0
35264123,22984503,1,"<p>Ruby Code that got 100/100 on codility</p>

<pre><code>def solution(a)
  a.sort!
  if a[a.length - 1] &gt;= 0
    a[a.length - 1] * ([a[0] * a[1] ,a[a.length - 2] * a[a.length - 3]].max) 
  else
    a[a.length - 1] * a[a.length - 2] * a[a.length - 3]
  end    
end
</code></pre>
",0
47503495,47503484,2,"<p>You <a href=""http://en.cppreference.com/w/c/language/const"" rel=""nofollow noreferrer"">can't cast a <code>const</code> pointer to non-<code>const</code></a>.</p>

<pre><code>const char *(*p) = &amp;values[0];
^~~~~
</code></pre>

<p>This is what you should have written.</p>
",1
35265145,35265058,6,"<p>That is an old style function definition, it is missing the argument list, so add them:</p>

<pre><code>sizeof( void(*)(void) )
</code></pre>
",0
35265159,35265058,2,"<p>For readability purposes, I recommend declaring a type for the <em>signature</em> of any function you'll want have some pointer to:</p>

<pre><code> typedef void my_sigt(void);
</code></pre>

<p>then, to declare a pointer to such a function, code:</p>

<pre><code> my_sigt* funptr;
</code></pre>

<p>and to get its size code <code>sizeof(my_sigt*)</code> (or <code>sizeof(funptr)</code> if you have such a variable <code>funptr</code>)</p>

<p>BTW, I am not sure that the C99 standard guarantees that every function pointer has the same size (or has the same size as some data pointer). But POSIX requires that (in particular, to be able to use <a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/dlsym.html"" rel=""nofollow"">dlsym</a> for dynamic linking of such functions).</p>
",0
34962003,34961982,2,"<pre><code>script[strcspn(script, ""\n"")] = 0;
</code></pre>

<p>This terminates the C-string after the first newline. You may want to loop over the string and replace  <code>\n'</code> with <code>' '</code> instead.</p>

<p>Something like:</p>

<pre><code>// strip newlines
for(size_t i = 0; script[i]; i++)
if (script[i] == '\n') script[i] = ' ';
</code></pre>

<hr>

<p>By the way, you should be using <a href=""http://pubs.opengroup.org/onlinepubs/009696699/basedefs/sys/types.h.html"" rel=""nofollow""><code>off_t</code></a> (POSIX defined) to store the file size (as the type of <code>filesize</code>), not an <code>int</code>. An <code>int</code> may not be able to hold the size of a file.</p>
",1
34962526,34961982,0,"<p>In addition to the solution provided by l3x, I should add that the method used is not reliable:</p>

<ul>
<li><code>ftell</code> may fail and upon success, its return value is the number of bytes in the file only if the file is opened in binary mode.  For text mode, the Standard does not guarantee anything beyond the fact that it can be used as an argument to <code>fseek</code>.</li>
<li>seeking to the end of file and back to the beginning will not work as expected if the stream does not refer to an actual file: for a terminal, a character device or a pipe, it may not work at all.</li>
</ul>

<p>It is much more reliable to read the file with <code>getc()</code> into a buffer that you reallocate on demand, one chunk at a time.</p>
",0
34922869,23144000,0,"<pre><code>        int sum = 0;
        int count;
        count = int.Parse(Console.ReadLine()); //Armstrong numbers from 0 to count
        Console.WriteLine();
        Console.Write("" Armstrong numbers from 0 to "" + count + "" are: ""); 
        for (int c = 0; c &lt;= count; c++)
        {
            sum = 0;
            for (int i = 1; i &lt;= c; i *= 10)
            {
                if (c / i % 10 &gt;= 1)
                {
                    int cube = (c / i % 10);
                    sum += cube * cube * cube;
                }
            }
            if (sum == c)
            {
                Console.Write(sum + "" "");
            }
        }
</code></pre>
",1
35278899,35278396,0,"<p>After taking a quick look at the <a href=""http://opengi.sourceforge.net/doc/group__mesh.html#gac2d6a026c752f1ac9e5aaae95b1db3a4"" rel=""nofollow"">documentation</a>, you should call the function <code>giGetIndexedMesh</code> twice. First, to retrieve the required sizes (<code>vcount</code> and <code>icount</code>) by setting the last parameter to NULL. And the second time to retrieve the indices.</p>

<p>In your code snippet, you allocate the array using an old value of <code>icount</code>. The required value is determined later, but you must determine it before:</p>

<pre><code>GIuint vcount, icount;
giGetIndexedMesh(&amp;vcount, &amp;icount, NULL);
GIunit *indices = malloc (...);
giGetIndexedMesh(&amp;vcount, &amp;icount, indices);
</code></pre>

<p>I didn't find enough information on the array layout. Thus, I didn't completed the <code>malloc</code> call. You should also check the return value of <code>malloc</code> an <code>giGetIndexedMesh</code>.</p>
",3
47511777,47511563,1,"<p>What about next solution? </p>

<pre><code>for (precalculation (); CONDITION; somethingWith (calculationParams));
</code></pre>

<p><code>precalculation ()</code> is executed once, the CONDITION is evaluated at every iteration and <code>somethingWith (calculationParams)</code> take the place in of the incrementation. The body of the <code>for</code> loop is empty.</p>

<p>Pure C beauty.</p>

<p>Obviously, precalculation and somethingWith (calculationParams) must become a new function.</p>
",0
47512480,47511563,0,"<p>First of all, please note that <code>do {} while(something)</code> is equivalent to <code>something=true; while something{}</code>. The former saves a bit of extra execution in case you don't want the initialization part.</p>

<blockquote>
  <p>How can I get my code block in a nice one-liner </p>
</blockquote>

<p>There is nothing wrong with your code. <code>} while ( (data[0] &amp; 0x01) &amp;&amp; intervalMS &lt; 200);</code> is perfectly clear to me - another C programmer. </p>

<p>You check if the lsb is set and you check a timer interval. The only way this code could be improved would be to explain why you check the lsb - which you can do with a comment (do you check if a number is odd or do you read a bit in bit-field etc). </p>

<p>Now what you can and should do, is to put the whole snippet inside a function and give it a meaningful name. There's the nice one-liner.</p>
",0
34972056,34971876,0,"<p>I just compiled and tested your code. The file name you are giving is incorrect; you need a ""/"" in front of ""home"".</p>

<p>Not sure what the requirements are, but write your matrixFile like a matrix: add a new line after <em>each row</em> of the matrix is ""multiplied"", not after every element:</p>

<pre><code>for(i = 0; i &lt; n; i++) {
     for(j = 0; j &lt; n; j++) {
         sumArr[i][j] = arrA[i][j] * arrB[i][j];
         printf(""Writing matrix "");
         fprintf(matrixFile, ""%0.3lf "", sumArr[i][j]);
     }
     fprintf(matrixFile, ""\n""); 
}
</code></pre>

<p>Also, take Craig Easley's comment seriously. Stack Overflow can happen, even off the premises this website ;) Consider allocating your matrix dynamically on the heap.</p>
",0
34972203,34971876,1,"<p>If <code>n</code> is large enough, you'll generate a stack overflow using <code>VLA</code>s. I've verified this experimentally with your code (e.g. use <code>n</code> of 5000).</p>

<p>So, you'll need to use <code>malloc</code> to allocate from heap. But, that would require a bit of a rewrite.</p>

<p>Here's a way to use heap allocation <em>and</em> get the benefit of a <code>VLA</code> [using some slight trickery]:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define C(_arr) (double (*)[(size_t)(n)]) _arr

void
docalc(FILE *fout,int n,double arrA[n][n],double arrB[n][n],double sumArr[n][n])
{
    // must declare outside of for loop due to resolve C99 mode error
    int i,
     j;

    // randomly populate arrA and arrB
    for (i = 0; i &lt; n; i++) {
        printf(""%d\n"", i);
        for (j = 0; j &lt; n; j++) {
            printf(""%4d"", j);
            arrA[i][j] = (double) rand() / (double) RAND_MAX;
            arrB[i][j] = (double) rand() / (double) RAND_MAX;
        }
    }

    printf(""Exiting Matrix randomization"");

    // multiply the matrices and write them to the file
    for (i = 0; i &lt; n; i++) {
        for (j = 0; j &lt; n; j++) {
            sumArr[i][j] = arrA[i][j] * arrB[i][j];
            printf(""Writing matrix\n"");
            fprintf(fout, ""%0.3lf\n"", sumArr[i][j]);
        }
    }
}

int
main(int argc, char *argv[])
{

    FILE *matrixFile;
    int n = atoi(argv[1]);              // the number of matrices

    printf(""Usage: %s &lt;size of nxn matrices&gt;\n"", argv[1]);

    matrixFile = fopen(""/tmp/results.txt"", ""w+"");
    if (matrixFile == NULL) {
        perror(""fopen"");
        exit(1);
    }

    double *arrA = malloc(sizeof(double) * n * n);
    double *arrB = malloc(sizeof(double) * n * n);
    double *sumArr = malloc(sizeof(double) * n * n);

    docalc(matrixFile,n,C(arrA),C(arrB),C(sumArr));

    if (matrixFile)
        fclose(matrixFile);

    matrixFile = NULL;

    return 0;
}
</code></pre>
",2
34971945,34971876,1,"<p>This error is going to come down to writing off the end of your array or failure to open your file. I would suggest running gdb to check out your program when it is running, but from a quick glance I wonder if you don't mean to have </p>

<pre><code>""/home/acolwell/Documents/CPE631_HW2_Number1/results.txt""
</code></pre>

<p>as the file to write instead of</p>

<pre><code>""home/acolwell/Documents/CPE631_HW2_Number1/results.txt""
</code></pre>

<p>I would suggest checking the result of your fopen call before calling fprintf.</p>
",2
41694378,41694188,4,"<p>Set <code>fpLogFile</code> to <code>NULL</code>, and before each <code>fprintf</code>, check if it is still <code>NULL</code>. If so, open the file.</p>
",0
41695048,41694188,1,"<p>I could create a file for each error log</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int g_Error_Num = 0;

#define LOG_INFO(...) \
do{\
    FILE *fpLogFile;\
    char file_name[32];\
    sprintf(file_name, ""./Error_LOG_%d.txt"", g_Error_Num++);\
    fpLogFile = fopen (file_name, ""w+"");\
    if (fpLogFile != NULL) {\
        fprintf(fpLogFile, __VA_ARGS__ ); \
        fclose(fpLogFile);\
    }\
} while( 0 )

int main(void)
{
    LOG_INFO(""Test 1\n"");
    LOG_INFO(""Test 2\n"");

    return 0;
}
</code></pre>
",2
41193264,41193066,2,"<p>You pass an <a href=""http://en.cppreference.com/w/c/language/type"" rel=""nofollow noreferrer""><code>unsigned long long</code></a> (<code>j</code>) to <code>printf()</code> (8 bytes). But, because of the incorrect format specifier (<code>%lu</code> should be <a href=""http://en.cppreference.com/w/c/io/fprintf"" rel=""nofollow noreferrer""><code>%llu</code></a>), <code>printf()</code> reads only half of them (the least significant 4 bytes). The other 4 bytes are interpreted by <code>printf()</code> for <code>%d</code> (instead of <code>i</code> which is ignored). All 4 most significant bytes of <code>1000</code> are <code>0</code>.</p>

<p>Because of the mismatch between the number of bytes of the value and its specifier, it is <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer""><code>Undefined Behaviour</code></a>.</p>

<p>The first <code>printf()</code> works fine because it just happens that the 4 bytes of <code>j</code> read by <code>printf()</code> are the least significant bytes. Put a number greater than <code>2^32</code> in <code>j</code> and you'll get wrong results on both calls of <code>printf()</code>.</p>
",0
34892600,34892550,5,"<p>You can use the ternary operator:</p>

<pre><code>int valueCompare(int i, int j) 
{
    return (i == j) ? 1 : -1;
}
</code></pre>
",4
34892676,34892550,2,"<p>It is readable and it is the compiler's responsibility to make it efficient. Any ""clever"" way of writing it will be <em>less readable</em> and will <em>not</em> be more efficient.</p>

<p>Basically I would leave it at omitting the braces when there is just a single statement and even that is a matter of taste:</p>

<pre><code>if(i != j)
    return -1;
else
    return 1;
</code></pre>

<p>vs.</p>

<pre><code>if(i != j) {
    return -1;
} else {
    return 1;
}
</code></pre>

<p>vs.</p>

<pre><code>if(i != j)
{
    return -1;
}
else
{
    return 1;
}
</code></pre>

<p>Of course I can think of many ""clever"" way of writing it from</p>

<pre><code>return (i != j) ? -1 : 1;
</code></pre>

<p>that is only appropriate for <strong>simple</strong> expressions (i.e. this is ok, but throw in a couple of function calls and it will be totally unreadable) to</p>

<pre><code>return 2 * (i == j) - 1;
</code></pre>

<p>but <strong>this is barely readable</strong>. You should, however, be able to understand it, because you <em>might</em> see this kind of thing in the wild.</p>

<p>And there is absolutely nothing on either to make them more efficient.</p>
",8
34892848,34892550,0,"<p>How about </p>

<pre><code>#define SAME_VALUE 1
#define DIFFERENT_VALUE -1
</code></pre>

<p>Or the like ?
and how about </p>

<pre><code> int valueCompare (int i, int j){
         return i == j;
    }
</code></pre>
",0
34894101,34892550,3,"<p>For readability, consider rewriting the function to use boolean logic instead:</p>

<pre><code>#include &lt;stdbool.h&gt;

bool isEqual (int i, int j) {
  return i == j;
}
</code></pre>

<p>This is, in my opinion, the most readable form possible.</p>

<hr>

<p>Or alternatively for generic programming/portability/usefulness purposes, you should make a C programming de facto standard ""functor"" for value comparison:</p>

<pre><code>int compare_int (const void* i1, const void* i2)
{
  const int* ip1 = i1;
  const int* ip2 = i2;
  return *ip1 - *ip2;
}
</code></pre>

<p>This has plenty of advantages: </p>

<ul>
<li>Generic function format.</li>
<li>Standard. Can be passed to functions like <code>bsearch, qsort</code> etc.</li>
<li>Mixes equality, lesser than and greater than checks in one single function.</li>
<li>Compatible with dinosaur compilers.</li>
</ul>
",0
34916880,34916671,10,"<blockquote>
  <p>printf(""%s"", ptr);</p>
</blockquote>

<p>Here <code>printf</code> expects a valid pointer, which points to null terminated string, you can't pass NULL to it. If you do so, you will trigger undefined behaviour, and can't reason about output of the program.</p>

<p>PS. I have found an answer which might have slightly more details about the thing you might be interested in. See <a href=""https://stackoverflow.com/a/11589443/3963067"">here</a>. Actually your question seems to be a duplicate of that one. </p>
",13
34917425,34916671,-1,"<p>As i can make out 
printf is actually using a system call called write() which will be used by  the kernel to write to the stdout file descriptor. In this case the \n causes the pointer to move to unchartered territory and trying to write data from there to the stdout file descriptor causes this behaviour.</p>

<p>Found one good reference from SO itself </p>

<p><a href=""https://stackoverflow.com/questions/2442966/c-c-function-definitions-without-assembly"">C/C++ function definitions without assembly</a></p>
",3
34918613,34916671,3,"<p>Some <code>printf</code> implementation take care about <code>NULL</code> <em>string</em> parameter, but some of these implementations have ""bugs"", see <a href=""http://www.ciselant.de/projects/gcc_printf/gcc_printf.html"" rel=""nofollow"">gcc printf optimization</a> .</p>

<p>Whatever, C standard says:</p>

<blockquote>
  <p>the argument shall be a pointer to the initial element of an array of
  character type</p>
</blockquote>

<p>If not, then it is an <em>undefined behavior</em>. The behavior you've faced is one of these.</p>
",0
34923958,34916671,3,"<p>The technical reason behind is:</p>

<p>If you write a statement like</p>

<pre><code>printf(""%s\n"", ptr);
</code></pre>

<p>some compilers (i.e. gcc with optimizations) will ""optimize"" it to:</p>

<pre><code>puts(ptr);
</code></pre>

<p>The glibc-implementation of <code>puts()</code> doesn't print <code>(null)</code> on a NULL-pointer (as printf does), but happily segfaults.</p>

<p>When gcc is invoked without optimizations activated, this substitution is not made and <code>printf(""%s\n"", NULL);</code> will not segfault.</p>

<p>This behaviour is standard compliant, since passing a NULL-pointer to <code>printf()</code> invokes ""undefined behaviour"".</p>
",5
39340017,39339997,4,"<p>Yes, you mean that you want to capture 3 strings separated with spaces and then the rest of it</p>

<pre><code>if (sscanf(string, ""%s%s%s%[^\n]"", one, two, three, four) != 4) {
    fprintf(stderr, ""The string `%s' doesn't match the format\n"");
}
</code></pre>

<p>And better be careful with a buffer overflow</p>

<pre><code>char one[100];
char two[100];
char three[100];
char four[100];

if (sscanf(string, ""%99s%99s%99s%99[^\n]"", one, two, three, four) != 4) {
    fprintf(stderr, ""The string `%s' doesn't match the format\n"");
}
</code></pre>
",4
39340114,39339997,4,"<p>Use <code>""%n""</code>to record where scanning stopped.  Always limit input by specifying maximum input width.  Check <code>sscanf()</code> results.</p>

<pre><code>char one[10];
char two[10];
char three[10];
int n;
char * s = ""XXX YYY ZZZ A something heyyy O"";

if (sscanf(s, ""%9s%9s%9s %n"", one, two, three, &amp;n) != 3) Handle_Failure();
else printf(""'%s' '%s' '%s' '%s'\n"", one, two, three, &amp;s[n]);
</code></pre>
",2
38992079,38992022,2,"<p>Yes, use <code>*</code> as the precision, which takes another <code>int</code> argument off the argument list (before the argument whose value is to be printed):</p>

<pre><code>void prec_print(double d, int prec)
{ 
    printf(""%.*f\n"", prec, d);
}
</code></pre>

<p>(Similarly, the field width may be specified dynamically by using <code>*</code>, too: <code>%*.*f, width, prec, val</code>.)</p>
",2
37635648,37635504,0,"<p>You might want to read closely <a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/fopen.html"" rel=""nofollow"">fopen description</a>, especially</p>

<blockquote>
  <p>When a file is opened with update mode ( '+' as the second or third character in the mode argument), both input and output may be performed on the associated stream. However, the application shall ensure that output is not directly followed by input without an intervening call to fflush() or to a file positioning function ( fseek(), fsetpos(), or rewind()), and input is not directly followed by output without an intervening call to a file positioning function, unless the input operation encounters end-of-file.</p>
</blockquote>

<p>You used 'w+' mode, which allows reading and writing, but did not flush, nor rewind file pointer after write.</p>

<p>As a side note, Your code could use some error checking (<code>NULL != file</code>).  </p>
",0
36379498,36379471,0,"<p>What is wrong is that you are using the operator <code>^</code> the wrong way: it is not the power operator, but the bitwise <code>XOR</code> operator. There is no power operator in C, but a pow() function the math library.</p>

<p>On the other way... where the factorial is calculated?</p>
",2
37198662,37198613,-1,"<p>If you initialize an array with a string literal that is smaller than the array, the string, including the trailing NUL, will be copied into the array.  Any excess elements will then be initialized according to the same rules used to initialize variables with static storage duration, which for <code>char</code> is <code>0</code>. (q.v. C99 6.7.8/21)</p>

<p>The first printf loop is printing the array one character at a time using <code>%c</code>.
So when you initialize at the array to <code>""""</code> (which is equivalent to <code>{'\0'}</code>), the array will be initialized with all zeros: the first zero from the null terminator, and the others because that's the default value for a <code>char</code> with static duration. Since a decimal value of zero represents an ASCII value of NUL, printf prints...NUL, which often shows up as a blank space.</p>

<p>For the second one, you're setting the array to ASCII 0, because you're setting all of the values to <code>0</code>, which is hexadecimal value 0x30 (I forget the decimal conversion). So, since you're printing <code>%c</code>, it will print ASCII 0.</p>

<p>Now, if you change your first printf to print a <code>%d</code>, instead of <code>%c</code>, then it will print the integer value stored in the array, which will be all zeroes. If you change the second printf to print <code>%x</code>, then it'll print a bunch of 0x30's.</p>

<p>Read up on the differences between <code>%c</code>, <code>%d</code>, <code>%x</code>, and the other printf flags, and how they all behave.</p>
",5
35247446,35247331,0,"<p>This will work:</p>

<pre><code>    #include &lt;stdio.h&gt;
    #include &lt;string.h&gt;

    int main(){
            int i, count;
            char str[1000];

            printf(""Enter: "");
            scanf(""%s"", str);
            printf(""You have typed: %s\n"", str);

            //used strlen() only once because strlen() takes O(n) time
            int len = strlen(str);
            printf(""length: %d\n"", len);

            //iterate through the string
            for (i = 0; i &lt; len - 1; i++){

                    //every char appears at least once
                    count = 1;

                    //print the char regardless of it repeating
                    printf(""%c"", str[i]);
                    for (int j = i; str[j] == str[j+1]; ++j, ++i)
                            ++count;

                    //print the count if it's greater than 1
                    if (count &gt; 1) printf(""%d"", count);
            }

            //print the last char if it's different from the second last
            if (str[len - 1] != str[len - 2]) printf(""%c"", str[len - 1]);

            //print new line
            printf(""\n"");
    }
</code></pre>
",0
44349093,44349064,0,"<p>You can't transpose a matrix in place. That is to say, it is not possible to write a function which will take a matrix and modify it so that it is its transpose, without creating a temporary matrix of equal size. At least without some very fancy programming.</p>

<p>Now your task isn't exactly the transpose, but it seems to be very similar. So I wouldn't expect there to be a nice, in place solution. You must simply create a temporary, apply the mapping from input to temporary, and write the values back.</p>

<p>What might help is this.</p>

<pre><code>/* swap two rows of a matrix */
void swaprows(int *mtx, int width, int height, int rowa, int rowb)
{
   int i;

   for(i=0;i&lt;width;i++)
   {
      int temp = mtx[rowa*width+i];
      mtx[rowa*width+i] = mtx[rowb*width+i];
      mtx[rowa*width+i] = temp;
   }
} 

/* transpose a matrix */
int transpose(int *mtx, int width, int height)
{
    int *tmtx = malloc(width*height*sizeof(int));
    if(!tmtx)
       return -1;
    for(y=0;y&lt;width;y++)
      for(x=0;x&lt;height;x++)
        tmtx[y*height+x] = mtx[x*width+y];

    mempy(mtx, tmtx, width * height * sizeof(int));
    free(tmtx);
}


/* your logic  */

int arr[3][7] = {
            {1, 2, 3, 4, 5, 6, 7},
            {8, 9, 10, 11, 12, 13, 14}, 
            {15, 16, 17, 18, 19, 20, 21}
        };

 swaprows((int *) arr, 7, 3, 0, 1);
 transpose(int *) arr, 7, 3);
</code></pre>

<p>This seems to be what you are trying to do. </p>
",0
44349218,44349064,0,"<p>like this ?</p>

<pre><code>#include &lt;stdio.h&gt;

#define ROWS 3
#define COLS 7

int main(void){
    int arr[ROWS][COLS] = {
        {1, 2, 3, 4, 5, 6, 7},
        {8, 9, 10, 11, 12, 13, 14}, 
        {15, 16, 17, 18, 19, 20, 21}
    };
    int result[ROWS][COLS];
    int order[ROWS] = {1, 0, 2};
    int n = sizeof(arr)/sizeof(**arr);//number of elements
    int r = 0, c = 0, i = 0, j = 0;

    while(n--){
        result[r++][c] = arr[order[i]][j++];
        if(r == ROWS){
            r = 0;
            c += 1;
        }
        if(j == COLS){
            j = 0;
            i += 1;
        }
    }
    //check print
    for(r = 0; r &lt; ROWS; ++r){
        for(c = 0; c &lt; COLS; ++c)
            printf(""%-2d "", result[r][c]);
        puts("""");
    }
}
</code></pre>
",0
44349340,44349064,0,"<p>The transposition part can be done like this:</p>

<pre><code>#include &lt;stdio.h&gt;

typedef struct Sequence2D
{
    int idx_slow;
    int idx_fast;
    int max_slow;
    int max_fast;
} Sequence2D;

static inline void next2D(Sequence2D *seq)
{
    if (++seq-&gt;idx_fast == seq-&gt;max_fast)
    {
        seq-&gt;idx_fast = 0;
        if (++seq-&gt;idx_slow == seq-&gt;max_slow)
            seq-&gt;idx_slow = 0;
    }
}

static inline void dump2D(const char *tag, int rows, int cols, int data[rows][cols])
{
    printf(""%s:\n"", tag);
    for (int r = 0; r &lt; rows; r++)
    {
        for (int c = 0; c &lt; cols; c++)
            printf(""%3d"", data[r][c]);
        putchar('\n');
    }
}

enum { ROWS = 3, COLS = 7 };

int main(void)
{
    int src[ROWS][COLS] =
    {
        {  1,  2,  3,  4,  5,  6,  7 },
        {  8,  9, 10, 11, 12, 13, 14 },
        { 15, 16, 17, 18, 19, 20, 21 },
    };
    int dst[ROWS][COLS];
    Sequence2D dst2D = { 0, 0, COLS, ROWS };
    Sequence2D src2D = { 0, 0, ROWS, COLS };

    dump2D(""Source"", ROWS, COLS, src);

    for (int i = 0; i &lt; ROWS * COLS; i++)
    {
        dst[dst2D.idx_fast][dst2D.idx_slow] = src[src2D.idx_slow][src2D.idx_fast];
        printf(""dst[%d][%d] = src[%d][%d] = %d\n"",
               dst2D.idx_fast, dst2D.idx_slow,
               src2D.idx_slow, src2D.idx_fast,
               dst[dst2D.idx_fast][dst2D.idx_slow]);
        next2D(&amp;dst2D);
        next2D(&amp;src2D);
    }

    dump2D(""Target"", ROWS, COLS, dst);

    return 0;
}
</code></pre>

<p>The <code>Sequence2D</code> structure plus the <code>next2D()</code> function cycle through array indexes, changing the fast index on each call of <code>next2D()</code> and the slow index when necessary.  This saves you writing out the sequence of 21 assignments, and immediately scales to other shapes without requiring much extra work on your part.  Indeed, it would not take much to handle all the sizes as run-time inputs instead of compile-time constants.</p>

<p>The output of this code is:</p>

<pre><code>Source:
  1  2  3  4  5  6  7
  8  9 10 11 12 13 14
 15 16 17 18 19 20 21
dst[0][0] = src[0][0] = 1
dst[1][0] = src[0][1] = 2
dst[2][0] = src[0][2] = 3
dst[0][1] = src[0][3] = 4
dst[1][1] = src[0][4] = 5
dst[2][1] = src[0][5] = 6
dst[0][2] = src[0][6] = 7
dst[1][2] = src[1][0] = 8
dst[2][2] = src[1][1] = 9
dst[0][3] = src[1][2] = 10
dst[1][3] = src[1][3] = 11
dst[2][3] = src[1][4] = 12
dst[0][4] = src[1][5] = 13
dst[1][4] = src[1][6] = 14
dst[2][4] = src[2][0] = 15
dst[0][5] = src[2][1] = 16
dst[1][5] = src[2][2] = 17
dst[2][5] = src[2][3] = 18
dst[0][6] = src[2][4] = 19
dst[1][6] = src[2][5] = 20
dst[2][6] = src[2][6] = 21
Target:
  1  4  7 10 13 16 19
  2  5  8 11 14 17 20
  3  6  9 12 15 18 21
</code></pre>

<p>If you rearrange the initial matrix (<code>src</code>) according to whatever arcane rules you're using before you copy the 'transpose' of <code>src</code> into the result (<code>dst</code>), then you should be able to get the result you desire.</p>

<hr>

<p>As noted, the code can be generalized rather easily using C99 and variable-length arrays:</p>

<pre><code>#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;

typedef struct Sequence2D
{
    int idx_slow;
    int idx_fast;
    int max_slow;
    int max_fast;
} Sequence2D;

static inline void next2D(Sequence2D *seq)
{
    if (++seq-&gt;idx_fast == seq-&gt;max_fast)
    {
        seq-&gt;idx_fast = 0;
        if (++seq-&gt;idx_slow == seq-&gt;max_slow)
            seq-&gt;idx_slow = 0;
    }
}

static inline void dump2D(const char *tag, int rows, int cols, int data[rows][cols])
{
    printf(""%s:\n"", tag);
    for (int r = 0; r &lt; rows; r++)
    {
        for (int c = 0; c &lt; cols; c++)
            printf(""%3d"", data[r][c]);
        putchar('\n');
    }
}

static void transpose(int rows, int cols)
{
    assert(rows * cols &lt; 1000000);
    int src[rows][cols];
    int dst[rows][cols];
    Sequence2D dst2D = { 0, 0, cols, rows };
    Sequence2D src2D = { 0, 0, rows, cols };
    int cells = rows * cols;
    for (int i = 0; i &lt; cells; i++)
    {
        src[src2D.idx_slow][src2D.idx_fast] = i;
        next2D(&amp;src2D);
    }
    /* src2D is back to its initial state! */

    dump2D(""Source"", rows, cols, src);

    for (int i = 0; i &lt; cells; i++)
    {
        dst[dst2D.idx_fast][dst2D.idx_slow] = src[src2D.idx_slow][src2D.idx_fast];
        printf(""dst[%d][%d] = src[%d][%d] = %d\n"",
               dst2D.idx_fast, dst2D.idx_slow,
               src2D.idx_slow, src2D.idx_fast,
               dst[dst2D.idx_fast][dst2D.idx_slow]);
        next2D(&amp;dst2D);
        next2D(&amp;src2D);
    }

    dump2D(""Target"", rows, cols, dst);
}

int main(void)
{
    transpose(3, 7);
    transpose(9, 4);
    return 0;
}
</code></pre>

<p>The first section of the output is the same as before; the 9x4 part looks like:</p>

<pre><code>Source:
  0  1  2  3
  4  5  6  7
  8  9 10 11
 12 13 14 15
 16 17 18 19
 20 21 22 23
 24 25 26 27
 28 29 30 31
 32 33 34 35
dst[0][0] = src[0][0] = 0
dst[1][0] = src[0][1] = 1
dst[2][0] = src[0][2] = 2
dst[3][0] = src[0][3] = 3
dst[4][0] = src[1][0] = 4
dst[5][0] = src[1][1] = 5
dst[6][0] = src[1][2] = 6
dst[7][0] = src[1][3] = 7
dst[8][0] = src[2][0] = 8
dst[0][1] = src[2][1] = 9
dst[1][1] = src[2][2] = 10
dst[2][1] = src[2][3] = 11
dst[3][1] = src[3][0] = 12
dst[4][1] = src[3][1] = 13
dst[5][1] = src[3][2] = 14
dst[6][1] = src[3][3] = 15
dst[7][1] = src[4][0] = 16
dst[8][1] = src[4][1] = 17
dst[0][2] = src[4][2] = 18
dst[1][2] = src[4][3] = 19
dst[2][2] = src[5][0] = 20
dst[3][2] = src[5][1] = 21
dst[4][2] = src[5][2] = 22
dst[5][2] = src[5][3] = 23
dst[6][2] = src[6][0] = 24
dst[7][2] = src[6][1] = 25
dst[8][2] = src[6][2] = 26
dst[0][3] = src[6][3] = 27
dst[1][3] = src[7][0] = 28
dst[2][3] = src[7][1] = 29
dst[3][3] = src[7][2] = 30
dst[4][3] = src[7][3] = 31
dst[5][3] = src[8][0] = 32
dst[6][3] = src[8][1] = 33
dst[7][3] = src[8][2] = 34
dst[8][3] = src[8][3] = 35
Target:
  0  9 18 27
  1 10 19 28
  2 11 20 29
  3 12 21 30
  4 13 22 31
  5 14 23 32
  6 15 24 33
  7 16 25 34
  8 17 26 35
</code></pre>
",2
44349093,44349064,0,"<p>You can't transpose a matrix in place. That is to say, it is not possible to write a function which will take a matrix and modify it so that it is its transpose, without creating a temporary matrix of equal size. At least without some very fancy programming.</p>

<p>Now your task isn't exactly the transpose, but it seems to be very similar. So I wouldn't expect there to be a nice, in place solution. You must simply create a temporary, apply the mapping from input to temporary, and write the values back.</p>

<p>What might help is this.</p>

<pre><code>/* swap two rows of a matrix */
void swaprows(int *mtx, int width, int height, int rowa, int rowb)
{
   int i;

   for(i=0;i&lt;width;i++)
   {
      int temp = mtx[rowa*width+i];
      mtx[rowa*width+i] = mtx[rowb*width+i];
      mtx[rowa*width+i] = temp;
   }
} 

/* transpose a matrix */
int transpose(int *mtx, int width, int height)
{
    int *tmtx = malloc(width*height*sizeof(int));
    if(!tmtx)
       return -1;
    for(y=0;y&lt;width;y++)
      for(x=0;x&lt;height;x++)
        tmtx[y*height+x] = mtx[x*width+y];

    mempy(mtx, tmtx, width * height * sizeof(int));
    free(tmtx);
}


/* your logic  */

int arr[3][7] = {
            {1, 2, 3, 4, 5, 6, 7},
            {8, 9, 10, 11, 12, 13, 14}, 
            {15, 16, 17, 18, 19, 20, 21}
        };

 swaprows((int *) arr, 7, 3, 0, 1);
 transpose(int *) arr, 7, 3);
</code></pre>

<p>This seems to be what you are trying to do. </p>
",0
44349218,44349064,0,"<p>like this ?</p>

<pre><code>#include &lt;stdio.h&gt;

#define ROWS 3
#define COLS 7

int main(void){
    int arr[ROWS][COLS] = {
        {1, 2, 3, 4, 5, 6, 7},
        {8, 9, 10, 11, 12, 13, 14}, 
        {15, 16, 17, 18, 19, 20, 21}
    };
    int result[ROWS][COLS];
    int order[ROWS] = {1, 0, 2};
    int n = sizeof(arr)/sizeof(**arr);//number of elements
    int r = 0, c = 0, i = 0, j = 0;

    while(n--){
        result[r++][c] = arr[order[i]][j++];
        if(r == ROWS){
            r = 0;
            c += 1;
        }
        if(j == COLS){
            j = 0;
            i += 1;
        }
    }
    //check print
    for(r = 0; r &lt; ROWS; ++r){
        for(c = 0; c &lt; COLS; ++c)
            printf(""%-2d "", result[r][c]);
        puts("""");
    }
}
</code></pre>
",0
44349340,44349064,0,"<p>The transposition part can be done like this:</p>

<pre><code>#include &lt;stdio.h&gt;

typedef struct Sequence2D
{
    int idx_slow;
    int idx_fast;
    int max_slow;
    int max_fast;
} Sequence2D;

static inline void next2D(Sequence2D *seq)
{
    if (++seq-&gt;idx_fast == seq-&gt;max_fast)
    {
        seq-&gt;idx_fast = 0;
        if (++seq-&gt;idx_slow == seq-&gt;max_slow)
            seq-&gt;idx_slow = 0;
    }
}

static inline void dump2D(const char *tag, int rows, int cols, int data[rows][cols])
{
    printf(""%s:\n"", tag);
    for (int r = 0; r &lt; rows; r++)
    {
        for (int c = 0; c &lt; cols; c++)
            printf(""%3d"", data[r][c]);
        putchar('\n');
    }
}

enum { ROWS = 3, COLS = 7 };

int main(void)
{
    int src[ROWS][COLS] =
    {
        {  1,  2,  3,  4,  5,  6,  7 },
        {  8,  9, 10, 11, 12, 13, 14 },
        { 15, 16, 17, 18, 19, 20, 21 },
    };
    int dst[ROWS][COLS];
    Sequence2D dst2D = { 0, 0, COLS, ROWS };
    Sequence2D src2D = { 0, 0, ROWS, COLS };

    dump2D(""Source"", ROWS, COLS, src);

    for (int i = 0; i &lt; ROWS * COLS; i++)
    {
        dst[dst2D.idx_fast][dst2D.idx_slow] = src[src2D.idx_slow][src2D.idx_fast];
        printf(""dst[%d][%d] = src[%d][%d] = %d\n"",
               dst2D.idx_fast, dst2D.idx_slow,
               src2D.idx_slow, src2D.idx_fast,
               dst[dst2D.idx_fast][dst2D.idx_slow]);
        next2D(&amp;dst2D);
        next2D(&amp;src2D);
    }

    dump2D(""Target"", ROWS, COLS, dst);

    return 0;
}
</code></pre>

<p>The <code>Sequence2D</code> structure plus the <code>next2D()</code> function cycle through array indexes, changing the fast index on each call of <code>next2D()</code> and the slow index when necessary.  This saves you writing out the sequence of 21 assignments, and immediately scales to other shapes without requiring much extra work on your part.  Indeed, it would not take much to handle all the sizes as run-time inputs instead of compile-time constants.</p>

<p>The output of this code is:</p>

<pre><code>Source:
  1  2  3  4  5  6  7
  8  9 10 11 12 13 14
 15 16 17 18 19 20 21
dst[0][0] = src[0][0] = 1
dst[1][0] = src[0][1] = 2
dst[2][0] = src[0][2] = 3
dst[0][1] = src[0][3] = 4
dst[1][1] = src[0][4] = 5
dst[2][1] = src[0][5] = 6
dst[0][2] = src[0][6] = 7
dst[1][2] = src[1][0] = 8
dst[2][2] = src[1][1] = 9
dst[0][3] = src[1][2] = 10
dst[1][3] = src[1][3] = 11
dst[2][3] = src[1][4] = 12
dst[0][4] = src[1][5] = 13
dst[1][4] = src[1][6] = 14
dst[2][4] = src[2][0] = 15
dst[0][5] = src[2][1] = 16
dst[1][5] = src[2][2] = 17
dst[2][5] = src[2][3] = 18
dst[0][6] = src[2][4] = 19
dst[1][6] = src[2][5] = 20
dst[2][6] = src[2][6] = 21
Target:
  1  4  7 10 13 16 19
  2  5  8 11 14 17 20
  3  6  9 12 15 18 21
</code></pre>

<p>If you rearrange the initial matrix (<code>src</code>) according to whatever arcane rules you're using before you copy the 'transpose' of <code>src</code> into the result (<code>dst</code>), then you should be able to get the result you desire.</p>

<hr>

<p>As noted, the code can be generalized rather easily using C99 and variable-length arrays:</p>

<pre><code>#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;

typedef struct Sequence2D
{
    int idx_slow;
    int idx_fast;
    int max_slow;
    int max_fast;
} Sequence2D;

static inline void next2D(Sequence2D *seq)
{
    if (++seq-&gt;idx_fast == seq-&gt;max_fast)
    {
        seq-&gt;idx_fast = 0;
        if (++seq-&gt;idx_slow == seq-&gt;max_slow)
            seq-&gt;idx_slow = 0;
    }
}

static inline void dump2D(const char *tag, int rows, int cols, int data[rows][cols])
{
    printf(""%s:\n"", tag);
    for (int r = 0; r &lt; rows; r++)
    {
        for (int c = 0; c &lt; cols; c++)
            printf(""%3d"", data[r][c]);
        putchar('\n');
    }
}

static void transpose(int rows, int cols)
{
    assert(rows * cols &lt; 1000000);
    int src[rows][cols];
    int dst[rows][cols];
    Sequence2D dst2D = { 0, 0, cols, rows };
    Sequence2D src2D = { 0, 0, rows, cols };
    int cells = rows * cols;
    for (int i = 0; i &lt; cells; i++)
    {
        src[src2D.idx_slow][src2D.idx_fast] = i;
        next2D(&amp;src2D);
    }
    /* src2D is back to its initial state! */

    dump2D(""Source"", rows, cols, src);

    for (int i = 0; i &lt; cells; i++)
    {
        dst[dst2D.idx_fast][dst2D.idx_slow] = src[src2D.idx_slow][src2D.idx_fast];
        printf(""dst[%d][%d] = src[%d][%d] = %d\n"",
               dst2D.idx_fast, dst2D.idx_slow,
               src2D.idx_slow, src2D.idx_fast,
               dst[dst2D.idx_fast][dst2D.idx_slow]);
        next2D(&amp;dst2D);
        next2D(&amp;src2D);
    }

    dump2D(""Target"", rows, cols, dst);
}

int main(void)
{
    transpose(3, 7);
    transpose(9, 4);
    return 0;
}
</code></pre>

<p>The first section of the output is the same as before; the 9x4 part looks like:</p>

<pre><code>Source:
  0  1  2  3
  4  5  6  7
  8  9 10 11
 12 13 14 15
 16 17 18 19
 20 21 22 23
 24 25 26 27
 28 29 30 31
 32 33 34 35
dst[0][0] = src[0][0] = 0
dst[1][0] = src[0][1] = 1
dst[2][0] = src[0][2] = 2
dst[3][0] = src[0][3] = 3
dst[4][0] = src[1][0] = 4
dst[5][0] = src[1][1] = 5
dst[6][0] = src[1][2] = 6
dst[7][0] = src[1][3] = 7
dst[8][0] = src[2][0] = 8
dst[0][1] = src[2][1] = 9
dst[1][1] = src[2][2] = 10
dst[2][1] = src[2][3] = 11
dst[3][1] = src[3][0] = 12
dst[4][1] = src[3][1] = 13
dst[5][1] = src[3][2] = 14
dst[6][1] = src[3][3] = 15
dst[7][1] = src[4][0] = 16
dst[8][1] = src[4][1] = 17
dst[0][2] = src[4][2] = 18
dst[1][2] = src[4][3] = 19
dst[2][2] = src[5][0] = 20
dst[3][2] = src[5][1] = 21
dst[4][2] = src[5][2] = 22
dst[5][2] = src[5][3] = 23
dst[6][2] = src[6][0] = 24
dst[7][2] = src[6][1] = 25
dst[8][2] = src[6][2] = 26
dst[0][3] = src[6][3] = 27
dst[1][3] = src[7][0] = 28
dst[2][3] = src[7][1] = 29
dst[3][3] = src[7][2] = 30
dst[4][3] = src[7][3] = 31
dst[5][3] = src[8][0] = 32
dst[6][3] = src[8][1] = 33
dst[7][3] = src[8][2] = 34
dst[8][3] = src[8][3] = 35
Target:
  0  9 18 27
  1 10 19 28
  2 11 20 29
  3 12 21 30
  4 13 22 31
  5 14 23 32
  6 15 24 33
  7 16 25 34
  8 17 26 35
</code></pre>
",2
37339559,25876478,0,"<p>The ISO C standard states that <code>stdout</code> may be <em>fully</em> buffered (as opposed to line buffered) if the output device can be definitively determined to not be interactive (see <code>C11 7.21.3 Files /3</code> and <code>/7</code> for details).</p>

<p>A fully buffered stream won't care about newlines, it will happily buffer all your data until the buffer (for example, 4K of data) is full or the stream is closed.</p>

<p>This is generally for efficiency since flushing buffers often is relatively expensive. The reason it's done for interactive I/O is that you generally want the user to receive information immediately.</p>

<p>The likelihood is that you are running your code <em>within</em> the IDE and it's detecting that as a non-interactive device.</p>

<p>To fix it, you could flush standard output after each <code>printf</code> with something like:</p>

<pre><code>fflush (stdout);
</code></pre>

<p>or you could change it to line buffering once somewhere at the start of your program, though support for this is, I believe, implementation dependent):</p>

<pre><code>setvbuf (stdout, NULL, _IOLBF, BUFSIZ);
</code></pre>
",0
37340902,25876478,0,"<p>Building on paxidiablo answer:<BR>
I <strong>do not</strong> suppose that <code>the output device can be definitively determined to not be interactive</code> if you run Eclipse with a typical compiler. Therefore I <strong>would not assume</strong> that what you see is: <code>stdout fully buffered</code>.<BR>
I think that a more probable cause is that for some reasons (this may be a bug in Eclipse, or your omission) the executable code that you run is not the result of compiling the source code that you see, but one of its previous versions.<BR>
I believe restarting Eclipse and recompiling the program afresh should help here.</p>
",0
43769293,43769246,1,"<p>Because you left off the <code>()</code> when declaring <code>main</code>, the compiler thinks you are declaring a variable, hence the confusion expressed in the error message.</p>
",1
43769293,43769246,1,"<p>Because you left off the <code>()</code> when declaring <code>main</code>, the compiler thinks you are declaring a variable, hence the confusion expressed in the error message.</p>
",1
36339614,36339534,3,"<p><a href=""http://www.cplusplus.com/reference/cstring/strcmp/"" rel=""nofollow""><code>strcmp</code></a> returns <strong>zero</strong> if the strings are equal. Your condition is incorrect.</p>

<p>You should do <code>if (! strcmp(...)) printf(""it works"");</code> instead of <code>if (strcmp(...) != 0) ...</code></p>
",1
36339629,36339534,1,"<p>Top hello is ""Hello ""</p>

<p>While hello near line 97 is ""hello\n""</p>

<p>Either:</p>

<p>1) edit one of the hellos</p>

<p>2) use <strong>stricmp()</strong></p>
",7
36339788,36339534,1,"<pre><code>while( (read_size = recv(sock , client_message , 2000 , 0)) &gt; 0 )
</code></pre>

<p><a href=""http://linux.die.net/man/2/recv"" rel=""nofollow"">recv Linux</a></p>

<blockquote>
  <p>All three routines return the length of the message on successful completion.</p>
</blockquote>

<p>In this case, you do not ensure that the client_message has a string ending character. Many connections will only send the actual message characters and not the NULL character at the end. You should add (assuming it will fit)</p>

<pre><code>client_message[read_size] = '\0';
</code></pre>

<p>That way the <code>strlen(client_message)</code> will be certain to be correct. Alternatively you can use</p>

<pre><code>write(sock , client_message , read_size);
</code></pre>

<p>Since you are repeating the message, the sizes are the same.</p>

<p>Note that if you use the client_message string elsewhere in the code, you should make sure that the '\0' character has been added, just to be safe.</p>
",1
43206104,27361656,0,"<p>In addition to i486's correction, also the line</p>

<pre><code>            b[j] = true;
</code></pre>

<p>has to be moved out of (after) the <code>if(b[j] ){¡­}</code> block; otherwise no <code>b[j]</code> ever becomes <code>true</code>.</p>
",0
47991498,47991383,3,"<p>When <code>index</code> is 8; <code>riv64[7-index]</code> is <code>riv64[-1u]</code>, which is undefined. The <code>8u</code> in the message suggests the type of <code>index</code> is <code>unsigned int</code>, in which case <code>7-index</code> will evaluate to a very large value that is outside the array bounds. (<code>7-8u</code> will be evaluated as <code>7u-8u</code>, which is equivalent to <code>-1u</code>. Unsigned arithmetic wraps, so that produces a very large value, <code>UINT_MAX</code>.)</p>
",5
39678396,39678228,2,"<p>According to <strong><a href=""https://msdn.microsoft.com/en-us/library/d45bbxx4.aspx"" rel=""nofollow"">msdn page of</strong> <code>strcat_s()</code></a> function, it's definition is:</p>

<pre><code>errno_t strcat_s(
   char *strDestination,
   size_t numberOfElements,
   const char *strSource 
);
</code></pre>

<p>here, <code>numberOfElements</code> refers to <em>Size of the destination string buffer</em>. So you need to send in <code>1024</code>(which is size of the destination string) as your second argument instead of <code>10</code> each time you use the <code>strcat_s()</code> function this way:</p>

<pre><code>strcat_s(finalNumString, 1024, ""abcabcabc""); 
</code></pre>
",0
35240306,35240182,4,"<p>There are two problems in your code:</p>

<ul>
<li><strong>Server does not send null terminator</strong> - your code passes <code>strlen(temp)</code> to <code>write(client_sock, ...)</code>, meaning that null terminator would not be sent to the client. You need to use <code>strlen(temp)+1</code> instead.</li>
<li><strong>Client code uses <code>strlen</code></strong> - instead of <code>strlen(server_reply)</code> you should use <code>sizeof(server_reply)</code></li>
</ul>

<p>Another alternative to having the server send you <code>'\0'</code> is to null-terminate the string that you receive yourself, like this:</p>

<pre><code>ssize_t len;
if((len = recv(s , server_reply , 2000 , 0)) &lt; 0)
{
    puts(""recv failed"");
    break;
}
server_reply[len] = '\0';
puts(""Server reply :"");
puts(server_reply);
puts(""THATS IT"");
</code></pre>

<p>This would make the client more robust, avoid undefined behavior in situations when the server sends invalid replies.</p>
",4
38014330,38014111,0,"<p>You could build one generic function by using void pointers. This one mallocs everything and frees all that is allocated if malloc would return NULL somewhere on the way.</p>

<pre><code>void **alloc_2_dim(size_t ptrSize, size_t size, int n1, int n2)
{
    void ** p = malloc(n1 * ptrSize);

    if (p != NULL)
    {
        for (int i = 0; i &lt; n1; i++)
        {
            p[i] = malloc(n2 * size);

            if (p[i] == NULL)
            {
                for (int j = i; j &gt;= 0; j--)
                {
                    free(p[i]);
                }
                free(p);
                p = NULL;
                break;
            }
        }
    }

    return p;
}
</code></pre>

<p>Use it like this:</p>

<pre><code>wchar_t **p = alloc_2_dim(sizeof(wchar_t *), sizeof(wchar_t), 10, MAX_PATH_OR_CMD);
char **p = alloc_2_dim(sizeof(char *), sizeof(char), 10, MAX_PATH_OR_CMD);
</code></pre>

<p>Playing with macros you can make it a little bit clearer by removing the sizeofs.</p>

<pre><code>#define ALLOC_2D_CHAR(n1, n2) alloc_2_dim(sizeof(char *), sizeof(char), n1, n2)
#define ALLOC_2D_WCHAR(n1, n2) alloc_2_dim(sizeof(wchar_t *), sizeof(wchar_t), n1, n2)
</code></pre>
",3
38014581,38014111,-1,"<p>You can just use a single dimention array , and then you can reach the [i,j] element with an index mappaing function:</p>

<p>The allocation for the single dimention array:</p>

<pre><code>wchar_t * lFilterPatterns = malloc(aNumOfFilterPatterns*aNumOfFilterPatterns*sizeof( wchar_t));
</code></pre>

<p>The index retrievel function:</p>

<pre><code>int GetElementIndex(int i, int j, int length)
{
     return i * length + j;
}
</code></pre>

<p>Usage:</p>

<pre><code>lFilterPatterns[GetElementIndex(i,j,aNumOfFilterPatterns)] = 1;
</code></pre>
",0
38014812,38014111,0,"<p>There are 2 generally accepted methods of allocating 2D arrays in C: the contiguous method and the ragged method.  Both methods have their advantages and disadvantages. For example, you can shuffle arrays made from the ragged approach, but not contiguous. On the other hand, it takes a loop to free the ragged, but only a quick 2 frees for contiguous.</p>

<p>Contiguous:</p>

<pre><code>int** table = (int**)malloc(sizeof(int*)*rows);
int* data = (int*)malloc(sizeof(int)*rows*columns);
int i = 0;
for( i = 0; i &lt; rows; i++ )
table[i] = &amp;data[i*columns]
</code></pre>

<p>Freeing Contiguous:</p>

<pre><code>free( table[0] );
free( table );
</code></pre>

<p>Ragged:</p>

<pre><code>int** table = (int**)malloc(sizeof(int*)*rows);
int i = 0;
for( i = 0; i &lt; rows; i++ )
    table[i] = (int*)malloc(sizeof(int)*columns);
</code></pre>

<p>Freeing Ragged:</p>

<pre><code>  for( i = 0; i &lt; rows; i++ )
        free( table[i] );

  free( table );
</code></pre>
",1
38015058,38014111,2,"<p>If the function you are calling expects a <code>wchar_t **</code> as a parameter, then no, there's really not a better way to do this.  </p>
",0
45735301,45735228,3,"<p><code>-l</code> is for libraries, and you never built a library from your <code>Communication.c</code>. The simplest solution is just add <code>Communication.c</code> to your compiler command line.</p>

<hr>

<p>For larger projects, compile each translation unit separately with the <code>-c</code> switch like this:</p>

<pre class=""lang-none prettyprint-override""><code>gcc -c -Wall -Wextra -pedantic -omain.o main.c
gcc -c -Wall -Wextra -pedantic -oCommunication.o Communication.c
</code></pre>

<p>and so on ... (as a suggestion, I added some common <em>warning options</em> here, they help you spot errors)</p>

<p>The resulting <code>.o</code> files are <em>object code</em>. That's already compiled machine code, but with meta-information needed for a linker to link it with other object code into a complete executable.</p>

<p>Then link them all with one command:</p>

<pre><code>gcc -oprogram main.o Communication.o
</code></pre>

<hr>

<p>If you actually <strong>want</strong> a library from -- say -- <code>Communication.c</code> and <code>ADIS16227.c</code>, you could compile both to <em>object code</em>:</p>

<pre><code>gcc -c -Wall -Wextra -pedantic -oCommunication.o Communication.c
gcc -c -Wall -Wextra -pedantic --oADIS16227.o ADIS16227.c
</code></pre>

<p>and then use <code>ar</code> to create a <strong>static library</strong> from them:</p>

<pre><code>ar rcs libCommunication.a Communication.o ADIS16227.o
</code></pre>

<p>Then your initial compiler command would work (with the <code>-lCommunication</code> switch).</p>

<hr>

<p>Final piece of advice: <strong>Never</strong> compile as root. This is completely unnecessary. So remove your <code>sudo</code> here.</p>
",0
45735302,45735228,1,"<p>those options:</p>

<pre><code>-L /home/pi/Desktop/intern/adis16227_generic -lCommunication
</code></pre>

<p>suggest that the linker should find <code>libCommunication.a</code> (or <code>.so</code>) in the <code>/home/pi/Desktop/intern/adis16227_generic</code> directory.</p>

<p>But there are only sources in this directory. The linker won't build the sources of your ""Communication"" library for you.</p>

<p>So you could build the library and link with it:</p>

<pre><code>gcc -c ADIS16227.c Communication.c
ar r libCommunication.a ADIS16227.o Communication.o
</code></pre>

<p>but maybe the fastest &amp; quickest way to achieve a successful build would be:</p>

<pre><code>sudo gcc -o main *.c
</code></pre>

<p>so it compiles all the files of the directory into the executable called <code>main</code></p>

<p>Of course, it makes compilation times longer, but maybe it's not noticeable.</p>
",0
45735332,45735228,1,"<p>First move into the <code>/home/pi/Desktop/intern/adis16227_generic</code> directory:</p>

<pre><code>cd /home/pi/Desktop/intern/adis16227_generic
</code></pre>

<p>Then, compile the source:</p>

<pre><code>gcc ADIS16227.c Communication.c main.c -I .
</code></pre>

<p>You can now run your compiled program (called by default <code>a.out</code>):</p>

<pre><code>./a.out
</code></pre>
",0
45735374,45735228,1,"<p>You have to compile separatedly files and then compile main with related obj file.</p>

<pre><code>gcc -c Communication.c Communication.h
gcc main.c Communication.o -o main 
</code></pre>
",0
41647599,41647521,0,"<p>You are using array of pointers without initializing it first . initialize it.</p>

<p>In loop</p>

<pre><code> subsdir[i] = malloc((GetStringSize(moviesdir[i]) + 1 + 4) * sizeof(char));
</code></pre>

<p>This is the second step . First u need to initialize</p>

<pre><code> subsdir = malloc (sizeof(char*) * number);
</code></pre>
",3
37758509,37758447,1,"<p>Try this : Here I make <code>i</code> and <code>j</code> as arguments because in each recursion they have different values.</p>

<pre><code>void triangulo(int max,int i,int j) //make i and j as arguments
{
    if(i&lt;max)
    {
        if(j&lt;max)
        {
            printf(""%d"",j);
            triangulo(max, i, ++j);//dont use post increment operation
        }
        else
        {
            printf(""\n"");
            triangulo(max , ++i, 0);
        }
    }
}
</code></pre>

<hr>

<p>Generally,</p>

<ul>
<li>use <code>if</code> and <code>else</code> for condition and</li>
<li>send arguments at the end of it as what may happen in iterative method.</li>
</ul>
",10
37758554,37758447,0,"<p>I hope that links below may help:</p>

<p><a href=""http://www.refactoring.com/catalog/replaceIterationWithRecursion.html"" rel=""nofollow noreferrer"">http://www.refactoring.com/catalog/replaceIterationWithRecursion.html</a></p>

<p><a href=""http://webrewrite.com/iteration-versus-recursion-which-one-you-choose/"" rel=""nofollow noreferrer"">http://webrewrite.com/iteration-versus-recursion-which-one-you-choose/</a></p>

<p><a href=""https://stackoverflow.com/questions/19794739/what-is-the-difference-between-iteration-and-recursion"">What is the difference between iteration and recursion?</a></p>

<p><a href=""https://stackoverflow.com/questions/7939493/converting-an-iterative-function-to-recursive?rq=1"">Converting an iterative function to recursive</a></p>
",0
38209136,38208526,0,"<p>I belive that there is no cross-plattform way of doing so...</p>

<p>My solution would be the following:</p>

<ol>
<li>Read in all data from the file</li>
<li>Write new data to the file</li>
<li>Append previously (<code>1.</code>) read data at the end</li>
</ol>

<p>This will lead to the result you wanted. If you need only one writing operation, you should first manage all your data in memory before writing it to a file...</p>
",0
36758583,36758287,2,"<p>Changing the <code>scanf(""%f"",...)</code> to <code>scanf(""%lf"",...)</code> solves the issue for me. The data values in the table are no longer output as zeros. Since the <code>scanf</code> function is looking for a float in your code, it doesn't correctly read the data from the user, hence the zeros.</p>
",0
44693190,44692388,1,"<p>Your Program is unable to get the declaration of getString() method show just declare your method before calling it inside main(). What you can do is:</p>

<pre><code>#include&lt;stdio.h&gt;
/* demo.c:  My first C program on a Linux */
void getString()
{
printf(""Hello World"");
}

void main()
{
getString();
}
</code></pre>
",0
35254166,4238179,2,"<p><em>Yes you can</em>.<br><br>
<strong>Simple Program:</strong></p>

<pre><code>int main()
{
    printf(""Anything"");
    main();
    return 0;
}
</code></pre>

<p><strong>Explanation:</strong></p>

<p>A <code>call stack</code> or <code>function stack</code> is used for several related purposes, but the main reason for having one is to keep track of the point to which each active subroutine should return control when it finishes executing.</p>

<p>A <code>stack overflow</code> occurs when too much memory is used on the call stack.</p>

<p>Here function <code>main()</code> is called repeatedly and its return address is stored in the stack. After stack memory is full. It shows <code>stack overflow error</code>.</p>
",0
43228287,42680027,0,"<p>Here </p>

<pre><code>if ((x) || (y = z))
</code></pre>

<p>there are two condition
one condition is 
<code>if ((x))</code> and another condition is <code>if ((y = z))</code> 
if one of them is true then if portion is execute otherwise else condition work</p>

<ul>
<li>only and only when both condition are false then else execute.</li>
</ul>
",0
41682466,41682334,0,"<p>Use <a href=""https://www.tutorialspoint.com/c_standard_library/c_function_strcmp.htm"" rel=""nofollow noreferrer"">strcmp</a>:</p>

<pre><code>if (strcmp (sn, ""1866203214226041"") != 0) {
    printf(""Serial number is correct\n"");
}
</code></pre>
",0
41682407,41682334,0,"<p>fseek does not read from the file, it just moves the file pointer around for your next read. You need to use fread to read from the file. Documentation on fread can be found here: <a href=""https://linux.die.net/man/3/fread"" rel=""nofollow noreferrer"">https://linux.die.net/man/3/fread</a>.</p>

<p>Additionally, it is good practice to open a binary file in binary mode:</p>

<pre><code>fopen(""mtd0"",""rb"");
</code></pre>

<p>As per Alden's comment, string comparison in C is done using a function called strcmp, whose documentation can be found here: <a href=""https://linux.die.net/man/3/strcmp"" rel=""nofollow noreferrer"">https://linux.die.net/man/3/strcmp</a>.</p>

<p>Finally, you should probably fully qualify the path to mtd0, i.e.:</p>

<pre><code>fopen(""/dev/mtd0"",""rb"");
</code></pre>
",2
41682576,41682334,1,"<p>There are a few things wrong with what you're doing.</p>

<ol>
<li><p><code>fseek</code> simply adjusts the file pointer for the <em>next</em> read or write from the file; it doesn't actually retrieve anything from the file for you.  Furthermore, the valid values for the third argument to <code>fseek</code> are:</p>

<ul>
<li><p><code>SEEK_SET</code> -  set the position of the file pointer to the beginning of the file plus the value in the second argument</p></li>
<li><p><code>SEEK_CUR</code> -  set the position of the file pointer to the current position of the file pointer, plus the value in the second argument</p></li>
<li><p><code>SEEK_END</code> -  set the position of the file pointer to the end of the file.</p></li>
</ul></li>
<li><p>Assuming you meant to do ""read 16 bytes from the file at position 0x1fc30"", you would want to save that data as a byte array, not a string:</p>

<pre><code>typedef unsigned char byte; 
byte s_no[16];
fseek(fp, 0x1fc30, SEEK_SET);
fread(s_no, 1, 16, fp);
</code></pre></li>
<li><p>While <code>strcmp</code> is the correct way to compare strings in C, if the serial number is stored as <em>bytes</em>, which I'm assuming it is, because <code>/dev/mtd0</code> looks like a binary file, you would have to compare memory using <code>memcmp</code> with another byte array set to the valid value for the serial.</p></li>
</ol>
",2
36227759,36227341,2,"<p>Based on how <code>mauldiv3c</code> is used, my guess is that the definition should be</p>

<pre><code>#define mauldiv3c(x, c, o) o[0]=x[0]/c; o[1]=x[1]/c; o[2]=x[2]/c
</code></pre>

<p><code>y</code> is never used in the macro expanaio, whereas <code>c</code> is, so it doesn't make sense that the macro's second parameter is <code>y</code>.</p>
",0
36227557,36227341,0,"<p>The variable <code>c</code> is an array, which decays to a pointer when you use it in expressions like that. You can't divide a value by an array.</p>
",0
37697903,37646383,1,"<p>The conversion and error reporting could be moved to a function to simplify the calling code. Input is taken by <code>fgets</code> and the value is parsed in the function by <code>strtol</code>. This function returns success or failure. Other values get back to the caller through pointers.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;limits.h&gt;

int get_int_range ( char *line, char **next, char *delim, int *value, int min, int max);//prototype

int main( int argc, char *argv[])
{
    char line[100] = {'\0'};//input buffer
    int valid = 0;
    int size = 0;

    do {
        printf ( ""Size of tower (0 &lt;= x &lt;= 23) or quit\n"");
        fgets ( line, sizeof ( line), stdin);//read a line
        if ( strcmp ( line, ""quit\n"") == 0) {
            valid = 0;
            break;// if quit is entered, exit loop
        }
        valid = get_int_range ( line, NULL, ""\n"", &amp;size, 0, 23);// call to parse a value
    } while ( !valid);// on failure, keep looping the above

    if ( valid) {
        printf ( ""Size of tower is %d\n"", size);
    }

    return 0;
}

//inputs
// char *line : pointer to text to be parsed
// char **next : pointer to pointer to allow modification of caller's pointer
// char *term : pointer to characters to be considered terminators
// int *value : pointer to int to allow modification of caller's int
// int min : minimum value of range
// int max : maximum value of range
// returns : 0 failure or 1 success
int get_int_range ( char *line, char **next, char *delim, int *value, int min, int max)
{
    long int input = 0;
    char *end = NULL;//will point to end of parsed value

    if ( line == NULL) {
        printf ( ""no text to parse\n"");
        return 0;
    }
    if ( value == NULL) {
        printf ( ""unable to save parsed value\n"");
        return 0;
    }
    errno = 0;
    input = strtol ( line, &amp;end, 10);//get the integer from the line. end will point to the end of the parsed value
    if ( ( errno == ERANGE &amp;&amp; ( input == LONG_MAX || input == LONG_MIN))
    || ( errno != 0 &amp;&amp; input == 0)){// parsing error from strtol
        perror ( ""input"");
        return 0;
    }
    if ( end == line) {// nothing was parsed. no digits
        line[strcspn ( line, ""\n"")] = '\0';//remove newline
        printf ( ""input [%s] MUST be a number\n"", line);
        return 0;// return failure
    }
    // *end is the character that end points to
    if ( *end != '\0' &amp;&amp; !( delim &amp;&amp; strchr ( delim, *end))) {// is *end '\0'? is *end in the set of term characters?
        line[strcspn ( line, ""\n"")] = '\0';//remove newline
        printf ( ""problem with input terminator: [%s] \n"", line);
        return 0;
    }
    if ( input &lt; min || input &gt; max) {// parsed value is outside of range
        printf ( ""input out of range %d to %d\n"", min, max);
        return 0;
    }

    if ( next != NULL) {// if next is NULL, caller did not want pointer to end of parsed value
        *next = end;// *next allows modification to caller's pointer
    }
    *value = input;// *value allows modification to callers int
    return 1;// success
}
</code></pre>
",0
39664186,28122420,0,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
int main()
{
    int test;
    scanf(""%d"",&amp;test);
    while(test--)
    {
        unsigned int low,high,i=0,j=2,k,x=0,y=0,z;
        unsigned long int a[200000],b[200000];
        scanf(""%d"",&amp;low);
        scanf(""%d"",&amp;high);
        for(i=low;i&lt;=high;i++)
            a[x++]=i;
        for(i=2;i&lt;=32000;i++)
            b[y++]=i;
        i=0;
        while(b[i]*b[i]&lt;=high)
        {
            if(b[i]!=0)
            {
                k=i;
                for(;k&lt;y;k+=j)
                {
                    if(k!=i)
                    {
                        b[k]=0;
                    }
                }
            }
            i+=1;j+=1;
        }
            for(i=0;i&lt;y;i++)
            {
                if(b[i]!=0 &amp;&amp; (b[i]&gt;=low &amp;&amp; b[i]&lt;=sqrt(high)))
                    printf(""%d\n"",b[i]);
            }
            int c=0;
            for(i=0;i&lt;y;i++)
            {
                if(b[i]!=0 &amp;&amp; (b[i]&gt;=1 &amp;&amp; b[i]&lt;=sqrt(high)))
                    b[c++]=b[i];
            }
            int m=a[0];
            for(i=0;i&lt;c;i++)
            {
                z=(m/b[i])*b[i];k=z-m;
                if(k!=0)
                    k += b[i];
                for(;k&lt;x;)
                {
                    if(a[k]!=0)
                    {
                        a[k]=0;
                    }
                    k+=b[i];
                }
            }
            for(i=0;i&lt;x;i++)
            {
                if(a[i]!=0 &amp;&amp; (a[i]&gt;=2 &amp;&amp; a[i]&lt;=(high)))
                    printf(""%d\n"",a[i]);
            }
        printf(""\n"");
    }
    return 0;
}
</code></pre>
",0
47460628,47460564,7,"<p>(Restricting the answer to IEEE754 although all floating point schemes supported by C mandate that the <code>double</code> set is a superset of the <code>float</code> set.)</p>

<p><code>0.1</code> is <code>0.1000000000000000055511151231257827021181583404541015625</code></p>

<p><code>0.1f</code> is <code>0.100000001490116119384765625</code>.</p>

<p><code>0.100000001490116119384765625</code> is promoted to a <code>double</code>, but it's the same number as all <code>float</code>s can be represented as <code>double</code>s exactly.</p>

<p>So <code>(double)(0.1f)</code> is bigger than <code>0.1</code>, accounting for the result.</p>
",0
47460639,47460564,2,"<p>The key issue is that <code>0.1</code> can't be represented <strong>exactly</strong> in binary. Converting this to base 2, you get a number with a <em>repetend</em> in the fraction part, <code>1001</code> is repeating forever (just like in decimal, <code>1/3</code> ends up with <code>3</code> repeating forever).</p>

<p>When storing <code>0.1</code> in a float, it ends up getting <em>rounded up</em> in the last digit *), therefore the <code>float</code> 0.1 is larger than the <code>double</code> 0.1</p>

<p>So, yes, converting the <code>float</code> to <code>double</code> just appends (binary) zeros, but the <code>float</code> was already a bit too large in the first place.</p>

<hr>

<p>*) this actually depends on the representation of floating point numbers your implementation uses. With IEEE 754 <code>float</code>s, the representation would end with</p>

<pre><code>... 10011001100
</code></pre>

<p>and because the next digit would be a 1, rounding is done upwards, so the final result ends with</p>

<pre><code>... 10011001101
</code></pre>
",3
41655648,41655586,4,"<p>In ""old"" C all declarations must be at the top of the functions. In later versions like C99, C declarations can be anywhere in the code. I guess you have an old compiler.</p>
",0
41661419,41655586,0,"<p>Change your code to</p>

<pre><code>void f(void) {
  int i;
  int j;
  i = 6;
  j = 20;
}
</code></pre>

<p>The problem is that for some old compilers you need to declare the variables before any executable statement. If you do not want to have this problem, switch to a newer compiler.</p>
",0
41661862,41655586,0,"<p>If your compiler is configured to compile c code following c98 then you will get this error because following c98 standard the d¨¦claration of variables must be done first then we can make assignment so we can't make declaration of variable in the middle of the code. </p>

<p>However you can select the option to compile your code following the standard c99 and in this case you can make the d¨¦claration of variable in the middle of your code.</p>
",0
35218244,24535344,0,"<p><strong>Explanation Code 1:</strong></p>

<p>if <code>(0.7 &gt; a)</code> here <code>a</code> is a float variable and <code>0.7</code> is a double constant. The double constant <code>0.7</code> is greater than the float variable a. Hence the if condition is satisfied and it prints <code>'Hi'</code>
<br><strong>Example:</strong></p>

<pre><code>#include&lt;stdio.h&gt;
int main()
{
    float a=0.7;
    printf(""%.10f %.10f\n"",0.7, a);
    return 0;
}
</code></pre>

<p><br><strong>Output:</strong><br><br>
0.7000000000 0.6999999881</p>

<p><strong>Consider this code:</strong></p>

<pre><code>int main(void)
{
    int a = 300, b,c;
    if (a&gt;=400)
      b=300;
    c=200;
    printf(""%d %d %d\n"",a,b,c);
 }
</code></pre>

<p><strong>Explanation:</strong></p>

<p><strong>Step 1:</strong>  <code>int a = 300, b, c;</code> here variable <code>a</code> is initialized to <code>'300'</code>, variable <code>b</code> and <code>c</code> are declared, but not initialized.<br><br>
<strong>Step 2:</strong> <code>if(a &gt;= 400)</code> means <code>if(300 &gt;= 400)</code>. Hence this condition will be failed.<br><br>
<strong>Step 3:</strong> <code>c = 200;</code> here variable <code>c</code> is initialized to <code>'200'</code>.<br><br>
<strong>Step 4:</strong> <code>printf(""%d, %d, %d\n"", a, b, c);</code> It prints <code>""300, garbage value, 200""</code>. because variable <code>b</code> is not initialized.</p>
",0
37342226,37341693,6,"<p>Not tested (no time). Hope it helps.</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    float num = 0.0;
    float i = 1.0;
    char ch;

    printf(""Enter a float number: "");

    while((ch = getchar()) != '\n')
    {
        if (ch == '.')
        {
            i = 0.1;
        }
        else if ((ch&gt;= '0') &amp;&amp; (ch &lt;='9'))
        {
            if (i==1)
            {
                num *= 10;
                num += ch - '0';
            }
            else
            {
                num += (ch - '0') * i;
                i /= 10;
            }
        }
    }

    printf(""%.4f\n"", num);

    return 0;
}
</code></pre>
",0
37342235,37341693,0,"<p>It would be simpler if you first write a function reading integer.</p>

<p>Then you can think about writing a function reading the decimal part and combine the result.</p>

<p>Also, you need to accumulate the read information. At the moment you are overwriting previously read digit with a new one.</p>
",0
37343964,37341693,3,"<p>Ok, so you should first specify what you want - as usual keep away from the keybord until you exactly know what you want to build:</p>

<ul>
<li>read until end of file or first new line</li>
<li>skip initial blank characters (optional but not expensive)</li>
<li>ignore trailing blank character (optional but not expensive)</li>
<li>reject any non blank after first trailing blank</li>
<li>reject any character other than blanks, digits and dot</li>
<li>process the integer part (until first dot) but multiplying current value by 10 and adding character code minus char '0'</li>
<li>ensure at most one dot</li>
<li>process the decimal part by adding char - '0' multiplied by 0.1 power decimal position</li>
</ul>

<p>Once that has been stated coding is simple and could be:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;

void error(int pos, char c) {
    fprintf(stderr, ""Unwanted character %c at %d\n"", c, pos);
    exit(1);
}

int main() {
    double f = 0.;
    int c;
    bool initial = 1, final=0;
    int pos = 0;
    double decimal = 0;

    while (((c = getchar()) != EOF) &amp;&amp; (c != '\n')) {
        pos += 1;
        if (isspace(c)) { // accept spaces before and after the number
            if (initial || final) continue;
            else {
                final = 1;
                continue;
            }
        }
        else if (final) {  // do not accept anything after a space after the number
            error(pos, c);
        }
        initial = 0;     // at least one non blank char
        if (c == '.') {
            if (decimal) { // accept only one decimal dot
                error(pos, c);
            }
            else decimal = 1;
        }
        else if (! isdigit(c)) { // only digits
            error(pos, c);
        }
        else if (decimal == 0) {
            f = f * 10 + c - '0';   // integer part
        }
        else {
            decimal *= .1;     // fractional part
            f += (c - '0') * decimal;
        }
    }
    printf(""%.4f\n"", f);

    return 0;
}
</code></pre>

<p>As a bonus I showed you how to process error conditions</p>
",0
37348098,37341693,0,"<p>Another possibility using only <code>stdio</code> in solving the task could be a simple two-step process:</p>

<ul>
<li>declaring and reading the input into a character array, using some more or less sophisticated fool-proofing</li>
<li>""parsing"" the array members on the left and right hand side of the decimal point and multiplying the ('0' offset subtracted value) by the corresponding power of 10.</li>
</ul>

<p>_</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
  float power_of_ten, num = 0.;
  char c, ch[32];
  int j, i = 0;
  int point_pos = -1; //initialize decimal point position 'offscale'

  while(((c = getchar()) != EOF) &amp;&amp; (c != '\n')) //simple fool-proof check
    if(((c &gt;= '0')&amp;&amp;(c &lt;= '9')) || (( c == '.')&amp;&amp;(point_pos == -1))){
      ch[i] = c;
      if(ch[i] == '.') 
          point_pos = i;
      i++;
      }
  ch[++i] = '\0'; //length of the array
  //parsing the array
  if(point_pos &gt;= 0){  //to the right of decimal point
      power_of_ten = .1;
      for(j = point_pos + 1; j &lt; i-1; j++){      
          num += (float)(ch[j] - '0')*power_of_ten;
          power_of_ten *= .1;
          }
      }

  power_of_ten = 1.;   //to the left of decimal point
  if(point_pos == -1)point_pos = i-1;  
  for(j = point_pos - 1; j &gt;= 0 ; j --){  
      num += (float)(ch[j] - '0')*power_of_ten;
      power_of_ten *= 10;
      }

   printf(""%.4f\n"", num); 

  return 0;
}
</code></pre>
",0
47503854,47503735,3,"<p>Unreachable code is not an error because:</p>

<ol>
<li><p>It's often useful, especially as the result of macro expansion or functions which are only ever called in a way that makes some paths unreachable due to some of their arguments being constant or limited to particular range. For instance, with an inline version of <code>isdigit</code> that's only ever called with non-negative arguments, the code path for an <code>EOF</code> argument would be unreachable.</p></li>
<li><p>In general, determining whether code is unreachable is equivalent to the halting problem. Sure there are certain cases like yours that are trivial to determine, but there is no way you can specify something like ""trivial cases of unreachable code are errors, but nontrivial ones aren't"".</p></li>
</ol>
",6
47503794,47503735,1,"<p>Broadly speaking, C does not aim to help a developer catch mistakes; rather, C trusts the developer to do a perfect job, just as it trusts the compiler to do a perfect job.</p>

<p>Many newer languages take a more active stance, aiming to protect the developer from his or herself &mdash; and plenty of C compilers will emit compile-warnings (which can typically be ""promoted"" to errors via command-line flags) &mdash; but the C community has never wanted the language to stop trusting developers. It's just a philosophical difference. (If you've ever run into a case where a language prevents you from doing something that seems wrong but that you actually have a good reason for, you'll probably understand where they're coming from, even if you don't agree.)</p>
",2
46102958,46102910,3,"<p>You read an <em>integer</em> not a character. The <a href=""http://en.cppreference.com/w/c/string/byte/isdigit"" rel=""nofollow noreferrer""><code>isdigit</code></a> checks if a <em>character</em> is a digit. If <code>current</code> is a single-digit number then it is, by virtue of being a single-digit number, definitely a ""digit"".</p>

<p>Because of this, the <code>isdigit</code> function will always return <code>0</code> (unless you enter a decimal value that correspond the the current character-encoding values for digits), which is equal to false in C, so you never increase <code>counter</code>.</p>

<p>For your problem I would use the <code>""%u""</code> format to <code>scanf</code> to read an unsigned decimal number, and check what <a href=""http://en.cppreference.com/w/c/io/fscanf"" rel=""nofollow noreferrer""><code>scanf</code></a> returns to see if the input was correct or not.</p>

<p>Note that if the input is not correct, it will be left in the input buffer for the next call to <code>scanf</code>, unless you remove it. The only portable way to remove it is to read character by character until you have read a newline.</p>
",1
46103217,46102910,0,"<p><a href=""https://stackoverflow.com/a/46102958/14660"">As @SomeProgrammerDude pointed out</a>, <code>isdigit</code> checks if a character is a digit. You're passing it an integer. It will interpret that integer as a character, so it will think <code>10</code> is a newline and <code>43</code> is a <code>+</code>. If you give it <code>50</code> it will pass because that's character <code>2</code>.</p>

<p>To check that <code>scanf</code> got an integer, don't check <code>current</code> because that will contain garbage if <code>scanf</code> failed. Instead, check the return value of <code>scanf</code> which tells you how many items it matched.</p>

<pre><code>int counter = 0;
int largest = 0;

// It's safer to check for X &lt; BOUND than X != BOUND in case
// X happens to go over the BOUND.
while (counter &lt; 10) { 
    int current;
    printf(""%s"", ""Enter non-negative number: "");

    // What if `scanf` didn't get a number?
    if( scanf(""%d"", &amp;current) != 1 ) {
        puts(""That doesn't look like a number"");
    }
    // What if it isn't positive?
    else if( current &lt; 0 ) {
        puts(""Invalid number. Number must be positive. \n"");
    }
    // Now that all the error conditions have been checked...
    else {
        if (current &gt; largest)
        {
            largest = current; 
        }
        counter++; 
    }
}
printf(""%d"", largest);
</code></pre>

<p>But there's still a problem. If you get an invalid number, the code will go into an infinite loop. This is one of the <a href=""http://c-faq.com/stdio/scanfprobs.html"" rel=""nofollow noreferrer"">many, many, many problems with <code>scanf</code></a> in particular <a href=""http://c-faq.com/stdio/scanfjam.html"" rel=""nofollow noreferrer"">this one</a>.</p>

<p>The problem is that <code>scanf</code> does not read lines, it reads as much as you tell it to. If it fails to read that much, it just leaves it on the buffer. If <code>scanf</code> fails it will leave the input on <code>stdin</code>. When you go to read again, you'll read the same input and fail again. If there's any extra input on the line, like <code>10 foo</code> it will read the <code>10</code> and then leave <code>foo</code> on the buffer to be read by the next call to <code>scanf</code>.</p>

<p>The general solution is to read input line by line and parse the line. Use <code>fgets</code> to read the line and <code>sscanf</code> to scan the string.</p>

<pre><code>int counter = 0;
int largest = 0;
char line[255];
while (counter &lt; 10) {
    int current;

    printf(""%s"", ""Enter non-negative number: "");
    fgets(line, sizeof(line), stdin);

    if( sscanf(line, ""%d"", &amp;current) != 1 ) {
        puts(""That doesn't look like a number"");
    }
    ...and the rest is the same...
}
</code></pre>

<p>This guarantees you'll never get into an infinite loop. Though if the input is larger than <code>line</code> it might have to loop through <code>fgets</code> several times to get all the input.</p>
",2
46103305,46102910,1,"<p>isdigit() is used to check whether a character's ASCII code is the
       equivalent ASCII code of a number from 0-9. You should use it only
       with a character variable.  </p>

<p>scanf(""%d"",&amp;current) will always read an integer to the variable current. You need not check it. If you
   enter a character in the input you get an infinite loop since scanf()
   cannot store the character in any variable i.e. it is not getting what it is expecting.</p>

<p>You can get around the infinite loop problem by writing 
scanf(""%s"",&amp;str) where str is a character array(string) instead of scanf_s(""%d"", &amp;current). 
Now you can check whether the first character i.e. isdigit(str[0]).
If not a number skip it else
convert it to a number using atoi() function.</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;ctype.h&gt;
#include&lt;stdlib.h&gt;
#define BUF_LEN 256
int main()
{
    int counter = 0;
    int largest = 0;
    while (counter != 10) 
    { 
        char str[BUF_LEN];
        printf(""%s"", ""Enter non-negative number: ""); 
        scanf(""%s"", str); 
        if (isdigit(str[0]))//If first character is a digit then we asume that str contains a valid number. You should actually check it for all the characters in the string.
        {
            int current = atoi(str);//Convert string to integer (ASCII to Integer).
            if (current &gt; largest)
            {
                largest = current; 
            }
            counter++; 
        }
        else 
        {
        puts(""Invalid number. Number must be positive. \n"");
        }

    }
    printf(""%d"", largest);
}
</code></pre>
",0
38863232,38863162,5,"<blockquote>
  <p>but <code>#pragma once</code> SHOULD guard against that</p>
</blockquote>

<p><code>#pragma once</code> is used to avoid reduplicate including within <strong>single translation unit</strong> (<code>.c</code> file in this case), but it can't prevent multiple definition crossing multiple translation unit.</p>

<p>You're defining global variable <code>ONE</code> and <code>TWO</code> in <code>.h</code> file, and they're included in multiple translation unit and cause multiple definition error.</p>

<p>For example, finally, <code>ONE</code> will be defined in <code>X.c</code> and <code>Main.c</code>, <code>TWO</code> will be defined in <code>Y.c</code>, <code>X.c</code> and <code>Main.c</code>.</p>

<p>You should declare <code>ONE</code> and <code>TWO</code> in <code>.h</code> file (by using <code>extern</code>), and define them in <code>.c</code> file.</p>

<p>X.h</p>

<pre><code>#pragma once

#include ""Y.h""

extern int ONE;
int combine();
</code></pre>

<p>X.c</p>

<pre><code>#include ""X.h""

int ONE = 1;

int combine()
{
    return ONE + TWO;
}
</code></pre>

<p>Y.h</p>

<pre><code>#pragma once

extern int TWO;
</code></pre>

<p>Y.c</p>

<pre><code>#include ""Y.h""

int TWO = 2;
</code></pre>
",11
38863376,38863162,1,"<p><code>#pragma once</code> only guards against the same header being included twice in the same compilation unit.  It does not prevent problems when you define the same variable in multiple compilation units.</p>

<p>To see what's wrong, let's walk through what each compilation unit looks like as it's being compiled.</p>

<p>After preprocessing, X.c ends up looking like this:</p>

<pre><code>int TWO = 2;

int ONE = 1;

int combine();

int combine()
{
    return ONE + TWO;
}
</code></pre>

<p>As you can see, it contains definitions for the symbols <code>TWO</code>, <code>ONE</code>, and <code>combine</code>.</p>

<p>Y.c ends up looking like this:</p>

<pre><code>int TWO = 2;
</code></pre>

<p>It also defines the symbol <code>TWO</code>.</p>

<p>main.c looks like this:</p>

<pre><code>int TWO = 2;

int ONE = 1;

int combine();

int main()
{
    int fusion = combine();

    return 0;
}
</code></pre>

<p>So it also has definitions for <code>TWO</code> and <code>ONE</code>, along with <code>main</code>.</p>

<p>So after compilation, we end up with 3 object files, all three of which have definitions for <code>TWO</code>, and two of which have definitions for <code>ONE</code>.  When we get to linking, the linker sees references to <code>ONE</code> and <code>TWO</code> in the definition of <code>combine</code> and goes looking for those symbols' definitions.  Since they're defined in multiple places, it throws an error and gives up.</p>

<p>You can fix this problem by <em>declaring</em> <code>ONE</code> and <code>TWO</code> in X.h and Y.h and <em>defining</em> <code>ONE</code> and <code>TWO</code> in X.c and Y.c.</p>
",14
38863342,38863162,0,"<p><code>#pragma once</code> prevents a header file from getting included more than once when compiling a single source module.</p>

<p>That's all it does.</p>

<p>Your header file is getting included from two different source modules.</p>

<p>That header file declares and defines an object in global scope.</p>

<p>Both of your two source modules, therefore, end up defining the same object in global scope.</p>

<p>And that's where the duplicate symbol definition comes from.</p>

<p><code>#pragma once</code> is not a substitute for knowing and understanding C++ scoping rules.</p>
",2
39111288,39110879,1,"<p>Simply do</p>

<pre><code> uint8_t brightnesstable[101]; 
 memcpy(brightnessstable, brightnessvariants[index], 101*sizeof(uint8_t));
</code></pre>

<p><code>brightnessvariants[index]</code> is the address of the first item in the <code>(index+1)nth</code> row and the number of bytes you want to copy is 
<code>ROWSIZE*sizeof(ITEM_SIZE)</code>.</p>
",1
39111464,39110879,1,"<p>It really depends on what you need to do. If you need to create separate storage for a duplication of one of the rows of <code>brightnessvariants</code>, then you can simply declare a separate array and copy the values as discussed in the comments and the other answer. </p>

<p>If, however, you simply need to access one of the rows of <code>brightnessvariants</code> in the current scope, then there is no need for separate storage and copying. All that is required is to declare a pointer and assign the starting address of the desired row. Then you can access the desired row of <code>brightnessvariants</code> as if it were a separate array. e.g.</p>

<pre><code>uint8_t brightnessvariants[4][101] = {{0}}, *btable = NULL;
</code></pre>

<p>Above, <code>btable</code> (short for your <code>brightnesstable</code>) is simply a <code>uint8_t</code> pointer. It can be assigned the the address of any of the rows in <code>brightnessvariants</code>. e.g. for the second row</p>

<pre><code>btable = brightnessvariants[1];
</code></pre>

<p><code>btable</code> can then be used to access any value within the second row, just as if it were a separate array. Here is a short example that may help:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;

int main (void) {

    uint8_t brightnessvariants[4][101] = {{0}}, *btable = NULL;
    int nrows = sizeof brightnessvariants / sizeof *brightnessvariants;

    for (int i = 0; i &lt; 101; i++) {
        brightnessvariants[0][i] = i + 1;
        brightnessvariants[1][i] = i + 3;
        brightnessvariants[2][i] = i + 5;
        brightnessvariants[3][i] = i + 7;
    }

    for (int i = 0; i &lt; nrows; i++) {
        printf (""\nbrightnesstable[%d] :\n\n"", i);
        btable = brightnessvariants[i];
        for (int j = 0; j &lt; 101; j++) {
            if (j &amp;&amp; j % 10 == 0) putchar ('\n');
            printf ("" %3hhu"", btable[j]);
        }
        putchar ('\n');
    }

    return 0;
}
</code></pre>

<p><strong>Example Use/Output</strong></p>

<pre><code>$ ./bin/ptrtobtable

brightnesstable[0] :

   1   2   3   4   5   6   7   8   9  10
  11  12  13  14  15  16  17  18  19  20
  21  22  23  24  25  26  27  28  29  30
  31  32  33  34  35  36  37  38  39  40
  41  42  43  44  45  46  47  48  49  50
  51  52  53  54  55  56  57  58  59  60
  61  62  63  64  65  66  67  68  69  70
  71  72  73  74  75  76  77  78  79  80
  81  82  83  84  85  86  87  88  89  90
  91  92  93  94  95  96  97  98  99 100
 101

brightnesstable[1] :

   3   4   5   6   7   8   9  10  11  12
  13  14  15  16  17  18  19  20  21  22
  23  24  25  26  27  28  29  30  31  32
  33  34  35  36  37  38  39  40  41  42
  43  44  45  46  47  48  49  50  51  52
  53  54  55  56  57  58  59  60  61  62
  63  64  65  66  67  68  69  70  71  72
  73  74  75  76  77  78  79  80  81  82
  83  84  85  86  87  88  89  90  91  92
  93  94  95  96  97  98  99 100 101 102
 103

brightnesstable[2] :

   5   6   7   8   9  10  11  12  13  14
  15  16  17  18  19  20  21  22  23  24
  25  26  27  28  29  30  31  32  33  34
  35  36  37  38  39  40  41  42  43  44
  45  46  47  48  49  50  51  52  53  54
  55  56  57  58  59  60  61  62  63  64
  65  66  67  68  69  70  71  72  73  74
  75  76  77  78  79  80  81  82  83  84
  85  86  87  88  89  90  91  92  93  94
  95  96  97  98  99 100 101 102 103 104
 105

brightnesstable[3] :

   7   8   9  10  11  12  13  14  15  16
  17  18  19  20  21  22  23  24  25  26
  27  28  29  30  31  32  33  34  35  36
  37  38  39  40  41  42  43  44  45  46
  47  48  49  50  51  52  53  54  55  56
  57  58  59  60  61  62  63  64  65  66
  67  68  69  70  71  72  73  74  75  76
  77  78  79  80  81  82  83  84  85  86
  87  88  89  90  91  92  93  94  95  96
  97  98  99 100 101 102 103 104 105 106
 107
</code></pre>

<p>Look things over and let me know if you have any questions. If you need an example of copying instead of the use of a pointer, let me know and I'm happy to help.</p>
",0
35222220,35222163,3,"<blockquote>
  <p>What will be the output of this code </p>
</blockquote>

<p>Anything can happen as the code provokes undefined behaviour by printing a pointer value using the conversion specifier for an <code>unsigned</code>.</p>

<p>To print pointer values use the conversion specifier <code>p</code>.</p>

<hr>

<p>The address of an array and the address of its 1st element are the same. Pointers to them both however are of different type.</p>

<hr>

<p><code>x</code> as well as <code>x + 3</code> are of type <code>int (*)[3]</code>, that is pointing to an array of three <code>int</code>s. Assuming <code>int</code> to be of size <code>4</code>, an array of three <code>int</code>s is of size <code>12</code>.</p>

<p>Increasing <code>x</code> (a pointer to <code>int (*)[3]</code>) by three elements one ends up with an address <code>3 * 12</code> bytes beyond where <code>x</code> points to. This is called pointer arithmetic.</p>
",7
35222313,35222163,1,"<p>You're misusing a format specifier and invoking undefined behavior because of that. At that point, what happens is arbitrary and uninteresting.</p>

<p>If you want to print a pointer, use the <code>%p</code> specifier.</p>
",3
35222675,35222163,1,"<p>x is a pointer to an array of pointers. The array of pointers has 4 elements. Each of these four elements points to 3 integers.</p>

<p>Hence if x = 2000 then,</p>

<p>x[0] = 2000, x[1] = 2012, x[2] = 2024, x[3] = 2036.</p>

<p>Therefore, </p>

<p>x + 3 = 2036 (because x is an array pointer and it increases by 12 each time.)</p>

<p>*(x+3) = x[3] = 2036 again.</p>

<p>*(x+2)+3 = x[2] + 3 = 2024 + 3*4 = 2036 again.</p>

<p>Hence the output will be three same numbers. </p>
",0
36271776,36271734,5,"<p><code>seed</code> is of type <code>int</code>.  <code>seed*seed</code> will also be of type <code>int</code>.  And <code>88888*88888</code> overflows the size of <code>int</code>.  You then assign this garbage value to your <code>long long</code>.</p>

<p>Change the type of <code>seed</code>, or cast in you calculation:</p>

<pre><code>long long square = ((long long) seed) * seed;
</code></pre>
",2
40572968,40572410,1,"<p>As other mentioned:</p>

<p>changing <code>* (start + i)</code> to <code>start[i]</code> improves readability</p>

<p><code>""\0""</code> should be <code>'\0'</code> or simply 0 - in c, double quotes are used to represent strings, and strings are actually memory addresses.</p>

<p>array indexes start from 0</p>

<p>Also keep in mind that strings write in clear in the source (ex: ""abcba this is a string"") are constant strings (const char*) and must be copied to other location in order to modify them.</p>

<pre><code>void RemoveSame(char * start) {
    int i, j, k;

    for (i = 0; start[i];) { // advance while haven't reached the string's end
        if (start[i] != ' ') {
            for (j = i + 1; ; ++j) {
                if (start[j] == ' ' || !start[j]) { // advance until I find a word
                    if (start[i] == start[j - 1]) {
                        for (k = i; (start[k] = start[k + j - i]); ++k); // delete word
                    }
                    else {
                        i = j;
                    }
                    break;
                }
            }
        }
        else {
            ++i;
        }
    }
}
</code></pre>
",0
40573063,40572410,0,"<p>like this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

char *RemoveSame(char *str) {
    char *from, *to, *p;
    from = to = str;
    while(*from){
        if(isspace((unsigned char)*from)){//pre spaces copy before processing a word
            *to++ = *from++;
            continue;
        }
        p = from;//top of word
        while(*p &amp;&amp; !isspace((unsigned char)*p))
            ++p;
        if(*from == p[-1])//top == end
            from = p;//skip
        else {
            while(*from &amp;&amp; !isspace((unsigned char)*from))
                *to++ = *from++;//copy
        }
    }
    *to = 0;
    return str;
}

int main(void) {
    char sentence[] = ""madam adam madam ada adam eve"";
    printf(""'%s'\n"", RemoveSame(sentence));

}
</code></pre>
",2
40573599,40572410,0,"<p>Your function <code>RemoveSame()</code> has multiple problems:</p>

<ul>
<li><p><code>i</code> should start at <code>0</code></p></li>
<li><p><code>j</code> should start at <code>1</code>.  You are accessing characters much too far into the string with <code>start[i + j + 1]</code></p></li>
<li><p>you should stop at the <code>'\0'</code></p></li>
<li><p>you never copy the characters of the words you wish to keep</p></li>
<li><p>setting the rest of the string to <code>0</code> seems unnecessary, but in any case you should use the null character <code>'\0'</code> instead of an empty string <code>""\0""</code></p></li>
</ul>

<p>Here is a corrected version:</p>

<pre><code>void RemoveSame(char *str) {
    int i, j, to = 0;
    for (i = 0; str[i] != '\0';) {
        if (str[i] == ' ') {
            str[to++] = str[i++];
            continue;
        }
        for (j = 1; str[i + j] != '\0'; j++) {
            if (str[i + j] == ' ')
                break;
        }
        if (str[i] == str[i + j - 1]) {
            /* skip the word */
            i += j;
            continue;
        }
        for (; j &gt; 0; j--) {
            str[to++] = str[i++];
        }
    }
    str[to] = '\0';  /* set the null terminator */
}
</code></pre>

<p>Notes:</p>

<ul>
<li><p><code>str</code> is a more explicit name for a string than <code>start</code>.</p></li>
<li><p>using the array notation <code>str[i]</code> is much more readable than <code>*(str + i)</code>.</p></li>
<li><p>the spaces before or after the removed word should probably be removed too.</p></li>
</ul>

<p>There are other problems in your code:</p>

<ul>
<li><p><code>scanf(""%s"", &amp;readerName);</code> is incorrect, use <code>scanf(""%s"", readerName);</code> instead.</p></li>
<li><p>allocating <code>line</code> this way: <code>line = calloc(FILE_NAME_LENGTH, FILE_NAME_LENGTH * sizeof(char))</code> is incorrect, use an automatic array instead: <code>char line[LINE_LENGTH];</code></p></li>
<li><p><code>while (!feof(reader))</code> is always wrong.  Use <code>while (fgets(line, LINE_LENGTH, reader))</code> instead.</p></li>
<li><p><code>WriteLine()</code> should stop at the first <code>'\0'</code>.</p></li>
<li><p>you should use <code>'\0'</code> for the null character, not <code>NULL</code> as in <code>*(start + i) != NULL</code></p></li>
</ul>
",0
40573090,40572410,1,"<p>For starters the code is so bad formatted that it is difficult to understand what it does.</p>

<p>It is not clear why the outer loop starts from 1.
The inner loop</p>

<pre><code>  for (j = i; j &lt; LINE_LENGTH; j++) {
    if ( * (start + i + j + 1) == ' ') {
      last = * (start + i + j);
    } else {
      break;
    }
  }
</code></pre>

<p>does not make any sense.</p>

<p>This loop</p>

<pre><code>for (; i != j; i++) {
  k = j - i; 
  * (start + k) = ""\0"";
}
</code></pre>

<p>also does not make sense and moreover in this statement</p>

<pre><code>  * (start + k) = ""\0"";
</code></pre>

<p>you are trying to assign an object of type <code>char</code> with a value of type <code>char *</code>. The compiler should issue here a diagnostic message.</p>

<p>It is also unclear why you do not use standard C functions.</p>

<p>The function can look the following way as it is shown in this demonstrative program</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;

#define N   100

char * remove_words( char *s )
{
    size_t n = strlen( s );

    char *t = s;

    while ( *t )
    {
        while ( isblank( ( unsigned char )*t ) ) ++t;

        char *last = t;

        if ( *last++ )
        {
            while ( *last &amp;&amp; !isblank( ( unsigned char )*last ) ) ++last;

            if ( t[0] == last[-1] ) memmove( t, last, n - ( last -t ) + 1 );
            else t = last;
        }
    }

    return s;
}

int main( void ) 
{
    while ( 1 )
    {
        char s[N];

        printf( ""Input a sentence: (Enter - exit): "" );

        if ( fgets( s, sizeof( s ), stdin ) == NULL || s[0] == '\n' ) break;

        s[ strcspn( s, ""\n"") ] = '\0';

        puts( s );

        puts( remove_words( s ) );

        printf( ""\n"" );     
    }       

    return 0;
}
</code></pre>

<p>Its output might look like</p>

<pre><code>Input a sentence: (Enter - exit): ab aba abc abcbca dd d
ab aba abc abcbca dd d
ab  abc   

Input a sentence: (Enter - exit): 
</code></pre>

<p>Another approach is to delete also blanks that follow the word that must be deleted. And it is more efficient than the first approach.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;

#define N   100

char * remove_words( char *s )
{
    char *destination = s;

    //  for starters skip leading blands
    while ( isblank( ( unsigned char )*destination ) ) ++destination;

    char *source = destination;

    while ( *source )
    {
        char *last = source;

        if ( *last++ )
        {
            while ( *last &amp;&amp; !isblank( ( unsigned char )*last ) ) ++last;

            char *blank_tail = last;

            while ( isblank( ( unsigned char )*blank_tail ) ) ++blank_tail;

            if ( source[0] != last[-1] )
            {
                //  copy valid word to the destination
                if ( destination != source )
                {
                    memmove( destination, source, blank_tail - source );
                }
                destination += blank_tail - source;
            }

            source = blank_tail;
        }
    }

    *destination = '\0';

    return s;
}

int main( void ) 
{
    while ( 1 )
    {
        char s[N];

        printf( ""Input a sentence: (Enter - exit): "" );

        if ( fgets( s, sizeof( s ), stdin ) == NULL || s[0] == '\n' ) break;

        s[ strcspn( s, ""\n"") ] = '\0';

        puts( s );

        puts( remove_words( s ) );

        printf( ""\n"" );     
    }       

    return 0;
}
</code></pre>

<p>The program output might look the same way as it is shown abobe</p>

<pre><code>Input a sentence: (Enter - exit): ab aba abc abcbca dd d
ab aba abc abcbca dd d
ab abc 

Input a sentence: (Enter - exit): 
</code></pre>
",0
34971888,34971877,3,"<p>You get segmentation fault not because of printing, but because you try to make a write into memory of a <em>string literal</em>. If you make a copy into writable memory, your code would work:</p>

<pre><code>int main(void) {
   char qwe[] = ""qwe"";
   //   ^^^^^
   qwe[2] = '\0';
   printf(""%s\n"", qwe); // prints ""qw""
   return 0;
}
</code></pre>
",4
40564637,40564621,3,"<p><code>10^3</code> means <em>10 XOR 3</em>, not <em>10 to the power 3</em>. </p>

<p>To raise a number to some power, use <a href=""http://www.cplusplus.com/reference/cmath/pow/"" rel=""nofollow noreferrer""><code>pow(number, power)</code></a> from <code>math.h</code>. Although in your case this is probably overkill as <code>pow</code> is complicated enough to raise floats to float powers, but you could just multiply the number with itself.</p>
",2
40564649,40564621,1,"<p>10^3 means xor - you need <code>pow</code> function - see <a href=""https://linux.die.net/man/3/pow"" rel=""nofollow noreferrer"">https://linux.die.net/man/3/pow</a></p>
",0
45085838,45085752,4,"<p>No, C does not handle variable variables like in PHP.</p>
",0
45086087,45085752,-1,"<p>You can use <a href=""https://en.wikipedia.org/wiki/X_Macro"" rel=""nofollow noreferrer"">X macro</a> to achieve what you mentioned.</p>

<p>Just do this:</p>

<pre><code>#define LIST_OF_VARIABLES X(value1) X(value2) X(value3)


//Declaring the variables

#define X(name) int name;
LIST_OF_VARIABLES
#undef X



//Reading values into the variables

#define X(name) scanf(""%i"", &amp;name);
LIST_OF_VARIABLES
#undef X



//Printing the values

#define X(name) printf(""\n%i"", name);
LIST_OF_VARIABLES
#undef X
</code></pre>

<p><br></p>

<p>First we define a macro <code>LIST_OF_VARIABLES</code> which will be calling another macro <code>X</code>.<br>
We keep <code>LIST_OF_VARIABLES</code> the way it is as it will be used over and over again.</p>

<p>Next we define the macro <code>X</code> which was used in the body of <code>LIST_OF_VARIABLES</code>.<br>
This second macro is the one that we modify to fit our needs.</p>

<p>Each time we change the purpose of the second macro <code>X</code>, we first undefine it with <code>#undef</code> and then redefine it <code>#define</code>.
<br><br></p>

<p>The above code will be end up first as follows after expanding <code>LIST_OF_VARIABLES</code> macro:</p>

<pre><code>//Declaring the variables

#define X(name) int name;
X(value1) X(value2) X(value3)
#undef X



//Reading values into the variables

#define X(name) scanf(""%i"", &amp;name);
X(value1) X(value2) X(value3)
#undef X



//Printing the values

#define X(name) printf(""\n%i"", name);
X(value1) X(value2) X(value3)
#undef X
</code></pre>

<p><br><br>
Then after expanding the <code>X()</code> macro each time, the <a href=""https://en.wikipedia.org/wiki/C_preprocessor"" rel=""nofollow noreferrer"">C pre-processor</a> would finally give the following (which will then be used by the compiler):</p>

<pre><code>//Declaring the variables

int value1; int value2; int value3;   



//Reading values into the variables

scanf(""%i"", &amp;value1); scanf(""%i"", &amp;value2); scanf(""%i"", &amp;value3);



//Printing the values

printf(""\n%i"", value1); printf(""\n%i"", value2); printf(""\n%i"", value3);
</code></pre>

<p>which is the output you wanted.</p>
",0
45086102,45085752,-1,"<p>Variable variables are similar to pointers in your example. So you can do something like this.</p>

<pre><code>int value1;
int value2;
int value3;

void handle_value(int * var) {
    scanf(""%i"", var);
}

int main(void) {
    handle_value(&amp;value1);
    handle_value(&amp;value2);
    handle_value(&amp;value3);
}
</code></pre>
",0
36511982,36511831,2,"<p>The function <code>glade_project_get_type()</code> is compiled into a library, e.g. <code>libglade</code>. The raw source code of this library doesn't contain a definition exactly, because the source code for this function is generated from a template, which can be viewed <a href=""https://github.com/GNOME/glade/blob/47bf92b0a77e8eea9b6d4b66954f246e630f5383/gladeui/gladeui-enum-types.c.template"" rel=""nofollow"">here</a>.</p>

<p>The headers you are using only describe the functions available. Headers rarely contain actual source code in C, they generally just contain function and type definitions. The compiler uses the information in the header to know what return types and argument types the functions has or what members are in a struct or union. It is the linker's job to actually make sure the functions you are using have definitions. The linker will link your source code with the precompiled <code>libglade</code> library and connect everything up.</p>
",1
36512041,36511831,4,"<p>The code implementing <code>glade_project_get_type</code> is in the library <code>libgladeui</code>, which is compiled separately and linked with the <code>glade</code> executable.</p>

<p>The source code for <code>libgladeui</code> is shipped along with that of <code>glade</code>.  The definition of the function <code>glade_project_get_type</code> is in the file <code>glade-project.c</code>.  You won't find the string <code>glade_project_get_type</code> in that file because the actual code for the function is the result of a complicated macro expansion, coming from the following lines of <code>glade_project_get_type</code>:</p>

<pre><code>G_DEFINE_TYPE_WITH_CODE (GladeProject, glade_project, G_TYPE_OBJECT,
                         G_ADD_PRIVATE (GladeProject)
                         G_IMPLEMENT_INTERFACE (GTK_TYPE_TREE_MODEL,
                                                glade_project_model_iface_init)
                         G_IMPLEMENT_INTERFACE (GTK_TYPE_TREE_DRAG_SOURCE,
                                                glade_project_drag_source_init))
</code></pre>

<p>This macro is defined in the header files for <code>glib</code>, specifically <code>gobject/gtype.h</code>.  At some point in its expansion, I would guess that <a href=""https://gcc.gnu.org/onlinedocs/cpp/Concatenation.html"" rel=""nofollow"">token pasting</a> (the <code>##</code> preprocessor directive) will be used to take one of the tokens passed to the macro (here <code>glade_project</code>) and define a function whose name is that token concatenated with <code>_get_type</code>.</p>

<p>Here is a simple example of what is going on here:</p>

<pre><code>#define MAKE_FUNC(name, val) int my_ ## name ## _function (void) { return val; }

MAKE_FUNC(magic, 42)

int main(void) {
  printf(""%d\n"", my_magic_function());
  return 0;
}
</code></pre>

<p>Although at first glance, the program doesn't appear to include a definition of <code>my_magic_function</code>, the macro <code>MAKE_FUNC</code> actually expands to create it.  The expansion of <code>MAKE_FUNC(magic, 42)</code> is simply</p>

<pre><code>int my_magic_function(void) { return 42; }
</code></pre>
",4
44651498,44651287,2,"<p>Here is how you extract bits 16 through 22, inclusive (7 bits):</p>

<ol>
<li>Read the number from the register into <code>unsigned int reg = ...</code></li>
<li>Shift <code>reg</code> to the right by 16, so bit 16 is at the least significant position: <code>reg &gt;&gt;= 16</code></li>
<li>Mask the number with 0000000001111111<sub>2</sub>, which is 0x7F: <code>reg &amp;= 0x7F</code></li>
</ol>

<p><strong>Note:</strong> The above counts bits starting from zero (the traditional way of numbering bits).</p>
",3
42545902,42545735,1,"<p>Pointers are just numbers corresponding to a memory location. You can do math on them, but it works a bit differently than normal. It's called <a href=""http://www.tutorialspoint.com/cprogramming/c_pointer_arithmetic.htm"" rel=""nofollow noreferrer"">pointer arithmetic</a>.</p>

<p>Adding 1 to a pointer moves it forward in memory not 1 byte, but the size of whatever it's pointing at. If it's a <code>char *</code> it will move 1 byte. If it's a <code>int *</code> it will move 4 or 8 bytes depending on the size of your integers. If its a 50 byte struct, it will move forward 50 bytes.</p>

<p>So all you need to do is add 1 to your pointer.</p>

<pre><code>#include &lt;stdio.h&gt;

struct example {
    char string[50];
};

int main() {
    struct example foo; 
    struct example *bar = &amp;foo + 1;

    printf(""%p %p\n"", &amp;foo, bar);
}

$ ./test
0x7fff5897b4a0 0x7fff5897b4d2
</code></pre>

<p>...except now <code>bar</code> is pointing to unallocated memory. If you try to use it, it will be <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behavior</a>.</p>

<p>If you want to make two structs adjacent to each other in memory that you can actually use, make an array.</p>

<pre><code>#include &lt;stdio.h&gt;

struct example {
    char string[50];
};

int main() {
    struct example list[2];

    printf(""%p %p\n"", &amp;list[0], &amp;list[1]);
}

$ ./test
0x7fff5ba21470 0x7fff5ba214a2
</code></pre>

<p>Or if you're using heap memory...</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct example {
    char string[50];
};

int main() {
    struct example *list = malloc( 2 * sizeof(struct example) );

    printf(""%p %p\n"", &amp;list[0], &amp;list[1]);
}
</code></pre>
",0
42545907,42545735,2,"<blockquote>
  <p>If 'x' is 50 bytes, I would want both pointers to be 50 bytes away from each other.</p>
</blockquote>

<p>You are in luck, because C has a perfect mechanism for placing pointers exactly the size of a <code>struct</code> apart. OK, not <em>exactly exactly</em><sup>*</sup>, but close enough for most practical purposes.</p>

<p>You get this behavior by declaring an array of two items. They will be placed in memory apart by at least <code>sizeof(struct mystruct)</code>, depending on the alignment of the <code>struct</code> and its actual size:</p>

<pre><code>struct mystruct { ... }; // This is your struct definition
...
struct mystruct array[2];
struct mystruct *a = &amp;array[0];
struct mystruct *b = &amp;array[1];
</code></pre>

<p>Now pointers <code>a</code> and <code>b</code> are apart by <code>sizeof(struct mystruct)</code>.</p>

<p><sup>*</sup> <a href=""https://en.wikipedia.org/wiki/Data_structure_alignment"" rel=""nofollow noreferrer""><em>Alignment</em></a> becomes important when placing pointers exactly the size of the struct apart creates performance issues, or even impossible for the program to run on a given platform. For example, some platforms require placing pointers only at even addresses; if the first element of a <code>struct</code> is a pointer, and a <code>struct</code> has an odd size, then adding an extra byte at the end is required to make it possible for the program to run.</p>
",0
42545942,42545735,1,"<p>I'm not sure how to place a pointer at a certain address, but I think there's some way to make sure two things are aligned, or a certain amount of bytes apart. </p>

<p>In K&amp;R 2e, on the top of page 186: </p>

<p><a href=""https://i.stack.imgur.com/8979A.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/8979A.png"" alt=""screenshot""></a></p>

<p>So I guess you can wrap your struct in a <em>union</em>, and <em>typedef</em> Align as some type with size of <em>n</em>, where <em>n</em> is the number of bytes you want them to be apart from each other. </p>
",2
36294063,36293809,0,"<pre><code>I want to know if fprintf() uses errno to indicate its error?
</code></pre>
<p>No it does not use <code>errno</code> to indicate an error.</p>
<p>It does use it's return value to indicate what happened and you can find out what that errno means. If you're on Linux have a look at <code>explain_fprintf</code></p>
<p><a href=""http://linux.die.net/man/3/explain_fprintf"" rel=""nofollow noreferrer"">http://linux.die.net/man/3/explain_fprintf</a></p>
<blockquote>
<p>The explain_fprintf function is used to obtain an explanation of an error returned by the fprintf(3) system call. The least the message
will contain is the value of strerror(errno), but usually it will do
much better, and indicate the underlying cause in more detail.</p>
</blockquote>
",4
36293978,36293809,1,"<p>Setting <code>errno</code> by <code>fprintf()</code> is <em>not</em> specified by the C standard.</p>
<p>Some compilers do create code that sets <code>errno</code> to the value of <code>ERANGE</code> to indicate out of range (overflow) or to other values.  Recall the C standard only specifies a few: <code>EDOM</code>, <code>EILSEQ</code>, <code>ERANGE</code>.</p>
<p>Concerning the return value of <code>fprintf()</code>:</p>
<blockquote>
<p>The <code>fprintf</code> function returns the number of characters transmitted, or a negative value if an output or encoding error occurred. C11 ¡ì7.21.6.1 14</p>
</blockquote>
<pre><code>if (fprintf(ostream, ...) &lt; 0) {
  Handle_Error();
}
</code></pre>
",0
40980181,40980048,2,"<p>In C you do not have flexibility to add a number to a string. If you want to append a number to a string then first you have to convert it into a string using <a href=""http://www.cplusplus.com/reference/cstdlib/itoa/"" rel=""nofollow noreferrer""><code>itoa</code></a> function. You can find online documentation about that function.</p>

<p>And here is general outline how would you add a number to string in C</p>

<ul>
<li>First convert the number into string (store it in a new buffer of type <code>char[]</code>) using <code>itoa</code> or <a href=""http://www.cplusplus.com/reference/cstdio/sprintf/"" rel=""nofollow noreferrer""><code>sprintf</code></a></li>
<li>Then make a new buffer of type <code>char[]</code>. Make sure you create it of enough size so that it can hold complete file path.</li>
<li>Then use <a href=""http://en.cppreference.com/w/cpp/string/byte/strcat"" rel=""nofollow noreferrer""><code>strcat</code></a> to append the two strings.</li>
</ul>

<p>Instead of all the above process, you can also use <code>sprintf</code>.</p>

<ul>
<li>Then you can pass the result to <a href=""http://www.cplusplus.com/reference/cstdio/fopen/"" rel=""nofollow noreferrer""><code>fopen</code></a></li>
</ul>
",1
40980184,40980048,1,"<p><code>C</code> doesn't have strings with the idea of concatenation. So if you want to concatenate strings you have to use functions like this:</p>

<pre><code>function editFile(char* number)
{
    char pathName[MAX_PATH];
    strcpy(pathName, ""/data/"");
    strcat(pathName, number);
    strcat(pathName, "".txt"");
    fp=fopen(pathName, ""wr"");

    ...
    // do some other things
}
</code></pre>

<p>You can utilize <code>sprintf</code> to make it shorter. But you should add security checks because you have the risk of buffer overrun. Hint: <code>strcpy_s</code>, <code>strccat_s</code>, <code>sprintf_s</code>. (But this' beyond the answer to your question.)</p>
",0
40980188,40980048,1,"<p>In C you cannot build a string in that way. Use <code>sprintf</code> to create the file name in a local variable.</p>

<pre><code>char filename[1024];
sprintf(filename, ""/data/%d.txt"", number); // assume that a signed value comes from `int`
fp = fopen(filename, ""w+"");                // replaced ""wr""
</code></pre>
",0
40980191,40980048,1,"<p>You are probably used to high level languages where you can ""build"" a string by concatenating integers, floats, other strings, etc. to it.  This doesn't work in C.</p>

<p>As commented @WeatherVane pointed out, the <a href=""http://www.cplusplus.com/reference/cstdio/sprintf/"" rel=""nofollow noreferrer""><code>sprintf</code></a> function is the right tool for the job:</p>

<pre><code>char buffer[PATH_MAX]; // assuming POSIX
sprintf(buffer, ""/data/%d.txt"", number);
fp = fopen(buffer, ""wr"");
</code></pre>
",0
40757430,40757370,1,"<p>In the code given, function is recursive. Count(n-1) calls the function again and again until the condition if(n>1) fails. So if you are passing 5 to the count function. It prints 5 times.</p>
",0
40757670,40757370,1,"<p>For count(n) your code will print something like this:</p>

<pre>
n,n-1,n-2....1 Integer value is 1<br>
Integer value is 2<br>
Integer value is 3<br>
....<br>
....<br>
Integer value is n<br>
</pre>

<p>Now let's look at the reason, find the recursive call for count(3) for illustration: <br></p>

<p>count(3)--print(3)<br>
&emsp;&emsp;&emsp;&emsp; (3>1) is true---count(2)--print(2)<br>
   &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;(2>1) is true---count(1)--print(1)<br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;(1>1) is false exec prev func call <br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;print(Integer value is 2) 
                                      return 2<br>
            &emsp;&emsp;&emsp;&emsp; print(Integer value is 3)<br>
           &emsp;&emsp;&emsp;&emsp; return 3 <br> 
In the recursion tree see where the code is printing the values.</p>

<pre>
Input: count(3)<br>
Output: <br>
321Integer value is 1<br>
Integer value is 2<br>
Integer value is 3<br></pre>
",0
40757699,40757370,0,"<p>It prints out 6 times. This is, because the program is told so. Let's insert the function call into the main code:</p>

<pre><code>int count(3) // call with 3
{
  print(""%d"" , 3);                      // prints 3
  if(3&gt;1)
  {
    count(3-1);
  }
  print(""Integer value is %d\n"" , n);   // prints 3
  return n;
}
</code></pre>

<p>Again, insert the call:</p>

<pre><code>int count(3) // call with 3
{
  print(""%d"" , 3);                          // prints 3
  if(3&gt;1)
  {
    // count(3-1)
    {
      print(""%d"" , 2);                      // prints 2
      if(2&gt;1)
      {
        count(2-1);
      }
      print(""Integer value is %d\n"" , 2);   // prints 2
      return 2;
    }
  }
  print(""Integer value is %d\n"" , 3);       // prints 3
  return 3;
}
</code></pre>

<p>Again:</p>

<pre><code>int count(3) // call with 3
{
  print(""%d"" , 3);                          // prints 3
  if(3&gt;1)
  {
    // count(3-1)
    {
      print(""%d"" , 2);                      // prints 2
      if(2&gt;1)
      {
        // count(2-1);
        {
          print(""%d"" , 1);                      // prints 1
          if(1&gt;1)                            // is false, no recursion any more
          {
            // count(1-1);
          }
          print(""Integer value is %d\n"" , 1);   // prints 1
          return 1;
        }
      }
      print(""Integer value is %d\n"" , 2);   // prints 2
      return 2;
    }
  }
  print(""Integer value is %d\n"" , 3);       // prints 3
  return 3;
}
</code></pre>
",1
47469372,34375757,1,"<blockquote>
  <p>I know whenever I call the structure member, actually I am actually
  passing a memory address for example logger->Name will have a memory
  address. Same with logger->qty.</p>
</blockquote>

<p>Your problem comes from a misconception here. It's not <em>whenever</em>, but (from ISO/IEC 9899:201x):</p>

<blockquote>
  <p>Except when it is the operand of the <code>sizeof</code> operator, the <code>_Alignof</code>
  operator, or the unary <code>&amp;</code> operator, or is a string literal used to
  initialize an array, an expression that has type ¡®¡®array of <em>type</em>¡¯¡¯
  is converted to an expression with type ¡®¡®pointer to <em>type</em>¡¯¡¯ that
  points to the initial element of the array object and is not an
  lvalue.</p>
</blockquote>

<p>So, what you believed to know applies to arrays, but not to <em>an lvalue that does not have array type</em>, particularly not to <code>logger-&gt;qty</code> and <code>Logger-&gt;Name[6]</code>, which are <em>converted to the
value stored in the designated object</em>.</p>

<blockquote>
  <p>I am only interested in comparing the last 4 digits '7','8','9','0' of
  the Base_PN individually. partNum_t
  Base_PN={'1','2','3','4','5','-','7','8','9','0'}; How can I achieve
  this.</p>
</blockquote>

<p>You can use</p>

<pre><code>UINT8 *Get_PN6(void) { return &amp;Logger-&gt;Name[6]; }
</code></pre>

<p>or</p>

<pre><code>UINT8 *Get_PN6(void) { return Logger-&gt;Name+6; }
</code></pre>

<p>(which are equivalent), or, as suggested by Dmitri, stay with <code>RawValue_PN = Get_PN()</code> and</p>

<pre><code>    memcmp(RawValue_PN+6, Base_PN+6, 4)
</code></pre>

<blockquote>
  <p>That would work but I need individual access to each byte so I can
  compare each one and and then display individual character.</p>
</blockquote>

<p>You do already have <em>individual access to each byte</em> through <code>RawValue_PN[6]</code>, <code>RawValue_PN[7]</code>, <code>Base_PN[6]</code>, etc.</p>

<blockquote>
  <p>I got rid of the Warning about comparison between pointer and integer
  by using typecasting</p>
</blockquote>

<p>This way is wrong. By converting an <code>UINT8</code> to an <code>UINT8 *</code>, you are reinterpreting a character value (e. g. '7') as a memory address, which is most probably fatal for your program and certainly not what you want. </p>
",0
37769704,37769673,0,"<p>Call a process <code>myProcess</code> that returns no type and takes an <code>int</code> as a parameter. Then...</p>

<pre><code>void myProcess(int x) 
{ 
if (x &gt; 5) return;
if (x != 0)
    myProcess(x - 1);
return;
};

int main()
{
int myvar = 5;
myProcess(myvar);
return 0;
}
</code></pre>

<p>It's done recursively.</p>
",0
37769715,37769673,2,"<p>You need to use recursion.</p>

<p>For example:</p>

<pre><code>void create_processes(int n) {
  if(n == 0) return;
  if(fork() == 0) {
    int status;

    // You're in the child process. Calling it recursively will have the
    // child's PID as parent
    create_processes(n - 1);

    // Do work you need done before the child terminates
    wait(&amp;status);
    // Do work you need done after the child terminates
  } 
}
</code></pre>

<p>Then call it like</p>

<pre><code>create_processes(5);
</code></pre>
",2
36252092,26064236,0,"<p><strong>Simple Use of Do-While Loop.</strong></p>

<p>Choice is the variable in which user's choice will be stored, whether he wants to print the statement again or not.</p>

<pre><code>int choice;
do{
   printf(""\nHello World!"");  //This is the task of the program (Replace it with your task)
   printf(""\nDo You Want to Print it again ? 1 Yes/0 No: "");
   scanf(""%d"",&amp;choice);
}while(choice==1); //Loop will exit when choice gets value other than 1
</code></pre>
",0
42521588,42521547,3,"<p><code>newAccs</code> is an <em>array</em> of those structures, which will decay to a pointer to the first element when passing it to a function.</p>

<p>So, if you want to use a pointer, you'll need your function to accept <code>account *</code>. If you want a <em>single</em> account element, you'll need to pass one, such as with <code>newAccs[4]</code>.</p>

<p>Which one you choose will depend on your intent (it's a little difficult to discern <em>which</em> way you want to go based on your current <code>isValid</code> function at the moment since it doesn't use any array indexing despite the presence of a <code>for</code> loop).</p>

<hr>

<p>By way of example, here's a function (which I <em>think</em> is probably what you're after, based on the information provided) that goes through the entire set of accounts and check if the username exists in one of the entries. It will either return the index of that entry or -1 if not found:</p>

<pre><code>int findUN (char *userName, account *accountList, int accountSz) {
    int idx;
    for (idx = 0; idx &lt; accountSz; idx++)
        if (strcmp (userName, accountList[idx].unList) == 0)
            return idx;
    return -1;
}
</code></pre>

<p>Then you call it with something like:</p>

<pre><code>int idx = findUN (inputUN, newAccs, sizeof(newAccs) / sizeof(*newAccs));
</code></pre>

<p>You'll notice I've done <em>two</em> things differently there. The first is to accept a <em>pointer</em> to an account structure (the pointer to the first of the ten in the array).</p>

<p>The second is to pass the size of that array, basically the size in bytes of the entire array divided by the size in bytes of one element in that array.</p>

<p>That's because the decay of the array into a pointer does not let you later extract the array size. To do that, you need to pass it separately.</p>
",6
42521629,42521547,0,"<p>The method <code>isValid</code> expects as single instance of <code>accounts</code> as second parameter but you are passing an array to it while calling the method.</p>

<p>So either you need to change the method signature to </p>

<pre><code>int isValid(char inputUN[], struct accounts *);
</code></pre>

<p>or pass a single instance of <code>accounts</code> from the array while calling the method as</p>

<pre><code>isValid(inputUN, newAccs[someindex]);
</code></pre>
",1
43734316,43733616,1,"<p>There are only two ways to display something while waiting for input:</p>

<ul>
<li>use non blocking IO and poll for user input while constantly updating the displayed time. That will be easy with a GUI library or through non portable system calls - sadly non longer standard portable C</li>
<li>use 2 threads, one for updating the display, the other for user input. It is almost portable since C11, except that the support for C threads is optional. And it will lead to a much more complex program</li>
</ul>

<p>TL/DR: Even if it looks simple (and was indeed possible with basic language in the 80' on any <em>personnal</em> computer), non blocking terminal IO is far from simple in C language because of the assumption that the terminal is just a special case of IO.</p>
",1
43733788,43733616,0,"<p>Your problem is simple: you can't wait for an user input and do something else meanwhile, unless you use threads. May be what you could do is to wait for an input for a certain amount of time, print time and loop.<br>
 Otherwise, just know that using thread is not really complicated, but it will increase significantly the complexity of your program which purpose seemed to remain simple.</p>
",0
43734228,43733616,0,"<p>What you want is ""non-blocking I/O"".</p>

<p><a href=""https://stackoverflow.com/questions/717572/how-do-you-do-non-blocking-console-i-o-on-linux-in-c"">How do you do non-blocking console I/O on Linux in C?</a></p>

<p>There is an answer in the above linked question that has a code snippet. The accepted answer also states that:</p>

<blockquote>
  <p>you pretty much don't do non-blocking I/O</p>
</blockquote>

<p>and if you have to, you will</p>

<blockquote>
  <p>simplify this another way, by putting the console I/O into a thread or lightweight process.</p>
</blockquote>

<p>The code snipped is hideously complicated and in my experience not guaranteed to work.</p>
",1
35199314,35198095,3,"<p>There are two potential answers to your question, depending on if your file has known line lengths or not.</p>

<hr>

<blockquote>
  <p>is there a way to read from a specific line number to EOF</p>
</blockquote>

<p>In a file with <strong>line lengths are completely arbitrary</strong> (variable), no.</p>

<p>For example, if line 1 is 10 characters, and line 2 is 20 characters, then there is no way to calculate where line 3 is going to start without iterating through lines 1 and 2.</p>

<p>Operating systems aren't magic; if this kind of functionality was supported, they'd have to iterate through the file first as well. Either way, you're going to be looping through the contents.</p>

<hr>

<p>Now, if the <strong>line lengths are guaranteed to be the same</strong>, that's a different story.</p>

<p>Say you have a text file like so:</p>

<pre><code>AAAAAAA
BBBBBBB
CCCCCCC
</code></pre>

<p>Each line in the above text file is 7 characters. Assuming your line terminator is <code>\n</code>, each line takes up exactly 8 bytes.</p>

<p>In this case, you can safely <code>fread()</code> 8 bytes at a time and know that you're getting exactly one line. In order to jump to a particular <em>byte</em> in a file, you would use <code>fseek()</code>.</p>

<p>Since you know the length of the lines in this scenario, you could jump to line <code>N</code> by simply doing</p>

<pre><code>fseek(fp1, S * N, SEEK_SET);
</code></pre>

<p>where <code>N</code> is the line number (starting at 0) and <code>S</code> is the length of the line (as mentioned above, 8 bytes in our example file).</p>

<hr>

<p>Note that the second solution will break if you're using a multi-byte encoding such as Unicode. Keep that in mind.</p>
",0
35198986,35198095,0,"<p>Using <strong>fgets()</strong> i made program, try it.  </p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

int main()
{
        FILE *fp1, *fp2;
        char ch,*str,*r;
        int i =0;
        int n = 0;
        int l;

        fp1 = fopen(""co.data"", ""r"");
        fp2 = fopen(""Output.txt"", ""w+"");
        printf(""please enter how many lines do not need to be copied\n"");
        scanf (""%d"", &amp;l);
        while (1)
        {
                if(r=fgets(str, 500, fp1))
                {                      /*  a loop to read/copy    the file*/
                        i++;
                }
                if (r == NULL)
                        break;
                else if (i &gt; l)
                        fputs(str, fp2);

        }
        printf(""File copied Successfully!\n"");
        printf(""number of lines read is %d\n"",i-1);
        printf(""number of lines copied is %d\n"",i-1-l);
        fclose(fp1);
        fclose(fp2);
}
</code></pre>
",6
37151961,37151762,1,"<p>It appears that  the issue might be in the line <code>#include &lt;omp.h&gt;</code>. Some  libraries may require you to include their header files in a certain order, or else they can result in <a href=""https://stackoverflow.com/questions/36569538/compilation-error-whith-boost-python-and-lapack"">errors like this</a>. My suggestion is to try placing that #include at the top of the file. However, it does not appear that it is being used, so I would leave it out until you determine that you need it.</p>

<p>In addition, even if you remove that #include, you will  need to make sure to <code>#include &lt;time.h&gt;</code> and <code>#include &lt;stdlib.h&gt;</code>, or else your calls to <code>time()</code> and <code>rand()</code> will result in compilation errors.</p>
",3
37832509,37832235,1,"<p>As you include conio.h, the solution is already tied to a Windows (or MS/DOS) platform.</p>

<p>Here as i assume you do not really need a command line program, the best way would be build a Windows GUI program having an event loop and directly processing the <code>WM_KEYDOWN</code> and <code>WM_KEYUP</code> messages to be alerted as soon as a key is pressed on released on the keyboard. To avoid any risk of loosing one change in the state of the key, you could even consistently use the <code>GetKeyboardState</code> API function to load the current state of all keys on the keyboard.</p>

<p>I know this is more a hint that a precise answer, but a detailed answer would be much too long for a SO post.</p>
",0
37833343,37832235,1,"<p>This shows how to use the Windows <code>GetAsyncKeyState</code> function. It does not need to be in a GUI - this console app works as shown. It will be up to you to examine the bit status flags <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/ms646293(v=vs.85).aspx"" rel=""nofollow"">as documented</a> to determine action. For example, auto-repeat is honoured when a key is pressed. You probably won't need to check every key either.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;

int main(void)
{
    unsigned short buff[256] = {0};
    unsigned short kval;
    int i;
    while (1) {
        for(i=0; i&lt;256; i++) {
            kval = GetAsyncKeyState(i);
            if(kval != buff[i]) {
                printf(""%02X:%04X "", i, kval);
                buff[i] = kval;
            }
        }
    }
    return 0;
}
</code></pre>

<p>In this test, the first line was output before I pressed any key. The second line was output when I pressed and released <code>'A'</code>.</p>

<pre><code>0D:0001 26:0001 45:0001 53:0001 54:0001 0D:0000 26:0000 45:0000 53:0000 54:0000
41:8001 41:8000 41:0000
</code></pre>

<p>Note: linked with <code>user32.lib</code>.</p>
",0
42617053,42617028,1,"<ol>
<li><blockquote>
  <p>Normally we declare a function prototype in header file like:</p>

<pre><code>void function();
</code></pre>
  
  <p>Can this function take any argument?</p>
</blockquote>

<p>It is unspecified what arguments this function will take.</p></li>
<li><blockquote>
  <p>If the function takes integer as argument, we write:</p>
  
  <p>void function(int);</p>
  
  <p>But sometimes I see people write: void function(int*);</p>
  
  <p>What is the <code>*</code> doing here?</p>
</blockquote>

<p>This is a <a href=""https://www.tutorialspoint.com/cprogramming/c_pointers.htm"" rel=""nofollow noreferrer"">pointer</a> to an <code>int</code>.</p></li>
<li><blockquote>
  <p>If the function can take several types of argument, like integer and double, what should we do?</p>
</blockquote>

<p><code>int</code> and <code>double</code> are incompatible types. You can't take one function that takes either one, or the other. You can't define two different functions with two different types, but that share the same name, either.</p></li>
</ol>
",10
42617208,42617028,1,"<ol>
<li><p>The question itself is worded incorrectly. This is not a prototype at all. This is a <em>non-prototype</em> function declaration. </p>

<p>It does not say anything about function arguments, which is exactly what makes it different from prototype. The function declared in this way can be called with any set of arguments.</p>

<p>However, if the arguments used in the call (after usual arithmetic conversions) do not match the parameters used the actual definition (in number and type), the behavior is undefined. If the actual function is defined as variadic (has <code>...</code> in the parameter list), the behavior is undefined.</p></li>
<li><p>These are prototypes. The first one says that the function has a single <code>int</code> parameter. The second one says that it has a single <code>int *</code> parameter (a pointer to <code>int</code>). There's nothing special about it if you know what pointers are.</p></li>
<li><p>It is not clear what is being asked. ""What should we do?"" I don't know... Fly to Hawaii and spend five days dancing naked in the rain.</p>

<p>This function is declared as taking several arguments of different types</p>

<pre><code>void foo(int, double, char, short *);
</code></pre>

<p>There's nothing special about it. If you meant something else - clarify the question.</p></li>
</ol>
",0
35217183,35217124,0,"<p>C has only pass by value. If pointer to <code>node struct</code> is used as parameter then any modification to passed pointer will not be seen in the caller function. In that case you have to return a pointer from the function <code>insert</code>. Pointer to pointer is used here to update the pointer passed to function  <code>insert</code>.</p>
",0
35217192,35217124,0,"<p>When you want to change the value of a variable defined in <code>main()</code> through some function. Think what do you do. You send the address of that variable and then using that address, change the content of that variable.</p>

<p>Now, in an example cases, the variable is of <code>int</code> type, so sending the address of that variable would mean in the function, you have to receive it in a variable of type <code>int *</code></p>

<pre><code>void test(int* var) {
    *var++;
}

int main() {
    int integer = 1;
    test(&amp;integer);
    printf(""%d"", integer);
    return 0;
}
</code></pre>

<p>To change the value of the variable <code>integer</code> you send the address of that to the function <code>test()</code>. </p>

<hr>

<p>Now take this same situation, and think if you need to change the content of a variable which is itself a <code>struct node *</code>. Then you send the address of that variable, and receive it with a <code>(struct node *)*</code>. Thats what is happening in the example you posted.</p>

<p>You want the changes that is to be made to the <code>leaf</code> variable in the <code>insert()</code> fucntion to reflect in the calling function. For this to take place you send the address and change the content accordingly.</p>
",0
35217208,35217124,0,"<p>It is call by  reference . if we have to change the value of *leaf then we should have its address thats why we used two *'s when is for pointer of leaf and other to get address of *leaf.</p>
",0
35217214,35217124,0,"<p>Case 1:</p>

<p>When you are passing a address of a variable then a single pointer is enough to access the variable</p>

<p>Example:</p>

<pre><code>struct node a;

func(&amp;a); // calling
</code></pre>

<p>In the <code>func()</code> definition:</p>

<pre><code>func(struct node *a);
</code></pre>

<p>Here a points to the address of node. And we can access <code>a</code> using its address directly.</p>

<p>Case 2:</p>

<p>When you are sending the address of pointer variable:</p>

<pre><code>struct node *a;

func(&amp;a); // calling
</code></pre>

<p>Then in the function definition it should use a double pointer:</p>

<pre><code>func(struct node **a);
</code></pre>
",0
35217365,35217124,1,"<p>In <code>insert(int key, struct node **leaf)</code> you are Passing the Address pointed by <code>*leaf</code> by C version of ""Pass By Reference"". And in <code>insert(int key, struct node *leaf)</code> you are passing the Address pointed by <code>*leaf</code> by <code>Pass By Value</code> method.Note C Parameter are always Passed by Value.</p>

<p>So, In This particular Case it doesn't matter if you use <code>insert(int key, struct node **leaf)</code> or <code>insert(int key, struct node *leaf)</code> both will achieve the same outputs.The only difference in this case is that in <code>insert(int key, struct node **leaf)</code> your passing the address by C version of Pass by Reference and in <code>insert(int key, struct node *leaf)</code> your passing the address by <code>Pass By Value</code> method.</p>

<p>Example Code A,</p>

<pre><code>#include&lt;stdio.h&gt;

struct node
{
   int data;
};

void AddFive(struct node **t);

int main()
{
   struct node *n = NULL;
   n = new node;
   n-&gt;data = 5;
   printf(""%d\n"", n-&gt;data);
   AddFive(&amp;n);
   printf(""%d\n"", n-&gt;data);

   return 0;
}

void AddFive(struct node **t)
{
    (*t)-&gt;data = (*t)-&gt;data+5;
}
</code></pre>

<p>Example Code B,</p>

<pre><code>#include&lt;stdio.h&gt;

struct node
{
   int data;
};

void AddFive(struct node *t);

int main()
{
   struct node *n = NULL;
   n = new node;
   n-&gt;data = 5;
   printf(""%d\n"", n-&gt;data);
   AddFive(n);
   printf(""%d\n"", n-&gt;data);

   return 0;
}

void AddFive(struct node *t)
{
    t-&gt;data = t-&gt;data+5;
}
</code></pre>

<p>If you notice both Code A and Code B achieve the same output.</p>
",0
39597597,39597497,-1,"<p>Try:</p>

<pre><code>char *holders[MAX_STRINGS];
int k= 0;
while(spaceTk != NULL &amp;&amp; k&lt;MAX_STRINGS){
    holders[k] = malloc(strlen(spaceTk)+1);
    strcpy(holders[k], spaceTk);
    spaceTk = strtok(NULL, "" "");
    k++;
}
</code></pre>
",0
39598649,39597497,0,"<p>If all you want is to get rid of multiple spaces (and have a mutable string) you can do that in-place because the output is always smaller than or equal to the input. Example:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

char *strip_inter_space(char *s)
{
  int i, j;
  int len;

  len = (int) strlen(s);

  for (i = 0, j = 0; i &lt; len; i++) {
    if (s[i] == ' ') {
      // keep one space
      s[j] = s[i];
      j++;
      i++;
      // skip all others
      while (s[i] == ' ') {
        i++;
      }
    }
    // copy the characters we want from beyond the space
    s[j] = s[i];
    j++;
  }
  // strip trailing space if any
  if (s[j - 2] == ' ') {
    s[j - 2] = '\0';
  }
  // terminate string to get rid of the rest
  else {
    s[j] = '\0';
  }
  return s;
}

int main(int argc, char **argv)
{
  char *cp;

  if (argc &lt; 2) {
    fprintf(stderr, ""Usage: %s teststring\n"", argv[0]);
    exit(EXIT_FAILURE);
  }
  // work on copy here, just in case
  cp = malloc(strlen(argv[1]) + 1);
  if (cp == NULL) {
    fprintf(stderr, ""Malloc failed to allocate a measly %zu bytes\n"",
            strlen(argv[1]) + 1);
    exit(EXIT_FAILURE);
  }
  strcpy(cp, argv[1]);

  printf(""BEFORE: \""%s\""\n"", cp);
  cp = strip_inter_space(cp);
  printf(""AFTER:  \""%s\""\n"", cp);

  free(cp);

  exit(EXIT_SUCCESS);
}
</code></pre>

<p>You do not need to use the two integers, you could do with a single second pointer and push them around (not shown here) but you won't save much.</p>
",0
39599359,39597497,1,"<p>Your use of <code>strtok()</code> is very strange.  One would ordinarily let <em>it</em> iterate through the source string to find delimiters, but you appear to be doing that manually, and only then calling <code>strtok()</code>.</p>

<p>Additionally, if you have <code>strdup()</code> then it is much more convenient than <code>strlen()</code> + <code>malloc()</code> + <code>strcpy()</code>, with identical result (including the same obligation to free the allocated storage when you no longer need it).  If you do not have <code>strdup()</code>, and you need to make dynamically-allocated copies of strings, then you should consider <em>writing</em> it.</p>

<p>Furthermore, using <code>strcat()</code> to copy between objects that overlap -- as you are doing -- produces undefined behavior.  Avoid that at all costs.  Since you're already creating a working copy of the original string, one way to avoid copying between overlapping objects would be to concatenate the pieces into the original string, instead of concatenating them into the working space, and then copying that back to the original string.</p>

<p>Any way around, however, you need to somehow handle each token as you receive it.  Your current code ignores all the tokens between the first and last (leaking memory all the while, too).  Here's a variation on your code that would work better:</p>

<pre><code>struct dh *temp;

temp = header-&gt;next;
while(temp != NULL){
    char *spaceString = strdup(temp-&gt;string);
    // ... need a NULL check on spaceString here, in case allocation failed
    char *first_token = strtok(spaceString, "" "");
    char *next_token = strtok(NULL, "" "");

    if (next_token) {  // else the original string is OK as-is
        strcpy(temp-&gt;string, first_token);
        do {
            strcat(temp-&gt;string, "" "");
            strcat(temp-&gt;string, next_token);
            next_token = strtok(NULL, "" "");
        } while (next_token);
    }

    // It is obligatory to free the working string now that we're done with it
    free(spaceString);
}
</code></pre>

<p>But that's still pretty inefficient (albeit better than yours), because the <code>strcat()</code> calls all have to find the end of the string by scanning it from the beginning, not to mention because of the dynamic memory allocation (which is also a potential point of failure) and the function call overhead.  It's not too hard to write code for <em>in-place</em> whitespace compression that doesn't suffer from any of those problems.  That might look something like this:</p>

<pre><code>char *start_at = strstr(header-&gt;next, ""  "");

if (start_at) {  // else nothing to do
    char *lag = start_at + 1;  // after the first space
    char *lead = lag + 1;      // after the second space
    int space_count = 2;

    do {
        if (*lead != ' ') {
            // not part of a run of spaces
            space_count = 0;
        } else if (space_count++) {
            // the second or subsequent space in a run of spaces
            continue;
        }

        *lag++ = *lead;
    } while (*lead++);
}
</code></pre>
",2
40540599,40540266,0,"<p>Hope it helps you.</p>

<pre><code>#include &lt;stdio.h&gt;
#define MAX 8

struct move {
int left;
int right;
int up;
int down;
};

int main()
{
        struct move moves[MAX]={[0 ... MAX-1].right = 1};

        printf(""...%d\n"",moves[0].left);
        printf(""...%d\n"",moves[1].right);
        printf(""...%d\n"",moves[2].right);
        printf(""...%d\n"",moves[3].right);
        printf(""...%d\n"",moves[4].right);
        printf(""...%d\n"",moves[5].right);
        printf(""...%d\n"",moves[6].right);
        printf(""...%d\n"",moves[7].right);
        return 0;
}
</code></pre>
",0
45726805,45726177,0,"<p>Try this.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

char string[5][5]={{'a','l','p','h','b'},{'c','d','e','f','g'},
    {'i','j','k','m','n'},{'o','q','r','s','t'},
    {'u','v','w','x','y'}};
char strsearch[100];
int rowindex[100];
int colindex[100];

int main(int argc, const char *argv[])
{
    printf(""\nEnter String="");
    gets(strsearch);
    int count = 0;
    for (int i = 0; i &lt; strlen(strsearch); i++) {
        for(int row = 0; row &lt; 5; row++)
        {
            for(int column = 0; column &lt; 5; column++)
            {
                if(string[row][column] == strsearch[i])
                {
                    rowindex[count] = row;
                    colindex[count++] = column;
                }
            }
        }
    }

    printf(""row"");
    char prefix = '=';
    for(int i = 0; i &lt; count; i++)
    {
        printf(""%c%d"", prefix, rowindex[i]);
        prefix = ',';
    }


    printf(""\ncolumn"");
    prefix = '=';
    for(int i = 0; i &lt; count; i++)
    {
        printf(""%c%d"", prefix, colindex[i]);
        prefix = ',';
    }
    printf(""\n"");

    return 0;
}
</code></pre>
",0
38999237,38999185,1,"<pre><code>sentence = strdup("""");
</code></pre>

<p>You're only allocating 1 <code>char</code> for <code>sentence</code>. You need to allocate enough memory to store all 3 animal names (13 = 3 times the longest animal name, goat + 1 null character). Also, use <code>calloc</code> to zero out the string.</p>

<pre><code>sentence = calloc(13, sizeof(char));  /* CORRECT */
</code></pre>

<p>Also, you're not freeing your memory when you are done:</p>

<pre><code>free(sentence);
</code></pre>

<p>By the way, you should not use <code>void main()</code> as it is not standards compliant. Use <code>int main()</code> instead.</p>
",3
38999355,38999185,2,"<p>Your program crashed because <code>sentence</code> didn't have enough memory allocated to store the string.</p>

<pre><code>void main() {

    char *str[] = {""Dog"", ""Cat"", ""Hen"", ""Goat""};
    char *sentence = NULL; //initialize the string
    int i;
    srand(time(NULL));

    for(i=0; i&lt;20; i++) {
        sentence=malloc(13); // longest string would be GoatGoatGoat + terminating null
        sentence[0]='\0';
        strcat(sentence, str[rand()%4]);
        strcat(sentence, str[rand()%4]);
        strcat(sentence, str[rand()%4]);
        printf(""%s\n"", sentence);
        free(sentence); //always free the allocated memory
    }


}
</code></pre>
",5
38511863,38511691,5,"<p>The <code>enum cmds</code> type and the enumeration members <code>A</code>, <code>B</code>, and <code>C</code>, are local to the function scope.</p>

<p>Note that while enumerations don't introduce a new scope for their member constants, they do get scoped within the <em>containing</em> scope, in this case the function body.</p>

<pre><code>int doSomething(void)
{
    enum cmds {
        A, B, C  // 0, 1, 2
    };

    return C;  // returns 2
}

int anotherThing(void)
{
    enum cmds {
        C, D, E  // 0, 1, 2
    };
    return C;  // returns 0
}
</code></pre>

<p><a href=""http://coliru.stacked-crooked.com/a/f6e3551674d42c23"" rel=""noreferrer"">Run the example code here on Coliru</a></p>
",0
38511719,38511691,1,"<blockquote>
  <p>enums don't introduce new scope.</p>
</blockquote>

<p>Refer <a href=""https://stackoverflow.com/questions/8447946/enumeration-scope"">this</a>.</p>
",8
38514548,38511691,2,"<p>Like almost any other declaration, an <code>enum</code> type defined inside a block is local to that block.</p>

<p>In your case:</p>

<pre><code>void doSomething()
{
   enum cmds {
      A, B, C
   }
}
</code></pre>

<p>the block happens to be the outermost block of the function, but it doesn't have to be:</p>

<pre><code>void doSomething(void) {
    if (condition) {
        enum cmds {A, B, C};
        // The type and constants are visible here ...
    }
    // ... but not here.
}
</code></pre>

<p>(Goto labels are the only entity in C that actually has function scope.)</p>
",0
38517134,38511691,0,"<p>As you refered in this question, The <code>enum cmd</code> you defined can <strong>only be used in this function</strong>. But if you define an enum in header, that you can use the all items of enum in any c file which including this header. </p>

<p>It is the same as the normal variable, but sometimes, The item can be used as <code>marco</code>(actually it's just an integer). That's very convenient in some cases. </p>
",0
34990083,34989907,0,"<ul>
<li><p>You can use below code.</p>

<pre><code>int main(void)
{
  int a=-23,b=23,c=-123,d=1;
  char arr[10];
  printf(""arr,%04d|%03d|%04d|%03d"",a,b,c,d);
}
</code></pre></li>
</ul>
",6
34991283,34989907,2,"<p>You can specify a precision in the printf format specifier to indicate the minimum number of digits, so if you want a minimum of 3 digits:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    int a = -23, b = 23, c = -123, d = 1, e = -2345;

    printf(""|%.3d|%.3d|%.3d|%.3d|%.3d|\n"", a, b, c, d, e);
    return 0;
}
</code></pre>

<p>Output: <code>|-023|023|-123|001|-2345|</code></p>
",0
42647847,42647813,4,"<p>Use <code>static</code>? Something along the lines of </p>

<pre><code>void myfunction() // function is called periodically every 100 ms
{
    static int once = 1;
    if (once) {
        mySubfunction(); 
        once = 0;
    }
}  
</code></pre>

<p>The variable <code>once</code> in the example will be initalized only once and retain its value between invocations because of <code>static</code> keyword.</p>

<p>Be aware of implications in multithreaded environment, see <a href=""https://stackoverflow.com/q/15857732/5899161"">this question</a>.</p>
",0
42647941,42647813,0,"<p>you can have something like </p>

<pre><code>static int flag = 1
void myfunction() // function is called periodically every 100 ms
{
    if(flag)
    {
       mySubfunction(); 
       flag = 0;
    }     
 }   
</code></pre>

<p>...</p>
",0
42649466,42647813,0,"<p>This may be more advanced than you're looking for, but you could use function pointers and change which function gets called.</p>

<pre><code>// Function declarations
void mySubfunction(void);
void myNormalfunction(void);

// Function pointer, which can be changed at run time.
static void (*myfunction)(void) = mySubfunction;

void mySubfunction(void)
{
    // Do the sub-function stuff.

    // Change the function pointer to the normal function.
    myfunction = myNormalfunction();

    // Do the normal function stuff (if necessary on the first call).
    myNormalfunction();
}

void myNormalfunction(void)
{
    // Etc.
}

int main(void)
{
    int x;
    for(x = 0; x &lt; 3; x++)
    {
        // Call myfunction as you usually would.
        myfunction();
    }
    return 0;
}
</code></pre>
",0
42648979,42647813,0,"<p>on first look task is very simply, can be next code:</p>

<pre><code>void func()
{
    static LONG first = TRUE;
    if (_InterlockedExchange(&amp;first, FALSE))
    {
        subfunc();
    }
    // some code
}
</code></pre>

<p>this give 100% guarantee that  <code>subfunc()</code> will be called once and only once even if several thread in concurrent call your <code>func()</code></p>

<p>but what be if <code>// some code</code> depended on result of <code>subfunc</code> ? in this case task become already not trivial. need some synchronization. and here already depended from os or compiler. in Windows, begin from Vista understand this problem and add function <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/ms683493(v=vs.85).aspx"" rel=""nofollow noreferrer""><code>InitOnceExecuteOnce</code></a> - read <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/ms686934(v=vs.85).aspx"" rel=""nofollow noreferrer"">Using One-Time Initialization</a>
if your <code>subfunc()</code> have no <em>in</em> and <em>out</em> parameters code can be very simply:</p>

<pre><code>BOOL CALLBACK InitOnceCallback(PINIT_ONCE /*InitOnce*/, PVOID /*Parameter*/,PVOID* /*Context*/)
{
    subfunc();
    return TRUE;
}

void func()
{
    static INIT_ONCE once = RTL_RUN_ONCE_INIT;
    if (InitOnceExecuteOnce(&amp;once, InitOnceCallback, 0, 0))
    {
        // somecode
    }
    // error init
}
</code></pre>

<p>also some modern compilers can correct handle static one time initialization. say latest versions of <code>CL</code>. with it code can be next:</p>

<pre><code>void func()
{
    static char tag = (subfunc(), 0);
    // some code
}
</code></pre>

<p>here <code>CL</code> internally call special functions (implemented in <em>CRT</em>) <code>_Init_thread_header</code>, <code>_Init_thread_footer</code> - implementation can be look in crt source code - <code>thread_safe_statics.cpp</code></p>
",0
38022571,38022133,4,"<p>One of the best ways to cement in your mind the way to handle dereferencing, is too sit down and write the same allocation routine several different ways. All allowable, but as the sound advice in the comments points out, some of the ways make more sense than others. Take your first example, you can pass the <em>address of a pointer to pointer to char</em>, but it may not be the best way to go. For example, you can write your <code>funcion</code>[sic] in the following manner,</p>

<pre><code>/* called passing address of p */
void function (char ***ptr)
{
    *ptr = malloc (2 * sizeof *ptr);

    (*ptr)[0] = malloc (5 * sizeof(char));
    (*ptr)[1] = malloc (5 * sizeof(char));

    strcpy ((*ptr)[0], ""AAAA"");
    strcpy ((*ptr)[1], ""BBBB"");
}
</code></pre>

<p>There is no need to pass anything to your function if all of your allocation and data is contained in the function. You simply need to <em>assign the return</em> from the function. For example:</p>

<pre><code>/* p simply assigning the address of ptr */
char **function2 (void)
{
    char **ptr = malloc (2 * sizeof *ptr);

    ptr[0] = malloc (5 * sizeof(char));
    ptr[1] = malloc (5 * sizeof(char));

    strcpy (ptr[0], ""AAAA"");
    strcpy (ptr[1], ""BBBB"");

    return ptr;
}
</code></pre>

<p>Since the function allocates memory for the pointers and also allocates storage for the hardcoded <code>""AAAA""</code> and <code>""BBBB""</code> values, all you need back from the function is the address for <code>ptr</code> which you can <em>assign</em> to <code>p</code>. You simply need to match the function <code>type</code> for the required return. You can then access all values from the calling function through <code>p</code>.</p>

<p>You can also look at tools available to simplify what it is you are trying to accomplish. For example <code>strdup</code> can both allocate and copy a string. You could further simplify <code>function2</code> above as:</p>

<pre><code>/* a simplified version of funciton2 */
char **function3 (void)
{
    char **ptr = malloc (2 * sizeof *ptr);

    ptr[0] = strdup (""AAAA"");
    ptr[1] = strdup (""BBBB"");

    return ptr;
}
</code></pre>

<p>Finally, whenever you allocate data, you need to preserve a pointer to the starting address for each block, so you can <code>free</code> the information when it is no longer in use. For your case above, a simple function (which isn't necessarily needed as a function) could be:</p>

<pre><code>/* always free all allocated memory */
void free_p (char **p)
{
    free (p[0]);
    free (p[1]);
    free (p);
}
</code></pre>

<p>Putting that altogether in a bit of test code, you could use all 3 to accomplish the same task:</p>

<pre><code>int main (void)
{
    char **p = NULL;

    function (&amp;p);
    printf (""%s %s\n"", p[0], p[1]);
    free_p (p);

    p = function2();
    printf (""%s %s\n"", p[0], p[1]);
    free_p (p);

    p = function3();
    printf (""%s %s\n"", p[0], p[1]);
    free_p (p);

    return 0;
}
</code></pre>

<p><strong>Example Use/Output</strong></p>

<pre><code>$ ./bin/ptrp
AAAA BBBB
AAAA BBBB
AAAA BBBB
</code></pre>

<p>Don't forget to validate your memory use with a memory error checker (such as <code>valgrind</code> for Linux). They are simple to use and available for all platforms. Example:</p>

<pre><code>$ valgrind ./bin/ptrp
==17888== Memcheck, a memory error detector
==17888== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.
==17888== Using Valgrind-3.10.1 and LibVEX; rerun with -h for copyright info
==17888== Command: ./bin/ptrp
==17888==
AAAA BBBB
AAAA BBBB
AAAA BBBB
==17888==
==17888== HEAP SUMMARY:
==17888==     in use at exit: 0 bytes in 0 blocks
==17888==   total heap usage: 9 allocs, 9 frees, 78 bytes allocated
==17888==
==17888== All heap blocks were freed -- no leaks are possible
==17888==
==17888== For counts of detected and suppressed errors, rerun with: -v
==17888== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 1 from 1)
</code></pre>

<p>Always confirm <em>All heap blocks were freed -- no leaks are possible</em> and equally important <em>ERROR SUMMARY: 0 errors from 0 contexts</em>.</p>
",2
43756991,43756437,1,"<p>You have a race condition. I imagine that the other threads that you kick off hit the <code>if</code> statement before your global variable is set. You need to protect the lock with a mutex. In pseudo code this would be something like</p>

<pre><code>if (dsp_id == 0) {
    get mutex lock
    if (!alreadyRun)
    {
        //code run only once
        //irq start all other dsps including dsp_id 0
        set alreadyRun to true
    }
    release mutex lock
} else {
    //code run multiple times
}
</code></pre>

<p>where <code>alreadyRun</code> is your boolean variable. You cannot, by the way, just write <code>alreadyRun = true</code> because there is no guarantee that other processors will see the change if the cache of the processor setting it has not been flushed back to main memory. Your threading library will have appropriate functions to do the mutex locking and safely set alreadyRun. For example, C11 defines atomic types and operations in <code>stdatomic.h</code> for your flag and mutex functions in <code>threads.h</code></p>
",1
43756991,43756437,1,"<p>You have a race condition. I imagine that the other threads that you kick off hit the <code>if</code> statement before your global variable is set. You need to protect the lock with a mutex. In pseudo code this would be something like</p>

<pre><code>if (dsp_id == 0) {
    get mutex lock
    if (!alreadyRun)
    {
        //code run only once
        //irq start all other dsps including dsp_id 0
        set alreadyRun to true
    }
    release mutex lock
} else {
    //code run multiple times
}
</code></pre>

<p>where <code>alreadyRun</code> is your boolean variable. You cannot, by the way, just write <code>alreadyRun = true</code> because there is no guarantee that other processors will see the change if the cache of the processor setting it has not been flushed back to main memory. Your threading library will have appropriate functions to do the mutex locking and safely set alreadyRun. For example, C11 defines atomic types and operations in <code>stdatomic.h</code> for your flag and mutex functions in <code>threads.h</code></p>
",1
34961430,34961151,4,"<p>You've to force arithmetic to be run in floating point mode.</p>

<p>This can be done by changing <code>5</code> to <code>5.0</code> or <code>9</code>  to <code>9.0</code>:</p>

<pre><code>*pcelsius = (*pfahrenheit - 32) * (5.0 / 9);
</code></pre>

<p>Although there's no need for <code>convFtoC</code> to return type being <code>float</code>; It can be <code>void</code>.</p>

<p>Also, You have a typo mistake in calling <code>convFtoC</code></p>
",0
42542882,42542648,0,"<p>One common way to expose only some functions in the public API (this is how the Motif GUI libraries do it) is to put prototypes for the publicly available functions in MyThing.h, then put the rest in MyThingI.h, which #includes MyThing.h, and your .c file includes MyThingI.h (The I is for Internal). That way, your own code can have multiple files that include the I.h file, while the public .h files delivered with your library only include the .h file.</p>

<p>All of the prototypes in the .h file should use the ""extern"" keyword.</p>
",0
42542846,42542648,2,"<p>Easy. For ""public"" function prototypes/declarations, put them in the <code>.h</code> file.</p>

<p><strong><code>func.h</code></strong></p>

<hr>

<pre><code>int func1(void);
int func2(int i);
</code></pre>

<p>For the functions you don't want exposed, just put them in the <code>.c</code> file.</p>

<p><strong><code>func.c</code></strong></p>

<hr>

<pre><code>/* Function prototypes. */
static int func3(void);

/* Function definitions. */
int func1(void) {
    func3();
    return 0;
}

int func2(int i) {
    func3();
    return (i + i);
}

static int func3(void) {
    return 42;
}
</code></pre>

<p>Next, depending on your compiler, setup an <a href=""https://gcc.gnu.org/wiki/Visibility"" rel=""nofollow noreferrer"">exported symbol whitelist</a> (ie: <code>gcc hidden attributes</code>, for example, on Linux), to limit what symbols are exported.</p>

<p>Finally, <code>strip</code> the final binary after it has been compiled (ie: <code>strip --strip-unneeded myfile.so</code>), and you're all set. Even if the user knows the API in use, your ""private"" symbols could only be directly accessed via non-portable hacks.</p>

<p>Enjoy!</p>
",0
43769532,43769437,3,"<p>Base 3</p>

<pre><code>0, 1, 2
10, 11, 12, /* 3, 4, 5 in base 10 */
20, 21, 22 /* 6, 7, 8 */
100, 101, 102 /* 9, 10, 11 */
...
</code></pre>
",3
43769589,43769437,1,"<p>If performance is not a concern, you could fit five ternary values per 8-bit char. the first ternary value is stored as <code>x</code>, the second is stored as <code>x*3</code>, the third is stored as <code>x*3*3</code>, the fourth as <code>x*3*3*3</code>... etc.</p>

<p>To get the zeroth ternary value from the <code>char</code>, which let's call <code>y</code>, you'd take <code>y % 3</code>. To get the second ternary value, take <code>(y/3) % 3</code>, <code>(y/(3*3)) % 3</code> for the third... etc.</p>

<p>This will result in much more divisions than if you settled for storing 4 ternary values per char, but you can squeeze in an extra value through this method.</p>
",0
43769594,43769437,1,"<p>(Almost) the best you can do without compressing is to pack 5 ternary values (trits) in one byte. Enumerate every possible combination of five consecutive trits: </p>

<pre><code>FFFFF (0)
FFFFI (1)
FFFFV (2)
FFFIF (4) 
...
VVVVV (242)
</code></pre>

<p>There are 243 such combinations, therefore, an 8-bit byte (2**8=256) is sufficient to store any of them. Likewise, you can store 10 trits in 2 bytes, 15 trits in 3 bytes, etc.</p>
",2
43769532,43769437,3,"<p>Base 3</p>

<pre><code>0, 1, 2
10, 11, 12, /* 3, 4, 5 in base 10 */
20, 21, 22 /* 6, 7, 8 */
100, 101, 102 /* 9, 10, 11 */
...
</code></pre>
",3
43769589,43769437,1,"<p>If performance is not a concern, you could fit five ternary values per 8-bit char. the first ternary value is stored as <code>x</code>, the second is stored as <code>x*3</code>, the third is stored as <code>x*3*3</code>, the fourth as <code>x*3*3*3</code>... etc.</p>

<p>To get the zeroth ternary value from the <code>char</code>, which let's call <code>y</code>, you'd take <code>y % 3</code>. To get the second ternary value, take <code>(y/3) % 3</code>, <code>(y/(3*3)) % 3</code> for the third... etc.</p>

<p>This will result in much more divisions than if you settled for storing 4 ternary values per char, but you can squeeze in an extra value through this method.</p>
",0
43769594,43769437,1,"<p>(Almost) the best you can do without compressing is to pack 5 ternary values (trits) in one byte. Enumerate every possible combination of five consecutive trits: </p>

<pre><code>FFFFF (0)
FFFFI (1)
FFFFV (2)
FFFIF (4) 
...
VVVVV (242)
</code></pre>

<p>There are 243 such combinations, therefore, an 8-bit byte (2**8=256) is sufficient to store any of them. Likewise, you can store 10 trits in 2 bytes, 15 trits in 3 bytes, etc.</p>
",2
35193671,35193344,2,"<p>When you write code like
<code>struct { ... } Foo;</code>, it's not declaring a <em>type</em> named <code>Foo</code> but a <em>variable</em>.  Its type is an anonymous <code>struct</code> corresponding to what you put in the curly braces. If you want to declare a type, write <code>struct Foo { ... };</code>.</p>

<p>That's where your error is coming from -- <code>myStruct</code> is not a type name, so when you write <code>struct myStruct</code> in the definition of <code>myNestedStruct</code> the compiler thinks you're about to define a struct by that name. But then it encounters an <code>[</code> which shouldn't be the next token in a struct declaration ever so it tells you can't make sense of the code.</p>
",0
35193599,35193344,3,"<p>You need to declare <code>myStruct</code> first before using it as a struct type.</p>

<pre><code>struct myStruct {
    int a;
    int b;
};

static struct {
    int c;
    int d;
    struct myStruct s[10];
} myNestedStruct[100];
</code></pre>

<p>This creates a variable called <code>myNestedStruct</code> which is an array of 100 structs, each containing two <code>int</code>s and an array of 10 <code>mystruct</code>s.</p>
",0
40962131,40962034,0,"<p>One possible way: use <code>scanf()</code> function to read the input. It returns the number of items it successfully read.</p>

<p>Another way: read the input as string with <code>scanf()</code> of <code>fgets()</code> and then try <a href=""https://stackoverflow.com/q/7021725/633969"">to parse it as integer</a>.</p>
",0
40962760,40962034,1,"<p>I propose this (it doesn't handle integer overflow):</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{

    char buffer[20] = {0};    // 20 is arbitrary;
    int n; char c;

    while (fgets(buffer, sizeof buffer, stdin) != NULL) 
    {
        if (sscanf(buffer, ""%d %c"", &amp;n, &amp;c) == 1)
            break;

        else
            printf(""Input not integer. Retry: "");
    }

    printf(""Integer chosen: %d\n"", n);

    return 0;
}
</code></pre>

<p><strong>EDIT: Agreed with chux suggestions below!</strong></p>
",1
37760103,37760042,1,"<p>If you expand the macro, the line</p>

<pre><code>j = product(i++);
</code></pre>

<p>becomes</p>

<pre><code>j = i++*i++;
</code></pre>

<p>and the line</p>

<pre><code>k = product(++i);
</code></pre>

<p>becomes</p>

<pre><code>k = ++i*++i;
</code></pre>

<p>Both these lines are subject to undefined behavior. You can try to make sense of it for one run of the program but the results are not guaranteed to be same with a different compiler or even the same compiler with different compiler flags.</p>

<p>When you use a function call instead of a macro, the behavior of the code is more straight forward. The line </p>

<pre><code>j = product(i++);
</code></pre>

<p>is equivalent to:</p>

<pre><code>int temp = i;
j = product(temp);
i++;
</code></pre>

<p>The line</p>

<pre><code>k = product(++i);
</code></pre>

<p>is equivalent to:</p>

<pre><code>++i;
k = product(i);
</code></pre>

<p>Hence, there are no problems when a function is used instead of a macro.</p>
",0
37760157,37760042,0,"<p>The output you expect will require you to change the macro to a function</p>

<pre><code>#include &lt;stdio.h&gt;
int product(int a) { return a * a; }

int main() {
    int i = 3, j, k;
    j = product(i++);
    k = product(++i);
    printf(""%d %d\n"", j, k);

    return 0;
}
</code></pre>

<p><strong>Output</strong></p>

<pre><code>9 25
</code></pre>

<p>Since macro unpacks inline, the value of <code>i</code> changes in the <code>main</code> function's callframe and you get an unexpected result.</p>
",0
41213699,41212379,0,"<p>It's to do with they way the windows console is passing the CTRL+Z to the program. It's probably waiting for you to compose a line and not recognising a line until it has a non- CTRL-Z character in it. So it waits until you accidentally press space and also enter.</p>

<p>Just echo everything in a scratch program to see exactly what is going on.</p>
",0
34939730,34939422,1,"<p>If you are talking about compiler implementation: Yes, I think the C standard doesn't impose any upper bound, only minimums (like char is 8 bits or more)  and limits on relative sizes (like, long can't be shorter than int). So you can set the size to anything in your own compiler (or a backend to an existing compiler), or provide command line switches to select it at compile time.</p>

<p>If you are asking from application programmers perspective: <strong>No</strong>, I don't know of a compiler which would support this. It would have the complication, that you would also need all libraries compiled with custom integer type sizes, because if library code expects a long to be 64 bits, and you call it with 128 bit long, there'll be trouble. At machine code level, there is no C type, there's just raw bytes in registers and memory, and the machine code just has to handle them right everywhere in the application and the librararies.</p>

<p>Perhaps you should ask a question about what you actually want to achieve, there is probably a solution. Use a bigint library? Use a compiler-specific non-standard large integer type? Use a struct or an array with several integers in it (a bigint library basically does this under the hood)? Use floating point? Use ascii text numbers?</p>
",0
43928847,43928492,1,"<p>First, your line:</p>

<pre><code>scanf(""%c"", &amp;character);
</code></pre>

<p>is reading the newline character from your previous scanf when the user hits enter. This is problematic if you want to enter anything besides '\n'. I changed the line to :</p>

<pre><code>do {
    scanf(""%c"", &amp;character);
} while(character == '\n');
</code></pre>

<p>As for your segmentation fault, I only receive this error when I input a text file which isn't created. This causes fopen to return null. When you pass foef() a null pointer, you get a segmentation fault. Make sure you are entering a text file which has been created. To remove both of these problems, try this:</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#define len 20
int main (void)
{
    FILE *fp;
    char filename[len];
    char character,temp;
    int count = 0;
    printf(""Enter the file name\n"");
    scanf(""%s"",filename);
    printf(""Enter the character to be counted\n"");
    do {
        scanf(""%c"", &amp;character);
    } while(character == '\n');

    fp=fopen(filename,""r"");
    if(fp != NULL) {
        while(!feof(fp))
        {
            temp=fgetc(fp);
            if(temp==character)
                count++;
        }
        printf(""File '%s' has %d instances of letter '%c'"", filename, count, character);
        fclose(fp);
    }
    else
        printf(""File Entered Does Not Exist"");
    return 0;
}
</code></pre>
",0
38408739,38408721,1,"<p>Remove the \n from your scanf code:</p>

<pre><code>printf(""How old are you?\n"");
scanf(""%d"", &amp;age);// Used to be  scanf(""%d\n"", &amp;age);
</code></pre>
",2
38408754,38408721,1,"<pre><code>scanf(""%d\n"", &amp;age);
</code></pre>

<p>should be</p>

<pre><code>scanf(""%d"", &amp;age);
</code></pre>

<p>Note that <code>scanf(""%d\n"", &amp;age)</code> is the same as <code>scanf(""%d "", &amp;age)</code>. This requires the input to be an integer followed by some whitespace (newline for example). The scanning will stop after the next non-whitespace.  It is essentially the same as <code>scanf(""%d %s"", ...)</code> but without storing the string anywhere (I'm doing a bit of hand-waving here).</p>

<p>The manual for <code>scanf()</code> may be found here: <a href=""http://en.cppreference.com/w/c/io/fscanf"" rel=""nofollow"">http://en.cppreference.com/w/c/io/fscanf</a></p>
",1
41929114,41928369,3,"<p>A non-null pointer is treated as true in a conditional statement. Therefore,</p>

<pre><code>while(fgets(buff,255,fp))
</code></pre>

<p>is equivalent to </p>

<pre><code>while(fgets(buff,255,fp)!=NULL)
</code></pre>

<p>Also, the <code>(FILE*)fp</code> is a typecast. Since <code>fp</code> is already declared as <code>FILE *fp;</code> the cast has no effect.</p>
",0
35190457,35190357,1,"<p>If I see this correctly, the memory allocated in CreateMemoryPlayer() is only assigned to the local variable <code>tmpPlayer</code>, but you never update the argument variable <code>player</code> which is needed to pass the reference to the allocated memory back to the main() method.</p>

<p>A better pattern would be to write the two methods such that they can be used like this:</p>

<pre><code>Player ** player = CreateMemoryPlayer(sizePlayer);
DeleteMemoryPlayer(player, sizePlayer);
</code></pre>
",2
35190509,35190357,1,"<p>You should return the <code>Player</code> array, instead of passing it by pointer.</p>

<pre><code>Player **creatplayer(size_t size)
{
    Player **ret;
    size_t i;

    if ((ret = calloc(1, sizeof (Player *))) == NULL)
        return NULL;

    for (i = 0; i &lt; size; ++i)
        if ((ret[i] = calloc(1, sizeof (Player))) == NULL)
            return NULL;

    return ret;
}
void delplayer(Player **p, size_t size)
{
    size_t i;
    for (i = 0; i &lt; size; ++i)
        free(p[i]);
    free(p);
}
</code></pre>
",0
46637461,46637437,3,"<p>You haven't initialised the pointers to NULL</p>

<pre><code>char *username[SIZE] = {0};
</code></pre>

<p>And you are double freeing the first element</p>

<pre><code>for (p = 0; username[p]; p++) {
    free(username[p]);
}
// then get rid of this line.... 
// free(*username);
</code></pre>
",7
46094695,46094541,2,"<p><code>scanf</code> syntax for integer is as follows:</p>

<pre><code>int i;
scanf(""%d"", &amp;i);
</code></pre>

<p>It does not need <code>\n</code> like in <code>printf</code></p>

<p>Change your for loop into this</p>

<pre><code>for(i=0; i&lt;t; i++)
{
    scanf(""%d"", &amp;a[i]);
}
</code></pre>
",0
46095695,46094541,0,"<p>Actually when you are printing into your screen the symbol ""\n"" , it means that the outputstream takes a command to change line. This is being used only in the printing process. When you are trying to input values via scanf its actually useless and problematic thus breaking your code. So you have to write:</p>

<p><code>scanf("" %d"", &amp;a[i]);</code></p>
",0
34935237,34934864,1,"<p>The answer is not 1.  You're close,  answers 2 and 3 don't make sense. </p>

<pre><code>p = &amp;x
</code></pre>

<p>p points to the memory address of x so setting </p>

<pre><code>p = 60
</code></pre>

<p>would be setting its address to 60 which is not what you want.</p>

<pre><code>k = x;
</code></pre>

<p>Changing k will not change x because k doesn't store the memory of x, it has instead copied the value of x.</p>

<pre><code>*p = 60
</code></pre>

<p><strong>The value that p is pointing to equals 60, in this case p is pointing to the address of x</strong></p>

<p>So when ever the <strong>value</strong> at the <strong>address</strong> of x changes, *p changes or vice versa.</p>

<p><strong>The key point is *p is pointing the value at the  memory address of x, so changing *p changes x</strong></p>

<p>The answer is 4.</p>
",0
34934925,34934864,1,"<p>You can simply compile it and run it in a debugger via single step to see how it works.</p>
",3
34934997,34934864,3,"<p>Here is an explanation:</p>

<pre><code>int *p; //declares a pointer to an integer
int x;  //declares an integer called x
int k;  //declares an integer called k

//at this point all values are uninitialized and could contain anything

x = 30; //the numerical value 30 is assigned to x
k = x;  //the contents of x(30) is assigned to k
p = &amp;x; //the address of int x is stored in p

//now all values have valid and reliable values
</code></pre>

<p>Now let me explain what each line you described does:</p>

<pre><code>k = 60; //assigns value 60 to variable k

*k = 60; //attempts to dereference k which is a non pointer type (compile time error)

p = 60;  //attempts to assign the value 60 to a pointer p this is NOT what you want

*p = 60; //dereferences pointer p(which points to x) and sets the value 60 to it
</code></pre>

<p>the last line has the same effect as <code>x=60;</code> so it is the correct answer. </p>

<p><code>k=60;</code> will not affect the content of <code>x</code>, because <code>x</code> and <code>k</code> are different variables they each have their own separate memory. <code>k=x;</code> will simply copy the contents of <code>x</code> into <code>k</code>, it will not make the variables aliases of each other.</p>
",3
36463149,36462670,1,"<p>In your add function, <code>int**</code> is NOT <code>int[][]</code>
Both are extremely different datatypes, one is an array of arrays, and the other is a pointer to a pointer. You should declare it as a <code>int (*name)[size]</code>
or alternatively (this happens to be my favorite way), typecast it to a pointer and then use simple pointer arithmetic - </p>

<pre><code>int add(int *a, int *b, int *c, int rows, int columns, int rowsize){
    for(int i = 0; i &lt; rows; i++){
        for(int j = 0; j &lt; columns; j++){
            *(c + rowsize*i + j) = (*(a + rowsize*i + j))*(*(b + rowsize*i + j));
        }
    }
    return 0;
}
</code></pre>
",4
36463063,36462670,1,"<p>The confusion is in the fact that <code>int x[5]</code> is not a pointer. It can be used as a pointer, but it is actually a block of 5 <code>int</code>s. And by this logic, <code>int y[5][5]</code> is also not a double pointer. This however cannot be used as a double pointer. Simply because there is no actual pointer pointing to each row. It is just a bunch (25) of integers, of which you( and the compiler) know how big each row is. So that you know that element [0,4] are the first row [5,9] the second, etc.
This means that you have to tell the function how log the rows are. There are two ways to do this. One is to explicitly make add accept blocks of 5x5</p>

<pre><code>void add(int a[5][5],int b[5][5],int c[5][5],int row,int col){
   ...
}
</code></pre>

<p>The other is to pass it as a single pointer (eg. <code>int* a</code>), and to pass the width as another argument. </p>
",0
36463712,36462670,3,"<p>When passed, <code>a</code>, <code>b</code> and <code>c</code> decay to <code>int (*)[5]</code>, rather than <code>int **</code>.</p>

<p>So you should rewrite your function as:</p>

<pre><code>void add(int a[][5], int b[][5], int c[][5], size_t row, size_t col)
{
    size_t i, j;
    for(i = 0; i &lt; row; i++)
    {
        for(j = 0; j &lt; col; j++)
        {
            c[i][j] = a[i][j] * b[i][j];
        }
    }
}
</code></pre>
",0
37636419,37635258,1,"<pre><code>#include&lt;stdio.h&gt;
#include&lt;math.h&gt;
#include&lt;stdlib.h&gt;
 #define pi 3.14159
 typedef struct v1
{
      int x, y;
}vertex;
vertex p0;
int process_vertices(  int n, vertex *v)
{
  int i;
  for(i=0;i&lt;n;i++) scanf("" %d %d"",&amp;v[i].x,&amp;v[i].y);
  return n;
}
void swap(vertex *v1, vertex *v2)
{
    vertex temp = *v1;
    *v1 = *v2;
    *v2 = temp;
}
int orientation(vertex p, vertex q, vertex r)
{
 int val = (int)(q.y - p.y) * (r.x - q.x) - ( int)(q.x - p.x) * (r.y - q.y);
if (val == 0) return 0;
return (val &gt; 0)? 1: 2;
}
 int distSq(vertex p1, vertex p2)
{
    return (int)(p1.x - p2.x)*(p1.x - p2.x) + ( int)(p1.y - p2.y)*(p1.y     - p2.y);
}
 int compare(const void *vp1, const void *vp2)
 {
   vertex *p1 = (vertex *)vp1;
    vertex *p2 = (vertex *)vp2;


    int o = orientation(p0, *p1, *p2);
    if (o == 0)
     return (distSq(p0, *p2) &gt;= distSq(p0, *p1))? -1 : 1;

    return (o == 2)? -1: 1;
 }
vertex * Convex_Hull(vertex *v,  int *count)
{
 int n = *count, ymin = v[0].y, min = 0, i,m;vertex *stack;
for(i = 1; i &lt; n; i++)
{
    if((v[i].y &lt; ymin) || ((v[i].y == ymin) &amp;&amp; (v[i].x &lt; v[min].x)))
    {
        ymin = v[i].y;
        min = i;
    }
}
swap(&amp;v[0], &amp;v[min]);
p0 = v[0];
if(n &gt; 1)
    qsort(&amp;v[1], n - 1, sizeof(vertex), compare);
     m = 1;
for(i = 1; i &lt; n; i++)
{
    while((i &lt; n - 1) &amp;&amp; orientation(v[0], v[i], v[i + 1]) == 0)
        i++;
    v[m++] = v[i];
}
*count = n = m;
if(n &lt; 3)
    return v;
  stack = (vertex *)malloc(n * sizeof(vertex));
stack[0] = v[0];
stack[1] = v[1];
stack[2] = v[2];
m = 2;
for(i = 3; i &lt; n; i++)
{
    while(orientation(stack[m-1], stack[m], v[i]) != 2)
        m--;
    stack[++m] = v[i];
}
*count = n = ++m;
free(v);
return stack;
}

 int main()
{
 int t, n, i,count;

 vertex *v;


    scanf(""%d"", &amp;n);


    v = (vertex *)malloc( n * sizeof(vertex));
    count = process_vertices(n, v);

    v = Convex_Hull(v, &amp;count);
    for(i=0;i&lt;count;i++) printf(""%d %d\n"",v[i].x,v[i].y);

return 0;
}
</code></pre>
",1
36785298,36784988,0,"<p>Try with <a href=""http://linux.die.net/man/3/sprintf"" rel=""nofollow"">sprintf</a>. It would print to a string.</p>

<pre><code>char fName[200];
sprintf(fName, ""C:\\Users\\%s\\Desktop\\Result"", getenv(""USERNAME""));
</code></pre>
",2
37760412,37760364,0,"<p>Suppose we wish to store information about employees in an organization.
Name Grade Age</p>

<pre><code>If grade=HSK(Highly skilled)
hobby name
credit card number
If Grade=SSK(Semi skilled)
Vehicle no.
Distance from Company
</code></pre>

<p>We can use a single structure for it but then it would lead to wastage of memory coz either hobby name &amp; credit card no. or vehicle no. &amp; distance from com. is used at a time. Both of them are never used simultaneously. So, here union inside structure can be used effectively:</p>

<p>Code:</p>

<pre><code>struct info1
{
char hobby[10];
int crcardno;
};
struct info2
{
char vehno[10];
int dist;
};
union info
{
struct info1 a;
struct info2 b;
};
struct emp
{
char n[20];
char grade[4];
int age;
union info f;
};
struct emp e;
</code></pre>

<p>HOPE YOU UNDERSTAND.......</p>

<p>Source : <a href=""http://cboard.cprogramming.com/c-programming/122228-union-inside-structure.html"" rel=""nofollow"">http://cboard.cprogramming.com/c-programming/122228-union-inside-structure.html</a></p>
",0
37760649,37760364,2,"<p>In your example, i.e. </p>

<pre><code>typedef struct
{
  int k;
  union
  {
    int i;
    int j;
  }use;

}std;
</code></pre>

<p>it doesn't seem to make much sense as <code>i</code> and <code>j</code> are the same type and the names of the variables isn't that descriptive. </p>

<p>It can make sense to have the same type for union elements if that would make the code easier to write, read, understand and maintain. Example:</p>

<pre><code>...
union
{  
    int numberOfCars;
    int numberOfBicycles;
}use;
...
</code></pre>

<p>When writing code for handling <code>cars</code> you could use <code>numberOfCars</code> and when writing code for handling <code>bicycles</code> you could use <code>numberOfBicycles</code>. In this way the code would be easier to understand/maintain and the two code blocks could still share a common structure.</p>

<p>In one code block you could have:</p>

<pre><code>std carDealer;
carDealer.use.numberOfCars = 9;
</code></pre>

<p>and in another code block (other file perhaps), you could have:</p>

<pre><code>std bicyclesDealer;
bicyclesDealer.use.numberOfBicycles = 9;
</code></pre>

<p>A more typical case for unions is that the elements are of different type.</p>
",0
37631609,37631539,1,"<p>Character '\' has a special meaning in C and C++ strings.  It's used as a prefix to get special characters.  For example new line is '\n'. Which by the way you have to add to the end of all your lines.   If you want to output '\' you have to double to make it '\'.</p>

<p>The line </p>

<pre><code>printf(""|_|   \___|_|  |___/\___/|_| |_|\__,_|_| |____/ \__,_|_|_|   \__, |"");
</code></pre>

<p>Should actually be</p>

<pre><code>printf(""|_|   \\___|_|  |___/\\___/|_| |_|\\__,_|_| |____/ \\__,_|_|_|   \\__, |\n"");
</code></pre>

<p>Do the for the rest of the lines.   Also on some operating systems like Windows you have to put both newline and carriage return at the end of the string so it should be '\r\n'  at the end not just '\n'</p>
",1
37631566,37631539,4,"<p>Use <code>puts()</code> to have newline characters inserted automatically</p>

<pre><code>puts("" ____                                 _   ____        _            "");
puts(""|  _ \\ ___ _ __ ___  ___  _ __   __ _| | |  _ \\  __ _(_)_ __ _   _ "");
puts(""| |_) / _ \\ '__/ __|/ _ \\| '_ \\ / _` | | | | | |/ _` | | '__| | | |"");
puts(""|  __/  __/ |  \\__ \\ (_) | | | | (_| | | | |_| | (_| | | |  | |_| |"");
puts(""|_|   \\___|_|  |___/\\___/|_| |_|\\__,_|_| |____/ \\__,_|_|_|   \\__, |"");
puts(""                                                             |___/ "");
</code></pre>

<p>or insert newline characters manually.</p>

<pre><code>printf("" ____                                 _   ____        _            \n"");
printf(""|  _ \\ ___ _ __ ___  ___  _ __   __ _| | |  _ \\  __ _(_)_ __ _   _ \n"");
printf(""| |_) / _ \\ '__/ __|/ _ \\| '_ \\ / _` | | | | | |/ _` | | '__| | | |\n"");
printf(""|  __/  __/ |  \\__ \\ (_) | | | | (_| | | | |_| | (_| | | |  | |_| |\n"");
printf(""|_|   \\___|_|  |___/\\___/|_| |_|\\__,_|_| |____/ \\__,_|_|_|   \\__, |\n"");
printf(""                                                             |___/ \n"");
</code></pre>
",1
35258873,35258107,0,"<p>It seems like you're having trouble adding suitable logic to main() because that logic belongs in the actual iterative calculation, e.g. in your eSeries function.  @chux pushed the stop condition into eSeries(), while @Weather Vane pulled the iteration up into main(), either is fine.</p>

<p>I'll offer the following as my own take on the problem - I thought you'd find it it interesting to see the behavior of eSeries() with various ""target thresholds""...</p>

<h2>output from e.c</h2>

<pre><code>$ gcc e.c
$ ./a.out
hello from eSeries, threshold=0.100000
  i/  n :     diff : current approx of 'e'
  1/100 : 1.00000000 : 2.00000000
  2/100 : 0.50000000 : 2.50000000
  3/100 : 0.16666675 : 2.66666675
  4/100 : 0.04166675 : 2.70833349
hello from eSeries, threshold=0.010000
  i/  n :     diff : current approx of 'e'
  1/100 : 1.00000000 : 2.00000000
  2/100 : 0.50000000 : 2.50000000
  3/100 : 0.16666675 : 2.66666675
  4/100 : 0.04166675 : 2.70833349
  5/100 : 0.00833344 : 2.71666694
hello from eSeries, threshold=0.001000
  i/  n :     diff : current approx of 'e'
  1/100 : 1.00000000 : 2.00000000
  2/100 : 0.50000000 : 2.50000000
  3/100 : 0.16666675 : 2.66666675
  4/100 : 0.04166675 : 2.70833349
  5/100 : 0.00833344 : 2.71666694
  6/100 : 0.00138879 : 2.71805573
  7/100 : 0.00019836 : 2.71825409
hello from eSeries, threshold=0.000100
  i/  n :     diff : current approx of 'e'
  1/100 : 1.00000000 : 2.00000000
  2/100 : 0.50000000 : 2.50000000
  3/100 : 0.16666675 : 2.66666675
  4/100 : 0.04166675 : 2.70833349
  5/100 : 0.00833344 : 2.71666694
  6/100 : 0.00138879 : 2.71805573
  7/100 : 0.00019836 : 2.71825409
  8/100 : 0.00002480 : 2.71827888
$ 
</code></pre>

<h2>e.c source code</h2>

<pre><code>#include &lt;stdio.h&gt;

float eSeries (int n, float threshold){
   int nFact = 1;
   float e = 1.0;
   float last = e;
   int i;
   printf(""hello from eSeries, threshold=%f\n"", threshold );
   printf(""%3s/%3s : %8s : %s\n"", ""i"", ""n"", ""diff"", ""current approx of 'e'"" );
   for (i = 1; i &lt; n; i++) {
      nFact *= i;
      e = e + (1.0 / nFact);
      float diff = e - last;
      last = e;
      printf(""%3d/%3d : %8.8f : %8.8f\n"", i, n, diff, e );
      if( diff &lt; threshold ) break; // good enough, stop early
   }
   return e;
}


int main(int argc, char const *argv[]) {

   float current;
   float past;
   int count = 0;

   eSeries( 100, 0.1 );
   eSeries( 100, 0.01 );
   eSeries( 100, 0.001 );
   eSeries( 100, 0.0001 );

   //do {
      // here's where i can't get the logic right.
   //} while(current != past);

   return 0;
}
</code></pre>
",2
35258587,35258107,0,"<p>Rather than stopping when the text decimal version (to 3 places) of <code>e</code> repeats, let us do so mathematically.</p>

<p>2 ideas:</p>

<ol>
<li><p>Since the series begins <code>1.0/0! + 1.0/1! + 1.0/2! + 1.0/3! ...</code>, once the term becomes so small adding it to 1.0 makes no difference, stop.</p></li>
<li><p>Once the term become <code>delta &lt; 0.001</code>, stop.</p></li>
</ol>

<p>Difference series have different convergence concerns, but for <code>e</code>, the above work OK.</p>

<pre><code>float eSeries(void) {
  float nFact = 1;
  float e = 1.0;

  for (int i = 1; i &lt; 99; i++) {
    nFact *= i;
    double delta = 1.0 / nFact;

    e = e + delta;

    // Pick 1 of 2 methods
    if (delta + 1.0 == 1.0) break;
    if (delta &lt; 0.001) break;
  }
  return printf(""%1.9f\n"", e);
}
</code></pre>
",0
35258742,35258107,1,"<p>This is a simple way of using the <em>e = 1 + 1/1! + 1/2! + 1/3! ...</em> series to calculate <em>e</em> and test for convergence.</p>

<pre><code>#include &lt;stdio.h&gt;

#define SIGNIF 0.001
#define DIGITS 3

int main(void)
{
    double e = 1.0, term = 1.0, diff, last;
    int i = 1;
    do {
        last = e;
        term /= i;
        i++;
        e += term;
        diff = e - last;
    } while (diff &gt; SIGNIF || diff &lt; -SIGNIF);
    printf(""Term %d = %.*f\n"", i, DIGITS, e);
    return 0;
}
</code></pre>

<p>Program output</p>

<pre><code>Term 8 = 2.718
</code></pre>
",2
44349143,44349032,0,"<p>This isn't a complete answer, but if you do</p>

<pre><code>#include &lt;wchar.h&gt;
#include &lt;locale.h&gt;
</code></pre>

<p>and then</p>

<pre><code>setlocale(LC_ALL, ""en_US.UTF-8"");
</code></pre>

<p>and then call <code>getwchar()</code> or <code>getwc(fp)</code> instead of <code>getchar</code>/<code>getc</code>, and then check for the value 8217 as well as <code>'\''</code>, you might be able to get it all to work.</p>

<p>(It works for me.  YMMV.  Depending on your OS, you might have to use a locale string other than ""en_US.UTF-8"".)</p>

<p>(And if this does work, welcome to the wonderful world of <a href=""https://en.wikipedia.org/wiki/Internationalization_and_localization"" rel=""nofollow noreferrer"">internationalization</a>.  Having gone down this road, there are several other issues you'll have to pay attention to if you want your code to work properly under all circumstances and in all locales.)</p>
",1
44349143,44349032,0,"<p>This isn't a complete answer, but if you do</p>

<pre><code>#include &lt;wchar.h&gt;
#include &lt;locale.h&gt;
</code></pre>

<p>and then</p>

<pre><code>setlocale(LC_ALL, ""en_US.UTF-8"");
</code></pre>

<p>and then call <code>getwchar()</code> or <code>getwc(fp)</code> instead of <code>getchar</code>/<code>getc</code>, and then check for the value 8217 as well as <code>'\''</code>, you might be able to get it all to work.</p>

<p>(It works for me.  YMMV.  Depending on your OS, you might have to use a locale string other than ""en_US.UTF-8"".)</p>

<p>(And if this does work, welcome to the wonderful world of <a href=""https://en.wikipedia.org/wiki/Internationalization_and_localization"" rel=""nofollow noreferrer"">internationalization</a>.  Having gone down this road, there are several other issues you'll have to pay attention to if you want your code to work properly under all circumstances and in all locales.)</p>
",1
39647429,39645191,0,"<p>Weather Vane suggest using <code>fread</code>.<br>
and I suggest using <code>argv[1]</code> as file name.<br>
Something like the following</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;

int main(int argc, char *argv[]) {
    if(argc != 2){
        printf(""Usage: %s filename\n"", argv[0]);
        exit(EXIT_FAILURE);
    }

    FILE *file = fopen( argv[1] , ""rb"");
    if (file == NULL) {
        perror(""fopen"");
        exit(EXIT_FAILURE);
    }
    size_t n;
    unsigned no = 0;
    unsigned char buffer[16];

    while(n = fread(buffer, 1, 16, file)){
        printf(""%08X"", no);
        for(size_t i = 0; i &lt; n; ++i){
            if(i % 4 == 0)
                putchar(' ');
            printf("" %02X"", buffer[i]);
        }
        for(size_t i = n; i &lt; 16; ++i){
            if(i % 4 == 0)
                putchar(' ');
            printf("" %2s"", """");
        }
        fputs(""  "", stdout);
        for(size_t i = 0; i &lt; n; ++i){
            putchar(isprint(buffer[i]) ? buffer[i] : '.');
        }
        puts("""");
        no += 16;
    }
    fclose(file);
    return 0;
}
</code></pre>
",0
41402787,41402623,5,"<p>It is not doubling the value, for example if you type :</p>

<pre><code>a
b
c
Ctrl+D
</code></pre>

<p>you will see <code>6</code> cause there is a <code>line break</code> after each character like:</p>

<pre><code>a\n
b\n
c\n
Ctrl+D
</code></pre>

<p><code>\n</code> is considered as a character (if am not wrong, in mac the <code>line break</code> character is <code>\r</code>).</p>

<p>if you type :</p>

<pre><code>abc
Ctrl+D
</code></pre>

<p>you will have 4 characters because of the <code>line break</code> at the end of the <code>abc</code> sequence.</p>

<hr>

<p><strong>NOTE :</strong> as other members noticed you are using the wrong formatting character for <code>long</code> type, it must be <code>%ld</code> but you are using <code>%1d</code> (1 instead of l) i think it is a mistake when you copied the code.</p>

<hr>

<p>hope that answer you question.</p>
",1
34889256,34889220,4,"<p>You're using a logical OR, which is true if at least one parameter is true. In other words, the truth table is this:</p>

<pre class=""lang-none prettyprint-override""><code>In | In | Out
T  | T  | T
T  | F  | T
F  | T  | T
F  | F  | F
</code></pre>

<p>It sounds like you want a logical AND, which is true if both parameters are true. This way, the fight continues as long as both the player and enemy have over 0 health. The operator for logical AND in C (and many other languages) is <code>&amp;&amp;</code>.</p>

<p>In case you're interested, here's the truth table for AND:</p>

<pre class=""lang-none prettyprint-override""><code>In | In | Out
T  | T  | T
T  | F  | F
F  | T  | F
F  | F  | F
</code></pre>
",0
34889266,34889220,1,"<p>While both the grunt's hp <strong>and</strong> the player's hp (true) are above 0 you want the loop to continue so you want:</p>

<pre><code>while(grunt-&gt;hp &gt; 0 &amp;&amp; player-&gt;hp &gt; 0)
</code></pre>

<p>If either the grunt's hp <strong>or</strong> the player's hp goes below 0 the condition above will be false and you will exit the loop. </p>
",0
34891118,34889220,0,"<p>Sometimes an abstraction can make things easier to grasp. </p>

<p>Consider if you had:</p>

<pre><code>#define Alive(who) ((who)-&gt;hp &gt; 0)
</code></pre>

<p>then you could write:</p>

<pre><code>while (Alive(grunt) &amp;&amp; Alive(player)) {
    ¡­
}
</code></pre>
",0
34894952,34889220,1,"<p>If in your head you were thinking ""I want to end the game when the player's HP or the enemy's HP is below or equal to zero"", the right while condition would be:</p>

<pre><code>while(!(grunt-&gt;hp &lt;= 0 || player-&gt;hp &lt;= 0))
</code></pre>

<p>With the logical inverse operator <code>!</code></p>

<p>Recall: <code>!(A || B) == !A &amp;&amp; !B</code> so other guys answer is strictly equivalent.</p>
",0
36291424,36291352,3,"<p>A variable cannot be ""empty."" It always has a value.</p>

<p>You can manually specify a value, which indicates ""emptiness"" as done with strings: a null byte (with the value <code>0</code>) indicates the end of the string. Here, it's not emptiness per se but you get what I mean, hopefully.</p>

<p>Because a variable cannot be empty, there is no common NaN value for it; every value is a number, so NaN (not a number) does not make sense.<br>
The floating-point format IEEE 754 supports NaN values but that is only possible because certain values of floating-point numbers have been assigned that meaning.</p>
",5
36291538,36291352,0,"<p>You can't have ""nothing"" stored in variable. Every variable has value.
In most cases there will be stored ""0"", but in not-so-rare cases you will have some garbage stored in your Variable. Its something that's just left there just before your Variable got it's place in memory (the one where 'garbage' is).</p>

<p>The 'NaN' you get in some other cases, like dividing by zero, and something like that.</p>
",0
36291603,36291352,0,"<p>You always have a value to a variable. If you didn't store anything in it, It stores a random number which often called ""Garbage"", and we want to avoid it. So you can't check if a variable is empty, because it never will be.</p>
",0
36291613,36291352,2,"<p>A variable resides in RAM. RAM is never empty. Each cell has a value. Either the value is known by the programmer or not, depends whether the programmer has initialized that variable or not.</p>

<p>I know two ways of signaling the ""emptyness"" of a variable. One is to have a value that means ""empty"", like ""0"", or MAX_INTEGER, or whatever you like. This works if the logic of your algorithm imposes your variable to have only certain values, so you can know when the value is valid or not. If not, you can say the variable is not valid, or empty.</p>

<p>If your variable can hold any value (within the limits of your type), then a solution may be to use a small struct, like this:</p>

<pre><code>typedef struct
{
  int value;
  int is_empty;
} tVar;
</code></pre>

<p>So declaring variable <code>i</code> this way...</p>

<pre><code>tVar i;
</code></pre>

<p>You can initialize as empty, like this:</p>

<pre><code>i.is_empty = 1;
</code></pre>

<p>So, your program becomes:</p>

<pre><code>int main( void )
{
  tVar someVar = {0,1};  // declaring and initializing it as empty

  ...
  ...
  ...    
  if (!someVar.is_empty) // if someVar is not empty...
  {
     someVar.value = -1;
     someVar.is_empty = 0; // is not empty any more
  }
  else if (someVar.is_empty &amp;&amp; (some_other_condition))
  {
     someVar.value = 1;
     someVar.is_empty = 0;
  }

  return 0;
}
</code></pre>
",1
38288677,38288452,9,"<p>Integers can be expressed in decimal, octal, or hexadecimal form.</p>

<ul>
<li>No leading zeros indicate a decimal number(base10 => 0-9)</li>
<li>A leading 0 indicates an octal number(base8 => 0-7)</li>
<li>A leading 0x or 0X indicates a hexadecimal number.(base16 => 0-9,A/a-F/f)</li>
</ul>

<p>For example, 32 , 040 , and 0x20 are decimal, octal, and hexadecimal representations of the same value.</p>

<p>So if</p>

<pre><code>int a=028;
</code></pre>

<p>gives you :</p>

<pre><code>error: invalid digit ""8"" in octal constant
</code></pre>

<p>the reason is obvious, '8' is not a valid octal 'digit'.</p>
",1
38288468,38288452,6,"<p><code>printf()</code> will do just a normal operation. Integer constants that begin with 0 and not hexadecimal constant are octal constant as the message suggests.</p>

<p>034 = 3 * 8 + 4 = 28</p>

<p>And by the time the printf sees it at execution time,  the number is in binary, looking like this:  </p>

<pre><code>011100 (binary)
</code></pre>

<p>That is, sixteen plus eight plus four or 28 (decimal)</p>
",0
38288709,38288452,2,"<p>It isint the printf function, the concern here is of integer value, to be more precise, integer value of base 8, i.e. Octal numbers.</p>

<p>When we feed an input in integer variable like this :</p>

<pre><code>int n = 34;
</code></pre>

<p>It simply means we are putting in a Decimal number (of base 10) in variable n. But when we put an additional zero in front of digit, like:</p>

<pre><code>int n = 034;
</code></pre>

<p>The compiler interprets it as if we wish to put a value of base 8, Octal number, in variable n. Therefore, instead of putting in the plain Decimal number 34, it treats the input constant as an Octal ((3*8)+4=28) and puts the corresponding binary value for it in n.</p>

<p>On similar notes, we can also feed a hexadecimal value into a plain integer variable, like :</p>

<pre><code>int n = 0x34;
</code></pre>

<p>Here, compiler will simply put the binary equivalent of hexadecimal value 0x34 ((3*16)+4=52) in variable.
<em>Note. in ""0x"" , first character is Zero 0, not character 'o' or 'O'</em> </p>

<p>An example will sum it up :</p>

<pre><code>#include&lt;stdio.h&gt;

int main(){
    int n;

    //feeding in a Decimal Value
    n = 34;
    printf(""\n\nDecimal value with\t%%d : %d"", n);

    //feeding in an Octal Value
    n = 034;
    printf(""\n\nOctal Value with\t%%o : %o"", n);
    printf(""\nOctal Value with\t%%d : %d"", n);

    //feeding in a Hexa-decimal Value
    n = 0x34;
    printf(""\n\nHexadecimal Value with\t%%d : %d"", n);
    printf(""\nHexadecimal Value with\t%%x : %x"", n);

    return 0;       
}

/*
Output:
Decimal value with  %d : 34

Octal Value with    %o : 34
Octal Value with    %d : 28

Hexadecimal Value with  %d : 52
Hexadecimal Value with  %x : 34
*/
</code></pre>

<p>Hope this explains everything.. </p>
",0
38288620,38288452,1,"<p>The problem here is C language identify numbers written with 0 leading as octal numbers in Integer data type.So if you want to print the zero at the beginning don't use a zero at the beginning of the integer. Try this code. It gives zero at the beginning. </p>

<pre><code>#include&lt;stdio.h&gt;
int main()
{
    int a=34;
    char ds[80];
    sprintf(ds,""%03d"",a);
    puts(ds);
    return 0;
}
</code></pre>

<p>You have to use sprintf which gives formatted outputs.Here ds means Pointer to an char array.Here value of int variable is stored at char array.</p>
",1
38288720,38288452,-3,"<pre><code>int a = 34;

printf(""0%i\n"", a);
</code></pre>

<p><strong><em>Number cannot have zero in front!</em></strong> If you need to print a leading zeros like this <code>034</code> or <code>00345</code> or <code>007</code>, you need to print those zeros as characters.</p>

<pre><code>printf(""00%i"", 7);
</code></pre>

<p>When a number starts with a zero in C/C++/JavaScript and some other languages, it just means some special rarely used type of a number, called Octal.</p>
",2
38288633,38288452,14,"<p>In <code>C</code> if you start an integer with a zero (<code>0</code>) then it is treated as an octal representation of the number. In octal representation there are only 8 valid digits. They are 0, 1, 2, 3, 4, 5, 6, and 7. </p>

<p>So you can see that <code>printf</code> is working correctly here. <code>034</code> is an <code>octal</code> number, which is <code>28</code> in decimal. So <code>printf</code> is printing correct value of int variable <code>a</code> which is <code>34</code> in octal, which is equivalent to <code>28</code> in decimal.</p>

<p>However, the error - while using <code>038</code> - is not related to the <code>printf</code>. You get error when you try to use a number like <code>038</code> because, you are using an octal representation - by starting the number with <code>0</code> - but you are using an invalid digit, <code>8</code> , which simply does not exist in <code>octal</code> number system. </p>

<p><strong>P.S:</strong> If you start a number with <code>0x</code> or <code>0X</code> then that is treated as a hexadecimal representation of the number.</p>

<p><strong>P.S:</strong> If you want to print an integer in octal format, the format specifier is <code>%o</code>. For example: <code>printf(""num = %o \n"", num);</code></p>

<p><strong>P.S:</strong> If you want to print an integer in hexadecimal format, the format specifiers are <code>%x</code> or <code>%X</code>. For example: <code>printf(""num1 = %x, num2 = %X \n"", num1, num2);</code></p>
",0
38290484,38288452,2,"<p>Quoted from <a href=""http://port70.net/~nsz/c/c11/n1570.html#6.4.4.1"" rel=""nofollow"">N1570, 6.4.4.1 Integer constants</a>: (&lt;- See this link for more information.
)</p>

<pre><code>integer-constant:
                ......
                octal-constant integer-suffixopt
                ......
          ......
          octal-constant:
                0
                octal-constant octal-digit
          octal-digit: one of
                0   1   2   3   4   5   6   7
</code></pre>

<blockquote>
  <p>If I give a value as 034, the output is 28.</p>
</blockquote>

<p>Due to that leading zero, <code>034</code> is considered as an ""octal-constant"" by the compiler, and 34 in octal is 28 in decimal.</p>

<blockquote>
  <p>if it's 028, it gives an error saying ""invalid digit ""8"" in octal
  constant"".</p>
</blockquote>

<p>Again, the leading zero makes <code>028</code> an ""octal-constant. However, as you can see above, 8 is not a legal ""octal-digit"", so the compiler gives you an error.</p>
",0
44351770,44351168,2,"<blockquote>
  <p>I have two programs: one (program1) writes to a file continuously, and I want the other program (program2) to read the file continuously. </p>
</blockquote>

<p>What happens then is platform-specific. BTW, the mere ability to run several programs at once (in several <a href=""https://en.wikipedia.org/wiki/Process_(computing)"" rel=""nofollow noreferrer"">processes</a>) is provided by the <a href=""https://en.wikipedia.org/wiki/Operating_system"" rel=""nofollow noreferrer"">operating system</a> (and is <em>not</em> defined in, since outside of, the <a href=""https://en.wikipedia.org/wiki/C11_(C_standard_revision)"" rel=""nofollow noreferrer"">C11</a> standard). Read <a href=""http://pages.cs.wisc.edu/~remzi/OSTEP/"" rel=""nofollow noreferrer""><em>Operating Systems : Three Easy Pieces</em></a> (freely downloadable chapters).</p>

<p><sup>IIRC, on Windows (that I don't know and never used) that is not allowed to happen (one of the programs would be blocked or would have its file open fail).</sup></p>

<p>However, if on Linux with a native local file system (such as Ext4), you could consider using <a href=""http://man7.org/linux/man-pages/man7/inotify.7.html"" rel=""nofollow noreferrer"">inotify(7)</a> facilities (which won't work with remote file systems ¨¤ la NFS, and probably won't work on FAT filesystems like e.g. some USB key; but you need to check).</p>

<blockquote>
  <p>Basically, I want the output of program1 to be used as the input of program2. Is there any way to read and write in RAM instead of file as disk read costs more time.</p>
</blockquote>

<p><sup>(I am supposing you wrote both <em>program1</em> and <em>program2</em>, or at least have their source code and can modify it)</sup></p>

<p>BTW, application programs don't read <em>directly</em> from RAM; they work in <a href=""https://en.wikipedia.org/wiki/Virtual_memory"" rel=""nofollow noreferrer"">virtual memory</a> and each <a href=""https://en.wikipedia.org/wiki/Process_(computing)"" rel=""nofollow noreferrer"">process</a> has its own <a href=""https://en.wikipedia.org/wiki/Virtual_address_space"" rel=""nofollow noreferrer"">virtual address space</a>. See <a href=""https://unix.stackexchange.com/a/367995/50557"">this answer</a>.</p>

<p>You surely want to have some <a href=""https://en.wikipedia.org/wiki/Inter-process_communication"" rel=""nofollow noreferrer""><strong>inter-process communications</strong></a>, which are provided by your operating system.</p>

<p>On Linux there are many ways of doing that (you should <strong>read <a href=""http://advancedlinuxprogramming.com/"" rel=""nofollow noreferrer""><em>Advanced Linux Programming</em></a></strong> whose chapters are freely downloadable). I suggest considering some <a href=""http://man7.org/linux/man-pages/man7/fifo.7.html"" rel=""nofollow noreferrer"">fifo(7)</a>, or some <a href=""http://man7.org/linux/man-pages/man7/pipe.7.html"" rel=""nofollow noreferrer"">pipe(7)</a> (if both running programs can be started from a common process), or some <a href=""http://man7.org/linux/man-pages/man7/unix.7.html"" rel=""nofollow noreferrer"">unix(7)</a> sockets.
You surely need to multiplex for I/O (in both processes) e.g. by having some <a href=""https://en.wikipedia.org/wiki/Event_loop"" rel=""nofollow noreferrer"">event loop</a> around a <a href=""http://man7.org/linux/man-pages/man2/poll.2.html"" rel=""nofollow noreferrer"">poll(2)</a>.</p>

<p><a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa365574(v=vs.85).aspx"" rel=""nofollow noreferrer"">Windows also has inter-process communication</a> facilities. But I don't know them.</p>

<p><sup>(I strongly recommend to spend a few days reading, notably <a href=""http://advancedlinuxprogramming.com/"" rel=""nofollow noreferrer""><em>Advanced Linux Programming</em></a> or some other similar book, before writing a single line of code. You lack an overall picture on OSes and on Linux)</sup></p>

<p>I would recommend using a <a href=""http://man7.org/linux/man-pages/man7/pipe.7.html"" rel=""nofollow noreferrer"">pipe(7)</a>, or else some named <a href=""http://man7.org/linux/man-pages/man7/fifo.7.html"" rel=""nofollow noreferrer"">fifo(7)</a>, or else some <a href=""http://man7.org/linux/man-pages/man7/unix.7.html"" rel=""nofollow noreferrer"">unix(7)</a> socket. You could then write code portable on all <a href=""https://en.wikipedia.org/wiki/POSIX"" rel=""nofollow noreferrer"">POSIX</a> systems. I don't recommend to use a file and <a href=""http://man7.org/linux/man-pages/man7/inotify.7.html"" rel=""nofollow noreferrer"">inotify(7)</a>  (which is complex and Linux specific). See also <a href=""http://man7.org/linux/man-pages/man3/popen.3.html"" rel=""nofollow noreferrer"">popen(3)</a>.</p>

<p>You might find some framework libraries (e.g. <a href=""https://developer.gnome.org/gtk-tutorial/stable/c2023.html"" rel=""nofollow noreferrer"">Glib</a> from GTK, <a href=""http://doc.qt.io/qt-5/qtcore-index.html"" rel=""nofollow noreferrer"">QtCore</a>, <a href=""https://pocoproject.org/"" rel=""nofollow noreferrer"">POCO</a>, <a href=""http://libevent.org/"" rel=""nofollow noreferrer"">libevent</a>, <a href=""http://zeromq.org/"" rel=""nofollow noreferrer"">0mq</a>) to help you write portable code able to run on many platforms.</p>
",2
44351438,44351168,4,"<p>The most basic version of your code needs to reset the file stream status when it encounters EOF and then sleep for a while.  For example, assuming POSIX and using only the simplest (most ubiquitous) functions:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

int main(void)
{
    const char filename[] = ""gbbct1.seq"";
    FILE *fptr = fopen(filename, ""r"");
    if (fptr == 0)
    {
        fprintf(stderr, ""failed to open file '%s' for reading\b"", filename);
        exit(EXIT_FAILURE);
    }

    while (1)
    {
        int c;
        while ((c = fgetc(fptr)) != EOF)
            fputc(c, stdout);

        clearerr(fptr);
        sleep(1);
    }
    /*NOTREACHED*/
    return EXIT_FAILURE;
}
</code></pre>

<p>The <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/sleep.html"" rel=""nofollow noreferrer""><code>sleep()</code></a> function sleeps for an integral number of seconds; if you want sub-second sleeps, you can consider <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/usleep.html"" rel=""nofollow noreferrer""><code>usleep()</code></a>,
<a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/nanosleep.html"" rel=""nofollow noreferrer""><code>nanosleep()</code></a>, <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/timer_create.html"" rel=""nofollow noreferrer""><code>timer_create()</code></a> and relatives, etc.</p>

<p>I have a program I call <code>dribbler</code> (because it dribbles data to its output):</p>

<pre><code>Usage: dribbler [-hlntV][-s nap.time][-r std.dev][-f outfile][-i infile][-m message][-o openstr][-F format]
  -V           Print version information and exit
  -f outfile   Write to named file (dribbler.out)
  -h           Print this help message and exit
  -i infile    Read lines from input file
  -l           Loop back to start of input file on EOF
  -m message   Write message on each line of output
  -n           Number lines read from input file
  -o openstr   Flags passed to fopen() (a+)
  -s nap.time  Sleep for given interval between writes (1.000 second)
  -r std.dev   Randomize the time (Gaussian around nap.time with std.dev)
  -t           Write to standard output instead of file
  -F format    Printf format to use instead of %zu
</code></pre>

<p>I used:</p>

<pre><code>$ dribbler -s 3 -r 1.3 -f gbbct1.seq &amp;
[1] 81129
$
</code></pre>

<p>to write to the control file that <code>program2</code> is coded to read.  I then ran <code>program2</code> on it, and it produced the outputs as it proceeded.</p>

<p>It's hard to show the time sequence on SO.  I have another program (the story of my life) called <code>tstamp</code> which reads lines of input and prints them with a timestamp prefixed to the line:</p>

<pre><code>Usage: tstamp [-hV][-f num][-F format]
  -f num  Number of fractional digits (0, 3, 6, 9)
  -h      Print this help message and exit
  -F fmt  Time format (strftime(3)) to use
  -V      Print version information and exit
</code></pre>

<p>I tried modifying <code>program2.c</code> to set line buffered mode on my Mac (macOS Sierra 10.12.5, GCC 7.1.0), by adding the line below before the <code>while</code> loop in <code>program2.c</code>, but it was effectively ignored, somewhat to my surprise and chagrin:</p>

<pre><code>setvbuf(fptr, 0, _IOLBF, 0);
</code></pre>

<p>So, I rewrote the <code>while</code> loop as:</p>

<pre><code>    while ((c = fgetc(fptr)) != EOF)
    {
        fputc(c, stdout);
        if (c == '\n')
            fflush(stdout);
    }
</code></pre>

<p>Then I was able to run <code>dribbler</code> in the background, and <code>program2 | tstamp -f 3</code> to get output like:</p>

<pre><code>$ program2 | tstamp -f 3
2017-06-03 23:52:44.836: 0: message written to file
2017-06-03 23:52:44.836: 1: message written to file
2017-06-03 23:52:44.836: 2: message written to file
2017-06-03 23:52:44.836: 3: message written to file
[¡­more similar lines with the same time stamp¡­]
2017-06-03 23:52:44.836: 22: message written to file
2017-06-03 23:52:44.836: 23: message written to file
2017-06-03 23:52:44.836: 24: message written to file
2017-06-03 23:52:44.836: 25: message written to file
2017-06-03 23:52:50.859: 26: message written to file
2017-06-03 23:52:54.866: 27: message written to file
2017-06-03 23:52:58.880: 28: message written to file
2017-06-03 23:53:02.888: 29: message written to file
2017-06-03 23:53:05.902: 30: message written to file
2017-06-03 23:53:07.907: 31: message written to file
2017-06-03 23:53:09.913: 32: message written to file
2017-06-03 23:53:12.925: 33: message written to file
2017-06-03 23:53:14.935: 34: message written to file
2017-06-03 23:53:15.938: 35: message written to file
2017-06-03 23:53:19.954: 36: message written to file
2017-06-03 23:53:21.964: 37: message written to file
2017-06-03 23:53:23.972: 38: message written to file
^C
$ kill %1
[1]+  Terminated: 15          dribbler -s 3 -r 1.3 -f gbbct1.seq
$
</code></pre>

<p>You can see that I'd had <code>dribbler</code> running for a while when I started <code>program2</code> (it got modified and recompiled ¡ª part of my chagrin), so there was quite a lot of date to read immediately (hence the multiple lines with the timestamp <code>2017-06-03 23:52:44.836:</code>), but then it was waiting on <code>dribbler</code> to write more, and as you can see, it sometimes waited nearly 6 seconds between lines, and other times about 1 second, and various intervals in between.  The gaps are made more uniform by <code>program2</code> sleeping for a second at a time.  (Yes, I wrote these tools to help answer questions on SO ¡ª but <code>dribbler</code> and <code>tstamp</code> both pre-date this question by months.)</p>
",2
36527859,36525305,-1,"<p>The nested structure is not a pointer, so there is no need to allocate it. For the <code>AllData</code> struct use:</p>

<pre><code>AllData *all = malloc ( sizeof(*all));
</code></pre>

<p>Edit:</p>

<p>Just seen that you are using the nested one as array. Just allocate the nested structure in the same way as the other one after you allocated AllData:</p>

<pre><code>all-&gt;langdata = malloc ( sizeof(*all-&gt;langdata) * n);
</code></pre>

<p>Where n is the number of elements...
I would also change the definition from LangData lang[] to LangData *data</p>
",0
36231119,36230651,0,"<p>If you only want to print the filename without the .txt extension then you can do it without change the string.</p>

<pre><code>write(1, filename, strlen(filename) - 4);
</code></pre>
",0
36230692,36230651,5,"<p>This:</p>

<pre><code>filename[size-4] = '\0';
</code></pre>

<p>will not work, since size is not (necessarily) the length of the string.</p>

<p>Try:</p>

<pre><code>filename[strlen(filename) - 4] = '\0';
</code></pre>

<hr>

<p>Minimal example:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define SIZE 20

int main(void) {
  char filename[SIZE] = ""test.txt"";
  printf(""%s\n"", filename);
  // -4 for .txt
  filename[strlen(filename) - 4] = '\0';
  printf(""%s\n"", filename);
  return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>gsamaras@gsamaras:~$ ./a.out 
test.txt
test
</code></pre>

<p>PS - You may want to check if <em>.txt</em> really exists.</p>

<hr>

<p>Or<sup>*</sup>, by using <a href=""http://www.cplusplus.com/reference/cstring/strstr/"" rel=""nofollow"">strstr()</a>, you could do this and check if <em>.txt</em> actually exists:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main (void) {
  char str[] = ""test.txt"";
  char *pch;
  pch = strstr(str, "".txt"");
  if(pch) // if's body won't execute if .txt is absent
    *pch = '\0';
  puts(str);
  return 0;
}
</code></pre>

<p>*<sub>as @user3386109 said</sub></p>
",2
36230693,36230651,0,"<p>Trying doing </p>

<pre><code>strncopy(noExt_string, filename, strlen(filename) - 4)
</code></pre>

<p>This should copy the contents of filename in to noExt_string without the last 4 characters. </p>
",0
46934858,46933482,0,"<p>The outer loop will scan two items an int and a char. When the outer loop scans an int and a space, the inner loop will set the variables and continue scanning until an int and newline is scanned.</p>

<pre><code>char ws = ' ';
int num = 0;

while ( result = fscanf ( inFileHandle, ""%d%c"", &amp;num, &amp;ws)) {
    if ( EOF == result) {
        break;
    }
    if ( 2 == result &amp;&amp; ' ' == ws) {//scanned an int an a space
        sum = num;
        highest = num;
        lowest = num;
        while ( 2 == fscanf ( inFileHandle, ""%d%c"", &amp;num, &amp;ws)) {
            sum += num;
            if ( highest &lt; num) {
                highest = num;
            }
            if ( lowest &gt; num) {
                lowest = num;
            }
            if ( '\n' == ws) {//quit when a newline is scanned
                break;
            }
        }
        printf ( ""sum is %d\n"", sum);
        printf ( ""highest is %d\n"", highest);
        printf ( ""lowest is %d\n"", lowest);
    }
}
</code></pre>
",0
46934874,46933482,0,"<p>If you are not allowed to use arrays (including strings which are char arrays), you'll have to read the file one char at the time and build the integer values manually. To do that you need a number of state variables to keep track on the progress.</p>

<p>It could be like:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;limits.h&gt;

int main(void) {
  int max = INT_MIN;
  int min = INT_MAX;
  int current;
  int numbersOnThisLine = 0;
  int parsingNumber = 0;
  int negative;
  int number = 0;
  int firstNumber;


  FILE* f = fopen(""numbers.txt"", ""r"");
  if (!f)
  {
    printf(""file error\n"");
    return 1;
  }

  while ((current = fgetc(f)) != EOF)
  {
    switch (current)
    {

      case '-':
          negative = 1;
          break;

      case ' ':
          if (parsingNumber)
          {
            if (negative) number = -number;
            printf(""Found %d\n"", number);
            ++numbersOnThisLine;
            if (numbersOnThisLine == 1)
            {
              firstNumber = number;
            }
            if (numbersOnThisLine &gt;= 2)
            {
              if (firstNumber &gt; max) max = firstNumber;
              if (firstNumber &lt; min) min = firstNumber;
              if (number &gt; max) max = number;
              if (number &lt; min) min = number;
            }
          }
          parsingNumber = 0;
          number = 0;
          negative = 0;
          break;

      case '\n':
          if (parsingNumber)
          {
            if (negative) number = -number;
            printf(""Found %d\n"", number);
            ++numbersOnThisLine;
            if (numbersOnThisLine &gt;= 2)
            {
              if (number &gt; max) max = number;
              if (number &lt; min) min = number;
            }
          }
          numbersOnThisLine = 0;
          parsingNumber = 0;
          number = 0;
          negative = 0;
          break;

      default:
          if (current &gt; '9' || current &lt; '0')
          {
            printf(""Illegal file format\n"");
            fclose(f);
            return 1;
          }
          parsingNumber = 1;
          number = 10 * number + (current - '0');
          break;
    }
  }
  fclose(f);

  printf(""min=%d max=%d\n"", min, max);
  return 0;
}
</code></pre>

<p>With numbers.txt as:</p>

<pre><code>-12343
5 -5 -11 0
555
444 -2 343 -4 7
</code></pre>

<p>the output is:</p>

<pre><code>Found -12343
Found 5
Found -5
Found -11
Found 0
Found 555
Found 444
Found -2
Found 343
Found -4
Found 7
min=-11 max=444
</code></pre>

<p><strong>BTW</strong> The code above actually uses char arrays (aka strings) in the <code>printf</code> - if you must avoid that also, you can use <code>putc</code> for printing.</p>
",0
43180731,43180529,-2,"<blockquote>
  <p>What is the effect in term of running performance when all static function become non-static function ?</p>
</blockquote>

<p>Ans - None</p>

<p>A Static function means that function is only visible to that file only and cannot be called outside that file. i.e. it has <strong>file scope</strong>.</p>

<p>Static functions are typically used in large programs when you do not want your functions to clash with other people's functions. A static function ensures that you can define a function and use it inside your own file, and somebody else can also define the same static function name in other file.</p>

<p>If your code compiles after removing the static keyword, then you do not have two functions with the same name and it will work just like any normal function. </p>

<p>It will have no run time penalty.</p>
",1
43180809,43180529,5,"<p>Yes, your worries are correct: Declaring a function as <code>static</code> provides a good hint to the compiler, which it can turn into better optimization. The amount of speedup that you receive from <code>static</code> depends on your precise situation, though, so there's only truth in measurement (as always when it comes to performance).</p>

<p>The point about declaring a function as <code>static</code> is, that the compiler knows definitely, that it sees <em>all</em> the calling sites of a function. And if it sees, that the function is only called from one single place, it will generally always inline it, no matter how long it is. And the inlining may unlock further opportunities for optimization. This avoids the function call overhead, both in terms of size and speed. In this, <code>static</code> is actually a stronger hint than <code>inline</code>.</p>

<p>Of course, the effect on the performance depends on the frequency of calls to the <code>static</code> function. So, as I said, you need measurement to assess how much performance you gain from the <code>static</code> keyword.</p>
",2
43180841,43180529,3,"<blockquote>
  <p>What is the effect in term of running performance when all static function become non-static function ?</p>
</blockquote>

<p>The answer is ""some"", I think. The only way you can be sure what the performance issue is likely to be is to measure the performance of your program with and without static functions. The most obvious thing I can think of is that the optimiser might not be able to inline non static functions. </p>

<p>You actually don't need to make the static functions non static, the only issue will be the lack of symbolic names in the backtrace. </p>

<p>However, I think you have bigger problems. From your link to the man page:</p>

<blockquote>
  <p>Omission of the frame pointers (as implied by any of gcc(1)'s nonzero optimization levels) may cause these assumptions to be violated.</p>
</blockquote>

<p>For <code>backstrace</code> to work reliably, it looks like you will have to compile without optimisation. That will certainly have a huge impact on performance. I think I'd manage without it.</p>
",2
37299356,37299208,1,"<p>You did not provide the entire code, but I believe your problem is that you are sending the function an array of pointers, but your not initializing that array. You are probably passing an array of NULLs, and then trying to dreference them.</p>
",2
37299420,37299208,0,"<p>First of all, all pointers must be initialized properly before they can be dereferenced. So to write <code>frames_video1[i]-&gt;pkt_size</code> you must somehow initialize pointer under <code>frames_video1[i]</code> (either using <code>malloc</code> or storing address to already existing structure <code>AVFrame</code> with the right scope). </p>

<p>Secondly, after passing array to function you are losing information about it's size, so it has to be passed as argument together with an array, so e.g.:</p>

<pre><code>int decode_video(char *src_filename, AVFrame *frames_video[])
</code></pre>

<p>should be changed to:</p>

<pre><code>int decode_video(char *src_filename, AVFrame *frames_video[],
                 int frames_count)
</code></pre>

<p><code>frames_count</code> gives you information how far can you iterate other <code>frames_video</code> (e.g. index <code>i = 3</code> is already too big, <code>frames_video</code> doesn't contain such element). So in your case to those functions you pass <code>frames_count = 3</code> and iterate from <code>0</code> to <code>i &lt; 3</code>.</p>
",0
37299300,37299208,4,"<p>In your code, <code>frames_video1[]</code> has just been defined, but its values (pointers) were not explicitly initialized<sup>*</sup>.  So you cannot dereference them - do <code>frames_video1[i]-&gt;pkt_size</code>.  This results in <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow"">undefined behavior</a>.</p>

<p><sup>* they were implicitly initialized to NULL, attempting dereferencing which still causes UD.</sup></p>
",17
38191907,38191742,1,"<p>You should add error checking and casting of <code>calloc</code> values is discouraged, but the reason your code doesn't work is that you advance <code>dbTransaction</code> pointer in your loop, but never rewind it. The prints you're making are actually of elements 5-9 of the array while you fill elements 0-4.</p>

<p>See the corrected code:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

typedef struct _TransactionType
{
    char    field1[20];
    char    field2[20];
}TransactionType;

int main(int argc, char *argv[]) {
    int i;
    int numreg = 0;
    char  temp[12];
    TransactionType *dbTransaction;
    TransactionType *dbTransactionRoot;

    dbTransaction = (TransactionType*) calloc(10,sizeof(TransactionType));
    dbTransactionRoot = dbTransaction;


    for(i=0; i&lt;5;i++)
    {
        memset(temp,0,sizeof(temp));
        sprintf(temp,""%d"",i);
        strcpy(dbTransaction-&gt;field1, temp);
        dbTransaction-&gt;field1[strlen(dbTransaction-&gt;field1)] = '\0';
        strcpy(dbTransaction-&gt;field2, temp);
        dbTransaction-&gt;field2[strlen(dbTransaction-&gt;field2)] = '\0';
        numreg++;
        dbTransaction++;
    }

    printf(""reg = %d\n"", numreg);

    for (i=0; i&lt;numreg;i++)
    {
        printf(""dbTransaction-&gt;field1 = %s\n"",(dbTransactionRoot + i)-&gt;field1);
        printf(""dbTransaction-&gt;field2 = %s\n"",(dbTransactionRoot + i)-&gt;field2);

    }


    return 0;
}
</code></pre>
",2
38301084,38293393,1,"<blockquote>
  <p>Is my understanding correct?</p>
</blockquote>

<p>Both yes and no.</p>

<p>Yes, it is correct that the <code>consumer</code>will be stuck if the <code>producer</code> calls <code>put</code> and <code>put</code> gets stuck (e.g. by entering a endless loop).</p>

<p>However, you can't assume that <code>there are 2 resources left</code>. The <code>pthread_cond_signal</code>does not promise the <code>producer</code> executes before the <code>consumer</code> have read all 3 three elements. All you can know is that the <code>consumer</code> read at least one element but maybe it read 2 or even 3 before the producer executes.</p>

<blockquote>
  <p>If so, that's unfair ....</p>
</blockquote>

<p>No, it is not unfair. It is exactly what a mutex is for, i.e. making sure that only one thread has access to the shared resource.</p>

<p>Therefore it is important to make sure that a thread holding a mutex <strong>will not</strong> get stuck! That is your responsibility as a programmer.</p>

<p>Note: In your case there is nothing inside put that can cause the thread to be stuck.</p>
",0
38300915,38293393,1,"<blockquote>
  <p>Assume the producer just got stuck in put(); then the consumer cannot continue either (because the mutex is held by producer) even though there are 2 resources left.</p>
</blockquote>

<p>You must never do something that can get stuck while you hold the mutex, and your code does not.</p>
",0
42557613,42557573,3,"<p><code>fibonacci(limit);</code> does not print anything even though your code theoretically ""works"".</p>
",1
42557659,42557573,2,"<p>You don't print anything in fibonacci(int) method. </p>
",0
42560032,42557573,0,"<pre><code>fibonacci(limit);
</code></pre>

<p>This line is not printing anything, you return your answer in some result in some variable or print it simply by <code>printf(""%d"", fibonacci(limit));</code></p>
",0
42557836,42557573,3,"<p>Replace: </p>

<pre><code>printf(""The Fibonacci sequence is : \n"");

fibonacci(limit);
</code></pre>

<p>with</p>

<pre><code>printf(""The Fibonacci sequence is : %d \n"",fibonacci(limit));
</code></pre>

<p>or </p>

<pre><code>int result;
result = fibonacci(limit);
printf(""The Fibonacci sequence is : %d \n"",result);
</code></pre>
",0
41690740,41690698,9,"<p>It is the same with pointers. All variables in C are passed by value, even pointers.</p>

<p>You copy the address stored in the pointer outside the function, into its parameter.</p>

<p>But you can use that address to <em>reference</em> a variable which can be allocated anywhere. So in the following code:</p>

<pre><code>int j = 0;
incVar(&amp;j);
</code></pre>

<p><code>incVar</code> receives <em>by-copy</em> the address of <code>j</code>. But it can use that address to read or modify <code>j</code> (in)directly.</p>
",2
41690774,41690698,1,"<p>In fact the same thing as with values happens with pointers. Just make sure to understand the syntax correctly. You are <em>not</em> passing the integer <code>*i</code> by copy to <code>incVar</code>, but you are passing the pointer <code>i</code> of type <code>int*</code> by copy. No matter how often you copy the pointer to an address, it always points to the same address. So <code>i</code> in your second <code>incVar</code> example points to the integer the caller took the address of. So by derefencing the copy of the pointer (in <code>(*i)++</code>), you are acessing the integer of the caller.</p>
",0
41691664,41690698,0,"<p>Its better to see <code>int *i;</code> as a variable named <code>i</code> of type <em>pointer-to-int</em>, instead of a pointer named <code>*i</code>.</p>

<p>In your example:</p>

<pre><code> void incVar(int *i) {
      (*i)++; 
    }
</code></pre>

<p>We probably use it as such in the main function:</p>

<pre><code>int a = 5;
incVar(&amp;a); //After this line, a is now 6.
</code></pre>

<p>What happens in <code>incVar(..)</code> is this:</p>

<ol>
<li>A variable <code>i</code> is created, of type <em>pointer-to-int</em>.</li>
<li>It holds a <strong>copy</strong> of the value of <code>&amp;a</code>.</li>
<li>Although <code>i</code> is a copy, its value is the same as that of the value of <code>&amp;a</code>, and it still points to the same integer <code>a</code>.</li>
<li>As a result, by de-referencing <code>i</code>, I refer to the integer <code>a</code>.</li>
<li>Increment the integer <code>a</code>, which obviously is at the address pointed to by <code>i</code>.</li>
</ol>
",0
41688696,41688593,4,"<p>The problem is that <code>100*(totalIncome - totalDollars)</code> is not exactly 40, but <code>3.999999999941792e+01</code>, thus casting it to <code>int</code> yields 39. This is a good example why one should never use floating points for computations with currencies.</p>

<p>BTW: You can simply avoid this issue altogether using something like
<code>scanf(""%d.%d"", &amp;hourlyDollars, &amp;hourlyCents);</code></p>
",2
41689695,41688593,1,"<p>To take a floating point money to floating point cents to the nearest whole number, use <code>round()</code> or <code>rint()</code></p>

<pre><code>double x;
double cents = rint(x * 100.0);
</code></pre>

<p>To take a floating point money to nearest integer cents, use <code>lround()</code> or <code>llround()</code></p>

<pre><code>long long cents = llround(x * 100.0);
</code></pre>

<p>To break into FP dollars into whole dollars and whole cents, scale, round and then separate.</p>

<pre><code>double x;
double cents = rint(x * 100.0);
double cent =  fmod(cents, 100.0);
double dollar = (cents - cent)/100;
</code></pre>

<hr>

<p>Avoid mixing types to support money.  Use <code>long long</code> or <code>double</code>.  Each has its <a href=""https://stackoverflow.com/a/32214586/2410359"">short comings</a>.  For learner programs start with wide integer types of the smallest denomination (cents).</p>
",0
36219807,36219522,2,"<p>The main problem of your code is that you can't estimate the length of an array provided just a pointer to it. Although your main mistake is that you don't allocate space for topics array but your solution might still not work in some environments. Solution for pointer arrays is quite simple. You just make last element a <code>NULL</code> explicitly. For instance for integers you need to use some special value to indicate and of array (for example maximal or minimal int value).
Here's a code for your problem:</p>

<pre><code>char **get_topics() {
    struct Topic *aux, *trav;
    char **topics = NULL;
    int i = 0, counter = 0;

    aux = head;
    trav = head;

    // you need a length of array
    while (trav != NULL)
    {
        ++counter;
        trav = trav-&gt;next;
    }

    // allocate memory
    topics = malloc(sizeof(char*) * (counter + 1));

    while(aux != NULL)  {
        topics[i] = aux-&gt;name;
        aux = aux-&gt;next;
        i++;
    }
    topics[counter] = NULL; // make sure that the last element is NULL
    return topics;
}
</code></pre>
",0
36261415,36261077,1,"<p>I can assume that you defined the variables with the internal linkage and with file scopes. So each translation unit has its own set of these varaibles.</p>

<p>Any initialization of these variables in one translation unit does not influence on the variables in other translation unit.</p>

<p>Remove keyword <code>static</code> in the declaration of the variables. Declare them in some header with keyword <code>extern</code> and define them only in one translation unit.</p>
",0
37295142,37295107,1,"<blockquote>
  <p>Why does this generate this error?  </p>
</blockquote>

<p>C standard doesn't allow this. Variable length arrays can't be initialized using brace-enclosed list of initializers.  </p>

<p>Standard says:<br>
C11-¡ì6.7.9/3: </p>

<blockquote>
  <p>The type of the entity to be initialized shall be an array of unknown size or a complete object type that is not a variable length array type.  </p>
</blockquote>
",1
36756580,36755003,2,"<p>As stated in the <a href=""http://linux.die.net/man/3/sem_open"" rel=""nofollow"">sem_open man page</a>: </p>

<blockquote>
  <p>The semaphore is identified by name.</p>
</blockquote>

<p>Since your code provides the same name value (<code>/mysem</code>) for both <code>sem_open</code> calls it results in referencing the same semaphore for both full and empty. That's clearly not what the logic of the program should be. Instead, open different semaphores for each. It's also best practice to check the return values of all function calls.</p>

<pre><code>empty = sem_open(""/empty_sem"", O_CREAT, 0644, BUFFER_SIZE);
if (empty == SEM_FAILED) {
     perror(""Failed to open semphore for empty"");
     exit(-1);
}

full = sem_open(""/full_sem"", O_CREAT, 0644, 0);
if (full == SEM_FAILED) {
     sem_close(empty);
     perror(""Failed to open semphore for full"");
     exit(-1);
}
</code></pre>
",2
34979935,34979184,0,"<p>As pointed out in the comments, the statement: <code>char line[83];</code> is not large enough to contain some of the lines shown in your input file, resulting in <em><a href=""https://en.wikipedia.org/wiki/Buffer_overflow"" rel=""nofollow"">buffer overflow</a></em>.   likewise, some of the fields in your <code>struct</code> are hard coded to lengths that may not be large enough to contain what future input files <em>may</em> hand you.  ( For example, some of the airline names in <em><a href=""https://en.wikipedia.org/wiki/Airline_codes-A"" rel=""nofollow"">this link</a></em> are longer than 31 characters, and will not fit into <code>char airlineName[31]</code> )  Fields like <code>arrive</code>, <code>depart</code> are probably safe using <code>float</code> types.  But the fields <code>notes</code>, <code>airlines</code> and even <code>id</code> are at least in question.  You may also <em>not</em> know the number of lines in your input file.</p>

<p>You can address input file line length or number of lines several ways.  Two options come immediately to mind:     </p>

<p><strong><em>1)</em></strong> Make an estimate of line lengths, and number of lines, and hope
they are stable for each input file. (as you have seen, this has
consequences)<br>
<strong><em>2)</em></strong> determine number of lines, and max line lengths as
a <em>preprocessing step</em>, then use that information to create
appropriately sized input line char buffer, and using pointer to
struct, create space enough to contain data in each line of data,
regardless of how many lines input file contains.</p>

<p>For example, create a function to determine the count of lines in the file, and length of the longest line in the file, then use that information to create memory sufficient to read file line by line without risk of buffer overflow: </p>

<pre><code>int longestline(const char *filename, int *lc)
{
    FILE *fp;
    int cnt=0, cntKeep=0;
    char c;
    (*lc) = 0;
    fp = fopen(filename, ""r"");
    if(!fp) return 0;
    while ( (c = fgetc ( fp) ) != EOF )
    {
        if(c != '\n') 
        {
            cnt++;
        }
        else 
        {
            cnt = 0;
            (*lc)++; //update line counter
        }
        cntKeep = cntKeep &lt; cnt ? cnt : cntKeep;//update longest line counter
    }
    if(cnt &gt; 0) (*lc)++;//last line may not have '\n'
    fclose(fp);
    return cntKeep;
}
</code></pre>

<p>Usage example:  </p>

<pre><code>int line_cnt = 0;
int longestLine = longestline(""c:\\inputfile.txt"", &amp;line_cnt)//determine longest line of file.
//char line[83];
char *line = calloc(longestLine + 1, 1);//create buffer to accommodate longest of lines found in file
//AIRLINE plane[12] = {0};
AIRLINE *plane = calloc(line_cnt, sizeof(AIRLINE));
</code></pre>

<p>This same <em>preprocessing</em> approach can also extend to creating appropriately sized struct member variables sizes as well.  Determine longest field lengths, member by member by using a similar approach expanded to use the <em><a href=""http://www.tutorialspoint.com/c_standard_library/c_function_strtok.htm"" rel=""nofollow"">strtok()</a></em> and <em><a href=""http://www.tutorialspoint.com/c_standard_library/c_function_fgets.htm"" rel=""nofollow"">fgets()</a></em> function on each line, and tracking longest length of each field as you read through the file.</p>
",0
34980149,34979184,0,"<p>When scanning for float with %f the address of the variable is needed and there are missing &amp; for those values.<br>
Scanning with %c will not terminate the variable with a '\0' and printf can then be a problem.<br>
The format ""%6s %30[^0-9]%f%f %99[^\n]"" will scan up to six characters then scan up to 30 characters that are not digits, then scan two floats and finally up to 99 characters stopping at a newline.</p>

<pre><code>#include &lt;stdio.h&gt;
typedef struct
{
    char id[7];
    char airlineName[31];
    float arrive,depart;
    char notes[100];
} AIRLINE;

void openFile(const char *data2)
{
    AIRLINE plane[12] = {{{0}}};
    int i = 0;
    FILE *file = fopen(data2,""r"");
    if ( file )
    {
        char line[83];
        while( i &lt; 6 &amp;&amp; fgets(line,sizeof line, file))
        {
            fputs(line, stdout);
            if( sscanf(line,""%6s %30[^0-9]%f%f %99[^\n]"",
                plane[i].id,
                plane[i].airlineName,
                &amp;plane[i].arrive,       // needed &amp;
                &amp;plane[i].depart,       // needed &amp;
                plane[i].notes) == 5 )
            {
                printf("" %s "",plane[i].id);
                printf("" %s "",plane[i].airlineName);  // use %s for string
                printf("" %f "",plane[i].arrive);
                printf("" %f "",plane[i].depart);
                printf("" %s "",plane[i].notes);
                i++;
            }
        }
        fclose(file);
    }
    else
    {
        perror(data2);
    }
}

int main(void)
{
    openFile(""data2.txt"");
    return 0;
}
</code></pre>
",0
46635087,46635028,1,"<p>Your function <code>calculations()</code> simply returns its parameter (<code>0 + num</code> is simply <code>num</code>).</p>

<p>The statement</p>

<pre><code>int sum_n = 0;
</code></pre>

<p>in it resets <code>sum_n</code> to <code>0</code> every time of calling it.</p>

<p>Move this statement out of it - directly into <code>main()</code> function (and before calling <code>calculations()</code>).</p>
",0
46635148,46635028,1,"<p>Corrections mentioned in comments below. </p>

<pre><code>int calculations (int *num){  //Should be a pointer or array eg. int num[] as you want to pass an array to this function

        int sum_n = 0;
        int i;

        //Create loop here to iterate over array and sum elements
        for(i=0; i&lt;sizeof(num)/sizeof(int); i++)
        sum_n+=num[i];

        return sum_n;
}
</code></pre>

<p>And  </p>

<pre><code> if (n[index] = 10){  //This is logically incorrect. This should be if(index==10). 
                     // n[index]=10 will assign 10 to a[10] and if will still pass as if(10) is true but make a note of it. Don't use assignment operator inside if, you need comparison operator `==`          

    printf(""The Sum of numbers is %d\n"",calculations(n[index])); //You should call calculations like this -&gt; calculations(n). You should pass whole array not just an element.
    }
</code></pre>
",2
46635216,46635028,4,"<p>every time you call a function the variables declared within a function are reset.
in case you want a variable that won't be reset every time you call a function you can simply make it static.</p>

<p>moreover you are passing and argument n[10] but your array stores number from n[0] to n[9] . And if you want sum of all ten numbers then you have to call calculation function for every number or you could just pass whole array. here is modified code.</p>

<pre><code>#include&lt;stdio.h&gt;
int calculations (int);

int main()
{
    int n[10];
    int index;
    int largest_n;
    int smallest_n;
    int *p;
    p = &amp;n[10];
    int a;
    int ans=0;
    printf(""Enter 10 Integers\n"");

     for (index = 0; index &lt; 10;  index ++){
        scanf(""%d"",&amp;n[index]);
        ans = calculations(n[index]);
        }

    printf(""The Sum of numbers is %d\n"",ans);
}



int calculations (int num){

    static int sum_n;

    sum_n += num;

    return sum_n;
}
</code></pre>
",0
46635257,46635028,3,"<p>First you don't need <code>array</code> for <code>sum</code> in this code, Second always remember to <em>check</em> what returned by <code>scanf</code>.The code is very simple.</p>

<p>first part with <code>main</code></p>

<pre><code>  int main()
  {
   int n;
   int sum=0;

   printf(""Enter 10 Integers\n"");

   for (int index = 0; index &lt; 10;  index ++){
       if(scanf(""%d"", &amp;n))
           sum+=n;
  }
    printf(""The Sum of numbers is %d\n"",sum);//calculations(n));

}
</code></pre>

<p>Second using function <code>calculation</code></p>

<pre><code>  int sum=0;

  void calculation(int num){
        sum+= num;
  }

 int main()
 {
    int n;
    printf(""Enter 10 Integers\n"");

    for (int index = 0; index &lt; 10;  index ++){
       if(scanf(""%d"", &amp;n))
             calculation(n);
    }
    printf(""The Sum of numbers is %d\n"",sum);//calculations(n));

  }
</code></pre>
",0
46041549,46041298,0,"<p><code>b</code> is never assigned to anything valid when it's declared:</p>

<pre><code>float *b,d;
</code></pre>

<p>At best, it's NULL or pointing to an invalid memory address:</p>

<p>I don't know what the <code>lubksb</code> function does:</p>

<pre><code>lubksb(a,n,indx,b);
</code></pre>

<p>But <code>b</code> is clearly an invalid parameter since you never assign to it before calling this function.</p>

<p>And with this statement:</p>

<pre><code>for(i = 1; i = 3; i++) {
    printf(""%.2f"",b[i]);
}
</code></pre>

<p>As others have pointed out, array indices start at zero.  But there's no evidence that <code>b</code> has a length of three anyway.</p>
",1
46041441,46041298,1,"<p>This is a Two Dimensional Array and you are looping as it was just one. You should do something like:</p>

<pre><code> for (int i = 0; i &lt; 3; ++i) {
    for(int j = 0; j &lt; 3; ++j) {
        printf(""%d %d: "", i+1, j+1);

    }
}
</code></pre>

<p>Is bad practice to define the size of the array explicit. Try to use a constant.</p>

<p>And as said in the comments by @Marged:</p>

<blockquote>
  <p>In C arrays starts in 0</p>
</blockquote>
",0
37691344,37691320,3,"<pre><code>while (x &gt;= 8 &amp;&amp; x &lt;= 600){

}
</code></pre>
",1
37693059,37691320,0,"<p>The relational and equality operators (<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>==</code>, and <code>!=</code>) don't work like that in C.  The expression <code>a &lt;= b</code> will evaluate to 1 if the condition is true, 0 otherwise.  The operator is <em>left-associative</em>, so <code>8 &lt;= x &lt;= 600</code> will be evaluated as <code>(8 &lt;= x) &lt;= 600</code>.  <code>8 &lt;= x</code> will evaluate to 0 or 1, both of which are less than 600, so the result of the expression is always 1 (true).  </p>

<p>To check if <code>x</code> falls within a range of values, you have to do two separate comparisons: <code>8 &lt;= x &amp;&amp; x &lt;= 600</code> (or <code>8 &gt; x || x &gt; 600</code>)</p>
",0
37696529,37691320,-1,"<p>this one means if x>=8£¬if x is bigger than 8 ,it turns 1 &lt;= 600 £»(always true)
if not , Then it turns 0&lt;=600 ; (always fause)</p>
",2
34985094,34985034,2,"<p>Change the <code>sscanf</code> to:</p>

<pre><code>sscanf(str, ""%*[^;];%d"", &amp;separate);
</code></pre>

<p>I.e., you need to match the semicolon <code>;</code> after the string that excludes it.  The portion in the square brackets matches the string that precedes the semicolon, leaving <code>;2</code>.  So you then need to match the semicolon <code>;</code> before trying to match the <code>2</code>.</p>
",0
36806541,36806525,3,"<p>Inside the foo loop, you defined a variable with the same name <code>FOO</code>, this will shadow the <code>FOO</code> in the outside, which means, the <code>FOO</code> you use in the loop is a variable local to the block only. The final <code>printf</code> is outside the loop, so the <code>FOO</code> it prints is the one resides in the outside scope. The shadowed <code>FOO</code> no longer exists at the this point.
So the code can be treat as same as this:</p>

<pre><code>int FOO_out = 0, bar = 0, i;
for (i = 0; i &lt; 4; i++) {
    int FOO_in = i;
    printf(""%d "", FOO_in);
    if (i % 2 == 0)
        FOO_in += bar;
    bar++;
}
printf(""%d %d"", FOO_out, bar);
</code></pre>
",0
36431475,36431024,0,"<p>There are a few things wrong in your code.
One is that you keep changing the head in the loop where you should only change it at the beginning (and use another variable when you traverse the linked-list). Also you should have more checks when you may hit the end of the list.</p>

<p>Try something like (disclaimer, I did not actually try it):</p>

<pre><code>void swap(struct node *head)
{
    struct node *odd, *even;
    if ((head == NULL) || (head-&gt;next == NULL))
        return;
    odd = head;
    even = head-&gt;next;
    head = head-&gt;next;  // change this one once and for all

    while ((odd != NULL) &amp;&amp; (even != NULL)) {
        // swap the elements
        odd-&gt;next = even-&gt;next;
        even-&gt;next = odd;

        // move to the next ones
        odd = even-&gt;next;
        if (odd != NULL)
            even = odd-&gt;next;
    }
}
</code></pre>
",0
42572071,42571700,4,"<p>The problem is probably here:</p>

<pre><code>tempNode -&gt; input = compare;
</code></pre>

<p>You let your node point to the input buffer, but that gets overwritten when you read the next input. (Except when you take extra precautions to avoid exactly that). Instead of copying the pointer, allocate memory to create a copy of the string, and let <code>tempNode -&gt; input</code> point to that.</p>
",0
34959755,34959728,2,"<pre><code>char Days[7] = {""Sun"",""Mon"",""Tue"",""Wed"",""Thu"",""Fri"",""Sat""};
</code></pre>

<p>can store <em>one</em> string of a maximum of 6 characters (+1 for the NUL-terminator). Fix it by using a 2D array:</p>

<pre><code>char Days[7][4] = {""Sun"",""Mon"",""Tue"",""Wed"",""Thu"",""Fri"",""Sat""};
</code></pre>

<p>or use an array of pointers to <code>char</code> as <a href=""https://stackoverflow.com/questions/34959728/why-is-the-error-expected-a-in-hew-using-c/34959755#comment57650555_34959728"">@BLUEPIXY suggested</a>:</p>

<pre><code>char *Days[7] = {""Sun"",""Mon"",""Tue"",""Wed"",""Thu"",""Fri"",""Sat""};
</code></pre>

<p>Note that you aren't supposed to modify the strings if you use this method.</p>
",0
34959756,34959728,1,"<p>That might be because you've defined an array of characters and not an array of strings.  <code>char Days[7]</code> refers to an array of seven characters.</p>

<p>You could use <code>char Days[7][4]</code> for a multidimensional array with seven three-letter strings.</p>
",0
34959775,34959728,1,"<pre><code>char Days[7] = {""Sun"",""Mon"",""Tue"",""Wed"",""Thu"",""Fri"",""Sat""}; // &lt;--- Incorrect because the initializers are for strings not chars.
</code></pre>

<p>So use an array of pointer to char instead:</p>

<p><code>char *Days[] = {""Sun"",""Mon"",""Tue"",""Wed"",""Thu"",""Fri"",""Sat""};</code></p>

<p>Or, alternatively use a 2D character array:</p>

<p><code>char Days[][30] = {""Sun"",""Mon"",""Tue"",""Wed"",""Thu"",""Fri"",""Sat""};</code></p>

<p>In either case, it's better to omit the number of array elements <code>7</code>. You don't need to provide the number of array elements when you already provide the list of values.</p>
",0
45722832,45722784,1,"<p>Returning address of local variable leads to <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behavior</a>, becouse it is not in scope (ended its lifetime) in the time you are passing it to <code>printf()</code>.</p>

<p>You have to pass an array to function as parameter, or allocate <code>char* res</code> on <code>heap</code> (<em>dynamic storage duration</em>).</p>

<p>Example</p>

<pre><code>char* res = malloc (amountOfBytesYouNeed);
if (res == NULL) { /*err msg*/ exit(-1); }
// Store data to res insted of arr
return res;

//
char * ptr = numberToBinary(4);
printf(""%s\n"", ptr);
free(ptr); // !
</code></pre>
",0
43747281,43747091,0,"<p>The <code>newline</code> character in C/C++ is <code>'\n'</code>. So in theory you only need to check:</p>

<pre><code>while (ch[k-1] != '\n')
</code></pre>

<p>However, I would suggest changing this:</p>

<pre><code>scanf("" %c"", &amp;ch[k - 1]); 
</code></pre>

<p>into this:</p>

<pre><code>scanf(""%c"", &amp;ch[k - 1]); 
</code></pre>

<p>Or you can use <code>gets_s()</code> for reading all the string and then parse it char by char.</p>
",2
36339084,36338968,1,"<p>You are changing a local copy of the pointer in <code>push</code>. That does not change the value of the pointer in the calling function.</p>

<p>I suggest changing the return type of <code>push</code> to <code>searchQueue*</code> and returning the new pointer.</p>

<pre><code>searchQueue* push(Node* node_to_insert, searchQueue* queue)
{
  searchQueue* elem_to_insert = (searchQueue*)malloc(sizeof(searchQueue));
  elem_to_insert-&gt;node = node_to_insert;
  if(queue_size == 0)
    elem_to_insert-&gt;next = NULL;
  else
    elem_to_insert-&gt;next = queue;
  queue = elem_to_insert;
  queue_size++;

  return element_to_insert;
} 
</code></pre>

<p>and in the calling function, use:</p>

<pre><code> queue = push(start_node, queue);
</code></pre>
",0
39630607,39629933,1,"<p>As @chux pointed out, i made a silly mistake by using equal sign (""=="") instead of assignment sign (""="") on line #34:</p>

<pre><code>line[i] == c -&gt; line[i] = c 
</code></pre>

<p>So the corrected program would be</p>

<pre><code>#include &lt;stdio.h&gt;
#define MAX 100

int getlinetext(char s[]);

int main(void)
{
    char longest[MAX];
    int longestlenght = 0;
    char line[MAX];
    int lenght;

    while ((lenght = getlinetext(line)) &gt; 0){
        if(lenght &gt; longestlenght){
            longestlenght = lenght;
            int i = 0;
            while (line[i] != '\0'){
                longest[i] = line[i];
                i++;
            }
            longest[i] = '\0';
        }
    }
    printf(""The longest lenght is %d\n"", longestlenght);
    printf(""%s\n"", longest); 
    return 0;
}

int getlinetext(char line[])
{
    int i=0;
    int c;
    while ((c = getchar()) != EOF){
        line[i] = c;
        if (c == '\n')
            break;
        i++;
    }
    line[i] = '\0';
    return i;
}
</code></pre>
",5
36377565,36377539,-1,"<p>You intitialized one byte and printed four, so the other three of them are something arbitrary. </p>

<p>Try this:</p>

<pre><code>int testvar = 9;
</code></pre>

<p>That will initialize four bytes. </p>

<p>Or this:</p>

<pre><code>char testvar = 9;
char dummy1 = 0;
char dummy2 = 0;
char dummy3 = 0;

int * p = (int *)&amp; testvar;
</code></pre>

<p>Depending on how the stack is laid out that may get you what you want (depending on platform and compiler and optimization). <strong>It's very, very bad programming practice. Don't <em>ever</em> do this sort of thing in production code.</strong> </p>

<p>Don't do it in your homework either. It's the kind of thing you play with just to see what happens when you're learning how pointers work. </p>
",15
35260326,35259700,1,"<p>You could add another switch case for the dash, which would toggle some kind of negative flag and then read a number as you're already doing. If you do not like introducing such a flag, then the best option would be using fgets, which returns the entire input line. But that has the downside that you need to parse the input. I.e. do some string manipulation, which may be slightly more complex than a simple flag parameter.</p>

<p>On the other hand, from the code you attached, I deduct that the only valid input consists of mere numbers (integers). You could just read an integer then with scanf.</p>
",0
36664875,36664812,1,"<p>Avoid <code>&amp;</code> in <code>printf</code>, it returns address of that variable. </p>
",3
36664988,36664812,0,"<p>Why are you writing this line <code>largest = nvalue;</code> ?
And your if-else if commands are totally wrong.
Try this code:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(){
    int largest = 0;
    int no1, no2, no3;

    printf(""Number1: "");
    scanf(""%d"", &amp;no1);

    printf(""Number2: "");
    scanf(""%d"", &amp;no2);

    printf(""Number3: "");
    scanf(""%d"", &amp;no3);

    if ((no1 &gt; no2) &amp;&amp; (no1&gt;no3)){
        largest=no1; 
    }
    else if ((no2 &gt; no1) &amp;&amp; (no2&gt;no3)) {
        largest=no2; 
    }
    else {
        largest=no3; 
    }
    printf(""The largest number is:%d"", largest);

    return 0;
}
</code></pre>
",4
36665566,36664812,0,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;limits.h&gt;

int main(void) {
    int largest = INT_MIN;
    int n, value;
    int i;

    printf(""Enter value of n:"");//fflush(stdout);
    scanf(""%d"", &amp;n);

    for(i = 1; i &lt;= n; ++i){
        printf (""Number%d:"", i);//fflush(stdout);
        if(1 != scanf(""%d"", &amp;value)){
            printf(""invalid input!\n"");
            while(getchar() != '\n');//clear input
            --i;
            continue;
        }
        if(value &gt; largest)
            largest = value;
    }
    printf(""The largest number is %d\n"", largest);

    return 0;
}
</code></pre>
",0
36666651,36664812,1,"<p>Code should be well formatted e.g code inside curly braces ({ }) should be indented properly (this makes it easier to read your code).</p>

<pre><code>#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
</code></pre>

<p>Variables should be descriptive (helpful if other people are reading over your code).</p>

<pre><code>    int largest = 0;
    int num1 = 0, num2 = 0, num3 = 0;
</code></pre>

<p>The newline character ('\n) isn't necessary, unless you want scanf to take the newline character as part of your input.</p>

<pre><code>    printf(""Enter the first number : "");
    scanf(""%d"", &amp;num1);

    printf(""Enter the second number : "");
    scanf(""%d"", &amp;num2);

    printf(""Enter the third number : "");
    scanf(""%d"", &amp;num3);
</code></pre>

<p>This is a much cleaner and simpler check to see which is the largest number. (taken from <a href=""https://stackoverflow.com/a/36664988/6179830"">Rishav Choudhuri's</a> code above)</p>

<pre><code>    if (num1 &gt; num2 &amp;&amp; num1 &gt; num3)
    {
        largest = num1;
    }
    else if (num2 &gt; num1 &amp;&amp; num2 &gt; num3)
    {
        largest = num2;
    }
    else
    {
        largest = num3;
    }

    printf(""The largest number is : %d"", largest);

    return 0;
}
</code></pre>

<p>I also recommend reading this book <a href=""https://rads.stackoverflow.com/amzn/click/com/0131103628"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">The C Programming Language 2nd Edition</a> and reading some tutorials online</p>

<p>also be sure to write lots of code as well :D</p>
",0
37037216,37037165,2,"<p><code>getkey</code> has been declared to return a <code>char</code>, but you're trying to return <code>candidate</code> which is a <code>char</code> array.</p>

<p>You probably meant to return one of the elements in the array, i.e. something like <code>candidate[x]</code>.</p>

<p>The reason for the error message saying ""pointer"" instead of ""array"" is that the compiler is converting <code>candidate</code> to a pointer to the first element in the array, which happens implicitly in some contexts, for example when returning, since arrays can't be returned (or passed as parameters) by value in C (see <a href=""https://stackoverflow.com/q/1461432/3425536"">What is array decaying?</a>).</p>
",0
37037241,37037165,6,"<p>Your local variable <code>candidate</code> is an array of char.  When you say</p>

<pre><code>return candidate;
</code></pre>

<p>you return a pointer to char.  (This is due to the very close relationship between arrays and pointers in C, which you will have to learn about if you don't know yet.)  But you've stated that your function <code>getkey</code> returns a char, not a pointer-to-char.</p>

<p>You need to make the function's return value match its type.  You might want change the <code>return</code> statement so it returns a single char.  If you want to have the function return a whole string, you could change its declaration to <code>char *getkey()</code>, but in that case you'll also have to take care of the allocation of the <code>candidate</code> array.</p>

<p>Here's what the warning means.  You tried to return a pointer.  The function is supposed to return a character, which is represented as a small integer.  The compile is willing to try to convert the pointer to an integer, in case that's what you really want to do, but since that's not usually a good idea, it warns you.  Indeed, in this case the warning tells you that you probably made a mistake.</p>
",7
35266864,35266457,1,"<p>You're nearly there, there is a simple (and quite common) algorithm or doing a scramble on an array.  With one pass through the array you can randomise the positions of each value without duplicating them.  The check function isn't necessary now due to the scramble function's operation.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

void deal(void);
void check(void);

int cases[22];
int prizes[22] = {1,2,3,4,5,6,8,10,15,20,25,35,50,65,85,100,105,135,165,200,250};

int main()
{
  srand(time(NULL));

  int a = 0;
  deal();

  for(a = 0 ; a &lt; 22 ; a++)
    printf(""%d \n"", cases[a]);

  return 0;
}

//this is a neat algorithm for re-ordering an array without duplication
void scramble(int* array, int length)
{
  int i;
  int r;
  int temp;

  for(i = 0 ; i &lt; length ; i++)
  {
    //swap this element with a random one to it's left (or itself)
    r = rand() % (i + 1);

    temp = array[r];
    array[r] = array[i];
    array[i] = temp;
  }
}

void deal(void)
{
  int r;
  int n = 1;

  //copy the prizes across directly
  for(n = 0 ; n &lt; 22 ; n++)
    cases[n] = prizes[n];

  scramble(cases, 22);
}
</code></pre>

<p>Examine the scramble() function in detail and you'll find it quite interesting.</p>

<p><strong>Edited to change the algo to a single pass as per a suggestion in the comments.</strong></p>
",8
39128705,39120091,1,"<p>Why don't you just use this? :</p>

<pre><code>#include &lt;stdio.h&gt;
int main() {
int index=0;
char str[1000];
char c;
while((c=getchar())!='/')  {
  str[index] = c;
  index++;
}
str[index]='\0';
printf(""%s"",str);
return 0;
}
</code></pre>
",0
39129055,39120091,2,"<p>When reading characters from <code>stdin</code>, in your case, you have <em>three</em> conditions to protect against if you want to terminate the read on <code>'/'</code>:</p>

<ol>
<li><code>index + 1 &lt; 1000</code> (to prevent overrun and preserve space for the
<em>nul-terminating</em> char)</li>
<li><code>(c = getchar()) != '/'</code> (your chosen terminator); and</li>
<li><code>c != EOF</code>  (you don't want to read after <code>EOF</code> is set on the
stream)</li>
</ol>

<p>Putting those pieces together, you could simply do:</p>

<pre><code>#include &lt;stdio.h&gt;

#define MAXC 1000   /* define a constant (macro) for max chars */

int main (void) {

    int c, idx = 0;
    char str[MAXC] = """";    /* initialize your array (good practice) */

    /* read each char up to MAXC (-2) chars, stop on '/' or EOF */
    while (idx + 1 &lt; MAXC &amp;&amp; (c = getchar()) != '/' &amp;&amp; c != EOF)
        str[idx++] = c; /* add to str */

    str[idx] = 0; /* nul-terminate (optional here if array initialized, why?) */

    printf (""%s"", str);

    return 0;
}
</code></pre>

<p>(I would encourage a <code>putchar ('\n');</code> after the <code>printf</code> (or simply add a <code>'\n'</code> to the <em>format string</em>) to protect against input without a final POSIX <em>end-of-line</em>, e.g. in the event of a stop on <code>'/'</code>, or on reaching <code>1000</code> chars, or reading from a redirected file that does not contain a POSIX EOL)</p>

<p><strong>Example Input File</strong></p>

<pre><code>$ cat ../dat/captnjack.txt
This is a tale
Of Captain Jack Sparrow
A Pirate So Brave
On the Seven Seas.
</code></pre>

<p><strong>Example Use/Output</strong></p>

<pre><code>$ ./bin/getchar_io &lt;../dat/captnjack.txt
This is a tale
Of Captain Jack Sparrow
A Pirate So Brave
On the Seven Seas.
</code></pre>

<p>Look things over and let me know if you have any questions.</p>
",0
36628008,36627955,5,"<p>Change the first character by subscripting the substring.</p>

<pre><code>substring[0] = 'b';
</code></pre>

<p>If you want to replace multiple characters, try a loop, or use memcpy. Don't use strcpy: you don't want the NUL terminator to be copied.</p>

<pre><code>memcpy(substring, ""how"", 3);
</code></pre>
",1
36628091,36627955,-2,"<p><code>*substring = 'b';</code> as posted by user EOF my solution was as so</p>

<pre><code>for (int x = 0; x &lt; strlen(newstring); x++){
    *substring++ = newstring[x];
}
</code></pre>
",1
47525295,32833597,0,"<p>You can use memcmp function with this format:</p>

<pre><code>int memcmp ( const void * ptr1, const void * ptr2, size_t num );
</code></pre>

<p>For example;</p>

<pre><code>/* memcmp example */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main ()
{
  char buffer1[] = ""abcde"";
  char buffer2[] = ""abcde"";

  int n;

  n=memcmp ( buffer1, buffer2, sizeof(buffer1) );

  if (n&gt;0) printf (""'%s' is greater than '%s'.\n"",buffer1,buffer2);
  else if (n&lt;0) printf (""'%s' is less than '%s'.\n"",buffer1,buffer2);
  else printf (""'%s' is the same as '%s'.\n"",buffer1,buffer2);

  return 0;
}
</code></pre>

<p>output is:</p>

<pre><code>'abcde' is same as 'abcde'.
</code></pre>
",0
34897849,34897803,2,"<p>Add</p>

<pre><code>#include &lt;string.h&gt;
</code></pre>

<p>memset is available in string.h</p>
",1
34897855,34897803,18,"<p>Add</p>

<pre><code>#include &lt;string.h&gt;
</code></pre>

<p>at the top of file.</p>

<p>This because is the header file where the <a href=""http://www.tutorialspoint.com/c_standard_library/c_function_memset.htm"" rel=""noreferrer"">memset</a> prototype can be found by compiler.</p>

<p>Avoid using gets function... Use <a href=""http://www.tutorialspoint.com/c_standard_library/c_function_scanf.htm"" rel=""noreferrer"">scanf</a> or <a href=""http://www.tutorialspoint.com/c_standard_library/c_function_fgets.htm"" rel=""noreferrer"">fgets</a> instead. </p>

<p>Take a look <a href=""https://stackoverflow.com/questions/1694036/why-is-the-gets-function-so-dangerous-that-it-should-not-be-used"">HERE</a></p>
",3
42594118,42594061,0,"<p>Use <code>floor()</code> to find the integer part, and then subtract the integer part from the original value to find the fractional part.</p>

<p>Note: The problem you're most likely having is that some numbers are too large for the integer part to fit in the range of an <code>int</code>.</p>

<p>--Added--</p>

<p>If and only if you are able to assume that an <code>unsigned int</code> is larger than the floating point representation's significand (e.g. 32-bit <code>unsigned int</code> and IEEE standard single-precision floating point with only 23 fractional bits, where ""32 &lt; 23"" is true); then a number that is too large for an <code>unsigned int</code> can't have any fractional bits. This leads to a solution like:</p>

<pre><code>if(x &gt; UINT_MAX) {
    integer_part = x;
    fractional_part = 0;
} else {
    integer_part = (int)x;
    fractional_part = x - integer_part;
}
</code></pre>
",12
35282118,35281915,2,"<p>Your program has several problems:</p>

<ul>
<li>you should parsing all arguments before copying: there might be a <code>-o</code> option after the <code>-i</code> option.</li>
<li>The filename should be <code>optarg</code></li>
<li><code>fgets</code> returns <code>NULL</code> at end of file</li>
<li><code>printf</code> will duplicate the <code>\n</code>, you should use <code>fputs</code>.</li>
<li><code>fputc</code> does not take a buffer</li>
<li><code>fgets</code> takes 3 arguments.</li>
</ul>

<p>Here is a corrected version:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main(int argc, char *argv[]) {
    char *infile = NULL;
    char *outfile = NULL;
    FILE *file = stdin;
    FILE *text = stdout;
    char ch[200];

    while ((opt = getopt(argc, argv, ""i:o:"")) != -1) {
        switch (opt) {
          case 'i':
            infile = optarg;
            break;
          case 'o':
            outfile = optarg;
            break;
          case '?':
            if (optopt == 'i') {
                fprintf(stderr, ""Missing mandatory input option\n"");
            } else
            if (optopt == 'o') {
                fprintf(stderr, ""Missing mandatory output option\n"");
            } else {
                fprintf(stderr, ""Invalid option received\n"");
            } 
            break;
        }
    }
    if (infile) {
        file = fopen(infile, ""r"");
        if (file == NULL) {
            fprintf(stderr, ""cannot open input file %s: %s\n"", 
                infile, strerror(errno));
            exit(1);
        }
    }
    if (outfile) {
        text = fopen(outfile, ""r"");
        if (text == NULL) {
            fprintf(stderr, ""cannot open output file %s: %s\n"",
                outfile, strerror(errno));
            exit(1);
        }
    }
    while (fgets(ch, 200, file) != NULL) {
        fputs(ch, text);
    }
    fclose(file);
    fclose(text);
    return 0;
}
</code></pre>
",0
35201678,35201595,1,"<p>The main will call the function 82 times and each time the func will call recursively itself 80 times in a loop of decreasing <code>n</code> items.</p>

<p>So altogether it will be 81*81.</p>

<p>EDIT: I didn't notice the return after first iteration so actually it's pretty small number.</p>
",5
35201759,35201595,0,"<ol>
<li><p>Set the number of elements in <code>a</code> to be arbitrarily high.</p></li>
<li><p>Build a <em>function</em> to assign elements to <code>a</code>, and only use that function to set elements of <code>a</code>. You could use this function to make sure that you don't attempt to write outside the bounds of <code>a</code>. (Else the behaviour of your program will be undefined and so any results will be meaningless).</p></li>
<li><p>Encode a ""watermark"" <code>static int</code> in that function to record the largest index accessed.</p></li>
<li><p>Run your program and note the value of the variable set up for (3).</p></li>
</ol>
",0
35201761,35201595,0,"<p>Declare a global counter - it will be initialized to zero.  In the function, at the same scope as 'a' is declared, increment the counter.</p>

<p>Printf() it out at the end of main().</p>
",1
40554973,40554423,3,"<p>In general, no. C has no use for a structure definition once the code is compiled. The compiler will convert all the member references like this...</p>

<pre><code>foo.x = 1;
</code></pre>

<p>...to assembly language that only knows that <code>x</code> is a data item of a certain type at a certain offset from the beginning of <code>foo</code>. (Some hardware architectures may use a different addressing mechanism, but it will be conceptually the same.)</p>

<p>It's possible there's a compiler out there that embeds debug symbols in the object file rather than a separate debug file. I'm unaware of any such compilers, but one could exist. However, that's not really the same thing at all. Those symbols would probably only be loaded by a debugger and wouldn't be available to the program itself.</p>
",0
40747101,40747015,0,"<p>You should <code>#include &lt;string.h&gt;</code> and do something like this:</p>

<p><code>case '0': strcpy(CardValue[i],""ACE"");</code></p>

<p>etc. Also note, that <code>CardValue[i];</code> has no effect at all. You should also remove <code>CardValue[i][6]=i;</code>, I don't really know what you meant by that, but it surely should not be there.</p>
",0
40747105,40747015,2,"<p>You need to doing a strcpy and not assigning string literals directly. Also, the array usage is wrong.</p>

<p>The code should be like below:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main ()
{
    char CardValue[52][6];
    int i;

   /* Not clear what you are trying in the below 2 lines. But, it'll not work :-) */
    /*CardValue[i][6]=i;
    CardValue[i];*/    

    for (i=0;i&lt;52;i++)
    {

        switch (i%13)
        {
            case '0': strcpy(CardValue[i],""ACE"");
            break;

            case '1': strcpy(CardValue[i],""2"");
            break;

          /** Do the same way for other case **/

        }
     }
}
</code></pre>
",0
35279191,35279055,1,"<ol>
<li><p>You need to put braces around the body of the function. And you shouldn't have braces around each block that asks a question -- that makes the variables like <code>q1</code> local to that block, so you can't use them later in the function. </p></li>
<li><p>Every statement <strong>must</strong> end with <code>;</code>. </p></li>
<li><p><code>if()</code> is totally meaningless -- you have to put something inside the <code>()</code>; but I don't see the point of doing an extra check before checking the answer to question 2.</p></li>
<li><p>To update <code>correct</code>, you have to use <code>=</code>, not <code>==</code>; the latter is for comparison, not assignment. BTW, the idiomatic way to write <code>correct = correct + 1</code> is <code>correct++</code>.</p></li>
<li><p>Since <code>main()</code> is declared to return <code>int</code>, you should have a <code>return</code> statement at the end.</p></li>
<li><p>You had a bunch of typos. For instance, you used <code>&amp;q12</code> and <code>&amp;q1</code> when you meant <code>&amp;q2</code> and <code>&amp;q3</code> in your <code>scanf()</code> calls.</p></li>
</ol>

<p>

<pre><code>#include &lt;stdio.h&gt;
int main(void) {
    int correct = 0;

    int q1;
    printf(""What is 24/(6-3)-7?\n "");
    scanf(""%d"",&amp;q1);

    int q2;
    printf(""What is -3x4+16?\n "");
    scanf(""%d"",&amp;q2);

    int q3;
    printf(""What is 9^(1/2)?\n "");
    scanf(""%d"",&amp;q3);

    if(q1 == 1){
        correct = correct + 1;
    }
    if(q2 == 4){
        correct = correct + 1;
    }
    if(q3 == 3){
        correct = correct + 1;
    }

    printf(""You got %d answers correct!\n"", correct);
    return 0;
}
</code></pre>
",3
40973016,40972863,1,"<p>What you're asking for is to map a string (well, in your case a single character) to a variable in C.  This is not directly supported by the language.  You could however use your choice of associative array implementation, for which there are tons of choices--see here: <a href=""https://stackoverflow.com/questions/1138742/looking-for-a-good-hash-table-implementation-in-c"">Looking for a good hash table implementation in C</a></p>

<p>Or, since in your example you have only single-character variables (P,D,G,H), you could build a lookup table:</p>

<pre><code>int P=0, D=0, G=0, H=0;
int* targets[256] = {};
targets['P'] = &amp;P;
targets['D'] = &amp;D;
targets['G'] = &amp;G;
targets['H'] = &amp;H;

for (size_t i = 0; i &lt; strlen(s); i += 3) {
    assert(targets[s[i]]);
    (*targets[s[i]])++; /* if s[i] == 'P', increment P */
}
</code></pre>
",0
35197053,35196530,1,"<p><code>clock</code> function in <code>&lt;ctime&gt;</code>:</p>

<blockquote>
  <p>Returns the processor time consumed by the program.</p>
  
  <p>The value returned is expressed in clock ticks, which are units of
  time of a constant but system-specific length (with a relation of
  CLOCKS_PER_SEC clock ticks per second).</p>
</blockquote>

<p><a href=""http://www.cplusplus.com/reference/ctime/clock/"" rel=""nofollow noreferrer"">reference</a></p>

<p>So, basically it returns number of processor ticks passed since the start of the program. While the processor tick is the number of processor instructions executed by a <a href=""https://en.wikipedia.org/wiki/CPU_time"" rel=""nofollow noreferrer"">process</a>, it does not account for IO time and any such that does not use CPU.</p>

<p><code>CLOCKS_PER_SEC</code> Is the average number of CPU ticks executed by machine and varies from machine to machine, even it (probably) changes time to time, because doing too much IO will cause overall decrease for each process <code>CLOCKS_PER_SEC</code> because more time will be spent not using CPU.</p>

<p>Also this statement: <code>(end-start) / CLOCKS_PER_SEC) = !seconds</code>
is not correct, because the right implementation is</p>

<pre><code>while (((end-start) / CLOCKS_PER_SEC) != seconds)
    end = clock();
</code></pre>

<p>Does the trick of <a href=""https://en.wikipedia.org/wiki/Busy_waiting"" rel=""nofollow noreferrer"">busy waiting</a>, program will be trapped inside this while loop until <code>seconds</code> seconds will be passed using CPU clocks and CLOCKS_PER_SEC to determine time passed.</p>

<p>Although I would suggest changing it to:</p>

<pre><code>while (((end-start) / CLOCKS_PER_SEC) &lt; seconds)
    end = clock();
</code></pre>

<p>Because if process has low priority, or computer is too busy handling many processes chance is one CPU tick can take more than one second (probably when system is crashed, for some buggy program who take up a lot of resources and has high enough priority to cause CPU starvation).</p>

<p>Finally, I do not recommend using it, because you are still using CPU while waiting which can be avoided by using sleep tools discussed <a href=""https://stackoverflow.com/questions/4184468/sleep-for-milliseconds"">here</a></p>
",0
35196586,35196530,5,"<p>It's just a busy-wait loop, which is a very nasty way of implementing a delay, because it pegs the CPU at 100% while doing nothing. Use <a href=""http://linux.die.net/man/3/sleep"" rel=""nofollow"">sleep()</a> instead:</p>

<pre><code>#include &lt;unistd.h&gt;

void wait(int seconds)
{
    sleep(seconds);
}
</code></pre>

<hr>

<p>Also note that the code given in the question is buggy:</p>

<pre><code>while (((end-start) / CLOCKS_PER_SEC) = !seconds)
</code></pre>

<p>should be:</p>

<pre><code>while (((end-start) / CLOCKS_PER_SEC) != seconds)
</code></pre>

<p>or better still:</p>

<pre><code>while (((end-start) / CLOCKS_PER_SEC) &lt; seconds)
</code></pre>

<p>(but as mentioned above, you shouldn't even be using this code anyway).</p>
",3
35196641,35196530,1,"<p>Generally, clock_t is a structure in  library. It returns the number of clock ticks elapsed from the program initiation till end or till you want to count the time.</p>

<p>If you want to know more you can read details here: <a href=""http://www.tutorialspoint.com/c_standard_library/c_function_clock.htm"" rel=""nofollow"">http://www.tutorialspoint.com/c_standard_library/c_function_clock.htm</a></p>
",0
35196950,35196530,1,"<p>The <strong>clock()</strong> function returns the number of system clock cycles that have occurred since the program began execution. 
Here is the prototype: <strong>clock_t clock(void);</strong></p>

<p>Note that, <em>the return value is not in seconds</em>. To convert the result into seconds, you have to divide the return value by <strong>CLOCKS_PER_SEC</strong> macro. 
You program just does this. Functionally it stops the program execution for <strong>seconds</strong> seconds (you pass this value as an argument to the <strong>wait</strong> function).</p>

<p>By the way, it uses <strong>time.h</strong>, not <strong>clock.h</strong>. And it is not the right point to start learning <strong>C</strong>.</p>

<p>To learn more: <a href=""http://www.cplusplus.com/reference/ctime/?kw=time.h"" rel=""nofollow"">http://www.cplusplus.com/reference/ctime/?kw=time.h</a></p>
",0
46027976,39455200,0,"<p>Knots really apply to unstructured Fortran-type code, and less to modern languages. They give a measure of how complex the control flow is. Some programs we looked at were pure spaghetti! </p>

<p>The phrase ""code is considered to be simpler (and thus faster)"" is incorrect. Code with less knots is considered to be simpler and easier to maintain. Nothing to do with speed. </p>

<p>From David Hedley (who first counted them)</p>
",0
39319841,39319772,3,"<p>The ""extra"" output is because you are printing the return value of <code>Menu()</code> (but it doesn't return one). This is <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer""><em>undefined behaviour</em></a>.</p>

<p>What happens is that <code>printf()</code> prints 120 (<code>printf(""%d"", Fact(n));</code>) for your chosen input of 5  and its return value (the number of chars printed) is 3, which is printed by the <code>printf()</code> in main(). But don't rely on this as this is just en explanation of what happens in your case and by no means a guarantee. As said before, your code has undefined behaviour.</p>

<p>If you don't have the need to return a value from <code>Menu()</code>, you can just make it a <code>void</code> function.</p>

<hr>

<p>There are more problems that I initially found. Compiling your code, GCC reports:</p>

<pre><code>test.c: In function ¡®Menu¡¯:
test.c:12:18: warning: implicit declaration of function ¡®Fact¡¯ [-Wimplicit-function-declaration]
     printf(""%d"", Fact(n));
                  ^
test.c:18:18: warning: implicit declaration of function ¡®Fib¡¯ [-Wimplicit-function-declaration]
     printf(""%d"", Fib(n));
                  ^
test.c:22:5: warning: implicit declaration of function ¡®exit¡¯ [-Wimplicit-function-declaration]
     exit(0);
     ^
test.c:22:5: warning: incompatible implicit declaration of built-in function ¡®exit¡¯
test.c:22:5: note: include ¡®&lt;stdlib.h&gt;¡¯ or provide a declaration of ¡®exit¡¯
test.c:26:14: warning: suggest parentheses around comparison in operand of ¡®^¡¯ [-Wparentheses]
     while(num&lt;0 ^ num&gt;2){
              ^
test.c: In function ¡®Fact¡¯:
test.c:36:9: warning: variable ¡®Factorial¡¯ set but not used [-Wunused-but-set-variable]
     int Factorial;
         ^
test.c: In function ¡®Fib¡¯:
test.c:46:9: warning: variable ¡®Fibinnaci¡¯ set but not used [-Wunused-but-set-variable]
     int Fibinnaci;
         ^
test.c: In function ¡®Menu¡¯:
test.c:33:1: warning: control reaches end of non-void function [-Wreturn-type]
 }
 ^
test.c: In function ¡®Fact¡¯:
test.c:43:2: warning: control reaches end of non-void function [-Wreturn-type]
  }
  ^
test.c: In function ¡®Fib¡¯:
test.c:53:1: warning: control reaches end of non-void function [-Wreturn-type]
 }
 ^
</code></pre>

<p>1) You are calling <code>Fact()</code> and <code>Fib()</code> before compiler could their declarations. You can fix it by declaring at the top:</p>

<pre><code>int Fact(int);
int Fib(int);
</code></pre>

<p>2) You haven't included <code>stdlib.h&gt;</code> for <code>exit()</code>'s prototype.</p>

<p>3) Not returning anything for inputs other than <code>1</code> or <code>0</code> from <code>Fact()</code> and <code>Fib()</code> functions. You can fix this by returning values from the <code>else</code> parts:</p>

<pre><code> else {
     return n* Fact(n-1);
 }
</code></pre>

<p>and </p>

<pre><code>else {
    return Fib(n-1)+ Fib(n-2);
}
</code></pre>
",5
39319880,39319772,1,"<p>You could change the factorial function as:</p>

<pre><code>int Fact(int n){

    if(n==1 || n==0){
        return 1;
    }
    else{
     return n* Fact(n-1);
     }


 }
</code></pre>
",1
39320223,39319772,1,"<p>Unlike in some other languages, the return value is produced in the function code by the <code>return</code> statement.  You <code>Fib</code> and <code>Fact</code> functions are incorrect, as the compiler would underscore with warnings if invoked with the appropriate flags (such as <code>gcc -Wall</code>).</p>

<p>Here is a corrected version:</p>

<pre><code>int Fact(int n) {
    if (n == 1 || n == 0) {
        return 1;
    } else {
        return n * Fact(n - 1);
    }
}

int Fib(int n) {
    if (n &lt;= 1) {
        return n;
    } else {
        return Fib(n - 1) + Fib(n - 2);
    }
}
</code></pre>

<p>Since the functions weren't returning anything for the general case, <code>printf</code> was printing whatever value happens to be in the register that would normally be set with the return value.  This is a form of undefined behavior: anything ca happen, trying to interpret the observed behavior is useless.</p>

<p>Furthermore, you should output a linefeed after the number:</p>

<pre><code>printf(""%d\n"", Fact(n));
</code></pre>

<p>Note also that the condition in <code>while (num &lt; 0 ^ num &gt; 2)</code> is probably not what you meant: the operator for logical OR is written <code>||</code>.  The <code>^</code> is the bitwise exclusive or operator.</p>

<pre><code>while (num &lt; 0 || num &gt; 2) 
</code></pre>
",0
34954986,34954835,2,"<ol>
<li><p>Your main function doesn't have a return value. You need to use either int or void.</p></li>
<li><p><code>arr[i] = ""a"";</code> assigns a null-terminated string to <code>arr[i]</code>, you want to assign a char.</p></li>
<li><p>What is <code>arr</code>? The name of your array is <code>myArray</code>!</p></li>
<li><p><code>printf(""%s\n"", myArray[i]);</code> will interpret <code>myArray[i]</code> as a string, but it is a char.</p></li>
</ol>

<p>This is the corrected program:</p>

<pre><code>int main() 
{
    int i;
    char myArray[10];

    for (i = 0; i &lt; 5; i++) 
    {
        myArray[i] = 'a';
        printf(""%c\n"", myArray[i]);
    }
}
</code></pre>
",3
34955377,34954835,1,"<p>For the sake of completion, I felt obligated to point out that even <code>return 0;</code> isn't quite official, as I'll demonstrate below.</p>
<blockquote>
<p>Also, did you know you are only iterating through 5, but declared for 10?</p>
<p>-e0k</p>
<p>@e0k thanks for making me notice. Ya, I need some sleep hehe</p>
<p>-Asperger</p>
</blockquote>
<p>In order for you to remember to iterate through the same amount of indices as you declared in your array, you should <code>#define</code> your array length like this:</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define ARRAY_SIZE 10

int main(void) // we're not using argc and argv
{
    size_t i; // use size_t since i is used as an array index
    char myArray[ARRAY_SIZE];

    for (i = 0; i &lt; ARRAY_SIZE; i++) 
    {
        myArray[i] = 'a';
        printf(&quot;%c\n&quot;, myArray[i]);
    }

    return EXIT_SUCCESS; // defined in stdlib.h
}
</code></pre>
",0
34954936,34954835,2,"<ol>
<li><p><code>arr</code> is array with elements of type <code>char</code> - you should assign 'a' to each element instead of ""a"" (the latter gives you some address in memory - namely address where ""a"" is stored).</p></li>
<li><p><code>%s</code> is used to print null terminated string. Use <code>%c</code> instead due to type of elements in your array.</p></li>
</ol>

<p>PS. Better use main like this:</p>

<pre><code>int main(void)
{
  ...
  return 0;
}
</code></pre>
",1
36352238,36351996,0,"<p>You set <code>ptr_node2</code> once before the loop, and that's it. If you do no update it in the loop it will not change.</p>

<p>A better loop condition might be <code>while (ll2-&gt;size &gt; 0)</code>.</p>
",1
35295578,35295286,0,"<p>If you want to point the first not allowed char.</p>

<pre><code>int main()
{
    char input[100];
    char arrow[100] = {0};
    printf(""Type a String which will be converted to an Integer: "");
    scanf(""%s"", input);

    int number = 0;
    int i = 0;
//    int x = 0;
    bool success = true;

    while (input[i] != '\0')
    {
        if (input[i] &gt;= '0' &amp;&amp; input[i] &lt;= '9')
        {
            number = number * 10 + input[i] - '0';
            arrow[i] = ' ';
            i++;
        }
        else
        {
            success = false;
            arrow[i]='^';
            printf(""\nInput number is wrong!\n%s\n%s\n"", input, arrow);
            break;
        }
    }
    if (success)
    {
        printf(""string %s -&gt; number %d \n"", input, number);
    }

    return 0;
}
</code></pre>

<p>output is</p>

<pre><code>Input number is wrong!
423432rr55
      ^
</code></pre>
",3
44715745,34016070,0,"<blockquote>
  <p>I know my problems are with the two lines with //placeholder comment,
  but I'm not sure how to proceed.</p>
</blockquote>

<p>The <code>counter</code> and the distinction of cases odd/even is futile. In any case:</p>

<pre><code>    int i, j, k;
    for (i=0; i&lt;wDiagRowSize; i++)
    for (j=0; j&lt;wDiagColSize; j++)
    diagUpRightArray[i][j] =
      i&lt;wDiagColSize  &amp;&amp;                   j&lt;=i              ? wordArray[i-j][j]
    : wDiagColSize&lt;=i &amp;&amp; (k=wDiagColSize-1-j)&gt;i-wDiagColSize ? wordArray[k][i-k]
    : '\0';
</code></pre>
",0
34885141,34884386,0,"<p>Now it runs ok but i have done it manually the question would be ""how the function of inserting a node before it's first element"" will look like</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
struct entry {
 int value;
 struct entry *next;

};
//X struct u want to target
struct entry insertentry(struct entry *new_entry, struct entry *x){
int data;

printf(""Enter a value for your new entry"");
scanf(""%i"",&amp;data);
new_entry-&gt;value=data;
new_entry-&gt;next=x-&gt;next;
x-&gt;next=&amp;(*new_entry);
return *new_entry;};

int main (void)
{struct entry n1, n2, n3,n4,n5,list_head;
struct entry *list_pointer;
n1.value = 100;
list_head.next=&amp;n1;

n4=insertentry(&amp;n5,&amp;list_head);
list_pointer=&amp;n4;
n1.next = &amp;n2;
n2.value = 200;
n2.next = &amp;n3;
n3.value = 300;

n3.next = (struct entry *) 0; // Mark list end with null pointer
while ( list_pointer != (struct entry *) 0 ) {
printf (""%i\n"", list_pointer-&gt;value);
list_pointer = list_pointer-&gt;next;
}
printf(""%i\n"",n5.value);


getch();
return 0;
} 
</code></pre>
",1
38185797,38185741,4,"<p><code>total</code> is not initialized here. You need to set it to <code>0</code>:</p>

<pre><code>float total = 0;
</code></pre>
",2
38185855,38185741,3,"<p><code>float total</code>;</p>

<p>is unititialized, so you are invoking <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow"">Undefined Behavior</a></p>

<p>Change it to.</p>

<pre><code>float total = 0;
</code></pre>
",0
42471182,42464164,1,"<p>It depends on the output device (terminal), and on how many characters are being erased. Typically, if the device supports an Erase-to-EOL in the first place, it's there because it's faster than doing more than one or two Erase-Single-Character operations.</p>

<p>Unless you're operating over a very slow connection, it probably doesn't matter. Back in the '80s this sort of thing was something of a concern because we were often working over 1200bps connections and the like; that's also why people often eschewed curses(3) and went right to termcap. These days, both communications and output devices are typically so much faster than users' reaction times you can often get away with redrawing the screen entirely.</p>

<p>Out of curiosity, why use termcap at all? It was superseded by terminfo on most UNIXy platforms decades ago. Not to mention the availability of higher-level libraries like curses.</p>
",2
35219643,35218641,3,"<p><strong>Declarators</strong> are the <strong>components of a declaration</strong> that specify names of objects or functions. Declarators also specify whether or not the named object is an object, pointer, reference or array. While declarators do not specify the base type, they do modify the type information in the basic type to specify derived types such as pointers, references, and arrays. Applied to functions, the declarator works with the type specifier to fully specify the return type of a function to be an object, pointer, or reference.Reference link <a href=""https://msdn.microsoft.com/en-us/library/tb971bed.aspx"" rel=""nofollow"">Here.</a>Which is provide more information about Declarators.</p>

<p>Declarators for Pointers</p>

<pre><code>int *i; // declarator is *i
int **i; // declarator is **i;
</code></pre>
",0
35219656,35218641,5,"<p><strong>Declaration in C</strong></p>

<hr>

<p>In C the syntax for a <em>declaration</em> is of the form:</p>

<pre><code>declaration-specifiers declarator
</code></pre>

<p><strong>declarator</strong> are variables or functions or pointers and basically correspond to the name of the object declared.</p>

<p><strong>specifiers</strong> can be <code>type specifiers</code> like <code>int, unsigned, etc.</code> or <code>storage class specifier</code> like <code>typedef, extern, static</code> or <code>type qualifiers</code> like <code>const, volatile, etc.</code></p>

<p>For example in the following declaration:</p>

<pre><code>typedef long double DBL;
</code></pre>

<p>We have introduced a new type name <strong>DBL</strong> which is an alias for <code>long double</code> and we have:</p>

<ol>
<li><strong>typedef</strong>: storage class specifier</li>
<li><strong>long double</strong>: type specifier</li>
<li><strong>DBL</strong>: declarator</li>
</ol>

<p>When you use typedef you are basically aliasing a type specifier with a new name. If you typedef a struct like in the following:</p>

<pre><code>typedef struct {
   int a;
   int b;
} mystruct;
</code></pre>

<p>Then you can specifiy the type of a variable to be <strong>mystruct</strong>, like in the following declaration:</p>

<pre><code>mystruct c;
</code></pre>

<hr>

<p>Related posts:
<a href=""https://stackoverflow.com/questions/13808932/what-are-declarations-and-declarators-and-how-are-their-types-interpreted-by-the"">What are declarations and declarators and how are their types interpreted by the standard?</a> and
<a href=""https://stackoverflow.com/questions/20426716/how-do-i-use-typedef-and-typedef-enum-in-c"">How do I use typedef and typedef enum in C?</a> and
<a href=""https://stackoverflow.com/questions/13092620/declaration-specifiers-and-declarators"">Declaration specifiers and declarators</a></p>
",0
36289587,36289512,1,"<p><code>free()</code> just marks the memory as available (as in, it can be used for further allocations). It does not removes the content of the memory. </p>

<p>That said, <strong>you should not access the content of a <code>free</code>d memory, as it is <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow"">Undefined Behavior</a>.</strong></p>
",2
41906134,41906118,1,"<p>You need to have a nested for loop, this means a for loop within your for loop for the repetitive display of characters. </p>

<pre><code>            int a = 0;
            int b = 1;
            int c = 0;
            for (int i = 0; i &lt; 10; i++){
                c = a + b;
                a = b;
                b = c;
                for(int x = 0; x &lt; c; x++) {
                    System.out.print(c);
                }

                System.out.print("" "");
            }
</code></pre>
",3
37400667,37400392,2,"<p>Basically it's the n number of bytes from one place to some other place in the file.</p>

<p>This could actually mean different things for different file formats:</p>

<p>Eg, the offset of the data after the beginning of the section header,
Or, the offset from of that section from the beginning of the file,
Etc...etc....</p>

<p>You're going to have to check the spec for the file format that you're using.</p>
",0
42659794,42658300,0,"<p>There are a large number of ways to approach the problem. You can use <code>scanf</code> with character classes as shown, or you can use any other method to read the input (e.g. <code>getchar</code>, <code>fgets</code>, POSIX <code>getline</code>) and then simply analyze the characters entered for anything other than <code>""ACGT""</code>.</p>

<p>Additionally, in your problem statement you state ""<em>The user just keeps entering the sequence not more than 250 characters</em>"". Obviously you will need to loop to handle entry of multiple strings, but beyond that, you will also need to protect against and handle the remainder of any strings greater than <code>250</code> characters. It is unclear whether in that case, you want to keep the first 250 valid characters entered (seems logical you would), and then discard any over the 250 character limit.</p>

<p>Your tools for validating the input are, in the case of using <em>character-oriented</em> input (e.g. using <code>getchar</code>) are simply to check each character input against your <code>ACGT</code>. When using <em>line-oriented</em> input, (e.g. <code>fgets</code> or <code>getline</code>) the C library provides a number of tools to check for characters within a string, or substrings within a string (<code>strchr</code> is applicable here) or you can simply walk a pointer down the entire string of input checking each character. (you also need to check for, and remove the <code>'\n'</code> the line-oriented functions read <em>and include</em> in the buffer)</p>

<p>Putting the pieces together into a short example using <code>fgets</code> for input and <code>strchr</code> to check whether each character is one of <code>ACGT</code>, you could do something like the following. Here the user can enter as many strings as desired. The program terminates when <code>EOF</code> is read (manually generated with <kbd>Ctrl + D</kbd> on Linux, <kbd>Ctrl + Z</kbd> on windoze). In the event an invalid string is entered, the code identifies the position of the first invalid character in the entry:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define MAXC 250

int main (void) {

    char str[MAXC+1] = """", *valid = ""ACGT"";

    printf (""Enter sequences [ctrl+d] to quit:\n"");
    while (fgets (str, MAXC+1, stdin))          /* read input */
    {
        size_t len = strlen (str), good = 1;    /* get length, set flag */
        char *p = str;                          /* pointer to str */
        int c;

        if (str[len-1] == '\n')                 /* trim '\n' char */
            str[--len] = 0;                     /* overwrite with nul */
        else                                    /* line &gt; 250, discard extra */
            while ((c = getchar()) != '\n' &amp;&amp; c != EOF) {}

        for (; *p; p++)                         /* for each char in str */
            if (!strchr (valid, *p)) {          /* check against valid  */
                good = 0;                       /* not found - invalid */
                break;
            }

        if (good)
            printf (""VALID\n"");
        else
            fprintf (stderr, ""INVALID ('%c' at character '%ld'\n"", *p, p - str);
    }

    return 0;
}
</code></pre>

<p><strong>Example Use/Output</strong></p>

<pre><code>$ ./bin/acgtvalid
Enter sequences [ctrl+d] to quit:
ACGTTTGGCCCATTAGGC
VALID
ACCGGTTCCGGAITT
INVALID ('I' at character '12')
</code></pre>
",0
42658525,42658300,1,"<p>like this</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void){
    char dna[250+1], rest;
    if(scanf(""%250[ACGT]%c"", dna, &amp;rest) == 2 &amp;&amp; rest == '\n')
        printf(""VALID sequence \n"");
    else
        printf(""INVALID sequence \n"");
}
</code></pre>
",2
35213102,35212840,1,"<p>Your process gets killed by the <em>OOM-Killer</em> (Out of memory).</p>

<p><code>static double vectors[100000][10000]</code> needs about 100000*10000*8 bytes of memory, which makes about 8GB. This memory is not physically allocated until something is written to it (memory overcommitment). If you <code>fork()</code> n times and write to these pages in each process, the memory needed is about n*8GB, which quickly exceeds your physical memory + swap, I assume. <code>dmesg</code> should show you a message regarding this.</p>

<p>A solution is, to create a shared map with <code>mmap()</code> before <code>fork()</code>ing and make all processes work on the same array (if that is what you need):</p>

<pre><code>double *vectors = mmap(NULL, 10000*100000*sizeof(double), 
                       PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);
</code></pre>

<p>and instead of</p>

<pre><code>vectors[a][b]
</code></pre>

<p>access</p>

<pre><code>vectors[a*10000+b]
</code></pre>
",7
34895128,34891301,0,"<p>To compare dates, you can use <code>difftime()</code> function; first convert the dates to a correct format by <code>strptime()</code>:</p>

<pre><code>bool check_expired(const char *date, const char *expdate)
{
    struct tm tm_date, tm_expdate;

    if (strptime(date, ""%d %b %Y"", &amp;tm_date) == NULL
        || strptime(expdate, ""%d %b %Y"", &amp;tm_expdate) == NULL) {
        // wrong format, count as expired
        printf(""strptime failed\n"");
        return true;
    }

    return difftime(mktime(&amp;tm_date), mktime(&amp;tm_expdate)) &lt; 0;
}
</code></pre>

<p>To compare records, for performance reasons the best idea usually is to read the file once and then keep all the records in memory, in an array.</p>

<p>If it is not possible or not desired, this logic should work: read the file line-by-line. Keep a current record and fill it until all fields have been filled. Then do the SSN check; it it matches, compare the dates and break the file-reading loop. Assuming a record is always 6 non-empty lines:</p>

<pre><code>#define _XOPEN_SOURCE
#include &lt;time.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdbool.h&gt;

// ...

void member_exp()
{
    FILE *membership;
    struct MembershipInfo_t member;
    char line[256];
    char ssncheck[20];
    char tmp1[20], tmp2[20];
    int record_line = 0;

    membership = fopen(""MembershipRecord.DAT"", ""rb"");

    printf(""Please enter social security number\n"");
    if (scanf(""%20s"", ssncheck) != 1) {
        return;
    }

    while (fgets(line, sizeof(line), membership)) {
        // check if the line is whitespace only
        char *p = line;
        bool is_spaces_only = true;
        while (*p) {
            if (!isspace(*p)) {
                is_spaces_only = false;
                break;
            }
            p++;
        }
        if (is_spaces_only) {
            continue;
        }

        switch (record_line) {
        case 0:
            sscanf(line, ""%s %s"", member.cust_lname, member.cust_fname);
            break;
        case 1:
            sscanf(line, ""%s"", member.memtype);
            break;
        case 2:
            // TODO
            break;
        case 3:
            sscanf(line, ""SSN: %s"", member.ssn);
            break;
        case 4:
            // TODO
            break;
        case 5:
            sscanf(line, ""%20s %20s %20s"", member.date, tmp1, tmp2);
            strcat(member.date, "" "");
            strcat(member.date, tmp1);
            strcat(member.date, "" "");
            strcat(member.date, tmp2);
            break;
        case 6:
            sscanf(line, ""Expiration Date: %20s %20s %20s"", member.expdate, tmp1, tmp2);
            strcat(member.expdate, "" "");
            strcat(member.expdate, tmp1);
            strcat(member.expdate, "" "");
            strcat(member.expdate, tmp2);
            break;
        }

        record_line++;
        if (record_line &gt; 6) {
            if (!strcmp(member.ssn, ssncheck)) {
                printf(""record found. it is %sexpired\n"",
                        check_expired(member.date, member.expdate) ? ""not "" : """");
                break;
            }
            record_line = 0;
        }
    }

    fclose(membership);
}
</code></pre>
",0
36394225,36394136,2,"<pre><code>scanf(""%d"",&amp;array[rows][columns]);
</code></pre>

<p>You are using <code>%d</code> to scan into <code>float</code>, which is undefined behaviour. You need to use <code>%f</code> instead. Also, you should check the return value of <code>scanf</code> to ensure it has successfully scanned something. <code>scanf</code> returns the number of items successfully scanned, so in your case it should return 1. If there was no suitable input, it will return 0, or if there was an error reading the input, it will return <code>EOF</code>.</p>

<p>For example, you could have:</p>

<pre><code>if (scanf(""%f"", &amp;array[rows][columns]) != 1)
{
    fprintf(stderr, ""Unable to read input\n"");
    return 1;
}
</code></pre>
",1
34972576,34972513,8,"<p>You will recurse infinitely.  You need a small adjustment [please pardon the gratuitous style cleanup]:</p>

<pre><code>#include &lt;stdio.h&gt;

int
power(int x, unsigned int y)
{
    //int temp = power(x, y / 2);

    if (y == 0)
        return 1;

    int temp = power(x, y / 2);

    if (y % 2 == 0)
        return temp * temp;
    else
        return x * temp * temp;
}

// Driver function
int
main(int argc,char **argv)
{
    int u;
    unsigned int v;

    printf(""Enter the value of u and v"");
    scanf(""%d %u"", &amp;u, &amp;v);

    printf(""%d\n"", power(u, v));

    return 0;
}
</code></pre>
",2
39382888,39363009,0,"<p>If you want to test for some combination of <code>BIT_A</code> and <code>BIT_B</code> (or whatever number of bits you can have) You can do this:</p>

<pre><code>#define BIT_A (1 &lt;&lt; 3)
#define BIT_B (1 &lt;&lt; 5)
...
#define BIT_Z (1 &lt;&lt; Z)

...
/*      |here you put all bits           |here you put only the ones you want set */
/*      V                                V                                               */
if (a &amp; (BIT_A | BIT_B | ... | BIT_Z) == (BIT_A | ... | BIT_I | ...))
{
    /* here you will know that bits BIT_A,..., BIT_I,... will **only**
     * be set in the mask of (BIT_A | BIT_B | ... | BIT_Z) */
} 
</code></pre>

<p>as with <code>a &amp; (BIT_A | BIT_B | ... )</code> you force all bits not in the set to be zero, so only the bits in the set will conserve their values.  With the second mask, you generate a bitmap with only the bits of the set you want to be set (and of course the bits that are not in the set forced zero) so if you compare both values for equalness, you'll get the expected result.</p>

<h1>NOTE</h1>

<p>As an answer to your question, the particular case in which you want all the bits equal to one, is to make both masks equal.  For your case, you want to check if <strong>both bits are zero</strong>, then your test is (the second mask has no bits set, so it is zero):</p>

<pre><code>if (a &amp; ((1 &lt;&lt; 3) | (1 &lt;&lt; 5)) == 0) { ...
</code></pre>

<p>(All bits in the second mask are zero as the required mask, and both, the third and the fifth bits are set in the first mask)  This can be written in a more compact form as (you can see it written as):</p>

<pre><code>if (!(a &amp; 0x28)) { /* 0x28 is the octal for 00101000, with the bits you require */
</code></pre>

<h1>WHY THE CODE YOU WROTE IS NOT CORRECT</h1>

<p>First you mix logical operators like <code>!</code> with bitmasks, making <code>!(1&lt;&lt;3)</code>to eval to <code>0</code> (<code>1&lt;&lt;3</code> is different of <code>0</code> so it is true, negating gives <code>0</code>) and the same for the <code>!(1&lt;&lt;5)</code> subexpression.  When you mask a with those values makes you get <code>a &amp; 0 ==&gt; 0</code> and <code>a &amp; 0 ==&gt; 0</code> and anding both together gives <code>0 &amp;&amp; 0 ==&gt; 0</code>. So the result value of your expression is <code>0 -- false</code> always, independent of the original value of <code>a</code>.</p>
",0
34891253,34891181,2,"<p>The first choice is much better:</p>

<pre><code>for (int i = 0; i &lt; 100; i++) { }
</code></pre>

<p>The alternative is sometimes encouraged by local coding rules, it is a bad recommendation:</p>

<ul>
<li>it tends to generate more code if you use <code>i</code> in the loop body as an index or in an expression.</li>
<li>it can also lead to more bugs especially if you later modify your code and the upper boundary exceeds 255 and is read from a <code>unsigned</code> variable.</li>
<li>a good embedded compiler will take advantage of the small range if it is pertinent anyway.</li>
</ul>

<p>Embedded systems have plenty of resources nowadays, but if you are targeting a very limited chipset, you may want to check both alternatives and make an informed decision.</p>
",0
34891238,34891181,0,"<p>depends on the chip you are targeting</p>

<p>on an 8bit chip, it could make a difference using an 8bit type, however even on an 8 bit chip they often have one register that is of a bigger size.  </p>

<p>In some cases it might help with stack usage.</p>

<p>In general I suggest using a unsigned for a loop anyways, but it's up to you to make informed choices on the bit width you need.</p>
",5
34891350,34891181,1,"<p>Use <code>int</code>. Just use <code>int</code>. That's what it's for. If you had to think about and pick the size in bits for every variable, that'd be a nuisance, that'd indicate you were using a poor language, that wasn't doing its job.  It would be as bad as if you had to pick the machine instructions to evaluate every expression you wrote. But C is a good language. Let it generate your code efficiently. Let it worry about the exact sizes of variables when you don't care, which ought to be most of the time. Just use <code>int</code>.</p>
",1
34891645,34891181,0,"<p>Use a pointer to array type and use post increment per loop. Then define magic number as constant plus max offset for sizeof() to array limit. Store address once per instantiating.   </p>

<p>If you are over thinking it then you may as well go to assembly. </p>

<p>Or you can apply the unix philosophy and get it working.  Optimization is another step. </p>
",0
37201515,37201384,3,"<p>There are two approaches to this. If what you described is all you want to do, then you can use the <a href=""http://www.dyncall.org/"" rel=""nofollow"">dyncall library</a> so that you dont have to worry about platform/compiler-specific calling semantics yourself:</p>

<blockquote>
  <p>The dyncall library encapsulates architecture-, OS- and compiler-specific function call semantics in a virtual bind argument parameters from left to right and then call interface allowing programmers to call C functions in a completely dynamic manner. In other words, instead of calling a function directly, the dyncall library provides a mechanism to push the function parameters manually and to issue the call afterwards.</p>
</blockquote>

<p>The other approach is, if you might want to do more: e.g. what if an argument cannot be created by a literal? What if the argument is the output of another function? Can you write <code>f(123, g(""a""))</code> in your console? Can you write <code>x=g(""a""); f(x)</code>? And <code>if(cond) x=""a"" else x=""b""; f(x)</code> In this case you need to embed a scripting language like e.g. LUA.</p>
",0
37203457,37201384,0,"<p>If you compile your binary with debug information, you can extract it using libdwarf (<a href=""https://www.prevanders.net/dwarf.html"" rel=""nofollow"">https://www.prevanders.net/dwarf.html</a>), so for every function you can get a list a parameters with types and you would know how to interpret user's input.</p>
",1
34939505,34939441,2,"<p><strong>1.</strong> You should write this loop (<em>so as to check return of</em> <code>fscanf</code> ) ¡ª</p>

<pre><code>  for (c=0;c&lt;i;c++)
  {
    fscanf(fp,""%s"",a[c].b);
  }
</code></pre>

<p>as ¡ª</p>

<pre><code>c=0;
while (fscanf(fp,""%29s"",a[c].b) == 1 &amp;&amp; c&lt;i){
 ...
 c++;
}
</code></pre>

<p><strong>2.</strong> Also <code>while(!feof(fp))</code> is wrong, so instead use <code>fscanf</code> to control the loop ¡ª</p>

<pre><code>while (fscanf(fp,""%29s"",k)==1)
  i++;
</code></pre>

<p><strong>Note</strong> ¡ª And, just to avoid confusion, give different names to your structure member and structure.</p>
",0
34956874,34939441,0,"<p>after applying all the comments, the resulting code is:</p>

<pre><code>#define _GNU_SOURCE
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;



int main( void )
{
    char **lines = NULL;
    size_t lineCount = 0;
    FILE *fp = NULL;

    if ((fp=fopen(""translate.txt"",""r""))==NULL)
    {
       perror(""¦²¦Õ?¦Ë¦Ì¦Á ¦Ê¦Á¦Ó? ¦Ó¦Ï ?¦Í¦Ï¦É¦Ã¦Ì¦Á ¦Ó¦Ï¦Ô ¦Á¦Ñ¦Ö¦Å?¦Ï¦Ô\n"");
       exit( EXIT_FAILURE );
    }


    char * inputBuf = NULL;
    size_t inputLen = 0;

    while( getline( &amp;inputBuf, &amp;inputLen, fp ) )
    {
        lineCount++;
        char **tempLines = realloc( lines, (lineCount+1)*sizeof( char*) );
        if( !tempLines )
        { // then realloc failed
            perror( ""realloc failed"");
            free( lines );
            exit( EXIT_FAILURE );
        }

        lines = tempLines;
        lines[lineCount] = strdup( inputBuf );
        lineCount++;
    }

    fclose(fp);
    free( lines );
    return 0;
} // end function: main
</code></pre>

<p>however, this code is not very efficient as it repeatedly calls <code>realloc()</code></p>

<p>To fix that, initially allocate enough room in <code>lines[]</code> for several lines, say 10, then keep a count of how many of those pointers are being used. </p>

<p>When all the allocated pointers are used and need to add another line, then double the allocation via <code>realloc()</code>. </p>
",0
34976568,34976505,4,"<p>For the first look, I suppose that root of problem is in the following lines:</p>

<pre class=""lang-cpp prettyprint-override""><code>  int *p;
  p = (int *)malloc(20000 * sizeof(int));
  p = primeslessthan(20000);
</code></pre>

<p>I see, that after allocation made with <code>malloc</code>, pointer <code>p</code> is rewritten with value returned by <code>primeslessthan</code>. So, check that code carefully</p>
",0
34976639,34976505,0,"<p>Change your function declaration to:</p>

<pre><code>void primeslessthan(int n, int *pr)
</code></pre>

<p>Remove <code>pr</code> redeclaration from its code. Change the call to</p>

<pre><code>primeslessthan(20000, p);
</code></pre>

<p>This way it should work.</p>
",0
34977471,34976505,0,"<p>i see that your function doesn't return <code>int*</code>, and your are using this value in the ain in :
<code>p = primeslessthan(20000);</code></p>
",0
38992412,38992147,2,"<p>Endianness doesn't affect the order of the members.</p>

<p>From N1570 6.7.2.1 Structure and union specifiers:</p>

<blockquote>
  <ol start=""6"">
  <li>As discussed in 6.2.5, a structure is a type consisting of <strong>a sequence of members, whose
  storage is allocated in an ordered sequence</strong>, and a union is a type consisting of a sequence
  of members whose storage overlap.</li>
  </ol>
</blockquote>

<p>There might be padding bytes in between the members and at the end of structure though.</p>
",0
38992325,38992147,5,"<p><a href=""https://en.wikipedia.org/wiki/Endianness"" rel=""nofollow"">Endianness refers to the order of the bytes comprising a <strong>digital word</strong> in computer memory</a></p>

<p>C <code>struct</code> is NOT a <em>digital word</em> (it is not an entity with which CPU deals), so the answer is no, endianness does not affect how structure members are stored into the memory</p>

<p>What does affect how structure members are stored into the memory is <a href=""https://en.wikipedia.org/wiki/Data_structure_alignment"" rel=""nofollow"">Data structure alignment</a>, which may add some padding between members to align member address to make it equal to some multiple of the word size</p>
",2
38992330,38992147,5,"<p>Endianness is not a factor in the process of deciding offsets of <code>struct</code> members. The initial member will always be allocated at offset zero; the remaining members will be allocated at higher offsets in the order they appear in the <code>struct</code> declaration.</p>

<p>System-independent way to code your program is as follows:</p>

<pre><code>struct {
    uint32_t i;
    uint32_t i2;
}s;
intptr_t p = (intptr_t)&amp;s;
intptr_t pi = (intptr_t)&amp;s.i;
intptr_t pi2 = (intptr_t)&amp;s.i2;
printf(""%tu %tu\n"", pi-p, pi2-p);
</code></pre>

<p><a href=""http://ideone.com/q6gypJ"" rel=""nofollow"">Demo 1.</a> <code>intptr_t</code> lets you treat pointers as if they were integers; <code>%tu</code> format specifier prints <code>ptrdiff_t</code> values as unsigned numbers.</p>

<p>You can also do it like this:</p>

<pre><code>struct S {
    uint32_t i;
    uint32_t i2;
};
printf(""%tu %tu\n"", offsetof(struct S, i), offsetof(struct S, i2));
</code></pre>

<p><a href=""http://ideone.com/cTaYbQ"" rel=""nofollow"">Demo 2</a>.</p>
",0
38992361,38992147,1,"<p>Endianness refers to the order of bytes within the processor's natural types: <code>integers</code> and <code>floats</code>. The top element in a <code>struct</code> will always come first in memory regardless of endianness. You do have to mind out for the gaps as usually structs are padded (byte aligned) dependant on compiler etc. </p>
",0
38992386,38992147,0,"<p>Structure members' layout is implementation dependent, so it can vary between compilers' brands, chosen optimization modes and destination architectures. Generally, though, the endiannes alone is the order of bytes in multi-byte types (like <code>int32</code>), so it shouldn't affect the order of multi-byte chunks of data.</p>
",0
42490890,29768610,0,"<p><code>_iobuf::_file</code> can be used to get the internal file number, useful for functions that require the file no. Ex: <code>_fstat()</code>.</p>
",1
34987114,34986405,1,"<p>It goes like this:</p>

<pre><code>#include &lt;stdbool.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define BUFFER_SIZE 256

int main ()
{
    int16_t i;                                                                                                                                                         
    char buffer[BUFFER_SIZE];

    while (NULL != fgets(buffer, sizeof(buffer), stdin)) {
        sscanf(buffer, ""%[^\n]"", buffer);

        uint8_t len = strlen(buffer);
        uint8_t numbers[BUFFER_SIZE] = {0};

        for (i = 0; i &lt; len; i++) {
            numbers[len - 1 - i] = buffer[i] - '0';
        }

        bool high = false;
        for (i = BUFFER_SIZE - 1; i &gt;= 0; i--) {
            high = high || (0 != numbers[i]);

            if (high) {
                printf(""[%d] =&gt; %d\t"", i, numbers[i]);
            }
        }

        putchar('\n');
    }   

    return EXIT_SUCCESS;
}
</code></pre>

<p>content of input <code>numbers.txt</code>:</p>

<pre><code>54673
1245841
326987
</code></pre>

<p>Then you can run your program like this:</p>

<pre><code>./app &lt; numbers.txt
</code></pre>
",0
34986510,34986405,2,"<p>1) Using command line argument pass file name to your c program. study this <a href=""http://www.tutorialspoint.com/cprogramming/c_command_line_arguments.htm"" rel=""nofollow"">http://www.tutorialspoint.com/cprogramming/c_command_line_arguments.htm</a></p>

<p>2) 
then in your c program open that file and read input.</p>
",1
37397636,37397514,0,"<p><code>50!</code> is a very large number (over 60 digits) and <code>2^64</code> is less than <code>50!</code>. The reason that you don't get the right number is that you get <a href=""https://en.wikipedia.org/wiki/Integer_overflow"" rel=""nofollow"">overflow</a>, you are counting above the limit of what your computer can calculate. </p>

<pre><code>enter n 50
-3258495067890909184
</code></pre>

<p>If you have a 64-bit integer, the largest value it can represent is 2^64 which I is smaller than 50!. Therefore you get overflow. </p>

<p>Normally in these situations you resort to some trick, similar to a 4-bit system running 8-bit code by doubling the number of instructions per word (the way <a href=""https://en.wikipedia.org/wiki/Intel_4004"" rel=""nofollow"">Intels first CPU</a> had 8-bit code). </p>

<p>So your 64-bit system actually can handle 128-bit words, you just have to write an algorithm that puts the data in ""chunks"" so that you can double your word length. </p>
",1
37397676,37397514,0,"<p>It will not go with standard C types, you need something else(maybe string) . Please look at <a href=""http://onlinemschool.com/math/formula/factorial_table/"" rel=""nofollow"">http://onlinemschool.com/math/formula/factorial_table/</a></p>

<p>As you can see, it is quite big number. </p>
",0
37398354,37397514,1,"<p><code>50!</code> is <code>30414093201713378043612608166064768844377641568960512000000000000</code> or about <code>3.04e+64</code>, a 215-bit number.   This value typically exceeds the range of types such as <code>long</code>.  Even <code>uintmax_t</code> and <code>unsigned long long</code> need only to needs to be able to represent at least 64-bit integers.</p>

<pre><code>long int fact(long int n) {
  ...
  // Overflows!
  return n*fact(n-1);
</code></pre>

<p>To get an exact answer, code could use alternate types.  The following uses a string/decimal representation of a integer.  It works for large values of <code>n</code> as correct functionality being limited by the buffer size.</p>

<pre><code>char *strfact_mult(char *s, unsigned x) {
  unsigned sum = 0;
  size_t len = strlen(s);
  size_t i = len;
  while (i &gt; 0) {
    sum += (s[--i] - '0')*x;
    s[i] = sum%10 + '0';
    sum /= 10;
  }
  while (sum) {
    len++;
    memmove(&amp;s[1], s, len);
    s[i] = sum%10 + '0';
    sum /= 10;
  }
  return s;
}

char *str_fact(char *dest, unsigned n) {
  strcpy(dest, ""1"");
  while (n &gt; 1) {
    strfact_mult(dest, n--);
  }
  return dest;
}

int main(void) {
  char buf[1000];
  puts(str_fact(buf, 0));
  puts(str_fact(buf, 1));
  puts(str_fact(buf, 5));
  puts(str_fact(buf, 50));
}
</code></pre>

<p>Output</p>

<pre><code>1
1
120
30414093201713378043612608166064768844377641568960512000000000000
</code></pre>
",2
36607827,36607751,3,"<p>No, this is not the right way of doing the <code>free</code>, because you set the pointer to be freed to <code>NULL</code> <em>before</em> actually freeing it. You should do it the other way around:</p>

<pre><code>free(a-&gt;array);  // Free the memory
a-&gt;array = NULL; // Clear out a dangling pointer
</code></pre>

<p>The pattern with an empty conditional branch is questionable, too. Rather than doing</p>

<pre><code>if(a-&gt;array){
}
else{
    printf(""OUT OF MEMORY !!!\n\r"");
}
</code></pre>

<p>you should do</p>

<pre><code>if(!a-&gt;array){
    printf(""OUT OF MEMORY !!!\n\r"");
}
</code></pre>

<p>You should also set <code>a-&gt;size</code> to zero when the allocation fails (currently your code falls through to the case that sets size to <code>initialSize</code> even on a failed allocation):</p>

<pre><code>if(!a-&gt;array){
    printf(""OUT OF MEMORY !!!\n\r"");
    a-&gt;used = 0;
    a-&gt;size = 0;
    return;
}
</code></pre>
",0
36607848,36607751,2,"<p>That <code>freeArray</code> uses the wrong order. It first sets <code>a-&gt;array</code> to <code>NULL</code>, then tries to <code>free</code> a <code>NULL</code> pointer. This doesn't work. You need to swap the first two lines in the function: first <code>free</code>, then set the pointer to <code>NULL</code>.</p>

<pre><code>void freeArray(Array *a) {
   free(a-&gt;array);
   a-&gt;array = NULL;   
   a-&gt;used = 0;
   a-&gt;size = 0;
}
</code></pre>
",0
36607864,36607751,2,"<p>When you do this:</p>

<pre><code>void freeArray(Array *a) {
   a-&gt;array = NULL;    
   free(a-&gt;array);
   a-&gt;used = 0;
   a-&gt;size = 0;
}
</code></pre>

<p>You are first assigning NULL to the pointer, let's see what happens when you call free with a NULL pointer looking some <a href=""http://en.cppreference.com/w/c/memory/free"" rel=""nofollow"">documentation</a>:</p>

<blockquote>
  <p>void free( void* ptr ); Deallocates the space previously allocated by
  malloc(), calloc(), aligned_alloc, (since C11) or realloc(). If ptr is
  a null pointer, the function does nothing.</p>
</blockquote>

<p>So nothing happens, you're not deallocating anything, you are creating a memory leak as you don't have the reference to the memory anymore.</p>

<p>To make it works you just need to change the order and set NULL after</p>

<pre><code>void freeArray(Array *a) {
   free(a-&gt;array);
   a-&gt;array = NULL;    
   a-&gt;used = 0;
   a-&gt;size = 0;
}
</code></pre>
",0
43216557,43216363,0,"<p>I put all your logic in one file, and add simple main:</p>

<pre><code>int main()
{
    push(4.0);
    push(3.8);
    sum();
    return 0;
}
</code></pre>

<p>Then compile all as <code>gcc main.c</code>. And it works fine:</p>

<blockquote>
  <p>Pop:3.800000<br>
  Pop:4.000000<br>
  num1:3.800000 num2:4.000000 sum:7.800000  </p>
</blockquote>

<p>Are you sure that you really normally link your project (and break your code to some modules)? Can you put more information about how you compile your version?<br>
P.S. You have all good in program logic</p>

<p><strong>Update</strong><br>
You need to add <code>Stack.h</code> file with the same text:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void push(double n);
double pop(void);
void display(void);
</code></pre>

<p>In <code>Stack.c</code> remove this code and add <code>#include ""Stack.h""</code> in the first line.<br>
In <code>Main.c</code> only add <code>#include ""Stack.h""</code> in the 6 line (just after system <code>#include</code> directives).<br>
Don't change your makefile. It's not required.</p>

<p>With regards,<br>
AJIOB</p>
",3
37202549,37202015,2,"<p>There is a limit of array allocation, the size u are trying causes <strong>stack overflow</strong> of the function, because your array can't fit into the memory allocated to the function <strong>stack</strong>.</p>

<p>There is a limit of <strong>8MB</strong> on the maximum size of objects, due to internal compiler implementation limits.
You should use <strong>malloc()</strong> to create large arrays instead.</p>
",3
37202352,37202015,2,"<p>See if this helps</p>

<pre><code>char **a;
int i;

a = malloc(700000 * sizeof(char*));
for (i = 0; i &lt; 700000; i++) {
    a[i] = malloc(120*sizeof(char));
}

// read file here instead
strcpy(a[0],""hello"");
strcpy(a[1],""goodbye"");
strcpy(a[2],""yes"");

for (i=0;i&lt;=3;i++) {
    printf(""%s\n"",a[i]);
}
</code></pre>

<p>Per Michi, remember to free the memory afterwards.</p>

<pre><code>for (i = 0; i &lt; 700000; i++) {
    free(a[i]);
}
free(a);
</code></pre>

<p><strong>Appendix</strong> Turns out you can check the stack size AND change it. Consider this</p>

<pre><code>struct rlimit rl;
int result;

result = getrlimit(RLIMIT_STACK, &amp;rl);

printf(""stack limit %d\n"", rl.rlim_cur);
printf(""stack limit %d\n"", rl.rlim_max);
return 0;
</code></pre>

<p>It gives me</p>

<pre><code>stack limit 8388608
stack limit -1
</code></pre>

<p>(there is the 8MB).</p>
",1
37202374,37202015,0,"<p>I think there is no need of creating <strong>str</strong> variable, you could have used the <strong>a</strong> itself. Moreover as mentioned in the comments too, try using dynamic memory, as most programmers don't use stack for huge allocations. May be heap may have greater size than stack. </p>
",0
37202844,37202015,0,"<p>In Linux Environment, ulimit -s can return the stack size.</p>

<pre><code>root@ubuntu:# ulimit -s
8192
</code></pre>

<p>It means the max stack space that the system support is <strong>8192 KB</strong>, that is <strong>8MB</strong>. test program as follows, try to modify array size from 8*1024 to 7*1024.</p>

<pre><code>#include&lt;stdio.h&gt;

void test()
{
}

int main()
{
    char a[7*1024][1024];
    test();
    return 0;
}
</code></pre>
",0
37204301,37202015,0,"<p>You can try this.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

void main(void) {

    FILE *fp = NULL;
    fp = fopen(""read.txt"", ""rb"");
    if(fp == NULL)
        printf(""failure\n"");
    else
        printf(""success\n"");

    char buffer[4096];
    while (fgets(buffer, sizeof(buffer), fp) != 0)
        fputs(buffer, stderr);

}
</code></pre>
",0
44354297,44354255,2,"<p>Many floating point values do not have an exact representation in base 2.</p>

<p>You can try adding a very small value to push the value a little bit:</p>

<pre><code>int i = (change + 0.0001) * 100;    //converts dollars into cents
</code></pre>
",0
44354304,44354255,3,"<p>You have this behavior because of the way a <code>float</code> is represented.</p>

<p>In <a href=""https://en.wikipedia.org/wiki/IEEE_floating_point"" rel=""nofollow noreferrer"">IEEE 754</a>, <code>4.2</code> is actually stored as <code>4.19999980926513671875</code> so that when you multiply it by <code>100</code> and cast it back to an <code>int</code>, you get <code>419</code> (<em>i.e.</em> the integer part of the result).</p>

<p>A solution would be to use</p>

<pre><code>int i = (int) roundf(change * 100);
</code></pre>

<p>or</p>

<pre><code>int i = (int) lrintf(change * 100);
</code></pre>

<p>with <code>#include &lt;math.h&gt;</code>.</p>
",2
44354318,44354255,2,"<p>As you can see <a href=""https://www.h-schmidt.net/FloatConverter/IEEE754.html"" rel=""nofollow noreferrer"">here</a> when you store a value in a <code>float</code> the actual number stored is not always what you expected. This is due to how floats are represented in binary (you can learn more on <a href=""https://en.wikipedia.org/wiki/Floating-point_arithmetic"" rel=""nofollow noreferrer"">wiki</a>).</p>

<p>Now, as shown in the <a href=""https://www.h-schmidt.net/FloatConverter/IEEE754.html"" rel=""nofollow noreferrer"">1st link</a>, when you try to store <code>4.2</code> in change, you actually store <code>4.19...</code>. Multiply it by 100, store it inside an <code>int</code>,and you get 419.</p>

<p>Changing your <code>float</code> into <code>double</code> will give you better (<em>double</em>) precision, and in your case, it will yield the expected result</p>

<pre><code>double change; # float changed to double
do
{
    printf(""O hai! Enter amount in dollars to convert in cents.\n"");

    scanf(""%lf"",&amp;change);   //accepts input in dollars # ""%f"" changed to ""%lf""

} while(change &lt; 0.00);

int i = change * 100;    //converts dollars into cents

printf(""The equivalent cents are %d\n"",i);

input: 4.2
output: 420
</code></pre>

<p>on my machine.</p>

<p>Note that using <code>double</code> is not a fail-safe. It can also give misleading results, but it should behave better than <code>float</code>.</p>
",3
44354357,44354255,0,"<p>In this case that you know that the decimals for work with money are 2, I suggest that work with float representation with 3 decimals, and then the result must do round up to 2 decimals. Is important be carefully, because the working with money is very delicate.
Hope this help.</p>
",0
38403311,38403098,0,"<p>Firstly, you can typecast the malloc allocated space to (int *) as by default malloc allocates space as (void *).
SEcondly, you are running the loop j=0 to 8 i.e 9 times however u have allocated space for just 8.Hence you have a kindof array index out of bounds error</p>
",2
38403237,38403098,3,"<p>Insufficient memory allocated.</p>

<pre><code>int *m=malloc(sizeof(int)*8);  // 8 `int`
...
for(j=0;j&lt;9;j++){
  scanf(""%d"",&amp;m[j]);          // attempt to set the the 9th `int`, m[8]
</code></pre>

<p>Allocate sufficient memory.</p>

<pre><code>#define JSIZE 9
int *m=malloc(sizeof *m * JSIZE);
if (m == NULL) Handle_OutOfMemory();
...
for(j=0;j&lt;JSIZE;j++){
  if (scanf(""%d"",&amp;m[j]) != 1) Handle_BadInput();
</code></pre>
",0
41900206,41900151,23,"<p><code>a.out</code> is the default executable name generated by the <code>gcc</code>. Once you invoke <code>gcc a.out</code> (which you really shouldn't - as it is passing <code>a.out</code> as an <em>input</em> to <code>gcc</code>), it is trying to create a <em>new</em> <code>a.out</code>, but failing as it is trying to read the existing <code>a.out</code> as a <em>source</em> file, which it is not. This is what making it &quot;disappear&quot;.</p>
<p>If you want <code>gcc</code> to generate an executable with specific name, use the <code>-o</code> switch followed with the desired name:</p>
<pre><code>gcc hello.c -o hello
</code></pre>
<p>will generate the executable named <code>hello</code>, which can be run using</p>
<pre><code>./hello
</code></pre>
",9
41900404,41900151,2,"<p>In addition to the previous answer, I'd suggest you use </p>

<pre><code>gcc -o hello hello.c
</code></pre>

<p>This will create an executable called ""hello"" rather than the default ""a.out"". Of course you can call it whatever you want.</p>
",0
41900993,41900151,4,"<p><code>a.out</code> is the default executable, since you didn't tell GCC what to name it (by using <code>-o</code>). Just typing <code>a.out</code> won't run it, because it's in the current directory, and Linux doesn't put the current directory in the path like other broken OSes do, so you have to type <code>./a.out</code> to run it.</p>

<p>You later typed <code>gcc a.out</code>, which erased it, and tells gcc to try to compile the executable as if it were a C program, which makes no sense, so the <code>a.out</code> it produced is empty.</p>

<p>What you meant to do was:</p>

<pre><code>gcc hello.c
./a.out
</code></pre>

<p>Or even better:</p>

<pre><code>gcc -o hello hello.c
./hello
</code></pre>
",0
37918814,37918310,0,"<p>Change your ""judge"" function(which is actually calculating number of digits) as follows</p>

<pre><code>int judge(long n) {
    int length = 0;
    while (n!=0) {
       n = n/10;
       length++;
    } 
  return length;
}
</code></pre>

<p>I'm sure it will work</p>
",0
37918844,37918310,0,"<p>Your <code>judge</code> function is returning an incorrect value. In this function, you detect the no of digits of the number. It should return <code>1</code> for input <code>1</code> and <code>5</code> for input <code>40585</code>. It is returning <code>6</code> for the second input. </p>

<p>It should be changed as follows.</p>

<pre><code>int judge(long n)
{

  int length = 0;

  while (n &gt;= 1)
  {
    length++;
    n = n/10;
  }
  return length;
}
</code></pre>
",0
37919491,37918310,1,"<p>your judge function return wrong value.you can correct it using 2 ways. 1st approach</p>

<pre><code> int judge(long n)
 {
    int length = 0;
    while (n &gt; 0)
    {
            length++;
            n = n/10;
    }
    return length;
 }
</code></pre>

<p>Another approach is you take extra variables int size and char str[10].</p>

<pre><code> size = sprintf(str,""%d"",exact);     // find length of digit
 if (size == 1){              // check lenght of digit == 1 
</code></pre>

<p>both approaches return correct results. </p>
",0
35192534,35192412,0,"<p>Try looking at this post: <a href=""https://stackoverflow.com/questions/3501338/c-read-file-line-by-line"">C read file line by line</a></p>

<p>From there it should be a simple matter of counting lines read and discarding them until you have read <code>firstNum</code> lines at which point print until you've reached <code>secondNum</code>.</p>
",0
35192564,35192412,2,"<p>There are several issues with your code, so just go through them sequentially:</p>

<ul>
<li><p>It's better to use high level <code>fopen</code> rather than low level <code>open</code> to open a file. So it's better to write this way:</p>

<pre><code>FILE *file = fopen(argv[1], ""r"");
if (file == NULL)
    exit(EXIT_FAILURE);
</code></pre></li>
<li><p>Your <code>read</code> is wrong as it reads exactly 80 characters instead of a line as you expect.</p>

<pre><code>while ((size=read(file,l,80)) &gt; 0)   // &lt;-- WRONG because this reads 80 chars instead of one line
</code></pre></li>
<li><p>For similar reason as with <code>open</code>, it's better to use alternative like <code>printf</code> instead of low level <code>read</code> and <code>write</code>.</p></li>
<li><p>To read line by line, you should use library function <code>getline</code>.</p></li>
<li><p>To control what line number to print, a simple way is to have a variable tracking what line number and compare with your command line arguments.</p></li>
</ul>

<p>So put them together, you would need something like this:</p>

<pre><code>FILE *file = fopen(argv[1], ""r"");
if (file == NULL)
    exit(EXIT_FAILURE);

int line_num = 0;

char * line = NULL;
size_t len = 0;
ssize_t read = 0;
while ((read = getline(&amp;line, &amp;len, file)) != -1)
{
    line_num++;
    if( firstNum &lt;= line_num &amp;&amp; line_num &lt;= secondNum )
    {
        printf( ""line %d: %s"", line_num, line );
        if( line_num == secondNum )
            break;
    }
}
</code></pre>
",1
36664791,36664754,1,"<p>It should be <code>fp = fopen(str, ""r"");</code>, because <code>fopen()</code> expects <code>mode</code> as a <code>char *</code> pointing to a string, rather than a single <code>char</code>.</p>

<p>Also, since parameters in C are <strong>passed by value</strong>, your <code>fp</code> won't get modified after <code>openFile()</code> is called. To get it work, you'll have to rewrite it, and call it by <code>openFile(&amp;fp);</code>. Here is an example:</p>

<pre><code>void openFile(FILE **fp) {
    puts(""What's the name of the file (and format) to be accessed?"");
    char str[64];
    fgets(str, 64, stdin);
    str[strcspn(str, ""\n"")] = '\0';  
    *fp = fopen(str, ""r"");
}
</code></pre>

<p><code>fgets()</code> is used to provide buffer overflow protection.</p>
",0
36664823,36664754,2,"<p>The main problem is that you are trying to set an argument passed by value in a function and expect the value to be changed outside. This can't work.</p>

<p>Currently you have:</p>

<pre><code>void openFile(FILE* fp) {
  fp = ...
}

int main()
{
  FILE* fp;
  openFile(fp);
}
</code></pre>

<p>But <code>fp</code> in <code>main()</code> is passed as a pointer by value. Which means that inside <code>openFile</code> you are setting a local variable, while the passed one is not modified.</p>

<p>To solve the problem you can:</p>

<ul>
<li>directly return a <code>FILE*</code> from <code>openFile</code></li>
<li>accept a pointer to pointer argument to be able to set it, eg <code>void openFile(FILE** fp)</code> and then <code>openFile(&amp;fp)</code></li>
</ul>

<p>Mind that the second argument of <code>fopen</code> is a <code>const char*</code> not a single <code>char</code>, <code>""r""</code> should be used.</p>
",1
41652778,41652743,4,"<p>You forgot to allocate memory for the name member of the struct.  It is a pointer, but unless you malloc() some memory, you have no idea where it points to.</p>

<p>Try something like s2.name = malloc(80).  Make sure you check the return value, and note that gets() is unsafe.  Don't use that in production code. (or rather, don't use gets() at all).</p>
",2
45735665,45735647,2,"<p>You have to pass pointer to <code>scanf</code>.</p>

<pre><code>scanf(""%d"",year);
</code></pre>

<p>should be</p>

<pre><code>scanf(""%d"", &amp;year);
</code></pre>
",2
35250343,35250227,0,"<p>It looks like you probably want to get the input as one string/char array and then parse it. Not sure if c# has anything to help you with this, but it is doable by using the spaces between the numbers to split them up, and then converting the single number char sequences to ints. you then probably want to put the ints in some sort of array or list, whatever your comfortable with, for sorting. after that the algorithm may take some work, and may involve a few arrays but there should be nothing too complicated about it.</p>
",0
35252144,35250227,0,"<p>The following should work. Code in C#:</p>

<pre><code>Console.Write(""input: "");
var input = Console.ReadLine();
var nums = input.Split(' ').Select(s =&gt; int.Parse(s)).ToList();
if (nums.Count % 2 != 0) {
    throw new InvalidOperationException(""Length must be even."");
}
var seq1 = nums.GetRange(0, nums.Count / 2);
var seq2 = nums.GetRange(nums.Count / 2, nums.Count / 2);
Console.WriteLine(""seq1: "" + string.Join("" "", seq1));
Console.WriteLine(""seq2: "" + string.Join("" "", seq2));
bool areEquiv = true;
for (int i = 0; i &lt; seq1.Count &amp;&amp; areEquiv; i++) {
    for (int j = 0; j &lt; seq2.Count &amp;&amp; areEquiv; j++) {
        if ((seq1[i] &lt;= seq1[j]) != (seq2[i] &lt;= seq2[j])) {
            areEquiv = false;
        }
    }
}
Console.WriteLine(string.Format(""Are {0}order equivalent"", areEquiv ? string.Empty : ""NOT ""));
</code></pre>

<p>Example input and output:</p>

<pre><code>input: 7 5 9 13 12 4 2 25 33 26
seq1: 7 5 9 13 12
seq2: 4 2 25 33 26
Are order equivalent

input: 5 6 9 8
seq1: 5 6
seq2: 9 8
Are NOT order equivalent
</code></pre>
",0
42658111,42657943,1,"<p>Might be because you are using <code>&amp;&amp;</code> instead of <code>&amp;</code> in this: <code>sb-&gt;st_mode &amp;&amp; S_IRGRP</code></p>
",1
42658612,42657943,1,"<p>As a formatting suggestion, please consider:</p>

<pre><code>snprintf(permstr, STR_SIZE, ""%c%c%c%c%c%c%c%c%c%c"", ftpe,
            (sb-&gt;st_mode &amp; S_IRUSR) ? 'r' : '-',
            (sb-&gt;st_mode &amp; S_IWUSR) ? 'w' : '-',
            (sb-&gt;st_mode &amp; S_ISUID) ? (sb-&gt;st_mode &amp; S_IXUSR ? 's' : 'S') :
                                      (sb-&gt;st_mode &amp; S_IXUSR ? 'x' : '-'),

            (sb-&gt;st_mode &amp; S_IRGRP) ? 'r' : '-',    // Fix 1 (&amp;&amp; --&gt; &amp;)
            (sb-&gt;st_mode &amp; S_IWGRP) ? 'w' : '-',    // Fix 2 (prefix '(')
            (sb-&gt;st_mode &amp; S_ISGID) ? (sb-&gt;st_mode &amp; S_IXGRP ? 's' : 'S') :
                                      (sb-&gt;st_mode &amp; S_IXGRP ? 'x' : '-'),

            (sb-&gt;st_mode &amp; S_IROTH) ? 'r' : '-',
            (sb-&gt;st_mode &amp; S_IWOTH) ? 'w' : '-',
            (sb-&gt;st_mode &amp; S_ISVTX) ? (sb-&gt;st_mode &amp; S_IXOTH ? 't' : 'T') :
                                      (sb-&gt;st_mode &amp; S_IXOTH ? 'x' : '-')
        );
</code></pre>

<p>That at least makes it easier to see what's going on.  I'm sure there'll be some disagreement about the finest points of the indentation (should the 'per-bit' lines be indented 3 spaces left ¡ª that would be OK too; should the file type <code>ftpe</code> be on a line on its own, too), but the overall idea of making the symmetry between the structures clearer helps with the readability.</p>

<p>I'll observe that both the fixes were dead easy to spot in this format.</p>

<p><sup><em>Please do not accept this as 'the' answer; just consider it as advice on layout that cannot be demonstrated in a comment.  It's a formatted comment as much as it is an answer.</em></sup></p>
",1
47461510,47461440,5,"<blockquote>
  <p>Getting the file descriptor</p>
</blockquote>

<p>No, it gets the <strong>flags</strong> of the file descriptor. See the <a href=""http://man7.org/linux/man-pages/man2/fcntl.2.html"" rel=""noreferrer""><code>fcntl()</code> manual page</a>. The outer call then sets these flags, with additionally <code>FD_CLOEXEC</code> set. This makes sure the file is closed when a function of the <code>exec()</code> family is called (i.e. when the process is replaced with a new program image). This is a security measure, it avoids leaking the opened file accidentally to a program you pass control to with <code>exec*()</code>.</p>

<p>It's only done when no <code>O_CLOEXEC</code> is available, which allows setting this flag already when opening the file.</p>
",3
47461526,47461440,1,"<p><code>fcntl(fd, F_GETFD)</code> is ""get file descriptor <em>flags</em>"" operation and <code>fcntl(fd, F_SETFD, flags)</code> is ""set file descriptor flags"".</p>

<p>Thus the overall meaning is ""add <code>FD_CLOEXEC</code> to the set of the flags"".</p>
",0
35243083,35243026,10,"<p>Identifiers that begin with two underscores or an underscore and a capital letter are reserved by the C standard and should not be used in your own code, cf. ISO 9899:2011 ¡ì7.1.3 ?1 #1:</p>
<blockquote>
<h3>7.1.3 Reserved identifiers</h3>
<p>1 Each header declares or defines all identifiers listed in its associated subclause, and optionally declares or defines identifiers listed in its associated future library directions subclause and identifiers which are always reserved either for any use or for use as file scope identifiers.</p>
<ul>
<li>All identifiers that begin with an underscore and either an uppercase letter or another underscore are always reserved for any use.</li>
<li>All identifiers that begin with an underscore are always reserved for use as identifiers with file scope in both the ordinary and tag name spaces.</li>
<li>Each macro name in any of the following subclauses (including the future library directions) is reserved for use as specified if any of its associated headers is included; unless explicitly stated otherwise (see 7.1.4).</li>
<li>All identifiers with external linkage in any of the following subclauses (including the future library directions) and <code>errno</code> are always reserved for use as identifiers with external linkage.<sup>184)</sup></li>
<li>Each identifier with file scope listed in any of the following subclauses (including the future library directions) is reserved for use as a macro name and as an identifier with file scope in the same name space if any of its associated headers is included.</li>
</ul>
<p>2 No other identifiers are reserved. If the program declares or defines an identifier in a context in which it is reserved (other than as allowed by 7.1.4), or defines a reserved identifier as a macro name, the behavior is undefined.</p>
<p>3 If the program removes (with <code>#undef</code>) any macro definition of an identifier in the first group listed above, the behavior is undefined.</p>
<hr />
<p>184)?The list of reserved identifiers with external linkage includes <code>math_errhandling</code>, <code>setjm</code>, <code>va_copy</code>, and <code>va_end</code>.</p>
</blockquote>
<p>For double underscores inside names: These are hard to tell apart from single underscores in many typefaces and lead to confusion. I recommend you to avoid doing that.</p>
",0
35243116,35243026,2,"<p>Because it's hard to tell looking at it whether there's one or two underscores, so you're likely to type current_balance when you meant current__balance.</p>

<p>On a similar theme, try not to mix the numbers 0 and 1 with the letters o and l, and don't make variables that only differ in capitalization, for example:</p>

<pre><code>bool boo1;
bool b00l;
int i_byte;
int i_Byte;
</code></pre>
",0
38302275,38302220,9,"<p><code>char</code> is signed on your platform, and <code>0xe0</code> does not fit into a signed <code>char</code>.<br>
Change <code>buf</code>'s type to <code>unsigned char</code>.</p>
",0
36664104,36663945,7,"<p>Your issue seems to be that you are mishandling floating point arithmetic.</p>

<ol>
<li><p>The first argument of the <code>newton_raphson</code> function should be a <code>double</code>, especially because you seem to be calling it recursively. As it is right now, you just cast the result of one iteration into an integer and pass that to the next iteration.</p></li>
<li><p><code>1 / 2</code> uses integer arithmetic. That should be <code>0.5</code> or <code>1.0 / 2.0</code> instead. Note that in integer arithmetic, <code>1 / 2</code> is <code>0</code>. The error you see is because then you pass that <code>0</code> to the next iteration and then it divides by <code>0</code>.</p></li>
</ol>

<h1>The fixed code</h1>

<pre><code>#include &lt;stdio.h&gt;

double newton_raphson(double n, int iter);

double newton_raphson(double n, int iter)
{
    if (iter == 0) {
        return 1;
    }
    else {
        return 0.5 * (newton_raphson(n, iter - 1) + n/(newton_raphson(n, iter - 1)));
    }
}

int main()
{
    int n;
    int i;

    printf(""Enter a number you want to know the square root of:\n"");
    fflush(stdout);
    scanf(""%d"", &amp;n);
    printf(""Enter number of iterations to be worked out:\n"");
    fflush(stdout);
    scanf(""%d"", &amp;i);

    printf(""%.3f\n"", newton_raphson(n, i - 1));

    return 0;
}
</code></pre>

<h1>Possible improvements</h1>

<p>As others pointed out in the comments, you could make this implementation more efficient.</p>

<p>First, you can eliminate a function call by saving the result in a variable. Since this is a recursive function, this will save you a <strong>lot</strong> of execution time if you have many iterations.</p>

<pre><code>double newton_raphson(double n, int iter)
{
    if (iter == 0) {
        return 1;
    }
    else {
        double xk = newton_raphson(n, iter - 1);
        return 0.5 * (xk + n / xk);
    }
}
</code></pre>

<p>Then, you could eliminate recursion alltogether. This will make your program consume much less memory if you run with many iterations because you get rid of unnecessary stack operations.</p>

<pre><code>double newton_raphson(double n, int iter)
{
    int k;
    double xk = 1;
    for (k = 0; k &lt; iter; k++) {
        xk = 0.5 * (xk + n / xk);
    }
    return xk;
}
</code></pre>

<h1>Some more tips</h1>

<p>For the iteration count, you should use <code>unsigned int</code> (or simply <code>unsigned</code>) instead of <code>int</code>. It does not make sense to run a negative number of iterations, eg. you can't run <code>-5</code> iterations... so you do not need a signed integer there.</p>

<pre><code>#include &lt;stdio.h&gt;

double newton_raphson(double n, unsigned iter);

double newton_raphson(double n, unsigned iter)
{
    unsigned k;
    double xk = 1;
    for (k = 0; k &lt; iter; k++) {
        xk = 0.5 * (xk + n / xk);
    }
    return xk;
}

int main()
{
    int n;
    unsigned i;

    printf(""Enter a number you want to know the square root of:\n"");
    fflush(stdout);
    scanf(""%d"", &amp;n);
    printf(""Enter number of iterations to be worked out:\n"");
    fflush(stdout);
    scanf(""%u"", &amp;i);

    printf(""%.3f\n"", newton_raphson(n, i - 1));

    return 0;
}
</code></pre>

<p>Few more things:</p>

<ul>
<li>It is usually a good practice to protect your code from possible division by zero errors, by checking the parameters of your functions or the results of function calls that can possibly return zero.</li>
<li>You should possibly check the input for negative numbers and tell the user that a negative number isn't something you can calculate the square root of with this algorithm.</li>
<li>For the input, you could allow the user to enter a floating point number instead of an integer.</li>
</ul>
",1
34946689,34946462,0,"<p>You are printing the character ascii value <code>0</code>. It is a null value. When you are simply executing with <code>./a.out | cat</code> or <code>./a.out</code> it does not print anything. Because by default cat will not print non printable characters. But when you are using with <code>cat -e</code>, it is for printing the non-printable characters. </p>

<pre><code> printf(""%c"",0);
</code></pre>

<p>From the man page of <code>cat</code>,</p>

<pre><code> -e     equivalent to -vE
 -E, --show-ends
          display $ at end of each line
 -v, --show-nonprinting
          use ^ and M- notation, except for LFD and TAB
</code></pre>
",6
36303186,36303139,2,"<p>It goes wrong because of this line, (and similar ones later)</p>

<pre><code>swap(&amp;middle, &amp;arr[beg]);
</code></pre>

<p><code>middle</code> is a separate variable, and when you swap using the above way, the actual element in the array (<code>array[middle]</code>) is not getting swapped (which you need).</p>

<hr>

<p>You want to swap the elements in the index <code>beg</code> and <code>middle</code> of array. That can be achieved by doing</p>

<pre><code>swap(&amp;arr[middle], &amp;arr[beg]);
</code></pre>
",7
46954254,34286859,1,"<p>gedit simply doesn&#39;t show newlines in files. Why is there a newline in your file? Depends on how you created that file. If you used for example <code>puts(&quot;M&quot;);</code> then you should understand that puts() adds a newline. If you created it with an editor, you should understand that editors usually write complete lines ending in a newline.
                    &ndash;&nbsp;Jens</p>
",0
36288029,36287654,0,"<p>This is how you should code it:</p>

<pre><code>void displayBoard(Cell board[BOARD_HEIGHT][BOARD_WIDTH], Player * player)
{
     int i, j;
    printf(""| "");
    for (j = 0; j &lt; BOARD_WIDTH; j++)
    {
        printf(""|%d"",j);
    }

    printf(""|\n"");

    for (i = 0; i &lt; BOARD_HEIGHT; i++)
    {
        for (j = 0; j &lt; BOARD_WIDTH; j++)
        {
            if (j == 0)
            {
                printf(""|%d"",i);
            }
            printf(""| "");
        }
        printf(""|\n"");
    }
    printf(""\n"");
}
</code></pre>

<p>There are couple of issues with your current code:</p>

<ol>
<li><p>You <code>printf(""|%d"",i);</code> in the inner loop for every <code>j</code> while what you really want is just to print it when <code>j == 0</code> once. The rests, you want to <code>printf(""| "")</code>:</p>

<pre><code>printf(""| ""); //you want to make this blank
if (j == 0)
{
    printf(""|%d"",i); //you want to print i here, not j
}
</code></pre></li>
<li><p>between the print of number when <code>j == 0</code> and the print of blank should be reversed:</p>

<pre><code>if (j == 0)
{
    printf(""|%d"",i); //you want to print i here, not j
}
printf(""| ""); //put the blank printing after the number
</code></pre></li>
</ol>
",0
36288223,36287654,0,"<p>You are printing the number i in every line, when you want a blank or the array data. you also need to get rid of printing a zero every row, which is what you have coded in. Here is that part of the code corrected:</p>

<pre><code>for (i = 0; i &lt; BOARD_HEIGHT; i++)
    {
        for (j = 0; j &lt; BOARD_WIDTH; j++)
        {

            if (j == 0)
            {
                printf(""|%d"",i);
            }
            printf(""| ""); ///or printf(""|%d"",board[i][j]) if you are after  stored data

        }
        printf(""|\n"");
    }
</code></pre>

<p>hope this helps.</p>
",0
36288063,36287654,1,"<p>At no point in the body of the inner loop are you printing spaces.  You're instead printing the value of <code>i</code>, which is the column number.</p>

<pre><code>        printf(""|%d"",i);
        if (j == 0)
        {
            printf(""|%d"",j);
        }
</code></pre>

<p>Instead, print <code>i</code> only on the first iteration and print the space each time:</p>

<pre><code>        if (j == 0) {
            printf(""|%d"",i);
        }
        printf(""| "");
</code></pre>

<p>Output:</p>

<pre><code>| |0|1|2|3|4|5|6|7|8|
|0| | | | | | | | | |
|1| | | | | | | | | |
|2| | | | | | | | | |
|3| | | | | | | | | |
|4| | | | | | | | | |
|5| | | | | | | | | |
|6| | | | | | | | | |
|7| | | | | | | | | |
|8| | | | | | | | | |
</code></pre>
",0
36288267,36287654,0,"<p>Try this:</p>

<pre><code>#define BOARD_HEIGHT 10
#define BOARD_WIDTH  10

void displayBoard()
{
    int i, j;

    printf(""| "");
    for (j = 0; j &lt; BOARD_WIDTH; j++)
    {
        printf(""|%d"", j);
    }
    printf(""|\n"");

    for (i = 0; i &lt; BOARD_HEIGHT; i++)
    {
        printf(""|%d"", i);
        for (j = 1; j &lt; BOARD_WIDTH; j++)
        {
            printf(""| "");
        }
        printf(""| |\n"");
    }
}
</code></pre>

<p>BTW, there is no need to pass any arguments to this function.</p>
",0
36288084,36287654,1,"<p>The key to getting this done correct is enclosing the repeating logic (the blank cells) in the loop while confining the specialized logic to be outside the loop:</p>

<pre><code>void displayBoard(int height, int width)
{
    int i, j;

    printf(""| "");
    for (j = 0; j &lt; width; j++) {
        printf(""|%d"", j);
    }
    printf(""|\n"");

    for (i = 0; i &lt; height; i++) {
        printf(""|%d"", i);
        for (j = 0; j &lt; width; j++) {
            printf(""| "");
        }
        printf(""|\n"");
    }
}
</code></pre>

<p>Look mom! no <code>if</code>s</p>
",0
34986068,34985790,1,"<ul>
<li><p>It is not printing output because your while loop is not ending.Try below code.</p>

<pre><code>#include &lt;stdio.h&gt;
/*histogram of frequences of chars*/
int main()
{
   int  numa, numb, i;
   numa = numb = i = 0 ;
   int charIn;
   while(1)
   {
      while ((charIn = getchar()) != EOF &amp;&amp; charIn != '\n')
      {
         if (charIn =='a')
            ++numa;
         if (charIn =='b')
            ++numb;
      }
      printf(""A:%d\n"",numa);
      printf(""B:%d\n"",numb);
      numa = numb = 0;
   }
}
</code></pre></li>
</ul>
",2
34987488,34985790,0,"<p>First off, change <code>(ch==getchar()) != EOF</code> to <code>(ch=getchar()) != EOF</code>. The first one is comparing <code>ch</code>, which is never initialized, to the value returned by <code>getchar()</code>. And the second one is giving the value returned by <code>getchar()</code> to <code>ch</code>, which is what you actually mean.</p>

<p>Next, note that you can <strong>never</strong> end an unnested loop using <code>(ch=getchar()) != EOF</code>. see <a href=""https://stackoverflow.com/q/27183865/5399734"">getchar() != EOF</a>. Instead, use <code>(ch=getchar()) != '\n'</code>, and it will work.</p>

<p>BTW: Your program will be better if you bother to write <code>int main()</code> and <code>return 0;</code>.</p>
",4
34985798,34985790,2,"<p>Loop is running infinitely. Change   </p>

<pre><code>while ((charIn == getchar()) != EOF)
</code></pre>

<p>to  </p>

<pre><code>while ((charIn = getchar()) != EOF)  
</code></pre>

<p>Also note that you are using <code>charIn</code> before initialization in  <code>(charIn == getchar())</code> and it will invoke undefined behavior.</p>
",0
34987741,34985790,0,"<pre><code>(charIn == getchar())
</code></pre>

<p>Is a condition. <code>==</code> is a comparison operator. You want to set your char though, so use </p>

<pre><code>while ((charIn = getchar()) != EOF)
</code></pre>

<p>Additionally, you should initialize your <code>charIn</code> with the rest of your numbers, as failing to do so invoked Undefined behavior.</p>

<p>Now, if you want to stop on newlines and not the EOF char (which is actually not even a char really) then you need to check against newlines, or <code>'\n'</code>, so like this:</p>

<pre><code>#include &lt;stdio.h&gt;
/*histogram of frequencies of chars*/
main()
{
    int charIn, numa, numb;
    numa = numb = charIn = 0;

    while ((charIn = getchar()) != '\n')
    {
        if (charIn =='a')
            ++numa;
        if (charIn =='b')
            ++numb; 
    }

    printf(""A:%d\n"",numa);
    printf(""B:%d\n"",numb);
}
</code></pre>
",0
34958449,34958292,3,"<blockquote>
  <p>Can I get a simple example program of this escape sequence</p>
</blockquote>

<pre><code>char* s = ""abc"";
</code></pre>

<p>can also be coded as:</p>

<pre><code>char* s = ""\x61\x62\x63"";
</code></pre>

<blockquote>
  <p>I'm not quite clear on its purpose.</p>
</blockquote>

<p>In addition to the usual characters that can be typed easily, 
the C11 standard identifies the following <em>simple-escape-sequence</em>s:</p>

<pre><code>\' \"" \? \\
\a \b \f \n \r \t \v
</code></pre>

<p>If a character cannot be typed easily and it cannot be represented by using one of the simple escape sequences, you will have to resort the using <code>\xnn</code> (hexadecimal escape sequence) or <code>\nnn</code> (octal escape sequence).</p>
",1
37110548,36626696,1,"<p>This example assigns a struct using a pointer and one statement. </p>

<pre><code>int main(void) {

    struct Foo {
        char a;
        int b;
        double c;
    } *foo, *bar;

    foo-&gt;b = 10;
    bar = foo; /* now  bar-&gt;b=10 as well */
}
</code></pre>
",0
35242715,35242647,1,"<p>The compiler says there is syntax error because there is syntax error.</p>

<p>The first argument for calling <code>matrixCheck</code> should be <code>matrix</code> with no extra <code>[]</code> and other junks.</p>

<p>Junk <code>int</code> before second and third arguments should also be removed.</p>
",0
35243722,35242647,-3,"<p>I don't know what the function does but you can try with <code>int array[][]</code> that is the same like <code>int **array</code> -> so a pointer for a two dimensional array.</p>
",3
35244527,35242647,1,"<p>The call should be just:</p>

<pre><code>flag =  matrixCheck( matrix, j, i ) ;
</code></pre>

<p>You do not specify data type or array dimensions of arguments in the function call; only in the definition or declarations.</p>
",0
35243910,35242647,0,"<p>I'm not sure what the function does, so I'll make it print the first value of the first group in the array, then it will print the value of j and i.</p>

<p>After function exit, the value of flag will be printed.</p>

<p>I'm not sure if you know how to use a debugger, but if you don't, then at least make use of the printf statement to print out the numeric variables so you can understand how they are processed. See my code:</p>

<pre><code>#include &lt;stdio.h&gt;
#define LEN 50

int matrixCheck(int array[][LEN] , int j , int i){
    printf(""array[0][0]=%d,  i=%d, j=%d\n"",array[0][0],i,j);
    return 1;
}

int main(){
    int matrix[][LEN] = {{16,2,3,13},{5,11,10,8},{9,7,6,12},{4,14,15,1}};
    int i = 17, j = 18;
    int flag = 0;
    flag =  matrixCheck(matrix,j,i);
    printf(""flag=%d\n"",flag);
    return 0;
}
</code></pre>
",2
37627432,37626864,0,"<p>First of all, remove the printf statement as it is not needed and will mess up the expected I/O as given by SPOJ.</p>

<p>Next, there is no need of the newline character in <code>scanf</code>. You can directly write <code>scanf(""%d %d"", &amp;input1, &amp;input2);</code>. Another way would be to write the <code>scanf</code> statement twice as:</p>

<pre><code>scanf(""%d"", &amp;input1);
scanf(""%d"", &amp;input2);
</code></pre>

<p>Lastly, you can also remove the <code>if</code> statement, if input bounds are given by SPOJ.</p>
",0
37628232,37626864,2,"<p>The first print statement</p>

<pre><code>printf(""enter two natural numbers\n"");
</code></pre>

<p>The Second</p>

<pre><code>scanf(""%d"",&amp;input1);//Press Enter
</code></pre>

<p>The Third</p>

<pre><code>scanf(""%d"",&amp;input2);//Press Enter
</code></pre>

<p>And finally</p>

<pre><code>printf(""\n%d"",sum);
</code></pre>
",0
35237718,35237694,1,"<pre><code>else if ( 70&gt;=age&gt;50 ){
</code></pre>

<p>In C this is not how you do this. Instead try this -</p>

<pre><code>else if (age&gt;50 &amp;&amp; age &lt;=70){    // age in between 50 and 70(including)
</code></pre>
",2
36607513,36607386,5,"<p><strong>Edit:</strong> You can't, at least not on Linux. <code>read</code> will never transfer more than what a 32-bit integer can hold.</p>

<p>From the manpages of Linux on <code>read</code>:</p>

<blockquote>
  <p>On Linux, read() (and similar system calls) will transfer at most
         0x7ffff000 (2,147,479,552) bytes, returning the number of bytes
         actually transferred.  (This is true on both 32-bit and 64-bit
         systems.)</p>
</blockquote>

<p>This is not a contraint of POSIX, it's allowed by POSIX, but in the end it's implementation defined how <code>read</code> behaves. As <a href=""https://stackoverflow.com/users/4756299/andrew-henle"">Andrew Hanle</a> reports, reading a 32GB file works just fine on Solaris. In this case, my old answer is still valid.</p>

<p><strong>Old Answer:</strong></p>

<p><code>read</code> can work with 64-bit files just fine. It's defined in <code>&lt;unistd.h&gt;</code> as the following:-</p>

<pre><code>ssize_t read(int fd, void *buf, size_t count);
</code></pre>

<p>You would have to adjust your routines to work with <code>size_t</code> instead of <code>int</code>, to properly support big files.</p>

<p>You should check <code>SSIZE_MAX</code> (the maximum value supported for <code>count</code>), before using <code>read</code> with a big file, and abort if it's to small (or split into smaller chunks). <code>SSIZE_MAX</code> is an implementation defined value.</p>
",9
36608041,36607386,0,"<p>As @Leandros observed, POSIX-conforming implementations of <code>read()</code> and <code>write()</code> accept byte counts of type <code>size_t</code>, and return byte counts of type <code>ssize_t</code>.  These are probably the definitions that actually apply to you, as the <code>read()</code> and <code>write()</code> functions are not specified by the C standard.  That's a distinction without much difference, however, because <code>size_t</code> is not required to be wider than <code>int</code> -- in fact, it can be narrower.</p>

<p>You anyway have a bigger problem.  The Fortran code seems to assume that the C functions it is calling will read / write the full specified number of bytes or else fail, but POSIX <code>read()</code> and <code>write()</code> are not guaranteed to do that when they succeed.  Indeed, there was a question around here the other day that hinged on the fact that these functions did not transfer more bytes at a time than can be represented by a signed, 32-bit integer, even on a 64-bit system with 64-bit <code>[s]size_t</code>.</p>

<p>You can kill both of these birds with one stone by implementing the <code>read_()</code> and <code>write_()</code> functions to <em>loop</em>, performing successive calls to the underlying <code>read()</code> or <code>write()</code> function, until the full number of specified bytes is transferred or an error occurs.</p>
",7
38619109,38618602,2,"<p>The most plausible explanation for this error is the <code>struct Reference_XS Acc_G</code> must be defined at the global scope.  Initializers for global variables must be constant in C.</p>
",2
34936147,34935927,1,"<p>There might be some typo here because I'm writing from my smartphone. Be aware of that. By the way here as how I would do that :</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void) {

    int yescount = 0, nocount = 0;
    int c;

    while ((c = getchar) != EOF) {
        switch (c) {
          case 'y':
          case 'Y':
            puts(""Yes registered"");
            yescount++;
            break;

          case 'n':
          case 'N':
            puts(""No registered"");
            nocount++;
            break;

          default:
            puts(""Invalid selection."");
            break;
        }
    }
    return 0;
}
</code></pre>
",0
34936244,34935927,1,"<p>You should learn how to present your code correctly: it helps a lot with readability and makes many bugs more visible.</p>

<p>There are problems with your code:</p>

<ul>
<li>You call <code>scanf</code> for no purpose, but you do not read the response as requested.</li>
<li>You forgot an <code>else</code> at the end of the body of the first <code>if</code>.  The consequence is that the last <code>else</code> branch is taken if the response is <code>y</code> or <code>Y</code>.</li>
<li>You should probably print a <code>\n</code> after each message so it appears separate from the subsequent output.</li>
</ul>

<p>Here is a corrected version:</p>

<pre><code>scanf(""%c"", &amp;response);
if (response == 'y' || response == 'Y') {
    yesCount++;
    printf(""YES WAS RECORDED\n"");
} else
if (response == 'n' || response == 'N') {
    noCount++;
    printf(""NO WAS RECORDED\n"");
} else {
    printf(""INVALID\n"");
}
</code></pre>

<p>From your comment, they expect you to use <code>scanf(""%c"", &amp;response);</code> to read the <code>char</code> into <code>response</code>, not the simplest way to read a byte from <code>stdin</code>.</p>
",4
34895035,34894978,1,"<p>You could use bit fields:</p>

<pre><code>typedef struct {
    int n0 : 4;
    int n1 : 4;
    int n2 : 4;
    int n3 : 4;
    int n4 : 4;
    int n5 : 4;
    int n6 : 4;
    int n7 : 4;
    int n8 : 4;
    int n9 : 4;
    int n10 : 4;
    int n11 : 4;
    int n12 : 4;
    int n13 : 4;
    int n14 : 4;
    int n15 : 4;
} S64;

typedef union {
    uint64_t i;
    S64 b;
} U64;
</code></pre>

<p>Note: you may need to pay attention to to the endianness of your target platform(s), if you require a specific ordering of the 4 bit fields within the 64 bit value.</p>
",5
34895036,34894978,2,"<p>You can use bitshifting and bitwise-OR to do this.  Assuming the <code>a[n]</code> values are all between 0 and 15 and also <code>unsigned __int64</code>s:</p>

<pre><code>unsigned __int64 text=0x0;

text = a[0] |
       a[1] &lt;&lt; 4 |
       a[2] &lt;&lt; 8 |
       etc....;
</code></pre>

<p>If you don't trust the <code>a[n]</code> values, use <code>(a[n] &amp; 0xF)</code> to clear all but the four least significant bits before shifting.  If <code>a[n]</code> is not an <code>unsigned __int64</code>, cast it before shifting.</p>
",0
34895249,34894978,1,"<p>If you <em>must</em> use a loop, you can do something like</p>

<pre><code>uint64_t text = 0;
for (int i = 15; i &gt;= 0; --i)
{
    text &lt;&lt;= 4;
    text |= a[i] &amp; 0x0f;  // Masking in case a[i] have more than the lowest four bits set
}
</code></pre>
",5
34895882,34894978,1,"<p>Try the below code. I have tried to copy 0x01, 0x02....0x0f into 16 different nibbles. The code extracts the values and shifts them appropriately combined with the OR operation.</p>

<pre><code>#define NIBBLES   16      /* 64-bit has 16 nibbles */
#define MASK      0x0FLLU  


int main()
{
    unsigned int val[NIBBLES] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                                 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f};

    long long unsigned int num = 0, tmp;
    int i, shift = 0;

    for (i = 0; i &lt; NIBBLES; i++) { 
        tmp = (val[i] &amp; MASK) &lt;&lt; shift;
        num = num | tmp;
        shift = shift + 4;
    }
    printf (""0x%llx\n"", num);

}
</code></pre>

<p>Output: 0xfedcba9876543210</p>
",0
36732605,36732580,2,"<p>The <code>-&gt;</code> operator expects a pointer on the left hand side. <code>&amp;x</code> returns the address of <code>x</code> so it satisfies that requirement (even if it is totally redundant). To think about it another way...</p>

<pre><code>cool *y = x;
y-&gt;a = 3;
</code></pre>

<p>The <code>.</code> operator expects a <a href=""https://en.wikipedia.org/wiki/Stack-based_memory_allocation"" rel=""nofollow"">stack allocated</a> struct on the left hand side. <code>x</code> is that, so <code>x.a</code> works fine.</p>

<p>You can also go the other way, if you have a pointer <code>y</code> you can dereference it with <code>*y</code> and use <code>.</code> on it: <code>(*y).a</code>. This is also totally redundant.</p>
",4
36732928,36732580,1,"<p>The <code>&amp;</code> prefix operator returns the <em>memory address</em> of whatever object you put it in front of.</p>

<p>This means that you have to put it in front of objects that actually <em>have</em> a memory address. For example, literals and temporary expression results don't necessarily have an address. Variables declared with <code>register</code> storage class don't have an address, either.</p>

<p>Thus:</p>

<pre><code>int i = 5;
&amp;i;  // works

&amp;5;  // Nope!

&amp;(i + 1); // Nope!

&amp;i + 1;  // Works, because &amp;i has higher precedence than +1.
</code></pre>

<p>So what does the address of an object give you? It is a <em>pointer</em> to the object. This is how you can do <em>dynamic memory allocation</em> using the <em>heap</em>. This is where functions like <code>malloc()</code> come in. And this is how you can build arbitrarily large data structures.</p>

<p>In C, <em>arrays</em> are represented as pointers. So arrays and pointers are often used interchangeably. For example:</p>

<pre><code>char buffer[100];  // array
strcpy(buffer, ""hello""); // strcpy is declared to take (char *, const char *)
</code></pre>

<p>The opposite of the <em>address_of</em> operator is the <code>*</code> <em>dereference</em> operator. If I declare a pointer to something, I can get ""what it points at"" using this syntax:</p>

<pre><code>int i = 5;
int *pi = &amp;i;  // pointer to int. Note the * in the declaration?

i + i; // 10
i + *pi;  // Also 10, because pi ""points to"" i
</code></pre>

<p>In the case where you have an aggregate type like a <code>struct</code> or <code>union</code>, you would have to do something like this:</p>

<pre><code>struct {
    int a;
} s;

s.a = 5;

/* ??? */ ps = &amp;s;  // pointer to s

s.a;  // 5

(*ps).a; // Also 5, because ps points to s.

ps-&gt;a;  // 5, because a-&gt;b is shorthand for (*a).b
</code></pre>

<p>This only works, of course, if you have a pointer to an object that CAN use the <code>.member</code> and that has an appropriately named <em>member.</em> For example, you can't do this:</p>

<pre><code>i = 5;
pi = &amp;i;

pi-&gt;a;  // WTF? There is no i.a so this cannot work.
</code></pre>

<p>If you have a pointer, you can take the address of it. You then have a pointer to a pointer. Sometimes this is an array of pointers, as with the <code>argv</code> array passed to <code>main</code>:</p>

<pre><code>int main(int argc, const char *argv[]);
int main(int argc, const char **argv); // Effectively the same.
</code></pre>

<p>You can do weird stuff with pointers to pointers:</p>

<pre><code>int i = 5;
int j = 100;


int * pij;

for (pij = &amp;i; i &lt; j; ) {
    if (i &amp; 1) {
        *pij *= 2;
        pij = &amp;j;
    } 
    else {
        i += 1;
        *pij -= 1;
        pij = &amp;i;
    }
}
</code></pre>

<p>Note: I have no idea what that code does. But it's the kind of thing you can wind up doing if you're working with pointers.</p>
",0
36806242,36806175,0,"<p>You might wish to use the ternary operator :</p>

<pre><code>strings_quadruples1_action[0]!=NULL?strings_quadruples1_action[0]:""""
</code></pre>

<p>Do the same for other three strings as well.</p>

<p>Or define a macro in the beginning :</p>

<pre><code>#define NO_NULL(X) X!=NULL?X:""""
</code></pre>

<p>and do printf like :</p>

<pre><code>printf("" %d \t %s \t %s \t %s \t %s.\n"",
                        quadruples_line_counter,
                        NO_NULL(strings_quadruples1_action[0]),
                        NO_NULL(strings_quadruples2_variable1[0]),
                        NO_NULL(strings_quadruples3_variable2[0]),
                        NO_NULL(strings_quadruples4_temp_variable[0]));
</code></pre>
",0
36500192,36500136,5,"<p>Accessing the first letter is done with the array-operator [].
Converting to uppercase is done with the ANSI-C function toupper().</p>

<pre><code>f_name[0] = toupper(f_name[0]);
</code></pre>

<p>Printing out something which is a number is done with the %d placeholder.
Converting a string to a number is done via ANSI-C function atoi().</p>

<pre><code>printf(""Id: %d\n"", atoi( st_id ) );
</code></pre>

<p>You should read <a href=""https://en.wikipedia.org/wiki/The_C_Programming_Language"" rel=""nofollow"">https://en.wikipedia.org/wiki/The_C_Programming_Language</a> to get a better understanding of C.</p>
",2
36500263,36500136,3,"<pre><code>$ apropos upper
toupper (3)          - convert letter to upper or lower case
toupper (3p)         - transliterate lowercase characters to uppercase
towlower (3p)        - transliterate uppercase wide-character code to lowercase
towupper (3)         - convert a wide character to uppercase
towupper (3p)        - transliterate lowercase wide-character code to uppercase
$ man toupper
NAME
       toupper, tolower - convert letter to upper or lower case

SYNOPSIS
       #include &lt;ctype.h&gt;

       int toupper(int c);
       int tolower(int c);

DESCRIPTION
       toupper() converts the letter c to upper case, if possible.

       tolower() converts the letter c to lower case, if possible.

       If c is not an unsigned char value, or EOF, the behavior
       of these functions is undefined.
</code></pre>
",0
36500322,36500136,4,"<p>You can call <a href=""http://man7.org/linux/man-pages/man3/toupper.3.html"" rel=""nofollow""><code>toupper(int)</code></a> to capitalize one character; and you can use <a href=""http://linux.die.net/man/3/atoi"" rel=""nofollow""><code>atoi(const char *)</code></a> to parse the student id. Something like</p>

<pre><code>printf(""First Name: %c%s\n"", toupper(f_name[0]), f_name + 1);
printf(""Last  Name: %c%s\n"", toupper(l_name[0]), l_name + 1);
printf(""Student ID: %i\n"", atoi(st_id + 1));
</code></pre>

<p>Outputs (with no other changes)</p>

<pre><code>First Name: David
Last  Name: House
Student ID: 966898
</code></pre>
",2
34968356,34968326,1,"<p>It's off because of cumulative rounding errors inside calculations.</p>

<p>You can use <code>double</code> for more precision.</p>

<p>See Joachim comment: <a href=""https://stackoverflow.com/questions/34968326/c-least-amount-of-coins-for-amount-entered/34968356#comment57666858_34968326"">c least amount of coins for amount entered</a></p>
",0
34983621,34983599,5,"<p>If you keep your <code>for</code> loop, then at the end of it, we have <code>n = count</code>. If you remove it, you have <code>n = 0</code>. This then changes your second <code>for</code> loop, as <code>i</code> doesn't take the same values.</p>
",3
46617159,46617015,3,"<p>You could use the <code>realloc</code> function:</p>

<pre><code>void *realloc(void *ptr, size_t size);
</code></pre>

<p>Quoted from the man pages:</p>

<blockquote>
  <p>The realloc() function changes the size of the memory block pointed to
  by ptr to size bytes.   The
         contents  will be unchanged in the range from the start of the region up to the minimum of the old
         and new sizes.  If the new size is larger than the old size, the added memory will not be initial©\
         ized.   If  ptr  is  NULL, then the call is equivalent to malloc(size), for all values of size; if
         size is equal to zero, and ptr is not NULL, then the call is equivalent to free(ptr).  Unless  ptr
         is NULL, it must have been returned by an earlier call to malloc(), calloc() or realloc().  If the
         area pointed to was moved, a free(ptr) is done.</p>
</blockquote>
",2
36220014,36219596,0,"<p>Insufficient string space.  Also add limit to scanning</p>

<pre><code>char ap[3];
scanf(""%d%d%d%2s"",&amp;hh,&amp;mm,&amp;ss,ap);
</code></pre>

<p><a href=""https://stackoverflow.com/a/1784777/1212012""><code>stricmp</code></a> is not standard. Use <a href=""http://linux.die.net/man/3/strcasecmp"" rel=""nofollow noreferrer""><code>strcasecmp</code></a> on linux or <a href=""https://msdn.microsoft.com/fr-fr/library/k59z8dwe.aspx"" rel=""nofollow noreferrer""><code>_stricmp</code></a> on windows.</p>

<p>Functionally missing the handling of times like 12 34 56 AM which should change to 0 34 56.  </p>

<pre><code>if(stricmp(ap,""AM"")==0) {
  if (hh &gt;= 12) hh -= 12;
} else if(stricmp(ap,""PM"")==0) {
  hh +-= 12;
}
</code></pre>

<p>More usual to print minutes.seconds with leading zeros.</p>

<pre><code>printf(""%d:%02d:%02d"",hh,mm,ss);
</code></pre>
",0
40956141,40955085,0,"<blockquote>
  <p><em>My problem is that I cannot seem to get the windows to draw on the same line.</em></p>
</blockquote>

<p>The basic problem is you're adding newlines to your print statements when drawing an individual window.</p>

<pre><code>for (i = 0; i &lt;= numOfWindows;i++)
{
    /* There shouldn't be a newline here */
    printf(""===\n"");
    for (j = 0; j &lt;= numOfWindows;j++)
    {
        /* Nor a newline here */
        printf(""|  |\n"");
    }

    printf(""==="");
}
</code></pre>

<p>You're also counting your windows from 0 which results in one too many windows. Either start from 1 or go until <code>i &lt; numOfWindows</code>.</p>

<p>You have to draw each line in its own loop, including the outer walls, ending with a newline. First the upper sills, then the windows, then the lower sills.</p>

<pre><code>void drawUpperFloors(int numOfWindows)
{
    int i;

    /* Draw the upper sills, including the outer walls */
    printf(""|  "");
    for (i = 1; i &lt;= numOfWindows;i++)
    {
        printf(""=== "");
    }
    printf("" |\n"");

    /* Draw the windows, including the outer walls */
    printf(""|  "");
    for (i = 1; i &lt;= numOfWindows;i++)
    {
        printf(""| | "");
    }
    printf("" |\n"");

    /* Draw the lower sills, including the outer walls */
    printf(""|  "");
    for (i = 1; i &lt;= numOfWindows;i++)
    {
        printf(""=== "");
    }
    printf("" |\n"");
}
</code></pre>

<p>That gets repetitive, so it's best to put drawing a line of a floor into a function.</p>

<pre><code>void drawFloorLine(int num, const char *to_repeat) {
    int i;

    printf(""|  "");
    for (i = 1; i &lt;= num;i++)
    {
        printf(""%s"", to_repeat);
    }
    printf("" |\n"");
}

void drawUpperFloors(int numOfWindows)
{
    drawFloorLine(numOfWindows, ""=== "");    
    drawFloorLine(numOfWindows, ""| | "");
    drawFloorLine(numOfWindows, ""=== "");
}
</code></pre>
",2
34907500,34907297,6,"<p>C does not have support for regular expressions in the code itself.  Libraries exist to perform regular expressions on text, but not on the code. </p>

<p>Variable declarations must be done separately.  For pointers in particular, a <code>*</code> next to a declared variable applies only to that variable.  For example:</p>

<pre><code>int *a, b, *c;
</code></pre>

<p>This declares <code>a</code> and <code>c</code> as <code>int *</code> and <code>b</code> as <code>int</code>.  Another way of looking at is that <code>*a</code>, <code>b</code>, and <code>*c</code> are all of type <code>int</code>.</p>
",0
35192875,35192844,1,"<p>In this following assignment -</p>

<pre><code>result[0][index + 1] = ""\0""; // 1
result[1][index] = ""\0"";     // 2
</code></pre>

<p>Use single quotes <code>' '</code> and not double quotes . </p>

<p><code>""""</code> are use for string literals where as <code>result[1][index]</code> and similar are <code>char</code> , therefore , you get the warning. </p>

<pre><code>result[0][index + 1] = '\0';      /*  &lt;-- assigning character   */ 
</code></pre>
",0
42482556,42482349,7,"<p>Assuming <code>x</code> is a 32 bit floating point:</p>

<p>Floating point values have a limited resolution. <code>100000001</code> is <code>1*10^8</code> so you lose your <code>1</code> at the end. If you would add <code>1</code>, it again gets lost because the next float value is <code>1.00000008*10^8</code>. You can add as many <code>1</code>s as you like the result will always be the same.</p>

<p>That is the reason why your code is an endless loop.</p>
",0
42482559,42482349,5,"<pre><code>float x = 100000001.0f;
</code></pre>

<p>will initialize <code>x</code> with the nearest representable <code>float</code>, which is <code>100000000</code>. Adding <code>1</code> to this value will lead to the same value.</p>

<p>If you print the value of <code>x</code> in the loop you will see what happen: <a href=""http://ideone.com/3FJGTz"" rel=""noreferrer"">http://ideone.com/3FJGTz</a></p>
",0
36237348,36237289,2,"<p>I modified your code like this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void input(void);

int main(int argc, char** argv) {
    input();
    return(EXIT_SUCCESS);
}

void input(void) {
    char buffer[10];
    FILE *ptr;
    ptr = fopen(""data.bin"",""rb"");  // r for read, b for binary
    fread(buffer, sizeof(buffer), 1, ptr); // read 10 bytes to our buffer
    printf(""%s"", buffer);

    fclose(ptr);
}
</code></pre>

<p>Output:</p>

<blockquote>
  <p>6</p>
</blockquote>

<p>and for more, read this: <a href=""https://stackoverflow.com/questions/17598572/read-write-to-binary-files-in-c"">Read/Write to binary files in C</a>.</p>
",0
36240595,36239378,0,"<ul>
<li><code>fgets(strbuff, sizeof(strbuff), fp)</code></li>
<li>replace all tokens (ie <code>/</code> ) with spaces.</li>
<li>remove all commas (<code>,</code>) and trailing <code>/n</code></li>
<li>use <code>strtok()</code></li>
<li>parse each token with <code>atof()</code></li>
<li>store <code>atof()</code> result as a <code>long long int</code></li>
<li>repeat for each token</li>
<li>repeat for each line.</li>
</ul>
",4
36241075,36239378,3,"<p>This is a good exercise for you to think through, but you must take it step-by-step, and account for all character-contingencies you will encounter reading your file a character at a time. </p>

<p>The two primary approaches you can take are to (1) read each char, and if a digit, perform a conversion and intermediate sum to build the value of the integer, or (perhaps easier) (2) add each digit to a <em>character-array</em> and when you reach a non-digit, <em>nul-terminate</em> and convert the character-array to an integer using <code>atoi</code> or <code>strtol</code>. I find the second a bit easier. (otherwise, you need to handle the intermediate-sum for each digit encountered)</p>

<p>Taking the second approach, you could write your <code>findints</code> something similar to:</p>

<pre><code>int findints (FILE *fp, int *arr, size_t sz)
{
    int c, n = 0, idx = 0;
    char tmp[MAXD] = """";

    while ((c = fgetc (fp)) != EOF) {       /* for each char    */
        if (c == ',')                       /* get next if ,    */
            continue;
        if (idx &amp;&amp; !isdigit(c)) {           /* if end of digits */
            tmp[idx] = 0;                   /* nul-terminate    */
            arr[n++] = (int) strtol (tmp, NULL, BASE);  /* convert to int */
            idx = 0;                        /* reset idx */
            memset (tmp, 0, sizeof tmp);    /* reset tmp */
            if (n == (int)sz) {             /* validate sz &lt; MAXSZ */
                fprintf (stderr, ""warning: MAXSZ reached.\n"");
                break;
            }
            if (c == '.')   /* truncate after '.' */
                while (isdigit ((c = fgetc (fp)))) {}
        }
        if (isdigit (c))    /* add digit to char array */
            tmp[idx++] = c;
    }

    return n;
}
</code></pre>

<p>There are probably improvements you can make, but take the time and step through it <em>line-by-line</em> and <em>character-by-character</em> to understand the testing done and how the character array is built, converted and reset, how the decimal truncation is done for numbers containing a <code>'.'</code>, etc..</p>

<p>You can test the code on your datafile with a short program that calls <code>findints</code>. <em>note:</em> the code with read from the file given as the first argument (or from <code>stdin</code> if no filename is give by default).</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;

enum { BASE = 10, MAXD = 21, MAXSZ = 128 };

int findints (FILE *fp, int *arr, size_t sz);

int main (int argc, char **argv) {

    int a[MAXSZ] = {0}, i, n = 0;
    FILE *fp = argc &gt; 1 ? fopen (argv[1], ""r"") : stdin;

    if (!fp) {
        fprintf (stderr, ""error: file open failed '%s'.\n"", argv[1]);
        return 1;
    }

    n = findints (fp, a, MAXSZ);    /* call findints */

    printf (""\n the array has '%d' elements.\n\n"", n);
    for (i = 0; i &lt; n; i++)
        printf (""  array[%2d] : %d\n"", i, a[i]);
    putchar ('\n');

    if (fp != stdin)
        fclose (fp);

    return 0;
}

int findints (FILE *fp, int *arr, size_t sz)
{
    int c, n = 0, idx = 0;
    char tmp[MAXD] = """";

    while ((c = fgetc (fp)) != EOF) {       /* for each char    */
        if (c == ',')                       /* get next if ,    */
            continue;
        if (idx &amp;&amp; !isdigit(c)) {           /* if end of digits */
            tmp[idx] = 0;                   /* nul-terminate    */
            arr[n++] = (int) strtol (tmp, NULL, BASE);  /* convert to int */
            idx = 0;                        /* reset idx */
            memset (tmp, 0, sizeof tmp);    /* reset tmp */
            if (n == (int)sz) {             /* validate sz &lt; MAXSZ */
                fprintf (stderr, ""warning: MAXSZ reached.\n"");
                break;
            }
            if (c == '.')   /* truncate after '.' */
                while (isdigit ((c = fgetc (fp)))) {}
        }
        if (isdigit (c))    /* add digit to char array */
            tmp[idx++] = c;
    }

    return n;
}
</code></pre>

<p><strong>Example Output</strong></p>

<pre><code>$ ./bin/txt2array &lt;dat/getint.txt

 the array has '9' elements.

  array[ 0] : 2
  array[ 1] : 3
  array[ 2] : 3
  array[ 3] : 65000000
  array[ 4] : 31
  array[ 5] : 9
  array[ 6] : 9
  array[ 7] : 1
  array[ 8] : 1986
</code></pre>

<p>As you discover or encounter additional cases (as pointed out in the comment), you can refine your <code>findints</code> process to do what it is you would like it to do. One such case, not addressed in you original datafile would be the case where there is a leading <code>'.'</code> followed by digits (e.g. <code>.nnn</code> (say <code>.1234</code>)). Since your original question truncated all decimals, above should evaluate to <code>0</code>, but <code>0</code> is a valid integer value. So you could decide to treat any fractional parts as if they were <code>0.1234</code> which would be <code>0</code> in the original statement, but would nevertheless be added to the array in its own right. </p>

<p>So you would need a test for <code>'.'</code> when no digits had been added to your character array. The case where digits exist before a <code>'.'</code> is encountered is already covered by <code>if (idx &amp;&amp; !isdigit(c))</code>, so you need only add something like:</p>

<pre><code>while ((c = fgetc (fp)) != EOF) {       /* for each char    */
    ...
    if (idx &amp;&amp; !isdigit(c)) {           /* if end of digits */
        ...
    }
    /* consider '.nnn' as 0 */
    if (c == '.' &amp;&amp; isdigit ((c = fgetc (fp)))) {
        while (isdigit ((c = fgetc (fp)))) {}
        arr[n++] = 0;
    }
    ...
</code></pre>

<p>That is the benefit of building your own parsing routine, you can tailor it to do exactly what you need it to do and add to it when you encounter additional cases that need to be addressed.</p>

<p>Let me know if you have any questions.</p>
",3
36239549,36239378,-1,"<p>First copy the lines(from file) into strings then you can use <code>""atoi(some_string)""</code> function that return the first integer that lies in <code>some_string</code>....I think it can help to make the array as you are hoping...</p>
",1
36268007,36267964,0,"<p>First ask how many elements has to be entered, before entering the loop to read elements.</p>

<pre><code>int elements;
for(loop = 0; loop &lt; routines; loop++)
{
    printf(""enter number of elements for row %d\n"", loop + 1);
    scanf(""%d"", &amp;elements);    //read the number of elements
    for(j = 0; j &lt; elements; j++)
    {
        scanf("" %c"", &amp;danceRoutines[loop][j]);
    }
}
</code></pre>

<hr>

<p><strong>NOTE:</strong></p>

<p>Notice the space before <code>%c</code> in <code>scanf()</code>. That is required to clear the input buffer.</p>
",0
36269859,36267964,0,"<p>This is how you can implement this.Create a <code>char**</code> array <code>danceRoutines</code> which will point to the strings, and then assign the address of every new string entered by user to the <code>danceRoutines[i]</code> inside the loop.</p>

<pre><code>int routines=5,loop;
char **danceRoutines=(char**)malloc(sizeof(char*)*routines);
for(loop = 0; loop &lt; routines; loop++)
{
    char *s=(char*)malloc(sizeof(char*));
    scanf(""%s"",s);
    danceRoutines[loop]=s;
}
</code></pre>

<p>Then simply display the strings by iterating over array <code>danceRoutines</code></p>

<pre><code>//display
for(loop = 0; loop &lt; routines; loop++)
{
    printf(""%s\n"",danceRoutines[loop]);
}
</code></pre>
",0
37449242,37449087,3,"<p>After the inner loop completes, you've reached the end of <code>stdin</code>. So when you go to the next iteration of the outer loop, there's nothing left in <code>stdin</code>, so the inner loop ends immediately.</p>

<p>Assuming <code>stdin</code> is connected to a seekable stream (e.g. an ordinary file), you can solve this by rewinding back to the beginning before the inner loop.</p>

<p>Another problem was that you were closing <code>fileInput</code> inside the loop. So after you read the first line of that file, it was closing the file, so it got an error trying to read the next line.</p>

<pre><code>while (fgets(fline, sizeof(fline), fileInput)){
    rewind(stdin);
    while (fgets(line, sizeof(line), stdin)){
        printf(""%s"", fline);
        printf(""%s"", line); 
    }
}
fclose(fileInput);
</code></pre>

<p>A more general solution would be to read <code>stdin</code> into an array, then iterate over the array instead of using a <code>fgets</code> loop.</p>
",0
40973718,40973453,-1,"<p>On some platforms (especially Windows and Linux) you can use fflush(stdin);:</p>

<p>Do modify your code like :-</p>

<pre><code>while(saut==1)
...
....

scanf(""%d"",&amp;saut);
fflush(stdin);
}
fflush(stdin);
</code></pre>

<p>these is another trick to solve this issue :-</p>

<p>It goes into an infinite loop because scanf() will not consumed the input token if match fails. scanf() will try to match the same input again and again. you need to flush the stdin.</p>

<p>if (!scanf(""%d"", &amp;sale.m_price)) fflush(stdin)</p>
",8
36286601,36286398,2,"<p>One option is saving to a file the names that have been used, and using them as a checklist. You also want to seed rand with something like <code>srand(time(NULL))</code>. </p>

<p>another is ignoring the randomisation, and just going in order, e.g. aaa, aab aac...aba ,abb etc. Again, save where your cycle is up to on a file.</p>
",2
36286655,36286398,1,"<p>Your question seems a little bit unclear but if you want to generate a unique string there are a couple of things you can consider:</p>

<ol>
<li>Get System timestamp ( yyyy-MM-dd-HH-mm-ss-fff-tt)</li>
<li>Use Random function to generate a random number</li>
</ol>

<p>Combine this with your function and I am sure you will get a unique string.</p>

<p>Hope it helps !</p>
",1
36287082,36286398,0,"<p>If it's available, you could avoid manually generating random names that might collide and let the system do it for you (and handle collision resolution by creating a new name) by using <a href=""http://man7.org/linux/man-pages/man3/mkstemp.3.html"" rel=""nofollow""><code>mkstemps</code></a>. This is also safer because it opens the file for you, removing the risk of a random name being generated, verified to be unique, then trying to open it and discovering another thread/process raced in and created it.</p>

<pre><code>char name[] = ""/path/to/put/files/in/__ft_XXXXXX.txt"";
int fd = mkstemps(name, strlen("".txt""));
if (fd == -1) { ... handle error ... }
</code></pre>

<p>After <code>mkstemps</code> succeeds, <code>name</code> will hold the path to the file (it's mutated in place, replacing the <code>XXXXXX</code> string), and <code>fd</code> will be an open file descriptor to that newly created file; if you need a <code>FILE*</code>, use <a href=""http://linux.die.net/man/3/fdopen"" rel=""nofollow""><code>fdopen</code></a> to convert to a <code>stdio</code> type.</p>
",1
36644020,36643616,4,"<p>Never use <code>gets</code>, is deprecated in C99 and removed from C11. </p>

<p>IMO, <code>scanf</code> is not a good function to use when you don't know the number of elements before-hand, I suggest <code>fgets</code>:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
{
    char str[128];
    char *ptr;

    fgets(str, sizeof str, stdin);
    /* Remove trailing newline */
    ptr = strchr(str, '\n');
    if (ptr != NULL) {
        *ptr = '\0';
    }
    /* Tokens */
    ptr = strtok(str, "" "");
    while (ptr != NULL) {
        printf(""%s\n"", ptr);
        ptr = strtok(NULL, "" "");
    }
    return 0;
}
</code></pre>
",3
36644279,36643616,1,"<p><code>gets</code> is not recommended to use, as there is no way to tell the size of the buffer. <code>fgets</code> is ok here because it will stop reading when the 1st new line is encountered. You could use strtok to store all the splited words in to an array of strings, for example:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void) {
    char s[256];
    char *result[10];

    fgets(s, sizeof(s), stdin);
    char *p = strtok(s, "" \n"");
    int cnt = 0;
    while (cnt &lt; (sizeof result / sizeof result[0]) &amp;&amp; p) {
        result[cnt++] = p;
        p = strtok(NULL, "" \n"");
    }
    for (int i = 0; i &lt; cnt; i++)
        printf(""%s\n"", result[i]);
    return 0;
}
</code></pre>
",2
36644903,36643616,0,"<p>As most of the other answers haven't covered another thing you were asking:</p>

<p><code>strtok</code> will not allocate temporary memory and will use your given string to replace every separator with a zero termination. This is why <code>Good morning John</code> becomes <code>GoodNULLmorningNULLJohn</code>. If it wouldn't do this, each token would print the whole rest of the string on its tail like:</p>

<pre><code>result[0] = Good morning John
result[1] = morning John
result[2] = John
</code></pre>

<p>So if you want to keep your original input and an array of char* per word, you need 2 buffers. There is no other way around that. You also need the token buffer to stay in scope as long as you use the result array of char* pointers, else that one points to invalid memory and will cause undefined behavior.</p>

<p>So this would be a possible solution:</p>

<pre><code>int main()
{
    const unsigned int resultLength = 10;
    char* result[resultLength];
    memset(result, 0, sizeof result);   // we should also zero the result array to avoid access violations later on

    // Read the input from the console
    char input[256];
    fgets(input, sizeof input, stdin);

    // Get rid of the newline char
    input[strlen(input) - 1] = 0;

    // Copy the input string to another buffer for your tokens to work as expected
    char tokenBuffer[256];
    strcpy(tokenBuffer, input);

    // Setting of the pointers per word
    char* token = strtok(tokenBuffer, "" "");
    for (unsigned int i = 0; token != NULL &amp;&amp; i &lt; resultLength; i++)
    {
        result[i] = token;
        token = strtok(NULL, "" "");
    }

    // Print the result
    for (unsigned int i = 0; i &lt; resultLength; i++)
    {
        printf(""result[%d] = %s\n"", i, result[i] != NULL ? result[i] : ""NULL"");
    }
    printf(""The input is: %s\n"", input);

    return 0;
}
</code></pre>

<p>It prints:</p>

<pre><code>result[0] = Good
result[1] = morning
result[2] = John
result[3] = NULL
result[4] = NULL
result[5] = NULL
result[6] = NULL
result[7] = NULL
result[8] = NULL
result[9] = NULL
The input is: Good morning John
</code></pre>
",0
36253187,36253086,1,"<pre><code>strcpy(output_file, input_file); // Make a copy of the input file name
strcat(output_file, "".cvt""); // Add the "".cvt"" suffix to it
</code></pre>
",0
37700394,37700201,2,"<p>A working solution is given in the answer from sokkyoku.</p>

<p><strong>Another possibility</strong> to read variable length lines is to use strtok like in the following code snippet:</p>

<pre><code>int getlines (FILE *fin)
{
    int  nlines = 0;
    int  count  = 0;
    char line[BUFFSIZE]={0};
    char *p;

    if(NULL == fgets(buff, BUFFSIZE, fin))
        return -1;

    while(fgets(line, BUFFSIZE, fin) != NULL) {
        //Remove the '\n' or '\r' character
        line[strcspn(line, ""\r\n"")] = 0;
        count = 0;
        printf(""line[%d] = %s\n"", nlines, line);
        for(p = line; (p = strtok(p, "" \t"")) != NULL; p = NULL) {
            printf(""%s "", p);
            ++count;
        }
        printf(""\n\n"");
        ++nlines;
    }

    return nlines;
}
</code></pre>

<p><strong>Explanation</strong> of the above function <code>getlines</code>:</p>

<p>Each line in the file <code>fin</code> is read using <code>fgets</code> and stored in the variable <code>line</code>. 
Then each substring in <code>line</code> (separated by a white space or <code>\t</code> character) is extracted and the pointer to that substring stored in <code>p</code>, by means of the function <code>strtok</code> in the for loop (see for example this <a href=""https://stackoverflow.com/questions/18927793/how-to-use-strtok"">post</a> for further example on strtok).</p>

<p>The function then just print <code>p</code> but you can do everything with the substring here. 
I also count (<code>++count</code>) the number of items found in each line. At the end, the function <code>getline</code> count and returns the number of lines read.</p>
",2
37700463,37700201,2,"<p>The reason this never ends is because you are constantly providing the same string to scan.</p>

<p><code>sscanf</code> provides the <code>%n</code> switch which stores the amount of characters read before it is reached inside a, which allows you to move forward in your input string by that amount of characters before rescanning.</p>

<p>This'll work:</p>

<pre><code>int step[20];
int index=0;
int readLen;
while(sscanf(mystring,""%d%n"", &amp;step[index++], &amp;readLen)&gt;0) {
  mystring += readLen;
}
</code></pre>
",0
35247803,35246888,0,"<p>The problem you are running into is while 1/9 is a repeating decimal both in base 10 (0.1111..) and in base 16, (0.1c71c7..) when you multiply by 9 again, you get 1... as far as the floating point routines are concerned.  The way to get your 0.9999 in C is to break up the repeated decimal by subtracting just a little bit so it won't round back to 1.  If you only want to see 9s, you will need to limit how much gets printed out by some means other than the floating point formatting. This will do what you need:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
main()
{
    double val=9;
    char disp[21];
    val=1.0/9.0;
    val -= 0.0000000000000001;
    printf(""%20.19f\n"", val);
    val *=9;
    printf(""%20.19f\n"", val);
    sprintf(disp,""%20.19f"",val);
    printf(""%.15s\n"", disp);
}
</code></pre>

<p>This gives:</p>

<pre><code>0.1111111111111110078
0.9999999999999991118
0.9999999999999
</code></pre>

<p>on my machine.</p>
",0
35247069,35246888,-1,"<p>This happend, because results isn't really 0.1111111. You can check this with <code>std::setprecision(numOfDecimals)</code> from <code>#include &lt;iomanip&gt;</code></p>

<p>Here is little example:</p>

<pre><code>double a=1.0/9.0;
double b=9.0;
std::cout&lt;&lt;a*b; //result is 1
</code></pre>

<p>From mathematic reasons: (1/9)*(9/1)=(9/9)=1.</p>

<p>If we actualy have results like this:</p>

<pre><code>double a=round(1.0/9.0 * 100.0)/100.0;//100 for 2 decimal places: here is 0.11 actualy
double b=9.0;
std::cout&lt;&lt;a*b; //result is 0.99
</code></pre>

<p><a href=""http://cpp.sh/35a7n"" rel=""nofollow"">Example</a></p>
",0
34895913,34895868,1,"<p>It's called a buffer overflow resulting in undefined behavior. It may or may not crash your problem, but it is a security hole nonetheless.</p>

<p><code>scanf</code> with <code>%s</code> without a maximum length specified is always a security hole just like <code>gets()</code> and should not be used!</p>

<p>BTW: <code>sizeof char</code> is guaranteed to be <code>1</code> so you don't need to specify it - just use the number of chars you need; multiplying by <code>sizeof char</code> is likely to be optimized away by your compiler.</p>
",7
34895916,34895868,3,"<p>You write beyond the boundary of the memory you allocated. This is undefined behavior, and you are unlucky enough that it seemed to ""work"".</p>
",0
34896267,34895868,0,"<blockquote>
  <p>From what I understand (char*)malloc(sizeof(char)) should only
  allocate space for one character</p>
</blockquote>

<p>Thats correct. <code>malloc</code> in this case returns a pointer to 1 byte of allocated memory. </p>

<pre><code>fflush(stdin);
</code></pre>

<p>Is undefined. At this point, anything may happen.</p>

<pre><code>scanf(""%s"",sir[i]);
</code></pre>

<p>Is also undefined. Again, at this point anything may happen, from crashing your program with a segfault to it seemingly working.</p>
",0
36360190,36360133,1,"<p>You must work with the memory management; <a href=""http://linux.die.net/man/3/strtok"" rel=""nofollow""><code>strtok()</code></a> returns a pointer into the input string (<code>line</code>), which of course will be replaced by each successive <code>fgets()</code>.</p>

<p>If you have it, you can use <a href=""http://linux.die.net/man/3/strdup"" rel=""nofollow""><code>strdup()</code></a> to duplicate the string and store that, or just use arrays rather than pointers and <code>strcpy()</code> the text in.</p>

<p>Also, since you can be pretty sure that your line won't start with <em>both</em> <code>'n'</code> and <code>'m'</code>, the second <code>if</code> should be an <code>else if</code>. Your handling of upper/lower case there seems dubious, too (<code>'n</code>' doesn't equal <code>'N'</code>).</p>
",0
34981930,34981674,2,"<p>This code should work for what you want to do :</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    int num = 0;
    char c = '#';
    char readLine[50];

    while ((fgets(readLine, sizeof readLine, stdin) != NULL) &amp;&amp; sscanf(readLine, ""%d"", &amp;num) == 1)
    {
        for (int i=0;i&lt;num;i++){
                printf(""%c"",c);
        }
        printf(""\n"");
        fflush(stdout);
    }
    return 0;
}
</code></pre>

<p>The behaviour of this code is the following : fgets will read anything you enter in the standard stream (stdin), and put it in the readLine array. The program will then try to read the number which is in your readLine variable and put it in your num variable with the sscanf function. If a number is read, the program will execute the behaviour you did present in your question (writing a # character ""num"" times), and go back to the beginning of the loop. If anything else than a number has been read, the loop is stopped.</p>
",1
34982911,34981674,0,"<p>In general, avoid <code>scanf</code>.  It's very easy to leave yourself with unprocessed cruft on the input stream.  Instead, read the whole line and then use <code>sscanf</code> (or something else) to process it.  This guarantees that you won't get stuck with a partially read line, those are hard to debug.</p>

<p>I prefer <code>getline</code> to <code>fgets</code> to read lines.  <code>fgets</code> requires you to guess how long the input might be, and input might get truncated.  <code>getline</code> will allocate the memory to read the line for you avoiding buffer overflow or truncation problems.</p>

<p>NOTE: <a href=""https://stackoverflow.com/questions/13112784/undefined-reference-to-getline-in-c""><code>getline</code> is it's not a C standard function, but a POSIX one</a> and fairly recent (2008), though it was a GNU extension well before that.  Some older compilers may not have it.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    char c = '#';
    char *line = NULL;
    size_t linelen = 0;

    /* First read the whole line */
    while( getline(&amp;line, &amp;linelen, stdin) &gt; 0 ) {
        /* Then figure out what's in it */
        long num = 0;
        if( sscanf(line, ""%ld"", &amp;num) &gt; 0 ) {
            for( int i = 0; i &lt; num; i++ ) {
                printf(""%c"", c);
            }
            printf(""\n"");
        }
    }

    free(line);

    return 0;
}
</code></pre>

<p><code>if( sscanf(line, ""%ld"", &amp;num) &gt; 0 ) {</code> will ignore any line that does not match any part of the pattern, such as a blank line or a line full of words, by checking how many things matched.  Yet it will still handle <code>0</code> as a valid input.</p>

<pre><code>$ ./test
foo
bar
foo123
12
############

1
#
0

2
##
</code></pre>

<p>I also moved <code>num</code> inside the loop to guarantee it's reinitialized each iteration, and on the general principle of putting your variables in minimum scopes to avoid interference.  And I upgraded it to a <code>long int</code> better able to handle the unpredictably large numbers users might type in.</p>
",0
34983584,34981674,0,"<p>Here is how I have done input parsing over the years using the fgets() and sscanf() functions.  I don't write c++ much, and if I can I keep code within old style ansi C then I do.
The fgets and sscanf functions from the stdio.h library are universal and are always available on any platform.</p>

<p>For a character array used to read in anything, I generally set LINE_SIZE to 256 or 512 even if I know typically the line to be read is 80 characters or less.  With any computer today having over 1GB of RAM, not worth worrying about allocating an extra 500 or so bytes.  Obviously, if you have no idea how long the input line is then you either have to:</p>

<p>guess at what LINE_SIZE should be set to and not worry about it</p>

<p>or verify a newline character is present in line[] prior to a null character after calling fgets().</p>

<pre><code># include &lt;stdio.h&gt;

# define LINE_SIZE  256

int main ( int argc, char *argv[] )
{
    FILE *fp;
    char line[LINE_SIZE];
    int nn;
    int value;

    fp = fopen( ""somefile"", ""r"" );

    fgets( line, LINE_SIZE, fp );

    /*
        this way to read from standard input (i.e. the keyboard)
        using fgets with stdin prevents compiler warning when using
        deprecated gets function

        fgets( line, LINE_SIZE, stdin );
    */

    if ( line[0] != '\n' )
    {
        /* definitely not a blank line */

        nn = sscanf( line, ""%d"", &amp;num );

        if ( nn == 1 )
        {
            /* some number placed into num variable that met the
               %d conversion for the sscanf function
            */
        }
    }
    return 0;
</code></pre>
",0
41908526,41906172,1,"<p>As commented above, in <strong>C Langage</strong>, functions from Library have a strict format and using not that expected format will occur warning or error at compilation time or runtime.</p>

<p><strong>Function 1</strong> - the <code>printf()</code> is the common function to write C strings to the standard output <code>stdout</code> (declared in <code>&lt;stdio.h&gt;</code>).</p>

<blockquote>
  <p>See the <a href=""https://www.tutorialspoint.com/c_standard_library/c_function_printf.htm"" rel=""nofollow noreferrer"">C library function - printf()</a></p>
</blockquote>

<pre><code>int printf(const char *format, ...)
</code></pre>

<p>In the provided source code, the <code>printf()</code> function has been used in the following cases:</p>

<ol>
<li><code>printf(""It work\n"");</code> to write a fixed string which complies with the <code>const char *</code> expected format of the first parameter ==> <strong>OK</strong>,</li>
<li><code>printf(var1);</code> to write the content of the entered string <code>var1</code> (declared as <code>char var1[100];</code>) which not exactly complies with <code>const char *</code> of the first parameter but will be cast during compile time. A proposed format to write the <code>var1</code> string could be <code>printf(""%s"",var1);</code> (or more verbose <code>printf(""var1: %s"",var1);</code>) where the first parameter <code>""%s""</code> will specify that the following argument <code>var1</code> will be a string.</li>
<li><code>printf(f);</code> to write the content of the random value (declared as <code>char f;</code>) which doesn't comply with <code>const char *</code> of the first parameter and doesn't compile at all. The minimal expected format to write the <code>f</code> character is <code>printf(""%c"",f);</code> (or more verbose <code>printf(""f=%c"",f);</code>) where the first parameter <code>""%c""</code> will specify that the following argument <code>f</code> will be a character.</li>
</ol>

<p><strong>Function 2</strong> - the <code>strcmp()</code> is a function to compare two C strings parameters (declared in <code>&lt;string.h&gt;</code>.</p>

<blockquote>
  <p>See the <a href=""https://www.tutorialspoint.com/c_standard_library/c_function_strcmp.htm"" rel=""nofollow noreferrer"">C library function - strcmp()</a></p>
</blockquote>

<pre><code>int strcmp(const char *str1, const char *str2)
</code></pre>

<p>In the provided source code, the <code>strcmp()</code> function has not been used as specified. The function expects two input parameters:</p>

<ol>
<li>First parameter of <code>strcmp(var1,...)==0</code> is <code>var1</code> (declared as <code>char var1[100];</code>) which not exactly complies with <code>const char *</code> but will be cast during compile time.</li>
<li>Second parameter of <code>strcmp(...,f)==0</code> is <code>f</code> (declared as <code>char f;</code>) which doesn't comply with <code>const char *</code> and doesn't compile at all.</li>
</ol>

<blockquote>
  <p>To compare the character <code>f</code> with <code>var1</code>, it shall be necessary to
  convert it to a string (In C, a string is an array of <code>char</code> ended by
  a  character).</p>
</blockquote>

<p><strong>Solution 1</strong> - how to convert the character <code>char f;</code> to a string.</p>

<p>A C string is an array of characters: <code>char str_f[]= { '&lt;char&gt;', ... , '&lt;NUL&gt;' };</code>. Meaning that a minimal array of 2 characters is necessary to convert the character <code>char f;</code> to a string.</p>

<pre><code>char f = rand() % 38;
// use a 2 characters string
char str_f[2] = { f, '\0' };
// Could be also initialised as str_f[0] = f; str_f[1] = '\0'; 

// compare the strings using `str_f`
if (strcmp(var1,str_f)==0) {
</code></pre>

<p><strong>Warning 1</strong> - be careful to the random value range.</p>

<blockquote>
  <p>When printing characters, a C string is supposed to be filled by ASCII
  characters different from  which is used to end the string.</p>
</blockquote>

<p>In the provided source code, the assignment of <code>f</code>, <code>char f = rand() % 38;</code>, will generate values from 0 to 37 which include the  character and the first 31 non-printable characters (ctrl-characters). Only characters greater than 31 will be displayed.</p>

<blockquote>
  <p>In will be more easy to generate: <code>char f = ' ' + (rand() % 38);</code>
  where <code>' '</code> is the first printable ASCII character <code>= 32</code>.</p>
</blockquote>
",10
34971314,34971166,0,"<p>You are reading answers with the wrong <code>scanf</code> format: <code>%s</code> reads a word from <code>stdin</code> and stores it to the <code>char</code> array for which it recieves a pointer.  You pass the address of a single <code>char</code>. You should write:</p>

<pre><code>char answer1;

scanf("" %c"", &amp;answer1);
if (answer1 == 'A' || answer1 == 'a')
    score++;
</code></pre>

<p>And so on for all the other answers.</p>

<p>Note that <code>score</code> should be defined as an <code>int</code> and initialized to <code>0</code>.</p>

<p>Here is a corrected version:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void) {
    int score = 0;
    char answer1, answer2, answer3, answer4, answer5;
    char answer6, answer7, answer8, answer9, answer10;
    char answer11, answer12, answer13, answer14, answer15;
    char answer16, answer17, answer18, answer19, answer20;
    char answer21, answer22, answer23, answer24, answer25;

    printf(""\nDirection: Choose the letter of the correct answer"");
    printf(""\n \n1. What is the REAL name of BILL GATES?"");
    printf(""\nA. William Henry Bill Gates III \tB.Steve Jobs  \tC. William Henry Bill Gates  \tD. William Henry Bill Gates II"");
    printf(""\nAnswer?"");
    scanf("" %c"", &amp;answer1);
    if (answer1 == 'A' || answer1 == 'a') score++;
    printf(""\n2. Bill Gates was born in?"");
    printf(""\nA.Washington DC \tB. Seattle, Washington \tC. United States of America \tD. Los Angles, California"");
    printf(""\nAnswer?"");
    scanf("" %c"", &amp;answer2);
    if (answer2 == 'B' || answer2 == 'b') score++;
    printf(""\n3. Who was the Co-Founder of Windows?"");
    printf(""\nA. Ray Allen \tB. Paul Allen  \tC. Patrick Allen \tD. Leandro Allen"");
    printf(""\nAnswer?"");
    scanf("" %c"", &amp;answer3);
    if (answer3 == 'B' || answer3 == 'b') score++;
    printf(""\n4. When did the first WINDOWS launched?"");
    printf(""\nA. December 20, 1985 \tB. October 20, 1985 \tC. November 20, 1985 \tD. December 31, 1998"");
    printf(""\nAnswer?"");
    scanf("" %c"", &amp;answer4);
    if (answer4 == 'C' || answer4 == 'c') score++;
    printf(""\n5. What is the REAL name of STEVE JOBS?"");
    printf(""\nA. Steven Paul  Jobs \tB. Paul Leandro Lanot \tC. Steven Paul Jobs II \tD. Steve Paul Jobs"");
    printf(""\nAnswer?"");
    scanf("" %c"", &amp;answer5);
    if (answer5 == 'A' || answer5 == 'a') score++;
    printf(""\n6. Three states of matter."");
    printf(""\nA.density, volume and weight  \tB. solid, liquid, and gas \tC. water, metal and gases \tD. water, air and gases"");
    printf(""\nAnswer?"");
    scanf("" %c"", &amp;answer6);
    if (answer6 == 'B' || answer6 == 'b') score++;
    printf(""\n7. The temperature at which a substance changes from a liquid to a gas."");
    printf(""\nA. Freezing point   \tB. Melting point \tC.Boiling point \tD. Condensation point"");
    printf(""\nAnswer?"");
    scanf("" %c"", &amp;answer7);
    if (answer7 == 'C' || answer7 == 'c') score++;
    printf(""\n8.The temperature at which a substance changes from a liquid to a solid"");
    printf(""\nA. Freezing point \tB.Boiling point \tC. Melting point \tD. Condensation point"");
    printf(""\nAnswer?"");
    scanf("" %c"", &amp;answer8);
    if (answer8 == 'A' || answer8 == 'a') score++;
    printf(""\n9. Anything that has definite volume but no definite shape."");
    printf(""\nA.  Solid  \tB. Metal \tC. Liquid \tD. Gas"");
    printf(""\nAnswer?"");
    scanf("" %c"", &amp;answer9);
    if (answer9 == 'B' || answer9 == 'b') score++;
    printf(""\n10. The amount of space something takes up."");
    printf(""\nA. Density \tB. Volume \tC. Mass \tD. Length"");
    printf(""\nAnswer?"");
    scanf("" %c"", &amp;answer10);
    if (answer10 == 'B' || answer10 == 'b') score++;
    printf(""\n11. The temperature at which a substance changes from a gas to liquid."");
    printf(""\nA. boiling point \tB. condensation point \tC. freezing point \tD. melting point"");
    printf(""\nAnswer?"");
    scanf("" %c"", &amp;answer11);
    if (answer11 == 'B' || answer11 == 'b') score++;
    printf(""\n12. The temperature at which a substance changes from a solid to a liquid."");
    printf(""\nA. Condensation point \tB. boiling point \tC. freezing point \tD. Melting point"");
    printf(""\nAnswer?"");
    scanf("" %c"", &amp;answer12);
    if (answer12 == 'D' || answer12 == 'd') score++;
    printf(""\n13. Which of Newton's Three Laws does the following statement satisfy? For every action there is an equal and opposite reaction."");
    printf(""\nA. Newton's First Law \tB. Newton's Second Law \tC. Newton's Third Law \tD. All of the above"");
    printf(""\nAnswer?"");
    scanf("" %c"", &amp;answer13);
    if (answer13 == 'C' || answer13 == 'c') score++;
    printf(""\n14. Which of Newton's Three Laws does the following statement satisfy? Every object in a state of uniform motion tends to remain in that state of motion unless an external force is applied to it."");
    printf(""\nA. Newton's First Law \tB. Newton's Second Law \tC. Newton's Third Law \tD.  All of the above"");
    printf(""\nAnswer?"");
    scanf("" %c"", &amp;answer14);
    if (answer14 == 'A' || answer14 == 'a') score++;
    printf(""\n15. Which of Newton's three laws does the following example illustrate? If you have a hockey puck sliding along a table, it will eventually come to a stop."");
    printf(""\nA. Newton's First Law \tB. Newton's Second Law \tC. Newton's Third Law \tD.  All of the above"");
    printf(""\nAnswer?"");
    scanf("" %c"", &amp;answer15);
    if (answer15 == 'A' || answer15 == 'a') score++;
    printf(""\n16. In the following example, what are the forces that are acting on the ball? Check all that apply. If a ball is thrown in the air, it will keep going the same velocity unless a force changes the velocity (speed and direction)."");
    printf(""\nA. air friction \tB. gravity \tC. resistance of the ground \tD. all of the above"");
    printf(""\nAnswer?"");
    scanf("" %c"", &amp;answer16);
    if (answer16 == 'D' || answer16 == 'd') score++;
    printf(""\n17. Which law states the need to wear seatbelts?"");
    printf(""\nA. Newton's First Law \tB. Newton's Second Law \tC. Newton's Third Law \tD.  None of the above"");
    printf(""\nAnswer?"");
    scanf("" %c"", &amp;answer17);
    if (answer17 == 'A' || answer17 == 'a') score++;
    printf(""\n18.What is another name for the Newton's first law of motion?"");
    printf(""\nA.Law of Acceleration \tB.Law of Velocity \tC.Law of Inertia \tD.Law of Mass"");
    printf(""\nAnswer?"");
    scanf("" %c"", &amp;answer18);
    if (answer18 == 'C' || answer18 == 'c') score++;
    printf(""\n19.Which of Newton's Three Law does the following example illustrate? The blood in your head rushes to your feet when riding on an elevator this is descending and abruptly stops. "");
    printf(""\nA. Newton's First Law \tB. Newton's Second Law \tC. Newton's Third Law \tD.  None of the above"");
    printf(""\nAnswer?"");
    scanf("" %c"", &amp;answer19);
    if (answer19 == 'A' || answer19 == 'a') score++;
    printf(""\n20. A triangle with one angle greater than 90 degrees."");
    printf(""\nA. equilateral triangle \tB. obtuse triangle \tC. acute triangle \tD. isosceles triangle"");
    printf(""\nAnswer?"");
    scanf("" %c"", &amp;answer20);
    if (answer20 == 'B' || answer20 == 'b') score++;
    printf(""\n21. A triangle with all three angles less than 90 degrees."");
    printf(""\nA. equilateral triangle \tB. obtuse triangle \tC. acute triangle \tD. isosceles triangle"");
    printf(""\nAnswer?"");
    scanf("" %c"", &amp;answer21);
    if (answer21 == 'C' || answer21 == 'c') score++;
    printf(""\n22.A triangle with one angle equal to 90 degrees."");
    printf(""\nA.right triangle \tB.equilateral triangle \tC. acute triangle \tD. isosceles triangle"");
    printf(""\nAnswer?"");
    scanf("" %c"", &amp;answer22);
    if (answer22 == 'A' || answer22 == 'a') score++;
    printf(""\n23.A triangle having three equal sides."");
    printf(""\nA. equilateral triangle \tB. obtuse triangle \tC. acute triangle \tD. right triangle"");
    printf(""\n23.Answer?"");
    scanf("" %c"", &amp;answer23);
    if (answer23 == 'D' || answer23 == 'd') score++;
    printf(""\n24.The sum of the measures of all three sides of a triangle."");
    printf(""\nA.area \tB. perimeter \tC. diameter \tD.none of the above"");
    printf(""\nAnswer?"");
    scanf("" %c"", &amp;answer24);
    if (answer24 == 'B' || answer24 == 'b') score++;
    printf(""\n25.In right triangle, the side opposite to right angle is called"");
    printf(""\nA. altitude \tB.hypotenuse \tC. angle bisector \tD.none of the above"");
    printf(""\nAnswer?"");
    scanf("" %c"", &amp;answer25);
    if (answer25 == 'B' || answer25 == 'b') score++;

    printf(""\n\t\tTEST Score=%d\n"", score);
    return 0;
}
</code></pre>
",6
36420777,36420655,0,"<p>You will have to use nested loop. </p>

<pre><code>int p = fact(10);
for(int i = 1; i &lt;= 10; i++){
   for(int j = 1; j &lt;= 10; j++){
       if(fact(i) + fact(j) == p){
         a[0] = i;
         a[1] = j;
         return a;
      }
  }
} 
</code></pre>

<p>You can implement fact function which will be used to calculate the factorial of an integer .</p>
",0
36420917,36420655,0,"<p>You can return a pointer like you wanted : </p>

<pre><code>int * solve10(){
    //your code assigning x and y
    int * returnValue = malloc(2 * sizeof (int));
    returnValue[0]=x;
    returnValue[1]=y;
    return returnValue;
}
</code></pre>
",0
46634880,46634854,0,"<p>It adds a null character (<code>'\0'</code>) to the end of the string you read in. Without it, printing the value in <code>buffer</code> might go past the end of <code>""hello""</code> and potentially print garbage values.</p>
",0
46634885,46634854,0,"<p>The '\0' character is known as the string terminator. This lets string functions know that the string in the area of memory you pass to it is done. This helps avoid reading too far in memory.</p>
",0
46634886,46634854,1,"<p>It makes sure there is a NUL character to terminate a C-style string, to make it safe for use with <code>printf</code>: <a href=""https://en.wikipedia.org/wiki/Null-terminated_string"" rel=""nofollow noreferrer"">https://en.wikipedia.org/wiki/Null-terminated_string</a></p>

<p>In C++ there are better types, like <code>std::string</code>:</p>

<p><strong><kbd><a href=""http://coliru.stacked-crooked.com/a/89a58d9d616912ee"" rel=""nofollow noreferrer"">Live On Coliru</a></kbd></strong></p>

<pre><code>#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;cstdio&gt;
#include &lt;array&gt;
#include &lt;iostream&gt;

int main(int argc, char *argv[]) {

    if (argc &lt; 2)
        return -1;

    std::array&lt;char, 6&gt; buffer;
    printf(""%s\n"", argv[1]);

    int fh = open(argv[1], O_RDONLY);

    printf(""File handle %d\n"", fh);

    while (int gotten = read(fh, buffer.data(), buffer.size())) {
        std::cout.write(buffer.data(), gotten);
    }
}
</code></pre>
",0
46634888,46634854,0,"<p>Null terminates the string. </p>

<p><code>'\0'</code> is the null-termination character. <code>gotten</code> is set by the <code>read()</code> function which will return the number of characters read so <code>buffer[gotten]</code> will be the next spot in the array (since it's 0-based).</p>

<p>The null-termination allows C to know when the string ends. Since you are reusing the buffer for every read it's impossible to know what will be in the buffer beforehand so manually null-terminating is the best option.</p>
",0
46634891,46634854,0,"<p>Strings in <a href=""/questions/tagged/c"" class=""post-tag"" title=""show questions tagged &#39;c&#39;"" rel=""tag"">c</a> are <code>char</code> arrays where the last character of the string is the <code>\0</code> character which marks the end of the string. Since reading the characters from the file doesn't include the <code>\0</code> character, it needs to be added manually so it can be treated as a normal string.</p>
",0
46634896,46634854,0,"<p>In C, <code>char</code> strings are really called <strong><em>null terminated</strong> character strings</em>. That <code>'\0'</code> character is the ""null terminator"" (not to be confused with a null pointer).</p>

<p>If that's missing, all standard string functions will not work, as they will go out of bounds looking for it.</p>

<p>Because of the terminator, any string of e.g. 6 characters need space for at least <em>7</em> characters, to able to fit the terminator.</p>
",0
35193036,35192736,0,"<ul>
<li>It will execute like this;</li>
<li><p>First it is considers like this, </p>

<pre><code>y = (++i * ++i) * ++i // so first i is incremented to 4 and again it will incremented to 5.
</code></pre></li>
<li><p>So now first expression will executed like this</p>

<pre><code>y = (5 * 5) * ++i; 
y = 25 * ++i;
</code></pre></li>
<li><p>Now again i is incremented to 6 and final expression is like this,</p>

<pre><code>y = 25 * 6;
y = 150;
</code></pre></li>
</ul>
",0
35247809,35247566,1,"<p>the posted code contains a few problems.  including undefined behaviour.</p>

<p>Caveat: this code assumes the parameter <code>str</code> points to a NUL terminated string.</p>

<pre><code>#include &lt;stdio.h&gt;  // printf()
#include &lt;stdlib.h&gt; // exit(), EXIT_FAILURE
#include &lt;string.h&gt; // strlen(), malloc()

char * cut(char *str, char *symbol)
{
    char *temp = NULL;
    if( NULL == (temp = malloc( strlen(str)+1) ) )
    { // then malloc failed
        perror( ""malloc failed"" );
        exit( EXIT_FAILURE );
    }

    // implied else, malloc successful

    int i;
    for(i=0; str[i] &amp;&amp; str[i] !=symbol[0]; i++)
    {
        temp[i]=str[i];
    }

    // terminate string
    temp[i] = '\n';

    printf(""temp %s\n"",temp);
    return temp;
}
</code></pre>

<p>However, the question says to return the first word AND the rest of the string which neither the posted code nor my answer implement</p>
",3
34910693,34910561,1,"<p>A reasonable comment for <code>towers</code> would be:</p>

<blockquote>
  <p>Move <em>num</em> discs from peg <em>frompeg</em> to peg <em>topeg</em> (the remaining peg being <em>auxpeg</em>)</p>
</blockquote>

<p>Then recursive section says to:</p>

<ol>
<li><p>Move <em>num-1</em> discs from peg <em>frompeg</em> to peg <em>auxpeg</em> (the remaining peg being <em>topeg</em></p></li>
<li><p>Move disc from peg <em>frompeg</em> to peg <em>topeg</em>.</p></li>
<li><p>Move <em>num-1</em> discs from peg <em>auxpeg</em> to peg <em>topeg</em> (the remaining peg being <em>frompeg</em></p></li>
</ol>
",0
34929572,34928825,2,"<p>I am not exactly sure what you want to achieve.</p>

<p><code>printf</code> will treat a parameter as a type you want using % format specifier.</p>

<p>So if you have entered some value which is interpreted as signed decimal integer you can print it treating as a different type with the <code>printf</code> function.</p>

<p>If you want your <code>m</code> variable being printed as character do: </p>

<p><code>printf(""The number as a character is %c"", m);</code></p>

<p>If you want to display it as a <code>float</code>, use <code>%f</code>.</p>

<p>Here is some reference:
<a href=""http://www.cplusplus.com/reference/cstdio/printf/"" rel=""nofollow"">http://www.cplusplus.com/reference/cstdio/printf/</a></p>
",1
34929018,34928825,1,"<p>You're probably looking at the <code>printf</code> formats</p>

<pre><code>#include &lt;stdio.h&gt;

int main (void)
{
    int m;

    printf(""Please enter an integer : "");
    scanf(""%d"", &amp;m);

    printf(""The number as a character is : '%c' %02X %o %d %f"", m, m, m, m, (float) m);

    return 0;
}
</code></pre>
",0
38192170,31542494,0,"<pre><code>#include&lt;stdio.h&gt;
int main()
{
    int i,nb=0;
    char sent[100];

    printf(""Enter a sentence: "");

    for(i=0;(sent[i]=getchar())!='\n';i++)
    {
        if(sent[i]==' ')
        {
            nb++;
            if(nb&gt;=2)
            {
                i--; 
                nb--;
            }
        }
        if(sent[i]!=' ')
        nb=0;
    }

    sent[i]='\0';

    printf(""\nResult: "");

    for(i=0;sent[i]!='\0';i++)
    {
        putchar(sent[i]);
    }

    return 0;
}
</code></pre>

<p>Answer of same question, I did this without using EOF. Especially for mobile users who can't use 'Ctrl+D'.</p>
",0
36322747,36322685,2,"<p>There's a good reason why you'd always get 1. Observe that</p>

<pre><code>word_count[word-1]=+1; // This assigns to the value ""+1""!`
</code></pre>

<p>should be</p>

<pre><code>word_count[word-1]+=1; // This increments your array item`
</code></pre>

<p>It's a bugger what compiles in C :).</p>
",2
35205404,35203825,1,"<p>Code is missing prototypes.</p>

<p>That is all, format is OK, functions are OK.</p>

<pre><code>#include&lt;stdio.h&gt;

// Add these to the same file as main() 
// Or better yet, add to another file Compute.h and #include ""Compute.h"" 
// here and in the the separate C file
double ComputeMinimum(double num1, double num2);
double ComputeMaximum(double num1, double num2);

int main(void)
  ...

  // suggest adding check
  if (2 != scanf(""%le%le"", &amp;num1, &amp;num2)) {
    puts(""Input error"");
    return -1;
  } 
</code></pre>
",0
37770368,37770362,6,"<p>The problem is in your print statement.  You are printing the address of a, not the value.  Use <code>print(""%d"",a);</code></p>
",2
37770370,37770362,2,"<p>The <code>%d</code> format specifier for <code>printf</code> expects an <code>int</code>, not an <code>int *</code>:</p>

<pre><code>printf(""%d"",a);
</code></pre>

<p>It's not attempting to write to <code>a</code>, so it doesn't need its address.</p>

<p>If you compile with the warning level turned up (<code>-Wall -Wextra</code> for gcc), it will tell you this:</p>

<pre><code>format ¡®%d¡¯ expects type ¡®int¡¯, but argument 2 has type ¡®int *¡¯
</code></pre>
",0
37770588,37770362,0,"<p>scanf needs a pointer to the variable if it is going to    change the variable itself, so we use the address-of operator to get the pointer.</p>

<p>scanf()  received ""%d"", as a parameter and then knows it needs to read an integer and store it in the next variable in the argument list.</p>

<pre><code>    #include&lt;stdio.h&gt;
    #include&lt;stdlib.h&gt;

    int main(void)
    {
     int a = 0;
     printf(""Enter a number: "");
     scanf (""%d"" ,&amp;a);
     printf (""%d \n "",a);
return 0;
}
</code></pre>
",0
34968554,34968446,0,"<p>For the split part I would recommend this version, it is easier to understand (considering that you've learned the <code>for</code> way of working). It does the same thing, but helps you organize your code.</p>

<pre><code>char *p;
int i;
    for(p = strtok(sentence, "" ""); p != NULL; p = strtok(NULL, "" ""))
    {
        int isNumber = 1;
        for(i = 0; i &lt; strlen(p); i ++)
        {
            if(!isDigit(p[i])
            {
                isNumber = 0;
                break;
            }
        }
        if(isNumber == 1)
        {
            int number = atoi(pch);
            number *= 2;
            printf(""%d\n"", number);
        }
        else
        {
            printf(""%s\n"", p);
        }
    }
</code></pre>

<p>For the number, I would recommend using the <code>atoi</code> function. <a href=""http://www.tutorialspoint.com/c_standard_library/c_function_atoi.htm"" rel=""nofollow"">Here</a> you have a good reference.</p>

<p>To solve your problem, first of all, you need to check every single word you get. For example: You take it word by word and see if the ""word"" contains ONLY digits. If it contains only digits, you can use <code>atoi</code> to convert it to a number, multiply it by 2 and print the result.</p>

<p>On the other hand, if you find a char that is NOT a digit, you have letters or any other characters in your word, so it is not a word so you simply print that as it is.</p>
",3
34968557,34968446,0,"<p>Here is a working example, even if it's not really precise. Basically, we need to find out whether our current string is a number or not. In this case, I just tried to get the first element of the current string, and tried to determine if it's numeric or not.</p>

<p>Of course, if you want to be <em>really</em> sure, we need to iterate the string and check every char, if it is a number or not.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

void main()
{
    char sentence[100];

    printf(""Enter a sentence to split: "");
    scanf(""%[^\n]s"", sentence);
    char * pch;
    int y;
    y = atoi(sentence);
    printf(""After splitting:\n"", sentence);
    pch = strtok (sentence,"" "");
    while (pch != NULL)
    {
        if(isdigit(pch[0]))
        {
            int number = atoi(pch);
            number *=2;
            printf(""%d\n"",number);
            pch = strtok (NULL, "" "");
            continue;
        }
        printf(""%s\n"",pch);
        pch = strtok (NULL, "" "");
    }

    system(""PAUSE"");
}
</code></pre>
",8
34968658,34968446,0,"<p>Here's another (more compact) answer:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;

int is_numeric(char *s)
{
    int i = 0;
    while (s[i] != '\0') {
        if (!isdigit(s[i]))
            return 0;
        ++i;
    }
    return 1;
}

int main()
{
    char sentence[255];
    char *pch;

    printf(""Enter a sentence to split: "");
    if (!fgets(sentence, sizeof(sentence), stdin)) {
        return 1;
    }
    sentence[strcspn(sentence, ""\n\r"")] = 0; /* Strip newline */

    pch = strtok(sentence, "" "");
    while (pch != NULL) {
        if (atoi(pch)) {
            printf(""%d\n"", 2 * atoi(pch));
        } else {
            printf(""%s\n"", pch);
        }
        pch = strtok(NULL, "" "");
    }
    return 0;
    /* system(""PAUSE""); */
}
</code></pre>

<p>The key is that atoi will return 0 for a non-numeric argument. </p>
",2
34968695,34968446,1,"<p>Here is a simpler version with a test for all digit numbers:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main(void) {
     char sentence[100];
     char *pch;

     printf(""Enter a sentence to split: "");
     if (!fgets(sentence, sizeof sentence, stdin))
          return 1;

     printf(""After splitting:\n"");
     for (pch = strtok(sentence, "" \n""); pch != NULL; pch = strtok(NULL, "" \n"")) {
         if (pch[strspn(pch, ""0123456789"")] == '\0') {
             printf(""%d\n"", atoi(pch) * 2);
         } else {
             printf(""%s\n"", pch);
         }
     }
     system(""PAUSE"");
     return 0;
}
</code></pre>

<p>If you want to parse floating point numbers too, you could use this code:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;

int main(void) {
     char sentence[100];
     char *pch, *pend;
     double value;

     printf(""Enter a sentence to split: "");
     if (!fgets(sentence, sizeof sentence, stdin))
          return 1;

     printf(""After splitting:\n"");
     for (pch = strtok(sentence, "" \n""); pch != NULL; pch = strtok(NULL, "" \n"")) {
         value = strtod(pch, &amp;pend);
         if (*pend == '\0' &amp;&amp; isfinite(value)) {
             printf(""%g\n"", value * 2);
         } else {
             printf(""%s\n"", pch);
         }
     }
     system(""PAUSE"");
     return 0;
}
</code></pre>

<p>Note the test for <code>isfinite()</code> to avoid recognizing <code>inf</code> and <code>nan</code> as numbers.</p>

<p>NOTE: <code>isfinite</code> is part of C99, it is not supported by VisualStudio 12, but more recent versions do support it.  For this older version, use <code>_finite()</code> defined in <code>&lt;float.h&gt;</code>.</p>
",5
34973634,34972420,0,"<p>On <em>client</em> side, after printing received answer you're closing <code>clientFd</code> and not trying to reconnect for further use. In fact for second time <code>write</code> is doing on a closed file descriptor. One solution is this:</p>

<pre><code>while (1) {
    /* Create a socket, bidirectional, default protocol */
    clientFd = socket(AF_LOCAL, SOCK_STREAM, DEFAULT_PROTOCOL);

    do { /* Loop until a connection is made with the server */
        result = connect(clientFd, serverSockAddrPtr, serverLen);
        printf(""Attempting to connect...\n"");
        if (result == -1) sleep(1); /* Wait and then try again */
    } while (result == -1);

    char country[300];

    printf(""%s \n"", "" "");
    printf(""Please enter country &gt; "");
    fflush(stdout);
    fgets(country, sizeof(country), stdin);
    printf(""%s \n"", "" "");

    if (0 == strcmp(country, ""end\n"")) {
        printf(""Thank you for using country services\n"");
        exit(0);
    } else {
        write(clientFd, country, strlen(country));
        parse(clientFd);
    }

    close(clientFd);
    printf(""%d\n"", clientFd);
    clientFd = 0;
 }
</code></pre>
",1
37693403,37693297,0,"<p>Assuming you are using C++, there are couple of things that you need to change in your code:</p>

<ol>
<li><code>scanf(""%d"", tcs);</code> should rather be <code>scanf(""%d"", &amp;tcs);</code>  This mistake is the reason your program crashes, as <code>tcs</code> doesn't have the correct intended value.</li>
<li>The function <code>int calc_fact(n)</code> should be outside the main() function with the prototype <code>int calc_fact(int n)</code>.  Due to this mistake, your code won't compile in the first place (are you sure when you say that your code complies when the arrays are declared statically)?</li>
</ol>

<p>Please see the modified code below:</p>

<pre><code>#include &lt;stdio.h&gt;
//#include &lt;conio.h&gt;                    //You actually don't need it.

int calc_fact(int n)
{
    if(n==1)
        return 1;
    else
        return n*calc_fact(n-1);
}

int main()
{
    int n, i, count, k, tcs, j, l, m;
    scanf(""%d"", &amp;tcs);
    int fact[tcs];
    int arr[tcs];
    for(j=0; j&lt;tcs; j++)
    {
        scanf(""%d"", &amp;arr[j]);
    }

    j=0;
    m=0;
    while(m&lt;tcs &amp;&amp; j&lt;tcs)
    {
        fact[m]=calc_fact(arr[j]);
        m++;
        j++;
    }


    m=0;
    for(l=0; l&lt;tcs; l++)
    {
        i=1;
        count=0;
        while(i&lt;=fact[m])
        {
            if((fact[m])%i==0)
            count++;
            i++;
        }
    m++;
    k=(count)%((10^9)+7);
    printf(""%d\n"", k);            //and not printf(""\n%d"", k);

    }

    return 0;
}
</code></pre>

<p>Working code <a href=""http://ideone.com/hxCzc3"" rel=""nofollow""><strong>here</strong></a>.</p>
",2
35257541,35257538,1,"<p>Because of integer division, change <code>5 / 9</code> to <code>5.0 / 9.0</code>. Also, make <code>Fahrenheit</code> <code>double</code> and change <code>scanf()</code> to</p>

<pre><code>if (scanf(""%lf"", &amp;Fahrenheit) == 1)
{
    Celcius = 5.0 * (Fahrenheit - 32.0) / 9.0;
    printf(""Your temperature in celsius is %3.2f.\n"", Celsius);
}
</code></pre>

<p>Also:</p>

<ol>
<li>There is absolutely no reason to make your variables global.</li>
<li><p>I have seen many peculiar <code>main()</code> signatures and now</p>

<pre><code>double main(void);
</code></pre></li>
<li><p>Ignoring the return value of <code>scanf()</code> would lead to potential undefined behavior. If I had a teacher that forbids <code>if</code> statements but requires <code>scanf()</code> I would quit with him and find a good instructor.</p>

<p>But of course if I was learning how would I know that ignoring ?<code>scanf()</code>'s return value is bad? And that's the sad part, many even don't know that it returns a value or that it fails, for instance try this</p>

<pre><code>int value;
if (scanf(""%d"", &amp;value) != 1)
    fprintf(stderr, ""Error, invalid input\n"");
else
    fprintf(stdout, ""Ok, so your input is `%d'\n"", value);
</code></pre>

<p>type <code>""abcd""</code> instead of a number, what happens?</p></li>
</ol>
",10
35217252,35217166,3,"<p>This...</p>

<pre><code>printf (""\n second_equation\n\n"", second_equation);
</code></pre>

<p>... does not print the <code>second_equation</code> variable: it provides it as an argument to <code>printf</code>, but <code>printf</code> only uses extra arguments as directed by <code>%f</code> or other conversion instructions embedded in the text provided as the first argument.  You could write:</p>

<pre><code>printf (""\n second_equation %f\n\n"", second_equation);
</code></pre>

<p>You may want to do something similar for <code>first_equation</code>.</p>

<p>Alternatively [when I answered the question was tagged C++] you could use C++ I/O routines (<code>scanf</code> and <code>printf</code> are from the C library, and have a number of disadvantages, the most obvious here being that you have to remember funny letter codes like ""lf"" matching your data types)...</p>

<pre><code>#include &lt;iostream&gt;
</code></pre>

<p>...at the very top of your file, then in your function write...</p>

<pre><code>std::cout &lt;&lt; ""\n second_equation "" &lt;&lt; second_equation &lt;&lt; ""\n\n"";
</code></pre>

<p>You could also use C++ I/O for input, replacing <code>scanf</code> with...</p>

<pre><code>if (!(std::cin &gt;&gt; x))
{
    std::cerr &lt;&lt; ""you didn't enter a valid number\n"";
    exit(1);
}
</code></pre>
",0
35217316,35217166,0,"<p>Your code is really unclear; but going by your question, you seem to want to be able to print your answer. In that case, here is the proper syntax</p>

<pre><code>printf (""Answer: %d \n"", yourAnswer); //if 'yourAnswer' is decimal or number
</code></pre>

<p>To use one of your code snippets, you'll have this:</p>

<pre><code>printf (""\n second_equation: %d\n"", second_equation);
</code></pre>
",0
40545546,40545479,1,"<p>No, you cannot achieve this straightaway. When array names are passed to a function as argument, it decays to the pointer to the first element of the array, so from inside the called function, you cannot directly get the size of the original array, in general.</p>

<p>However, if your array has a special sentinel value, then it can work, but that is a conditional scenario.</p>
",1
40545552,40545479,1,"<p>No, the members of structs cannot be referenced as variables. Note that C is a compiled language. At runtime, the information about the identifiers used for members is no longer present.</p>

<p>You would need to use separate functions for each member, such as</p>

<pre><code>size_t getAlphaSize(void) {
    return sizeof(fooBar.alpha);
}
</code></pre>

<p>Also note that <code>sizeof</code> returns an unsigned value of type <code>size_t</code>, not an <code>int</code>.</p>
",1
40545621,40545479,4,"<p>You could do it with a macro:</p>

<pre><code>#define getTest(t) sizeof(fooBar.t)

typedef struct FooBar {
  char alpha[50];
  char beta[50];
} FooBar;

FooBar fooBar;


int main()
{
  int alphasize = getTest(alpha);
}
</code></pre>

<p>But I'm not sure if this fulfills your requirement.</p>
",11
35227667,35227657,1,"<p>To use <code>strcat()</code> you need to have a valid string, an uninitialized array of <code>char</code> is not a valid string.</p>

<p>To make it a valid ""<em>empty</em>"" string, you need to do this</p>

<pre><code>char str[100] = {0};
</code></pre>

<p>this creates an empty string because it only contains the <em>null</em> terminator.</p>

<p>Be careful when using <code>strcat()</code>. If you intend two just concatenate to <em>valid <a href=""/questions/tagged/c"" class=""post-tag"" title=""show questions tagged &#39;c&#39;"" rel=""tag"">c</a> strings</em> it's ok, if they are more than 2 then it's not the right function because the way it wroks.</p>

<p>Also, if you want your code to work, declare the array in <code>main()</code> instead and pass it to the function, like this</p>

<pre><code>void 
func(char *str)
{
    strcat(str, ""aa"");
    printf(""%s\n"", str);
}

int  
main()
{
    char str[100] = {0};

    func(str);
    func(str);
    func(str);

    return 0;
}
</code></pre>
",1
35227751,35227657,1,"<p>There's nothing in the standard that says data on the stack needs to be ""destroyed"" when a function returns.  It's <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow"">undefined behavior</a>, which means anything can happen.  </p>

<p>Some implementations may choose to write zeros to all bytes that were on the stack, some might choose to write random data there, and some may chose to not touch it at all.</p>

<p>On <em>this particular implementation</em>, it appears that it doesn't attempt to sanitize what was on the stack.</p>

<p>After the first call to <code>func</code> returns. The data that was on the stack is still physically there because it hasn't been overwritten yet.  When you then call <code>func</code> again immediately after the first call, the <code>str</code> variable happens to reside in the same physical memory that it did before.  And since no other functions calls were made in the calling function, this data is unchanged from the first call.</p>

<p>If you were to call some other function in between the calls to <code>func</code>, then you'd most likely see different behavior, as <code>str</code> would contain data that was used by whatever other function was called last.</p>
",0
35227948,35227657,0,"<p>Function <code>strcat</code> means to concatenate two <code>strings</code>. So the both arguments of the function must to represent strings. Moreover the first argument is changed.</p>

<p>That a character array would represent a string you can either to initialize it with a string literal (possibly an ""empty"" string literal) or implicitly to specify a zero value either when the array is initialized or after its initialization.</p>

<p>For example</p>

<pre><code>void func(){
    char str1[100] = """";
    char str2[100] = {'\0'};
    char str3[100];
    str3[0] ='\0';
    //...
}
</code></pre>

<p>Take into account that objects with the automatic storage duration are not initialized implicitly. They have indeterminate  values.</p>

<p>As for your question</p>

<blockquote>
  <p>Why local array value isn't destroyed in function?</p>
</blockquote>

<p>then the reason for this is that the memory occupied by the array was not overwritten by other function. However in any case it is undefined behavior.</p>
",0
35228015,35227657,0,"<p>When you declare:</p>

<pre><code>char str[100];
</code></pre>

<p>all you are doing is declaring a character array, but it's random garbage.</p>

<p>So you are effectively appending to garbage.</p>

<p>If you did this instead:</p>

<pre><code>char str[100] = {0};
</code></pre>

<p>Then you will get different results since the string will be null to begin with. Anytime you allocate memory in C, unless you initialize it when you allocate it, it will simply be whatever was in memory in that spot at the time. You cannot assume it will be NULL and zero'ed for you.</p>
",0
35245538,35244833,-1,"<p>Reading your code I found quite a few mistakes, e.g. <code>sizeof(a)</code> doesn't return size of array, because in C there is no standard array type. Only memory allocated to a pointer. So in your case <code>sizeof(a)</code> returns size of pointer <code>a</code>. That's why you always have to keep track of the length of the array by yourself.</p>

<p>Back to your problem though. My simple solution would go like this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char *argv[]){
    int arr[] = {1,1,1,1,2,5,6,8,8,2,5,6,2,1,8,3};
    size_t len = 16;
    // create a new array with the same size as the original
    // since there is no guarantee all of the numbers
    // are not unique
    int *new_array = (int *)calloc(len, sizeof(int)), new_len = 0;

    // loop throught every number
    for (int i = 0; i &lt; len; i++) {
        // if the current number, arr[i], is unique
        int unique = 1;
        // loop backwards to check if any of the previous
        // number are the same as the current one
        for (int j = i - 1; j &gt; -1; j--) {
            // if the same number if found, set unique to 0
            // and break out of loop
            if (arr[i] == arr[j]) {
                unique = 0;
                break;
            }
        }
        // if looped all the way to index 0 without
        // finding the same number, add it to the last index
        // of our new array and increment it's size
        if (unique) {
            new_array[new_len] = arr[i];
            new_len++;
        }
    }
    // finally, if there have been found any duplicated,
    // adjust the memory allocated to the new_array pointer
    if (new_len &lt; len) {
        new_array = (int *)realloc(new_array, sizeof(int) * new_len);
    }

    // when you're done using your new array,
    // free the memory allocated to it
    free(new_array);
    return 0;
}
</code></pre>
",1
35254746,35244833,0,"<p>There are several issues in your code:</p>

<ul>
<li><p><code>sizeof(a)</code> does not evaluate to the number of elements in <code>a</code>, but the size in bytes required for object <code>a</code>.  If <code>a</code> is an array, you can get the number of elements with <code>sizeof(a) / sizeof(a[0])</code>, but if <code>a</code> is a pointer, you cannot determine the number of elements from <code>a</code> alone.</p></li>
<li><p><code>NULL</code> is not a valid value for an <code>int</code>, you cannot use this method for an <code>int</code> array.</p></li>
<li><p>Your comparisons are incorrect: you use the assignment operator <code>=</code> instead of the equality operator <code>==</code>.</p></li>
<li><p>You should declare the function <code>fixArr</code> before calling it from <code>main</code>.</p></li>
</ul>

<p>Here is a simpler version that uses the <em>two finger method</em>: iterating with one index and storing unique elements into the same array with another index:</p>

<pre><code>#include &lt;stdio.h&gt;

int fixArr(int *ptr, int size) {
    int i;  // index for reading (first finger)
    int j;  // index for writing (second finger)
    int k;  // index for searching duplicates

    for (i = j = 0; i &lt; size; i++) {
        for (k = 0; k &lt; j; k++) {
            if (ptr[k] == ptr[i])
                break;
        }
        if (k == j) {  // element ptr[i] was not found
            ptr[j] = ptr[i];  // copy new unique element
            j++;       // increment new element count
        }
    }
    return j;  // new size
}

int main(void) {
    int a[] = { 1, 1, 1, 1, 2, 5, 6, 8, 8, 2, 5, 6, 2, 1, 8, 3 };
    int size = sizeof(a) / sizeof(a[0]);
    int i, newsize;

    printf(""original array:"");
    for (i = 0; i &lt; size; i++) {
        printf("" %d"", a[i]);
    }
    printf(""\n"");

    newsize = fixArr(a, size);

    printf(""fixed array:"");
    for (i = 0; i &lt; newsize; i++) {
        printf("" %d"", a[i]);
    }
    printf(""\n"");
    return 0;
}
</code></pre>
",0
36627765,36627683,4,"<p>The array do save the value in</p>

<pre><code>if(board[j][i]=SYMBOL_EMPTY)return FALSE;
</code></pre>

<p>and only <code>board[0][0]</code> is affected because <code>SYMBOL_EMPTY</code> is non-zero, so the control will return from the function.</p>

<p>Do you mean comparision instead of the assignment? e.g.</p>

<pre><code>if(board[j][i]==SYMBOL_EMPTY)return FALSE;
</code></pre>
",0
36628079,36627683,0,"<p>The comparison expression should be written this way:</p>

<pre><code>const int VAR = 0;

int main(void) {
    if(VAR==3) return 1;
    return 0;
}
</code></pre>

<p>so, if you forget one <code>=</code> you obtain a compilation error:</p>

<pre><code>prog.c: In function 'main':
prog.c:6:9: error: assignment of read-only variable 'VAR'
  if(VAR =3) return 1;
</code></pre>
",0
36628388,36627683,1,"<p>gcc throws up a lot of warnings when compiling this code:</p>

<pre><code>[fbgo448@n9dvap997]~/prototypes/board: gcc -o board -std=c99 -pedantic -Wall board.c
board.c: In function afindEmptyBoxa:
board.c:33: warning: suggest parentheses around assignment used as truth value
board.c: At top level:
board.c:60: warning: return type of amaina is not ainta
board.c: In function amaina:
board.c:64: warning: implicit declaration of function asystema
board.c:61: warning: unused variable aja
board.c:61: warning: unused variable aia
board.c:61: warning: unused variable aya
board.c:61: warning: unused variable axa
</code></pre>

<p>The first warning is complaining about the following:</p>

<pre><code>if(board[j][i]=SYMBOL_EMPTY)return FALSE;
</code></pre>

<p>You are <em>assigning</em> <code>SYMBOL_EMPTY</code> to <code>board[j][i]</code>, not <em>comparing</em> them to each other.  Since <code>SYMBOL_EMPTY</code> is non-zero, the value of the assignment expression is non-zero, so the function immediately returns <code>FALSE</code>.</p>

<p>Change that to</p>

<pre><code>if(board[j][i] == SYMBOL_EMPTY) return FALSE;
</code></pre>

<p>and you'll be able to assign to 0,0. </p>

<p>A common practice when comparing against constant expressions is to put the constant on the left-hand side of the <code>==</code> operator, like so:</p>

<pre><code>if ( SYMBOL_EMPTY == board[i][j] )
</code></pre>

<p>That way, if you accidentally write <code>=</code> instead of <code>==</code>, the compiler will catch it and issue a diagnostic (a constant expression cannot be the target of an assignment statement).  This doesn't help when both operands are variables, and I've never written comparisons this way myself, but it can be helpful.  </p>

<p>The next warning is complaining about</p>

<pre><code>void main()
</code></pre>

<p><code>main</code> returns <code>int</code>, not <code>void</code>; change that to</p>

<pre><code>int main( void )
</code></pre>

<p>While that isn't your main problem (the <code>=</code> instead of <code>==</code> was), it is something you want to fix.  There are some oddball platforms out there that will choke on a program that uses <code>void main()</code>.  </p>

<p>You'll also want to include <code>stdlib.h</code> to get rid of the ""implicit declaration of function system"" warning. </p>

<p>You should also get rid of any unused variables, but that's not critical, and not the problem you're facing right now.</p>
",3
35255324,35253945,2,"<p>Turn off Avast or any other antivirus you currently have for a few minutes while you test your program. </p>

<p>Antivirus software sometimes get stuck analyzing this new executable and never return control back to the OS.</p>

<p>If this solves your issue, add your C projects folder to the exclusion list so you don't have to manually disable/re-enable the antivirus each time you want to run your application.</p>
",1
39652055,39651705,0,"<p><code>entry</code> has to be defined as a pointer. <code>struct dirent* entry</code>. I compiled this on c and it works fine.</p>

<pre><code>#include &lt;dirent.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;

int main( int argc, char **argv )
{
    DIR *dirPos;
    struct dirent* entry;
    struct stat st;
    char *pattern = argv[argc-1];

    //----------------------
    //a few error checks for command line and file opening
    //----------------------

    //Open directory
    if ((dirPos = opendir(""."")) == NULL){
        //error message if null
    }

    //Print entry
    while ((entry = readdir(dirPos)) != NULL){
        if (!strcmp(entry-&gt;d_name, pattern)){
            stat(entry-&gt;d_name, &amp;st);
            printf(""%s\t%d\n"", entry-&gt;d_name, st.st_size);
        }
    }

    return 0;
}
</code></pre>
",3
38307071,38306981,7,"<p>The reverse function is extremely complicated. The better way to go about it would be:</p>

<pre><code>long reverse (long n)
{
    long result = 0;
    while (n != 0)
    {
        result *= 10;
        result += n % 10;
        n /= 10;
    }
    return result;
}
</code></pre>

<p>I think the problem in your code is that in the following segment</p>

<pre><code>  digit++;
  ar[digit] = x;
</code></pre>

<p>you first increment the position then assign to it, thus leaving <code>ar[0]</code> unintialized.</p>
",3
38307549,38306981,2,"<blockquote>
  <p>How can I fix this problem?</p>
</blockquote>

<p>You need to initialize <code>sum</code></p>

<pre><code>long k, sum = 0;
              ^
</code></pre>

<p>See the code from @Armen Tsirunyan for a simpler approach.</p>
",2
37150987,37150839,0,"<p>The character '\b' moves the cursor back one position. The following sequence gets what you want:</p>

<pre><code>printf(""Loading."");
while (not done yet) {
   delay
   printf(""."");
   delay
   printf(""."");
   delay
   printf(""\b\b   \b\b""); // erase the last two dots, and move the cursor back again
}
</code></pre>
",0
37150925,37150839,1,"<p>There's two things you need.</p>

<p><code>\r</code>, or carriage return, moves the cursor back to the beginning of the line.</p>

<p>Then normally <code>stdout</code> will not display anything until it sees a newline. This is called buffering and it needs to be turned off. You can do this with <a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/setvbuf.html"" rel=""nofollow""><code>setvbuf()</code></a>.</p>

<p>Here's a demonstration.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int
main()
{
    /* Turn off stdout buffering */
    setvbuf(stdout, NULL, _IONBF, 0);

    for(int i = 0; i &lt; 3; i++) {
        /* Clear the current line by moving to the start,
           overwriting it with spaces, and going back to the start.
        */
        printf(""\r                                             \r"");

        printf(""Loading"");

        /* Print ... over 3 seconds */
        for(int i = 0; i &lt; 3; i++) {
            sleep(1);
            printf(""."");
        }

        sleep(1);
    }

    /* Finish it all up with a newline */
    printf(""\n"");

    return 0;
}
</code></pre>

<p>There are fancier ways to do this <a href=""http://heather.cs.ucdavis.edu/~matloff/UnixAndC/CLanguage/Curses.pdf"" rel=""nofollow"">using the curses library</a>, but <code>\r</code> is enough for your purposes.</p>
",0
37150926,37150839,1,"<p>You need to use '\r' character:</p>

<pre><code>while (1) {
    int i;
    for (i=1; i&lt;=3; i++) {
        printf(""Loading%s\r"", i==1 ? ""."" : i==2 ? "".."":""..."");
        fflush(stdout);
        sleep(1); /* or whatever */
    }
    printf(""%20s\r"", "" "");
}
</code></pre>

<p>(Fixed: added <code>fflush(stdout);</code>)</p>
",0
36247798,36247450,2,"<p>You are type casting a char * to an int. This will result in the ASCII value of it. %i and %d point to the same thing i.e signed integers.<br/>
Refer: <a href=""http://codeforwin.org/2015/05/list-of-all-format-specifiers-in-c.html"" rel=""nofollow noreferrer"">Format specifiers in C</a>
<br/>
You can use the following<br/></p>

<pre><code>printf(""%s"", argv[1]);
</code></pre>

<p>or<br/></p>

<pre><code>printf(""%d"", atoi(argv[1]));
</code></pre>

<p>Remember when using atoi(argv<a href=""http://codeforwin.org/2015/05/list-of-all-format-specifiers-in-c.html"" rel=""nofollow noreferrer"">1</a>), there should be no other ASCII characters such as -,+ etc. in these cases atoi() will return 0, since atoi() will not detect any errors (Refer: <a href=""http://linux.die.net/man/3/atoi"" rel=""nofollow noreferrer"">http://linux.die.net/man/3/atoi</a>). So remember to strip all these characters from the argument and just pass pure numbers. Alternatively you can write your own atoi() too, if you fell like it.</p>
",0
36247585,36247450,0,"<p>First of all, you can't cast a <code>char *</code> to <code>int</code> like this. Have a look at <code>atoi();</code>.
Next, if you want to print only decimal numbers, you should you the <code>%d</code> flag, instead of <code>%i</code>. If you want to print every arguments, you should use <code>%s</code> flag, so you don't have to cast your argument.</p>

<p>Last but not least, in your code, you won't print the argument, but the pointer of the value. 6 seems to point on 54, which is its ASCII value.
To print the value, you can do as below:</p>

<p><code>printf(""%d\n"", atoi(argv[1]));</code></p>

<p>OR
<code>printf(""%s\n"", argv[1]);</code></p>
",0
36247478,36247450,3,"<p>Command line arguments are passed as C strings, not as numbers. You cannot cast a C string to its corresponding number, because it is a pointer to a sequence of characters, not the number itself.</p>

<p>Your code attempts to cast the first character in a string representing <code>6</code>, i.e. <code>""6""</code>, to <code>int</code>. The cast succeeds, because <code>char</code> is an integral numeric type, but you get 54 instead of 6 because that is the character code of <code>'6'</code> on your system.</p>

<p>You can use <a href=""http://en.cppreference.com/w/cpp/string/byte/atoi"" rel=""nofollow""><code>atoi</code></a> to do the conversion properly:</p>

<pre><code>int n = atoi(argv[1]);
printf(""%i\n"", n);
</code></pre>

<p>You need to include <code>&lt;stdlib.h&gt;</code> in order for this to compile.</p>
",0
38295667,38295618,3,"<p>The reason that you get ""initialization makes pointer from integer"" warning, despite the function returning a pointer, is somewhat obscure. The root case is that the function has no prototype, but that's not the whole story. According to pre-C99 rules, you were allowed to call a function that has no forward declaration, but the compiler must assume that all parameters are subject to <a href=""https://stackoverflow.com/q/1255775/335858"">default type promotions</a>, and the return type is <code>int</code> as well.</p>

<p>That is why when the compiler sees <code>pListHead = getListFromMap(key)</code> call, it assumes that the function returns an <code>int</code>. In order to avoid this problem, add a forward declaration at the top of the file, right after the <code>typedef</code>s:</p>

<pre><code>list *getListFromMap(int key);
</code></pre>
",1
42546453,42545525,2,"<p>The system stdint.h can make assumptions about the architecture and knows things like the size of a short or int. <code>/usr/include/stdint.h</code> on macOS is very easy to read. Here's the relevant bit.</p>

<pre><code>/* 7.18.1.1 Exact-width integer types */
#include &lt;sys/_types/_int8_t.h&gt;
#include &lt;sys/_types/_int16_t.h&gt;
#include &lt;sys/_types/_int32_t.h&gt;
#include &lt;sys/_types/_int64_t.h&gt;

#include &lt;_types/_uint8_t.h&gt;
#include &lt;_types/_uint16_t.h&gt;
#include &lt;_types/_uint32_t.h&gt;
#include &lt;_types/_uint64_t.h&gt;

/* 7.18.1.2 Minimum-width integer types */
typedef int8_t           int_least8_t;
typedef int16_t         int_least16_t;
typedef int32_t         int_least32_t;
typedef int64_t         int_least64_t;
typedef uint8_t         uint_least8_t;
typedef uint16_t       uint_least16_t;
typedef uint32_t       uint_least32_t;
typedef uint64_t       uint_least64_t;
</code></pre>

<p>You can dig into each individual header file and look at the typedef. Looking through each of them, they're very simple.</p>

<pre><code>typedef __signed char           int8_t;
typedef short                   int16_t;
typedef int                     int32_t;
typedef long long               int64_t;
</code></pre>

<p>And <code>uint*_t</code> are just unsigned versions of that.</p>

<hr>

<p>Since gcc is not the system compiler on a Mac, that's clang, it cannot make assumptions about the architecture, so it uses the existing stdint.h. Here's gcc's stdint.h. It loads the system stdint.h, plus its own header to add its own non-standard things.</p>

<pre><code>$ cat /opt/local/lib/gcc6/gcc/x86_64-apple-darwin16/6.3.0/include/stdint.h 
#ifndef _GCC_WRAP_STDINT_H
#if __STDC_HOSTED__
# if defined __cplusplus &amp;&amp; __cplusplus &gt;= 201103L
#  undef __STDC_LIMIT_MACROS
#  define __STDC_LIMIT_MACROS
#  undef __STDC_CONSTANT_MACROS
#  define __STDC_CONSTANT_MACROS
# endif
# include_next &lt;stdint.h&gt;
#else
# include ""stdint-gcc.h""
#endif
#define _GCC_WRAP_STDINT_H
#endif
</code></pre>
",0
47613094,47612759,2,"<p>In C you cannot assign an array to another, basically because an array cannot be on the left side of an assignment. So the following:</p>

<pre><code>char a[5] = { 1, 2, 3, 4, 5 };
char b[5];
b = a; 
</code></pre>

<p>is not correct. But of course this is correct:</p>

<pre><code>b[0] = a[0]; 
b[1] = a[1]; 
b[2] = a[2]; 
b[3] = a[3]; 
b[4] = a[4]; 
</code></pre>

<p>because <code>b[0]</code> (which is <code>*(b+0)</code>) is not an array, but a <code>char</code>.</p>

<p>Now to the point. In line 36 you do:</p>

<pre><code>scanf(""%s"", &amp;(lst[i].name));
</code></pre>

<p><em>A comment before dissecting: don't use <code>scanf()</code> for user input.</em></p>

<p>Anyway, the function is a variable argument function, meaning that it will happily accept anything you pass as the second parameter. But what you should be passing there is a <code>char*</code> (a pointer to char). Why? Because the guys who devised the function decided so: when the format string has a %s you need a <code>char*</code> parameter.</p>

<p>What type is <code>&amp;(lst[i].name)</code>? The expression <code>lst[i].name</code> is of type <code>char[50]</code> (an array of 50 char), so <code>&amp;(lst[i].name)</code> is ""the address of an array of 50 char"", which in C is called ""a pointer to an array of 50 char"" or in C syntax <code>char(*)[50]</code>. Which is not a <code>char*</code>. So this is wrong or better Undefined Behavior.</p>

<p>What should the correct version have been? Well, this:</p>

<pre><code>scanf(""%s"", lst[i].name);
</code></pre>

<p>because when you use an array in an expression it <em>decays</em> to a pointer to the first element.</p>

<p>Ok, but why does it work anyway? It <em>may</em> work on some compilers, because they just pass the address of the array in both cases, so on the stack both things are the same number.</p>

<p>Finally, no array is ""assigned"" in this expression statement, thus the question in fact makes no sense in the first place. Or better, the function receives the <em>address</em> of the array and fills it using that pointer to the first element. Another funny thing is that you cannot have functions with array parameters. Only pointers.</p>
",0
36589740,36589634,1,"<p>You could use a <em>flag</em>. If you find a file <em>ending</em> in <code>"".txt""</code> then you set the flag and exit the loop. After the loop you check the flag.</p>

<hr>

<p><strong><em>One</em></strong> way to check if a string ends with a specific sub-string:</p>

<pre><code>static const char string_to_find[] = "".txt"";

...

// First make sure the filename is long enough to fit the name-suffix
if (strlen(dir-&gt;d_name) &gt; strlen(string_to_find))
{
    // +strlen(dir-&gt;d_name) to get a pointer to the end of dir-&gt;d_name
    // -strlen(string_to_find) to get a pointer to where the suffix should start
    if (strcmp(dir-&gt;d_name + strlen(dir-&gt;d_name) - strlen(string_to_find),
               string_to_find) == 0)
    {
        // File-name ends with "".txt""
    }
}
</code></pre>
",2
36589751,36589634,0,"<p>Instead of printing the directories you could just put it in an if-statement to check if it's the desired file. If it is: return the directory name, else continue. You can put it all in a for-loop so you can check every directory.</p>

<p>For example:</p>

<pre><code>If(!strcmp(filename, filetofind))
    Return dirname
</code></pre>
",2
36590318,36589634,0,"<p>As an alternative, lazy and Windows-specific solution, you can just let the job to the windows <code>for</code> command this way:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define MAX_LENGTH 1024

int main()
{
    char buffer[MAX_LENGTH];

    FILE *f = _popen(""cmd /c @for /R C:\\Users\\xp\\Desktop\\Star1\\ %i in (.) do @if exist \""%~i\""\\*.txt echo %~fi 2&gt; NUL"", ""r"");
    if (f != NULL)
    {
        while (fgets(buffer, MAX_LENGTH, f) != NULL)
        {
            int len = strlen(buffer);
            if (buffer[len - 1] == '\n')
            {
                buffer[--len] = '\0';
            }

            printf(""Found: %s\n"", buffer);
        }
        _pclose(f);
    }
}
</code></pre>

<p>Edit: fixed answer to give directory list instead of .txt files.</p>
",3
35216683,35216508,1,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

static void print_reversed(const char *str, size_t len)
{
    const char *ptr = str + len;
    while (ptr &gt; str)
        putchar(*--ptr);
}

int main(int argc, char **argv)
{
    for (int i = 0; i &lt; argc; i++)
    {
        if (i != 0)
            putchar(' ');
        print_reversed(argv[i], strlen(argv[i]));
    }
    putchar('\n');
    return 0;
}
</code></pre>

<p>There's no need to modify the strings; simply print the characters out one at a time in reverse order.</p>
",0
35216695,35216508,0,"<p>There are lots of ways to do string reversal, and it is worth spending some time looking into because it is a standard interview question.</p>

<p>a simple implementation for null-terminated strings in <code>C</code> looks like</p>

<pre><code>char * reverse(char * string){
  int i;
  int len = strlen(string);
  for (i = 0; i &lt; len/2; i++){
    char c              = string[i];
    string[i]           = string[len - i - 1];
    string[len - i - 1] = c;
  }
  return string;
}
</code></pre>

<p>This version does manipulate the string, so we'll make a copy of the string just in case.</p>

<p>Once you have string reversal, you will need to run <code>reverse</code> on each argument, and print it out. </p>

<p><strong>NOTE:</strong> arguments in a standard console application like this start with the name of the program as it was typed by the user. So if the program is invoked as <code>./my-program arg1 arg2</code>, <code>argv[0]</code> will be <code>""./my-program""</code>, so we will skip <code>argv[0]</code></p>

<p>Using this, all you have to do is call reverse on each argument. like so</p>

<pre><code>int main(int argc, char ** argv){
  int i;
  char * copy;

  for ( i = 1; i &lt; argc; i++){ // skip argv[0]
    copy = strdup(argv[i]); // copy the string;
    copy = reverse(copy);

    printf(""argv[%d] = \""%s\""\n"", i, copy);

    free(copy); // clean up the copy
  }
}
</code></pre>

<p>All together, you get</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

char * reverse(char * string){
  int i;
  int len = strlen(string);
  for (i = 0; i &lt; len/2; i++){
    char c              = string[i];
    string[i]           = string[len - i - 1];
    string[len - i - 1] = c;
  }
  return string;
}


int main(int argc, char ** argv){
  int i;
  char * copy;

  for ( i = 1; i &lt; argc; i++){ // skip argv[0]
    copy = strdup(argv[i]); // copy the string;
    copy = reverse(copy);

    printf(""argv[%d] = \""%s\""\n"", i, copy);

    free(copy); // clean up the copy
  }
}
</code></pre>
",0
35216765,35216508,0,"<p>Try this code give File name as reverse and put command line argument:-
<a href=""https://i.stack.imgur.com/GBRz5.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/GBRz5.png"" alt=""May be this will work for you.....""></a></p>
",1
35216587,35216508,0,"<p>The logic is fairly straightforward: <em>For each string in argv, reverse it and then print it.</em></p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void swap_characters(char *s, char *t) {
    char tmp = *s;
    *s = *t;
    *t = tmp;
}

void reverse_string(char *s, int length) {
    for (int i = 0; i &lt; length / 2; ++i)
        swap_characters(s + i, s + length - 1 - i);
}

int main(int argc, char **argv) {
    for (int i = 0; i &lt; argc; ++i) {
        reverse_string(argv[i], strlen(argv[i]));
        printf(""%s "", argv[i]);
    }
    printf(""\n"");
}
</code></pre>
",0
39661215,39660334,1,"<p>Strictly speaking you can't. But you can keep pointers to <code>base</code> structure!
When I was need ""OOP"" at C, i used this approach (as example):</p>

<pre><code>// http://ideone.com/FhSULX

#include &lt;stdio.h&gt;


struct BaseFigure
{
    int type;
    const char * name;
};

struct RectangleFigure
{
    struct BaseFigure base; // must be first field!
    int width, height;
};

struct CircleFigure
{
    struct BaseFigure base; // must be first field!
    float radius;
};

enum {FIGURE_RECTANGLE, FIGURE_CIRCLE};

int main()
{
    enum {FIGURE_COUNT = 2};

    struct BaseFigure *arrayOfFigures[FIGURE_COUNT];
    struct RectangleFigure rectangle;
    struct CircleFigure circle;
    int i;

    rectangle.base.name = ""rectangle"";
    rectangle.base.type = FIGURE_RECTANGLE;
    rectangle.width = 10;
    rectangle.height = 20;

    circle.base.name = ""circle"";
    circle.base.type = FIGURE_CIRCLE;
    circle.radius = 3.5f;

    arrayOfFigures[0] = (struct BaseFigure*)&amp;rectangle;
    arrayOfFigures[1] = (struct BaseFigure*)&amp;circle;

    for (i = 0; i &lt; FIGURE_COUNT; i++)
    {
        struct BaseFigure * const baseFigure = arrayOfFigures[i];
        printf(""Figure type: %d, name: %s\n"", baseFigure-&gt;type, baseFigure-&gt;name);
        switch (baseFigure-&gt;type)
        {
            case FIGURE_RECTANGLE:
            {
                struct RectangleFigure * const figure = (struct RectangleFigure*)baseFigure;
                printf(""%s: width: %d, height: %d\n"", figure-&gt;base.name,
                    figure-&gt;width, figure-&gt;height);
            }
            break;

            case FIGURE_CIRCLE:
            {
                struct CircleFigure * const figure = (struct CircleFigure*)baseFigure;
                printf(""%s: radius: %f\n"", figure-&gt;base.name,
                    figure-&gt;radius);
            }
            break;

            default:
                printf(""Error: unknown figure with type '%d'!\n"", baseFigure-&gt;type);
        }
    }

    return 0;
}
</code></pre>
",0
40752895,40752731,0,"<p>Review the code below. It fixed few issues with your code.</p>

<pre><code>    #include&lt;stdio.h&gt;
    #include &lt;string.h&gt;
    int main()
    {
        int i;

        char word_array[10][20] ={""araba"",""car"",""kalem"",""pencil"",""derin"",""deep"",""mavi"",""blue"",""el"",""hand"" };
        char search[10] = ""araba"";


        for(i = 0 ; i &lt; 10; i++){
            if(strcmp(word_array[i],search) == 0){
                printf(""i found: %s\n"",i);
                break;
            }
       }

       if(i&gt;=10) {
            printf(""The word %s isnt in the array.\n"",search);
        }

        return 0;
    }
</code></pre>
",2
40752923,40752731,0,"<pre><code>#include&lt;stdio.h&gt;
#include &lt;string.h&gt; // &lt;-------- Include header containing strcmp()
int main()
{
    int i;

    char word_array[10][20] = { ""araba"", ""car"", ""kalem"", ""pencil"", ""derin"", ""deep"", ""mavi"", ""blue"", ""el"", ""hand"" };
    //char arama[5] = {'d','e','r','i','n'};
    char search[10] = ""araba""; // &lt;-------- Remove space to have the same string.


    for (i = 0; i &lt; 10; i = i + 1){ // &lt;-------- Search each word in array as opposed to each second word.
        if (strcmp(word_array[i], search) == 0){ // &lt;-------- Use proper C-string comparison.
            printf(""%i found: %s\n"", i, word_array[i]); // &lt;-------- Correct specifier ""i"" to ""%i"" and add the actual found word to output for ""%s""
        }
        else{
            printf(""The word isnt in the array. %s\n"", word_array[i], search);
        }
    }

    return 0;
}
</code></pre>

<p>Also see: <a href=""https://stackoverflow.com/questions/8004237/how-do-i-properly-compare-strings-in-c"">How do I properly compare strings?</a></p>
",3
35254129,35247421,0,"<p>Try this add function to solve the problem</p>

<pre><code>void add(struct Cell *orig, int a)
{
   struct Cell *newCell=(struct Cell *)malloc(sizeof(struct Cell));
   orig-&gt;next = newCell;
   newCell-&gt;info = a;
   printf(""New Cell: %d\n"", newCell-&gt;info);
   printf(""New Cell Address: %x\n"", &amp;newCell);
   //printf(""Test: %d\n"", newCell)-&gt;info);
}
</code></pre>

<p>For construction of the linked list You should allocate the memory to each node by using a <code>malloc()</code> function from library <code>stdlib.h</code>  </p>
",0
35283761,35283481,4,"<p>Since you are in C, cannot rename the words and cannot change the case, and you don't want also to mess with the libraries... no much choice.</p>

<p><strong>You could create a <em>struct</em></strong></p>

<pre><code>typedef struct {int load, loada, store, mov, add, sub, mul, div, mod, cmp, b,
                blt, ble, bne, beq, bge, bgt, read, write;
} OP_CODE;
</code></pre>

<p>Assign member values</p>

<pre><code>OP_CODE op;
op.load  = 1;
op.loada = 2;
...
</code></pre>

<p>and use <code>op.</code><em>opcode</em> wherever necessary.
<hr>
<strong>Use #define</strong></p>

<p>The other workaround which will do exactly what you want is not very clean</p>

<ul>
<li>the <code>#define</code> have to be declared <em>after</em> the headers includes</li>
<li>you cannot use the definitions that you <em>define</em> from the libraries anymore </li>
</ul>

<p>for instance</p>

<pre><code>#include &lt;stdlib.h&gt;
...
#define load  1
#define loada 2
....
</code></pre>

<p>Then you can use the names as is</p>

<pre><code>if (opcode == div) { 
    // do div stuff
}
</code></pre>

<p>Not recommended but if you <em>have to</em> use the names as they are in C, that's the solution (note that a few <em>defines</em> are used a lot in C, like <em>read</em> and <em>write</em> to name two, to read and write files).</p>
",0
35283810,35283481,2,"<p><code>div</code> is a standard function [defined in <code>stdlib.h</code>].  Since you can't change the names [or case], there are several workarounds.</p>

<p>The first is:</p>

<pre><code>#define div __not_div__
#include &lt;stdlib.h&gt;
#undef div

typedef enum opcode {
    load,
    loada,
    store,
    mov,
    add,
    sub,
    mul,
    div,
    mod,
    cmp,
    b,
    blt,
    ble,
    bne,
    beq,
    bge,
    bgt,
    read,
    write
} OP_CODE;
</code></pre>

<p>The second is:</p>

<pre><code>#include &lt;stdlib.h&gt;

typedef enum opcode {
    load,
    loada,
    store,
    mov,
    add,
    sub,
    mul,
    _div,
    mod,
    cmp,
    b,
    blt,
    ble,
    bne,
    beq,
    bge,
    bgt,
    read,
    write
} OP_CODE;

#define div _div
</code></pre>

<p>The third is [to use <code>#define</code> instead of <code>enum</code>]:</p>

<pre><code>#include &lt;stdlib.h&gt;

#define load    0
#define loada   1
#define store   2
#define mov     3
#define add     4
#define sub     5
#define mul     6
#define div     7
#define mod     8
#define cmp     9
#define b       10
#define blt     11
#define ble     12
#define bne     13
#define beq     14
#define bge     15
#define bgt     16
#define read    17
#define write   18
</code></pre>

<p>The fourth option is to simply structure your code so that any file that needs <code>OP_CODE</code> does <em>not</em> include <code>stdlib.h</code> [or vice versa]</p>
",2
35283557,35283481,2,"<p><code>div</code> is a library function, so you should not use the same name.  So you should  ""change the words or the case letters"" (or change the compiler to C++ and use namespace to isolate your enumeration).</p>

<p>You can rename all members of your enum, e.g.</p>

<pre><code> typedef enum opcode {LOAD, LOADA, STORE, MOV, ADD, SUB, MUL, DIV, MOD, CMP, B, BLT, BLE, BNE, BEQ, BGE, BGT, READ, WRITE} OP_CODE;
</code></pre>

<p>or</p>

<pre><code> typedef enum opcode {op_load, op_loada, op_store, op_mov, op_add, op_sub, op_mul, op_div, op_mod, op_cmp, op_b, op_blt, op_ble, op_bne, op_beq, op_bge, op_bgt, op_read, op_write} OP_CODE;
</code></pre>

<p>I prefer the last option (with prefix added to names of all values of <code>opcode</code>)</p>
",4
42523146,42523023,0,"<p>You need to print a space in the inner loop and a newline in the outer loop to get the output in the same format as your file.</p>

<pre><code>for(i=0; i&lt;inputs; i++){
    for(j=0; j&lt;4; j++){
        fscanf(fptr, ""%d"", &amp;matrix[j]);
        printf(""%d "", matrix[j]);
        printf("" "");
    }
    printf(""\n"");
}
</code></pre>

<p><strong>EDIT</strong>: I just ran this in an IDE and it works fine and prints on screen in exactly the way you have shown your file is. If you are getting a segmentation fault, your actual file content is different from what you have shown us. Please show the actual content of your <code>key.txt</code> file.</p>
",4
42523337,42523023,0,"<p>the problem in your original code is <strong>int matrix[5]</strong>.</p>

<p>you are reading in more than 5 values based on your sample text file.
the basic problem is declaring an array large enough to hold the amount of values you will be reading in.  How you determine that is up to you.</p>

<p>Based on your sample text file, consider something like this below.</p>

<pre><code>/*
My text file simply says the following:

4
1 3 5 7
3 5 7 1
5 7 1 3
7 1 3 5
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define NCOL 4
#define MAX_ROWS 10

int main ( void )
{
    FILE *fptr;
    int number_rows;
    int i, j;
    int matrix[MAX_ROWS][NCOL];

    fptr = fopen(""key.txt"", ""r"");
    if ( fptr == NULL )
    {
       printf(""Error: failed to open file key.txt\n\n"");
    }
    else
    {
       fscanf(fptr, ""%d"", &amp;number_rows);
       if ( number_rows &lt;= 0 )
       {
          printf(""Error: value read for number of rows is %d\n\n"", number_rows );
       }
       else if ( number_rows &gt; MAX_ROWS )
       {
          printf(""Error: value entered for number rows &gt; MAX_ROWS\n\n"");
       }
       else
       {
          for ( i = 0; i &lt; number_rows; i++ )
          {
             for ( j = 0; j &lt; NCOL; j++ )
             {
                fscanf(fptr, ""%d"", &amp;matrix[i][j] );
             }
          }
       }
       fclose( fptr );
    }

    /* if the above failed because key.txt could not be read,
       then we will be printing out bogus numbers below.
    */

    for ( i = 0; i &lt; number_rows; i++ )
    {
       for ( j = 0; j &lt; NCOL; j++ )
       {
          printf(""%d "", matrix[i][j]);
       }
       printf(""\n"");
    }

    return 0;
}
</code></pre>
",0
42523242,42523023,0,"<p>Few things: </p>

<p>1) I think your code can only result to a Segmentation Fault if that <code>key.txt</code> does not exist in the current directory (or <code>key.txt</code> does not contain your sample data above). So make sure that file exists with the correct content.  </p>

<p>2) Try to program defensively, meaning that: check whether you actually opened the file successfully and got a valid <code>FILE *</code>.</p>

<pre><code>FILE *fptr = fopen(""key.txt"", ""r"");
if (fptr == NULL){
   fprintf(stderr, ""Error, could not open the file!"");
   return -1;
}
</code></pre>

<p>3) If you want to define a matrix, you need a 2D array</p>

<pre><code>int matrix[5][5];

// and in the loop you use
fscanf(fptr, ""%d"", &amp;matrix[i][j]);
</code></pre>
",0
45721144,45717653,0,"<p>Threads of RTOS are very useful when you perform tasks with soft deadline. Soft deadline means that if the execution delays the system will not fail. In your case, the oscillator has a hard deadline e.g. if the duty cycle of PWM is not precise and stable the motor will not be having the desirable constant angular velocity. In this case you have to use the available Timer/Counter peripheral of the MCU. </p>

<p>You can set a timer to interrupt the CPU on a given interval and toggle the output in the ISR (Interrupt Service Routine). Using this approach the load of time-counting is moved from the CPU to the timer peripheral, allowing both precise oscillating output and smooth execution of other tasks.</p>

<p>You do not make clear which RTOS or MCU/CPU you are using, but all of them have timer/counter peripherals. If not supported directly from the RTOS, look in the CPU vendor datasheet.</p>
",4
47651101,47650764,1,"<p>You probably want this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
{
  FILE* pf = NULL;
  char chaine[1000];
  int count = 0;
  int com = 0;
  pf = fopen(""test.c"", ""r"");

  if (pf == NULL)   // we abort if the file cannot be opened
  {
    printf(""File cannot be opened\n"");
    return 1;
  }

  while (1)  // see link below
  {
    if (com % 2 == 0)
      count++;

    if (fgets(chaine, sizeof(chaine), pf) == NULL)
      break;  // if fgets returns NULL we are presumably at the end of the file

    if (chaine[0] == '\n' || chaine[0] == ' ' || strstr(chaine, ""//"") != NULL)
    {
      count--;
    }

    if (strstr(chaine, ""//*"") != NULL || strstr(chaine, ""*//"") != NULL)
    {
      com++;
    }

    printf(""The line %d have the following string : %s\n"", count, chaine);
  }
}
</code></pre>

<p>This is untested code, there may be errors.</p>

<p>Also read this: <a href=""https://stackoverflow.com/questions/5431941/why-is-while-feof-file-always-wrong"">Why is ¡°while ( !feof (file) )¡± always wrong?</a>.</p>

<p>I also strongly recommand you to read the chapter dealing with strings and the chapter dealing with pointers in your C text book.</p>
",2
35283450,35283434,0,"<p>Your function is not returning anything but you're assigning the return value to a variable <code>m</code>. If you're calling it just for side effects, don't assing the return value to anything.</p>
",1
35283458,35283434,0,"<p>When a function returns <code>void</code>, you cannot use:</p>

<pre><code>m = myMax1(a,len,m);
</code></pre>

<p>You can use:</p>

<pre><code>myMax1(a,len,m);
</code></pre>
",1
38018239,38018216,6,"<p>Just pass address to the middle of the array.</p>

<pre><code>qsort(array + 2, 5 - 2, sizeof(int), compa);
</code></pre>
",0
44743430,44743412,8,"<p>You could <code>#include</code> any kind of (syntactically valid) C code, but you generally should not (by convention) include a <code>.c</code> file. Read more about the <a href=""https://en.wikipedia.org/wiki/C_preprocessor"" rel=""nofollow noreferrer"">C preprocessor</a>.</p>

<p>In practice, you should consider making some <a href=""https://en.wikipedia.org/wiki/Library_(computing)"" rel=""nofollow noreferrer"">library</a> (to be <a href=""https://en.wikipedia.org/wiki/Linker_(computing)"" rel=""nofollow noreferrer"">linked</a> for reuse), and separate your shared code into a <code>.h</code> header file (containing <em>definitions</em>) that you would <code>#include</code> for re-using and an implementation <code>.c</code> file. Of course don't define any <code>main</code> in the shared source code. In some simple cases and on some operating systems, you might also share a <em>single</em> (or some few) <a href=""https://en.wikipedia.org/wiki/Object_file"" rel=""nofollow noreferrer"">object file</a> (and related header files).</p>

<p>Your shared header would declare functions and <code>extern</code> variables (and <code>#define</code> some macros). It could also contain the <em>definition</em> (with their body) of <em>short</em> <code>static inline</code> functions.</p>

<p>Your shared implementation would <em>define</em> these (and others) functions and variables.</p>

<p><strong>C programming entails a lot of <em>conventions</em></strong> (and you need to define your own ones). <strong>Look at existing examples</strong> (some <a href=""https://en.wikipedia.org/wiki/Free_software"" rel=""nofollow noreferrer"">free software</a> source code from <a href=""http://github.com"" rel=""nofollow noreferrer"">github</a>, or from a Linux distribution). For reusable container libraries, look into <a href=""https://developer.gnome.org/glib/stable/"" rel=""nofollow noreferrer"">glib</a> (from GTK) and also <a href=""http://sglib.sourceforge.net/"" rel=""nofollow noreferrer"">sglib</a> (which uses a lot of preprocessor tricks) and many others.</p>

<p>Because C does not have any notion of <a href=""https://en.wikipedia.org/wiki/Namespace"" rel=""nofollow noreferrer"">namespaces</a> it is wise (for readability and other reasons) to have a consistent naming convention, e.g. starting all the public names (of functions and variables and macros in headers) of your library by some common prefix.</p>
",2
44743434,44743412,1,"<p>You need to define a header file, <code>linkedList.h</code>, and declare your linked list function prototypes in there, which you probably already have defined in you <code>linkedList.c</code> file. And then, you can use <code>'#include linkedList.h'</code> to reuse your code.</p>
",1
36647091,36646997,2,"<p>When you do <code>C = (4*B*A*A);</code>, this doesn't mean that <code>C</code> will <em>always</em> contains what that expression evaluates to.  It means that you're modifying <code>C</code> based on the value of that expression <em>at that moment</em>.  </p>

<p>So changing <code>A</code> after this point has no effect on the value of <code>C</code>.  And since <code>A</code> is uninitialized, this results in <strong><a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow"">undefined behavior</a></strong>, meaning the results are not necessarily predictable.</p>

<p>You need to first read in the value of <code>A</code>, <em>then</em> modify <code>C</code> based on the current values of <code>A</code> and <code>B</code>:</p>

<pre><code>printf ("" Enter value of A : ""); scanf(""%f"", &amp;A);
C = (4*B*A*A);
printf (""\n"");
printf ("" So, the result is : %f"", C);
printf (""\n"");
</code></pre>

<p>To do what you <em>though</em> your original code would do, you'd need to define a function that will calculate the value of <code>C</code> when you call it.</p>

<pre><code>#include &lt;stdio.h&gt;

int C(int A, int B)
{
    return 4*B*A*A;
}

int main()
{
    float A, B;
    B = 3.14;

    printf ("" Enter value of A : ""); scanf(""%f"", &amp;A);
    printf (""\n"");
    printf ("" So, the result is : %f"", C(A,B));
    printf (""\n"");
}
</code></pre>
",0
36647109,36646997,0,"<p>You are calculating the ""result"" before you ask for input:</p>

<pre><code>float A, B, C;
B = 3.14;

C = (4*B*A*A);   //  What value has A here? Probably 0 !!

printf ("" Enter value of A : ""); scanf(""%f"", &amp;A);  // This has no influence
                                                   // whatsoever on the 
                                                   // value of C
printf (""\n"");
printf ("" So, the result is : %f"", C);
printf (""\n"");
</code></pre>

<p>I am not sure about C (question was tagged C++ before), but I guess <code>A</code> gets initialized to <code>0</code>, thus the result is indeed exactly <code>0</code>.</p>

<p>PS: a kind compiler would issue a warning, something like ""Warning: variable A is used uninitialized.""</p>
",0
39334618,39334465,0,"<h3>Designated initializers</h3>

<p>Assuming you want one space in the strings and zeros in the numbers, then using C99 designated initializers is going to be as compact as you can reasonably get:</p>

<pre><code>_X x = { .AA = "" "", .BB = "" "", .CC = "" "", ¡­, .ZZ = "" "" };
</code></pre>

<p>is about the minimum you can get away with.  If you want 9 spaces per string (why?), then change the string literals to 9 spaces.  All the unmentioned elements (the <code>int</code> members) are initialized to zero.</p>

<p>If you need the same initialization in many places, consider creating a constant global variable that you can use when necessary:</p>

<pre><code>const _X x_default = { .AA = "" "", .BB = "" "", .CC = "" "", ¡­, .ZZ = "" "" };
</code></pre>

<p>and then use:</p>

<pre><code>_X other_x = x_default;
</code></pre>

<p>This can't be used to initialize global or file scope variables, but you shouldn't have many of those (<code>x_default</code> being the noticeable exception).  You can wrap this in a function, either one that takes a <code>_X *</code> argument that is initialized by assignment (<code>void set_x(_X *xp) { *xp = x_default; }</code>) or one that returns a value (<code>_X set_x(void) { return x_default; }</code>) ¡ª the choice is yours.  But the initializer should be written out as few times as possible.  Look up <code>PTHREAD_MUTEX_INITIALIZER</code> and consider how that idea might be used, too.</p>

<p>If for some reason your compiler doesn't support the old C standard (C99) and only supports the archaic C standard (C90), then you have to write out the initializer fully:</p>

<pre><code>_X x = { "" "", 0, "" "", 0, "" "", 0, ¡­, "" "", 0 };
</code></pre>

<hr>

<h3>Structure design</h3>

<p>The structure shown is problematic because of its repeated content.  It should probably be:</p>

<pre><code>struct Y
{
    char name[10];
    int  number;
};

struct X
{
    struct Y letters[26];
};
</code></pre>

<p>Or something along those lines.  Changing that would require a lot of editing, but a lot of processing will be a lot simpler.  Funnily enough, the initialization sequence would become a little more noisy, but the fact that you don't have to write everything else out 26 times will save in the long run.</p>

<hr>

<h3>Usurping reserved identifiers</h3>

<p>Note that the names <code>_X</code> and <code>__X</code> are both unconditionally reserved for the implementation.  Do <em>not</em> use them in your code.  Unless you really like reading the fine print, don't use names starting with underscore.  If you like the fine print, then ¡ì7.1.3 Reserved identifiers of C11 (and C99) applies:</p>

<blockquote>
  <ul>
  <li>All identifiers that begin with an underscore and either an uppercase letter or another
  underscore are always reserved for any use.</li>
  <li>All identifiers that begin with an underscore are always reserved for use as identifiers
  with file scope in both the ordinary and tag name spaces.</li>
  </ul>
</blockquote>
",0
39334557,39334465,1,"<p>The easiest way to achieve this is to write an initialization function:</p>

<pre><code>void initialize(_X *x)
{
  memset(x, 0, sizeof(_X));

 x-&gt;AA[0] = ' ';
 x-&gt;BB[0] = ' ';
 // etc
 // etc
 x-&gt;ZZ[0] = ' ';
}
</code></pre>

<p>You're not going to get in much more minimal than that.</p>

<p>EDIT: If you're looking to fill the char arrays fully with spaces then you'll need to <code>memset</code> them, rather than set the first char to a space.</p>
",0
37840700,37839153,1,"<p><code>realloc(input, (sizeof(char))); //allocate more memory</code> only allocates 1 <code>char</code>.  Not 1 <em>more</em> <code>char</code>.  <a href=""https://stackoverflow.com/questions/37839153/c-read-string-into-dynamic-array/37840700#comment63139211_37839153"">@MikeCAT</a></p>

<p><code>(sizeof(char)*length+1)</code> is semantically wrong.  Should be <code>(sizeof(char)*(length+1))</code>, but since <code>sizeof (char) == 1</code>, it makes no functional difference.  </p>

<p>Need space for the null character. <a href=""https://stackoverflow.com/questions/37839153/c-read-string-into-dynamic-array/37840700#comment63139299_37839153"">@MikeCAT</a></p>

<p>Should test for reallocation failure.</p>

<p><code>char c</code> is insufficient to distinguish all 257 different responses from <code>getchar()</code>.  Use <code>int</code>.  <code>getchar()</code> may return <code>EOF</code>.  <a href=""https://stackoverflow.com/questions/37839153/c-read-string-into-dynamic-array/37840700#comment63139454_37839153"">@Andrew Henle</a></p>

<p>Minor: Better to use <code>size_t</code> for array indexes than <code>int</code>.  <code>int</code> maybe too narrow.</p>

<p>In the end code needs to do something like:</p>

<pre><code>size_t length = 0;
char *input = malloc(1);
assert(input); 
int c;
...
while((c = getchar()) != '\n' &amp;&amp; c != EOF) {
  char *t = realloc(input, length + 1);
  assert(t); 
  input = t;
  input[length++] = c;
}
...
return input;

int main(void) {
  ...
  input = read_string_from_terminal();
  printf(""Output \n %s"", input);
  free(input);
  return EXIT_SUCCESS;
}    
</code></pre>
",1
37397524,37397464,4,"<p>Get the operator from the user and store it as a char.  Then compare the operator to the plus sign, '+', and the minus sign,'-'.  If it matches one of those, do that operation.  If it doesn't, print your error message.</p>

<pre><code>char operator;

if(operator == '+')
    sum = integer1 + integer2;
else if(operator == '-')
    sum = integer1 - integer2;
else
{
    printf(""Error"");
    return 0;
}
</code></pre>
",2
37397705,37397464,3,"<p>You could read the whole expression,like 2+3, in one <code>scanf()</code> statement and then compare the operator to determine what to do.</p>

<pre><code>   int integer1, integer2, sum;// Declare 3 integer variables
   char oper;//this is where you read the operator as character

   printf(""Enter an expression: "");// Display a prompting message

   // Read expression like 2+3,2 +3,2 + 3... from user
   int res=scanf(""%d %c%d"", &amp;integer1,&amp;oper,&amp;integer2);

   //we expect 3 fields to be converted and assigned by scanf
   if(res&lt;3)//this will catch expressions like 2+h,...
   { 
       printf(""Input error"");
       return 1;
   }

   switch(oper)
   {
      case '+':
         sum = integer1 + integer2;// Compute the sum
         printf(""The sum of %d and %d is %d.\n"", integer1, integer2, sum);
         break;
      case '-':
         sum = integer1 - integer2;// Compute the difference
         printf(""The difference of %d and %d is %d.\n"", integer1, integer2, sum);
         break;
      default:
         printf(""Invalid entry"");
   }   
</code></pre>
",2
46614670,46614621,0,"<p>You don't need to pass in a pointer to a pointer in <code>top()</code>. It's sufficient to change the function definition from <code>Node top(Node** head)</code> to <code>Node top(Node* head)</code>.</p>

<p>Now you won't need to pass in the address of <code>stack</code> when calling the following (without spelling mistakes):</p>

<pre><code>printf(""Node value: %d, %d\n"", (top(stack)).x, (top(stack)).y); 
</code></pre>
",0
46614723,46614621,1,"<p>I suppose it's just a typo (<code>pop</code> instead of <code>top</code>), such that you actually call a library function not returning your <code>Node</code> type. Write <code>printf(""Node value: %d, %d\n"", top(&amp;stack).x, top(&amp;stack).y);</code> and it should work as expected.</p>
",1
46614801,46614621,1,"<pre><code>Node* newPtr = (Node*) malloc(sizeof(Node));
</code></pre>

<p>There is no need to cast the return of <code>malloc</code>, it is unnecessary. See: <a href=""http://stackoverflow.com/q/605845/995714""><strong>Do I cast the result of malloc?</strong></a>. The following is sufficient:</p>

<pre><code>Node *newPtr = malloc (sizeof *newPtr);
</code></pre>

<p>The address for <code>head</code> isn't changing in <code>top</code>, so there is no need to pass the address of <code>head</code>, e.g.</p>

<pre><code>Node top (Node *head){
    return *head;
}
</code></pre>

<p>You shouldn't return a <em>negative</em> value from <code>main()</code>. There are two defined returns:</p>

<pre><code>EXIT_SUCCESS: 0
EXIT_FAILURE: 1
</code></pre>

<p><a href=""http://stackoverflow.com/questions/204476/""><strong>See What should main() return in C and C++?</strong></a></p>

<p>Putting it altogether:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct nodeStrcut{
    int x,y;
    struct nodeStrcut* next;
} Node;

Node top (Node *head){
    return *head;
}

void push (Node **head, int x, int y) {

    Node *newPtr = malloc (sizeof *newPtr);
    newPtr-&gt;x = x;
    newPtr-&gt;y = y;
    newPtr-&gt;next = *head;
    *head = newPtr;
}

int main (void) {

    Node *stack = NULL;

    push (&amp;stack, 3, 3);
    push (&amp;stack, 2, 3);
    push (&amp;stack, 3, 5);

    printf (""Node value: %d, %d\n"", (top (stack)).x, (top (stack)).y);

    return 0;
}
</code></pre>

<p><strong>Example Use/Output</strong></p>

<pre><code>$ ./bin/stacktop
Node value: 3, 5
</code></pre>
",0
39324817,39324800,6,"<p>The ordering of storage class specifiers (<code>extern</code>, <code>static</code>, <code>register</code>, <code>auto</code>, <code>typedef</code>) with respect to type specifiers (<code>int</code>, <code>double</code>, <code>char</code>, etc.) does not matter. Both are valid and declare the same object.</p>

<p>It is, however, considered a good practice to conform to a certain order. The specifier-qualifier list which precedes the declarator (<code>i</code> in your case) consists of distinctive groups of keywords which are best used in the following order:</p>

<ul>
<li>Storage class specifiers, if any: <code>static</code>, <code>extern</code>, <code>auto</code>, <code>register</code>, <code>typedef</code>, <code>_Thread_local</code> (C11);</li>
<li>Type qualifiers, if any: <code>const</code>, <code>volatile</code>, <code>restrict</code>;</li>
<li>Type modifiers, if any: <code>signed</code>, <code>unsigned</code>, <code>short</code>, <code>long</code>;</li>
<li>The type specifier: <code>int</code>, <code>char</code>, <code>double</code>, <code>float</code>, etc.</li>
</ul>

<p>Following that rule would lead to more readable declarations like this:</p>

<pre><code>static const volatile unsigned long int a;
</code></pre>

<p>Instead of (an extreme example):</p>

<pre><code>unsigned volatile int static const long a;
</code></pre>
",0
39324833,39324800,4,"<p>The C grammar allows you to put the storage specifier in both positions, there's no ambiguity since the intersection between the set of valid types an valid storage specifiers is empty. However, usually I've always seen the storage specifier written before the type, so you should probably stick to this convention for ease of reading by other people. </p>

<p>(also, avoid using <code>auto</code>, nobody ever uses it because it is always implied, to the point that C++ even repurposed that keyword for variables with inferred type) </p>
",0
39678027,39677935,1,"<ol>
<li>Convert the number to a character array. Look at the <code>sprintf</code> function.</li>
<li>Swap the positions of the characters.</li>
<li>Convert the character array to double. Look at the <code>atof</code> function.</li>
</ol>
",0
39678172,39677935,1,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int dotPos(char arr[]) {
    int i = 0;
    while (arr[++i] != '.');
    return i;
}

int main() {
    double d = 45392.56;

    int MAX = 100;
    char arr[MAX];
    sprintf(arr, ""%f"", d);

    if (dotPos(arr) &gt; 3) {
        char aux = arr[1];
        arr[1] = arr[3];
        arr[3] = aux;
    }

    d = atof(arr);
    printf(""%.2f\n"", d);
}
</code></pre>

<p>Output:</p>

<pre><code>49352.56
</code></pre>
",12
39678520,39677935,1,"<p>Avoiding conversion to string and back, take the integral part of the number, find the two values in position 1 and 3 (in decimal notation), and compute the value to add or substract to/from the original double.
this is <code>(a-b) *pow(10,hipos) - (a-b) * pow(10,lopos)</code></p>

<pre><code>#include &lt;stdio.h&gt;

long finddiff(unsigned long val, unsigned lpos, unsigned rpos);

int main(void) {
    double d = 45392.56;
    unsigned long u;
    long dif;

    u = d;
    dif = finddiff(u,3,1);

    d += dif;

    printf(""%.2f\n"", d);
    return 0;
}

long finddiff(unsigned long val, unsigned lpos, unsigned rpos)
{
long res;
unsigned pos, ll, rr;

if (lpos &lt; rpos) return finddiff(val, rpos,lpos);

for (pos=0; pos &lt; rpos; pos++) { val /= 10; }
rr = val %10;
for (; pos &lt; lpos; pos++) {  val /= 10; }
ll = val %10;

// fprintf(stderr, ""%u,%u\n"", ll,rr);

res = rr-ll;
for (; pos &gt; rpos; pos--) { res *= 10; }
res -= rr-ll;
for (; pos &gt; 0; pos--) { res *= 10; }

// fprintf(stderr, ""%u,%u,%ld\n"", ll,rr, res);

if (ll &gt; rr) res = -res;
else if (rr &gt; ll) {;}
else res = 0;
return res;
}
</code></pre>

<p>BTW: this will fail miserably for values whose integer part is larger than the maximum log int, eg <code>6.3E23</code> .
For negative numbers some additional logic should be added.</p>
",0
37403142,37403111,2,"<p>Instead of <code>double perimeter(double x, w)</code>, write function with arguments like this <code>double perimeter(double x, double w)</code>.</p>
",2
37403212,37403111,-1,"<p>Ok, it seems that you have much more mistakes, so I correct them all and post a new answer with full corrected code, you can compare it with yours.</p>

<pre><code>#include &lt;stdio.h&gt;
double perimeter(double x, double w);
double area(double x, double w);
int main (){
    double x, w;
    printf(""Enter the length: "");
    scanf(""%lf"", &amp;x);
    printf(""Enter the width: "");
    scanf(""%lf"", &amp;w);
    printf(""The perimeter is %lf\n"", perimeter(x, w));
    printf(""The area is %lf\n"", area(x, w));
    return 0;
}
double perimeter(double x, double w){
    return (2*x)+(2*w);
}
double area(double x, double w){
    return (x*w);
}
</code></pre>
",0
37403255,37403111,2,"<p>There are a few issues here. </p>

<p>First, your <em>defined</em> functions do not match your <em>declared</em> functions:</p>

<pre><code>//Declared:
double perimeter(double x);
double area(double w);

//Defined:
double perimeter(double x, w){
    return (2*x)+(2*w);
}
double area(double x, w){
    return (x*w);
}
</code></pre>

<p>In your function declarations you only have one parameter, but in your definition, you try to use two. </p>

<p>Try this:</p>

<pre><code>double perimeter(double length, double width){
    return (2*length)+(2*width);
}
double area(double length, double width){
    return (length*width);
}
</code></pre>

<p>The second problem is when you call your functions:</p>

<pre><code>printf(""The perimeter is %lf\n"", perimeter);
printf(""The area is %lf\n"", area);
</code></pre>

<p>You aren't passing the <em>length</em> and <em>width</em> values to your functions. 
You also missed a semicolon after the second scanf.</p>

<p>Give this a try:</p>

<pre><code>int main (){
    double length, width;
    printf(""Enter the length: "");
    scanf(""%lf"", &amp;length);
    prntf(""Enter the width: "");
    scanf(""%lf"", &amp;width);
    printf(""The perimeter is %lf\n"", perimeter(length, width);
    printf(""The area is %lf\n"", area(length, width);
    return 0;   
}   
</code></pre>

<p>Best of luck. </p>
",0
37403299,37403111,0,"<p>in the following code is your program running pefectly, the mistake was the way you use your functions, consider the things that the others above wrote you.</p>

<pre><code>#include &lt;stdio.h&gt;

double perimeter(double x, double w){
    return (2*x)+(2*w);
}
double area(double x, double w){
    return (x*w);
}

int main (){
    double x, w;
    printf(""Enter the length: "");
    scanf(""%lf"", &amp;x);
    printf(""Enter the width: "");
    scanf(""%lf"", &amp;w);
    printf(""The perimeter is %lf\n"", perimeter(x,w));
    printf(""The area is %lf\n"", area(x,w));
    return 0;
}
</code></pre>

<p>Check this code with yours and find your errors. </p>
",0
37405040,37403111,0,"<p>The problem with your code are</p>

<p>The declarations and definitions do not match. The correct declaration would be<br>
<code>double perimeter(double w, double x)</code> and <code>double area(double w,double x)</code>.</p>

<p><strong>NOTE:</strong> Always remember that the order, type and number of arguments must match while declaring, defining and calling the corresponding function.</p>

<p>When you are calling functions <code>perimeter</code> and <code>area</code> in printf, you are not passing arguments. As you will see in your declaration and definition of functions you have used <code>perimeter(double x,w)</code> and <code>area(double x,w)</code>. </p>

<p>So the correct lines would be</p>

<pre><code> printf(""The perimeter is %lf\n"", perimeter(x,w));
 printf(""The area is %lf\n"", area(x,w));
</code></pre>
",0
37771145,37771113,3,"<p>You've confused the ""is equal"" operator <code>==</code> and the ""assignment"" operator <code>=</code>.</p>

<p>All of the lines like <code>if(box[x][y]== num)</code> are correct: you're comparing if they're equal.</p>

<p>All of the lines like  <code>box[++x][y]==num;</code> need to change to <code>box[++x][y] = num;</code> - you want to ""assign"" num to the <code>box</code> entry, not ""compare"" it.</p>

<p>But you've also got another problem: in all of the lines <code>box[++x][y] = num;</code> you do NOT want to use <code>++x</code> or <code>--y</code> - these actually change <code>x</code> and <code>y</code>, which I don't think you want. The <code>for</code> loops are moving <code>x</code> and <code>y</code> from <code>0</code> to <code>9</code> - using <code>--x</code> and <code>++y</code> changes these <code>for</code> loop values.</p>

<p>Instead you want something like <code>box[x+1][y] = num;</code> or <code>box[x][y-1] = num;</code> which calculate ""one more than <code>x</code>"" and ""one less than <code>y</code>"" and uses the calculated values, rather than changing <code>x</code> or <code>y</code>.</p>

<p>But if you do that you've got even <em>more</em> problems: <code>y-1</code> when <code>y</code> is already <code>0</code> is outside of the box. <code>x+1</code> when <code>x</code> is already <code>9</code> is outside of the box. You need to be <em>much</em> more careful with your mathematics.</p>
",1
47992991,47992622,1,"<p>First I think you have a problem with your function definition. Your code expects a <code>unsigned int</code> but in <code>main</code> you write that <code>171</code> shall result in <code>S</code> (i.e. both MSB and LSB set). That will not happen as an <code>unsigned int</code> is more than 8 bits. </p>

<p>So my guess is that you want:</p>

<pre><code>char set_reset(unsigned char number)
                        ^^^^
</code></pre>

<p>In that case your program could be:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;limits.h&gt;

char set_reset(unsigned char number)
{
    unsigned int lsb = number &amp; 1;
    unsigned int msb = number &amp; (1 &lt;&lt; (CHAR_BIT-1));

    if (lsb &amp;&amp; msb) return 'S';
    if (lsb) return 'L';
    if (msb) return 'M';
    return 'R';
}

 int main (void)
{
    printf(""%c\n"", set_reset(150));
    printf(""%c\n"", set_reset(11));
    printf(""%c\n"", set_reset(171));
    printf(""%c\n"", set_reset(42));

}
</code></pre>

<p>Output:</p>

<pre><code>M
L
S
R
</code></pre>

<p>Notice that CHAR_BIT from limits.h is the number of bits in a char. Normally it is 8 but that is not guaranteed. Therefore it is better to take it from limits.h</p>
",0
43212303,43212114,0,"<p>You would have to return a battleship structure.</p>

<p>If you don't need to return anything, just change:</p>

<pre><code>struct battleship
</code></pre>

<p>with:</p>

<pre><code>void
</code></pre>

<p>Meaning the function returns nothing.</p>

<p>Considering you allocate some memory here for something, you probably want to return the address of body, which is a pointer to int type.<br>
In this case, your function should start with:</p>

<pre><code>int * makeShip(int size, int pos)
</code></pre>
",0
43215548,43212114,0,"<pre><code>struct battleship makeShip (int size, int pos)
{
    int i, j;
    int* body;
    body = (int*) malloc (size * sizeof(int));
    for (i = pos; i &lt; (pos + size); i++){
        for (j=0; j &lt; size; j++){
            body[j] = 1;
        }
    }
    struct battleship ship;
    ship.body = body;
    ship.size = size;
    ship.pos = pos;
    return ship;
</code></pre>

<p>}</p>
",0
42494728,42494011,-1,"<p>Here is a code, maybe it can help you</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
using namespace std;


typedef struct Pos {
    int x;
    int y;
} Pos;

Pos * initializeStruct (int x1, int y1) {
    Pos * vars = new Pos();
    vars-&gt;x = x1 + 1;
    vars-&gt;y = y1 + 2;
    return vars;
}

bool func1(Pos *, int );

int main(int argc, char ** argv) 
{
    Pos *vars = new Pos();
    vars-&gt;x = 0;
    vars-&gt;y = 0;

    if (func1(vars, 0)) {
        return 1;
    }
    return 0;
}

bool func1(Pos *vars, int step) {
    if (step == 2) {
        return true;
    }
    func1(initializeStruct(vars-&gt;x, vars-&gt;y), step+1);

    printf(""%d %d\n"", vars-&gt;x, vars-&gt;y);

    return true;
}
</code></pre>
",1
42498217,42494011,1,"<p>You need to use a 'compound literal', which looks like a cast before an initializer:</p>

<pre><code>bool func1(Pos vars, int step) {
    if (step == 2) {
        return true;
    }

    func1((Pos){.x = vars.x + 1, .y = vars.y + 2}, step+1);

    printf(""%d %d"", vars.x, vars.y);

    return true;
}
</code></pre>

<p>This feature was added to C99 ¡ª but since you're attempting to use designated initializers, that presumably isn't a problem to you.</p>

<hr>

<p><sup>
<em>I see that <a href=""https://stackoverflow.com/users/971127/bluepixy"">BLUEPIXY</a> pointed out this notation in a <a href=""https://stackoverflow.com/questions/42494011/pass-struct-into-function-as-its-individual-attributes/42498217#comment72127346_42494011"">comment</a> that I didn't read until after adding this answer.<br>
I've made this Community Wiki.</em></sup></p>
",0
36223997,36223658,1,"<p>We beginners should help each other.</p>

<p>Here is a demonstrative program that shows how this can be done</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main( void )
{
    char *s1 = ""Hello"";
    char *s2 = ""there"";
    char s3[strlen( s1 ) + strlen( s2 ) + 1];

    char *p1 = s1, *p2 = s2, *p3 = s3;
    int first = 0;

    while ( *p1 &amp;&amp; *p2 )
    {
        *p3++ = ( first ^= 1 ) ? *p1++ : *p2++; 
    }

    while ( *p1 ) *p3++ = *p1++;
    while ( *p2 ) *p3++ = *p2++;

    *p3 = '\0';

    puts( s1 );
    puts( s2 );
    puts( s3 );

    return 0;
}
</code></pre>

<p>The program output is</p>

<pre><code>Hello
there
Htehlelroe
</code></pre>

<p>These three statements</p>

<pre><code>while ( *p1 ) *p3++ = *p1++;
while ( *p2 ) *p3++ = *p2++;

*p3 = '\0';
</code></pre>

<p>can be substituted for</p>

<pre><code>while ( *p1 ) *p3++ = *p1++;
while ( *p3++ = *p2++ );
</code></pre>

<p>If the compiler does not support variable length arrays then you need to allocate array s3 dynamically using malloc.</p>

<p>For example</p>

<pre><code>char *s3 = malloc( strlen( s1 ) + strlen( s2 ) + 1 );
</code></pre>

<p>If the first two strings are ""Hello"" and ""goodbye"" then the output will be</p>

<pre><code>Hello
goodbye
Hgeololdobye
</code></pre>

<p>You can also use the approach shown in the post of <strong>@Pedro Rodrigues</strong> . For example</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main( void )
{
    char *s1 = ""Hello"";
    char *s2 = ""there"";
    char s3[strlen( s1 ) + strlen( s2 ) + 1];

    char *p1 = s1, *p2 = s2, *p3 = s3;

    do
    {
        if ( *p1 ) *p3++ = *p1++;
        if ( *p2 ) *p3++ = *p2++;
    } while ( *p1 || *p2 );

    *p3 = '\0';                    

    puts( s1 );
    puts( s2 );
    puts( s3 );

    return 0;
}
</code></pre>

<p>It is the same program as shown by <strong>@Pedro Rodrigues</strong> but it does not use indices.</p>
",1
36224143,36223658,0,"<pre><code>int main()
{
    char c1[]=""Hello"",c2[]=""There"",c3[11];
    int i=0,j=0,k=0;
    while(c1[i]!='\0' &amp;&amp; c2[j]!='\0')
    {
            c3[k]=c1[i];
            k++;
            c3[k]=c2[j];
            k++;
            if(c1[i]!='\0')
                    i++;
            if(c2[j]!='\0')
                    j++;

    }
    c3[k]='\0';
    printf(""%s\n"",c3);
</code></pre>

<p>}</p>

<p>Try this, it'll Work</p>
",1
36224175,36223658,1,"<p>Not sure how much effort you've put into solving this problem, but here goes a possible way of solving it:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(int argc, char **argv)
{
    if(argc != 3)
    {
        printf(""Give me two strings!"");
        return 1;
    }

    int len = strlen(argv[1]) + strlen(argv[2]);
    char mixed_string[len];
    char *a = argv[1];
    char *b = argv[2];
    int i ;
    for(i = 0; i &lt; len;)
    {
        if(*a)
        {
            mixed_string[i++] = *a++;
        }

        if(*b)
        {
            mixed_string[i++] = *b++;
        }
    }

    mixed_string[i] = '\0';

    printf(""%s\n"", mixed_string);

    return 0;
}
</code></pre>

<p>Now a little explanation. The new string's size will be the size of both strings:</p>

<pre><code>int total = strlen(argv[1]) + strlen(argv[2]);
char mixed_string[total];
</code></pre>

<p>We alternate characters between one string and another while the smallest string still has characters to read:</p>

<pre><code>for(i = 0; i &lt; total;)
{
    if(*a)
    {
        mixed[i++] = *a++;
    }

    if(*b)
    {
        mixed[i++] = *b++;
    }
}
</code></pre>

<p>I don't really need to check which one is smaller, that is implicit when I'm checking if the pointers are pointing to something valid.</p>

<p>You can run this on the command line by passing two strings as input (I'm using Bash and GCC here):</p>

<pre><code>? ~/Code/C gcc -o test test.c
? ~/Code/C ./test First Second
FSiercsotnd
</code></pre>

<p>Hope it helps!</p>
",1
37707916,37707855,1,"<ul>
<li>Initialize <code>Menu</code> before using, or you will invoke <em>undefined behavior</em>.</li>
<li>Check if reading is successful, and if not remove junk from the stream.</li>
<li>Add <code>#include &lt;stdlib.h&gt;</code> to use the function <code>exit()</code>.</li>
</ul>

<p>Try this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
    int Menu = 0;
    while (Menu &gt;= 0)
    {
        printf(""\n(1) y"");
        printf(""\n(2) exactness"");
        printf(""\n(3) x"");
        printf(""\n\nTo exit press (0)."");
        printf(""\n\nYour choice: "");
        if (scanf(""%d"", &amp;Menu) != 1)
        {
            /* read error */
            Menu = 9999; /* assign dummy value */
            scanf(""%*s""); /* remove junk */
        }

        switch (Menu)
        {
        case 0:
            {
                exit (0);
            }
        case 1:
            {
                printf(""Please enter a value for y: "");
                break;
            }
        case 2:
            {
                printf(""Please enter the exactness for the calculation: "");
                break;
            }
        case 3:
            {
                printf(""Please enter a value for x: "");
                break;
            }
        default:
            {
                printf(""Wrong input\n"");
            }
        }

    }

}
</code></pre>
",1
37075039,37074900,0,"<p>You can use <code>realloc</code> to get the string of unknown length. Read the entered string character by character until <code>'\n'</code> or <code>EOF</code> is found and use <code>realloc</code> each time to allocate memory for next character to be read.   </p>

<pre><code>char *read_string(void)
{
    int c;
    int i = 0;
    char *s = malloc(1);
    printf(""Enter a string: \t""); // It can be of any length
    /* Read characters until found an EOF or newline character. */
    while((c = getchar()) != '\n' &amp;&amp; c != EOF)
    {
        s[i++] = c;
        s = realloc(s, i+1); // Add memory space for another character to be read.
    }
    s[i] = '\0';  // Nul terminate the string
    return s;
}
</code></pre>
",7
36226227,36185580,0,"<p>The posted code contains some errors in the logic for generating the masks  </p>

<p>The following code is for examining the masks.</p>

<p>I have also included some example bad masks.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;

uint64_t occupancyMaskRook[64];
uint64_t occupancyMaskBishop[64];

void generateOccupancyMasks()
{
    int i;
    int bitRef;
    uint64_t mask;

    for (bitRef=0; bitRef&lt;=63; bitRef++)
    {
        mask = 0;
        for (i=bitRef+8; i&lt;=55; i+=8) mask |= (((uint64_t)1) &lt;&lt; i);
        for (i=bitRef-8; i&gt;=8; i-=8) mask |= (((uint64_t)1) &lt;&lt; i);
        for (i=bitRef+1; i%8!=7 &amp;&amp; i%8!=0 ; i++) mask |= (((uint64_t)1) &lt;&lt; i);
        for (i=bitRef-1; i%8!=7 &amp;&amp; i%8!=0; i--) mask |= (((uint64_t)1) &lt;&lt; i);
        occupancyMaskRook[bitRef] = mask;



        mask = 0;
        for (i=bitRef+9; i%8!=7 &amp;&amp; i%8!=0 &amp;&amp; i&lt;=55; i+=9) mask |= (((uint64_t)1) &lt;&lt; i);
        for (i=bitRef-9; i%8!=7 &amp;&amp; i%8!=0 &amp;&amp; i&gt;=8; i-=9) mask |= (((uint64_t)1) &lt;&lt; i);
        for (i=bitRef+7; i%8!=7 &amp;&amp; i%8!=0 &amp;&amp; i&lt;=55; i+=7) mask |= (((uint64_t)1) &lt;&lt; i);
        for (i=bitRef-7; i%8!=7 &amp;&amp; i%8!=0 &amp;&amp; i&gt;=8; i-=7) mask |= (((uint64_t)1) &lt;&lt; i);
        occupancyMaskBishop[bitRef] = mask;
    }


    printf( ""\n the possible Rook masks\n"");
    for( bitRef=0; bitRef &lt; 64; bitRef++ )
    {
        for( i = 0; i&lt;8; i++ )
        {
            for( int j=0; j&lt;8; j++ )
            {
                putchar( occupancyMaskRook[bitRef] &amp; (((uint64_t)1) &lt;&lt; (i*8+j))? '1' : '0');
            }
            putchar( '\n' );
        }
        puts( ""\n"" );
    }

    printf( ""\n the possible bishop masks\n"");
    for( bitRef=0; bitRef &lt; 64; bitRef++ )
    {
        for( i = 0; i&lt;8; i++ )
        {
            for( int j=0; j&lt;8; j++ )
            {
                putchar( occupancyMaskBishop[bitRef] &amp; (((uint64_t)1) &lt;&lt; (i*8+j))? '1' : '0');
            }
            putchar( '\n' );
        }
        puts(""\n"");
    }
}

int main( void )
{
    generateOccupancyMasks();
    return 0;
}
</code></pre>

<p>the following bad mask is for a bishop in row 6, column 1</p>

<p>Note the missing coverage in the row 8, column 3 and the missing coverage in row 1, column 6</p>

<pre><code>00000000
00001000
00010000
00100000
01000000
00000000
01000000
00000000
</code></pre>

<p>The above is just an example, there are LOTS more bad masks</p>
",0
36257413,36257370,0,"<p>Make a generic pointer.</p>

<blockquote>
  <p>When a variable is declared as being a pointer to type void it is
  known as a generic pointer. Since you cannot have a variable of type
  void, the pointer will not point to any data and therefore cannot be
  dereferenced. It is still a pointer though, to use it you just have to
  cast it to another kind of pointer first. Hence the term Generic
  pointer.</p>
</blockquote>

<p>This <a href=""http://www.nongnu.org/c-prog-book/online/x658.html"" rel=""nofollow"">link</a> has an example.</p>
",2
36781134,36775366,2,"<p>There is a place call <code>scanf()</code>-land that is evil, surround by sharks and crawling with snakes.  Tortured sad code bodies are littered about.</p>

<p>There is a happier place called <code>fgets()</code>-land.  It has a few bumps and pitfalls, but is much safer - code with long old grey beards live there.</p>

<hr>

<p>Step 1: flush the output to insure buffering does not prevent it from being shown <em>after</em> input</p>

<pre><code>printf (""Enter a command for player 1 ([row,col], c, s, p):"");
fflush(stdout);
</code></pre>

<p>Step 2: Read the line</p>

<pre><code>// scanf (""%d,%d"", &amp;x, &amp;y);
char buffer[80];
if (fgets(buffer, sizeof buffer, stdin) == NULL) Handle_input_closed();
</code></pre>

<p>Step 3: Parse the input.  Always check for errors.</p>

<pre><code> int x,y;
 char command;
 if (sscanf(buffer, ""%d,%d"", &amp;x, &amp;y) == 2) {
   Do_xy_Stuff();
 }

 else if (sscanf(buffer, "" %c"", &amp;command) == 1) {
   if (command == 'c') Do_c_Stuff();
   else if (command == 's') Do_s_Stuff();
   else if (command == 'p') Do_p_Stuff();
   else Complain_about_bad_input();

 } else {
   Complain_about_bad_input();

 }
</code></pre>
",0
47961092,47960999,3,"<p>These are multicharacter literals, and their value is implementation-defined.</p>

<p>From C11 6.4.4.4 p10-11:</p>

<blockquote>
  <p>The value of an integer character constant containing more than one character (e.g., 'ab'), or containing a character or escape sequence that does not map to a single-byte execution character, is implementation-de?ned. </p>
</blockquote>

<p>...</p>

<blockquote>
  <p>The value of a wide character constant containing more than one multibyte character or a single multibyte character that maps to multiple members of the extended execution character set, or containing a multibyte character or escape sequence not represented in the extended execution character set, is implementation-de?ned. </p>
</blockquote>

<p>From your testing, it looks like GCC chooses to ignore all but the rightmost character on wide multicharacter literals. However, if you don't specify <code>L</code>, <code>u</code>, or <code>U</code>, GCC will combine the characters given as different bytes of the resulting integer, in an order depending on endianess. This behavior should not be relied on in portable code.</p>
",0
37908030,37907986,3,"<p>You read <code>B_SIZE * 128</code>(512 * 128 = 64k) bytes into a buffer of only 512 bytes. That will write out of bounds of the allocated memory and lead to <em>undefined behavior</em>.</p>

<p>If you want to read only 512 bytes at a time, then do e.g.</p>

<pre><code>fread(data, 1, B_SIZE, file);
</code></pre>
",0
36439889,36434999,1,"<p>use the <code>tcgetattr()</code> function on the serial/usb port used by your terminal to get the current setup of the terminal driver.</p>

<p>use the <code>tcsetattr()</code> function to update the serial/usb port used by your terminal to turn off the <code>echo</code> feature of the terminal driver.</p>

<p>use the <code>escape</code> sequences to move the cursor around on the terminal, change colors, etc.</p>

<p>Be sure to save the original settings returned from the call to <code>tcgetattr()</code> so you can easily restore the terminal driver to its' original settings.</p>

<p>Read the man page for tcgetattr(3) and tcsetattr(3) for all the details of those commands.  The details can be found online at: <code>http://man7.org/linux/man-pages/man3/termios.3.html</code></p>

<p>Read the man page for <code>console_codes(4)</code>.  The details can be found online at: <code>http://man7.org/linux/man-pages/man4/console_codes.4.html</code></p>
",0
36297887,36297736,2,"<p>Fallthough is when a switch case ""falls through"" to another case:</p>

<pre><code>switch(someInt) {
case 0:
    // Do stuff
case 1:
    // Do more stuff
    break;
}
</code></pre>

<p>In this example, if <code>someInt</code> is 0, it will execute both commented sections of code before hitting the <code>break</code> statement, which exits the switch. Forgetting to put in a <code>break</code> after each switch section is a common beginner error. If you want to make <code>case 0</code> only execute it's own code and not the code for <code>case 1</code>, it would look like this:</p>

<pre><code>switch(someInt) {
case 0:
    // Do stuff
    break;
case 1:
    // Do more stuff
    break;
}
</code></pre>

<p>Compiling with optimization simply refers to using the <a href=""https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html"" rel=""nofollow"">optimization option</a> to let the compiler figure out ways to speed up or simplify the program.</p>
",0
38408319,38408258,1,"<p>The latter assignment is identical to:</p>

<pre><code>sum = sum + (uint16_t)HEX_Parse(Buffer[strlen(Buffer)-2]);
</code></pre>

<p>The expression <code>sum + (uint16_t)HEX_Parse(Buffer[strlen(Buffer)-2])</code>, actually has the type <code>int</code>, because of integer promotions.
And as there are no casts to do the explicit conversions, the compiler warns about the implicit conversion from <code>int</code> back to <code>uint16_t</code> when the <code>int</code> expression <code>sum + (uint16_t)HEX_Parse(Buffer[strlen(Buffer)-2])</code> is assigned to <code>sum</code>.</p>

<p>You should cast to the whole expression:</p>

<pre><code>sum = ( uint16_t )( sum + HEX_Parse(Buffer[strlen(Buffer)-2]) );
</code></pre>
",1
41003083,41002986,4,"<p>I am able to compile and run the following with <code>gcc</code> without warning or error:</p>

<pre><code>#include &lt;stdio.h&gt;

void test(void *a)
{
        int *h = a;
        printf(""test: %d\n"", *h);
}

int main(int argc, char const* argv[])
{
        int z = 13;
        test(&amp;z);
        return 0;
}
</code></pre>

<p>The only conceivable reason you would be getting an error on the line you indicated is that you are using a C++ compiler (<code>g++</code> maybe?). If I try that I get the following error:</p>

<pre>
error: invalid conversion from ¡®void*¡¯ to ¡®int*¡¯
</pre>

<p>If you need to use a C++ compiler, you need to explicitly cast <code>a</code> to an <code>int *</code>:</p>

<pre><code>int *h = (int *) a;
</code></pre>

<p>That one change allows this code to compile with <code>g++</code> as well.</p>
",1
46120145,46119956,1,"<p>Your pointer can be static. Malloced memory is always dynamic</p>
",2
34952707,34952627,6,"<p>It's missing parentheses:</p>

<pre><code>int thisChar;
while ((thisChar = getchar()) != '\n') {
    n = n * 10 + thisChar - '0';
}
</code></pre>

<p>Without these additional parentheses, you always assign to <code>thisChar</code> the value of the comparison <code>getchar() != '\n'</code>, i.e. always <code>1</code> or <code>0</code> ...</p>

<p>Note that you should also handle <code>EOF</code>:</p>

<pre><code>int thisChar = getchar();
while (thisChar != EOF &amp;&amp; thisChar != '\n') {
    n = n * 10 + thisChar - '0';
    thisChar = getchar();
}
</code></pre>
",4
34952770,34952627,3,"<p><code>!=</code> have higher precedence than that of <code>=</code> operator. Therefore, the expression   </p>

<pre><code>while(thisChar = getchar() != '\n') {...}  
</code></pre>

<p>will be parsed as  </p>

<pre><code>while(thisChar = (getchar() != '\n')) {...} 
</code></pre>

<p>and the result of the comparison <code>getchar() != '\n')</code> will be assigned to <code>thisChar</code>.   </p>

<p>You need to put the sub-expression <code>thisChar = getchar()</code> inside a bracket  </p>

<pre><code>while((thisChar = getchar()) != '\n') {...}
</code></pre>
",2
36358877,36354759,2,"<p>Even with a change in the test for lower case letters and period, you still have a potential problem because the user might have a period in the name, but still not have a period at the end.    </p>

<p>This code checks for lower case letters only, excluding the last character, and then tests that the last character is a period.<br>
Also there is some control on name length.</p>

<pre><code>int main()
{
    int flag, n;
    char *Nameplate = malloc(22);   //last name of the doctor
    fflush(stdin);

    while(1) {
        printf(""Please enter the last name of your doctor(please type with only small letters):\n"");
        printf(""End name with a period/full stop\n"");
        fgets(Nameplate, 20, stdin);

        /* test for all valid lower case letters */
        flag = 0;
        for(n = 0; n &lt; strlen(Nameplate) - 2; n++) {
           if (!('a' &lt;= Nameplate[n] &amp;&amp; Nameplate[n] &lt;= 'z')) {
               /* not a lower case character */
               flag = 1;
               break;
           }
        }

        /* now test for terminating period */
        if(Nameplate[strlen(Nameplate) - 2] != '.') {
            /* no period at end of name */
            flag = 2;
        }

        /* handle errors or accept */
        if(flag == 1) {
            printf(""small letters only\n"");
        } else if (flag == 2) {
            printf(""remember to end with a period/full stop\n"");
        } else {
            /* name was all lower case with terminating period so exit input */
            break;
        }
    }

    printf(""\n Your appointment with %s has been successfully canceled.\n\n"", Nameplate);
    free(Nameplate);
    return 0;
}
</code></pre>
",5
46614853,46614603,1,"<p>Taking into account how the data member <code>first</code> is used in the code it follows that it is declared either as a character array or a pointer to character. In any case the initialization in this declaration</p>

<pre><code>struct list pivot = A[start]-&gt;first;
</code></pre>

<p>does not make sense because the structure and the character array (or pointer to character) are evidently incompatible types.</p>

<p>It seems you could write instead</p>

<pre><code>const char *pivot = A[start]-&gt;first;
</code></pre>

<p>If you want to use a structure object as a pivot then you should write</p>

<pre><code>struct list pivot = *A[start];
</code></pre>

<p>and further in the code use expression <code>pivot.first</code> instead of <code>pivot</code> as for example</p>

<pre><code>while(strcmp(A[i]-&gt;first, pivot.first) &lt; 0) {
</code></pre>
",2
36393131,36392854,0,"<p>(form the comments)
Remove <code>tid2= tid2 + teach[i].IDnum;</code>.</p>

<p>Yes, you can use <code>if (tid == teach[i].IDnum)</code></p>

<p>However, look at what your <code>while(1)</code> loop in <code>tborrow</code> is doing:</p>

<pre><code>while(1)
   read a teacher from the file
   is the teacher the right one?
      yes - do something
      no  - print an error and recursively call tborrow again.
</code></pre>

<p>Think about how you would do this if you were looking for a teacher by hand in a list on paper - would you look at the first teacher in the list, then give up and start again if it wasn't the right one?</p>
",4
34953736,34953077,0,"<p>This is not an answer, but the comment is not big enough.  If you run this as your main, what is the output?</p>

<pre><code>int main( int argc, char ** argv )
{
    FILE * fin = fopen( ""/www/stest/input1.txt"", ""rt"" );
    if( !fin )
        return 1;
    char buffer[1000];
    while( fgets( buffer, 1000, fin ) )
    {
        size_t token_count;
        char ** tokens = strsplit( buffer, ""@\n"", &amp;token_count );
        if( tokens )
        {
            size_t index;
            for( index = 0; index &lt; token_count; ++index )
                if( !strcmp( tokens[index], ""member"" ) )
                    printf( ""%d: %s  | %s"", index, tokens[index], buffer );
            for( index = 0; index &lt; token_count; ++index )
                free( tokens[index] );
            free( tokens );
        }
    }
    fclose( fin );
    return 0;
}
</code></pre>

<p>When I run with those 5 lines in the text file, I get:</p>

<pre><code>3: member  |     abc@yahoo.com.com@andy@member
</code></pre>

<p>EDIT:</p>

<p>You can tokenize the string without malloc by keeping a second buffer and using pointers to that (still uses memory on the stack).</p>

<pre><code>int main( int argc, char ** argv )
{
    FILE * fin = fopen( argv[1], ""rt"" );
    if( !fin )
        return 1;
    char buffer[1000];
    while( fgets( buffer, 1000, fin ) )
    {
        char buffer_copy[1000];
        strcpy( buffer_copy, buffer );
        char * tokens[1000];
        size_t token_count = 0;
        char * ptr = tokens[token_count] = buffer_copy;
        while( *ptr )
            if( ( *ptr == '@' ) || ( *ptr == '\n' ) )
                *ptr++ = '\0', tokens[++token_count] = ptr;
            else
                ++ptr;

        size_t index;
        for( index = 0; index &lt; token_count; ++index )
             if( !strcmp( tokens[index], ""member"" ) )
                 printf( ""%d: %s  | %s"", index, tokens[index], buffer );
    }
    fclose( fin );
    return 0;
}
</code></pre>

<p>If you go with fixed position (always 3rd (0 indexed)), you can just scan and check:</p>

<pre><code>int is_member( const char * buffer )
{
    if( !buffer )
        return 0;

    size_t index;
    const char * ptr = buffer;
    for( index = 0; index &lt; 3; ++index, ++ptr )
        if( !( ptr = strchr( ptr, '@' ) ) )
            return 0;
    return !strncmp( ptr, ""member"", 6 ) &amp;&amp; ( ( *( ptr + 7 ) == 0 ) || ( *( ptr + 7 ) == '@' ) || ( *( ptr + 7 ) == '\n' ) );
}

int main( int argc, char ** argv )
{
    FILE * fin = fopen( argv[1], ""rt"" );
    if( !fin )
        return 1;
    char buffer[1000];
    while( fgets( buffer, 1000, fin ) )
        if( is_member( buffer ) )
             printf( ""%s"", buffer );
    fclose( fin );
    return 0;
}
</code></pre>

<p>Or if the position is not known, then you can find each token on the fly.  This takes no significant additional memory (a couple pointers) and does not modify your buffer:</p>

<pre><code>int is_member( const char * buffer, const char * delimiters )
{
    size_t index;
    const char * ptr = buffer, * eptr = buffer;
    for( ; eptr; ptr = eptr + 1 )
        // If the next delimiter is found and it is 6 characters away or not found, and the substring matches 'member', return 1.
        if( ( !( eptr = strpbrk( ptr, delimiters ) ) || ( eptr - ptr == 6 ) ) &amp;&amp;
            !strncmp( ptr, ""member"", 6 ) )
            return 1;
    return 0;
}

int main( int argc, char ** argv )
{
    FILE * fin = fopen( argv[1], ""rt"" );
    if( !fin )
        return 1;
    char buffer[1000];
    while( fgets( buffer, 1000, fin ) )
        if( is_member( buffer, ""@\n"" ) )
             printf( ""%s"", buffer );
    fclose( fin );
    return 0;
}
</code></pre>
",3
34953771,34953077,1,"<p>I suspect what you want is something like this:</p>

<pre><code>tokens = strsplit(buf, ""@\n"", &amp;numtokens);
if(numtokens &gt;= 4 &amp;&amp; strcmp(tokens[3],""member"") == 0)
    {
    printf(""%s"",buf);
    }
</code></pre>

<p>As shown in George Houpis's answer it would also be good to double-check that <code>strsplit</code> does not return a null pointer.</p>
",0
36487835,36487621,1,"<p>Problem 1: This is not how you test if a variable is between two values:</p>

<pre><code>    if (0.01 &lt;= c &lt;= 5.20){
</code></pre>

<p>The correct way is</p>

<pre><code>    if (0.01 &lt;= c &amp;&amp; c &lt;= 5.20){
</code></pre>

<p>Your code is interpreted as if you'd written:</p>

<pre><code>    if ((0.01 &lt;= c) &lt;= 5.20){
</code></pre>

<p><code>(0.01 &lt;= c)</code> will be either <code>0</code> or <code>1</code>, and both of these are less than <code>5.20</code>, so it's always true.</p>

<p>Problem 2: The variables <code>a</code> and <code>c</code> need to be <code>float</code>, not <code>int</code>, because <code>int</code> variables can't have fractions in them, and <code>%f</code> format in <code>scanf</code> requires that the corresponding argument be a pointer to <code>float</code>.</p>
",1
37399572,37397756,1,"<p>The fundamental mistake is to think that MS Excel can open a text file and take it as a correctly formatted <code>.xlsx</code> file. The text format accepted by Excel is commonly called a <code>.csv</code> or ""comma separated variable"" file. So I have replaced your <code>tab</code> character with a comma (and simplified each print). When I double-click <code>Graph.csv</code> it correctly runs Excel with the data.</p>

<pre><code>#include &lt;stdio.h&gt;                          // removed trailing ;
#include &lt;stdlib.h&gt;                         // removed trailing ;

int main()
{
    double r,H;
    int i;
    int a=5;
    int b=10;
    int t=5;
    int I=10;
    int y;
    double x,z;
    FILE *fp;
    fp=fopen(""Graph.csv"" ,""wt"");            // open a a CSV file in text mode
    if(fp == NULL) {
        exit(1);                            // added error checking
    }
    for(i=0;i&lt;=1000;i++){
        r = 0.015 * i;
        if(r&gt;=0 &amp;&amp; r&lt;5){
            H=(I*r)/(2*3.14*a*a);
            fprintf(fp,""%f,%f\n"", r, H);    // simplified to a single statement ...
        }
        else if(r&gt;=5 &amp;&amp; r&lt;10){
            H=I/(2*3.14*r);
            fprintf(fp,""%f,%f\n"", r, H);    // ... with a comma instead of a tab ...
        }
        else if(r&gt;=10 &amp;&amp; r&lt;15){
            x=(r*r- b*b);
            y=(t*t+2*b*t);
            z= 1 - x / y;
            H=z*I/(2*3.14*r);
            fprintf(fp,""%f,%f\n"", r, H);    // ... same thing here too
        }
        else
            H=0;

    }
    fclose(fp);
    return 0;
}
</code></pre>
",4
38209022,38208675,2,"<p>Are you sure you aren't looking at your own input? I cut and paste and see: </p>

<pre><code>Please input dimensions: (between 3 and 9, inclusive): 
3
8
7
6
5
...
</code></pre>

<p>The 3 is actually what I typed and is echoed. </p>
",0
38398851,38398816,1,"<p><code>i%i==0</code> will be always true unless <code>i</code> is zero, so <code>isPrime</code> will return <code>0</code> for whatever <code>i</code> which is 2 or greater.</p>

<p>You can use <code>j&lt;i</code> instead of <code>j&lt;=i</code>, for example.</p>

<p>Another point is that your <code>isPrime</code> will mistakenly judge all integers that is 1 or less as primes, so you should check for them before the loop.</p>
",0
38398863,38398816,1,"<p>Apart from being sub-optimal, your code goes all the way to <code>i</code> when trying to find the divisor. This means that all checks will eventually succeed when <code>i == j</code>, so <code>i%j</code> is zero.</p>

<p>A better stopping condition for the loop is</p>

<pre><code>for( j=2 ; j*j &lt;= i ; j++)
</code></pre>

<p>In other words, stop upon passing the square root of <code>i</code>. This is valid, because if you have not found proper divisors smaller than the square root, then it is guaranteed that there are also no divisors larger than the square root.</p>

<p>If you know the upper limit for <code>n2</code>, you could make your solution even faster by pre-computing all primes up to <code>sqrt(n2)</code>, and using them to test whether other numbers are prime or not.</p>
",0
38398870,38398816,2,"<p>You must stop the loop in <code>isPrime</code> before <code>i</code> because all non zero numbers are divisible by themselves:</p>

<pre><code>int isPrime(int i) {
    int j;
    for (j = 2; j &lt; i; j++) {
        if (i % j == 0) {
            return 0;
        }
    }
    return 1;
}
</code></pre>

<p>Note that you should also return <code>0</code> for numbers below <code>2</code>.  Furthermore, you can improve performance dramatically by stopping at the square root of <code>i</code> and by testing only odd numbers above <code>2</code>.  </p>

<pre><code>int isPrime(int i) {
    if (i &lt;= 2) {
        return i == 2;
    }
    for (int j = 3; j * j &lt;= i; j += 2) {
        if (i % j == 0) {
            return 0;
        }
    }
    return 1;
}
</code></pre>
",0
38399214,38398816,0,"<p>For starters 2 is a prime number. And every number is divisible by itself. So this condition</p>

<pre><code>if(i%j==0)
</code></pre>

<p>will be always equal to <code>true</code> when <code>j</code> is equal to <code>i</code>.</p>

<p>The function can be written the following way</p>

<pre><code>int isPrime( unsigned int x )
{
    int prime = ( x == 2 ) || ( x % 2 != 0 &amp;&amp; x &gt; 2 );

    for ( unsigned int i = 3; prime &amp;&amp; i * i &lt;= x; i += 2 )
    {
        prime = x % i != 0;
    }

    return prime;
}
</code></pre>
",0
36315227,36310991,0,"<p>You populate your list backwards,so the first item allocated becomes the last in the list. But the <code>urm</code> member for this item is never initialised with <code>NULL</code> indicating it is the last item.</p>

<p>In the main function:</p>

<pre><code>l=(LISTA)malloc(sizeof(Lista));  //memory allocated for first (last when list is populated) item
l-&gt;urm = NULL;  //initialise urm to NULL, indicating this is the last item
scanf(""%d"",&amp;x);
//etc...
</code></pre>

<p>This way the while loop can detect the last item in the list and stop.</p>
",5
38289105,38289094,3,"<p>It is very simple. Just remove the comma from between.</p>

<pre><code>printf("" %10d 0x%X\n"", answer, answer);
</code></pre>

<p>This should do it.</p>
",1
38289180,38289094,1,"<pre><code>printf("" % % "", , );
</code></pre>

<p>Whatever you write between the "" "" will get printed. The number of % in "" "" will be the number of values you want to print, so they are separated by commas later.</p>
",0
38289836,38289094,0,"<p>What is there to ask about you can simply do :-</p>

<pre><code>printf("" %10d 0x%X\n"", answer, answer);
</code></pre>

<p>And You'll have your output like this:-</p>

<pre><code>5214 0x145E
</code></pre>

<p>You can also include tabs to provide space between them like</p>

<pre><code>printf("" %10d \t 0x%X\n"", answer, answer);
</code></pre>

<p>The answer will look like this:-</p>

<pre><code>5214           0x145E
</code></pre>
",1
37199234,37199061,0,"<p>example</p>

<pre><code>#include &lt;stdio.h&gt;

struct character {
    int *power;
};

void test(struct character *var);

int main (void){
    struct character use_power;
    int power = 5;

    use_power.power = &amp;power;
    test(&amp;use_power);
    printf(""%d\n"", power);

    return 0;
}

void test(struct character *var){
    int use_power = *var-&gt;power;
    *var-&gt;power = use_power * use_power;
}
</code></pre>
",0
37199146,37199061,1,"<p>Your code has many mistakes it can't even compile</p>

<ol>
<li>Multiple missing semicolons.</li>
<li><p>Implicit declaration of <code>test()</code> here</p>

<pre><code>test (use_power)
</code></pre>

<p>with a missing semicolon too.</p></li>
<li><p><code>power</code> is not declared in <code>main()</code>.</p></li>
<li><p>This line</p>

<pre><code>void test use_power()
</code></pre>

<p>does not make sense and is invalid, and also has no semicolon.</p></li>
<li><p>The <code>a</code> instance in <code>test()</code> defined at the end is local to <code>test()</code> and as such will be deallocated when <code>test()</code> returns. The <code>use_power</code> <code>int</code>, has exactly the same problem and trying to extract it's address from the function is useless because you can't access it after the function has returned.</p></li>
</ol>

<p>I have no idea what you were trying to do, but this might be?</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct character {
    int *power;
};

/* Decalre the function here, before calling it
 * or perhaps move the definition here
 */
void test(struct character *pointer);
/*                                  ^ please */

int
main(void) /* int main() is not really a valid signature */
{
    struct character instance;
    test(&amp;instance);
    if (instance.power == NULL)
        return -1;
    printf(""%d\n"", *instance.power);
    free(instance.power);
    return 0;
}

void
test(struct character *pointer)
{
    pointer-&gt;power = malloc(sizeof(*pointer-&gt;power));
    if (pointer-&gt;power != NULL)
        *pointer-&gt;power = 25;
}
</code></pre>
",5
37200314,37199061,0,"<p>Your code seems to be wrong. Your definition for <code>test</code> contains no arguments as </p>

<pre><code>void test () 
{
  int use_power = 25;
  struct character a;
  a.power = &amp;use_power;
}
</code></pre>

<p>but your prototype contains one argument</p>

<pre><code>void test (use_power)
</code></pre>

<p>which is wrongly put. First there are no semicolons<code>;</code> at the end of your prototype declaration, secondly by looking at your code, <code>use_power</code> is a variable and not a datatype so it cannot be present solely in a function declaration.</p>

<p>You will get an argument mismatch error.</p>

<p>You have used the line in <code>main()</code></p>

<pre><code>printf(""%d\n"",*power);
</code></pre>

<p>which is absolutely wrong. you cannot access any member of a structure without a structure variable.</p>

<p>And again, you have not mentioned the<code>;</code> after your call to the incorrect <code>test()</code>before this line</p>

<p>As you have not put your question so properly, I must figure out what you wish to achieve. I bet you want to hold the address of a integer in the pointer member of a structure and then print its value. </p>

<p>Below is a code snippet which will work as you desire.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct character 
{
  int *power;
};
struct character a;    //define a structure variable

void test ();

int main ()
{
  test ();
  printf(""%d\n"",*(a.power)); // print the member of structure variable a 

  return 0; 
}

void test () 
{
  int use_power = 25;
  a.power = &amp;use_power;
}
</code></pre>
",6
36498859,36498832,7,"<p>You can't return more than one variable at once from a function in C. The statement  </p>

<pre><code>return(p, q); // or return p, q; 
</code></pre>

<p>returns <code>q</code> only. The <code>,</code> in <code>p, q</code> is a <a href=""https://en.wikipedia.org/wiki/Comma_operator"" rel=""nofollow"">comma operator</a>. <code>p</code> will be evaluated and it's value will be discarded, then <code>q</code> will be evaluated and then its value will be returned.</p>
",5
43946701,43946650,0,"<pre><code>Temp_s[5-i]=(result%10)+0x30;
</code></pre>

<p>Writes at index 5-i of the array Temp_s 
The result modulo 10 + 48.</p>

<p>The continue skips the statements in the loop and goes back to the i++ statement and after that to the predicate of the loop. But only if i is equal to two.</p>

<p>All in all this should give you the result calculated before as a string representation.</p>

<p>The if i==2 preserves that you do not overwrite the <code>'.'</code>. </p>
",4
43946719,43946650,0,"<p>That's weird.  Looks like you're iterating over that for loop, but you're not executing the code for i == 2.  The continue statement sends you to the next iteration of the for loop before you do anything.  </p>

<p>That'd the kind of code that'd really benefit from a well-placed comment..</p>
",3
43946995,43946650,1,"<p>The code as a whole converts a 5-digit decimal number such as 54321 into <code>""543.21  * C\r\n""</code> ¡ª?except that it doesn't ensure that the string is null terminated.  However, if the target array <code>Temp_s</code> is a global variable and is big enough and is only written to by this function, then probably there is a null at the end already, but it is simpler and safer to make sure.</p>

<p>The assignment <code>Temp_s[0]=0x30;</code> could be dropped, and the loop could be written more clearly as:</p>

<pre><code>for (i = 0; i &lt; 6; i++)
{
    if (i == 2)
        Temp_s[5-i] = '.';
    else
    {
        Temp_s[5-i] = (result % 10) + '0';
        result /= 10;
    }
}
strcpy(&amp;Temp_s[6], ""  * C\r\n"");  // Adds null termination
</code></pre>

<p>Frankly, though, it could (and maybe should) be written as a call to <code>sprintf()</code> (which also ensures that the string is null terminated):</p>

<pre><code>int dp = result % 100;
int un = result / 100;
sprintf(Temp_s, ""%.3d.%.2d  * C\r\n"", un, dp);
</code></pre>

<p>You could write instead (noting that <code>result</code> is an <code>unsigned long</code>, hence the change of format conversion specifier):</p>

<pre><code>sprintf(Temp_s, ""%.3lu.%.2lu  * C\r\n"", result / 100, result % 100);
</code></pre>

<p>It would be preferable to be able to use <code>snprintf()</code>, but it isn't clear how this global variable is declared, and using <code>sizeof(Temp_s)</code> might not be correct:</p>

<pre><code>snprintf(Temp_s, sizeof(Temp_s), ""%.3lu.%.2lu  * C\r\n"", result / 100, result % 100);
</code></pre>
",1
43947009,43946650,3,"<p>Well that's a nice mess for sure. Here's what this code does (assuming there's a <code>Temp_s</code> char array in scope that has at least 13 elements).</p>

<pre><code>void Convert_data_to_temp(unsigned long data)
{
    unsigned long result;
    unsigned char i=0;

    // Calculate... something.
    // Apparently the calculation is done in fixed-point decimal,
    // with 3 decimal places (hence `*1000`).
    // Also, the comment is wrong: that's not rounding off, the result will wrap.
    // In any case, we can be sure that 0 &lt;= result &lt; 100000.
    result=((33*1000*data)/4096)%100000;//rounding off to maximum 5 digits

    Temp_s[0]=0x30; // ASCII for '0'
    Temp_s[3]='.';

    // Now Temp_s looks like this (? represents an indeterminate value:
    //
    // 0 ? ? . ? ? ? ? ? ? ? ? ?

    // Now we're filling Temp_s backwards from the 5th index,
    // with the respective digits of `result`. The `continue` skips over
    // index 3 so we don't overwrite the '.' we just put there.
    for(i=0;i&lt;6;i++)
    {
        if(i==2){continue;}
        Temp_s[5-i]=(result%10)+0x30; // Again, 0x30 is just ASCII '0'.
        result=result/10;
    }

    // Let's say that result was 12345. Now Temp_s looks like this:
    //
    // 1 2 3 . 4 5 ? ? ? ? ? ? ?

    // And now we fill the rest of Temp_s with these hard-coded values.
    // Note that we retrieve i at the value it was left by the for, i.e. 6.
    Temp_s[i]=32;   // 32 is an ASCII space
    Temp_s[i+1]=32;
    Temp_s[i+2]='*';
    Temp_s[i+3]=32;
    Temp_s[i+4]='C';
    Temp_s[i+5]=13; // ASCII Carriage return
    Temp_s[i+6]=10; // ASCII Line feed

    // In the end, Temp_s looks like this:
    //
    // 1 2 3 . 4 5 [space] [space] * [space] C \r \n
}
</code></pre>

<p>Apparently the code is broken, too: the computation of <code>result</code> hints at 3-decimals fixed-point, but the representation ends up with only two decimals, and overwrites the <code>'0'</code> that was assigned at the very beginning.</p>

<p>I suggest you just throw that crazy code away and use the tried-and-true standard library:</p>

<pre><code>snprintf(
    Temp_s, sizeof Temp_s,
    ""%.3lu.%.2lu  * C\r\n"",
    result / 100, result % 100
);
</code></pre>
",0
36526815,36520146,0,"<p>You need to learn some basic of C, in this case: <em>functions</em>.</p>

<p>A function is an operation that can give you (<em>return</em>) something when you eventually feed it with some other things (<em>arguments</em>).</p>

<p>The form of the function is:</p>

<p>return_type name_of_function(argument1, argument2, ...)</p>

<p>you can feed in no arguments if you don't need to.</p>

<p>A function for calculating the area of a circle should be</p>

<pre><code>float circlearea(float radius){
    float area = 2 * PI * radius* radius;
    return area;
}
</code></pre>
",0
41455102,41455031,1,"<p>Use scanf(""%c %c "" , &amp;k, &amp;l ); or scanf("" %c %c"" , &amp;k, &amp;l ); 
This will consume your new line stored in buffer. </p>
",1
36527512,36527471,2,"<p>If your don't want to use <code>printf()</code> there are always other options like <code>putchar(), puts()</code> etc. But still if you don't want to use any one of them then use </p>

<pre><code>system(""echo Hello World!"");
</code></pre>

<p>It will give you the output <code>Hello World!</code></p>
",1
42599181,42599087,0,"<p>try this:</p>

<pre><code>#include &lt;stdio.h&gt;

int main (void) {
   int i;
   printf(""Please enter a number: "");
   scanf(""%d"",&amp;i);      /* Waits for input.    */
   printf(""You entered %d\n"",i);
   return 0;
}
</code></pre>
",5
42539827,42539613,0,"<p><strong>first:</strong> <code>char findThisString[argc];</code> . don't do staff like that. when you declare an array the compiler will need to know the size of the array to find and save place for the array. use pointers, <code>malloc</code> and <code>free</code>. this an undefined behavior that only allowed in C99.</p>

<p><strong>second:</strong> <code>findThisString[i] = argv[i];</code> . you declared one of them as an array of strings (char*) and another as an array of chars (char). </p>

<p><strong>third:</strong> did you declared <code>nextChar</code> somewhere?? use <code>getchar</code> instead.</p>

<p><strong>forth:</strong> you write <code>int i=0; while(...){...; i++; }</code>. this is not an error but when you are writing this loop like this it is better to write 
<code>for(int i=0; i&lt;argc; i++)</code>. </p>
",3
45664153,45664133,4,"<pre><code>struct Name {int stuff; int data;} variable;
</code></pre>

<p>It's just the same thing as, for example, <code>int variable;</code>, so, this is an ordinary variable, but with a complex, or, as pointed out in the comments, a <a href=""https://stackoverflow.com/a/6025530/4354477"">derived</a> type.</p>
",7
45664198,45664133,-1,"<p>you declare the global variable <code>event</code> which type is a <em>""tagless""</em> or <strike><em>""incomplete""</em></strike>  (this is the question for the language lawyers how to call it properly) structure <code>struct { int ventNum;   int eventType; }</code>. As it is the global variable, it is visible in the scope of entire program including your function</p>
",12
45664489,45664133,4,"<p>In your code fragment, <code>event</code> is an instance of an unnamed structure, an uninitialized global variable. At global scope, uninitialized objects have all members initialized to the zero value for their type.</p>

<p>The function <code>function()</code> can use the <code>event</code> name to refer to this object and assign a value to one of its members: <code>event.eventNum = 10;</code>.</p>

<p>You may have seen initialized structure definitions like this:</p>

<pre><code>struct {
    int eventNum;
    int eventType;
} event = { 10, 0 };
</code></pre>

<p>Or C99 specific initalizers like this:</p>

<pre><code>struct {
    int eventNum;
    int eventType;
} event = { .eventNum = 10 };
</code></pre>

<p>These definitions can occur at global or local scope and define an initialized object <code>event</code>.</p>
",0
35199771,35198820,3,"<p>What the above declaration basically does is declare an <code>extern</code> function called <code>my_main()</code> with no arguments.</p>

<p>The <code>__attribute__</code> section is a GNU/LLVM <a href=""https://gcc.gnu.org/onlinedocs/gcc/Attribute-Syntax.html"" rel=""nofollow"">attribute syntax</a>. Attributes are basically pragmas that describe some non-standard or extended feature of the function in question - in this case, <code>my_main()</code>.</p>

<hr>

<p>There are two attributes applied to <code>my_main()</code>.</p>

<p><a href=""https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#Common-Function-Attributes"" rel=""nofollow""><code>__noreturn__</code></a> (search for <code>noreturn</code>) indicates that the function will <em>never</em> return.</p>

<p>This is different from returning <code>void</code> - in <code>void</code>-type functions, calls to the function still <code>return</code> at some point, even without a value. This means execution will jump/return back to the caller.</p>

<p>In <code>noreturn</code> (a.k.a. <code>_noreturn</code> or <code>__noreturn__</code>) functions, this indicates that, among other things, calls to this function shouldn't add the return address to the stack, as the function itself will either exit before execution returns, or will long jump to another point in execution.</p>

<p>It is also used in places where adding the return address to the stack will disrupt the stack in a way that interferes with the called function (though this is rare and I've only ever seen it used for this reason once).</p>

<hr>

<p>The second attribute, <code>asection("".main"",""f=ax"")</code>, is a little more vague. I can't seem to find specific documentation for it, but it seems more or less pretty straightforward.</p>

<p>What it appears to be doing is specifying a <a href=""https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/4/html/Using_ld_the_GNU_Linker/sections.html"" rel=""nofollow"">linker section</a> as well as what <em>appears</em> to be a <a href=""https://en.wikipedia.org/wiki/Chmod#Symbolic_modes"" rel=""nofollow"">unix filemode</a> specifying that the resulting binary is e<strong>x</strong>ecutable, though I could be wrong.</p>

<hr>

<p>When you write native code, all functionality is placed into appropriate sections of the target binary format (e.g. ELF, Mach-O, PE, etc.) The most common sections are <code>.text</code>, <code>.rodata</code>, and <code>.data</code>.</p>

<p>However, when invoking <code>ld</code>, the GCC linker, you can specify a <a href=""https://sourceware.org/binutils/docs/ld/Scripts.html"" rel=""nofollow"">linker script</a> to specify <em>exactly</em> how you want the target binary to be constructed.</p>

<p>This includes sections, sizes, and even the object files you want to use to make the file, specifying where they should go and their size limits.</p>

<p>One common misconception is that you never use <code>ld</code>. This isn't the case; when you run <code>gcc</code> or <code>g++</code> or the <code>clang</code>-family of compilers without the <code>-c</code> flag, you inadvertently invoke <code>ld</code> with a <a href=""http://sourceware-org.1504.n7.nabble.com/How-to-get-the-default-linker-script-used-by-gcc-td141145.html"" rel=""nofollow"">default linker script</a> used to link your binaries.</p>

<p>Linker scripts are important especially for embedded hardware where ROM must be built to memory specification.</p>

<hr>

<p>So back to your line of code: it places <code>my_func()</code> into an arbitrary section called <code>.main</code>. That's all it does. Ultimately, somewhere in your project, there is a linker script that specifies how <code>.main</code> is used and where it goes.</p>

<p>I would imagine the goal of this code was to place <code>my_main()</code> at an <em>exact</em> address in the target binary/executable, so whatever is using it knows the exact location of that function (<code>asection("".main"")</code>) and can use it as an entry point (<code>__noreturn__</code>).</p>
",2
37398003,37397947,1,"<p><strong>TL;DR</strong> The mistake of using <code>=</code> instead of <code>==</code> caused this.</p>

<p>First, you're changing the value of <code>ic</code> unwantedly.</p>

<p>Second, due to operator precedence, </p>

<pre><code>  (ic='U'||ic='u')
</code></pre>

<p>is the same as</p>

<pre><code>  ((ic='U'||ic) = 'u')
</code></pre>

<p>where, the result of <code>(ic='U'||ic)</code> is <strong>not</strong> an lvalue.</p>
",1
37398019,37397947,0,"<p>Are you sure it is not just a simple bug? You usually don't assign in a condition. If I fix that, then you get some program flow:</p>

<pre><code>Enter the number of your conversion option to continue...
1-  Convert from JOD
2-  Convert to JOD
1
Enter the character of your second currency to continue...
U - - USD
E - - EUR
Enter your amount:
</code></pre>

<p>Code</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
void main(){
    float jod_usd=1.41, usd_jod=0.71, jod_eur=1.26, eur_jod=0.8, currency;
    char ic;
    int f;
    printf(""Enter the number of your conversion option to continue...\n1-  Convert from JOD\n2-  Convert to JOD\n"");
    scanf(""%d"",&amp;f);
    printf(""Enter the character of your second currency to continue...\nU - - USD\nE - - EUR\n"");
    scanf(""%c"",&amp;ic);
    printf(""Enter your amount:\n"");
    scanf(""%f"",&amp;currency);
    if(f==1 &amp;&amp; (ic=='U' || ic=='u')){
        printf(""%.2f JOD  - - %.2f USD\n"",currency,(currency*jod_usd));
    }
    if(f==1&amp;&amp;(ic=='E'||ic=='e')){
        printf(""%.2f JOD  - - %.2f EUR\n"",currency,(currency*jod_eur));
    }
    if(f==0&amp;&amp;(ic=='E'||ic=='e')){
        printf(""%.2f EUR  - - %.2f JOD\n"",currency,(currency*eur_jod));
    }
    if(f==0&amp;&amp;(ic=='U'||ic=='u')){
        printf(""%.2f USD  - - %.2f JOD\n"",currency,(currency*usd_jod));
    }
    system(""pause"");

}
</code></pre>
",1
36732646,36732497,0,"<p>I would not have used arrays, I would've done something more like this:</p>

<pre><code>    int dir = 0;
    char hour = 3;
    for(int i=0; i&lt;12; i++){
        float xcoord = rad * cos(dir*M_PI/180);
        float ycoord = rad * sin(dir*M_PI/180);
        printf(...);
        dir += 30;
        hour++;
        hour = (hour &gt; 12) ? 1 : hour+1;
    }
</code></pre>
",0
36732748,36732497,3,"<p>Just taking sequential statements like this and abstracting them into a loop is a task that requires factoring out the parts that are common.</p>

<p>Start with these two pairs of statements:</p>

<pre><code>x[0] = rad * cos(90*M_PI/180);
y[0] = rad * sin(90*M_PI/180);

x[1] = rad * cos(60*M_PI/180);
y[1] = rad * sin (60*M_PI/180);
</code></pre>

<p>What changes here, between the first pair and the second?  Only the index of <code>x</code>/<code>y</code> and the input angle.</p>

<p>We can see from scanning the rest of the statements that the index increments sequentially (value increases by one) with each subsequent pair.  So we could use a simple loop index as the array indices:</p>

<pre><code>for (int i = 0 ; i &lt; 12; i++) {
    x[i] = rad * cos(90*M_PI/180);
    y[i] = rad * sin(90*M_PI/180);
}
</code></pre>

<p>Okay, good start, but now all 12 values will use 90 degrees.  How can we abstract out the angle to make our loop work equivalent to the statements you used?  Start by deciding what the increment should be -- in this case, it's not just by 1 like <code>i</code> was.  We want 30 degrees, which is also one twelfth of 360.</p>

<pre><code>const size_t divisions = 12;
const size_t degrees_per_iter = 360 / divisions;
for (int i = 0 ; i &lt; divisions; i++) {
    x[i] = rad * cos(i*degrees_per_iter*M_PI/180);
    y[i] = rad * sin(i*degrees_per_iter*M_PI/180);
}
</code></pre>

<p>Now, we're off to a good start.  We will cover all 12 values of <code>x</code> and <code>y</code> this way.  But we're not 100% identical to the original code.  Is the order critical?  Let's assume that it <em>is</em> critical, and that will raise the bar a bit.</p>

<p>In order to stay within the valid degree range and keep the output function continuous, we need to use <a href=""https://en.wikipedia.org/wiki/Modulo_operation"" rel=""nofollow"">modulus</a> or remainder division.</p>

<pre><code>const size_t divisions = 12;
const size_t degrees_per_iter = 360 / divisions;
const size_t start_angle_deg = 90;
for (int i = 0 ; i &lt; divisions; i++) {
    const size_t angle_deg = (start_angle_deg + (i * degrees_per_iter)) % 360;

    const float x = rad * cos(angle_deg * M_PI/180);
    const float y = rad * sin(angle_deg * M_PI/180);
    printf(""The x and y coordinates of the 12 o'clock mark are (%f , %f)\n"", x, y);
}
</code></pre>

<blockquote>
  <p>Also wondering if I do need arrays</p>
</blockquote>

<p><strike>Yes, indeed you do!  But you were already using them for <code>x</code> and <code>y</code>.  No further arrays are necessary.</strike>  No arrays are necessary.</p>
",3
38404315,38404286,6,"<blockquote>
  <p>Does anyone know how I can resolve the warning:return makes pointer from integer without a cast [enabled by default] when I return <code>new_cost</code>?</p>
</blockquote>

<p>Change the return type of the function from <code>int*</code> to <code>int</code>.</p>

<p>Returning an <code>int*</code> from that function does not make sense anyway.</p>
",0
37457004,37456438,3,"<p>The member <code>next_buff</code> is a pointer-to-const-data, which means that even if you can change the value of the <code>next_buff</code> pointer itself, you cannot change the contents of the structure(s) it is pointing to. So to fix it, remove the <code>const</code> in the declaration <code>const struct text_object *text_buff</code>.</p>
",3
38855606,38855554,3,"<p>Since you don't have the proper <code>#include &lt;stdio.h&gt;</code> your compiler thinks that <code>printf</code> is a function that should be declared somewhere, hence this:</p>

<blockquote>
  <p>function printf should have a prototype </p>
</blockquote>

<p>also, you forgot <code>;</code> at the end of the line</p>
",0
38855722,38855554,1,"<p>You are missing a semicolon(<code>;</code>) here. In C, every statement ends with a semicolon.  You are also missing a newline (\n) at the end of the string to be printed.  Your <code>printf</code> statement should look like this:</p>

<pre><code>printf(""I see, I remember\n"");
</code></pre>

<p>And about the warning. Warnings are not any error, but are used to show that your code can show undefined behavior.</p>

<p>Use <code>int main()</code> as function name. Here, <code>int</code> is the return type of a function. <code>int</code> before <code>main()</code> means it means the function returns an integer.</p>

<p>So, you might wanna add <code>return 0;</code> at the end of your program as <code>main</code> function expects an <code>int</code> to return. The <code>return 0;</code> statement tells that your program has successfully completed the execution.</p>

<p>And also you are missing a header file <code>#include&lt;stdio.h&gt;</code> from which your <code>printf()</code> function definition comes. If you don't include header files, your compiler thinks that <code>printf()</code> is a function that should be declared somewhere.</p>

<p>Your code should look something like this:</p>

<pre><code>#include&lt;stdio.h&gt;
int main()
{
    printf(""I see, I remember\n"");
    return 0;
}
</code></pre>

<p>I hope this clears your doubts.</p>
",10
38856667,38855554,4,"<p>First of all, Turbo C++ is a <em>very</em> old and discontinued development environment which does not support the latest C programming language standards.  You'd be better off using <a href=""http://www.mingw.org/"" rel=""nofollow"">MinGW</a> or <a href=""http://www.cygwin.com/"" rel=""nofollow"">Cygwin</a> instead.  </p>

<p>Secondly, the code pasted here is missing a few things; either you didn't copy it correctly, or the book you're using is not well-written.  Here's what the code <em>should</em> look like using modern C:</p>

<pre><code>#include &lt;stdio.h&gt;

int main( void )
{
  printf( ""I see, I remember\n"" );
}
</code></pre>

<p>As of the C99 language standard, implicit function declarations are no longer allowed; the compiler will no longer assume that a function returns <code>int</code> if the type isn't specified.  </p>

<p>Also, you should not leave the parameter list for <code>main</code> empty; in this case, we're specifying that <code>main</code> takes no arguments using the <code>void</code> keyword<sup>1</sup>.</p>

<p><code>printf</code> writes to standard output, and standard output is usually <em>line buffered</em>, meaning the output won't appear on your console unless you fill the buffer or send a newline character (<code>'\n'</code>).  </p>

<p>Also as of C99, you don't need an explicit return from <code>main</code>, even though it's typed to return an integer value; by default, it will return 0 to the runtime environment when the program finishes executing.  </p>

<p><hr>
<sup></p>

<ol>
<li><code>main</code> is unique in that it can either take no arguments (<code>int main( void )</code>) or two arguments (<code>int main( int argc, char **argv )</code>) for processing command-line parameters, and implementations <em>may</em> provide additional versions.
</ol>

<p></sup></p>
",5
47548335,47548244,1,"<p>Your prototype makes no sense, <code>openFile()</code> can't change the caller's <code>FILE *</code> when it's passed by value, you need to pass the address of the pointer in that case:</p>

<pre><code>int openFile(FILE **inputFile)
{
  *inputFile = fopen(""input.txt"", ""rt"");
  return *inputFile == NULL ? -1 : 0;
}
</code></pre>

<p>But of course this serves very little purpose, just use <code>fopen()</code> directly where you want to open a file, instead. Returning the pointer to the open file is easier to work with, instead of having to manage a separate <code>int</code> that carries no added value or information (an <code>int</code> being 0 or -1 is not ""better"" than a pointer being <code>NULL</code> or not <code>NULL</code>).</p>
",0
47548344,47548244,0,"<p>You should return <code>inputFile</code> itself. That wauy you can reused it from other function.
Also why pass that <code>FILE*</code> to <code>openFile</code> function? It's redundant.</p>

<p>Design-wise you can pass the filename and the parameters like <code>r</code>,<code>w</code> etc.</p>

<pre><code>FILE* openFile(const char*name, const char*params)
{
    inputFile = fopen(name, params);

    if (inputFile != NULL)
        return inputFile;
    else
        return NULL;
}
</code></pre>

<p>But in doing that you are just abstracting out the <code>fopen()</code> call. You still have to check the return value of <code>openFile()</code>. You can use double pointer and achieve the same thing but yes I have provided with an alternative. </p>

<pre><code>FILE *inputFile = openFile(""input.txt"",""r"");
if( !inputFile ){
    //...
}
</code></pre>

<p>The thing is as far as the method shown this is really doing anything other than wrapping the <code>fopen()</code> call. What you can get to know from this answer that you can pass the pointer around in Functions and how to use it.</p>

<p>Other answer provides how you use the double pointer but do you get what happened in previous case?</p>

<p>You are changing the local variable that is passed to <code>openFile()</code>. You change it. And when the function completes then that local variable is not there anymore. It's value wont affect the <code>FILE*</code> variable in <code>main()</code>.</p>

<p>To be clear you don't need this method to open a file. It's better if you use the 2 lines alone. Because there is no improvement whatsoever. You still have to check the return value just like you would have in case of direct <code>fopen</code> call.</p>
",0
36393566,36393513,1,"<pre><code>printArray(array[5][3], v);
</code></pre>

<p><code>array[5][3]</code> means the element in the 6th row and 4th column. There are two obvious problems here:</p>

<ul>
<li>The array doesn't have 6 rows and 4 columns.</li>
<li>The function expects you to pass (a pointer to) the entire array, not just one element of it.</li>
</ul>

<p>Change it to:</p>

<pre><code>printArray(array, v);
</code></pre>
",2
36557976,36557874,1,"<p>Here is how you can pass an array of integers to a function:</p>

<pre><code>#include &lt;stdio.h&gt;

void print_array(int arr[]);

int main()
{
    int my_array[] = { 1, 2, 3, 4, 5 };

    print_array(my_array);

    return 0;
}

void print_array(int arr[])
{
    int i;

    for (i = 0; i &lt; 5; ++i)
        printf(""%d "", arr[i]);
    printf(""\n"");
}
</code></pre>
",0
36558017,36557874,1,"<p>Probably this might be what you are looking for :</p>

<pre><code>for (counter = 0; counter &lt; 5; counter++) //notice changes here as well
    {
          printf(""How long is chart %d? "", counter) ;
          scanf(""%d"", &amp;chart) ;
          changeToAsterisk(chart);
    }
</code></pre>

<p>where your method definition can have the for loop of displaying the asterisk using the argument(not exactly but something like this ) :</p>

<pre><code>void changeToAsterisk(int chartNumber) {
  printf (""1.  %d|"", chartNumber);
  for (int i = 0; i &lt; chartNumber; i++)
    {
     printf(""*"");
    }
}
</code></pre>
",1
40529316,40529276,1,"<p>Yes, but probably not in a very portable way.</p>

<p>You need to figure out howe to control your terminal, so that you can send the necessary control codes to move the cursor as needed to build the box and then move back inside it.</p>

<p>One popular library that does this (and more) is <a href=""https://www.gnu.org/software/ncurses/"" rel=""nofollow noreferrer"">GNU ncurses</a>.</p>
",0
36811796,36811471,0,"<p><code>for(;a[i]!=' '||a[i]!='\0';i++)</code>  </p>

<p>This should be changed to  </p>

<p><code>for(;a[i]!=' '&amp;&amp; a[i]!='\0';i++)</code></p>

<p>Try following code</p>

<p>`</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
void main()
{
    int i,n,m,j;
    char a[100];
    printf(""Enter your sentence: "");
    gets(a);
    n=strlen(a);
    m=n-1;
    for(i=m;i&gt;=0;i--)
    {
        if(a[i]== ' '){
            for(j=i+1;(a[j]!=' ') &amp;&amp; (a[j]!='\0');j++)
                printf(""%c"",a[j]);
            printf("" "");
            }
        else if(i==0){
            for(j=i;(a[j]!=' ') &amp;&amp; (a[j]!='\0');j++)
                printf(""%c"",a[j]);
            }
    }
}
</code></pre>

<p>`</p>
",0
36811805,36811471,0,"<p>Your code seems particularly hard to read, I think you should rather do something such as this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define MAGIC_NUMBER 100

int is_separator(char c)
{
    return c == ' ' || c == '\t' || c == '\n';
}

int main()
{
    char input[MAGIC_NUMBER];
    char output[MAGIC_NUMBER];

    printf(""Enter your sentence\n"");

    if (fgets(input, MAGIC_NUMBER, stdin) == NULL)
    {
        printf(""No input!\n"");
        return 1;
    }

    // Length of input line
    int n = strlen(input);

    // let set i be the position of previous found word
    int i = n;

    // let first_word be 1 as long as output is empty
    int first_word = 1;

    // Let's initialize output as a empty string
    strcpy(output, """");

    while (i &gt; 0)
    {
        // Searching last character of next word
        int j = i;
        while (j &gt; 0 &amp;&amp; is_separator(input[j - 1]))
        {
            j--;
        }

        // Searching first character of next word
        int k = j;
        while (k &gt; 0 &amp;&amp; !is_separator(input[k - 1]))
        {
            k--;
        }

        if (k &lt; j)
        {
            // Adding a new word
            if (first_word)
            {
                first_word = 0;
            }
            else
            {
                // If it is not first found word, insert a space
                strcat(output, "" "");
            }

            strncat(output, input + k, j - k);
        }

        i = k;
    }

    printf(""%s\n"", output);

    return 0;
}
</code></pre>
",0
39603483,39603241,2,"<p>I took the liberty to comment the code a bit</p>

<pre><code>/*
  Convert an unsigned 32-bit (assuming UINT32 to mean uint32_t or similar) large
  integer to a hexadecimal representation
*/
bool uint32tox(const UINT32 input, UINT8 *str)
{
    UINT32 val = input;
    INT16  i;
    UINT16  j = 0;

    if (str == NULL) return(false);

    for (i = 28; i &gt;= 0; i -= 4) {
        // Shift input by i bits to the right and snip of the rightmost 4 bits
        /*

            0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31

            with i = 28 sval contains the leftmost four bits 28 - 31
            with i = 24 sval contains bits 24-27
            with i = 20 sval contains bits 20-23
            with i = 16 sval contains bits 16-19
            with i = 12 sval contains bits 12-15
            with i =  8 sval contains bits  8-11
            with i =  4 sval contains bits  4- 7
            with i =  4 sval contains bits  0- 3
        */
        UINT8 sval = (val &gt;&gt; i) &amp; 0x0F;
        // If sval is smaller than ten we can use a base ten digit
        // that gets constructed by adding the numerical value of ASCII '0'
        // to sval (the digits 0-9 are guaranteed to be in order without gaps).
        // If sval is bigger we need a hexdigit, one of A, B, C, D, E, F.
        // These are normally consecutive at least in ASCII, so you can handle it
        // like the other branch and just add the numerical value of 'A' instead
        str[j++] = (sval &lt; 10u) ? sval + '0' : sval - 10 + 'A';
    }
    // terminate the UINT8 array such that it can be used as a C-string
    str[j] = '\0';
    return(true);
}
</code></pre>
",8
39603561,39603241,1,"<p>first and foremost, this function is broken, as it has no size for the *str buffer, can cause malicious attacks, or plain buggy overflows.</p>

<p>secondly, you can use <code>sprintf(strOut, ""%x"",input);</code> instead of this function.</p>

<h2>Third, i'll explain this function:</h2>

<p>there is a trick, where each Hex digit, is 4 binary bits bits:</p>

<pre><code>0100 1111 0010 1101 0011 1110 1111 0000 &gt;&gt; 83,022,831
4 =4 15=F 2 =2 13=D 3 =3 14=E 15=F 0 =0 &gt;&gt; 0x4F2D3EF
</code></pre>

<ol>
<li>loops starts at <code>i=28</code></li>
<li>shift val 28 places right >> leaves 4 Left Bit [28-31] as Right most bits.</li>
<li>mask with 0x00000F >> leaves only the 4 right most bits.</li>
<li>if the number is smaller than 10 (where we start counting with Letters), add the ASCII of '0' (e.g 3 will '0' is 48 + 3 = 51 = '3')</li>
<li>if the number is bigger then 10, then subtract 10, and add the ASCII of 'A' (e.g 14 will be 14-10=4 > 'A' is 65 + 4 = 69 = 'E')</li>
<li>subtract 4 from i, therefore shifting 24 bits and doing the same on bits [24-27]
until <code>i=0</code> is processed.</li>
</ol>
",5
36837744,36837104,0,"<p>There is a reason why this can happen: when you try to write in strings that are in the code section of your program (instead of on stack or heap).</p>

<p>Calling the code like this (the data is in the (readonly) code section):</p>

<pre><code>char *s = ""1234567890"";
delchar(s, '5');
</code></pre>

<p>will segfault, but this (the data is on the heap):</p>

<pre><code>char *s;
s = malloc(1024);
strcpy(s, ""1234567890"");
delchar(s, '5');
</code></pre>

<p>will not.</p>

<p>To fix, I  would not touch the existing <code>char *</code>, but allocate a new one, copying every character, except the one you want to delete from it (note: code isn't tested, but you get the idea).</p>

<pre><code>char *delchar(const char *s, char c) {
    char *n, *p = calloc(strlen(s)+1, 1);
    n = p;
    while (*s != '\0') {
       if (*s != c) {
          *n = *s;
          n++;
       }
       s++;
    }
    return p;
}
</code></pre>

<p>the code is cleaner, easier to read and you are not touching existing strings. Don't forget to <code>free()</code> the result of course. </p>
",12
36837866,36837104,2,"<p>Even though you won't get a segmentation fault because of that, there is a flaw in your algorithm. You advance your <code>p</code> cursor even if you deleted a char.</p>

<p>Use a <code>while</code> instead of a <code>for</code>:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void delchar(char *s, char c)
{
    char *p, *q = NULL;

    p = s;
    while (*p != '\0')
    {
        if (*p == c)
        {
            q = p;
            do {
                *q = *(q + 1);
                q++;
            } while(*q != '\0');
        }
        else
            p++; // Advance cursor only if no character was deleted
    }
}

int main()
{
    char str[1024];
    strcpy(str, ""Yes or  no?"");
    delchar(str, ' ');
    printf(""%s\n"", str);

    return 0;
}
</code></pre>

<p>output:</p>

<blockquote>
  <p>Yesorno?</p>
</blockquote>

<p>A reason why you could get a segmentation fault is because trying to update an string literal. String literals are not done to be modified. They are not the same at all than an array of char. The main difference is you cannot overwrite their content.</p>

<pre><code>int main()
{
    char *str = ""to to""; // string literal
    delchar(str, ' '); // segmentation fault

    char array[] = ""to to""; // array of char
    delchar(array, ' '); // no segmentation fault
    printf(""%s\n"", str);

    return 0;
}
</code></pre>

<p>You could duplicate your string with <code>strcpy()</code> the same way I do above, or you can use an array of chars instead of a string literal.</p>
",6
36838911,36837104,-1,"<p>The typical algorithm for removing all occurrences of a character from a string would be:</p>

<pre><code>void remove_ch (char* restrict dest, const char* restrict src, char ch)
{
  while(*src != '\0')
  {
    if(*src != ch)
    {
      *dest = *src;
      src++;
    }
    dest++;
  }

  *dest = '\0';
}
</code></pre>

<p>To do in-place deletion, you will have to rewrite this function. Remove <code>restrict</code> and also consider using a temporary <code>char</code> memory location, since copying between overlapping memory regions could invoke undefined behavior. </p>

<p>Once that modification is done, you should be able to pass the same parameter as both <code>dest</code> and <code>src</code>.</p>
",0
46982460,46982380,1,"<p>A good way of doing this would be putting all your file pointers in an array:</p>

<blockquote>
<pre><code>FILE *inputfp[6];
</code></pre>
</blockquote>

<pre><code>for(int i=0;i&lt;6;i++)
{
  inputfp[i] = fopen(argv[i+1], ""r"");                         //Open file for read.

  if (inputfp[i] == NULL)
  {
    printf(""Error opening file %s!"",argv[i+1]);    //Program prints error message and closes if file is not found            
    exit(0);
  }
}
</code></pre>
",0
46982516,46982380,0,"<p>I'd do it the first way, but use a loop:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;

int main(int argc, char **argv) {

    char line[80] = {0};
    FILE *inputfp1;

    if( argc == 7 )
    {
        /*printf(""The first argument supplied is %s\n"", argv[1]);
        printf(""The second argument supplied is %s\n"", argv[2]);
        printf(""The third argument supplied is %s\n"", argv[3]);
        printf(""The first argument supplied is %s\n"", argv[4]);
        printf(""The second argument supplied is %s\n"", argv[5]);
        printf(""The third argument supplied is %s\n"", argv[6]);
        printf(""The third argument supplied is %s\n"", argv[7]);*/
    }
    else if( argc &gt; 7 )
    {
        printf(""Too many arguments supplied.\n"");
        exit( 1 );
    }
    else
    {
        printf(""Not enough arguments supplied. \n"");
        exit( 1 );
    }

    for (int i = 1; i &lt; argc; ++i)
    {
        inputfp1 = fopen(argv[i], ""r"");                         //Open file for read.
        if (inputfp1 == NULL)
        {
            printf(""Error opening file %s!"",argv[i]);    //Program prints error message and closes if file is not found            
            exit(0);
        }

        while(fgets(line, 80, inputfp1) != NULL)
        {
            //do work
        }
        fclose(inputfp1);
    }
    return 0;
}
</code></pre>
",4
36500006,36499895,3,"<p><code>stack</code> is a pointer and it must be pointing to some valid memory location. Since <code>stack</code> is passed to the function and isn't initialized, you are getting a warning. In the function you are trying to access some random memory location which can cause the program crash or any erroneous behavior of the program, aka undefined behavior.</p>
",0
36500178,36499895,3,"<p>Change this:</p>

<pre><code>struct Arr *stack;
</code></pre>

<p>To this:</p>

<pre><code>struct Arr stack;
</code></pre>
",0
36500222,36499895,4,"<p>As haccks answer says, </p>

<ul>
<li>you need to initialize your pointer, so it points to a real location</li>
<li><p>pass the pointer (rather than the address of the pointer variable)</p>

<pre><code>int main() 
{
   struct Arr realArray;   // allocate memory for the Arr (on the CPU's stack)
   struct Arr *stack;      // pointer variable (undefined)

   stack = &amp;realArray;     // make variable ""stack"" point to realArray

   initArr(stack, 2);      // pass the pointer to realArray
} 
</code></pre></li>
</ul>
",1
36500719,36499895,0,"<p>First look at the declaration of your initArr function:</p>

<pre><code>void initArr(struct Arr * da, int capacity)
</code></pre>

<p>Your first argument is of type 'pointer to a struct'</p>

<p>Now look at your invocation of this function:</p>

<pre><code>struct Arr *stack;
initArr(&amp;stack, 2);
</code></pre>

<p>We see that stack is of type 'pointer to a struct', and in the function you are passing the address of stack (<em>.i.e.</em> the type is a pointer to a pointer to a struct).  Which is what the gcc error is about, the note actually gives more information about the type that the function expects and the type that you are providing</p>

<p>There are two ways to fix this</p>

<ol>
<li><p>leave the declaration of <code>initArr</code> as it is, and then change the function
invocation from <code>initArr(&amp;stack, 2)</code> to <code>initArr(stack, 2)</code>.  In this case you will need to make sure that you have allocated memory for the structure prior to passing it to the function;</p>

<pre><code> int main()
 {
     struct Arr* da = NULL;
     da = malloc(sizeof(struct Arr));

     initArr(da, 2);
 }
</code></pre></li>
</ol>

<p>or equivalently,</p>

<pre><code>     int main
     {
         struct Arr     stack;

         initArr(&amp;stack, 2);
     }
</code></pre>

<p>I would probably go for one of the above solutions.</p>

<ol start=""2"">
<li><p>Modify the declaration of <code>initArr</code> to <code>initArray(struct Arr** da, int capacity)</code>.  You will still need to make sure memory is allocated as before.  However, if you change <code>initArr</code> to:</p>

<pre><code>void initArr(struct Arr** da, int capacity)
{
     *da = malloc(sizeof(struct Arr));
     (*da)-&gt;data = malloc(sizeof(TYPE) * capacity);
     (*da)-&gt;size = 0;
     (*da)-&gt;capacity = capacity;
}
</code></pre></li>
</ol>

<p>In this case I am changing the semantics of your <code>initArr</code> function so that I am initializing the structure all in one place.  The code in your main function would remain unchanged.  </p>

<p>N.B.  For clarity, error checking has been omitted in the above code snippets, please don't do this in real code. Always check the return value from malloc to ensure that memory has been allocated.  </p>
",0
34977557,34976743,1,"<p>Okay, since you have mentioned you are a beginner. let me explain.</p>

<p>This happens when your program crashes. It can be for various reasons. Normally you will have to use some debugging tool. But in this case, is simple as  ""Joachim Pileborg"" has mentioned in the comments.</p>

<p>You have to think about what happens when 'b' becomes zero. You are trying to divide something by zero. That is not mathematically possible. That's why your program crashes.</p>

<p>This has to do with basic mathematics, not programming. 
<a href=""http://mathforum.org/dr.math/faq/faq.divideby0.html"" rel=""nofollow"">take a look</a></p>
",0
47962749,47962448,2,"<p>The problem here is that </p>

<p>When you enter the character and then you press <kbd>enter</kbd>, you input two characters. One is the alphabetic character you enter and the other is the <code>\n</code>. That's why you get what you see. Solution is to consume the white space charcaters ..which is done by putting the <code>' '</code> in the <code>scanf</code>. </p>

<pre><code>scanf("" %c"", &amp;array[index]);
       ^
</code></pre>

<p>Why it works? </p>

<p>Quoting the <a href=""http://port70.net/~nsz/c/c11/n1570.html#7.21.6.2p5"" rel=""nofollow noreferrer"">standard- <strong>7.21.6.2</strong></a></p>

<blockquote>
  <p>A directive composed of white-space character(s) is executed by
  reading input up to the first non-white-space character (which remains
  unread), or until no more characters can be read. The directive never
  fails.</p>
</blockquote>

<p>Example code:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define SIZE 6

int main(void)
{
    char array[SIZE];
    int index;

    printf(""Please enter letters a to z.\n"");
    for(index = 0; index &lt; SIZE; index++)
        if( scanf("" %c"", &amp;array[index]) != 1){
            fprintf(stderr,""%s\n"",""Error in input"");
            exit(1);
        }
        else {
            printf(""read: %c\n"",array[index]);
        }
    for(index = 0; index &lt; SIZE; index++)
        printf(""%c"", array[index]);

    putchar('\n');
    return 0;
}
</code></pre>
",5
34940078,34940061,3,"<pre><code>b=2*cond*dt/(dx*dx);
</code></pre>

<p>Variables <code>dt</code> and <code>dx</code> are uninitialized and using uninitialized variables leads to undefined behavior.</p>

<p>You have a VLA based on variables <code>i</code> and <code>j</code> and they are uninitialized too.
Since <code>i</code> and <code>j</code> are uninitialized and you are using them to create an array looks like the value of <code>i</code> and <code>j</code> is some hugh value and there is no enough stack memory to allocate that array and you are seeing a crash.</p>
",2
37072882,37072738,2,"<p>The reason is that you invoked undefined behaviour when you supplied AGE macro to printf. The format string in your code expects a string argument, but in reality your AGE macro is an integer constant literal.</p>

<p>You've got 2 options: either change format string from</p>

<pre><code>""My name is %s and is %s\n""
</code></pre>

<p>to</p>

<pre><code>""My name is %s and is %d\n""
</code></pre>

<p>or change your AGE macro from</p>

<pre><code>#define AGE 30
</code></pre>

<p>to</p>

<pre><code>#define AGE ""30""
</code></pre>
",0
37072889,37072738,2,"<p>To understand what is going on, do manual substitution the way the preprocessor does:</p>

<pre><code>printf(""My name is %s and is %s\n"", NAME, AGE);
</code></pre>

<p>becomes</p>

<pre><code>printf(""My name is %s and is %s\n"", ""Doelal"", 30);
</code></pre>

<p>Now match the <code>%</code> specifiers in the format string to the parameters. Do you see a mismatch in printing a number <code>30</code> with a <code>%s</code> format specifier?</p>

<p>You can fix it by providing the proper <code>%d</code> format specifier for the age:</p>

<pre><code>""My name is %s and is %d\n""
//                     ^
</code></pre>
",0
34972206,34972127,1,"<p>From the <a href=""https://dev.mysql.com/doc/refman/5.7/en/mysql-stmt-close.html"" rel=""nofollow"">manual for <code>mysql_stmt_close</code></a>:</p>

<blockquote>
  <p>Closes the prepared statement. mysql_stmt_close() also deallocates the
  statement handle pointed to by stmt.</p>
</blockquote>

<p>If you do:</p>

<pre><code>MYSQL_STMT prepared = *mysql_stmt_init(&amp;_mysql);
mysql_stmt_close(&amp;prepared);
</code></pre>

<p>That passes a pointer to a <em>stack</em> variable into the <code>mysql_stmt_close</code> function which will then try to <code>free</code> it resulting in the error you saw. Instead, you must pass in the original pointer returned by <code>mysql_stmt_init</code> as shown in your first code snippet. <code>mysql_stmt_init</code> returns dynamic memory (obtained via <code>malloc</code> or similar function) which then needs to be freed by <code>mysql_stmt_close</code>.</p>
",3
34972237,34972127,0,"<p>From the <a href=""http://dev.mysql.com/doc/refman/5.7/en/mysql-stmt-init.html"" rel=""nofollow"">MySQL API</a>:</p>

<pre><code>23.8.11.15 mysql_stmt_init()
----------------------------

MYSQL_STMT *mysql_stmt_init(MYSQL *mysql)

Description

Create a MYSQL_STMT handle. The handle should be freed with mysql_stmt_close(MYSQL_STMT *).
</code></pre>

<p>The <code>mysql_stmt_init()</code> function returns a <em>pointer</em> to a <code>MYSQL_STMT</code>.  The part saying that it ""should be freed"" implies that it is dynamically allocated from the heap.  The value returned is the memory address (pointer) of this heap memory.  To properly free it, the same memory address (pointer value) must be given to <code>mysql_stmt_close()</code>.</p>

<p>When you use your original <code>MYSQL_STMT prepared = *mysql_stmt_init(&amp;_mysql);</code> version, you are <em>copying the value</em> of the <code>MYSQL_STMT</code> returned into the local variable <code>prepared</code>, which resides on the stack.  When you take the address of this to give to <code>mysql_stmt_close(&amp;prepared)</code> you are not giving the original memory address from the heap that you were given by <code>mysql_stmt_init()</code>.</p>
",0
34978899,34978503,2,"<p>Like thurizas says, ""Undefined reference"" means that an external function or variable you use cannot be found by the linker (the part of the compiler which pieces together your code objects into the final program). Usually this means you forgot to link with a library, or your linker found the wrong version of that library.</p>

<p>In this case you should add ""-lSDL2"" to your compiler command line which means ""link with libSDL2.so"". This is necessary <em>in addition</em> to you #including the header files. Only the standard C library (libc.so) is linked in by default (-lc).</p>
",3
46633119,46633025,0,"<p>Your first assertion works because the difference is just too small for the precision to work (Floating point precision is limited).</p>

<p>That's why your second assertion works.</p>
",0
46633123,46633025,2,"<p>If you compile the following code:</p>

<pre><code>#include &lt;stdio.h&gt;
int main() {
    float a=5.00;
    float b=5.01;
    float c=0.01;
    printf(""%.25f"",a-b+c);
}
</code></pre>

<p>The value should be mathematically zero, but floating-point errors mean that the result will not be precisely zero. On my system this prints out <code>-0.0000002291053533554077148</code>.</p>

<p>For this reason, testing floats for inequality typically checks to within a small elipson instead of testing for exact inequality.</p>
",0
39114251,39114247,3,"<p>This is not a function. The first part is a <code>typedef</code> that defines a <a href=""https://en.wikipedia.org/wiki/Struct_(C_programming_language)"" rel=""nofollow"">structure</a>. And the latter is the definition of an initialized array of the structure type <code>PRE25G</code>.</p>
",0
46129962,46129661,2,"<pre><code>e - c == k;
</code></pre>

<p>This line of code has no effect. It checks whether the value of <code>e - c</code> is equal to that of <code>k</code> but nothing is done with the result of the check.</p>

<p>If you want to <em>assign</em> a value to <code>k</code>, use <code>k = e - c</code>. Likewise with <code>l = f - d.</code></p>

<p><code>if (e - c &gt;= 0, f - d &gt;= 0)</code> should be  <code>if (e - c &gt;= 0 &amp;&amp; f - d &gt;= 0)</code>. Multiple conditions for an <code>if</code> statement cannot be joined using a comma. The logical operator <code>&amp;&amp;</code> means <em>'and'</em>.</p>
",0
38409879,38409836,1,"<pre><code>while (nums[i + 1] == nums[i]) { ... }
</code></pre>

<p>Consider what happens with arrays like <code>[1, 2, 2, 2, 2, 2]</code>. It'll happily read past the end.</p>

<p>You need to stop the loop when you reach the end:</p>

<pre><code>while (i+1 &lt; numsSize &amp;&amp; nums[i + 1] == nums[i]) { ... }
</code></pre>
",0
39109378,39109280,0,"<p>First of all, you have declared <code>uname</code> and <code>passwd</code> as single characters, but you want to read strings. So you need to define the maximum length for each one and declare them as following:</p>

<pre><code>char [X] uname;     //where X is the maximum length for uname, for instance 25
char [Y] passwd;   //where Y is the maximum length for passwd, for instance 20
</code></pre>

<p>Accordingly, your <code>scanf()</code> function should then be modified to :</p>

<pre><code>scanf(""%s"", uname);
scanf(""%s"", passwd);
</code></pre>

<p>Apart from that, you need <code>strcmp()</code> to compare a string with a value. Change your <code>if</code> statement to :</p>

<pre><code>if ( (strcmp(uname, ""waw"") == 0) &amp;&amp; (strcmp(passwd, ""wow"") == 0) ) {
   printf(""You have logged in\n"");
</code></pre>
",4
39109415,39109280,4,"<p>1) Don't read (scan) into a char. You need a string. Use format specifier %s instead of %c</p>

<p>2) Use strcmp to compare string values</p>

<p>Try this:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(){
   int res;
   char uname[40];   // char arrays instead of single char
   char passwd[40];

   printf(""Enter your username: "");
   res = scanf(""%39s"", uname);  // Set a maximum number of chars to read to
                                // 39 to avoid overflow
   if (res != 1) exit(1);       // Error on stdin. End program

   printf(""Enter your password: "");
   res = scanf(""%39s"", passwd);
   if (res != 1) exit(1); // Error on stdin

   printf("" \n"");

   // Use strcmp to compare values of two strings.
   // If strcmp returns zero, the strings are identical
   if ((strcmp(uname, ""waw"") == 0) &amp;&amp; (strcmp(passwd, ""wow"") == 0)){
       printf(""You have logged in\n"");
   } else{
       printf(""Failed, please try again\n"");
   }
   return 0;
}
</code></pre>
",1
39110395,39109280,1,"<p>There is no <code>string</code> data type in C programming language. Strings in C are represented as <code>array of characters</code>. </p>

<p>In C, <code>char</code> is a data type to represent a character. So, all you need to do is declare a <code>array of char data type</code> to represent a string in C. Each element in that array will hold a character of your string. </p>

<p>Also, operators in C like <code>==, !=, +=, +</code> are defined for <code>build-in data types</code> in C and since, there is no operator overloading in C, you can't use these operators with your C-String as C-Strings are not build-in data type in C programming language. </p>

<p><strong>Note: C-Strings are actually Null-terminated array of char data types. That means, last character in any C-String in C will be used to store a Null Character <code>('\0')</code> which marks the end of the string.</strong></p>

<p>The Header file <code>&lt;string.h&gt;</code> has predefined functions that you can use to operate on C-String(Null-terminated array of char data type). You can read more about it over <a href=""https://www.cs.cf.ac.uk/Dave/C/node19.html"" rel=""nofollow"">here</a>.</p>

<p>So, your program should look like:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define CSTR_MAX_LEN 100
int main()
{
    char uname[CSTR_MAX_LEN+1];   //An extra position to store Null Character if 100 characters are to be stored in it.
    char passwd[CSTR_MAX_LEN+1];

    printf(""Enter your username: "");
    scanf(""%s"", uname); 


    printf(""Enter your password: "");
    scanf(""%s"", passwd);

    // Use strcmp to compare values of two strings.
    // If strcmp returns zero, the strings are identical
    if ((strcmp(uname, ""waw"") == 0) &amp;&amp; (strcmp(passwd, ""wow"") == 0)){
         printf(""You have logged in\n"");
    } else{
         printf(""Failed, please try again\n"");
    }
    return 0;
 }
</code></pre>

<p>Remember, the correct format specifier to handle C-Strings are <code>%s</code> in C programming language. So, i have to change your <code>scanf()</code> function call. Also, i have used <code>strcmp()</code> function which is declared in header file <code>&lt;string.h&gt;</code> (i have included this header file in the above program). It returns numeric zero if strings match. You can read more about it above <a href=""http://www.cplusplus.com/reference/cstring/strcmp/"" rel=""nofollow"">here</a>. Also, have a look at <code>strncmp()</code> which is safer version of <code>strcmp()</code>. Also, remember that it can lead to <code>undefined behavior</code> if you try to access any array out of it's bound. So, it would be good idea to include checking in your program. As, someone included in their answer you can change my <code>scanf()</code> function call to:</p>

<pre><code>scanf(""%100s"", uname);
</code></pre>

<p>It avoids to read more than 100 characters in array <code>uname</code> as it is allocated only to store 100 characters(excluding the Null character).</p>
",2
39121986,39109280,1,"<p>This is how you can do it with <a href=""https://github.com/spitstec/milkstrings"" rel=""nofollow"">milkstrings</a></p>

<pre><code>tXt ask(tXt prmp) {
  printf(""%s ?"",prmp) ;
  return(txtFromFile(stdin)) ; }



void main(void) {
  tXt user = ask(""user"") ;
  if ( strcmp(txtConcat(user,""/"",ask(""password""),NULL),""waw/wow"") == 0)
    printf(""You have logged in\n""); 
  else
    printf(""Failed, please try again\n"");
}
</code></pre>
",0
39337378,39337355,3,"<p>Take a look to <a href=""https://stackoverflow.com/questions/5431941/why-is-while-feof-file-always-wrong"">Why is ¡°while ( !feof (file) )¡± always wrong?</a></p>

<p><code>fgets</code> is enough:</p>

<pre><code>while (fgets(temp, 300, input) != NULL) {
    printf(""%s \n"", temp);
}
</code></pre>

<p>Also, don't use magic numbers like <code>300</code>, change to</p>

<pre><code>while (fgets(temp, sizeof temp, input) != NULL) {
    printf(""%s \n"", temp);
}
</code></pre>

<blockquote>
  <p>it starts printing out the lines starting in the middle</p>
</blockquote>

<p>Notice that <code>fgets</code> includes the trailing newline <code>'\n'</code> and you don't need to include it in the <code>printf</code>, do you mean this by ""in the middle""?</p>
",4
37110570,37105074,2,"<p>Your code has a <em>logical</em> error which makes it broken - very easy to fix.</p>

<ul>
<li>Your for loop has <em>empty body</em> - that's why it only prints the first character. <em>Semicolon</em> deleted.</li>
</ul>

<p>There is also a style issue in checking the value of the counter:</p>

<ul>
<li>Although <em>checking</em> <code>i</code> against <em>not</em> being <code>100</code> won't make your code fail if everything else is OK, it's more common and conforming to your task specification to check its value for being <em>less than</em> <code>100</code>, or whichever constant you want.</li>
</ul>

<p>Although this may not be the most elegant way of completing such a task, it's a rework of your read-by-character method code:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
 FILE *wse;
 char a[1000];
 int i;

  if((wse=fopen(""3.txt"",""r"")) == NULL)//always check for file errors!
      return 1;

  for( i=0 ; i&lt;100 ; i++ )
  {
      if(fscanf(wse,""%c"",&amp;a[i]) != 1) //check against end of file!
          break;
      printf(""%c"",a[i]);
  }
  fclose(wse);
 return 0;
}
</code></pre>
",1
37110864,37105074,1,"<p>Please find the corrected code :</p>

<pre><code>FILE *wse;
char a[1000];
int i=0;

wse=fopen(""21e.txt"",""r"");

while(fscanf(wse,""%c"",&amp;a[i]) == 1)
{
    printf(""%c"",a[i]);
    i++;
}
</code></pre>

<p>Firstly, I corrected the code by removing your semicolon after the for loop. And secondly, replaced for with while loop so that it reads till end of file. It is because if the loop crosses EOF(End Of File), it might crash.</p>
",0
37110913,37105074,1,"<p>Step back a minute and learn the alternatives you have for input in C. You have <em>character oriented</em> input functions (<code>getchar()</code>, <code>fgetc()</code>, etc..) which will read a file one-character-at-a-time. You then have <em>line-oriented</em> input functions (e.g. <code>fgets</code> and <code>getline</code>) which will read lines of input at a time, and finally you have <em>block-oriented</em> input functions such as <code>fread</code> and <code>read</code> that you can use to read the entire file into a single block of memory. (there are some other tools for copying and memory access such as <code>sendfile</code> and <code>mmamp</code> that can also be utilized, but probably not intended here. The <code>scanf</code> family of functions, while they do have there uses, are not intended to read differing values over multiple lines.</p>

<p>Your basic approach should either be <em>character-oriented</em> input or <em>line-oriented</em> input to read a file into an array. The easier or the two would probably be <em>line-oriented</em> input where you would read an entire line and then <em>tokenize</em> the line into separate words with <code>strtok</code> (or by using a start and end pointer to walk down each line after it is read separating words).</p>

<p>Take a stab an your chosen approach and post back when you get stuck. We are happy to help.</p>

<p>A short example of using <code>fgets</code> to read each line following by <code>strtok</code> to separate each line into words could be something similar to the following. <strong>note</strong>: the program will read from the filename given on the command line (or from <code>stdin</code> by default if no name is given)</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

enum {MAXC = 1000};

int main (int argc, char **argv) {

    char buf[MAXC] = """";
    char *delims = "" \t\n.,:;"";  /* word separators for strtok */
    FILE *fp = argc &gt; 1 ? fopen (argv[1], ""r"") : stdin;

    if (!fp) {  /* always validate file is open for reading */
        fprintf (stderr, ""error: file open failed '%s'.\n"", argv[1]);
        return 1;
    }

    while (fgets (buf, MAXC, stdin)) {  /* read each line into buf */
        char *p = buf;
        printf (""\n line:  %s\n tokens:\n"", buf);
        /* tokenize buf into words with strtok */
        for (p = strtok (buf, delims); p; p = strtok (NULL, delims))
            printf (""   %s\n"", p);
    }
    if (fp != stdin) fclose (fp);  /* close if not reading stdin */

    return 0;
}
</code></pre>

<p><strong>Example Input</strong></p>

<pre><code>$ cat dat/captnjack.txt
This is a tale
Of Captain Jack Sparrow
A Pirate So Brave
On the Seven Seas.
</code></pre>

<p><strong>Example/Output</strong></p>

<pre><code>$ ./bin/strtok_fgets_file &lt;dat/captnjack.txt

 line:  This is a tale

 tokens:
   This
   is
   a
   tale

 line:  Of Captain Jack Sparrow

 tokens:
   Of
   Captain
   Jack
   Sparrow

 line:  A Pirate So Brave

 tokens:
   A
   Pirate
   So
   Brave

 line:  On the Seven Seas.

 tokens:
   On
   the
   Seven
   Seas
</code></pre>
",0
37240577,37240510,0,"<p>The <code>%s</code> format instructs <code>scanf</code> to read a single word.  White space acts as a word separator, hence only <code>Miami</code> gets parsed into <code>m.title</code> and <code>Vice</code> stays in the input stream.  Subsequent calls to <code>scanf</code> with a <code>%d</code> format fail to parse an integer from the stream and return <code>0</code>, leaving <code>m.year</code>and <code>m.date</code> uninitialized.  You therefore invoke undefined behavior when printing their values with the last call to <code>printf</code>.</p>

<p>You can correct the problem with a different format: <code>%[^\n]</code>.  Furthermore, you should prevent <code>scanf</code> from writing beyond the end of <code>m.title</code> with a width specifier: <code>%39[^\n]</code>.  An additional <code></code> before the format will skip white space if any is present before the movie title. An additional <code>%*c</code> would read the <code>\n</code> but is not required since the subsequent <code>scanf(""%d"",...)</code> will skip leading white space including the <code>\n</code> left pending in the input stream.</p>

<p>Here is a modified version of your program:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct movie {
    char title[40];
    int rate;
    int year;
};

int main(void) {
    struct movie m;

    puts(""What was the title of the movie you saw?"");
    if (scanf("" %39[^\n]"", m.title) != 1)
        return 1;
    puts(""What was the release year?"");
    if (scanf(""%d"", &amp;m.year) != 1)
        return 1;
    puts(""How would you rate the movie? (1-10)"");
    if (scanf(""%d"", &amp;m.rate) != 1)
        return 1;

    printf(""You saw the movie %s which was released in %d and you rated it a %d\n"",
           m.title, m.year, m.rate);

    return 0;
}
</code></pre>
",5
37240902,37240510,1,"<p>Try to use <code>fgets()</code> whenever reading strings as inputs. Anyways here is the code to which I modified a bit. Feel free to modify the code to your own needs.</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;

struct movie {
    char title[40];
    int rate;
    int year;
};

int main(){

   struct movie m;
   char *newline_char=NULL;

   puts(""What was the title of the movie you saw?"");
   fgets(m.title,40,stdin);

   //The below two lines of code are used to remove the '\n'
   //character from the input since fgets() also stores the '\n'
   //character. Replace the '\n' char with '\0' character.
   if((newline_char=strchr(m.title,'\n')) != NULL){
    *newline_char = '\0';
   }

   puts(""What was the relase year?"");
   fscanf(stdin, ""%d"", &amp;m.year);
   puts(""How would you rate the movie? (1-10)"");
   fscanf(stdin, ""%d"", &amp;m.rate);

   printf(""You saw the movie %s which was released %d and you rated it a %d"", m.title, m.year, m.rate);
   return 0;
}
</code></pre>

<p>As chux recommends, You can also use only <code>fgets()</code> and avoid <code>fscanf()</code> as shown below in the code,</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;

struct movie {
    char title[40];
    int rate;
    int year;
};

int main(){

    struct movie m;
    char *newline_char=NULL;
    char input[256];

    puts(""What was the title of the movie you saw?"");
    fgets(m.title,40,stdin);

    if((newline_char=strchr(m.title,'\n')) != NULL){
       *newline_char = '\0';
    }

    puts(""What was the relase year?"");
    fgets(input,256,stdin);
    sscanf(input,""%d"",&amp;m.year);
    puts(""How would you rate the movie? (1-10)"");
    fgets(input,256,stdin);
    sscanf(input,""%d"",&amp;m.rate);

    printf(""You saw the movie %s which was released %d and you rated it a %d"", m.title, m.year, m.rate);
    return 0;
}
</code></pre>
",1
40998510,40998251,1,"<p>For simple cases such as a function which simply returns an int, first style is much clearer and straightforward.</p>

<p>The second style is preferred in certain cases, for example, if you want to get multiple values returned from the function. As per the C standard a function can return only one value, therefore to get a second value back, you can pass a pointer to the function, which the function can update. Following is a hypothetical example to illustrate this:</p>

<pre><code>char *getline(FILE *f, int *size);
</code></pre>

<p>Consider a function <code>getline</code> which returns a string representing a line from the file, and since it is reading a line, you must want to know the length of the line as well, and to get that, you pass a pointer to an int to the function, which it will update after reading the line. This is good from performance point of view as well, because the function <code>getline</code>, in this case is doing the hardwork of scanning the characters from the file, so it might as well give us back the size of the line. Otherwise, after getting the string back, you would have to call <code>strlen()</code> yourself, which would repeat the same task. This small trick can help save many CPU instructions in performance critical code.</p>
",0
40998378,40998251,5,"<p>The first style is perfect for small types like <code>int</code>, <code>double</code>, etc.</p>

<p>The second makes sense for return values bigger than <code>int</code>, like <code>structs</code>.</p>

<p>This has the following advantages:</p>

<ul>
<li>The result struct can live either on the stack or on the heap, at the caller's discretion.</li>
<li>There are no ownership problems, as it is clear that the caller is responsible for allocating and freeing the result struct.</li>
<li>The structure could even be longer than what is needed, or be embedded in a larger struct.</li>
</ul>
",0
40998403,40998251,3,"<p>This is mostly a style issue and therefore quite a bit subjective. You'd use either form on case-to-case basis.</p>

<p>However, the form <code>void function (int *result)</code> has the advantage that you could reserve the return value for an error code. It is custom practice to write libraries so that every function in the API returns the same kind of error type. </p>

<p>Reserving the return value for error codes also means that if the caller is not interested in the function result, they can ignore it by typing <code>(void) function(x);</code>.</p>
",0
40571857,40571772,3,"<p>Valgrind is pointing you to the location of a malloc that is never freed. Before you terminate your program, you will need to iterate through the list an free all its elements.</p>
",0
40954875,40954829,5,"<p>There is nothing in your program to stop the infinite recursion.</p>

<pre><code>You execute a.out.  
  a.out executes a.out  
    a.out executes a.out  
      a.out executes a.out  
        a.out executes a.out  
</code></pre>

<p>and so on.</p>

<p>At some point, the system runs of of resources and does not execute the next <code>system</code> call and the programs exit in the reverse order. It appears that your computer reached the limit by the time it ran the program 563 times.</p>
",4
40955393,40954829,31,"<p>I'll tackle the second program first, since that's easiest to explain. Try this code instead which will print out the recursion depth as it goes.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main(int argc, char** argv){
  int depth = argc &gt; 1 ? atoi(argv[1]) : 0;
  printf(""%d\n"", depth);
  char cmd[128];
  sprintf(cmd, ""%s %d"", ""./a.out"", depth+1);
  system(cmd);
  system(cmd);
}
</code></pre>

<p>It will grow up until your limit (in my case 538), then start trashing up and down the recursion tree. </p>

<pre><code>530 531 532 533 534 535 536 537 538 538 537 538 538 536 537
</code></pre>

<p>Eventually this process would finish, but it will take a very long time!</p>

<p>As for the first program. I believe you are just running into your user process limit.</p>

<p>You can find your process limit by running</p>

<pre><code>ulimit -u
</code></pre>

<p>In my case the limit is 709. Count my other processes running with</p>

<pre><code>ps aux | grep user | wc -l
</code></pre>

<p>That gives me 171. 171 + 538 (my depth at which the program died) gives a solid answer for you :)</p>

<p><a href=""https://superuser.com/questions/559709/how-to-change-the-maximum-number-of-fork-process-by-user-in-linux"">https://superuser.com/questions/559709/how-to-change-the-maximum-number-of-fork-process-by-user-in-linux</a></p>
",1
40958930,40954829,3,"<p>To see what happens under the hood use one of the following programs:</p>

<ul>
<li>strace (Linux)</li>
<li>ktruss (Solaris)</li>
<li>ktrace (BSD)</li>
<li>Process Monitor (Windows)</li>
</ul>

<p>These programs list all the system calls made by the process, including any error codes.</p>

<p>Read their documentation, since that will help you more in the long run than me giving a single use case here.</p>
",0
35214354,35214279,1,"<pre><code>newnode -&gt; item.string = (char *)newnode + sizeof(log_t);
</code></pre>

<p>The right side will take the pointer <code>newnode</code>, cast it to a character pointer then add the size of an object to it.</p>

<p>This gives a pointer <code>n</code> bytes beyond <code>newnode</code>, where <code>n</code> is the size of the <code>log_t</code> object.</p>

<p>It then places this pointer value into the <code>string</code> member of the <code>item</code> member of the object pointed to by <code>newnode</code>.</p>

<p>Without seeing the actual structures in use, it's a little hard to tell <em>why</em> this is being done but my best guess would be that it's to provide an efficient self-referential pointer. </p>

<p>In other words, the pointer within <code>newnode</code> will point to an actual part of the <code>newnode</code> itself, or part of a larger memory block that was allocated which contains a <code>newnode</code> object at the start of it. And, since you state that <code>newnode</code> is of the type <code>log_t</code>, it must be the latter case (a type cannot contain a copy of itself - it can contain a <em>pointer</em> to the type itself but not a <em>actual</em> copy).</p>

<hr>

<p>An example of where this may come in handy is an object allocation where small sizes are satisfied completely by the object itself but larger ones are handled differently, such as with an <code>int</code>-to-<code>string</code> map entry:</p>

<pre><code>typedef struct {
    int  id;
    char *string;
} hdr_t;

typedef struct {
    hdr_t hdr;
    char  smallBuff[31];
} entry_t;
</code></pre>

<p>In the case where you want to populate an <code>entry_t</code> variable with a 500-character string, you would allocate the string separately then just set up <code>string</code> to point to it.</p>

<p>However, for a string of thirty characters or less, you could just create it in <code>smallBuff</code> then set <code>string</code> to point to that instead (no separate memory needed). That would be done with:</p>

<pre><code>entry_t *entry = malloc (sizeof (*entry)); // should check for NULL.
entry-&gt;hdr.id = 7;
entry-&gt;hdr.string = (char*)entry + sizeof (hdr_t);
strcpy (entry-&gt;hdr.string, ""small string"");
</code></pre>

<p>The third line in that sample above is <em>very</em> similar to what you have in your code.</p>

<hr>

<p>Similarly (and probably more apropos to your case), you can allocate more memory than you need and use it:</p>

<pre><code>typedef struct {
    int  id;
    char *string;
} entry_t;

char *str = ""small string"";
entry_t *entry = malloc (sizeof (*entry) + strlen (str) + 1); // with extra bytes.
entry-&gt;id = 7;
entry-&gt;string = (char*)entry + sizeof (entry_t);
strcpy (entry-&gt;string, str);
</code></pre>
",4
35214365,35214279,0,"<p>It's doing pointer arithmetic.  In C, when you add a value to a pointer, it moves the pointer by that value * the size of the type pointed to by the pointer.</p>

<p>What this is doing is casting newnode to a char*, so that the pointer arithmetic is done assuming that newnode is a char*, thus the size of the data it points to is 1.  It them adds the sizeof(log_t) which is the size of type log_t.  Based on your description of log_t, it looks like it contains a single char*, so its size would be the size of a pointer, either 4 or 8 bytes, depending on the architecture.</p>

<p>So, this will set <code>newnode.item.string</code> to be <code>sizeof(log_t)</code> bytes after address that newnode contains.</p>
",0
35214435,35214279,1,"<p>I'm assuming the memory for newnode was allocated with additional space for the string.</p>

<p>The result is the same, but I'd personally write that as <code>newnode-&gt;item.string = (char*) &amp;newnode[1];</code></p>

<p>That is, the storage space for string is immediately after the log_t object.  This is sometimes done when a single chunk of memory has been allocated in advance, and objects and their members all point to memory in this chunk.  It's been done in the past to cut down on the overhead of small memory allocations.</p>

<p>If log_t is 32 bytes, and the string is 16 bytes long (including the nul terminator!), you could malloc 48 bytes, point the string member to the 32nd byte of this memory allocation and copy the string there.</p>
",11
39010373,39010302,5,"<p>The setup of arguments is not actually within the purview of the C standard, it simply dictates the allowable forms of <code>main</code> that you can use. There are two canonical forms of this (assuming a hosted implementation), one being the <code>argc/argv</code> option, the other being the <code>void</code> option (although note that an implementation is free to provide others).</p>

<p>Typically, there is code that runs <em>before</em> <code>main</code> is called, such as from startup code in an object file like <code>crt0.o</code>.</p>

<p>However, as stated, the standard doesn't dictate anything that happens at that stage, it's the responsibility of the ""environment"" to set up things correctly so that <code>main</code> can be called.</p>

<p>In terms of doing what you request, I suspect the easiest solution would be to provide a <code>main</code> taking the canonical form and simply call a <code>myMain</code> with the first character of each argument, though you would probably need to intelligently handle any number of arguments that may be given to <code>main</code>.</p>

<p>An example follows which can handle between one and three arguments:</p>

<pre><code>#include &lt;stdio.h&gt;

int myMain0(void) {
    printf (""myMain0\n"");
    return 0;
}

int myMain1(char p1) {
    printf (""myMain1 [%c]\n"", p1);
    return 0;
}

int myMain2(char p1, char p2) {
    printf (""myMain2 [%c] [%c]\n"", p1, p2);
    return 0;
}

int main(int argc, char *argv[]) {
    switch (argc) {
        case 1: return myMain0();
        case 2: return myMain1(argv[1][0]);
        case 3: return myMain2(argv[1][0], argv[2][0]);
    }
    printf (""Invalid argument count of %d\n"", argc - 1);
    return 1;
}
</code></pre>
",2
39010538,39010302,0,"<p>The operating system is the one that passes the number of arguments and the arguments themselves from the command line to the C program.</p>

<p>The function <code>main</code> is not picky about its arguments. You can get no argument at all, you can get only <code>argc</code>, and you can get both <code>argc</code> and <code>argv</code>.</p>

<p>You can even get 3 or 4 arguments with whatever types you want, but they will contain garbage. The operating system will always pass the number of arguments and their names as an int and an array of pointers to strings.</p>
",3
39010713,39010302,0,"<p>Your <code>main()</code> declaration does not actually <em>define</em> what parameters you get. That is the responsibility of the program's environment: the operating system and the calling program, usually the command line processor.</p>

<p>The caller (typically a shell program) prepares parameters and passes them to appropriate operating system's routine for the program to be called. The OS routine prepares those data for a callee, typically on the stack, and makes a jump into your program's entry point, which then follows to the <code>main</code> function.</p>

<p>Your <code>main()</code> declaration just <em>declares</em> what your <code>main</code> <em>expects</em> on the stack, which indirectly defines <em>how you can use</em> those data, but not what they are. That's also why you can declare <code>main</code> without parameters as <code>main(void)</code> ¨C that simply means 'whatever is passed to me, I'll ignore it anyway'.</p>
",0
39010740,39010302,0,"<p>There are standards (like  ANSI C, C89, etc.), that provide main rules and set set of restrictions, and there are agreements, that do not violate the standards and provide you some possibility.</p>

<p>Fist, I have one more example for you:</p>

<pre class=""lang-cpp prettyprint-override""><code>#include &lt;stdio.h&gt;

int main(int argc, char * argv[], char * envs[])
{
    int i = 1;
    while (envs[i] != NULL)
    { 
        printf(""%d : %s\n"", i, envs[i]);
        i++;
    }
    return 0;
}
</code></pre>

<p>Just try and see how this third argument of <code>main</code> can be useful.</p>

<p>Also, I want to explain my approach to command line arguments processing. I make <code>ParseCommandLine</code> (or <code>EvaluateParameters</code>) and call it at the beginning of <code>main</code>. That function analyze strings from command line and store all settings for further convenient usage. E.g. if I expect my program to be run as</p>

<pre><code>  prog.exe -i input_file_name -o output_file_name -e
</code></pre>

<p>I will do something like:</p>

<pre class=""lang-cpp prettyprint-override""><code>#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

#define FNAME_LEN 20

struct settings
{
    char inpFName[FNAME_LEN];
    char outFName[FNAME_LEN];
    bool isEncoded;
} globalSettings;

bool ParseCommandLine(int argc, char * argv[])
{
    int c;
    for (int c = 1; c &lt; argc; c += 2)
    {
        if (!strcmp(argv[c], ""-i"") &amp;&amp; c &lt; argc - 1)
        {
            strncpy(globalSettings.inpFName, argv[c + 1], FNAME_LEN - 1);
            continue;
        }
        if (!strcmp(argv[c], ""-o"") &amp;&amp; c &lt; argc - 1)
        {
            strncpy(globalSettings.outFName, argv[c + 1], FNAME_LEN - 1);
            continue;
        }
        if (!strcmp(argv[c], ""-e""))
        {
            globalSettings.isEncoded = true;
            c--;
            continue;
        }
    }
    // rules to check mandatory values
    if (strlen(globalSettings.inpFName) == 0 || strlen(globalSettings.outFName) == 0)
    {
        return false;
    }
    return true;
}

int main(int argc, char * argv[])
{
    if (ParseCommandLine(argc, argv))
    {
        // do something
    }
    else
    {
        // explain how to run program
    }
    return 0;
}
</code></pre>
",0
37243353,37243332,4,"<p>No, chaining of logical OR operators (<code>||</code>) is not possible. You need to check each one of them individually. Change</p>

<pre><code> if(n == 1 || -1 || 2 || -2)
</code></pre>

<p>to</p>

<pre><code>if(n == 1 || n == -1 || n ==  2 || n == -2)
</code></pre>

<p>Otherwise, due to left-to-right evaluation rule (associativity), what you're end up getting is</p>

<pre><code>if ( (n == 1) || -1 || 2 || -2)
</code></pre>

<p>which is same as either</p>

<pre><code>if( 0 || -1 || 2 || -2)
</code></pre>

<p>or</p>

<pre><code>if( 1 || -1 || 2 || -2)
</code></pre>

<p>both of which yields <code>1</code> as result as the other operands of <code>||</code> are non-zero (TRUE).</p>
",0
39646828,39646216,0,"<p><code>v2</code> must be double pointer <code>int ** v2</code> because after <code>realloc</code> the new value of the pointer must be returned to the calling function (where it is <code>free</code>-d).</p>
",1
39648074,39646216,2,"<p>The problem is that <code>v2</code> in function <code>copiaValorsemrepetir</code> is not the same variable as <code>v2</code> in <code>main</code>. There are two variables, which I'm going to call <code>v2func</code> and <code>v2main</code>. <code>v2func</code> is the copy used in function <code>copiaValorsemrepetir</code>. <code>v2main</code> is the copy that is in <code>main</code>.</p>

<p>When you call <code>realloc</code> to change <code>v2func</code>, <code>realloc</code> frees the memory that <code>v2main</code> points to, and provides a new pointer that is stored in <code>v2func</code>. When <code>copiaValorsemrepetir</code> returns, the memory that <code>v2func</code> points to is lost (resulting in a memory leak). </p>

<p>The pointer in <code>main</code> still has its original value, which points to nothing. Therefore, the call to <code>imprimeVetor</code> is using a bad pointer, which could result in a segfault. And the line <code>free(v2)</code> attempts to free memory that has already been freed. That's why the code generates a <em>""double free""</em> error message.</p>

<hr>

<p>To fix the problem, change the function call in <code>main</code> to update <code>v2</code></p>

<pre><code>v2 = copiaValorsemrepetir(v1,tam1,v2,tam2_ptr);
</code></pre>

<hr>

<p>And change the function so that it returns the new pointer to <code>main</code></p>

<pre><code>int *copiaValorsemrepetir(int *v1, int tam1, int *v2, int *tam2_ptr)
{
    ...

    *tam2_ptr = tam;
    return v2;
}
</code></pre>
",0
39246402,39244757,5,"<p>Yes it is possible, since C99. Your guess was very close; but it is required to provide a braced initializer even if you plan to assign another value later:</p>

<pre><code>struct S test = { &amp;(int){0}, &amp;(float){0} };
</code></pre>

<p>This feature is called <a href=""http://en.cppreference.com/w/c/language/compound_literal"" rel=""noreferrer"">compound literal</a>. A compound literal is an lvalue.</p>

<p>Note that your <code>testfunc</code> contains an error though; since <code>a</code> has type <code>void *</code>, you cannot write <code>*(test.a)</code>.  You could either change <code>S</code> to have <code>int *a; float *b;</code>, or you'll have to cast at the point of writing, e.g. <code>*(int *)test.a = 5;</code>.</p>
",7
39381281,39381237,2,"<p><strong>malloc():</strong></p>

<p><code>malloc()</code> takes one arguement: the amount of bytes to be allocated. The allocated bytes are <strong>uninitialized.</strong> Hence, their values could be anything from 0-255, or any combination of those numbers. <strong>Don't count on anything!</strong></p>

<p><em>Code Sample:</em></p>

<pre><code>int *mem = malloc(5 * sizeof(int));
</code></pre>

<p><hr>
<strong>calloc():</strong></p>

<p><code>calloc()</code> takes two arguements: the amount of elements to allocate memory for and the amount of memory that needs allocated for each element. It <strong>initializes</strong> each byte to zero.</p>

<p><em>Code Sample:</em></p>

<pre><code>int *mem = calloc(5, sizeof(int));
</code></pre>

<p>From <em>The C programming Language</em> ~ Brian W. Kernighan and Dennis M. Ritchie:</p>

<blockquote>
  <p>void *calloc(size_t nobj, size_t size)<br>
  calloc returns a pointer to space for an array of nobj objects,<br>
  each of size size, or NULL if the request cannot be satisfied.<br>
  <strong>The space is initialized to zero bytes.</strong></p>
</blockquote>

<p><sub>[Emphasis mine]</sub></p>

<hr>

<p><strong>Alternatively, you can initialize memory with <code>memset()</code></strong></p>

<pre><code>#include &lt;string.h&gt; // for memset()

//allocate memory
int *mem = malloc(5 * sizeof(int));

//initialize memory to zeros
memset(mem, 0, 5 * sizeof(int));
</code></pre>
",9
39381334,39381237,0,"<p>You can use memset if you want to avoid using calloc for some reason.  you can do it like this:</p>

<pre><code>memset (c, 0, 5 * sizeof(int));
</code></pre>

<p>Don't forget to check the return value from malloc.</p>
",1
39381355,39381237,2,"<p>You can use <code>calloc()</code>, it's safe or else why would it be implemented in the standard library and how? It will be presumably more efficient than <code>malloc()</code> + <code>memset()</code> for large allocations.</p>
",1
39616957,39616432,0,"<p>Comparing floating point values is not as easy as it might seem, have a look at <a href=""https://stackoverflow.com/questions/17333/most-effective-way-for-float-and-double-comparison"">Most effective way for float and double comparison</a>.</p>

<p>It all boils down to the fact, that floating point numbers are not exact (well 
most are not). Usually you compare 2 floats by allowing a small error window (epsilon):</p>

<pre><code>if( fabs(a - 2.3f) &lt; epsion) { ... }
</code></pre>

<p>where epsilon is small enough for your calculation, but not too small (bigger than <a href=""https://en.wikipedia.org/wiki/Machine_epsilon"" rel=""nofollow noreferrer"">Machine epsilon</a>).</p>
",0
37069726,37068423,0,"<p>Rewriting your filename might cause a problem if the name of the file is smaller than the new name. I.e. the user selected <code>C:\a.txt</code> and you want to rename it to <code>C:\tmp.txt</code>. This would cause an error since the array bound would be exceeded. Hence you have to create a new array. The code below works, but is not really nice to look at. Since you are not familiar with the string functions, I thought this might be the best way to go. But I highly recommend to look at these provided functions in order to reduce the amount of written code and increase the readability.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char *argv[]) {
    char* p = ""C:\\a.txt"";
    int x; // this will hold the position of the last backslash
    int i;
    for(i = 0; p[i] != '\0'; i++){
        if(p[i] == '\\') {
            x = i;
        }
    }
    char pp[x+9];
    pp[x+8] = '\0';
    for(i = 0; i &lt;= x; i++){
        pp[i] = p[i]; 
    }
    pp[i+0] = 't';
    pp[i+1] = 'm';
    pp[i+2] = 'p';
    pp[i+3] = '.';
    pp[i+4] = 't';
    pp[i+5] = 'x';
    pp[i+6] = 't';

    printf(""%s -&gt; %s\n"", p, pp);
    return (0);
}
</code></pre>

<p><strong>Edit</strong></p>

<p>Instead of doing every operation by hand, one can use the built-in <a href=""http://www.tutorialspoint.com/ansi_c/c_function_references.htm"" rel=""nofollow"">library functions</a>. Using these will make the code much shorter and easier to understand.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main(int argc, char *argv[]) {
    char* p = ""C:\\a.txt""; // the path
    char* t = ""tmp.txt""; // the new name of the file
    char* e = strchr(p, '\\'); // returns a pointer to the last occurence of the backslash within the string p
    int i = (int)(e-p); // i contains the index position of the last occurence of the backslash
    char n[i+1+strlen(t)]; // create a string with max size i + 1 + length of t
    strncpy(n, p, i+1);// copy the first (i+1) characters of p to n 
    strncpy(&amp;n[i+1], t, strlen(t)+1); // copy the whole string t and \0 to the end of the new path   
    printf(""%s -&gt; %s\n"", p, n);
    return (0);
}
</code></pre>
",2
37070844,37068423,1,"<p>To ""delete"" part of a C string, all you need to do is set the character after the last one you want to keep to a <code>0</code>. (I say ""delete"" (quoted) here because you don't actually remove anything from memory; the 'string' gets shorter but the amount of memory allocated for it stays the same, and all content beyond the <code>0</code> is still available.)</p>

<p>There is a standard <code>string.h</code> function to locate the last occurrence of a certain character: <a href=""http://en.cppreference.com/w/c/string/byte/strrchr"" rel=""nofollow""><code>strrchr</code></a>. This returns a</p>

<blockquote>
  <p>[p]ointer to the found character in <code>str</code>, or null pointer if no such character is found</p>
</blockquote>

<p>So to locate the last backslash and to lop off what's behind it, you can use</p>

<pre><code>char *ptr;
ptr = strrchr (address1, '\\');
if (ptr) ptr[1] = 0;
</code></pre>

<p>Note the explicit test to see if <code>ptr</code> actually found a backslash.</p>

<p>Now you don't actually <em>want</em> to discard everything after that backslash, you want to copy something new in it. For that, you don't need to first make it shorter and then (presumably) use <code>strcat</code>, you can use <code>strcpy</code> right away:</p>

<pre><code>ptr = strrchr (address1, '\\');
if (ptr)
    strcpy (ptr+1, ""tmp.txt"");
else
    strcpy (address1, ""tmp.txt"");
</code></pre>

<p>which, personally, I usually write as</p>

<pre><code>ptr = strrchr (address1, '\\');
if (ptr) ptr++; else ptr = address1;
strcpy (ptr, ""tmp.txt"");
</code></pre>

<p>Note that both use <code>ptr+1</code> because <code>ptr</code> itself points ""at"" the backslash; and you want to keep it.</p>

<p>There is an inherent danger in using string concatenations such as this: if the part after the last backslash is shorter than the newly inserted string, you can overwrite data after the string. This depends <em>entirely</em> on how you created <code>address1</code> in the first place. A <strong>very dirty fix</strong> is to explicitly test if the <em>current</em> contents of <code>address1</code> has enough space left:</p>

<pre><code>char *to_add = ""tmp.txt"";
ptr = strrchr (address1, '\\');
if (ptr &amp;&amp; strlen(ptr+1) &lt;= strlen(to_add) )
    strcpy (ptr+1, to_add);
else
    printf (""too long, ignored\n"");
</code></pre>

<p>(I only add this for completeness; you probably should not use this in production code.)</p>

<p>The reason <code>strcpy</code> (and <code>strcat</code>, and related string functions) cannot know if there is 'enough' space left is because a simple C string does not store the available maximum length anywhere.</p>
",0
35281732,35281595,1,"<p><strong>Hint 1</strong> - Subtraction can be accomplished by adding negative numbers.</p>

<p><strong>Hint 2</strong> - Negation can be done with bitwise operators: <code>-n == ~n+1</code>.</p>

<p><strong>Hint 3</strong> - Right shifting a non-negative number by <em>n</em> is equivalent to dividing by 2<sup><i>n</i></sup>: <code>n&gt;&gt;1 == n/2</code>, <code>n&gt;&gt;2 == n/4</code>, etc.</p>
",6
35276750,35276670,1,"<p>Unless you are actually writing a software floating-point emulator (in which case you need more help than we can give you), you should let the compiler handle this:</p>

<pre><code>#include &lt;stdint.h&gt;
#include &lt;assert.h&gt;

static_assert(sizeof(float) == sizeof(uint32_t));

uint32_t multiply_by_4_as_float(uint32_t n)
{
    union {
        uint32_t u;
        float f;
    } conv;

    conv.u = n;
    conv.f *= 4;
    return conv.u;
}
</code></pre>

<p>(This use of unions has unspecified, but not undefined, behavior in C1999 with technical corrigienda applied, and in C2011.  In C1989 it was undefined, and in C++ it may still be undefined.)</p>

<p>(If you're asking this question because you need to do a little bit of floating-point math in a program that <em>can't</em> use the hardware floating point unit for some concrete reason, check your compiler's documentation - there may be an option you can set that makes it use its own software FP.  But keep in mind that software floating point is <em>orders of magnitude</em> slower than the hardware.)</p>
",5
41925688,41925608,0,"<p>Well if you know two's complement, then you know that for a 32 bit integer, 0x80000000 must be the largest negative value, because if you flip the bits and add one from 0x80000000, you get 0x7fffffff. add one and you get 0x80000000, the largest negative number possible with 32 bits. This has a 1 in the MSB, and there is no way to get larger than this, given that the initial number needs to save a bit for the sign. Your original code just fills the int with 1's and then shifts over 31 resulting in the same final value as *x = 1 &lt;&lt;31;</p>
",0
41926066,41925608,1,"<p>If your <code>int</code> is on 32 bits on your architecture, the largest negative <code>int</code> value is obviously 0x80000000.<br>
Let's look at your code and add parenthesis to show the precedence of operators (this is the key here):  </p>

<pre><code>*x = 1 &lt;&lt;31 | ~ 1&lt;&lt;31 = (1 &lt;&lt; 31) | ((~1) &lt;&lt; 31)
</code></pre>

<p>The evaluation of the expression <code>((~1) &lt;&lt; 31)</code> gives the result 0x00000000.<br>
So the final result is <code>1 &lt;&lt; 31 = 0x80000000</code>.</p>
",2
37113022,37112870,2,"<blockquote>
  <p>Why do I see some books using the pointers method while others use the normal definitions ?</p>
</blockquote>

<p>Neither of those is more ""normal"" than the other. A string in C is purely a contiguous (uninterrupted) series of <code>char</code> terminated with a <code>0</code> char. You can refer to that with a <code>char[]</code>, or you can refer to it with a <code>char *</code>, or a <code>const char *</code>, etc. They're all just ways of referring to the block of memory with the series of <code>char</code>s in it. Each is appropriate in different contexts, depending on how the code in question receives the string and what it's doing with it.</p>
",0
37114034,37112870,13,"<p>A short answer won't do your question justice.  You're asking about two of the most significant, but often misunderstood, aspects of C.</p>

<p>First of all, in C, by definition, a string is <em>an array of characters, terminated with a nul character, <code>'\0'</code>.</em></p>

<p>So if you say</p>

<pre><code>char string1[] = ""Hello"";
</code></pre>

<p>it's as if you had said</p>

<pre><code>char string1[] = {'H', 'e', 'l', 'l', 'o', '\0'};
</code></pre>

<p>When you use a string constant like <code>""Hello""</code> in your program, the compiler automatically constructs the array for you, as a convenience.</p>

<p>Next we have the character pointer type, <code>char *</code>.  You called this a ""string to a char array"", but it's really a <em>pointer to a single <code>char</code>.</em>  People often refer to <code>char *</code> as being C's ""string type"", and in a way it is, but it can be a misleading thing to say, because not every <code>char *</code> is a string, and more importantly C has very few mechanisms for automatically managing strings for you.  (What I mean is that, in C, you can't just sling strings around as if they were a basic data type, like you can in C++ or BASIC.  You typically have to worry about where they're stored, how they're allocated.)</p>

<p>But let's go back to the definition of a string.  If a string is an <em>array</em> of characters, then why would a <em>pointer</em> to characters be useful for manipulating strings at all?  And the answer is, pointers are always useful for manipulating arrays in C; pointers are so good at manipulating arrays that sometimes it seems as if they <em>are</em> arrays.  (But don't worry, they're not.)</p>

<p>I can't delve into a full treatise on the relationship between arrays and pointers in C here, but a couple of points must be made:</p>

<p>If you say something like</p>

<pre><code>char *string2 = ""world"";
</code></pre>

<p>what actually happens (what the compiler does for you automatically) is as if you had written</p>

<pre><code>static char __temporaryarray[] = ""world"";
char *string2 = __temporaryarray;
</code></pre>

<p>And, actually, since <code>string2</code> is a pointer to a character (that is, what it points at is characters, not whole arrays of characters), it's really:</p>

<pre><code>char *string2 = &amp;__temporaryarray[0];
</code></pre>

<p>(That is, the pointer actually points to the array's first element.)</p>

<p>So since a string is always an array, when you mentioned the string <code>""world""</code> in a context where you weren't using it to initialize an array. C went ahead and created the array for you, and then made the pointer point to it.  C does this whenever you have a string constant lying around in your program.  So you can later say</p>

<pre><code>string2 = ""sailor"";
</code></pre>

<p>and you can also say things like</p>

<pre><code>if(strcmp(string1, ""Goodbye"") == 0) { ... }
</code></pre>

<p>Just don't do</p>

<pre><code>char *string3;

strcpy(string3, ""Rutabaga"");        /* WRONG!! *//
</code></pre>

<p>That's very wrong, and won't work reliably at all, because nobody allocates any memory for <code>string3</code> to point to, for <code>strcpy</code> to copy the string into.</p>

<hr>

<p>So to answer your question, you will sometimes see strings created or manipulated as if they are arrays, because that's what they actually are.  But you will often see them manipulated using pointers (<code>char *</code>), because this can be extremely convenient, as long as you know what you are doing.</p>
",0
37204150,37143548,0,"<p>I finally got it!
Just put <code>#define _FILE_OFFSET_BITS 64</code> in the header of your code.</p>
",0
37160954,37160873,-1,"<p>For the first case, your return type is a <code>char</code> You are trying to pass a <code>const char</code> as the return.</p>

<p>For the second case, the problem is in <code>s2ptr=s2</code>.  <code>s2ptr</code> is a <code>char</code> and <code>s2</code> is a <code>const char</code>.</p>
",1
37161271,37160873,23,"<blockquote>
  <p>Doesn't const char *s means that ""s is a pointer which is pointing towards a constant char""</p>
</blockquote>

<p>Indeed it does. You get the warning because you are trying to convert this into a pointer pointing to a (non-constant) char. There is a rule in C saying that it is always ok to convert from pointer-to-type into pointer-to-const-type, <em>but not the other way around</em>.</p>

<p>It doesn't matter if your code tries to change the values or not. Just by using <code>char*</code> you tell the compiler that you want a pointer which is allowed to change values.</p>

<p>Most of the C standard library functions do not always make sense when it comes to ""const correctness"". There is for example no way to cleanly implement <code>strchr</code>. You will have to return <code>(char*)s</code> and cast away the <code>const</code>, which is very bad programming practice. This is the fault of the person who specified the <code>strchr</code> function: it is flawed by design.</p>
",7
37161356,37160873,5,"<blockquote>
  <p>For first warning: <em>return discards 'const' qualifiers from pointer target type</em></p>
</blockquote>

<p>C does not have an implicit conversion from <code>const-qualified</code> pointer types to non-const-qualified ones, so to overcome the warning you need to add it explicitly.</p>

<p>Replace <strong><code>return s;</code></strong> with <strong><code>return (char *)s;</code></strong></p>

<blockquote>
  <p>For second warning: <em>assignment discards 'const' qualifiers from pointer target type</em></p>
</blockquote>

<ul>
<li><strong>'s2ptr'</strong> is of type <strong><code>char *</code></strong> and <strong>'s2'</strong> is of type <strong><code>const char *</code></strong></li>
<li>You are not allowed to assign a <strong><code>const char*</code></strong> value to a <strong><code>char *</code></strong> pointer. </li>
</ul>

<p>And regarding how to fix this warning... It depends on what you are trying to do. Either you can make <code>char *s2ptr</code> as <code>const char * s2ptr</code> or remove the <code>const</code> from <code>s2</code>.</p>

<p>So if you wish to convert <code>char *s2ptr</code> to <code>const char *s2ptr</code>, do remember to explicitly cast <code>s2ptr</code> to <code>(char *)s2ptr</code> while returning it in the <em>my_strpbrk()</em> function.</p>
",2
37454621,37454371,3,"<p>In the last line, in the last part replace </p>

<pre><code>*((u2+ij+nx)+ *(u2+ij-nx))*0.5*diffusivity.cy;
</code></pre>

<p>with</p>

<pre><code>(*(u2+ij+nx)+ *(u2+ij-nx))*0.5*diffusivity.cy;
</code></pre>

<p>Explanation:</p>

<p><code>(u2+ij+nx)</code> - is a pointer as <code>u2</code> is a pointer</p>

<p><code>*(u2+ij-nx)</code> - is a double</p>

<p>You cannot add a double to a pointer value. It is prohibited in C. </p>

<p>I guess you wanted to take the sum of the two values and multiply it by <code>0.5*diffusivity.cy</code>, which is what is given in the suggested solution.</p>
",0
37073584,37073436,4,"<p>Aside from some obvious problems (see the comments...)</p>

<p>When you find a duplicate you generate a new number, but you don't restart the check for duplicates, so it won't compare it with previous values in the array.</p>
",3
37073717,37073436,0,"<p>You can use a boolean array and use direct hashing.
Let's say r is the first random number.
make <code>input[r]=1;</code>Now, when the next random number is generated you can simply check if it has been previously generated using </p>

<pre><code>if(!input[r])
{
...
}
</code></pre>

<p>Now each time the condition is false, decrement the loop counter by 1. </p>

<pre><code>  for (x = 0; x &lt; 20; x++)
  {
    int r=rand()%20+1;
    if(!arr[r])
      printf(""%d\n"",r);
    else
      x--;
    arr[r]=1;    
  }
</code></pre>
",0
45219757,45219462,3,"<p>Traditionally, variadic functions are written such that the type of each argument can be predicted by the contents of previous arguments.</p>

<p>You cannot reliably determine the type of an argument through trial and error.  The caller places the arguments on the stack and it is up to the function to know the offset and type of each argument on the stack.</p>

<p>If for example you were to have the possibility of two 32 bit integers or one 64 bit integer.. or one signed 64 bit integer vs one unsigned 64 bit integer, how would you know the difference?  The processor will happily treat an unsigned int as a signed int and compute the wrong result if you ask it to.. there will be no error telling you that you had the wrong type.</p>

<p>In your edited question, I now see what you are trying to accomplish.  This kind of thing is easy to do in higher level languages like python, where all the arguments are objects which can be introspected if necessary to determine their type.  C is not like that.  You are working with the data at a much lower level.. a 64 bit integer is literally 64 bits of memory, containing an integer value.  You have no metadata telling you the type.  Your code has to know what type of data it is dealing with and where it is located.  When arguments are passed on the stack, you have no way of knowing even know how many were passed or where one ends and the next starts, much less the type of each.  Your function has to know all that.  When you are dealing with normal (non-variadic) functions, this is something that the compiler takes care of for you, so you don't have to think about it much.  Contrast with python where arguments are in a high level list or dictionary which gives you a lot of information about what it contains.</p>
",0
45220131,45219462,2,"<p>What you're talking about is declaring a function such as this...</p>

<pre><code>void println(...);
</code></pre>

<p>since that is the only way a C compiler would be able to accept a function call with an arbitrary number of arguments of unknown type. But that won't compile as the <code>...</code> has to be preceded by a named argument.</p>

<p>That named argument is typically used to define the format of the following arguments because as far as your compiled code is concerned, it's all just a load of bytes in memory. </p>
",0
45219986,45219462,1,"<p>There is a fundamental difference between the languages you mentioned and <a href=""/questions/tagged/c"" class=""post-tag"" title=""show questions tagged &#39;c&#39;"" rel=""tag"">c</a>.</p>

<p>For example <a href=""/questions/tagged/python"" class=""post-tag"" title=""show questions tagged &#39;python&#39;"" rel=""tag"">python</a> uses a parser that will determine the type of each variable from it's input that is a text strings. So there is no problem, because you can attempt multiple conversions giving priority to the less likely and until you reach the text representation, because everything that can be printed can be represented as text, which in the end is the purpose of a <code>print()</code> function.</p>

<p>If <a href=""/questions/tagged/c"" class=""post-tag"" title=""show questions tagged &#39;c&#39;"" rel=""tag"">c</a> were to infer the types at compile time for example then this would be possible. But <a href=""/questions/tagged/c"" class=""post-tag"" title=""show questions tagged &#39;c&#39;"" rel=""tag"">c</a> doesn't have such a feature, types are expressed before compilation and can't be changed. In a variadic function it's impossible to tell what type each argument is, the function should have a method to determine this or all the arguments can be of the same type, for example text.</p>

<p>If all the arguments are of the same type, you can write a function that would accept the following syntax</p>

<pre><code>println(""example text and a "", ""10"", "" which is a number"");
</code></pre>

<p>but doing it like you can in <a href=""/questions/tagged/python"" class=""post-tag"" title=""show questions tagged &#39;python&#39;"" rel=""tag"">python</a> or <a href=""/questions/tagged/go"" class=""post-tag"" title=""show questions tagged &#39;go&#39;"" rel=""tag""><img src=""https://i.stack.imgur.com/sawHl.png"" height=""16"" width=""18"" alt="""" class=""sponsor-tag-img"">go</a>, is simple not possible at all, or at least <strong>not without a format string</strong> and variadic functions.</p>

<p>Also your attempt to try something and if it doesn't work try the next thing will not work because in <a href=""/questions/tagged/c"" class=""post-tag"" title=""show questions tagged &#39;c&#39;"" rel=""tag"">c</a> you can cast a variable from many types to other incompatible type without something special happening, so for example suppose that you pass <code>10</code> and <code>""nice""</code> like you did in your example, then trying to extract <code>""nice""</code> as an integer will work and you will end up printing <code>""nice""</code>'s address (<em>or probably not</em>) instead of the string <code>""nice""</code>.</p>

<p>I said probably not, because such thing in c is undefined behavior and the resulting behavior cannot really be predicted from the code alone.</p>
",0
45220659,45219462,-1,"<p>This is just not possible. Stop thinking about it and look for some other problem to solve :)</p>

<p>It is not just that there is no way to tell the type of an argument from the binary representation of the argument. You can't even tell <em>where to look for the argument</em> unless you know its type.</p>

<p>Consider this interesting bit of Undefined Behaviour (I put the format strings into named variables to avoid the C warning about mismatched format conversions):</p>

<pre><code>#include &lt;stdio.h&gt;
const char* good=""%d %f\n"";
const char* bad=""%f %d\n"";
int main(void) {
    int a = 42;
    double b = 375.0;
    printf(good, a, b);
    printf(bad, a, b);  /* Undefined behaviour; format mismatch */
return 0;
}
</code></pre>

<p>Output (on at least one popular compiler):</p>

<pre><code>42 375.000000
375.000000 42
</code></pre>

<p>(<a href=""http://ideone.com/1TIqMF"" rel=""nofollow noreferrer"">Live on ideeone</a>)</p>

<p>The second <code>printf</code> acts as though the arguments were in the reverse order, so they actually match the format conversions. How is that possible?</p>

<p>Undefined behaviour can result in anything, of course, so the observed behaviour is trivially possible. But there is an explanation:</p>

<p>On many architectures, the first few arguments to a function are passed in specific hardware registers rather than being pushed onto the stack. Integer arguments are passed in certain general purpose registers (in a specific order) while floating point arguments are passed in floating point registers.</p>

<p>So (in the second case) <code>printf</code> uses the <code>stdarg.h</code> facilities to get  argument 1 as type <code>double</code> and argument 2 as type <code>int</code>. As it happens, argument 1 is type <code>int</code> and argument 2 is type <code>double</code>, but the runtime doesn't know that, so when <code>va_arg(ap, double)</code> is called to get argument 1, <code>va_arg</code> looks for the argument in the first floating point register (since it will be the first floating point argument in the list). And when the next <code>va_arg(ap, int)</code> is called to get argument 2, it looks for that argument in the first general purpose register used for argument passing. </p>
",0
39649316,39649241,5,"<p>To expand upon the comment by Dunno:  the string <code>""1234""</code>in C is five bytes long. The fifth byte <code>s[4]</code> is a zero byte denoting string termination.</p>

<p>Your code copies that zero byte to <code>srev[0]</code>, so now you have a C string that terminates before it has even begun.</p>

<p>Use <code>i&lt;4</code> in your <code>for</code> loop (and adjust the arithmetic to <code>3-i</code> accordingly) so that you only swap the non-zero bytes. Then set <code>srev[4] = '\0';</code> explicitly to terminate the new string in the correct place.</p>
",1
39649328,39649241,2,"<p>In your <code>for</code> loop the last thing you do is put <code>s[4]</code> into <code>srev[0]</code>. The that element (the fifth because arrays are zero indexed) is the strings null terminator. That means that the first thing in <code>srev</code> tells <code>printf</code> to stop printing.<br>
Change your loop to this:</p>

<pre><code>for(i=0; 3&gt;=i; ++i){  
    srev[i] = s[3-i];
}
</code></pre>

<p>or:</p>

<pre><code>for(i=0; 4 &gt; i; ++i){  
    srev[i] = s[3-i];
}
</code></pre>
",0
39649389,39649241,0,"<p>becuase s[4] = '\0' which means end of character string. if you assign null terminator to a string it means you tell it: ""it's the end, accept no more characters"":</p>

<pre><code>#include &lt;stdio.h&gt;

#define MAXL 1000

char s[MAXL] = ""1234""; 
char srev[MAXL]; 

main(){

    int i = 0;                   
    for(i=0; 4 &gt; i; ++i){  
        srev[i] = s[3-i];  // 3 - 0 = 3 so s[3] = '4' s4 = '\0'
    }

    printf(""srev[]: %s"", srev);
    printf(""\n\n"");
}
</code></pre>
",0
39670272,39670157,3,"<p>Writing a separate loop for each row is insane. When you're doing the same thing over and over with slight variation, that means you need another wrapping loop. This should really only require a pair of <code>for</code> loops:</p>

<pre><code>unsigned maxval = ...;
for (unsigned rowlen = 1, val = 1; val &lt;= maxval; ++rowlen) {
    for (unsigned item = 0; item &lt; rowlen &amp;&amp; val &lt;= maxval; ++item) {
        printf(""%u "", val++);
    }
    printf(""\n"");
}
</code></pre>
",2
39670298,39670157,1,"<p>If you're doing this to practice the do while use this piece of code if you arent though go with @ShadowRanger's answer since i feel that it is better for this case scenario</p>

<pre><code>int x,y,counter, row;
row = 1;
counter = 0;
y=10;
x=1;

do {
    do { 

    counter --;
    printf(""%i "", x);
    x++;

    } while(counter &gt; 0);
        printf(""\n"");
        row++;
        counter = row;

}   while (x&lt;=y);
</code></pre>

<p>This adds 1 to the <code>row</code> variable each time the first do while loops to check in which row you're currently in then the <code>counter</code> is set to the row number that you're currently in to know how many numbers there will be in that row  the <code>x</code> variable is for the number that will be printed and the <code>y</code> variable is for how many numbers will be printed.</p>

<blockquote>
  <p>Note: this code will finish any row that has missing numbers Example:
  If you want to print 4 numbers this is what the code will print:
  1
  2 3
  4 5 6
  If you do NOT want this to happen change the first do while condition to
  this: while(counter > 0 &amp;&amp; x&lt;=y);</p>
</blockquote>
",0
39670331,39670157,3,"<p>You can do it with a single loop.</p>

<pre><code>void print_tri(unsigned int max_val) {
    unsigned int row_lim = 1;
    unsigned int row_len = 0;

    for (unsigned int i = 1; i &lt;= max_val; i++) {
        printf(""%u "", i);
        if (++row_len == row_lim) {
            putchar('\n');
            row_lim++;
            row_len = 0;
        }
    }
}
</code></pre>
",1
39670786,39670157,1,"<pre><code>#include &lt;stdio.h&gt;

void main() {
    int row = 1;
    int column = 1;

    for (int i = 1; i &lt;= 10; i++) {
        printf(""%d"", i);

        if (column == row) {
            printf(""\n"");
            row++;
            column = 1;
        }
        else {
            printf("" "");
            column++;
        }
    }
}
</code></pre>
",0
39674033,39670157,0,"<p>There are a number of ways to approach the logic, all are fine. Here is was that specifies a <code>b</code> begin variable to control the spacing logic (none on the first, a single space before for the remainder in the row) and provides two format strings (<code>fmt1</code> and <code>fmt2</code>) to accommodate. The code increment a <code>c</code> - count of values to print per row until it reaches <code>n</code> - the number of counts per row.</p>

<p>Take a look at all answers and let me know if you have any questions:</p>

<pre><code>#include &lt;stdio.h&gt;

int main (void) {

    /* i, b - begin, c - count, n - num per row */
    int i, b = 1, c = 0, n = 1;
    char *fmt1 = ""%d"", *fmt2 = "" %d"";

    for (i = 1; i &lt; 11; i++) {
        printf (i == b ? fmt1 : fmt2, i);
        c++;
        if (c == n) {
            b = i + 1, c = 0, n++;
            putchar ('\n');
        }
    }

    return 0;
}
</code></pre>

<p><strong>Example Use/Output</strong></p>

<pre><code>$ ./bin/looppyrimid
1
2 3
4 5 6
7 8 9 10
</code></pre>
",0
39675875,39670157,0,"<p>Thanks to all of you.The answer i was looking for is the answer that Marcel Jacques Machado and Ivan posted.I am just a beginner.And the exercise was to practice nested loops. The other post were helpful as well.</p>
",0
39681649,39680854,0,"<p>Here's the problem.</p>

<p>First, your first malloc call allocates space for a 1-element array.</p>

<p>You'll want to change it from</p>

<pre><code>int *p = (int *)malloc(sizeof(*p));
</code></pre>

<p>to</p>

<pre><code>int *p = (int *)malloc(sizeof(int*) * 20);
</code></pre>

<p>And then your second malloc call is slightly incorrect as well.</p>

<pre><code>p[i] = (int )malloc(sizeof(int*));
</code></pre>

<p>should be changed to</p>

<pre><code>p[i] = (int *)malloc(sizeof(int));
</code></pre>

<p>You just put the asterisk in the wrong place.</p>

<p>Finally, you really only create a 20-element array. All you do in the inner for loop is assign each cell in the array the value 0  times. If you want to make a 20x30 array, you can always take the easy route and create a 1D array and use some math (which is ultimately what the compiler does with non-dynamic 2D arrays anyway):</p>

<pre><code>int main()
{
    int *p = (int *)malloc(sizeof(int) * 600);
    ...
    for (i = 0; i &lt;= 19; i++)
    {
        printf("" %2d "", i);
        for (j = 0; j &lt;= 29; j++)
        {
            p[i * 30 + j] = 0; // It's i * 30, not i * 20 because you have to skip the space that the 'j' dimension takes up.
            printf(""%2d"", j);
        }
        printf(""\n"");
    }

    free((void*)p); //I found the program crashes without the void* cast
}
</code></pre>

<p>I've tested this code and it runs.</p>

<p>Hope this helps.</p>
",6
39687408,39687382,1,"<p>'^' is not a power operator. It's a bit operator. You need to <code>#include &lt;math.h&gt;</code> and use <code>pow(r, n)</code> instead. </p>
",0
44728818,44715982,1,"<p>This code may be easier to understand if you add all the curly brackets, and convert the ternary operator into an if-else statement:</p>

<pre><code>double *cholesky(double *A, int n) {
    double *L = (double*)calloc(n * n, sizeof(double));
    if (L == NULL) {
        exit(EXIT_FAILURE);
    }
    for (int i = 0; i &lt; n; i++) { // loop A
        for (int j = 0; j &lt; (i+1); j++) { // loop B
            double s = 0;
            for (int k = 0; k &lt; j; k++) { // loop C
                s += L[i * n + k] * L[j * n + k];
            }
            // still in loop B
            if (i == j) {
                L[i * n + j] = sqrt(A[i * n + i] - s);
            } else {
                L[i * n + j] = (1.0 / L[j * n + j] * (A[i * n + j] - s));
            }
        }
    }
    return L;
}
</code></pre>

<p>The code execution goes like this:</p>

<ol>
<li><em>loop A</em> starts and sets <code>i = 0</code>, and assuming <code>i</code> is less than <code>n</code> it runs</li>
<li><em>loop B</em> starts and sets <code>j = 0</code>, <code>j</code> is less than <code>i+1</code> (<code>1</code>) so it runs</li>
<li><code>s = 0</code></li>
<li><em>loop C</em> starts and sets <code>k = 0</code>, but since <code>k &lt; j</code> (<code>0 &lt; 0</code>) is false, the code in <em>loop C</em> does not run</li>
<li><p>The rest of <em>loop B</em> then executes:</p>

<pre><code>if (i == j) {
    L[i * n + j] = sqrt(A[i * n + i] - s);
} else {
    L[i * n + j] = (1.0 / L[j * n + j] * (A[i * n + j] - s));
}
</code></pre>

<p>Since <code>i = 0</code> and <code>j = 0</code>, <code>L[i * n + j]</code> is set to <code>sqrt(A[i * n + i] - s)</code></p></li>
<li><em>loop B</em> increments <code>j</code> to <code>1</code>, but since <code>j &lt; (i+1)</code> (<code>1 &lt; 1</code>) is false, it terminates</li>
<li><em>loop A</em> increments <code>i</code> to <code>1</code>, and assuming <code>i</code> is less than <code>n</code> it runs</li>
<li><em>loop B</em> starts and sets <code>j = 0</code>, <code>j</code> is less than <code>i+1</code> (<code>2</code>) so it runs</li>
<li><code>s</code> is set to <code>0</code></li>
<li><em>loop C</em> starts and sets <code>k = 0</code>, but since <code>k &lt; j</code> (<code>0 &lt; 0</code>) is false, the code in <em>loop C</em> does not run</li>
<li>The rest of <em>loop B</em> runs. <code>i == j</code> is false, so <code>L[i * n + j]</code> is set to <code>(1.0 / L[j * n + j] * (A[i * n + j] - s))</code></li>
<li><em>loop B</em> increments <code>j</code> to <code>1</code>, and since <code>j &lt; (i+1)</code> (<code>1 &lt; 2</code>) is true, it runs</li>
<li><code>s</code> is set to <code>0</code></li>
<li><em>loop C</em> starts and sets <code>k = 0</code>, and since <code>k &lt; j</code> (<code>0 &lt; 1</code>) is true, it runs</li>
<li><code>s</code> is incremented by <code>L[i * n + k] * L[j * n + k]</code></li>
<li><em>loop C</em> increments <code>k</code> to <code>1</code>, but since <code>k &lt; j</code> (<code>1 &lt; 1</code>) is false, it terminates</li>
<li>The rest of <em>loop B</em> runs. <code>i == j</code> is true, so <code>L[i * n + j]</code> is set to <code>sqrt(A[i * n + i] - s)</code></li>
<li><em>loop B</em> increments <code>j</code> to <code>2</code>, but since <code>j &lt; (i+1)</code> (<code>2 &lt; 2</code>) is false, it terminates</li>
<li><em>loop A</em> increments <code>i</code> to <code>2</code>, and assuming <code>i</code> is less than <code>n</code> it runs</li>
<li>...</li>
</ol>
",0
37636242,37635495,2,"<p>No.</p>

<p>You can decode declaration in reverse order of normal evaluation of expression.</p>

<p>Normal evaluation order:</p>

<ol>
<li><code>foo</code></li>
<li><code>foo()</code></li>
<li><code>*foo()</code></li>
<li><code>(*foo())[30]</code></li>
<li><code>*(*foo())[30]</code></li>
</ol>

<p>So this declaration is:</p>

<ol>
<li><code>*(*foo())[30]</code>: <strong>a pointer</strong></li>
<li><code>(*foo())[30]</code>: <strong>array of</strong> pointers</li>
<li><code>*foo()</code>: <strong>a pointer to</strong> array of pointers</li>
<li><code>foo()</code>: <strong>function that returns a</strong> pointer to array of pointers</li>
<li><code>foo</code></li>
</ol>

<p>So this declaration means ""a function <code>foo</code> that returns a pointer to array of pointers to <code>int</code>"".</p>

<p>The point in which you are wrong is that the number of arguments of <code>foo</code> isn't specified here, so its number of arguments need not be zero.</p>
",0
37828405,37827212,0,"<p>As suggested by iharob, you will probably need to create a temporary file, write the modified content to it and rename it. It will work for most cases.</p>

<p>However, If this involves thousands or hundreds of thousands of entries, this method is not practical. Then, you will need a different file storage structure. Each field should have a maximum limit and be padded upto it's limit. The size of each line will become equal in each case, and can be easily replaced by another line.</p>

<p>e.g.</p>

<pre><code>AG001;July biscuits      ;005.035;090
BG001;Maximu Bun         ;003.050;020 
BG002;Lamli Burger       ;004.060;015
CG001;TTT Candy          ;004.000;042
</code></pre>
",2
37829649,37827212,0,"<p>I made an simplified example to show you how you can use structs and a 'temporary' file to achieve your goal. </p>

<p>This is a shortend structure of your items. For simplicity i only used the item code and the item name:</p>

<pre><code>typedef struct
{
  char item_code[10];
  char item_name[50];
} item;
</code></pre>

<p>First of all i would suggest to write a read an write fuction so you can easily write this struct to an file and read it from it. Something like this: </p>

<pre><code>void write_items_to_file(FILE* fp, item* items, size_t size)
{
  if (!fp)
  {
    fprintf(stderr, ""File not open!\n"");
    return;
  }

  for (size_t i = 0; i &lt; size; i++)
  {
    fprintf(fp, ""%s;%s;\n"", items[i].item_code, items[i].item_name);
  }
}

size_t read_items_from_file(FILE* fp, item* items, size_t max)
{
  if (!fp)
  {
    printf(""File not open!\n"");
    return -1;
  }

  char line[MAX_LEN];
  size_t current_item = 0;
  while (fgets(line, MAX_LEN, fp) &amp;&amp; current_item &lt; max)
  {
    if (sscanf(line, ""%5[^;];%50[^;];"", (items[current_item].item_code), (items[current_item].item_name)) != 2) // change '2' to the amount of atributes of item
    {
      fprintf(stderr, ""Wrong internal file organization!\n"");
      return -2;
    }
    current_item++;
  }
  return current_item;
}
</code></pre>

<p>Now we got this, lets face the changing part. Assume we have a file with two items:</p>

<pre><code>AG001;July biscuits;
BG001;Maximu Bun;
</code></pre>

<p>Now we can use the <code>read_items_from_file</code> function to get the items. If You now want to change <code>July biscuits</code> to <code>Gardenia</code> we can use <code>strncmp</code> to find the item with the name <code>July biscuits</code> and replace it.</p>

<p>When we're finished with editing the items we write the to another file e.g. <code>""items.txt.tmp""</code> using the <code>write_items_to_file</code> function. After that we <code>rename</code> the 'temporary' file to the original file und thus replaced the name of the desired item in the original file. This is as others pointed out the easiest approach.</p>

<p>Here ist the complete main of the scenario i described:  </p>

<pre><code>int main()
{
  FILE *fp = fopen(""items.txt"", ""r"");
  item items_read[2]; 

  size_t read_values = read_items_from_file(fp, items_read, 2);

  for (size_t i = 0; i &lt; read_values; i++)
  {
    if (strncmp(items_read[i].item_name, ""July biscuits"", 50) == 0)
    {
      strncpy(items_read[i].item_name,""Gardenia"", 50);
    }
  }

  if (fp)
  {
    fclose(fp);
  }

  // now create a new file
  fp = fopen(""items.txt.tmp"", ""w"");
  if (fp)
  {
    write_items_to_file(fp, items_read, 2);
    fclose(fp);

    // now ""move"" the temp file to the original file using 'rename'
    rename(""items.txt.tmp"", ""items.txt"");
  }
}
</code></pre>

<p><strong>Note:</strong> Of course you have to change the <code>item struct</code> and the read and write functions according to your requirements.</p>
",0
37349469,37349011,0,"<p>According to the standard, <code>fpos_t</code> can be ""<em>a complete object type other than an array type</em>"" (<a href=""http://port70.net/~nsz/c/c11/n1570.html#7.21.1p2"" rel=""nofollow"">7.21.1p2</a>).</p>

<p>Thus <code>printf</code>ing an <code>fpos_t</code> with <code>%d</code> type specifier does invoke <em>undefined behaviour</em> - unless it is <code>int</code> by chance. As there are no guarantees about its type, you must not rely on a specific type. Just don't <code>fprintf</code> <code>fpos_t</code>.</p>

<p>Enable compiler warnings and pay heed to them. In C a warning is always to be treated seriously.</p>
",0
37641565,37641524,0,"<p>Yes its possible. You will have to create a struct having 3 data members like this:  </p>

<pre><code>struct node
{
     char name[20];
     char occupation[20];
     long salary;
     struct node *left_child;
     struct node *right_child;
};
</code></pre>

<p>and then you can perform the operations of insertion and deletion wrt the salary keeping in mind that lesser salary nodes will be on the left and higher salary on the right. Also you'll need a root node pointer as well.</p>
",0
37691322,37691303,4,"<p>It's undefined behavior, try</p>

<pre><code>scanf(""%14s"", name);
</code></pre>

<p>You pass the wrong parameter to the ""%c"" specifier which expects a pointer to a single <code>char</code>. Instead you need the <code>""%s""</code> specifier and since <code>name</code> is an array it's automatically a pointer to it's first element so you don't need the <code>&amp;</code> address of operator.</p>
",1
37698540,37698301,3,"<p>Provide explicit casting in initialization as:</p>

<pre><code>io_hw_t *const  io[] = {(io_hw_t *)PABASE, (io_hw_t *)PBBASE};
</code></pre>

<p><code>io</code> is declared as as array of <code>const</code> pointer to <code>io_hw_t</code>. So each member must be a pointer. But <code>PABASE</code> is integer constant and needs to be explicitly casted to pointer.</p>

<p>Alternatively you can add the casts in your macros also as:</p>

<pre><code>#define PABASE ((void *)0x200)
</code></pre>
",0
37762819,37762762,2,"<p>It seems you mean the following</p>

<pre><code>void matrix_deallocation(MATRIX* matrix)
//this function deallocates a matrix
{
    for ( int i = 0; i &lt; matrix-&gt;n_rows; i++ )
    //                           ^^^^^^ 
    {
        free( matrix-&gt;pp_matrix[i] );
    }
    free(matrix-&gt;pp_matrix);
}
</code></pre>
",2
40892026,40891898,1,"<p>You can check if the last character is a newline in <code>questionLength</code> (<code>fgets()</code> will read in the newline if there's room). If so, you know it's less than or equal to 50 chars.
Otherwise, the input is longer.</p>

<p>When the input is <em>exactly</em> 49 bytes then there won't be a newline. You can work around it by reading one more character (change <code>questionLength</code> size of 51).</p>
",0
40892264,40891898,0,"<p>You'll know if the whole string was read because it contains a <code>newline</code>. If you want to discard the remainder of any long string, an easy way is to read it all in the first place. If it was read in a single attempt, that's good.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define STRLEN 50

int main(void) 
{
    char questionLength[STRLEN+2];          // 1 for newline, 1 for EOS
    int tries;

    while(1) {
        tries = 0;
        printf(""Second can you tell me the question for your answer\n"");
        do {
            if(fgets(questionLength, sizeof questionLength, stdin) == NULL) {
                exit(1);
            }
            tries++;
        } while(strchr(questionLength, '\n') == NULL);

        if(tries == 1) {
            printf(""You entered: %s"", questionLength);
        }
        else {
            printf(""Your entry was too long\n"");
        }
        printf(""\n"");
    }
    return 0;
}
</code></pre>
",0
37771561,37771340,4,"<p>Here is a working example of your code</p>

<pre><code>#include &lt;stdio.h&gt;

struct x
{
    char cGender;
    char szBirthDt[200];
    char szEmailAddr[200];
    char szFullName[200];
    char szStreetAddress[200];
    char szCity[200];
    char szStateCd[200];
    char szZipCd[200];

};

struct y
{
    char szFlightId[200];
    int iRequestSeats;
};

int main(void) {
    struct x customer;
    struct y flight;
    int iScanfCnt;
    char* szInputBuffer = ""m a bbbb cccccc\nsome text\nde fg hijkl mnop 10"";

    iScanfCnt = sscanf(szInputBuffer, ""%1c %1s %4s %30[^\n] %30[^\n] %2s %2s %5s %s %d\n""
    , &amp;customer.cGender
    , customer.szBirthDt
    , customer.szEmailAddr
    , customer.szFullName
    , customer.szStreetAddress
    , customer.szCity
    , customer.szStateCd
    , customer.szZipCd
    , flight.szFlightId
    , &amp;flight.iRequestSeats);

    if (iScanfCnt &lt; 10)
    {
        printf(""invalid input when reading student data, only %d valid values. \n""
            , iScanfCnt);
        printf(""\tdata is %s\n"", szInputBuffer);
        return -1;
    }

// Fix:      %c                 %s   %s
    printf(""%1c %10.2s %10.2s %30s %30s %10.2s %2s %5s %s %d\n""
            , customer.cGender  // Fix: no &amp;
            , customer.szBirthDt
            , customer.szEmailAddr
            , customer.szFullName
            , customer.szStreetAddress
            , customer.szCity
            , customer.szStateCd
            , customer.szZipCd
            , flight.szFlightId
            , flight.iRequestSeats);    // Fix: no &amp;

    return 0;
}
</code></pre>

<p>I only needed to fix the <code>printf</code> - the <code>sscanf</code>worked fine.</p>

<p>Output:</p>

<pre><code>m          a         bb                         cccccc                      some text         de fg hijkl mnop 10
</code></pre>

<p>See <a href=""https://ideone.com/ipAHIb"" rel=""nofollow"">https://ideone.com/ipAHIb</a></p>
",4
40760149,40759555,0,"<pre><code>#include&lt;stdio.h&gt;
// Use double pointer since fp is getting address of a pointer variable
void hello(FILE ** fp)
{ 
    // If the file is already pointing to some file then close that file
    if(*fp != NULL)
    {
        fclose(*fp); 
        *fp = NULL;
    }
    if( ( *fp = fopen(""log"",""r"") ) == NULL)
        printf(""%s"", ""Error opening file"");
}

int main()
{
    char p;
    FILE *sf=fopen(""prac.txt"",""r"");
    // While sending the file pointer you need to send the address of the file pointer
    hello(&amp;sf);

    p=fgetc(sf);
    printf(""%c"",p);

    return 0;
}
</code></pre>
",0
40759641,40759555,0,"<p>you should close the file before reopning it</p>

<pre><code>#include&lt;stdio.h&gt;
void hello(FILE ** fp)
{ 
 fclose(*fp);
if( ( *fp = fopen(""log"",""r"") ) == NULL)
  printf(""%s"", ""Error opening file"");    
}

void main()
{
 char p;
 FILE *sf=fopen(""prac.txt"",""r"");
 hello(&amp;sf);

 p=fgetc(sf);
 printf(""%c"",p);
}
</code></pre>
",2
40759712,40759555,2,"<p>In <code>void hello(FILE *fp)</code>, <code>fp</code> only exists in the scope of the function <code>hello</code> (the value of the pointer is copied when you call the function and it's destroyed at the end of the func).</p>

<p>This works: </p>

<pre><code>#include&lt;stdio.h&gt;

FILE* hello(FILE * fp)
{ 
    fclose(fp);
    if( ( fp = fopen(""log"",""r"") ) == NULL) {
        printf(""%s"", ""Error opening file"");
        return NULL;
    }
    return fp;
}

void main()
{
    char p;
    FILE *sf=fopen(""prac.txt"",""r"");
    sf = hello(sf);

    if (sf != NULL) 
    {
        p=fgetc(sf);
        printf(""%c"",p);
    }
}
</code></pre>
",2
40759720,40759555,3,"<p>If you want to change what the <code>FILE*</code> points to, you need to pass a <code>FILE**</code>. Before you change it, you need to ensure that any file it happens to be pointing to is closed. This also relies on you always setting <code>FILE*</code> variables to NULL after <code>fclose</code> (this, alas, does not happen automatically), so there's a decent chance careless use of this function would call <code>fclose</code> on an already-closed <code>FILE*</code>. But this is probably still better than willfully leaking file descriptors and not flushing files.</p>

<pre><code>void hello(FILE **fp)
{
  // This is actually a horrible test. And in general, this is not
  // something you should do, but it is better than leaking open
  // file descriptors, so, yeah, 
  if (*fp != NULL) {
    fclose(*fp);
    *fp = NULL;
    printf(""Closed file."");
  }
  if( (*fp = fopen(""log"",""r"") == NULL) {
    printf(""%s"", ""Error opening file"");
  }
}
</code></pre>
",2
40759726,40759555,0,"<p>This is because you copy arguments. You do not override the content of the file pointer only the local copy of the address. </p>

<p>The file pointer itself is not updated. To archive this either pass a pointer to a pointer to the function and dereference accordingly or return the new file pointer and override the old one. Anyways care for closing the file.</p>
",0
46943693,46943576,2,"<pre><code>fwrite(&amp;one, one_len, 1, fp);
</code></pre>

<p><code>&amp;one</code> is the address of the <em>pointer</em> <code>one</code> on the stack, not the location it points to. This means that, instead of writing the string pointed to by <code>one</code>, you're writing the bytes that make up its address, potentially along with whatever happens to come after that in memory.</p>

<pre><code>fread(&amp;(temp-&gt;filename), sizeof(char), temp-&gt;filename_len, fp);
</code></pre>

<p>Similarly, this reads a pointer (or part of a pointer) into <code>temp-&gt;filename</code>, and may additionally overwrite whatever happens to be after it.</p>

<p>What you need to do is:</p>

<pre><code>fwrite(one, one_len, 1, fp);
</code></pre>

<p>Write the actual contents of the string, not its address.</p>

<pre><code>temp-&gt;filename = calloc(temp-&gt;filename_len + 1, sizeof(char));
fread(temp-&gt;filename, sizeof(char), temp-&gt;filename_len, fp);
</code></pre>

<p>Allocate a buffer sized appropriately for the filename, then read data into that buffer.</p>
",2
46943700,46943576,1,"<p>1) You are calling <code>fread</code> with the <strong>address of</strong> <code>temp-&gt;filename</code>. </p>

<pre><code>fread(&amp;(temp-&gt;filename), sizeof(char), temp-&gt;filename_len, fp)
</code></pre>

<p>You don't want to do this.  <code>temp-&gt;filename</code> is already a pointer to a char.  Instead pass simply <code>temp-&gt;filename</code>.</p>

<p>2) You aren't allocating any space for <code>temp-&gt;filename</code>.  You need to do this after you read <code>temp-&gt;filename_len</code>.</p>

<pre><code>fread(&amp;(temp-&gt;filename_len), sizeof(int), 1, fp);
temp-&gt;filename = malloc((temp-&gt;filename_len + 1) * sizeof(char))
fread(temp-&gt;filename, sizeof(char), temp-&gt;filename_len, fp);
temp-&gt;filename[temp-&gt;filename_len] = '\0';
</code></pre>

<p>Similarly for <code>temp-&gt;contents</code></p>
",0
37906606,37906099,0,"<p>You <code>planet</code> is a <code>char</code> so it can hold only one <code>char</code> but in <code>scanf</code> you are trying to read string instead.
use <code>%c</code> instead of <code>%s</code></p>

<p><code>scanf(""%c"",&amp;planet);</code></p>

<p>Variable <code>earth</code> contains garbage initially because you haven't assigned any value to it.
In the <code>if</code> statement you are assigning <code>=</code> instead of comparision <code>==</code>.</p>

<p>When you are reading value for <code>weight</code> you are not using <code>address of</code>operator <code>&amp;</code> hence it can't read the value.</p>

<p><code>mass=weight/a;</code> here you should have used explicit typecasting else your result would be in <code>int</code> which would be later upgraded to <code>float</code> while assigning but your decimal value would already be lost by then.</p>

<pre><code>int main()
 {
char planet;
char earth='A'; //at least assign something
int  weight;
float mass;
int a=9;
printf(""Planet Name \n"");
scanf(""%c"",&amp;planet);

if(planet==earth){

printf(""Enter your weight \n"");
scanf(""%d"",&amp;weight);
mass=(float)weight/a;
printf(""Your mass is %d"",mass);}
else {
printf(""Aww,snap!!!!!!We couldn't find the data"");
}

return 0;}
</code></pre>

<p>I didn't compile, should work.</p>
",1
37906354,37906099,0,"<p>When you do this</p>

<pre><code>if(planet=earth){
</code></pre>

<p>you are doing equivalent to:</p>

<pre><code>char x = planet=earth;
if(x){
</code></pre>

<p>and not </p>

<p>bool x = planet==earth;
   if(x){</p>

<p>the wrong part is that according to the language spacification</p>

<pre><code>if(x){
</code></pre>

<p>can be accepted by the compiler and in case x is not a boolean expression, it will be converted to a boolean one, BUT following the criteria:</p>

<ul>
<li>false if x is zero,  true otherwise.</li>
</ul>

<p>so at the end </p>

<pre><code>if(false){ //never met until the char given as input is a valid
    ...
else {
    printf(""Aww,snap!!!!!!We couldn't find the data"");
}
</code></pre>
",0
37910035,37906099,0,"<p>The correct version of your code is this :</p>

<pre><code>#include&lt;stdio.h&gt;
int main()
 {
char planet;
char earth='e';//Assign a value to this variable first.
int  weight;
float mass;
int a=9;
printf(""Planet Name \n"");
scanf(""%c"",&amp;planet);

if(planet==earth){

printf(""Enter your weight \n"");
scanf(""%d"",&amp;weight);
mass=(float)weight/a;
printf(""Your mass is %f"",mass);}
else {
printf(""Aww,snap!!!!!!We couldn't find the data"");
}

return 0;}
</code></pre>

<p>If you input 'e' in the console you will get your required answer after you enter the weight.</p>
",0
37962176,37958585,0,"<p>if only 1st and last elements must be characters , then u can try this,
but if u want 1st and last element to be char and all middle to be digits then add another if statement after first ""if""</p>

<p>boolean b=false;</p>

<p>while(b!=true){</p>

<p>take input in ch[10];</p>

<p>if(ch[0]>='A'&amp;&amp;ch[0]&lt;='Z' &amp;&amp; ch[9]>='A'&amp;&amp;ch[0]&lt;='9'){</p>

<p>//means 1st and last are char</p>

<p>b=true;//will break because of this
}</p>

<p>else {</p>

<p>print f(""Wrong input, enter again"");</p>

<p>b=false;}</p>

<p>}
//this will run until user does not give correct input</p>
",3
38414364,38414337,-1,"<p>You need to add <code>getchar()</code> before second <code>scanf();</code>
There is already a <code>'\n'</code> char in the buffer. In the second <code>scanf()</code> operation it reads that character and terminates the program.</p>
",0
38414476,38414337,0,"<p>Prevent buffer overflow by passing the maximum number of characters to <code>scanf</code> and skip the <code>'\n'</code> with a dummy format:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void) {
    char word1[20], word2[20];

    printf(""Enter word 1: "");
    fflush(stdout);  // make sure prompt is output
    if (scanf(""%19[^\n]%*c"", word1) &lt; 1)
        return 1;

    printf(""Enter word 2: "");
    fflush(stdout);  // make sure prompt is output
    if (scanf(""%19[^\n]%*c"", word2) &lt; 1)
        return 1;

    return 0;
}
</code></pre>

<p>Note that using <code>scanf</code> to read lines has some side effects: you cannot read an empty line this way and you have to hard code the buffer size in the format string in an awkward way.</p>

<p>I would instead suggest using <code>fgets()</code> and stripping the trailing <code>'\n'</code> this way:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void) {
    char word1[20], word2[20];

    printf(""enter word 1 : "");
    fflush(stdout);  // make sure prompt is output
    if (fgets(word1, sizeof word1, stdin) == NULL)
        return 1;

    word1[strcspn(word1, ""\n"")] = '\0'; // strip the \n if any

    printf(""enter word 2 : "");
    fflush(stdout);  // make sure prompt is output
    if (fgets(word2, sizeof word2, stdin) == NULL)
        return 1;

    word2[strcspn(word2, ""\n"")] = '\0'; // strip the \n if any

    printf(""word1: |%s|, word2: |%s|\n"", word1, word2);
    return 0;
}
</code></pre>
",4
38414429,38414337,2,"<p>If you read the manual page <a href=""http://linux.die.net/man/3/scanf"" rel=""nofollow"">scanf</a></p>

<p>Then this bit does not make sense</p>

<pre><code>scanf(""%[^\n]s"",&amp;word1);
</code></pre>

<p>It should be</p>

<pre><code>if (scanf(""%19[^\n]"",word1) == 1) ....
</code></pre>

<p>And ditto for <code>word2</code></p>

<p><strong>EDIT</strong></p>

<p>For word 2</p>

<pre><code>if (scanf(""\n%19[^\n]"",word2) == 1) ....
</code></pre>
",3
38414436,38414337,4,"<p>You are sending <strong>wrong argument type</strong> into <code>scanf()</code> for scanning strings and <strong>not checking for whitespaces</strong>... Instead use <code>scanf</code> this way :</p>

<pre><code>scanf(""%19[^\n]"",word1); 
//and also
scanf("" %19[^\n]"",word2); 
// a space in front to consume white spaces and don't put &amp; before string variable 
</code></pre>

<ul>
<li>While scanning a string using <code>scanf()</code> the argument to be sent must be of the type <code>char*</code> but not <code>char</code></li>
<li>here, <code>word1</code> and <code>word2</code> are of the type <code>char*</code> whereas <code>word1[i]</code> and <code>word2[i]</code> are of the type <code>char</code></li>
<li><code>%19[^\n]</code> would  allow scanning only <code>19</code> characters including whitespaces (i.e, <code>'\0'</code>, <code>'\n'</code> <code>' '</code>) and will leave the last index for terminating null character <code>'\0'</code>. Here, 19 iss known as <a href=""https://msdn.microsoft.com/en-us/library/xdb9w69d.aspx"" rel=""nofollow""><strong>width field</strong></a> <em>(click to know more)</em></li>
</ul>

<hr>

<p>Further reading :</p>

<p><a href=""http://c-faq.com/stdio/scanfprobs.html"" rel=""nofollow""><strong><em>Why does everyone say not to use scanf? What should I use instead?</em></strong></a></p>
",2
38392307,37933235,0,"<p><a href=""http://ideone.com/3umold"" rel=""nofollow"">ideone.com/3umold</a> ¨C BLUEPIXY</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

double sum(const char s[]);

int main(void) {
    int i;
    //double sum=0;

    char* str[] = {
        ""12, 34, 56, 78"",
        ""82.16, 41.296"",
        ""2, -3, 5, -7, 11, -13, 17, -19"",
        ""9.00009, 90.0009, 900.009, 9000.09, 90000.9""
    };

    for(i = 0; i &lt; sizeof(str)/sizeof(*str); i++){
        //print
        printf(""sum = %f \n"", sum(str[i]));
    }

    return 0;
}

double sum(const char s[]){
    char str[100];
    char *token, *del = "", "";
    double sum = 0.0;

    strcpy(str, s);
    token = strtok(str, del);

    while( token != NULL ){
        sum += atof(token);
        token = strtok(NULL, del);
    }
    return sum;
}
</code></pre>
",0
39671951,39671911,2,"<p>Arrays passed into functions always modify the original array. The function declarations:</p>

<pre><code>void func( int* array);
void func( int array[]);
</code></pre>

<p>Are equivalent, because when you call these functions with an array argument the array <em>decays</em> into a pointer for both. Because you're passing a pointer, you're actually passing the array by reference, and the original array is modified.</p>
",9
39602083,39597202,0,"<p>As the range contains negative integers we need a signed number. The largest signed integer that the C standard specifies
is the long long int (introduced in the ISO C99 standard, see <a href=""https://en.wikipedia.org/wiki/C_data_types"" rel=""nofollow"">https://en.wikipedia.org/wiki/C_data_types</a>).</p>

<p>The standard stipulates that it should be able to at least hold
numbers in the range -(2^63 - 1) to 2^63 - 1. Note here that the common way of implementing this data type in
hardware is to use a 64-bit two's complemented integer that gives the exact range of -2^63 to 2^63-1. This is too small
for your needs so you'll either need to use a non-standard datatype or create your own.</p>

<p>Luckily there is a 128 bit
signed integer datatype in both the gcc and the clang compilers. It is called __int128_t. I couldn't find any specification
on the range of this type but we can assume it in practice to be -2^127 to 2^127-1. This datatype can handle
addition in the range you specify except when carry occurs (see <a href=""https://en.wikipedia.org/wiki/Carry_(arithmetic)"" rel=""nofollow"">https://en.wikipedia.org/wiki/Carry_(arithmetic)</a>).</p>
",0
37902976,37902902,0,"<p>I fixed so that your program compiles, but it still has issues. I had to comment out a type mismatch, but at least this compiles so that you have something to work on. </p>

<pre><code>#include &lt;stdio.h&gt;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define MAX 100

FILE *fp;
FILE *fpIn;
FILE *fpOut;

typedef struct {
    char first[7];
    char initial[1];
    char last[9];
    char street[16];
    char city[11];
    char state[2];
    char zip[5];
    int age;
    char sex[1];
    int tenure;
    double salary;
} workers;

void readFile();
void strsub (char buf[], char sub[], int start, int end);

int main()
{

    if (!(fpIn = fopen(""payfile.txt"", ""r"")))
    {
        printf(""payfile.txt could not be opened for input."");
        exit(1);
    }
    if (!(fpOut = fopen(""csis.txt"", ""w"")))
    {
        printf(""csis.txt could not be opened for output."");
        exit(1);
    }

    return 0;
}
workers array[8];
void readFile()
{
    int i =0;
    char buf[MAX];
    while(!feof(fpIn))
    {
        fgets(buf, MAX, fpIn);
        strsub(buf, array[i].first, 0, 6);
        strsub(buf, array[i].initial, 8, 8);
        strsub(buf, array[i].last, 10, 18);
        strsub(buf, array[i].street, 20, 35);
        strsub(buf, array[i].city, 37, 47);
        strsub(buf, array[i].state, 49, 50);
        strsub(buf, array[i].zip, 52, 56);
        strsub(buf, array[i].age, 58, 59);
        strsub(buf, array[i].sex, 61, 61);
        strsub(buf, array[i].tenure, 63, 63);
        //strsub(buf, array[i].salary, 65, 70);
    }
}

void strsub (char buf[], char sub[], int start, int end)
{
    int i, j;

    for (j=0, i=start; i &lt;= end; i++, j++)
    {
        sub[j] = buf[i];
    }
    sub[j] = '\0';
}
</code></pre>
",5
37195061,37194923,0,"<p>Getline reads everything until the end of line character is seen. You must assure you haven't left the endline character in the deleted line. You can achieve that by pressing backspace.</p>
",0
37912460,37911928,0,"<p>Look, beside of : <code>malloc(sizeof(char)*strlen(aux));</code> you are allocating the sizof string without '\0' so you should allocate 1 more for example <code>malloc(sizeof(char)*strlen(aux) + 1);</code>. When you are copying the <code>aux</code> you are writing over the next segment of memory you didn't allocate. Next, there is no link between nodes. That is why </p>

<pre><code>while (next-&gt;prox != NULL)
                next = next-&gt;prox;
</code></pre>

<p>fails. Try to make a links inside of while loop and that should work. And i hope you made the <code>name</code> variable as <code>char *</code> </p>

<p>In while loop, you are missing ')'.</p>
",3
37904442,37898799,0,"<p>We can make more efficient use of memory (2x) by only sieving odd numbers as all the even numbers you're processing waste time and space.  It's trickier to work out but gives us something like:</p>

<pre><code>#include &lt;math.h&gt;
#include &lt;libc.h&gt;

#define MAX_ODD_PRIMES 1048576

void prime(unsigned long fn, unsigned long sn)
{
    unsigned char primes[MAX_ODD_PRIMES];

    for (unsigned long i = 0; i &lt; MAX_ODD_PRIMES; i++)
    {
        primes[i] = TRUE;
    }

    primes[0] = 0; // preset first odd, '1'

    for (unsigned long k = 3; k &lt;= sqrt(sn) + 1; k += 2)
    {
        if (primes[k / 2])
        {
            for (unsigned long j = 3; (k * j) &lt;= sn; j += 2)
            {
                primes[k * j / 2] = FALSE;
            }
        }
    }

    if (fn &lt;= 2)
    {
        printf(""2\n"");
        fn = 3;
    }

    for (unsigned long i = fn / 2; i * 2 + 1 &lt;= sn; i++)
    {
        if (primes[i])
        {
            printf(""%lu\n"", i * 2 + 1);
        }
    }
}
</code></pre>

<p><strong>EXAMPLE</strong></p>

<pre><code>&gt; ./a.out
1 1999900 2000000
1999957
1999969
1999979
1999993
&gt;
</code></pre>
",0
38998688,38998407,1,"<p>I think you are searching for this one. It is very easy to use and it does the job.</p>

<pre><code>line[strcspn(line, ""\n"")] = '\0';
</code></pre>
",11
38999308,38998407,3,"<p>There are problems in your code:</p>

<ul>
<li><p>You do not check the return value of <code>fopen()</code>, nor that of <code>malloc()</code>.</p></li>
<li><p><code>strcpy(command, strcat(command,"" -o""));</code> and <code>strcpy(line, strcat(line, "".lst""));</code> invoke undefined behavior as you call <code>strcpy</code> on overlapping strings.</p></li>
<li><p><code>strcpy(command, line);</code> overwrites the string you just copied to <code>command</code> with <code>strcpy(command, ""crunch 8 8 -t "");</code>.</p></li>
<li><p>You do not check the lengths before copying or concatenating strings into <code>line</code> and <code>command</code>.  You should use <code>snprintf()</code> for both a safer and simpler method.</p></li>
</ul>

<p>To get rid of the trailing linefeed in <code>line</code> left by <code>fgets()</code>, you can either write:</p>

<pre><code>line[strcspn(line, ""\n"")] = '\0';
</code></pre>

<p>or you can write this:</p>

<pre><code>char *p = strchr(line, '\n');
if (p != NULL)
    *p = '\0';
</code></pre>

<p>or even this one that <em>removes the linefeed at the end of the string</em>:</p>

<pre><code>size_t len = strlen(line);
if (len &gt; 0 &amp;&amp; line[len - 1] == '\n')
    line[--len] = '\0';
</code></pre>

<p>With both of the latter methods, you can track whether there was indeed a linefeed or not.  The absence of a linefeed at the end of the line can mean one of several possibilities:</p>

<ul>
<li><p>The line was truncated because it does not fit in the buffer provided.  You should be careful to handle this condition because the string read does not correspond to the actual file contents. It could happen in your case if a filename is longer than 298 bytes, which is possible on many modern file systems.</p></li>
<li><p>The end of file was reached but no linefeed is present in the file at the end of the last line.  This is probably not an error, but could indicate that the input file was truncated somehow.</p></li>
<li><p>The input file contains a <code>'\0'</code> byte, which causes early termination of the line read by <code>fgets()</code>. This would not be allowed as part of a filename and is quite unlikely to occur in text files, unless the file was encoded as ucs2 or UTF-16.</p></li>
</ul>
",0
40969826,40968982,2,"<p>You have two issues :-</p>

<p>in this part you are continuously increasing the mm++ but not initialize the mm again when you are going to read another line from file. issue is array bound error.</p>

<pre><code>while(fgets(data, 30, fp)!=NULL){
        printf(""data is = %s\n"", data);
edited: mm=0;
        token=strtok(data, "" "");
        while(token!=NULL)
        {
                printf(""token is = %s\n"", token);
                ct[mm]=atoi(token);
                printf(""%d....%d\n"",mm,ct[mm]);
                token=strtok(NULL, "" "");
                mm++;
        }
</code></pre>

<p>Second issue is :-</p>

<p>you have one arrey city[30][30], where row and column, both are 30.
in you code you reading a file that conation string like ""30 435"", and performed strtok() operation on each string and saved conversion of string to int in ct[0] = 30 and ct[1] = 435. you got issue because array bound checking.
ct[1] is 435 but you define city[30[30]. </p>

<pre><code>        city[ct[0]][ct[1]]=ct[2];
        printf(""%d"", city[ct[0]][ct[1]]);
        city[ct[1]][ct[0]]=ct[2];
        printf(""%d"", city[ct[1]][ct[0]]);
</code></pre>
",0
39674251,39674199,1,"<p>You can assign a global variable using an expression. But only inside a function. As said by the compiler/linker, outside a function you can initialize variables only to constant. This is because, outside a function, no code can be executed and the variables are initialized to constant value by the compiler/linker at build time. Note that if you don't init the variable (outside a function), the default initialization is to 0.
To make it work you should write</p>

<pre><code>#include&lt;stdio.h&gt;
int a=8;
int b;
int main()
{
   b=a+9;
   printf(""%d"",b);
   return 0;
}
</code></pre>
",1
39674296,39674199,3,"<p>The reason is that global variables are initialized in compiling time,
and you are trying to initialize <code>b=a+9;</code>  as an operation that must be done in execution time.</p>
",0
39674403,39674199,0,"<p>As <code>b</code> is of arithmetic type and has static storage duration, its initializer has to satisfy the rules of arithmetic constant expressions (C11 ¡ì6.6 Expressions):</p>

<blockquote>
  <p><strong>8</strong>    An arithmetic constant expression shall have arithmetic type and
  shall only have
       operands that are integer constants, floating constants, enumeration constants, character
       constants, sizeof expressions whose results are integer constants, and _Alignof
       expressions. </p>
  
  <p>Cast operators in an arithmetic constant expression shall only convert
       arithmetic types to arithmetic types, except as part of an operand to a sizeof or
       _Alignof operator.</p>
</blockquote>

<p><code>int b=a+9;</code> doesn't.</p>
",0
47475833,47475702,0,"<p>It seems you have your terminology mixed up.  What you're calling ""signed"" numbers are actually called <em>fractional</em> numbers.</p>

<p>So what you're really asking for is a datatype that hold values that are both fractional and negative.  The <code>double</code> type can do just that.</p>
",0
35275161,35275027,2,"<p>The compiler will complain for the <code>==</code> if both variables don't have the same type. So I suspect this is to ensure the values really can be compared.</p>

<p>Try:</p>

<pre><code>int i;
char *p;
(void)min(i, p);
</code></pre>

<p>And yes, the operation will be optimised away with any optimisation level other than <code>-O0</code>.</p>
",3
38022792,38022739,2,"<p>Interesting.  It looks like you and the test program have a different coordinate system.  Your result and the reference result are identical if you flip both axis.</p>
",6
40752719,40752693,3,"<p>You also need to <code>malloc()</code> the <code>questionName</code>, <code>objectName</code> and so on. But you can also do something easier and simlper, use <code>strdup()</code> like this</p>

<pre><code>ptr-&gt;questionName = strdup(""Does it have a tail?"");
</code></pre>

<p>One more thing, you need to check the return value of <code>malloc()</code> against <code>NULL</code>.</p>

<p>NOTE: And please don't use spaces around the <code>-&gt;</code> operator, it looks terrible. Also, be consistent with white space usage, use enough of it not too little but not too much. Only, be consistent with your own style.</p>
",4
36269228,36266703,1,"<blockquote>
  <p>Is a uintmax_t guarantee to be large enough to hold a function pointer? </p>
</blockquote>

<p>No guaranteed way as well answered by others.</p>

<hr>

<p>Yet the size of a function pointer does exist and it does have a bit pattern.  If sufficiently large, <code>uintmax_t</code> could hold the pointer's bit pattern (and maybe more).  This size test could be assessed at compile time.</p>

<pre><code>#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;

int foo(int x) {
 return x+x;
}

int main(void) {
  union {
    uintmax_t um;
    int (*fp)(int);
  } u  = {0};
  assert(sizeof u.um &gt;= sizeof u.fp);  // This assertion may fail
  u.fp = foo;

  uintmax_t save = u.um;
  printf(""%ju\n"", save);

  u.um = save;
  printf(""%d\n"", (*u.fp)(42));

  return 0;
}
</code></pre>

<p>Output</p>

<pre><code>4198816
84
</code></pre>
",0
36267994,36266703,5,"<p>There is no such guarantee in the C standard.</p>

<p>First, there is no guarantee that any pointer can be losslessly converted to an integer type (except a NULL pointer). It is true that <code>uintptr_t</code> must be able to losslessly represent a void pointer (and thus any onject pointer). However, there is no guarantee that an implementation has <code>uintptr_t</code>, since it and <code>intptr_t</code> are optional (last sentence of &sect; 7.20.1.4).</p>

<p>Second, a function pointer is not an object pointer, and it is not necessarily possible to convert one to a void pointer and back. So even if <code>uintptr_t</code> does exist, it might not be big enough to hold a function pointer.</p>

<p>On an X/Open System Interface (XSI) compatible implementation (most Posix systems), you must be able to convert between void pointers and function pointers, and uintptr_t must exist. So in that case, you do have the guarantee. (The convertibility between void and function pointers is required by the <code>dlsym</code> system interface, which was moved from XSI to base Posix in Issue 7 (2008). However, the existence of uintptr_t continues to be an XSI extension.)</p>
",0
36267686,36266703,4,"<p>No, not in general. <code>void*</code> and in consequence <code>[u]intptr_t</code> are only guaranteed to be wide enough to hold <em>object pointers</em>, that is pointers to object types. Function pointers may, on some platforms, be wider and comprise more information than just an entry point to the function. So on such platforms a <code>void*</code> or <code>uintptr_t</code> has not enough bits to represent all information that would be needed.</p>

<p>On many platforms, function pointers have the same width as object pointers, though, and they may even allow to convert from one to another. But this is an extension of the C standard and you'd have to check with your platform documentation.</p>
",0
38497084,38496853,0,"<p>the method is calling itself recursively after subtracting one from its argument integer. so the method will run five times, first with an argument of <code>4</code>, then <code>3</code>, <code>2</code>, <code>1</code>, then <code>0</code> when it enters the <code>if</code> and ceases to call itself any more</p>
",5
38497088,38496853,0,"<p>This is because of the recursion.</p>

<p>You start by calling <code>singSongFor(4)</code>, which prints ""4 bottles of beer..."" etc. until it reaches the line <code>singSongFor(oneFewer);</code>.</p>

<p>There it calls <code>singSongFor(3)</code>, which prints ""3 bottles of beer"" and calls <code>SingSongFor(2)</code>... and then <code>singSongFor(1)</code> and lastly <code>singSongFor(0)</code>.</p>

<p><code>singSongFor(0)</code> only prints ""There are simply no bottles"" and ends,</p>

<p>then <code>singSongFor(1)</code> continues running and prints ""... 1 empty bottles..."" and ends,</p>

<p>then <code>singSongFor(2)</code> continues and prints ""2 empty bottles"",</p>

<p>then <code>singSongFor(3)</code> prints ""3 empty bottles"" </p>

<p>and finally the starting function call <code>singSongFor(4)</code> continues and prints ""4 bottles"" and ends.</p>

<p>The point of the recursion here is that when the function calls itself, it pauses and runs the newly called function and so on until it reaches a point where it doesnt make a recursive call. Then it starts going back again to the previous functions and continues them until they end.</p>
",4
38497431,38496853,0,"<p>For understanding this you have to understand recursion. Here you method</p>

<pre><code>void singSongFor(int numberOfBottles
</code></pre>

<p>is recursive method as it calls itself inside method body.So what is happening here:
when you call <code>singSongFor(4);</code> in main function.
it checks the if condition, as 4 is not equal to zero,it goes in else part and prints both <code>printf(""%d bottles of beer on the wall. %d bottles of beer.\n"",     numberOfBottles, numberOfBottles);</code>  and <code>printf(""Take one down, pass it around, %d bottles of beer on the wall.\n\n"", oneFewer);</code> but before printing the last line that you are talking about, the method calls itself <code>singSongFor(oneFewer);</code>. and the execution of <code>printf(""Put a bottle in the recycling, %d empty bottles in the bin.\n"", numberOfBottles);</code> put into a stack when number of bottles is 4 and this keep on going until numberOfBottles == 0.When this happens If part execute and the stack containing <code>printf(""Put a bottle in the recycling, %d empty bottles in the bin.\n"", numberOfBottles);</code> is popped off. At the top of stack this statment has numberOfBottles 1,next 2,next 3 and lastone 4.</p>
",2
38497656,38496853,1,"<p>Put breakpoints and try to understand execution of this snippet, you will get how it works.</p>

<p>When I tried this snippet, it will execute like :</p>

<pre><code>4 bottles of beer on the wall. 4 bottles of beer.
Take one down, pass it around, 3 bottles of beer on the wall.

3 bottles of beer on the wall. 3 bottles of beer.
Take one down, pass it around, 2 bottles of beer on the wall.

2 bottles of beer on the wall. 2 bottles of beer.
Take one down, pass it around, 1 bottles of beer on the wall.

1 bottles of beer on the wall. 1 bottles of beer.
Take one down, pass it around, 0 bottles of beer on the wall.

There are simply no more bottles of beer on the wall.

Put a bottle in the recycling, 1 empty bottles in the bin.
Put a bottle in the recycling, 2 empty bottles in the bin.
Put a bottle in the recycling, 3 empty bottles in the bin.
Put a bottle in the recycling, 4 empty bottles in the bin.
</code></pre>
",0
38497895,38496853,0,"<p>Remember! </p>

<blockquote>
  <p>To undestand recursion you have to understand recursion first.</p>
</blockquote>
",0
35213514,35213140,1,"<p>M.M is correct.
The lack of parenthesis makes the compiler prematurely end evaluation of the if statement. It would read the Line 12: ""arg &lt; 11"" then stop.</p>

<p>Also!
Don't forget to correct the spelling, some of the calls to argc were incorrectly typed as just 'arg'. ex. Line 12, ""(arg &lt; 11...""
If you submitted (to SE) your code word-for-word, this is surely one compile error.</p>
",0
35213271,35213140,1,"<p>The syntax of <code>if</code> is:</p>

<pre><code>if ( condition )
</code></pre>

<p>followed by either <code>else</code> or a statement-block.  Your code does not match this syntax, so you are getting a syntax error.</p>

<p>You could write:</p>

<pre><code>if ( (arg &lt; 11)&amp;&amp;(argc%2 == 0) )
</code></pre>

<p>optionally without the inner sets of parentheses. <code>&amp;&amp;</code> has lower precedence than the other operators involved there, but some consider it adds clarity to use the parentheses anyway.</p>
",0
39656994,39652606,1,"<p>You are writing to the wrong file descriptor in both parent and child.</p>

<p>The following line:</p>

<pre><code>fprintf(fp, ""%d"", i++);
</code></pre>

<p>should be:</p>

<pre><code>fprintf(fp1, ""%d"", i++);
</code></pre>

<p>Indeed you have already closed fp before.</p>
",0
38524254,38524021,4,"<p>You can't use the name <code>f</code> for <code>errno_t</code> as you have already used it for <code>FILE*</code>.</p>

<p>So change <code>errno_t f = fopen_s(....</code> to <code>errno_t error = fopen_s(....</code></p>
",0
37759811,37759689,1,"<p>Problem 1:</p>

<pre><code>scanf(""%c"",&amp;key);
</code></pre>

<p>is not right. It will read just one character. You need to use</p>

<pre><code>scanf(""%6s"", key);
</code></pre>

<p>Problem 2:</p>

<pre><code>    if(key==""sesame"") 
</code></pre>

<p>is not the proper way to compare two strings. It will compare two pointers and will evaluate to false. You need to use:</p>

<pre><code>    if( strcmp(key, ""sesame"") == 0 )
</code></pre>
",0
37759792,37759689,4,"<p>You cannot compare value of strings using == operator </p>

<pre><code>      if(key==""sesame"") // This compares pointers  
</code></pre>

<p>You need</p>

<pre><code>      if(strcmp(key,""sesame"") == 0)
</code></pre>

<p>See: <a href=""http://www.tutorialspoint.com/c_standard_library/c_function_strcmp.htm"" rel=""nofollow noreferrer"">http://www.tutorialspoint.com/c_standard_library/c_function_strcmp.htm</a></p>

<p>Also </p>

<pre><code>  scanf(""%c"",&amp;key);
</code></pre>

<p>will not work. %c gets only 1 character.
You need %s for string.</p>

<pre><code>int ret =  scanf(""%6s"", key); // or scanf(""%6s"", &amp;key[0]); 
if (ret &lt; 0)
     {
     // The function returns the number of input items successfully matched and assigned,
     // which can be fewer than provided for, or even zero in the event of an early matching failure.
     // The value EOF is returned if the end of input is reached before either the 
     // first successful conversion or a matching failure occurs. EOF is also returned 
     // if a read error occurs, in which case the error indicator for the stream (see ferror(3)) is set, and errno is set indicate the error.
     // see: http://linux.die.net/man/3/scanf
     }
</code></pre>

<p>Note that you need just <code>key</code> or <code>&amp;key[0]</code> as a pointer to the <code>key</code> buffer.</p>
",8
37759875,37759689,-1,"<pre><code>#include &lt;stdio.h&gt;

int main()
{
    char *a = ""sesame"";

    printf(""this program show a message if you get the correct key \n"");

    printf(""write the correct key:\n"");

    //  scanf(""%c"",&amp;key);

    if(a == ""sesame"")
    {   
        printf(""welcome to stack overflow \n""); 
    }
    else
    {
        printf(""you keep going to sleep \n"");
    }
    return 0;
}
</code></pre>
",0
38200776,38200696,1,"<p>I think your problem is because of the integer division (i.e. <code>sum_wind/13</code> and <code>sum_temp/13</code>). You should declare them as <code>float</code> or <code>double</code> variables in order to get correct division results. Integer division produces the result truncated to zero.</p>
",1
38201019,38200696,3,"<p>Computation of max and min are wrong, look at this:</p>

<pre><code>if (wind[k] &gt; maxW) {
    wind[k]=maxW;
}
</code></pre>

<p>it changes your data! Should be like:</p>

<pre><code>if (wind[k] &gt; maxW) {
    maxW=wind[k]; // stores a greater value in maxW
}
</code></pre>

<p>You also have problems with integer division, consider using doubles:</p>

<pre><code>double avgW; // declare it as a real
</code></pre>

<p>and next:</p>

<pre><code>avgW = sum/13.0; // floating division
</code></pre>

<p>But, we don't understand why you divide by 13??? Should not be a constant but the current number of read elements:</p>

<pre><code>avgW = ((double)sum)/(k+1); // convert one to double to ensure correct division
</code></pre>

<p>---EDIT---</p>

<p>You also have problems with initialization, in fact you don't initialize avg, sum, etc. You must! Initialize them as sum=0, max=less possible value, etc:</p>

<pre><code>int sum=0;
int maxW = INT_MIN;
int minW = INT_MAX;
</code></pre>

<p>etc.</p>
",3
38396095,38396018,13,"<p>When you get a new largest number, the old largest number become the second largest number. So all you need is a single check for the largest number, and two assignments.</p>

<p>Something like</p>

<pre><code>if (number &gt; largest)
{
    largest2 = largest;
    largest = number;
}
</code></pre>

<p>You still need to check for numbers larger than <code>largest2</code>.</p>
",0
38396116,38396018,1,"<p>In the following code:</p>

<pre><code>if (number &gt; largest)
    {
    largest = number;
    }
</code></pre>

<p>you throw away the known largest number, while that number should become the second largest number. So you should add the line largest2 = largest.</p>

<p>Note: By initializing largest and largest2 to zero the algorithm won't work for negative numbers.</p>
",1
38396184,38396018,1,"<p>if <code>number</code> is greater than <code>largest</code>, you should update <code>largest2</code> too, because now that you found a number greater than any previous ones, <code>largest</code> becomes the second largest number!<br/></p>

<pre><code>    if (number &gt; largest)
    {
        largest = number;
    }
</code></pre>

<p>becomes</p>

<pre><code>    if (number &gt; largest)
    {
        largest2 = largest;
        largest = number;
    }
</code></pre>
",1
38396535,38396018,3,"<p>Your logic must be refined:</p>

<ul>
<li>When you get a new largest number, you must update the second largest as well, since the previous largest number becomes the second largest.</li>
<li>Furthermore, you should initialize the largest and second largest to <code>INT_MIN</code> so you can handle negative numbers correctly.</li>
<li>You must also check the return value of <code>scanf_s()</code> and exit if the user fails to enter a number.</li>
</ul>

<p>Here is an improved version:</p>

<pre><code>#include &lt;limits.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void) {
    int number, largest = INT_MIN, largest2 = INT_MIN;

    for (int counter = 1; counter &lt;= 10; counter++) {
        printf(""Enter number %d: "", counter);
        if (scanf_s(""%d"", &amp;number) != 1) {
            printf(""input failure\n"");
            return 1;
        }
        if (number &gt; largest) {
            largest2 = largest;
            largest = number;
        } else
        if (number &gt; largest2) {
            largest2 = number;
        }
    }
    printf(""The largest number is %d\n"", largest);
    printf(""The second largest number is %d\n"", largest2);
    system(""pause"");
    return 0;
}
</code></pre>
",2
41649248,41649220,2,"<p>Most likely your file gets included multiple times, hence the redefinition error.
To avoid this problem use <a href=""https://en.wikipedia.org/wiki/Include_guard"" rel=""nofollow noreferrer""><strong>include guards</strong></a>:</p>

<pre><code>#ifndef HEADERNAME_DEFINED
#define HEADERNAME_DEFINED

// your code goes here.

#endif // HEADERNAME_DEFINED
</code></pre>

<p>or you can use non-standard preprocessor directive like <a href=""https://msdn.microsoft.com/en-us/library/4141z1cx.aspx"" rel=""nofollow noreferrer""><code>#pragma once</code></a> to do the job. It results in less code, and sometimes faster compilation speed.<br>
Put that on top of your file:</p>

<pre><code>#pragma once

// your code goes here
</code></pre>

<p><strong>Note:</strong> <em>The comment (<code>// HEADERNAME_DEFINED</code> part) after <code>#endif</code> isn't necessary. It is just a hint for programmer to know what belongs together.</em></p>
",2
40560796,40560744,2,"<p>Notice that the character <code>'0'</code> does <strong>not</strong> have the integer value <code>0</code>. See for instance <a href=""https://en.wikipedia.org/wiki/ASCII"" rel=""nofollow noreferrer"">https://en.wikipedia.org/wiki/ASCII</a></p>

<p>The integer value of the character <code>'0'</code> is normally 48. So if you read the text string ""01:23:45"", you'll end up with <code>time[0]</code> having the integer value 48, <code>time[1]</code> having the integer value 49, <code>time[3]</code> having the integer value 50  and so on.</p>

<p>Therefore you need to subtract 48 to the values in <code>time</code> in the second loop. That is normally done by: <code>time[j]-'0'</code>. </p>

<p>Try this:</p>

<pre><code>for(int i = 0, j = 0;i&lt;3;i++, j+=3){
    realtime[i] = ((time[j]-'0')*10+(time[j+1]-'0');
                   //      ^^^^               ^^^^^
}
</code></pre>
",1
38291765,38285759,0,"<p>this:  rewind(f = fopen(argv[1], ""r""));
does not rewind f.
instead it assigns a new value for f, opening the same file and rewinding it (although it has just been opened).
on some systems there is a limit to the open file descriptors you can have. why 252? i guess your limit is 256 and the kernel probably uses the remaining 4.
to fix the problem you can either close the file first, or:</p>

<pre><code>rewind(f);
</code></pre>

<p>this should work with no reassignment of f.</p>
",0
41005832,41005475,1,"<p><code>func3</code> is defined as</p>

<pre><code>void func3(struct foo *a)
</code></pre>

<p>but it is been previously declared as</p>

<pre><code>void func3(struct foo);
</code></pre>

<p>Taking a structure by value and a pointer to a structure are 2 very different things. You forgot to type the <code>*</code> before the <code>)</code>.</p>

<p>Note that <code>(*a).num</code> is exactly equivalent to <code>a-&gt;num</code> but much less readable.  Avoid cluttering your code with this kind of contorted syntax.</p>
",0
38395199,38393918,0,"<p>Let's clean up those calls a bit, first.  C does not require you to cast the result of <code>malloc</code>, and doing so is considered bad practice (C++, on the other hand, <em>does</em> require the cast, but you shouldn't be using <code>malloc</code> in C++).  Also, you can pass the dereferenced target as the operand to <code>sizeof</code>, so the basic form of any <code>malloc</code> call looks like</p>

<pre><code>T *p = malloc( sizeof *p * N );
</code></pre>

<p>This allocates enough space for <code>N</code> objects of type <code>T</code> and assigns the resulting pointer to <code>p</code>.  Each element may be accessed using <code>p[i]</code>.</p>

<p>So, in the first case, you are doing</p>

<pre><code>struct complex *ptr1 = malloc( sizeof *ptr1 * 4 );
</code></pre>

<p>This sets aside space for 4 objects of type <code>struct complex</code>, each of which is accessed as <code>ptr1[i]</code>.  That's the simpler case.</p>

<pre><code>struct complex (*ptr1)[4] = malloc( sizeof *ptr1 );
</code></pre>

<p>This sets aside space for 1 object of type <code>struct complex [4]</code> (IOW, a 4-element array of <code>struct complex</code>) and assigns the resulting pointer to <code>ptr1</code>.  Each element would be accessed as either <code>(*ptr1)[i]</code> <em>or</em> <code>ptr1[0][i]</code>.  You'd really only use this form if you were trying to allocate space for a 2-dimensional array of <code>struct complex</code>:</p>

<pre><code>struct complex (*p)[4] = malloc( sizeof *p * N );
</code></pre>

<p>This allocates space for <code>N</code> 4-element arrays, or more simply an <code>N</code>x4 array, of <code>struct complex</code>.  Each element would be accessed as <code>p[i][j]</code>.</p>
",0
36350933,36350742,2,"<p>""Generate"" doesn't mean ""print to standard output"", it means ""create in-memory state"", in other words your <code>initialiseBoard()</code> function is supposed to <em>change</em> the contents of the board array its passed, so that it becomes an initialized board (rather than a random non-initialized board).</p>

<p>The <code>printf()</code>s in your loops should be assignments to cells of <code>board</code>:</p>

<pre><code>void initialiseBoard(Cell board[BOARD_HEIGHT][BOARD_WIDTH])
{
  for (size_t y = 0; y &lt; BOARD_HEIGHT; ++y)
  {
    for (size_t x = 0; x &lt; BOARD_WIDTH; ++x)
      board[y][x] = EMPTY;
  }
}
</code></pre>

<p>This sets all cells to <code>EMPTY</code>.</p>
",0
40536750,40536690,1,"<p>If you want the value for <code>dS</code> to come out of the function modified you have to pass a pointer.</p>

<pre><code>double gen(double *dS) {

*dS=dx/100;
</code></pre>

<p>and then </p>

<pre><code>gen(&amp;dSummand);
</code></pre>
",3
40572017,40571924,1,"<p>Let us assume you keep the value of <code>numberOfTerms</code> as <code>10</code>. Then, in the <code>cosine</code> and <code>sine</code> functions, in the <code>for</code> loop, you are incrementing <code>exponent</code> by <code>2</code> every time. And, you are using the factorial of <code>exponent</code> in the denominator.</p>

<p>If the loop runs <code>9</code> times, the value for <code>exponent</code> would increase as <code>2, 4, 6, 8, 10, 12, 14, 16, 18</code>.</p>

<p>We know that <code>14! = 87178291200</code>. But a <code>signed int</code> (which is used to return the result of the factorial function) can hold a positive value up to <code>2147483647</code>. There occurs an overflow.</p>

<p>I suggest you use <code>double</code> (or even <code>unsigned long long</code>) for the return type and the parameter of the factorial function. But do not try to compute factorials of large numbers as they would not fit in any data type in C.</p>

<p>Also, since you have not defined <code>pow</code> function yourself, I think you are missing a <code>#include&lt;math.h&gt;</code> at the top.</p>

<p>Another suggestion, define <code>pi</code> as a symbolic constant rather than a global variable.</p>
",1
40572534,40571924,0,"<p>The implicit declaration of <code>pow</code> returns an int, but the actual definition returns double, the code will interpret the double an an int by bit pattern resulting in an <em>entirely</em> incorrect value - not just the integer part of the double.</p>
",0
38523598,38523391,0,"<p>You are passing a string to scanf function in line number 5 &amp; 8 and no buckets to hold the scanned/read arguments.</p>

<p>The <code>scanf</code> function's prototype is as follows:</p>

<p><code>int scanf(const char *format_string, ...);</code></p>

<p>Where the <code>format_string</code> is string containing <code>format specifiers</code> such as <code>%d, %f</code>...etc</p>

<p>And <code>""...""</code> in prototype means variable number of arguments. The arguments are buckets to hold the values that <code>scanf</code> fills by reading the <code>format_string</code>.</p>

<p>Hence the corrected lines of code should be</p>

<pre><code>line 5.  scanf(""%d %d"", &amp;a,&amp;b);
line 8.  scanf(""%d"", &amp;x);
</code></pre>

<p>Another notewothy thing is the variable arguments for <code>scanf</code> are always pointers to objects.</p>
",0
38523653,38523391,0,"<p>Syntax of scanf function is</p>

<pre><code>scanf(¡°format string¡±, argument list); 
</code></pre>

<p>So for example, change</p>

<pre><code>scanf(""%d %d, &amp;a,&amp;b"");
scanf(""%d, &amp;x"");
</code></pre>

<p>to</p>

<pre><code>scanf(""%d %d"", &amp;a,&amp;b);
scanf(""%d"", &amp;x);
</code></pre>
",0
38524720,38523391,0,"<p>first of all your input nothing to be scan from your console or any other input.</p>

<p>please check scanf() sysntax.</p>

<pre><code>#include&lt;stdio.h&gt;
int main()
{
 int a,b,c,x;
 printf(""Enter a &amp; b \n""); //printing 
 scanf(""%d %d"", &amp;a, &amp;b);
 printf(""1. add \n 2. sub \n 3. multiply \n 4. div \n 5. mod \n 6. and \n 7. or\n 8. not \n 9. xor \n"");
 printf(""Enter your choice \n"");
 scanf(""%d"", &amp;x);
 switch(x)
 {
  case 1:   c=a+b;

    break;
 case 2:  c=a-b;

    break;
 case 3:  c=a*b;

    break;
case 4:  c=a/b;

    break;
case 5:  c=a%b;

     break;
case 6:  c=a &amp;&amp; b;

     break;
case 7:  c=a || b;

      break;
case 8:  c=~a;

    break;
case 9:  c=a^b;

     break;
default: printf(""Make correct choice\n"");
}
  printf(""result is: %d"",c);
  return 0;
 }
</code></pre>
",0
38989618,38989549,1,"<p>The length argument must be <em>before</em> the data argument, so try this</p>

<pre><code>sprintf((char*)fout,""%s%0*d"", fa , flen, 0);
</code></pre>

<p>instead of</p>

<pre><code>sprintf((char*)fout,""%s%0*d"", fa , 0, flen);
</code></pre>

<p>Quote from <a href=""http://chimera.roma1.infn.it/SP/COMMON/iso-iec-9899-1990.pdf"" rel=""nofollow"">N1570</a> 7.21.6.1 The fprintf function, paragraph 5:</p>

<blockquote>
  <p>As noted above, a field width, or precision, or both, may be indicated by an asterisk. In
  this case, an int argument supplies the field width or precision. The arguments
  specifying field width, or precision, or both, shall appear (in that order) before the
  argument (if any) to be converted.</p>
</blockquote>
",0
37035382,37035341,3,"<p>Only the value matters, as long as both sides agree on the encoding.</p>

<p>So, as long as your value will fit in a short, then <code>htons()</code> or <code>htonl()</code> will work, if consistent on both sides.</p>

<p>And if it really fits in a byte, just send that, making the whole byte-order issue vanish.</p>
",7
38878268,38877960,2,"<blockquote>
  <p>assigning char pointer p as s will not reference its address rather
  its value  </p>
</blockquote>

<p>When you assign s to p you are actually assigning the address.<br>
If you wanted to assign just the value, then you would need to do something like this:</p>

<pre><code>char p; //create a char called p
p = *s; //value at p = value at s
</code></pre>

<p>But then you can't scan through the array in your while loop using p.</p>

<hr>

<blockquote>
  <p>why it prints the whole array</p>
</blockquote>

<p>%s means keep printing until you see a null character. So because p points to the first address of your string it prints the whole thing.</p>

<hr>

<blockquote>
  <p>its size is only 8  </p>
</blockquote>

<p>sizeof(s) means what is the size of the variable s. You defined s as a char pointer, so it returns the size or a char pointer (8). The function you want is:</p>

<pre><code>strlen(s);  
</code></pre>

<hr>

<p><strong>EDIT:</strong>
Fixed the first example to remove undefined behavior. </p>
",2
38880149,38877960,0,"<p>%s takes a memory address and prints the characters till it finds a null character.</p>

<p>When u initiallize a pointer at the time of declaration as in this case ""char *p = s;"" , the address of s is assigned to p and not the value.</p>

<ol>
<li><p>char *p;
 p=s; </p></li>
<li><p>char *p=s;</p></li>
</ol>

<p>Both are same things.</p>
",0
38880541,38877960,0,"<p>Under most circumstances, an <em>expression</em> of type ""N-element array of <code>T</code>"" will be converted (""decay"") to an expression of type ""pointer to <code>T</code>"", and the value of the expression will be the address of the first element of the array.</p>

<p>The exceptions to this rule are:</p>

<ul>
<li>when the array expression is the operand of the <code>sizeof</code> or unary <code>&amp;</code> operators;</li>
<li>when the array expression is a string literal used to initialize another array in a declaration (thus, the <code>""welcome back ""</code> string literal used to initialize <code>c</code> is <em>not</em> converted to a pointer expression; instead, the contents of the string literal are copied to <code>c</code>).  </li>
</ul>

<p>When you call</p>

<pre><code>len=strlen1(c);
</code></pre>

<p>the <em>expression</em> <code>c</code> is converted from type ""14-element array of <code>char</code>"" to ""pointer to <code>char</code>"", and this pointer expression is what actually gets passed to <code>strlen1</code>.  </p>

<p>In the context of a function parameter declaration, <code>T a[N]</code> and <code>T a[]</code> are treated the same as <code>T *a</code>; <code>a</code> is declared as a pointer to <code>T</code>, not an array of <code>T</code>.  This makes sense, since a function <em>cannot</em> receive an array expression as a parameter; it will have been converted to a pointer before being passed to the function.  </p>

<blockquote>
  <p>then why it prints the whole array</p>
</blockquote>

<p>That's how the <code>%s</code> conversion specifier works; it tells <code>printf</code> to start printing the sequence of characters beginning at the address specified by <code>s</code> until it sees a 0-valued byte.  </p>

<blockquote>
  <p>its size is only 8</p>
</blockquote>

<p>The type of the <em>expression</em> <code>s</code> is <code>char *</code>, so <code>sizeof s</code> is equivalent to <code>sizeof (char *)</code> (that is, the size of a pointer to <code>char</code>), so what you're displaying is the number of bytes required to store a <em>pointer</em> value, not the size of the string that <code>s</code> is pointing to.  </p>

<p>Here's a memory map of how things play out on my platform, which may help understand some of these concepts:</p>

<pre><code>           Item        Address   00   01   02   03
           ----        -------   --   --   --   --
""welcome back ""       0x400c89   77   65   6c   63    welc
                      0x400c8d   6f   6d   65   20    ome.
                      0x400c91   62   61   63   6b    back
                      0x400c95   20   00   25   64    ..%d

              c 0x7fffa9c401a0   77   65   6c   63    welc
                0x7fffa9c401a4   6f   6d   65   20    ome.
                0x7fffa9c401a8   62   61   63   6b    back
                0x7fffa9c401ac   20   00   00   00    ....

            len 0x7fffa9c401bc   00   00   00   00    ....

              s 0x7fffa9c400e8   a0   01   c4   a9    ....
                0x7fffa9c400ec   ff   7f   00   00    ....

              p 0x7fffa9c40128   a0   01   c4   a9    ....
                0x7fffa9c4012c   ff   7f   00   00    ....
</code></pre>

<p>This is the state of things at the entry to <code>strlen1</code>.  </p>

<p>The string literal <code>""welcome back ""</code> is stored starting at address <code>0x400c89</code>.  The character array <code>c</code> is stored starting at address <code>0x7fffa9c401a0</code>.  The pointer object <code>s</code> is stored starting at address <code>0x7fffa9c400e8</code> and contains the <em>address</em> of the array object <code>c</code> (x86 is little-endian, so it reads from least-signficant byte to most-significant byte).  The <em>object</em> <code>s</code> is only 8 bytes wide, which is why you got <code>8</code> as output for <code>sizeof(s)</code>.  </p>

<p>You should not use the <code>%d</code> format specifier to print a value of type <code>size_t</code> (which is what <code>sizeof</code> returns).  If you're using C99 or later, use <code>%zu</code>;  if you're using C89, use <code>%lu</code> and cast the value to <code>unsigned long</code>:</p>

<pre><code>printf( ""size of s=%zu\n"", sizeof s ); // C99 or later
printf( ""size of s=%lu\n"", (unsigned long) sizeof s ); /* C89 */
</code></pre>
",1
41217954,41217648,0,"<p>There are some points that can help in reading from a file while it is actively being written to :-</p>

<ol>
<li>You can use mmap() with MAP_SHARED in both reader and writer. This way the reader will see the changes done by the writer practically immediately.</li>
<li>Linux does not make any snapshot of the data in the file when you open the file, so you should see the changes that are being made in the file even if you just use read() and lseek().</li>
<li>In order to determine whether a file was modified/opened/accessed/etc in Linux you can use inotify API. This allows you to make your process wait for an event you're interested in until it occurs (as opposed to polling it regularly).</li>
<li>tail(), to find a tail of a file. </li>
</ol>

<p>A small snippet can work for you: here in this example we are reading and writing at the same time.</p>

<pre><code>read_pos = write_pos = 0;
while ((val1 = fgetc(file_descriptor)) != EOF) {
    read_pos = ftell(file_descriptor);
    fseek(file_descriptor, write_pos, SEEK_SET);
    if (('a' &lt;= val1) &amp;&amp; (val1 &lt;= 'z')) {
      fputc(val1 - 32, file_descriptor);
    } else {
      fputc(val1, file_descriptor);
    }
    write_pos = ftell(file_descriptor);
    fseek(file_descriptor, read_pos, SEEK_SET);
  }
  fclose(file_descriptor);
  return (0);
}
}  
</code></pre>
",0
41217871,41217648,0,"<p>you can count the rows that you have already read and after 5 seconds you can read from next line.</p>

<pre><code>void GotoLine(std::fstream&amp; file, unsigned int num){
    file.seekg(std::ios::beg);
    for(int i=0; i &lt; num - 1; ++i){
        file.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(),'\n');
    }
    string line;
   file&gt;&gt;line;
   cout&lt;&lt;line&lt;&lt;endl; //printing the new line data
}
</code></pre>
",0
41221990,41217648,1,"<p>This should work :</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;//To use the sleep function under UNIX

int main(void)
{
    FILE *f;
    int i;
    char line[1024];

    f = fopen(""yourfile"", ""r"");

    i = 0;
    while(fgets(line, 1024, f) != NULL)
    {
        //You can use your line here
        i++; //'i' is the number of line
    }

    fclose(f);
    sleep(5);//This line may change on windows

    f = fopen(""yourfile"", ""r"");//Reopen your file after modification

    while(i != 0)//We skip the line we already used
    {
        fgets(line, 1024, f);
        i--;
    }

    while(fgets(line, 1024, f) != NULL)//Here are the new line
    {
        //You can use your new line here
    }

    fclose(f);
    return 0;
}
</code></pre>
",4
37113641,37112255,1,"<p>The problem is the function:</p>

<pre><code>Void
SolvePrecondMatrix(double *Bloc_Precond_Matrix, double *HVector, 
        double *Bloc_Residue_Vector, int Bloc_VectorSize)
</code></pre>

<p>It should have been:</p>

<pre><code>void
SolvePrecondMatrix(double *Bloc_Precond_Matrix, double *HVector, 
        double *Bloc_Residue_Vector, int Bloc_VectorSize)
</code></pre>

<p>That is, you mistakenly capitalized <code>void</code> to <code>Void</code>.</p>
",0
41004348,41004046,3,"<p>The third parameter to the function doesn't match what the function is expecting.  You're passing in a <code>char []</code> (which decays to a <code>char *</code>), while the function expects <code>char *[]</code> (equivalently <code>char **</code> as a function parameter).</p>

<p>The definition of the third parameter doesn't match how you intend to use it, which is as a character array.</p>

<p>Get rid of the extra level of indirection on the parameter, and adjust the function accordingly.</p>

<pre><code>int In2File(int argc, char *argv[], char temp[] ){
        ...
        while ((c = fgetc(user_file)) != EOF &amp;&amp; g &lt;= tmplng - 1) { 
            temp[g] = c; 
            g++;  
        }
</code></pre>
",2
41004458,41004046,0,"<p>This declaration of <code>temp</code>:</p>

<blockquote>
<pre><code>char temp[tmplng];
</code></pre>
</blockquote>

<p>... does not go with this call ...</p>

<blockquote>
<pre><code>In2File(argc,argv,temp);
</code></pre>
</blockquote>

<p>... to this function ...</p>

<blockquote>
<pre><code>int In2File(int argc, char *argv[], char *temp[] );
</code></pre>
</blockquote>

<p>The function expects its third argument to be a pointer to a pointer to <code>char *</code>, but what it receives is a pointer to <code>char</code>.  When it then tries to assign the character read ...</p>

<blockquote>
<pre><code>    *temp[g] = c;
</code></pre>
</blockquote>

<p>That attempts to interpret the <code>g</code><sup>th</sup> element of <code>temp</code> (itself interpreted as a <code>char **</code>) as a <code>char *</code>, to <em>dereference</em> that pointer, and to assign <code>c</code> to that location.  That is highly unlikely to be a valid memory access.</p>

<p>It looks like you want to declare the third argument of <code>In2File</code> as either <code>char *temp</code> or <code>char temp[]</code>, which are equivalent, and to write to it as <code>temp[g] = c</code>.</p>

<p>ALSO, as an aside, note that your</p>

<blockquote>
<pre><code>printf(""%s\n"", temp);
</code></pre>
</blockquote>

<p>is problematic because you do not ensure that <code>temp</code> is null-terminated.  And inasmuch as you support reading up to the very last byte, you don't have room to terminate it.</p>
",1
41004717,41004046,0,"<p>As numerous folks are pointing out in the comments, your code would be much easier to understand if you employed ""early exit"" for your error conditions.</p>

<p>It would also be a better separation of concerns to have <code>main</code> deal with the program arguments and let <code>In2File</code> just deal with a file pointer.</p>

<pre><code>int main( int argc, char *argv[] ) {
    FILE *fp;

    if( argc == 2 ) {
        fp = fopen(argv[1], ""r"");
        if ( fp == NULL ) {
            fprintf(stderr, ""Couldn't open %s: %s"", argv[1], strerror(errno));
            exit(2);
        }
    }
    else if( argc &gt; 2 ) {
        fprintf(stderr, ""Usage: %s &lt;optional filename&gt;"", argv[0]);
        exit(1);
    }
    else {
        fp = stdin;
    }

    char *lines = In2File(fp);

    printf(""%s\n"", lines);

    free(lines);
}
</code></pre>

<p>Note that <code>stdin</code> is a file pointer just like anything you opened with <code>fopen</code>. I've also used <code>strerror</code> and <code>errno</code> to provide the reason the file didn't open.</p>

<p>Now <code>In2File</code> just takes a file pointer. Also note that I have it returning the content, not passing in a preallocated array. This is because when reading from input you never know how much input you're going to get. You either must stop reading before you run out of space, or allocate more memory. You can't reallocate stack memory, so it's best to let <code>In2File</code> control allocating memory. It also avoids having to pass around a global variable.</p>

<p>Once that's done, <code>In2File</code> becomes much simpler.</p>

<pre><code>static char *In2File( FILE *fp ){
    size_t read_size = 1024;

    /* Don't forget space for null */
    char *content = calloc( read_size + 1, sizeof(char) );

    fread( content, sizeof(char), read_size, fp );

    return content;
}
</code></pre>

<p>Rather than step through a character at a time, I've used <code>fread</code> to read a block from the file not larger than the amount I've allocated. Memory reallocation is a topic for another time.</p>
",1
47691824,47691628,0,"<p>Hint: You have to clear the the consonant and vowel counts after increment the other (e.g <code>{c_vwl++;c_cnsnt=0;}</code>), not when they are equal, and always tests your BAD condition.</p>

<p>I will not give you a sample code. Good luck</p>
",4
45116203,45115968,1,"<p>The call to <code>printf()</code> is expecting a null-terminated string, yet the <code>copy()</code> function is not providing one.</p>

<p>Change the first loop in <code>copy()</code> so that the array index <code>i</code> is checked, to avoid buffer overflow, and then add a null-terminator after the loop terminates:</p>

<pre><code>// check array index
while(i &lt; MAXLINE-1 &amp;&amp; (c = getchar()) != EOF)
{
    from[i] = c;
    ++i;
}

// add null-terminator to from[]
from[i] = '\0';
</code></pre>

<p>Then change the second loop so that it terminates when the null-terminator is encountered, and add a <code>\0</code> character to the end of <code>to[]</code>:</p>

<pre><code>// change loop termination condition
while((to[a] = from[a]) != '\0')
    ++a;

// add null-terminator to to[]
to[a] = '\0';
</code></pre>

<p>Better, use the saved value of <code>i</code> to terminate the loop, and copy the <code>\0</code> from <code>from[]</code> to <code>to[]</code>:</p>

<pre><code>// better, use i to terminate loop
for (a = 0; a &lt;= i; a++)
    to[a] = from[a];
</code></pre>

<p>In my first version of the above loop, I inadvertently used <code>for (a = 0; a &lt; i; a++) {}</code>, caught by @alk. This loop fails to copy the final <code>\0</code> character, since when <code>a == i</code>, the loop terminates without executing the body. The quick fix above, changing <code>a &lt; i</code> to <code>a &lt;= i</code> works, but the loop is no longer idiomatic (hence my initial trouble; I write <code>a &lt; i</code> in loops by reflex). A possibly better solution would be to increment <code>i</code> after the <code>\0</code> character is stored in <code>from[]</code>, just as has been done for every other character in <code>from[]</code>. This is illustrated in the final code below.</p>

<p>Additionally, note that the function signature for <code>main()</code> should be <code>int main(void)</code>, and since <code>copy()</code> is declared as returning <code>void</code>, there should be no value <code>return</code>ed at the end of the function. And, to be truly correct, the types of array indices should be <code>size_t</code>, which is an <code>unsigned</code> integer type guaranteed to be able to hold any array index.</p>

<pre><code>#include &lt;stdio.h&gt;

#define MAXLINE 1000

void copy(char to[], char from[]);

int main(void)
{
//    int length;
//    int limit;
    char saved[MAXLINE];
    char len[MAXLINE];

    copy(saved,len);

    printf(""%s"", saved);

    return 0;
}

void copy(char to[],char from[])
{
    size_t a,i;
    int c;

    i = 0;
    a = 0;

    // check array index
    while(i &lt; MAXLINE-1 &amp;&amp; (c = getchar()) != EOF)
    {
        from[i] = c;
        ++i;
    }

    // add null-terminator to from[], increment i
    from[i] = '\0';
    ++i;

    // use i to terminate copy loop
    for (a = 0; a &lt; i; a++)
        to[a] = from[a];
}
</code></pre>
",3
35282726,35282717,0,"<p>Missing a <code>{</code> after <code>while (day&lt;32)</code>.</p>
",0
35284923,35282717,0,"<p>Missing <code>{</code> after <code>while</code> and <code>}</code> after <code>return 0;</code></p>

<pre><code>int main()
{
  int day = 1;
  float penny = 0.01;
  while (day&lt;32)
  {
     printf(""On Day %d you had %f dollars"",day, penny);
    penny *=2;
    day++;

  }

  return 0;
}
</code></pre>
",0
47503469,47503394,1,"<p>Deleting a file does not necessarily actually ""remove"" it. The things that happen is that the reference to the file is destroyed. It is a bit like pointers. You can compare your code to this:</p>

<pre><code>void delete(int ** ptr)
{
    *ptr=NULL;
}

int main()
{
    int a=5;
    int p1=&amp;a;
    int p2=&amp;a;
    delete(p1);  // Pretty much equivalent to deleting a file
    printf(""a: %d\n"", *p1);  // We can still access it through a another pointer
}
</code></pre>
",0
47503500,47503394,3,"<p>It's OS/implementation dependent. On Linux, the file is actually ""pending for deletion"", meaning that since the file is opened, the kernel ""waits"" for the file to be closed before to actually free the space taken by the file.</p>

<p>Doing <code>lsof</code>  (maybe extend the <code>sleep</code> to give you time to do that)</p>

<pre><code>lsof | grep file
</code></pre>

<p>shows that your program processes maintains the file opened (<a href=""https://linux.die.net/man/8/lsof"" rel=""nofollow noreferrer"">lsof man page</a>).</p>
",0
42531337,42530758,1,"<ol>
<li>Subtract the mean value from each element.</li>
<li>Take the absolute value of the result. </li>
<li><p>Store the position and element which have lowest difference.</p>

<pre><code> int fnFindClosestVal(int arn2DArray[][6], int nRows, int nCols, double nTotal, int *posRow, int *posCol)
    {
        int nClosestValue = arn2DArray[0][0];
        int nDiff = abs(arn2DArray[0][0] - nTotal);
        int Row,Col;

        for (nCountRows = 0; nCountRows &lt; nRows; nCountRows++)
        {
            for (nCountCols = 0; nCountCols &lt; nCols; nCountCols++)
            {
                    if(abs(arn2DArray[nCountRows][nCountCols] - nTotal) &lt; nDiff)
                     {
                        nDiff = abs(arn2DArray[nCountRows][nCountCols] - nTotal);
                        nClosestValue = arn2DArray[nCountRows][nCountCols];
                        *posRow = nCountRows;
                        *posCol = nCountCols;
                     }
            }
        }
    return nClosestValue;
}
</code></pre></li>
</ol>
",5
37288050,37287412,1,"<p>Perhaps an approach like the following which uses loops with arrays would be shorter and more compact. This is a fairly straightforward transformation that consolidates separate variables into arrays. This does use an array of function pointers (see <a href=""https://stackoverflow.com/questions/840501/how-do-function-pointers-in-c-work"">How do Function pointers in C work</a>).</p>

<p>The <code>do_file_1()</code>, <code>do_file_2()</code>, etc. functions are just place holders for the actual functions you are using. This keeps the literal file names (""F1"", ""F2"", etc.) that you specify though I am not sure why you are requiring certain, specific file names.</p>

<p>I also use the <code>strcpy()</code> function to copy the file name argument into the array of file names to open rather than using the <code>sprintf()</code> function.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;io.h&gt;
#include &lt;string.h&gt;

void do_file_1 (FILE *fp)
{
    printf (""function do_file_1 called.\n"");
}
void do_file_2 (FILE *fp)
{
    printf (""function do_file_2 called.\n"");
}
void do_file_3 (FILE *fp)
{
    printf (""function do_file_3 called.\n"");
}
void do_file_4 (FILE *fp)
{
    printf (""function do_file_4 called.\n"");
}

int main(int argc, char **argv)
{
    int   i;
    char  *fileArray[4] = { ""F1"", ""F2"", ""F3"", ""F4""};
    char  fname[4][64] = {0};
    void  (*funcs[4]) (FILE *fp) = {do_file_1, do_file_2, do_file_3, do_file_4};

    for( i = 1; i &lt; argc; i++) {
        int  j;
        for (j = 0; j &lt; 4; j++) {
            if ( strcmp(argv[i], fileArray[j]) == 0 ) {
                strcpy(fname[j],argv[i]);
                break;
            }
        }
    }

    if( !(fname[0][0] &amp;&amp; fname[1][0] &amp;&amp; fname[2][0] &amp;&amp; fname[3][0]) ) {
        printf(""Must input four files!!\n"");
        exit(-1);
    }

    for (i = 0; i &lt; 4; i++) {
        if (access(fname[i],0) == 0) {
            FILE *fp = fopen(fname[i],""r"");
            if (fp != NULL) {
                funcs[i](fp);
                fclose(fp);
            } else {
                break;
            }
        } else {
            break;
        }
    }
    if (i &lt; 4) exit(-1);

    return 0;
}
</code></pre>
",5
39652541,39652529,0,"<p>It returns <code>0</code> in this case. The <code>scanf()</code> function returns the number of matched format specifiers. In this case, none matched and hence it returns <code>0</code>.</p>

<p>If you initialize <code>number</code> before calling <code>scanf()</code> and it then fails returning <code>0</code>, the value you used to initialize <code>number</code> doesn't change after the call to <code>scanf()</code>.</p>

<p>If you don't initialize <code>number</code>, then trying to read the value is <em>undefined behavior</em>. It will have an undeterminate value so you can't predict which value it will be.</p>
",1
39652587,39652529,4,"<p><code>scanf(""%d"",&amp;minutes)</code> will not read the value of the character. The value in <code>minutes</code> will be unchanged. The character will remain in the buffer and scanf will keep trying to read it and keep failing.</p>

<p>The return value of <code>scanf</code> will be the number of elements read, so it will be 0 if you feed in a character, and that can be used to break the loop.</p>

<pre><code>do
{
  printf(""minutes: "");
  ret = scanf(""%d"", &amp;minutes);
  if (ret != 1)
     break;
}while(minutes &lt; 1);
</code></pre>
",0
38520479,38520252,2,"<p>You are passing a pointer (<code>int*</code>) to <code>disp()</code>. Inside of <code>disp()</code> you pass a pointer to that pointer (<code>int**</code>) to <code>show()</code>.</p>

<p>Just pass the pointer and not the address of it:</p>

<pre><code>int disp(int *n){
    show(n);
    return 0;
}
</code></pre>
",0
38522053,38520252,1,"<p>YOu have to catch with double pointer in Show()function,</p>

<p>disp(&amp;marks[i]) send the address of that and it be catch with pointer now u r trying to send address insted of data so u have to catch with double pointer like this</p>

<pre><code>#include&lt;stdio.h&gt;
int show( int **m);
int disp(int *n);

int main()
{
int i;
int marks[]={55,65,70,75,78};
for(i=0;i&lt;4;i++)
{
disp(&amp;marks[i]);
return 0;
}
}
int disp(int *n)
{
show(&amp;n);
return 0;
}
int show(int **m)
{
printf(""%d\n"", **m);
return 0;
}
</code></pre>
",0
40969025,40968987,3,"<p>You are returning the address of a local variable. When you leave the function your code does not know this variable anymore, thus the segmentation fault.
You would have to give a pointer to this function as a parameter or dynamically create memory for this variable in the heap.</p>

<p>e.g.</p>

<pre><code>void g(int* p) {
  *p = 10;
}

int main() {
  int a;
  g(&amp;a);
  printf(""%d"", a);
  return 0;
}
</code></pre>

<p>or </p>

<pre><code>int* g() {
  int* p = (int*) malloc(sizeof(int));
  *p = 10;
  return p; 
}

int main() {
  int* p;
  p = g();
  printf(""%d"", *p);
  free(p)
  return 0;
}
</code></pre>
",2
48027813,48027797,5,"<p>This is <a href=""http://www.difranco.net/compsci/C_Operator_Precedence_Table.htm"" rel=""nofollow noreferrer""><strong>precedence</strong></a> issue.(Array subscript <code>[]</code> has higher precedence than dereference <code>*</code>). You should try </p>

<pre><code>(*str)[1]
</code></pre>

<p>This will give you the correct result. In earlier case (In Code-2) you had <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer""><strong>undefined behavior</strong></a>. You were de-referencing <code>str[1]</code> which is pointing to out of bound memory. </p>

<p>So initially what you were doing in Code-2</p>

<pre><code>*str[1] --&gt; *(*(str+1))
</code></pre>

<p>Now what we did,</p>

<pre><code>(*str)[1] --&gt; *((*str)+1)
</code></pre>

<p>Well in the modification you are basically getting the address of the array (string literals are array which decayed into pointer) and then you index into correct position - which will give you the correct result.</p>

<hr>

<p>Well if you check earlier example you will see the similarity. Earlier code  (Code-1) you print <code>temp[1]</code> which is <code>*(temp+1)</code> But what is <code>temp</code>? In the line before you did this <code>temp = *str</code> so what is it you are  doing?</p>

<pre><code>*(temp+1) --&gt; *(*str+1) --&gt; *((*str)+1)
</code></pre>
",2
43952625,43952283,1,"<p>this is because when there are 'abc' the code will everytime increase success.
try with:</p>

<pre><code>    #include &lt;stdio.h&gt;

int main()
{
    char n1 = 0;
    char n2 = 0;
    char n3 = 0;
    char n4 =0;//Added
    char test = 0;
    int success = 0;
    int total = 0;
    int count = 3;
    double result = 0;//changed from int to double
    printf(""Please enter word to check\n"");//Added
    while (1)
    {
        test = getchar(); //take this out
        if(test == '$'){
          if (n1 == 'a' &amp;&amp; n2 == 'b' &amp;&amp; n3 == 'c' &amp;&amp; count == 3)success++; //check if there is another seq before exit
          break;
        }
        printf(""check %c:\n"", test);//Only for debug
        if (test == '#')
        {
           if (n1 == 'a' &amp;&amp; n2 == 'b' &amp;&amp; n3 == 'c' &amp;&amp; count == 3) success++;
           n1 = 0;
           n2 = 0;
           n3 = 0;
           count = 0;
           total++;
        }else
            {
                n1 = n2;
                n2 = n3;
                n3 = test;
                count++;
            }

    }
    result = (double)success/total;//casted to double
    printf(""%.2f"", result);//changed to %.2f instead of %d, 2 digit only after decimal point
    return 0;
}
</code></pre>
",0
42541516,42541329,1,"<p>From your code seems that you want to swap the last two elements from your array that are 0,0
Your array of 5 element is initialized with 1,2, 3, 0,0
When you call swap function with the address of 'third' element which is actually the fourth element of array you basically swap the 4th and 5th element of array and you actually print the 2nd element of array  </p>
",1
42541696,42541329,2,"<p>The <code>reverse_array</code> function works fine, but you don't call it correctly in main:</p>

<p>You want this:</p>

<pre><code>int main() {
  int arr[] = { 1,2,3 };
  reverse_array(arr, 3);

  int i;
  for (i=0;i &lt; 3;i++) {
    printf(""%d\n"", arr[i]);
  }
}
</code></pre>

<p>There are 3 problems in your code:</p>

<pre><code>// here you declare an array of size 5 but you only initialize the first 3 elements
//This is not actually a problem in first place
int arr[5] = {1,2,3};     

// &amp;arr[3] is the address of 4th element of the array, which has not
// been initialized, This actually swaps arr[3] with arr[4]
reverse_array(&amp;arr[3], 2);

// here you print the second element which has not been modified
// at all by the reverse_array(&amp;arr[3], 2);
printf(""%d\n"", arr[1]);
</code></pre>

<p>As already mentioned, the XOR swap stuff is old fashioned and works only for integral types.</p>
",1
42541622,42541329,0,"<p>All the comments and answers need to be understood so you learn what mistakes you made. With that being said, I re-worked your code just a bit to make it work. Please study the differences and ask questions...</p>

<pre><code>#include &lt;stdio.h&gt;

/*** Prototypes - get in the habit of using them ***/
void inplace_swap(int *x, int *y);
void reverse_array(int *a, int cnt);
/***************************************************/

#define NUM_ELEMENTS(x)     (sizeof(x)/sizeof(x[0]))    

void inplace_swap(int *x, int *y)
{
    if (*x!=*y)
    {
        printf(""Doing swap...\n"");
        *y = *x ^ *y; 
        *x = *x ^ *y; 
        *y = *x ^ *y; 
    }
}

void reverse_array(int *a, int cnt)
{
    int first, last;

    for (first = 0, last = cnt-1; first &lt;= last; first++, last--)
    {
        inplace_swap(&amp;a[first], &amp;a[last]);
    }
}

int main()
{
    int arr[] = {1,1,2};

    reverse_array(arr, NUM_ELEMENTS(arr));

    for ( int i = 0; i &lt; NUM_ELEMENTS(arr); ++i )
    {
        printf(""%d "", arr[i]);
    }
    printf(""\n"");

    return(0);
}
</code></pre>
",7
42541668,42541329,1,"<p>This code works well:</p>

<pre><code>#include &lt;stdio.h&gt;

static void inplace_swap(int *x, int *y){
   if( x != y ) {
      *y = *x ^ *y;
      *x = *x ^ *y;
      *y = *x ^ *y;
   }
}

static void print_array( int arr[], size_t count ) {
   size_t i;
   for( i = 0; i &lt; count; ++i ) {
      printf( ""%s%d"", i ? "", "" : """", arr[i] );
   }
   printf( ""\n"" );
}

static void reverse_array( int a[], int cnt ) {
   int first, last;
   for( first = 0, last = cnt-1; first &lt;= last; first++, last-- ) {
      inplace_swap(&amp;a[first], &amp;a[last]);
   }
}

int main() {
   int arr[] = { 1, 2, 3, 4, 5 };
   size_t count = sizeof(arr)/sizeof(arr[0]);
   print_array  ( arr, count );
   reverse_array( arr, count );
   print_array  ( arr, count );
}
</code></pre>

<p>Execution trace:</p>

<pre><code>1, 2, 3, 4, 5
5, 4, 3, 2, 1
</code></pre>
",0
40986358,40986259,2,"<p>your code is perfect except || in the 'if' condition. || returns true if at least one condition is true. When menSelect is equal to 1, it is not equal to 2 and hence, 'if' condition evaluates to true. Using &amp;&amp; solves the problem. If menSelect equals to 1, then the 'if' condition fails and evaluates to false</p>

<pre><code>if(menSelect!=1 &amp;&amp; menSelect!=2){
        fprintf(stderr,""%s, %d Is Not a Valid Selection\nPlease Try Again\n"",name,menSelect);
    }
</code></pre>

<p>Hope it helps!</p>
",1
42549938,42549605,0,"<p>In binary level, <code>float</code> and <code>int</code> don't look alike at all.</p>

<p>When trying to copy a <code>float</code> into a <code>int</code>, there's an implicit conversion, that's why when you call a function that takes <code>int</code> as argument but you provide a <code>float</code> you get the integer part of it, but in the final test you get to see how ugly it really look like. That's no garbage, that's how a <code>float</code> looks like in memory if you'd print it in hexadecimal. See <a href=""https://en.wikipedia.org/wiki/IEEE_floating_point"" rel=""nofollow noreferrer"">IEEE 754</a> for details.</p>

<p>The issue with <code>p1()</code> however is that you are trying to call a function that has not been declared, so it's automatically declared as <code>int p1()</code>. Even though you later define it as <code>void p1(unsigned int tmp)</code>, it has already been declared as <code>int p1()</code> (not taking any parameters) so it doesn't work (behavior is undefined). I'm pretty sure the compiler is screaming with warnings and errors about that, those errors aren't meant to be ignored.</p>

<p>Notice there's a big difference between declaring and defining a function. It is perfectly legal to define a function later, the way you are doing, but if you want it to work properly it has to be declared before any attempt to use it.</p>

<p>Example:</p>

<pre><code>// declare functions
void p1(unsigned int tmp);
void p2(unsigned int tmp);

// use functions
int main()
{
    p1(1);
    p2(1);
}

// define functions
void p1(unsigned int tmp)
{
    // do stuff
}
void p2(unsigned int tmp)
{
    // do stuff
}
</code></pre>
",0
42549951,42549605,3,"<p>The C programming language is essentially a single-scan language - a compiler doesn't need to reread the code but it can assemble it line by line, retaining information only on how identifiers were declared.</p>

<p>The C89 standard had the concept of implicit declaration. In absence of a declaration, the function <code>p1</code> is declared implicitly as <code>int p1()</code>; i.e. a function that returns an <code>int</code> and takes unspecified arguments that go through default argument promotions. When you call such a function giving it a <code>float</code> as an argument, the float argument is promoted to a <code>double</code>, as called for by default argument promotions. It would be fine if the function was <code>int p1(double arg)</code>; but the expected argument type is <code>unsigned int</code>, and the return value is not compatible either (<code>void</code> vs <code>int</code>). This mismatch will cause the program to have <em>undefined behaviour</em> - there is no point in reasoning what is happening then. However, there are many old C programs that would fail to compile, if the compilers wouldn't support the archaic implicit declarations - thus you just need to consider all these warnings as errors.</p>

<p>Notice that if you change the <strong>return value</strong> of <code>p1</code> into an <strong><code>int</code></strong>, you will get less warnings:</p>

<pre><code>% gcc implicit.c
implicit.c:14:5: warning: implicit declaration of function ¡®p1¡¯ [-Wimplicit-function-declaration]
 p1(fvar);
 ^~
</code></pre>

<p>But the observed behaviour on my compiler would be mostly the same.</p>

<p>Thus the presence of mere <strong>warning: implicit declaration of function ¡®x¡¯</strong> is quite likely a <strong>serious error</strong> in newly written code.</p>

<p>Were the function declared before its use, as is case with <code>p2</code>, then the compiler knows that it expects an <code>unsigned long</code> as the argument, and returns <code>void</code>, and therefore it would know to generate correct conversion code from <code>float</code> to <code>unsigned long</code> for the argument.</p>

<hr>

<p>The C99 and C11 do not allow implicit function declarations in strictly-conforming programs - but they also do not require a conforming compiler to reject them either. C11 says:</p>

<blockquote>
  <p>An identifier is a primary expression, provided it has been declared as designating an object (in which case it is an lvalue) or a function (in which case it is a function designator).</p>
</blockquote>

<p>and a footnote noting that</p>

<blockquote>
  <p>Thus, an undeclared identifier is a violation of the syntax.</p>
</blockquote>

<p>However, it doesn't require a compiler to reject them.</p>
",3
42549727,42549605,2,"<p>This,</p>

<pre><code>void p1(unsigned int tmp);
</code></pre>

<p>would be <a href=""https://stackoverflow.com/a/9182835/1983495"">implicitly declared</a> as</p>

<pre><code>int p1();
</code></pre>

<p>by the compiler.</p>

<p>Although the compiler does not throw an error, it should be considered one as you can read in the linked post.</p>

<p>In any event, this is undefined behavior and you can't expect a predictable output.</p>
",1
34966647,34959596,1,"<h2>First Pass</h2>

<p>When I take your code, add <code>void</code> to <code>int main()</code> to get it past my compilation options, and reformat the code so it is indented more or less orthodoxly, then I get no compilation warnings.  For that, you have my compliments; very few programs shown on SO need so little editing to get past my default compilation options:</p>

<pre><code>gcc -O3 -g -std=c11 -Wall -Wextra -Wmissing-prototypes -Wstrict-prototypes \
    -Wold-style-definition -Werror -c test.c
gcc -O3 -g -std=c11 -Wall -Wextra -Wmissing-prototypes -Wstrict-prototypes \
    -Wold-style-definition -Werror -c AVL_tree.c
gcc -g -o avl test.o AVL_tree.o
</code></pre>

<p>When I then run it under <a href=""http://valgrind.org/"" rel=""nofollow""><code>valgrind</code></a>, then I get told:</p>

<pre><code>starting insert 1000000 elements with increment 500000 in next round
inserting 0 
inserting 6 
inserting 1 
double right left rotating 
==47254== Invalid read of size 8
==47254==    at 0x100000FB5: right_rotate (AVL_tree.c:54)
==47254==    by 0x10000159E: insert (AVL_tree.c:138)
==47254==    by 0x100001AB6: main (test.c:20)
==47254==  Address 0x18 is not stack'd, malloc'd or (recently) free'd
==47254== 
==47254== 
==47254== Process terminating with default action of signal 11 (SIGSEGV)
==47254==  Access not within mapped region at address 0x18
==47254==    at 0x100000FB5: right_rotate (AVL_tree.c:54)
==47254==    by 0x10000159E: insert (AVL_tree.c:138)
==47254==    by 0x100001AB6: main (test.c:20)
</code></pre>

<p>In your code as formatted, line 54 is the <code>struct vertex *tmp</code> line at:</p>

<pre><code>        (*v)-&gt;p-&gt;l = (*v)-&gt;l;
    else
        (*v)-&gt;p-&gt;r = (*v)-&gt;l;
}
struct vertex  *tmp = (*v)-&gt;l-&gt;r;
(*v)-&gt;l-&gt;r = (*v);
(*v)-&gt;l-&gt;p = (*v)-&gt;p;
(*v)-&gt;p = (*v)-&gt;l;
(*v)-&gt;l = tmp;
if (tmp != NULL)
    tmp-&gt;p = (*v);
</code></pre>

<p>The address 0x18 strongly suggests you have dereferenced a null pointer.  It is a small offset from NULL and on a 64-bit machine, address offset 0x18 corresponds to <code>r</code> in the structure, I think.  At any rate, it appears that your code has not taken into account a null pointer somehow.</p>

<p>Another run produced:</p>

<pre><code>starting insert 1000000 elements with increment 500000 in next round
inserting 6 
inserting 2 
inserting 3 
double left right rotating 
 p is not NULL
p's l  == v
WTF r != NULL r 0x100aa85d0 p 0x100aa84f0 p-&gt;l 0x100aa8560 (*v) 0x100aa8560 
WTF r == NULL r 0x0 p 0x100aa8560 p-&gt;l 0x0 (*v) 0x100aa85d0 
get there before
r == NULL
==47387== Invalid read of size 8
==47387==    at 0x100001134: left_rotate (AVL_tree.c:99)
==47387==    by 0x10000157F: insert (AVL_tree.c:128)
==47387==    by 0x100001AB6: main (test.c:20)
==47387==  Address 0x10 is not stack'd, malloc'd or (recently) free'd
==47387== 
==47387== 
==47387== Process terminating with default action of signal 11 (SIGSEGV)
==47387==  Access not within mapped region at address 0x10
==47387==    at 0x100001134: left_rotate (AVL_tree.c:99)
==47387==    by 0x10000157F: insert (AVL_tree.c:128)
==47387==    by 0x100001AB6: main (test.c:20)
</code></pre>

<p>Again, that suggests a null pointer dereference.</p>

<p>I recommend adding a bunch of assertions checking that all the pointers you think can't be null actually aren't null ¡ª some of them, it appears, are in fact null.</p>

<p>I also recommend using a different <code>main()</code> program.  Keep the current one for later, when things are mostly working and you want to stress test the code.  For now, you want a simple deterministic program.  You should try inserting the sequences <code>0, 6, 1</code> and <code>6, 2, 3</code> and see whether you get a crash.  If so, you can debug them, and look for parallel problems in the code.  (Another, longer sequence that crashed at the same point as the second crash was <code>3, 4, 1, 1, 4, 3, 1, 7, 5, 1, 7</code>; and another was <code>4,  5,  4,  3,  2,  2,  4,  2,  5,  0,  2</code>.)</p>

<p>I note that your header should not itself include any other headers.  A header should only include those other headers that are necessary to make the code within compilable on its own.  Your structure doesn't use any features defined in <code>&lt;stdio.h&gt;</code>, <code>&lt;stdlib.h&gt;</code> or <code>&lt;assert.h&gt;</code>, so none of those headers should be included there.  You don't actually have any assertions in the posted code, but the other two headers are needed in the implementation code and <code>&lt;stdio.h&gt;</code> is needed in the test code; but they should included directly.</p>

<p>Note that when debugging with assertions, make independent assertions.  If you write:</p>

<pre><code>assert((*v) != NULL &amp;&amp; (*v)-&gt;r != NULL);
</code></pre>

<p>and the assertion fires, you can't tell which of the two conditions failed.  Use independent assertions:</p>

<pre><code>assert((*v) != NULL);
assert((*v)-&gt;r != NULL);
</code></pre>

<p>but sequence them like that ¡ª not the reverse.  This tells you which of the two conditions is erroneous.</p>

<h2>Second Pass</h2>

<p>I added some instrumentation to your code in  <code>AVL_tree.c</code>, using the formatting available in <code>&lt;inttypes.h&gt;</code> to format pointers according to my prejudices, rather than letting the <code>%p</code> format do it for me (it prints null pointers as <code>0x0</code> instead of using a similar width to other pointers ¡ª not what I want for readable output; using <code>%.9</code> is a hack that works on this 64-bit machine [Mac OS X 10.11.3, GCC 5.3.0]; stack addresses are about 12 hex digits wide, so it is potentially flaky formatting).  And I created a minimal deterministic test program, <code>avl2.c</code>.</p>

<h3><code>AVL_tree.c</code></h3>

<pre><code>#include ""AVL_tree.h""
#include &lt;assert.h&gt;
#include &lt;inttypes.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

static void dump_vertex(const char *tag, struct vertex *v)
{
    if (v == NULL)
        printf(""%s: data  ; height  ; v = 0x%.9"" PRIXPTR ""\n"", tag, (uintptr_t)v);
    else
        printf(""%s: data %d; height %ld; v = 0x%.9"" PRIXPTR "", l = 0x%.9""
               PRIXPTR "", r = 0x%.9"" PRIXPTR "", p = 0x%.9"" PRIXPTR ""\n"",
               tag, v-&gt;data, v-&gt;height, (uintptr_t)v, (uintptr_t)v-&gt;l,
               (uintptr_t)v-&gt;r, (uintptr_t)v-&gt;p);
}

static void dump_tree_inorder_notag(const struct vertex *v)
{
    if (v != NULL)
    {
        dump_tree_inorder_notag(v-&gt;l);
        printf(""data %d; height %ld; v = 0x%.9"" PRIXPTR "", l = 0x%.9"" PRIXPTR
               "", r = 0x%.9"" PRIXPTR "", p = 0x%.9"" PRIXPTR ""\n"",
               v-&gt;data, v-&gt;height, (uintptr_t)v, (uintptr_t)v-&gt;l,
               (uintptr_t)v-&gt;r, (uintptr_t)v-&gt;p);
        dump_tree_inorder_notag(v-&gt;r);
    }
}

static void dump_tree_inorder(const char *tag, struct vertex *v)
{
    printf(""--&gt;&gt; %s: (root 0x%.9"" PRIXPTR "")\n"", tag, (uintptr_t)v);
    dump_tree_inorder_notag(v);
    printf(""&lt;&lt;-- %s:\n"", tag);
}

static inline long
max(long a, long b)
{
    return(((a) &gt; (b)) ? a : b);
}

static long
balance_factor(struct vertex *v)
{
    assert(v != NULL);
    if (v-&gt;l == NULL &amp;&amp; v-&gt;r == NULL)
        return 0;
    else if (v-&gt;l == NULL)
        return (-1) - v-&gt;r-&gt;height;
    else if (v-&gt;r == NULL)
        return v-&gt;l-&gt;height - (-1);

    return(v-&gt;l-&gt;height - v-&gt;r-&gt;height);
}

static void
update_height(struct vertex *v)
{
    assert(v != NULL);
    if (v-&gt;l == NULL &amp;&amp; v-&gt;r == NULL)
    {
        v-&gt;height = 0;
        return;
    }
    else if (v-&gt;l == NULL)
    {
        v-&gt;height = v-&gt;r-&gt;height + 1;
        return;
    }
    else if (v-&gt;r == NULL)
    {
        v-&gt;height = v-&gt;l-&gt;height + 1;
        return;
    }
    v-&gt;height = max(v-&gt;l-&gt;height, v-&gt;r-&gt;height) + 1;
}

static void
right_rotate(struct vertex **v)
{
    if ((*v)-&gt;p != NULL)
    {
        if ((*v)-&gt;p-&gt;l == (*v))
            (*v)-&gt;p-&gt;l = (*v)-&gt;l;
        else
            (*v)-&gt;p-&gt;r = (*v)-&gt;l;
    }
    struct vertex  *tmp = (*v)-&gt;l-&gt;r;
    (*v)-&gt;l-&gt;r = (*v);
    (*v)-&gt;l-&gt;p = (*v)-&gt;p;
    (*v)-&gt;p = (*v)-&gt;l;
    (*v)-&gt;l = tmp;
    if (tmp != NULL)
        tmp-&gt;p = (*v);

    update_height(*v);
    (*v) = (*v)-&gt;p;
    update_height(*v);
}

static void
left_rotate(struct vertex **v)
{
    assert(v != NULL);
    assert(*v != NULL);
    dump_vertex(""--&gt;&gt; left_rotate"", *v);
    if ((*v)-&gt;r == NULL)
        printf(""1 r == NULL\n"");

    if ((*v)-&gt;p != NULL)
    {
        printf(""p is not NULL\n"");
        if ((*v)-&gt;p-&gt;r == (*v))
        {
            (*v)-&gt;p-&gt;r = (*v)-&gt;r;
        }
        else if ((*v)-&gt;p-&gt;l == (*v))
        {
            printf(""p's l  == v\n"");
            dump_vertex(""LR1 -  current node"", *v);
            dump_vertex(""LR1 -   parent node"", (*v)-&gt;p);
            dump_vertex(""LR1 -  parent  left"", (*v)-&gt;p-&gt;l);
            dump_vertex(""LR1 - current right"", (*v)-&gt;r);
            dump_tree_inorder(""LR1 - tree from parent"", (*v)-&gt;p);

            //if ((*v)-&gt;r != NULL)
                //printf(""WTF r != NULL r %p p %p p-&gt;l %p (*v) %p\n"", (*v)-&gt;r, (*v)-&gt;p, (*v)-&gt;p-&gt;l, (*v));

            printf(""Assign (*v)-&gt;r (0x%.9"" PRIXPTR "") to (*v)-&gt;p-&gt;l (0x%.9"" PRIXPTR "")\n"",
                (uintptr_t)(*v)-&gt;r, (uintptr_t)(*v)-&gt;p-&gt;l);
            (*v)-&gt;p-&gt;l = (*v)-&gt;r;

            dump_vertex(""LR2 -  current node"", *v);
            dump_vertex(""LR2 -   parent node"", (*v)-&gt;p);
            dump_vertex(""LR2 -  parent  left"", (*v)-&gt;p-&gt;l);
            dump_vertex(""LR2 - current right"", (*v)-&gt;r);
            // At this point, we don't have a tree
            //dump_tree_inorder(""LR2 - tree from parent"", (*v)-&gt;p);

            //if ((*v)-&gt;r == NULL)
                //printf(""WTF r == NULL r %p p %p p-&gt;l %p (*v) %p\n"", (*v)-&gt;r, (*v)-&gt;p, (*v)-&gt;p-&gt;l, (*v));
        }
        else
        {
            printf(""error case\n"");
        }
    }
    else
        dump_vertex(""(*v)-&gt;p == NULL"", (*v)-&gt;p);
    printf(""get there before\n"");

    if ((*v)-&gt;r == NULL)
        printf(""r == NULL\n"");

    assert((*v)-&gt;r != NULL);

    struct vertex  *tmp = (*v)-&gt;r-&gt;l;
    printf(""get there after\n"");
    (*v)-&gt;r-&gt;l = (*v);
    printf(""get there\n"");
    (*v)-&gt;r-&gt;p = (*v)-&gt;p;
    (*v)-&gt;p = (*v)-&gt;r;
    (*v)-&gt;r = tmp;
    printf(""get there\n"");
    if (tmp != NULL)
        tmp-&gt;p = (*v);
    printf(""get there\n"");
    update_height(*v);
    (*v) = (*v)-&gt;p;
    update_height(*v);
    dump_vertex(""&lt;&lt;-- left_rotate"", *v);
}

static void
insert_fixup(struct vertex *new_vertex)
{
    dump_tree_inorder(""insert fixup 0"", new_vertex);
    while ((new_vertex-&gt;p != NULL)
           &amp;&amp; ((new_vertex-&gt;height + 1) &gt; new_vertex-&gt;p-&gt;height))
    {
        update_height(new_vertex-&gt;p);
        new_vertex = new_vertex-&gt;p;
        if (balance_factor(new_vertex) == 2)
        {
            if (balance_factor(new_vertex-&gt;l) == -1)
            {
                printf(""double left right rotating\n"");
                left_rotate(&amp;new_vertex-&gt;l);
                printf(""double left right rotating finish\n"");
            }
            right_rotate(&amp;new_vertex);
            dump_tree_inorder(""insert fixup 1"", new_vertex);
            return;
        }
        else if (balance_factor(new_vertex) == -2)
        {
            if (balance_factor(new_vertex-&gt;r) == 1)
            {
                printf(""double right left rotating\n"");
                right_rotate(&amp;new_vertex-&gt;r);
                printf(""double right rotating finish\n"");
            }
            left_rotate(&amp;new_vertex);
            dump_tree_inorder(""insert fixup 2"", new_vertex);
            return;
        }
    }
    dump_tree_inorder(""insert fixup 3"", new_vertex);
}

void
insert(struct vertex **tree, int data)
{
    assert(tree != NULL);
    struct vertex  *new_vertex = malloc(sizeof(struct vertex));
    assert(new_vertex != NULL);
    new_vertex-&gt;data = data;
    new_vertex-&gt;height = 0;
    new_vertex-&gt;l = NULL;
    new_vertex-&gt;r = NULL;
    new_vertex-&gt;p = NULL;

    if (tree == NULL)
        return;
    else if (*tree == NULL)
    {
        *tree = new_vertex;
        dump_tree_inorder(""insert-1"", *tree);
        return;
    }
    struct vertex  *root = *tree;
    while (1)
    {
        if (root-&gt;data &lt; data)
        {
            if (root-&gt;r != NULL)
                root = root-&gt;r;
            else
            {
                root-&gt;r = new_vertex;
                new_vertex-&gt;p = root;
                break;
            }
        }
        else
        {
            if (root-&gt;l != NULL)
                root = root-&gt;l;
            else
            {
                root-&gt;l = new_vertex;
                new_vertex-&gt;p = root;
                break;
            }
        }
    }
    insert_fixup(new_vertex);
    while ((*tree)-&gt;p != NULL)
    {
        (*tree) = (*tree)-&gt;p;
    }
    dump_tree_inorder(""insert-2"", *tree);
}

void *
find(struct vertex *v, int data)
{
    while (v != NULL &amp;&amp; v-&gt;data != data)
        if (v-&gt;data &lt; data)
            v = v-&gt;r;
        else
            v = v-&gt;l;

    return v;
}

static void
free_tree(struct vertex *root)
{
    if (root-&gt;l != NULL)
        free_tree(root-&gt;l);
    if (root-&gt;r != NULL)
        free_tree(root-&gt;r);

    free(root);
}

void
clear_tree(struct vertex **root)
{
    free_tree(*root);
    *root = NULL;
}
</code></pre>

<h3><code>avl2.c</code></h3>

<pre><code>#include ""AVL_tree.h""
#include &lt;stdio.h&gt;

int main(void)
{
    struct vertex *root = NULL;
    long sample[] = { 6, 2, 3 };
    enum { SIZE = sizeof(sample) / sizeof(sample[0]) };

    for (int j = 0; j &lt; SIZE; j++)
    {
        insert(&amp;root, sample[j]);
    }

    clear_tree(&amp;root);
    return(0);
}
</code></pre>

<h3>Sample output</h3>

<p>Again, run under <code>valgrind</code>, and I'm omitting about twenty lines of <code>valgrind</code> administrative output (nothing relevant):</p>

<pre><code>--&gt;&gt; insert-1: (root 0x100AA94F0)
data 6; height 0; v = 0x100AA94F0, l = 0x000000000, r = 0x000000000, p = 0x000000000
&lt;&lt;-- insert-1:
--&gt;&gt; insert fixup 0: (root 0x100AA9560)
data 2; height 0; v = 0x100AA9560, l = 0x000000000, r = 0x000000000, p = 0x100AA94F0
&lt;&lt;-- insert fixup 0:
--&gt;&gt; insert fixup 3: (root 0x100AA94F0)
data 2; height 0; v = 0x100AA9560, l = 0x000000000, r = 0x000000000, p = 0x100AA94F0
data 6; height 1; v = 0x100AA94F0, l = 0x100AA9560, r = 0x000000000, p = 0x000000000
&lt;&lt;-- insert fixup 3:
--&gt;&gt; insert-2: (root 0x100AA94F0)
data 2; height 0; v = 0x100AA9560, l = 0x000000000, r = 0x000000000, p = 0x100AA94F0
data 6; height 1; v = 0x100AA94F0, l = 0x100AA9560, r = 0x000000000, p = 0x000000000
&lt;&lt;-- insert-2:
--&gt;&gt; insert fixup 0: (root 0x100AA95D0)
data 3; height 0; v = 0x100AA95D0, l = 0x000000000, r = 0x000000000, p = 0x100AA9560
&lt;&lt;-- insert fixup 0:
double left right rotating
--&gt;&gt; left_rotate: data 2; height 1; v = 0x100AA9560, l = 0x000000000, r = 0x100AA95D0, p = 0x100AA94F0
p is not NULL
p's l  == v
LR1 -  current node: data 2; height 1; v = 0x100AA9560, l = 0x000000000, r = 0x100AA95D0, p = 0x100AA94F0
LR1 -   parent node: data 6; height 2; v = 0x100AA94F0, l = 0x100AA9560, r = 0x000000000, p = 0x000000000
LR1 -  parent  left: data 2; height 1; v = 0x100AA9560, l = 0x000000000, r = 0x100AA95D0, p = 0x100AA94F0
LR1 - current right: data 3; height 0; v = 0x100AA95D0, l = 0x000000000, r = 0x000000000, p = 0x100AA9560
--&gt;&gt; LR1 - tree from parent: (root 0x100AA94F0)
data 2; height 1; v = 0x100AA9560, l = 0x000000000, r = 0x100AA95D0, p = 0x100AA94F0
data 3; height 0; v = 0x100AA95D0, l = 0x000000000, r = 0x000000000, p = 0x100AA9560
data 6; height 2; v = 0x100AA94F0, l = 0x100AA9560, r = 0x000000000, p = 0x000000000
&lt;&lt;-- LR1 - tree from parent:
Assign (*v)-&gt;r (0x100AA95D0) to (*v)-&gt;p-&gt;l (0x100AA9560)
LR2 -  current node: data 3; height 0; v = 0x100AA95D0, l = 0x000000000, r = 0x000000000, p = 0x100AA9560
LR2 -   parent node: data 2; height 1; v = 0x100AA9560, l = 0x000000000, r = 0x100AA95D0, p = 0x100AA94F0
LR2 -  parent  left: data  ; height  ; v = 0x000000000
LR2 - current right: data  ; height  ; v = 0x000000000
--&gt;&gt; LR2 - tree from parent: (root 0x100AA9560)
data 2; height 1; v = 0x100AA9560, l = 0x000000000, r = 0x100AA95D0, p = 0x100AA94F0
data 3; height 0; v = 0x100AA95D0, l = 0x000000000, r = 0x000000000, p = 0x100AA9560
&lt;&lt;-- LR2 - tree from parent:
get there before
r == NULL
Assertion failed: ((*v)-&gt;r != NULL), function left_rotate, file AVL_tree.c, line 156.
==47909== 
==47909== Process terminating with default action of signal 6 (SIGABRT)
==47909==    at 0x100318032: __pthread_sigmask (in /usr/lib/system/libsystem_kernel.dylib)
==47909==    by 0x100225774: __abort (in /usr/lib/system/libsystem_c.dylib)
==47909==    by 0x1002256F5: abort (in /usr/lib/system/libsystem_c.dylib)
==47909==    by 0x1001ECDF7: __assert_rtn (in /usr/lib/system/libsystem_c.dylib)
==47909==    by 0x10000178A: left_rotate (AVL_tree.c:156)
==47909==    by 0x100001EAC: insert (AVL_tree.c:189)
==47909==    by 0x1000025B7: main (avl2.c:12)
</code></pre>

<p>What I think is relevant to the problem is the value of current node in the LR1 and LR2 output lines:</p>

<pre><code>LR1 -  current node: data 2; height 1; v = 0x100AA9560, l = 0x000000000, r = 0x100AA95D0, p = 0x100AA94F0
¡­
LR2 -  current node: data 3; height 0; v = 0x100AA95D0, l = 0x000000000, r = 0x000000000, p = 0x100AA9560
</code></pre>

<p>Both of these are printing <code>*v</code>, but the node that it represents has changed.  Tracking down why that changed, and what to do about it, will probably resolve the problem.</p>

<p>Note the debugging techniques:</p>

<ul>
<li>Reduce the test case to a deterministic, non-interactive minimum.</li>
<li>Have debug printing functions to print the data structures.</li>
<li>Use assertions.</li>
<li>Code around unexpected null pointers in the debug code. (For example, <code>dump_vertex()</code> originally had <code>assert(v != NULL)</code> but it fired when I didn't want it to, so now it handles null pointers.)</li>
</ul>

<p>I'd often have the dump functions taking a <code>FILE *fp</code> argument so that they can be used to print to any file.  I'd also usually use <code>fflush(fp);</code> at the end of them to ensure the output is sent to the file stream, even if the program crashes abruptly afterwards.  Because I'm writing to standard output and it isn't redirected, it isn't causing trouble here ¡ª but it would be better to do it in the dumping code (and it would save me typing here, but you should know why it was done).</p>
",1
41911329,41911126,0,"<p>This could help. It's not the best that there is and it could be made more efficient, but it should give you an idea.<br/></p>

<pre><code>#include&lt;stdio.h&gt;

void print(int space, int star) 
{
    while (space--) {
        printf("" "");
    }
    while (star--) {
        printf(""*"");
    }
    printf(""\n"");
}

void main()
{
    int star,space,i,j;
    printf(""Enter number:"");
    scanf(""%d"",&amp;star);
    j=star/2;
    i=star;space=0;
    while (space&lt;j || star&gt;0) {
        print(space,star);
        space=space+1;star=star-2;
    }
    space=j-1;star=3;
    while(space&gt;0 || star&lt;=i) {
        print(space,star);
        space=space-1;star=star+2;
    }
}
</code></pre>

<p>Please comment if you have any doubts.<br/>
<strong>Note</strong>:The above code is just a sample. There are many (and far more efficient) ways to implement the pattern and it is encouraged to find a way to do so.<br/>
<strong>Edit</strong>:The code now prints only 1 star in the middle. Did not notice that. Apologies. </p>
",5
41911715,41911126,1,"<p>You can use only <strong>1 loop</strong> for printing:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;


int main(int argc, char* argv[])
{
    int a=0;
    scanf(""%d"",&amp;a);
    int i=0;
    char* asterisk=malloc(sizeof(char)*a);
    memset(asterisk,'*',a*sizeof(char));
    while(i&lt;a)
    {
        if(i&lt;=a/2)
            printf(""%*.*s\n"",a-i,a-2*i,asterisk);
        else
            printf(""%*.*s\n"",i+1,2*(i+1)-a,asterisk);
        i++;
    }
    free(asterisk);
    return 0;
}
</code></pre>
",8
41912620,41911126,0,"<p>Guys I found the mistake, What i did in that  code.</p>

<pre><code>#include &lt;stdio.h&gt;
void main()
{
int i, j, n;
printf(""Enter Odd value for n : "");
scanf(""%d"", &amp;n);
for(i=n/2+1; i&gt;1; i--)
{
for(j=i; j&lt;n; j++)
{
    printf("" "");
}
for(j=1; j&lt;=(2*i-1); j++)
{
    printf(""*"");
}
printf(""\n"");
}


for(i=1; i&lt;=n/2+1; i++)
{
for(j=i; j&lt;n; j++)
{
    printf("" "");
}
for(j=1;j&lt;=(2*i-1); j++)
{
    printf(""*"");
}
printf(""\n"");
}
}
</code></pre>

<p>Thank You!!!!!!! Guys for your help.</p>
",0
34977989,34977964,8,"<p>Yes, the two statements are different. <code>!n / 10</code> is equivalent to <code>(!n) / 10</code> and <code>n / 10 == 0</code> is equivalent to <code>!(n / 10)</code>.<br>
Operator <code>!</code> has higher precedence than that of <code>/</code> operator and therefore <code>n</code> will bind to <code>!</code> first in <code>!n / 10</code>.   </p>

<p>As @<a href=""https://stackoverflow.com/users/596781/kerrek-sb"">Kerrek SB</a> pointed in his comment, <code>!n</code> will evaluated either to <code>0</code> or <code>1</code> so, the expression will always be <code>false</code>.</p>
",1
34978002,34977964,1,"<p>You're asking this because maybe you are not clear about how if statement works. So, let me explain it first.
The syntax of if statement is
 if( expression )
{ procedure to follow } </p>

<p>Here expression to be used should be a logical one that it should result in true or false. Whenever the expression will result in true, the if statement is executed and vice-versa.
Another concept is that if the expression will result in 0 (false), the if statement will not get executed. 
Now when you use  if( n/10 ) , for n = 123, n/10 will result in 12 (the statement uses integers hence the result). Since it is not 0, it is treated as a true and the if statement will execute and n will be returned according to your code. Now n/10 doesn't change n, hence n(=123) will be returned and printed.
Now let's see about  if( n/10 == 0 ) . For the first time when n=123 is n/10 will be 12 which is not equal to 0. So, here a false is generated and the if statement is not executed unlike the previous one.
According to your desired logic you should use if( n/10==0 ).</p>
",0
34978123,34977964,3,"<p>This statement</p>

<pre><code>if (!n / 10)
    return; 
</code></pre>

<p>is equivalent to</p>

<pre><code>if ( ( !n ) / 10)
    return;
</code></pre>

<p>According to the description of the operatpr (6.5.3.3 Unary arithmetic operators)</p>

<blockquote>
  <p>5 The result of the logical negation operator ! is 0 if the value of
  its operand compares unequal to 0, 1 if the value of its operand
  compares equal to 0. The result has type int. The expression !E is
  equivalent to (0==E).</p>
</blockquote>

<p>Thus if n is equal to 0 then expression <code>( !n ) / 10</code> equal to expression <code>1 / 10</code> and as the both operands are integers then the result is equal to 0.</p>

<p>If n is not equal to 0 then expression <code>( !n ) / 10</code> equal to <code>0 / 10</code> and its result again equal equal to 0.</p>

<p>So the original expression is equivalent to</p>

<pre><code>if ( 0 ) return;
</code></pre>

<p>It means that the return statement will be executed never.</p>

<p>As for the second statement</p>

<pre><code>if (n / 10 == 0) 
   return;
</code></pre>

<p>when n is less than 10 then  result of <code>n / 10</code> (provided that n is integer) will be equal to 0 and you will get</p>

<pre><code>if ( 0 == 0 ) return;
</code></pre>

<p>So the return statement in the second if statement will be executed when <code>n</code> is less than <code>10</code>.</p>
",0
47523392,47523279,1,"<p>Use <code>atoi</code> and <code>atof</code> functions from the cstdlib header file.
<a href=""http://www.cplusplus.com/reference/cstdlib/atoi/"" rel=""nofollow noreferrer"">http://www.cplusplus.com/reference/cstdlib/atoi/</a></p>

<p>Note that if the conversion fails zero is returned, so you need special case handling in case of a zero. </p>

<p>There are other ways to do this: you can use streams or <a href=""http://en.cppreference.com/w/cpp/string/basic_string/stol"" rel=""nofollow noreferrer"">std::stoi</a>, just search from ""string to number conversion C++"" or something similar</p>
",3
47526016,47523279,2,"<p>You have a lot packed into your question as far as (1) do we have a string? or (2) was it a number? and (2a.) if it was a number, was it a floating-point number? or (2b) was it an integer value? and unasked, but (3) do we have characters that follow a number entered by the user?</p>

<p>All these questions can be answered by starting off attempting a conversion to <code>double</code> with <code>strtod</code>. <code>strtod</code> takes two arguments. The first <code>nptr</code> a pointer to a string containing a number, and <code>endptr</code> a pointer to pointer to char that upon conversion of digits in in the string is set to <em>one character after</em> the last digit converted (or set to <code>nptr</code> if no digits were converted). That right off the bat answers whether the user entered a number at the beginning of his (or her) input.</p>

<p>The validation is not done. If digits were converted, you still need to check <code>errno</code> to validate the conversion was to a valid number in the range of <code>double</code>. If the conversion is fine, then you need to check whether there is actually a <em>fractional part</em> to the floating-point number of if a whole number was entered. (a simple cast is used below, but you can completely validate the fractional part existence with <code>modf</code> that allows checking for <code>NaN</code> or positive/negative infinity)</p>

<p>Finally, regarding number input, you need to check whether <code>endptr</code> is pointing to the <em>nul-terminating</em> character or a <code>'\n'</code>. Otherwise, additional characters remain following the number in <code>str</code> (beginning at <code>endptr</code>).</p>

<p>If none of the above applies, the user input did not start with a number and is a string.</p>

<p>Putting it altogether, you could do something similar to the following:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;     /* for strtod  */
#include &lt;string.h&gt;     /* for strlen, strcmp */
#include &lt;errno.h&gt;

#ifndef BUFSIZ          /* if you need a constant, define one */
#define BUFSIZ 4096     /* don't skimp on buffer size */
#endif

int main (void) {

    char str[BUFSIZ] = """", *p = str;    /* p for strtod endptr */
    long longnum = 0;
    double dblnum = 0.0;
    size_t len = 0;

    printf (""Enter your input: "");
    if (fgets (str, BUFSIZ, stdin) == NULL) {   /* validate read */
        fprintf (stderr, ""error: invalid input or user canceled.\n"");
        return 1;
    }

    errno = 0;
    dblnum = strtod (str, &amp;p);          /* attempt convert to double */
    if (p != str) {                     /* digits were converted */
        if (!errno) {                   /* a valid conversion took place */
            longnum = (long)dblnum;     /* trim fractional part */
            if (longnum != dblnum)      /* do we have a double? */
                printf (""you entered a floating-point: %f\n"", dblnum);
            else
                printf (""you entered an integer value: %ld\n"", longnum);
            if (*p &amp;&amp; *p != '\n')   /* characters follow number */
                printf (""characters exist following number: %s"", p);
        }
        else
            perror (""strtod failed"");

        return errno ? 1 : 0;
    }

    /* we have a string, now trim the trailing '\n' before comparison */
    len = strlen (str);                 /* get str length */
    if (len &amp;&amp; str[len - 1] == '\n')    /* check last char '\n' */
        str[--len] = 0;                 /* overwrite with nul-character */
    else    /* warn if input too long */
        fprintf (stderr, ""warning: input too long.\n"");

    printf (""input was not a number: %s\n"", str);   /* it was a string */
    if (strcmp (str, ""John"") == 0 || strcmp (str, ""smith"") == 0 ||
        strcmp (str, ""kat"") == 0)
        printf (""the input matched a name: '%s'\n"", str);

    return 0;
}
</code></pre>

<p><strong>Example Use/Output</strong></p>

<p>A string input:</p>

<pre><code>$ ./bin/fgets_str_or_num
Enter your input: my dog has fleas.
input was not a number: my dog has fleas.
</code></pre>

<p>A floating-point (whether you read as double or float is up to you):</p>

<pre><code>$ ./bin/fgets_str_or_num
Enter your input: 123.456
you entered a floating-point: 123.456000
</code></pre>

<p>An integer value:</p>

<pre><code>$ ./bin/fgets_str_or_num
Enter your input: 123
you entered an integer value: 123
</code></pre>

<p>A number followed by more text:</p>

<pre><code>$ ./bin/fgets_str_or_num
Enter your input: 123.456 - that's the number of fleas.
you entered a floating-point: 123.456000
characters exist following number:  - that's the number of fleas.
</code></pre>

<p>An input matching your test:</p>

<pre><code>$ ./bin/fgets_str_or_num_names
Enter your input: John
input was not a number: John
the input matched a name: 'John'
</code></pre>
",0
40958243,40958185,2,"<pre><code>void count_digits(int num) {
    int i, arr[10] = {0}, e = num;

    if (num == 0) arr[0]++;
    else if (num &lt; 0) num *= (-1);

    while (num &gt; 0) {
        arr[num % 10]++;
        num /= 10;
    }
    for (i = 0; i &lt; 10; i++) {
        printf(""%d appears %d times in %d\n"", i, arr[i], e);
    } 
}
</code></pre>

<p>This is a simple code for this purpose.</p>

<ol>
<li><p>I used <code>num &gt; 0</code> as the condition for stopping the loop execution.</p></li>
<li><p>I took the remainder of the <code>num</code> when divided by 10 <code>num % 10</code> and incremented the count value in the array corresponding to this remainder(<code>arr[num % 10]++</code>).</p></li>
<li><p>I then divided <code>num</code> by <code>10</code>. The loop then repeats until the condition is un-satisfied.</p></li>
<li><p>Then I just printed the values. </p></li>
</ol>

<p>Edit:  <code>arr[10] = {0}</code> initializes the array <code>arr</code> of size <code>10</code> with <code>0</code>s.</p>

<p>Edit 2: <code>if(num == 0) arr[0]++</code>. This line checks whether the number input is 0 and increments the count in the array <code>arr</code> if it is equal to <code>0</code></p>

<p>Edit 3: As per, @chux's suggestion, I have made necessary changes so that the function even handles negative numbers.</p>
",7
40958288,40958185,0,"<p>You can use </p>

<pre><code>int sprintf(char * restrict str, const char * restrict format, ...);
</code></pre>

<p>With this function you can put your integer into a string and after you can compare with the table ascii each character <code>tab[i] = '1'</code>...</p>
",0
40972281,40958185,2,"<p>There are a number of way to determine the frequency of the individual digits in a number. Many times it is just as easy to handle the number in <em>sting</em> format as opposed to a number it self. The approach to determining frequency is identical in each case, so match your routine to the type of data you are dealing with.</p>

<p>The short example below, simply loops using <code>mod</code> to extract the digits from any number passed to the <code>ndigits()</code> function. Since you are only concerned with the frequency of the digits, there is no reordering of the separated numbers as would be required in a typical <em>conversion</em> process. You pass your zero-initialized frequency array as a parameter to the function, and within the function, you simply update the element that corresponds to whatever digit is encountered. On return, the array contains the per-digit frequency for each digit in the number passed as 'n':</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;  /* for atoi */

#define NDIG 10   /* array size to hold frequency of digits (0-9) */

int ndigits (int n, int *a);

int main (int argc, char **argv) {

    int a[NDIG] = {0};        /* initialize freq array to all 0 */
    int n = argc &gt; 1 ? atoi (argv[1]) : 347213,   /* set number */
        nd = ndigits (n, a);   /* get number of digits/set freq */

    printf ("" the frequency of digits in '%d' (%d digits):\n\n"", n, nd);
    printf ("" digits | frequency\n--------+---------\n"");
    for (int i = 0; i &lt; NDIG; i++)  /* output elements of freq array */
        printf ("" %6d | %2d\n"", i, a[i]);

    return 0;
}

/* record the frequency of digits in 'n' in array 'a' */
int ndigits (int n, int *a)
{
    int d = 0;
    for (; n; n /= 10, d++)
        a[n % 10]++;

    return d;
}
</code></pre>

<p><strong>Example Use/Output</strong></p>

<pre><code>$ ./bin/freq_digits
 the frequency of digits in '347213' (6 digits):

 digits | frequency
--------+---------
      0 |  0
      1 |  1
      2 |  1
      3 |  2
      4 |  1
      5 |  0
      6 |  0
      7 |  1
      8 |  0
      9 |  0
</code></pre>

<p>Look it over and let me know if you have any additional questions.</p>
",6
40978282,40958185,0,"<p>Using <code>% 10</code> is a simple way to exact one decimal digit at a time from <code>int num</code>.  </p>

<p><code>log10(abs(num))</code> has trouble with some non-positive numbers 0 and perhaps <code>INT_MIN</code>.  It also has trouble should the precision of <code>int</code> exceed the precision of <code>double</code>.  This precision issue is not common but does occur on select 64-bit machines.  IAC, no <em>need</em> for <code>double</code> and a good solution exist with <code>int</code> math.</p>

<p><code>some_int % 10</code> results in a value [-9 ... 9], so code uses <code>abs()</code>.</p>

<pre><code>// A solution that handles the entire range of `int` including 0 and INT_MIN
void count_digits(int num) {
  int x = num;
  int digit_count[10] = { 0 };

  // use a do loop to insure at least 1 pass - important for num == 0
  do {
    int digit = x % 10;
    digit_count[abs(digit)]++;
    x /= 10;
  } while (x);

  for (int i = 0; i &lt; 10; i++) {
    // As desired, eliminate the ""if"" test to always display 10 lines.
    if (digit_count[i]) {
      printf(""The digit %d appeared %d time(s) in %d\n"", i, digit_count[i], num);
    }
  }
}
</code></pre>

<p>Sample usage</p>

<pre><code>#include &lt;limits.h&gt;
int main(void) {
  count_digits(347213);
  count_digits(0);
  count_digits(INT_MIN);
  return 0;
}

The digit 1 appeared 1 time(s) in 347213
The digit 2 appeared 1 time(s) in 347213
The digit 3 appeared 2 time(s) in 347213
The digit 4 appeared 1 time(s) in 347213
The digit 7 appeared 1 time(s) in 347213
The digit 0 appeared 1 time(s) in 0
The digit 1 appeared 1 time(s) in -2147483648
The digit 2 appeared 1 time(s) in -2147483648
The digit 3 appeared 1 time(s) in -2147483648
The digit 4 appeared 3 time(s) in -2147483648
The digit 6 appeared 1 time(s) in -2147483648
The digit 7 appeared 1 time(s) in -2147483648
The digit 8 appeared 2 time(s) in -2147483648
</code></pre>
",0
43933600,43932627,1,"<p><code>scanf(""%lld"", &amp;l);</code> doesn't discard the newline <em>after</em> the number, so the character read by the first <code>scanf(""%c"", ...)</code> is the newline. </p>

<p>So if the number is exactly <code>9999</code>, it will read the <em>newline</em> and 9998 following characters, ignoring the 9999th.</p>

<p>The fix would be to add a space after the <code>%lld</code>: <code>scanf(""%lld "", &amp;l);</code>; this will discard the following whitespace.</p>

<hr>

<p>Then again, you <em>don't</em> have to read these characters into a buffer - instead just use <code>getchar()</code> to read character at a time...</p>
",0
44710089,44709992,1,"<p>You are getting a Segmentation error because you have an <code>||</code> condition in your first if statement, where one of those conditions will always be true, causing your stack to overflow from infinite recursion! Change this to an <code>&amp;&amp;</code> and it should be all fixed!</p>

<pre><code>if((c = getchar()) != EOF &amp;&amp; (c != '\n'))
</code></pre>

<p><strong>EDIT:</strong> Additionally I believe you are going to run into some improper functionality due to the second getchar(). I would change your function to:</p>

<pre><code>void RecursionLine()
{
  int c = getchar();
if(c != EOF || c != '\n')
    {
      RecursionLine();
      printf(""%c"",c);
    }
 else if(c != EOF &amp;&amp; c == '\n'){
      printf(""\n"");
      RecursionLine();
}
}
</code></pre>

<p>Otherwise you are going to read in potentially 2 characters every iteration and that is going to cause one/both of them to be skipped!</p>
",3
40970627,40970451,2,"<p>There are some problems in your code:</p>

<ul>
<li><p>To scan the strings into <code>units</code>, you must define it as a 2D array of <code>char</code>:</p>

<pre><code>char units[3][20];
</code></pre></li>
<li><p>You should modify the <code>scanf</code> format to stop the word parsing on <code>,</code> and spaces, as suggested by user3386109.</p></li>
<li><p>Also modify the <code>printf</code> to pass the array instead of its address.</p></li>
</ul>

<p>Here is the modified code:</p>

<pre><code>double total_weight_kg(char *s, int Length) {
    double weights[3];
    char units[3][20];
    int test = sscanf(s, ""%lf, %19[^, \n], %lf, %19[^, \n], %lf, %19[^, \n]"",
                      &amp;weights[0], units[0],
                      &amp;weights[1], units[1],
                      &amp;weights[2], units[2]);
    printf(""%i\n"", test);
    printf(""%s\n"", units[0]);
   ...
}

int main(void) {
    total_weight_kg(""5, g, 1, t, 175, kg"", 3);
    return 0;
}
</code></pre>
",4
39646294,39646193,0,"<p>You're <code>malloc</code>ing space for the struct, but not for the string inside the struct. </p>

<pre><code>item * item = malloc(sizeof(item));
item-&gt;word  = malloc(sizeof(char) * MAXSTRINGSIZE); //add this line or something similar
strcpy(item-&gt;word, ""this is a word"");
</code></pre>
",6
42503335,37219544,-1,"<p>try this one.</p>

<pre><code>#include&lt;stdio.h&gt;
int main(){
    int a,b,c;
    scanf(""%d"",&amp;a);
    if(a&lt;100 &amp;&amp; a&gt;=1){
        if(a%2==0 &amp;&amp; a&gt;3){
            b=a/2;
            if(b%2==0){
                printf(""YES\n"");
                printf(""%d %d"",b,b);
            }else{
                b=b+1;
                c=b-2;
                printf(""YES\n"");
                printf(""%d %d"",c,b);
           }
        }else{
        printf(""NO"");
    } else{
       printf(""Invalid Input"");
    }
 return 0;
 }
</code></pre>
",1
41218194,37219544,-1,"<p>If the melon can be divided into two even numbers <em>2x</em> and <em>2y</em> (<em>x, y</em> ¡Ý 1), then the sum is <em>2*(x+y</em>).
Thus any even number ¡Ý 4 can be divided into two even parts.</p>

<p>To check for an even number, you can simply use <code>x%2 == 0</code>.</p>

<p>any even number can be divided into two evens. Except 2, 2=1+1. Hence the condition.</p>

<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int main() {
    int w;
    cin&gt;&gt;w;
    if(w&gt;2 &amp;&amp; w%2==0){
        cout&lt;&lt;""YES""&lt;&lt;endl;
    }
    else{
        cout&lt;&lt;""NO""&lt;&lt;endl;
    }
    return 0;
}
</code></pre>
",0
39316821,39257049,0,"<ul>
<li>when both strings are empty (*str == 0) return true </li>
<li>when just one string is empty, return false</li>
<li>if first chars are not same return false </li>
<li>otherwise return the result of comparing the rest of the strings</li>
</ul>

<p>I think you second if has some errors</p>
",2
39317563,39257049,0,"<p>Code contains several errors:</p>
<ol>
<li><p>do not use <code>strcmp()</code> as a function name unless you really know what you do!  This function and its semantic is defined by the C standard. The compiler can rely on it and can replace calls with a more efficient implementation</p>
</li>
<li><p><code>strlen(str1)-strlen(str2) &gt; 1</code> is prone to (defined) unsigned integer underflows and will hold in most cases (e.g. <code>strlen(&quot;a&quot;) - strlen(&quot;aaaaaaa&quot;) &gt; 1</code> is <strong>true</strong>).</p>
<p>Use <code>strlen(str1) &gt; strlen(str2) + 1</code> (usually you should check the <code>+ 1</code> operation for overflows too)</p>
</li>
<li><p>The modifications of <code>err</code> will never be seen by the recursive calls.  Either declare it as <code>static</code> or pass it as a paramter to your function.</p>
</li>
</ol>
",1
39318675,39257049,0,"<p>this is the final code i'v written...   </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int one(char* s1, char* s2){
  int two;
  if(*s1==' '){
      two=one(s1+1,s2);
      return two;
  }
  if(*s2==' '){
      two=one(s1,s2+1);
      return two;
     }
  if(*s1=='\0' &amp;&amp; *s2=='\0'){
      return 0;
  }
    if(*s1=='\0'){
        return strlen(s2);
    }
  if(*s2=='\0'){
      return strlen(s1);
  }
  two=one(s1+1,s2+1);
  if (*s1==*s2){
return two;
}
    else{
        return two+1;
}
} 
void main(){
    int diff;
    char str1[51],str2[51];
printf(""enter the first string\n"");
    scanf(""%s"", &amp;str1);
    printf(""enter the second string\n"");
    scanf(""%s"", &amp;str2);
    diff=one(str1,str2);
    if(diff==1){
    printf(""1\n"");
}
    else{
        printf(""0\n"");
}
  }
</code></pre>
",0
37114954,37114837,0,"<p>That because <code>un_i</code> is of type <code>unsigned int</code>, it does not represent negative values. If you expect the result to be negative, you will need signed type, like <code>int</code>, try this:</p>

<pre><code>unsigned int un_i = 1112;
printf (""PRINTF: un_i[%d] and u_i/10[%d]\n"", (1 - un_i), (1 - (int)un_i)/10);
</code></pre>
",0
37115154,37114837,0,"<p>You expect to print <code>-1111</code> and <code>-111</code>. However <code>1 - un_i</code> produces a result that is also of type <em><code>unsigned int</code></em>; the result is also always non-negative. If <code>unsigned int</code> is 32 bits wide (as it is in your case), the result will be <code>4294966185</code>; and that divided by 10 would result in <code>429496618</code>.</p>

<hr>

<p>The <code>%d</code> switch expects a (<code>signed</code>) <code>int</code>, not an <code>unsigned int</code>. Of that  the C11 standard says that when using variable arguments with wrong type the behaviour is undefined, <strong>excepting</strong> that</p>

<blockquote>
  <p>one type is a signed integer type, the other type is the corresponding unsigned integer type, <strong>and the value is representable in both types</strong></p>
</blockquote>

<hr>

<p>Thus printing <code>429496618</code> with <code>%d</code> has defined behaviour, as this same value is representable as both <code>signed int</code> and <code>unsigned int</code>.</p>

<p>However <code>1 - 1112U</code> will have the value of <code>UINT_MAX - 1110</code>, which, when used as an argument to <code>printf</code> and converted with <code>%d</code> will lead to <strong>undefined behaviour</strong> since the <code>UINT_MAX - 1100</code> value is not representable as a <code>signed int</code>; getting <code>-1111</code> printed just happens to be the (<strong>undefined</strong>) behaviour in this case.</p>

<hr>

<p>Since you really want to use signed numbers, then you should declare your variable <code>un_i</code> as an <code>int</code> instead of <code>unsigned int</code>.</p>

<p>In case you expect to do signed math with numbers greater than <code>int</code> use <code>long int</code> or <code>long long int</code> or even better, types such as <code>int64_t</code> instead of this unsigned trickery.</p>
",3
39651695,39651568,1,"<p>From the manual.</p>

<blockquote>
  <p>The  system()  library  function uses fork(2) to create a child process
         that executes the shell command specified in command using execl(3)  as
         follows:</p>
</blockquote>

<p><code>execl(""/bin/sh"", ""sh"", ""-c"", command, (char *) 0);</code></p>

<p>I think your parent process is getting terminated before the execution of the child process.So, call <code>execl()</code> directly.</p>

<pre><code>execl(""/bin/bash"",""bash"",""path_to_dummy.sh"",NULL);
</code></pre>

<p>Or, if you really need a child process to execute it : </p>

<pre><code>pid_t id = fork();
if(id &gt; 0) {
    /**
     * In parent
     */
    wait(NULL);
}else if(id == 0) {
    /**
     * In Child
     */
    execl(""/bin/bash"",""bash"",""path_to_dummy.sh"",NULL);
}
</code></pre>
",1
39651711,39651568,0,"<p>If a <code>calloc()</code> fails and returns <code>NULL</code>, <code>system()</code> will still work on the second sample because you are not attempting to overwrite memory you are not supposed to touch before calling it.</p>

<p>On the first code, some <code>calloc()</code> call is failing and returning <code>NULL</code> and you are not handling this problem correctly, you write to <code>NULL</code> and the program crashes before you call <code>system()</code>.</p>
",0
35209108,35209009,1,"<p>You'll need to do a forward declaration of one of the structs to reference the other, and you'll need to give the structs themselves names so they can be referenced without the typedef:</p>

<pre><code>struct ppl;

typedef struct book
{
    char *nameBook;
    char *auother;
    struct ppl *p;
}book;

typedef struct ppl
{
    char *firstName;
    char *lastname;
    int id;
    struct book **books;
    int num_of_your_books;
}ppl;
</code></pre>
",5
47690448,47690378,1,"<p>The problem is this:</p>

<pre><code>printf(""Total positive int = %d\n"", &amp;total);
                                    ^
</code></pre>

<p>Instead of printing value of <code>total</code> variable, you are printing the address of it. Remove <code>&amp;</code>.
Correct way is:</p>

<pre><code>printf(""Total positive int = %d\n"", total);
</code></pre>
",0
47692120,47690378,0,"<p>There is a minor bug in your code here:</p>

<pre><code>printf(""Total positive int = %d\n"", &amp;total);
                                    ^
</code></pre>

<p>When this is changed to:</p>

<pre><code>printf(""Total positive int = %d\n"", total);
</code></pre>

<p>A simpler version of the same would look like:</p>

<pre><code>#include&lt;stdio.h&gt;

int main(void)
{
    int number = 0;
    int total = 0;

    while(1)
    {
        printf(""Enter Integer: "");
        scanf(""%d"", &amp;number);

        if (number &gt;= 0)
        {
            total += number;
        }
        else if(number &lt; 0)
        {
            total += number;
            printf(""Total positive int = %d\n"", total);
            break;
        }
        else
        {
            ;
        }
    }

    return 0;
}
</code></pre>

<p>This code will do what it says, but it will also do different things if valid input is not inserted. Because, it doesn't take care of inputs that are not numbers.</p>

<p>Here is the one, that takes care of validating inputs and only allows numbers.</p>

<p>This version below has a lot to improve on, but I prefer it this way for letting learners understand the code and improve it further.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main (void) 
{ 
    char str[10] = { 0 }; //Assuming that the number can only be restricted to 9 digits. Change as required!
    char *ptr = NULL;
    double ret = 0.0;
    double total = 0.0;

    printf(""Enter numbers: "");

    while(1)
    {
        str[0] = '\0';

        scanf(""%s"", str);
        ret = strtod(str, &amp;ptr);
        if(ret == 0.0)
        {
           if(ptr != NULL)
           {
               printf(""\nNot a number!"");
               continue;
           }
           else
           {
               total += ret;
           }
        }
        else if(ret &lt; 0.0)
        {
           total += ret;
           break;
        }
        else
        {
           total += ret;
        }
    }

    printf(""\n%lf"", total);

    return(0);
}
</code></pre>
",0
45063015,45062866,2,"<p>Just after you leave the inner loop, but inside the outer loop, reset the value of <code>Total</code> by setting it to <code>0</code>.</p>

<pre><code>for (int year = 0; year &lt; NUMYEARS; year++) {
  total = 0.0;
  for (int month = 0; month &lt; NUMMONTHS; month++) {
    printf(""Enter rain for %d, %d:\n"", year + 1, month + 1);
    scanf(""%f"", &amp; Rain);
    Raindata[year][month] = Rain;
    total = total + Rain;
  }
  printf(""Total rainfall: %.2f\t\n"", total);
}
</code></pre>

<p>This way, you start afresh from zero each year.</p>
",6
45063022,45062866,3,"<p>Calculate the total in <code>printdata()</code>, and set it to <code>0</code> at the beginning of each year.</p>

<pre><code>void printdata() {
  // Print data
  printf(""year\t month\t rain\n"");
  for (int year = 0; year &lt; NUMYEARS; year++) {
    float total = 0;
    for (int month = 0; month &lt; NUMMONTHS; month++) {
      printf(""%s\t %s\t %5.2f\n"", years[year], months[month], Raindata[year][month]);
      total += Raindata[year][month];
    }
    printf(""%s Total\t %6.2f\n"", total);
  }
}
</code></pre>
",1
39136223,39136132,1,"<p>Just store your first STUDENT and link it later.  </p>

<pre><code>STUDENT *DeleteLastAndMoveFirstToLast(STUDENT *students)
{
  STUDENT *pFirst = students;
  STUDENT *pHead = pFirst-&gt;Next;

  if (!pHead) return 0;

  STUDENT *pNext = pHead;
  STUDENT *pNextAfterNext = pNext-&gt;Next;

  if (pNextAfterNext) {
    while (pNextAfterNext-&gt;Next) {
      pNext = pNext-&gt;Next;
      pNextAfterNext = pNext-&gt;Next;
    }
  }

  pNext-&gt;Next = pFirst;
  pFirst-&gt;Next = 0;
  return pHead;
}
</code></pre>
",0
42467108,42467028,1,"<p>This is a long shot, but do you account for the fact, that strings in C are null-terminated? I.e. string <code>""abc""</code> really consists of 4 characters, <code>'a', 'b',  'c' and '\0'</code>. When you use <code>memcpy</code> you might be missing on the last null. And <code>printf</code> assumes that string is null terminated as well, null signifying the place where it has to stop printing output.</p>

<p>C has a number of functions that work with strings and account for null character. Try looking up the following functions: <code>strlen</code>, <code>strcpy</code> (instead of <code>memcpy</code>).</p>
",1
42467349,42467028,0,"<p>There can be many run time errors in it.</p>

<ol>
<li>len -4 can return a negative value.</li>
<li>you can miss copying the last null character of incoming string into comment. that case comment will be no longer string and when you use %s it will give you error or garbage.</li>
</ol>

<p>Better approach will be to check if :</p>

<pre><code>if (size &gt; 0 &amp;&amp; size &lt;= strlen(src)?{
     memcpy(comment, src, size);
     comment[strlen(comment)] = '\0';
}
</code></pre>
",0
37458744,37458414,0,"<p><code>rand() % 9</code> will return a number between <code>0</code> and <code>8</code> included. But your array's border occupies indices <code>0</code> and <code>8</code>.</p>

<p>To avoid overwriting it, pick a random number between <code>1</code> and <code>7</code>:</p>

<pre><code>r1 = 1 + rand() % 7;
</code></pre>

<p>Note that scaling <code>rand()</code>'s output (dividing by <code>RAND_MAX + 1</code> then multiplying by your upper bound) has less bias than using a remainder, but in your case it's probably not important.</p>
",1
46119993,46119892,0,"<pre><code>char* str1;
scanf(""%s"",str1);

char* str2;
scanf(""%s"",str2);
</code></pre>

<p><code>str1</code> and <code>str2</code>are <strong>not initialised</strong>, and since they are pointer, you are basically writing the results of your your scanf into random places in memory. </p>

<p>This is why you get a <em>Segmentation fault</em> (your program tries to write on a memory segment where it is not authorized to write)</p>
",11
35192869,35192319,0,"<ul>
<li><p>Try this one,</p>

<pre><code>#include &lt;stdio.h&gt;
int main() 
{
    int intNum = 13, intBin = 7;
     unsigned i;
     for (i = 1 &lt;&lt; (intBin-1); i &gt; 0; i = i / 2)
         (intNum &amp; i)? printf(""1""): printf(""0"");
    return 0;
}
</code></pre></li>
</ul>
",0
35192515,35192319,0,"<p>You are massively over-complicating things. If I understand correctly what you want to do (I didn't read your code because the formatting is a mess), it is as simple as iterating through the bits you want to print, and printing each bit. Because you start with the highest index bit, run a for loop from largest index to 0.</p>

<p>Your function can be three lines:</p>

<pre><code>void printBin(int num, int bits) {
    for (int i = bits-1; i &gt;= 0; --i) {
        printf(""%d"",num&gt;&gt;i &amp; 1);
    }
}
</code></pre>
",2
35204001,35192319,0,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;limits.h&gt;
#include &lt;conio.h&gt;

void printBin(int num, int bits){
    unsigned n = (unsigned)num;
    unsigned mask;
    int bit_len = sizeof(n) * CHAR_BIT;

    if(bits &lt;= 0 || bits &gt; bit_len)
        return ;

    for(mask = 0x1 &lt;&lt; --bits; mask; mask &gt;&gt;= 1){
        putchar(n &amp; mask ? '1' : '0');
    }
}

int main(void){
    int intNum, intBits;

    printf(""\nEnter a integer number and number of bits :"");
    scanf(""%d %d"", &amp;intNum, &amp;intBits);

    printf(""\nInteger number in binary format :"");
    printBin(intNum, intBits);puts("""");

    getch();
    return 0;
}
</code></pre>
",1
39313583,39313385,0,"<p>I think you are trying to do this,</p>

<pre><code>#include &lt;stdio.h&gt;
#define NICKEL 5
#define DIME 10
#define QUARTER 25

int main(void)
{
  int coins;
  int sum  = 0;

  do {
    printf(""Insert Coins:"");
    scanf(""%d"", &amp;coins);
    if(coins == NICKEL || coins == DIME || coins == QUARTER) {
      sum += coins;
    } else if(coins == 0) {
      break;
    } else {
      printf(""Wrong Coin\n"");
    }
  }while(1); // Infinite Loop.

  printf(""The amount you put in %d\n"", sum);
}
</code></pre>
",0
39313987,39313385,0,"<p>The problem is in your in while statement not in break. </p>

<blockquote>
  <p>0 == 0 <strong>true</strong> 0 != 0 <strong>false</strong></p>
</blockquote>

<p>in a control statement (like if-else,for,while) in the condition checking it always evaluate the condition and based on the result, it takes the decision , </p>

<p>you have written <code>while (coins != 0)</code>  when some one enters 0 than it becomes <code>while (0 != 0)</code> after evaluating this <code>while (0)</code> and that causes the loop to terminate</p>
",1
39331122,39322155,0,"<p>After some research i used this code to solve the problems.</p>

<pre><code>ranW(let, a);
printf(""Word: %s\n"",a);
fflush(stdin);
fgets(b,(sizeof b)+1 ,stdin);
</code></pre>

<p>I can still use advice if this is not right to use.</p>
",0
35194031,35193969,3,"<p>Parentheses are parentheses. In C you don't use any other kind of braces when grouping expressions, as the square-braces <code>[]</code> and curly-braces <code>{}</code> have special meaning in the language. Just use parentheses <code>()</code>.</p>

<hr>

<p>Then a couple of general hints: For any pointer or array <code>p</code> and index <code>i</code>, the expression <code>*(p + i)</code> is equivalent to <code>p[i]</code>. The latter is usually easier to read and understand, which means it's also more maintainable. Note the <code>p</code> can be any expression that yields a pointer (or array), and <code>i</code> can be any expression that yields an non-negative integer.</p>

<p>Also, if you have a statically sized ""array"" like e.g. <code>phi</code> in your code, declare it as an array instead. That will also make it easier to understand and maintain. And if <code>phi</code> is an so-called ""2d"" array, then make it an array of arrays:</p>

<pre><code>double phi[201][201];
</code></pre>

<p>This is especially important as you actually don't <code>free</code> the memory you allocate. It works out fine in this case since you exit the program which on most system will mean that allocated memory will be free'd automatically, but making a habit to free what you allocate will save you trouble down the road. Using arrays you don't need to free anything.</p>

<p>Lastly, in C you should not cast the result of <code>malloc</code> (or any function returning <code>void *</code>). See <a href=""https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc"">this SO question and answer for more information</a>.</p>
",0
35215025,35214984,0,"<pre><code>alpha[0] == ""#""
            ^ ^
            double quotes for string literal
</code></pre>

<p>should be</p>

<pre><code>alpha[0] == '#'
            ^ ^
            single quotes for character literal
</code></pre>

<p>Comparing a single character to a string literal is a constraint violation (thanks to @AnT for pointing out terminology error), and the compiler <em>shouldn't</em> allow it. Instead compare a single character to a character literal.</p>
",3
35215050,35214984,1,"<p>You can use the <code>%x</code> format specifier to read hex values.  With a 0-padded width of two, there will be no need to range-test.  <em>e.g.</em></p>

<pre><code>int r, g, b;
if( 3 == scanf( ""#%02x%02x%02x"", &amp;r, &amp;g, &amp;b ) )
{
    printf( ""Red   : %3d (%02x)\n"", r, r );
    printf( ""Green : %3d (%02x)\n"", g, g );
    printf( ""Blue  : %3d (%02x)\n"", b, b );
}
</code></pre>
",0
41190374,41190261,2,"<p>The problem is that you are assigning a pointer of type <code>char *</code> to one of type <code>int *</code>, hence ""<em>INCOMPATIBLE</em>"" pointers. </p>

<p>You also attempted to pass the <code>int *</code> pointer to <code>puts()</code> which expects a <code>char *</code> pointer, thus there is another warning.</p>

<p>Why are you doing this? If they are clearly pointers of different type it's very strange that you attempted it anyway. </p>

<p>It would be interesting to know, if you think this is correct for some reason.</p>

<p>You need to carefully read warnings and try to understand what they mean, it would help you learn a lot of the basics and good practice too.</p>

<p>Also, please note that: <a href=""https://stackoverflow.com/a/26557243/1983495""><code>while (!feof(fp))</code></a> is not a good way to check if there is nothing else to read because <code>fgets()</code> needs to fail first (to attempt a read after <code>EOF</code>) so you still do the <code>for (i ...)</code> loop after the bad read. You should change to <code>while (fget(x, 100, fp) != NULL)</code></p>

<p>Finally, in <a href=""/questions/tagged/c"" class=""post-tag"" title=""show questions tagged &#39;c&#39;"" rel=""tag"">c</a> there is no need to cast <code>void *</code> to any other poitner type, and it's considered bad practice to cast the return value of <code>malloc()</code> because of the reasons <a href=""https://stackoverflow.com/a/605858/1983495"">explained in this answer</a></p>
",10
41190390,41190261,5,"<p>The problem is that you seem to be assigning the result of calling <code>getNum</code> to a variable of type <code>int *</code>, which doesn't make much sense as <code>getNum</code> returns a <code>char *</code>. </p>

<p>You also try to print with <code>puts</code> that variable of type <code>int *</code>, while <code>puts</code> accepts only a <code>const char *</code>.</p>

<p>What's more, you're getting out of bounds in your function's code, as I've already mentioned in the comments: <code>n = (char *)malloc(1000 * sizeof(char));</code> allocates memory for exactly 1000 characters. <code>n[1000] = '\0';</code> tries to access the 1001st (!) character. Remember, the array indices start from zero!</p>
",2
41190407,41190261,3,"<blockquote>
<pre><code>n = (char *)malloc(1000 * sizeof(char)); // ugly code
</code></pre>
</blockquote>

<p>That should really be</p>

<pre><code> n = malloc(1000);
 if (n==NULL) {perror(""malloc""); exit(EXIT_FAILURE);};
</code></pre>

<p>because <code>sizeof(char)</code> is <em>always</em> 1, and because you should not cast (in C) the result of <code>malloc</code>, and because <code>malloc</code> <em>can fail</em> and you should test against that.</p>

<p>Then you do later</p>

<blockquote>
<pre><code>   n[1000] = '\0'; // wrong code
</code></pre>
</blockquote>

<p>This changes the 1001<sup>-th</sup> byte (<em>not</em> the last 1000<sup>-th</sup> one), so is <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behavior</a> (it is a <a href=""https://en.wikipedia.org/wiki/Buffer_overflow"" rel=""nofollow noreferrer"">buffer overflow</a>). You should be <a href=""https://stackoverflow.com/a/25636788/841108"">really scared</a>, bad things could happen (and if they don't, it is because you are <em>unlucky</em>). You probably want</p>

<pre><code> n[999] = '\0'; // the 1000th byte
</code></pre>

<p>BTW, I guess you are using <a href=""http://gcc.gnu.org/"" rel=""nofollow noreferrer"">GCC</a> or <a href=""http://clang.llvm.org/"" rel=""nofollow noreferrer"">Clang</a> on some POSIX like system. You really should take the habit of compiling with all warnings and debug info:</p>

<pre><code>cc   -Wall -g  8.c   -o 8
</code></pre>

<p><sup>(If using <code>make</code>  you probably want <code>CFLAGS= -Wall -g</code> in your <code>Makefile</code>)</sup></p>

<p>You might want to learn more about <a href=""https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html"" rel=""nofollow noreferrer"">instrumentation options</a>, e.g. you could also pass <code>-fsanitize=address</code> to <code>gcc</code> </p>

<p>Then you can use the <code>gdb</code> debugger and perhaps also <a href=""http://valgrind.org/"" rel=""nofollow noreferrer"">valgrind</a>. But be sure to improve your own code till you get no warnings.</p>

<p>Of course <code>num = getNum();</code>  is incorrect. You are assigning a pointer into an integer (so you have a <em>type mismatch</em>). That is often wrong (and in the <em>rare</em> cases -not here- you would really mean it, you should have some <em>explicit</em> cast to show to the reader of your code - perhaps you next year - what you really wanted to do).</p>

<p>You want to <em>convert</em> a string to a number. Read more the <a href=""http://en.cppreference.com/w/c"" rel=""nofollow noreferrer"">documentation</a> of the <a href=""https://en.wikipedia.org/wiki/C_standard_library"" rel=""nofollow noreferrer"">C standard library</a>. You want to use <a href=""http://en.cppreference.com/w/c/string/byte/atoi"" rel=""nofollow noreferrer"">atoi</a> (type <code>man atoi</code> in a terminal, or read <a href=""http://man7.org/linux/man-pages/man3/atoi.3.html"" rel=""nofollow noreferrer"">atoi(3)</a>) then code:</p>

<pre><code>num = atoi(getNum());
</code></pre>

<p>You are also coding:</p>

<blockquote>
<pre><code>while(!feof(fp)) // bad code
</code></pre>
</blockquote>

<p>This is wrong (and a bit tricky, see <a href=""https://stackoverflow.com/questions/5431941/why-is-while-feof-file-always-wrong"">this</a>). <code>feof</code> is only valid <em>after</em> some read operation (and not <em>before</em>, see <a href=""http://man7.org/linux/man-pages/man3/feof.3.html"" rel=""nofollow noreferrer"">feof(3)</a>). since you want to remove the ending <code>\n</code> (but read <a href=""http://man7.org/linux/man-pages/man3/fgets.3.html"" rel=""nofollow noreferrer"">fgets(3)</a> &amp; <a href=""http://man7.org/linux/man-pages/man3/strchr.3.html"" rel=""nofollow noreferrer"">strchr(3)</a>...) you probably want instead</p>

<pre><code> do {
   if (NULL==fgets(x, 100, fp)) break;
   char*eol = strchr(x, '\n');
   if (eol) *eol = 0;
 } while (!feof(fp));
</code></pre>

<p>at last your code is also incorrect because <code>malloc</code> is not initializing the returned memory zone. So your <code>n</code> might have a zero byte in some unexpected place.</p>

<p>Perhaps you should read about the (POSIX specific) <a href=""http://man7.org/linux/man-pages/man3/strdup.3.html"" rel=""nofollow noreferrer"">strdup(3)</a> or <a href=""http://man7.org/linux/man-pages/man3/getline.3.html"" rel=""nofollow noreferrer"">getline(3)</a>. Both could make your code simpler. And think about the adverse situation of files with very long lines (you might have a file with a line of many thousand bytes, and you could even have a file without any newlines in it).</p>

<p>Your <code>puts(num)</code> is also wrong, since also a <em>type mismatch</em>. Consider using <a href=""http://man7.org/linux/man-pages/man3/printf.3.html"" rel=""nofollow noreferrer"">printf(3)</a> (but take the habit of ending the control format string with <code>\n</code> or else use <a href=""http://man7.org/linux/man-pages/man3/fflush.3.html"" rel=""nofollow noreferrer"">fflush(3)</a> because <code>&lt;stdio.h&gt;</code> is <em>buffering</em>), so <code>printf(""%d\n"", num);</code></p>
",2
40577328,40577248,1,"<p>You are attempting to print a file pointer:</p>

<pre><code>puts(fp);
</code></pre>

<p>Read the manual of <code>puts()</code> -that's not what it takes.</p>

<p>To read char-by-char and print on the stdout, you can do:</p>

<pre><code>int ch;
fp = fopen(argv[i], ""r"");
if (!fp) {
   perror(""fopen"");
   exit(1);
}
while((ch=fgetc(fp)) != EOF) {
   putchar(ch);
}
flcose(fp);
</code></pre>

<p>Unless you are passing multiple file names as arguments, your outer loop doesn't make much sense.</p>
",5
40577402,40577248,1,"<p>Your program has multiple problems:</p>

<ul>
<li><p>You do not test the return value of <code>fopen()</code>: the program invokes undefined behavior if any of the command line arguments cannot be opened as a stream for reading.</p></li>
<li><p><code>while(!feof(fp))</code> is incorrect. Read this: <a href=""https://stackoverflow.com/questions/5431941/why-is-while-feof-file-always-wrong"">Why is ¡°while ( !feof (file) )¡± always wrong?</a></p></li>
<li><p><code>puts(fp);</code> is incorrect as <code>fp</code> is a <code>FILE *</code>, not a string. Use a loop to copy the file contents one byte at a time.</p></li>
</ul>

<p>Here is a corrected version:</p>

<pre><code>#include &lt;errno.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(int argc, char *argv[]) {
    FILE *fp;
    int i, c;

    for (i = 1; i &lt; argc; i++) {
        fp = fopen(argv[i], ""r"");
        if (fp == NULL) {
            fprintf(stderr, ""cannot open %s: %s\n"", argv[i], strerror(errno));
        } else {
            printf(""%s\n"", argv[i]);
            while ((c = getc(fp)) != EOF) {
                putchar(c);
            }
            fclose(fp);
        }
   }    
   return 0;
}
</code></pre>
",0
40577593,40577248,0,"<pre><code>int main(int argc, char *argv[]) {
    FILE *fp;
    int i;
    char buff[128];
    for (i = 1; i &lt; argc; i++) {
        printf(""\n%s\n"", argv[i]);
        if(NULL == (fp = fopen(argv[i], ""r""))){//check open file
            perror(""fopen"");
            continue;
        }
        while (fgets(buff, sizeof buff, fp)) {//read into buffer
            fputs(buff, stdout);//print buffer (not add newline)
        }
        fclose(fp);
   }    
   return 0;
}
</code></pre>
",0
48043608,48042785,3,"<p>OP's biggest failing is not checking the return value of <code>fscanf()</code>.  Had code done so, problems would be more rapidly detected.</p>

<hr>

<p>When is comes to reading lines of data the first consideration is:</p>

<blockquote>
  <p>Could input be faulty?</p>
</blockquote>

<p>With learner applications this is often considered no.  Input is either ""good"" or end-of-file.  Let us not assume data is too well formated.</p>

<p>As it turns out, while the data file may not be faulty, the code reading it may be wrong.  The subtle 2nd reason for code to check the <code>*scanf()</code> return values - self validation.</p>

<hr>

<p>For <em>line</em> orientated data, it is much better to read is a <em>line</em> of data with <code>fgets()</code> than <code>feof(), fscanf()...</code>  See also <a href=""https://stackoverflow.com/questions/48042785/reading-from-file-into-a-struct-in-c/48043608#comment83056866_48042785"">@Paul Ogilvie</a></p>

<pre><code> char buf[sizeof(Book) * 2]; // Use an ample sized buffer
 while (fgets(buf, sizeof buf, fp)) {
</code></pre>

<hr>

<p>Use <code>""%s""</code> to read in text that does not include white-space.  This will also read in <code>'/'</code>.  Since <code>'/'</code> is use to delimit, <code>""%s""</code> is not an acceptable input specifier.  Further names like ""Adam Mickiewicz"" include a space.  A 2nd reason to not use <code>""%s""</code>.</p>

<p>Consider what <code>fscanf(fp, ""%s/"", new-&gt;authors[i]);</code> is doing. <code>""%s""</code> scans into <code>new-&gt;authors[i]</code> non-white-space characters. A character after non-white-space characters is a white-space, never a <code>'/'</code>.</p>

<p>Use <code>""%[^/]""</code> to read in text that does not include <code>'/'</code>.</p>

<p>Use <code>""%n""</code> to keep track of the current scan offset.</p>

<p>Now parse the line.</p>

<pre><code>    char *p = buf;
    Book *nu = malloc(sizeof *nu);  // no cast needed
    for (size_t i = 0; i &lt; AK; i++) {
      int n = 0;
      sscanf(p, ""%99[^/]/%n"", nu-&gt;authors[i], &amp;n);
      if (n == 0) {
        Handle_Parse_Error();
      }
      p += n; 
    }
    if (sscanf(p, ""%254[^/]/%99[^/]/%u/%lf"", 
        nu-&gt;title, nu-&gt;publisher, &amp;nu-&gt;year, &amp;nu-&gt;price) != 4) {
      Handle_Parse_Error();
    }
</code></pre>

<p>Robust code would add checks on each member.  Suit to coding goals.</p>

<pre><code>    if (nu-&gt;year &lt; -6000 || nu-&gt;year &gt; 2999) Fail_Year_Range();
</code></pre>

<hr>

<p>Further work is needed to link data together.  OP's code is unclear on this matter and so left to OP.  A possible approach:</p>

<pre><code>Book *read_from_file(const char *path) {
  Book first;  // Only the .next member is used.
  first.next = NULL;
  Book *current = &amp;first;

  // setup while () loop
  ...
  while (fgets(buf, sizeof bu, fp)) {
    ...
    Book *nu = malloc(sizeof *nu);
    nu-&gt;next = NULL;
    ...
    // parse data, fill in rest of nu-&gt;
    ....
    current-&gt;next = nu;  // update current pointer
    current = nu;
  }
  // close up file ...

  return first.next;
}
</code></pre>
",0
39621776,39621551,1,"<p>There are many issues:</p>

<p>You probably want this (untested code)</p>

<pre><code>#include &lt;stdio.h&gt;

int main () {    
   char firstname[20];
   char lastname[20];
   char response[20];

   printf (""Type your first name:\n"");
   scanf (""%s"", firstname);
   printf (""\n"");  
   printf (""Type your last name:\n"");
   scanf (""%s"", lastname);
   printf (""\n"");

   printf (""Hi %s %s do you want to stop giving me information?\nSay Y or  N"", firstname, lastname);
   scanf (""%s"",response);

   if (response[0] == 'Y' || response[0] == 'y') {
      system (""pause&lt;NULL"");
   }
   printf(""Thank you for using my program. Good Bye!\n\n""); 

   system (""pause&lt;NULL"");

   return 0;
}
</code></pre>

<ul>
<li>There is no <code>'c'</code> format specifier, it's <code>%s</code></li>
<li><code>scanf (""%s"", &amp;firstname)</code> is wrong, <code>firstname</code> is already the address of the buffer</li>
<li><code>response == 'y'</code>is wrong, <code>response</code> is the address of the buffer, you just need the first char of the buffer, that is <code>responde[0]</code> </li>
<li><code>if (response[0] == 'Y' || response[0] == 'y'); {</code>, there was a stray <code>;</code> before the <code>{</code></li>
</ul>
",2
39621780,39621551,0,"<p>Your problem is that you are asking for a char input, you want a string.</p>

<p>tutorialspoint has a simlpe and claean example. 
<a href=""https://www.tutorialspoint.com/c_standard_library/c_function_scanf.htm"" rel=""nofollow"">https://www.tutorialspoint.com/c_standard_library/c_function_scanf.htm</a></p>
",1
41207094,41207076,0,"<p>When you enter 5 and press enter which is ""\n"" then ""\n"" remains in stream and gets assigned to <code>str1</code>. You need to take that ""\n"" out of the input stream for which many choices are there. You can figure that out. :) Perhaps later I will edit this answer to let you know.</p>

<p>Edit 1:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main()
{
    int length;
    char c;
    printf(""Enter the length of the string:\t"");
    scanf(""%d%c"",&amp;length, &amp;c);

    char str1[10];
    printf(""Enter string:\t"");
    gets(str1);
    printf(""%s"",str1);
    return 0;
}
</code></pre>

<p>This is incorrect way of doing it but your code will at least start working. You can also simply call <code>getc(stdin)</code> which is slightly better. The <code>scanf</code> regex specified in the other answers where it has been marked as duplicate will also work but is ugly and unnecessarily complicated.</p>

<p>I have not tested this and it may not work.</p>
",1
41207138,41207076,0,"<p>When you type '5¡¯ followed by the enter key, you are sending two chars to the program - '5' and newline. So your first <code>scanf</code> gets the '5' and the second gets the newline, which it converts to the number zero.</p>

<p>See <a href=""https://stackoverflow.com/questions/314401/how-to-read-a-line-from-the-console-in-c"">How to read a line from the console in C?</a></p>
",0
35288344,35282666,1,"<p>""<a href=""https://en.wikipedia.org/wiki/Endianness"" rel=""nofollow"">Endianness</a>"" of a CPU is a property of the physical architecture of the CPU of a computer.  </p>

<p>Intel x86 compatible CPUs are little endian, which means that when storing a multi-byte integer in memory, the <strong>least</strong> significant byte is stored in the <strong>lower</strong> memory address.  This seems ""backwards"" to a human's typical way of thinking about numbers.  If you were to view a hex dump of the 32-bit integer <strong>0xaabbccdd</strong> from little endian machine then you's see it from left to right as <code>ddccbbaa</code>.</p>

<p>On big endian machines (Sun Sparc for instance) the same hex dump would contain <code>aabbccdd</code> which seems more intuitive to most people.</p>

<p>The reason that little endianness exists is primarily down to the way that the architecture is implemented in CPU manufacture.  That's beyond the scope of this question.</p>

<p>Normally a programmer doesn't have to think about endianness unless they are doing peculiar, esoteric things.  Well written C code can usually be compiled for big or little endian machines without having to take this difference into account, as the compiler knows how to cope with it itself.</p>

<p><code>char</code> on the other hand is a single byte long and therefore it is represented left-to-right on all CPUs, regardless of endianness.</p>

<p>Edit: here's a short program to tell you the endianness of any computer you run it on...</p>

<p>Compile this with:   <strong>gcc -pedantic -std=c99 main.c</strong></p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;inttypes.h&gt;

int main()
{
  uint8_t i[4]  = {0xAA, 0xBB, 0xCC, 0xDD};

  //deliberately casting this to a void* because we're interested in the hardware
  //storage order of the individual bytes...
  uint32_t* ptr = (void*) &amp;i[0];

  switch(*ptr)
  {
    case 0xAABBCCDD:
      printf(""BIG endian."");
      break;

    case 0xDDCCBBAA:
      printf(""LITTLE endian."");
      break;

    case 0xBBAADDCC:
      printf(""MIDDLE endian (am I a PDP-11?)."");
      break;

    default:
      printf(""WARNING -- unknown endianness!"");
      break;
  }

  printf(""  0x%08X\n"", *ptr);

  return 0;
}
</code></pre>
",1
41200889,41200849,1,"<p>Write a separate function and use it in the loop condition. For example</p>

<pre><code>#include &lt;ctype.h&gt;

//...

int valid_name( const char *name )
{
    while ( *name &amp;&amp; isalpha( ( unsigned char )*name ) ) ++name;

    return *name == '\0';
}

//...

do
{
    //...
} while ( !valid_name( name ) );
</code></pre>
",5
37627956,37627929,1,"<p><code>scanf</code> with the argument <code>""%s""</code> reads one word, up to the first space or tab or newline, and will not include any <code>\n</code> character in the input. Your loop will never end. Or, more accurately, it will give what the C standard calls ""undefined behaviour"". In practice, it means that it will keep looping until it either finds a newline somewhere in memory (perhaps 817 places from the start!), or reaches the end of allocated memory and crashes.</p>
",0
37627962,37627929,1,"<p>scanf reads input till <code>\n</code> but not including it So :</p>

<pre><code>while ( sentence[number] != '\n' ) // always true for legal array bound
</code></pre>

<p>will lead to illegal memory access, causing undefined behavior. If you do wish to read the string including the <a href=""http://www.tutorialspoint.com/c_standard_library/c_function_isspace.htm"" rel=""nofollow"">[ white-space ]</a> characters, use <a href=""http://www.cplusplus.com/reference/cstdio/fgets/"" rel=""nofollow"">[ fgets ]</a>.</p>

<p>If you wish to count the number of characters, change the <code>while</code> loop to</p>

<pre><code>while ( sentence[number] != '\0' )
</code></pre>
",0
37627974,37627929,1,"<p>If you read the <a href=""http://linux.die.net/man/3/scanf"" rel=""nofollow"">manual page</a> the function <code>scanf</code> does not read white space.</p>

<p>Perhaps <a href=""http://linux.die.net/man/3/fgets"" rel=""nofollow"">fgets</a> would be a better choice along with changing the while loop to</p>

<pre><code>while (sentence[number] != 0 &amp;&amp; sentence[number] != '\n')
</code></pre>
",0
37627984,37627929,0,"<p>Just change this line :</p>

<pre><code>while ( sentence[number] != '\n' )
</code></pre>

<p>to </p>

<pre><code>while ( sentence[number] != '\0' )
</code></pre>

<p>and <code>return 0</code> at the end</p>
",1
37628059,37627929,-2,"<p>Here is a better version of code to count the number of characters</p>

<pre><code>#include &lt;stdio.h&gt;
main(){
    double c;
    for(n=0; getchar() != EOF; ++n);
    printf(""%.0f\n"", n);
}
</code></pre>
",4
41659585,41659364,1,"<p>The way you have structured your loops, if any of the accepted random numbers before the last one is <code>99</code>, none of the remaining loops can terminate, since new acceptable numbers can not be less than <code>99</code>, or equal to <code>99</code>, or greater than <code>99</code>.</p>

<p>It would probably be simpler to generate an array filled with unique random numbers, sort, and then read these into your <code>struct</code>s. Note that the <code>in_list()</code> function is passed the count of random numbers already added to the list so that only these numbers are searched.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#include &lt;stdbool.h&gt;

bool in_list(int num, int arr[], size_t list_sz)
{
    size_t i;
    for (i = 0; i &lt; list_sz; i++) {
        if (arr[i] == num) {
            break;
        }
    }

    return i &lt; list_sz ? true : false;
}

int compare(const void *x, const void *y) {
    const int *cx = (const int *) x;
    const int *cy = (const int *) y;

    return (*cx &gt; *cy) - (*cx &lt; *cy);
}

int main(void)
{
    int random_numbers[10];
    int num;

    srand(time(NULL));

    for (size_t i = 0; i &lt; 10; i++) {
        do {
            num = rand() % 100;
        }while (in_list(num, random_numbers, i));
        random_numbers[i] = num;
    }

    qsort(random_numbers, 10, sizeof(int), compare);

    for (size_t i = 0; i &lt; 10; i++) {
        printf(""%d\n"", random_numbers[i]);
    }

    return 0;
}
</code></pre>

<p>Sample output:</p>

<pre><code>0
19
20
29
30
56
58
72
82
86
</code></pre>
",1
39678948,39678918,6,"<p>Your problems are all due to floating point imprecision: binary floating point cannot be precisely converted to and from decimal notation.</p>

<p>It happens that 0.25 can be represented exactly in floating point: as can many of its multiples. But 0.1 cannot. So your incrementing by these amounts will give you unexpected behaviour.</p>

<p>Your best bet in this case is to use integral types throughout and work in cents.</p>
",0
40552046,40551971,4,"<p>You need to dig out your operator precedence table.</p>

<p><code>*p++</code> is evaluated as <code>*(p++)</code></p>

<p><code>++*p</code> is evaluated as <code>++(*p)</code></p>

<p>The second one is due to the prefix <code>++</code> having the same precedence as pointer dereference <code>*</code> so <em>associativity</em> (which is from right to left for those operators) comes into play.</p>

<p>For completeness' sake, <code>*(p++)</code> dereferences the current value of <code>p</code>, and <code>p</code> is increased by one once the statement completes. <code>++(*p)</code> adds 1 to the data pointed to by <code>p</code>.</p>
",1
40552405,40551971,0,"<p>You have two things going on here:</p>

<ul>
<li><p>The different semantics between prefix and postfix <code>++</code>;</p></li>
<li><p>Different precedence of prefix and postfix operators.</p></li>
</ul>

<p>Postfix operators have higher precedence than unary (prefix) operators, so the expression <code>*p++</code> is parsed as <code>*(p++)</code> - you're applying the <code>*</code> operator to the result of <code>p++</code>.  By contrast, the prefix <code>++</code> operator and unary <code>*</code> have the same precedence, so the expression <code>++*p</code> is parsed as <code>++(*p)</code> - you're applying the <code>++</code> operator to the result of <code>*p</code>. </p>

<p>Also remember that prefix and postfix <code>++</code> have slightly different behavior.  Both increment their operand as a side effect, but the <em>result</em> of postfix <code>++</code> is the current value of the operand, while the result of prefix <code>++</code> is the value of the operand plus 1.</p>
",0
43748160,43747898,3,"<p>In C, if you want a function to modify the value of an object (such as <code>a</code> in the <code>scanf</code> call), you must pass a <em>pointer to</em> that object.  A pointer is any expression that evaluates to the <em>location</em> of an object in memory.  In this case, the pointer to <code>a</code> is obtained by using the unary <code>&amp;</code> operator:</p>

<pre><code>scanf( ""%d"", &amp;a ); // write an integer value to a
</code></pre>

<p>You can create a pointer variable that serves much the same purpose:</p>

<pre><code>int a;
int *p = &amp;a;       // the object p stores the location of a
                   // p points to a

scanf( ""%d"", p );  // also writes an integer value to a through the pointer p
                   // note no &amp; here because p is already a pointer type
</code></pre>

<p>If you just want to pass an object's value to a function, you wouldn't use the <code>&amp;</code> operator:</p>

<pre><code>printf( ""%d"", a ); // write the value stored in a to standard output, 
                   // formatted as a decimal integer
</code></pre>

<p>If you have a pointer, and you want the value of the thing the pointer points to, you'd use the unary <code>*</code> operator:</p>

<pre><code>printf( ""%d"", *p ); // write the value stored in a to standard output,
                    // going through the pointer p
</code></pre>

<p>To summarize,</p>

<pre><code> p == &amp;a  // int * == int *
*p ==  a  // int   == int
</code></pre>
",1
36305198,36293939,0,"<p>apparently I was not reallocating enough memory, this is my working code:</p>

<pre><code>    char **temp = realloc(words, (sizeof(char *) * number_of_words +1));
</code></pre>
",0
36294009,36293939,4,"<p><code>realloc</code> may return a new pointer where more space has been allocated.</p>

<pre><code>char **temp = realloc(words, (sizeof(char *) * number_of_words));
if(temp == NULL) {
    //realloc failed.
    perror(""realloc"");
    exit(EXIT_FAILURE);
}
words = temp;
</code></pre>
",4
36294122,36293939,4,"<p><code>realloc(words, (sizeof(char *) * number_of_words));</code></p>

<p>Be careful of the nuance regarding <code>realloc</code>, always use a temporary pointer. If <code>realloc</code> fails, the temporary pointer will be <code>NULL</code>.</p>

<p>Use this:</p>

<pre><code>char **words_temp = realloc(words, sizeof(char*) * number_of_words);
if (words_temp) words = words_temp;
else{
   // Whoops, memory reallocation failure.
}
</code></pre>

<p>Looking at the initialization as in the amended question:</p>

<pre><code>char **words;
words = malloc(9*sizeof(char *));
words[0] = malloc(strlen(""the""));
strcpy(words[0],""the"");
</code></pre>

<p><code>words[0]</code> has the supposedly, string 'the', then the following line, copy 'the' into the same pointer location, obviously, OP did not take into account of the terminating string character or NUL, and clobbered the memory pointer contained in the address of <code>words</code>. </p>

<pre><code>words[0] = malloc(strlen(""the"") + 1);
strcpy(words[0], ""the"")
</code></pre>

<p>Notice the difference? or for sanity, use <code>strdup</code> function which takes into account and will add an extra NUL character.</p>
",2
37761992,37761552,3,"<p>Because the standard says so. See <em>6.7.6.3p2</em>:</p>

<blockquote>
  <p>The only storage-class specifier that shall occur in a parameter declaration is <code>register</code>.</p>
</blockquote>

<p>Storage class specifiers usually don't make sense for function parameters.</p>
",6
38091468,37761552,1,"<p>All that the <code>static</code> keyword does in that program is it tells the compiler (essentially) 'hey, I have a variable here that I don't want anyone else accessing, don't tell anyone else it exists'.</p>

<blockquote>
  <p>The only storage-class specifier that shall occur in a parameter
  declaration is register.</p>
</blockquote>

<p><strong>strong text</strong></p>
",0
39667782,39667690,1,"<p>To test if a string is a valid floating point value, use <a href=""https://linux.die.net/man/3/strtod"" rel=""nofollow""><code>strtod</code></a>.  This function parses numeric strings with an optional decimal point and an optional exponent specifier (""e"" or ""E""):</p>

<pre><code>char *p;

errno = 0;
double f = strtod(str,&amp;p);
if (errno) {
    printf(""conversion failed"");
}
if (strlen(str)==0) {
    printf(""empty string\n"");
} else {
    printf(""f=%f\n"", f);
    if (*p == 0) {
        printf(""entire string valid\n"");
    } else {
        printf(""extra characters: %s\n"", p);
    }
}
</code></pre>
",12
39668325,39667690,0,"<p>Checking for correctness is just as hard as parsing it completely, there is no shortcut. I am reworking my arbitrary precision lib and one of things that is still an unholy mess is the string parsing, so I set down and did a (hopefully) proper implementation of a finite state machine (with some shortcuts, admitted.). Nearly 500 lines of code. I've used simple 'double's for testing (not for use, the errors are too large!), to be able to run some simple tests.</p>

<p>Please be aware that I allow octal numbers, too, with the same binary exponent and exponent marker <code>p</code> as the standardized hexadecimal numbers, <code>strtod</code> does not.</p>

<p>Oh, and I'm pretty sure it has some bugs.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

// for pow() only
#include &lt;math.h&gt;


#ifdef DEBUG
#   define PUTS(x) puts(x)
#else
#   define PUTS(x)
#endif


#define FSM_OK     1
#define FSM_ERROR  0

/*
   EBNF (ISO 14977) for the real numbers this code should be able to treat correctly.

   (* sign *)
   sign = '+'|'-';

   (* numbers starting with zero are octal, hence the special treatment for zero *)
   zero = '0';

   (* binary digit *)
   bindig = '1';
   (* binary integer *)
   binint = bindig , [{(zero | bindig)}];

   (* octal digit *);
   octdig = bindig|'2'|'3'|'4'|'5'|'6'|'7';
   (* octal integer *)
   octint = octdig , [{(zero | octdig)}];

   (* decimal digit *)
   decdig = octdig|'8'|'9';
   (* decimal integer *)
   decint = decdig , [{(zero | decdig)}];

   (* hexadecimal digit *)
   hexdig =  decdig |'A'|'B'|'C'|'D'|'E'|'F'|'a'|'b'|'c'|'e'|'f';
   (* hexadecimal integer *)
   hexint = hexdig , [{(zero | hexdig)}];

   (* prefix for the base; inclusion of octal numbers made it interesting *)
   prefix = '0';
   (* Implementing only the four main bases has been deemed sufficient *)
   binbase = prefix , ('B'|'b');
   octbase = prefix , octdig;
   hexbase = prefix , ('X'|'x');

   (* decimal point *)
   decpoint = '.';

   (* exponents *)
   expobin = ('P'|'p'), [sign], decint;
   expodec = ('E'|'e'), [sign], decint;

   (* thousands separator *)
   (* tsep = ','|'\''|'_'; *)

   (* ""xyz"", ""xyz."", ""xyz.zyx"", "".zyx"" *)   
   stubrealbin = binint | (binint, decpoint, [binint]) | (decpoint, binint);
   stubrealoct = octint | (octint, decpoint, [octint]) | (decpoint, octint);
   stubrealdec = decint | (decint, decpoint, [decint]) | (decpoint, decint);
   stubrealhex = hexint | (hexint, decpoint, [hexint]) | (decpoint, hexint);

   fullrealbin = [sign], binbase, stubrealbin, [expobin];
   fullrealoct = [sign], octbase, stubrealoct, [expobin];
   fullrealdec = [sign],          stubrealdec, [expodec];
   fullrealhex = [sign], hexbase, stubrealhex, [expobin];

   (* ""InF"" and ""NaN"" should be case insensitive in praxi *)
   real = ([sign], ""Inf"") | ""NaN"" | fullrealbin | fullrealoct | fullrealdec | fullrealhex;



   Input characters (grouped for clarity. Case sensitive for brevity only!).
   The input is case insensitive, so 'e', 'E', 'b', and 'B' are only
   distinguishable by context: once you have hexdigits 'e' and 'b' are hexdigits
   and a following sign must trigger an error

   '0'
   '1'                     = bin
   '2'|'3'|'4'|'5'|'6'|'7' = oct
   '8'|'9'                 = dec
   'A'|   |'C'|'D'    |'F' = hex
   'x'
   'b'
   'e'
   'p'
   '.'
   '+' | '-'               = sgn

   Any other input character is not valid (state: ERROR), ""Inf"" and ""NaN"" get handled
   elsewhere to keep things simple.


   States

   START
   SIGN
   PREFIX
   DECPOINT
   DECFRAC
   BINBASE
   OCTBASE
   DECBASE
   HEXBASE
   BINFRAC
   OCTFRAC
   HEXFRAC
   EXPOMARK
   EXPOSIGN
   EXPONENT
   ERROR

   Transition table

   START   '0'  it is a prefix              PREFIX
           bin  it is a binary digit        DECBASE
           oct  it is an octal digit        DECBASE
           dec  it is a decimal digit       DECBASE
           hex  it is a hexadecimal digit   HEXBASE
           'x'  cannot be                   ERROR
           'b'  it is a hexadecimal digit   HEXBASE
           'e'  it is a hexadecimal digit   HEXBASE
           'p'  cannot be                   ERROR
           '.'  a decimal point             DECPOINT (!)
           sgn  a sign                      SIGN

   SIGN   '0'   it is a prefix              PREFIX
           bin  it is a binary digit        DECBASE
           oct  it is an octal digit        DECBASE
           dec  it is a decimal digit       DECBASE
           hex  it is a hexadecimal digit   HEXBASE
           'x'  cannot be                   ERROR
           'b'  it is a hexadecimal digit   HEXBASE
           'e'  it is a hexadecimal digit   HEXBASE
           'p'  cannot be                   ERROR
           '.'  a decimal point             DECPOINT (!)
           sgn  a sign                      ERROR

   PREFIX  '0'  zero                        OCTBASE
           bin  binary digit                OCTBASE
           oct  octal digit                 OCTBASE
           dec  cannot be                   ERROR
           hex  cannot be                   ERROR
           'x'  hexadecimal number          HEXBASE
           'b'  binary number               BINBASE
           'e'  cannot be                   ERROR
           'p'  cannot be                   ERROR
           '.'  decimal point               DECFRAC
           sgn  cannot be                   ERROR

   The only place, that is still lingering in limbo is the decimal point. We
   need to fork again, but we do not know in which base the integral part (if one
   exists at all) is, so we still take ""decimal"" to be the default base.


   DECPOINT '0'  binary digit               DECFRAC
            bin  binary digit               DECFRAC
            oct  octal digit                DECFRAC
            dec  decimal digit              DECFRAC
            hex  hexadecimal digit          HEXFRAC
            'x'  cannot be                  ERROR
            'b'  hexadecimal digit          HEXFRAC
            'e'  hexadecimal digit          HEXFRAC
            'p'  binary exponent            EXPOMARK
            '.'  decimal point              ERROR
            sgn  cannot be                  ERROR

   A fractional part in decimal base is simple enough

   DECFRAC '0'   binary digit               DECFRAC
            bin  binary digit               DECFRAC
            oct  octal digit                DECFRAC
            dec  decimal digit              DECFRAC
            hex  cannot be                  ERROR
            'x'  cannot be                  ERROR
            'b'  cannot be                  ERROR
            'e'  exponent delimiter         EXPOMARK
            'p'  cannot be                  ERROR
            '.'  cannot be                  ERROR
            sgn  cannot be                  ERROR

   All other fractions need a base, so handle bases first

   BINBASE '0'   binary digit               BINBASE
            bin  binary digit               BINBASE
            oct  cannot be                  ERROR
            dec  cannot be                  ERROR
            hex  cannot be                  ERROR
            'x'  cannot be                  ERROR
            'b'  cannot be                  ERROR
            'e'  cannot be                  ERROR
            'p'  exponent delimiter         EXPOMARK
            '.'  decimal point              BINFRAC
            sgn  cannot be                  ERROR

   OCTBASE  '0'  binary digit               OCTBASE
            bin  binary digit               OCTBASE
            oct  octal digit                OCTBASE
            dec  cannot be                  ERROR
            hex  cannot be                  ERROR
            'x'  cannot be                  ERROR
            'b'  cannot be                  ERROR
            'e'  cannot be                  ERROR
            'p'  exponent delimiter         EXPOMARK
            '.'  decimal point              OCTFRAC
            sgn  cannot be                  ERROR

   HEXBASE  '0'  binary digit               HEXBASE
            bin  binary digit               HEXBASE
            oct  octal digit                HEXBASE
            dec  decimal digit              HEXBASE
            hex  hexadecimal digit          HEXBASE
            'x'  cannot be                  ERROR
            'b'  cannot be                  ERROR
            'e'  cannot be                  ERROR
            'p'  exponent delimiter         EXPOMARK
            '.'  decimal point              HEXFRAC
            sgn  cannot be                  ERROR

   It is easy now to fill the gaps.

   BINFRAC '0'   binary digit               BINFRAC
            bin  binary digit               BINFRAC
            oct  cannot be                  ERROR
            dec  cannot be                  ERROR
            hex  cannot be                  ERROR
            'x'  cannot be                  ERROR
            'b'  cannot be                  ERROR
            'e'  cannot be                  ERROR
            'p'  exponent delimiter         EXPOMARK
            '.'  cannot be                  ERROR
            sgn  cannot be                  ERROR

   OCTFRAC  '0'  binary digit               OCTFRAC
            bin  binary digit               OCTFRAC
            oct  octal digit                OCTFRAC
            dec  cannot be                  ERROR
            hex  cannot be                  ERROR
            'x'  cannot be                  ERROR
            'b'  cannot be                  ERROR
            'e'  cannot be                  ERROR
            'p'  exponent delimiter         EXPOMARK
            '.'  cannot be                  ERROR
            sgn  cannot be                  ERROR

   HEXFRAC  '0'  binary digit               HEXFRAC
            bin  binary digit               HEXFRAC
            oct  octal digit                HEXFRAC
            dec  decimal digit              HEXFRAC
            hex  hexadecimal digit          HEXFRAC
            'x'  cannot be                  ERROR
            'b'  hexadecimal digit          HEXFRAC
            'e'  hexadecimal digit          HEXFRAC
            'p'  exponent delimiter         EXPOMARK
            '.'  decimal point              ERROR
            sgn  cannot be                  ERROR

   The exponent is always encoded in decimal base (IEEE 754 (ISO/IEC 60559) sec. 5.12.3 for
   the hexadecimal example)

   EXPOMARK '0'  binary digit               EXPONENT
            bin  binary digit               EXPONENT
            oct  octal digit                EXPONENT
            dec  decimal digit              EXPONENT
            hex  cannot be                  ERROR
            'x'  cannot be                  ERROR
            'b'  cannot be                  ERROR
            'e'  cannot be                  ERROR
            'p'  cannot be                  ERROR
            '.'  cannot be                  ERROR
            sgn  sign                       EXPOSIGN

   EXPOSIGN '0'  binary digit               EXPONENT
            bin  binary digit               EXPONENT
            oct  octal digit                EXPONENT
            dec  decimal digit              EXPONENT
            hex  cannot be                  ERROR
            'x'  cannot be                  ERROR
            'b'  cannot be                  ERROR
            'e'  cannot be                  ERROR
            'p'  cannot be                  ERROR
            '.'  cannot be                  ERROR
            sgn  sign                       ERROR

   EXPONENT '0'  binary digit               EXPONENT
            bin  binary digit               EXPONENT
            oct  octal digit                EXPONENT
            dec  decimal digit              EXPONENT
            hex  cannot be                  ERROR
            'x'  cannot be                  ERROR
            'b'  cannot be                  ERROR
            'e'  cannot be                  ERROR
            'p'  cannot be                  ERROR
            '.'  cannot be                  ERROR
            sgn  sign                       ERROR

   ERROR    nothing follows an error, only more ERROR

   Nothing marking an end-state, it is just the end of the input buffer


ZERO     '0'
BINDIG   '1'
OCTDIG   '2'|'3'|'4'|'5'|'6'|'7'
DECDIG   '8'|'9'
HEXDIG   'A'|   |'C'|'D'    |'F'
PREHEX   'x'
PREBIN   'b'
EXPDEC   'e'
EXPBIN   'p'
DECPNT   '.'
SGNCHR     '+' | '-'

           ZERO   BINDIG  OCTDIG  DECDIG  HEXDIG PREHEX  PREBIN  EXPDEC   EXPBIN  DECPNT   SGNCHR
START     PREFIX  DECBASE DECBASE DECBASE HEXBASE ERROR  HEXBASE HEXBASE  ERROR   DECPOINT SIGN
SIGN      PREFIX  DECBASE DECBASE DECBASE HEXBASE ERROR  HEXBASE HEXBASE  ERROR   DECPOINT ERROR
PREFIX    OCTBASE OCTBASE OCTBASE  ERROR   ERROR HEXBASE BINBASE  ERROR   ERROR   DECFRAC  ERROR
DECPOINT  DECFRAC DECFRAC DECFRAC DECFRAC HEXFRAC ERROR  HEXFRAC HEXFRAC  EXPOMARK ERROR   ERROR
DECFRAC   DECFRAC DECFRAC DECFRAC DECFRAC  ERROR  ERROR   ERROR  EXPOMARK ERROR    ERROR   ERROR
BINBASE   BINBASE BINBASE  ERROR   ERROR   ERROR  ERROR   ERROR   ERROR   EXPOMARK BINFRAC ERROR
OCTBASE   OCTBASE OCTBASE OCTBASE  ERROR   ERROR  ERROR   ERROR   ERROR   EXPOMARK OCTFRAC ERROR
DECBASE   DECBASE DECBASE DECBASE  ERROR   ERROR  ERROR   ERROR  EXPOMARK ERROR    DECFRAC ERROR
HEXBASE   HEXBASE HEXBASE HEXBASE HEXBASE HEXBASE ERROR   ERROR   ERROR   EXPOMARK HEXFRAC ERROR
BINFRAC   BINFRAC BINFRAC  ERROR   ERROR   ERROR  ERROR   ERROR   ERROR   EXPOMARK ERROR   ERROR
OCTFRAC   OCTFRAC OCTFRAC OCTFRAC  ERROR   ERROR  ERROR   ERROR   ERROR   EXPOMARK ERROR   ERROR
HEXFRAC   HEXFRAC HEXFRAC HEXFRAC HEXFRAC HEXFRAC ERROR  HEXFRAC HEXFRAC  EXPOMARK ERROR   ERROR
EXPOMARK  EXPON'T EXPON'T EXPON'T EXPON'T  ERROR  ERROR   ERROR   ERROR   ERROR    ERROR   EXPOSIGN
EXPOSIGN  EXPON'T EXPON'T EXPON'T EXPON'T  ERROR  ERROR   ERROR   ERROR   ERROR    ERROR   ERROR
EXPONENT  EXPON'T EXPON'T EXPON'T EXPON'T  ERROR  ERROR   ERROR   ERROR   ERROR    ERROR   ERROR
ERROR     ERROR   ERROR    ERROR   ERROR   ERROR  ERROR   ERROR   ERROR   ERROR    ERROR   ERROR
*/


#if !(defined _BSD_SOURCE || defined _DEFAULT_SOURCE || _POSIX_C_SOURCE &gt;= 200112L)
#   include &lt;ctype.h&gt;
static int strncasecmp(const char *s1, const char *s2, size_t n)
{
  char c1 = 0;
  char c2 = 0;

  while (n--) {
    c1 = tolower(*s1);
    c2 = tolower(*s2);

    if (c1 != c2) {
      break;
    }
    if (c1 == '\0') {
      break;
    }
    s1++;
    s2++;
  }
  return (int) (c1 - c2);
}
#endif

#ifdef _MSC_VER
#define strncasecmp(x,y,z) _strnicmp(x,y,z)
#endif


enum fsm_input {
  ZERO,                         // '0'
  BINDIG,                       // '1'
  OCTDIG,                       // '2'|'3'|'4'|'5'|'6'|'7'
  DECDIG,                       // '8'|'9'
  HEXDIG,                       // 'A'    |'C'|'D'    |'F'
  PREHEX,                       // 'x'
  PREBIN,                       // 'b'
  EXPDEC,                       // 'e'
  EXPBIN,                       // 'p'
  DECPNT,                       // '.'
  SGNCHR,                       // '+' | '-'
  OTHER
};

enum fsm_states {
  START,
  SIGN,
  PREFIX,
  DECPOINT,
  DECFRAC,
  BINBASE,
  OCTBASE,
  DECBASE,
  HEXBASE,
  BINFRAC,
  OCTFRAC,
  HEXFRAC,
  EXPOMARK,
  EXPOSIGN,
  EXPONENT,
  ERROR
};

#ifdef DEBUG
static const char *st2str[16] = {
  ""START"",
  ""SIGN"",
  ""PREFIX"",
  ""DECPOINT"",
  ""DECFRAC"",
  ""BINBASE"",
  ""OCTBASE"",
  ""DECBASE"",
  ""HEXBASE"",
  ""BINFRAC"",
  ""OCTFRAC"",
  ""HEXFRAC"",
  ""EXPOMARK"",
  ""EXPOSIGN"",
  ""EXPONENT"",
  ""ERROR""
};
#endif
// transition-table
static int fsm_table[16][11] = {
  {PREFIX, DECBASE, DECBASE, DECBASE, HEXBASE, ERROR, HEXBASE, HEXBASE, ERROR,
   DECPOINT, SIGN},
  {PREFIX, DECBASE, DECBASE, DECBASE, HEXBASE, ERROR, HEXBASE,
   HEXBASE, ERROR, DECPOINT, ERROR},
  {OCTBASE, OCTBASE, OCTBASE, ERROR, ERROR, HEXBASE, BINBASE, ERROR, ERROR,
   DECFRAC,
   ERROR},
  {DECFRAC, DECFRAC, DECFRAC, DECFRAC, HEXFRAC, ERROR, HEXFRAC, HEXFRAC,
   EXPOMARK, ERROR, ERROR},
  {DECFRAC, DECFRAC, DECFRAC, DECFRAC, ERROR, ERROR, ERROR, EXPOMARK, ERROR,
   ERROR, ERROR},
  {BINBASE, BINBASE, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, EXPOMARK,
   BINFRAC, ERROR},
  {OCTBASE, OCTBASE, OCTBASE, ERROR, ERROR, ERROR, ERROR, ERROR, EXPOMARK,
   OCTFRAC, ERROR},
  {DECBASE, DECBASE, DECBASE, ERROR, ERROR, ERROR, ERROR, EXPOMARK, ERROR,
   DECFRAC, ERROR},
  {HEXBASE, HEXBASE, HEXBASE, HEXBASE, HEXBASE, ERROR, ERROR, ERROR, EXPOMARK,
   HEXFRAC, ERROR},
  {BINFRAC, BINFRAC, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, EXPOMARK, ERROR,
   ERROR},
  {OCTFRAC, OCTFRAC, OCTFRAC, ERROR, ERROR, ERROR, ERROR, ERROR, EXPOMARK,
   ERROR, ERROR},
  {HEXFRAC, HEXFRAC, HEXFRAC, HEXFRAC, HEXFRAC, ERROR, HEXFRAC, HEXFRAC,
   EXPOMARK, ERROR, ERROR},
  {EXPONENT, EXPONENT, EXPONENT, EXPONENT, ERROR, ERROR, ERROR, ERROR, ERROR,
   ERROR, EXPOSIGN},
  {EXPONENT, EXPONENT, EXPONENT, EXPONENT, ERROR, ERROR, ERROR, ERROR, ERROR,
   ERROR, ERROR},
  {EXPONENT, EXPONENT, EXPONENT, EXPONENT, ERROR, ERROR, ERROR, ERROR, ERROR,
   ERROR, ERROR},
  {ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR, ERROR}
};


#include &lt;ctype.h&gt;
static int check_type(char c)
{
  int type;
  switch (tolower(c)) {
    case '0':
      type = ZERO;
      break;
    case '1':
      type = BINDIG;
      break;
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
      type = OCTDIG;
      break;
    case '8':
    case '9':
      type = DECDIG;
      break;
    case 'a':
    case 'c':
    case 'd':
    case 'f':
      type = HEXDIG;
      break;
    case 'x':
      type = PREHEX;
      break;
    case 'b':
      type = PREBIN;
      break;
    case 'e':
      type = EXPDEC;
      break;
    case 'p':
      type = EXPBIN;
      break;
    case '.':
      type = DECPNT;
      break;
    case '+':
    case '-':
      type = SGNCHR;
      break;
    default:
      type = OTHER;
      break;
  };
  return type;
}

// some variables to hold the relevant parts of a real number
static int main_sign = 1;
static int expo_sign = 1;

static double integral_part = 0.0;
static double fractional_part = 0.0;
static int hex_frac = 0;
static int dec_frac = 0;
static int oct_frac = 0;
static int bin_frac = 0;

static int exponent_part = 0;
// flags with both a boolean and a numerical value
// prob. not the best idea but simple
#define DECIMAL_EXP 10
#define BINARY_EXP   2
static int exponent_binordec = 0;

// assuming ASCII. Full map for more bases in the future.
// Far future.
static const char digit_map[] = {
    -1, -1, -1, -1, -1, -1, -1, -1,     //  0x00-0x07
    -1, -1, -1, -1, -1, -1, -1, -1,     //  0x08-0x0f
    -1, -1, -1, -1, -1, -1, -1, -1,     //  0x10-0x17
    -1, -1, -1, -1, -1, -1, -1, -1,     //  0x18-0x1f
    -1, -1, -1, -1, -1, -1, -1, -1,     //  0x20-0x27
    -1, -1,  1, -1, -1, -1, -1, -1,     //  0x28-0x2f '+' = 0x2b, '-' = 0x2d
     0,  1,  2,  3,  4,  5,  6,  7,     //  0x30-0x37
     8,  9, -1, -1, -1, -1, -1, -1,     //  0x38-0x3F
    -1, 10, 11, 12, 13, 14, 15, -1,     //  0x40-0x47
    -1, -1, -1, -1, -1, -1, -1, -1,     //  0x48-0x4f
    -1, -1, -1, -1, -1, -1, -1, -1,     //  0x50-0x57
    -1, -1, -1, -1, -1, -1, -1, -1,     //  0x58-0x5f
    -1, 10, 11, 12, 13, 14, 15, -1,     //  0x60-0x67
    -1, -1, -1, -1, -1, -1, -1, -1,     //  0x68-0x6f
    -1, -1, -1, -1, -1, -1, -1, -1,     //  0x70-0x77
    -1, -1, -1, -1, -1, -1, -1, -1      //  0x78-0x7f
};


static int fsm(char input, int *state)
{
  int res = FSM_OK;

  input = tolower(input);
#ifdef DEBUG
  printf(""INPUT: %c [0x%2x] (%d)  STATE: %-10s\n"", input, input,digit_map[+input],st2str[*state]);
#endif
  switch (*state) {
    case START:
      fprintf(stderr,
              ""Something is messed up in quite some hefty way and form!\n"");
      exit(EXIT_FAILURE);
    case SIGN:
      main_sign = digit_map[+input];
      break;
    case PREFIX:
      // not used
      break;
    case DECPOINT:
      // not used
      break;
    case DECBASE:
      integral_part *= 10.0;
      integral_part += digit_map[+input];
      break;
    case BINBASE:
      integral_part *= 2.0;
      integral_part += digit_map[+input];
      break;
    case OCTBASE:
      integral_part *= 8.0;
      integral_part += digit_map[+input];
      break;
    case HEXBASE:
      if (input == 'x') {
        break;
      }
      integral_part *= 16.0;
      integral_part += digit_map[+input];
      break;
    case BINFRAC:
      if (input == '.') {
        break;
      }
      fractional_part *= 2.0;
      fractional_part += digit_map[+input];
      bin_frac++;
      break;
    case OCTFRAC:
      if (input == '.') {
        break;
      }
      fractional_part *= 8.0;
      fractional_part += digit_map[+input];
      oct_frac++;
      break;
    case DECFRAC:
      if (input == '.') {
        break;
      }
      fractional_part *= 10.0;
      fractional_part += digit_map[+input];
      dec_frac++;
      break;
    case HEXFRAC:
      if (input == '.') {
        break;
      }
      fractional_part *= 16.0;
      fractional_part += digit_map[+input];
      hex_frac++;
      break;
    case EXPOMARK:
      exponent_binordec = (input == 'e') ? DECIMAL_EXP : BINARY_EXP;
      break;
    case EXPOSIGN:
      expo_sign = digit_map[+input];
      break;
    case EXPONENT:
      exponent_part *= 10;
      exponent_part += digit_map[+input];
      break;
    case ERROR:
      fprintf(stderr, ""ERROR state reached\n"");
      exit(EXIT_FAILURE);
      // ""Run in circles, scream and shout!""
      // Infantry Journal, Vol. 35, p. 396, United States Infantry Association, 1929
      // Or was it Herman Wouk? The Caine Mutiny? No, that would be 1951 and too late.
      break;
    default:
      fprintf(stderr, ""Unexpected state with input %c\n"", input);
      *state = ERROR;
      res = FSM_ERROR;
      break;
  }
  return res;
}

static char *trim_both(char *s)
{
  char *end,*p;
  p = s;
  while (isspace(*p)) {
    p++;
  }
  if (*p == '\0') {
    return p;
  }
  end = p + strlen(p) - 1;
  while (end &gt; p &amp;&amp; isspace(*end)) {
    end--;
  }
  *(end + 1) = '\0';
  return p;
}

static int str2dbl(char *s, double *d)
{
  int cur_state = START;
  int type;
  int res;

  s = trim_both(s);

  if(*s == '\0'){
     // empty input, would an error be better?
     *d = 0.0;
     return FSM_OK;
  }

  if(*s == '0' &amp;&amp; *(s+1) == '\0'){
     *d = 0.0;
     return FSM_OK;
  }

  if (!strncasecmp(s, ""-inf"", 4)) {
    *d = -INFINITY;
    return FSM_OK;
  }
  if (!strncasecmp(s, ""+inf"", 4) || !strncasecmp(s, ""inf"", 3)) {
    *d = INFINITY;
    return FSM_OK;
  }
  if (!strncasecmp(s, ""-nan"", 4) || !strncasecmp(s, ""+nan"", 4) || !strncasecmp(s, ""nan"", 3) ) {
    *d = NAN;
    return FSM_OK;
  }

  while (*s != '\0') {
    type = check_type(*s);
    if (type == OTHER) {
      fprintf(stderr, ""OTHER: %c"", *s);
      return FSM_ERROR;
    }

    cur_state = fsm_table[cur_state][type];
    res = fsm(*s, &amp;cur_state);
    if (res != FSM_OK) {
      break;
    }
    s++;
  }

  printf(""exp; %d, intp: %.20g, fracp: %.20g\n"", exponent_part, integral_part,
         fractional_part);

  // The following will work with arbitray precision in production, use of
  // a ""double"" is just for testing and not for real use. The error is
  // larger than one ulp in way too many times

  // the integral part needs no treatment, yet.
  *d += integral_part;

  // the fractional part needs to be shifted by the base to the right
  if (hex_frac &gt; 0) {
    fractional_part /= pow(16, hex_frac);
  } else if (dec_frac &gt; 0) {
    fractional_part /= pow(10, dec_frac);
  } else if (oct_frac &gt; 0) {
    fractional_part /= pow(8, oct_frac);
  } else if (bin_frac &gt; 0) {
    fractional_part /= pow(2, bin_frac);
  }
  printf(""fracp: %.20g\n"", fractional_part);
  *d += fractional_part;

  // (exponent_binordec != 0) also means that there is an exponent in the first place
  if (exponent_binordec) {
    if (expo_sign &gt;= 0) {
      *d *= pow(exponent_binordec, exponent_part);
    } else {
      *d /= pow(exponent_binordec, exponent_part);
    }
  }
  *d *= main_sign;
  return FSM_OK;
}

int main(int argc, char **argv)
{
  int res;
  char *input, *endptr;
  double out, libc;

  if (argc != 2) {
    fprintf(stderr, ""Usage: %s float\n"", argv[0]);
    exit(EXIT_FAILURE);
  }

  input = malloc(strlen(argv[1]) + 1);
  if (input == NULL) {
    fprintf(stderr, ""Malloc failed to allocate a measly %zu bytes\n"",
            strlen(argv[1]) + 1);
    exit(EXIT_FAILURE);
  }
  strcpy(input, argv[1]);

  // all checks ommited!
  libc = strtod(input, &amp;endptr);
  printf(""\nINPUT: %s\t%g\t%s\n\n"", input, libc, endptr);
  out = 0.0;

  res = str2dbl(input, &amp;out);

  printf
      (""fsm returned %d and the result (if any) is: \n\tinp:  %s\n\town:  %.20g\n\tlibc: %.20g\n"",
       res, trim_both(input) ,out, libc);
  free(input);
  exit(EXIT_SUCCESS);
}
</code></pre>
",0
37767012,37765412,1,"<p>You seem to have a typo in your vertical handling</p>

<pre><code>   ...
   ships[7][1]= ships[5][1];
   ships[8][0]= ships[5][0]+3;
   ships[8][1]= ships[0][1];
                     ^^^^^^^
</code></pre>
",1
39651357,39651276,0,"<p>Because you use the <code>read</code> function to read user input, you're reading raw bytes as opposed to a string.  So what it read in doesn't include a null terminating byte, so you don't have a null terminated string since the buffer returned by <code>malloc</code> is uninitialized.</p>

<p>Use <code>calloc</code> instead of <code>malloc</code>, which returns a buffer initialized to all zeros.</p>

<pre><code>inBuf = calloc(BUF_SIZE + 1, 1);
</code></pre>

<p>Note that this leaves an extra byte for a terminating null character.</p>

<p>You should also be checking the return value of <code>read</code> for an error, and you shoudn't cast the return value of <code>malloc</code>/<code>calloc</code>/<code>realloc</code>.</p>

<p>Your output buffer size is also too small.  It should be at least the size of the input string plus the format string.</p>

<pre><code>outBuf = (char*) malloc(BUF_SIZE + 1 + strlen(fmt));
</code></pre>
",1
40543201,40542906,0,"<p>The type of the integer constant is int and when it is assigned to the type char, it is converted in an implementation-defined manner.</p>

<p>An implementation that satisfies your result works conceptually like this: add or subtract the range of the type (which is 256 in this case) from the value, until the value can be represented by the type.</p>

<p>Range of char in this case is: [-128,127] and 400 is not representable by type char.</p>

<p>Subtract 256, and the result 144 is still not representable.</p>

<p>Subtract again, and the result -112 is representable.</p>
",2
40543629,40542906,2,"<p>thank to all users.</p>

<p>from what that I saw in comments, I reached to this conclusion that will end all discussions.
there are 3 different way for representing signed types. </p>

<ol>
<li>signed magnitude</li>
<li>1's complement </li>
<li>2's complement</li>
</ol>

<p>and in all of these representations, if the most significant bit is 1 then the number is negative and if it is 0 then the number is positive.
therefore, in this question, my computer uses 2's complement. As a result, 10010000 is a representation in 2's complement. its value is equal to the negative of 01110000=112, so the real result is -112.</p>

<p>however, when the type is unsigned, then the value of 400 must transfer to representation in binary but only there is enough space for 8 digits. Therefore, the representation will be 1001 0000 and since this is unsigned it is equal to 2^7+2^4=144.</p>
",1
44719904,44719789,0,"<p><code>%x</code> prints the hexadecimal representation of an unsigned integer. In this case the first character from <code>argv[2]</code> argument.</p>

<p>So if you pass a letter 'a' as your argument, the print output should be the hexadecimal representation of that character, e.g. ""61"" if ASCII encoding. And because you are printing only the first character you will see the same ""61"" printed even if your command line argument would be ""abc"".</p>

<p>Link to the reference: <a href=""http://en.cppreference.com/w/c/io/fprintf"" rel=""nofollow noreferrer"">http://en.cppreference.com/w/c/io/fprintf</a></p>
",4
44720044,44719789,2,"<p>In third <code>printf</code>, <code>argv[2]</code> points to the second command line argument after the name of the program.  In this case it is ""abc"".  </p>

<p>So <code>*argv[2]</code> dereferences that pointer to point to the first character in the string which is 'a'.  This syntax is the same as <code>argv[2][0]</code>.</p>

<p>The <code>%x</code> format specifier says to print its argument in hexadecimal format.  It's argument is <code>*argv[2]</code> which is 'a'.  Assuming ASCII encoding, the ASCII value for this character is 97 decimal or 61 hex.</p>

<p>So the third <code>printf</code> outputs ""61"".</p>
",0
44723321,44719789,-1,"<p><code>argv</code> is the sequence of command line arguments:</p>

<pre><code>argv[0] == ""./commandline"" 
argv[1] == ""123"" 
argv[2] == ""abc""
</code></pre>

<p>Each argument is a string (a zero-terminated array of <code>char</code>).  </p>

<p><code>*argv[2]</code> is equivalent to <code>argv[2][0]</code> - it evaluates to the first character of <code>argv[2]</code>, which is <code>'a'</code> (ASCII 97).  </p>

<p>The type of the expression <code>*argv[2]</code> is <code>char</code> - since <code>printf</code> is a variadic function, the type of the expression is ""promoted"" from <code>char</code> to <code>int</code>.  </p>

<p>The <code>%x</code> conversion specifier takes an <code>unsigned int</code> argument and formats the output as a hexadecimal integer; thus, that ASCII value of 97 is treated as an <code>unsigned int</code> and the output is the hexadecimal equivalent - <code>0x61</code>.  </p>
",1
37916746,37916441,1,"<p>""Segmentation fault"" means that you tried to access memory that you do not have access to.</p>

<p>There are four common mistakes that lead to segmentation faults: dereferencing NULL, dereferencing an uninitialized pointer, dereferencing a pointer that has been freed (or deleted, in C++) or that has gone out of scope (in the case of arrays declared in functions), and writing off the end of an array. </p>
",1
37916616,37916441,1,"<p>First issue, you are allocating 1 big buffer for the <code>mat</code> buffer, however, you are accessing it like a 2d array(row x col matrix). Fix the allocation try this:</p>

<pre><code>void mat_alloca (pmatrice m)
{
    m-&gt;mat = malloc(m-&gt;nrig * sizeof(*m-&gt;mat));
    if (m-&gt;mat == NULL) {
        perror(__func__);
        exit(1);
    }
// problem here:    m-&gt;mat[0] = calloc(m-&gt;nrig * m-&gt;ncol, sizeof(**m-&gt;mat));    
    int r;
    for (r = 0; r &lt; m-&gt;nrig; r++) {
        m-&gt;mat[r] = malloc(m-&gt;ncol * sizeof(int));
        if (m-&gt;mat[r] == NULL) {
            perror(__func__);
            exit(1);
        }
    }
}
</code></pre>

<p>Another issue is this typo in <code>mat_stampa</code> function, array index out of bound caused the segfault:</p>

<pre><code>void mat_stampa (pmatrice mat, FILE* f)
{
    int i, j;
    fprintf(f, ""%d %d\n"", mat-&gt;ncol, mat-&gt;nrig);
    for (i=0; i&lt;mat-&gt;nrig; i++){

        for(j=0; j&lt;mat-&gt;ncol; i++){ // &lt;=== here, should be j++ !!!

            fprintf(f, ""%2d "", mat-&gt;mat[i][j]);
        }
        fprintf(f,""\n"");
    }
    fprintf(f, ""\n"");
}
</code></pre>
",5
40958845,40957395,0,"<p>applying all the comments to the posted code and following the axiom: </p>

<p><em>only one statement per line and (at most) one variable declaration per statement.</em> </p>

<p>and checking the returned value from <code>scanf()</code> to assure the operation was successful </p>

<p>results in:</p>

<pre><code>#include &lt;stdio.h&gt; // scanf(), printf(), fprintf()
#include &lt;stdlib.h&gt; // exit(), EXIT_FAILURE

void getInteger(int *n);

int main( void )
{
    int n;
    int m;
    int p;
    getInteger(&amp;n);
    getInteger(&amp;m);
    p = n + m;

    printf(""p = %d"",p);
}

void getInteger(int *n)
{
    if( 1 != scanf(""%d"",n) )
    {
        fprintf( stderr, ""scanf failed"" );
        exit( EXIT_FAILURE );
    }
}
</code></pre>

<p>and when run with an input of: '1 3' the output is</p>

<pre><code>p = 4
</code></pre>
",0
40683872,40683633,0,"<p>Here is a sample code that will write those words that meet your required condition (words greater than a certain length) to a separate new file.</p>

<pre><code>int doRemove(int length)
{
        FILE *ptr_file;
        FILE *newFile;
        char buf[1000];

        ptr_file =fopen(""sample.txt"",""r"");
        newFile = fopen(""output.txt"",""w"");
        if (!ptr_file)
            return 1;

        while (fgets(buf,1000, ptr_file)!=NULL){
            if(strlen(buf) &gt; length){
              // remove it from this file 
            } else {
              // stay in this file &amp; print for debugging
              printf(""%s"",buf);
              fprintf(newFile, ""%s"", buf);
            }
        }

    fclose(ptr_file);
    fclose(newFile);
    return 0;
}
</code></pre>
",3
41924508,41924460,4,"<p>Your file has not been opened correctly. You are attempting to write to a NULL pointer here:</p>

<pre><code>fprintf(fileptr,""%d"", port);
</code></pre>

<p>Solution:</p>

<pre><code>fileptr = fopen(""server_port"", ""w"");
</code></pre>
",1
41924562,41924448,0,"<p>There might be other reasons as well, but the following fragment will crash for sure:</p>

<pre><code>for(j = 0; insert != '\0'; i++, j++)
{
    temp[i] = insert[j];
}
</code></pre>

<p>The reason is that - since <code>insert</code> will not be increased or manipulated - this is an endless loop writing ""indefinitely"" long into temp. Once exceeding its length <code>80</code> (or a bit later) it will crash. I suppose you meant <code>for(j = 0; insert[j] != '\0'; i++, j++)</code>, right?</p>
",0
41924566,41924448,0,"<p>Check all <code>for</code> loop conditions in <code>insertString</code> function. For example:</p>

<pre><code>for(j = 0; insert != '\0'; i++, j++)
{
    temp[i] = insert[j];
}
</code></pre>

<p>is infinite loop. Because of it you access memory out of <code>temp</code> array bounds. It causes UB and segmentation fault. Looks like you need <code>insert[j] != '\0'</code> condition here.</p>
",0
41927149,41924448,0,"<p>I'm familiar with this book. The author, Stephen Kochan, has a website with answers to the odd-numbered end of chapter exercises.</p>

<p>The website is at classroomm.com but you'll need to look around some to find the information.</p>

<p>Here is the info from that site related to this exercise:</p>

<blockquote>
  <p>Programming in C, exercise 10-7 (3rd edition) and 9-7 (4th edition)</p>
  
  <p>/* insert string s into string source starting at i
     This function uses the stringLength function defined
     in the chapter.</p>
  
  <p>Note: this function assumes source is big enough
           to store the inserted string (dangerous!)   */</p>

<pre><code>void  insertString (char  source[], char  s[], int  i)
{ 
int  j, lenS, lenSource;

/* first, find out how big the two strings are */

lenSource = stringLength (source);
lenS = stringLength (s);

/* sanity check here -- note that i == lenSource
  effectively concatenates s onto the end of source */

if (i &gt; lenSource)
    return;

/* now we have to move the characters in source
  down from the insertion point to make room for s.
  Note that we copy the string starting from the end
  to avoid overwriting characters in source.
  We also copy the terminating null (j starts at lenS) 
  as well since the final result must be null-terminated */

for ( j = lenSource;  j &gt;= i;  --j )
    source [lenS + j] = source [j];
</code></pre>
  
  <p>/* we've made room, now copy s into source at the 
        insertion point */</p>

<pre><code>for ( j = 0;  j &lt; lenS; ++j )
    source [j + i] = s[j];
}
</code></pre>
</blockquote>
",3
41931832,41931060,1,"<blockquote>
  <p>Is there any way I can check if a pointer points to a string that is
  sin, cos, pow, log or exp that are part of the math.h header file?</p>
</blockquote>

<p>I assume you would like to call different <em>math</em> functions based on a string match.</p>

<p>You could use something like following data structure to achieve this:</p>

<pre><code>// Make a generic function pointer, since no. of arguments differs
typedef double (*genericfptr)( );

struct FunMap
{
    const char* funName;
    genericfptr fptr;
    unsigned int nargs;
};

// Following could be used to get correct compatible types
typedef double (*OneArg)( double );
typedef double (*TwoArg)( double , double );
</code></pre>

<hr>

<p>Then you could create a data structure to map nfunctions and no. of arguments like :</p>

<pre><code>struct FunMap fMap[ ] = 
{
    { ""sin"", sin, 1 },
    { ""cos"", cos, 1 },
    { ""log"", log, 1 },
    { ""pow"", pow, 2 },
    // ....
};
</code></pre>

<hr>

<p>Using this <em>function</em> map table you can call function based on our <em>string match</em>.  Something like following :</p>

<pre><code>    if( strcmp( p, fMap[ j ].funName ) == 0 )
    {

        switch( fMap[ j ].nargs )
        {
            case 1:
            result = ((OneArg )fMap[ j ].fptr)( val1 );
            break;

            case 2:

            result = ((TwoArg )fMap[ j ].fptr)( val1, val2 );
            break;

            default:
            result = 0.0;
            //assert ( false );
            break;
        }
        break;
    }
</code></pre>

<p><kbd><a href=""http://rextester.com/ESZH39232"" rel=""nofollow noreferrer""><strong><em><code>Demo here</code></em></strong></a></kbd></p>
",0
40538198,40535878,0,"<p>fix like this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define OFFSET 8 //arrival time

typedef struct flight {
    //char arr[5];//4+1(NUL)//unnecessary or must be synchronized to string of member.
    char *string;
    struct flight *next;
} LIST;

void bubbleSort(LIST *start);
void swap(LIST *a, LIST *b);

int main(int argc, char *argv[]){
    FILE *fp;
    char buffer[20];
    LIST *current, *head, *node;

    head = current = NULL;
    fp=fopen(argv[1], ""r"");//argc &gt; 1.
    while(fgets(buffer, sizeof buffer, fp)){
        node = malloc(sizeof(*node));//cast is not required in C.
        node-&gt;string = strdup(buffer);
        node-&gt;next = NULL;
        if(head == NULL){
            current = head = node;
        } else {
            current = current-&gt;next = node;
        }
        bubbleSort(head);//head instead of start
    }
    fclose(fp);
    for(current = head; current ; current = current-&gt;next){
        printf(""%s"", current-&gt;string);//Include a newline in the (all)line
    }
}

void bubbleSort(LIST *start){
    int swapped;
    LIST *lptr = NULL;//last

    do {
        LIST *ptr = start;
        swapped = 0;
        while (ptr-&gt;next != lptr){
            if(strncmp(ptr-&gt;string + OFFSET,  ptr-&gt;next-&gt;string + OFFSET, 4) &gt; 0) {// use strncmp
                swap(ptr, ptr-&gt;next);
                swapped = 1;
            }
            ptr = ptr-&gt;next;
        }
        lptr = ptr;
    } while (swapped);
}

void swap(LIST *a, LIST *b){//remove ;
    char *temp = a-&gt;string;//type is char*
    a-&gt;string = b-&gt;string;
    b-&gt;string = temp;
}
</code></pre>
",0
41919772,41919641,1,"<p>The <code>rcomment()</code> function does not parse the single line comments correctly:</p>

<ul>
<li><p>If you match a <code>'/'</code> for the second character, you should read all remaining characters upto the newline and output just the newline.</p></li>
<li><p>If the second character is a quote, you fail to output the first character and parse the literal.  An easy way to do this is to unget the second character with <code>ungetc(d, fp);</code> and only output <code>c</code>.</p></li>
</ul>

<p>There are other special cases you do not handle:</p>

<ul>
<li><p>Escaped newlines should be handled in literals and single line comments as well as in between the <code>/</code> and the <code>*</code> at the start of a multi-line comment and between the <code>*</code> and the <code>/</code> at the end.  You can do this simply by using a utility function to read the bytes from the file that handles escaped newlines but it will be difficult to output them back to the output file to preserve the line counts.</p></li>
<li><p>You should replace multiline comments with a single space or newline characters to avoid pasting tokens and to preserve the line count.</p></li>
<li><p><code>incomment()</code> and <code>echo_quote()</code> should handle a premature end of file. As currently coded, they run indefinitely.</p></li>
</ul>

<p>This parsing task is more subtile than it looks.  You could try another approach and implement a state machine.</p>

<p>Here is a quick fix for the <code>rcomment()</code> function, but the other issues above remain:</p>

<pre><code>int peekc(FILE *fp) {
    int c = getc(fp);
    if (c != EOF)
        ungetc(c, fp);
    return c;
}

void rcomment(int c, FILE *fp) {
    int d;

    if (c == '/') {
        if ((d = getc(fp)) == '*') {
            incomment(fp);
        } else
        if (d == '/') {
            while ((c = getc(fp)) != EOF &amp;&amp; c != '\n') {
                if (c == '\\' &amp;&amp; peekc(fp) == '\n') {
                    putchar(getc(fp));
                }
            }
            putchar('\n');
        } else {
            putchar(c);
            ungetc(d, fp);
        }
    } else
    if (c == '\'' || c == '""') {
        echo_quote(c, fp);
    } else {
        putchar(c);
    }
}
</code></pre>
",0
38093357,38093275,0,"<p>To clear things out some more, your <code>if</code> statement would look something like this</p>

<pre><code>if(n&lt;=0)
    ;
</code></pre>

<p>That is an <code>if</code> with a blank line after that, hence nothing gets executed.</p>
",0
38093408,38093275,0,"<pre><code>    #include&lt;stdio.h&gt;

    int n;
    main()
    {
        printf(""Enter your age for qualification:"");
        scanf(""%d"",&amp;n);

      if (n&gt;=0 &amp;&amp; n&lt;=100)
      {
        if (n&lt;=0)
        {
            printf(""you're still in your mother's womb!"");
        }
        else
        {
            /*(n&gt;=1 &amp;&amp; n&lt;=17);*/
            printf(""you're too young! you're not qualified!"");
        }
        if(n&gt;=18 &amp;&amp; n&lt;=100)
        {
            printf(""you're qualified to vote"");
        }
        else
        {
             /*(n&gt;=121);*/
             printf(""that's impossible! you're already dead!"");
        }
      }

      return 0;  
    }
</code></pre>

<p>What your code should looks like, for example</p>
",3
38093309,38093275,1,"<p>When you do e.g.</p>

<pre><code>if(n&lt;=0);
</code></pre>

<p>you have a single <code>if</code> statement that does <em>nothing</em>. And then the <code>else</code> is a stray keyword out of context. </p>

<p>The format of an <code>if</code> statement is</p>

<pre><code>if (condition) statement
</code></pre>

<p>or</p>

<pre><code>if (condition) statement else statement
</code></pre>

<p>Note that there is no semicolon after the condition, instead it's part of <code>statement</code>.</p>

<p>In your case with <code>if(n&lt;=0);</code> the semicolon at the end is the <code>statement</code>, an empty statement.</p>
",3
40981848,40981823,3,"<p>Set <code>int cnt1 = 0, cnt2 = 0</code> etc. (they are not nullified by default, just have some garbage [like a rented room not cleaned explicitly...]).</p>

<p>Also:</p>

<pre><code>if(GPA &lt; 1 || GPA &gt; 4){
    printf(""invalid number \n"");
    continue; // skip the rest of the loop body
}
</code></pre>

<p>Or a slightly cleaner approach (in full):</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void){
int cnt1 = 0, cnt2 = 0, cnt3 = 0, cnt4 = 0;
int numofsdts, GPA;

printf(""Enter number of students: "");
scanf(""%d"", &amp;numofsdts);

students = 0;
while(students &lt;= numofsdts){
    printf(""GPA of student number %d: "", students + 1);
    scanf(""%d"", &amp;GPA);

    if(GPA &lt; 1 || GPA &gt; 4){
        printf(""invalid number \n"");
        continue;
    }

    if(GPA == 1)
        cnt1++;
    else if(GPA == 2)
        cnt2++;
    else if(GPA == 3)
        cnt3++;
    else if(GPA == 4)
        cnt4++;

    students++;
}

printf(""GPA 1: %d students \n"", cnt1);
printf(""GPA 2: %d students \n"", cnt2);
printf(""GPA 3: %d students \n"", cnt3);
printf(""GPA 4: %d students \n"", cnt4);
}
</code></pre>
",4
40981930,40981823,1,"<p>There are multiple errors here. The first is that <code>cnt1-4</code> have to be initialized prior to being added to. The second is that C uses zero indexing, so <code>GPAFreq[4]</code> is not accessing the fourth element of your array (which would be <code>GPAFreq[3]</code>.</p>

<p>The third is that your <code>if</code> statement isn't doing what you think it is. It is evaluating the values inside of your array as boolean variables, i.e. 0 is <code>false</code>, anything else is <code>true</code>. A better approach is to do this:
<code>GPAFreq[GPA - 1] += 1;</code>
This will be counting the frequencies in each of the indices of the array. Then to print them, you just access <code>GPAFreq</code> and no longer need the <code>cnt</code> variables.</p>
",1
36667443,36667173,1,"<p>If you know in advance exactly how much space you need, you can try for all the needed files:</p>

<ol>
<li><a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/fopen.html"" rel=""nofollow"">fopen</a> the file and fill it with blanks until you reach the exact size you need.</li>
<li><a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/fflush.html"" rel=""nofollow"">fflush</a> the file and check for error.</li>
<li><a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/rewind.html"" rel=""nofollow"">rewind</a> the file pointer to the beginning and overwrite the content with the real data.</li>
</ol>

<p>In case of error when fflush'ing, <a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/remove.html"" rel=""nofollow"">remove</a> all files.</p>

<p>When you're finished, fclose the files.</p>
",6
43196687,43196284,1,"<p>Variable declread as</p>

<pre><code>extern int c;
</code></pre>

<p>is an <em>external</em> declaration that potentially requires an <em>external</em> definiton. ""External"" in this case means ""located outside of any function"". Your <code>c</code> declared locally in <code>main()</code> does not fullfill that role.</p>

<p>Since you are <em>using</em> that externally declared variable <code>c</code> in your code you have to <em>define</em> it and define it only <em>once</em>.</p>

<p>You need</p>

<pre><code>int c;
</code></pre>

<p>or </p>

<pre><code>int c = 0;
</code></pre>

<p>or</p>

<pre><code>extern int c = 0;
</code></pre>

<p>it one of your implementation files, at file scope. All of these are definitions. Any of them will <em>define</em> your variable.</p>
",1
43196772,43196284,1,"<p>Define your variable <em>once</em> in one of your files (to reserve space),</p>

<pre><code>int c = 0;
</code></pre>

<p>Declare your variable references <em>everywhere else</em> (in all of your other files) (to reference said space),</p>

<pre><code>extern int c;
</code></pre>

<p>But that could be confusing, so name them indicative of the 'global' use,</p>

<pre><code>int glob_a, glob_b;
int glob_c;
float glob_f;
</code></pre>

<p>And declare your variable references everywhere else,</p>

<pre><code>extern int glob_a, glob_b;
extern int glob_c;
extern float glob_f;
</code></pre>

<p>But you really want to avoid littering you namespace, so when you have a collection of globals, declare a struct that contains them (in a header file probably called globals.h),</p>

<pre><code>typedef struct globals_struct {
    int a, b;
    int c;
    float f;
} globals_t;
</code></pre>

<p>And once (in your file main.c that declares main()), you define the struct,</p>

<pre><code>#include globals.h
globals_t globs;
</code></pre>

<p>And everywhere else, reference the space,</p>

<pre><code>#include globals.h
extern globals_t globs;
</code></pre>

<p>Often, you will see a stanza such as this, where MAIN is only declared in one file,</p>

<pre><code>#ifndef MAIN
extern globals_t globs;
#else
globals_t globs;
#endif
</code></pre>

<p>Use your globals,</p>

<pre><code>int my_a = globs.a;
int my_b = globs.b;
int my_f = globs.f;
</code></pre>

<p>Notice how you have avoided needless namespace pollution?</p>

<p>Because extern just tells the compiler (actually the linker) that a variable is being defined elsewhere and needs to be linked against.</p>
",0
42668275,42668005,1,"<p>Sure, you can do it this way :</p>

<pre><code>#include &lt;stdio.h&gt;

int pali(int n)
{
  int sum = 0;
  int keeper = 0;
  for (int i = n; i &gt; 0; i /= 10) {
    if (keeper != 0) {
      sum *= 10;
      sum += (keeper - i * 10);
    }
    keeper = i;
  }
  sum *= 10;
  sum += keeper;
  return sum;
}

int main(int argc, char** argv)
{
  int i, n;     
  printf(""Enter the number : "");
  scanf(""%d"",&amp;n);
  i = pali(n);
  if(n == i) 
    printf(""Number is palindrome""); 
  else     
    printf(""Not Palindrome"");  
}
</code></pre>

<p>Using recursion is even easier : </p>

<pre><code>#include &lt;stdio.h&gt;

int pali(int n, int sum)
{
  sum += n - ((n / 10) * 10);
  n /= 10;
  if (n &gt; 0)
    pali(n, sum * 10);
  else
    return sum;
}

int main(int argc, char** argv)
{
  int i, n;     
  printf(""Enter the number : "");
  scanf(""%d"",&amp;n);
  i = pali(n, 0);
  if(n == i) 
    printf(""Number is palindrome""); 
  else     
    printf(""Not Palindrome"");  
}
</code></pre>

<p>And a recursive version with only one parameter :</p>

<pre><code>#include &lt;stdio.h&gt;

int pali(int n)
{
  int fUnit, lUnit;
  fUnit = n;
  int mul = 1;
  while (fUnit &gt; 10) {
    fUnit /= 10;
    mul *= 10;
  }

  lUnit = n - ((n / 10) * 10);
  n -= (fUnit * mul);
  n /= 10;

  if (mul == 1) return 1;
  else if (fUnit == lUnit) return pali(n);
  else return 0;
}

int main(int argc, char** argv)
{
  int n;     
  printf(""Enter the number : "");
  scanf(""%d"",&amp;n);
  if(pali(n) == 1) 
    printf(""Number is palindrome""); 
  else     
    printf(""Not Palindrome"");  
}
</code></pre>
",10
42668699,42668005,0,"<p>Here is an optimized version that</p>

<ul>
<li>Doesn't use local <code>static</code>.</li>
<li>Only includes stdio.h</li>
<li>Uses recursion.</li>
</ul>

<hr>

<pre><code>#include &lt;stdio.h&gt;

static void perform_useless_recursion (int n)
{
  if(n--)
  {
    perform_useless_recursion(n);
  }
}

_Bool is_pali (int n)
{
  perform_useless_recursion(1);

  int sum = 0;
  for(int i=n; i!=0; i/=10)
  {
    sum = sum*10 + i%10;
  }
  return n == sum;
}

int main (void)
{
  int n=5005;

  if(is_pali(n)) 
    printf(""Number is pall""); 
  else     
    printf(""Not Pall"");  

  return 0;  
}
</code></pre>

<p>The code could be improved even further by removing the <code>perform_useless_recursion()</code> function.</p>

<p>The advantage of this code is that the actual calculation is performed by a fast loop, instead of slow, dangerous recursion. In the real world outside artificial school assignments, there is no reason to write inefficient and dangerous code when you could write efficient and safe code. As a bonus, removing recursion also gives far more readable code.</p>

<p>If you benchmark this code you'll notice that it will be faster than all other versions posted and consumes less memory.</p>
",4
42668093,42668005,3,"<p>Yes, the typical (""functional"") approach is to carry the state in the form of a function argument. This often makes it necessary/nice to have a second function that does the actual recursion, which you can start by calling with the proper initial values for the state:</p>

<pre><code>int do_pali(int sum, int n)
{
  if(n != 0)
  {
    const int r = n % 10;
    return do_pali(10 * sum + r, n / 10);
  }
  return sum;
}
</code></pre>

<p>the public function then just becomes:</p>

<pre><code>int pali(int n)
{
  return do_pali(0, n);
}
</code></pre>

<p>In languages with inner functions this can be more neatly expressed (GCC supports this as an extension).</p>
",3
42668099,42668005,0,"<p>Since your function returns <code>sum</code> you could replace this line:</p>

<pre><code>pali(n/10);
</code></pre>

<p>with</p>

<pre><code>sum=pali(n/10);
</code></pre>

<p>You'd also have to move it up a line too.</p>
",0
42671942,42668005,0,"<p>You can make a function that check only the first and the last digits of the number and pass the rest of the number onward.</p>

<p>To explain better, think about the following cases:</p>

<ul>
<li><p>pali(<strong>1</strong>22<strong>0</strong>) would check for the first (<strong>1</strong>) and last (<strong>0</strong>) digits. Since 1 != 0 pali would return false.</p></li>
<li><p>pali(1<strong>789</strong>1) would check first (1) and last (1). Since they're equal then the function would recursively return pali(<strong>789</strong>) (which itself would return false since 7 != 9).</p></li>
<li><p>pali(<strong>878</strong>) would check that 8=8 and recursively return pali(<strong>7</strong>)</p></li>
<li><p>pali(<strong>3</strong>) would check that first (<strong>3</strong>) and last (<strong>3</strong>) numbers are equal and return 0.</p></li>
</ul>

<p>The challenge here is to develop an algorithm that:</p>

<ul>
<li><p>Check if first and last numbers are the same (even if it's only one digit!)</p></li>
<li><p>Strip the number from first and last digits and call itself on the remainder</p></li>
</ul>

<p>Then all you need to do is apply recursion. Here's a sample implementation:</p>

<pre><code>int pali(int number)
{
    int smallDigit, bigDigit;

    /* When recursion ends suceffuly*/
    if (number == 0)
        return 1;

    /* Check for first and last digit of a number */
    smallDigit = number % 10;
    bigDigit = number;

    while(bigDigit/10!=0)
    {
        bigDigit = bigDigit/10;
        smallDigit = smallDigit*10;
    }

    /* Check to see if both digits are equal (Note: you can't use smallDigit here because it's been multiplied by 10 a few times) */
    if (bigDigit != number%10)
        return 0;
    else
    {
        number = (number - smallDigit)/10; /* This is why smallDigit was multiplied by 10 a few times */
        return pali(number); /* Recursion time */
    }
}
</code></pre>
",0
44347762,44347718,2,"<p>Calling from <code>main()</code> must be like this:</p>

<pre><code>graph g;
initGraph(1, 1, &amp;g);
</code></pre>

<p>or like this:</p>

<pre><code>graph *g = malloc( sizeof(graph) );
initGraph(1, 1, g);
</code></pre>

<p>EDIT:</p>

<p>In the comments there is a multivoted question about how I explained that there is an error in the code that is not shown in the OP query.</p>

<p>Lets see beginning of the function:</p>

<pre><code>void initGraph(int numberNode, int numberArc, graph *g) {
    int i, j;
    g-&gt;numberNode = numberNode;
}
</code></pre>

<p>And the error:</p>

<blockquote>
<pre><code>Program received signal SIGSEGV, Segmentation fault.
0x00000000004009a3 in initGraph (numberNode=15, numberArc=17, g=0x1) at src/topologicGraphOp.c:45
45          g-&gt;numberNode = numberNode;
</code></pre>
</blockquote>

<p>The error mention line <code>45</code> and I was asked question in comment about how we can know where the line <code>45</code>. However, I immediately removed question because near the line number error show line content, so we can find that line in mentioned code.</p>

<p>Code at line <code>45</code> is enough simple and may cause error only when pointer <code>g</code> is referred to wrong memory.</p>

<p>The pointer <code>g</code> is not modified by this function before use. This function supposes the valid memory pointed by function param <code>g</code>.</p>

<p>Therefore, function is called with wrong pointer for param g. So I just suggested valid and typical approach to proper initialize variable and call such function with such param.</p>
",2
44348054,44347718,1,"<p>A segmentation fault <em>virtually always</em> means you are messing up a pointer in some way. Either during allocation, or during dereference (for reading or writing, that's the same thing here). You might also have changed the address it points to, for example by forgetting to dereference it on assignment (similar to <code>*g = ...;</code> becomes <code>g = ...;</code>); that particular mistake would be less likely with structures, but you never know...</p>

<p>Consequently, when you get a segmentation fault, <em>always double-check all pointers involved in the problematic statement</em>. In this case, <code>g</code> is the only pointer involved (both the parameter and the field <code>numberNode</code> are non-pointer variables), so <code>g</code> is the suspect part.</p>

<p>You don't show us how you call the initialization function, but in this case the code is simple enough that the cause should be obvious once you look at where the <code>g</code> parameter to <code>initGraph()</code> is coming from, and what its value (and address) is on entry to <code>initGraph()</code>. Is <code>g</code> allocated at all? Does <code>g</code> point to a sufficiently large block of memory to hold the entire structure? Has any relevant field (e.g. in the case of a pointer to a structure that itself contains pointers) been initialized, and is the value reasonable immediately before the problematic statement?</p>

<p>If you are still uncertain, look at the address and value of that pointer, either through the debugger or by adding something like <code>printf(""&amp;g=(%p)"",g);</code> to the top of <code>initGraph()</code>. Invalid pointers have a tendency to stand out quite well from the noise of actual memory addresses.</p>
",0
44348054,44347718,1,"<p>A segmentation fault <em>virtually always</em> means you are messing up a pointer in some way. Either during allocation, or during dereference (for reading or writing, that's the same thing here). You might also have changed the address it points to, for example by forgetting to dereference it on assignment (similar to <code>*g = ...;</code> becomes <code>g = ...;</code>); that particular mistake would be less likely with structures, but you never know...</p>

<p>Consequently, when you get a segmentation fault, <em>always double-check all pointers involved in the problematic statement</em>. In this case, <code>g</code> is the only pointer involved (both the parameter and the field <code>numberNode</code> are non-pointer variables), so <code>g</code> is the suspect part.</p>

<p>You don't show us how you call the initialization function, but in this case the code is simple enough that the cause should be obvious once you look at where the <code>g</code> parameter to <code>initGraph()</code> is coming from, and what its value (and address) is on entry to <code>initGraph()</code>. Is <code>g</code> allocated at all? Does <code>g</code> point to a sufficiently large block of memory to hold the entire structure? Has any relevant field (e.g. in the case of a pointer to a structure that itself contains pointers) been initialized, and is the value reasonable immediately before the problematic statement?</p>

<p>If you are still uncertain, look at the address and value of that pointer, either through the debugger or by adding something like <code>printf(""&amp;g=(%p)"",g);</code> to the top of <code>initGraph()</code>. Invalid pointers have a tendency to stand out quite well from the noise of actual memory addresses.</p>
",0
44347762,44347718,2,"<p>Calling from <code>main()</code> must be like this:</p>

<pre><code>graph g;
initGraph(1, 1, &amp;g);
</code></pre>

<p>or like this:</p>

<pre><code>graph *g = malloc( sizeof(graph) );
initGraph(1, 1, g);
</code></pre>

<p>EDIT:</p>

<p>In the comments there is a multivoted question about how I explained that there is an error in the code that is not shown in the OP query.</p>

<p>Lets see beginning of the function:</p>

<pre><code>void initGraph(int numberNode, int numberArc, graph *g) {
    int i, j;
    g-&gt;numberNode = numberNode;
}
</code></pre>

<p>And the error:</p>

<blockquote>
<pre><code>Program received signal SIGSEGV, Segmentation fault.
0x00000000004009a3 in initGraph (numberNode=15, numberArc=17, g=0x1) at src/topologicGraphOp.c:45
45          g-&gt;numberNode = numberNode;
</code></pre>
</blockquote>

<p>The error mention line <code>45</code> and I was asked question in comment about how we can know where the line <code>45</code>. However, I immediately removed question because near the line number error show line content, so we can find that line in mentioned code.</p>

<p>Code at line <code>45</code> is enough simple and may cause error only when pointer <code>g</code> is referred to wrong memory.</p>

<p>The pointer <code>g</code> is not modified by this function before use. This function supposes the valid memory pointed by function param <code>g</code>.</p>

<p>Therefore, function is called with wrong pointer for param g. So I just suggested valid and typical approach to proper initialize variable and call such function with such param.</p>
",2
38192829,38192686,1,"<p>Despite the title of the question, this has nothing to do with <code>sprintf()</code>, which probably works as expected, but everything with <code>count</code>.</p>

<p>If count is a global variable (i.e. outside any functions), then it should keep its value between function calls. So that is probably not the case.</p>

<p>If it is a local variable (declared inside the function), then it can have any value, since these lose their value when the function ends and don't get initialized when the function is run again. It can be always 0, but under different circumstances, it can just as well be something else. In other words, the value is more or less undetermined.</p>

<p>To have a local variable keep its value between function calls, make it static.</p>

<pre><code>static int count = 0;
</code></pre>

<p>But note that when you stop and run the program again, it will start as 0 again. That means you would possibly overwrite <code>000.txt</code>, then <code>001.txt</code>, etc.</p>

<p>If you really want to avoid duplicate file names, you will have to be more sophisticated, and see which files are already there, determine the highest number, and increment that by one. So you don't use a variable, you check the files that already exist. That is far more work, but the only reliable way to avoid overwriting existing files with such numbered file names.</p>

<hr>

<p>FWIW, I would use something like <code>""00%04d.txt""</code> as format string, so you get files <code>000000.txt</code>, <code>000001.txt</code>, etc. which look better in an alphabetically sorted file listing than <code>000.txt</code>, <code>001.txt</code>, <code>0010.txt</code>, <code>0011.txt</code>, <code>002.txt</code>, etc. They are also easier to parse for their number.</p>

<p>As Weather Vane noticed, be sure to make your buffer a little larger, e.g.</p>

<pre><code>char filename[20];
</code></pre>

<p>A buffer that is too small is a problem. One that is too large is not, unless it is huge and clobbers up the stack. That risk is very small with 20 chars.</p>
",2
38194994,38192686,1,"<p>I think it is likely the sprintf. ""0%02d.txt"" is 7 chars. The null at the end of the string will go in the next location, which is likely the count on the stack. On a little endian machine (x86), that likely means the bottom byte of count gets zeroed out in every sprintf(). </p>

<p>As other folks said. Make the filename buffer larger. </p>
",0
38209515,38209400,2,"<p>This may not cover ALL of your errors, but immediately I see this:</p>

<pre><code>int xcoor,ycoor;
char symbol[2];
while((xcoor!=0)
</code></pre>

<p>Do you think <code>xcoor</code> has a valid value right now? Should it? Because it doesn't. You've created a variable, then before actually setting it to anything, you are checking its value. </p>

<p>It's more than likely your <code>scanf</code> call that's giving you trouble. Regardless, try actually setting these variables. It will most likely fix your issues.</p>

<p>See here for more info: <a href=""https://stackoverflow.com/questions/30852028/is-reading-from-unallocated-memory-safe/30852070#30852070"">Is reading from unallocated memory safe?</a></p>
",0
38209604,38209400,0,"<p>You are using an uninitialized variable <code>xcoor</code> in the conditional of the <code>while</code> statement.</p>

<p>You can fix that by initializing <code>xcoor</code>. </p>

<p>More importantly, you can simplify the code for reading user data and the related error checks. Here's what I suggest:</p>

<pre><code>while ( scanf(""%d%d %c%c"", &amp;xcoor, &amp;ycoor, &amp;symbol[0], &amp;symbol[1]) == 4 )
{
   if ( xcoor &lt; 0 || xcoor &gt;= 30 )
   {
      // Deal with problem.
      fprintf(stderr, ""Out or range value of xcoor: %d\n"", xcoor);
      exit(1);
   }
   if ( ycoor &lt; 0 || ycoor &gt;= 30 )
   {
      // Deal with problem.
      fprintf(stderr, ""Out or range value of ycoor: %d\n"", ycoor);
      exit(1);
   }

   grid[xcoor-1][ycoor-1] = symbol[1];
}
</code></pre>
",0
40958168,40958072,1,"<blockquote>
  <p><code>while ((a % 2 != 0) || (a % 5 != 0))</code></p>
</blockquote>

<p>this test fails for the value of 50 or any integer that is multiple of both 2 an 5. Therefore the <code>while</code> loop will not be entered and no division will occur, so <code>a</code> conserves its value.</p>

<p>maybe your intent was the inverse of the condition:</p>

<p><code>while ((a % 2 == 0) || (a % 5 == 0))</code></p>
",1
42638895,42638574,0,"<p>First of all, this is a warning, and not an error. Your code should compile successfully in the least, if this warning is the only issue the compiler produces during the build process. However, if you want to overcome this issue, you can simply change:</p>

<pre><code>charArray[arraySize-1] = NULL;
</code></pre>

<p>To:</p>

<pre><code>charArray[arraySize-1] = 0;
</code></pre>

<p>While <code>charArray</code> is a pointer that points to the first memory space in the array, <code>charArray[i]</code>, where <code>i</code> represents a counter as an example here, is of data type <code>int</code>. Now, <code>NULL</code> is used when a pointer points to nothing, or in computer terms, to the ground. Therefore, the compiler warns you that you are storing a pointer attribute in a non-pointer memory space (Sorry for the really por choice of words, if there is anything wrong with it, please correct me in the comments box).</p>

<p>The above code change should resolve the warning your compiler produces.</p>
",0
36363564,36362267,0,"<p>If this is a standard Windows bitmap, then <code>newrows</code> must be of a scanline size. A bitmap image consists of scanlines. A scanline consists of pixels. A pixel consists of one or more components (colors).</p>

<p>A scanline must be a multiple of 4 bytes. So after the last component of the last pixel of a scanline, there may follow some unused bytes.</p>

<p>So your scaled bitmap must have scanlines of the appropriate size. See also<br>
<a href=""https://stackoverflow.com/questions/36261768/dealing-with-padding-in-a-bmp-file-in-c/36262866#36262866"">Dealing with padding in a BMP file in C</a> of how to calculate scanline sizes and iterate over an image.</p>

<p>Note also that if you just ""scale"" with an integer, you can scale 1, 2, 3... integer times (100%, 200%,...). Scaling with non-integers requires smearing the pixels out over the new width and hight. Numerous algorithms and ready-to-use code are available on the internet.</p>
",0
36363708,36362267,0,"<p>Try this:</p>

<pre><code>int enlarge(PIXEL* original, int rows, int cols, float scale,
        PIXEL** enlarged, int* newrows, int* newcols)
{
    int row, col;
    if((rows&lt;=0)|| (cols&lt;=0))
    {
        return -1;
    }

    (*newrows)=(int)((float)rows * scale);
    (*newcols)=(int)((float)cols * scale);

    *enlarged=(PIXEL*)malloc((*newrows)*(*newcols)*sizeof(PIXEL));

    for(row=0;row&lt;(*newrows);row++)
    {
            for(col=0;col&lt;(*newcols);col++)
            {
                     (*enlarged)[row * (*newcols) + col] = original[(row * rows / (*newrows))  * cols + col * cols / (*newcols)];
            }
    }

/* THIS IS THE METHOD THAT YOU SHOULD WRITE */
    return 0;
}
</code></pre>

<p>NOTE: i change scale type to float in order to you could scale in any factor, but you could change to int with any problem</p>

<p>You must pass newrows and newcols by ref (not pointer)</p>

<p><strong>EDIT</strong>: function usage</p>

<pre><code>    scale = 2.0f;
    readFile(""example.bmp"",&amp;r,&amp;c,&amp;b);
    enlarge(b,r,c,scale,&amp;nb,&amp;nr,&amp;nc);
    writeFile(""enlarge.bmp"",nr,nc,nb);
    free(nb);
</code></pre>
",4
41214361,40197423,0,"<p>You get garbage output because your code invokes undefined behavior:
for the input <code>12 8 2</code>, the case <code>(midNum == b) &amp;&amp; (bigNum == a)</code> is not handled in the code and <code>smallNum</code> stays uninitialized.</p>

<p>You can simplify your code by rearranging the array with 3 tests and swaps:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void) {
    const int MAX_NUM = 3;
    int userArray[MAX_NUM];
    int x;

    printf(""Please enter three integers separated by spaces:\n"");

    for (int j = 0; j &lt; MAX_NUM; ++j) {
        if (scanf(""%d"", &amp;userArray[j]) != 1)
            exit(1);
    }
    if (userArray[0] &gt; userArray[1]) {
        x = userArray[0]; userArray[0] = userArray[1]; userArray[1] = x;
    }
    if (userArray[1] &gt; userArray[2]) {
        x = userArray[1]; userArray[1] = userArray[2]; userArray[2] = x;
    }
    if (userArray[0] &gt; userArray[1]) {
        x = userArray[0]; userArray[0] = userArray[1]; userArray[1] = x;
    }

    printf(""%d %d %d\n"", userArray[0], userArray[1], userArray[2]);

    return 0;
}
</code></pre>
",0
41214607,40197423,1,"<p>There are 6 cases to consider for determining smallNum.</p>

<pre><code>if((midNum == a) &amp;&amp; (bigNum == b) || ((midNum == b) &amp;&amp; (bigNum == a))){
 smallNum = c; 
}
else if((midNum == b) &amp;&amp; (bigNum == c) || ((midNum == c) &amp;&amp; (bigNum == b))){
 smallNum = a; 
}
else if((midNum == c) &amp;&amp; (bigNum == a) || ((midNum == a) &amp;&amp; (bigNum == c))){ 
smallNum = b; 
}
</code></pre>

<p>The junk is due to the missing cases.</p>
",0
41214620,40197423,0,"<p>I agree with the other answers - your code doesn't take into account all 6 possibilities in which the values could be ordered.</p>

<p>A possible way to fix this: first, modify your ""find maximum"" function so it returns an index instead of a value:</p>

<pre><code>int findBig(int d, int e, int f) {
    if ((d &gt;= e) &amp;&amp; (d &gt;= f)) {
        return 0; // index of largest element is 0
    } else
    if ((e &gt;= d) &amp;&amp; (e &gt;= f)) {
        return 1; // index of largest element is 1
    } else
    if ((f &gt;= e) &amp;&amp; (f &gt;= d)) {
        return 2; // index of largest element is 2
    }
}
</code></pre>

<p>Then, find which number is big, small and median:</p>

<pre><code>bigIndex = findBig(a, b, c);
smallIndex = findBig(-a, -b, -c); // a hack to find the minimum instead of maximum
if (bigIndex == smallIndex)
{
    // Edge case - all numbers are equal
    // Doesn't matter which index is which; just choose 3 different ones
    bigIndex = 0;
    midIndex = 1;
    smallIndex = 2;
}
else
{
    // Choose the index that is neither big nor small
    midIndex = 3 - bigIndex - smallIndex;
}
</code></pre>

<p>Then print them:</p>

<pre><code>printf(""%d %d %d\n"", userArray[smallIndex], userArray[midIndex], userArray[bigIndex]);
</code></pre>

<p>Here it helps that you have an array. Otherwise, it would still be possible to convert an index to a value bit it would be ugly:</p>

<pre><code>printf(""%d %d %d\n"",
    smallIndex == 0 ? a : smallIndex == 1 ? b : c,
    midIndex == 0 ? a : midIndex == 1 ? b : c,
    bigIndex == 0 ? a : bigIndex == 1 ? b : c);
</code></pre>
",0
40757678,40757349,0,"<p>The array <code>temp[]</code> is uninitialized, and you attempt to find <code>strlen(temp)</code>. You don't even know if there is a <code>NUL</code> stored in the array. Try doing:</p>

<pre><code>#define MAXLINE 1000
</code></pre>

<p>and changing your calls to <code>fgets()</code>:</p>

<pre><code>fgets(temp, MAXLINE, user_file);
...
fgets(temp, MAXLINE, stdin);
</code></pre>
",1
40757680,40757349,0,"<p>Your code has multiple problems.</p>

<p>Here's the first problem:</p>

<pre><code>char temp[1000];
</code></pre>

<p>Your buffer declaration does not initialize the buffer's contents - so the value of each char value will be whatever was in the raw memory previously. In C most strings are ""null-terminated"" so having a terminating <code>NULL</code> (<code>0</code> - zero) is important otherwise you can run into buffer-overruns.</p>

<p>The ""best"" approach is to zero-out (zero-initialize) the array/buffer before you use it, like so (in C99):</p>

<pre><code>char temp[1000] = {0};
</code></pre>

<p>...this way <code>temp</code> will contain all <code>0</code> values (<code>NULL</code>) so anything written to it (provided it's no longer than 999 bytes) will automatically have a null-terminator (though <code>fgets</code> will append a terminating <code>0</code> value, but not every function in C does this).</p>

<p>The second problem is related to the first: you're using the <em>runtime</em> string-length function <code>strlen</code> to get the size of the <code>strlen</code> buffer. This is incorrect as the buffer sized is fixed at compile-time to 1000. The <code>strlen</code> will return the index of the first <code>0</code> (<code>NULL</code>) char value, which is undefined behavior at this point because you haven't zero-initialized the buffer anyway (so it could return <code>0</code> immediately if the buffer's original raw data contained a zero, or it could overrun 1000 because there was never any zero value.</p>

<p>...thus you need to re-use the buffer-length, like so:</p>

<pre><code>#define TEMP_LENGTH 1000

char temp[ TEMP_LENGTH ];

...

fgets( temp, TEMP_LENGTH, user_file );
</code></pre>

<p>Finally, you're making the same mistake when you call <code>fgets( temp, ..., stdin )</code>.</p>
",1
40757706,40757349,0,"<p>Here problem is in your code, instead of passed numerical value in second argument you passed strlen(temp).</p>

<pre><code>fgets(temp,strlen(temp),user_file);
</code></pre>

<p>right way is :-</p>

<pre><code>fgets(temp,1000,user_file);
</code></pre>
",0
40964200,40964186,5,"<p>The problem is that you need to copy the values, not the pointers:</p>

<pre><code>int temp = *b;
*b = *a;
*a = temp;
</code></pre>

<p><strong>Note:</strong> Your code is assigning pointers of wrong type - <code>&amp;a</code> is <code>int**</code>, while <code>b</code> is <code>int*</code> (i.e. the number of asterisks does not match). Your compiler should have given you warnings about that. Fixing them would fix the problem. </p>
",3
40964216,40964186,1,"<p>Remember that your <code>a</code> and <code>b</code> are already pointers - so inside the function you must not use the <code>&amp;</code> (address operator), instead you must use the <code>*</code> (dereference operator):</p>

<pre><code>int temp = *b; 
*b = *a;                                             
*a = temp;
</code></pre>
",0
47484659,47484365,1,"<p>In your <code>preorder</code> <code>inorder</code> and <code>postoder</code> you make errors in the parameters:</p>

<pre><code>       printf(""\n%d"", t-&gt;left);    // you can't print a node
       inorder(t-&gt;data);           // you can't traverse an integer
</code></pre>

<p>which should be:</p>

<pre><code>       printf(""\n%d"", t-&gt;data);
       inorder(t-&gt;left);
</code></pre>

<p>In <code>create</code> you forget to assign the data:</p>

<pre><code>       p-&gt;data= x;
</code></pre>

<p>You may be compiling as C++ instead of C. This explains the undefined references as you have the functions overloaded and the C++ compiler can't find the various overloaded functions. Compile as C.</p>

<p>Note: for preorder/inorder/postorder just move the print statement and recursively call the appropriate function.</p>
",2
47484681,47484365,2,"<ol>
<li>Your code is not well formatted. You forgot to close the curly brackets <code>}</code>. You need to close them after writing your function:
<code>void foo(){//code for function}</code>.</li>
<li>You cannot print a pointer using <code>%d</code>. If you want to print the value of your node try <code>printf(&quot;\n%d&quot;, t-&gt;data)</code>. If you want to print a pointer try using <code>%p</code>.</li>
<li>You are not saving the read value <code>x</code>.</li>
<li>You are not traversing the tree as you should. Google it and read more about it.</li>
</ol>
<p>Formatted code:</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

typedef struct node {
    int data;
    struct node *left;
    struct node *right;
} node;

node *create() {
    node *p;
    int x;
    printf(&quot;Enter data (-1 for no data): &quot;);
    scanf(&quot;%d&quot;, &amp;x);
    if (x == -1) {

        return NULL;
    } else {
        p = (node *) malloc(sizeof(node));
        //save read value
        p-&gt;data=x;
        printf(&quot;Enter left child node: \n&quot;);
        p-&gt;left = create();
        printf(&quot;Enter right child node: \n&quot;);
        p-&gt;right = create();
        return p;
    }
}

//function is not returning anything so its return type should be void
void preorder(node *t) {
    if (t != NULL) {
        //key left right
        printf(&quot;\n%d&quot;, t-&gt;data);
        preorder(t-&gt;left);
        preorder(t-&gt;right);
    }
}

void inorder(node *t) {
    if (t != NULL) {
        //left key right
        inorder(t-&gt;left);
        printf(&quot;\n%d&quot;, t-&gt;data);
        inorder(t-&gt;right);
    }
}

void postorder(node *t) {
    if (t != NULL) {
        //left right key
        postorder(t-&gt;right);
        postorder(t-&gt;left);
        printf(&quot;\n%d&quot;, t-&gt;data);
    }
}

int main() {
    node *root;
    root = create();
    printf(&quot;\nThe preorder traversal is: \n&quot;);
    preorder(root);
    printf(&quot;\nThe inorder traversal is: \n&quot;);
    inorder(root);
    printf(&quot;\nThe postorder traversal is: \n&quot;);
    postorder(root);
    return 0;
}
</code></pre>
<p>Edit: Changed function return type of <code>preorder</code>, <code>inorder</code> and <code>postorder</code>, from <code>int</code> to <code>void</code></p>
",0
47485212,47484365,1,"<pre><code>1. You have defined the function inorder, postorder and preorder in the create function. Place the closing brackets correctly and it will resolve that error.

2. In create function, you are not assigning the data to node. 

3. Inorder, postorder and preorder function needs of data type node* but you are passing of data type int at several places. That is the reasons of some warnings. 

4. I have written the same code based on your implementation. I complied with gcc and run a test. It seems okay. Have a look at it for your reference. 
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
struct node
{
      int data;
      struct node *left;
      struct node *right;
};

typedef struct node node; 
node *create()
{

    int x;
    printf(""Enter data (-1 for no data): "");
    scanf(""%d"", &amp;x);
    if(x==-1)
    {
        return NULL;
    }
    else
    {
        node *p;
        p=(node*)malloc(sizeof(node));
        p-&gt;data = x;
        printf(""Enter left child node: \n"");
        p-&gt;left=create();
        printf(""Enter right child node: \n"");
        p-&gt;right=create();
        return p;
    }
}

void preorder(node *t)
{
    if(t!=NULL)
    {
            printf(""\n%d"", t-&gt;data);
            preorder(t-&gt;left);
            preorder(t-&gt;right);
    }
    return; 
}

void inorder(node *t)
{

    if(t != NULL)
    {
        inorder(t-&gt;left);
        printf(""%d\n"", (t-&gt;data));
        inorder(t-&gt;right);
    }

    return;
}

void postorder(node *t)
{
    if(t!=NULL)
    {
        postorder(t-&gt;left);
        postorder(t-&gt;right);
        printf(""%d\n"", (t-&gt;data));
    }
    return; 
}



int main()
{
  node *root;
  root=create();
  printf(""\nThe preorder traversal is: \n"");
  preorder(root);
  printf(""\nThe inorder traversal is: \n"");
  inorder(root);
  printf(""\nThe postorder traversal is: \n"");
  postorder(root);
  return 0;
}
</code></pre>
",0
42618793,42617959,1,"<p>Penguin Brian <a href=""https://stackoverflow.com/a/42618162/1475978"">already answered</a> the stated question, but I'd like to point out that since the asker is using POSIX/BSD sockets, they should also use the proper interfaces, namely <a href=""http://man7.org/linux/man-pages/man3/getaddrinfo.3.html"" rel=""nofollow noreferrer""><code>getaddrinfo()</code></a>. It handles both name and port/service translation, and supports IPv4 and IPv6 (allowing the caller to restrict to either one if desired, of course).</p>

<p>The <a href=""http://man7.org/linux/man-pages/man3/getaddrinfo.3.html"" rel=""nofollow noreferrer""><code>man 3 getaddrinfo</code></a> man page does include two example programs (client and server type), but here's mine, for illustration, with sufficient error checking:</p>

<pre><code>#define  _POSIX_C_SOURCE 200809L
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;

int main(int argc, char *argv[])
{
    struct addrinfo hints, *list, *curr;
    const char     *host, *port;
    int             sockfd, result;

    if (argc != 3 || !strcmp(argv[1], ""-h"") || !strcmp(argv[1], ""--help"")) {
        printf(""\n"");
        printf(""Usage: %s [ -h | --help ]\n"", argv[0]);
        printf(""       %s host port\n"", argv[0]);
        printf(""\n"");
        return EXIT_FAILURE;
    }

    host = argv[1];
    port = argv[2];

    /* """" or ""-"" host refers to loopback. */
    if (!host[0] || (host[0] == '-' &amp;&amp; !host[1])) 
        host = NULL;

    memset(&amp;hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC;        /* IPv4 or IPv6 */
    hints.ai_socktype = SOCK_STREAM;    /* TCP */
    hints.ai_protocol = 0;
    hints.ai_flags = AI_ADDRCONFIG;

    list = NULL;
    result = getaddrinfo(host, port, &amp;hints, &amp;list);
    if (result) {
        fprintf(stderr, ""%s.\n"", gai_strerror(result));
        return EXIT_FAILURE;
    }

    for (curr = list; curr; curr = curr-&gt;ai_next) {

        sockfd = socket(curr-&gt;ai_family, curr-&gt;ai_socktype, curr-&gt;ai_protocol);
        if (sockfd == -1)
            continue;

        if (connect(sockfd, curr-&gt;ai_addr, curr-&gt;ai_addrlen) != -1)
            break;

        close(sockfd);
        sockfd = -1;
    }

    if (sockfd == -1) {
        freeaddrinfo(list);
        fprintf(stderr, ""Cannot connect.\n"");
        return EXIT_FAILURE;
    }

    printf(""Descriptor %d is now connected. Disconnecting.\n"", sockfd);
    fflush(stdout);

    if (close(sockfd)) {
        fprintf(stderr, ""Error closing socket: %s.\n"", strerror(errno));
        return EXIT_FAILURE;
    }

    printf(""Done.\n"");
    return EXIT_SUCCESS;
}
</code></pre>

<p>Note that the above code does not record or report the error messages from the <code>connect()</code> call, because the <code>getaddrinfo()</code> interface provides multiple alternatives, and I'm not sure <em>which</em> of the errors produced in a typical case is the proper one to report. (Remember that even in a successful connection case, one or more of the <code>connect()</code> calls in the loop may have failed, without any actual ""error"" having occurred.) The <code>getaddrinfo()</code> call itself will fail if the host (node) or port (service) part is invalid.</p>

<p>In my own applications, I tend to use an error cookie -- one bit per error -- to record all the errors from the <code>connect()</code> calls for one result list from a <code>getaddrinfo()</code> call. The errors I test for are <code>EADDRINUSE</code> (local port already in use), <code>ECONNREFUSED</code> (connection refused), <code>ENETUNREACH</code> (network unreachable), <code>EACCES</code> (permission denied), <code>EADDRNOTAVAIL</code> (all ephemeral ports already in use), <code>EAFNOSUPPORT</code> (address family (IPv4/IPv6) not supported), and a catch-all for all other errors.</p>

<p>If none of the <code>connect()</code> calls succeed, I check the cookie for errors that did occur -- as an unordered set; i.e., ignoring the <em>order</em> in which they occurred --, and report the first match to the above list. It's not foolproof by any measure, more like trying-to-be-helpful heuristic, and I suspect that a generic error message (""Cannot connect"" or similar -- this is what browsers do, after all) is generally just as useful to most users.</p>
",1
42618059,42617959,0,"<p>On the second question: You pass a pointer to a specific <strong>Internet</strong> socket address structure, but <code>connect</code> expects a generic socket address structure, so simply cast one type of pointer to the other:</p>

<pre><code>connect(sockfd, (const struct sockaddr *)&amp;serv_addr, sizeof(serv_addr)
</code></pre>

<p>This warning is actually almost irrelevant, since all pointer types on modern architectures have the same size.</p>
",0
42618162,42617959,2,"<p>You have a semicolon where there should not be a semicolon:</p>

<pre><code>if (sockfd &lt; 0);
{
    error(""ERROR opening socket"");
}
</code></pre>

<p>As a result, the <code>error()</code> function will always be called, even if the if condition fails. You want:</p>

<pre><code>if (sockfd &lt; 0)
{
    error(""ERROR opening socket"");
}
</code></pre>
",0
42466547,42466467,3,"<pre><code>char *str = """";

printf(""Please enter the message to encode: "");
fgets(str, MAX_LEN, stdin);
</code></pre>

<p>is wrong, <code>str</code> is a string literal (tipically placed on read only segments, thus, not modifiable) and you need room to store the string with <code>fgets</code>, change to:</p>

<pre><code>char str[MAX_LEN];
</code></pre>

<p>and</p>

<pre><code>str = encode(str); /* str now is an array, you can not assign to */
</code></pre>

<p>to</p>

<pre><code>encode(str);
</code></pre>

<p>And note that you are not incrementing <code>i</code> in the <code>while</code> loop (infinite loop)</p>

<p>Also, you are mixing C and C++, don't do that, if you want C, <code>iostream</code> should be <code>stdio.h</code> and use a valid signature for <code>main</code>: <code>int main(void)</code> instead of <code>void main()</code></p>
",11
36486922,36483694,0,"<p>Each time you read a word, convert it to a unique 32-bit hash.  It is much faster and easier to search in a sorted array of integers than to do 1000's of string compares.</p>
",0
42529984,42529889,3,"<p>The typical and most robust way would be:</p>

<ol>
<li>Read the contents of the directory into an in-memory array (see <a href=""https://linux.die.net/man/3/opendir"" rel=""nofollow noreferrer""><code>opendir()</code></a> and friends if you're on POSIX)</li>
<li>Sort the array based on the filenames (using <a href=""https://linux.die.net/man/3/qsort"" rel=""nofollow noreferrer""><code>qsort()</code></a> of course)</li>
<li>Extract the three last elements</li>
</ol>

<p>Of course this would be brittle if files can be created while you're doing this, that is typical for this kind of filesystem-inspection.</p>
",4
42504084,42503512,0,"<p>The issue is because you are reading and printing one less than the actual size of the array. So the last entry of the array will have some junk value which you don't know. But while sorting you are using it and it gets sorted. Sometimes the junk value is lower than the other random values and it gets printed. </p>

<p>I have made the fix. Please check all the for loops.</p>

<pre><code>#include &lt;stdio.h&gt;
int main(){
int howmany,i,temp,swap;

printf(""Enter how many numbers you want to sort: \n"");
scanf("" %d"",&amp;howmany);

int number[howmany];

printf(""*** The original numbers *** \n"");

for (i=0;i&lt;howmany ;i++){ //Read howmany values and print
    number[i]=(rand()% 25)+1;
    printf(""Random number is: %d\n"",number[i]);
}

while(1){
    swap = 0;
    for (i=0;i&lt;howmany-1;i++){
        if(number[i]&gt;number[i+1]){
            temp = number[i];
            number[i]=number[i+1];
            number[i+1] = temp;
            swap = 1;
            }

    }
    if (swap == 0){
        break;
    }
}
printf(""*** The sorted numbers ***\n"");
for (i=0;i&lt;howmany;i++){ //Print howmany values 
    printf(""The sorted number: %d\n"",number[i]);


}


}
</code></pre>
",3
42653275,42653191,0,"<p>You need to set up a raster.</p>

<p>Your console screen is probably 80x25 character wide. Find out its dimensions.</p>

<p>Then set up an array char screen[25][80], and write a function to write the entire screen to the console in one go. Get it working, then the Sudoku problem becomes an issue of placing addition signs, vertical pipes and minus signs in the right places.</p>
",0
42653704,42653191,2,"<p>A sudoku board is small enough that you don't even need loops (you could use loops if you want to though):</p>

<pre><code>void print_line(int *start) {
   printf(""| %d %d %d | %d %d %d | %d %d %d |\n"", 
       start[0], start[1], start[2],
       start[3], start[4], start[5],
       start[6], start[7], start[8]);

void print_edge() {
    printf(""+-------+-------+-------+\n"");
}

print_board(int board[81]) {
    print_edge();
    print_line(board + 0*9);
    print_line(board + 1*9);
    print_line(board + 2*9);
    print_edge();
    print_line(board + 3*9);
    print_line(board + 4*9);
    print_line(board + 5*9);
    print_edge();
    print_line(board + 6*9);
    print_line(board + 7*9);
    print_line(board + 8*9);
    print_edge();
}
</code></pre>
",0
42569663,42566555,0,"<p>It's obvious that you use the wrong variable. <code>dirInfo</code> is init by this line <code>if (lstat(fileName, &amp;dirInfo) &lt; 0)</code>. that's why always print Dir.</p>

<pre><code>   if(S_ISDIR(dirInfo.st_mode))
    {
        printf(""Dir\n"");
    }
    else if(S_ISREG(dirInfo.st_mode))
    {
        printf(""File\n"");
    }
</code></pre>

<p>on linux, maybe you can use <code>dirp-&gt;d_type</code> to get type. read <a href=""https://www.gnu.org/software/libc/manual/html_node/Directory-Entries.html"" rel=""nofollow noreferrer"">this</a></p>

<p>if want to use S_ISREG/S_ISDIR, just call <code>lstat</code> to get file status first.</p>
",0
42569663,42566555,0,"<p>It's obvious that you use the wrong variable. <code>dirInfo</code> is init by this line <code>if (lstat(fileName, &amp;dirInfo) &lt; 0)</code>. that's why always print Dir.</p>

<pre><code>   if(S_ISDIR(dirInfo.st_mode))
    {
        printf(""Dir\n"");
    }
    else if(S_ISREG(dirInfo.st_mode))
    {
        printf(""File\n"");
    }
</code></pre>

<p>on linux, maybe you can use <code>dirp-&gt;d_type</code> to get type. read <a href=""https://www.gnu.org/software/libc/manual/html_node/Directory-Entries.html"" rel=""nofollow noreferrer"">this</a></p>

<p>if want to use S_ISREG/S_ISDIR, just call <code>lstat</code> to get file status first.</p>
",0
42577482,42577328,0,"<p><code>getchar()</code> reads one character from the standard input, but you have multiple characters in <code>stdin</code> (character you've entered plus <code>\n</code> for enter key), so when it goes to the second iteration of the loop it reads that leftover <code>\n</code> from <code>stdin</code>.</p>

<p>Solution: instead of <code>fflush(stdin)</code> use <code>fpurge(stdin)</code> to clear all the buffered data.</p>

<p><strong>Edit:</strong> your system may luck <code>fpurge</code> though, it's non-standard BSD function. On libc-based system (Linux, e.g.) there's <code>__fpurge</code> (see <a href=""https://www.gnu.org/software/libc/manual/html_node/Flushing-Buffers.html"" rel=""nofollow noreferrer"">https://www.gnu.org/software/libc/manual/html_node/Flushing-Buffers.html</a>)</p>
",6
42581332,42577328,0,"<p>A simple way to read one char safely would be to use this function,</p>

<pre><code>char readChar()
{
    char c;
    scanf("" %c"" , &amp;c);
    return c;
}
</code></pre>

<p>so in your code your can use </p>

<pre><code>input = readChar();
</code></pre>

<p>and it will work.</p>
",2
42641788,42641514,0,"<p>The below condition needs change:</p>

<pre><code>while(strcmp(lib_books[i].status,""returned"")!=0);
</code></pre>

<p>If the status for none of the books in <code>lib_books</code> is <code>""returned""</code>, this will go into a infinite loop. Please update this condition to check if <code>i</code> has reached the max elements in <code>lib_books</code>. That should atleast solve your infinite loop and printing problem.</p>
",0
47531773,47531707,4,"<p>This:</p>

<pre><code>binaryfirst = malloc(sizeof(char*));

and

binarysecond = malloc(sizeof(char*));
</code></pre>

<p>allocates the size of a pointer, but the loop that writes to it makes it clear that it expects to store at most 60 bytes at that location. This makes no sense at all; C does not magically grow the allocation when you write outsite it, instead you get undefined behavior.</p>

<p>If you're unsure about heap memory allocations, and they're not crucial to the problem you're trying to solve, first do it without any. Just use simple arrays:</p>

<pre><code>char binaryfirst64];
char binarysecond[64];
</code></pre>
",1
40573369,40573297,-1,"<p>Comparing string is not done by ==. Instead use string compare function like this</p>

<pre><code>strcmp(fname,name)
</code></pre>
",4
38856352,38855735,2,"<p><code>fscanf()</code>, will crash because you are using <code>&amp;phi[index]</code> there, but <code>phi</code> is not pointing to memory that you have allocated. </p>

<p>You need to allocate the needed memory first.</p>

<pre><code>if((phi = malloc(Nx * Ny * sizeof(double))) == NULL) { /* Allocate memory */
    /* Error handling code */       
    exit(1);
}
/* ... */
/* ... */

for (i=0; i&lt;Nx; i++) {   
    for (j=0; j&lt;Ny; j++) {
        index=get_index(i,j);
        printf(""%i"",index);
        if (fscanf(conf,""%i %i %lf"", &amp;ki, &amp;kj,  &amp;phi[index]) != 3) {
            /* Code to handle fscanf failure */
        }
    }
}

/* .... */
/* .... */
free(phi);  /* Free the allocated memory when it is not needed anymore */
</code></pre>
",0
38856869,38855735,1,"<p>It is hard to tell exactly what you are trying to accomplish. Your primary issue was attempting to use an uninitialized pointer <code>phi</code> that points nowhere. Since you know the maximum number of elements, and they are a reasonable number, simply declare <code>phi[Nx * Ny]</code> and use automatic storage.</p>

<p>However, most of your additional errors flow from a failure to validate any of your file opens, or reads from the file. If your file does have the blank lines you show, then you are ill advised to use <code>fscanf</code> to attempt to read/parse the file into your actual values. You can use temporary values, but you are far better served using <code>fgets</code> to read each line into a buffer, and then parse the buffer to extract the data you need. This separates the read from the testing of the number of conversions allowing greater flexibility in testing the line and parsing the values.</p>

<p>Putting those pieces together and commenting out the unused code and header files, you could do something like the following:</p>

<pre><code>#include &lt;stdio.h&gt;

enum { Ny = 44, Nx = 88, MAXC = 128 };  /* constants */

int get_index (int i, int j);

int main (int argc, char **argv)
{
    int i, j, ki, kj, index;
    double phi[Nx * Ny] = { 0.0 };
    char buf[MAXC] = """";
    FILE *conf/*, *fp*/;

    /*
    if (!(fp = fopen (argc &gt; 1 ? argv[1] : ""test.txt"", ""w+""))) {
        fprintf (stderr, ""error: output file open failed.\n"");
        return 1;
    } */
    if (!(conf = fopen (argc &gt; 2 ? argv[2] : ""InitConditions.txt"", ""r""))) {
        fprintf (stderr, ""error: input file open failed.\n"");
        return 1;
    }

    i = j = ki = kj = index = 0;

    for (i = 0; i &lt; Nx; i++) {                  /* for each i */
        for (j = 0; j &lt; Ny; j++) {              /* for each j */
            index = get_index (i, j);           /* compute index */
            while (fgets (buf, MAXC, conf)) {   /* read line into buf */
                int tmpki, tmpkj;               /* tmp vars to hold values */
                double tmpphi;
                /* if line holds 3 values, then assign to array */
                if (sscanf (buf, ""%d %d %lf"", &amp;tmpki, &amp;tmpkj, &amp;tmpphi) == 3) {
                    ki = tmpki;
                    kj = tmpkj;
                    phi[index] = tmpphi;
                    /* test print */
                    printf ("" phi[%4d] : %.6le\n"", index, phi[index]);
                    break;
                }
            }
        }
    }
    return 0;
}

int get_index (int i, int j)
{
    int index;

    index = i * Ny + j;

    return index;
}
</code></pre>

<p>(<strong>note:</strong> since you are looping <code>i</code> and <code>j</code>, you must force the read of <code>1</code> set of values per iteration. Using <code>while (fgets...</code> and breaking the read on successful parse of values allows you to accomplish this.)</p>

<p><strong>Example Use/Output</strong></p>

<pre><code>$ ./bin/rdivals stuff dat/ivals.txt
 phi[   0] : -1.000047e+00
 phi[   1] : -1.000047e+00
 phi[   2] : -1.000047e+00
 phi[   3] : -1.000047e+00
 phi[   4] : -1.000047e+00
 phi[   5] : -1.000047e+00
 phi[   6] : -1.000047e+00
 phi[   7] : -1.000047e+00
</code></pre>

<p>Look things over and let me know if you have any questions. If I missed the logic in your question, just let me know and I'm happy to work with you further.</p>
",0
41916639,41916314,1,"<p>Your program is crashing because of this line in the <code>getString()</code> function:</p>

<pre><code>printf(""Output: %s\n"", buf[i]);
</code></pre>

<p>The value stored in <code>buf[i]</code> is a <code>char</code>, but you are trying to print it using the <code>%s</code> conversion specification, leading to undefined behavior. There are also problems in the <code>encrypt()</code> and <code>decrypt()</code> functions, where you try to find <code>strlen(buf - 1)</code>. Remember, <code>buf</code> is converted to a pointer to <code>char</code> in the expression, so this is pointer arithmetic. And if the result of a pointer arithmetic operation points to any location that is not in the array itself, or one past the end of the array, the behavior is undefined. So you have UB here also. I suspect that you meant <code>strlen(buf) - 1</code>, which should not be necessary anyway.</p>

<p>You should rewrite the <code>getString()</code> function to remove the trailing newline from the input so that you no longer need to worry about it. Furthermore, if the user enters too many characters, there will be extra characters left behind in the input stream, and it would be a good idea to discard these as well:</p>

<pre><code>void getString(char buf[])
{
    int c;
    int i = 0;

    while ((c = getchar()) != '\n' &amp;&amp; c != EOF)
        continue;                   // discard leading characters


    fgets(buf, SIZE, stdin);
    while (buf[i] != '\n' &amp;&amp; buf[i] != '\0')
    {
        ++i;
    }

    if (buf[i] == '\n')             // replace newline with '\0'
    {
        buf[i] = '\0';
    } else {
        while ((c = getchar()) != '\n' &amp;&amp; c != EOF)
            continue;               // discard extra characters
    }
}
</code></pre>

<p>Here, <code>c</code> is declared as an <code>int</code>, to hold the possible <code>EOF</code> value. There is a loop before calling <code>fgets()</code> to remove anything left in the input stream from previous calls to <code>scanf()</code>. After getting the input, there is a loop that searches the input for a <code>\n</code> character. If found, the newline is replaced with a <code>NUL</code> terminator. Otherwise, there are extra characters in the input stream and these are discarded.</p>

<p>The code that prints <code>Input:</code> and <code>Output:</code> has been moved to <code>main()</code>, where it should be, so that the transformed input can be displayed.</p>

<p>The <code>encrypt()</code> and <code>decrypt()</code> functions can easily be improved in such a way that the <code>\0</code> is not transformed:</p>

<pre><code>void encrypt(char buf[], int shift)
{
    int i = 0;

    while (buf[i] != '\0')
    {
        buf[i] = buf[i] + shift;
        ++i;
    }
}
</code></pre>

<p>Rather than using a count to control the loop, the loop continues until the <code>NUL</code> character is encountered.</p>

<p>Here is the modified code in its entirety:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#define SIZE 500

int getUserChoice(void)
{
    int decision = 0;

    printf(""-------------------------------\n"");
    printf(""| 1) Change Shift (default 3) |\n"");
    printf(""| 2) Encrypt a message        |\n"");
    printf(""| 3) Decrypt a message        |\n"");
    printf(""| 4) Quit                     |\n"");
    printf(""-------------------------------\n"");
    printf(""Option: "");
    scanf(""%d"", &amp;decision);
    if(decision &lt;= 0 || decision &gt;= 4)
    {
        return 0;
    }

    return decision;
}

int getShift(void)
{
    int key = 3;
    printf(""Enter new shift value: "");
    scanf(""%d"", &amp;key);
    return key;
}

void getString(char buf[])
{
    int c;
    int i = 0;

    while ((c = getchar()) != '\n' &amp;&amp; c != EOF)
        continue;                   // discard leading characters


    fgets(buf, SIZE, stdin);
    while (buf[i] != '\n' &amp;&amp; buf[i] != '\0')
    {
        ++i;
    }

    if (buf[i] == '\n')             // replace newline with '\0'
    {
        buf[i] = '\0';
    } else {
        while ((c = getchar()) != '\n' &amp;&amp; c != EOF)
            continue;               // discard extra characters
    }
}

void encrypt(char buf[], int shift)
{
    int i = 0;

    while (buf[i] != '\0')
    {
        buf[i] = buf[i] + shift;
        ++i;
    }
}

void decrypt(char buf[], int shift)
{
    int i = 0;

    while (buf[i] != '\0')
    {
        buf[i] = buf[i] - shift;
        ++i;
    }
}

int main(void)
{
    char userStr[SIZE];
    int shift = 3;
    int number;
    while(1)
    {
         number = getUserChoice();
        if(number == 1)
        {
            shift = getShift();
        }
        if (number == 2)
        {
            printf(""Input: "");
            getString(userStr);
            encrypt(userStr, shift);
            printf(""Output: %s\n"", userStr);
        }
        if (number == 3)
        {
            printf(""Input: "");
            getString(userStr);
            decrypt(userStr, shift);
            printf(""Output: %s\n"", userStr);
        }
        if (number == 0)
        {
            break;
        }
    }
    return 0;

}
</code></pre>

<p>And here is a sample interaction:</p>

<pre><code>-------------------------------
| 1) Change Shift (default 3) |
| 2) Encrypt a message        |
| 3) Decrypt a message        |
| 4) Quit                     |
-------------------------------
Option: 2
Input: hello world
Output: khoor#zruog
-------------------------------
| 1) Change Shift (default 3) |
| 2) Encrypt a message        |
| 3) Decrypt a message        |
| 4) Quit                     |
-------------------------------
Option: 3
Input: khoor#zruog
Output: hello world
-------------------------------
| 1) Change Shift (default 3) |
| 2) Encrypt a message        |
| 3) Decrypt a message        |
| 4) Quit                     |
-------------------------------
Option: 4
</code></pre>
",0
40529718,40529660,1,"<p>A pointer to pointer and a 2D array are not interchangeable, change to:</p>

<pre><code>int (*ipp)[4]; /* A pointer to an array of 4 ints */
...
ipp = ventas;
</code></pre>
",1
40529873,40529660,1,"<p>When you have such casting like</p>

<pre><code>ipp = (int **)ventas;
</code></pre>

<p>then the value of the variable is the address of the first element of the array <code>ventas</code>. In this case after dereferencing the pointer</p>

<pre><code>*ipp
</code></pre>

<p>you get the value stored at this address. If to assume that <code>sizeof( int )</code> is equal to <code>sizeof( int * )</code> than the first element of the array equal to 1 is considered as a memory address. After applying second dereferencing</p>

<pre><code>**ipp
</code></pre>

<p>you get memory access violation.</p>

<p>It will be correct to write either like</p>

<pre><code>int ( *ipp )[4] = ventas;
</code></pre>

<p>and then</p>

<pre><code>printf(""%d\n"", **ipp);
</code></pre>

<p>or like</p>

<pre><code>int *ipp = ( int * )ventas;
</code></pre>

<p>and then</p>

<pre><code>printf(""%d\n"", *ipp);
</code></pre>
",0
40529793,40529660,1,"<ul>
<li><p>A pointer-to-pointer is not an array. Nor is it a pointer to a 2D array. They aren't the slightest compatible. Just forget about pointer-to-pointers in this case.</p></li>
<li><p>If you want a pointer to a 2D array, you must write <code>int (*ipp)[3][4] = &amp;ventas;</code></p></li>
<li><p>You can't print a pointer using <code>%d</code> format specifier. You should use <code>%p</code>.</p></li>
</ul>

<p>Corrected code for printing the address of the 2D array:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void){
  int ventas [3][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};
  int (*ipp)[3][4];

  ipp = &amp;ventas;
  printf(""%p\n"", ipp);

  return 0;
}
</code></pre>
",3
36233856,36233424,0,"<p>What follows is not a full solution, but some hints on how you might want to proceed with your problem.</p>

<p>What you want is only achievable by first counting how many fractional digits your input numbers have - That decides how many fractional digits you need in the output. Obviously, that will only work if you have a string representation of your numbers.</p>

<pre><code>/* necessary casts removed for clarity */
int fractionalDigs1 = arg1 + strlen(arg1) - strchr (arg1, '.') - 1;
int fractionalDigs2 = arg2 + strlen(arg2) - strchr (arg2, '.') - 1;
</code></pre>

<p>For addition of two numbers, you would want to have the output fractional digit count the maximum of the two input arguments' fractions, for multiplication the sum - you decide.</p>

<pre><code>int fractionalDigsOut = max (fractionalDigs1, fractionalDigs2);
</code></pre>

<p>Output with a non-constant field width works with the field-width format specifier <code>*</code> like so (<code>*</code> takes an argument from the argument list and uses it as a field width):</p>

<pre><code>printf (""%8.*f"", fractionalDigitsOut, num);
</code></pre>
",0
38980239,38980177,3,"<p>The loop</p>

<pre><code>for(i=1;i&lt;=t;i+2)
</code></pre>

<p>in the function <code>series()</code> is an infinite loop when <code>t &gt;= 1</code> because <code>i</code> isn't updated in the loop. Try changing <code>+</code> to <code>+=</code> and use</p>

<pre><code>for(i=1;i&lt;=t;i+=2)
</code></pre>

<p>instead. Also it seems you should use type <code>int</code> for <code>x</code> and <code>n</code> in the function <code>main()</code> because the arguments of <code>series()</code> is <code>int</code>. Don't forget to change the format specifier when changing their types.</p>
",0
40987431,40987379,3,"<p>You have passed in a <code>char</code> type to something that expected a <code>const void*</code>.  This would have been okay if you had passed it a <code>char*</code>.  You can do that as either <code>&amp;fileLine[10]</code> or <code>fileLine + 10</code>.</p>

<p>Since you are offsetting by 10, you also want to ensure you copy 10 fewer characters:</p>

<pre><code>memcpy(line, &amp;fileLine[10], stringLength-10);
</code></pre>

<p>Although you probably want to copy the string terminator too...</p>

<pre><code>memcpy(line, &amp;fileLine[10], stringLength-9);
</code></pre>

<p>Yuck!</p>

<p>Instead, you could use <code>strcpy</code>:</p>

<pre><code>strcpy(line, fileLine + 10);
</code></pre>

<p>In all cases, make sure that <code>line</code> is an array or a pointer to memory that is actually allocated to your process.</p>
",0
40987528,40987379,0,"<p>You can use getline function to get part of the string. But first, you have to move your read pointer to the position from which you want to read using seekg function.
seekg(ios flag, bytes);
cin.getline(source, number of characters, ending character);</p>
",0
47695688,47695508,4,"<p>Nothing is wrong with the macro definition. However, the <code>if</code> condition needs an explanation.</p>

<p>Note the difference between:</p>

<pre><code>if (var == TRUE) 
</code></pre>

<p><code>1</code> makes the condition true and every other value makes it false.</p>

<p>and </p>

<pre><code>if (var) 
</code></pre>

<p>Every value except <code>0</code> makes the condition true. Only <code>0</code> makes it false.</p>
",1
40577044,40576958,1,"<p>Depends on the type of data, and what you plan to do with it. If it's a small enough file that sits in a single buffer, just load the file and then <em>throw out</em> whichever parts you don't want from the buffer.</p>

<p>If the data needs to be loaded into a data structure other than a flat buffer, then you'll need to process the input, probably line-by-line, building the structure and throwing out what you don't need as you go.</p>

<p>Note that the standard file routines can read a byte or line of text efficiently (they still use a larger buffer internally).</p>

<p>Other than that, you're question really isn't that clear.</p>
",0
40577125,40576958,0,"<p>First, you should define which encoding is your text file using. On most operating systems, it would be <a href=""http://utf8everywhere.org/"" rel=""nofollow noreferrer"">UTF-8</a> (so <a href=""http://unicode.org/"" rel=""nofollow noreferrer"">Unicode</a> characters can take several bytes each).</p>

<p>Then, the notion of word is probably (human) language specific. I'm not sure it would be the same in English (BTW, <code>gklk6k</code>  is <em>not</em> an English word, it does not appear in any English dictionnary), in ancient Greek, in Russian, in Japanese, in Chinese. Notice that the notion of letter is not as simple as you would imagine (Unicode has much more letters than <code>A</code> ... <code>Z</code> &amp; <code>a</code> ... <code>z</code>; my family name in Russian is <code>§³§ä§Ñ§â§í§ß§Ü§Ö§Ó§Ú§é</code> and all these letters are outside of <code>A</code> ... <code>Z</code>  &amp; <code>a</code> ... <code>z</code>, and they need more than one byte each). And what about <a href=""https://en.wikipedia.org/wiki/Combining_character"" rel=""nofollow noreferrer"">combining characters</a>? <a href=""https://en.wikipedia.org/wiki/Greek_diacritics"" rel=""nofollow noreferrer"">Greek diacritics</a>? What exactly are words for you, how can they be separated? What about punctuation?</p>

<p>If your system provides it, I would use <a href=""http://man7.org/linux/man-pages/man3/getline.3.html"" rel=""nofollow noreferrer"">getline(3)</a> to read a line and have a loop around that. Then process every line. Splitting it into words is itself interesting. You could use some UTF-8 library like <a href=""http://site.icu-project.org/"" rel=""nofollow noreferrer"">ICU</a>, <a href=""https://developer.gnome.org/glib/stable/glib-Unicode-Manipulation.html"" rel=""nofollow noreferrer"">Glib</a> (from <a href=""http://gtk.org/"" rel=""nofollow noreferrer"">GTK</a>) etc etc...</p>

<p>In other words, you should <strong>define <em>first</em> what your input can be</strong> (and a few examples <em>don't</em> constitute a definition). Perhaps you could specify the possible valid input using <a href=""https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form"" rel=""nofollow noreferrer"">EBNF</a> notation. Maybe reading more about <a href=""https://en.wikipedia.org/wiki/Lexical_analysis"" rel=""nofollow noreferrer"">lexing</a> &amp; <a href=""https://en.wikipedia.org/wiki/Parsing"" rel=""nofollow noreferrer"">parsing</a> techniques is relevant.</p>
",2
40578211,40576958,1,"<p>Based of your comment we came to this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;

int evenCheck(const char *ptr);
size_t middleCheck(const char *ptr);

int main(void){
    const char *ptr = ""t4k4k"";
    size_t middle = middleCheck(ptr);

    if( evenCheck(ptr) == 0){
        printf(""Output to file the word %s\n"",ptr);
    }else{
        if ( isdigit(ptr[middle]) ){
            printf(""Ignoring the word %s, because has the number %c in the middle\n"",ptr, ptr[middle]);
        }else{
            printf(""Output to file the word %s, because the middle is %c which is a Letter\n"",ptr, ptr[middle]);
        }
    }
}

int evenCheck(const char *ptr){
    size_t len = strlen(ptr);

    if ( (len % 2) ){
       return 1;
    }

    return 0;
}

size_t middleCheck(const char *ptr){
    size_t middle = strlen(ptr) / 2;

    return middle;
}
</code></pre>

<p>Output:</p>

<pre><code>Output to file the word t4k4k, because the middle is k which is a Letter
</code></pre>

<p>Now you were asking about how to do this if the file has more than one word.</p>

<p>Well one option will be to save the file in a <a href=""https://www.tutorialspoint.com/cprogramming/c_multi_dimensional_arrays.htm"" rel=""nofollow noreferrer"">Multi-Dimensional array</a> or read the whole file.</p>

<p>I'm sure you can do it, if not come back with another Question.</p>
",0
39122958,39122868,0,"<pre><code>struct player
{
char name[20];
enum cell token;
unsigned score;
};


BOOLEAN init_player2(struct player *second, enum cell token)
{
    second-&gt;token= 1;
}

int main()
{
    struct player second;
    init_player2(&amp;second, second.token);
    printf(""The value of second token is: %d\n"", second.token);

    return 0;
}
</code></pre>

<p>You just need to use variable of structure inside function using pointer to change the value. </p>
",1
39122900,39122868,4,"<p>C uses pass-by-value for function argument passing.</p>

<p>In your code, <code>second.token</code> is passed by value, so any change made to it inside the function will not reflect to the caller.</p>

<p>What you're expecting, is the below code </p>

<pre><code>void change( int x)
{
      x = 10;
}

int main(void)
{
    int p = 5;
    change(p);
    printf(""%d\n"", p);
    return 0;
}
</code></pre>

<p>to print 10, which is simply not possible. (If you make the call as <code>change(15);</code>, <em>imagine the horror</em>.)</p>

<p>Solution:</p>

<p>You don't need to pass the second argument separately. You're already passing the pointer to the structure containing the enum variable, just use the pointer to change the value in the called function, and then in the caller, print the value of the enum member of the structure variable.</p>
",1
45677115,43080264,2,"<p>This is an artefact of ""smart"" text editors.</p>

<p>The code is supposed to read:</p>

<pre><code>inorder(r);
printf(""\nPreorder = "");
preorder(r);
</code></pre>

<p>where <code>r</code> is a <code>struct node *</code>.</p>

<p>The original author pasted the text and didn't check, smart text editing transformed (r) into the copyright sign.</p>

<p>Note that <code>inorder</code> and <code>preorder</code> are functions defined earlier in the code.</p>
",0
41180678,41180360,0,"<p>If the problem is entering name with spaces, like Name and Surname you should use <a href=""https://linux.die.net/man/3/fgets"" rel=""nofollow noreferrer"">fgets</a> to retrieve input string and remove manually the newline char</p>

<pre><code>#include&lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
{
    char name1[27];
    int maths;
    int physics;
    int Cs;
    int bio;
    int english;
    int urdu;
    int ps;
    int isl;

    printf(""What is your name : "");
    fgets(name1, sizeof(name1), stdin);
    name1[strcspn(name1, ""\n"")] = 0;

    printf(""\n\nwhat is your score in Mathematics : "");
    scanf("" %d"",&amp;maths);
    printf(""\n\nwhat is your score in physics : "");
    scanf("" %d"",&amp;physics);
    printf(""\n\nwhat is your score in computer science : "");
    scanf("" %d"",&amp;Cs);
    printf(""\n\nwhat is your score in biology : "");
    scanf("" %d"",&amp;bio);
    printf(""\n\nwhat is your score in English : "");
    scanf("" %d"",&amp;english);
    printf(""\n\nwhat is your score in Urdu : "");
    scanf("" %d"",&amp;urdu);
    printf(""\n\nwhat is your score in Pakistan study : "");
    scanf("" %d"",&amp;ps);
    printf(""\n\nwhat is your score in Islamiat : "");
    scanf("" %d"",&amp;isl);

    printf(""\n****************************************************************************************"");
    printf(""\nName            Mathematics    Physics    Com.sc    Biology    English    Urdu    Pak-Study    Islamiat"");
    printf(""\n****************************************************************************************"");
    printf(""\n%-16s%-15d%-11d%-10d%-11d%-11d%-8d%-13d%0d"",name1,maths,physics,Cs,bio,english,urdu,ps,isl);
    return (0);
}
</code></pre>
",0
40577526,40576703,0,"<p>Anytime a function returns malloc'd memory, you've got a hot potato.  You have to free that memory and cannot pass it on unless you've documented you're doing so.  And you mustn't lose hold of (e.g. reuse) the pointer before freeing it.  Below is how I interpret how <code>read_buffer()</code> needs to work.  Since ""buffer length is unknown"" I'm assuming it comes from <code>malloc</code> and we can use <code>realloc</code>:</p>

<pre><code>static int read_buffer(int const fd, char **buffer)
{
    char local_buffer[BUFF_SIZE + 1];

    int bytes_read = read(fd, local_buffer, BUFF_SIZE);

    if (bytes_read &gt; 0)
    {
        local_buffer[bytes_read] = '\0';

        char *joined = ft_strjoin(*buffer, local_buffer);

        if (joined != NULL)
        {
            *buffer = realloc(*buffer, strlen(joined) + 1);

            if (*buffer != NULL)
            {
                ft_strcpy(*buffer, joined);
            }
            else
            {
                bytes_read = -1;
            }

            free(joined);
        }
        else {
            bytes_read = -1;
        }
    }

    return bytes_read;
}
</code></pre>

<p>Note that there are a lot of potential pitfalls that you need to test for and recover from.</p>

<p>If you're reading from the user directly, and don't want newlines as part of the concatenation of strings, you can replace this line:</p>

<pre><code>     local_buffer[bytes_read] = '\0';
</code></pre>

<p>with something like:</p>

<pre><code>    if (local_buffer[bytes_read - 1] == '\n')
    {
        local_buffer[bytes_read - 1] = '\0';
    }
    else
    {
        local_buffer[bytes_read] = '\0';
    }
</code></pre>

<p>Assuming the above newline fix, here's a small test program I wrote:</p>

<pre><code>int main() {

    char *buffer = malloc(1);

    *buffer = '\0';

    for (int i = 0; i &lt; 3; i++)
    {
        (void) read_buffer(0, &amp;buffer);

        puts(buffer);
    }

    free(buffer);

    return 0;
}
</code></pre>

<p><strong>RESULT</strong></p>

<pre><code>&gt; ./a.out
abcdefg
abcdefg
hijklmn
abcdefghijklmn
opqrstu
abcdefghijklmnopqrstu
&gt; 
</code></pre>
",2
44371399,44371325,3,"<p>You are using string literal, which is <code>const char</code>, so you cannot modify it.</p>

<p>You can change it to</p>

<pre><code>char permenant[]=""Won&amp;acute;t Get Fooled Again"";
</code></pre>

<p>It will generate an array of <code>char</code>s initialized with the literal string's characters.</p>

<p>Side note: the <code>s</code> pointer is totally useless. You can perform your checks on <code>permanent</code> directly.</p>
",5
44371432,44371325,3,"<p>You may want to have a look at</p>

<pre><code>char *strstr(const char *haystack, const char *needle)
</code></pre>

<p>It returns the pointer to the first time that <code>needle</code> shows up in <code>haystack</code>. Just take the return pointer and write your replacement character to it.</p>

<p>PS: It is part of <code>&lt;string.h&gt;</code></p>
",1
44371805,44371325,0,"<p>Okay, your code has several issues which have been pointed out already.</p>

<p>To recap:</p>

<ul>
<li>You can't modify a string expressed like that, you need a character array.</li>
<li>You should use <code>strstr()</code> to find sub-strings, not hand-written comparison chains.</li>
<li>You should use <code>memmove()</code> to compact the string when doing the replacement.</li>
</ul>

<p>Here's my attempt:</p>

<pre><code>void replaceShorten(char *s, const char *what, const char *withWhat)
{
  char *hit;
  const size_t wLen = strlen(what);
  const size_t wwLen = strlen(withWhat);
  if(wwLen &gt;= wLen)
    return;
  while((hit = strstr(s, what)) != NULL)
  {
    memcpy(hit, withWhat, wwLen);
    memmove(hit + wwLen, hit + wLen, strlen(hit + wLen) + 1);
    s = hit + wwLen;
  }
}
</code></pre>

<p>This is not optimized for maximum speed (it could use fewer calls to <code>strlen()</code>) but perhaps somewhat clear. It seems to work, when used like this:</p>

<pre><code>char s[] = ""Don&amp;acute;t do it!"";
replaceShorten(s, ""&amp;acute;"", ""'"");
</code></pre>

<p>Note that it <em>must</em> shorten the string when doing the replacement, as the name implies. Arbitrary replacement is not supported.</p>
",2
44374888,44371325,0,"<p>Personally, I'd break this down as follows:</p>

<ul>
<li>First, <em>don't</em> attempt to modify the input string; instead, write the converted string to a different buffer;</li>
<li>Second, break your operations up into different functions - one to find the entity in the string, one to map the entity onto a replacement string, one to perform the replacement, etc;</li>
<li>Third, use a lookup table or something instead of trying to match individual characters.</li>
</ul>

<p>Here's a pass off the top of my head - it undoubtedly has some ugly bugs, but it should give you a flavor of what I'm trying to do:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

/**
 * Create a structure to map an entity name onto a replacement string...
 */
struct entity_lookup {
   char *entity_name;
   char *replacement;
};

/**
 * ... and use that structure to build the lookup table
 */
static const struct entity_lookup lookup_table[] =  {
  { ""acute"", ""'"" },
  { ""amp"", ""&amp;"" },
  { ""apos"", ""'""},
  { ""lt"", ""&lt;"" },
  { ""gt"", ""&gt;"" },
  { ""nbsp"", "" "" },
  { NULL, NULL }
};

/**
 * Scan the input string for the next entity, which begins with the
 * character '&amp;' and ends with ';' - if we don't find the trailing
 * ';', then we treat the '&amp;' as a literal character.  Returns the location
 * of the first character of the entity name in the string.  
 */
char *getNextEntity( const char *str, char **start, size_t *len )
{
  *len = 0;
  *start = strchr( str, '&amp;' );

  if ( *start )
  {
    *start = *start + 1; // we want the text *following* &amp;
    const char *end = strchr( *start, ';' );
    if ( end )
    {
      *len = end - *start - 1;
    }
    else
    {
      *start = NULL;
      *len = 0;
    }
  }

  return *start;
 }

/**
 * Find the replacement string for the given entity name.  Since our lookup
 * table is so small, a linear search is just fine in this case.
 */
char *getEntityReplacement( const char *entity )
{
  const struct entity_lookup *entry = lookup_table;

  while ( entry-&gt;entity_name != NULL &amp;&amp; strcmp( entity, entry-&gt;entity_name ) )
  {
    entry++;
  }

  return entry-&gt;replacement;
}

/**
 * Replace any and all entities in an input string.  This code tries
 * to avoid any buffer overflows, but it's not very pretty and I haven't
 * exercised it that well.  I'm sure I could come up with a more elegant
 * method, but I've spent enough time on this already.
 */
void replaceEntities( const char * restrict input, char * restrict output, size_t maxOutputLen )
{
  char *entityStart = NULL;
  size_t entityLen = 0;

  /**
   * Initially point to the beginning of the input string.
   */
  const char *current = input;

  /**
   * Initially write an empty string to the output buffer.
   */
  *output = 0;

  /**
   * Look for the next entity; if we find one, copy everything from
   * the current position in the input buffer up to (but not including) 
   * the first character of the entity; then we copy the replacement
   * for the entity to the output buffer.
   */
  while ( getNextEntity( current, &amp;entityStart, &amp;entityLen ) )
  {
    if ( strlen( output ) + entityStart - current - 1 &lt;  maxOutputLen - 1 )
    {
      /**
       * Copy everything from the current position to the start of the
       * entity to the output buffer; for example, copy ""Won"" to 
       * the output.
       */
      strncat( output, current, entityStart - current - 1 );

      /**
       * Find the entity in the lookup table.
       */
      char entityText[20] = {0};
      strncpy( entityText, entityStart, entityLen + 1 );

      char *repl = getEntityReplacement( entityText );

      /**
       * If there's a match and there's room in the output buffer,
       * write the replacement text to the output buffer, e.g., ""'""
       */
      if ( repl &amp;&amp; strlen( output ) + strlen( repl ) &lt; maxOutputLen - 1 )
        strcat( output, repl );
      else
      {
        output[maxOutputLen] = 0;
        return;
      }
      current = entityStart + entityLen + 2;
    }
    else
    {
      output[maxOutputLen] = 0;
      return;
    }
  }

  /**
   * If we don't find any more entities, write the remainder of the input
   * string to the output buffer, e.g., ""t Get Fooled Again""
   */
  if ( strlen( output ) + strlen( current ) &lt; maxOutputLen - 1 )
    strcat( output, current );
}

int main( int argc, char **argv )
{
  char output[128];

  replaceEntities( argv[1], output, sizeof output );

  printf( ""Original: %s\n"", argv[1] );
  printf( ""Stripped: %s\n"", output );

  return 0;
}
</code></pre>

<p>As always, the proof is in the pudding - here are some example runs:</p>

<pre><code>$ ./entities ""Won&amp;acute;t Get Fooled Again""
Original: Won&amp;acute;t Get Fooled Again
Stripped: Won't Get Fooled Again

$ ./entities ""Won&amp;acute;t&amp;nbsp;Get&amp;nbsp;Fooled&amp;nbsp;Again""
Original: Won&amp;acute;t&amp;nbsp;Get&amp;nbsp;Fooled&amp;nbsp;Again
Stripped: Won't Get Fooled Again

$ ./entities ""Black &amp;amp; Blue""
Original: Black &amp;amp; Blue
Stripped: Black &amp; Blue

$ ./entities ""Black &amp; Blue""
Original: Black &amp; Blue
Stripped: Black &amp; Blue

$ ./entities ""#include &amp;lt;stdio.h&amp;gt;""
Original: #include &amp;lt;stdio.h&amp;gt;
Stripped: #include &lt;stdio.h&gt;
</code></pre>

<p>This code is too fragile for production use, but again, it should give you some ideas.  </p>
",0
39114828,39114334,1,"<p>You're using <code>cicleProgram()</code> as your signal handler (despite it having the wrong type ¡ª it should take an <code>int</code> argument).  That means you never return from the signal handler until you type <code>q</code> or <code>Q</code>, and the system is probably blocking the signal until the first signal handler returns.  So, you never get the second signal ¡ª it is blocked.</p>

<p>Use a separate signal handler function.  See also <a href=""https://stackoverflow.com/questions/231912/"">What is the difference between <code>sigaction()</code> and <code>signal()</code>?</a> and use <code>sigaction()</code> in preference to <code>signal()</code>.</p>

<p>And use <code>int main(void)</code> ¡ª with at least the return type.  Even the old (C99) version of the standard requires that, let alone the current (C11) standard.  We've progressed to the 21st Century; don't code in 20th Century C!</p>

<p>See also <a href=""https://stackoverflow.com/questions/16891019/"">How to avoid using <code>printf()</code> in a signal handler?</a> for information on what you can do in a signal handler.</p>

<hr>

<blockquote>
  <p>Could I add some control in that ""while"" in order to evaluate the signal alarm and avoid the deadlock?</p>
</blockquote>

<p>There are multiple problems with the original code, and not all possible problems were diagnosed.  An additional problem was that if the alarm fired, there was nothing to set the alarm again, so the program falls into waiting until you type a character.</p>

<p>Here's some experimental code you play with:</p>

<pre><code>#include &lt;assert.h&gt;
#include &lt;signal.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

static int duration = 2;
static volatile sig_atomic_t alarm_fired = 0;

static void alarm_handler(int signum)
{
    //signal(SIGALRM, alarm_handler);
    write(STDOUT_FILENO, ""Signalled!\n"", 11);
    alarm_fired = signum;
    alarm(duration);
}

static void cicleProgram(void)
{
    int opcion = 0;
    while (opcion != 'q' &amp;&amp; opcion != 'Q')
    {
        signal(SIGALRM, alarm_handler);
        alarm(duration);
        if ((opcion = getchar()) == EOF)
            clearerr(stdin);
        if (alarm_fired)
        {
            alarm_fired = 0;
            printf(""Alarm!\n"");
        }
        printf(""c = %d\n"", opcion);
    }
}

static void actionProgram(void)
{
    struct sigaction sa = { 0 };
    sa.sa_handler = alarm_handler;
    sa.sa_flags = 0;
    sigfillset(&amp;sa.sa_mask);
    sigaction(SIGALRM, &amp;sa, 0);

    int opcion = 0;
    while (opcion != 'q' &amp;&amp; opcion != 'Q')
    {
        alarm(duration);
        if ((opcion = getchar()) == EOF)
            clearerr(stdin);
        if (alarm_fired)
        {
            alarm_fired = 0;
            printf(""Alarm!\n"");
        }
        printf(""c = %d\n"", opcion);
    }
}

int main(void)
{
    printf(""Using signal (q to quit):\n"");
    cicleProgram();
    printf(""Using sigaction (q to quit):\n"");
    actionProgram();
    return 0;
}
</code></pre>

<p>There are two active functions, each with a loop.  The first is based on your original <code>cicleProgram()</code> but the function has been revamped; it is no longer the signal handler.  I am running on Mac OS X (BSD-based), and these systems do not require you to reset the <code>signal()</code> handler in the signal handler function.  The second function, <code>actionProgram()</code>, uses <code>sigaction()</code> instead of <code>signal()</code>.  It probably isn't necessary, but it gives you something to look at.  The absence of <code>SA_RESTART</code> in the <code>sa.sa_flags</code> element means that the <code>read()</code> system call reports that it was interrupted each time the signal goes off.  The code in the <code>signal_handler()</code> doesn't use disallowed function calls.</p>

<p>Example output (program name <code>al97</code>):</p>

<pre><code>$ ./al97
Using signal (q to quit):
Signalled!
Signalled!
Signalled!
Signalled!
WonderfulSignalled!

Alarm!
c = 87
c = 111
c = 110
c = 100
c = 101
c = 114
c = 102
c = 117
c = 108
c = 10
Signalled!
Signalled!
q
Alarm!
c = 113
Using sigaction (q to quit):
c = 10
Signalled!
Alarm!
c = -1
Signalled!
Alarm!
c = -1
Signalled!
Alarm!
c = -1
Signalled!
Alarm!
c = -1
ASignalled!
Alarm!
c = -1
lso workingSignalled!
Alarm!
c = -1

c = 65
c = 108
c = 115
c = 111
c = 32
c = 119
c = 111
c = 114
c = 107
c = 105
c = 110
c = 103
c = 10
qSignalled!
Alarm!
c = -1

c = 113
$
</code></pre>

<p>There were some quite long pauses in the run, but you can experiment on your machine.  You may need to reinclude the <code>signal()</code> in the <code>alarm_handler()</code> function for <code>cicleProgram()</code> and use a different handler (that doesn't use <code>signal()</code>, as now) for <code>actionProgram()</code>.</p>
",3
36297295,36297041,1,"<p>This code uses the modulus operation to pick a 1 or a 0 off the right side of the binary number that was entered and store it in <code>remainder</code>. Each 1 or 0, stored in <code>remainder</code>, is then multiplied by the value it represents, represented by <code>j</code>, and then added to the <code>decimalNumber</code>. The binary number is then divided by 10 to shift all the digits to the right. This repeats until there are no more 1's left in the binary number.</p>
",0
39129827,39129735,0,"<p>While in forward declarations you don't need to give parameter's name only type is required (while you can provide name). But this doesn't have to be same as when you define the function . </p>

<p>In funciton definition say <code>void my_func(int i){..}</code> , in this function parameter is of type <code>int</code> and variable name is <code>i</code> . You can access it's value by variable name <code>i</code> inside the function block.</p>

<p>Also ,there is no re-declaration of variables as these have scope limited to function block.  </p>

<p>There is basically no difference in those methods , it's convention how you use it.</p>
",0
39129839,39129735,0,"<p>This would work too:</p>

<pre><code>void my_func(int);
</code></pre>

<p>In function signatures it's not about the <strong>name</strong> of the arguments but about the <strong>type</strong>.</p>

<p>There are special rules for when you declare an external variable with the same name as a parameter</p>

<pre><code>int idum1 = 1;

void my_func(int idum1)
{
  idum1++;
}
</code></pre>

<p>Here the variable with the most local scope is incremented, not the external.</p>
",0
40750461,40750355,0,"<p>Only unsigned int has defined overflow behavior, signed int does not, so compiler could throw away half of your code if it detect it. Anyway in your code int never will be bigger than INT_MAX because on overflow it should be negative value.</p>
",0
40750471,40750355,0,"<p>If you try int max / i &lt; x for the overflow ?</p>
",0
40750381,40750355,-3,"<p><code>x == INT_MAX</code> only tests if <code>x</code> is <strong>exactly equal</strong> to <code>INT_MAX</code>. Not less, not more, <em>exactly equal</em>.</p>

<p>What you should be testing for is signed integer overflow, which happens when you multiply by 1627964 by 8:  <code>if (x==INT_MAX || x &lt; 0)</code> - the sign bit gets incremented which makes your value negative.</p>
",5
41000910,41000638,1,"<ol>
<li><p>There are variation depending on keyboard and stdin, but getche() gets the key without echoing. When the user types Enter, the un C-ified char may be '\n' or '\r'. When this is printed you get the corresponding line-feed or carriage return. Since Enter maps to '\r' on your keyboard, when fetched via getche(), test for that and print '\n'. When fetched via getchar(), C translates the Enter to '\n'.</p>

<p>int ch = getche();</p>

<p>if (ch == '\r') c = '\n';</p>

<p>printf(""%c"", ch);</p></li>
<li><p>Use int c so code can check for EOF.</p></li>
</ol>
",0
40778796,40778662,10,"<p>This works if you are using Windows or another operating system that ignores case on its file system. It doesn't work on Linux and other Unix flavours, because they do care about case (by default).</p>

<p>When you add an include statement like <code>#include &lt;any_file.h&gt;</code>, then the C-compiler will ask the operating system to open file <code>any_file.h</code>.</p>

<p>If your operating system doesn't care about case, then it will open any file that matches the pattern. If it, for instance, finds a file named <code>aNy_fILe.H</code>, it will open the file and present it to the C compiler.</p>

<p>The C-compiler will interpret the content of the file - this is the case-sensitive bit of the C language.</p>
",0
39128251,39127968,0,"<p>This invokes undefined behavior, which means that anything can happen in your program.</p>

<p>See the C99 spec, specifically <em>J.2 Undefined Behavior:</em></p>

<blockquote>
  <p>The behavior is undefined in the following circumstances: <em>[...]</em></p>
  
  <ul>
  <li>Between two sequence points, an object is modified more than once, or is modified and the prior value is read other than to determine the value to be stored (6.5).</li>
  </ul>
</blockquote>

<p>As a rule of thumb, ""between two sequence points"" means between two semicolons (<code>;</code>) that end a statement. The ""object"" mentioned in the excerpt is the variable <code>c</code>.</p>

<p>With that out of the way, we can clearly see that the object is modified twice between two sequence points. It's modified once during the evaluation of the expression <code>c++</code> and once during the assignment.</p>
",0
40957882,40957874,5,"<p>Use the <code>c</code> conversion specifier:</p>

<pre><code>printf(""%c\n"", (char) 89);
</code></pre>

<p>or as pointed out by <em><a href=""https://stackoverflow.com/users/4593267/chqrlie"">chqrlie</a></em>'s <a href=""https://stackoverflow.com/questions/40957874/how-to-print-ascii-instead-of-integer-in-c/40957882#comment69124978_40957882"">comment</a>, just simply:</p>

<pre><code>printf(""%c\n"", 89);
</code></pre>

<p>or with context:</p>

<pre><code>char c = 89;  /* or int c = 89; */

printf(""%hhd is '%c'.\n"", c, c);
</code></pre>

<hr>

<p><a href=""http://www.iso-9899.info/n1570.html#7.21.6.1p8"" rel=""nofollow noreferrer"">Referencing the C11 Standard (draft)</a>:</p>

<blockquote>
  <p><strong>7.21.6.1 The <code>fprintf</code> function</strong></p>
  
  <p>[...]</p>
  
  <p>8 The conversion specifiers and their meanings are:</p>
  
  <p>[...]</p>
  
  <p>c </p>
  
  <p>[...] the <code>int</code> argument is converted to an
  <code>unsigned char</code>, and the resulting character is written.</p>
</blockquote>
",9
40957884,40957874,6,"<p>Assuming you have an integer <code>int value = 89;</code> you can</p>

<ul>
<li><p>use <code>printf(""%c"", value);</code> instead of <code>printf(""%d"", value);</code>.</p></li>
<li><p>or simply <code>putchar(value);</code></p></li>
</ul>

<p>Note however that <code>Y</code> is not the ASCII value of <code>89</code>. It is the other way around: character <code>Y</code> has an ASCII value of <code>89</code>.  The C language supports different character sets besides ASCII, so <code>'Y'</code> might not necessarily have the value <code>89</code>, indeed its value is <code>232</code> on IBM Mainframes that still use the EBCDIC character set.</p>
",0
36359136,36359041,6,"<p>In the environment where you run the program <code>sizeof(int)</code> is equal to <code>4</code>.</p>

<p>The size of the array can be calculated like</p>

<pre><code>size = sizeof( array ) / sizeof( int );
</code></pre>

<p>Take into account the type of the value returned by the operator <code>sizeof</code> is <code>size_t</code>. So it would be better to use this type for the size of the array.</p>

<p>Also you could introduce a manifest constant for number <code>5</code>. As for example</p>

<pre><code>#define N 5
</code></pre>

<p>and declare the array like</p>

<pre><code>int array[N];
</code></pre>

<p>Or if the compiler supports variable length arrays you could write</p>

<pre><code>int main( void )
^^^^^^^^^^^^^^^^
{
    const size_t N = 5;
    int array[N];

    //...
</code></pre>
",1
36360096,36359041,0,"<p>The architecture of the compiler in which you're executing your code is 32bit so the size of int is 32bits = 4 bytes.</p>

<p><code>size = sizeof(int)</code>
will return 
<code>size = 4</code>
and you will be only able to enter four values.</p>
",1
45785524,45785464,1,"<p><code>^</code> is the operator for bitwise xor, not exponentiation. When n=10 the expression <code>10^n</code> evaluates to 0 which causes <code>cardnumber % (10^n)</code> to become a divide by zero.</p>
",2
36372855,36372749,1,"<p>You are dereferencing pointer to pointer in</p>

<pre><code>char **output_matrix[10][10];
draw_character(ASCII_Value, font, height, **output_matrix[7][7]);
</code></pre>

<p>Instead, pass array:</p>

<pre><code>draw_character(ASCII_Value, font, height, output_matrix);
</code></pre>
",2
45106137,45105920,1,"<p>It's undefined behavior to use the value of an uninitialized (auto) variable that could have been declared with the <code>register</code> keyword (see <a href=""http://port70.net/~nsz/c/c11/n1570.html#6.3.2.1p2"" rel=""nofollow noreferrer"">6.3.2.1p2</a> in the C standard).</p>

<p><code>int XY;</code> could have been declared with <code>register</code> (you're not taking its address anywhere) and it's still unitialized at the right hand side of <code>int XY = XY;</code>, so the behavior is undefined.</p>

<p>If you did <code>int XY = *&amp;XY;</code> the behavior would no longer be undefined, but <code>XY</code> would get an indeterminate value.</p>
",11
40955790,40954807,1,"<p>Continuing from my comment, you are currently overrunning the bounds of <code>word</code> using your loop indexing of <code>for (j = 3; j &lt; 10; j++)</code>. You additionally have no idea what will be in <code>word[0-2]</code> as <code>word</code> is not initialized and you never fill indexes <code>0-2</code> with anything. Also, in C when you declare <code>char word[8];</code> there are only <code>8</code> characters that you can add to <code>word</code> in indexes <code>0-7</code>. </p>

<p>If you intend to use the array as a <em>character-string</em>, then C requires that the string be <em>nul-terminated</em> (e.g. have the <em>nul-byte</em>, i.e. <code>0</code> or <code>'\0'</code> (they are equivalent) as the last character of the string). Attempting to use <code>word</code> as a string without being <em>nul-terminated</em> is <em>undefined behavior</em> (e.g. calling <code>printf(""Word: %s"", word[j]);</code> on <code>word</code> without it being <em>nul-terminated</em>)</p>

<p>You don't need two loops, you just need a <em>random length</em> between <code>3-9</code> for each of the words you will generate. This can be a separate call to <code>rand()</code> before entering the loop to generate the characters for <code>word</code>.</p>

<p>To fix all of the problems (and noting the inclusion of <code>stdlib.h</code> for <code>rand()</code> and <code>srand()</code>), you could do something similar to the following:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt; /* for rand()/srand() */
#include &lt;time.h&gt;

enum { MINW = 3, MAXW = 9 };    /* constants for min/max length */

int main (void)
{
    int i, randlength;
    char word[MAXW+1] = """";     /* initialize your variables */
    i = randlength = 0;

    srand (time (NULL));        /* initialize the random number generator */
    randlength = rand() % (MAXW - MINW + 1) + MINW;  /* randlength of 3-9 */
    printf (""length : %d\n\n"", randlength);

    for (i = 0; i &lt; randlength; i++) {
        int randomnumber = rand() % 26,
            randchar = 'a' + randomnumber;
        printf("" number[%2d] : %2d  '%c'\n"", i, randomnumber, randchar);
        word[i] = randchar;
    }
    word[i] = 0;    /* nul-terminate (note: also done by initialization) */
    printf (""\nWord : %s\n"", word);

    return 0;
}
</code></pre>

<p><strong>Example Use/Output</strong></p>

<pre><code>$ ./bin/randword       
length : 3

 number[ 0] :  8  'i'
 number[ 1] : 20  'u'
 number[ 2] :  0  'a'

Word : iua

$ ./bin/randword
length : 8

 number[ 0] : 24  'y'
 number[ 1] : 13  'n'
 number[ 2] : 12  'm'
 number[ 3] : 14  'o'
 number[ 4] :  9  'j'
 number[ 5] :  6  'g'
 number[ 6] :  9  'j'
 number[ 7] : 12  'm'

Word : ynmojgjm
</code></pre>

<p>It is important you understand the comment following <code>word[i] = 0;</code> <em>""also done by initialization""</em>. Think about why that explicit <em>nul-termination</em> could be eliminated there. Let me know if you have any questions.</p>
",0
40476485,40476461,6,"<p>A <code>while</code> loop checks if the condition is true.</p>

<p>An expression that evaluates to 0 is considered false, while any non-zero expression is considered true.</p>

<p>From section 6.8.5 of the <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""nofollow noreferrer"">C Standard</a>:</p>

<blockquote>
  <p><em>4</em> An iteration statement causes a statement called the loop body to be executed repeatedly <strong>until the controlling expression compares equal
  to 0</strong>.  The repetition occurs regardless of whether the loop body is
  entered from the iteration statement or by a jump</p>
</blockquote>

<p>So this loop tests if <code>q</code> is non-zero.  Once <code>q</code> is decremented to 0, the loop exits.</p>
",1
40476630,40476461,0,"<p>Basically, the expression <code>while(q--)</code> is equal to</p>

<pre><code>while(q == true)
{
    q--;
}
</code></pre>

<p>since <code>while</code> compares what's in between the parantheses to <code>true</code> and at the same time can do operations, same as <code>for loop</code>.
Note that the value 1 means <code>true</code> and the value 0 means <code>false</code> so as soon as you have <code>q= 0</code> the condition will return <code>false</code> which will make the loop stop. </p>
",0
40476509,40476461,1,"<p>IN C a ""TRUE"" is represented by NON-Zero-Value. So the loop will run until ""q"" reaches ""0"".</p>

<p>This is lazy-bad programming. It does not take that much effort to make the code clear and precise.</p>

<p>while( (q--)!=0) Would be more appropriate.
or
    while (q!=0)
      {
       q--;
    //.......
      }</p>
",1
46639375,46638889,2,"<p>You can't use <code>arr[i][j]</code> in this code because <code>arr</code> points to type <code>int</code> rather than to <code>int *</code> or <code>int[SOME_DIMENSION]</code>. But if you want to use <code>malloc</code> to make a real 2-dimensional array, <strong>you can</strong>:</p>

<pre><code>int (*arr)[c] = (int *)malloc(r * sizeof *arr);
</code></pre>

<p>Now, <code>arr[i]</code> has type <code>int[c]</code>, which decays to <code>int *</code>, and therefore <code>arr[i][j]</code> is valid.</p>
",4
46639530,46638889,0,"<p>If <code>arr</code> is <code>int *</code>, then <code>arr[i]</code> is <code>int</code>.</p>

<p><code>malloc</code> in that code is creating a <strong>one dimensional</strong> vector long <code>r*c</code>.</p>

<p><code>*(arr + i*c + j)</code> can be translated to <code>arr[i*c + j]</code>. This means that this vector is divided in <code>r</code> segments long <code>c</code> and the <code>i</code> is selecting the segment, while <code>j</code> is the offset in the segment.</p>

<p>You may also use <code>malloc</code> to allocate a pointer array, and then <code>malloc</code> each pointer of the array. In that case you¡¯d have a <code>int **</code> and your method will work, but it¡¯s strongly discouraged cause you¡¯d have to <code>free</code> all the pointers in the pointer array.</p>
",0
36560153,36559670,0,"<p>Your header file <code>map.h</code> is fine, even though it should have an include guard. Adding an include guard can be as simple as adding <code>#pragma once</code> on its own line at the top of your header file.</p>

<p>Your source file <code>map.c</code> has a syntax error that needs to be fixed.</p>

<pre><code>const char *map = {
    /* ... */
};
</code></pre>
",2
40531942,40531566,1,"<p>you need to apply following changes:</p>

<pre><code>char input[256];
scanf(""%s"", input);
printf(""your name is %s good job!\n "", name);
</code></pre>

<p>to compare strings use <a href=""https://linux.die.net/man/3/strcmp"" rel=""nofollow noreferrer""><code>strcmp</code></a> - have a look at documentation of this function.</p>

<p>be careful with <code>scanf</code> - think about how long string you can store there and what can go wrong. Have a look at <code>scanf_s</code> </p>
",0
40533396,40531566,0,"<p>You did some errors. First, if you want to insert a string, you can use the <code>%s</code>, but you have to use an array of <code>char</code> in which you can store that string. That's, you have to write something like this.</p>

<pre><code>char input[100];
scanf(""%s"", input);
</code></pre>

<p>and then it'll work. This snippet of code means: I need to insert (store) a string. So first I create a place in which I can store it (pay attention that the string must be maximum of 99 characters; my array has size 100, but the last character is used to represent the end of the string), and then I use the <code>scanf</code> to write what I want.</p>

<p>The second error is that if you want to compare two strings, you can't simply use the <code>==</code> or <code>!=</code>, like when you do with numbers. The <code>string.h</code> library lets you use the <code>strcmp</code> function, like this:</p>

<pre><code>if (strcmp(name, input) == 0)   // this means the strings are equal
   ...
else
   ...
</code></pre>

<p>remembering that</p>

<pre><code>char* name = ""Alina"";
char input[100];
</code></pre>

<p>Eventually, here you're an inspected version of your code:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {

    char* name = ""Alina"";
    char input[100];
    printf(""What's your name?\n"");
    scanf(""%s"", input);
    if (strcmp(name, input) == 0)
        printf(""Your name is %s good job!\n"", name);
    else
        printf(""Are you sure? Open the program again and insert the correct name\n"");

    return 0;
}
</code></pre>

<p>The <code>while(1)</code> at the end of your code is absolutely dangerous, because it starts an infinite loop that never ends, crashing your program. You want to definitely remove it!</p>
",2
40559253,40559242,2,"<p>The valid indices are <code>auction[0][*]</code> and <code>auction[1][*]</code>.</p>
",1
40559293,40559242,1,"<p>You are setting elements of the array beyond its boundaries: the initial dimension of <code>auction</code> is <code>2</code>, the only valid values for this index are <code>0</code> and <code>1</code>.</p>

<p>You can fix and simplify the code this way:</p>

<pre><code>void initAuction(float auction[2][]) {
    for (int i = 0; i &lt; MAXAUCTIONITEMS; i++) {
        auction[0][i] = -1;
        auction[1][i] = 0;
    }
}
</code></pre>

<p>Note that the second dimension is not part of the type of <code>auction</code>, it is ignored by the compiler.</p>
",1
36574806,36572331,1,"<p>You probably created a default project with an existing C source file containing a <code>main</code>, then you probably added a new file to type your code that contains a <code>main</code>, and then the IDE complains when compiling because you have two mains. Remove the default file from the project.</p>
",1
43965144,43964846,3,"<pre><code>char ch;
</code></pre>

<p><a href=""https://stackoverflow.com/questions/7119470/int-c-getchar"">This is wrong</a>. <code>getc</code> and friends return an <strong>int</strong>. This is not something you are free to shrug off and continue on your merry way.</p>

<pre><code>ch = getc(fileptr1);
while (ch != EOF)
 {
     ch = getc(fileptr1);
</code></pre>

<p>You are losing the very first character of the file for ever this way. Find <em>any</em> example of a <code>getc</code>/<code>fgetc</code>/<code>getchar</code> based loop in any introductory C book.</p>

<pre><code>if (ch == '\n')
    temp++;
if (temp != delete_line)
{
    //copy all lines in file replica.c
    putc(ch, fileptr2);
}
</code></pre>

<p>If you try to delete the first line, you replace it with an empty line instead. Use your debugger to verify that. Determine which newline character you are skipping when you are deleting line number N. Think what you have to do to fix that.</p>
",2
40578218,40577982,0,"<p>Well first the file type has absolutly no importance. In C you read a file as it is, directly in binary. Everything (except folders, I'm not sure, and some exception maybe) in Windows are files, even executables.</p>

<p>Then the size is not really a problem, if you read it step by step with a ""small"" buffer (like what you are doing), there will be no problem.</p>

<p>So you could do, after every 10 buffer, you write in a new file, until the end of the one you read. There is not really a problem or question here.</p>

<p>Just some details, your buffer size should be <code>4096</code> for performances on big files. 4096 should be the most optimized size, at least with the read() function, I dunno for fget().</p>

<p>Then your filename size shoud be <code>256</code>. 255 is the max filename size on most OS (256 with the nullbyte).</p>
",0
43205531,43205390,0,"<p>Hex array does not exist. Hex is only representation for numbers in computer language (used for programmers).</p>

<pre><code>volatile int Send_Data[3] = {1, 2, 3};
</code></pre>
",5
43206215,43205390,0,"<p><strong>I would use like this, having a hex table in array.</strong></p>

<pre><code>volatile uint16_t hex16_table[256] = {
0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50a5, 0x60c6, 0x70e7 };
</code></pre>

<p>I guess this is what your looking for.</p>
",0
46102235,46102102,1,"<p>Combine values with indexes in a <code>struct</code>, sort them, and print indexes along with values:</p>

<pre><code>struct ind_val {
    int index;
    double value;
};
int sorting_ind_val (const void * a, const void * b) {
    double lhs = ((struct ind_val*)a)-&gt;value;
    double rhs = ((struct ind_val*)b)-&gt;value;
    if (lhs &lt; rhs)
        return 1;
    if (lhs &gt; rhs)
        return -1;
    return 0;
}
...
double values[] = { 88.54, 56.65, 100.13, 2.091, 25.223 };
struct ind_val pair[5];
for (int i = 0 ; i != 5 ; i++) {
    pair[i].index = i;
    pair[i].value = values[i];
}
qsort(pair, 5, sizeof(struct ind_val), sorting_ind_val);
for (int i = 0 ; i != 5 ; i++) {
    printf(""%d: %f\n"", pair[i].index, pair[i].value);
}
</code></pre>

<p><a href=""https://ideone.com/zKmd6I"" rel=""nofollow noreferrer"">Demo.</a></p>

<pre><code>2: 100.130000
0: 88.540000
1: 56.650000
4: 25.223000
3: 2.091000
</code></pre>
",3
36609376,36608580,0,"<p>You can use some C tricks to get a more elegant solution.</p>

<p>Try this:</p>

<pre><code>result += 50 * ((d1 == 5) + (d2 == 5) + (d3 == 5) + (d4 == 5) + (d5 == 5) + (d6 == 5));
</code></pre>

<p>Do you see what this does?</p>

<p>First, the d1 == 5 is a boolean expression resulting in a true or false, so if it's 5 it will yield a 1. If not, a 0. So what you do is you collect the count of fives and multiply by 50. This would cut a huge chunk of your code to just one line.</p>
",2
41653289,41653107,1,"<p>Your code is a bit wired, as you mix the use of data structure <code>parent_in</code> with the use of <code>parentsArray</code> and it's entries; you malloc on the one, and use it at the other (e.g. concerning <code>parent_in</code>).</p>

<p>But concerning your error, there are two main issues that I see immediately:</p>

<ol>
<li><p>You scanf a string into a non-initialized pointer, i.e <code>scanf(""%s %d"", &amp;parentsArray[numOfParents]-&gt;lastname, ...</code>. Note that you might have reserved space for a parents structure; this structure has a pointer to <code>lastname</code>, which for itself does not get ""malloced"".</p></li>
<li><p>You (re)-allocate always to the same number of entries, i.e. <code>1</code> in
<code>parentsArray = (parent**)realloc(parentsArray, 1 *
sizeof(parent*))</code>. You probably meant <code>realloc(parentsArray,
(numOfParents+1) * sizeof(parent*))</code>.</p></li>
</ol>

<p>I suppose that point 1 is responsible for your ""error reading characters of string""; If you overcome this, I'm rather sure that point 2 will lead to the next memory corruption.</p>
",1
36757687,36757449,1,"<p>Your if must be something like:</p>

<pre><code>if ('a' &lt;= c &amp;&amp; c &lt;='z'){character++;}
else if ( 'A' &lt;= c &amp;&amp; c &lt;='Z'){character++;}
</code></pre>
",0
40751149,40751105,2,"<p>you could do a ternary expression using the fact that <code>printf(</code> is equivalent to <code>fprintf(stdout,</code>:</p>

<pre><code>fprintf(flag == 1 ? pt : stdout, ""Random text..."");
</code></pre>
",3
40751167,40751105,8,"<p>How about something like this:</p>

<pre><code>FILE *out=stdout;

fprintf(out,""Hello World\n"");
</code></pre>

<p>Since this is a function, you can pass in the <code>out</code> pointer as an argument. When printing to the terminal, just assign <code>stdout</code> to it.</p>
",3
45112434,45112226,2,"<pre><code>  char *_res=(char *)malloc(sizeof(str));
</code></pre>

<p>is wrong. <code>sizeof(str)</code> is measuring the size of a char pointer. This is either 4 or 8 (typically) depending on your system (32 or 64 bit).</p>

<p>You need</p>

<pre><code>char *_res=(char *)malloc(strlen(str) + 1);
</code></pre>

<p>strlen returns the number of characters in the string, and you need to add 1 for the terminating 0;</p>

<p>Second you have to add a terminating zero at the end, do:</p>

<pre><code>_res[cur] = '\0'; 
</code></pre>

<p>before returning</p>
",2
40963748,40963696,1,"<p>You cannot access <code>STUDENT_SIZE</code> with how the header file is written. The header file bridges and extends the scope of the aforementioned items: </p>

<pre><code>struct stud{}; //this should be fixed btw
void inc_stud_pos();
int get_stud_pos();
</code></pre>

<p>If you want to extend the scope of <code>STUDENT_SIZE</code> then instead of declaring it in the <code>.c</code> file put it in the <code>.h</code> file. If you do this however you will have to remove the line of code where you declare <code>STUDENT_SIZE</code> in the <code>.c</code> file.</p>
",0
40963998,40963696,2,"<p>The header file (<code>.h</code>) is the programmer's interface to your module. Anything a user (programmer) of your module needs to know to use your module should be in there, but put the actual implementations in the associated <code>.c</code> file. Generally, you put the function prototypes (e.g. <code>int f(void);</code>) in the <code>.h</code> file and the definitions (the implementations, e.g. <code>int f(void) { return 1; }</code>) in the <code>.c</code> file. The linker matches the prototype to the definition because the function signatures match (the name, argument types, and return type).  One way to think about it is the <code>.h</code> file as what you share with everyone, and the <code>.c</code> file as what you keep to yourself.</p>
<p>If you want a user of your module to have access to <code>STUDENT_SIZE</code>, then put</p>
<pre><code>#define STUDENT_SIZE 20
</code></pre>
<p>in your <code>.h</code> file instead of your <code>.c</code> file. Then, any file with</p>
<pre><code>#include &quot;stud.h&quot;
</code></pre>
<p>would have your macro for <code>STUDENT_SIZE</code>. (Notice the file name is <code>&quot;stud.h&quot;</code> not <code>&quot;stud&quot;</code>.)</p>
<blockquote>
<p>Lets say i want to use STUDENT_SIZE in another file whats the syntax? Do i need to use stud.STUDENT_SIZE?</p>
</blockquote>
<p>No. You might be confusing this with namespaces, which <a href=""https://stackoverflow.com/questions/4396140/why-doesnt-ansi-c-have-namespaces"">C does not have</a> in the same sense as other languages like C++, Java, etc. Just use <code>STUDENT_SIZE</code>. (This is why it is important to not use existing identifiers, and also why many people frown upon macros.)</p>
<blockquote>
<p>... i want from another file to access some of the functions inside stud.c.</p>
</blockquote>
<p>If you want another file to have access to some function in <code>stud.c</code>, then put that function's prototype in <code>stud.h</code>. This is precisely what the header file is for.</p>
<blockquote>
<p>... if i want to lets say make an array of students:</p>
<p><code>struct stud students[STUDENT_SIZE];</code></p>
<p>Can i access that normally like <code>students[5].stud_id</code> ?</p>
</blockquote>
<p>As you have written your header file, no. You might know some <code>struct stud</code> exists, but you don't know what the members are called (i.e. you wouldn't know <code>stud_id</code> exists). The reason is that the user of your module sees only what is in the header file, and you defined no members of the struct in your header file.  (I'm surprised what you have written even compiles, because you define <code>struct stud</code> twice, once empty <code>{}</code>, and once with members.) Again, if you want the programmer user to have access to the members of <code>struct stud</code>, its definition</p>
<pre><code>struct stud {
    char stud_id[MAX_STR_LEN];
    char stud_name[MAX_STR_LEN];
    struct grade Grade[MAX_STRUCT];
    struct income Income[MAX_STRUCT];
};
</code></pre>
<p>belongs in your header file (along with whatever those other macros are). Without knowing this, the programmer (and the compiler) has no idea what the members of <code>struct stud</code> are.</p>
<p>(You didn't ask about this, but if you want to share access to a <em>global variable</em> in your <code>.c</code> file, then <em>declare</em> it with the keyword <code>extern</code> in your <code>.h</code> file, and without <code>extern</code> in your <code>.c</code> file. See <a href=""https://stackoverflow.com/questions/496448/how-to-correctly-use-the-extern-keyword-in-c"">How to correctly use the extern keyword in C</a> for more.)</p>
",1
39687032,39686780,-3,"<pre><code>int nrows = 2000, ncolumns = 190;

int **a=calloc(nrows * ncolumns, sizeof(a));

printf(""%d"", a[0][0]);
</code></pre>
",0
39687254,39686780,1,"<p>If you want to be able to access the matrix elements by using the <code>[]</code> operator, you'll have to first allocate an intermediate structure that contains pointers to the data stored on each row of the matrix.</p>

<p>Each row will be zeroed because they're allocated using <code>calloc()</code>. Is this what you're looking for?</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main(void)
{
    int **a;
    unsigned int num_rows = 2000;
    unsigned int num_columns = 190;

    a = calloc(num_rows, sizeof(*a));
    if (a == NULL) {
        /* TODO: Error handling. */
        return -1;
    }

    for (unsigned int i = 0; i &lt; num_rows; i++) {
        a[i] = calloc(num_columns, sizeof(**a));
        if (a[i] == NULL) {
            /* TODO: Error handling. */
            return -1;
        }
    }

    printf(""%d\n"", a[0][0]);

    /* TODO: Free calloc'd memory. */    

    return 0;
}
</code></pre>
",0
46046191,46046089,0,"<p>If you use getline it will retain the newline character so you'll still have to check for it.</p>

<p>If you can use any of the standard C library then you can use isdigit(...) from ctypes.h</p>

<p>It returns non-zero if the input character is a digit.</p>

<p>If you use the getline function the input would be written into the buffer that you pass as the first argument.  It will append a null terminal character to this buffer so you can walk through it as so:</p>

<pre><code>for(char* s = buffer; *s; s++)
    /* test *s */
</code></pre>
",0
46627047,40979473,1,"<blockquote>
  <p>I'm new at C (programming at all actually), and I need to do a tic tac toe game for college.</p>
</blockquote>

<p>These three do not compute! One should not be generally new to programming and new to C at the same time, as the only reasonable guides seem to assume a minimum prerequisite knowledge.</p>

<p>Sure, you'll find those who claim to teach C as an introductory language. I'm not saying it's not possible to learn C as a first language through your college, but I wouldn't be confident enough to bet on it. A good book, however, will get you there.</p>

<p>Perhaps SICP, prior to K&amp;R2E would be good. It seems like you could use some guidance in using arguments more liberally; SICP will help you with that.</p>

<p>Moving on...</p>

<hr>

<blockquote>
  <p>In pascal ...</p>
</blockquote>

<p>I would no sooner learn C as though it has similarities with Pascal than I would learn French as though it has similarities with German. They're both procedural programming languages, and there are some other vague similarities on the surface with some shocking yet subtle gotchas woven betwixt. You should learn languages that have UB as though they might have a secret door with a gas or spike trap... all in the fun of exploration, of course!</p>

<hr>

<blockquote>
  <p>... I used to declare a type and then a file of that type, then seek(file, position) and could read or write at the given position(that I would get by iterating the txt file), with no problems, but I couldn't realize how to achieve equivalent task in C.</p>
</blockquote>

<p>As the idea of <em>files</em> came from Unix, and C is recognised as the Unix system language, the idea is very similar in C. You can use <code>fseek</code> to <code>fseek(file, index * size_of_object, SEEK_SET)</code>, for example. Or, if you're bound to a particularly Unix-like system (such as Linux, BSD, Solaris, Mac OS, etc) you could use <code>mmap</code> to map a region of memory to a file, so you could for example, treat a 2GB file as though it's your array. You've got a few manuals to read before that's an option, but it's a good option to look into.</p>

<hr>

<blockquote>
  <p>How could I find specif match details from the binary file?</p>
</blockquote>

<ol>
<li>Read an item from the file.</li>
<li>Test the item to check if it's the one you're looking for. If not, go to 1.</li>
<li>If necessary, re-read the item and/or perform a final test to ensure the item you've read is a match.</li>
</ol>

<hr>

<p>P.S. I would expect (and thus suggest) the <code>size</code> argument to be <code>sizeof (struct TicTac)</code>, and the <code>nitems</code> argument to be <code>1</code>, not the other way around... The other way around is more likely buggy. Look at how you've written your <code>fwrite</code> code as a good example: <code>fwrite(&amp;Match, sizeof(struct TicTac), 1, bfp);</code>... now replace <code>fwrite</code> with <code>fread</code> and you have a read instead of a write. However, in your reads, you swap the middle arguments which changes the behaviour slightly.</p>
",0
40684203,40683899,0,"<p>I suggest you use a library like ncurses(<a href=""http://www.projectpluto.com/win32a.htm"" rel=""nofollow noreferrer"">PDCurses</a> in windows) to display stuff wherever you want. </p>

<p>If you wanna continue using the standard output, you need to print the <code>col + 1</code> inside the <code>for</code> that iterate columns but checking if it is in the first line. The main problem I foresee is the correct spacing between numbers on the way you should display them because you need to print numbers with same spacing so it fits correctly, to solve it, I suggest you to use left padding of the <code>printf</code> function: </p>

<pre><code>int value1 = 2;
int value2 = 12;
printf(%02d, value1) // output is 02
printf(%02d, value2) // output is 12
</code></pre>

<p>OBS: check <a href=""https://stackoverflow.com/questions/29254127/printing-leading-spaces-and-zeros-in-c"">this link</a> for other leading options of the <code>printf</code>.</p>
",0
39648939,39648860,1,"<p>Just keep track of how many times you called <code>strtok</code>, and copy the string to the appropriate place each time.</p>

<pre><code>char a[50], b[50], c[50];
int count = 0;

char *token = strtok(str, "","");

// Keep printing tokens while one of the
// delimiters present in str[].
while (token != NULL)
{
    printf(""%s\n"", token);
    count++;
    switch (count) {
    case 1:
        strcpy(a, token);
        break;
    case 2:
        strcpy(b, token);
        break;
    case 3:
        strcpy(c, token);
        break;
    }
    token = strtok(NULL, ""-"");
}    
</code></pre>
",0
39648975,39648860,-1,"<p>You'd need to allocate a buffer for each token that is returned and store it.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main()
{
char str[] = ""+5000,-9000,7jj4"";

// We'll use this to allocate pointers.
//
char **tokens = NULL;
int totalTokens = 0;

// Returns first token 
char *token = strtok(str, "","");

// Keep printing tokens while one of the
// delimiters present in str[].
while (token != NULL)
{
    printf(""%s\n"", token);
    token = strtok(NULL, ""-"");

    // Allocate first/next pointer
    //
    if (! tokens) {
        tokens = malloc(sizeof(char *));
        if (! tokens) {
           // Handle malloc() error...
           //
        }
    } else {
        // Allocate next pointer
        //
        tokens = realloc(tokens, (sizeof(char *) * totalTokens);
        if (! tokens) {
            // Handle realloc() error.
            //
        }
    }

    // Use the newly allocates pointer to malloc() a buffer
    //
    tokens[totalTokens] = malloc(sizeof(char) * (strlen(token) + 1));

    if (! tokens[totalTokens]) {
       // Handle malloc() error.
       //
    }

    // Store token and next
    //
    strcpy(tokens[totalTokens++], token);
}

return 0;
}
</code></pre>

<p>Hopefully ought to help.</p>
",2
39649058,39648860,1,"<p>You can just assign each variable from <code>strtok</code>.</p>

<pre><code>char *a, *b, *c;

a = strtok(str, "","");
b = strtok(NULL, "","");
c = strtok(NULL, "","");
</code></pre>
",0
39649772,39648860,0,"<p>Well what's the fun in using rolling wheels, C is all about creating something new. Here is the code - </p>

<pre><code>int main (void ){

char str[] = ""+5000, -9000, 7jj4"";
char *p_str = str;
char a[10], b[10], c[10];
size_t a_count = 0,b_count = 0,c_count = 0;     // Need new index ever time for new token strings
size_t index = 0;

     while( *p_str ){
       if(*p_str == ',' ) { 
         p_str++; index++; p_str++;     // you can ignore p_str++ here.
      }    
        if(index == 0 &amp;&amp; *p_str != ',' ){
          a[a_count++] = *p_str;        
       } else if( index == 1 &amp;&amp; *p_str != ',' ){ 
           b[b_count++] = *p_str; 
        } else if ( index == 2 &amp;&amp; *p_str != '\0' ){
            c[c_count++] = *p_str; 
         }      
       p_str++;
    }
   a[a_count] = b[b_count] = c[c_count] = '\0';
   printf(""A : "" ); puts(a); 
   printf(""B : "" ); puts(b);
   printf(""C : "" ); puts(c);
 return 0;
}
</code></pre>

<p>Note : You can do dynamic allocation also. </p>
",0
44360881,44360569,0,"<p>You want to enter the number of player. It seems that you have already written code for entering players name. So for entering number of Player you need to use one <code>scanf()</code></p>

<pre><code>int main() 
{
   int i, player_num; 
   char names[8][25];
   printf(""\n\n"");  
//user inputs value of player_num, here, as you have now
   printf(""Enter the number of player(from 1 to 8)\n"");
   scanf_s(""%d"",&amp;player_num,sizeof(int));
   for(i = 0; i &lt; player_num; i++) {
     printf(""Enter the player's name: "");
     scanf_s(""%s"", names[i],25);  //enters name and creates a newline &lt;enter key&gt;
     getchar();               //removes the newline from the keyboard buffer
   }
   printf(""\n\n"");
   for(i = 0; i &lt; player_num; i++)
      printf(""\n%s"", names[i]);
   printf(""\n\n\t\t\t     press enter when ready"");
   getchar();   //holds the console window open until you press enter
   return 0;
}
</code></pre>

<p>Hope this Helps :)</p>
",14
46108844,45183957,0,"<p>If those (non-standard) qualifiers are anything like the <code>const</code> qualifier, for example, then:</p>

<pre><code>const int *a;                 // a is a pointer to const int
int const *b;                 // b is a pointer to int const (same as a)
int * const c = (int[42]){0}; // c is a const pointer to int (DIFFERENT!)
</code></pre>

<p>The differences to these can be observed by trying to modify them:</p>

<pre><code>a = (int const[]){0}; // This is allowed
a[0] = 42;            // This is NOT allowed
c = NULL;             // This is NOT allowed
c[0] = 42;            // This is allowed
</code></pre>

<hr>

<p>I think you probably meant to write <code>int __attribute__((bigendian)) *</code>, i.e. putting the attribute <em>before</em> the asterisk to denote that you wanted a <em>pointer to big endian <code>int</code></em>, because putting it <em>after</em> would denote a <em>big endian pointer to <code>int</code></em>...</p>
",0
43963782,43963707,1,"<p>If you're going to free a makeshift matrix like what you've created, you iterate through the pointed-to array and free each of those pointers, and then free the main pointer. Do not free <code>arr</code>, as this points to the last created array. Something like this should work nicely for you:</p>

<pre><code>for (size_t i = 0; i &lt; rows; ++i)
{
    free(matrix[i]);
}

free(matrix);
</code></pre>
",1
43963978,43963707,2,"<p>Valgrind (see <a href=""http://valgrind.org/"" rel=""nofollow noreferrer"">http://valgrind.org/</a>) shows the problem in your:</p>

<pre><code>scanf(""%d"",arr + j + 1);
</code></pre>

<p>line.</p>

<p>If you want to keep the length on the first position your allocation size:</p>

<pre><code>arr = (int*)malloc(len * sizeof(int));
</code></pre>

<p>is too small (you need one more <code>int</code> for the length itself).</p>
",3
39595536,39595224,0,"<p>you should make a class of this, not a method. (a dictionary is also an option, but i wouldnt recommend it)</p>

<p>after that you should make a new instance of the class for every line in the text file. you can put those in a list or an array of the class</p>

<p>(FYI if you want to keep using it like this, then you should at least make the <code>char name[]</code> a <code>string name[]</code>)</p>

<p>edit:
if this is in C then you can discard the above, because then you dont have classes. If its c++ then do use it as above in a class</p>
",0
39596235,39595224,0,"<p>in the condition of your for loop, <code>scanf(""%d"", id+i)==1 &amp;&amp; scanf(""%d"", id+i) != EOF</code>, you call <code>scanf</code> twice. Since <code>i</code> has not yet been incremented, the second call will overwrite the result of the first call.</p>

<p>Further, <code>scanf</code> returns the number of fields successfully converted and assigned. It does not return <code>EOF</code>.</p>
",0
40559637,40559571,1,"<p>With conditional expressions in C, zero is treated as false, everything else as true.</p>

<p>So the statement:</p>

<pre><code>if (n / 10)
</code></pre>

<p>is identical to:</p>

<pre><code>if (n / 10 != 0)
</code></pre>

<p>In other words, the body of the <code>if</code> statement will execute as long as <code>n</code> is not between <code>-9</code> and <code>9</code> inclusive. This is the case for all C standards from C99 onwards (C90 had an implementation-defined result when one or more of the inputs to division was negative).</p>

<p>In terms of the code you've provided, it's rife with syntax errors so you'll need to clean that up before getting anything useful out of it.</p>
",5
36835618,36835449,0,"<p>You may  replace;</p>

<pre><code>gets(b1.Title);  // gets is deprecated
gets(b1.Author);
</code></pre>

<p>with</p>

<pre><code>fgets(b1.Title,80,stdin);
fgets(b1.Author,80,stdin);
</code></pre>

<blockquote>
  <p>Notice that gets is quite different from fgets: not only gets uses
  stdin as source, but it does not include the ending newline character
  in the resulting string and does not allow to specify a maximum size
  for str</p>
</blockquote>

<p>Then put </p>

<pre><code>while(getchar()!='\n') // Wasting any unprocessed buffer
  continue;;
</code></pre>

<p>just after the second <code>scanf()</code>. This is for the below reason :</p>

<p>gets() can take empty strings(see the citation above). If your terminal is line buffered, after the second  <code>scanf()</code>, when you press enter on the keyboard, that creates an unprocessed <code>\n</code> for the <code>stdin</code> buffer and this will be consumed by the next <code>gets()</code>. In other words the next <code>b1.Title</code> will be an empty string. The bad part is that this messes up the whole input sequence afterwards.</p>

<p><strong>Reference:</strong> <a href=""http://www.cplusplus.com/reference/cstdio/gets/"" rel=""nofollow"">gets</a></p>
",3
45766250,45766142,0,"<p>You can but there's a lot of considerations.</p>

<p>1) What does that <em>mean</em>?</p>

<p>The only really useful abstraction when this actually gets used is that you need to access a specific memory location because something is mapped to a specific point, generally hardware control registers (less often: a specific area in flash or from the linker table).  The fact that you are assigning 60000 (a decimal number rather than a hexadecimal address or a symbolic mnemonic) makes me quite worried.</p>

<p>2) Do you have ""odd"" pointers?</p>

<p>Some microcontrollers have pointers with strange semantics (near vs far, tied to a specific memory page, etc.)  You may have to do odd things to make the pointer make sense.  In addition, some pointers can do strange things depending upon where they point.  For example, the PIC32 series can point to the exact same data but with different upper bits that will retrieve a cached copy or an uncached copy.</p>

<p>3) Is that value the correct size for the pointer?</p>

<p>Different architectures need different sizes.  The newer data types like intptr_t are meant to paper over this.</p>
",2
45766163,45766142,9,"<p>You can, but unless you're developing for an embedded device with known memory addresses with a compiler that explicitly allows it, attempting to dereference such a pointer will invoke undefined behavior.</p>

<p>You should only assign the address of a variable or the result of a memory allocation function such as <code>malloc</code>, or <code>NULL</code>.</p>
",3
45766204,45766142,0,"<p>According to the pointer conversion rules, e.g. as described in <a href=""http://port70.net/~nsz/c/c11/n1570.html#6.3.2.3p5"" rel=""nofollow noreferrer"">this</a> online c++ standard draft, any integer may be converted to a pointer value:</p>

<blockquote>
  <p>6.3.2.3 Pointers</p>
  
  <p>(5) An integer may be converted to any pointer type. Except as
  previously specified, the result is implementation-defined, might not
  be correctly aligned, might not point to an entity of the referenced
  type, and might be a trap representation.</p>
</blockquote>

<p>Allowing the conversion does, however, not mean that you are allowed to dereference the pointer then.</p>
",0
39644129,39643989,3,"<p>Watch these sort of problems melt away if you declare your variables as close to their first use as possible.</p>

<p>In your case, move <code>int sum = 0;</code> to just before the <code>for</code> loop.</p>
",1
40985039,40984985,7,"<p>There are 4 issues:</p>
<h2>Issue 1</h2>
<p>The code setting up the signal handler is wrong.</p>
<p>These 2 lines are in the wrong order:</p>
<pre><code>    sigaction(SIGUSR1, &amp;action, NULL);
    action.sa_handler = handler_sigusr1;
</code></pre>
<p>They should be</p>
<pre><code>    action.sa_handler = handler_sigusr1;
    sigaction(SIGUSR1, &amp;action, NULL);
</code></pre>
<h2>Issue 2</h2>
<p>Your parent process sends SIGKILL to your child right after it sends SIGUSR1. SIGKILL will terminate your child process - and it cannot be blocked or ignored.</p>
<p>Unless you're lucky, your child's sigusr1 handler will not be able to run or finish before the parent sends SIGKILL - which terminates the child process immediately.</p>
<p>You can greatly increase the chance SIGUSR1 gets delivered and handled by inserting a delay like so:</p>
<pre><code>kill(child1, SIGUSR1);
sleep(1);
kill(child1, SIGKILL);
</code></pre>
<h2>Issue 3</h2>
<p>You have SIGUSR1 blocked, so it will not be delivered to your process.</p>
<p>Remove the line</p>
<pre><code> sigaddset(&amp;new_mask, SIGUSR1);
</code></pre>
<p>Note that when the signal mask is being set with <code>sigprocmask()</code> or <code>sigsuspend()</code> , the signals set in the mask are the signals that are <strong>blocked</strong>.</p>
<h2>Issue 4</h2>
<p>You cannot safely use printf() in a signal handler.</p>
<p>printf() is not signal async safe, and cannot be used inside a signal handler. If you're unlucky it might not behave as it should behave when used in a signal handler. Use write() instead to write directly to stdout, e.g.</p>
<pre><code> write(1, &quot;Signal SIGUSR1\n&quot;, 15);
</code></pre>
",1
40985111,40984985,0,"<p>Simple - the child process doesn't have time to handle the SIGUSR1 signal before it gets killed.</p>
",0
40985778,40984985,4,"<h3>First pass</h3>

<p>Here's an amended version of your code which seems to work.  Note that no process can ever block SIGKILL or SIGSTOP. I removed the SIGTERM code since is not being used.  The signal handler calls <code>write()</code> rather than <code>printf()</code> since <code>write()</code> is async-signal-safe.  It hand-encodes the signal number into the message since functions such as <code>sprintf()</code> are not async-signal-safe (neither is <code>strlen()</code>, officially) ¡ª see <a href=""https://stackoverflow.com/questions/16891019"">How to avoid using <code>printf()</code> in a signal handler</a> for more information.</p>

<pre><code>#include &lt;signal.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;unistd.h&gt;

static void handler_sigusr1(int signum)
{
    char msg[] = ""Signal ?? SIGUSR1\n"";
    msg[7] = (signum / 10) + '0';
    msg[8] = (signum % 10) + '0';
    write(2, msg, sizeof(msg) - 1);
}

int main(void)
{
    struct sigaction action;

    action.sa_flags = 0;
    action.sa_handler = handler_sigusr1;
    sigemptyset(&amp;action.sa_mask);

    sigaction(SIGUSR1, &amp;action, NULL);

    int child1 = fork();
    if (child1 == 0)
    {
        sigset_t new_mask, oldmask;
        sigemptyset(&amp;new_mask);
        sigaddset(&amp;new_mask, SIGUSR1);
        sigprocmask(SIG_BLOCK, &amp;new_mask, &amp;oldmask);
        sigsuspend(&amp;new_mask);
        printf(""Child (%d) unsuspended\n"", (int)getpid());
    }

    if (child1 != 0)
    {
        kill(child1, SIGUSR1);
        sleep(1);
        kill(child1, SIGKILL);
        int status;
        int corpse = wait(&amp;status);
        printf(""Child (%d) - corpse = %d (0x%.4X)\n"", child1, corpse, status);
    }
    return 0;
}
</code></pre>

<p>Example run:</p>

<pre><code>Signal 30 SIGUSR1
Child (41875) - corpse = 41875 (0x0009)
</code></pre>

<p>The first message is from the signal handler in the child, obviously.  It indicates that SIGUSR1 was received.  The second message is from the parent.  The hex number indicates that the child died from signal 9 (aka SIGKILL).</p>

<h3>Second pass</h3>

<p>What is that code in the child process doing?  Answer: confusing me (and probably you too).  I added an extra <code>printf()</code> before <code>sigsuspend()</code>, and ran the code and it shows:</p>

<pre><code>Signal 30 SIGUSR1
Child (42688) suspending
Child (42688) - corpse = 42688 (0x0009)
</code></pre>

<p>The <code>sigprocmask()</code> call blocks SIGUSR1, but the parent on my machine is too quick and gets the signal delivered before that takes effect.  The <code>sigsuspend()</code> then goes to sleep with SIGUSR1 blocked; the process dies because of the SIGKILL.</p>

<p>This variant of the code doesn't use <code>sigprocmask()</code> at all.  It has a very different effect:</p>

<pre><code>#include &lt;signal.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;unistd.h&gt;

static void signal_handler(int signum)
{
    char msg[] = ""Signal ??\n"";
    msg[7] = (signum / 10) + '0';
    msg[8] = (signum % 10) + '0';
    write(2, msg, sizeof(msg) - 1);
}

int main(void)
{
    struct sigaction action;

    action.sa_flags = 0;
    action.sa_handler = signal_handler;
    sigemptyset(&amp;action.sa_mask);

    sigaction(SIGUSR1, &amp;action, NULL);
    sigaction(SIGTERM, &amp;action, NULL);

    int child1 = fork();
    if (child1 == 0)
    {
        sigset_t new_mask;
        sigemptyset(&amp;new_mask);
        printf(""Child (%d) suspending\n"", (int)getpid());
        sigsuspend(&amp;new_mask);
        printf(""Child (%d) unsuspended\n"", (int)getpid());
    }
    else
    {
        kill(child1, SIGUSR1);
        sleep(1);
        kill(child1, SIGTERM);
        sleep(1);
        kill(child1, SIGUSR1);
        sleep(1);
        kill(child1, SIGKILL);
        int status;
        int corpse = wait(&amp;status);
        printf(""Child (%d) - corpse = %d (0x%.4X)\n"", child1, corpse, status);
    }

    return 0;
}
</code></pre>

<p>Example output:</p>

<pre><code>Signal 30
Child (42969) suspending
Signal 15
Child (42969) unsuspended
Child (42969) - corpse = 42969 (0x0000)
</code></pre>

<p>This time, the child dies normally, after reporting that it was unsuspended, because <code>SIGTERM</code> and <code>SIGUSR1</code> were not blocked.</p>

<p>You can ring the variations, adding <code>SIGTERM</code> and/or <code>SIGUSR1</code> to the signal mask passed to <code>sigsuspend()</code>, maybe in response to different command line options.</p>

<p>I note that the man page for <code>sigsuspend()</code> on macOS Sierra says:</p>

<blockquote>
  <p>The signal mask set is usually empty to indicate that all signals are to be unblocked for the duration of the call.</p>
</blockquote>
",0
37770957,37770854,1,"<p>Try this:
Also to note use 'unsigned char x' in your main this basically means positive values 0-255</p>

<pre><code>#include &lt;stdio.h&gt;

int is_digit(int x)
 {
    if (x &gt;= 48 &amp;&amp; x &lt;= 57)
        {
            return 1;
        }
    return 0;
 }
</code></pre>

<p>It would be better to change your method to return an int and not char.</p>

<p>Remove the single quotes because you are comparing the number values of the ASCII characters (int)</p>

<p>Also use the '&lt;=' and '>=' signs because the question said inclusive. '&lt;' and '>' is exclusive.</p>

<p>You don't need a else block since the answer is immediately returned if it is a number.</p>

<p>""//Is this what the question means by ""function must return a value of 0""?""</p>

<p>Yes, that's what it means.</p>
",1
37770893,37770854,0,"<p>Your return type is <code>char</code>,
try this:</p>

<pre><code>int is_digit(int x)
</code></pre>
",3
37770995,37770854,1,"<p>You could do a direct comparison:</p>

<pre><code>int is_digit(char x)
{
    int result;
    if (x &gt;= '0' &amp;&amp; x &lt;= '9')
    {
        result = 1;
    }
    else
    {
        result = 0;
    }
    return result;
}
</code></pre>
",1
37770929,37770854,0,"<p>In short: because you're not telling it to. The final line should be:</p>

<p><code>return is_digit(x);</code></p>

<p>Without the <code>return</code>, the result from <code>is_digit()</code> is simply being thrown away...</p>
",2
37771010,37770854,0,"<p>Your mistake is with</p>

<pre><code>if (x &gt; '48' &amp;&amp; x &lt; '57') //The ascII range between 0-9 (i think...)
</code></pre>

<p>It should be</p>

<pre><code>if (x &gt; 47 &amp;&amp; x &lt; 58) //The ascII range between 0-9 (i think...)
</code></pre>

<p>The corrected code is shown below</p>

<pre><code>   #include &lt;stdio.h&gt;

            int is_digit(char x)
            {
                if (x &gt; 47 &amp;&amp; x &lt; 58) //The ascII range between 0-9 (i think...)
                {
                    return 1;
                }
                else                      
    //Whatever the user input is it always runs the else
                {
                    return 0;             
    //Is this what the question means by ""function must return a value of 0""
                }
            }

            int main()
            {
                char x;
                printf(""input: "");
                scanf(""%c"", &amp;x);
                printf(""result is: %d"",is_digit(x));
                return 0;

            }
</code></pre>

<p>A return statement in programming is a proof of what the computer did. In c and c++, returning 0 in main means your program ended correctly, without crashing but not necessarily that you code is wrong or right.</p>
",2
47542252,47542152,2,"<p>The reason is division by 0 in the line where you have div1 /= 10. You see, div1 is an integer, so each time you divide it by 10, it gets smaller, and after many iterations, couple of thousand of them, it gets 0. Division by 0 causes the problem.
Put some if around the code to check if it is 0, and see what will you do if it is.</p>
",0
37119124,37118993,0,"<p>Use of <code>*(a+i)</code> and <code>*(b+i)</code> in the calls to <code>scanf</code> is not right. They need to be <code>(a+i)</code> and <code>(b+i)</code>.</p>

<p>You are running into undefined behavior since you are passing the wrong argument to <code>scanf</code>.</p>

<p>You need to up the compiler warning level to detect these errors at compile time.</p>

<p>I get the following warnings when I use <code>gcc -Wall</code>:</p>

<pre><code>soc.c: In function ¡®inner_product¡¯:
soc.c:11:5: warning: format ¡®%d¡¯ expects argument of type ¡®int *¡¯, but argument 2 has type ¡®int¡¯ [-Wformat=]
     scanf(""%d"",*(a+i));
     ^
soc.c:11:5: warning: format ¡®%d¡¯ expects argument of type ¡®int *¡¯, but argument 2 has type ¡®int¡¯ [-Wformat=]
soc.c:17:5: warning: format ¡®%d¡¯ expects argument of type ¡®int *¡¯, but argument 2 has type ¡®int¡¯ [-Wformat=]
     scanf(""%d"",*(b+i));
     ^
soc.c:17:5: warning: format ¡®%d¡¯ expects argument of type ¡®int *¡¯, but argument 2 has type ¡®int¡¯ [-Wformat=]
</code></pre>
",0
37119137,37118993,0,"<p>You can fix the warnings. </p>

<pre><code>$ gcc main.c 
main.c: In function ¡®inner_product¡¯:
main.c:11:15: warning: format ¡®%d¡¯ expects argument of type ¡®int *¡¯, but argument 2 has type ¡®int¡¯ [-Wformat=]
         scanf(""%d"",*(a+i));
               ^
main.c:17:15: warning: format ¡®%d¡¯ expects argument of type ¡®int *¡¯, but argument 2 has type ¡®int¡¯ [-Wformat=]
         scanf(""%d"",*(b+i));
</code></pre>

<p>If I fix the warnings, then I can enter 4 elements:</p>

<pre><code>$ ./a.out 
How many elements do you want to store?  4
enter value for first array: 2
enter value for first array: 3
enter value for first array: 4
enter value for first array: 5
enter value for second array: 3
enter value for second array: 4
enter value for second array: 5
enter value for second array: 6
68
</code></pre>

<p>I just changed the call from int to pointer. </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int inner_product(int *a, int *b, int size)
{
    int sum = 0, i;

    for (i=0; i&lt;size; i++)
    {
        printf(""enter value for first array: "");
        scanf(""%d"",(a+i));
    }

    for (i=0; i&lt;size; i++)
    {
        printf(""enter value for second array: "");
        scanf(""%d"",(b+i));
    }

    for (i=0; i&lt;size; i++)
        sum += *(a+i) * *(b+i);

    return sum;
}


int main() {
    int n, *a, *b;
    printf(""How many elements do you want to store?  "");
    scanf(""%d"", &amp;n);
    a = (int *) malloc(n * sizeof(int));
    b = (int *) malloc(n * sizeof(int));

    printf(""%d\n"", inner_product(a, b, n));

    free(a);
    free(b);
}
</code></pre>
",2
41911233,41911115,2,"<p>Say, your text console has 80 character width and tabulation positions are 0,8,16,....72.
According to the standard, you know that if you send (print) one tabulation character to the console, your cursor moves to the 8th position. If two, then to 16th position .... If nine, then to 72th position. But if you send more tabulations, it's not specified where your cursor should be placed. For example, on my current console it's placed to the rightmost (79) position in that case but in no way should we rely on this assumption.</p>
",4
41911789,41911115,0,"<p><b>About tabs</b></p>

<blockquote>
  <p>Most terminal programs will have a tab stop at every 8th column.<li>For every ""\t"" you print the cursor goes to the next possible position ( <i>usually 8 spaces</i> ).</li> <li>If there is space for N tabulation characters in your console you can safely print from 0 to N ""\t"".</li></p>
</blockquote>

<p>Let's say that my tiny console has space for only 4 tabs and (after a new line) I have the below code</p>

<pre><code>printf ( ""\t\t\t\t\t"" );  // As you can see...
//...here I want to put 5 tabulation tabs on screen 
</code></pre>

<p>In this case we don't know how the last \t will be printed.</p>

<p>Note: Sometimes, if you print many \t like this; <code>printf(""\t\t\t...\t\t); </code> the cursor goes to previous lines, but we can't be sure if it will happen.</p>
",0
44726315,44726233,1,"<p>Let's try to dissect <code>char *argv[]</code> step by step:-</p>

<pre><code>char *argv[] is an array of character pointers  
argv[i]      is the ith element in the array i.e a char*  
*(argv[i]+0) i.e argv[i][0] is the first character of the ith element of the array  
</code></pre>

<p>I guess you get the idea by now..</p>
",1
44726327,44726233,2,"<p>It might be worth it for you to look into how strings are ""handled"" in C.
strings are really just an array of chars in c. </p>

<p>Where argv[1] will give you the second argument, argv[1][0] will give you the first character of the second argument.</p>

<p>Just loop from there, ie:</p>

<pre><code>int main (int argc, char * argv[])
{
    for (int i = 0; i &lt; argc; i ++){
        printf(""%c\n"",argv[i][0]);
    }
    return 0;
}
</code></pre>

<p>sorry i don't have a compiler handy to check my syntax.
cheers!</p>
",0
43208905,43206620,2,"<p>I'm honestly not exactly sure what your program is supposed to be doing. It might help if you include the whole thing so we can see how you're calling your functions through <code>main</code>. Regardless, if you want a logfile, the simplest way to do this would be to just output to a text file.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;



int main()
{
    // Open a file pointer named ""log.txt"" for writing (w+)
    // If you google c file i/o you'll find all the specifiers for
    // writing, reading, writing and reading, etc. I just chose
    // only writing here as an example
    FILE* fp;
    fp = fopen(""log.txt"", ""w"");

    // Generate whatever you want logged here, ""data"" is just an example
    char* data = ""The data to be logged..."";

    // This lines writes the info in ""data"" to the file pointer specified
    fputs(data, fp);

    // Always remember to close your files
    fclose(fp);

    return EXIT_SUCCESS;
}
</code></pre>
",0
40982499,40981549,0,"<p>Imagine that you're using one of those text editors to open your file and moving the caret/cursor is the only way to navigate. Your first goal is to navigate through the whole content and display it. That's what the loop below does:</p>

<pre><code>while(!feof(fp)){
    fgets(ch, 200, fp);
    puts(ch);
}
</code></pre>

<p>The <code>!feof(fp)</code> moved the cursor to the end of the file so you could read it all.</p>

<p>If you have to count chars then you need to navigate back to somewhere in your file. Since you want statistics from the whole txt, then you could simply use <code>rewind(fp)</code> or <code>fseek(fp, 0, SEEK_SET)</code> before your second loop to move the cursor back to the begin.</p>

<p>I recommed using <code>fseek()</code> because it will clear the end of file indicator.
Take a closer look <a href=""http://www.cplusplus.com/reference/cstdio/fseek/"" rel=""nofollow noreferrer"">here</a>.</p>
",1
40984963,40981549,0,"<p>I finally got it to work, if anyone is interested the final code is here:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;

int main() {

    // declaring variables
    FILE *fp;
    int charcount = 0, wordcount = 0, linecount = 1;
    int charcount2 = 0, wordcount2 = 0, linecount2 = 1;
    int character;
    char first[50];
    char second[50];
    char ch[200];

    // asking the user for the file names and scanning the names they enter as txt files
    printf("" Enter the first file name: "");
    scanf(""%s"", first);
    strcat(first, "".txt"");

    printf("" Enter the second file name: "");
    scanf(""%s"", second);
    strcat(second, "".txt"");

    // opening the file stream
    fp = fopen(first, ""r"");

    // if the file cannot be reached, display error
    if (fp == NULL) {
        printf(""File cannot be opened: %s\n"", first);
        return 0;
    }

    // reading and printing the file into the program
    printf(""\n---FIRST FILE---\n"");
    while (!feof(fp)) {
        fgets(ch, 200, fp);
        fputs(ch, stdout);
    }

    // counting the characters, words and lines until the program is finished
    fseek(fp, 0, SEEK_SET);
    while ((character = fgetc(fp)) != EOF) {
        if (character == EOF)
            break;
        {
            charcount++;
        }
        if (character == ' ' || character == '.')
        {
            wordcount++;
        }
        if (character == '\n')
        {
            linecount++;
        }
    }

    // closing the stream
    fclose(fp);

    // printing the number of characters, words and lines
    printf(""\n Characters: %d \n Words: %d\n Lines: %d\n\n\n"", charcount, wordcount, linecount);

    //---------SECOND FILE----------//

    // opening the stream
    fp = fopen(second, ""r"");

    // reading and printing the file into the program
    printf(""\n---SECOND FILE---\n"");
    while (!feof(fp)) {
        fgets(ch, 200, fp);
        fputs(ch, stdout);
    }

    // counting the characters, words and lines until the program is finished
    fseek(fp, 0, SEEK_SET);
    while ((character = getc(fp)) != EOF) {
        if (character == EOF)
            break;
        {
            charcount2++;
        }
        if (character == ' ' || character == '.')
        {
            wordcount2++;
        }
        if (character == '\n')
        {
            linecount2++;
        }
    }

    // closing the stream
    fclose(fp);

    // printing the number of characters, words and lines
    printf(""\n Characters: %d \n Words: %d\n Lines: %d\n\n"", charcount2, wordcount2, linecount2);

}
</code></pre>
",0
40985219,40981549,0,"<p>counting sample</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

typedef struct statistics {
    size_t charcount, wordcount, linecount;
} Statistics;

Statistics count_cwl(FILE *fp){
    size_t c = 0, w = 0, l = 0;
    int ch;
    char prev = ' ';

    while((ch = getc(fp)) != EOF){
        ++c;
        if(isspace(prev) &amp;&amp; !isspace(ch)){
            ++w;//need to delete punctuation marks ?
        }
        if(ch == '\n'){
            ++l;
        }
        prev = ch;
    }
    if(prev != '\n')//There is no newline at the end of the file
        ++l;
    return (Statistics){ c, w, l};
}

int main(void) {
    char filename[50] = ""test.c"";
    FILE *fp = fopen(filename, ""r"");

    if (fp == NULL) {
        printf(""File cannot be opened: %s\n"", filename);
        return -1;
    }

    Statistics stat = count_cwl(fp);

    fclose(fp);

    printf(""\nCharacters: %zu\nWords: %zu\nLines: %zu\n"", stat.charcount, stat.wordcount, stat.linecount);
}
</code></pre>
",0
46938502,46938277,-1,"<p>You need to allocate memory for pNode, for your case (C language) it could be,</p>
<pre><code>pNode = malloc( numElem * sizeof(Node) );
</code></pre>
<p>The cast is not required for strict C, but for C++ it is.</p>
",5
46938493,46938277,2,"<p>I needed this <code>pNode = malloc(numElem * sizeof(Node));</code></p>
",4
41173073,41172887,3,"<p>A function with a return type of <code>void</code> means that it returns nothing.  So it doesn't make sense to assign the result (i.e. nothing) to any variable.</p>

<p>Even if it did return a value, you're not actually calling the function:</p>

<pre><code>nodes[i]= print_postorder;
</code></pre>

<p>Without the parenthesis after the function name, the expression is actually the <em>address</em> of the function, not the result of calling the function.</p>

<p>What it looks like you want is for <code>print_postorder</code> to return the total number of nodes in the tree.  To do this, change the return type to <code>int</code> and return either the sum of the left and right subtrees plus 1, or 0 if the subtree is empty:</p>

<pre><code>int print_postorder(node * tree)
{
    if (tree) {
        int left = print_postorder(tree-&gt;left);
        int right = print_postorder(tree-&gt;right);
        printf(""%d\n"",tree-&gt;data);
        return left + right + 1;
    } else {
        return 0;
    }
}
</code></pre>

<p>Then to check the number of nodes, get rid of <code>node</code> and the loop and just call the function once.</p>

<pre><code>printf(""Post Order Display\n"");
int node_count = print_postorder(root);

if(node_count &gt; 0){
    printf(""There is at least one node in the tree"");
}
</code></pre>
",0
40997923,40997855,3,"<ol>
<li>Put the <code>typedef</code> <strong>before</strong> <code>main</code>. <code>typedef</code>s must occure <em>before</em> you use them just as vaiables.</li>
<li>Replace <code>unsigned cust;</code> by <code>cust cust;</code>. <code>unsigned cust;</code> is the same as <code>unsigned int cust;</code> and declares an unsigned integer, you want to declare a <code>cust</code>.</li>
<li>Replace <code>float charges;</code> by <code>float charge;</code> in the <code>typedef</code></li>
<li>Replace <code>Break;</code> by <code>break;</code>. Case matters in C. <code>Break</code> is not <code>Break</code>, just as <code>Int</code> is not <code>int</code>.</li>
</ol>

<p>Then it compiles.</p>

<p>Now if it it runs correctly or not is another story.</p>
",0
40997938,40997855,0,"<p>There is not a single structure in your code, not in the form of a variable declaration nor as a type definition<sup>1</sup>, and you are treating <code>cust</code> which is simply an unsigned <code>int</code> as if it was a structure, perhaps you mean</p>

<pre><code>struct {
    float previousreading;
    float currentreading;
    /* And so on */
} cust;
</code></pre>

<p>Also, there is no <code>Break</code> keyword in c, it's <code>break</code>, all lower case.</p>

<p>But,</p>

<ol>
<li><p>Don't do it, create a new <code>struct</code> so that you can use declare variables of type <code>struct Costumer</code> for example. Like at the end of your code, except that the compiler needs to know about it before using it, and the <code>cust</code> variable should have it's type.</p></li>
<li><p>A <code>char</code> is not a string type, if you want a string you need an array of <code>char</code>, so <code>char custname;</code> is not going to work for the <em>name</em> string.</p></li>
<li><p>Use meaningful names for your variables, and the members if your structure and the type name too. Like <code>costumer</code> instead of <code>cust</code>.</p></li>
</ol>

<p><strong>Additional NOTE</strong></p>

<p>See <a href=""https://stackoverflow.com/questions/5431941/why-is-while-feof-file-always-wrong"">Why <code>while (!foef(file))</code> is always wrong</a>. Your code will always attempt a read with <code>fscanf()</code> that will fail but it proceeds to print the data, it's very likely that your last row is printed twice once you make the code compile.</p>

<p>Instead, check the return value of <code>fscanf()</code>, if you don't know what it returns and don't fully understand it you can always read <a href=""http://man7.org/linux/man-pages/man3/scanf.3.html"" rel=""nofollow noreferrer"">fscanf(3)</a> documentation.</p>

<hr>

<p><sup>1</sup><sub>At least not before you attempt to use it.</sub></p>
",0
40557994,40556698,0,"<p>You mainly have four problems.</p>

<ol>
<li>""0x0123456789abcdef"" need 19 rooms. E.g char hexmsg[19];</li>
<li>Numbers and letters are different. E.g 0 != '0'          </li>
<li><code>char value;</code>... <code>value= value+hexmsg[2];</code> : using an uninitialized variable</li>
<li><code>gets</code> is obsoleted. You should not use it. There is a danger of entering more than the buffer size.</li>
</ol>

<p>For example, do as follows.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

int main(void){
    //input format : 0x0123456789abcdef
    char hexmsg[17];// omit 0x, 16 hexdigit chars + 1 for NUL
    char line[96], ch;

    for(int i = 0; i &lt; 18; ++i){//do 18 times
        printf(""write the hexmsg&gt;"");fflush(stdout);
        fgets(line, sizeof line, stdin);//Make room for input acceptance
        if(1 != sscanf(line, ""0%*1[xX]%16[0-9A-Fa-f] %c"", hexmsg, &amp;ch)){
            printf(""invalid input\n"");
            --i;//cancel this turn
            continue;
        }
        ch = tolower(*hexmsg);//3rd position of input
        if(ch == ""0123456789abcdef""[i % 16]){//check hexdigit : 0..9a..f01
            puts(""OK"");
        } else {
            puts(""NOT OK"");
            break;
        }
    }

    return 0;
}
</code></pre>
",0
41006012,41005874,5,"<p>The buffer you allocate to read the input file is one byte too short: you must allocate one extra byte and store a null terminator to make it a C string.</p>

<p>You also assume that the output message fits in a buffer of size <code>MAX</code>, which is incorrect if the source file is larger than <code>MAX-1</code> bytes.  Either limit the input to <code>MAX-1</code> bytes or allocate the output buffer to the proper size.</p>

<p>Here is a corrected version of the <code>main</code> function:</p>

<pre><code>#include &lt;ctype.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main(int argc, char *argv[]) {
    FILE *pointer_in, *pointer_out;
    char *input_buffer, *output_string;
    long len;
    int key;

    if (argc &lt; 3) {
        fprintf(stderr, ""usage: %s input_file output_file\n"", argv[0]);
        return 1;
    }
    pointer_in = fopen(argv[1], ""r"");
    if (pointer_in == NULL) {
        fprintf(stderr, ""cannot open input file %s: %s\n""
                argv[1], strerror(errno));
        return 1;
    }

    /* Get the file size */
    fseek(pointer_in, 0L, SEEK_END);
    len = ftell(pointer_in);
    fseek(pointer_in, 0L, SEEK_SET);    

    /* allocate memory to read the whole file */
    input_buffer = calloc(len + 1, sizeof(char));
    output_string = calloc(len + 1, sizeof(char));

    if (input_buffer == NULL || output_string == NULL) {
        fprintf(stderr, ""cannot allocate memory for %ld bytes\n"", len + 1);
        return 1;
    }

    /* read the file into the buffer */
    if (fread(input_buffer, sizeof(char), len, pointer_in) != len) {
        fprintf(stderr, ""cannot read input file %s\n"", argv[1]);
        return 1;
    }
    input_buffer[len] = '\0';
    fclose(pointer_in);

    /* key is calculated and passed */    
    key = find_key(input_buffer);

    /* decrypts the input_buffer, using the key and
    passes decrypted text to output_string */
    decrypt(input_buffer, output_string, key);

    /* prints the output_string to the pointer_out */
    pointer_out = fopen(argv[2], ""w"");
    if (pointer_out == NULL) {
        fprintf(stderr, ""cannot open output file %s: %s\n""
                argv[2], strerror(errno));
        return 1;
    }
    fputs(output_string, pointer_out);
    fclose(pointer_out);
    free(input_buffer);
    free(output_string);

    return 0;
}
</code></pre>

<p>Your <code>find_key()</code> function is <strong>very</strong> inefficient:</p>

<ul>
<li>You recompute the length of the string for each character.</li>
<li>You should compute the array index instead of using a huge <code>switch</code></li>
</ul>

<p>Here is a simplified version:</p>

<pre><code>int find_key(char aString[]) {
    /* This code assumes ASCII: the letters are assumed to be contiguous */
    int alphaFreq[26] = { 0 };
    int c, key;

    for (int i = 0; (c = (unsigned char)aString[i]) != '\0'; i++) {
        if (c &gt;= 'a' &amp;&amp; c &lt;= 'z') {
            alphaFreq[c - 'a']++;
        } else
        if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') {
            alphaFreq[c - 'A']++;
        }
    }

    /* find the most frequent character */
    c = 0;
    for (int i = 1; i &lt; 26; i++) {
        if (alphaFreq[c] &lt; alphaFreq[i]) {
            c = i;
        }
    }
    key = c - 4;
    return key;
}
</code></pre>
",13
41942955,39887775,0,"<p>When you do <code>scanf</code>, it takes the input until the space character, which is a delimiter. You do not need to specify anything extra for that.
If you do not need to use the value of <code>n</code> again, you could use this code.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main (void) {
  int n, x, i;
  scanf (""%d%d"", &amp;n, &amp;x);
  int *a = (int *) malloc (n * sizeof(int));    //This will allocate 'n' integer sized memory for 'a'
  for(i = 0; i &lt; n; i++) {
        scanf (""%d"", &amp;a[i]);
  }
}
</code></pre>
",0
47520689,47520513,0,"<p><code>strtok</code> accepts a string containing list of delimiters, not a single character.
To get rid of compilation error you need to replace:</p>

<p><code>real_token = strtok(real_val,' ');</code></p>

<p>with</p>

<p><code>real_token = strtok(real_val,"" "");</code></p>

<p>And the same with other occurences.</p>

<p>Also, you cannot mix two tokenizations, you need to split first string, and then second one. You can store results of both tokenizations in two arrays of char* and then iterate over them during printing. So something like this:</p>

<pre><code>char *real_token[50], *imag_token[50];
real_token[0] = strtok(real_val,"" ""); 
n = 1;
while (real_token[n-1] != NULL) {
    real_token[n] = strtok(NULL, "" "");
    n++;
}
imag_token[0] = strtok(imag_val,"" "");
n = 1;
while(imag_token[n-1] != NULL){
    imag_token[n] = strtok(NULL, "" "");
    n++;
}

// here loop from 0 to n and print
</code></pre>
",2
41647505,41647445,4,"<p>Arrays and pointers can not be used interchangeably in <em>all</em> possible use cases, and you just happened to stumble into one of them. At times, an <code>int</code> array can be implicitly converted into a pointer, and at times it, well, shouldn't be.</p>
<p>In your case, implicitly (or explicitly) converting <code>a</code> to an (<code>int **</code>) would not work, simply because <code>a</code> points to the first element in your 2d array when considered as a pointer. Converting <code>a</code> to an <code>int **</code> would make <code>pr</code> lose the information on <code>a</code> being an array. Consequently, handling it as a typical (<code>int **</code>) in <code>pr</code> and trying to dereference it twice would cause the first element in <code>a</code> (<code>a[0][0] = 1</code>) to be handled as an address and the value in that address would be looked up, which I believe is not the desired behavior of <code>pr()</code>.</p>
<p>Ideally, you should declare <code>pr</code> in a way that takes a 2D array as a parameter, not an <code>int **</code>. A declaration of <code>pr</code> with the mentioned <em>fix</em> is given below.</p>
<pre><code>void pr(int a[][5]){
    printf(&quot;%d&quot;, a[0][0]);
}
</code></pre>
<p>Now, you mention in the comments to your question that the definition of <code>pr</code> can not be modified. In order not to modify <code>pr()</code>, you would have to change the data structure you have in <code>main</code> to something similar to the one given below.</p>
<pre><code>int main(){
    int a0[5]={1,4,7,11,15};
    int a1[5]={2,5,8,12,19};
    int a2[5]={3,6,9,16,22};
    int a3[5]={10,13,14,17,24};
    int a4[5]={18,21,23,26,30};
    int *a[5] = {a0, a1, a2, a3, a4};
    pr(a);
}
</code></pre>
<p>Note that the sample above is not the most syntactically concise way to achieve your goal. Also, check <a href=""http://ideone.com/qfdlk3"" rel=""nofollow noreferrer"">here</a> to see this usage at work.</p>
",0
41647606,41647445,6,"<p>The core problem is that arrays and pointers are not the same (albeit they are closely related), and a 2D array is not an array of pointers.</p>

<p>This code shows three ways to fix up the problem.  The array <code>a0</code> is your array renamed and reformatted; the array <code>a</code> is an array of pointers, and each pointer is a pointer to an array of 5 <code>int</code> via a 'compound literal', a feature added to C99.  I've upgraded the printing function to print all 25 elements of the array that is passed to it ¡ª and created two new printing functions with different interfaces that also print the entire array passed to them.  I assume the array is square; a rectangular (non-square) matrix can be readily handled, especially by a variant on <code>pr1()</code> such as <code>pr2(int n, int m, int a[n][m])</code> ¡ª which is almost identical to <code>pr1()</code> but needs a single adjustment internally to test <code>j</code> against <code>m</code> instead of <code>n</code>.</p>

<pre><code>#include &lt;stdio.h&gt;

static void pr0(int a[][5]);
static void pr1(int n, int a[n][n]);

static void pr(int **a)
{
    for (int i = 0; i &lt; 5; i++)
    {
        for (int j = 0; j &lt; 5; j++)
            printf(""%3d"", a[i][j]);
        putchar('\n');
    }
    putchar('\n');
}

int main(void)
{
    int a0[5][5] =
    {
        {  1,  4,  7, 11, 15 },
        {  2,  5,  8, 12, 19 },
        {  3,  6,  9, 16, 22 },
        { 10, 13, 14, 17, 24 },
        { 18, 21, 23, 26, 30 },
    };
    int *a[] =
    {
        (int[]){  1,  4,  7, 11, 15 },
        (int[]){  2,  5,  8, 12, 19 },
        (int[]){  3,  6,  9, 16, 22 },
        (int[]){ 10, 13, 14, 17, 24 },
        (int[]){ 18, 21, 23, 26, 30 },
    };

    pr(a);
    pr0(a0);
    pr1(5, a0);

    return 0;
}

static void pr0(int a[][5])
{
    for (int i = 0; i &lt; 5; i++)
    {
        for (int j = 0; j &lt; 5; j++)
            printf(""%3d"", a[i][j]);
        putchar('\n');
    }
    putchar('\n');
}

static void pr1(int n, int a[n][n])
{
    for (int i = 0; i &lt; n; i++)
    {
        for (int j = 0; j &lt; n; j++)
            printf(""%3d"", a[i][j]);
        putchar('\n');
    }
    putchar('\n');
}
</code></pre>

<p>The sample output is wonderfully uniform:</p>

<pre><code>  1  4  7 11 15
  2  5  8 12 19
  3  6  9 16 22
 10 13 14 17 24
 18 21 23 26 30

  1  4  7 11 15
  2  5  8 12 19
  3  6  9 16 22
 10 13 14 17 24
 18 21 23 26 30

  1  4  7 11 15
  2  5  8 12 19
  3  6  9 16 22
 10 13 14 17 24
 18 21 23 26 30
</code></pre>

<p>The three blocks are the same.  Given a choice, I'd use the technique in <code>pr1()</code>, using VLAs (variable length arrays) in the interface.  If you must stick with the <code>int **</code> argument, you must stick with the array <code>a</code>, or something quite similar.  There are certainly other ways to create that.  For example:</p>

<pre><code>int *a[] = { a0[0], a0[1], a0[2], a0[3], a0[4] };
</code></pre>
",0
37296779,37296642,1,"<p>As the comment in the code you posted specifies, there is fall through from the first case to the second case in the switch block. Therefore, after calling <code>get_grade()</code> for the second time, the code proceeds into the second case.</p>
",2
37347537,37347439,2,"<p>You misunderstand the way preprocessor definitions work: they are a completely compile-time construct. By the time the compiler finishes the translation (in fact, by the time the compiler <em>starts</em> the translation) the definitions such as <code>BANK1</code> and <code>BANK2</code> are gone irretrievably.</p>

<p>If you would like to use symbolic names for numbers, you need to build this functionality yourself: add a check for <code>argv[1]</code> or <code>argv[2]</code> to be a C string containing <code>BANK1</code> or <code>BANK2</code> using <code>strcmp</code>, then either call <code>strtol</code> or use a pre-defined constant:</p>

<pre><code>#define STR(X) #X
...
int parse(const char* str) {
    if (strcmp(str, STR(BANK1)) == 0) {
        return BANK1;
    }
    if (strcmp(str, STR(BANK2)) == 0) {
        return BANK2;
    }
    return strtol(str, NULL, 0);
}
</code></pre>

<p><strong>Note:</strong> In case you are curious of how <code>STR(X)</code> works, look up <a href=""https://msdn.microsoft.com/en-us/library/7e3a913x.aspx?f=255&amp;MSPPError=-2147217396"" rel=""nofollow""><em>stringizing operator</em></a>.</p>
",0
37347593,37347439,-1,"<p>When you call </p>

<pre><code>./main BANK1 0x30 
</code></pre>

<p><code>BANK1</code> is a string. In your code <code>BANK1</code> is a integer. So you have to map it. Read the argument as a string and search for it in a map <a href=""http://www.cplusplus.com/reference/map/map/map/"" rel=""nofollow"">like here</a></p>
",4
37347641,37347439,0,"<blockquote>
  <p>The C Preprocessor is not a part of the compiler, but is a separate
  step in the compilation process. In simple terms, a C Preprocessor is
  just a text substitution tool and it instructs the compiler to do
  required pre-processing before the actual compilation. Read <a href=""http://www.tutorialspoint.com/cprogramming/c_preprocessors.htm"" rel=""nofollow"">here</a></p>
</blockquote>

<p>This means that when you have your .exe file there is no reference to <code>BANK1 - BANK2</code> and so on.
They are sobstituted before compilation phase with their values. In fact:</p>

<blockquote>
  <p><code>#define</code> Substitutes a preprocessor macro.</p>
</blockquote>

<p>When you give in input <code>BANK1</code> that is just a string!</p>

<hr>

<h2>EXAMPLE:</h2>

<p>If you try this example, you can understand how preprocessor works. When you compile your code it substitute <code>__TIME__</code> constant with the current time, and whenever you'll execute your code it'll print the time when you compiled:</p>

<pre><code>#include &lt;stdio.h&gt;
int main(){
    printf(""Time :%s\n"", __TIME__ );

    getchar();
}
</code></pre>

<p>For more read <a href=""https://en.wikipedia.org/wiki/C_preprocessor"" rel=""nofollow"">here</a></p>
",0
41910356,41910209,2,"<p>You are only comparing the previous and next strings. You need to check the lengths of <em>all</em> the strings.</p>

<pre><code>void length(char str[][MAX])
{
    size_t longest = strlen(str[0]);
    szie_t j = 0;

    for(size_t i = 1; i &lt; LEN; i++)
    {
        size_t len = strlen(str[i]);
        if(longest &lt; len)
        {
           longest = len;
           j = i;
        }
   }
   printf(""%s"", str[j]);
}
</code></pre>

<p>I am assuming you have at least 1 string and handle corner cases (if user inputs less than <code>LEN</code> strings etc -- depends on how you fill the <code>str</code> with strings).</p>
",0
47521571,47520782,0,"<p>I don't think that you are on the right way; The way how a C compiler passes parameters to functions is mostly unspecified; it may decide to use registers, the stack, or both; and it also may vary the offsets between register arguments and stacked arguments; So all your assumptions may hold, but they may not hold any more for different compilers or different platforms.
Maybe your compiler lets you somehow control argument passing, but there is no standard way of doing this.</p>

<p>C standard introduces <code>va_list</code> structure and associated macros in order to get independent from these implementation details. Use this; other ways are very likely undefined behaviour (e.g. adding an integral value to a pointer such that it points beyond the last element of an ""array"" or accessing the element one past the last element through such a pointer is UB; your code actually does this).</p>
",2
43726474,43724943,0,"<blockquote>
  <p>Printing number of line <em>before</em> </p>
</blockquote>

<p>To print the line number <em>before</em> the line, detect if the previous character was a <code>'\n'</code>.</p>

<pre><code>unsigned long long line = 0;
int previous = '\n';
int ch;

while ((ch = fgetc(source)) != EOF) {
  if (previous == '\n') {
    line++;
    printf(""%llu."", line);
  }
  putchar(ch);
  previous = ch;
}

// With files that do not end with a \n, perhaps print a \n anyways
if (previous != '\n') {
  putchar('\n');
}
</code></pre>
",2
43725345,43724943,1,"<p>Ok the issue has been fixed.
The output now looks like what I wanted and I'm working on the little tips provided by you guys.</p>

<p>Here's the output</p>

<pre><code>The file being displayed is asd.txt
1.Teste
2.Teste
3.Teste
4.
5.asd
6.asd
7.asd
8.asd
9.asd
10.asd
11.asd
12.asd
13.asd
</code></pre>

<p>And here's the fixed code.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/*
 * 
 */
int main(int argc, char** argv) {
   char source_file[20];
   int ch;
   FILE *source;
   int i=1;
   if( argc == 2 ) {
      printf(""The file being displayed is %s\n"", argv[1]);

   source = fopen(argv[1], ""r"");

   if( source == NULL )
   {
      printf(""Press any key to exit...\n"");
      exit(EXIT_FAILURE);
   }

   while( ( ch = fgetc(source) ) != EOF )
   {
       if(ch=='\n')
       {
          putchar(ch);
          printf(""%d."", i);
          i++;
       }
       else if(i==1)
       {
           printf(""%d."", i);
           i++;
           putchar(ch);
       }
       else
          putchar(ch);
   }

   fclose(source);

    return (EXIT_SUCCESS);
}
}
</code></pre>

<p>Thanks everyone for the help.</p>
",1
41652727,41652654,3,"<p>Your function has problems:</p>

<ul>
<li>you omit the return type, this is no longer supported by Standard C.</li>
<li>The first <code>for</code> loop effectively erases the string pointed to by <code>str2</code>.  There is no guarantee it even has a null terminator.</li>
<li>the <code>while</code> loop invokes undefined behavior if the <code>str1</code> does not contain a <code>.</code> or if it is shorter than <code>str2</code>.</li>
<li>do not hardcode ASCII values such as <code>97</code> or <code>122</code>. It is neither portable not even readable.  Use <code>'a'</code> and <code>'z'</code> or preferably the functions defined in <code>&lt;ctype.h&gt;</code>.</li>
</ul>

<p>Here is a simple string function for your purpose:</p>

<pre><code>int str_ends_with(const char *s, const char *suffix) {
    size_t slen = strlen(s);
    size_t suffix_len = strlen(suffix);

    return suffix_len &lt;= slen &amp;&amp; !strcmp(s + slen - suffix_len, suffix);
}
</code></pre>
",5
43935886,43935823,0,"<p><code>strlen()</code> just counts non-zero bytes starting from the argument pointer. You don't seem to zero your <code>temp</code> array anywhere.</p>
",0
43935904,43935823,1,"<p><code>strlen</code> checks for the first occurence of <code>\0</code>. When you call <code>strlen</code> with an uninitialized array, like you do here:</p>

<pre><code>    char temp[size];
    printf(""The value of i is : %d\n"", i);
    printf(""The value of size is : %d\n"", size);
    printf(""The copy has the size of: %d\n"", strlen(temp));
</code></pre>

<p>the content of the array is random, and your program has undefined behavior because you're not allowed to use uninitialized variables.</p>
",0
41656608,41656578,1,"<p>Try <code>d = DEPILER(&amp;p);</code> instead of <code>d = DEPILER(*p);</code>.</p>
",1
41682177,41682085,1,"<p>Because unless you are using some overrun-protection library/debugging tool, nothing will notice that you¡¯re writing to memory you shouldn¡¯t be. If you run this under <code>valgrind</code> it will display that you wrote to memory you shouldn¡¯t have. But <code>malloc(5)</code> returns a pointer into a likely larger block of memory, so the chances of the buffer overflow resulting in trying to access an unmapped address is low. But if you had other <code>malloc()</code> calls, etc., you might notice the <code>""overflow""</code> part ending up in one of those other buffers¡ªbut it really depends on the implementation of <code>malloc()</code> and what code that overflow breaks won¡¯t be deterministic.</p>
",0
41682118,41682085,1,"<p>Copying to a buffer that is too small is undefined behavior; that doesn't necessarily mean it's guaranteed to crash.  For all we know those other bytes occupying the <code>""overflow\0""</code> part of your string aren't being used anyway.</p>
",0
41682347,41682085,1,"<p>Your buffer is allocated in the heap so your pointer src is pointing to buffer of char basicly of size 5 bytes because the size of char is 1 byte, however if the size of this allocated buffer + the added size by copying the string into this buffer doesn't exceed the size of the heap then it will work ,in the other hand if the total size try to overwrite an allocat memory by other pointer then you get the crash or the size exceed the heap size limitation you get the crash
As conclusion avoid this kind of code because you will get an unexpected behavior.</p>
",0
41682215,41682085,3,"<p>Buffer overflows are not guaranteed to crash you: they cause undefined behavior. While a lot of platforms make the sequence of events that <em>may</em> or <em>may not</em> culminate in a crash rather predictable, one very important thing to consider is that the possible crash almost never happens at the same time that the damage is caused.</p>

<p>In a stack buffer overflow, possible crashes happens when you read the value of a variable that sat on the stack and was overflowed onto, or when you return from the function and the return address has been overwritten.</p>

<p>However, you're <em>not overflowing a stack buffer</em>: you're overflowing a heap buffer that you got from <code>malloc</code>. Typically, possible crashes there happens when you <code>free</code> that buffer or try to use a buffer that happened to be contiguous to it (there is, on purpose, no way to predict this). You allocate only one buffer and never free it, so you're not going to observe any problem from a small overflow.</p>

<p>In addition, I don't know any mainstream <code>malloc</code> implementation on desktops that returns blocks of less than 32 bytes, so even though you said <code>malloc(5)</code>, you probably have room for 32 bytes, so your short write is not overflowing on anything (although you <strong>must not</strong> rely on this).</p>

<p>The only case where an overflow will straight-up crash your program is if you overflow to a memory location that has not been assigned any meaning. For instance, if you do something like <code>memset('c', dest, 100000000)</code>, that will probably happen because you'll be busting out of the memory area that is reserved to the stack and there is probably nothing next to it.</p>
",0
41682231,41682085,4,"<p>It does crash due to a buffer overrun.</p>

<p>The behaviour of your code is undefined as you are overrunning your buffer. You can't expect the behaviour to be in any way predictable.</p>

<p>It's difficult - and not required by the c standard - to issue an appropriate diagnostic in such cases.</p>
",0
37643267,37643234,3,"<p><code>*p++;</code> means</p>

<ol>
<li>increment <code>p</code> and get its value before incrementing</li>
<li>dereference the value</li>
<li>throw the result away</li>
</ol>

<p><code>*p++=*q;</code> means</p>

<ol>
<li>increment <code>p</code> and get its value before incrementing</li>
<li>dereference the value to know where to store</li>
<li>dereference <code>q</code></li>
<li>store the data read</li>
</ol>

<p>(the actual order of evaluation is unspecified and may differ)</p>

<p>Changing it do changes. You didn't observe the change because you didn't check the value stored in <code>p[-1]</code> (<code>p</code> is value after incrementing).</p>

<p>Note that the lines</p>

<pre><code>printf(""%d  \n"", p);
printf(""%d  \n"", q);
</code></pre>

<p>invoke <em>undefined behavior</em> by passing data having wrong value to <code>printf</code>. The lines should be</p>

<pre><code>printf(""%p  \n"", (void*)p);
printf(""%p  \n"", (void*)q);
</code></pre>

<p>Use <code>%p</code> specifier and cast the pointer to print to <code>void*</code> to print pointers via <code>printf</code>.</p>
",0
37643273,37643234,0,"<p>Your question is wrong. You claim ""nothing changes"" and ask why. </p>

<p>The reality is that <em>something</em> changed. But not any of the things you were looking at. Go and figure out what changed. </p>

<p>On top of that, printing p and q with a %d modifier is undefined behaviour. </p>

<p>I have ¡ê5 in my wallet. I put ¡ê10 in my sock. I check my wallet, and there is still ¡ê5 in my wallet. Nothing changed. Why? </p>
",2
43752736,43752641,-6,"<p>The error is because in </p>

<p>printf(""%d:this is for test:%s"",a);</p>

<p>You need to pass two parameters, one to %d and another to %s.
So, now a will be substituted in the place of ""%d"", you are not passing anything to be substituted in the place of %s.</p>
",1
43752761,43752641,2,"<p>compile with <code>gcc -Wall</code><br>
for this situation warning be like: <code>warning: format ¡®%s¡¯ expects a matching ¡®char *¡¯ argument [-Wformat=]</code></p>
",0
43752830,43752641,-5,"<p>Why you are using ""%s""? Here no need to use ""%s"" as it is used to print string value.
For integer value you only need ""%d"".</p>

<p>Run your code like this.</p>

<pre><code>#include&lt;stdio.&gt;
int main()
{
  int a = 1;
  printf(""%d: this is for test"", a);
}
</code></pre>

<p>Thanks.</p>

<p>[EDIT]</p>

<p>It's undefined if you pass fewer arguments than the format specifiers. Compiler is not required to produce any errors on undefined behaviour.</p>

<p>Although, most compilers would do. GCC, for example, produces the following for your code:</p>

<pre><code>warning: too few arguments for format
</code></pre>

<p>when compiled with:</p>

<pre><code>gcc -Wall -Wextra -std=c99 file.c
</code></pre>
",5
43752830,43752641,-5,"<p>Why you are using ""%s""? Here no need to use ""%s"" as it is used to print string value.
For integer value you only need ""%d"".</p>

<p>Run your code like this.</p>

<pre><code>#include&lt;stdio.&gt;
int main()
{
  int a = 1;
  printf(""%d: this is for test"", a);
}
</code></pre>

<p>Thanks.</p>

<p>[EDIT]</p>

<p>It's undefined if you pass fewer arguments than the format specifiers. Compiler is not required to produce any errors on undefined behaviour.</p>

<p>Although, most compilers would do. GCC, for example, produces the following for your code:</p>

<pre><code>warning: too few arguments for format
</code></pre>

<p>when compiled with:</p>

<pre><code>gcc -Wall -Wextra -std=c99 file.c
</code></pre>
",5
43752736,43752641,-6,"<p>The error is because in </p>

<p>printf(""%d:this is for test:%s"",a);</p>

<p>You need to pass two parameters, one to %d and another to %s.
So, now a will be substituted in the place of ""%d"", you are not passing anything to be substituted in the place of %s.</p>
",1
43752761,43752641,2,"<p>compile with <code>gcc -Wall</code><br>
for this situation warning be like: <code>warning: format ¡®%s¡¯ expects a matching ¡®char *¡¯ argument [-Wformat=]</code></p>
",0
44713901,44713842,2,"<p>When you do</p>

<pre><code>filename_ptr = &amp;time_stamp();
</code></pre>

<p>you <strong><em>call</em></strong> the <code>time_stamp</code> function with no argument, and take a pointer to the returned string.</p>

<p>If you want a pointer to the function (why?) then drop the parentheses.</p>

<p>Later you use the pointer to the function (which doesn't point to a function) and call it, <em>again</em> without an argument.</p>

<p>All of this should cause the compiler to should loudly at you, and lead to plenty of <em>undefined behavior</em>.</p>

<p>Furthermore there is no <code>output</code> variable, which will lead to a compiler <em>error</em>.</p>

<p>By the way, the <code>time_stamp</code> function doesn't really do anything with the time. It basically only copies a fixed static string into the buffer.</p>

<hr>

<p>To call the function in a loop, just do it? Passing the loop iterator variable as argument.</p>

<pre><code>for (int i = 0; i &lt; 3; ++i)
{
    FILE *fp = fopen(time_stamp(i));
    ...
}
</code></pre>
",2
41668532,41668455,4,"<p>If you open a file for update (<code>+</code>) and if you do one or more read operations, you must do a positioning operation (e.g. <code>fseek()</code>) before you do any writes.  If you do one or more write operations, you must do a positioning operation (e.g. <code>rewind()</code>) before you do any reads.  See POSIX's specification of <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/fopen.html"" rel=""nofollow noreferrer""><code>fopen()</code></a> for example.</p>

<blockquote>
  <p>When a file is opened with update mode (<code>'+'</code> as the second or third character in the mode argument), both input and output may be performed on the associated stream. However, the application shall ensure that output is not directly followed by input without an intervening call to <code>fflush()</code> or to a file positioning function (<code>fseek()</code>, <code>fsetpos()</code>, or <code>rewind()</code>), and input is not directly followed by output without an intervening call to a file positioning function, unless the input operation encounters end-of-file.</p>
</blockquote>

<p>You are doing no positioning operations between reads and writes.  That, in and of itself, leads to undefined behaviour.</p>

<p>Assuming your implementation exhibits 'undefined behaviour' by not going out of its way to misbehave, after your last <code>fread()</code>, you will write over the next entry ¡ª or append a new entry if the last one read was at the end of the file.</p>

<ul>
<li>Decide where you want the data written.</li>
<li>Seek to the correct location (use <code>fseek(fp, 0L, SEEK_CUR)</code> if you don't want to move the read/write pointer).</li>
<li>Write.</li>
<li>If you'll be reading next, do another seek ¡ª another no-op if need so be.</li>
</ul>
",0
37635156,37634966,0,"<p>As you said there should be no characters before <code>t</code>, <strong>in the <code>checker()</code> function just check if the first element of your sent string is <code>t</code> or not.</strong></p>

<pre><code>int checker(char* string)
{
    if(string[0]=='t')
       return 1;
    return 0;
}
</code></pre>
",0
37640817,37634966,4,"<p>There is no way to check whether or not  a pointer passed to a function points to the first element. If you decrement the pointer to a location <em>before</em> the region of storage allocated to the pointer, you invoke <em>undefined behaviour</em>.</p>

<p>The decremented pointer might end up pointing to a completely different variable than the one passed to your function or some uninitialized memory with unpredictable results. The pointer may even point outside the memory allocated to your process resulting in a crash.</p>

<p>Undefined behaviour may even result in your program working as expected for years until it starts failing in mysterious ways, sometimes in completely unrelated parts of the code.</p>
",0
41647620,41647605,0,"<p>Pass <code>pp</code>, not <code>*pp</code>, to the function <code>SumStr</code>. <code>*pp</code> has the type <code>char</code>, and the function expects <code>char *</code>. In fact, you do not even need <code>pp</code> at all, just pass the <code>buffer</code> as the parameter.</p>

<p>Also:</p>

<blockquote>
  <p><a href=""https://stackoverflow.com/questions/1694036/why-is-the-gets-function-dangerous-why-should-it-not-be-used"">Never use gets()</a>.  Because it is impossible to tell without knowing the
         data in advance how many  characters  gets()  will  read,  and  because
         gets() will continue to store characters past the end of the buffer, it
         is extremely dangerous to use.  It has  been  used  to  break  computer
         security.  Use fgets() instead.</p>
</blockquote>
",1
41647848,41647605,2,"<p>This may serve your purpose </p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

int main()
{
    int i, sum = 0, store;
    char str[] = ""a14fg5pk145asdasdad6"";
    int length = strlen(str);
    for(i = 0; i &lt; length; i++) {
        store = 0;
        while(isdigit(str[i])) {
            store = (store * 10) + (str[i] - '0');
            i++;
        }
        sum += store;
    }
    printf(""%d\n"", sum);
    return 0;
}
</code></pre>

<p><strong>output :</strong></p>

<pre><code>170
</code></pre>
",0
41647809,41647605,2,"<p>First problem with your code which is causing Exception.</p>

<pre><code>x = SumStr(*pp);
</code></pre>

<p>it should be</p>

<pre><code>x = SumStr(pp);
</code></pre>

<p>Because you should pass address of the string pointer not its first character by attaching asterix.</p>

<p>Second Issue that will not make it work is.</p>

<pre><code>num += (*str);
</code></pre>

<p>and</p>

<pre><code>num = num * 10 + (*str);
</code></pre>

<p>By (*str) you are actually adding the character ascii value instead of number.
This will solve the problem by changing the ascii value to number.</p>

<pre><code>num += (*str) - '0';

num = num * 10 + (*str) - '0';
</code></pre>
",1
37761677,37761561,0,"<blockquote>
  <p>I am not getting all of the data</p>
</blockquote>

<ul>
<li><p>That's because you are not printing the <code>sequence</code> in <code>printf()</code> of the <code>for</code> loop.</p>

<pre><code>printf(""\t\t\t%d\n "", c);
</code></pre></li>
<li><p>and even before 2<sup>nd</sup> number before <code>for</code> loop</p>

<pre><code>printf("" %d \t\t\t%d\n \t\t\t%d\n "", sequence, a, b);
</code></pre></li>
</ul>

<hr>

<p>try making the below changes to your code :</p>

<pre><code>printf("" %d \t\t\t%d\n %d\t\t\t%d\n "", sequence, a, sequence+1, b);

sequence++; //as you've printed 2 values already in above printf

for (i=0; i &lt;= (n - 3); i++)
{
    c = a + b;
    a = b;
    b = c;
    printf(""%d\t\t\t%d\n "",++sequence, c); 
 //or do sequence++ before printf as you did and just use sequence in printf
}
</code></pre>

<hr>

<p><strong>sample input :</strong> <code>5</code></p>

<p><strong>sample output :</strong></p>

<pre><code>How many Fibonacci numbers would you like to print?: 5 
 n       Fibonacci Numbers
 1          0
 2          1
 3          1
 4          2
 5          3
</code></pre>

<hr>

<p><strong>Edit</strong> : you can do it using functions this way... it's nearly the same thing :)</p>

<pre><code>#include &lt;stdio.h&gt;

void fib(int n)
{
    int i,sequence=0,a=0,b=1,c=0;

    printf(""\n n\t\t Fibonacci Numbers\n"");

    printf("" %d \t\t\t%d\n %d\t\t\t%d\n "", sequence, a, sequence+1, b);

    sequence++;

    for (i=0; i &lt;= (n - 2); i++)
    {
        c = a + b;
        a = b;
        b = c;
        printf(""%d\t\t\t%d\n "",++sequence, c);
    }
}

int main()
{
int n;

printf(""How many Fibonacci numbers would you like to print?: "");
scanf(""%d"",&amp;n);
fib(n);

return 0;
}
</code></pre>
",3
37761619,37761561,0,"<p>You forgot to print <code>sequence</code> in the for loop. Print <code>sequence</code> along with <code>c</code> in the for loop after giving proper number of <code>\t</code>!</p>
",1
37761894,37761561,0,"<p>This would work, also it is better to properly indentate your code:</p>

<pre><code>int main() {
    int i, n;
    int sequence = 1;
    int a = 0, b = 1, c = 0;

    printf(""How many Fibonacci numbers would you like to print?: "");
    scanf(""%d"",&amp;n);

    printf(""\n n\t\tFibonacci Numbers\n"");

    printf("" %d\t\t\t%d\n"", sequence, a);
    printf("" %d\t\t\t%d\n"", ++sequence, b); //   &lt;- and you can use pre increment operator like this for your purpose

    for (i=0; i &lt;= (n - 3); i++) {
        c = a + b;
        a = b;
        b = c;
        sequence++;
        printf("" %d\t\t\t%d\n"",sequence, c);
    }

    return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>How many Fibonacci numbers would you like to print?: 4

 n      Fibonacci Numbers
 1          0
 2          1
 3          1
 4          2
</code></pre>
",0
45115753,45115324,0,"<p>Correct your for loop,begin from 0 since C is 0 origin.</p>

<pre><code>for(i=0;i&lt;n;i++){ 
  scanf(""%d"",&amp;a[i]);
}
</code></pre>

<p>C function parameters are always ""pass-by-value"", which means that the function scanf only sees a copy of the current value of whatever you specify as the argument expression.</p>

<p>Array name returns the pointer of the first element of a array (memory location where array is stored), and name of the scalar variable returns the value of the scalar, so you need to use &amp; operator to get the memory location of scalar in which you need to write the value.</p>

<p><strong>And kindly check your Quick sort logic and calling</strong></p>
",2
45116116,45115324,0,"<p>This is a working version of your program with some small modifications:</p>

<p>1) The first element is chosen as pivot</p>

<p>2) Check stop condition of the recursive function, that is <code>if (lo &gt;= hi) { return; }</code></p>

<p>3) Swap the pivot element with element at index <code>i-1</code> after the <code>while</code> loop</p>

<p>4) Include equality in <code>else if (a[i] &lt;= pivot)</code> and <code>else if (a[j] &gt;= pivot)</code> to prevent infinitive loop when an element has the same value as pivot, for example <code>1 1 3 5</code></p>

<pre><code>#include &lt;stdio.h&gt;


void quick(int a[], int lo, int hi)
{
    if (lo &gt;= hi)
    {
        return;
    }

    int pivot, j, temp, i;
    pivot = a[lo];
    i = lo + 1;
    j = hi;

    while (i &lt;= j)
    {
        if (a[i] &gt; pivot &amp;&amp; a[j] &lt; pivot)
        {
            temp = a[i];
            a[i] = a[j];
            a[j] = temp;
            i++;
            j--;
        }
        else if (a[i] &lt;= pivot)
            i++;
        else if (a[j] &gt;= pivot)
            j--;
    }

    int l = i - 1;
    temp = a[l];
    a[l] = a[lo];
    a[lo] = temp;

    quick(a, lo, l-1);
    quick(a, l+1, hi);
}

int main()
{
    const int MAX_NUM = 100;
    int arr[MAX_NUM];

    int n = 0;
    printf(""How many numbers? n = "");
    scanf(""%d"", &amp;n);

    if (n &lt; 1 || n &gt; 100)
    {
        printf(""Invalid input. Nothing to do\n"");
        return 0;
    }

    for (int i = 0; i &lt; n; i++)
    {
        printf(""a[%d] = "", i);
        scanf(""%d"", &amp;arr[i]);
    }

    printf(""Sorting...\n"");
    quick(arr, 0, n-1);

    for (int i = 0; i &lt; n; i++)
    {
        printf(""%d "", arr[i]);
    }
    printf(""\n"");
}
</code></pre>
",1
45116149,45115324,0,"<p>Try this and you can even modify as per your choice:</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;

void swap(int* a, int* b)
{
    int t = *a;
    *a = *b;
    *b = t;
}

int partition (int arr[], int low, int high)
{
    int pivot = arr[high];
    int i = (low - 1); 

    for (int j = low; j &lt;= high- 1; j++)
    {
        if (arr[j] &lt;= pivot)
        {
            i++; // increment index of smaller element
            swap(&amp;arr[i], &amp;arr[j]);
        }
    }
    swap(&amp;arr[i + 1], &amp;arr[high]);
    return (i + 1);
}
/*
arr[] --&gt; Array to be sorted,
low --&gt; Starting index,
high --&gt; Ending index */
void quickSort(int arr[], int low, int high)
{
    if (low &lt; high)
    {
        int pi = partition(arr, low, high);

        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

void printArray(int arr[], int size)
{
    int i;
    for (i=0; i &lt; size; i++)
        printf(""%d "", arr[i]);

}

void main()
{
    clrscr();
    int arr[100], n,i;
    printf(""Enter the size of array:\n"");
    scanf(""%d"",&amp;n);

    printf(""Enter your Array List:\n"");
    for (i=0;i&lt;n;i++)
    scanf(""%d"",&amp;arr[i]);

    quickSort(arr, 0, n-1);
    printf(""Sorted array: "");
    printArray(arr, n);
    getch();
}
</code></pre>
",0
45116036,45115324,1,"<p>As other people pointed out in comments, you're doing some mistakes:</p>

<ol>
<li>You've declared your array as <code>int a[n]</code>; and array indexing starts from 0, then why are you passing the array like it's indexing starts from 1 ? You need to change those for loops to : <code>for(i=0;i&lt;n;i++)</code> and you quicksort call like this: <code>quick(a,0,n-1);</code>.</li>
<li>You quicksort logic seems flawed. You choose <code>a[l]</code> as your pivot but you include that in your partitioning logic. You're also not checking for the base condition of your recursion, i.e <code>l &lt; u</code>. </li>
<li>After partiioning the array you're supposed to swap the pivot with the mid element of your partition (i.e last element of first half or the first element of second half, depending upon your choice). I changed your quicksort function like <a href=""https://gist.github.com/rohanKanojia/d7c2327742480cd7367bc133e9da823f"" rel=""nofollow noreferrer"">this</a>. And i was able to see the desired output.</li>
</ol>

<p>I hope this helps.</p>
",2
45294326,45293951,2,"<p>From the <a href=""https://linux.die.net/man/2/pause"" rel=""nofollow noreferrer"">pause(2) man page</a> (emphasis mine):</p>

<blockquote>
  <p>pause() causes the calling process (or thread) to sleep <strong>until a signal is delivered that either terminates the process or causes the invocation of a signal-catching function</strong>.</p>
</blockquote>

<p>And more specifically:</p>

<blockquote>
  <p>pause() only returns when a signal was caught and the signal-catching function returned.</p>
</blockquote>

<p>This means that for your child to unpause, you need to send it a signal (and probably a custom signal handler).</p>

<p>This is a simple signal handling function - Usually these are put at the top of your page (under the imports) or in the header file.</p>

<pre><code>void handleContinueSignal(int sig) {
    myGlobalStaticContinueVariable = 1; // Or some other handling code
}
</code></pre>

<p>And this is how you announce that your signal handling function should be associated with the <code>SIGCONT</code> signal, should it ever be received. You'll probably only want your child process to run this line. Make sure you put it in before the pause though - getting signal handlers running is one of the first things that a new process should do.</p>

<pre><code>signal(SIGCONT, handleContinueSignal); // Name of the signal handling function
</code></pre>

<p>Finally, you can make your parent send a <code>SIGCONT</code> signal to the child by giving its PID like this:</p>

<pre><code>kill(yourChildPID, SIGCONT);
</code></pre>

<p>For your code, you'll have to make the parent loop though and call this once for each child's PID, which will wake each of them up in turn.</p>
",8
42592912,42592689,1,"<p>Your X is some variable which is aligned to 8 bits (8, 16, 32, etc).</p>

<p>When you write <code>x = 12</code> you set <code>x = 1100</code> (binary) for lower nibble but you set all other bits to <code>0</code>.
When you invert this, all other bits are also inverted and if your <code>X</code> is <code>signed</code> (for example char) you will get negative output which is ok.</p>

<pre><code>//Assume x is char
char x;
x = 12; //00001100;
x = ~x; //11110011;
</code></pre>

<p>Thats why you get <code>-13</code> here.</p>
",8
40579526,40579208,-1,"<p>First: You need to start your loop with zero (<code>i = 0</code>), because C arrays are zero-based.</p>

<p>That said, I guess your problem is because the last <code>scanf()</code> leaves a line break in the <code>stdin</code> buffer. You can try the following code:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define STUD 3

struct students {
  char name[30];
  int score;
  int presentNr;
} student[STUD];

void clean_stdin(void)
{
  char c;
  do c = getchar(); while (c != '\n' &amp;&amp; c != EOF);
}

int main() {
  for (int i = 0; i &lt; STUD; i++) {

    printf(""Name of the student %d:\n"", i + 1);
    fgets((char*)&amp;student[i].name, 30, stdin);

    // Remove the line break at the end of the name
    student[i].name[strlen((char*)&amp;student[i].name) - 1] = '\0';

    printf(""His score at class: "");
    scanf(""%d"", &amp;student[i].score);

    printf(""Number of presents at class: "");
    scanf(""%d"", &amp;student[i].presentNr);

    // cleans stdin buffer
    clean_stdin();
  }

  getchar();
}
</code></pre>

<p>Note: There's a builtin function (<code>fflush()</code>) to flush the input buffer, but sometimes, for some reason it does not work, so we use the custom <code>clean_stdin()</code> function.</p>
",2
41903987,41903877,-1,"<p>Remember always that an <strong>Array</strong> is a <strong>Pointer</strong> to the first object of the array.
And secondly, in your call to <code>scanf()</code> you only read a character. Not a whole string (represented by <code>%s</code> in C)</p>

<p>So in conclusion, your call to <code>scanf()</code> shouldn't have a pointer <strong>and</strong> should have a <strong>string</strong> instead of a <strong>character</strong>.</p>

<pre><code>scanf(""%s"", Repeatprog);
</code></pre>

<p>or simply </p>

<pre><code>gets (Repeatprog);
</code></pre>

<h2>EDIT :</h2>

<p>As the commenter @EOF said, <code>gets()</code> is not a good idea since it can lead to <code>Undefined Behaviour</code>. That's because the program can read more characters than it should have and lead to overflow, thus it isn't secure.</p>

<p>So I recommend using <code>char *fgets(char *str, int n, FILE *stream)</code></p>

<h2><em>Note:</em></h2>

<p>Also, your code is using string literals. So if you make any attempt to change the content of the <code>char</code> <strong>pointer</strong> then it will lead to <code>Undefined Behaviour</code>. </p>

<blockquote>
  <p><strong>For this note, please thank the guys <em>below</em> me [comments]. I made a huge mistake and I'm sorry.</strong></p>
</blockquote>
",12
40568963,40568933,0,"<p>The function must be declared like</p>

<pre><code>void change(int v[]) {
            ^^^^^^
</code></pre>

<p>and called like</p>

<pre><code>changes( v );
</code></pre>

<p>As result you have to change these statements</p>

<pre><code>   if (*v[i] &gt; *v[j]) {
        tmp = *v[i];
        *v[i] = *v[j];
        *v[j] = tmp;
</code></pre>

<p>like</p>

<pre><code>   if ( v[i] &gt; v[j]) {
        tmp = v[i];
        v[i] = v[j];
        v[j] = tmp;
</code></pre>

<p>The function can look like</p>

<pre><code>void change( int v[] ) 
{
    for ( int i = 0; i &lt; 10; i++ ) 
    {
        for ( int j = i + 1; j&lt; 10; j++ )
        {
            if ( v[i] &gt; v[j] ) 
            {
                int tmp = v[i];
                v[i] = v[j];
                v[j] = tmp;
            }
        }           
    }
}
</code></pre>

<p>Take into account that it would be better if the function could deal with arrays of different sizes. In this case it must have second parameter that will specify the number of elements in the array. For example</p>

<pre><code>void change( int v[], size_t n ) 
{
    for ( size_t i = 0; i &lt; n; i++ ) 
    {
        for ( size_t j = i + 1; j &lt; n; j++ )
        {
            if ( v[i] &gt; v[j] ) 
            {
                int tmp = v[i];
                v[i] = v[j];
                v[j] = tmp;
            }
        }           
    }
}
</code></pre>

<p>And the function can be called like</p>

<pre><code>change( v, 10 );
</code></pre>
",3
40569140,40568933,0,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include &lt;string.h&gt;

void change(int *v[]) {
int *tmp;
for (int i = 0; i &lt; 10; i++) {
    for (int j = i + 1; j&lt; 10; j++)
        if (v[i] &gt; v[j]) {
            tmp = v[i];
            v[i] = v[j];
            v[j] = tmp;
        }
}

}


void main() {
int *v[10];
for (int i = 0; i &lt; 10; i++) {
    printf(""Enter the value for v[%d]: \n"", i);
    scanf(""%d"", &amp;v[i]);
}
printf(""The vector is: \n"");
for (int i = 0; i &lt; 10; i++)
    printf(""Value on the position %d is %d \n"", i, v[i]);

        change(v);                              



   printf(""\n\n After function call, the vector is: \n"");
   for (int i = 0; i &lt; 10; i++)
    printf(""Value on the position %d is %d \n"", i, v[i]);

_getch();
}
</code></pre>

<p>I solve ! thank you guy. This is the code if someone is 
interested</p>
",0
41910297,41910012,0,"<p>You did not allocate any memory for the info_text strings. You either have to use <code>malloc()</code> first, or if your C library supports it (the GNU one does), use <code>asprintf()</code> instead of <code>sprintf()</code> to have it allocate enough memory to hold the whole output string for you:</p>

<pre><code>for(cpt = 0; cpt &lt; 2; cpt++)
  asprintf(&amp;module_text3.info[cpt], ""info[%u]"", cpt);
</code></pre>

<p>Don't forget that you also have to free the memory again at some point.</p>

<p>The reason that the following line works:</p>

<pre><code>module_text3.info_text[0] = ""toto[0]"";
</code></pre>

<p>Is that the compiler ensures the string <code>""toto[0]""</code> is stored in memory somewhere, and you just make the pointer <code>module_text3.info_text[0]</code> point to that string.</p>
",1
41910307,41910012,0,"<p>You have not allocated space for the strings in the <code>info_text</code> field. The simplest thing to do would be to change the <code>struct</code>:</p>

<pre><code>/*module.h*/

#define NB_LINE_MAX 10
#define INFO_MAX 25

struct message3
{
  char info_text[NB_LINE_MAX][INFO_MAX]; /*a few info lines.*/
  char *error_text; /*only one line for error.*/
  int id;
  int info_nb_max;
  int info_nb;
};

extern struct message3* moduleFcn3(void);
</code></pre>
",0
41906023,41906012,2,"<p>The problem is that you used a function without first telling the compiler about it. </p>

<p>In this case you must provide function prototype as the function definition itself is provided after <code>main</code></p>

<pre><code>int dis( void ); // function prototype
int main()
{
    ...
}
int dis() // function definition
{
    ...
}
</code></pre>

<p>Alternatively, you can put the function definition before <code>main()</code>. But usually it would be better to have function prototypes before <code>main()</code> and  (usually) even better to put the prototypes in a separate header file - that way it'd be easier to look straight into the main program without being bother about other function details.</p>
",10
41906037,41906012,3,"<p>Here is the prototype of printf function:</p>

<pre><code>int printf(const char * restrict format, ...);
</code></pre>

<p>And look what you are typing:</p>

<pre><code>int GlobalVariable=0;
printf(GlobalVariable);
</code></pre>
",1
43958836,43958519,0,"<p>like this</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void){
    int n[100], i, j;
    char x[100];

    do {
        for(i = 0; i &lt; 100; ++i){
            int ch;
            while((ch = getchar()) != EOF &amp;&amp; ch != '\n'){//check newline
                if(ch == '-' || '0' &lt;= ch &amp;&amp; ch &lt;= '9'){
                    ungetc(ch, stdin);//back to stream a character
                    break;
                }
            }
            if(ch == EOF || ch == '\n')
                break;
            if(2 != scanf(""%d %c"", &amp;n[i], &amp;x[i])){
                fprintf(stderr, ""invalid format.\n"");
                i = 0;//End the outer do-while loop
                break;
            }
        }
        //print
        for(j = 0; j &lt; i; ++j){
            printf(""(%d, %c)"", n[j], x[j]);
        }
        printf(""\n"");
    } while(i != 0);//End with empty line
}
</code></pre>

<hr>

<pre><code>#include &lt;stdio.h&gt;

#define DATA_MAX_LEN 100

int main(void){
    int n[DATA_MAX_LEN], i, len, loop_end;
    char x[DATA_MAX_LEN], newline[2], ch;

    while(scanf(""%1[\n]"", newline) != 1){//End with empty line(only newline), Need EOF check
        for(loop_end = len = i = 0; i &lt; DATA_MAX_LEN &amp;&amp; !loop_end; ++i){
            //format: integer character[space|newline]
            if(scanf(""%d %c%c"", &amp;n[i], &amp;x[i], &amp;ch) != 3)
                loop_end = printf(""invalid format.\n"");
            else if(ch == '\n')
                loop_end = len = ++i;
            else if(ch != ' ')
                loop_end = printf(""invalid format.\n"");
        }
        for(i = 0; i &lt; len; ++i){
            printf(""%d %c "", n[i], x[i]);
        }
        printf(""\n"");
    }
}
</code></pre>
",2
43958873,43958519,0,"<p><a href=""http://c-faq.com/stdio/scanfprobs.html"" rel=""nofollow noreferrer""><code>scanf</code> and <code>fscanf</code> have many problems</a> so it's best to avoid them.</p>

<p>The general pattern for dealing with input is to create a large input buffer, and then process that into smaller chunks.</p>

<pre><code>char line[4096];
fgets( line, sizeof(line), stdin );
</code></pre>

<p>Since <code>line</code> is reused it's ok to make it large enough to hold any reasonable input.</p>

<hr>

<p>Now that you've read a line into memory, it's a string of known size to process as you like. <code>sscanf</code> (scanf on a string) doesn't have most of the problems of <code>scanf</code>, but it's also not suited to moving through a string. One approach is to split the string into tokens on whitespace with <a href=""http://www.tutorialspoint.com/c_standard_library/c_function_strtok.htm"" rel=""nofollow noreferrer""><code>strtok</code></a>, and process them alternately as letters and numbers.</p>

<pre><code>const char sep[] = "" \t\n"";
bool expect_letter = false;
for(
    char *token = strtok( line, sep );
    token != NULL;
    token = strtok( NULL, sep )
) {
    if( expect_letter ) {
        printf(""Letter %s\n"", token);
        expect_letter = false;
    }
    else {
        printf(""Number %s\n"", token);
        expect_letter = true;
    }    
}
</code></pre>

<hr>

<p>If you want to store them in an array, it's bad practice to allocate what you hope is enough memory. You'll have to use an array that grows as needed. C does not have these built in. You can write your own, and it's a good exercise, but it's easy to get wrong. For production <a href=""https://developer.gnome.org/glib/stable/glib-Arrays.html"" rel=""nofollow noreferrer"">use one from a library such as Glib</a>.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;glib.h&gt;

int main() {
    // Read a single line of input into a buffer.
    char line[4096];
    fgets( line, sizeof(line), stdin );

    // Create arrays to hold letters and numbers, these will grow as needed.
    GArray *numbers = g_array_new( FALSE, TRUE, sizeof(int) );
    GArray *letters = g_array_new( FALSE, TRUE, sizeof(char) );

    // Split the string on whitespace into tokens.
    const char sep[] = "" \t\n"";
    gboolean expect_letter = FALSE;
    for(
        char *token = strtok( line, sep );
        token != NULL;
        token = strtok( NULL, sep )
    ) {
        if( expect_letter ) {
            // Need an error check to ensure that `token` is a single character.
            g_array_append_val( letters, token[0] );
            expect_letter = FALSE;
        }
        else {
            // strtol is a better choice, it has error checking
            int num = atoi(token);
            g_array_append_val( numbers, num );
            expect_letter = TRUE;
        }
    }

    // Print the numbers and letters.
    for( guint i = 0; i &lt; letters-&gt;len; i++ ) {
        printf(
            ""%d%c\n"",
            g_array_index( numbers, int, i ),
            g_array_index( letters, char, i )
        );
    }
}
</code></pre>

<p>Note that GLib provides its own boolean, so I switched to that instead of stdbool to keep things consistent.</p>

<p>As noted in the comments, this does not include checks that the token is what you expect. It's also possible to have a number with no letter, so checking that <code>letters</code> and <code>numbers</code> are the same size would be good. Or you can make a struct to hold the letter/number pairs and have a single list of those structs.</p>
",0
41923299,41923212,3,"<p>The only way for the loop to terminate is if both <code>a!=0</code> and <code>a!=1</code> are false. Or in other words: it can only end when <code>a == 0</code> and <code>a == 1</code> at the same time. That is of course impossible, so the loop never terminates.</p>

<p>If you want to loop to terminate when the user inputs <code>1</code> or <code>0</code>, then you need a logical and operator there:</p>

<pre><code>do 
{
    puts(""Give 1 or 0 for input:"");
    scanf(""%d"",&amp;a); 
} while(a!=0 &amp;&amp; a!=1);
</code></pre>

<p>Aside from that, you really must check the return value of <code>scanf</code>, and purge the input stream in case of failure. If you input a character, then <code>scanf</code> will signify it failed, but leave the character in the input stream. The subsequent iterations will just get stuck on trying to read that character.</p>

<p>One way to do so is with <code>scanf</code> itself and the <code>%*s</code> format specifier.</p>

<pre><code>do 
{
    puts(""Give 1 or 0 for input:"");
    int read_res = scanf("" %d"",&amp;a); 
    if (read_res != 1)
      scanf(""%*s"");
} while(a != 0 &amp;&amp; a != 1);
</code></pre>

<p>The asterisk in the format string means <code>scanf</code> will still match any non white-space character and purge them from the stream, but will not attempt to assign them into anything (so no extra parameter is required). I also added a leading white-space to <code>%d</code> in order to disregard any leading white-spaces before the number.</p>
",2
42607573,42607535,1,"<pre><code>srand(time(NULL));
for(i=0;i&lt;9;i++)
{
    temp=rand()%9;
    for(j=0;j&lt;=i;j++)
    {
        if(temp==randarr[j])
        {
           break;
        }
    }
    if(j &gt; i) 
        randarr[i]=temp;
    else 
      i--;
}
</code></pre>
",0
42607582,42607535,7,"<p>You don't want to generate every number randomly. You want to shuffle the numbers from 0 to 8 in some random order.</p>

<p>A far simpler approach (that also eliminates the use of <code>goto</code>) is to start from a sorted array and pick an index to swap with randomly each iteration.</p>

<pre><code>srand(time(NULL));
int randarr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8};
for(int i = 0; i &lt; 9; ++i)
{
    int swap_idx = rand() % 9;
    int temp = randarr[swap_idx];
    randarr[swap_idx] = randarr[i];
    randarr[i] = temp;
}
</code></pre>

<hr>

<p>As noted by <strong>HolyBlackCat</strong>, the naive approach tends to give a non-uniform distribution of the various permutations. If that is a concern for you, an improvement is possible in the form of the <a href=""http://www.i-programmer.info/programming/theory/2744-how-not-to-shuffle-the-kunth-fisher-yates-algorithm.html"" rel=""noreferrer"">Fisher-Yates (or Knuth) shuffle</a></p>

<pre><code>srand(time(NULL));
int randarr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8};
for(int i = 0; i &lt; 9; ++i)
{
    int swap_idx = i + rand() % (9 - i);
    int temp = randarr[swap_idx];
    randarr[swap_idx] = randarr[i];
    randarr[i] = temp;
}
</code></pre>
",3
42607620,42607535,0,"<pre><code>srand(time(NULL));
i = 0;
while(i &lt; 9)
{
    temp = rand() % 9;
    int doesExist = 0;
    for(j = 0; j &lt;= i; j++)
    {
        if(temp == randarr[j])
        {
            doesExist = 1;
            break;
        }
    }

    if (doesExist == 0)
    {
        randarr[i] = temp;
        i++;
    }
    //printf(""%d "",randarr[i]);
}
</code></pre>
",1
42607652,42607535,2,"<p>As noted in the other answer, this is a really terrible way to randomly select the numbers 0-8.  You should randomly shuffle them.</p>

<p>However, if you find yourself with a similar problem that seems to require a <code>goto</code>, you can always remove them by setting a flag.  So something like:</p>

<pre><code>srand(time(NULL)); // Make sure you only execute this *ONCE* per program.
                   // Do not put it inside a function called repeatedly, or a loop.

for(i=0;i&lt;9;) {
    int temp=rand()%9;
    bool matched = false;
    for(j=0;j&lt;=i;j++) {
        if(temp==randarr[j]) {
            matched = true;
            break;
        }
    }
    if (! matched) {
        randarr[i]=temp;
        i++;
    }
}
</code></pre>

<p>It is a matter of taste whether this is easier or more difficult to read than the corresponding code with <code>goto</code>.  Personally, I am very happy using code like</p>

<pre><code>     // acquire resources 
     ...

     // do work
     ret = function(...);
     if (ret) goto error:
     ....

     // release resources
 error:
     ....
     return ret;
</code></pre>

<p>But I would avoid jumping <em>backwards</em> (as your original code did).</p>
",2
42610546,42607535,1,"<ul>
<li>The condition in the inner loop should be <code>j &lt; i</code> , randarr[i] is not yet assigned</li>
<li>No need for indicator variables, you can detect the breaking out of the inner loop by <code>j != i</code> after the inner loop.</li>
</ul>

<hr>

<pre><code>for(i=0; i &lt; 9;) {
    int temp=urand(9);  /* to be supplied */
    for(j=0; j &lt; i; j++ ) { /* Note j&lt; i, *NOT* j&lt;= i */
        if(temp==randarr[j]) break;
        }
    if ( j != i) continue; /* inner loop ended prematurely */
    randarr[i]=temp;
    i++;
    }
}
</code></pre>

<hr>

<p>BTW: there isno need for the temp variable:</p>

<pre><code>for(i=0; i &lt; 9; ) {
    randarr[i] = urand(9);  
    for(j=0; j &lt; i; j++ ) { 
        if(randarr[j] == randarr[i]) break;
        }
    if (j != i) continue; /* inner loop ended prematurely */
    i++;
    }
}
</code></pre>
",0
41929688,41929598,2,"<pre><code>printf(""Please give the charge (Coulombs) and voltage (Volts) for Capacitor 3: \n"");
scanf(""%lf%lf"",&amp;serCaps.c2.q, &amp;serCaps.c3.v);
//                      ==             ==             Oops
</code></pre>

<p>Copying and pasting code doesn't work. If you find yourself doing it, you are doing it wrong.</p>
",0
40548235,40547356,0,"<p>For double use specifier  <code>%l(ell)f</code> not <code>%1(one)f</code> in scanf.</p>

<p><em>Note that</em> this is one place that <code>printf</code> format strings differ substantially from <code>scanf</code> (and fscanf, etc.) format strings. For output, you're passing a value, which will be promoted from <code>float</code> to <code>double</code> when passed as a variadic parameter. For input you're passing a <code>pointer</code>, which is not promoted, so you have to tell <code>scanf</code> whether you want to read a <code>float</code> or a <code>double</code>, <strong>so for <code>scanf</code>, <code>%f</code> means you want to read a <code>float</code> and <code>%lf</code> means you want to read a <code>double</code>.</strong></p>
",2
45762683,45761471,4,"<p>Your <code>check</code> function has numerous problems:</p>

<pre><code>int check(int a,int n ,int k ){
</code></pre>

<p>Your prototype does not match the one in the assignment - you're only supposed to take 2 arguments, neither of which is the sequence of values you're checking against.  Somehow, someway, you are supposed to access that sequence from within the body of the function, either by referencing a global array (<em>bad</em>), or by reading the input sequence from within the body of the function (slightly less bad, and probably the intent of the exercise<sup>1</sup>).      </p>

<pre><code>  int f;           
   int value;      
</code></pre>

<p><code>auto</code> variables are not implicitly initialized in a declaration - their initial value is <em>indeterminate</em> (it <em>may</em> be <code>0</code>, it <em>may</em> be a trap representation, it <em>may</em> be a valid non-zero integer value).  This will cause problems later.</p>

<pre><code>   int counter=0;
    counter++;
</code></pre>

<p>I think I know what you're trying to go for here, and it won't work as written<sup>2</sup> - <code>counter</code> only exists for the lifetime of the function.  Each time you call <code>check</code>, a <em>new</em> instance of <code>counter</code> is created and initialized to <code>0</code>.  It won't remember the value stored in it from a previous call.  </p>

<pre><code>  if (a==n)
  {
    f++;
</code></pre>

<p><code>f</code> isn't guaranteed to be <code>0</code> at this point (or any other specific value).  It <em>could</em> be <code>0</code>, or it could be any non-zero value, or even a <em>trap representation</em> (a bit pattern that does not correspond to a valid integer value).  </p>

<pre><code>  }
  if(f==k)
  {
    value= counter;
  }
 return value;
}
</code></pre>

<p>At this point, <code>counter</code> is only ever going to be <code>1</code> - you initialize it to <code>0</code> at function entry and immediately increment it, then you <em>never touch it again</em>.  So <code>value</code> is only ever going to be <em>indeterminate</em> or <code>1</code>.  </p>

<p>So, how should you proceed from here <em>and</em> satisfy the requirements of the assignment?</p>

<p>The less bad option is to read the sequence from within the <code>check</code> (or <code>find</code>) function, although that's still pretty bad (again, I/O should be a separate operation, and we're assuming all input comes through <code>stdin</code>).  </p>

<pre><code>int find( int n, int k )
{
  int next; // next value in the sequence
  ... // additional items for index, number of matches, etc.

  while ( scanf( ""%d"", &amp;next ) == 1 &amp;&amp; next != -1 )
  {
     // update index, does next match n, is it the k'th match, etc.
  }
  ...
}
</code></pre>

<p><code>scanf</code> is a poor tool for interactive input, but at this point is the simpler approach.<br>
<hr>
<sup></p>

<ol>
<li>Which, honestly, isn't any better than keeping a global array.  I/O should be factored out from computation whenever possible, and if a function *is* required to read from an input stream, that stream should be specified as a parameter to the function - you shouldn't force your code to assume all input comes through <code>stdin</code>.  
<li><code>counter</code> would need to be declared <code>static</code> for it to retain its value from call to call.   
</ol>

<p></sup></p>
",0
45764502,45761471,1,"<p>My solution is totally extension of what John Bode said above and as John Bode said, you are using more parameters than the preferred. You should stick to only 2 parameters. And as you have two parameters n(for search element) and K(k th occurrence) you cant pass an sequential array to that function, So you should start reading(scanning) the sequence inside the find().</p>

<p>As the program clearly says it terminates with -1. You can use this to end the loop in terminating the find function.
Scan function returns true as long as it reads. even for -1 it returns true so you should use the value!=-1. And inside the loop you can use your logic of matching and finding the index number.</p>

<pre><code>int find(int n, int k){
   int next;
   int match=0;
   int  index=0; //for parsing the sequence
   while( scanf(""%d"", &amp;next) ==1 &amp;&amp; next!=-1){
       if(next == n){
           match++;
           if(match==k)
              return index;
        }
        index++; //move the index
    }
    return -1;
 }
</code></pre>
",0
44328901,44328780,1,"<p>You have a semi color extra in every if condition</p>

<pre><code>if (sex == 'm' &amp;&amp; age &lt;= 55);
{
    printf(""Olet mies parhaassa i?ss?!"");
}
if (age &gt;= 56 &amp;&amp; sex == 'm');
{
    printf(""Olet viisas mies!"");
}
</code></pre>

<p>so your messages will be printed no matter what you give as input</p>

<p>Do remove those ; and use an if else condition instead:</p>

<pre><code>if (sex == 'm' &amp;&amp; age &lt;= 55)
{
    printf(""Olet mies parhaassa i?ss?!"");
}
else if (age &gt;= 56 &amp;&amp; sex == 'm')
{
    printf(""Olet viisas mies!"");
}
</code></pre>
",0
44328911,44328780,1,"<p><code>if (sex == 'm' &amp;&amp; age &lt;= 55);</code><br>
The <code>;</code> after <code>if()</code> makes a blank statement for <code>if()</code>. Thus the statement <code>printf()</code> is not inside <code>if()</code></p>
",0
44329038,44328780,1,"<p>You just need to remove ; from the if statements. Rest is fine. </p>
",0
44334662,44328780,0,"<p>To clarify the issue, if after an <code>if</code> you don't use brackets, then only one line of code will be inside its block. And as lines end with <code>;</code>, by just placing a <code>;</code> you are placing an empty line there. Like this:</p>

<pre><code>if (condition)
    ;
next line....
</code></pre>

<p>Brackets are optional for single line if blocks, but mandatory if there are more lines. For example:</p>

<pre><code>if (condition)
    something;
else if (condition2)
{
   something_else;
}
else if (condition3)
{
   something_else;
   something_else;
}
</code></pre>

<p>Besides this, you can avoid checking for <code>'m'</code> twice by doing this:</p>

<pre><code>if (sex == 'm')
{
    if (age &lt;= 55)
    {
        printf(""Olet mies parhaassa i?ss?!"");
    }
    else if (age &gt;= 56)
    {
        printf(""Olet viisas mies!"");
    }
}
</code></pre>
",0
45051635,44529617,3,"<p>String literals are always allocated statically and program can access anytime, </p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>char* a = NULL;
{
    char* b = ""stackoverflow"";
    a = b;
}

printf(a);</code></pre>
</div>
</div>
</p>

<p>Here memory to string literal <code>""stackoverflow""</code> is allocated by compiler same as it allocate memory to <code>int</code>/<code>char</code> variables or pointers. </p>

<p>Difference is that string literal are places in READONLY section/segment.
Variable <code>b</code> is allocated at stack but it is holding memory address of read only section/segment.</p>

<p>In the code var <code>b</code> has an address of string literal. Even when <code>b</code> looses its scope the memory for string literal will always be allocated. </p>

<p>Note: Memory allocated to string literals is part of binary and will be removed once the program is unloaded.</p>

<p>Refer ELF binary specification to understand in more details.</p>
",0
45064878,44529617,3,"<p>The code doesn't generate any error because you are simply assigning character pointer <code>b</code> to another character pointer <code>a</code> and that is perfectly fine. </p>

<p>In C, You can assign a pointer reference to another pointer. here actually the string ""stackoverflow"" is used as a literal and the base address location of that string will be assign to <code>a</code> variable.</p>

<p>Though you are out of scope for variable <code>b</code> but still the assignment had been done with the <code>a</code> pointer. So it will print the result without any error.</p>
",0
45068272,44529617,2,"<p>I think that, as a proof of previous answers, it is good to take a look at what really sits inside your code. People already mentioned that string literals lay inside .text section. So, they (literals) are simply, always, there. You can easily find this for the code</p>

<pre><code>#include &lt;string.h&gt;

int main() {
  char* a = 0;
  {
    char* b = ""stackoverflow"";
    a = c;
  }
  printf(""%s\n"", a);
}
</code></pre>

<p>using following command</p>

<pre><code>&gt; cc -S main.c
</code></pre>

<p>inside main.s you will find, at the very bottom</p>

<pre><code>...
...
...
        .section        __TEXT,__cstring,cstring_literals
L_.str:                                 ## @.str
        .asciz  ""stackoverflow""

L_.str.1:                               ## @.str.1
        .asciz  ""%s\n""
</code></pre>

<p>You can read more about assembler sections (for example) here: <a href=""https://docs.oracle.com/cd/E19455-01/806-3773/elf-3/index.html"" rel=""nofollow noreferrer"">https://docs.oracle.com/cd/E19455-01/806-3773/elf-3/index.html</a></p>

<p>And here you can find very well prepared coverage of Mach-O executables:
<a href=""https://www.objc.io/issues/6-build-tools/mach-o-executables/"" rel=""nofollow noreferrer"">https://www.objc.io/issues/6-build-tools/mach-o-executables/</a></p>
",1
41650890,41650878,2,"<p>The behaviour of the first <code>printf</code> is undefined due to a mismatched formatter.</p>

<p>In many respects, your compiler is being kind to you.</p>

<p>Don't do that!</p>
",0
41651049,41650878,-1,"<p>If you want to print out an address of a variable, use %x or %p as formatter.</p>
",2
41664531,41664377,1,"<p>If the input buffer contains non-digit characters and you use <code>scanf()</code> rith <code>%d</code> to read input, the input will fail and the non-digit characters will remain buffered, only for the subsequent <code>scanf()</code> to fail because nothing has changed.</p>

<p>Solutions are legion; here's one:</p>

<pre><code>while( scanf(""%d"",&amp;choice_after_execution) != 1 )
{
    while( getchar() != '\n' ) ; // read buffer until end of line
}
</code></pre>

<p>An alternative is to read an entire line of input using <code>fgets()</code> and parse it using <code>sscanf()</code>.</p>

<p>I strongly suggest that however you do it, you wrap the solution in a function for reuse (so you only have to solve the problem once):</p>

<pre><code>int getDecimalInput()
{
    int input = 0 ;
    while( scanf(""%d"",&amp;input) != 1 )
    {
        while( getchar() != '\n' ) ; // read buffer until end of line
    }

    return input ;
}
</code></pre>
",0
41905779,41905381,0,"<p>The are two things in the code that cause it to ignore the user input.</p>

<p>First, the <code>getUserChoice</code> function returns a value, but <code>main</code> doesn't store or use the return value. The function call should look like this:</p>

<pre><code>number = getUserChoice();
</code></pre>

<p>Second, a single equal sign <code>if(number = 1)</code> acts as an assignment. It sets <code>number</code> to the value <code>1</code>. To compare <code>number</code> with <code>1</code>, use the equality operator, e.g.</p>

<pre><code>if ( number == 1 )
</code></pre>

<p>Note that any decent compiler will generate a warning when you mistakenly put an assignment inside an <code>if</code> statement. You should make sure that you enable all warnings (use <code>-Wall</code> with gcc or clang, <code>/W4</code> with microsoft), and fix all of the warnings. If you ignore compiler warnings, you'll get nowhere fast.</p>

<p>There are other problems in your code, but those are the two problems that are causing the user input to be ignored.</p>
",0
41905830,41905381,1,"<p>That looks a lot like homework and you didn't seem to make much effort on finding the issues, but here we go.. There are several flaws on the code:</p>

<h3>1) Ignoring return values:</h3>

<p>Some of your functions, <code>getUserChoice</code> and <code>getShift</code>, are supposed to return a value but those values are completely ignored in the code. You are not assigning it to any local variables and they are not modifying anything outside their scope, so whatever value is being returned is getting lost.</p>

<p>The code:</p>

<pre><code>if(number = 1){
    getShift();
}
</code></pre>

<p>Should be:</p>

<pre><code>if(number == 1){
    shift = getShift();
}
</code></pre>

<p>Which brings me to another big mistake, reason of many headaches on C when it happens unintentionally:</p>

<h3>2) Mistakenly writing the assignment operator '=' where a comparison operator '==' is required:</h3>

<p>The assignment operator returns a value: the left operand value after assignment. So the expression <code>if(number = 1)</code> is valid and will evaluate to true every time, since the returning value of the assignment is always 1. <code>if(number == 1)</code> however, will only evaluate to true when <code>number</code> is equal to 1. I find it useful to make comparisons ""Yoda-Style"", like <code>if(1 == number)</code> to avoid those kind of mistakes (that can easily happen on a typo). They are hard to track, since the code is valid, but the behavior is not the expected. Using the ""Yoda-Style"" comparison, you would get a compiler error if you mistyped <code>if(1 = number)</code>, since that's an invalid assignment.</p>

<h3>3) Not properly filtering the user input:</h3>

<p>On the function <code>getUserChoice</code> you have the following conditional statement to check if the input is valid (when invalid it defaults to the ""Quit"" option):</p>

<pre><code>if(decision == 0 || decision &gt;= 4)
{
    return 0;
}
</code></pre>

<p>However, since decision is a <code>signed int</code>, negative values are valid. You don't account for those. The following addresses that:</p>

<pre><code>if(decision &lt;= 0 || decision &gt;= 4)
{
    return 0;
}
</code></pre>

<h3>4) <code>getShift</code> doesn't return the shift value:</h3>

<p>You used <code>scanf</code> on the <code>getShift</code> function to get a shift value, but returned 0. You should return the <code>key</code> value instead.</p>

<h3>5) Unused variable at <code>getString</code> + Wrong size argument on <code>fgets</code>:</h3>

<p>You declared an array of 0's on <code>getString</code> which serves no purpose on it. Also, from <code>fgets</code> man page:</p>

<blockquote>
  <p>fgets()  reads in at most <strong>one less than size</strong> characters from stream and
         stores them into the buffer pointed to by s.  Reading  stops  after  an
         EOF  or a newline.  If a newline is read, it is stored into the buffer.
         A terminating null byte ('\0') is stored after the  last  character  in
         the buffer.</p>
</blockquote>

<p>So you don't really need to subtract 1 from SIZE, since it will already account for the null character.</p>

<h3>6) Not clearing the <code>stdin</code> before calling <code>fgets</code>:</h3>

<p>After the call to <code>scanf(""%d"",...);</code>, you will have a hanging newline character in your <code>stdin</code>. That's because the format string parsed to <code>scanf</code> there only instructs it to read any number of decimal digits, not including the newline that follows those.</p>

<p>That hanging newline would cause your <code>fgets</code> to quit before getting any user input. You need to clear the <code>stdin</code> by reading the hanging characters from a previous <code>scanf</code> call. In the example, this is being done by this loop:</p>

<pre><code>int c;
while((c = getchar()) != '\n' &amp;&amp; c != EOF){
    //Clearing Stdin
}
</code></pre>

<p>An alternative is to use:</p>

<pre><code>scanf(""%*[^\n]""); scanf(""%*c""); //Consume all characters up to \n (if present) then consume exactly one char ('\n' itself)
</code></pre>

<h3>7) Not using a loop in main to prompt the user repeatedly:</h3>

<p>You only prompt the user once, do what is asked and quit, instead of asking the user repeatedly for options until he asks to quit.</p>

<h3>8) Unnecessary <code>return</code> statements on the end of <code>void</code> returning functions:</h3>

<p><code>void</code> return functions will return when they reach their end, so there is no need to add a <code>return</code> statement unless you are returning before the end of the function body.</p>

<p>The code below is edited to fix the mentioned issues:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#define SIZE 500
int getUserChoice()
{
    int decision = 0;

    printf(""-------------------------------\n"");
    printf(""| 1) Change Shift (default 3) |\n"");
    printf(""| 2) Encrypt a message        |\n"");
    printf(""| 3) Decrypt a message        |\n"");
    printf(""| 4) Quit                     |\n"");
    printf(""-------------------------------\n"");
    printf(""Option: "");
    scanf(""%d"", &amp;decision);
    int c;
    while((c = getchar()) != '\n' &amp;&amp; c != EOF){
        //Clearing Stdin
    }
    if(decision &lt;= 0 || decision &gt;= 4)
    {
        return 0;
    }

    return decision;
}

int getShift()
{
    int key = 3;
    printf(""Enter new shift value: "");
    scanf(""%d"", &amp;key);
    int c;
    while((c = getchar()) != '\n' &amp;&amp; c != EOF){
        //Clearing Stdin
    }
    return key;
}
void getString(char *buf)
{
    fgets(buf, SIZE, stdin);
    return;
}
void encrypt(char *buf, int shift)
{
    int i = 0;
    for(i = 0; i &lt;= (strlen(buf)-1);++i)
    {
        buf[i] = buf[i] + shift;
    }
    return;
}
void decrypt(char *buf, int shift)
{
    int i = 0;
    for(i = 0; i &lt;= (strlen(buf)-1); ++i)
    {
        buf[i] = buf[i] - shift;
    }
    return;
}
int main()
{
    char userStr[SIZE];
    int shift = 3;

    while(1){
        int number = getUserChoice();
        if(number == 1)
        {
            shift = getShift();

        }
        if (number == 2)
        {
            getString(userStr);
            printf(""Message: %s\n"", userStr);
            encrypt(userStr, shift);
            printf(""Shifted Message: %s\n"", userStr);
        }
        if (number == 3)
        {
            getString(userStr);
            printf(""Shifted Message: %s\n"", userStr);
            decrypt(userStr, shift);
            printf(""Message: %s\n"", userStr);
        }
        if (number == 0){
            break;
        }
    }
    return 0;
}
</code></pre>
",15
41664081,41663575,0,"<p>We, beginners, should help each other.:)</p>

<p>Here you are. The code is written in C++. So you need to investigate it and rewrite it in C yourself.</p>

<pre><code>#include &lt;iostream&gt;

int main() 
{
    while ( true )
    {
        std::cout &lt;&lt; ""Input the number of elements : "";

        unsigned int n;

        if ( not ( std::cin &gt;&gt; n ) or ( n == 0 ) ) break;

        std::cout &lt;&lt; ""Input the size of each element : "";

        unsigned int m;

        if ( not ( std::cin &gt;&gt; m ) or ( m == 0 ) ) break;

        std::cout &lt;&lt; '\n';

        for ( unsigned int i = 0; i &lt; m + 2; i++  )
        {
            char c1 = i == 0 || i == m + 1 ? '+' : '|';
            char c2 = i == 0 || i == m + 1 ? '-' : ' ';

            for ( unsigned int j = 0; j &lt; n + m * ( n - 1 ); j++ )
            {
                std::cout &lt;&lt; ( j % (m + 1) == 0 ? c1 : c2 );  
            }
            std::cout &lt;&lt; '\n';
        }

        std::cout &lt;&lt; std::endl;
    }

    return 0;
}
</code></pre>

<p>The program output might look the following way</p>

<pre><code>Input the number of elements : 10
Input the size of each element : 3

+---+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |   |
|   |   |   |   |   |   |   |   |   |
|   |   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+---+

Input the number of elements : 0
</code></pre>
",0
41922543,41922230,2,"<p>The initial comments hit the nail on the head here. You need to <em>loop</em> over new input multiple times. This can be done fairly easily.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main(void)
{
    char terminal[100];

    printf(""Enter cmds: "");

    // this expression will return zero on invalid input, exiting the loop
    while (scanf(""%99s"", terminal) == 1) {  
        // your if statement and other code you want to repeat go here.
    }
}
</code></pre>

<p>To better encapsulate this kind of behaviour, defining some sort of function that compares strings and returns an element of an enum is a very common practice, but not required in this question.</p>
",0
44703681,44703384,0,"<p>Not really. C function pointers are an address plus a prototype which describes the arguments as they are (in the notional machine) pushed onto the stack. You can't switch from one prototype to another easily.</p>

<p>What you can do is build your own dynamic resolution at run time on top of C function pointers. Another trick is to always pass a void * to a function pointer which gives it context. The function that calls the function pointer never examines this void *, just passes it through. But you can then cast to your own structure, and potentially switch on a value somewhere to call one of a list of possible functions.</p>
",0
41684705,41684035,0,"<blockquote>
  <p>I was thinking maybe finding the max and min X and Y could work but I didn't get further than that.</p>
</blockquote>

<p>This sounds about right for me and was the first thing that I thought when reading that problem statement.</p>

<p><a href=""https://i.stack.imgur.com/apc4U.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/apc4U.png"" alt=""enter image description here""></a></p>

<p>As for the 2nd quadrilateral maybe you could do something like trying to find a bounding rectangle with tilted axis instead of axis that are parellel to the X and Y axis. For example, with a tilt of 45 degrees the bounding box would look like this:</p>

<p><a href=""https://i.stack.imgur.com/IsfKY.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/IsfKY.png"" alt=""enter image description here""></a></p>

<blockquote>
  <p>I can not figure out how to connect my points or how to tell the computer which points to connect.</p>
</blockquote>

<p>I'm kind of getting the impression that you are trying to find the <a href=""https://en.wikipedia.org/wiki/Converx_Hull"" rel=""nofollow noreferrer"">Convex Hull</a> of your set of points. That would be a much harder problem than just finding a bounding box. (And it might not be a quadrilateral anyway)</p>

<p><a href=""https://i.stack.imgur.com/OaTUk.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/OaTUk.png"" alt=""enter image description here""></a></p>
",1
44724329,44724260,2,"<p>The second <code>%d</code> is not a <code>printf()</code> specifier, it's the <code>%</code> modulo division operator and the <code>int</code> variable <code>d</code> which has a value of <code>1</code>, what is the difference? they are not alike at all.</p>

<p>The second problem, is that you are casting a pointer to <code>int</code>, which is not well defined.</p>
",0
44724590,44724260,3,"<p>Let's start with the second example:</p>

<pre><code>int d=1;
printf(""%d"",(int)""printf("");
</code></pre>

<p><code>""printf(""</code> here is a string constant, only containing the name of a C function in an attempt to confuse you. A string constant has the type <code>char *</code>, it's a pointer to the first character. The <code>(int)</code> converts the pointer to an integer. While this is <em>implementation defined</em>, you will get <em>some</em> value that is related to the address at which the string <code>""printf(""</code> is actually stored.</p>

<p>So you print a number here that happens to be the result of a pointer converted to <code>int</code>.</p>

<p>Moving on:</p>

<pre><code>int d=1;
printf(""%d"",(int)""printf("" % d);
</code></pre>

<p>There's only one change, and I added spaces to make it obvious: The <code>int</code> you get from your pointer conversion is taken <em>modulo <code>d</code></em>, so the result is the remainder of the integer division by <code>d</code>. As <code>d</code> is one, there will be never any remainder, any number is divisable by 1 without a remainder. Therefore the result is <code>0</code>.</p>
",0
44724661,44724260,4,"<p>This bonus question is a trick question:</p>

<p><code>printf(""%d"",(int)""printf(""%d);</code> is parsed as</p>

<pre><code>printf(
       ""%d"",
       ((int)""printf("") % d
      );
</code></pre>

<p>The address of the string <code>""printf(""</code> is converted to <code>int</code> and the modulus operation is computed.  Since <code>d = 1</code>, the modulus is always <code>0</code>.  Hence <code>printf</code> outputs <code>0</code>.</p>

<p>The second call just prints the address of the string converted to <code>int</code>, something that will vary from one environment to another, it may even vary from one run to another (it does on my Mac)...</p>

<p>As a matter of fact, the conversion may even fail and trigger implementation specific behavior. So the answer really should be <em>implementation defined behavior in both cases.</em></p>

<p>Another question should have been:</p>

<pre><code>int d=1;
printf(""%d"",(int)printf(""%d"", d));
</code></pre>

<p>Which produces <code>11</code>. Can you explain why?</p>

<p>Note that even this last question is tricky: calling <code>printf</code> without a proper prototype, for example if <code>&lt;stdio.h&gt;</code> is not included, has undefined behavior.</p>
",0
44340759,44340584,0,"<p>You need to record the founded highest (as well as lowest).</p>

<pre><code>struct hit
{
    int value,
        day;
};
struct hit highest = {-40; 0}, lowest = {+40; 0};
....
if (high &gt; highest.value)
{
    highest.value = high;
    highest.day = i;
}
...
</code></pre>

<p>Finally you can print founded values:</p>

<pre><code>print(""The highest has been %d on day %d\n"", highest.value, highest.day);
</code></pre>
",2
44340767,44340584,1,"<p>Not different from the comments which arrived while I was typing.</p>

<pre><code>#include &lt;stdio.h&gt;
#define NUMS 3

int main(void) {

    int high;
    int low;
    int highest =-42;
    int highday = -1;
    int lowday  = -1;
    int lowest  = 42;
    int totalhigh=0;
    int totallow=0;
    double average;
    int i;

    printf(""---=== IPC Temperature Analyzer ===---\n"");
    for (i = 0; i &lt; 3; i++)
    {
        printf(""Enter the high value for day %d: "", i + 1);
        scanf(""%d"", &amp;high);
        printf(""Enter the low  value for day %d: "", i + 1);
        scanf(""%d"", &amp;low);
        printf(""\n"");

        totalhigh = high + totalhigh;
        totallow = low + totallow;
        if (high&gt;highest)
        {    highest=high;
             highday=i+1;
        }
        if (low&lt;lowest)
        {   lowest=low;
            lowday=i+1;
        }
    }

    average = (double)(totalhigh + totallow) / 6 ;

    printf(""The average (mean) temperature was:  %.2lf\n"", average);
    printf(""The lowest         temperature was: %3d on day %d\n"", lowest, lowday);
    printf(""The highest        temperature was: %3d on day %d\n"", highest, highday);
    return 0;
}
</code></pre>
",4
44340759,44340584,0,"<p>You need to record the founded highest (as well as lowest).</p>

<pre><code>struct hit
{
    int value,
        day;
};
struct hit highest = {-40; 0}, lowest = {+40; 0};
....
if (high &gt; highest.value)
{
    highest.value = high;
    highest.day = i;
}
...
</code></pre>

<p>Finally you can print founded values:</p>

<pre><code>print(""The highest has been %d on day %d\n"", highest.value, highest.day);
</code></pre>
",2
44340767,44340584,1,"<p>Not different from the comments which arrived while I was typing.</p>

<pre><code>#include &lt;stdio.h&gt;
#define NUMS 3

int main(void) {

    int high;
    int low;
    int highest =-42;
    int highday = -1;
    int lowday  = -1;
    int lowest  = 42;
    int totalhigh=0;
    int totallow=0;
    double average;
    int i;

    printf(""---=== IPC Temperature Analyzer ===---\n"");
    for (i = 0; i &lt; 3; i++)
    {
        printf(""Enter the high value for day %d: "", i + 1);
        scanf(""%d"", &amp;high);
        printf(""Enter the low  value for day %d: "", i + 1);
        scanf(""%d"", &amp;low);
        printf(""\n"");

        totalhigh = high + totalhigh;
        totallow = low + totallow;
        if (high&gt;highest)
        {    highest=high;
             highday=i+1;
        }
        if (low&lt;lowest)
        {   lowest=low;
            lowday=i+1;
        }
    }

    average = (double)(totalhigh + totallow) / 6 ;

    printf(""The average (mean) temperature was:  %.2lf\n"", average);
    printf(""The lowest         temperature was: %3d on day %d\n"", lowest, lowday);
    printf(""The highest        temperature was: %3d on day %d\n"", highest, highday);
    return 0;
}
</code></pre>
",4
42463190,42463012,1,"<p>Change</p>

<pre><code>else
    printf(""Bi-weekly salary must be greater than 0.0!\n"");
    }
}

return 0;
</code></pre>

<p>to</p>

<pre><code>else
    printf(""Bi-weekly salary must be greater than 0.0!\n"");
    }
return 0;
}
</code></pre>

<p>You would see this easily if you would format the code (now it is hard to read).</p>
",1
44343132,44343098,-1,"<p>Use <code>sprintf</code></p>

<pre><code>sprintf (number, ""| %.4d |"", num);
</code></pre>

<p><a href=""https://linux.die.net/man/3/sprintf"" rel=""nofollow noreferrer"">Here</a> the documentation</p>
",2
44343132,44343098,-1,"<p>Use <code>sprintf</code></p>

<pre><code>sprintf (number, ""| %.4d |"", num);
</code></pre>

<p><a href=""https://linux.die.net/man/3/sprintf"" rel=""nofollow noreferrer"">Here</a> the documentation</p>
",2
43199760,43199647,0,"<p><strong>Escape sequences</strong></p>

<p><a href=""https://i.stack.imgur.com/K617O.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/K617O.png"" alt=""enter image description here""></a></p>

<p>Escape sequences are used to represent certain special characters within string literals and character literals.
The above escape sequences are available (extra escape sequences may be provided with implementation-defined semantics):</p>
",0
45100974,44570213,-1,"<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main()
{
char a[100],b[100],c[100],d[100];
gets(a);
gets(b);
gets(c);
gets(d);
if(d[0]&gt;=0 &amp;&amp; d[0]&lt;=64)
printf(""no"");
else if(a[0]==d[0] || b[0]==d[0] || c[0]==d[0])
printf(""yes"");
else
printf(""no"");
}
</code></pre>
",1
44647532,44570213,0,"<pre><code>    #include&lt;stdio.h&gt;
    #include&lt;stdlib.h&gt;
    int main()
    {
       char a[256],b[256],c[256],d[256];

        fgets(a,256,stdin);
        fgets(b,256,stdin);
        fgets(c,256,stdin);
        fgets(d,256,stdin);
        if(d[0]==a[0]||d[0]==b[0]||d[0]==c[0])
        printf(""\nyes"");
        else
        printf(""\nno"");
    }

this will help you pass the string with space test case.
</code></pre>
",0
40579258,40576454,0,"<p>You have a few things that are throwing off your program here.  One issue was already pointed out by @gudok, where you close the <code>fd_toParent[PIPE_INPUT]</code> and then attempt to read from it immediately after:</p>

<pre><code>close( fd_toChild[PIPE_OUTPUT] ); 
close( fd_toParent[PIPE_INPUT] ); 
// just closed on the preceding line
read(fd_toParent[PIPE_INPUT], buff, sizeof(r)); 
</code></pre>

<p>One other issue is in the child-process where you're trying to <code>read</code> in the values to operate on in the calculation:</p>

<pre><code>read(fd_toChild[PIPE_INPUT], buff, sizeof(a)); 
printf(""Child reads value %d from a \n"", a); 
</code></pre>

<p>Here you pass the <code>buff</code> as your <code>read</code> buffer and then you try to operate/print from <code>a</code>.  This leaves <code>a</code> uninitialized, this would explain why you are just getting zero's back out when printing.  Instead you could use the address-of operator <code>&amp;</code> of your coefficient variables:</p>

<pre><code>read(fd_toParent[PIPE_INPUT], &amp;a, sizeof(a));
</code></pre>

<p>This goes for <code>b</code>, <code>c</code>, and <code>x</code> too.</p>

<p>And also when attempting to print out the result in the parent:</p>

<pre><code>read(fd_toParent[PIPE_INPUT], buff, sizeof(r)); 

pid = wait(&amp;status); 

fprintf(stdout, ""Parent received back the result %d.\n"", r); 
printf(""The polynomial evaluates to %d \n"", r); 

close( fd_toParent[PIPE_OUTPUT] );
</code></pre>

<p>The line <code>read(fd_toParent[PIPE_INPUT], buff, sizeof(r));</code> you're passing in <code>buff</code> but printing out <code>printf(The polynomial evaluates to %d \n"", r)</code> you print <code>r</code> which is uninitialized inside of the parent-process.</p>

<p>You also have been enclosing the majority of your logic inside of a <code>while(1)</code> loop.  This won't affect the end result of the program because of the <code>break</code> in the parent-process but if you alter the parent-process loop the repeated calls to <code>close</code> would shutdown all ends of the pipes.</p>

<pre><code>while(1){
    ....
    close( fd_toChild[PIPE_OUTPUT] ); 
    close( fd_toParent[PIPE_INPUT] );
}
</code></pre>

<p>Without the <code>break</code> your pipe won't be of any use.  </p>

<p>I made several edits to show a working version of the code:</p>

<pre><code>#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt; 
#include &lt;unistd.h&gt; 
#include &lt;string.h&gt; 
#include &lt;sys/wait.h&gt; 

#define PIPE_INPUT 0 
#define PIPE_OUTPUT 1 
#define INDENT 20 


void testError(int err, const char * str)
{ 
    if (err &lt; 0) {
        perror(str); 
        exit( EXIT_FAILURE ); 
    }
}

int main(int argc, char *argv[])
{ 
    int fd_toChild[2], fd_toParent[2], buff;
    pid_t pid; 

    testError( pipe(fd_toChild), ""pipe"" ); 
    testError( pipe(fd_toParent), ""pipe"" ); 
    testError( pid = fork(), ""fork"" ); 

    int a, b, c, x, r; 

    if (pid &gt; 0){     
        // this is the parent 

        int status;

        close( fd_toChild[PIPE_INPUT] ); 
        close( fd_toParent[PIPE_OUTPUT] ); 

        printf(""This program will evaluate a polynomial a(x^2) + bx + c. \n""); 
        printf(""Please input an integer value for a: ""); 
        scanf(""%d"", &amp;a); 
        write(fd_toChild[PIPE_OUTPUT], &amp;a, sizeof(a)); 

        printf(""Parent writes value %d to a \n"", a); 
        sleep(1);
        printf(""Please input an integer value for b: ""); 
        scanf(""%d"", &amp;b); 
        write(fd_toChild[PIPE_OUTPUT], &amp;b, sizeof(b)); 
        printf(""Parent writes value %d to b \n"", b); 
        sleep(1);
        printf(""Please input an integer value for c: ""); 
        scanf(""%d"", &amp;c); 
        write(fd_toChild[PIPE_OUTPUT], &amp;c, sizeof(c)); 
        printf(""Parent writes value %d to c \n"", c); 
        sleep(1);
        printf(""Please input an integer value for x: ""); 
        scanf(""%d"", &amp;x); 
        write(fd_toChild[PIPE_OUTPUT], &amp;x, sizeof(x)); 
        printf(""Parent writes value %d to x \n"", x); 
        sleep(1);
        // XXX you close then attempt to read from it
        //close( fd_toParent[PIPE_INPUT] ); 

        read(fd_toParent[PIPE_INPUT], &amp;buff, sizeof(buff)); 

        pid = wait(&amp;status); 
        // XXX Here you are showing the results as your uninitialized variable ""r""
        fprintf(stdout, ""Parent received back the result %d.\n"", buff); 
        printf(""The polynomial evaluates to %d \n"", buff); 

        close( fd_toChild[PIPE_OUTPUT] ); 
        close( fd_toParent[PIPE_OUTPUT] ); 
    } else { 
        // this is child 

        close( fd_toChild[PIPE_OUTPUT] ); 
        close( fd_toParent[PIPE_INPUT] ); 

        read(fd_toChild[PIPE_INPUT], &amp;a, sizeof(a)); 
        printf(""Child reads value %d from a \n"", a); 

        read(fd_toChild[PIPE_INPUT], &amp;b, sizeof(b)); 
        printf(""Child reads value %d from b \n"", b); 

        read(fd_toChild[PIPE_INPUT], &amp;c, sizeof(c)); 
        printf(""Child reads value %d from c \n"", c); 

        read(fd_toChild[PIPE_INPUT], &amp;x, sizeof(x)); 
        printf(""Child reads value %d from x \n"", x); 
        r = a * x * x + b * x + c; 
        printf(""x is %d\n"", x); 
        printf(""r is %d\n"", r); 

        write(fd_toParent[PIPE_OUTPUT], &amp;r, sizeof(r)); 
        fprintf(stdout, ""%*sChild is all done\n"", 0, """"); 

        close( fd_toChild[PIPE_INPUT] ); 
        close( fd_toParent[PIPE_OUTPUT] );
    } 

    return EXIT_SUCCESS; 
}
</code></pre>
",0
38193558,38193334,1,"<pre><code>int num_args = argc - 1;
</code></pre>

<p>Because the argc consists of the actual destination as its first char array (which is *argv[]). So you just subtract 1, eliminating the actual destination of the file you're running, and yup you got your num of args.</p>
",0
40984851,40984831,3,"<p>You are passing a single element and it's not even a valid element, try </p>

<pre><code>decode(enc_message, dec_message, key);
</code></pre>

<p>Also, format your code so it's readable that is really important, and looping to compute the length of the string to use it in another loop is not a very smart thing, print it in a loop like</p>

<pre><code>for (int i = 0 ; enc_message[i] != '\0' ; ++i) ...
</code></pre>

<p>also, don't over use <code>break</code>, just think about the logical condition for the loop, it's the same one where you <code>break</code>.  Code is much more readable if the condition appears in the right place.</p>
",1
40752720,40735276,0,"<p>I am not sure what API you teacher want you to use for <code>reverse</code>:</p>

<ul>
<li>The simplest one would take a <code>Node *</code> and return the new head pointer. You would invoke it from <code>main</code> as <code>head = reverse(head);</code></li>
</ul>

<p>Here is a simple implementation of this approach:</p>

<pre><code>Node *reverse(Node *head) {
    Node *front = head;
    Node *newhead = NULL;
    while (front) {
        Node *back = front-&gt;next;
        front-&gt;next = newhead;
        newhead = front;
        front = back;
    }
    return newhead;
}
</code></pre>

<ul>
<li>An alternative API would have <code>reverse</code> take a pointer to the head pointer, hence a <code>Node **</code>, and update that to point to the reversed list.</li>
</ul>

<p>Here is how it works:</p>

<pre><code>void reverse(Node **headp) {
    Node *front = *headp;
    Node *newhead = NULL;
    while (front) {
        Node *back = front-&gt;next;
        front-&gt;next = newhead;
        newhead = front;
        front = back;
    }
    *headp = newhead;
}
</code></pre>

<p>Note that you do not need nested loops.</p>

<p>Note also that you should not hide pointers behind typedefs, it is bad practice, error prone and creates confusion for both the next reader and the original author.</p>
",0
38870730,38870692,2,"<p><code>;;;;;</code> are empty statements. They are allowed in C.</p>
",3
38870756,38870692,8,"<p>An <em>empty statement</em> is legal in C. Since <code>;</code> is the <em>statement terminator</em>, multiple <code>;</code> are syntactically valid. Sometimes this is even useful: such as the <code>for (;;) {/*code here*/}</code> idiom.</p>

<p>(Although some compilers will warn you in appropriate instances).</p>

<p>Do note that, conceptually at least, the excess <code>;</code> in that line are <strong>not</strong> part of the <code>if</code> block.</p>
",1
38870865,38870692,6,"<p>Your program just has a sequence of empty statements at the end of the <code>main</code> function.  It is parsed as this:</p>

<pre><code>#include &lt;stdio.h&gt;

int main() {
    int a = -1, b = -10, c = 5;

    if (a &gt; b)
        printf(""Hello World"");
    else
        printf(""Get out World"");
    ;
    ;
    ;
    ;
    ;
}
</code></pre>

<p>Note that <code>int main()</code> should be written <code>int main(void)</code> and it should return an <code>int</code> value, for example <code>0</code>.  C99 makes this <code>return 0;</code> implicit, but it is considered bad style and it is indeed less portable to omit it.</p>
",10
38870893,38870692,0,"<p>As we know, semicolon (<code>;</code>) works as a statement terminator. In the Line no.8 the first semicolon terminates the statement under <code>else</code> and the next semicolon terminates the empty statement, and so on.</p>
",0
38870802,38870692,2,"<p>It's a <em>null statement</em> which you have after the printf() statment. Having more than one semi-colons is allowed.</p>

<p><em>C11, ¡ì6.8.3, 4</em></p>

<blockquote>
  <p>A null statement (consisting of just a semicolon) performs no
  operations</p>
</blockquote>
",0
38872716,38870692,3,"<p>Extra semicolons in general are not ""OK"".</p>

<p>For example, changing your code slightly:</p>

<pre><code>#include &lt;stdio.h&gt;

int main() {
    int a = -1, b = -10, c = 5;
    if (a &gt; b)
        printf(""Hello World"");;;;;;
    else
        printf(""Get out World"");
}
</code></pre>

<p>That won't even compile.</p>

<p>Another example, and this one does compile:</p>

<pre><code>   ...

   int done = 0;

   ...

   while ( !done );
   {
       ...

       done = 1;
   }

   ...
</code></pre>
",1
47973692,47971200,0,"<p>The  unary * produces an lvalue as its result. A non-null pointer p always points to an object, so *p is an lvalue. For example:</p>

<pre><code>int a[N];
int *p = a;
...
*p = 3;     // ok
</code></pre>

<p>Although the result is an lvalue, the operand can be an rvalue, as in:</p>

<pre><code>*(p + 1) = 4;    // ok
</code></pre>

<p>Hope this answers your query.</p>
",5
47973838,47971200,0,"<p>From the 1999 C standard, Section 6.3.2.1, para 1 starts with .....</p>

<blockquote>
  <p>An lvalue is an expression with an object type or an incomplete type other than void;</p>
</blockquote>

<p>and then refers to footnote 53, which says</p>

<blockquote>
  <p>The name ¡®¡®lvalue¡¯¡¯ comes originally from the assignment expression <code>E1 = E2</code>, in which the left
  operand <code>E1</code> is required to be a (modifiable) lvalue. It is perhaps better considered as representing an
  object ¡®¡®locator value¡¯¡¯. What is sometimes called ¡®¡®rvalue¡¯¡¯ is in this International Standard described
  as the ¡®¡®value of an expression¡¯¡¯.</p>
  
  <p>An obvious example of an lvalue is an identifier of an object. As a further example, if <code>E</code> is a unary
  expression that is a pointer to an object, <code>*E</code> is an lvalue that designates the object to which <code>E</code> points.</p>
</blockquote>

<p>In n1548 (draft of the 2011 standard), the same para starts with something worded slightly differently, but with essentially the same meaning;</p>

<blockquote>
  <p>An
  lvalue
  is  an  expression  (with  an  object  type  other  than
  void
  )that  potentially
  designates an object;</p>
</blockquote>

<p>This para refers to footnote 64, which is identical in content to footnote 53 from the 1999 C standard.</p>

<p>Bear in mind that footnotes in the standard are not normative - their purpose is to clarify and explain.</p>

<p>To answer the original question, the dereference operator (<code>*p</code>) produces an lvalue.   However, the value of the expression can be used as an rvalue.</p>
",0
44745272,44745184,1,"<p>I think you misunderstood the concept of the function <code>exit(int)</code>. The <code>exit</code> function terminates the current calling process and returns control to the Operating System, which in your case means that it terminates the execution of <code>main</code>. </p>
",4
46636248,46636137,1,"<p>In unix shells such as bash, <code>$$</code> is a variable containing the current process id. Use <code>'$$'</code> or <code>\$\$</code> to prevent shell variable expansion.</p>
",0
42560315,42559994,1,"<p>Change</p>

<pre><code>z=(x^y)+2(x&amp;y);
</code></pre>

<p>to </p>

<pre><code>z=(x^y)+2*(x&amp;y);
</code></pre>

<p>and</p>

<pre><code>z=2(x|y)-(x^y);
</code></pre>

<p>to</p>

<pre><code>z=2*(x|y)-(x^y);
</code></pre>

<p>You need the multiplication operator if multiplication is what you intended.</p>
",0
42560552,42559994,1,"<p>As for what the error means: <code>2(x&amp;y)</code> tells the compiler to call the function <code>2</code>, passing <code>x&amp;y</code> as an argument (just like <code>printf(""hi"")</code> means ""<em>call <code>printf</code> and pass <code>""hi""</code> as an argument</em>"").</p>

<p>But <code>2</code> isn't a function, so you get a type error. Syntactically speaking, whenever you have a value followed by <code>(</code>, that's a function call.</p>
",0
42475473,42475422,2,"<p>You don't want to include 93mydates.c, you want to compile it as a module, so get rid of this line:</p>

<pre><code>#include""9.3mydates.c""
</code></pre>

<p>And then add 9.3mydates.c to your compiler command line or project.</p>
",2
42488872,42475422,2,"<p><code>year</code> is not found because it's not defined. :-)</p>

<pre><code>int promptYear(void)
{
    int year; /* you have to define the variable! */

    printf(""Give me a year buddy: "");
    scanf(""%d"", &amp;year);
    fflush(stdin);  
    return year;    
}   
</code></pre>

<p>By the way: this <strong>must never</strong> show up in production code! Is this a home work assignment?</p>
",2
38865994,38865855,1,"<p>Your second <code>scanf</code> is consuming the <code>'\n'</code> char left into <code>stdin</code> by the <code>dice</code> one</p>

<p>Simply adding a space before format specifier you can consume all chars in stdin before accempting the character inserted by user:</p>

<pre><code>scanf ("" %c"", &amp;ch);
</code></pre>

<p>In a <code>scanf()</code> format, a blank, tab or newline means 'skip white space if there is any to skip'.</p>
",0
38866167,38865855,0,"<pre><code>printf (""dice\n"");
scanf (""%d"", &amp;dice);
</code></pre>

<p>This has left '\n' in the buffer and your second call to scanf reads this '\n' instead of 'n' and continues. You must read remaining '\n' before reading character.</p>

<p>man scanf(3):</p>

<pre><code>   The  format  string  consists  of a sequence of directives which describe how to process the sequence of input characters.  If processing of a directive fails, no
   further input is read, and scanf() returns.  A ""failure"" can be either of the following: input failure, meaning that input characters were unavailable, or  match©\
   ing failure, meaning that the input was inappropriate (see below).

   A directive is one of the following:

   ¡¤      A sequence of white-space characters (space, tab, newline, etc.; see isspace(3)).  This directive matches any amount of white space, including none, in the
          input.

   ¡¤      An ordinary character (i.e., one other than white space or '%').  This character must exactly match the next character of input.

   ¡¤      A conversion specification, which commences with a '%' (percent) character.  A sequence of characters from the input is converted according to this  speci©\
          fication,  and the result is placed in the corresponding pointer argument.  If the next item of input does not match the conversion specification, the con©\
          version fails¡ªthis is a matching failure.
</code></pre>

<p>There are two options.</p>

<pre><code>scanf ("" %c"", &amp;ch);
</code></pre>

<p>or </p>

<pre><code>(void) getchar ();
scanf (""%c"", &amp;ch);
</code></pre>
",0
38865938,38865855,0,"<p>You have to use a space before <code>%c</code></p>

<pre><code>scanf("" %c"", &amp;ch);
</code></pre>
",2
38865944,38865855,0,"<p>changing your scanf will solve all the problems</p>

<pre><code>scanf("" %c"",&amp;ch); //notice space
</code></pre>
",1
38866610,38865855,0,"<p>The biggest problem you have is not accounting for the <code>'\n'</code> left in your <em>input buffer</em> (<code>stdin</code> here) that results from the user pressing <kbd>Enter</kbd> after entering <code>dice</code> as the <code>%c</code> format specifier will happily take the <code>'\n'</code> as the user-input for <code>ch</code>.</p>

<p>The next problem is <code>ch</code> should be and <code>int</code> not <code>char</code> or you will never be able to test/trap <code>EOF</code>.</p>

<p>Further, you fail to validate the <code>return</code> of <code>scanf</code> to confirm any of the conversions are valid.</p>

<p>Given the problems associated with taking user input with <code>scanf</code>, you are better served taking user input with <code>fgets</code> and reading the entire line of user input into a buffer of sufficient size for the input and then parsing your numeric values from the buffer with <code>sscanf</code> (or simply subtracting <code>'0'</code> for a single digit).</p>

<p>Putting those pieces together, you could do something like the following:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define BUFLEN 128

int main () {

    int ch, cash, dice;
    char buf[BUFLEN] = """";
    printf (""cash: "");

    if (!fgets (buf, BUFLEN, stdin)) {  /* read/validate cash */
        fprintf (stderr, ""error: invalid input - cash.\n"");
        return 1;
    }
    if (sscanf (buf, ""%d"", &amp;cash) != 1) { /* parse cash from buf */
        fprintf (stderr, ""error: invalid conversion - cash.\n"");
        return 1;
    }

    if (cash &lt; 1000) {
        printf (""No\n"");
        return 1;
    }

    do {
        ch = 'n';  /* set/reset ch to exit each iteration */

        printf (""dice: "");
        if (!fgets (buf, BUFLEN, stdin)) { /* read/validate dice */
            fprintf (stderr, ""error: invalid input - dice.\n"");
            break;  /* break on EOF */
        }
        /* parse/validate  dice */
        if (sscanf (buf, ""%d"", &amp;dice) != 1 || dice &lt; 1 || dice &gt; 6) {
            fprintf (stderr, ""error: invalid conversion - dice.\n"");
            ch = 'y';   /* set ch to 'y' */
            continue;   /* prompt again, etc */
        }

        if (dice == 1) {
            cash = cash / 2;  /* note: truncated division */
            break;
        }
        cash = (dice * 100) + cash;
        printf (""\nDo you want to continue? (y/n): "");
        if (fgets (buf, BUFLEN, stdin))
            ch = *buf;  /* simply assign first char */
        else
            break;  /* exit loop on EOF */

    } while (ch == 'y');

    printf (""\nwon = %d\n\n"", cash);

    return 0;
}
</code></pre>

<p>(note: tests to validate less than 128 chars entered for each input omitted)</p>

<p><strong>Example Use/Input</strong></p>

<pre><code>$ ./bin/rfmt
cash: 1200
dice: 7
invalid dice.
dice: 5

Do you want to continue? (y/n): y
dice: 2

Do you want to continue? (y/n): y
dice: 6

Do you want to continue? (y/n): n

won = 2500
</code></pre>

<p>Look over all the answer and decide whether you want to go with <code>scanf</code> or <code>fgets/sscanf</code>. Both are doable, you just lose a bit of flexibility when you couple both your read and parse in a single <code>scanf</code> call. Let me know if you have any questions.</p>
",0
45783520,45783468,0,"<p>You are using getch() which will stop the program until you press any key right after the execution of all your program. remove getch(), compile and run the .exe from the source folder file after closing the IDE. </p>
",5
45783602,45783468,0,"<p>Well, I executed the code, without getch() and it worked fine!</p>
",0
42662888,42662655,0,"<pre><code>   int main() {
   int num1, num2, ans;

   printf(""Enter the two numbers : "");
   scanf(""%d %d"", &amp;num1, &amp;num2);

   ans= sum(num1, num2);

   printf(""\nAddition of two number is : "");
   return (0);
}

int sum(int num1, int num2) {
   int num3;
   num3 = num1 + num2;
   return (num3);
}
</code></pre>
",5
47503460,47503441,1,"<blockquote>
  <p>What exactly happens when i send EOF to my kernel.</p>
</blockquote>

<p>The system (MSYS) tells the program that its standard input has reached EOF (end-of-file), and there'll be no more input availablr.</p>

<blockquote>
  <p>Is there a way to send EOF without immediately killing my program?</p>
</blockquote>

<p>No. Sending an EOF never terminates a program immediately. It lets the program continue without reading input anymore. It's your program that terminates itself when it found nothing to read.</p>

<p>The reason you see <code>Stopped</code> is that you didn't send an EOF at all! Oj Unix shells (including MSYS and Cygwin), Ctrl-Z means <strong>Suspend</strong>. You can type <code>fg</code> to bring it to foreground again, then press <strong>Ctrl-D</strong> to send it an EOF.</p>

<p>Note: Ctrl-Z sends EOF only in Windows CMD, and in Windows 10 <a href=""http://proc-x.com/2017/06/ctrlz-does-not-generate-eof-in-windows-10/"" rel=""nofollow noreferrer"">you have to uncheck a box</a>.</p>
",5
46986364,46985704,1,"<p><code>VirtualAlloc</code> has very specific usage. Use <code>malloc</code> instead. Or use <code>VirtualAllocEx</code> if trying to access memory in another process. </p>

<p>Having said that, first you have to put something in <code>lpvAddr</code>. Put either zeros, bytes, or string. Example:</p>

<pre><code>char *jmp_esp = ""abc"";
LPVOID lpvAddr;
lpvAddr = VirtualAlloc(NULL, strlen(jmp_esp)+1, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
strcpy(lpvAddr, jmp_esp);
</code></pre>

<p>Note you have to allocate 1 extra byte for the <strong><code>null-character</code></strong> at the end. </p>

<p>Next problem is <code>full2</code> which is uninitialized pointer. First you have to initialize, then use <code>strcpy</code> to write in to empty string, then use <code>strcat</code> to add another string to a <strong><code>NUL terminated string</code></strong>.</p>

<pre><code>const char *X = ""xyz"";
char *full2 = malloc(strlen(x) + strlen(jmp_esp) + 1);
strcpy(full2 , X);
strcat(full2 , lpvAddr);
</code></pre>

<p>This should end with <code>VirtualFree</code> and <code>free</code> for <code>malloc</code> allocation.</p>
",4
42475765,42475689,2,"<p>You don't need two arguments in method <code>get_population</code>. You only need to pass the <code>year</code> to it and it should return the calculated population value.</p>

<p>Also calling the method and setting it's returned value to a variable also not done properly.</p>

<p>No need of <code>printf</code> in <code>get_population</code> method as it won't be executed coz control will return from the method before it.</p>

<p>Change your code as following.</p>

<pre><code>int get_population (int);

int main (void){
    int year; 
    double population;

    printf(""Enter a year after 1990 &gt;  "");
    scanf(""%d"", &amp;year);

    population = get_population (year);

    printf(""Predicted Gotham City population for %d (in thousands):%f"", year, population);

    return 0;
}
int get_population (int year){
    double population = 52.966 + 2.184* year;
    return population;
}
</code></pre>
",3
42475919,42475689,1,"<p>Some things were already explained in the other answer, this is just a different approach.</p>

<p>Annotated original code:</p>

<pre><code>/*Calculate Gotham's population*/

#include &lt;stdio.h&gt;

//Your population calculation depends on the year only, so you only need one argument
int get_population (int , double );

int main (void){
    int t; 
    double population; //Can a not natural number of people exist? An int is better suited for this

    printf(""Enter a year after 1990 &gt;  "");
    scanf(""%d"", &amp;t);

    //There is no need to cast the return of the function
    //Also a cast to another type would be done by enclosing it with brackets
    //Example: population = (int) get_population(t);
    population = int get_population (t);

    printf(""Predicted Gotham City population for 2015 (in thousands):%f"");

    return 0;
}

int get_population (int t, double P){
    double P = 52.966 + 2.184*t;
    return P;
    //The following code will not be executed, since the function has ended
    printf(""Predicted Gotham City population for 2015 (in thousands):%d"");
}
</code></pre>

<p>Following is how I'd 'fix' your code:</p>

<pre><code>/*Calculate Gotham's population*/

#include &lt;stdio.h&gt;
//Since the function only depends on the year, only 1 argument is needed
int get_population (int);

int main (void){
    //Since a not natural number of people can't exist, using ints
    int year, population;

    printf(""Enter a year after 1990 &gt;  "");
    scanf(""%d"", &amp;year);

    //Calling the function that our code knows returns an int and assigning it to a variable
    population = get_population (year);

    //To use variables in a printf, you'll use the '%' followed by a description( %d for (decimal) int, %c for char, %s for strings,...)
    //And add those variables, in the right order, at the end
    printf(""Predicted Gotham City population for %d (in thousands):%d"", year, population );

    return 0;
}

//Since you only do the same thing every time, you can just return the calculation
int get_population (int year){
    return (52.966 + 2.184*year);
}
</code></pre>

<p>If you understand the changes, maybe try adding some fail-safe tests, maybe output another text if the input year is &lt; 1990.</p>
",2
44343008,44342415,1,"<p>Here is a version that does <strong>not</strong> mix different integer types. All calculations are kept as <code>int</code>. In that way you don't need to care about size of different integer types.</p>

<p><strong>Note</strong> This part only handles <code>x&gt;=0</code>.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;limits.h&gt;

int reverseNumber(int x){
    int result=0;
    if (x &lt; 0)
    {
        printf(""This version requires x &gt;= 0\n"");
        exit(1);
    }
    while (x != 0)
    {
        if (result &gt; INT_MAX/10)  // Check for overflow before multiplying
        {
            return 0; // Will overflow
        }
        result = 10 * result;

        if (result &gt; (INT_MAX - (x % 10)))   // Check for overflow before adding
        {
            return 0; // Will overflow
        }
        result = result + (x % 10);

        x /= 10;
    }

    return result;
}

int main(void) {
    printf(""%d\n"", reverseNumber(INT_MAX));
    printf(""%d\n"", reverseNumber(2147483412));
    return 0;
}
</code></pre>

<p><strong>Output:</strong></p>

<pre><code>0
2143847412
</code></pre>
",0
44343008,44342415,1,"<p>Here is a version that does <strong>not</strong> mix different integer types. All calculations are kept as <code>int</code>. In that way you don't need to care about size of different integer types.</p>

<p><strong>Note</strong> This part only handles <code>x&gt;=0</code>.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;limits.h&gt;

int reverseNumber(int x){
    int result=0;
    if (x &lt; 0)
    {
        printf(""This version requires x &gt;= 0\n"");
        exit(1);
    }
    while (x != 0)
    {
        if (result &gt; INT_MAX/10)  // Check for overflow before multiplying
        {
            return 0; // Will overflow
        }
        result = 10 * result;

        if (result &gt; (INT_MAX - (x % 10)))   // Check for overflow before adding
        {
            return 0; // Will overflow
        }
        result = result + (x % 10);

        x /= 10;
    }

    return result;
}

int main(void) {
    printf(""%d\n"", reverseNumber(INT_MAX));
    printf(""%d\n"", reverseNumber(2147483412));
    return 0;
}
</code></pre>

<p><strong>Output:</strong></p>

<pre><code>0
2143847412
</code></pre>
",0
42496248,42496191,5,"<p>It doesn't refer to an array, it refers to a single <code>const double</code> element. However, that element could very well be the first in an array of constant doubles.</p>

<p>So if we preform pointer arithmetic, we may reference other elements in the array. To do that, you can use the subscript operator <code>values[i]</code>. But you must ensure that you only compute and reference addresses that are in the array. And you cannot know that from the pointer value alone.</p>

<p>So unless your function is modified to receive a size parameter as well, you may not generally reference any element besides the one whose address was passed.</p>

<p>Once you have the size available to you, however, iteration should look just as you'd expect it from your Java experience: </p>

<pre><code>double function(const size_t num_elem, const double* values) {
  double result = 0.0;
  // .. pre iteration stuff
  for (size_t i = 0; i &lt; num_elem; ++i) {
    if (values[i] &lt; 1e-6)
      // do something
  }
  // post iteration stuff
  return result;
}
</code></pre>
",2
42496327,42496191,1,"<p>Arrays in C are a chunk of memory allocated to hold a number of elements of a certain type. The way you access each element is by using a pointer to the memory location and dereferencing it (i.e. <code>*ptr</code>). </p>

<p><code>values</code> is a pointer to a memory location where a <code>double</code> can be stored. Assuming it points to the first location of a chunk of memory allocated to store <code>double</code>s you can access the first element in that chunk by either doing <code>*values</code> or <code>values[0]</code>. The second element would be accessed with <code>*(values + 1)</code> or <code>values[1]</code>. And so on.</p>

<p>Given this, you can't know how big the chunk of memory is by just having the location to the start. The function needs to take another argument that tells it how many elements are supposed to be there.</p>

<pre><code>double function(const double* values, const int count);
</code></pre>

<p>If you are just starting with C I suggest you dig a little bit deeper into the fundamentals of the language. I have found <a href=""https://en.wikipedia.org/wiki/The_C_Programming_Language"" rel=""nofollow noreferrer"">The C Programming Language
</a> extremely simple, short and informative when it comes to grasping the fundamentals of C.</p>
",0
42496537,42496191,0,"<p>Pure C arrays don't know their sizes (which is why C is quite powerful). You can index anything at any point (as long as the OS allows you to)</p>

<p>so,</p>

<pre><code>int main ( )
{
    //size of your array, you could use size_t which is type for sizes I'll not be doing so,
    //to simplify the code
    const int size = 10


    //both ""size"", the type and the name of the array are virtually infinitely flexible
    int array[size] = {0}//never forget to initialize your array, or you'll get garbage.

    //in pure C, you have to declare i before using it, here I declare and also initialize it
    //because, why not?
    int i = 0;

    //since i have already been initialized, I could easily rewrite the for statement below:
    //for ( ; i &lt; size; ++i ) no initialization required. 
    for ( i = 0; i &lt; size; ++ i )
    {
        array[i] //do whatever you want.
    }
}
</code></pre>
",0
42511435,42511040,1,"<p>The search for the maximum could be done on the fly as follows; neither the macro nor the program itself would need an array for this.</p>

<pre><code>#include &lt;stdio.h&gt; 
#include &lt;limits.h&gt;
#define LARGEST(x,y) ( (x) &gt; (y) ? (x) : (y) )
int main()
{
    int a = INT_MIN;
    int i = 0;
    for(i=0; i&lt;5; i++)
    {
        int x = 0;
        printf(""Enter the value of X:\n"");
        scanf(""%d"", &amp;x);
        a = LARGEST(x, a);
    }    
    printf(""%d"", a);
}
</code></pre>

<p>The macro uses the ternary operator to evaluate to the larger of its arguments. In the program itself, only a local variable for the current input and the current maximum are used; the maximum is initialized to the smallest value possible.</p>
",5
42512241,42511040,0,"<p>Continuing from the comment, you can either check for the largest each time input is taken, or you can store all input in an array and then loop over each value in the array. The first approach is much simpler:</p>

<pre><code>#include &lt;stdio.h&gt;

#define MAX 5
#define LARGEST(a,b) ((a) &gt; (b) ? (a) : (b))

int main (void)
{
    int largest = 0, n = 0, x;

    while (n &lt; MAX) {
        int ret;
        printf (""enter value %d of %d: "", n + 1, MAX);
        ret = scanf (""%d"", &amp;x); /* validate conversion */
        if (ret == 1) {         /* input is valid */
            if (n)              /* not the first value */
                largest = LARGEST(largest,x);
            n++;
        }
        else if (ret == EOF) {  /* always check EOF */
            fprintf (stderr, ""user canceled input.\n"");
            return 0;
        }
        else {          /* input was not an integer */
            fprintf (stderr, ""error: invalid input.\n"");
            int c;      /* flush stdin to avoid loop */
            while ((c = getchar()) != '\n' &amp;&amp; c != EOF) {}
        }
    }

    printf (""\nlargest: %d\n"", largest);

    return 0;
}
</code></pre>

<p>Look things over and let me know if you have any questions.</p>
",3
42537850,42537778,2,"<p>Incorrect use of ternary operator.</p>

<pre><code>#define MAX(x,y) x&gt;y x : y
</code></pre>

<p>Should be:</p>

<pre><code>#define MAX(x,y) (x&gt;y) ? x : y
</code></pre>

<p>And to allow for more complex expressions:</p>

<pre><code>#define MAX(x,y) (((x)&gt;(y)) ? (x) : (y))
</code></pre>
",1
42537887,42537778,0,"<p>You mention that you don't know what is going on. There is only way - run only the preprocessor.
What compiler are you using? Assuming gcc/clang you can -</p>

<p><code>gcc -E filename.c</code></p>

<p>This will only run the preprocessor and let you analyze what is going on.</p>

<p>BTW you code doesn't compile because you made a mistake with the ternary operator - should be <code>x &gt; y ? x : y</code>.</p>
",2
42539192,42537778,2,"<p>Expanding the macro as-is, we get the following:</p>

<pre><code>Original                   Expanded
--------                   --------
c = MAX( a, 3 );           c = a&gt;3 a : 3;
d = MAX( y, x );           d = y&gt;x y : x;
e = MAX( ++x, 1 );         e = ++x&gt;1 ++x : 1;
f = MAX( b, MAX (6, 7) );  f = b&gt;MAX (6, 7) b : MAX (6, 7);
                           f = b&gt;6&gt;7 6 : 7 b : 6&gt;7 6 : 7;
</code></pre>

<p>Macro expansion is just dumb text substitution - syntax, scope, precedence, associativity, values, side effects, etc., are simply not taken into account when a macro is expanded (macro expansion occurs before the source code is fed to the compiler proper).  </p>

<p>Obviously, none of the expanded expressions above will compile.  For that to happen, we need to fix the <code>MAX</code> macro by defining it as</p>

<pre><code>#define MAX( x, y ) x&gt;y ? x : y
</code></pre>

<p>Now we get the following:</p>

<pre><code>Original                   Expanded
--------                   --------
c = MAX( a, 3 );           c = a&gt;3 ? a : 3;
d = MAX( y, x );           d = y&gt;x ? y : x;
e = MAX( ++x, 1 );         e = ++x&gt;1 ? ++x : 1;
f = MAX( b, MAX (6, 7) );  f = b&gt;MAX (6, 7) ? b : MAX (6, 7);
                           f = b&gt;6&gt;7 ? 6 : 7 ? b : 6&gt;7 ? 6 : 7;
</code></pre>

<p>Better.  The expanded expressions above will compile, but the last two don't do <em>anything</em> like what you expect them to.  <code>e</code> won't get the max of <code>x</code> and <code>1</code>, it will either get <code>x+2</code> or <code>1</code> (<code>?</code> introduces a sequence point, so the behavior isn't undefined).  <code>f</code> gets ... <em>something</em>, can't remember the associativity of <code>&gt;</code> and <code>?:</code> offhand, not really willing to dig it up.  </p>

<p>Again, macros don't take precedence and associativity into account when expanding their arguments.  Imagine we write a macro <code>CUBE</code> that does the following:</p>

<pre><code>#define CUBE(x) x * x * x
</code></pre>

<p>and we call it as</p>

<pre><code>y = CUBE( 2 + 3 );
</code></pre>

<p>That expands to</p>

<pre><code>y = 2 + 3 * 2 + 3 * 2 + 3;
</code></pre>

<p>which gives us the value 17, when we were <em>probably</em> expecting 125.  </p>

<p>The <em>right</em> way to define the <code>MAX</code> macro is</p>

<pre><code>#define MAX( x, y ) ((x) &gt; (y) ? (x) : (y))
</code></pre>

<p>We not only parenthesize each argument, we parenthesize the entire expression.  This way, precedence and associativity are preserved not only if you pass complex expressions as arguments, but also if you pass this macro as an argument to another one (as in the last example):</p>

<pre><code>Original                   Expanded
--------                   --------
c = MAX( a, 3 );           c = ((a) &gt; (3) ? (a) : (3));
d = MAX( y, x );           d = ((y) &gt; (x) ? (y) : (x));
e = MAX( ++x, 1 );         e = ((++x) &gt; (1) ? (++x) : (1));
f = MAX( b, MAX (6, 7) );  f = ((b) &gt; (MAX (6, 7)) ? (b) : (MAX (6, 7)));
                           f = ((b) &gt; ((6) &gt; (7) ? (6) : (7)) ? (b) : ((6) &gt; (7) ? (6) : (7)));
</code></pre>

<p>This time, <code>f</code> will be evaluated like you expect it to be.  </p>

<p>The evaluation of <code>e</code> is still problematic (<code>++x</code> can still be evaluated twice).  This is a problem in general with macros that expand their arguments more than once - arguments that have side effects can be evaluated multiple times, which will lead to wrong answers or undefined behavior.  </p>
",0
42522428,42522382,0,"<p>To be 100% sure we'd need to see how you are constructing cmd instances, but I can make an educated guess that it is using a common buffer so all <code>cmd</code>s have their <code>cmd_str</code> pointing to the same thing (i.e. you have multiple <code>cmd</code>s all pointing to the same C string).</p>

<p>Have you considered making <code>cmd</code> contain an array of chars instead of just a pointer? </p>
",5
42531279,42529316,2,"<p>If I rebuild (your code), I get the warning like this</p>

<p><a href=""https://i.stack.imgur.com/Opzux.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Opzux.png"" alt=""enter image description here""></a></p>

<p><strong>then, try with    <code>scanf("" %c"", &amp;choice);</code></strong></p>

<p>The %c conversion specifier won't automatically skip any leading whitespace, so if there's a stray newline in the input stream. the scanf call will consume it immediately.</p>

<p>One way around the problem is to put a blank space before the conversion specifier in the format string:</p>

<pre><code>scanf("" %c"", &amp;choice);
</code></pre>

<p>The blank in the format string tells scanf to skip leading whitespace, and the first non-whitespace character will be read with the %c conversion specifier.
The Check Rebuild, And I get <strong>no warning</strong> with this</p>

<hr>

<ul>
<li>Whenever gets() statement encounters then characters entered by user
(the string with spaces) will be copied into the variable.</li>
<li>If user start accepting characters , and if new line character
appears then the newline character will not be copied into the string
variable(i.e name).</li>
<li>A terminating null character is automatically appended after the
characters copied to string vriable (i.e name)</li>
<li>gets() uses stdin (Standered Input Output) as source, but it does not
include the ending newline character in the resulting string and does
not allow to specify a maximum size for string variable (which can
lead to buffer overflows).</li>
</ul>

<p>The gets() function has no means of preventing you typing the characters and so should be avoided.</p>

<p>I hope this use full. Sorry if any mistake :) I learner</p>
",0
42531334,42529316,0,"<p>I can't say why it ""stopped working"" on your system, although as it's been mentioned already, you're passing an incorrect parameter, so undefined behaviour is expected. See the following, from the man page:</p>

<blockquote>
  <p>char *gets(char *s);</p>
  
  <p>DESCRIPTION</p>
  
  <p>Never use this function.</p>
  
  <p>gets()  reads a line from stdin into the buffer pointed to by s  until either a terminating newline or EOF, which it replaces with a
  null byte ('\0').  No check for buffer overrun is performed
         (see BUGS below).</p>
</blockquote>

<p>So there were two mistakes, passing a char instead of a buffer pointer, and using <em>gets</em> in the first place. The manual further explains why it's so dangerous to use <em>gets</em>:</p>

<blockquote>
  <p>BUGS
  Never use gets(). Because it is impossible to tell without
  knowing the data in advance how many characters gets() will read, and
  because gets() will continue to store characters past the end of the
  buffer, it is extremely dangerous to use. It has been used to break
  computer security.  Use fgets() instead.</p>
  
  <p>For more information, see CWE-242 (aka ""Use of Inherently Dangerous
  Function"") at <a href=""http://cwe.mitre.org/data/definitions/242.html"" rel=""nofollow noreferrer"">http://cwe.mitre.org/data/definitions/242.html</a></p>
</blockquote>

<p>Put it simply, suppose you had declared choice as follows:</p>

<pre><code>char choice[2]; // e.g. 'y' plus terminating null byte
</code></pre>

<p>There's nothing stopping the user from entering ""Yes"" or anything else, which goes beyond the buffer size.</p>

<p>Remember that you would be passing a pointer, and every time you pass a pointer to a buffer, the receiving function should also receive the buffer size and ensure that it won't go past its boundary. Because this function does not take size as a parameter, it's now deprecated (read ""forbidden"" in this case).</p>

<p>Anyway, there are many alternatives, this is one potential solution.</p>

<p>Replace ""char choice"" with:</p>

<pre><code>int choice, c;
</code></pre>

<p>And instead of ""gets(choice)"" you could use this:</p>

<pre><code>while( (c = getchar()) != '\n' &amp;&amp; c != EOF )
    /* discard */ ;
choice = getchar();
</code></pre>

<p>Note that ""getchar() is equivalent to getc(stdin)"". It doesn't actually read directly from the keyboard. That's why we've add the while loop to discard unprocessed data from the input stream, prior to the prompt. See <a href=""http://c-faq.com/stdio/stdinflush2.html"" rel=""nofollow noreferrer"">this answer on c-faq</a> for details.</p>
",0
42556751,42556583,1,"<p>Inside the comparison, the <code>float</code> value is implicitly converted to type <code>double</code>.</p>

<p>Then the two values <strong>of the same type</strong> are compared.</p>
",2
42565689,42556583,0,"<p>You should look up IEEE764 float and double definitions to see how real numbers are really stored, and what the binary-point offsets are for floats and doubles. The endian-ness of the machine will also affect things.</p>
",0
38518748,38518211,0,"<p>If you're not <code>malloc</code>ating memory, then below would be my approach</p>

<pre><code>int c; 
char myword[20]; // max characters to store is 20
int i=0;
FILE* ptr=fopen(""38518211"",""r"");
if (ptr==NULL){
printf(""Can't open the file"");
}
else{
while(i&lt;19 &amp;&amp; (c=fgetc(ptr)) != EOF)
  myword[i++]=c;
}
if((c=fgetc(ptr)) != EOF)
 printf(""Original string is truncated to fit into alloted space\n"");
myword[i]='\0'; // Null terminating the string
printf(""String from file %s\n"",myword);
fclose(ptr);
</code></pre>
",0
41174790,41163011,1,"<p>In testing OP's code, the list, as posted, had a space after the 0.7.  Normally this white-space is not an issue, yet my saving of the file <code>text.txt</code> caused the line to end with <code>"" \r\n""</code> and the <code>'\r'</code> created additional tokens.  Additional  white-space characters to <code>strtok(NULL, "" \n\r\t"")</code> solved this.</p>

<pre><code>&lt;1.0 2.5 5.1 5.8 5.9 0.7 &gt;
&lt;1.2 4.1 5.1 5.8 6.8 1.9 2.9 0.2&gt;
&lt;1.7 4.9 5.1 5.8 7.0 2.8 4.8 0.1 1.5 1.4&gt;
</code></pre>

<p>Depending on how the list is saved, the last line may or may not end with a <code>'\n'</code>.  This becomes an issue with OP's method of lopping off the <code>'\n'</code> with the below as it may render the last line as <code>""1.7 4.9 5.1 5.8 7.0 2.8 4.8 0.1 1.5 1.""</code>  (last <code>4</code> missing).</p>

<pre><code>    line[strlen(line) - 1] = 0;
</code></pre>

<p>Better to use the below which does not require a final <code>'\n'</code> to work right.</p>

<pre><code>    line[strcspn(line, ""\n"")] = '\0';
</code></pre>

<hr>

<p>OP's code is creating one too many coordinates in its <code>xy</code> list.  It also has trouble potential due to other white-spaces.  A more complete list is added.</p>

<pre><code>while (token != NULL) {
  xy = atof(token);
  polygon_vertices[xycount++] = xy;
  token = strtok(NULL, "" \n\r\t"");  // more white-spaces.
  if (token == NULL) break;
}
</code></pre>

<p>Code will then calculate answer <em>close</em> to the expected values.  After that fix, an earlier  proposed duplicate applies. <a href=""https://stackoverflow.com/questions/588004/is-floating-point-math-broken"">Is floating point math broken?</a></p>

<pre><code>   area=11.775000   expected area=11.770000
   perimeter=15.645596  expected perimeter=15.640000
</code></pre>

<p>Rather than compare FP numbers for exact matching, code need to allow for a small tolerance.  See <a href=""https://stackoverflow.com/q/11747251/2410359"">comparing double values in C</a>,<br>
<a href=""https://stackoverflow.com/q/30424292/2410359"">precision of comparing double values with EPSILON in C</a>.</p>

<hr>

<p>Various simplifications and accuracy improvements possible.  Example:  </p>

<pre><code>#include &lt;assert.h&gt;
/* calculate polygon perimeter */
double perimeter(double *vertices, int size) {
  assert(size % 2 == 0 &amp;&amp; size &gt;= 0);   // Insure only positive pairs are used
  double perimeter = 0.0;
  if (size &gt; 1) {
    double x_previous =  vertices[size - 2];
    double y_previous =  vertices[size - 2 + 1];
    while (size &gt; 1) {
      double x = *vertices++;
      double y = *vertices++;
      // hypot() certainly as accurate than sqrt(x*x + y*y) and avoids overflow
      perimeter += hypot(x - x_previous, y - y_previous);
      x_previous = x;
      y_previous = y;
      size -= 2;
    }
  }
  return perimeter;
}
</code></pre>
",0
44705502,44705357,1,"<p>First of all, I am assuming you have ""#include"" instead of ""import"" in line 1, and ""answer"" instead of ""a"" in line 12.</p>

<p>To answer the actual question you have, in C char and string are different. You have a char type variable answer, that you are comparing with the string ""u"". As a result, the compiler is creating a constant string ""u"" and comparing the pointer to that string with the char type variable answer. Your check should instead have </p>

<pre><code>if(answer == 'u') {
</code></pre>
",0
42545619,42545454,1,"<p>Yes it is essentially just a list of instructions. The purpose of a makefile is to be easily build an executable that might take many commands to create (which would be a pain to compile over and over again manually).</p>
",2
42549412,42545454,2,"<p>The answer above is pretty correct, but misses an important point: makefiles are intelligent, they are meant to run only the needed commands, not all. This is done with the concept of dependencies between items, like: </p>

<blockquote>
  <p>to generate A from B, it is necessary to run (for example) ""cc -o A B"".</p>
</blockquote>

<p>These rules/dependencies can be cascaded (to have A you must use B; to have B, you must use C+D+E, to have D you must do ...)</p>

<p>If your <em>project</em> is structured in many files, a makefile will (normally) recreate the objects whose dependencies are changed, <em>not</em> all the objects. </p>

<p>Think of a C project split in 10 files. You modify one, say ""main.c"" and then want to test the project. With Makefile, only ""main.c"" gets recompiled and then the final executable gets linked. Without a Makefile, perhaps all the 10 files would get recompiled.</p>
",0
40965177,40964737,0,"<p>I think your over complicating it slightly. </p>

<p>In this block of code:</p>

<pre><code>char String;
char *sendString;
char getString[100];
int counter;

*sendString = String;
</code></pre>

<p>You don't need most of these <code>char</code> declarations, if you only want to calculate the length of the string from <a href=""https://www.tutorialspoint.com/c_standard_library/c_function_fgets.htm"" rel=""nofollow noreferrer""><code>fgets</code></a>. </p>

<p>This can simply be reduced to:</p>

<pre><code>char getstring[100];
int myStrLen;
</code></pre>

<p>Where you only need to give a string buffer to <code>fgets</code>, and an integer declaration <code>myStrLen</code>, used to calculate the final string length. </p>

<p>Additionally, there are some problems with your <code>calcLength()</code> function. You need to pass a <code>char []</code> parameter to this function, so it knows what string it needs to calculate the length of. It really should be as simple as this:</p>

<pre><code>int
calcLength(char sendstring[]) {
    int counter, len = 0;

    for (counter = 0; sendstring[counter] != '\0'; counter++) {
        len++;
    }
    return len;
}
</code></pre>

<p>With all of these recommendations, your code should look like this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define BUFFSIZE 100

int calcLength(char sendstring[]);

int 
main(void) {
    char getstring[BUFFSIZE];
    int myStrLen;

    printf(""\nPlease enter string:\n"");
    if (fgets(getstring, BUFFSIZE, stdin) != NULL) {
        getstring[strlen(getstring)-1] = '\0'; // To remove '\n' character from fgets()
    }

    myStrLen = calcLength(getstring);

    printf(""String length = %d\n"", myStrLen);

    return 0;
}

int
calcLength(char sendstring[]) {
    int counter, len = 0;

    // Every valid character found, increment a counter
    for (counter = 0; sendstring[counter] != '\0'; counter++) {
        len++;
    }
    return len;
}
</code></pre>

<p>Note: This code can be improved, but it should help point you in the right direction. I've added some comments in the code for clarification. </p>
",1
40996619,40996058,2,"<p>You are never initializing <code>temp</code>.
before doing <code>strcmp</code> do <code>strcpy(temp, inputarray)</code></p>
",2
41000158,40996058,0,"<p>You have printf(""%s Please enter string>""); 
This could lead to corruption, please try after removing %s from this printf statement</p>
",0
41000325,40996058,0,"<p>Try using this as your palindrome function instead of <code>strrev</code> (which is not standard C).  I noticed that when I tried using <code>strcmp(strrev(str), str)==0)</code> to test for a palindrome I always got ""is palindrome"" too.</p>

<pre><code>int ispalindrome(char *str, int len)
{   
    char *p = &amp;str[0];
    char *q = &amp;str[len - 1];
    do
    {
        if(p &gt;= q)
        {
            return 1;
        }
    } while (*p++ == *q--);
    return 0;
}
</code></pre>
",0
42581732,42581613,0,"<p>Read your compiler messages:</p>

<p>The problem is here:</p>

<pre><code>scanf(""%s"",b.fee);
</code></pre>

<p>The format specifier is <code>%s</code>, but <code>b.fee</code> is a float.</p>

<p>You need this:</p>

<pre><code>scanf(""%f"", &amp;b.fee);
</code></pre>

<p>There are likely more problems like that one. Check them out by yourself. Each <code>scanf</code>format specifier must match the variable.</p>
",2
41002261,41002063,0,"<p>For an array, as of c99, this is <strong>not</strong> an valid operation</p>

<pre><code>int main(void)
{
  int vec[3]={1,2,3};
  int sel[2]={1,2};
  vec[sel];  // Invalid, will cause compilation to fail
  return 0;
}
</code></pre>

<p>In order to select all of the variables you would have to loop through the array</p>

<pre><code>int main(void)
{
  int vec[3]={1,2,3};
  int sel[2]={1,2};
  int i;
  int indv;
  for(i=0;i&lt;2;i++)
  {
     indv=vec[sel[i]];
     ## dosomething to indv
  }
  return 0;
}
</code></pre>
",3
45043985,45031248,0,"<p>Okay looking at your code and analyzing it step by step,</p>

<pre><code>    #include &lt;stdio.h&gt;
    int main(){
        int a = 5;//You've assigned the value of 5 to integer a.
        int b,c;//You've declared two integer variables ""b"" and ""c"".
        if (a==4)/*Compiler checks whether the if condition is true,which in your  case is not*/
        {
            b = 6;/*Assigning value 6 to the b variable but no effect as the if condition of your's is not satisfied*/

            c = 7;/*The same above condition applies here.*/
        }
        printf(""%d %d\n"",b,c);/*Here your trying to print the values of b and c, 

But remember you have not given them any value. So the compiler automatically prints the garbage value(random value). It need not be 0 all the time.*/  

return 0;//You forgot this step btw:)
    }
</code></pre>
",0
42544409,42544239,3,"<p>Since <code>obuf</code> is an array, printing its value causes it to decay to a pointer and prints the value of the memory address that the array is stored at. Write sensible code to print a 256-bit value.</p>

<p>Maybe something like:</p>

<pre><code>for (int i = 0; i &lt; 32; ++i)
    printf(""%02X"", obuf[i]);
</code></pre>
",0
42544919,42544239,0,"<p>This is not really intended as an answer, I'm just sharing a code fragment with the OP.</p>

<p>To hash the binary time_t directly without converting the time to a string, you could use something like (untested):</p>

<pre><code>time_t cur_time;
char t_ID[40];
char obuf[40];

gmtime(&amp;cur_time);
SHA256(&amp;cur_time, sizeof(cur_time), obuf);

// You know this doesn't work:
// sprintf(t_ID, ""%02x"", obuf);

// Instead see https://stackoverflow.com/questions/6357031/how-do-you-convert-buffer-byte-array-to-hex-string-in-c
</code></pre>

<p><a href=""https://stackoverflow.com/questions/6357031/how-do-you-convert-buffer-byte-array-to-hex-string-in-c"">How do you convert buffer (byte array) to hex string in C?</a></p>

<p>This doesn't address byte order. You could use network byte order functions, see:</p>

<p><a href=""https://stackoverflow.com/questions/19207745/htons-function-in-socket-programing"">htons() function in socket programing</a>
<a href=""http://beej.us/guide/bgnet/output/html/multipage/htonsman.html"" rel=""nofollow noreferrer"">http://beej.us/guide/bgnet/output/html/multipage/htonsman.html</a></p>

<p>One complication: the size of time_t is not specified, it can vary by platform. It's traditionally 32 bits, but on 64 bit machines it can be 64 bits. It's also usually the number of seconds since Unix epoc, midnight, January 1, 1970.</p>

<p>If you're willing to live with assumption that the resolution is seconds and don't have to worry about the code working in 20 years (see: <a href=""https://en.wikipedia.org/wiki/Year_2038_problem"" rel=""nofollow noreferrer"">https://en.wikipedia.org/wiki/Year_2038_problem</a>) then you might use (untested):</p>

<pre><code>#include &lt;netinet/in.h&gt;

time_t cur_time;
uint32_t net_cur_time; // cur_time converted to network byte order
char obuf[40];

gmtime(&amp;cur_time);
net_cur_time = htonl((uint32_t)cur_time);
SHA256(&amp;net_cur_time, sizeof(net_cur_time), obuf);
</code></pre>

<p>I'll repeat what I mentioned in a comment: it's hard to understand what you possibly hope to gain from this hash, or why you can't use the timestamp directly. Cryptographically secure hashes such as SHA256 go through <em>a lot</em> of work to ensure the hash is not reversible. You can't benefit from that because the input data is from a limited known set. At the very least, why not use CRC32 instead because it's much faster.</p>

<p>Good luck.</p>
",0
42465804,42465715,1,"<p>When scoreLength is given as 1, the loop executes for first time with i = 0. Inside the loop you are incrementing i = i + 1, which makes i = 1. So check your condition in the while loop. It says <code>i &lt; scoreLength</code> which evaluates as false. So your loop executes only once.</p>
",0
42465812,42465715,0,"<p>do while first execute the do then check the while to go next
step : 1</p>

<pre><code>do
    {
        printf(""%d \n"", scores[i]); // here i = 0, output is 23
        i = i + 1;   // i becomes 1, so i = 1
    }
    while (i &lt; scoreslength); // here 1 &lt; 1 is false so can't execute further
    so the output is only 23
</code></pre>
",0
42465764,42465715,0,"<p>If scoreslength is 1, still only one pass on the loop will be before it exists.<br>
If you set scoreslength  to two, the output will be 23 and 24.</p>
",0
42465861,42465715,-2,"<p>Check out with this code:</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    int scores[] = {23, 24, 25, 26, 27, 28};
    int scoreslength = 0;
    int i = 0;
    do
    {
        printf(""%d \n"", scores[i]);
        i = i + 1;
    }
    while (i &lt;= scoreslength);

    return 0;
}
</code></pre>
",0
43985298,43985146,1,"<p>First of all, always turn on your compiler's warnings! With <code>gcc</code>, this is done by passing</p>

<pre><code>-Wall -Wextra -pedantic
</code></pre>

<p>Although, oddly enough, the warning in question is on by default in <code>gcc</code>, so you should have seen something like</p>

<pre><code>main.c: In function ¡®main¡¯:
main.c:6:14: warning: initialization makes pointer from integer without a cast [enabled by default]
</code></pre>

<p>If you don't understand a warning, don't ignore it! Ask about it instead.</p>

<hr>

<p>You called <code>hello</code> without declaring it, so it was implicitly declared as <code>int hello();</code></p>

<p><code>a.h</code>:</p>

<pre><code>typedef struct { int i; } a_t;

a_t* hello(void);
</code></pre>

<p><code>a.c</code>:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include ""a.h""

a_t* hello(void) {
    a_t* a = malloc(sizeof(a_t));
    a-&gt;i = 100;
    return a;
}
</code></pre>

<p><code>main.c</code>:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include ""a.h""

int main(void) {
    a_t* a = hello();
    printf(""%d\n"", a-&gt;i);
    free(a);
    return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>$ gcc -Wall -Wextra -pedantic -o main main.c a.c &amp;&amp; main
100
</code></pre>
",4
43197395,43197158,1,"<p>If you want to follow the instruction you were given, your function declaration should be</p>

<pre><code>double average(int *array, int array_size)
</code></pre>

<p>Also, your solution should be general, not only for array with length of 7.</p>

<p>In general in C language - when you want to pass an array which its length is unknown, you pass the address of the array (here <code>*array</code>) and its size (here <code>array_size</code>). Then your function will iterate over the array from the given address, with jumps of the type (here jumps of <code>sizeof(int)</code> because it's an array of ints).</p>
",0
43197758,43197158,0,"<p>In C Program execution always starts from main.
So the stack will be like</p>

<pre><code>main()--&gt;Function()
</code></pre>

<p>You are almost  right just you called the function which returns the average so to keep that average or to accept that average in main you need variable so just remove all the code shown below</p>

<pre><code>for(i=0; i&lt;7; i++)
    {
    // This takes all the array's elements and sums them up.
    sum += Array[i];
    }
    // This prints the sum
    printf(""Sum = %d\n"", sum);

// The double average is found by taking the sum found and dividing it by 7.
average = sum/7;
// This prints the average in a double.
printf(""The resulting average is %lf \n"", average);
</code></pre>

<p>Now take the results returned by the Function() in average variable shown below.</p>

<pre><code>average=Function(Array);
</code></pre>

<p>Now print that value if you want to print or use in main if you need.</p>
",0
43219869,43197158,0,"<p>the posted code contains several misconceptions</p>

<ol>
<li>no need to '#include' header files those contents are not needed.</li>
<li>only write code that is part of the solving of the problem.  Other code that is added for 'debug' purposes should be eliminated from the final executable.  Usually be surrounding the debug code with: <code>#ifndef NDEBUG .... #endif</code>   Suggest learning how to work with <code>NDEBUG</code></li>
<li>The problem only needs to solved once, not both in 'main()' and in 'Function()'  BTW: <code>function</code> is a terrible function name suggest: <code>calculateAverage()</code>.  Function names should indicate what they will perform, usually by starting the function with some active verb, like <code>calculate</code></li>
<li>for ease of readability and understanding, consistently indent the code.  Indent after every opening brace '{'. unindent before every closing brace '}'.  Suggest each indent level be 4 spaces as that is wide enough to be visible even with variable width fonts. Remember, the compiler (in general) doesn't care about the 'style' of the code formatting.  However, any human cares a lot, because the human wants to be able to read the code.</li>
<li>it is (almost always) a bad idea to hard code any values other than 0 and 1.  Instead give them meaningful names via a <code>enum</code> statement or <code>#define</code> statements, then use those meaningful names throughout the code. </li>
<li><p>Please pay attention to these 3 details in the code:</p>

<ul>
<li>how the size of the array is calculated</li>
<li>how the parameters are passed to the 'Function()' </li>
<li>how the average is calculated.</li>
</ul></li>
</ol>

<p>Note: when all the variables in a divide operation are integers, then a integer divide is performed. This can produce some surprising results.
For instance, 5/3 results in 1, not 1.66.
by wanting to keep the fraction, cast one of the elements (not the whole expression) to <code>double</code> or <code>float</code></p>

<p>and now the code</p>

<pre><code>#include &lt;stdio.h&gt; // printf()
//#include &lt;stdlib.h&gt;

double Function(int *pArray, int numElements );

int main( void )
{
    // int array numbers are declared and initialized.
    // note: usually best to let the compiler calculate array size
    //       rather than hardcoding the size
    int Array[] = {78, 90, 56, 99, 88, 68, 92};

    // number of elements in array
    int sizeofArray = sizeof(Array)/sizeof(int);

    // call Function to calculate and return as double,
    // the average of the array elements
    double average = Function( Array, sizeofArray );

    // This prints the average as a 'double'.
    printf(""The resulting average is %lf \n"", average);

    //system(""pause""); // not portable, suggest:
    int ch;
    while( (ch = getchar()) != EOF &amp;&amp; '\n' != ch );
    getchar();

    //return 0;   // &lt;-- in modern C, if main to return 0 then this line not needed
} // end function: main


double Function(int *pArray, int numInts )
{
    int sum = 0;

    double average;

    for(int i=0; i&lt;numInts; i++)
    {
        sum += pArray[i];
    }

    // cast one of the values as a double so an integer divide is NOT performed
    average = (double)sum / numInts;

    return average;
}  // end function: Function
</code></pre>
",0
42526524,42526198,1,"<p><code>isdigit()</code> can be used to check for a single character. What you are passing to it is a float (which might be completely malformed). 
What you need to do is read the input as a string and check for each character till you encounter a '\0'.</p>

<p>Besides that, the reason your program keeps looping is </p>

<pre><code>if(i==2){ 
    i=0-1; // i = -1;
} 
</code></pre>

<p>You are never letting i go above 2 for the loop to stop.</p>
",0
42528492,42526198,0,"<p>What is happening is that the <code>scanf</code> fails, and without removing the alphabetical text from <code>stdin</code>. That means that the next <code>scanf</code> also fails, and so on.</p>

<p>You need to check the return value of <code>scanf</code> and if you fail to scan a number, you need to remove the non-numeric input from <code>stdin</code>. I would recommend using <code>fgets</code> to remove one entire line of input from <code>stdin</code> when you get a failure from <code>scanf</code>.</p>

<pre><code>    while (1 != scanf(""%f"", &amp;arr[i])) {
        // Scan failed! Remove input line with non-numeric input
        char tmp[100];
        fgets(tmp, sizeof tmp, stdin);
        printf(""Not a number! Enter the weight of the cabin %d:\t"", i);
        fflush(stdout); 
    }
</code></pre>
",1
42559796,42559408,0,"<p>I think you are looking for a program to guess a number, but your code doesn't seems to be optimal way. It is possible to do it in one loop and three if-else statement: if matches print ""Congratulation"" and break the loop, else look for changing the upper limit or lower limit.</p>

<p>Try something like this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

int main(void) 
{

int random_num = 0;
int guessed_num = 0;
int counter = 0; 
int lower = 0;
int upper;    

printf(""Enter the upper range: "");
scanf(""%d"", upper);

srand(time(NULL));
random_num = rand() % upper + 1;

printf(""Guess my number! ""); 

    while(1)
    {
        counter++; 

        scanf(""%d"", &amp;guessed_num);

        if (guessed_num == random_num) 
        {
            printf(""You guessed correctly in %d tries! Congratulations!\n"", counter); 
            break;
        }

        if (guessed_num &lt; random_num) 
            printf(""Your guess is too low. Guess again. "");

        if (guessed_num &gt; random_num) 
            printf(""Your guess is too high. Guess again. "");

    } 

return 0;   
}
</code></pre>

<p>In case you want to stick to your code, I would suggest you to use <code>getchar()</code> function instead of <code>scanf(""%c"", &amp;ans)</code>. You can understand more about it from this <a href=""http://quiz.geeksforgeeks.org/difference-getchar-getch-getc-getche/"" rel=""nofollow noreferrer"">link</a></p>
",1
42559661,42559408,0,"<p>Try this:</p>

<pre><code>scanf("" %c"", &amp;ans);
</code></pre>

<p>Instead of</p>

<pre><code>scanf(""%c"", &amp;ans);
</code></pre>
",1
42641954,42641892,3,"<p>In the first problem you give an element after the array as a parameter to your function.</p>

<p>You define a long int array, and pass it into a function expecting an int array.</p>

<pre><code>long int theArray[SIZE] = {5,2,3,4,5,6,1,2,10,5,10,12,6,8,7};
</code></pre>

<p>should be</p>

<pre><code>int theArray[SIZE] = {5,2,3,4,5,6,1,2,10,5,10,12,6,8,7};
</code></pre>

<p>Instead of this:</p>

<pre><code>numberFrequency = frequency (theArray[SIZE], n, x);
</code></pre>

<p>try this:</p>

<pre><code>numberFrequency = frequency (theArray, n, x);
</code></pre>

<p>And replace:</p>

<pre><code>count = count++;
</code></pre>

<p>with:</p>

<pre><code>count++;
</code></pre>
",5
43198626,43197827,0,"<pre><code>int Function(int a, int b, int c)   
{ 
    if ( a &gt; b &amp;&amp; a &gt; c )
        return a;
    else if ( b &gt; a &amp;&amp; b &gt; c )
        return b;
    else if ( c &gt; a &amp;&amp; c &gt; b )
        return c;
}
</code></pre>

<p>I hope you know how to call this function in main(). Try doing some basic C coding tutorials, you will be able to do this quite easily.</p>
",1
42632713,42632659,4,"<p>Check the return value of <code>fscanf</code> -- it should return 1 when it successfully reads a number and 0 on that blank line.</p>
",6
42633121,42632659,1,"<p>OP is reading a file, line by line and has 4 outcomes:</p>

<ol>
<li>Successful translated to a number.</li>
<li>Line begins with a <code>#</code> or whitespace only.</li>
<li>No more input  (end-of-file).</li>
<li>Something else.</li>
</ol>

<p>Suggest new approach: read line by line as text and then attempt various parsings.  It is important to check the return value of <code>*scanf()</code> to help determine success.</p>

<pre><code>   printf(""File opened successfully\n"");
   float /* or double */ arr[N];
   size_t i = 0;
   char buffer[100];

   while (fgets(buffer, sizeof buffer, fptr)) {
     double x;
     char sof[2];
     if (sscanf(buffer, ""%lf"" ,&amp;x) == 1) {
       if (i &lt; N) {
         arr[i++] = x;
       } else {
         puts(""No room"");
       }
     } else if (sscanf(buffer, ""%1s"" , sof) != 1 || sof[0] == '#') {
       ; // quietly ignore white-space only lines and that begin with # 
     } else {
       puts(""Unexpected input"");
     }
   }
   fclose(fptr);
   puts(""Done"");
</code></pre>
",0
42620339,42618081,1,"<p>the <code>!</code> operator is for logical negation, <code>!x</code> is equivalent to <code>x == 0</code> for both numeric and pointer types.</p>

<p><code>!x</code> has type <code>int</code> and a value of <code>1</code> if <code>x</code> compares equal to <code>0</code> and has a value of <code>0</code> for all other cases.</p>
",0
42618153,42618081,5,"<p>The <code>!</code> is the <em>logical</em> negation operator. If you give it nonzero things it gives you back a zero. If you give it a zero it gives you back 1.</p>

<p>So</p>

<pre><code>   !x | x
=&gt; !1 | 1
=&gt; 0 | 1
=&gt; 1
</code></pre>

<p>Note how this is different from the <em>bitwise</em> negation operator, <code>~</code>. If you had used this instead of <code>!</code>, things would have worked out like this (assuming 8-bit values, you can scale up to 32 or 64 or whatever):</p>

<pre><code>   ~x | x
=&gt; ~1 | 1
=&gt; 11111110 | 00000001
=&gt; 11111111
=&gt; -1
</code></pre>

<p>It all comes down to understanding the difference between <code>!</code> and <code>~</code>. It's not obvious; it's just something you have to get used to. Just as a reminder</p>

<pre><code>!7 = !23423523 = !46 = !(-200) = !1 = 0
</code></pre>

<p>For any nonzero <code>x</code>, <code>!x = 0</code>. That's just how it is. The idea behind that is C takes 0 as false and anything else as true. So, since a value like 70343 or 1 counts as true, applying <code>!</code> to it gives false, or 0.</p>
",0
42566963,42566680,0,"<p>Change your search function declaration to:</p>

<pre><code>int search(int no,int *num)
</code></pre>

<p>Change the way you access to the array elements:</p>

<pre><code>if (no == num[i]) // Instead of *num[i]
</code></pre>

<p>and call it like:</p>

<pre><code>s=search(no,num)
</code></pre>

<p>I think you have some confusion about arrays, pointers and argument passing.
Also, as comments below your question already point out, you should adopt a better coding style. Your code is really hard to read. </p>

<p>This may be a good start point:
<a href=""https://www.kernel.org/doc/Documentation/process/coding-style.rst"" rel=""nofollow noreferrer"">https://www.kernel.org/doc/Documentation/process/coding-style.rst</a></p>
",0
42617564,42617447,1,"<p>Use <code>fclose</code>before returning from function.
Also check return value of <code>fopen</code> every time.
Or I think <code>Output</code> is a global variable( No local declaration found). So no need to open and close every time.    </p>
",0
42501033,42500868,0,"<p>Due to an overflow that would lead to a negative zero, the binary representation for the smallest signed integer using twos complement representation is usually a one bit for the sign, followed by all zero bits.</p>

<p>If you divide the values in an unsigned type into two groups, one group for negative and another positive, then you'll end up with two zeros (a negative zero and a positive zero). This seems wasteful, so many have decided to give that a value. What value should it have? Well, it:</p>

<ul>
<li>has a 1 for a sign bit, implying negative;</li>
<li>has a 1 for the most significant bit, implying 2<sup>width-1</sup> (128, in your example)...</li>
</ul>

<p>Combining these points to reinterpret that value as -128 seems to make sense.</p>
",0
42500943,42500868,4,"<p>You are close.</p>

<p>The minimum value of a signed integer with n bits is found by making the most significant bit 1 and all the others 0.</p>

<p>The value of this is -2^(n-1).</p>

<p>The maximum value of a signed integer with n bits is found by making the most significant bit 0 and all the others 1.</p>

<p>The value of this is 2^(n-1)-1.</p>

<p>For 8 bits the range is -128...127, i.e., <code>10000000</code>...<code>01111111</code>.</p>

<p>Read about <a href=""https://en.wikipedia.org/wiki/Two%27s_complement#Why_it_works"" rel=""nofollow noreferrer"">why this works</a> at Wikipedia.</p>
",1
42657391,42655909,0,"<p>In your <code>main</code> function, replace the call to <code>sortLowerUpperCase(""LiDoR"");</code></p>

<p>with</p>

<pre><code>char * string = (char *)malloc(6);
strcpy(string, ""LiDoR"");
sortLowerUpperCase(string);
</code></pre>

<p><strong>Reason</strong></p>

<p>In C, string literals are created in a read-only area of the memory on most architecture. Later, when you try to write / replace some part of that string literal (in the statements <code>arr[index1] = arr[index2];</code> and <code>arr[index2] = aux;</code>) which is in the read-only memory section, you obviously get this error (seg fault). So to avoid accidentally writing memory to read-only section, you should create memory on your own (either using <code>malloc</code> or using an array) and then copy the string literal to that memory.</p>
",0
42384924,42384723,2,"<p>you have to add <code>break</code>after every <code>case</code> statement</p>

<pre><code>switch (letterGrade)
    {
        case 'A':
            numberGrade = 4.0;
            break;
        case 'B':
            numberGrade = 3.0;
            break;
        case 'C':
            numberGrade = 2.0;
            break;
        case 'D':
            numberGrade = 1.0;
            break;
        default:
            numberGrade = 0.0;
    }
</code></pre>
",2
42385373,42384723,1,"<p>The way switch-case operates is when the first <code>case</code> match is found, all the subsequent <code>case</code> blocks are executed until the execution hits a <code>break</code> statement or end of <code>switch</code> block. Switch-case statements act in fall-through manner.</p>

<p>Here, let's say 'B' is the value for <code>letterGrade</code>, then all the following <code>case</code> blocks will be executed</p>

<pre><code>case 'B'
case 'C'
case 'D'
default
</code></pre>

<p>Since <code>default</code> will also get executed, it will mark <code>numberGrade</code> to <code>0.0</code>.</p>
",1
42386293,42384723,0,"<p>you have 2 problems in your program :</p>

<p><strong>first</strong> : <code>scanf</code> function will read any leading whitespace </p>

<p>the first <code>scanf(""%d"", &amp;numCourse)</code> will work as expected but the next <code>scanf(""%c"", &amp;letterGrade)</code> will consume leading whitespace so your input is incorrect and you will not get the right result.</p>

<p>to solve this problem just put a blank space before the conversion specifier:</p>

<pre><code>scanf("" %c"", &amp;letterGrade);
</code></pre>

<p><strong>second</strong> :</p>

<p>you should add <code>break</code> after <code>switch</code> cases because it will always take 
<code>numberGrade = 0.0</code> as default and will not take other cases</p>

<p>your program solution :</p>

<pre><code>int main()
{
    float gpa;
    float numberGrade = 0;
    float sum = 0;
    int i, numCourse;
    char letterGrade, modifier;
    printf(""Enter the number of course:"");
    scanf("" %d"", &amp;numCourse);

    for (i = 0; i &lt; numCourse; i++) {
        printf(""What grade did you earn?\n"");
        printf(""Enter A, B, C, D, or F: "");
        scanf("" %c"", &amp;letterGrade);


        switch (letterGrade)
        {
        case 'A': numberGrade = 4.0;
            break;
        case 'B': numberGrade = 3.0;
            break;
        case 'C': numberGrade = 2.0;
            break;
        case 'D': numberGrade = 1.0;
            break;
        default: numberGrade = 0.0;

        }

        printf(""Enter modifier - for letter grades A-, etc. + for letter grades B+, etc. , and _ for letter grades A, B, etc.: "");
        scanf("" %c"", &amp;modifier);

        if (modifier == '-')
            numberGrade = numberGrade - 0.3;
        else if (modifier == '+')
            numberGrade = numberGrade + 0.3;

        sum = sum + numberGrade;
    }
    gpa = sum / numCourse;
    printf(""The final gpa is %.2f.\n"", gpa);
    return 0;
}
</code></pre>
",4
42386501,42384723,-1,"<p>try this one, i have made some changes in your code.</p>

<pre><code>    #include &lt;stdio.h&gt;

int main()
{
    float gpa;
    float numberGrade = 0;
    float sum = 0;
    int i, numCourse;
    char letterGrade, modifier;
    printf(""Enter the number of course: "");
    scanf(""%d"", &amp;numCourse);

    for (i = 0; i &lt; numCourse; i++)
    {
        printf(""What grade did you earn?\n"");
        printf(""Enter A, B, C, D, or F: "");
        scanf("" %c"", &amp;letterGrade);

        switch (letterGrade)
        {
            case 'A':
                numberGrade = 4.0;
                break;
            case 'B':
                numberGrade = 3.0;
                break;
            case 'C':
                numberGrade = 2.0;
                break;
            case 'D':
                numberGrade = 1.0;
                break;
            default:
                numberGrade = 0.0;
                break;                
        }

        printf(
                ""Enter modifier - for letter grades A-, etc. + for letter grades B+, etc. , and _ for letter grades A, B, etc.: "");
        scanf("" %c"", &amp;modifier);

        if (modifier == '-')
            numberGrade = numberGrade - 0.3;
        else if (modifier == '+')
            numberGrade = numberGrade + 0.3;

        sum = sum + numberGrade;
    }
    gpa = sum / numCourse;
    printf(""The final gpa is %.2f.\n"", gpa);
    return 0;
}
</code></pre>
",1
43942255,43942216,1,"<p>You have this code...</p>

<pre><code>avg = freq*100/count;
</code></pre>

<p>...freq is an array so it should be</p>

<pre><code>avg = freq[i]*100/count;
</code></pre>
",0
43942280,43942216,1,"<p>You are missing the array index in the following line:</p>

<pre><code>avg = freq*100/count;
</code></pre>

<p>It should be:</p>

<pre><code>avg = freq[i]*100/count;
</code></pre>

<p>Array pointer cannot be multiplied :)</p>
",0
43942300,43942216,1,"<p>here freq is array of float numbers. array name is a pointer to memory location of first position i.e. freq points to freq[0].</p>

<p>therefore when you use ""avg = freq*100/count;"" the freq is (float*) and it expects float. so use <strong>freq[i]</strong></p>
",0
43942364,43942216,0,"<p>There are multiple errors in this code:
1) you use  unitializated vars:</p>

<pre><code>float count=0, avg=0;
</code></pre>

<p>2) avg is an array</p>

<pre><code> avg = freq[i]*100/count;
</code></pre>

<p>3)i is a float, but you want a integer (or just a char)</p>

<pre><code>char i=0;
</code></pre>

<p>4) while(apl==-1) is not correct, the do while will always terminated(excep when there will be an error. use</p>

<pre><code>while(apl!=-1)
</code></pre>
",2
43967337,43966967,1,"<p><code>arr</code> is an array of arrays of <code>int</code> (which immediately gets converted to a pointer to an array of int`; look up ""array to pointer decay"" if you are not sure why is this so).</p>

<p><code>arr[0]</code> is an array of <code>int</code> (which immediately gets converted to a pointer to <code>int</code>).</p>

<p><code>arr[0][0]</code> is an <code>int</code>.</p>

<p><code>&amp;arr[0][0]</code> is a pointer to <code>int</code>.</p>

<p>Your function requires a pointer to an array of <code>int</code> (you can use an array of arrays of <code>int</code>, which, as we already know, immediately gets converted to a pointer to an array of <code>int</code>, which is just what your function needs). (The parameter type is written as <code>int arr[][x]</code>, that is, an array of arrays of <code>int</code>, but it is a deception. It's a pointer to an array of <code>int</code>. Look up ""parameter type adjustment"" if you are not sure why is this so).</p>

<p>A pointer to <code>int</code> is not the same as a pointer to an array of <code>int</code>, which is why your compiler complains.</p>

<p>Fortunately you already have <code>arr</code>, which is an array of arrays of <code>int</code>, which immediately gets converted to a pointer to an array of <code>int</code>, which is exactly what your function needs.</p>

<p>I'm deliberately not touching the issue of array sizes.</p>
",0
42557667,42557396,0,"<p>You did not allocate memory to hold your strings. Do</p>

<pre><code>for(x=0; x&lt;size; x++){
    name[x] = (char*)malloc((size_t)64);
    scanf(""%s"", name[x]);
    printf(""&lt;one&gt;\n"");
}
</code></pre>
",0
39130704,39129394,1,"<p>You need to know what parameter types the <code>sendfile()</code> function takes.
See <a href=""http://man7.org/linux/man-pages/man2/sendfile.2.html"" rel=""nofollow"">sendfile() man page.</a></p>

<p>Notice that the 3rd parameter that you are calling offset is of type <code>off_t *</code>. Make sure you are passing in a pointer to type <code>off_t</code> and your error will be fixed.</p>

<p>So instead of defining offset as:</p>

<p><code>int offset;</code></p>

<p>Try</p>

<p><code>off_t offset;</code></p>
",0
47489276,47487724,0,"<ol>
<li><p>The largest value of <code>b</code> passed to <code>L</code> would be at least 2,168,393,136. However, if an <code>int</code> is 32 bits, this overflows the maximum value of an <code>int</code>, 2,147,483,647. <code>b</code> should be made an <code>unsigned int</code> (or any wider integer type).</p></li>
<li><p>The function <code>L</code> computes <code>5*b*b + 8*b + 4</code>. Since the largest <code>b</code> is slightly over 2<sup>31</sup>, the mathematical value of this expression is somewhat over 2<sup>64</sup>. Unless <code>unsigned long long</code> is wider than 64 bits, this exceeds the maximum value of <code>unsigned long long</code>, with the result that an undesired value is computed.</p></li>
<li><p><code>L</code> applies <code>sqrt</code> to <code>X1</code> (and <code>X2</code>). This converts the value to <code>double</code>, which commonly has 53 bits of precision. Since the value has 65 bits, 12 bits are lost. Fortunately, the derivative of square root is very small at this magnitude, so large changes in the input produce small changes in the output. So the result of <code>sqrt</code> should be near the exact mathematical result, and it should be feasible to adjust the result to find the integer nearest the exact mathematical square root, and then that can be used to test whether <code>X1</code> is an exact square. Alternatively, an integer square root routine could be written.</p></li>
<li><p>Once the above problems are fixed, the program may continue further than before, which will result in larger values of <code>b</code> being used. Continuing evaluation may be necessary to ensure the types are wide and precise enough for the work. (I tried a kludge to extend the domain the code can support. It is currently running with b exceeding 16 billion. I could have a bug, but I think you should be prepared for considerably larger numbers.)</p></li>
</ol>

<p>In summary, the native types of C and common implementations do not support doing this arithmetic directly. It is necessary to write special code to handle the large numbers or to work around them.</p>

<p>As the point of Euler Project problems like this is to push the boundaries of built-in arithmetic, that is where the answer should stop¡ªthe student should continue thinking from there.</p>
",0
45104858,45104764,2,"<p>Every variable is stored in binary (i.e as a number,)  <code>char</code>s, are just numbers of a specific size.  </p>

<p>They represent a character when encoded using some character encoding, the ASCII standard (<a href=""http://www.asciitable.com"" rel=""nofollow noreferrer"">www.asciitable.com</a>) is here.</p>

<p>As in the <a href=""https://stackoverflow.com/questions/45104764/relationship-between-char-and-ascii-code#comment77180585_45104764"">@Igor comment</a>, if you run the following code; you see the ASCII character, Decimal and Hexadecimal representation of your <code>char</code>.</p>

<pre><code>char c = 'A'; 
printf(""%c %d 0x%x"", c, c, c);
</code></pre>

<p>Output:</p>

<blockquote>
  <p>A 65 0x41</p>
</blockquote>

<p>As an exercise to understand it better, you could make a program to generate the ASCII Table yourself.</p>
",0
45104867,45104764,3,"<blockquote>
  <p>So, is char considerd as a number or a character or both?</p>
</blockquote>

<p>Both. It is an integer, but that integer value represents a character, as described by the character encoding of your system. The character encoding of the system that your computer science teacher uses happens to be ASCII.</p>

<blockquote>
  <p>Can we print out the number behind a char?how?</p>
</blockquote>

<p>C++ (as the question used to be tagged):</p>

<p>The behaviour of the character output stream (such as <code>std::cout</code>) is to print the represented character when you insert an integer of type <code>char</code>. But the behaviour for all other integer types is to print the integer value. So, you can print the integer value of a <code>char</code> by converting it to another integer type:</p>

<pre><code>std::cout &lt;&lt; (unsigned)'c';
</code></pre>

<p>C:</p>

<p>There are no templated output streams, so you don't need to do explicit conversion to another integer (except for the signedness). What you need is the correct format specifier for <code>printf</code>:</p>

<pre><code>printf(""%hhu"", (unsigned char)'c');
</code></pre>

<p><code>hh</code> is for integer of size <code>char</code>, <code>u</code> is to for unsigned as you probably are interested in the unsigned representation.</p>
",6
45104868,45104764,3,"<p>A <code>char</code> can hold a number, it's the smallest integer type available on your machine and must have <em>at least</em> 8 bits. It is synonymous to a <em>byte</em>.</p>

<p>It's <em>typical</em> use is to store the codes of characters. Computers can only deal with numbers, so, to represent characters, numbers are used. Of course you must agree on which number means which character.</p>

<p>C doesn't require a specific <em>character encoding</em>, but most systems nowadays use a superset of ASCII (this is a very old encoding using only 7 bits) like e.g. UTF-8.</p>

<p>So, if you have a <code>char</code> that holds a character and you add or subtract some value, the result will be another number that happens to be the code for a <em>different</em> character.</p>

<p>In ASCII, the characters <code>0</code>-<code>9</code>, <code>a</code>-<code>z</code> and <code>A</code>-<code>Z</code> have adjacent code points, therefore by adding e.g. 2 to <code>A</code>, the result will be <code>C</code>.</p>

<blockquote>
  <p>Can we print out the number behind a char?</p>
</blockquote>

<p>Of course. It just depends whether you <em>interpret</em> the value in the <code>char</code> as just a number or as the code of a character. E.g. with <code>printf</code>:</p>

<pre><code>printf(""%c\n"", 'A');                   // prints the character
printf(""%hhu\n"", (unsigned char)'A');  // prints the number of the code
</code></pre>

<p>The cast to <code>(unsigned char)</code> is only needed because <code>char</code> is allowed to be either signed or unsigned, we want to treat it as unsigned here.</p>
",2
45104896,45104764,3,"<p>A <code>char</code> takes up a single byte.  On systems with an 8 bit byte this gives it a range (assuming <code>char</code> is signed) of -128 to 127.  You can print this value as follows:</p>

<pre><code>char a = 65;
printf(""a=%d\n"", a);
</code></pre>

<p>Output:</p>

<pre><code>65
</code></pre>

<p>The <code>%d</code> format specifier prints its argument as a decimal integer.  If on the other hand you used the <code>%c</code> format specifier, this prints the character associated with the value.  On systems that use <a href=""https://en.wikipedia.org/wiki/ASCII"" rel=""nofollow noreferrer"">ASCII</a>, that means it prints the ASCII character associated with that number:</p>

<pre><code>char a = 65;
printf(""a=%c\n"", a);
</code></pre>

<p>Output:</p>

<pre><code>A
</code></pre>

<p>Here, the character <code>A</code> is printed because 65 is the ASCII code for <code>A</code>.</p>

<p>You can perform arithmetic on these numbers and print the character for the resulting code:</p>

<pre><code>char a = 65;
printf(""a=%c\n"", a);
a = a + 1;
printf(""a=%c\n"", a);
</code></pre>

<p>Output:</p>

<pre><code>A
B
</code></pre>

<p>In this example we first print <code>A</code> which is the ASCII character with code 65.  We then add 1 giving us 66.  Then we print the ASCII character for 66 which is <code>B</code>.</p>
",0
45107232,45104764,1,"<blockquote>
  <p>My computer science teacher taught us that which data type to declare depends on the size of the value for a variable you need.</p>
</blockquote>

<p>This is correct.  Different types can represent different ranges of values.  For reference, here are the various integral types and the <em>minimum</em> ranges they must be able to represent:</p>

<pre><code>Type                             Minimum Range
----                             -------------
signed char                       -127...127
unsigned char                        0...255
char                same as signed or unsigned char, depending on implementation
short                           -32767...32767
unsigned short                       0...65535
int                             -32767...32767
unsigned int                         0...65535
long                       -2147483647...2147483647
unsigned long                        0...4294967295
long long         -9223372036854775807...9223372036854775807
unsigned long long                   0...18446744073709551615
</code></pre>

<p>An implementation may represent a larger range in a given type; for example, on most modern implementations, the range of an <code>int</code> is the same as the range of a <code>long</code>.  </p>

<p>C doesn't mandate a fixed size (bit width) for the basic integral types (although unsigned types are the same size as their signed equivalent); at the time C was first developed, byte and word sizes could vary between architectures, so it was easier to specify a minimum range of values that the type had to represent and leave it to the implementor to figure out how to map that onto the hardware.  </p>

<p>C99 introduced the <code>stdint.h</code> header, which defines fixed-width types like <code>int8_t</code> (8-bit), <code>int32_t</code> (32-bit), etc., so you can define objects with specific sizes if necessary.  </p>

<blockquote>
  <p>So, is char considerd as a number(since we can do math with it ) or a character or both?</p>
</blockquote>

<p><code>char</code> is an integral data type that can represent values in <em>at least</em> the range <code>[0...127]</code><sup>1</sup>, which is the range of encodings for the <em>basic execution character set</em> (upper- and lowercase Latin alphabet, decimal digits <code>0</code> through <code>9</code>, and common punctuation characters).  It can be used for storing and doing regular arithmetic on small integer values, but that's not the typical use case.  </p>

<p>You can print <code>char</code> objects out as a characters or numeric values:</p>

<pre><code>#include &lt;limits.h&gt; // for CHAR_MAX
...
printf( ""%5s%5s\n"", ""dec"", ""char"" );
printf( ""%5s%5s\n"", ""---"", ""----"" );

for ( char i = 0; i &lt; CHAR_MAX; i++ )
{
  printf(""%5hhd%5c\n"", i, isprint(i) ? i : '.' );
}
</code></pre>

<p>That code will print out the integral value and the associated character, like so (this is ASCII, which is what my system uses):</p>

<pre><code>...
65    A
66    B
67    C
68    D
69    E
70    F
71    G
72    H
73    I 
...
</code></pre>

<p>Control characters like <code>SOH</code> and <code>EOT</code> don't have an associated printing character, so for those value the code above just prints out a <code>'.'</code>.  </p>

<p>By definition, a <code>char</code> object takes up a single <em>storage unit</em> (byte); the number of bits in a single storage unit must be <em>at least</em> 8, but could be more.  </p>

<p><hr>
<sup></p>

<ol>
<li>Plain <code>char</code> may be either signed or unsigned depending on the implementation so it can represent additional values outside that range, but it must be able to represent *at least* those values.  
</ol>

<p></sup></p>
",0
45078270,45078103,2,"<p>A lot of what you are asking depends on your development environment.</p>

<p>Your development environment should be offering you some means to somehow configure how your program is launched, by modifying something called ""debug configuration"" or ""launch configuration"" or something along these lines.  Note that these options are different from the general options of the development environment, because they differ from project to project.</p>

<p>Right now it appears that nothing is configured, so the current directory of your application is the same directory as the directory where the <code>.exe</code> file is.  Since you are running your debug build, the <code>.exe</code> file is generated under <code>Documents\Debug</code>, and that's its working directory.  So, in the launch configuration specify that you want its working directory to be in <code>C:\Users\Bob\Documents</code>.</p>

<p>Alternatively, you can of course try opening ""..\test.txt"", but this will fail if you ever try to run your <code>.exe</code> under deployment conditions, where both the <code>.exe</code> and <code>""test.txt""</code> are probably going to be in the same directory.</p>
",1
45078233,45078103,3,"<p>Since you don't pass a path to <code>fopen</code> it will open files in the current working directory, which happens to be the Debug directory in your case.</p>

<p>Pass a full path instead, e.g.</p>

<pre><code>fpointer = fopen(""C:\\Users\\Bob\\Documents\\test.txt"", ""r"");`
</code></pre>

<p>or change the working directory (either programatically, or in your IDE settings).</p>
",4
42484031,42483830,0,"<pre><code>InitData(&amp;TestDataArr)
</code></pre>

<p>is not equal to</p>

<pre><code>InitData(&amp;TestDataArr[0])
</code></pre>

<p>cause <code>TestDataArr[0]</code> is equal to <code>*TestDataArr</code> and then <code>InitData(&amp;TestDataArr[0])</code> equal to <code>InitData(&amp;*TestDataArr)</code> or <code>InitData(TestDataArr)</code>.
You can see, that</p>

<pre><code>InitData(&amp;TestDataArr)
</code></pre>

<p>is the address of <code>TestDataArr</code> and</p>

<pre><code>InitData(TestDataArr)
</code></pre>

<p>just the array.
That are also different types!</p>
",5
43183737,43181731,0,"<pre><code>#include &lt;stdio.h&gt;
void main()
{
  char ch='/';
  while(ch!=':')
  { 
      if(isdigit(ch))
      {
        printf(""%c\n "",ch);
      }
      ch++;
   }
}
</code></pre>
",3
43183751,43181731,1,"<p>There's countless of ways to write obscure, nonsense C code. One example:</p>

<pre><code>#include &lt;stdio.h&gt;

int main (void)
{
  for(size_t i=!""A string.""; i&lt;sizeof(""A string.""); i++)
    printf(""%zu "", i);
}
</code></pre>

<p>Or, more creatively, in pure standard C:</p>

<pre><code>??= include""stdio.h""

#define wtf(x,...) x%:%: nt ma ##x %:%:n(vo ##x %:%:d) ??&lt;for(x %:%:nt x =(+ __LINE__??!??!\
+__LINE__) +- !!""WTF""; x&lt;=__LINE__; +i++)??&lt;\
pr ##x %:%:nt %:%:f((char[])&lt;%'%','d',' ',!""WTF""??&gt;,-+-x);%&gt;??&gt;



                                   wtf(i)
</code></pre>
",1
43182627,43181731,1,"<pre><code>#include &lt;stdio.h&gt;

#define ZERO ('a' - 'a')
#define ONE ((int)(sizeof (char)))
#define TWO (ONE + ONE)
#define THREE (TWO + ONE)
#define SIX (TWO * THREE)
#define SEVEN (SIX + ONE)

int main(void) {
    printf(""%d%d%d\n"", SEVEN, TWO, SIX);
    /* Assume C99 and implicit return 0; */
}
</code></pre>
",0
43187565,43181731,2,"<pre><code>#include &lt;stdio.h&gt;

int main(void){
    for(int n = !&amp;n; snprintf(NULL, !&amp;n, ""%d"", n)==!!&amp;n; printf(""%d\n"", n++));
}
</code></pre>
",0
43191752,43181731,-2,"<p>You can check the values of <a href=""http://www.asciitable.com/"" rel=""nofollow noreferrer"">ASCII code</a> an use the char with %d placeholder for extract the number.
E.g. :</p>

<pre><code>#include &lt;stdio.h&gt;

int main(int argc, char **argv)
{
    char a='H';
    printf(""%d"",a);
    return 0;
}
</code></pre>
",0
42542454,42540945,1,"<p><a href=""https://docs.google.com/file/d/0B5Gl6fAWcS-_UUp2ZW5jXzdKcVU/view"" rel=""nofollow noreferrer"">A small book, a must have.</a></p>

<p>This code works as desired:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void combinaisons( const char * input[], size_t index, size_t count, char * str ) {
   const char * group = input[index];
   for( size_t i = 0, len = strlen( group ); i &lt; len; ++i ) {
      str[index] = group[i];
      if( index+1 &lt; count ) {
         combinaisons( input, index+1, count, str );
      }
      else {
         printf( ""%s\n"", str );
      }
   }
   str[index] = '\0';
}

int main() {
   const char * groups[] = {
      ""ABC"", /* 2 */
      ""DEF"", /* 3 */
      ""GHI"", /* 4 */
      ""JKL"", /* 5 */
      ""MNO"", /* 6 */
      ""PQRS"",/* 7 */
      ""TUV"", /* 8 */
      ""WXYZ"",/* 9 */
   };
   const char * input[100];
   size_t count = 0;
   char c;
   while(( c = getchar()) &gt; 20 &amp;&amp; count &lt; 100 ) {
      if( c &gt;= '2' || c &lt;= '9' ) {
         input[count++] = groups[c-'2'];
      }
   }
   char str[100] = """";
   combinaisons( input, 0, count, str );
   return 0;
}
</code></pre>

<p>Execution trace:</p>

<pre><code>246
AGM
AGN
AGO
AHM
AHN
AHO
AIM
AIN
AIO
BGM
BGN
BGO
BHM
BHN
BHO
BIM
BIN
BIO
CGM
CGN
CGO
CHM
CHN
CHO
CIM
CIN
CIO
</code></pre>

<p>Some explanations:</p>

<p><code>groups</code> is an array of string (i.e. const char *). It can be indexed by the char, for example '2' as index 0 with c-'2'.</p>

<p><code>input</code> store the selected groups, with '246', input contains <code>{""ABC"",""GHI"",""MNO""}</code>.</p>

<p><code>str</code> is a string built from the letters picked into <code>input</code>, at index 0: A, B or C, at index 1: G, H or I, and so on.</p>

<p>The recursion is used to apply the same treatment on different index of <code>str</code> from different group extracted from <code>input</code>. The recursion terminates when no remaining group exist, when all the group from input are consumed. An important instruction is the last of <code>combinaisons</code>: <code>str[index] = '\0';</code>, it truncate the string by removing the last char added, because the recursion backtrack. I suggest to execute this code step by step with a debugger and to observe how <code>str</code> is filled.</p>

<p><code>c = getchar()</code> read a single character from standard input, <a href=""https://linux.die.net/man/3/getchar"" rel=""nofollow noreferrer"">see documentation</a>.</p>

<p>The condition <code>&gt; 20</code> is used to detect any non printable character, as cr to end the <code>while</code> loop.</p>

<p><code>size_t</code> is the type of <code>count</code>, <code>count</code> is incremented each time a number is read from stdin with the instruction <code>input[count++]</code> which means <em>use count to index input array then increment it</em>, it's a post incrementation. The first index is zero.</p>
",5
41199660,41199443,0,"<p>You can do this by nesting for loops, like you are already doing. For example:</p>

<pre><code>int N=3; /* size of matrix */
for (int j=0; j &lt; N; j++) { /* for each column... */
   printf(""starting column %d\n"", j);
   for (int i=1; i &lt; N; i++) { /* for each row except the first one... */
       printf(""  do something i=%d j=%d\n"", i, j);
   }
}
</code></pre>

<p>It will end up printing:</p>

<pre class=""lang-none prettyprint-override""><code>starting column 0
  do something i=1 j=0
  do something i=2 j=0
starting column 1
  do something i=1 j=1
  do something i=2 j=1
starting column 2
  do something i=1 j=2
  do something i=2 j=2
</code></pre>
",0
41199702,41199443,1,"<p>Instead of <code>i++</code>, you can use <code>i += 3</code> if all you want to do is count by 3s through the loop. </p>
",0
42530897,42530570,2,"<pre><code>#include &lt;stdio.h&gt;

int main(void) {
    int height=5;
    const char* bricks = ""###############""
    for(int i=1; i&lt;height+1; ++i)
    {
        printf(""%*.*s      %.*s\n"", height,i,bricks, i,bricks);
    }
    return 0;
}
</code></pre>

<p><a href=""http://ideone.com/i5jtEJ"" rel=""nofollow noreferrer"">IDEOne Link</a></p>

<p>Output:</p>

<pre><code>    #      #
   ##      ##
  ###      ###
 ####      ####
#####      #####
</code></pre>
",0
42530726,42530570,0,"<pre><code>for(star=1;star&lt;=row*2;star++){

        printf(""#"");
    if(star == row)
    printf("" "");

 }
</code></pre>

<p><strong>Modify the second loop as above</strong></p>
",0
42531061,42530570,0,"<p>The following code is <strong>simple to understand</strong> and <strong>gives you full control</strong> over the peramid: </p>

<p>You can change also the height (number of rows) and the size of the half peramid (in example - 4). Then it prints <code>*</code> as the bricks in the image, <code>spaces</code> as the spaces and <code>##</code> as the space between them.</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    int row,col,space,n1=4, n2=4;

    for(row=1;row&lt;=n1;row++){

    for(space=n2-row;space&gt;=0;space--)
        printf("" "");

    for(col=1;col&lt;=row;col++)
        printf(""*"");

    printf(""##"");

    for(col=1;col&lt;=row;col++)
        printf(""*"");      

    for(space=n2-row;space&gt;=0;space--)
        printf("" "");

    }

    printf(""\n"");
}
</code></pre>

<p><strong>Example output:</strong></p>

<pre><code>    *##*    
   **##**   
  ***##***  
 ****##****  
</code></pre>
",0
41665650,41665454,1,"<p>Beginners should help beginners :-)</p>

<p>Here a slightly different approach:</p>

<pre><code>for (int i=0; i &lt;= 5; i++)
{
    for (int j=0; j&lt;5 ; j++)
    {
        if (j &gt;= i)
            printf(""%1d "", 5-i);
        else
            printf(""  "");
    }
    printf(""\n"");
}
</code></pre>
",0
41665543,41665454,0,"<p>You arr half way correct..just delete the 3 rd for loop inside the for loop..</p>

<pre><code>scanf(""%d"", &amp;N);

for(i=N; i&gt;=1; i--)
{
    //Logic to print spaces
    for(j=N; j&gt;i; j--)
    {
        printf("" "");
    }

    //Logic to print numbers
    for(j=1; j&lt;=i; j++)
    {
        printf(""%d "", i);
    }

    printf(""\n"");
}
</code></pre>
",0
41665587,41665454,3,"<p>Your program gives this output:</p>

<pre><code>5 5 5 5 5
 4 4 4 4
  3 3 3
   2 2
    1
</code></pre>

<p>To get the output you want requires one very simple change. Because the characters are spaced, you need an extra space here:</p>

<pre><code>//Logic to print spaces
for(j=N; j&gt;i; j--)
{
    printf(""  "");       // 2 spaces
}
</code></pre>

<p>New program output:</p>

<pre><code>5 5 5 5 5
  4 4 4 4
    3 3 3
      2 2
        1
</code></pre>
",0
41665596,41665454,0,"<p>try this</p>

<pre><code>int i, j, N;
    scanf(""%d"", &amp;N);
    for (int i = N; i &gt; 0; i--)
    {
        for (j = 0; j &lt; N - i; j++)
        {
            printf(""  "");
        }

        for(j = 1; j &lt;= i; j++)
        {
            printf(""%d "",i);
        }
        printf(""\n"");
    }
</code></pre>

<p>output:</p>

<pre><code>5 5 5 5 5 
  4 4 4 4 
    3 3 3 
      2 2 
        1 
</code></pre>
",1
41665603,41665454,7,"<p>We beginners should help each other.</p>

<p>Here you are</p>

<pre><code>#include &lt;stdio.h&gt;

int main( void ) 
{
    while ( 1 )
    {
        unsigned int n;

        printf( ""Enter a non-negative number (0 - exit): "" );

        if ( scanf( ""%u"", &amp;n ) != 1 || n == 0 ) break;

        printf( ""\n"" );

        for ( unsigned int i = 0; i &lt; n; i++ )
        {
            printf( ""%*u"", i + 1, ( n - i ) % 10 );
            for ( unsigned int j = i + 1; j &lt; n; j++  ) printf( ""%u"", ( n - i ) % 10 );
            printf( ""\n"" );
        }

        printf( ""\n"" );
    }

    return 0;
}
</code></pre>

<p>The program output might look like</p>

<pre><code>Enter a non-negative number (0 - exit): 10

0000000000
 999999999
  88888888
   7777777
    666666
     55555
      4444
       333
        22
         1

Enter a non-negative number (0 - exit): 5

55555
 4444
  333
   22
    1

Enter a non-negative number (0 - exit): 0
</code></pre>

<p>If you need to include a blank between outputted digits then the program can look like</p>

<pre><code>#include &lt;stdio.h&gt;

int main( void ) 
{
    while ( 1 )
    {
        unsigned int n;

        printf( ""Enter a non-negative number (0 - exit): "" );

        if ( scanf( ""%u"", &amp;n ) != 1 || n == 0 ) break;

        printf( ""\n"" );

        for ( unsigned int i = 0; i &lt; n; i++ )
        {
            printf( ""%*u"", 2 * i + 1, ( n - i ) % 10 );
            for ( unsigned int j = i + 1; j &lt; n; j++  ) printf( "" %u"", ( n - i ) % 10 );
            printf( ""\n"" );
        }

        printf( ""\n"" );
    }

    return 0;
}
</code></pre>

<p>For example its output might look like</p>

<pre><code>Enter a non-negative number (0 - exit): 5

5 5 5 5 5
  4 4 4 4
    3 3 3
      2 2
        1

Enter a non-negative number (0 - exit): 4

4 4 4 4
  3 3 3
    2 2
      1

Enter a non-negative number (0 - exit): 3

3 3 3
  2 2
    1

Enter a non-negative number (0 - exit): 2

2 2
  1

Enter a non-negative number (0 - exit): 1

1

Enter a non-negative number (0 - exit): 0
</code></pre>
",0
42614764,42613939,0,"<p>im sorry im making this as an answer, i just want you to really read it.
this code have tons of problems, ill just clarify most of them:</p>

<p>1) you are not declaring any of your functions</p>

<p>2) the way you call most of your functions is wrong</p>

<p>3) you are using tons of variable without initializing them, like <code>x</code></p>

<p>4)you cant put a non constant variable in array declaration, it must be a constant number, or use dynamic allocation. (for example <code>Stocks D[count]</code>)</p>

<p>and this is only what i saw from general look.</p>

<p>its look like you have some homework to do before you continue this code.</p>

<p>hope its helping somehow.</p>
",0
39313755,39313445,1,"<p>Your code has a series of errors. Some of them:</p>

<ol>
<li>You don¡ät need (in this case) to use spaces in scanf. This is causing a reading error.</li>
<li>You don't need to pass an array address to a function in order to alter its values. Arrays are always passed by reference. So change your function from <code>void sort(double*[],int);</code> to <code>void sort(double[],int);</code>, make the necessary corrections inside the function and call it using <code>sort(arr,l);</code> instead of <code>sort(&amp;arr,l);</code></li>
<li>Your min() function declares an uninitialized variable <code>minP</code>, so this variable contains garbage from your memory. The for() loop isn't entering none of the both if() conditions, so your function ends and returns the still uninitialized variable <code>minP</code>. This random value is then used to access an index in your array: <code>j = min(0, arr, l);</code> min returns an random number and then <code>arr2[i] = arr[j];</code> accessing forbidden memory region, which is causing your segmentation fault error. The same problem is occurring with the variables <code>maxP</code> and <code>maxA</code> in the <code>mode()</code> function.</li>
</ol>

<p>You must always be careful when accessing your arrays to not go beyond its bounds and always be sure that variables will be initialized when using them. And as others have commented, I also highly recommend you to learn how to debug your programs, since this will help you to analyze its execution and trace bugs.</p>
",2
39313971,39313445,1,"<p>I tracked your segmentation fault to your <code>sort()</code> routine called by <code>median()</code>.  Rather than fix <code>sort()</code>, I substituted <code>qsort()</code> from the library to convince myself that's the problem:</p>

<pre><code>// Median Function:
// Uses the Sort Function. Assuming that works, returns the median.

int comparator(const void *p, const void *q) {

    double a = *((double *) p);
    double b = *((double *) q);

    return (a &gt; b) - (a &lt; b); // compare idiom
}

double median(double array[], int length) { 
    // sort(array, length);

    qsort(array, length, sizeof(double), &amp;comparator);

    double d = array[length / 2];

    if (length % 2 != 0) {
        return d;
    }

    double dd = array[(length / 2) - 1];

    return (d + dd) / 2;
}
</code></pre>

<p>For the example list of numbers provided, after correcting the rest of the code, this returns a median of 44627.5</p>

<p><strong>Other fixes:</strong></p>

<p>You're missing a final newline here:</p>

<pre><code>printf(""%.1lf\n%.1lf\n%.0lf"",mean(arr,i),median(arr,i),mode(arr,i));
</code></pre>

<p>You should probably initialize the variables in <code>mode()</code>:</p>

<pre><code>double mode(double array[], int length) {
    int maxA = INT_MIN;
    int maxP = -1;

    for (int i = 0; i &lt; length; i++) {
        int j = numberOf(array[i], array, length);

        if (j &gt; maxA) {
            maxA = j;
            maxP = i;
        } else if (j == maxA &amp;&amp; array[maxP] &gt; array[i]) {
            maxP = i;
        }
    }

    return array[maxP];
}
</code></pre>
",0
41207250,41207197,2,"<p>The standard (ISO/IEC 9899:201x 6.79->10) says:</p>

<blockquote>
  <p>If an object that has automatic storage duration is not initialized
  explicitly, its value is indeterminate.</p>
</blockquote>

<p>Some compilers may initialize them to zero, though you can't expect the same behavior for all the compilers.</p>

<p>However, I see that question is <strong>why is the counter ¡°c¡± is incremented?</strong></p>

<p>The fact that you haven't initialized a variable doesn't stop <code>C</code> from incrementing it. However, re-iterating the above point, the starting value is indeterminate.</p>

<p>To conclude, your programme has ambiguous behavior</p>

<p>To get the expected results change the statement</p>

<pre><code>int i,c,j,l; 
</code></pre>

<p>to </p>

<pre><code>int i,c=0,j,l; // c is initialized to zero, all others are at some point in the  pgm
</code></pre>
",1
41210219,41210103,0,"<p>To get the length (which is a better term since it has little to do with the size of the buffer it's in) of a string, use <code>strlen()</code>:</p>

<pre><code>const size_t len = strlen(buff);
</code></pre>

<p>This will count the number of characters before the first 0-character, which is how strings are terminated (""end-marked"") in C.</p>

<p>Now you can iterate using an index if you want:</p>

<pre><code>for(size_t i = 0; i &lt; len; ++i)
  printf(""The character at index %zu is '%c'\n"", i, buff[i]);
</code></pre>

<p>Note that many C programmers would iterate over the buffer directly instead, using a pointer:</p>

<pre><code>for(const char *s = buff; *s != '\0'; ++s)
  printf(""Found character '%c'\n"", *s);
</code></pre>
",0
41210165,41210103,0,"<p>A C-""string"" of 1000 characters requires a buffer of 1000+1=1001 <code>char</code>s, as a C-""string""'s end is indicated by an additional <code>0</code>.</p>

<p>So to enable your code to actually read 1000 characters, change</p>

<pre><code>const int buffsize = 1000;
</code></pre>

<p>to be</p>

<pre><code>const int buffsize = 1000 + 1;
</code></pre>

<p>and to make sure to also just scan in 1000 <code>char</code>s and not overflow <code>buff</code>, change</p>

<pre><code>fscanf(fp, ""%s"", buff);
</code></pre>

<p>to be</p>

<pre><code>fscanf(fp, ""%1000s"", buff);
</code></pre>
",3
41223194,41223024,-2,"<p>In wrong way you are handling the array. first read the array concept and try again. </p>

<p>printf(""%c"" , s); will print only initial value with is ""HackerRank "".</p>

<p>strcat(s, a); will generate the new string object.</p>
",0
41224151,41223024,1,"<p><code>sum = i+j</code> This statement does not have a semicolon and post the problem you are facing not the code as it is . First see that the code is error free</p>
",0
44712257,44711784,0,"<p>If you really want to do this with recursion than do this:</p>

<pre><code>#include &lt;stdio.h&gt;

int recursion() {
    int c = getchar();
    if(c != '\n' &amp;&amp; c != EOF) {
        int n = recursion();
        printf(""%c"", c);
        return n;
    } else {
        return c;
    }
}

int main (void) {
    while(recursion() != EOF) printf(""\n"");
}
</code></pre>
",0
44711922,44711784,1,"<p>First, you must make sure that your function ""Recursion"" can work to a single line. Your function ""Recursion"" may be declared like this:</p>

<pre><code>//source must have pointed to storage space of the line and the 
//storage space of line must be not read-only. As we know ""dogs"" is  
// a constant value you can't change.

int Recursion(char *source,int length);
</code></pre>

<p>Inputting the string ""dogs"" to the Recursion, the output must be the ""sgod"".</p>

<p>Then, you can read each line of the file and input them  to this function Recursion so that you can get the result you want.</p>

<p>I think the function Recursion may have bugs or you are failed to read line from the file. If you can give me detail code about function Recursion or the module of reading file, it is easy to figure out the error.</p>

<p>You are using the function getchar() instead of reading line from the file. So 'EOF' is not right and should be '\n'. You also should't using while in Recursion because it is already a recursion function. So the right code is following:</p>

<pre><code>void Recursion()
{
  int c;
  if((c = getchar()) != '\n')
  {
     Recursion(c);
     printf(""%c"",c);
  }
  else
     return;
}
</code></pre>

<p>I think your code is not good. In my opinion,  the function to reverse the string does't need Recursion and just likes this:</p>

<pre><code>int Recursion(char *source,int length);
</code></pre>

<p>so that you can divide the program into separate modules---read line and reverse. Thus the main function just likes this:</p>

<pre><code>int main()
{
    int fd = open();

    while(1)
    {
       // 1.read line
       ....
       //2. is EOF?
       break;
       //3. reverse line
       Recursion(line,strlen(line));
    }
}
</code></pre>

<p>I hope that can help you.</p>
",7
45702348,45701591,4,"<p>You can look up ""pointer arithmetic"" if you want to know more and/or my answer will not help.</p>

<p><strong>Explanation:</strong> </p>

<p><code>int *p[]={a,a+1,a+2,a+3,a+4};</code> fills the array <code>p</code> with pointers to each element in array <code>a</code>. It is equivalent to <code>int *p[]={&amp;a[0],&amp;a[1],&amp;a[2],&amp;a[3],&amp;a[4]}</code>. <code>p[0]</code> points to <code>a[0]</code>, <code>p[1]</code> points to <code>a[1]</code> and so on.</p>

<p><code>int **ptr=p;</code> then creates pointer that points at beginning of array <code>p</code>. That is, it is equivalent to <code>int **ptr=&amp;p[0];</code>.</p>

<p><code>ptr++</code> increments <code>ptr</code>, so that it points to next element. In this case, result is same as <code>ptr = &amp;p[1];</code>.</p>

<p>Then, when printing numbers:</p>

<p>subtracting pointers (pointer arithmetic) means that result is equal to number of elements that can fit between two operands. Because you incremented ptr line before, they are exactly 1 element apart (that is, <code>sizeof(int *)</code>). <code>ptr</code> points to <code>p[1]</code>, and <code>p</code> points to <code>p[0]</code>.</p>

<p>Same goes for <code>*ptr - a</code>, they are 1 element apart (only in this case, it is <code>sizeof(int)</code>). <code>*ptr</code> (that is, <code>p[1]</code>) points to <code>a[1]</code>, <code>a</code> points to <code>a[0]</code>.</p>

<p>And <code>ptr</code> points to <code>p[1]</code>, which points to <code>a[1]</code>, which is <code>3</code>, therefore <code>**ptr</code> is <code>3</code>.</p>

<p><strong>Code warnings:</strong></p>

<p>As pointed out by David Bowling, the <code>printf</code> statement uses the wrong format specifiers for the provided arguments. As result of pointer subtraction, for example <code>ptr-p</code>, is of type <code>ptrdiff_t</code>, correct format specifier is <code>%td</code>: <code>printf(""\n%td %td %d\n"",ptr-p,*ptr-a,**ptr);</code></p>

<p>Using <code>%d</code> specifier is used with <code>int</code> type and causes undefined behavior when used with incorrect types.</p>

<p>You can see what specifiers to use with which types for example here: <a href=""http://www.cplusplus.com/reference/cstdio/printf/"" rel=""nofollow noreferrer"">http://www.cplusplus.com/reference/cstdio/printf/</a></p>
",5
43960604,43960247,2,"<p><code>realloc</code> takes a pointer to dynamically assigned memory and resizes the memory block. An important point that people less experienced with dynamic memory often miss is that the pointer returned by <code>realloc</code> may not be the same as the pointer passed in (and usually isn't). Generally, the heap does not have enough contiguous memory to do the requested expansion, so it finds a new block of memory large enough to fit it and copies the previous contents in.</p>

<p>The first thing I notice about your code is that you perform an unsafe <code>realloc</code>:</p>

<pre><code>buffer = realloc(buffer, BUFFER_SIZE + new_word_len - old_word_len);
</code></pre>

<p>By assigning a pointer to its own <code>realloc</code>, you run the risk that the OS cannot complete the allocation and returns <code>NULL</code>. If that occurs, you've lost the pointer to your old memory and you have a memory leak on your hands. To properly <code>realloc</code> (and I'm guessing you'll need to do this anyway to fix my next point), assign the results of <code>realloc</code> to a different pointer, confirm it's not <code>NULL</code>, and then overwrite the pointer.</p>

<p>But I think the main problem with your code lies here:</p>

<pre><code>buffer = init;
</code></pre>

<p>If I understand correctly, the purpose of this statement is to return <code>buffer</code> to the beginning of the string. However, the memory that <code>init</code> pointed to has been freed by the <code>realloc</code>, and you end up dereferencing the dangling pointer. You'll need to store a reference to the beginning of the new memory returned by <code>realloc</code>.</p>
",2
42662782,42662753,3,"<p><strong>Important note:</strong> Pointer arithmetic on a pointer that does not point to an array is undefined behavior. You can get 16, but you can also get a crash, for example, if the implementation chooses to produce a trap representation for the result.</p>

<p>This is pointer arithmetic: when you add a number <code>x</code> to a pointer to <code>T</code>, numeric value that corresponds to the pointer is increased by <code>x * sizeof(T)</code>.</p>

<p>In your case, the numeric value of the pointer is zero, <code>x</code> is 4, and <code>sizeof(int)</code> is also 4. <code>4*4</code> yields 16.</p>
",3
42662791,42662753,1,"<p>Pointer arithmetic in C use the type's size as an unit; adding 1 to int* will make it advance by 4 (assuming int is 32bit).</p>

<p>EDIT: pointer arithmetic on invalid pointers (including NULL) is undefined behavior.</p>
",0
43184802,43176527,0,"<p>You cannot do it with your existing code where a single scanf statement is used to e ter both the values. Something like this can be tried:</p>

<pre><code>void main(){
   int a;char b;
    printf(""Enter two values\n"");
    scanf(""%d"",&amp;a);
    top:
    scanf(""%c"",&amp;b);
    if(b=='\n'){
        printf(""Missing value\n"");
        goto top;
    }
    printf(""I got all values"");
}
</code></pre>
",0
45721520,45716669,1,"<p>You can add integers together regardless of the base because they are all stored as binary values anyway.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main(void){

    char tab[] = ""10"";
    int num = atoi(tab);
    int num2 = 0x6000;
    int sum = num + num2;
    char tab2[20];

    sprintf(tab2, ""%04X"", sum);
    puts(tab2);
}
</code></pre>
",0
39627925,39627860,1,"<p>I recommend looking at the return value from <code>scanf</code>.  It is likely returning zero.  It is failing and not storing a value in <code>num</code>.  The <code>2</code> is likely the indeterminate value that was on the stack when the program started.</p>

<p>If you want to read the value that was input, then use <code>fgets</code> to read the input into the buffer and then <code>sscanf</code> to extract it.</p>
",0
39628025,39627860,1,"<p><code>int num;</code> leaves <code>num</code> uninitialized. When you input <code>""dog""</code>, the <code>scanf</code> operation doesn't match anything against <code>num</code>, so nothing is stored in it. Thus when you <code>printf</code> <code>num</code> it is still uninitialized and the value you get is garbage.</p>

<p>You could test for this by examining the return of <code>scanf</code>. <code>scanf</code> will return the number of successful matches, which you should expect to be <code>1</code> if a number was entered</p>

<pre><code>printf(""Number: "");
if (scanf(""%d"",&amp;num) != 1) {
    puts(""You didn't enter a number!"");
}
</code></pre>

<p>For a better proof it is not being set, try initializing <code>num</code> to something and see what gets printed</p>

<pre><code>#include &lt;stdio.h&gt;
int main() {
  int num = 5; // I'm initializing to 5
  char string[31];

  printf(""Number: "");
  scanf(""%d"",&amp;num);

  sprintf(string, ""%d"", num);

  printf(""%s"", string);  // now this prints ""5"" if I input ""dog""
  return 0;
}
</code></pre>

<p>For further evidence of this, running your original program through valgrind prints a bunch of errors about using an uninitialized value. I've edited out some of the noise in the below:</p>

<pre><code>$ echo ""dog"" | valgrind ./a.out
==32450== 
==32450== Use of uninitialised value of size 8
==32450==    at _itoa_word
==32450==    by vfprintf 
==32450==    by vsprintf
==32450==    by  sprintf
==32450==    by main
==32450== 
==32450== Conditional jump or move depends on uninitialised value(s)
==32450==    at vfprintf 
==32450==    by vsprintf
==32450==    by sprintf
==32450==    by main
</code></pre>

<p>To accomplish your goal of reading a string then checking it, you'll want to use <code>fgets</code> instead</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

int main() {
  char input[31];
  printf(""Number: "");
  fgets(input, sizeof input, stdin);  // read up to a line of input as a string
  if (isdigit(input[0])) {  // check if it's a number
    puts(""this is a number (or at least starts with one)"");
  } else {
    puts(""this is not a number"");
    return 1;
  }

  int num = 0;
  char string[31];

  sscanf(input, ""%d"", &amp;num);  // now you can do the scanf on the input string

  sprintf(string, ""%d"", num);
  printf(""%s"", string);
  return 0;
}
</code></pre>
",1
43963785,43963225,1,"<p>You should know how programming languages are parsed and executed.
I recommend you to read ""Concepts, Models and Techniques of Computer Programming"" by Peter Van Roy, if you want deeper information.</p>

<p>Your programming language is constructed by syntax, semantic and pragmatics. Your assignment text describes the grammatic rules of your programming language (syntax). These rules are useful for writing valid senteces in your languages. 
Valid sentences can be understood by your interpreter and then executed.
During the execution, you are basically assigning a semantic meaning to each sentence.</p>

<p>These are the steps:</p>

<ol>
<li>Write a tokenizer. Each word of your programming language is a token. <code>BEGIN</code> is a token, <code>CALL</code> is a token, function names are token too (function identifiers). The tokenizer analyses your source code (which is a simple string) and creates a list of tokens.
<code>Text files -&gt; [TOKENIZER] -&gt; sequence of token</code></li>
<li>Write a parser. Sentences are composed by words, then similarly your P.L sentences will be composed by tokens. You should use your grammar rules in order to know which sequence of token are valid and which are not. E.g. functions has to begin with <code>BEGIN</code> token, followed by a <code>identifier</code> token, followed by one or more <code>instruction</code> token and ending with the <code>END</code> token. You have to create a <strong>parse tree</strong> (<a href=""https://en.wikipedia.org/wiki/Parse_tree"" rel=""nofollow noreferrer"">https://en.wikipedia.org/wiki/Parse_tree</a>). The nodes of the parse tree are non-terminator symbols, the leaves are terminator symbols (tokens).
<code>Sequence of token -&gt; [PARSER] -&gt; Parse tree</code></li>
<li>Write an interpreter. It's time to assign the semantic to each symbol: starting at the root of the parsing tree, the interpreter analyses each node executing the related instruction. </li>
</ol>

<p>Implementation:</p>

<p>The tokenizer and the parser are just Finite State Machines.
The interpreter is basically a program that converts a parse tree in an execution stack, from which each instruction is poped out and executed.</p>
",0
47468318,47468281,3,"<p>Try:</p>

<pre><code>printf(""%Ns\n"", """");
</code></pre>

<p>where <code>N</code> is the number of spaces you want to display.</p>

<p>This way you are displaying an empty string preceded by <code>N</code> spaces.</p>

<pre><code>printf(""please Choose: 1-For Checking what is the most popular number in the array\n%8s2-To sort your array from the smallest number to the biggest\n%8s3-To sort your array that even will be to your left and odd to the right\n%8s*Any other number will exit the program\n"", """", """", """");
</code></pre>
",3
43220222,43219006,0,"<p>I presume int i is the starting index of the string and int j is the ending index. If that is so, have a closer look at the first line of your palindromelength() function. Could the function ever start from somewhere other than index 0?</p>

<p>As for ways to do the ispalindrome() function, there are many algorithms out there to check whether or not an input is a palindrome, I would suggest having a look around and finding out different methods. If your way works, great! probably the cleanest way is to use recursion although that can take some thinking.</p>
",0
45217825,45217709,1,"<p><code>addr</code> is casted to uint64_t; its content shifted 32 bits to the right (with zeros pushed from the left) and the results is cast to uint32_t. It does not seems to make much sense a part of returning zero of type uint32_t in a complex way. </p>

<p>Besides, it has nothing to do with memory allocation, a part of possibly few temporaries on the stack.</p>
",2
39682228,39671313,2,"<p>I've checked the code you gave a link to.</p>

<p><code>BOOL</code> type is properly included. To check that you can compile <code>Cheat.c</code> with <code>/P</code> option.</p>

<p>All the problems are caused by upgrade of the project from Visual Studio 6 to Visual Studio 2015.</p>

<p>If you will investigate the pre-processor ouput you will see the transformation:</p>

<pre><code>BOOL TreeView_GetCheckState(HWND hwndTreeView, HTREEITEM hItem); //(line 55, error thrown.)
BOOL TreeView_SetCheckState(HWND hwndTreeView, HTREEITEM hItem, BOOL fCheck); //(line 56)
</code></pre>

<p>pre-processed to:</p>

<pre><code>BOOL ((((UINT)(SendMessageA((HWND hwndTreeView), (0x1100 + 39), (WPARAM)(HTREEITEM hItem), 0xF000))) &gt;&gt; 12) -1);
BOOL { TVITEMA _ms_TVi; _ms_TVi.mask = 0x0008; _ms_TVi.hItem = (HTREEITEM hItem); _ms_TVi.stateMask = (0xF000); _ms_TVi.state = ((((BOOL fCheck)?2:1) &lt;&lt; 12)); SendMessageA((HWND hwndTreeView), (0x1100 + 13), 0, (LPARAM)(TVITEMA *)&amp;_ms_TVi);};
</code></pre>

<p>It's not what you expect to see in your function declarations. </p>

<p>Both of these <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/bb773810%28v=vs.85%29.aspx"" rel=""nofollow""><code>TreeView_GetCheckState</code></a> and <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/bb760044(v=vs.85).aspx"" rel=""nofollow""><code>TreeView_SetCheckState</code></a> are standard macroses defined in <code>CommCtrl.h</code>. Remove your old functions and use these macroses.</p>
",1
41665781,41665753,0,"<p>The loop exit condition is a null character (<code>\0</code>). This character is seen at the end of the string. </p>

<p>There is no source for the number characters to appear from, therefore they don't </p>
",0
41666073,41665753,2,"<p>The actual output I would expect is this:</p>

<pre><code>string1 = Hello
string3 = Good Bye
</code></pre>

<p>Both functions implement the copy part of <code>strcpy()</code>, using index notation and pointer pushing respectively.  They both copy characters from the source (second argument) into the destination (first argument) upto and including the null terminator. Evaluating the test actually copies the character: the null terminator is copied and the loop stops.</p>

<p>The rest of the destination arrays <code>string1</code> and <code>string3</code> remains uninitialized. They do not contain anything precise: these arrays are allocated on automatic storage (aka <em>on the stack</em>) and are <strong>not</strong> initialized.  I don't know where you derive this notion of initial contents for arrays, maybe from some sample program that did initialize arrays with this contents, but no such thing happens by default.</p>

<p><code>printf()</code> outputs the contents of the array <code>string1</code> as an argument for the <code>%s</code> format, deemed to be a C string, and stops when it reaches the null terminator.</p>
",1
41666135,41665753,0,"<p>You have to init string1 and string3 with 0..9 before you use your copy functions, but before init you have to extend the field length of string1 and string3 from 10 to 11 (the \0 char is added):
<code>strcpy(string1,""0123456789"");
    strcpy(string3,""0123456789"");</code></p>
",3
46984685,46982386,0,"<p>There are multiple ways of solving this problem, but here is my code. I am not sure if it works, because I have not tested it yet. But hopefully it gives you an idea on how to solve the problem.</p>

<pre><code>#include&lt;stdio.h&gt;

int main(void)

{ 
  FILE *infile;

  infile=fopen(""filein"",""r"");

  int num_trans=0;
  int j=0;
  int combomeal[20],alameal[20];
  totalsales[20]={0};
  totalcombo[20]={0};
  totalala[20]={0};


 while(fscanf(infile,""%d %d"",&amp;combomeal[num_trans],&amp;alameal[num_trans]) !=EOF) num_trans++;


 printf("" Total Combo Meal    Total Ala Meal      Total Sales\n"");

  for(j=0;j&lt;num_trans;j++)
   {
     totalcombo[j]+=combomeal[j];
     totalala[j]+=totalala[j];
     totalsales[j]=combomeal[j]+totalala[j];
     printf(""  %d                    %d                     %d\n"",totalcombo[j],totalala[j],totalsales[j]);      
   }


 fclose(infile); 

}
</code></pre>
",0
41919961,41919637,1,"<p>C Macros perform textual substitution: each instance is replaced with the macro definition with the macro parameter names replaced with the exact text of the instance arguments.</p>

<p>Your <code>cubem</code> macro defined as <code>#define cubem(a) (a * a * a)</code> will expand this way:</p>

<p><code>cubem(--a)</code>  ->  <code>(--a * --a * --a)</code></p>

<p>Modifying <code>a</code> multiple times within the same expression has undefined behavior.  You cannot work around this problem portably.  You could try using compiler extensions if you are familiar enough and don't mind relying on non-portable constructions.</p>

<p>The correct way to implement the function and have it expand inline is via an inline function definition:</p>

<pre><code>static inline cubem(int a) { return a * a * a; }
</code></pre>

<p>Note also that the macro has other problems:</p>

<p><code>cubem(1 + 1)</code>  expands to  <code>(1 + 1 * 1 + 1 * 1 + 1)</code> which evaluates to 4 instead of 8.</p>

<p>To avoid this problem, all macro arguments should be parenthesized:</p>

<pre><code>#define cubem(a)  ((a) * (a) * (a))
</code></pre>

<p>But this definition still does not support arguments with side effects:</p>

<p><code>cubem(getchar())</code> will read 3 bytes from standard input.</p>
",0
41919735,41919637,0,"<p>Since you invoke <code>cubem(--a)</code> like this, your cubem definition should avoid side effect.</p>

<pre><code>#define cubem(a) \
({ \
    typeof(a) dummy_a = (a); \
    dummy_a * dummy_a * dummy_a; \
})
</code></pre>

<p>Above is a gcc c extension, read the gcc document, chapter </p>

<blockquote>
  <p>Statements and Declarations in Expressions</p>
</blockquote>
",3
41919920,41919637,4,"<p>The reason is that</p>

<pre><code>#define cubem(a) (a * a * a)

/* and later using it .... */

printf(""cubem = %d\n"", cubem(--a));
</code></pre>

<p>does text substitution, and produces</p>

<pre><code>printf(""cubem = %d\n"", (--a * --a * --a));
</code></pre>

<p>which modifies <code>a</code> three times in one statement.  That is undefined behaviour according to the C standard.</p>

<p>In comparison, </p>

<pre><code>int cubef(int a) {
    return a * a * a;
}

/* and later */

printf(""cubef = %d\n"", cubef(--a));
</code></pre>

<p>evaluates <code>--a</code> once, passes the resultant value to <code>cubef()</code>.</p>

<p>If you really want to ""put a function in a macro"", then do something like</p>

<pre><code>#define cubem(a) cubef(a)
</code></pre>

<p>which causes the statement</p>

<pre><code>printf(""cubem = %d\n"", cubem(--a));
</code></pre>

<p>to become</p>

<pre><code>printf(""cubem = %d\n"", cubef(--a));
</code></pre>

<p>The problem with this is that it does not work with a macro that uses its argument more than once.  For example</p>

<pre><code>int sq(int a) {return a * a;}

#define cubesq(a) (a * sq(a))    /*  uses a more than once
</code></pre>

<p>causes</p>

<pre><code>printf(""cubesq = %d\n"", cubesq(--a));
</code></pre>

<p>to be seen by the compiler as</p>

<pre><code>printf(""cubem = %d\n"", (--a * cubesq(--a));
</code></pre>

<p>which, again, modifies <code>a</code> more once and causes undefined behaviour.</p>

<p>The reason is simple:  the preprocessor does TEXT SUBSTITUTION and modifies source code seen by a later phase of the compiler.</p>

<p>Instead of ""trying to put a function inside a macro"", simply don't use macros.   Write functions.   Use functions.    Or use macros, but respect their limitations (i.e. they don't work like functions do, even if they look like functions).</p>
",1
43228282,43228102,1,"<p>There are several issues in the code.</p>

<p>First, your variables, especially <code>odd_counter</code> and so on are not initialised. Hence, an expression like <code>odd[odd_counter]=input</code> yields undefined behaviour (and actually you have a good chance that the program crashes). Note that in C local variables of integral type are NOT by default initialized, neither with <code>0</code> nor with any other value. So you need to write <code>int odd_counter=0, even_counter=0, ...</code> and so on. Otherwise your program might yield a correct output (as a correct output is one of thousands of possible outputs due to undefined behaviour), but it is for sure not guaranteed.</p>

<p>Second, <code>even_p=(even_counter/total_counter)*100</code> performs an integer division (nothing behind the comma), so <code>even_counter/total_counter</code> will always be <code>0</code> if <code>total_counter</code> is greater than <code>even_counter</code>. So you could write <code>even_p=((even_counter*100)/total_counter)</code>, or <code>(((float)even_counter)/total_counter)*100</code>. Decide if <code>even_p</code> should be <code>float</code> or <code>double</code> as well.</p>

<p>Third, you use <code>%d</code> (i.e. int) to scan into a variable of type <code>signed char</code>. Use <code>scanf(""%hhd"", &amp;cinput)</code> instead; Format specifier <code>%d</code> together with length sub-specifier <code>hh</code> tells <code>scanf</code> to scan a numerical value into a signed char target (confer <a href=""http://www.cplusplus.com/reference/cstdio/printf/"" rel=""nofollow noreferrer"">printf/scanf reference</a>). Or: change type of variable <code>cinput</code> to <code>int</code>.</p>

<p>After fixing all these issues, the topic ""Why is the first value in odd_array always a 0"" should be solved as well.</p>
",0
43228183,43228102,1,"<pre><code>even_p=(even_counter/total_counter)*100;
</code></pre>

<p>The above preforms <strong>integer division</strong>. You don't get an exact divisor, but the the integer immediately preceding it. Since <code>even_counter</code> is always less than <code>total_counter</code> you get zero.</p>

<p>A simple fix is to multiply first, and divide second:</p>

<pre><code>even_p = even_counter * 100 / total_counter;
</code></pre>

<p>But your program has undefined behavior all around regardless. You don't initialize all of your variables. For instance, <code>odd_counter</code> isn't initialized, and yet you confidently read its value here:</p>

<pre><code>    if (input % 2 != 0)
    {
        odd[odd_counter]=input; //Insert number in odd numbers array
        odd_counter++;
        total_counter++;
    }
</code></pre>

<hr>

<p>The things you can't figure out can fill a post on their own. It's all about parsing. You need to read an entire line (say with <code>fgets</code>) and then try to parse it (for instance, with repeated applications of <code>sscanf</code>).</p>
",7
43229055,43228102,0,"<p>You declare</p>

<pre><code>    char cinput;
</code></pre>

<p>and then use it in</p>

<pre><code>    scanf(""%d"", &amp;cinput)
</code></pre>

<p>That's bad, very bad... Format specifier <code>""%d""</code> expects a pointer to <code>int</code> as a corresponding parameter, not a pointer to <code>char</code>. And <code>int</code> is longer than <code>char</code> (typically 4 vs. 1 byte), so the input value gets stored <em>outside</em> the destination <code>cinput</code> variable.</p>

<p>What happens next is Undefined Behavior.</p>
",0
43209555,43200025,1,"<p><code>argc</code> is an integer that represents the number of command line arguments passed in to the program. It is the argument count, hence the name. <code>*argv[]</code> (or <code>**argv</code> depending on developer preference) represents the actual arguments. The proper name for <code>argv</code> is argument vector, which makes sense if you're familiar with that particular data type.</p>

<p>The first argument passed in, <code>argc = 1</code> is the program's name. Argc is always at least one because argv will always contain at a minimum the name of the program.</p>

<p>To answer your question, you need to pass in a second command-line argument, <code>argc = 2</code>, where argv[1] equals the user's first name. We can accomplish that like this:</p>

<pre><code>int main(int argc, char** argv)
{
    // This line will print out how many command line arguments were passed in.
    // Remember that it will always be at least one because the name of the program
    // counts as an argument.
    printf(""argc: %d"", argc);

    // Remember that you want the second argument in argv,
    // so you have to call argv[1] because arrays in C 
    // are 0-index based. Think of them as offsets.
    printf(""\nWelcome, %s"", argv[1]);

    return 0;
}
</code></pre>

<p>This should get you started. All you need to do now is write the code to read the string from the standard input and output it to the console.</p>
",2
45703637,45703511,0,"<p>After you add 1 to the day, check to see if that value is greater than the number of days in that month.  If so, set the day to 1 and add 1 to the month.  Then check if month is greater than 12, and if so set the month to 1 and add 1 to the year.</p>

<p>As for determining the number of days in a month, all months except February have the same number of days whether or not the year is a leap year.  Right now you're checking if the year is a leap year for those other months.  You can leave that check out and just check the month number.</p>

<pre><code>if (month == 12 || month == 1 || month == 3 || month == 5 
     || month == 7 || month == 8 || month == 10 ) {
    leapdays = 31;
}
if (month == 4 || month == 6 || month == 9 || month == 11) {
    leapdays = 30;
}
</code></pre>
",0
45703998,45703511,-1,"<p>Got it right :) thanks for all the help</p>

<pre><code>#include &lt;stdio.h&gt;

    int day, month, year, ndays, leapdays;
    bool leapyear;
    int main () {
        day = 31;
        month = 12;
        year = 2010;
        ndays = day + 1;
        leapyear = false;
        printf (""Enter a date in the form day month year: %d %d %d \n"", day, month, year);
        if (year % 4 == 0) {
            leapyear = true;
        }
        if (year % 100 == 0) {
            leapyear = false;
        }
        if (year % 400 == 0) {
            leapyear = true;
        }
        if ((leapyear) &amp;&amp; (month == 12 || month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 )) {
            leapdays = 31;
        }
        if ((leapyear) &amp;&amp; (month == 4 || month == 6 || month == 9 || month == 11 )) {
            leapdays = 30;
        }
        if ((leapyear) &amp;&amp; (month == 2 )) {
            leapdays = 29;
        } else if (leapyear == false) {
            leapdays = 28;
        }
        if ((leapdays == 31) &amp;&amp; (day == 31)) {
            ndays = 1;
            month = month + 1;
        }else if ((leapdays == 30) &amp;&amp; (day == 30)) {
                    ndays = 1;
                    month = month + 1;

        }else if ((leapdays == 29) &amp;&amp; (day == 29)) {
                        ndays = 1;
                     month = month + 1;
        }else if ((leapdays == 28) &amp;&amp; (day == 28)) {
                    ndays = 1;
                    month = month + 1;
        }else if ((month == 12) &amp;&amp; (day == 31)) {
                   ndays = 1;
                    month = 1;
                   year = year + 1;
        }


        printf (""The date of the next day is: %d/%d/%d"", ndays, month, year);
    }
</code></pre>
",2
45715951,45703511,1,"<p>Consider a different flow.  First find the days per month first, then test if at end of month, and end of year.</p>

<pre><code>  int year, month, day;
  // set year, month, day in some fashion

  day++;  // tomorrow

  int days_per_month = 31;
  if (month == 4 || month == 6 || month == 9 || month == 11) {
    days_per_month = 30;
  } else if (month == 2) {
    days_per_month = 28;
    if (year % 4 == 0) {
      days_per_month = 29;
      if (year % 100 == 0) {
        days_per_month = 28;
        if (year % 400 == 0) {
          days_per_month = 29;
        }
      }
    }
  }
  if (day &gt; days_per_month) {
    day = 1;
    month++;
    if (month &gt; 12) {
      month = 1;
      year++;
    }
  }
</code></pre>

<p>Other improvement would use helper functions, enumerated types and various defines.  Yet this code seems to reflect OP's level.</p>
",0
45718850,45718718,3,"<p>Step 1: read the line (note OP implies code is starting with a string so this step is illustrative.)</p>

<pre><code>char buf[100];
if (fgets(buf, sizeof buf, stdin) == NULL) Handle_EOF_or_Error();
// strip potential \n
buf[strcspn(buf, ""\n"")] = '\0';
</code></pre>

<hr>

<blockquote>
  <p>check if only two numbers are entered separated by only ONE space, with no leading or trailing whitespace at all</p>
</blockquote>

<p>Step 2: Scan per format.  <code>""%d""</code> allows for leading whitespace - so code needs to see what is before the numeric text.  Use <code>""%n""</code> to store the scan offset for later  whitespace detection.  <code>%*1[ ]</code> to scan (not save) 1 and exactly 1 space.</p>

<pre><code>int i[2];
int sep[3];
int cnt = sscanf(buf, ""%n%d%*1[ ]%n%d%n"", &amp;sep[0], &amp;i[0], &amp;sep[1], &amp;i[1], &amp;sep[2]);

// 2 int            leading space?        leading space?        \0 ?
if (cnt != 2 || isspace(buf[sep[0]]) || isspace(buf[sep[1]]) || buf[sep[2]]) {
  Handle_Bad_Input();
} else {
  Success();
}
</code></pre>

<hr>

<p>Simplification idea per <a href=""https://stackoverflow.com/questions/45718718/sscanf-usage-in-very-specific-format/45718850?noredirect=1#comment78398389_45718850"">@Jonathan Leffler</a></p>

<pre><code>int i[2];
int sep[2];
int cnt = sscanf(buf, ""%d%*1[ ]%n%d%n"", &amp;i[0], &amp;sep[0], &amp;i[1], &amp;sep[1]);

// 2 int        leading space?     leading space?          \0 ?
if (cnt != 2 || isspace(buf[0]) || isspace(buf[sep[0]]) || buf[sep[1]]) { 
</code></pre>

<hr>

<p>Note: pedantic code would cast the <code>char</code> with <code>(unsigned char)</code> to handle negative <code>char</code> as <code>is...()</code> functions are defined for the <code>unsigned char</code> range and <code>EOF</code>.</p>

<pre><code>isspace(buf[...]) --&gt; isspace((unsigned char) buf[...]) 
</code></pre>

<h2>---</h2>

<p>A more robust approach would call a helper function to assess the integer - which can be crafted per code's needs.  Using <code>strtol()</code> is a good starting point for define-ness and overflow detection.</p>

<pre><code>#include &lt;ctype.h&gt;
#include &lt;errno.h&gt;
#include &lt;limits.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdlib.h&gt;

// Return error status
bool scan_int(const char **input, int *dest) {
  errno = 0;
  const char *s = *input;

  if (isspace((unsigned char) *s) {
    // reject leading space
    return true;
  }

  char *endptr;
  long num = strtol(s, &amp;endptr, 10);
  if (s == endptr) {
    // no conversion
    return true;
  }
  *input = (const char *) endptr;
  if (errno == ERANGE) {
    // Overflow
    return true;
  }
#if LONG_MAX &gt; INT_MAX  || LONG_MIN &lt; INT_MIN
  if (num &gt; INT_MAX || num &lt; INT_MIN) {
    errno = ERANGE;
    // Overflow
    return true;
  }
#endif
  *dest = (int) num;
  return false;
}

// Return error status - On success, return false
bool sz_int_space_int(const char *input, int *dest) {
  return scan_int(&amp;input, &amp;dest[0]) || *input++ != ' '
      || scan_int(&amp;input, &amp;dest[1]) || *input;
}
</code></pre>
",3
45721275,45718718,1,"<p>If you only deal with positive integers without leading signs, here is a simpler solution:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int validate_string(const char *buf, int *int1, int *int2) {
    size_t len1, len2;
    /* return non 0 if and only if line has the correct format
       and int1 and int2 contain the converted numbers */
    return (len1 = strspn(buf, ""0123456789"")) &gt; 0
    &amp;&amp;     buf[len1] == ' '
    &amp;&amp;     (len2 = strspn(buf + len1 + 1, ""0123456789"")) &gt; 0
    &amp;&amp;     buf[len1 + len2 + 1] == '\0'
    &amp;&amp;     sscanf(buf, ""%d%d"", int1, int2) == 2);
}
</code></pre>

<p>Note however that this solution does not adequately test for potential overflow in the numeric conversions.</p>

<p>Here is an alternative with <code>strtol()</code></p>

<pre><code>#include &lt;ctype.h&gt;
#include &lt;stdlib.h&gt;

int parse_int(int *dest, const char *buf, char **pp)
int validate_string(const char *buf, int *int1, int *int2) {
    char *p1, *p2;
    return !isspace((unsigned char)*buf)
    &amp;&amp;     ((*int1 = strtol(buf, &amp;p1, 10)), p1 &gt; buf)
    &amp;&amp;     *p1++ == ' '
    &amp;&amp;     !isspace((unsigned char)*p1)
    &amp;&amp;     ((*int2 = strtol(p1, &amp;p2, 10)), p2 &gt; p1)
    &amp;&amp;     *p2 == '\0');
}
</code></pre>

<p>Modified to avoid implementation defined behavior commmented by chux:</p>

<pre><code>#include &lt;ctype.h&gt;
#include &lt;errno.h&gt;
#include &lt;limits.h&gt;
#include &lt;stdlib.h&gt;

int parse_int(int *dest, const char *buf, char **pp) {
    long val;
    if (isspace((unsigned char)*buf)
        return 0;
    val = strtol(buf, pp, 10);
    if (*pp &lt;= buf)
        return 0;
    if (val &lt; INT_MIN) {
        val = INT_MIN;
        errno = ERANGE;
    } else
    if (val &gt; INT_MAX) {
        val = INT_MAX;
        errno = ERANGE;
    }
    *dest = (int)val;
    return 1;
}

int validate_string(const char *buf, int *int1, int *int2) {
    char *p1, *p2;
    return parse_int(int1, buf, &amp;p1)
    &amp;&amp;     *p1++ == ' '
    &amp;&amp;     parse_int(int2, p1, &amp;p2)
    &amp;&amp;     *p2 == '\0');
}
</code></pre>

<p>Here is one with just a single <code>scanf()</code>:</p>

<pre><code>#include &lt;stdio.h&gt;

int validate_string(const char *buf, int *int1, int *int2) {
    int p1, p2, p3;
    char c;
    return sscanf(buf, "" %n%d%1*[ ]%n %n%d%c"", &amp;p1, int1, &amp;p2, &amp;p3, int2, &amp;c) == 2
        &amp;&amp; p1 == 0 &amp;&amp; p2 == p3;
}
</code></pre>
",3
43199351,43199291,5,"<p>They <strong>are</strong> and <strong>will be</strong> equal if you supply the <strong>same</strong> initial values of the operands.</p>

<p>In your case, the side effect of the first statement (post increment on <code>a</code>) is affecting the second one. Due to the presence of the post-increment in the first expression, <code>a</code> is incremented to <code>3</code> before the next statement is executed.</p>

<p><strong>Re-initialize</strong> the variables with the same genesis value before calculating the second one.</p>
",3
43199372,43199291,3,"<p>You need to check the <a href=""http://en.cppreference.com/w/c/language/operator_precedence"" rel=""nofollow noreferrer"">C operator precedence</a> to understand it.</p>

<p>The confusing thing here is that <code>a+++b</code> may be read as either <code>a + (++b)</code> or as <code>(a++) + b</code>. According to the <a href=""http://en.cppreference.com/w/c/language/operator_precedence"" rel=""nofollow noreferrer"">C operator precedence</a>, it is actually looks like:</p>

<pre><code>int a=2, b=3, c;

c = (a++) + b; // 2+3=5 and 'a' will be 3 after that line
printf(""%d\n"",c); // c = 5

c = a + (b++); // 3+3=6 and 'b' will be 4 after that line
printf(""%d\n"",c); // c= 6
</code></pre>

<p>From the link above:</p>

<p><code>++</code> as sufix has highest priority.</p>

<p><code>++</code> as prefix has lower priority.</p>

<p><code>+</code> has even lower priority.</p>
",12
43199409,43199291,1,"<pre><code> int a=2, b=3, c;

 c = (a++) + b; // The value for a will be 3 after that line
 printf(""%d\n"",c); // c = 5

 c = a + (b++); // So here a value is 3 (3+3) =6 after executing this line b value will be 4
  printf(""%d\n"",c); // c= 6
</code></pre>

<p>To avoid this you need to reinitialize the variables</p>
",0
43199546,43199291,0,"<pre><code>c = a+++b; 
</code></pre>

<p>is equivalent  </p>

<pre><code>c = a++ + b;
</code></pre>

<p><code>a++</code> means post-increment, means expression takes the value of <code>a</code> and then increment.</p>

<pre><code>c = a+b++;
</code></pre>

<p>is equivalent </p>

<pre><code> c = a + b++;
</code></pre>

<p><code>b++</code> means post-increment, means expression takes the value of <code>b</code> and then increment.</p>

<p><strong>If you provide same value in both cases, then both express variable c same.</strong></p>
",0
44715843,44715805,4,"<p>The C standard is very clear on this.</p>

<ol>
<li><p>The memory pointed to by <code>ptr</code> has <em>dynamic storage duration</em>.</p></li>
<li><p>The memory associated with an <code>int foo[5];</code>, say has <em>automatic storage duration</em>.</p></li>
</ol>

<p>The key difference between the two is that in the dynamic case you need to call <code>free</code> on <code>ptr</code> to release the memory once you're done with it, whereas <code>foo</code> will be released automatically once it goes out of <em>scope</em>.</p>

<p>The mechanism for acquiring the memory in either case is intentionally left to the compiler.</p>

<p>For further research, Google the terms that I've <em>italicised</em>.</p>
",0
44715924,44715805,6,"<h3>1. Answer in terms of the language</h3>

<p>It differs in the <em>storage duration</em>. If you use an integer array, it could be at the file scope (outside any function):</p>

<pre><code>int arr[5];
</code></pre>

<p>This has <em>static</em> storage duration, which means the object is alive for the whole execution time of the program.</p>

<p>The other possibility is inside a function:</p>

<pre><code>void foo(void)
{
    int arr[5];
}
</code></pre>

<p>This variant has <em>automatic</em> storage duration, so the object is only alive as long as the program execution is inside this function (more generally: inside the scope of the variable which is the enclosing pair of braces: <code>{ ... }</code>)</p>

<p>If you use <code>malloc()</code> instead, the object has <em>dynamic</em> storage duration. This means <em>you</em> decide for how long the object is alive. It stays alive until you call <code>free()</code> on it.</p>

<h3>2. Answer in terms of the OS</h3>

<p><code>malloc()</code> is typically implemented on the <em>heap</em>. This is an area of your address space where your program can dynamically request more memory from the OS.</p>

<p>In contrast, with an object with <em>automatic</em> storage duration, typical implementations place it on the <em>stack</em> (where a new frame is created for each function call) and with <em>static</em> storage duration, it will be in a data segment of your program already from the start.</p>

<p>This part of the answer is intentionally a bit vague; C implementations exist for a vast variety of systems, and while <em>stack</em>, <em>heap</em> and <em>data segments</em> are used in many modern operating systems with virtual memory management, they are by no means required -- take for example embedded platforms and microcontrollers where your program might run without any operating system. So, writing portable C code, you should (most of the time) only be interested in what the language specifies.</p>
",0
42612968,42612829,4,"<p>To prevent <code>int</code> overflow, use <code>(a%3 +b%3+c%3)/3</code> to handle the division of the remainders. <a href=""https://stackoverflow.com/questions/42612829/finding-mean-of-3-numbers-in-c-whats-wrong-with-the-code/42612968#comment72354923_42612829"">@EOF</a>  <a href=""https://stackoverflow.com/questions/42612829/finding-mean-of-3-numbers-in-c-whats-wrong-with-the-code/42612968#comment72354877_42612829"">@Jean-Fran?ois Fabre</a></p>

<pre><code>int mean3pf(int a, int b, int c) { 
  return a/3 + b/3 + c/3 + (a%3 +b%3+c%3)/3;
}
</code></pre>
",7
47962067,47961794,0,"<p>You have two issues in your queue_is_full function. The following is the right version.</p>

<pre><code>int queue_is_full(void)
{
    if (((tail + 1) % MAX_QUEUE_SIZE == head) || (((head == 0) &amp;&amp; (tail == MAX_QUEUE_SIZE - 1))))
    {
        return 1;
    }
    else
    {
        return 0;
    }
}
</code></pre>

<p>Issues are the <code>(tail + 1) % MAX_QUEUE_SIZE == head</code> and <code>head == 0</code> ( you gave only one <code>=</code>)</p>
",2
45281385,45281182,1,"<p><code>M</code> is <strong>uninitialized</strong>!
Read <code>M</code> before creating the array <code>a</code> or, make <code>a</code> big enough to contains all possible input sizes and use <code>M</code> to limit the access to <code>a</code>. The latter this is quite common in competitive programming: create a static array big enough and then use only a portion of it based on other information, like <code>M</code> in this case.</p>

<p>Anyway, the error would be easily spotted enabling compiler warnings <code>Wall -Wextra</code>:
Here is what <code>gcc</code>, <code>clang</code> and <code>icc</code> complains about. </p>

<pre><code> gcc   -Wall -Wextra -g -O3 -Wshadow  test.c
test.c: In function ¡®main¡¯:
test.c:7:1: warning: ¡®M¡¯ is used uninitialized in this function [-Wuninitialized]
 int N, M, a[M], i, j, fake;

             ^~~
</code></pre>

<hr>

<pre><code> clang   -Wall -Wextra -g -O3 -Wshadow  test.c
test.c:7:13: warning: variable 'M' is uninitialized when used here
      [-Wuninitialized]
int N, M, a[M], i, j, fake;

           ^
test.c:7:9: note: initialize the variable 'M' to silence this warning
int N, M, a[M], i, j, fake;
            ^
         = 0
1 warning generated.
</code></pre>

<hr>

<pre><code> icc   -Wall -Wextra -g -O3 -Wshadow  test.c
test.c(7): warning #592: variable ""M"" is used before its value is set
  int N, M, a[M], i, j, fake;
</code></pre>
",0
47482658,47482650,0,"<p>You have to use the correct format specifier which will be <code>scanf(&quot;%f&quot;,&amp;f)</code> in this case.</p>
<p>Also <code>fc=((5.0/9.0)*(f-32))</code>, otherwise integer division yields <code>0</code>.(<em>Integer division truncates</em>).<code>5/9.0</code> will also work.</p>
<p>It is useless to put <code>getch()</code> after <code>return</code> statement. It will never reach upto that line.</p>
<hr />
<h3>What happens in your version?</h3>
<p>Actually when two integers are divided the result is the quotient. If there any fractional part it is discarded. If you divide 5 by 9 the result will be <code>0.555...</code>. When fractional part discarded it will be <code>0</code>. So you always get <code>0</code>.</p>
<p>Whenever you need an outcome of a division not t truncate you must make one of them floating point. That ensures that it(result) will <em>not</em> truncate.</p>
<hr />
<p>So the program would be</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

void celciusToFahreinheit();

float fahr_temp,celc_temp;

int main()
{
    celciusToFahreinheit();
    return EXIT_SUCCESS;
}
void celciusToFahreinheit() 
{
    printf(&quot;\n Enter the temperature (in *F) to covert it into Celsius: &quot;);
    if( scanf(&quot;%f&quot;,&amp;fahr_temp) != 1 ){
        fprintf(stderr,&quot;Error in input\n&quot;);
        exit(EXIT_FAILURE);
    }
    celc_temp=((5.0/9.0)*(fahr_temp-32));
    printf(&quot;\n %f*C&quot;,celc_temp);
}
</code></pre>
<p>Apart from the problem few things would be - Using readable function name and checking the return value of <code>scanf</code>.</p>
",0
47482675,47482650,0,"<pre><code>fc=((5/9)*(f-32));
</code></pre>

<p>Because 5 and 9 are <strong>integers</strong>, the arithmetic calculation is done at integer level, thus <code>5/9 == 0</code>.</p>

<p>You should change it to floating point:</p>

<pre><code>fc = ((5.0f / 9.0f) * (f - 32.0f));
</code></pre>

<p>Besides, format specifier <code>%d</code> is used for <strong>integers</strong>. If you want to read a floating point number, use <code>%f</code>:</p>

<pre><code>scanf(""%f"", &amp;f);
</code></pre>

<p>The result should be right now.</p>
",0
42617377,42616734,3,"<p>You can do this, but it's not a good idea.</p>

<p>What you're asking for is <a href=""https://en.wikipedia.org/wiki/Digital_rights_management"" rel=""nofollow noreferrer"">Digital Rights Management or DRM</a> and it doesn't work. Even the largest software companies can't make it work reliably for the fundamental reason that if I can run your code I can modify your code. All DRM is is a speed bump. Your idea of altering a number in the binary it is very easy to find and defeat. Friendly tip: don't waste your time on it. Instead, have a license and enforce it, or don't distribute your software (ie. provide it as a server).</p>

<hr>

<p>But let's do it as an exercise.</p>

<p>Append a number to the end of the <em>compiled</em> executable. The executable reads that to determine the number of times it has remaining, and rewrites it with the new number of times.</p>

<p>There's any number of ways to put the number on the end. You can write it there with a hex editor. I used a small Perl program to write the 4 bytes.</p>

<pre><code># It's backwards because x86 machines are little-endian.
# And you're probably on an x86 machine.
$ perl -we 'open my $fh, ""&gt;&gt;"", shift; print $fh ""\x03\x00\x00\x00"";' executable
</code></pre>

<p>That means the program has to...</p>

<ol>
<li>Open itself using <code>argv[0]</code>.</li>
<li>Seek 4 bytes from the end.</li>
<li>Read the last 4 bytes into a 4 byte integer.</li>
<li>Check that it's not 0.</li>
</ol>

<p>We need to read/write a specific number of bytes, so I'll be using uint32_t to have a fixed size 4 byte integer.</p>

<pre><code>// Open our own executable for reading.
FILE *fp = fopen(argv[0], ""rb"");
if( fp == NULL ) {
    fprintf( stderr, ""Can't open %s for %s: %s"", argv[0], mode, strerror(errno) );
    exit(-1);
}

// Seek 4 bytes from the end.
if( fseek( fp, -4, SEEK_END ) != 0 ) {
    fprintf( stderr, ""Can't seek: %s"", strerror(errno) );
    exit(-1);
}

// Read 4 bytes
uint32_t times = 0;
fread( &amp;times, 4, 1, fp );

if( times == 0 ) {
    printf(""Program expired. Please give me $money$.\n"");
    exit(-1);
}
else {
    printf(""You have %d tries remaining.\n"", times);
}
</code></pre>

<p>Writing is very similar.</p>

<ol>
<li>Open itself using <code>argv[0]</code>.</li>
<li>Seek 4 bytes from the end.</li>
<li>Write the new number of times remaining.</li>
</ol>



<pre><code>// Open our own executable for reading &amp; writing.
// Can't use ""a"", that will always write to the end of the file.
// Can't use ""w"", that will erase the file.
FILE *fp = fopen(argv[0], ""r+b"");
if( fp == NULL ) {
    fprintf( stderr, ""Can't open %s for %s: %s"", argv[0], mode, strerror(errno) );
    exit(-1);
}

// Seek 4 bytes from the end.
if( fseek( fp, -4, SEEK_END ) != 0 ) {
    fprintf( stderr, ""Can't seek: %s"", strerror(errno) );
    exit(-1);
}

fwrite( &amp;times, 4, 1, fp );
</code></pre>

<hr>

<p>Again, this form of copy protection is barely a speed bump. Anyone who knows what a hex editor is can easily recognize it and break it. Anyone who doesn't can Google for instructions written by someone who does. This answer is only for an exercise.</p>
",4
41183262,41183022,1,"<p>You missed '&amp;' here... </p>

<pre><code>   printf(""Enter second number"");
    scanf(""%d"", &amp;no2);
</code></pre>
",0
41183023,41183022,4,"<p>Look closely at the this snippet: <code>scanf(""%d"", no2);</code> </p>
",2
41183024,41183022,1,"<p>Say you declare a variable named foo.</p>

<pre><code>int foo;
</code></pre>

<p>This variable occupies some memory. It occupies four bytes of memory (because an int is four bytes wide).</p>

<p>Now let's declare another variable.</p>

<pre><code>int *foo_ptr = &amp;foo;
</code></pre>

<p>foo_ptr is declared as a pointer to int. We have initialized it to point to the foo variable.</p>

<p>As I said, foo occupies some memory. Its location in memory is called its address. The char '&amp;' is the ¡°address-of"" operator.</p>

<p>This operator returns the address of an variable. In our case foo, thus foo_ptr now point to the address memory of the foo variable.</p>

<p>Think of every variable as a box. foo is a box that is sizeof(int) bytes in size. The location of this box is its address. When you access the address, you actually access the contents of the box it points to.</p>

<p><a href=""https://i.stack.imgur.com/rguV9.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/rguV9.png"" alt=""boxes""></a></p>
",0
41187679,41183022,1,"<p>You forgot to put '&amp;' at the second scanf :)</p>
",0
45733586,45732390,3,"<p>This code doesn't even compile. The <strong>main</strong> problem is here:</p>

<pre><code>char[] apples = moves;
</code></pre>

<ol>
<li><p>This is invalid syntax. If you want to declare an array, the <code>[]</code> goes <strong>after the identifier</strong>, like <code>char apples[]</code>.</p></li>
<li><p>Even when corrected, a pointer (<code>moves</code>) is not a valid initializer for an array:</p>

<ul>
<li>When you leave out the dimension of the array in the declaration, the dimension must be deduced from the initializer. This is impossible with just a pointer, there's no size information in a pointer.</li>
<li>Assigning an array is <strong>not possible</strong> in C.</li>
</ul></li>
</ol>

<p>If you really <strong>want</strong> to copy a string to a <code>char</code> array, you'd have to do something like this:</p>

<pre><code>char apples[strlen(moves) + 1]; // one extra byte for terminating 0
strcpy(apples, moves);
</code></pre>

<p>This uses a <em>variable-length array</em>, which was introduced in C99, is optional in C11, but supported by <strong>most</strong> compilers. For alternatives, please do some research yourself.</p>

<hr>

<p>Additionally, this line doesn't do what you probably <strong>think</strong> it does:</p>

<pre><code>    if (a &amp;&amp; b == 0) {return true;}
</code></pre>

<p>The condition is evaluated as <code>a &amp;&amp; ( b == 0 )</code>. If <code>a</code> is <strong>not</strong> 0, this is logically <em>true</em>, so the whole expression is true <strong>exactly</strong> when a is not 0 and b is 0. You seem to want:</p>

<pre><code>    if (a == 0 &amp;&amp; b == 0) {return true;}
</code></pre>

<hr>

<p>What's really uhm ... ""<em>surprising</em>"" ... about the code is the fact that the array serves no purpose at all. You could just directly access the characters through <code>moves</code> without ever taking a copy:</p>

<pre><code>bool judgeCircle(char* moves) {
    int a = 0;
    int b = 0;

    for (int i = 0; i &lt; strlen(moves); i++)
    {
        if (moves[i] == 'U') { a++;}
        if (moves[i] == 'D') { a--;}
        if (moves[i] == 'L') { b--;}
        if (moves[i] == 'R') { b++;}     
    }

    if (a == 0 &amp;&amp; b == 0) {return true;}
    else {return false;}
}
</code></pre>

<p>This doesn't change anything about the semantics of the function, but just leaves out the one part that you got <strong>completely</strong> wrong.</p>
",0
45734656,45732390,1,"<p>There is no need to use another array and also the way you have initialized apples[] array is wrong. </p>

<p>Even then if you want to use another array, then you can change the apples[] declaration as follows:</p>

<pre><code>char apples[100];
strcpy(apples, moves);
</code></pre>

<p>or else:</p>

<pre><code>char *apples = moves;
</code></pre>

<p>Hope it will help !!</p>
",0
40563893,40563706,0,"<p>Initially when the list is empty then <code>headp</code> is equal to <code>NULL</code>.</p>

<p>Thus these statements</p>

<pre><code>if (headp-&gt;next == NULL)
</code></pre>

<p>and</p>

<pre><code>while(current-&gt;next != NULL)
</code></pre>

<p>result in undefined behavior.</p>

<p>Also you forgot to initialize to NULL the data member <code>next</code> of the appended node.</p>

<p>The function can be written more simpler</p>

<pre><code>static int insert_end( Person **headp, char *name, int age ) 
{
    Person *p = malloc( sizeof( Person ) ); 
    int success = p != NULL;

    if ( success )
    {
        p-&gt;name = name;
        p-&gt;age  = age;
        p-&gt;next = NULL;

        wjile ( *headp ) headp = &amp;( *headp )-&gt;next; 

        *headp = p;
    }

    return success;
}
</code></pre>

<p>And the function can be called like</p>

<pre><code>size_t i = 0;

while ( i &lt; sizeof( names ) / sizeof( *names ) &amp;&amp; 
        insert_end( &amp;people1, names[i], ages[i] ) ) i++         
</code></pre>
",0
45774606,45774245,-1,"<pre><code>#include &lt;stdio.h&gt;

int main(void) {

    int N, i;
    scanf(""%d"", &amp;N);

    int numArray[N]; // Define an array of four integers

    // Get inputs for the array elements
    for (i=0;i&lt;N; i++) {
        scanf(""%d"", &amp;numArray[i]);
    }

    int sum = 0;
    // Write here the logic to add these integers:
    for (i=0;i&lt;N;i++) sum += numArray[i];



    printf(""%d\n"",sum);  // Print the sum

    return 0;
}
</code></pre>
",1
47560560,47560121,1,"<p>Simplest solution: Make <code>method</code> require (by documentation guarantees, since C can't force a specific array size to be passed) the caller to provide the size 100 buffer, rather than maintain a local and non-local buffer. You'll also want to return the result from <code>read</code>, so the caller knows how many valid bytes they received:</p>

<pre><code>/* ...
 * text - must point to at least 100 bytes of valid memory
 * Returns number of read bytes
 */
int method(char* text) {
    return read(STDIN_FILENO, text, 100); // i write ""sth"" on keyboard
}
</code></pre>

<p>and in <code>main</code>:</p>

<pre><code>char c[100];
// Store number of valid bytes available
int numvalid = method(c);
// Use .* to specify a dynamic maximum field width, so you don't have a read overflow
printf(""%.*s"", numvalid, c); // should print ""sth""
</code></pre>

<p>Other approaches include having the function perform the allocation for the caller (with the caller passing a double-pointer and <code>free</code>ing the buffer themselves):</p>

<pre><code>int method(char** text) { // Receives double-pointer so it can change caller's char*
    *text = malloc(100); // Dynamic allocation (add error checking)
    return read(STDIN_FILENO, *text, 100); // i write ""sth"" on keyboard
}

char *c = NULL; // Pointer to be filled, not array
int numvalid = method(&amp;c); // Pass address of pointer so method can change c
// Use .* to specify a dynamic maximum field width, so you don't have a read overflow
printf(""%.*s"", numvalid, c); // should print ""sth""
free(c); // Free memory allocated by method
</code></pre>

<p>Or keep using your current, separated buffers, and copy from one to the other before the <code>method</code> exits via <code>memcpy</code> (which copies the data), not via pointer assignment (which doesn't change anything visible to the caller):</p>

<pre><code>int method(char* text) {
    char args[100];
    int read = read(STDIN_FILENO, args, 100); // i write ""sth"" on keyboard
    // Copy data from args to text buffer
    // Note: Using memcpy, *not* strcpy, because read provides no guarantees
    // that the buffer will be NUL-terminated
    memcpy(text, args, read);
    return read; // Still need to return number of valid bytes
}

char c[100];
int numvalid = method(c);
printf(""%.*s"", numvalid, c); // should print ""sth""
</code></pre>

<p>This approach is kind of pointless though; <code>method</code> still requires a 100 byte buffer to be passed to operate safely, it just needlessly puts the data in a temporary space, then copies it to the final destination to waste cycles.</p>

<p>Finally, a solution that remains safe, while <em>not</em> requiring you to add a return value to <code>method</code>:</p>

<pre><code>/* ...
 * text - must point to at least 100 bytes of valid memory
 * On return, data is NUL-terminated, *unless* 100 non-NUL bytes were read
 */
void method(char* text) {
    int numread = read(STDIN_FILENO, text, 100);
    if (0 &lt;= numread &amp;&amp; numread &lt; 100) text[numread] = '\0';

    // Or the one-liner for people who don't believe in error handling: :-)
    // text[read(STDIN_FILENO, text, 100)] = '\0';
}
</code></pre>

<p>and then the caller can assume that their buffer is at most 100 bytes, so they can use a limiter on the <code>%s</code> format code to stop on <code>NUL</code> or after 100 bytes, whichever comes first:</p>

<pre><code>char c[100];
method(c);
// Use .100 to prevent read overflow, knowing that method NUL terminated
// anything shorter than 100 bytes (preventing undefined behavior reading
// uninitialized bytes for smaller reads)
printf(""%.100s"", c); // should print ""sth""
</code></pre>
",0
46056017,46055897,2,"<p>The <code>gets</code> function is dangerous because it places no limit on the number of characters entered.</p>

<p>For example given the following code:</p>

<pre><code>char str[10];
gets(str);
</code></pre>

<p>If the user were to enter a string 10 characters or longer, the result would be written off the end of the array.  Doing so invokes <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behavior</a>.</p>

<p>A safer alternative is the <code>fgets</code> function which has the following signature:</p>

<pre><code>char *fgets(char *s, int size, FILE *stream);
</code></pre>

<p>The first parameter is the buffer to receive the string, and the second is the size of that buffer.  In your case you would call it like this:</p>

<pre><code>fgets(PS, sizeof(PS), stdin);
</code></pre>

<p>Note that unlike <code>gets</code>, <code>fgets</code> will store a newline character in the resulting string if there is space for it.</p>
",1
44647377,44647303,0,"<p>Try replacing the declaration</p>

<pre><code>const char *biomes[BIOME_COUNT][STRING_LENGTH+1]
</code></pre>

<p>as follows.</p>

<pre><code>const char biomes[BIOME_COUNT][STRING_LENGTH+1]
</code></pre>
",2
44647986,44647303,0,"<p>Your array was a 2-D array of pointers, and, you indexed one too many in the <code>printf</code> loop.</p>

<p>I have changed this to a 1-D array of pointers, and also removed the hard coded sizes. Instead I replaced the last string <code>""void""</code> with a <code>NULL</code> pointer, and used that to control the loop.</p>

<pre><code>#include &lt;stdio.h&gt;

void CreateBiomes(void)
{
    const char *biomes[] = {""beaches"", ""birch_forest"", ""birch_forest_hills"", ""cold_beach"", ""deep_ocean"", ""desert"", ""desert_hills"", ""extreme_hills"", ""extreme_hills_with_trees"", ""forest"", ""forest_hills"", ""frozen_ocean"", ""frozen_river"", ""hell"", ""ice_flats"", ""ice_mountains"", ""jungle"", ""jungle_edge"", ""jungle_hills"", ""mesa"", ""mesa_clear_rock"", ""mesa_rock"", ""mushroom_island"", ""mushroom_island_shore"", ""mutated_birch_forest"", ""mutated_birch_forest_hills"", ""mutated_desert"", ""mutated_extreme_hills"", ""mutated_extreme_hills_with_trees"", ""mutated_forest"", ""mutated_ice_flats"", ""mutated_jungle"", ""mutated_jungle_edge"", ""mutated_mesa"", ""mutated_mesa_clear_rock"", ""mutated_mesa_rock"", ""mutated_plains"", ""mutated_redwood_taiga"", ""mutated_redwood_taiga_hills"", ""mutated_roofed_forest"", ""mutated_savanna"", ""mutated_savanna_rock"", ""mutated_swampland"", ""mutated_taiga"", ""mutated_taiga_cold"", ""ocean"", ""plains"", ""redwood_taiga"", ""redwood_taiga_hills"", ""river"", ""roofed_forest"", ""savanna"", ""savanna_rock"", ""sky"", ""smaller_extreme_hills"", ""stone_beach"", ""swampland"", ""taiga"", ""taiga_cold"", ""taiga_cold_hills"", ""taiga_hills"",
                             NULL };

    for(int i = 0; biomes[i] != NULL; i++) {        // changed loop control
        printf(""%s\n"", biomes[i]);                  // changed argument passed
    }
}

int main(void){
    CreateBiomes();
    return 0;
}
</code></pre>

<p>Please note that this function won't do much good, because <code>biomes</code>, a local variable, will not be accessible after the function returns.</p>
",0
44648127,44647303,0,"<p>Try this way, your code should work. </p>

<pre><code>void CreateBiomes()
{

   int BIOME_COUNT = 63;
   char *biomes[]= {""beaches"", ""birch_forest"", ""birch_forest_hills"", ""cold_beach"", ""deep_ocean"", ""desert"", ""desert_hills"", ""extreme_hills"", ""extreme_hills_with_trees"", ""forest"", ""forest_hills"", ""frozen_ocean"", ""frozen_river"", ""hell"", ""ice_flats"", ""ice_mountains"", ""jungle"", ""jungle_edge"", ""jungle_hills"", ""mesa"", ""mesa_clear_rock"", ""mesa_rock"", ""mushroom_island"", ""mushroom_island_shore"", ""mutated_birch_forest"", ""mutated_birch_forest_hills"", ""mutated_desert"", ""mutated_extreme_hills"", ""mutated_extreme_hills_with_trees"", ""mutated_forest"", ""mutated_ice_flats"", ""mutated_jungle"", ""mutated_jungle_edge"", ""mutated_mesa"", ""mutated_mesa_clear_rock"", ""mutated_mesa_rock"", ""mutated_plains"", ""mutated_redwood_taiga"", ""mutated_redwood_taiga_hills"", ""mutated_roofed_forest"", ""mutated_savanna"", ""mutated_savanna_rock"", ""mutated_swampland"", ""mutated_taiga"", ""mutated_taiga_cold"", ""ocean"", ""plains"", ""redwood_taiga"", ""redwood_taiga_hills"", ""river"", ""roofed_forest"", ""savanna"", ""savanna_rock"", ""sky"", ""smaller_extreme_hills"", ""stone_beach"", ""swampland"", ""taiga"", ""taiga_cold"", ""taiga_cold_hills"", ""taiga_hills"", ""void""};
   int i;
   for(i = 0; i &lt; BIOME_COUNT-1; i++)
   {
    printf(""%s\n"", biomes[i]);
   }

   return;
}
</code></pre>
",4
43727489,43713990,-2,"<p>The solution. </p>

<p><a href=""https://es.stackoverflow.com/questions/66325/por-qu%c3%a9-en-c-el-desplazamiento-de-bits-de-un-elemento-de-una-array-de-enteros?noredirect=1#comment121790_66325""> SOLUTION</a>. </p>

<p>Thanks @OscarGarcia and everibody who expended time analizing this code.</p>
",0
43732937,43732902,3,"<p>It's <strong>undefined behavior</strong> because you have used wrong format specifier for <code>char</code> type. So, use <code>%c</code> instead of <code>%s</code>.</p>

<p>c99 7.19.6.1 paragraph 9:</p>

<blockquote>
  <p>If a conversion specification is invalid, the behavior is
  undefined.225) If any argument is not the correct type for the
  corresponding coversion specification, the behavior is undefined.</p>
</blockquote>
",0
43733031,43732902,0,"<p>You should use <code>%c</code> instead of <code>%s</code> while print. Because <code>%s</code> will try to look for an end of line char, since its is not available in memory it throws an exception.</p>

<p>Try with below one, it will work.</p>

<pre><code>int main() {
    char a[2] = {'B','\0'};

    printf(""test %s\n"",a);

    return 0;
}
</code></pre>
",0
40568939,40568891,0,"<p>You are assigning <code>lettergrade</code> to an ASCII value between A(65) and F(70).</p>

<p>But, in the condition, you are checking if value is less than A(65) and more than F(70). </p>

<p>Naturally, if <code>lettergrade</code> falls between A(65) and B(70) (which it will), the <code>return</code> statement won't be evaluated.</p>

<p>Replace</p>

<pre><code>    if(lettergrade &lt;= 'A' &amp;&amp; lettergrade &gt;= 'F'){
        return lettergrade;
    }
    else{
        return -1;
    }
</code></pre>

<p>With</p>

<pre><code>    if(lettergrade &gt;= 'A' &amp;&amp; lettergrade &lt;= 'F'){
        return lettergrade;
    }
    return -1;
</code></pre>

<p>As an extra tip,i would advise you to do away with the <code>else</code> statement as well. The reason being that the control will reach <code>return -1</code> only when the other <code>return</code> statement has not been executed.</p>
",3
40568980,40568891,1,"<p>the condition is not well formed, the 'F' is 70 in <a href=""http://www.asciitable.com/"" rel=""nofollow noreferrer"">ASCII</a> and the 'A' is 65 so </p>

<pre><code>if (lettergrade &lt;= 'A' &amp;&amp; lettergrade &gt;= 'F') {
    return lettergrade;
}
</code></pre>

<p>won't evaluate to true as lettergrade ('A') is less than 70 ('F') and not bigger than it</p>

<p>you'd rather do it this way </p>

<pre><code>if (lettergrade &gt;= 'A' &amp;&amp; lettergrade &lt;= 'F') {
    return lettergrade;
}
</code></pre>

<p>by flipping the bigger than and less than signs</p>
",0
43752290,43752219,0,"<p>Use this:</p>

<pre><code>scanf("" %[^\n]s"", str);
      ^^^
    Whitespace
</code></pre>

<p>instead of</p>

<pre><code>scanf(""%[^\n]s"", str);
</code></pre>

<p>For more information, refer <a href=""https://classes.soe.ucsc.edu/cmps012a/Fall98/faq/scanfQ.html"" rel=""nofollow noreferrer"">this</a> link.</p>
",2
43757659,43752219,0,"<p>Stop using <code>scanf()</code>. The terminal sends your application a full line at a time, but <code>scanf()</code> only consumes the parts it needs, i.e. one character in the case of <code>%c</code> or just all the digits in case of <code>%d</code>. The rest is left in the input buffer, where the following <code>scanf()</code> get them. That causes the user's input and what the program receives to be somewhat ""out of sync"".</p>

<p>It's better to read full lines at a time, with <code>fgets()</code> or <code>getline()</code>, and then parse whatever you want from them. E.g.:</p>

<pre><code>#define LINELEN 255 
char line[LINELEN];
fgets(line, LINELEN, stdin);
int num;
int a = sscanf(line, ""%d"", &amp;num);
</code></pre>

<p>Use whatever format string you require on the <code>sscanf()</code> and put the whole thing in a function if you like. (<code>LINELEN</code> there is of course an arbitrary
limit, but <code>fgets()</code> requires <em>some</em> limit.)</p>

<p>See also: <a href=""http://c-faq.com/stdio/scanfprobs.html"" rel=""nofollow noreferrer"">http://c-faq.com/stdio/scanfprobs.html</a> and the <a href=""http://c-faq.com/stdio/scanfprobs.html"" rel=""nofollow noreferrer"">longer explanation</a> linked there.</p>
",0
43758667,43752219,0,"<p>use scanf like this: <code>scanf(""%s"", str)</code> </p>

<p>Only scanf statements need to be changed:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int top=-1;
int word;


char stack_string[100];
void push(char word);
char pop(void);
int main()
{
char input;
char str[100];
int i;
printf(""press [a] for palindrome check, [b] for string reversal:"");
scanf(""%c"", &amp;input);

if (input == 'b'){
    printf(""Input a string:\n"");
    scanf(""%s"", str);
    for(i=0;i&lt;strlen(str);i++)
        push(str[i]);
    for(i=0;i&lt;strlen(str);i++)
        str[i]=pop();
    printf(""Reversed String is: %s\n"",str);
}
else if(input == 'a'){
    char str[100];
    int count = 0;
    printf(""Input a string:\n"");
    scanf(""%s"", str);

    for (i = 0; i &lt; strlen(str); i++)
    {
        push(str[i]);
    }
 for (i = 0; i &lt; strlen(str); i++)
    {
        if (str[i]==pop())
        count++;
    }

    if (count == strlen(str))
        printf(""%s is a palindrome\n"", str);
    else
        printf(""%s is not a palindrome\n"", str);

}

    return 0;
}

void push(char word)
{
    top=top+1;
    stack_string[top]=word;
}

 char pop()
{
    word = stack_string[top];
    top=top-1;
    return word;
}
</code></pre>
",0
43752290,43752219,0,"<p>Use this:</p>

<pre><code>scanf("" %[^\n]s"", str);
      ^^^
    Whitespace
</code></pre>

<p>instead of</p>

<pre><code>scanf(""%[^\n]s"", str);
</code></pre>

<p>For more information, refer <a href=""https://classes.soe.ucsc.edu/cmps012a/Fall98/faq/scanfQ.html"" rel=""nofollow noreferrer"">this</a> link.</p>
",2
43757659,43752219,0,"<p>Stop using <code>scanf()</code>. The terminal sends your application a full line at a time, but <code>scanf()</code> only consumes the parts it needs, i.e. one character in the case of <code>%c</code> or just all the digits in case of <code>%d</code>. The rest is left in the input buffer, where the following <code>scanf()</code> get them. That causes the user's input and what the program receives to be somewhat ""out of sync"".</p>

<p>It's better to read full lines at a time, with <code>fgets()</code> or <code>getline()</code>, and then parse whatever you want from them. E.g.:</p>

<pre><code>#define LINELEN 255 
char line[LINELEN];
fgets(line, LINELEN, stdin);
int num;
int a = sscanf(line, ""%d"", &amp;num);
</code></pre>

<p>Use whatever format string you require on the <code>sscanf()</code> and put the whole thing in a function if you like. (<code>LINELEN</code> there is of course an arbitrary
limit, but <code>fgets()</code> requires <em>some</em> limit.)</p>

<p>See also: <a href=""http://c-faq.com/stdio/scanfprobs.html"" rel=""nofollow noreferrer"">http://c-faq.com/stdio/scanfprobs.html</a> and the <a href=""http://c-faq.com/stdio/scanfprobs.html"" rel=""nofollow noreferrer"">longer explanation</a> linked there.</p>
",0
43758667,43752219,0,"<p>use scanf like this: <code>scanf(""%s"", str)</code> </p>

<p>Only scanf statements need to be changed:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int top=-1;
int word;


char stack_string[100];
void push(char word);
char pop(void);
int main()
{
char input;
char str[100];
int i;
printf(""press [a] for palindrome check, [b] for string reversal:"");
scanf(""%c"", &amp;input);

if (input == 'b'){
    printf(""Input a string:\n"");
    scanf(""%s"", str);
    for(i=0;i&lt;strlen(str);i++)
        push(str[i]);
    for(i=0;i&lt;strlen(str);i++)
        str[i]=pop();
    printf(""Reversed String is: %s\n"",str);
}
else if(input == 'a'){
    char str[100];
    int count = 0;
    printf(""Input a string:\n"");
    scanf(""%s"", str);

    for (i = 0; i &lt; strlen(str); i++)
    {
        push(str[i]);
    }
 for (i = 0; i &lt; strlen(str); i++)
    {
        if (str[i]==pop())
        count++;
    }

    if (count == strlen(str))
        printf(""%s is a palindrome\n"", str);
    else
        printf(""%s is not a palindrome\n"", str);

}

    return 0;
}

void push(char word)
{
    top=top+1;
    stack_string[top]=word;
}

 char pop()
{
    word = stack_string[top];
    top=top-1;
    return word;
}
</code></pre>
",0
46947584,46945341,1,"<p><code>scanf (""%s %s %f\n"", s[i].name, s[i].lname, &amp;s[i].marks);</code></p>

<p>should be</p>

<p><code>scanf (""%s %s %f"", s[i].name, s[i].lname, &amp;s[i].marks);</code></p>

<p>The <code>\n</code> in scanf just consumes newline char. It will continue consuming newline until a non-newline char is found, which is put back into stdin for the next IO operation</p>
",2
46950040,46945341,0,"<p>Try this Code</p>

<pre><code>#include&lt;stdio.h&gt;
typedef struct student
{
char name[50];
char lname[50];
int mark;
}S;

int main ()
{
int i, j,k;

printf(""Please enter the number of students:\n"");
scanf (""%d"", &amp;j);

S record[j];

for (i = 0; i &lt; j; i++)    {
   printf (""Please enter the information for %d student as asked.\n"",i+1);

  scanf (""%s %s %f"",record[i].name, record[i].lname, &amp;record[i].mark);
}

printf(""Please enter a number\n"");
scanf (""%d"", &amp;k);

printf(""your number was %d \n"", k);

return 0;
}
</code></pre>

<p>You were declaring structure student array in the structure declaration itself.you have to declare the array in main function.</p>
",2
43771721,43771661,2,"<p>The problem is that your summation is outside of the for-loop here:</p>

<pre><code>   for( a = 1; a &lt;= i; a++ ) {
        printf(""%i\n"", a);
    }
    sum += a;
    printf(""The total is %i"",a);
</code></pre>

<p>What this does is print that statement multiple times, then do the sum once.</p>

<p>What you want is this:</p>

<pre><code>    for( a = 1; a &lt;= i; a++ ) {
        printf(""%i\n"", a);
        sum += a;
    }
</code></pre>

<p>Also, if you'd like to print the sum, you want <code>printf(""The total is %i\n"", sum);</code>
rather than <code>printf(""The total is %i"", a);</code>.</p>
",0
46099792,46098876,1,"<p>In the comments I wrote:</p>

<blockquote>
  <p>This kind of ""don't use the most appropriate tool to solve"" problem should be a red flag to you; your resource, whatever it is, is teaching you to solve problems in an inappropriate way. Why, in the real world, would anyone not use loops in C here? Alternatively, if the author wants to teach functional programming, why would they use a non-functional language likc C? <strong>Get a better book!</strong></p>
</blockquote>

<p>Nonetheless, here I find myself offering an answer...</p>

<p>First off, <strong>they're technically both loops</strong>! I gather when you state that you <em>can't use any loop</em>, you're actually referring to <em>procedural loops</em> (i.e. loops built from <code>goto</code>, <code>while</code>, <code>do...while</code> or <code>for</code>), and not <em>functional loops</em> (which are built by recursive function application). They're both technically <em>loops</em>, and since C is a procedural language <strong>you should use procedural loops</strong>. Nonetheless...</p>

<p><strong>There's a pattern!</strong> Procedural loops can be converted to functional loops simply by observing and reproducing a pattern. That is, every procedural loop has an equivalent functional loop, and they all end up looking very similar. Look for the pattern below.</p>

<p>Here's a function containing a basic <em>procedural loop</em>:</p>

<pre><code>void procedural_loop_on_str(char const *source, size_t source_position, int *dest, size_t dest_position) {
    while (source[source_position] != '\0') {
        source_position++;
    }
}
</code></pre>

<p>... and here it is as a functional loop:</p>

<pre><code>void functional_loop_on_str(char const *source, size_t source_position, int *dest, size_t dest_position) {
    if (source[source_position] != '\0') {
        source_position++;
        functional_loop_on_str(source, source_position, dest, dest_position);
    }
}
</code></pre>

<p>The two pieces of code seem very similar, don't they? Any procedural loop can be trivially translated to a functional equivalent based on this observation; all you'll be doing is adding the extra code that fills in your loop. As an exercise, consider isolating the parts of this code that are identical. They generally sit in the same place in both pieces of code; they're not hard to find! In fact, here are those differences, side-by-side:</p>

<pre><code>    while ...                                  if ...
                                                   functional_loop_on_str...
</code></pre>

<p>The only difficulties come in place when backtracking is necessary, which is irrelevant for this question. Hence, you should be able to write the <em>procedural version</em> and translate it to a <em>functional version</em> easily. Allow me to start you off:</p>

<pre><code>void procedural_loop_on_str(char const *source, size_t source_position, int *dest, size_t dest_position) {
    while (source[source_position] != '\0') {
        int value, nbytes, success = sscanf(source + source_position, ""%d%n"", &amp;value, &amp;nbytes);
        if (!success) { nbytes = 1; }
        else { /* XXX: You do this part!
                *      You need to do something with value, dest and dest_position */
        }
        source_position += nbytes;
    }
}
</code></pre>

<p>... and here it is translated to our <em>functional version</em> by <em>reproducing the pattern</em>:</p>

<pre><code>void functional_loop_on_str(char const *source, size_t source_position, int *dest, size_t dest_position) {
    if (source[source_position] != '\0') {
        int value, nbytes, success = sscanf(source + source_position, ""%d%n"", &amp;value, &amp;nbytes);
        if (!success) { nbytes = 1; }
        else { /* XXX: You do this part!
                *      You need to do something with value, dest and dest_position */
        }
        source_position += nbytes;
        functional_loop_on_str(source, source_position, dest, dest_position)
    }
}
</code></pre>

<p><strong>Notice how little has actually changed between the two examples; most of the pattern is still there!</strong> Recall the exercise above? Well, you can do the same here to find that the same changes are made in the same place when converting from procedural to functional.</p>

<p>I think this pattern would've been obvious to you had you read a (better) book about functional programming and a (better) book about C programming, or even created these basic examples yourself to observe the pattern. Nonetheless, I stand by my beliefs that:</p>

<ol>
<li>You shouldn't be using <em>functional loops</em> in C or any procedural language for that matter, but specifically <em>not</em> C; if C were designed for every-day functional looping, there'd be optimisation guarantees in the standard. If your guide is guiding otherwise, consider choosing a new guide such as the book with the giant blue ""C"", written by founding forefathers of C Kernighan &amp; Richie (choose the <em>second edition</em>). I'll leave you to find that one.</li>
<li>You shouldn't be using <em>procedural languages</em> to study <em>functional elements</em>. This is a no-brainer. Consider Scheme; there's a REALLY NICE ""wizard book"" about Scheme!</li>
</ol>

<p>Either way, it appears you need a <em>better book</em>!</p>
",9
46099028,46098876,0,"<p>pass a pointer to the end of you integer array as an argument to the function s well as a pointer to the current character in the string. if not white space, add the number to the int array and increment the int pointer. increment the char pointer appropriatley regaurdless and recurse. I assume you can handle converting strings to ints, there are many posts to help with this if not.</p>
",0
46099045,46098876,0,"<p><a href=""http://www.cplusplus.com/reference/cstdio/sscanf/"" rel=""nofollow noreferrer"">sscanf</a> sounds like the tool you need. It's the one I would use. You can recursively read your string into your int array. I would also create an int array with 501 positions, since that is the highest amount of ints you can get(if each int is just a single digit number and there is just one space between them).</p>

<p>Alternatively you could use <a href=""http://www.cplusplus.com/reference/cstdlib/atoi/"" rel=""nofollow noreferrer"">atoi</a></p>
",0
43956543,43956500,0,"<p>It's because after this loop</p>

<pre><code>for (Counter = Counter - 1; Counter &gt;= 0; Counter--)
    {
        printf(""%d"", BinaryArray[Counter]);
    }
</code></pre>

<p>Counter will be set to 0. To fix store is value in a var, and  use it in the for loop instead of using the Counter var.</p>
",0
43956689,43956500,0,"<p>You have a loop in the loop using the same global control variable. What to do:</p>

<ol>
<li>Use another variables for particular loop</li>
<li>Use local variables in the for loops.</li>
</ol>
",0
43967535,43967453,0,"<p>Your function definition is wrong in terms of good code practices.</p>

<p>Instead of</p>

<pre><code>int Occur(char S[100], char L)
</code></pre>

<p>You should write it as</p>

<pre><code>int Occur(char S[] , char L)
</code></pre>

<p>because otherwise your code would specifically look to accept strings of size not more than 100 chars.</p>

<p>Apart from that as Ilario Pierbattista said its a input buffer problem.
The stdin needs to get cleared before taking further input, hence the juggad of putting scanf before a getchar() call would work.</p>
",2
43967538,43967453,5,"<p>First, you should have tried debugging your code. If you would have done it, you would have seen that the letter you thought L holds is not what L actually holds.</p>

<p>Second, your problem is simple, L is not getting the letter you enter because of the enter from the string before is stuck in the scanf buffer... use <code>scanf ("" %c"")</code> [with preceeding whitespace] to resolve. </p>

<p>As mentioned in other answers, there are other solutions like the unrecommended <code>fflush()</code>. An alternative that is not considered harmful is <code>getchar()</code> between the <code>scanf(""%s"")</code> and the <code>scanf(""%c"")</code>. That will give you the same effect as using <code>scanf("" %c"");</code> </p>

<p>The reason that all of these methods work is because they all consume the last <code>char</code> (which is, in your case the <code>\n</code>) stuck in the buffer, and thus allowing the <code>%c</code> to consume the <code>char</code> you actually intend to read</p>
",0
43967547,43967453,0,"<p>It's an input buffer problem. The char is read by <code>getchar</code> instead of <code>scanf</code>.
Doing <code>l = getchar()</code> solves the problem (the call of <code>scanf</code> just before clears the input buffer).</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int Occur(char [],char);


int main()
{

char s[100],l;
printf(""Enter A String:\n"");
scanf(""%s"",s);
printf(""Enter A Letter:\n"");
scanf(""%c"",&amp;l);
l = getchar();

printf(""Num Of Occurance is %d "",Occur(s,l));


return 0;
}


int Occur(char S[100],char L){

int i;
int num=0;

for(i=0;S[i]!='\0';i++){

if(S[i]==L)
    num++;
}

return num;

}
</code></pre>
",0
43967706,43967453,3,"<p>Reason of problem : </p>

<p><code>scanf(""%c"",&amp;l)          //Here %c takes enter key of scanf(""%s"",s);</code>;</p>

<p>So, there are mainly 2 solution to your problem:</p>

<p><strong>Sol. 1</strong>     => <code>scanf("" %c"",&amp;l)           //use whitespace before %c</code></p>

<p><strong>Sol. 2</strong>    =>   Use  <em>fflush(stdin)</em> that flushes the output buffer of a stream.</p>

<pre><code>int main()
{

char s[100],l;
printf(""Enter A String:\n"");
scanf(""%s"",s);
printf(""Enter A Letter:\n"");
fflush(stdin);                       //here fflush(stdin) used to flushes the output buffer.
scanf(""%c"",&amp;l);
l = getchar();
......
......
}
</code></pre>

<p><strong>NOte:</strong> Since fflush(stdin) has  undefined behavior so, always use priority to Solution 1 , instead of fflush().  :)</p>
",1
43758429,43758006,-1,"<pre><code>#include&lt;stdio.h&gt;
#include&lt;math.h&gt;

 void main()
 {
int a, h;
double interres;
double base;
printf(""Input  a: "");
scanf(""%d"", &amp;a);
printf(""Input  height h: "");
scanf(""%d"", &amp;h);
base =(double)((a*a) * sqrt(3))/ 4;//line 13
interres =(double) (a *a)  * sqrt(3);//line 14

printf(""(%d^2*sqrt(3))/4=(%d^2*%f)/4=(%f*%f)/4=%f/4=%f cm"",a,a,sqrt(3),a*a,sqrt(3),interres,base);

 }
</code></pre>
",1
43763774,43758006,0,"<p>Several issues:</p>

<p>In C and C++, <code>main</code> returns <code>int</code>, not <code>void</code>.  Unless your compiler documentation explicitly lists <code>void main()</code> as a valid signature, using it invokes undefined behavior.  <code>main</code> should be defined as </p>

<pre><code>int main( void )
</code></pre>

<p>if you don't take any command line arguments, or</p>

<pre><code>int main( int argc, char **argv )
</code></pre>

<p>if you do.</p>

<p>Secondly, the <code>^</code> operator is the bitwise XOR operator, not an exponentiation operator; neither C nor C++ have an exponentiation operator.  You must either use the <code>pow</code> function in the standard library or roll your own.  </p>

<p>Finally, <code>scanf</code> <em>can</em> be unsafe when reading input with either the <code>%s</code> or <code>%[</code> conversion specifiers, which you aren't doing.  Personally, I'd disable the warning as described in the error message.  </p>
",0
43758429,43758006,-1,"<pre><code>#include&lt;stdio.h&gt;
#include&lt;math.h&gt;

 void main()
 {
int a, h;
double interres;
double base;
printf(""Input  a: "");
scanf(""%d"", &amp;a);
printf(""Input  height h: "");
scanf(""%d"", &amp;h);
base =(double)((a*a) * sqrt(3))/ 4;//line 13
interres =(double) (a *a)  * sqrt(3);//line 14

printf(""(%d^2*sqrt(3))/4=(%d^2*%f)/4=(%f*%f)/4=%f/4=%f cm"",a,a,sqrt(3),a*a,sqrt(3),interres,base);

 }
</code></pre>
",1
43763774,43758006,0,"<p>Several issues:</p>

<p>In C and C++, <code>main</code> returns <code>int</code>, not <code>void</code>.  Unless your compiler documentation explicitly lists <code>void main()</code> as a valid signature, using it invokes undefined behavior.  <code>main</code> should be defined as </p>

<pre><code>int main( void )
</code></pre>

<p>if you don't take any command line arguments, or</p>

<pre><code>int main( int argc, char **argv )
</code></pre>

<p>if you do.</p>

<p>Secondly, the <code>^</code> operator is the bitwise XOR operator, not an exponentiation operator; neither C nor C++ have an exponentiation operator.  You must either use the <code>pow</code> function in the standard library or roll your own.  </p>

<p>Finally, <code>scanf</code> <em>can</em> be unsafe when reading input with either the <code>%s</code> or <code>%[</code> conversion specifiers, which you aren't doing.  Personally, I'd disable the warning as described in the error message.  </p>
",0
46109644,46107545,0,"<p>Since the message printed before reading value in <code>name</code> is <i>Enter the username</i> and as usernames are usually strings, I suppose you are reading a string and not a single character.</p>

<p>If that's the case, change</p>

<pre><code>char name;
</code></pre>

<p>to</p>

<pre><code>char name[20]; //20 is just a number. Make it bigger if you need
</code></pre>

<p>because a string is just a sequence of characters which may be stored in a character array.</p>

<p>You could use <code>fgets()</code> to read into <code>name</code>.</p>

<pre><code>fgets(name, sizeof(name), stdin);
</code></pre>

<p>fgets will stop reading when a <code>\n</code> is encountered but the <code>\n</code> will be stored in <code>name</code> as well.</p>

<p>So replace the <code>\n</code> with <code>\0</code> to mark the end of string.</p>

<pre><code>name[strlen(name)-1]='\0';
</code></pre>

<p>For finding the length of the string with <code>strlen()</code> for storing into <code>len</code>.</p>

<pre><code>else if((isdigit(name)) || (isalpha(name))) //this one does not work
{
    printf(""invalid"");
}
</code></pre>

<p>If you are checking the last character entered into <code>name</code> in the <code>else if</code>, it may be re-written as </p>

<pre><code>else if(isalnum(name[len-1]))
{
    printf(""invalid"");
}
</code></pre>

<p><code>isalnum()</code> will return non-zero if its argument is alphanumeric.</p>

<p><br><hr><br></p>

<p>Now in case you really did mean <code>name</code> to be a single character and just need the last entered character for comparison in the <code>else if</code>.</p>

<p>If <code>name</code> is a <code>char</code>, <code>sizeof(char)</code> must be <code>1</code>. So</p>

<pre><code>for (i = 0; i &lt;= (sizeof(name)/2); i ++)
{
    len++; 
}
</code></pre>

<p>is equivalent to just</p>

<pre><code>len++;
</code></pre>

<p>as <code>sizeof(name)/2</code> is <code>0</code>.</p>

<p>Note that <code>getchar()</code> returns an <code>int</code> and not a <code>char</code> and the value returned is <code>EOF</code> if some error occurred.</p>

<p>Try</p>

<pre><code>while (name != '\n' &amp;&amp; name != EOF)
</code></pre>
",0
44700859,44700171,0,"<p>In your <code>main()</code>, you call  </p>

<pre><code>   RatingMovie();
</code></pre>

<p>But RatingMovie's definition is</p>

<pre><code>void RatingMovie(int num_movie);
</code></pre>

<p>Indicates <code>RatingMovie()</code> expects an int as a parameter. </p>

<p>Since you did not declare <code>RatingMovie()</code> before caling it in <code>main()</code>, the compiler at that point thinks RatingMovie takes no parameter and returns an int.</p>

<p>At runtime, when your program calls <code>RatingMovie()</code> from <code>main()</code>, <code>RatingMovie(int num_movie)</code> receives garbage as its <code>num_movies</code> parameter, resulting in undefined behavior.  In  this case your program crashes, probably because <code>num_movie</code> is negative or really big.</p>

<p>Other issues are imho: </p>

<ul>
<li>You call <code>RatingMovie()</code> twice in your code.  Pick one. </li>
<li><code>struct movie_show mov_show[num_movie];</code>  num_movie is not a constant, this is non-standard C.  Use a constant for the maximum of movies, or allocate an array with <code>calloc()</code> or <code>malloc()</code></li>
<li>calling <code>exit(0);</code> from <code>NumMovie()</code>  is not very elegant.  There must be a more elegant way of handling exit as part of the normal flow of your app.  </li>
</ul>

<p>If you move all of your function bodies before main(), and reorder your functions and fix all issues until your compiler issues <strong>no more warnings</strong>, your program should run fine.</p>
",6
45048492,45048210,1,"<p>I start from strange line of your code, and then I will try to answer the question. </p>

<p>Statement</p>

<pre><code> printf(argv[1], line);
</code></pre>

<p>make me curious - what you what to print, actually?</p>

<p>Here <code>line</code> is not initialized, and <code>argv[1]</code> can hardly be used as format line.</p>

<p>So I suppose it should be just</p>

<pre><code> printf(argv[1]);
</code></pre>

<p>or</p>

<pre><code> printf(""Filename is %s\n"", argv[1]);
</code></pre>

<p>As for reading from a file with name provided as <code>argv[1]</code> your code looks able to work, I mean your code read line by line till the end of file and prints these lines at the screen.</p>

<p>If you want to change this logic, e.g. read only 4 first line, add condition with counter, e.g.:</p>

<pre><code>int cnt;
for (cnt = 0; cnt &lt; 4; cnt++) // repeat reading 4 times
{
    if (fgets(line, 1000, pt) != NULL)
        printf(""%s"", line);
    else
        break; // stop when reading fails
}
</code></pre>

<p>or (I prefer this version)</p>

<pre><code>int cnt = 0;
while (fgets(line, 1000, pt) != NULL &amp;&amp; cnt &lt; 4)
{
    printf(""%s"", line);
    cnt++;
}
</code></pre>

<p>Such changes allows to stop reading (as well as output), so only 4 or less lines will be shown at console screen.</p>

<p>Finally, for case when you want to show file by groups of 4 (or other constant value), consider the following snippet:</p>

<pre class=""lang-cpp prettyprint-override""><code>#include &lt;stdio.h&gt;

#define MAX_LINES_TO_PRINT 4

int main(int argc, char *argv[])
{

    char line[1000];
    FILE *pt;

    pt = fopen(argv[1], ""r"");
    if (pt == NULL) return -1;
    printf(""Filename is %s\n"", argv[1]);
    int cnt = 0;
    while (fgets(line, 1000, pt) != NULL)
    {
        printf(""%s"", line);
        cnt++;
        if (cnt % MAX_LINES_TO_PRINT == 0)
        {
            int answer;
            printf(""[%d lines printed] Continue? (Y/N) : "", cnt);
            answer = getchar(); // get user's response
            while (getchar() != '\n'); // clean input buffer after getchar
            if (toupper(answer) == 'N')
            {
                break; // stop reading the file
            }
        }
    }
    fclose(pt);
    return 0;
}
</code></pre>

<p>Try this program with your file and ask question if something is unclear.</p>

<p>Changing the value in the line <code>#define MAX_LINES_TO_PRINT 4</code> you can regulate maximum number of lines printed at once (before the next request to continue), e.g.   <code>#define MAX_LINES_TO_PRINT 15</code> make your program printing up to 15 lines.</p>
",2
46638923,46638895,4,"<p>You can't use printf outside of an function. Move the line ""int a = printf..."" inside main.</p>

<p>You variable ""a"" is an global variable. You can only initialize ""a"" with an constant. For example:</p>

<pre><code>int a = 42;

int main()
{
   a = printf(...
</code></pre>
",0
43924831,43913796,0,"<p>Your <code>Team</code> array has 2 elements, but you are putting stuff into indexes 1 and 2.  Arrays in C are zero-based - the first element is <code>[0]</code>, so you want to use elements <code>[0]</code> and <code>[1]</code> instead:</p>

<pre><code>Team t[2];
...
sprintf(t[0].name_team,""%s"",""Orange"");
sprintf(t[1].name_team,""%s"",""Verte"");
... 
// etc - change all t[1] references to t[0], and all t[2] references to t[1]
</code></pre>

<p>Also change your <code>for</code> loop to <code>for (i=0;i&lt;2;i++)</code>.</p>

<p>When you write into index <code>[2]</code>, you are overwriting memory that doesn't belong to you and corrupting the stack.</p>
",1
43926714,43912254,0,"<p>The error is the <code>if( number[j] != number[k] )</code>line as pointed out by BluePixy.</p>

<p>The correction is <code>if( number[j-1] != number[k] )</code></p>

<p>I would to point out that the code has hidden the problem partly because of a smattering of one letter variable names and inconsistent naming.</p>

<p>Here is the code that I used to find the same solution</p>

<pre><code>int is_huiwen_2(int L )
{
    int ret = 1;
    int j = 0;
    int k = 0;
    int t = L * L;
    int number[8] = { 0 };

    for( j = 0; t; j++)
    {
        number[j] = t % 10;
        t /= 10;
    }

    for( k = 0; (j - k) &gt; 0 &amp;&amp; ret; k++, j-- )
    {
        if( number[j-1] != number[k] )
        {
            ret = 0;
        }
    }
    return( ret );
}

int is_huiwen_1( int L )
{
    int ret = 1;
    int y = 0;
    int t = L * L;
    int x = t;

    do
    {
        y = y * 10 + t % 10;
        t /= 10;
    }
    while( t );

    if( x != y )
    {
        ret = 0;
    }
    return( ret );

}

int main()
{
    int i = 0;
    int flag = 0;

    for( i = 0; i &lt; 256; i++)
    {
        flag = is_huiwen_1(i);

        if(flag)
        {
            printf(""1: %d is huiwen\n"",i);
        }
    }

    for( i = 0; i &lt; 256; i++)
    {
        flag = is_huiwen_2(i);

        if(flag)
        {
            printf(""2: %d is huiwen\n"",i);
        }
    }

    printf(""end\n"");

    return( 0 );
}
</code></pre>

<p>I don't know what all the variables do. The use of 'l' looks like a '1' in some editors.</p>

<p>Being a Code Refactoring monk or zealot, I did some modifications such as reducing the code to one consistent return condition, value and point of return.
While it might seem overly simple, having multiple declarations on one line hides trouble, such as <code>int i</code> not being used in the second function.
The use of <code>int numbers[20] = { 0 };</code> was also misleading us as for the range of values here <code>[20]</code> was overkill, having an explanation of what the range of values ""12321"", ""1234321"" where could have meant easier debugging of this code. A simple comment of what the outcome should look like would have solved several problems.</p>

<pre><code>// A Huiwen number looks like this ""12321"", ""1589851""
</code></pre>

<p>While this might be a simple exercise it portends greater problems down the line if this was not a trivial exercise. Try not to make it hard on the next coder.</p>

<p>Document your algorithms, arithmetic and variables please.</p>
",0
43957962,43957073,1,"<p>Your code structure is slightly crazy. In general, you should never include a <code>.c</code> file, especially not in a header. What you're doing is even more confusing: You're including <code>bq.h</code> in <code>BinaryFile.c</code> and <code>BinaryFile.c</code> in <code>bq.h</code>, forming an infinite loop of includes.</p>

<p>What you should do instead is ... well, it depends. This code seems simple enough that you can just put it all in a single <code>.c</code> file and be done with it.</p>

<p>If you want to structure your code in a way that uses multiple files, then you should think about modules, i.e. units of related functionality. For example, you could have a module that defines a binary tree type and functions that work on that tree.
For each such module, you would write a <code>.h</code> file that describes the module interface and a <code>.c</code> file that implements the interface.</p>

<p>Your code could be split into three parts: A binary tree module, a queue module, and a main program.</p>

<p>You would have a binary tree header, <code>tree.h</code>:</p>

<pre><code>#ifndef TREE_H_
#define TREE_H_

typedef struct tree
{
    int info;
    struct tree *left;
    struct tree *right;
}
tree;

void createBST(void);
void inputBST(int);
void printBST_1(void);

#endif
</code></pre>

<p>Note that the header only contains type definitions and function declarations (if you decide to use global variables in your interface, you would also put variable declarations here (but you should avoid global variables where possible)).</p>

<p>A corresponding implementation file, <code>tree.c</code>:</p>

<pre><code>// important: include our own interface definition to make sure it matches our implementation
#include ""tree.h""
#include &lt;stdlib.h&gt;

// private functions/variables (those not part of our interface) are marked 'static'
static tree *head;

void createBST(void) {
    ...  // your code goes here
}

void inputBST(int) {
    ... // your code goes here
}

void printBST_1(void) {
    ... // your code goes here
}
</code></pre>

<p>Similarly, for queues you would have a <code>bq.h</code>:</p>

<pre><code>#ifndef BQ_H_
#define BQ_H_

#include ""tree.h""

typedef struct queue
{
    //int info;
    tree *info; //tree node in queue....
    struct queue *next;
}
queue;

void createemptystack(void);
void enqueue(tree *);
tree *dequeue(void);
tree *peek(void);
int is_empty(void);

#endif
</code></pre>

<p>And a corresponding <code>bq.c</code>:</p>

<pre><code>#include ""bq.h""

static queue *front;
static queue *rear;

void createemptystack(void) {
    ...  // your code goes here
}

...  // other function definitions go here
</code></pre>

<p>Finally, you have <code>main.c</code>:</p>

<pre><code>#include ""tree.h""
#include ""bq.h""
#include &lt;stdio.h&gt;

int main(void) {
    ...  // your code goes here
    return 0;
}
</code></pre>

<p>In short: Only include header files, and never put function or variable definitions in headers (headers should only contain declarations).</p>
",1
45069559,45069490,0,"<p>Change your declaration from</p>

<pre><code>Word* addWord(Word* top, Word* newNode)   // my function declaration
</code></pre>

<p>to</p>

<pre><code>struct Word* addWord(Word* top, Word* newNode)   // my function declaration
</code></pre>

<p>Notice the <code>struct</code> keyword. This is because in C, structure instances have the following syntax:</p>

<pre><code>struct struct-name instance-name;
</code></pre>

<p>Or, you could define your struct like this</p>

<pre><code>tyepdef struct Word
 {
     char data[10];                         //my structure
     struct Word *nextWord;
     struct Word  *lastWord;
 };
</code></pre>

<p>The <code>typedef</code> keyword allows us to write just <code>Word *w</code> instead of <code>struct Word *w</code>.</p>
",1
45069621,45069490,0,"<p>You have to add <code>struct</code> to the struct name when creating a new variable type. That is <code>struct Word *newWord;</code>, read more information here <a href=""https://en.wikipedia.org/wiki/Struct_(C_programming_language)"" rel=""nofollow noreferrer"">C struct</a></p>

<p>Change this</p>

<p><code>Word* addWord(Word* top, Word* newNode)</code></p>

<p>to this</p>

<p><code>struct Word* addWord(struct Word* top, struct Word* newNode)</code></p>
",0
45071720,45069490,0,"<p>if you are using C++ program then you need not to declare the struct keyword but as you are in C program then in the function add a struct key word i.e.
struct Word* addWord(struct Word* top, struct Word* newNode);</p>
",0
45086663,45086618,2,"<p>you could start by dropping <code>else if ( val1 == val2 )</code> for just <code>else</code>, since it's the only case left, and you will avoid floating point equality error at worst and at best simplify your code a little bit.</p>

<p>But the real culprit is this line:</p>

<pre><code>result = pow( val1 + val2 , 3/4 ) ;
</code></pre>

<p><code>3/4</code> is <code>0</code> because of <em>integer division</em>. Use <code>3.0/4</code> for instance or just <code>0.75</code>.</p>
",4
46618205,46618180,1,"<p>Add <code>*</code> to type definition <code>char * hostnames[5][2]</code>. This must be array of pointers, not simple <code>char</code>s. Another necessary change is <code>strcpy</code> instead of <code>=</code> in <code>strcpy( hostname, getClientHostName(""122.205.26.34"") );</code>.</p>

<p>PS: Always try to compile with 0 compiler warnings, not only 0 errors!</p>
",0
46618229,46618180,2,"<p>After fixing the compiler errors and warnings you get:</p>

<pre><code>const char* getClientHostName(const char* client_ip) {

    const char * hostnames[5][2];
    hostnames[0][0] = ""122.205.26.34"";
    hostnames[0][1] = ""aaaaa"";
    hostnames[1][0] = ""120.205.36.30"";
    hostnames[1][1] = ""bbbbb"";
    hostnames[2][0] = ""120.205.16.36"";
    hostnames[2][1] = ""ccccc"";
    hostnames[3][0] = ""149.205.36.46"";
    hostnames[3][1] = ""dddddd"";
    hostnames[4][0] = ""169.205.36.33"";
    hostnames[4][1] = ""eeeeee"";
    for(int i = 0; i&lt;5; i++) {
        if(!strcmp(hostnames[i][0], client_ip))
            return hostnames[i][1];
    }
    return NULL;
}

int main(int argc, char* argv[]) {
    const char * hostname = getClientHostName(""128.205.36.34"");
    printf(""%s\n"", hostname);
}
</code></pre>
",0
46618251,46618180,2,"<blockquote>
  <p>Is there a even better way where I don't have to hardcode the size?</p>
</blockquote>

<p>Take the habit to compile with all warnings and debug info: <code>gcc -Wall -Wextra -g</code> with <a href=""http://gcc.gnu.org/"" rel=""nofollow noreferrer"">GCC</a>. Improve the code to get no warnings at all.</p>

<p>If you want to get genuine IP addresses, this is operating system specific (since standard <a href=""https://en.wikipedia.org/wiki/C11_(C_standard_revision)"" rel=""nofollow noreferrer"">C11</a> don't know about IP addresses; check by reading <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""nofollow noreferrer"">n1570</a>). On Linux you would use name service routines such as <a href=""http://man7.org/linux/man-pages/man3/getaddrinfo.3.html"" rel=""nofollow noreferrer"">getaddrinfo(3)</a> &amp; <a href=""http://man7.org/linux/man-pages/man3/getnameinfo.3.html"" rel=""nofollow noreferrer"">getnameinfo(3</a>) or the obsolete <a href=""http://man7.org/linux/man-pages/man3/gethostbyname.3.html"" rel=""nofollow noreferrer"">gethostbyname(3)</a>.</p>

<p>If this is just an exercise without actual relationship to TCP/IP sockets (see <a href=""http://man7.org/linux/man-pages/man7/tcp.7.html"" rel=""nofollow noreferrer"">tcp(7)</a>, <a href=""http://man7.org/linux/man-pages/man7/ip.7.html"" rel=""nofollow noreferrer"">ip(7)</a>, <a href=""http://man7.org/linux/man-pages/man7/socket.7.html"" rel=""nofollow noreferrer"">socket(7)</a>) you could store the table in some <em>global</em> array:</p>

<pre><code> struct myipentry_st {
   const char* myip_hostname;
   const char* myip_address;
 };
</code></pre>

<p>then define a <a href=""https://en.wikipedia.org/wiki/Global_variable"" rel=""nofollow noreferrer"">global</a> array containing them, with the convention  of terminating it by some <code>{NULL, NULL}</code> entry:</p>

<pre><code>const struct myipentry_st mytable[] = {
    {""aaaaa"", ""122.205.26.34""},
    {""bbbb"", ""120.205.36.30""},
    /// etc
    {NULL, NULL} // end marker
};
</code></pre>

<p>You'll better have a <em>global</em> or <a href=""https://en.wikipedia.org/wiki/Static_variable"" rel=""nofollow noreferrer"">static variable</a> (not an <a href=""https://en.wikipedia.org/wiki/Automatic_variable"" rel=""nofollow noreferrer"">automatic</a> one sitting on the <a href=""https://en.wikipedia.org/wiki/Call_stack"" rel=""nofollow noreferrer"">call stack</a>) because you don't want to fill it on every call to your <code>getClientHostName</code>.</p>

<p>Then your lookup routine (inefficient, since in linear time) would be:</p>

<pre><code>const char* getClientHostName(char* client_ip) {
   for (const struct myipentry_st* ent = mytable;
        ent-&gt;myip_hostname != NULL;
        ent++)
   // the if below is the only statement of the body of `for` loop
     if (!strcmp(ent-&gt;myip_address, client_ip))
         return ent-&gt;myip_hostname;
   // this happens after the `for` when nothing was found
   return NULL;
}
</code></pre>

<p>You could even declare that table as a <a href=""https://en.wikipedia.org/wiki/C_dynamic_memory_allocation"" rel=""nofollow noreferrer"">heap allocated</a> pointer:</p>

<pre><code>const struct myipentry_st**mytable;
</code></pre>

<p>then use <code>calloc</code> to allocate it and read its data from some text file.  </p>

<p>Read the documentation of every <a href=""http://en.cppreference.com/w/c"" rel=""nofollow noreferrer"">standard</a> or external function that you are using. Don't forget to check against failure (e.g. of <code>calloc</code>, like <a href=""https://stackoverflow.com/a/26551951/841108"">here</a>). Avoid <a href=""https://en.wikipedia.org/wiki/Memory_leak"" rel=""nofollow noreferrer"">memory leaks</a> by appropriate calls to <code>free</code>. Use the debugger <code>gdb</code> and <a href=""http://valgrind.org/"" rel=""nofollow noreferrer"">valgrind</a>. Beware of <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behavior</a>.</p>

<p>In the real world, you would have perhaps thousands of entries and you would perform the lookup many times (perhaps millions of times, e.g. once per every <a href=""https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol"" rel=""nofollow noreferrer"">HTTP</a> request in a web server or client). Then choose a better <a href=""https://en.wikipedia.org/wiki/Data_structure"" rel=""nofollow noreferrer"">data structure</a> (<a href=""https://en.wikipedia.org/wiki/Hash_table"" rel=""nofollow noreferrer"">hash table</a> or <a href=""https://en.wikipedia.org/wiki/Red%E2%80%93black_tree"" rel=""nofollow noreferrer"">red-black tree</a> perhaps). Read some <a href=""https://en.wikipedia.org/wiki/Introduction_to_Algorithms"" rel=""nofollow noreferrer""><em>Introduction to Algorithms</em></a>.</p>
",1
46622352,46622302,2,"<p>For one thing, you need to allocate storage for that struct... right now all you have a single pointer.  Right at the top of your loop, you should do something like:</p>

<pre><code>allClients[i] = malloc(sizeof(clientDetails));
</code></pre>

<p>It's been a while since I've done structs in ""C"", but you could/should probably <code>typedef</code> your struct as well.</p>
",1
40577579,40577532,1,"<p>There's no 12th element in your array; they are only 11 elements in <code>p</code>.Your assignments (<code>p[11] = 'e primo';</code>) are thus results in <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer""><em>undefined behaviour</em></a>.</p>

<p><code>'e primo'</code> is a multi-byte character literal with implementation-defined behaviour. You probably want to use <code>strcpy()</code> to copy. </p>

<pre><code>strcpy(p, ""e primo"");
</code></pre>

<p>(and increase the array size to accommodate longer string in your other string copy as pointed in the comment).</p>

<p>Or, you can simply use a pointer that point to the string literal as yo don't really need the array.</p>

<pre><code>char *p = ""nao e primo"";
printf(""Informe um numero para checar se e primo: "");
scanf(""%d"", &amp;n);
do {
    if (n % c == 0) {
        p = ""e primo"";
        break;
    } else {
        p = ""nao e primo"";
    ...

printf(""\nO numero %s"", p);
</code></pre>

<p>Related: <a href=""https://stackoverflow.com/questions/3683602/single-quotes-vs-double-quotes-in-c-or-c"">Single quotes vs. double quotes in C or C++</a></p>
",1
40577628,40577532,0,"<p>Firstly, you cannot say</p>

<pre><code>p[11] = 'e primo';
</code></pre>

<p>p is array of chars, and with p[11] you can set or retrieve the char on 11th position. Secondly, there is no char with index 11. In C, indexing begins from 0, so you can retrieve chars at p[0], p[1], ..., p[10]. 11 elements. </p>

<p>Did you read warnings?</p>

<pre><code>1.c: In function ¡®main¡¯:
1.c:16:21: warning: character constant too long for its type
             p[11] = 'e primo';
                     ^
1.c:16:21: warning: overflow in implicit constant conversion [-Woverflow]
1.c:21:21: warning: character constant too long for its type
             p[11] = 'nao e primo';
                     ^
1.c:21:21: warning: overflow in implicit constant conversion [-Woverflow]
</code></pre>

<p>It actually says that <code>character constant too long for its type</code>.</p>

<p>What you can say:</p>

<pre><code>p[10] = 'e'
</code></pre>

<p>Then, with %s you print ""string"": array of characters <strong>determined with determinate 0</strong>.
So, after last character that should be visible, you have to say e.g.:
p[10] = '\0'.</p>

<p>I would make the code work, but I am not sure what is actually the point. As it seems, you are always assigning last character to something.</p>
",1
40577678,40577532,1,"<p>Your program has some problems:</p>

<ul>
<li><p>you cannot copy string with a simple assignment <code>p[11] = 'e primo';</code>.  You could use <code>strcpy()</code> with a string if you make the buffer larger or you could just use a string pointer <code>const char *p;</code>.</p></li>
<li><p>The loop runs forever if <code>n</code> is less than <code>4</code>.  More precisely, it invokes undefined behavior when <code>c = c + 1;</code> causes arithmetic overflow.</p></li>
<li><p>The result is the exact opposite for other values.</p></li>
<li><p>The loop is very slow for large prime numbers, you should stop when <code>c * c &gt; n</code>.</p></li>
</ul>

<p>Here is a corrected version:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void) {
    // var
    int n, c;
    const char *p = ""e primo"";
    // code
    printf(""Informe um numero para checar se e primo: "");
    if (scanf(""%d"", &amp;n) == 1) {
        for (c = 2; c * c &lt;= n; c = c + 1) {
            if (n % c == 0) {
                p = ""nao e primo"";
                break;
            }
        }
        printf(""O numero %s\n"", p);
        return 0;
    }
</code></pre>
",5
44717341,44717310,1,"<p><code>location == city1</code> is comparing <em>pointer addresses</em>, which will not be equal.</p>

<p>You need to use <code>!strcmp(location, city1)</code> &amp;c. instead. <code>strcmp</code> returns 0 if the string <em>contents</em> are the same.</p>
",0
42464777,42464685,0,"<p>To print every word in the new line you just have to modify your print statement to check for <code>,</code> character in the linked list.</p>

<pre><code>void print() {

struct Word *temp;
temp = ptr;
char c;

while(temp != NULL) {

    if (temp-&gt;data == ',') {
        printf(""\n"");
        temp = temp-&gt;next;
    } else {
        printf(""%c"", temp-&gt;data);
        temp = temp-&gt;next;
    }

}

   printf(""\n"");

}
</code></pre>

<p>This will check if there is a <code>,</code> in the linked list and print a <code>\n</code> to print newline character and move to the next node.</p>

<p>Also you should free your linked list after the program is complete to avoid memory leaks. </p>

<pre><code>void freeData(struct Word* head)
{
   struct Word* tmp;

   while (head != NULL)
    {
       tmp = head;
       head = head-&gt;next;
       free(tmp);
    }

}
</code></pre>

<p><a href=""http://ideone.com/J4dN6O"" rel=""nofollow noreferrer"">Code link</a></p>

<p>Just try it out.</p>
",3
42464282,42464252,0,"<p>Check your 'multiples_of_one_eighth' array in a debugger. You will find that they are all zero, because you are asking the compiler to perform divisions like (1/8) in integer space. If I understand your desirement correctly, you probably want that to be an array of char* (c-strings), surrounded with double-quotes for each entry. Then, change your return type to char* as well. </p>
",0
42464512,42464252,1,"<p>I'm guessing this is a function that takes a number and rounds it to the nearest eighth. Like 0.26 would return <code>""1/4""</code>.</p>

<p>The main problem is you can't store the string representation of a fraction (ie. the string <code>""1/4""</code>, not the number 1/4) in a single <code>char</code>. <code>char</code> stores a single 1 byte character. <code>1/8</code> is a mathematical formula to return a number. <code>""1/8""</code> is a 4 character string, that gets stored in a <code>char *</code>, a pointer to some memory that contains characters. You want that last one. So you're returning a <code>char *</code>.</p>

<p>You could return a Unicode fraction like ? but that rapidly gets complicated.</p>

<hr>

<p>Then there's all that <code>interest - trunc(interest)</code> that does nothing.</p>

<p>First, <code>trunc</code> takes a <code>double</code>, but <code>interest</code> is a <code>long double</code>. It returns a <code>double</code> but then subtracts it from a <code>long double</code> losing precision. Compiler warnings will tell you about things like that, turn them on with <code>-Wall</code>. You'd need to use <code>truncl</code>. It's not a big deal, it won't overtly break the code, but it will lose some of the precision of <code>long double</code>.</p>

<p>But you don't need to use <code>truncl</code> at all. <code>truncl(0.1)</code> is <code>0.0</code>. <code>truncl(0.9)</code> is <code>0.0</code>. All <code>interest - trunc(interest)</code> is doing, in your range, is <code>interest - 0</code>. So get rid of it.</p>

<hr>

<p>There's also no need for the <code>Return</code> variable, for such a simple function you can just return immediately. You may have been told something like ""there should only ever be one return from a function"" which is outdated advice from a thing called <a href=""https://en.wikipedia.org/wiki/Structured_programming"" rel=""nofollow noreferrer"">Structured Programming</a>. It's supposed to make things simpler, but if followed too strictly it leads to complexity.</p>

<p>You still shouldn't return willy-nilly. For such a small function it really doesn't matter. Here we can use multiple returns for a thing called <a href=""https://en.wikipedia.org/wiki/Structured_programming#Early_exit"" rel=""nofollow noreferrer"">early exit</a> where rather than storing a value to be returned at the end of a loop or if/else chain, we can return immediately. Makes the code simpler.</p>

<hr>

<p>There's also no need for the <code>multiples_of_one_eighth</code> array. That would be useful if we could reference the fractions by array index, like:</p>

<pre><code>int index = ...some calculation involving interest...
return multiples_of_one_eight[index];
</code></pre>

<p>But since we have to hard code each index into the if/else anyway, might as well remove some complexity and hard code the number. Then it's very easy to see mistakes. Like:</p>

<pre><code>  else if (interest - trunc(interest) &lt; 0.1875)
  {
    Return = multiples_of_one_eighth[1];
  }
</code></pre>

<p>You're returning <code>multiples_of_one_eighth[1]</code> but that's <code>1/4</code>. I'm pretty sure you meant <code>1/8</code>.</p>

<p>Put it all together and we get something like this.</p>

<pre><code>#include &lt;stdio.h&gt;

const char *fractionCalculator(long double interest)
{
    if (interest &lt; 0.0625) {
        return ""0"";
    }
    else if (interest &lt; 0.1875) {
        return ""1/8"";
    }
    else if (interest &lt; 0.3125) {
        return ""1/4"";
    }
    else if (interest &lt; 0.4375) {
        return ""3/8"";
    }
    else if (interest &lt; 0.5625) {
        return ""1/2"";
    }
    else if (interest &lt; 0.6875) {
        return ""5/8"";
    }
    else if (interest &lt; 0.8125) {
        return ""3/4"";
    }
    else {
        return ""1"";
    }
}

int main() {
    printf(""%s\n"", fractionCalculator(0.8));
}
</code></pre>

<p>Note that this returns constant strings that cannot be modified, so they are declared <code>const char *</code>.</p>

<p>Also note that the math is a bit wrong, I basically copied what you had, so I'll leave that to you to fix.</p>
",0
42480420,42480393,3,"<p>Erroneous code: </p>

<pre><code>// k = 12, j = 10
k = j; // k =&gt; 10
j = k; // j =&gt; 10
</code></pre>

<p>Use the operation below if you want to swap the values of k and j:</p>

<pre><code>// k = 12, j = 10
k = k + j; // k =&gt; 22
j = k - j; // j =&gt; 22 - 10 =&gt; 12
k = k - j; // k =&gt; 22 - 12 =&gt; 10
</code></pre>
",1
42480452,42480393,1,"<pre><code>int j=10,k=12;
if(k&gt;=j) // k is superior or equal to j, so true
{
    {
        k=j;  // now k=10
        j=k;  // now j=10
        printf(""%d\n%d"",j,k); //so you'll print 10 and 10
    }
}
</code></pre>

<p>You first assign the value of <code>j</code>, ie 10, to <code>k</code>, so after that <code>k=10</code>.
Then you assign the value of <code>k</code>, which is now <code>10</code>, to <code>j</code>, so j remains unchanged, and in the end, both have the value <code>10</code>.</p>
",0
42468935,42468880,4,"<p>Single quotes <code>'</code> denote 'character constants'. In the following line</p>

<pre><code>char number_all [13]={'A','2','3','4','5','6','7','8','9','10','J','Q','K'};
</code></pre>

<p>the <code>'10'</code> is a 'multi-character constant'. This is 'implementation defined' - that is, different compilers are free to interpret it in different ways. In this case given the error message you have provided, it is likely the source of your error. I would suggest using an <a href=""http://www.cs.utah.edu/~germain/PPS/Topics/C_Language/enumerated_types.html"" rel=""nofollow noreferrer"">enumerated type</a> to represent your cards.</p>
",2
42469121,42468880,1,"<p>I hope you are getting these two error</p>

<p>h.c:9:59: warning: multi-character character constant</p>

<p>h.c:9: warning: overflow in implicit constant conversion</p>

<p>It happens because in the program, </p>

<blockquote>
  <p>char number_all
  [13]={'A','2','3','4','5','6','7','8','9','10','J','Q','K'};</p>
</blockquote>

<p>you have <strong>'10'</strong> which is a multi character constant, the compiler is unable to convert it into a single character. </p>

<p>From Wikipedia:</p>

<blockquote>
  <p>Individual character constants are single-quoted, e.g. 'A', and have
  type int (in C++, char). The difference is that ""A"" represents a
  null-terminated array of two characters, 'A' and '\0', whereas 'A'
  directly represents the character value (65 if ASCII is used). The
  same backslash-escapes are supported as for strings, except that (of
  course) "" can validly be used as a character without being escaped,
  whereas ' must now be escaped.</p>
  
  <blockquote>
    <p>A character constant cannot be empty (i.e. '' is invalid syntax),
    although a string may be (it still has the null terminating
    character). Multi-character constants (e.g. 'xy') are valid, although
    rarely useful ¡ª they let one store several characters in an integer
    (e.g. 4 ASCII characters can fit in a 32-bit integer, 8 in a 64-bit
    one). Since the order in which the characters are packed into an int
    is not specified, portable use of multi-character constants is
    difficult.</p>
  </blockquote>
</blockquote>
",0
40753539,40753354,1,"<p>Or copy the file to where .exe resides.</p>
",0
40558349,40558179,1,"<p>If I say</p>

<pre><code>char str[] = ""Hello, world!"";
int i = 7;
printf(""%d %d\n"", str[i], str[i+1]);
if(str[i] &gt; str[i+1]) { printf(""it is greater\n""); }
</code></pre>

<p>it will print</p>

<pre><code>119 111
it is greater
</code></pre>

<p>But there is nothing ""magic"" going on here, and there are no special conversions, either.  In C, a character is simply represented by a small integer giving the value of the character in the machine's character set, which for all intents and purposes we can assume will be ASCII (or maybe its superset, Unicode).  And as any ASCII chart will tell you, 'o' is 111 and 'w' is 119.</p>
",1
40575448,40575108,0,"<p>There are 2 major problems in your code:</p>

<ul>
<li><p>The condition <code>while (user_input[0] == !'q')</code> should be written <code>while (user_input[0] != 'q')</code></p></li>
<li><p>The obsolete function <code>gets()</code> should never be used.  Use <code>fgets()</code> instead.</p></li>
<li><p>You do not read a new line in the <code>while</code> loop... the condition is constant, you have either an infinite loop (if you type enter directly) or one you never enter.</p></li>
</ul>

<p>Here is a better version:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void) {
    // Declaration Part
    char input[100];

    //Main Body
    while (fgets(input, sizeof input, stdin) != NULL &amp;&amp; input[0] != 'q') {
        switch (input[0]) {
          case '0':
          case '1':
            printf(""You chose boolean algebra! \n"");
            break;
          case 'c':
            printf(""%s\n"", ""You chose to continue!"");
            continue;
        }
    }
    printf(""You chose to quit!\n"");
    return 0;
}
</code></pre>
",0
40575467,40575108,0,"<p>The operator <code>!</code> is Boolean, if the operand is non-zero, the result is <code>false</code> which implicitly casts to zero in your condition expression:</p>

<pre><code>user_input[0] == !'q'
</code></pre>

<p>You are simply comparing <code>user_input[0]</code> to zero so the switch is never entered.  That is to say it is not switch that is not doing what you want - it is the incorrect Boolean expression in the <code>if(...)</code> that precedes it.</p>

<p>What you need is the <em>binary operator</em> <code>!=</code></p>

<pre><code>user_input[0] != 'q'
</code></pre>
",1
40575546,40575108,0,"<blockquote>
  <p>Why does it ""ignore"" the switch?</p>
</blockquote>

<p>It is not <em>executing</em> the switch because it is inside a conditional block for which the condition is <em>never</em> true.  You are addressing the wrong part of the code; why it does not execute the switch should be obvious, the question you should then ask is rather ""<em>Why is the <code>while</code> condition never true?</em>"".</p>

<p>The operator <code>!</code> is boolean, if the operand is non-zero, the result is <code>false</code> which implicitly casts to zero when compared to an integer.  In your condition expression:</p>

<pre><code>user_input[0] == !'q'
</code></pre>

<p>you are simply comparing <code>user_input[0]</code> to zero so the loop body and therefore the switch is never entered.  So it is not switch that is not doing what you want - it is the incorrect boolean expression in the <code>while(...)</code> that precedes it.</p>

<p>What you need is the <em>binary operator</em> <code>!=</code></p>

<pre><code>user_input[0] != 'q'
</code></pre>
",0
42589747,42588613,1,"<p>There seems to be a couple issues.</p>

<pre><code>if(a = 'y')
.
.
.
if(a = 'n')
</code></pre>

<p>These are valid statements, but not what you are actually wanting to do.
When your if statement has an asignment operator in it, you're only checking to see if the assignment is a success. So in your case if you assign 'y' to a. </p>

<p>You want to check to see if a already contains 'y'
it should be</p>

<pre><code>if(a == 'y')
.
.
.
if(a == 'n')
</code></pre>

<p>Next, you're always getting 0 because you forgot to print out deposit. </p>

<pre><code>printf(""deposit = %.4f\n"");
</code></pre>

<p>should be</p>

<pre><code>printf(""deposit = %.4f\n"", deposit);
</code></pre>
",0
42589750,42588613,0,"<p>The main error here is with your if-statement condition:</p>

<blockquote>
  <p>a = 'y'</p>
</blockquote>

<p>Use one equal sign only when declaring and assigning values. You need two equal signs when comparing values.</p>

<p>It should be:</p>

<blockquote>
  <p>a == 'y'</p>
</blockquote>

<p>Same for the else-if condition.</p>
",0
42589242,42589211,6,"<p>you're reusing <code>i</code> in both your loops:</p>

<pre><code>while (i &lt; 6)
{
    printf(""What score would you like for %s?\nPlease use each score only once.\n"", abS[i]);
    for (i = 0; i &lt; 6; i++)
</code></pre>

<p>the inner <code>for</code> loop changes the value of <code>i</code> for the outer <code>while</code> loop as well and it exits at first iteration. Consider using 2 separate variables</p>
",0
42589249,42589211,2,"<p>You re-use <code>i</code> inside the <code>for</code> loop in the while loop. After the for loop is done, <code>i</code> will be set to 6, therefore breaking your loop condition.</p>
",0
42589267,42589211,1,"<p>Create a new variable in the inner loop, this is good practice, for example (changed <code>i</code> to <code>j</code>):</p>

<pre><code>while (i &lt; 6)
{
    printf(""What score would you like for %s?\nPlease use each score only once.\n"", abS[i]);
    for (int j = 0; j &lt; 6; j++)
    {
        printf(""%2d\n"", abScore[j]);
    }
    //scanf(""%d"", &amp;abScoreTwo[i]);
    i++;
}
</code></pre>

<p>Another good practice would be to give more meaningful names to your variables instead of <code>i</code> and <code>j</code></p>
",0
41915879,41915598,1,"<p>You look confused. Read first the wikipage on <a href=""https://en.wikipedia.org/wiki/Linker_%28computing%29"" rel=""nofollow noreferrer"">linkers</a> and on <a href=""https://en.wikipedia.org/wiki/Compiler"" rel=""nofollow noreferrer"">compilers</a>. You don't link <a href=""https://en.wikipedia.org/wiki/Source_code"" rel=""nofollow noreferrer"">source</a> files, but only <a href=""https://en.wikipedia.org/wiki/Object_file"" rel=""nofollow noreferrer"">object files</a> and <a href=""https://en.wikipedia.org/wiki/Library_%28computing%29"" rel=""nofollow noreferrer"">libraries</a>.</p>

<p><sup>(I am guessing and supposing and hoping for you that you are using Linux)</sup></p>

<p>You also compile <a href=""https://en.wikipedia.org/wiki/Translation_unit_%28programming%29"" rel=""nofollow noreferrer"">translation units</a> into object files.</p>

<p><a href=""https://en.wikipedia.org/wiki/Include_directive"" rel=""nofollow noreferrer"">Header files</a> are for the <a href=""https://en.wikipedia.org/wiki/C_preprocessor"" rel=""nofollow noreferrer"">preprocessor</a> (the first ""phase"" of the compilation). The <a href=""https://gcc.gnu.org/onlinedocs/cpp/"" rel=""nofollow noreferrer"">preprocessing</a> is a textual operation. See <a href=""https://stackoverflow.com/a/8110940/841108"">this answer</a> for some hint.</p>

<p>So you probably want to compile your <code>main.c</code> into <code>main.o</code> with</p>

<pre><code>gcc -Wall -g -c main.c -o main.o
</code></pre>

<p>(the <code>-Wall</code> asks for all warnings, so never forget that; the <code>-g</code> asks for debugging information; <code>-c</code> asks to compile some source into some object file; order of <a href=""https://gcc.gnu.org/onlinedocs/gcc/Option-Summary.html#Option-Summary"" rel=""nofollow noreferrer"">program arguments</a> to <code>gcc</code> matters a big lot).</p>

<p>Likewise, you want to compile your <code>sortfile.c</code> into <code>sortfile.o</code>. I leave as an exercise to get the right command doing that.</p>

<p>Finally, you want to get an executable program <code>myprogsort</code>, by linking both object files. Do that with </p>

<pre><code>gcc -g main.o sortfile.o -o myprogsort
</code></pre>

<p>But you really want to use some <a href=""https://en.wikipedia.org/wiki/Build_automation"" rel=""nofollow noreferrer"">build automation</a> tool. Learn about <a href=""https://www.gnu.org/software/make/"" rel=""nofollow noreferrer"">GNU make</a>. Write your <a href=""https://en.wikipedia.org/wiki/Makefile"" rel=""nofollow noreferrer""><code>Makefile</code></a> (beware, <kbd>tab</kbd>s are important in it). See <a href=""https://stackoverflow.com/a/16751650/841108"">this</a> example. Don't forget to try <code>make -p</code>  to understand (and take advantage of) all the builtin rules <code>make</code> is knowing.</p>

<blockquote>
  <p>Also would like to know what information usually goes in a header file.</p>
</blockquote>

<p><em>Conventionally</em> you want only <em>declarations</em> in your common header file (which you would <code>#include</code> in every source file composing a translation unit). You can also add <em>definitions</em> of <code>static inline</code> functions. Read more about <a href=""https://en.wikipedia.org/wiki/Inline_function"" rel=""nofollow noreferrer"">inline functions</a> (you probably don't need them at first).</p>

<p>Don't forget to learn how to use the <a href=""https://www.sourceware.org/gdb/"" rel=""nofollow noreferrer""><code>gdb</code> debugger</a>. You probably will run</p>

<pre><code>gdb ./myprogsort
</code></pre>

<p>more than once. Don't forget to rebuild your thing after changes to source code.</p>

<p>Look also inside the source code of some medium sized <a href=""https://en.wikipedia.org/wiki/Free_software"" rel=""nofollow noreferrer"">free software</a> project coded in C on <a href=""http://github.com/"" rel=""nofollow noreferrer"">github</a>. You'll learn a big lot.</p>
",2
40972207,40972051,0,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(){
printf(""Hello, World!\n"");
unsigned  char tlv_buffer[] = ""DF0402df4500DF0C03125050"";
int length = strlen(tlv_buffer );
printf(""Length is %d \n"", length );
return 0;
}
</code></pre>

<p>// just tested. it work</p>
",5
40972322,40972051,4,"<p>You should initialized like:</p>

<p><code>unsigned char *tlv_buffer = ""DF04024500DF0C03125050""</code>;</p>

<p>and then calculate the length using <a href=""https://www.tutorialspoint.com/c_standard_library/c_function_strlen.htm"" rel=""nofollow noreferrer"">strlen</a></p>

<p><code>int tlv_buffer_length = strlen((char*) tlv_buffer)</code>;</p>

<p>or as @M.M point it up in the comments :</p>

<p><code>char tlv_buffer [] = ""DF04024500DF0C03125050""</code>; </p>

<p><code>int tlv_buffer_length = strlen(tlv_buffer)</code>;</p>
",0
40754411,40754380,0,"<p>There are possibly many errors in this code.  Here is a flagrant error:</p>

<pre><code>toRtn[0] =    ((S_ISDIR(fileStat.st_mode)) ? 'd' : '-');
// WAIT what about the NUL terminator?
strcat(toRtn, (fileStat.st_mode &amp; S_IRUSR) ? ""r"" : ""-"");
</code></pre>

<p>Another error is here:</p>

<pre><code>contents[cnt] = toRtn;
</code></pre>

<p>So <em>every</em> entry in <code>contents</code> will point to <code>toRtn</code> (i.e. <code>contents[0] == contents[1]</code> which I'm sure is not what you want) and these will all be dangling pointers (which is also not what you want).</p>

<p>Start by fixing these errors, maybe there are more.</p>
",2
40755474,40754380,0,"<p>The reason is that, for various values of <code>cnt</code>.</p>

<pre><code>contents[cnt] = toRtn;  
</code></pre>

<p>is being used to (indirectly) return <code>toRtn</code> to the caller, where <code>toRtn</code> is a local array in the function, so ceases to exist when the function returns.</p>

<p>Which means, for the caller that the loop</p>

<pre><code>for (int i = 0; i &lt; cnt; i++)
{
    printf(""%s "", contents[i]);
}
</code></pre>

<p>repeatedly tries to print the contents of an array of <code>char</code> that no longer exists.   That gives undefined behaviour.</p>

<p>There are other fundamental concerns in your code too.  You need to better understand the relationship between pointers and arrays (they can be used interchangeably in some circumstances, but some of your code is using them interchangeably when they are not interchangeably) and the meaning of scope (returning the address of a local variable to the caller, by any means, is a bad idea since the variable will cease to exist when its containing function/scope ends).</p>
",0
47971310,47970812,3,"<p>That is how the C grammar is defined. Variable declarations are not considered statements:</p>

<pre><code>int x; //a declaration
int y = 3; //another declaration
x = y + 1; //a statement
</code></pre>

<p>A label is required to be followed by a statement. A label plus a declaration is not allowed.</p>

<pre><code>foo: int x; //error
bar: x = y +1; //ok
</code></pre>

<p>That is, IMO, inconvenient:</p>

<pre><code>while (...)
{
    //...
    goto end;
    end:   //error, no statement   
}
</code></pre>

<p>And remember that a <code>case</code> is just a special kind of label, so:</p>

<pre><code>case 1: int x; //error
case 2: x = y +1; //ok
</code></pre>

<p>The issue with braces is that in C they are used to build a <em>compound statement</em>, that of course is a kind of statement. The lines inside the compound statements can be both declarations and statements, all mixed (old C versions only allowed declarations at the beginning, not in the middle). So:</p>

<pre><code>case 1: int x; //error: label plus declaration
case 2: { int x; } //ok: label plus compound statement
</code></pre>

<p>As a footnote, since modern C allows to intermix declarations and statements you can also write:</p>

<pre><code>case 1:; int x; //ok: label plus empty statement.
</code></pre>

<p>because an isolated <code>;</code> is an empty statement, it can be used to satisfy the grammar whereever a no-op statement is needed.</p>

<p>Whether to use a <code>;</code> or a <code>{ ... }</code> is a matter of readability. In the <code>end:</code> example I'd use a <code>;</code>, but in the <code>case:</code> I prefer the  <code>{...}</code>.</p>

<pre><code>while (...)
{
    //...
    goto end;
    end:;   //ok, empty statement   
}

switch (...)
{
    case 1: //ok, compound statement
    {
        int x;
    }
}
</code></pre>

<p>Of course more creative solutions can be written, such as:</p>

<pre><code>case 1: {} int x; //ok, label plus empty compound statement
</code></pre>
",3
47971668,47970812,2,"<h1>C Rules About Case Labels</h1>

<p>The rules of the C standard that prevent a declaration from following a case label are:</p>

<ul>
<li><p>A case label must be followed by a <em>statement</em> (C 2011 [N1570] 6.8.1).</p></li>
<li><p>The C standard defines a <em>statement</em> as one of <em>labeled-statement</em>, <em>compound-statement</em>, <em>expression-statement</em>, <em>selection-statement</em>, <em>iteration-statement</em>, or <em>jump-statement</em> (6.8).  None of these is a <em>declaration</em>.</p></li>
</ul>

<p>The C standard treats declarations and statements separately. The rule that allows declarations to be largely mingled with statements is that a <em>compound-statement</em> is a list of <em>block-item</em>s in braces (that is, <strong>{</strong> <em>block-item-list<sub>opt</sub></em> <strong>}</strong>) (6.8.2), and a <em>block-item</em> is defined as a <em>declaration</em> or a <em>statement</em>. So, inside braces, you can mix declarations and statements. But a case label must be part of a statement; it is not a separate thing you can insert anywhere.</p>

<p>Declarations can be included inside a switch using two alternatives. One is to use an empty statement after the case label, as in:</p>

<pre><code>case 123:
    ;
    int foo;
    ¡­
</code></pre>

<p>Another is to use a compound statement after the case label, as in:</p>

<pre><code>case 123:
{
    int foo;
    ¡­
}
</code></pre>

<p>Generally, the latter is preferable, because the scope of <code>foo</code> is limited to the compound statement, so it cannot be used accidentally in another section of the switch statement.</p>

<h1>Reasons For the Rules</h1>

<p>I do not see a reason for this other than history. Originally, declarations were even more restricted than they are now. Inside functions, declarations had to be the first statements inside braces. You could not put a declaration after any statement. That has been relaxed in modern C, but why is there still a restriction on what follows a case label?</p>

<p>There cannot be a semantic reason that a declaration cannot follow a case label in modern C, because the empty-statement example above would have the same semantics as:</p>

<pre><code>case 123:
    int foo;
</code></pre>

<p>That is, the compiler would have to be prepared to create and initialize a new object at the same point in execution. Since it has to do that for the legal example code, it would be able to do it for this version too.</p>

<p>I also do not see a syntactic or grammatical barrier. The colon after the constant expression of a case label is pretty distinct. (The constant expression can have colons in it from <code>? :</code> operators, but the first <code>:</code> not associated with a <code>?</code> will be the end of the case label.) Once parsing reaches that colon, the current parsing state seems clean. I do not see why it could not recognize either a declaration or a statement there, just as it was prepared to do before the <code>case</code>.</p>

<p>(If somebody can find a problem in the grammar that would be caused by allowing a case label to be followed by a declaration, that would be interesting.)</p>
",0
48037354,47970812,0,"<p>First to say, the error you post is a syntax error related to the format of a <code>case</code> label statement.  It allows you to use only an executable statement, and not a declaration.  Put an empty statement before the declaration and you'll be ok.  Try the following:</p>

<pre><code>#include &lt;stdio.h&gt;
int main()
{
    switch(3) {
        int x = 3;  /* the initializer is ignored by the compiler
                     * you can include declarations here, but as
                     * this code is never executed, the initializer
                     * never takes place. */
    case 3:; /* &lt;=== look this semicolon to allow the next declaration */
        int y = 5;
        printf(""x = %d, y = %d\n"", x, y);
        break;
    }
}
</code></pre>

<p>The first variable, <code>x</code>, will be declared properly, but the initializer will not be executed, as the case statement selected is the one corresponding to case label <code>3</code>.  The <code>printf</code> will print</p>

<pre><code>x = 0, y = 5
</code></pre>

<p>(note: this happens on my machine, as the variable <code>x</code> is not initialized, Undefined Behaviour <strong>is</strong> expected)</p>

<p>In C, some evolution has been realized over the years, concerning the use of declarations in a block.</p>

<p>In ancient C, variables can be declared only at the beginning of a block (the piece of code between <code>{</code> and <code>}</code>, but this approach has been thrown for the new possibility of declaring a variable whenever you need it (even after some executable sentences after a block begin)  But a <code>case</code> statement permits only to put an executable statement, and not a declaration, so that's the reason of your compiler error.</p>

<p>If you follow the ancient C way, you can only declare new local variables only after the opening <code>{</code> curly brace after the switch, as in:</p>

<pre><code>switch(something) {
    int var1;
case BLA_BLA:
    /* use var1 here */
</code></pre>

<p>which, although counterintuitive, is valid since the old K&amp;R code.  The problem with this approach is that the variable is valid from the point of definition until the end of the switch statement, and so, it is global to all the case parts.</p>

<p>Another way, is the form you propose, in which you declare a new block by opening curly braces.  This works also since the old K&amp;R code, and makes it easier to control the scope of the variables defined.  Personally, I prefer this second approach.  A block is an executable statement, so there's no problem in using it as the labeled case statement of the switch (the declarations happen inside it).</p>

<p>Case labels don't delimit blocks of code, they label executable statements, so their syntax is specific to the <code>case</code> statement syntax (which finishes after the semicolon of the statement it is attached to, or the closing curly br)</p>
",0
46050337,46045682,1,"<p>It's not as difficult to implement as it looks. Use constants or an <code>enum</code> to represent the specific operators, rather than working with the characters themselves. So, for example, <code>OP_PLUS=0, OP_MINUS=1...</code></p>

<p>Then use a lookup table of some sort, or just a plain function containing a <code>switch()</code>, that gets the precedence of each operator, as a number from (say) zero to five. So, in a sense, implement this function:</p>

<pre><code>int get_precedence (Operator my_operator) {...}
</code></pre>

<p>where ""Operator"" is the <code>enum</code> that lists the different operator values. Then comparing whether one operator has a higher precedence than another simply amounts to calling get_priority() on each one, and seeing which is higher. </p>

<p>A quick and dirty way to achieve a similar objective is to assign numbers to each operator, such that the numbers are assigned <em>in order of precedence</em>. So to compare precedence all you have to do is compare the numbers the represent the operators. But I suspect this will lead to code that is hard to understand and maintain.</p>

<p>The key to any of these approaches is to assign a number (enum, constant, whatever) to represent each operator, and pass those numbers around, rather than character values.</p>
",0
40959469,40959353,3,"<p>There are various errors in your code.</p>

<ol>
<li><p>Allocating an incorrectly sized memory block :</p>

<p><code>data.children = calloc(data.nChildren, sizeof data.nChildren);</code></p>

<p><code>data.children</code> is an array of <code>Child</code> structures, yet you're allocating structures whose size is equal to <code>sizeof(unsigned int)</code>, due to <code>data.nChildren</code> being an <code>unsigned int</code>.</p></li>
<li><p>Taking the address of a temporary variable and storing it for later usage :</p>

<p><code>NaryNode* createNode(Data data){
  newNaryNode-&gt;data = &amp;data;
}</code></p>

<p><code>data</code> in <code>createNode</code> only exists for as long as the function is running : in this case, you're taking the address of the local variable <code>data</code> and storing it in the structure that you're returning for later usage. This is a very bad idea, since this pointer will refer to an object that doesn't exist anymore after the function returns.</p>

<p>Keep in mind that you don't need to pass a copy of the <code>Data</code> object into <code>createNode</code> in your current code, since there is really only one <code>Data</code> object in the whole program. Thus, you can change the prototype of <code>createNode</code> to <code>createNode(Data* data)</code>, and pass the address of the <code>Data</code> structure that you create in <code>main</code>. Doing anything more involved than that, though, would require deep-copying the structure, I think.</p></li>
<li><p>Incorrectly managing the objects' lifetime.</p>

<p><code>NaryNode *root = calloc(1, sizeof(NaryNode));
*root = *createNode(data);</code></p>

<p><code>createNode</code> returns an <code>NaryNode*</code>. However, you never actually assign it to an <code>NaryNode*</code> so that you can free it later. Instead, the pointer to the object that the function returns is known only during the <code>*root = *createNode(data)</code> invocation, and irrevocably lost later on. You do, however, retain the contents of the object due to dereferencing it and copying it into <code>root</code> : the object itself, however, as returned from <code>createNode</code>, is lost and not recoverable, unless pointers to it still exist in the tree.</p></li>
</ol>
",2
40959521,40959353,2,"<p>Here is another problem. This line does not allocate space for a NaryNode, but only for a <em>pointer</em> to a NaryNode:</p>

<pre><code>NaryNode *newNaryNode = malloc(sizeof (NaryNode*));
</code></pre>
",1
47480852,47480829,0,"<p>as shown in some of your snippets <code>Vector3</code> is used like:</p>

<pre><code>static Inline struct Vector3 GET_ENTITY_COORDS
</code></pre>

<p>So, since this works, it means that it's defined (in some code we don't see) as <code>struct</code>, but not as <code>typedef struct</code> (which would allow to use it without <code>struct</code> keyword).</p>

<p>your error is when declaring your variable as <code>Vector3</code>:</p>

<pre><code>Vector3 playerCoords = GET_ENTITY_COORDS(pedID, 1);
</code></pre>

<p>should be</p>

<pre><code>struct Vector3 playerCoords = GET_ENTITY_COORDS(pedID, 1);
</code></pre>

<p>the rest of the errors are just a consequence of that one. The parser is lost at this point.</p>
",0
46672809,46672732,0,"<p>You are storing it in a character. So char will store only '5' and not '15'. Use data type string or char*.</p>
",0
46672876,46672732,0,"<p>Problem with your code is, it read all characters(in your file one by one)</p>

<p>Your code need needs to detect end of the line </p>

<pre><code>ch!= '\n'
</code></pre>

<p>Try this:</p>

<pre><code> char buffer[10]; /* as big as the biggest number */
    char ch;
    int i = 0;
    double d, dMax = 1000, dMin = -1000;

    while ((ch= getc(fp)) != EOF) {
        if (ch!= '\n')
            buffer[i++] = ch;
        else {
            buffer[i] = '\0';
            d = atof(buffer);
            if (d &gt; dMax) dMax = d;
            if (d &lt; dMin) dMin = d;
            i = 0;
       }
    }
</code></pre>
",4
40968408,40966280,0,"<p>Not sure I understand correctly, I understood you want to loop an undertemined amount of students.</p>

<p>I will assume you want to stop if certain keyword is added as a student name, let's say ""quit"". </p>

<p>Without changing your structure much, it would look like this.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt; 
#include &lt;string.h&gt;

int main (){
    char StudentName[100];
    float ExamValue, Sum, Avg;
    int students,exams;
    bool in = true;

    while (in) {
        Sum =0.0;

        printf(""Enter Student Name \n"");
        scanf(""%s"", StudentName);
        if( strcmp(StudentName, ""Quit"") == 0 || strcmp(StudentName, ""quit"") == 0){
            in = false;
            break;
        }


        for (exams=0; exams &lt; 3; exams++){
            printf (""Enter exam grade: \n"");
            scanf(""%f"", &amp;ExamValue);
            Sum += ExamValue;
        }

        Avg = Sum/3.0;
        printf( ""Average for %s is %f\n"",StudentName,Avg);
    }
    return 0;
}
</code></pre>
",2
43930806,43930366,2,"<p>Unless you're on an architecture completely outside of the mainstream that violates pretty much every standard, your structs will be packed and aligned so that their elements always get correct alignment if the struct is correctly aligned and <code>malloc</code> will always return memory aligned such that it will match the strictest possible alignment of any data type on your architecture.</p>
",0
43930838,43930366,3,"<p>When you dynamically allocate memory via <code>malloc</code>, it is guaranteed that the returned memory address will satisfy the target platform's minimum alignment requirements for all built-in types. This works for structs, too: alignment requirements are interpreted recursively, such that the struct's alignment is the largest alignment required for any of its members.</p>
<p>In effect, the language standard guarantees that your code will work correctly on the target platform. Which is a pretty reasonable guarantee, and means that you don't have to worry about any of this in the general case.</p>
<p>Quoting the (<a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf"" rel=""nofollow noreferrer"">draft</a>) C99 language standard, ¡ì7.20.3 (&quot;Memory management functions&quot;):</p>
<blockquote>
<p>The order and contiguity of storage allocated by successive calls to the <code>calloc</code>, <code>malloc</code>, and <code>realloc</code> functions is unspecified. <strong>The pointer returned if the allocation succeeds is suitably aligned so that it may be assigned to a pointer to any type of object and then used to access such an object or an array of such objects in the space allocated (until the space is explicitly deallocated).</strong> The lifetime of an allocated object extends from the allocation until the deallocation. Each such allocation shall yield a pointer to an object disjoint from any other object. The pointer returned points to the start (lowest byte address) of the allocated space. If the space cannot be allocated, a null pointer is returned. If the size of the space requested is zero, the behavior is implementation- defined: either a null pointer is returned, or the behavior is as if the size were some nonzero value, except that the returned pointer shall not be used to access an object.</p>
</blockquote>
<p><sup>(emphasis mine)</sup></p>
<p>The only time you have to worry about alignment is if you want a <em>stricter</em> alignment than is required. For example, your platform might work just fine with 32-bit alignment, but perform <em>better</em> with 64-bit alignment. In this case, the language standards don't guarantee that 64-bit alignment will be used for dynamically-allocated memory, since 32-bit alignment is sufficient. If you want 64-bit alignment, you will either need to set a compiler option that enforces such alignment, or you will need to call something like <code>aligned_malloc</code>.</p>
<p>Virtually all implementations will by default add padding to the fields of a struct to keep each of them aligned. The compiler generally doesn't &quot;pack&quot; your struct unless you use some kind of implementation-specific option to request that it does so. However, all of this is compiler-dependent, so you will need to check your compiler's documentation to be sure of what it will do.</p>
<p>The most common case where people start worrying about alignment beyond that which is minimally guaranteed is when they are writing SIMD code, in particular, on x86, where 128-bit alignment often yields a performance improvement. However, if you are letting the compiler generate the SIMD code, it very likely already knows to do the necessary alignment (assuming you have specified the correct options for your target platform), and you don't need to do anything special. If you are using intrinsics to force the generation of certain instructions, then you should also be using the provided types, like <code>__m128</code>, which are already annotated to ensure the appropriate alignment. You can probably add similar annotations to your own typedefs, if you'd like to have them aligned to a stricter rule; again, see your compiler documentation for details on how to achieve this.</p>
<p>For example, this is what <a href=""https://msdn.microsoft.com/en-us/library/ycsb6wwf.aspx"" rel=""nofollow noreferrer"">the documentation for Microsoft's C compiler</a> has to say:</p>
<blockquote>
<p><code>malloc</code> is guaranteed to return memory that's suitably aligned for storing any object that has a fundamental alignment and that could fit in the amount of memory that's allocated. A <em>fundamental alignment</em> is an alignment that's less than or equal to the largest alignment that's supported by the implementation without an alignment specification. (In Visual C++, this is the alignment that's required for a <code>double</code>, or 8 bytes. In code that targets 64-bit platforms, it¡¯s 16 bytes.) For example, a four-byte allocation would be aligned on a boundary that supports any four-byte or smaller object.</p>
<p>Visual C++ permits types that have <em>extended alignment</em>, which are also known as <em>over-aligned</em> types. For example, the SSE types <code>__m128</code> and <code>__m256</code>, and types that are declared by using <code>__declspec(align(n))</code> where <em>n</em> is greater than 8, have extended alignment. Memory alignment on a boundary that's suitable for an object that requires extended alignment is not guaranteed by <code>malloc</code>. To allocate memory for over-aligned types, use <code>_aligned_malloc</code> and related functions.</p>
</blockquote>
",1
41642088,41640700,0,"<p>One proposal, the idea is to:</p>

<ol>
<li>compute frequencies</li>
<li>sort the results with qsort and a comparator function</li>
<li><p>swap the 2 characters in the string</p>

<pre><code>static int frequencyComparator (void const *a, void const *b)
{
    const Histo* ha=a;
    const Histo* hb=b;
    return hb-&gt;freq-ha-&gt;freq;
}

struct Histo
{
    char c;
    int freq;
};

Histo histo[ENG_LETTERS]={0};
char str[STR_LEN] = { 0 };
char *pStr = str;
printf(""Please enter a string:\n"");
fgets(str, STR_LEN, stdin);

int index=0;
while(*pStr!=0)
{
    index=(*pStr)-'a';
    if(index&gt;=0 &amp;&amp; index&lt;26)
    {
        histo[index].c=(*pStr);
        histo[index].freq++; 
    }
    pStr++;
}

qsort (histo, ENG_LETTERS, sizeof(Histo), frequencyComparator);

if(histo[0].freq&gt;0 &amp;&amp; histo[1].freq&gt;0)
{
    printf(""%c %c\n"", histo[0].c, histo[1].c);
    pStr = str;
    while(*pStr!=0)
    {
        if(*pStr==histo[0].c) *pStr=histo[1].c
        else if(*pStr==histo[1].c) *pStr=histo[0].c
        pStr++;
    }
}

printf(""%s\n"", str);
</code></pre></li>
</ol>
",0
47970667,47970524,0,"<p><strong>THIS IS NOT AN ANSWER BUT TOO BIG FOR A COMMENT</strong></p>

<p>Here are your problems:</p>

<p>1.</p>

<pre><code> files = (FILES *)malloc(sizeof(FILES));
</code></pre>

<p>This is enough size of one <code>FILES</code>. This is will not be enough</p>

<ol start=""2"">
<li><p>After </p>

<pre><code>while((filesInDirectory = readdir(directory)) != NULL){
</code></pre></li>
</ol>

<p>Put something like</p>

<pre><code>size_t len = strlen(filesInDirectory-&gt;d_name);
if (len &lt; 5 || strcmp(filesInDirectory-&gt;d_name + len - 4, "".txt"") != 0) {
  continue;
}
</code></pre>

<p>This will check to ensure files end in .txt</p>

<ol start=""3"">
<li><p>Consider using <code>fstat</code> to ensure that the file is a text file</p></li>
<li><p>Remove the casts on malloc</p></li>
<li><p>Perhaps use <code>realloc</code> for <code>files</code></p></li>
<li><p><code>while ... feof</code> is bad - see link above</p></li>
<li><p><code>fscanf(file, ""%s"",</code> - Buffer overruns is possible. Do something about this. Read the manual page</p></li>
</ol>
",0
41930431,40878851,4,"<p>The error means you are writing to memory you don't own. Will likely happen if you try to copy a string longer than the one you specified for food ('pizza'). In this case it could be cos you are copying the string into memory location assigned to a string constant. </p>

<p>try this instead:- </p>

<pre><code>char *food = malloc(sizeof(char)*6); 
strcpy(food, ""pizza""); 
printf(""The best food is %s \n"", food); 

strcpy(food, ""bacon"");`
printf(""The best food is %s \n"", food);
</code></pre>
",0
46635677,46635480,1,"<p>Yes.  To do so, you would have to write some code to determine how many places after the decimal point you need to print.</p>

<p>I'll leave converting the pseudo-code below to actual code to you:</p>

<pre><code> value = 2.51
 places = 1
 while(testDigitsAfterDecimal(value, places) { places ++ }
 sprintf(format_string, ""%%.%df"", places)
 printf(format_string, value)
</code></pre>

<p>In summary, if you write code to mathematically test for places following the decimal and keep count of how many places you need, you can then use that number in a <code>sprintf</code> to create a format string that specifies the desired number of places.  With that done, you can pass that string to <code>printf</code> as the format to print your number.</p>
",0
44704514,44704429,2,"<p>To use the math library in C, pass the <code>lm</code> flag to the compiler:</p>

<p><code>gcc main.c -lm</code></p>

<p>Then your program will compile and link against the math library. </p>
",0
44704610,44704429,1,"<p>As pointed out, to use <code>-lm</code> flag while compiling, although it seems the logic is not correct.</p>

<p>In order to make your program work, you should insert this statement</p>

<pre><code>s=((a+b+c)/2);
</code></pre>

<p>after the <code>scanf</code> statement.</p>

<p>In your code, you are calculating the sum of <code>a</code>, <code>b</code> and <code>c</code> before even reading the values from terminal.</p>
",0
46652284,46652206,2,"<p>just replace || (or) with &amp;&amp; (and) because in your case two of the three conditions will always be true for each and every character that is why while loop goes to infinite.</p>
",1
44726934,44726814,0,"<p>let's think your value array is like: 1 2 5 6 9 so min=1,max=9,mid=5; now suppose your value is 7 then <code>if (value &gt; value[middle]){min = middle + 1;}</code> this block will be active. </p>

<p>Now look as we are sure that our value is greater than middle value so we can increase our minimum value to be (mid+1)th index of value array.</p>

<p>same applies when it is smaller.  so you are actually moving min/max index of value array. Hope that helps </p>
",0
44747262,44726814,1,"<p>Your function is broken in many respects:</p>

<ul>
<li>it does not implement binary search</li>
<li><code>MAX</code> is not <em>massive</em>, and it is not even used anywhere</li>
<li><code>middle</code> is undefined, and it is not modified in the loop.</li>
<li><code>value &gt; value[middle]</code> should probably be <code>value &gt; values[mid]</code>...</li>
</ul>

<p>Here is a simple correct implementation (borrowed from Matt Timmermans):</p>

<pre><code>bool search(int value, int values[], size_t n) {
    size_t pos = 0;
    size_t limit = n;

    while (pos &lt; limit) {
        size_t middle = pos + ((limit - pos) &gt;&gt; 1);

        if (values[middle] &lt; value)
            pos = middle + 1;
        else
            limit = middle;
    }
    return pos &lt; n &amp;&amp; values[pos] == value;
}
</code></pre>
",0
46655893,46655537,0,"<ol>
<li>You can remove this error by including ""shared.h"" into ""shared2.c"".</li>
<li>libshared2.so doesn't include definition of <code>foo2</code> function that you are using in your ""test"" program, that's why you need to add libshared.so at the compile time.</li>
</ol>

<p>Your ""test"" program is not actually using ""libshared2.so"", only <code>foo2</code> from ""libshared.so"". You don't need <code>-lshared2</code> here.</p>
",3
44742150,44741963,0,"<p>You need to make a couple of changes:</p>

<p>1)You can do it everything inside the main function unless you need to move it.</p>

<p>2)Remember you need to set the array size (in this case 100).</p>

<p>3)If you use a function you need to declare the prototype before the main function.</p>

<p>4)You can use the same for loop once to iterate and print the numbers.</p>

<pre><code>  #include &lt;stdio.h&gt;
  #include &lt;stdlib.h&gt;
  #include &lt;time.h&gt;

  int main()
 { 
     int list[100]; /*creating an arry call list*/
     srand(time(NULL));

   int i; 
  for (i=0; i&lt;100; i++){
  list[i] = 100+rand()%900  ;
    printf(""%d \n"", list[i]); 
}

}
</code></pre>
",1
44742619,44741963,0,"<p>If you want a function to be executed you must invoke that function.
Without making an explicit call a function cannot be executed.</p>

<p>You must also provide the array size in your code before compilation. </p>

<p>Alternatively you can also choose to use the variable length array feature in C which allows you to specify the array size at run time instead of forcibly specifying before compilation. </p>
",0
45041023,45039683,0,"<p>It works because an array variable in C (i.e. arr in your example) is just a pointer to the beginning of an array of memory locations.  A pointer is number which represents the address of a specific memory location.  When you put and '*' in front of a pointer, it means ""give me the data in that memory location"".  </p>

<ul>
<li>So, if arr is a pointer to the beginning of the array, *(arr) or *(arr + 0) is the <strong>data in the 0th index</strong> of the array, and *(arr + 1) is the <strong>data in the 1st index</strong>, and so on.</li>
<li>An expression which looks like <strong>A[B]</strong> essentially gets translated into something like <strong>*(A+B)</strong>.  So, <strong>arr[0] = *(arr + 0)</strong> and <strong>arr[i] = *(arr+i)</strong>, etc.  </li>
<li>And because <strong>A+B = B+A</strong>, the two are interchangeable.  Meaning <strong>*(arr+i) = *(i+arr)</strong>.  </li>
<li>And because <strong>arr[i] = *(arr+i)</strong> and <strong>*(arr+i) = *(i+arr)</strong>, it should make sense that <strong>arr[i] = i[arr]</strong>.  </li>
</ul>
",0
45040471,45039683,1,"<p>The notation <code>a[i]</code> is syntactic sugar for <code>*(a+i)</code>.</p>

<p>The first one is mathematical syntax (symbolics closer of what human brain is educated with) while the second one corresponds directly to one assembler instruction.</p>

<p>On the other hand <code>*(a+i)=*(i+a)=i[a]</code> because the <a href=""https://stackoverflow.com/questions/13668014/c-array-arithmetic-and-pointers"">arithmetic of pointers is commutative</a>.</p>
",0
45041227,45039683,0,"<p>These are the same because of how the array subscript operator <code>[]</code> is defined.</p>

<p>From sectino 6.5.2.1 of the <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""nofollow noreferrer"">C standard</a>:</p>

<blockquote>
  <p><em>2</em> A postfix expression followed by an expression in square brackets <code>[]</code>
  is a subscripted designation of an element of an array object. <strong>The
  definition of the subscript operator <code>[]</code> is that <code>E1[E2]</code> is
  identical to <code>(*((E1)+(E2)))</code></strong>. Because of the conversion rules that
  apply to the binary <code>+</code> operator, if <code>E1</code> is an array object
  (equivalently, a pointer to the initial element of an array object)
  and <code>E2</code> is an integer, <code>E1[E2]</code> designates the <code>E2</code>-th element of
  <code>E1</code> (counting from zero).</p>
</blockquote>

<p>The expression <code>arr[i]</code> in your example is of the form <code>E1[E2]</code>.  Because the standard states that this is the same as <code>*(E1+E2)</code> that means that <code>arr[i]</code> is the same as <code>*(arr + i)</code>.</p>

<p>Because of the commutative property of addition, <code>*(arr + i)</code> is the same as <code>*(i + arr)</code>.  Applying the equivalence rule above to this expression gives <code>i[arr]</code>.</p>

<p>So in short, those 4 expressions are equivalent because of how the standard defines array subscripting and because of the commutative property of addition.</p>
",0
45039744,45039683,1,"<p>They are the same because the C language specification says so. Read <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""nofollow noreferrer"">n1570</a></p>
",0
45040054,45039683,3,"<p>Each element in the array, have a position in memory. The positions in the arrays are sequential. The arrays in C are pointers and always point the first direction on memory for the collection (first element of the array).</p>

<p><strong>arr[i]</strong> => Gets value of ""i-position"" in the array. It is the same that <code>arr[i] = *(arr + i)</code></p>

<p><strong>*(arr+i)</strong> => Gets value that is in memory by adding the position in memory that point <code>arr</code> and <code>i value</code>.</p>

<p><strong>*(i+arr)</strong> => Is the same that <code>*(arr+i)</code>. The sum is commutative.</p>

<p><strong>i[arr]</strong> => Is the same that <code>*(i+arr)</code>. It's another way of representing.</p>
",4
45040117,45039683,6,"<p>Lets take a look at how your array is laid out in memory:</p>

<pre>
low address                   high address
|                             |
v                             v
+----+----+----+----+----+----+
| 34 | 65 | 23 | 75 | 76 | 33 |
+----+----+----+----+----+----+
^    ^    ^    ^
|    |    |    ...etc
|    |    |
|    |    arr[2]
|    |
|    arr[1]
|
arr[0]
</pre>

<p>That the first elements is <code>arr[0]</code>, the second <code>arr[1]</code> is pretty clear, that's what everybody learns. What is less clear is that the compiler actually translates an expression such as <code>arr[i]</code> to <code>*(arr + i)</code>.</p>

<p>What <code>*(arr + i)</code> does is first get a pointer to the first element, then do pointer arithmetic to get a pointer to the wanted element at index <code>i</code>, and then dereference the pointer to get its value.</p>

<p>Due to the <a href=""https://en.wikipedia.org/wiki/Commutative_property"" rel=""noreferrer"">commutative</a> property of addition, the expression <code>*(arr + i)</code> is equal to <code>*(i + arr)</code> which due to the above mentioned translation is equal to <code>i[arr]</code>.</p>

<hr>

<p>The equivalence of <code>arr[i]</code> and <code>*(arr + i)</code> is also what's behind the <em>decay</em> of an array to a pointer to its first element.</p>

<p>The pointer to the arrays first element would be <code>&amp;arr[0]</code>. Now we know that <code>arr[0]</code> should be equal to <code>*(arr + 0)</code> which means <code>&amp;arr[0]</code> has to be equal to <code>&amp;*(arr + 0)</code>. Adding zero to anything is a no-op, so leading to the expression <code>&amp;*(arr)</code>. Parentheses with only one term and no operator can also be removed, leaving <code>&amp;*arr</code>. And lastly the address-of and dereference operator are each other opposites and cancel out each other, leaving us with simply <code>arr</code>. So <code>&amp;arr[0]</code> is equal to <code>arr</code>.</p>
",0
40959401,40959251,1,"<p>As @ChronoKitsune points out you've got an extra <code>;</code> after the <code>for</code> loop.</p>

<p>Before this gets closed for a typo; use <code>clang-format</code> or another automatic formatting tool! It will make these errors obvious.</p>

<p>Watch what happens when I <code>clang-format</code> your code sample:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;
#define maxn 1000
int main()
{
    double c = 12.01, h = 1.008, n = 14.01, o = 16.00, sum = 0, al, num;
    char mol[maxn];
    scanf(""%s"", mol);
    for (int i = 0; i &lt; strlen(mol); i++)
        ;
    {
        if (isalpha(mol[i])) {
            if (mol[i] == 'C')
                al = c;
            if (mol[i] == 'H')
                al = h;
            if (mol[i] == 'O')
                al = o;
            if (mol[i] == 'N')
                al = n;
            if (isalpha(mol[i + 1]))
                sum += al;
            else {
                num = mol[i + 1] - '0';
                sum += al * num;
            }
        }
    }
    printf(""%lf\n"", sum);
    return 0;
}
</code></pre>

<p>And the typo stands out a mile:</p>

<pre><code>    for (int i = 0; i &lt; strlen(mol); i++)
        ;
    {
</code></pre>

<p>Remove the errant <code>;</code> and re-apply <code>clang-format</code> (which, by the way, is a single keyboard command on whatever code editor you're using):</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;
#define maxn 1000
int main()
{
    double c = 12.01, h = 1.008, n = 14.01, o = 16.00, sum = 0, al, num;
    char mol[maxn];
    scanf(""%s"", mol);
    for (int i = 0; i &lt; strlen(mol); i++) {
        if (isalpha(mol[i])) {
            if (mol[i] == 'C')
                al = c;
            if (mol[i] == 'H')
                al = h;
            if (mol[i] == 'O')
                al = o;
            if (mol[i] == 'N')
                al = n;
            if (isalpha(mol[i + 1]))
                sum += al;
            else {
                num = mol[i + 1] - '0';
                sum += al * num;
            }
        }
    }
    printf(""%lf\n"", sum);
    return 0;
}
</code></pre>

<p>That's the built-in <code>webkit</code> style. You can specify your own style, for example if you want <code>if (mol[i] == 'C') al = c;</code> to be on one line if it's short enough.</p>
",0
40959404,40959251,1,"<p>There is an extra <code>;</code> at the end of <code>for (int i = 0; i &lt; strlen(mol); i++);</code></p>

<p>The loop is empty, the following code executes with <code>i</code> equal to <code>strlen(mol)</code>, but since <code>i</code> is defined for the scope of the <code>for</code> statement only, it is undefined in the block. Hence the error message.</p>

<p>You can avoid this kind of silly bug by using the Kernighan and Ritchie indentation style: put the <code>{</code> at the end of the line with the <code>if</code>, <code>for</code>, <code>while</code>, <code>do</code> or <code>switch</code> statement. This makes it much less likely to type a spurious <code>;</code> between the control statement and its block.</p>

<p>It is also advisable to always use braces for compound statements and always use uppercase for macros.</p>

<p>Here is your program with this indentation and pacing style:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;

#define MAXN  1000 

int main() {
    double c = 12.01, h = 1.008, n = 14.01, o = 16.00, sum = 0, al, num;
    char mol[MAXN];

    scanf(""%s"", mol);
    for (int i = 0; i &lt; strlen(mol); i++) {
        if (isalpha(mol[i])) {
            if (mol[i] == 'C') {
                al = c;
            }
            if (mol[i] == 'H') {
                al = h;
            }
            if (mol[i] == 'O') {
                al = o;
            }
            if (mol[i] == 'N') {
                al = n;
            }
            if (isalpha(mol[i + 1])) {
                sum += al;
            } else {
                num = mol[i + 1] - '0';
                sum += al * num;
            }
        }
    }
    printf(""%lf\n"", sum);
    return 0;
}
</code></pre>

<p>Note also that:</p>

<ul>
<li><p><code>scanf(""%s"", mol);</code> cannot prevent buffer overfow if the input is loo long.  You could use <code>scanf(""%999s"", mol);</code> but you would need to maintain consistency between the <code>999</code> and the definition of <code>MAXN</code> which is non-obvious.</p></li>
<li><p><code>isalpha(mol[i])</code> may invoke undefined behavior if <code>char</code> is signed by default and <code>mol[i]</code> has a negative value.  You can prevent this by writing <code>isalpha((unsigned char)mol[i])</code>.</p></li>
<li><p>You assume that <code>mol</code> only contains alpha and numeric characters. If the user enters anything else, <code>num = mol[i + 1] - '0'</code> will not be the value of a digit and the computation will be incorrect.</p></li>
<li><p>Actually, the code silently fails if an unknown element is entered by the user, if the number of a given element in the molecule exceeds 9, such as for decane <code>C10H22</code> or if the last element is not followed by a number as in <code>H2O</code>.</p></li>
</ul>

<p>Here is an improved version:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

int main() {
    double c = 12.01, h = 1.008, n = 14.01, o = 16.00, sum = 0, al, num;
    char mol[1000];

    scanf(""%999s"", mol);
    for (int i = 0; mol[i] != '\0'; i++) {
        if (isalpha((unsigned char)mol[i])) {
            if (mol[i] == 'C') {
                al = c;
            } else
            if (mol[i] == 'H') {
                al = h;
            } else
            if (mol[i] == 'O') {
                al = o;
            } else
            if (mol[i] == 'N') {
                al = n;
            } else {
                printf(""unknown element: '%c'\n"", mol[i]);
                al = 0;
            }
            num = 1;
            if (isdigit((unsigned char)mol[i + 1])) {
                num = 0;
                for (int j = 1; isdigit((unsigned char)mol[j]); j++) {
                    num = num * 10 + mol[j] - '0';
                }
            }
            sum += al * num;
        }
    }
    printf(""%f\n"", sum);
    return 0;
}
</code></pre>
",2
45754505,45754310,2,"<p>This is never going to work...</p>

<pre><code>outText[strlen(outText)] = '\0';
</code></pre>

<p>... because <code>strlen()</code> needs the string to be null terminated for it to work properly.</p>

<p>But you don't need to do anything as complicated as what you have, since you're already incrementing <code>outText</code>, when the loop finishes it's already at the end of the string and you can just do</p>

<pre><code>*outText='\0';
</code></pre>

<p>Also, I'm not sure what the <code>'\0'</code> is doing in this line of code, but it's not terminating anything. It'll just be converted into an integer of value 0.</p>

<pre><code>*outText = ((*outText + shift) + '\0');
</code></pre>

<p>What you should probably do is make sure that when you shift the letters they stay as letters like this.</p>

<pre><code>*outText = (((*outText-'a') + shift) % 26)+'a';
</code></pre>

<p>That obviously only works for lowercase letters - you'd need to use <code>'A'</code> instead for uppercase letters - you can tell what you've got by using <code>isupper()</code> or <code>islower()</code> like this and then you won't also need to do the <code>isalpha()</code> check as well.</p>

<pre><code>if(isupper(*inText)) {
    *outText = (((*outText-'A') + shift) % 26)+'A';
}
else if(islower(*inText)) {
    *outText = (((*outText-'a') + shift) % 26)+'a';
}
</code></pre>
",1
45754506,45754310,3,"<p>Problem is in your format part.</p>

<p>You must take care of lowercase or uppercase first.</p>

<p>Check if statement if character is lowercase or uppercase.</p>

<pre><code>if (isalpha(*inText)) {
    if (isupper(*outText)) {
        *outText = (((*outText - 'A') + shift) % 26 + 'A');
    } else {
        *outText = (((*outText - 'a') + shift) % 26 + 'a');
    }
}
</code></pre>

<p>lowercase and uppercase values have different values in ASCII table but they are one after another, meaning letter <code>b</code> is just after <code>a</code>.</p>

<p>To get your result, you have to first subtract base character (either 'A' or 'a') do the mathematical job and after add again base character.</p>

<p>Later, replace your strlen for null termination with</p>

<pre><code>*outText = 0;
</code></pre>

<hr>

<p>Full code</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;

void confab(const char* inText, int shift, char* outText) {
    // visit each char of inText
    // assign current val of inText to current val of outTextheck
    // if current val of inText is letter, shift the letter
    // go to next char of inText
    outText[0] = '\0';
    while (*inText) {
        *outText = *inText;
        if (isalpha(*inText)) {
            char t = isupper(*outText) ? 'A' : 'a';
            int tmp = (((int)*outText - t) + shift) % 26;
            if (tmp &lt; 0) {
                tmp += 26;
            }
            *outText = tmp + t;
        }
        (inText++);
        (outText++);
    }
    *outText = 0;
}

int main(void) {
    char buffer[60] = {0};
    char* s = ""The quick brown fox jumps over the lazy dog."";
    confab(s, -1, buffer);
    printf(""%s\n%s\n"", s, buffer);
}
</code></pre>
",10
45755020,45754310,0,"<p>I didn't use pointer so it's (I think) easier to understand.</p>

<pre><code>void confab(const char* inText, int shift, char* outText) 
{
    int i = 0;
    int j = 0;
    unsigned char character = '\0';
    while (inText[i] != '\0') 
    {
        if (inText[i] &gt;= 'A' &amp;&amp; inText[i] &lt;= 'Z') 
        {
            character = inText[i] + shift;
            if (character &gt; 'Z')
                character = character - 'Z' + 'A' - 1;
            outText[j] = character;
            j++;
        } 
        else if (inText[i] &gt;= 'a' &amp;&amp; inText[i] &lt;= 'z') 
        {
            character = inText[i] + shift;
            if (character &gt; 'z')
                character = (character - 'z' + 'a' - 1);
            outText[j] = character;
            j++;
        } 
        else 
        {
            outText[j] = inText[i];
            j++;
        }
        i++;
    }
    outText[j] = '\0';
}
</code></pre>

<p>unsigned char because its value might because more than 127.
<code>if (character &gt; 'Z')</code>
= am I still within the alphabet, if not <code>character = (character - 'Z' + 'A' - 1);</code> out of alphabet? start again from A.
At the end of the fuction <code>outText[j] = '\0';</code> makes sure that your string is delimited as you want it to be.</p>
",0
47660444,47659961,1,"<p>You mentioned you want to make a game in C.</p>

<p>Create your own window.
Capture and Process events.</p>

<p>This sounds a bit much for a beginner but actually it is not.
Use a library like SDL2 to help you with that.</p>

<p>Here is a <a href=""http://lazyfoo.net/tutorials/SDL/"" rel=""nofollow noreferrer"">tutorial series</a> that walks you through some of the basics of game making.</p>
",0
46973476,46973390,1,"<p>You're putting <code>%c</code> in your <code>printf</code> statement, telling the compiler that you want to print a single character.</p>

<p>You're also using single quotes <code>'</code> around the sequence of characters  <code>pasundu</code> - what you have here is a multicharacter literal. Multicharacter literals have an implementation-defined value - in this case it appears the compiler is taking the last character in your literal.</p>

<p>To fix this, I assume you want to display <code>pasundu</code> as a string:</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    printf(""%s\n"",""pasundu"");
}
</code></pre>

<p>Note that I've also changed the return type of <code>main</code>, as void is allowed but isn't required to be supported in all compilers.</p>
",5
45055654,45055525,-3,"<p>I think the main problem is that you don't provide a sentence to get the words.</p>

<pre><code>char s[2222] = ""Enter here the sentence you want to check."";
</code></pre>
",3
45057370,45055525,0,"<ol>
<li>You cannot use <code>strstr</code> to search for words: the number of occurrence of <code>""is""</code> in <code>""is this a test?""</code> is two, not one.</li>
<li>You cannot use <code>strtok</code> two times; first time to search for first occurrence and second time for subsequent occurrences, instead of <code>strstr</code>: <code>strtok</code> is using a static variable (see the note in this <a href=""https://msdn.microsoft.com/en-us/library/2c8d19sb.aspx"" rel=""nofollow noreferrer"">page</a>).</li>
</ol>

<p><strong>[EDIT]</strong></p>

<p>A begginner solution (<a href=""http://ideone.com/bEUXAl"" rel=""nofollow noreferrer"">run it</a>):</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

#define MAXWORD 32
typedef struct
{
  char word[MAXWORD];
  int count;
} word_and_count_t;

#define MAXWORDCOUNT 1024
word_and_count_t table[MAXWORDCOUNT];

int table_size;

word_and_count_t* find( const char* word ) // range checking ignored
{
  int i;

  for ( i = 0; i &lt; table_size; ++i )
    if ( !strcmp( table[i].word, word ) )
      return table + i;

  strcpy( table[i].word, word );
  table[i].count = 0;

  ++table_size;

  return table + i;
}

void display()
{
  for ( int i = 0; i &lt; table_size; ++i )
    printf( ""%s - %d\n"", table[i].word, table[i].count );
}

int main()
{
  //
  char s[] = ""The greatness of a man is not in how much wealth he acquires, but in his integrity and his ability to affect those around him positively."";

  //
  for ( char* word = strtok( s, "" ,."" ); word; word = strtok( 0, "" ,."" ) )
    find( word )-&gt;count++;

  //
  display();

  return 0;
}
</code></pre>
",0
41207585,41207558,1,"<p>You don't <code>#define</code> functions, you <code>#define</code> macros, and those are quite different from functions.</p>

<ol>
<li><p>They aren't called. They are expanded into the source code directly by the preprocessor, before the code is compiled by the compiler.</p></li>
<li><p>They have <a href=""https://gcc.gnu.org/onlinedocs/cpp/Macro-Pitfalls.html"" rel=""nofollow noreferrer"">pitfalls</a> that one must be aware of. To name one, if you pass an expression with side effects to a macro the uses its parameter more than once, the side effects <em>will</em> occur more than once, and you may get wrong results.</p></li>
<li><p>The substation is plain token substitution, so</p>

<pre><code>CUBE(n + 1)
</code></pre>

<p>will be expand to this:</p>

<pre><code>(n + 1 * n + 1 * n + 1) 
</code></pre></li>
</ol>
",0
41207592,41207558,0,"<pre><code>#define CUBE(x) ((x) * (x) * (x))
</code></pre>

<p>should give you the expected result.</p>

<p>In your, on preprocessing, <code>x</code> in <code>CUBE(x)</code> is <em>replaced</em> by <code>3+1</code> which gives you</p>

<pre><code>(3+1 * 3+1 * 3+1) // this happens during pre-processing, not in run time
</code></pre>

<p>as macro is plain-text replacement.</p>

<p>which will be grouped like</p>

<pre><code>(3+(1 * 3)+(1 * 3)+1)
</code></pre>

<p>giving you <code>10</code>. For more complex cases, I suggest writing a function.</p>
",0
41207607,41207558,0,"<p>As the previous answer already suggest, you are missing a pair of brackets,
because the preprocessor basically does find and replace. So your version result in </p>

<pre><code>m = n + 1 * n + 1 * n + 1
</code></pre>

<p>which evaluates to the result, you observed.</p>

<p>With </p>

<pre><code>#define CUBE(x) ((x) * (x) * (x))
</code></pre>

<p>you will get the correct calculation of</p>

<pre><code>m = (n + 1) * (n + 1) * (n + 1)
</code></pre>
",0
45036945,45036764,9,"<p>This is undefined behavior: the standard does not guarantee pointers to <code>int</code> and <code>float</code> to have the same alignment, so <code>(int*)&amp;f</code> cast is invalid (<a href=""https://stackoverflow.com/a/30276722/335858"">Q&amp;A</a>).</p>

<p>In your case, the cast produced a value that is consistent with IEEE-754 representation of 0.5 (5e-1) below:</p>

<pre><code>bin:    0011 1111 0000 0000 0000 0000 0000 0000
        +--- ---- -=== ==== ==== ==== ==== ====
hex:       3    f    0    0    0    0    0    0
</code></pre>

<p>where <code>+</code> is the sign bit, <code>-</code> are exponent bits, and <code>=</code> are mantissa bits.</p>

<p>However, there is absolutely no guarantee that the same program is going to produce the same result when you run it on other systems, or even that the program is going to run to completion.</p>
",0
45036966,45036764,5,"<p>You may prefer</p>

<pre><code>void dump(const void *data, size_t len) {
    const unsigned char *x = data;
    printf(""%02x"", x[0]);
    for (size_t k = 1; k &lt; len, k++) printf("" %02x"", x[k]);
    puts("""");
}
</code></pre>

<p>And then</p>

<pre><code>float f = 5e-1;
dump(&amp;f, sizeof f);
</code></pre>
",0
45037181,45036764,2,"<p>Since you are new to <code>C / C++</code> - I guess - you may not have any ideas with respect to <code>undefined behaviors</code>. In short, there are some corners at which the <code>C / C++</code> languages do not <code>define</code> what should happen exactly. Why? There are a lot of reasons behind, e.g. performance. In those cases, the results or effects of the behaviors are completely rely on implementations (compilers - more specifically (e.g. gcc, vc++)).</p>

<p>What you are doing here is listed at item 7 of the accepted answer to <a href=""https://stackoverflow.com/questions/367633/what-are-all-the-common-undefined-behaviours-that-a-c-programmer-should-know-a"">What are all the common undefined behaviours that a C++ programmer should know about?</a></p>
",2
45037475,45036764,2,"<p>Others have already addressed the undefined behavior so I'll only address this part:</p>

<blockquote>
  <p>I'm having difficulties in understanding why this code results in 3f000000</p>
</blockquote>

<p>The code tries to print the binary representation of the float value 0.5 (or 5e-1).</p>

<p>(<em>it does that in an illegal way though - see other answers for the correct way</em> - see this answer <a href=""https://stackoverflow.com/a/45036945/4386427"">https://stackoverflow.com/a/45036945/4386427</a> )</p>

<p>The explanation for the value 3f000000 is that your system seem to use IEEE 754 single-precision binary floating-point format (see <a href=""https://en.wikipedia.org/wiki/Single-precision_floating-point_format"" rel=""nofollow noreferrer"">https://en.wikipedia.org/wiki/Single-precision_floating-point_format</a>).</p>

<p>The format uses</p>

<ul>
<li>bit 31 as sign bit (0 in your case)</li>
<li>bit 30..23 as exponent (01111110 binary = 7e hex = 126 decimal in your case)</li>
<li>bit 22..0 as fraction (all zero in your case)</li>
</ul>

<p>So in your case</p>

<ul>
<li>sign is 0</li>
<li>exponent is 126</li>
<li>fraction is 0</li>
</ul>

<p>In general the value is calculated as:</p>

<blockquote>
  <p>value = (-1)^sign * (1 + fraction) * 2^(exponent - 127)</p>
</blockquote>

<p>Since sign and fraction is 0, it is pretty easy to calculate the value: </p>

<blockquote>
  <p>value = 1 * 1 * 2^(126 - 127) = 2^-1 = 0.5</p>
</blockquote>

<p>So with IEEE 754 single-precision binary floating-point a float with value 0.5 is stored with the binary pattern 3f000000</p>
",0
43191521,43191296,-2,"<p>You need <code>malloc</code> for dynamic allocation of memory.In your case, both the types <code>char</code> and <code>int</code> are known to the compiler, it means the compiler can know the exact memory requirement at compile time. </p>

<p>For e.g. you can create a <code>struct</code> object like in the <code>main</code> function</p>

<pre><code> #include&lt;stdio.h&gt;
 #include&lt;stdlib.h&gt;
 struct FluxCapacitor{
    unsigned char* c_string;
    unsigned int value;
 };

 int main() {
     FluxCapacitor x;
     x.c_string = ""This is x capacitor""
     x.value = 10
 }
</code></pre>

<p>The <code>x</code> is of value type. You can make a copy and pass around this value. Also, observe we are using <code>.</code> notation to access its member variables.</p>

<p>But this doesn't happen at all time. We are not aware of future <code>FluxCapacitor</code> requirement and so above program will need more memory as while it is running and by using the <code>malloc</code> we can ask the compiler to provide us requested memory. This is a good place to use <code>malloc</code>, what <code>malloc</code> does is, it returns us a pointer to a piece of memory of the requested size. It is dynamic memory allocation. </p>

<p>Here's a simple example: let suppose if you need struct declaration of <code>FluxCapacitor</code> but don't know how many you will need, then use <code>malloc</code>  </p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

typedef struct FluxCapacitor {
   unsigned char* c_string;
   int value;;
} flux;
// typedef is used to have the alias for the struct FluxCapacitor as flux

int main() {
    flux *a = malloc(sizeof(flux)); // piece of memory requested
    a -&gt; c_string = ""Hello World"";  // Pointer notation
    a -&gt; value = 5;

    free(a);                       // you need to handle freeing of memory
    return 0;
}
</code></pre>

<p>.</p>
",8
43194309,43191296,1,"<p>You do not need <code>malloc()</code> to create an instance of a <code>struct</code>. And I would recommend that you avoid <code>typedef</code>ing structures merely to reduce keystrokes. The extra keystrokes would only be saved in declarations and function prototypes (and maybe if you need to cast something), since you don't need the <code>struct</code> keyword elsewhere; the advantage is that when you see <code>struct FluxCapacitor</code>, you know exactly what it is. If you only see <code>FluxCapacitor</code> alone, you don't know if it is a <code>typedef</code> for a <code>struct</code>, or a <code>union</code>, or an integer type or what.</p>

<p>Note that the posted code was missing the semicolon at the end of the declaration. Also, it is unclear why you have <code>unsigned char* c_string;</code>. This may not allow assignment to a string literal. I have changed this in the code below. You can create a single <code>struct</code> like this:</p>

<pre><code>struct FluxCapacitor
{
    char *c_string;
    unsigned int value;
};

...

struct FluxCapacitor fcap_1;
</code></pre>

<p>You can then assign values to the fields of <code>fcap_1</code>:</p>

<pre><code>fcap_1.c_string = ""McFly"";
fcap_1.value = 42;
</code></pre>

<p>Note that you could also use designated initializers at the point of declaration:</p>

<pre><code>struct FluxCapacitor fcap_2 = { .c_string = ""Biff"",
                                .value = 1985
};
</code></pre>

<p>If you need an array of <code>FluxCapacitor</code> structures, just declare one:</p>

<pre><code>struct FluxCapacitor fcaps[2];
</code></pre>

<p>You can assign to the fields of each array member in a loop:</p>

<pre><code>struct FluxCapacitor fcaps[2];

char *somestrings[] = { ""McFly"", ""Biff"" };
unsigned somevalues[] = { 42, 1985 };

for (size_t i = 0; i &lt; 2; i++) {
    fcaps[i].c_string = somestrings[i];
    fcaps[i].value = somevalues[i];
}
</code></pre>

<p>Alternatively, you can use designated initializers here too:</p>

<pre><code>struct FluxCapacitor fcaps[2] = { { .c_string = ""McFly"", .value = 42 },
                                  { .c_string = ""Biff"", .value = 1985}
};
</code></pre>

<h2>Using <code>malloc()</code></h2>

<p>Since OP seems determined to use <code>malloc()</code>, it would be good to first recall that memory allocated with <code>malloc()</code> must later be deallocated with <code>free()</code>. Also note that <code>malloc()</code> can fail to allocate memory, returning a null pointer. Thus the result of a call to <code>malloc()</code> must be checked before attempting to dereference this pointer. The additional complexity should be avoided in favor of the above approaches unless OP has good reason to do manual allocation.</p>

<p>In the code below, the function <code>create_flux_cap()</code> takes a string and an <code>unsigned int</code> as arguments, and returns a pointer to a newly allocated <code>FluxCapacitor</code> structure with the arguments assigned to the appropriate fields. Note that since the <code>FluxCapacitor</code> structure is accessed through a pointer, the arrow operator is used instead of the dot operator.</p>

<p>Inside the function, the return value from the call to <code>malloc()</code> is checked before attempting assignment. If the allocation has failed, no assignment is made and a null pointer is returned to the calling function. Note that in the call to <code>malloc()</code>, the result is not cast, since there is no need for this in C and it needlessly clutters the code. Also observe that an identifier is used instead of an explicit type with the <code>sizeof</code> operator. This is less error-prone, easier to maintain if types change in the future, and is much cleaner code. That is, instead of this:</p>

<pre><code>new_fcap = (struct FluxCapacitor *)malloc(sizeof (struct FluxCapacitor));
</code></pre>

<p>use this:</p>

<pre><code>new_fcap = malloc(sizeof *new_fcap);
</code></pre>

<p>In <code>main()</code>, the return values from the calls to <code>create_flux_cap()</code> are checked. If an allocation has failed, the program exits with an error message.</p>

<p>The <code>stdlib.h</code> header file has been included for the function prototypes of <code>malloc()</code> and <code>exit()</code>, and also for the macro <code>EXIT_FAILURE</code>.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct FluxCapacitor
{
    char* c_string;
    unsigned value;
};

struct FluxCapacitor * create_flux_cap(char *, unsigned);

int main(void)
{
    struct FluxCapacitor *fcap_1 = create_flux_cap(""McFly"", 42);
    struct FluxCapacitor *fcap_2 = create_flux_cap(""Biff"", 1985);

    /* Check for allocation errors */
    if (fcap_1 == NULL || fcap_2 == NULL) {
        fprintf(stderr, ""Unable to create FluxCapacitor\n"");
        exit(EXIT_FAILURE);
    }

    /* Display contents of structures */
    printf(""%s, %u\n"", fcap_1-&gt;c_string, fcap_1-&gt;value);
    printf(""%s, %u\n"", fcap_2-&gt;c_string, fcap_2-&gt;value);

    /* Free allocated memory */
    free(fcap_1);
    free(fcap_2);

    return 0;
}

struct FluxCapacitor * create_flux_cap(char *str, unsigned val)
{
    struct FluxCapacitor *new_fcap;

    new_fcap = malloc(sizeof *new_fcap);

    if (new_fcap != NULL) {
        new_fcap-&gt;c_string = str;
        new_fcap-&gt;value = val;
    }

    return new_fcap;
}
</code></pre>
",0
43198140,43197980,1,"<p>In <code>addFront</code> and <code>addRear</code> you are using</p>

<pre><code>ptrNew-&gt;name=Name;
</code></pre>

<p>You cannot just assign the pointer for <code>name</code> in the list to the pointer that you are reading from scanf. What happens in this case is the every <code>List-&gt;name</code> will point to the same location and if <code>Name</code> (from scanf) changes (in your case to ""quit"" as the last element. every <code>List-&gt;name</code> will give ""quit""</p>

<p>What you need to do, is to allocate memory for each name separately.</p>

<pre><code>ptrNew-&gt;name=malloc(strlen(Name)+1);
strcpy(ptrNew-&gt;name, Name);
</code></pre>

<p>Or, you can change the structure definition to store an array in name of sufficient length</p>

<pre><code>typedef struct person {
    char name[20];
    int age;
    struct person *next;
} Person;    
</code></pre>

<p>in which case you can skip the malloc step above, but the <code>strcpy</code>  is still required.</p>
",0
43198148,43197980,1,"<p>You are using <code>ptrNew-&gt;name</code> as character pointer and it always points to <code>theName</code> variable from <code>main()</code>. So all nodes in linked list points to same name.</p>

<p>Rather you should change code in <code>addFront()</code> and <code>addRear()</code> to </p>

<pre><code>ptrNew-&gt;name= strdup(Name);
</code></pre>

<p>Instead of </p>

<pre><code>ptrNew-&gt;name=Name;
</code></pre>

<p>Make sure you <code>free</code> the memory appropriately when you are done with the node.</p>
",0
45113916,45113354,0,"<p>Doing this:</p>

<pre><code>celcius=(ferenheit-32)*(5.0/9.0);
</code></pre>

<p>Does not mean that the value of <code>celcius</code> will always be <code>(ferenheit-32)*(5.0/9.0)</code>, anytime that <code>ferenheit</code> changes.  What is does mean is that it sets <code>celcius</code> to <code>(ferenheit-32)*(5.0/9.0)</code> <strong>at the time the statement is encountered</strong>.  Since <code>ferenheit</code> doesn't have value yet when this statement runs, the value of <code>celcius</code> is indeterminate.</p>

<p>You need to first read in the value of <code>ferenheit</code>, <em>then</em> calculate <code>celcius</code> based on that:</p>

<pre><code>printf(""Enter your ferenheit temperature : "");
scanf(""%f"",&amp;ferenheit);             // first read
celcius=(ferenheit-32)*(5.0/9.0);   // then calculate
printf(""Your ferenheit temperature in celcius is :%d\n"",celcius);
</code></pre>

<p>Also, they're spelled ""celsius"" and ""fahrenheit"".</p>
",0
47546112,47545948,2,"<p>You showed in the question:</p>

<pre><code>((sz)+PGSIZE-1) =&gt; (0x123456)+4096-1 
                =(0x123456)+(0x1000 0000 0000) - 1 //4096 is 2^12
                =0x1000 0012 3456 - 1
</code></pre>

<p>You converted 4096 to a binary notation, but then treat it as a hexadecimal number. That won't work. If you want to keep the hexadecimal notation, that's: </p>

<pre><code>((sz)+PGSIZE-1) =&gt; (0x123456)+4096-1 
                =(0x123456)+(0x1000) - 1
                =0x124456 - 1
</code></pre>

<p>Or converting both to binary, that's:</p>

<pre><code>((sz)+PGSIZE-1) =&gt; (0x123456)+4096-1 
                =(0b1_0010_0011_0100_0101_0110)+(0b1_0000_0000_0000) - 1
                = 0b1_0010_0100_0100_0101_0110 - 1
</code></pre>
",1
47548837,47545948,1,"<p>The error is in your calculation.
2^12 is not 1000 0000 0000, but 0001 0000 0000 0000.</p>

<p>The weights of binary begin as 2^0 which is one so 2^12 comes at 13th position so 4096 is 0x1000
 If you use this for your manual calculation you will get 0x124000 as your answer.</p>

<p>The below calculation also answers your doubt ""how 0x124455 &amp; 1000 becomes 0x124000? Does if automatically fill 1s to the front? Could you explain little more about it on the question?"" in the comment of the previous answer.</p>

<pre><code>4096 = 0x1000 
4096-1 =&gt; 0xfff =&gt; 0x0000 0fff
    ~(4096-1) is thus 0xfffff000

    Coming to the addition part in macro 
     (0x123456)+4096-1 
         =&gt;0x123456+0x1000-1
         =&gt;0x124456-1
         =&gt;0x124455

    You result will be 0x124455 &amp; 0xfffff000 which is 0x124000 which is the correct output
</code></pre>
",3
46100050,46099749,1,"<p>Here is an attempt to answer what you asked:</p>

<pre><code>#include &lt;stdio.h&gt;

struct strData
{
//changed member name from data to value due to conflicting call in funtion
    int value;
    char* name;
};

//function takes a void pointer as parameter and returns a void pointer
//I don't understand why you have written such code below.
void *function (void *args)
{ 
    struct strData *data = args; 
    char* str;
    int a;
    str = data-&gt;name; 
    a = data-&gt;value;
    if( data-&gt;value == 1)
    {   
        data-&gt;value = 10; 
    }   

    //return statement required at the end. Why?
    return data;
}

int main(){
    //created a variable of strData
    struct strData data;
    //initialised random values
    data.value = 1;
    data.name = ""stackoverflow.com"";
    //pass address of the variable. Why? typecast to struct. Why? Finally get value using *. Why?
    data = *(struct strData*)function(&amp;data);
    printf(""%s %d"", data.name, data.value);
    return 0;
}
</code></pre>

<p>Answer all why questions yourself. </p>
",6
47964852,47964458,2,"<p>You have to put the code that you need to use again inside a loop. A <code>while</code> loop with a check variable (you already have that) is all you need.</p>

<p>example:</p>

<pre><code>// print menu
// get input
// check if input is valid
while(menu != 'c')
{
    //your code here

     // print menu
    // get input
   // check if input is valid
}
</code></pre>
",3
44376908,44376881,5,"<p>That's because <code>main()</code> is always the entry point for a C/C++ program and is the only implicitly called function.</p>

<p>Try:</p>

<pre><code>int main(void) {
   printf(""Came to main. \n"");
   main1();
   main2();
}
</code></pre>
",0
44376942,44376881,0,"<p>You failed to call your function inside the main function. One suggestion is to not name the function as main1 and main2 since it is ambiguous.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main1(void)
{
   printf(""Came to main1.\n"");
}

int main2(void)
{
   printf(""Came to main2.\n"");
}

int main(void)
{
   printf(""Came to main. \n"");
   main1();  // this is the plain function call. 
   main2();
}
</code></pre>

<p><strong>Output:</strong></p>

<pre><code>Came to main.
Came to main1.
Came to main2.
</code></pre>

<p>More information about the <a href=""http://beginnersbook.com/2014/01/c-functions-examples/"" rel=""nofollow noreferrer"">function call</a>. </p>
",4
44377373,44376881,1,"<p>I think you are just curious as a beginner that you can define multiple mains in your program. Understand that main is a special function. You cannot have several mains in your program. If you define main1 or main2 they are always going to be ordinary functions. And execution of programs will start with main(). Though there are constructors that are called before main and you can explicitly define a function to be one, but in general/default cases main is the entry point of the program.</p>

<p>But if you still want to call main1 before main here's how you can do:</p>

<pre><code>#include &lt;stdio.h&gt;

int main1(void) __attribute__ ((constructor));// Note this line.     

int main2(void) __attribute__ ((constructor));

int main2(void)
{
   printf(""Came to main2.\n"");
}


int main1(void)
{
   printf(""Came to main1.\n"");

}

int main(void)
{
   printf(""Came to main. \n"");
}
</code></pre>

<p>Also note the order in which main1 and main2 are defined. main1 is defined after main2. Therefore the output is </p>

<pre><code>Came to main1.
Came to main2.
Came to main.
</code></pre>

<p>Beware, this is a gcc specific thing.</p>
",0
44377128,44376881,2,"<p>You can do this with some preprocessor trickery:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#ifdef MAIN1

int main(void)
{
   printf(""Came to main1.\n"");
   return 0;
}

#elif defined MAIN2

int main(void)
{
   printf(""Came to main2.\n"");
   return 0;
}

#else

int main(void)
{
   printf(""Came to main. \n"");
   return 0;
}

#endif
</code></pre>

<p>Then you define <code>MAIN1</code> or <code>MAIN2</code> as needed:</p>

<pre class=""lang-none prettyprint-override""><code>[dbush@centos72 ~]$ gcc -o x1 x1.c
[dbush@centos72 ~]$ ./x1
Came to main. 
[dbush@centos72 ~]$ gcc -D MAIN1 -o x1 x1.c
[dbush@centos72 ~]$ ./x1
Came to main1.
[dbush@centos72 ~]$ gcc -D MAIN2 -o x1 x1.c
[dbush@centos72 ~]$ ./x1
Came to main2.
[dbush@centos72 ~]$
</code></pre>
",0
45712577,45712052,4,"<p>Ok, let's spot the errors:</p>

<pre><code>void double_min_max(int **range, int min, int max)
{
    range = (int **)malloc(sizeof(int)* 10);
</code></pre>

<p>The cast with malloc is unnecessary and could even <a href=""https://stackoverflow.com/q/605845/2371524"">lead to problems</a>. Don't do this.</p>

<p>Then you want to assign to <code>*range</code>, not to <code>range</code>. <code>range</code> is local to your function (all arguments are passed <em>by value</em> in C), so modifying it will never have any effect visible to the calling code. When you call this function, you should pass a <em>pointer to a pointer</em>, so the pointer can be modified by the function through <code>*range</code>.</p>

<p>Finally, this should be obvious, but you should <strong>calculate</strong> the required size from your <code>min</code> and <code>max</code>. The <code>10</code> is just a ... uhm ... <em>very rough guess</em>. Not a good idea.</p>

<pre><code>    int i = 0;
        while (min &lt; max)
        {
        **range[i] = min;
</code></pre>

<p>This is wrong. <code>[]</code> does dereference the pointer, so you have three levels of dereferencing here. But it's only a <em>pointer to pointer</em>, not <em>pointer to pointer to pointer</em>. Also, indexing precedes the normal dereference, not what you want. Use <code>(*range)[i]</code> instead.</p>

<pre><code>        i++;
        min++;
    }
}
</code></pre>

<p>A sensible implementation could look like this:</p>

<pre><code>size_t double_min_max(int **range, int min, int max)
{
    // check for valid input
    if (min &gt; max) return 0;

    // calculate required size
    size_t size = max - min + 1;

    *range = malloc(size * sizeof **range);

    // check allocation succeeded:
    if (!*range) return 0;

    for (size_t i = 0; i &lt; size; ++i)
    {
        (*range)[i] = min++;
    }
    return size;
}
</code></pre>

<p>Call it like this:</p>

<pre><code>int *range;
size_t result = double_min_max(&amp;range, 10, 20);

// result should now be 11, the size of the array `range` points to

// when done:
free(range);
</code></pre>
",0
45712797,45712052,0,"<p>With <code>**range = malloc...</code>, you actually access/assign the first integer value to which the ""pointer to pointer to int"" (this is what <code>int **range</code> denotes) points. 
This should be <code>*range = malloc...</code> instead. Further, <code>**range[i]</code> is illegal, as <code>**range</code> is an integer value, not an array or pointer, such that the  <code>**range[i]=min</code> dereferences an integer value (which in this context is illegal/undefined behaviour). It should rather be <code>*range[i]=min</code>.</p>

<p>So the complete code including some necessary checks, the use of the function and also the use of the result could look as follows:</p>

<pre><code>int double_min_max(int **range, int min, int max) {

    // range is a pointer PPI to a pointer PI pointing to one (or more consecutive) integers I
    // *range is the ""value"" of PI, i.e. the pointer to the memory block representing the sequence of integers

    if (min &gt;= max)  // check if the range is valid
        return 0;

    if (!range) // check if you may assign a value to *range
        return 0;

    int size = max - min;
    int *intArray = malloc(size * sizeof(int));
    if (!intArray) // did malloc fail?
        return 0;

    // fill the range
    for (int i=0; i&lt;size; i++) {
        intArray[i] = min+i;
    }

    // let *range point to the malloced and filled array
    *range = intArray;

    // return the size of the array.
    return size;
}

int main() {

    int *myRange = NULL;
    int size = double_min_max(&amp;myRange, -30, -10);

    if (size &amp;&amp; myRange) {
        for (int i=0; i&lt;size; i++) {
            printf(""%d "", myRange[i]);
        }
        free(myRange);
    }
    return 0;
}
</code></pre>
",2
45660985,45660876,2,"<p>Assigment direction is from right to left</p>

<p>So in this expression</p>

<pre><code>deck[i] = rand()%52 + 1;
</code></pre>

<ul>
<li>First is called function <code>rand()</code></li>
<li>Then the result of function <code>%52</code></li>
<li>Then <code>1</code> is added</li>
<li>And finnally its assigned to <code>deck[i]</code></li>
</ul>

<hr>

<p><strong>Array</strong> (what you have in main) is</p>

<pre><code>  0   1   2   3   4
+---+---+---+---+---+
| 0 | 0 | 0 | 0 | 0 |
+---+---+---+---+---+
  ^-------------------------- arr[0]
</code></pre>

<p>While <strong>Array of pointers</strong> (what your function expects) is</p>

<pre><code>      0   1   2   3   4
    +---+---+---+---+---+
    | 0 | 0 | 0 | 0 | 0 |    0
    +---+---+---+---+---+
------^
|   +---+---+---+---+---+
|   | 0 | 0 | 0 | 0 | 0 |    1
|   +---+---+---+---+---+
|   +---+---+---+---+---+
|   | 0 | 0 | 0 | 0 | 0 |    2
|   +---+---+---+---+---+
|
----------------------------- arr[0][0]
</code></pre>

<p>When array is passed to function, then <code>arr[]</code> and <code>*arr</code> are the same. But only as function arguments!</p>

<hr>

<ol start=""3"">
<li><code>%53</code> returns <code>0-52</code>,so if you need <code>1-52</code>, use <code>%52 + 1</code> (<code>0-51</code> + <code>1</code> = <code>1-52</code>)</li>
</ol>

<hr>

<p>If you cant solve it, here is code with fixed bugs.</p>

<pre><code>void shuffleDeck(int deck[]) {
    int i;
    for(i=0;i&lt;=52;i++)
       deck[i] = rand()%52 + 1;
}
int main() {
    srand(time(NULL));

    int deck[2000];

    shuffleDeck(deck);

    int i;
    for(i=0;i&lt;=52;i++){
        printf(""%d"", deck[i]);
    }

    return 0;
}
</code></pre>
",5
45722467,45722432,2,"<p>You have to change</p>

<pre><code>scanf(""%c"",&amp;n);
</code></pre>

<p>to</p>

<pre><code>scanf("" %c"",&amp;n); // Skip leading whitespaces
</code></pre>

<hr>

<p>Arrays in C are passed by pointer, so for</p>

<pre><code>char name2[10];
</code></pre>

<p>You dont have to use reference operator</p>

<pre><code>scanf(""%s"",&amp;name2);
</code></pre>

<p>just simply do</p>

<pre><code>scanf(""%s"",name2);  // Will pass an arrays address
</code></pre>

<p>Also it would be nice to limit input, or buffer overflow may occur and it would lead to undefined behavior</p>

<pre><code>scanf(""%9s"",name2);
</code></pre>
",0
43734935,43726810,0,"<p>The recursive function can be written the following way as it is shown in the demonstrative program below. All you need to do is to supply a file name, open the file and pass the pointer to the file in the function. In the demonstrative program there is used <code>stdin</code> as the function argument.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

void pyramid( FILE *f, unsigned int n )
{
    static int width = 0;

    if ( n )
    {
        ++width;
        pyramid( f, n - 1 );

        for ( unsigned int i = 0; i &lt; 2 * n - 1; i++ )
        {
            fprintf( f, ""%*c"", i == 0 ? width : 1, '*' );
        }

        fputc( '\n', f );

        --width;
    }
}

int main(void) 
{
    while ( true )
    {
        printf( ""Enter a non-negative number (0 - exit): "" );

        unsigned int n;

        if ( scanf( ""%u"", &amp;n ) != 1 || n == 0 ) break;

        putchar( '\n' );

        pyramid( stdout, n );

        putchar( '\n' );
    }

    return 0;
}
</code></pre>

<p>The program output might look like</p>

<pre><code>Enter a non-negative number (0 - exit): 5

    *
   ***
  *****
 *******
*********

Enter a non-negative number (0 - exit): 4

   *
  ***
 *****
*******

Enter a non-negative number (0 - exit): 3

  *
 ***
*****

Enter a non-negative number (0 - exit): 2

 *
***

Enter a non-negative number (0 - exit): 1

*

Enter a non-negative number (0 - exit): 0
</code></pre>
",0
44231484,44231404,1,"<p>The Argument should be a matrix rather than an integer variable i suppose </p>

<pre><code>printf(""Mode = %d "", mode(a,n));
</code></pre>
",0
43976026,43975070,0,"<p>Try something like that : </p>

<pre><code>int main()
{
    int count = 0;
    while(getchar() != '\t') // If tab is entered we break
    {
       count++; // iterate
       printf(""%d\n"", count); // print counter
   }
   return 0;
}
</code></pre>

<p>Console will stop asking for input when you'll input a tab. But the prints will only be printed when the loop is exited.</p>

<p>EDIT : </p>

<p>I think Ideone has a particular way to handle EOF. It seems like Ideone aumatically puts EOF when it has computed everything in the output text area. I found no way to reproduce EOF manually, even by writing <code>\n</code>. However using a character as a way to exit the loop seems to work correctly.      </p>

<p>I don't know if it can help you, but I found this in Ideone's FAQ.</p>

<p><a href=""https://i.stack.imgur.com/NjlHn.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/NjlHn.png"" alt=""enter image description here""></a></p>
",6
43975829,43975070,0,"<p>As explained in the comment section you can not reach <code>EOF</code> by pressing the enter.
One way to get out of the while loop is that you write some <code>if</code> statement with a <code>break</code> as following example when you press <code>space</code> it will go out of the loop.
The other way is just press <code>Ctrl + d</code> to get out of the loop. </p>

<pre><code>int main(){
 int count=0;
    while(getchar()!=EOF){
       count++;
    if(getchar() == ' '){
      break;
      }
    printf(""%d"",count);
   }
return 0;
}
</code></pre>
",3
43978432,43975070,1,"<p>The <code>getchar()</code> function returns <code>EOF</code> <strong>when input fails</strong>.  It does not mean that it read an ""EOF character"" or something like that.  You should not think of EOF as meaning ""end-of-file"" in this context.</p>

<p>When you ran the program from Code::Blocks, you never did anything to cause input to fail. So input never failed, so your loop conditional was always true.</p>

<p>When ideone runs the program, it uses the input you supplied when you ran the program as input.  When that input has all been processed, trying to get more input fails and therefore the loop breaks.</p>
",0
44708403,44708193,1,"<p><code>typedef</code> is used to create an alias to another type (existing or defined in the same <code>typedef</code> statement).</p>

<p>Its general format is:</p>

<pre><code>typedef existing_or_new_type alias;
</code></pre>

<p>The aliased type in your <code>typedef</code> is the new <code>struct MapItem</code> defined in the <code>typedef</code> statement but the alias is missing. This is the cause of the error.</p>

<p>You can use:</p>

<pre><code>typedef struct MapItem {
    int item;
    int count;
} MapItem;
</code></pre>

<p>This statement declares the new type <code>struct MapItem</code> (the <code>struct</code> keyword is part of the type name) and the new type <code>MapItem</code> that is an alias of <code>struct MapItem</code>. This means that everywhere you can or have to use <code>struct MapItem</code> you can use <code>MapItem</code> instead.</p>

<p>If this seems confusing, you can use different names for the <code>struct</code> type and its alias. Or you can omit the name from the <code>struct</code> definition at all:</p>

<pre><code>typedef struct {
    int item;
    int count;
} MapItem;
</code></pre>

<p>This way, <code>MapItem</code> is the name of an anonymous <code>struct</code> type and it is the only way to declare variables of this type.</p>
",0
44708339,44708193,1,"<p>Your typedef are incorrect.  The syntax is:</p>

<pre><code>typedef type typealias ;
</code></pre>

<p>So:</p>

<pre><code>typedef struct 
{
    int item;
    int count;
} MapItem;

typedef struct
{
    MapItem item;
    int x;
    int y;
    int tile;
    Direction dir;
    int drop;
} MapTile;
</code></pre>

<p>Note that <em>types</em> being aliased here are <em>anonymous structs</em>, the struct-tag is only required for self-referencing structs.</p>
",0
43768855,43768747,5,"<p>The <code>*</code> in <code>scanf (""%*[^\n]"", first_line);</code> tells <code>scanf</code> to scan but not store the scanned string.</p>

<p>In your case, you only have one argument, which is not set because of this.</p>

<p>Note that <code>-Wall</code> (or <code>-Wformat-extra-args</code>) issues a warning on ""recent"" <code>gcc</code> compilers:</p>

<pre><code>test.c: In function 'main':
test.c:6:8: warning: too many arguments for format [-Wformat-extra-args]
 scanf (""%*[^\n]"", first_line);
        ^~~~~~~~~
</code></pre>

<p>That works fine:</p>

<pre><code> scanf (""%[^\n]"", first_line);
 printf(""%s\n"",first_line);
</code></pre>

<p>and you can even limit the size to read (making <code>scanf</code> safer) like this:</p>

<pre><code>char first_line[10] = {0};
scanf (""%9[^\n]"", first_line);
</code></pre>

<p>so even if user enters more than 9 characters, you don't overflow your buffer</p>

<p>Note however that if no characters are present on the line before the <code>\n</code>, <code>scanf()</code> will fail to match the <code>%[^\n]</code> conversion specification and return <code>0</code> without consuming any byte from standard input.  For this reason, it is much more advisable to use <code>fgets()</code> for your purpose:</p>

<pre><code>char line[100];

if (fgets(line, sizeof line, stdin)) {
    /* a line was read from standard input */
    /* you can strip the newline character with this simple one liner */
    line[strcspn(line, ""\n"")] = '\0';
    printf(""%s\n"", line);
}
</code></pre>
",1
43768855,43768747,5,"<p>The <code>*</code> in <code>scanf (""%*[^\n]"", first_line);</code> tells <code>scanf</code> to scan but not store the scanned string.</p>

<p>In your case, you only have one argument, which is not set because of this.</p>

<p>Note that <code>-Wall</code> (or <code>-Wformat-extra-args</code>) issues a warning on ""recent"" <code>gcc</code> compilers:</p>

<pre><code>test.c: In function 'main':
test.c:6:8: warning: too many arguments for format [-Wformat-extra-args]
 scanf (""%*[^\n]"", first_line);
        ^~~~~~~~~
</code></pre>

<p>That works fine:</p>

<pre><code> scanf (""%[^\n]"", first_line);
 printf(""%s\n"",first_line);
</code></pre>

<p>and you can even limit the size to read (making <code>scanf</code> safer) like this:</p>

<pre><code>char first_line[10] = {0};
scanf (""%9[^\n]"", first_line);
</code></pre>

<p>so even if user enters more than 9 characters, you don't overflow your buffer</p>

<p>Note however that if no characters are present on the line before the <code>\n</code>, <code>scanf()</code> will fail to match the <code>%[^\n]</code> conversion specification and return <code>0</code> without consuming any byte from standard input.  For this reason, it is much more advisable to use <code>fgets()</code> for your purpose:</p>

<pre><code>char line[100];

if (fgets(line, sizeof line, stdin)) {
    /* a line was read from standard input */
    /* you can strip the newline character with this simple one liner */
    line[strcspn(line, ""\n"")] = '\0';
    printf(""%s\n"", line);
}
</code></pre>
",1
43768868,43768747,2,"<pre><code> scanf (""%*[^\n]"", first_line);
</code></pre>

<p>This code will discard all the characters until <code>\n</code> is encountered. So you are not storing any value in your <code>first_line</code> variable.</p>

<p>Don't use <code>scanf</code> for reading character array or strings. Instead you can use <code>fgets</code>.</p>

<p><a href=""https://stackoverflow.com/questions/2430303/disadvantages-of-scanf"">Disadvantages of scanf</a></p>

<pre><code>char first_line[80];
while(fgets(first_line, 80, stdin)) {
    printf(""%s"",first_line);
}
</code></pre>

<p>Where 80 is size of your <code>first_line</code> character array.</p>
",4
43944401,43944122,0,"<pre><code>    while(read(simpleChildSocket, buff, 256)) {
</code></pre>

<p>The number of bytes that was read from the stream was returned by the <code>read</code> function. You should store it somewhere so you can access it later.</p>

<p>Generally, you have two choices for how to tell how many bytes are in a buffer:</p>

<p>1) Just store the number of bytes in a separate integer.</p>

<p>2) If your data is a text string, terminate the text string with a zero byte and then you call <code>strlen</code> any time you need to know its length.</p>
",2
43946716,43944122,-1,"<p>I do not know if I got it!</p>
<p>If I understood, are you sending the size of data and the data separeted by space character?</p>
<p>example: &quot;3 123&quot;
3 = length and 123 = data</p>
<pre><code>     //server side
     int received;
     /*while(read(simpleChildSocket, buff, 256))*/ 
   
     do{
         received = read(simpleChildSocket, buff, 256);
         if ( received &gt; 0 ) 
             printf(&quot;Data received: %s\n&quot;, buff);
         else if ( received == 0 )
         {
             printf(&quot;Connection closed\n&quot;);
             break;
         }
         else
         {
             printf(&quot;recv failed -1\n&quot;);
             break;
         }
         /*int receved=strlen(buff);*/
         char bufftmp[256]={0};
         /*Loop through the buffer until you find space*/
         for(int k=0;k&lt;received;k++)
         { 
             bufftmp[k]=buff[k];
             if(buff[k]==' ')/*is equal space?*/
             {
                 bufftmp[k]='\0';//make space null
                 int numpart=atoi(bufftmp);
                 printf(&quot;lenght of message is: %d\n&quot;,numpart);/*get only length*/
                 break;
             } 
         } 
         bzero(buff, 256);

     }while(received&gt;0)
</code></pre>
",1
43928575,43896750,-1,"<p>Finally I have to manually add the following declaration ahead of int main£¬then it is compiled perfectly£¡£¡</p>

<pre><code>FILE *open_memstream(char **, size_t *);
</code></pre>

<p>So the solution of Jean-Fran?ois is right, but why this would only result in such warning without impacting on the final compiling and running£¡£¿</p>
",1
43928893,43896750,1,"<p>You're getting a warning:</p>

<pre class=""lang-none prettyprint-override""><code>Initialization between types ""struct {...}*"" and ""int"" is not allowed.
</code></pre>

<p>on this line:</p>

<pre><code>FILE *om = open_memstream(&amp;ls_sh, &amp;len);
</code></pre>

<p>First problem: the <code>open_memstream</code> is not a standard C library function. It's defined by some versions of POSIX. The man page on my Linux system (Ubuntu 16.10) says:</p>

<blockquote>
  <p>CONFORMING TO<br>
         POSIX.1-2008.  These functions are not specified in POSIX.1-2001, and are not widely available on other systems.</p>
</blockquote>

<p>You might be trying to compile code written for another system (one that provides <code>open_memstream</code> on a different system (one that doesn't provide <code>open_memstream</code>). Or it might be available on your system, but you haven't provided whatever incantation is needed to make it visible. A conforming ISO C implementation is forbidden to define functions in standard headers other than the ones defined by the C standard (unless they use reserved names, which doesn't apply here), but typically there's a way to request conformance to POSIX rather than just to ISO C. If that's the case, the man page on your system should tell you what you need to do: <code>man open_memstream</code>. You might need to define a macro or pass a command-line argument to the compiler.</p>

<p>(This all might have been simpler if all POSIX-specific functions were declared in separate headers rather than sharing the C-standard ones line <code>&lt;stdio.h&gt;</code>, but there are historical reasons why that wasn't done.)</p>

<p>Second problem: You've also asked why you only get a warning. Prior to the 1999 ISO C standard, it was legal to call an undeclared function. The compiler would create an implicit declaration, assuming that the function takes whatever arguments you've passed it and returns a result of type <code>int</code>. If the actual function doesn't match that assumption, the behavior is undefined. The 1999 standard dropped this ""implicit <code>int</code>"" rule, making a call to an undeclared function a <em>constraint violation</em>. But compilers aren't required to reject code that violates such a rule; printing a warning and continuing to compile is valid. Which means that you should take all warnings from your C compiler <em>very</em> seriously.</p>

<p>(If your system doesn't have <code>open_memstream</code>, you might look for <code>fmemopen</code>, which appears to be similar. It's also defined by POSIX and not by ISO C, so the same considerations apply.)</p>

<p><strong>UPDATE</strong> :</p>

<p>Since you're using <code>xlC</code>, I presume you're on an AIX system. Here's the <a href=""https://www.ibm.com/support/knowledgecenter/en/ssw_aix_72/com.ibm.aix.basetrf1/open_memstream.htm"" rel=""nofollow noreferrer"">man page for <code>open_memstream</code> on AIX</a>.</p>

<p>I see there are no instructions for enabling symbols that aren't defined by ISO C. The man page includes an example. Here's a stripped-down version that should compile with out error:</p>

<pre><code>#include &lt;stdio.h&gt;
int main(void) {
    char *buf;
    size_t len;
    FILE *f = open_memstream(&amp;buf, &amp;len);
}
</code></pre>

<p>Please try compiling this example. If you get a complaint about <code>open_memstream</code>, most likely you're using some restrictive command-line option (try compiling with just <code>xlc c.c</code>) <em>or</em> you've hacked your <code>stdio.h</code>. If the latter, restore that header file to its original contents. If you didn't save a backup of the original, you <em>really</em> need to stop messing around with your system.</p>

<p>Also, if I recall correctly, <code>xlC</code> is the C++ compiler; the C compiler is <code>xlc</code>.</p>
",13
43925810,43896750,0,"<p>there are a few problems with the posted code.</p>

<ol>
<li><p>the parameter <code>argc</code> should always be checked to assure the command line argument(s) actually exist.  The compiler outputs a warning about the parameter not being used</p></li>
<li><p>the call to <code>open_memstream()</code> should have the returned value checked (!=NULL) and if NULL, then call <code>perror()</code> so the proper error message is passed to <code>stderr</code>, including the text of why the system thinks the call failed.</p></li>
</ol>

<p>So, other than not using the passed parameter <code>argc</code> and not checking the returned value from <code>open_memstream()</code> the program compiles and runs with no problems.</p>

<p>Note the warning about <code>argc</code> can be fixed by having the following as the first statement in the body of <code>main()</code>:</p>

<pre><code>(void)argc;
</code></pre>

<p>Also, it is a poor programming practice to include header files those contents are not used.  I.E. remove this statement:</p>

<pre><code>#include &lt;unistd.h&gt;
</code></pre>

<p>however, the root of YOUR problem is that the xlC compiler has a bug regarding initialization of arrays.  This discussed at: <code>https://stat.ethz.ch/pipermail/r-sig-mac/2003-October/001009.html</code></p>
",0
44354185,44354155,-1,"<p>when you use <code>malloc</code> the allocation is not guaranteed. </p>

<p><code>block = (char *)malloc(sizeof(10485760));</code>is <em>trying</em> to allocate space for <em>10485760</em> which is an <code>int</code> - meaning 4/8 bytes on 32/64-bit machine. <code>""random_string""</code> is longer then that, hence your error</p>
",1
44354206,44354155,3,"<pre><code>block = (char *)malloc(sizeof(10485760));
</code></pre>

<p>is allocating only sizeof(int) number of bytes, when you access memory beyond that its will end up accessing invalid memory and program might crash</p>
",0
47538045,47537950,3,"<p>You can't write <em>portably</em> variadic functions without <code>va_list</code>.</p>

<p>The <code>va_start</code>, <code>va_arg</code>, <code>va_end</code> macros translate to compiler magic (e.g. compiler builtin).</p>

<p>Because they are tied to the <a href=""https://en.wikipedia.org/wiki/Application_binary_interface"" rel=""nofollow noreferrer"">ABI</a> conventions (see also x86 ABI <a href=""https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI"" rel=""nofollow noreferrer"">list</a>, which you might want to follow for your homework).</p>

<p>For example my <code>/usr/lib/gcc/x86_64-linux-gnu/7/include/stdarg.h</code> contains:</p>

<pre><code>  #define va_start(v,l) __builtin_va_start(v,l)
</code></pre>
",0
46108704,46108574,0,"<p>I believe you  need <a href=""http://%20%20%20%20%20https://msdn.microsoft.com/en-us/library/t58y75c0(v=vs.140).aspx"" rel=""nofollow noreferrer"">ConvertStringToBSTR</a></p>

<pre><code>// ConvertStringToBSTR.cpp  
#include &lt;comutil.h&gt;  
#include &lt;stdio.h&gt;  

#pragma comment(lib, ""comsuppw.lib"")  
#pragma comment(lib, ""kernel32.lib"")  

int main() {  
   char* lpszText = ""Test"";  
   printf_s(""char * text: %s\n"", lpszText);  

   BSTR bstrText = _com_util::ConvertStringToBSTR(lpszText);  
   wprintf_s(L""BSTR text: %s\n"", bstrText);  

   SysFreeString(bstrText);  
}  
</code></pre>
",1
43768013,43767727,3,"<p>The character <code>|</code> is not correct bitwise or operator. Search for this <code>|</code>  in your keyboard.
This code compiles well in my machine with <code>|</code>.</p>

<pre><code>#include ""stdio.h""
int main(int argc, char const *argv[]) {
    int x, y , z;
    x = 0xffff;
    y = 0x8888;
    z = x | y;
    printf(""0x%u \n"",z );
    return 0;
}
</code></pre>
",0
43768107,43767727,1,"<p>If you can't find the proper character (<code>|</code> vs <code>|</code>), use the <a href=""http://port70.net/~nsz/c/c11/n1570.html#5.2.1.1"" rel=""nofollow noreferrer"">trigraph</a> <code>??!</code>.</p>

<p>Your line would look like this</p>

<pre><code>z = x ??! y;
</code></pre>
",3
43767879,43767727,1,"<p>You are using the wrong character. 
You should use:     <code>|</code></p>

<p>So, your code should look like this: </p>

<pre><code>#include ""stdio.h"" 

int main(int argc, char const *argv[])
{ 
     int x, y, z; 
     x = 0xffff; 
     y = 0x8888; 
     z = x | y; 
     printf(""0x%u \n"", z); 
     return 0; 
}
</code></pre>
",4
43768013,43767727,3,"<p>The character <code>|</code> is not correct bitwise or operator. Search for this <code>|</code>  in your keyboard.
This code compiles well in my machine with <code>|</code>.</p>

<pre><code>#include ""stdio.h""
int main(int argc, char const *argv[]) {
    int x, y , z;
    x = 0xffff;
    y = 0x8888;
    z = x | y;
    printf(""0x%u \n"",z );
    return 0;
}
</code></pre>
",0
43768107,43767727,1,"<p>If you can't find the proper character (<code>|</code> vs <code>|</code>), use the <a href=""http://port70.net/~nsz/c/c11/n1570.html#5.2.1.1"" rel=""nofollow noreferrer"">trigraph</a> <code>??!</code>.</p>

<p>Your line would look like this</p>

<pre><code>z = x ??! y;
</code></pre>
",3
46656780,46656741,1,"<p>Every time you call <code>operations</code>, you could get a different result. You need to compare against <code>d</code> in your conditions, not against <code>operator</code>. You have a similar issue in <code>createQuestion</code>, where what is passed to <code>checkQuestion</code> is probably not what was shown to the user.</p>

<p>For example:</p>

<pre><code>if (d == '+') {
  // ...
}
</code></pre>
",2
46656925,46656741,0,"<p>One weird thing is, you have a function that returns a char:</p>

<pre><code>**char** operations(void){
  etc...
}
</code></pre>

<p>then you put it in a function that expects a float:</p>

<pre><code>checkQuestion(integers(), integers(), **operations()**, answer);
void checkQuestion(float a, float b, **float c**, char d)
</code></pre>
",1
46035684,46033487,0,"<p>First, there is something wrong with your <code>insert()</code> signature
(as already pointed by @MichaelWalz )</p>

<p>you'd rather</p>

<pre><code>node_t* insert(node_t** pNode, char* word, int weight);
</code></pre>

<p>and then</p>

<pre><code>insert(&amp;root,""cute"",4);
</code></pre>

<p>why don't you start fixing this and edit your post ?</p>
",0
46037868,46033487,1,"<p>Some improvements of your code</p>

<ul>
<li><code>insert()</code> must have first parameter to be <code>node_t **</code> (see comments)</li>
<li><code>char *data</code> must be <code>char data</code>, because every node contains only one char</li>
<li><code>weight</code> can be calculated when the list is filled up</li>
</ul>

<p>Here is corrected version of your code. Function <code>get()</code> is used to find the key in the filled up list (for testing).</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

typedef struct node {
    char data;
    int weight;
    struct node * left;
    struct node * equal;
    struct node * right;
} node_t;

void insert(node_t** pNode, char* word, int weight)
{
    char data;
    node_t **pNext;
    node_t *pCurrent;

    if (word == NULL)
    {
        return ;
    }

    data = word[weight];

    if (*pNode == NULL)
    {
        *pNode = malloc(sizeof(node_t));
        pCurrent = *pNode;
        memset(pCurrent, 0, sizeof(node_t));
        pCurrent-&gt;data = data;
    }
    else
    {
        pCurrent = *pNode;
    }

    if (data == pCurrent-&gt;data)
    {
        weight ++;
        if (strlen(word) == weight)
        {
            pCurrent-&gt;weight = weight;
            return;
        }

        pNext = &amp;pCurrent-&gt;equal;
    }
    else if (data &gt; pCurrent-&gt;data)
    {
        pNext = &amp;pCurrent-&gt;right;
    }
    else
    {
        pNext = &amp;pCurrent-&gt;left;
    }

    insert(pNext, word, weight);
}

int get(node_t** pNode, char *word, int weight)
{
    char data;
    node_t **pNext;
    node_t *pCurrent;

    if (word == NULL)
    {
        return 0;
    }

    data = word[weight];

    if (*pNode == NULL)
    {
        return 0; // not found
    }

    pCurrent = *pNode;

    if (data == pCurrent-&gt;data)
    {
        weight ++;

        if (strlen(word) == weight)
        {
            return pCurrent-&gt;weight;
        }

        pNext = &amp;pCurrent-&gt;equal;
    }
    else if (data &gt; pCurrent-&gt;data)
    {
        pNext = &amp;pCurrent-&gt;right;
    }
    else
    {
        pNext = &amp;pCurrent-&gt;left;
    }

    return get(pNext, word, weight);
}

int main()
{
    node_t * root = NULL;

    insert(&amp;root, ""cat"", 0);
    insert(&amp;root, ""at"", 0);
    insert(&amp;root, ""cute"", 0);

    printf(""cat=%d\n"",get(&amp;root,""cat"",0)); // cat=3
    printf(""at=%d\n"",get(&amp;root,""at"",0)); // at=2
    printf(""cute=%d\n"",get(&amp;root,""cute"",0)); // cute=4

    // todo: free memory

    return 0;
}
</code></pre>

<p>The code is tested except freeing the memory.</p>
",0
46936239,46935755,1,"<p>This Code calls function recursively to list the files and directories.</p>

<pre><code>#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;dirent.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void) {
    listdir(""."", 0);       //Call the function for the current path
}

/* Function to list files and directories
 * @parameter Name : Name is the path
 * @parameter indent: indentation for printing the files and directories 
                      in the hierarchical structure
 */
void listdir(const char *name, int indent)
{
    DIR *dir;
    struct dirent *entry;

    /* Base Case, return if the current file is not directory */
    if (!(dir = opendir(name)))
        return;

    /*Loop for all the files in the current directory */
    while ((entry = readdir(dir)) != NULL) {
        if (entry-&gt;d_type == DT_DIR) {
            char path[1024];

            /* If the path is . (current path) or .. (parent of the current 
              directory) then continue (do not call  lisdir()), 
              we don't want to stuck in infinite situation!
            */
            if (strcmp(entry-&gt;d_name, ""."") == 0 || strcmp(entry-&gt;d_name, "".."") == 0)
                continue;
            snprintf(path, sizeof(path), ""%s/%s"", name, entry-&gt;d_name);
            printf(""%*s[%s]\n"", indent, """", entry-&gt;d_name);

            /* Call the function again for the current path
               Add 2 to indentation, that is to leave 2 more spaces in the 
               hierarchical structure 
            */
            listdir(path, indent + 2);
        } else {
            printf(""%*s- %s\n"", indent, """", entry-&gt;d_name);
        }
    }
    closedir(dir);
}
</code></pre>
",0
46107330,46107259,0,"<p>You will want to start a child process, then <em>redirect</em> its <code>stdout</code> to your own process' output, and its <code>stdin</code> to your own process' input - but presumably you'll want to intercept certain keystrokes to allow a user to terminate the child process without killing your own.</p>
<p>In a POSIX environment you would use <code>popen()</code> which gives you a pipe for redirecting input and output. On Windows you would use <code>CreatePipe</code> instead. Windows does not implement the POSIX <code>popen()</code> but it does have an internal function <code>_popen</code> but I understand it has different semantics.</p>
<p>But there is no function or capability in the C Standard Library to pipe between processes (C itself doesn't even require the computer to support a concept of a &quot;process&quot; either - it's a surprisingly platform-agnostic language and library - you can even use it for a platform without a <code>malloc</code> implementation).</p>
<p>Anyway, if you're okay with targeting just Windows, or for writing a wrapper library, I recommend you read this MSDN article which describes <em>exactly</em> what you're looking to do:</p>
<p><a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/ms682499(v=vs.85).aspx"" rel=""nofollow noreferrer"">https://msdn.microsoft.com/en-us/library/windows/desktop/ms682499(v=vs.85).aspx</a></p>
<blockquote>
<h3>Creating a Child Process with Redirected Input and Output</h3>
<p>The example in this topic demonstrates how to create a child process using the CreateProcess function from a console process. It also demonstrates a technique for using anonymous pipes to redirect the child process's standard input and output handles. Note that named pipes can also be used to redirect process I/O.</p>
</blockquote>
",0
46107332,46107259,0,"<p>you can use the function system and path the program 
example : </p>

<pre><code>system (""ConsoleProgram2.exe""); // if it were in the same path
</code></pre>

<p>system() is a shell script method so you can use it as any way you want but people say that is a bad thing to use system function but in you'r case i don't see a problem.</p>
",0
44326655,44326633,5,"<p><code>#include &lt;stdint.h&gt;</code> for <a href=""http://port70.net/~nsz/c/c11/n1570.html#7.20.1.1"" rel=""nofollow noreferrer"">exact width integer types</a>!</p>

<p>What is wrong with <code>int32_t</code> and <code>uint32_t</code>? These are integer types without padding bits and exactly 32 value bits (uint32_t) or 31 value bits + a sign bit (int32_t). These are maximally portable, if they exist.</p>

<p>If however you require <em>at least</em> 32 bits, but the exact number of value bits is not specified, use <code>(u)int_least32_t</code>.</p>
",1
44357666,44357596,0,"<p>First of all, <code>y</code> is not a variable, you have to compare with the character code:</p>

<pre><code>if (ans == 'y') {...}
</code></pre>

<p>To terminate your program, use:</p>

<pre><code>exit(0);
</code></pre>
",0
44357686,44357596,1,"<p>If this is to be restricted to the <code>main()</code> method, then just return out.</p>

<pre><code> if(ans == 'y') {
     return 0;
 }
</code></pre>

<p>It is a good practice to avoid hard exits unless you really need them.</p>

<p>But if you really need to hard exit out, you may try <code>_exit(0);</code> here. <code>exit(0);</code> as well, which has already been mentioned.</p>
",0
46133192,46132650,-1,"<ol>
<li>You have to use <code>%s</code> instead of <code>%c</code>, (first one works with strings, second one with single chars).</li>
<li>change <code>printf(""%c\t"",v.name[i]);</code> to <code>printf(""%c\t"",v.name[j]);</code> because otherwise your loop wouldn't pass through all the names thus, print them out.</li>
</ol>
",0
46132900,46132650,0,"<p>%c is the format string for a char data type
for printing a string you will want to use the %s format string </p>

<pre><code># include &lt;stdio.h&gt; 

int main(){
    char name [3][20];
    printf(""Enter 3 names\n"");

    for(int i = 0; i &lt; 3; i++){
        scanf(""%s"", name[i]);
    }

    for(int i = 0; i &lt; 3; i++){
        printf(""%s\n"", name[i]);  
    }
    return 0;
}
</code></pre>
",0
44231406,44231343,3,"<p>That is not defined, so it cannot be answered in general.</p>

<p>For any specific case you can easily try it by printing out the addresses:</p>

<pre><code>printf(""x is at %p, A_two at %p and A_one at %p\n"", (void *) &amp;x,
       (void *) &amp;A_two, (void *) &amp;A_one);
</code></pre>

<p>Note that the C standard does not, for instance, require that these variables are put on a stack.</p>
",2
42502958,42502786,1,"<p>Just write it like this </p>

<pre><code>#define UUID_BASE 0xaa, 0x82, 0xe0, 0x12, 0x69, 0xa2, 0x4b, 0xe7, 0x93, 0xe4, 0x19, 0xc9, 0xb2, 0xaf
#define USER_ADVERTISE_SCAN_RESPONSE_DATA {0x10, UUID_BASE, 0x0}
</code></pre>

<p>The reason is, that apart from the terminating <code>\0</code>, the data is identical as soon as you put it into an array.</p>

<p>This code</p>

<pre><code>#define UUID_BASE 0xaa, 0x82, 0xe0, 0x12, 0x69, 0xa2, 0x4b, 0xe7, 0x93, 0xe4, 0x19, 0xc9, 0xb2, 0xaf
char dataA[] = {UUID_BASE, 0x0};
</code></pre>

<p>is completely equivalent to this code</p>

<pre><code>#define UUID_BASE_STR ""\xaa\x82\xe0\x12\x69\xa2\x4b\xe7\x93\xe4\x19\xc9\xb2\xaf""
char dataB[] = UUID_BASE_STR;
</code></pre>

<p>You can test it like this:</p>

<pre><code>#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

#define UUID_BASE_BYTES 0xaa, 0x82, 0xe0, 0x12, 0x69, 0xa2, 0x4b, 0xe7, 0x93, 0xe4, 0x19, 0xc9, 0xb2, 0xaf
#define UUID_BASE_STR ""\xaa\x82\xe0\x12\x69\xa2\x4b\xe7\x93\xe4\x19\xc9\xb2\xaf""

int main() {
    char dataA[] = {UUID_BASE_BYTES, 0x0};
    char dataB[] = UUID_BASE_STR;

    if(strcmp(dataA,dataB) == 0) {
        printf(""The strings are equal\n"");
    }
    else {
        printf(""The strings are not equal\n"");
    }
}
</code></pre>

<p>This outputs <code>The strings are equal</code></p>
",4
42559951,42544569,0,"<p>If you already know the expected number of strings and the maximum word length, use this:</p>

<pre><code>char array[45440][20];
int n;
for (n = 0; n &lt; 45440; n++) {
    if (scanf(""%19[^\n]"", array[n]) != 1)
        break;
    scanf(""%*[^\n]);  /* skip the rest of the line if any */
    scanf(""%*c);      /* skip the newline if any */
}
</code></pre>

<p>Or this simpler alternative:</p>

<pre><code>char array[45440][20];
int n, c, i;
for (n = 0; n &lt; 45440; n++) {
    for (i = 0; (c = getchar()) != EOF &amp;&amp; c != '\n';) {
        if (i &lt; 19)
            array[n][i++] = '\0';
    }
    array[n][i] = '\0';
    if (c == EOF)
        break;
}
</code></pre>
",0
43960965,43960868,1,"<p>Your code might crash (happened to me when verifying it on my machine) because you did not allocate space for <code>str</code>...
you should change <code>char *str, ch;</code> to something like <code>char *str = malloc(100), ch;</code></p>

<p>Also, change <code>scanf(""%c"", &amp;ch);</code> to <code>scanf("" %c"", &amp;ch);</code> to resolve your problem. This happens because when you enter your string, you end it with enter, and that enter is consumed by your next <code>scanf(%c)</code> and so, your second <code>scanf()</code> only reads the enter instead of reading the char you intend. <code>scanf("" %c"", &amp;ch);</code> will ignore all whitespaces, including the previously entered enter :-) and wil allow your char to be processed</p>
",2
43960998,43960868,0,"<p>Always write scanf like this, to read the previous newline character:</p>

<pre><code>printf(""\nEnter the character to be searched : "");
scanf("" %c"", &amp;ch);
</code></pre>

<p>OR</p>

<p>use <code>getchar()</code></p>

<pre><code>printf(""\nEnter the character to be searched : "");
getchar();
scanf(""%c"", &amp;ch);
</code></pre>
",0
43963345,43960868,0,"<p>Defining a max length would be the simplest way to solve this. Insted of using scanf, I would recomend using fgets as done below. It is much more failsafe since you can define the max number of characters to be read.
<a href=""https://www.tutorialspoint.com/c_standard_library/c_function_fgets.htm"" rel=""nofollow noreferrer"">Tutorialspoint's explanation of fgets</a></p>

<pre><code>#define MAX_LENGTH 100

int main() {
   char str[MAX_LENGTH], ch;
   int count = 0;

   printf(""\nEnter a string : "");
   fgets(str, MAX_LENGTH, stdin);

   printf(""\nEnter the character to be searched : "");
   scanf(""%c"", &amp;ch);

   ...

}
</code></pre>
",2
44695958,44695785,3,"<p>This:</p>

<pre><code>array[5] = atoi(argv[x+1]);
</code></pre>

<p>is clearly wrong, it always tries to assign to <code>array[5]</code> which is out of bounds. It should be:</p>

<pre><code>array[x] = atoi(argv[x + 1]);
</code></pre>

<p>This converts the <code>x + 1</code>:th argument from string format into an integer, and stores that in <code>array[x]</code>. If you're not familiar with the standard function <code>atoi()</code>, just read <a href=""https://linux.die.net/man/3/atoi"" rel=""nofollow noreferrer"">the manual page</a>.</p>

<p>So if you start the program like this:</p>

<pre><code>./myprogram 1 2 3 4 5
</code></pre>

<p>That has 6 arguments (the first is the name itself), and will end up with <code>array</code> containing the numbers one through five.</p>

<p>Then in the summing function, the first line should be something like:</p>

<pre><code>void print_count(int *array, int size)
</code></pre>

<p>so that you give names to the arguments, which makes them usable in the function. Not providing names is an error, I think.</p>

<p>And it doesn't need to ""interact"" with <code>main()</code> more than it already does; <code>main()</code> calls <code>print_count()</code>, passing it a pointer to the first element of <code>array</code> and the length of the array, that's all that's needed to compute the sum.</p>
",2
44701608,44695785,1,"<p>Your <code>print_count</code> function has a few issues:</p>

<ul>
<li><p>The loop runs one step too far: <code>i</code> should vary between <code>0</code> and <code>size-1</code> included.  The standard idiom for this loop is:</p>

<pre><code>   for (i = 0; i &lt; size; i++) {
       ...
</code></pre></li>
<li><p>Incrementing <code>sum</code> is simply done with:</p>

<pre><code>sum += array[i];
</code></pre></li>
<li><p>There is an extra <code>(</code> on the first <code>printf</code> line.</p></li>
<li>You should print a newline after the output.</li>
<li>Returning <code>0</code> from a <code>void</code> function is invalid.</li>
</ul>

<p>Here is a corrected version:</p>

<pre><code>void print_count(int *array, int size) {
    int i;
    int sum = 0;

    printf(""Elements: "");
    for (i = 0; i &lt; size; i++) {
        printf(""%d "", array[i]);
        sum += array[i]);
    }
    printf(""\nSum = %d\n"", sum);
}
</code></pre>
",2
44711747,44695785,1,"<p>the following proposed code:</p>

<ol>
<li>cleanly compiles.</li>
<li>explains what is being accomplished at each step of the 'main()' function.</li>
<li>properly outputs error messages to 'stderr'. </li>
<li>implements the typical method to announce an error in the number of command line parameters.</li>
</ol>

<p>Now the proposed code with explanatory comments:</p>

<pre><code>#include &lt;stdio.h&gt;    // printf(), fprintf()
#include &lt;stdlib.h&gt;   // atoi(), exit(), EXIT_FAILURE


void print_count(int *, int);

int main(int argc, char *argv[])
{
    if (argc != 6)
    {
        fprintf( stderr, ""USAGE: %s int1 int2 int3 int4 int5\n"", argv[0] );
        exit( EXIT_FAILURE );
    }

    // implied else, correct number of arguments

    // only declare variables when they are needed
    int array[5];

    // place each command line parameter into 'array', 
    // except program name
    // I.E. skip the program name in argv[0]
    for( int i = 1; i &lt; argc;  i++ )
    {
        // array[] index starts at 0, but loop counter starts at 1
        array[i-1] = atoi(argv[i]);
    } // end for( each value pointed at by argv[], except program name )

    // print sum of command line parameters to stdout
    int size = argc-1;  // number of command line parameters after program name
    print_count(array, size);
    return 0;
} // end function: main
</code></pre>
",0
44651718,44651311,0,"<p>you should have to return inside if because after if statement it again comes into while loop and add extra node at the end </p>

<pre><code>struct node
{
    int data; // node format
    struct node* next;
};

void insertAtEnd(struct node** headRef, int newData)
{
    struct node* ptr;
    struct node* newnode;
    ptr = (*headRef);
    newnode = (struct node*)malloc(sizeof(struct node));
    newnode-&gt;data = newData;
    newnode-&gt;next = NULL;
    if (*headRef == NULL)
    {
        *headRef = newnode;
         return;

    }
    while (ptr-&gt;next != NULL)
    {
        ptr = ptr-&gt;next;
    }
    ptr-&gt;next = newnode;
    return;
}
</code></pre>
",0
45223846,45223807,2,"<p>On a Unix-like system, if you type CTRL-D at the start of a line in the console, that's equivalent to EOF (the condition in your while loop).  If you're on Windows, use CTRL-Z instead.</p>
",1
44353100,44346258,0,"<p>I changed your program to</p>

<pre><code>#include &lt;stdio.h&gt;

int main() {
  int n;
  printf(""%d\n"", n);
  scanf(""%d"", &amp;n);
  printf(""%d\n"", n);
}
</code></pre>

<p>When I run it with the input ""a"", it prints</p>

<pre><code>32767
32767
</code></pre>

<p>So whatever is causing <code>n</code> to start out with the bit pattern for 32767, it is <em>not</em> anything that <code>scanf</code> is doing.</p>

<p>At one level this is interesting, perhaps even fascinating: despite the fact I'm using a very different system (clang-600.0.57 under MacOS 10.9.5), I got a remarkably similar result.  But no matter how intriguing this is, I'm not going to waste time trying to figure out why, because it'd be hard, and it wouldn't teach me anything useful about writing proper programs.  It's just some random, meaningless coincidence.</p>
",0
46626713,46626561,1,"<p>Since you're passing in both <code>int</code> and <code>string</code> inputs to <code>snprintf()</code> and <code>sprintf()</code>, you need to change <code>""%s %s %s %s %s %s""</code> to <code>""%s %s %d %d %d %s""</code> in order to properly handle <code>int</code> values.</p>
",6
46626714,46626561,1,"<p><code>allClients[i]-&gt;port</code> (and some other variables) look like integers. You cannot print them with <code>%s</code>; that is for strings. What happens is that the <code>%s</code> format makes the <code>sprintf</code> read the memory behind the adress that the <code>int</code> contains, 0x000010e2, as 0x10e2 = 4322, and then continue reading from there until it finds a <code>¡¯\0¡¯</code>, as it thinks it is processing a string. This is undefined behavior.</p>

<p>Use <code>%d</code> instead, or <code>%ld</code> if it is a long int, etc.</p>
",0
44329423,44329331,2,"<p>Remove the <code>\n</code> from the end of your <code>scanf()</code> format.  Any run of one or more whitespace characters (e.g. spaces, tabs, newlines, ...) in the format matches a run of any number of the same.  Thus, your <code>scanf()</code> keeps matching whitespace -- as many newlines as you choose to enter, for example -- until it sees the next <em>non</em>-whitespace character.</p>
",0
44329454,44329331,0,"<p>The <code>\n</code> in <code>scanf(""%f\n"",&amp;age3);</code> is causing the problem. remove the <code>\n</code>. refer <a href=""https://stackoverflow.com/questions/15443483/using-n-in-scanf-in-c"">Using &quot;\n&quot; in scanf() in C</a> </p>
",0
44329538,44329331,0,"<p><code>scanf(""%f"",&amp;age3);</code>

Try with this</p>
",0
44364528,44362348,0,"<p>I could not reproduce the segfault (probably because of being ""lucky"" or maybe because of having wrong input).<br>
The problem I did have was wrong sorting and strange values in sorted output, I believe that the same problem causes all misbehaviours, including the segfault in your case.</p>

<p>Here is a commented version of your code, picking up from the excellent comments and adding the (many) necessary changes to work on strings instead of integers.<br>
<em>(Allow me this little rant: It would really have saved a lot of time to provide actual sample input from start.)</em><br>
It does have no segfault (at least not for me), no missorting and no strange values.
Output (i.e. new content of input file):  </p>

<pre><code>Damro
Duriyan
Evoks
Godrej
Luxxe
Nilkamal
Wipro
Zuari
</code></pre>

<p>Code:</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;

typedef char brandname[20];

void sort(brandname *sorted, int count, brandname *value){
    int i=0;
    strncpy((char*)sorted[count], (char*)value, sizeof(brandname));
    if(count == 0) return;

    // picking up input by BLUEPIXY;
    // this probably prevents the segfault,
    // it definitly prevents strange values
    // appearing in the sorted result
    for(i=count;i&gt;0;i--)
    {
        if(0&gt;strncmp((char*)value, (char*)sorted[i-1],sizeof(brandname)))
            strncpy( (char*)sorted[i], (char*)sorted[i-1], sizeof(brandname));
            else break;
    }
    strncpy((char*)sorted[i], (char*)value, sizeof(brandname));
}
int main(int argc,char *argv[]){
    FILE *fp = NULL;
    brandname sorted[1024];
    brandname value;
    int count = 0;
    int i=0;
    fp = fopen(""brandlist.txt"",""r+"");
    //fp = fopen(""brandlist.txt"",""w"");
    if(NULL == fp){
        perror(""fopen"");
        exit(0);
    }
    // picking up input from cooments on feof
    // but also use the increasing ""count""
    // instead of unchanging ""i""
    while(1==fscanf(fp,""%s"", value))
    {
        // use the read value inside ""sorted[count]""
        sort(sorted, count, &amp;value);
        ++count;
    }
    // do not append sorted to input
    rewind(fp);
    for(i=0;i&lt;count;i++){
        fprintf(fp,""%s\n"",sorted[i]);
    }

    if(fp){
        fclose(fp);
        fp = NULL;
    }

    // avoid a warning
    return 0;
}
</code></pre>
",10
42596891,42596776,0,"<pre><code>    #include &lt;stdio.h&gt;
    #include &lt;stdlib.h&gt;

    // conversion of decimal to octal
    int main()
    {
        int num,i,len=0,x[100];
        printf(""enter a number\t"");
        scanf(""%d"",&amp;num);

        while (num&gt;0){
            x[len]=num%8;
            num=num/8;
            len++;
        }
        for(i=len;i&gt;=0;i--)
            printf(""\n%d"",x[i]);
        return 0;
   }
</code></pre>

<p>This will work for the conversion from decimal to octal.</p>

<p>Note: Check the logic works!.Make the sum <code>long int</code>. After 63 your <code>int</code> no longer able to hold the answer.</p>
",1
42596987,42596776,0,"<p>The problem with the code is actually reported by the compiler if you turn on some warnings, however the problem is that you are implicitly converting from <code>double</code> to <code>int</code>, and depending on the implementation, you'd lose precision. <code>pow</code> returns a <code>double</code> but you're storing it in an <code>int</code> (<code>x</code>)</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
// conversion of decimal to octal
int main()
{
    int num,sum,count,x,y;
    printf(""enter a number\t"");
    scanf(""%d"",&amp;num);
    count = 0;
    sum = 0;
    while (num&gt;0){
        x=num%8;
        x=x*pow(10,count);
       /* ^^^^^^^^^^^^^^^^ problem here */
        count=count+1;
        num=num/8;
        sum=sum+x;
    }
    printf(""\n%d"",sum);





    return 0;
}
</code></pre>

<h1>now the fix</h1>

<p>Instead of using the library pow, you should implement your own that's integer only (because you KNOW you are using ints only)</p>

<pre><code>/* a trivial implementation */
long pow10(int  n) {

      long result = 1;
      while(n--) {
          result *= 10;
      }
      return result;
}
</code></pre>

<p>Now to clean up the program a bit:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;

long pow10(int  n);

/* a trivial implementation */
long pow10(int  n) {

    long result = 1;
    while(n--) {
          result *= 10;
    }
    return result;
}

int main()
{
    int num, count;
    long sum, x;
    printf(""enter a number\t"");
    scanf(""%d"",&amp;num);
    count = 0;
    sum = 0;
    while (num&gt;0){
        x=num%8;
        x=x*pow10(count);
        count=count+1;
        num=num/8;
        sum=sum+x;
    }
    printf(""\n%ld"",sum);
    return 0;
}
</code></pre>
",0
42596727,42596699,2,"<p>The thing is, you are printing an answer after reducing <code>n</code>. Swap lines.
Then you will need to change condition in <code>while</code> loop to <code>n&gt;=i</code>.</p>
",0
42596956,42596699,0,"<p>In this code, you are decreasing your number first and the printing the value of n. So, if n=5, it is first getting decremented by 1 then prints 4, again it gets decremented by 1 and prints 3 and this goes on.   </p>

<pre><code>while(n&gt;i){
   n--;
   printf(""%d\n"", n);
 }
</code></pre>

<p>In order to fix it, first print number and then decrease it. Fixed code will be like:</p>

<pre><code>while(n&gt;i){
   printf(""%d\n"", n);
   n--;
 }
</code></pre>
",1
44727701,44727615,2,"<p>You don't need nested loops. The two arrays work together in parallel, so just one loop will do it. You're multiplying the quantity by the prices of <em>all</em> the products, not just the product corresponding to that quantity.</p>

<p>And your code will be much simplified if you start your loops at <code>0</code> instead of <code>1</code>, since that's where array indexes start.</p>

<pre><code>for (i = 0; i &lt; n; i++) {
    r += a[i] * b[i];
}
</code></pre>

<p>It becomes more obvious if you used a single array of structures instead of multiple arrays:</p>

<pre><code>struct item {
    int quantity;
    int price;
} items[10];
</code></pre>

<p>Then it would be clear that you just need a single loop:</p>

<pre><code>for (i = 0; i &lt; n; i++) {
    r += items[i].quantity * items[i].price;
}
</code></pre>

<p>The other problem is that you're setting <code>p</code> to the total amount minus the discount, not the discount. So</p>

<pre><code>p = r - (r * 0.05);
</code></pre>

<p>should just be:</p>

<pre><code>p = r * 0.05;
</code></pre>

<p>You do the subtraction later when you print <code>r - p</code>. The result of this is that you were displaying the total to be paid for the discount, and the discount for the total to be paid.</p>

<p><a href=""http://rextester.com/RMCN34357"" rel=""nofollow noreferrer"">DEMO</a></p>
",9
42598449,42598242,1,"<p>You're adding a whitespace in scanf. Should be scanf(""%s"",...) and as well scanf(""%f"",...) not scanf("" %s"", ....) neither scanf("" %f"",...)</p>
",0
42598461,42598242,1,"<p>First, performing <code>scanf</code> with a format does not work properly. Not sure of what it does, but it's utterly useless to read a float. Just use <code>%f</code>, no space, and the float will be read.</p>

<p>Had you checked <code>scanf</code> return code, you'd have seen that it returned 0 instead of 1.</p>

<p>Then, drop <code>gets</code> in favor of protected <code>scanf</code> to avoid buffer overflow. </p>

<p>That code below works fine:</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

struct customer
{   char customer_name[20];
    float order_amount;
}c[10];

int main()
{   int i;
    int n=10;       

    printf(""\n******Enter customer details******\n"");

    for(i=0; i&lt;n; i++)
    {
        printf(""\nEnter customer name: "");
        scanf(""%19s"",c[i].customer_name);  // not above 19 characters
        printf(""Enter order amount: "");        
        scanf(""%f"",&amp;(c[i].order_amount)); // plain scanf %f
    }
    // print routine is unchanged

    printf(""\n\t*********Displaying information*********\n"");
    printf(""\nCustomers that has ordered are: \n"");

    for(i=0; i&lt;n; ++i)
    {   printf(""\nCustomer name: %s\n"",c[i].customer_name);     
        printf(""Ordered amount: %0.2f\n"",c[i].order_amount);
    }
    return 0;   
}
</code></pre>
",1
44374695,44374573,3,"<p>A few things:</p>

<ul>
<li><pre><code>v=(int*)malloc(sizeof(int));
c=(int*)malloc(sizeof(int));
</code></pre>

<p>These overwrites the pointers, so you lose the original <code>v</code> and <code>c</code>.</p></li>
<li><p><code>sizeof(v)/sizeof</code> is a syntax error</p></li>
<li><p>Getting the size of a pointer with <code>sizeof</code> returns the size of <em>the pointer</em>, not what it points to</p></li>
<li><p>Your reassignment of <code>v</code> and <code>c</code> above makes those variables points to memory for only a <em>single</em> <code>int</code>, and then you loop over <code>tam</code> elements meaning you go out of bounds of the memory</p></li>
<li><p>With <code>fscanf(fp,""%d"",&amp;v)</code> you pass a pointer <em>to the pointer</em></p></li>
<li><p>Read <a href=""https://stackoverflow.com/questions/5431941/why-is-while-feof-file-always-wrong"">Why is ¡°while ( !feof (file) )¡± always wrong?</a></p></li>
<li><p>No error checking, what happens if you can't open a file?</p></li>
<li><p>Your function will return immediately after the first <code>c[i]==v[j]</code> check, and it will return <em>unconditionally</em></p></li>
</ul>

<p>And probably much more.</p>
",0
42672793,42672729,1,"<p>This is simple. Use:</p>

<pre><code>printf(""%.2f"", 0.409999999);
</code></pre>

<p>This will print 0.41</p>
",0
42672870,42672729,0,"<p>Most floating points datatypes are, by their nature, imprecise. They try to store real numbers (infinite precision) in a limited precision bit-vector. As such, it's possible the closest representation of 0.41 on your platform is 0.409999999.</p>

<p>You should read up on the IEEE754 floating point representation to get an idea what's kind of issue you hit there.</p>
",2
42672951,42672729,1,"<ul>
<li>%f   (print as a floating point) </li>
<li>%4f  (print as a floating point with a width of at least 4 wide) </li>
<li>%.4f (print as a floating point with a precision of four characters after the decimal point) </li>
<li>%3.2f    (print as a floating point at least 3 wide and a precision of   2)</li>
</ul>
",0
44369312,44368366,0,"<p>I found out what you want, here ya have it, this explains how to find the ""islands"", meaning the number of connected 1's</p>

<p><a href=""http://www.geeksforgeeks.org/find-number-of-islands/"" rel=""nofollow noreferrer"">http://www.geeksforgeeks.org/find-number-of-islands/</a></p>
",0
44380073,44368366,0,"<p>like this</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef int Color;

typedef struct cell {
    char kind;
    Color color;
} Cell;

typedef struct pos {//position
    int h, v;
} Pos, Size;

typedef struct world {
    Size size;
    Cell **cells;
} World;

typedef struct node {
    Pos pos;
    struct node *next;
} Node;

typedef struct stack {
    Node *np;
} Stack;

void push(Stack *s, Pos pos){
    Node *np = malloc(sizeof(*np));
    np-&gt;pos = pos;
    np-&gt;next = s-&gt;np;
    s-&gt;np = np;
}
int isEmpty(Stack *s){
    return !s-&gt;np;
}

Pos pop(Stack *s){
    Pos ret = s-&gt;np-&gt;pos;
    Node *next = s-&gt;np-&gt;next;
    free(s-&gt;np);
    s-&gt;np = next;
    return ret;
}

World *make_world(Size size, Stack *s);
void ruin(World *w);
void paint(World *w, Pos pos, Color *color);

int main(void){
    int rows, cols;

    puts(""Enter number of rows:"");
    scanf(""%d"", &amp;rows);

    puts(""Enter number of columns:"");
    scanf(""%d"", &amp;cols);

    Stack land = { NULL };
    World *world = make_world((Size){.v = rows, .h = cols}, &amp;land);

    Color color = 0;
    while(!isEmpty(&amp;land)){//`land` is a position list of `1`
        paint(world, pop(&amp;land), &amp;color);//Paint the same color from the specified position. New location paints another color(do increment color)
    }
    printf(""Number of connected objects = %d\n"", color);//The number of colors used is the number of connected objects.
    ruin(world);
}

enum { BLANK = 0, LAND = '1', SEA = '0', NONE = -1 };

World *make_world(Size size, Stack *landList){
    World *w = malloc(sizeof(*w));
    w-&gt;size = size;
    w-&gt;cells = malloc(size.v * sizeof(*w-&gt;cells));
    for(int r = 0; r &lt; size.v; ++r){
        w-&gt;cells[r] = calloc(size.h, sizeof(**w-&gt;cells));
    }
    puts(""Enter the matrix:"");
    for(int r = 0; r &lt; size.v; ++r){
        for(int c = 0; c &lt; size.h; ++c){
            char ch = 0;
            scanf("" %c"", &amp;ch);
            if((w-&gt;cells[r][c].kind = ch) == LAND)
                push(landList, (Pos){ .v = r, .h = c});
        }
    }
    return w;
}

void ruin(World *w){
    for(int r = 0; r &lt; w-&gt;size.v; ++r)
        free(w-&gt;cells[r]);
    free(w-&gt;cells);
    free(w);
}

void fill(World *w, Pos pos, Color *color, Cell *neighbor){
    if(pos.h &lt; 0 || pos.v &lt; 0 || pos.h &gt;= w-&gt;size.h || pos.v &gt;= w-&gt;size.v)//Out of range
        return;
    Cell *cell = &amp;w-&gt;cells[pos.v][pos.h];//reduce code
    if(cell-&gt;color != BLANK)//Color already painted
        return;
    if(neighbor != NULL){//There are adjacent cells
        if(cell-&gt;kind != neighbor-&gt;kind){//Do not process unless they are of the same kind
            return;
        }
        cell-&gt;color = neighbor-&gt;color;//Fill with the color of the adjacent cell
    } else {
        cell-&gt;color = ++*color;//The first cell paints a new color.
    }
    //Process my own neighbor cell
    fill(w, (Pos){.v = pos.v-1, .h = pos.h-1}, color, cell);
    fill(w, (Pos){.v = pos.v-1, .h = pos.h  }, color, cell);
    fill(w, (Pos){.v = pos.v-1, .h = pos.h+1}, color, cell);
    fill(w, (Pos){.v = pos.v  , .h = pos.h-1}, color, cell);
//  fill(w, (Pos){.v = pos.v  , .h = pos.h  }, color, cell);//current cell
    fill(w, (Pos){.v = pos.v  , .h = pos.h+1}, color, cell);
    fill(w, (Pos){.v = pos.v+1, .h = pos.h-1}, color, cell);
    fill(w, (Pos){.v = pos.v+1, .h = pos.h  }, color, cell);
    fill(w, (Pos){.v = pos.v+1, .h = pos.h+1}, color, cell);
}

void paint(World *w, Pos pos, Color *color){//wrapper function
    fill(w, pos, color, NULL);
}
</code></pre>
",0
46977234,46977165,3,"<p>Because a <code>union</code>, other than a <code>struct</code>, overlays its members. It makes no sense to initialize both members.</p>
",0
46977250,46977165,7,"<p>Your compiler should actually warn you about ""excessive initializers"" or something similar. Try to enable more warnings (personal recommendation for <code>gcc</code>/<code>clang</code>: <code>-std=c11 -Wall -Wextra -pedantic</code>).</p>

<p>With a <code>union</code>, an initializer (without a designator) always initializes the first union member. You can't have multiple members of a <code>union</code> hold a value at the same time, they all share the same memory, so initializing more than one doesn't make sense. If you do using designators, the last one ""wins"".</p>

<p>Your compiler just drops the <code>97</code> and uses the <code>1</code> for initializing <code>p.x</code>. This doesn't guarantee reading <code>p.y</code> will give you <code>1</code>, but on a little-endian machine, this will happen. </p>
",1
46977309,46977165,1,"<p>Your program is undefined - you can only initialize one of the members of a union because all members occupy are stored at the same address.   I am surprised your C compiler didn¡¯t get all excited about this, have you disabled warnings?  Once you have jumped into undefined, there is no telling what the compiler will do.</p>
",3
46977315,46977165,1,"<p>Because it is an union and only one initialisation value is needed. The second one is ignored. </p>
",0
44720161,44718110,0,"<p>This code is quite strange and some parts of it should not be compiled by c compiler.</p>

<p>E.g.:</p>

<pre><code>        int NV  = 500   #No. of nodes
        int m  = 10000 #No. of edges
        int nblinks = 0; # edge counter:
</code></pre>

<p>where <code>#No. of nodes</code> is like comment and <code>int NV  = 500</code> has no <code>;</code> in the end - so is not completed line of code.</p>

<p>Style is also not perfect, e.g.:</p>

<pre><code>    if(ls == NULL){
    printf(""Error in opening file ls!\n"");}
    if(ed == NULL){
    printf(""Error in opening file ed!\n"");}
    if(lk == NULL){
    printf(""Error in opening file lk!\n"");}
    else 
    {
</code></pre>

<p>should be </p>

<pre><code>    if(ls == NULL)
    {
          printf(""Error in opening file ls!\n"");
          return 1;
    }
    if(ed == NULL)
    {
          printf(""Error in opening file ed!\n"");
          return 1;
    }
    if(lk == NULL)
    {
          printf(""Error in opening file lk!\n"");
          return 1;
    }
    // no else needed after 3 way to the exit (return)
</code></pre>

<p>or better</p>

<pre><code>    if(!lk || !ed || !ls)
    {
          printf(""Error in opening on of the files\n"");
          return 1;
    } 
</code></pre>

<p>In general, if all files are opened in the required mode (and after all writing are closed) no problem should be with <code>fprintf</code> except incorrect format string or wrong data for output.</p>

<p><strong>UPDATE:</strong></p>

<p>Just to check output, you can use <code>stdout</code> as the first argument of <code>fprintf</code> to see result at the screen (console), or make <code>lk = stdout;</code> instead of <code>lk = fopen(""link2.txt"", ""w"");</code>.</p>

<p>Then if you see data at the screen look what is wrong with the file.</p>
",5
45761628,45761430,0,"<p>I've included a little 32-bit to num to letter converter for you to grasp the basics.  It works a single ""32-bit number"" at a time.  You could use this as a basis for an array based solution like you have half way done in your example, or change the type to be bigger, or whatever.  It should show you roughly what you need to do:</p>

<pre><code>void intToBase4 (uint32_t num, char *outString)
{
  // There are 16 digits per num in this example
  for(int i=0; i&lt;16; i++)
  { 
    // Grab the lowest 2 bits and convert to a letter.
    *outString++ = (num &amp; 0x03) + 'a';

    // Shift next 2 bits low
    num &gt;&gt;= 2;
  }
  // NUL terminate string.
  *outString = '\0';
}
</code></pre>
",0
45762299,45761430,0,"<p>A bit more universal one:
Usage:
value - value to decode, buff - buff where result string will be stored, numofwrds - number of fields to be decoded, ... fields sizes in bits</p>

<p>example ""xxxxyyvvzz"": - 4 bits, two bits, two bits, two bits</p>

<pre><code>decode(v, buff, 4, 4, 2, 2, 2);
</code></pre>

<hr>

<pre><code>char dictionary[] = ""abcdefghijklmnopqrstuwxyz"";

char *decode(unsigned int value, char *buff, int numofwrds, ...)
{
    va_list vl;
    int *fieldsizes = malloc(sizeof(int) * numofwrds);
    int bitsize = 0;
    char *result = NULL;

    if (fieldsizes != NULL)
    {
        va_start(vl, numofwrds);

        for (int i = 0; i &lt; numofwrds; i++)
        {
            fieldsizes[i] = va_arg(vl, int);
            bitsize += fieldsizes[i];
        }
        va_end(vl);

        for (int i = 0; i &lt; numofwrds; i++)
        {
            unsigned int mask, offset;

            mask = (1 &lt;&lt; fieldsizes[i]) - 1;
            offset = bitsize - fieldsizes[i];
            mask &lt;&lt;= offset;
            buff[i] = dictionary[(value &amp; mask) &gt;&gt; offset];
            bitsize -= fieldsizes[i];
        }
        free(fieldsizes);
        result = buff;
    }
    buff[numofwrds] = '\0';
    return result;
}
</code></pre>
",2
46666303,46666145,0,"<p>You are trying to access a memory location that doesnot belong to your array. When you define an array of size 3 the index are 0,1,2 . The values board game[0][3],board game[1][3],board game[2][3],board game[3][0],board game[3][1], board game[3][2],board game[3][3] are out of bound</p>
",0
46666339,46666145,0,"<p>It's Out Of Bound and undefined (offsets: 3, 3| 3, 0) when the indexes only can be between 0..2</p>

<p>And you declared 0 at the start to all the array values</p>

<p><code>board_game[row][col]</code> Means the value of the array in that offsets</p>
",0
44687053,44686850,1,"<p>There are a number of unrelated issues here.</p>

<pre><code>arm = fopen(""C:\\Programming\\ARMENIA.TXT"", ""wt"");
</code></pre>

<p>That should be ""w+"", not ""wt"". Same for the others.  Or just ""w"", unless you want to both read and write.</p>

<pre><code>if (arm, ita, esp == NULL)
</code></pre>

<p>The comma operator evaluates its left operand and discards it, then evaluates its right operand and keeps that value.  So this is equivalent to <code>if (esp == NULL)</code></p>

<pre><code>fflush(stdin);
</code></pre>

<p>This is meaningless. When printing, the system is allowed to buffer output and then print it all at once, which can speed things up.  <code>fflush</code> forces it to actually print anything that's currently in the buffer.  It's useful if, for example, you want to prompt the user for input and need to make sure the prompt shows up.</p>

<p>As such, it only works on an output stream.  (This error is actually taught in some terrible references, so I suspect this one isn't your fault.  You should stop using whatever reference told you to do this.)</p>

<p>Addendum: As Olaf points out in the comments, this invokes undefined behavior, which is a topic unto itself.  The short and imprecise version is that any undefined behavior creates bugs that are really hard to track down.</p>

<pre><code>if (ret = strstr(person.lastName, ian)) 
</code></pre>

<p>This tells you that ian is in person.lastName somewhere, but not that it's at the end.  For example, suppose the last name is ""ian in ez"".  It'll match all three of your conditions. As an aside, you don't need to store ian in a variable; you can just do <code>strstr(person.lastName, ""ian"")</code>.</p>
",10
44687250,44686850,1,"<p>In addition to the issues Ray pointed out, see the following simple code for a <code>strEndsWith</code>-function. Hope it helps.</p>

<pre><code>int strEndsWith(const char* str, const char* ending) {
    size_t strlenStr = strlen(str);
    size_t strlenEnding = strlen(ending);
    if (strlenStr &lt; strlenEnding)
        return 0;

    const char* strAtEnding = str + strlenStr - strlenEnding;

    return (strcmp(strAtEnding, ending) == 0);
}
</code></pre>
",2
44688333,44686850,1,"<p>Your program has multiple issues.</p>

<p>Some of the have been addressed by Ray and Stephen Lechner, but here are some more:</p>

<ul>
<li><p>The reason for the crashes is you pass string to <code>fwrite</code> instead of <code>FILE*</code> stream pointers: <code>fwrite(person.lastName, 1, strlen(person.lastName), ini);</code> should be written:</p>

<pre><code>fwrite(person.lastName, 1, strlen(person.lastName), ita);
</code></pre>

<p>This is an indication that you compile without proper warnings enabled. Let the compiler help avoid such silly mistakes with <code>-Wall</code> for <code>gcc</code> or <code>/W3</code> for <code>msvc</code>.</p></li>
<li><p>Note also that you should use <code>fprintf</code> to properly format the output to your text files. For example:</p>

<pre><code>if (strEndsWith(person.lastName, ""ian"")) {
    fprintf(arm, ""%s, %s\n"", person.lastName, person.firstName);
}
</code></pre></li>
</ul>

<p>Here is an improved version:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int strEndsWith(const char *str, const char *ending) {
    size_t len1 = strlen(str);
    size_t len2 = strlen(ending);
    return len1 &gt;= len2 &amp;&amp; !strcmp(str + len1 - len2, ending);
}

int main(void) {
    FILE *arm = fopen(""C:\\Programming\\ARMENIA.TXT"", ""wt"");
    FILE *ita = fopen(""C:\\Programming\\ITALIA.TXT"", ""wt"");
    FILE *esp = fopen(""C:\\Programming\\ESPANIA.TXT"", ""wt"");

    if (arm == NULL || ita == NULL || esp == NULL) {
        printf(""Error: The archives could not be created.\n"");
        return 1;
    } else {
        printf(""Operation Successful: Archives created.\n\n"");
    }

    for (;;) {
        char firstName[20];
        char lastName[30];
        char response;

        printf(""\n\nPlease input the first name: "");
        if (scanf(""%19s"", firstName) != 1)
            break;
        printf(""Please input the last name: "");
        if (scanf(""%29s"", lastName) != 1)
            break;

        if (strEndsWith(lastName, ""ian"")) {  
            fprintf(arm, ""%s, %s\n"", lastName, firstName);
        }
        if (strEndsWith(lastName, ""ini"")) {  
            fprintf(ita, ""%s, %s\n"", lastName, firstName);
        }
        if (strEndsWith(lastName, ""ez"")) {  
            fprintf(esp, ""%s, %s\n"", lastName, firstName);
        }

        printf(""\n\nWould you like to enter another person into the archive?: (y) or (n): "");
        if (scanf("" %c"", &amp;response) != 1 || response != 'y')
            break;
    }

    printf(""\n\nThe operation has finished.\n\n"");

    fclose(arm);
    fclose(ita);
    fclose(esp);

    return 0;
}
</code></pre>
",1
45071705,45071669,2,"<p>This: <code>?:</code> is the ternary operator. Here's the syntax: <code>(condition) ? (if_true) : (if_false)</code>. What this means is that, this expression will return <code>if_true</code> if <code>condition</code> is true, else <code>if_false</code> will be returned.</p>

<p>So, in your case, the <code>condition</code> is <code>4</code> which is always true (because not all of the bits are <code>0</code> if you represent <code>4</code> in binary), hence the <code>if_true</code> part is returned. Check <a href=""https://en.wikipedia.org/wiki/%3F:#C"" rel=""nofollow noreferrer"">this</a> as well.</p>
",0
45071778,45071669,3,"<p>It is returning output 2 because your condition is true as you are checking for 4 which is always true in second line of code. If you want result as 8: Then write code as below:</p>

<pre><code>int x=3;
x = x==4? 2: 8;
</code></pre>

<p>it will return 8 as condition is false because value of x is 3 and you are checking it against 4.</p>
",0
45069077,45068965,2,"<p>I have not seen a matrix. It seems you mean an array or a vector.</p>

<p>For starters according to the C Standard the function main without parameters shall be declared like </p>

<pre><code>int main( void )
</code></pre>

<p>The variable <code>matrix_sum</code> was not initialized.</p>

<p>In this loop </p>

<pre><code>for(i = 0; i &lt; m ; i++)  //filling the matrix
matrix[i] = matrix[i-1]+1;
                   ^^^^
</code></pre>

<p>there is an attempt to access memory beyond the array when the variable <code>i</code> is equal to 0.</p>

<p>And it looks like you wanted to use the conversion specifier <code>%ld</code> in this statement</p>

<pre><code>printf(""%lo \n"",matrix_sum);
        ^^^
</code></pre>

<p>Otherwise the output will be as an octal number.</p>

<p>I think you mean the following. At least the program output is exactly equal to 15.:)</p>

<pre><code>#include &lt;stdio.h&gt;

#define N   5

int main(void) 
{
    int a[N];
    int i;
    long sum;

    for ( i = 0; i &lt; N ; i++ ) a[i] = i + 1;

    sum = 0;
    for ( i = 0; i &lt; N ; i++ ) sum += a[i];

    printf( ""%ld\n"", sum );

    return 0;
}
</code></pre>
",2
45068987,45068965,4,"<p>Think about what happens on the first iteration of this loop:</p>

<pre><code>for(i = 0; i &lt; m ; i++)  //filling the matrix
    matrix[i] = matrix[i-1]+1;
</code></pre>

<p>Notice that you'll be reading from index -1 of this array (oops!) This leads to <em>undefined behavior</em>, which means that in principle <em>anything</em> can happen. Your program could get garbage data, get the wrong answer, or even outright crash!</p>

<p>It's up to you to decide how to avoid this case. Consider changing the loop indices so that you start at a higher index.</p>

<p>Also, look at the remaining variables in <code>main</code>. Are they initialized? If not, adding values to them will again result in undefined behavior and pretty much anything can happen to them.</p>

<p>Finally, look at how you're <code>printf</code>ing things:</p>

<pre><code>printf(""%lo \n"",matrix_sum);
</code></pre>

<p>The <code>%lo</code> specifier means ""the argument is a <code>long</code>, and it should be printed in octal (base-8)."" This means that you're not printing the value in decimal, so even if you'd expect to get the value 15<sub>dec</sub>, you'd instead see 17, the octal representation of the number.</p>
",2
45731856,45730903,0,"<p>You will fine enough help <a href=""https://stackoverflow.com/questions/174531/easiest-way-to-get-files-contents-in-c"">here</a> and <a href=""https://stackoverflow.com/questions/12784766/check-substring-exists-in-a-string-in-c"">here</a>.</p>

<p>First of all if you want to read the c file, find your answer in the first link. Second of all after opening it from the first step, you should look for types (helping yourself with the second link): bool, int, void, ..., then you will save the line with a getline().</p>

<p>your getline should include the following if your c file is well indent :</p>

<ul>
<li>the type (including pointers if any), </li>
<li>the name of the function, </li>
<li>the parameters </li>
</ul>

<p>Then from the <strong>first</strong> '{' you will find your function implementation. If there is any more loop inside your fonction, you have to count all the '{' in order to know where your function finishes by putting them in a LIFO.</p>

<p>You will have to do this until the end of the doc to know all the functions.</p>
",1
44714880,44714721,0,"<p>just replace a with i in your loop.</p>

<pre><code> for(int i=a;i&lt;=b;i++)
{
     first=i;
     last=i%10;
     temp=i/10;
     middle=temp%10;
    while(first&gt;10)
    {
        first=first/10;
    }

    sum=first+last;
    if(sum == middle)
    {
        cnt=cnt+1;
    }
}
printf(""%d"",cnt);
</code></pre>

<p>This will give you correct result :) </p>
",0
44720552,44714721,0,"<pre><code>for(int i=a;i&lt;=b;i++)
{
    first=i;
    last=i%10;
    temp=i/10;
    middle=temp%10;
    while(first&gt;10)
    {
        first=first/10;
    }

    sum=first+last;
    if(sum == middle)
    {
        count=count+1;
    }
}
printf(""%d"",count);
</code></pre>
",0
44694162,44694117,5,"<p>You cannot store a string in an array of 1 characters. The only string you can store is <code>""""</code> (the empty string) since that requires exactly one character for the <code>'\0'</code> terminator.</p>

<p>Your code suffers from undefined behavior, so it cannot be reasoned about beyond that.</p>
",0
46965102,46964776,1,"<p>The better for string input is <code>fgets</code> as <code>scanf (""%[^\n]%*c"", &amp;address.city)</code>; does not work well if the the line is only <code>""\n""</code> or too long. Stick with <code>fgets()</code>.</p>

<pre><code> fgets(address.city,40,stdin);
</code></pre>

<p>EDIT: If you still want to use <code>scanf</code> use like this</p>

<pre><code> scanf ("" %[^\n]%*c"", &amp;address.city)
</code></pre>

<p>it will scan characters until it finds <code>'\n'</code></p>
",0
46964836,46964776,0,"<p>Put the <code>&amp;</code> on your reference to <code>address.city</code>
like this</p>

<pre><code>scanf(""%40s"", &amp;address.city);
</code></pre>
",2
44693521,44693207,1,"<p>That's what declarations are for. Consider the following code:</p>

<pre><code>extern void func(void);

int main(void)
{
     func(void);
     return 0;
}
</code></pre>

<p>when compiled with i.e. <code>gcc -c main.c</code>, it will produce a <code>main.o</code> object file, where the main function will look like this:</p>

<pre><code>Disassembly of section .text:

0000000000000000 &lt;main&gt;:
   0:   55                      push   %rbp
   1:   48 89 e5                mov    %rsp,%rbp
   4:   e8 00 00 00 00          callq  9 &lt;main+0x9&gt;
   9:   b8 00 00 00 00          mov    $0x0,%eax
   e:   5d                      pop    %rbp
   f:   c3                      retq   
</code></pre>

<p>And the relocation table will contain an entry:</p>

<pre><code>RELOCATION RECORDS FOR [.text]:
OFFSET           TYPE              VALUE 
0000000000000005 R_X86_64_PC32     func-0x0000000000000004
</code></pre>

<p>Now note that <code>5</code> is the exact offset of the callq immediate address in <code>main</code> (not particularly important how this is encoded, it might vary across different platforms or even inside one platform).</p>

<p>Anyway, given the external declaration of <code>func</code> you placed in C code, the compiler knows that it might not have yet a proper address for the function to place into callq.</p>

<p>When linker links together different object files, it makes sure that all such dangling addresses are successfully resolved.</p>

<p>Now answering your particular question - the key to matching relocation table entries (external declarations) to actual symbols (function or variable definitions) are their signatures. A particular signature produces such relocation entries and symbols, that might be matched. Different signatures are essentially different in terms of linkage.</p>

<p>Beyond this point, your question is actually quite broad. So please either ask for further research directions or make it more clear.</p>

<p><strong>EDIT:</strong> please also note that I obtained these listings under x86_64 linux, you might get different results in your environment, but the idea will still be the same.</p>
",1
46114301,46113825,0,"<pre><code>#define MAX_STRING_SIZE 256

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

static int getList(char ***pppclist){
    int n=0;
    int i =0;

    printf(""Enter the number of items in the List: "");
    scanf(""%d"", &amp;n);

    //Array of Pointers to characters
    *pppclist = (char **) malloc(n * sizeof(char *));

    for(i = 0; i &lt; n; i++){
        (*pppclist)[i] = (char *) malloc(MAX_STRING_SIZE);

        printf(""Enter the %d items in the List: "", i);
        scanf(""%s"", (*pppclist)[i]);
    }
    return n;
}

int main(void){
    int i;
    char **ppclist = NULL;

    int n = getList(&amp;ppclist);

    for(i = 0; i &lt; n; ++i){
        printf(""The Entered List is:%s\n"", ppclist[i]);
        free(ppclist[i]);
    }
    free(ppclist);

    for(;;);
}
</code></pre>
",1
46114136,46113825,0,"<p>You probably want this:</p>

<pre><code>#define MAX_STRING_SIZE 256

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

static void getList(char ***pppclist, int *n)
{
  int i = 0;

  printf(""Enter the number of items in the List: "");
  scanf(""%d"", n);
  *pppclist = (char **)malloc(*n * sizeof(char *));  //X50, x51, x52

  for (i = 0; i &lt; *n; i++)   // using &lt; instead of &lt;= to prevent access out of bounds
  {
    // parentheses placed correctly
    (*pppclist)[i] = (char *)malloc(MAX_STRING_SIZE * sizeof(char)); //*X50 = X100

    printf(""Enter the %d items in the List: "", i);
    scanf(""%s"", (*pppclist)[i]);   // indirection correct
  }
}

int main(int argc, char *argv[])    // main needs to return an int, required by C standard
{
  char **ppclist = NULL;
  int nbofitems;

  getList(&amp;ppclist, &amp;nbofitems);  // needs to return the number of items in the list
                                  // so we can print it

  printf(""The Entered List is\n"");

  // manually printing list element by element
  // a single printf cannot handle the whole list
  for (int i = 0; i &lt; nbofitems; i++)
    printf(""%d: %s\n"", i, ppclist[i]);
}
</code></pre>

<ul>
<li>See comments for explanations.</li>
<li>If you are using a C (not C++) compiler, you should remove the casts before <code>malloc</code></li>
<li>No error checking is done for brevity.</li>
</ul>
",5
46114198,46113825,0,"<p>First, in the getList function, when you want to access to the n item in the array, you have to wrap <code>*pppclist</code> in paranthesis, not <code>*pppclist[i]</code> because you should first dereference the pointer and after access to the n item.</p>

<p>Next thing, when you allocate your array, you should allocate one more item and set it to <code>NULL</code>. It's usefull for browse your array later.</p>

<p>Here is your code corrected: </p>

<pre><code>#define MAX_STRING_SIZE 256

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;


static void getList(char ***pppclist)
{
    int n=0;
    int i =0;

    printf(""Enter the number of items in the List: "");
    scanf(""%d"", &amp;n);

    //Array of Pointers to characters
    *pppclist = (char **)malloc((n + 1) * sizeof(char *));  //X50, x51, x52
    (*pppclist)[n] = NULL;

    for( i=0; i&lt;n; i++)
    {
      (*pppclist)[i] = (char *)malloc(MAX_STRING_SIZE * sizeof(char)); //*X50 = X100

        printf(""Enter the %d items in the List: "", i);
        scanf(""%s"", (*pppclist)[i]);
    }

}

int main(int argc, char *argv[])
{


    char **ppclist = NULL; //array of Pointer to Pointer to character
    int index;

    getList(&amp;ppclist); //X1

    index = 0;
    while (ppclist[index]) {
      printf(""The Entered List is:%s\n"", ppclist[index]);
      index += 1;
    }

    return (0);
}
</code></pre>
",0
46945881,46945762,1,"<p>Problem is this line:</p>

<pre><code>while((c = getchar() != EOF)) {
</code></pre>

<p>It should be:</p>

<pre><code>while((c = getchar()) != EOF) {
</code></pre>

<p>With your version, you actually assign the value of <code>getchar() != EOF</code> to <code>c</code>. This will usually be <code>1</code>, unless <code>EOF</code> is reached in which case it'll be <code>0</code>.</p>
",1
46945887,46945762,1,"<p>It's an <a href=""http://en.cppreference.com/w/c/language/operator_precedence"" rel=""nofollow noreferrer""><em>operator precedence</em></a> problem.</p>

<p>The expression <code>c = getchar() != EOF</code> is equal to <code>c = (getchar() != EOF)</code>. I.e. you assign the result of <code>getchar() != EOF</code> to the variable <code>c</code>. After this <code>c</code> will be either <code>1</code> or <code>0</code>.</p>

<p>You need to think about those extra parenthesis you have, and where to put them.</p>
",1
46981043,46980032,0,"<p>In your <code>fscanf(tfptr, ""%u:%u:%.2f\n"", &amp;combo_trans, &amp;ala_trans, &amp;grand_total);</code>, the <code>%.2f</code> will cause problem.</p>

<p>You can't specify the precision for floating-point numbers in <code>scanf()</code> unlike in the case of <code>printf()</code>. See <a href=""https://stackoverflow.com/a/28132773/5375464"">this</a> answer.</p>

<p>So, instead of <code>%.2f</code> in the <code>scanf</code> format string, use just <code>%f</code>.</p>

<p>Since you just need the last line, you could just read the file line by line with <code>fgets()</code> and keep the last line.</p>

<pre><code>while( fgets(str, sizeof(str), tfptr)!=NULL );
printf(""\nLast line: %s"", str);
</code></pre>

<p><code>fgets()</code> will return <code>NULL</code> when the file is over (or if some error occurred while reading).</p>

<p>The lines in the input file are read one by one and when there are no more lines to read, <code>str</code> (a character array of suitable size) will have the line that was read last.</p>

<p>You could then parse the string in <code>str</code> with <code>sscanf()</code> like</p>

<pre><code>sscanf(str, ""%u:%u:%f"", &amp;combo_trans, &amp;ala_trans, &amp;grand_total);
</code></pre>

<p>Also, you should be checking the return value of <code>fopen()</code> to see if the file was really opened. <code>fopen()</code> will return <code>NULL</code> if some error occurred.</p>

<pre><code>if( (tfptr = fopen(""trans.txt"", ""r""))==NULL )
{
    perrror(""Error"");
}
</code></pre>
",1
46980124,46980032,0,"<p>What did go wrong? Did you get another line?</p>

<p>Don't use ""&amp;"" as you don't want to save a pointer. That can be the reason of failure.</p>
",1
45042382,45040732,2,"<p>Replace the ||(ORs) by &amp;&amp;(ANDs) </p>

<pre><code>for(i=0;i&lt;pnum;i++) {
    do {
      printf(""Player %d insert your class:\n"", i+1);
      p[i].class=getc(stdin);
    } while(p[i].class!='c' &amp;&amp; p[i].class!='t' &amp;&amp; p[i].class!='a' &amp;&amp; p[i].class!='d');
}
</code></pre>

<p>Imagine the user enter <code>char t</code>. If it were OR instead of AND, first condition would be true which is enough to proceed with the loop again. But if it's AND all conditions needs to be TRUE in order to proceed with the loop. Since second will be FALSE, so the do-while loop shall terminate.</p>

<p>In short, </p>

<pre><code>(p[i].class!='c' || p[i].class!='t' || p[i].class!='a' || p[i].class!='d')
</code></pre>

<p>would mean that <strong>ANY</strong> of them being <strong>TRUE</strong> is sufficient to <strong>PROCEED</strong> with the loop</p>

<p>but,</p>

<pre><code>(p[i].class!='c' &amp;&amp; p[i].class!='t' &amp;&amp; p[i].class!='a' &amp;&amp; p[i].class!='d')
</code></pre>

<p>would mean that <strong>ANY</strong> of them being <strong>FALSE</strong> is sufficient to <strong>STOP</strong> the loop</p>
",0
45076922,45075059,7,"<pre><code>char *malloc();
</code></pre>

<p>Is a K&amp;R C function declaration. We call it K&amp;R C because it is the C dialect described in the first edition of <em>The C Programming Language</em> by Kernighan and Ritchie which was published in around 1980. That declaration says ""malloc exists, returns <code>char*</code> and may or may not take parameters"".</p>

<p>In 1990, the first official C standard was published. One of the biggest improvements over K*R style C was the introduction of function prototypes in which the types of the parameters can also be declared. Another, was the introduction of the <code>void</code> type and therefore also <code>void *</code>. Since 1990, the C header file <code>stdlib.h</code> has had the following declaration for <code>malloc</code></p>

<pre><code>void *malloc(size_t size);
</code></pre>

<p>This conflicts with your redeclaration in having a different return type, hence the error.</p>

<p>Your book C Traps and Pitfalls <a href=""https://www.amazon.co.uk/C-Traps-Pitfalls-Andrew-Koenig/dp/0201179288"" rel=""noreferrer"">is 27 years old</a> and three standards out of date (C90, C99, C11). Get a new book.</p>
",1
47705275,47705213,4,"<p>If you use a function without declaring it, the compiler may provide a default declaration. This is not part of modern C, but compilers may use old standards or be unduly lax in this regard. (It is better to require explicit declarations because it helps reduce mistakes.)</p>

<p>Any declaration of a function must match the definition of the function. The declaration gives the compiler information about how to call the function. If the declaration does not match, things can go wrong. So, yes, the declaration can affect your program; it can break it.</p>

<p>In this case, you got lucky, the default declaration of a function happened to match your function <code>fact</code>. The default declaration is a function that returns <code>int</code> and accepts whatever arguments you pass it, subject to default argument promotions. (Roughly speaking, the default argument promotions are that integers narrower than an <code>int</code> are converted to <code>int</code>, and <code>float</code> values are converted to <code>double</code>. So, if a function returns <code>int</code> and accepts only <code>int</code> and <code>double</code> arguments, it can match the default declaration.)</p>

<p>A good compiler will warn you that a declaration is missing or that a declaration is wrong. Your compiler has ¡°switches¡± or other options that tell it what sorts of warning and error messages you want. You should ask for lots of warning messages.</p>

<p>Your compiler probably also has switches that say which version of C to use. (There have been several standard versions, most recently 1999 and 2011, and there are some non-standard variants.) You might want to request that your compiler use the C 2011 standard, until you have good reason to change that. (Unfortunately, if you are using Microsoft Visual C, I do not believe it supports C 2011.)</p>
",1
46958464,46958348,1,"<p>You cannot return more than one value. One option is to pass pointers to those variables to a function instead:</p>

<pre><code>void Variables(int *a, int *b, int *c)
{ 
    printf(""input variables"");
    scanf(""%d"", a);
    scanf(""%d"", b);
    scanf(""%d"", c);
    printf(""%d:%d:%d\n"", *a, *b, *c);
}

int main(void) 
{
    int a, b, c;
    Variables(&amp;a, &amp;b, &amp;c)
    printf(""\n%d:%d:%d\n"", a, b, c);
    return 0;
}
</code></pre>

<p>Notice there are additional <code>&amp;</code> and <code>*</code>.</p>

<p>Another options is to do this using structures:</p>

<pre><code>struct variables {
    int a, b, c;
};

struct variables Variables(void)
{
    struct variables var;
    scanf(""%d"", &amp;var.a);
    scanf(""%d"", &amp;var.b);
    scanf(""%d"", &amp;var.c);
    return var;
}

int main(void) 
{
    struct variables var = Variables();
    printf(""\n%d:%d:%d\n"", var.a, var.b, var.c);
    return 0;
}
</code></pre>

<p>You have to understand comma <code>,</code> operator. This why your code didn't work as you expected. You can read about it here: </p>

<ul>
<li><a href=""https://stackoverflow.com/questions/54142/how-does-the-comma-operator-work"">How does the Comma Operator work</a></li>
<li><a href=""https://stackoverflow.com/questions/16563235/what-does-a-comma-separated-list-of-values-enclosed-in-parenthesis-mean-in-c-a?noredirect=1&amp;lq=1"">What does a comma separated list of values, enclosed in parenthesis mean in C? a = (1, 2, 3);</a></li>
</ul>
",0
46958553,46958348,0,"<p>A clean and simple option is to call <code>Function</code> 3 times with only one parameter at a time . like this:</p>

<pre><code>  #include &lt;stdio.h&gt;

  int Variables () 
  { 
  printf(""input variables"");
  scanf(""%d"", &amp;a);
  return a;
  }

  int main (void) 
  { 
  printf (""\n%d:%d:%d\n"", Var(),Var(),Var());
  return 0;
  }
</code></pre>
",5
46958580,46958348,0,"<p>You cannot return multiple values in C.
The comma operator you used is quite useless here. Your function simply returns the last one.</p>

<p>You might split your function call in two steps and use pointers or return a struct, like this:</p>

<pre><code>#include &lt;stdio.h&gt;

void Variables (int *a, int *b, int *c) /* Example of a function wich stores    
variables with user input */
{ 
    printf(""input variables"");
    scanf(""%d"", a);
    scanf(""%d"", b);
    scanf(""%d"", c);
    printf(""%d:%d:%d\n"", *a, *b, *c); // Dunno why you need to print twice...
}

int main (void) 
{
int a, b, c;
Variables(&amp;a, &amp;b, &amp;c);
printf (""\n%d:%d:%d\n"", a, b, c );
return 0;
}
</code></pre>

<p>How about?</p>
",0
46989291,46989215,0,"<p>Due to <a href=""http://www.geeksforgeeks.org/factorial-large-number/"" rel=""nofollow noreferrer"">this</a> link,
Following is a simple solution where we use an array to store individual digits of the result. The idea is to use basic mathematics for multiplication. 
The following is detailed algorithm for finding factorial.</p>

<p><strong>factorial(n)</strong></p>

<p>1) Create an array ¡®<code>res[]</code>¡¯ of MAX size where MAX is number of maximum digits in output.</p>

<p>2) Initialize value stored in <code>¡®res[]¡¯</code> as 1 and initialize ¡®res_size¡¯ (size of ¡®res[]¡¯) as 1.</p>

<p>3) Do following for all numbers from x = 2 to n.</p>

<p>¡­¡­a) Multiply x with res[] and update res[] and res_size to store the multiplication result.</p>

<p>How to multiply a number ¡®x¡¯ with the number stored in res[]?</p>

<p>The idea is to use simple school mathematics. We one by one multiply x with every digit of <code>res[]</code>. The important point to note here is digits are multiplied from rightmost digit to leftmost digit. If we store digits in same order in <code>res[]</code>, then it becomes difficult to update <code>res[]</code> without extra space. That is why <code>res[]</code> is maintained in reverse way, i.e., digits from right to left are stored.</p>

<p><strong>multiply(res[], x)</strong></p>

<p>1) Initialize carry as 0.</p>

<p>2) Do following for i = 0 to res_size ¨C 1</p>

<p>¡­.a) Find value of res[i] * x + carry. Let this value be prod.</p>

<p>¡­.b) Update res[i] by storing last digit of prod in it.</p>

<p>¡­.c) Update carry by storing remaining digits in carry.</p>

<p>3) Put all digits of carry in res[] and increase res_size by number of digits in carry.</p>

<p><strong>Example to show working of multiply(res[], x)
A number 5189 is stored in res[] as following.</strong></p>

<pre><code>res[] = {9, 8, 1, 5}
x = 10

Initialize carry = 0;

i = 0, prod = res[0]*x + carry = 9*10 + 0 = 90.
res[0] = 0, carry = 9

i = 1, prod = res[1]*x + carry = 8*10 + 9 = 89
res[1] = 9, carry = 8

i = 2, prod = res[2]*x + carry = 1*10 + 8 = 18
res[2] = 8, carry = 1

i = 3, prod = res[3]*x + carry = 5*10 + 1 = 51
res[3] = 1, carry = 5

res[4] = carry = 5
res[] = {0, 9, 8, 1, 5} 
</code></pre>

<p>Below is the implementation of above algorithm.</p>

<pre><code>// C++ program to compute factorial of big numbers
#include&lt;iostream&gt;
using namespace std;

// Maximum number of digits in output
#define MAX 500

int multiply(int x, int res[], int res_size)

// This function finds factorial of large numbers and prints them
void factorial(int n)
{
    int res[MAX];

    // Initialize result
    res[0] = 1;
    int res_size = 1;

    // Apply simple factorial formula n! = 1 * 2 * 3 * 4...*n
    for (int x=2; x&lt;=n; x++)
        res_size = multiply(x, res, res_size);

    cout &lt;&lt; ""Factorial of given number is n"";
    for (int i=res_size-1; i&gt;=0; i--)
        cout &lt;&lt; res[i];
}

// This function multiplies x with the number represented by res[].
// res_size is size of res[] or number of digits in the number represented
// by res[]. This function uses simple school mathematics for multiplication.
// This function may value of res_size and returns the new value of res_size
int multiply(int x, int res[], int res_size)
{
    int carry = 0;  // Initialize carry

    // One by one multiply n with individual digits of res[]
    for (int i=0; i&lt;res_size; i++)
    {
        int prod = res[i] * x + carry;
        res[i] = prod % 10;  // Store last digit of 'prod' in res[]
        carry  = prod/10;    // Put rest in carry
    }

    // Put carry in res and increase result size
    while (carry)
    {
        res[res_size] = carry%10;
        carry = carry/10;
        res_size++;
    }
    return res_size;
}

// Driver program
int main()
{
    factorial(100);
    return 0;
}
</code></pre>

<p>This links also may help you:</p>

<p><a href=""https://discuss.codechef.com/questions/7349/computing-factorials-of-a-huge-number-in-cc-a-tutorial"" rel=""nofollow noreferrer"">https://discuss.codechef.com/questions/7349/computing-factorials-of-a-huge-number-in-cc-a-tutorial</a></p>
",1
45292411,45292347,0,"<p>check here <code>while(t)</code> its in an infinite loop because you have to set a condition for <code>t</code> something like while(t==1) or while(t>1) or (t&lt;1) something like that. saying while(t) means that t can be anything and it will continue to run.</p>
",1
45292418,45292347,0,"<blockquote>
  <p>There is nothing in to break the while loop.</p>
</blockquote>

<p>consider getting rid of the boolean, and simply using a while (1) loop with a break. Also you should be using ""%d"" to indicate an integer in scanf/printf. And there is no need for the scanf call in the else, since your program would loop back and call scanf again anyway.</p>

<pre><code>#include &lt;stdio.h&gt;
int main() {
  int inp = 0;
  printf(""type an integer\n"");
  while (1) {
    if (scanf(""%d"", &amp;inp) == 1) { 
      printf(""The integer is %d"", inp);
      break;
    }
    else {
      printf(""try again"");
    }
  }
  return 0;
}
</code></pre>

<p>I hope this helped.</p>
",4
46950328,46949615,1,"<p><em>values in array before start loop: 1,3,4,6,7</em></p>

<p>The value for index is set at the top of each iteration of the for loop.<br>
So the first time through the loop, <code>index</code> is set to represent the value <code>1</code>.</p>

<ul>
<li>so <code>index-1</code> would hold the value <code>1-1</code>, or <code>0</code>  </li>
<li>so <code>array[index - 1]</code> is the same as <code>array[0]</code>  </li>
<li><code>array[0]</code> holds the value <code>1</code>. </li>
<li>hence <code>array[index - 1] + 2</code> is the same as <code>1 + 2</code>, or <code>3</code> </li>
<li>So then, we assign <code>array[index]</code> which we know to represent the <code>array[1]</code> which <em>used to hold the value of <code>3</code></em>, now is assigned to (again) hold the value <code>3</code>.  </li>
</ul>

<p><em>values in array at end of 1st time through the loop: 1,3,4,6,7</em></p>

<p>Now, back up to the top of the loop..
<code>index</code> is told to increment itself by <code>1</code><br>
ie: <code>index</code> <em>which was 1</em>, now represents the number <code>2</code>  </p>

<ul>
<li>so <code>index-1</code> would hold the value <code>2-1</code>, or <code>1</code>.  </li>
<li>so <code>array[index - 1]</code> is the same as <code>array[1]</code>,</li>
<li><code>array[1]</code> holds the value <code>3</code></li>
<li>so <code>array[index - 1]</code> + 2, is the equivalent of <code>3 + 2</code>, or <code>5</code>   </li>
<li>So then, we assign <code>array[index]</code> which we know to represent the element <code>array[2]</code> (<em>which used to hold the value of <code>4</code>)</em>, now is assigned to hold the value <code>5</code>.</li>
</ul>

<p><em>values in array at end of 2nd time through the loop: 1,3,5,6,7</em></p>

<p>etc.</p>

<pre><code>array      index  index-1  array[index-1] array[index-1]+2  array[index]
1,3,4,6,7  1      0        1              3                 array[1] = 3
1,3,4,6,7  2      1        3              5                 array[2] = 5
1,3,5,6,7  3      2        5              7                 array[3] = 7
1,3,5,7,7  4      3        7              9                 array[4] = 9
1,3,5,7,9  5      (exits for loop since condition fails)
</code></pre>

<p>final result: <code>1 3 5 7 9</code></p>

<blockquote>
  <p>Also, you can use an 'online c compiler' to test code snippets.  </p>
</blockquote>

<p>Here's one: <a href=""https://www.jdoodle.com/c-online-compiler"" rel=""nofollow noreferrer"">JDoodle</a></p>
",0
45093919,45093729,1,"<p><code>*((int *) arg) += 1</code> inside <code>produce(...)</code> causes the <code>segmentation fault</code>. Because <code>pthread_create(&amp;tid_produce[i], NULL,produce, NULL);</code> passes <code>NULL</code> as <code>arg</code>.</p>

<p>So we need to allocate some memory for <code>arg</code>.</p>

<pre><code>// main
int i, prod, con;
pthread_t tid_produce[MAXNTHREADS],  tid_consume[MAXNTHREADS];
int p_arg[MAXNTHREADS]; // &lt;======
// ...
for (i = 0; i &lt; prod; i++)
{
    pthread_create(&amp;tid_produce[i], NULL,produce, p_arg+i); // &lt;====
}
</code></pre>
",1
46116445,46116362,0,"<p>Because your main function is recursively calling itself, and giving itself too many parameters. You're also going to cause a stack overflow by recursively calling infinite times.</p>
",0
46117416,46116362,0,"<p>Well you are currently implementing a recursive function main with 2 arguments ( <strong>main(1,2)</strong> ) , but the main you have already written has no arguments ( <strong>main()</strong> ) , so the recursive method will never end. Although I cannot understand what are you trying to do , its generally a bad idea to implement recursive processes on your <strong>main</strong> function. In the end , you will run out of memory as the stack pointer will try to access prohibited segments of memory. So your program crushes.<br>
For future endeavours in the recursion process I suggest you to put a condition that when met the recursion will end.</p>
",0
46116647,46116362,4,"<p>Although you are allowed to call <code>main</code> from itself in C (note you are not allowed to in C++), you need to (i) ensure the parameter list is valid and, (ii) ensure you have a mechanism in place to prevent <em>infinite recursion</em>.</p>

<p>As you do neither of these, the behaviour of your program is <em>undefined</em>.</p>
",4
46116737,46116362,0,"<blockquote>
  <p>I understand that a segmentation fault occurs when the program tries to access the area of memory that it is not allowed to access. Which line of my code is accessing memory it is not allowed to access and why?</p>
</blockquote>

<p>To answer that question you need to understand how recursion is implemented in C and how the stack works.</p>

<p><a href=""https://www.youtube.com/watch?v=ygK0YON10sQ"" rel=""nofollow noreferrer"">Watch this video</a>. Although he doesn't tell you what happens when there is an infinite recursion, I am sure you can figure it out.</p>
",0
45042898,45042799,2,"<p>You can take the result you get back from <code>mktime</code> and convert it to milliseconds.</p>

<pre><code>if ((result = mktime(&amp;tv)) == (time_t)-1) {
    fprintf(stderr, ""Conversion Error\n"");
}
long long resultmilli = (result * 1000LL) + ms;
</code></pre>
",0
45043013,45042799,4,"<p>I don't understand why you need to convert those timestamps into a <code>struct tm</code>, or into any other representation. They will already lexicographically sort just the way you want, in their current string form. So just do that.</p>
",0
45055473,45055398,0,"<p>scanf() should never be used for user input. The best way to get input from the user is with fgets(). </p>

<p>Read more: <a href=""http://sekrit.de/webdocs/c/beginners-guide-away-from-scanf.html"" rel=""nofollow noreferrer"">http://sekrit.de/webdocs/c/beginners-guide-away-from-scanf.html</a></p>
",6
45056072,45055398,2,"<blockquote>
  <p>How to scan total line from user input with c program?</p>
</blockquote>

<p>There are many ways to <em>read</em> a line of input, and your usage of the word <em>scan</em> suggests you're already focused on the <code>scanf()</code> function for the job. This is unfortunate, because, although you can (to some extent) achieve what you want with <code>scanf()</code>, it's definitely not the best tool for reading a line.</p>

<p>As already stated in the comments, your <code>scanf()</code> format string will <em>stop</em> at a newline, so the next <code>scanf()</code> will first find that newline and it can't match <code>[^\n]</code> (which means anything <strong>except</strong> newline). As a newline is just another whitespace character, adding a blank in front of your conversion will silently <em>eat it up</em> ;)</p>

<p>But now for the better solution: Assuming you only want to use standard C functions, there's already one function for <em>exactly</em> the job of reading a line: <a href=""http://man7.org/linux/man-pages/man3/fgets.3p.html"" rel=""nofollow noreferrer""><code>fgets()</code></a>. The following code snippet should explain its usage:</p>

<pre><code>char line[1024];
char *str = fgets(line, 1024, stdin); // read from the standard input

if (!str)
{
    // couldn't read input for some reason, handle error here
    exit(1); // &lt;- for example
}

// fgets includes the newline character that ends the line, but if the line
// is longer than 1022 characters, it will stop early here (it will never 
// write more bytes than the second parameter you pass). Often you don't 
// want that newline character, and the following line overwrites it with
// 0 (which is ""end of string"") **only** if it was there:
line[strcspn(line, ""\n"")] = 0;
</code></pre>

<p>Note that you <strong>might</strong> want to check for the newline character with <a href=""https://linux.die.net/man/3/strchr"" rel=""nofollow noreferrer""><code>strchr()</code></a> instead, so you actually know whether you have the whole line or maybe your input buffer was to small. In the latter case, you might want to call <code>fgets()</code> again.</p>
",0
45108349,45055398,1,"<blockquote>
  <p>How to scan total line from user input with c program?</p>
</blockquote>

<p><code>scanf(""%99[^\n]"",st)</code> reads a <em>line</em>, almost.</p>

<p>With the C Standard Library a <em>line</em> is</p>

<blockquote>
  <p>A text stream is an ordered sequence of characters composed into <em>lines</em>, <strong>each line consisting of zero or more characters plus a terminating new-line character</strong>.  Whether the last line requires a terminating new-line character is implementation-defined.  C11dr  ¡ì7.21.2 2</p>
</blockquote>

<p><code>scanf(""%99[^\n]"",st)</code> fails to read the end of the line, the <code>'\n'</code>.</p>

<p>That is why on the 2nd call, the <code>'\n'</code> remains in <code>stdin</code> to be read and <code>scanf(""%99[^\n]"",st)</code> will not read it.</p>

<p>There <em>are</em> ways to use  <code>scanf(""%99[^\n]"",st);</code>, or a variation of it as a step in reading user input, yet they suffer from 1) Not handling a blank line <code>""\n""</code> correctly 2) Missing rare input errors 3) Long line issues and other nuances.</p>

<hr>

<p>The preferred portable solution is to use <code>fgets()</code>.  Loop example:</p>

<pre><code>#define LINE_MAX_LENGTH 200
char buf[LINE_MAX_LENGTH + 1 + 1];  // +1 for long lines detection, +1 for \0
while (fgets(buf, sizeof buf, stdin)) {
  size_t eol = strcspn(buf, ""\n"");  **
  buf[eol] = '\0';  // trim potential \n
  if (eol &gt;= LINE_MAX_LENGTH) {
    // IMO, user input exceeding a sane generous threshold is a potential hack
    fprintf(stderr, ""Line too long\n"");
    // TBD : Handle excessive long line
  }

  // Use `buf[[]`
}
</code></pre>

<hr>

<p>Many platforms support <a href=""http://man7.org/linux/man-pages/man3/getline.3.html"" rel=""nofollow noreferrer""><code>getline()</code></a>  to read a line.   </p>

<p>Short-comings: Non C-standard and allow a hacker to overwhelm system resources with insanely long lines.     </p>

<hr>

<p>In C, there is not a <em>great</em> solution.  What is best depends on the various coding goals.</p>

<hr>

<p>** I prefer <code>size_t eol = strcspn(buf, ""\n\r"");</code> to read lines in a *nix environment that may end with <code>""\r\n""</code>.</p>
",0
46968055,46967120,1,"<p>I'd strongly suggest that you first read about the basics of pointers and arrays. Check out <a href=""https://www.tutorialspoint.com/cprogramming/c_pointer_to_an_array.htm"" rel=""nofollow noreferrer"">this article</a>.</p>

<p>An array like <code>char y[]</code> is organised as a contiguous set of <code>char</code> elements, and a pointer called <code>y</code> points to the first element of the array. Since this pointer points to a <code>char</code> type, the type of the pointer itself is <code>char *</code>.</p>

<p>Thus, when you say <code>return y</code>, you are not returning the contents of the array <code>y</code> - you are returning the value of <code>y</code>, which is an address to the first element of the <code>y</code> array.</p>

<p>So the return type of your function should be <code>char *</code>.</p>
",0
46978789,46978627,0,"<p>For the given input <code>( 2 % a b ( r ) ? ( (</code>, the program takes the first character <code>(</code> as input to variable <code>standart</code> -</p>

<pre><code>scanf(""%c"", &amp;standart);
</code></pre>

<p>The problem is occurring because in the first iteration of <code>for</code> loop the <code>scanf</code> was reading the first whitespace character (a blank space) from given input that exists after <code>(</code> and storing it into <code>input[0]</code>.
The <code>for</code> loop runs for 10 iterations and the last character <code>(</code> is not inserted in the <code>input</code> array because of which the <code>standart</code> character count in <code>input</code> array is coming one less than expected i.e. 2.</p>

<p>Change the <code>for</code> loop <code>scanf</code> statement to -</p>

<pre><code>scanf("" %c"", &amp;input[i]); //Removed the space after %c and added a space before %c.
</code></pre>

<p>With this, the for loop <code>scanf</code> will eat whitespaces characters. 
So, the next character from input - <code>2</code> will be stored to <code>input[0]</code> and <code>%</code> will be stored to <code>input[1]</code> and so on and the last character '(' will be stored to <code>input[9]</code>.
And the <code>b</code> will have the correct <code>standart</code> character count in <code>input</code> array i.e. 3.</p>
",0
46980251,46978627,0,"<p>You have to do it like this <code>scanf("" %c"",&amp;c);</code><br/>
Because it reads '\n' from previous input, so the space will skip the '\n'</p>
",0
46088254,46087148,0,"<p>The array of 2 booleans, <code>flag</code>, must be in shared memory for this to have a chance of working.  For processes, that is crucial; if these were threads, you'd not need shared memory.</p>

<p>Initially, neither process 0 or 1 has set its <code>flag</code> value to <code>true</code>.</p>

<p>Suppose process <code>i = 0</code> tries to gain access to the critical section. The first busy loop (<code>while</code> loop) waits until <code>flag[1]</code> is <code>false</code> (and it is false at the moment); then the code sets <code>flag[0] = true</code>.  The code now enters the second busy loop; <code>flag[1]</code> is still <code>false</code>, so it goes ahead and enters the critical section safely, knowing that the other process is not in the critical section either.</p>

<p>Suppose that while process 0 is in the critical section, process 1 tries to enter it too.  It is blocked in the first busy loop because <code>flag[0]</code> is true.  It remains like that until process 0 leaves and sets <code>flag[0]</code> back to false.  When process 0 leaves, process 1 sets <code>flag[1]</code> to true, enters the second busy loop, and then leaves because <code>flag[0]</code> is false; it is now in the critical section.</p>

<p>Why the two busy loops?  Because it might happen that the two processes are running on multiple cores at the same time, and both might enter the first busy loop at the same time.  They would both see that the other's flag is false, exit the loop and set their own flag to true, and recheck that the other's is still false.  Most of the time, one of them would see that the other's is false and would enter the critical section.  Occasionally, they might both spot that the other's is true (because they were working so much in lock-step), and then both would enter the second busy-loop, and neither would exit ¡ª deadlock.</p>

<p>So, I'm not convinced that the code is a foolproof mutual exclusion mechanism, though it would require bad luck to get into deadlock.  However, given enough attempts, bad luck will occur ¡ª long-running processes can't afford the risk.</p>
",0
45277967,45277687,3,"<p>You have Segmentation fault (core dumped) error due to this line:</p>

<pre><code>scanf(""%i"", inp);
</code></pre>

<p><strong>scanf</strong> method takes pointers as arguments. Now program is trying to write new value to memory which is not reserved for our program.</p>

<p>You should replace this line by:</p>

<pre><code>scanf(""%i"", &amp;inp);
</code></pre>
",0
45278268,45277687,3,"<p>One of the problems with your code is that you are incorrectly using <code>scanf</code>. The first parameter of <code>scanf</code> is a format string, and any additional parameter should be a pointer, so:</p>

<pre><code>// Incorrect
scanf(""%i"", inp);

// Correct
scanf(""%i"", &amp;inp);
</code></pre>

<p>Segmentation faults happen when you are trying to access a memory address that is either invalid or you don't have the rights to access. Suppose you run your program, and the first number you write is 3, so <code>inp = 3</code>. Up until this point, everything runs OK, since you are reading the first number using <code>getchar</code>. But then, you use <code>scanf(""%i"", inp)</code> so <code>scanf</code> will write the next number at address <code>inp</code>, i.e, at address <code>3</code>, which is an address you cannot write in! Thus you get a segmentation fault.</p>

<hr>

<p>There is another error in your code, a logic error though. You read your first number by using <code>getchar</code>: what if you want to input a number larger than 9? You should use <code>scanf</code> for the first read too.</p>

<pre><code>...
printf(""The secret number is between 0 and 19, take a guess\n"");
int inp;

// Not good
inp = getchar();

// Good
scanf(""%i"", &amp;inp);
...
</code></pre>

<hr>

<p>Also, your <code>while</code> loop will never end, i.e., your program will run forever (unless you kill it). Indeed whenever this <code>if</code> block is executed:</p>

<pre><code>if (inp == x) {
    printf(""Correct. Total number of guesses you spent was %i. Would you like to start a new game? Y/n"", c);
    bool running = 0;
}
</code></pre>

<p>You declare a new variable <code>bool running</code> that overwrites the previously declared <code>running</code> variable. You should just replace it with:</p>

<pre><code>if (inp == x) {
    printf(""Correct. Total number of guesses you spent was %i. Would you like to start a new game? Y/n"", c);
    running = 0;
}
</code></pre>
",3
45278523,45277687,1,"<p>In addition to the previous answers, which correctly point out the reason for the segmentation fault, you have many more problems.  The below does (I think) what you need:</p>

<pre><code>int main()
{
    int c = 1;
    bool running = 1;
    srand(time(0));
    int x = rand() % 20;
    printf(""The secret number is between 0 and 19, take a guess\n"");
    int inp;
    scanf(""%i"", &amp;inp);
    while (running) {
        if (inp == x) {
            printf(""Correct. Total number of guesses you spent was %i. Would you like to start a new game? Y/N"", c);
            char a;
            scanf("" %c"", &amp;a);
            if (a == 'N' || a == 'n')
            {
                running = 0;
            }
            else
            {
                c = 0;
                srand(time(0));
                x = rand() % 20;
                printf(""The secret number is between 0 and 19, take a guess\n"");
                scanf(""%i"", &amp;inp);
            }
        }
        else if (inp&gt;x) {
            printf(""guess smaller\n"");
            scanf(""%i"", &amp;inp);
        }
        else if (inp&lt;x) {
            printf(""guess larger\n"");
            scanf(""%i"", &amp;inp);
        }
        c += 1;
    }
}
</code></pre>

<p>Things to note.  You need to give a seed value before calling rand() otherwise you will get a sequence of numbers in the same order.  Usually current time is a good enough seed.  Secondly you need to read in the answer to the question whether the user wished to continue or not and act accordingly.  Here you must not re-define running (with bool) otherwise you create a new variable rather than replace the value in the higher level variable.  Also note the use of a white space when prompting for a char ("" c%"").  This is necessary to avoid the program seeming to skip the input. Finally, you need to reset the counter and x if the user opts to continue.</p>
",5
46625160,46625065,1,"<p>Some will argue that the exact width of a float is unspecified by the <code>C standard</code> and therefore implementation-dependent, but on any platform you are likely to encounter a <code>C float</code> means an <a href=""https://en.wikipedia.org/wiki/IEEE_754"" rel=""nofollow noreferrer"">IEEE754</a> <a href=""https://en.wikipedia.org/wiki/Single-precision_floating-point_format"" rel=""nofollow noreferrer"">single-precision</a> number.</p>

<p>It's a lot of math over there if you are interested, but, in a nutshell, a <code>float</code> can store about <code>7-8 significant decimal digits</code>. Let me illustrate this with an example:</p>

<pre><code>2073741824.0; // float
       ^^^ ^ // all this information is most likely lost
</code></pre>

<p>By <strong>most likely</strong> I mean that you should <strong>NEVER</strong> assume that the program will remeber those digits.</p>

<pre><code>2073741xxx.x; // float
       ^^^ ^ // this is how you should treat you number form a safe programmer's prespective
</code></pre>
",2
46625246,46625065,3,"<p><code>-2073741714.0</code> is not typically <em>exactly</em> representable as a <code>float</code>.  Use wider types or accept imprecision.  <code>float</code> as a 32-bit variable can not exactly encode <em>every number</em>, just about 2<sup>32</sup> of them. The typical closest one is <code>-2073741696</code></p>

<pre><code>float b4 = -2073741714.0;
printf(""b4 = %f\n"", b4);
// typical output
// b4 = -2073741696.000000
</code></pre>

<p>Instead consider either wider  FP types.</p>

<pre><code>int main(void) {
  double b1 = 23.0;
  double b2 = 42.0;
  double b3 = 2073741824.0;
  double b4 = -2073741714.0;
  double b5 = -64.0;
  double b6 = -111.0;
  double be;
  printf(""b4 = %f\n"", b4);

  be = b1 + b2 + (b3 + b4) + b5 + b6;
  printf(""Das Float Ergebnis ist:   %f\n"", be); // Das Float Ergebnis ist:   0.000000
  return (EXIT_SUCCESS);
}
</code></pre>

<p>Or use wider math</p>

<pre><code>int main(void) {
  float b1 = 23.0;
  float b2 = 42.0;
  float b3 = 2073741824.0;
  double b4 = -2073741714.0;
  float b5 = -64.0;
  float b6 = -111.0;
  float be;
  printf(""b4 = %f\n"", b4);

  be = b1 + b2 + (b3 + b4) + b5 + b6;
  printf(""Das Float Ergebnis ist:   %f\n"", be); // Das Float Ergebnis ist:   0.000000
  return (EXIT_SUCCESS);
}
</code></pre>

<p>A 3rd choice is to re-arrange the evaluation order.  This will help, yet not overcome limitations of <code>float</code>.</p>

<pre><code>int main(void) {
  float b1 = 23.0;
  float b2 = 42.0;
  float b3 = 2073741824.0;
  float b4 = -2073741714.0;
  float b5 = -64.0;
  float b6 = -111.0;
  float be;

  be = b1 + b2 + (b3 + b4) + b5 + b6;
  printf(""Das Float Ergebnis ist:   %f\n"", be);  // Das Float Ergebnis ist:   18.000000
  return (EXIT_SUCCESS);
}
</code></pre>
",0
45723238,45723132,0,"<p>I think it is seeing the newline character that was produced due to hitting the enter key. <code>gets</code> then stops reading. Try eating those special characters before <code>gets</code> sees them. Or use scanf with <code>%s</code> which eats any leading whitespace as you have seen it works.</p>
",6
48022358,48022341,1,"<p>Well when you input character, <code>scanf</code> actually tries to get those wrong character inputs from the <code>stdin</code> but as it is not as per the conversion specification provided it fails. And then it keeps those wrong input in the stdin. And next time the <code>scanf</code> fails again due to those wrong inputs. So you need to clear it before you attempt to get the input again using <code>scanf</code>. Also check the return value of <code>scanf</code> and in case it failed clear the <code>stdin</code>.</p>

<p>The provided code checks for <code>EOF</code> and also return value of <code>scanf</code> the standard says explicitly about the return value of <code>scanf</code> :-</p>

<p><strong><a href=""http://port70.net/~nsz/c/c11/n1570.html#7.21.6.2p16"" rel=""nofollow noreferrer"">7.21.6.2p16</a></strong></p>

<blockquote>
  <p>The <code>fscanf</code> function returns <strong><em>the value of the macro <code>EOF</code> if an
  input failure occurs before the first conversion (if any) has
  completed</em></strong>. Otherwise, the function <em>returns the number of input
  items assigned</em>, which can be fewer than provided for, or <strong><em>even
  zero, in the event of an early matching failure</em></strong>.</p>
</blockquote>

<p>The code will be something like <strong><a href=""https://stackoverflow.com/questions/48012277/validation-check-with-scanf-does-not-work-inside-a-loop/48012671#48012671"">this</a></strong>. (This is using <code>scanf</code>).</p>

<p>Better even use <code>fgets</code>. you can easily and more better way control the erro neous inputs. With <code>fgets</code> you will read the entire line and then parse the integer input from it using <code>strtol</code> or <code>strtoul</code>. Yes in case of integer input there will be a case there also - you need to check if the parsed long or unsigned long is of proper size so that they can be kept in <code>int</code> variable.</p>
",2
47560316,47559450,1,"<p>I'm not sure what language this is, but I'll assume that dalsi translates to next (if not, add a <code>struct auta *next</code> at the end of the structure).   I'm also assuming you're a beginner so I'll go over some of what I'm doing below:</p>

<pre><code>AUTA *pStart = NULL;   // keep track of start of list:
AUTA **pp = &amp;pStart;   // set a pointer to the pointer of the active entry

while (!feof(fr)) {
    fgets(z[0],5,fr);
    if (feof(fr))
           break;
    if (strcmp(z[0],""$"") != 0) 
           continue;   // non $ sign -- not start of record... ignore line
    // allocate record:
    *pp = malloc(AUTA*)malloc(sizeof(AUTA))
    if (*pp == NULL) {   // double check that malloc succeeded
        sprintf(stderr, ""Out of memory\n""); 
        exit -1;
    }
    // read in record -- note pp points to the pointer to the 
    // record, so you want to access (*pp)-&gt; ...
    fgets((*pp)-&gt;kategoria,50,fr);
    fgets((*pp)-&gt;znacka,50,fr);
    fgets((*pp)-&gt;predajca,100,fr);
    fscanf(fr,""%d"",&amp;(*pp)-&gt;cena);
    fscanf(fr,""%d\n"",&amp;(*pp)-&gt;rok_vyroby);
    fgets((*pp)-&gt;stav_vozidla,200,fr);
    (*pp)-&gt;dalsi = NULL;   // in case this is the last entry...
    pp = &amp;(*pp)-&gt;dalsi;
}
</code></pre>

<p>This solution used double indirection (a pointer to a pointer), which is a bit to take in if you're new.   I would suggest drawing a diagram if you're having trouble getting your head around it.   Basically, we start with a pointer to the first record (<code>pStart</code>).   <code>pStart</code> starts off as <code>NULL</code>.  You then have a pointer to the pointer to the first entry (that is, <code>pp</code> points to <code>pStart</code>.  You then start looping.   If you find a <code>$</code>, you start reading.  First, you allocate memory for a new record and set <code>*pp</code> to point to that (remember that <code>pp</code> pointed to <code>pStart</code>, ergo now <code>*pp</code> or <code>pStart</code> points to the new record.   You then scan in that record.   When you're done, you set <code>pp</code> to point to the next pointer (<code>dalsi</code>) of the current record, and loop.  The second iteration of the loop will populate <code>pStart-&gt;dalsi</code> to point to the next record, so you end up with:</p>

<pre><code> pStart ------&gt; (record1)     +---&gt; (record2)    +---&gt; (record3)
                  \ dalsi  ---+       \dalsi  ---+         \dalsi --&gt; NULL
</code></pre>
",5
45661439,45661322,1,"<p>When you are doing     </p>

<pre><code>if (nr &lt; 0)
{
    print_char('-');
    nr *= -1;
}
</code></pre>

<p>It inverses negative number to the positive one.
If you will run it for -2.147.483.648, you will receive</p>

<pre><code>nr = 2.147.483.648 // == binary 1 0000000000000000000000000000000
</code></pre>

<p>As INT is 32 BIT variable in your architecture (and at least 16 BIT variable by the spec), so '1' overflows it and so on </p>

<pre><code>nr = 0 // For gcc-like C realisation
</code></pre>

<p>And accepting the ISO9899 spec, this behaviour of signed int overflow is realisation-specified thing and may not be predicted in common.</p>

<p>Use long long value if you're needing to use your program for larger values.
Something like:</p>

<pre><code>#include&lt;stdio.h&gt;

void    print_char(char character)
{
    printf(""%c"",character);
}

void    print_number(long long nr)
{
    int reverse=0;

    if (nr &lt; 0)
    {
        print_char('-');
        nr *= -1;
    }

    while(nr &gt; 9)
    {
        reverse = reverse * 10 + nr % 10;
        nr = nr / 10;
    }
    print_char(nr + '0');

    while(reverse)
    {
        print_char(reverse % 10 + '0');
        reverse = reverse / 10;
    }
}

void main(void){
    print_number(-2147483648LL);
}
</code></pre>

<p>And test:</p>

<pre><code>&gt; gcc test.c
&gt; ./a.out 
-2147483648
</code></pre>
",18
45661816,45661322,1,"<p>Firstly, the MAX and MIN range for an INT are <code>-2,147,483,648</code> and <code>2,147,483,647</code> respectively.
<br> Negating <code>-2,147,483,648</code> means a positive value <code>2,147,483,648</code> would result in an overflow by 1 as it is out of bounds for the MAX range. 
This operation will result in the same value of <code>-2,147,483,648</code>.</p>

<p>Secondly, you might encounter an overflow during the integer reversing process.<br>
Example, reversing <code>2147483647</code> causes an overflow after the intermediate result of <code>746384741</code>.<br>
Therefore, you should handle that by throwing an exception or returning 0.</p>

<p>Thirdly, your loop for reversing the number is inaccurate. It should loop till <code>while(nr != 0)</code></p>

<p>Here's the complete code.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

int main()
{
    void reverseNumber(int);

    reverseNumber(124249732);
    return 0;
}

void reverseNumber(int nr)
{
    printf(""nr = %d\n"", nr);

    int reverse = 0;
    bool neg = false;
    if (nr &lt; 0) {
        neg = true;
        nr *= -1;
    }

    while (nr != 0) {
        int digit = nr % 10;
        int result = reverse * 10 + digit;

        if ((result - digit) / 10 != reverse) {
            printf(""ERROR\n"");
            exit(0);
        }

        reverse = result;
        nr = nr / 10;
    }

    if(neg) {
        printf(""%c"", '-');
    }
    printf(""%d\n"", reverse);
}
</code></pre>
",1
47452967,47433572,0,"<p>some suggestions were given in the comments already. define the size of the arrays and reuse the defines in the loops do avoid overflows.
at first calculate the averages and memorize the maximum value.
then you can easily output them comparing your maximum value to the memorized avg values.</p>

<pre><code>#define D  3
#define C  10
    float num[D][C] = {
        {5.0, 8.0, 7.5, 4.5, 9.0, 9.0, 6.5, 3.0, 4.5, 8.5},
        {6.0, 8.5, 7.0, 5.0, 9.5, 9.5, 6.5, 2.5, 5.0, 7.5},
        {5.5, 8.0, 6.5, 7.5, 9.5, 9.5, 6.5, 4.0, 5.5, 9.5},
    };
    float avg[C]; /*will hold all the average values*/
    float max = 0; /*will hold the maximum vlaue*/
    int i, j;
    for (i = 0; i &lt; C; i++) {
        float sum = 0;
        /*sum columns*/
        for (j = 0; j &lt; D; j++) {
            sum += num[j][i];
        }
        /*memorize calculated avg*/
        avg[i] = sum / D;
        /*check if maximum*/
        if (max &lt; avg[i])
            max = avg[i];
    }
    /*output index and average*/
    for (i = 0; i &lt; C; i++)
        if (avg[i] == max)
            printf(""%0.2f %d\n"",max,i);
</code></pre>
",0
45785072,45784869,0,"<p>strcmp() is responsible for lexicographic comparison of strings(character order).i.e.first character compared with first character if equal then second and so on.
Its signature is as follows:</p>

<pre><code>int strcmp(const char *str1, const char *str2)
</code></pre>

<p><a href=""http://forgetcode.com/C/1026-strcmp-lexicographically-compares-two-strings"" rel=""nofollow noreferrer"">http://forgetcode.com/C/1026-strcmp-lexicographically-compares-two-strings</a>
<a href=""https://www.tutorialspoint.com/c_standard_library/c_function_strcmp.htm"" rel=""nofollow noreferrer"">https://www.tutorialspoint.com/c_standard_library/c_function_strcmp.htm</a></p>

<p>This function return values that are as follows:</p>

<p>if Return value &lt; 0 then it indicates str1 is less than str2.</p>

<p>if Return value > 0 then it indicates str2 is less than str1.</p>

<p>if Return value = 0 then it indicates str1 is equal to str2.</p>
",0
45785300,45784869,1,"<p>The code is just a joke... </p>

<p>It just compares two fixed strings. To make it confusing the two strings contain the name of a library function (strcmp) but that - of cause - doesn't make it a function call.</p>

<p>The code</p>

<pre><code>printf(""%d"",strcmp(""strcmp()"",""strcmp()""))
</code></pre>

<p>is similar to</p>

<pre><code>printf(""%d"",strcmp(""A"",""A""))
</code></pre>

<p>It will print <code>0</code> (zero) as the strings are identical and <code>strcmp</code> return zero when strings have an exact compare.</p>
",0
45707948,45707881,4,"<p>This line</p>

<pre class=""lang-none prettyprint-override""><code>==4545==  Address 0x0 is not stack'd, malloc'd or (recently) free'd
</code></pre>

<p>tells you you're dereferencing a <code>NULL</code> pointer (Address <code>0x0</code> ...)!</p>

<p>With the code you show, this can only mean <code>fopen</code> failed and returned <code>0</code>/<code>NULL</code>. Always check the return values of your function calls.</p>
",8
46027503,46027254,0,"<p>Your code has a lot of problems, I hope I will catch all.</p>

<pre><code>unsigned char fancyMostFrequentChar(unsigned char c, ...) // resolve ambigity of char
{
    unsigned char j = '\0';   // was not initialized 
    int max = 0;
    int fre[256] = {0};    // max unsigned char is 255 -&gt; array length = 256 (0..255)
    unsigned char temp;
    va_list argp;

    if (c == '\0')
        return '\0';
    va_start(argp, c);

    //This for loop will run through the arguments
    //and record their frequencies into fre[] array
    while ((temp = va_arg(argp, unsigned char)) != '\0')
    {
        ++fre[temp];
        if (fre[temp] &gt; max)
        {
            max = fre[temp];
            j = temp;
        }
    }

    va_end(argp);

    return j;
}
</code></pre>
",3
46027640,46027254,2,"<p>You should definitely make <code>temp</code> an <code>unsigned char</code> or use a cast as you use it to index into the array <code>fre</code>. <code>char</code> can be, and often is, signed by default so any negative values would access outside the boundaries of the array. By the way, you should make <code>fre</code> one item larger to accommodate for all 8-bit values, including <code>255</code>.</p>

<p>Note that you do not count the first argument, so <code>fancyMostFrequentChar('a', 'b', 'a', '\0')</code> would return <code>'b'</code> instead of <code>'a'</code>.</p>

<p>Note also (as commented by M.M) that the first argument should be defined as <code>int</code> for <code>va_start</code> to have defined behavior:</p>

<blockquote>
  <p><strong>7.16.1.4 The <code>va_start</code> macro</strong></p>
  
  <p><strong>Synopsis</strong></p>

<pre><code>#include &lt;stdarg.h&gt;
void va_start(va_list ap, parmN);
</code></pre>
  
  <p><strong>Description</strong></p>
  
  <p>The <code>va_start</code> macro shall be invoked before any access to the unnamed arguments.</p>
  
  <p>The <code>va_start</code> macro initializes <code>ap</code> for subsequent use by the <code>va_arg</code> and <code>va_end</code> macros. [...]</p>
  
  <p>The parameter <code>parmN</code> is the identifier of the rightmost parameter in the variable parameter list in the function definition (the one just before the , ...). If the parameter <code>parmN</code> is declared with the <code>register</code> storage class, with a function or array type, or with a type that is not compatible with the type that results after application of the default argument promotions, the behavior is undefined.</p>
</blockquote>

<p>You mention you are not supposed to change the prototype... Unfortunately the prototype as posted <code>char fancyMostFrequentChar(char c, ...)</code> cannot be used to access the arguments past the first one.</p>

<p>Here is a corrected version:</p>

<pre><code>char fancyMostFrequentChar(int c, ...) {
    int fre[256] = { 0 };
    char temp, res = (char)c;

    if (res != '\0') {
        va_list argp;
        va_start(argp, c);

        ++fre[(unsigned char)res];    
        //This for loop will run through the arguments
        //and record their frequencies into fre[] array
        while ((temp = va_arg(argp, char)) != '\0') {
            if (++fre[(unsigned char)temp] &gt; fre[(unsigned char)res]) {
            res = temp;
        }
        va_end(argp);
    }
    return res;
}
</code></pre>
",0
46028233,46027254,1,"<p><code>va_arg(argp, char)</code> is undefined behaviour.  The use of <code>va_arg</code> macro requires that the type be unchanged under the <a href=""http://en.cppreference.com/w/c/language/conversion#Default_argument_promotions"" rel=""nofollow noreferrer"">default argument promotions</a> -- which means you can't use <code>float</code>, nor any integer type narrower than <code>int</code>. (Character types are integer types).  Reference: C11 7.16.1.1/2</p>

<p>It is also undefined behaviour to have the second argument to <code>va_start</code> be of a type that changes under the default argument promotions. So it is actually impossible to correctly access the variadic arguments for a function declared as <code>char fancyMostFrequentChar(char c, ...)</code>.</p>

<p>To fix this you <strong>must</strong> change the prototype of the function, for example:</p>

<pre><code>char fancyMostFrequestChar(int c, ...)
</code></pre>

<p>and the relevant part of your loop should be:</p>

<pre><code>int temp;

while ((temp = va_arg(argp, int)) != '\0')
{
    unsigned char index = (unsigned char)temp;
</code></pre>

<p>and then use <code>index</code> as your array index. It is then guaranteed to be in the range of <code>1</code> through to <code>UCHAR_MAX</code> (which is usually <code>255</code>).  For pedantic correctness you could change your array definition to be <code>int fre[UCHAR_MAX+1]</code>.</p>
",0
46028569,46027984,0,"<p>It looks like there's an integer overflow in the case.</p>

<p>As <a href=""https://stackoverflow.com/questions/46027984/i-get-incorrect-values-when-printing-fibonacci-numbers-from-the-93rd-value-upwar#comment79016260_46027984""><em>Steve Summit</em> suggested in comments</a>,</p>

<pre><code>fib[93] = 12,200,160,415,121,876,738 = 64 bits
max_uint64 = 18,446,744,073,709,551,615
</code></pre>

<p>So it's sure that <code>fib[94]</code> will cause an int overflow because it's larger than 2<sup>64</sup>.</p>

<p>You can use <a href=""https://en.m.wikipedia.org/wiki/Arbitrary-precision_arithmetic"" rel=""nofollow noreferrer"">arbitrary-precision arithmetics</a> if you want a super big number.</p>
",0
46028644,46027984,2,"<p>If you are only interested in the last digit of the Fibonacci numbers, do the computations modulo 10:</p>

<pre><code>#include &lt;stdio.h&gt;

int fibonacciSum(int n);

int main(void) {
    int n = 0;
    if (scanf(""%d"", &amp;n) == 1) {
        printf(""%d\n"", fibonacciSum(n));
    }
    return 0;
}

int fibonacciSum(int n) {
    if (n &lt;= 1)
        return n;
    int previous = 0;
    int current  = 1;
    for (int i = 1; i &lt; n; i++) {
         printf(""fib(%d) % 10 = %d\n"", i, current);
         int tmp_previous = previous;
         previous = current;
         current = (tmp_previous + current) % 10;
    }
    return current;
}
</code></pre>

<p>If you also want the complete numbers, you should use a multiprecision package (also called bignum) as Fibonacci numbers exceed 64 bits from the 93rd on.</p>

<p>You could write a simplistic one to handle addition of positive numbers only, stored as allocated strings of decimal digits. An interesting challenge for the next 24 hours, I shall post a simple program here then.</p>
",0
46041466,46041367,3,"<p>You declare an array <code>test</code>, and you pass it to the function <code>Encap</code>.  Your question is a little unclear, but there are two things which may be surprising you:</p>

<ol>
<li>Within the function <code>Encap</code>, you are modifying the contents of the array.</li>
<li>After the function <code>Encap</code> returns, back in the caller, the modifications to the <code>test</code> array persist.</li>
</ol>

<p>(You also asked about ""rvalue"", which can be an important concept, but it doesn't apply here in the way that you expect.)</p>

<p>The reason this works the way it does is because of two different things:</p>

<ol>
<li>When you pass the array <code>test</code> to the function <code>Encap</code>, you do not pass the entire value of the array. what actually gets passed is just a pointer to the array;s first element.</li>
<li>Within the function <code>Encap</code>, you are not modifying the pointer that was passed, instead, you are modifying the memory that the pointer points to.  You are using the pointer as a value (a pointer value) to know where the memory is that you should modify -- and this ends up being the <code>test</code> array up in <code>main()</code>.</li>
</ol>
",2
46041530,46041367,2,"<p>You are passing pointer to function, It will surely change value at the memory location.
As you are passing pointer, another copy of pointer will be created and which will be used in function.(Whenever we call to a function, copy of variable is made and operations are done on that copy variable). Here the variable is of type pointer, hence another pointer variable will be created which will be pointing to same memory locations as pointed by test but will be having different address.
That's why two different memory address gets printed as you are printing address of two different pointers.</p>
",2
46943832,46943802,5,"<p>Yes, it's part of multi-line comment syntax <code>/*insert comment here*/</code></p>
",1
46981072,46980733,2,"<p>The code is invoking <em>undefined behavior</em>. The <code>fprintf</code> specification from the <a href=""http://port70.net/~nsz/c/c11/n1570.html#7.21.6.1"" rel=""nofollow noreferrer"">C Standard</a> is stating (the emphasis is mine):  </p>

<p>For <code>%x</code></p>

<blockquote>
  <p>o,u,x,X<br>
   -- The <strong>unsigned int</strong> argument is converted to unsigned octal (o), unsigned decimal 
     (u), or unsigned hexadecimal notation (x or X) in the style dddd;</p>
</blockquote>

<p>And for <code>%p</code>:</p>

<blockquote>
  <p>p<br>
    The argument shall be a <strong>pointer to void</strong>. The value of the pointer is
  converted to a sequence of printing characters, in an
  implementation-defined manner.</p>
</blockquote>

<p>And then <a href=""http://port70.net/~nsz/c/c11/n1570.html#7.21.6.1p9"" rel=""nofollow noreferrer"">here</a>:</p>

<blockquote>
  <p>If any argument is not the correct type for the corresponding
  conversion specification, <strong>the behavior is undefined</strong>.</p>
</blockquote>

<p>You are feeding both specifiers it with a non-void pointers, which are definitely not the correct type for the conversion specification.</p>

<p><strong>Update</strong></p>

<p>As suggested by @chux the fully compliant call will look as following:</p>

<pre><code>printf(""argc: addr=%x addrp=%p val=%x\n"", 
    (unsigned)(uintptr_t)(void*) &amp;argc, (void*)&amp;argc, (unsigned)argc);
</code></pre>
",4
46981157,46980733,2,"<p>Because pointers are not integers.</p>

<p>Pointers are <em>pointers</em>.  The right way to printf a pointer is using <code>%p</code>.</p>

<p>You might think you know that pointers are just integers.  (Back in the day, pointers <em>were</em> just integers.)  If you know what you're doing, you can still probably get away with treating pointers as integers, but you have to know what you're doing.</p>

<p>For example, you have to know how big your pointers actually are.  They might not be the same size as plain <code>int</code>, especially if you're on a so-called 64-bit platform.</p>

<p>So if <code>%x</code> doesn't work, you might be able to get away with <code>%lx</code>, or <code>%llx</code>.  But, most of the time, it's easier (and more portable) to just use <code>%p</code>.</p>
",0
46980890,46980733,2,"<p><code>%x</code> prints an <code>unsigned int</code>, which on most modern platforms, is 32-bits.</p>

<p><code>%p</code> prints a platform-specific pointer value.<br>
Some platforms are 32-bit, some are 64-bit (there may be other sizes too)</p>

<p><code>sizeof(unsigned int)</code> is often equal to <code>sizeof(void*)</code>, but it is not guaranteed at all, and it is common to see 32-bit <code>unsigned int</code> with 64-bit <code>void*</code>.<p>
As a result, <code>%x</code> and <code>%p</code> print different widths.</p>
",3
46661977,46661897,1,"<p>No, this is not a correct syntax in C. </p>

<p>You must write it like : </p>

<pre><code>for ( int i = 0; i &lt; 5 ; i++ )
{
    printf(""Value of i: %d\n"", i);
}
</code></pre>

<p>For more information: 
<a href=""https://www.tutorialspoint.com/cprogramming/c_for_loop.htm"" rel=""nofollow noreferrer"">https://www.tutorialspoint.com/cprogramming/c_for_loop.htm</a></p>
",0
47486301,47486250,2,"<p>The code doesn't work because there is no guarantee that duplicate's will appear consecutive manner. your code handles that not the other ways. That's why it fails.</p>

<p>A simple solution would be to consider a 10 element array where you will keep count of which element appeared and which didn't.</p>

<p>The idea is to map the digits to the array indices of the 10 element array. Intialized with <code>0</code>. </p>

<pre><code>...
int digitAppeared[10]={0};
while (number)
{
    digit = number % TEN; //breaking number into digits
    number /= TEN;
    digit_sum  += (1 - digitAppeared[digit]) * digit;
    digitAppeared[digit] = 1;
}
...
</code></pre>

<p>To give you a clear idea this line basically checks whether the element appeared or not and as per the result it will add the digit.</p>

<p>If digit <code>D</code> appeared then <code>digitAppeared[D]=1</code>
        and if it didn't then <code>digitAppeared[D]=0</code>.</p>

<p>We will add it to digitsum if it appears first time. That's why the <code>(1-digitAppeared[D])</code> will tell us whether to add it or not.</p>

<pre><code>    digit_sum  += (1 - digitAppeared[digit]) * digit;
</code></pre>
",4
47486308,47486250,0,"<p>Convert the number to string use itoa() . sort it and then  walk through it , looking for unique number and do your calculation</p>
",2
47486364,47486250,0,"<p>You can mark which digits were already added by using setting logical flags as represented by <code>done</code> in program below:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#define TEN 10 
int main ()
{
 int number = 0;
 int digit = 0;
 int last_digit = 0;
 int digit_sum = 0;
 int i = 0;
 int done[10];
while (i == 0)
{
 printf(""Please Enter A Positive Number! \n""); //explaining
 scanf(""%d"",&amp;number);
 if (number &gt; 0)
{
    i++;
}

}
    memset(done,0,sizeof(done));
    while (number &gt; 0)
    {
    digit = number % TEN; //breaking number into digits
    number /= TEN;
      if(done[digit] == 0)
      {
       digit_sum += digit;
       done[digit] = 1;
      }
    }


    printf(""The Sum Of The Digits Is : %d"",digit_sum);
    return 0;
}
</code></pre>
",0
46947370,46946854,0,"<p>Continuing from both my comments above:</p>

<blockquote>
  <p>It¡¯s just the address of a string, right?</p>
</blockquote>

<p>Right. The <em>address of</em> (e.g. a <em>pointer to</em>) a string. <code>execvp</code> requires a <code>char *const argv[]</code> as the second argument. (<em>an array of const pointer to char</em>). <code>&amp;argv[1]</code> simply provides the starting address for the <em>array of const pointers to char</em>. </p>

<p>Since you have an array of pointers to char, a simple way to visualize what is happening is simply to <code>printf</code> what each pointer (each string) in the array. You can iterate by indexes, or declare a <em>pointer to the first pointer</em> and iterate over each of the pointers by simply using <em>pointer arithmetic</em>.</p>

<p>A quick example is simply to add a quick <code>char **p = &amp;argv[1];</code> to your code and then iterate over the pointers that will be passed to <code>execvp</code> (up to the ending <code>NULL</code>) to see what is being passed.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

int main(int argc, char* argv[]){
    if(argc &lt; 2){
        perror(""little arguments"");
        return -1;
    }
    int n = 1;              /* declare a counter variable */
    char **p = &amp;argv[n];    /* declare a pointer to pointer to argv[1] */
    while (*p)              /* iterate over each pointer, and index */
        printf (""points to argv[%d]: '%s'\n"", n++, *p++);
    execvp(argv[1], &amp;argv[1]);
    return 0;
}
</code></pre>

<p><strong>Example Use/Output</strong></p>

<pre><code>$ ./bin/execvp ls -l dat
points to argv[1]: 'ls'
points to argv[2]: '-l'
points to argv[3]: 'dat'
total 892
-rw-r--r-- 1 david david    31 May  6  2016 11nums.txt
...
</code></pre>

<p>Look things over and let me know if you have questions of either the comments or the answer.</p>
",0
46021658,46021624,2,"<p>Three main problems:</p>

<ol>
<li>When equal ages, you are passing the pointer to integer not the integer itself to <code>printf()</code></li>
<li><code>else</code> statment does not have an `if'</li>
<li><strong>INDENTATION</strong> - <em>does not effect the execution but is crucial in helping one find problems in the code much easier</em></li>
</ol>

<p><em>Correct code:</em></p>

<pre><code>/* to find the age of individuals according to youngest to oldest */

#include &lt;stdio.h&gt;

int main(void)

{
    int age1, age2, age3, youngest, middle, oldest;
    printf (""Enter the age of the first individual: "");
    scanf  (""%d"", &amp;age1);
    printf (""Enter the age of the second individual: "");
    scanf  (""%d"", &amp;age2);
    printf (""Enter the age of the third individual: "");
    scanf  (""%d"", &amp;age3);

    if ( ( age1 == age2 ) &amp;&amp; ( age2 == age3) )
    {
    printf(""All individuals have the same age of %d"", age2);
    }

    else if ((age1 != age2) &amp;&amp; (age1 != age3) &amp;&amp; (age2 != age3))
    {
        youngest = age1;

        if (age1 &gt; age2)
        youngest = age2;
        if (age2 &gt; age3)
        youngest = age3;

        middle = age1;

        if (age1 &gt; age2)
        middle = age2;
        if (age2 &lt; age3)
        middle = age2;

        oldest = age1;

        if (age1 &lt; age2)
        oldest = age2;
        if (age2 &lt; age3)
        oldest = age3;

        printf(""%d is the youngest.\n"", youngest);
        printf(""%d is the middle.\n"", middle);
        printf(""%d is the oldest.\n"", oldest);
    }

    return 0;

}
</code></pre>

<p><strong>-- EDIT</strong></p>

<p>Please note that in the above solution, if two of the ages are equal, the oldest and youngest ages are not printed. To fix this I would remove the if condition for the <code>else</code>, and include a check before printing the middle value. New else statment:</p>

<pre><code>    else
    {
        youngest = age1;

        if (age1 &gt; age2)
        youngest = age2;
        if (age2 &gt; age3)
        youngest = age3;

        middle = age1;

        if (age1 &gt; age2)
        middle = age2;
        if (age2 &lt; age3)
        middle = age2;

        oldest = age1;

        if (age1 &lt; age2)
        oldest = age2;
        if (age2 &lt; age3)
        oldest = age3;

        printf(""%d is the youngest.\n"", youngest);

        // If two ages are equivalent, do not print middle
        if ((age1 != age2) &amp;&amp; (age1 != age3) &amp;&amp; (age2 != age3))
            printf(""%d is the middle.\n"", middle);

        printf(""%d is the oldest.\n"", oldest);
    }
</code></pre>

<p>Disclaimer: Although I have given the above solutions to keep the original code, I would prefer a more generic approach in the following way:</p>

<ol>
<li>Create a method that sorts an array of integers: <code>sort(int *array, int size)</code></li>
<li>Read the input ages into an integer array: <code>int ages[3]</code></li>
<li>Pass the ages to the sort function: <code>sort(ages, 3);</code></li>
<li>Print results from sorted array : <code>ages[0]</code>, <code>ages[1]</code>, <code>ages[2]</code></li>
</ol>

<p>This way the code is way more readable, and reusable..</p>
",2
46021666,46021624,0,"<p>Why don't you do something like </p>

<pre><code>if (age1&gt;age2 &amp;&amp; age1&gt;age3) {
   oldest=age1;
   if (age2&gt;age3)
       middle = age2;
       youngest=age3;
    } else {
        middle = age3;
        youngest=age2;
    }
 } else if (age2&gt;age3) {
   oldest=age2;
   if (age1&gt;age3)
       middle = age1;
       youngest=age3;
    } else {
        middle = age3;
        youngest=age1;
    }
} else {
   oldest=age3;
   if (age2&gt;age1)
       middle = age2;
       youngest=age1;
    } else {
        middle = age1;
        youngest=age2;
    }
}
</code></pre>
",0
46043809,46043742,0,"<p>A function <code>void f(void) { ... }</code> does not accept a anything to pass into the function, nor does it return anything. You need to change the signature of the function (return type and parameters and its types) and its body according to the task your teacher gave to you.</p>
",0
46051832,46051752,1,"<p>Your code is wrong for so many reasons. </p>

<p>To start with, with an array defined like</p>

<pre><code>  char word[10];
</code></pre>

<p>using </p>

<pre><code>  scanf (""%14s"", &amp;word);
</code></pre>

<p>is very wrong.</p>

<ul>
<li><p>You don't need to pass the address of array variable, the array name decays to the pointer to the first element. with <code>scanf()</code>, <code>%s</code> expects an argument as a pointer to the start of a character array long enough to hold the converted input and the null terminator.</p></li>
<li><p>for an array size 10, which can hold a string of size 9 (plus, null-terminator), you're allowing 14 characters to be scanned and stored, this is invalid memory access which leads to undefined behavior.</p></li>
</ul>

<p>That said, you did not check for the success of the <code>scanf()</code> call, either. In case <code>scanf()</code> fails, you'll be accessing indeterminate values.</p>
",2
46051987,46051752,0,"<p>You should do the declaration of the struct type <code>struct entry</code> before you use it the first time, which is in the prototype just before your declaration.</p>
",0
46126173,46125743,1,"<p>As yano pointed out k1.data is of type pointer-to-pointer-to-int (int**) so you need to allocate first the array of int* and then allocate each array of int associated with each int*</p>

<p>I've made the changes to your code so that it now works without a runtime error.  You look over it to see how k1.data is first allocated and then each element of k1.data is then allocated.  Also note that I called free on everything that had previously been allocated.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct {
    int** data;
} kdtree;

typedef struct {
    int* data;
} bipartition;

void kdtree_fn(int*, bipartition);
bipartition bipartition_fn(int*);

#define ROW 5
#define COL 4

int main(void) {
    int data[COL] = {0};

    int i;
    for(i = 0; i &lt; COL; i++)
        data[i] = i;

    bipartition bp;
    kdtree kd;
    kdtree_fn(data, bp);

}

void kdtree_fn(int* data, bipartition bp) {
    kdtree k1;
    k1.data = (int**)calloc(ROW, sizeof(int*));

    int i;
    for(i = 0; i &lt; ROW; i++)
        k1.data[i] = (int*)calloc(COL, sizeof(int));

    int j;
    for(j = 0; j &lt; ROW; j++) {
        bp = bipartition_fn(data);

        for(i = 0; i &lt; COL; i++) {
            k1.data[j][i] = bp.data[i];
            printf(""%d "",k1.data[j][i]);
        }
        printf(""\n"");

        free(bp.data);
    }

    for(i = 0; i &lt; ROW; i++)
        free(k1.data[i]);
    free(k1.data);
}

bipartition bipartition_fn(int* data) {
    bipartition bp1;
    bp1.data = (int*)calloc(COL, sizeof(int));

    int i;
    for(i = 0; i &lt; COL; i++)
        bp1.data[i] = data[i] + 1;

    return bp1;
}
</code></pre>

<p>I used calloc instead of malloc so that the memory is zeroed out rather than holding garbage values.</p>

<p>I changed your hard coded numbers (4 and 5) to symbolic constants ROW and COL so that you only need to change the numbers in a single place instead of throughout your code.</p>

<p>I made your variable 'data' an array instead of a dynamic array as there was no point in that.</p>
",3
46127733,46125743,0,"<p>My attempt at a rework of your code trying to keep all the pointers properly allocated and freed:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define COLUMNS (4)
#define ROWS (5)

typedef struct {
    int **data;
} kdtree;

typedef struct {
    int *data;
} bipartition;

void bipartition_fn(int *data, bipartition *bp) {

    for (int i = 0; i &lt; COLUMNS; i++) {
        bp-&gt;data[i] = data[i] + 1;
    }
}

void kdtree_fn(int *data, kdtree *kd) {

    bipartition bp;
    bp.data = calloc(COLUMNS, sizeof(int));

    for (int j = 0; j &lt; ROWS; j++) {

        bipartition_fn(data, &amp;bp);

        for (int i = 0; i &lt; COLUMNS; i++) {
            kd-&gt;data[j][i] = bp.data[i];
            printf(""%d "", kd-&gt;data[j][i]);
        }

        printf(""\n"");
    }

    free(bp.data);
}

int main() {

    kdtree kd;
    kd.data = calloc(ROWS, sizeof(int *));

    for (int j = 0; j &lt; ROWS; j++) {
        kd.data[j] = calloc(COLUMNS, sizeof(int));
    }

    int *data = calloc(COLUMNS, sizeof(int));

    for (int i = 0; i &lt; COLUMNS; i++) {
        data[i] = i;
    }

    kdtree_fn(data, &amp;kd);

    // do something with kd

    for (int j = 0; j &lt; ROWS; j++) {
        free(kd.data[j]);
    }

    free(kd.data);
    free(data);

    return 0;
}
</code></pre>

<p>I reordered the code and tossed the function prototypes to simplify the example and focus on memory mangement.  Your original passes and returns structures which causes data to be copied -- I switched to passing around pointers to avoid the copying.</p>
",2
46127927,46125743,-1,"<p>There are three ways to do so: </p>

<ol>
<li><p>You can initialize an memory to zero using <code>calloc</code> function instead of <code>malloc</code> <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/"" rel=""nofollow noreferrer"">here</a> you can read about it. Its also on the same header file and initialize the chunk memory allotted to zero. </p></li>
<li><p>other way is you can manually do it by <code>bp-&gt;data[i]=0;</code> </p></li>
<li><p>last way will be using <code>bzero(char*,int)</code>  which zero all bits <a href=""http://www.mkssoftware.com/docs/man3/bzero.3.asp"" rel=""nofollow noreferrer"">here</a> is where you can read about it.</p></li>
</ol>

<p><strong>I prefer to use <code>calloc</code></strong> because I don't have to call another function to initialize the memory thus little less time taking process. </p>
",2
47504773,47504585,-2,"<p>You can add four extra  class variables in your code as memXd,memYd,memXn,memYn and initialize them with null value.
And in your ReachDestinationAvoidingNode() method just initialize them with new value at the end of your function. Like</p>

<pre><code>    unsigned char memXd='';
    unsigned char memYd='';
    unsigned char memXn='';
    unsigned char memYn='';
    void ReachDestinationAvoidingNode(unsigned char Xd,unsigned char Yd,unsigned char Xn,unsigned char Yn)
     {
        //do your stuff;
        memXd=Xd;
        memYd=Yd;
        memXd=Xn;
        memYd=Yn;
        // by this your function will always remember previous value you can use it in your code
     }
     int main(void)
     {
       ReachDestinationAvoidingNode(5,'D',6,'D');
       buzzer_on();
       _delay_ms(500);
       buzzer_off();
       ReachDestinationAvoidingNode(2,'F',2,'D');
       buzzer_on();
       _delay_ms(500);
       buzzer_off();
       ReachDestinationAvoidingNode(2,'A',2,'C');
       buzzer_on();

     }
</code></pre>
",3
46663903,46663874,7,"<p>You call the <code>lfDemanaMensualitat()</code> function twice, and it does one call to <code>printf()</code>, so of course you're going to have two print-outs.</p>

<p>If you wanted to only call it once and store the value, you can something like this:</p>

<pre><code>const double t = lfDemanaMensualitat();
const double a = (1 + lfDemanaTaxa()) / t;
const double b = pow(a, t);
</code></pre>

<p>And then compute <code>c</code> and <code>TAE</code> like you already do. This just saves the result of <code>lfDemanaMensualitat()</code> in a temporary variable called <code>t</code>.</p>

<p>By the way you should know that <code>scanf()</code> can fail, if the user enters things that don't match the specified conversion. You must check the return value to make sure it succeeded before relying on the input.</p>
",0
47518743,47518701,0,"<p><code>a</code> is <code>1</code> so the second part of the first <code>(..)</code> is not executed. Value of <code>c</code> doesn't change.</p>
<p>Now <code>c</code> is 1 but as it is true, the second statement <code>b--</code> is executed also. (as <code>b</code> is <code>3</code> both of them is truthy).The whole conditional expression evaluates to true. That's why the result 2 1 2 1.</p>
<p>Because in an <code>or</code> conditional expression if any of the expression results in truthy value it short circuits and other expressions are not executed. <code>||</code> works from left to right.</p>
<p><code>exp1 || exp2</code>  - if <code>exp1</code> is non zero then <code>exp2</code> will not be executed. As the whole condition evaluates to true.</p>
<p>But in the case of <code>&amp;&amp;</code> all the expressions must be truthy.</p>
<p><code>e1 &amp;&amp; e2 &amp;&amp; e3</code> will be true if <code>e1</code> is true and <code>e2</code> is true and <code>e3</code> is true.</p>
<p>And if any of them is false, suppose <code>e1</code> then <code>e2</code> and <code>e3</code> wont be executed further. Because there is no way their result will make the condition true.</p>
<p>Both <code>&amp;&amp;</code> and <code>||</code> guarantees left to right evaluation.</p>
<h3>Intuition-</h3>
<p>You can consider <code>||</code> and <code>&amp;&amp;</code> (<code>logical or</code> and <code>logical and</code>)operator to be lazy. They will work as much as they need to know whether the whole expression is true.</p>
<p>for example <code>a || b || c</code> where <code>a = 0, b = 1, c =0</code>..it first checks whether <code>a</code> is true or false. It finds out <code>a</code> is false. So it has to check more. Then it sees <code>b</code> and it is <code>1</code>, it's true - then it doesn't check anymore.</p>
<p>Same goes with <code>&amp;&amp;</code> (logical and) but with falsy values.</p>
<p>This is known as <em>short-circuit-evaluation</em>.</p>
",0
47518842,47518701,0,"<p>The <code>||</code> and <code>&amp;&amp;</code> operators have a behavior called <strong>short-circut evaluation</strong>.  What this means is that if the result of the operator can be determined by evaluating only the first operand, the second operand will not be evaluated.</p>

<p>In the case of the first subexpression:</p>

<pre><code>(a||c--)
</code></pre>

<p>The value of <code>a</code> is 1, so the result of the <code>||</code> will be 1, regardless of the value of the right operand.  So <code>c--</code> is not evaluated and is therefore not decremented.</p>

<p>The above expression is the left side of a <code>&amp;&amp;</code> operand.  At this point the result of the operator is not yet known, so next the right side is evaluated:</p>

<pre><code>(c&amp;&amp;b--)
</code></pre>

<p>The value of <code>c</code> at this point is 1, so the right hand side <code>b--</code> must be evaluated.  That has a value of 3, plus a side effect that decrements <code>b</code>.  So the expression is <code>1 &amp;&amp; 3</code> which evaluates to 1.  This results in the entire expression evaluating to true, so the value of <code>b</code> (2) is printed.</p>
",0
47659945,47659886,1,"<p>The types are different. Type of <code>&amp;arr1[0]</code> is <code>int*</code> but that of <code>arr1_ptr</code> is <code>int*[10]</code>. That's why this error message. You even copied the error message wrong.</p>

<p>Also note that maybe this is what you wanted </p>

<pre><code>arr1_ptr[0] = &amp;arr1[0];
</code></pre>

<p>Because now the types match and also it means - you are assigning a <code>int</code> variables address to the first element of an array where each element of the array is of type <code>int*</code>.</p>
",0
47659964,47659886,1,"<p><code>arr1[0]</code> is a <em>single</em> <code>int</code> value. Therefore <code>&amp;arr1[0]</code> is a pointer to that single <code>int</code>. And therefore <code>&amp;arr1[0]</code> has to be of type <code>int *</code>.</p>

<p>The variable <code>arr1_ptr</code> is an array of <code>10</code> pointers to <code>int</code>. If you want to make an element of that array point to an element of <code>arr1</code>, then you have to assign the address of an element of <code>arr1</code> to an element of <code>arr1_ptr</code>:</p>

<pre><code>arr1_ptr[0] = &amp;arr1[0];
</code></pre>

<p>If on the other hand you want a pointer to an array, then you have to do e.g.</p>

<pre><code>int (*arr1_ptr)[ten] = &amp;arr1;
</code></pre>
",0
48012252,48011958,4,"<p>Your leap year condition is wrong.</p>

<p>Change the Leap year condition as follows.  </p>

<pre><code> int daysInMonth (int month, int year) 
    {
    if (month == 1)     //Feb
        {
    if (( year%400 == 0)|| (( year%4 == 0 ) &amp;&amp;( year%100 != 0)))
            return 29;
        else
            return 28;
        }
</code></pre>
",1
46109770,46109537,0,"<blockquote>
  <p>I'd like your advice on a way to define data structures (struct) which are defined in a configuration file</p>
</blockquote>

<p>The simplest method, by far, would be to use header (<code>.h</code>) files as your configuration files. You could include them into your project like so:</p>

<pre><code>#include CONFIG_FILE
</code></pre>

<p>... and introduce them during compilation like so:</p>

<pre><code>cc -D'CONFIG_FILE=""path/to/config.h""' path/to/source/files.c
</code></pre>

<p>If you wrap all of your config values into function-like-macros from the very start, this should be nice and flexible; you shouldn't have a problem generating clean <code>struct</code>s from your INI files.</p>

<blockquote>
  <p>I'm guessing it will be something like ini file</p>
</blockquote>

<p>I should point out that in the world of C, <em>define</em> has a <em>very strict</em> meaning, and to <em>define data structures (struct)</em> can only be done in C source files (or header files, which are later included into source files).</p>

<p>Suit yourself! My recommendation would give you an interface that allows you to put the lexing/parsing on hold until a (much) later point in time (i.e. when you have the time to write a full-fledged INI-to-C-header compiler, because that's what you're asking about), and give you an interface with which to <em>fill in the blanks</em>, so to say.</p>
",4
46132663,46132193,0,"<p>It is simple-
int total_age = atoi(user[0].age) + atoi(user[1].age) and so on till last record.</p>

<p>And you can convert the integer into string by using itoa() if you want to do so.
Please use following read() function.</p>

<pre><code>void read() {
    FILE *f;
    int total_age = 0;
    int i = 0;
    f = fopen(""file.txt"", ""r"");

    if (f == NULL) {
        printf(""The file does not exist"");
    } else {
        system(""cls"");
        while (!feof(f)) {
            fscanf(f,""%s %s %d"", users[i].name,users[i].sname,users[i].age);
            total_age = total_age + (users[i].age);
            i++;
        }
        printf(""Total age is %d"",total_age);
        fclose(f);
    }
}
</code></pre>

<p>And change structure as follows-</p>

<pre><code> struct contact {
        char name[20];
        char sname[20];
        int age;
    };
</code></pre>
",12
47522980,47522551,1,"<p>The check_legal function uses movecol in both the columns and rows.</p>
",0
47546688,47545567,0,"<p>In a physical simulation you need to store the state for current time T and use this to compute a new state at time T + \delta T. Then repeat until T reaches the desired end time. For some very simple problems, you can get away with storing just the current state and update it on the fly. But this problem is more easily done with 2 states. Let's call them C and N for the current T and next T+\delta T states respectively.  The basic algorithm is</p>

<pre><code>Store initial conditions in N. For starters: N.t = 0
Emit N as output.
while (N.t &lt; end of simulated time) {
  Copy N to C
  Use C to compute N // N.t = C.t + delta_t and do Verlet integration...
  Emit N as output.
}
</code></pre>

<p>You can get fancy with pointers to avoid the copy operation. But I gather you're a new C programmer. Don't go there yet.</p>

<p>The states can consist of arrays to hold the positions (x coordinates) of the atoms, their velocities, and accelerations.  I suggest you declare these as struct fields:</p>

<pre><code>#define MAX_ATOM_COUNT (20) // or whatever, but don't make much bigger than needed
typedef struct state_s {
  double t; // Time of this state
  int n_atoms; // Actual number of atoms must be &lt;= MAX_ATOM_COUNT.
  double x[MAX_ATOM_COUNT]; // position
  double v[MAX_ATOM_COUNT]; // velocity
  double a[MAX_ATOM_COUNT]; // acceleration
} STATE;
</code></pre>

<p>The advantage of structs is that you can do the copy operation of the algorithm with one statement:</p>

<pre><code>STATE current, next;

next.t = 0;
...
while (next.t &lt; SIMULATION_END_TIME) {
  current = next;
  ...
</code></pre>

<p>You get to do the rest.</p>
",2
47567914,47545567,0,"<p>I am new in C, I tried to follow up on your concept but I could not go past the idea. I came up with a little code but it's full of errors. Hope you can advise.
Here is the code:</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;
#include&lt;graphics.h&gt;
#include&lt;math.h&gt;
//#define MAX_ATOM_COUNT (20)

 // 
typedef struct state_s{
double t; // Time of this state
int n_atoms; 
/* Actual number of atoms must be &lt;= 
* MAX_ATOM_COUNT
*/
double x[MAX_ATOM_COUNT]; // position
double v[MAX_ATOM_COUNT]; //velocity
double a[MAX_ATOM_COUNT]; // acceleration
}STATE;

void main()
{

/*
* Let the current initial conditions be c
* Let the next condition be n
* Let the MAX_ATOM_COUNT be user specified
* 
*/
double t, MAX_ATOM_COUNT;
double SIMULATION_END_TIME;
double c, n;
int gd = DETECT, gm;
initgraph(&amp;gd, &amp;gm, ""C:\\tc\\bgi"");
//Path for graphics drivers

line(100, 200, 150, 200);

arc(200, 200, 0, 180, 50);
arc(260, 200, 0, 180, 50);
arc(230, 200, 180, 360, 20);

arc(320, 200, 0, 180, 50);
arc(290, 200, 180, 360, 20);

arc(380, 200, 0, 180, 50);
arc(350, 200, 180, 360, 20);

line(430, 200, 470, 200);

getch();
closegraph();

//Value of simulation end time
printf("" Enter the value of simulation duration\n"");
scanf(""%d"", &amp;SIMULATION_END_TIME);

// Store initial conditions in N
printf(""Enter the Maximum atom count\n"");
scanf(""%d"", &amp;MAX_ATOM_COUNT);

printf(""Enter the current initial conditions\n"");
scanf(""%d"", &amp;c);

printf(""Enter the next conditions\n"");
scanf(""%d"", &amp;n);

while (t &lt; SIMULATION_END_TIME) {
c = n;
n * t = c * t + delta_t;

// Do verlet Integration Computation
x1 = x0 + (x0 - x1) + a*pow(dt, 2);

printf(""%d"", &amp;n);
}


STATE current, next;

next.t = 0;

while (next.t &lt; SIMULATION_END_TIME) {
c = n;
}

printf(""The position is:\n"");
printf(""%d"", &amp;x);

printf(""The velocity is:\n"");
printf(""%d"", &amp;v);

printf(""The acceleration is:\n"");
printf(""%d"", &amp;a);

}
</code></pre>
",0
47552324,47552208,2,"<p>You seem to have forgotten the  <code>*</code> in  the pointer declaration:</p>

<pre><code>int sammenlign_hold (const void *p1, const void *p2) {
    loebsdata2017 *resultat1 = (loebsdata2017 *)p1;
    loebsdata2017 *resultat2 = (loebsdata2017 *)p2;

    return strcmp(resultat1 -&gt; rytterhold, resultat2 -&gt; rytterhold)
} 
</code></pre>
",5
47658295,47658216,7,"<p>The <code>%c</code> format specifier accepts any character, including newlines.  So if you press <code>N</code>, then <code>scanf</code> reads that character first but the newline from pressing ENTER is still in the input buffer.  On the next loop iteration the newline character is read.  And because a newline is neither <code>n</code> or <code>N</code> the loop exits.</p>

<p>You need to add a space at the start of your format string.  That will absorb any leading whitespace, including newlines.</p>

<pre><code>scanf("" %c"", &amp;quit);
</code></pre>
",0
47658323,47658216,1,"<p>Just change your code to:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(){

  char quit = 'n';

  do{
    printf(""Quit? (Y/N)"");
    scanf("" %c"", &amp;quit);
  }while(quit=='n' || quit=='N');
}
</code></pre>

<p>For more information read this <a href=""https://stackoverflow.com/questions/17079144/why-we-need-to-put-space-before-c"">link</a></p>
",0
47489798,47489393,0,"<pre><code>#define 2R0 3
</code></pre>

<p>Identifiers must start with either a letter or underscore, digits are not allowed.</p>
",0
47488047,47487940,2,"<p>First off, you'll have to learn the rules for each language you learn as it is one of the areas that varies between languages.  There's no universal rule about what's what.</p>

<p>Second, in C, you need to know the list of keywords; that seems to be what you're referring to as 'reserved words'.  Those are important; they're immutable; they can't be abused because the compiler won't let you.  You can't use <code>int</code> as a variable name; it is always a type.</p>

<p>Third, the C preprocessor can be abused to hijack anything; if you compile with <code>#define double int</code> in effect, you get what you deserve, but there's nothing much to stop you doing that.</p>

<p>Fourth, the only predefined variable name is <code>__func__</code>, the name of the current function.</p>

<p>Fifth, names such as <code>printf()</code> are defined by the standard library, but the standard library has to be implemented by someone using a C compiler; ask the maintainers of the GNU C library.  For a discussion of many of the ideas behind the treaty between the standard and the compiler writers, and between the compiler writers and the programmers using a compiler, see the excellent book <a href=""https://rads.stackoverflow.com/amzn/click/com/0131315099"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">The Standard C Library</a> by P J Plauger from 1992.  Yes, it is old and the modern standard C library is somewhat bigger than the one from C90, but the background information is still valid and very helpful.</p>
",0
47488175,47487940,0,"<p>Reserved words are <em>part of the language's syntax</em>. C without <code>int</code> is not C, but something else. They are <em>built into the language</em> and are not and cannot be defined anywhere in terms of this particular language. </p>

<p>For example, <code>if</code> is a reserved keyword. You can't redefine it and even if you could, how would you do this in terms of the C language? You could do that in assembly, though.</p>

<p>The standard library functions you're talking about are ordinary <em>functions</em> that have been included into the standard library, nothing more. They are defined in terms of the language's syntax. Also, you <em>can</em> redefine these functions, although it's not advised to do so as this may lead to all sorts of bugs and unexpected behavior. Yet it's perfectly valid to write:</p>

<pre><code>int puts(const char *msg) {
    printf(""This has been monkey-patched!\n"");
    return -1;
}
</code></pre>

<p>You'd get a warning that'd complain about the redefinition of a standard library function, but this code is valid anyway.</p>

<p>Now, imagine reimplementing <code>return</code>:</p>

<pre><code>unknown_type return(unknown_type stuff) {
    // what to do here???
}
</code></pre>
",0
48004441,48004348,0,"<p>The program always writes ""\nab\bsi\rha"" to its stdout.</p>

<p>The difference comes from how this is displayed.</p>

<p>You can use <code>gcc hello.c &amp;&amp; ./a.out | xxd</code> to see it.</p>

<pre><code>00000000: 0a61 6208 7369 0d68 61                   .ab.si.ha
</code></pre>
",0
48004550,48004348,0,"<p><code>\r</code> is <code>CR</code> (carriage return) code. It returns the cursor to the start of line. You have ""ab"", then <code>\b</code> which is backspace. Following ""si"" will overwrite ""b"" and you have ""asi"". Then <code>\r</code> goes to the start of line and ""ha"" is printed in the place of ""as"" - the result is ""hai"". But the cursor is after ""s"" and when Bash prompt is displayed, it replaces ""i"" because it is the first free position after cursor. And you see ""ha{prompt-message}"". Add <code>\n</code> after <code>\rha</code> to see ""hai"".</p>
",3
48004576,48004348,1,"<p><code>\t</code> refers to a tab character, <code>\r</code> to a carriage return (think of a typewriter), and <code>\b</code> to a <em>nondestructive</em> backspace. As crvv pointed out, the same output is always sent to stdout: <code>""\nab\bsi\rha""</code>. However, your terminal and XCode will produce different output (by choice).</p>

<p>Your terminal will do the following: it sees the <code>\n</code>, goes to a new line, it sees <code>ab</code> and ""stores"" that, but then it sees <code>\b</code>, so it performs a <em>nondestructive backspace.</em> This basically means the cursor, aka the point where new characters are written, goes back one space:</p>

<p>Initially:</p>

<pre><code>ab
  ^
</code></pre>

<p>After encountering <code>\b</code>:</p>

<pre><code>ab
 ^
</code></pre>

<p>Note that the cursor is now under b, so it will be overwritten if any subsequent characters result.</p>

<p>Next, it reads in <code>s</code> and then <code>i</code>, so we get:</p>

<pre><code>asi
   ^
</code></pre>

<p>Next, it reads in <code>\r</code>. This is the carrage return, which on old typewriters would return the cursor to the beginning of the line. So now we have:</p>

<pre><code>asi
^
</code></pre>

<p>Finally, it reads in <code>ha</code>, and because the cursor is under <code>a</code>, <code>ha</code> will overwrite <code>as</code>:</p>

<pre><code>hai
  ^
</code></pre>

<p>Here's the thing. Note that your cursor is <em>still</em> under i. It is not under the next empty space, after the i. Because your program <code>printf</code> does not print anything after <code>printf(""\rha"")</code>, when the terminal prints your output, the cursor will remain under i.</p>

<p>So, what is the next thing your terminal outputs? Usually, it's the normal prompt, i.e. <code>yourname@ubuntu</code>. <em>This overwrites the i</em>, hence, you will see something like <code>hayourname@ubuntu</code>.</p>

<p>Xcode, on the other hand, does things a little differently. It consumes the <code>\b</code>, so the cursor doesn't go back a character, and the <code>\r</code> is treated as a newline, hence:</p>

<pre><code>absi
ha
</code></pre>
",4
47500015,47499842,-1,"<p>Because of my badge count, i couldn't write a comment so i want to post my answer.Hope this will help...</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;
#include&lt;iostream&gt;

using namespace std;

int main(){

	char First[1024],Second[1024];
	//Type zero when want to exit from loop

	int flag = 1;
	while(flag){
		scanf(""%s"",&amp;First);
		scanf(""%s"",&amp;Second);
		printf(""enter 0 to exit\n"");
		cin&gt;&gt;flag;
	}

	printf(""%s  %s"",First,Second);
	system(""PAUSE"");
	return 0;
}</code></pre>
</div>
</div>
</p>
",4
47500212,47499842,0,"<p>Ok, the answer will be this code:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char *argv[]) {
  int current_line;
  int from_line;
  char *text;
  int i;

  if (argc &lt; 3) {
    printf(""%s\n"", ""Should provide at lest 2 arguments"");
    return 1;
  }

  from_line = atoi(argv[2]);
  text = argv[1];
  current_line = 0;
  i = 0;

  while (text[i++] != '\0');

  while (i &gt;= 0) {
    if (text[i] == '\n') {
      current_line++;
    }
    if (current_line == from_line) {
      break;
    }
    i--;
  }

  /*
    If text is ""SOME TEXT"" then text + 0 is also ""SOME TEXT""
    but text + 1 would be ""OME TEXT"" and text + 5 ""TEXT"".
  */
  printf(""%s\n"", text + i + 1);

  return 0;
}
</code></pre>

<p>Firstly it will check if the user passed at lest 2 arguments to the program.
Then it will assign <code>argv[1]</code> which should hold out text to <code>char *text</code> pointer.
Next we will convert <code>argv[2]</code> to integer and store it in <code>int from_line</code> variable.</p>

<p>Then we have assign <code>int i</code> value 0 and run loop to find the size of the string.</p>

<p>We are going to enter the loop so we need to initialize <code>int current_line</code>,
it keeps track of the current line we are in.</p>

<p>Then we have the loop, it will run until we reached the end of the string or we found the line we are looking for,
the loop will run though string in reverse (from end to beggining) since we are looking for nth line from the end.</p>

<p><code>'\n'</code> in most programming languages means newline, if we found newline we are going to increment the <code>current_line</code> variable.</p>

<p>At the end we need to print the string from the character that precedes <code>'\n'</code> newline character.</p>
",1
47501996,47501877,2,"<p>Well: <code>scanf</code>... tries to read in an integral value (positive or negative); the return value of <code>scanf</code> is the number of correctly read in formats like <code>%d</code>, so you may expect <code>1</code> for a successful read of <code>""%d""</code>. If <code>scanf</code> returns <code>1</code>,  the inner loop exits; otherwise, <code>getchar()</code> is called which takes a character from the input stream and leads to the next try of <code>scanf</code>. The outer loop then makes sure that positive values are ignored.</p>

<p>Note that the ""correct"" answer has a bug if ""end-of-file"" is entered. This will lead to an endless loop then. So I'd actually adapt the code as follows:</p>

<pre><code>int c=0;
while (c&gt;=0 &amp;&amp; !feof(stdin))
    while (scanf(""%d"", &amp;c)!=1 &amp;&amp; getchar() != EOF);
</code></pre>
",1
46634799,46634653,1,"<p>I think Bo Persson above may have the right solution for you. You declared all your functions in the header file, and that is all your other source files need to ""see"" the functions defined in filaPreferencial.c. As such, in usaFilaPreferencial.c you should be including ""filaPreferencial.h"" rather than ""filaPreferencial.c"".</p>

<p>Including a source file that is already in the project into another source file, effectively creates two copies of every function in the project. What happens is that when the preprocessor sees <code>#include ""filaPreferencial.c""</code>, it replaces that statement with the contents of filaPreferencial.c.</p>
",2
46624773,46624693,2,"<p>From <a href=""https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues"">What are rvalues, lvalues, xvalues, glvalues, and prvalues?</a>:</p>

<blockquote>
  <p>An lvalue (so-called, historically, because lvalues could appear on the left-hand side of an assignment expression) designates a function or an object.</p>
</blockquote>

<p>You're trying to assign something to an array (declared like <code>type x[dimension];</code>).</p>

<p>C language doesn't allow that. Hence, arrays cannot be lvalues, which explains the compiler error message.</p>
",0
46624806,46624693,1,"<p>You can't assign something to an array type, we can say that an array is not a left-value (the value that receives the assignment).
There is a special case, you can assign to an array when you declare it, but not after that.</p>

<pre><code>char array[] = ""hello world""; // OK
array = ""nop it doesn't work""; // KO
</code></pre>

<p>The only way to assign to an array after its declaration, is to copy the values into the array :</p>

<pre><code>strcpy(array, ""yeah it works"");
</code></pre>

<p>Note that,</p>

<pre><code>char array[];
array++;
</code></pre>

<p>obviously does not work, because it's the same thing as</p>

<pre><code>array = array + 1
</code></pre>

<p>Always remember that arrays are not pointers.</p>
",0
47966723,47966708,5,"<p>Add the line</p>

<pre><code>#include &lt;unistd.h&gt;
</code></pre>

<p>At the top of the file 'mymalloc.c' so that the function is declared</p>
",0
46634758,46634625,0,"<p><code>char* initials = """";</code> is not <code>char initials[SOME_SIZE] = {0};</code> You are not allocating any memory, you just take a pointer and start writing some characters to memory, which is not supposed to be written to. In general segmentation fault tells you that you're modifing a piece of memory that you're not allowed to. That's what happens in your case.</p>
",0
46650266,46649685,0,"<p>The problem is when you are assigning count to the Str[i], you are not converting integer to character. Just add '0' to the count to covert integer into character. </p>

<pre><code>#include&lt;stdio.h&gt;
    void main()
    {
      char str[]=""OpenText"";
      int i=0,strlen,count=0;
      while(str[i]!='\0')
        i++;
      strlen=i;

      for(i=0;i&lt;strlen;i++)
      {
         if(str[i]=='T' || str[i]=='t')
         {
           count++;
           str[i] = '0' + count; // Only change to convert integer to character
         } 
      }
      printf(""%s"", str);
    }
</code></pre>

<p>Cheers!!</p>
",1
46647672,46647616,0,"<p>Due to <code>1 &lt; i</code> being the stopping condition, your loop will either not run at all, or run forever (well, until you get undefined behaviour due to <code>a</code> overflowing, then <em>anything</em> could happen). This is because the loop body does not change <code>i</code>.</p>

<p>Did you mean <code>a &lt; i</code>?</p>

<p>And ditch <code>&lt;conio.h&gt;</code>. Most of us don't drive cars that old. Use standard C.</p>
",0
46647691,46647616,2,"<p>your loop is wrong</p>

<pre><code>for (a; 1 &lt; i; a++) {
</code></pre>

<p><code>1&lt;i</code> that condition is never met. For your purpose try </p>

<pre><code>for (a; a &lt; i; a++) {
</code></pre>
",1
46647767,46647616,0,"<p>Replace <code>for (a; 1 &lt; i; a++)</code>
by      <code>for (a; a &lt; i; a++)</code></p>
",0
46648333,46647616,1,"<p>Yor program shows up the name infinity times because:</p>

<pre><code>for (a; 1 &lt; i; a++) {
    printf(""%s\n"", n);
</code></pre>

<p>}</p>

<p><strong>1 &lt; i will allways be true</strong></p>

<p>You need to replace ""1 &lt; i"" by ""a &lt; i"", because your 
loop is working with variable ""a"".</p>
",0
46668419,46668217,1,"<p>You should append a null terminator to a buffer.</p>

<pre><code>    ...
    while (c != 13);
    buffer[pos] = '\0'; // Here
}
</code></pre>
",0
45087518,45080117,5,"<p>Reference counting allows clients of your library to keep reference objects created by your library on the heap and allows you to keep track of how many references are still active. When the reference count goes to zero you can safely free the memory used by the object. It is a way to implement basic ""garbage collection"".</p>

<p>In C++, you can do this more easily, by using ""smart pointers"" that manage the reference count through the constructor and destructor, but it sounds like you are looking to do it in C.</p>

<p>You need to be very clear on the protocol that you expect users of your libraries to follow when accessing your objects so that they properly communicate when a new reference is created or when a reference is no longer needed. Getting this wrong will either prematurely free memory that is still being referenced or cause memory to never be freed (memory leak). </p>

<p>Basically, You include a reference count in your struct, that gets incremented each time that your library returns the struct. </p>

<p>You also need to provide a function that releases the reference:</p>

<pre><code>struct Object {
  int ref;
  ....
}

Object* getObject (...) {
  Object *p = .... // find or malloc the object
  p-&gt;ref++;
  return p;
}

void releaseReference (Object* p) {
  p-&gt;ref--;
  if (p-&gt;ref == 0) free(p);
}

void grabReference (Object* p) {
  p-&gt;ref++;
}
</code></pre>

<p>Use <code>grabReference()</code> if a client of your library passes a reference to another client (in the above example, the initial caller of your library doesn't need to call <code>grabReference()</code>)</p>

<p>If your code is multi-threaded then you need to make sure that you handle this correctly when incrementing or decrementing references</p>
",2
47969528,47969504,6,"<p>Well it is the famous signed unsigned comparison. Here <code>-1</code> which is signed number when compared to unsigned numbers - promoted to an unsigned number resulting in a big magnitude value (<code>SIZE_MAX</code>). So it is always false.</p>

<p>The explanation why there would be type promotion here when comparing:</p>

<p>From standard <a href=""http://port70.net/~nsz/c/c11/n1570.html#6.3.1.8"" rel=""nofollow noreferrer""><strong>¡ì6.3.1.8</strong></a></p>

<blockquote>
  <p>Otherwise, if the operand that has unsigned integer type has rank
  greater or equal to the rank of the type of the other operand, then
  the operand with signed integer type is converted to the type of the
  operand with unsigned integer type.</p>
</blockquote>

<p>Also from <a href=""http://port70.net/~nsz/c/c11/n1570.html#6.5.8p3"" rel=""nofollow noreferrer""><strong>¡ì6.5.8</strong></a> under relational operators</p>

<blockquote>
  <p>If both of the operands have arithmetic type, the usual arithmetic
  conversions are performed.</p>
</blockquote>

<p>And what sizeof returns? </p>

<p>Under The sizeof and _Alignof operators <a href=""http://port70.net/~nsz/c/c11/n1570.html#6.5.3.4"" rel=""nofollow noreferrer""><strong>¡ì6.5.3.4</strong></a></p>

<blockquote>
  <p>The value of the result of both operators is implementation-defined, and its type (an unsigned integer type) is
  size_t, defined in  (and other headers).</p>
</blockquote>

<p>And in section <a href=""http://port70.net/~nsz/c/c11/n1570.html#7.19"" rel=""nofollow noreferrer""><strong>¡ì7.19</strong></a> under Common definitions</p>

<blockquote>
  <p>size_t which is the unsigned integer type of the result of the sizeof
  operator;</p>
</blockquote>

<p>To clarify a bit further when you are converting <code>-1</code> to <code>size_t</code> it will have the value (Basically modulo <code>SIZE_MAX+1</code>)</p>

<pre><code>SIZE_MAX+1+(-1)
</code></pre>

<p>Also from standard <a href=""http://port70.net/~nsz/c/c11/n1570.html#6.2.5p9"" rel=""nofollow noreferrer""><strong>¡ì6.2.5</strong></a> (Explaining the conversion)</p>

<blockquote>
  <p>A computation involving unsigned operands can never overflow, because
  <strong>a result that cannot be represented by the resulting unsigned integer
  type is reduced modulo the number that is one greater than the largest
  value that can be represented by the resulting type</strong>.</p>
</blockquote>
",0
48011049,48011017,2,"<p>No you can't do that. <code>isdigit()</code> is supposed to work with characters and you passed a multigit integer variable. </p>

<p>What you can do is simply like this</p>

<pre><code>if( scanf(""%d"",&amp;a[i])== 1){
  // you can be sure number is entered
}
</code></pre>

<p>And <code>fflush(stdin)</code> is undefined behavior.</p>

<p>So the use of <code>scanf</code> will be more prominent if you would do this</p>

<pre><code>int clearstdin(){
  int c;
  while ((c = getchar()) != '\n' &amp;&amp; c != EOF);
  return (c == EOF);
}
</code></pre>

<p>In <code>main()</code></p>

<pre><code>int earlyend = 0;
for(size_t i=0; i&lt;SIZE; i++){
...
... 
    int ret = scanf(""%d"",&amp;a[i]); 
    while( ret == 0){
         if( clearstdin() ){ /* EOF found */earlyend = 1; break; }
         fprintf(stderr,""%s\n"",""Entered something wrong"");
         ret = scanf(""%d"",&amp;a[i]);
    }
    if( earlyend ){ /*EOF found*/ }
    if( ret == EOF) { /* Error occured */}
...
}
</code></pre>
",0
48012602,48011017,0,"<p>The <code>%d</code> conversion specifier will cause <code>scanf</code> to skip over any leading whitespace, then read a sequence of decimal digits, stopping at the first non-digit character.  If there are no digit characters in the input (for example, you enter something like <code>¡±abc¡±</code>), then nothing is read from the input stream, <code>a[i]</code> is not updated, and <code>scanf</code> will return 0 to indicate a <em>matching failure</em>.</p>

<p>So, you can do a test like </p>

<pre><code>if ( scanf( ¡°%d¡±, &amp;a[i] ) == 1 )
{
  // user entered valid input
}
</code></pre>

<p>But...</p>

<p>This doesn¡¯t fully protect you from bad input.  Suppose you enter something like <code>¡±123abc¡±</code> - <code>scanf</code> will read, convert, and assign <code>123</code> and return a 1 indicating success, leaving <code>¡±abc¡±</code> in the input stream to potentially foul up the next read.</p>

<p>Ideally, you¡¯d like to reject the whole thing outright.  Personally, I do this as follows:</p>

<pre><code>char inbuf[SOME_SIZE];  // buffer to store input

if ( fgets( inbuf, sizeof inbuf, stdin ) ) // read input as text
{
  char *chk;                                  // use strtol to convert text to integer
  int temp = (int) strtol( inbuf, &amp;chk, 10 ); // first non-digit character written to chk
  if ( isspace( *chk ) || *chk == 0 )         // if chk is whitespace or 0, input is valid
  {
    a[i] = temp;
  } 
  else
  {
    // bad input
  }
}
</code></pre>

<p>This still isn¡¯t a 100% solution - it doesn¡¯t make sure the user didn¡¯t enter more characters than the buffer can hold, but it¡¯s a step in the right direction.</p>

<p>Input validation in C is, frankly, a pain in the ass.</p>
",0
46636704,46636564,1,"<p>Instead of having <code>get_date</code> <em>return</em> a pointer to the buffer with the data produced by the function, make it <em>take</em> a pointer to a buffer into which the data will be written. I.e. the prototype of <code>get_date</code> could be something like</p>

<pre><code>void get_date(char *buf);
</code></pre>

<p>However, it might be useful for get_date() to be able to tell not only the starting address of the buffer but also the size of the buffer . That way,
 the function can tell if the given buffer is too small (and then return e.g. an <code>int</code> indicating an error code). Hence, the prototype</p>

<pre><code>int get_date(char *buf, size_t len);
</code></pre>

<p>might be more useful in practice.</p>

<p>On the caller side, you could then use e.g. </p>

<pre><code>char date[100];
for (i = 0; i &lt; 10000; i++) {
    // return value 0 means success
    if (get_date(date, sizeof date) == 0) {
        //do something
    }
}
</code></pre>

<p>I.e. in this case, you wouldn't need <code>malloc</code> or <code>free</code> at all.</p>
",0
46636764,46636564,0,"<p>100 bytes?  Why are you using <code>malloc()</code> at all?</p>

<pre><code>for (i = 0; i &lt; 10000; i++) {

    char c[100]:
    //do something
}
</code></pre>
",0
46636624,46636564,-1,"<p>If you have a function that returns temporary fixed size memory, the memory can be static:</p>

<pre><code>thread_local char get_date_buffer [100];

char* get_date() {
    // change get_date_buffer...
    return get_date_buffer;
};
</code></pre>

<p>You must not free the return value and you must copy the data when reusing it and recalling the function. Many api-functions use this technique, like <code>glGetString</code>.</p>
",2
46636660,46636564,1,"<p>You are trying to save 10,000 malloc / free calls? </p>

<p>Before you change your code, measure how long it takes. If you are too lazy to measure it, then the speed is not important, so don't change it. </p>
",3
44230237,44230182,0,"<p>From the read manpage</p>

<blockquote>
  <p>On success, the number of bytes read is returned (zero indicates end of
         file),  and the file position is advanced by this number.  It is not an
         error if this number is smaller than the  number  of  bytes  requested;
         this  may happen for example because fewer bytes are actually available
         right now (maybe because we were close to end-of-file,  or  because  we
         are  reading  from  a  pipe, or from a terminal), or because read() was
         interrupted by a signal.  See also NOTES.</p>
</blockquote>

<p><code>read</code> is returning only the string <code>""something""</code> because that's what's been put into the pipe the first time, then the program falls out of the <code>if</code> statement and reads the second <code>""something""</code> and finishes</p>

<p>if you want to read everything in the pipe then you need to call <code>read</code> from within a loop (and also probably <code>return</code> at the end of the <code>if</code> statement).</p>
",0
46650984,46650872,2,"<pre><code>while ((ch =getchar() != '\n') &amp;&amp; x&lt;MAX)
</code></pre>

<p>should be</p>

<pre><code>while (((ch = getchar()) != '\n') &amp;&amp; x&lt;MAX)
</code></pre>

<p>Notice the extra <code>( .. )</code> around the assignment. <code>ch =getchar() != '\n'</code> is equivalent to and evaluated as <code>ch = (getchar() != '\n')</code> due to operator precedence. <code>!=</code> has higher precedence than <code>=</code>(assignment).</p>
",0
47963791,47963771,3,"<pre><code> char string[100];
 sprintf(string, ""The tile in %d,%d is occupied: "", row, col);
</code></pre>
",0
47963956,47963771,0,"<p>What you've got to understand is that a construct like <code>""The tile in %d,%d is occupied: "", row, col</code> is not some ""magic"" construct of the C language that always applies with strings. The reason for why you might think that, is that most beginners guides and books don't care to mention, what a line like <code>printf(""You name is %s"", name)</code> actually does.</p>

<p>It's not magic done by the C language, it's the how <em><code>printf</code></em>  (and whole <code>print</code>, <code>scanf</code> family of function) were design in the first place.</p>

<p>In C a string <code>""Your name is Mike""</code> and <code>""Your name is %""</code> are just two strings (a series of characters terminated with <code>\0</code>), the second one is no more special than the first one from the C perspective. The C language has also a special feature (some call it ellipses) that allow you to pass an undefined amount of arguments.</p>

<p>Take a look at this:</p>

<pre><code>void foo(int a, int b);
</code></pre>

<p>With this declaration, there is only one way to call <code>foo</code>: with too arguments. If however <code>foo</code> would be declared as</p>

<pre><code>void foo(int a, int b, ...);
</code></pre>

<p>then you can call foo so:</p>

<pre><code>struct something k;
foo(1,2);
foo(1,2,3,4,5,6,7);
foo(2, 3, ""This is a string"", k, &amp;k);
</code></pre>

<p>Using <code>va_list</code> (Variable Argument Lists) <code>foo</code> can access the rest of the parameters passed to it that come <strong>after</strong> the last named arguments, in this case <code>b</code>.</p>

<p><code>printf</code> is a function that allows this flexibility, you can call <code>printf</code> with many arguments (always at least one).</p>

<pre><code>// man 3 printf
#include &lt;stdio.h&gt;

int printf(const char *format, ...);
int fprintf(FILE *stream, const char *format, ...);
int dprintf(int fd, const char *format, ...);
int sprintf(char *str, const char *format, ...);
int snprintf(char *str, size_t size, const char *format, ...);
</code></pre>

<p>As you can see, all these function are declared that way. The basic way that <code>printf</code> work, is that it reads the first argument and parses it. When it encounters a substring like <code>%d</code> it knows that the user has passed an integer. It retrieves the integer using <code>va_list</code> and prints the value of the integer instead of <code>%d</code>. Then in continues until it reaches the end of the <em>format</em>-String, always replacing the <code>%</code>s with values retrieved using <code>va_list</code>.</p>

<p><code>strcpy</code> is declared as <code>char *strcpy(char *dest, const char *src);</code>, it doesn't use the ""ellipse trick"" as <code>printf</code> does, so your line is wrong and the compiler complains about it.</p>

<p>There are other function that use similar strategies as <code>printf</code>, but the vast majority of function accepting strings do not implement this ""trick"". For those cases you can use <code>sprintf</code>.</p>
",0
48010589,48010471,0,"<p>Simple mod:</p>

<pre><code>scanf("" %c %d"",&amp;y,&amp;x);
       ^
</code></pre>

<p>What's that space? A space in <code>scanf()</code> format string consumes and discards all whitespaces if present. So spaces, tabs and newlines won't bother anymore.</p>

<p>From <a href=""http://port70.net/~nsz/c/c11/n1570.html#7.21.6.2p5"" rel=""nofollow noreferrer"">standard</a> </p>

<blockquote>
  <p><strong>A directive composed of white-space character(s) is executed by
  reading input up to the first non-white-space character (which remains
  unread), or until no more characters can be read.</strong> The directive never
  fails.</p>
</blockquote>
",0
43951869,43951821,0,"<p>Malloc and free is defined under stdlib.h. So without including it your program wont work.</p>
",8
43954774,43951821,3,"<p><code>&lt;stdlib.h&gt;</code> is the correct header to include when calling <code>malloc</code> and <code>free</code>.  In fact, it's correct to say that you <em>must</em> include <code>&lt;stdlib.h&gt;</code> (directly or indirectly) when calling <code>malloc</code> and <code>free</code>.</p>

<p>There are lots of reasons why it might have worked for you once before even though you didn't.  Without seeing that older code, I couldn't say why.  Don't worry about it.  Just always include <code>&lt;stdlib.h&gt;</code> when calling <code>malloc</code> and <code>free</code>.</p>
",0
43962694,43961884,1,"<p>Use</p>

<pre><code>char a[10000][6];
scanf(""%d"",&amp;n);
int i;
for (i = 0;i &lt; n;i++)
{
scanf(""%s"",&amp;a[i]);
}
</code></pre>
",0
43962113,43961884,0,"<p>I recently solved this question in my program. I came to the conclusion that the best way to read input from keyboard is to handle character one by one. You can use code below.:
<br><br> </p>

<pre><code>bool in()
{
    int i;
    int a;
    int len;
    int max;
    char *text[10000];

    //change 'max' somehow here before loop

    for(i = 0, len = 0; i &lt; max; i++)
    {
        text[i] = NULL;

        do  
        {
            do
            {
                a = getchar();
            }
            while(a == '\n' &amp;&amp; !text[i]);

            if(text[i])
            {
                len = strlen(text[i]);
                len++;
            }
            else
            {
                len = 1;
            }

            text[i] = realloc(text[i], sizeof(char)*(len+1));
            if(!text[i])
            {
                printf(""cant realloc\n"");
                return false;
            }

            if(a != '\n')
            {
                text[i][len-1] = (char) a; 
                text[i][len] = '\0'; 
            }
            else
            {
                text[i][len-1] = '\0'; 
            }
        }
        while(a != '\n');
    }

    return true;
}
</code></pre>
",5
43962586,43962358,1,"<p>Instead of</p>

<pre><code>for (i=0, j=9; i&lt;10; i++, j--) {
</code></pre>

<p>use</p>

<pre><code>for (i=0, j=9; i&lt;5; i++, j--) {           // Note 5 instead of 10
</code></pre>

<p>to stop iteration after <em>all <code>5</code> pairs</em> will be swapped.</p>
",1
43962813,43962714,0,"<p>There is a difference between assignment operator (=) and comparison operator (==). In your code you are comparing so you should use ""==""</p>

<pre><code>for(x=2;x&lt;=n/2;x++)
{
 if ((n%x)==0)
 {
    y=1;
 }
}
</code></pre>
",0
43963237,43962714,0,"<p>Like others said the problem is in the condition of the <code>if</code> statement. Lets say <code>n = 13</code>.
It enters the <code>for</code> statement.
So the first step would be this:</p>

<pre><code>if(1 = 0)//13 % 2 = 1
    y = 1;
</code></pre>

<p>It's like saying 5 = 9 or 100 = 12 or 5 = 0. Which is impossible.
To check if <code>n % x</code> is 0 use <code>n % x == 0</code>.</p>

<p><a href=""http://www.includehelp.com/c-programming-questions/what-is-difference-between-assignment-and-equalto-operator.aspx"" rel=""nofollow noreferrer"">http://www.includehelp.com/c-programming-questions/what-is-difference-between-assignment-and-equalto-operator.aspx</a></p>
",0
47559248,47559200,2,"<p><code>&amp;subjects-&gt;subjs[i],</code> This is Undefined behavior. Accessing garbage value. You need to properly initialize it proper memory address. You ddin't do it anywhere.</p>

<p><code>(*subjects).subjs</code> or <code>subjects-&gt;subjs</code> -> This is not pointing anywhere. It is <code>NULL</code>.</p>

<p>Also here you don't need the double pointer. A single pointer would do the thing you want to do. </p>

<pre><code>typedef struct{
        Subject *subjs;
        int num_subjs;
}Subjects;
</code></pre>

<p>For single pointer this would be like </p>

<pre><code>Subjects *subjects = malloc(sizeof(Subjects));
subjects-&gt;num_subjs = 10;
subjects-&gt;subjs = malloc(subjects-&gt;num_subjs * sizeof Subject);
subjects-&gt;subjs[0].subjName = malloc(40);
</code></pre>

<p>Each of the <code>malloc</code> should be checked with it's return Value. If it's NULL then it would be error to proceed further or access it.</p>

<p>And <code>free()</code> it accordingly when you are done working with it.</p>

<hr>

<p>Some basic things:-</p>

<pre><code>  typedef struct{
          Subject *subjs;
          int num_subjs;
  }Subjects;
</code></pre>

<p>Now let's look a bit in the code. </p>

<p>Op asked why OP should initialize and isn;t <code>subjects-&gt;num_subjs = 0;
    subjects-&gt;subjs = NULL;</code> not enough?</p>

<p>A pointer is a variable that is supposed to hold address. here <code>Subject*</code> will hold the address of the variables of type <code>Subject</code>.</p>

<p>Now here initially you initialized it. </p>

<p>You have allocated a memory and assigned it's address to the <code>Subject*</code> variable <code>subjects</code>.</p>

<p>Now let's see what else you do.</p>

<pre><code>subjects-&gt;num_subjs = 0;
subjects-&gt;subjs = NULL;
</code></pre>

<p>You initialized it. And then you try to access it(<code>subjects-&gt;subjs[i]</code>). Can you tell me where it points to? (<code>subject-&gt;subjs</code>)?</p>

<p>Answer is nope. It is pointing to nowhere. It contains <code>NULL</code> value now. Don't you think you should tell it how many <code>subject</code> you want to hold and allocate accordingly? Yes you should and that's what I did precisely in the example shown.</p>

<p>Whenever you have a pointer variable ask yourself what it contains - and if the value is something you know about, not some random garbage value. </p>
",8
47491573,47480781,0,"<p>Oh well after a day of pain(actually i learned a lot so yay), i finaly pulled it of.</p>

<p>Here it is how it looks:</p>

<pre><code>    #include &lt;stdio.h&gt;
    #include &lt;stdlib.h&gt;
    #include &lt;string.h&gt;

typedef struct tempfile
{
    int ev;
    int hnap;
    int nap;
    int ora;
    int perc;
    int meret;
    char nev[218];
    char kiterjesztes[218];
}tempfile;

    int main(void)
    {
        char input[1024];
        char edited[1024];
        int i = 0;
        int p = 0;
        FILE *temp;
        tempfile a;

        system(""dir&gt;temp.txt"");
        temp = fopen(""temp.txt"", ""r"");
        if (temp == NULL)
            return -1;

        while (fgets(input, sizeof input, temp))
        {
            if (input[0] == ' ' || input[0] == '\n')
            {
                continue;//atugorja azokat a sorokat amik space vagy ujsorral kezdodnek
            }
            if (strstr(input, ""&lt;DIR&gt;""))
            {
                continue;//atugorja azokat a sorokat okat amikben benne van a &lt;DIR&gt;
            }
            while (input[i] != '\0')
            {
                if (input[i] != '¨B')
                {
                    edited[p] = input[i];
                    p++;
                }
                i++;
            }
            edited[p] = '\0';                        //rongy¨¢ editel¨¦se a sornak
            p = 0;
            i = 0;
            while (edited[i] != '\0')
            {
                if (edited[i] == '.')
                    edited[i] = ' ';
                i++;
            }
            i = 0;


            sscanf(edited, ""%d  %d  %d   %d:%d    %d %s %s\n"", &amp;a.ev, &amp;a.hnap, &amp;a.nap, &amp;a.ora, &amp;a.perc, &amp;a.meret, &amp;a.nev, &amp;a.kiterjesztes);
            printf(edited, ""%d %d %d %d %d %d %s %s\n"", a.ev, a.hnap, a.nap, a.ora, a.perc, a.meret, a.nev, a.kiterjesztes);

        }

        fclose(temp);
        system(""DEL temp.txt"");
        printf(""press enter\n"");
        getchar();
        return 0;
    }
</code></pre>
",0
47525078,47525037,0,"<pre><code>char server_ip[9];
</code></pre>

<p>is not big enough, IP4 address will be max 15 characters long and one char for <code>\0</code> so you should declare your variable as</p>

<pre><code>char server_ip[16];
</code></pre>

<p>Even if you enter 10.0.2.15, you are one char short as it wll need 10 characters to store this ip considering null character.</p>

<p>You are likely to hit another undefined behaviour here:</p>

<pre><code>        send(clientSocket,""Client1"",MAX,0);
</code></pre>

<p>if MAX is greater than 7 (length of ""Client1""), as <code>send()</code> will try to read beyond bounds of string literal ""Client1"". 
You should pass proper send buffer and its size to send() function, you should correct these situations leading to undefined behaviors and try again</p>
",1
47525311,47525037,0,"<p>Two things,</p>

<ol>
<li>your char array <code>server_ip[9]</code> is of insufficient length. It should be at least 16 byte long - <code>server_ip[16]</code>.</li>
<li>you don't have an option to parse 'a' in <code>getopt</code>. <code>getopt (argc, argv, ""p:i:"")</code> should be <code>getopt (argc, argv, ""p:i:a:"")</code> </li>
</ol>
",0
46980197,46979502,0,"<p>The main thing is getting the strings. For which you can use <code>strtok</code>.</p>

<p>A small demo would be something like this:</p>

<p>suppose the line contains the strings separated by spaces.(in <code>line</code>)</p>

<pre><code>char *word;
word=strtok(line,"" "");
char list[N1][N2];
int index =0;
while(word != NULL)
{
    print(""%s \n"", word); // you can also copy this.
    memset(list[index], '\0', sizeof(list[index]));
    strncpy(list[index++],word,strlen(word));
    word=strtok(NULL,"" "");
}

if( strncmp(list[0],list[1],BUFFERSIZE))
{
  //...
}
</code></pre>

<p>Based on OP's comment I understand that OP wants to read words in a single char array and then compare each of the words with another word. </p>

<p>As we are tokenizing the string in <code>list[]</code>..we can use this to compare with other word.</p>
",7
46980346,46979393,0,"<p>In c if we have local variable without initialization ,then it will have some garbage value. And in many of the functions u are intializing somevalue = array(x) it is not correct. The location you are accessing on the array is not valid.Make those chages it will work correctlu</p>
",0
46984730,46979393,1,"<p>You need to initialize local variables in your functions especially when you are using that to access your array. Without that local variable can contain any value ,if you use that as index to your array, you might be accessing valid memory.</p>

<pre><code>#include &lt;stdio.h&gt;
#define MAX 10

void getdata(int array[]);
int displaylargest(int array[]);
int displaysmallest(int array[]);
int displayaverage(int array[]);

void displaydata(int array[]);

int main() {
    int array[MAX];
    int largest;
    int smallest;
    int average;

    printf(""\nEnter ten numbers \n\n"");
    getdata(array);
    displaydata(array);
    largest = displaylargest(array);
    printf(""\nThe  largest %d\n"", largest);
    smallest = displaysmallest(array);
    printf(""\nThe smallest is %d\n"", smallest);
    average = displayaverage(array);
    printf(""\nThe average is %d\n"", average);

    return 0;
}

void getdata(int array[]) {
    int x;
    printf(""Enter a number\n "" );
    for (x = 0; x&lt;MAX; x++) {
        scanf(""%d"", &amp;array[x]);
    }
}

int displaylargest(int array[]) {
    int x, largest = array[0];
    for (x = 0; x&lt;MAX; x++) {
        if (array[x]&gt;largest)
            largest = array[x];
        }
    return(largest);
}

int displaysmallest(int array[]) {
    int x, smallest = array[0];
    for (x = 0; x&lt;MAX; x++) {
        if (array[x]&lt;smallest)
            smallest = array[x];
    }
    return(smallest);
}

int displayaverage(int array[]) {
     int x;
     int sum = 0;
     int average;

     for (x = 0; x&lt;MAX; x++) {
        sum += array[x];
      }
      {
        average = sum / MAX;
     }
     return(average);
 }

void displaydata(int array[]) {
    int x;
    for (x = 0; x&lt;MAX; x++) {
        printf(""%d, "", array[x]);
    }
}
</code></pre>
",0
46985579,46979393,0,"<p>Local variables need to be used here. While defining</p>

<blockquote>
  <p>largest=array[x];</p>
</blockquote>

<p>make sure that x=0, else x may contain garbage value and the array may try to access invalid memory locations, leading to either the conditions known as underflow or overflow.</p>

<p>Also, I see that you've declared getdata() of type int, though it is not returning any value. Please make it of type void, as is just used to insert the asked values into the array. Hope this helps!</p>
",0
47985851,47984207,0,"<p>How are you linking together your <code>ContactsHelpers.c</code>, <code>Contacts.c</code>, and your <code>main.c</code> ? Are you using Make with GCC, or some other compiler?</p>

<p>Whatever you do, <strong>don't</strong> <code>#include</code> another .c file. This will cause your compiler to compile recursively and try to compile the same code twice. Something else about your code that jumped out at me: No header guards. You are at risk of including the same information twice, breaking your program and causing errors. Wrap these lines around your header files.</p>

<pre><code>#ifndef CONTACTS_H
#define CONTACTS_H

// content of contacts.h here...

#endif
</code></pre>

<p>And then for <code>contactHelpers.h</code>:</p>

<pre><code>#ifndef CONTACTHELPERS_H
#define CONTACTHELPERS_H

// content of contactHelpers.h here...

#endif
</code></pre>

<p>If you're using Make to compile this, you will want your Makefile to be something like this. This is written with the assumption that <code>main()</code> is in <code>main.c</code>:</p>

<pre><code>ContactsHelpers.o:
    gcc -o ContactsHelpers.o ContactsHelpers.c

Contacts.o:
    gcc -o Contacts.o Contacts.c

main.o:
    gcc -o main.o main.c

all:
    gcc -o Contacts ContactsHelpers.o Contacts.o main.o
</code></pre>
",1
46983197,46983143,3,"<p>It will return <code>0</code> automatically in C99-compliant compilers (and later). In pre-C99 compilers the return value is undefined in such cases.</p>

<p>In other words, in <em>modern</em> C you don't need an explicit <code>return 0</code> at the end of <code>main</code>.</p>
",1
46987297,46985933,1,"<p>You have two primary problems, (1) the column width in <code>str</code> is not sufficient to hold <code>1, 0, \n, \0</code> that would be required by <code>10</code>. While you will read <code>1, 0, \0</code>, the <code>'\n'</code> will remain unread in your input stream. To correct the issue, increase the column width. </p>

<p>(never be stingy with buffer size, if you think you may read 3-4 chars, declare a buffer of <code>8</code> or so)</p>

<p>Second, you fail to remove the trailing <code>'\n'</code> read and included in <code>str[x]</code> by default. (all <em>line-oriented</em> functions, e.g. <code>fgets</code> and POSIX <code>getline</code> read and include the <code>'\n'</code> in the buffer they fill. Trimming a newline is simple. Get the length, check the last char if the last char in the buffer is <code>'\n'</code> by checking <code>str[n][length-1]</code>. If it is a <code>'\n'</code>, the remove it by overwriting with the <em>nul-terminating</em> character, e.g.</p>

<pre><code>    /* read each line up to MAXL lines */
    while (n &lt; MAXL &amp;&amp; fgets (str[n], MAXC, fp)) {
        size_t len = strlen (str[n]);   /* get length */
        long tmp;       /* tmp value for conversion */
        errno = 0;      /* reset errno before each conversion     */
        if (len &amp;&amp; str[n][len-1] == '\n')   /* is last char '\n'? */
            str[n][--len] = 0;         /* overwrite with nul-char */
        else {           /* the string was too long, handle error */
            fprintf (stderr, ""error: value at line %d too long.\n"", n);
            return 1;
        }
</code></pre>

<p>(<strong>note:</strong> you also have the benefit of confirming if the line was too-long for the buffer if the last char was not <code>'\n'</code>)</p>

<p>Next, you fail to validate the return of <code>fgets</code>. The read could fail and you still try and copy <code>temp</code>, e.g. (<code>strcpy(str[i], temp);</code>). You must validate ALL user input or you can have no confidence you are not simply processing garbage from that point on.</p>

<p>You can use <code>strtol</code> to convert your string to a <code>long</code>. Use a temporary <code>long</code> for the return from <code>strtol</code>, then, after checking <code>errno</code> to validate the conversion, you can validate the number returned is within the range of valid integers before assigning it to your integer array, e.g.</p>

<pre><code>        tmp = strtol (str[n], NULL, BASE);  /* convert to long */
        if (errno) {                        /* validate conversion */
            fprintf (stderr, ""error: conversion to int failed '%s'.\n"",
                    str[n]);
            return 1;
        }   /* validate in integer range */
        if (tmp &lt; INT_MIN || tmp &gt; INT_MAX) {
            fprintf (stderr, ""error arr[%ld] exceeds range of int.\n"", 
                    tmp);
            return 1;
        }
        arr[n++] = tmp; /* assign converted &amp; validated value to array */
</code></pre>

<p>Putting it altogether, you can read your file (or from <code>stdin</code>), store the values read as strings and convert the strings to integer values with something like the following:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;limits.h&gt;

enum { MAXC = 8, BASE = 10, MAXL = 26 };

int main (int argc, char **argv) {

    int n = 0,                      /* array index */
        arr[MAXL] = {0};            /* array of integers */
    char str[MAXL][MAXC] = {""""};    /* array of strings */
    FILE *fp = argc &gt; 1 ? fopen (argv[1], ""r"") : stdin;

    if (!fp) {  /* validate file open for reading */
        fprintf (stderr, ""error: file open failed '%s'.\n"", argv[1]);
        return 1;
    }

    /* read each line up to MAXL lines */
    while (n &lt; MAXL &amp;&amp; fgets (str[n], MAXC, fp)) {
        size_t len = strlen (str[n]);   /* get length */
        long tmp;       /* tmp value for conversion */
        errno = 0;      /* reset errno before each */
        if (len &amp;&amp; str[n][len-1] == '\n')   /* is last char '\n'? */
            str[n][--len] = 0;         /* overwrite with nul-char */
        else {           /* the string was too long, handle error */
            fprintf (stderr, ""error: value at line %d too long.\n"", n);
            return 1;
        }
        tmp = strtol (str[n], NULL, BASE);  /* convert to long */
        if (errno) {                        /* validate conversion */
            fprintf (stderr, ""error: conversion to int failed '%s'.\n"",
                    str[n]);
            return 1;
        }   /* validate in integer range */
        if (tmp &lt; INT_MIN || tmp &gt; INT_MAX) {
            fprintf (stderr, ""error arr[%ld] exceeds range of int.\n"", 
                    tmp);
            return 1;
        }
        arr[n++] = tmp; /* assign converted &amp; validated value to array */
    }
    if (fp != stdin) fclose (fp);   /* close file if not stdin */

    for (int i = 0; i &lt; n; i++)     /* output both string and ints */
        printf (""str[%2d] : %-3s    arr[%2d] : %3d\n"",
                i, str[i], i, arr[i]);

    return 0;
}
</code></pre>

<p><strong>Example Use/Output</strong></p>

<pre><code>$ ./bin/cnvstrtoint &lt; ../dat/numdata.txt
str[ 0] : 8      arr[ 0] :   8
str[ 1] : 2      arr[ 1] :   2
str[ 2] : 0      arr[ 2] :   0
str[ 3] : 10     arr[ 3] :  10
str[ 4] : .5     arr[ 4] :   0
str[ 5] : 3      arr[ 5] :   3
str[ 6] : 7      arr[ 6] :   7
str[ 7] : 3      arr[ 7] :   3
str[ 8] : 7      arr[ 8] :   7
str[ 9] : 12     arr[ 9] :  12
str[10] : 12     arr[10] :  12
str[11] : 12     arr[11] :  12
str[12] : 12     arr[12] :  12
str[13] : 1      arr[13] :   1
str[14] : 10     arr[14] :  10
str[15] : .5     arr[15] :   0
str[16] : 12     arr[16] :  12
str[17] : 12     arr[17] :  12
str[18] : 12     arr[18] :  12
str[19] : 12     arr[19] :  12
str[20] : 7      arr[20] :   7
str[21] : 3      arr[21] :   3
str[22] : 7      arr[22] :   7
str[23] : 3      arr[23] :   3
</code></pre>

<p><strong>note:</strong> the integer conversion of <code>.5</code> above results in <code>0</code>, so if you need to store floating point values, you must declare the array to hold the converted values to <code>double</code> or <code>float</code> and use a floating-point conversion like <code>strtod</code> for the conversion.</p>

<p>Look things over and let me know if you have further questions.</p>

<hr>

<p><strong>Handling non-long integer Lines</strong></p>

<p>As you have found, depending on your implementation, <code>strtol</code> may not accept and truncate <code>.5</code> to <em>zero</em>, instead it may set <code>errno</code>. You have the flexibility to handle a failed conversion any way you choose. For example, if you want to assign <code>0</code> manually on a failed conversion and keep the index consistent with the number of lines read, you can <em>warn</em> on the failed conversion and manually assign <code>0</code>, e.g.</p>

<pre><code>    if (errno) {                        /* validate conversion */
        /* if you want to assing zero on a failed conversion, warn */
        fprintf (stderr, ""warning: conversion to int failed '%s' - ""
                ""assigning 0.\n"", str[n]);
        tmp = 0;
    }
</code></pre>

<p>(output is the same)</p>

<p>On the other hand, if you simply want to skip any values that are not converted by <code>strtol</code>, you can simply <em>warn</em> and <code>continue</code> (the line having already been read by <code>fgets</code>, continuing just advances to the next line in the file):</p>

<pre><code>    if (errno) {                        /* validate conversion */
        /* if you want to skip the value entirely, just continue */
        fprintf (stderr, ""warning: conversion to int failed '%s' - ""
                ""skipping.\n"", str[n]);
        continue;
    }   /* validate in integer range */
</code></pre>

<p><strong>Example Use/Output (skipping non-long integer values</strong></p>

<pre><code>$ ./bin/cnvstrtoint &lt; ../dat/numdata.txt
str[ 0] : 8      arr[ 0] :   8
str[ 1] : 2      arr[ 1] :   2
str[ 2] : 0      arr[ 2] :   0
str[ 3] : 10     arr[ 3] :  10
str[ 4] : 3      arr[ 4] :   3
str[ 5] : 7      arr[ 5] :   7
str[ 6] : 3      arr[ 6] :   3
str[ 7] : 7      arr[ 7] :   7
str[ 8] : 12     arr[ 8] :  12
str[ 9] : 12     arr[ 9] :  12
str[10] : 12     arr[10] :  12
str[11] : 12     arr[11] :  12
str[12] : 1      arr[12] :   1
str[13] : 10     arr[13] :  10
str[14] : 12     arr[14] :  12
str[15] : 12     arr[15] :  12
str[16] : 12     arr[16] :  12
str[17] : 12     arr[17] :  12
str[18] : 7      arr[18] :   7
str[19] : 3      arr[19] :   3
str[20] : 7      arr[20] :   7
str[21] : 3      arr[21] :   3
</code></pre>

<p>Look things over a second time and let me know if you have further questions.</p>
",2
47497657,47497527,4,"<p>The include statements are not correct and do not need a full path. You will probably need:</p>

<pre><code>#include &lt;sys/fcntl.h&gt; 
#include &lt;sys/stat.h&gt;
#include &lt;sys/ioctl.h&gt;      
#include &lt;unistd.h&gt;     
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
</code></pre>
",3
44377488,44377418,3,"<p>You aren't dereferencing the pointer properly. </p>

<p>At line 11:</p>

<pre><code>ptr[i] = rand();
</code></pre>

<p>At line 20:</p>

<pre><code>if (ptr[i] &gt; ptr[j]){
    ptr[i] = ptr[j];
}
</code></pre>

<p>Alternatively you can specify <code>*(ptr + i)</code> to get the value at <code>ptr[i]</code>.</p>
",0
44377806,44377418,1,"<p>Here is a version with the errors avoided and <code>-Wall</code>warnings, too.<br>
I did not change things which are against good coding practice. Take some time later to learn about those, too. Read the comments on your question and on this answer for doing that.
As an encore I got your sorting working (in a very blind, inefficient way) and added a printer, for demonstration purposes. I use array size 10 instead of 100, for convenience. It seems that you intend to keep the orignal array and create a sorted version, I left that for you.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
    int myArray[10];
    int *ptr = myArray;
    // int i; Do not use globals for counters inside functions.

    // it would be better to give the size of arrays as an explicit
    // parameter to functions, instead of using a global variable
    // (keeping this only for minimised differences to your code)
    int n = sizeof(myArray)/sizeof(int);

void MakeRandArray(int *ptr)
{
    int i;
    for(i = 0; i &lt; n; i++)
    {
        *(ptr + i) = rand();
    }
}

void PrintArray(int *ptr)
{
    int i;
    for(i = 0; i &lt; n; i++)
    {
        printf(""%8d\n"", *(ptr + i));
    }
    printf(""\n"");
}


void SortArray(int *ptr)
{
    // this is far off even the simplest sorting algorithms
    // it is worth reading up on one (e.g. the quite simple bubble sort),
    // then enjoy optimising this (my) totally blind method here;
    // note that I sort within the original array,
    // you seem to intend to keep unsorted in addition to sorted
    int i;
    int j;
    for (j = 0; j &lt; n; j++)
    {
        for (i = 0; i &lt; n-1; i++)
        {   int help;
            if (*(ptr+i) &gt; *(ptr + i + 1))
            {
                help = *(ptr+i);
                *(ptr + i) = *(ptr + i + 1);
                *(ptr + i + 1)=help;
            }
        }
    }
}    

int main(void)
{
    MakeRandArray(ptr);
    PrintArray(ptr);
    SortArray(ptr);
    PrintArray(ptr);

    return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>      41
   18467
    6334
   26500
   19169
   15724
   11478
   29358
   26962
   24464

      41
    6334
   11478
   15724
   18467
   19169
   24464
   26500
   26962
   29358
</code></pre>
",8
44377633,44377418,1,"<p>You're using old-style (pre-standard, K&amp;R style) function definitions.  You should be using the faintly modern C90 and later prototype style function definitions.</p>

<p>You wrote:</p>

<pre><code>int MakeRandArray(ptr, i)
{
    for (i = 0; i &lt; n; i++) {
        (ptr + i) = rand()
    }
}
</code></pre>

<p>In this function as shown, the type of <code>ptr</code> is <code>int</code>, as is the type of <code>i</code> ¡ª they are implicitly typed to <code>int</code> because you didn't specify the type.  (Note that these variables are unrelated to the global variables <code>ptr</code> and <code>i</code> ¡ª they simply hide the global variables.  They do <em>not</em> inherit the same type as the global variables.)  You should pass <code>n</code> to the function and should not pass <code>i</code> to the function.  You should avoid all those global variables.</p>

<p>You immediate compilation error is because you omit the <code>*</code> from <code>*(ptr + i)</code> and you also omit the <code>;</code> at the end of the statement.  You should use <code>ptr[i]</code> because it is simpler, easy to type, easier to read, more reliable, and generally more beneficial to everyone than the alternative.</p>

<p>You claim your function returns an <code>int</code>; it returns nothing.</p>

<p>Thus, your code for this function should be:</p>

<pre><code>void MakeRandArray(int *ptr, int n)
{
    for (int i = 0; i &lt; n; i++)
        ptr[i] = rand();
}
</code></pre>

<p>You can put the braces around the body of the loop if you prefer; personally, I don't prefer that.  Defining <code>i</code> in the loop like that requires a compiler that handles C99 mode.  If you were really stuck, you could define <code>int i;</code> before the loop and remove <code>int</code> from the loop control line.  However, you're on a Mac; you are not that stuck.</p>

<p>There are similar issues throughout the code.</p>

<pre><code>// Syntactically valid; semantically dubious - it does not sort!
void SortArray(int *ptr, int n)
{
    for (int i = 0; i &lt; n; i++)
    {
        int j = i + 1;
        if (ptr[i] &gt; ptr[j])
            ptr[i] = ptr[j];
    }
}

int main(void)
{
    MakeRandArray(myArray, 100);
    SortArray(myArray, 100);
}
</code></pre>

<p>Note that even though it should compile, it won't sort the array.  Of course, you've not shown any printing code, so you can't demonstrate that the array is, or is not, sorted.  You'd need to do that.  You could write a function to check that the array is sorted.</p>

<p>Your sort function will need a second loop inside it, iterating <code>j</code>.  You will need to swap elements, not simply overwrite them.</p>

<p>Your definition of <code>n</code> is:</p>

<pre><code>int n = sizeof(myArray);
</code></pre>

<p>This probably sets <code>n</code> to 400.  If you want the size of an array, you need <code>int n = sizeof(myArray) / sizeof(myArray[0]);</code> which gives the correct answer in this context.  You should be able to do without that variable, and the global <code>i</code>, <code>ptr</code>.  You don't use <code>SortedArray</code> at all.  The <code>myArray</code> could be local to <code>main()</code> ¡ª which means you need no global variables at all.  Try to avoid global variables; they are often not a good idea.</p>
",0
47964230,47961545,0,"<p>An array size is <strong>fixed</strong> once the array is created.  It cannot change.</p>

<hr>

<p>If <code>fp</code> can be read twice, read the file once for the word count.</p>

<pre><code>size_t word_count = 0;
int word_length_max = 0;

long pos = ftell(fp); // remember file location
int n = 0;
while (fscanf(fp, ""%*s%n"", &amp;n) != EOF &amp;&amp; n &gt; 0) {  // Use %n to record character count
  word_count++;
  if (n &gt; word_length_max) {
    word_length_max = n; 
  }
  n = 0; 
}
</code></pre>

<p>Now code knows the <code>word[]</code> array size needed and the maximum length.</p>

<pre><code>char *words[word_count];
char word[word_length_max + 1u];  // buffer size needed to read in the words

fseek(fp, pos, SEEK_SET); // go back
for (size_t i=0; i&lt;word_count; i++) {
  if (fscanf(fp, ""%s"", word) != 1) {
    Handle_UnexpectedError(); // 2nd pass should have same acceptable results
  }
  words[i] = strdup(word); // allocate a duplicate 
}
</code></pre>

<p>When done with <code>words[]</code>, be sure to free the allocated memory.</p>

<pre><code>....  
for (size_t i=0; i&lt;word_count; i++) {
  free(words[i]);
}
</code></pre>

<p>Better code would also check the return value of <code>ftell(), fseek(), malloc()</code> for errors and limit <code>fscanf(fp, ""%s"", word)</code>.</p>
",0
47969303,47969265,1,"<p>Try this.</p>

<pre><code>void remplitPartieSup(int tab[N][N])
{ 
   int i,j;
   for (i=0;i&lt;N;i++)
      {
        for (j=i+1;j&lt;N;j++)
         {
             tab[i][j]=1;
         }
      }
}
</code></pre>
",2
47983708,47982711,0,"<p>doing a quick 'google' for a bubble sort, in C, results in:</p>

<pre><code>// where 'n' is the number of entries in the array
// where 'array' is declared as 'int array[n];
for ( int c = 0 ; c &lt; ( n - 1 ); c++ )
{
    for ( int d = 0 ; d &lt; n - c - 1; d++ )
    {
        if ( array[d] &gt; array[d+1] ) /* For decreasing order use &lt; */
        {
            int temp   = array[d];
            array[d]   = array[d+1];
            array[d+1] = temp;
        }
    }
}
</code></pre>

<p>Notice the limits on the upper bound of the index variables.</p>

<p>in your program you will be using <code>char</code> rather than <code>int</code> for <code>temp</code> and for the declaration of <code>array[]</code></p>

<p>notice there is no need for anything in the <code>string.h</code> header file.</p>

<p>notice the limiting of the scope of the local variables <code>c</code>, <code>d</code>, and <code>temp</code></p>

<p>The comments on your posted question cover the problems in the posted code, so I will not repeat all of them here.</p>
",0
47983773,47982711,0,"<pre><code>for(i=0;i&lt;7;i++) {
  scanf(""%s"",array);
}
</code></pre>

<p>If you want 8 strings of length 7, you can't scanf them into the array. Your array is an array of pointers as defined here:</p>

<pre><code>char *array[8];
</code></pre>

<p>Which is very different from this:</p>

<pre><code>char array[8];
</code></pre>

<p>The first is an array that stores 8 pointers to strings. The second is an array that stores 8 characters. If you wanted to store a single string, you would do this:</p>

<pre><code>char array[8];
printf(""Please input a string with size 7: "");
scanf(""%s"", array);
</code></pre>

<p>Which is probably what you're used to at this point.</p>

<p>So, an array of pointers is just like a list of little arrows that point to blocks of memory. Your array doesn't store any characters itself, which is why you can't scanf directly into it.</p>

<pre><code>int main(void) {
  char *arr[8];
  char new_word[8];

  for(int i = 0; i &lt; 8; i++) {
    printf(""Enter a new word of length 7: "");
    scanf(""%s"", new_word);
    arr[i] = malloc(strlen(new_word) + 1);
    strcpy(arr[i], new_word);
  }
  for(int i = 0; i &lt; 8; i++) {
    printf(""%s\n"", arr[i]);
  }

  return 0;
}
</code></pre>

<p>This program creates two arrays: a pointer array (arr) and a character array (new_word). In the loop, you ask for seven strings of length 7, which is scanf'd into the character array. New memory is set aside for that string with malloc. Then, the string is copied into the block of memory that your first array pointer points to. We increment our array index with the for loop so that now we're using the next pointer, and so on. </p>

<p>It's important to use strcpy and copy the string out of the character array every time, otherwise at the end, you will just have an array of pointers pointing to a single string, new_word.</p>
",0
48001161,48000678,0,"<p><code>strrev</code> is not standard, but can be easily implemented</p>

<pre><code>void strrev(char *s) {
    int i,n = strlen(s);
    for(i=n/2 ; i&gt;=0 ; i--) {
        char c = s[i];
        s[i] = s[n-i-1];
        s[n-i-1] = c;
    }
}
</code></pre>
",0
48010956,48010931,0,"<pre><code>strcat(naam,""\""\"""");
</code></pre>

<p>This is the way. You have to escape them so that they are considered pass of the string literal.</p>

<p>If you want it around the filename then <code>sprintf</code> is the way to go.</p>

<p>Also it is not clear why you want to concatenate then in the <code>naam</code>.</p>

<p>If <code>naam</code> is something like this <code>filename.txt</code> then it will be after putting any of these operations mentioned above will be </p>

<p><code>""filename.txt""</code> or <code>filename.txt""""</code>.</p>

<p>You can do it more clearly given the context that it will be used in <code>fopen</code>.</p>

<pre><code>const char *filename = ""file.txt"";
FILE *fp = fopen(filename,""r"");
</code></pre>

<p><strong>Edit</strong> (Yes  this is for illustration - <code>strcpy</code> etc are used)</p>

<p>For the OP the correct code would be</p>

<pre><code>strcpy(naam, n);
strcat(naam, ""."");
strcat(naam, x);
...
if ((fp = fopen(naam, ""w+"")) == NULL){
     fprintf(fp,""Hello world"");
}
fclose(fp);
</code></pre>
",0
46978050,46977982,0,"<p>You're returning <code>int</code> from the function, which is the integral type that does not hold fractional type. Look at your declaration: <code>int checkInput1(void)</code>. <code>int</code> before function name (<code>checkInput1</code>) signifies the type returned. Consider using other type there.</p>
",0
47491359,47488361,0,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
char*pointer(char*now);

void main() {
    char*name = ""Paz Leviim"", **p_name = &amp;name;
    *p_name = pointer(*p_name);
    printf(""Now it's %s"", *p_name);
    getchar();
}
char*pointer(char*now) {
    static char name_to_main[100];
    printf(""The value now is %s\nPlease set value:"",now);
    scanf_s(""%[^\n]%*c"", &amp;name_to_main,100);
    return name_to_main;
}
</code></pre>

<p>Now all working :)</p>
",0
47504102,47503966,1,"<p>You need to use <code>wait()</code> command, system call <code>wait()</code> function blocks the calling process until one of its child processes exits or a signal is received.</p>

<pre><code>int status;
pid_t pid = wait(&amp;status);
printf(""Exit = %d, child = %d\n"", WEXITSTATUS(status), pid);
</code></pre>

<p>see example at:</p>

<p><a href=""https://stackoverflow.com/questions/2708477/fork-and-wait-with-two-child-processes"">fork() and wait() with two child processes</a></p>

<p>and 2nd example using wait() and WEXITSTATUS()</p>

<p><a href=""https://stackoverflow.com/questions/22431386/linux-fork-and-wait"">Linux fork() and wait()</a></p>

<p>Also more about what happen with multiple cores scheduling of processes:</p>

<p><a href=""https://stackoverflow.com/questions/28242722/fork-and-wait-calls"">fork() and wait() calls</a></p>
",1
44647698,44647576,0,"<p>You need a &amp; to scan into.</p>

<pre><code>int a,i;

scanf(""%d"", &amp;a);
for(i=0; i&lt;a; i++){...}
</code></pre>

<p>Read a bit more about scanning integers here.</p>

<p><a href=""https://stackoverflow.com/questions/26583717/how-to-scanf-only-integer"">How to scanf only integer?</a></p>
",0
44647773,44647576,0,"<p>Change <code>scanf(""%d"", a)</code> to <code>scanf(""%d"", &amp;a)</code></p>

<p>The code didn't work for you because you failed to store the value entered by the user.<br>
Before modifying your code as my suggestion try to print the value of <code>a</code> in your code, you'll get it, why it's not working..</p>
",2
44647830,44647576,0,"<p>The problem is in line:</p>

<pre><code>scanf(""%d"", a);
</code></pre>

<p>You have to use:</p>

<pre><code>scanf(""%d"", &amp;a);
</code></pre>

<p><code>&amp;</code> sign represents address, you want to store input value on the address of variable <code>a</code>. </p>

<p>Read more about ampersand here:
<a href=""https://stackoverflow.com/questions/18403154/when-should-i-use-ampersand-with-scanf"">When should I use ampersand with scanf()</a></p>
",0
44739384,44739276,3,"<p>Here is a simple way to compute the number of digits at the start of a string, including initial zeroes:</p>

<pre><code>#include &lt;string.h&gt;

size_t count_digits(const char *s) {
    return strspn(s, ""0123456789"");
}
</code></pre>

<p><code>strspn()</code>, a lesser known but standard function, counts the number of characters at the start of its first string argument that are present in the second string argument. Its counterpart <code>strcspn()</code> counts the characters that are not present in the second string argument, it can be used to remove the trailing newline from the buffer filled by <code>fgets()</code>: <code>buf[strcspn(buf, ""\n"")] = '\0';</code>.</p>
",5
44739684,44739276,0,"<p><a href=""https://stackoverflow.com/users/4593267/chqrlie"">chqrlie</a>'s <a href=""https://stackoverflow.com/a/44739384/2371524"">answer</a> is arguably the simplest possible solution in C if you don't want to go with a simple <code>strlen()</code>. The following would be a bit more efficient:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

size_t numDigits(const char *str)
{
    size_t n = 0;

    // increment counter while the character is a digit:
    while (isdigit(str[n])) ++n;

    return n;
}

int main(int argc, char **argv)
{
    if (argc != 2)
    {
        fprintf(stderr, ""Usage: %s [number]\n"", argv[0]);
        return 1;
    }
    size_t digits = numDigits(argv[1]);
    if (argv[1][digits]) // not end of string after the digits found
    {
        puts(""not a number"");
    }
    else
    {
        printf(""%zu digits\n"", digits);
    }
    return 0;
}
</code></pre>
",8
44745262,44739276,0,"<p>I'm new here but most languages have a trim left &amp; right function to remove spaces and a Len function to return a string length so something like:</p>

<pre><code>nbrdigits = len(rtrim(ltrim(inputstring)))
</code></pre>

<p>Assuming that only digits were input.</p>
",0
47540168,47540110,2,"<p>No need for <code>&amp;</code> on <code>b[i].name</code> as this decomposes to a pointer to the zeroth element already</p>
",0
47540191,47540110,4,"<p><code>&amp;b[i].name</code> is a pointer to an array of <code>char</code> (it's a <code>char (*)[25]</code>), but <code>scanf</code> wants a pointer to a <code>char</code> (a <code>char*</code>).  </p>

<p>You need to pass a pointer to the array's first element.</p>

<p>You can either get that explicitly with <code>&amp;b[i].name[0]</code>, or rely on implicit conversion  with just <code>b[i].name</code></p>
",0
47537951,47537853,5,"<p>This is the signature of the <code>signal</code> function.  </p>

<p>The first argument <code>signr</code> is of type <code>int</code> and is the signal whose handler you want to change.  </p>

<p>The second argument <code>sighandler</code> is a function pointer of type <code>void (*)(int)</code>, i.e. a function that takes an <code>int</code> and returns <code>void</code>.  This parameter is the name of a function which will handle the signal.</p>

<p>The function returns a function pointer of type <code>void (*)(int)</code> (same type as argument 2) which points to the previous signal handling function.</p>

<p>Breaking it down:</p>

<pre><code> signal                                 // signal
 signal()                               // is a function
 signal(int)                            // taking a int
 signal(int, void (*)(int))             // and a function pointer
                                        // which takes an int and return void
 (*signal)(int, void (*)(int))(int)     // and returns a function pointer
                                        // which takes an int
 void (*signal)(int, void (*)(int))(int)   // and returns void
</code></pre>

<p>The man page includes a typedef which makes this a bit more clear:</p>

<pre><code>typedef void (*sighandler_t)(int);

sighandler_t signal(int signum, sighandler_t handler);
</code></pre>
",0
45074923,45074746,0,"<blockquote>
  <p>F(x) x^3-2.5x^2-1.8x+2.356</p>
</blockquote>

<ol>
<li>^ is not the power operator in C use pow(), powf() function (but in this case there is no need of it)</li>
<li>2.5x has to be 2.5 * x - buy a book about C</li>
<li>do not #define functions make them ""real""functions</li>
<li>Do not use double literals in float expressions</li>
</ol>

<hr>

<pre><code>float F(float x)
{
  return x * x * x + 2.5f * x * x + 1.8f * x + 2.356f;
}
</code></pre>
",1
47531395,47531314,1,"<p>Static variables are not visible outside the C file where they are declared (or even outside the scope, with ""C file"" being ""a particular file's file scope""). So there is no collision, and of course variable names don't matter in compiled code.</p>
",0
47531484,47531314,1,"<p>The static variable is visible only within the module, it provides the local linkage. </p>

<ol>
<li>The static variable inside the function it retains the value during function call.</li>
<li>The Static global variable or the function is visible only in the file or module that is declared.</li>
</ol>

<hr>

<p>The static specifier specifies both static storage duration and internal linkage.</p>

<p>Static storage duration. The storage duration is the entire execution of the program, and the value stored in the object is initialized only once, prior to main function.</p>
",1
47554649,47554158,1,"<p>Here is a simple code that do the job.</p>

<p>First put your text inside a <code>test.txt</code> file, save it in C source code path.</p>

<blockquote>
  <p>test.txt</p>
</blockquote>

<pre><code>A17ke4004       44         66      84
A17ke4005       33         62      88
A17ke4008       44         66      86
</code></pre>

<p><strong><em>Code</em></strong></p>

<pre><code>#include &lt;stdio.h&gt;

int main (void)
{

        FILE *fp = NULL;
        char *line = NULL;
        size_t len = 0;
        size_t read = 0;
        char string[10][32];
        int a[10], b[10], c[10];
        int count = 0;

        fp = fopen(""test.txt"", ""r"");

        if(fp != NULL){
            while((read = getline(&amp;line, &amp;len, fp)) != -1){
                sscanf(line, ""%s%d%d%d"", string[count], &amp;a[count], &amp;b[count], &amp;c[count]);
                printf(""&lt;%s&gt; - &lt;%d&gt; - &lt;%d&gt; - &lt;%d&gt;\n"", string[count], a[count], b[count], c[count]);
                count++;
            }
        }else{
                printf(""File can't open\n"");
        }

        return 0;
}
</code></pre>

<blockquote>
  <p>Compile, Run</p>
</blockquote>

<p><code>gcc -Wall  -Wextra te.c -o te</code></p>

<p><code>./te</code></p>

<p>If you have more than 10 lines you should increase the arrays dimension.
Hope this help you.</p>
",4
45787121,45786872,1,"<p>The solution depends on how ""pedantic"" your code has to be when deciding if an input is valid or not. For example, you might expect <code>""2-14""</code>, <code>""02 - 15""</code>, <code>""  2-14   ""</code> as valid, or you might not. It depends. </p>

<p>If you want to get a pedantic version that accepts only the exact format <code>""dd-dd""</code> with no leading or trailing characters or white spaces and with exactly a two-digit format for each hour value, you could check the string as follows before reading in the values with your <code>sscanf</code>-code:</p>

<pre><code>if (strlen(hours) != 5)
    return 0;

if (hours[2] != '-')
    return 0;

if ( !isdigit(hours[0])
    || !isdigit(hours[1])
    || !isdigit(hours[3])
    || !isdigit(hours[4])
    )
    return 0;
</code></pre>
",2
45787401,45786872,0,"<p>Another way:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

bool hourIsValid(
      char *I__hours
      )
   {
   long openH, closeH;

   openH=strtol(I__hours, &amp;I__hours, 10);
   if(      '-' != *I__hours                   // Ensure that there is a dash between the two numbers in the string.
         || 0 &gt;= openH                         // Ensure that the 1st number in the string is non-negative.
         || 24 &lt;= openH                        // Ensure that the 1st number in the string is 24 or less.
         )
      return(false);

   ++I__hours;                                 // Skip over the dash between the two numbers.
   closeH=strtol(I__hours, &amp;I__hours, 10);
   if(      *I__hours                          // Ensure that there are no additional characters beyond the 2nd number.
         || 0 &gt;= closeH                        // Ensure that the 2nd number in the string is non-negative.
         || 24 &lt;= closeH                       // Ensure that the 2nd number in the string is 24 or less.
         || openH &gt;= closeH                    // Ensure that the 1st number is less or equal to the 2nd number.
         )
      return(false);

   return(true);
   }
</code></pre>
",4
47660894,47660560,0,"<p>Try to store the variable using scanf(); also u can declare variables as follows: if u did not mention int before main(),than by default it returns as int type.. </p>

<pre><code>#include &lt;stdio.h&gt;
main()
{
        int A,B,C;
        printf(""Enter A: "");
        scanf(""%d"", &amp;A);
        printf(""Enter B: "");
        scanf(""%d"", &amp;B);
        printf(""Enter C: "");
        scanf_s(""%d"", &amp;C);
        if (A &gt; B)
        {
                if (A &gt; C)
                {
                        printf(""A is largest. \n"");
                }
                else
                {
                        printf(""C is largest. \n"");
                }
        }
        else
        {
                if (B &gt; C)
                {
                        printf(""B is largest. \n"");
                }
                else
                {
                        printf(""C is largest. \n"");
                }
        }
return 0;
}
</code></pre>
",2
47663322,47663229,0,"<p>That's expected behavior in C and other languages. Your title of the question also is not worded very well. The assignment operator ""is"" the equal operator, and that is exactly what you are using. You might be getting confused by the order of operations in C. On your <code>printf</code> line, the expression <code>y = x</code> happens first, and the resulting value (<code>y</code>) is used as a parameter in your <code>printf</code> function, which is why you see the value of <code>y</code> printed. This is one of the fundamentals of C. I would recommend reading up on C syntax.</p>
",0
47663368,47663229,1,"<p>According to the <a href=""http://port70.net/~nsz/c/c11/n1570.html#6.5.16p3"" rel=""nofollow noreferrer"">standard</a>, an assignment expression evaluates to the valueof the left operand <em>after</em> assignment: </p>

<blockquote>
  <p><strong>6.5.16 Assignment operators</strong></p>
  
  <p>(3) An assignment operator stores a value in the object designated by
  the left operand. An assignment expression has the value of the left
  operand after the assignment</p>
</blockquote>

<p>So <code>y=x</code> in <code>printf( ""%d\n"", y = x)</code> first lets <code>y</code> take on the value of <code>x</code>, and then evaluates to the (newly assigned) value of <code>y</code>. So the output of the <code>printf</code>-statement will be <code>5580</code>, i.e. the value of <code>x</code>, which is the new value of <code>y</code>.</p>
",1
45217582,45216116,0,"<p>Looking at your code, you seem to be trying to call <code>Win32 API</code> functions, get current user's username and print a greeting message based on time of day (but you didn't implement this part yet).</p>

<p>When concatenating two null-terminated strings, you need to make sure that the target buffer has enough space to hold the two strings that you are concatenating.</p>

<p>In your case, you already know your maximum space required to hold username, through the use of <code>UNLEN</code> macro.</p>

<p>So you can use a buffer with size: <code>sizeof(msg1) + UNLEN</code> alocated through malloc. something like this:</p>

<pre><code>char *target_msg1 = (char *)malloc(sizeof(msg1) + UNLEN);
</code></pre>

<p>You can even use the <code>lpnSize</code>parameter of <code>GetUserName</code> and allocate as little space as possible, but since you are doing Win32 programming I don't think a couple bytes of memory is much of a concern.</p>

<p>Your code would change like this:</p>

<pre><code>strcpy(target_msg1, msg1);
insert_substring(target_msg1,username,17);
printf(""%s\n"",target_msg1);
</code></pre>
",2
45215322,45215258,2,"<p>If you want to print the address you need the appropriate specifier,</p>

<pre><code>printf(""%p\n"", __builtin_return_address(0));
</code></pre>

<p>should work.</p>
",0
45215360,45215258,4,"<p>According to <a href=""https://gcc.gnu.org/onlinedocs/gcc/Return-Address.html"" rel=""nofollow noreferrer"">gcc.gnu.org</a>, syntax of function:</p>

<pre><code>void * __builtin_return_address (unsigned int level)
</code></pre>

<p>function return the <code>void*</code>. So, use <code>%p</code> format specifier instead of <code>%s</code>.</p>
",0
47962230,47962211,3,"<p>The issue is that you never read the <code>EOF</code> (End Of File); this is the end of the input data coming from the console (where you type).</p>

<p>Everything you type is either a letter, digit, special character, or newline, but never <code>EOF</code>.</p>

<p>To generate an <code>EOF</code> you need to enter a special control-key combination. On Windows this is <code>Ctrl+Z</code> and on UNIX/Linux/macOS this is <code>Ctrl+D</code>.</p>

<p>The book you're reading is great and written by the two creators of C. It one of my first programming books and I still have it; all worn-out.</p>

<p>Small piece of advice: Always put your code blocks inside <code>{ }</code> to avoid mistakes and create more visual clarity, use spaces consistently, and add empty lines. Your code would look like this:</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

int main()
{
    int c, nl;
    nl = 0;

    while ((c = getchar()) != EOF)
    {
        if (c == '\n')
        {
            ++nl;
        }
    }

    printf(""%d\n"", nl);

    return 0;
}
</code></pre>
",0
47962232,47962211,1,"<p>Why should it stop? Your expectations are wrong. <code>getchar()</code> will go on getting characters until it encounters <code>EOF</code>.</p>
<h3>How to pass that to <code>getchar</code>?</h3>
<p>For Windows <kbd>Ctrl+Z</kbd> will do the trick. And then press <kbd>Enter</kbd>.<br />
For Unix or Linux system it would be <kbd>Ctrl+D</kbd></p>
<h3>Responsive output before entering <code>EOF</code></h3>
<p>To get a more responsive output you can add this line, that will tell you the cumulative sum of <code>\n</code> found.</p>
<pre><code>    if(c == '\n'){
        ++nl;
        printf(&quot;Till now %d newline found&quot;,nl);
        fflush(stdout);
    }
</code></pre>
<h3>Further Explanation of the added code</h3>
<p>The code segment provided above will provide you some output when you press enter. But the thing is until you enter <code>EOF</code> it will keep on waiting for more and more input. That's what also happened in the first case. So you have to press <kbd>Ctrl+Z</kbd> and press <kbd>Enter</kbd>. That will break the loop. And you will see the final output - the number of line count.</p>
",0
48009271,48002129,0,"<p>regarding: </p>

<pre><code>//transfer the output to mytab2411.txt//
result = freopen(""mytab2411.txt"", ""w+"", stdout);
</code></pre>

<p>The modification to the I/O only applies to output AFTER the call is made. </p>

<p>Suggest placing this statement at the beginning of the 'encrypt' section of the code.</p>
",0
45733121,45732759,0,"<p>Assume <code>char *score</code> points to a score like <code>""1-3""</code>, then:</p>

<pre><code>int i1= atoi(score);
while (*score!='-') score++;
score++;
int i2= atoi(score);
</code></pre>

<p>This is also called Stupid Character Processing.</p>

<p>A more complete example would be:</p>

<pre><code>if (!isdigit(*score)) return(-1);
int i1= atoi(score);
while (*score &amp;&amp; *score!='-') score++;
if (!*score) return(-1);
score++;
if (!isdigit(*score)) return(-1);
int i2= atoi(score);
</code></pre>

<p>where <code>return(-1)</code> means an error.</p>
",1
47699568,47699543,1,"<p>In <code>main()</code> you declare <code>n</code> but it has no value, so likely defaults to 0.  You then declare and define an array <code>A</code> and give it size <code>n</code>, which as I say is likely zero.</p>

<p>Within <code>max()</code> you then read in a value and assign it to <code>n</code> but your array <code>A</code> is size zero.</p>

<p>So change <code>main()</code> to</p>

<pre><code>/* Get the number of items to store in the array */
int n;
printf(""Enter the number of elements you want in your array\n"");
scanf(""%d"",&amp;n);

/* Create the array of the given size */
int A[n];

/* Now find the max value in that array */
max(n,A);
</code></pre>

<p>And remove the setting of <code>n</code> from <code>max()</code>.</p>
",7
47699614,47699543,2,"<pre><code>int n;
int A[n];
</code></pre>

<p>You have to initialize <code>n</code> otherwise it contains garbage value. And now after this point you run into undefined behavior.</p>

<p>Correct code would be</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
void printMax(int n,int A[]);

int main()
{
    size_t n;
    printf(""Enter the number of elements you want in your array\n"");
    if( scanf(""%zu"",&amp;n) != 1){
        fprintf(stderr,""Error in input"");
    }
    if( n &lt;= 0){
        fprintf(stderr, ""%s\n"", ""Error in input : Enter number &gt;= 0 ."");
    }
    int a[n];
    printf(""Enter the elements  in your array\n"");
    for(size_t i = 0; i &lt; n; i++)
    {
        if( scanf(""%d"",&amp;a[i]) != 1){
            fprintf(stderr,""%s\n"",""Error in input"");
            exit(1);
        }
    }
    printMax(n,a);
    return 0;
}

void printMax(size_t n,int A[])
{
    int max=A[0];
    for(size_t i = 1; i &lt; n; i++)
        if(A[i] &gt; max)
            max = A[i];

    printf(""%d"",max);
}
</code></pre>
",2
46022399,46022380,1,"<p>According to <a href=""http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1570.pdf"" rel=""nofollow noreferrer"">N1570</a> draft (<a href=""/questions/tagged/c11"" class=""post-tag"" title=""show questions tagged &#39;c11&#39;"" rel=""tag"">c11</a>):</p>

<p><strong>6.5.9 Equality operators</strong></p>

<blockquote>
  <p>The <code>==</code> (equal to) and <code>!=</code> (not equal to) operators are analogous to the relational operators except for their lower precedence. Each of the operators yields <code>1</code> if the specified relation is true and <code>0</code> if it is false. <strong>The result has type</strong> <code>int</code>.</p>
</blockquote>

<p>So in your case, condition is false, because <code>10</code> is not less that <code>10</code>, so <code>0</code> is stored to the <code>z</code>.</p>
",1
45717028,45716965,5,"<p><code>strcpy()</code> <strong>copies</strong> a string, as implied by the name. So each time you call it, you overwrite your existing string. You are looking for <code>strcat()</code>, which concatenates by searching the first <code>0</code> byte in the destination and copying there.</p>

<p>You can just replace <code>strcpy()</code> by <code>strcat()</code> in your code if you initialize <code>concat[0] = 0;</code> first.</p>
",0
45717308,45716965,2,"<p><strong>strcpy</strong> copies the source's characters into the pointer, as you always use the same address i.e. the start of that string, it keeps overwriting your old string.
It can work if you add an offset by the amount of characters already copied, this way you copy the string properly and get it concatenated</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;

int main(int argc, char **argv)
{
    int kar = 1;
    int size = 0;
    char *concat;

    size_t argl[argc];

    //find size to malloc concat
    while (kar &lt; argc)
    {
            unsigned int arglen = strlen(argv[kar]);
            size += arglen;
            argl[kar] = arglen; // Save the length
            kar++;
    }

    //malloc size + argc for space characters
    concat = malloc(size + argc + 1);
    kar = 1;

    unsigned int offset = 0;
    while (kar &lt; argc)
    {
            strcpy(concat+offset,argv[kar]);
            offset += argl[kar];  // Offset by the length
            strcpy(concat+offset,"" "");
            offset += 1;
            kar++;
    }
    printf(""%s"",concat);
}
</code></pre>
",6
45717360,45716965,0,"<p>Consider using <code>snprintf()</code>; it will also work and is easier to use in some situations.</p>

<p><code>snprintf(destination, buffer_size, source)</code> is basically a <code>strcpy</code>, and the return value tells you how many bytes were copied.</p>

<p><code>snprintf(destination + strlen(destination), buffersize - strlen(destination), new string to add on)</code></p>

<p>this does a concatenation but also allows you to insert variables using format <code>%d</code>, etc.</p>
",2
45717549,45716965,0,"<p>For starters you should include the header <code>&lt;stdlib.h&gt;</code> where the functions <code>malloc</code> and <code>free</code> are declared.</p>

<p>In general <code>argc</code> can be equal to 0. So it is better explicitly to reserve one byte to the terminating zero instead of using the expression <code>size + argc</code>.</p>

<p>The function <code>strcpy</code> overwrites the previous content of the target string. You should use the function only once when the first command line parameter is being copied. In all other cases you should use standard function <code>strcat</code>.</p>

<p>Also you should free the allocated memory before exiting the program.</p>

<p>The program can look the following way</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main( int argc, char * argv[] )
{
    size_t n = 0;

    for ( int i = 1; i &lt; argc; i++ ) n += strlen( argv[i] );

    if ( argc &gt; 1 ) n += argc - 2;

    ++n;

    char *s = malloc( n );

    s[0] = '\0';

    for ( int i = 1; i &lt; argc; i++ )
    {
        if ( i == 1 )
        {
            strcpy( s, argv[i] );
        }            
        else
        {            
            strcat( s, "" "" );
            strcat( s, argv[i] );
        }
    }

    puts( s );

    free( s );

    return 0;
}
</code></pre>

<p>If to specify command line arguments like</p>

<pre><code>first second third
</code></pre>

<p>then the output will be</p>

<pre><code>first second third
</code></pre>
",0
46081423,46081271,1,"<p>You won't exploit a quad core system if you have a single-threaded program.</p>

<p>It will run on one core only, so the 21/25% CPU usage is realistic.</p>

<p>A way to use it all would be, first of all not using recursion as it makes it annoying to do, and when you have a for/while loop split it into 4 while loops and put each of them in a new thread. Then you'll have to manage synchronization in order to print the message properly, but it's not even that hard. You could store all the results in an array and then print it when all the threads are done.</p>
",0
46084213,46081271,4,"<blockquote>
  <p>the number of calls being made to the recursive function is something of 2^n, or exponential complexity. Understood.</p>
</blockquote>

<p>I'm not sure you do entirely understand this, since you seem surprised about how slow it becomes around n=40, and n=47.</p>

<p>With a complexity of 2^n, and an <em>n</em> of 40, that would be 2<sup>40</sup>, or 1,099,511,627,776, or about 1 <em>trillion</em> operations. If your computer can run about one of these operations per nanosecond, i.e. 1 billion operations per second, it would take 1000 seconds to finish.</p>

<p>Consider if <em>n</em> was only 30. 2<sup>30</sup> is 1,073,741,824, which would take only about 1 second to do on that same computer.</p>

<p>As has been mentioned, you're only using one core. You could parallelize, but that won't help much. Use four cores instead of one, and my n=40 example will still take 250 seconds. Go up to n=42 and you're back to 1000 seconds, because parallelizing <em>at best</em> multiplies your performance, but an algorithm like this grows exponentially.</p>
",0
46087365,46081271,2,"<ol>
<li>the posted code contains some extreme over complexity.  </li>
<li>even a <code>long long unsigned int</code> cannot contain a Fibonacci value
number 100 (or even close to it) </li>
</ol>

<p>Suggest using a very simple program to start, one that calculates the Fibonacci sequence.  Then use that program to determine how to display the results.</p>

<p>The following program calculates the numbers, is very fast, but still has the problem of overflow of a <code>long long unsigned int</code></p>

<pre><code>#include &lt;stdio.h&gt;  // printf()


int main( void )
{
    long long unsigned currentNum = 1;
    long long unsigned priorNum = 1;

    printf( ""1\n1\n"" );

    for (size_t i = 2;  i &lt; 100; i++ )
    {
        long long unsigned newNum = currentNum+priorNum;
        printf( ""%llu\n"", newNum );
        priorNum = currentNum;
        currentNum = newNum;
    }
}
</code></pre>

<p>On my linux 86-64 computer, here are the last few lines of the output, showing the overflow problem.</p>

<pre><code>99194853094755497
160500643816367088
259695496911122585
420196140727489673
679891637638612258
1100087778366101931
1779979416004714189
2880067194370816120
4660046610375530309
7540113804746346429
12200160415121876738
1293530146158671551
13493690561280548289
14787220707439219840
9834167195010216513
6174643828739884737
16008811023750101250
3736710778780434371
</code></pre>

<p>So, why is recursion taking so long?</p>

<p>because of the huge number of recursions and the handling of the overflows</p>

<p>The above suggested code eliminates the recursions, but not the overflows and it takes less than a second (on my computer) to run.</p>
",1
46111319,46081271,0,"<p>Building on the answer made by @<a href=""https://stackoverflow.com/users/3629249/user3629249"">user3629249</a>, you can get rid of the <em>overflows</em> he mentioned by using the <em>infinite precision arithmetic library</em> provided by <a href=""https://gmplib.org/"" rel=""nofollow noreferrer"">GMP</a>.</p>

<p><strong>e.g.</strong></p>

<pre class=""lang-c prettyprint-override""><code>#include &lt;stdio.h&gt;  // printf
#include &lt;stdlib.h&gt; // free
#include &lt;gmp.h&gt;    // mpz_t

int main( void )
{
    mpz_t prevNum, currNum, tempNum, counter;

    mpz_init_set_si(prevNum, 0);
    mpz_init_set_si(currNum, 1);
    mpz_init_set_si(tempNum, 1);
    mpz_init_set_si(counter, 1);

    printf( ""0: 0\n"" );

    while (1) {
        char *tempNumRepr = mpz_get_str(NULL, 10, tempNum);
        char *counterRepr = mpz_get_str(NULL, 10, counter);

        printf(""%s: %s\n"", counterRepr, tempNumRepr);

        free(tempNumRepr);
        free(counterRepr);

        mpz_add(tempNum, currNum, prevNum); // tempNum = currNum + prevNum;
        mpz_add_ui(counter, counter, 1);    // counter = counter + 1;
        mpz_set(prevNum, currNum);          // prevNum = currNum;
        mpz_set(currNum, tempNum);          // currNum = tempNum;
    }

    mpz_clear(prevNum);
    mpz_clear(currNum);
    mpz_clear(tempNum);
    mpz_clear(counter);

    return EXIT_SUCCESS;
};
</code></pre>

<p>To compile it, ensure that you have <em>libgmp</em> installed, type:</p>

<pre><code>~$ gcc fib.c -lgmp
</code></pre>

<p>You get massive <em>fibonacci</em> values pretty fast:</p>

<pre><code>~$ ./a.out
0: 0
1: 1
2: 1
3: 2
4: 3
5: 5
6: 8
7: 13
8: 21
9: 34
...
90: 2880067194370816120
91: 4660046610375530309
92: 7540113804746346429
93: 12200160415121876738
94: 19740274219868223167
95: 31940434634990099905
96: 51680708854858323072
97: 83621143489848422977
98: 135301852344706746049
99: 218922995834555169026
100: 354224848179261915075
...
142: 212207101440105399533740733471
143: 343358302784187294870275058337
144: 555565404224292694404015791808
145: 898923707008479989274290850145
146: 1454489111232772683678306641953
147: 2353412818241252672952597492098
148: 3807901929474025356630904134051
149: 6161314747715278029583501626149
150: 9969216677189303386214405760200
...
10456: 6687771891046976665010914682715972428661740561209776353485935351631179302708216108795962659308263419533746676628535531789045787219342206829688433844719175383255599341828410480942962469553971997586487609675800755252584139702413749597015823849849046700521430415467867019518212926720410106893075072562394664597041033593563521410003073230903292197734713471051090595503533547412747118747787351929732433449493727418908972479566909080954709569018619548197645271462668017096925677064951824250666293199593131718849011440475925874263429880250725807157443918222920142864819346465587051597207982477956741428300547495546275347374411309127960079792636429623948756731669388275421014167909883947268371246535572766045766175917299574719971717954980856956555916099403979976768699108922030154574061373884317374443228652666763423361895311742060974910298682465051864682016439317005971937944787596597197162234588349001773183227535867183191706435572614767923270023480287832648770215573899455920695896713514952891911913499762717737021116746179317675622780792638129991728650763618970292905899648572351513919065201266611540504973510404007895858009291738402611754822294670524761118059571137973416151185102238975390542996959456114838498320921216851752236455715812273599551395186676228882752252829522673168259864505917922994675966393982705428427387550834530918600733123354437191268657802903434440996622861582962869292133202292740984119730918997492224957849300327645752441866958526558379656521799598935096546592129670888574358354955519855060127168291877171959996776081517513455753528959306416265886428706197994064431298142841481516239689015446304286858347321708226391039390175388745315544138793021359869227432464706950061238138314080606377506673283324908921190615421862717588664540813607678946107283312579595718137450873566434040358736923152893920579043838335105796035360841757227288861017982575677839192583578548045589322945
...
</code></pre>

<p>Use <em>CTRL+C</em> to stop the program.</p>
",1
46131113,46131068,3,"<p>The problem is that the function is not returning in the <code>default</code> case. That is undefined behavior. </p>

<p>Note that <code>return price;</code> makes the following <code>break;</code> unnecessary, and it also makes the code harder to read, instead and since you are setting <code>price</code>'s value in every case (<em>except the <code>default</code></em>) you can just put <code>return price;</code> at the end. And finally, add a initialization statement in the <code>default</code> case.</p>

<p>Something like this</p>

<pre><code>int juice(char size, int qty)
{
    int price = 0;
    switch (size) {
        case 's': // 's' for small size of cup
            printf(""size small\n"");
            price = 20 * qty; 
            break;
        case 'm': // 'm' for medium size of cup
            printf(""size medium\n"");
            price = 30 * qty;
            break;
        case 'l': // 'l' for large size of cup
            printf(""size large\n"");
            price = 40 * qty;
            break;
        default: // if costumer choose wrong size
            printf(""choose proper size\n"");
            price = -1; // Invalid value?
            break;
    }
    return price;
}
</code></pre>

<p>Also, the new line character <code>'\n'</code> is meant to be placed at the end of a line, IO streams are line buffered so that would flush the stream and create a new line and it makes more sense to place the at the end.</p>
",4
46031840,46031645,3,"<p>From declaration of node, I can see that for data you are not assigning memory, you are just creating a pointer to character type, you can change the definition of node as follows(and code change is needed for the same)-</p>

<pre><code>typedef struct node {
char data;
int weight;
bool  end_of_key;
struct node * left;
struct node * equal;
struct node * right;} node_t;
</code></pre>
",0
46110400,46110372,5,"<p>Yes, It is possible.</p>

<pre><code>#include&lt;stdio.h&gt;
int main(){
   if(printf(""hello world"")){}
}
</code></pre>
",0
46110416,46110372,5,"<p>There you go!</p>

<h1>Solution 1</h1>

<pre><code>#include&lt;stdio.h&gt;
        int main(){
            if(printf(""Hello world"")){
            }
        }
</code></pre>

<h1>Solution 2</h1>

<pre><code>#include&lt;stdio.h&gt;
int main(){
    while(!printf(""Hello world"")){
    }
}
</code></pre>

<h1>Solution 3</h1>

<pre><code>#include&lt;stdio.h&gt;
int main(){
    switch(printf(""Hello world"")){
    }
}
</code></pre>

<h1>Solution 4</h1>

<pre><code>#include&lt;stdio.h&gt;
#define PRINT printf(""Hello world"")
int main()
{
    if(PRINT)
    {
    }
}
</code></pre>
",0
46118214,46117781,1,"<p>As pointed by Chris, fscanf moves file pointer as you read the file in the first pass. So you're not reading anything in second pass. I'm assuming all the code is in the main function and the <code>plik</code> is just another identifier copied from <code>file</code> . Resetting the file pointer to the beginning of the file using <code>fseek(file, 0, SEEK_SET)</code> seemed to solve the problem for me:</p>

<pre><code>#include &lt;stdio.h&gt;

int main() {
  char name[30];
  scanf (""%s"", name);

  FILE *file = fopen (name, ""r"");
  if (!file) 
    {
      printf (""Cannot read from file %s!\n"", name);
      return 1;
    }

  double results;
  int size = 0;
  FILE *pFilePtr = file;
  printf(""file = %p\n"", file);
  while ( fscanf (pFilePtr, ""%lf"", &amp;results) != EOF) 
      size++;
  printf(""size : %d\n"", size);

  double numbers[size]; 
  fseek(file, 0, SEEK_SET);
  FILE *plik = file;
  for (int i=0; i&lt;size; i++)
      fscanf (plik, ""%lf"", &amp;numbers[i]);
  for(int i = 0; i &lt; size; i++)
      printf(""%lf\n"" , numbers[i]);
  return 0;
}
</code></pre>

<p>I ran it assuming this file input:</p>

<pre><code>~/Documents/src : $ cat testFile.txt 
1.2334 2.223 3.34 4.21 5.34 6.23
~/Documents/src : $ g++ testFillArr.c
~/Documents/src : $ ./a.out 
testFile.txt    
file = 0x559494bdd420
size : 6
1.233400
2.223000
3.340000
4.210000
5.340000
6.230000
</code></pre>
",1
47484284,47484040,0,"<p>There are a few problems with this code, but you're almost there!</p>

<p>First <code>code</code> reading needs to eat the previous <code>\n</code> (<a href=""https://stackoverflow.com/questions/13542055/how-to-do-scanf-for-single-char-in-c"">see this</a>), otherwise the code is neither <code>Z</code> not <code>S</code> (it's a newline), and that's why the fees are never added.
(Search also for ""fgets vs scanf"" to see how to use the safer <code>fgets</code>).</p>

<pre><code>scanf("" %c"",&amp;code);
</code></pre>

<p>then these lines</p>

<pre><code>bookgst=bookgst+newfee;
nogst=nogst+newfee_nogst;
</code></pre>

<p>add the newfee / newfee_nogst ; these variables are set to <code>0</code> before the loop, but at the next occurence, they're still set to the value of the previous occurrence, thus either set them to <code>0</code> at the beginning of the loop, or, add the value directly in the <code>if</code> (see below). And since we're here, print an error if the code is wrong (and maybe subtract one to <code>cnt</code> to do one more loop with a correct code, in this case).</p>

<p>Also, the  GST calculation is probably wrong, 6% of x is <code>0.06 * x</code>, and if you want GST added to the value that's <code>x * 1.06</code></p>

<pre><code>if(code=='S')
{
    bookgst = bookgst + bookfee*1.06; // or bookgst += bookfee*1.06
}
else if(code=='Z')
{
    nogst = nogst + bookfee; // or nogst += bookfee
}
else {
    printf(""Code not understood\n"");
}
</code></pre>
",0
47503019,47502993,1,"<p>You opened the file for reading, not writing. The file is now <code>input</code> but you don't refer to <code>input</code> anywhere else.</p>

<p>Open the file with <code>input = fopen(na , ""r+"");</code> to both read and write but you don't show any code that writes to the file <code>input</code>.</p>
",5
43771506,2192547,9,"<p>The <code>auto</code> keyword is similar to the inclusion of semicolons in Python, it was required by a previous language (<a href=""https://en.wikipedia.org/wiki/B_%28programming_language%29"" rel=""nofollow noreferrer""><code>B</code></a>) but developers realized it was redundant because most things were <code>auto</code>.</p>
<p>I suspect it was left in to help with the transition from B to C. In short, one use is for B language compatibility.</p>
<p>For example in B and 80s C:</p>
<pre><code>/* The following function will print a non-negative number, n, to
   the base b, where 2&lt;=b&lt;=10.  This routine uses the fact that
   in the ASCII character set, the digits 0 to 9 have sequential
   code values.  */

printn(n, b) {
        extern putchar;
        auto a;

        if (a = n / b)        /* assignment, not test for equality */
                printn(a, b); /* recursive */
        putchar(n % b + '0');
}
</code></pre>
",1
47998470,47998026,1,"<p>Not clear but it seems the file contains a mix of line that have either four or two items.<br>
Consider reading each line. Parse the line into up to four strings using sscanf. As needed use <code>sscanf</code> to capture the integers from the line. If there are two items, process them if <code>trovato</code> flag indicates a match has been found. If there are four items, see if there is a match and set <code>trovato</code>.</p>

<pre><code>int main ()
{
    FILE *cfPtr;
    int matricola_in, matricola, nEsami, codEsame, voto;
    char nome[20], cognome[20];
    char temp[4][20];
    char line[200];
    int result;
    int i, j, trovato = 0;
    float somma = 0.0;

    printf(""Inserisci una matricola:\n"");
    scanf(""%d"", &amp;matricola_in);

    if( (cfPtr = fopen(""studenti.txt"", ""r"")) == NULL ) {
        printf(""Errore"");
        return 0;
    }

    while( fgets ( line, sizeof line, cfPtr)){//read a line until end of file
        result = sscanf ( line, ""%19s%19s%19s%19s"", temp[0], temp[1], temp[2], temp[3]);//scan up to four strings
        if ( result == 2) {//the line has two items
            if ( trovato) {// match was found
                sscanf ( temp[0], ""%d"", &amp;codEsame);
                sscanf ( temp[1], ""%d"", &amp;voto);
                somma += voto;
            }
        }
        if ( result == 4) {//the line has four items
            if ( trovato) {
                break;//there was a match so break
            }
            sscanf ( temp[0], ""%d"", &amp;matricola);
            sscanf ( temp[3], ""%d"", &amp;nEsami);
            if( matricola_in == matricola ){//see if there is a match
                trovato = 1;//set the flag
            }
        }
    }
    printf(""Media: %.1f\n"", somma/nEsami);//print results

    fclose(cfPtr);

    return 0;
}
</code></pre>
",0
47526668,47526597,0,"<p>When using a function call in C, the value is passed by copy.  This means that</p>

<pre><code>int value = 0;
function(value);
printf(""%d\n"", value);
</code></pre>

<p>will always print the value <code>0</code>, even if the function reads like</p>

<pre><code>void function(int value) {
   value++;
}
</code></pre>

<p>because within the function <code>function</code>, a copy of the <code>int value</code> is being incremented.</p>

<p>To fix this, pass a copy of the memory location of <code>value</code>, and then increment the number stored at that location.</p>

<pre><code>int value = 0;
function(&amp;value);
</code></pre>

<p>with </p>

<pre><code>void function(int* value) {
  (*value)++;
}
</code></pre>
",0
47526675,47526597,0,"<p><code>sunk</code> is passed by value. It needs to be passed by reference. Send the pointer to <code>sunk</code>, and receive <code>sunk</code> as a pointer in the shoot function.</p>

<p>Alternatively, make sunk a <code>global</code> variable and increment it, although I'd not suggest this for bigger programs!</p>

<p>Read more about passing by value and passing by reference to prevent such things from happening in the future! :D</p>
",0
47487572,47487449,0,"<p>if you have to scan doubles you use ""lf"" and to print them as well. It was your only mistake. ""f"" it is just for floats.</p>

<pre><code>int main(void)
{
    double *p1,*p2, val1,val2;
    p1 = &amp;val1;
    p2 = &amp;val2,
    printf(""Enter  two number: "");
    scanf(""%lf %lf"", p1,p2);
    if(*p1+*p2 &gt;= 0)
        printf(""%lf\n"", *p1+*p2);
    else
        printf(""%lf\n"", -(*p1+*p2));
    return 0;
}
</code></pre>
",0
47487653,47487449,0,"<p><a href=""http://www.cplusplus.com/reference/cstdio/scanf/"" rel=""nofollow noreferrer"">http://www.cplusplus.com/reference/cstdio/scanf/</a></p>

<p>Please consult this website or a similar one for errors or warnings.</p>

<p>%f is used for float values, and c compilers often issue warnings or stop compilation when type conversions occur without specifying them.</p>

<p>%lf is used for doubles. </p>
",0
47545123,47545024,-2,"<p>Your struct is just a single integer so an integer can be cast into this structure without any problem. If you enable warnings, you'll get one but the code itself will work.These are the ones I get</p>

<pre><code>foo.c: In function ¡®fun¡¯:
foo.c:10:5: warning: implicit declaration of function ¡®printf¡¯ [-Wimplicit-function-declaration]
     printf(""%d %d"",c,c.a);
     ^
foo.c:10:5: warning: incompatible implicit declaration of built-in function ¡®printf¡¯
foo.c:10:5: warning: format ¡®%d¡¯ expects argument of type ¡®int¡¯, but argument 2 has type ¡®struct X¡¯ [-Wformat=]
foo.c: In function ¡®main¡¯:
foo.c:20:5: warning: incompatible implicit declaration of built-in function ¡®printf¡¯
     printf(""Hello World"");
     ^
foo.c:22:9: warning: passing argument 1 of ¡®fun¡¯ from incompatible pointer type
     fun(&amp;p);
         ^
foo.c:6:6: note: expected ¡®struct X *¡¯ but argument is of type ¡®int *¡¯
 void fun(struct X *b)
      ^
foo.c:16:14: warning: unused variable ¡®d¡¯ [-Wunused-variable]
     struct X d;
              ^
</code></pre>

<p>If you're interested in the gory details, take a look at <a href=""http://www.catb.org/esr/structure-packing/"" rel=""nofollow noreferrer"">this</a>.</p>
",4
47545142,47545024,0,"<p>I think this can not be complied. c is s strong type language. You need make sure this is the file you are compiling.</p>
",0
47545180,47545024,4,"<p>Your code is indeed invalid. C language does not allow you to pass an <code>int *</code> pointer where a <code>struct X *</code> pointer is expected. Such conversion would require an explicit cast in C.</p>

<p>This means that your <code>fun(&amp;p)</code> call contains a <em>constraint violation</em>, which is what is usually referred to as ""compile error"". However, for reasons of backward compatibility with archaic pre-standard versions of the language many C compilers (in their default configuration) report such violations as mere ""warnings"" and then continue to compile the code. Continuing to compile the code is not illegal: as long as the compiler informed you about the problem, it is allowed to continue to compile. However, your program is not a valid C program and its behavior is not defined by C language.</p>

<p>I'm sure that in your case the compiler issued such a diagnostic message for the invalid <code>fun(&amp;p)</code> call.</p>

<p>It is your responsibility to look through the diagnostic messages issued by your compiler and figure out which ones indicate serious errors and which ones are ""mere warnings"". In some cases you can ask your compiler to help you to detect violations of language rules by issuing a ""hard error"" message and aborting compilation. In case of GCC or Clang this can be achieved by using <code>-pedantic-errors</code> command-line option.</p>
",0
47550652,47546847,0,"<p>To make as few changes to your code, you can do something like this</p>

<pre><code>FILE *fre;
int re_rng;

fre = fopen(""vals"", ""r"");
if (fre==NULL){
    printf(""Error"");
}

while (fscanf(fre, ""%d"", &amp;re_rng) == 1)
{
    printf(""%d\n"", re_rng);
}
</code></pre>

<p>Things to note: You put wrong specifier at in the fopen, <code>a</code> means append, it is opening the file for writing at the end of the file. You want to use <code>r</code> for reading. </p>

<p>You need to check if the file is ok right after you opened it. If you first try to read and then check, if it failed the program will end with segfault probably.</p>

<p>You can also move the fscanf into the condition for while, where it returns number of conversion made, meaning for you that it returns 1 when it reads a number, 0 when it fails to read a number and -1 when it's at the end of file.</p>

<p>I would suggest you try to read about all of these functions (+feof) at some documentation sites like <a href=""http://cppreference.com"" rel=""nofollow noreferrer"">cppreference.com</a>.</p>
",0
47550748,47546847,0,"<p>There are a number of ways to approach this problem. If you have a file with nothing but numbers in it, and you are not taking any other mixed input with <code>scanf</code>, then it can be use to read each integer value in the file until <code>EOF</code> is encountered. Nothing special is needed.</p>

<p>The following code reads from the filename provided as the first argument (or from <code>stdin</code> by default if no arguments is provided)</p>

<pre><code>#include &lt;stdio.h&gt;

int main (int argc, char **argv) {

    int i;  /* read from 1st arg (or stdin by default) */
    FILE *fp = argc &gt; 1 ? fopen (argv[1], ""r"") : stdin;

    if (!fp) {  /* validate file open for reading */
        fprintf (stderr, ""error: file open failed '%s'.\n"", argv[1]);
        return 1;
    }
    while (fscanf (fp, ""%d"", &amp;i) == 1)  /* validate 1 conversion */
        printf ("" %2d"", i);         /* output your integer */
    putchar ('\n');                 /* tidy up with newline */

    if (fp != stdin) fclose (fp);   /* close file if not stdin */

    return 0;
}
</code></pre>

<p><strong>Example Input File</strong></p>

<pre><code>$cat dat/verticallist.txt
12
2
7
5
4
10
15
4
18
</code></pre>

<p><strong>Example Use/Output</strong></p>

<pre><code>$ ./bin/rdintsfromfile &lt;dat/verticallist.txt
 12  2  7  5  4 10 15  4 18
</code></pre>

<p>Look things over and let me know if you have any further questions.</p>
",0
47556298,47556130,2,"<p>Here</p>

<pre><code>if (toc&amp;&amp;((GET_GAME_TIMER()-tic) &gt; 8000)) {
</code></pre>

<p>you check immediately after setting <code>tic</code> to a clock value if 8 seconds have passed. Unless the computer is <em>very</em> slow, that will not happen.</p>

<p>Doing a <em>while</em> on the opposite condition will work</p>

<pre><code>while (toc &amp;&amp; (GET_GAME_TIMER()-tic) &lt;= 8000)) {
    // nothing, just wait
    // or you could use that time to do some quick tasks
}
toc = 0;
</code></pre>

<p>waiting in a loop until 8 seconds passed.</p>
",0
48007929,48007768,0,"<p>The simplest way to skip characters in string until some condition is met is:</p>

<pre><code>char someString[MAXCHAR];

for (char* ptr = someString; *ptr != '\0'; ptr++) {
    if (conditionIsMet(ptr)) {
        doSomething();
        break;
    }
}
</code></pre>

<p>In your case, <code>conditionIsMet(ptr)</code> should be comparing <code>*ptr</code> to <code>':'</code> and in that case, the password hash is under <code>(ptr + 1)</code> (string starting from the next character). I think you can write the rest of the code yourself.</p>
",0
48016304,48016266,6,"<p>It doesn't make sense to put a pointer in shared memory. The receiving process now knows the address of the string in the other process' memory space, but that doesn't do it any good. Instead, put the string itself in shared memory.</p>

<p>For example, change:</p>

<pre><code>char *pname;
</code></pre>

<p>to:</p>

<pre><code>char pname[512];
</code></pre>

<p>And adjust the rest of your program appropriately.</p>
",1
47458020,47457640,3,"<p>strlen returns the length of the string. So you can iterate through whole string, increment a counter and return the counter as the length</p>

<p>code:</p>

<pre><code>size_t my_strlen(char *str) {
    size_t i;
    for (i = 0; str[i] != '\0'; i++) 
        ;
    return i;
}
</code></pre>

<h3>Edit:</h3>

<p>Your revstr code seems really complex. Here is a simple way of doing that.</p>

<pre><code>char * revstr( char * str)
{
    int i,end,len;
    char temp;

    len= my_strlen(str);
    end = len-1;
    for(i=0;i&lt;len/2;i++)
    {
       temp=str[i];
       str[i]=str[end];
       str[end--]=temp;
    }

    return str;
}
</code></pre>

<p>Note: It is good practice to write <code>str[i]</code> instead of <code>*(str + i)</code>. 
and the code works perfect for your question :)</p>
",2
47458456,47457640,1,"<p>I don't think it's ever <em>""forbidden""</em> to use standard library functions, using <code>strlen()</code> here is fine. Their is no need to write your own. As for your reverse function, I suggest you break down the problem.</p>

<p>A simple approach is to have two counters, one which starts at the beginning of the string, and one that starts at the end of the string. You'll need to swap these characters, which can be done like this:</p>

<pre><code>void swap(char *a, char *b) {
    char temp = *a;
    *a = *b;
    *b = temp;
}
</code></pre>

<p>Once these start and end characters are swapped, increment the start counter and decrement the end counter to move inward the string, and swap again. This can be written in a simple loop:</p>

<pre><code>for (start = 0, end = len-1; start &lt;= end; start++, end--) {
    swap(&amp;string[start], &amp;string[end]);
}
</code></pre>

<p>I'll let you fill in the rest of the code, but this gives the general idea.</p>
",1
47461824,47457640,1,"<p>I do it like this:</p>

<pre><code>void revstr(char *str)
{
    char *s = str;
    char *e;

    for (e=s; *e; ++e); //find the end

    if (e==s)
        return; //empty string

    for (--e; e&gt;s; --e,++s)
    {
        char t = *s;
        *s = *e;
        *e = t;
    }
}
</code></pre>
",0
47463839,47463621,0,"<p>You are limited by the size of your array. A simple solution would be to increase the size of your array. But you are always susceptible to stack smashing if someone enters a long word.</p>

<p>A word is delimited by spaces.</p>

<p>You can simply store a counter variable initialized to zero, and a variable that records the current char that you are looking at. Every time you read in a character using <code>fgetc(inFile, &amp;temp)</code> that is a space, you increment the counter.</p>
",0
47463812,47463621,0,"<p>As you've correctly identified by rendering your source code invalid (future tip: <code>/* put your arrows in comments */</code>), the problem is that <code>temp_word</code> only has enough room for 20 characters (one of which must be a terminal null character).</p>

<p>In addition, you should check the return value of <code>fopen</code>. I'll leave that as an exercise for you. I've answered this question in other questions (such as <a href=""https://stackoverflow.com/questions/30419563/translation-limit-in-c"">this one</a>), but I don't think just shoving code into your face will help you.</p>

<p>In this case, I think it may pay to better analyse the problem you have, to see if you actually need to store <em>words</em> to count them. As we define a <em>word</em> (the kind read by <code>scanf(""%s"", ...)</code> as a sequence of non-whitespace characters followed by a sequence of (zero or more) whitespace characters, we can see that such a <em>counting</em> program as yours needs to follow the following procedure:</p>

<ol>
<li>Read as much whitespace as possible</li>
<li>Read as much non-whitespace as possible</li>
<li>Increment the ""word"" counter if all was successful</li>
</ol>

<p>You don't need to store the non-whitespace any more than you do the whitespace, because once you've read it you'll never revisit it. Thus you could write this as two loops embedded into one: one loop which reads as much whitespace as possible, another which reads non-whitespace, followed by your incrementation and then the outer loop repeats the whole lot... until <code>EOF</code> is reached...</p>

<p>This will be best achieved using the <code>%*s</code> directive, which tells <code>scanf</code>-related functions not to try to store the <em>word</em>. For example:</p>

<pre><code>size_t word_count = 0;
do {
     fscanf(inFile, ""%*s"");
} while (!feof(inFile) &amp;&amp; ++word_count);
</code></pre>
",0
47467019,47463621,0,"<p>In your current code you simply want to count the words. Therefore you are not interested in the words themselves. You can suppress the assignment with the optional <code>*</code> character:</p>

<pre><code>    fscanf(inFile, ""%*s"");
</code></pre>
",0
47468252,47466502,0,"<p>I consider this a home work question, so I answer according to<br>
<a href=""https://meta.stackoverflow.com/questions/334822/how-do-i-ask-and-answer-homework-questions"">How do I ask and answer homework questions?</a></p>

<p>Find a tutorial on C, work through it.<br>
Then take a HelloWorld, modify it in small steps to approach your goal in steps from working program to working program. This way you should at least get to being able to read text from a file and print it.<br>
Then learn to store parts of what you print into basic variables.<br>
Then learn about structures.<br>
And so on.  </p>

<p>This way you will get quite close to the solution.<br>
If it is not completely what you need show the code you have here at that point and ask a specific question about the first problem explaining what you suspect the problem to be. Show code which has exactly that one problem and makes it visible and has not other warnings (using at least e.g. <code>gcc -Wall mycode</code>).</p>

<p>Fix with the help of commments/answers you receive, repeat.</p>
",1
47487440,47487371,0,"<p>In C this is not directly possible, however.</p>

<p>A tricky (thus <strong>not</strong> recommended) approach does exist:</p>

<pre><code>#define X (vector[0][0])
</code></pre>

<p>Now you're able to use <code>X</code> anywhere to resemble <code>vector[0][0]</code>.</p>

<p>If you migrate your project to C++ then reference will be available, providing a natural way to do so.</p>
",1
47491705,47491632,2,"<p>The first issue is just a warning.  The fatal error is you are missing the <code>gb_</code> symbols, which are defined here:</p>

<p><a href=""http://ftp.cs.stanford.edu/pub/sgb/gb_flip.w"" rel=""nofollow noreferrer"">http://ftp.cs.stanford.edu/pub/sgb/gb_flip.w</a></p>

<p>So first you need to compile gb_flip.w into a .c file, then compile both .c files together like this:</p>

<pre><code>gcc sliding.c gb_flip.c -o sliding
</code></pre>
",1
47499007,47498959,1,"<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;


int main(int argc, char const *argv[]) {
  char* srcValue = ""Hello World"";
  char* output = calloc(strlen(srcValue)*2+1, sizeof(char));
  for (int i=0; i&lt;strlen(srcValue); i++){
    output[2*i] = srcValue[i];
    output[2*i+1] = srcValue[i];
  }
  output[2*strlen(srcValue)] = '\0';
  printf(""%s\n"", output);
  return 0;
}
</code></pre>
",18
47499029,47498959,0,"<p>destValue and srcValue are essentially pointers to char arrays.  But you did not allocate any memory to them.  The scanf function will attempt to copy the entered text into an initialized memory location.</p>
",0
47499084,47498959,2,"<p>Simply You can do like this</p>

<pre><code>   #include&lt;stdio.h&gt;
#include&lt;malloc.h&gt;
#define len 10
int main()
{
        char *destValue;
        char *srcValue;

        srcValue = malloc(len * sizeof(char));
        destValue = malloc((2 * len * sizeof(char)) + 1);
        //User input
        printf(""Please enter valid text: "" );
        scanf(""%s"", srcValue);
        int j = 0;
        for(int i = 0  ;srcValue[i]!= '\0';i++) {
                destValue[j++]= srcValue[i];
                destValue[j++]= srcValue[i];
        }

        destValue[j]='\0';
        puts(destValue);

        free(destValue);
        free(srcValue);

        return 0;
}
</code></pre>

<p>I hope you will get this.</p>
",6
47539656,47539573,1,"<p>When you do this:</p>

<pre><code>pNew-&gt;objectName = input;
</code></pre>

<p>You're assigning the address of the <code>input</code> array to <code>objectName</code>.  You are <strong>not</strong> making a copy.</p>

<p>Then when you do this:</p>

<pre><code>currentNode-&gt;question = input;
</code></pre>

<p>You are again assigning the address of <code>input</code> to this field.  So now <code>pNew-&gt;objectName</code> and <code>currentNode-&gt;question</code> both point to the <em>same place</em>, i.e. <code>input</code>.  So anytime <code>input</code> changes it will be reflected when you use either of the variables above.</p>

<p>To make a copy of the string, use <code>strdup</code>:</p>

<pre><code>pNew-&gt;objectName = strdup(input);
</code></pre>

<p>This dynamically allocates memory for a copy of the string, copies the string to the newly allocated memory, and returns the address of that memory.</p>

<p>Just be sure to call <code>free</code> on each of these objects when you clean up the containing struct.</p>
",0
47539701,47539573,1,"<p>You are scanning into the same variable all the time, i.e. into <code>input</code></p>

<p>You need to allocate new memory for each variable. Like:</p>

<pre><code>fgets(input,INPUT_SIZE,stdin);
input[strcspn(input, ""\n"")] = '\0';
char* tmp = malloc(strlen(input) + 1);  // Allocate memory - Plus 1 for the string termination
if (tmp == NULL)
{
    // ups... out of mem
    exit(1);
}
strcpy(tmp, input);
pNew-&gt;objectName = tmp;
</code></pre>

<p>An alternative is to use <code>strdup</code> but that isn't part of the standard so it's not supported by all systems.</p>
",0
47545268,47545131,1,"<p>Integer constants have type <code>int</code> by default.  The <code>""%ld""</code> format specifier expects a <code>long int</code>.  Using the wrong format specifier invokes undefined behavior.</p>

<p>You need to add the <code>L</code> suffix for an integer literal to have type <code>long</code>:</p>

<pre><code>printf(""%ld \n"",3809L);
</code></pre>
",1
47545157,47545131,2,"<p>This is <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behavior</a>. The compiler warns you and then the <code>printf</code> tries to process <code>sizeof(long int)</code> bytes where you have provided it with an integer literal which is of size <code>sizeof(int)</code> bytes. </p>

<p>It expects <code>sizeof(long int)</code> bytes and now if <code>sizeof(int)==sizeof(long)</code> It's alright else it's Undefined Behavior.</p>

<p><strong>Don't think that format specifier are similar to variables. <code>long</code> variable can hold values of an <code>int</code>. This doesn't go with the format specifiers.</strong></p>

<p>A casting would solve the problem</p>

<pre><code>printf(""%ld \n"",(long)3809);
</code></pre>

<p>From standard <code>¡ì7.21.6.1</code> (Formatted input/output functions)</p>

<blockquote>
  <p>[7] If a conversion specification is invalid, the behavior is
  undefined. <strong>If any argument is not the correct type for the
  corresponding conversion specification, the behavior is undefined.</strong></p>
</blockquote>
",2
47660557,47660382,0,"<p>Though your array is sorted here, initializing high to a constant value of SIZE (100) is the problem. If you trace the values of low and high in iterations, you will know that. Instead you can use this:</p>

<pre><code>int arr[] = {10, 47, 67, 78, 95, 99};
int n = sizeof(arr)/ sizeof(arr[0]);
</code></pre>

<p>and pass n to the function and initialize high = n-1.</p>
",0
47973032,47973017,0,"<p>b<code>enter code here</code>[6] = ""Hello"";</p>

<p>Here you are assigning a char const * to a single char (and in addition that char is out of range).</p>

<p>If you want be to hold ""H"" do:</p>

<pre><code>strcpy(b, ""H"");
</code></pre>
",1
47973069,47973017,2,"<p>In C, Strings are treated as <code>char</code> arrays, and the name of an array is treated as a pointer to the beginning of the array.</p>

<pre><code>char b[6];
</code></pre>

<p>Based on this declaration, <code>b</code> is a pointer to the beginning of an array of 6 <code>char</code>s.</p>

<pre><code>b[6] = ""Hello"";
</code></pre>

<p>This line attempts to set the 6th element of <code>b</code> to ""Hello"", but there's two problems with doing that:</p>

<ol>
<li><p><code>b[6]</code> does not actually exist. <code>b</code> is 6 elements long, beginning with index 0, so the highest index you can use is 5.</p></li>
<li><p><code>b</code> is an array, so <code>b[6]</code> refers to a specific <code>char</code> whereas you attempt to set it to a String, i.e. a pointer to <code>char</code>, hence your error message.</p></li>
</ol>

<p>If you're trying to make <code>b</code> hold the value of ""Hello"", there are a number of ways to do that. Theoretically, your method of <code>b = ""Hello"";</code> would work, but would probably be considered bad practice by most. The most basic is to set the values of the <code>char</code>s in the array to the letters in ""Hello"" one-by-one, followed by a <code>NULL</code> byte. Using the <code>&lt;string.h&gt;</code> standard library, you could (and probably should) do it using <code>strcpy</code>.</p>

<pre><code>strcpy(b, ""Hello"");
</code></pre>
",4
48008047,47973017,0,"<p>regarding: `</p>

<pre><code>b[6] = ""Hello"";`  
</code></pre>

<p>when an array is referenced; the result is the address of the first byte of the array.  </p>

<p>So the statement is trying to assign the address of ""Hello"" to the char <code>b[]</code>.   </p>

<p>Are you trying to fill the array <code>b[]</code>?  if so, then the proper method is: </p>

<pre><code>strcpy( b, ""Hello"" );
</code></pre>
",0
47970101,47970080,3,"<p>Because the standard doesn't impose any constraint in it.</p>

<p>The section that says this is from <a href=""http://port70.net/~nsz/c/c11/n1570.html#6.5p3"" rel=""nofollow noreferrer"">6.5</a></p>

<blockquote>
  <p>The grouping of operators and operands is indicated by the syntax.85)
  Except as specified later, <strong>side effects and value computations of
  subexpressions are unsequenced.</strong></p>
</blockquote>

<p>From standard itself <a href=""http://port70.net/~nsz/c/c11/n1570.html#6.5.2.2p12"" rel=""nofollow noreferrer"">6.5.2.2</a> (Showing an example that standard doesn't impose any constraint)</p>

<blockquote>
  <p>In the function call</p>
</blockquote>

<pre><code>  (*pf[f1()]) (f2(), f3() + f4())
</code></pre>

<blockquote>
  <p><strong>the functions <code>f1</code>, <code>f2</code>, <code>f3</code>, and <code>f4</code> may be called in any order</strong>. All side
  effects have to be completed before the function pointed to by
  <code>pf[f1()]</code> is called.</p>
</blockquote>

<p>The answer to your question would be <em>unspecified</em>. You can't say something for sure. If <code>f1()</code> is called first result would be something and if it is other way round then the result would be different.</p>

<p>To support what I said check this <a href=""https://en.wikipedia.org/wiki/Sequence_point"" rel=""nofollow noreferrer""><strong>link</strong></a></p>

<blockquote>
  <p>... In the expression <code>f(i++) + g(j++) + h(k++)</code>, <code>f</code> is called with a
  parameter of the original value of <code>i</code>, but <code>i</code> is incremented before
  entering the body of <code>f</code>. Similarly, <code>j</code> and <code>k</code> are updated before
  entering <code>g</code> and <code>h</code> respectively. <strong>However, it is not specified in
  which order f(), g(), h() are executed</strong>, nor in which order i, j, k
  are incremented. If the body of f accesses the variables j and k, it
  might find both, neither, or just one of them to have been
  incremented. (The function call f(a,b,c) is not a use of the comma
  operator; the order of evaluation for a, b, and c is unspecified.)</p>
</blockquote>
",5
47970246,47970080,3,"<p>These two function calls are <em>indeterminately sequenced w.r.t. each other</em>. <a href=""http://port70.net/~nsz/c/c11/n1570.html#6.5.2.2p10"" rel=""nofollow noreferrer"">C11 6.5.2.2p10</a>:</p>

<blockquote>
  <p>There is a sequence point after the evaluations of the function designator and the actual arguments but before the actual call. <em>Every evaluation in the calling function (<strong>including other function calls</strong>) that is not otherwise specifically sequenced before or after the execution of the body of the called function is indeterminately sequenced with respect to the execution of the called function.</em></p>
</blockquote>

<p>And indeterminately sequenced means that <a href=""http://port70.net/~nsz/c/c11/n1570.html#5.1.2.3p3"" rel=""nofollow noreferrer"">C11 5.1.2.3p3</a></p>

<blockquote>
  <p>Evaluations A and B are indeterminately sequenced when A is sequenced either before or after B, but it is unspecified which</p>
</blockquote>

<p>Therefore either <code>f1</code> or <code>f2</code> will be called first, and the execution of the functions would not be interleaved. You can tell it afterwards by checking the value of <code>x</code> - if it is <code>5</code> then <code>f2</code> was called first; if <code>10</code>, <code>f1</code> was called first.</p>

<p>The <a href=""http://port70.net/~nsz/c/c11/n1570.html#note86"" rel=""nofollow noreferrer"">footnote 86</a> says also:</p>

<blockquote>
  <p>In an expression that is evaluated more than once during the execution of a program, unsequenced and indeterminately sequenced evaluations of its subexpressions need not be performed consistently in different evaluations.</p>
</blockquote>

<p>I.e. if you did this in a loop, on first iteration <code>f1</code> might be called first and on next <code>f2</code> might be called first...</p>

<hr>

<p>The operator associativity and precedence have almost nothing at all to do with actual <em>order of evaluation</em> - the order of evaluation of operands of <code>+</code>, like almost all other operators, is <a href=""http://port70.net/~nsz/c/c11/n1570.html#6.5p3"" rel=""nofollow noreferrer"">unspecified - and unsequenced (C11 6.5p3)</a>.</p>
",6
45677938,45677712,-1,"<p>Constant expression is the expression which value is known (can be evaluated) during the compilation</p>

<p>examaples </p>

<pre><code>int a = 5+5+3;  //5 + 5 +3 
char []= ""Hello""; // string literal ""hello""
</code></pre>

<p>Not modificable lvalues are constant objects &amp; constant expessions</p>

<p>Exmaples </p>

<pre><code>const char c;
c = '3';

'3' = c;
</code></pre>

<p>Modifiable lvalue has to be addressable (ie you can get their address using &amp;) and assignable ie they can be on the left side of the assignment operator. The only exception are register variables which do no have the address.</p>
",3
45677977,45677712,6,"<blockquote>
  <p><em>What are constant expressions?</em></p>
</blockquote>

<p>¡ì6.6- Constant Expression:  </p>

<blockquote>
  <p>A constant expression can be evaluated during translation rather than runtime, and accordingly may be used in any place that a constant may be.  </p>
</blockquote>

<p>One of the constraint on the constant expression is  </p>

<blockquote>
  <p>Constant expressions shall not contain assignment, increment, decrement, function-call, or comma operators, except when they are contained within a subexpression that is not evaluated<sup>115)</sup>.  </p>
</blockquote>

<hr>

<blockquote>
  <p><em>What are the differences between constant expressions and nonmodifiable lvalues?</em></p>
</blockquote>

<p>Non modifiable lvalues are not constant expressions. <strong>Non-modifiable values are lvalues that can't be used to modify an object</strong>.  </p>

<pre><code>int const i = 5;
</code></pre>

<p><code>i</code> is referring to a const object but it is an lvalue, a special kind of lvalue called non-modifiable lvalue. </p>

<p>Wherever standard says about ""lvalue"", it actually means ""modifiable lvalue"" (you won't find this in standard but for the sake of clarity)  </p>

<p>Now let me explain it a bit more. </p>

<pre><code>int x = 5;
int const *p;
</code></pre>

<p><code>x</code> is a non const object and it is a modifiable lvalue. <code>p</code> is a pointer to a <code>const int</code> object.   </p>

<pre><code>p = &amp;x;  // This will raise a warning though and hazardous to do.
</code></pre>

<p>Above assignment uses a qualification conversion to convert a value of type <em>pointer to <code>int</code></em> into a value of type <em>pointer to <code>const int</code></em>.<br>
<code>*p</code> and <code>x</code> are two different expression referring to the same object. This abject can be modified using <code>x</code>  </p>

<pre><code>--x;  
</code></pre>

<p>but this can't be done using <code>*p</code> as it is a non-modifiable lvalues.   </p>

<pre><code>--(*p); // Error
</code></pre>

<p>One more difference between a constant expression and a non-modifiable lvalue is   </p>

<pre><code>int const x = 5;
int *p;
/* Assigning address of a non-modifiable object */
p = &amp;x      // Correct
/* Assigning address of a constant expression */
p = &amp;5      // Wrong  
</code></pre>

<blockquote>
  <p><em>Are constant expressions always non-lvalues?</em> </p>
</blockquote>

<p>Yes, constant expressions are always <em>non-lvalues</em>, i.e rvalues.</p>

<blockquote>
  <p><em>Are nonmodifiable lvalues constant expressions?</em>  </p>
</blockquote>

<p><strong>No</strong>.</p>
",5
45677991,45677712,4,"<ol>
<li><p>Constant expressions are defined in <a href=""http://port70.net/~nsz/c/c11/n1570.html#6.6"" rel=""nofollow noreferrer"">C11 6.6</a>:</p>

<blockquote>
  <p><strong>Description</strong></p>
  
  <p><a href=""http://port70.net/~nsz/c/c11/n1570.html#6.6p2"" rel=""nofollow noreferrer"">2</a>. A constant expression can be evaluated during translation rather than runtime, and accordingly may be used in any place that a constant may be. </p>
  
  <p>Constraints</p>
  
  <p><a href=""http://port70.net/~nsz/c/c11/n1570.html#6.6p3"" rel=""nofollow noreferrer"">3</a> Constant expressions shall not contain assignment, increment, decrement, function-call, or <a href=""https://stackoverflow.com/questions/1737634/c-comma-operator"">comma operators</a>, except when they are contained within a subexpression that is not evaluated.115)</p>
  
  <p><a href=""http://port70.net/~nsz/c/c11/n1570.html#6.6p4"" rel=""nofollow noreferrer"">4</a> Each constant expression shall evaluate to a constant that is in the range of representable values for its type.</p>
</blockquote>

<p>There are several types of constant expressions which might be allowed in a place. There are constant expressions that evaluate to</p>

<ul>
<li>an arithmetic constant expression,

<ul>
<li>a special case of this is <em>integer constant expression</em>, which is allowed for example as the size of a (statically allocated) array, or a bitfield width.</li>
</ul></li>
<li>a null pointer constant,</li>
<li>an address constant, or</li>
<li>an address constant for a complete object type plus or minus an integer constant expression. </li>
</ul></li>
<li><p>lvalues or locator values (potentially) designate objects. You can take the address of an lvalue. The difference between a modifiable and non-modifiable lvalue is that the latter cannot be used as the left-hand side of an assignment. Or, <a href=""http://port70.net/~nsz/c/c11/n1570.html#6.3.2.1p1"" rel=""nofollow noreferrer"">C11 6.3.2.1p1</a>:</p>

<blockquote>
  <p>A modifiable lvalue is an lvalue that does not have array type, does not have an incomplete type, does not have a const- qualified type, and if it is a structure or union, does not have any member (including, recursively, any member or element of all contained aggregates or unions) with a const- qualified type.</p>
</blockquote>

<p>A non-modifiable lvalue is an lvalue that is not modifiable.</p>

<p>Constant expressions are just... values. They do not reside in memory - there  is no address for number 42 - <code>&amp;42</code> is meaningless.</p></li>
<li><p>constant expressions are thus always non-lvalues. They do not designate <em>objects</em>. You cannot take the address of <code>6 * 9</code>.</p></li>
<li><p>no, but... lvalues of array types implicitly decay into pointers-to-arrays, and these <em>are</em> address constants. However as they're thusly converted they stop being lvalues.</p></li>
</ol>
",2
45678075,45677712,2,"<p>I think there are more than one <em>complex</em> questions, let me try to answer it in a simple way (<em>mostly by blatantly copy-pasting from the standard, just creation a retational connection on my own</em>).</p>

<blockquote>
  <p><em>1. What are constant expressions?</em></p>
</blockquote>

<p><code>C11</code>, chapter ¡ì6.5, <code>Expressions</code>,</p>

<blockquote>
  <p>An <em>expression</em> is a sequence of operators and operands that specifies computation of a
  value, or that designates an object or a function, or that generates side effects, or that
  performs a combination thereof.</p>
</blockquote>

<p>chapter 6.6, <code>Constant expressions</code></p>

<blockquote>
  <p>constant expression can be evaluated during translation rather than runtime, and
  accordingly may be used in any place that a constant may be.</p>
</blockquote>

<p>and, P4</p>

<blockquote>
  <p>Each constant expression shall evaluate to a constant that is in the range of representable
  values for its type.</p>
</blockquote>

<p>and, for <code>Lvalues</code>, chapter ¡ì6.3.2,</p>

<blockquote>
  <p>An lvalue is an expression (with an object type other than void) that <strong>potentially
  designates an object</strong></p>
</blockquote>

<p>and, for an <strong><em>object</em></strong>, ¡ì3.15,</p>

<blockquote>
  <p><strong>object</strong></p>
  
  <p>region of data storage in the execution environment, the contents of which can represent
  values</p>
</blockquote>

<p>Some constant expressions, such as arrays (array names), string literals or address constants, are lvalues. Otherwise, for the whole range of non-modifiable lvalues, consists of constant object (or object references) and constant expressions.</p>
",3
35296753,35295826,1,"<p>Having structs hidden has advantages and disadvantages. A hidden struct can never be allocated by the client without constructor. A hidden struct requires a destructor and the client is required to remember calling it. This is an advantage or a disadvantage depending on your requirement.</p>

<p>Here are two implementations for comparison:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/*VIVIBLE.h*/
typedef struct
{
    int number;
}VISIBLE;
void VISIBLE_INIT(VISIBLE * me, int num);
void VISIBLE_PRINT(const VISIBLE * me);

/*VIVIBLE.c*/
void VISIBLE_INIT(VISIBLE * me, int num) { if(me) me-&gt;number = num; }
void VISIBLE_PRINT(const VISIBLE * me) { if(me) printf(""%i\n"", me-&gt;number); }

/*SECRET.h*/
struct CLIENT;
void CLIENT_CTOR(struct CLIENT ** me, int num);
void CLIENT_DTOR(struct CLIENT ** me);
void CLIENT_PRINT(const struct CLIENT * me);

/*SECRET.c*/
typedef struct CLIENT
{
    int number;
}CLIENT;
void CLIENT_CTOR(CLIENT ** me, int num)
{
    if (me)
    {
        *me = (CLIENT*)malloc(sizeof(CLIENT));
        (*me)-&gt;number = num;
    }
}
void CLIENT_DTOR(CLIENT ** me)
{
    if (me &amp;&amp; *me) free(*me);
    *me = 0;
}
void CLIENT_PRINT(const CLIENT * me) { if(me) printf(""%i\n"", me-&gt;number); }

/*main.c*/
void visible()
{
    VISIBLE vis; // client can allocate memory
    VISIBLE_INIT(&amp;vis, 4);
    VISIBLE_PRINT(&amp;vis);
    //if there is no need for a destructor the client does not need to call one
}

void hidden()
{
    CLIENT * hidden; 
    CLIENT_CTOR(&amp;hidden, 3);
    CLIENT_PRINT(hidden);
    CLIENT_DTOR(&amp;hidden); //Client is never allowed to forget the destructor
}

int main()
{
    visible();
    hidden();
}
</code></pre>
",0
35296053,35295826,6,"<p>You're almost there.  Your interface has to be in terms of pointers to the opaque type:</p>

<pre><code>struct hidden_implementation_type;
typedef struct hidden_implementation_type visible_type_to_clients;

int component_function1(visible_type_to_clients *instance_type);
</code></pre>

<p>and:</p>

<pre><code>int main(void)
{
    visible_type_to_clients *a = 0;
    return component_function1(a);
}
</code></pre>

<p>This will at least compile ¡ª it won't do anything useful, though.  You'd probably need a function such as:</p>

<pre><code>visible_type_to_clients *new_visible(void);
</code></pre>

<p>to create a value of the type and return a pointer it, and then you can use:</p>

<pre><code>int main(void)
{
    visible_type_to_clients *a = new_visible();
    return component_function1(a);
}
</code></pre>

<p>Basically, the clients won't be able to create structures on the stack (or global structures) of your type because you've not told the compiler how big the type is.  But you can deal in pointers ¡ª and typed pointers are vastly safer than 'untyped' <code>void *</code> pointers.</p>

<p>I left out error checking for simplicity.  I redid the structure tag name without the leading underscore because for all practical purposes, names starting with an underscore are <a href=""https://stackoverflow.com/questions/1449181/"">reserved for the implementation</a>.  I'd go with:</p>

<pre><code>typedef struct VisibleType VisibleType;
</code></pre>

<p>where the tag and the type name are the same.</p>
",0
40956455,40956228,2,"<p>So you want an ""array 10 of pointer to array of pointer 20 to <code>int</code>"" (you have to specify the dimensions for all but functions arguments where you can omit the outermost dimension only).</p>

<p>That would be:</p>

<pre><code>int *(*a[10])[20];
</code></pre>

<p>For such constructs, cdecl is very helpful. The line in quotes is the  declaration for the tool.</p>

<p>Note this is <em>what you asked for</em>. Which is not necessarily what you really need. Often such complex constructs are a symptom of a severe design flaw. You might want to reconsider your program code.</p>
",0
40956267,40956228,1,"<p>Try changing the declaration of <code>m</code> to</p>

<pre><code>int **m[2];
</code></pre>
",3
34956052,34955891,1,"<p>This cast is justified, and you need it because you want to convert a pointer into a pointer to pointer. If you do not cast, dereference will be incorrect.</p>

<p>In other words, your <code>base*</code> has the same address as <code>pt</code> object. So you can access it through a pointer to pt. But you have to dereference it. </p>
",0
34956226,34955891,2,"<p>The code doesn't just casts, it also dereferences the pointer to the pointer to struct base. This is necessary to obtain the pointer to base in the first place. </p>

<p>This is what happens in your code, if the function <code>tobase_pointed</code> was removed:</p>

<pre><code>struct pointed pt = {&amp;em.base};
void* object = &amp;pt;                  //pass to the function
struct base** bs = object;           //the cast in the function
assert( bs == (struct base**)&amp;pt ) ; //bs points to the struct pointed
assert( bs == &amp;(pt.base) ) ;         //bs also points to the initial member struct base* base
struct base* b = *bs ;               //the dereference in the function
base_print(x);
</code></pre>

<p><code>bs</code> is the pointer that was suitably converted to point to the initial member. Your code is correct.</p>
",1
45669467,3684450,14,"<p>You can apply <code>static</code> to both variables and functions.  There are two answers that discuss the behaviour of <code>static</code> and <code>extern</code> with respect to variables, but neither really covers functions.  This is an attempt to rectify that deficiency.</p>

<h1>TL;DR</h1>

<ul>
<li>Use static functions whenever possible.</li>
<li>Only declare external functions in headers.</li>
<li>Use the headers where the functions are defined and where the functions are used.</li>
<li>Don't declare functions inside other functions.</li>
<li>Don't exploit the GCC extension with function definitions nested inside other functions.</li>
</ul>

<h1>External functions</h1>

<p>By default, functions in C are visible outside the translation unit (TU ¡ª basically the C source file and included headers) in which they are defined.  Such functions can be called by name from any code that notifies the compiler that the function exists ¡ª usually by a declaration in a header.</p>

<p>For example, the header <code>&lt;stdio.h&gt;</code> makes visible declarations of functions such as <code>printf()</code>, <code>fprintf()</code>, <code>scanf()</code>, <code>fscanf()</code>, <code>fopen()</code>, <code>fclose()</code>, and so on.  If a source file includes the header, it can call the functions.  When the program is linked, the correct library must be specified to satisfy the function definition.  Fortunately, the C compiler automatically provides the library that provides (most of) the functions in the standard C library (and it usually provides a lot more functions than just those).  The 'most of' caveat applies because on many systems (Linux, for instance, but not macOS), if you use functions declared in the <code>&lt;math.h&gt;</code> header, you need to link with the maths library ('math' library if you're American), which usually is indicated by the option <code>-lm</code> on the linker command line.</p>

<p>Note that external functions should be declared in headers.  Each external function should be declared in one header, but one header may declare many functions.  The header should be used both in the TU where each function is defined and in each TU that uses the function.  You should never need to write a declaration for a global function in a source file (as opposed to a header file) ¡ª there should be a header to declare the function and you should use that header to declare it.</p>

<h1>Static functions</h1>

<p>As an alternative to generally visible functions, you can make your own functions <code>static</code>.  This means that the function cannot be called by name from outside the TU in which it is defined.  It is a hidden function.</p>

<p>The primary advantage of static functions is hiding details which the outside world doesn't need to know about. It is a basic but powerful information hiding technique.  You also know that if a function is static, you do not need to look for uses of the function outside the current TU, which can greatly simplify the search.  However, if the functions are <code>static</code>, there can be multiple TUs which each contain a definition of a function with the same name ¡ª each TU has its own function, which may or may not do the same thing as a function with the same name in a different TU.</p>

<p>In my code, I qualify all functions except <code>main()</code> with the keyword <code>static</code> by default ¡ª unless there's a header that declares the function.  If I subsequently need to use the function from elsewhere, it can be added to the appropriate header and the keyword <code>static</code> removed from its definition.</p>

<h1>Declaring functions inside other functions</h1>

<p>It is possible, but very inadvisable, to declare a function inside the scope of another function.  Such declarations fly in the face of Agile Development maxims such as SPOT (Single Point of Truth) and DRY (Don't Repeat Yourself).  They're also a maintenance liability.</p>

<p>However, you can, if you so desire, write code such as:</p>

<pre><code>extern int processor(int x);

int processor(int x)
{
    extern int subprocess(int);
    int sum = 0;
    for (int i = 0; i &lt; x; i++)
        sum += subprocess((x + 3) % 7);
    return sum;
}

extern int subprocess(int y);

int subprocess(int y)
{
    return (y * 13) % 37;
}
</code></pre>

<p>The declaration in <code>processor()</code> suffices for it to use <code>subprocess()</code>, but is otherwise unsatisfactory.  The <code>extern</code> declaration before the definition is necessary if you use GCC compiler options such as:</p>

<pre><code>$ gcc -O3 -g -std=c11 -Wall -Wextra -Werror -Wmissing-prototypes -Wstrict-prototypes \
&gt;     -c process.c
process.c:12:5: error: no previous prototype for ¡®subprocess¡¯ [-Werror=missing-prototypes]
 int subprocess(int y)
     ^~~~~~~~~~
cc1: all warnings being treated as errors
$
</code></pre>

<p>This is, I find, a good discipline, similar to what C++ enforces.  It's another reason I make most functions static, and define the functions before they're used.  The alternative is to declare static functions at the top of the file and then define them in whatever order seems appropriate.  There are some merits to both techniques; I prefer to avoid the need to declare and define the same function in the file by defining before use.</p>

<p>Note that you cannot declare a <code>static</code> function within another function, and if you attempt to define a function such as <code>subprocess()</code> as a static function, the compiler gives an error:</p>

<pre><code>process.c:12:16: error: static declaration of ¡®subprocess¡¯ follows non-static declaration
     static int subprocess(int y)
                ^~~~~~~~~~
process.c:5:20: note: previous declaration of ¡®subprocess¡¯ was here
         extern int subprocess(int);
                    ^~~~~~~~~~
</code></pre>

<p>Since functions that are externally visible should be declared in a header, there is no need to declare them inside a function, so you should never run into this as a problem.</p>

<p>Again, the <code>extern</code> is not necessary in the function declaration inside the function; if omitted, it is assumed.  This can lead to unexpected behaviour in novice programs here on SO ¡ª you sometimes find a function declaration where a call was intended.</p>

<p>With GCC, the option <code>-Wnested-externs</code> identifies nested <code>extern</code> declarations.</p>

<h1>Called by name vs called by pointer</h1>

<p><sup><em>If you have a nervous disposition, stop reading now. This gets hairy!</em></sup></p>

<p>The 'called by name' comment means that if you have a declaration such as:</p>

<pre><code>extern int function(void);
</code></pre>

<p>you can write in your code:</p>

<pre><code>int i = function();
</code></pre>

<p>and the compiler and linker will sort things out so that the function is called and the result used.  The <code>extern</code> in the declaration of the function is optional but explicit.  I normally use it in a header file to match the declaration of those rare global variables ¡ª where the <code>extern</code> is not optional but mandatory.  Many people disagree with me on this; do as you wish (or must).</p>

<p>Now what about static functions?
Suppose the TU <code>reveal.c</code> defines a function <code>static void hidden_function(int) { ¡­?}</code>.
Then, in another TU <code>openness.c</code>, you cannot write :</p>

<pre><code>hidden_function(i);
</code></pre>

<p>Only the TU that defines the hidden function can use it directly.  However, if there's a function in <code>reveal.c</code> that returns a function pointer to the <code>hidden_function()</code>, then the code <code>openness.c</code> can call that other function (by name) to get a pointer to the hidden function.</p>

<h3><code>reveal1.h</code></h3>

<pre><code>extern void (*(revealer(void)))(int);
</code></pre>

<p>Obviously, that's a function that takes no arguments and returns a pointer to a function that takes an <code>int</code> argument and returns no value.  No; it isn't pretty.  One of the times it makes sense to use <code>typedef</code> on pointers is with pointers to functions (<code>reveal2.h</code>):</p>

<pre><code>typedef void (*HiddenFunctionType)(int);
extern HiddenFunctionType revealer(void);
</code></pre>

<p>There: much simpler to understand.</p>

<p>See <a href=""http://stackoverflow.com/questions/750178/is-it-a-good-idea-to-typedef-pointers"">Is it a good idea to typedef pointers</a> for a general discussion on the subject of <code>typedef</code> and pointers; the short summary is ""it isn't a good idea except perhaps with function pointers"".</p>

<h3><code>reveal1.c</code></h3>

<pre><code>#include &lt;stdio.h&gt;
#include ""reveal1.h""

static void hidden_function(int x)
{
    printf(""%s:%s(): %d\n"", __FILE__, __func__, x);
}

extern void (*(revealer(void)))(int)
{
    return hidden_function;
}
</code></pre>

<p>Yes, it is legitimate (but very unusual) to define the function with an explicit <code>extern</code> ¡ª I very, very seldom do it, but here it emphasizes the role of <code>extern</code> and contrasts it with <code>static</code>.  The <code>hidden_function()</code> can be returned by <code>revealer()</code>, and could be called by code inside <code>reveal.c</code>.  You can remove the <code>extern</code> without changing the meaning of the program.</p>

<h3><code>openness1.c</code></h3>

<pre><code>#include &lt;stdio.h&gt;
#include ""reveal1.h""

int main(void)
{
    void (*revelation)(int) = revealer();
    printf(""%s:%s: %d\n"", __FILE__, __func__, __LINE__);
    (*revelation)(37);
    return 0;
}
</code></pre>

<p>This file cannot usefully contain a direct call by name to <code>hidden_function()</code> because it is hidden in the other TU.  However, the <code>revealer()</code> function declared in <code>reveal.h</code> can be called by name and it returns a pointer to the hidden function, which can then be used.</p>

<h3><code>reveal2.c</code></h3>

<pre><code>#include &lt;stdio.h&gt;
#include ""reveal2.h""

static void hidden_function(int x)
{
    printf(""%s:%s(): %d\n"", __FILE__, __func__, x);
}

extern HiddenFunctionType revealer(void)
{
    return hidden_function;
}
</code></pre>

<h3><code>openness2.c</code></h3>

<pre><code>#include &lt;stdio.h&gt;
#include ""reveal2.h""

int main(void)
{
    HiddenFunctionType revelation = revealer();
    printf(""%s:%s: %d\n"", __FILE__, __func__, __LINE__);
    (*revelation)(37);
    return 0;
}
</code></pre>

<h3>Sample outputs</h3>

<p>Not the most exciting output in the world!</p>

<pre><code>$ openness1
openness1.c:main: 7
reveal1.c:hidden_function(): 37
$ openness2
openness2.c:main: 7
reveal2.c:hidden_function(): 37
$
</code></pre>
",0
46097813,46097517,-2,"<p><strong>Wrong answer</strong></p>

<p>You can use a type which can store the 19 bits. Example : <code>uint32_t *n = (uint32_t *) tempVal;</code>. Now you can get the desired bits <code>(*n) &amp; 0x7FFFF</code></p>

<hr>

<p><strong>Good answer</strong></p>

<p>You can use union to respect strict aliasing :</p>

<pre><code>union foo {
    unsigned char   tmp[6];
    unsigned int    n;
};
</code></pre>
",2
46097913,46097517,-1,"<p>You probably intended to achieve something like this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;

int main(void)
{
  unsigned char tempVal[6] = { 0x1,0x2,0x3,0x4,0,0 };
  uint32_t *temPtr = (uint32_t *)tempVal; // Say I am using pt
  uint32_t newVal = *temPtr;

  printf(""%08x\n"", newVal);
  newVal &amp;= 0x7ffff;
  printf(""%08x\n"", newVal);
}
</code></pre>

<p>On a little endian system the output will be:</p>

<pre><code>04030201
00030201
</code></pre>

<p>On a big endian system the output will be:</p>

<pre><code>01020304
01020304
</code></pre>

<p>Be aware that this is <strong>not portable</strong> as it depends on the endianness of the target system and it also violates the <a href=""https://stackoverflow.com/questions/98650/what-is-the-strict-aliasing-rule""><strong>strict aliasing rule</strong></a></p>

<p><strong>Portable and correct solution:</strong></p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;

int main(void)
{
  unsigned char tempVal[6] = { 0x1,0x2,0x3,0x4,0,0 };

  uint32_t value = 0;
  for (int i = 0; i &lt; 4; i++)
  {
    value &lt;&lt;= 8;
    value |= tempVal[i];
  }

  printf(""%08x\n"", value);
  value &amp;= 0x7ffff;
  printf(""%08x\n"", value);
}
</code></pre>
",5
46098396,46097517,1,"<p>The main issue here is that you can't take a pointer to <code>unsigned char</code> and wildly cast it to a larger pointer type. This would result in a strict aliasing violation - undefined behavior. This can give incorrectly generated code and similar evil bugs.</p>

<p>To dodge this and access the array through a pointer, you could use a container type that contains the same type among its members:</p>

<pre><code>#include &lt;stdint.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;inttypes.h&gt;

typedef union
{
  unsigned char u8 [6];
  uint32_t u32;
} my_union_t;

int main()
{
  unsigned char tempVal[6] = { 0x11,0x22,0x33,0x44,0x55,0x66};
  my_union_t* mu = (my_union_t*)tempVal;
  printf(""%""PRIx32""\n"", mu-&gt;u32 &amp; 0x7FFFF);
}
</code></pre>

<p>As for what this will print, it depends on CPU endianess - the code is not portable. On my 32 bit little endian CPU I get <code>32211</code>. </p>
",8
40998013,10997552,0,"<p>Merging can be done by sorting the elements of the elements which are going to be merged code for merging two arrays</p>

<pre><code>#include&lt;stdio.h&gt;
void sort(int arr[],int size){  // sorting function
    int i,j,temp;
    for(i=0;i&lt;size;i++){
        for(j=i;j&lt;size;j++){
            if(arr[i]&gt;arr[j]){
                temp = arr[i];
                arr[i] = arr[j];
                arr[j] =  temp;
            }
        }
    }
}
int main(){
    int a[10],b[10],c[10];
    int n,i,k=0,j=0;
    printf(""Enter the size of the array:"");
    scanf(""%d"",&amp;n);
    for(i=0;i&lt;n;i++){
        printf(""Enter the element of array A at index %d:"",i); //input array A
        scanf(""%d"",&amp;a[i]);
    }
    sort(a,n);
    for(i=0;i&lt;n;i++){
        printf(""Enter the element of array B at index %d:"",i);  //Input array B
        scanf(""%d"",&amp;b[i]);
    }
    sort(b,n);
    for(i=0;i&lt;(n+n);i++){   // merging the two arrays
        if(a[k]&lt;b[j]){
            c[i] = a[k];
            k++;
        }
        else{
            c[i] = b[j];
            j++;
        }
    }
    printf(""Merged Array :\n"");
    for(i=0;i&lt;(n+n);i++){
        printf(""c -&gt; %d "",c[i]);
    }
    return 0;
}
</code></pre>

<p>Reference <a href=""http://www.psychocodes.in/c-program-to-merge-two-arrays-after-sorting.html"" rel=""nofollow noreferrer"">C program to Merge Two Arrays after Sorting</a></p>
",0
41687044,7462396,0,"<p>Or you could use an extern.</p>

<p>Define a function in main.c:</p>

<pre><code> void sj_handleException(bool fatal, const char* msg, const char* libMsg){
  fprintf(stderr, msg);
  if(libMsg != NULL) fprintf(stderr, libMsg);

  if(fatal) exit(EXIT_FAILURE);    
}
</code></pre>

<p>Any file that mallocs memory add as you would a forward declaration:</p>

<pre><code>extern void sj_handleException(bool fatal, const char* msg, const char* libMsg)
</code></pre>

<p>Now write malloc as:</p>

<pre><code>char *ptr = (char *)malloc(sizeof(char) * some_int);
if (ptr == NULL) sj_handleException(true, ""failed to allocate memory.\n"", NULL);
</code></pre>

<p>The linkage between the place in your code where you malloc'd memory and main.c that handles the exception is generated behind the scenes by the linker; it maps calls to the function with the function even though the two exist in different  source files. </p>
",0
39672003,39671122,1,"<p>You have to do it exactly like you did it in your second snippet. The only way you can do it all in one initialization (as in your original code) is if you declare <code>elements</code> as an array of <code>shape_t *</code>, as in <code>shape_t *elements[10]</code>, but you probably don't want to have a fixed size array there.</p>
",0
39672054,39671122,1,"<p>If you move elements member to the END of the structure DEFINITION you can then use the following on C99, and later, compilers:</p>

<pre>container_t c2 = {
    .name       = {""Case2""},
    .num_elts   =3,
    .elements   =  {
        &(shape_t){ 3, ""Triangle"" } ,
        &(shape_t){ 4, ""Rectangle"" },
        &(shape_t){ 2, ""Line"" }
    }
};</pre>

<p>The variable size member must be the last member of the structure.</p>

<p>The part of me that hates places for easy bugs notes you can get rid of the need for a manually set element count by ending the list with a NULL pointers and dropping num_elts:</p>

<pre>container_t c2 = {
    .name       = {""Case2""},
    .elements   =  {
        &(shape_t){ 3, ""Triangle"" } ,
        &(shape_t){ 4, ""Rectangle"" },
        &(shape_t){ 2, ""Line"" },
        NULL
    }
};</pre>

<p>Now you just step through the list until <code>NULL == container_list->elements[n]</code></p>
",0
39672071,39671122,2,"<p>You are almost there; you just need to ensure that the <code>elements</code> initializer is a suitable pointer, like this:</p>

<pre><code>struct shape {
    int     angles;
    char    shape_name[16];
};
typedef struct shape shape_t;
struct container {
    char            name[32];
    shape_t         **elements;
    int             num_elts;
};
typedef struct container container_t;

shape_t triangle = {
    .angles     = 3,
    .shape_name = { ""Triangle"" }
};
shape_t rectangle = {
    .angles     = 4,
    .shape_name = { ""Rectangle"" }
};

container_t c = {
    .name       = { ""Case"" },
    .elements   =  (shape_t *[]) {
        &amp;triangle,
        &amp;rectangle,
    },
    .num_elts   = 2,
};

int main(void) {
    return 0;
}
</code></pre>

<p>Note the use of a compound literal for the array of pointers to <code>shape_t</code> elements.</p>
",2
46651157,8896281,4,"<p>""void value not ignored as it ought to be"" 
 this error occurs when function like srand(time(NULL)) does not return something and you are treating it as it is returning something. As in case of pop() function in queue ,if you will store the popped element in a variable you will get the same error because it does not return anything.</p>
",0
46048758,34156406,0,"<ul>
<li><p>In <code>consumer()</code> you have two calls to <code>sem_wait(full)</code>; drop the second one.</p></li>
<li><p>In <code>consumer()</code> you have <code>i = (i + 1) % (BUFF_SIZE)</code>; correct is <code>i = (i + 1) % MAX_BUF</code>.</p></li>
<li><p>Note that subsequent runs of your program may behave differently from the first run, since you don't remove the semaphores by <code>sem_unlink()</code>, and their initial values are set when created.</p></li>
</ul>
",0
47473364,47473323,1,"<p>You can do it simply using a VLA. The OP's initial question never mentioned that OP needs to get the input in a line and parse it. I have given that as an answer in the second part. But simply that is not needed. It is not a feasible reason that you have to get the <code>numbers</code> all at once. You can get the size using one <code>scanf</code> and then the elements in another <code>scanf</code>.</p>
<pre><code>scanf(&quot;%d&quot;, &amp;num);
//Then you know the dimension of the array.

int arr[num][num];
for(size_t i=0;i&lt;num; i++)
  for(size_t j =0; j&lt; num; j++)
     if( scanf(&quot;%d&quot;,&amp;arr[i][j]) != 1)
     {
        fprintf(stderr,&quot;Error in input&quot;);
        exit(1);
     }
</code></pre>
<p>Also as you know how many numbers will be read you don't need to continue scanning until you get <code>'\n'</code> or <code>EOF</code>.</p>
<p>Given your case your over complicating things IMHO. As you know the numbers you can get the benefit of VLA.</p>
<hr />
<p>If you have to get all the numbers in a single line you need to look at 3 functions. <code>fgets()</code>  and <code>strtol</code>. Those will help you achieving reading everything in a line and then tokenizing.</p>
<p>To give you a demo of what I said you can do this</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define BUFSIZE 256

int main(void)
{
    char line[BUFSIZE];
    long temp[BUFSIZE];
    int i = 0;
    if (fgets(line, sizeof line, stdin) != NULL)
    {
        const char *ptr = line;
        while (*ptr != '\0')
        {
            char *endptr = NULL;
            long val = strtol(ptr, &amp;endptr, 10);
            if (endptr != ptr)
              temp[i++] = val;
            else
                break;
            ptr = endptr;
        }
    }
    int sz = temp[0];
    if( sz &lt;= 0 )
    {
        fprintf(stderr,&quot;Error in size input&quot;);
        exit(1);
    }
    int tempIn = 1;
    long arr[sz][sz];
    for(size_t i = 0; i &lt; sz; i++)
        for(size_t j = 0; j &lt; sz; j++)
            arr[i][j]= temp[tempIn++];

    for(size_t i = 0; i &lt; sz; i++)
        for(size_t j = 0; j &lt; sz; j++)
            printf(&quot;%ld &quot;,arr[i][j]);

}
</code></pre>
<p>In the second code, as you can see <code>fgets</code> has been used which basically read a line and then <code>strtol</code> has been used. As you have mentioned that you will give a single line input of numbers.</p>
<p>Now what we did?</p>
<p>The line scanned and the parsed number by number using <code>strtol</code>. For a brief overview of <code>strtol</code> check <a href=""https://linux.die.net/man/3/strtol"" rel=""nofollow noreferrer"">this</a>.</p>
<hr />
<p>Also OP asked for how to use dynamic memory allocation to do the same thing. And there is no way a while loop is needed here. This is redundant. So while modifying I will add the code that will be able to do it much more simpler way.</p>
<pre><code>scanf(&quot;%d&quot;, &amp;num);
int matIndex = 0;      
/* Set Matrix dimension. */
dimension = num;
if (dimension &lt;= 0)
{
    printf(&quot;Size must be posiitve integer&quot;);
    return 1;
}
else
{
    mat = malloc(dimension * dimension * sizeof *mat);
    if ( mat == NULL ){
        fprintf(stderr, &quot;%s\n&quot;, &quot;Error in malloc&quot;);
        exit(1);
    }
}

// All the numbers will be taken as elements of the dynamically allocated array,
for(size_t i = 0; i &lt; dimension*dimension ; i++)
    if( scanf(&quot;%d&quot;,&amp;mat[i]) == 1){
         //ok
    }
    else{
        fprintf(stderr,&quot;Some error occured&quot;);
        break;
    }
</code></pre>
<hr />
<p>When you want to access the <code>i-th row and j-th column</code> element, you can do this <code>mat[i*dimension+j]</code> //<code>equivalent to mat[i][j]</code></p>
<p>Some useful information:-</p>
<ul>
<li><p>Allocating <code>dim*dim</code> memory doesn't let you access the element in the form of <code>mat[i[[j]</code>. Because you allocated a single chunk of memory - you have to calculate the positions explicitly and access the element in the linear array.</p>
</li>
<li><p>You can do all the scanning using <code>scanf()</code> but you need to be careful when having <code>scanf()</code>. But yes you can get this thing done using <code>scanf</code> also.</p>
</li>
<li><p>Also there is another thing to know about. The VLA will have automatic storage duration and limiting the memory you can have use this way. The dynamically allocated memory has much higher limit giving you a scope of having much larger dimensions array.</p>
</li>
<li><p>Note that in dynamic memory allocation you will need to <code>free</code> the allocated memory when you are done working with it.</p>
</li>
<li><p>If you want to use <code>mat[i][j]</code> not <code>mat[i*dim+j]</code> you can consider creating one <code>jagged array</code>.</p>
</li>
</ul>
<p>Few things that you will need:</p>
<h3>Reading Suggestion:</h3>
<ul>
<li><a href=""https://ericlippert.com/2014/03/05/how-to-debug-small-programs/"" rel=""nofollow noreferrer"">How to debug small programs</a></li>
<li><a href=""http://sekrit.de/webdocs/c/beginners-guide-away-from-scanf.html"" rel=""nofollow noreferrer"">Beginner's guide away from scanf</a></li>
<li><a href=""https://stackoverflow.com/questions/562303/the-definitive-c-book-guide-and-list"">Book list</a></li>
</ul>
",6
47473553,47473323,0,"<p>You can use following code:<br>
<strong>Note</strong>: You can redirect <code>STDIN</code> to your file. See <a href=""https://stackoverflow.com/a/42719418/8013471"">posts available here</a></p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    int D, i, j;
    freopen(""testfile.txt"",""r"",stdin);
    printf(""Ender dimention of matrix: "");
    scanf(""%d"",&amp;D);

    int** matrix =  malloc(D*D*sizeof(int));
    for(i=0; i&lt;D; i++)
    {
        for(j=0; j&lt;D; j++)
        {
            printf(""Ender element of matrix: "");
            scanf(""%d"",&amp;matrix[i][j]);
        }
    }

    printf(""Matrix is: \n"");
    for(i=0; i&lt;D; i++)
    {
        for(j=0; j&lt;D; j++)
        {
            printf(""%d "", matrix[i][j]);
        }
        printf(""\n"");
    }
    free(matrix);
    return 0;
}
</code></pre>
",4
36315339,36315080,0,"<p>dbush is correct, however a better pseudo random number would be to use the encryption library (if you OS supports one) as the ""randomness"" of the random number generator is better than using time as your seed.</p>

<p>As it stands, with the corrections, this would be easy to predict the numbers and defeat  the ""game.""</p>
",0
36315127,36315080,3,"<p>The way it is now, each time you call <code>generateBattleShipX</code> or <code>generateBattleShipY</code> you re-seed the random number generator.  Since <code>time</code> returns the time in seconds, multiple successive calls will return the same value, so the random number generator gets seeded with the same value, resulting in the same ""random"" number each time.</p>

<p><code>srand</code> should only be called once at the start of your program to seed the random number generator.  Once you do that, you'll get more random results.</p>
",1
35235121,35235082,4,"<p>Casting to <code>const char*</code> does nothing. It still points to the <code>str</code> value, which becomes invalid when you return because it's on the stack.</p>

<p>Adding the <code>const</code> just makes it so that whatever uses the return value can't modify the data pointed to by the pointer (unless they cast off the const). But since it points to a returned function's stack space, once <code>foo</code> returns, any access to the pointer is undefined behavior, so the point is moot.</p>
",4
44649251,44649095,0,"<p>The condition</p>

<pre><code>while (*z++ = *x++)
</code></pre>

<p>might be puzzling because of the expression concept of C which differs from some other languages. Note that strictly speaking, C does not have a boolean type. Furthermore, an assignment expression itself has a value, namely the assigned value.</p>
",1
44649256,44649095,3,"<p>In C, any expression can be used as a boolean. 0 (or null for pointers) means ""false"", non-zero means ""true"".</p>

<p>This even includes assignments. The expression is assigned, then evaluated.
So you can have code like</p>

<pre><code>while(*dest++ = *src++);
</code></pre>

<p>This is the sort of thing that tends to give C a bad name, but it is allowed.</p>
",0
44649303,44649095,2,"<p>To answer : </p>

<blockquote>
  <p>But how this line while (*z++ = *x++); can act as boolean 1/0</p>
</blockquote>

<p>This <code>while</code> loop will run until <code>*z</code> points to NUL, since the string literal contains ""abc\0"" this will loop over a, b, c then it will encounter <code>\0</code> which converts to <code>0</code> which will not satisfy the <code>while</code> and thus it terminates.</p>

<p><em>Big big disclaimer though</em>:
This code is dereferencing a pointer that was obtained by <code>malloc(0)</code>, that is already very much undefined behaviour and thus there's no point in reasoning why this code works or doesn't work.</p>
",0
44649318,44649095,6,"<blockquote>
  <p>But how this line <code>while (*z++ = *x++);</code> can act as boolean 1/0</p>
</blockquote>

<p>This is because in C, an assignment is an <em>expression</em> and it evaluates to the value that is assigned. When <code>*x</code> reaches the final <code>'\0'</code> terminator, it evaluates to <code>0</code>, therefore <code>false</code> in a boolean context.</p>

<p>This is btw a nice source of bugs due to mistyping:</p>

<pre><code>if (x = 1) // always true, as a side effect assigns 1 to x
</code></pre>

<blockquote>
  <p>And why I even set the <code>malloc(0);</code> to zero it also works well without any problem??</p>
</blockquote>

<p>Using the return value of <code>malloc(0)</code> to write values is just undefined and ""works by accident"". You request <em>zero</em> bytes, so you are never allowed to write to this allocation and <code>malloc()</code> could even return you a <em>null pointer</em>.</p>

<p>Citing myself here about <em>undefined behavior</em>:</p>

<blockquote>
  <h3>Undefined behavior in <code>C</code></h3>
  
  <p>C is a very low-level language and one consequence of that is the following:</p>
  
  <p><em>Nothing will ever stop you from doing something completely wrong</em>.</p>
  
  <p>Many languages, especially those for some <em>managed environment</em> like <code>Java</code>
  or <code>C#</code> actually stop you when you do things that are not allowed, say,
  access an array element that does not exist. <code>C</code> doesn't. As long as your
  program is <em>syntactically</em> correct, the compiler won't complain. If you do
  something forbidden in your program, <code>C</code> just calls the behavior of your
  program <strong>undefined</strong>. This formally allows anything to happen when running
  the program. Often, the result will be a crash or just output of ""garbage""
  values, as seen above. But if you're really unlucky, your program will seem
  to <em>work just fine</em> until it gets some slightly different input, and by that
  time, you will have a really hard time to spot where exactly your program is
  <em>undefined</em>. Therefore <strong>avoid undefined behavior by all means!</strong>.</p>
  
  <p>On a side note, <em>undefined behavior</em> can also cause security holes. This
  has happened <em>a lot</em> in practice.</p>
</blockquote>
",2
44649534,44649095,1,"<p>An assignment has a value, which is its left-hand side so:</p>

<pre><code>a = b; // value of the expression is a, after the assignment
</code></pre>

<p>So <code>if(a = b){}</code> is like saying <code>a = b; if(a){}</code>.</p>

<p>In <code>C</code> any <em>non zero</em> numeric value or <em>pointer</em> equals <em>true</em> and only zero <code>0</code> or a <em>null pointer</em> is false.</p>

<p>So the expression <code>if(*x){}</code> is <em>true</em> if the <code>char</code> pointed to by <code>x</code> is any character except the <em>null terminator</em> character <code>'\0'</code>.</p>

<p>Putting it all together:</p>

<pre><code>if(*x++ = *y++){}
</code></pre>

<p>Take the <code>char</code> pointed to by <code>y</code> and copy it to the <code>char</code> pointed to by <code>x</code>. Then increment both <code>x</code> and <code>y</code>. Execute the while body if that <code>char</code> was not the <em>null terminator</em> <code>'\0'</code>.</p>

<p>Sort of equivalent to:</p>

<pre><code>*x = *y
exp = *x;
x++;
y++;
if(exp){}
</code></pre>
",1
37829799,14484682,0,"<blockquote>
  <p>my stack frame is corrupted</p>
</blockquote>

<p>Looks very much like you declared a variable that is too large for the stack. Instead of </p>

<pre><code>int largeArray[1000][1000];
</code></pre>

<p>declare it as a pointer</p>

<pre><code>int *largeArray[1000][1000];
</code></pre>

<p>Of course changes in the code are necessary. </p>
",0
41912967,17906235,1,"<p>This question usually triggers a barrage of answers trying to explain the situation through the concept of <em>operator precedence</em>. In reality it cannot be explained that way, since this is a typical example of an input, on which surrogate concepts like ""operator precedence"" break down. As you probably know, there's really no ""operator precedence"" in C. There are only grammatical groupings, which generally cannot be expressed precisely through any linear ordering of operators.</p>

<p>Let's take a look at what the language specification says about it. The relevant portions of C grammar in this case are the grammars of <code>?:</code> operator and <code>=</code> operator. For <code>?:</code> operator it is </p>

<pre><code>conditional-expression:
  logical-OR-expression
  logical-OR-expression ? expression : conditional-expression
</code></pre>

<p>and for the <code>=</code> operator it is</p>

<pre><code>assignment-expression:
  conditional-expression
  unary-expression assignment-operator assignment-expression
</code></pre>

<p>In the first case the critical part is the last operand of <code>?:</code> operator: it is not an <code>expression</code>, but rather a <code>conditional-expression</code>. The <code>conditional-expression</code> is a different entry point into the grammar of C expression: it ""enters"" the grammar at the point where it is no longer possible to include a top-level <code>=</code> operator into a <code>conditional-expression</code>. The only way to ""smuggle"" a <code>=</code> operator into a <code>conditional-expression</code> is to descend the grammar all the way to the very bottom </p>

<pre><code>primary-expression:
  identifier
  constant
  string-literal
  ( expression )
  generic-selection
</code></pre>

<p>and then wrap around all the way to the top using the <code>( expression )</code> branch. This means that a <code>conditional-expression</code> can contain a <code>=</code> operator only when it is explicitly wrapped in <code>(...)</code>. E.g. the grammar prohibits you from having <code>g = b</code> as the last operand of <code>?:</code> operator. If you want something like that, you have to explicitly parenthesize it: <code>&lt;smth&gt; ? &lt;smth&gt; : (g = b)</code>.</p>

<p>A very similar situation exists with the second piece of grammar: assignment operator. The left-hand side (LHS) of assignment is <code>unary-expression</code>. And <code>unary-expression</code> ""enters"" the general grammar of C expression at the point where it is too late to include a top level <code>?:</code> operator. The only way to reach the <code>?:</code> operator from <code>unary-expression</code> is to descend all the way down to <code>primary-expression</code> and take the <code>( expression )</code> branch. This means that grammar prohibits you from having <code>a &gt; b ? g = a : g</code> as the LHS operand of <code>=</code> operator. If you want something like that, you have to explicitly parentesize it: <code>(a &gt; b ? g = a : g) = &lt;smth&gt;</code>.</p>

<p>For this reason ""popular"" answers claiming that ""operator precedence"" makes the language to parse your expression as </p>

<pre><code>(a &gt; b ? g = a : g) = b
</code></pre>

<p>are actually completely incorrect. In reality, there's no derivation tree in formal C grammar that would make your input fit the syntax of C language. Your input is not parsable at all. It is not an expression. It is simply syntactically invalid. C language sees it as a syntactic gibberish. </p>

<p>Now, in practice you might see some implementations to respond with a ""lvalue required as left operand of assignment"" diagnostic message. Formally, this is a misleading diagnostic message. Since the above input does not satisfy the grammar of C language <em>expression</em>, there's no ""assignment"" in it, there's no ""left operand"" and there's no meaningful ""lvalue"" requirement.</p>

<p>Why do compilers issue this strange message? Most likely they do indeed parse this input as a valid C expression</p>

<pre><code>(a &gt; b ? g = a : g) = b
</code></pre>

<p>The result of <code>?:</code> is never an lvalue in C, hence the error. However, this interpretation of your input is non-standard (extended?) behavior, which has no basis in formal C language. This behavior of specific implementations might be caused by their attempts to reconcile C and C++ grammars (which are quite different in this area), by their attempts to produce a more readable (albeit ""fake"") error message or by some other reason.</p>

<p>Typically, in such implementations a similar issue also would pop up in case of inputs like</p>

<pre><code>a + b = 5
</code></pre>

<p>The same error would be issued, suggesting a <code>(a + b) = 5</code> parse, while from the pedantic point of view <code>a + b = 5</code> is not parsable as an expression at all (for the same reasons as described above).</p>

<p>Again, formally, this is not enough to say that the compiler is ""broken"": the compiler is required to detect a constraint violation and issue <em>some</em> diagnostic message, which is exactly what happens here. The fact that the text of the diagnostic message does not correctly reflect the nature of the problem is inconsequential (the compiler can simply say ""Ha ha ha!""). But one undesirable consequence of such misleading diagnostics is that it misleads users into misinterpreting the problem, which is BTW painfully evident from the barrage of formally incorrect answers posted to this question.</p>
",0
41657550,41657519,6,"<p>There's nothing wrong with using return values of functions directly as arguments, per se.</p>

<p>Your particular use of it does leak memory, however. This is simple to see, since you never call <code>free()</code> on the memory you got from <code>calloc()</code>. (Unless your <code>plot()</code> function calls <code>free()</code>, at least.)</p>
",0
41186058,41185910,1,"<p>Given your requirement of</p>

<blockquote>
  <ol start=""2"">
  <li>while using child_old, I dont want to consume extra space needed by child_new.</li>
  </ol>
</blockquote>

<p>you can't use a union.</p>

<p>Per <strong>6.7.2.1 Structure and union specifiers</strong>, paragraph 16 of <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""nofollow noreferrer"">the C Standard</a>:</p>

<blockquote>
  <p>The size of a union is sufficient to contain the largest of its
  members.</p>
</blockquote>

<p>Thus the size of the union would be that of the largest member.</p>

<p>Note also, as pointed out in the comments, that changing the union may also impact the padding/alignment of other elements of any structure containing that union.</p>
",9
41186136,41185910,4,"<p>What you've written is fine, and you would consume it with something like:</p>

<pre><code>switch(p.flag) {
   case CHILD_OLD:
       // work with p.c1
       break;
   case CHILD_NEW:
       // work with p.c2
       break;
} 
</code></pre>

<p>However, your full struct will always be big enough for the largest member of the union. So when you use c1, you still have enough space for c2 allocated. But, at least you're not allocating <code>sizeof(c1) + sizeof(c2)</code> each time.</p>

<p>If you really want to allocate more or less space depending on which variant each record uses, you'll need to put a pointer in the struct, and dynamically allocate a separate record for the child elements.</p>

<hr>

<p>All of this does mean that if you're reading byte arrays from disk then casting them to a struct:</p>

<pre><code>  parent *p = (parent*) addressOfSomeDataReadFromAFile;
</code></pre>

<p>(Not a great idea, but not unusual in the wild)</p>

<p>... then expanding the <code>parent</code> struct using the union technique will not generally work. Your existing files will represent a record as fewer bytes than the new struct.</p>
",10
41186586,41185910,0,"<p>It is possible, but it is neither pretty nor effective. It is considered bad practice to use unions for storing different kinds of unrelated data. And as already mentioned, the size will be that of the biggest member of the union, so it is not memory-efficient either.</p>

<p>Instead, here is a more sensible solution:</p>

<pre><code>struct parent {
    char c[4];
    float f;
    double d;
    int flag;

    void* data;
}

...

struct parent x;
x.data = malloc(sizeof(struct child_old));
struct child_old* co_ptr = x.data;
co_ptr-&gt;i = ...;
</code></pre>

<p>Here the <code>void*</code> points at the actual data which is allocated elsewhere. You will also need some means to keep track of which kind of data that is stored there.</p>
",0
41187112,41185910,0,"<p>It's ugly but it work.</p>

<pre><code>#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;

enum Type {
  A,
  B,
};

struct Base {
  enum Type type;
};

struct A {
  char foo[4];
};

struct B {
  char bar[8];
};

struct BaseA {
  struct Base base;
  struct A a;
};

struct BaseB {
  struct Base base;
  struct B b;
};

int main(void) {
  int fd = open(""foo.bar"", O_RDONLY);
  if (fd == -1) {
    return 1;
  }

  union {
    struct Base base;
    struct BaseA base_a;
    struct BaseB base_b;
  } buffer;
  if (read(fd, &amp;buffer.base, sizeof buffer.base) != sizeof buffer.base) {
    return 1;
  }

  if (buffer.base.type == A) {
    if (read(fd, &amp;buffer.base_a.a, sizeof buffer.base_a.a) !=
        sizeof buffer.base_a.a) {
      return 1;
    }
  } else if (buffer.base.type == B) {
    if (read(fd, &amp;buffer.base_b.b, sizeof buffer.base_b.b) !=
        sizeof buffer.base_b.b) {
      return 1;
    }
  } else {
    return 1;
  }
}
</code></pre>

<p>You could do what you want in if statement. Add every <code>Base_A</code> in an array, and all <code>Base_B</code> in another one.</p>

<p>If you don't want padding use something like <code>#pragma pack(n)</code>.</p>
",1
47469091,47469026,1,"<p><code>char</code>, <code>signed char</code>, and <code>unsigned char</code> are all distinct types.</p>

<p>Your implementation can set <code>char</code> to be either <code>signed</code> or <code>unsigned</code>.</p>

<p><code>unsigned char</code> has a distinct range set by the standard. The problem with using simply <code>char</code> is that your code can behave differently on different platforms. It could even be a 1's complement or signed magnitude type with a range -127 to +127.</p>
",0
47469163,47469026,0,"<p>From <a href=""http://en.cppreference.com/w/c/language/arithmetic_types#Character_types"" rel=""nofollow noreferrer"">CppReference</a>:</p>

<blockquote>
  <h3>Character types</h3>
  
  <ul>
  <li><code>signed char</code> - type for signed character representation.</li>
  <li><code>unsigned char</code> - type for unsigned character representation. Also used to inspect object representations (raw memory).</li>
  <li><code>char</code> - type for character representation. Equivalent to either <code>signed char</code> or <code>unsigned char</code> (which one is <strong>implementation-defined</strong> and may be controlled by a compiler commandline switch), but <strong><code>char</code> is a distinct type</strong>, different from both <code>signed char</code> and <code>unsigned char</code>.</li>
  </ul>
</blockquote>

<p>So if you want to ensure that you're using either an <code>unsigned char</code> or a <code>signed char</code>, <strong>specify it explicitly</strong>. Otherwise there'd be no guarantee whether it'll be signed or not.</p>
",1
47469180,47469026,1,"<p>Because no-one in the candidate duplicate answer cited the right paragraph from the spec:</p>
<blockquote>
<p><strong>6.2.5 [Types], paragraph 15</strong></p>
<p>The three types char, signed char, and unsigned char are collectively called the character types. The implementation shall define char to have the same range, representation, and behavior as either signed char or unsigned char</p>
</blockquote>
<p>So char could be either. (FWIW, I believe I ran into char = unsigned char in JNI.)</p>
",3
36757306,36725987,1,"<p>I needed to include a newline command in my fscanf call. </p>

<pre><code>while(fscanf(file, ""%c,%d,%d\n"", &amp;office, &amp;x, &amp;y) &gt; 0)
</code></pre>
",0
36294067,36293997,2,"<p>You're not returning anything when you perform the recursive calls. So it will only return <code>1</code> if the item is found at the root of the tree.</p>

<p>Also, you don't return anything when you reach the bottom of the tree without finding anyhthing, this needs to return <code>0</code> to indicate failure.</p>

<pre><code>int isElementInBinaryTree(BinaryTreeNode *root, int search_item) {
    if(root) {
        if(search_item == root -&gt; data) {
            return 1;
        }
        return isElementInBinaryTree(root -&gt; left, search_item) || 
               isElementInBinaryTree(root -&gt; right, search_item);
    } else {
        return 0;
    }
}
</code></pre>
",2
36294078,36293997,3,"<p>Your code doesn't actually return anything when it recurses, so the 'return value' is typically whatever is left over in the register used for that purpose.</p>

<p>This code</p>

<pre><code>if(root) {
        if(search_item == root -&gt; data) return 1;
        isElementInBinaryTree(root -&gt; left, search_item);
        isElementInBinaryTree(root -&gt; right, search_item);
    }
</code></pre>

<p>needs to look more like this</p>

<pre><code>if(root) 
{
    if(search_item == root -&gt; data) return 1;

    if (isElementInBinaryTree(root -&gt; left, search_item)) return 1;
    return isElementInBinaryTree(root -&gt; right, search_item);
}
return 0;
</code></pre>

<p>The final <code>return 0;</code> ensures you return something sensible when a NULL pointer is provided.</p>

<p>When you compile your code it should be displaying warnings about a typed function terminating without a return statement. You need to pay attention to those warnings and resolve them all.</p>

<p>The whole thing can actually be reduced to a single (though less clear) line of code</p>

<pre><code>return root &amp;&amp; ((search_item == root-&gt;data) ||
                isElementInBinaryTree(root-&gt;left, search_item) ||
                isElementInBinaryTree(root-&gt;right, search_item));
</code></pre>

<p>which relies on shortcut evaluation to only go so far as needed.</p>
",1
40963652,40963553,2,"<p>As it is somewhat difficult to determine which iteration of the loop is the last one, one could put the comma <em>before</em> the output instead of <em>after</em> the output and omit the first comma as follows, where the comments are deleted for brevity.</p>

<pre><code>int isFistIteraion = 0;
for(i = 2; i &lt;= N; i++)
{
    isPrime = 0;
    for(j = 2; j &lt;= i/2; j++){
        if(i % j == 0){
          isPrime = 1;
          break;
        }
    }
    if(IsPrime == 0 &amp;&amp; N != 1){
        if (0 == isFirstIteration){
            isFirstIteraion = 1;
            printf(""%d"", i);
        } else {
            printf("", %d"", i);
        }
    }
}
</code></pre>
",0
35258067,35257724,6,"<p>You can test if an ASCII letter <code>c</code> is upper case by checking its <code>0x20</code> bit, it must be <code>0</code> for uppercase and <code>1</code> for lowercase:</p>

<pre><code>if (!(c &amp; 0x20))
    printf(""ASCII letter %c is uppercase\n"", c);
</code></pre>

<p>but be aware that this test does not work if you don't already know that <code>c</code> is a letter.  It would erroneously match <code>'@'</code> and <code>'['</code>, <code>'\\'</code>, <code>']'</code>, <code>'^'</code> and <code>'_'</code>, and the whole range of characters with the high bit set from 192 to 223, which are not part of ASCII but are valid <code>unsigned char</code> values.</p>

<p>If you want a single test to verify if <code>c</code> is an uppercase ASCII letter, try:</p>

<pre><code>if ((unsigned)(c - 'A') &lt;= (unsigned)('Z' - 'A'))
     printf(""%c is an uppercase ASCII letter\n"", c);
</code></pre>

<p><strong>EDIT:</strong> it is unclear what you mean by <em>I am not allowed to use if statements, or any kind of type casting operations. I must test to see if the number is between the two numbers, including numbers far outside the range of the ASCII code, and return 1 if it is or else 0</em>.</p>

<ul>
<li>If you know <code>c</code> is a letter, both <code>!(c &amp; 0x20)</code> and <code>(((c &gt;&gt; 5) &amp; 1) ^ 1)</code> will have value <code>1</code> if <code>c</code> is uppercase and <code>0</code> if not.</li>
<li>If <code>c</code> can be any integer value, just write the regular comparison <code>(c &gt;= 'A' &amp;&amp; c &lt;= 'Z')</code> and the compiler will produce better code than you would by attempting hazardous bit-twiddling tricks.</li>
</ul>

<p><strong>EDIT again</strong>:</p>

<p>Since <code>c</code> can be any integer value and you are only allowed bit manipulations, here is another solution: <code>!((c &gt;&gt; 5) ^ 2) &amp; (0x07fffffeU &gt;&gt; (c &amp; 31))</code>.  Below is a program to test this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

static int uppertest(int c) {
    return !((c &gt;&gt; 5) ^ 2) &amp; (0x07fffffeU &gt;&gt; (c &amp; 31));
}

int main(int argc, char *argv[]) {
    for (int i = 1; i &lt; argc; i++) {
        int c = strtol(argv[i], NULL, 0);
        printf(""uppertest(%d) -&gt; %d\n"", c, uppertest(c));
    }
    return 0;
}
</code></pre>
",11
35258867,35257724,1,"<blockquote>
  <p>...  to see if a letter is uppercase</p>
</blockquote>

<p>Simplification:
Let us assume ranges [A-Z] and [a-z] <code>char</code> differ by the same value which is a power of 2.  So <code>'B'-'b'</code>  equals <code>'X'-'x'</code>, etc.</p>

<pre><code>#define CASE_MASK ('A' ^ 'a')

// Is letter uppercase?
int is_letter_upper(int ch) {
   return (ch &amp; CASE_MASK) == ('A' &amp; CASE_MASK);
}

// Is letter lowercase?
int is_letter_lower(int ch) {
   return (ch &amp; CASE_MASK) == ('a' &amp; CASE_MASK);
}
</code></pre>

<p>This works for <a href=""https://en.wikipedia.org/wiki/ASCII"" rel=""nofollow"">ASCII</a> and <a href=""https://en.wikipedia.org/wiki/EBCDIC"" rel=""nofollow"">EBCIDIC</a></p>

<p>A more ""bit manipulation"" answer</p>

<pre><code>int is_letter_upperBM(int ch) {
   return !((ch &amp; CASE_MASK) ^ ('A' &amp; CASE_MASK));
}
</code></pre>
",7
35259300,35257724,0,"<p>Since OP is stuck on case <code>0x7fffffff</code>, exclude it by extending the otherwise working solution. </p>

<pre><code>!((~(((x &amp; 32)&gt;&gt;5))&lt;&lt;31))&gt;&gt;31) &amp; !(x ^ 0x7fffffff)
</code></pre>

<p>Pedantically, just code as below and let the compiler simplify.</p>

<pre><code>isupper = (!(x ^ 'A')) | (!(x ^ 'B')) | (!(x ^ 'C')) ... (!(x ^ 'Z'));
</code></pre>
",0
35275536,35257724,0,"<p>You could use <em>unsigned</em> integer division, if that's allowed:</p>

<pre><code>!((x-0x41)/26)
</code></pre>

<p>But that's probably not in the spirit of the original question.  Consider what happens when you subtract 0x3B from any upper case letter:</p>

<pre><code>A: 0x41 - 0x3B = 0x06
Z: 0x5A - 0x3B = 0x1F
</code></pre>

<p>The interesting feature here is that any value initially larger than 0x5A will have one of the high bits set (~0x1F).  You can perform the same shifting for moving 'A' down to zero, so anything initially less than 'A' would have the high bits set.  In the end a solution requires only subtractions, an or, and some bit-wise ands:</p>

<pre><code>!(((x-0x3B) &amp; ~(0x1F)) || ((x-0x41) &amp; ~(0x1F)))
</code></pre>

<p>I believe that does what you want.  Given the nature of conditional (short circuit) evaluation in C, this has an implicit conditional embedded in it though.  If you want to remove that, minimize the computation, and maximize the obscurity you could do this:</p>

<pre><code>!(((x-0x3B) | (x-0x41)) &amp; ~(0x1F))
</code></pre>

<p>or my new personal favorite:</p>

<pre><code>!((('Z'-x) | (x-'A')) &amp; ~(0x1F))
</code></pre>
",1
38304771,38304682,1,"<pre><code>for(i=1;i&lt;num;i++) 
</code></pre>

<p>instead of</p>

<pre><code>for(i=1,i&lt;num;i++)
</code></pre>
",1
38305377,38304682,2,"<p>Your loops are identical (unless I missed something) apart from the initial value of <code>i</code>.  You may merge them:</p>

<pre><code>int initi;

if (clock_mhz == 80)
    initi = 1;
else
    initi = 0;

for (i = initi; i &lt; num; ++i) {
    /* loop as before */
}
</code></pre>
",0
37403473,37403357,2,"<p>You are invoking <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behavior</a>.  You have made use of <a href=""https://stackoverflow.com/questions/4176328/undefined-behavior-and-sequence-points"">sequence points</a>, usage of which is undefined in C.</p>

<p>You say it <em>seems to print the results expected</em> - it <em>may</em> or it <em>may not</em>, because it is undefined.  So the fact that you get the expected values is just pure luck.</p>

<p>As for getting some warnings, please compile and run the code; it will indeed give you a warning:</p>

<blockquote>
  <p>warning: operation on 'i' may be undefined [-Wsequence-point]</p>
</blockquote>

<p>Live demo <a href=""http://cpp.sh/275o"" rel=""nofollow noreferrer""><strong>here</strong></a>.</p>

<p>Besides, if you are thinking why it is just a <em>warning</em> and not an <em>error</em>, then please note that the compiler is in no way bound to report all of your undefined behaviors - its job is just to compile your code, not to point out your undefined behavior.</p>
",2
37403508,37403357,1,"<p>Depending on the evaluation order, the first time execution of</p>

<pre><code>     arr[i++] = i;
</code></pre>

<p>could end up setting <code>arr[1]</code> to <code>1</code> (if the LHS is evaluated first) or to <code>0</code> (if the RHS is evaluated first). If they are executed in parallel, the result could be anything.</p>

<p>We cannot guarantee the state of the program after that line. Don't use it.</p>
",0
37404334,37403357,1,"<p>""It works as expected"" is one of the possible outcomes for undefined behavior.</p>

<p><code>arr[i++] = i;</code> is <em>explicitly</em> called out as an example of undefined behavior in the language standard.  The order in which each subexpression is evaluated is unspecified; it's not guaranteed to be left-to-right.  For <code>i == 1</code>, <em>any</em> of the following results are possible:</p>

<pre><code>arr[1] = 1;
arr[1] = 2; 
arr[2] = 2; 
arr[2] = 1;
</code></pre>
",0
38858208,38858159,2,"<p>Lets look at these two lines:</p>

<pre><code>char name[21],filename[21],cpf[16];
...
for ( ;strlen(name)&lt;3; ) {
</code></pre>

<p>First you declare the array <code>name</code> (and some others), but you don't initialize it. Then you use the uninitialized in a call to <code>strlen</code>. That will lead to <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow""><em>undefined behavior</em></a> because the contents of <code>name</code> is <em>indeterminate</em>.</p>

<p>You must explicitly initialize the array, or any other local variables, before you use it.</p>

<p>Simplest way is doing something like</p>

<pre><code>char name[21] = """", ...;
</code></pre>

<hr>

<p>As for why the code behaves differently in different situation is because of the <em>undefined behavior</em>. Undefined behavior is, by its very definition, <em>undefined</em>. It means just about anything can happen, even to <em>seemingly</em> work fine. It could also crash or cause <a href=""http://www.catb.org/jargon/html/N/nasal-demons.html"" rel=""nofollow"">nasal demons</a>.</p>
",1
38858213,38858159,1,"<p>You've left <code>name</code> unitialized, so <code>strlen(name)</code> is undefined behavior and seems to return <code>false</code>. To avoid this, try changing your <code>for</code> loop to a <code>do while</code> loop, which will always run once before checking the condition. This could look like:</p>

<pre><code>do {
    //loop body that initializes name
} while (strlen(name) &lt; 3);
</code></pre>
",0
37452614,37452532,4,"<p>They are the same. By the De Morgan's law the negation of disjunction is the conjuction of the negation.</p>

<p>So (not A) or (not B) is the same of not (A and B). If you say that A is i &lt; 8 and B is i >= 0 you have the answer .</p>
",0
37452630,37452532,0,"<p>In this case they are the same, but the first statement might evaluate only the first part, so in the future make sure you know what you're doing making swaps like this.</p>
",4
42492661,42492602,0,"<p>Look at this:</p>

<p>Predict the output of following C program.</p>

<pre><code>#include&lt;stdio.h&gt;
int main()
{
    float x = 0.1;
    if (x == 0.1)
        printf(""IF"");
    else if (x == 0.1f)
        printf(""ELSE IF"");
    else
        printf(""ELSE"");
}
The output of above program is ¡°ELSE IF¡± which means the expression ¡°x == 0.1¡± returns false and expression ¡°x == 0.1f¡± returns true.
</code></pre>

<p>Taken from <a href=""http://www.geeksforgeeks.org/comparison-float-value-c/"" rel=""nofollow noreferrer"">here</a></p>
",0
46627279,46627080,0,"<p>It is important to know more about the C source-code of the OP, such as where and how the variable result is declared. If there is a problem with how <strong>result</strong> is declared, then that might well  be the reason that the code is behaving in such an odd fashion. </p>

<p>In a subsequent comment, the OP explained:</p>

<blockquote>
  <p>There was a problem with how I declared the result. It is working now.</p>
</blockquote>
",0
40528342,40528106,1,"<p>To answer your second question: 
variable=0;
variable=variable^0x800000;</p>

<p>This operation is a bitwise operation called XOR. 
An XOR operation is usually used to toggle bits regardless of it's previous state:
<code>
0 ^ 1 = 1
1 ^ 1 = 0</code></p>
",0
40528240,40528106,2,"<p><code>while(variable);</code> implements a <em>spin-lock</em>; i.e. this thread will remain at this statement until <code>variable</code> is 0. I've introduced the term to help you search for a good technique in your new language.</p>

<p>It obviously burns the CPU, but can be quite an efficient way of doing this if only used for a few clock cycles. For it to work well, <code>variable</code> needs to be qualified with <code>volatile</code>.</p>

<p><code>variable = variable ^ 0x800000;</code> is an XOR operation, actually a single bit toggle in this case. (I would have preferred to see <code>variable ^= 0x800000</code> in multi-threaded code.)  Its exact use is probably explainable from its context. Note that the arguments of the XOR are promoted to <code>int</code> if they are smaller than that. It's doubtful that <code>variable^0x800000</code> is a 24 bit type <em>unless</em> <code>int</code> is that size on your platform (unlikely but possible).</p>
",0
40528241,40528106,2,"<blockquote>
  <p>I am trying to translate a C program. </p>
</blockquote>

<p><strong>Don't translate a <em>C</em> program</strong>, unless you are writing a <a href=""https://en.wikipedia.org/wiki/Compiler"" rel=""nofollow noreferrer"">compiler</a> (sometimes called a transpiler - or <a href=""https://en.wikipedia.org/wiki/Source-to-source_compiler"" rel=""nofollow noreferrer"">source to source compiler</a> -, if translating to some other programming language different of assembler) which would do such task. And you'll need a lot of work (at least several months for a naive compiler ¨¤ la <a href=""https://en.wikipedia.org/wiki/Tiny_C_Compiler"" rel=""nofollow noreferrer"">TinyCC</a>, and more probably many dozens of years)</p>

<p><strong>Think in <em>C</em></strong> and try to understand its <a href=""https://en.wikipedia.org/wiki/Semantics_%28computer_science%29"" rel=""nofollow noreferrer""><em>semantics</em></a> (much more important than its <em>syntax</em>).</p>

<blockquote>
  <p><code>while(variable);</code></p>
</blockquote>

<p>that loop has an empty body. It is more readable to make that empty body apparent (semantics remain the same): </p>

<pre><code> while(variable) {};
</code></pre>

<p>Since the body (and the test) of the loop don't change <code>variable</code> (it has no <em>observable</em> <a href=""https://en.wikipedia.org/wiki/Side_effect_%28computer_science%29"" rel=""nofollow noreferrer"">side-effect</a>) the loop will run indefinitely as soon as the initial value of <code>variable</code> is non-zero. This will heat your processor.</p>

<p>But you might have declared that <code>variable</code> as <a href=""https://en.wikipedia.org/wiki/Volatile_%28computer_programming%29"" rel=""nofollow noreferrer""><em>volatile</em></a> and then have something external changing it.</p>

<blockquote>
  <p><code>variable=variable^0x800000;</code></p>
</blockquote>

<p>The <code>^</code> is a <a href=""https://en.wikipedia.org/wiki/Bitwise_operation#XOR"" rel=""nofollow noreferrer"">bitwise XOR</a>. You are toggling (replacing 0 with 1 and 1 with 0) a single bit (the 23<sup>rd</sup> one, IIRC)</p>
",1
34955952,34955900,3,"<p>This</p>

<pre><code>int n = atoi(&amp;c);
</code></pre>

<p>is undefined behavior.</p>

<p>The <code>atoi()</code> function takes a <code>char *</code> pointer pointing to a string, AKA a sequence of non-<code>nul</code> bytes followed by a <code>nul</code> byte.</p>

<p>You are passing a pointer to a single <code>char</code>, then <code>atoi()</code> increments the pointer trying to find the terminating <code>'\0'</code> but dereferencing the incremented pointer is undefined behavior because the pointer does not point to an array.</p>

<p>When there is undefined behavior in your code, it doesn't matter what other behavior you observe because it might very well be caused by the <em>undefined behavior</em> problem.</p>

<p>To convert a single <code>char</code> to <code>int</code> you just need to subtract the ascii value of <code>0</code> from the ascii value of the digit like this</p>

<pre><code>int n = c - '0';
</code></pre>

<p>but that doesn't guarantee that <code>n</code> is the value you expect, for that you need to check with <code>isdigit(c)</code> before attempting to use <code>c</code> as if it were a digit.</p>

<p>Also: The type of <code>c</code> is wrong, it should be <code>int</code> since <code>getchar()</code> returns <code>int</code> and you don't want the value to be truncated.</p>
",0
38194328,38191630,1,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int ** generate(int A, int *number_of_cols) {
    int **result = malloc(A * sizeof(int *));
    int nc;//number of columns

    for(int i = 0; i &lt; A; ++i){
        number_of_cols[i] = nc = i + 1;
        result[i] = malloc(nc * sizeof(int));
        result[i][0] = result[i][nc-1] = 1;
        if(i &gt; 1)
            for(int j = 1; j &lt; nc -1; ++j){
                result[i][j] = result[i-1][j-1] + result[i-1][j];
            }
    }
    return result;
}
int main(void){
    int n;
    scanf(""%d"", &amp;n);

    int *number_of_cols = malloc(n * sizeof(int));
    int **pascal_triangle = generate(n, number_of_cols);

    for(int i = 0; i &lt; n; ++i){
        printf(""%*s"", 2 * (n-i-1), """");
        for(int j = 0; j &lt; number_of_cols[i]; ++j){
            printf(""%4d"", pascal_triangle[i][j]);
        }
        puts("""");
        free(pascal_triangle[i]);
    }
    free(pascal_triangle);
    free(number_of_cols);

    return 0;
}
</code></pre>
",0
38194331,38191630,1,"<p>I can't understand the purpose of passing the <strong>*number_of_row</strong> just to assign it the other parameter address. However, I'd split your main <strong>for</strong> loop in 2:
one to allocate all memory and another to fill it.</p>

<pre><code>for(i=0;i&lt;A;i++)
  result[i]=(int)malloc((i+1)*sizeof(int));

result[0][0]=1; //in your code, result[i-1] was accessed with i=0
for(i=1;i&lt;A;i++) {
  result[i][0] = i+1;
  result[i][1] = 1;
  for(j=2;j&lt;i;j++)
    result[i][j] = result[i-1][j] + result[i-1][j-1]; //when j reaches the last value, 
                       //[i-1][j] won't work! So put j&lt;i instead.
  result[i][j] = 1;
}
</code></pre>

<p>The rest of code was OK, check if this is what you wanted. The resulting triangle shoud be:</p>

<pre><code>1
2   1
3   1  1
4   1  2  1
5   1  3  3  1
6   1  4  6  4  1 etc.
</code></pre>
",0
43184940,27364279,0,"<blockquote>
  <p>the problem is that when call insert_nodo(), the pointer is lost and
  the root of the tree is null.</p>
</blockquote>

<p>That's because you pass the root of the tree <em>by value</em> to <code>insert_nodo()</code>, hence it can't be altered, as BLUEPIXY hinted at with the comment</p>

<blockquote>
  <p>2) <code>pnodo = ini_nodo();</code> : no effect. because
  <code>pnode</code> is local variabel.</p>
</blockquote>

<p>You'd have to make the following changes:</p>

<pre><code>    ob = insert_nodo(key, &amp;pdicc-&gt;tree);    // pass tree by address
¡­
int insert_nodo(int key, PNODO *ppnodo) {
    int ob = 0;
    if (!*ppnodo) {
        *ppnodo = ini_nodo();
        (*ppnodo)-&gt;info = key;
        return ob;
    }
    ob += 1;
    if (key == (*ppnodo)-&gt;info) {
        return ERR;
    }
    else if (key &lt; (*ppnodo)-&gt;info)
        ob += insert_nodo(key, &amp;(*ppnodo)-&gt;l);
    else
        ob += insert_nodo(key, &amp;(*ppnodo)-&gt;r);
    return ob;
}
</code></pre>
",0
46975789,46975697,2,"<p>There is absolutely no reason why you can't do this in 2 lines of code like you already do. It is clear and readable.</p>

<p>If you <em>must</em> complicate things for the sake of it, you can write a <em>compound literal</em>:</p>

<pre><code>int* p = (int[]){1,2,3};
</code></pre>

<p>This will yield exactly the same machine code as the code you already have, so no version is better than the other. </p>
",3
35268157,35268083,3,"<p>You cannot init with <code>malloc</code> a global variable.</p>

<p>You must write, eg:</p>

<pre><code>EventHandler *keyFuncArray;

int main ()
{
    keyFuncArray = malloc(sizeof(EventHandler) * kpSize)

   // STUFF:..

   return 0;
}
</code></pre>

<p>Take a look also to: <a href=""https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc"">Do I cast malloc return?</a></p>
",0
35268382,35268083,2,"<p>You can only do declarations in the global scope. So a function call can't execute in the global scope. As <code>malloc()</code> is also a function call, it couldn't execute.</p>

<p>So you can declare the global pointer variable and initialize it in any of your functions (not restricted to <code>main</code> only). Since the pointer is global it is available globally after initialization to any of your functions.</p>
",0
34891167,34891065,2,"<p>In that case you want:</p>

<pre><code>void sum ( int * x, int y ) {
     if (x != NULL) *x += y;
}
  ...
sum(&amp;x, y);
</code></pre>

<p>Saying <code>int * y</code> says you need to pass the address of an int variable. The <code>&amp;</code> character is the <code>address-of</code> operator. </p>

<p>In the function <code>*y</code> says use the value at the address, not the address itself.</p>

<p>The <code>if (x != NULL)</code> check is because, without it doing:</p>

<pre><code>sum(NULL, x);
</code></pre>

<p>is ""undefined behavior"" (think Allstate ""Mayhem"" commercial) :)</p>
",2
34891104,34891065,3,"<p>This should work:</p>

<pre><code>void sum(int *x, int y){
    *x += y; // *x means ""contents of what is pointed to by pointer x""
}

void call_sum() {
    int x = 1, y = 2;

    sum(&amp;x,y); // &amp;x because you're passing the address

    printf(""%d\n"", x); // this should print 3
}
</code></pre>
",2
34904781,34904730,2,"<p>You missed a closing braces for <code>for</code> loop in the function <code>arraycpy</code></p>

<pre><code>void arraycpy(int *dest, int *src, int n)
{
    int i;
    int *src_p, *dst_p;

    src_p = (int*)src;
    dst_p = (int*)dest;

    for (i = 0; i &lt; n; i++) {
        *(dst_p+i) = *(src_p+i);
    }
 // ^^^
}
</code></pre>

<p>So, the next braces is being taken as the braces for the <code>for</code> loop, and thus when you define the next function, it is being defined inside the next function <code>arraycpy</code></p>
",4
41196573,41196422,1,"<p>In the two-dimensional array as:</p>
<p>X coordinate = ((p1-1)¨G3)*3 + (p2-1)¨G3;</p>
<p>Y coordinate = ((p1-1)/3)*3 + (p2-1)/3;</p>
",2
41196951,41196422,1,"<p>Here is a function that takes an array of two <code>size_t</code> values to store the indices of the cell, and the two position arguments given by the user. It finds the indices for the given positions in a zero-indexed 3X3 array, and then combines these results to produce the indices in the 9X9 array.</p>

<p>I put it in a little program to test a couple of inputs:</p>

<pre><code>#include &lt;stdio.h&gt;

void get_index(size_t indices[2], int pos, int sub_board);

int main(void)
{
    size_t indices[2];
    int pos, sub_board;

    pos = 2;
    sub_board = 2;

    get_index(indices, pos, sub_board);

    printf(""Cell indices are: [%zu][%zu]\n"", indices[0], indices[1]);

    pos = 6;
    sub_board = 9;

    get_index(indices, pos, sub_board);

    printf(""Cell indices are: [%zu][%zu]\n"", indices[0], indices[1]);    

    return 0;
}

void get_index(size_t indices[2], int pos, int sub_board)
{
    size_t row_pos, col_pos;
    size_t row_sub, col_sub;

    row_pos = (pos - 1) / 3;
    col_pos = (pos - 1) % 3;
    row_sub = (sub_board - 1) / 3;
    col_sub = (sub_board - 1) % 3;

    indices[0] = 3 * row_sub + row_pos;    
    indices[1] = 3 * col_sub + col_pos;

}
</code></pre>

<p>Output:</p>

<pre><code>Cell indices are: [0][4]
Cell indices are: [7][8]
</code></pre>
",0
46627185,28718332,0,"<p>From my understanding, <code>adjtime</code> is a Linux-ism which likely crawled its way into the BSD world via FreeBSD. It's certainly not documented by any of the C or POSIX standards.</p>

<p>Even those which are documented by the C and POSIX standards often aren't implemented correctly in the Microsoft world, so it wouldn't surprise me that this function doesn't exist.</p>

<p>I'm very interested to hear more about this project of yours. Though a simplistic wrapper of some implementation-defined stuff can be written for the purposes of portability, I can only imagine highly niche usecases, for which there are better alternatives:</p>

<ul>
<li>If you need something with a large amount of good, secure entropy to seed your pseudo-random number generator, you should use something provided by a cryptographic library.</li>
<li>If you want to conduct performance tests, you should learn how to use the profiler rather than rolling your own profiling code. Also, every ""performance test"" should be conducted as though through the eyes of a scientist observing the very first time; it's generally best not to let tests from previous projects guide optimisation for future projects. Instead, let the profile of the current project guide optimisation for the current project (on the current hardware), and you'll be cheering before you know it!</li>
</ul>
",0
42499908,42499762,0,"<p>127.0.0.1 is a local IP address (assigned to loopback interface see below IP for <strong>lo0</strong> interface). Its good for communicating across difference process acting in client server roles on the same host/system.</p>

<p>What you need is the assigned IP of the primary interface (like eth0/ en0 etc.) on your server system. On a MAC this looks as below</p>

<pre><code>#ifconfig -au
lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 16384
    ..
    inet 127.0.0.1 netmask 0xff000000 
    nd6 options=1&lt;PERFORMNUD&gt;
en0: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
    ..
    inet 192.168.1.2 netmask 0xffffff00 broadcast 192.168.1.255
    nd6 options=1&lt;PERFORMNUD&gt;
    media: autoselect
    status: active
</code></pre>

<p>In the above output I'd use the IP address on <strong>en0</strong> which is 192.168.1.2 (for  server to bind) and then the clients can connect to that IP over the network.</p>
",6
41195195,41195141,0,"<p>To concatenate char and string (first char, then string) do:</p>

<pre><code>const char* conc_char_string(const char ch, const char* str, int len) {
    const char* out = malloc(len + 2); /* 1 char from ch, len chars from str, and zero character, totally len+2 */
    out[0] = ch; /* copy the character */
    strcpy(out+1, str); /* copy the string */
    return out;
}
</code></pre>

<p>Here <code>len</code> should be <code>strlen(str)</code></p>
",1
41195780,41195141,0,"<p>The statement <code>str_mid = """";</code> assigns the address of costant string <code>""""</code> to pointer <code>str_mid</code>, which will cause <strong>segmentfault</strong> later. Use <code>str_mid[0] = '\0';</code> instead.</p>

<p>In statement <code>ch = str3[i - 1];</code>, you are assigning <code>char</code> to <code>char pointer</code>, which will cause <strong>segmentfault</strong>.</p>

<p>If all you want is simply appending a character to the string, you can keep track of length of string, like this:</p>

<pre><code>len_mid = strlen(str_mid);
for (i = 1; i &lt; len3 + 1; i++)
{
  for (j = 1; j &lt; len2 + 1; j++)
     if (lcs1[i][j])
     {

        str_mid[len_mid++] = str3[i - 1];
        str_mid[len_mid] = '\0';
        break;
     }
}
</code></pre>
",9
41197299,41195141,3,"<p>So long as <code>MAX_SIZE</code> is large enough that <code>str_mid</code> will be able to hold the extra character, you can use <code>strcat()</code> and a compound literal (for C99 or later):</p>

<pre><code>strcat(str_mid, (char[2]){ str3[i - 1], '\0' });
</code></pre>

<p>Note that in your code, <code>str3[i - 1]</code> is a <code>char</code>, while you have declared <code>ch</code> as a pointer to <code>char</code>.</p>
",4
41197677,41195141,-1,"<p>First rule of the C-club, create your own string buffer, second rule of the C-club create your own string buffer.
Each programmer has it's own string buffer. Minimal requirement is :</p>

<pre><code> #define STRINGSTRTSZ 256
 typedef struct string
 {
     char *str;
     size_t n;
     size_t buf_sz;

  }String,*pString;

  pString new_string()
  {
      pString res;
      res=malloc(sizeof(String)); ///i leave to you the error handling
      res-&gt;bus_sz=STRINGSTRSZ;
      res-&gt;n=0;
      res-&gt;str=malloc(res-&gt;bus_sz); 
  }
  char*concatbase(pString *string,char*s,size_t len)
  {
      if(len+1&gt;=string-&gt;buf_sz-string-&gt;n)
      {
           res-&gt;buf_sz+=len+res-&gt;buf_sz; 
           char *tmp=realloc(string-&gt;str,res-&gt;buf_sz);
            if(tmp)
               string-&gt;str=tmp;
            else
              ...
      }
     memcpy(string-&gt;str+string-&gt;n,s,len);
     string-&gt;n+=len;
     *(string-&gt;str+string-&gt;n)='\0';
     return string-&gt;str;  
  }

  #define concatNllPtr(string,nllptr) concatbase(string,nllptr,strlen(nllptr))
  #define concatString(string,str2) concatbase(string,(str2)-&gt;str,(str2)-&gt;n)
</code></pre>

<p>End so on...</p>
",5
41197686,41195141,1,"<blockquote>
  <p>How to concatenate char and string </p>
</blockquote>

<p>There is <em>no</em> need to call any library function at all, nor to dynamically allocate any memory.</p>

<p>Assuming <code>str_mid</code> is large enough just do:</p>

<pre><code>{
  size_t tmp_len = strlen(str_mid);
  str_mid[tmp_len] = str3[i - 1];
  str_mid[tmp_len + 1] = '\0';
}
</code></pre>

<hr>

<p>To still have the feeling to use a function you might want to wrap the above code into a macro like this:</p>

<pre><code>#define STRCATCHAR(s, c) \
do { \
  assert(s != NULL); \
  size_t tmp_len = strlen(s); \
  (s)[tmp_len] = (c); \
  (s)[tmp_len + 1] = '\0'; \
} while (0)
</code></pre>

<p>and use it like this:</p>

<pre><code>STRCATCHAR(str_mid, str3[i - 1]);
</code></pre>
",0
37692594,37691588,2,"<p><strong>Remove All Blank Lines &amp; Compressing All Tab &amp; Spaces to 1 Space</strong></p>

<p>The biggest problem you have is if you encounter a <code>' '</code> or a <code>'\n'</code> where you need to replace multiple occurrences of either with a smaller number, you need to keep reading (at that point within your outer <code>while</code> loop) until you find a character that is not a <code>' '</code> or a <code>'\n'</code>. That simplifies keeping track of your counts. (and eliminates the need for <code>spacecount</code> and <code>newlinecount</code>)</p>

<p>Since you are testing against multiple characters, when you find the first character that does not match your current search character, simply put it back in <code>stdin</code> and move to the next iteration of your outer while loop.</p>

<p>When compressing all <code>tabs</code> and <code>spaces</code> to a single <code>space</code>, you need to test for either a <code>tab</code> or <code>space</code> in a single <code>if</code> statement.</p>

<p>Putting that together, you can do:</p>

<pre><code>#include &lt;stdio.h&gt;

int main (void) {

    int c;

    while ((c = getchar ()) != EOF)
    {
        if (c == '\r') continue;
        if (c == '\n') {        /* handle newlines/carriage-returns */
            putchar (c);
            while ((c = getchar ()) == '\n' || c == '\r') {}
            if (c != EOF) ungetc (c, stdin); else break;
            continue;
        }
        if (c == ' ' || c == '\t') {  /* spaces &amp; tabs */
            putchar (' ');
            while ((c = getchar ()) == ' ' || c == '\t') {}
            if (c != EOF) ungetc (c, stdin); else break;
            continue;
        }
        putchar (c);
    }
    return 0;
}
</code></pre>

<p>(<strong>note:</strong> the code was updated to handle DOS/windoze <code>\r\n</code> line endings as well as Linux <code>'\n'</code>)</p>

<p><strong>Example Input</strong></p>

<pre><code>$ cat dat/gcfmt.txt

N &lt;tab&gt; description
21      grapes
18      pickles



N &lt;spaces&gt; description
23         apples
51         banannas



&lt;spaces&gt;N&lt;tab&gt;  description
        8       cherries
        4       mellons
        6       strawberries


that's  all     folks   &lt;tab separated&gt;

that's  all     folks   &lt;space separated&gt;
</code></pre>

<p><strong>Exampe Use/Output</strong></p>

<p>Using the same input file, the output is now:</p>

<pre><code>$ ./bin/gcfmt1 &lt;dat/gcfmt.txt
N &lt;tab&gt; description
21 grapes
18 pickles
N &lt;spaces&gt; description
23 apples
51 banannas
&lt;spaces&gt;N&lt;tab&gt; description
 8 cherries
 4 mellons
 6 strawberries
that's all folks &lt;tab separated&gt;
that's all folks &lt;space separated&gt;
</code></pre>

<p>Let me know if that is what you intended.</p>
",7
36233214,36233202,2,"<p>You are not declaring the function <code>MeanInt</code> before its first invocation so compiler assumes the type of <code>MeanInt</code> is a function returning <code>int</code> taking any number of arguments.</p>

<p><strong>Fix</strong><BR>Include appropriate header file (containing the declaration), or move the definition above usage or declare it before usage as:</p>

<pre><code>float MeanInt(int x[],int num);
</code></pre>

<p>You can declare it at global scope at the top of the file or in narrower scope also.</p>
",1
47542697,47542472,0,"<p>If you want an approach that uses just pointer arithmetic (without any indexing):</p>

<pre><code>printf(""%c\n"", *(*a+1));     //3
printf(""%c\n"", *(*(a+1)+1)); //4
</code></pre>

<p>Explanation:</p>

<ul>
<li><code>a</code> is an array of 3 <code>char</code> pointers.</li>
<li><code>*a</code> is the first <code>char</code> pointer in the array, and it points to the first <code>char</code> in ""slm"".</li>
<li><code>*a+1</code> points to the second <code>char</code> in ""slm"".</li>
<li><code>*(*a+1)</code> gets the second <code>char</code> in ""slm"".</li>
<li><code>printf(""%c\n"", *(*a+1))</code> prints the second <code>char</code> in ""slm"".</li>
<li><code>*(a+1)</code> is the second <code>char</code> pointer in the array, and it points to the first <code>char</code> in ""boro"".</li>
<li><code>*(a+1)+1</code> points to the second <code>char</code> in ""boro"".</li>
<li><code>*(*(a+1)+1)</code> gets the second <code>char</code> in ""boro"".</li>
<li><code>printf(""%c\n"", *(*(a+1)+1))</code> prints the second <code>char</code> in ""boro"".</li>
</ul>
",0
47542742,47542472,1,"<p><code>*(a+1)</code> is actually <code>a[1]</code>, in 3) and 4)</p>

<pre><code>printf(""%c\n"", *a[1]);      //3  is **(a+1)
printf(""%c\n"", *(a+1)[1]);  //4  is **(a+1+1)
</code></pre>

<p>In 3) <code>*(a+1)</code> gives you the 2nd string, <code>**(a+1)</code> its first char<br>
In 4) same, for 2nd string</p>

<p>because <code>[</code> has more precedence than <code>*</code>. Instead</p>

<pre><code>printf(""%c\n"", (*a)[1]);      //3 or a[0][1] ==&gt; 's'
printf(""%c\n"", (*(a+1))[1]);  //4 or a[1][1] ==&gt; 'o'
</code></pre>
",0
47542812,47542472,1,"<pre><code>#include &lt;stdio.h&gt;
void main(){
    char *a[3] = {""slm"", ""boro"", ""dige""};
    printf(""%c\n"", *a[1]);    // From pointer a, take what is in index 1 (""boro"") and derreference it (""boro""[0] = 'b'), print it as a char ('b')
    printf(""%c\n"", (*a)[1]);  // From pointer a, derreference it (a[0] = ""slm"") and take what is in index 1 (""slm""[1] = 'l'), print it as a char ('l')

    printf(""%c\n"", *(a+1)[1]);    // From pointer a, add 1, take what is in index 1 (""dige"") and derreference it (""dige""[0] = 'd'), print it as a char ('d')
    printf(""%c\n"", (*(a+1))[1]);  // From pointer a add 1 and derreference it ((a+1)[0] = ""boro""),  and take what is in index 1 (""boro""[1] = 'o'), print it as a char ('o')
}  
</code></pre>
",0
35200120,35198846,0,"<p>Assuming the input byte order is big-endian, you can do this:</p>

<pre><code>unsigned char fromfile[8];  //contains 8 bytes from a binary file
unsigned long int output;   //output to be printed

output =
  (fromfile[4] &amp; 0xf) &lt;&lt; 16 |
  fromfile[5] &lt;&lt; 8 |
  fromfile[6];

printf(""%lu"", output);
</code></pre>

<p>To explain what's happening in the expression assigned to <code>output</code>, let's look at bytes 4 through 6 of the input which correspond to the binary digits 23 through 0 of the desired value (because of the big endian byte order):</p>

<pre class=""lang-none prettyprint-override""><code>byte:         4        5        6
 bit: 23       15        7      0
       00001111 11111111 11111111
</code></pre>

<p>We're interested in the bits masked with <code>1</code> and not interested in bits masked with <code>0</code>.</p>

<ol>
<li><p><code>fromfile[4] &amp; 0xf</code> takes byte 4 and masks its value with F<sub>16</sub> = 00001111<sub>2</sub>, which is exactly the mask underneath byte 4 in the figure above,  using the bitwise AND operation (<code>&amp;</code>).</p></li>
<li><p><code>... &lt;&lt; 16</code> shifts the result of step 1 to the left by 16 binary digit positions, which is exactly the position where we need the lower nibble of byte 4 to go according to the figure above.</p></li>
<li><p><code>fromfile[5] &lt;&lt; 8</code> ¨C similarly to step 2, this takes byte 5 and shifts it to the left by 5 positions because that's where its bits are supposed to go.</p></li>
<li><p><code>fromfile[6]</code> doesn't perform a bit shift, because the value read from byte 6 needs to be mapped to the lowest 8 bits of the output value anyway.</p></li>
<li><p>So now we have three values (<code>X</code>, <code>Y</code>, and <code>Z</code> mark unknown bits of the values <code>x</code>, <code>y</code>, and <code>z</code> respectively):</p>

<pre class=""lang-none prettyprint-override""><code>0000XXXX 00000000 00000000
00000000 YYYYYYYY 00000000
00000000 00000000 ZZZZZZZZ
</code></pre>

<p>To assemble them into one value, we use the binary OR operation (<code>|</code>) twice (<code>x | y | z</code>):</p>

<pre class=""lang-none prettyprint-override""><code>0000XXXX YYYYYYYY ZZZZZZZZ
</code></pre>

<p>This is exactly how we want the bits of the input data arranged and we're done.</p></li>
</ol>
",2
36757812,36757288,1,"<p>Be sure that the file does not have more than MAXSIZE lines.</p>

<p>You can use fscanf instead of scanf</p>

<p>If you really need scanf you can send the file as input to your program with</p>

<pre><code>$ ./test &lt; test.txt
</code></pre>

<p>This code will work with a file and the fscanf function.</p>

<pre><code>#include &lt;stdio.h&gt;

#define MAXSIZE 100    

int main(int argc, char *argv[]) {
    int i;
    int a, b;
    double c, d, e;
    int A[MAXSIZE], B[MAXSIZE];
    double C[MAXSIZE], D[MAXSIZE];

    FILE* fp = fopen(""teste.txt"", ""r"");

    if(fp == NULL) {
        printf(""Failed to open file.\n"");
        return 1;
    }

    fscanf(fp, ""%d"", &amp;i);// ignore first value
    i = 0;
    while (fscanf(fp, ""%d %d %lf %lf"", &amp;a, &amp;b, &amp;c, &amp;d) == 4) {
        A[i] = a;
        B[i] = b;
        C[i] = b;
        D[i] = d;

        i++;
        printf(""%d %d %f %f\n"", a, b, c, d);
    }
    return 0;
}
</code></pre>
",1
37632755,37632545,0,"<p>First of all it's not necessary to protect the include from main since it's already done from STRUCT.h</p>

<p>So instead of in main</p>

<pre><code>#ifndef STRUCT_H
#include  ""struct.h""
#endif
</code></pre>

<p>directly use(in main the .h is the one which should have protection which it already does, no need to do it twice)</p>

<pre><code>#include  ""struct.h""
</code></pre>

<p>Now back to your code the problem you are having is that you're not modifying the structure in a function, meaning that rows[0].posX = 1; will never be executed</p>

<p>This should work:</p>

<pre><code>#include ""struct.h""

int main(void)
{

    rows[0].posX = 1;

    //do something else like print result etc
    return 0;
}
</code></pre>

<p>Also you're not using the typedef, it's an empty use of typedef since you didn't put any name afterwords  note these two are the same:</p>

<pre><code>typedef struct Row
{
    char *label;
    int posX;
    int posY;
};



struct Row
{
    char *label;
    int posX;
    int posY;
};
</code></pre>

<p>I would use something along the lines of </p>

<pre><code>typedef struct Row
{
    char *label;
    int posX;
    int posY;
}row_t;
</code></pre>

<p>Now you can directly use row_t as a data type instead of struct row</p>

<p>Finally I wouldn't make it a global variable I would make it local to main and pass a pointer to any function that requieres the array/membery of array</p>

<pre><code>#include &lt;stdio.h&gt;

typedef struct Row
{
    char *label;
    int posX;
    int posY;
}row_t;


int main(void)
{

    row_t rows[20];//Not global local to main
    rows[0].posX = 1;
    printf(""%d\n"",rows[0].posX );
    //do something else like print result etc
    return 0;
}
</code></pre>
",3
35268044,35267903,0,"<p>You are messing up with the size of the matrix. You might want to change the sequence of these two and give it a try : </p>

<pre><code>r--; c--;
int mat[r][c];
</code></pre>

<p>change this to</p>

<pre><code>int mat[r][c];
r--; c--;
</code></pre>

<p>and the code should work as you expect.</p>
",0
35268063,35267903,1,"<p>You don't use the number of rows and columns correctly. It is true that in C, an array with <code>N</code> entries can access the indices 0 through <code>N - 1</code> only and that the index <code>N</code> is one beyond the range of the array. But you still have to define the array with the actual size:</p>

<pre><code>// Don't adjust c and r here

int mat[r][c];
</code></pre>

<p>When you use the dimension in a <code>for</code> loop, you can ensure that you never access <code>mat[r][c]</code> by using <code>&lt;</code> instead of <code>&lt;=</code> as condition:</p>

<pre><code>for (a = 0; a &lt; r; a++) {
    for (b = 0; b &lt; c; b++) {
        if (a % 2 == 0) {
            mat[a][b] = 0;
        } else {
            mat[a][b] = 1;
        }
    }
}
</code></pre>
",0
39320179,39320147,3,"<p>You are comparing a char value that contains the <a href=""http://www.asciitable.com/"" rel=""nofollow"">ASCII</a> representation of a number, to an actual number.  Change  </p>

<pre><code>if(!(str[i]&gt;=0 &amp;&amp; str[i]&lt;=9)){  
</code></pre>

<p>to</p>

<pre><code>if(!(str[i]&gt;='0' &amp;&amp; str[i]&lt;='9')){  
</code></pre>

<p>I did not check if the rest of the code is correct, but certainly, this is one issue.</p>
",1
39320186,39320147,2,"<pre><code>   if(!(str[i]&gt;=0 &amp;&amp; str[i]&lt;=9)){   //if str[i] is not a number
</code></pre>

<p>This is incorrect. '0' and 0 are not same. Neither is 9 and '9'. The value of '9' will be integer that represents '9' in ASCII chart.</p>

<p>Rest of the logic seems suspicious too, for example what happens if you have ""55"", code will enter <code>if</code> twice, once for 55 and second time for 5, isn't it?</p>
",2
39320214,39320147,1,"<p>This seems a bit odd. What's the goal?</p>

<p>Agree with previous comment.</p>

<p>Why are you doing atoi() on what is NOT a number?</p>

<p>You will go past the end of the string.
Your spaces COUNT in the example</p>

<p>and so on.
you don't update i when you find a number, so you will count ""44"" as 44 first and 4 second.</p>

<p>If you're trying to learn, hook up a debugger, step through the code, and see how the data changes.</p>
",1
38292192,38292143,0,"<p>In practice, writes to a pointer will be atomic on popular modern platforms, <em>if the pointer storage is aligned.</em>   Which it will be in your case, where the pointer is allocated on the stack.  If the pointer were stored on the heap, you would need to make sure to store it with the proper alignment.</p>

<p>In theory, no, it's not safe.</p>
",3
39377128,39374680,1,"<p>What you have done wrong is already listed in the comments but you are doing it overly complicated, nearly Rube-Goldberg like. It is quite simple and can be done without any complicated tricks.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

// ALL CHECKS OMMITTED!

char *int8_to_bin(int n, char *buf)
{
  int i = 8;
  // we need an unsigned integer for the bit-juggling
  // because of two's complement numbers.
  // Not really needed here because the input is positive
  unsigned int N;
  // check for proper size
  if (n &lt; 0 || n &gt; 255) {
    return NULL;
  }
  // is safe now
  N = (unsigned int) n;
  // we work backwards here, least significant bit first
  // but we want it least significant bit last.
  while (i--) {
    // make a (character) digit out of an integer
    buf[i] = (char) (N &amp; 0x1) + '0';
    // shift one bit to the right and
    // drop the least significant bit by doing it
    N &gt;&gt;= 1;
  }
  // return the pointer to the buffer we got (for easier use)
  return buf;
}

int main(int argc, char **argv)
{
  // keeps the intermediate integer
  int addr;
  // command-line argument, helper for strtol() and int8_to_bin()
  char *s, *endptr, *cp;
  // buffer for int8_to_bin() to work with
  // initialize to all '\0';
  char buf[9] = { '\0' };
  // array holding the end-result
  // four 8-character groups with three periods and one NUL
  char binaddr[4 * 8 + 3 + 1];
  // iterator
  int i;

  if (argc &lt; 2) {
    fprintf(stderr, ""Usage: %s dotted_ipv4\n"", argv[0]);
    exit(EXIT_FAILURE);
  }
  // set a pointer pointing to the first argument as a shortcut
  s = argv[1];

  // the following can be done in a single loop, of course

  // strtol() skips leading spaces and parses up to the first non-digit.
  // endptr points to that point in the input where strtol() decided
  // it to be the first non-digit
  addr = (int) strtol(s, &amp;endptr, 0);

  // work on copy to check for NULL while keeping the content of buf
  // (checking not done here)
  cp = int8_to_bin(addr, buf);
  // if(cp == NULL)...

  // copy the result to the result-array
  // cp has a NUL, is a proper C-string
  strcpy(binaddr, cp);

  // rinse and repeat three times
  for (i = 1; i &lt; 4; i++) {
    // skip anything between number and period,
    // (or use strchr() to do so)
    while (*endptr != '.'){
      endptr++;
    }
    // skip the period itself
    endptr++;
    // add a period to the output
    strcat(binaddr, ""."");
    // get next number
    addr = (int) strtol(endptr, &amp;endptr, 0);
    cp = int8_to_bin(addr, buf);
    // if(cp == NULL)...
    strcat(binaddr, cp);
  }
  printf(""INPUT:  %s\n"", s);
  printf(""OUTPUT: %s\n"", binaddr);

  exit(EXIT_SUCCESS);
}
</code></pre>

<p>We don't need a complicated parsing algorithm, <code>strtol()</code> does it for us, we just need to find the next period ourselves. The size of all in- and output is known and/or can be easily checked if they are inside their limits--e.g.: no need for tedious and error-prone memory allocations, we can use fixed size buffers and <code>strcat()</code>.</p>

<p>There is a principle, that holds not only in the Navy but also in programming: <a href=""https://en.wikipedia.org/wiki/KISS_principle"" rel=""nofollow"">KISS</a>.</p>
",0
41687326,41687291,5,"<p>Variables inside a function in C are not guaranteed to be set to anything by default. In memory, whatever was last stored there (which might not be flushed/erased to be 0) will be what the int is initialized to.</p>

<p>This is answered in <a href=""https://stackoverflow.com/questions/7975008/initializing-variables-in-c"">Initializing variables in C</a></p>

<p>EDIT: As chux has stated below, local <em>static</em> variables are initialized to 0 if they aren't given an initial value. Also covered <a href=""https://stackoverflow.com/questions/6212921/is-un-initialized-integer-always-default-to-0-in-c"">Is un-initialized integer always default to 0 in c?</a></p>
",3
36302772,36302590,4,"<p>This block doesn't make sense at all:</p>

<pre><code> first = malloc(sizeof(Node));
 if (first == NULL) {
    first-&gt;x = x;
    first-&gt;y = y;
    first-&gt;next = NULL;
 }
</code></pre>

<p>Probably you wanted to move the <code>first = malloc(sizeof(Node));</code> inside the block. It would work, however it's completely unnecessary because it would be logically equal to the <code>else</code> block. So you can leave just the second block there:</p>

<pre><code>    Node * temp = malloc(sizeof(Node));
    temp-&gt;x = x;        
    temp-&gt;y = y;                      
    temp-&gt;next = first;                 
    first = temp;
    return first;
    // or rather return temp directly
</code></pre>

<p>There is one more point - you should add error handling in case <code>malloc</code> runs out of memory, so you should check for <code>temp == NULL</code> and act accordingly (return <code>NULL</code> from function or whatever...).</p>
",1
36302785,36302590,0,"<p>For starters even the first statement of the function is wrong because the value of the parameter <code>first</code> is overwritten.</p>

<pre><code>Node* addFront(Node* first, double x, double y) {   

     first = malloc(sizeof(Node));
     //...
</code></pre>

<p>The function can look the following way</p>

<pre><code>Node * addFront( Node *first, double x, double y ) 
{   
    Node *temp = malloc( sizeof( Node ) );

    if ( temp != NULL )
    {
        temp-&gt;x = x;        
        temp-&gt;y = y;                      
        temp-&gt;next = first;                 

        first = temp;
    }

    return first;
}
</code></pre>

<p>Or with a testing code</p>

<pre><code>Node * addFront( Node *first, double x, double y ) 
{   
    Node *temp = malloc( sizeof( Node ) );

    if ( temp != NULL )
    {
        temp-&gt;x = x;        
        temp-&gt;y = y;                      
        temp-&gt;next = first;                 

        first = temp;
    }

    // start pf inline test
    size_t size = 0;

    for ( Node *current = first; current != NULL; current = current-&gt;next )
    {
        printf( ""(%.4f, %.4f)\n"", current-&gt;x, current-&gt;y );
        ++size;
    }
    printf( ""Size: %zu\n"", size );
    // end pf inline test

    return first;
}
</code></pre>
",0
42479570,42479480,0,"<p>You probably need to change this part:</p>

<pre><code>if(c=='\n'){
  array[i][j] = c;
  i++;
  j = 0;
}
</code></pre>

<p>To</p>

<pre><code>if(c=='\n'){
  i++;
  j = 0;
} else {
  array[i][j] = c;
  j++;
}
</code></pre>

<p>This means that if the character is a new line, move to the next row, otherwise save it in the array.</p>
",6
42479583,42479480,0,"<p>You only store something in the array when you encounter a newline. </p>

<p>I would rewrite the loop to</p>

<pre><code>while ((c = fgetc(fp)) != EOF)
{
    if(c!='\n'){
     array[i][j]=c;
     j++;
    }
    else
    {
      i++;
      j = 0;
    }
}
</code></pre>

<p>fgetc returns EOF on feof() AND ferror() so you wont have an infinite loop if there is a harddisk problem.</p>
",0
39006921,39006814,0,"<p>You are going to end up doing this with <code>sizeof</code> anyway.  I just checked this in Visual Studio, and Microsoft defines it as (across several defines)</p>

<pre><code>#define _INTSIZEOF(n)   ( (sizeof(n) + sizeof(int) - 1) &amp; ~(sizeof(int) - 1) )
#define _crt_va_arg(ap,t)    ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_arg _crt_va_arg
</code></pre>

<p>You can find these in vadefs.h.  Long story short, you're not going to get away from using sizeof somewhere, so you should just do it where it is most simple.  Personally I think that'd be just passing the size into your <code>getMem</code> function instead of the type will save you way more headache in the long run.</p>
",1
39006862,39006814,2,"<p>Do this with a CPP macro:</p>

<pre><code>#define getMem(type, size) \
    malloc(sizeof(type) * size)
</code></pre>

<p>However, personally, I prefer this:</p>

<pre><code>#define getMemOf(ptr, size) \
    ptr = malloc(sizeof(*ptr) * size)

// invoke with:
    getMemOf(ptr, 1000);
</code></pre>
",4
39006877,39006814,0,"<p><code>malloc()</code> does not need to know the type to work well, just the <em>size</em> of the type.</p>

<p>Should code want to insure no overflow in the size calculation, a check could be made.</p>

<pre><code>void *getMem(size_t element_count, size_t type_size) {
  if (element_count &gt; SIZE_MAX/type_size) return NULL;
  return malloc(element_count * size);
}

// usage example
size_t element_count, 
void * p = getMem(element_count, sizeof (char));
</code></pre>

<p>If one wants zero-ed memory, simple use <code>calloc()</code></p>

<pre><code>// usage example
size_t element_count, 
void * p = calloc(element_count, sizeof (char));
</code></pre>

<hr>

<p>Recommend that code not use <code>void *</code> pointers and expresses a type like <code>char</code> separately.  Instead, declare a pointer with a non-<code>void</code> type.</p>

<pre><code>#define ALLOCATE_ASSIGN(addr_ptr, count) (*(addr_ptr)=malloc(sizeof **(addr_ptr) * count))

some_type *mem;
ALLOCATE_ASSIGN(&amp;mem, element_count);
</code></pre>
",1
39007291,39006814,2,"<p><code>_Generic</code> in <strike>C99</strike> C11 may offer something close to OP's need.</p>

<p>Example: Code wants to assign the maximum value of a common integer type.</p>

<pre><code>#define integer_max(X) _Generic((X), \
  unsigned long long: ULLONG_MAX, \
  long long: LLONG_MAX, \
  unsigned long: ULONG_MAX, \
  long: LONG_MAX, \
  unsigned: UINT_MAX, \
  int: INT_MAX, \
  unsigned short: USHRT_MAX, \
  short: SHRT_MAX, \
  unsigned char: UCHAR_MAX, \
  signed char: SCHAR_MAX, \
  char: CHAR_MAX, \
  _Bool: 1, \
  default: 1/0 \
  )

  // Here the _type_ of `x` is used by integer_max(), not its value.
  some_integer_type x = integer_max(x);
</code></pre>
",1
36559425,36559320,0,"<p>The important thing from an efficiency standpoint is that the code doesn't just continually cycle.  In your example, presumably the <code>wait()</code> function is returning control to your OS so that it can immediately dispatch another task.</p>

<p>In short, yes, your second example is power efficient as well, assuming <code>wait()</code> returns control to the the OS.</p>
",0
37828985,37828755,1,"<p>In the call</p>

<pre><code>strcpy(poleNazvu[count][ALOKACE_MALA-1],levaStrana); //ITS HERE
</code></pre>

<p>the destination <code>poleNazvu[count][ALOKACE_MALA-1]</code> is an <strong><em>uninitialized</em></strong> pointer. It's value is <em>indeterminate</em> leading to <em>undefined behavior</em>.</p>

<p>Either allocate memory for the pointer before copying, or use <code>strdup</code> instead (which does allocation and copying in a single call), or make <code>poleNazvu</code> not be an array of array of pointers to <code>char</code>.</p>

<hr>

<p>There are also some things that doesn't really make any sense, like why are you using <code>poleNazvu[count][ALOKACE_MALA-1]</code> as the destination? It will always copy the string to the same entry in the array arrays.</p>

<p>Perhaps you are supposed to make <code>poleNazvu</code> an array of arrays of <code>char</code>, not an array of arrays of pointers to <code>char</code>? Like</p>

<pre><code>char poleNazvu[ALOKACE_POLI][ALOKACE_MALA];
</code></pre>

<p>Then you would just do</p>

<pre><code>strcpy(poleNazvu[count], levaStrana);
</code></pre>

<p>Of course this requires the length of the string in <code>levaStrana</code> be less than <code>ALOKACE_MALA</code> characters. So perhaps use <code>strncpy</code>  and explicit termination instead, like</p>

<pre><code>strncpy(poleNazvu[count], levaStrana, ALOKACE_MALA - 2);
poleNazvu[count][ALOKACE_MALA - 1] = '\0';
</code></pre>
",5
39669104,39669010,1,"<p>You need to check if <code>name</code> contains a newline character.  If it does, there's nothing in the buffer and you don't need to flush it.</p>

<pre><code>    fgets(name, 5, stdin);
    printf(""Name: %s\n"", name);
    if (strchr(name, '\n') == NULL) {
        int c;
        while ((c = getchar()) != '\n' &amp;&amp; c != EOF);
    }
</code></pre>
",1
39669107,39669010,1,"<p>We already discussed this in passing in the commentary on <a href=""https://stackoverflow.com/a/39667600/2402272"">my answer to your previous question</a>.  If there is room for it in the buffer, <code>fgets()</code> will consume the terminating newline, placing it in the buffer.  You can determine whether it has done so by looking for a newline in the buffer.  If you find one, then</p>

<ol>
<li><p>You probably want to remove it -- by replacing it with <code>'\0'</code>, for example.</p></li>
<li><p>You should avoid trying to drain the tail of the input line, because the stream has already advanced to the next line.</p></li>
</ol>
",3
39669746,39669010,0,"<ol>
<li><p>Check the result of <code>fgets()</code>.  Unless code does so, using the contents of <code>name</code> may be undefined behavior.  Avoid magic numbers: uses <code>sizeof name</code>.</p>

<pre><code>        // fgets(name, 5, stdin);
        if (fgets(name, sizeof name, stdin) == NULL) Handle_EOF();
</code></pre></li>
<li><p>Look for a <em>potential</em> <code>'\n'</code> in <code>name[]</code>.</p>

<pre><code>        char *eol = strchr(name, '\n');
</code></pre></li>
<li><p>If one is found, overwrite with the null character, else consume the rest of the line</p>

<pre><code>        if (eol) {
          *eol = '\0';
        } else {
          int ch;
          while ((ch = getchar()) != '\n' &amp;&amp; ch != EOF);
        }
</code></pre></li>
<li><p>Print <code>name[]</code></p>

<pre><code>        printf(""Name: %s\n"", name);
</code></pre></li>
</ol>
",0
36461530,36458261,0,"<p>I tried to come up with my own solution for the problem, since I couldn't have a quick understanding of yours. I hope it helps. I tested it against your case scenario and another one I made up, and it worked for both.</p>

<pre><code> #include &lt;iostream&gt;

 using namespace std;

 int* get_line_order(int in1, int *in2);

 int main()
 {
     int in[] = {7,0,1,4,3,1,0,1,1,0};
     int *out;
     int N = 10;

     out = get_oringinal(N, in);

     for(int i = 0; i&lt;N; i++)
         cout &lt;&lt; out[i] &lt;&lt; endl;

     return 0;
 }

 int* get_line_order(int in1, int *in2)
 {
     int *out = new int[in1];
     int i,j,k, count;

     //initializes out array
     for(i=0; i&lt;in1; i++)
         out[i] = in1;

     //loops through in2
     for(i=0; i&lt; (in1-1); i++)
     {
         count = 0;
         //loops through out
         for(j=0; j&lt; (in1-1); j++)
         {
             if(out[j] &gt; (i+1))
                 count++;
             if(count == in2[i])
             {
                 for(k = j+1; k&lt;in1; k++)
                     if(out[k] == in1)
                     {
                         out[k] = i+1;
                         break;
                     }
                 break;
             }
             else if(count &gt; in2[i])
             {
                 for(k = j; k&lt;in1; k++)
                     if(out[k] == in1)
                     {
                         out[k] = i+1;
                         break;
                     }
                 break;
             }
         }
     }

     return out;
 }
</code></pre>
",0
34888807,34888776,2,"<p>No, don't use <code>feof()</code> to detect the end of the file. Instead check for a read failure, for example <code>fgets()</code> will return <code>NULL</code> if it attempts to read past the end of the file whereas <code>feof()</code> will return <code>0</code> until some function attempts to read past the end of the file, only after that it returns non-zero.</p>
",2
34889162,34888776,2,"<blockquote>
<p>Does feof() work when called after reading in last line?</p>
<p>No.</p>
</blockquote>
<p><code>feof()</code> becomes true when reading <strong>past</strong> the end of data.  Reading the last line may not be pass the end of data if the last line ended in <code>'\n'</code>.</p>
",0
34889415,34888776,1,"<p>The short answer is <strong>NO</strong>.  Here is why:</p>

<p>If <code>fgets</code> successfully read the <code>'\n'</code> at the end of the line, the end-of-file indicator in the <code>FILE</code> structure has not been set.  Hence <code>feof()</code> will return <code>0</code>, just like it should before reading anything, even on an empty file.</p>

<p><code>feof()</code> can only be used to distinguish between end-of-file and read-error conditions after an input operation failed. Similarly, <code>ferr()</code> can be used to check for read-error after an input operation failed.</p>

<p>Programmers usually ignore the difference between end-of-file and read-error. Hence they only rely on checking if the input operation succeeded or failed. Thus they never use <code>feof()</code>, and so should you.</p>

<p>The behavior is somewhat similar as that of <code>errno</code>:  <code>errno</code> is set by some library functions in case of error or failure.  It is not reset to <code>0</code> upon success.  Checking <code>errno</code> after a function call is only meaningful if the operation failed <strong>and</strong> if <code>errno</code> was cleared to <code>0</code> before the function call.</p>

<p>If you want to check if you indeed reached to the of file, you need to try and read extra input. For example you can use this function:</p>

<pre><code>int is_at_end_of_file(FILE *f) {
    int c = getc(file);
    if (c == EOF) {
        return 1;
    } else {
        ungetc(c, file);
        return 0;
    }
}
</code></pre>

<p>But reading extra input might not be worthwhile if reading from the console: it will require for the user to type extra input that will be kept in the input stream. If reading from a pipe or a device, the side effect might be even more problematic. Alas, there is no portable way to test if a <code>FILE</code> stream is associated with an actual file.</p>
",5
35249977,35249965,1,"<p><code>strcasecmp()</code> is not a standard C function, but it is on most compilers.</p>

<p>Write your own:</p>

<pre><code>int strnocasecmp(char const *a, char const *b)
{
    for (;; a++, b++) {
        int d = tolower((unsigned char)*a) - tolower((unsigned char)*b);
        if (d != 0 || !*a)
            return d;
    }
}
</code></pre>

<p>Don't forget the <code>#include &lt;ctype.h&gt;</code> library for <code>tolower()</code>.</p>
",1
35249989,35249965,1,"<p>If it is OK to support only single-byte English alphabets to ignore cases, just convert each characters to lower case (or upper case) and compare.</p>

<pre><code>#include &lt;ctype.h&gt;

int cmp(const char *a, const char *b) {
    while (*a || *b) {
        int c1 = tolower((unsigned char)*a++);
        int c2 = tolower((unsigned char)*b++);
        if (c1 != c2) return c1 &gt; c2 ? 1 : -1;
    }
    return 0;
}
</code></pre>
",3
35250186,35249965,0,"<p>If you have access to <code>strcasecmp</code> (POSIX) in <code>string.h</code>, that's probably your best bet.</p>

<pre><code>strcasecmp(""TOMMY"", ""tOMmy"") == 0
</code></pre>

<p>Otherwise, it's not too hard to make your own.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdbool.h&gt;

bool check_strings(const char* str1, const char* str2)
{
    if (strlen(str1) != strlen(str2))
        return false;

    do {
        if (tolower(*str1++) != tolower(*str2++))
            return false;
    } while(*str1 || *str2)

    return true;
}
</code></pre>
",2
34958282,34957953,1,"<p>You should read a new number in each iteration of the <code>while</code> loop:</p>

<pre><code>#include &lt;stdio.h&gt;

int reverseInteger();
int generateMagicNumber();

int main() {
    int n, i;
    char all;
    printf(""How many magic numbers do you want"");
    if (scanf(""%d"", &amp;n) != 1)
        return 1;

    for (i = 0; i &lt; n; i++) {
        int num, temp, rev, magic;
        if (scanf(""%d"", &amp;num) != 1)
            return 2;

        rev = 0;
        temp = num;
        while (temp != 0) { //reversing number
            rev = rev * 10;
            rev = rev + temp % 10;
            temp = temp / 10;
        }
        if (rev &lt; num)
            magic = num - rev;
        else
            magic = rev - num;
        printf(""%d "", magic);
    }
    printf(""\n"");
    return 0;
}
</code></pre>

<p>If you enter all the numbers on one line, the answers will appear on a single line below it.</p>
",10
45057186,45057086,3,"<p>What happens is something called <a href=""http://en.cppreference.com/w/c/language/conversion#Usual_arithmetic_conversions"" rel=""nofollow noreferrer""><em>usual arithmetic conversion</em></a> which leads to <a href=""http://en.cppreference.com/w/c/language/conversion#Integer_promotions"" rel=""nofollow noreferrer""><em>integer promotion</em></a> for both arguments of the <code>&lt;&lt;</code> operator.</p>

<p>If you instead of using the shift expression directly in the <code>printf</code> argument, and instead stored it in a <code>uint8_t</code> variable, then the result would be zero. <em>However</em> when you call <code>printf</code> you would instead have a <a href=""http://en.cppreference.com/w/c/language/conversion#Default_argument_promotions"" rel=""nofollow noreferrer""><em>default argument promotion</em></a> which would turn the <code>uint8_t</code> variable into an <code>int</code>. But that would lead to another problem because even though the format <code>""%x""</code> expects an <code>int</code> (an <code>unsigned int</code> actually, see e.g. <a href=""http://en.cppreference.com/w/c/io/fprintf"" rel=""nofollow noreferrer"">this <code>printf</code> and family reference</a>) the data is actually an <code>uint8_t</code>. That means you have mismatched format specifier and argument, leading to <em>undefined behavior</em>. The correct format specifier to print an <code>uint8_t</code> is <code>""%hhx""</code>, or better yet use the <code>PRI8x</code> macro:</p>

<pre><code>uint8_t result = ...
printf(""%"" PRI8x ""\n"", result);
</code></pre>

<p>See e.g. <a href=""http://en.cppreference.com/w/c/types/integer#Format_macro_constants"" rel=""nofollow noreferrer"">this format macro reference</a>.</p>
",4
45057195,45057086,3,"<p><em>Both</em> arguments of <code>&lt;&lt;</code> are converted to <code>int</code> prior to the evaluation, <em>despite</em> the fact that you've attempted to force the issue with <code>(uint8_t)24</code>.</p>

<p>This is necessarily true since <code>uint8_t</code> is narrower than an <code>int</code> on any platform.</p>

<p>So the result, <code>ff000000</code>, you observe is consistent with an <code>int</code> being at least 32 bits wide on your platform.</p>
",4
44356549,44356452,1,"<p>Your <code>World</code> struct has a flexible array member as the last element.  There is actually no space set aside for that member.  As a result, you write off the end of the struct when you write to the array, resulting in undefined behavior.</p>

<p>You need to declare a <code>World *</code>  and use <code>malloc</code> to allocate space for the struct plus the array.</p>

<pre><code>World *world = malloc(sizeof(World) + 10 * 10 * sizeof(Cell));
</code></pre>
",1
44357036,44356452,2,"<p><code>grid.cell[]</code> is not have been allocated any memory space. You should allocate it a memory by adding following line before starting of the loop:</p>

<pre><code> grid.cell = Cell[100];
</code></pre>

<p>The size <code>100</code> is based on the fact that <code>grid.sizeX = 10;</code> and <code>grid.sizeY = 10;</code>. There is no need of using <code>malloc()</code> because the size is fixed.</p>

<p>If size is not fixed for <code>grid.sizeX</code> and <code>grid.sizeY</code>then, you should add following line instead of <code>grid.cell = Cell[100];</code>:</p>

<pre><code> grid.cell = (Cell*)malloc(sizeof(Cell) *(grid.xSize  * grid.ySize ));
</code></pre>

<p>The line <code>World *grid = malloc(sizeof(World) + xSize * ySize * sizeof(Cell));</code> which is added by you is just a tricked way and not much clear. Even it is logically correct!!!</p>
",0
44367172,44356452,0,"<p>Here is the results : </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define LIVE 1
#define DEAD 0
#define xSize 10
#define ySize 10

typedef struct {
  int x;
  int y;
  unsigned char status;
} Cell;

typedef struct {
  int sizeX;
  int sizeY;
  Cell cell[1];
} World;

int main() {
  int i, x, y;
  i = 0;
  World *grid = malloc(sizeof(World) + xSize * ySize * sizeof(Cell));;
  grid-&gt;sizeX = xSize;
  grid-&gt;sizeY = ySize;

  for (x = 0; x &lt; grid-&gt;sizeX; x++) {
    for (y = 0; y &lt; grid-&gt;sizeY; y++) {
      Cell cell;
      cell.x = x;
      cell.y = y;
      cell.status = DEAD;

      printf(""%d,%d: "", cell.x, cell.y);

      grid-&gt;cell[i] = cell;
      i++;
    }
  }

    return 0;
}
</code></pre>
",0
42601312,42601168,2,"<p>Due to operator precedence, the 2 below lines are the same.</p>

<pre><code>// Not what OP needs
pos=getc(stdin) != EOF
pos=(getc(stdin) != EOF)
</code></pre>

<p>Instead, use <code>()</code></p>

<pre><code>while((pos=getc(stdin)) != EOF) 
</code></pre>

<hr>

<p>Use <code>int ch</code> to distinguish the values returned from <code>fgetc()</code> which are values in the <code>unsigned char</code> range and <code>EOF</code>.  Typically 257 different, too many for a <code>char</code>.</p>

<pre><code>int main() {
  unsigned long character_count = 0;
  unsigned long word_count = 0;
  unsigned long line_count = 0;
  unsigned long letter_count = 0;
  int pos;

  while((pos = getc(stdin)) != EOF) {
    ...
</code></pre>

<hr>

<p>You may want to review your word count strategy too. <a href=""https://stackoverflow.com/questions/42601168/c-programming-counts-the-number-of-characters-words-and-lines-from-another-tex/42601312#comment72333082_42601168"">@Tony Tannous</a></p>

<hr>

<p>For me, I would count a ""word"" as any time a letter occurred that did not follow a non-letter.  This avoids a problem <a href=""https://stackoverflow.com/users/6530695/tony-tannous"">@Tony Tannous</a> and other issues.  Like-wise, I would count a <em>line</em> as any character that followed a <code>'\n'</code> or the very first one and avoid any post loop calculation.  This handles the issue commented by <a href=""https://stackoverflow.com/questions/42601168/c-programming-counts-the-number-of-characters-words-and-lines-from-another-tex/42601312#comment72333323_42601168"">Weather Vane</a>.</p>

<p>It also appear 39 is a <em>letter</em> count and not a character count <a href=""https://stackoverflow.com/questions/42601168/c-programming-counts-the-number-of-characters-words-and-lines-from-another-tex/42601312#comment72333325_42601168"">@BLUEPIXY</a>.<br>
Suggest using <code>&lt;ctype.h&gt;</code> functions to test for letter-ness  (<code>isapha()</code>) </p>

<pre><code>int previous = '\n';
while((pos = getc(stdin)) != EOF) {
  character_count++;
  if (isalpha(pos)) {
    letter_count++;
    if (!isalpha(previous)) word_count++;
  }
  if (previous == '\n') line_count++;
  previous = pos;
}

printf(""characters %lu\n"", character_count);
printf(""letters %lu\n"", letter_count);
printf(""words %lu\n"", word_count);
printf(""lines %lu\n"", line_count);
</code></pre>
",6
43737155,43735053,4,"<p>These are bit-fields. There is not much in the way of an ""expected"" output, as these are very poorly specified by the standard. In addition, compilers tend to have poor support for them.</p>

<p>To begin with, the complete section that you quote (6.7.2.1/11) says:</p>

<blockquote>
  <p>An implementation may allocate any addressable storage unit large
  enough to hold a bitfield. If enough space remains, a bit-field that
  immediately follows another bit-field in a structure shall be packed
  into adjacent bits of the same unit. If insufficient space remains,
  whether a bit-field that does not fit is put into the next unit or
  overlaps adjacent units is implementation-defined. The order of
  allocation of bit-fields within a unit (high-order to low-order or
  low-order to high-order) is implementation-defined. The alignment of
  the addressable storage unit is unspecified.</p>
</blockquote>

<p>All of this means that you pretty much can make no assumptions about how the bits end up in memory. You can't know how the compiler will arrange alignment, you can't know the bit order of the bits, you can't know the signedness, you can't know the endianess.</p>

<p>As for if <code>int</code> and <code>_Bool</code> will merge into the same ""storage unit""... well, why would they? They are incompatible types. The C standard does not mention what will happen when you have two adjacent bit fields of incompatible types - it is left open to subjective interpretation. I suspect that there will be various type aliasing concerns.</p>

<p>So it is perfectly fine for the compiler to put all of these in separate ""storage units"". If you place items of the same type adjacently, I would however expect it to merge them or the quoted part wouldn't make any sense. For example I would expect size 8 from the following:</p>

<pre><code>struct s {
    int a : 6;
    int h : 12;
    _Bool b : 1;
    _Bool c : 1;
    _Bool d : 1;
    _Bool e : 1;
    _Bool f : 1;
    _Bool g : 1;
};
</code></pre>

<hr>

<p>Now what you should do if you want deterministically behaving, portable code is to throw bit-fields out the window and use bit-wise operators instead. They are 100% deterministic and portable. </p>

<p>Assuming you actually don't want some mysterious signed number fields, which your original code hints about, then:</p>

<pre><code>#define a UINT32_C(0xFC000000)
#define b (1u &lt;&lt; 18)
#define c (1u &lt;&lt; 17)
#define d (1u &lt;&lt; 16)
#define e (1u &lt;&lt; 15)
#define f (1u &lt;&lt; 14)
#define g (1u &lt;&lt; 13)
#define h UINT32_C(0x00000FFF)

typedef uint32_t special_thing;
</code></pre>

<p>Then design setter/getter functions or macros that sets/gets the data from this 32 bit chunk. Written properly, you can even make such code endianess-independent.</p>
",3
43736288,43735053,0,"<p>My guess is that the compiler is treating the <code>int</code> bit-fields and <code>_Bool</code> bit-fields as different types. So it combines all of the <code>_Bool</code> bit-fields together and the <code>int</code> bit-fields together, but does not combine <code>_Bool</code> and <code>int</code> bit-fields. So the structure would be put together something like this to make 12 bytes:</p>

<pre><code>struct s {
    int a : 6; // no more int bit-fields, so 4 bytes (usual size)

    // 6 bits fits in one byte, but these might have to be aligned 
    // on a 4 byte boundary for efficient access, so 4 bytes in total
    _Bool b : 1; // combine
    _Bool c : 1; // combine
    _Bool d : 1; // combine
    _Bool e : 1; // combine
    _Bool f : 1; // combine
    _Bool g : 1; // combine with above _Bool bit-fields to make 6 bits

    int h : 12; // no more int bit-fields around again, so 4 bytes
};
</code></pre>

<p>EDIT: This paragraph from the 2011 C standard could be interpreted to make <code>_Bool</code> bit-fields act different:</p>

<blockquote>
  <p><strong>6.7.2.1 Structure and union specifiers</strong><br>
  A bit-field is interpreted as having a signed or unsigned integer type consisting of the specified number of bits. If the value 0 or 1 is stored into a nonzero-width bit-field of type _Bool, the value of the bit-field shall compare equal to the value stored; <em>a _Bool bit-field has the semantics of a _Bool.</em></p>
</blockquote>

<p>If a <code>_Bool</code> bit-field has the semantics of a _Bool, then perhaps the implementer interpreted that as to say ""Act like <code>_Bool b : 1;</code> is equivalent to <code>_Bool b;</code>""</p>

<p>A quick test <a href=""https://ideone.com/wPgy0s"" rel=""nofollow noreferrer"">here</a> seems to confirm this theory.</p>
",5
40997921,40997798,0,"<p>They already told you how to define the pointer, now if you want to access a property would be  *pointer->property.....</p>
",0
41000197,40997798,1,"<p>Remember that unless it is the operand of the <code>sizeof</code> or unary <code>&amp;</code> operators, or is a string literal used to initialize a character array in a declaration, an <em>expression</em> of type ""N-element array of <code>T</code>"" (<code>T [N]</code>) will be converted (""decay"") to an expression of type ""pointer to <code>T</code>"" (<code>T *</code>), and the value of the expression will be the address of the first element of the array.</p>

<p>This naturally leads us to the following:</p>

<pre><code>tTest *ptr = sTestStructure;  // note no &amp; operator!
</code></pre>

<p>The <em>expression</em> <code>sTestStructure</code> is implicitly converted from type ""20-element array of <code>tTest</code>"" to ""pointer to <code>tTest</code>"", and the value of the expression is the same as <code>&amp;sTestStructure[0]</code>.  To access any element of <code>sTestStructure</code>, you could simply index into <code>ptr</code> as you would <code>sTestStructure</code>:</p>

<pre><code>ptr[i].u8Mem1 = some_value;                // sTestStructure[i].u8Mem1 = some_value
printf( ""%"" PRIu8 ""\n"", ptr[j].u8Mem2 );
</code></pre>

<p>Remember that the subscript operation <code>a[i]</code> is <em>defined</em> as <code>*(a + i)</code>; given the address <code>a</code>, offset <code>i</code> <em>elements</em> from that address and defereference the result.  Thus, the <code>[]</code> operator implicitly dereferences <code>ptr</code>, which is why we use the <code>.</code> operator to access each struct member.</p>

<p>Alternately, you could also access struct members using the <code>-&gt;</code> operator, and advance the pointer as necessary:</p>

<pre><code>tTest *ptr = sTestStructure;
while( ptr-&gt;u8Mem1 != some_value )  // no subscript operation here
  ptr++;
</code></pre>

<p>The expression <code>ptr-&gt;u8Mem1</code> is equivalent to <code>(*ptr).u8Mem1</code><sup>1</sup>, which is equivalent to <code>ptr[0].u8Mem1</code>.  </p>

<p>So what happens if we decide to use <code>&amp;sTestStructure</code> instead?  Since <code>sTestStructure</code> is the operand of the unary <code>&amp;</code> operator, the conversion rule above doesn't apply; instead of getting a pointer to a pointer to <code>tTest</code>, we get a pointer to a <em>20-element array</em> of <code>tTest</code>, or:</p>

<pre><code>tTest (*arrPtr)[20] = &amp;sTestStructure;
</code></pre>

<p>This presents a bit more of a challenge, since we have to dereference <code>arrPtr</code> <em>before</em> we can index into it:</p>

<pre><code>(*arrPtr)[i].u8Mem1 = some_value;
printf( ""%"" PRIu8 ""\n"", (*arrPtr)[j].u8Mem2 );
</code></pre>

<p>Since <code>a[i]</code> is defined as <code>*(a + i)</code>, the expression <code>*arrPtr</code> can also be written as <code>arrPtr[0]</code> (<code>*arrPtr == *(arrPtr + 0) == arrPtr[0]</code>).  So those 
lines could also be written as</p>

<pre><code>arrPtr[0][i].u8Mem1 = some_value;
printf( ""%"" PRIu8 ""\n"", arrPtr[0][j].u8Mem2 );
</code></pre>

<p>As should be evident from those last couple of lines, you normally don't see this form of an array pointer unless you're dealing with multi-dimensional arrays.  Remember our conversion rule, where an expression of type <code>T [N]</code> is converted to an expression of type <code>T *</code>?  Well, replace <code>T</code> with an array type like <code>Q[M]</code>, and we get the conversion from ""N-element array of M-element array of <code>Q</code>"" (<code>Q [N][M]</code>) to ""pointer to M-element array of <code>Q</code>"" (<code>Q (*)[M]</code>):  </p>

<pre><code>tTest sTestStructure[10][20];
tTest (*arrPtr)[20] = sTestStructure;
</code></pre>

<p><hr>
<sup></p>

<ol>
<li>Postfix <code>.</code> has higher precedence than unary <code>*</code>, so <code>*ptr.u8Mem1</code> would be parsed as <code>*(ptr.u8Mem1)</code>, which is not what you want here.
</ol>

<p></sup></p>
",0
34890881,34890747,-1,"<p>The compiler is telling you what the problem is, I'm assuming that somewhere you have a line that looks like</p>

<pre><code>int rate_1_mph, rate_2_mph, distance_total_mile, time_minute;
</code></pre>

<p>Change the int to float.</p>

<p>When you're done with this you need to change all every %d to %f within your printf statements.  %d is actually used for integers, not doubles.</p>
",3
34912470,34912180,1,"<p>As others have pointed out, use the scanf result.
And you don't need to call scanf from 2 locations.
I'd suggest something like this:</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    float sum, smallest, largest, value, average;
    int count;

    for (count = sum = 0; scanf(""%f"", &amp;value) == 1; count++) {
        if (value &lt;= -100000 || value &gt;= 100000)
            break;

        sum += value;

        if (count == 0)
            smallest = largest = value;
        else if (value &gt; largest)
            largest = value;
        else if (value &lt; smallest)
            smallest = value;
    }

    if (count) {
        average = sum / count;
        printf(""%.2f %.2f %.2f\n"", smallest, largest, average);
    } else {
        printf(""error, no data processed\n"");
    }

    return 0;
}
</code></pre>
",0
34912355,34912180,2,"<p>How do you want to handle bad (non-numeric) input?</p>

<p>The simplest approach is probably the following:</p>

<pre><code>while ( scanf( ""%f"", &amp;value ) == 1 &amp;&amp; value &gt;= -100000 &amp;&amp; value &lt;= 100000 )
{
  // do stuff with value
}
</code></pre>

<p>This will loop until <code>value</code> is outside the specified range <em>or</em> <code>scanf</code> fails on input, either because of a matching failure (the input isn't numeric) or because EOF has been signaled, or because of some other input error.  </p>

<p>Note that the <code>&amp;&amp;</code> operator forces left-to-right evaluation; the <code>scanf</code> call will be executed and <code>value</code> updated before either test.  </p>

<p>Also note that if the user types in a number with a non-numeric trailing character like <code>12.3r</code>, <code>scanf</code> will convert and assign <code>12.3</code> to <code>value</code> and leave <code>r</code> stuck in the input stream, which will cause the <em>next</em> call to <code>scanf</code> to fail, at which point the loop will exit.  </p>
",2
34915396,34914634,4,"<p>Structure <em>type</em> declarations do not support initializers, such as you are trying to provide.  Moreover, intializers for structure objects are expressed quite differently than you are trying to do.  Your <code>struct</code> declaration should have this form:</p>

<pre><code>struct validate_acc {
    int user_acc_try;
    int i;
    int user_has_not_entered_right_acc;
    int retries;
};
</code></pre>

<p>That declares a <em>type</em>, not (in itself) any object with associated storage that you could initialize.  That's why you can declare a type alias for it as you have done:</p>

<pre><code>typedef struct validate_acc Validate_acc;
</code></pre>

<p>If you want to perform initialization of objects of that type then you must do it on a per-object basis, like so:</p>

<pre><code>struct validate_acc validate_object = { 0, 0, 1, 3 };
</code></pre>

<p>or, using the <code>typedef</code>ed alias:</p>

<pre><code>validate_acc validate_object = { 0, 0, 1, 3 };
</code></pre>

<p>Perhaps your idea was to provide default values for your structure's members, but C does not have such a feature.  You can create a shortcut initialization macro, however, such as</p>

<pre><code>#define VALIDATE_ACC_DEFAULTS { 0, 0, 1, 3 }
</code></pre>

<p>.  You could then do</p>

<pre><code>struct validate_acc validate_object = VALIDATE_ACC_DEFAULTS;
</code></pre>

<p>That doesn't shorten the code in this case, but it does make it clearer.  Supposing you put the macro definition in the same header is the structure declaration, it also provides a central place where you can change the default initialization values.</p>
",2
38018353,38018307,2,"<p>You don't have a type <code>node</code>. You have a type <code>struct node</code>. So the cast <code>(node*)</code> is invalid. Change it to <code>(struct node*)</code> or better remove it at all as explained in the answers to <a href=""https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc"">this famous question</a>.</p>
",0
34953882,34953873,3,"<p>Your format specifier for <code>double</code> is wrong, it should be <code>""%lf""</code>. But that's not enough, you should also check that <code>scanf()</code> successfuly read read the value, like this</p>

<pre><code>#include &lt;stdio.h&gt;

int report_error(const char *const message)
{
    // TODO: add message formatting capabilities to this function
    fprintf(stderr, ""error: %s\n"", message);
    return EXIT_FAILURE;
}

int main(void)
{
    double celsius = 0;
    double fahrenheit = 0;

    printf(""Enter a temperature in degrees Celsius: "");
    if (scanf(""%lf"", &amp;celsius) != 1)
        return report_error(""Invalid Input"");
    fahrenheit = (5.0 / 9.0) * celsius + 32;
    //                ^ Define this as a constant?

    printf(""That is %.2f Fahrenheit \n"", fahrenheit);
    printf(""Enter a temperature in degrees fahrenheit: "");

    if (scanf(""%lf"", &amp;fahrenheit) != 1)
        return report_error(""Invalid Input"");
    celsius = (fahrenheit - 32) * (5.0 / 9.0);
    //                                 ^ see if it was a constant???

    printf(""That is %.2f Celsius \n"", celsius);
    return 0;
}
</code></pre>

<p>Also, it appears that your algebra went wrong. You should check the <code>celsius</code> expression apparently.</p>
",4
34973797,34973530,0,"<p>Ok, so I compiled the program online <a href=""http://www.tutorialspoint.com/compile_c_online.php"" rel=""nofollow noreferrer"">here</a>, making some changes, as the program you have given only compiles in the old Turbo C.</p>

<p>I compiled the following program:</p>

<pre><code>#include &lt;stdio.h&gt;
//#include &lt;conio.h&gt;
//#include &lt;dos.h&gt;
#include &lt;ctype.h&gt;

 main()
 {

 char name[25], c;
 int a;
 //clrscr();

 printf(""Hello, whats your name? \n"");
 scanf(""%s"",name); //still dont get why it worked without the ""&amp;""//
 printf(""nice to meet you %s!!!\n"");

 printf(""Whats your age?"");
 scanf(""%d"",&amp;a);
     {
      if((a &lt;= 21) &amp;&amp; (a &gt;= 0))
        printf(""Young!\n"");

      else if((a &lt;= 100) &amp;&amp; (a &gt;= 22))
       printf(""old!\n"");

      else
       printf(""that's not an age!\n"");
     }

printf(""whats your favorite color? \n""); //this is where the program stops//
scanf(""%c"",&amp;c);
  switch(c){
    case 'r':printf(""Fiery!"");break;
    case 'o':printf(""oranggerrr!!"");break;  
    // .
     //. //basically applied the whole rainbow and put some reactions// 
     //.
  }

getchar();
return 0;
}
</code></pre>

<p>Okay, so when I executed it, I got a segmentation fault, because of this line:</p>

<pre><code>printf (""nice to meet you %s!!!\n"");
</code></pre>

<p>to</p>

<pre><code>printf (""nice to meet you %s!!!\n"", name);
</code></pre>

<p>Then everything worked perfectly. </p>

<p>Now your doubt:</p>

<ul>
<li><code>scanf (""%s"", name);</code>
<em>That works because name is a char array, and the name of an   array is equal to the address of the first element in that array</em>. Check <a href=""https://stackoverflow.com/questions/34557160/what-will-happen-if-is-not-put-in-a-scanf-statement-in-c#comment56857317_34557176"">this</a> comment. Also, you can see the question.</li>
</ul>

<p>Improvements:</p>

<ul>
<li>Change <code>scanf (""%c"", &amp;c);</code> to <code>scanf ("" %c"", &amp;c);</code></li>
</ul>

<p><strong>NOTE:</strong> I cannot exactly reproduce your problem as I do not have Turbo C. Also, maybe your program crashed because of <code>tolower</code>. Note that <code>tolower</code> return the changed char, so you will have to do: <code>c = tolower (c);</code></p>
",0
35249906,35249853,1,"<p>You should change your question to match the question you are asking in the comments</p>

<p>Answering your question in the comment:</p>

<p>You use <code>atoi()</code> like this:</p>

<pre><code>int main ()
{
  int i;
  char buffer[256];
  printf (""Enter a number: "");
  fgets (buffer, 256, stdin);
  i = atoi (buffer);
  printf (""The value entered is %d. Its double is %d.\n"",i,i*2);
  return 0;
}
</code></pre>

<p>The code will output:</p>

<pre><code>Enter a number: 73
The value entered is 73. Its double is 146
</code></pre>

<p>Another solution is this:</p>

<pre><code>char myarray[5] = {'-', '1', '2', '3', '\0'};
int i;
sscanf(myarray, ""%d"", &amp;i);
</code></pre>

<p><code>i</code> will equal to <code>-123</code>. </p>
",0
35250252,35249853,1,"<p>You were pretty close. Some tweaking only. Here's the corrected code with most of your original logic. Note the addition of an extra boolean inside your parsing function as well as a reversal of the <code>if</code> sense. [please pardon the gratuitous style cleanup]:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stddef.h&gt;
#include &lt;stdlib.h&gt;

char *
ASCIItoInt(char *str, int *integerPtr)
{
    int chr;
    char *cp;
    int valid;

    //printf(""ASCIItoInt: ENTER str=%s"",str);

    *integerPtr = 0;

    valid = 0;
    cp = str;
    for (chr = *cp;  chr != 0;  chr = *++cp) {
        //printf(""ASCIItoInt: chr=%2.2X\n"",chr);

        // is char a digit? bug out if not
        if (! ((chr &gt;= '0') &amp;&amp; (chr &lt;= '9')))
            break;

        *integerPtr *= 10;
        *integerPtr += (chr - '0');

        //printf(""ASCIItoInt: %d\n"",*integerPtr);

        // say we found a valid digit
        valid = 1;
    }

    if (! valid)
        cp = NULL;

    //printf(""ASCIItoInt: EXIT cp='%s'\n"",cp);

    return cp;
}

int
main(int argc,char **argv)
{
    char inputBuffer[1024];
    char *ptr = NULL;
    int integer = 8888;
    FILE *xfin;

    --argc;
    ++argv;

    // need the argv for convenience if using gdb
    if (argc &gt; 0)
        xfin = fopen(*argv,""r"");
    else
        xfin = stdin;

    while (fgets(inputBuffer, sizeof(inputBuffer), xfin)) {
        ptr = inputBuffer;
        int done = 0;

        while (!done) {
            char *newPtr = ASCIItoInt(ptr,&amp;integer);

            if (newPtr == NULL) {
                if (*ptr != '\0')
                    ++ptr;              // Skip over offending character
                else
                    done = 1;
            }
            else {
                printf(""%d\n"", integer);
                ptr = newPtr;
            }
        }
    }

    if (argc &gt; 0)
        fclose(xfin);

    return 0;
}
</code></pre>

<hr>

<p>Here's a way to do it with <code>atoi</code> (using <code>strtol</code> instead because of error checking):</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

int
main(int argc,char **argv)
{
    char inputBuffer[1024];
    char *bp;
    char *cp;
    int integer = 8888;
    FILE *xfin;

    --argc;
    ++argv;

    // need the argv for convenience if using gdb
    if (argc &gt; 0)
        xfin = fopen(*argv,""r"");
    else
        xfin = stdin;

    while (fgets(inputBuffer, sizeof(inputBuffer), xfin)) {
        bp = inputBuffer;

        while (1) {
            cp = strtok(bp,"" \n"");
            bp = NULL;

            // nothing more
            if (cp == NULL)
                break;

            integer = strtol(cp,&amp;cp,10);
            if (*cp != 0) {
                printf(""syntax error\n"");
                continue;
            }

            printf(""%d\n"",integer);
        }
    }

    if (argc &gt; 0)
        fclose(xfin);

    return 0;
}
</code></pre>

<hr>

<p><strong>UPDATE:</strong></p>

<p>Per your request, here's the meaning of <code>%2.2X</code>. Note that the actual interpretation can vary with the conversion specifier [the <code>X</code>], so the authoritative reference is <code>man 3 printf</code></p>

<p>Because the character being tested could be any [8 bit] value [notably newline], we don't want to output with <code>%c</code> as we might get semi-unprintable output, so <code>%2.2X</code> will output a ""zero filled"" 2 digit hexadecimal representation. <em>Note:</em> See below for a better way to output the trace printf</p>

<p>So, a space is <code>20</code>, a <code>q</code> is <code>61</code>, a <code>0</code> is <code>30</code> and newline is <code>0A</code>.</p>

<p>In general, for a format of <code>%w.pX</code>:</p>

<p><code>w</code> is the ""field width"" [the <em>minimum</em> number of characters that the field should occupy]</p>

<p><code>p</code> is the ""precision"". For the <code>X</code> conversion [and <code>d</code>], this is the <em>minimum</em> number of digits. For newline, since it's a value of <code>0x0A</code> [decimal 10], with a field width of <code>2</code>, it must be zero padded [on the left].</p>

<p>For hex, we could have <code>%2.2X</code> or <code>%2.2x</code>. This controls uppercase/lowercase [respectively] for our output.</p>

<p>Here are some formats and their outputs. The quotes are added to make it easy to see how much space the format is actually using. I've added some decimal formats for comparison</p>

<pre><code>%X          --&gt;  'A'
%2X         --&gt;  ' A'
%2.2X       --&gt;  '0A'
%02X        --&gt;  '0A'
%2.2x       --&gt;  '0a'

%d          --&gt;  '1'
%10d        --&gt;  '         1'
%10.10d     --&gt;  '0000000001'
%10.9d      --&gt;  ' 000000001'
%10.7d      --&gt;  '   0000001'

%d          --&gt;  '37'
%10d        --&gt;  '        37'
%10.10d     --&gt;  '0000000037'
%10.9d      --&gt;  ' 000000037'
%10.7d      --&gt;  '   0000037'

%d          --&gt;  '289'
%10d        --&gt;  '       289'
%10.10d     --&gt;  '0000000289'
%10.9d      --&gt;  ' 000000289'
%10.7d      --&gt;  '   0000289'

%d          --&gt;  '1096'
%10d        --&gt;  '      1096'
%10.10d     --&gt;  '0000001096'
%10.9d      --&gt;  ' 000001096'
%10.7d      --&gt;  '   0001096'

%d          --&gt;  '28492'
%10d        --&gt;  '     28492'
%10.10d     --&gt;  '0000028492'
%10.9d      --&gt;  ' 000028492'
%10.7d      --&gt;  '   0028492'

%d          --&gt;  '137862923653'
%10d        --&gt;  '137862923653'
%10.10d     --&gt;  '137862923653'
%10.9d      --&gt;  '137862923653'
%10.7d      --&gt;  '137862923653'
</code></pre>

<p>I would be remiss if I didn't include a better way to output the debugging <code>printf</code>:</p>

<pre><code>int
isprintable(int chr)
{
    return (chr &gt;= 0x20) &amp;&amp; (chr &lt;= 0x7E);
}

printf(""DEBUG: chr=%2.2X/'%c'\n"",chr,isprintable(chr) ? chr : '.');
</code></pre>
",1
35243615,35242061,0,"<p>use <code>getchar()</code> from the standard libraries instead of <code>getch()</code><br>
If you want to  to use <code>getch()</code> include <code>#include &lt;curses.h&gt;</code> on unix or <code>#include &lt;conio.h&gt;</code> on windows.</p>
",0
35242127,35242061,1,"<p><code>getch()</code> is not an ANSI C function. You need to include the header file <code>&lt;conio.h&gt;</code> to use it. Or best of all, just use the ANSI conformant function <code>getchar()</code>.</p>
",4
39132179,39131805,3,"<p>What you have doesn't produce the right output at all!</p>

<p>The following is portable:</p>

<pre><code>#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

uint8_t* pack_uint8(uint8_t* dest, uint8_t src) {
   *(dest++) = src;
   return dest;
}

uint8_t* pack_uint32be(uint8_t* dest, uint32_t src) {
   *(dest++) = src &gt;&gt; 24;
   *(dest++) = (src &gt;&gt; 16) &amp; 0xFF;
   *(dest++) = (src &gt;&gt; 8) &amp; 0xFF;
   *(dest++) = src &amp; 0xFF;
   return dest;
}

uint8_t* build_packet(
   uint8_t maj_version,
   uint8_t min_version,
   uint8_t type,
   uint8_t seq,
   uint8_t flags,
   uint32_t session_id,
   uint32_t body_length,
   const uint8_t* body
) {
   uint8_t* packet = malloc(12 + body_length);
   uint8_t* p = packet;
   p = pack_uint8(p, ( maj_version &lt;&lt; 4 ) | min_version);
   p = pack_uint8(p, type);
   p = pack_uint8(p, seq);
   p = pack_uint8(p, flags);
   p = pack_uint32be(p, session_id);
   p = pack_uint32be(p, body_length);
   memcpy(p, body, body_length);
   return packet;
}
</code></pre>
",3
35211399,35211355,4,"<p>Try this:</p>

<pre><code>int main()
{
    srand(time(0));
    int percent = rand() % 100;

    if (percent &lt; 25) {
        printf(""horse\n"");
    } else if (percent &lt; 75) {
        printf(""dog\n"");
    } else {
        printf(""cat\n"");
    }

    return 0;
}
</code></pre>

<p>The problem with your code is that you are ""rolling"" for each outcome. That makes all the outcomes independent of each other. What I've done above is roll the random number once. Then we look at the cumulative probability for each outcome. This insures exactly one outcome will run. Also notice the use of <code>else if</code>.</p>
",5
35215475,35215363,0,"<p>It depends on whether the numbers are signed or unsigned.</p>

<p>If both operands are unsigned, overflow will wrap back around to 0.  </p>

<p>If one or both operands are signed, the behavior is implementation defined, however most implementations represent signed integers in 2's complement, so in those cases positive overflow will wrap around to the negative side, and negative overflow will wrap around to the positive side.</p>

<p>In the case of unsigned overflow, the result will be less than at least one operand, so you can test for it this way:</p>

<pre><code>if ((x + y &lt; x) || (x + y &lt; y) {
    printf(""overflow\n"");
}
</code></pre>

<p>In the signed case, you first need to check whether both are positive (and check for negative wraparound) or both are negative (and check for positive wraparound):</p>

<pre><code>if ((x &gt; 0) &amp;&amp; (y &gt; 0) &amp;&amp; ((x + y &lt; x) || (x + y &lt; y))) {
    printf(""negative overflow\n"");
}
if ((x &lt; 0) &amp;&amp; (y &lt; 0) &amp;&amp; ((x + y &gt; x) || (x + y &gt; y))) {
    printf(""positive overflow\n"");
}
</code></pre>

<p>As I mentioned before, the signed case is implementation defined, and the above will only work if signed integers are represented as 2's complement.  In practice however, this will typically be the case.</p>

<p>This should give you an idea of how overflow works, although it doesn't use only the specific operators you mentioned.  With this, you should be able to figure out how to use those other operators to achieve what the expressions above do.</p>
",3
35215534,35215363,-1,"<p>As pointed by many peoples, it is not right for signed... 
So I changed it for unsigned first.</p>

<p>You need to calculate part by part. </p>

<p>Since you didn't tell us the data type, I assumed it is 4 byte unsigned data.</p>

<pre><code>unsigned long x, unsigned long y;
// x = ...
// y = ...
unsigned long first_byte_x = (x &amp; 0xFF000000) &gt;&gt; 24;
unsigned long first_byte_y = (y &amp; 0xFF000000) &gt;&gt; 24;
unsigned long other_bytes_x = x &amp; 0x00FFFFFF;
unsigned long other_bytes_y = y &amp; 0x00FFFFFF;
unsigned long other_bytes_sum = other_bytes_x + other_bytes_y;
unsigned long carry = (other_bytes_sum &amp; 0xFF000000) &gt;&gt; 24;
unsigned long first_byte_sum = first_byte_x + first_byte_y + carry;
if (first_byte_sum &gt; 0xFF)
    // overflow
else
    // not overflow
</code></pre>

<p>If you can use mod(%), then it will be more simple.</p>

<p>*It looks like a homework so I hoped you considered enough before your asking...</p>
",2
35215580,35215363,0,"<p>With signed integer math, unless you have access to the limits like <code>INT_MAX INT_MIN</code>, there is <strong>no</strong> answer that gets around undefined behavior.</p>

<pre><code>#include &lt;limits.h&gt;

int is_overflow_add_signed(int a, int b) {
  // This uses -, so does not meet OP's goal.
  // Available as a guide
  return (a &lt; 0) ? (b &lt; INT_MIN - a) : (b &gt; INT_MAX - a);
}
</code></pre>

<p>With unsigned math, simply  see if the result ""wrapped"" around.</p>

<pre><code>int is_overflow_add_unsigned(unsigned a, unsigned b) {
  return (a + b) &lt; a;
}
</code></pre>
",0
35220461,35220400,2,"<p>You haven't allocated any storage for the actual strings - <code>char *name[2]</code> is just an array of two uninitialised pointers. Try:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    char name[2][80];
    scanf(""%s"", name[0]);
    printf(""%s"", name[0]);
    return 0;
}
</code></pre>

<p>or, if it really does need to be <code>char *name[2]</code>, then you can allocate memory dynamically:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    char *name[2];
    name[0] = malloc(80);  // allocate memory for name[0] (NB: name[1] left uninitialised)
    scanf(""%s"", name[0]);
    printf(""%s"", name[0]);
    free(name[0]);         // free memory allocated for name[0]
    return 0;
}
</code></pre>
",0
35220515,35220400,0,"<pre><code>char *name[2];
</code></pre>

<p>You have 2 pointers which are of type <code>char</code></p>

<p>Allocate memory to the pointer using <code>malloc()</code> or any of its family membres.</p>

<pre><code>name[0] = malloc(20);
</code></pre>
",0
35263937,35263850,2,"<p>Your for loops should start from <code>i = 0</code> and <code>j = 0</code> respectively.</p>
",0
35263974,35263850,0,"<p>As Holsetly pointed out, C is 0-based.</p>

<p>So you need to make the following changes.</p>

<pre><code>for(i = 0; i &lt; 18; i++){
    for(j = 0; j &lt; 16; j++){
        A[i][j] = i + j + 2;    // Add 1 for i, 1 for j
        printf(""%d "", A[i][j]);
    } // End inner loop
    printf(""\n"");
} // End outer loop
</code></pre>

<p>Similarly, make changes for the other loop.</p>

<p>Edit: For the second loop, you need to add 3, to <code>i + 2j</code> to get the proper answer.</p>
",0
35288196,35287940,4,"<p>You are resetting values of ""i"" and ""j"" to zero in the function.
static variables are initialized only once in the declaration statement.
Initialize the variables like this :</p>

<pre><code>static int i=0, k=0;
</code></pre>

<p>You can also do away with initializing static variables to 0 as it would be done automatically. But it is a good programming practice to initialize variables during declaration.</p>
",3
35289822,35287940,0,"<p>See @vikas answer, however, that will work only one time as to reverse a second string, i and k must be reset again. The following does that:</p>

<pre><code>static int i, k;
void reverse(char s[]);

int main(void)
{
    char s[]=""hello world"";

    i= k= 0;
    reverse(s);

    return 0;
}

void reverse(char s[])
{
     int c;
     if ((c = s[i]) != '\0')
     {
          i++;
          reverse(s);
     }
     if (c != '\0')
          s[k++] = c;
}
</code></pre>
",9
37760701,37760672,1,"<p>Standard qsort routines always sort array <em>lines</em>, and you define a callback comparison function (and pass its address), which is completely under your control.</p>

<p>In that callback function, qsort will pass you two elements (rows) and ask you for comparison, and you return 1, 0, -1 for greater, equal, smaller accordingly. You can in that code compare only the columns you want to sort on (or do about anything fancy you want), and qsort will always sort the whole array lines.</p>
",0
37760868,37760672,0,"<p>How about this: you have a <code>struct</code> with a key and value pair, build an array of this <code>struct</code>, populate the elements as desired and then use a callback function as suggested by Aganju. Thus, you would have an array of <code>struct</code>s which are sorted.</p>
",1
36249777,36249371,0,"<p>In principle your solution looks very good. I don't understand completely if for the larger files you are intending to process them in chunks or as a whole. From my experience I suggest that you assign as large as possible blocks to the slaves. This way the rather expensive message passing operations are executed only very seldom.</p>

<p>What I cannot understand in your question is what the overall goal of your program is. Is it your intention to sort the complete input files in parallel? If this is the case you will need some sort of merge sort to be applied to the results you receive from the individual processes.</p>
",1
36269659,36249371,1,"<p>For this answer I am going to stick with the assumption that this should be done with Quicksort, and that the data is read on a single process. Just  keep in mind that there are <a href=""https://stackoverflow.com/a/3969847/620382"">many sophisticated parallel sorting techniques</a>.</p>

<p>Your idea of separating the numbers by subsets is problematic, because it makes assumptions about the shape of data. For non-uniformly distributed data sets it won't even help to know the minimum and maximum. It is better to simply send out equal amount of numbers to each process, let them sort and afterwards merge the data.</p>

<p>For the merge you start with <code>ntasks</code> sorted sub-lists and want to end up with a single one. A naive merge would repeatedly look for the minimal element in each sub-list, remove that and append it to the final list. This needs <code>ntasks</code> * <code>N</code> comparisons, <code>N</code> swaps and <code>N * 2</code> memory. You can optimize the comparisons to <code>log2(ntasks) * N</code> by doing an actual merge sort, but that also needs <code>log2(ntasks) * N</code> swaps. You can further refine that by keeping the sub-lists (or pointers to their first element) in a <a href=""https://en.wikipedia.org/wiki/Priority_queue"" rel=""nofollow noreferrer"">priority queue</a>, which should give you <code>log2(ntasks) * N</code> comparisons and <code>N</code> swaps.</p>

<p>About the usage of MPI:</p>

<ol>
<li>Do not use <code>MPI_Isend</code> &amp; <code>MPI_Wait</code> right after each other. In this case use <code>MPI_Send</code> instead. Use the immediate variants only if you can actually do something useful between the <code>MPI_Isend</code> and <code>MPI_Wait</code>.</li>
<li>Use collective operations whenever possible. To distribute data from the root to all slaves, use <code>MPI_Scatter</code> or <code>MPI_Scatterv</code>. The first requires all ranks to receive the same number of elements, which can also be achieved by padding. To collect data from the slaves in the master, use <code>MPI_Gather</code> or <code>MPI_Gatherv</code>.<sup>1</sup> Collectives are more easy to get right, because they describe the high level operation. Their implementation is usually highly optimized.</li>
<li>To receive an unknown-size message, you can also send the message directly and use <code>MPI_Probe</code> at the receiver side to determine the size. You are even allowed to <code>MPI_Recv</code> with a buffer that is <em>larger</em> than the sent buffer, if you know an upper bound.</li>
</ol>

<p><sup>1</sup> You could also consider the merge step as a reduction and parallelize the necessary computation for that.</p>
",6
40993315,40992980,3,"<p>Well, you can't just magically go from the string <code>sin</code> to calculating the sine function. You have to write code to do that.</p>

<p>I'd recommend splitting the input into tokens (perhaps just using <code>strtok()</code> in a loop), then inspecting each token.</p>

<p>For numbers, push the numbers onto your stack (I assume you want a stack since you mention the functions/operators being postfix).</p>

<p>For strings (names of functions), look them up in a hardcoded table or <code>if</code>-series and do the evaluation.</p>

<p>Something like:</p>

<pre><code>char **tokens = ... // NULL-terminated list of input tokens
int i = 0;
while(tokens[i] != NULL)
{
  if(isdigit(tokens[i][0]))
  {
    stack_push(strtol(token, NULL, 10));
  }
  else if(strcmp(tokens[i], ""sin"") == 0)
  {
    stack_push(sin(stack_pop()));
  }
  else if ...
}
</code></pre>

<p>Note that this is very rough, only intended to give an outline of how this can be solved.</p>
",0
40999010,40992980,0,"<p>You have two questions. One:</p>

<blockquote>
  <p>how can I read sin,log etc. from file</p>
</blockquote>

<p>The other:</p>

<blockquote>
  <p>how can I ... put them into array</p>
</blockquote>

<hr>

<p>First question: reading from file. Use <code>strtok</code> to separate a line of text into ""words"". Use <code>strcmp</code> to examine the function name.</p>

<pre><code>int main(){
    char str[] = ""2 3 +"";
    char *p;
    for (p = strtok(str, "" ""); p != NULL; p = strtok(NULL, "" "")) {
        if (isdigit(*p)) { // it's a number
            long val = strtol(p, &amp;p, 10); 
            printf(""%ld\n"", val);
        } else { // it's a name of a function
            if (strcmp(p, ""+"") == 0)
                puts(""Add"");
            else if (strcmp(p, ""-"") == 0)
                puts(""Subtract"");
            else if (strcmp(p, ""sin"") == 0)
                puts(""Sine"");
            else if (strcmp(p, ""log"") == 0)
                puts(""Logarithm"");
            else if ...
            ...
            else
                fputs(""Error!"", stderr);
        }
    }
}
</code></pre>

<hr>

<p>Second question: adding to an array. I recommend using a <a href=""https://en.wikipedia.org/wiki/Tagged_union"" rel=""nofollow noreferrer"">tagged union</a>:</p>

<pre><code>enum type {CONSTANT, UNARY_FUNCTION, BINARY_FUNCTION, X};

struct operation
{
    enum type type;
    union {
        double val;
        double (*func1)(double); // a pointer to a function with 1 argument
        double (*func2)(double, double); // a pointer to a function with 2 arguments
    };
};
</code></pre>

<p>Here, there are 4 possible types for an ""operation"" - it can be a number, an unary function (like <code>sin</code>), a binary function (like <code>+</code>) or an independent variable <code>x</code>.</p>

<p>To convert a token <code>p</code> to an <code>operation</code>:</p>

<pre><code>char *p;
struct operation o;
...
if (isdigit(*p)) { // it's a number
    o.type = CONSTANT;
    o.val = strtol(p, &amp;p, 10); 
} else { // it's a name of a function or ""x""
    if (strcmp(p, ""x"") == 0)
    {
        o.type = X;
    }
    else if (strcmp(p, ""+"") == 0)
    {
        o.type = BINARY_FUNCTION;
        o.func2 = plus;
    }
    else if (strcmp(p, ""sin"") == 0)
    {
        o.type = UNARY_FUNCTION;
        o.func1 = sin;
    }
    else if (strcmp(p, ""log"") == 0)
    {
        o.type = UNARY_FUNCTION;
        o.func1 = log;
    }
    ...
}
</code></pre>

<p>Here the function <code>plus</code> adds two numbers. Standard library doesn't have it (unlike <code>sin</code>, which it has), so I have to define it by myself:</p>

<pre><code>double plus(double x, double y) {return x + y;}
</code></pre>

<p>Finally, if you have an array of <code>operation</code> objects:</p>

<pre><code>struct operation my_array[1000];
</code></pre>

<p>you can add objects to the array:</p>

<pre><code>struct operation my_array[1000];
size_t my_array_size = 0;

for (...)
{
    ... // parse input file
    struct operation o;
    ... // parse individual token and convert it to an ""operation""
    my_array[my_array_size++] = o; // add to the array
}
</code></pre>

<hr>

<p>The main part of the program is using the array to calculate the value of the encoded function for any value of <code>x</code>. Now that you have your function encoded as an array of operations, the calculation itself will be easy. Just make a temporary stack of values, and apply each operation.</p>
",2
36812562,36812248,0,"<p>If I understand your question correctly, you want to have a lot of <code>struct element</code>, where <code>sizeof(struct element)</code> is quite big, and you want to add and remove them dynamically during your program.</p>

<p>That means you want to allocate and deallocate memory for them dynamically, so you want to use <code>malloc()</code> and <code>free()</code> and you will be working with <code>struct elem *</code>s. Now the data structure to keep your pointers in depends on the operations you will perform on the data.</p>

<p>If you don't need to search in the elements (or if you never have a lot of them at one point), if it's enough just to iterate through them, a <a href=""https://en.wikipedia.org/wiki/Linked_list"" rel=""nofollow"">Linked list</a> is appropriate. It allows you to dynamically add and remove elements and it is memory-efficient.</p>

<p>If you need to search in the elements, but using just one variable, you can put your pointers into a <a href=""https://en.wikipedia.org/wiki/Binary_tree"" rel=""nofollow"">binary tree</a> (or a <a href=""https://en.wikipedia.org/wiki/Hash_table"" rel=""nofollow"">hash table</a>).</p>

<p>Otherwise (if you need to search in the data using multiple variables), you should probably keep them in linked list and construct binary-tree or hash-table <a href=""https://en.wikipedia.org/wiki/Database_index"" rel=""nofollow"">index</a> to speed-up searches over often searched variables.</p>

<p>But at that point, you might consider using some existing DBMS.</p>
",2
38500752,38157133,0,"<p><code>char *d = malloc (strlen (s));</code> is wrong. You need <code>char *d = malloc (strlen (s) + 1);</code>. That needs to be fixed first. It may or may not resolve other errors. ¨C R Sahu</p>
",0
38192652,38192560,2,"<p>Issue 1:
Your problem is you're trying to compile code originally written for MS-DOS/Windows terminal on osx. The <code>conio.h</code> is a header that provides terminal user interfaces for MS-DOS.  </p>

<p>You can fix your problem by replacing it with the <code>curses</code> lib</p>

<p>Issue 2:
The signature for main should be <code>int main(int argc, char** argv)</code></p>

<p>Issue 3: Probably related to issue 1, <code>conio.h</code> is not available so the declarations for its functions, including <code>fetch</code> are not available</p>
",3
36237819,36237648,2,"<p>You may use the sleep() function right before writing any line.
EDIT: you need to include:</p>

<p>In Windows</p>

<pre><code>#include &lt;windows.h&gt;  
Sleep(&lt;timeInMs&gt;);
</code></pre>

<p>In Unix</p>

<pre><code>#include &lt;unistd.h&gt;
sleep(&lt;timeInSeconds&gt;);
</code></pre>
",5
36252443,36251796,3,"<p><code>ini_parse()</code> is defined in ini.c, so you need to compile that as well. Assuming it's in the same directory as ini.h, you should be able to compile everything like this:</p>

<pre><code>cc -Wall -o dump ../ini.c ini_dump.c
</code></pre>
",0
38190624,38190595,1,"<p>You may want to delete the first node, then apply the algorithm to the remaining linked list. This is one way it should work, and it's the simplest in my view.</p>
",6
38191186,38190595,2,"<p>You can free first node and get the new head outside the while loop. Then free all alternative node inside the while loop.</p>

<p>I have slightly changed the code. </p>

<pre><code>struct node *deleteEveryOther(struct node *head) 
{ 
    struct node *forward, *current;

    /* If empty list */
    if (head == NULL)
            return NULL;

    /* Free first element */
    current = head;
    forward = head-&gt;next;
    free(current);

    /* Get new head */
    current = forward;
    head = current;

    /* Now remove all next elements */
    while (current != NULL) {
            forward = current-&gt;next; 
            if (forward != NULL) {
                    current-&gt;next = forward-&gt;next;
                    free(forward);
            }
            current = current-&gt;next;
    }

    /* Return new head */
    return head;
}
</code></pre>

<p>In your code, there are few mistakes. Like you are not updating new <code>head</code>, but returning same old <code>head</code>. Also you were dereferencing  some pointers without checking if they are <code>NULL</code> (in your printf statements).</p>

<p>This can also be done recursively. In you version, you are not returning head, (a <code>void</code> function), which is an issue. There are few other issues as well. You can compare below code with your code and see the differences. </p>

<pre><code>/* deleteEveryOtherRecursively: recursively delete odd numbered nodes */
struct node *deleteEveryOtherRecursively(struct node *head) 
{ 
    struct node *forward;

    /* Base case    */
    if (head == NULL)
            return NULL;

    forward = head-&gt;next; /* Get the next node in forward */ 
    free(head);           /* free old head */
    head = forward;       /* new head points to next elem */

    if (head != NULL)     /* recur down if needed */
            head-&gt;next = deleteEveryOtherRecursively(head-&gt;next);

    return head;          /* return new head */
}
</code></pre>
",14
38412622,38412560,5,"<p>If you see e.g. <a href=""http://en.cppreference.com/w/c/language/floating_constant"" rel=""nofollow"">this floating point literal reference</a> you will see that hexadecimal floating point values need the <code>p</code> or <code>P</code> infix to denote the exponent.</p>

<p>So the definition should look like</p>

<pre><code>float x = 0X2ap10;
</code></pre>
",4
38412624,38412560,5,"<p>Hex floats use <code>p</code> as the exponent marker:</p>

<pre><code>float x = 0x2ap+10;
</code></pre>

<p>That's actually a <code>double</code> value, though. If you want a <code>float</code> literal, you need an <code>f</code> suffix:</p>

<pre><code>float x = 0x2ap+10f;
</code></pre>
",0
38412694,38412560,16,"<p><code>0X2aE+10</code> is a valid preprocessor token that does not translate into a valid C token, hence the compilation error.  C99 Hexadecimal floating point numbers use <code>P</code> or <code>p</code> as the exponent marker, as in:</p>

<pre><code>float x = 0X2aP+10;
</code></pre>

<p>Which has the value <code>0x2a * 1024</code> -> <code>43008</code>.</p>

<p>For those who do not know about preprocessing numbers:</p>

<blockquote>
  <p><strong>6.4.8 Preprocessing numbers</strong></p>
  
  <p><strong>Syntax</strong></p>

<pre><code>pp-number:
      digit
      . digit
      pp-number digit
      pp-number identifier-nondigit
      pp-number e sign
      pp-number E sign
      pp-number p sign
      pp-number P sign
      pp-number .
</code></pre>
  
  <p><strong>Description</strong></p>
  
  <p>A preprocessing number begins with a digit optionally preceded by a period (.) and may be followed by valid identifier characters and the character sequences <code>e+</code>, <code>e-</code>, <code>E+</code>, <code>E-</code>, <code>p+</code>, <code>p-</code>, <code>P+</code>, or <code>P-</code>.</p>
  
  <p>Preprocessing number tokens lexically include all floating and integer constant tokens.</p>
  
  <p><strong>Semantics</strong></p>
  
  <p>A preprocessing number does not have type or a value; it acquires both after a successful conversion (as part of translation phase 7) to a floating constant token or an integer constant token.</p>
</blockquote>
",0
36451725,36449837,0,"<p>Minus other advice already given:</p>

<pre><code>        if ((a &gt; b) &amp;&amp; (a &gt; c)) {
            printf(""\n The greatest number is =%d"",a);
        }
        else {
            if ((b &gt; a) &amp;&amp; (b &gt; c)) {
                printf(""\n The greatest number is =%d"",b);
            }
            else {
                printf(""\nThe greatest number=%d"",c);
            }
        }
</code></pre>

<p>C is one of those languages designed to minimize the keystrokes needed to express something, as though that were some kind of efficiency. However it causes the language to be relatively difficult to understand if the reader is not already familiar with the algorithm expressed. Thus the importance of proper and consistent formatting, which eliminates a level of analysis otherwise required.</p>

<p>(Actually, the human mind welcomes some redundancy in written expressions so it can verify its projections of meaning as it reads along. A few more keystrokes, as in Pascal for instance, enables the unfamiliar reader to more quickly comprehend the coder's intent.)</p>
",0
36500551,36500446,5,"<p>You want to use <code>scandir</code>.  From the <a href=""http://linux.die.net/man/3/scandir"">man page</a>:</p>

<blockquote>
<pre><code>   int scandir(const char *dir, struct dirent ***namelist,
          int(*filter)(const struct dirent *),
          int(*compar)(const struct dirent **, const struct dirent **));

   int alphasort(const void *a, const void *b);
   int versionsort(const void *a, const void *b);
</code></pre>
  
  <p>The scandir() function scans the directory  dir,  calling  filter()
  on    each  directory entry.  Entries for which filter() returns
  non-zero are    stored in strings allocated via malloc(), sorted using
  qsort() with the    comparison  function compar(), and collected in
  array namelist which is    allocated via malloc().  If filter is NULL,
  all entries are selected.</p>
  
  <p>The alphasort() and versionsort() functions can be used as the
  comparison  function  compar().  The former sorts directory entries
  using strcoll(3), the latter using strverscmp(3) on the strings
  (*a)->d_name and    (*b)->d_name.</p>
</blockquote>
",2
36784351,36784322,2,"<p>You're not allowed to perform arithmetic on void pointers in C. So the following code is illegal:</p>

<pre><code>void *foo = whatever;
foo + 1;
</code></pre>

<p>By casting <code>foo</code> to a <code>char *</code>, she can perform arithmetic on the pointer.</p>
",1
36784834,36784322,0,"<p>My comments are on why <code>void *ptr</code>, one cannot perform address arithmetic.  Warning , Long rambling :). </p>

<p>In general
when you do  a ptr arithmetic like </p>

<pre><code>ptr  = ptr + N ; 
</code></pre>

<p>The interpretation by  C is to perform the following equivalent integer arithmetic  (Infact the compiler will  produce assembly code equivalent to below integer arithmetic)</p>

<p><strong>ptr = ptr + N* sizeof (typeof(*N)) ;</strong> </p>

<p>Hence  The compiler has to know the typeof (*N) for it to produce code. typeof (*N) here means, the type of variable ""ptr"" points to. (typeof is not a standard c construct, it is being bought here for mere explanation). </p>

<p>Take an e.g. </p>

<pre><code>int x ;  // Assume x is at addesss 1000
int *ptr =  &amp;x ; // ptr has a value of 1000
</code></pre>

<p>Then 
ptr = ptr + 1 ;<br>
would make ptr as 1004 during run time (assuming size of int is 4 bytes)</p>

<p>Explanation-1: The above statement means that ptr should  contain the address of next integer variable after ptr.  Since ptr  points to x , which is at address 1000, the next integer variable after 1000 would be 1004. So ptr would be 1004. </p>

<p>Explanation-2 This is also in sync with the interpretation of  ptr = ptr +N is equivalent  to  integer arithmeitc</p>

<pre><code>ptr = ptr + N* sizeof (typeof(*N)) ; // typeof (*N)-&gt;int
           //  =&gt; 1000 + 1 *sizeof (typeof (int))
                               //  =&gt; 1004
</code></pre>

<p>To summarize For the ptr arith operation </p>

<pre><code>ptr = ptr  + N ;
</code></pre>

<p>the compiler produces an equivalent assembly code as</p>

<p>ptr = ptr + N* sizeof (typeof(*N)) // Compiler Needs to typeof(*N)</p>

<p><strong>Hence the compiler needs to know what is the  data-type that ptr is pointing to</strong>.</p>

<p>Now consider  </p>

<pre><code>void foo (int type, void *ptr) {

    ptr = ptr + 2 ;
}
f2() {
int x ;
char c ;
f1(&amp;x) ;
f1(&amp;c);
} 
</code></pre>

<p>The void * ptr is a generic ptr pointing to an addresss.  When called with f1(&amp;x) the ptr points to an address of integer, when called with f1(&amp;c) it points to address of a character. So at compile time , compiler cannot determine what is the typeof  (*ptr). (for in one case it is integer and another is character).   Hence it is not possible for the compiler to generate code for
    ptr = ptr + n ;</p>

<p>So you will have to cast the ptr of being a particular known type and then do arithmetic operation. </p>

<p>Hope this helps. </p>
",0
37759500,37759477,1,"<p>Simple error!</p>

<p>Printing the value of &amp;students or &amp;assignments is not correct. That would print value of the pointer to that variable. You need the following code:      </p>

<pre><code>    printf (""How many students?\n "");
    fscanf (inputFile, ""%d"", &amp;students);
    printf (""%d"", students); // not &amp;students
    printf (""\nHow many assignments?\n "");
    fscanf (inputFile, ""%d"", &amp;assignments);
    printf (""%d"", assignments); // not &amp;assignments
    printf (""\n"");
</code></pre>
",1
42505778,42505493,1,"<p>From <a href=""http://man7.org/linux/man-pages/man3/fopen.3.html"" rel=""nofollow noreferrer"">Man Page</a> <code>w+</code> flag: <br></p>

<blockquote>
  <p>Open for reading and writing.  The file is created if it does
                not exist, otherwise it is truncated.</p>
</blockquote>

<p>You are probably trying to open a file which doesn't exist at the path you provided, or is <code>read-only</code> as @WhozCraig suggested in comment. This means a new file is being created, an empty file! hence you are seeing <code>0</code> bytes read.</p>

<p>To sum up, The <code>fopen</code> is failing, in that case you need to check the return value if it is equal to <code>-1</code>. <br>
To find what was the error, you can check the <code>errno</code> as it is set to
indicate the error.</p>

<p>If you are only intending to read, open the file with <code>r</code> flag instead of <code>w+</code></p>
",2
42506832,42505493,2,"<p>The problem is that you open the file with the <code>w+</code> mode. There are two possibilities:</p>

<ul>
<li>if the file doesn't exist, it will be created empty. Reading from it immediately gives end of file resulting in <code>fread()</code> returning 0.</li>
<li>if the file <em>does</em> exist, it will be truncated i.e. changed into an empty file. Reading from it immediately gives end of file resulting in <code>fread()</code> returning 0.</li>
</ul>

<p>If you just want to read from the file (as per your example), open it in mode <code>r</code>. If you want to read and write without destroying its existing content, use mode <code>r+</code>. </p>

<p>Whatever mode you choose, always check that <code>fopen()</code> returns non null and print the error if it returns null (this is not the cause of your problem but is best practice).</p>
",0
42508811,42505493,1,"<p>The problem lies within this line of code:</p>

<pre><code>fp = fopen(""test.txt"",""w+"") 
</code></pre>

<p>the <code>""w+""</code> mode, clear the previous content of the file and the file will be empty when you just going to read the file without writing anything to it. Hence, it is printing <code>""Read could not happen""</code> because you are trying to read an empty file.</p>

<p>I would suggest you to use <code>""r+""</code> mode, if you are willing to read and then write into the file. Otherwise, <code>r</code> mode is good enough for simple reading of a file.</p>
",0
42468814,42467240,2,"<p>Here is a simple solution that generates the 362880 permutations in lexicographical order:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void perm9(char *dest, int i) {
    if (i == 9) {
        printf(""%.9s\n"", dest);
    } else {
        for (char c = '1'; c &lt;= '9'; c++) {
            if (memchr(dest, c, i) == NULL) {
                dest[i] = c;
                perm9(dest, i + 1);
            }
        }
    }
}

int main(void) {
    char dest[9];
    perm9(dest, 0);
    return 0;
}
</code></pre>
",0
38294522,38292101,0,"<p>If you initialize your structure array <code>hello</code> correctly, the errors you are facing should disappear.  The way you initialize it currently is <em>very</em> confusing, as the compiler tells you:</p>

<blockquote>
  <p>warning: (<strong>near initialization</strong> for ¡®hello[0].somechars¡¯) [enabled by default]</p>
</blockquote>

<p>Meaning that there is an error with the way you initialize your structure array (<a href=""https://stackoverflow.com/questions/23415158/what-is-near-initialization"">see here</a> to fully understand the grammar involved in the error).  Your second error:</p>

<blockquote>
  <p>warning: initialization makes pointer from integer without a cast</p>
</blockquote>

<p>The compiler is also confused in your initialization of your structure array.  Take, for example, this initialization:</p>

<pre><code>struct my_struct {
   int a;
   int b;
}
//Create a structure assigning the value of a to 10 and b to 20:
struct my_struct foo = {10, 20};
</code></pre>

<p>This will initialize <em>one</em> structure, not multiple.  If you wanted to use a similar syntax creating an array of structures, you could do something like this:</p>

<pre><code>//Use my_struct from the previous example
struct my_struct foo[] {
   {.a = 10, .b = 20},
   {.a = 1, .b = 2},
   {.a = 5, .b = 5}
};
</code></pre>

<p>To understand this syntax further, see <a href=""https://stackoverflow.com/questions/330793/how-to-initialize-a-struct-in-accordance-with-c-programming-language-standards"">designated initializers</a>.  The syntax above creates an array of structures with these members for each structure in the array:</p>

<pre><code>foo[0].a = 10;
foo[0].b = 20;

foo[1].a = 1;
foo[1].b = 2;

foo[2].a = 5;
foo[2].b = 5;
</code></pre>

<p>Initialize <code>struct stack_base hello[]</code> to have these values for each member:</p>

<pre><code>//hello[0].somechars will be assigned the string ""hello""
hello[0].achar = 'a';
hello[0].anint = 1;
hello[0].afloat = 1.0;
hello[0].abool = 0;

//hello[1].somechars will be assigned the string ""bye bye""
hello[1].achar = 'b';
hello[1].anint = 2;
hello[1].afloat = 10.0;
hello[1].abool = 1;
</code></pre>

<p>Then, you could write:</p>

<pre><code>struct stack_base hello[] {
   {.achar = 'a', .anint = 1, .afloat = 1.0, .abool = 0},
   {.achar = 'b', .anint = 2, .afloat = 10.0, .abool = 1}
};

//Assign strings to achar
strcpy(hello[0].somechars, ""hello"");
strcpy(hello[1].somechars, ""bye bye"");
</code></pre>

<p>In the example above, instead of assigning exact values to each member of the structure, it would make sense for you to replace the assignments to each member with the constants.  For example, you might replace <code>.anint = 1</code> with <code>.anint = BCONST</code>, etc. </p>

<p>Currently, however, it is simply confusing the way you have initialized your structure array.</p>
",1
38295555,38292101,1,"<p>The structure member initialization in your main function is different from you structure definition.
You structure member should be initialized like this.</p>

<pre><code>struct stack_base hello[] = {
        {
            ""hey there"",'a',22,11,true
        },
        {
            ""thank you"",'b',11,11,false
        },
        {
            ""hello"",'c',11,11,true
        }
  };
</code></pre>

<p>And the following line,</p>

<blockquote>
  <p>int size = sizeof(code);</p>
</blockquote>

<p><code>code</code> is just a pointer to the structure whose size is always 4 (older systems) or 8 (newer systems) bytes. I guess you are trying to find number of members in <code>hello[]</code> structure array. In this case either you have to pass this number separately as a function to <code>vm_cpu</code> function or use some logic to determine this number within the vm_cpu function.
In case you don't want to pass no. of members as an argument, initialize the structure in <code>main</code> fn as follows:</p>

<pre><code>struct stack_base hello[] = {
        {
            ""abc"",'a',11,11,true
        },
        {
            ""abc"",'a',11,11,true
        },
        {
            ""abc"",'a',11,11,true
        },NULL
};
</code></pre>

<p>And in vm_cpu function, use the following logic to find out no. of structure array elements.</p>

<pre><code>int size = 0;
    struct stack_base *ptr = code;

    while(ptr[size].somechars) {
        size++;
        ptr++;
    }
    size--;
    printf(""The no. of elements of structure array: %d\n"", size);
</code></pre>
",0
37241435,37241364,2,"<p>Usually you should declare characters as char and use int for integers being capable of holding bigger values. On most systems a char occupies a byte which is 8 bits. Depending on your system this char might be signed or unsigned by default, as such it will be able to hold values between 0-255 or -128-127.</p>

<p>An int might be 32 bits long, but if you really want exactly 32 bits for your integer you should declare it as int32_t or uint32_t instead.</p>
",0
37241444,37241364,1,"<p>I think there's no difference, but you're allocating extra memory you're not going to use. You can also do <code>const long a = 1;</code>, but it will be more suitable to use <code>const char a = 1;</code> instead.</p>
",0
37241766,37241364,9,"<p>The <code>char</code> type has multiple roles.</p>

<p>The first is that it is simply part of the chain of integer types, <code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>, etc., so it's just another container for numbers.</p>

<p>The second is that its underlying storage is the smallest unit, and all other objects have a size that is a multiple of the size of <code>char</code> (<code>sizeof</code> returns a number that is in units of <code>char</code>, so <code>sizeof char == 1</code>).</p>

<p>The third is that it plays the role of a character in a string, certainly historically. When seen like this, the value of a <code>char</code> maps to a specified character, for instance via the ASCII encoding, but it can also be used with multi-byte encodings (one or more <code>char</code>s together map to one character).</p>
",1
37241654,37241364,57,"<p>The difference is the size in byte of the variable, and from there the different values the variable can hold.</p>

<p>A char is required to accept all values between 0 and 127 (included). So in common environments it occupies exactly 
one byte (8 bits). It is unspecified by the standard whether it is signed (-128 - 127) or unsigned (0 - 255).</p>

<p>An int is required to be at least a 16 bits signed word, and to accept all values between -32767 and 32767. That means that an int can accept all values from a char, be the latter signed or unsigned.</p>

<p>If you want to store only characters in a variable, you should declare it as <code>char</code>. Using an <code>int</code> would just waste memory, and could mislead a future reader. One common exception to that rule is when you want to process a wider value for special conditions. For example the function <code>fgetc</code> from the standard library is declared as returning <code>int</code>:</p>

<pre><code>int fgetc(FILE *fd);
</code></pre>

<p>because the special value <code>EOF</code> (for End Of File) is defined as the <code>int</code> value -1 (all bits to one in a 2-complement system) that means more than the size of a char. That way no char (only 8 bits on a common system) can be equal to the EOF constant. If the function was declared to return a simple <code>char</code>, nothing could distinguish the EOF value from the (valid) char 0xFF.</p>

<p>That's the reason why the following code is <em>bad</em> and should never be used:</p>

<pre><code>char c;    // a terrible memory saving...
...
while ((c = fgetc(stdin)) != EOF) {   // NEVER WRITE THAT!!!
    ...
}
</code></pre>

<p>Inside the loop, a char would be enough, but for the test not to succeed when reading character 0xFF, the variable needs to be an int.</p>
",7
37241495,37241364,3,"<p>Size of an <code>int</code> is 4 bytes on most architectures, while the size of a <code>char</code> is 1 byte.</p>
",9
37907382,37635591,0,"<p>The corrected code that will solve your problem is:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void)
{
int row = 0 ;
int i = 0 ;
int j=0,length=0;
char message[256] ;
scanf( ""%d"", &amp;row );
fgets( message, sizeof(message), stdin ) ;
length = strlen(message);//stores the length of the array.
    for(j=1;j&lt;=row;j++) 
    {
        while( i &lt; length )//use this condition in the while loop instead of (message[i]!='\0') in this case.
        {
            putchar(message[i]) ;
            i=i+row;
        }
        printf(""\n"");
        i=j;
    }       
return 0;
}
</code></pre>

<p>Note that since you were using a static array and the condition (message[i]!='\0') in the while loop,in most of the cases your code would require accessing an array element beyond the array length which could invoke undefined behaviour.Using a dynamic array or changing the condition in the while loop will prevent such errors.
Moreover,this problem could also be solved if you had stored all the rows in a Two-dimensional array and then displayed each column in a single line.</p>
",0
37701242,37701124,2,"<p>One way is:</p>

<pre><code>typedef int Int_array_3[3];

Int_array_3 * foo(void);
</code></pre>
",4
37701461,37701124,4,"<p>I'd advise against doing this.</p>

<p>It's often done as a poor workaround for the apparent limitation that C has of not being able to have an array as a return value.</p>

<p>Too often, a <em>dangling</em> pointer will be returned since the programmer will return a pointer to an array in the function that has automatic storage duration. Then this gets hacked to a <code>static</code> which ruins the threading model and breaks all previous returned pointers!</p>

<p>Only slightly better is returning a pointer given to you by a <code>malloc</code> call internal to the function. But then, that burdens (asymmetrically) the caller with having to call <code>free</code> at some point. Eventually your function winds up in some kind of precompiled library which uses a different C runtime to a client. Your <code>malloc</code> and their <code>free</code> no longer match, and you end up with a truck load of undefined behaviour!</p>

<p>Instead of all this, do consider passing the array <em>by pointer</em> on the function parameter list, preferably pre-allocating the memory.</p>
",3
37701486,37701124,4,"<p>First, I agree with the other answers that you probably need a <code>typedef</code> or a <code>struct</code> in there to clarify.</p>

<p>If you want to know how to <strong>declare</strong> the return type, it's
<code>int (*foo(void))[3] {</code></p>

<p>In the <a href=""https://softwareengineering.stackexchange.com/questions/117024/why-was-the-c-syntax-for-arrays-pointers-and-functions-designed-this-way"">""declaration reflects use""</a> pattern, you can build this up by considering the usage, i.e. how to get from <code>foo</code>'s type to the plain type <code>int</code>:</p>

<ul>
<li>take <code>foo</code></li>
<li>call it (with no arguments): <code>foo()</code></li>
<li>dereference the return value: <code>*foo()</code></li>
<li>add an array index: <code>(*foo())[i]</code>; the parentheses are needed because the postfix syntax would otherwise take precedence over prefix one.</li>
<li>the result is of plain type <code>int</code></li>
</ul>

<p>Declaration reflects it:</p>

<ul>
<li>take <code>foo</code></li>
<li>call it: <code>foo(void)</code>, inserting <code>void</code> to say it's specifically a 0-param function rather than one with an unspecified set of parameters</li>
<li>dereference the function return value: <code>*foo(void)</code></li>
<li>add an array index: <code>(*foo(void))[3]</code>, making the ""index"" be the size of the array</li>
<li>we got down to the plain type, so declare that the thing you built has that type: <code>int (*foo(void))[3]</code></li>
</ul>

<p>Example code:</p>

<pre><code>#include &lt;stdio.h&gt;
int arr[3];
int (*foo(void))[3] {
  return &amp;arr;
}
int main (void) {
  arr[0] = 413;
  arr[1] = 612;
  arr[2] = 1025;
  printf(""%d %d %d\n"", (*(foo()))[0], (*(foo()))[1], (*(foo()))[2]);
  return 0;
}
</code></pre>

<p>Side note: be sure that the array you are returning a pointer to will continue to exist after the function returns.</p>
",7
37703960,37701124,1,"<p>As a rule of thumb, avoid functions passing/returning raw array pointers or function pointers, because such code is a nightmare both to program and read. In this case it would have been </p>

<pre><code>int (*func()) [3]
</code></pre>

<p>which is completely unreadable. Just forget about writing such code. Instead, use a typedef to define an array type:</p>

<pre><code>typedef int iarr3_t [3];
</code></pre>

<p>And then write a function returning a pointer to such an array:</p>

<pre><code>iarr3_t* func (void);
</code></pre>

<hr>

<p>However, as indicated by other comments and answers, returning an array pointer is usually quite questionable practice to begin with. The need to do so could be an indication of poor program design.</p>
",5
37701576,37701411,1,"<p>You need to declare the function correctly with the arguments you are willing to pass in it. </p>

<p>Let's say for example that <code>verifyWord</code> returns <code>void</code> and accepts <code>char pointer</code> as an argument. </p>

<p>The proper declaration would be: </p>

<pre><code>void verifyWord (char *nextWord);
</code></pre>

<p>And you will use it like:</p>

<pre><code>char* nextWord = NULL;

verifyWord(nextword);
</code></pre>

<p>Your problem is that you didn't tell your compiler how to deal with the function. You need to have explicit declaration, like the one I mentioned above, placed somewhere before the line where you call it, and it has to be within the same scope. </p>
",2
37827041,37802501,1,"<p>Use <strong>n=abs(n/10)</strong> instead of <strong>n=n/10</strong> </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
main()
{
printf(""Sum Digit Program\n"");
int n,re, sum = 0;
printf(""Enter an integer n=""); scanf(""%d"", &amp;n);
while(n)
    {
    re = n % 10;
    sum = sum + re;
    n =abs(n/10);
    }
printf(""Sum digit = %d"", sum);
return 0;
}
</code></pre>
",0
37915521,37915440,1,"<p>You probably should take into account that printable <strong>strings are zero-byte terminated in C</strong>. Hence the fields in your anonymous <code>struct</code> should each have one more byte (so <code>char first[8];</code> and <code>char initial[2];</code> etc...). BTW the space for the <code>last</code> (family) name is really too small: my name won't fit in it, and is not that unusually wide.</p>

<p>You also should test the result of <a href=""http://en.cppreference.com/w/c/io/fscanf"" rel=""nofollow noreferrer""><code>scanf</code> &amp; <code>sscanf</code></a>. They return the number of scanned items. You might use <code>%5s</code> to scan a field of 5 characters (+1 for the terminating zero byte). You should read the documentation of <code>scanf</code> before using it.</p>

<p>You should probably clear <code>workers[i]</code> e.g. with <code>memset(workers+i, 0, sizeof(workers[i]));</code> before filling it.</p>

<p>BTW, compile your program with all warnings &amp; debug info (e.g. <code>gcc -Wall -g</code> if using <a href=""http://gcc.gnu.org/"" rel=""nofollow noreferrer"">GCC</a>...) and <strong>use the debugger</strong> (e.g. <code>gdb</code>) e.g. to run it step by step.</p>

<p>Perhaps you should consider using pointers to the heap and <a href=""https://en.wikipedia.org/wiki/C_dynamic_memory_allocation"" rel=""nofollow noreferrer"">C dynamic memory allocation</a>. Then be sure to test against failure of <code>malloc</code> and beware of <a href=""https://en.wikipedia.org/wiki/Memory_leak"" rel=""nofollow noreferrer"">memory leaks</a>; a tool like <a href=""http://valgrind.org/"" rel=""nofollow noreferrer"">valgrind</a> would be very helpful.</p>

<hr>

<p>BTW, a <code>printf</code> call like <code>printf(""%s"", workers[0].first);</code> is having an <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer""><strong>undefined behavior</strong></a> (UB) when <code>workers[0].first</code> is a field or array of <code>char</code>-s which is <em>not</em> zero-byte terminated. And UB is really <a href=""https://stackoverflow.com/a/25636788/841108"">bad</a>, you always should avoid it. Read <a href=""http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html"" rel=""nofollow noreferrer"">Lattner's blog entries about <em>undefined behavior</em></a>.</p>
",5
37915870,37915440,1,"<p>Your code contains an undefined behavior. This function <code>strsub(buf, workers[i].first, 0, 6)</code> will write outside of array boundary:</p>

<pre><code>void strsub (char buf[], char sub[], int start, int end)
{
    int i, j;

    for (j=0, i=start; i &lt;= end; i++, j++)
    {
        sub[j] = buf[i];
    }
    sub[j] = '\0';
}
</code></pre>

<p>After the loop a <code>j</code> variable would be 7 and you will overwrite adjusted struct members. This is a root of your problems with the <code>sprintf</code> function and incorrect symbol output.</p>

<p>However the main problem is in your reading algorithm. You are taking parts of the fixed length from the input string. But different people have a names of different lengths. Lets consider your example</p>

<blockquote>
  <p>""ADA A AGUSTA 33 BABBAGE ROAD LOVELACE GB 19569 28 F 2 350.50""</p>
</blockquote>

<p><code>firstName</code> is expected to be <code>ADA</code>. Yet since you are taking fixed 7 characters from the string it will be <code>ADA A A</code>. Is a data sting dont have a sufficient length you will be reading outside its boundary which is an undefined behavior as well.</p>
",5
38196135,38195689,0,"<p>Replace line,</p>

<pre><code>if (num!=2&amp;&amp; num!=3 &amp;&amp; num!=5 &amp;&amp; num!=7 &amp;&amp; num!=11 &amp;&amp; num!=17 &amp;&amp; num!=19)
</code></pre>

<p>instead of,</p>

<pre><code>if (num!=2||3||5||7||11||17||19)
</code></pre>
",3
38196944,38195689,0,"<p>In function <code>factor</code>, first try dividing by <code>2</code> repeatedly, then try every odd number while said odd number squared is less or equal to <code>num</code>. This simple method is a bit redundant as you try and divide by composite numbers, but since you will already have removed all smaller prime factors, <code>num</code> will not be divisible by such composite numbers.  Iterating while <code>i * i &lt;= num</code> will stop much earlier than with your current <code>i &lt;= num</code> test.</p>

<p>Try and write code to implement the above algorithm and post it as an edit.</p>
",1
43223618,43221231,0,"<p>You have written wrong variables,<br></p>

<pre><code>for (cla = 0; i &lt; sizeof(arScore) / sizeof(arScore[0]); cla++) {  // i instead of cla
        sum[cla] = 0;

        for (stu = 0; j &lt; sizeof(arScore[0]) / sizeof(arScore[0][0]); stu++) {
            sum[cla] += arScore[cla][stu];   //j instead of stu
</code></pre>

<p><br> write this instead<br></p>

<pre><code>for (cla = 0; cla &lt; sizeof(arScore) / sizeof(arScore[0]); cla++) {
        sum[cla] = 0;

        for (stu = 0; stu &lt; sizeof(arScore[0]) / sizeof(arScore[0][0]); stu++) {
            sum[cla] += arScore[cla][stu];
</code></pre>
",2
38191626,38191567,1,"<p>sprintf(title,""%.3d.jpg"" , i); will put a string value XXX.jpg to the title buffer, which is 7 bytes long.</p>

<p>However sprintf null terminates the string, so requires and additional buyte to store the null byte.</p>
",0
38285202,38284908,1,"<p>Not sure what you want to achieve by that - but you get it with a double for loop:
</p>

<pre><code>char exp[64];
scanf(""%s"", exp);

for(char* e = exp; *e; ++e)
{
    for(char* ee = exp; ee &lt; e; ++ee)
    {
        if(ee != exp)
            putchar(',');
        putchar(*ee);
    }
    putchar('\n');
}
</code></pre>

<p>I assume that you insured by whatever means that the string in the buffer is null-terminated. If you cannot guarantee, you might want to check instead of for <code>*e</code> for something like <code>e &lt; exp + sizeof(exp)</code> or <code>e &lt; exp + maxLength</code> or combine one of the latter two with <code>*e &amp;&amp;</code></p>
",0
38288046,38284908,0,"<p>If you really want to copy one character from the original array plus one comma and print the result after each such addition, you can use two arrays:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    char exp[] = ""567+*"";
    char res[1024];          // Plenty big enough

    char c;
    char *src = exp;
    char *tgt = res;
    while ((c = *src++) != '\0')
    {
        *tgt++ = c;
        *tgt++ = ',';
        *tgt = '\0';
        puts(res);
    }

    return 0;
}
</code></pre>
",0
38866333,38864558,0,"<p>Your issue is that you didn't declare your function <code>test</code> properly. You have to declare every function that is used before it is used, be it by putting the actual function above or writing a function declaration.</p>

<p>As soon as you do that, your code works:</p>

<pre><code>#include &lt;stdio.h&gt;
char *test (char *str); // this is the function declaration
int main(void) {
    register char *str = ""Hello World"";
    char *ans;
    ans = test(str);
    if(!ans)
        return 1;
    free(ans);
    return 0;
}
char *test(char *str) {

         char *str1 ;
         char *str2;
         char *str3;
         str1 = malloc(strlen(str) + 5);
         str2 = str;
         str3 = str1;
         *str3++ = '\b';
         *str3++ = '\b';
         while(*str2)
             *str3++ = *str2++;
         *str3++ = '\f';
         *str3++ = '\f';
         *str3 = '\0';
         return (str1);
}
</code></pre>

<p>Demo: <a href=""https://ideone.com/HIXyMs"" rel=""nofollow"">https://ideone.com/HIXyMs</a></p>
",0
38410229,38410200,3,"<p>Your code is pretty close, but you've made three mistakes:</p>

<ul>
<li>You initialize array using a comma expression,</li>
<li>You put a semicolon after your <code>if</code>, and</li>
<li>You are swapping in the wrong direction (your array would be sorted in descending order) - i.e. <code>if (arr[i]&lt;arr[j])</code> should be <code>if (arr[i]&gt;arr[j])</code></li>
</ul>

<p>Fixing these three mistakes will produce a working solution. Initialization needs to happen as part of a declaration, and use curly braces:</p>

<pre><code>int i,j,arr[10] = {10,30,50,40,20};
</code></pre>

<p><a href=""http://ideone.com/ydQXJk"" rel=""nofollow"">Demo.</a></p>
",0
38410764,38410200,0,"<ol>
<li>init of array at wrong place.</li>
<li>sorting is not correct</li>
<li>semicolon after if statement preventing from swaping.</li>
</ol>

<p>change it to: </p>

<pre><code>    int i,j,arr[10]= {10,20,30,40,50};

        printf(""ascending order"");

        for(i=0;i&lt;5;i++)
        {
            for(j=i;j&lt;(5-i-1);j++)
            {
                if (arr[j]&gt;arr[j+1])
                swa(&amp;arr[j],&amp;arr[j+1]);
            }
        }
        for(i=0;i&lt;5;i++)
        {
            printf(""%d "",arr[i]);
        }
</code></pre>
",0
38411455,38410200,0,"<p>An array can be initialized when it is declared using a braced list.</p>

<p>Thus this attempt to initialize the array</p>

<pre><code>int i,j,arr[10];
arr[10]= (10,20,30,40,50);
</code></pre>

<p>is invalid. In fact in the second statement in the right side there is used the comma operator and a non-existent element of the array with index 10 is assigned to 50.</p>

<p>This if statement </p>

<pre><code>if (arr[i]&lt;arr[j]);
                  ^^
</code></pre>

<p>has an empty sub-statement due to the incorrectly placed semicolon. It must be removed.</p>

<p>Moreover the condition in the if statement says that you are trying to sort the array in the descending order instead of the ascending order.</p>

<p>Also it is a bad style of programming to use magic numbers as for example number 5 in your program.</p>

<p>The program can look the following way</p>

<pre><code>#include &lt;stdio.h&gt;

void swap( int *x, int *y )
{
    int tmp = *x;
    *x = *y;
    *y = tmp;
}

#define N   10

int main(void) 
{

    int arr[N] = { 10, 20, 30, 40, 50 };
    size_t i, j;

    size_t n = 0;
    while ( n &lt; N &amp;&amp; arr[n] != 0 ) ++n;

    printf( ""descending order:"" );

    for ( i = 0; i &lt; n; i++ )
    {
        for ( j = i + 1; j &lt; n; j++ )
        {
            if ( arr[i] &lt; arr[j] ) swap( &amp;arr[i], &amp;arr[j] );
        }
    }

    for ( i = 0; i &lt; n; i++ ) printf( "" %d"", arr[i] );
    printf( ""\n"" );

    return 0;
}
</code></pre>

<p>Its output is</p>

<pre><code>descending order: 50 40 30 20 10
</code></pre>
",0
39133118,39130984,0,"<p><code>t</code> can be <code>10^5</code> or 100,000. Your <code>c</code> array is <code>c[t][100]</code>, so the size of that is <code>100000 * 100</code>, which is 10,000,000. You're probably getting a stack overflow.</p>

<p>As WhozCraig pointed out, the processing of each case is independent. Thus, <code>c</code> can be a one dimensional array: <code>char c[100]</code>. Change all <code>c[t][...]</code> into <code>c[...]</code>.</p>

<p>Adjust things so that you have one outer loop:</p>

<pre><code>int
main()
{
    int t;
    char c[100];

    scanf(""%d"", &amp;t);

    for (int i = 0; i &lt; t; i++) {
        scanf("" %s"", c);
        // do all processing for this line ...
        n = strlen(c);
    }

    return 0;
}
</code></pre>
",0
38614485,38602610,0,"<pre><code>void function(int rowNUM){

int c;
int d;
int columnNUM;



typedef struct {
int member[3][3];
}mystruct;

mystruct identity[ROW][COLUMN];
static bool first_call = true;
if (first_call) {
// INTIALIZE each element of member array to 1 
for (columnNUM=0;columnNUM&lt;COLUMN;columnNUM++)//total cell
{
for (c=0;c&lt;3;c++)
   {
for(d=0;d&lt;3;d++){
   identity[rowNUM][columnNUM].member[c][d]=1;
//printf(""identity[%d][%d].member[%d][%d]=%d\n"",rowNUM,columnNUM,c,d,identity[rowNUM][columnNUM].member[c][d]);
       }
    }
}
first_call = false;
    }



identity[0][0].member[0][0]=identity[0][0].member[0][0]+3;
printf(""%d\n"", identity[0][0].member[0][0]);
identity[0][0].member[0][1]=identity[0][0].member[0][1]+1;
printf(""%d\n"", identity[0][0].member[0][1]);



}
</code></pre>

<p>The above code produce:
 first call= <code>4 2</code> second call= <code>7 3</code> third call= <code>10 4</code>
Work perfectly fine,nice. But it works fine either I declare  </p>

<pre><code>mystruct identity[ROW][COLUMN];
</code></pre>

<p>or</p>

<pre><code>static mystruct identity[ROW][COLUMN];
</code></pre>

<p>Does it mean I dont need to declare static at all? </p>
",5
39009713,39009672,6,"<p>Because <code>||</code> has higher precedence than <code>=</code>, so it's being parsed as if you'd written.</p>

<pre><code>if (b = (a || (b == ++c)))
</code></pre>

<p>This calculates <code>a || (b == ++c)</code>. This is true because <code>b == 0</code> and <code>++c == 0</code>, so <code>b == ++c</code> is true, and true is <code>1</code>.</p>

<p>Add parentheses to get what you want:</p>

<pre><code>if ((b = a) || (b == ++c))
</code></pre>

<p>But IMHO it's generally best to avoid writing such complex expressions. Do them as separate statements:</p>

<pre><code>b = a;
if (b || b == ++c)
</code></pre>
",8
39009969,39009672,0,"<p>Once you are clear with the precedence of operators,it will be easy for you to tackle such type of questions.Go through  <a href=""http://en.cppreference.com/w/c/language/operator_precedence"" rel=""nofollow"">this </a> to know about operator precedence in C.</p>

<p>You should see my answer after going through the precedence list  because then it will get more easily  inside your mind.</p>

<blockquote>
  <p>Now,coming to your question....</p>
</blockquote>

<p>Out of all the operators used in the above code, <code>++c</code> has the highest precedence.So the value of <code>c</code> becomes <code>0</code> and then value of <code>c</code> is compared to value of <code>b</code> here  <code>b == ++c</code> which evaluates to <code>true</code> i.e <code>1</code> and now <code>||</code> of <code>1</code> and <code>a</code> is taken which is <code>1</code>.</p>

<p>And finally this result <code>1</code> is assigned  to <code>b</code>.So the overall execution of <code>if</code> statement evaluates to true and value of <code>a</code> is incremented by <code>3</code>.</p>

<p>Hence finally the value of <code>a=3,b=1 and c=0</code>. </p>
",0
43938840,43938769,6,"<p><code>Letters[Input[i]]</code> is plain wrong, and it invokes <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behavior</a> accessing array out of bounds.</p>

<p>As you can see on a <a href=""http://www.asciitable.com/"" rel=""nofollow noreferrer"">ASCII table</a> values of letters are not from <code>0</code> to <code>25</code>, as you supposed.</p>

<p>You can do, for example:</p>

<pre><code>int index;
for(i=0;i&lt;size;i++)
{
    index = toupper(Input[i]) - 'A';
    if ((index &gt;= 0) &amp;&amp; (index &lt; 26))
    {
       Letters[index]++;
    }
}
</code></pre>

<hr>

<p><strong>EDIT</strong>
If you can assume all input letters and are lower case just</p>

<pre><code>Letters[Input[i] - 'a']++;
</code></pre>

<hr>

<p><strong>EDIT2</strong></p>

<p>Moreover your loop</p>

<pre><code>for (i = Letters[j]; Letters[j] != 0; i = i - 2)
</code></pre>

<p>does not take care of i>0: fixed</p>

<pre><code>for (i = Letters[j]; (Letters[j] != 0) &amp;&amp; (i&gt;=0); i = i - 2)
</code></pre>

<hr>

<p><strong>EDIT3</strong></p>

<p>trying to correct your code without using ""too complicated"" matters, your code can simply be</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void MakeItPOLI(char Input[99])
{
    int i, size, j;
    size = strlen(Input);

    char Poli[99] = {0};

    for (i=0; i&lt;size; i++)
    {
        Poli[i] = Input[i];
    }

    if ((size%2) == 0)
    {
        j=size-1;
    }
    else
    {
        j=size-2;
    }

    do
    {
        Poli[i++] = Input[j];
    }
    while (j-- &gt; 0);

    Poli[i] = '\0';

    printf(""This is not a palindrom but it could be: %s\n"", Poli);
}

int main()
{
    char test[99] = ""test"";
    char test2[99] = ""testc"";
    MakeItPOLI(test);
    MakeItPOLI(test2);
}
</code></pre>

<p>OUTPUT</p>

<pre><code>This is not a palindrom but it could be: testtset
This is not a palindrom but it could be: testctset
</code></pre>
",8
43939279,43938769,0,"<pre><code>#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

char *makeItPal(char *str)
{
  if (!str || strlen(str) &lt; 2)
    return NULL;

  char *dest = malloc(sizeof(char) * ((strlen(str) * 2) + 1));
  if (!dest)
    exit(0);

  int i = 0, j = 0;
  for (i = 0; str[i]; i++)
    dest[j++] = str[i];

  i -= 2;

  while (i &gt;= 0)
    {
      dest[j] = str[i];
      i--;
      j++;
    }

  dest[j] = 0;
  return dest;
}

int main()
{
  char str[] = ""stack"";
  char str2[] = ""foo"";
  char str3[] = ""str3"";

  char *dest = makeItPal(str);
  char *dest2 = makeItPal(str2);
  char *dest3 = makeItPal(str3);

  printf(""%s\n"", dest);
  printf(""%s\n"", dest2);
  printf(""%s\n"", dest3);
}
</code></pre>

<p>here is i think a better solution</p>

<pre><code>Output : rifzy@rifzy-HP-EliteBook-840-G1:~$ gcc test.c &amp;&amp; ./a.out
         stackcats
         fooof
         str3rts
</code></pre>
",6
39251426,39251371,5,"<p>You are printing out the address of x. Remove the '&amp;' before it in the printf and you should see the right thing.
Putting an &amp; before a variable gets a pointer to it - this is necessary in the scanf because it must change the value, but since printf only uses the value, no pointer is needed (except for strings, which are always pointers).</p>
",1
39251429,39251371,6,"<p>You <code>printf</code> <code>x</code>'s address instead of value. Fix like this:</p>

<pre><code>printf(""You entered %d.\n"", x);
</code></pre>

<p><code>scanf</code> wants the address where to store the result, <code>printf</code> can take the value itself.</p>
",0
40994280,40994185,1,"<p>Bitwise operations on struct's doesn't make to much sense because of padding and  more importantly it's just killing the purpose of having a struct in the first place. Bitwise operation are as the name said to operate on bit's in variable. Struct variables usually (if they're not packed) will be padded so until you pack them you wouldn't have guarantee where they are to access them but if you want to ask if you can, yes you can, but you would have to cast struct g to let's say 32 bit value then if two variables would be in this space you could use bit operation on this casted value. If it's necessary you can create union from your struct and have raw variable as one union part, and structure as the other option, then you can manipulate bitwise on raw variable.</p>
",0
40994625,40994185,0,"<p>You can change the data by getting offset of b. I know, this code does not look good.But it serve your purpose. </p>

<pre><code>#include &lt;stdio.h&gt;

struct name
{
        int a;
        char b;
        float c;
}g;

int main()
{
        g.b='X';
        int y=0;

        int offset = &amp;((struct name *)NULL)-&gt;b; // Find Offset of b
        char *p = (char *)&amp;g;
        int i=0;

        for(i=0;i&lt;offset;i++)
        {
                ++p;
        }

        *p=*p|(1&lt;&lt;0);

       // *p = 'A';

        printf(""........%c\n"",g.b);

}
</code></pre>
",2
39676715,39676665,0,"<p>Strings ended at ""\0"" not at ""\o""</p>
",0
39676807,39676665,0,"<p>See the thing is, <code>printf()</code> prints all the characters in series, until it sees a null byte. Your previous word already filled up some bytes, and since you can read them, obviously, they are not null.</p>

<p>To fix your code, you have to add a null byte at the end of your word in the <code>hold[]</code> array.</p>

<pre><code> else
{
    /* j now refers to the array-slot which should be NULL */
    hold[j] = '\0';

    printf(""%s\n"",hold);
    j = 0;
}
</code></pre>
",0
39676918,39676665,1,"<p>Please add the lines </p>

<pre><code>hold[j]='\0'; 
</code></pre>

<p>Reason: The end of the string is '\0' if you have not explicitly adding a '\0' it will take the entire string until it finds the first '\0'
and</p>

<pre><code>printf(""%s\n"",hold); 
</code></pre>

<p>Reason: To get the last word printed, if the string of words is not ending with a space</p>

<p>as in the below edited program</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
char *string;
char *hold;


int main(void)  
{
   string = malloc(200);
   hold = malloc(50);
   int i=0;
   int j=0;

   printf(""please enter a string\n"");
   scanf(""%[^\n]"",string);
   printf(""%s\n"",string);

   while (string[i] !='\0')
   {
      if (string[i] !=' ')
      {
          hold[j] = string[i];
          j++;
      }
      else
      {
         hold[j]='\0';         **//Edited here**
         printf(""%s\n"",hold);
         j = 0;
      }
  i++;
}
printf(""%s\n"",hold); **//Edited here**
return 0;
free(string);       
}
</code></pre>
",1
39686287,39685792,-1,"<p>part of <code>else if (isalnum(input[0])){</code> should be something like</p>

<pre><code>else if (isalnum(input[0])){
    while (input[i]!='\0' &amp;&amp; input[i]!='\n'){
        bool found = false;
        for (int x=0; x &lt; sizeof(alpha)/sizeof(char*);x++){
            if (*alpha[x]==input[i]){
                print_array[print_array_index++] = morse[x];
                found = true;
                break;
            }
        }
        if(!found){
            fprintf(stderr, ""Invalid input!\n"");
        }
        i++;
    }
    for (int x=0; x &lt; print_array_index; x++){
        printf(""%s"", print_array[x]);
    }
    printf(""\n"");
}
</code></pre>
",2
40564604,40559126,0,"<p>You code seems correct, but you probably have a problem elsewhere.  Here is an example where it behaves as expected:</p>

<pre><code>#include &lt;stdbool.h&gt;
#include &lt;stdio.h&gt;

bool left_diag_win(char **board, int num_rows, int num_cols) {
    if (board[0][0] == '*') {
        return false;
    }
    for (int i = 1; i &lt; num_rows; ++i) {
        if (board[i][i] != board[0][0]) {
            return false;
        }
    }
    return true;
}

bool right_diag_win(char **board, int num_rows, int num_cols) {
    if (board[0][num_cols - 1] == '*') {
        return false;
    }
    for (int i = 1; i &lt; num_rows; ++i) {
        if (board[i][num_cols - i - 1] != board[0][num_cols - 1]) {
            return false;
        }
    }
    return true;
}

int main(void) {
    char *matrix1[] = { ""X****"", ""*X***"", ""**X**"", ""***X*"", ""****X"" };
    char *matrix2[] = { ""****X"", ""***X*"", ""**X**"", ""*X***"", ""X****"" };

    printf(""matrix:\n"");
    for (int i = 0; i &lt; 5; i++) {
        printf(""%s\n"", matrix1[i]);
    }
    printf(""left-diagonal: %d\n"", left_diag_win(matrix1, 5, 5));
    printf(""right-diagonal: %d\n\n"", right_diag_win(matrix1, 5, 5));

    printf(""matrix:\n"");
    for (int i = 0; i &lt; 5; i++) {
        printf(""%s\n"", matrix2[i]);
    }
    printf(""left-diagonal: %d\n"", left_diag_win(matrix2, 5, 5));
    printf(""right-diagonal: %d\n\n"", right_diag_win(matrix2, 5, 5));

    return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>matrix:
X****
*X***
**X**
***X*
****X
left-diagonal: 1
right-diagonal: 0

matrix:
****X
***X*
**X**
*X***
X****
left-diagonal: 0
right-diagonal: 1
</code></pre>
",0
40562932,40562915,0,"<p>You might have to reassign <code>headp</code> to <code>people</code> once you are done inserting, because else the <code>people</code> pointer still points to the last person (because you advance the <code>people</code> pointer in every insert).</p>
",0
40562936,40562915,2,"<p>You are overwriting the passed variable <code>p</code> with the address returned by <code>malloc</code> (memory leak and you loose the previous head), change to:</p>

<pre><code>static Person *insert(Person *head, char *name, int age) 
{
  Person *p = malloc(sizeof(Person)); /* Don't cast malloc */

  if (p == NULL)
    abort();
  p-&gt;name = name;
  p-&gt;age = age;
  p-&gt;next = head;
  return p;
}  
</code></pre>
",6
43956530,43926679,0,"<p>From what I understand you wanted to split the main file into n's files.
What you can do is use is a loop with fscanf and save to a buffer the data, in the main loop, when it arrives in the last iteration, increment the limit of the loop that captures the ints, if there is a remainder of division of between TAMANHO_ARQUIVO/QTD_DISCOS The loop that captures the int's will be larger, so the last loop will save more int's than the others.</p>

<p>The fscanf function allows you to use parameters to capture integers, floats, chars, etc.</p>

<p>Using fread for this will make the task much more complicated.
Do not forget that to put the file pointer in the correct position we have to count the end of line.</p>

<p>No doubt there must be more practical ways of doing what you intend.
Any question I can write in pt-br.</p>

<pre><code>#define TAMANHO_ARQUIVO 10 // main file size
#define QTD_DISCOS 3       // number of files to divide the main file

int main () 
{

    FILE *arquivoPrincipal;  // main file

    int x = 0;
    int incpos=0;
    char name[FILENAME_MAX];
    int memoria_interna = (int) ceilf(TAMANHO_ARQUIVO/QTD_DISCOS);
    char vet[256] ;
    printf(""memoria_interna:%d remainder:%d \n"",memoria_interna,TAMANHO_ARQUIVO%QTD_DISCOS);
    int remainder  = TAMANHO_ARQUIVO%QTD_DISCOS;
    arquivoPrincipal = fopen(""arquivo.txt"", ""w+"");
    int isLastDisco = memoria_interna-1;



    srand(time(NULL));
    for (int i = 0; i &lt; TAMANHO_ARQUIVO; ++i) 
    {
        x = rand() % 10;
        fprintf(arquivoPrincipal, ""%d\n"", x);
    }

    fseek(arquivoPrincipal, 0 , SEEK_SET);/*reseta para a posi??o zero*/

    for (int i = 0; i &lt; QTD_DISCOS; ++i) 
    {
        FILE *arquivo;
        int   numOfIntsTosave;
        int *pInts;
        sprintf(name,""disco_%d.txt"", i); // generating files names dynamically          printf(""%s\n"", name);
        memset(vet, 0, 256); // clearing vector

        //qtd_int = fread(vet, sizeof(char), memoria_interna*2, arquivoPrincipal); 
        // reading main file to get number of items from 0 to memoria_interna (which is the size of the main file / the number of files to be divided)

        arquivo = fopen(name, ""w"");
        if (!arquivo) 
        {
            printf(""Error!\n"");
            exit(0);
        }
        if(i==QTD_DISCOS-1)/*If we are in the last iteration of the for loop, then if there is a remainder, we add to memoria_interna */
            numOfIntsTosave = memoria_interna+remainder;/*remainder this can be zero*/
        else
            numOfIntsTosave = memoria_interna;

        pInts = (int*)malloc(sizeof(int)*numOfIntsTosave);/*alloc buffer to int¡äs*/
        if(pInts==NULL){
            printf(""error malloc\n"");
            exit(0);
        }
        for(int u=0;u&lt;numOfIntsTosave;u++)
        {
            fscanf(arquivoPrincipal,""%d\n"",&amp;pInts[u]);/*le do arquivo principal*/
            fprintf(arquivo, ""%d\n"", pInts[u]);/*salva no arquivo*/
            incpos+=2;/* um int e um /n */
        }
        if(pInts)
            free(pInts);/*free buffer of int¡äs*/
        incpos+=2;/* um int e um /n */
        //fwrite(vet, sizeof(char), qtd_int , arquivo);//printf(""Error!\n"");
        fclose(arquivo);

        /*seeking/seting the position (for the next loop)*/
        fseek(arquivoPrincipal,incpos, SEEK_SET);

    }
    fclose(arquivoPrincipal);

    return 0;
}
</code></pre>
",0
40553274,40553245,0,"<p>The format string in <code>printf</code> does not match the argument list</p>

<p>Change:</p>

<pre><code>  printf(""%d \t"", n[i].marks[j]);
</code></pre>

<p>to</p>

<pre><code>  printf(""%f \t"", n[i].marks[j]);
</code></pre>
",3
40563121,40562790,1,"<h1>Problem #1</h1>

<pre><code>char fname[25];
scanf (""%s"",&amp;n.fname);
</code></pre>

<p>As explained <a href=""https://stackoverflow.com/questions/5406935/reading-a-string-with-scanf"">elsewhere</a>, this might seem to work, but it is wrong. Use <code>scanf(""%s"", fname);</code></p>

<h1>Problem #2</h1>

<pre><code>rl = (char) n.roll + "".txt"";
</code></pre>

<p>This statement does not concatenate strings, as you probably meant to do; the binary <code>+</code> operator in C does not work like that. What is happening here:</p>

<ul>
<li><code>"".txt""</code> is an expression of type ""pointer to <code>char</code>"", that points to the first element of the sequence (<a href=""http://mfukar.github.io/resources/n1570.html#6.5.6"" rel=""nofollow noreferrer"">C11 6.3.2.1p3</a>)</li>
<li><code>(char) n.roll</code> casts an <code>int</code> to a narrower <strong>integer</strong> type, <code>char</code>, and thus discards some information. If you need a <code>char</code>, use a <code>char</code>, otherwise document its purpose</li>
<li><code>(char) n.roll</code> is of integer type, therefore if its value N is in the range [0, 4], the result is of type ""pointer to <code>char</code>"" and points to the N-th element of the array object, otherwise the behaviour is undefined
(<a href=""http://mfukar.github.io/resources/n1570.html#6.5.6"" rel=""nofollow noreferrer"">C11 6.5.6p8</a>)</li>
<li>the result is assigned to <code>rl</code>, which is of type <code>char</code>, which means you are trying to assign a pointer to an integer (and should be seeing a warning that says exactly that)</li>
</ul>

<p>If you wanted to safely create a character string, which contains a string of the form ""NNN.txt"", you use string formatting functions like <code>snprintf</code>:</p>

<pre><code>char buffer[MAXIMUM_FILENAME_SIZE];
snprintf (buffer, sizeof buffer, ""%d.txt"", n.roll);
</code></pre>

<p>Then check for errors and handle them appropriately.</p>
",0
40965750,40965728,3,"<blockquote>
  <p>floating point variable x with 3 digits before the decimal point and two digits after the decimal point.</p>
</blockquote>

<p>What you need is floating-point modulo remainder function <code>fmod</code></p>

<pre><code>double x = 123456.789;
double y = fmod( x, 1000 );
printf(""%06.2f"",y);
</code></pre>

<p>Remember to <code>#include &lt;math.h&gt;</code>, and compile with <code>-lm</code> for the math library, example: </p>

<p><code>gcc test.c -o test -lm</code></p>
",2
40553442,40553286,1,"<p>You should know, if you have a finite decimal you may not have a finite binary.</p>

<p>For instance 0.1 in Decimal:</p>

<pre><code>0.1 * 2 = 0.2 -&gt; 0
0.2 * 2 = 0.4 -&gt; 0
0.4 * 2 = 0.8 -&gt; 0
0.8 * 2 = 1.6 -&gt; 1
0.6 * 2 = 1.2 -&gt; 1
0.1 * 2 = 0.2 -&gt; 0
0.2 * 2 = 0.4 -&gt; 0
0.4 * 2 = 0.8 -&gt; 0
0.8 * 2 = 1.6 -&gt; 1
0.6 * 2 = 1.2 -&gt; 1
0.1 * 2 = 0.2 -&gt; 0
0.2 * 2 = 0.4 -&gt; 0
0.4 * 2 = 0.8 -&gt; 0
0.8 * 2 = 1.6 -&gt; 1
0.6 * 2 = 1.2 -&gt; 1 (and repeat infinitely)
</code></pre>

<p>So, 0.1 in Decimal is 0.000110001100011...</p>

<p>So maybe it's your problem and you should learn about the <a href=""https://en.wikipedia.org/wiki/Floating_point"" rel=""nofollow noreferrer"">mantissa</a>.</p>

<p>This is why some languages record their floating point numbers as fractions.</p>
",2
40553548,40553286,-1,"<p>Maybe you can try this, I didnt test the code so I am not 100% sure it will work, but it should. I am also sure it can be optimized. Give it a try and let us know!</p>

<pre><code>while ( number/10 &gt; 10 )
{
    number = number/10;     // Analyzing integer part
    quantity++;
}
number = number/10;

if (number == 10)
{
    quantity = quantity + 2;
}
else
{
    quantity++;
}

quantity++; // One more character for .

remaining = number % 1;

while (remaining/10 &gt; 10)
{
    quantity++;             // Analyzing decimal part
    remaining=remaining/10;
}
remaining = remaining/10;

if (remaining = 10)
{
    quantity = quantity + 2;
}
else
{
    quantity++;
}
</code></pre>
",0
40553554,40553286,3,"<blockquote>
  <p>Thanks to this data, I will create a malloc with a right dimension.</p>
</blockquote>

<p>Don't worry about it. Just allocate 32 bytes.</p>

<p><a href=""https://stackoverflow.com/a/1701085/149341"">A <code>double</code> can always be represented in 24 characters or less using scientific notation.</a></p>

<p>Allocating a couple of bytes more than you need will not increase your application's memory usage. Most <code>malloc()</code> implementations round allocations up to the next 8 bytes (sometimes even 16 or 32) for alignment purposes, so allocating an ""odd"" number like 24 bytes will result in the same memory usage as if you'd allocated 32.</p>
",0
40553643,40553286,2,"<p>Use <code>snprintf()</code> for C99 or more recent (use a <em>large enough</em> buffer for C89).</p>

<pre><code>n = snprintf(NULL, 0, ""%.2f"", a);
data = malloc(n + 1);
</code></pre>

<p><a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/snprintf.html"" rel=""nofollow noreferrer"">http://pubs.opengroup.org/onlinepubs/9699919799/functions/snprintf.html</a></p>
",0
41662913,41662533,0,"<p>In the case where your teacher write <code>fork() &amp;&amp; (fork() || fork());</code>:</p>

<p><code>fork()</code> create a new process and return the <code>pid_t</code> of the new processes if you are the parent or <code>0</code> if you are the child or <code>-1</code> if they are errors.</p>

<p>There are a lot of possibilities, I will ignore that <code>fork()</code> can <code>return</code> error.</p>

<p>The main process call <code>fork()</code> and it's <code>return</code> <code>0</code> in the child, this stop the logical <code>&amp;&amp;</code>, the first child <code>return</code>. The parent has a positive value so it calls a second <code>fork()</code>. Here this is a <code>||</code> so the parent stop here and <code>return</code>. The second child call the next <code>fork()</code> and then <code>return</code>. The third child <code>return</code> too because they are no more instruction.</p>
",4
45040456,45040135,0,"<p>Lets break it down piece by piece:</p>

<ul>
<li><code>while((s[0] = c = getch()) == ' ' || c == '\t')</code> skips all spaces and tabulation from the beginning fo the string. At the end of this loop <code>s[0]</code> contains the first char which is not either of the two mentioned before.</li>
</ul>

<p>Now if <code>c</code> is something other than <code>.</code> or a digit we simply return that.</p>

<pre><code>   if(!isdigit(c) &amp;&amp; c != '.') {
        return c;
    }
</code></pre>

<p>If <code>c</code> is not a digit we are done and it's quite right to set  <code>s[1]</code> to <code>null</code>! </p>

<p>Otherwise, if <code>c</code> is a digit we read as much digit chars as we can overwriting <code>s</code> from position <code>1</code>. s[1] was '\0' but it does not matter because s[++i] would be s[1] at the very first iteration of </p>

<pre><code> i = 0;
    if(isdigit(c))
        while(isdigit(s[++i] = c = getch()))
</code></pre>

<p>so <code>s</code> is kept in a consistent status.</p>
",2
40568020,40566712,0,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

char substitute(char letter, char* cipher)
{
int i;
int cipher_length = strlen(cipher);
char substitution = letter;

for(i = 0; i &lt; cipher_length; ++i)
{
    if(cipher[i] == letter)
    {
        substitution = cipher[(i%2) ? (i-1) : (i+1)];
        break;
    }
}
return substitution;
}

void GaDeRy(char* stringtoencode, char* fullcipher)
{
 int i;
 char* cipher = fullcipher;
 int string_length = strlen(stringtoencode);
 for(i = 0; i &lt; string_length; ++i)
 {
     stringtoencode[i] = substitute(stringtoencode[i], cipher);
 }
 }

 int main()
{
char c;
int option;
FILE *plik = fopen( ""hp.txt"", ""rt"" );
char* cipher1 = ""GADERYPOLUKIgaderypoluki"";
char* cipher2 = ""POLITYKARENUpolitykarenu"";
char* cipher3 = ""KACEMINUTOWYkaceminutowy""; 

printf(""Choose the cipher\n"");
printf(""[1]GA-DE-RY-PO-LU-KI\n"");
printf(""[2]PO-LI-TY-KA-RE-NU\n"");
printf(""[3]KA-CE-MI-NU-TO-WY\n"");
scanf(""%d"",&amp;option);

while((c = getchar()) != EOF)
{
c = getc( plik );
switch(option)
{
    case 1: putchar(substitute(c, cipher1));
        break;
    case 2:  putchar(substitute(c, cipher2));
        break;
    case 3:  putchar(substitute(c, cipher3));
        break;
}
}

fclose( plik );  
}
</code></pre>
",3
40763336,40746822,1,"<p>If I understand correctly you tried to save some intermediate result in <code>PREVIOUS_PRINTING</code> macro definition which should store the contents of macro <code>HIERARCHY_PRINTING</code> at that point to be used later, after <code>HIERARCHY_PRINTING</code> is undefined. </p>

<p>But such approach doesn't work since preprocessor doesn't unfold definitions  until they are needed. And <code>#undef</code> command just throws away what was defined before it. So for your example when preprocessor finishes handling of the header file it will have the following:</p>

<pre><code>#define PREVIOUS_PRINTING HIERARCHY_PRINTING "";""
#define HIERARCHY_PRINTING PREVIOUS_PRINTING
</code></pre>

<p>So when it will try to unfold the value of <code>HIERARCHY_PRINTING</code> it will get <code>HIERARCHY_PRINTING "";""</code> and that it since recursion is prohibited. And finally the compiler will complain for the undeclared <code>HIERARCHY_PRINTING</code> since there no such declarations in the code.</p>
",0
44356731,44356654,2,"<p>The simplest way without changing very much your code is declaring two variables <code>day</code> instead of one:</p>

<pre><code>int day_low = 0;
int day_high = 0;
</code></pre>

<p>Then change your <code>if</code> conditions below for these:</p>

<pre><code>if((high[0] &lt; high[i])) {
   high[0] = high[i];
   day_high = i;
}

if ((low[0] &gt; low[i])) {
   low[0] = low[i];
   day_low = i;
}
</code></pre>

<p>And finally:</p>

<pre><code>printf(""The highest temperature was %d, on day %d\n"", high[0], day_high);
printf(""The lowest temperature was %d, on day %d\n"", low[0], day_low);
</code></pre>
",2
44358142,44356654,0,"<p>Thanks everyone for the help. I had to add to variable and initiate as 0 as mentioned. </p>

<p>But was still wrong. Day one was showing as ""Day 0"". To fix it I add +1.</p>

<pre><code>if((high[0] &lt; high[i])){
       high[0] = high[i];
       highestDay = i + 1;
    }

    if ((low[0] &gt; low[i])){ 
       low[0] = low[i];
       lowestDay = i + 1;
    }  
</code></pre>
",0
40778221,40778110,2,"<p>First of all, this snippet</p>

<pre><code>printf(""Enter time:"");
scanf(""%d"", &amp;t);
</code></pre>

<p>shouldn't work as you haven't declared <code>t</code> as an integer, so just declare <code>t</code> on the line above like such.</p>

<p><code>int a, c, t;</code></p>

<p>You also didn't declare any of the variables in your <code>si</code> function. When you pass the <code>c</code> variable, it never gets initialized.</p>

<p>What will help your type mismatch error is a forward declaration of the <code>si</code> function.</p>

<p>By adding the line <code>float si(int a, int c, float b);</code> to the top of your program (above main), you let the compiler know what type of function <code>si</code> is, as well as what arguments to expect.</p>

<p>Here is my best attempt to fix up the code:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;

float si(int a, int c, float b);

float si(int a, int c, float b){
    float f;
    f=(a*b*c/100);
    return f;
 }

void main(){
    int a, c;
    float b, d;

    printf(""Enter principle value :"");
    scanf(""%d"", &amp;a);
    printf(""Enter rate :"");
    scanf(""%f"", &amp;b);
    printf(""Enter time:"");
    scanf(""%d"", &amp;c);

    d = si(a,c,b);
    printf(""The simple interest is %f"", d);
}
</code></pre>
",4
40778283,40778110,1,"<p>When you call </p>

<pre><code>d = si(a,c,b);
</code></pre>

<p>your program doesn't know of that function, because it's defined afterwards at the bottom. Look up ""forward declaration"" to fix this. Also, you use the variable 't' but I can't see it defined.</p>
",0
40997916,40997800,3,"<p>You have <code>header.h</code> included multiple times without an include guard.</p>

<p>You first include it in <code>fungsi.c</code>.  You then include it in <code>main.c</code>, which also includes <code>fungsi.c</code>.  So everything in <code>header.h</code> appears twice, resulting in multiple definition errors.</p>

<p>Put include guards into your header as follows:</p>

<pre><code>#ifndef HEADER_H
#define HEADER_H

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#define T_anak 200000
#define T_kes 1000000
#define T_makan 20000
struct date {
    int hari,bulan,tahun;
};

struct pegawai 
{
    int nip,jum_anak,jum_kk, gol;
    char nama[30];
    struct date lahir;
};

void fungsiInputpegawai();

#endif
</code></pre>

<p>The first time this include file is encountered, it defines the <code>HEADER_H</code> macro and the contents of the file are included.  Then if it is included a second time, <code>#ifndef HEADER_H</code> evaluates to false, so the remainder of the file (i.e. the struct definitions, variable and function declarations, etc.) is not processed and you don't have duplicate definitions.</p>

<p>Also, it's bad practice to include one .c file in another.  What you should be doing is compiling main.c and fungsi.c separately, then linking them.  </p>

<p>So remove <code>#include ""fungsi.c""</code> from main.c and compile as follows:</p>

<pre><code>gcc -c -Wall -Wextra fungsi.c
gcc -c -Wall -Wextra main.c
gcc -Wall -Wextra -o my_program main.o fungsi.o
</code></pre>
",1
40961245,40961091,0,"<p>I suggest this approach : </p>

<pre><code>int main()
{
    int c, array[MAXNUMBERS], maximum, amount_numbers;

    clrscr();

    getNumbers(array);



    location = find_maximum(array, MAXNUMBERS);
    if (location == -1 )
        printf(""No Even integer"");
    else {
        maximum = array[location];
        printf(""Highest even integer :%d"", maximum);
    }
    getch();
}
int find_maximum(int a[], int n) {
    int c, max, index;

    max = -10000; // A very low number
    index = -1; // shows that no even integer is found yet.

    for(c = 1 ; c &lt; n ; c++) {
        if(a[c] &gt; max &amp;&amp; a[c] %2 == 0) {
            index = c;
            max = a[c];
        }
    }

    return index;
}
int getNumbers(int arr[])
{
    int c;
    printf(""You may enter a max. %d numbers, enter a number less than 1 to end.\n"", MAXNUMBERS);

    for(c = 0 ; c &lt; MAXNUMBERS ; c++)
    {
        scanf(""%d"", &amp;arr[c]);
        fflush(stdin);
        if(arr[c] &lt; 1)
        {
            break;
        }
    }
}
</code></pre>

<p>You should first scan the array from the user which is what getNumbers function does.
Next you need to find the highest even integer which is what find_maximum funciton does.
this function returns index of the highest event integer in your array. the default value is -1 which indicates that no even value is found ! if it's given any other value means that found the highest even integer.
so now that you have the index you check if it's -1(not found) or it's found (returned index).</p>
",0
40961394,40961091,0,"<p>There is no sense to define an array for a sequence of numbers with undefined size that to determine the maximum value. When a next number is entered you can compare it with the current maximum value provided that the entered number is even.</p>

<p>The program can look the following way</p>

<pre><code>#include &lt;stdio.h&gt;

int main( void )
{
        int max = 0;
        int value;

        printf(""Enter a sequence of integer numbers.\n""
            ""Enter a number less than 1 to end: "");

        while (scanf(""%d"", &amp;value) == 1 &amp;&amp; !(value &lt; 1))
        {
            if (value % 2 == 0 &amp;&amp; max &lt; value) max = value;
        }

        if (max != 0)
        {
            printf(""Highest even integer: %d\n"", max);
        }
        else
        {
            puts(""No even integer"");
        }
}
</code></pre>

<p>As for your program then this loop is wrong.</p>

<pre><code>for (c = 0 ; c &lt; MAXNUMBERS ; c++)
{
    location = find_maximum(array, MAXNUMBERS);
    maximum = array[location];
}
</code></pre>

<p>For starters the number of entered values can be less than <code>MAXNUMBERS</code>. You have to use at least the variable <code>amount_numbers</code> in the condition.</p>

<p>Moreover the loop is not needed Because it does the same that is it calls several times the function  <code>find_maximum</code> and nothing is changed with the function result between iterations of the loop. Moreover you have to check whether the variable <code>location</code> gets value 0 and whether the element with this index is less or greater than 1. Otherwise you can show invalid result.</p>
",0
40961399,40961091,0,"<p>As commented, you are only required to output the answer so there is no need to store the input in an array. This shows how to do it with a simple loop. The program also ends at non-numeric input (effectively a 0 value).</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void) {
    int innum = 0;
    int maximum = 0;
    while(scanf(""%d"", &amp;innum) == 1 &amp;&amp; innum &gt; 0) {
        if(innum % 2 == 0 &amp;&amp; maximum &lt; innum) {
            maximum = innum;
        }
    }

    if(maximum &lt; 2) {
        puts(""NO EVEN INTEGER"");
    }
    else {
        printf(""Highest even integer: %d\n"", maximum);
    }
    return 0;
}
</code></pre>

<p>Program session:</p>

<pre>
3 8 1 5 3 4 -5
Highest even integer: 8
</pre>
",0
40981692,40981657,1,"<p>Try this:</p>

<pre><code>int t1 = time(0);
fire_neuron();     // place the ""neuron firing"" code here
int t2 = time(0);

printf(""Seconds taken to fire neuron: %d\n"", t2 - t1);
</code></pre>

<p>If you want to do it ""properly"", you can <code>#include &lt;time.h&gt;</code> and write it like this:</p>

<pre><code>time_t t1 = time(NULL);
fire_neuron();            // place the ""neuron firing"" code here
time_t t2 = time(NULL);

printf(""Seconds taken to fire neuron: %f\n"", difftime(t2, t1));
</code></pre>

<p>As I can't see your code, I don't know exactly how to help you. Maybe you want something like...</p>

<pre><code>if (dx[i] &lt;= -20) {
    time_t t1 = time(NULL);
    fire_neuron();
    time_t t2 = time(NULL);
}

printf(""Seconds taken to fire neuron: %f\n"", difftime(t2, t1));
</code></pre>
",8
40999850,40998756,1,"<p>Here is one possible implementation. I've tried to explain in comments as much as I can but feel free toleave a comment if there is something that's not clear.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdbool.h&gt;

int alphabetic(char *string)
{
    int i, valid;
    valid = true;
    for (i = 0; i &lt; strlen(string); i++)
    {
        if (toupper(string[i]) &lt; 'A' || toupper(string[i]) &gt; 'Z')
        {
            valid = false;
            // break here we are done;
            break;
        }

    }
    return valid;
}

void printArray(char* str)
{
    printf(""Array = "");
    for (int i = 0; i &lt; strlen(str); ++i)
    {
        printf(""%c"", str[i]);
    }
    printf(""\n"");
}

bool isPalindrome(char* str1, char* str2)
{
    bool isValidPalindrome = true;
    int length = strlen(str1);
    if (length != strlen(str2))
    {
        printf(""Strings must be the same lenth"");
        isValidPalindrome = false;
    }
    else
    {
        --length;
        for (int i = length; i &gt;= 0; --i)
        {
            if (str1[i] != str2[length - i])
            {
                isValidPalindrome = false;
                break;
            }
        }
    }
    return isPalindrome;
}

int main()
{
    const int length = 10;
    char c, inputarray[length], temp[length];
    int i = 0;
    // Comparing strings that have not been initialized
    // produces undefined behavior. Imagine inputArray is equal to:
    // inputArray: ""my String ... some other unknown stuff""... where does
    // the string ends? there is no '\n' in the horizon.
    // The stack error you are getting is produced by the statement
    // below. I've pusehd this statement below right after inputArray
    // has been initialized
    // strcpy(temp, inputarray);

    // You don't need the format specifier %s unless you
    // rewrite your printf statement as printf(""%s"", ""Please enter string"");
    // for simplicity you can write it as follows
    printf(""Please enter string: "");

    while ((c = getchar()) != '\n')
    {
        if (i &lt; length - 1)
            inputarray[i] = c;
        i++;
    }

    // Pulled the code inside the if to avoid multiple returns // just preference... not needed
    if (i &lt; length)
    {
        inputarray[i] = '\0';
        // helper function to print array
        printArray(inputarray);

        if (!alphabetic(inputarray))
        {
            printf(""Invalid input"");
        }
        // copy the strings here
        strcpy(temp, inputarray);
        // reverse the string here
        strrev(inputarray);
        // you will have to roll out your own isPalindrome
        // implementation since reversing a string and comparing it
        // with itself will always return false e.g.
        // inputArray = ""hello"";
        // copy inputArray into temp
        // temp = ""hello"";
        // reverse inputArray
        // compare strings: ""olleh"" == ""hello"" -&gt; false
        if (isPalindrome(inputarray, temp) == true)
            printf(""Palindrome\n"");
        else
            printf(""Not palindrome\n"");
    }
    else
    {
        inputarray[9] = '\0';
        printf(""String too long\n"");
    }
    return 0;
}
</code></pre>
",0
42517726,42517686,2,"<p>You are dividing two integers so the actual division returns the result rounded down. You should instead cast to double and then divide.</p>

<pre><code>test = ((double)i/squareRoot);
</code></pre>
",0
42517729,42517686,1,"<p>There are two things you can do,</p>

<ol>
<li><p>Without changing your program, simply cast the <code>i</code> and <code>squareRoot</code> variables to <code>double</code></p>

<pre><code>test = (double) i / (double) squareRoot;
</code></pre></li>
<li><p>Change your program and make <code>i</code> and <code>squareRoot</code> a <code>double</code>.</p></li>
</ol>

<p>I, would choose <em>2</em> because <code>sqrt()</code> returns a <code>double</code> and that might cause an integer overflow.</p>
",2
42618029,41156515,0,"<p>First of all the scanf(""%s"", &amp;text); you are using will not read any spaces. It will read only till the first space is encountered in the name. use scanf(""%[^/n]s"", &amp;text); instead to read the name with spaces.
The way your are reading the 2D array is wrong. The simple way is to use a  for loop.</p>

<p>example:</p>

<pre><code>for (i=0;i&lt;n;i++)
{
   scanf (""%[^/n]s,text[i]);
}
</code></pre>
",0
41176014,41156515,0,"<p>Simply because scanf read until the 1st space.
You have to use gets here.
This for a simple caracter counting without spaces:</p>

<pre><code>char str [100];
int i=0,cpt=0;
printf (""Enter some words: "");
gets (str);
While(str [i]!='\0'){
    if (str [i]!=' '){
        cpt++;
    }
    i++;
}

printf (""Size: %d"",cpt);
</code></pre>
",1
41186344,41185861,3,"<p>When you pick a character, just remove it from the set:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;

char getRandomChar(char *set) {
    size_t len = strlen(set);
    if (len == 0) {
        /* We are all out of characters */
        return -1;
    }
    /* Select a character at random */
    int rv = rand() % len;
    char ret = set[rv];
    /* Remove the selected character from the set */
    set[rv] = set[len -1];
    set[len -1] = '\0';
    /* Return the character */
    return ret;
}

int main(void) {
    char set[27] = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ"";
    char randomChar;

    /* Intialize random number generator */
   srand((unsigned)time(NULL));

    while ((randomChar = getRandomChar(set)) != -1) {
        printf(""Selected %c. Remaining: %s\n"", randomChar, set);
    }
    return 0;
}
</code></pre>

<p>Note that the code can handle that the same character occurs more than one time. If you want each character to be drawn twice, use the starting set <code>""AABBCCDDEEFFGGHHIIJJKKLLMMNNOOPPQQRRSSTTUUVVWWXXYYZZ""</code>.</p>
",7
41186230,41185861,0,"<p>If you can modify the characters, then randomly pick a character, if it's not zero (or something) then you have the character and you get it and set the entry to zero (or something). If it is zero (or something) then loop and pick another character.</p>

<p>If you can't modify the original characters, have another ""array"" that contains a boolean value if a certain character has been picked or not. It should mirror the dimensions of the <code>characters</code> arrays and you check that if a character has been picked or not.</p>
",0
44648459,44648270,0,"<p>Modify your program likes this and you'll find out what happens:</p>

<pre><code>#include &lt;stdio.h&gt;   //Sorting array program
#include &lt;assert.h&gt;

int main()
{
  int arr[20], i, j, n, temp;
  printf(""Enter number of elements  : "");
  scanf(""%d"", &amp;n);
  printf(""\nEnter the elements of the array : "");

  for (i = 0; i&lt;n; i++)
    scanf(""%d"", &amp;arr[i]);

  for (i = 0; i&lt;n; i++)
  {                                       // &lt;&lt;&lt; line added
    for (j = 0; j &lt; arr[i]; j++)
    {
      assert(j &lt; n);                      // &lt;&lt;&lt; line added
      assert(i + 1 &lt; n);                  // &lt;&lt;&lt; line added

      if (arr[i + 1] &lt; arr[i])
      {
        temp = arr[i];
        arr[i] = arr[i + 1];
        arr[i + 1] = temp;
      }
    }                                     // &lt;&lt;&lt; line added
  }

  printf(""\nThe sorted list is : \n"");

  for (i = 0; i&lt;n; i++)
    printf(""\n arr[%d] : %d"", i, arr[i]);

  return 0;
}
</code></pre>

<p>Read about <code>assert</code> <strong><a href=""https://www.tutorialspoint.com/c_standard_library/c_macro_assert.htm"" rel=""nofollow noreferrer"">here</a></strong>.</p>

<p>But anyway the algorithm looks fishy to me anyway:</p>

<p>This line is particularly suspicious:</p>

<pre><code>for (j = 0; j &lt; arr[i]; j++)
</code></pre>
",2
44649259,44648270,0,"<p>Try this</p>

<pre><code>#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;   //Sorting array program

int main()
{
    int arr[20], i, j, n, temp;

    printf(""Enter number of elements  : "");
    scanf(""%d"", &amp;n);
    printf(""\nEnter the elements of the array : "");
    for (i = 0; i&lt;n; i++)
        scanf(""%d"", &amp;arr[i]);

    for (i = 0; i&lt;n; i++)
    {
        for (j = 0; j&lt;n; j++)
            if (arr[i]&lt;arr[j])
            {
                temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
    }
    printf(""\nThe sorted list is : \n"");
      for (i = 0; i&lt;n; i++)
         printf(""\n arr[%d] : %d"", i, arr[i]);
    printf(""\n"");

   return 0;
}
</code></pre>
",0
44339827,44339804,2,"<pre><code>if (a=5)
</code></pre>

<p>its assigning 5 to a, also it makes <code>if</code> condition true so <code>printf(""a is five \t"");</code> this statement gets executed</p>
",3
44339834,44339804,0,"<pre><code>if(a=5)
</code></pre>

<p>is not a comparison, it's an assignment. in other words you are not asking whether a is five, you are setting a to five.</p>
",0
44339827,44339804,2,"<pre><code>if (a=5)
</code></pre>

<p>its assigning 5 to a, also it makes <code>if</code> condition true so <code>printf(""a is five \t"");</code> this statement gets executed</p>
",3
44339834,44339804,0,"<pre><code>if(a=5)
</code></pre>

<p>is not a comparison, it's an assignment. in other words you are not asking whether a is five, you are setting a to five.</p>
",0
41642698,41642445,4,"<p>The format <code>%6.3f</code> is incorrect for <code>scanf()</code>. You probably want <code>%f</code>, or possibly <code>%7f</code>. You cannot specify the number of decimals in a <code>scanf()</code> format.</p>
",1
41669703,41669631,3,"<p>There seems to be a bug in the <code>printf()</code> implementation on your system:</p>
<blockquote>
<p><strong>7.21.6.1: The <code>fprintf</code> function</strong></p>
<p>6 The flag characters and their meanings are:</p>
<p><code>+</code>   The result of a signed conversion always begins with a plus or minus sign. (It begins with a sign only when a negative value is converted if this flag is not specified.)</p>
<p><code>0</code>   For d, i, o, u, x, X, a, A, e, E, f, F, g, and G conversions, leading zeros (following any indication of sign or base) are used to pad to the field width rather than performing space padding, except when converting an infinity or NaN. If the <code>0</code> and <code>-</code> flags both appear, the <code>0</code> flag is ignored.</p>
</blockquote>
<p><code>%04.0f</code> should pad the number with leading <code>0</code>s after the negative sign and should not output a <code>+</code> unless you also pass the <code>+</code> flag as in:</p>
<pre><code>printf(&quot;%7.1f %+04.0f\n&quot;, (double) fahr, (double) celcius);
</code></pre>
",1
41685875,41669631,0,"<p>OP's <code>printf()</code> fails to print floating point numbers with the desired format.</p>

<p><em>Sometimes</em> the compiler/binary is faulty per specification <a href=""https://stackoverflow.com/a/41669703/2410359"">@chqrlie</a></p>

<p>Below is an integer only solution as a work around.</p>

<pre><code>  // Declare Variables
  int fahr;
  int milli_celcius;
  int lower, upper, step;

  // Initialize Variables
  lower = 0; // lower limit of temperature
  upper = 300; // upper limit
  step = 20; // step size
  fahr = lower;

  // Print out table
  while (fahr &lt;= upper) {
    printf(""%5d.0 "", fahr);
    milli_celcius = ((fahr - 32) * 5 * 1000) / 9;
    // round to nearest whole degree;
    int celcius = milli_celcius &lt; 0 ? 
        (milli_celcius - 1000 / 2) / 1000 :  
        (milli_celcius + 1000 / 2) / 1000;
    printf(""%+04d  Ref:%f\n"", celcius, (fahr - 32.0) * 5 / 9.0);
    fahr = fahr + step;
  }
</code></pre>

<p>Output</p>

<pre><code>    0.0 -018  Ref:-17.777778 
   20.0 -007  Ref:-6.666667 
   ...
  280.0 +138  Ref:137.777778 
  300.0 +149  Ref:148.888889 
</code></pre>
",1
41677756,41677371,2,"<p>When you test <code>err</code> after calling <code>semctl</code>, there is an error in the <code>if</code> statement. The cause is hard to see and obscured my a comment that sits too close to the code.</p>

<p>Here is the test without that comment:</p>

<pre><code>if (err == -1);
{
    perror(""semctl failed"");

    return 0;
}
</code></pre>

<p>The semicolon after the condition makes this an <code>if</code> with an empty body: The check is performed, but nothing is done.</p>

<p>The code block in curly braces is entered unconditionally, regardless of the value of <code>err</code>. Such blocks are legal and sometimes useful to structure your code and to define tightly scoped variables.</p>

<p><strong>TL;DR</strong>: Remove the semicolon:</p>

<pre><code>if (err == -1) {
    perror(""semctl failed"");
    return 0;
}
</code></pre>
",1
41687088,41686807,0,"<p>When you uncomment:</p>

<pre><code>//dup2(in, STDIN_FILENO); //if  I uncomment this it stops printing to out or err
</code></pre>

<p>you are making Python read from an empty file (it was created and/or truncated when you opened it), so Python gets nothing to do and exits.</p>

<p>Your reader code then sits in the <code>while (1) ;</code> loop doing nothing useful.</p>

<p>At the very least, add a <code>printf()</code> after the <code>system()</code> statement so you know when the Python command has completed.</p>
",3
44342668,44342542,-1,"<p>I'm not sure, but I have some ideas.
In float numbers any number consists of 2 parts: m,p. Any number can be shown as:
X = m * 2^p. (m and p - binary. 0&lt; m &lt;1)
So, if you try to do some calculations with numbers(X+Y), firstly computer needs to represent X and Y with the same p.
Simple example (not like in program, but like people could do the same):</p>

<pre><code>X=0.5, Y=1.45
  0.55+1.45
  0.55 * 10^0 + 0.145 * 10^1
  0.055 * 10^1 + 0.145 * 10^1 (*)
  0.200 * 10^1
</code></pre>

<p>BUT. If X and Y has too different p we have some problems in (*) line. m has limited number of digits, so:
Ex.:</p>

<pre><code>X = 0.1, Y = 0.000000000000000001
X + Y = 0.100000000000(000001) &lt;- this part didn't fit into m, so
X + Y = 0.1.
</code></pre>

<p>Hope you got what I wanted to say</p>
",5
44342668,44342542,-1,"<p>I'm not sure, but I have some ideas.
In float numbers any number consists of 2 parts: m,p. Any number can be shown as:
X = m * 2^p. (m and p - binary. 0&lt; m &lt;1)
So, if you try to do some calculations with numbers(X+Y), firstly computer needs to represent X and Y with the same p.
Simple example (not like in program, but like people could do the same):</p>

<pre><code>X=0.5, Y=1.45
  0.55+1.45
  0.55 * 10^0 + 0.145 * 10^1
  0.055 * 10^1 + 0.145 * 10^1 (*)
  0.200 * 10^1
</code></pre>

<p>BUT. If X and Y has too different p we have some problems in (*) line. m has limited number of digits, so:
Ex.:</p>

<pre><code>X = 0.1, Y = 0.000000000000000001
X + Y = 0.100000000000(000001) &lt;- this part didn't fit into m, so
X + Y = 0.1.
</code></pre>

<p>Hope you got what I wanted to say</p>
",5
41919089,41919033,1,"<p>This is probably due to <code>int</code> is signed and becomes negative after <code>2e16 - 1</code>. </p>

<p>Try using <code>unsigned int</code>. But even if this works, you are still limited but <code>int</code> maximum size.</p>

<p>You can try using <code>unsigned long</code> or <code>unsigned long long</code> or <code>double</code> to check how far you can get with your function.</p>
",1
42499880,42494932,0,"<p>From ""The C Programming Language"" by Kernighan and Ritchie: </p>

<blockquote>
  <p>""The switch statement is a multi-way decision that tests whether an expression matches one of a number of <strong>constant integer values</strong>, and branches accordingly.""</p>
</blockquote>

<p>So it should look similar to this:</p>

<pre><code>while ((choice = getchar())!= EOF){
    switch (choice){
      case '1':
          // calculate Fibonacci sequence
          break;
      case '2':
          return 0;
    }
}
</code></pre>

<p>As one of the comments suggests, either initialize your local variables in the beginning or check the return value of your getchar() or scanf() calls, since values of uninitialized variables are indeterminate.</p>

<p>If you've just started studying C, I suggest that you read the book that I mentioned. It's relatively short and has lots of helpful examples.</p>
",2
47552923,47552778,5,"<p><code>memset</code> is not designed for setting values of objects other than arrays of characters or bytes. <code>memset</code> fills every byte of the destination with the same value. When you use <code>memset(destination, 24, sizeof(int))</code>, you are filling each byte with the value 24. Those combined bytes make a very larger integer value.</p>

<p>Although you fill the <code>age</code> field with a large integer, you do not see it in your <code>printf</code> because you pass the value to <code>printf</code> using <code>*(Person_data)</code>. Since <code>Person_data</code> is a pointer to <code>char</code>, this expression only fetches one character from the object, so it only gets one of the bytes containing <code>24</code>. In contrast, when you use <code>Person1-&gt;age</code>, <code>age</code> is an <code>int</code>, so the entire <code>int</code> is fetched.</p>

<p>Additionally, you should not assume you can simply add the sizes of objects in a structure to get the addresses of the members. Most hardware architectures have alignment requirements for data, meaning that objects of more than one byte must start at memory addresses that are multiples of their size or of values such as two, four, or eight bytes. When you declare a structure with diverse object types in it, the compiler includes some unused space between them to make the alignments correct. There is an <code>offsetof</code> macro in the <code>&lt;stddef.h&gt;</code> header that will give you the offsets of members within a structure. (I am assuming this code is just for exploring how C works and not for use in a real product. If it were for use in a real product, this is very bad code for that.)</p>

<p>The assignment operator <code>=</code> knows how many bytes to move because the compiler knows the type of the left operand (because you have declared the type previously in your source code).</p>

<p>If you do want to set an <code>int</code> to 24 by writing to its individual bytes, then you have to put 24 in its low-valued byte and 0 in its other bytes. However, which byte is the low-valued byte varies from system to system. Some hardware architectures put the low-valued byte in the low address, and some put it in the high address. (And, if you want to set an <code>int</code> to a value greater than fits into a byte, you have to break it into multiple bytes and write those.)</p>
",0
47552975,47552778,9,"<p>Whatever you want to do, don't do it that way.</p>

<pre><code>char Person_Data[50];
size_t offset = 0;
memset(Person_Data + offset, 24, sizeof(int));
offset += sizeof(int);
memset(Person_Data + offset, 'M', sizeof(char));
offset += sizeof(char);
memset(Person_Data + offset, 55, sizeof(int));
</code></pre>

<p>This will create the following memory layout (ints assumed to be 32 bit):</p>

<pre><code>+--+--+--+--+--+--+--+--+--+--+--+--+
|18|18|18|18| M|37|37|37|37|xx|xx|xx| 
+--+--+--+--+--+--+--+--+--+--+--+--+
 \   int   /char\  pad / \   int   / 
</code></pre>

<p>You copy into wrong locations.</p>

<p>Why does printing seem to work?
Because you don't print int values but only char.</p>

<pre><code>printf(""Age = %d, Gender = %c, weight = %d\n"", *(Person_Data), *(Person_Data + sizeof(int)), *(Person_Data + sizeof(int) + sizeof(char)));
</code></pre>

<p>The single character values are read from memory and promoted to <code>int</code> before passing to <code>printf</code>.</p>

<p>As a general rule:</p>

<ul>
<li>Don't calculate offsets, but use <code>offsetof</code> as already suggested in comments.</li>
<li>Don't use <code>memset</code> to fill integers.</li>
<li>Don't mess around with <code>char</code> arrays if you want to use structures.</li>
</ul>
",2
42673641,42673564,2,"<p>You must repeat the</p>

<pre><code>if(is_word_started==1)
{
    is_word_started=0;
    word[j]='\0';
    printf(""%s\n"", word);
    j=0;
}
</code></pre>

<p>outside the <code>for ()</code> cycle (at the end of its <code>}</code>)</p>

<p>Otherwise when you finish parsing the <code>str</code>, the letters you were accumulating in <code>word</code> are ""lost"".</p>

<p>Technically you could short it to:</p>

<pre><code>if(is_word_started==1)
{
    word[j]='\0';
    printf(""%s\n"", word);
}
</code></pre>

<p>because after that you won't reuse those variables.</p>

<p>Other than the ""Never use <code>gets()</code>"" suggested by @usr, you should correctly-size <code>word</code>: always use the worst case. If <code>str[1000]</code> then <code>word[1000]</code>!</p>
",0
45675598,45675563,0,"<p>When referencing a <code>struct</code> type, you need to use the <code>struct</code> keyword:</p>

<pre><code>struct test *tester() {
   ...
}
</code></pre>

<p>If you want to be able to use <code>test</code> as a type, you need a <code>typedef</code>:</p>

<pre><code>typedef struct test {
  int id_number;
  int age;
} test;
</code></pre>
",0
45675611,45675563,0,"<p>The type is called <code>struct test</code>, unless you add a <code>typedef</code>:</p>

<pre><code>typedef struct test test;
</code></pre>

<p>You can combine the two, this is very common:</p>

<pre><code>typedef struct {
  int id_number;
 int age;
} test;
</code></pre>

<p>This is very common; notice that the ""struct tag"" can be omitted.</p>
",0
42658981,42658947,2,"<p>Mutual inclusion is your problem. <code>storage.h</code> must include <code>list.h</code> to compile, and <code>list.h</code> includes <code>storage.h</code> for some reason.</p>

<p>So simply remove the redundant include of <code>storage.h</code> from <code>list.h</code></p>
",10
42634282,42634221,3,"<p>This is because <code>set</code> is uninitialized, ie, you never set it. You do this:</p>

<pre><code>set==i;
return set;
</code></pre>

<p>which is comparing <code>set</code> to <code>i</code> (which does nothing). Then you return it uninitialized. Do</p>

<pre><code>return i;
</code></pre>

<p>Since you don't use <code>set</code> for anything anyway.</p>
",1
42634382,42634221,2,"<p><code>j = round(pow(i, e))</code> would be a lot more stable; truncating floating point to the next-lower integer exaggerates tiny errors if they happen to be in the wrong direction.</p>

<p>But you can probably do better by estimating the root with an inverse exponent:</p>

<pre><code>int root = round(pow(number, 1.0/e));
</code></pre>

<p>Then just check if <code>root</code> to the power of <code>e</code> is <code>number</code>.</p>
",0
42635605,42634221,0,"<p>The function pow takes a <code>double</code> argument for the power, which would be <code>1.0 / n</code> for the n-th root.</p>

<p>This program then uses integer arithmetic on values bracketing the result, to see if they power up correctly. There is no need for an exhaustive loop.</p>

<p>The program run-arguments are <code>number</code> and <code>n-th root</code>.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

unsigned powN (unsigned num, unsigned power)
{
    unsigned prod = 1;
    while (power) {
        if (power &amp; 1)
            prod *= num;
        num *= num;
        power &gt;&gt;= 1;
    }
    return prod;
}

int main(int argc, char *argv[])
{
    unsigned number, root, answer, test;

    if(argc &lt; 3) {
        return 0;
    }
    if(sscanf(argv[1], ""%u"", &amp;number) != 1) {
        return 0;
    }
    if(sscanf(argv[2], ""%u"", &amp;root) != 1) {
        return 0;
    }

    answer = (unsigned)pow(number, 1.0 / root);

    // check this value
    test = powN(answer, root);
    if(test == number) {
        printf(""%u**%u = %u\n"", answer, root, number);
        return 0;
    }

    // check the value above
    test = powN(answer+1, root);
    if(test == number) {
        printf(""%u**%u = %u\n"", answer+1, root, number);
        return 0;
    }

    // check the value below
    if (answer &gt; 1) {
        test = powN(answer-1, root);
        if(test == number) {
            printf(""The %u**%u = %u\n"", answer-1, root, number);
            return 0;
        }
    }

    printf(""No exact %u-th root of %u\n"", root, number);
    return 0;
}
</code></pre>

<p>Sample runs:</p>

<pre>
test 49 2
7**2 = 49

test 50 4
No exact 4-th root of 50

test 64 3
4**3 = 64

test 16807 5
7**5 = 16807
</pre>
",0
42634275,42634221,2,"<p>You have a typo</p>

<pre><code>set == i
</code></pre>

<p>probablye should be</p>

<pre><code>set = i
</code></pre>

<p>DO NOT IGNORE COMPILER WARNINGS, and if you don't have them activate them. Also, try to use the most recent compiler, to get the newest diagnostic power.</p>
",0
43222124,43221093,1,"<p>You are using <code>int</code> where you should have been using <code>time_t</code>. <code>int</code> can potentially overflow in this context leading to undefined behavior.</p>
",0
43221256,43221093,0,"<p>Depending on how fast your computer is, the loop without the print may take less than a second to run 10 million times, so may seem to exit 'instantly' (it takes about a second and a half on my averageish 2 yr old desktop).</p>

<p>If you want an infinite loop, use <code>while(1)</code> or <code>for(;;)</code></p>
",0
43227168,43221093,0,"<ol>
<li><em>clock();</em> returns the amount of time spent in your program.</li>
<li><em>CLOCKS_PER_SEC</em> This macro expands to an expression representing the
number of clock ticks per second.</li>
</ol>

<p>Now as @Chris_Dodd said, your CPU is very fast. So <strong>time will immediately reach the value 5.</strong> </p>
",0
43745397,43745168,0,"<p>Note that <code>s[i].ID</code> is defined as <code>char   ID[8]</code>. Howevr, the ID as input is <strong>1234567b</strong> which is 8 characters. If the id was supposed to be <code>1234567</code>, then you neglected to put in the <code>\0</code> NULL character that is required to end the string. As a result  <code>printf("" ID STUDENT  :%s\n"",s[i].ID);</code> prints from the start of <code>s[i].ID</code> until the first NULL charater (at the end of the name).</p>
",3
46085214,46084911,0,"<p>As suggested in the comments try to trace the code by hand, I will go through the first two iterations with you so you get the idea</p>

<p>When your program starts it calls your <code>main</code> function, and starts executing the for loop as follows:</p>

<pre><code>i=0 =&gt; calls F(n=0) =&gt; is n==0 true? Yes =&gt; return 1 =&gt; print 1

i=1 =&gt; calls F(n=1) =&gt; is n==0 true? No =&gt; then 1-M(F(0)) =&gt; F(0) calculated from the previous iteration to return a value of 1 =&gt; call M(n=1) =&gt; is n==0 true? No =&gt; then 1-F(M(0)) =&gt; M(0) returns 0 since n==0 is true =&gt; then 1-F(M(0)) is equal to 1-F(0) =&gt; we calculated F(0) to return 1 =&gt; so 1-F(0) return 0 from M =&gt; take the return back to 1-M(F(0)) =&gt; 1-0 = 1 =&gt; print 1
</code></pre>

<p>Do not be frustrated because what you are asking would be actually much easier to understand with some patient. I extremely recommend that you hold down a pen and paper and start tracing yourself.</p>

<ol>
<li>Go iteration by iteration as I did.</li>
<li>Call each function according to the correct flow of the if conditions.</li>
<li>When you call a function, mark where you have left in the code to jump to said function, such that once it returns a value, you know exactly where to place the returned value.</li>
</ol>

<p>Peace of paper, patience, and trace.</p>
",0
46085056,46084911,0,"<p>Consider on <code>for</code></p>

<pre><code>for(i=0;i&lt;6;i++)
{
    printf(""%2d\n"",F(i));
}
</code></pre>

<p><strong>Short answer:</strong></p>

<p><code>F(0) =&gt; 1;</code></p>

<p><code>F(1)=&gt; 1 - M(F(0))</code></p>

<pre><code>when  F(0):1 then F(1) = 1 - M(1)
go to calculate M(1), but we start from 0, M(0)= 0;
M(1) = 1- F(M(0)) = 1- F(0) = 1-1=0;
last we have M(1) = 0; and as F(1) = 1-M(1) = 1-0=1
last we have: F(1)=1
</code></pre>

<p><strong>More complete:</strong></p>

<p>Let see <code>F()</code> way of working.
the last command in <code>F()</code>, 
  <code>return(n==0)?1:n-M(F(n-1));</code></p>

<p>expanded to </p>

<pre><code>if (n==0){
 return 1;
}else{
   return n-M(F(n-1));
}
</code></pre>

<p>In first for iteration <code>i:0</code>, we want <code>F(0)</code> as n is zero, (<code>n:0</code>), the <code>if (n==0)</code> is true , <code>return 1;</code> is executed and value of<code>F(0)</code> have to be 1.</p>

<p>for second iteration we want <code>F(1)</code>, for that <code>if (n==0)</code> is false and else block is execute.</p>

<p>as now the <code>n:1</code>, <code>F(1) = 1 - M (F(0))</code>.</p>

<p>In previous iteration we have <code>F(0)=1</code>, OK now we can rewire or equation: <code>F(1) = 1 - M(1)</code>, it obvious that if we have value of <code>M(1)</code> simply , put it on to the last formula , <code>F(1)</code> have been solved. </p>

<p>for this we must expand <code>M()</code> function.</p>

<p>Similarly we can write for  <code>M()</code>.   </p>

<pre><code>if (n==0){
 return 0;
}else{
   return n-F(M(n-1));
}
</code></pre>

<p><code>M(0) = 0;</code></p>

<p><code>M(1)= 1- F(M(0))= 1- F(0) = 1 - 1=0;</code></p>

<p>now we have <code>M(1) = 0;</code> by putting it on the <code>F(1) = 1 - M(1)</code> 
we achieve to <code>F(1) = 1</code>.</p>

<p>Now the first two pair of <code>1</code> in output of your code is calculated by hand.</p>

<p>for others, do this way over and over. </p>
",0
43191289,43191066,0,"<p>You only <code>malloc</code> memory for <code>id</code> once. You need to do it for each book:</p>

<p>Like:</p>

<pre><code> // books-&gt;id=(char*)malloc(100);              Remove this line
 fptr=fopen(filename,""r"");
 if(fptr==NULL)
    return-1;
//this gets all the books into the book array
  for(i=0;i&lt;bookcount;i++){
    fgets(tempstring,maxsize,fptr);
    token=strtok(tempstring,"","");
    books[i].id=(char*)malloc(100);    //        Add this line
    strcpy(books[i].id,token);
</code></pre>

<p><strong>BTW</strong></p>

<p>This code seems strange:</p>

<pre><code> while(libsize&lt;bookcount){
    libsize *= 1.5;
 }
 books = (book*) malloc(libsize*sizeof(book));
</code></pre>

<p>why not simply do:</p>

<pre><code> books = (book*) malloc(bookcount*sizeof(book));
</code></pre>

<p>(note: you don't need to cast <code>malloc</code>)</p>
",3
43193929,43190962,0,"<p>If your line format is fixed, something like could make the job:</p>

<pre><code>#include &lt;stdio.h&gt;

struct point {
    float x;
    float y;
};

int main() {
    FILE *fp = fopen(""b.txt"", ""r"");
    int i = 0;
    struct point p[3];
    char bracket, comma;

    fscanf(fp, ""(%f,%f) (%f,%f) (%f,%f)"", &amp;p[0].x, &amp;p[0].y, &amp;p[1].x, &amp;p[1].y,
           &amp;p[2].x, &amp;p[2].y);

    for (int j = 0; j &lt; 3; j++) {
        printf(""%.2f %.2f\n"", p[j].x, p[j].y);
    }

    fclose(fp);
    return 0;
}
</code></pre>

<p>In order to understand the code I'd recommend you take a look to <a href=""https://www.tutorialspoint.com/c_standard_library/c_function_fscanf.htm"" rel=""nofollow noreferrer"">fscanf</a> docs</p>
",0
43970335,43970197,1,"<p>The reason you are getting this problem is most likely the thing that @Steephen has already pointed out: <code>(*sys)-&gt;c_array = malloc(num_challenges * sizeof(Activity));</code>. It's most likely that the extra bracket was causing the error.</p>
",3
46987059,46987039,3,"<p>When <code>func</code> is invoked, it creates a stack for its local variables <code>x</code> and <code>p</code>. However, when it returns, this stack is destroyed. Therefore, <code>p</code> points a value that has already been destroyed, so its behavior is undefined.</p>
",0
43969366,43969296,4,"<p>I assume they intend to run this program like so:</p>

<pre><code>./example &lt; example.c
</code></pre>

<p>You are correct about the fact that the program does not open a file and it does not use arguments. The getchar() function operates on stdin.
The program does not make much sense if you use it on the compiled file, so that is why I assumed it is supposed to be run with the source file. I see how the instructions are confusing.</p>
",0
45089848,45089411,2,"<p>From what I can tell, <code>g1</code> returns a pointer to an array of <code>char</code> containing exactly 10 elements, whereas <code>g2</code> returns a pointer to a single <code>char</code>, which would allow for a <code>char</code> array of any length following it in memory.</p>

<p>Seeing as C will not enforce the bounds of an array, the only advantage I can see with <code>g1</code> over <code>g2</code> is the ability to specify a size when assigning a variable, just as you have mentioned.</p>

<p>If you wanted to rewrite <code>g1</code> using a <code>typedef</code>, you could use the following:</p>

<pre><code>typedef char (*char_array_t)[10];

char_array_t g1(int dummy)
{
 char_array_t p = malloc(sizeof *p);
 return p;
}
</code></pre>
",1
45090063,45089411,2,"<p><code>g1</code> is more ""correct"" since it accurately reflects the type of the object you are returning (pointer to 10-element array of <code>char</code>).  You don't normally see functions that return pointers to arrays, since the array size must be fixed at compile time, limiting its usefulness, and most of us subconsciously avoid writing code like that because it's just too damned eye-stabby.  If I were writing a function that allocated a 2D array, I'd usually write it as</p>

<pre><code>void g1( size_t rows, size_t cols, char (**p)[cols] )
{
  *p = malloc( sizeof **p * rows );
}

int main( void )
{
  char (*table)[10];
  g1( 5, 10, &amp;table );
  if ( table )
  {
     ...
  }
}
</code></pre>

<p>which allows me to take advantage of VLA semantics (in C99 or later), making it flexible without being <em>excessively</em> ugly.</p>

<p>You <em>can</em> typedef some of the ugliness away:</p>

<pre><code>typedef char MyType[10];

MyType *g1( int dummy );
{
  MyType *p = malloc( sizeof *p );
  ...
  return p;
}
</code></pre>

<p>but I'm leary of using <code>typedef</code>s just to make the code scan better.  You should only <code>typedef</code> a type for <em>abstraction</em> purposes (i.e., to hide the implementation from the user of the type).  If the user of the type needs to be aware of the ""array-ness"" of the type, then do <em>not</em> hide it behind a <code>typedef</code>.  </p>

<p>I don't like <code>g2</code> because it <em>lies</em>.  <code>p</code> is not a <code>char *</code>, it's a <code>char (*)[10]</code>.  That <em>matters</em>.   </p>
",2
45091063,45089411,1,"<blockquote>
  <p>Is there a better way to write?</p>
</blockquote>

<p>If the function needs to return ""a pointer to an array of size 10 chars"" then <code>g1()</code> is fine.  It meets the design goal.</p>

<pre><code>char (*g1(int dummy))[10] {
 char (*p)[10] = malloc(sizeof *p);
 return p;
}
</code></pre>

<p>If the function needs to return ""a pointer to 10 chars"" then use</p>

<pre><code>char *allocate10char(int dummy) {
 char *p  = malloc(sizeof *p * 10);
 return p;
}
</code></pre>

<p>If <code>char (*g1(int dummy))[10]</code> is too strange, then the coding goal needs to imporve.</p>

<p>`</p>
",0
43764353,43764335,4,"<pre><code>scanf(""&amp;d"", &amp;n);

scanf(""&amp;d"", &amp;m);
</code></pre>

<p>You need to change it to</p>

<pre><code>scanf(""%d"", &amp;n);

scanf(""%d"", &amp;m);
</code></pre>

<p>Additionally in printf function you should not pass address of variables</p>
",0
43764439,43764335,1,"<p>There are several problems in your code. First your <code>scanf()</code> should be like this: </p>

<pre><code>scanf(""%d"", &amp;var);
</code></pre>

<p>Next off is in your <code>printf</code> statement. In the var section, you did <code>&amp;cake</code> and <code>&amp;m</code> which is wrong due to the fact you are gonna print the address of the variable. To fix that, remove the <code>&amp;</code>.</p>
",0
43764532,43764335,3,"<p>The ""&amp;d"" holds the address of the particular variable. So, you need to change the 
    <code>scanf(""&amp;d"",&amp;m)</code> to <code>scanf(""%d"",&amp;m)</code> and <code>scanf(""&amp;d"",&amp;n)</code> to <code>scanf(""%d"",&amp;n)</code>. Here <code>%d</code> is the placeholder for integer variables.
Similarly, in the final print statement the ampersand <code>&amp;</code> prints the address not the value, so remove <code>&amp;</code> in final printf statement</p>
",1
43764353,43764335,4,"<pre><code>scanf(""&amp;d"", &amp;n);

scanf(""&amp;d"", &amp;m);
</code></pre>

<p>You need to change it to</p>

<pre><code>scanf(""%d"", &amp;n);

scanf(""%d"", &amp;m);
</code></pre>

<p>Additionally in printf function you should not pass address of variables</p>
",0
43764439,43764335,1,"<p>There are several problems in your code. First your <code>scanf()</code> should be like this: </p>

<pre><code>scanf(""%d"", &amp;var);
</code></pre>

<p>Next off is in your <code>printf</code> statement. In the var section, you did <code>&amp;cake</code> and <code>&amp;m</code> which is wrong due to the fact you are gonna print the address of the variable. To fix that, remove the <code>&amp;</code>.</p>
",0
43764532,43764335,3,"<p>The ""&amp;d"" holds the address of the particular variable. So, you need to change the 
    <code>scanf(""&amp;d"",&amp;m)</code> to <code>scanf(""%d"",&amp;m)</code> and <code>scanf(""&amp;d"",&amp;n)</code> to <code>scanf(""%d"",&amp;n)</code>. Here <code>%d</code> is the placeholder for integer variables.
Similarly, in the final print statement the ampersand <code>&amp;</code> prints the address not the value, so remove <code>&amp;</code> in final printf statement</p>
",1
43723857,43723579,0,"<p>You should look up the ASCII table to see how characters are represented in a computer.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main()
{
    char string[100] = """";
    int length;
    int i;
    char largest = 'a' - 1; // Init to a value not in ASCII table
    unsigned char smallest = 'z' + 1; // Init to a value not in ASCII table

    scanf(""%s"", string);
    length = strlen(string);

    for (i = 0; i &lt; length; i++) {
        if(string[i] &gt;= 'a' &amp;&amp; string[i] &lt;= 'z') {
            if(string[i] &lt; smallest) {
                smallest = string[i];
            }
            if(string[i] &gt; largest) {
                largest = string[i];
            }
        }
    }

    for(i = smallest; i &lt;= largest; i++) {
        printf(""%c"", i);
    }
    printf(""\n"");    

    return 0;
}
</code></pre>

<p>Basically what I'm doing is checking to make sure each char is in the range of 'a' to 'z' because a char in the C language is really an 8 byte integer thus chars can be compared to ints. Then I save the smallest and largest values and loop through them while printing them.</p>
",6
43726361,43723579,1,"<blockquote>
  <p>what is the smallest and largest letter and how to i make him type the letters in between ?</p>
</blockquote>

<p>You should be aware that both your problem statement and your code depend on specifics of the ASCII character set, so it's not a portable result. There's nothing wrong with depending on that, but ASCII is not universal and there is no guarantee that letters are represented consecutively in <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""nofollow noreferrer"">the C Standard</a>, so there is no easy way to say ""the letters in between"".  Only the digits <code>0</code>-<code>9</code> have the guarantee. Per <strong>5.2.1 Character sets</strong>, paragraph 3  of the  C Standard:</p>

<blockquote>
  <p>Both  the  basic  source  and  basic  execution  character  sets 
  shall  have  the  following members: the 26 uppercase letters of the
  Latin alphabet</p>

<pre><code>A B C D E F G H I J K L M
N O P Q R S T U V W X Y Z
</code></pre>
  
  <p>the 26 lowercase letters of the Latin alphabet</p>

<pre><code>a b c d e f g h i j k l m
n o p q r s t u v w x y z
</code></pre>
  
  <p>the 10 decimal digits</p>

<pre><code>0 1 2 3 4 5 6 7 8 9
</code></pre>
  
  <p>the following 29 graphic characters</p>

<pre><code>! "" # % &amp; ' ( ) * + , - . / :
; &lt; = &gt; ? [ \ ] ^ _ { | } ~
</code></pre>
  
  <p>the  space  character, and  control  characters  representing 
  horizontal  tab,  vertical  tab,  and form  feed.   The 
  representation  of  each  member  of  the  source  and  execution 
  basic character sets shall fit in a byte.  <strong>In both the source and
  execution basic character sets, the value of each character after <code>0</code>
  in the above  list of decimal digits shall be one greater than the
  value of the previous.</strong> ...</p>
</blockquote>

<p><a href=""https://en.wikipedia.org/wiki/EBCDIC"" rel=""nofollow noreferrer"">Letters do not have to be represented consecutively.</a>  <code>'a' + 1</code> does not have to be equal to <code>'b'</code>.</p>

<p>The portable way to identify a letter is with the <code>isalpha()</code> function:</p>

<blockquote>
  <p><strong>7.4.1.2  The <code>isalpha</code> function</strong></p>
  
  <p>...</p>
  
  <p>The <code>isalpha</code> function tests for any character for which <code>isupper</code> or
  <code>islower</code> is true, or  any  character  that  is  one  of  a 
  locale-specific  set  of  alphabetic  characters  for  which none  of
  <code>iscntrl</code>, <code>isdigit</code>, <code>ispunct</code>, or <code>isspace</code> is  true. In  the <code>""C""</code>
  locale, <code>isalpha</code> returns true only for the characters for which
  <code>isupper</code> or <code>islower</code> is true.</p>
</blockquote>
",0
43724655,43724418,3,"<p>The main problem is that you're passing a pointer on the same array of chars each time, just shifting the address by one:</p>

<pre><code>scanf(""%s"",&amp;first_name[i]);
</code></pre>

<p>That stores the first string in <code>first_name</code>, the second one in <code>first_name+1</code> (destroying the first string except for the first character) and ends up overwriting unallocated memory, since 1 byte is not enough to store the last item (when you reach the last item, you overflow your char array): <em>undefined behaviour</em> occurs then.</p>

<p>Also, computing string length with <code>length = sizeof(first_name[i])/sizeof(char);</code> is not correct. The value is 1 here, so your lowercase loop does nothing. use <code>strlen(first_name[i])</code> for that.</p>

<p>In the end, I suppose that you want to declare a 2D array holding 10 slots of 100-length strings:</p>

<pre><code>char first_name[10][100];
</code></pre>

<p>And in the rest of your code replace</p>

<pre><code>&amp;first_name[xxx];
</code></pre>

<p>by</p>

<pre><code>first_name[xxx];
</code></pre>

<p>to get the address of the xxxth string of your table, in a simple way.</p>

<p>BTW: For extra safety use a limit when doing <code>scanf</code>:</p>

<pre><code>scanf(""%99s"",first_name[i]);
</code></pre>

<p>so noone can enter more than 99 chars and crash/exploit your program.</p>
",0
46988919,46988265,0,"<p>You are not allowed to suppose that the number of bits in char is 8 and insert that magic constant there, as the definition of C says, it must be at least 8, but there is no upper limit, otherwise your code is not portable.</p>

<p>Next, sizeof(char) = 1 all the time, even when char type is implemented on 16, 64 bits, etc.  There are compilers that implement char on 64 bits, simply to avoid to to perform any kind of implicit arithmetic conversions.</p>

<p>The number of bits is found in <code>limits.h</code>, the macro named CHAR_BIT, in my case it is defined so by my compiler:</p>

<pre><code>/* Number of bits in a `char'.  */
#  define CHAR_BIT  8
</code></pre>

<p>There are lots of ways to reverse a byte, here is one way (supposing your code implements it on 8 bits or 16 bits, you can keep a precomputed table):</p>

<pre><code>char rev_byte(char byte) {
  char reversed_table = {0x00, 0x80, 0x40, ...};
  return reversed_table[byte];
}
</code></pre>

<p>Here is another way to reverse the bits in a byte <code>char x</code>, supposing as well that a byte has 8 bits. I also explained each step of the algorithm composed of a few bitwise instructions.</p>

<p>Suppose</p>

<blockquote>
  <p>X = [ a b c d e f g h ]   <strong>INITIALLY</strong></p>
</blockquote>

<pre><code> /* 0x55 = ~0xAA -- 0101 0101 ~ 1010 1010 /*
 /* switch 8 groups of 1 */
 x = (x &amp; 0x55) &lt;&lt;  1 | (x &amp; 0xAA) &gt;&gt;  1;  
</code></pre>

<blockquote>
  <p>==> X = [ b a d c f e h g ]</p>
</blockquote>

<pre><code> /* switch 4 groups of 2 now */
 x = (x &amp; 0x33) &lt;&lt;  2 | (x &amp; 0xCC) &gt;&gt;  2;  
</code></pre>

<blockquote>
  <p>==> X = [ d c b a h g f e ] </p>
</blockquote>

<pre><code> /* switch 2 groups of 4 now */
 x = (x &amp; 0x0F) &lt;&lt;  4 | (x &amp; 0xF0) &gt;&gt;  4;  
</code></pre>

<blockquote>
  <p>==> X = [ h g f e d c b a ] </p>
</blockquote>
",0
45054700,45054609,4,"<p>Nearly correct.</p>

<p>The wrong ones are (a), (c) and (e) (1,3,5, after the edit).</p>

<p>The explanation for all of them is basically the same: (a) and (e) perform pointer arithmetics, this isn't possible on <code>void *</code>, because <code>void</code> is unknown and doesn't have a size. (c) is similar, <code>sizeof()</code> is given a <code>void</code> expression, again, <code>void</code> doesn't have a size.</p>
",3
45054885,45054609,2,"<p>The wrong ones are: 1,3,5 because </p>

<h2>Arithmetic on a <code>void*</code> is illegal in both C and C++.</h2>

<p>From the Standard:</p>

<blockquote>
  <p>6.5.6-2: For addition, either both operands shall have arithmetic type, or one operand shall be a pointer to an object type and the
  other shall have integer type</p>
  
  <p>6.2.5.1: Types are partitioned into object types (types that fully describe objects) , function types (types that describe functions),
  and incomplete types (types that describe objects but lack information
  needed to determine their sizes).</p>
  
  <p>6.2.5-19: The void type comprises an empty set of values; it is an incomplete type that cannot be completed</p>
</blockquote>

<p><code>void</code> is incomplete (<strong>which translates to, the compiler does not know its size</strong>) so by <code>6.5.6-2</code> you can't use it in the aforementioned expressions.</p>
",0
45055517,45054609,1,"<pre><code>vptr++
</code></pre>

<p>is incorrect because vptr is a pointer that points to an object of unknown size, so this expression will be desugared in <code>vptr+=sizeof(*vptr)</code> and the type of <code>*vptr</code> is void; <code>sizeof(void)</code> is undefined as the type is incomplete.  <code>gcc</code> considers <code>sizeof(void)=sizeof(char)=1</code> but this is gnu extension.</p>

<pre><code>vsize = sizeof(*vptr);
</code></pre>

<p>is not correct as <code>*vptr</code> has the type <code>void</code> as described above.</p>

<pre><code>s = vptr - 1;
</code></pre>

<p>is also incorrect as the pointer arithmetic means to subtract the <code>sizeof (typeof(*vptr))</code>.</p>
",0
43957880,43858694,0,"<p>I think this code implements what is asked for ¡ª fill an array with the letters of the alphabet and then print it.</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{   
    char alphabet[27];
    int i;

    for (i = 'a'; i &lt;= 'z'; i++)
        alphabet[i - 'a'] = i;
    alphabet[i - 'a'] = '\0';
    printf(""alphabet: %s\n"", alphabet);

    return 0;
}
</code></pre>

<p><em>(Incidentally, I check these things before I post them, and in this case, I'm very glad I did.  I originally had <code>alphabet[i] = '\0';</code> after the loop, but this is reported as <code>error: array subscript is above array bounds [-Werror=array-bounds]</code> ¡ª and that's right!  Even simple code that ""can't go wrong"" can go wrong.  My GCC 7.1.0 command line ¡ª which works with many other versions of GCC, was: <code>gcc -O3 -g -std=c11 -Wall -Wextra -Werror -Wmissing-prototypes -Wstrict-prototypes -Wold-style-definition x3.c -o x3</code>.  I recommend using most of those options ¡ª at minimum, use <code>-Wall -Wextra -Werror</code>.)</em></p>

<p>This is similar to the code in the question, but probably isn't the way I'd actually write the code, in part because of the gotcha that nearly got me.</p>

<p>Another way of doing it would be:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{   
    char alphabet[26];
    int i;

    for (i = 0; i &lt; 26; i++)
        alphabet[i] = i + 'a';
    printf(""alphabet: %.*s\n"", 26, alphabet);

    return 0;
}
</code></pre>

<p>Note that <code>alphabet</code> is not a string; it is not null-terminated.  The <code>%.*s</code> conversion specification in conjunction with the <code>26</code> argument ensures that at most 26 characters are printed; it doesn't matter that <code>alphabet</code> is not a string.  Of course, using a slightly larger array and <code>alphabet[i] = '\0';</code> after the loop ¡ª analogous to the other code ¡ª would also work cleanly without the extra complexity in the <code>printf()</code> format string.</p>

<p>Left to my own devices, I'd probably use the null-terminating version of the second example program.</p>

<p>Read the POSIX specification of <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/printf.html"" rel=""nofollow noreferrer""><code>printf()</code></a> for the details.  It does have some (clearly marked) extensions over standard C <code>printf()</code>, but it serves for both POSIX and standard C.  Then re-read it.  And re-re-read it.  And do that daily for a week, and then weekly for a month, and then monthly for a year, and then yearly ever after.  It will repay the effort.  And similarly for <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/scanf.html"" rel=""nofollow noreferrer""><code>scanf()</code></a>, which is even harder to use right than <code>printf()</code>.</p>
",1
43959641,43959521,2,"<p>A proper way in C to do this is to use designated initializers.</p>

<pre><code>#include &lt;stdio.h&gt;

void read(void)
{
    puts(""read"");
}

void write(void)
{
    puts(""write"");
}

typedef void (*function_map_t)(void);

function_map_t function_map[] = {
    ['r'] = read,
    ['w'] = write,
};
</code></pre>

<p>Use function_map[255] if you want to fix the size of the array. All missing entries are initialized with zero, as required by the standard.</p>

<p><a href=""https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html"" rel=""nofollow noreferrer"">https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html</a></p>
",0
44359561,44358420,2,"<p>Instead of using the <code>time</code> shell command, you should use the <code>clock()</code> function defined in <code>&lt;time.h&gt;</code>. It is far more precise with much less overhead.</p>

<p>Here is the modified code:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

unsigned long int fibo(int n) {
    if (n &lt;= 1)
        return 1;
    else
        return fibo(n - 1) + fibo(n - 2);
}

int main(void) {
    unsigned long fn;
    unsigned int n;
    double time_in_secs;

    printf(""Enter an integer &lt;= 47:\n"");
    if (scanf(""%u"", &amp;n) == 1) {
        clock_t start = clock();

        fn = fibo(n); 

        time_in_secs = (double)(clock() - t) / CLOCKS_PER_SEC;

        printf(""Fibo(%u) = %lu\n"", n, fn);
        printf(""Computation took %f secs\n"", time_in_secs);
    }
    return 0;
}
</code></pre>

<p>If your are programming on an MS/DOS system, and <code>clock()</code> is not available there, you could try and define it this way:</p>

<pre><code>#define CLOCK_PER_SEC  18.2
#define clock() (*(unsigned long __far *)0x0040006C)
</code></pre>

<p>The tick interrupt (INT 8) updates a 32-bit tick counter 65536 times per hour. The 32-bit tick counter is accessible at absolute address <code>0040:006C</code>.  If you want more precise timings, you can try and reprogram the interrupt controller to make it fire interrupts faster. You then need to install your own handler to filter these interrupts to avoid messing the system's tick counter.</p>

<p>Here is a useful site for more info about the PC/DOS system and its BIOS data: <a href=""http://www.fysnet.net/rombios.htm"" rel=""nofollow noreferrer"">http://www.fysnet.net/rombios.htm</a></p>

<p>Also note that your Fibonacci sequence is not consistent with the classic definition <code>fib(0) = 0, fib(1) = 1</code>.  The <a href=""https://en.wikipedia.org/wiki/Fibonacci_number"" rel=""nofollow noreferrer"">Wikipedia article is here</a>.</p>

<p>Here is the corresponding code:</p>

<pre><code>unsigned long int fibo(int n) {
    if (n &lt;= 1)
        return n;
    else
        return fibo(n - 1) + fibo(n - 2);
}
</code></pre>
",0
44342913,44342739,0,"<p>According to <a href=""http://port70.net/~nsz/c/c11/n1570.html#6.2.5p13"" rel=""nofollow noreferrer"">6.2.5p13</a>, you can do (not tested!)</p>

<pre><code>double complex a[42];
double tmp[2];
tmp[0] = 3.14159;
tmp[1] = -2.71828;
memmove(a + 3, tmp, sizeof tmp); // a[3] = 3.14159 - 2.71828i
</code></pre>
",1
44342913,44342739,0,"<p>According to <a href=""http://port70.net/~nsz/c/c11/n1570.html#6.2.5p13"" rel=""nofollow noreferrer"">6.2.5p13</a>, you can do (not tested!)</p>

<pre><code>double complex a[42];
double tmp[2];
tmp[0] = 3.14159;
tmp[1] = -2.71828;
memmove(a + 3, tmp, sizeof tmp); // a[3] = 3.14159 - 2.71828i
</code></pre>
",1
44328086,44327724,2,"<p>It's an old and largely outdated claim about C.</p>

<p>C was originally designed as, roughly, a more readable and portable assembler.   For this reason, most of the core language features tended - on most target machines - to be easily translated.     Generally more complicated functionality was provided by library functions, including the standard library.</p>

<p>Over time, C (both the language and the standard library) have evolved, and become more complicated.   Computing hardware has also become more complicated - for example, supporting a set of more advanced instructions - and C constructs which can be implemented in terms of advanced instructions will translate to more complicated assembler on machines that support older and simpler instruction sets.</p>

<p>The distinction between a ""small"" language and a ""large"" one is completely subjective - so some people still continue to describe C as small and simple, both others describe is as large and complex.   While simpler than some other languages (like C++), C is now also significantly more complex - by various measures - than quite a few other programming languages.</p>
",0
44328130,44327724,1,"<p>C provides low-level control of memory and resources at the byte and bit level.  For example C and assembly language are very common in the programming of microcontrollers (my area of expertise), which have very little memory and most often require bit-level control of input and output ports.  </p>

<p>If you write a C program and build it, then look at your listing file, you'll typically see the very close correspondence between your C statements and the few assembly instructions into which the C is assembled.  </p>

<p>Another clue to its simplicity is to look at its grammar definition as compared to that for C# or Java or Python, for example.  The C grammar is small, terse, compact compared to the ""fuller"" languages, and it's true, there isn't even input or output defined in C.  That typically comes from including <code>stdio.h</code> or similar.  In this way, you only get what you need in your executable.  That is in start contrast to the ""big"" languages.</p>

<p>While many in the embedded (microcontroller) programming space still prefer assembly, C is a great way to abstract <strong>a little bit</strong> things like flow of control and pointers, while still retaining the power to employ practically every instruction the microprocessor or microcontroller is capable of.</p>
",0
44328203,44327724,3,"<p>It makes no sense to say <code>compiled language</code> and <code>interpreted language</code>.</p>

<p>This kind of statement are made by persons without education and could not understand the foundations of programming.</p>

<p>A language is defined mathematically via a way to define languages -- operational, denotational, axiomatic, etc and the programmers implement the language as they wish.</p>

<p>There are machines that  run C via interpretation, they dispatch the code at the moment of execution and execute it instead of accumulating some  object code that would be executed later by some machine, etc.</p>

<p>It is correct to say <code>compiled implementation</code>, <code>interpreted implementation for the language</code>, but even so it is relative to a given machine.  Because when you <code>compile</code> it for x86 processors, the compiled code is interpreted by the datapath and controller of a stack machine for the X86 language, etc.</p>

<p>Basically the statement <code>what you see is all you get</code> means that is almost 1 to 1 correspondence between the operators of the CAM defined in the abstract semantics of ISO 9899 and the current stack-machines on the market, like x86, mips, etc.</p>
",17
44327991,44327724,2,"<p>C is nothing more than a platform-independent Assembly translator, what you write in C is efficiently ""translated"" into machine code as it would if you write it directly in Assembly. Thats the point of:</p>

<blockquote>
  <p>""what you see is all you get"" language: a C statement corresponds to at most a handful of assembly statements</p>
</blockquote>

<p>Any C sentence you write is directly transformed to ASM by the compiler without abstraction layers, interpreters, etc, unlike other languages.</p>

<p>By definition, C is tinny, it has nothing but the esentials to be considered a <a href=""https://en.wikipedia.org/wiki/Turing_completeness"" rel=""nofollow noreferrer"">turing complete</a> language and nothing more. Any additional feature is achieved via libraries, C ships the std lib (diferent implementations tho) that packs things like RNG, memory management, etc.</p>

<p>That's what this means:</p>

<blockquote>
  <p>everything else is provided by library functions</p>
</blockquote>
",2
44327998,44327724,7,"<p>The assembly is the language for a single processor family, it is directly compiled to the machine code that the processor runs. If one programs in assembly, one needs to rewrite the entire code for the different processor family. Phones usually use ARM processors whereas the desktop computers have 32-bit or 64-bit x86-compatible processors. Each 3 of these potentially need a completely separately written program, and perhaps not even limited to that.</p>

<p>In contrast standard C is a portable language - if you write so-called strictly conforming programs. <a href=""http://port70.net/~nsz/c/c11/n1570.html#4p5"" rel=""nofollow noreferrer"">C11 4p5</a>:</p>

<blockquote>
  <p>A strictly conforming program shall use only those features of the language and library specified in this International Standard. (3) It shall not produce output dependent on any unspecified, undefined, or implementation-defined behavior, and shall not exceed any minimum implementation limit.</p>
</blockquote>

<p>With <a href=""http://port70.net/~nsz/c/c11/n1570.html#note5"" rel=""nofollow noreferrer"">footnote 5</a> noting that:</p>

<blockquote>
  <p>Strictly conforming programs are intended to be maximally portable among conforming implementations. Conforming programs may depend upon nonportable features of a conforming implementation</p>
</blockquote>

<p>Unlike the assembler whose specifics vary from processor to another, it is possible to write programs in C and then <em>port</em> them to various platforms without any changes into the source code, yet these programs will still be compiled into the assembly language, and performance could - and often will - surpass hand-written assembly when using a modern high-quality optimizing compiler.</p>

<p>Additionally the <em>C standard library</em>, which any conforming hosted implementation needs to provide, provides for a portable way to manage files, dynamic memory, input and output, all of which are not only processor but also operating-system specific when using assembler.</p>

<p>However, C is still quite close to the assembly, to the extent that it has been called a ""high-level assembly language"" by some.</p>
",5
44329171,44327724,2,"<p>This quote is absolutely true for the good old K&amp;R C implementation of the 70'. In this old days, C was indeed a thin wrapper around machine instructions, and the programmer could easily guess how the compiler would translate the source:</p>

<ul>
<li>for loop: a counter in appropriate register, a test at end of loop a goto</li>
<li>function call: push arguments to the stack (with no conversion!), call the sub-routine address. On return put the return value (required to be scalar or pointer) to the appropriate register and use machine return. On return, the caller cleans up the stack</li>
</ul>

<p>On a symetric point of view, anything that could be executed by the processor could be expressed in C. If you have an array of two integers and know that the internal representation is a valid double, just cast a pointer and use it.</p>

<p>That's all wrong with recent version of the C language and with optimizing compilers. The <em>as if</em> rule allows the optimizer to do anything, <strong>provided the observable results are what a natural implementation should have given</strong>. Many operations can invoke Undefined Behaviour. For example writing a float at a memory location and using it as an integer is explicitely UB. The optimizer can assume that no UB exists in the program, so it can just optimize out any block containing UB (recent versions of gcc are great at that).</p>

<p>Look for example at this function:</p>

<pre><code>void stopit() {
   int i = 0;
   while(1) {
      i+=1;
   }
   printf(""done"");
}
</code></pre>

<p>It contains an infinite loop, so the printf should never be reached. But the loop has no observable result, so the compiler is free to optimize it out and translate it the same as:</p>

<pre><code>void stopit() {
   printf(""done"");
}
</code></pre>

<p>Another example</p>

<pre><code>int i = 12;
float *f = &amp;i;
*f = 12.5;              // UB use an float variable to access an int
printf(""0x%04x\n"", i);  // try to dump the representation of 12.5
</code></pre>

<p>This code can legally display <code>0x000c</code>, because the compiler is free to assume that the <code>*f=0.</code> has not modified <code>i</code>, so it can directly use a cached value and translate the last line directly as <code>printf(""0x%04x\n"", 12);</code></p>

<p>So not, recent versions of the C language are no longer <em>a small ""what you see is all you get"" language</em></p>

<hr>

<p>What is true is that C is a low level language. The programmer has full control on allocation/deallocation of dynamic storage. You have a natural access at the byte level for any type, you have the notion of pointer and explicit pointer/integer conversion to allow direct access to well known memory addresses. That indeed allows to program embedded systems or micro-controller in C. The standard even defines two environment levels: a hosted environment where you have full access to the standard library and a freestanding environment where the standard library is not present. This can be specifically interesting for systems with very little memory.</p>
",0
44332175,44327724,0,"<p>Regarding the ""what you see is all you get"" statement...</p>

<p>C is a ""small"" language in that provides only a handful of <em>abstractions</em> - that is, high-level language constructs that either hide implementation-specific details (such as I/O, type representations, address representations, etc.) or simplify complex operations (memory management, event processing, etc.).  C doesn't provide any support at the language level (either in the grammar or standard library) for things like networking, graphics, sound, etc.; you must use separate, third-party libraries for those tasks, which will vary based on platform (Windows, MacOS, iOS, Linux).  Compare that to a language like Java, which provides a class library for just about <em>everything</em> you could ever want to do.  </p>

<p>Compared to languages like C++ and Java, not a whole lot of things happen ""under the hood"" in C.  There's no overloading of functions or operators, there are no constructors or destructors that are automatically called when objects are created or destroyed, there's no real support for ""generic"" programming (writing a function template that can be automatically instantiated for arguments of different types), etc.  Because of this, it's often easier to predict how a particular piece of code will perform.  </p>

<p>There's no automatic resource management in C - arrays don't grow or shrink as you add or remove elements, there's no automatic garbage collection that reclaims dynamic memory that you aren't using anymore, etc.  </p>

<p>The only container provided by the C language is the array - for anything more complex (lists, trees, queues, stacks, etc.) you have to write your own implementation, or use somebody else's library.  </p>

<p>C is ""close to the machine"" in that the types and abstractions it provides are based on what real-world hardware provides.  For example, integer and floating-point representations and operations are based on what the native hardware supports.  The size of an <code>int</code> is (usually) based on the native CPU's word size, meaning it can only represent a certain range of values (the minimum range required by the language standard is <code>[-32767..32767]</code> for signed integers and <code>[0..65535]</code> for unsigned integers).  Operations on <code>int</code> objects are mapped to native <code>ADD/DIV/MUL/SUB</code> opcodes. Languages like Python provide ""arbitrary precision"" types, which are not limited by what the hardware can natively support - the tradeoff is that operations using these types are often slower, since you're not using native opcodes.  </p>
",0
44713531,44713491,1,"<p><code>time</code> is declared as <code>double</code> (argument of <code>displayresults</code>), so result of expression <code>time/3600</code> is also of type <code>double</code>, but you are trying to store this result in <code>hr</code> (as well as in <code>t</code>) of <code>int</code> type.
Moreover taking remainder of the division (<code>%</code>) has no sense with arguments of <code>double</code> type - this is actually the error found by the compiler.</p>

<p>First of all check if you really get time as <code>double</code>, and in no, just change other part of program and signature of your function... perhaps it should be </p>

<pre><code>  void displayresults(int time, double range, double maxheight, int rovertime)
</code></pre>

<p>If time is really comes as <code>double</code> you should make integer before use integer division (<code>/</code>) and remaining (<code>%</code>), e.g.:</p>

<pre><code>  hr = int(time) / 3600;
  t = int(time) % 3600;
</code></pre>

<p>or better use the following operations with <code>double</code> type for all variables:</p>

<pre><code>  double hr, t, min, sec;
  hr = trunc(time / 3600);
  t = fmod(time, 3600);
  min = trunc(t / 60);
  sec = fmod(t, 60);
  printf(""%.0lf (hrs) %.0lf (mins) %lf (seconds)\n"", hr, min, sec);
</code></pre>

<p>Specifier <code>%.0lf</code> in <code>printf</code> allows printing <code>double</code> as <code>int</code> (without fraction)</p>
",6
45049298,45049135,5,"<p>The C Preprocessor is not a part of the compiler, but is a separate step in the compilation process. </p>

<p>Now, because it's a separate step in the compilation process, it's not the same as assigning <code>i</code> with different values. When your code runs, it treats <code>i</code> as <code>20</code> because that was defined before <code>main</code>. But, as I said,it's a separate step, <strong>and</strong> it does not care about functions scope, so, there is <em>before main</em> (<code>i=20</code>) and <em>after main</em> (<code>i=30</code>). When the Preprocessor  runs it treats the whole scope as global.</p>

<p>Try using the <code>#define</code> inside the main, not in a function, and check what happens... </p>

<p>Example: </p>

<pre><code>void f(){
    #define a 5
    printf(""%d\n"", a);
    #undef a
    #define a 10
    printf(""%d\n"", a);
}

int main()
{
    printf(""%d\n"", a); // a can be printed even though f() was never called!!
    #define i 20
    printf(""%d\n"", i); // 20
    #undef i
    #define i 30
    printf(""%d\n"", i); // 30! :)
    return 0;
}
</code></pre>

<p>You can find more info in this <a href=""https://stackoverflow.com/questions/36968567/is-it-possible-to-use-define-inside-a-function"">Q&amp;A</a></p>
",0
45052206,45049135,0,"<p>defines are preprocessed before the compilation and they are global. If you want to assign a value in the function just use normal C assign operator &amp; the a global variable,.</p>
",0
44691086,44690922,6,"<p>If you're using ISO 8859-15 or 8859-1 code set, the ? (LATIN SMALL LETTER Y WITH DIAERESIS, U+00FF in Unicode) has code 255<sub>10</sub> or 0xFF.  When you store EOF in the array, it gets converted to ?.</p>

<p>Don't store EOF in a <code>char</code>.  And remember that <code>getchar()</code> returns an <code>int</code>, not a <code>char</code>.  It has to be able to return every value that can be stored in an <code>unsigned char</code>, plus EOF which is negative (usually but not necessarily <code>-1</code>).</p>

<p>And, as noted in the comments, <a href=""http://stackoverflow.com/questions/5431941/while-feof-file-is-always-wrong""><code>while (!feof(file))</code> is always wrong</a>.  This is just another reason why.</p>

<p>This code is fixed, more or less.  It really should report an error if it fails to open the file.  Note that it also ensures you don't overflow the buffer.</p>

<pre><code>FILE *fp = fopen(""/file.txt"", ""r"");
if (fp != 0)
{
    char text[1000];
    int i=0;
    int c;
    while ((c = getc(fp)) != EOF &amp;&amp; i &lt; sizeof(text)-1)
        text[i++] = c;

    text[i]='\0';

    printf(""%s\n"", text);
    fclose(fp);
}
</code></pre>

<p>See also <a href=""https://stackoverflow.com/questions/13694394/while-c-getcfile-eof-loop-wont-stop-executing/""><code>while ((c = getc(file)) != EOF)</code> loop won't stop executing</a>.</p>
",9
44691093,44690922,5,"<p>The <code>?</code> is the byte 255 in your codepage, which is the constant <code>EOF</code> coerced into a <code>char</code>. Instead of using <code>feof</code>, you <em>must</em> store the return value of <code>getc</code> into an <code>int</code>, then compare it against <code>EOF</code>, here's an easy-to-read example (notice that you'd have to have bounds-checking too):</p>

<pre><code>while (1) {
    int c = getc(fp);
    if (c == EOF) {
        break;
    }
    text[i++] = c;
}
</code></pre>
",1
44697433,44697351,1,"<p><code>char * strncpy ( char * destination, const char * source, size_t num );</code></p>

<p>No null-character is implicitly appended at the end of destination if source is longer than num. Thus, in this case, destination shall not be considered a null terminated C string (reading it as such would overflow).</p>

<p>Therefore, it should be:</p>

<pre><code>char line_one_NEW[100] = {0};
strncpy(line_one_NEW, line_one, strlen(line_one)-1);
</code></pre>
",0
44697490,44697351,4,"<p>Use <code>strrchr</code> for a reverse search.</p>

<pre><code>char* pos = strrchr(line_one, '\n');
if (pos) *pos = 0;
</code></pre>

<p>Your method that copies the string over is incorrect, because you miss to add a null character to terminate the string.</p>
",12
44697531,44697351,2,"<p>For starters to remove the new line character from a string you can use the following trick</p>

<pre><code>line_one[ strcspn( line_one, ""\n"" ) ] = '\0';
</code></pre>

<p>As for this code snippet</p>

<pre><code>strncpy(line_one_NEW, line_one, strlen(line_one)-1);
printf(""%s"", line_one_NEW);
</code></pre>

<p>then at first it is logically wrong because in general the new line character can be absent in the string <code>line_one</code>. In this case the expression for the number of copied characters</p>

<pre><code>strlen(line_one)-1
</code></pre>

<p>will be wrong.</p>

<p>But in any case if you use the standard function <code>strncpy</code> you should explicitly to append a terminating zero. For example</p>

<pre><code>strncpy(line_one_NEW, line_one, strlen(line_one)-1);
line_one_NEW[strlen(line_one)-1] = '\0';
</code></pre>

<p>Or if you want to copy the first line into the second line without the new line character but keeping the new line character in the first line then you can write</p>

<pre><code>size_t n = strcspn( line_one, ""\n"" );
strncpy( line_one_NEW, line_one, n );
line_one_NEW[n] = '\0'; 
</code></pre>
",0
44697391,44697351,3,"<p>the easiest solution i think is strcspn() to remove \n:</p>

<pre><code>buffer[strcspn(buffer, ""\n"")] = 0;
</code></pre>
",4
44697997,44697351,-5,"<pre><code>strncpy(arg1 , arg2 ,  integer);
</code></pre>

<p>a function in the <code>string.h</code> library means Copy first n chars of <code>arg2</code>  into <code>arg1</code> </p>

<pre><code>strlen(str) :
</code></pre>

<p>a function in the <code>string.h</code> library  , is used to count the number of the characters in the string str and return integer int , Because we don't want to write '/n' , so it avoids last character which is '/n'by writing </p>

<pre><code>strlen(line_one)-1
</code></pre>
",1
44699867,44697351,0,"<p>In order to remove  the ""\n"" from the line you need to write this code line after the fgets(I will write the line of the fgets too):</p>

<pre><code>fgets(str,MAX_CHARACTERS,fp); 
//MAX_CHARACTERS is the maximum of characters that you want to get from the fgets
str[strcspn(str,""\n"")]=0;
</code></pre>

<p>Hope that my comment was helpful for you ;)</p>
",0
44705305,44704267,0,"<p><code>long long</code> (which is signed, by default) is supposed to be (at least) 64 bits in length, meaning that the maximum representable number is (at least) +9,223,372,036,854,775,807 (i.e. 2^63-1). The number you've specified, 1,111,111,111,111,111,111 is less than 9,223,372,036,854,775,807, and thus fits in a signed <code>long long</code>. However, your number multiplied by 10 exceeds the max value for a 64-bit signed <code>long long</code>. If you declare x to be of type <code>unsigned long long</code> then the multiplication you specified should work.</p>

<p>Best of luck.</p>
",2
44739666,44739074,1,"<p>The behavior you observe has nothing to do with capital letter, but rather with answers with multiple words. You cannot read multiple words with <code>scanf("" %s"", dealer);</code>.  The initial space is redundant as <code>%s</code> skips any leading white space and reads a single word into the destination array. The following words will be read by subsequent calls to <code>scanf()</code> as answers for other questions.</p>

<p>You can either use <code>fgets(dealer, sizeof dealer, stdin)</code> and remove the trailing newline or use <code>scanf("" %39[^\n]"", dealer);</code> to read multiple words on the same line upto 39 bytes.  The same holds for the other input lines, adjusting for the different array sizes.</p>
",3
44742357,44742209,3,"<p>First, and most important, <strong><em>turn on warnings</em></strong>. You have several elementary mistakes in your code that would be caught with compiler warnings. They're unfortunately off by default. <code>-Wall</code> turns on the basic warnings. It's not ""all"" warnings, because this is C! <code>-fsanitize=address -Wall -Wshadow -Wwrite-strings -Wextra -Wconversion -std=c99 -pedantic</code> is a good set of warnings to work with.</p>

<hr>

<p>You could put a loop around the loop, but that rapidly gets hard to maintain. Instead, put the game into a function and loop around that.</p>

<pre><code>void do_game(int tries) {
    int number = rand() % 200 + 1;

    for (int i=0; i &lt; tries; i++) {
        int guess;
        printf(""\n\nYour guess? "");
        scanf(""%i"",&amp;guess);

        if (guess == number) {
            printf(""**** CORRECT  ****\n\n"");
            return;
        }
        else if (guess &gt; number) {
            printf(""Too high!"");
        }
        else if (guess &lt; number) {
            printf(""Too low!"");
        }
        else if (guess &gt; 200) {
            printf(""Illegal guess. Your guess must be between 1 and 200.\nTry again. Your guess?"");
        }
    }

    puts(""\n\nSorry, you ran out of tries.\n\n"");
    return;
}
</code></pre>

<p>Note how the game only has to concern itself with the game. No other logic or questions about playing another game. And it can immediately return when the game is over.</p>

<p>Then the rest of the program is pretty simple. Run the game in an infinite loop, break out of it when you're done.</p>

<pre><code>int main() {
    printf(""Welcome to the game of Guess It!\nI will choose a number between 1 and 200."");
    printf(""\nYou will try to guess that number.If you guess wrong, I will tell you if you guessed too high or too low."");
    printf(""\nYou have 5 tries to get the number.\n\nOK, I am thinking of a number. Try to guess it."");

    srand(time(NULL));

    while(1) {
        do_game(5);

        char answer;        
        printf(""Want to play again?(y/n) "");
        scanf(""%c"",&amp;answer);

        if (answer == 'n') {
            printf(""Goodbye, It was fun. Play again soon."");
            break;
        }
    }

    return 0;
}
</code></pre>

<hr>

<p>There's a problem, and it's <code>scanf</code>. It's always <code>scanf</code>. <code>scanf</code> is such a problem, <a href=""http://c-faq.com/stdio/scanfprobs.html"" rel=""nofollow noreferrer"">there's a whole FAQ for it</a>.</p>

<p><code>scanf(""%i"")</code> reads a single integer <em>but not the following newline</em>. That newline, and any other extra input, hangs around on stdin. A later <code>scanf(""%c"", &amp;answer);</code> might then read that newline instead of their answer.</p>

<p><code>scanf(""%i\n"")</code> does not solve the problem. That tells <code>scanf</code> to read an integer, then a newline, then look for another non-whitespace character. <code>scanf</code> is weird.</p>

<p>You're much better off reading the whole line with <code>fgets</code> and parsing it with <code>sscanf</code>. You can write a little utility function for that which gets into <a href=""http://www.tutorialspoint.com/c_standard_library/c_macro_va_start.htm"" rel=""nofollow noreferrer"">variadic arguments</a>.</p>

<pre><code>void line_scanf( const char *fmt, ... ) {
    // Get the list of arguments.
    va_list args;
    va_start(args, fmt);

    // Read a line.
    char line[256];
    fgets(line, sizeof(line), stdin);

    // Scan the line like sscanf() but with a va_list.
    vsscanf( line, fmt, args );

    // Close the list of arguments.
    va_end(args);
}
</code></pre>

<p>Then use it just like <code>scanf</code>. It guarantees to read the whole line and not leave newlines or partial input on the buffer.</p>

<pre><code>    int guess;
    printf(""\n\nYour guess? "");
    line_scanf(""%i"",&amp;guess);
</code></pre>
",1
44742396,44742209,0,"<p>scanf(""%i"", ...) reads integers in base 10, not characters or strings.</p>

<p>You need to organize your loops.  You have 2 main loops, one that runs while the user wants to keep playing, and another that runs while the a game is on.</p>

<p>You program in a nutshell:</p>

<pre><code>int main()
{
  // loop until player has had enough
    // pick a number
    // game loop :
      // get a number from user:
        // user entry loop:
          // print prompt
          // get user entry
          // validate
       // loop number from user: until 0 &lt;= entry &lt;= 200

     // if number is ok
       // user has won, exit game loop
     // if too low
       // say 'low'
     // if too high
       // say high
     // if # of attempts &gt; MAX
       // say 'lost' exit game loop 
   // end game loop

   // want to contine?
     // user entry loop:
       // print prompt
       // get user entry
       // validate
     // loop user entry loop until 0 &lt;= entry &lt;= 200
  // end loop
}
</code></pre>

<p>You could start your loops within main a bit like this:</p>

<pre><code>int attempts;
char yesno = 0;
int guess;

do                    // loop until player has had enough
{
   // generate a number here

   attempts = 0;
   while(1)           // loop while game is on
   {
     while (1)        // loop until user entered a valid entry
     {
        // prompt
        // get user guess
        if (0 &lt;= guess &amp;&amp; guess &lt;= 200)
          break;
     }

    if (guessed right)
     {
        // game over!
        break;
     }

     // tell if high or low.

     if (++attempts &lt;= MAX)
     {
        // game over!
        break;
     }    
   }

   do                  // loop until user entered a valid entry.
   {
     printf(""Another game (y/n)?"");
     yesno = fgetc();
   } while(yesno != 'y' &amp;&amp; yesno != 'n');  // could make case-insensitive ?

} while (yesno != 'n');
</code></pre>

<p>There are probably as many ways to do this as there are numbers between 0 and 200.  A good strategy is to start by writing comments in your C file that describe step by step what the program needs to do.  Going through them one by one is much easier than having the program only in your head, especially when you are starting to code.  It will get easier with time as you get used to juggle the concepts and basic blocks your mind.</p>
",1
44742409,44742209,1,"<p>This is only a partial answer, but it can be a starting point. You really should have a <em>reliable</em> input function. Your <code>scanf()</code> won't do, even if you fix the obvious errors trying to get a character using <code>%i</code>, which is for integers. I won't go into details here, I <a href=""http://sekrit.de/webdocs/c/beginners-guide-away-from-scanf.html"" rel=""nofollow noreferrer"">wrote a document on this</a>. (Basically, you will at least run into problems with unparsable input that <code>scanf()</code> will just leave unread.)</p>

<p>Here's an example how you <em>could</em> do reliable input for your usecase with comments along the way:</p>

<pre><code>#include &lt;limits.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define INVALIDNUMBER -1
#define READERROR -2

int readPositiveNumber(void)
{
    char buf[64];

    // read a line:
    if (!fgets(buf, 64, stdin)) return READERROR;
    size_t len = strlen(buf);

    // line was empty -&gt; invalid:
    if (!len) return INVALIDNUMBER;

    // line was not complete (last character isn't newline):
    if (buf[len-1] != '\n')
    {
        // read the rest of the line
        do
        {
            if (!fgets(buf, 64, stdin)) return READERROR;
        } while (!buf[strcspn(buf, ""\n"")]);

        // input was invalid
        return INVALIDNUMBER;
    }

    // convert to number:
    char *endptr;
    long num = strtol(buf, &amp;endptr, 10);

    // endptr == buf means no characters could be parsed as a number,
    // endptr doesn't point to newline means there were non-numeric characters later:
    if (endptr == buf || *endptr != '\n') return INVALIDNUMBER;

    // if result is out of range of int or is negative -&gt; invalid:
    if (num &gt; INT_MAX || num &lt; 0) return INVALIDNUMBER;

    return (int)num;
}

int main(void)
{
    fputs(""Enter a number between 1 and 200: "", stdout);
    int number = readPositiveNumber();
    if (number == READERROR) return EXIT_FAILURE;

    while (number &lt; 1 || number &gt; 200)
    {
        fputs(""Enter a valid number between 1 and 200: "", stdout);
        number = readPositiveNumber();
        if (number == READERROR) return EXIT_FAILURE;
    }

    printf(""You entered %d.\n"", number);
    return EXIT_SUCCESS;
}
</code></pre>

<p>Try to understand this function, read the manuals for functions you don't know or understand (google ""<em>man strtol</em>"" for example will find you a manual page for <code>strtol()</code>).</p>

<p>For reading your yes/no response, use <code>fgets()</code> as well, but of course this function will look different, like check if the input is only 1 character (the second one has to be <code>'\n'</code>) and return this one character.</p>

<hr>

<p>just because it's a bit of fun, here's a possible whole game working robustly:</p>

<pre><code>#include &lt;limits.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;

#define INVALIDINPUT -1
#define READERROR -2

static int readLine(char *buf, size_t bufsize)
{
    if (!fgets(buf, bufsize, stdin)) return READERROR;
    size_t len = strlen(buf);
    if (!len) return INVALIDINPUT;
    if (buf[len-1] != '\n')
    {
        do
        {
            if (!fgets(buf, bufsize, stdin)) return READERROR;
        } while (!buf[strcspn(buf, ""\n"")]);
        return INVALIDINPUT;
    }
    return 0;
}

static int readPositiveNumber(void)
{
    char buf[64];
    int rc = readLine(buf, 64);
    if (rc &lt; 0) return rc;
    char *endptr;
    long num = strtol(buf, &amp;endptr, 10);
    if (endptr == buf || *endptr != '\n') return INVALIDINPUT;
    if (num &gt; INT_MAX || num &lt; 0) return INVALIDINPUT;
    return (int)num;
}

static int readYesNo(void)
{
    char buf[64];
    int rc = readLine(buf, 64);
    if (rc &lt; 0) return rc;
    if (buf[0] == 'y' || buf[0] == 'Y')
    {
        if (buf[1] == '\n') return 1;
        if ((buf[1] == 'e' || buf[1] == 'E')
                &amp;&amp; (buf[2] == 's' || buf[2] == 'S')
                &amp;&amp; buf[3] == '\n') return 1;
        return INVALIDINPUT;
    }
    if (buf[0] == 'n' || buf[0] == 'N')
    {
        if (buf[1] == '\n') return 0;
        if ((buf[1] == 'o' || buf[1] == 'O')
                &amp;&amp; buf[2] == '\n') return 0;
        return INVALIDINPUT;
    }
    return INVALIDINPUT;
}

int main(void)
{
    srand(time(0));

    for (;;)
    {
        int number = rand() % 200 + 1;
        int tries = 5;
        int found = 0;
        while (tries--)
        {
            int guess = INVALIDINPUT;
            while (guess &lt; 1 || guess &gt; 200)
            {
                fputs(""guess [1..200]: "", stdout);
                guess = readPositiveNumber();
                if (guess == READERROR) return EXIT_FAILURE;
            }
            if (guess == number)
            {
                puts(""Correct!"");
                found = 1;
                break;
            }
            else if (guess &lt; number) puts (""Too low!"");
            else puts(""Too high!"");
        }
        if (!found)
        {
            puts(""No luck!"");
        }
        int yn = INVALIDINPUT;
        while (yn &lt; 0)
        {
            fputs(""play again (y/n)? "", stdout);
            yn = readYesNo();
            if (yn == READERROR) return EXIT_FAILURE;
        }
        if (!yn)
        {
            puts(""Bye!"");
            return EXIT_SUCCESS;
        }
    }
}
</code></pre>
",0
44742846,44742209,1,"<p>This exercise is an exercise to ingrain in your mind why <code>scanf</code> <em>is generally a bad choice for taking mixed user input!</em> You can do it, but you must be very careful to account for any characters that remain in the input buffer (i.e. <code>stdin</code>) -- <strong>especially when taking character input...</strong> Why?</p>

<p>When you enter a value that is read by <code>scanf</code>, the <code>'\n'</code> will always remain in the input buffer (unless accounted for in your <em>format string</em>). Further, on a <em>failed conversion</em> -- <strong>all</strong> characters will remain in the input buffer. Further, the user can do something stupid like entering <code>""4 is my guess""</code> when prompted leaving <code>is my guess\n</code> for you to deal with.</p>

<p>Further, what if the user cancels input by pressing <code>ctrl + d</code> (or <code>ctrl + z</code> on windoze) generating a manual <code>EOF</code>? You must account for all possibilities for <strong>each and every input</strong>.</p>

<p>You must also use the correct <em>format specifier</em> to read input. You are not going to read <code>'y'</code> or <code>'n'</code> with <code>%d</code> or <code>%i</code>. When you want to read an <code>int</code> use <code>%d</code> when you want to read a <code>char</code>, use <code>%c</code>. You must also take into account that <code>%c</code> <strong>never</strong> skips leading <em>whitespace</em>. </p>

<p>(you beginning to understand why it's better to use <code>fgets</code> and then call <code>sscanf</code> for user input??)</p>

<p>How do you handle the characters that remain in the input buffer? Well generally you will use <code>getchar()</code> to read until you have read <code>'\n'</code> (generated by pressing <kbd>Enter</kbd>) or until <code>EOF</code> is encountered. You can make it easy on yourself by writing a short function like the following:</p>

<pre><code>/* empty characters that remain in stdin */
void fflushstdin ()
{
    for (int c = getchar(); c != '\n' &amp;&amp; c != EOF; c = getchar()) {}
}
</code></pre>

<p>If you call <code>fflushstdin</code> after each input, you will always take care of any characters that remain. If you know chars remain from a prior input that have not been removed, then call it before taking input.</p>

<p>Don't use <strong><em>magic numbers</em></strong> in your code (e.g. <code>1, 5, 200</code>), instead define any needed constants at the beginning of your code and use the constants in your code. Why? If they change, then you have a single readily accessible place to change them and you don't have to go picking though your code to find them. You can use a <code>#define</code> or an <code>enum</code> like the following:</p>

<pre><code>enum {LOW = 1, TRIES = 5, HIGH = 200 }; 
</code></pre>

<p>The remainder of your problems are simply logic problems that you can work out. Incorporating the above, you can handle (what I think you are attempting to do) as follows:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

enum {LOW = 1, TRIES = 5, HIGH = 200 }; 

/* empty characters that remain in stdin */
void fflushstdin ()
{
    for (int c = getchar(); c != '\n' &amp;&amp; c != EOF; c = getchar()) {}
}

int main (void) {

    int i, number, guess, ret;
    char answer;

    printf (""Welcome to the game of Guess It!\n""
            ""I will choose a number between %d and %d.\n""
            ""You will try to guess that number.\n""
            ""I will tell you if you guessed too high or too low.\n""
            ""You have %d tries to get the number.\n\n""
            ""OK, I am thinking of a number. Try to guess it.\n\n"", 
            LOW, HIGH, TRIES);

    srand(time(NULL));

    while (1) {                         /* outer loop until user quits  */
        number = rand() % HIGH + 1;     /* set number INSIDE loop       */
        for (i = 0; i&lt; TRIES; i++) {    /* loop for set number of TRIES */

            while (1) {      /* validate user guess, handle cancelation */
                printf (""Your guess no. %d? "", i + 1);      /* prompt   */
                if ((ret = scanf ("" %d"", &amp;guess)) != 1) { /* chk return */
                    if (ret == EOF) {          /* check for cancelation */
                        printf (""input canceled, exiting.\n"");
                        return 0;
                    }
                    fprintf (stderr, ""  error: invalid input.\n"");
                    fflushstdin();    /* empty chars remaining in stdin */
                    continue;
                }
                if (guess &lt; LOW || guess &gt; HIGH)        /* check limits */
                    printf(""Illegal guess. Your guess must be between ""
                           ""%d and %d.\nTry again. Your guess?"", LOW, HIGH);
                break;
            }

            if (guess == number) {  /* correct answer */
                printf (""\n**** CORRECT  ****\n\nWant to play again(y/n) "");
                fflushstdin();
                /* validate answer, you are reading a `char` NOT `int` */
                while ((ret = scanf ("" %c"", &amp;answer)) != 1 || 
                        (answer != 'y' &amp;&amp; answer != 'n')) {
                    fprintf (stderr, ""error: invalid answer, play again (y/n) "");
                    if (ret == EOF) {          /* check for cancelation */
                        printf (""input canceled, exiting.\n"");
                        return 0;
                    }
                    fflushstdin();    /* empty chars remaining in stdin */
                }
                if (answer == 'y')  /* use goto for breaking nested loops */
                    goto done;

                printf (""Goodbye, It was fun. Play again soon.\n""); /* no */
                return 0;
            }

            if (guess &gt; number)         /* provide &gt; and &lt; feedback */
                printf (""Too high!\n"");

            if (guess &lt; number)
                printf(""Too low!\n"");
        }
        printf (""Sorry, you exhausted all your tries, number was: %d\n""
                ""play again (y/n) "", number);

        fflushstdin();
        /* validate answer, you are reading a `char` NOT `int` */
        while ((ret = scanf ("" %c"", &amp;answer)) != 1 || 
                (answer != 'y' &amp;&amp; answer != 'n')) {
            fprintf (stderr, ""error: invalid answer, play again (y/n) "");
            if (ret == EOF) {
                printf (""input canceled, exiting.\n"");
                return 0;
            }
            fflushstdin();
        }
        if (answer != 'y')
            break;

        done:;  /* goto lable to play again after correct asnwer */
    }

    return 0;
}
</code></pre>

<p><strong>Example Use/Output</strong></p>

<pre><code>$ ./bin/guess
Welcome to the game of Guess It!
I will choose a number between 1 and 200.
You will try to guess that number.
I will tell you if you guessed too high or too low.
You have 5 tries to get the number.

OK, I am thinking of a number. Try to guess it.

Your guess no. 1? onehundred
error: invalid input.
Your guess no. 1? 100
Too low!
Your guess no. 2? 150
Too high!
Your guess no. 3? 125
Too low!
Your guess no. 4? 137
Too high!
Your guess no. 5? 131
Too low!
Sorry, you exhausted all your tries, number was: 132
play again (y/n) y
Your guess no. 1? 100
Too low!
Your guess no. 2? 150
Too low!
Your guess no. 3? 175
Too low!
Your guess no. 4? 187
Too high!
Your guess no. 5? 181

**** CORRECT  ****

Want to play again(y/n) y
Your guess no. 1? 100
Too low!
Your guess no. 2? 150
Too high!
Your guess no. 3? 125
Too high!
Your guess no. 4? 112
Too high!
Your guess no. 5? 106
Too low!
Sorry, you exhausted all your tries, number was: 110
play again (y/n) n
</code></pre>

<p>Note, the above handles stupid user input (like <code>onehundred</code>) and adds <code>number</code> to the failure output to let the user know what he missed.</p>

<p>Look things over and let me know if you have further questions.</p>
",0
45280978,45280864,6,"<p>You can store any values in a char array. But if you want to store a value of 0x00, you cannot use the string functions on this array. So you have to use an integer variable to store the length of the data you want to store. You can then write functions that use this integer.</p>
",4
45287234,45287185,3,"<p><strong>You need to replace i++ with i--</strong></p>

<pre><code>#include&lt;stdio.h&gt;
void main()
{
    int a,b[100],i;
    printf(""Enter the total numbers:\n"");
    scanf(""%d"",&amp;a);
    printf(""Enter the numbers:\n"");
    for(i=0;i&lt;a;i++)
    {
        scanf(""%d"",&amp;b[i]);
    }
    for(i=a-1;i&gt;=0;i--)
    {
        printf(""%d\n"",b[i]);
    }
}
</code></pre>
",0
45287315,45287185,2,"<p>Segmentation fault occurs when you are trying to access un-referenced memory or going out of bounds. So as mentioned just change i++ to i-- in second loop. </p>
",1
47542987,47542882,0,"<p>for code 1 the looping count equals the number of times the check ""i&lt;=5"" passes. for code 2 the looping count equals the number of times the check ""i&lt;=5"" happens. for code 1 i is 1 when the first check passes, therefore it passes for 5 times. the loop runs 5 times. for code 2 i is 2 when the first check happens (and passes). therefore it passes for 4 times. note that the number of times the check happens is always 1 greater than the number of times it passes, (the last check always fails that's when the loop exits), therefore the check happens 5 times for code-2. the loop runs 5 times.</p>
",0
46019505,46013045,1,"<p>The assignment <code>char a = 01212;</code> on most of the systems is out of range and <strong>implementation dependent.</strong> A system with 8-bit <code>char</code> that implement 2's complement will print <code>-118</code>.  </p>

<p>For detail, please read below explanation. </p>

<p>Unlike <code>integer</code> a <code>char</code> is not signed by default; there are three different char types in C.</p>

<p><code>char</code>, </p>

<p><code>signed char</code></p>

<p>and </p>

<p><code>unsigned char</code></p>

<p>A <code>char</code> has a range from <code>CHAR_MIN</code> to <code>CHAR_MAX</code>. For a particular compiler, the <code>char</code> will use either an underlying signed or unsigned representation. You can check this value in <code>limits.h</code> of your system.
Here is the text from C99 standard point number <strong>15</strong></p>

<blockquote>
  <p>6.2.5 Types</p>
  
  <p>The three types char, signed char, and unsigned char are collectively called
  the character types. The implementation shall define char to have the same range,
  representation, and behavior as either signed char or unsigned char.35)</p>
</blockquote>

<p>And again note <strong>35</strong> says</p>

<blockquote>
  <p>35) CHAR_MIN, defined in , will have one of the values 0 or SCHAR_MIN, and this can be
  used to distinguish the two options. Irrespective of the choice made, char is a separate type from the
  other two and is not compatible with either.</p>
</blockquote>

<p>Having said this <code>char a = 01212;</code> is larger than 8 bit. The C standard allows char size more than 8 bit but I think almost all computers in today's world implement 8 Bit <code>char</code>.</p>

<p>So if <code>char</code> is implemented as unsigned char and the value is more than <code>CHAR_MAX</code> the value will be converted according to Modulo <code>CHAR_MAX+1</code>. </p>

<p>In 8 bit system, the converted value is 650 modulo 256 which is 650-512 = 138</p>

<p>If char is implemented as signed char the conversion is implementation dependent. If it's an 8-bit char system and it implements 2's complement the value will be <code>-118</code> as you have seen in your result. Note that in this system the Range for <code>char</code> will be from <code>-128</code> to <code>+127</code>. </p>
",2
46020178,46013045,1,"<p>The value of <code>650</code> is most likely out-of-range for your <code>char</code> type. In C the behavior is <em>implementation-defined</em> in such cases as out-of-range integer conversions. I.e. it is clear that you will not get <code>650</code> in your <code>char</code>, and what exactly you will get depends on your compiler. Consult your compiler documentation to figure out why you got <code>-118</code>.</p>
",1
46086818,46085393,1,"<p>No, there is no problem with sleeping for 25 minutes.<br>
In fact, using <code>sleep</code> is about the <em>most</em> efficient way to wait for 25 minutes.</p>
",0
45770760,45769855,0,"<p>The code in the original question is pretty close - you just needed one more loop inside to iterate and print the numbers X times.</p>

<p>If you want your output to look like</p>

<pre><code>1
22
22
333
333
333
</code></pre>

<p>then this will do it</p>

<pre><code>int main()
{
    int n,i,j,k;
    scanf(""%d"",&amp;n);

    for(i=1;i&lt;=n;i++)
    {
        for(j=1;j&lt;=i;j++)
        {
            for(k=1;k&lt;=i;k++) { //this prints the numbers X times
                printf(""%d"",i);
            }
            printf(""\n"");
        }
    }
}
</code></pre>
",0
45716539,45716210,0,"<ul>
<li><p>You are reading characters from file until you receive new line character (<code>\n</code>) or fill an array, then you return characters stored in an array passed by caller.</p></li>
<li><p>From this returned array you may get separated values with <code>strtok</code>.</p></li>
<li><p>Repeat until you receive <code>0</code> from <code>getline</code> (Getline received <code>EOF</code> from file.)</p></li>
</ul>

<p>Here is simple example with your own <code>getline</code> function which you may modify.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int getline(char s[],int lim, FILE * fp)
{
    int c, i;
    for (i=0; i &lt; lim-1 &amp;&amp; (c=fgetc(fp))!=EOF &amp;&amp; c!='\n'; ++i)
    {
        s[i] = c;
    }
    if (c == '\n')
    {
        s[i] = c;
        ++i;
    }
    s[i] = '\0';
    return i;
}

int main()
{
    FILE * fp = fopen(""c:\\textfile.txt"", ""r"");

    char line[100];
    char * ptr;

    while (getline(line, 100, fp))
    {
        ptr = strtok(line, "","");

        while( ptr != NULL )
        {
           printf("" %s\n"", ptr);

           ptr = strtok(NULL, "","");
        }
    }

    return 0;
}
</code></pre>

<p>Output</p>

<pre><code>I
Ate
Cookies

She
Drink
Coffee

Tom
Wears
Pyjamas
</code></pre>

<p>Storing strings into variable isnt tough, here is an example</p>

<pre><code>strcpy(name, ptr);
</code></pre>

<p>But be careful, writing outside of bounds have <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behavior</a>.</p>

<pre><code>strncpy(name, ptr, 100); You can limit number of copied characters with strncpy, but be careful, this function is error-prone.
</code></pre>
",0
45716592,45716210,0,"<p>You can do like this, </p>

<ol>
<li>Go on reading characters from a file, after every character is read compare with ',' character. </li>
<li>If the character read is ',' then you have finished reading the name, otherwise store it in a character array and continue reading the file. </li>
<li>Once you hit ',' character, terminate the character array with null character(Now you have a complete name with you).</li>
<li>Compare this character array with a string you receive as input using a strcmp(String compare function). If its it matches decide what you wanna do?</li>
</ol>

<p>I hope i am clear.</p>
",0
45716440,45716210,0,"<p>There is different ways to read data from a <code>FILE *</code> in C :</p>

<ul>
<li>You read only one character : <code>int fgetc(FILE *fp);</code>.</li>
<li>You read a whole line : <code>char *fgets(char *buf, int n, FILE *fp);</code> (take care to <code>buf</code>, it must point to allocate memory).</li>
<li>You read a formatted string, which is your case here : <code>int fscanf(FILE *stream, const char *format, ...)</code>, it works like <code>printf()</code> :</li>
</ul>

<p>This way :</p>

<pre><code>char name[20], action[20], item[20];
FILE *f = fopen(""myfile.txt"", ""r"");

if (! f)
    return;

if (3 == fscanf(f, ""%19[^,\n],%19[^,\n],%19[^,\n]\n"", name, action, item))
    printf(""%s %s %s\n"", name, action, item)
</code></pre>

<p><code>%30[^,\n],</code> here is used to read of whole object of your line, except <code>,</code> or <code>\n</code>, which will read item by item the content of your string.</p>
",3
45718322,45716210,0,"<p>start with like this</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define DATA_FILE ""data.txt""
#define LEN 19
#define SIZE (LEN+1)
//Stringification
#define S_(n) #n
#define S(n) S_(n)

enum { NOT_FOUND, FIND };

int pull_data(const char name[SIZE], char action[SIZE], char item[SIZE]){
    int ret = NOT_FOUND;

    FILE *fp = fopen(DATA_FILE, ""r"");//fileopen --&gt; fopen
    if(fp == NULL){
        perror(""fopen:"");
        exit(EXIT_FAILURE);
    } else {
        char nametxt[SIZE];
        *action = *item = 0;
        while(fscanf(fp, ""%"" S(LEN) ""[^,],%"" S(LEN) ""[^,],%"" S(LEN) ""[^\n]%*c"", //""%19[^,],%19[^,],%19[^\n]%*c""
            nametxt, action, item) == 3){
            if(strcmp(name, nametxt) == 0){//Use strcmp for comparison of strings
                ret = FIND;
                break;
            }
        }
    }
    fclose(fp);
    return ret;
}

int main(void){
    char name[SIZE], action[SIZE], item[SIZE];

    printf(""Enter name: \n"");//prinf --&gt; printf
    if(scanf(""%"" S(LEN) ""s"", name) == 1){
        if(pull_data(name, action, item) == FIND){
            printf(""%s\n%s\n%s\n"", name, action, item);
        } else {
            printf(""%s not found.\n"", name);
        }
    }
}
</code></pre>
",0
45769540,45769455,0,"<p>declare:</p>

<pre><code>uint16_t detect = 0xffff;
</code></pre>

<p>and add after the printf</p>

<pre><code>detect &lt;&lt;= 8;
detect |= (unsigned)ch &amp; 0xff;

id(detect == 0x0083) printf(""\n"");
</code></pre>
",1
45771384,45769455,0,"<p>Minimalistic state machine:</p>

<ul>
<li>if the program <em>sees</em> a <code>\0</code>, it does not <em>yet</em> print it</li>
<li>but it does <em>remember</em> having seen it.</li>
<li>on the next character, the <code>\0</code> still needs to be printed, but (maybe) a <code>\n</code> needs to be output first.</li>
<li>and the next character is always printed.</li>
</ul>

<p>[the program will fail if two consecutive <code>\0</code> characters occur, but that could be fixed with an extra condition]</p>

<hr>

<pre><code>int ch,state;

for(state=0;;){
        ch = getc(fi);
        if (ch == EOF) break;
        switch (state) {
        case 0: if(ch == 0) { state++; continue;}
                break;
        case 1: if(ch == 0x83) fputc('\n', fo);
                fprintf(fo,""00"");
                state = 0;
                break;
                }
        fprintf(fo, ""02X"",ch&amp;0xff);
        }
if(state) fprintf(fo,""00"");
</code></pre>
",1
45749362,45749319,0,"<p>Let's start by what is not ok.</p>

<pre><code>scanf (""%[^\n]%*c"", &amp;encryptArr); //Wrong
scanf (""%[^\n]%*c"", &amp;encryptArr[0]); //OK
scanf (""%[^\n]%*c"", encryptArr); //OK
</code></pre>

<p>Now your rotation function.</p>

<pre><code>char rotateArray(char str[], int degree, int length) {
    char temp[length]; //Declared on stack, values are not known, UB
    for(int i=0; i &lt; length + 1; i++) { //Why +1? Forces UB in later stage
        str[i] = str[i]+ &amp;degree; //Degree is variable on stack, adding &amp; is just getting address from stack
        str[i] = temp[i]; //Assigning temp value with undefined value
        //printf (""%c"", str[i]); //Printing undefined value
        }
    return &amp;str; //You should get at least warning here.
    return str[0]; //Better
}
</code></pre>

<p>This is now generic. When you will tell us what is desired output according to input, I will be able to tell you more.</p>

<pre><code>printf(""%s\n"", rotateArray);
</code></pre>

<p>You cannot just print function name as string. This is undefined behavior in C.</p>
",0
45749851,45749319,3,"<p>Your code contains some behaviours that are wrong.</p>

<p>I guess maybe you're coming from another language and attempting to learn C?</p>

<p>Well, let us see what kind of errors in the code that you've made.</p>

<hr>

<h1>1.</h1>

<pre><code>char rotateArray(char str[], int degree, int length) {

    char temp[length];
    for(int i=0; i &lt; length +1; i++)
    {
        str[i] = str[i]+ &amp;degree;
        str[i] = temp[i];
        //printf (""%c"", str[i]);
        }
    return &amp;str;
}
</code></pre>

<p>My guess is you're trying to rotate (shift the character) one by one and storing it into the <code>temp</code> string array. You don't actually need to store the new rotated value into the a new <code>temp</code> because <code>str</code> array has already been modified here <code>str[i] = str[i]+ &amp;degree</code>. The reason is that in C, an array is passed kind of like reference so you can modify the value and it still gonna 'affects' the <code>str</code>'s value outside of it.</p>

<p>So we can remove <code>temp</code> array altogether. </p>

<pre><code>/* char rotateArray(char str[], int degree, int length) { */
void rotateArray(char str[], int degree, int length) {

    /* char temp[length]; */

    for(int i=0; i &lt; length +1; i++)
    {
        str[i] = str[i]+ degree;
        /* str[i] = temp[i]; */
        //printf (""%c"", str[i]);
    }
    /* return &amp;str; */
}
</code></pre>

<hr>

<h1>2.</h1>

<p>In the main body, almost on every <code>printf</code> and <code>scanf</code> you've inserted <code>\n</code> at the back. I guess again maybe this style of coding was influenced by another programming language? :)</p>

<p>Actually, in C, you don't have to put the <code>\n</code> as a new parameter unless you had put specifier at the format string. So you can remove <code>, ""\n""</code> altogether.</p>

<pre><code>/* printf(""Enter the value of degree: "", ""\n""); */
printf(""Enter the value of degree: "");

/* scanf(""%d"",&amp;degree, ""\n""); */
scanf(""%d"",&amp;degree);

/* printf(""Enter the string array you want to encrypt: "", ""\n""); */
printf(""Enter the string array you want to encrypt: "");

/* printf(""The character string is: %s\n"", encryptArr, ""\n""); */
printf(""The character string is: %s\n"", encryptArr);
</code></pre>

<p><code>printf</code> &amp; <code>scanf</code> is kinda like a beast to a new C programmer. Please take a look at more resources that discuss those matter.</p>

<hr>

<h1>3.</h1>

<p>Lastly, at the end of your main body,</p>

<pre><code>printf(""%s\n"", rotateArray);
</code></pre>

<p>This is kinda nonsense because you're trying to print the function name. Well, I guess again maybe you thought that it will print the returned value of the function, right?</p>

<p>Actually, from what I have told you earlier at the top, any string array that passed into the function as a <code>str</code> parameter is kinda like a reference, so when you're modifying <code>str</code> inside the <code>rotateArray</code> body it will 'affect' the value of the main function too.</p>

<p>So instead of that wrong code, you can change it to be like this,</p>

<pre><code>/* printf(""%s\n"", rotateArray); */
printf(""%s\n"", encryptArr);
</code></pre>

<hr>

<p>So, the final modified code will be:</p>

<pre><code>/*
 *  Assignment.c
 *
 *  Created on: 18-Aug-2017
 *  Author: sumeetpatil
 */

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

/* char rotateArray(char str[], int degree, int length) { */
void rotateArray(char str[], int degree, int length) {

    /* char temp[length]; */

    for(int i=0; i &lt; length +1; i++)
    {
        str[i] = str[i]+ degree;
        /* str[i] = temp[i]; */
        //printf (""%c"", str[i]);
    }
    /* return &amp;str; */
}

int main(){

    int length;
    int degree;
    char encryptArr[50];

    /* printf(""Enter the value of degree: "", ""\n""); */
    printf(""Enter the value of degree: "");
    fflush(stdout);

    /* scanf(""%d"",&amp;degree, ""\n""); */
    scanf(""%d"",&amp;degree);

    /* printf(""Enter the string array you want to encrypt: "", ""\n""); */
    printf(""Enter the string array you want to encrypt: "");
    fflush(stdout);

    fgets(encryptArr, 100, stdin);

    scanf (""%[^\n]%*c"", &amp;encryptArr);

    length = strlen(encryptArr);

    /* printf(""The character string is: %s\n"", encryptArr, ""\n""); */
    printf(""The character string is: %s\n"", encryptArr);

    printf(""The size of character array is %u\n"", length);

    rotateArray(encryptArr, degree, length);

    /* printf(""%s\n"", rotateArray); */
    printf(""%s\n"", encryptArr);

}
</code></pre>

<hr>

<h1>Bonus</h1>

<p>What're you trying to achieve here is what called as <a href=""https://en.wikipedia.org/wiki/Caesar_cipher"" rel=""nofollow noreferrer"">Caesar cipher</a>.</p>

<p>Your implementation was wrong because it doesn't handle 'alphabet overflow' correctly. What I mean is when your code exceeds <code>z</code> it doesn't rotate itself to <code>a</code> again. There are many ways to achieve this either by using remainder operator <code>%</code> or using <code>if-else</code> statement to check either the alphabet has overflowed.</p>

<p>Try to look at the example <a href=""https://en.wikipedia.org/wiki/Caesar_cipher#Example"" rel=""nofollow noreferrer"">here</a>.</p>
",2
45750427,45749319,0,"<p>The encoding function has problems:</p>

<ul>
<li><p>the loop index should vary from <code>0</code> to <code>len - 1</code> inclusive, hence the test should be:</p>

<pre><code>for (int i = 0; i &lt; length; i++) { ...
</code></pre></li>
<li><p>shifting the character values by <code>degree</code> must be done more carefully, handling lowercase and uppercase characters separately and using a modulo computation for a circular permutation.</p></li>
<li><p>to use the value of <code>degree</code>, you do not need the <code>&amp;</code> addressof operator.</p></li>
<li><p>the string is modified in place, you do not need a temporary array.</p></li>
</ul>

<p>Here is a corrected version:</p>

<pre><code>char *rotateArray(char *str, int degree, int length) {
    for (int i = 0; i &lt; length; i++) {
        char c = str[i];
        if (c &gt;= 'a' &amp;&amp; c &lt;= 'z') {
            str[i] = 'a' + (c - 'a' + degree) % 26;
        } else
        if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') {
            str[i] = 'A' + (c - 'A' + degree) % 26;
        }
    }
    return str;
}
</code></pre>

<p>The <code>main()</code> function has problems too:</p>

<ul>
<li><p><code>fgets()</code> and <code>scanf()</code> are 2 different ways to read the string, just use one.</p></li>
<li><p>The second argument to <code>fgets(encryptArr, 100, stdin);</code> should be <code>50</code> or <code>sizeof(encryptArr)</code> to tell <code>fgets()</code> the size of the destination array and prevent buffer overflow.</p></li>
<li><p>You pass extra <code>""\n""</code> arguments to <code>scanf()</code> and <code>printf()</code> that are ignored. Enable compiler warnings (<code>-Wall -Wextra</code>) and study the messages.</p></li>
<li><p>function <code>rotateArray()</code> modifies <code>encryptArr</code> in place, you should pass <code>encryptArr</code> to <code>printf()</code> instead of the function name.</p></li>
</ul>

<p>Here is a corrected version:</p>

<pre><code>int main(void) {
    int length;
    int degree;
    char encryptArr[50];

    printf(""Enter the value of degree: "");
    if (scanf(""%d"", &amp;degree) != 1)
        return 1;

    printf(""Enter the string array you want to encrypt: "");
    if (!fgets(encryptArr, sizeof(encryptArr), stdin))
        return 1;

    length = strlen(encryptArr);
    printf(""The character string is: %s\n"", encryptArr);
    printf(""The length of character string is %d\n"", length);

    rotateArray(encryptArr, degree, length);
    printf(""%s\n"", encryptArr);

    return 0;
}
</code></pre>

<p>Finally, you include <code>&lt;stdio.h&gt;</code> twice. While it does not cause a problem, you should only include header files once and only those needed:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
</code></pre>
",1
45752520,45749319,0,"<p>Use this:</p>

<pre><code>char *rotateArray(char *str, int degree, int length) {
    for (int i = 0; i &lt; length; i++) {
        char c = str[i];
        if (c &gt;= 'a' &amp;&amp; c &lt;= 'z') {
            str[i] = 'a' + (c - 'a' + degree) % 26;
        } else
        if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') {
            str[i] = 'A' + (c - 'A' + degree) % 26;
        }
    }
    return str;
}
</code></pre>
",0
45756697,45756630,1,"<p><code>scanf</code> is looking for a pointer to <code>char</code>, but in your code you've got this</p>

<pre><code>scanf(""%s"",&amp;a[i].name);
</code></pre>

<p><code>a[i].name</code> is an array of <code>char</code> which for the purposes of <code>scanf</code> is the same as a <code>char *</code>, but you're getting the pointer to it, so you end up with <code>char (*)[50]</code>. Just remove the unneeded ampersand and you'll remove the warning and fix your code.</p>
",0
45756755,45756630,3,"<p><code>&amp;a[i].surname</code> is actually giving the address of struct member array <code>surname</code>. <code>surname</code> is of type <code>char [50]</code> so it's address will be of type <code>char (*)[50]</code>. As an argument to a function, array decay to pointer to it's first element. So, <code>a[i].surname</code> will do the job. You need to remove <code>&amp;</code> from the argument.   </p>

<pre><code>printf(""Surname:"");
scanf(""%s"",a[i].surname);
printf(""Name:"");
scanf(""%s"",a[i].name);
</code></pre>
",0
45756665,45756630,1,"<p>Do not use <code>&amp;</code> in strings as <code>surname</code> is already in format scanf is expecting it.</p>

<pre><code>printf(""Surname:"");
scanf(""%s"",a[i].surname);
printf(""Name:"");
scanf(""%s"",a[i].name);
</code></pre>

<p>Also, please read why you have to set length for string in <code>scanf</code>.</p>

<p><a href=""https://stackoverflow.com/questions/35103745/read-a-string-as-an-input-using-scanf"">Read a string as an input using scanf</a></p>
",0
45782933,45782899,2,"<p>Because you need to use the correct <code>scanf()</code> specifier.</p>

<p>If you use <code>float</code> then <code>""%f""</code>, and <code>""%lf""</code> if you use <code>double</code>.</p>

<p>For <code>float</code>, you would do it like this</p>

<pre><code>#include&lt;stdio.h&gt;

int main()
{
    float n1, n2;
    float n3;

    printf(""input 2 flt:"");
    if (scanf(""%f%f"", &amp;n1, &amp;n2) == 2) {
        n3 = n1 * n2;
        printf(""n1 * n2 = %.2f"",n3);
    }
}
</code></pre>

<p>And for <code>double</code></p>

<pre><code>#include&lt;stdio.h&gt;

int main()
{
    double n1, n2;
    double n3;

    printf(""input 2 flt:"");
    if (scanf(""%lf%lf"", &amp;n1, &amp;n2) == 2) {
        n3 = n1 * n2;
        printf(""n1 * n2 = %.2f"",n3);
    }
}
</code></pre>

<p>Note that I checked that <code>scanf()</code> returned <code>2</code> before using the values of  <code>n1</code> and <code>n2</code>, that's because if you don't check the program might invoke undefined behavior due to <code>n1</code> and/or <code>n2</code> not being initialized.</p>

<p>Your <code>printf()</code> specifier is also wrong, for both <code>float</code> and <code>double</code> <strong>you can use</strong> <code>""%f""</code>, read the documentation.</p>
",3
45782941,45782899,1,"<p>You must use <code>%f</code>. </p>

<pre><code>#include  &lt;stdio.h&gt;
int main(){
float n1,n2;
float n3;
printf(""input 2 flt:"");
scanf(""%f %f"",&amp;n1,&amp;n2);
n3 = n1 * n2;
printf(""n1 * n2 = %.2f"",n3);
}
</code></pre>
",0
45788753,45782899,0,"<p>from other answers£¬I learnt the <code>%f %lf</code> things are called format specifiers.</p>

<p><code>f lf</code> are for different data-types. <code>f</code> is for float  <code>lf</code> for double</p>

<p>this site listed all <a href=""http://codeforwin.in/2015/05/list-of-all-format-specifiers-in-c-programming.html"" rel=""nofollow noreferrer"">spes</a>.</p>

<hr>

<p>and I checked c11 standard, found the <code>l</code> before <code>f</code> is called a length modifier.</p>
",0
46131964,46131811,1,"<p>by nested ?: code do you mean this?if  yes then you can write like this..but don't use this in real life as it is messy..
use a simple if  else in stead</p>

<pre><code>#include &lt;stdio.h&gt;
 int main(){

 int a=7;
 int b=6;
 int c=5;
 int d=a&gt;b?(b&gt;c?3:4):1;
 printf(""%d"",d);
 return 0;
 }
//prints 3
</code></pre>
",2
46099381,46099091,1,"<p>You're right that when one of the <code>exec*()</code> family of functions is called, you do not specify the number of arguments explicitly ¡ª that is indicated by the presence of a null pointer at the end of a list of arguments.</p>

<p>The count is passed to the <code>int main(int argc, char **argv)</code> function for convenience, so that the code does not have to step through the entire argument list to determine how many arguments are present.  It is only convenience ¡ª since <code>argv[argc] == 0</code> is guaranteed, you can determine the end of the arguments unambiguously.</p>

<p>For the rest, the reason is historical ¡ª it was done that way from the start, and there has been no reason to change it (and every reason not to change it).</p>

<p>It isn't clear what you mean by 'a keyword' for the argument count.  C has very few keywords, and one for this purpose would be peculiar.  Similarly, although there could be a function to do the job, that isn't really necessary ¡ª the interface chosen obviates the need for such a function.  It might have been useful to have functional access to the argument list (and the environment) so that library code could enumerate the arguments and environment.  (Using <code>getenv()</code>, you can find out about environment variables you know about; you can't find out about environment variables which you don't know about.  On POSIX systems, there is the <code>extern char **environ;</code> variable that be used to enumerate the content of the environment, but that's not part of Standard C.)</p>
",0
47539644,46249276,2,"<p>Lets decode it line by line:</p>

<pre><code>char *s=""Peace"";
</code></pre>

<p>here <code>s</code> points to 'P'</p>

<pre><code>printf(""%s\n"",s);
</code></pre>

<p>Prints entire string ""Peace"" as <code>s</code> is at 'P'. <strong>That's what %s does actually</strong>.</p>

<pre><code>printf(""%s\n"",s+1);
</code></pre>

<p>Now <code>s</code> is at 'e' , so it will print ""eace"".</p>

<pre><code>printf(""%s\n"",s++);
</code></pre>

<p>This would also print ""eace"" as you've used a post increment operator. If you had used <code>++s</code> instead then it would print ""ace"".</p>
",0
46634544,46634499,5,"<ol>
<li><p>In C ANY numeric type can be evaluated as a bool, and for such types, any non-zero value is 'true'.  So since the character <code>'m'</code> is non-zero (only <code>'\0'</code> is zero), it is ""true""</p></li>
<li><p>Precedence -- All operators in C have precedence, and ?:, while lower than most, is higher than assignment operators.  So this expression is equivalent to:</p></li>
</ol>

<p><code>x = (5 ? (y = z) : (z = y))</code></p>
",0
48004675,48004506,1,"<p>It certainly <em>is</em> possible to chain together a lot of variables for printing, you just have to make sure your format string matches the arguments given, lest you get into undefined behaviour territory.</p>

<p>What you have in your simplified code should work fine, leading me to believe you may have simplified it <em>too</em> much. I would suggest posting the <em>actual</em> code that causes the problem (a full, able-to-be-compiled program, exhibiting the errant behaviour) since there's absolutely nothing wrong with what you're given us. The data is being set correctly and the <code>printf</code> is being called correctly.</p>

<p>I've seen implementations of <code>printf</code> (such as in embedded systems) that have limitations such as 4K maximum buffer size but you're nowhere near that.</p>

<hr>

<p>However, look at your (original, now changed) code:</p>

<pre><code>int len = snprintf(NULL,0, ""xxx"", yyy);
char *somevar = malloc(len + 1);
sprintf(NULL,0, ""xxx"", yyy);
</code></pre>

<p>If that truly <em>is</em> how you're doing it, I'm not surprised you're crashing - you don't actually <em>populate</em> the memory that you're allocating, meaning it will be set to some arbitrary value, including possible a non-null-terminated ""string"".</p>

<p>In any case, <code>sprint</code> is not like <code>snprintf</code>, it doesn't really like a NULL buffer being passed in.</p>

<p>The third line should be of the form:</p>

<pre><code>sprintf(somevar, ""xxx"", yyy);
</code></pre>

<hr>

<p>And, on top of that, though unlikely in a small program, <code>malloc</code> is allowed to fail and return <code>NULL</code> - you should <em>always</em> check for failure before relying on values from C functions.</p>
",2
48005144,48004506,0,"<blockquote>
  <p>I have an error when try output a lot of variable via printf.</p>
</blockquote>

<p><strong>The error is probably elsewhere.</strong> You are allowed to give many arguments (probably hundreds or thousands of them, the limit is implementation specific and quite high in practice) to <code>printf</code>, if the format control string (first argument to <code>printf</code>) is conforming the the other arguments (in number of argument and in type), and if the arguments are all valid. Otherwise, it is <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behavior</a>. Be very <a href=""https://stackoverflow.com/a/25636788/841108"">scared</a> of UB (and you probably have some).</p>

<p>You should compile with all warnings and debug info, e.g. <code>gcc -Wall -Wextra -g</code> with <a href=""http://gcc.gnu.org/"" rel=""nofollow noreferrer"">GCC</a>, and improve your code to get no warnings. You should read the <a href=""http://en.cppreference.com/w/c"" rel=""nofollow noreferrer"">documentation</a> of every standard C function, and of every external function you are using.</p>

<p><strong>Use the <a href=""https://sourceware.org/gdb/current/onlinedocs/gdb/"" rel=""nofollow noreferrer"">debugger <code>gdb</code></a></strong> to run your program step by step and query its state, then understanding what is wrong. You might also use tools like <a href=""http://valgrind.org/"" rel=""nofollow noreferrer"">valgrind</a> to hunt <a href=""https://en.wikipedia.org/wiki/Memory_leak"" rel=""nofollow noreferrer"">memory leaks</a>, <a href=""https://en.wikipedia.org/wiki/Buffer_overflow"" rel=""nofollow noreferrer"">buffer overflows</a>, and other <a href=""https://en.wikipedia.org/wiki/Memory_corruption"" rel=""nofollow noreferrer"">memory corruption</a> (and you probably have some) etc.</p>

<p>Your bug is probably in some other code that your question don't show.</p>

<p>BTW, you might use <a href=""http://man7.org/linux/man-pages/man3/asprintf.3.html"" rel=""nofollow noreferrer"">asprintf(3)</a> if your system has it, and you <a href=""https://stackoverflow.com/a/32716494/841108"">should test</a> against failure of <code>malloc</code>.</p>
",0
46959722,46958820,1,"<p>The easiest way may be:</p>

<pre><code>    scanf(""%d"", &amp;x);
    if (!x) break;        // break the loop, not asking anything else
</code></pre>
",0
46967310,46966512,2,"<p>You want <code>snprintf</code>.  Just like <code>printf</code>, but you give it a destination buffer and a size.  (The size is important, so <code>snprintf</code> can be sure not to overflow it.)  Use it like this:</p>

<pre><code>char outbuf[100];
snprintf(outbuf, sizeof(outbuf), ""%d %f %s %c"", 1, 2.3, ""four"", '5');
</code></pre>
",0
46966534,46966512,3,"<p>The answer is <code>sprintf</code>: it's exactly <code>printf</code> to a buffer.</p>
",8
47463915,47460778,0,"<p>It looks that your iteration enhances around last point, but is still coarse around start point:</p>

<pre><code>*---------------* refine 0

*-------*-------* refine 1

*-------*---*---* refine 2

*-------*---*-*-* refine 3
</code></pre>

<p>And as your equation looks hyperbolic (depends on all previous iterations) the solution error will be cumuluative in nature. I think you shall iterate with fine grid from the begining to get proper solution - not only around neighborhood. Eg. for simple equation df/dx=f with such implementation:</p>

<pre><code>float update(float f_prev, float dx, float /* unused */ target_dx) {
    return f_prev*dx + f_prev;
}

int main(void)
{
    int n = 8;
    float dx = 2.f/(float)(n-1);
    float f[n];
    f[0] = 1.f;

    for (int i = 1; i &lt; n; i++) {
        f[i] = update(f[i-1], dx, dx / 16.f);
    }

    return 0;
}
</code></pre>

<p>I would go with simple recursive formula:</p>

<pre><code>float update_recursive(float f_prev, float dx, float target_dx) {
    if (dx &gt; target_dx) {
        return update_recursive(
            update_recursive(f_prev, dx / 2.f, target_dx), dx / 2.f, target_dx
        );
    }

    return dx * f_prev + f_prev;
}
</code></pre>

<p>The approach enhances the quality of solution. The terminating condition may be more adaptive to solution than target_dx is. Of course, it is needed to ensure that recursion is well bounded.</p>
",0
47538856,47538827,0,"<p>Print <code>4*(i-1)+y</code> instead of <code>y</code>:</p>

<pre><code>printf(""%d "",4*(i-1)+y);
</code></pre>
",1
47538860,47538827,0,"<pre><code>for(y=1; y&lt;=count; y++){
     printf(""%d "",num1++);
}
</code></pre>

<p>That way you will ensure that all the <code>numbers</code> will be printed. you can use <code>num1</code> variable that you have declared and initialized with <code>1</code>. </p>

<p>Don't use unnecessary global variables. And keep the declarations close to where you use them. That way you won't have to look in the top of the page to check the type or if you initialized or not.</p>

<pre><code>for(i=1; i&lt;=count; i++){
     printf(""%d "",i);
     if( i % 4 == 0)
        printf(""\n"");
}
</code></pre>
",0
47498995,47498747,0,"<pre><code>q=n&lt;p? n++: p++;
</code></pre>

<p>Means</p>

<pre><code>if (n &lt; p) {
  q = n;
  n = n + 1;
} else {
  q = p;
  p = p + 1;
}
</code></pre>

<p>Look at your code this way (this is how compiler sees it):</p>

<pre><code>q = ((n &lt; p) ? n++ : p++);
</code></pre>

<p>What you probably want is this:</p>

<pre><code>(q=n)&lt;p? n++: p++;
</code></pre>

<p>Compiler sees this as:</p>

<pre><code>q = n;
if (q &lt; p) {
  n = n + 1;
} else {
  p = p + 1;
}
</code></pre>
",0
47498779,47498747,3,"<blockquote>
  <p>it checks if(5=15&lt;10) n++ else q++</p>
</blockquote>

<p>Not true.</p>

<pre><code>q=n&lt;p? n++: p++;
</code></pre>

<p>is an <strong>assignment</strong>.</p>

<p>The C draft in section <code>6.5.16.1</code> p2 says:</p>

<blockquote>
  <p>In simple assignment (=), the value of the right operand is converted
  to the type of the assignment expression and replaces the value stored
  in the object designated by the left operand.</p>
</blockquote>

<p>In your case,it just that the value of the right operand is deduced from the expression <code>n&lt;p? n++: p++</code>.</p>

<p>Also as you have two prefix expressions <code>n++</code> and <code>p++</code> the value of <code>n</code> and <code>p</code> before the increment is taken into account depending on the branching.</p>
",0
47498797,47498747,2,"<p>check the <code>conditional</code> operator <code>associativity</code>, its Left to Right .</p>

<pre><code>q=n&lt;p? n++: p++;
</code></pre>

<p>first <code>n&lt; p</code> is solved which is <code>false</code>, so result will be <code>p++</code> 
so <code>q = p++;</code> // here <code>p</code> value also <code>change</code> but first 10 is assigned to q because of post increment </p>

<p>finally <code>p</code> becomes <code>11</code>  and <code>q = 10</code></p>
",0
47498804,47498747,1,"<p>Its not that much confusing
These are increment statements
Pre increnent or post increment.
So
A++ 
Means value of A is used first in the expression and then it will increment
And
++A 
Means value of A us increment first then used.
Ao in the expression</p>

<pre><code>int n=15, p=10, q=5;
q=n&lt;p? n++: p++;
</code></pre>

<p>As <code>n&lt;p</code> is false
And then it resembles to</p>

<pre><code>q = p++
</code></pre>

<p>It means </p>

<pre><code>q = p
</code></pre>

<p>Then <code>p = p+ 1</code>.
Hope this will clear the doubt..</p>
",0
47498892,47498747,1,"<p>The q= is an assignment operator so it is not part of the evaluation. </p>

<p>Your conversion to the if statement should really be </p>

<pre><code>if (n &lt; q) {
    q = n;
    n++; 
} else {
    q = p;
    p++;
}
</code></pre>
",0
47501466,47498747,0,"<p>regarding: </p>

<pre><code>q=n&lt;p? n++: p++; 
</code></pre>

<p>properly written: </p>

<pre><code>q = (n&lt;p)? n++: p++; 
</code></pre>

<p>means that the variable: q will be set to either n or p, depending on if the value in n is less than the value in p or not. </p>

<p>So the initial value in q is meaningless</p>
",0
47965523,47965002,3,"<p>Since it is Christmas Eve, lets help out fellow man... who obviously is badly in need. For code that is supposed to pass an <code>array</code> to <code>least_in_array</code>, <code>largest_in_array</code> and <code>average_array</code> -- you have no array! That somewhat puts you behind the eight-ball from the word ""Go!"".</p>

<p>Your thought to use a <code>stuct</code> to capture and coordinate <code>dayInMonth</code>, <code>month</code> and <code>temperature</code> is 100% correct. (but note: C-style generally avoids <code>camelCase</code> variable names in favor of all lowercase). Also, defining <code>struct Data1</code> within <code>main()</code> prevents your functions above that point from knowing what <code>struct Data1</code> is, so you need to move your struct definition to the top of the file. (or provide a <em>forward declaration</em>, but we will save that for later) For now, let's just move your <code>Data1</code> to the top (I used a <code>typedef</code> to alleviate having to prefix each use with <code>stuct</code> and renamed <code>Data1</code> <code>data</code>:</p>

<pre><code>#define NDAYS 365

typedef struct {
    int day,
        month;
    double temperature;
} data;
</code></pre>

<p><strong>Note</strong> the <em>defined constant</em> <code>NDAYS</code>. Since you are going to need an array, and since a dynamically allocated and reallocated approach seem well beyond your needs here, let's just define a constant, a maximum, for the number of elements we will have in our array.</p>

<p>Now, before we go further, let's think about our array. If we are going to use a <code>struct</code> to hold the associated date and temperature measurement, then we are going to need an array of... what?? An array of <code>struct</code>. And with our constant <code>NDAYS</code>, we will declare a maximum of <code>365</code> elements in our array. So how would this work? We have our stuct typedeffed to <code>data</code>, so if we want an array of <code>data</code> we need:</p>

<pre><code>    data da[NDAYS] = {{0, 0, 0.0}};
</code></pre>

<p><strong>Note:</strong> the older initializer format initializing each field was used as it is unclear whether you could be using a C89 compiler. C99 and later added named initializers , e.g. <code>{{.day = 0}}</code> and any uninitialized elements are implicitly initialized to zero.</p>

<p>Now we have an array of <code>data</code> and can capture measurements. Of course you are responsible for keeping track of the indexes you fill. A simple counter, incremented each time a successful measurement in entered is all you need (<code>ndx</code> is used below)</p>

<p>How do we make <code>least_in_array</code>, <code>largest_in_array</code> and <code>average_array</code> work with an array of <code>data</code>? Recall, we moved the definition of the struct to the beginning of the source file, so now each function knows what <code>data</code> is. We simply need to pass our array of <code>data</code> as a parameter, e.g. </p>

<pre><code>float least_in_array (data *array, int n)
{
    int i;
    float least = INT_MAX;   /* sufficiently high temp */

    for (i = 0; i &lt; n; i++)
        if (array[i].temperature &lt; least)
            least = array[i].temperature;

    return least;
}
</code></pre>

<p>(<strong>note</strong>, each of the quantities of <code>least_in_array</code>, <code>largest_in_array</code> and <code>average_array</code> refer to the <code>temperature</code> values and therefore need to return type <code>float</code>.)</p>

<p>The remainder of putting together <code>largest_in_array</code> and <code>average_array</code> follows the same pattern.</p>

<p>The crux of your remaining problems relate to handling user input, and the particular pitfalls associated with taking user input with <code>scanf</code>. It can be done, but you must <strong><em>always validate the return</em></strong>, and test for user cancellation of input by testing for <code>EOF</code> (the result of the user pressing <kbd>Ctrl+d</kbd> (or <kbd>Ctrl+z</kbd> on windoze)). </p>

<p>You must validate that the number of expected conversions did in fact take place, or you must handle the error, and most importantly, you must <strong><em>account for any characters left in the input buffer</em></strong> (e.g. <code>stdin</code>), otherwise, if an invalid entry is made and you don't remove it from <code>stdin</code>, you will loop forever... (with <code>scanf</code> if a <em>matching</em> or <em>input</em> failure occurs -- no additional character are processed -- leaving them where? (oh, in <code>stdin</code>)</p>

<p>You can make this fairly easy on yourself if you declare a few helper functions to empty stdin, and make the normal process of getting an integer or float from the user relatively safe. For example, to empty <code>stdin</code>, you simply read all remaining characters until a <code>'\n'</code> or <code>EOF</code> is encountered, e.g.</p>

<pre><code>/** simple function to empty all characters that remain
 *  in stdin. Needed when using scanf for user input.
 */
void empty_stdin()
{
    int c = getchar();

    while (c != '\n' &amp;&amp; c != EOF)
        c = getchar();
}
</code></pre>

<p>To ask the user for an <code>int</code> or <code>float</code>, you simply validate the return, check the number of successful conversion (what <code>scanf</code> returns), check whether <code>EOF</code> was generated by the user, and finally handle the error if invalid input was given and <code>empty_stdin</code> as required. You generally want to loop until the user either provides valid input, or cancels. (an invalid input does you no good).</p>

<p>For example, getting integer input can be handled as follows. (note: I put it in a function to keep from repeating this block of code for each input you take in the main body of your code...</p>

<pre><code>/** abbreviated function to read integer value from user.
 *  returns value on success, exits if user cancels.
 *  empties stdin after call to scanf.
 */
int getint ()
{
    int n = 0;

    for (;;) {              /* loop until valid input or EOF */
        int rtn = 0;        /* variable to capture return of scanf */
        rtn = scanf (""%d"", &amp;n);
        if (rtn == 1) {     /* we got an integer */
            empty_stdin();
            break;
        }
        else if (rtn == EOF) {  /* if user cancels, exit */
            fprintf (stderr, ""user canceled input.\n"");
            exit (EXIT_FAILURE);
        }
        if (rtn == 0)       /* handle error */
            fprintf (stderr, ""getint() error: invalid integer input.\n"");

        empty_stdin();      /* empty all chars remaining in stdin */
    }

    return n;
}
</code></pre>

<p>(taking input for a float works the same way).</p>

<p>Lastly, you generally want to avoid using <code>float</code> in most cases, using <code>double</code> instead, just due to loss of precision and limitations for representing floating-point numbers with a <code>23-bit</code> mantissa. However, here we are taking temperature, and <code>float</code> will suffice for this code.</p>

<p>Putting it altogether, you could do something like the following. Note, I have left your functions before <code>main()</code> as you had them, and added the helper function <em>definitions</em> after <code>main()</code>, but provided <em>declarations</em> before <code>main()</code> so they are visible to <code>main()</code> :</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;limits.h&gt;

#define NDAYS 365

typedef struct {
    int day,
        month;
    double temperature;
} data;

float least_in_array (data *array, int n)
{
    int i;
    float least = INT_MAX;   /* sufficiently high temp */

    for (i = 0; i &lt; n; i++)
        if (array[i].temperature &lt; least)
            least = array[i].temperature;

    return least;
}

float largest_in_array (data *array, int n)
{
    int i;
    float largest = INT_MIN; /* sufficiently low temp */

    for (i = 0; i &lt; n; i++)
        if (array[i].temperature &gt; largest)
            largest = array[i].temperature;

    return largest;
}

float average_array (data *array, int n)
{
    int i;
    float sum = 0.0;

    for (i = 0; i &lt; n; i++)
        sum += array[i].temperature;

    return sum / (float)n;
}

void empty_stdin();
int getint();
float getfloat();

int main (void) {

    int ndx = 0;
    float max = 0.0, min = 0.0, avg = 0.0;
    data da[NDAYS] = {{0, 0, 0.0}};

    for (;;) {

        int choose = 0;

        printf (""\n  (1) New measurement\n""
                ""  (2) Statistics\n""
                ""  (3) Exit\n\n""
                ""  choice: "");
        choose = getint();
        putchar ('\n');

        switch (choose) {
            case 1: if (ndx == NDAYS) {
                        fprintf (stderr, ""error: array full.\n"");
                        break;
                    }
                    printf (""    Enter day in month : "");
                    da[ndx].day = getint();
                    printf (""    Enter month        : "");
                    da[ndx].month = getint();
                    printf (""    Enter temperature  : "");
                    da[ndx].temperature = getfloat();
                    printf (""  da[%3d] saved\n""
                            ""  ----------------------------\n"", ndx++);
                    break;
            case 2: if (ndx == 0) {
                        fprintf (stderr, ""error: no measurements taken.\n"");
                        break;
                    }
                    min = least_in_array (da, ndx);
                    max = largest_in_array (da, ndx);
                    avg = average_array (da, ndx);
                    printf (""  minimum temp : %.2f\n""
                            ""  maximum temp : %.2f\n""
                            ""  average temp : %.2f\n""
                            ""  ----------------------------\n"",
                            min, max, avg);
                    break;
            case 3:
                    goto done;
                    break;
            default:
                    fprintf (stderr, ""error: invalid choice.\n"");
                    empty_stdin();
                    break;
        }
    }
    done:;

    return 0;
}

/** simple function to empty all characters that remain
 *  in stdin. Needed when using scanf for user input.
 */
void empty_stdin()
{
    int c = getchar();

    while (c != '\n' &amp;&amp; c != EOF)
        c = getchar();
}

/** abbreviated function to read integer value from user.
 *  returns value on success, exits if user cancels.
 *  empties stdin after call to scanf.
 */
int getint ()
{
    int n = 0;

    for (;;) {              /* loop until valid input or EOF */
        int rtn = 0;        /* variable to capture return of scanf */
        rtn = scanf (""%d"", &amp;n);
        if (rtn == 1) {     /* we got an integer */
            empty_stdin();
            break;
        }
        else if (rtn == EOF) {  /* if user cancels, exit */
            fprintf (stderr, ""user canceled input.\n"");
            exit (EXIT_FAILURE);
        }
        if (rtn == 0)       /* handle error */
            fprintf (stderr, ""getint() error: invalid integer input.\n"");

        empty_stdin();      /* empty all chars remaining in stdin */
    }

    return n;
}

/** abbreviated function to read float value from user.
 *  returns value on success, exits if user cancels.
 *  empties stdin after call to scanf.
 */
float getfloat ()
{
    float v = 0.0;

    for (;;) {              /* loop until valid input or EOF */
        int rtn = 0;        /* variable to capture return of scanf */
        rtn = scanf (""%f"", &amp;v);
        if (rtn == 1) {     /* we got an float */
            empty_stdin();
            break;
        }
        else if (rtn == EOF) {  /* if user cancels, exit */
            fprintf (stderr, ""user canceled input.\n"");
            exit (EXIT_FAILURE);
        }
        if (rtn == 0)       /* handle error */
            fprintf (stderr, ""getint() error: invalid float input.\n"");

        empty_stdin();      /* empty all chars remaining in stdin */
    }

    return v;
}
</code></pre>

<p><strong>Note:</strong> how the array bounds are limited to <code>365</code> or less in your take measurement part of the code, and how a check is made that there is at least one measurement present before any statistics can be provided. You always need to validate each step of the process. Look for corner-cases, think about what could go wrong with input (what if a cat stepped on the keyboard), and then go provide validations and checks to handle each case. The validations above are just the bare minimum, there are always more you can add to more fully report and handle each error condition.</p>

<p><strong>Example Use/Output</strong></p>

<pre><code>$ ./bin/tempmxmnavg

  (1) New measurement
  (2) Statistics
  (3) Exit

  choice: 2

error: no measurements taken.

  (1) New measurement
  (2) Statistics
  (3) Exit

  choice: 1

    Enter day in month : 8
    Enter month        : 2
    Enter temperature  : 20.0
  da[  0] saved
  ----------------------------

  (1) New measurement
  (2) Statistics
  (3) Exit

  choice: 1

    Enter day in month : 9
    Enter month        : 2
    Enter temperature  : 30.0
  da[  1] saved
  ----------------------------

  (1) New measurement
  (2) Statistics
  (3) Exit

  choice: 1

    Enter day in month : 10
    Enter month        : 2
    Enter temperature  : 70.0
  da[  2] saved
  ----------------------------

  (1) New measurement
  (2) Statistics
  (3) Exit

  choice: 2

  minimum temp : 20.00
  maximum temp : 70.00
  average temp : 40.00
  ----------------------------

  (1) New measurement
  (2) Statistics
  (3) Exit

  choice: 3
</code></pre>

<p>Look things over and let me know if you have any further questions (although given the evening, I won't be here much longer...)</p>
",0
47542904,47542729,1,"<p>Two things that prevent the program to give the result you expect</p>

<p>1) using <code>read</code> to read from standard input (characters) and store that into a (binary) integer</p>

<p>2) storing the result of <code>read</code> into that same integer, overwriting the (wrong) value stored in 1)</p>

<p>Have a look at <code>scanf</code> or <code>fgets</code> (<code>atoi</code>...), to read into a character array (string), <em>then</em> convert the characters read into a binary number, for instance</p>

<pre><code>char str[20];
fgets(str, 20, stdin);
int s = atoi(str);
</code></pre>

<p><code>read</code> version</p>

<pre><code>char str[20];
ssize_t nread = read(STDIN_FILENO, str, 20);
int s = atoi(str);
</code></pre>

<p>See <a href=""https://en.wikipedia.org/wiki/C_data_types#Fixed-width_integer_types"" rel=""nofollow noreferrer"">what an integer is</a>,</p>
",6
47698193,47697926,11,"<p>This is a portable solution:</p>

<pre><code>#include &lt;stdint.h&gt;

typedef uint32_t DWORD;   // DWORD = unsigned 32 bit value
typedef uint16_t WORD;    // WORD = unsigned 16 bit value
typedef uint8_t BYTE;     // BYTE = unsigned 8 bit value
</code></pre>
",3
47698051,47697926,3,"<p>You have it defined at: <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa383751(v=vs.85).aspx"" rel=""nofollow noreferrer"">https://msdn.microsoft.com/en-us/library/windows/desktop/aa383751(v=vs.85).aspx</a>, and that is already defined in Windows Data Type headers for WinAPI:</p>

<pre><code>typedef unsigned short WORD;
typedef unsigned char BYTE;
typedef unsigned long DWORD;
</code></pre>

<p>and it is a type, and not a macro.</p>
",1
47657639,47657537,1,"<p>I bet, you get the error ahead of the <code>if</code> statement at:</p>

<pre><code>value = j % i;
</code></pre>

<p>This is, because you start with <code>i</code> = 0:</p>

<pre><code>for(i = 0; i &lt; stop; ++i)
</code></pre>

<p>Since the modulo operator <code>%</code> is a division, using 0 as second operand isn't legal. You get a divide by zero error.</p>

<p>BTW: Starting with 1 is meaningless.</p>
",1
47695707,47695172,0,"<p>As mentionned in the comments, you should:</p>

<ul>
<li>include the proper headers (stdlib.h and string.h)</li>
<li><p>check for the value return, in particular the getenv call:</p>

<pre><code>if (!(vhome = (char *)getenv(""VHOME""))){
    fprintf(stderr, ""getenv(\""VHOME\"") returned NULL\n"");
    return -1;
}
</code></pre></li>
</ul>
",0
48007876,48007046,2,"<p>The loop in your code is never entered because <code>i=0</code> and then you check if <code>i&gt;=3</code> which is never true.
 You could use something like this:</p>

<pre><code>int digit_sum(int num){
int sum=0;
while (num !=0){
 sum += num%10;
  num = num/10;
}
  return sum;
}
int main()
{
int num = 12346;
/*
if (num &lt;0) // add this block if negative number is posible 
    num = -num; // and its ok to change num or use some temp instead
*/
int sum = digit_sum(num);
printf(""the sum of five digits is %d"",sum);
 return 0;
}
</code></pre>

<p>Or use recursion:</p>

<pre><code>int digit_sum(int num){
if (num) 
   return num%10 + digit_sum(num/10);
}
</code></pre>
",0
48007317,48007046,2,"<p>Your loop is never entered because i=0 and cant be greater then 3!!! so the solution is:</p>

<pre><code>int number=12345;
int total=0;
int remainder=0;

while(number&gt;0){
remainder=number%10;
total=total+remainder;
number=number/10;
}
</code></pre>
",5
48007452,48007046,1,"<p>Your code is almost correct, just needed correct loop condition. Added comments so that you can see what is going on:</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    int i, a, num = 32765, n;
    int sum = 0;

    // extract 1st digit
    a = num % 10; // a is 5 (% returns the remainder of the division)
    n = num / 10; // n is 3276 (should be 3276.5, but int eats 0.5)
    sum = sum + a; // sum is 5 which is (0 + 5)

    // extract the remaining 4 digits
    for (i = 0; i &lt; 4; i++) // i is 0, 1, 2, 3 
    {
        a = n % 10; // a is 6, 7, 2, 3
        n = n / 10; // n is 327, 32, 3, 0
        sum = sum + a; // sum is 11, 18, 20, 23
    }

    printf(""the sum of five digits is %d"", sum);
    return 0;
}
</code></pre>

<p><a href=""https://ideone.com/EI9tgM"" rel=""nofollow noreferrer"">https://ideone.com/EI9tgM</a></p>
",6
39317020,39316991,2,"<p>Yes, you are right on both accounts.</p>

<p>The important to note is that this behaviour is guaranteed by the C standard and is commonly known as <a href=""https://en.wikipedia.org/wiki/Short-circuit_evaluation"" rel=""nofollow noreferrer""><em>short circuting</em></a>.</p>

<p>Relevant: <a href=""https://stackoverflow.com/questions/628526/is-short-circuiting-boolean-operators-mandated-in-c-c-and-evaluation-order"">Is short-circuiting logical operators mandated? And evaluation order?</a></p>
",0
39317038,39316991,1,"<p>The left side of the <code>||</code> evaluates to <code>true</code>, and therefore the right side does not need to be evaluated. Hence, <code>c</code> and <code>d</code> remain <code>1</code>, <code>b</code> is incremented to <code>2</code>, and <code>a</code> gets assigned to <code>true</code>, which is promoted to <code>1</code>.</p>

<p><strong>Explanation:</strong></p>

<pre><code>a = b = c = d = 1;
</code></pre>

<p>All four variables equal <code>1</code>.</p>

<pre><code>a = ++b &gt; 1
</code></pre>

<p>The variable <code>b</code> gets incremented to <code>2</code> <em>before</em> the rest of the RHS gets evaluated.  This results in the expression <code>2 &gt; 1</code>, which is true.  As others have mentioned, your <code>||</code> expression is then <em>short-circuited</em>, which means that what follows the <code>||</code> will not be evaluated because the program already knows that the entire RHS will be true regardless of what happens.  This is why I did not bother to even write the expression <code>++c &gt; 1 &amp;&amp; ++d &gt; 1</code>, because it will be skipped.</p>

<p>And the variable <code>a</code> is set to true, which is the same as <code>1</code>.</p>

<p>Reference on promoting true to <code>int</code>: <a href=""https://stackoverflow.com/questions/2725044/can-i-assume-booltrue-int1-for-any-c-compiler"">Can I assume (bool)true == (int)1 for any C++ compiler?</a></p>
",0
37073317,37073316,7,"<p><a href=""http://man7.org/linux/man-pages/man2/chmod.2.html""><code>fchmod(2)</code></a> would be in keeping with your other calls... Given a file descriptor in <code>fd</code>:</p>

<pre><code>struct stat buf;
fstat(fd, &amp;buf);
fchmod(fd, buf.st_mode | S_IXUSR | S_IXGRP | S_IXOTH);
</code></pre>

<p>will add all three execute bits to the file's current mode (error handling left as an exercise for the reader).</p>

<p>You'd use <a href=""http://man7.org/linux/man-pages/man3/fileno.3.html""><code>fileno(3)</code></a> to get the file descriptor from your <code>FILE *</code> structures. Alternatively you could use <a href=""http://man7.org/linux/man-pages/man2/chmod.2.html""><code>chmod(2)</code></a> and pass it the file name.</p>
",2
37073318,37073316,0,"<p>You could use fchmod (see fchmod(3)), or umask if you want to apply the same for every file created (extracts below taken from <a href=""http://www.gnu.org/software/libc/manual/html_node/Setting-Permissions.html"" rel=""nofollow"">http://www.gnu.org/software/libc/manual/html_node/Setting-Permissions.html</a> and the <a href=""http://linux.die.net/man/2/umask"" rel=""nofollow"">umask(2) man page</a>):</p>

<p>The functions in this section are declared in sys/stat.h.</p>

<p>Function: mode_t umask (mode_t mask)</p>

<p>The umask function sets the file creation mask of the current process to mask, and returns the previous value of the file creation mask.</p>

<pre><code>Here is an example showing how to read the mask with umask without changing it permanently:

mode_t
read_umask (void)
{
  mode_t mask = umask (0);
  umask (mask);
  return mask;
}

However, on GNU/Hurd systems it is better to use getumask if you just want to read the mask value, because it is reentrant.
</code></pre>

<h3>Name</h3>

<p>umask - set file mode creation mask</p>

<p><code>mode_t umask(mode_t mask);</code></p>

<h3>Description</h3>

<p>umask() sets the calling process's file mode creation mask (umask) to mask &amp; 0777 (i.e., only the file permission bits of mask are used), and returns the previous value of the mask.</p>

<p>The umask is used by open(2), mkdir(2), and other system calls that create files to modify the permissions placed on newly created files or directories. Specifically, permissions in the umask are turned off from the mode argument to open(2) and mkdir(2).</p>

<p>The constants that should be used to specify mask are described under stat(2).</p>

<p>The typical default value for the process umask is S_IWGRP | S_IWOTH (octal 022). In the usual case where the mode argument to open(2) is specified as:</p>

<pre><code>S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH
</code></pre>

<p>(octal 0666) when creating a new file, the permissions on the resulting file will be:</p>

<pre><code>S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH
</code></pre>

<p>(because 0666 &amp; ~022 = 0644; i.e., rw-r--r--).
Return Value
This system call always succeeds and the previous value of the mask is returned</p>
",1
37073319,37073316,4,"<p><a href=""http://man7.org/linux/man-pages/man2/chmod.2.html"" rel=""nofollow""><code>chmod<b>(2)</b></code></a> <strong><em>is</em></strong> an API call,
and is the canonical way of changing the mode of a file (referenced by name)
from a program; it is not overkill.</p>
",3
43967753,9653072,3,"<pre><code>struct emp {
    int id;
    char *name;
};

struct emp get() {
    char *name = ""John"";

    struct emp e1 = {100, name};

    return (e1);
}

int main() {

    struct emp e2 = get();

    printf(""%s\n"", e2.name);
}
</code></pre>

<p>works fine with newer versions of compilers.
Just like id, content of the name gets copied to the assigned structure variable.</p>
",1
35262576,35262547,5,"<p>The format specifier <code>%ld</code> is for implicitly typecasting the <strong>numeric value</strong> to <code>long int</code>, whereas, <code>%d</code> is for <code>int</code> alone.</p>
<p><strong>Edit:</strong></p>
<p>I ran your code now, using the following data types of the variables mentioned therein:</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main()
{
 char tempStr[100];
 char year_str[5];
 char month_str[3];
 char day_str[3];
 long int tempout;
 char other[100];
 int count;

 strcpy(year_str, &quot;2016&quot;);
 strcpy(month_str ,&quot;02&quot;);
 strcpy(day_str ,&quot;08&quot;);

 sprintf(tempStr,&quot;%s%2s%s&quot;,year_str,month_str,day_str);
 count=sscanf(tempStr,&quot;%ld%s&quot;,&amp;tempout,other);

 printf(&quot;tempStr: %s\ntempout: %ld\n&quot;, tempStr,tempout);
}
</code></pre>
<p>Then only did I understand what your concern is, the output is showing:</p>
<blockquote>
<p>tempStr: 20160208<br>
tempout: 20160208</p>
</blockquote>
<p>Clearly, we can see that the problem here is in <code>sprintf</code> and not in <code>sscanf</code>.</p>
<p>The format specifier <code>%s%2s%s</code> that you have given to <code>sprintf</code> means that you want to <strong>concatenate</strong> the three strings, <code>year_str</code>, <code>month_str</code> and <code>day_str</code> namely, without any character (<strong>'/'</strong>, <strong>space</strong> or a <strong>'-'</strong>) in between them. The <code>2</code> in <code>%2s</code> only means a padding of two spaces only where it is possible.</p>
<p>This means that when <code>sscanf</code> will try to read a <code>long int</code> into <code>tempout</code> it will read <code>20160208</code> as one number doing rightly what it is meant to do.</p>
<p>You therefore have to add a character such as <code>space</code> <code>-</code> or <code>/</code> between <strong>year</strong>, <strong>month</strong> and <strong>day</strong> and everything will work fine:</p>
<pre><code>sprintf(tempStr,&quot;%s %2s %s&quot;, year_str,month_str,day_str);
</code></pre>
<p>New output now is:</p>
<blockquote>
<p>tempStr: 2016 02 08<br>
tempout: 2016</p>
</blockquote>
<p><strong>Edit2:</strong></p>
<p>If you look at the <a href=""http://linux.die.net/man/3/localtime"" rel=""nofollow noreferrer"">Man Page of localtime()</a> you will see that the ranges of the members of the <code>struct tm</code> are:</p>
<blockquote>
<p>tm_mday</p>
<p>The day of the month, in the range 1 to 31.</p>
<p>tm_mon</p>
<p>The number of months since January, in the range 0 to 11.</p>
<p>tm_year</p>
<p>The number of years since 1900.</p>
</blockquote>
<p>Which explains the addition of <code>1</code> in <code>sprintf(month_str,&quot;%02d&quot;,current_time-&gt;tm_mon + 1);</code> so similarly, <code>1900</code> should be added to <code>current_time-&gt;tm_year</code> for correct output:</p>
<pre><code>sprintf(year_str,&quot;%d&quot;,current_time-&gt;tm_year+1900);
</code></pre>
",5
39116717,39116352,2,"<p>One solution is to manually create all the init values in an enum and just use them:</p>

<pre><code>enum Init_bit {
  // etc
  i_3 = 7u, // use longer names because global space
  i_4 = 15u,
  i_5 = 31u,
  // etc
};
</code></pre>

<p>You write that once and then it becomes easy:</p>

<pre><code>X x = {/*other fields*/, i_4, /*other fields*/};
</code></pre>

<hr>

<p>Another solution I found is to init to <code>0</code> and then decrement. This is well defined because we are dealing with unsigned type. If you need to initialize you can create a function like this:</p>

<pre><code>X get_x()
{
  X x;
  x.a = 0;
  --x.a;

  return x;
}
</code></pre>

<p>With optimizations enable the compiler will direct initialize:</p>

<pre><code>get_x:
        movl    $15, %eax
        ret
</code></pre>

<p>You can then use that function for initialization:</p>

<pre><code>X x = get_x();
</code></pre>

<p>Of course this has the disadvantage that you need to init the other fields of <code>X</code> in <code>get_x</code>.</p>

<hr>

<p><em>where <code>X</code> was defined as:</em></p>

<pre><code>struct X {
  unsigned a : 4;
};

typedef struct X X;
</code></pre>

<hr>

<p>It seems that it is tricky to initialize bit fields like this without warnings (gcc 6.1):</p>

<pre><code>X x = {-1};
//!!warning: negative integer implicitly converted to unsigned type [-Wsign-conversion]

X x = {-1u};
//!!warning: large integer implicitly truncated to unsigned type [-Woverflow]

X x = {(unsigned)-1};
//!!warning: large integer implicitly truncated to unsigned type [-Woverflow]

X x = {~0};
//!!warning: negative integer implicitly converted to unsigned type [-Wsign-conversion]

X x = {~0u};
//!!warning: large integer implicitly truncated to unsigned type [-Woverflow]
</code></pre>
",2
39117156,39116352,0,"<p>If you use bitfields, then their size is known at compile time and is known to the programmer. </p>

<p>Therefore initialization can be done by simply using the maximum value, which has all bits set to one.</p>

<p>To avoid repeating yourself, a macro containing the max value for that type should be used. Just like UINT_MAX holds the maximum value for type unsigned int, you define your own type. For example, a unsigned bitfield of width 7:</p>

<pre><code>#define UBIT7_MAX 0x7F
</code></pre>
",0
39117718,39116352,1,"<p>You can use memset </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

struct bitfields {
    unsigned int a : 1;
    unsigned int b : 2;
    unsigned int c : 5;
};

int main(void) {
    struct bitfields x;
    memset(&amp;x,0xff, sizeof(x));
    printf(""a=%u; b=%u, c=%u\n"", x.a, x.b, x.c);
    return 0;
}
</code></pre>
",0
39126101,39116352,0,"<blockquote>
  <p>If I use -1 I get a warning that I am assigning signed to unsigned variable.</p>
</blockquote>

<p>Use an <em>unsigned</em> constant by appending a <code>u</code>.  The <code>-</code> does not change the type of the constant.</p>

<pre><code>// to initialize a unsigned field in bitfield with 0xfff.
struct {
  unsigned u:7;
} x = {-1u};
</code></pre>

<p>Alternatively</p>

<pre><code>int main(void) {
  typedef struct {
    unsigned u :7;
  } useven;
  useven z = { 0 };
  z.u--;
  useven x = { z.u };  // No warnings/errors - set to all 1 bits.
  printf(""%X\n"", x.u); // Prints 7F
}
</code></pre>

<p>This may generate a warning like ""warning: large integer implicitly truncated to unsigned type"" but it does get rid of the warning in OP's post.</p>

<p>If your bitfield is wider than <code>unsigned</code>, use <code>-1lu</code>, etc.  Note: using bitfields wider than <code>int/unsigned</code> is not universally supported.  Do not recommend.</p>
",0
47478954,47477239,-1,"<p>Take <code>dimension</code> as integer first, then take whole input as a string. Then check if the string has exact number of inputs by using <code>strtok</code>.</p>

<p>here is the code:</p>

<pre><code>//after the dimension is scanned and verified successfully.
 char input[200];
 char *token;
 char temp;

 fflush(stdin);
 scanf(""%199[0-9 ]"",&amp;input[0]);
 // take all inputs as a string.    

 token = strtok(input, "" "");
 while( token != NULL )
 {
      top++;
      mat[top] = atoi(token);

      token = strtok(NULL, "" "");

 }

if(top &lt; dimension * dimension -1)
{
    printf(""Not enough inputs.!"");
}
else if(top &gt; dimension * dimension -1)
{
    printf(""input limit exceeded"");
}
else
{
    // Input is correct.!

    //  . . .
}
</code></pre>
",5
47532933,47532364,0,"<p><code>scanf</code> is difficult to use if you want a very strict validation of the input typed by the user.</p>

<p>Instead you could you use <code>getc</code> to read the input char-by-char and do the validation and value calculation yourself.</p>

<p>Another approach could be <code>fgets</code> combined with <code>sscanf</code>. That could be something like:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define MAX_LEN 8

int main(void) {
  char str[MAX_LEN];
  int d, n;

  int flag = 0;                    // Assume it isn't an int

  if (fgets(str, MAX_LEN, stdin))  // Read into str
  {
    size_t l = strlen(str);
    if (l &gt; 0)                     // Check that we did read something
    {
      if (str[l-1] == '\n')        // Last char must be new line
      {
        if (sscanf(str,""%d%n"", &amp;d, &amp;n) == 1)  // Try to scan the str into an int
        {
          if (n == l-1)            // Check that all chars was used
          {
            flag = 1;              // It is an int so set the flag
          }
        }
      }
    }
  }

  if (flag)
  {
    printf(""%d\n"", d);
  }
  else
  {
    printf(""Not an int\n"");
  }
  return 0;
}
</code></pre>
",0
41402514,41402484,12,"<pre><code>str1[0] = ""b"";
</code></pre>

<p>Here, <code>""b""</code> is a string literal, <em>not</em> a character. Characters are enclosed in single quotes:</p>

<pre><code>str1[0] = 'b';
</code></pre>

<p>If you had compiler warnings enabled you'd get something like:</p>

<blockquote>
  <p>warning: incompatible pointer to integer conversion assigning to 'char' from 'char [2]' [-Wint-conversion]</p>

<pre><code>str1[0] = ""b"";
        ^ ~~~
</code></pre>
</blockquote>

<hr>

<p>In your second code, your string is missing a terminating <a href=""https://en.wikipedia.org/wiki/Null_character"" rel=""nofollow noreferrer"">null-character</a>, and so passing it to <code>printf</code> invokes undefined behavior because <code>printf</code> can't know where your string ends. To append the null-character at the end, just do:</p>

<pre><code>str1[5] = '\0';
</code></pre>
",2
41402553,41402484,3,"<p>In C, single quotes identify chars and double quotes create a string literal.</p>

<p>Try doing the following: </p>

<pre><code>str1[0] = 'b'; //note the single quote
</code></pre>
",0
42571318,42570629,0,"<p>The simplest alternative I can think of right now is - </p>

<pre><code>int i;
for (i = 0; label[i] != '\0'; i++)
    printf(""%02x"", (int)label[i]);
printf(""\n"");
</code></pre>

<p>This should give exactly what you want. Also any representation issues shouldn't come in.</p>
",0
42571318,42570629,0,"<p>The simplest alternative I can think of right now is - </p>

<pre><code>int i;
for (i = 0; label[i] != '\0'; i++)
    printf(""%02x"", (int)label[i]);
printf(""\n"");
</code></pre>

<p>This should give exactly what you want. Also any representation issues shouldn't come in.</p>
",0
41679144,41679086,5,"<p>Yes. In general, the order of ""typey words"" at the beginning of a declaration doesn't matter:</p>

<pre><code>static const unsigned long int x = 42;
</code></pre>

<p>is the same as</p>

<pre><code>long const int unsigned static x = 42;
</code></pre>

<p>Reference: C99, 6.7.2/2</p>

<blockquote>
  <p>[...] the type specifiers may occur in any order, possibly
  intermixed with the other declaration specifiers.</p>
</blockquote>

<p>(Both <code>float</code> and <code>_Complex</code> are type specifiers.)</p>
",2
41679314,41679086,7,"<p><code>complex</code> is a macro from complex.h which expands into the type specifier <code>_Complex</code>. This behaves as all other type specifiers, for example <code>int, bool, double</code>. For all type specifiers belonging to the same ""group"", you can combine them in various orders. This is specified by C11 6.7.2, emphasis mine:</p>

<blockquote>
  <p><strong>At least one type specifier shall be given in the declaration
  specifiers in each declaration</strong>, and in the specifier-qualifier list in
  each struct declaration and type name. Each list of type specifiers
  shall be one of the following multisets (delimited by commas, when
  there is more than one multiset per item); <strong>the type specifiers may
  occur in any order</strong>, possibly intermixed with the other declaration
  specifiers.</p>
</blockquote>

<p>Then follows a list of valid groups of type specifiers, where we find</p>

<blockquote>
  <ul>
  <li><code>float _Complex</code>  </li>
  <li><code>double _Complex</code></li>
  </ul>
</blockquote>

<p>Meaning that any permutation of the specifiers in the same group is fine.</p>

<hr>

<p>To take another example, there is a group</p>

<blockquote>
  <ul>
  <li><code>unsigned long long</code>, or <code>unsigned long long int</code></li>
  </ul>
</blockquote>

<p>Which gives us the following possible combinations:</p>

<pre><code>unsigned long long x;
long unsigned long y;
long long unsigned z;
</code></pre>

<p>or</p>

<pre><code>unsigned long long int a;
unsigned long int long b;
unsigned int long long c;
int unsigned long long d;
long unsigned long int e;
long long unsigned int f;
long long int unsigned g;
long unsigned int long h;
...
</code></pre>

<p>These all mean the same thing. </p>
",2
36345560,36345526,0,"<p>fgets includes a '/n' before nul char.</p>
<p>So when you reverse a string, the first thing you do is print it.</p>
<hr />
<p>My ugly fix is:</p>
<p>replace the fist printf with</p>
<pre><code>printf(&quot;%s\n&quot;, sr+1);
</code></pre>
<p>remove the second one.</p>
<hr />
<p>And remember, when all fails, read the manual.:</p>
<blockquote>
<p>fgets() reads in at most one less than size characters from stream  and
stores  them  into  the buffer pointed to by s.</p>
<p>Reading stops after an EOF or a newline.  <strong>If a newline is read, it is stored into the  buffer.</strong></p>
<p>A  terminating  null  byte ('\0') is stored after the last character in the buffer.</p>
</blockquote>
",0
47988837,12331328,1,"<p>I am adding this answer to specify the rules of the standard. </p>

<p>Here this is utilizing the return value of <code>printf</code>. Respectively <code>3-1</code> spaces(<code>' '</code>) and then again space (as you specified) and  <code>4-1</code> spaces and then again 1 space is being printed. And then the total number of characters written is returned. That is how the sum is being done. </p>

<p>I just remember this rule </p>

<pre><code>printf(""%*c"",X,C) prints the char C in a field of size X
</code></pre>

<p>All these behavior is explained in C11 Standard.</p>

<p>From standard <strong><a href=""http://port70.net/~nsz/c/c11/n1570.html#7.21.6.1p4"" rel=""nofollow noreferrer""> ¡ì7.21.6.1p4</a></strong></p>

<blockquote>
  <p>An optional minimum field width. <strong><em>If the converted value has fewer
  characters than the field width, it is padded with spaces (by default)</em></strong>
  on the left (or right, if the left adjustment flag, described later,
  has been given) to the field width. <em>The field width takes the form of
  an asterisk <code>*</code> (described later) or a nonnegative decimal integer.</em></p>
</blockquote>

<p>And in the same section <strong><a href=""http://port70.net/~nsz/c/c11/n1570.html#7.21.6.1p5"" rel=""nofollow noreferrer""> ¡ì7.21.6.1p5</a></strong></p>

<blockquote>
  <p>As noted above, <strong><em>a field width, or precision, or both, may be
  indicated by an asterisk. In this case, an int argument supplies the
  field width or precision</em></strong></p>
</blockquote>

<p>At last <a href=""http://port70.net/~nsz/c/c11/n1570.html#7.21.6.1p14"" rel=""nofollow noreferrer""><strong>¡ì7.21.6.1.p14</strong></a></p>

<blockquote>
  <p><strong><em>The <code>fprintf</code> function returns the number of characters transmitted</em></strong>, or
  a negative value if an output or encoding error occurred.</p>
</blockquote>

<hr>

<p>To clear your idea this example will be good enough (I am using <code>%d</code> here so that you get the idea of the field).</p>

<p>If <code>x = 10</code> and <code>y=2</code> then it will be</p>

<pre><code>printf(""%*d%*d"",  x, x,  y, y);
</code></pre>

<p>More clearly</p>

<pre><code>| | | | | | | | |1|0| |2|
 1 2 3 4 5 6 7 8 9 10 \ \
                      11 12

That's how 12 characters are printed.
</code></pre>
",0
35258567,25289526,0,"<p>Dont work the left diagonal check, I try this code:</p>

<pre><code>//checks left diagonal win
    for(i=0;i&lt;sizeWidth-3;i++)
        for(j=3;j&lt;sizeHeight;j++)
            if(board[i][j] != 0 &amp;&amp; board[i][j]==board[i+1][j-1] &amp;&amp; board[i][j]==board[i+2][j-2] &amp;&amp; board[i][j]==board[i+3][j-3])
                printf(""\n4"");
</code></pre>

<p>Because the varible j is decremented, so you have to inicialize j to 3 and remove sizeHeight-3 in the condition.</p>
",0
36834837,36834709,9,"<p>They are different, <code>void foo(void)</code> declares <code>foo</code> as a function that takes NO argument, and returns nothing.</p>

<p>While for <code>void foo()</code>, the function <code>foo</code> takes UNSPECIFIED number of arguments, and returns void.</p>

<p>You should always use the first one for standard conforming C.</p>
",6
36834845,36834709,3,"<p>Yes, there is a difference. It is better to define functions like <code>void foo(void){}</code> cause it will prevent passing any arguments to function in compilation time with error like:<code>too many arguments to function 'foo'</code></p>

<p><strong>EDIT</strong>: If you want to add such compiler's validation for existing code, this probably can be done changing prototypes in the headers. Without changing the function definitions. But it looks awkward IMHO. So for newly created programs (as pointed by skillful commentators above) it's better to make definition and declaration <strong>match verbose</strong>, and this is bad and ancient practice to declare and define with empty parentheses</p>
",1
36836023,36834709,5,"<h1>They are semantically different</h1>

<p>Given the following functions:</p>

<pre><code>void f(void);
void g();
</code></pre>

<p>It is a compile-time error to call <code>f</code> with arguments:</p>

<pre><code>error: too many arguments to function ""f""
</code></pre>

<p>However, that declaration of <code>g</code> means it takes an <em>unspecified</em> number of arguments. To the compiler, this means it can take any number of arguments, from zero to some implementation-defined upper bound. The compiler will accept:</p>

<pre><code>g();
g(argument);
g(argument1, argument2, ... , argumentN);
</code></pre>

<p>Essentially, because <code>g</code> did not <em>specify</em> its arguments, the compiler doesn't really know how many arguments <code>g</code> accepts. So the compiler will accept anything and emit code according to the actual usage of <code>g</code>. If you pass one argument, it will emit code to push one argument, call <code>g</code> and then pop it off the stack.</p>

<p>It's the difference between explicitly saying ""no, I don't take any arguments"" and not saying anything when questioned. Remaining silent keeps the issue ambiguous, to the point where the statement which calls <code>g</code> is the only concrete information the compiler has regarding which parameters the function accepts. So, it will emit machine code according to <em>that</em> specification.</p>

<h1>Recommendations</h1>

<blockquote>
  <p>which way should I actually use?</p>
</blockquote>

<p><a href=""https://www.securecoding.cert.org/confluence/display/c/DCL20-C.+Explicitly+specify+void+when+a+function+accepts+no+arguments"" rel=""nofollow noreferrer"">According to the SEI CERT C Coding Standard</a>, it is recommended to <em>explicitly specify <code>void</code> when a function accepts no arguments.</em></p>

<p>The article cites, as the basis of its recommendation, the C11 standard, subclause 6.11.6:</p>

<blockquote>
  <p>The use of function declarators with empty parentheses
  (not prototype-format parameter type declarators)
  is an obsolescent feature.</p>
</blockquote>

<p>Declaring a function with an unspecified parameter list is classified as medium severity. Concrete examples of problems that may arise are presented. Namely:</p>

<ol>
<li>Ambiguous Interface

<ul>
<li>Compiler will not perform checks</li>
<li>May hide errors</li>
</ul></li>
<li>Information Outflow

<ul>
<li>Potential security flaw</li>
</ul></li>
</ol>

<p><a href=""https://security.stackexchange.com/q/43042/9252"">Information Security has a post</a> exploring not just the security but also the programming and software development implications of both styles.</p>

<blockquote>
  <p><strong>The issue is more about quality assurance.</strong>
  Old-style declarations are dangerous, not because of evil programmers,
  but because of human programmers, who cannot think of everything
  and must be helped by compiler warnings. That's all the point of function
  prototypes, introduced in ANSI C, which include type information for
  the function parameters.</p>
</blockquote>
",1
44359306,44359144,-1,"<p>There is absolutely no benefit, because both things are very similar. In C an array can be considered as the pointer to the first element of the array (Inside of the scope of the function where the array is declared the compiler is also aware of the size of the array, so there is some different behavior between the 2, although not in your examples). A char array is a pointer to the first element in the array, notice how there is no type casting when he does:</p>

<pre><code>char * pMovie = movie;
</code></pre>

<p>There is no need to type cast because these 2 variables are considered to be the same type (char *) by the compiler.</p>

<p>A similar way to create an array is:</p>

<pre><code>char *test = (char*)malloc(sizeof(char)*size_of_array);
</code></pre>

<p>I am assuming your teacher is trying to make you familiar with this concept (that arrays in C are similar to pointers and vice-versa)</p>
",9
40769582,40769383,1,"<blockquote>
  <p>I am trying to reverse a string in c but i get segmentation</p>
</blockquote>

<p><code>strcpy()</code> is used to copy a string into destination string. So the arguments are <code>char*</code> and <code>const char*</code>. But here in your code you are sending a <code>char</code> as the second argument of <code>strcpy()</code> function.</p>

<p>You need not use <code>strcpy()</code> function at all for reversing the string, just a <code>for</code> loop is enough to achieve reversing the string.</p>

<p>Example for <code>for</code> loop:</p>

<pre><code>for (i = 0; i &lt;= lenstr; i++) 
{ 
    revstr[i] = inputstr[lenstr - i]; 
} 
revstr[i] = '\0';
</code></pre>
",0
40769722,40769383,-1,"<p>what should do strcpy()?</p>

<p>Here my version of reverse:</p>

<pre><code>void reverse(char * s, int len)
{
    char c,*end =s+len-1;
    while (s&lt;end)
    {
       c=*s;
       *s++=*end;
       *end--=c;
     }
}
</code></pre>

<p>With XOR  you can avoid to declare the temporary c variable... but it is not redeable, and I am quite curious to know if gives some performances improvments... I choosed to pass the len, rather than compute it inside, since you can reverse also substrings, or because the length is already availabe</p>
",1
45725708,45725654,1,"<p>I think <code>fwrite</code> is working fine.  Change the declaration of <code>temp</code> so the type is an array of one-byte unsigned characters:</p>

<pre><code>unsigned char temp [100] = {0} ;
</code></pre>

<p>The current version of the code displays a four-byte integer each time in the print statement.  This will confirm that the contents of the file are as you expect.  On my machine:</p>

<pre><code>0x1,0,0,0,0x2,0,0,0,0x3,0,0,0,0x4,0,0,0,0x5,0,0,0,0x6,0,0,0,0x7,0,0,0,0x8,0,0,0,0x9,0,0,0,0xa,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
</code></pre>
",1
42645487,42645455,2,"<p>You have the statements :</p>

<pre><code>int i,j,temp;
int card[i];
</code></pre>

<p>but you have not initialized <code>i</code>. Therefore, you do not know how many elements array <code>card</code> will have and the behaviour of your program will be <em>undefined</em>, probably leading to segmentation fault. If you want your array to have <code>52</code> elements, initialize i to :</p>

<pre><code>int i = 52;
</code></pre>

<p>and then declare :</p>

<pre><code>int card[i];
</code></pre>

<p><strong><em>But actually</em></strong>, the array you want to shuffle is the global array <code>struct Cards card[52]</code> , and not the array <code>cards</code> defined inside <code>shuffle</code> (see <a href=""https://www.tutorialspoint.com/cplusplus/cpp_variable_scope.htm"" rel=""nofollow noreferrer"">this link</a> on variables' scope). So try removing the following lines of code :</p>

<pre><code>int card[i];
for (i=0;i&lt;52;i++)
{
   card[i] = i + 1;
}
</code></pre>

<p>and see if the results are what you expected.</p>
",5
42645759,42645455,0,"<p>In addition to the answer already given, in order to randomize pack of cards, please observe following:
In function 'shuffle', you have created a local array 'card'; which eclipses global array 'card' of type 'struct Cards'.
What you need to do is use global 'card' in your shuffle function instead of local 'card'.
Local int array 'card' has life and visibility only inside shuffle().</p>

<p>HTH, Swanand</p>
",1
42645941,42645455,1,"<p>There are many problems with this code.</p>

<p>As Marievi says, this line </p>

<pre><code>int card[i];
</code></pre>

<p>should be </p>

<pre><code>int card[52];
</code></pre>

<p>because i is uninitialised at that point (you would have caught the error if you had compiled with lots of warnings enabled. If you are using gcc, compile with <code>-Wall</code>.</p>

<p>This line</p>

<pre><code>j = (rand()%51) + 1;
</code></pre>

<p>actually gives you a pseudo random number between 1 and 51 inclusive, not 0 and 51 inclusive, which I think is what you want because it should be an index into the array.</p>

<p>Most importantly, the array you are shuffling is not the array with the cards in it. The line that should be <code>int card[52];</code> defines a new local array that exists only until the function returns and is then thrown away. It ""shadows"" your global card array for the duration of the function. If you delete it and get rid of the </p>

<pre><code>for (i=0;i&lt;52;i++)
{
   card[i] = i + 1;
}
</code></pre>

<p>you'll find your global card array is shuffled.</p>

<p>One more thing: you don't need to putthe colour of your cards in the <code>Card</code> struct. The colour is encoded by the suit. Hearts and diamonds are red; clubs and spades are black.</p>
",4
34933704,34933661,4,"<p>Please instead of trying to read the unreadable, make it readable and enjoy</p>

<pre><code>if (2 &lt; 1);
else 
    x = (2 &lt; 0) ? printf(""one"") : printf(""four"");
printf(""%d"", x);
</code></pre>

<p>Of course <code>2 &lt; 1</code> is false, and <code>2 &lt; 0</code> is false again so the return value of <code>printf(""four"")</code> which is <code>4</code> because <code>""four""</code> has 4 characters is assigned to <code>""x""</code>.</p>

<p>So the output should be</p>

<pre><code>four4
</code></pre>
",6
34933724,34933661,3,"<p>Function <code>printf</code> returns the number of printed characters.</p>

<p>Because in this conditional operator</p>

<pre><code> (2&lt;0)?printf(""one""):printf(""four"")
</code></pre>

<p>the condition <code>(2&lt;0)</code> is false this expression <code>printf(""four"")</code> is evaluated and its value is equal to 4 - the number of the outputed characters.</p>

<p>From the description of function <code>printf</code> (the C Standard, 7.21.6.3 The printf function)</p>

<blockquote>
  <p>3 The printf function <strong>returns the number of characters
  transmitted</strong>, or a negative value if an output or encoding error
  occurred.</p>
</blockquote>

<p>I think that the reason of the confusion is the assignment operator before the 
conditional operator. However the assignment operator has lower priority compared with the conditional operator. So in fact you have</p>

<pre><code> else x = ( (2&lt;0) ? printf(""one"") : printf(""four"") );
</code></pre>
",2
39003283,39003181,3,"<pre><code> a[i] = b[i] = c[i] = 0;
</code></pre>

<p>is parsed as:</p>

<pre><code> a[i] = (b[i] = (c[i] = 0));
</code></pre>

<p>and has the same effect as:</p>

<pre><code> a[i] = 0;
 b[i] = 0;
 c[i] = 0;
</code></pre>
",12
39004525,39003181,0,"<p>The processing of above code goes as follows ...</p>

<p>First <code>0</code> is assigned to <code>c[i]</code> and then value of <code>c[i]</code> is assigned to <code>b[i]</code> and then the value of <code>b[i]</code> is assigned to <code>a[i]</code>.</p>

<p>So,overall to clear your concept,u should keep in mind from now that such assignment statements are evaluated from <code>right to left</code>.</p>
",2
40964437,40964353,6,"<p>First off, <code>ptrdiff_t</code> is a signed type (the difference between two pointers can be negative), so that rules out <code>unsigned long long</code>.</p>

<p>An array subscript can be any integer type, but the resulting value has to be in bounds. For example, on a 32-bit platform you can't have an array with more than about 4 billion elements, so <code>ptrdiff_t</code> is likely going to be a 32-bit integer type. Indexing an array with a <code>long long</code> value that exceeds 32 bits just causes undefined behavior (ouf of bounds access).</p>

<p>As usual, the real reason is backwards compatibility: <code>long long</code> was added to the language long after <code>ptrdiff_t</code>, and <code>ptrdiff_t</code> was added after compilers were already written. It wouldn't make sense to specify completely different rules for pointer arithmetic (such as ""subtracting two pointers must yield a 64+ bit result"") when there's existing code relying on (decades old) behavior.</p>
",2
40964442,40964353,0,"<p>You are wrong. <code>ptrdiff_t</code> can be an alias for <code>long long int</code>. It depends on the used system and the size of the address registers.</p>

<p>So an array can not be larger than the value that can be stored in an address register.</p>

<p>There is another problem that can lead to undefined behavior.</p>

<p>The problem is that the difference of two pointers can be a negative number. Thus you can not use an unsigned number as the result. Moreover the index also can be negative. For example consider the following code snippet</p>

<pre><code>const char *s = ""aabbcc"";
size_t n = 0;

for ( const char *p = s; *p++; )
{
    if ( p[0] == p[-1] ) ++n;
}
</code></pre>

<p>It is a valid code. </p>

<p>So the pointer arithmetic needs signed numbers.</p>

<p>On the other hand the size of an object is determinate by the type <code>size_t</code> that can be as large as the type <code>unsigned long long</code>. </p>

<p>The problem is that the range of non-negative values of any signed integral type is not greater than the range of non-negative values of the unsigned type with the same rank. And absolute addresses stored in registers are non-negative numbers.</p>
",1
46108049,46107991,0,"<p>You are using wrong variable:</p>

<pre><code>memcpy(value + 2, &amp;num, value_length);
</code></pre>

<p>Also, you must not trait your value as string, as far as it uses binary value. Change your code to:</p>

<pre><code>    /* expectation: 0x02 0x01 0x4f */
    int dumplen=len+2;
    for (int i = 0; i &lt; dumplen; i++)
        printf(""%02x\n"", value[i]);
    return 0;
</code></pre>
",3
46108067,46107991,1,"<pre><code>memcpy(value + 2, &amp;value_value, value_length);
</code></pre>

<p>this expression copies <code>value_length</code> bytes from <code>&amp;value_value</code>.</p>

<p>Given that it's declared as</p>

<pre><code>char *value_value
</code></pre>

<p><code>&amp;value_value</code> is read as a <code>pointer-to-a-pointer-to-a-char</code>. So effectively you're reading the pointer value.</p>

<p>How to solve:</p>

<pre><code>memcpy(value + 2, &amp;num, value_length);
</code></pre>

<p>Another problem with your code:</p>

<p>you're using <code>strlen(value)</code> while <code>value</code> is not a null-terminated C-string. It's just an array of bytes that you fill with your data.</p>

<p>How to fix:</p>

<p>don't use <code>strlen</code> in this case, you know the size of the array: <code>2 + value_length</code>. For clarity you may put it to a separate variable.</p>
",0
38286128,38167373,0,"<p>Here an example:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define MAXSTR 50
#define MAXEMPLOYEES 100

typedef struct {
    char name[MAXSTR];
    char designation[MAXSTR];
    float salary;
} Employee;

typedef struct {
    Employee employeesArray[MAXEMPLOYEES];
    int count;
} Employees;

void initEmployees(Employees*);
Employee readEmployee();
void addEmployee(Employees*, Employee);
void showAllEmployees(Employees);

int main()
{
    int choice;
    Employee newEmployee;
    Employees employeesArchive;
    initEmployees(&amp;employeesArchive);

    do{
        printf(""1. Add new Employee.\n"");
        printf(""2. Show all Records.\n"");
        printf(""0. Exit.\n"");
        printf(""Select: "");
        scanf(""%d"", &amp;choice);

        switch(choice){
        case 1:
            newEmployee = readEmployee();
            addEmployee(&amp;employeesArchive, newEmployee);
            break;

        case 2:
            showAllEmployees(employeesArchive);
            break;
        }
     }while(choice!=0);

    return 0;
}

void initEmployees(Employees *_employees){
    _employees-&gt;count = 0;
}

Employee readEmployee(){
    Employee _newEmployee;

    printf(""NEW RECORD\n"");
    printf(""-&gt; Name: "");
    scanf(""%s"", _newEmployee.name);
    printf(""-&gt; Designation: "");
    scanf(""%s"", _newEmployee.designation);
    printf(""-&gt; Salary: "");
    scanf(""%f"", &amp;_newEmployee.salary);

    return _newEmployee;
 }

void addEmployee(Employees *_employees, Employee _newEmployee){
    int index;
    index = _employees-&gt;count;

    strcpy(_employees-&gt;employeesArray[index].name, _newEmployee.name);
    strcpy(_employees-&gt;employeesArray[index].designation, _newEmployee.designation);
    _employees-&gt;employeesArray[index].salary = _newEmployee.salary;

    _employees-&gt;count++;
    printf(""New Employee correctly added!\n"");
    system(""pause"");
}

void showAllEmployees(Employees _employees){
    int i, allRecords;
    allRecords = _employees.count;
    for(i=0; i&lt;allRecords; i++){
        printf(""#%d\nName: %s\tDesignation: %s\tSalary: %f\n"",
           i+1,
           _employees.employeesArray[i].name,
           _employees.employeesArray[i].designation,
           _employees.employeesArray[i].salary);
        printf(""\n"");
    }
}
</code></pre>
",0
39678184,39677149,1,"<blockquote>
  <p>what did I do wrong?</p>
</blockquote>

<p><strong>You are sending in the wrong arguments to <a href=""https://www.tutorialspoint.com/c_standard_library/c_function_strcmp.htm"" rel=""nofollow""><code>strcmp()</code></a> function</strong>. <em>and also you are</em> <strong>Accessing an array out of bounds</strong>. </p>

<p>I think you have a misunderstanding of what the <a href=""https://www.tutorialspoint.com/c_standard_library/c_function_strcmp.htm"" rel=""nofollow""><code>strcmp()</code></a> function does. It does not compare two characters but instead, it compare two strings(character arrays with null terminating character).</p>

<p>If you just want to compare two strings then no function is required, just use the <code>==</code> operator this way:</p>

<pre><code>ret = (str1 == str2[2]);

if (ret == 1) 
{
   printf(""The are equal"");
} 
else 
{
  printf(""They are not equal"");
}
</code></pre>

<hr>

<p>So now, <strong>when to use the <code>strcmp()</code> function?</strong></p>

<p>Use it when you want to compare two(character arrays which end with null terminating character) strings this way:</p>

<pre><code>char str1[10] = { 'a', 'b', 'c', '\0'};
char str2[10] = ""abc"";    //here automatically null character is provided at the end
int ret;

ret = strcmp(str1 ,str2);

if (ret == 0) 
{
   printf(""The are equal"");
} 
else 
{
  printf(""They are not equal"");
}
</code></pre>
",0
46979278,19671001,0,"<blockquote>
  <p>How can we check if an input string is a valid double?</p>
</blockquote>

<p>Start with<br>
<code>strtod()</code> for <code>double</code>,<br>
<code>strtof()</code> for <code>float</code> and<br>
<code>strtold()</code> for <code>long double</code>.</p>

<pre><code>double strtod(const char * restrict nptr, char ** restrict endptr);
</code></pre>

<blockquote>
  <p>The <code>strtod</code>, ... functions convert the initial portion of the string pointed to by <code>nptr</code> to <code>double</code> ....  </p>
  
  <p>A pointer to the final string is stored in the object pointed to by <code>endptr</code>, provided that <code>endptr</code> is not a null pointer.  </p>
  
  <p>C11dr ¡ì7.22.1.3 2&amp;5</p>
</blockquote>

<p>Simplified code to check loosely for validity.  Does not complain about over/underflow nor extra text.</p>

<pre><code>// Return true on valid
bool valid_string_to_double(const char *s) {
  char *end;
  strtod(s, &amp;end);
  return s != end;
}
</code></pre>

<hr>

<p>Challenges of using <code>strto*()</code> include: <code>errno == RANGE</code> on arithmetic overflow and <em>maybe</em> <a href=""https://en.wikipedia.org/wiki/Arithmetic_underflow"" rel=""nofollow noreferrer"">underflow</a>.   The return value on overflow is only specified in default rounding mode. That value is <code>HUGE_VAL</code> which may be an infinity or a great number.  The return value on underflow is implementation defined.  <code>errno</code> has been known to be set to other non-zero values on conditions not specified by the C spec.  Leading white-space is allowed, trailing white-space is not considered.</p>

<hr>

<p>Sample function that looks for 1) conversion, 2) extra space, 3) over/underflow.  It not only returns a valid indication, it also addresses the value of the conversion and the state of <code>errno</code> afterward.</p>

<pre><code>// Return 0 on success
// Return non-0 on error, adjust these values as needed - maybe as an `enum`?
int convert_string_to_double(double *y, const char *s) {
  char *end;
  errno = 0;
  *y = strtod(s, &amp;end);

  if (s == end) {
    return 1; // Failed: No conversion, *y will be 0
  }

  // This may/may not constitute an error - adjust per coding goals
  // Too great or too small (yet not exactly 0.0)
  if (errno == ERANGE) {
    if (fabs(*y) &gt; 1.0) {
      return 2; // Overflow
    }

    // In the case of too small, errno _may_ be set. See ¡ì7.22.1.3 10.
    // For high consistency, return 0.0 and/or clear errno and/or return success.
    // *y = 0.0; errno = 0; 
  }

  // What to do if the remainder of the string is not \0?
  // Since leading whitespace is allowed, 
  // let code be generous and tolerate trailing whitespace too.
  while (isspace((unsigned char) *end)) {
    end++;
  }
  if (*end) {
    return 3; // Failed: Extra non-white-space junk at the end.
  }

  return 0;  // success
}
</code></pre>

<hr>

<blockquote>
  <p>If the result underflows (7.12.1), the functions return a value whose magnitude is no greater than the smallest normalized positive number in the return type; whether <code>errno</code> acquires the value <code>ERANGE</code> is implementation-defined.  C11dr ¡ì7.22.1.3 10</p>
</blockquote>

<hr>

<p>A consideration includes the value of <code>errno</code> after this function is done.  The C spec only species <code>errno == ERANGE</code> for <code>strtod()</code>, yet various implementations have been known to set <code>errno</code> to other values for other reasons including ""no conversion"". Code could clear <code>errno</code> except when <code>ERANGE</code> for high consistency.</p>
",0
39688653,39688609,6,"<p><code>pow(x, y)</code> is normally implemented as <code>exp(y log x)</code>. This can go off for even seemingly trivial values of the arguments.</p>

<p>You are seeing the effect of this.</p>

<p>There's no hard and fast rule for dealing with floating point precision issues. Comparing with a tolerance is often mooted as a solution but picking the level of tolerance or the way it ought to be applied is not in itself trivial.</p>

<p>In your case it would be best to compare <code>a * a + b * b</code> with <code>c * c;</code> particularly if these are always integral values.</p>
",0
46961481,46960755,0,"<p>Your representation of polynomials is impractical:</p>

<ul>
<li><p>you iterate in 2 nested loops (quadratic complexity) to try and match the corresponding terms of both polynomials, but if the second has a power that the first does not have, it will be missing in the sum.</p></li>
<li><p>you pass the degree as a global variable <code>dataSize</code> that may have an inappropriate value.</p></li>
</ul>

<p>You should instead use an array of coefficients for all exponents from <code>0</code> to the degree of the polynomial and pass the destination polynomial and its degree this way:</p>

<pre><code>/* add 2 polynomials into a destination array.
 * count variables are the sizes of the arrays,
 *   ie 1 more than the degree of the polynomials.
 * return the size of the resulting polynomial,
 *   potentially larger than the size of the destination array.
 */
int add_polynomials(int dest[], int dest_count,
                    const int co1[], int count1,
                    const int co2[], int count2) {
    /* compute the result coefficients */
    int i, count;
    for (i = count = 0; i &lt; dest_count; i++) {
        int coef = 0;
        if (i &lt; count1)
            coef += co1[i];
        if (i &lt; count2)
            coef += co2[i];
        dest[i] = coef;
        if (coef != 0)
            count = i + 1;
    }
    /* determine the result count */
    for (; i &lt; count1 &amp;&amp; i &lt; count2; i++) {
        if (co1[i] + co2[i] != 0)
            count = i + 1;
    }
    for (; i &lt; count1; i++) {
        if (co1[i] != 0)
            count = i + 1;
    }
    for (; i &lt; count2; i++) {
        if (co2[i] != 0)
            count = i + 1;
    }
    return count;
}
</code></pre>

<p>If you must use the given prototype and global definition for <code>dataSize</code>, you could use 2 nested loops indeed, but depending on how the exponents are used in both polynomials, it might be impossible to fit the result in the destination array:</p>

<ul>
<li><p>the source polynomials can each have up to <code>dataSize</code> terms with any range of exponents.  The resulting polynomial might have a total number of terms that exceeds <code>dataSize</code> and thus not representable in an array of size <code>dataSize</code>.</p></li>
<li><p>your code fails because you wrote <code>co1[i] = co1[i] + co2[i];</code> instead of <code>co1[i] = co1[i] + co2[j];</code>, but you also modify <code>co2[i]</code>, which is inappropriate and you miss the terms that are only present in <code>co2</code>/<code>ex2</code>.</p></li>
</ul>

<p>If we can assume that the maximum exponent is less than <code>dataSize</code>, here is an efficient approach (linear time) that will generate a result in normalized form:</p>

<pre><code>#define dataSize  50

// co = coefficients, ex = exponents
void add_polynom(int co1[], int ex1[], int co2[], int ex2[]) {
    int res[dataSize] = { 0 };
    int i, j;
    for (i = 0; i &lt; dataSize; i++) {
        res[ex1[i]] += co1[i];
        res[ex2[i]] += co2[i];
    }
    j = 0;
    for (i = dataSize; i-- &gt; 0;) {
        if (res[i] != 0) {
            co1[j] = res[i];
            ex1[j] = i;
            j++;
        }
    }
    while (j &lt; dataSize) {
        co1[j] = ex1[j] = 0;
    }
}
</code></pre>
",12
46961180,46960755,0,"<p>Take for example say <code>7x^3 + 2x + 1</code> as first and <code>5x^4 + 9x^2</code> as second polynomial. Now <code>dataSize</code> becomes 5(since higher degree of both is 4).</p>

<p>Now <code>co1</code> would be {1, 2, 0, 7, 0} and <code>co2</code> would be {0, 0, 9, 0, 5}.</p>

<pre><code>       for (i = 0; i &lt; dataSize; i++)
       {
            co1[i] += co2[i];
       }
</code></pre>
",0
46961913,46960755,0,"<p>Your interface is ""suboptimal"". It forces guarantees to to be made for it to work at all.</p>

<ul>
<li><p>Use option 1 if you can guarantee that all values of <code>exs1</code> and <code>exs2</code> are in [0..(<i>DATASIZE</i>-1)].</p></li>
<li><p>Use option 2 if you can merely guarantee that there are fewer than <em>DATASIZE</em> different values in <code>exs1</code> and <code>exs2</code> combined.</p></li>
</ul>

<p><strong>Option 1</strong></p>

<p>This solution's performance is bound by O(N).</p>

<pre><code>#define DATASIZE 50

void panic(const char* msg) {
   fprintf(stderr, msg);
   exit(EXIT_FAILURE);
}

find_ex(ex, 

// Assumes all values in exs1 are in [0..49].
// Assumes all values in exs2 are in [0..49].
void add_polynom(int cos1[], int exs1[], int cos2[], int exs2[]) {
    int cos_sum[DATASIZE];
    size_t i;
    int exs1i, exs2i;

    for (i=DATASIZE; i--; )
       cos_sum[i] = 0;

    for (i=DATASIZE; i--; ) {
        if (exs1[i] &lt; 0 || exs1[i] &gt;= DATASIZE || exs2[i] &lt; 0 || exs2[i] &gt;= DATASIZE)
            panic(""add_polynom: Exponent out of range\n"");

        cos_sum[exs1[i]] += cos1[i];
        cos_sum[exs2[i]] += cos2[i];
    }

    for (i=DATASIZE; i--; ) {
        cos1[i] = cos_sum[i];
        exs1[i] = i;

        cos2[i] = 0;
        /* exs2[i] = i; */
    }
}
</code></pre>

<p><strong>Option 2</strong></p>

<p>This solution's performance is bound by O(N<sup>2</sup>). The bound can be reduced to O(N) by using an associative array instead of <code>find_index_of_ex</code>, but that's too much work for this answer.</p>

<pre><code>#define DATASIZE 50

void panic(const char* msg) {
   fprintf(stderr, msg);
   exit(EXIT_FAILURE);
}

ssize_t find_index_of_ex(int ex, int cos[], int exs[], size_t size) {
    ssize_t i;
    for (i=0; i&lt;size; ++i) {
        if (exs[i] == ex) {
            return i;
        }
    }

    return -1;
}

// Assumes there are fewer than DATASIZE different values in exs1 and exs2 combined.
void add_polynom(int cos1[], int exs1[], int cos2[], int exs2[]) {
    int cos_sum[];
    int exs_sum[];
    ssize_t lookup_is_by_ex[datasize];
    size_t i, sum_count;
    ssize_t i_sum;

    for (i=DATASIZE; i--; ) {
       cos_sum[i] = 0;
       exs_sum[i] = 0;
    }

    sum_count = 0;
    for (i=DATASIZE; i--; ) {
        if (cos1[i] == 0)
            continue;

        i_sum = find_index_of_ex(exs1[i], exs_sum, sum_count);
        if (i_sum &gt;= 0)
           cos_sum[i_sum] += cos1[i];
           continue;
        }

        if (sum_count == DATASIZE)
            panic(""add_polynom: Too many different exponents\n"");

        cos_sum[sum_count] = cos1[i];
        exs_sum[sum_count] = exs1[i];
        ++sum_count;
    }

    for (i=DATASIZE; i--; ) {
        if (cos2[i] == 0)
            continue;

        i_sum = find_index_of_ex(exs2[i], exs_sum, sum_count);
        if (i_sum &gt;= 0)
           cos_sum[i_sum] += cos2[i];
           continue;
        }

        if (sum_count == DATASIZE)
            panic(""add_polynom: Too many different exponents\n"");

        cos_sum[sum_count] = cos2[i];
        exs_sum[sum_count] = exs2[i];
        ++sum_count;
    }

    for (i=DATASIZE; i--; ) {
        cos1[i] = cos_sum[i];
        exs1[i] = exs_sum[i];

        cos2[i] = 0;
        /* exs2[i] = i; */
    }
}
</code></pre>
",0
35246621,35246380,1,"<p>You need to read up on C pointer and memory allocation. There are two misunderstandings here:</p>

<ol>
<li><code>tmp</code> is not, as it is written, a string buffer. It is just a string pointer. It can only be assigned to point to strings that are allocated somewhere else, and not contain the string itself.</li>
<li>You are just copying the pointer to <code>actived</code> (which by the way probably should be spelled <code>activated</code>). This means that all <code>actived</code> pointers all point to the same as <code>tmp</code> does, which is always the same, since tmp is never changed (and also has uninitialized value).</li>
</ol>

<p>I suggest you use <code>tmp = malloc(1024)</code>. Don't forget to use <code>free(services_i.actived[i])</code> when you don't need them anymore.</p>

<p>I also suggest making an array of structs instead of a struct of arrays, to make it more logical.</p>
",1
35246525,35246380,1,"<p>Here is some example code of how to assign a value to structure:</p>

<pre><code>#include &lt;stdio.h&gt;

struct date {           /* global definition of type date */
    int month;
    int day;
    int year;
};

main()
{

    struct date  today;

    today.month = 10;
    today.day = 14;
    today.year = 1995;

    printf(""Todays date is %d/%d/%d.\n"", \
        today.month, today.day, today.year );
}
</code></pre>
",3
39682933,21074682,0,"<p>Psuedo code in python for divide by constant</p>

<p>n_bits = Number of bits of input over which division is expected to be accurate</p>

<p>den = divisor</p>

<pre><code>prec = int(math.ceil(math.log(den,2)))
shift = n_bits + prec
mult = int(math.ceil((1&lt;&lt;shift)/float(den)))
answer = (x*mult) &gt;&gt; shift
err = sum([round(x/den) - ((x*mult) &gt;&gt; shift) for x in range(1&lt;&lt;n_bits)])
</code></pre>

<p>Multiplication can be implemented with shifts and adds</p>
",0
39113360,39089086,0,"<p>So.. I finally solved it! I created a new program to try to find how to fix the one I'm currently working on. </p>

<p><em>(Code goes in [...] of</em></p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include &lt;windows.h&gt;

void ClearScreen(void)
{
  system(""cmd /c cls"");
}

int main(void)
{
  [...] //Everything is in here for next examples
}
</code></pre>

<p><em>for next examples)</em></p>

<p><strong><em>For Any Letter:</em></strong></p>

<pre><code>  int i=0;
  char name[20];

  while(1)
  {
    for(i=1; i&gt;0&amp;&amp;i&lt;5; i++)
    {
      //ClearScreen();
      printf(""%i"", i);
      printf(""                                         Welcome to Guy's game!\n\n"");
      Sleep(500);
      while (kbhit())
      { 
        getch();
        goto INPUT;
        i=0;
      }   
    }
  goto INPUT;
  }
  INPUT:
  ClearScreen();
  //this is the where it should skip
  printf(""                                         Welcome to Guy's game!\n\n"");
  printf(""Please enter your name: "");
  gets(name);
  Sleep(250);
  printf(""%s"", name);
  return 0;
</code></pre>

<p><strong><em>For Only One Letter:</em></strong></p>

<pre><code>  int i=0;
  char name[20];

  while(1)
  {
    for(i=1; i&gt;0&amp;&amp;i&lt;5; i++)
    {
       //ClearScreen();
       printf(""%i"", i);
       printf(""                                         Welcome to Guy's game!\n\n"");
       Sleep(500);
       while (kbhit()&amp;&amp;getch()== 'p')
       {
         goto INPUT;
         i=0;
       }   
    }
    goto INPUT;
  }
  INPUT:
  ClearScreen();
  //this is the where it should skip
  printf(""                                         Welcome to Guy's game!\n\n"");
  printf(""Please enter your name: "");
  gets(name);
  Sleep(250);
  printf(""%s"", name);
  return 0;
</code></pre>

<p>You may use this in your code if you like! Good luck, and thank you for all of your answers!</p>

<p>*BTW I made it show numbers in the loop so that it would prove that the program works, but you can take that part out because it is not needed.</p>
",0
37340924,37340629,0,"<p><code>SensorData</code> is just a pointer, it hold's no value. You need to actually allocate memory for it.</p>

<p>Changing the definition of <code>SensorData</code> to:</p>

<pre><code>static Byte_t SensorData[5];
</code></pre>

<p>will fix your problem.</p>

<p>A wonder your program did run at all, you are accessing data you're not supposed to access.</p>
",0
37340947,37340629,2,"<p>Your pointer is pointing to undefined address. It is <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow"">Undefined Behavior</a></p>

<p>You must init your pointer</p>

<pre><code>Byte_t  *SensorData = malloc(requested_size);
if (SensorData != NULL)
{
    // your stuff
}
free(SensorData);
</code></pre>

<p>Or declare it as an array</p>

<pre><code>static Byte_t SensorData[requested_size];
</code></pre>
",0
37340986,37340629,0,"<p>I think you should add following line to allocate memory for your <code>SensorData</code> array:</p>

<pre><code>SensorData=malloc(sizeof(Byte_t)*5);
</code></pre>

<p>Or you would get ""segmentation fault"" while you try to access <code>SensorData[]</code>.</p>
",0
37904469,37904353,5,"<p>I see couple of problems:</p>

<ol>
<li><p>A VLA, such as <code>p</code>, cannot be used as an argument to a function that expects a fixed size array. Imagine the problems if <code>m</code> is not <code>8</code> or <code>n</code> is not <code>12</code>.</p></li>
<li><p>A VLA cannot be initialized using an intializer list.</p></li>
</ol>

<p>You can solve both problems by making <code>m</code> and <code>n</code> macros.</p>

<pre><code>#define m 8
#define n 12
</code></pre>

<p>If you choose to do that, replace the use of the hard coded value <code>8</code> and <code>12</code> by <code>m</code> and <code>n</code>, respectively, everywhere.</p>

<p><strong>Update to point 1 above</strong></p>

<p>gcc does not mind if a VLA is used an argument in a function call where the expected argument type is fixed array. i.e. it is OK using <code>int (*)[n]</code> when the argument type is <code>int (*)[12]</code>. I have not been able to find anything in the standard that indicates which compiler is correct.</p>
",7
37904819,37904353,2,"<p>To get around the issues mentioned by <a href=""https://stackoverflow.com/users/434551/r-sahu""><em>R Sahu</em></a>'s <a href=""https://stackoverflow.com/a/37904469/694576"">answer</a>, you can do the following:</p>

<pre><code>#include &lt;stdio.h&gt;

void maxId(size_t m,size_t m, int p[m][n]){

}

#define M (8)
#define N (12)

int main(void)
{
  int p[M][N] = 
  {
    {0,1,1,0,1,0,0,0,1,1,1,0},
    {0,1,1,0,1,0,0,0,1,1,1,0},
    {0,0,1,0,1,0,0,0,1,1,1,0},
    {0,1,0,0,1,1,1,0,1,1,1,0},
    {0,0,1,0,1,0,1,0,1,1,1,0},
    {0,0,1,0,1,0,1,0,1,1,1,0},
    {0,1,0,0,1,1,0,0,1,1,1,0},
    {0,0,1,0,1,0,0,0,1,0,1,1}
  };

  size_t n = N;
  size_t m = M;

  int v[m][n];

  for (size_t i = 0; i &lt; m; i++)
  {
    for(size_t j = 0; j &lt; n; j++)
    {
      v[i][j] = p[i][j];
    }
  }

  maxId(m, n, v);

  return 0;
}
</code></pre>
",6
40964609,40964455,0,"<p>I think you want something like:</p>

<pre><code>struct list *copyList(struct list *list)
{
    struct list *new = list_new(); 
    struct link *current = list-&gt;first;
    struct link *newCurrent = malloc(sizeof(struct link));

    if((current == NULL) || (newCurrent == NULL) || (new == NULL))
    {
        if(newCurrent != NULL)
        {
            free(newCurrent);
        }
        if(new != NULL)
        {
            free(new);
        }

        return NULL; 
    }
    else
    {
        new-&gt;first = newCurrent; 
    }


    while(current != NULL) 
    {
        newCurrent-&gt;name = strdup((char*)current -&gt; name); 
        current = current-&gt;next;        
        if(current != NULL)
        {
            newCurrent-&gt;next = malloc(sizeof(struct link));
            newCurrent = newCurrent-&gt;next;
        }
        else
        {
            newCurrent-&gt;next = NULL;
            new-&gt;last = newCurrent;
        }
    }

    return new;
}
</code></pre>
",4
41187468,41187038,2,"<p>Search for a matching acceptable escape character from the list of <code>""</code>, <code>'</code>, <code>?</code>, <code>\</code>, <code>a</code>, <code>b</code>, <code>t</code>, <code>n</code>, <code>v</code>, <code>f</code>, <code>r</code></p>

<pre><code>char ab_to_escape(char a, char b) {
  if (a == `\\`) {
    static const char *escapev = ""\""\'\?\\abtnvfr"";
    static const char *escapec = ""\""\'\?\\\a\b\t\n\v\f\r"";
    char *p = strchr(escapev, b);
    if (p == NULL || *p == '\0') {
      return b; // TBD this condition, invalid escape character found.
      // Perhaps it begins an octal (0-7) or hexadecimal (x or X) escape sequence?
      // \0 or \x42 etc.
    }
    return escapec[p - escapev];
  }
  return a;// TBD this condition
}
</code></pre>

<hr>

<p>I think OP needs a different function though to handle all escape sequence, many of which are longer than one character after the <code>\\</code>. </p>

<pre><code>int Decode_Escape(char *dest, const char *src) {
  int ch;
  do {
    ch = *src++;
    if (src == '\\') {
      if (simple_escape) Handle_Simple_Escape();            \\ \n \t ...
      else if (octal_escape) Handle_Octal_Escape();         \\ \0 \123
      else if (hex_escape) Handle_Hex_Escape();             \\ \x2 \XAb
      else if (universal_escape) Handle_Universal_Escape(); \\ \uABCD \U12345678
      else { Error(); return 1; }
    } else {
      *dest++ = ch;
    }
  } while (ch);
  return 0;
} 
</code></pre>
",0
47492173,47492066,2,"<p>Here's how I'd approach the problem as a first pass:</p>

<pre><code>typedef struct
{
  // data_length should come first because it's not an arbitrary length and needs
  // to be aligned on a 4-byte boundary. This avoids ugly padding issues.
  int data_length;
  char file_name[256];
} FileInfo;

size_t writeFileInfo(FILE* f, FileInfo* fi) {
  return fwrite((void*)&amp;fi-&gt;data_length, sizeof(int), 1, f) &amp;&amp;
    fwrite((void*)&amp;fi-&gt;file_name, 1, fi-&gt;data_length, f);
}

size_t readFileInfo(FILE* f, FileInfo* fi) {
  size_t rv = 0;

  rv += fread((void*)&amp;fi-&gt;data_length, sizeof(int), 1, f);
  rv += fread((void*)&amp;fi-&gt;file_name, 1, fi-&gt;data_length, f);

  // Don't forget to NULL-terminate this string
  fi-&gt;file_name[fi-&gt;data_length] = 0;

  return rv;
}
</code></pre>

<p>These two functions break out the reading and writing operations into self-contained chunks of code, but they could just as easily be incorporated as part of another read/write function respectively.</p>

<p>The trick here is to write out a <em>variable length field</em> in your header as a length + string pair. Older file formats will use 8-bit or 16-bit values for these fields to avoid file bloat, but two extra bytes is probably not the end of the world here. You can trim those off by switching your length field to <code>uint16_t</code> if you feel that's necessary.</p>

<p>Here's a quick demonstration:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void testWrite(char* path) {
  FILE* f = fopen(path, ""w"");

  FileInfo example;

  strcpy(example.file_name, ""example.txt"");
  example.data_length = strlen(example.file_name);

  writeFileInfo(f, &amp;example);

  fclose(f);
}

void testRead(char* path) {
  FILE* f = fopen(path, ""r"");

  FileInfo example;

  readFileInfo(f, &amp;example);

  printf(""Read: %d / %s\n"", example.data_length, example.file_name);

  fclose(f);
}

int main(int argc, char** argv) {
  char* testDump = ""dump.bin"";

  testWrite(testDump);
  testRead(testDump);

  return 0;
}
</code></pre>

<p>You should get a simple binary file with the right content in it. Pay very close attention to correctly NULL terminating your strings when reading in to raw buffers. C is always one tiny mistake away from a massive buffer overflow bug.</p>

<p>You'll want to get rid of that fixed-length character buffer and use something like <code>malloc()</code> to read in whatever size the size field dictates. Be careful with possibly huge values though. A single bit flip corruption error could trick your program into allocating 2GB of memory for no reason.</p>
",6
47493879,47492066,0,"<p>It was a really simple error - it was because I wasn't reading the file at all. Changing the if statement to be <code>&lt;=0</code> helped me track that down.</p>

<p>From:</p>

<pre><code>if (fread(&amp;fileInfo, sizeof(FileInfo), 1, file) &lt; 0)
    printf(""something went wrong with reading the file\n"");
</code></pre>

<p>To: </p>

<pre><code>if (fread(&amp;fileInfo, sizeof(FileInfo), 1, file) &lt;= 0)
    printf(""something went wrong with reading the file\n"");
</code></pre>
",0
46101840,46101786,1,"<pre><code>largest = array[0];            //consider your 1st element as largest element
for (i = 1; i &lt; size; i++)     //
{
    if (largest &lt; array[i])    //compare largest element with i'th element
        largest = array[i];    //if it is, make i'th element as largest
}
printf(""\n largest element present in the given array is : %d"", largest);
</code></pre>

<p>try this</p>
",3
46103692,46101786,0,"<blockquote>
  <p>Going point by point for error corrections : </p>
  
  <ol>
  <li><p><code>for(i=1;i&lt;c;i++)</code>  <code>i</code> needs to be set to 1. So that when you do array[i-1] , it starts from i = 1 such  that, <code>array[1-1]</code> happens.
  Otherwise if <code>i</code> is set to <code>0</code> then it will turn out to <code>array[0-1]</code>
  ,i.e, array[-1], since this value is not defined, it could point to
  any value in stack memory.</p></li>
  <li><p><code>if(array[i-1] &gt; array[i])</code> This if statment simply checks, if a previous value is greater than its next value, i.e, if an array <code>1 2 3
  4 5 6 7</code> is there, it would only see. <code>if (array[0]&gt;array[1] )</code> , then
  <code>if(array[1] &gt; array[2] )</code>. In the example array, <code>1 2 3 4 5 6 7</code> ,
  which is ascending order, it would never enter the if condition.
  Since, <code>1 &gt; 2</code> is not true. <code>2 &gt; 3</code> is not true, and so on. Hence the
  correct way of checking it would be, to check the current array index
  with the existing max value. i.e, </p></li>
  </ol>
  
  <p><code>if(array[i-1] &gt; max) { max = array[i-1] ;}</code> This would keep replacing
  the <code>max</code> value if a bigger number is encountered. And then check the
  next number with the max.</p>
  
  <ol start=""3"">
  <li><pre><code>else if(last_element &gt; array[i-1])  //This else if detects greatest
{                                   //index of array in last index
    max = last_element;             //This statement is always eval
}//end if                           //uating true.
}//end for
</code></pre></li>
  </ol>
  
  <p>Now this would again  be a wrong statement. Consider the example array
  <code>5  4 3 2 1' .Here the last element is always smaller than
  </code>array[i-1]`, that means last element is always smaller than all
  previous elements. So this condition would never be entered.</p>
  
  <p>FINALLY, Correct code: declare a variable  <code>int max = 0</code> Such that, if
  array[i]>max, then  max value is replaced to that array's value. And
  then the next array value is checked with the newly declared max.</p>

<pre><code>int max =0;
for(int i=0; i&lt;c; i++){
if(array[i] &gt; max){
max=array[i];
}
}
</code></pre>
</blockquote>
",0
34918941,34918890,2,"<p>It's <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow""><em>Undefined behaviour</em></a> if <code>printf()</code> has format specifier mismatch. <code>%lf</code> expects a <code>double</code> but you are passing a <code>long int</code>.</p>

<p><a href=""http://port70.net/~nsz/c/c11/n1570.html#7.21.6.1p9"" rel=""nofollow"">C11, 7.21.6.1 The fprintf function</a></p>

<blockquote>
  <p>9 If a conversion specification is invalid, the behavior is
  undefined.282) If any argument is not the correct type for the
  corresponding conversion specification, the behavior is undefined.</p>
</blockquote>

<p>That said, what probably happens is that when you call <code>printf()</code> the first time, the value of <code>f</code> is passed in a floating point register or at a location in stack for double. The next time you call p<code>rintf()</code>, it reads from the <em>same</em> location due to the format specifier <code>%lf</code>. As opposed to reading from where the value of <code>l</code> is stored. If you swap the order of printf() calls, you would probably observe a different output. But this is all platform specific. Once your program invokes <em>undefined behaviour</em>, anything can happen. Basically, you can't expect it to do anything sensible and there is absolutely no guarantee about its behaviour.</p>
",5
34918969,34918890,0,"<p>You have a specifier mismatch. The value</p>

<pre><code>long l = 1024L;
</code></pre>

<p>is interpreted as a double; and this happens to be approximately 1.3 (at least on your and my pc. This might be different on different architectures I think; depending on how long a ""long"" and a ""double"" are, and how they are represented internally.</p>

<p>As for the <strong>meaning</strong> of the <code>%lf</code> placeholder, you can see in the <a href=""http://www.cplusplus.com/reference/cstdio/printf/"" rel=""nofollow"">printf documentation</a> that <code>%f</code> means: <strong>decimal floating point</strong>. the <code>l</code> length modifier has <strong>no</strong> influence on the <code>%f</code> specifier. </p>

<p>Conclusion: <code>%lf</code> = <code>%f</code> = <strong>decimal floating point</strong></p>
",3
34918993,34918890,0,"<p>Here if you change your code to this:</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    double f = 1.3;
    long l = 1024L;

    printf(""f = %lf"", f);
    printf(""l = %lf"", (float)l);
    return 0;
}
</code></pre>

<p>you will see that the output would be different. When you pass a long to be presented as double you should expect undefined behavior</p>
",0
43195720,43195548,4,"<p>This should leave you with the correct answer. In your example you were finding the sum of 0 to 999,999. I also removed the needless casting for you.</p>

<pre><code>unsigned long long sum = 0;

for (unsigned long long i = 1; i &lt;= 1000000; i++) sum += i;

printf(""%llu"", sum);
</code></pre>
",1
43195721,43195548,1,"<p>You sum up all numbers from 0 to 999999. Your result is some Kinde of strange. </p>

<p>With this you should get the correct one:</p>

<pre><code>unsigned long long sum=0;
for(unsigned long long i=1;i&lt;=1000000;i++){
    sum+=i;
}
</code></pre>
",2
46066415,46066294,5,"<p>The two versions with the cast are non-standard; the cast is not necessary in either case (though there is more justification for it in the second of them).</p>

<p>The initializations do two different jobs ¡ª both are good jobs, but they are different.</p>

<pre><code>static char *name = """";
</code></pre>

<p>Here, <code>name</code> is a valid pointer to an empty string.  It can be passed to functions that expect a valid pointer but where an empty string is sensible.</p>

<pre><code>static char *name = NULL;
static char *name = 0;
</code></pre>

<p>In both these cases, <code>name</code> is a null pointer ¡ª it doesn't point to anywhere valid.  Dereferencing <code>name</code> after either of these initializations leads to undefined behaviour, which means your program typically (but not necessarily) crashes.  You need to make the variable point at something valid before dereferencing it.</p>
",0
41914661,41914626,3,"<ol>
<li><p>If you don't enter anything, <code>scanf</code> will return a negative value.</p>

<pre><code>int integer; 
int result = scanf(""%d"", &amp;integer);
if (result &gt; 0) { /* safe to use integer */ }
</code></pre></li>
<li><p><code>int integer;</code> is initialized to the data which was at the location the program allocated for it. Hence it will look like garbage and should be initialized with a sensible value such as <code>0</code>.</p></li>
</ol>
",1
41924075,41914626,0,"<p>this is from: <a href=""https://gcc.gnu.org/ml/gcc-help/2006-03/msg00101.html"" rel=""nofollow noreferrer"">https://gcc.gnu.org/ml/gcc-help/2006-03/msg00101.html</a></p>

<pre><code>/* --- self-identity --- */
#include ""kbhit.h""

/* fileno setbuf stdin */
#include &lt;stdio.h&gt;

/* NULL */
#include &lt;stddef.h&gt;

/* termios tcsetattr tcgetattr TCSANOW */
#include &lt;termios.h&gt;

/* ioctl FIONREAD ICANON ECHO */
#include &lt;sys/ioctl.h&gt;

static int initialized = 0;
static struct termios original_tty;


int kbhit() 
{
  if(!initialized)
  {
    kbinit();
  }

  int bytesWaiting;
  ioctl(fileno(stdin), FIONREAD, &amp;bytesWaiting);
  return bytesWaiting;
}

/* Call this just when main() does its initialization. */
/* Note: kbhit will call this if it hasn't been done yet. */
void kbinit()
{
  struct termios tty;
  tcgetattr(fileno(stdin), &amp;original_tty);
  tty = original_tty;

  /* Disable ICANON line buffering, and ECHO. */
  tty.c_lflag &amp;= ~ICANON;
  tty.c_lflag &amp;= ~ECHO;
  tcsetattr(fileno(stdin), TCSANOW, &amp;tty);

  /* Decouple the FILE*'s internal buffer. */
  /* Rely on the OS buffer, probably 8192 bytes. */
  setbuf(stdin, NULL);
  initialized = 1;
}

/* Call this just before main() quits, to restore TTY settings! */
void kbfini()
{
  if(initialized)
  {
    tcsetattr(fileno(stdin), TCSANOW, &amp;original_tty);
    initialized = 0;
  }
}

----------------------------------

To use kbhit:

----------------- demo_kbhit.c -----------------
/* gcc demo_kbhit.c kbhit.c -o demo_kbhit */
#include ""kbhit.h""
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;

int main()
{
  int c;
  printf(""Press 'x' to quit\n"");
  fflush(stdin);
  do
  {
    if(kbhit())
    {
      c = fgetc(stdin);
      printf(""Bang: %c!\n"", c);
      fflush(stdin);
    }
    else usleep(1000); /* Sleep for a millisecond. */
  } while(c != 'x');
}

----------------------------------
</code></pre>

<p>IF wanting to use <code>scanf()</code>  then check the returned value (not the parameter value.)  If the returned value is 1 then the user entered a integer value</p>
",0
36759777,36759717,0,"<p>Local variables declared inside a function are not initialized by the runtime. They are allocated on the stack and have undefined values (whatever happens to be in that stack location).</p>

<p>Variables defined in global scope are initialized to 0 automatically.</p>
",0
36759781,36759717,1,"<p>Uninitialized variables can contain any value(32767 in your case), or even trap representation. In fact, trying accessing an uninitialized invokes undefined behavior, which makes everything from working as expected to a runtime crash possible.</p>

<p>Since <code>sum</code> is expected to start at <code>0</code>, initialize it as following works:</p>

<pre><code>int sum = 0;
</code></pre>
",0
36759747,36759717,4,"<p>Unlike some other programming languages like C# and Java, C does not automatically initialize its variables, meaning that you will see whatever random data happens to be at the memory location that is assigned to the variable when the variable is created.</p>

<p>For this reason, you must always set your variables to some initial value before using them (usually zero for numeric variables).</p>
",6
36411205,36411144,3,"<blockquote>
  <p>I want to save the string that printf produces in a char</p>
</blockquote>

<p>You mean in a <code>char</code> array?</p>

<p>You can use <a href=""http://www.cplusplus.com/reference/cstdio/snprintf/"" rel=""nofollow"">snprintf</a></p>

<pre><code>  char buffer [50];
  int a=2, b=3;
  snprintf (buffer, 50, ""%d + %d = %d"", a, b, a+b);
</code></pre>
",5
36411233,36411144,1,"<p>Please look up [snprintf](<a href=""http://www.cplusplus.com/reference/cstdio/snprintf/]"" rel=""nofollow"">http://www.cplusplus.com/reference/cstdio/snprintf/]</a></p>

<p>This function is able to store the value in a string</p>

<p>The code goes like thus:</p>

<pre><code>char s[1024]; // or some other suitable value

snprintf(s, 1024, ""Hello, my name is %s\n"", name_variable);

printf(""Here it is %s\n"", s);
</code></pre>
",1
40783414,40783223,1,"<p>You are not casting properly:</p>

<pre><code>int comp(const void* a, const void* b)
{
    const char* pa = *(const char**)a;
    const char* pb = *(const char**)b;

    return strcmp(pa, pb);
}
</code></pre>

<p>should be:</p>

<pre><code>int comp(const void* a, const void* b)
{
    const char* pa = (const char*)a;
    const char* pb = (const char*)b;

    return strcmp(pa, pb);
}
</code></pre>

<p>I do not know if there are other problems in your code, but when you cast a <code>void*</code> to a <code>const char**</code> you are sending the processor to access memory addresses that are bogus.</p>
",0
40783458,40783223,1,"<p>You write your program as words has type <code>char *words[N]</code> (array of pointers to C-strings). But your type is <code>char words[N][MAX + 1]</code>. Its flat array, compiler can translate it to <code>char words[N * (MAX + 1)]</code>.</p>

<p>So, if you really want to save type of words then:</p>

<pre><code>qsort(words, N, sizeof(*words), comp);

int comp(const void* a, const void* b)
{
    return strcmp(a, b);
}
</code></pre>
",5
40783466,40783223,0,"<p>In your string compare function change</p>

<pre><code>const char* pa = *(const char**)a;
const char* pb = *(const char**)b;
</code></pre>

<p>to</p>

<pre><code> const char* pa = (const char*)a;
 const char* pb = (const char*)b;
</code></pre>
",0
40784386,40783223,0,"<pre><code>const char* pa = *(const char**)a;
const char* pb = *(const char**)b;
</code></pre>

<p>should be:</p>

<pre><code>const char* pa = (const char*)a;
const char* pb = (const char*)b;
</code></pre>

<p>and</p>

<pre><code>qsort(words, N, sizeof(char*), comp);
</code></pre>

<p>should be:</p>

<pre><code>qsort(words, N, sizeof(words[0]), comp);
</code></pre>

<p>the third parameter means the length of the array</p>
",0
41934181,41934092,1,"<p>It doesn't define a macro. It adds an expression to a bitmask. That operation there is bitwise or. The macro/enum <code>SSL_OP_NO_SSLv3</code> must exist for it to be valid code.</p>

<p>If the macro <code>OPENSSL_NO_SSL3</code> <strong>is defined</strong>, then the code inside the conditional isn't included in the source.</p>

<p>Having the preprocessor check for macro definitions is a common way to implement conditional compilation. This way the same source can be compiled under various configurations. The macros to check against can be defined in source with <code>#define</code>, passed by the build system (like with the gcc <code>-D</code> option), or be builtin to the preprocessor (such as <code>__STDC_IEC_559__</code>).</p>
",0
41934596,41934092,2,"<p>The question makes sense only with the surrounding code (slightly simplified here):</p>

<pre><code>    mask =  SSL_OP_NO_TLSv1_1|SSL_OP_NO_TLSv1
#if !defined(OPENSSL_NO_SSL3)
                  |SSL_OP_NO_SSLv3
#endif
    ;
</code></pre>

<p>The preprocessor just does textual substitution. So if the preprocessor macro <code>OPENSSL_NO_SSL3</code> is not defined, the preprocessed code will look like this:</p>

<pre><code>    mask =  SSL_OP_NO_TLSv1_1|SSL_OP_NO_TLSv1
                  |SSL_OP_NO_SSLv3
    ;
</code></pre>

<p>otherwise the preprocessed code ill look like this:</p>

<pre><code>    mask =  SSL_OP_NO_TLSv1_1|SSL_OP_NO_TLSv1
    ;
</code></pre>
",0
46049023,28850464,-1,"<p>You can use <code>fgets( )</code> function to read a line of text.</p>

<p><code>fgets(str , 100 , stdin);</code></p>

<p>You can also use gets( ) function if your string is small since this funtion has no buffer overflow protection.</p>

<p><code>gets(str)</code> </p>

<p>U can also use <code>scanf</code> to do this as others have mentioned. </p>
",2
37763320,37762957,1,"<p>Remove the space: <code>scanf(""%s"", ...)</code> <br>and add a space: <code>scanf("" %c"", ..)</code></p>

<pre><code>int main()
{
    char title[61];
    char artist[41];
    short noOfTracks = 0;
    int isAlbum = 0;
    float price = 0.0;
    char albumOrSingleResponse;

    printf(""Please enter the title: "");

scanf(""%s"", title);

printf(""Please enter the artist: "");
scanf(""%s"", artist);

printf(""Please enter the number of records: "");
scanf(""%hu"", &amp;noOfTracks);

printf(""Please enter whether or not the cd is an album/single (A or S): "");
scanf("" %c"", &amp;albumOrSingleResponse);

if(albumOrSingleResponse == 'A')
{
    isAlbum = 1;


   }

    printf(""Please enter the price of the CD: "");
    scanf(""%f"", &amp;price);

   displayCDInfo(title, artist, noOfTracks, isAlbum, price);

   return 0;
}
</code></pre>

<p>Because when you add a space before <code>"" %c""</code> it consumes newline characters entered with previous inputs.</p>

<p><br>Edit: From <a href=""https://stackoverflow.com/questions/8699812/what-is-the-format-specifier-for-unsigned-short-int"">this</a>, you may use <code>""%hu""</code> for printing the <code>short</code> to avoid any warning. </p>
",0
37763495,37762957,1,"<p>This will work. Just move the position of char array declaration from top of main body.</p>

<pre><code>void displayCDInfo(char* title, char* artist, short noOfTracks, int isAlbum, float price);

int main()
{
    short noOfTracks = 0;
    int isAlbum = 0;
    float price = 0.0;
    char albumOrSingleResponse;
    char title[61];
    char artist[41];

    printf(""Please enter the title: "");
    scanf("" %s"", title);

    printf(""Please enter the artist: "");
    scanf("" %s"", artist);

    printf(""Please enter the number of records: "");
    scanf("" %d"", &amp;noOfTracks);

    printf(""Please enter whether or not the cd is an album/single (A or S): "");
    scanf("" %c"", &amp;albumOrSingleResponse);

    if(albumOrSingleResponse == 'A')
    {
        isAlbum = 1;
    }

    printf(""Please enter the price of the CD: "");
    scanf("" %f"", &amp;price);

   displayCDInfo(title, artist, noOfTracks, isAlbum, price);

   return 0;
}

void displayCDInfo(char* title, char* artist, short noOfTracks, int isAlbum, float price)
{
    printf(""\nThe title of the CD is %s"", title);
    printf(""\nThe name of the artist is %s"", artist);
    printf(""\nThe number of tracks on this CD are %d"", noOfTracks);
    printf(""\nThe CD is an %s"", (isAlbum == 1) ? ""album"" : ""single"");
    printf(""\nThe price of the cd is $%.2f"", price);
}
</code></pre>
",0
37763523,37762957,1,"<p>I figured out how to fix this now whilst keeping <code>noOfTracks</code> as a short. Since I was using <code>""%d""</code> for scanf on the Number of tracks variable I was overwriting the space allocated for the previous variable which was artist, hence why it wasn't being displayed. To solve this I had to change the <code>""%d""</code> to <code>""%hu""</code> for short int. </p>

<pre><code>void displayCDInfo(char* title, char* artist, short noOfTracks, int isAlbum, float price);

int main()
{
    char title[61];
    char artist[41];
    short noOfTracks = 0;
    int isAlbum = 0;
    float price = 0.0;
    char albumOrSingleResponse;

    printf(""Please enter the title: "");
    scanf(""%s"", title);

    printf(""Please enter the artist: "");
    scanf(""%s"", artist);

    printf(""Please enter the number of records: "");
    scanf(""%hu"", &amp;noOfTracks);

    printf(""Please enter whether or not the cd is an album/single (A or S): "");
    scanf("" %c"", &amp;albumOrSingleResponse);

    if(albumOrSingleResponse == 'A')
    {
        isAlbum = 1;
    }

    printf(""Please enter the price of the CD: "");
    scanf("" %f"", &amp;price);

    displayCDInfo(title, artist, noOfTracks, isAlbum, price);

    return 0;
}

void displayCDInfo(char* title, char* artist, short noOfTracks, int isAlbum, float price)
{
    printf(""\nThe title of the CD is %s"", title);
    printf(""\nThe name of the artist is %s"", artist);
    printf(""\nThe number of tracks on this CD are %hu"", noOfTracks);
    printf(""\nThe CD is an %s"", (isAlbum == 1) ? ""album"" : ""single"");
    printf(""\nThe price of the cd is $%.2f"", price);
}
</code></pre>
",1
36271903,36270925,-2,"<p>From what I understand you are trying to pass the filename to your program and not sure how to do that. In that case you might want to do this</p>

<pre><code>int main(int argc, char* argv[])
{
  if(argc&gt;1)
  std::string filename = argv[1];
  //now you have the file in the filename

 // your code 
 return 0;
}
</code></pre>

<p>so when you execute just do this</p>

<pre><code>./binary binary1.txt
</code></pre>

<p>you don't need to use <code>&lt;</code> and I am assuming that both your executable and text file are in the same directory</p>
",3
36271693,36270925,0,"<p>I am not sure what you are asking. I guess you need to compile your source using a compiler. If you are using Linux you could do:<code>gcc binary.c -o binary</code> to get an executable file...</p>
",0
46060276,41448263,0,"<p>Here's two suggestions, both of which have small memory footprint. The first will use no more memory that the number of results you wish to return for the request. It's a constant-time O(1) memory - it only depends on the size of the result set but is ultimately quadratic time (or worse) if the user really does page through all results:</p>

<p>You are only looking for a small paged result (e.g the r=25 entries). You can generate these by scanning through all filenames and maintaining a sorted list of items you will return, using an insertion sort of length r and for each file inserted, only retain the first r results. (In practice you would not insert the file F if it is lower than the r<sup>th</sup> entry).</p>

<p>How would you generate the 2<sup>nd</sup> page of results? You already know the 25th file from the previous request - so during the scan ignore all entries that are before that. (You'll need to work harder if sorting on fields with duplicates)</p>

<p>The upside is the minimum memory required - the memory needed is not much larger than the r results you wish to return (and can even be less if you don't cache the names). The downside is generating the complete result will be quadratic in time in terms of the number of total files you have. In practice people don't sort results then page through all pages, so this may be acceptable.</p>

<p>If your memory budget is larger (e.g. fewer than 10000 files) but you still don't have enough space to perform a simple in-memory sort of all 10000 filenames then seekdir/telldir is your friend. i.e. create an array of longs by streaming readdir and using telldir to capture the position of each entry. (you might even be able to compress the delta between each telldir to a 2 byte short). As a minimal implementation you can then sort 'em all with clib's sort function and writing your own callback to convert a location into a comparable value. Your call back will use seekdir twice to read the two filenames. </p>

<p>The above approach is overkill - you just sorted <em>all</em> entries and you only needed one page of ~25, so for fun why not read up on Hoare's QuickSelect algorithm and use a version of it to identify the results within the required range. You can recursive ignore all entries outside the required range and only sort the entries between the first and last entry of the results.</p>
",0
46061283,41448263,0,"<p>What you want is an <a href=""https://en.wikipedia.org/wiki/External_sorting"" rel=""nofollow noreferrer"">external sort</a>, that's a sort done with external resources, usually on disk. The Unix <code>sort</code> command does this. Typically this is done with an <a href=""https://en.wikipedia.org/wiki/External_sorting#External_merge_sort"" rel=""nofollow noreferrer"">external merge sort</a>.</p>

<p>The algorithm is basically this. Let's assume you want to dedicate 100k of memory to this (the more you dedicate, the fewer disk operations, the faster it will go).</p>

<ol>
<li>Read 100k of data into memory (ie. call <code>readdir</code> a bunch).</li>
<li>Sort that 100k hunk in-memory.</li>
<li>Write the hunk of sorted data to its own file on disk.

<ul>
<li>You can also use offsets in a single file.</li>
</ul></li>
<li>GOTO 1 until all hunks are sorted.</li>
</ol>

<p>Now you have X hunks of 100k on disk an each of them are sorted. Let's say you have 9 hunks. To keep within the 100k memory limit, we'll divide the work up into the number of hunks + 1. 9 hunks, plus 1, is 10. 100k / 10 is 10k. So now we're working in blocks of 10k.</p>

<ol start=""5"">
<li>Read the first 10k of each hunk into memory.</li>
<li>Allocate another 10k (or more) as a buffer.</li>
<li>Do an <a href=""https://en.wikipedia.org/wiki/Merge_algorithm#K-way_merging"" rel=""nofollow noreferrer"">K-way merge</a> on the hunks.

<ol>
<li>Write the smallest in any hunk to the buffer. Repeat.</li>
<li>When the buffer fills, append it to a file on disk.</li>
<li>When a hunk empties, read the next 10k from that hunk.</li>
</ol></li>
<li>When all hunks are empty, read the resulting sorted file.</li>
</ol>

<p>You might be able to find a library to perform this for you.</p>

<hr>

<p>Since this is obviously overkill for the normal case of small lists of files, only use it if there are more files in the directory than you care to have in memory.</p>

<p>Both in-memory sort and external sort begin with the same step: start calling <code>readdir</code> and writing to a fixed-sized array. If you run out of files before running out of space, just do an in-memory quicksort on what you've read. If you run out of space, this is now the first hunk of an external sort.</p>
",0
40579868,40577422,0,"<p>Two lines</p>

<pre><code>char lines[5000];
strcpy(lines, ""ABC/DEF'/'GH"");
</code></pre>

<p>will </p>

<ul>
<li>allocate memory for 5000 objects of type char on stack </li>
<li>copy string literal contents to memory pointed by name ""lines"", which you can modify</li>
</ul>

<p>on the other hand</p>

<pre><code>char *lines2 = ""ABC/DEF'/'GH"";
</code></pre>

<p>defines pointer to string literal that is usually located in read only memory.<br>
Read only, as in <strong>do not modify me</strong> :)</p>

<p>You tagged this <strong>C</strong> so I assume You are talking about using <a href=""https://www.gnu.org/software/libc/manual/html_node/Line-Input.html"" rel=""nofollow noreferrer"">getline()</a> function - not a part of C standard, but provided by GNU C Library, that manages memory on it's own (so basically it can, and will do memory allocations, unless you preallocate it. It uses only heap memory, so if preallocated size is too small it reallocates it. Thus You can't provide address to stack char array instead).</p>

<p>To actually find and replace escape character from string, I'd say you should not reinvent wheel and use library string functions. </p>

<pre><code>char *line = NULL;
char *needle;
ssize_t line_size;
size_t size = 0;

line_size = getline(&amp;line, &amp;size, stdin);
while (line_size != -1) {
  needle = strchr(line, '/');
  while (needle) {
      if (needle != line &amp;&amp; !(*(needle - 1) == '\'' &amp;&amp; *(needle + 1) == '\''))
        *needle = '\n';
      needle = strchr(needle + 1, '/');
  }
  printf(""%s"", line);
  line_size = getline(&amp;line, &amp;size, stdin);
}
</code></pre>
",0
46066039,46066016,0,"<pre><code>*p=17;
</code></pre>

<p>p points to invaid memory and you are are storing a value there.</p>

<p>Its leading to undefined behaviour when you write to invalid memory, you are probably lucky program did not error in segment fault.</p>
",1
46066040,46066016,0,"<p>I add one more line in your program. It is core dumped. It will core dump, when you try to access the pointer variable, since you didn't allocate the memory for pointer variable p.</p>

<pre><code>    #include &lt;stdio.h&gt;
    int main()
    {
            int *p =0;
            *p = 17;
            printf(""%d"",*p);
            return 0;
    }
</code></pre>
",0
46066106,46066016,0,"<p>p is supposed to store the address of an integer, however, it's storing 0. Then, you are accessing address 0 and storing 17 there. 0 is likely not even a valid address so the behavior is undefined. Segfault is one of the possible outcomes.</p>
",0
36267822,36267684,1,"<p><code>realloc</code> does not modify the pointer you pass to it. Instead, it returns a new pointer, that MIGHT be the one you passed to it, if there is enough free space in the memory. </p>

<p>Instead of <code>realloc(a,(len()+1)*sizeof(char));</code> you should use <code>a = realloc(a,(len()+1)*sizeof(char));</code>. </p>

<p>You can learn more about realloc here: <a href=""http://www.cplusplus.com/reference/cstdlib/realloc/"" rel=""nofollow"">http://www.cplusplus.com/reference/cstdlib/realloc/</a></p>
",5
36267712,36267684,5,"<p>You ignore the return value of <code>realloc</code> and just continue to use the old block of memory that may or may not still be yours. Surely you meant:</p>

<pre><code>        a = realloc(a,(len()+1)*sizeof(char));
</code></pre>
",12
36259161,36259102,1,"<p>By using :</p>

<pre><code>int const a=10;
</code></pre>

<p>the value of a remains constant throughout the execution of program.</p>

<p>Using:</p>

<pre><code>int* const a=&amp;b;
</code></pre>

<p>The value contained by a i.e. the address of b remains constant throughout. </p>

<p>The value of b can change.</p>
",4
36513158,36512416,0,"<p>Defining <code>!=</code> and <code>~=</code> may cause unnecessary confusion, because some tokens can be either unary operator or binary operator, determined by the context. For example: What does <code>a -= b</code> mean, <code>a = a - b</code> or <code>a = -b</code>? </p>

<p>Any way, you don't need them. <code>a = !b</code> and <code>a = ~b</code> don't cause more typing, and are quite easy to understand.</p>
",0
42599235,33400540,0,"<p>This function copy a content of a first file to a second file. If the second file exists - will to override it, otherwise - will to create it and to write the content of the first file to it. The key for this function is the function <strong>fputc()</strong> (<a href=""http://www.cplusplus.com/reference/cstdio/fputc/"" rel=""nofollow noreferrer"">http://www.cplusplus.com/reference/cstdio/fputc/</a>).</p>

<hr>

<p><strong>A solution</strong></p>

<pre><code>#include &lt;stdio.h&gt;

/**
 * Copy content from one file to other file.
 */
int
copy_file(char path_to_read_file[], char path_to_write_file[])
{
    char chr;
    FILE *stream_for_write, *stream_for_read;

    if ((stream_for_write = fopen(path_to_write_file, ""w"")) == NULL) {
        fprintf(stderr, ""%s: %s\n"", ""Impossible to create a file"", path_to_write_file);
        return -1;
    }

    if ((stream_for_read = fopen(path_to_read_file, ""r"")) == NULL) {
        fprintf(stderr, ""%s: %s\n"", ""Impossible to read a file"", path_to_read_file);
        return -1;
    }

    while ((chr = fgetc(stream_for_read)) != EOF)
        fputc(chr, stream_for_write);

    fclose(stream_for_write);
    fclose(stream_for_read);

    return 0;
}
</code></pre>

<p><strong>Usage:</strong></p>

<pre><code>int
main(int argc, char *argv[])
{
    copy_file(""file1"", ""file2"");
    return 0;
}
</code></pre>
",1
35213752,35213704,0,"<pre><code>int n;    /* The user input choice */
do {
     printf(""MENU\n""
            ""1. foo();\n""
            ""2. bar();\n""
            ""3. Quit\n""
            ""Enter your option: "");
} while (scanf(""%d"", &amp;n) != 0 &amp;&amp; n &gt;= 1 &amp;&amp; n &lt;= 3);
</code></pre>

<p>This code displays the menu, and then checks the user input. If it is not a number, or if it is not in the range [1, 3], then the program will display the menu again. The program will continue this until the user enters good input.</p>
",0
36440955,36440856,3,"<p>Generally, the approach to problems like that is to use <code>scanf</code> to get in the whole string, and then parse it yourself when it is in memory:</p>

<pre><code>char cmdline[100];
scanf(""%99s"", cmdline);
if (strstr(cmdline, ""ADD"") == cmdline) {
    ... Get an int from cmdline buffer starting at position 3
} else if (strstr(cmdline, ""END"") == cmdline) {
    ... Don't get anything
}
</code></pre>
",0
36220852,36220402,1,"<p>Might be a bit bulky, but it kind of works) You can optimize it yourself. I hope that I get you correctly.</p>

<p><a href=""https://ideone.com/BN0qZ8"" rel=""nofollow"">IDEOne demo</a></p>

<pre><code>#include &lt;stdio.h&gt;

unsigned int weirdAnd(unsigned int a, unsigned int b) {
    unsigned int result = 0;
    unsigned int coef = 1;
    while (a &amp;&amp; b) {
        result += ((a % 10) &amp;&amp; (b % 10)) * coef;
        coef *= 10;
        a /= 10;
        b /= 10;
    }
    return result;
}

unsigned int weirdOr(unsigned int a, unsigned int b) {
    unsigned int result = 0;
    unsigned int coef = 1;
    while (a || b) {
        result += ((a % 10) || (b % 10)) * coef;
        coef *= 10;
        a /= 10;
        b /= 10;
    }
    return result;
}

int main(void) {
    // your code goes here
    unsigned int a = 10110;
    unsigned int b = 10011;
    printf(""%u and \n%u = \n%u\n\n"", a, b, weirdAnd(a, b));
    printf(""%u or  \n%u = \n%u\n\n"", a, b, weirdOr(a, b));
    return 0;
}
</code></pre>

<p>Output: </p>

<blockquote>
  <p>10110 and  10011 =  10010</p>
  
  <p>10110 or   10011 =  10111</p>
</blockquote>
",9
36220951,36220402,0,"<p>The problem is that <code>and</code> works on bits only, and it does not care if the input numbers are given in decimals, octal, hexadecimal, or any other way. To force <code>and</code> to work correctly, you <em>must</em> give it an input in 'binary', that is, only ones and zeroes. To do so you need to grab each digit of the input numbers <em>as if</em> they are binary digits.</p>

<p>The following works as expected:</p>

<pre><code>#include &lt;stdio.h&gt;

int cheap_pow (int base, int exponent)
{
    int result = base;
    while (exponent-- &gt; 0)
        result *= base;
    return result;
}

int main (void)
{
    int a = 10111, b = 1001 ;
    int result, factor;

    printf (""BAD:  %05d AND %05d = %05d\n"", a, b, a &amp; b);

    printf (""GOOD: %05d AND %05d = "");

    result = 0;
    factor = 1;
    while (a | b)
    {
        result += factor * ((a &amp; 1) and (b &amp; 1));
        factor *= 10;
        a /= 10;
        b /= 10;
    }
    printf (""%05d\n"", result);
}
</code></pre>

<p>but you <strong>must</strong> be careful when defining your inputs. When written directly into your source code, a value <code>b = 01001</code> will be interpreted by the C compiler as <em>octal</em> (base 8), rather than decimal; and it will have the (decimal) value <code>513</code>. It's just a Rule of C.</p>

<p>If your input comes from elsewhere, you don't need to take this into account ¨C except when you use a standard function such as <code>strtol</code>, where you should carefully <a href=""http://man7.org/linux/man-pages/man3/strtol.3.html"" rel=""nofollow"">read the documentation</a> because it does the same thing:</p>

<blockquote>
  <p>If <em>base</em> is zero or 16, the string may then include a ""0x""
         prefix, and the number will be read in base 16; otherwise, a zero
         <em>base</em> is taken as 10 (decimal) unless the next character is '0', in
         which case it is taken as 8 (octal).</p>
</blockquote>

<p>An additional note is this program only will work in the range for <code>signed int</code>, that is (currently) up to 10 ""binary"" digits. If you need <em>some</em> more, you could switch to a larger type; but beyond that, you are better off with a not-numerical solution and use a character strings throughout.</p>
",0
36220594,36220402,-2,"<pre><code>int a, b;
int tmp = a &amp; b;
int res = 0;

while ((tmp != 0 &amp;&amp;) (tmp / 10 != 0)){
    int dig = tmp % 10;
    res = (dig == 1)? ++res: res;
    tmp /= 10;       
}
</code></pre>

<p>Try this.</p>
",0
39628863,39628749,0,"<p>the error occurred due to this 
    if (strlen (String() >= MAX_STR_LEN-1)) {
        }
remove the () after String. String is not function. 
strlen return the length of String. The following will work fine.</p>

<pre><code>if(strlen(String) &gt;= MAX_STR_LEN-1){
} 
</code></pre>
",3
43216686,43213934,0,"<p>after much thinking, i finally figured it out:</p>

<pre><code>#include&lt;stdio.h&gt;

void getUserInput(int *numHospitalRooms, int *numFlowers);

int main()
{
    float hospitalRoomsPrices_Array[5]={300.00,350.00,400.00,450.00,500.00};
    int numHospitalRooms = 0;
    int numFlowers = 0;
    float flowerPricing = 2.50;

    getUserInput(&amp;numHospitalRooms, &amp;numFlowers);

    float flowerCost = numFlowers*flowerPricing;

    float totalCost = (flowerCost + hospitalRoomsPrices_Array[numHospitalRooms - 1]);

    printf(""\nCost for %d room(s): $%.2f"", numHospitalRooms, hospitalRoomsPrices_Array[numHospitalRooms - 1]);
    printf(""\nFlower(s) Cost: $%.2f \n"", flowerCost);

    printf(""\nTotal cost:  $%.2f"", totalCost);

    return 0;
}

void getUserInput(int *numHospitalRooms, int *numFlowers)
{
    do {
        printf(""\nHow many hospital rooms: "");
        scanf(""%d"", numHospitalRooms);
        if (*numHospitalRooms &lt; 1 || *numHospitalRooms &gt; 5)
        {
            printf(""\nInvalid number of rooms, room number must be between 1-5!\n"");
        }
    }while((*numHospitalRooms &lt; 1 || *numHospitalRooms &gt; 5));

    do {
        printf(""\nEnter number of flowers: "");
        scanf(""%d"", numFlowers);
        if (*numFlowers &lt; 0)
        {
            printf(""\nInvalid number of flowers, negative values are not accepted!\n"");
        }
    }while((*numFlowers &lt; 0));
}
</code></pre>

<p>this should be like this: <code>getUserInput(&amp;numHospitalRooms, &amp;numFlowers);</code></p>

<p>and this should be like this: </p>

<pre><code>scanf(""%d"", numHospitalRooms); //no appresand
</code></pre>

<hr>

<p>There was no need for all that back and forth for such a simple mistake anyone could have pointed out from here. As a student trying to learn, this feels very discouraging to have to fight for learning my mistakes. a simple two lines of code recommendation like i posted now would have shined a bright day here instead of a negative atmosphere. </p>
",0
37836075,37835909,2,"<p>This is the same problem as ""not able to take <code>char</code> after an <code>int</code>"", with a small twist. </p>

<p>Recall that when you read an <code>int</code> from an input using <code>scanf</code> with <code>%d</code> format specifier, the characters representing the number are consumed, but the separator following it is not. Consider a buffer that looks like this (I use underscores to show spaces):</p>

<pre><code>char     9 8 _ x _ 7 6
         - - - - - - -
position 0 1 2 3 4 5 6
</code></pre>

<ul>
<li>Before the first <code>scanf</code> call your buffer is positioned at zero.</li>
<li>After the first call your buffer is positioned at 2.</li>
<li>After the second call your buffer is positioned at 3, because space is read for your <code>char</code></li>
</ul>

<p>Now the problem becomes clear: the third <code>scanf</code> tries to read an <code>int</code>, but the buffer is at <code>x</code>, so the read is not possible.</p>
",0
37835962,37835909,8,"<p>The <code>""%d""</code> format specifier includes skipping leading white-space. The <code>""%c""</code> format doesn't have that, it reads the next character in the input buffer no matter what kind of character it is.</p>

<p>If you want to skip leading white-space using the <code>""%c""</code> format, you need to tell <code>scanf</code> explicitly to do so with a space in the format string, like e.g. <code>"" %c""</code>.</p>
",0
35296601,35296322,1,"<pre><code>    switch(userChoice)
    {       
            case 'C':
            case 'c':
                    C=enterSingleChar();
                    break;
            case 'Q':
            case 'q':
                    printf(""The program will now quit\n"");
                    exit(1);
            default:
                    break;
    }
</code></pre>
",0
35255361,35255260,1,"<h1>Use your compiler</h1>

<p>If you try and compile that code with all warnings enabled, it starts spewing out errors which you should correct before going on:</p>

<blockquote>
<pre><code>test.c:10:5: error: stray ¡®`¡¯ in program
     `enter code here`{
     ^
test.c: In function ¡®main¡¯:
test.c:10:6: error: unknown type name ¡®enter¡¯
     `enter code here`{
      ^
</code></pre>
</blockquote>

<p>And:</p>

<blockquote>
<pre><code>test.c: In function ¡®main¡¯:
test.c:34:25: warning: implicit declaration of function ¡®printRectangleOne¡¯ [-Wimplicit-function-declaration]
                         printRectangleOne(N,C);
                         ^
test.c: In function ¡®enterSingleChar¡¯:
test.c:53:22: error: ¡®singleCharC¡¯ undeclared (first use in this function)
         scanf(""%c"", &amp;singleCharC);
</code></pre>
</blockquote>

<h1>Check your input</h1>

<p>One problem that I can see is that when using <code>scanf</code> to read from standard input, <strong>also the Enter key will be put in the queue</strong>.</p>

<p>So you are asked,</p>

<pre><code>Enter one character:
Enter another character:
</code></pre>

<p>and you type:</p>

<p><kbd>A</kbd> <kbd>Enter</kbd> <kbd>B</kbd> <kbd>Enter</kbd></p>

<p>and you expect the two characters to be A and B. What is really in the input queue could be, depending on platforms (I'm not sure):</p>

<pre><code>A\r\nB\r\n  (*six* characters!)
A\nB\n      four characters
A\rB\r      four characters
</code></pre>

<p>Also, if you use one of those spurious characters (e.g. ""\n"", which is <strong>newline</strong>) to draw a 3x3 rectangle around the character ""C"", you will actually send to the output three empty lines (the top row), one empty line (the left border of the central line), a ""C"", and another four empty lines.</p>

<p>Which can be quite puzzling.</p>

<p>You do not state in your question what your problem actually <em>is</em>, but check your input routines, should any of the above symptoms make itself known.</p>

<h1>Other problems</h1>

<pre><code>void printRectangleOne(int N, char C)
{
        int i;
        int j;
        for (i = 0; i &lt;= N; i++)
        {
                // Why do you output this C here?
                fprintf(stdout, &amp;C);
                // You are checking and incrementing i here, not j.
                for(j = 0; i &lt;= N; i++)
                {
                     // fprintf does not work this way. Use
                     // putchar(C);
                     // instead.
                     fprintf(stdout, &amp;C);
                }
        }
        // I don't think this is going to work. Use either
        // putchar('\n') or printf(""\n"") to get a newline.
        printf();
}
</code></pre>
",0
35255414,35255260,1,"<p>I suggest iterative approach. If you run write code together without compiling then debugging would be difficult. Hence start with simple complete program. I think the problem description is clear with different tasks. You could first start with the menu and then ensure it works fine before adding another feature to your code. This also provides you better learning and new features.</p>
",1
36806896,36806759,0,"<p>To avoid double free error, try this:</p>

<ul>
<li>Right <em>after</em> <code>free</code>ing a pointer, set it to NULL</li>
<li>Right <em>before</em> <code>free</code>ing a pointer, check if it is NULL</li>
</ul>

<p>I would try to remove the amount of special casing, for example</p>

<pre><code>typedef struct dog Node;

Node * delete_from_list(Node * head) {
  const int key_to_delete = GetKeyToDelete();
  if (!head) return NULL;
  for (Node * cur = head; cur; ) {
    if (cur-&gt;key = key_to_delete) {
      Node * curnext = cur-&gt;next;
      free(cur);
      cur = curnext;
    } 
    else {
      break;
    }
  }
  Node * new_head = cur;
  for (Node * cur = new_head; cur; cur = cur-&gt;next) {
    if (cur-&gt;next &amp;&amp; (cur-&gt;next-&gt;key == key_to_delete)) {
      Node * curnextnext = cur-&gt;next-&gt;next;
      free(cur-&gt;next);
      cur-&gt;next = curnextnext;
    }
  }
  return new_head;
}
</code></pre>
",3
44696509,44696158,0,"<p><em>If</em> you do it, do it this way:</p>

<pre><code>#ifdef _print1_ 
#  include ""header1.h"" 
#elif _print2_
#  include ""header2.h"" 
#endif 

int main(void) 
{ 
  ...

  return 0; 
} 
</code></pre>
",3
34933961,34933924,1,"<p>Because <code>1/h</code> is an expression not an <em>lvalue</em>, you can't assign to expressions. You can read about what constitutes an <em>lvalue</em> in the <a href=""/questions/tagged/c"" class=""post-tag"" title=""show questions tagged &#39;c&#39;"" rel=""tag"">c</a> standard.</p>

<p>Try this</p>

<pre><code>int i;
double h;
double u;

u = 0;
for (i = 1 ; i &lt;= 1000 ; ++i)
    u += 1.0 / (double) i;
h = 1.0 / u;

fprintf(stdout, ""1/h = %f\n"", h);
</code></pre>

<p>Is the value correct?</p>
",5
34934723,34933924,0,"<pre><code>    int i ;
double h , a ;


a = 0 ;

for( i = 1 ; i &lt;= 1000 ; ++i )
{
    a += 1.0 / (double) i;

    h = 1 / a ;

    printf(""%lf"",h);

}
</code></pre>

<p>I changed my code to this. I get the result I want I guess. I'm not sure because I didn't calculate the values for each step. But in every step the value is decreasing so it should be right.</p>

<p>I'm still not sure if that's the perfect or right way to express myself. It will be appreciated if you can give comments about my code.</p>
",3
34935999,34933924,0,"<p><code>1/h = 0</code> and <code>(1/h) += (1/i)</code> don't work because you're trying to assign a value the result of an <em>expression</em>, not an object.  It's like writing <code>1 = 2</code> and expecting it to be meaningful; it isn't.  </p>

<p>You're trying to solve for <code>h</code>.  So you need to sum <code>1/1 + 1/2 + 1/3 + ...</code> and take the inverse:</p>

<pre><code>double u = 0.0; // u == 1/h == 1/1 + 1/2 + 1/3 + 1/4 + ...

for ( int i = 1; i &lt;= 1000; i++ )
{
  u += 1.0 / i;
}
printf( ""1/h = %f, h = %f\n"", u, 1.0/u );
</code></pre>
",0
34954710,34954641,2,"<p>Take a look here:</p>

<pre><code>    if (i % 2 == 0) 
        break;
    else if (i % 3 == 0)
        continue;
    else 
        printf(""%d\n"", i );
</code></pre>

<p>When <code>i</code> is 3, the second condition <code>(i % 3 == 0)</code> evaluates to true, since 3 mod 3 is 0.  So it executes the <code>continue</code> statement.</p>

<p>Regarding this part:</p>

<pre><code>if ((i++ + 1) == 5)
    printf(""%d\n"", i);
</code></pre>

<p><code>i</code> will have been 2 prior to the <code>if</code> part being executed.  So it evaluates <code>((2 + 1) == 5)</code>, which is false.  The only time this will be true is when <code>i</code> is 4 prior to this statement.</p>
",3
34993207,34992664,1,"<p>Macros are mere text replacement. Expanding your code, you will get this:</p>

<pre><code>int a=1+1?1:0;
int b=2*a+a&amp;a;
</code></pre>

<p>Note the complete and utter lack of parenthesis, which is caused by the macros in turn lacking appropriate parenthesis.</p>

<p><code>1+1</code> is a non-zero value so <code>a</code> will be 1.</p>

<p><code>b</code> will therefore be <code>2*1+1&amp;1</code>. Follow the operator precedence rules in C,  <code>*</code> has highest precedence in the expression, followed by <code>+</code>, followed by <code>&amp;</code>, followed by <code>=</code> which has lowest precedence.</p>

<p>So the expression is equivalent to: <code>b = ( ( (2*1) + 1) &amp; 1);</code></p>

<p><code>2*1 == 2</code>, <code>2+1==3</code>, <code>3 &amp; 1 == 1</code>.</p>
",0
35199798,35199751,3,"<p>An extension simply a convenient and conventional embellishment to a file name.</p>

<p><em>Any</em> file can be opened with c (subject to permissioning).</p>

<p>You might want to choose between ""text"" and ""binary"" formats accordingly. But we're into specifics at this point, and such choices are down to you.</p>
",0
35200056,35199751,1,"<p>You can open any file extension in C. Only if you have permissions. Also, Bathsbeba answer is correct, just check out <a href=""https://www.openoffice.org/dev_docs/source/file_extensions.html"" rel=""nofollow"">this</a> link to see what are the main types of extensions. </p>

<p>To open a file with any extension, do this:</p>

<pre><code>fopen (""file.extension"", ""your mode"");
</code></pre>

<p>You can open it in binary and text formats. If you do not know how to open in binary, this is an example:</p>

<pre><code>fopen (""file.extension"", ""wb"");
</code></pre>

<p>To open in <code>write binary</code> mode.</p>
",0
35240087,35240023,2,"<p>Not really easy to spot as usually bugs like this are down to i &amp; j typos.
The <code>return max;</code> is inside the row's for loop.</p>

<p>Move it to the end of the function and then you'll examine every row of the matrix. I actually compiled and ran this fix.</p>

<p>The way to discover such errors, is to either put in extra print statements, like :</p>

<pre><code>printf( ""a[%d][%d]=%d "", i, j, a[i][j]);
</code></pre>

<p>Or to step through your program with a debugger, setting a break point on the code you're interested in.</p>
",2
35241884,35241738,0,"<pre><code>scanf(""%d %d"",&amp;x,&amp;y);
int kancelar[x][y];
</code></pre>

<p>You cannot create an array with variable values, you can do this with only constant values. So to create a custom array you need to allocate memory for you array dynamically  </p>

<p>I have taken this code from this link : <a href=""https://www.eskimo.com/~scs/cclass/int/sx9b.html"" rel=""nofollow"">LINK</a></p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    int r, c;
    scanf(""%d %d"",&amp;r,&amp;c);

    // allocating memory
    int *arr = (int *)malloc(r * c * sizeof(int));

    int i, j, count = 0;
    // giving them default values
    for (i = 0; i &lt;  r; i++)
      for (j = 0; j &lt; c; j++)
         *(arr + i*c + j) = ++count;

    // printing the values 
    for (i = 0; i &lt;  r; i++)
      for (j = 0; j &lt; c; j++)
         printf(""%d "", *(arr + i*c + j));

   // free memory
   free(arr);

   return 0;
}
</code></pre>

<p>Check out the link as they show <strong>more than one ways</strong> to achieve this</p>
",5
35241962,35241738,1,"<p>You are getting messed up by the <code>newline</code>s present in the input buffer by the press of the <kbd>Enter</kbd> key after each input. You need to consume the newline each time before going for the <code>getchar()</code>.</p>

<p>A simple solution may look like</p>

<pre><code>printf(""Array size:"");
scanf(""%d %d%*c"",&amp;x,&amp;y);  //eat up the newline
int kancelar[x][y];
int i;
int q;
for(q = 0;q &lt; x;q++)
{
    for(i = 0;i &lt; y;i++ )
    {
        kancelar[q][i] = getchar();
        getchar(); //eat up newline
    }

}
</code></pre>
",1
44741380,44741326,4,"<p>On Windows, there is <a href=""https://msdn.microsoft.com/de-de/library/windows/desktop/bb773584(v=vs.85).aspx"" rel=""nofollow noreferrer"">PathFileExists()</a>.</p>

<p>On a POSIX system, you have <a href=""https://linux.die.net/man/2/stat"" rel=""nofollow noreferrer"">stat()</a> or <a href=""https://linux.die.net/man/2/access"" rel=""nofollow noreferrer"">access()</a>.</p>

<p>That said, if you check for existence of the file because your code needs the file, this is the wrong approach -- file systems are out of your program's control, so this would be a race condition, the only correct way would be to properly handle errors when opening the file.</p>
",5
44741436,44741326,5,"<p>You are thinking about the problem the wrong way.  You shouldn't ever ""check whether a file already exists"", because that has an inherent <a href=""https://cwe.mitre.org/data/definitions/367.html"" rel=""noreferrer"">TOCTOU race</a> ¡ª in between the time you check whether the file exists, and the time you act on that information, another process may come along and change whether the file exists, rendering the check invalid.</p>

<p>What you do instead depends on why you want to know.  One very common case is that you only want to create the file if it doesn't already exist, in which case you use the lower-level <code>open</code> function in <code>O_EXCL</code> mode:</p>

<pre><code>int fd = open(""whatever"", O_WRONLY|O_CREAT|O_EXCL, 0666);
if (fd == -1 &amp;&amp; errno == EEXIST) {
    /* the file already exists */
} else if (fd == -1) {
    /* report that some other error happened */
} else {
    FILE *fp = fdopen(fd, ""w"");
    /* write data to fp here */
}
</code></pre>

<p>Another very common case is that you want to create the file if it doesn't exist, or <em>append</em> new data to the file if it does; this can be done with the <code>""a""</code> mode to <code>fopen</code> or <code>O_APPEND</code> flag to <code>open</code>.</p>
",5
36486250,36485512,1,"<p>The image below shows the step by step breakdown of whats happening with your link list append operations.</p>

<p>Basically the first time round head and tail point to the new element which has NULL prev and next pointers.</p>

<p>The second time round the head points to the old item and the tail points to the new item. The new item has both prev and next set to the existing item. Only the prev should point to the old item, next should be NULL. You must also update the old item next pointer to point to the new item which you have not done.</p>

<p>As it stands the old element is still first in the list and the next pointer is still NULL so you only get one output.</p>

<p><a href=""https://i.stack.imgur.com/0t9bi.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/0t9bi.png"" alt=""Step by step addition to linked list""></a></p>

<p>Your append code should probably be like this:</p>

<pre><code>ConsoleInfo *new = CI_new(name, ip, list-&gt;tail, NULL);
list-&gt;tail-&gt;next = new;
list-&gt;tail = new;
</code></pre>

<p>(But I have not tested that.)</p>
",0
36486235,36485512,1,"<p>I'm not a C expert, but this part doesn't make sense for a linked list:</p>

<pre><code>ConsoleInfo *new = CI_new(name, ip, list-&gt;tail, list-&gt;head);
list-&gt;tail = new;
list-&gt;head = new-&gt;next;
</code></pre>

<p>It should be</p>

<pre><code>ConsoleInfo *new = CI_new(name, ip, list-&gt;tail, NULL);
list-&gt;tail-&gt;next = new
list-&gt;tail = new;
</code></pre>

<p>I counldn't test this, since I'm not sure how to get your code to run.</p>
",0
37038115,37037299,1,"<p>I believe the problem is because the odd way you are storing the head and tail pointers to the start and end of the list in a root node and then mixing that interchangeably with the actual nodes of the list. This confusion could be eliminated if you just have simple <code>Node *head</code> and <code>Node *tail</code> pointers, but that is only a suggestion.</p>

<p>In your delete function, you set the root node to effectively <code>rt-&gt;fwd</code>, which is fine for forwards traversal as <code>rt-&gt;fwd-&gt;fwd</code> is what is desired, but you forget to consider the value of <code>rt-&gt;fwd-&gt;bwd</code> which is always pointing at NULL  for the first item in the list (as there is nothing technically before this node), not the actual tail of the list which is the desired functionality by that logic.</p>

<p>This obviously causes a problem when you try to use it to iterate backwards as it thinks the list is empty. You should change your deletion code to something like this:</p>

<pre><code>void deleteFirst(Node *rt)
{
  if (rt == NULL)
  {
    return; /* Return if an invalid root was passed in */
  }

  if (rt-&gt;fwd == NULL) {
    return; /* Return if the list is already empty */
  }

  Node *tmpfwd = rt-&gt;fwd; /* Store the current ""head"" */

  rt-&gt;fwd = rt-&gt;fwd-&gt;fwd; /* Set the root's head to the current head's next node */
  rt-&gt;fwd-&gt;bwd = NULL; /* Set the new head's previous node to NULL as it is the start of the list */

  free(tmpfwd); /* Delete the old ""head"" */
}
</code></pre>

<p>There are a lot of other problems here regarding edge cases and things the comments have mentioned (just the overall design makes this very problematic) but I think this is the problem you are having currently.</p>
",4
41002664,41002638,9,"<p>Unlike C++ which treats <code>struct</code> tags as new type names, C requires an explicit typedef if you wish to use <code>Node</code> without <code>struct</code>:</p>

<pre><code>typedef struct Node Node;
</code></pre>

<p>Alternatively, you could use <code>struct Node</code> in your declaration:</p>

<pre><code>struct Node* hashtable[HashArraySize];
</code></pre>
",3
41002680,41002638,6,"<p>Change <code>Node* hashtable[HashArraySize];</code> to <code>struct Node* hashtable[HashArraySize];</code></p>

<p>or </p>

<pre><code>typedef struct Node  {
    position* p;
    struct Node* next;
    struct Node* prev;
} Node;
</code></pre>
",0
36808953,36807114,0,"<p>When passing an array as argument, array decays into the pointer of FIRST element of array. One must define a rule, to let the method know the number of elements.</p>

<p>You declare <code>char mbuf[16]</code>, you pass it to <code>setName()</code>, <code>setName()</code> will not get <code>char[]</code>, but will get <code>char*</code> instead.</p>

<p>So, the declaration should be</p>

<pre><code>static void setName(const char* str, char* buf)
</code></pre>

<p>Next, <code>char mbuf[16]</code> can only store 15 chars, because the last char has to be 'null terminator', which is '\0'. Otherwise, the following situation will occur:</p>

<blockquote>
  <p>// if I use buf in my code it is leading to spurious characters since length is greater than 16 .</p>
</blockquote>

<p>Perhaps this will help you understand:</p>

<pre><code>char str[] = ""foobar""; // = {'f','o','o','b','a','r','\0'};
</code></pre>

<p>So the code should be</p>

<pre><code>static void setName(const char* str, char* buf)
{
    int sz = MIN(strlen(str), 15); // not 16
    for (int i = 0; i &lt; sz; i++) buf[i] = str[i];
    buf[sz] = '\0'; // assert that you're assigning 'null terminator'
}   
</code></pre>

<p>Also, I would recommend you not to reinvent the wheel, why don't use <code>strncpy</code> instead?</p>

<pre><code>char mbuf[16];
strncpy(mbuf, ""12345678901234567890"", 15);
</code></pre>
",9
42665821,42664872,2,"<p>Addressing the question, yes there are several advantages in implementing a function for each type, and in some cases is mandatory. Some libraries which are aimed for high performance
use very specific instructions in order to handle the fetch/processing/write of the data an efficient manner based on the variable type.</p>

<p>A clear example of this is would be the case for <code>float</code> and <code>int</code>, even when they have the same size (for 32 bit processors),
the representation is comp?etely different and the operation is handled by a different operational unit, <a href=""https://en.wikipedia.org/wiki/Arithmetic_logic_unit"" rel=""nofollow noreferrer""><code>ALU</code></a> for <code>int</code> and <a href=""https://en.wikipedia.org/wiki/Floating-point_unit"" rel=""nofollow noreferrer""><code>FPU</code></a> for <a href=""https://en.wikipedia.org/wiki/IEEE_floating_point"" rel=""nofollow noreferrer""><code>float</code></a>s.</p>

<p>Also only for a C11 compiler you could use the <a href=""http://en.cppreference.com/w/c/language/generic"" rel=""nofollow noreferrer""><code>_Generic()</code></a> but if you are using <code>C99</code> there's no way to know the type of the variable. <a href=""https://stackoverflow.com/questions/6280055/how-do-i-check-if-a-variable-is-of-a-certain-type-compare-two-types-in-c"">(AFAIK)</a>
<code>_Generic()</code> works at compile time so either you end up with a function for each type.</p>
",0
42666646,42664872,0,"<p>It depends what your functions do.  If they do not actually use the data at all then <code>void*</code> could be correct, whereas if they do need to know anything about the data then specifying the types is the correct way to go.</p>

<p>For example, your dynamic array library probably does not need separate functions to add, remove, sort (etc) <code>int</code> and <code>float</code> data items to the array.  In this instance the functions do not need to know anything about the type of the object being stored, just its location; in which case passing a <code>void*</code> is correct.</p>

<p>On the other hand, the matrix library may need different prototypes for the different data types, because <code>int</code> and <code>float</code> (etc) data use different instructions to manipulate them.</p>
",0
42669198,42664872,2,"<p>You could easily and correctly write a function <strong>matrixop(void *arg, int type_of_arg, etc)</strong> and then cast <strong>arg</strong> as necessary according to <strong>type_of_arg</strong>. Of course, as has already been said, for the function to work correctly, some operations might have to be performed differently for different <strong>type_of_arg</strong>'s. But the user wouldn't have to know that, and would see just the one function. And since you say, ""get my head wrapped around C more and especially pointers"", I'd definitely recommend you give it a try this way. Your particular matrix example may not be the very, very best situation where void pointers are most useful, but it's definitely fine and dandy for practice.</p>
",0
42670363,42664872,1,"<blockquote>
  <p>My question is, is there an advantage in having a function/struct for each data type?</p>
</blockquote>

<p>Yes. It adds compile-time type checking.</p>

<p>The code used to implement the same operation for different types does differ, and not necessarily by just the element type used. (For matrix operations, the optimum caching strategy may differ between integer and floating-point types of the same size, for example; especially if the hardware supports vectorization.) This means each element type requires their own version of each operation.</p>

<p>It is possible to use some templating techniques to generate element type specific versions of operations that only differ by the type, but usually the end result is more complicated (and thus harder to maintain) than just maintaining the slightly differing implementations separately. </p>

<p>It is quite possible to add an additional layer -- no modifications, just an additional header file included after GSL --, using the preprocessor and either GCC extensions (<code>__typeof__</code>) or C11 <code>_Generic()</code> to present a single ""function"" for each matrix operation, that chooses the function called at compile time based on the type of the parameter(s).</p>

<blockquote>
  <p>Why not just use a void pointer instead to only have one set of those structs/functions?</p>
</blockquote>

<p>Because not only do you lose the compile-time type checking -- the user can supply say a literal string, and the compiler won't warn about it, no matter what warnings are enabled --, but it would also add run-time overhead. </p>

<p>Instead of choosing the proper function (implementation) to call at compile time, the data type field would have to be examined and the correct function called at run time. The generic matrix multiply function, for example, might look like</p>

<pre><code>status_code_type matrix_multiply(void *dest, void *left, void *right)
{
    const element_type  tleft = ((struct generic_matrix_type *)left)-&gt;type;
    const element_type  tright = ((struct generic_matrix_type *)right)-&gt;type;

    if (tleft != tright)
        return ERROR_TYPES_MISMATCH;

    switch (tleft) {
    case ELEMENT_TYPE_INT:
        return matrix_mul_int_int(dest, left, right);
    case ELEMENT_TYPE_FLOAT:
        return matrix_mul_float_float(dest, left, right);
    case ELEMENT_TYPE_DOUBLE:
        return matrix_mul_double_double(dest, left, right);
    case ELEMENT_TYPE_COMPLEX_FLOAT:
        return matrix_mul_cfloat_cfloat(dest, left, right);
    case ELEMENT_TYPE_COMPLEX_DOUBLE:
        return matrix_mul_cdouble_cdouble(dest, left, right);
    default:
        return ERROR_UNSUPPORTED_TYPE;
    }
}
</code></pre>

<p>All of the above code is pure overhead, with the sole purpose of making it ""slightly easier"" on the programmer.  The GSL developers, for example, didn't find it necessary or useful.</p>

<hr>

<p>Quite a lot of C code -- including most C libraries' <code>FILE</code> implementation -- does utilize a related approach, however: the data structure itself contains function pointers for each operation the data type supports, in an object-oriented fashion.</p>

<p>For example, you could have</p>

<pre><code>struct matrix {
    long     rows;
    long     cols;
    long     rowstep; /* Number of bytes to next row */
    long     colstep; /* Number of bytes to next element */
    size_t   size;    /* Size of each element */
    int      type;    /* Type of each element */
    char    *data;    /* Logically void*, but allows pointer arithmetic */
    int    (*supports)(int, int);
    int    (*get)(struct matrix *, long, long, int, void *);
    int    (*set)(struct matrix *, long, long, int, const void *);
    int    (*mul)(struct matrix *, long, long, int, const void *);
    int    (*div)(struct matrix *, long, long, int, const void *);
    int    (*add)(struct matrix *, long, long, int, const void *);
    int    (*sub)(struct matrix *, long, long, int, const void *);
};
</code></pre>

<p>where the </p>

<pre><code>int supports(int source_type, int target_type);
</code></pre>

<p>is used to find out whether the other callbacks support the necessary operations between the two types, and the rest of the member functions,</p>

<pre><code>int get(struct matrix *m, long row, long col, int to_type, void *to);
int set(struct matrix *m, long row, long col, int from_type, void *from);
int mul(struct matrix *m, long row, long col, int by_type, void *by);
int div(struct matrix *m, long row, long col, int by_type, void *by);
int add(struct matrix *m, long row, long col, int by_type, void *by);
int sub(struct matrix *m, long row, long col, int by_type, void *by);
</code></pre>

<p>operate on a single element of a given matrix. Note how we need to pass a reference to the matrix itself; if we call e.g. <code>some-&gt;get(...)</code>, the function that the <code>get</code> function pointer points to, does not automatically get a pointer to the structure via which it was called.</p>

<p>Also note how the value read from the matrix (<code>get</code>), or otherwise used in the operation, is provided via a pointer; and the type of the data specified by the pointer is separately provided. This is needed, if you want a function that say initializes a matrix to identity to work, without the user implementing every single matrix operation function for their custom type themselves.</p>

<p>Because access to an element involves an indirect call, the overhead of the function pointers is quite significant -- especially if you consider how simple and fast the single-element operations actually take. (For example, a 5 clock cycle indirect call overhead on an operation that itself only takes 10 clock cycles, adds 50% overhead!)</p>
",0
36274172,36273875,1,"<p>There are a few issue with your code. However, the direct answer to your question is in this loop:</p>

<pre><code>for (int j = 0; j &lt; (sizeof(numbers) / sizeof(char*)); j++){
        temp = rep_str(temp, numbers[j], words[j]);
}
</code></pre>

<p>You are calling <code>rep_str</code> for every digit while you mean call <code>rep_str</code> only if the digit in <code>temp</code> matches the corresponding digit in <code>numbers</code>. So add this conditional <code>if(strcmp(temp,numbers[j]) == 0)</code> right before the line <code>temp=...</code>. Then it'll solve your current problem. </p>

<p>The segfault is caused because there are only three elements in the <code>words</code> array. Your old loop indexes from 0 to 9 and fails when <code>j=3</code>, out of bound.</p>

<p>Also, delete the <code>free()</code> at the end of your program. <code>test</code> was never allocated and will cause a core dump.</p>
",1
36274375,36273875,0,"<pre><code>ret = (char*)malloc(i + count * (newlen - oldlen));
</code></pre>

<p>There are a few problems with this line of code.</p>

<ul>
<li>For a start, <a href=""https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc"">don't cast malloc</a> (or any <code>void *</code> that you're assigning to a variable of different pointer type, or vice versa).</li>
<li>If you intended to allocate space to store a string, where's the string-terminating <code>'\0'</code> going to go? You need to realise that for an empty <code>old</code> string, this will be <code>malloc(0)</code> and zero bytes is not enough to store an empty string.</li>
<li>There's also a problem if you expect that <code>old</code> may be a substring of <code>new</code> (for example, you're replacing <code>""0""</code> with <code>""hell0""</code>). You'll need to tweak your algorithm to handle this problem. I'll leave that as a challenge for you to attempt :)</li>
</ul>

<hr>

<pre><code>for (int i = 0; i &lt; tempSize; i++){
    if (isdigit(temp[i])){
        for (int j = 0; j &lt; (sizeof(numbers) / sizeof(char*)); j++){
            temp = rep_str(temp, numbers[j], words[j]); //it makes it to this line, but never gets to assert()
        }
    }
}
</code></pre>

<p><a href=""https://stackoverflow.com/a/36274172/1989425"">users previous answer</a> highlighted this code correctly, but not for the right reason... and so the solution he/she presented is wrong.</p>

<p><a href=""https://stackoverflow.com/questions/8877410/visual-c-debug-assertion-failed""><code>isdigit(temp[i])</code> may also cause segfaults for some inputs.</a> I recommend using <code>isdigit((unsigned char) temp[i])</code> instead, in this case.</p>

<p>It's not valid to access <code>words[j]</code> where <code>word_count</code> is 3 and <code>j</code> is greater or equal to 3; you're accessing that array out of bounds.</p>

<p>You also need to be careful to <code>free</code> any memory you <code>*alloc</code> (while simultaneously not <code>free</code>ing memory that you don't <code>*alloc</code>). Forgetting to do the former won't cause crashes, but your program won't run happily; it'll use <em>heaps</em> of memory.</p>

<p>Consider something like this, instead:</p>

<pre><code>temp = strdup(temp);
if (temp == NULL) {
    exit(EXIT_FAILURE);
}
for (int i = 0; i &lt; tempSize; i++){
    if (isdigit((unsigned char) temp[i])){
        for (int i = min(word_count, sizeof(numbers) / sizeof(char*)), j = 0; j &lt; i; j++){
            char *new = rep_str(temp, numbers[j], words[j]);
            free(temp);
            temp = new;
        }
    }
}
</code></pre>
",0
36526992,36526958,0,"<p>If you use an older compiler, I think all pre-C99 compilers, all the declarations in a function must come before any function calls. Move the line</p>

<pre><code>clrscr();
</code></pre>

<p>after you have declared all the variables, i.e. move it after the line</p>

<pre><code>float mean,Tfd=0;
</code></pre>

<p>You can use your existing code if your compiler supports C99 (through the use of a compiler flag, perhaps). Then you need to find how to enable it.</p>
",1
42635674,42635627,7,"<pre><code>(user_input != '.') || (user_input != '?') || (user_input != '!')
</code></pre>

<p>The above doesn't evaluate the way you think it does. For the condition to be false (and the loop to stop) all three clauses must be false. That means that all respective inverses must be true, i.e:</p>

<pre><code>(user_input == '.') &amp;&amp; (user_input == '?') &amp;&amp; (user_input == '!')
</code></pre>

<p>And that is of course impossible. A single character variable cannot contain three different values at once.</p>

<p>I assume you want the loop to terminate if the program receives either of those characters as input, so you need to check that the input is neither of those, meaning:</p>

<pre><code>(user_input != '.') &amp;&amp; (user_input != '?') &amp;&amp; (user_input != '!')
</code></pre>
",1
36339443,36339351,0,"<p>To begin with, you have <em>undefined behavior</em> in your code, as you do operations on an uninitialized variable.</p>

<p>Uninitialized local variables, like for example <code>s</code>, have an <em>indeterminate</em> value, and doing e.g. <code>s++</code> will lead to undefined behavior. The variable <code>s</code> is not the only one you don't initialize and then perform operations on.</p>

<p>Then when you initialize <code>s</code>, remember that the loop keeps on iterating <code>while (s &gt; 0)</code>, so if you initialize <code>s</code> to zero, then do <code>s++</code> that means that <code>s</code> <em>will</em> be larger than zero and the loop continues.</p>

<p>You should initialize (I recommend) <code>s</code> to zero, and then loop <code>while (s == 0)</code>.</p>

<p>Or, you know, just <code>break</code> out of the loop:</p>

<pre><code>if (last == 1)
    break;
// No else, no special loop condition needed, loop can be infinite
</code></pre>
",0
36340041,36339351,0,"<p>Your indentation made the do ... while loop look like it was an infinite loop. You also had an extra close bracket after the scores that removed the while from the do ... while. That actually made it an infinite loop.</p>

<pre><code>#include &lt;stdio.h&gt;

int main()

{
    int H, N, mark, s, n=0, last;
    /*Student Marks Input, Grade Output/Loop*/
    do
    {  
       // processing  
       if(last==0)
       {
          n++;
       }
       else if (last==1)
       {
          s++;
       }
    } // This converts the do ... while into an infinite loop

    while(s&gt;0); // This is an invalid while since it never gets here
</code></pre>

<p>Change this to a while at the beginning</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    int H, N, mark, last;
    int s = 0;
    int mark = 0;
    /*Student Marks Input, Grade Output/Loop*/

    while (s &lt; 1) // First loop runs sinc s is initialized to 0.
    {  
        // Get the entry for the next pass through the loop.
        printf(""Please enter your marks:"");
        scanf(""%d"", &amp;mark);  

        // Perform your processing

       /*Decisions*/

       printf(""Are you the last student?(Y=1/N=0):"");
       scanf(""%i"", &amp;last);


        if(last==0)
        {
          n++;
        }
        else if (last==1)
        {
          s++;
        }
      // This is the end of the while loop
      }

      /*Results*/

      if(H&gt;N)
        printf(""Good Results"");
      else
        printf(""Bad Results"");

      return 0;
}          
</code></pre>

<p>Now it will exit the loop as you intended when the last student enters the mark</p>
",0
36440149,36439789,0,"<p>Some things that stand out:</p>

<p>1) Read about how to use <a href=""http://www.cprogramming.com/tutorial/printf-format-strings.html"" rel=""nofollow""><code>printf</code></a> -- it's pretty different if you're new to C. You pass it a single string as the first parameter and a list of args as the rest, and you represent the args in the string using % followed by a type identifier. For example: <code>%d</code> for an int, so:</p>

<pre><code>printf(""You roll 3 dice: %d %d %d"", playerdie1, playerdie2, playerdie3);
</code></pre>

<p>2) C does not have nested functions; you'll want to move your definition of <code>int initial3roll()</code> outside of <code>main</code> on it's own. It should look similar to your definition of <code>main</code>.</p>

<p>3) C does not have tuples, so this won't work:</p>

<pre><code>(playerdie1,playerdie2,playerdie3) = int initial3roll();
</code></pre>

<p>You'll have to return a single <code>int</code> from <code>initial3roll</code> unless you want to use pointers or pass in reference parameters. You might want to consider just running this function 3 times instead, one roll each, to simplify things. Or just remove it altogether and use <code>rand</code> on its own.</p>

<p>4) Each <code>case</code> needs a colon after the number and should probably be on its own line (for clarity). The <code>default</code> case is correct.</p>

<p>5) Make things easier on yourself and properly indent your code. Your editor can probably do this for you; search around for how. It's hard to follow like this.</p>
",2
40754717,40754554,0,"<p>When you start program you can give it some data over terminal (like you are doing in your example) or you can explicitly ask user to give you some data via scanf() function.</p>

<p>For your example you could use something like:</p>

<pre><code>int main() {
    // You need to allocate space for something that you will read.
    char input[100];
    // You need to know how many things you want to read.
    while(something)
        scanf(""%s"", input)
} 
</code></pre>

<p>Downside of that is that you need to know in front how long your word is gona be and how many words you will have so you can save them in some array if you want to sort them or do with them for something else (or use c++ with list or vector or set or something else for saving and string for saving words, set will sort words for you ;) ).</p>
",4
36607372,36607248,1,"<p>You have</p>

<pre><code>void printRecords (STUREC records[], int count)

STUREC records[ARRAY_MAX];
int count;
int i;
{
</code></pre>

<p>But I guess you want:</p>

<pre><code>void printRecords (STUREC records[], int count)
{
    int i;
</code></pre>

<p><strong>EDIT:</strong>
Thanks to callyalater for noting the redeclaration of the parameters in the function...</p>
",3
36607576,36607248,3,"<p>If you want to use <a href=""https://stackoverflow.com/questions/1585390/c-function-syntax-parameter-types-declared-after-parameter-list"">old style C parameter declarations</a>, you need to do this:</p>

<pre><code>void printRecords(records, count)
    STUREC records[ARRAY_MAX];
    int count;
{
    int i;
    // ... rest of the code ...
}
</code></pre>

<p>But this is not considered a good practice and can make your code harder to read. Some compilers have even stopped supporting this syntax.</p>

<p>The other comments/answers are saying that you <em>re-declare</em> (and therefore hide) your function parameters in the body of the function, but this is not what you want to do (otherwise you effectively lose the parameters being passed in).</p>

<p>If you define a function like this:</p>

<pre><code>void fxn(int num) {
    int num;
    num = num;
}
</code></pre>

<p>What does <code>num</code> refer to: the parameter or the local variable?</p>

<p>Either do this:</p>

<pre><code>void printRecords(records, count)
    STUREC records[ARRAY_MAX];
    int count;
{
    int i;
    // ... rest of the code ...
}
</code></pre>

<p>or do this:</p>

<pre><code>void printRecords(STUREC records[], int count)
{
    int i;
    // ... rest of the code ...
}
</code></pre>

<p>But don't try to do both or a mixture of the two.</p>
",9
41174647,41171863,1,"<p>Although the question wasn't clear, I think I've got it...</p>

<p><strong>Notes</strong>:</p>

<ul>
<li>I assume that <code>scanner</code> contains dummy data and is used to mock the device.</li>
<li><p>I am using <em>VStudio 10</em> (on 64bit <em>Win10</em>), so certain things in your code won't work:</p>

<ul>
<li>The binary formatted numbers (e.g. <em>0b00000001</em>), so I had to convert them (to hex).</li>
<li>Some assignments (e.g. <code>unsigned char *DDRA  = (unsigned char *)0x0002;</code> which is trying to dereference the 2nd memory byte, and that's not allowed).</li>
</ul></li>
<li><p>However, I've also found some issues that no compiler would like:</p>

<ol>
<li>The assignment: <code>*PORTB = pattern(scanner[index]/32);</code>, while <code>pattern</code> returns nothing: <code>void pattern(char threshold)</code>.</li>
<li>Referencing <code>pattern</code> and <code>wait</code> from <code>main</code>, when they haven't been declared.</li>
</ol></li>
</ul>

<p>So, I have 2 questions:</p>

<ul>
<li>Does the code even compile?</li>
<li>What compiler are you using?</li>
</ul>

<p>As I said that I had to modify the code to compile on my environment (especially the binary number problems), I'm not going to post the whole code snippet that would do the trick, but instruct what portions of the existing code (<strong>in the question code snippet</strong>, so you would have to update the code on your machine/device with what's in your question) to replace with what.</p>

<ul>
<li><p>For problem <em>1.</em> (that I mentioned above): the function should return an <code>unsigned char</code>:</p>

<ul>
<li>The function definition: <code>void pattern(char threshold)</code> should be changed to <code>unsigned char pattern(char threshold)</code>.</li>
<li>You have to return something from it (I assume it's <code>display</code>), so add <code>return display;</code> before the function closing brace (<code>}</code>).</li>
</ul></li>
<li><p>For problem <em>2.</em>, either:</p>

<ul>
<li><p>Forward declare (add the 2 lines of code below) <code>wait</code> and <code>pattern</code> <strong>before</strong> <code>main</code>'s declaration (<code>int main(void) {</code>):</p>

<p><code>void wait(int seconds);</code><br>
<code>unsigned char pattern(char threshold);</code></p></li>
<li><p>Move <code>wait</code> and <code>pattern</code> function bodies before <code>main</code>.</p></li>
</ul></li>
<li><p>A 3rd  (minor, I suppose typo) problem that I fixed when I edited the question was that the 4th <code>LedTable</code> element was missing the <code>0b</code> marker at the beginning.</p></li>
</ul>

<p>Now, the logical problem (and some others) relies in the <code>do/while</code> loop (as you said - or better: as you were told). So, I suggest to replace that loop:</p>

<pre><code>do {
    *PORTB = pattern(scanner[index]/32);
    wait (1);
} while ((index&lt;=scanner[0]) &amp;&amp; (read&lt;threshold));
</code></pre>

<p>by:</p>

<pre><code>while (((index &lt;= read) &amp;&amp; (scanner[index] &lt; threshold))) {
    *PORTB = pattern(scanner[index] / 32);
    //printf(""pattern(scanner[%d]/32): %02X - %d\n"", index, pattern(scanner[index] / 32), scanner[index]);
    wait(1);
    index++;
};
</code></pre>

<p>Explanation:</p>

<ul>
<li>by changing the <code>do/while</code> into <code>while</code> loop, I am avoiding some corner cases that might arise involving either the 1st or the last element in the array.</li>
<li><code>index++;</code> - that's the error that @DavidC.Rankin spotted: if you don't increment <code>index</code> it will have the same value (that you assign to it before entering the loop), and the loop will never end.</li>
<li>the loop conditions(I'm going to go over them from right to left in the original code):

<ul>
<li>compare <code>threshold</code> to <code>read</code> or the array index makes no sense.</li>
<li>compare <code>index</code> to <code>read</code> instead of <code>scanner[0]</code> - <strong>this is optional</strong> the 2 have the same value, I chose this form because it's more efficient.</li>
</ul></li>
</ul>

<p>The last change is: replace <code>if (index &lt; threshold) {</code> by <code>if (index &lt; read) {</code> as it makes no point comparing an array index (after exiting the <code>while</code> loop) to a value (that might be in that array) - same thing as above.</p>
",0
36712318,36712089,0,"<p>The function structure should look like this</p>

<pre><code>trace* readTrace(char* fileName)
{
    trace* traceptr;
    int no_of_elements;

    // Read the no of trace elements stored in file
    // Generally this is avaliable in a location in the start of file,
    // If not, then you have to guess and resize if it falls short.

    traceptr = malloc(sizeof(trace) * no_of_elements);

    // Read the trace elements from file

    return (traceptr);
}
</code></pre>

<p>To call it in main()</p>

<pre><code>int main(void)
{
    trace *traceptr;
    // Other stuff

    traceptr = readTrace(filename);

    simuTrace(NBPTS, DT, Pa, traceptr);

}
</code></pre>

<p>You need to modify your <code>printTrace</code> function to take a pointer to struct as input instead of an entire structure. Then it can take <code>traceptr</code> as it's input. Similarly for the <code>saveTraceBin</code> function.</p>
",2
36836415,36836334,1,"<p>You can't assign to an array. You'll need to say something like this:</p>

<pre><code>char *result = callMe(buf_t, ""Test successful : %d"", test_flag);
printf(""\n\n Result = %s"", result);
</code></pre>

<p>You've also got a problem with this line:</p>

<pre><code>vsnprintf(buf_test, sizeof(buf_test), fmt, ap);
</code></pre>

<p><code>buf_test</code> is delcared as a <code>char*</code> so applying <code>sizeof</code> to it will return the size of a pointer. Since you're getting ""Test su` back it implies that the pointer size is 8 bytes. Although the variable points to an array the compiler has no way of inferring this.</p>

<p>What you need to so is pass the size of the buffer into the function:</p>

<pre><code>char * callMe(char *buf_test, size_t size, const char *fmt, ...)
{
   va_list ap;
   va_start(ap, fmt);
   vsnprintf(buf_test, size, fmt, ap);
   va_end(ap);
   return buf_test;
}
</code></pre>

<p>and then pass the size when you make the call:</p>

<pre><code>callMe(buf_t, sizeof(buf_t), ""Test successful : %d"", test_flag);
</code></pre>

<p>The compiler will be able to work out the size of the array here because it has access to the full definition of the variable.</p>
",5
36836457,36836334,-1,"<p>As the error indicates, you cannot assing the result to an array. Instead, you can use a pointer by changing this line :</p>

<pre><code> buf_t = callMe(buf_t, ""Test successful : %d"", test_flag);
</code></pre>

<p>to :</p>

<pre><code> char *success;
 success = callMe(buf_t, ""Test successful : %d"", test_flag);
</code></pre>

<p>and therefore modify your <code>print</code> statement to :</p>

<pre><code>printf(""\n\n Result = %s"", success);
</code></pre>
",2
38409132,38409107,0,"<p>You were missing an <code>&amp;</code> ampersand when taking values from user. You have to take the values in the address of the variable and not the variable itself, so use <code>&amp;</code> while taking values from user in <code>scanf</code> function.</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;
void main(){
    int a,b,c;
    printf(""Enter the 1st number:"");
    scanf(""%d"",&amp;a);
    printf(""Enter the 2nd number:"");
    scanf(""%d"",&amp;b);
    c=a*b;
    printf(""The value of %d * %d is %d"",a,b,c);
    getch();
}
</code></pre>
",5
37340754,37340558,2,"<p>Numbers are a matter of arithmetic. <code>1</code>, <code>01</code>, <code>1.0</code>, <code>1.000</code>, <code>0x01</code>, <code>1e0</code> all describe the same number: whichever representation you use has the same mathematical properties, and behaves identically in calculation (ignoring the matter of computer storage of numbers as <code>int</code> or <code>float</code> or <code>double</code>... which is again another matter entirely).</p>

<p>The representation of a number is a matter of sequences of characters, or strings. Representations of numbers can be formatted differently, and can be in different bases, but can't be calculated with directly by a computer. To store leading zeroes, you need a string, not an int.</p>

<p>You typically convert from number representation to number at input, and from number to number representation at output. You would achieve your stated desire by not converting from number representation to number at input, but leaving it as a string.</p>
",0
37345110,37340558,0,"<p>You don't want to store <code>012</code>, you want to store <code>0.012</code>.</p>

<p>The value 0.012 in binary is (approximately):</p>

<pre><code>0.00000011000100100110111010010111b
</code></pre>

<p>..and the value 12.012 is (approximately):</p>

<pre><code>110.00000011000100100110111010010111b
</code></pre>

<p>Note that 0.012 is impossible to store precisely in binary because it would consume an infinite number of bits; in the same way that 1/3 can't be written precisely in decimal (0.333333333.....) because you'd need an infinite number of digits.</p>

<p>Let's look at 12.012. In hex it's this:</p>

<pre><code>0x0000000C.03126E97
</code></pre>

<p>This makes it easier to see how the number would be stored in a pair of 32-bit integers. The integer part in one 32-bit integer, and the fractional part in another 32-bit integer.</p>

<p>The first problem is that you're using signed 32-bit integers, which means that one of the bits of the fraction is wasted for a sign bit. Essentially, you're using a ""sign + 31 bit integer + wasted bit + 31 bit fraction"" fixed point format. It'd be easier and better to use an unsigned integer for the fractional bits.</p>

<p>The second problem is that standard C functions don't support fixed point formats. This means that you either have to write your own ""string to fixed point"" and ""fixed point to string"" conversion routines, or you have use C's floating point conversion routines and write your own ""floating point to fixed point"" and ""fixed point to floating point"" conversion routines.</p>

<p>Note that the latter is harder (floating point is messy), slower, and less precise (double floating point format only supports 53 bits of precision while you can store 62 bits of precision).</p>
",1
37350593,37340558,0,"<p>A <em>fraction</em> does not consists of a single integer.  A <em>fraction</em> consists of 2 integers: numerator/denominator.  </p>

<p>Code needs to keep track of width of the fraction input.  Could use <code>""%n""</code> to record offset in scan.</p>

<pre><code>#include &lt;stdio.h&gt;

struct real_number {
    int ipart;
    int num;
    int den_pow10;
};

void main(void) {
    struct real_number num1;
    printf(""input the number : "");
    fflush(stdout);

    int n1 = 0;   
    int n2 = 0;   
    scanf(""%d.%n%d%n"",&amp;num1.ipart, &amp;n1, &amp;num1.num , &amp;n2):
    if (n2 == 0) {
      fprintf(stderr, ""bad input\n"");
      return -1;
    }
    num1.den_pow10 = n2 - n1;
    printf(""%d.%*0d"",num1.ipart,num1.den_pow10, num1.frac_num);
    return 0; 
}
</code></pre>

<p>Input/Output</p>

<pre><code>input the number : 12.00056
Result 12.00056
</code></pre>
",0
37394450,37394070,2,"<ol>
<li><p>Create function <code>drawDigit(int digit)</code> where <code>digit</code> is a single digit number between 0 and 9.<br>
You <em>can</em> use function pointers to select which <code>number</code> function to call, but if that is too complex, you can use the <code>if</code>/<code>else</code> method for now.</p></li>
<li><p>Convert score to string:</p>

<pre><code>int score = 259;
char digits[SIZE];  // Size must be large enough to hold all digits and nul character ('\0')
int numDigits = snprintf(digits, SIZE, ""%d"", score);  // snprintf is from ""stdio.h""
// digits contains now 4 character string ""259"" with nul character at the end
</code></pre></li>
<li><p>Loop over string to draw all digits:</p>

<pre><code>for(int i = 0; i &lt; numDigits; ++i) {
    int digit = digits[i] - '0';  // Convert character digit to numeric digit
    drawDigit(digit);
}
</code></pre></li>
</ol>

<p>You probably need extra a parameter to <code>drawDigit</code> function to adjust the horizontal placement, but I'll leave that exercise to the reader.</p>
",0
37394682,37394070,1,"<p><strong><em>Function pointers and switch/case are not the solution !</em></strong></p>

<p>The problem is not <em>if-statement</em> or even the functions. Since your algorithms to draw scores are very different in each function then you can not stop using lots of conditions, so you have to some where call them by lots of <code>if</code> statements.</p>

<p>The solution is to find an uniform algorithm to draw scores on the screen for every number. For example write 10 functions to draw digits between [0..9], then use this functions to draw numbers with arbitrary length numbers.</p>
",0
37394374,37394070,9,"<p>You can use an array of pointers to function and a recursive function to reverse the value:</p>

<pre><code>#include &lt;stdio.h&gt;

static void func0(void) { printf(""0\n""); }
static void func1(void) { printf(""1\n""); }
static void func2(void) { printf(""2\n""); }
static void func3(void) { printf(""3\n""); }

static void (*func[])(void) = {func0, func1, func2, func3};

static void exec(int value)
{
    if (value) {
        exec(value / 10);
        func[value % 10]();
    }
}

int main(void)
{
    exec(123);
    return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>1
2
3
</code></pre>

<p>As pointed out by @user3078414 in comments this fails when <code>exec(012)</code> is passed (the first <code>0</code> is not evaluated in the recursive function), in addition, <code>012</code> is interpreted as an octal (not as a decimal).</p>

<p>An alternative using strings:</p>

<pre><code>#include &lt;stdio.h&gt;

static void func0(void) { printf(""0\n""); }
static void func1(void) { printf(""1\n""); }
static void func2(void) { printf(""2\n""); }
static void func3(void) { printf(""3\n""); }

static void (*func[])(void) = {func0, func1, func2, func3};

int main(void)
{
    char *ptr = ""012"";

    while (*ptr) {
        func[*ptr - '0']();
        ptr++;
    }
    return 0;
}
</code></pre>
",7
37394422,37394070,1,"<p>You can use pointer to function, e.g:</p>

<pre><code>#include &lt;stdio.h&gt;

typedef void (*typ_callback)(int);

static void number1(int Q);
static void number2(int Q);

typ_callback my_table[] = { NULL, number1, number2 };

int main(void)
{
    size_t number;

    printf(""Entern the number of callback: "");
    scanf(""%zu"", &amp;number);

    if (number &lt;= (sizeof(my_table)/sizeof(my_table[0])))
    {
        if (my_table[number] != NULL)
        {
            my_table[number](number);
        }
    }
    else
    {
        fprintf(stderr, ""Wrong number\n"");
    }

    return 0;
}

static void number1(int Q)
{
    printf(""You called %s function with passing value %d\n"", __func__, Q);
}

static void number2(int Q)
{
    printf(""You called %s function with passing value %d\n"", __func__, Q);
}
</code></pre>
",0
37394858,37394070,2,"<p>It seems like functions number1(), number2(), etc are quite similar. I'd be against creating different functions; I'd rather create one single function (let's say number()) which receives the whole number ""632"" from your example, and loops digit by digit.</p>

<p>Creating one single function is easier to handle by you. Just check that the resulting function is not too big, but it's quite likely that functions number1(), number2(), etc have a lot of code in common. If that's the case, reducing redundancy and repetition in code is highly recommended!</p>

<p>Let me know if I'm right with this.</p>

<p>Cheers!</p>
",0
37757956,37757911,1,"<p>Always consider radix when doing bitwise operations. It defaults to decimal in your program.</p>

<p>10<sub>10</sub> <em>and</em> 0xa <em>and</em> 012 <em>and</em> 0b1010 <em>and</em> 1010<sub>2</sub>, all are notations for the same thing.</p>

<p>That is, just as your decimal 10<sub>10</sub> is 1 * 10 + 0, it's also 1 * 2<sup>3</sup> + 2<sup>1</sup> or perhaps, mixing radices, 8 + 2, so in binary, 01010<sub>2</sub>.</p>

<p>When you combine it via operators with 1 (which, mercifully, is the same in every radix) you are matching up with the rightmost 0 in your 10<sub>10</sub>.</p>
",0
37757974,37757911,0,"<p>Binary representation of 10 and 1 are as follows</p>

<p>10 = 1010</p>

<p>1 = 0001</p>

<p>So:</p>

<p>10 &amp; 1</p>

<p>=
 1010 &amp; 0001</p>

<p>=
0000</p>
",0
37757997,37757911,2,"<p>Remember, these are <strong>binary</strong> operators. You've got to look at the numbers' base 2 bits, not their digits, which are base 10. Let's do that. I'll use subscripts to indicate what base each number is written in.</p>

<p>First, let's <strong>convert the numbers to base 2</strong>.</p>

<blockquote>
  <p>10<sub>10</sub> = 1010<sub>2</sub> &nbsp;&nbsp;&nbsp;&nbsp;(ten in base 10 is ""1010"" in base 2)<br>
  1<sub>10</sub> = 1<sub>2</sub> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(in either base, one is written as ""1"")</p>
</blockquote>

<p>Next, we must remember to work <strong>right-to-left</strong>, not left-to-right. We can do that by padding the numbers with 0's. Just as 37 is the same as 037 in decimal &mdash;both are thirty-seven&mdash;1<sub>2</sub> is the same as 0001<sub>2</sub> in binary.</p>

<blockquote>
  <p>10<sub>10</sub> = 1010<sub>2</sub><br>
  01<sub>10</sub> = 0001<sub>2</sub></p>
</blockquote>

<p>Now perform the binary operations. Do you see now why 1010<sub>2</sub> &amp; 0001<sub>2</sub> is equal to 0000<sub>2</sub>?</p>
",1
37758014,37757911,0,"<p>In some versions of <a href=""https://stackoverflow.com/questions/2611764/can-i-use-a-binary-literal-in-c-or-c""><code>gcc</code> and other compilers</a>, you can use literal binary values, i.e. </p>

<pre><code> unsigned int x = 0b10;  
 unsigned int y = 0b01;
</code></pre>

<p>Then it will work the way you want it to.</p>
",0
37907624,37865768,0,"<p>This depend, as always, on the performance, size and maintenance/readability of your code.
In most case you probably need maintenance and readability so you keep your code clear with explicit variable name and don't reuse them to avoid confusion. 
In time critical code and/or on low resource system you probably want to reuse a lot because you want to avoid to load the stack too much.</p>

<p>If your compiler is C99 compliant, you can use restrict the variable scope for their usage but be careful, your compiler may not handle this very well and continue to load the stack in some case.
In following example restrict.c stack usage for function frame is higher than reuse.c on gcc 4.8.2</p>

<p><em>Example : restrict.c</em>  </p>

<pre><code>int main(int argc, char** argv)
{
    int a=0;
    for(int i1=0;i1&lt;10;i1++){
        a++;
    }
    for(int i2=0;i2&lt;10;i2++){
        a++;
    }
    for(int i3=0;i3&lt;10;i3++){
        a++;
    }
    for(int i4=0;i4&lt;10;i4++){
        a++;
    }   
    return 0;
}
</code></pre>

<p><em>Example : reuse.c</em>  </p>

<pre><code>int main(int argc, char** argv)
{
    int i, a=0;
    for(i=0;i&lt;10;i++){
        a++;
    }
    for(i=0;i&lt;10;i++){
        a++;
    }
    for(i=0;i&lt;10;i++){
        a++;
    }
    for(i=0;i&lt;10;i++){
        a++;
    }   
    return 0;
}
</code></pre>

<p><em>Example : restrict.disasm</em>  </p>

<pre><code>main:
    pushq   %rbp
    .seh_pushreg    %rbp
    movq    %rsp, %rbp
    .seh_setframe   %rbp, 0
    subq    $64, %rsp
    .seh_stackalloc 64
    .seh_endprologue
    movl    %ecx, 16(%rbp)
    movq    %rdx, 24(%rbp)
    call    __main
    movl    $0, -4(%rbp)
    movl    $0, -8(%rbp)
    jmp .L2
.L3:
    addl    $1, -4(%rbp)
    addl    $1, -8(%rbp)
.L2:
    cmpl    $9, -8(%rbp)
    jle .L3
    movl    $0, -12(%rbp)
    jmp .L4
.L5:
    addl    $1, -4(%rbp)
    addl    $1, -12(%rbp)
.L4:
    cmpl    $9, -12(%rbp)
    jle .L5
    movl    $0, -16(%rbp)
    jmp .L6
.L7:
    addl    $1, -4(%rbp)
    addl    $1, -16(%rbp)
.L6:
    cmpl    $9, -16(%rbp)
    jle .L7
    movl    $0, -20(%rbp)
    jmp .L8
.L9:
    addl    $1, -4(%rbp)
    addl    $1, -20(%rbp)
.L8:
    cmpl    $9, -20(%rbp)
    jle .L9
    movl    $0, %eax
    addq    $64, %rsp
    popq    %rbp
    ret
</code></pre>

<p><em>Example : reuse.disasm</em>  </p>

<pre><code>main:
    pushq   %rbp
    .seh_pushreg    %rbp
    movq    %rsp, %rbp
    .seh_setframe   %rbp, 0
    subq    $48, %rsp
    .seh_stackalloc 48
    .seh_endprologue
    movl    %ecx, 16(%rbp)
    movq    %rdx, 24(%rbp)
    call    __main
    movl    $0, -8(%rbp)
    movl    $0, -4(%rbp)
    jmp .L2
.L3:
    addl    $1, -8(%rbp)
    addl    $1, -4(%rbp)
.L2:
    cmpl    $9, -4(%rbp)
    jle .L3
    movl    $0, -4(%rbp)
    jmp .L4
.L5:
    addl    $1, -8(%rbp)
    addl    $1, -4(%rbp)
.L4:
    cmpl    $9, -4(%rbp)
    jle .L5
    movl    $0, -4(%rbp)
    jmp .L6
.L7:
    addl    $1, -8(%rbp)
    addl    $1, -4(%rbp)
.L6:
    cmpl    $9, -4(%rbp)
    jle .L7
    movl    $0, -4(%rbp)
    jmp .L8
.L9:
    addl    $1, -8(%rbp)
    addl    $1, -4(%rbp)
.L8:
    cmpl    $9, -4(%rbp)
    jle .L9
    movl    $0, %eax
    addq    $48, %rsp
    popq    %rbp
    ret
</code></pre>

<p>In fact you can mix both statement, declare general loop counter (i,j,k) that are reuse in you function and keep important meaning variable explicitly named.</p>
",0
37913232,37913185,0,"<p>Every odd number in binary has the lowest order bit set. And <code>X &amp; 1</code> is always testing that bit. Hence that check is always true.</p>

<p>If you don't see why the first statement is true then just convert a few decimal numbers to binary and it should be clear.</p>

<pre><code>1 == 00000001b
3 == 00000011b
5 == 00000101b
7 == 00000111b
etc
</code></pre>

<p>Then just to be sure, do the same for a few even numbers to verify that the lowest order bit is always 0:</p>

<pre><code>2 == 00000010b
4 == 00000100b
6 == 00000110b
8 == 00001000b
etc
</code></pre>
",0
37913233,37913185,0,"<p>It is because of binary number. Every binary number is the set of the 2 to the power of some number. If you are looking for the 4 bit number, then only odd number is 1(2 to the power of 0). If you are looking for number for example 12 it is on binary representation 1100. When you put the mask of 1 it looks like this</p>

<pre><code>    1100
   &amp;0001
    0000
</code></pre>

<p>if you pick a odd number for example 3, you have
 <code>
    0011
   &amp;0001
    0001</code>
As you can see only last digit of binary number is odd and 1 is 00000001.</p>
",0
37914140,37913185,0,"<p>No matter what <code>sizeof(int)</code> on a platform, the number <code>1</code> represented by all  the bits set to <code>0</code> except the least significant bit, which is set to <code>1</code>. Let's the take the most common representation -- a 32 bit number. On such a platform, <code>1</code> is:</p>

<pre><code>00000000 00000000 00000000 00000001 
</code></pre>

<p>If you perform a bitwise AND operation of any other number with <code>1</code>, all the bits except the least significant bit will always be <code>0</code>. The only time the least significant bit of the result will be <code>1</code> is when the least significant bit of the other number is also <code>1</code>.</p>

<p>Those numbers are:</p>

<pre><code>00000000 00000000 00000000 00000001, which is 1
00000000 00000000 00000000 00000011, which is 3
00000000 00000000 00000000 00000101, which is 5
00000000 00000000 00000000 00000111, which is 7
</code></pre>

<p>and so on. As you can see from the pattern, the least significant bits of all the odd numbers are <code>1</code>. The least significant bit of all the even numbers are <code>0</code>. Hence, </p>

<pre><code>x &amp; 1 is 1 for all odd values of x
x &amp; 1 is 0 for all even values of x
</code></pre>
",1
37918099,37917970,1,"<ol>
<li><p>readFile();</p></li>
<li><p>numOfWorkers = readFile();</p></li>
</ol>

<p>Remove the first one here.</p>
",1
37918059,37917970,2,"<p>You're calling <code>readFile</code> twice:</p>

<pre><code>readFile();

numOfWorkers = readFile();
</code></pre>

<p>The second time around it returns 0 since it has already reached EOF. And you're <code>printWorkers</code> uses 0 to iterate exactly 0 times, thus it looks as if it doesn't get called, even though it does.</p>
",0
37918422,37918139,0,"<p>I got it. You must not print the non-significant '0'. For example <code>1230</code> gives <code>321</code>. Here is my working code:</p>

<pre><code>#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/* strrev reverses a given string */
char *strrev(char *str)
{
    char    tmp;
    size_t  i = 0,
            len = strlen(str);

    for (; i &lt; len / 2 ; ++i)
    {
        tmp = str[i];
        str[i] = str[len - i - 1];
        str[len - i - 1] = tmp;
    }
    return str;
}

int main(void)
{
    char    buff[32],
            *s;
    size_t  i,
            len;

    scanf(""%zu"", &amp;len);
    for (i = 0 ; i &lt; len ; ++i)
    {
        scanf(""%s"", buff);
        s = strrev(buff);
        while (*s == '0')
            ++s; /* discarding '0' */
        printf(""%s\n"", s);
    }
    return EXIT_SUCCESS;
}
</code></pre>
",11
37919608,37918139,0,"<p>try this code (I'm agree with molbdnilo's comment):</p>

<pre><code>//This program reverses a given integer.

#include&lt;stdio.h&gt;
#include &lt;math.h&gt;

int main(void)
{
    int i,j,t,n,l,r = 0;
    char d[1024]; // stock digits

    scanf(""%d"",&amp;t);

    while(t--){
        scanf(""%d"",&amp;n);
        i = 0;
        while(n&gt;0){
          l=n%10;
          n=n/10;
          d[i] = l;
          i++;
        }

        for(j=0;j&lt;i;j++)
            r+= d[i-j-1] * pow(10,j); // r is the reversed number
        printf(""%d\n"",r);
    }


    return 0;

}
</code></pre>
",4
39324632,38780321,1,"<p>Including a header file usually just informs your translation unit (your program in this case) that certain things exist, in order than the code can be compiled,</p>

<p>To actually <em>use</em> those things, you need to do more than just figure out that they exist, you need to actually incorporate the code for them within your executable.</p>

<p>This is generally the responsibility of the link stage and, as per the <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa379479(v=vs.85).aspx"" rel=""nofollow"">Microsoft documentation</a>, the code for these functions are to be found in <code>winscard.lib/.dll</code>. You need to modify your project so that those libraries are included in your build.</p>
",0
38019355,38019336,1,"<pre><code>char directory[5]
</code></pre>

<p>This needs to be of type <code>int</code> . As also you pass <code>char *</code> as argument to <code>%d</code> you programs exhibits undefined behaviour. </p>

<p>And this should be inside <code>for</code> loop -</p>

<pre><code>if(a==directory[i]);  // out of loop i is out of bounds
   printf(""number is found"");
else
   printf(""number not found"");
</code></pre>
",16
38019499,38019336,2,"<p><code>%d</code> is expecting an <code>int</code> but <code>char directory[5]</code> is <code>char</code> values. This should be called as </p>

<pre><code>int directory[5];
</code></pre>

<p>Also you are only looking at the value of <code>i</code> which at the end of the for loop previously would be 5 in the array in the line:</p>

<pre><code>if(a=directory[i]);
</code></pre>

<p>You should instead have a for loop saying:</p>

<pre><code>for(i = 0; i &lt; 5; i++)
{
    if(a == directory[i])
    {
         printf(""number is found"");
    }
    else
    {
         printf(""number not found"");
    }
}
</code></pre>

<p>Two more things you should notice about my <code>if</code> are the <code>==</code> and the ending. Using a single <code>=</code> is an assignment which means a will now equal the value of <code>directory[i]</code> and check the boolean value if <code>a</code> is true (anything besides 0) or false (0). Writing it as <code>==</code> is what you want to check if they have the same value.</p>

<p>At the end of your <code>if</code> you have a semi colon. That makes the <code>if</code> pointless. The block will stop at the end of it.</p>

<p><strong>EDIT</strong>
In your new edit you are still using a <code>char</code> array instead of <code>int</code></p>

<pre><code>char directory[5];
</code></pre>

<p>Should be:</p>

<pre><code>int directory[5];
</code></pre>

<p>I assume it was just a copy paste issue but you are missing the opening { in your else. Either take out the closing } or add the other. Also assuming a copy paste issue for this one but you are missing the closing "" in the line:</p>

<pre><code>printf(""number not found);
</code></pre>
",0
38019515,38019336,0,"<pre><code> if(a=directory[i]);
</code></pre>

<p>If statements do NOT end with semi-colons!<bR>
You meant:</p>

<pre><code>for(i=0;i&lt;5;i++)
{
    scanf(""%d"",&amp;directory[i]);
    if(a == directory[i])
    {
        printf(""number is found"");
    }
    else
    {
        printf(""number not found"");
    }
}
getch();
</code></pre>
",0
38019517,38019336,0,"<p>first mistake,you have to declare array as int</p>

<pre><code>int directory[5]
</code></pre>

<p>second mistake is that in if condition you assigning value with ""="" operator
you should use ""=="" operator</p>

<pre><code>if(directory[i]==a)
</code></pre>

<p>""="" is assignment operator</p>

<p>if and else should be in the for loop</p>
",0
38019722,38019336,0,"<p>In Your Code 
char directory[5] //You need to Declare it as an Integer to compare it with another integer
if(a=directory[i]); //You don't need to have semicolon here it does not make any sense
if(a=directory[i]); // You need to use == instead of = to compare
Finally, make them  within a loop. Happy Coding</p>
",0
38019947,38019336,0,"<p>There appear to be some problems in the version of the program you posted; I've taken the liberty of correcting them below:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

int main()
  {
  int a=2, b, i;
  int directory[5];
  int found=false;

  printf(""Enter a number you want to find: "");
  scanf(""%d"",&amp;a);

  printf(""Enter the numbers you want to check\n"");
  for(i = 0 ; i &lt; 5 ; i++)
    scanf(""%d"", &amp;directory[i]);

  for(i = 0 ; i &lt; 5 ; ++i)
    {
    if(a == directory[i])
      {
      found = true;
      break;
      }
    }

  if (found)
    printf(""number is found\n"");
  else
    printf(""number not found\n"");
  }
</code></pre>

<p>The most important thing is that the original code never looped through the array of entered values to see if any of them matched the target value. In addition, the ""entered value"" which was checked was not actually in the array (the index used was outside the range of the valid index values for the array), and the ""comparison"" was coded as an assignment ('=' was used instead of '=='), so what was being checked was whether the value in the byte after the end of the array was zero or non-zero. In this version of the program the array is defined as being of type <code>int</code> rather than <code>char</code></p>

<p>Best of luck.</p>
",2
38020108,38019336,0,"<p>And you didnt initialize .It's logic fault</p>

<pre><code>int directory[5] 
</code></pre>
",1
39643549,39643026,1,"<p>Try this</p>

<pre><code>#include&lt;stdio.h&gt;;
void main()
{
    char opt='y';
    while(1)
    {
    float w,h,bmi;
    printf(""vul uw gewicht in in kilogram.\n"");
    scanf(""%f"",&amp;w);
    printf(""vul uw hoogte in in meters. (bijvoorbeeld: 1.75)\n"");
    scanf(""%f"",&amp;h);
    bmi=w/(h*h);
    printf(""bmi: %f"",bmi);
    bmi&lt;18.5?printf("" je bent best wel dun eet een burger :p\n""):(bmi&lt;25)?printf("" lekker gewicht, blijf zo doorgaan\n""):(bmi&lt;30)?printf("" ik zou wat minder gaan eten als ik jou was\n""):printf(""Oh Oh, u bent in gevaar\n"");
        printf(""calculate again : n for exit, y to continue?\n"");
        scanf(""%c&amp;*c"",&amp;opt);
        if(opt=='n')
        {
            printf(""EXIT\n"");
            break;
        }
    }
}
</code></pre>
",0
39626139,39626042,2,"<p>Your <code>return true</code> after the array is sorted is popping out of the <code>main</code> function, so the print code at the bottom is never reached.</p>
",0
40756579,40756510,2,"<p>You have 2 basic problems: </p>

<ul>
<li>when using a while and you need to repeat a whole lot of lines of code you need to use braces {} around all the code that is going to be repeated.</li>
<li>when you write int var you are <em>declaring</em> the variable - this tells the compiler what kind of variable it is and what it is called. Later changes to this value do not require a re-declaration as you are doing.</li>
</ul>
",0
40756649,40756510,1,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

int main() {
    printf(""Welcome to rock paper scissors!\n"");
    int keep_playing=5;
    while (keep_playing==5) {
        printf(""Press 'y' to play or 'n' to quit: "");
        char playornot;
        scanf(""%c"",&amp;playornot);
        if (playornot=='y') {
            printf(""Ok.\n"");
        } else if (playornot=='n') {
            keep_playing=4;
        }
    }
    return 0;
}
</code></pre>

<p>Is how your code should look like. In your case, there was an infinite loop because the only line which was repeated was <code>printf(""Press 'y' to play or 'n' to quit: "");</code>. This was caused by the luck of curly braces.</p>

<p>Then, you had a typo I would say - redundant <code>int</code> in <code>int keep_playing=4</code>. This declared another variable, visible only in this scope. Actually it should have caused the error when there were no curly braces, as it was the same scope at that moment.</p>

<p>And there was a third bug which noone mentioned before. If the entered character wasn't <code>y</code> it should have been <code>n</code>. Otherwise you should ask for another input or somehow decide how to deal with it.</p>

<p>And the fourth one was that yoou tried to scan two characters to <code>char playornot</code>. Removed <code>\n</code> from <code>scanf</code>.</p>
",7
41914930,41914782,-1,"<p>You need to allocate a <em>string</em> with size <code>spaceIndex+1.</code>
Your code is almost correct, you are just not remembering that the <code>'\0'</code> terminator is part of the <em>string</em> when you allocate it and when you call <code>strncpy</code>.</p>

<p>You need two fixes:</p>

<ol>
<li><p>Add one more <code>char</code> to <code>firstWord</code>:</p>

<p><code>char firstWord[spaceIndex + 1];</code></p></li>
<li><p>Be aware of that extra byte on the call to <code>strncpy</code>:</p>

<p><code>strncpy(firstWord, input, spaceIndex+1);</code></p>

<p>I recommend actually using the buffer size as paramenter:</p>

<p><code>strncpy(firstWord, input, sizeof(firstWord));</code></p></li>
</ol>

<p>Read <a href=""https://linux.die.net/man/3/strncpy"" rel=""nofollow noreferrer""><code>strncpy</code>'s documentation</a>, although you are using it correctly, this function is really tricky.</p>
",0
41942806,41942698,1,"<p>The memory capacity and availability is platform and operating system dependent.  </p>

<p>Some operating systems allow for <em>memory mapping</em> a file, in which the operating system manages the reading of data into memory for you.  </p>

<p>Reading without overflow is accomplished by using <em>block</em> reading (a.k.a. <code>fread</code> in C and <code>istream::read</code> in C++).  You tell the input function how much to read in the block and the function returns the quantity actually read.  The block size should be less than or equal to the memory allocated for the data.  The next read will start a the next location in the file.  Perform in a loop to read in all the data.  </p>

<p>Also, verify there is a reason to hold all the data in memory at the same time.   Most programs only hold a small portion of the data for a limited time.  </p>
",0
42520757,42520709,2,"<blockquote>
  <p>in this program it automatically converted into -10</p>
</blockquote>

<p>It does not convert to -10, it converts to a large positive number that <em>behaves</em> like -10 when you perform an addition.</p>

<p>C standard says:</p>

<blockquote>
  <p>A computation involving unsigned operands can never overflow, because a result that cannot be represented by the resulting unsigned integer type is reduced modulo the number that is one greater than the largest value that can be represented by the resulting type</p>
</blockquote>

<p>A consequence of this behavior is that when you add <code>10</code> to <code>- 10u</code>, the result is ""one greater than the largest value that can be represented by the resulting type"", so it gets truncated to zero. This is exactly the behavior that you get when adding <code>+10</code> and <code>-10</code> using a signed type.</p>

<p>Perhaps this behavior is easier to understand with decimals. Suppose you have a system that can represent numbers 0..99, with 100 wrapping back to zero. Then 10 would remain 10, while -10 would become 99+1-10=90. Now when you add 10 and 90, you get 100, which gets truncated to zero.</p>
",2
42520799,42520709,6,"<p><code>-10u</code> is a ""unary minus"" operator applied to a constant <code>10u</code> of type <code>unsigned int</code>. The result is value of <code>-10</code> represented in the domain of <code>unsigned int</code> type. According to the rules of unsigned arithmetic, the final result will be equal to <code>UINT_MAX + 1 - 10</code> and will have type <code>unsigned int</code>.</p>
",0
40987228,40987189,2,"<p>Undefined behaviour because of how you zero the grid.  Looks like a copy/paste error.</p>

<pre><code>for(b=0;a&lt;WIDTH;++b){
       ^^^
</code></pre>

<p>You meant <code>b &lt; WIDTH</code>.</p>
",3
39250923,39250263,0,"<blockquote>
  <p>I still need to demonstrate knowledge pointer use and function call by reference.</p>
</blockquote>

<p>C does not have call by reference.  Presumably your teacher wants you to demonstrate providing data to a function by passing a pointer to that data, but if he really called that ""pass by reference"" then he was sloppy.  C provides for passing pointers by value -- that has a similar effect, but it's not quite the same thing.</p>

<blockquote>
  <p>My plan is to create a function that can swap the musical notes in Option 2 (i.e Digital keyboard).</p>
</blockquote>

<p>That seems both a little weird and potentially tricky.  Allow me to suggest an alternative: create a function that plays songs, and that receives the notes to play via a pointer to an array (or two) of them.  Add a second song to your program's repertoire (e.g. ""Mary Had a Little Lamb""), so that you can use the same function to play your choice of those songs depending on that function's arguments.</p>

<p>The prototype for such a function might look like this:</p>

<pre><code>void play_song(float *pitch, int *duration, int num_notes);
</code></pre>

<p>You would combine that with arrays of pitches and notes, such as:</p>

<pre><code>float twinkle_pitch[TWINKLE_NUM_NOTES] =
        { 261.63, 261.63, 392.00, 392.00, /* etc */ };
int twinkle_duration[TWINKLE_NUM_NOTES] =
        {    600,    600,    600,    600, /* etc */ };
/* and similar for one or more other songs */
</code></pre>

<p>Your main program would play a selected song by calling the function, for example,</p>

<pre><code>play_song(twinkle_pitch, twinkle_duration, TWINKLE_NUM_NOTES);
</code></pre>
",0
39251504,39250263,0,"<p>In C, all function arguments are passed ``by value.'' This means that the called function is given the values of its arguments in temporary variables rather than the originals.</p>

<p>The only way to achieve call by reference is use pointers as argument of function.</p>

<p>example:</p>

<pre><code>#include &lt;stdio.h&gt;
void call_by_value_inc(int formal_argument)
{
    ++formal_argument;
    return;
}



void call_by_reference_inc(int *formal_argument)
{
    ++(*formal_argument);
    return;
}

int main()
{
    int actual_argument = 1;
    call_by_value_inc(actual_argument);
    /*after invoke call_by_value_inc,the actual_argument's value still be 1*/
    printf(""actual_argument %d\n"", actual_argument);

    call_by_reference_inc(&amp;actual_argument);
    /*after invoke call_by_value_inc,the actual_argument's value will be 2*/
    printf(""actual_argument %d\n"", actual_argument);
}
</code></pre>
",0
39312390,39312158,1,"<p><code>""hello, world""</code>, <code>""hello""</code>, and <code>"" world""</code> are all <em>string literals</em>; they are all stored as arrays of <code>char</code> such that they are available as soon as the program starts and are visible over the lifetime of the program.  </p>

<p>The statement</p>

<pre><code>p-&gt;str = ""hello, world"";
</code></pre>

<p>copies the <em>address</em> of the string literal to <code>p-&gt;str</code>.  This works fine for the <code>printf</code> statement and anything else that just needs to <em>read</em> the string.  However, in the statements</p>

<pre><code>p-&gt;str = ""hello"";
strcat( p-&gt;str, "" world"" );
</code></pre>

<p>you are trying to <em>modify</em> the string literal <code>""hello""</code> by appending the string <code>"" world""</code> to it.  String literals are not modifiable, and attempting to do so leads to <em>undefined behavior</em>, which in your case is a segfault - on many popular desktop platforms, string literals are saved in a read-only section of memory.</p>

<p>Therefore, you need to set aside a region of memory that you <em>can</em> write to.  You can either do it dynamically with</p>

<pre><code>p-&gt;str = malloc( SOME_SIZE);  // enough space to store your final string
strcpy( p-&gt;str, ""hello"" );  // copy the contents of ""hello"" to the memory str points to
strcat( p-&gt;str, "" world"" ); // append the contents of "" world"" to the memory str points to
</code></pre>

<p>or you can set <code>p-&gt;str</code> to point to an array you've declared elsewhere</p>

<pre><code>char buffer[SOME_SIZE];
p-&gt;str = buffer; // assigns the *address* of buffer to p-&gt;str
</code></pre>

<p>or you can declare <code>str</code> as an <em>array</em> of char in the <code>struct</code> definition:</p>

<pre><code>struct test
{
  char str[SOME_SIZE];
};
</code></pre>

<p>where <code>SOME_SIZE</code> is big enough to hold whatever string you want to store.  Note that in this case, <code>p-&gt;str = ""hello""</code> <em>won't</em> work; you can't use the <code>=</code> operator to assign the contents of arrays to each other; you must use <code>strcpy</code> in that case.</p>

<p>Obviously, dynamic allocation with <code>malloc</code> or <code>calloc</code> is more flexible; you can allocate exactly as much memory as you need, and you can grow or shrink the dynamic buffer as necessary using <code>realloc</code> You just need to remember to free <code>p-&gt;str</code> when you're done.  </p>

<p>You can still assign the address of a string literal to <code>p-&gt;str</code>, just be aware that you cannot pass that address to functions like <code>strcpy</code> or <code>strcat</code> or <code>strtok</code> or any other functions that attempt to modify the contents of the input string.</p>
",0
39326816,39326474,1,"<p>In the header file you need to first decalre the struct:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

#define max_size 10
struct stack
{
    int a[max_size];
    int top;
};

extern bool isEmpty(struct stack *b);
extern bool isFull(struct stack *b);
extern void push(struct stack *b,int data);
extern int pop(struct stack *b);
extern void display(struct stack *b);
</code></pre>

<p>In addition, there is no need to expose the internal implementation of the data structure. You can do something like:</p>

<p>.h file:</p>

<pre><code>typedef struct xx_t xx_t;
</code></pre>

<p>.c file:</p>

<pre><code>struct xx_t {
    ...
};
</code></pre>
",3
45281939,45281718,3,"<p>The constants <code>60123456</code> and <code>128</code> are of type <code>int</code>, therefore the expression <code>60123456 * 128</code> is also of type <code>int</code>.  The value of this expression would overflow the range of an <code>int</code>.  The compiler is able to detect it in this case because both operands are constants.</p>

<p>You should use the <code>ULL</code> suffix on the first operand to make the type of the constant <code>unsigned long long</code>.  That way it matches the type being assigned to.  Then for any operation involving this value, the other operand will be promoted to <code>unsigned long long</code> before the operation is applied and you won't have any overflow.</p>

<p>So the resulting expression should look like this:</p>

<pre><code>unsigned long long int data_size = 60123456ULL * 128 * sizeof(double);
</code></pre>
",0
45281778,45281718,46,"<p>Overflow occurs <em>before</em> value is assigned to the variable. To avoid that use long long suffix:</p>

<pre><code>60123456LL * 128 * sizeof(double)
</code></pre>

<p>(comments also suggest ULL which is not necessary here because values are within signed range, but that would be the generic way to go)</p>
",3
45281766,45281718,18,"<p>You are converting to ""long long"" too late. <code>60123456 * 128</code> is still an overflowing int expression.</p>

<p>Try <code>60123456LL * 128</code> instead. (LL because the resulting value is not guaranteed to fit in a long.)</p>
",1
45282709,45281718,12,"<pre><code>unsigned long long int data_size = 60123456 * 128 * sizeof(double);  // trouble-some code
</code></pre>

<p>The type of destination <code>unsigned long long int data_size =</code> is irrelevant to the product calculation <code>60123456 * 128 * sizeof(double)</code>.</p>

<p>Best to insure math is done using at least the size of the target type to avoid overflow.  In OP's case, that implies a constant with <code>LLU</code>.</p>

<hr>

<p>There are 2 product calculations, each with their own type math.</p>

<p><code>60123456</code> is an <code>int</code> or <code>long</code> depending on <code>int</code> range.  Let us assume it is an <code>int</code>.</p>

<p><code>60123456 * 128</code> is an <code>int * int</code>. The math product <code>7695802368</code> exceeds 32-bit <em>signed integer</em>  range, thus <strong>signed integer overflow</strong> or undefined behavior (UB) with a 32-bit <code>int</code>.</p>

<p>If <code>60123456 * 128</code> did not overflow, says 64-bit <code>int</code>, than the next multiplication would be <code>* sizeof(double);</code> and so <code>int * size_t</code> results in a <code>size_t</code> type product.</p>

<p>Product calculation should use at least <code>unsigned long long</code> math as below:</p>

<pre><code>unsigned long long int data_size = 1LLU * 60123456 * 128 * sizeof(double);

// or
unsigned long long int data_size = 60123456LLU * 128 * sizeof(double);

// or 
unsigned long long int data_size = 60123456;
data_size *= 128 * sizeof(double);

// or avoiding naked magic numbers
#define A_HEIGHT 60123456
#define A_WIDTH 128
unsigned long long int data_size = 1LLU * A_HEIGHT * A_WIDTH * sizeof(double);
</code></pre>

<hr>

<p>The <code>sizeof (double)</code> hints that code is attempting to find the size of some 2D-like structure.  I'd expect code like the following.  Notice the result type of <code>sizeof</code> is <code>size_t</code>, so the product math is done using at least <code>size_t</code> math.</p>

<pre><code>size_t data_size = sizeof(double) * 60123456 * 128;
printf(""data_size= %zu\n"", data_size);
</code></pre>

<hr>

<p>See also <a href=""https://stackoverflow.com/q/40633059/2410359"">Why write 1,000,000,000 as 1000*1000*1000 in C?
</a> and my answer <a href=""https://stackoverflow.com/questions/40633059/why-write-1-000-000-000-as-100010001000-in-c/40637622#40637622"">reasons not to use 1000 * 1000 * 1000</a> for applicable details..</p>
",2
45286355,45281718,3,"<p>The lexer attaches types on constants during translation phase 7 (conversion of preprocessing tokens into C tokens.) cf ISO9899 <code>5.1.1.2  Translation phases</code>.  As the others said, the lexer will attach on your constants the type <code>int</code> instead of <code>unsigned long long</code> as you wish, and in order for the <code>default arithmetic conversions</code> to generate a constant of type <code>unsigned long long</code> on the right side of the assignment you need to say to the lexer to attach the type <code>unsigned long long</code> on at least one constant from the operation <code>*</code> that generates the overflow, so by writing <code>60123456ULL * 128</code> or <code>60123456 * 128ULL</code> or both.</p>
",0
42477293,42477147,0,"<p>By the looks of the errors in your code, I'd say you're probably not reading a book to learn. That's unfortunate, because people who read books to learn C usually don't have this kind of trouble.</p>

<hr>

<pre><code>float toneladas[12];

for(i = 1; i &lt; 13; i++){
    printf(""Ingrese la cantidad de toneladas del mes #%d-&gt;"", i);
    scanf(""%f"", &amp;toneladas[i] );
 }
</code></pre>

<p>Here you've declared a carton of 12 eggs, <code>egg[0]</code> through to <code>egg[11]</code> (write them out and count them one by one, and you'll see there are 12)... and then tried to insert into <code>egg[12]</code>, which is out of bounds. Expect one smashed egg!</p>

<p>Throughout that code you're referring to that smashed egg again and again. I wouldn't be surprised if the recipe you're concocting is disastrous!</p>

<hr>

<p>Speaking of smashed eggs, you have an uninitialised variable: <code>int numMesses</code> which you then use without initialisation: <code>numMeses = numMeses + 1;</code>...</p>

<hr>

<pre><code>int numMeses, numToneladas,i, suma = 0, mesTon = 0;
/* SNIP */
printf(""El promedio anual es: %0.2f, %d mes(es) tuvieron mayor cosecha que el promedio anual, y el mayor numero de toneladas se produjo en el mes #%d con %0.2f"", promAnual,numMeses,mesTon, numToneladas);
</code></pre>

<p>As you can see, <code>numToneladas</code> is declared as <code>int</code>. However, in your call to <code>printf</code> you're telling <code>printf</code> it's a <code>double</code>. You're lying to <code>printf</code>; no wonder it's lying back at you!</p>

<hr>

<p>You appear to be including the non-portable header <code>&lt;conio.h&gt;</code>, though I see no point. Unlike most, you've not used a single function from that header! Why include a non-portable header you're not using?</p>

<p>My only guess is that you're copy/pasting from somewhere, and attempting to learn by unguided trial and error. As you've seen, that's dangerous; it'll cause you headaches due to strange, difficult to debug bugs like the one you've encountered today. You got lucky this time, <em>because you noticed</em>. If you write code like this in the real world you might cause someone injury!</p>

<p><strong>Read a book!</strong> Do the exercises as you stumble across them. I can recommend K&amp;R2E.</p>
",2
42478619,42477147,0,"<p>you would better check the end condition of ""for"" loop,  the array toneladas have 12 stores, which from 0 to 11,but you set it from 1 to 12,maybe it cause your issue.
  please try to set ""for(i=0;i&lt;12;i++)"",and run the code again.</p>
",0
40982829,40982772,2,"<p>It is operating system specific. I guess you are on Linux or some other Posix system. Read first <a href=""http://advancedlinuxprogramming.com/"" rel=""nofollow noreferrer"">Advanced Linux Programming</a>. Read also about <a href=""https://en.wikipedia.org/wiki/Glob_%28programming%29"" rel=""nofollow noreferrer"">globbing</a>. Be aware that your <a href=""https://en.wikipedia.org/wiki/Unix_shell"" rel=""nofollow noreferrer"">Unix shell</a> is expanding the arguments (and after expansion calling the <a href=""http://man7.org/linux/man-pages/man2/execve.2.html"" rel=""nofollow noreferrer"">execve(2)</a> system call....). If you shell is <code>bash</code> (and actually that behavior is mandated by POSIX) read about <a href=""https://www.gnu.org/software/bash/manual/html_node/Shell-Operation.html"" rel=""nofollow noreferrer""><em>Shell Operation</em></a> then about <a href=""https://www.gnu.org/software/bash/manual/html_node/Shell-Operation.html"" rel=""nofollow noreferrer""><em>Shell expansions</em></a>. Read also the <a href=""https://www.gnu.org/software/libc/manual/html_node/Program-Arguments.html"" rel=""nofollow noreferrer""><em>Program Arguments</em></a> chapter of <code>libc</code> documentation. See also <a href=""https://softwareengineering.stackexchange.com/a/307472/40065""><em>my answer</em></a> on ""good habits for designing command line arguments?"".</p>

<p>The <code>main</code> function (of signature <code>int main(int argc, char**argv);</code>, and such a [possible] signature is defined by the C standards) - of the program started by <code>execve</code> - gets the positive argument count and a <code>NULL</code> terminated array of strings. So in your case (<code>./testmt signal1 3 5 1 1</code>) you get <code>argc=6</code> and <code>argv[0]</code> is <code>""./testmt""</code>, <code>argv[1]</code> is <code>""signal""</code>, <code>argv[2]</code>  is <code>""3""</code>, etc... <code>argv[5]</code> is the last <code>""1""</code> and <code>argv[6]</code> is <code>NULL</code>.</p>

<p>So dive into your code, and look for <code>main</code>.</p>

<p><sup>PS. AFAIK, on Windows the behavior is probably different. The program (not the shell) is expanding the arguments (actually, probably done in startup files, before they call <code>main</code>). But I know nothing about Windows. See also <em><a href=""http://pages.cs.wisc.edu/~remzi/OSTEP/"" rel=""nofollow noreferrer"">Operating Systems: Three easy pieces</em></a>.</sup></p>
",0
40980346,40980190,3,"<p>It looks like you are expecting gets to allocate an appropriately-sized string and return a pointer to it but that is not how it works. <code>gets</code> needs to receive the buffer as a parameter so you would still need to declare the array with a huge number. In fact, I am surprised that you managed to get your code to compile since you are passing the wrong number of arguments to gets.</p>

<pre><code>char s[1000];
if (gets(s) == NULL) {
    // handle error
}
</code></pre>

<p>The return value of gets is the same pointer that you passed as a parameter to it. The only use of the return value is to check for errors, since gets will return NULL if it reached the end of file before reading any characters.</p>

<p>A function that works more similarly to what you want is <a href=""https://www.gnu.org/software/libc/manual/html_node/Line-Input.html"" rel=""nofollow noreferrer""><code>getline</code></a> in the GNU libc:</p>

<pre><code>char *s;
size_t n=0;
getline(&amp;s, &amp;n, stdin);

printf(""%s"", s); // Use the string here

free(s); //Then free it when done.
</code></pre>

<p>Alternatively, you could do something similar using malloc and realloc inside a loop. Malloc a small buffer to start out then use fgets to read into that buffer. If the whole line fits inside the buffer you are done. If it didn't then you realloc the buffer to something larger (multiply its size by a constant factor each time) and continue reading from where you stopped.</p>

<p>Another approach is to give up on reading arbitrarily large lines. The simplest thing you can do in C is to set up a maximum limit for line length (say, 255 characters), use fgets to read up to that number of characters and then abort with an error if you are given a line that is longer than that. This way you stick to functions in the standard library and you keep your logic as simple as possible.</p>
",0
40980494,40980190,0,"<p>You have not allocated temp.
And 3 kinds of C you should avoid i.e.</p>

<pre><code>void main() use int main() instead
fflush(stdin)
gets() use fgets() instead
</code></pre>
",3
45772156,45772113,0,"<p>What is returned is the <em>pointer value</em> returned from <code>alloc()</code>.</p>

<p><code>v</code> is local and returning <em>a pointer pointing to <code>v</code></em> is not good, but what <code>v</code> is pointing is not local, so returning it is valid.</p>
",3
40952762,40950501,0,"<p>The local variable <code>min</code> is being initialized to 0: <br/><code>double min = 0</code><br/>  <br/>Every input value in <code>n[]</code> is <strong>greater</strong> than 0.<br/><br/>  You will need to change the initialization value of <code>min</code> in order for this function to work.<br/><br/>You have <strong>2</strong> options see below:</p>

<ol>
<li>You can change the initialization value of min to be the maximum value a double can hold (assuming 64 bits) which is approximately:  <strong>1.7976931348623157 ¡Á 10<sup>308</sup></strong><br/><br/>
<code>min = 1.7976931331348623157E308;</code><br/><br/></li>
<li>Or you can initialize <code>min</code> to be the value of <code>x[0]</code> like so:<br/><br/>
<code>min = x[0];</code></li>
</ol>

<p>I would sooner choose option 2 since it is comparing actual values from the array and not using an approximation. </p>
",1
40952762,40950501,0,"<p>The local variable <code>min</code> is being initialized to 0: <br/><code>double min = 0</code><br/>  <br/>Every input value in <code>n[]</code> is <strong>greater</strong> than 0.<br/><br/>  You will need to change the initialization value of <code>min</code> in order for this function to work.<br/><br/>You have <strong>2</strong> options see below:</p>

<ol>
<li>You can change the initialization value of min to be the maximum value a double can hold (assuming 64 bits) which is approximately:  <strong>1.7976931348623157 ¡Á 10<sup>308</sup></strong><br/><br/>
<code>min = 1.7976931331348623157E308;</code><br/><br/></li>
<li>Or you can initialize <code>min</code> to be the value of <code>x[0]</code> like so:<br/><br/>
<code>min = x[0];</code></li>
</ol>

<p>I would sooner choose option 2 since it is comparing actual values from the array and not using an approximation. </p>
",1
41680345,41678949,-3,"<p>Use <code>fgets(char *str, int n, FILE *stream);</code> instead of <code>gets</code>.</p>
",2
41680398,41678949,5,"<p>Output is probably line buffered and your printf string does not end with a newline. Force output with <code>fflush(NULL);</code> after any <code>printf()</code> that does not end in <code>\n</code>.</p>
",1
42625954,42624543,1,"<p>One solution is to use assign different variable names to the same memory area. To treat it as if it has individual variable names, while at the same time have the ability to treat it as an array. To achieve that, we can use a union:</p>

<pre><code>typedef struct
{
  const char* title; 
  const char* firstName;
  const char* middleName;
  const char* surname;
} arcStr;

typedef struct
{
  ...
  union
  {
    arcStr arc;
    const char* array[4];
  };
  ...
} some_struct;
</code></pre>

<p>Usage: <code>P.strFullName.arc.title</code>.</p>

<p>So quite similar to what you already had, but you can now loop over this data as well:</p>

<pre><code>for(size_t i=0; i&lt;4; i++)
{
  if (strcmp(P.strFullName.array[i], "" "") != 0)
    printf(""%s "", P.strFullName.array[i]);
}
</code></pre>
",0
42624789,42624543,3,"<p>You can write a small function that holds the if condition and also prints.</p>

<pre><code>void CheckAndPrint(char *str)
{
   if (strcmp(str, "" "") != 0)
        printf(""%s "", str); 
}
</code></pre>

<p>Then in the main code you can call it as,</p>

<pre><code>CheckAndPrint(P.strFullName.arcTitle);
CheckAndPrint(P.strFullName.arcFirstName);
CheckAndPrint(P.strFullName.arcMiddleName);
CheckAndPrint(P.strFullName.arcSurname);
</code></pre>

<p>This has the advantage that maybe later if you want to add another check before printing, it will have to be done in only one place.</p>
",0
42625506,42624543,1,"<p>If you really must ""iterate"", you can use the standard <code>offsetof</code> macro to calculate the offset of each member, and then access it through the address of the struct:</p>

<pre><code>struct full_name {
  char const *arcTitle;
  char const *arcFirstName;
  char const *arcMiddleName;
  char const *arcSurname;
};

void print_full_name (struct full_name *fname) {
  size_t offest[] = {
    offsetof(struct full_name, arcTitle),
    offsetof(struct full_name, arcFirstName),
    offsetof(struct full_name, arcMiddleName),
    offsetof(struct full_name, arcSurname)
  };

  for (size_t idx = 0; idx &lt; sizeof(offset)/sizeof(offset[0]); ++i) {
    char *mem_raw_ptr = (char*)fname + offset[idx];
    char const *str = *(char const **)mem_raw_ptr;

    if (strcmp(str, "" "") != 0)
      printf(""%s "", str); 
  }
}
</code></pre>

<p>Be certain that all members you ""iterate"" over have the same type! And remember that you calculate a pointer to that member, so pointers to pointers may need to be used, when appropriate (and possibly, heaven forbid, pointers to arrays).</p>
",0
42682985,42682646,1,"<p>Few things:</p>

<p>In the client loop, you do a <code>write</code> and a <code>read</code> on the socket. But your server never writes to that socket(no <code>write</code> call in the server, only <code>read</code>). As a result, your client gets blocked on the <code>read</code> call. That's why you cannot enter more...</p>

<p>In general, you need to check how much you wrote in and keep writing until done (a loop is needed). </p>

<pre><code>int n = 0;
while (n != strlen(buffer){
   n += write(sockfd,&amp;buffer[n],strlen(buffer)-n);      
}
</code></pre>

<p>Same goes for reading from a socket:</p>

<pre><code>int n = 0;
while (n != strlen(buffer){
   n += read(sockfd,&amp;buffer[n],strlen(buffer)-n);      
}
</code></pre>
",0
42683202,42682646,0,"<p>Here's what I believe is likely happening.</p>

<ol>
<li>Client sends some chunk of data. Possibly all of the string <code>harris@ics.uci.edu</code>, but possibly less.</li>
<li>The server reads some chunk of this, most likely less than the full string, say <code>harris@ic</code>.</li>
<li>The server performs the <code>strcmp</code>, which doesn't match anything, so returns to the top of the loop.</li>
<li>The server reads the remainder of the email, say <code>s.uci.edu</code> <em>into <code>buffer</code>, thus overwriting it</em>.</li>
<li>Again, this doesn't match anything, so the server goes to the top of the while loop again.</li>
<li>The server hangs on the <code>read</code> call, waiting for data from the client. Because the client is waiting for a reply, it's stuck on its own <code>read</code> call. ...And nothing else happens.</li>
</ol>

<p>There are two main problems here. First, TCP sockets are just streams of bytes, and when you read data from them, the OS no longer keeps it around. You are now expected to handle any previously- or partially-read data if you need. And second, the OS often transmits (both sending and receiving) fewer bytes than you request. While you ask that the full string <code>harris@ics.uci.edu</code> be sent, only a portion of that may be sent, or only a portion of that may be read on the other side.</p>

<p>This means two things for you. It's always important to check the amount of data read/written any time you call <code>read(2)</code> or <code>write(2)</code>, but it's <em>crucial</em> in networking. Make sure you read/write as much as you need (the full email in this case) before moving on to, for example, waiting for a reply.</p>

<p>The second thing is that you need some way of delineating full messages and buffering partial messages. In what you've got, as is common in lots of text-based messaging protocols, the newline <code>\n</code> is your delimiter. So instead of a single call to <code>read(2)</code> in the server, you need something like this (pseduocode):</p>

<pre><code>while newline not in data:
    data += read(sockfd, ...)
</code></pre>

<p>Once you receive your newline, process the full message, but don't throw away any extra bytes you've read from the next message. Keep those around, and append the next bytes read from the socket to them, and so on.</p>

<p>EDIT:</p>

<p>Note that it's usually better to use <code>recv(2)</code> and <code>send(2)</code> when working with sockets. The <code>read(2)</code>/<code>write(2)</code> system calls will work just fine, but the others are more clear when working with sockets, and allow you to specify other flags, for example, peeking at the bytes currently on the socket or waiting until all the bytes you request are available before returning.</p>
",0
41195941,41195707,2,"<p>You are not writing in <em>Pure C</em>, but rather in C++.</p>

<p>To achieve your goal, you must summarize the problem into a sequence of logical steps:</p>

<ul>
<li>for each character read:

<ul>
<li>if the previous one is a line separator, you have a new line ;</li>
<li>if the previous one is a word separator and the current isn't, you have a new word ;</li>
<li>if all cases, you have a new character, save it as the previous character for the next iteration.</li>
</ul></li>
</ul>

<p>Use <code>'\n'</code> as the initial value for the <code>last</code> character, so the first character read if any starts a new line and possibly a new word if it is not whitespace.</p>

<p>Here is a simple implementation:</p>

<pre><code>#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;

int main(void) {
    long chars = 0, words = 0, lines = 0;

    printf(""Enter the text:\n"");

    for (int c, last = '\n'; (c = getchar()) != EOF; last = c) {
        chars++;
        if (last == '\n')
            lines++;
        if (isspace(last) &amp;&amp; !isspace(c))
            words++;
    }
    printf(""Characters: %ld\n""
           ""Words: %ld\n""
           ""Lines: %ld\n\n"", chars, words, lines);
    return 0;
}
</code></pre>

<p>If you are required to use a <code>while</code> loop, the <code>for</code> loop can be converted this way:</p>

<pre><code>#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;

int main(void) {
    long chars = 0, words = 0, lines = 0;
    int c, last = '\n';

    printf(""Enter the text:\n"");

    while ((c = getchar()) != EOF) {
        chars++;
        if (last == '\n')
            lines++;
        if (isspace(last) &amp;&amp; !isspace(c))
            words++;
        last = c;
    }
    printf(""Characters: %ld\n""
           ""Words: %ld\n""
           ""Lines: %ld\n\n"", chars, words, lines);
    return 0;
}
</code></pre>
",2
40475794,40443987,0,"<p>in c, any output (unless specifically set otherwise) is buffered.</p>

<p>Nothing is output until one of the following occurs:</p>

<ol>
<li><code>fflush()</code> is called </li>
<li>a '\n' is output</li>
<li>the buffer is filled.</li>
</ol>

<p>so you could add a call to <code>flush()</code> after the call to <code>printf()</code></p>

<p>Note: there are other word separators that you should probably be looking for, other than tab, space, newline.</p>

<p>Suggest adding: single quotes, double quotes, period, colon, semicolon, left paren, left brace, right paren, right brace, back tick.</p>
",0
40579161,40578877,0,"<p><code>clrscr()</code> function works only in Borland's C compilers - Turbo C etc. Use <code>system(""cls"")</code> function instead.</p>
",0
40530794,40530074,1,"<p>The problem is here:</p>

<pre><code>    printf(""***Realloqing: %d***\n"", tam * sizeof(*p1));
    p1 = (Product*)realloc(p1, tam * sizeof(Product));
</code></pre>

<p>When <code>tam</code> is, say 1, then you realloc <code>tam * sizeof(Product)</code>, but you need to realloc <code>(tam + 1) * sizeof(Product)</code>, because now you need space for <strong>2</strong> products.</p>

<p>So this fixes the problem:</p>

<pre><code>    printf(""***Realloqing: %d***\n"", (tam + 1) * sizeof(*p1));
    p1 = (Product*)realloc(p1, (tam + 1) * sizeof(Product));
</code></pre>
",0
40530200,40530074,1,"<p>This:</p>

<pre><code>p1 = (Product*)realloc(p1, (tam) * sizeof(Product));
</code></pre>

<p>Violates the First Rule of Realloc, which is that you must not assign the result of realloc directly to the same variable which is passed as its first argument.  When you do, if it fails, you have lost (leaked) the old pointer.</p>

<p>Second, you do not check the return values from various functions, such as <code>malloc()</code>, <code>realloc()</code>, and <code>scanf()</code>.   This too is a cardinal sin.</p>

<p>If fixing all that still leaves you with a broken program, use valgrind.</p>
",5
40569469,40569440,0,"<p>You are dealing with a ""scope"" issue. Since you declare the variable in the loop, it only ""lives"" for the duration of that iteration. Declare it before the loop and you should be set</p>
",4
46638208,46637944,1,"<p>Rather than repeatedly generating a pair until you find a unique pair, generate all pairs, then shuffle the pairs.</p>

<pre><code>int max_y = 2;
int max_x = 2;
size_t num_eles = (max_x+1)*(max_y+1);
size_t desired_num_eles = 6;

if (desired_num_eles &gt; num_eles)
   desired_num_eles = num_eles;

int* y_cord = malloc(sizeof(int) * num_eles);
int* x_cord = malloc(sizeof(int) * num_eles);

for (int y = max_y; y--; ) {
   for (int x = max_x; x--; ) {
      size_t i = y * max_x + x;
      y_cord[i] = y;
      x_cord[i] = x;
   }
}

for (size_t i = 0; i&lt;desired_num_eles; ++i) {
    size_t j = rand() % (num_eles - i) + i;
    // Swap i and j
    y_cord[i] ^= y_cord[j];  y_cord[j] ^= y_cord[i];  y_cord[i] ^= y_cord[j];
    x_cord[i] ^= x_cord[j];  x_cord[j] ^= x_cord[i];  x_cord[i] ^= x_cord[j];
}

num_eles = desired_num_eles;
y_cord = realloc(sizeof(int) * num_eles);
x_cord = realloc(sizeof(int) * num_eles);
</code></pre>
",0
46980698,46980303,2,"<pre><code>struct q *ptr1;
ptr1-&gt;x = (struct q*)&amp;p1.x;
</code></pre>

<p>Pointer <code>ptr1</code> is created, but is never initialized.  The second line attempts to dereference the pointer.  Since the pointer was never initialized and contains garbage, the second line is dereferencing an invalid memory address.  You need to allocate a <code>struct q</code> and make <code>ptr1</code> point to it before you can execute that second line.</p>
",1
46981700,46980303,0,"<p>The guys here already pointed out, but just for putting that in actual sample code:</p>

<pre><code>int main()
{
  struct p p1 = {1, 2};
  struct q q1;                  // reserve memory on stack
  struct q *ptr1 = &amp;q1;         // let ptr1 point to it
  ptr1-&gt;x = (struct q*)&amp;p1.x;   // cleaner: q1.x = p1.x; both are pointer to int
  printf(""%d\n"", ptr1-&gt;x[1]);
}
</code></pre>

<p>I'm not to a 100% sure whether <code>p1 = {1, 2}</code> shouldn't be rather <code>p1 = { {1, 2} }</code>, because the former one could be also used for e.g.</p>

<pre><code>struct {
  int a;
  int b;
} P1 = {1, 2};
</code></pre>
",0
40968220,40964600,1,"<p>There are multiple problems in your code:</p>

<ul>
<li><p>Index values are <code>0</code> based in C. Valid index values for your arrays of 20 elements are 0 to 19.  Your loops should be written:</p>

<pre><code>for (i = 0; i &lt; 20; i++)
    a[i] = rand() % s;
</code></pre></li>
<li><p>The call to <code>init</code> should read:</p>

<pre><code>init(x, y, vx, vy, m);
</code></pre></li>
<li><p>You should not define the variables at the global scope, make them local variables in the body of the <code>main</code> function and define <code>i</code> in the body of the <code>init</code> function too.</p></li>
<li><p><code>=-</code> is not an operator, the statement <code>c[i] =- 20 + rand() % 40;</code> in parsed as <code>c[i] = -20 + (rand() % 40);</code> which is probably your intent, but your presentation is misleading. Use this instead:</p>

<pre><code>c[i] = -20 + rand() % 40;
</code></pre></li>
<li><p>The <code>;</code> after the <code>}</code> at the end of the body of the <code>for</code> statements are useless and should be removed.</p></li>
</ul>

<p>As currently written, the code invokes undefined behavior in many places, which means anything can happen.</p>
",0
40998014,40997975,2,"<p>When your <code>if</code> has no brackets <code>{  }</code>, it'll consider only the first statement when executing. Since your <code>if</code> has more than one, the else won't work, because it's not after an <code>if</code> anymore.</p>

<p>Do this:</p>

<pre><code>if (C)
{
   scanf_s(""%c"", &amp;C, sizeof(C));
   printf(""Circle"");
}
else
{
   (op == !!R, T, C);
   scanf_s(""%c"", &amp;op, sizeof(op));
}
</code></pre>
",0
40998033,40997975,2,"<p>The error on the <code>else</code> is quite correct, actually. Adding braces to show you what the compiler sees:</p>

<pre><code>if (C) {
  scanf_s(""%c"", &amp;C, sizeof(C));
}
printf(""Circle"");

// Now this else is really without a corresponding if
else (op == !!R, T, C);
</code></pre>

<p>As a general rule, you should use braces to make explicit what belongs to which conditional statement. In your case you probably meant to include the <code>printf</code> invocation in the block belonging to the <code>if</code> statement.</p>

<p>Note also that your <code>else</code> has a quite peculiar statement:</p>

<pre><code>(op == !!R, T, C);
</code></pre>

<p>While this is <em>legal</em>, it doesn't really <em>mean</em> anything. At best it's an exercise in how to confuse the reader (barring any funny macro expansions). Heck, I couldn't even begin to interpret what you <em>might</em> mean with that.</p>
",1
40998362,40997975,0,"<p>As everyone here has already pointed out, you're missing the curly braces to connect the ifs with the else.  Also, I don't think this site should be doing your homework for you.  But here's an outline of what you should probably be attempting to code, by yourself!</p>

<pre><code>char input;

// print request for user input (printf)

// read user input (scanf)

// check if user input represents a rectangle, then triangle, then circle, else unknown.
if( input == 'R') {
    // rectangle
} else if ( input == 'T' ) {
    // triangle
} else if ( input == 'C' ) {
    // circle
} else {
    // unknown
}
</code></pre>
",0
40998367,40997975,0,"<p>As Phiter and Joey answered, <code>{}</code> is the problem of error message about <code>else</code>.</p>

<p>And, <code>else</code> do not need any conditions. Your code looks like you intended ""if input is not R, T nor C, scan again', right? </p>

<p><code>else</code> means 'case that condition was not matched with above every <code>if</code> conditions', thus you don't need to write condition.</p>

<p>Anyway, first of all, it seems entire program has problem.
Read your textbook again, and mail to your TA.</p>
",0
40974059,40974006,2,"<p>Three issues:</p>

<ol>
<li><p>Your <code>scanf</code> is incorrect, you need to supply a <em>pointer</em> to <code>ch</code>. Use <code>scanf(""%c"", &amp;ch);</code></p></li>
<li><p>You mean <code>while (ch != 'e' &amp;&amp; ch != 'E');</code>. This is easy to see if you consider the case when <code>ch</code> is <code>e</code>. In that case <code>ch != 'E'</code> is <code>1</code> so the loop still terminates.</p></li>
<li><p>Rewrite <code>case 'e' || 'E':</code> to <code>case 'e' : case 'E':</code> <code>'e' || 'E'</code> has the value 1 in C.</p></li>
</ol>
",0
40977441,40977243,0,"<p>There are many IDE`s for C. You can try some of these and choose which you like:</p>

<ul>
<li>Microsoft Visual Studio</li>
<li>Eclipse</li>
<li>NetBeans </li>
<li>CLion</li>
<li>and much more</li>
</ul>

<p>If you want just to debug, and you use Linux you can use GDB debugger. </p>
",1
40962477,40962258,1,"<p><strong>Suggestion for cleanup</strong></p>

<p>When you have </p>

<pre><code>int a[20][20];
</code></pre>

<p>The valid range of elements are <code>a[0][0]</code> - <code>a[19][19]</code>.</p>

<p>You are accessing elements <code>a[1][1]</code> - <code>a[n1][n2]</code> in all the <code>for</code> loops since you are using:</p>

<pre><code>for(i=1;i&lt;=n1;i++){
    for(j=1;j&lt;=n2;j++){
</code></pre>

<p>That won't be a problem unless the value of <code>n1</code> or the value of <code>n2</code> is 20.</p>

<p>Change those loops to use:</p>

<pre><code>for(i=0; i &lt; n1; i++){
    for(j=0; j &lt; n2; j++){
</code></pre>

<p><strong>Main problem</strong></p>

<p>The main problem in your code is that you are using <code>max</code> before it's initialized. Add a line to initialize <code>max</code> to <code>a[0][0]</code> before the loop to compute its final value.</p>

<pre><code>// Remove the `do-while` part. You don't need it.
max = a[0][0];
for(i=0; i &lt; n1; i++){
    if(a[i][i]&gt;max) {
        max=a[i][i];
    }
}
</code></pre>
",3
40963251,40962258,3,"<p>You iterate completely through the diagonal elements, keeping track of only the maximum <em>value</em>, then (after the loop) you try to swap this value with the first element of the matrix. The problem is that you no longer know <em>where</em> the maximum value was, since you never recorded that! You just record <em>what</em> the value was (in <code>max</code>), and ignored its <em>index</em> in the matrix.</p>

<p>For example, suppose your maximum value happens to be at <code>a[2][2]</code>. You iterate through the diagonal elements, find the maximum <em>value</em>, store it in <code>max</code>. At the end of your loop, you can't swap <code>a[2][2]</code> with <code>a[0][0]</code> because you lost the information that the maximum is at <code>a[2][2]</code>. (Assuming you learned the issue about array indexes starting at 0.) What you are doing is writing <code>max</code> to the first element <code>a[0][0]</code>. <code>a[2][2]</code> is unchanged because you don't change it, and you forgot where it was to change it anyway.</p>

<p>You need to keep track of the maximum <em>value</em> in some variable (<code>max</code> as it is written now is fine) and add another variable (say, <code>max_pos</code> for example) to keep track of the <em>index</em> of where this maximum value is. (You only need one <code>int</code> because they're diagonal elements, so both array indexes are always the same.) Any time you change the maximum value <code>max</code>, also update the maximum position <code>max_pos</code>. This way you would know at the end to swap <code>a[0][0]</code> and <code>a[max_pos][max_pos]</code>.</p>

<hr>

<p>A brief sketch of what the code might look like (I'll leave it you to fill in any details):</p>

<p>Add a declaration of a new variable to keep track of the <em>position</em> (say, <code>max_pos</code>) of the maximum value:</p>

<pre><code>int i, j, n1, n2, max, max_pos;
</code></pre>

<p>You need to initialize <code>max</code> and <code>max_pos</code> with the first diagonal element, then iterate through the others.</p>

<pre><code>max = a[0][0];
max_pos = 0;
for (i=0; i&lt;n1; i++){
    if (a[i][i] &gt; max) {
        max = a[i][i];
        max_pos = i;    // update max_pos anytime max is updated
    }
}
</code></pre>

<p>Notice how I changed the range of the indexes from 1...<em>n1</em> to 0..<em>n1</em>-1. (Make this consistent with the rest of your code.) Array indexes in C start with 0, not with 1. Notice here that you don't need that <code>do {} while ()</code> loop. Think about what it is really doing (hint: nothing).</p>

<p>Then, after this, you can swap <code>a[0][0]</code> and <code>a[max_pos][max_pos]</code>. By the way, <a href=""https://stackoverflow.com/questions/16535461/why-dont-people-use-xor-swaps"">XOR swap</a> is not necessary and makes the code harder to read. Just swap values with a temporary variable. Modern compilers are very good at optimizing and can likely implement this with registers, so you're probably not gaining whatever efficiency you think you are (and you're only doing it once). Don't try to outsmart your compiler.</p>
",0
44743450,44743212,0,"<p>Check the below code, you might wanna understand the code, rather than just copy pasting it.</p>

<ol>
<li><p>The code delegates the task of doing a repetitive task to a function.</p></li>
<li><p>The code then relies on the function to say how many chances player has played, or -1 for successful. </p></li>
<li>And note the <code>getchar()</code> rather than <code>scanf</code>.</li>
</ol>

<p>NOTE: The extra getchar() is needed, because I don't know but taking character input after taking integer input puts a <code>'\n'</code> character in the <code>stdin</code>, which results in unwanted behaviour. So this is a small trick I always use to tackle such cases.</p>

<ol start=""4"">
<li><p>Pay attention to the <code>do while</code> loop, this case becomes a classic example where you should use <code>do while</code> loop.</p></li>
<li><p>Also I have used macros to define <code>MAX_GUESS</code>. That's a good practice. You might wanna google it for ""why?""</p></li>
</ol>

<p>If you have any further queries, do comment in the answer.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;

#define MAX_GUESS 5

int playGame(int number)
{
    printf(""\nOK, I am thinking of a number. Try to guess it. \n"");

    int i, currentGuess;

    for (i=0; i&lt;MAX_GUESS; i++){

        printf(""\nYour guess?: "");
        scanf(""%i"", &amp;currentGuess);

        if (currentGuess &gt; 200) {
            printf(""Illegal guess. Your guess must be between 1 and 200.\n"");
            printf(""Try again.\n "");
        }

        else if (currentGuess &gt; number) {
                printf(""Too high!\n"");
        }


        else if (currentGuess &lt; number) {
            printf(""Too low!\n"");

        }

        else {
            printf(""****CORRECT****\n"");
            return 0;
        }
    }

    return i;
}

int main() {


    int i, number, x;

    char answer = 'n';

    time_t t;

    srand((unsigned)time(&amp;t));

    printf(""Welcome to the game of Guess It! \nI will choose a number between 1 and 200. \nYou will try to guess that number."");
    printf(""If you guess wrong, I will tell you if you guessed too high or too low. \nYou have 5 tries to get the number. \n"");

    do
    {
        number = rand()%200+1;
        x = playGame(number);

        if (x == MAX_GUESS)
            printf(""Sorry you have entered the maximum number of tries. \n"");

        printf(""Want to play again? \n"");

        // To flush the newline character
        getchar();
        answer = getchar();

    } while (answer != 'n' || answer != 'N');

    printf(""Goodbye, it was fun. Play again soon.\n"");

    return 0;
}
</code></pre>
",2
44743244,44743212,0,"<p>Here's an idea for you to do this in your code:</p>

<pre><code>char answer = 'y';

do
{
    // ...
    printf( ""Want to play again (y/n)? "" );
    scanf( "" %c"", &amp;answer );
    // Mind ^ the space here to discard any
    // previously read newline character

} while ( answer == 'y' );
</code></pre>
",3
40964555,40964467,1,"<p>You need to create Array.</p>

<p>This is how you declare it:</p>

<pre><code>    int LED[N] 
</code></pre>

<p>N here is number of elements that you can put in this array.</p>

<p>And now you got an Array of elements. You can put element in it with your for loop.
 Example:</p>

<pre><code>   LED[0] = 2 //This is how you give value of 2 to 0 element of an Array
   LED[2] = 2 //This is how you give value of 2 to 2. element of an Array
</code></pre>

<p>It will work with for loop you created</p>
",0
40970863,40968289,2,"<p>Two things :</p>

<p>1.You need to declare <code>struct node *hashTable</code> below the structure definition,</p>

<pre><code>//Hash table structure    
//struct node *hashTable; &lt;--- incorrect
struct node{
    int marker;
    char *key;
    char *value;
};
struct node *hashTable;
</code></pre>

<p>2.You are re-declaring <code>struct node *hashTable</code> in main(). </p>

<p><code>struct node *hashTable = malloc(sizeof(struct node)* len);</code></p>

<p>The scope of this pointer will be local. </p>

<p>You have already declared <code>struct node *hashTable</code> globally.</p>

<p>Use :</p>

<p><code>hashTable = (struct node *)malloc(sizeof(struct node)* len);</code></p>

<p>3.why are you dynamically allocating memory for <code>marker</code>? It is an int member of <code>struct node</code>. It has <code>sizeof(int)</code> bytes of memory.</p>

<p><code>hashTable[i].marker =(int*)malloc(sizeof(int));</code> ---> Not needed. You can comment it.</p>
",0
41184626,41184513,5,"<p>I think it's the code line <code>ncolumn_matrix2=ncolumn_matrix2;</code> which leads to ncolumn_matrix2 to be 0, such that the loop is not entered</p>
",4
41188741,41186939,0,"<p>Keep in mind that the <em><a href=""http://man7.org/linux/man-pages/man3/rand.3.html"" rel=""nofollow noreferrer"">rand()</a></em> function is a <em><a href=""https://en.wikipedia.org/wiki/Pseudorandomness"" rel=""nofollow noreferrer"">pseudo random</a></em> number generator. Even when seeded with its companion function: <em><a href=""https://linux.die.net/man/3/srand"" rel=""nofollow noreferrer"">srand()</a></em>, it is not guaranteed to produce purely random numbers.  To use it successfully in the manner you have described, i.e. obtaining a list of unique values from some min to some max, it needs help...</p>

<p>Following are examples of companion functions that work in conjunction with the rand() pseudo-random generator to provide a list of values, guaranteed unique, between some min and some max:</p>

<p>Summary: <code>int random = (rand()/32767.0)*max;</code> will return a number no bigger than max which is then tested for value >= some min.   </p>

<pre><code>#include &lt;stdlib.h&gt; //defines rand(), srand() and RAND_MAX

int randomGenerator(int min, int max)
{
    int random, trying;
    srand(clock());//seed the rand() function before using it
                   //call frequency must be less than clock tick frequency
                   //or values will repeat. 
                   //  (problem with the word pseudo)
    trying = 1;    
    while(trying)
    {
        //random = (rand()/32767.0)*max;
        random = (rand()/(float)RAND_MAX)*(max+1);
        (random &gt;= min) ? (trying = 0) : (trying = 1);
    }
    return random;
}
</code></pre>

<p>To obtain the complete list of unique values needed, keep a list  of previously obtained values (within 'A' to 'Z') and exclude them as they are returned until you have a sequenced through a unique set.  Perhaps something like this example:  </p>

<pre><code>BOOL filled(int *p, size_t size)
{
    int i;
    BOOL results = TRUE;
    for(i=0;i&lt;size;i++)
    {
        if(p[i] == 0) 
        {
            results = FALSE;
        }
    }
    return results;

}
</code></pre>

<p>Example usage of both functions together:</p>

<pre><code>int main(void)
{
    int result, i;
    int c='g';
    int previous['Z'-'A'+1] = {{0}}; //size array to contain alphbet, 
                                     //initialize all elements 
    size_t size = sizeof(previous)/sizeof(previous[0]);

    while(c != 'q')
    {
        while(!filled(previous, size))
        {
            result = randomGenerator('A', 'Z');
            if( previous[result - 'A'] != 1)
            {
                previous[result -'A'] = 1;
                printf(""%c\n"", result);
            }
            Sleep(1); // 1ms delay to avoid aliasing the clock() function
        }
        printf(""finished!\n"");
        printf(""'q' to quit, any other key to continue\n"");
        c = getchar();
        memset(previous, 0, size*sizeof(int)); 
    }
    return 0;
}
</code></pre>
",2
41200890,41200192,1,"<p>Currently, your code is designed to <strong>stop</strong> if it is working as apparently expected. You have probably written the test the other way round.</p>

<p>Once the <code>search</code> function has been fixed to iterate by returning the result of itself (return search(...)), this code executes:</p>

<pre><code>// insert node 4 on tree
insert(&amp;root, 4);

// check if tree nodes are now equal to arrExp that has now the 4 node
</code></pre>

<p>Now: you are outputting 11 nodes to <code>ap</code> which is pointing to an area reserved for 10 numbers. Quite clearly this <em>cannot</em> work. In this case it <em>appears</em> to work (i.e., it does not crash) because you're overwriting the next variable on the stack.</p>

<p>But even so, you're now comparing an 11-element tree to a 10-element vector (arr). They simply cannot be equal.</p>

<p>(BTW, you do not need to qsort arr again):</p>

<pre><code>outToArray(root, &amp;ap);
qsort(arr, n, sizeof(*arr), cmp);
for (i = 0; i &lt; n; i++) {
    if (arr[i] != arrExp[i]) {
        puts(""not same"");
        return -1;
    }
}
puts(""same"");
</code></pre>

<p>The above code of course finds the ""4"" element, which is not in arr, outputs ""not same"" and stops. You probably wanted:</p>

<pre><code>outToArray(root, &amp;ap);
for (i = 0; i &lt; n; i++) {
    if (arr[i] != arrExp[i]) {
        break;
    }
}
if (i == n) {
    puts(""same. This should not happen"");
    exit(1);
} else {
    puts(""not same, as expected.""); 
}
</code></pre>

<p>You need to fix arrays to hold space enough to work:</p>

<pre><code>int arrExp[sizeof(arr)/sizeof(*arr) + 2];
</code></pre>

<p>Then you cannot make <code>aporder</code> point to <code>arr</code>, since you're going to put 11 elements in it, which would mean write 11 elements to arr, which would overwrite the stack (and the value of root, of all things!).</p>

<pre><code>int *aporder = arrExp;
</code></pre>

<p>Finally, since you do not need to modify the value pointed to, you can simplify the <code>search()</code> function. I've added some more debug code:</p>

<pre><code>node* search(node *tree, int val)
{
    printf(""Start %08lx\n"", tree);
    if (tree) {
            if (val &lt; tree-&gt;data)
            {
                printf(""%d less than %d, going left\n"", val, tree-&gt;data);
                return search(tree-&gt;left, val);
            }
            if(val &gt; tree-&gt;data)
            {
                printf(""%d more than %d, going right\n"", val, tree-&gt;data);
                return search(tree-&gt;right, val);
            }
    }
    return tree;
}
</code></pre>
",2
41200906,41200192,1,"<p>Your code does not consider adding elements.<br>
Change it as like follows.</p>

<pre><code>int main(void) {
    node *root = NULL;
    int i;
    int arr[] = {55, 31, 49, 64, 65, 39, 47, 98, 97, 1};
    int n = sizeof(arr)/sizeof(*arr);
    int arrExp1[sizeof(arr)/sizeof(*arr)] = {0};
    int arrExp2[] = {1, 4, 31, 39, 47, 49, 55, 64, 65, 97, 98};
    int arrExp3[] = {55, 31, 1, 4, 49, 39, 47, 64, 65, 98, 97};
    int *ap = arrExp1;

    // insert nodes of arr on tree
    for (i = 0; i &lt; n; i++)
        insert(&amp;root, arr[i]);

    // check if the array elements are the same of the tree
    outToArray(root, &amp;ap);
    qsort(arr, n, sizeof(*arr), cmp);
    for (i = 0; i &lt; n; i++) {
        if (arr[i] != arrExp1[i]) {
            puts(""not same"");
            return -1;
        }
    }
    puts(""same"");

    // insert node 4 on tree
    insert(&amp;root, 4);

    // check if tree nodes are now icual to arrExp2 that has now the 4 node
    int out2[++n];
    ap = out2;
    outToArray(root, &amp;ap);
    for (i = 0; i &lt; n; i++) {
        if (out2[i] != arrExp2[i]) {
            puts(""not same"");
            return -1;
        }
    }
    puts(""same"");

    // check if pre order display is icual to ArrExp3
    ap = out2;
    outToArrayPorder(root, &amp;ap);
    for (i = 0; i &lt; n; i++) {
        if (out2[i] != arrExp3[i]) {
            puts(""not same"");
            return -1;
        }
    }
    puts(""same"");

    node *tmp = search(&amp;root, 55);
    if (tmp)
    {
        printf(""Searched node=%d\n"", tmp-&gt;data);
    }
    else
    {
        printf(""Data Not found in tree.\n"");
    }

    /* Deleting all nodes of tree */
    deltree(root);

    return 0;
}
</code></pre>

<hr>

<p>For comments.<br>
sample code:</p>

<pre><code>n = sizeof(arr2)/sizeof(*arr2);//length of arr2
for (i = 0; i &lt; n; i++)
    insert(&amp;root, arr2[i]);//values of arr2 add to tree

n = print_preorder(root);puts("""");//number of elements of tree

int out4[n];//new array for store tree to array
ap = out4;
outToArrayPorder(root, &amp;ap);

if(sizeof(out4) == sizeof(arrExp4) &amp;&amp; memcmp(out4, arrExp4, sizeof(out4))==0)//Each size may not be equal.
    puts(""same4"");
else
    puts(""not same"");
</code></pre>
",12
45056794,45056618,4,"<p>Lets take a close look at these two lines:</p>

<pre><code>char num[1];
...
sprintf(num,""%d"",i);
</code></pre>

<p>You declare <code>num</code> as an array of a <em>single</em> character, forgetting that (<code>char</code>) strings in C are really called <strong><em>null terminated</em></strong> <em>byte strings</em>. That means a string of a single character needs space for <em>two</em> <code>char</code> elements, to fit the terminator.</p>

<p>Since you don't have space for the terminator then <code>sprintf</code> will write <em>out of bounds</em> of your array, leading to <em>undefined behavior</em> and your smashed stack.</p>

<p>If you are certain that the number will never be more than a single digit (which it wont, it will include the two-digit number <code>10</code>), then you need to have an array of at least two character elements.</p>

<p>I also recommend you use <a href=""http://en.cppreference.com/w/c/io/fprintf"" rel=""nofollow noreferrer""><code>snprintf</code></a> to avoid buffer overflows like that.</p>
",0
45057794,45056618,0,"<p>thanks for all the help, what Some Programmer Dude said did help i think but i still had an issue. I found that the issue was the line</p>

<pre><code>strcat(buffer4,buffer3);
</code></pre>

<p>As the buffer size for both was the same, it was creating a string which requires a buffer of 80?</p>

<p>i amended the line </p>

<pre><code>char *buffer4 =malloc(buffer_size * sizeof(char));
</code></pre>

<p>to read </p>

<pre><code>char *buffer4 =malloc(80 * sizeof(char));
</code></pre>

<p>And this now works without stack smashing</p>

<p>Thanks!</p>
",0
41927433,41927404,1,"<p>The <code>break</code> stops the <code>while</code> loop after the first iteration, so it only checks the first option. I'm guessing that you originally had a <code>switch</code> statement there, so the <code>break</code> was used to exit the <code>switch</code> and continue with the <code>while</code> loop. Since you don't have <code>switch</code>, an empty <code>while</code> loop should work instead.</p>

<p>Other issues: </p>

<ul>
<li>You shouldn't pass in <code>""f""</code> if you don't want a <code>-f</code> option to be accepted.</li>
<li>You may also want to check for a <code>'?'</code> return value, which indicates when an unknown option was used.</li>
</ul>
",0
41943128,41943025,4,"<p>Can't verify that this is the only problem, but you are checking  <code>tmp-&gt;size &lt; size</code>, when you probably should check <code>tmp-&gt;size &gt;= size</code> instead.</p>
",3
42626617,42626573,6,"<p>Nothing to do with c, you're performing a <code>system</code> call on a command that doesn't necessarily exist.</p>

<p><code>color</code> exists in the Windows shell, but doesn't on Linux. Your code is just not portable on Linux as-is.</p>

<p>Linux has its own way of doing it. You should check which OS you're running on and call the <a href=""https://superuser.com/questions/651405/change-font-color-on-linux-terminal""><code>setterm</code></a> instead for instance if you detect Linux (or at compilation time), so you already have Windows &amp; Linux covered.</p>

<p>As a portable alternative, standard <a href=""https://stackoverflow.com/questions/2048509/how-to-echo-with-different-colors-in-the-windows-command-line/38617204#38617204"">ANSI escape sequences</a> are also widely available on a lot of OSes (For Windows, <a href=""https://stackoverflow.com/questions/16755142/how-to-make-win32-console-recognize-ansi-vt100-escape-sequences"">you need Windows 10</a>, though)</p>
",4
46976618,46976208,0,"<p>It looks like you don't have a struct called Node. Import it from other file or just implement it. C is good but it's not a magician so far.</p>
",0
46976806,46976208,2,"<p>You are missing underscore when declaring next.</p>

<pre><code>typedef struct _Node
{       
    int data;
    struct _Node *next;
} ListNode;
</code></pre>
",0
42383961,42383916,-1,"<p>On Linux and Posix systems, you might use globbing related functions. See <a href=""http://man7.org/linux/man-pages/man7/glob.7.html"" rel=""nofollow noreferrer"">glob(7)</a> and look into <a href=""http://man7.org/linux/man-pages/man3/glob.3.html"" rel=""nofollow noreferrer"">glob(3)</a>, <a href=""http://man7.org/linux/man-pages/man3/fnmatch.3.html"" rel=""nofollow noreferrer"">fnmatch(3)</a>, <a href=""http://man7.org/linux/man-pages/man3/wordexp.3.html"" rel=""nofollow noreferrer"">wordexp(3)</a> etc</p>

<p>Look also into <a href=""http://man7.org/linux/man-pages/man3/regcomp.3.html"" rel=""nofollow noreferrer"">regcomp(3)</a></p>

<p>If you need to write it by yourself, read about <a href=""https://en.wikipedia.org/wiki/Finite-state_machine"" rel=""nofollow noreferrer"">finite state machines</a>, <a href=""https://en.wikipedia.org/wiki/Context-free_grammar"" rel=""nofollow noreferrer"">context free grammars</a>, <a href=""https://en.wikipedia.org/wiki/Regular_grammar"" rel=""nofollow noreferrer"">regular grammars</a>, <a href=""https://en.wikipedia.org/wiki/Regular_expression"" rel=""nofollow noreferrer"">regular expressions</a>, <a href=""https://en.wikipedia.org/wiki/Parsing"" rel=""nofollow noreferrer"">parsing</a>.</p>
",1
42384503,42383916,1,"<p>Similar to how selection-sort algorithm works, but instead of checking integer value to arrange I'll just use a string comparison to select/remove and add an exception for (*). Iterate through the whole list and viola! </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {

    char inputString[] = ""AB**"";//input string (with asterisks)
    char comparisonString[] = ""AYYB"";//comparison string (without asterisks)

    int inputString_length = strlen(inputString);
    int comparisonString_length = strlen(comparisonString);

    int anagram = 1;//boolean

    if (inputString_length != comparisonString_length) {
        anagram = 0;
    } else {

        int i = 0;
        while ((i &lt; inputString_length) &amp;&amp; (anagram == 1)) {

            char *letterToCheck = inputString[0];
            memmove(&amp;inputString[0], &amp;inputString[0 + 1], strlen(inputString) - 0);//remove first character

            int j = 0;
            int comparisonString_length_new = strlen(comparisonString);
            int matchFound = 0;//boolean
            while ((j &lt; comparisonString_length_new) &amp;&amp; (matchFound == 0)) {
                char *letterToCompare = comparisonString[j];

                if (letterToCheck == '*') {
                    matchFound = 1;
                }

                if (letterToCheck == letterToCompare) {
                    matchFound = 1;
                    memmove(&amp;comparisonString[j], &amp;comparisonString[j + 1], strlen(comparisonString) - j);//remove matched character
                }

                j++;
            }

            if (matchFound == 0) {
                anagram = 0;
            }


            i++;
        }

    }


    if (anagram == 0) {
        printf(""Are NOT Anagrams"");
    } else {
        printf(""Are Anagrams"");
    }

}
</code></pre>

<p>Another solution where both input and comparison strings may contain * (Note: This solution below was added by an off-site user and not OP, it has also not been tested nor verified by OP)</p>

<pre><code>#include &lt;stdio.h&gt;

#define CHAR_LEN 4
#define SPECIAL_CHARACTER '*'

int count_special_char(char *string) {
    int i = 0, count = 0;
    for(i = 0; i &lt; CHAR_LEN; i++) {
        if(string[i] == SPECIAL_CHARACTER)
            count++;
    }
    return count;
}

int is_anagram(char *string_a, char *string_b) {
    int i, y;
    int found_count = 0;
    int a_special = count_special_char(string_a);
    int b_special = count_special_char(string_b);

    for(i = 0; i &lt; CHAR_LEN; i++) {
        if(string_a[i] == SPECIAL_CHARACTER) //compare only non-asterisk char
            continue;

        for(y = 0; y &lt; CHAR_LEN; y++) {
            if(string_a[i] == string_b[y]) {
                string_b[y] = '\0' //treat this char as found
                found_count++;
                break;
            }
        }
    }

    if((found_count + a_special + b_special) &gt;= CHAR_LEN)
        return 1;
    else
        return 0;
}

int main() {
    char a[CHAR_LEN] = ""**CD"";
    char b[CHAR_LEN] = ""AB**"";

    if(is_anagram(a, b))
        printf(""yes\n"");
    else
        printf(""no\n"");

    return 0;
}
</code></pre>

<p>A*** and *XYZ is assumed as anagram because first string has 3 * which can represent second string XYZ. And second string has 1 * which can represent first string A. If there are any mistakes do point out and help. Thanks!</p>
",2
43966293,43966192,0,"<p>In your code <code>temp2</code> is always NULL.<br>
Try below snippet</p>

<pre><code>void inOrder(struct TreeNode* temp1, struct TreeNode* temp2, int* result) {
    if (temp1-&gt;left != NULL) {
        inOrder(temp1-&gt;left, temp1, result);
    }
    if (temp2 != NULL) {
        int dif = temp1 -&gt; val - temp2 -&gt; val;
        if(dif &lt; 0) dif *= -1; //absolute diff
        *result = *result &gt; dif ? dif : *result;
    }
    printf(""%p\n"", temp2);
    //temp2 = temp1;
    if (temp1-&gt;right != NULL) {
        inOrder(temp1-&gt;right, temp1, result);
    }
}
</code></pre>
",3
42603879,42602961,1,"<ul>
<li><code>number = ( input / 100 ) * 81;</code> will be 0 for <code>0 &lt;= input &lt; 100</code> because results of integer division is truncated.<br>
Try <code>number = input * 81 / 100;</code> instead.</li>
<li>Top row and leftmost column won't become space because extra one is added when generating the random numbers.<br>
Try using <code>row_random [k] = rand () % 9;</code> and <code>column_random [k] = rand () % 9;</code></li>
<li>Only the last element of <code>row_random</code> and <code>column_random</code> is effective because <code>'0'</code> is assigned to <code>check</code> whenever the condition <code>j == column_random [k] &amp;&amp; i == row_random [k]</code> is false.<br>
Move <code>check = '0';</code> just before the loop <code>for ( k = 0; k &lt; number; k++ )</code>.</li>
<li><em>Undefined behavior</em> will be invoked by using value of uninitialized variable having automatic storage duration <code>check</code>, which is indeterminate, when <code>number = 0</code>.<br>
Initialize <code>check</code> when declareing it.</li>
<li>Two characters is printed for non-space (<code>check == '0'</code>), but only one character is printed for space (<code>check == '1'</code>), so the format will be broken.<br>
Have it print one more character for space if you want.</li>
</ul>

<p>These changes will make the behavior better, but number of spaces may be lesser than expected because duplicate position may be selected.
To avoid this, you should</p>

<ol>
<li>List up all 9*9 positions in one array.</li>
<li>Shuffle the array.</li>
<li>Take the first <code>number</code> elements of the shuffled array and use them as the place to turn to space.</li>
</ol>
",2
42523444,42523304,3,"<p>The <code>FILE *</code> returned by <code>fopen</code> is an unnecessary, but useful, layer of indirection.</p>

<p>Theoretically, <code>fopen</code> could have been designed to read the whole file into a buffer in memory, and just return you that buffer.</p>

<p>The issue approach is that it's not flexible at all. It forces you to read the entire file for all file IO operations, which is <em>very</em> undesirable. For example, here are some problems that would come about:</p>

<ul>
<li>How could you read a file that's too big to fit in RAM?</li>
<li>What if you just want to append a new line at the end of a file (such as for logging). You would have to read the whole file, append the line at the end, then rewrite the entire file back. Expensive!</li>
<li>What if you're only interested in reading a small part of a file, such as reading the <a href=""https://en.wikipedia.org/wiki/Magic_number_(programming)"" rel=""nofollow noreferrer"">magic number</a> to identify the file's type, without regard for its actual content?</li>
<li>What if you wanted to simultaneously edit the file from multiple programs. Each program need to constantly reread the whole file into memory, to ensure it kept up-to-date.</li>
</ul>

<p><code>fopen</code> returns a file handle that identifies a file still on disk. How much you read out of this file into memory is entirely up to you.</p>
",0
42523829,42523304,0,"<p>The explanation given above is pretty much self explanatory , still I would try to make it simple (in case anyone has problem understanding it)</p>

<p><strong>In Short,consider this example and you yourself would know 'why?'</strong></p>

<p><em>1) your files might be too large and stored in your hard drive , then if you try reading it frequently, don't you think this is an overhead for loading whole file again and again.</em></p>

<p><em>2) And more worse say the file is huge then if you load whole of your file it consumes your RAM even if you don't need whole file at once.</em></p>

<blockquote>
  <p>Why, in C, do you need a separate buffer to read a FILE *?</p>
</blockquote>

<p>First thing, Because reading into buffers and then using it is always faster. </p>

<blockquote>
  <p>does the file then not exist in contiguous memory starting at the
  address of said pointer?</p>
</blockquote>

<p>May or May not be ,depending on its size.</p>

<blockquote>
  <p>If someone could explain how theFIlE *file = fopen(filename, ""r"") and
  the subsequent fread(&amp;buffer,...) work in conjunction</p>
</blockquote>

<p>The fopen() function is used to open a file and associates an I/O stream with it. This function takes two arguments. The first argument is a pointer to a string containing name of the file to be opened while the second argument is the mode in which the file is to be opened.</p>

<p>Various modes can be like <code>r, r+, w, w+, a, a+</code> .</p>

<p>The fopen() function returns a FILE stream pointer on success while it returns NULL in case of a failure.</p>

<p>Look <a href=""http://www.thegeekstuff.com/2012/07/c-file-handling"" rel=""nofollow noreferrer"">here</a> for detailed info.</p>
",0
42524485,42523304,0,"<blockquote>
  <p>Why, in C, do you need a separate buffer to read a FILE *?</p>
</blockquote>

<p>No buffer aren't necessary while they are usually present to accelerate I/Os.</p>

<blockquote>
  <p>When you declare a FILE * and assign to it with fopen, does the file
  then not exist in contiguous memory starting at the address of said
  pointer?</p>
</blockquote>

<p>Certainly not, 'cause this would be at least inefficient (why read a entire file huge if it is not needed at the end?) and at worst impossible at all (RAM size is usually much less than DISK size).</p>

<blockquote>
  <p>If someone could explain how the FILE *file = fopen(filename, ""r"") and
  the subsequent fread(&amp;buffer,...) work in conjunction it would help my
  understanding tremendously.</p>
</blockquote>

<p>Then FILE * is not an handle to a memory object that contains the file data, but is a memory object that contains data to help accessing file data on disk. That opaque object (opaque means don't try to look inside details are hidden) contains for example the current offset (remember when you read or write this is done at a given offset and this would modify the offset accordingly), or the open mode (this way writing into an opened for read file will correctly fails), or some buffer (that may contains part of the file and sometimes the whole file!), etc. A FILE * is handle as a handle for a door. Don't confuse file and FILE*, the first is a generic term to embrace what you already know (data on disk), then second is a type to represent an <strong>opened file</strong> which is a dynamic object to represent manipulation of a given file.</p>

<blockquote>
  <p>I'm struggling to make the connection as to why you need need to read
  via fread() into a separate buffer.</p>
</blockquote>

<p>If you don't have/can't have the file in memory, then you need to ask for reading the part you are interested in.</p>
",0
42577177,42576479,0,"<p>Working from the code you give (i.e. counting words by finding delimiting spaces), you can solve the multiple spaces problem by remembering the last character ignoring subsequent spaces</p>

<pre><code>    while (c != end)
    {
        c = getchar();
        if (c == ' ' &amp;&amp; previous_c != ' ')
                words++;
        previous_c = c;
    }
</code></pre>

<p>Note though that if the user <em>begins</em> the input with a single space, then the program will still count this as one word. To prevent this you should initialse <code>previous_c</code> to some known value (e.g. <code>0</code>) and check for this case also. This means the <code>if</code> condition would become <code>(c == ' ' &amp;&amp; (previous_c != ' ' || previous_c == 0))</code></p>

<p>As Cool Guy commented, the program you've shown already ignores punctuation as-is.</p>

<p>As another improvement I would suggest looking at using a <code>do...while</code> loop instead of the <code>while</code> loop to reduce the places you need to call <code>getchar()</code></p>
",0
42578118,42576479,0,"<p>I would split it in 2 loops. One for skipping all non-word-chars and a second to skip the word-chars. Between these loops starts a word and will be counted.</p>

<pre><code>#include &lt;stdio.h&gt;
int main()
{
  char c;
  int words = 0;
  printf(""please enter a sentence: \n"");
  for(;;) {
    while((c=getchar())!=EOF &amp;&amp; !isalpha(c));
    if(c==EOF) break;
    words++;
    while((c=getchar())!=EOF &amp;&amp; isalpha(c));
    if(c==EOF) break;
  }
}
</code></pre>
",0
42656365,42656182,0,"<p>Your circle function should look like this: The meat and potatoes of your function is <code>sqrt((j-(k)/2)*(j-(k)/2) + (i-(k)/2)*(i-(k)/2))&lt;=radius</code>. The formula should look familiar if you've taken advanced math. k is surface and can be adjusted.</p>

<p>it essentially charts out your 50x50 surface area (or whatever k is). x,y are the different points along the plane.</p>

<p>(x-center)^2+(y-center)^2&lt;=radius</p>

<pre><code>void Circle(int radius) {
    int i,j;
    int k = 50;
    for (i=0; i&lt;k; i++) {
        for (j=0; j&lt;k; j++) {
            if(sqrt((j-(k)/2)*(j-(k)/2) + (i-(k)/2)*(i-(k)/2))&lt;=radius)
                printf(""*""); //meets criteria print *
            else
                printf("" ""); //blank space
        }
        printf(""\n"");
    }
}
</code></pre>

<p>With a radius of 20:</p>

<pre><code>                     *                        
               *************                  
             *****************                
           *********************              
         *************************            
        ***************************           
       *****************************          
      *******************************         
     *********************************        
     *********************************        
    ***********************************       
    ***********************************       
   *************************************      
   *************************************      
  ***************************************     
  ***************************************     
  ***************************************     
  ***************************************     
  ***************************************     
  ***************************************     
 *****************************************    
  ***************************************     
  ***************************************     
  ***************************************     
  ***************************************     
  ***************************************     
  ***************************************     
   *************************************      
   *************************************      
    ***********************************       
    ***********************************       
     *********************************        
     *********************************        
      *******************************         
       *****************************          
        ***************************           
         *************************            
           *********************              
             *****************                
               *************                  
                     *                        
</code></pre>

<p>if you don't want to use math.h you can define a custom sqrt:</p>

<pre><code>double sqrt(float number)
{
    double precision = 0.001;
    double s = number;

    while ((s - number / s) &gt; precision) {
        s = (s + number / s) / 2;
    }
    return s;
}
</code></pre>
",6
42624619,42624505,2,"<p>The behaviour of your program is <em>undefined</em>.</p>

<p>You should check the return value of <code>scanf</code>, which tells you the number of data that are read into the passed arguments. In your case the return value will be zero, as <code>%d</code> cannot be used to read in a <code>char</code>. So <code>u</code> is uninitialised, and therefore its value should not be read.</p>

<p>Note that the fact that you have passed in superfluous parameters to your <code>printf</code> is benign although, formally, such arguments are still evaluated. See <a href=""https://stackoverflow.com/questions/31559109/is-calling-printf-with-excess-arguments-undefined-behaviour"">Is calling printf with excess arguments undefined behaviour?</a>.</p>

<p>The moral of the story: <strong>always</strong> inspect the return value of <code>scanf</code>.</p>
",0
42625156,42624505,3,"<p>When <code>scanf()</code> reads input it cannot convert according to the specification, it stops scanning and returns the number of successful conversions. In your case, the character remains in the standard input buffer and <code>scanf()</code> returns <code>0</code>.</p>

<p>Your code has undefined behavior because <code>scanf()</code> fails to convert the input as an integer, leaving <code>u</code> uninitialized.  Passing this uninitialized value to <code>printf</code> has undefined behavior. In your case, a somewhat random value is printed, which may be different or not, but any other behavior is possible including a crash.</p>

<p>You must test the return value of <code>scanf()</code> to check if the conversion was successful.  Here is a modified version:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void) {
    int u, res;
    res = scanf(""%d"", &amp;u);
    if (res == 1) {
        /* conversion succeeded */
        printf(""%d\n"", u);
    } else
    if (res == 0) {
        /* conversion failed */
        printf(""input is not a valid number\n"");
    } else {
        /* res must be EOF */
        printf(""premature end of file: no input given\n"");
    }
    return 0;   
}
</code></pre>
",2
43721511,43721415,3,"<p>Your <code>process</code> is an array of <code>int</code>. You need to make it an array of function pointers.</p>

<pre><code>int (*process[])(void) = {0, 0, Greeting, 0, 0, 0};
</code></pre>

<p>Then call the function indirectly</p>

<pre><code>process[2]();
</code></pre>
",0
43721667,43721415,1,"<p>A simple example in which two function pointers are created first in a structure, then three functions are created. You initialize the function pointers with the function you want to call and then you pass the argument to get the work done.</p>

<pre><code>#include &lt;stdio.h&gt;

typedef struct
{
    /* Any function who take two int parameters and returns int can be pointed by this function pointer. */
    int (*function_name)(int a, int b);

    /* This can point to all functions having int argument and void return type */
    void (*print_fn)(int sum);

} FN_GROUP;

int add(int a, int b)
{
    return (a + b);
}

int subtract(int a, int b)
{
    return (a - b);
}

void show(int num)
{
   printf(""Result:%d\r\n"", num);
}

int main()
{
    int num1 = 20;
    int num2 = 10;
    int result = 0;   
    FN_GROUP group;

    /* Initialize the pointers with add() and show() functions. */    
    group.function_name = &amp;add;
    group.print_fn = &amp;show;

    /* Now call these functions. */
    result = group.function_name(num1, num2);
    group.print_fn(result);

    /* Initialize the pointers with subtract(). */        
    group.function_name = &amp;subtract;

    /* Now call these functions again */
    result = group.function_name(num1, num2);
    group.print_fn(result);

    return (0);
}
</code></pre>
",0
43224179,43223509,0,"<p>You have many problems in your code</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;inttypes.h&gt;

void byte_compare(uint64_t C, uint64_t D, int *array)
{
    int i = 0;

    while (i &lt; 8)
    {
        printf(""C = %""PRIx64""\n""  , (C&amp;0xFF));
        printf(""D = %""PRIx64""\n\n"", (D&amp;0xFF));

        if ((C&amp;0xFF) == (D&amp;0xFF))
        {
            array[i] = 1;
        }
        else
        {
            array[i] = 0;
        }

        i++;

        C &gt;&gt;= 8;
        D &gt;&gt;= 8;
    }
}

int main(void)
{
    int i = 0;

    uint64_t A = UINT64_C(0xAABBCCDDBBCCFFEE);
    uint64_t B = UINT64_C(0xAACCCCDDBBDDFF00);

    int array[8] = {0};

    byte_compare(A, B, array);

    while (i &lt; 8)
    {
        printf(""array[%d] - %d\n"", i, array[i]);
        i++;
    }
}
</code></pre>

<ol>
<li>Correct type for your variables must be <code>unsigned long long</code> due to the literals: bit 63 is set to 1 so assign it to a signed variable causes overflow which invoke <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">UB</a>. Using <code>stdint.h</code> standard header you can use <code>uint64_t</code> that is clearer.</li>
<li><code>byte_compare</code> function definition is wrong, you must pass parameters with correct type: <code>unsigned long long</code> (<code>uint64_t</code>). Moreover the function does not return an int so should be <code>void</code>.</li>
<li><code>printf</code> with <code>%x</code> format specifier wants an <code>unsigned int</code>, not a <code>uint64_t</code>. Best thing to do is to use defined in <code>inttypes.h</code> standard header where all format specifier are well reported: in your case <code>PRIx64</code> is the right one.</li>
<li>In your version of code you are left shifting a <code>long long int</code> that is used as mask to ""select"" the byte to check. It is plain wrong because last shift causes an overflow on a <code>signed</code> value that is <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">UB</a> as for point 1.</li>
<li><code>stdint.h</code> has also macros that append the correct suffix to literals.</li>
</ol>

<p>Another example using a mask:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;inttypes.h&gt;

void byte_compare(uint64_t C, uint64_t D, int *array)
{
    uint64_t mask = UINT64_C(0xFF00000000000000);

    while (mask &gt; 0)
    {
        printf(""C = %""PRIx64""\n""  , (C&amp;mask));
        printf(""D = %""PRIx64""\n\n"", (D&amp;mask));

        if ((C&amp;mask) == (D&amp;mask))
        {
            *array = 1;
        }
        else
        {
            *array = 0;
        }

        mask &gt;&gt;= 8;
        array--;
    }
}

int main(void)
{
    int i = 0;

    uint64_t A = UINT64_C(0xAABBCCDDBBCCFFEE);
    uint64_t B = UINT64_C(0xAACCCCDDBBDDFF00);

    int array[8] = {0};

    byte_compare(A, B, &amp;array[7]);

    while (i &lt; 8)
    {
        printf(""array[%d] - %d\n"", i, array[i]);
        i++;
    }
}
</code></pre>
",0
43195091,43194943,6,"<p>When you compile your code with %d being used for a pointer like &amp;my_age, you should get a  warning similar to: </p>

<pre><code>printf.c:10:1: warning: format ¡®%d¡¯ expects argument of type ¡®int¡¯, but argument 3 has type ¡®int *¡¯ [-Wformat=]
</code></pre>

<p>This is because you are using the wrong format option, and this results in unspecified behavior. The results are architecture and implementation dependent. In other words, unpredictable. Don't do that. </p>

<p>On my computer for example, the %d expects a 4 byte value, while an address like &amp;my_age is a 8 byte value. On my computer, this results in printf displaying the least significant 4 bytes of the pointer (which has a 1 in its msbit, so is interpreted as a negative 4 byte integer).</p>

<pre><code>#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt; 

int main(){ 

int my_age = 24;        
printf(""sizeof(my_age)=%d, sizeof(&amp;my_age)=%d\n"", sizeof(my_age), sizeof(&amp;my_age));
printf(""%d \t %p\n"",my_age, &amp;my_age); 
printf(""%d \t %d\n"",my_age, &amp;my_age); 
}
</code></pre>

<p>Results in output:</p>

<pre><code>sizeof(my_age)=4, sizeof(&amp;my_age)=8
24   0x7ffdf27cb52c
24   -226708180
</code></pre>

<p>The least significant 4 byte hex value of the pointer is f27cb52c and is interpreted as decimal -226708180.</p>

<p>Since specifics are architecture dependent, your results may vary. 
See post <a href=""https://stackoverflow.com/a/26155187/6693299"">here</a> for more details.</p>

<p><strong>Bottom line: ensure that all warnings are resolved before testing your code.</strong></p>
",2
43195184,43194943,2,"<p><code>%p</code> is displaying the address in hex and </p>

<p><code>%d</code> is displaying the address in decimal</p>

<p><code>%x</code> will display it in hex</p>

<p>The <code>%</code> specifiers that you can use in ANSI C are:</p>

<p>Usual variable type Display</p>

<pre><code>%c char single character
%d (%i) int signed integer
%e (%E) float or double exponential format
%f float or double signed decimal
%g (%G) float or double use %f or %e as required
%o int unsigned octal value
%p pointer address stored in pointer
%s array of char sequence of characters
%u int unsigned decimal
%x (%X) int unsigned hex value
</code></pre>

<p><a href=""https://www.le.ac.uk/users/rjm1/cotter/page_30.htm"" rel=""nofollow noreferrer"">Reference</a></p>
",2
45110036,45109944,6,"<p>That's 1KB, not 1MB.. which isn't much memory these days (35 years ago, it was a lot).</p>

<p>As to why it's using that much: <code>printf</code> uses buffered I/O, which allocates buffers.  The exact answer really depends upon the platform since c libraries and operating systems will vary.  But if you were to write the same program using just system calls eg. <code>write</code> instead of <code>printf</code>, you'd probably see the memory usage go down.</p>
",4
45110220,45109944,2,"<p><code>printf</code> buffers I/O before it actually writes that data to standard out (as @little_birdie mentioned). Buffered I/O refers to the practice of temporarily storing I/O operation in your application (user-space) prior to transmitting it to the kernel, which can be slow. In order to minimize these so called <em>system calls</em>, your application will ask for such memory ahead of time.</p>

<p>It is not uncommon for certain features of the system to disable this feature entirely, or even perhaps for a historical system to not have buffered I/O at all (although I'm not familiar with any).</p>

<p>If you want to disabled buffering on your <code>stdout</code> here (and thus allocation ""0"" bytes of heap memory), you can ask for it with <code>setbuf</code> like so:</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    int distance = 100;
    setbuf(stdout, NULL);
    printf(""You are %d miles away.\n"", distance);
    return 0;
}
</code></pre>

<p>If you want to learn more about this, check out the excellent <a href=""http://man7.org/tlpi/"" rel=""nofollow noreferrer"">Linux Programming Interface</a></p>
",0
43214436,43214338,1,"<p>This can't work:</p>

<pre><code>void init_test(test t) {
    t = (test)malloc(100 * sizeof(test));
}
</code></pre>

<p>It does not assign <code>t</code> to the <strong>caller</strong> <code>init_test(t)</code>, it just throws the pointer away since the argument <code>t</code> goes out of scope and its lifetime ends at the end of the function. You would have to save the malloc result and pass it to the caller, e.g. with</p>

<pre><code>init_test(&amp;t);
</code></pre>

<p>along with this</p>

<pre><code>void init_test(test *t) {
   *t = malloc(100 * sizeof **t);
}
</code></pre>

<p>And <strong>don't cast malloc</strong> (search this site why).</p>
",1
43214444,43214338,0,"<p>This will work. You were working with local variable('t').</p>

<pre><code>typedef unsigned char * test;

test init_test(test t);
test insert(test t);



int main() {

    test t;
    t = init_test(t);
    t = insert(t);

    printf(""%d\n"", t[3]);

    free(t);
    return 0;
}

test init_test(test t) {
    t = (test)malloc(100 * sizeof(test));
     return t;
}

test insert(test t) {
    t[0] = 200;
    t[1] = 201;
    t[2] = 202;
    t[3] = 203;
    t[4] = 204;
    return t;
}
</code></pre>
",1
43214464,43214338,1,"<p>In C, all function parameters are pass by value.  So your <code>init_test</code> function is updating a local value which is not reflected in the calling function.  As a result, <code>t</code> in <code>main</code> is still uninitialized after this call.  You then pass this uninitialized pointer to <code>insert</code> which tries to dereference that pointer.  This invokes <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behavior</a> which in this case manifests as a crash.</p>

<p>Instead of taking a parameter, have <code>init_test</code> return the allocated pointer and assign the return value to <code>t</code>.</p>

<p>So define your function like this:</p>

<pre><code>test init_test() {
    test t = malloc(100 * sizeof(*t));  // not sizeof(test)
    if (t==NULL) {
        perror(""malloc failed"");
        exit(1);
    }
}
</code></pre>

<p>Then call it like this:</p>

<pre><code>t = init_test();
</code></pre>

<p>Also, it's not a good idea to hide a pointer inside of a <code>typedef</code>.  It obscures the fact that you're using a pointer and can be confusing to readers of your code (including yourself).</p>
",3
46634774,46634713,1,"<p>Here is a fixed version. Please note the include of <code>stdio.h</code> as well as fixing the <code>||</code> to <code>&amp;&amp;</code> as well as the space before <code>""%c""</code> to be <code>"" %c""</code>.</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main(void)
{
    char answer;
    printf(""Please enter a letter: "");
    scanf(""%c"", &amp;answer);
    while (answer != 'y' &amp;&amp; answer != 'n')
    {
        printf(""Please enter another letter:"");
        scanf("" %c"", &amp;answer);
    }
    printf(""You entered either yes or no\n"");
    system(""pause"");
    return 0;
}
</code></pre>
",1
46634783,46634713,1,"<pre><code> while (answer!= 'y' || answer!= 'n')
</code></pre>

<p>should be</p>

<pre><code> while (answer!= 'y' &amp;&amp; answer!= 'n')
</code></pre>

<p>as the first condition is always true for <em>every</em> character in you <code>answer</code> variable.</p>
",5
44375860,44375709,2,"<p>scanf will try to write the value it read to the address stored <strong>in</strong> x. When you use the &amp; operator, it will write the value to the address <strong>of</strong> x.</p>

<p>In this case x is a variable on the stack. Variables on the stack are (in C) not automatically initialized, so initially x will probably contain a garbage value. scanf will thus try to write the input value to a garbage address in memory.</p>

<p>This may either cause corruption of the program code or data (which may crash the program or result in unexpected behavior), or cause a segmentation fault (which will cause the OS to abort the program) if the value in x points to memory to which the program is not allowed to write (invalid or read-only memory). What exactly will happen depends on the value of x, which may be a value left over from another program, and this may be different each time you run the program.</p>
",4
44377127,44375709,0,"<p>When you call <code>scanf</code> with the <code>%d</code> conversion specifier, the corresponding argument needs to be an expression that evaluates to the <em>location</em> of an integer object into which <code>scanf</code> will write the input value: <pre><code>scanf( ""%d"", <em>location-expression</em> );</code></pre></p>

<p><em><code>location-expression</code></em> can take on multiple forms.  To read into a single scalar object like <code>x</code>, you could use the expression <code>&amp;x</code>.  </p>

<pre><code>scanf( ""%d"", &amp;x ); // &amp;x evaluates to the location of x
</code></pre>

<p>Or, you could use a pointer variable that's initialized to point to <code>x</code>:</p>

<pre><code>int *p = &amp;x;      // p stores the address of x
scanf( ""%d"", p ); // scanf writes to x *through* p; p == &amp;x
</code></pre>

<p>The <em>expression</em> <code>p</code> is equivalent to the expression <code>&amp;x</code> in this case.  We don't use the <code>&amp;</code> operator on <code>p</code>, because we want write to the address <em>stored</em> in <code>p</code>, not the address <em>of</em> <code>p</code>.  </p>

<p>When you write</p>

<pre><code>scanf( ""%d"", x );
</code></pre>

<p>you're telling <code>scanf</code> to store input to the address <em>stored in <code>x</code></em>.  There are several problems with that:</p>

<ol>
<li><code>x</code> is not explicitly initialized to anything; its value is <em>indeterminate</em>;  </li>
<li>Because of 1, the odds that <code>x</code> contains a value that corresponds to a <em>valid</em> pointer value (that is, the location of an object in your program) are extremely low;</li>
<li>The type of the expression <code>x</code> is <code>int</code>, but <code>%d</code> expects its corresponding argument to have type <code>int *</code> - any modern compiler should yell at you.  </li>
</ol>
",2
45667376,45667327,0,"<p>The for-loop in the <code>power</code> function repeatedly multiplies (and updates) <code>p</code> by <code>base</code>. It does this <code>n</code> times -- <code>i</code> is the counter. If an if-statement were used, then you'd only get up to one multiplication.</p>
",5
43751059,43750991,0,"<p>You allocated memory for <code>nuevo</code> using <code>malloc</code>, but you never allocated memory for <code>sub</code> inside <code>nuevo</code>.</p>

<p>You tried dereferencing it in <code>fscanf</code> and the statement where you set it to <code>NULL</code>.</p>

<p>A simple fix would be to allocate space for <code>sub</code> as</p>

<pre><code>nuevo-&gt;sub = malloc(sizeof(*Sublista));
</code></pre>

<p>Both your errors should disappear now.
Do remember to free sub <em>before</em> you free nuevo.</p>
",1
43751059,43750991,0,"<p>You allocated memory for <code>nuevo</code> using <code>malloc</code>, but you never allocated memory for <code>sub</code> inside <code>nuevo</code>.</p>

<p>You tried dereferencing it in <code>fscanf</code> and the statement where you set it to <code>NULL</code>.</p>

<p>A simple fix would be to allocate space for <code>sub</code> as</p>

<pre><code>nuevo-&gt;sub = malloc(sizeof(*Sublista));
</code></pre>

<p>Both your errors should disappear now.
Do remember to free sub <em>before</em> you free nuevo.</p>
",1
43750915,43750880,2,"<p>The problem is: you are getting the input with <code>scanf(""%s"", input);</code></p>

<p>therefore the condition <code>input == 'a'</code> is the same as ""a"" == 'a' which never meets</p>

<p>you need to get the input as a char using </p>

<pre><code>scanf(""%c"", &amp;input);
</code></pre>

<p>not </p>

<pre><code>scanf(""%s"", input);
</code></pre>
",0
43751648,43750880,6,"<p><strong>the main problem is input stream</strong></p>

<p>for <strong>single char input</strong> in <strong>scanf</strong></p>

<p>we use   <code>scanf( ""%c"", &amp;input);</code></p>

<p>but for whole non-space array of characters / string we use</p>

<p><code>scanf( "" %s"", str);</code></p>

<p>for <strong>string contains whitespace except new line</strong></p>

<p><code>gets_s( str, sizeof( str ) ) ;</code></p>

<p><strong>for your case</strong></p>

<p>correct the following code</p>

<pre><code>scanf( ""%s"", input);
</code></pre>

<p>to</p>

<p><code>scanf( ""%c"", &amp;input);</code></p>

<p><strong>Happy Coding</strong></p>
",1
43750915,43750880,2,"<p>The problem is: you are getting the input with <code>scanf(""%s"", input);</code></p>

<p>therefore the condition <code>input == 'a'</code> is the same as ""a"" == 'a' which never meets</p>

<p>you need to get the input as a char using </p>

<pre><code>scanf(""%c"", &amp;input);
</code></pre>

<p>not </p>

<pre><code>scanf(""%s"", input);
</code></pre>
",0
43751648,43750880,6,"<p><strong>the main problem is input stream</strong></p>

<p>for <strong>single char input</strong> in <strong>scanf</strong></p>

<p>we use   <code>scanf( ""%c"", &amp;input);</code></p>

<p>but for whole non-space array of characters / string we use</p>

<p><code>scanf( "" %s"", str);</code></p>

<p>for <strong>string contains whitespace except new line</strong></p>

<p><code>gets_s( str, sizeof( str ) ) ;</code></p>

<p><strong>for your case</strong></p>

<p>correct the following code</p>

<pre><code>scanf( ""%s"", input);
</code></pre>

<p>to</p>

<p><code>scanf( ""%c"", &amp;input);</code></p>

<p><strong>Happy Coding</strong></p>
",1
43966429,43966386,1,"<p>This creates an array of three integers.  The commas separate the constant-value expressions.  The | is bitwise OR operator.</p>

<pre><code>(10&lt;&lt;16)|3 = (0xA&lt;&lt;16)|3 = (0x000A0000)|0x3 = 0x000A0003
(4&lt;&lt;16)|2 = (0x00040000)|0x2 = 0x00040002
</code></pre>

<p>Your array is { 0x000A0003, 0x00040002, 0xFFFF0002 }</p>
",0
43967860,43966386,0,"<pre><code>unsigned int PointSet[] = { (10&lt;&lt;16) | 3, (4&lt;&lt;16) | 2, 0xFFFF0002 };
         10 = 0000 0000 0000 0000 0000 0000 0000 1010 (Binary)
0x0000000A =    0    0    0    0    0    0    0    A
              0000 0000 0000 1010 0000 0000 0000 0000 (16 bit shift)
0x000A0000 =    0    0    0    A    0    0    0    0
         3 =  0000 0000 0000 0000 0000 0000 0000 0011
0x000A0003 =  0000 0000 0000 1010 0000 0000 0000 0011 (... | 3)

0x00000004 =  0000 0000 0000 0000 0000 0000 0000 0100
0x00040000 =  0000 0000 0000 0100 0000 0000 0000 0000 (16 bit shift)
0x00000002 =  0000 0000 0000 0000 0000 0000 0000 0010 
0x00040002 =  0000 0000 0000 0100 0000 0000 0000 0010 (... | 2)

unsigned int PointSet[] = {0x000A0003, 0x00040002,0xFFFF0002};
</code></pre>
",0
44347981,44347926,2,"<p>I don't think iterating over the characters would be too complicated:</p>

<pre><code>int i = 0;
while (string1[i] != '\0') {
    if (!((string[i] &gt;= 'A' &amp;&amp; string[i] &lt;= 'Z') || string[i] == ' ')) {
        printf(""Not good\n"");
        break;
    }
    ++i;
}
</code></pre>

<p><strong>EDIT:<br/></strong></p>

<p>As Stargateur commented, using <code>isupper</code> would be more elegant:</p>

<pre><code>int i = 0;
while (string1[i] != '\0') {
    if (!(isupper(string[i]) || string[i] == ' ')) {
        printf(""Not good\n"");
        break;
    }
    ++i;
}
</code></pre>
",1
44348019,44347926,4,"<p>Use <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/strspn.html"" rel=""nofollow noreferrer""><code>strspn()</code></a> (or <code>strcspn()</code>), prototype in <code>&lt;string.h&gt;</code></p>

<pre><code>char okchar[] = ""ABC...Z 0123456789"";
if (strspn(input, okchar) == strlen(input)) /* ok */;
</code></pre>
",1
44348610,44347926,1,"<blockquote>
  <p>ASCII characters A-Z or a SPACE.</p>
</blockquote>

<p>Source code's encoding may not be <a href=""https://en.wikipedia.org/wiki/ASCII"" rel=""nofollow noreferrer"">ASCII</a> - this is rare, yet serves as an opportunity to distinguish between source code, say in <a href=""https://en.wikipedia.org/wiki/EBCDIC"" rel=""nofollow noreferrer"">EBCIDIC</a> encoding and the contents of a string, read from external input, which is to be interpreted as ASCII data.</p>

<p>Note: regardless of encoding, the <em>null character</em> has the value <code>'\0'</code>.</p>

<p>This is a time when code <em>should</em> use 32, 65 and 90.  <code>#define ASCII_A 'A'</code> does  not work because the <code>'A'</code> is interpreted in the source code's encoding, which may differ from ASCII.</p>

<pre><code>#define ASCII_SPACE 32
#define ASCII_A 65
#define ASCII_Z 90
</code></pre>

<p>Also no need to test for the <em>null character</em> in the loop.</p>

<pre><code>// return true if `s` contains only ASCII A-Z or space and then the null character
bool test_ASCII_AZ_space(const char *s) {
  while ((*s &gt;= ASCII_A &amp;&amp; *s &lt;= ASCII_Z) || (*s == ASCII_SPACE)) {
    s++;
  }
  return *s == '\0';
}
</code></pre>

<p>To employ portability this using <code>strspn()</code> as suggested by <a href=""https://stackoverflow.com/a/44348019/2410359"">@pmg</a> requires that the pattern string is formed using ASCII values.  Also no need to use <code>strlen()</code> to run down the string again, just check if the value returned by <code>strspn()</code> indexes to the <em>null character</em>.</p>

<pre><code>const char okchar[] = { 32, 65, 66, 67, 68, 69,
  70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
  80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, '\0' };

if (input[strspn(input, okchar)] == '\0') {
  /* ok */;
}
</code></pre>
",0
44348019,44347926,4,"<p>Use <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/strspn.html"" rel=""nofollow noreferrer""><code>strspn()</code></a> (or <code>strcspn()</code>), prototype in <code>&lt;string.h&gt;</code></p>

<pre><code>char okchar[] = ""ABC...Z 0123456789"";
if (strspn(input, okchar) == strlen(input)) /* ok */;
</code></pre>
",1
44348610,44347926,1,"<blockquote>
  <p>ASCII characters A-Z or a SPACE.</p>
</blockquote>

<p>Source code's encoding may not be <a href=""https://en.wikipedia.org/wiki/ASCII"" rel=""nofollow noreferrer"">ASCII</a> - this is rare, yet serves as an opportunity to distinguish between source code, say in <a href=""https://en.wikipedia.org/wiki/EBCDIC"" rel=""nofollow noreferrer"">EBCIDIC</a> encoding and the contents of a string, read from external input, which is to be interpreted as ASCII data.</p>

<p>Note: regardless of encoding, the <em>null character</em> has the value <code>'\0'</code>.</p>

<p>This is a time when code <em>should</em> use 32, 65 and 90.  <code>#define ASCII_A 'A'</code> does  not work because the <code>'A'</code> is interpreted in the source code's encoding, which may differ from ASCII.</p>

<pre><code>#define ASCII_SPACE 32
#define ASCII_A 65
#define ASCII_Z 90
</code></pre>

<p>Also no need to test for the <em>null character</em> in the loop.</p>

<pre><code>// return true if `s` contains only ASCII A-Z or space and then the null character
bool test_ASCII_AZ_space(const char *s) {
  while ((*s &gt;= ASCII_A &amp;&amp; *s &lt;= ASCII_Z) || (*s == ASCII_SPACE)) {
    s++;
  }
  return *s == '\0';
}
</code></pre>

<p>To employ portability this using <code>strspn()</code> as suggested by <a href=""https://stackoverflow.com/a/44348019/2410359"">@pmg</a> requires that the pattern string is formed using ASCII values.  Also no need to use <code>strlen()</code> to run down the string again, just check if the value returned by <code>strspn()</code> indexes to the <em>null character</em>.</p>

<pre><code>const char okchar[] = { 32, 65, 66, 67, 68, 69,
  70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
  80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, '\0' };

if (input[strspn(input, okchar)] == '\0') {
  /* ok */;
}
</code></pre>
",0
44347981,44347926,2,"<p>I don't think iterating over the characters would be too complicated:</p>

<pre><code>int i = 0;
while (string1[i] != '\0') {
    if (!((string[i] &gt;= 'A' &amp;&amp; string[i] &lt;= 'Z') || string[i] == ' ')) {
        printf(""Not good\n"");
        break;
    }
    ++i;
}
</code></pre>

<p><strong>EDIT:<br/></strong></p>

<p>As Stargateur commented, using <code>isupper</code> would be more elegant:</p>

<pre><code>int i = 0;
while (string1[i] != '\0') {
    if (!(isupper(string[i]) || string[i] == ' ')) {
        printf(""Not good\n"");
        break;
    }
    ++i;
}
</code></pre>
",1
44375802,44219796,-1,"<p>You can try the below code!</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
void main(){
char str[2];
int a,b;
scanf(""%s"",str);
a=str[0];
b=str[1];
if(strlen(str)!=2)
printf(""Invalid Input"");
else if(str[0]=='0')
printf(""NO"");
else if((a&gt;47&amp;&amp;a&lt;58)&amp;&amp;(b&gt;47&amp;&amp;b&lt;58))
{
    if(((str[0]=='1')||(str[0]=='6')||(str[0]=='8')||(str[0]=='9'))&amp;&amp;((str[1]=='1')||(str[1]=='6')||(str[1]=='8')||(str[1]=='9')))
    printf(""YES"");
    else
    printf(""NO"");
}
else
printf(""Invalid Input"");

}
</code></pre>
",1
44726106,44725624,2,"<p>Perhaps your input is <a href=""https://en.wikipedia.org/wiki/UTF-8"" rel=""nofollow noreferrer"">UTF-8</a> encoded (which is a good thing, read about <a href=""http://utf8everywhere.org/"" rel=""nofollow noreferrer"">UTF8 everywhere</a>). Only you (or your user) can tell that (but read about <a href=""https://en.wikipedia.org/wiki/Byte_order_mark"" rel=""nofollow noreferrer"">byte order marks)</a>. On Linux, the <a href=""http://man7.org/linux/man-pages/man1/file.1.html"" rel=""nofollow noreferrer"">file(1)</a> command can often guess UTF-8 encoded textual files.</p>

<p>But UTF-8 is a variable byte encoding (some <a href=""https://en.wikipedia.org/wiki/Unicode"" rel=""nofollow noreferrer"">Unicode</a> characters are represented by <em>several</em> bytes, and in almost all C11 implementations, a byte is a <code>char</code>) and is not known by recent <a href=""https://en.wikipedia.org/wiki/C11_(C_standard_revision)"" rel=""nofollow noreferrer"">C11</a> standard. So you need to <em>parse</em> your byte stream as UTF-8. Notice that  <a href=""http://en.cppreference.com/w/c/string/byte/strlen"" rel=""nofollow noreferrer"">strlen</a> no longer gives the number of (or the length in) UTF-8 <em>characters</em> but simply the length in <em>bytes</em>. So you should think of <code>char</code> as meaning a <em>byte</em>, not a Unicode character.</p>

<p>I recommend using some external library for UTF-8 parsing, like <a href=""https://developer.gnome.org/glib/stable/glib-Unicode-Manipulation.html"" rel=""nofollow noreferrer"">Glib Unicode Manipulation</a> functions or the much simpler <a href=""https://www.gnu.org/software/libunistring/"" rel=""nofollow noreferrer"">libunistring</a>. If you are not allowed to use such an external library, you could ignore every <em>multibyte</em> UTF-8 characters by skipping every <code>char</code> whose higher bit is set (but that might be tricky if you want to write portable C code, since some C implementations have <code>char</code> the same as <code>signed char</code> and other implementations have <code>char</code> the same as <code>unsigned char</code>). I don't recommend using <code>wchar_t</code> which is implementation and operating system specific (and different on Linux and Windows).</p>

<blockquote>
  <p>I have tried <code>else if(c=='¡¯')</code></p>
</blockquote>

<p>Your C source file containing the above code chunk is (very likely) also UTF-8 encoded, so the character literal <code>'¡¯'</code> is a multi-byte character literal (like <code>'ab'</code> or <code>'?'</code> also is), actually it is a <em><code>U+2019 RIGHT SINGLE QUOTATION MARK</code></em> and the same as <code>'\342\200\231'</code>, and its interpretation is implementation specific. In general you should want to avoid such multi-byte characters in your C source code (outside of literal strings like <code>""¨¦x?""</code> or comments).</p>
",3
44726353,44725624,0,"<p>A better approach might be to think about what characters are left after you've stripped all the illegal ones. If it's just <code>a-z</code>, and a few others, that's an easy-to-detect range.</p>
",0
44726501,44726492,2,"<p>The problem is here:</p>

<pre><code>for (i = 0; i &gt; 3; i++)
</code></pre>

<p>Try  <code>for (i = 0; i &lt; 3; i++)</code> (while <code>i</code> is less than 3, instead of while <code>i</code> is <em>greater</em> than 3, which is never...)</p>
",1
44736897,44736713,0,"<p><code>x-- -y</code>means ""decrement x with 1 and subtract y from it"". </p>

<p>Your program is</p>

<pre><code>#include &lt;stdio.h&gt;

int main() {

    int n = 4, y = 3, z;
    z = n-- - y;
    printf(""\n%d%d%d"", n, y, z);

}
</code></pre>

<p>The output is</p>

<pre><code>331
</code></pre>

<p>z is 1 at the output because <code>n--</code> equals 4 and y equals 3, therefore z=n-- -y=1. </p>
",0
45762454,45762077,-1,"<pre><code>const howMany = 10;
</code></pre>

<p>This most likely is just the compiler you are using. I suppose it's a safe guard to prevent a segmentation fault. If howMany variable is changed after being used to initialize the array then a seg fault will  will definitely result.A seg fault is when you access something out of bounds.  If you try to change a const variable then the compiler will not let you.By making howMany const this will prevent any such errors.</p>
",0
45762177,45762077,0,"<p>In order to use rand(), you need to include the according lib and then ""plant a rand seed"" : take a look at <a href=""https://www.tutorialspoint.com/c_standard_library/c_function_rand.htm"" rel=""nofollow noreferrer"">C Rand Function</a></p>
",3
45765450,45762077,0,"<p>Visual studio doesn't support variable length arrays.  C is a little tricky, and the compiler/flags you use matters.  For example, if you were to compile with the gcc compiler, using the -std=c99 flag would allow you to run your code with no errors (since -std=c99 supports variable length arrays).</p>

<p>I'm not sure exactly how compilation in Visual Studio works, but that's your problem.  I usually don't like C programming in VS for this reason.  It's much easier for me to use something like Vim, and compile at the command like so that I can specify compiler settings.</p>
",0
45068501,45068135,5,"<p>According to BLUEPIXY's comment, it's quite clear that you call <code>./helloworld1.c</code> instead of <code>./helloworld1</code>. Thereby, your shell is expecting a shell script, but the C source code isn't a valid script (like bash or something like that). Hence, the shell (and not the C compiler) gives you a syntax error which doesn't have anything to do with the lanaguage C at all. Tried it with a file <code>test.c</code> into which I copied exactly the following lines of code:</p>

<p><strong>test.c</strong></p>

<pre><code>#include&lt;stdio.h&gt;
int main()
{
printf(""Hello World"");
return 0;
}
</code></pre>

<p>Then I called <code>chmod +ux test.c</code> to make it an executable, and finally called it in the terminal (which expects a bash script):</p>

<pre><code>./test.c
</code></pre>

<p>yields:</p>

<pre><code>./test.c: line 2: syntax error near unexpected token `('
./test.c: line 2: `int main()'
</code></pre>

<p>The error is at line 2, because the first line <code>#include...</code> starts with a <code>#</code> and is therefore interpreted as a comment.</p>
",4
45107896,45107630,1,"<p>When the length of the string is less than 40, your loop actually runs more than 40 times because <code>i</code> is decremented as long as <code>amount</code> is positive.  As a result, <code>k</code> becomes negative and you end up writing before the start of your <code>digits</code> array.  Reading and writing outside the bounds of an array invokes <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behavior</a>.</p>

<p>Your loop needs to check the value of <code>k</code> to ensure it remains non-negative:</p>

<pre><code>for (i = 0; i &lt; 40 &amp;&amp; k &gt;= 0; i++) {
</code></pre>

<p>A better way to do this would be to decrement <code>k</code> in the loop and increment <code>i</code> only when needed.</p>

<pre><code>for (i = 0, k = 39; k &gt;= 0; k--) {
    if (amount &gt; 0) {
      digits[k] = 0;
      under40 = 1;
      amount--;
      // don't decrement i here
    } else {
        switch (s[i]) {
            ...
        }
        i++;  // increment here instead
    }
    // no need to decrement k here
}
</code></pre>

<p>Also, you can simplify the <code>switch</code> into a single conditional (assuming ASCII encoding where 'A' - 'F' are sequential):</p>

<pre><code>digits[k] = (s[i] &gt;= 10) ? s[i] - 'A' + 10 : s[i] - '0';
</code></pre>
",1
45771743,45771731,1,"<p>Move decimal point to where you want to round up, do round up and move it back.</p>

<pre><code>ceil(value * 1000.0) / 1000.0
</code></pre>
",0
45771764,45771731,0,"<p>You could simply multiply your float value by 1000 and <code>ceil</code> it and then divide by 1000 to achieve your desired value.</p>

<p><code>ceil(data * 1000.0) / 1000.0</code></p>
",0
45711687,45711458,4,"<p>Looks like both/neither for me. It may be insert sort, because you always take first element in unsorted part of array and puts it into correct place in sorted part of array. However, insertion is not done by moving all necessary elements 1 element right and then inserting selected element to correct place (which i would say, standard insert sort does), but instead it swaps selected element with 1 element to the left, until selected element is in correct place.</p>

<p>Because of ""sorted"" and ""unsorted"" part of array, I would say insert sort.</p>

<p>Because of swapping neighbour elements, I would say bubble sort.</p>

<p>However, it seems more like insert sort to me. If instead of (inefficient) swapping, you would instead only move left element to right, and only finally write selected element to left (final, correct position of selected element), It would be a nice insert sort</p>
",1
45712205,45711458,0,"<p>This is a <code>Bubble Sort</code>algorithm. Only difference between <code>Bubble Sort</code> algorithm and your algorithm is that <code>Bubble Sort</code> algorithm sorts the rightmost elements first and then so on and your algorithm is sorting the leftmost elements first.</p>

<p><strong>Analysis:</strong></p>

<p>Your Algo:</p>

<pre><code>&lt;---------
 &lt;--------
  &lt;-------
   &lt;------
    &lt;-----
     &lt;----
      &lt;---
       &lt;--
        &lt;-
         &lt;
</code></pre>

<p>Bubble Sort Algo:</p>

<pre><code>------&gt;
-----&gt;
----&gt;
---&gt;
--&gt;
-&gt;
&gt;
</code></pre>
",2
45712234,45711458,2,"<p>I would say closer to insertion sort as you create sorted chunks by finding the first misfit. Rather than iterating whole array and pushing the largest element to the end (like in bubble sort)</p>

<p>It is closer to the standard version of insertion sort, where you swap elements until you find the right place in the sorted chunk. However, after you insert your element you start your index from wrong index, as it has created a sorted sub array.</p>

<p>This helps visualize the two sorting algorithms:
<a href=""https://visualgo.net/bn/sorting"" rel=""nofollow noreferrer"">https://visualgo.net/bn/sorting</a></p>
",0
46093871,46092470,2,"<p>I believe that in C you cannot do this. Actually the compiler will not even bother to ""cry"" as this is syntactically correct. But on the other hand this is wrong and won't execute. Personally I pay very much attention at mistakes that compiler accepts but disrupts the execution.
Generally speaking you have to declare this function above main , with the proper argument , character in this situation. Because C will look for the declaration of this particular function and she won't find it.
In C++ it's easy as you can overload functions and compiler would understand just from the type of arguments.</p>
",0
46092578,46092470,8,"<p><a href=""http://port70.net/~nsz/c/c11/n1570.html#6.2.7p2"" rel=""noreferrer"">C11 6.2.7p2</a></p>

<blockquote>
  <p>All declarations that refer to the same object or function shall have <strong>compatible type</strong>; otherwise, <strong>the behavior is undefined</strong>. </p>
</blockquote>

<p><code>void abcd(int, char);</code> is an external declaration that says <code>abcd</code> takes <code>int</code> and <code>char</code> as arguments. It is not compatible with <code>extern void abcd(char);</code>, which says that the same function now takes just one <code>char</code> as an argument.</p>

<p>If I read the standard correctly, this is not a constraint error, so a compiler need not produce even a <em>warning</em> for this. It is still broken and wrong.</p>
",2
46092580,46092470,2,"<p>sorry I overlooked the C instead C++ tag (C++ stuff removed). I think this should do in C:</p>

<pre><code>void abcd_c(char x){};
void abcd_i(int x){};
int main(int argc, char *argv[])
 {
 #define abcd abcd_c
 abcd('t');
 abcd('e');
 abcd('s');
 abcd('t');
 #undef abcd

 #define abcd abcd_i
 abcd(123);
 #undef abcd
 }
</code></pre>

<p>You just use <code>#define/#undef</code> to select wanted behavior in parts of code</p>
",0
46098159,46098044,1,"<p><code>scanf(""%f"", &amp;a);</code> is considered unsafe by the Visual Studio compiler and they rather cheekily schedule the function for deprecation. (Although ISO have no such plans.) Really they want you to use <code>scanf_s</code> instead, as that's less likely to mess up your memory.</p>

<p>You can disable this warning by following the compiler message: i.e. <code>#define</code> <code>_CRT_SECURE_NO_WARNINGS</code>.</p>

<p>The irony here is the compiler permits your non-standard <code>main()</code> function without a twitch! Do consider using the more portable</p>

<p><code>int main()</code></p>

<p>which has been required since and including C99.</p>
",3
46099586,46098044,0,"<p>Visual Studio 2015 is stricter about deprecated functions than 2010 was.</p>

<p>Rather than just advising you that you need to do something about your use of <code>scanf</code>, as Visual Studio 2010 did, it now FORCES you to do something about it.</p>

<p>You need to switch to <code>scanf_s</code> or use _CRT_SECURE_NO_WARNINGS.</p>
",0
46107717,46106533,-1,"<p>the following proposed code:</p>

<ol>
<li>cleanly compiles</li>
<li>performs the desired functionality</li>
<li>properly checks for errors</li>
<li>does not use well known system function names for local functions
however, <code>read()</code> and <code>write()</code> are prototyped in <code>unistd.h</code> so not a direct problem with the code as that header file is not included.</li>
</ol>

<p>the reason it did not work (well there are a few reasons)</p>

<p>most notably, the compiler will output several warning and error messages.
It is a wonder that it ever ran.  </p>

<p>When compiling, always enable all the warnings, then fix those warnings. </p>

<p>(for <code>gcc</code>, at a minimum use: <code>-wall -wextra -pedantic -std=gnu11</code>  I also use: `-Wconversion -Wmissing-prototypes -ggdb ) </p>

<p>and now the proposed code:</p>

<pre><code>#include &lt;stdio.h&gt;   // perror(), fopen(), FILE, fseek(), fread(), printf(), fclose()
#include &lt;stdlib.h&gt;  // exit(), EXIT_FAILURE
//#include &lt;string.h&gt;

struct data
{
    int numero;
};


// prototypes
void myRead( void );
void myWrite( void );


void myRead()
{

    FILE *arquivo = fopen(""/tmp/URL_NEW"", ""r"");
    if( !arquivo )
    {
        perror( ""fopen to read URL_NEW failed"" );
        exit( EXIT_FAILURE );
    }

    // implied else, fopen successful

    struct data dataTemp;

    // the following 'fseek()' skips over the first record
    if( 0 != fseek(arquivo, sizeof(struct data), SEEK_SET) )
    {
        perror( ""fseek failed"" );
        exit( EXIT_FAILURE );
    }

    // implied else, fseek successful


    // note: the returned value and the third parameter must match
    while ( 1 == fread(&amp;dataTemp, sizeof(struct data), 1, arquivo))
    {
        printf(""\nNumber = "");
        printf(""%d\n"", dataTemp.numero);
    }

    fclose(arquivo);
} // end function: myRead()


void myWrite()
{
    struct data dataTemp;
    FILE *arquivo = fopen(""/tmp/URL_NEW"", ""w"");
    if( !arquivo )
    {
        perror( ""fopen to write URL_NEW failed"" );
        exit( EXIT_FAILURE );
    }

    // implied else, fopen successful

    for(int i=1; i &lt; 2000;i++)
    {
        dataTemp.numero = i;

        // note: the returned value and the third parameter must match
        if( 1 != fwrite(&amp;dataTemp, sizeof(struct data), 1, arquivo) )
        {
            perror( ""fwrite failed"" );
            exit( EXIT_FAILURE );
        }

        // implied else, fwrite successful
    }

    fclose(arquivo);
}

int main( void )
{
    myWrite();
    myRead();
}
</code></pre>

<p>a sample of the early and late output:</p>

<pre><code>Number = 2 

Number = 3

Number = 4

....

Number = 1996

Number = 1997

Number = 1998

Number = 1999
</code></pre>
",3
46131893,46131851,2,"<p>You could try <code>c = (a - b)/10000;</code>
That will discard the last 4 digits without rounding up.</p>
",1
46942209,46942193,4,"<p>you incremented <code>ptr</code>'s value. It still resides in the same place in memory. <code>&amp;ptr</code> tells you its address.  This is no different than doing something like <code>a++</code>.  If you print out <code>a</code>'s value, it will now be 6, but if you print out the address of <code>a</code> with <code>printf(""%p\n"", (void*)&amp;a);</code>, it will be the same before and after the increment.</p>
",16
46942279,46942193,3,"<ol>
<li><p>5 is the value of <code>a</code> and <code>&amp;a</code> is the address of <code>a</code>.</p></li>
<li><p><code>ptr = &amp;a</code> means address of <code>a</code> equals the value of <code>ptr</code>.</p></li>
<li><p><code>&amp;ptr</code> is the address of <code>ptr</code>.</p></li>
</ol>

<p>You can think of <code>ptr</code> as a box that can hold an address as it's value.</p>

<p>When you increment <code>ptr</code> you change the address held inside the box i.e. <code>ptr</code>; not the address of the box itself.  </p>
",0
46636586,46636420,0,"<p>When you enter a non-decimal character by using <code>%d</code>, <code>scanf()</code> return 0 (error) and don't set <code>n</code>. When you print it, it's a non-initialized variable, then it prints random value.</p>

<p>If you want to counter the problem, you can get the user's input as <code>string</code>, check if it's a correct number, and then convert it to <code>int</code>:</p>

<pre><code>#include &lt;math.h&gt;

int main()
{
    int previous = 0; // previous term in sequence
    int current = 1; // current term in sequence
    int next; // next term in sequence
    int n; // to catch str conversion
    int i = -1; // for incrementation
    char str[10]; // user input
    int result; // nth term

    printf(""Please enter the number of the term in the fibonacci sequence you want to find\n"");
    scanf(""%s"", &amp;str); // Catch input as string
    while (str[++i])
        if (!isdigit(str[i])) // Check if each characters is a digit
            return -1;
    n = atoi(str); // Convert string to int

    // Rest of the function
</code></pre>
",1
47484856,47484733,0,"<p>You can read the number as a string</p>

<pre><code>char your_string[10];
fgets(your_string,sizeof(your_string),stdin);

for(i=0;i&lt;strlen(your_string)-1;i++){
    if(your_string[i]=='9') your_string[i] == '7';
}

int x = atoi(your_string);
</code></pre>

<p>(if you use fgets use i &lt; strlen(your_string) - 1 because the last char is '\n' and include string.h for strlen)</p>
",2
47969257,47969074,2,"<p>See <a href=""http://www.cplusplus.com/reference/cstdio/scanf/"" rel=""nofollow noreferrer"">the documentation for <em>scanf</em></a></p>

<blockquote>
  <p>On success, the function returns the number of items of the argument list successfully filled.</p>
</blockquote>

<p>Replace this part:</p>

<pre><code>if((scanf(""%c"",&amp;oper))=='\n')
    break;
</code></pre>

<p>with:</p>

<pre><code>if(scanf(""%c"",&amp;oper) &amp;&amp; oper=='\n')
    break;
</code></pre>

<p>This:</p>

<ul>
<li>checks whether <code>scanf()</code> has put any value into <code>oper</code></li>
<li>if yes then it checks if the value is equal to <code>\n</code></li>
</ul>
",1
46937168,46937084,0,"<p>The <code>gets</code> function is already populating <code>x</code> with a string specified by the user, so no need to return anything from <code>SchrijfString</code> or to assign anything to <code>x</code> back in main.  Your function prototypes don't match the definitions.  They need to be the same.</p>

<p>Also, <code>gets</code> is deprecated because it is unsafe.  Use <code>fgets</code> instead.</p>

<pre><code>void SchrijfString(char x[], int len);
void  LeesString(char x[]);

int main(void)
{
    char x[60];
    SchrijfString(x, sizeof(x));
    LeesString(x);
    return 0;
}

void SchrijfString(char x[], int len)
{
    printf(""geef een string in: \n"");
    fgets(x, len, stdin);
}
</code></pre>
",2
46942286,46942250,0,"<p>In fact there is code inbetween your declarations, the offending line being <code>arraySize = list-&gt;numElements</code>. You can move that line further down, after <code>LinkedListNode *curr</code> declaration or merge it with the declaration of <code>arraySize</code> the line before, like this: <code>int arraySize = list-&gt;numElements</code>.</p>
",0
47530390,47522076,0,"<p>Actually, the answer was simple and provided ASAP by Steve Summit:</p>

<pre><code>if (userInput == 4||6)
</code></pre>

<p>doesn't do the expected. The correct would be:</p>

<pre><code>if (userInput == 4 || userInput == 6)
</code></pre>

<p>IMHO, you should now ask:</p>

<p><strong>So, if <code>if (userInput == 4||6)</code> is wrong &ndash; why didn't the compiler complain?</strong> (I assume it didn't although I didn't try.)</p>

<p>There are two reasons for this and IMHO you should know these reasons (as you did not yet learn them from your C book).</p>

<ol>
<li>There are no special boolean types in C. Instead, every integer &ne; 0 is counted as <em>TRUE</em> but 0 is counted as <em>FALSE</em>. Hence, logic operators compute integers, comparison operators as well.</li>
</ol>

<p>Thus, <code>userInput == 4 || 6</code> is just a valid arithmetic expression and it has a precise result.</p>

<ol start=""2"">
<li>To understand how <code>userInput == 4 || 6</code> is evaluated you need to know about <strong>C operator associativity and precedence</strong> also. Both terms can be found by google very easy (because they probably are searched quite often (at least periodically by me)).</li>
</ol>

<p>I recommend the reference table of <a href=""http://en.cppreference.com/"" rel=""nofollow noreferrer"">cppreference.com</a>: <a href=""http://en.cppreference.com/w/c/language/operator_precedence"" rel=""nofollow noreferrer""><strong>C Operator Precedence</strong></a>.</p>

<p>Studying this table, we see:</p>

<ol>
<li><p>operators <code>==</code> and <code>||</code> are both evaluated from left to right.</p></li>
<li><p>operator <code>==</code> has lower precedence as operator <code>||</code>, i.e. <code>==</code> binds stronger, i.e. <code>==</code> is computed first.</p></li>
</ol>

<p>Hence, it's starting with two cases:</p>

<ol>
<li><p><code>userInput</code> contains value <code>4</code>: &rArr; <code>userInput == 4</code>: <code>1</code></p></li>
<li><p><code>userInput</code> contains anything else: &rArr; <code>userInput == 4</code>: <code>0</code></p></li>
</ol>

<p>These first results are applied to the second operator <code>|| 6</code>:</p>

<ol>
<li><p><code>1 || 6</code>: <code>1</code> (Remember, logic-or operator just checks whether at least one argument is not 0.)</p></li>
<li><p><code>0 || 6</code>: <code>1</code></p></li>
</ol>

<p>It shows that <em>anything</em> <code>|| 6</code> results in <code>1</code>.</p>

<p>That's why it was printing the tour menu regardless what you input.</p>

<hr>

<p>Don't forget: as well as in school math, it is allowed to use parentheses <code>()</code> to override associativity and precedence. So, if you are in doubt just put parentheses around. Normally, they don't have any impact on run-time performance (at least, not as long as you don't change the order of operator evaluation due to this).</p>
",0
48001111,48000768,1,"<p><em>edit</em> You don't want to use recursion because the <code>freeTree</code> function doesn't take a <code>Node</code> argument. In this case, you can remove that restriction by creating another function that is recursive, called initially by <code>freeTree</code>.</p>

<pre><code>void freeTree(Tree* tree, bool TreeContent){
    if(tree-&gt;root != NULL){
        freeNode(tree-&gt;root);
        tree-&gt;root = NULL;
    }
}            
</code></pre>

<p>The new <code>freeNode</code> could look like</p>

<pre><code>void freeNode(Node *node) {
    if (node-&gt;left) freeNode(node-&gt;left);
    if (node-&gt;right) freeNode(node-&gt;right);
    free(node);
}
</code></pre>

<p>Note that <code>freeNode</code> intent is to free the whole tree (otherwise the parent element's left or right [or root] would have to be set to NULL).</p>
",5
48001810,48000768,1,"<p>Your requirement is that you don't want to use recursion. </p>

<p>Any kind of traversal is not possible in <code>O(n)</code> time without use of a stack/queue (implicitly or explicitly). So we will use a stack (made using an array) and use it to delete all the nodes. </p>

<p>I understand that you have the size of the BST known, so you can create an array of appropriate size as - </p>

<pre><code>struct Node* stack[bst-&gt;size];
int top = -1;
</code></pre>

<p>This stack will hold all the elements to be processed.</p>

<p>We will first add the root to the stack - </p>

<pre><code>if(bst-&gt;root)
    stack[++top] = bst-&gt;root;
</code></pre>

<p>Now we need to process all the nodes in the tree using a loop - </p>

<pre><code>while(top&gt;=0){
    //Pop one node - 
    struct Node* node = stack[top--];
    //Add its children to the stack;
    if(node-&gt;left)
        stack[++top] = node-&gt;left;
    if(node-&gt;right)
        stack[++top] = node-&gt;right;
    // Now free the node as 
    free(node);
}
</code></pre>

<p>That is all, one by one each node will be added to the stack and the stack will become empty when all the nodes are done. </p>

<p>Also as a side note, in your insert function you need to do <code>bst-&gt;size++</code> in the <code>if(bst-&gt;root == NULL)</code> branch. Else your size will be one less than actual number of nodes. </p>
",2
